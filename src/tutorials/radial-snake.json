[
  {
    "repoUrl": "https://DAB0mB@github.com/DAB0mB/radial-snake",
    "branchName": "master",
    "historyBranchName": "master-history",
    "releases": [
      {
        "releaseVersion": "0.1.6",
        "releaseDate": "2018-06-21 10:10:56 +0800",
        "tagName": "master@0.1.6",
        "tagRevision": "133e7b8b38dd15aab45f74e613be8f97233a134f",
        "historyRevision": "fabd14068d64ff6e8c7e5cca23a2055c333dee38",
        "changesDiff": "",
        "manuals": [
          {
            "manualTitle": "How to implement a game engine in JavaScript and build a Tron-style game",
            "stepRevision": "08b88f5a9d7b2d3ba4c8a67a1433218ef6a6a3a5",
            "manualView": "![snake-demo-full-small](https://cloud.githubusercontent.com/assets/7648874/21073892/ae331a8a-bed2-11e6-9141-9554f9bb808b.gif)\n\nThis tutorial will guide you through the following steps:\n\n- [**Step 1**](https://github.com/DAB0mB/radial-snake/blob/master/.tortilla/manuals/views/step1.md) - Creating a server\n- [**Step 2**](https://github.com/DAB0mB/radial-snake/blob/master/.tortilla/manuals/views/step2.md) - Creating a game engine basis\n- [**Step 3**](https://github.com/DAB0mB/radial-snake/blob/master/.tortilla/manuals/views/step3.md) - Creating a splash screen using a keyframe animation engine\n- [**Step 4**](https://github.com/DAB0mB/radial-snake/blob/master/.tortilla/manuals/views/step4.md) - Creating a main menu screen using a font engine\n- [**Step 5**](https://github.com/DAB0mB/radial-snake/blob/master/.tortilla/manuals/views/step5.md) - Creating a snake and related geometry shapes\n- [**Step 6**](https://github.com/DAB0mB/radial-snake/blob/master/.tortilla/manuals/views/step6.md) - Creating a complex game screen with multiple layers\n- [**Step 7**](https://github.com/DAB0mB/radial-snake/blob/master/.tortilla/manuals/views/step7.md) - Bonus! Re-implementing geometry in C++\n\nMake sure you have the following software installed:\n\n- NodeJS with an ECMAScript 2015 support (v6.0.0 and above).\n- Any web-browser which supports ECMAScript 2015, with a preference for Google Chrome.\n\n> The final project is a hybrid of C++ and JavaScript. A JavaScript **only** version of this tutorial is available [here](https://github.com/DAB0mB/radial-snake/tree/master%40step6%400.1.3).\n\nThis tutorial is mostly based on pure JavaScript, so people can have a deeper understanding of the language and its dynamics. In addition, this tutorial makes a great practice on how to build a nice architecture for complex systems, which can then be expanded and maintained with ease. Yes, it is specifically designed for games, but I truly believe that video games can easily get messed up if not planned and designed properly in terms of object oriented relationships. They are naturally more complicated then any web-app you gonna see out there, so if you can create a game engine and understand its flow, creating a web-app would be a piece of cake for you. By the end of this tutorial, your general sense for programming should be enhanced greatly.\n\nSo hopefully that I got you pumped up by now, let's get started!"
          },
          {
            "manualTitle": "Step 1: Creating a server",
            "stepRevision": "1aed2194c509617dbe79447e2615aa34728262bc",
            "manualView": "The first thing we will learn to do would be creating a server so we can serve our assets. We will be using [HapiJS](https://hapijs.com/) to build a REST API, although this step can be implemented with any library you'd want, like [ExpressJS](http://expressjs.com/) or [Connect](https://www.senchalabs.github.com/connect) etc. Let's install it then:\n\n    $ npm install hapi --save\n\nWe will start by setting up a basis for our server, and we will expand it as we go further in this step. A general boiler plate should look like so:\n\n[{]: <helper> (diffStep 1.2)\n\n#### [Step 1.2: Add server basis](https://github.com/DAB0mB/radial-snake/commit/8ff8805)\n\n##### Added server.js\n```diff\n@@ -0,0 +1,36 @@\n+â”Š  â”Š 1â”Šconst Hapi = require(\"hapi\");\n+â”Š  â”Š 2â”Š\n+â”Š  â”Š 3â”Šlet port = 8000;\n+â”Š  â”Š 4â”Š\n+â”Š  â”Š 5â”Š// Initialize a new server\n+â”Š  â”Š 6â”Šlet server = new Hapi.Server();\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Šserver.connection({ port: process.env.PORT || port });\n+â”Š  â”Š 9â”Š\n+â”Š  â”Š10â”Š// Report each response made\n+â”Š  â”Š11â”Šserver.ext(\"onPreResponse\", (req, rep) => {\n+â”Š  â”Š12â”Š  let res = req.response;\n+â”Š  â”Š13â”Š\n+â”Š  â”Š14â”Š  console.log(\"Outcoming response:\");\n+â”Š  â”Š15â”Š  console.log(`in: ${new Date}`);\n+â”Š  â”Š16â”Š  console.log(`to: ${req.info.remoteAddress}`);\n+â”Š  â”Š17â”Š  console.log(`method: ${req.method}`);\n+â”Š  â”Š18â”Š  console.log(`url: ${req.url.path}`);\n+â”Š  â”Š19â”Š  console.log(`status: ${res.statusCode || res.output.statusCode}`);\n+â”Š  â”Š20â”Š  console.log();\n+â”Š  â”Š21â”Š\n+â”Š  â”Š22â”Š  rep.continue();\n+â”Š  â”Š23â”Š});\n+â”Š  â”Š24â”Š\n+â”Š  â”Š25â”Š// Print message once started\n+â”Š  â”Š26â”Šserver.start((err) => {\n+â”Š  â”Š27â”Š  if (err) throw err;\n+â”Š  â”Š28â”Š\n+â”Š  â”Š29â”Š  console.log();\n+â”Š  â”Š30â”Š  console.log(\"---------- -------- ------ ---- --\");\n+â”Š  â”Š31â”Š  console.log(\"----- ---- --- -- -\");\n+â”Š  â”Š32â”Š  console.log(`Server running at ${port}`);\n+â”Š  â”Š33â”Š  console.log(\"----- ---- --- -- -\");\n+â”Š  â”Š34â”Š  console.log(\"---------- -------- ------ ---- --\");\n+â”Š  â”Š35â”Š  console.log();\n+â”Š  â”Š36â”Š});ðŸš«â†µ\n```\n\n[}]: #\n\nWe simply initialize a new server which will connect to port `8000` by default, unless we defined an environment variable called `PORT`. Once the server is started, and whenever there is an outcoming response, a message will be printed to the console.\n\n> More information and configuration options regards HapiJS's API can be found in this [here](https://hapijs.com/).\n\nNow that the basis is ready, we want a convenient way to launch it. Repetitive scripts are usually defined in the `package.json` file under the `scripts` field. To start the server, we gonna create a simple script called `serve`:\n\n[{]: <helper> (diffStep 1.3)\n\n#### [Step 1.3: Add serve npm script](https://github.com/DAB0mB/radial-snake/commit/6e7d691)\n\n##### Changed package.json\n```diff\n@@ -6,6 +6,9 @@\n â”Š 6â”Š 6â”Š    \"url\": \"https://DAB0mB@github.com/DAB0mB/radial-snake.git\"\n â”Š 7â”Š 7â”Š  },\n â”Š 8â”Š 8â”Š  \"private\": true,\n+â”Š  â”Š 9â”Š  \"scripts\": {\n+â”Š  â”Š10â”Š    \"serve\": \"node server.js\"\n+â”Š  â”Š11â”Š  },\n â”Š 9â”Š12â”Š  \"dependencies\": {\n â”Š10â”Š13â”Š    \"hapi\": \"^16.0.1\"\n â”Š11â”Š14â”Š  }\n```\n\n[}]: #\n\nTo run this script, we will simply need to type the following:\n\n    $ npm run serve\n\nThis will run our server, and you should see the following message printed to the console:\n\n```\n---------- -------- ------ ---- --\n----- ---- --- -- -\nServer running at 8000\n----- ---- --- -- -\n---------- -------- ------ ---- --\n```\n\n> As for now, nothing happens, because we didn't define any handlers for HTTP requests. I will get to it in a bit, stay with me.\n\nThe main disadvantage of starting a server directly with node is that we have no listeners for changes in our files, so if we want the served files to be updated, we will have to restart our server anytime we make a change. To avoid that, we gonna use [nodemon](https://nodemon.io/), which is a simple utility that can monitor changes is source files and automatically restart our server. To install it, type the following:\n\n    $ sudo npm install nodemon -g\n\nNow that we have it, we will need to update our `serve` npm script to use `nodemon` instead of `node`:\n\n[{]: <helper> (diffStep 1.4)\n\n#### [Step 1.4: Change serve npm script to use nodemon](https://github.com/DAB0mB/radial-snake/commit/a238294)\n\n##### Changed package.json\n```diff\n@@ -7,7 +7,7 @@\n â”Š 7â”Š 7â”Š  },\n â”Š 8â”Š 8â”Š  \"private\": true,\n â”Š 9â”Š 9â”Š  \"scripts\": {\n-â”Š10â”Š  â”Š    \"serve\": \"node server.js\"\n+â”Š  â”Š10â”Š    \"serve\": \"nodemon server.js\"\n â”Š11â”Š11â”Š  },\n â”Š12â”Š12â”Š  \"dependencies\": {\n â”Š13â”Š13â”Š    \"hapi\": \"^16.0.1\"\n```\n\n[}]: #\n\nThe basis for our server is pretty much complete. From now on we gonna build stuff on top of it and extend our server. I'd like to add a small attachment to our server. I want that the IP address of the current computer will be printed to the console once the server is started. For this, we first gonna create a helper which we gonna call `ip_grabber`:\n\n[{]: <helper> (diffStep 1.5)\n\n#### [Step 1.5: Add ip_grabber helper](https://github.com/DAB0mB/radial-snake/commit/8ff1d1c)\n\n##### Added helpers&#x2F;ip_grabber.js\n```diff\n@@ -0,0 +1,23 @@\n+â”Š  â”Š 1â”Šconst Os = require(\"os\");\n+â”Š  â”Š 2â”Š\n+â”Š  â”Š 3â”Š// Grab local IP address of which the NodeJS process runs on\n+â”Š  â”Š 4â”Šfunction local() {\n+â”Š  â”Š 5â”Š  let interfaces = Os.networkInterfaces();\n+â”Š  â”Š 6â”Š  let addresses = [];\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Š  for (let k in interfaces) {\n+â”Š  â”Š 9â”Š    for (let k2 in interfaces[k]) {\n+â”Š  â”Š10â”Š      let address = interfaces[k][k2];\n+â”Š  â”Š11â”Š\n+â”Š  â”Š12â”Š      if (address.family == \"IPv4\" && !address.internal) {\n+â”Š  â”Š13â”Š        addresses.push(address.address);\n+â”Š  â”Š14â”Š      }\n+â”Š  â”Š15â”Š    }\n+â”Š  â”Š16â”Š  }\n+â”Š  â”Š17â”Š\n+â”Š  â”Š18â”Š  return addresses[0];\n+â”Š  â”Š19â”Š}\n+â”Š  â”Š20â”Š\n+â”Š  â”Š21â”Šmodule.exports = {\n+â”Š  â”Š22â”Š  local\n+â”Š  â”Š23â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nThis module simply goes through the available network interfaces and grabs the IP address of the default gateway using the `os` module. Now that we have it, let's import it in the server's entry file and use the `local` method to grab the IP address and report it once the server is started:\n\n[{]: <helper> (diffStep 1.6)\n\n#### [Step 1.6: Print IP address once server is started](https://github.com/DAB0mB/radial-snake/commit/18ed984)\n\n##### Changed server.js\n```diff\n@@ -1,5 +1,7 @@\n â”Š1â”Š1â”Šconst Hapi = require(\"hapi\");\n+â”Š â”Š2â”Šconst IpGrabber = require(\"./helpers/ip_grabber\");\n â”Š2â”Š3â”Š\n+â”Š â”Š4â”Šlet localIp = IpGrabber.local();\n â”Š3â”Š5â”Šlet port = 8000;\n â”Š4â”Š6â”Š\n â”Š5â”Š7â”Š// Initialize a new server\n```\n```diff\n@@ -29,7 +31,7 @@\n â”Š29â”Š31â”Š  console.log();\n â”Š30â”Š32â”Š  console.log(\"---------- -------- ------ ---- --\");\n â”Š31â”Š33â”Š  console.log(\"----- ---- --- -- -\");\n-â”Š32â”Š  â”Š  console.log(`Server running at ${port}`);\n+â”Š  â”Š34â”Š  console.log(`Server running at ${localIp}:${port}`);\n â”Š33â”Š35â”Š  console.log(\"----- ---- --- -- -\");\n â”Š34â”Š36â”Š  console.log(\"---------- -------- ------ ---- --\");\n â”Š35â”Š37â”Š  console.log();\n```\n\n[}]: #\n\nBy now you should have the following message printed to the console once you start the server:\n\n```\n---------- -------- ------ ---- --\n----- ---- --- -- -\nServer running at 95.221.122.30:8000\n----- ---- --- -- -\n---------- -------- ------ ---- --\n```\n\n> Instead of `95.221.122.30` you should have the IP address which is right for you.\n\nNow comes the most important part - handling HTTP requests! Because what does a server worth if it doesn't know how to handle anything? When using `HapiJS`, we can separate extensions to our server in different modules, and eventually register them as plug-ins. So the first plug-in is gonna be the routes batch for the endpoints - it will take care of serving file requests as is, and basically turning local directories into public ones. This is useful because our game is going to be dependent on many assets like textures, images, fonts, and so on... But before I go into the implementation part we first need to install a couple of libraries which will help us with the task. The first one is going to be `async`, which will take care of managing the control flow of asynchronous code:\n\n    $ npm install async --save\n\nAnd the second library is going to be `inert`, which is a `HapiJS` plug-in which will give us the ability to serve files from local directories:\n\n    $ npm install inert --save\n\nNow that we're set, let's implement the `endpoints` routes batch:\n\n[{]: <helper> (diffStep 1.8)\n\n#### [Step 1.8: Add endpoints routes](https://github.com/DAB0mB/radial-snake/commit/9c22408)\n\n##### Added routes&#x2F;endpoints.js\n```diff\n@@ -0,0 +1,80 @@\n+â”Š  â”Š 1â”Šconst Pack = require(\"../package.json\");\n+â”Š  â”Š 2â”Š\n+â”Š  â”Š 3â”Šregister.attributes = {\n+â”Š  â”Š 4â”Š  name: \"endpoints\",\n+â”Š  â”Š 5â”Š  version: Pack.version\n+â”Š  â”Š 6â”Š};\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Šfunction register(server, options, next) {\n+â”Š  â”Š 9â”Š  // Scripts endpoint\n+â”Š  â”Š10â”Š  server.route({\n+â”Š  â”Š11â”Š    method: \"GET\",\n+â”Š  â”Š12â”Š    path: \"/scripts/{path*}\",\n+â”Š  â”Š13â”Š    handler: {\n+â”Š  â”Š14â”Š      directory: {\n+â”Š  â”Š15â”Š        path: \"./resources/scripts/\"\n+â”Š  â”Š16â”Š      }\n+â”Š  â”Š17â”Š    }\n+â”Š  â”Š18â”Š  });\n+â”Š  â”Š19â”Š\n+â”Š  â”Š20â”Š  // Style-sheets endpoint\n+â”Š  â”Š21â”Š  server.route({\n+â”Š  â”Š22â”Š    method: \"GET\",\n+â”Š  â”Š23â”Š    path: \"/styles/{path*}\",\n+â”Š  â”Š24â”Š    handler: {\n+â”Š  â”Š25â”Š      directory: {\n+â”Š  â”Š26â”Š        path: \"./resources/styles/\"\n+â”Š  â”Š27â”Š      }\n+â”Š  â”Š28â”Š    }\n+â”Š  â”Š29â”Š  });\n+â”Š  â”Š30â”Š\n+â”Š  â”Š31â”Š  // Libraries endpoint\n+â”Š  â”Š32â”Š  server.route({\n+â”Š  â”Š33â”Š    method: \"GET\",\n+â”Š  â”Š34â”Š    path: \"/libs/{path*}\",\n+â”Š  â”Š35â”Š    handler: {\n+â”Š  â”Š36â”Š      directory: {\n+â”Š  â”Š37â”Š        path: \"./resources/libs/\"\n+â”Š  â”Š38â”Š      }\n+â”Š  â”Š39â”Š    }\n+â”Š  â”Š40â”Š  });\n+â”Š  â”Š41â”Š\n+â”Š  â”Š42â”Š  // Images endpoint\n+â”Š  â”Š43â”Š  server.route({\n+â”Š  â”Š44â”Š    method: \"GET\",\n+â”Š  â”Š45â”Š    path: \"/images/{path*}\",\n+â”Š  â”Š46â”Š    handler: {\n+â”Š  â”Š47â”Š      directory: {\n+â”Š  â”Š48â”Š        path: \"./resources/images/\"\n+â”Š  â”Š49â”Š      }\n+â”Š  â”Š50â”Š    }\n+â”Š  â”Š51â”Š  });\n+â”Š  â”Š52â”Š\n+â”Š  â”Š53â”Š  // Textures endpoint\n+â”Š  â”Š54â”Š  server.route({\n+â”Š  â”Š55â”Š    method: \"GET\",\n+â”Š  â”Š56â”Š    path: \"/textures/{path*}\",\n+â”Š  â”Š57â”Š    handler: {\n+â”Š  â”Š58â”Š      directory: {\n+â”Š  â”Š59â”Š        path: \"./resources/assets/textures/\"\n+â”Š  â”Š60â”Š      }\n+â”Š  â”Š61â”Š    }\n+â”Š  â”Š62â”Š  });\n+â”Š  â”Š63â”Š\n+â”Š  â”Š64â”Š  // Fonts endpoint\n+â”Š  â”Š65â”Š  server.route({\n+â”Š  â”Š66â”Š    method: \"GET\",\n+â”Š  â”Š67â”Š    path: \"/fonts/{path*}\",\n+â”Š  â”Š68â”Š    handler: {\n+â”Š  â”Š69â”Š      directory: {\n+â”Š  â”Š70â”Š        path: \"./resources/assets/fonts/\"\n+â”Š  â”Š71â”Š      }\n+â”Š  â”Š72â”Š    }\n+â”Š  â”Š73â”Š  });\n+â”Š  â”Š74â”Š\n+â”Š  â”Š75â”Š  next();\n+â”Š  â”Š76â”Š}\n+â”Š  â”Š77â”Š\n+â”Š  â”Š78â”Šmodule.exports = {\n+â”Š  â”Š79â”Š  register\n+â”Š  â”Š80â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nThis module actually represents a classic structure of a `HapiJS` plug-in. It should export a `name` for debugging proposes, a `version`, and a `register` function, which will take care of registering extensions to our server; in this case, these are the endpoints routes. To make this plug-in (Or any other plug-in) work, we need to register it. The registration is an asynchronous operation, thus we gonna handle it using `async`:\n\n[{]: <helper> (diffStep 1.9)\n\n#### [Step 1.9: Register ednpoints routes](https://github.com/DAB0mB/radial-snake/commit/bba460f)\n\n##### Changed server.js\n```diff\n@@ -1,11 +1,23 @@\n+â”Š  â”Š 1â”Šconst Async = require(\"async\");\n â”Š 1â”Š 2â”Šconst Hapi = require(\"hapi\");\n+â”Š  â”Š 3â”Šconst Inert = require(\"inert\");\n+â”Š  â”Š 4â”Šconst Endpoints = require(\"./routes/endpoints\");\n â”Š 2â”Š 5â”Šconst IpGrabber = require(\"./helpers/ip_grabber\");\n â”Š 3â”Š 6â”Š\n â”Š 4â”Š 7â”Šlet localIp = IpGrabber.local();\n â”Š 5â”Š 8â”Šlet port = 8000;\n â”Š 6â”Š 9â”Š\n â”Š 7â”Š10â”Š// Initialize a new server\n-â”Š 8â”Š  â”Šlet server = new Hapi.Server();\n+â”Š  â”Š11â”Šlet server = new Hapi.Server({\n+â”Š  â”Š12â”Š  connections: {\n+â”Š  â”Š13â”Š    routes: {\n+â”Š  â”Š14â”Š      files: {\n+â”Š  â”Š15â”Š        // Served files will be relative to current directory\n+â”Š  â”Š16â”Š        relativeTo: __dirname\n+â”Š  â”Š17â”Š      }\n+â”Š  â”Š18â”Š    }\n+â”Š  â”Š19â”Š  }\n+â”Š  â”Š20â”Š});\n â”Š 9â”Š21â”Š\n â”Š10â”Š22â”Šserver.connection({ port: process.env.PORT || port });\n â”Š11â”Š23â”Š\n```\n```diff\n@@ -24,8 +36,14 @@\n â”Š24â”Š36â”Š  rep.continue();\n â”Š25â”Š37â”Š});\n â”Š26â”Š38â”Š\n+â”Š  â”Š39â”Š// Register all routes and plug-ins\n+â”Š  â”Š40â”ŠAsync.series([\n+â”Š  â”Š41â”Š  next => server.register(Inert, next),\n+â”Š  â”Š42â”Š  next => server.register(Endpoints, next),\n+â”Š  â”Š43â”Š  // Once registrations are finished, start the server\n+â”Š  â”Š44â”Š  next => server.start(next)\n â”Š27â”Š45â”Š// Print message once started\n-â”Š28â”Š  â”Šserver.start((err) => {\n+â”Š  â”Š46â”Š], (err) => {\n â”Š29â”Š47â”Š  if (err) throw err;\n â”Š30â”Š48â”Š\n â”Š31â”Š49â”Š  console.log();\n```\n\n[}]: #\n\nOnce all the plug-ins have been registered, we gonna start our server as we previously did. Note that we also registered the `inert` plug-in, because as I said earlier, that's what gives us the ability to handle files requests.\n\nLastly, I want to create the `pages` routes batch, which will be responsible for serving pages in our application as listed above:\n\n- The `/` route will serve us the `game.html` file.\n- The `/test` route will serve us the `spec_runner.html` file.\n\nBy the name of each route and file you can probably what each one should do. The thing is, we don't want everyone to be able to access the `spec_runner.html` file, or the `game.html` file if in the middle of development. For this, we're going to create a new helper which will be responsible for handling permissions. So first we gonna install an npm package called `boom` which has the ability to format `permission denied` HTTP errors:\n\n    $ npm install boom --save\n\nAnd now we gonna implement the module itself:\n\n[{]: <helper> (diffStep 1.11)\n\n#### [Step 1.11: Add permitter helper](https://github.com/DAB0mB/radial-snake/commit/d26a5d7)\n\n##### Added helpers&#x2F;permitter.js\n```diff\n@@ -0,0 +1,29 @@\n+â”Š  â”Š 1â”Šconst Boom = require(\"boom\");\n+â”Š  â”Š 2â”Šconst Hapi = require(\"hapi\");\n+â”Š  â”Š 3â”Šconst IpGrabber = require(\"./ip_grabber\");\n+â”Š  â”Š 4â”Š\n+â”Š  â”Š 5â”Š// These addresses will be permitted by default\n+â”Š  â”Š 6â”Šconst defaultPermissions = [\n+â”Š  â”Š 7â”Š  IpGrabber.local(), \"127.0.0.1\", \"localhost\"\n+â”Š  â”Š 8â”Š];\n+â”Š  â”Š 9â”Š\n+â”Š  â”Š10â”Š// Manage file permissions\n+â”Š  â”Š11â”Šfunction file(path, permissions, req, rep) {\n+â”Š  â”Š12â”Š  // Apply default permissions\n+â”Š  â”Š13â”Š  permissions = permissions.concat(defaultPermissions);\n+â”Š  â”Š14â”Š  // Request address\n+â”Š  â”Š15â”Š  let remoteAddress = req.info.remoteAddress;\n+â”Š  â”Š16â”Š\n+â”Š  â”Š17â”Š  // If not permitted, reply error\n+â”Š  â”Š18â”Š  if (permissions.indexOf(remoteAddress) == -1) {\n+â”Š  â”Š19â”Š    let err = new Boom.forbidden(\"Missing permissions\");\n+â”Š  â”Š20â”Š    return rep(err);\n+â”Š  â”Š21â”Š  }\n+â”Š  â”Š22â”Š\n+â”Š  â”Š23â”Š  // If permitted, reply file\n+â”Š  â”Š24â”Š  rep.file(path);\n+â”Š  â”Š25â”Š}\n+â”Š  â”Š26â”Š\n+â”Š  â”Š27â”Šmodule.exports = {\n+â”Š  â”Š28â”Š  file\n+â”Š  â”Š29â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nThe default permitted IP address would be the current computer's IP address. Extra IP permissions can be provided with the invocation of the `file` method. If the requesting IP is not listed in the permissions list, an error is gonna be replied instead of the requested file. Now that we have our \"permitter\" ready, let's implement the `pages` routes batch, only we're gonna pass the requests through the black-list, for the reason mentioned above:\n\n[{]: <helper> (diffStep 1.12)\n\n#### [Step 1.12: Add pages routes](https://github.com/DAB0mB/radial-snake/commit/11860e9)\n\n##### Added routes&#x2F;pages.js\n```diff\n@@ -0,0 +1,35 @@\n+â”Š  â”Š 1â”Šconst Hapi = require(\"hapi\");\n+â”Š  â”Š 2â”Šconst Pack = require(\"../package.json\");\n+â”Š  â”Š 3â”Šconst Permitter = require(\"../helpers/permitter\");\n+â”Š  â”Š 4â”Š\n+â”Š  â”Š 5â”Šregister.attributes = {\n+â”Š  â”Š 6â”Š  name: \"pages\",\n+â”Š  â”Š 7â”Š  version: Pack.version\n+â”Š  â”Š 8â”Š};\n+â”Š  â”Š 9â”Š\n+â”Š  â”Š10â”Šfunction register(server, options, next) {\n+â”Š  â”Š11â”Š  server.route({ method: \"GET\", path: \"/\", handler: getGame });\n+â”Š  â”Š12â”Š  server.route({ method: \"GET\", path: \"/test\", handler: getSpecRunner });\n+â”Š  â”Š13â”Š\n+â”Š  â”Š14â”Š  next();\n+â”Š  â”Š15â”Š}\n+â”Š  â”Š16â”Š\n+â”Š  â”Š17â”Š// Serve game page\n+â”Š  â”Š18â”Šfunction getGame(req, rep) {\n+â”Š  â”Š19â”Š  let path = \"./views/game.html\";\n+â”Š  â”Š20â”Š  let permissions = [];\n+â”Š  â”Š21â”Š\n+â”Š  â”Š22â”Š  Permitter.file(path, permissions, req, rep);\n+â”Š  â”Š23â”Š}\n+â”Š  â”Š24â”Š\n+â”Š  â”Š25â”Š// Serve test page\n+â”Š  â”Š26â”Šfunction getSpecRunner(req, rep) {\n+â”Š  â”Š27â”Š  let path = \"./views/spec_runner.html\";\n+â”Š  â”Š28â”Š  let permissions = [];\n+â”Š  â”Š29â”Š\n+â”Š  â”Š30â”Š  Permitter.file(path, permissions, req, rep);\n+â”Š  â”Š31â”Š}\n+â”Š  â”Š32â”Š\n+â”Š  â”Š33â”Šmodule.exports = {\n+â”Š  â”Š34â”Š  register\n+â”Š  â”Š35â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nNow the only thing left to do would be registering the plug-in we've just created:\n\n[{]: <helper> (diffStep 1.13)\n\n#### [Step 1.13: Register pages routes](https://github.com/DAB0mB/radial-snake/commit/ed50bef)\n\n##### Changed server.js\n```diff\n@@ -2,6 +2,7 @@\n â”Š2â”Š2â”Šconst Hapi = require(\"hapi\");\n â”Š3â”Š3â”Šconst Inert = require(\"inert\");\n â”Š4â”Š4â”Šconst Endpoints = require(\"./routes/endpoints\");\n+â”Š â”Š5â”Šconst Pages = require(\"./routes/pages\");\n â”Š5â”Š6â”Šconst IpGrabber = require(\"./helpers/ip_grabber\");\n â”Š6â”Š7â”Š\n â”Š7â”Š8â”Šlet localIp = IpGrabber.local();\n```\n```diff\n@@ -40,6 +41,7 @@\n â”Š40â”Š41â”ŠAsync.series([\n â”Š41â”Š42â”Š  next => server.register(Inert, next),\n â”Š42â”Š43â”Š  next => server.register(Endpoints, next),\n+â”Š  â”Š44â”Š  next => server.register(Pages, next),\n â”Š43â”Š45â”Š  // Once registrations are finished, start the server\n â”Š44â”Š46â”Š  next => server.start(next)\n â”Š45â”Š47â”Š// Print message once started\n```\n\n[}]: #\n\nAnd that's it for the current step! In the next steps we will start storing files and assets in our public directories and implement all the necessary scripts, so our server is not running in vain."
          },
          {
            "manualTitle": "Step 2: Creating a game engine basis",
            "stepRevision": "a3e901039dc5db535111da14305175182f9f346c",
            "manualView": "Like any other JavaScript-based application, we should have an entry view written in HTML. However, in our application, the only visible element is going to be an [HTMLCanvas](https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API). The canvas is exactly what it sounds like - a blank white surface which we can draw things on top of it. As we go further with this tutorial, we will learn more about the canvas and dive into its API and how to use it. Now that you got the general idea, let's create the HTML file:\n\n[{]: <helper> (diffStep 2.1)\n\n#### [Step 2.1: Create basic game view](https://github.com/DAB0mB/radial-snake/commit/254f06f)\n\n##### Added views&#x2F;game.html\n```diff\n@@ -0,0 +1,10 @@\n+â”Š  â”Š 1â”Š<!DOCTYPE html>\n+â”Š  â”Š 2â”Š<html>\n+â”Š  â”Š 3â”Š  <head>\n+â”Š  â”Š 4â”Š    <title>radial snake</title>\n+â”Š  â”Š 5â”Š  </head>\n+â”Š  â”Š 6â”Š\n+â”Š  â”Š 7â”Š  <body>\n+â”Š  â”Š 8â”Š    <canvas id=\"gameCanvas\" tabindex=\"0\"></canvas>\n+â”Š  â”Š 9â”Š  </body>\n+â”Š  â”Š10â”Š</html>ðŸš«â†µ\n```\n\n[}]: #\n\nIn the previous step we've already set the route for this file, so if you'd like to run the game, simply start the server by typing `npm run serve`, and navigate to the address presented on the screen (Should be `localhost:8000` by default).\n\n> From now on I'm going to assume the server is running in the background, so I won't repeat the instruction above\n\nJust to make sure that the canvas is visible and not blended into the background, we will draw a black border around using a simple style-sheet:\n\n[{]: <helper> (diffStep 2.2)\n\n#### [Step 2.2: Create basic game stylesheet](https://github.com/DAB0mB/radial-snake/commit/44fe5aa)\n\n##### Added resources&#x2F;styles&#x2F;game.css\n```diff\n@@ -0,0 +1,6 @@\n+â”Š â”Š1â”Š#gameCanvas {\n+â”Š â”Š2â”Š  display: block;\n+â”Š â”Š3â”Š  margin: auto;\n+â”Š â”Š4â”Š  border-style: solid;\n+â”Š â”Š5â”Š  border-width: 1px;\n+â”Š â”Š6â”Š}ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -2,6 +2,9 @@\n â”Š 2â”Š 2â”Š<html>\n â”Š 3â”Š 3â”Š  <head>\n â”Š 4â”Š 4â”Š    <title>radial snake</title>\n+â”Š  â”Š 5â”Š\n+â”Š  â”Š 6â”Š    <!-- Styles -->\n+â”Š  â”Š 7â”Š    <link rel=\"stylesheet\" type=\"text/css\" href=\"/styles/game.css\">\n â”Š 5â”Š 8â”Š  </head>\n â”Š 6â”Š 9â”Š\n â”Š 7â”Š10â”Š  <body>\n```\n\n[}]: #\n\n> Note that every asset we create should be declared in the HTML file in order for it to take effect\n\nTo build this project we're also gonna use two very famous utility libraries called [JQuery](http://jquery.com/) and [Underscore](http://underscorejs.org/) which will make our lives a bit easier. Third-party libraries should be located in a directory called `libs`, according to the routes-map we created in the previous step. To set these libraries up, type the following commands in series:\n\n    resources$ mkdir libs\n    resources$ cd libs\n    resources/libs$ wget raw.githubusercontent.com/dab0mb/radial-snake/master/resources/libs/underscore.js\n    resources/libs$ wget raw.githubusercontent.com/dab0mb/radial-snake/master/resources/libs/jquery-2.1.1.js\n\nAnd load them in the game's HTML file's header:\n\n[{]: <helper> (diffStep 2.3 files=\"views/game.html\")\n\n#### [Step 2.3: Add jquery and underscore libs](https://github.com/DAB0mB/radial-snake/commit/085ca6b)\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -3,6 +3,10 @@\n â”Š 3â”Š 3â”Š  <head>\n â”Š 4â”Š 4â”Š    <title>radial snake</title>\n â”Š 5â”Š 5â”Š\n+â”Š  â”Š 6â”Š    <!-- Libs -->\n+â”Š  â”Š 7â”Š    <script type=\"text/javascript\" src=\"/libs/jquery-2.1.1.js\"></script>\n+â”Š  â”Š 8â”Š    <script type=\"text/javascript\" src=\"/libs/underscore.js\"></script>\n+â”Š  â”Š 9â”Š\n â”Š 6â”Š10â”Š    <!-- Styles -->\n â”Š 7â”Š11â”Š    <link rel=\"stylesheet\" type=\"text/css\" href=\"/styles/game.css\">\n â”Š 8â”Š12â”Š  </head>\n```\n\n[}]: #\n\nNow, we're finally going to build the game engine. At first, it's gonna be very basic simple, but further in this tutorial we're going to extend it and add some pretty neat features. When creating an application, of any kind, you don't want to garbage the global scope, so it can stay clean without any conflicts. Therefore, we're going to create an initial namespace for our game engine called `Engine`, which is going to contain all our game engine's classes and entities:\n\n[{]: <helper> (diffStep 2.4)\n\n#### [Step 2.4: Add engine namespace](https://github.com/DAB0mB/radial-snake/commit/3d52525)\n\n##### Added resources&#x2F;scripts&#x2F;namespaces.js\n```diff\n@@ -0,0 +1 @@\n+â”Š â”Š1â”ŠEngine = {};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -7,6 +7,9 @@\n â”Š 7â”Š 7â”Š    <script type=\"text/javascript\" src=\"/libs/jquery-2.1.1.js\"></script>\n â”Š 8â”Š 8â”Š    <script type=\"text/javascript\" src=\"/libs/underscore.js\"></script>\n â”Š 9â”Š 9â”Š\n+â”Š  â”Š10â”Š    <!-- Scripts -->\n+â”Š  â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n+â”Š  â”Š12â”Š\n â”Š10â”Š13â”Š    <!-- Styles -->\n â”Š11â”Š14â”Š    <link rel=\"stylesheet\" type=\"text/css\" href=\"/styles/game.css\">\n â”Š12â”Š15â”Š  </head>\n```\n\n[}]: #\n\nThe first thing we're going to define in the namespace we've just created would be the game loop. The game loop is the central code of your game, split into different parts. Generally, these are: update and draw.\n\nThe main purpose of the update phase is to prepare all objects to be drawn, so this is where all the geometry code, coordinate updates, score changes, animation refreshments and other similar operations belong. This is also where the input will be captured and processed.\n\nWhen everything is properly updated and ready, we enter the draw phase where all this information is put on the screen. This function should contain all the code to manage and draw the levels, shapes, score board and so on.\n\n![game-loop](https://cloud.githubusercontent.com/assets/7648874/21332964/4b80ef4e-c633-11e6-946a-0c5870d2f9c9.png)\n\n> You can find plenty of details and information about what \"game loop\" means simply by typing in on Google.\n\nA game loop can wear many forms, but the concept is gonna be the same, plus-minus. This is how our game loop is going to loop like:\n\n[{]: <helper> (diffStep 2.5)\n\n#### [Step 2.5: Create a game basis](https://github.com/DAB0mB/radial-snake/commit/1b7fcf9)\n\n##### Added resources&#x2F;scripts&#x2F;engine&#x2F;game.js\n```diff\n@@ -0,0 +1,99 @@\n+â”Š  â”Š 1â”ŠEngine.Game = class Game {\n+â”Š  â”Š 2â”Š  // The frequency of which each frame will be drawn in milliseconds\n+â”Š  â”Š 3â”Š  get fps() {\n+â”Š  â”Š 4â”Š    return 1000 / 60;\n+â”Š  â”Š 5â”Š  }\n+â”Š  â”Š 6â”Š\n+â”Š  â”Š 7â”Š  // Game's run speed.\n+â”Š  â”Š 8â”Š  // A lower value will make it run slower and a higher value will make it run faster\n+â”Š  â”Š 9â”Š  get speed() {\n+â”Š  â”Š10â”Š    return 1;\n+â”Š  â”Š11â”Š  }\n+â”Š  â”Š12â”Š\n+â”Š  â”Š13â”Š  constructor(canvas) {\n+â”Š  â”Š14â”Š    this.canvas = canvas;\n+â”Š  â”Š15â”Š    this.lastUpdate = this.creation = new Date().getTime();\n+â”Š  â”Š16â”Š\n+â”Š  â”Š17â”Š    // Canvas dimensions must be set programmatically otherwise you might encounter some\n+â”Š  â”Š18â”Š    // unexpected behaviors\n+â”Š  â”Š19â”Š    canvas.width = 1280;\n+â”Š  â”Š20â”Š    canvas.height = 720;\n+â”Š  â”Š21â”Š    // Canvas will be focused once game page is loaded so all events will automatically\n+â”Š  â”Š22â”Š    // be captured by it\n+â”Š  â”Š23â”Š    canvas.focus();\n+â”Š  â”Š24â”Š\n+â”Š  â”Š25â”Š    // We want to focus on the canvas once we press on it\n+â”Š  â”Š26â”Š    canvas.addEventListener(\"mousedown\", canvas.focus.bind(canvas), false);\n+â”Š  â”Š27â”Š\n+â”Š  â”Š28â”Š    this.assets = {};\n+â”Š  â”Š29â”Š    this.events = new Map();\n+â”Š  â”Š30â”Š    this.context = canvas.getContext(\"2d\");\n+â”Š  â”Š31â”Š    this.bufferedCanvas = document.createElement(\"canvas\");\n+â”Š  â”Š32â”Š    this.bufferedContext = this.bufferedCanvas.getContext(\"2d\");\n+â”Š  â”Š33â”Š    this.bufferedCanvas.width = canvas.width;\n+â”Š  â”Š34â”Š    this.bufferedCanvas.height = canvas.height;\n+â”Š  â”Š35â”Š  }\n+â”Š  â”Š36â”Š\n+â”Š  â”Š37â”Š  draw() {\n+â”Š  â”Š38â”Š    // Draw a black screen by default\n+â”Š  â”Š39â”Š    this.context.restore();\n+â”Š  â”Š40â”Š    this.context.fillStyle = \"black\";\n+â”Š  â”Š41â”Š    this.context.save();\n+â”Š  â”Š42â”Š    this.context.beginPath();\n+â”Š  â”Š43â”Š    this.context.rect(0, 0, this.canvas.width, this.canvas.height);\n+â”Š  â”Š44â”Š    this.context.fill();\n+â”Š  â”Š45â”Š  }\n+â”Š  â”Š46â”Š\n+â”Š  â”Š47â”Š  update() {\n+â”Š  â”Š48â”Š    // Calculate the time elapsed\n+â”Š  â”Š49â”Š    let lastUpdate = this.lastUpdate;\n+â”Š  â”Š50â”Š    let currUpdate = this.lastUpdate = new Date().getTime();\n+â”Š  â”Š51â”Š    let span = currUpdate - lastUpdate;\n+â”Š  â”Š52â”Š    this.updateScreen(span / this.speed);\n+â”Š  â”Š53â”Š  }\n+â”Š  â”Š54â”Š\n+â”Š  â”Š55â”Š  // The main loop of the game\n+â”Š  â”Š56â”Š  loop() {\n+â”Š  â”Š57â”Š    // If paused, don't run loop. The canvas will remain as is\n+â”Š  â”Š58â”Š    if (!this.playing) return;\n+â”Š  â”Š59â”Š\n+â”Š  â”Š60â”Š    setTimeout(() => {\n+â”Š  â”Š61â”Š      this.draw();\n+â”Š  â”Š62â”Š      this.update();\n+â”Š  â”Š63â”Š      this.loop();\n+â”Š  â”Š64â”Š    }, this.fps);\n+â”Š  â”Š65â”Š  }\n+â”Š  â”Š66â”Š\n+â”Š  â”Š67â”Š  play() {\n+â”Š  â”Š68â”Š    this.playing = true;\n+â”Š  â”Š69â”Š    this.loop();\n+â”Š  â”Š70â”Š  }\n+â”Š  â”Š71â”Š\n+â”Š  â”Š72â”Š  pause() {\n+â”Š  â”Š73â”Š    this.playing = false;\n+â”Š  â”Š74â”Š  }\n+â”Š  â”Š75â”Š\n+â”Š  â”Š76â”Š  // Defines global assets\n+â”Š  â”Š77â”Š  extendAssets(assets) {\n+â”Š  â”Š78â”Š    _.extend(this.assets, assets);\n+â”Š  â”Š79â”Š  }\n+â”Š  â”Š80â”Š\n+â”Š  â”Š81â”Š  // Disposes global assets\n+â”Š  â”Š82â”Š  clearAssets() {\n+â”Š  â”Š83â”Š    this.assets = {};\n+â”Š  â”Š84â”Š  }\n+â”Š  â”Š85â”Š\n+â”Š  â”Š86â”Š  // Adds event listener for game canvas\n+â”Š  â”Š87â”Š  addEventListener(type, listener, target) {\n+â”Š  â”Š88â”Š    let boundListener = listener.bind(target);\n+â”Š  â”Š89â”Š    this.events.set(listener, boundListener);\n+â”Š  â”Š90â”Š    this.canvas.addEventListener(type, boundListener, false);\n+â”Š  â”Š91â”Š  }\n+â”Š  â”Š92â”Š\n+â”Š  â”Š93â”Š  // Removes event listener from game canvas\n+â”Š  â”Š94â”Š  removeEventListener(type, listener) {\n+â”Š  â”Š95â”Š    let boundListener = this.events.get(listener);\n+â”Š  â”Š96â”Š    this.events.delete(listener);\n+â”Š  â”Š97â”Š    this.canvas.removeEventListener(type, boundListener, false);\n+â”Š  â”Š98â”Š  }\n+â”Š  â”Š99â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -9,6 +9,7 @@\n â”Š 9â”Š 9â”Š\n â”Š10â”Š10â”Š    <!-- Scripts -->\n â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n+â”Š  â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š12â”Š13â”Š\n â”Š13â”Š14â”Š    <!-- Styles -->\n â”Š14â”Š15â”Š    <link rel=\"stylesheet\" type=\"text/css\" href=\"/styles/game.css\">\n```\n\n[}]: #\n\nThe only thing it's doing right now is drawing a black background, but we're soon going to learn how to take advantage of this game-loop to draw stuff of our own. I'd like to point out that there is no need to implement a [double-buffer](https://en.wikipedia.org/wiki/Multiple_buffering) (A method similar to React's [virtual DOM](https://www.npmjs.com/package/react-dom)) when it comes to `HTMLCanvas` elements, since `HTML5` already does that for us. To start running the game, we first need to wait for the DOM content to initialize, and once it's ready we gonna create a new game instance and call the `play` method:\n\n[{]: <helper> (diffStep 2.6)\n\n#### [Step 2.6: Create game entry point](https://github.com/DAB0mB/radial-snake/commit/30e75df)\n\n##### Added resources&#x2F;scripts&#x2F;main.js\n```diff\n@@ -0,0 +1,4 @@\n+â”Š â”Š1â”Šdocument.addEventListener(\"DOMContentLoaded\", function(event) {\n+â”Š â”Š2â”Š  let game = new Engine.Game(document.getElementById(\"gameCanvas\"), false);\n+â”Š â”Š3â”Š  game.play();\n+â”Š â”Š4â”Š});ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -10,6 +10,7 @@\n â”Š10â”Š10â”Š    <!-- Scripts -->\n â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n â”Š12â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n+â”Š  â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n â”Š13â”Š14â”Š\n â”Š14â”Š15â”Š    <!-- Styles -->\n â”Š15â”Š16â”Š    <link rel=\"stylesheet\" type=\"text/css\" href=\"/styles/game.css\">\n```\n\n[}]: #\n\nThis will take control over the canvas and will draw a new picture every 17ms, which is 60fps (Frames per second). As for now you're only going to see a black canvas, but I promise the final result is not going to disappoint you.\n\nThe next thing we're gonna do would be adding a 'key state' manager, which will store a flag for each key pressed on the keyboard. Once we press the key, the flag's value would be `true`, and once we release it, its value would turn into `false`. This way we have an easy way to track all the key presses without registering a specific event listener for each key press we wanna track:\n\n[{]: <helper> (diffStep 2.7)\n\n#### [Step 2.7: Add key states manager](https://github.com/DAB0mB/radial-snake/commit/831b058)\n\n##### Added resources&#x2F;scripts&#x2F;engine&#x2F;key_states.js\n```diff\n@@ -0,0 +1,20 @@\n+â”Š  â”Š 1â”ŠEngine.KeyStates = class KeyStates {\n+â”Š  â”Š 2â”Š  constructor() {\n+â”Š  â”Š 3â”Š    // We will have 255 states, each one represents an ascii code matching its index\n+â”Š  â”Š 4â”Š    this.states = new Array(255);\n+â”Š  â”Š 5â”Š  }\n+â”Š  â”Š 6â”Š\n+â”Š  â”Š 7â”Š  get(k) {\n+â”Š  â”Š 8â”Š    return this.states[k];\n+â”Š  â”Š 9â”Š  }\n+â”Š  â”Š10â”Š\n+â”Š  â”Š11â”Š  // This should be called once we press a key\n+â”Š  â”Š12â”Š  add(k) {\n+â”Š  â”Š13â”Š    this.states[k] = true;\n+â”Š  â”Š14â”Š  }\n+â”Š  â”Š15â”Š\n+â”Š  â”Š16â”Š  // This should be called once we release a key\n+â”Š  â”Š17â”Š  remove(k) {\n+â”Š  â”Š18â”Š    this.states[k] = false;\n+â”Š  â”Š19â”Š  }\n+â”Š  â”Š20â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -9,6 +9,7 @@\n â”Š 9â”Š 9â”Š\n â”Š10â”Š10â”Š    <!-- Scripts -->\n â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n+â”Š  â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/key_states.js\"></script>\n â”Š12â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n```\n\n[}]: #\n\nNow that we have the key state manager, we will initialize a new instance as part of our game's essentials, and we will create a global event listener for key presses; Each time a key is pressed, the key state manager will update itself:\n\n[{]: <helper> (diffStep 2.8)\n\n#### [Step 2.8: Register key presses](https://github.com/DAB0mB/radial-snake/commit/9f55501)\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;game.js\n```diff\n@@ -14,7 +14,7 @@\n â”Š14â”Š14â”Š    this.canvas = canvas;\n â”Š15â”Š15â”Š    this.lastUpdate = this.creation = new Date().getTime();\n â”Š16â”Š16â”Š\n-â”Š17â”Š  â”Š    // Canvas dimensions must be set programmatically otherwise you might encounter some\n+â”Š  â”Š17â”Š    // Canvas dimensions must be set programmatically, otherwise you might encounter some\n â”Š18â”Š18â”Š    // unexpected behaviors\n â”Š19â”Š19â”Š    canvas.width = 1280;\n â”Š20â”Š20â”Š    canvas.height = 720;\n```\n```diff\n@@ -24,9 +24,13 @@\n â”Š24â”Š24â”Š\n â”Š25â”Š25â”Š    // We want to focus on the canvas once we press on it\n â”Š26â”Š26â”Š    canvas.addEventListener(\"mousedown\", canvas.focus.bind(canvas), false);\n+â”Š  â”Š27â”Š    // Key flags will be registered by the \"KeyStates\" instance\n+â”Š  â”Š28â”Š    canvas.addEventListener(\"keydown\", onKeyDown.bind(this), false);\n+â”Š  â”Š29â”Š    canvas.addEventListener(\"keyup\", onKeyUp.bind(this), false);\n â”Š27â”Š30â”Š\n â”Š28â”Š31â”Š    this.assets = {};\n â”Š29â”Š32â”Š    this.events = new Map();\n+â”Š  â”Š33â”Š    this.keyStates = new Engine.KeyStates();\n â”Š30â”Š34â”Š    this.context = canvas.getContext(\"2d\");\n â”Š31â”Š35â”Š    this.bufferedCanvas = document.createElement(\"canvas\");\n â”Š32â”Š36â”Š    this.bufferedContext = this.bufferedCanvas.getContext(\"2d\");\n```\n```diff\n@@ -96,4 +100,19 @@\n â”Š 96â”Š100â”Š    this.events.delete(listener);\n â”Š 97â”Š101â”Š    this.canvas.removeEventListener(type, boundListener, false);\n â”Š 98â”Š102â”Š  }\n-â”Š 99â”Š   â”Š};ðŸš«â†µ\n+â”Š   â”Š103â”Š};\n+â”Š   â”Š104â”Š\n+â”Š   â”Š105â”Šfunction onKeyDown(e) {\n+â”Š   â”Š106â”Š  // Once we're focused on the canvas, we want nothing else to happen\n+â”Š   â”Š107â”Š  // besides events the game is listening to. For example, when we press\n+â”Š   â”Š108â”Š  // the arrow keys, this will prevent the screen from scrolling\n+â”Š   â”Š109â”Š  e.preventDefault();\n+â”Š   â”Š110â”Š  // Register key press\n+â”Š   â”Š111â”Š  this.keyStates.add(e.keyCode);\n+â”Š   â”Š112â”Š}\n+â”Š   â”Š113â”Š\n+â”Š   â”Š114â”Šfunction onKeyUp(e) {\n+â”Š   â”Š115â”Š  e.preventDefault();\n+â”Š   â”Š116â”Š  // Register key release\n+â”Š   â”Š117â”Š  this.keyStates.remove(e.keyCode);\n+â”Š   â”Š118â”Š}\n```\n\n[}]: #\n\nA 2D game's view might get complex as we go through with its development and add more logic and entities into it. Having only one `draw` method and only one `update` method is not enough, and if you think of it, it might easily get buffed up into ridiculous dimensions, which is not the way to go. I'd like to introduce you into a new methodology which involves `screens` and `layers`:\n\n- **screen** - Will literally be used whenever we want to show a new screen in our game e.g. 'splash' screen and 'main menu' screen. A screen consists of multiple layers, and will be used as their communicator; All the relevant assets and logic will be initialized inside it.\n- **layer** - similar to Photoshop's layer system, any time we want to add something to the view we add new layers on top or beneath of each other.\n\n![screen-layer](https://cloud.githubusercontent.com/assets/7648874/21487708/9b366efe-cbb7-11e6-8669-3212e440871a.png)\n\nAs I said earlier, the purpose of the screens and the layers is just to split the task of updating and drawing and updating, so we can have logical segments; So the `layer` class should mainly consist of a `draw` and an `update` method:\n\n[{]: <helper> (diffStep 2.9)\n\n#### [Step 2.9: Add screen layer](https://github.com/DAB0mB/radial-snake/commit/736ab08)\n\n##### Added resources&#x2F;scripts&#x2F;engine&#x2F;layer.js\n```diff\n@@ -0,0 +1,43 @@\n+â”Š  â”Š 1â”ŠEngine.Layer = class Layer {\n+â”Š  â”Š 2â”Š  // The dimensions of the layer are correlated to dimensions of the canvas\n+â”Š  â”Š 3â”Š  get width() {\n+â”Š  â”Š 4â”Š    return this.canvas.width;\n+â”Š  â”Š 5â”Š  }\n+â”Š  â”Š 6â”Š\n+â”Š  â”Š 7â”Š  get height() {\n+â”Š  â”Š 8â”Š    return this.canvas.height;\n+â”Š  â”Š 9â”Š  }\n+â”Š  â”Š10â”Š\n+â”Š  â”Š11â”Š  // A hash of \"eventName\" : \"handlerName\" which should be overrided by user\n+â”Š  â”Š12â”Š  get events() {\n+â”Š  â”Š13â”Š    return {};\n+â”Š  â”Š14â”Š  }\n+â”Š  â”Š15â”Š\n+â”Š  â”Š16â”Š  constructor(screen) {\n+â”Š  â”Š17â”Š    this.age = 0;\n+â”Š  â”Š18â”Š    this.creation = new Date().getTime();\n+â”Š  â”Š19â”Š    this.screen = screen;\n+â”Š  â”Š20â”Š    this.game = screen.game;\n+â”Š  â”Š21â”Š    this.assets = screen.assets;\n+â”Š  â”Š22â”Š    this.keyStates = screen.keyStates;\n+â”Š  â”Š23â”Š    this.canvas = screen.game.canvas;\n+â”Š  â”Š24â”Š  }\n+â”Š  â”Š25â”Š\n+â”Š  â”Š26â”Š  update(span) {\n+â”Š  â”Š27â”Š  }\n+â”Š  â”Š28â”Š\n+â”Š  â”Š29â”Š  draw(context) {\n+â”Š  â”Š30â”Š  }\n+â”Š  â”Š31â”Š\n+â”Š  â”Š32â”Š  initEventListeners() {\n+â”Š  â”Š33â”Š    _.each(this.events, (listener, event) => {\n+â”Š  â”Š34â”Š      this.game.addEventListener(event, this[listener], this);\n+â”Š  â”Š35â”Š    });\n+â”Š  â”Š36â”Š  }\n+â”Š  â”Š37â”Š\n+â”Š  â”Š38â”Š  disposeEventListeners() {\n+â”Š  â”Š39â”Š    _.each(this.events, (listener, event) => {\n+â”Š  â”Š40â”Š      this.game.removeEventListener(event, this[listener]);\n+â”Š  â”Š41â”Š    });\n+â”Š  â”Š42â”Š  }\n+â”Š  â”Š43â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -10,6 +10,7 @@\n â”Š10â”Š10â”Š    <!-- Scripts -->\n â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n â”Š12â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/key_states.js\"></script>\n+â”Š  â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/layer.js\"></script>\n â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š14â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n```\n\n[}]: #\n\nSame thing for the screen, it only has a `draw` and `update` methods, only it has a stack of layers, which can either be added or removed:\n\n[{]: <helper> (diffStep 2.1)\n\n#### [Step 2.1: Create basic game view](https://github.com/DAB0mB/radial-snake/commit/254f06f)\n\n##### Added views&#x2F;game.html\n```diff\n@@ -0,0 +1,10 @@\n+â”Š  â”Š 1â”Š<!DOCTYPE html>\n+â”Š  â”Š 2â”Š<html>\n+â”Š  â”Š 3â”Š  <head>\n+â”Š  â”Š 4â”Š    <title>radial snake</title>\n+â”Š  â”Š 5â”Š  </head>\n+â”Š  â”Š 6â”Š\n+â”Š  â”Š 7â”Š  <body>\n+â”Š  â”Š 8â”Š    <canvas id=\"gameCanvas\" tabindex=\"0\"></canvas>\n+â”Š  â”Š 9â”Š  </body>\n+â”Š  â”Š10â”Š</html>ðŸš«â†µ\n```\n\n[}]: #\n\nNow that we have the `screen` class available for us, let's apply it to the main game loop:\n\n[{]: <helper> (diffStep 2.11)\n\n#### [Step 2.11: Draw and update screen in game loop](https://github.com/DAB0mB/radial-snake/commit/9f34754)\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;game.js\n```diff\n@@ -30,6 +30,7 @@\n â”Š30â”Š30â”Š\n â”Š31â”Š31â”Š    this.assets = {};\n â”Š32â”Š32â”Š    this.events = new Map();\n+â”Š  â”Š33â”Š    this.screen = new Engine.Screen(this);\n â”Š33â”Š34â”Š    this.keyStates = new Engine.KeyStates();\n â”Š34â”Š35â”Š    this.context = canvas.getContext(\"2d\");\n â”Š35â”Š36â”Š    this.bufferedCanvas = document.createElement(\"canvas\");\n```\n```diff\n@@ -46,6 +47,13 @@\n â”Š46â”Š47â”Š    this.context.beginPath();\n â”Š47â”Š48â”Š    this.context.rect(0, 0, this.canvas.width, this.canvas.height);\n â”Š48â”Š49â”Š    this.context.fill();\n+â”Š  â”Š50â”Š    this.drawScreen(this.context);\n+â”Š  â”Š51â”Š  }\n+â”Š  â”Š52â”Š\n+â”Š  â”Š53â”Š  drawScreen(context) {\n+â”Š  â”Š54â”Š    // If screen's assets are not yet loaded, don't draw it\n+â”Š  â”Š55â”Š    if (this.screen.loading) return;\n+â”Š  â”Š56â”Š    if (this.screen.draw) this.screen.draw(context);\n â”Š49â”Š57â”Š  }\n â”Š50â”Š58â”Š\n â”Š51â”Š59â”Š  update() {\n```\n```diff\n@@ -56,6 +64,13 @@\n â”Š56â”Š64â”Š    this.updateScreen(span / this.speed);\n â”Š57â”Š65â”Š  }\n â”Š58â”Š66â”Š\n+â”Š  â”Š67â”Š  updateScreen(span) {\n+â”Š  â”Š68â”Š    this.screen.age += span;\n+â”Š  â”Š69â”Š    // If screen's assets are not yet loaded, don't update it\n+â”Š  â”Š70â”Š    if (this.screen.loading) return;\n+â”Š  â”Š71â”Š    if (this.screen.update) this.screen.update(span);\n+â”Š  â”Š72â”Š  }\n+â”Š  â”Š73â”Š\n â”Š59â”Š74â”Š  // The main loop of the game\n â”Š60â”Š75â”Š  loop() {\n â”Š61â”Š76â”Š    // If paused, don't run loop. The canvas will remain as is\n```\n\n[}]: #\n\nThis step looks kind of useless for now, unless we will have the ability to change screens as we please. Any time a screen is changed, it should be loaded with its necessary assets e.g textures, sounds, fonts, etc. The assets loading is an asynchronous operation whose logic might get a bit messy if not managed properly. To make it easier, we're going to define an assets loader, which will help us load assets asynchronously:\n\n[{]: <helper> (diffStep 2.12)\n\n#### [Step 2.12: Add assets loader](https://github.com/DAB0mB/radial-snake/commit/d8895f8)\n\n##### Added resources&#x2F;scripts&#x2F;engine&#x2F;assets_loader.js\n```diff\n@@ -0,0 +1,13 @@\n+â”Š  â”Š 1â”ŠEngine.AssetsLoader = class AssetsLoader {\n+â”Š  â”Š 2â”Š  constructor(next) {\n+â”Š  â”Š 3â”Š    this.next = next;\n+â”Š  â”Š 4â”Š  }\n+â”Š  â”Š 5â”Š\n+â”Š  â”Š 6â”Š  // Load texture\n+â”Š  â”Š 7â”Š  texture(path) {\n+â”Š  â”Š 8â”Š    let image = new Image();\n+â”Š  â”Š 9â”Š    image.onload = this.next();\n+â”Š  â”Š10â”Š    image.src = `${path}.png`;\n+â”Š  â”Š11â”Š    return image;\n+â”Š  â”Š12â”Š  }\n+â”Š  â”Š13â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -12,6 +12,7 @@\n â”Š12â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/key_states.js\"></script>\n â”Š13â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/layer.js\"></script>\n â”Š14â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/screen.js\"></script>\n+â”Š  â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/assets_loader.js\"></script>\n â”Š15â”Š16â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š16â”Š17â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n```\n\n[}]: #\n\n> As for now the `assets loader` only has the ability to load textures, but we will extend it as we go further in this tutorial, no need to overdo it.\n\nNow that we have the `assets loader` we can add the ability to change a screen. Whenever we change a screen, the old screen's assets should be unloaded, and the new screen's assets should be loaded using the `assets loader`:\n\n[{]: <helper> (diffStep 2.13)\n\n#### [Step 2.13: Add the ability to change and load screen](https://github.com/DAB0mB/radial-snake/commit/90aab03)\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;game.js\n```diff\n@@ -92,6 +92,61 @@\n â”Š 92â”Š 92â”Š    this.playing = false;\n â”Š 93â”Š 93â”Š  }\n â”Š 94â”Š 94â”Š\n+â”Š   â”Š 95â”Š  changeScreen(Screen, ...screenArgs) {\n+â”Š   â”Š 96â”Š    // If there is a screen defined, dispose it first\n+â”Š   â”Š 97â”Š    if (this.screen) {\n+â”Š   â”Š 98â”Š      this.unloadScreen();\n+â”Š   â”Š 99â”Š      this.screen.disposeEventListeners();\n+â”Š   â”Š100â”Š    }\n+â”Š   â”Š101â”Š\n+â”Š   â”Š102â”Š    this.screen = new Screen(this, ...screenArgs);\n+â”Š   â”Š103â”Š\n+â”Š   â”Š104â”Š    // Load screen assets\n+â”Š   â”Š105â”Š    this.loadScreen(() => {\n+â”Š   â”Š106â”Š      // Once assets are loaded, initialize event listeners\n+â”Š   â”Š107â”Š      this.screen.initEventListeners();\n+â”Š   â”Š108â”Š      // The \"initialize\" method is exactly the same as the constructor, only it runs\n+â”Š   â”Š109â”Š      // once assets are available and event listeners are registered\n+â”Š   â”Š110â”Š      this.screen.initialize(this, ...screenArgs);\n+â”Š   â”Š111â”Š    });\n+â”Š   â”Š112â”Š  }\n+â”Š   â”Š113â”Š\n+â”Š   â”Š114â”Š  // Loads screen assets and invokes callback once loading is finished\n+â”Š   â”Š115â”Š  loadScreen(callback = _.noop) {\n+â”Š   â”Š116â”Š    if (!this.screen.load) return callback();\n+â”Š   â”Š117â”Š\n+â”Š   â”Š118â”Š    this.screen.loading = true;\n+â”Š   â”Š119â”Š    // The number of assets to load\n+â”Š   â”Š120â”Š    let loadsize = 0;\n+â”Š   â”Š121â”Š    let onload;\n+â”Š   â”Š122â”Š\n+â”Š   â”Š123â”Š    // This object can load assets\n+â”Š   â”Š124â”Š    let assetsLoader = new Engine.AssetsLoader(() => {\n+â”Š   â”Š125â”Š      loadsize++;\n+â”Š   â”Š126â”Š      return () => onload();\n+â”Š   â”Š127â”Š    });\n+â”Š   â”Š128â”Š\n+â”Š   â”Š129â”Š    // The \"load\" method returns the assets loaded by the screen\n+â”Š   â”Š130â”Š    let screenAssets = this.screen.load(assetsLoader);\n+â”Š   â”Š131â”Š\n+â”Š   â”Š132â”Š    // We use the \"after\" method because we want the following callback to be invoked\n+â”Š   â”Š133â”Š    // only once all assets are loaded\n+â”Š   â”Š134â”Š    onload = _.after(loadsize, () => {\n+â”Š   â”Š135â”Š      delete this.screen.loading;\n+â”Š   â”Š136â”Š      callback();\n+â”Š   â”Š137â”Š    });\n+â”Š   â”Š138â”Š\n+â”Š   â”Š139â”Š    // The returned assets will be available on screen's assets object\n+â”Š   â”Š140â”Š    _.extend(this.screen.assets, screenAssets);\n+â”Š   â”Š141â”Š  }\n+â”Š   â”Š142â”Š\n+â”Š   â”Š143â”Š  // Disposes screen assets\n+â”Š   â”Š144â”Š  unloadScreen() {\n+â”Š   â”Š145â”Š    if (!this.screen.unload) return;\n+â”Š   â”Š146â”Š    let assetsNames = this.screen.unload();\n+â”Š   â”Š147â”Š    _.omit(this.assets, assetsNames);\n+â”Š   â”Š148â”Š  }\n+â”Š   â”Š149â”Š\n â”Š 95â”Š150â”Š  // Defines global assets\n â”Š 96â”Š151â”Š  extendAssets(assets) {\n â”Š 97â”Š152â”Š    _.extend(this.assets, assets);\n```\n\n[}]: #\n\nLet's add a test screen just so we can get the hang of it. The test screen will only print a message to the canvas:\n\n[{]: <helper> (diffStep 2.14)\n\n#### [Step 2.14: Add test screen](https://github.com/DAB0mB/radial-snake/commit/85776e8)\n\n##### Added resources&#x2F;scripts&#x2F;test_screen.js\n```diff\n@@ -0,0 +1,10 @@\n+â”Š  â”Š 1â”Šclass TestScreen extends Engine.Screen {\n+â”Š  â”Š 2â”Š  draw(context) {\n+â”Š  â”Š 3â”Š    // A 20px sized \"Georgia\" font (Available natively)\n+â”Š  â”Š 4â”Š    context.font = \"20px Georgia\";\n+â”Š  â”Š 5â”Š    // The text should be colored white\n+â”Š  â”Š 6â”Š    context.fillStyle = \"white\";\n+â”Š  â”Š 7â”Š    // Draw the following message 50px from the left and 50px from the top\n+â”Š  â”Š 8â”Š    context.fillText(\"This is a Test Screen\", 50, 50);\n+â”Š  â”Š 9â”Š  }\n+â”Š  â”Š10â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -14,6 +14,7 @@\n â”Š14â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/screen.js\"></script>\n â”Š15â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/assets_loader.js\"></script>\n â”Š16â”Š16â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n+â”Š  â”Š17â”Š    <script type=\"text/javascript\" src=\"/scripts/test_screen.js\"></script>\n â”Š17â”Š18â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n â”Š18â”Š19â”Š\n â”Š19â”Š20â”Š    <!-- Styles -->\n```\n\n[}]: #\n\nNow we will use the test screen by changing to it as we create an instance of the game:\n\n[{]: <helper> (diffStep 2.15)\n\n#### [Step 2.15: Set test screen as the initial screen](https://github.com/DAB0mB/radial-snake/commit/203d084)\n\n##### Changed resources&#x2F;scripts&#x2F;main.js\n```diff\n@@ -1,4 +1,5 @@\n â”Š1â”Š1â”Šdocument.addEventListener(\"DOMContentLoaded\", function(event) {\n â”Š2â”Š2â”Š  let game = new Engine.Game(document.getElementById(\"gameCanvas\"), false);\n+â”Š â”Š3â”Š  game.changeScreen(TestScreen);\n â”Š3â”Š4â”Š  game.play();\n â”Š4â”Š5â”Š});ðŸš«â†µ\n```\n\n[}]: #\n\nOnce you will load the application you should see a black canvas with a white text saying:\n\n    This is a test screen\n\nIt means our screen system works and you may proceed to the next step, where we're gonna create our first screen :-)"
          },
          {
            "manualTitle": "Step 3: Creating a splash screen using a keyframe animation engine",
            "stepRevision": "4b2431bbc910f8945e5fd86aa964fec3ede8761c",
            "manualView": "![snake-demo-splash-small](https://cloud.githubusercontent.com/assets/7648874/21074086/a19fa9ce-bed6-11e6-9060-2ce94c215712.gif)\n\nIn this step we will be creating the `splash` screen - the initial screen that should be shown once we launch the game. Our splash is consisted of a random logo animation as presented in the `gif` file above. The \"splash\" effect can be achieved using 2 concepts:\n\n- A sprite class - Which will present the logo texture in different dimensions, angles and rotations.\n- A key-frame animation - Which will draw an animation automatically along the time axis using key-frames - each is a sprite representation of the texture in a specific time point.\n\nSo first thing first, we will start by implementing the sprite class:\n\n[{]: <helper> (diffStep 3.1)\n\n#### [Step 3.1: Create &#x27;Sprite&#x27; class](https://github.com/DAB0mB/radial-snake/commit/a32a711)\n\n##### Added resources&#x2F;scripts&#x2F;engine&#x2F;sprite.js\n```diff\n@@ -0,0 +1,58 @@\n+â”Š  â”Š 1â”ŠEngine.Sprite = class Sprite {\n+â”Š  â”Š 2â”Š  // An easy representation of a sprite on a canvas, with a set of convenient tools\n+â”Š  â”Š 3â”Š  // for alignment and coloring\n+â”Š  â”Š 4â”Š  constructor(texture) {\n+â”Š  â”Š 5â”Š    this.texture = texture;\n+â”Š  â”Š 6â”Š    this.x = 0;\n+â”Š  â”Š 7â”Š    this.y = 0;\n+â”Š  â”Š 8â”Š    this.width = texture.width;\n+â”Š  â”Š 9â”Š    this.height = texture.height;\n+â”Š  â”Š10â”Š    this.pivot = { x: 0, y: 0 };\n+â”Š  â”Š11â”Š    this.opacity = 1;\n+â”Š  â”Š12â”Š  }\n+â”Š  â”Š13â”Š\n+â”Š  â”Š14â”Š  draw(context, offsetX = 0, offsetY = 0) {\n+â”Š  â”Š15â”Š    context.save();\n+â”Š  â”Š16â”Š    context.globalAlpha = this.opacity;\n+â”Š  â”Š17â”Š\n+â”Š  â”Š18â”Š    // The following switch-case can also be seen as a list of all possible\n+â”Š  â”Š19â”Š    // alignment modes\n+â”Š  â”Š20â”Š    switch (this.align) {\n+â”Š  â”Š21â”Š      case \"top-left\": case \"left-top\": this.pivot = { x: 0, y: 0 }; break;\n+â”Š  â”Š22â”Š      case \"top-right\": case \"right-top\": this.pivot = { x: this.width, y: 0 }; break;\n+â”Š  â”Š23â”Š      case \"bottom-left\": case \"left-bottom\": this.pivot = { x: 0, y: this.height }; break;\n+â”Š  â”Š24â”Š      case \"bottom-right\": case \"right-bottom\": this.pivot = { x: this.width, y: this.height }; break;\n+â”Š  â”Š25â”Š      case \"middle\": case \"center\": this.pivot = { x: this.width / 2, y: this.height / 2 }; break;\n+â”Š  â”Š26â”Š      case \"left\": this.pivot = { x: 0, y: this.height / 2 }; break;\n+â”Š  â”Š27â”Š      case \"top\": this.pivot = { x: this.width / 2, y: 0 }; break;\n+â”Š  â”Š28â”Š      case \"right\": this.pivot = { x: this.width, y: this.height / 2 }; break;\n+â”Š  â”Š29â”Š      case \"bottom\": this.pivot = { x: this.width / 2, y: this.height }; break;\n+â”Š  â”Š30â”Š    }\n+â”Š  â”Š31â”Š\n+â”Š  â”Š32â”Š    context.drawImage(\n+â”Š  â”Š33â”Š      this.texture,\n+â”Š  â”Š34â”Š      (this.x - this.pivot.x) + offsetX,\n+â”Š  â”Š35â”Š      (this.y - this.pivot.y) + offsetY,\n+â”Š  â”Š36â”Š      this.width,\n+â”Š  â”Š37â”Š      this.height\n+â”Š  â”Š38â”Š    );\n+â”Š  â”Š39â”Š\n+â”Š  â”Š40â”Š    context.restore();\n+â”Š  â”Š41â”Š  }\n+â”Š  â”Š42â”Š\n+â”Š  â”Š43â”Š  // A sprite property (key) can also be resized based on a given percentage.\n+â”Š  â”Š44â”Š  // The 'relative' argument represents the whole of which the percents are gonna be\n+â”Š  â”Š45â”Š  // calculated from, and the 'adapters' argument is an array of property names which\n+â”Š  â”Š46â”Š  // gonna adapt themselves based on the changes made in the given key.\n+â”Š  â”Š47â”Š  // Usually 'width' goes along with ['height'] adapters, if we\n+â”Š  â”Š48â”Š  // want to keep their original ratio\n+â”Š  â”Š49â”Š  setPercentage(key, relative, percents, ...adapters) {\n+â”Š  â”Š50â”Š    let oldVal = this[key];\n+â”Š  â”Š51â”Š    let newVal = this[key] = (percents * relative) / 100;\n+â”Š  â”Š52â”Š    let ratio = newVal / oldVal;\n+â”Š  â”Š53â”Š\n+â”Š  â”Š54â”Š    adapters.forEach(adapter => {\n+â”Š  â”Š55â”Š      this[adapter] *= ratio;\n+â”Š  â”Š56â”Š    });\n+â”Š  â”Š57â”Š  }\n+â”Š  â”Š58â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -9,6 +9,7 @@\n â”Š 9â”Š 9â”Š\n â”Š10â”Š10â”Š    <!-- Scripts -->\n â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n+â”Š  â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/sprite.js\"></script>\n â”Š12â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/key_states.js\"></script>\n â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/layer.js\"></script>\n â”Š14â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/screen.js\"></script>\n```\n\n[}]: #\n\nAnd we will download the logo which will be presented in the splash screen using the sprite class:\n\n    resources$ mkdir assets\n    resources$ cd assets\n    resources/assets$ mkdir textures\n    resources/assets$ cd textures\n    resources/assets/textures$ wget raw.githubusercontent.com/dab0mb/radial-snake/master/resources/assets/textures/splash.png\n\n> Any logo can that you desired can be used instead! But to ease things up I already provided you with one as a sample\n\nNow we will create the initial splash screen, where we only gonna show a sprite of the logo in the middle of the screen, with no animation applied yet. We will first define a dedicated `Screens` module under the `Game` namespace:\n\n[{]: <helper> (diffStep 3.3)\n\n#### [Step 3.3: Create a &#x27;Game&#x27; namespace with a &#x27;Screens&#x27; module](https://github.com/DAB0mB/radial-snake/commit/ae85a96)\n\n##### Changed resources&#x2F;scripts&#x2F;namespaces.js\n```diff\n@@ -1 +1,5 @@\n+â”Š â”Š1â”ŠGame = {\n+â”Š â”Š2â”Š  Screens: {}\n+â”Š â”Š3â”Š};\n+â”Š â”Š4â”Š\n â”Š1â”Š5â”ŠEngine = {};ðŸš«â†µ\n```\n\n[}]: #\n\nAnd we can go ahead and implement the screen itself:\n\n[{]: <helper> (diffStep 3.4)\n\n#### [Step 3.4: Create initial splash screen](https://github.com/DAB0mB/radial-snake/commit/4dd73f3)\n\n##### Added resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;splash&#x2F;index.js\n```diff\n@@ -0,0 +1,19 @@\n+â”Š  â”Š 1â”ŠGame.Screens.Splash = class Splash extends Engine.Screen {\n+â”Š  â”Š 2â”Š  initialize() {\n+â”Š  â”Š 3â”Š    // Create splash sprite and set its properties\n+â”Š  â”Š 4â”Š    this.splashSprite = new Engine.Sprite(this.assets.splashTexture);\n+â”Š  â”Š 5â”Š    this.splashSprite.align = \"center\";\n+â”Š  â”Š 6â”Š    this.splashSprite.x = this.width / 2;\n+â”Š  â”Š 7â”Š  }\n+â”Š  â”Š 8â”Š\n+â”Š  â”Š 9â”Š  load(assetsLoader) {\n+â”Š  â”Š10â”Š    // These are local assets which will be disposed along with the screen\n+â”Š  â”Š11â”Š    return {\n+â”Š  â”Š12â”Š      splashTexture: assetsLoader.texture(\"/textures/splash\")\n+â”Š  â”Š13â”Š    };\n+â”Š  â”Š14â”Š  }\n+â”Š  â”Š15â”Š\n+â”Š  â”Š16â”Š  draw(context) {\n+â”Š  â”Š17â”Š    this.splashSprite.draw(context);\n+â”Š  â”Š18â”Š  }\n+â”Š  â”Š19â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -16,6 +16,7 @@\n â”Š16â”Š16â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/assets_loader.js\"></script>\n â”Š17â”Š17â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š18â”Š18â”Š    <script type=\"text/javascript\" src=\"/scripts/test_screen.js\"></script>\n+â”Š  â”Š19â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/splash/index.js\"></script>\n â”Š19â”Š20â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n â”Š20â”Š21â”Š\n â”Š21â”Š22â”Š    <!-- Styles -->\n```\n\n[}]: #\n\nNow we can set the splash screen as the initial screen in the entry script file:\n\n[{]: <helper> (diffStep 3.5)\n\n#### [Step 3.5: Set splash screen as the initial game screen](https://github.com/DAB0mB/radial-snake/commit/3576ff8)\n\n##### Changed resources&#x2F;scripts&#x2F;main.js\n```diff\n@@ -1,5 +1,5 @@\n â”Š1â”Š1â”Šdocument.addEventListener(\"DOMContentLoaded\", function(event) {\n â”Š2â”Š2â”Š  let game = new Engine.Game(document.getElementById(\"gameCanvas\"), false);\n-â”Š3â”Š â”Š  game.changeScreen(TestScreen);\n+â”Š â”Š3â”Š  game.changeScreen(Game.Screens.Splash);\n â”Š4â”Š4â”Š  game.play();\n â”Š5â”Š5â”Š});ðŸš«â†µ\n```\n\n[}]: #\n\nAnd we will get rid of the unnecessary test screen since we make no use of it any longer:\n\n    $ rm resources/scripts/test_screen.js\n\nWe will now proceed into the next stage where we will be implementing the key-frame animation engine as said at the beginning of the step. We first need to define an `Animations` module, since we can have multiple types of animation strategy like [sprite-atlas animation](http://www.joshmorony.com/how-to-create-animations-in-phaser-with-a-texture-atlas/), not necessarily a key-frame animation:\n\n[{]: <helper> (diffStep 3.7)\n\n#### [Step 3.7: Add &#x27;Animations&#x27; module to &#x27;Engine&#x27; namespace](https://github.com/DAB0mB/radial-snake/commit/ffe800c)\n\n##### Changed resources&#x2F;scripts&#x2F;namespaces.js\n```diff\n@@ -2,4 +2,6 @@\n â”Š2â”Š2â”Š  Screens: {}\n â”Š3â”Š3â”Š};\n â”Š4â”Š4â”Š\n-â”Š5â”Š â”ŠEngine = {};ðŸš«â†µ\n+â”Š â”Š5â”ŠEngine = {\n+â”Š â”Š6â”Š  Animations: {}\n+â”Š â”Š7â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nInside the newly created module we will create the key-frame animation engine. The key-frame animation consists of the following methods:\n\n- update - Updates the animation.\n- draw - Draws the current animation frame on the provided canvas context.\n- play - Enables update operations.\n- pause - Disables update operations.\n\n[{]: <helper> (diffStep 3.8)\n\n#### [Step 3.8: Create a key-frame animation engine](https://github.com/DAB0mB/radial-snake/commit/64c58fb)\n\n##### Added resources&#x2F;scripts&#x2F;engine&#x2F;animations&#x2F;keyframe.js\n```diff\n@@ -0,0 +1,142 @@\n+â”Š   â”Š  1â”ŠEngine.Animations.Keyframe = class Keyframe {\n+â”Š   â”Š  2â”Š  constructor(sprite, keyframes) {\n+â”Š   â”Š  3â”Š    this.sprite = sprite;\n+â”Š   â”Š  4â”Š    // The key-frames array contains objects with the properties of the\n+â”Š   â”Š  5â”Š    // sprite at the current time-point, e.g. width of 100 and height of 200\n+â”Š   â”Š  6â”Š    this.keyframes = keyframes;\n+â”Š   â”Š  7â”Š    this.age = 0;\n+â”Š   â”Š  8â”Š    this.frame = 0;\n+â”Š   â”Š  9â”Š    // This flag determines what's gonna happen to the animation once\n+â”Š   â”Š 10â”Š    // it's finished playing\n+â”Š   â”Š 11â”Š    this.repetitionMode = \"none\";\n+â”Š   â”Š 12â”Š    this.lastKeyframe = _.last(keyframes);\n+â”Š   â”Š 13â”Š    this.lastFrame = this.lastKeyframe.frame;\n+â”Š   â”Š 14â”Š\n+â”Š   â”Š 15â”Š    // These are the properties which we can animate\n+â”Š   â”Š 16â”Š    this.animables = [\n+â”Š   â”Š 17â”Š      \"x\", \"y\", \"width\", \"height\", \"opacity\"\n+â”Š   â”Š 18â”Š    ];\n+â”Š   â”Š 19â”Š\n+â”Š   â”Š 20â”Š    // Set a map whose keys represent animatable properties and values represent an array\n+â”Š   â”Š 21â”Š    // with relevant key-frames to its belonging property\n+â”Š   â”Š 22â”Š    this.trimmedKeyframes = this.animables.reduce((trimmedKeyframes, key) => {\n+â”Š   â”Š 23â”Š      trimmedKeyframes[key] = keyframes.filter(keyframe => keyframe[key] != null);\n+â”Š   â”Š 24â”Š      return trimmedKeyframes;\n+â”Š   â”Š 25â”Š    }, {});\n+â”Š   â”Š 26â”Š\n+â”Š   â”Š 27â”Š    // Set initial properties on sprite based on initial key-frame\n+â”Š   â”Š 28â”Š    _.each(keyframes[0], (value, key) => {\n+â”Š   â”Š 29â”Š      if (this.animables.includes(key)) sprite[key] = value;\n+â”Š   â”Š 30â”Š    });\n+â”Š   â”Š 31â”Š  }\n+â”Š   â”Š 32â”Š\n+â”Š   â”Š 33â”Š  draw(context, offsetX, offsetY) {\n+â”Š   â”Š 34â”Š    this.sprite.draw(context, offsetX, offsetY);\n+â”Š   â”Š 35â”Š  }\n+â”Š   â”Š 36â”Š\n+â”Š   â”Š 37â”Š  update(span) {\n+â”Š   â”Š 38â”Š    if (!this.playing) return;\n+â”Š   â”Š 39â”Š\n+â”Š   â”Š 40â”Š    this.age += span;\n+â”Š   â”Š 41â”Š\n+â”Š   â”Š 42â”Š    switch (this.repetitionMode) {\n+â”Š   â”Š 43â”Š      // After one cycle animation would stop\n+â”Š   â”Š 44â”Š      case \"none\":\n+â”Š   â”Š 45â”Š        this.frame += span;\n+â”Š   â”Š 46â”Š\n+â”Š   â”Š 47â”Š        if (this.frame > this.lastFrame) {\n+â”Š   â”Š 48â”Š          this.frame = this.lastFrame;\n+â”Š   â”Š 49â”Š          this.playing = false;\n+â”Š   â”Š 50â”Š        }\n+â”Š   â”Š 51â”Š\n+â”Š   â”Š 52â”Š        break;\n+â”Š   â”Š 53â”Š\n+â”Š   â”Š 54â”Š      // Once finished, replay from the beginning\n+â”Š   â”Š 55â”Š      case \"cyclic\":\n+â”Š   â”Š 56â”Š        this.frame = this.age % this.lastFrame;\n+â”Š   â”Š 57â”Š        break;\n+â”Š   â”Š 58â”Š\n+â”Š   â”Š 59â”Š      // Once finished, play backwards, and so on\n+â”Š   â”Š 60â”Š      case \"full\":\n+â”Š   â”Š 61â”Š        this.frame = this.age % this.lastFrame;\n+â”Š   â”Š 62â”Š        let animationComplete = (this.age / this.lastFrame) % 2 >= 1;\n+â”Š   â”Š 63â”Š        if (animationComplete) this.frame = this.lastFrame - this.frame;\n+â”Š   â”Š 64â”Š        break;\n+â”Š   â”Š 65â”Š    }\n+â”Š   â”Š 66â”Š\n+â”Š   â”Š 67â”Š    // Update sprite properties based on given key-frame's easing mode\n+â”Š   â”Š 68â”Š    this.animables.forEach(key => {\n+â”Š   â”Š 69â”Š      let motion = this.getKeyframeMotion(key);\n+â”Š   â”Š 70â”Š\n+â”Š   â”Š 71â”Š      if (motion)\n+â”Š   â”Š 72â”Š        this.sprite[key] = this.calculateRelativeValue(motion, key);\n+â”Š   â”Š 73â”Š    });\n+â”Š   â”Š 74â”Š  }\n+â”Š   â”Š 75â”Š\n+â”Š   â”Š 76â”Š  play() {\n+â”Š   â”Š 77â”Š    this.playing = true;\n+â”Š   â”Š 78â”Š  }\n+â”Š   â”Š 79â”Š\n+â”Š   â”Š 80â”Š  pause() {\n+â”Š   â”Š 81â”Š    this.playing = false;\n+â”Š   â”Š 82â”Š  }\n+â”Š   â”Š 83â”Š\n+â”Š   â”Š 84â”Š  // Gets motion for current refresh\n+â”Š   â”Š 85â”Š  getKeyframeMotion(key) {\n+â”Š   â”Š 86â”Š    let keyframes = this.trimmedKeyframes[key];\n+â”Š   â”Š 87â”Š\n+â”Š   â”Š 88â”Š    // If no key-frames defined, motion is idle\n+â”Š   â”Š 89â”Š    if (keyframes == null) return;\n+â”Š   â”Š 90â”Š    // If there is only one key frame, motion is idle\n+â”Š   â”Š 91â”Š    if (keyframes.length < 2) return;\n+â”Š   â”Š 92â”Š    // If last frame reached, motion is idle\n+â”Š   â”Š 93â”Š    if (this.frame > _.last(keyframes).frame) return;\n+â”Š   â”Š 94â”Š\n+â”Š   â”Š 95â”Š    let start = this.findStartKeyframe(keyframes);\n+â”Š   â”Š 96â”Š    let end = this.findEndKeyframe(keyframes);\n+â”Š   â”Š 97â”Š    let ratio = this.getKeyframesRatio(start, end);\n+â”Š   â”Š 98â”Š\n+â”Š   â”Š 99â”Š    return { start, end, ratio };\n+â”Š   â”Š100â”Š  }\n+â”Š   â”Š101â”Š\n+â”Š   â”Š102â”Š  // Gets the movement ratio\n+â”Š   â”Š103â”Š  getKeyframesRatio(start, end) {\n+â”Š   â”Š104â”Š    return (this.frame - start.frame) / (end.frame - start.frame);\n+â”Š   â”Š105â”Š  }\n+â”Š   â”Š106â”Š\n+â”Š   â”Š107â”Š  // Get property end value based on current frame\n+â”Š   â”Š108â”Š  findEndKeyframe(keyframes) {\n+â”Š   â”Š109â”Š    return _.find(keyframes, keyframe =>\n+â”Š   â”Š110â”Š      keyframe.frame >= (this.frame || 1)\n+â”Š   â”Š111â”Š    );\n+â”Š   â”Š112â”Š  }\n+â”Š   â”Š113â”Š\n+â”Š   â”Š114â”Š  // Get property start value based on current frame\n+â”Š   â”Š115â”Š  findStartKeyframe(keyframes) {\n+â”Š   â”Š116â”Š    let resultIndex;\n+â”Š   â”Š117â”Š\n+â”Š   â”Š118â”Š    keyframes.some((keyframe, currIndex) => {\n+â”Š   â”Š119â”Š      if (keyframe.frame >= (this.frame || 1)) {\n+â”Š   â”Š120â”Š        resultIndex = currIndex;\n+â”Š   â”Š121â”Š        return true;\n+â”Š   â”Š122â”Š      }\n+â”Š   â”Š123â”Š    });\n+â”Š   â”Š124â”Š\n+â”Š   â”Š125â”Š    return keyframes[resultIndex - 1];\n+â”Š   â”Š126â”Š  }\n+â”Š   â”Š127â”Š\n+â”Š   â”Š128â”Š  // Get a recalculated property value relative to provided easing mode\n+â”Š   â”Š129â”Š  calculateRelativeValue(motion, key) {\n+â”Š   â”Š130â”Š    let a = motion.start[key];\n+â”Š   â”Š131â”Š    let b = motion.end[key];\n+â”Š   â”Š132â”Š    let r = motion.ratio;\n+â”Š   â”Š133â”Š    let easing = r > 0 ? motion.start.easing : motion.end.easing;\n+â”Š   â”Š134â”Š\n+â”Š   â”Š135â”Š    switch (easing) {\n+â”Š   â”Š136â”Š      case \"in\": r = Math.sin((r * Math.PI) / 2); break;\n+â”Š   â”Š137â”Š      case \"out\": r = Math.cos((r * Math.PI) / 2); break;\n+â”Š   â”Š138â”Š    }\n+â”Š   â”Š139â”Š\n+â”Š   â”Š140â”Š    return ((b - a) * r) + a;\n+â”Š   â”Š141â”Š  }\n+â”Š   â”Š142â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -10,6 +10,7 @@\n â”Š10â”Š10â”Š    <!-- Scripts -->\n â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n â”Š12â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/sprite.js\"></script>\n+â”Š  â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/animations/keyframe.js\"></script>\n â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/key_states.js\"></script>\n â”Š14â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/layer.js\"></script>\n â”Š15â”Š16â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/screen.js\"></script>\n```\n\n[}]: #\n\nWhen initializing a new instance of the key-frame animation, we should invoke it with the desired sprite, and an array of key-frames. What exactly does a single key-frame represents? The properties of the sprite at that specific time point. In addition, a key-frame can be set with an [easing mode](https://css-tricks.com/ease-out-in-ease-in-out/) of `in` and `out`. By default, the animation would be linear.\n\nBased on the `repitationMode` property, three things can happen to the animation once finished:\n\n- `none` - The animation will play once, and then stop. It will appear as a static sprite.\n- `cyclic` - The animation will repeat itself from the beginning, over and over again until stopped manually.\n- `full` - The animation will play itself backwards, and then forwards, backwards, forwards, and so on.\n\nThanks to the key-frame animation engine, we can apply it to the splash screen to show a beautifully animated logo rather than showing a static image. So in addition to the logo sprite, we will initialize a key-frame animation as well:\n\n[{]: <helper> (diffStep 3.9)\n\n#### [Step 3.9: Apply key-frame animation to splash screen](https://github.com/DAB0mB/radial-snake/commit/8ca47e5)\n\n##### Changed resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;splash&#x2F;index.js\n```diff\n@@ -1,9 +1,34 @@\n â”Š 1â”Š 1â”ŠGame.Screens.Splash = class Splash extends Engine.Screen {\n â”Š 2â”Š 2â”Š  initialize() {\n â”Š 3â”Š 3â”Š    // Create splash sprite and set its properties\n-â”Š 4â”Š  â”Š    this.splashSprite = new Engine.Sprite(this.assets.splashTexture);\n-â”Š 5â”Š  â”Š    this.splashSprite.align = \"center\";\n-â”Š 6â”Š  â”Š    this.splashSprite.x = this.width / 2;\n+â”Š  â”Š 4â”Š    let splashSprite = new Engine.Sprite(this.assets.splashTexture);\n+â”Š  â”Š 5â”Š    splashSprite.align = \"center\";\n+â”Š  â”Š 6â”Š    splashSprite.x = this.width / 2;\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Š    // Create splash sprite animation\n+â”Š  â”Š 9â”Š    this.splashAnim = new Engine.Animations.Keyframe(splashSprite, [\n+â”Š  â”Š10â”Š      {\n+â”Š  â”Š11â”Š        y: (this.height / 2) - 30,\n+â”Š  â”Š12â”Š        width: splashSprite.width / 4,\n+â”Š  â”Š13â”Š        height: splashSprite.height / 4,\n+â”Š  â”Š14â”Š        opacity: 0,\n+â”Š  â”Š15â”Š        easing: \"in\",\n+â”Š  â”Š16â”Š        frame: 0\n+â”Š  â”Š17â”Š      },\n+â”Š  â”Š18â”Š      {\n+â”Š  â”Š19â”Š        y: this.height / 2,\n+â”Š  â”Š20â”Š        width: (splashSprite.width / 3) + (splashSprite.width * 0.05),\n+â”Š  â”Š21â”Š        height: (splashSprite.height / 3) + (splashSprite.height * 0.05),\n+â”Š  â”Š22â”Š        opacity: 1,\n+â”Š  â”Š23â”Š        frame: 3000\n+â”Š  â”Š24â”Š      },\n+â”Š  â”Š25â”Š      {\n+â”Š  â”Š26â”Š        frame: 3500\n+â”Š  â”Š27â”Š      }\n+â”Š  â”Š28â”Š    ]);\n+â”Š  â”Š29â”Š\n+â”Š  â”Š30â”Š    // Start playing animation\n+â”Š  â”Š31â”Š    this.splashAnim.play();\n â”Š 7â”Š32â”Š  }\n â”Š 8â”Š33â”Š\n â”Š 9â”Š34â”Š  load(assetsLoader) {\n```\n```diff\n@@ -14,6 +39,10 @@\n â”Š14â”Š39â”Š  }\n â”Š15â”Š40â”Š\n â”Š16â”Š41â”Š  draw(context) {\n-â”Š17â”Š  â”Š    this.splashSprite.draw(context);\n+â”Š  â”Š42â”Š    this.splashAnim.draw(context);\n+â”Š  â”Š43â”Š  }\n+â”Š  â”Š44â”Š\n+â”Š  â”Š45â”Š  update(span) {\n+â”Š  â”Š46â”Š    this.splashAnim.update(span);\n â”Š18â”Š47â”Š  }\n â”Š19â”Š48â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nThe following key-frames illustrate the nodes of the animation we've just created:\n\n    width: 0\n    height: 0\n    opacity: 0\n\n![logo-empty](https://cloud.githubusercontent.com/assets/7648874/21583394/ee7a1dec-d065-11e6-80ce-fdd37c4b5dbb.png)\n\n    width: 225\n    height: 175\n    opacity: 1\n\n![logo-half](https://cloud.githubusercontent.com/assets/7648874/21583396/ee9bdf68-d065-11e6-95fb-4cf5ed58a9de.png)\n\n    width: 342\n    height: 266\n    opacity: 1\n\n![logo-full](https://cloud.githubusercontent.com/assets/7648874/21583395/ee7b3754-d065-11e6-9646-476d196a6412.png)"
          },
          {
            "manualTitle": "Step 4: Creating a main menu screen using a font engine",
            "stepRevision": "f88428bffcdf2bcf269b9cc15837cc40e0ed9caf",
            "manualView": "![snake-demo-menu-small](https://cloud.githubusercontent.com/assets/7648874/21074099/e72a81bc-bed6-11e6-98cb-329dc12a4b06.gif)\n\nIn this step we will be creating the main menu screen as shown above. The main menu screen is a simple screen which will show the logo of the game and an instruction text saying `Press a key to start`. We will be using a simple texture to show the game-logo and we will use the key-frame animation engine to show a flickering animation of the instruction text. The instruction text is the main part of this step, since it is made out of a font file (`.ttf`) and the text is auto-generated, a general solution which can serve us in many situations. We will start by implementing the main menu using static assets, which means that we will use a texture to show the instructions text, and later on we will implement the generic solution I've just mentioned. First, we will download the necessary assets:\n\n    resources/assets/textures$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/assets/textures/instructions.png\n    resources/assets/textures$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/assets/textures/logo.png\n\nAnd then we will implement the initial main menu screen:\n\n[{]: <helper> (diffStep 4.2)\n\n#### [Step 4.2: Create initial main menu screen](https://github.com/DAB0mB/radial-snake/commit/ed79de7)\n\n##### Added resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;menu&#x2F;index.js\n```diff\n@@ -0,0 +1,44 @@\n+â”Š  â”Š 1â”ŠGame.Screens.Menu = class Menu extends Engine.Screen {\n+â”Š  â”Š 2â”Š  initialize() {\n+â”Š  â”Š 3â”Š    // Initialize snake logo sprite\n+â”Š  â”Š 4â”Š    this.logoSprite = new Engine.Sprite(this.assets.logoTexture);\n+â”Š  â”Š 5â”Š    this.logoSprite.setPercentage(\"width\", this.width, 30, \"height\");\n+â”Š  â”Š 6â”Š\n+â”Š  â”Š 7â”Š    // Initialize instructions sprite\n+â”Š  â”Š 8â”Š    let instructionsSprite = new Engine.Sprite(this.assets.instructionsTexture);\n+â”Š  â”Š 9â”Š    instructionsSprite.align = \"center\";\n+â”Š  â”Š10â”Š    instructionsSprite.setPercentage(\"width\", this.width, 35, \"height\");\n+â”Š  â”Š11â”Š    instructionsSprite.x = this.width / 2;\n+â”Š  â”Š12â”Š    instructionsSprite.y = this.height / 2;\n+â”Š  â”Š13â”Š\n+â”Š  â”Š14â”Š    // Create flickering animation for instructions sprite\n+â”Š  â”Š15â”Š    this.instructionsAnim = new Engine.Animations.Keyframe(instructionsSprite, [\n+â”Š  â”Š16â”Š      {\n+â”Š  â”Š17â”Š        opacity: 1,\n+â”Š  â”Š18â”Š        frame: 0\n+â”Š  â”Š19â”Š      },\n+â”Š  â”Š20â”Š      {\n+â”Š  â”Š21â”Š        opacity: 0,\n+â”Š  â”Š22â”Š        frame: 2000\n+â”Š  â”Š23â”Š      }\n+â”Š  â”Š24â”Š    ]);\n+â”Š  â”Š25â”Š\n+â”Š  â”Š26â”Š    // Play it repeatedly, back and forth\n+â”Š  â”Š27â”Š    this.instructionsAnim.repetitionMode = \"full\";\n+â”Š  â”Š28â”Š    this.instructionsAnim.play();\n+â”Š  â”Š29â”Š  }\n+â”Š  â”Š30â”Š\n+â”Š  â”Š31â”Š  unload() {\n+â”Š  â”Š32â”Š    // Dispose the following assets to prevent memory leaks\n+â”Š  â”Š33â”Š    return [\"logoTexture\", \"instructionsTexture\"];\n+â”Š  â”Š34â”Š  }\n+â”Š  â”Š35â”Š\n+â”Š  â”Š36â”Š  draw(context) {\n+â”Š  â”Š37â”Š    this.logoSprite.draw(context);\n+â”Š  â”Š38â”Š    this.instructionsAnim.draw(context);\n+â”Š  â”Š39â”Š  }\n+â”Š  â”Š40â”Š\n+â”Š  â”Š41â”Š  update(span) {\n+â”Š  â”Š42â”Š    this.instructionsAnim.update(span);\n+â”Š  â”Š43â”Š  }\n+â”Š  â”Š44â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -16,6 +16,7 @@\n â”Š16â”Š16â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/screen.js\"></script>\n â”Š17â”Š17â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/assets_loader.js\"></script>\n â”Š18â”Š18â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n+â”Š  â”Š19â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/menu/index.js\"></script>\n â”Š19â”Š20â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/splash/index.js\"></script>\n â”Š20â”Š21â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n```\n\n[}]: #\n\nThis screen is dependent on several assets which we will load during \"splash screen time\", to save some loading time and for a smooth experience. The main menu screen will be shown automatically once the splash animation has been finished:\n\n[{]: <helper> (diffStep 4.3)\n\n#### [Step 4.3: Queue main menu screen](https://github.com/DAB0mB/radial-snake/commit/cd83a30)\n\n##### Changed resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;splash&#x2F;index.js\n```diff\n@@ -32,10 +32,21 @@\n â”Š32â”Š32â”Š  }\n â”Š33â”Š33â”Š\n â”Š34â”Š34â”Š  load(assetsLoader) {\n+â”Š  â”Š35â”Š    // Load assets\n+â”Š  â”Š36â”Š    let instructionsTexture = assetsLoader.texture(\"/textures/instrucitons\");\n+â”Š  â”Š37â”Š    let logoTexture = assetsLoader.texture(\"/textures/logo\");\n+â”Š  â”Š38â”Š    let splashTexture = assetsLoader.texture(\"/textures/splash\");\n+â”Š  â”Š39â”Š\n+â”Š  â”Š40â”Š    // These are global assets which will be shared among all screens until manually\n+â”Š  â”Š41â”Š    // disposed. We use the time gap created by the splash animation to load necessary\n+â”Š  â”Š42â”Š    // assets without wasting any time\n+â”Š  â”Š43â”Š    this.game.extendAssets({\n+â”Š  â”Š44â”Š      instructionsTexture,\n+â”Š  â”Š45â”Š      logoTexture\n+â”Š  â”Š46â”Š    });\n+â”Š  â”Š47â”Š\n â”Š35â”Š48â”Š    // These are local assets which will be disposed along with the screen\n-â”Š36â”Š  â”Š    return {\n-â”Š37â”Š  â”Š      splashTexture: assetsLoader.texture(\"/textures/splash\")\n-â”Š38â”Š  â”Š    };\n+â”Š  â”Š49â”Š    return { splashTexture };\n â”Š39â”Š50â”Š  }\n â”Š40â”Š51â”Š\n â”Š41â”Š52â”Š  draw(context) {\n```\n```diff\n@@ -43,6 +54,12 @@\n â”Š43â”Š54â”Š  }\n â”Š44â”Š55â”Š\n â”Š45â”Š56â”Š  update(span) {\n-â”Š46â”Š  â”Š    this.splashAnim.update(span);\n+â”Š  â”Š57â”Š    if (this.splashAnim.playing) {\n+â”Š  â”Š58â”Š      this.splashAnim.update(span);\n+â”Š  â”Š59â”Š    }\n+â”Š  â”Š60â”Š    // Once animation has stopped play switch to main menu\n+â”Š  â”Š61â”Š    else {\n+â”Š  â”Š62â”Š      this.game.changeScreen(Game.Screens.Menu);\n+â”Š  â”Š63â”Š    }\n â”Š47â”Š64â”Š  }\n â”Š48â”Š65â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nBy now if you launch the application you should see the main menu screen as described in the beginning. But event though it works, we're not yet finished. We still need to convert the instruction texture into an auto-generated font texture. Obviously, this requires us to download the desired `ttf` file:\n\n    resources/assets/fonts$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/assets/fonts/minecraftia.ttf\n\n> Any font file can be used here, but to save time and effort I already provided you with one\n\n`ttf` is the most common format, but since we're using JavaScript, it would make sense to convert it into a `json` file, and that's exactly what we're going to do. There's a very convenient software called [font-builder](https://github.com/andryblack/fontbuilder), and it can cut fonts, store them in `png` files, along with some user-specified meta-data stored in an `xml` file.\n\n![font-builder](https://camo.githubusercontent.com/b2c95cda825c783f5399d9197599848c33cdfcc8/687474703a2f2f7777772e67616d656465762e72752f66696c65732f696d616765732f73637265656e312e6a706567)\n\nGo over to this website: https://github.com/andryblack/fontbuilder.\nFetch a copy of the `font-builder` repo, and try to convert the `minecraftia.ttf` file into a `png` file. If you want to skip this step, although I wouldn't recommend it, you can download the following files which I already generated myself:\n\n    resources/assets/fonts$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/assets/fonts/minecraftia.png\n    resources/assets/fonts$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/assets/fonts/minecraftia.xml\n\nAs promised, we will be working with a `json` file, not a `ttf` file and not an `xml` file. For this task we will be implementing a font-parser module, which will simply take all the meta-data in the `xml` file and put it into a nice `json` schema:\n\n[{]: <helper> (diffStep 4.6)\n\n#### [Step 4.6: Create font parser so we can convert &#x27;xml&#x27; font format to &#x27;json&#x27;](https://github.com/DAB0mB/radial-snake/commit/66044e9)\n\n##### Added helpers&#x2F;font_parser.js\n```diff\n@@ -0,0 +1,102 @@\n+â”Š   â”Š  1â”Šconst _ = require(\"underscore\");\n+â”Š   â”Š  2â”Šconst Async = require(\"async\");\n+â”Š   â”Š  3â”Šconst Fs = require(\"fs\");\n+â”Š   â”Š  4â”Šconst Path = require(\"path\");\n+â”Š   â”Š  5â”Šconst { DOMParser } = require(\"xmldom\");\n+â”Š   â”Š  6â”Š\n+â”Š   â”Š  7â”Šif (module === require.main) {\n+â”Š   â”Š  8â”Š  let fonstDir = Path.resolve(__dirname, \"../resources/assets/fonts\");\n+â”Š   â”Š  9â”Š  xmlsToJsons(fonstDir, err => { if (err) throw err });\n+â”Š   â”Š 10â”Š}\n+â”Š   â”Š 11â”Š\n+â”Š   â”Š 12â”Š// Gets a dir path containing font xmls and converts them all to jsons\n+â”Š   â”Š 13â”Šfunction xmlsToJsons(path, callback = _.noop) {\n+â”Š   â”Š 14â”Š  Fs.readdir(path, (err, files) => {\n+â”Š   â”Š 15â”Š    if (err) return callback(err);\n+â”Š   â”Š 16â”Š\n+â”Š   â”Š 17â”Š    // Remove all extensions\n+â”Š   â”Š 18â”Š    fileNames = _.uniq(files.map(file => file.split(\".\")[0]));\n+â”Š   â”Š 19â”Š\n+â”Š   â”Š 20â”Š    // Convert each xml individually\n+â”Š   â”Š 21â”Š    Async.each(fileNames, (fileName, next) => {\n+â”Š   â”Š 22â”Š      xmlToJson(`${path}/${fileName}`, next);\n+â”Š   â”Š 23â”Š    },\n+â”Š   â”Š 24â”Š    (err) => {\n+â”Š   â”Š 25â”Š      if (!err) console.log(\n+â”Š   â”Š 26â”Š        'All fonts have been successfully parsed!'\n+â”Š   â”Š 27â”Š      );\n+â”Š   â”Š 28â”Š\n+â”Š   â”Š 29â”Š      callback(err);\n+â”Š   â”Š 30â”Š    });\n+â”Š   â”Š 31â”Š  });\n+â”Š   â”Š 32â”Š}\n+â”Š   â”Š 33â”Š\n+â”Š   â”Š 34â”Š// Gets a font xml and converts it to json\n+â”Š   â”Š 35â”Šfunction xmlToJson(path, callback = _.noop) {\n+â”Š   â”Š 36â”Š  Async.waterfall([\n+â”Š   â”Š 37â”Š    (next) => {\n+â”Š   â”Š 38â”Š      Fs.readFile(`${path}.xml`, function(err, xmlBuffer) {\n+â”Š   â”Š 39â”Š        if (err) return next(err);\n+â”Š   â”Š 40â”Š\n+â”Š   â”Š 41â”Š        let json = {\n+â”Š   â”Š 42â”Š          chars: {}\n+â”Š   â”Š 43â”Š        };\n+â”Š   â”Š 44â”Š\n+â”Š   â”Š 45â”Š        let xml = xmlBuffer.toString();\n+â”Š   â”Š 46â”Š        let doc = new DOMParser().parseFromString(xml);\n+â”Š   â”Š 47â”Š        let fontDoc = doc.getElementsByTagName(\"Font\")[0];\n+â”Š   â”Š 48â”Š        let charsDoc = fontDoc.getElementsByTagName(\"Char\");\n+â”Š   â”Š 49â”Š\n+â”Š   â”Š 50â”Š        // Compose meta-data about font like size and family\n+â”Š   â”Š 51â”Š        _.each(fontDoc.attributes, (attr) => {\n+â”Š   â”Š 52â”Š          json[attr.name] = parseInt(attr.value) || attr.value;\n+â”Š   â”Š 53â”Š        });\n+â”Š   â”Š 54â”Š\n+â”Š   â”Š 55â”Š        // Compose data about each character in font\n+â”Š   â”Š 56â”Š        _.each(charsDoc, (charDoc) => {\n+â”Š   â”Š 57â”Š          let charCode = charDoc.getAttribute(\"code\");\n+â”Š   â”Š 58â”Š\n+â”Š   â”Š 59â”Š          let char = json.chars[charCode] = {\n+â”Š   â”Š 60â”Š            rect: rect = {},\n+â”Š   â”Š 61â”Š            offset: offset = {},\n+â”Š   â”Š 62â”Š            width: parseInt(charDoc.getAttribute(\"width\"))\n+â”Š   â”Š 63â”Š          };\n+â”Š   â”Š 64â”Š\n+â”Š   â”Š 65â”Š          [\n+â”Š   â”Š 66â”Š            rect.x,\n+â”Š   â”Š 67â”Š            rect.y,\n+â”Š   â”Š 68â”Š            rect.width,\n+â”Š   â”Š 69â”Š            rect.height\n+â”Š   â”Š 70â”Š          ] = extractIntegers(charDoc.getAttribute(\"rect\"));\n+â”Š   â”Š 71â”Š\n+â”Š   â”Š 72â”Š          [offset.x, offset.y] = extractIntegers(charDoc.getAttribute(\"offset\"));\n+â”Š   â”Š 73â”Š        });\n+â”Š   â”Š 74â”Š\n+â”Š   â”Š 75â”Š        next(null, JSON.stringify(json, null, 2));\n+â”Š   â”Š 76â”Š      });\n+â”Š   â”Š 77â”Š    },\n+â”Š   â”Š 78â”Š    (json, next) => {\n+â”Š   â”Š 79â”Š      // Once finished, write json into file\n+â”Š   â”Š 80â”Š      Fs.writeFile(path + \".json\", json, (err) => {\n+â”Š   â”Š 81â”Š        next(err);\n+â”Š   â”Š 82â”Š      });\n+â”Š   â”Š 83â”Š    }\n+â”Š   â”Š 84â”Š  ], (err) => {\n+â”Š   â”Š 85â”Š    if (!err) console.log(\n+â”Š   â”Š 86â”Š      `Font ${path} has been successfully parsed...`\n+â”Š   â”Š 87â”Š    );\n+â”Š   â”Š 88â”Š\n+â”Š   â”Š 89â”Š    callback(err);\n+â”Š   â”Š 90â”Š  });\n+â”Š   â”Š 91â”Š};\n+â”Š   â”Š 92â”Š\n+â”Š   â”Š 93â”Š// Converts an string of numbers to array of numbers\n+â”Š   â”Š 94â”Š// e.g. extractIntegers(\"1 2 3\") -> [1, 2, 3]\n+â”Š   â”Š 95â”Šfunction extractIntegers(srcstr) {\n+â”Š   â”Š 96â”Š  return srcstr.split(\" \").map((substr) => parseInt(substr));\n+â”Š   â”Š 97â”Š}\n+â”Š   â”Š 98â”Š\n+â”Š   â”Š 99â”Šmodule.exports = {\n+â”Š   â”Š100â”Š  xmlToJson,\n+â”Š   â”Š101â”Š  xmlsToJsons\n+â”Š   â”Š102â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nThis script will take everything that's in the `fonts` dir and parser it as mentioned above. Before we can user this script we will need to install some NPM dependencies like so:\n\n    $ npm install --save underscore\n    $ npm install --save xmldom\n\nAnd instead of running the parser manually over and over again whenever we wanna use it, we will use the following `NPM` script instead:\n\n[{]: <helper> (diffStep 4.8)\n\n#### [Step 4.8: Add font parsing npm scripts](https://github.com/DAB0mB/radial-snake/commit/7a1cf81)\n\n##### Changed package.json\n```diff\n@@ -7,7 +7,8 @@\n â”Š 7â”Š 7â”Š  },\n â”Š 8â”Š 8â”Š  \"private\": true,\n â”Š 9â”Š 9â”Š  \"scripts\": {\n-â”Š10â”Š  â”Š    \"serve\": \"nodemon server.js\"\n+â”Š  â”Š10â”Š    \"serve\": \"npm run parse:fonts && nodemon server.js\",\n+â”Š  â”Š11â”Š    \"build:fonts\": \"node helpers/font_parser.js\"\n â”Š11â”Š12â”Š  },\n â”Š12â”Š13â”Š  \"dependencies\": {\n â”Š13â”Š14â”Š    \"async\": \"^2.1.4\",\n```\n\n[}]: #\n\nWe don't want the generated fonts to be included by `git` since they are going to automatically regenerate themselves, therefore we gonna add the following ignore rule:\n\n[{]: <helper> (diffStep 4.9)\n\n#### [Step 4.9: Add rule to to git-ignore parsed fonts](https://github.com/DAB0mB/radial-snake/commit/bbf7647)\n\n##### Changed .gitignore\n```diff\n@@ -1,2 +1,3 @@\n â”Š1â”Š1â”Šnode_modules\n-â”Š2â”Š â”Šnpm-debug.logðŸš«â†µ\n+â”Š â”Š2â”Šnpm-debug.log\n+â”Š â”Š3â”Šresources/assets/fonts/*.jsonðŸš«â†µ\n```\n\n[}]: #\n\nNow we will build our `minecraftia` font by simply running:\n\n    $ npm run build:fonts\n\nAnd voila! We have a freshly created `json` file which we can work with. You can also get it from here:\n\n    resources/assets/fonts$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/assets/fonts/minecraftia.json\n\nNow that we have our assets finally ready we can go ahead and focus on extending the engine which powers up our game. We need some sort of a generic font-engine which will know how to load a font file and create a text-sprite out of it. First we will implement a class called `Restorable`, which shares the same restore API as the CanvasRenderingContext2D and will give us the ability to save and restore the font's state (More information can be found [here](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/restore)):\n\n[{]: <helper> (diffStep 4.11)\n\n#### [Step 4.11: Add &#x27;Restorable&#x27; class](https://github.com/DAB0mB/radial-snake/commit/8239c01)\n\n##### Added resources&#x2F;scripts&#x2F;engine&#x2F;restorable.js\n```diff\n@@ -0,0 +1,21 @@\n+â”Š  â”Š 1â”ŠEngine.Restorable = class Restorable {\n+â”Š  â”Š 2â”Š  // Acts the same as canvas's save() and restore() API.\n+â”Š  â”Š 3â”Š  // 'restorable' props are defined in the constructor\n+â”Š  â”Š 4â”Š  constructor(...restorableProps) {\n+â”Š  â”Š 5â”Š    this._restorableProps = restorableProps;\n+â”Š  â”Š 6â”Š    this._restorableStates = [];\n+â”Š  â”Š 7â”Š  }\n+â”Š  â”Š 8â”Š\n+â”Š  â”Š 9â”Š  // Save current state in the stack\n+â”Š  â”Š10â”Š  save() {\n+â”Š  â”Š11â”Š    this._restorableStates.push(this._restorableProps.reduce((state, prop) => {\n+â”Š  â”Š12â”Š      state[prop] = this[prop];\n+â”Š  â”Š13â”Š      return state;\n+â”Š  â”Š14â”Š    }, {}));\n+â”Š  â”Š15â”Š  }\n+â”Š  â”Š16â”Š\n+â”Š  â”Š17â”Š  // Pop most recent state and apply it\n+â”Š  â”Š18â”Š  restore() {\n+â”Š  â”Š19â”Š    _.extend(this, this._restorableStates.pop());\n+â”Š  â”Š20â”Š  }\n+â”Š  â”Š21â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -9,6 +9,7 @@\n â”Š 9â”Š 9â”Š\n â”Š10â”Š10â”Š    <!-- Scripts -->\n â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n+â”Š  â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/restorable.js\"></script>\n â”Š12â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/sprite.js\"></script>\n â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/animations/keyframe.js\"></script>\n â”Š14â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/key_states.js\"></script>\n```\n\n[}]: #\n\nAnd now we can go ahead and implement the font class itself:\n\n[{]: <helper> (diffStep 4.12)\n\n#### [Step 4.12: Create font engine](https://github.com/DAB0mB/radial-snake/commit/7a1f2c7)\n\n##### Added resources&#x2F;scripts&#x2F;engine&#x2F;font.js\n```diff\n@@ -0,0 +1,133 @@\n+â”Š   â”Š  1â”ŠEngine.Font = class Font extends Engine.Restorable {\n+â”Š   â”Š  2â”Š  // The src property acts just line native image's src property.\n+â”Š   â”Š  3â”Š  // Once finished loading, the onload() callback will be invoked\n+â”Š   â”Š  4â”Š  get src() {\n+â”Š   â”Š  5â”Š    return this._src;\n+â”Š   â”Š  6â”Š  }\n+â”Š   â”Š  7â”Š\n+â”Š   â”Š  8â”Š  set src(src) {\n+â”Š   â”Š  9â”Š    this._src = src;\n+â”Š   â”Š 10â”Š\n+â”Š   â”Š 11â”Š    // The font is actually an image, therefore we have 2 onload callbacks.\n+â”Š   â”Š 12â”Š    // The first one is the native one which will always be run,\n+â”Š   â”Š 13â”Š    // and the second one is a user defined one\n+â”Š   â”Š 14â”Š    if (this.onload) var done = _.after(2, this.onload);\n+â”Š   â”Š 15â”Š\n+â”Š   â”Š 16â”Š    this.atlas = new Image();\n+â”Š   â”Š 17â”Š    this.atlas.onload = done;\n+â”Š   â”Š 18â”Š    this.atlas.src = `${src}.png`;\n+â”Š   â”Š 19â”Š\n+â”Š   â”Š 20â”Š    // Get json based on the given src property\n+â”Š   â”Š 21â”Š    $.getJSON(`${src}.json`, data => {\n+â”Š   â”Š 22â”Š      this.data = data;\n+â”Š   â”Š 23â”Š      if (done) done();\n+â”Š   â”Š 24â”Š    });\n+â”Š   â”Š 25â”Š\n+â”Š   â”Š 26â”Š    return this._src;\n+â”Š   â”Š 27â”Š  }\n+â”Š   â”Š 28â”Š\n+â”Š   â”Š 29â”Š  constructor() {\n+â”Š   â”Š 30â”Š    // The color property is the only restorable property\n+â”Š   â”Š 31â”Š    super(\"color\");\n+â”Š   â”Š 32â”Š    this.charSpritesCache = {};\n+â”Š   â”Š 33â”Š  }\n+â”Š   â”Š 34â”Š\n+â”Š   â”Š 35â”Š  // Creates a texture out of the font with the given text\n+â”Š   â”Š 36â”Š  createTexture(text, options = {}) {\n+â”Š   â”Š 37â”Š    let { noOffsets, noSpaces } = options;\n+â”Š   â”Š 38â”Š    let canvas = document.createElement(\"canvas\");\n+â”Š   â”Š 39â”Š    let context = canvas.getContext(\"2d\");\n+â”Š   â”Š 40â”Š    let height = canvas.height = this.data.height;\n+â”Š   â”Š 41â”Š\n+â”Š   â”Š 42â”Š    // Calculates the width of the canvas based on the text and the font\n+â”Š   â”Š 43â”Š    let width = canvas.width = _.reduce(text, (width, c) => {\n+â”Š   â”Š 44â”Š      // No-space option means that the characters will be\n+â”Š   â”Š 45â”Š      // drawn with no any space between them\n+â”Š   â”Š 46â”Š      if (noSpaces) {\n+â”Š   â”Š 47â”Š        return width + this.getCharSprite(c).width;\n+â”Š   â”Š 48â”Š      }\n+â”Š   â”Š 49â”Š\n+â”Š   â”Š 50â”Š      return width + this.data.chars[c].width;\n+â”Š   â”Š 51â”Š    }, 0);\n+â”Š   â”Š 52â”Š\n+â”Š   â”Š 53â”Š    // A custom size can be specified for a font as well\n+â”Š   â”Š 54â”Š    if (this.size) {\n+â”Š   â”Š 55â”Š      let ratio = this.size / this.data.size;\n+â”Š   â”Š 56â”Š      canvas.height *= ratio;\n+â”Š   â”Š 57â”Š      canvas.width *= ratio;\n+â”Š   â”Š 58â”Š      context.scale(ratio, ratio);\n+â”Š   â”Š 59â”Š    }\n+â”Š   â”Š 60â”Š\n+â”Š   â”Š 61â”Š    // No we are going to draw each char on the canvas individually,\n+â”Š   â”Š 62â”Š    // naturally, there should be an offset after we draw each character.\n+â”Š   â”Š 63â”Š    // This variable will be used to calculate the offset\n+â”Š   â”Š 64â”Š    let offset = 0;\n+â”Š   â”Š 65â”Š\n+â”Š   â”Š 66â”Š    // Get for each char\n+â”Š   â”Š 67â”Š    _.map(text, (char) => {\n+â”Š   â”Š 68â”Š      return this.getCharSprite(char);\n+â”Š   â”Š 69â”Š    })\n+â”Š   â”Š 70â”Š    // Start drawing each char on the canvas\n+â”Š   â”Š 71â”Š    .forEach((charSprite, index) => {\n+â”Š   â”Š 72â”Š      let charData = this.data.chars[text.charAt(index)];\n+â”Š   â”Š 73â”Š\n+â”Š   â”Š 74â”Š      // Each char in the font xml has a native offset in addition to its rectangle.\n+â”Š   â”Š 75â”Š      // This option will disable the calculation of the native offset\n+â”Š   â”Š 76â”Š      if (noOffsets) {\n+â”Š   â”Š 77â”Š        charSprite.draw(context, offset);\n+â”Š   â”Š 78â”Š      }\n+â”Š   â”Š 79â”Š      else {\n+â”Š   â”Š 80â”Š        charSprite.draw(context, offset + charData.offset.x, charData.offset.y);\n+â”Š   â”Š 81â”Š      }\n+â”Š   â”Š 82â”Š\n+â”Š   â”Š 83â”Š      if (noSpaces) {\n+â”Š   â”Š 84â”Š        offset += charSprite.width;\n+â”Š   â”Š 85â”Š      }\n+â”Š   â”Š 86â”Š      else {\n+â”Š   â”Š 87â”Š        offset += charData.width;\n+â”Š   â”Š 88â”Š      }\n+â”Š   â”Š 89â”Š\n+â”Š   â”Š 90â”Š      // A color for the font can be specified as well\n+â”Š   â”Š 91â”Š      if (this.color) {\n+â”Š   â”Š 92â”Š        let overlayCanvas = document.createElement(\"canvas\");\n+â”Š   â”Š 93â”Š        let overlayContext = overlayCanvas.getContext(\"2d\");\n+â”Š   â”Š 94â”Š        overlayCanvas.width = width;\n+â”Š   â”Š 95â”Š        overlayCanvas.height = height;\n+â”Š   â”Š 96â”Š        overlayContext.beginPath();\n+â”Š   â”Š 97â”Š        overlayContext.rect(0, 0, width, height);\n+â”Š   â”Š 98â”Š        overlayContext.fillStyle = this.color;\n+â”Š   â”Š 99â”Š        overlayContext.fill();\n+â”Š   â”Š100â”Š\n+â”Š   â”Š101â”Š        context.save();\n+â”Š   â”Š102â”Š        context.globalCompositeOperation = \"source-in\";\n+â”Š   â”Š103â”Š        context.drawImage(overlayCanvas, 0, 0);\n+â”Š   â”Š104â”Š        context.restore();\n+â”Š   â”Š105â”Š      }\n+â”Š   â”Š106â”Š    });\n+â”Š   â”Š107â”Š\n+â”Š   â”Š108â”Š    // The canvas will be treated like an image\n+â”Š   â”Š109â”Š    return canvas;\n+â”Š   â”Š110â”Š  }\n+â”Š   â”Š111â”Š\n+â”Š   â”Š112â”Š  // Gets a sprite of the given char, using the current font\n+â”Š   â”Š113â”Š  getCharSprite(char) {\n+â”Š   â”Š114â”Š    // If char is already stored in cache, abort calculation and return it\n+â”Š   â”Š115â”Š    if (this.charSpritesCache[char]) return this.charSpritesCache[char];\n+â”Š   â”Š116â”Š\n+â”Š   â”Š117â”Š    // This data is fetched by the given json\n+â”Š   â”Š118â”Š    let { x, y, width, height } = this.data.chars[char].rect;\n+â”Š   â”Š119â”Š    // Creating a canvas which we will use to draw on,\n+â”Š   â”Š120â”Š    // but it is used exactly like an image afterwards\n+â”Š   â”Š121â”Š    let canvas = document.createElement(\"canvas\");\n+â”Š   â”Š122â”Š    let context = canvas.getContext(\"2d\");\n+â”Š   â”Š123â”Š\n+â”Š   â”Š124â”Š    // The canvas will have the same dimensions as the font\n+â”Š   â”Š125â”Š    canvas.width = width;\n+â”Š   â”Š126â”Š    canvas.height = height;\n+â”Š   â”Š127â”Š    // Draw a cropped image from the atlas, this image contains the char font\n+â”Š   â”Š128â”Š    context.drawImage(this.atlas, x, y, width, height, 0, 0, width, height);\n+â”Š   â”Š129â”Š\n+â”Š   â”Š130â”Š    // Store in cache and return it\n+â”Š   â”Š131â”Š    return this.charSpritesCache[char] = new Engine.Sprite(canvas);\n+â”Š   â”Š132â”Š  }\n+â”Š   â”Š133â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -10,6 +10,7 @@\n â”Š10â”Š10â”Š    <!-- Scripts -->\n â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n â”Š12â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/restorable.js\"></script>\n+â”Š  â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/font.js\"></script>\n â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/sprite.js\"></script>\n â”Š14â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/animations/keyframe.js\"></script>\n â”Š15â”Š16â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/key_states.js\"></script>\n```\n\n[}]: #\n\nThe font API shares a similar API as [HTMLImageElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/Image), once we set the `src` property the font will start loading itself, and the `onload` user-defined callback should be called once finished. Another neat feature would be the `createTexture` method, which takes a string as its first argument, representing the text that we would like to generate, and returns an instance of the `Sprite` class.\n\nWe will also be adding the option to load some font assets in our asset-loader:\n\n[{]: <helper> (diffStep 4.13)\n\n#### [Step 4.13: Add a font loading option to &#x27;AssetLoader&#x27;](https://github.com/DAB0mB/radial-snake/commit/a9d73cc)\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;assets_loader.js\n```diff\n@@ -10,4 +10,12 @@\n â”Š10â”Š10â”Š    image.src = `${path}.png`;\n â”Š11â”Š11â”Š    return image;\n â”Š12â”Š12â”Š  }\n+â”Š  â”Š13â”Š\n+â”Š  â”Š14â”Š  // Load font\n+â”Š  â”Š15â”Š  font(path) {\n+â”Š  â”Š16â”Š    let font = new Engine.Font();\n+â”Š  â”Š17â”Š    font.onload = this.next();\n+â”Š  â”Š18â”Š    font.src = path;\n+â”Š  â”Š19â”Š    return font;\n+â”Š  â”Š20â”Š  }\n â”Š13â”Š21â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nAnd replace the instructions texture loading with a `minecraftia` font loading in the initial splash screen:\n\n[{]: <helper> (diffStep 4.14)\n\n#### [Step 4.14: Load &#x27;minecraftia&#x27; font in splash screen](https://github.com/DAB0mB/radial-snake/commit/231a68f)\n\n##### Changed resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;splash&#x2F;index.js\n```diff\n@@ -33,7 +33,7 @@\n â”Š33â”Š33â”Š\n â”Š34â”Š34â”Š  load(assetsLoader) {\n â”Š35â”Š35â”Š    // Load assets\n-â”Š36â”Š  â”Š    let instructionsTexture = assetsLoader.texture(\"/textures/instrucitons\");\n+â”Š  â”Š36â”Š    let minecraftiaFont = assetsLoader.font(\"/fonts/minecraftia\");\n â”Š37â”Š37â”Š    let logoTexture = assetsLoader.texture(\"/textures/logo\");\n â”Š38â”Š38â”Š    let splashTexture = assetsLoader.texture(\"/textures/splash\");\n â”Š39â”Š39â”Š\n```\n```diff\n@@ -41,7 +41,7 @@\n â”Š41â”Š41â”Š    // disposed. We use the time gap created by the splash animation to load necessary\n â”Š42â”Š42â”Š    // assets without wasting any time\n â”Š43â”Š43â”Š    this.game.extendAssets({\n-â”Š44â”Š  â”Š      instructionsTexture,\n+â”Š  â”Š44â”Š      minecraftiaFont,\n â”Š45â”Š45â”Š      logoTexture\n â”Š46â”Š46â”Š    });\n```\n\n[}]: #\n\nNow it can use us in the main menu screen where we will create a text-sprite saying `Press a key to start`, just like the instruction sprite we're about to replace:\n\n[{]: <helper> (diffStep 4.15)\n\n#### [Step 4.15: Replace texture usage with font usage in main menu screen](https://github.com/DAB0mB/radial-snake/commit/a769b81)\n\n##### Changed resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;menu&#x2F;index.js\n```diff\n@@ -5,7 +5,8 @@\n â”Š 5â”Š 5â”Š    this.logoSprite.setPercentage(\"width\", this.width, 30, \"height\");\n â”Š 6â”Š 6â”Š\n â”Š 7â”Š 7â”Š    // Initialize instructions sprite\n-â”Š 8â”Š  â”Š    let instructionsSprite = new Engine.Sprite(this.assets.instructionsTexture);\n+â”Š  â”Š 8â”Š    let instructionsTexture = this.assets.minecraftiaFont.createTexture(\"Press a key to start\");\n+â”Š  â”Š 9â”Š    let instructionsSprite = new Engine.Sprite(instructionsTexture);\n â”Š 9â”Š10â”Š    instructionsSprite.align = \"center\";\n â”Š10â”Š11â”Š    instructionsSprite.setPercentage(\"width\", this.width, 35, \"height\");\n â”Š11â”Š12â”Š    instructionsSprite.x = this.width / 2;\n```\n```diff\n@@ -30,7 +31,7 @@\n â”Š30â”Š31â”Š\n â”Š31â”Š32â”Š  unload() {\n â”Š32â”Š33â”Š    // Dispose the following assets to prevent memory leaks\n-â”Š33â”Š  â”Š    return [\"logoTexture\", \"instructionsTexture\"];\n+â”Š  â”Š34â”Š    return \"logoTexture\";\n â”Š34â”Š35â”Š  }\n â”Š35â”Š36â”Š\n â”Š36â”Š37â”Š  draw(context) {\n```\n```diff\n@@ -41,4 +42,8 @@\n â”Š41â”Š42â”Š  update(span) {\n â”Š42â”Š43â”Š    this.instructionsAnim.update(span);\n â”Š43â”Š44â”Š  }\n+â”Š  â”Š45â”Š\n+â”Š  â”Š46â”Š  update(span) {\n+â”Š  â”Š47â”Š    this.instructionsAnim.update(span);\n+â”Š  â”Š48â”Š  }\n â”Š44â”Š49â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nIt shouldn't look any different from the beginning of the step where we manually drew the instruction texture, but in the next steps we will be using the font-engine a lot, and you will be thankful for what we've just did."
          },
          {
            "manualTitle": "Step 5: Creating a snake and related geometry shapes",
            "stepRevision": "ad178e03e276b088c96d6f67889db379ad201e3e",
            "manualView": "![snake-illustrate](https://cloud.githubusercontent.com/assets/7648874/21074115/46ef4466-bed7-11e6-9d5d-12fa6d43147b.gif)\n\nIn this step we will be creating all the necessary geometry shapes to form a snake; we're basically implementing the right infrastructure so in the next step we will be able to implement the game screen with ease. What exactly do I mean by \"geometry shapes\"? Well, our snake will be made out of circles, and lines. If we don't press any buttons at all, the snake should move forward at a straight line, and once we press on one of the arrow keys, the snake should move in a circular motion. Not only we want to draw the screen on the canvas, we also want to be able to detect collision with other snakes, since this is a \"Tron\" style game where we gonna fight against an opponent.\n\nKeep in mind that a computer's precision is limited due its [binary representation in memory](https://en.wikipedia.org/wiki/Memory_cell_(binary)). We need to take into consideration that there might be a significant deviation when detecting collisions and intersections between geometry shapes, especially when elapsed time is not always guaranteed to stay precise. To handle these deviation issues, we're gonna create some utility functions and place then in a new module called `Utils`:\n\n[{]: <helper> (diffStep 5.1)\n\n#### [Step 5.1: Create utilities module](https://github.com/DAB0mB/radial-snake/commit/58ae99a)\n\n##### Added resources&#x2F;scripts&#x2F;utils.js\n```diff\n@@ -0,0 +1,68 @@\n+â”Š  â”Š 1â”Š// A wrapper function for our utilities which will enable chaining\n+â”Š  â”Š 2â”Š// e.g. Utils().mod().trim().isBetween()...\n+â”Š  â”Š 3â”ŠUtils = function Utils(context) {\n+â”Š  â”Š 4â”Š  const chain = {};\n+â”Š  â”Š 5â”Š\n+â”Š  â”Š 6â”Š  Object.keys(Utils).forEach((utilName) => {\n+â”Š  â”Š 7â”Š    chain[utilName] = (...args) => {\n+â”Š  â”Š 8â”Š      const result = Utils[utilName](context, ...args);\n+â”Š  â”Š 9â”Š      return Utils(result);\n+â”Š  â”Š10â”Š    };\n+â”Š  â”Š11â”Š  });\n+â”Š  â”Š12â”Š\n+â”Š  â”Š13â”Š  // Returns the result of the chaining\n+â”Š  â”Š14â”Š  chain.value = () => context;\n+â”Š  â”Š15â”Š\n+â”Š  â”Š16â”Š  return chain;\n+â”Š  â”Š17â”Š};\n+â”Š  â”Š18â”Š\n+â”Š  â”Š19â”Š// Fixed modulo method which can calculate modulo of negative numbers properly\n+â”Š  â”Š20â”Š// e.g. (-803).mod(800) returns 797\n+â”Š  â”Š21â”ŠUtils.mod = function (context, num) {\n+â”Š  â”Š22â”Š  return ((context % num) + num) % num;\n+â”Š  â”Š23â”Š};\n+â”Š  â”Š24â”Š\n+â”Š  â”Š25â”Š// Trims number and leaves the number of decimals specified.\n+â”Š  â”Š26â”Š// The \"mode\" argument specifies which math function should be invoked\n+â”Š  â”Š27â”Š// right after the number has been trimmed.\n+â”Š  â”Š28â”Š// e.g. 12.12345.trim(3, \"ceil\") returns 12.124\n+â”Š  â”Š29â”ŠUtils.trim = function (context, decimals, mode = \"round\") {\n+â”Š  â”Š30â”Š  return Math[mode](context * Math.pow(10, decimals)) / Math.pow(10, decimals);\n+â”Š  â”Š31â”Š};\n+â”Š  â”Š32â”Š\n+â”Š  â”Š33â”Š// Tells if number is in specified range based on given precision.\n+â”Š  â”Š34â”Š// See the \"compare\" method for more information about precision\n+â”Š  â”Š35â”ŠUtils.isBetween = function (context, num1, num2, precision) {\n+â”Š  â”Š36â”Š  return Utils.compare(context, Math.min(num1, num2), \">=\", precision) &&\n+â”Š  â”Š37â”Š         Utils.compare(context, Math.max(num1, num2), \"<=\", precision);\n+â”Š  â”Š38â”Š};\n+â”Š  â”Š39â”Š\n+â”Š  â”Š40â”Š// Initiates comparison operator between context number and a given number, only here\n+â”Š  â”Š41â”Š// a precision can be specified\n+â”Š  â”Š42â”ŠUtils.compare = function (context, num, method, precision = method) {\n+â”Š  â”Š43â”Š  switch (precision) {\n+â”Š  â”Š44â”Š    // Fixed precision, \"almost equal\" with a deviation of Îµ\n+â”Š  â”Š45â”Š    case \"f\":\n+â”Š  â”Š46â”Š      switch (method) {\n+â”Š  â”Š47â”Š        case \"<\": case \"<=\": return context <= num + Number.EPSILON;\n+â”Š  â”Š48â”Š        case \">\": case \">=\": return context >= num - Number.EPSILON;\n+â”Š  â”Š49â”Š        default: return Math.abs(context - num) <= Number.EPSILON;\n+â”Š  â”Š50â”Š      }\n+â”Š  â”Š51â”Š    // Pixel precision, round comparison\n+â”Š  â”Š52â”Š    case \"px\":\n+â”Š  â”Š53â”Š      switch (method) {\n+â”Š  â”Š54â”Š        case \"<\": case \"<=\": return Math.round(context) <= Math.round(num);\n+â”Š  â”Š55â”Š        case \">\": case \">=\": return Math.round(context) >= Math.round(num);\n+â”Š  â”Š56â”Š        default: return Math.round(context) == Math.round(num);\n+â”Š  â”Š57â”Š      }\n+â”Š  â”Š58â”Š    // Exact precision\n+â”Š  â”Š59â”Š    default:\n+â”Š  â”Š60â”Š      switch (method) {\n+â”Š  â”Š61â”Š        case \"<\": return context < num;\n+â”Š  â”Š62â”Š        case \"<=\": return context <= num;\n+â”Š  â”Š63â”Š        case \">\": return context > num;\n+â”Š  â”Š64â”Š        case \">=\": return context >= num;\n+â”Š  â”Š65â”Š        default: return context === num;\n+â”Š  â”Š66â”Š      }\n+â”Š  â”Š67â”Š  }\n+â”Š  â”Š68â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -8,6 +8,7 @@\n â”Š 8â”Š 8â”Š    <script type=\"text/javascript\" src=\"/libs/underscore.js\"></script>\n â”Š 9â”Š 9â”Š\n â”Š10â”Š10â”Š    <!-- Scripts -->\n+â”Š  â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/utils.js\"></script>\n â”Š11â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n â”Š12â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/restorable.js\"></script>\n â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/font.js\"></script>\n```\n\n[}]: #\n\nNow we would like to start implementing the first class representation for a line, and for that we're requires to add a new module called `Geometry` to the `Engine` namespace:\n\n[{]: <helper> (diffStep 5.2)\n\n#### [Step 5.2: Add &#x27;Shapes&#x27; module to &#x27;Engine&#x27; namespace](https://github.com/DAB0mB/radial-snake/commit/4ed2788)\n\n##### Changed resources&#x2F;scripts&#x2F;namespaces.js\n```diff\n@@ -3,5 +3,6 @@\n â”Š3â”Š3â”Š};\n â”Š4â”Š4â”Š\n â”Š5â”Š5â”ŠEngine = {\n-â”Š6â”Š â”Š  Animations: {}\n+â”Š â”Š6â”Š  Animations: {},\n+â”Š â”Š7â”Š  Geometry: {}\n â”Š7â”Š8â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nAnd now that we have this module available to use, we can go ahead and implement our first geometry shape class - `Line`:\n\n[{]: <helper> (diffStep 5.3)\n\n#### [Step 5.3: Create &#x27;Line&#x27; class](https://github.com/DAB0mB/radial-snake/commit/fb38ab5)\n\n##### Added resources&#x2F;scripts&#x2F;engine&#x2F;geometry&#x2F;line.js\n```diff\n@@ -0,0 +1,65 @@\n+â”Š  â”Š 1â”ŠEngine.Geometry.Line = class Line {\n+â”Š  â”Š 2â”Š  // x1 - The first point's x value\n+â”Š  â”Š 3â”Š  // y1 - The first point's y value\n+â”Š  â”Š 4â”Š  // x1 - The second point's x value\n+â”Š  â”Š 5â”Š  // y2 - The second point's y value\n+â”Š  â”Š 6â”Š  constructor(x1, y1, x2, y2) {\n+â”Š  â”Š 7â”Š    this.x1 = Utils.trim(x1, 9);\n+â”Š  â”Š 8â”Š    this.y1 = Utils.trim(y1, 9);\n+â”Š  â”Š 9â”Š    this.x2 = Utils.trim(x2, 9);\n+â”Š  â”Š10â”Š    this.y2 = Utils.trim(y2, 9);\n+â”Š  â”Š11â”Š  }\n+â”Š  â”Š12â”Š\n+â”Š  â”Š13â”Š  // Draws the line on the given context\n+â”Š  â”Š14â”Š  draw(context) {\n+â”Š  â”Š15â”Š    context.moveTo(this.x1, this.y1);\n+â”Š  â”Š16â”Š    context.lineTo(this.x2, this.y2);\n+â”Š  â”Š17â”Š  }\n+â”Š  â”Š18â”Š\n+â”Š  â”Š19â”Š  // Gets the matching x value for a given y value\n+â”Š  â”Š20â”Š  getX(y) {\n+â”Š  â”Š21â”Š    let x = Utils.trim((((y - this.y1) * (this.x2 - this.x1)) / (this.y2 - this.y1)) + this.x1, 9);\n+â”Š  â”Š22â”Š    if (isNaN(x) || Utils.isBetween(x, this.x1, this.x2)) return x;\n+â”Š  â”Š23â”Š  }\n+â”Š  â”Š24â”Š\n+â”Š  â”Š25â”Š  // Gets the matching y value for a given x value\n+â”Š  â”Š26â”Š  getY(x) {\n+â”Š  â”Š27â”Š    let y = Utils.trim((((x - this.x1) * (this.y2 - this.y1)) / (this.x2 - this.x1)) + this.y1, 9);\n+â”Š  â”Š28â”Š    if (isNaN(y) || Utils.isBetween(y, this.y1, this.y2)) return y;\n+â”Š  â”Š29â”Š  }\n+â”Š  â”Š30â”Š\n+â”Š  â”Š31â”Š  // Returns if line has given point\n+â”Š  â”Š32â”Š  hasPoint(x, y) {\n+â”Š  â”Š33â”Š    if (!this.boundsHavePoint(x, y)) return false;\n+â”Š  â”Š34â”Š    let m = Utils.trim((this.y2 - this.y1) / (this.x2 - this.x1), 9);\n+â”Š  â”Š35â”Š    return (y - this.y1) / (x - this.x1) == m;\n+â”Š  â”Š36â”Š  }\n+â”Š  â”Š37â”Š\n+â”Š  â”Š38â”Š  // Returns if given point is contained by the bounds aka cage of line\n+â”Š  â”Š39â”Š  boundsHavePoint(x, y) {\n+â”Š  â”Š40â”Š    return Utils.isBetween(x, this.x1, this.x2) &&\n+â”Š  â”Š41â”Š           Utils.isBetween(y, this.y1, this.y2);\n+â”Š  â”Š42â”Š  }\n+â”Š  â”Š43â”Š\n+â”Š  â”Š44â”Š  getIntersection(shape) {\n+â”Š  â”Š45â”Š    if (shape instanceof Engine.Geometry.Line)\n+â”Š  â”Š46â”Š      return this.getLineIntersection(shape);\n+â”Š  â”Š47â”Š  }\n+â”Š  â”Š48â”Š\n+â”Š  â”Š49â”Š  // line - line intersection method\n+â”Š  â”Š50â”Š  getLineIntersection(line) {\n+â”Š  â”Š51â”Š    // Escape if lines are parallel\n+â”Š  â”Š52â”Š    if (!(((this.x1 - this.x2) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * (line.x1 - line.x2)))) return;\n+â”Š  â”Š53â”Š\n+â”Š  â”Š54â”Š    // Intersection point formula\n+â”Š  â”Š55â”Š    let x = Utils.trim(((((this.x1 * this.y2) - (this.y1 * this.x2)) * (line.x1 - line.x2)) - ((this.x1 - this.x2) * ((line.x1 * line.y2) - (line.y1 * line.x2)))) /\n+â”Š  â”Š56â”Š        (((this.x1 - this.x2) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * (line.x1 - line.x2))), 9);\n+â”Š  â”Š57â”Š    let y = Utils.trim(((((this.x1 * this.y2) - (this.y1 * this.x2)) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * ((line.x1 * line.y2) - (line.y1 * line.x2)))) /\n+â”Š  â”Š58â”Š        (((this.x1 - this.x2) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * (line.x1 - line.x2))), 9);\n+â”Š  â”Š59â”Š\n+â”Š  â”Š60â”Š    if (Utils.isBetween(x, this.x1, this.x2) && Utils.isBetween(x, line.x1, line.x2) &&\n+â”Š  â”Š61â”Š        Utils.isBetween(y, this.y1, this.y2) && Utils.isBetween(y, line.y1, line.y2)) {\n+â”Š  â”Š62â”Š      return { x, y };\n+â”Š  â”Š63â”Š    }\n+â”Š  â”Š64â”Š  }\n+â”Š  â”Š65â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -10,6 +10,7 @@\n â”Š10â”Š10â”Š    <!-- Scripts -->\n â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/utils.js\"></script>\n â”Š12â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n+â”Š  â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/geometry/line.js\"></script>\n â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/restorable.js\"></script>\n â”Š14â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/font.js\"></script>\n â”Š15â”Š16â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/sprite.js\"></script>\n```\n\n[}]: #\n\nYou can go through the comments of the step above which will guide you through the programmatic aspect of it, but I think it's more important to understand the concept of a line in 2D space. A line is made out of two points, usually represented as `(x1, y1)` and `(x2, y2)`. The slope of the line, usually represented as `m`, can be determined using these two points based on the following formula:\n\n![slope](https://cloud.githubusercontent.com/assets/7648874/21788249/b4c7e41c-d6b4-11e6-9c17-baff66ec6bc8.png)\n\nOnce we have two lines whose `m` is different (Unparalleled) and there is no intersection between the points of which they are represented with (In which case they are united), there must be an intersection point. The intersection point can be found using the following formula:\n\n![line-line](https://cloud.githubusercontent.com/assets/7648874/21787164/c9d83bf0-d6ae-11e6-9846-4fc013eebab3.png)\n\n![line-line-illustration](https://cloud.githubusercontent.com/assets/7648874/21790864/56725cf0-d6c6-11e6-916b-50b1fc0b87af.png)\n\n> See reference: http://mathworld.wolfram.com/Line-LineIntersection.html.\n\nObviously we have some logic here which needs to be tested. To test our `Line` class, we will be using a testing framework called [Jasmine](https://jasmine.github.io/). We first need to download `Jasmine`'s essentials in order for it to work:\n\n    resources/libs$ mkdir jasmine\n    resources/libs$ cd jasmine\n    resources/libs/jasmine$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/libs/jasmine/boot.js\n    resources/libs/jasmine$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/libs/jasmine/console.js\n    resources/libs/jasmine$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/libs/jasmine/jasmine-html.js\n    resources/libs/jasmine$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/libs/jasmine/jasmine.css\n    resources/libs/jasmine$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/libs/jasmine/jasmine.js\n    resources/libs/jasmine$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/libs/jasmine/jasmine_favicon.png\n\nThese essentials should be loaded in a newly created view where we're gonna see our specs running:\n\n[{]: <helper> (diffStep 5.5)\n\n#### [Step 5.5: Create specs runner view](https://github.com/DAB0mB/radial-snake/commit/150be1a)\n\n##### Added views&#x2F;spec_runner.html\n```diff\n@@ -0,0 +1,27 @@\n+â”Š  â”Š 1â”Š\n+â”Š  â”Š 2â”Š<!DOCTYPE html>\n+â”Š  â”Š 3â”Š<html>\n+â”Š  â”Š 4â”Š  <head>\n+â”Š  â”Š 5â”Š    <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n+â”Š  â”Š 6â”Š    <title>Jasmine Spec Runner v2.0.1</title>\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Š    <!-- Jasmine -->\n+â”Š  â”Š 9â”Š    <script type=\"text/javascript\" src=\"libs/jasmine/jasmine.js\"></script>\n+â”Š  â”Š10â”Š    <script type=\"text/javascript\" src=\"libs/jasmine/jasmine-html.js\"></script>\n+â”Š  â”Š11â”Š    <script type=\"text/javascript\" src=\"libs/jasmine/boot.js\"></script>\n+â”Š  â”Š12â”Š    <link rel=\"shortcut icon\" type=\"image/png\" href=\"libs/jasmine/jasmine_favicon.png\">\n+â”Š  â”Š13â”Š    <link rel=\"stylesheet\" type=\"text/css\" href=\"libs/jasmine/jasmine.css\">\n+â”Š  â”Š14â”Š\n+â”Š  â”Š15â”Š    <!-- Libs -->\n+â”Š  â”Š16â”Š    <script type=\"text/javascript\" src=\"libs/underscore.js\"></script>\n+â”Š  â”Š17â”Š\n+â”Š  â”Š18â”Š    <!-- Scripts -->\n+â”Š  â”Š19â”Š    <script type=\"text/javascript\" src=\"scripts/utils.js\"></script>\n+â”Š  â”Š20â”Š    <script type=\"text/javascript\" src=\"scripts/namespaces.js\"></script>\n+â”Š  â”Š21â”Š\n+â”Š  â”Š22â”Š    <!-- Specs -->\n+â”Š  â”Š23â”Š  </head>\n+â”Š  â”Š24â”Š\n+â”Š  â”Š25â”Š  <body>\n+â”Š  â”Š26â”Š  </body>\n+â”Š  â”Š27â”Š</html>ðŸš«â†µ\n```\n\n[}]: #\n\nNow once we'll navigate to the `/test` sub-route (`localhost:8000/test` by default) we should be provided with the spec runner. As for now there are no specs implemented at all, which brings us to the next stage - Implementing tests for `Line` class:\n\n[{]: <helper> (diffStep 5.6)\n\n#### [Step 5.6: Create &#x27;Line&#x27; class tests](https://github.com/DAB0mB/radial-snake/commit/c052752)\n\n##### Added resources&#x2F;scripts&#x2F;specs&#x2F;engine&#x2F;geometry&#x2F;line.js\n```diff\n@@ -0,0 +1,78 @@\n+â”Š  â”Š 1â”Šdescribe(\"Engine.Geometry.Line class\", function() {\n+â”Š  â”Š 2â”Š  beforeEach(function() {\n+â”Š  â”Š 3â”Š    this.line = new Engine.Geometry.Line(-5, -5, 5, 5);\n+â”Š  â”Š 4â”Š  });\n+â”Š  â”Š 5â”Š\n+â”Š  â”Š 6â”Š  describe(\"getX method\", function() {\n+â”Š  â”Š 7â”Š    describe(\"given inranged y\", function() {\n+â”Š  â”Š 8â”Š      it(\"returns x\", function() {\n+â”Š  â”Š 9â”Š        expect(this.line.getX(1)).toBeCloseTo(1);\n+â”Š  â”Š10â”Š      });\n+â”Š  â”Š11â”Š    });\n+â”Š  â”Š12â”Š\n+â”Š  â”Š13â”Š    describe(\"given outranged y\", function() {\n+â”Š  â”Š14â”Š      it(\"returns nothing\", function() {\n+â”Š  â”Š15â”Š        expect(this.line.getX(10)).toBeUndefined();\n+â”Š  â”Š16â”Š      });\n+â”Š  â”Š17â”Š    });\n+â”Š  â”Š18â”Š  });\n+â”Š  â”Š19â”Š\n+â”Š  â”Š20â”Š  describe(\"getY method\", function() {\n+â”Š  â”Š21â”Š    describe(\"given inranged x\", function() {\n+â”Š  â”Š22â”Š      it(\"returns y\", function() {\n+â”Š  â”Š23â”Š        expect(this.line.getY(1)).toBeCloseTo(1);\n+â”Š  â”Š24â”Š      });\n+â”Š  â”Š25â”Š    });\n+â”Š  â”Š26â”Š\n+â”Š  â”Š27â”Š    describe(\"given outranged x\", function() {\n+â”Š  â”Š28â”Š      it(\"returns nothing\", function() {\n+â”Š  â”Š29â”Š        expect(this.line.getY(10)).toBeUndefined();\n+â”Š  â”Š30â”Š      });\n+â”Š  â”Š31â”Š    });\n+â”Š  â”Š32â”Š  });\n+â”Š  â”Š33â”Š\n+â”Š  â”Š34â”Š  describe(\"hasPoint method\", function() {\n+â”Š  â”Š35â”Š    describe(\"given contained point\", function() {\n+â”Š  â”Š36â”Š      it(\"returns true\", function() {\n+â”Š  â”Š37â”Š        let x = 1;\n+â”Š  â”Š38â”Š        let y = 1;\n+â”Š  â”Š39â”Š        expect(this.line.hasPoint(x, y)).toBeTruthy();\n+â”Š  â”Š40â”Š      });\n+â”Š  â”Š41â”Š    });\n+â”Š  â”Š42â”Š\n+â”Š  â”Š43â”Š    describe(\"given uncontained point\", function() {\n+â”Š  â”Š44â”Š      it(\"returns false\", function() {\n+â”Š  â”Š45â”Š        let x = 10;\n+â”Š  â”Š46â”Š        let y = 10;\n+â”Š  â”Š47â”Š        expect(this.line.hasPoint(x, y)).toBeFalsy();\n+â”Š  â”Š48â”Š      });\n+â”Š  â”Š49â”Š    });\n+â”Š  â”Š50â”Š  });\n+â”Š  â”Š51â”Š\n+â”Š  â”Š52â”Š  describe(\"getLineIntersection method\", function() {\n+â”Š  â”Š53â”Š    describe(\"given intersecting line\", function() {\n+â”Š  â”Š54â”Š      it(\"returns intersection point\", function() {\n+â”Š  â”Š55â”Š        let line = new Engine.Geometry.Line(1, -5, 1, 5);\n+â”Š  â”Š56â”Š\n+â”Š  â”Š57â”Š        expect(this.line.getLineIntersection(line)).toEqual({\n+â”Š  â”Š58â”Š          x: 1,\n+â”Š  â”Š59â”Š          y: 1\n+â”Š  â”Š60â”Š        });\n+â”Š  â”Š61â”Š      });\n+â”Š  â”Š62â”Š    });\n+â”Š  â”Š63â”Š\n+â”Š  â”Š64â”Š    describe(\"given parallel line\", function() {\n+â”Š  â”Š65â”Š      it(\"returns nothing\", function() {\n+â”Š  â”Š66â”Š        let line = new Engine.Geometry.Line(-5, -6, 5, 4);\n+â”Š  â”Š67â”Š        expect(this.line.getLineIntersection(line)).toBeUndefined();\n+â”Š  â”Š68â”Š      });\n+â”Š  â”Š69â”Š    });\n+â”Š  â”Š70â”Š\n+â”Š  â”Š71â”Š    describe(\"given outranged line\", function() {\n+â”Š  â”Š72â”Š      it(\"returns nothing\", function() {\n+â”Š  â”Š73â”Š        let line = new Engine.Geometry.Line(10, 10, 10, 15);\n+â”Š  â”Š74â”Š        expect(this.line.getLineIntersection(line)).toBeUndefined();\n+â”Š  â”Š75â”Š      });\n+â”Š  â”Š76â”Š    });\n+â”Š  â”Š77â”Š  });\n+â”Š  â”Š78â”Š});ðŸš«â†µ\n```\n\n##### Changed views&#x2F;spec_runner.html\n```diff\n@@ -18,8 +18,10 @@\n â”Š18â”Š18â”Š    <!-- Scripts -->\n â”Š19â”Š19â”Š    <script type=\"text/javascript\" src=\"scripts/utils.js\"></script>\n â”Š20â”Š20â”Š    <script type=\"text/javascript\" src=\"scripts/namespaces.js\"></script>\n+â”Š  â”Š21â”Š    <script type=\"text/javascript\" src=\"scripts/engine/geometry/line.js\"></script>\n â”Š21â”Š22â”Š\n â”Š22â”Š23â”Š    <!-- Specs -->\n+â”Š  â”Š24â”Š    <script type=\"text/javascript\" src=\"scripts/specs/engine/geometry/line.js\"></script>\n â”Š23â”Š25â”Š  </head>\n â”Š24â”Š26â”Š\n â”Š25â”Š27â”Š  <body>\n```\n\n[}]: #\n\nNow if you'll refresh the spec runner page you should be able to a green screen indicating all tests have passed (Assuming the tutorial is updated and you followed it correctly). As introduced at the beginning of the step, the snake is also dependent on circles, whose representing class should look like so:\n\n[{]: <helper> (diffStep 5.7)\n\n#### [Step 5.7: Create &#x27;Circle&#x27; class](https://github.com/DAB0mB/radial-snake/commit/f9c5723)\n\n##### Added resources&#x2F;scripts&#x2F;engine&#x2F;geometry&#x2F;circle.js\n```diff\n@@ -0,0 +1,167 @@\n+â”Š   â”Š  1â”ŠEngine.Geometry.Circle = class Circle {\n+â”Š   â”Š  2â”Š  // x - The x value of the circle's center\n+â”Š   â”Š  3â”Š  // y - The y value of the circle's center\n+â”Š   â”Š  4â”Š  // r - The radius of the center\n+â”Š   â”Š  5â”Š  // rad1 - The first radian of the circle, not necessarily its beginning\n+â”Š   â”Š  6â”Š  // rad2 - The second radian of the circle, not necessarily its beginning\n+â”Š   â”Š  7â”Š  constructor(x, y, r, rad1, rad2) {\n+â”Š   â”Š  8â”Š    this.x = Utils.trim(x, 9);\n+â”Š   â”Š  9â”Š    this.y = Utils.trim(y, 9);\n+â”Š   â”Š 10â”Š    this.r = Utils.trim(r, 9);\n+â”Š   â”Š 11â”Š\n+â”Š   â”Š 12â”Š    // Trimming mode is done based on which radian represents the ending and which radian\n+â”Š   â”Š 13â”Š    // represents the ending\n+â”Š   â”Š 14â”Š    if (rad1 > rad2) {\n+â”Š   â”Š 15â”Š      this.rad1 = Utils.trim(rad1, 9, \"floor\");\n+â”Š   â”Š 16â”Š      this.rad2 = Utils.trim(rad2, 9, \"ceil\");\n+â”Š   â”Š 17â”Š    }\n+â”Š   â”Š 18â”Š    else {\n+â”Š   â”Š 19â”Š      this.rad1 = Utils.trim(rad1, 9, \"ceil\");\n+â”Š   â”Š 20â”Š      this.rad2 = Utils.trim(rad2, 9, \"floor\");\n+â”Š   â”Š 21â”Š    }\n+â”Š   â”Š 22â”Š  }\n+â”Š   â”Š 23â”Š\n+â”Š   â”Š 24â”Š  // Draws the circle on the given context\n+â”Š   â”Š 25â”Š  draw(context) {\n+â”Š   â”Š 26â”Š    context.arc(this.x, this.y, this.r, this.rad1, this.rad2);\n+â”Š   â”Š 27â”Š  }\n+â”Š   â”Š 28â”Š\n+â”Š   â”Š 29â”Š  // Gets the matching x value for the given radian\n+â”Š   â”Š 30â”Š  getX(rad) {\n+â”Š   â”Š 31â”Š    if (!Utils(rad).trim(9).isBetween(this.rad1, this.rad2).value()) return;\n+â”Š   â”Š 32â”Š    return Utils.trim((this.r * Math.cos(rad)) + this.x, 9);\n+â”Š   â”Š 33â”Š  }\n+â”Š   â”Š 34â”Š\n+â”Š   â”Š 35â”Š  // Gets the matching y value for the given radian\n+â”Š   â”Š 36â”Š  getY(rad) {\n+â”Š   â”Š 37â”Š    if (!Utils(rad).trim(9).isBetween(this.rad1, this.rad2).value()) return;\n+â”Š   â”Š 38â”Š    return Utils.trim((this.r * Math.sin(rad)) + this.y, 9);\n+â”Š   â”Š 39â”Š  }\n+â”Š   â”Š 40â”Š\n+â”Š   â”Š 41â”Š  // Gets the matching point for the given radian\n+â”Š   â”Š 42â”Š  getPoint(rad) {\n+â”Š   â”Š 43â”Š    if (!Utils.isBetween(rad, this.rad1, this.rad2)) return;\n+â”Š   â”Š 44â”Š\n+â”Š   â”Š 45â”Š    return {\n+â”Š   â”Š 46â”Š      x: Utils.trim((this.r * Math.cos(rad)) + this.x, 9),\n+â”Š   â”Š 47â”Š      y: Utils.trim((this.r * Math.sin(rad)) + this.y, 9)\n+â”Š   â”Š 48â”Š    };\n+â”Š   â”Š 49â”Š  }\n+â”Š   â”Š 50â”Š\n+â”Š   â”Š 51â”Š  // Gets the matching radian for the given point\n+â”Š   â”Š 52â”Š  getRad(x, y) {\n+â”Š   â”Š 53â”Š    let rad = Math.atan2(y - this.y, x - this.x);\n+â”Š   â”Š 54â”Š\n+â”Š   â”Š 55â”Š    // If calculated radian is in circle's radian range, return it\n+â”Š   â”Š 56â”Š    if (rad != null && Utils.isBetween(rad, this.rad1, this.rad2)) {\n+â”Š   â”Š 57â”Š      return rad;\n+â”Š   â”Š 58â”Š    }\n+â”Š   â”Š 59â”Š\n+â”Š   â”Š 60â”Š    // The calculated radian can still be in the circle's radian range in case one\n+â”Š   â”Š 61â”Š    // of the radians is greater than 2 PIEs\n+â”Š   â”Š 62â”Š    if (Math.abs(this.rad1) > Math.abs(this.rad2)) {\n+â”Š   â”Š 63â”Š      var greatestRad = this.rad1;\n+â”Š   â”Š 64â”Š    }\n+â”Š   â”Š 65â”Š    else {\n+â”Š   â”Š 66â”Š      var greatestRad = this.rad2;\n+â”Š   â”Š 67â”Š    }\n+â”Š   â”Š 68â”Š\n+â”Š   â”Š 69â”Š    // Check if the absolute radian is in the circle's radian range\n+â”Š   â”Š 70â”Š    if (Utils(rad + (2 * Math.PI * Math.floor(greatestRad / (2 * Math.PI)))).trim(9).isBetween(this.rad1, this.rad2).value() ||\n+â”Š   â”Š 71â”Š        Utils(rad + (2 * Math.PI * Math.ceil(greatestRad / (2 * Math.PI)))).trim(9).isBetween(this.rad1, this.rad2).value()) {\n+â”Š   â”Š 72â”Š      return rad;\n+â”Š   â”Š 73â”Š    }\n+â”Š   â”Š 74â”Š  }\n+â”Š   â”Š 75â”Š\n+â”Š   â”Š 76â”Š  // Returns if circle has given points\n+â”Š   â”Š 77â”Š  hasPoint(x, y) {\n+â”Š   â”Š 78â”Š    return this.getRad(x, y) != null;\n+â”Š   â”Š 79â”Š  }\n+â”Š   â”Š 80â”Š\n+â”Š   â”Š 81â”Š  getIntersection(shape) {\n+â”Š   â”Š 82â”Š    if (shape instanceof Engine.Geometry.Line)\n+â”Š   â”Š 83â”Š      return this.getLineIntersection(shape);\n+â”Š   â”Š 84â”Š    if (shape instanceof Engine.Geometry.Circle)\n+â”Š   â”Š 85â”Š      return this.getCircleIntersection(shape);\n+â”Š   â”Š 86â”Š  }\n+â”Š   â”Š 87â”Š\n+â”Š   â”Š 88â”Š  // circle - circle intersection method\n+â”Š   â”Š 89â”Š  getCircleIntersection(circle) {\n+â”Š   â”Š 90â”Š    let dx = circle.x - this.x;\n+â”Š   â”Š 91â”Š    let dy = circle.y - this.y;\n+â”Š   â”Š 92â”Š    let d = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\n+â”Š   â”Š 93â”Š\n+â”Š   â”Š 94â”Š    if (d > this.r + circle.r ||\n+â”Š   â”Š 95â”Š       d < Math.abs(this.r - circle.r)) {\n+â”Š   â”Š 96â”Š      return;\n+â”Š   â”Š 97â”Š    }\n+â”Š   â”Š 98â”Š\n+â”Š   â”Š 99â”Š    let a = ((Math.pow(this.r, 2) - Math.pow(circle.r, 2)) + Math.pow(d, 2)) / (2 * d);\n+â”Š   â”Š100â”Š    let x = this.x + ((dx * a) / d);\n+â”Š   â”Š101â”Š    let y = this.y + ((dy * a) / d);\n+â”Š   â”Š102â”Š    let h = Math.sqrt(Math.pow(this.r, 2) - Math.pow(a, 2));\n+â”Š   â”Š103â”Š    let rx = (- dy * h) / d;\n+â”Š   â”Š104â”Š    let ry = (dx * h) / d;\n+â”Š   â”Š105â”Š\n+â”Š   â”Š106â”Š    let interPoints = [\n+â”Š   â”Š107â”Š      {\n+â”Š   â”Š108â”Š        x: x + rx,\n+â”Š   â”Š109â”Š        y: y + ry\n+â”Š   â”Š110â”Š      },\n+â”Š   â”Š111â”Š      {\n+â”Š   â”Š112â”Š        x: x - rx,\n+â”Š   â”Š113â”Š        y: y - ry\n+â”Š   â”Š114â”Š      }\n+â”Š   â”Š115â”Š    ]\n+â”Š   â”Š116â”Š    .map(point => ({\n+â”Š   â”Š117â”Š        x: Utils.trim(point.x, 9),\n+â”Š   â”Š118â”Š        y: Utils.trim(point.y, 9)\n+â”Š   â”Š119â”Š     }));\n+â”Š   â”Š120â”Š\n+â”Š   â”Š121â”Š    interPoints = _.uniq(interPoints, point => `(${point.x}, ${point.y})`);\n+â”Š   â”Š122â”Š\n+â”Š   â”Š123â”Š    [this, circle].forEach(function(circle) {\n+â”Š   â”Š124â”Š      interPoints = interPoints.filter(point => circle.hasPoint(point.x, point.y));\n+â”Š   â”Š125â”Š    });\n+â”Š   â”Š126â”Š\n+â”Š   â”Š127â”Š    if (interPoints.length > 0) return interPoints;\n+â”Š   â”Š128â”Š  }\n+â”Š   â”Š129â”Š\n+â”Š   â”Š130â”Š  // circle - line intersection method\n+â”Š   â”Š131â”Š  getLineIntersection(line) {\n+â”Š   â”Š132â”Š    let x1 = line.x1 - this.x;\n+â”Š   â”Š133â”Š    let x2 = line.x2 - this.x;\n+â”Š   â”Š134â”Š    let y1 = line.y1 - this.y;\n+â”Š   â”Š135â”Š    let y2 = line.y2 - this.y;\n+â”Š   â”Š136â”Š    let dx = x2 - x1;\n+â”Š   â”Š137â”Š    let dy = y2 - y1;\n+â”Š   â”Š138â”Š    let d = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\n+â”Š   â”Š139â”Š    let h = (x1 * y2) - (x2 * y1);\n+â”Š   â”Š140â”Š    let delta = (Math.pow(this.r, 2) * Math.pow(d, 2)) - Math.pow(h, 2);\n+â”Š   â”Š141â”Š\n+â”Š   â”Š142â”Š    if (delta < 0) return;\n+â”Š   â”Š143â”Š\n+â”Š   â”Š144â”Š    let interPoints = [\n+â”Š   â”Š145â”Š      {\n+â”Š   â”Š146â”Š        x: (((h * dy) + (((dy / Math.abs(dy)) || 1) * dx * Math.sqrt(delta))) / Math.pow(d, 2)) + this.x,\n+â”Š   â”Š147â”Š        y: (((-h * dx) + (Math.abs(dy) * Math.sqrt(delta))) / Math.pow(d, 2)) + this.y\n+â”Š   â”Š148â”Š      },\n+â”Š   â”Š149â”Š      {\n+â”Š   â”Š150â”Š        x: (((h * dy) - (((dy / Math.abs(dy)) || 1) * dx * Math.sqrt(delta))) / Math.pow(d, 2)) + this.x,\n+â”Š   â”Š151â”Š        y: (((-h * dx) - (Math.abs(dy) * Math.sqrt(delta))) / Math.pow(d, 2)) + this.y\n+â”Š   â”Š152â”Š      }\n+â”Š   â”Š153â”Š    ]\n+â”Š   â”Š154â”Š    .map(point => ({\n+â”Š   â”Š155â”Š        x: Utils.trim(point.x, 9),\n+â”Š   â”Š156â”Š        y: Utils.trim(point.y, 9)\n+â”Š   â”Š157â”Š    }))\n+â”Š   â”Š158â”Š    .filter(point => {\n+â”Š   â”Š159â”Š      return this.hasPoint(point.x, point.y) &&\n+â”Š   â”Š160â”Š        line.boundsHavePoint(point.x, point.y);\n+â”Š   â”Š161â”Š    });\n+â”Š   â”Š162â”Š\n+â”Š   â”Š163â”Š    interPoints = _.uniq(interPoints, point => `(${point.x}, ${point.y})`);\n+â”Š   â”Š164â”Š\n+â”Š   â”Š165â”Š    if (interPoints.length > 0) return interPoints;\n+â”Š   â”Š166â”Š  }\n+â”Š   â”Š167â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -11,6 +11,7 @@\n â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/utils.js\"></script>\n â”Š12â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n â”Š13â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/geometry/line.js\"></script>\n+â”Š  â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/geometry/circle.js\"></script>\n â”Š14â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/restorable.js\"></script>\n â”Š15â”Š16â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/font.js\"></script>\n â”Š16â”Š17â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/sprite.js\"></script>\n```\n\n[}]: #\n\nJust like a line, a circle can be presented using variables as well. The center of the circle is represented as `(x, y)` and its radius is represented as `r`. Remember that our circle doesn't necessarily have to be a full one, therefore we limit its range using two radians - `rad1` and `rad2`. The formula for representing a circle in a 2D space looks like this:\n\n![circle-formula](https://cloud.githubusercontent.com/assets/7648874/21829783/84a54574-d77f-11e6-9b87-3fb0f073bb8d.png)\n\n![circle-circle-illustration](https://cloud.githubusercontent.com/assets/7648874/21790842/3a73408c-d6c6-11e6-8bdd-9c73355e6ebb.png)\n\n> `a` and `b` represent the offsets from the `x` and the `y` axes respectively.\n> See reference: http://mathworld.wolfram.com/Circle-CircleIntersection.html.\n\nTo find intersection between two circles, we simply calculate the solution for two equations with two variables. Given that a line can be represented in a 2D space using the following formula:\n\n![line-formula](https://cloud.githubusercontent.com/assets/7648874/21790671/1609c050-d6c5-11e6-8bd7-16cc306f5eea.png)\n\n![circle-line-illustration](https://cloud.githubusercontent.com/assets/7648874/21790810/1a052086-d6c6-11e6-9c5c-24298fedb043.png)\n\n> `n` represents the intersection value with the `y` axis.\n> See reference: http://mathworld.wolfram.com/Circle-LineIntersection.html.\n\nwe can find the intersection between a circle and line by solving the systems formed by the equations of both. We also want the line-circle algorithm to be available for any `Line` instance, therefore we gonna add the following delegate on the `Line` prototype:\n\n[{]: <helper> (diffStep 5.8)\n\n#### [Step 5.8: Delegate circle intersection methods](https://github.com/DAB0mB/radial-snake/commit/19828bf)\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;geometry&#x2F;line.js\n```diff\n@@ -44,6 +44,8 @@\n â”Š44â”Š44â”Š  getIntersection(shape) {\n â”Š45â”Š45â”Š    if (shape instanceof Engine.Geometry.Line)\n â”Š46â”Š46â”Š      return this.getLineIntersection(shape);\n+â”Š  â”Š47â”Š    if (shape instanceof Engine.Geometry.Circle)\n+â”Š  â”Š48â”Š      return this.getCircleIntersection(shape);\n â”Š47â”Š49â”Š  }\n â”Š48â”Š50â”Š\n â”Š49â”Š51â”Š  // line - line intersection method\n```\n```diff\n@@ -62,4 +64,9 @@\n â”Š62â”Š64â”Š      return { x, y };\n â”Š63â”Š65â”Š    }\n â”Š64â”Š66â”Š  }\n+â”Š  â”Š67â”Š\n+â”Š  â”Š68â”Š  // line - circle intersection method\n+â”Š  â”Š69â”Š  getCircleIntersection(circle) {\n+â”Š  â”Š70â”Š    return circle.getLineIntersection(this);\n+â”Š  â”Š71â”Š  }\n â”Š65â”Š72â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nThen again a newly created geometry shape class should be tested against different scenarios:\n\n[{]: <helper> (diffStep 5.9)\n\n#### [Step 5.9: Create &#x27;Circle&#x27; class tests](https://github.com/DAB0mB/radial-snake/commit/1d98a6e)\n\n##### Added resources&#x2F;scripts&#x2F;specs&#x2F;engine&#x2F;geometry&#x2F;circle.js\n```diff\n@@ -0,0 +1,144 @@\n+â”Š   â”Š  1â”Šdescribe(\"Engine.Geometry.Circle class\", function() {\n+â”Š   â”Š  2â”Š  beforeEach(function() {\n+â”Š   â”Š  3â”Š    this.circle = new Engine.Geometry.Circle(1, 1, 5, 0, 1.5 * Math.PI);\n+â”Š   â”Š  4â”Š  });\n+â”Š   â”Š  5â”Š\n+â”Š   â”Š  6â”Š  describe(\"getX method\", function() {\n+â”Š   â”Š  7â”Š    describe(\"given inranged rad\", function() {\n+â”Š   â”Š  8â”Š      it(\"returns x\", function() {\n+â”Š   â”Š  9â”Š        expect(this.circle.getX(0 * Math.PI)).toBeCloseTo(6);\n+â”Š   â”Š 10â”Š        expect(this.circle.getX(0.5 * Math.PI)).toBeCloseTo(1);\n+â”Š   â”Š 11â”Š        expect(this.circle.getX(1 * Math.PI)).toBeCloseTo(-4);\n+â”Š   â”Š 12â”Š        expect(this.circle.getX(1.5 * Math.PI)).toBeCloseTo(1);\n+â”Š   â”Š 13â”Š      });\n+â”Š   â”Š 14â”Š    });\n+â”Š   â”Š 15â”Š\n+â”Š   â”Š 16â”Š    describe(\"given outranged rad\", function() {\n+â”Š   â”Š 17â”Š      it(\"returns nothing\", function() {\n+â”Š   â”Š 18â”Š        expect(this.circle.getX(2 * Math.PI)).toBeUndefined();\n+â”Š   â”Š 19â”Š      });\n+â”Š   â”Š 20â”Š    });\n+â”Š   â”Š 21â”Š  });\n+â”Š   â”Š 22â”Š\n+â”Š   â”Š 23â”Š  describe(\"getY method\", function() {\n+â”Š   â”Š 24â”Š    describe(\"given inranged rad\", function() {\n+â”Š   â”Š 25â”Š      it(\"returns y\", function() {\n+â”Š   â”Š 26â”Š        expect(this.circle.getY(0 * Math.PI)).toBeCloseTo(1);\n+â”Š   â”Š 27â”Š        expect(this.circle.getY(0.5 * Math.PI)).toBeCloseTo(6);\n+â”Š   â”Š 28â”Š        expect(this.circle.getY(1 * Math.PI)).toBeCloseTo(1);\n+â”Š   â”Š 29â”Š        expect(this.circle.getY(1.5 * Math.PI)).toBeCloseTo(-4);\n+â”Š   â”Š 30â”Š      });\n+â”Š   â”Š 31â”Š    });\n+â”Š   â”Š 32â”Š\n+â”Š   â”Š 33â”Š    describe(\"given outranged rad\", function() {\n+â”Š   â”Š 34â”Š      it(\"returns nothing\", function() {\n+â”Š   â”Š 35â”Š        expect(this.circle.getY(2 * Math.PI)).toBeUndefined();\n+â”Š   â”Š 36â”Š      });\n+â”Š   â”Š 37â”Š    });\n+â”Š   â”Š 38â”Š  });\n+â”Š   â”Š 39â”Š\n+â”Š   â”Š 40â”Š  describe(\"getRad method\", function() {\n+â”Š   â”Š 41â”Š    describe(\"given inranged point\", function() {\n+â”Š   â”Š 42â”Š      it(\"returns rad\", function() {\n+â”Š   â”Š 43â”Š        let x = -3.0450849718747346;\n+â”Š   â”Š 44â”Š        let y = 3.9389262614623686;\n+â”Š   â”Š 45â”Š        expect(this.circle.getRad(x, y)).toBeCloseTo(0.8 * Math.PI);\n+â”Š   â”Š 46â”Š      });\n+â”Š   â”Š 47â”Š    });\n+â”Š   â”Š 48â”Š\n+â”Š   â”Š 49â”Š    describe(\"given outranged point\", function() {\n+â”Š   â”Š 50â”Š      it(\"returns nothing\", function() {\n+â”Š   â”Š 51â”Š        let x = 5.045084971874736;\n+â”Š   â”Š 52â”Š        let y = -1.9389262614623664;\n+â”Š   â”Š 53â”Š        expect(this.circle.getRad(x, y)).toBeUndefined();\n+â”Š   â”Š 54â”Š      });\n+â”Š   â”Š 55â”Š    });\n+â”Š   â”Š 56â”Š  });\n+â”Š   â”Š 57â”Š\n+â”Š   â”Š 58â”Š  describe(\"getCircleIntersection method\", function() {\n+â”Š   â”Š 59â”Š    describe(\"given circle with 2 intersection points\", function() {\n+â”Š   â”Š 60â”Š      it(\"returns array with intersection points\", function() {\n+â”Š   â”Š 61â”Š        let circle = new Engine.Geometry.Circle(-5, 1, 5, 0, 2 * Math.PI);\n+â”Š   â”Š 62â”Š\n+â”Š   â”Š 63â”Š        expect(this.circle.getCircleIntersection(circle)).toEqual([\n+â”Š   â”Š 64â”Š          { x: -2, y: -3 },\n+â”Š   â”Š 65â”Š          { x: -2, y: 5 }\n+â”Š   â”Š 66â”Š        ]);\n+â”Š   â”Š 67â”Š      });\n+â”Š   â”Š 68â”Š    });\n+â”Š   â”Š 69â”Š\n+â”Š   â”Š 70â”Š    describe(\"given circle with 1 intersection points\", function() {\n+â”Š   â”Š 71â”Š      it(\"returns array with intersection point\", function() {\n+â”Š   â”Š 72â”Š        let circle = new Engine.Geometry.Circle(-5, 1, 5, 0, 1 * Math.PI);\n+â”Š   â”Š 73â”Š\n+â”Š   â”Š 74â”Š        expect(this.circle.getCircleIntersection(circle)).toEqual([\n+â”Š   â”Š 75â”Š          { x: -2, y: 5 }\n+â”Š   â”Š 76â”Š        ]);\n+â”Š   â”Š 77â”Š      });\n+â”Š   â”Š 78â”Š    });\n+â”Š   â”Š 79â”Š\n+â”Š   â”Š 80â”Š    describe(\"given kissing circle\", function() {\n+â”Š   â”Š 81â”Š      it(\"returns array with intersection point\", function() {\n+â”Š   â”Š 82â”Š        let circle = new Engine.Geometry.Circle(-9, 1, 5, 0, 2 * Math.PI);\n+â”Š   â”Š 83â”Š\n+â”Š   â”Š 84â”Š        expect(this.circle.getCircleIntersection(circle)).toEqual([\n+â”Š   â”Š 85â”Š          { x: -4, y: 1 }\n+â”Š   â”Š 86â”Š        ]);\n+â”Š   â”Š 87â”Š      });\n+â”Š   â”Š 88â”Š    });\n+â”Š   â”Š 89â”Š\n+â”Š   â”Š 90â”Š    describe(\"given outer circle\", function() {\n+â”Š   â”Š 91â”Š      it(\"returns nothing\", function() {\n+â”Š   â”Š 92â”Š        let circle = new Engine.Geometry.Circle(10, 10, 2, 0, 2 * Math.PI);\n+â”Š   â”Š 93â”Š        expect(this.circle.getCircleIntersection(circle)).toBeUndefined();\n+â”Š   â”Š 94â”Š      });\n+â”Š   â”Š 95â”Š    });\n+â”Š   â”Š 96â”Š\n+â”Š   â”Š 97â”Š    describe(\"given inner circle\", function() {\n+â”Š   â”Š 98â”Š      it(\"nothing\", function() {\n+â”Š   â”Š 99â”Š        let circle = new Engine.Geometry.Circle(1, 1, 2, 0, 2 * Math.PI);\n+â”Š   â”Š100â”Š        expect(this.circle.getCircleIntersection(circle)).toBeUndefined();\n+â”Š   â”Š101â”Š      });\n+â”Š   â”Š102â”Š    });\n+â”Š   â”Š103â”Š  });\n+â”Š   â”Š104â”Š\n+â”Š   â”Š105â”Š  describe(\"getLineIntersection method\", function() {\n+â”Š   â”Š106â”Š    describe(\"given line with 2 intersection points\", function() {\n+â”Š   â”Š107â”Š      it(\"returns array with intersection points\", function() {\n+â”Š   â”Š108â”Š        let line = new Engine.Geometry.Line(-10, 1, 10, 1);\n+â”Š   â”Š109â”Š\n+â”Š   â”Š110â”Š        expect(this.circle.getLineIntersection(line)).toEqual([\n+â”Š   â”Š111â”Š          { x: 6, y: 1 },\n+â”Š   â”Š112â”Š          { x: -4, y: 1 }\n+â”Š   â”Š113â”Š        ]);\n+â”Š   â”Š114â”Š      });\n+â”Š   â”Š115â”Š    });\n+â”Š   â”Š116â”Š\n+â”Š   â”Š117â”Š    describe(\"given line with 1 intersection point\", function() {\n+â”Š   â”Š118â”Š      it(\"returns array with intersection point\", function() {\n+â”Š   â”Š119â”Š        let line = new Engine.Geometry.Line(-10, 1, 1, 1);\n+â”Š   â”Š120â”Š\n+â”Š   â”Š121â”Š        expect(this.circle.getLineIntersection(line)).toEqual([\n+â”Š   â”Š122â”Š          { x: -4, y: 1 }\n+â”Š   â”Š123â”Š        ]);\n+â”Š   â”Š124â”Š      });\n+â”Š   â”Š125â”Š    });\n+â”Š   â”Š126â”Š\n+â”Š   â”Š127â”Š    describe(\"given kissing line\", function() {\n+â”Š   â”Š128â”Š      it(\"returns array with intersection point\", function() {\n+â”Š   â”Š129â”Š        let line = new Engine.Geometry.Line(-10, 6, 10, 6);\n+â”Š   â”Š130â”Š\n+â”Š   â”Š131â”Š        expect(this.circle.getLineIntersection(line)).toEqual([\n+â”Š   â”Š132â”Š          { x: 1, y: 6 }\n+â”Š   â”Š133â”Š        ]);\n+â”Š   â”Š134â”Š      });\n+â”Š   â”Š135â”Š    });\n+â”Š   â”Š136â”Š\n+â”Š   â”Š137â”Š    describe(\"given outranged line\", function() {\n+â”Š   â”Š138â”Š      it(\"returns nothing\", function() {\n+â”Š   â”Š139â”Š        let line = new Engine.Geometry.Line(-10, 10, 10, 10);\n+â”Š   â”Š140â”Š        expect(this.circle.getLineIntersection(line)).toBeUndefined();\n+â”Š   â”Š141â”Š      });\n+â”Š   â”Š142â”Š    });\n+â”Š   â”Š143â”Š  });\n+â”Š   â”Š144â”Š});ðŸš«â†µ\n```\n\n##### Changed views&#x2F;spec_runner.html\n```diff\n@@ -19,9 +19,11 @@\n â”Š19â”Š19â”Š    <script type=\"text/javascript\" src=\"scripts/utils.js\"></script>\n â”Š20â”Š20â”Š    <script type=\"text/javascript\" src=\"scripts/namespaces.js\"></script>\n â”Š21â”Š21â”Š    <script type=\"text/javascript\" src=\"scripts/engine/geometry/line.js\"></script>\n+â”Š  â”Š22â”Š    <script type=\"text/javascript\" src=\"scripts/engine/geometry/circle.js\"></script>\n â”Š22â”Š23â”Š\n â”Š23â”Š24â”Š    <!-- Specs -->\n â”Š24â”Š25â”Š    <script type=\"text/javascript\" src=\"scripts/specs/engine/geometry/line.js\"></script>\n+â”Š  â”Š26â”Š    <script type=\"text/javascript\" src=\"scripts/specs/engine/geometry/circle.js\"></script>\n â”Š25â”Š27â”Š  </head>\n â”Š26â”Š28â”Š\n â”Š27â”Š29â”Š  <body>\n```\n\n[}]: #\n\nOur final shape in the geometry module would be a polygon. Why a polygon? Since I'm planning to make the snake's movement circular, which means that once the snake hits a random boundary, he will reappear from the other side of the canvas. The collision detection between the snake and the canvas would be done using a polygon - which is simply made out of 4 lines:\n\n[{]: <helper> (diffStep 5.1)\n\n#### [Step 5.1: Create utilities module](https://github.com/DAB0mB/radial-snake/commit/58ae99a)\n\n##### Added resources&#x2F;scripts&#x2F;utils.js\n```diff\n@@ -0,0 +1,68 @@\n+â”Š  â”Š 1â”Š// A wrapper function for our utilities which will enable chaining\n+â”Š  â”Š 2â”Š// e.g. Utils().mod().trim().isBetween()...\n+â”Š  â”Š 3â”ŠUtils = function Utils(context) {\n+â”Š  â”Š 4â”Š  const chain = {};\n+â”Š  â”Š 5â”Š\n+â”Š  â”Š 6â”Š  Object.keys(Utils).forEach((utilName) => {\n+â”Š  â”Š 7â”Š    chain[utilName] = (...args) => {\n+â”Š  â”Š 8â”Š      const result = Utils[utilName](context, ...args);\n+â”Š  â”Š 9â”Š      return Utils(result);\n+â”Š  â”Š10â”Š    };\n+â”Š  â”Š11â”Š  });\n+â”Š  â”Š12â”Š\n+â”Š  â”Š13â”Š  // Returns the result of the chaining\n+â”Š  â”Š14â”Š  chain.value = () => context;\n+â”Š  â”Š15â”Š\n+â”Š  â”Š16â”Š  return chain;\n+â”Š  â”Š17â”Š};\n+â”Š  â”Š18â”Š\n+â”Š  â”Š19â”Š// Fixed modulo method which can calculate modulo of negative numbers properly\n+â”Š  â”Š20â”Š// e.g. (-803).mod(800) returns 797\n+â”Š  â”Š21â”ŠUtils.mod = function (context, num) {\n+â”Š  â”Š22â”Š  return ((context % num) + num) % num;\n+â”Š  â”Š23â”Š};\n+â”Š  â”Š24â”Š\n+â”Š  â”Š25â”Š// Trims number and leaves the number of decimals specified.\n+â”Š  â”Š26â”Š// The \"mode\" argument specifies which math function should be invoked\n+â”Š  â”Š27â”Š// right after the number has been trimmed.\n+â”Š  â”Š28â”Š// e.g. 12.12345.trim(3, \"ceil\") returns 12.124\n+â”Š  â”Š29â”ŠUtils.trim = function (context, decimals, mode = \"round\") {\n+â”Š  â”Š30â”Š  return Math[mode](context * Math.pow(10, decimals)) / Math.pow(10, decimals);\n+â”Š  â”Š31â”Š};\n+â”Š  â”Š32â”Š\n+â”Š  â”Š33â”Š// Tells if number is in specified range based on given precision.\n+â”Š  â”Š34â”Š// See the \"compare\" method for more information about precision\n+â”Š  â”Š35â”ŠUtils.isBetween = function (context, num1, num2, precision) {\n+â”Š  â”Š36â”Š  return Utils.compare(context, Math.min(num1, num2), \">=\", precision) &&\n+â”Š  â”Š37â”Š         Utils.compare(context, Math.max(num1, num2), \"<=\", precision);\n+â”Š  â”Š38â”Š};\n+â”Š  â”Š39â”Š\n+â”Š  â”Š40â”Š// Initiates comparison operator between context number and a given number, only here\n+â”Š  â”Š41â”Š// a precision can be specified\n+â”Š  â”Š42â”ŠUtils.compare = function (context, num, method, precision = method) {\n+â”Š  â”Š43â”Š  switch (precision) {\n+â”Š  â”Š44â”Š    // Fixed precision, \"almost equal\" with a deviation of Îµ\n+â”Š  â”Š45â”Š    case \"f\":\n+â”Š  â”Š46â”Š      switch (method) {\n+â”Š  â”Š47â”Š        case \"<\": case \"<=\": return context <= num + Number.EPSILON;\n+â”Š  â”Š48â”Š        case \">\": case \">=\": return context >= num - Number.EPSILON;\n+â”Š  â”Š49â”Š        default: return Math.abs(context - num) <= Number.EPSILON;\n+â”Š  â”Š50â”Š      }\n+â”Š  â”Š51â”Š    // Pixel precision, round comparison\n+â”Š  â”Š52â”Š    case \"px\":\n+â”Š  â”Š53â”Š      switch (method) {\n+â”Š  â”Š54â”Š        case \"<\": case \"<=\": return Math.round(context) <= Math.round(num);\n+â”Š  â”Š55â”Š        case \">\": case \">=\": return Math.round(context) >= Math.round(num);\n+â”Š  â”Š56â”Š        default: return Math.round(context) == Math.round(num);\n+â”Š  â”Š57â”Š      }\n+â”Š  â”Š58â”Š    // Exact precision\n+â”Š  â”Š59â”Š    default:\n+â”Š  â”Š60â”Š      switch (method) {\n+â”Š  â”Š61â”Š        case \"<\": return context < num;\n+â”Š  â”Š62â”Š        case \"<=\": return context <= num;\n+â”Š  â”Š63â”Š        case \">\": return context > num;\n+â”Š  â”Š64â”Š        case \">=\": return context >= num;\n+â”Š  â”Š65â”Š        default: return context === num;\n+â”Š  â”Š66â”Š      }\n+â”Š  â”Š67â”Š  }\n+â”Š  â”Š68â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -8,6 +8,7 @@\n â”Š 8â”Š 8â”Š    <script type=\"text/javascript\" src=\"/libs/underscore.js\"></script>\n â”Š 9â”Š 9â”Š\n â”Š10â”Š10â”Š    <!-- Scripts -->\n+â”Š  â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/utils.js\"></script>\n â”Š11â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n â”Š12â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/restorable.js\"></script>\n â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/font.js\"></script>\n```\n\n[}]: #\n\nAgain we will delegate the newly created intersection methods in the `Line` class and `Circle` class:\n\n[{]: <helper> (diffStep 5.11)\n\n#### [Step 5.11: Delegate polygon intersection methods](https://github.com/DAB0mB/radial-snake/commit/d42a5d9)\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;geometry&#x2F;circle.js\n```diff\n@@ -83,6 +83,8 @@\n â”Š83â”Š83â”Š      return this.getLineIntersection(shape);\n â”Š84â”Š84â”Š    if (shape instanceof Engine.Geometry.Circle)\n â”Š85â”Š85â”Š      return this.getCircleIntersection(shape);\n+â”Š  â”Š86â”Š    if (shape instanceof Engine.Geometry.Polygon)\n+â”Š  â”Š87â”Š      return this.getPolygonIntersection(shape);\n â”Š86â”Š88â”Š  }\n â”Š87â”Š89â”Š\n â”Š88â”Š90â”Š  // circle - circle intersection method\n```\n```diff\n@@ -164,4 +166,9 @@\n â”Š164â”Š166â”Š\n â”Š165â”Š167â”Š    if (interPoints.length > 0) return interPoints;\n â”Š166â”Š168â”Š  }\n+â”Š   â”Š169â”Š\n+â”Š   â”Š170â”Š  // circle - polygon intersection method\n+â”Š   â”Š171â”Š  getPolygonIntersection(polygon) {\n+â”Š   â”Š172â”Š    return polygon.getCircleIntersection(this);\n+â”Š   â”Š173â”Š  }\n â”Š167â”Š174â”Š};ðŸš«â†µ\n```\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;geometry&#x2F;line.js\n```diff\n@@ -46,6 +46,8 @@\n â”Š46â”Š46â”Š      return this.getLineIntersection(shape);\n â”Š47â”Š47â”Š    if (shape instanceof Engine.Geometry.Circle)\n â”Š48â”Š48â”Š      return this.getCircleIntersection(shape);\n+â”Š  â”Š49â”Š    if (shape instanceof Engine.Geometry.Polygon)\n+â”Š  â”Š50â”Š      return this.getPolygonIntersection(shape);\n â”Š49â”Š51â”Š  }\n â”Š50â”Š52â”Š\n â”Š51â”Š53â”Š  // line - line intersection method\n```\n```diff\n@@ -69,4 +71,9 @@\n â”Š69â”Š71â”Š  getCircleIntersection(circle) {\n â”Š70â”Š72â”Š    return circle.getLineIntersection(this);\n â”Š71â”Š73â”Š  }\n+â”Š  â”Š74â”Š\n+â”Š  â”Š75â”Š  // line - polygon intersection method\n+â”Š  â”Š76â”Š  getPolygonIntersection(polygon) {\n+â”Š  â”Š77â”Š    return polygon.getLineIntersection(this);\n+â”Š  â”Š78â”Š  }\n â”Š72â”Š79â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nNow we will create a some tests to make sure our newly created polygon works properly:\n\n[{]: <helper> (diffStep 5.12)\n\n#### [Step 5.12: Create &#x27;Polygon&#x27; class tests](https://github.com/DAB0mB/radial-snake/commit/f3f890b)\n\n##### Added resources&#x2F;scripts&#x2F;specs&#x2F;engine&#x2F;geometry&#x2F;polygon.js\n```diff\n@@ -0,0 +1,96 @@\n+â”Š  â”Š 1â”Šdescribe(\"Engine.Geometry.Polygon class\", function() {\n+â”Š  â”Š 2â”Š  beforeEach(function() {\n+â”Š  â”Š 3â”Š    this.polygon = new Engine.Geometry.Polygon(\n+â”Š  â”Š 4â”Š      [0, 0, 5, 0],\n+â”Š  â”Š 5â”Š      [5, 0, 5, 5],\n+â”Š  â”Š 6â”Š      [5, 5, 0, 5],\n+â”Š  â”Š 7â”Š      [0, 5, 0, 0]\n+â”Š  â”Š 8â”Š    );\n+â”Š  â”Š 9â”Š  });\n+â”Š  â”Š10â”Š\n+â”Š  â”Š11â”Š  describe(\"hasPoint method\", function() {\n+â”Š  â”Š12â”Š    describe(\"given contained point\", function() {\n+â”Š  â”Š13â”Š      it(\"returns true\", function() {\n+â”Š  â”Š14â”Š        let x = 5;\n+â”Š  â”Š15â”Š        let y = 3;\n+â”Š  â”Š16â”Š        expect(this.polygon.hasPoint(x, y)).toBeTruthy();\n+â”Š  â”Š17â”Š      });\n+â”Š  â”Š18â”Š    });\n+â”Š  â”Š19â”Š\n+â”Š  â”Š20â”Š    describe(\"given outranged point\", function() {\n+â”Š  â”Š21â”Š      it(\"returns false\", function() {\n+â”Š  â”Š22â”Š        let x = 10;\n+â”Š  â”Š23â”Š        let y = 10;\n+â”Š  â”Š24â”Š        expect(this.polygon.hasPoint(x, y)).toBeFalsy();\n+â”Š  â”Š25â”Š      });\n+â”Š  â”Š26â”Š    });\n+â”Š  â”Š27â”Š  });\n+â”Š  â”Š28â”Š\n+â”Š  â”Š29â”Š  describe(\"getLineIntersection method\", function() {\n+â”Š  â”Š30â”Š    describe(\"given intersecting line\", function() {\n+â”Š  â”Š31â”Š      it(\"returns intersection point\", function() {\n+â”Š  â”Š32â”Š        let line = new Engine.Geometry.Line(0, 1, 5, 4);\n+â”Š  â”Š33â”Š\n+â”Š  â”Š34â”Š        expect(this.polygon.getLineIntersection(line)).toEqual([\n+â”Š  â”Š35â”Š          { x: 5, y: 4 },\n+â”Š  â”Š36â”Š          { x: 0, y: 1 }\n+â”Š  â”Š37â”Š        ]);\n+â”Š  â”Š38â”Š      });\n+â”Š  â”Š39â”Š    });\n+â”Š  â”Š40â”Š\n+â”Š  â”Š41â”Š    describe(\"given outranged line\", function() {\n+â”Š  â”Š42â”Š      it(\"returns nothing\", function() {\n+â”Š  â”Š43â”Š        let line = new Engine.Geometry.Line(10, 11, 15, 14);\n+â”Š  â”Š44â”Š\n+â”Š  â”Š45â”Š        expect(this.polygon.getLineIntersection(line)).toBeUndefined();\n+â”Š  â”Š46â”Š      });\n+â”Š  â”Š47â”Š    });\n+â”Š  â”Š48â”Š  });\n+â”Š  â”Š49â”Š\n+â”Š  â”Š50â”Š  describe(\"getCircleIntersection method\", function() {\n+â”Š  â”Š51â”Š    describe(\"given circle with 2 intersection points\", function() {\n+â”Š  â”Š52â”Š      it(\"returns array with intersection points\", function() {\n+â”Š  â”Š53â”Š        let circle = new Engine.Geometry.Circle(0, 0, 2, 0, 2 * Math.PI);\n+â”Š  â”Š54â”Š\n+â”Š  â”Š55â”Š        expect(this.polygon.getCircleIntersection(circle)).toEqual([\n+â”Š  â”Š56â”Š          { x: 2, y: 0 },\n+â”Š  â”Š57â”Š          { x: 0, y: 2 }\n+â”Š  â”Š58â”Š        ]);\n+â”Š  â”Š59â”Š      });\n+â”Š  â”Š60â”Š    });\n+â”Š  â”Š61â”Š\n+â”Š  â”Š62â”Š    describe(\"given circle with 1 intersection points\", function() {\n+â”Š  â”Š63â”Š      it(\"returns array with intersection point\", function() {\n+â”Š  â”Š64â”Š        let circle = new Engine.Geometry.Circle(0, 0, 2, 0, 0.25 * Math.PI);\n+â”Š  â”Š65â”Š\n+â”Š  â”Š66â”Š        expect(this.polygon.getCircleIntersection(circle)).toEqual([\n+â”Š  â”Š67â”Š          { x: 2, y: 0 }\n+â”Š  â”Š68â”Š        ]);\n+â”Š  â”Š69â”Š      });\n+â”Š  â”Š70â”Š    });\n+â”Š  â”Š71â”Š\n+â”Š  â”Š72â”Š    describe(\"given kissing circle\", function() {\n+â”Š  â”Š73â”Š      it(\"returns array with intersection point\", function() {\n+â”Š  â”Š74â”Š        let circle = new Engine.Geometry.Circle(-3, 3, 3, 0, 2 * Math.PI);\n+â”Š  â”Š75â”Š\n+â”Š  â”Š76â”Š        expect(this.polygon.getCircleIntersection(circle)).toEqual([\n+â”Š  â”Š77â”Š          { x: 0, y: 3 }\n+â”Š  â”Š78â”Š        ]);\n+â”Š  â”Š79â”Š      });\n+â”Š  â”Š80â”Š    });\n+â”Š  â”Š81â”Š\n+â”Š  â”Š82â”Š    describe(\"given outer circle\", function() {\n+â”Š  â”Š83â”Š      it(\"returns nothing\", function() {\n+â”Š  â”Š84â”Š        let circle = new Engine.Geometry.Circle(10, 10, 2, 0, 2 * Math.PI);\n+â”Š  â”Š85â”Š        expect(this.polygon.getCircleIntersection(circle)).toBeUndefined();\n+â”Š  â”Š86â”Š      });\n+â”Š  â”Š87â”Š    });\n+â”Š  â”Š88â”Š\n+â”Š  â”Š89â”Š    describe(\"given inner circle\", function() {\n+â”Š  â”Š90â”Š      it(\"nothing\", function() {\n+â”Š  â”Š91â”Š        let circle = new Engine.Geometry.Circle(2.5, 2.5, 2, 0, 2 * Math.PI);\n+â”Š  â”Š92â”Š        expect(this.polygon.getCircleIntersection(circle)).toBeUndefined();\n+â”Š  â”Š93â”Š      });\n+â”Š  â”Š94â”Š    });\n+â”Š  â”Š95â”Š  });\n+â”Š  â”Š96â”Š});ðŸš«â†µ\n```\n\n##### Changed views&#x2F;spec_runner.html\n```diff\n@@ -20,10 +20,12 @@\n â”Š20â”Š20â”Š    <script type=\"text/javascript\" src=\"scripts/namespaces.js\"></script>\n â”Š21â”Š21â”Š    <script type=\"text/javascript\" src=\"scripts/engine/geometry/line.js\"></script>\n â”Š22â”Š22â”Š    <script type=\"text/javascript\" src=\"scripts/engine/geometry/circle.js\"></script>\n+â”Š  â”Š23â”Š    <script type=\"text/javascript\" src=\"scripts/engine/geometry/polygon.js\"></script>\n â”Š23â”Š24â”Š\n â”Š24â”Š25â”Š    <!-- Specs -->\n â”Š25â”Š26â”Š    <script type=\"text/javascript\" src=\"scripts/specs/engine/geometry/line.js\"></script>\n â”Š26â”Š27â”Š    <script type=\"text/javascript\" src=\"scripts/specs/engine/geometry/circle.js\"></script>\n+â”Š  â”Š28â”Š    <script type=\"text/javascript\" src=\"scripts/specs/engine/geometry/polygon.js\"></script>\n â”Š27â”Š29â”Š  </head>\n â”Š28â”Š30â”Š\n â”Š29â”Š31â”Š  <body>\n```\n\n[}]: #\n\nAt last, all the necessary geometry shapes are implemented and ready to use. We will now focus on the snake itself. Since our game can potentially have infinite number of entities, not necessarily just a snake, we will add the a new module under the `Game` namespace called `Entities`:\n\n[{]: <helper> (diffStep 5.13)\n\n#### [Step 5.13: Add &#x27;Entities&#x27; module to &#x27;Game&#x27; namespace](https://github.com/DAB0mB/radial-snake/commit/a0bed8c)\n\n##### Changed resources&#x2F;scripts&#x2F;namespaces.js\n```diff\n@@ -1,4 +1,5 @@\n â”Š1â”Š1â”ŠGame = {\n+â”Š â”Š2â”Š  Entities: {},\n â”Š2â”Š3â”Š  Screens: {}\n â”Š3â”Š4â”Š};\n```\n\n[}]: #\n\nAnd now we can add the `Snake` class:\n\n[{]: <helper> (diffStep 5.14)\n\n#### [Step 5.14: Create &#x27;Snake&#x27; class](https://github.com/DAB0mB/radial-snake/commit/b938ba7)\n\n##### Added resources&#x2F;scripts&#x2F;game&#x2F;entities&#x2F;snake.js\n```diff\n@@ -0,0 +1,234 @@\n+â”Š   â”Š  1â”ŠGame.Entities.Snake = class Snake {\n+â”Š   â”Š  2â”Š  // Represents a snake data-structure which will eventually appear on screen.\n+â”Š   â”Š  3â”Š  // All the properties provided to the constructor are the initial values of\n+â”Š   â”Š  4â”Š  // the snake\n+â”Š   â”Š  5â”Š  constructor(x, y, r, rad, v, color, keyStates, options) {\n+â”Š   â”Š  6â”Š    this.x = x;\n+â”Š   â”Š  7â”Š    this.y = y;\n+â”Š   â”Š  8â”Š    this.r = r;\n+â”Š   â”Š  9â”Š    this.rad = rad;\n+â”Š   â”Š 10â”Š    this.v = v;\n+â”Š   â”Š 11â”Š    this.color = color;\n+â”Š   â”Š 12â”Š    this.keyStates = keyStates;\n+â”Š   â”Š 13â”Š    // A snake is made out of many geometry shapes\n+â”Š   â”Š 14â”Š    this.shapes = [];\n+â”Š   â”Š 15â”Š    // A snake starts with a line\n+â”Š   â”Š 16â”Š    this.currentShape = new Engine.Geometry.Line(x, y, x, y);\n+â”Š   â”Š 17â”Š    this.shapes.push(this.currentShape);\n+â”Š   â”Š 18â”Š    // A score can be provided in case we want to reserve previous scores from\n+â”Š   â”Š 19â”Š    // recent matches\n+â”Š   â”Š 20â”Š    this.score = options.score || 0;\n+â”Š   â”Š 21â”Š\n+â”Š   â”Š 22â”Š    // Custom keys can be specified\n+â”Š   â”Š 23â”Š    if (options.keys && options.keys) {\n+â”Š   â”Š 24â”Š      this.leftKey = options.keys.left;\n+â”Š   â”Š 25â”Š      this.rightKey = options.keys.right;\n+â”Š   â”Š 26â”Š    }\n+â”Š   â”Š 27â”Š    // Left and right arrow keys will be used by default\n+â”Š   â”Š 28â”Š    else {\n+â”Š   â”Š 29â”Š      this.leftKey = 37; // Left arrow\n+â”Š   â”Š 30â”Š      this.rightKey = 39; // Right arrow\n+â”Š   â”Š 31â”Š    }\n+â”Š   â”Š 32â”Š  }\n+â”Š   â”Š 33â”Š\n+â”Š   â”Š 34â”Š  draw(context) {\n+â”Š   â”Š 35â”Š    // Draw all shapes in the shapes array\n+â”Š   â”Š 36â”Š    this.shapes.forEach(shape => {\n+â”Š   â”Š 37â”Š      context.save();\n+â”Š   â”Š 38â”Š      context.strokeStyle = this.color;\n+â”Š   â”Š 39â”Š      context.lineWidth = 3;\n+â”Š   â”Š 40â”Š      context.beginPath();\n+â”Š   â”Š 41â”Š\n+â”Š   â”Š 42â”Š      // Each shape has its own unique drawing method\n+â”Š   â”Š 43â”Š      shape.draw(context);\n+â”Š   â”Š 44â”Š\n+â”Š   â”Š 45â”Š      context.stroke();\n+â”Š   â”Š 46â”Š      context.restore();\n+â”Š   â”Š 47â”Š    });\n+â”Š   â”Š 48â”Š  }\n+â”Š   â”Š 49â”Š\n+â”Š   â”Š 50â”Š  update(span, width, height) {\n+â”Š   â”Š 51â”Š    // Progress made based on elapsed time and velocity\n+â”Š   â”Š 52â”Š    let step = (this.v * span) / 1000;\n+â”Š   â”Š 53â”Š\n+â”Š   â”Š 54â”Š    this.updateShapes(step, width, height);\n+â”Š   â”Š 55â”Š    this.cycleThrough(step, width, height);\n+â”Š   â”Š 56â”Š  }\n+â”Š   â”Š 57â”Š\n+â”Š   â”Š 58â”Š  // Updates shapes array based on progress made\n+â”Š   â”Š 59â”Š  updateShapes(step, width, height, options = {}) {\n+â”Š   â”Š 60â”Š    this.updateCurrentShape(step, options);\n+â”Š   â”Š 61â”Š    this.updateDirection(step, options);\n+â”Š   â”Š 62â”Š  }\n+â”Š   â”Š 63â”Š\n+â”Š   â”Š 64â”Š  // Updates current shape\n+â”Š   â”Š 65â”Š  updateCurrentShape(step, options) {\n+â”Š   â”Š 66â”Š    if (this.currentShape instanceof Engine.Geometry.Line)\n+â”Š   â”Š 67â”Š      return this.updateCurrentLine(options);\n+â”Š   â”Š 68â”Š    if (this.currentShape instanceof Engine.Geometry.Circle)\n+â”Š   â”Š 69â”Š      return this.updateCurrentCircle(options);\n+â”Š   â”Š 70â”Š  }\n+â”Š   â”Š 71â”Š\n+â”Š   â”Š 72â”Š  // Updates current shape in case it is a line\n+â”Š   â”Š 73â”Š  updateCurrentLine(options) {\n+â”Š   â”Š 74â”Š    let lastX = options.lastX || this.x;\n+â”Š   â”Š 75â”Š    let lastY = options.lastY || this.y;\n+â”Š   â”Š 76â”Š    this.x = options.x || this.currentShape.x2;\n+â”Š   â”Š 77â”Š    this.y = options.y || this.currentShape.y2;\n+â”Š   â”Š 78â”Š    this.lastBit = new Engine.Geometry.Line(lastX, lastY, this.x, this.y);\n+â”Š   â”Š 79â”Š  }\n+â”Š   â”Š 80â”Š\n+â”Š   â”Š 81â”Š  // Updates current shape in case it is a circle\n+â”Š   â”Š 82â”Š  updateCurrentCircle(options) {\n+â”Š   â”Š 83â”Š    let lastX = options.lastX || this.currentShape.x;\n+â”Š   â”Š 84â”Š    let lastY = options.lastY || this.currentShape.y;\n+â”Š   â”Š 85â”Š    let lastR = options.lastR || this.currentShape.r;\n+â”Š   â”Š 86â”Š\n+â”Š   â”Š 87â”Š    // Update logic for left rotation\n+â”Š   â”Š 88â”Š    if (this.direction == \"left\") {\n+â”Š   â”Š 89â”Š      let lastRad = this.rad + (0.5 * Math.PI);\n+â”Š   â”Š 90â”Š      let currentShapePoint = this.currentShape.getPoint(this.currentShape.rad1);\n+â”Š   â”Š 91â”Š      this.x = options.x || currentShapePoint.x;\n+â”Š   â”Š 92â”Š      this.y = options.y || currentShapePoint.y;\n+â”Š   â”Š 93â”Š      this.rad = this.currentShape.rad1 - (0.5 * Math.PI);\n+â”Š   â”Š 94â”Š      this.lastBit = new Engine.Geometry.Circle(lastX, lastY, lastR, this.currentShape.rad1, lastRad);\n+â”Š   â”Š 95â”Š    }\n+â”Š   â”Š 96â”Š    // Update logic for right rotation\n+â”Š   â”Š 97â”Š    else {\n+â”Š   â”Š 98â”Š      let lastRad = this.rad - (0.5 * Math.PI);\n+â”Š   â”Š 99â”Š      let currentShapePoint = this.currentShape.getPoint(this.currentShape.rad2);\n+â”Š   â”Š100â”Š      this.x = options.x || currentShapePoint.x;\n+â”Š   â”Š101â”Š      this.y = options.y || currentShapePoint.y;\n+â”Š   â”Š102â”Š      this.rad = this.currentShape.rad2 + (0.5 * Math.PI);\n+â”Š   â”Š103â”Š      this.lastBit = new Engine.Geometry.Circle(lastX, lastY, lastR, lastRad, this.currentShape.rad2);\n+â”Š   â”Š104â”Š    }\n+â”Š   â”Š105â”Š  }\n+â”Š   â”Š106â”Š\n+â”Š   â”Š107â”Š  updateDirection(step, options) {\n+â”Š   â”Š108â”Š    // Update the direction based on pressed key\n+â”Š   â”Š109â”Š    if (this.keyStates.get(this.leftKey))\n+â”Š   â”Š110â”Š      var direction = \"left\";\n+â”Š   â”Š111â”Š    else if (this.keyStates.get(this.rightKey))\n+â”Š   â”Š112â”Š      var direction = \"right\";\n+â”Š   â”Š113â”Š\n+â”Š   â”Š114â”Š    this.changeDirection(step, direction, options);\n+â”Š   â”Š115â”Š    this.continueDirection(step, direction, options);\n+â”Š   â”Š116â”Š  }\n+â”Š   â”Š117â”Š\n+â”Š   â”Š118â”Š  // Change the recent shape type according to the given direction\n+â”Š   â”Š119â”Š  changeDirection(step, direction, options) {\n+â”Š   â”Š120â”Š    // If there is no change in direction, abort, unless we force it\n+â”Š   â”Š121â”Š    if (direction == this.direction && !options.force) return;\n+â”Š   â”Š122â”Š\n+â”Š   â”Š123â”Š    this.direction = direction;\n+â”Š   â”Š124â”Š\n+â”Š   â”Š125â”Š    // This will push a new shape with new properties, based on the direction\n+â”Š   â”Š126â”Š    switch (direction) {\n+â”Š   â”Š127â”Š      case \"left\":\n+â”Š   â”Š128â”Š        var angle = this.rad - (0.5 * Math.PI);\n+â”Š   â”Š129â”Š        var rad = this.rad + (0.5 * Math.PI);\n+â”Š   â”Š130â”Š        var x = this.x + (this.r * Math.cos(angle));\n+â”Š   â”Š131â”Š        var y = this.y + (this.r * Math.sin(angle));\n+â”Š   â”Š132â”Š        this.currentShape = new Engine.Geometry.Circle(x, y, this.r, rad, rad);\n+â”Š   â”Š133â”Š        break;\n+â”Š   â”Š134â”Š      case \"right\":\n+â”Š   â”Š135â”Š        angle = this.rad + (0.5 * Math.PI);\n+â”Š   â”Š136â”Š        rad = this.rad - (0.5 * Math.PI);\n+â”Š   â”Š137â”Š        x = this.x + (this.r * Math.cos(angle));\n+â”Š   â”Š138â”Š        y = this.y + (this.r * Math.sin(angle));\n+â”Š   â”Š139â”Š        this.currentShape = new Engine.Geometry.Circle(x, y, this.r, rad, rad);\n+â”Š   â”Š140â”Š        break;\n+â”Š   â”Š141â”Š      default:\n+â”Š   â”Š142â”Š        this.currentShape = new Engine.Geometry.Line(this.x, this.y, this.x, this.y);\n+â”Š   â”Š143â”Š    }\n+â”Š   â”Š144â”Š\n+â”Š   â”Š145â”Š    this.shapes.push(this.currentShape);\n+â”Š   â”Š146â”Š  }\n+â”Š   â”Š147â”Š\n+â”Š   â”Š148â”Š  // Extend the recent shape based on progress made\n+â”Š   â”Š149â”Š  continueDirection(step, direction) {\n+â”Š   â”Š150â”Š    switch (direction) {\n+â”Š   â”Š151â”Š      case \"left\":\n+â”Š   â”Š152â”Š        this.currentShape.rad1 -= step / this.r;\n+â”Š   â”Š153â”Š        break;\n+â”Š   â”Š154â”Š      case \"right\":\n+â”Š   â”Š155â”Š        this.currentShape.rad2 += step / this.r;\n+â”Š   â”Š156â”Š        break;\n+â”Š   â”Š157â”Š      default:\n+â”Š   â”Š158â”Š        this.currentShape.x2 += step * Math.cos(this.rad);\n+â”Š   â”Š159â”Š        this.currentShape.y2 += step * Math.sin(this.rad);\n+â”Š   â”Š160â”Š    }\n+â”Š   â”Š161â”Š  }\n+â”Š   â”Š162â”Š\n+â”Š   â”Š163â”Š  // Handles case where snake is out limits and we need to render it from\n+â”Š   â”Š164â”Š  // the other side of the canvas\n+â”Š   â”Š165â”Š  cycleThrough(step, width, height) {\n+â”Š   â”Š166â”Š    let intersectionPoint = this.getCanvasIntersection(width, height);\n+â”Š   â”Š167â”Š\n+â”Š   â”Š168â”Š    if (!intersectionPoint) return;\n+â”Š   â”Š169â”Š\n+â”Š   â”Š170â”Š    intersectionPoint = intersectionPoint[0];\n+â”Š   â”Š171â”Š\n+â”Š   â”Š172â”Š    // Re-calculate position based on canvas bounds\n+â”Š   â”Š173â”Š    if (intersectionPoint.x % width == 0)\n+â”Š   â”Š174â”Š      this.x = Utils.mod(this.x - width, width);\n+â”Š   â”Š175â”Š    if (intersectionPoint.y % height == 0)\n+â”Š   â”Š176â”Š      this.y = Utils.mod(this.y - height, height);\n+â”Š   â”Š177â”Š\n+â”Š   â”Š178â”Š    // Update shapes again based on custom properties\n+â”Š   â”Š179â”Š    this.updateShapes(step, width, height, {\n+â”Š   â”Š180â”Š      force: true,\n+â”Š   â”Š181â”Š      lastX: this.x,\n+â”Š   â”Š182â”Š      lastY: this.y,\n+â”Š   â”Š183â”Š      x: this.x,\n+â”Š   â”Š184â”Š      y: this.y\n+â”Š   â”Š185â”Š    });\n+â”Š   â”Š186â”Š  }\n+â”Š   â”Š187â”Š\n+â”Š   â”Š188â”Š  // Gets intersection points between last bit and own shapes\n+â”Š   â”Š189â”Š  getSelfIntersection() {\n+â”Š   â”Š190â”Š    if (this.currentShape instanceof Engine.Geometry.Circle &&\n+â”Š   â”Š191â”Š       Math.abs(this.currentShape.rad1 - this.currentShape.rad2) >= 2 * Math.PI) {\n+â”Š   â”Š192â”Š      if (this.direction == \"left\")\n+â”Š   â”Š193â”Š        var rad = this.currentShape.rad1;\n+â”Š   â”Š194â”Š      else\n+â”Š   â”Š195â”Š        var rad = this.currentShape.rad2;\n+â”Š   â”Š196â”Š\n+â”Š   â”Š197â”Š      return this.currentShape.getPoint(rad);\n+â”Š   â”Š198â”Š    }\n+â”Š   â”Š199â”Š\n+â”Š   â”Š200â”Š    let result;\n+â”Š   â”Š201â”Š\n+â”Š   â”Š202â”Š    this.shapes.slice(0, -2).some(shape =>\n+â”Š   â”Š203â”Š      result = this.lastBit.getIntersection(shape)\n+â”Š   â”Š204â”Š    );\n+â”Š   â”Š205â”Š\n+â”Š   â”Š206â”Š    return result;\n+â”Š   â”Š207â”Š  }\n+â”Š   â”Š208â”Š\n+â”Š   â”Š209â”Š  // Returns intersection points between snakes\n+â”Š   â”Š210â”Š  getSnakeIntersection(snake) {\n+â”Š   â”Š211â”Š    let result;\n+â”Š   â”Š212â”Š\n+â”Š   â”Š213â”Š    snake.shapes.some(shape =>\n+â”Š   â”Š214â”Š      // Only last bit is relevant, if we reached this point it means that\n+â”Š   â”Š215â”Š      // previous intersection will definitely fail\n+â”Š   â”Š216â”Š      result = this.lastBit.getIntersection(shape)\n+â”Š   â”Š217â”Š    );\n+â”Š   â”Š218â”Š\n+â”Š   â”Š219â”Š    return result;\n+â”Š   â”Š220â”Š  }\n+â”Š   â”Š221â”Š\n+â”Š   â”Š222â”Š  // Returns intersection points between snake and canvas\n+â”Š   â”Š223â”Š  getCanvasIntersection(width, height) {\n+â”Š   â”Š224â”Š    // Canvas polygon\n+â”Š   â”Š225â”Š    let canvasPolygon = new Engine.Geometry.Polygon(\n+â”Š   â”Š226â”Š      [0, 0, width, 0],\n+â”Š   â”Š227â”Š      [width, 0, width, height],\n+â”Š   â”Š228â”Š      [width, height, 0, height],\n+â”Š   â”Š229â”Š      [0, height, 0, 0]\n+â”Š   â”Š230â”Š    );\n+â”Š   â”Š231â”Š\n+â”Š   â”Š232â”Š    return canvasPolygon.getIntersection(this.lastBit);\n+â”Š   â”Š233â”Š  }\n+â”Š   â”Š234â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -22,6 +22,7 @@\n â”Š22â”Š22â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/screen.js\"></script>\n â”Š23â”Š23â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/assets_loader.js\"></script>\n â”Š24â”Š24â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n+â”Š  â”Š25â”Š    <script type=\"text/javascript\" src=\"/scripts/game/entities/snake.js\"></script>\n â”Š25â”Š26â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/menu/index.js\"></script>\n â”Š26â”Š27â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/splash/index.js\"></script>\n â”Š27â”Š28â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n```\n\n[}]: #\n\nThis class is titled with most complexity out of everything we did so far in this step. You can follow the code accompanied by comments regard it, but I'd also like to explain the key concepts. As said earlier, the `Snake` is simply made out of shapes; In this case - lines and circles.\n\nThe `draw` method just goes through this array and draws whatever shape it's currently looping through. Regardless of its type, every shape is provided with a `draw` method of its own, all shapes share the same interface, therefore we can just draw them regularly and the snake should be drawn automatically.\n\nThe `update` method updates the last bit only according to its type, the time elapsed and the speed of the snake. For example, the last bit of the snake is a line, and 5 seconds have passed at a speed of 5 meters per second, our line should be extended by 5 meters long. Same principle applies to circle extension only based on radians. The last bit's type might be changed according to the current input; e.g. if the `right` key is held the last bit would turn into a circle, and once released it would turn into a straight line.\n\nNote that besides shapes extension, collision detection should also be made. The embedded is the collision detection between the snake and the canvas, which means that any time the snake collides with the canvas's boundaries the last bit should be redrawn from the opposite side of the canvas. In addition, we've implemented intersection methods for self collision detection and collision detection between rivals, which should be used externally by the hosting screen.\n\nIn the next step we will be implementing the game screen where we will make use of the `Snake` class we've just created, and see how it works in action."
          },
          {
            "manualTitle": "Step 6: Creating a complex game screen with multiple layers",
            "stepRevision": "c27bb0d7806aab70ec489ccd9bbff182d1053dda",
            "manualView": "![snake-demo-game-small](https://cloud.githubusercontent.com/assets/7648874/21074124/8b7cd724-bed7-11e6-9f91-2a211630ac78.gif)\n\nIn this step we will be using the `Snake` class we've just created in the previous step to form the actual game screen - called the `Play` screen. The play screen is a complex screen made out multiple layers as following:\n\n- **`Ready` layer** - Displays a message at the beginning of each match.\n- **`Snake` layer** - Displays the the competitors' snakes.\n- **`Score` layer** - Displays the score board.\n- **`Win` layer** - Displays the winner at the end of each match.\n\nAs we go further with this step, we will give a deeper explanation about each layer and how they interact with each other; As for let's start with the `Play` screen's basis. Regardless of what the `Play` screen should contain at the final result, we want to have the ability to abort the match whenever we press the `Escape` key, therefore, the initial implementation should look like this:\n\n[{]: <helper> (diffStep 6.1)\n\n#### [Step 6.1: Create &#x27;Play&#x27; screen](https://github.com/DAB0mB/radial-snake/commit/e17a45f)\n\n##### Added resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;play&#x2F;index.js\n```diff\n@@ -0,0 +1,14 @@\n+â”Š  â”Š 1â”ŠGame.Screens.Play = class Play extends Engine.Screen {\n+â”Š  â”Š 2â”Š  get events() {\n+â”Š  â”Š 3â”Š    return {\n+â”Š  â”Š 4â”Š      \"keydown\": \"onKeyDown\"\n+â”Š  â”Š 5â”Š    }\n+â”Š  â”Š 6â”Š  }\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Š  onKeyDown() {\n+â”Š  â”Š 9â”Š    // Once escape is pressed, return to main menu screen\n+â”Š  â”Š10â”Š    if (this.keyStates.get(27)) {\n+â”Š  â”Š11â”Š      this.game.changeScreen(Game.Screens.Menu);\n+â”Š  â”Š12â”Š    }\n+â”Š  â”Š13â”Š  }\n+â”Š  â”Š14â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -23,6 +23,7 @@\n â”Š23â”Š23â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/assets_loader.js\"></script>\n â”Š24â”Š24â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š25â”Š25â”Š    <script type=\"text/javascript\" src=\"/scripts/game/entities/snake.js\"></script>\n+â”Š  â”Š26â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/index.js\"></script>\n â”Š26â”Š27â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/menu/index.js\"></script>\n â”Š27â”Š28â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/splash/index.js\"></script>\n â”Š28â”Š29â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n```\n\n[}]: #\n\nNow that we have the `Play` screen, we need to hook it to the `Menu` screen, so whenever we press a key, we will be proceeded to it:\n\n[{]: <helper> (diffStep 6.2)\n\n#### [Step 6.2: Hook &#x27;Play&#x27; screen to &#x27;menu&#x27; screen](https://github.com/DAB0mB/radial-snake/commit/495b9ee)\n\n##### Changed resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;menu&#x2F;index.js\n```diff\n@@ -1,4 +1,10 @@\n â”Š 1â”Š 1â”ŠGame.Screens.Menu = class Menu extends Engine.Screen {\n+â”Š  â”Š 2â”Š  get events() {\n+â”Š  â”Š 3â”Š    return {\n+â”Š  â”Š 4â”Š      \"keydown\": \"onKeyDown\"\n+â”Š  â”Š 5â”Š    }\n+â”Š  â”Š 6â”Š  }\n+â”Š  â”Š 7â”Š\n â”Š 2â”Š 8â”Š  initialize() {\n â”Š 3â”Š 9â”Š    // Initialize snake logo sprite\n â”Š 4â”Š10â”Š    this.logoSprite = new Engine.Sprite(this.assets.logoTexture);\n```\n```diff\n@@ -40,10 +46,18 @@\n â”Š40â”Š46â”Š  }\n â”Š41â”Š47â”Š\n â”Š42â”Š48â”Š  update(span) {\n-â”Š43â”Š  â”Š    this.instructionsAnim.update(span);\n+â”Š  â”Š49â”Š    // On key press, proceed to play screen\n+â”Š  â”Š50â”Š    if (this.keyPressed) {\n+â”Š  â”Š51â”Š      this.game.changeScreen(Game.Screens.Play);\n+â”Š  â”Š52â”Š    }\n+â”Š  â”Š53â”Š    // Else, just update animation\n+â”Š  â”Š54â”Š    else {\n+â”Š  â”Š55â”Š      this.instructionsAnim.update(span);\n+â”Š  â”Š56â”Š    }\n â”Š44â”Š57â”Š  }\n â”Š45â”Š58â”Š\n-â”Š46â”Š  â”Š  update(span) {\n-â”Š47â”Š  â”Š    this.instructionsAnim.update(span);\n+â”Š  â”Š59â”Š  // Register key press\n+â”Š  â”Š60â”Š  onKeyDown(e) {\n+â”Š  â”Š61â”Š    this.keyPressed = true;\n â”Š48â”Š62â”Š  }\n â”Š49â”Š63â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nBy now there shouldn't be anything special. Once you're at the main menu, just press a key as instructed, and you shall see a black screen, which is actually the `Play` screen we've just created; And once you'll press the `Escape` key, you should be receded to the main menu.\n\nThe next stage would be displaying a `Ready` message on the screen, and whenever a key is pressed, the message should fade away using a key-frame animation, and the match should start in the background:\n\n[{]: <helper> (diffStep 6.3)\n\n#### [Step 6.3: Create &#x27;Ready&#x27; layer](https://github.com/DAB0mB/radial-snake/commit/551962d)\n\n##### Added resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;play&#x2F;ready.js\n```diff\n@@ -0,0 +1,59 @@\n+â”Š  â”Š 1â”ŠGame.Screens.Play.Ready = class Ready extends Engine.Layer {\n+â”Š  â”Š 2â”Š  get events() {\n+â”Š  â”Š 3â”Š    return {\n+â”Š  â”Š 4â”Š      \"keydown\": \"onKeyDown\"\n+â”Š  â”Š 5â”Š    };\n+â”Š  â”Š 6â”Š  }\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Š  constructor(screen, snakes) {\n+â”Š  â”Š 9â”Š    super(screen);\n+â”Š  â”Š10â”Š\n+â”Š  â”Š11â”Š    this.snakes = snakes;\n+â”Š  â”Š12â”Š\n+â”Š  â”Š13â”Š    // Create \"ready\" sprite and set its properties\n+â”Š  â”Š14â”Š    let readyTexture = this.assets.minecraftiaFont.createTexture(\"Ready\");\n+â”Š  â”Š15â”Š    let readySprite = new Engine.Sprite(readyTexture);\n+â”Š  â”Š16â”Š    readySprite.align = \"center\";\n+â”Š  â”Š17â”Š    readySprite.setPercentage(\"width\", this.width, 15, \"height\");\n+â”Š  â”Š18â”Š\n+â”Š  â”Š19â”Š    // Create fade out animation for \"ready\" sprite\n+â”Š  â”Š20â”Š    this.readyAnim = new Engine.Animations.Keyframe(readySprite, [\n+â”Š  â”Š21â”Š      {\n+â”Š  â”Š22â”Š        x: this.width / 2,\n+â”Š  â”Š23â”Š        y: this.height / 2,\n+â”Š  â”Š24â”Š        opacity: 1,\n+â”Š  â”Š25â”Š        frame: 0\n+â”Š  â”Š26â”Š      },\n+â”Š  â”Š27â”Š      {\n+â”Š  â”Š28â”Š        y: this.height / 3,\n+â”Š  â”Š29â”Š        opacity: 0,\n+â”Š  â”Š30â”Š        frame: 700\n+â”Š  â”Š31â”Š      }\n+â”Š  â”Š32â”Š    ]);\n+â”Š  â”Š33â”Š  }\n+â”Š  â”Š34â”Š\n+â”Š  â”Š35â”Š  draw(context) {\n+â”Š  â”Š36â”Š    this.readyAnim.draw(context);\n+â”Š  â”Š37â”Š  }\n+â”Š  â”Š38â”Š\n+â”Š  â”Š39â”Š  update(span) {\n+â”Š  â”Š40â”Š    if (!this.ready) return;\n+â”Š  â”Š41â”Š\n+â”Š  â”Š42â”Š    if (this.readyAnim.playing) {\n+â”Š  â”Š43â”Š      this.readyAnim.update(span);\n+â”Š  â”Š44â”Š    }\n+â”Š  â”Š45â”Š    // Once animation is finished, dispose layer\n+â”Š  â”Š46â”Š    else {\n+â”Š  â”Š47â”Š      this.screen.removeLayer(this);\n+â”Š  â”Š48â”Š    }\n+â”Š  â”Š49â”Š  }\n+â”Š  â”Š50â”Š\n+â”Š  â”Š51â”Š  onKeyDown() {\n+â”Š  â”Š52â”Š    // One time event\n+â”Š  â”Š53â”Š    this.disposeEventListeners()\n+â”Š  â”Š54â”Š\n+â”Š  â”Š55â”Š    // This will start playing the animation\n+â”Š  â”Š56â”Š    this.ready = true;\n+â”Š  â”Š57â”Š    this.readyAnim.play();\n+â”Š  â”Š58â”Š  }\n+â”Š  â”Š59â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -24,6 +24,7 @@\n â”Š24â”Š24â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š25â”Š25â”Š    <script type=\"text/javascript\" src=\"/scripts/game/entities/snake.js\"></script>\n â”Š26â”Š26â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/index.js\"></script>\n+â”Š  â”Š27â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/ready.js\"></script>\n â”Š27â”Š28â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/menu/index.js\"></script>\n â”Š28â”Š29â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/splash/index.js\"></script>\n â”Š29â”Š30â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n```\n\n[}]: #\n\nIn order to hook the `Ready` layer to the `Play` screen, we will just push a new instance of it to the layers stack, using the screen's `appendLayer` method. Note that the order of the layer is super critic! Since if we push a new layer it means it will be drawn on top of any previous layer. To \"shift\" a layer to the layers stack, we can simply use the `prependLayer` method instead. Without further due, this is how our hook should look like:\n\n[{]: <helper> (diffStep 6.4)\n\n#### [Step 6.4: Hook &#x27;Ready&#x27; layer to &#x27;Play&#x27; screen](https://github.com/DAB0mB/radial-snake/commit/b461464)\n\n##### Changed resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;play&#x2F;index.js\n```diff\n@@ -5,6 +5,11 @@\n â”Š 5â”Š 5â”Š    }\n â”Š 6â”Š 6â”Š  }\n â”Š 7â”Š 7â”Š\n+â”Š  â”Š 8â”Š  // The ready screen will be the initial screen\n+â”Š  â”Š 9â”Š  initialize(game, snakes) {\n+â”Š  â”Š10â”Š    this.appendLayer(Game.Screens.Play.Ready, snakes);\n+â”Š  â”Š11â”Š  }\n+â”Š  â”Š12â”Š\n â”Š 8â”Š13â”Š  onKeyDown() {\n â”Š 9â”Š14â”Š    // Once escape is pressed, return to main menu screen\n â”Š10â”Š15â”Š    if (this.keyStates.get(27)) {\n```\n\n[}]: #\n\nNow if you'll launch the game and start a new match, you should see a white `Ready` message in the middle of the screen. Up next, would be the `Snake` layer, which will simply initialize 2 new `Snake` instances, and take care of drawing and updating them:\n\n[{]: <helper> (diffStep 6.5)\n\n#### [Step 6.5: Create &#x27;snake&#x27; layer](https://github.com/DAB0mB/radial-snake/commit/a36d7f2)\n\n##### Added resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;play&#x2F;snake.js\n```diff\n@@ -0,0 +1,79 @@\n+â”Š  â”Š 1â”ŠGame.Screens.Play.Snake = class Snake extends Engine.Layer {\n+â”Š  â”Š 2â”Š  constructor(screen, snakes = []) {\n+â”Š  â”Š 3â”Š    super(screen);\n+â”Š  â”Š 4â”Š\n+â”Š  â”Š 5â”Š    // Red snake\n+â”Š  â”Š 6â”Š    this.snakes = [\n+â”Š  â”Š 7â”Š      new Game.Entities.Snake(\n+â”Š  â”Š 8â”Š        this.width / 4,\n+â”Š  â”Š 9â”Š        this.height / 4,\n+â”Š  â”Š10â”Š        50,\n+â”Š  â”Š11â”Š        Math.PI / 4,\n+â”Š  â”Š12â”Š        100,\n+â”Š  â”Š13â”Š        \"FireBrick\",\n+â”Š  â”Š14â”Š        this.keyStates,\n+â”Š  â”Š15â”Š        {\n+â”Š  â”Š16â”Š          // Use score from previous matches\n+â”Š  â”Š17â”Š          score: snakes[0] && snakes[0].score,\n+â”Š  â”Š18â”Š          keys: {\n+â”Š  â”Š19â”Š            left: 37, // Left key\n+â”Š  â”Š20â”Š            right: 39 // RIght key\n+â”Š  â”Š21â”Š        }\n+â”Š  â”Š22â”Š      }),\n+â”Š  â”Š23â”Š\n+â”Š  â”Š24â”Š      // Blue snake\n+â”Š  â”Š25â”Š      new Game.Entities.Snake(\n+â”Š  â”Š26â”Š        (this.width / 4) * 3,\n+â”Š  â”Š27â”Š        (this.height / 4) * 3,\n+â”Š  â”Š28â”Š        50,\n+â”Š  â”Š29â”Š        (-Math.PI / 4) * 3,\n+â”Š  â”Š30â”Š        100,\n+â”Š  â”Š31â”Š        \"DodgerBlue\",\n+â”Š  â”Š32â”Š        this.keyStates,\n+â”Š  â”Š33â”Š        {\n+â”Š  â”Š34â”Š          score: snakes[1] && snakes[1].score,\n+â”Š  â”Š35â”Š          keys: {\n+â”Š  â”Š36â”Š            left: 65, // 'a' key\n+â”Š  â”Š37â”Š            right: 68 // 'b' key\n+â”Š  â”Š38â”Š        }\n+â”Š  â”Š39â”Š      })\n+â”Š  â”Š40â”Š    ];\n+â”Š  â”Š41â”Š  }\n+â”Š  â”Š42â”Š\n+â”Š  â”Š43â”Š  draw(context) {\n+â”Š  â”Š44â”Š    // Draw each snake in the snakes array\n+â”Š  â”Š45â”Š    this.snakes.forEach(snake => snake.draw(context));\n+â”Š  â”Š46â”Š  }\n+â”Š  â”Š47â”Š\n+â”Š  â”Š48â”Š  update(span) {\n+â”Š  â”Š49â”Š    if (!this.snakes.length) return;\n+â”Š  â”Š50â”Š\n+â”Š  â”Š51â”Š    // Storing original snakes array for future use, since it might get changed\n+â”Š  â”Š52â”Š    let snakes = this.snakes.slice();\n+â”Š  â”Š53â”Š\n+â”Š  â”Š54â”Š    snakes.forEach((snake, index) => {\n+â”Š  â”Š55â”Š      snake.update(span, this.width, this.height);\n+â”Š  â”Š56â”Š      // Disqualify if intersected with self\n+â”Š  â”Š57â”Š      if (snake.getSelfIntersection()) return this.snakes.splice(index, 1);\n+â”Š  â”Š58â”Š\n+â”Š  â”Š59â”Š      snakes.forEach((opponent) => {\n+â”Š  â”Š60â”Š        // Don't scan for intersection with self, obviously this will always be true\n+â”Š  â”Š61â”Š        if (opponent === snake) return;\n+â”Š  â”Š62â”Š        // Disqualify if intersected with opponent\n+â”Š  â”Š63â”Š        if (snake.getSnakeIntersection(opponent)) this.snakes.splice(index, 1);\n+â”Š  â”Š64â”Š      });\n+â”Š  â”Š65â”Š    });\n+â”Š  â”Š66â”Š\n+â”Š  â”Š67â”Š    // There can be only one winner, or a tie (very rare, most likely not to happen)\n+â”Š  â”Š68â”Š    // If the match is already finished, skip the next steps since they are not relevant\n+â”Š  â”Š69â”Š    if (this.snakes.length > 1 || this.matchFinished) return;\n+â”Š  â”Š70â”Š\n+â”Š  â”Š71â”Š    // The winner is the \"last snake standing\"\n+â”Š  â”Š72â”Š    let winner = this.snakes[0];\n+â”Š  â”Š73â”Š    // If this is not a tie, which is a very rare case, increase the winner's score\n+â”Š  â”Š74â”Š    if (winner) winner.score++;\n+â”Š  â”Š75â”Š\n+â”Š  â”Š76â”Š    // Indicates whether we should update the score counter or not\n+â”Š  â”Š77â”Š    this.matchFinished = true;\n+â”Š  â”Š78â”Š  }\n+â”Š  â”Š79â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -24,6 +24,7 @@\n â”Š24â”Š24â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š25â”Š25â”Š    <script type=\"text/javascript\" src=\"/scripts/game/entities/snake.js\"></script>\n â”Š26â”Š26â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/index.js\"></script>\n+â”Š  â”Š27â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/snake.js\"></script>\n â”Š27â”Š28â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/ready.js\"></script>\n â”Š28â”Š29â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/menu/index.js\"></script>\n â”Š29â”Š30â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/splash/index.js\"></script>\n```\n\n[}]: #\n\nOnce pressing a key in the `Ready` layer, not only we want to display an animation, but we also want the match to start in the background, thus, we gonna push a new instance of the `Snake` layer we've just created like so:\n\n[{]: <helper> (diffStep 6.6)\n\n#### [Step 6.6: Hook &#x27;snake&#x27; layer to &#x27;ready&#x27; layer](https://github.com/DAB0mB/radial-snake/commit/982db7b)\n\n##### Changed resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;play&#x2F;ready.js\n```diff\n@@ -55,5 +55,8 @@\n â”Š55â”Š55â”Š    // This will start playing the animation\n â”Š56â”Š56â”Š    this.ready = true;\n â”Š57â”Š57â”Š    this.readyAnim.play();\n+â”Š  â”Š58â”Š\n+â”Š  â”Š59â”Š    // Start the game in the background\n+â”Š  â”Š60â”Š    this.screen.prependLayer(Game.Screens.Play.Snake, this.snakes);\n â”Š58â”Š61â”Š  }\n â”Š59â”Š62â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nNote that the layer is pushed when the animation starts and not once finished; This would give a nice smooth feeling to our game-flow. If you'll test out the game, you would discover that the match is actually playable! The first snake (Red) snake should be controlled by the arrow keys, and the second snake (Blue) should be controlled by the letter keys `a`, `s`, `d` and `w`. So far, the snakes function great, but you can probably tell that whenever a match is finished, it feels a bit dull. There's no indication of winning, and there's no score board to present the score of each competitor, which brings us to the next stage - Implementing the `Score` layer.\n\nThe `Score` layer is a simple layer which takes the 2 snakes as a parameter and displays their scores at the top of the screen:\n\n[{]: <helper> (diffStep 6.7)\n\n#### [Step 6.7: Create &#x27;Score&#x27; layer](https://github.com/DAB0mB/radial-snake/commit/6ec4cac)\n\n##### Added resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;play&#x2F;score.js\n```diff\n@@ -0,0 +1,66 @@\n+â”Š  â”Š 1â”ŠGame.Screens.Play.Score = class Score extends Engine.Layer {\n+â”Š  â”Š 2â”Š  constructor(screen, snakes) {\n+â”Š  â”Š 3â”Š    super(screen);\n+â”Š  â”Š 4â”Š\n+â”Š  â”Š 5â”Š    this.snakes = snakes;\n+â”Š  â”Š 6â”Š    this.scoreSprites = [];\n+â”Š  â”Š 7â”Š    this.scores = [];\n+â”Š  â”Š 8â”Š\n+â”Š  â”Š 9â”Š    // It's important to match indexes to each snake since the number of snakes\n+â”Š  â”Š10â”Š    // can be reduced along the way as we play\n+â”Š  â”Š11â”Š    snakes.forEach((snake, index) => {\n+â”Š  â”Š12â”Š      snake.index = index;\n+â”Š  â”Š13â”Š    });\n+â”Š  â”Š14â”Š  }\n+â”Š  â”Š15â”Š\n+â”Š  â”Š16â”Š  draw(context) {\n+â”Š  â”Š17â”Š    this.scoreSprites.forEach((scoreSprite) => {\n+â”Š  â”Š18â”Š      scoreSprite.draw(context);\n+â”Š  â”Š19â”Š    });\n+â”Š  â”Š20â”Š  }\n+â”Š  â”Š21â”Š\n+â”Š  â”Š22â”Š  update(span) {\n+â”Š  â”Š23â”Š    this.snakes.forEach(snake => {\n+â”Š  â”Š24â”Š      let index = snake.index;\n+â”Š  â”Š25â”Š      if (this.scores[index] == snake.score) return;\n+â”Š  â”Š26â”Š\n+â”Š  â”Š27â”Š      // The sprite might be changed along the way so it's important to recreate it\n+â”Š  â”Š28â”Š      // over and over again. If no change was made the cache will be used by the engine\n+â”Š  â”Š29â”Š      this.scoreSprites[index] = this.createScoreSprite(snake);\n+â”Š  â”Š30â”Š      this.scores[index] = snake.score;\n+â”Š  â”Š31â”Š    });\n+â”Š  â”Š32â”Š  }\n+â”Š  â”Š33â”Š\n+â”Š  â”Š34â”Š  createScoreSprite(snake) {\n+â”Š  â”Š35â”Š    let minecraftiaFont = this.assets.minecraftiaFont;\n+â”Š  â”Š36â”Š    minecraftiaFont.save();\n+â”Š  â”Š37â”Š    minecraftiaFont.color = snake.color;\n+â”Š  â”Š38â”Š\n+â”Š  â”Š39â”Š    // Create a score sprite for the snake\n+â”Š  â”Š40â”Š    let scoreTexture = minecraftiaFont.createTexture(`${snake.score}`, {\n+â”Š  â”Š41â”Š      noOffsets: true,\n+â”Š  â”Š42â”Š      noSpaces: true\n+â”Š  â”Š43â”Š    });\n+â”Š  â”Š44â”Š\n+â”Š  â”Š45â”Š    let scoreSprite = new Engine.Sprite(scoreTexture);\n+â”Š  â”Š46â”Š\n+â”Š  â”Š47â”Š    // Size of score board is dynamic to screen size\n+â”Š  â”Š48â”Š    scoreSprite.setPercentage(\"width\", this.width, 4, \"height\");\n+â”Š  â”Š49â”Š\n+â”Š  â”Š50â”Š    // Set alignment modes.\n+â”Š  â”Š51â”Š    // Once we add more snakes we should add more cases here\n+â”Š  â”Š52â”Š    switch (snake.index) {\n+â”Š  â”Š53â”Š      case 0:\n+â”Š  â”Š54â”Š        scoreSprite.align = \"top-left\";\n+â”Š  â”Š55â”Š        break;\n+â”Š  â”Š56â”Š      case 1:\n+â”Š  â”Š57â”Š        scoreSprite.align = \"top-right\";\n+â”Š  â”Š58â”Š        scoreSprite.x = this.width;\n+â”Š  â”Š59â”Š        break;\n+â”Š  â”Š60â”Š    }\n+â”Š  â”Š61â”Š\n+â”Š  â”Š62â”Š    // Restore the font to its original color\n+â”Š  â”Š63â”Š    minecraftiaFont.restore();\n+â”Š  â”Š64â”Š    return scoreSprite;\n+â”Š  â”Š65â”Š  }\n+â”Š  â”Š66â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -24,6 +24,7 @@\n â”Š24â”Š24â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š25â”Š25â”Š    <script type=\"text/javascript\" src=\"/scripts/game/entities/snake.js\"></script>\n â”Š26â”Š26â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/index.js\"></script>\n+â”Š  â”Š27â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/score.js\"></script>\n â”Š27â”Š28â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/snake.js\"></script>\n â”Š28â”Š29â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/ready.js\"></script>\n â”Š29â”Š30â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/menu/index.js\"></script>\n```\n\n[}]: #\n\n> Note that the current score board is suitable for two players, but can easily be modified to support as much players as you want if done correctly.\n\nThe `Score` board should be appended to the layers stack as soon as the `Snake` layers is initialized, so it would be available to us once the match is started:\n\n[{]: <helper> (diffStep 6.8)\n\n#### [Step 6.8: Hook &#x27;Score&#x27; layer to &#x27;Snake&#x27; layer](https://github.com/DAB0mB/radial-snake/commit/feb4a0b)\n\n##### Changed resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;play&#x2F;snake.js\n```diff\n@@ -38,6 +38,9 @@\n â”Š38â”Š38â”Š        }\n â”Š39â”Š39â”Š      })\n â”Š40â”Š40â”Š    ];\n+â”Š  â”Š41â”Š\n+â”Š  â”Š42â”Š    // Show score board for newly created snakes\n+â”Š  â”Š43â”Š    screen.appendLayer(Game.Screens.Play.Score, this.snakes);\n â”Š41â”Š44â”Š  }\n â”Š42â”Š45â”Š\n â”Š43â”Š46â”Š  draw(context) {\n```\n\n[}]: #\n\nNow we're one layer further from completing the `Play` screen, the only thing missing is the `Win` layer, which should present the winner once the match is finished:\n\n[{]: <helper> (diffStep 6.9)\n\n#### [Step 6.9: Create &#x27;Win&#x27; layer](https://github.com/DAB0mB/radial-snake/commit/3476384)\n\n##### Added resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;play&#x2F;win.js\n```diff\n@@ -0,0 +1,43 @@\n+â”Š  â”Š 1â”ŠGame.Screens.Play.Win = class Win extends Engine.Layer {\n+â”Š  â”Š 2â”Š  constructor(screen, snakes, winner) {\n+â”Š  â”Š 3â”Š    super(screen);\n+â”Š  â”Š 4â”Š\n+â”Š  â”Š 5â”Š    this.snakes = snakes;\n+â”Š  â”Š 6â”Š    this.winner = winner;\n+â”Š  â”Š 7â”Š    // ttl stands for \"time to live\", which means, this layer is going to be\n+â”Š  â”Š 8â”Š    // disposed after 3 seconds\n+â”Š  â”Š 9â”Š    this.ttl = 3000;\n+â”Š  â”Š10â”Š\n+â”Š  â”Š11â”Š    // If there is a winner\n+â”Š  â”Š12â”Š    if (this.winner) {\n+â”Š  â”Š13â”Š      // Message could be something like \"RED SNAKE WINS\"\n+â”Š  â”Š14â”Š      var text = `${this.winner.color.toUpperCase()} SNAKE WINS`;\n+â”Š  â”Š15â”Š      var percent = 40;\n+â”Š  â”Š16â”Š    }\n+â”Š  â”Š17â”Š    // If there is a tie\n+â”Š  â”Š18â”Š    else {\n+â”Š  â”Š19â”Š      var text = 'TIE';\n+â”Š  â”Š20â”Š      var percent = 15;\n+â”Š  â”Š21â”Š    }\n+â”Š  â”Š22â”Š\n+â”Š  â”Š23â”Š    // Create winner sprite and set its properties\n+â”Š  â”Š24â”Š    let winnerTexture = this.assets.minecraftiaFont.createTexture(text);\n+â”Š  â”Š25â”Š    this.winnerSprite = new Engine.Sprite(winnerTexture);\n+â”Š  â”Š26â”Š    this.winnerSprite.align = \"center\";\n+â”Š  â”Š27â”Š    this.winnerSprite.setPercentage(\"width\", this.width, percent, \"height\");\n+â”Š  â”Š28â”Š    this.winnerSprite.x = this.width / 2;\n+â”Š  â”Š29â”Š    this.winnerSprite.y = this.height / 2;\n+â”Š  â”Š30â”Š  }\n+â”Š  â”Š31â”Š\n+â”Š  â”Š32â”Š  draw(context) {\n+â”Š  â”Š33â”Š    this.winnerSprite.draw(context);\n+â”Š  â”Š34â”Š  }\n+â”Š  â”Š35â”Š\n+â”Š  â”Š36â”Š  update(span) {\n+â”Š  â”Š37â”Š    // If limit not yet reached, abort\n+â”Š  â”Š38â”Š    if (this.age < this.ttl) return;\n+â”Š  â”Š39â”Š\n+â”Š  â”Š40â”Š    // Show \"ready\" message all over again, only this time use the updated score board\n+â”Š  â”Š41â”Š    this.screen.game.changeScreen(Game.Screens.Play, this.snakes);\n+â”Š  â”Š42â”Š  }\n+â”Š  â”Š43â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -24,6 +24,7 @@\n â”Š24â”Š24â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š25â”Š25â”Š    <script type=\"text/javascript\" src=\"/scripts/game/entities/snake.js\"></script>\n â”Š26â”Š26â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/index.js\"></script>\n+â”Š  â”Š27â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/win.js\"></script>\n â”Š27â”Š28â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/score.js\"></script>\n â”Š28â”Š29â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/snake.js\"></script>\n â”Š29â”Š30â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/ready.js\"></script>\n```\n\n[}]: #\n\nNote how we use the `changeScreen` method once the `Win` layer has reached its age limit (Time to live, aka `ttl`); This would clear the layers stack and restart the `Play` screen, so we can start a new match all-over, only this time we will pass the `Snake` instances to reserve the original scores. The `Win` layer should be presented whenever a collision has been detected between the snakes:\n\n[{]: <helper> (diffStep 6.1)\n\n#### [Step 6.1: Create &#x27;Play&#x27; screen](https://github.com/DAB0mB/radial-snake/commit/e17a45f)\n\n##### Added resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;play&#x2F;index.js\n```diff\n@@ -0,0 +1,14 @@\n+â”Š  â”Š 1â”ŠGame.Screens.Play = class Play extends Engine.Screen {\n+â”Š  â”Š 2â”Š  get events() {\n+â”Š  â”Š 3â”Š    return {\n+â”Š  â”Š 4â”Š      \"keydown\": \"onKeyDown\"\n+â”Š  â”Š 5â”Š    }\n+â”Š  â”Š 6â”Š  }\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Š  onKeyDown() {\n+â”Š  â”Š 9â”Š    // Once escape is pressed, return to main menu screen\n+â”Š  â”Š10â”Š    if (this.keyStates.get(27)) {\n+â”Š  â”Š11â”Š      this.game.changeScreen(Game.Screens.Menu);\n+â”Š  â”Š12â”Š    }\n+â”Š  â”Š13â”Š  }\n+â”Š  â”Š14â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -23,6 +23,7 @@\n â”Š23â”Š23â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/assets_loader.js\"></script>\n â”Š24â”Š24â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š25â”Š25â”Š    <script type=\"text/javascript\" src=\"/scripts/game/entities/snake.js\"></script>\n+â”Š  â”Š26â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/index.js\"></script>\n â”Š26â”Š27â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/menu/index.js\"></script>\n â”Š27â”Š28â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/splash/index.js\"></script>\n â”Š28â”Š29â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n```\n\n[}]: #\n\nThat's it folks, the `Play` screen is finished, and you can play as much matches as you'd feel like.\n\nAlthough the game is finished, it can still be optimized using `C++`. To discover more on hooking efficiency and how we can hook `C++` to the browser, see the next step."
          },
          {
            "manualTitle": "Step 7: Bonus! Re-implementing geometry in C++",
            "stepRevision": "cea4cffcc2f5e801020ed13ef8f1edde608c85f3",
            "manualView": "> This step is part of a bigger tutorial series where we learn how to create a game engine and implement a Tron-style game in JavaScript. The base project for the following step is available [here](https://github.com/DAB0mB/radial-snake/tree/step6).\n\nSo far I covered up pretty much everything I planned. I showed you how to create a game engine, including a font generator, an animation player and a screening system. On top of that, we've learned how to structure and organize our code well, so if in the future we'd like to extend our game by adding more screens or capabilities, we can do that with ease. Indeed, we've went through lots of great stuff, and if you've reached this point I give you my thumbs up. If so far this wasn't enough, in this step we will be focusing on optimization, and making our game engine run faster (a lot, faster). Obviously, when talking about optimizations, the first thing you would probably think of is how we can make our algorithms efficient by using minimum number of operations. While this is true, we will be actually focusing on optimizing our code using C++.\n\nUnlike JavaScript, which is a dynamic scripting file executed by an interpreter, C++ is a general purpose language which compiles into executables. Naturally, executables are much faster than scripts, since they don't have to be interpreted, and they can approach the hardware and memory much faster. In C++, we have to explicitly define our data-types, meaning that variables don't have to be parsed during run-time. While explicit variables definition is C++'s biggest drawback, it's also one of its biggest advantages. The mere fact that variables can be handled much faster, makes code much more efficient.\n\nAccordingly, we can conclude that the programming language we're using plays a very important role when it comes to efficiency. So how exactly are we going to integrate C++ into the browser? We're going to do that by using a compiler called - [Emscripten](http://kripken.github.io/emscripten-site/).\n\n![emscripten](https://cloud.githubusercontent.com/assets/7648874/22675449/ee6d7e9c-eccc-11e6-9570-1dd5d982ee66.png)\n\nEmscripten is an Open Source [LLVM](https://en.wikipedia.org/wiki/LLVM) to JavaScript compiler. Using Emscripten you can:\n\n- Compile C and C++ code into JavaScript\n- Compile any other code that can be translated into LLVM bitcode into JavaScript.\n- Compile the C/C++ runtimes of other languages into JavaScript, and then run code in those other languages in an indirect way (this has been done for Python and Lua)!\n\nLLVM is a library that is used to construct, optimize and produce intermediate and/or binary machine code. LLVM can be used as a compiler framework, where you provide the \"front end\" (parser and lexer) and the \"back end\" (code that converts LLVM's representation to actual machine code). LLVM can also act as a JIT compiler - it has support for x86/x86_64 and PPC/PPC64 assembly generation with fast code optimizations aimed for compilation speed.\n\nEmscripten operates by taking LLVM code and converting it into a subset of JavaScript called asm.js that can run anywhere that JavaScript can run (usually the browser, but also Node.js, etc.) and is easy for browsers to optimize. This means that you can basically write web applications in any language that has an LLVM compiler.\n\n![emscripten-flow](https://cloud.githubusercontent.com/assets/7648874/22675751/b244b76c-ecce-11e6-917e-f7039ed4b340.png)\n\nIn order to use Emscripten you will first have to install it. I recommend you to follow Emscripten's official installation instructions at their website over [here](https://kripken.github.io/emscripten-site/docs/getting_started/downloads.html). Installing Emscripten might be a bit tiring for some, I know for me it was, but if you're hyped about writing native code in the browser as much as I do, take as much time as needed to install it, and bare with me.\n\nAssuming that you have Emscripten installed, we can get right to business. The goal for this step is to re-implement our geometry namespace in C++, and to be more specific, the circle class and line class. We will start by creating an entry file for our C++ code under the path `resources/cpp/src/index.cpp`:\n\n    $ mkdir resources/cpp\n    $ mkdir resources/cpp/src\n    $ touch resources/cpp/src/index.cpp\n\nFrom now on, every C++ file that we would like to run in the browser should be included in the `index.cpp` file we've just created, otherwise it's not going to appear anywhere. The first stage for re-implementing our geometry would be re-writing the utility module, since our geometry is heavily based on it; Therefore the firs inclusion in our `index.cpp` file would be the following:\n\n[{]: <helper> (diffStep 7.1)\n\n#### [Step 7.1: Add CPP entry script](https://github.com/DAB0mB/radial-snake/commit/2f35323)\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;index.cpp\n```diff\n@@ -0,0 +1 @@\n+â”Š â”Š1â”Š#include \"utils.cpp\"ðŸš«â†µ\n```\n\n[}]: #\n\nFollowing that, we will create the `utils.cpp` module included above, which is a direct translation from C++ to JavaScript for the `utils.js` we've created earlier in this tutorial.\n\n[{]: <helper> (diffStep 7.2)\n\n#### [Step 7.2: Add base utility CPP module](https://github.com/DAB0mB/radial-snake/commit/6dba512)\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;utils.cpp\n```diff\n@@ -0,0 +1,73 @@\n+â”Š  â”Š 1â”Š#include <cfloat>\n+â”Š  â”Š 2â”Š#include <cmath>\n+â”Š  â”Š 3â”Š#include <string>\n+â”Š  â”Š 4â”Š#include \"utils.h\"\n+â”Š  â”Š 5â”Š\n+â”Š  â”Š 6â”Šnamespace utils {\n+â”Š  â”Š 7â”Š  // Fixed modulo method which can calculate modulo of negative numbers properly\n+â”Š  â”Š 8â”Š  // e.g. (-803).mod(800) returns 797\n+â”Š  â”Š 9â”Š  double mod(double context, double num) {\n+â”Š  â”Š10â”Š    return std::fmod((std::fmod(context, num) + num), num);\n+â”Š  â”Š11â”Š  }\n+â”Š  â”Š12â”Š\n+â”Š  â”Š13â”Š  // Trims number and leaves the number of decimals specified.\n+â”Š  â”Š14â”Š  // The \"mode\" argument specifies which math function should be invoked\n+â”Š  â”Š15â”Š  // right after the number has been trimmed.\n+â”Š  â”Š16â”Š  // e.g. 12.12345.trim(3, \"ceil\") returns 12.124\n+â”Š  â”Š17â”Š  double trim(double context, int decimals, const std::string mode) {\n+â”Š  â”Š18â”Š    double accumulator = context * std::pow(10, decimals);\n+â”Š  â”Š19â”Š\n+â”Š  â”Š20â”Š    if (mode.compare(\"ceil\") == 0)\n+â”Š  â”Š21â”Š      accumulator = std::ceil(accumulator);\n+â”Š  â”Š22â”Š    else if (mode.compare(\"floor\") == 0)\n+â”Š  â”Š23â”Š      accumulator = std::floor(accumulator);\n+â”Š  â”Š24â”Š    else\n+â”Š  â”Š25â”Š      accumulator = std::round(accumulator);\n+â”Š  â”Š26â”Š\n+â”Š  â”Š27â”Š    return accumulator / std::pow(10, decimals);\n+â”Š  â”Š28â”Š  }\n+â”Š  â”Š29â”Š\n+â”Š  â”Š30â”Š  // Tells if number is in specified range based on given precision.\n+â”Š  â”Š31â”Š  // See the \"compare\" method for more information about precision\n+â”Š  â”Š32â”Š  bool isBetween(double context, double num1, double num2, const std::string precision) {\n+â”Š  â”Š33â”Š    return compare(context, std::min(num1, num2), \">=\", precision) &&\n+â”Š  â”Š34â”Š           compare(context, std::max(num1, num2), \"<=\", precision);\n+â”Š  â”Š35â”Š  }\n+â”Š  â”Š36â”Š\n+â”Š  â”Š37â”Š  bool compare(double context, double num, const std::string precision) {\n+â”Š  â”Š38â”Š    return compare(context, num, \"==\", precision);\n+â”Š  â”Š39â”Š  }\n+â”Š  â”Š40â”Š\n+â”Š  â”Š41â”Š  // Initiates comparison operator between context number and a given number, only here\n+â”Š  â”Š42â”Š  // a precision can be specified\n+â”Š  â”Š43â”Š  bool compare(double context, double num, const std::string method, const std::string precision) {\n+â”Š  â”Š44â”Š    // Fixed precision, \"almost equal\" with a deviation of Îµ\n+â”Š  â”Š45â”Š    if (precision.compare(\"f\") == 0) {\n+â”Š  â”Š46â”Š      if (method.compare(\"<\") == 0 ||\n+â”Š  â”Š47â”Š          method.compare(\"<=\") == 0)\n+â”Š  â”Š48â”Š        return context <= num + DBL_EPSILON;\n+â”Š  â”Š49â”Š      if (method.compare(\">\") == 0 ||\n+â”Š  â”Š50â”Š          method.compare(\">=\") == 0)\n+â”Š  â”Š51â”Š        return context >= num - DBL_EPSILON;\n+â”Š  â”Š52â”Š      return std::abs(context - num) <= DBL_EPSILON;\n+â”Š  â”Š53â”Š    }\n+â”Š  â”Š54â”Š    // Pixel precision, round comparison\n+â”Š  â”Š55â”Š    else if (precision.compare(\"px\") == 0) {\n+â”Š  â”Š56â”Š      if (method.compare(\"<\") == 0 ||\n+â”Š  â”Š57â”Š          method.compare(\"<=\") == 0)\n+â”Š  â”Š58â”Š        return std::round(context) <= std::round(num);\n+â”Š  â”Š59â”Š      if (method.compare(\">\") == 0 ||\n+â”Š  â”Š60â”Š          method.compare(\">=\") == 0)\n+â”Š  â”Š61â”Š        return std::round(context) >= std::round(num);\n+â”Š  â”Š62â”Š      return std::round(context) == std::round(num);\n+â”Š  â”Š63â”Š    }\n+â”Š  â”Š64â”Š    // Exact precision\n+â”Š  â”Š65â”Š    else {\n+â”Š  â”Š66â”Š      if (method.compare(\"<\") == 0) return context < num;\n+â”Š  â”Š67â”Š      if (method.compare(\"<=\") == 0) return context <= num;\n+â”Š  â”Š68â”Š      if (method.compare(\">\") == 0) return context > num;\n+â”Š  â”Š69â”Š      if (method.compare(\">=\") == 0) return context >= num;\n+â”Š  â”Š70â”Š      return context == num;\n+â”Š  â”Š71â”Š    }\n+â”Š  â”Š72â”Š  }\n+â”Š  â”Š73â”Š}ðŸš«â†µ\n```\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;utils.h\n```diff\n@@ -0,0 +1,15 @@\n+â”Š  â”Š 1â”Š#pragma once\n+â”Š  â”Š 2â”Š\n+â”Š  â”Š 3â”Š#include <string>\n+â”Š  â”Š 4â”Š\n+â”Š  â”Š 5â”Šnamespace utils {\n+â”Š  â”Š 6â”Š  double mod(double context, double num);\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Š  double trim(double context, int decimals, const std::string mode = \"round\");\n+â”Š  â”Š 9â”Š\n+â”Š  â”Š10â”Š  bool isBetween(double context, double num1, double num2, const std::string precision = \"exact\");\n+â”Š  â”Š11â”Š\n+â”Š  â”Š12â”Š  bool compare(double context, double num, const std::string precision = \"exact\");\n+â”Š  â”Š13â”Š\n+â”Š  â”Š14â”Š  bool compare(double context, double num, const std::string method, const std::string precision);\n+â”Š  â”Š15â”Š}ðŸš«â†µ\n```\n\n[}]: #\n\nThe module above should work by itself when interacting with it inside the C++ scope, but that's not what we're striving for. We want this module to be available for use in our JavaScript project. This requires us to wrap our code in such a way the the Emscripten compiler will know how to compile it. Apart from providing a compiler, Emscripten provides us with functions and macros that will help use bind our C++ code to the JavaScript environment. These functionalities are packed in a single library which can be imported in our C++ code, and it is called [Embind](https://kripken.github.io/emscripten-site/docs/porting/connecting_cpp_and_javascript/embind.html) (probably stands for \"Emscripten bind\"). Using EMBind, let's wrap our utils module accordingly:\n\n[{]: <helper> (diffStep 7.3)\n\n#### [Step 7.3: EMBind CPP utils](https://github.com/DAB0mB/radial-snake/commit/0f34332)\n\n##### Changed resources&#x2F;cpp&#x2F;src&#x2F;utils.cpp\n```diff\n@@ -1,6 +1,7 @@\n â”Š1â”Š1â”Š#include <cfloat>\n â”Š2â”Š2â”Š#include <cmath>\n â”Š3â”Š3â”Š#include <string>\n+â”Š â”Š4â”Š#include <emscripten/bind.h>\n â”Š4â”Š5â”Š#include \"utils.h\"\n â”Š5â”Š6â”Š\n â”Š6â”Š7â”Šnamespace utils {\n```\n```diff\n@@ -70,4 +71,15 @@\n â”Š70â”Š71â”Š      return context == num;\n â”Š71â”Š72â”Š    }\n â”Š72â”Š73â”Š  }\n+â”Š  â”Š74â”Š}\n+â”Š  â”Š75â”Š\n+â”Š  â”Š76â”ŠEMSCRIPTEN_BINDINGS(utils_module) {\n+â”Š  â”Š77â”Š  emscripten::function(\"utils_mod\", &utils::mod);\n+â”Š  â”Š78â”Š  emscripten::function(\"utils_trim\", &utils::trim);\n+â”Š  â”Š79â”Š  emscripten::function(\"utils_isBetween\", &utils::isBetween);\n+â”Š  â”Š80â”Š  emscripten::function(\"utils_compare\",\n+â”Š  â”Š81â”Š    emscripten::select_overload<bool(double, double, const std::string, const std::string)>(\n+â”Š  â”Š82â”Š      &utils::compare\n+â”Š  â”Š83â”Š    )\n+â”Š  â”Š84â”Š  );\n â”Š73â”Š85â”Š}ðŸš«â†µ\n```\n\n[}]: #\n\nAfter a while you'll get used for Embind's API. If you'll look at it, it's self explanatory and easy to understand. Bound objects will be available the JavaScript environment will be available under an object named `Module`, e.g. the C++ method `mod` will be available for use as `Module.utils_mod`. Bound functions should have supported return types and argument types, meaning that if we're using a custom structure as a return type or an argument type, we first need to wrap it using EMBind, otherwise the compiler won't know how to handle it. A list of natively supported data-types can be found [here](https://kripken.github.io/emscripten-site/docs/porting/connecting_cpp_and_javascript/embind.html#built-in-type-conversions).\n\nEven though we've wrapped our C++ code and hypothetically it can already be used in the browser, I'd go for a second wrapper, since the compiled code doesn't have the optimal architecture. Right now we will have to approach C++ utility functions using `Module.utils_foo`. Instead, I'd like it to be `CPP.Utils.foo`, since it's clearer this way. The output of the Emscripten compiler can be wrapped with JavaScript code, using a prefix and a suffix, defined in 2 separate files respectively, called `pre.js` and `post.js`:\n\n[{]: <helper> (diffStep 7.4)\n\n#### [Step 7.4: Create CPP wrappers](https://github.com/DAB0mB/radial-snake/commit/cc28a34)\n\n##### Added resources&#x2F;cpp&#x2F;post.js\n```diff\n@@ -0,0 +1,10 @@\n+â”Š  â”Š 1â”Šreturn {\n+â”Š  â”Š 2â”Š  Utils: {\n+â”Š  â”Š 3â”Š    mod: Module.utils_mod,\n+â”Š  â”Š 4â”Š    trim: Module.utils_trim,\n+â”Š  â”Š 5â”Š    isBetween: Module.utils_isBetween,\n+â”Š  â”Š 6â”Š    compare: Module.utils_compare\n+â”Š  â”Š 7â”Š  }\n+â”Š  â”Š 8â”Š};\n+â”Š  â”Š 9â”Š\n+â”Š  â”Š10â”Š})();ðŸš«â†µ\n```\n\n##### Added resources&#x2F;cpp&#x2F;pre.js\n```diff\n@@ -0,0 +1 @@\n+â”Š â”Š1â”ŠCPP = (function() {ðŸš«â†µ\n```\n\n[}]: #\n\nWhat we've done in the code snippet above, we've created an anonymous function which calls itself, and inside we've exported a new namespace called `CPP` (C++). This way we can keep the generated code encapsulated, without worrying about spamming the global object.\n\nAfter creating a wrapper, I'd also recommend you to integrate the generated C++ code into existing namespaces, meaning that if for example we would like to approach the `CPP.Utils.foo` method, it could be done using `Utils.foo`. This way existing code won't have to be changed, and extra wrapping logic can be applied with ease, like the chaining logic implemented in the `Utils` namespace:\n\n[{]: <helper> (diffStep 7.5)\n\n#### [Step 7.5: Bind CPP utils to JS utils](https://github.com/DAB0mB/radial-snake/commit/0a67d50)\n\n##### Changed resources&#x2F;scripts&#x2F;utils.js\n```diff\n@@ -16,53 +16,9 @@\n â”Š16â”Š16â”Š  return chain;\n â”Š17â”Š17â”Š};\n â”Š18â”Š18â”Š\n-â”Š19â”Š  â”Š// Fixed modulo method which can calculate modulo of negative numbers properly\n-â”Š20â”Š  â”Š// e.g. (-803).mod(800) returns 797\n-â”Š21â”Š  â”ŠUtils.mod = function (context, num) {\n-â”Š22â”Š  â”Š  return ((context % num) + num) % num;\n-â”Š23â”Š  â”Š};\n-â”Š24â”Š  â”Š\n-â”Š25â”Š  â”Š// Trims number and leaves the number of decimals specified.\n-â”Š26â”Š  â”Š// The \"mode\" argument specifies which math function should be invoked\n-â”Š27â”Š  â”Š// right after the number has been trimmed.\n-â”Š28â”Š  â”Š// e.g. 12.12345.trim(3, \"ceil\") returns 12.124\n-â”Š29â”Š  â”ŠUtils.trim = function (context, decimals, mode = \"round\") {\n-â”Š30â”Š  â”Š  return Math[mode](context * Math.pow(10, decimals)) / Math.pow(10, decimals);\n-â”Š31â”Š  â”Š};\n-â”Š32â”Š  â”Š\n-â”Š33â”Š  â”Š// Tells if number is in specified range based on given precision.\n-â”Š34â”Š  â”Š// See the \"compare\" method for more information about precision\n-â”Š35â”Š  â”ŠUtils.isBetween = function (context, num1, num2, precision) {\n-â”Š36â”Š  â”Š  return Utils.compare(context, Math.min(num1, num2), \">=\", precision) &&\n-â”Š37â”Š  â”Š         Utils.compare(context, Math.max(num1, num2), \"<=\", precision);\n-â”Š38â”Š  â”Š};\n-â”Š39â”Š  â”Š\n-â”Š40â”Š  â”Š// Initiates comparison operator between context number and a given number, only here\n-â”Š41â”Š  â”Š// a precision can be specified\n-â”Š42â”Š  â”ŠUtils.compare = function (context, num, method, precision = method) {\n-â”Š43â”Š  â”Š  switch (precision) {\n-â”Š44â”Š  â”Š    // Fixed precision, \"almost equal\" with a deviation of Îµ\n-â”Š45â”Š  â”Š    case \"f\":\n-â”Š46â”Š  â”Š      switch (method) {\n-â”Š47â”Š  â”Š        case \"<\": case \"<=\": return context <= num + Number.EPSILON;\n-â”Š48â”Š  â”Š        case \">\": case \">=\": return context >= num - Number.EPSILON;\n-â”Š49â”Š  â”Š        default: return Math.abs(context - num) <= Number.EPSILON;\n-â”Š50â”Š  â”Š      }\n-â”Š51â”Š  â”Š    // Pixel precision, round comparison\n-â”Š52â”Š  â”Š    case \"px\":\n-â”Š53â”Š  â”Š      switch (method) {\n-â”Š54â”Š  â”Š        case \"<\": case \"<=\": return Math.round(context) <= Math.round(num);\n-â”Š55â”Š  â”Š        case \">\": case \">=\": return Math.round(context) >= Math.round(num);\n-â”Š56â”Š  â”Š        default: return Math.round(context) == Math.round(num);\n-â”Š57â”Š  â”Š      }\n-â”Š58â”Š  â”Š    // Exact precision\n-â”Š59â”Š  â”Š    default:\n-â”Š60â”Š  â”Š      switch (method) {\n-â”Š61â”Š  â”Š        case \"<\": return context < num;\n-â”Š62â”Š  â”Š        case \"<=\": return context <= num;\n-â”Š63â”Š  â”Š        case \">\": return context > num;\n-â”Š64â”Š  â”Š        case \">=\": return context >= num;\n-â”Š65â”Š  â”Š        default: return context === num;\n-â”Š66â”Š  â”Š      }\n+â”Š  â”Š19â”ŠObject.assign(Utils, CPP.Utils, {\n+â”Š  â”Š20â”Š  // Overload handling\n+â”Š  â”Š21â”Š  compare(context, num, method, precision = method) {\n+â”Š  â”Š22â”Š    return CPP.Utils.compare(context, num, method, precision);\n â”Š67â”Š23â”Š  }\n-â”Š68â”Š  â”Š};ðŸš«â†µ\n+â”Š  â”Š24â”Š});ðŸš«â†µ\n```\n\n[}]: #\n\nWhenever launching the compiler, the generated code should be outputted somewhere. I've decided to go with the path `resources/scripts/cpp.bundle.js`, but it doesn't matter how the file is gonna be called, as long as it's defined under the `scripts` dir, otherwise we won't be able to load it. Also, we need to make sure that we set a git-ignore rule for the generated file, since there's no reason for us to upload it to the git-host if we're planning on compiling it:\n\n[{]: <helper> (diffStep 7.5)\n\n#### [Step 7.5: Bind CPP utils to JS utils](https://github.com/DAB0mB/radial-snake/commit/0a67d50)\n\n##### Changed resources&#x2F;scripts&#x2F;utils.js\n```diff\n@@ -16,53 +16,9 @@\n â”Š16â”Š16â”Š  return chain;\n â”Š17â”Š17â”Š};\n â”Š18â”Š18â”Š\n-â”Š19â”Š  â”Š// Fixed modulo method which can calculate modulo of negative numbers properly\n-â”Š20â”Š  â”Š// e.g. (-803).mod(800) returns 797\n-â”Š21â”Š  â”ŠUtils.mod = function (context, num) {\n-â”Š22â”Š  â”Š  return ((context % num) + num) % num;\n-â”Š23â”Š  â”Š};\n-â”Š24â”Š  â”Š\n-â”Š25â”Š  â”Š// Trims number and leaves the number of decimals specified.\n-â”Š26â”Š  â”Š// The \"mode\" argument specifies which math function should be invoked\n-â”Š27â”Š  â”Š// right after the number has been trimmed.\n-â”Š28â”Š  â”Š// e.g. 12.12345.trim(3, \"ceil\") returns 12.124\n-â”Š29â”Š  â”ŠUtils.trim = function (context, decimals, mode = \"round\") {\n-â”Š30â”Š  â”Š  return Math[mode](context * Math.pow(10, decimals)) / Math.pow(10, decimals);\n-â”Š31â”Š  â”Š};\n-â”Š32â”Š  â”Š\n-â”Š33â”Š  â”Š// Tells if number is in specified range based on given precision.\n-â”Š34â”Š  â”Š// See the \"compare\" method for more information about precision\n-â”Š35â”Š  â”ŠUtils.isBetween = function (context, num1, num2, precision) {\n-â”Š36â”Š  â”Š  return Utils.compare(context, Math.min(num1, num2), \">=\", precision) &&\n-â”Š37â”Š  â”Š         Utils.compare(context, Math.max(num1, num2), \"<=\", precision);\n-â”Š38â”Š  â”Š};\n-â”Š39â”Š  â”Š\n-â”Š40â”Š  â”Š// Initiates comparison operator between context number and a given number, only here\n-â”Š41â”Š  â”Š// a precision can be specified\n-â”Š42â”Š  â”ŠUtils.compare = function (context, num, method, precision = method) {\n-â”Š43â”Š  â”Š  switch (precision) {\n-â”Š44â”Š  â”Š    // Fixed precision, \"almost equal\" with a deviation of Îµ\n-â”Š45â”Š  â”Š    case \"f\":\n-â”Š46â”Š  â”Š      switch (method) {\n-â”Š47â”Š  â”Š        case \"<\": case \"<=\": return context <= num + Number.EPSILON;\n-â”Š48â”Š  â”Š        case \">\": case \">=\": return context >= num - Number.EPSILON;\n-â”Š49â”Š  â”Š        default: return Math.abs(context - num) <= Number.EPSILON;\n-â”Š50â”Š  â”Š      }\n-â”Š51â”Š  â”Š    // Pixel precision, round comparison\n-â”Š52â”Š  â”Š    case \"px\":\n-â”Š53â”Š  â”Š      switch (method) {\n-â”Š54â”Š  â”Š        case \"<\": case \"<=\": return Math.round(context) <= Math.round(num);\n-â”Š55â”Š  â”Š        case \">\": case \">=\": return Math.round(context) >= Math.round(num);\n-â”Š56â”Š  â”Š        default: return Math.round(context) == Math.round(num);\n-â”Š57â”Š  â”Š      }\n-â”Š58â”Š  â”Š    // Exact precision\n-â”Š59â”Š  â”Š    default:\n-â”Š60â”Š  â”Š      switch (method) {\n-â”Š61â”Š  â”Š        case \"<\": return context < num;\n-â”Š62â”Š  â”Š        case \"<=\": return context <= num;\n-â”Š63â”Š  â”Š        case \">\": return context > num;\n-â”Š64â”Š  â”Š        case \">=\": return context >= num;\n-â”Š65â”Š  â”Š        default: return context === num;\n-â”Š66â”Š  â”Š      }\n+â”Š  â”Š19â”ŠObject.assign(Utils, CPP.Utils, {\n+â”Š  â”Š20â”Š  // Overload handling\n+â”Š  â”Š21â”Š  compare(context, num, method, precision = method) {\n+â”Š  â”Š22â”Š    return CPP.Utils.compare(context, num, method, precision);\n â”Š67â”Š23â”Š  }\n-â”Š68â”Š  â”Š};ðŸš«â†µ\n+â”Š  â”Š24â”Š});ðŸš«â†µ\n```\n\n[}]: #\n\nTo compile our C++ code and turn it into JavaScript, we'll need to run the following command:\n\n    $ emcc -O1 --pre-js resources/cpp/pre.js --post-js resources/cpp/post.js --bind -o resources/scripts/cpp.bundle.js resources/cpp/src/index.cpp\n\nHere's a detailed list with explanations regards the arguments vector we've just passed:\n\n- `-01` - Optimization level 1. The higher the index, the more optimized our code is gonna be, but less readable.\n- `--pre-js` - Specifies a JavaScript prefix for the compiled code.\n- `--post-js` - Specifies a JavaScript postfix for the compiled code.\n- `--bind` - Tells the compiler to use Embind\n- `-o` - The output path.\n\n> More informations regards Emscripten's CLI can be found [here](https://kripken.github.io/emscripten-site/docs/tools_reference/emcc.html).\n\nYou don't have to memorize the compilation command we've just typed, because we're gonna save it as an NPM script called `build:cpp`:\n\n[{]: <helper> (diffStep 7.6)\n\n#### [Step 7.6: Add ignore rule to CPP bundle](https://github.com/DAB0mB/radial-snake/commit/f4a75cf)\n\n##### Changed .gitignore\n```diff\n@@ -1,3 +1,4 @@\n â”Š1â”Š1â”Šnode_modules\n â”Š2â”Š2â”Šnpm-debug.log\n-â”Š3â”Š â”Šresources/assets/fonts/*.jsonðŸš«â†µ\n+â”Š â”Š3â”Šresources/assets/fonts/*.json\n+â”Š â”Š4â”Šresources/scripts/cpp.bundle.jsðŸš«â†µ\n```\n\n[}]: #\n\nNow if you'd like to compile the C++ code just run:\n\n    $ npm run build:cpp\n\nMoreover, the code should be compiled automatically any time you start the serer using the command:\n\n    $ npm run serve\n\nWe always have to be on the alert and run our tests against modules we've just translated from JavaScript to C++. This will guarantee that once we run the game we won't stumble upon any defect whatsoever. Before running the tests, be sure to import the C++ bundle in the HTML file's header:\n\n[{]: <helper> (diffStep 7.8)\n\n#### [Step 7.8: Load CPP bundle in spec runner](https://github.com/DAB0mB/radial-snake/commit/0d1bd08)\n\n##### Changed views&#x2F;spec_runner.html\n```diff\n@@ -16,6 +16,7 @@\n â”Š16â”Š16â”Š    <script type=\"text/javascript\" src=\"libs/underscore.js\"></script>\n â”Š17â”Š17â”Š\n â”Š18â”Š18â”Š    <!-- Scripts -->\n+â”Š  â”Š19â”Š    <script type=\"text/javascript\" src=\"scripts/cpp.bundle.js\"></script>\n â”Š19â”Š20â”Š    <script type=\"text/javascript\" src=\"scripts/utils.js\"></script>\n â”Š20â”Š21â”Š    <script type=\"text/javascript\" src=\"scripts/namespaces.js\"></script>\n â”Š21â”Š22â”Š    <script type=\"text/javascript\" src=\"scripts/engine/geometry/line.js\"></script>\n```\n\n[}]: #\n\nNow we can run the tests by running the following command:\n\n    $ npm run test\n\nAt this point **all our tests should pass**. If they don't, it means our newly created utility module is not working properly, and you will have to repeat the previous steps until you get it right.\n\nUp next, we gonna translate the geometry line class to C++. Since it's gonna be translated almost identically, we will have to make sure that all the necessary assets are gonna be available for our class before proceeding. The first thing we will have to do would be making sure that the utility functions are chainable directly from C++ as well. To do that, we will create a chain class which should return a new instance of it whenever we're about to chain the upcoming utility method. Once calling `result()`, the accumulator should be returned:\n\n[{]: <helper> (diffStep 7.9)\n\n#### [Step 7.9: Add chaining method to CPP utils](https://github.com/DAB0mB/radial-snake/commit/0927eea)\n\n##### Changed resources&#x2F;cpp&#x2F;src&#x2F;utils.cpp\n```diff\n@@ -5,6 +5,61 @@\n â”Š 5â”Š 5â”Š#include \"utils.h\"\n â”Š 6â”Š 6â”Š\n â”Š 7â”Š 7â”Šnamespace utils {\n+â”Š  â”Š 8â”Š  template<typename T>\n+â”Š  â”Š 9â”Š  Chain<T>::Chain(T accumulator): _accumulator(accumulator) {\n+â”Š  â”Š10â”Š  }\n+â”Š  â”Š11â”Š\n+â”Š  â”Š12â”Š  template<>\n+â”Š  â”Š13â”Š  Chain<double>* Chain<double>::mod(double num) {\n+â”Š  â”Š14â”Š    double result = utils::mod(_accumulator, num);\n+â”Š  â”Š15â”Š    Chain<double>* chain = new Chain<double>(result);\n+â”Š  â”Š16â”Š    delete this;\n+â”Š  â”Š17â”Š    return chain;\n+â”Š  â”Š18â”Š  }\n+â”Š  â”Š19â”Š\n+â”Š  â”Š20â”Š  template<>\n+â”Š  â”Š21â”Š  Chain<double>* Chain<double>::trim(int decimals, const std::string mode) {\n+â”Š  â”Š22â”Š    double result = utils::trim(_accumulator, decimals, mode);\n+â”Š  â”Š23â”Š    Chain<double>* chain = new Chain<double>(result);\n+â”Š  â”Š24â”Š    delete this;\n+â”Š  â”Š25â”Š    return chain;\n+â”Š  â”Š26â”Š  }\n+â”Š  â”Š27â”Š\n+â”Š  â”Š28â”Š  template<>\n+â”Š  â”Š29â”Š  Chain<bool>* Chain<double>::isBetween(double num1, double num2, const std::string precision) {\n+â”Š  â”Š30â”Š    bool result = utils::isBetween(_accumulator, num1, num2, precision);\n+â”Š  â”Š31â”Š    Chain<bool>* chain = new Chain<bool>(result);\n+â”Š  â”Š32â”Š    delete this;\n+â”Š  â”Š33â”Š    return chain;\n+â”Š  â”Š34â”Š  }\n+â”Š  â”Š35â”Š\n+â”Š  â”Š36â”Š  template<>\n+â”Š  â”Š37â”Š  Chain<bool>* Chain<double>::compare(double num, const std::string precision) {\n+â”Š  â”Š38â”Š    bool result = utils::compare(_accumulator, num, precision);\n+â”Š  â”Š39â”Š    Chain<bool>* chain = new Chain<bool>(result);\n+â”Š  â”Š40â”Š    delete this;\n+â”Š  â”Š41â”Š    return chain;\n+â”Š  â”Š42â”Š  }\n+â”Š  â”Š43â”Š\n+â”Š  â”Š44â”Š  template<>\n+â”Š  â”Š45â”Š  Chain<bool>* Chain<double>::compare(double num, const std::string method, const std::string precision) {\n+â”Š  â”Š46â”Š    bool result = utils::compare(_accumulator, num, method, precision);\n+â”Š  â”Š47â”Š    Chain<bool>* chain = new Chain<bool>(result);\n+â”Š  â”Š48â”Š    delete this;\n+â”Š  â”Š49â”Š    return chain;\n+â”Š  â”Š50â”Š  }\n+â”Š  â”Š51â”Š\n+â”Š  â”Š52â”Š  template<typename T>\n+â”Š  â”Š53â”Š  T Chain<T>::result() {\n+â”Š  â”Š54â”Š    delete this;\n+â”Š  â”Š55â”Š    return _accumulator;\n+â”Š  â”Š56â”Š  }\n+â”Š  â”Š57â”Š\n+â”Š  â”Š58â”Š  template<typename T>\n+â”Š  â”Š59â”Š  Chain<T>* chain(T accumulator) {\n+â”Š  â”Š60â”Š    return new Chain<T>(accumulator);\n+â”Š  â”Š61â”Š  }\n+â”Š  â”Š62â”Š\n â”Š 8â”Š63â”Š  // Fixed modulo method which can calculate modulo of negative numbers properly\n â”Š 9â”Š64â”Š  // e.g. (-803).mod(800) returns 797\n â”Š10â”Š65â”Š  double mod(double context, double num) {\n```\n\n##### Changed resources&#x2F;cpp&#x2F;src&#x2F;utils.h\n```diff\n@@ -3,6 +3,30 @@\n â”Š 3â”Š 3â”Š#include <string>\n â”Š 4â”Š 4â”Š\n â”Š 5â”Š 5â”Šnamespace utils {\n+â”Š  â”Š 6â”Š  template<typename T>\n+â”Š  â”Š 7â”Š  class Chain {\n+â”Š  â”Š 8â”Š  private:\n+â”Š  â”Š 9â”Š    T _accumulator;\n+â”Š  â”Š10â”Š\n+â”Š  â”Š11â”Š  public:\n+â”Š  â”Š12â”Š    Chain(T accumulator);\n+â”Š  â”Š13â”Š\n+â”Š  â”Š14â”Š    Chain<double>* mod(double num);\n+â”Š  â”Š15â”Š\n+â”Š  â”Š16â”Š    Chain<double>* trim(int decimals, const std::string mode = \"round\");\n+â”Š  â”Š17â”Š\n+â”Š  â”Š18â”Š    Chain<bool>* isBetween(double num1, double num2, const std::string precision = \"exact\");\n+â”Š  â”Š19â”Š\n+â”Š  â”Š20â”Š    Chain<bool>* compare(double num, const std::string precision = \"exact\");\n+â”Š  â”Š21â”Š\n+â”Š  â”Š22â”Š    Chain<bool>* compare(double num, const std::string method, const std::string precision);\n+â”Š  â”Š23â”Š\n+â”Š  â”Š24â”Š    T result();\n+â”Š  â”Š25â”Š  };\n+â”Š  â”Š26â”Š\n+â”Š  â”Š27â”Š  template<typename T>\n+â”Š  â”Š28â”Š  Chain<T>* chain(T accumulator);\n+â”Š  â”Š29â”Š\n â”Š 6â”Š30â”Š  double mod(double context, double num);\n â”Š 7â”Š31â”Š\n â”Š 8â”Š32â”Š  double trim(double context, int decimals, const std::string mode = \"round\");\n```\n\n[}]: #\n\n> Note that when coding in C++ we have to make sure that the objects are being disposed when not needed anymore, otherwise we will have some unnecessary memory leaks.\n\n2D shapes are presented in space using points with 2 values - `x` (axis) and `y` axis, therefore, we will create the appropriate point structure:\n\n[{]: <helper> (diffStep 7.1)\n\n#### [Step 7.1: Add CPP entry script](https://github.com/DAB0mB/radial-snake/commit/2f35323)\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;index.cpp\n```diff\n@@ -0,0 +1 @@\n+â”Š â”Š1â”Š#include \"utils.cpp\"ðŸš«â†µ\n```\n\n[}]: #\n\nReturned values can either be `null` (`undefined`) or not. Since there's no built in nullable-values mechanism in C++ (up until C++17), we're gonna create one of our own:\n\n[{]: <helper> (diffStep 7.11)\n\n#### [Step 7.11: Add nullable class](https://github.com/DAB0mB/radial-snake/commit/41b2f7c)\n\n##### Changed resources&#x2F;cpp&#x2F;src&#x2F;index.cpp\n```diff\n@@ -1 +1,2 @@\n+â”Š â”Š1â”Š#include \"nullable.cpp\"\n â”Š1â”Š2â”Š#include \"utils.cpp\"ðŸš«â†µ\n```\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;nullable.cpp\n```diff\n@@ -0,0 +1,37 @@\n+â”Š  â”Š 1â”Š#include \"nullable.h\"\n+â”Š  â”Š 2â”Š\n+â”Š  â”Š 3â”Štemplate <typename T>\n+â”Š  â”Š 4â”ŠNullable<T>::Nullable(T value): _value(value), _initialized(true) {\n+â”Š  â”Š 5â”Š\n+â”Š  â”Š 6â”Š}\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Štemplate <typename T>\n+â”Š  â”Š 9â”ŠNullable<T>::Nullable(): _initialized(false) {\n+â”Š  â”Š10â”Š\n+â”Š  â”Š11â”Š}\n+â”Š  â”Š12â”Š\n+â”Š  â”Š13â”Štemplate <typename T>\n+â”Š  â”Š14â”ŠT Nullable<T>::getValue() const {\n+â”Š  â”Š15â”Š  return _value;\n+â”Š  â”Š16â”Š}\n+â”Š  â”Š17â”Š\n+â”Š  â”Š18â”Štemplate <typename T>\n+â”Š  â”Š19â”Švoid Nullable<T>::setValue(T value) {\n+â”Š  â”Š20â”Š  _value = value;\n+â”Š  â”Š21â”Š  _initialized = true;\n+â”Š  â”Š22â”Š}\n+â”Š  â”Š23â”Š\n+â”Š  â”Š24â”Štemplate <typename T>\n+â”Š  â”Š25â”Švoid Nullable<T>::resetValue() {\n+â”Š  â”Š26â”Š  _initialized = false;\n+â”Š  â”Š27â”Š}\n+â”Š  â”Š28â”Š\n+â”Š  â”Š29â”Štemplate <typename T>\n+â”Š  â”Š30â”Šbool Nullable<T>::hasValue() const {\n+â”Š  â”Š31â”Š  return _initialized == true;\n+â”Š  â”Š32â”Š}\n+â”Š  â”Š33â”Š\n+â”Š  â”Š34â”Štemplate <typename T>\n+â”Š  â”Š35â”Šbool Nullable<T>::isNull() const {\n+â”Š  â”Š36â”Š  return _initialized == false;\n+â”Š  â”Š37â”Š}ðŸš«â†µ\n```\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;nullable.h\n```diff\n@@ -0,0 +1,23 @@\n+â”Š  â”Š 1â”Š#pragma once\n+â”Š  â”Š 2â”Š\n+â”Š  â”Š 3â”Štemplate <typename T>\n+â”Š  â”Š 4â”Šclass Nullable {\n+â”Š  â”Š 5â”Šprivate:\n+â”Š  â”Š 6â”Š  T _value;\n+â”Š  â”Š 7â”Š  bool _initialized;\n+â”Š  â”Š 8â”Š\n+â”Š  â”Š 9â”Špublic:\n+â”Š  â”Š10â”Š  Nullable(T value);\n+â”Š  â”Š11â”Š\n+â”Š  â”Š12â”Š  Nullable();\n+â”Š  â”Š13â”Š\n+â”Š  â”Š14â”Š  T getValue() const;\n+â”Š  â”Š15â”Š\n+â”Š  â”Š16â”Š  void setValue(T value);\n+â”Š  â”Š17â”Š\n+â”Š  â”Š18â”Š  void resetValue();\n+â”Š  â”Š19â”Š\n+â”Š  â”Š20â”Š  bool hasValue() const;\n+â”Š  â”Š21â”Š\n+â”Š  â”Š22â”Š  bool isNull() const;\n+â”Š  â”Š23â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nNow that all the necessary assets for the line class are ready, we can go ahead and create it:\n\n[{]: <helper> (diffStep 7.12)\n\n#### [Step 7.12: Add base line CPP module](https://github.com/DAB0mB/radial-snake/commit/9d17554)\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;geometry&#x2F;line.cpp\n```diff\n@@ -0,0 +1,99 @@\n+â”Š  â”Š 1â”Š#include \"../nullable.h\"\n+â”Š  â”Š 2â”Š#include \"../utils.h\"\n+â”Š  â”Š 3â”Š#include \"point.h\"\n+â”Š  â”Š 4â”Š#include \"line.h\"\n+â”Š  â”Š 5â”Š\n+â”Š  â”Š 6â”Šnamespace geometry {\n+â”Š  â”Š 7â”Š  // x1 - The first point's x value\n+â”Š  â”Š 8â”Š  // y1 - The first point's y value\n+â”Š  â”Š 9â”Š  // x1 - The second point's x value\n+â”Š  â”Š10â”Š  // y2 - The second point's y value\n+â”Š  â”Š11â”Š  Line::Line(double x1, double y1, double x2, double y2) {\n+â”Š  â”Š12â”Š    _x1 = utils::trim(x1, 9);\n+â”Š  â”Š13â”Š    _y1 = utils::trim(y1, 9);\n+â”Š  â”Š14â”Š    _x2 = utils::trim(x2, 9);\n+â”Š  â”Š15â”Š    _y2 = utils::trim(y2, 9);\n+â”Š  â”Š16â”Š  }\n+â”Š  â”Š17â”Š\n+â”Š  â”Š18â”Š  // Gets the matching x value for a given y value\n+â”Š  â”Š19â”Š  Nullable<double> Line::getMatchingX(double y) {\n+â”Š  â”Š20â”Š    // If an error was thrown it means we divided a number by zero,\n+â”Š  â”Š21â”Š    // in which case there is not intersection point\n+â”Š  â”Š22â”Š    double x = utils::trim(\n+â”Š  â”Š23â”Š      (((y - _y1) * (_x2 - _x1)) /\n+â”Š  â”Š24â”Š       (_y2 - _y1)) + _x1\n+â”Š  â”Š25â”Š    , 9, \"exact\");\n+â”Š  â”Š26â”Š\n+â”Š  â”Š27â”Š    // Check if result is in values range\n+â”Š  â”Š28â”Š    if (utils::isBetween(x, _x1, _x2, \"round\")) {\n+â”Š  â”Š29â”Š      return Nullable<double>(x);\n+â”Š  â”Š30â”Š    }\n+â”Š  â”Š31â”Š\n+â”Š  â”Š32â”Š    return Nullable<double>();\n+â”Š  â”Š33â”Š  }\n+â”Š  â”Š34â”Š\n+â”Š  â”Š35â”Š  // Gets the matching y value for a given x value\n+â”Š  â”Š36â”Š  Nullable<double> Line::getMatchingY(double x) {\n+â”Š  â”Š37â”Š    // If an error was thrown it means we divided a number by zero,\n+â”Š  â”Š38â”Š    // in which case there is not intersection point\n+â”Š  â”Š39â”Š    double y = utils::trim(\n+â”Š  â”Š40â”Š      (((x - _x1) * (_y2 - _y1)) /\n+â”Š  â”Š41â”Š       (_x2 - _x1)) + _y1\n+â”Š  â”Š42â”Š    , 9, \"exact\");\n+â”Š  â”Š43â”Š\n+â”Š  â”Š44â”Š    // Check if result is in values range\n+â”Š  â”Š45â”Š    if (utils::isBetween(y, _y1, _y2, \"round\")) {\n+â”Š  â”Š46â”Š      return Nullable<double>(y);\n+â”Š  â”Š47â”Š    }\n+â”Š  â”Š48â”Š\n+â”Š  â”Š49â”Š    return Nullable<double>();\n+â”Š  â”Š50â”Š  }\n+â”Š  â”Š51â”Š\n+â”Š  â”Š52â”Š  // Returns if line has given point\n+â”Š  â”Š53â”Š  bool Line::hasPoint(double x, double y) {\n+â”Š  â”Š54â”Š    if (!boundsHavePoint(x, y)) return 0;\n+â”Š  â”Š55â”Š\n+â”Š  â”Š56â”Š    double m = utils::trim(\n+â”Š  â”Š57â”Š      (_y2 - _y1) / (_x2 - _x1),\n+â”Š  â”Š58â”Š    9, \"exact\");\n+â”Š  â”Š59â”Š\n+â”Š  â”Š60â”Š    return (y - _y1) / (x - _x1) == m;\n+â”Š  â”Š61â”Š  }\n+â”Š  â”Š62â”Š\n+â”Š  â”Š63â”Š  // Returns if given point is contained by the bounds aka cage of line\n+â”Š  â”Š64â”Š  bool Line::boundsHavePoint(double x, double y) {\n+â”Š  â”Š65â”Š    return utils::isBetween(x, _x1, _x2, \"round\") &&\n+â”Š  â”Š66â”Š           utils::isBetween(y, _y1, _y2, \"round\");\n+â”Š  â”Š67â”Š  }\n+â”Š  â”Š68â”Š\n+â”Š  â”Š69â”Š  // line - line intersection method\n+â”Š  â”Š70â”Š  Nullable<Point> Line::getIntersection(Line line) {\n+â”Š  â”Š71â”Š    // Escape if lines are parallel\n+â”Š  â”Š72â”Š    if (!(((_x1 - _x2) * (line._y1 - line._y2)) -\n+â”Š  â”Š73â”Š          ((_y1 - _y2) * (line._x1 - line._x2))))\n+â”Š  â”Š74â”Š      return Nullable<Point>();\n+â”Š  â”Š75â”Š\n+â”Š  â”Š76â”Š    // Intersection point formula\n+â”Š  â”Š77â”Š    double x = utils::trim(\n+â”Š  â”Š78â”Š      ((((_x1 * _y2) - (_y1 * _x2)) * (line._x1 - line._x2)) -\n+â”Š  â”Š79â”Š       ((_x1 - _x2) * ((line._x1 * line._y2) - (line._y1 * line._x2)))) /\n+â”Š  â”Š80â”Š      (((_x1 - _x2) * (line._y1 - line._y2)) - ((_y1 - _y2) *\n+â”Š  â”Š81â”Š        (line._x1 - line._x2)))\n+â”Š  â”Š82â”Š    , 9, \"exact\");\n+â”Š  â”Š83â”Š    double y = utils::trim(\n+â”Š  â”Š84â”Š      ((((_x1 * _y2) - (_y1 * _x2)) * (line._y1 - line._y2)) -\n+â”Š  â”Š85â”Š       ((_y1 - _y2) * ((line._x1 * line._y2) - (line._y1 * line._x2)))) /\n+â”Š  â”Š86â”Š      (((_x1 - _x2) * (line._y1 - line._y2)) - ((_y1 - _y2) *\n+â”Š  â”Š87â”Š        (line._x1 - line._x2)))\n+â”Š  â”Š88â”Š    , 9, \"exact\");\n+â”Š  â”Š89â”Š\n+â”Š  â”Š90â”Š    if (utils::isBetween(x, _x1, _x2, \"round\") &&\n+â”Š  â”Š91â”Š        utils::isBetween(x, line._x1, line._x2, \"round\") &&\n+â”Š  â”Š92â”Š        utils::isBetween(y, _y1, _y2, \"round\") &&\n+â”Š  â”Š93â”Š        utils::isBetween(y, line._y1, line._y2, \"round\")) {\n+â”Š  â”Š94â”Š      return Nullable<Point>({ x, y });\n+â”Š  â”Š95â”Š    }\n+â”Š  â”Š96â”Š\n+â”Š  â”Š97â”Š    return Nullable<Point>();\n+â”Š  â”Š98â”Š  }\n+â”Š  â”Š99â”Š}ðŸš«â†µ\n```\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;geometry&#x2F;line.h\n```diff\n@@ -0,0 +1,30 @@\n+â”Š  â”Š 1â”Š#pragma once\n+â”Š  â”Š 2â”Š\n+â”Š  â”Š 3â”Š#include <vector>\n+â”Š  â”Š 4â”Š#include \"../nullable.h\"\n+â”Š  â”Š 5â”Š#include \"point.h\"\n+â”Š  â”Š 6â”Š\n+â”Š  â”Š 7â”Šnamespace geometry {\n+â”Š  â”Š 8â”Š  class Circle;\n+â”Š  â”Š 9â”Š  class EMCircle;\n+â”Š  â”Š10â”Š\n+â”Š  â”Š11â”Š  class Line {\n+â”Š  â”Š12â”Š  public:\n+â”Š  â”Š13â”Š    double _x1;\n+â”Š  â”Š14â”Š    double _y1;\n+â”Š  â”Š15â”Š    double _x2;\n+â”Š  â”Š16â”Š    double _y2;\n+â”Š  â”Š17â”Š\n+â”Š  â”Š18â”Š    Line(double x1, double y1, double x2, double y2);\n+â”Š  â”Š19â”Š\n+â”Š  â”Š20â”Š    Nullable<double> getMatchingX(double y);\n+â”Š  â”Š21â”Š\n+â”Š  â”Š22â”Š    Nullable<double> getMatchingY(double x);\n+â”Š  â”Š23â”Š\n+â”Š  â”Š24â”Š    bool hasPoint(double x, double y);\n+â”Š  â”Š25â”Š\n+â”Š  â”Š26â”Š    bool boundsHavePoint(double x, double y);\n+â”Š  â”Š27â”Š\n+â”Š  â”Š28â”Š    Nullable<Point> getIntersection(Line line);\n+â”Š  â”Š29â”Š  };\n+â”Š  â”Š30â”Š}ðŸš«â†µ\n```\n\n##### Changed resources&#x2F;cpp&#x2F;src&#x2F;index.cpp\n```diff\n@@ -1,2 +1,3 @@\n â”Š1â”Š1â”Š#include \"nullable.cpp\"\n-â”Š2â”Š â”Š#include \"utils.cpp\"ðŸš«â†µ\n+â”Š â”Š2â”Š#include \"utils.cpp\"\n+â”Š â”Š3â”Š#include \"geometry/line.cpp\"ðŸš«â†µ\n```\n\n[}]: #\n\nAfter creating our C++, we will also need to bind it using EMBind:\n\n[{]: <helper> (diffStep 7.13)\n\n#### [Step 7.13: EMBind CPP line](https://github.com/DAB0mB/radial-snake/commit/8920ddf)\n\n##### Changed resources&#x2F;cpp&#x2F;post.js\n```diff\n@@ -4,6 +4,10 @@\n â”Š 4â”Š 4â”Š    trim: Module.utils_trim,\n â”Š 5â”Š 5â”Š    isBetween: Module.utils_isBetween,\n â”Š 6â”Š 6â”Š    compare: Module.utils_compare\n+â”Š  â”Š 7â”Š  },\n+â”Š  â”Š 8â”Š\n+â”Š  â”Š 9â”Š  Geometry: {\n+â”Š  â”Š10â”Š    Line: Module.geometry_line\n â”Š 7â”Š11â”Š  }\n â”Š 8â”Š12â”Š};\n â”Š 9â”Š13â”Š\n```\n\n##### Changed resources&#x2F;cpp&#x2F;src&#x2F;geometry&#x2F;line.cpp\n```diff\n@@ -1,3 +1,6 @@\n+â”Š â”Š1â”Š#include <vector>\n+â”Š â”Š2â”Š#include <emscripten/bind.h>\n+â”Š â”Š3â”Š#include <emscripten/val.h>\n â”Š1â”Š4â”Š#include \"../nullable.h\"\n â”Š2â”Š5â”Š#include \"../utils.h\"\n â”Š3â”Š6â”Š#include \"point.h\"\n```\n```diff\n@@ -96,4 +99,52 @@\n â”Š 96â”Š 99â”Š\n â”Š 97â”Š100â”Š    return Nullable<Point>();\n â”Š 98â”Š101â”Š  }\n+â”Š   â”Š102â”Š\n+â”Š   â”Š103â”Š  emscripten::val EMLine::getMatchingX(double y) {\n+â”Š   â”Š104â”Š    Nullable<double> nullableX = Line::getMatchingX(y);\n+â”Š   â”Š105â”Š    return nullableX.hasValue() ?\n+â”Š   â”Š106â”Š      emscripten::val(nullableX.getValue()) :\n+â”Š   â”Š107â”Š      emscripten::val::undefined();\n+â”Š   â”Š108â”Š  }\n+â”Š   â”Š109â”Š\n+â”Š   â”Š110â”Š  emscripten::val EMLine::getMatchingY(double x) {\n+â”Š   â”Š111â”Š    Nullable<double> nullableY = Line::getMatchingY(x);\n+â”Š   â”Š112â”Š    return nullableY.hasValue() ?\n+â”Š   â”Š113â”Š      emscripten::val(nullableY.getValue()) :\n+â”Š   â”Š114â”Š      emscripten::val::undefined();\n+â”Š   â”Š115â”Š  }\n+â”Š   â”Š116â”Š\n+â”Š   â”Š117â”Š  emscripten::val EMLine::getIntersection(EMLine emLine) {\n+â”Š   â”Š118â”Š    Line line = Line(emLine._x1, emLine._y1, emLine._x2, emLine._y2);\n+â”Š   â”Š119â”Š    Nullable<Point> nullablePoint = Line::getIntersection(line);\n+â”Š   â”Š120â”Š\n+â”Š   â”Š121â”Š    if (nullablePoint.isNull()) return emscripten::val::undefined();\n+â”Š   â”Š122â”Š\n+â”Š   â”Š123â”Š    Point point = nullablePoint.getValue();\n+â”Š   â”Š124â”Š    emscripten::val emPoint = emscripten::val::object();\n+â”Š   â”Š125â”Š    emPoint.set(\"x\", emscripten::val(point.x));\n+â”Š   â”Š126â”Š    emPoint.set(\"y\", emscripten::val(point.y));\n+â”Š   â”Š127â”Š    return emPoint;\n+â”Š   â”Š128â”Š  }\n+â”Š   â”Š129â”Š}\n+â”Š   â”Š130â”Š\n+â”Š   â”Š131â”ŠEMSCRIPTEN_BINDINGS(geometry_line_module) {\n+â”Š   â”Š132â”Š  emscripten::class_<geometry::Line>(\"geometry_line_base\")\n+â”Š   â”Š133â”Š    .constructor<double, double, double, double>()\n+â”Š   â”Š134â”Š    .property<double>(\"x1\", &geometry::Line::_x1)\n+â”Š   â”Š135â”Š    .property<double>(\"y1\", &geometry::Line::_y1)\n+â”Š   â”Š136â”Š    .property<double>(\"x2\", &geometry::Line::_x2)\n+â”Š   â”Š137â”Š    .property<double>(\"y2\", &geometry::Line::_y2)\n+â”Š   â”Š138â”Š    .function(\"hasPoint\", &geometry::Line::hasPoint)\n+â”Š   â”Š139â”Š    .function(\"boundsHavePoint\", &geometry::Line::boundsHavePoint);\n+â”Š   â”Š140â”Š\n+â”Š   â”Š141â”Š  emscripten::class_<geometry::EMLine, emscripten::base<geometry::Line>>(\"geometry_line\")\n+â”Š   â”Š142â”Š    .constructor<double, double, double, double>()\n+â”Š   â”Š143â”Š    .function(\"getX\", &geometry::EMLine::getMatchingX)\n+â”Š   â”Š144â”Š    .function(\"getY\", &geometry::EMLine::getMatchingY)\n+â”Š   â”Š145â”Š    .function(\"getLineIntersection\",\n+â”Š   â”Š146â”Š      emscripten::select_overload<emscripten::val(geometry::EMLine)>(\n+â”Š   â”Š147â”Š        &geometry::EMLine::getIntersection\n+â”Š   â”Š148â”Š      )\n+â”Š   â”Š149â”Š    );\n â”Š 99â”Š150â”Š}ðŸš«â†µ\n```\n\n##### Changed resources&#x2F;cpp&#x2F;src&#x2F;geometry&#x2F;line.h\n```diff\n@@ -1,6 +1,7 @@\n â”Š1â”Š1â”Š#pragma once\n â”Š2â”Š2â”Š\n â”Š3â”Š3â”Š#include <vector>\n+â”Š â”Š4â”Š#include <emscripten/val.h>\n â”Š4â”Š5â”Š#include \"../nullable.h\"\n â”Š5â”Š6â”Š#include \"point.h\"\n â”Š6â”Š7â”Š\n```\n```diff\n@@ -27,4 +28,15 @@\n â”Š27â”Š28â”Š\n â”Š28â”Š29â”Š    Nullable<Point> getIntersection(Line line);\n â”Š29â”Š30â”Š  };\n+â”Š  â”Š31â”Š\n+â”Š  â”Š32â”Š  class EMLine : public Line {\n+â”Š  â”Š33â”Š  public:\n+â”Š  â”Š34â”Š    using Line::Line;\n+â”Š  â”Š35â”Š\n+â”Š  â”Š36â”Š    emscripten::val getMatchingX(double y);\n+â”Š  â”Š37â”Š\n+â”Š  â”Š38â”Š    emscripten::val getMatchingY(double x);\n+â”Š  â”Š39â”Š\n+â”Š  â”Š40â”Š    emscripten::val getIntersection(EMLine line);\n+â”Š  â”Š41â”Š  };\n â”Š30â”Š42â”Š}ðŸš«â†µ\n```\n\n[}]: #\n\nIn the code snippet above, you can see that we used a special data-type called `val` (`emscripten::val`). `val` means that just like JavaScript, that function can return values that are not necessarily of the same data-type; For instance, the `getMatchingY` function can either return a `number` or `undefined`. If you'll take a look at the `getIntersection(Line)` method you'll notice that instead of returning the raw point structure, I chose to build a JavaScript object using the `object` data type (`emscripten::object`). `object` behaves exactly like a native JavaScript `Object`, and it can save us some precious work of binding which sometimes might be just too much.\n\nIf you'll compare the C++ version of the line class to the JavaScript line class you'll notice that the `draw` and `getIntersection` methods are missing (when we used EMBind we renamed `getIntersection` to `getLineIntersection` because overloadings are forbidden). In addition, Emscripten's API exposes some additional class methods for generated C++ classes, like the `delete` method, which we will shed light on further in this tutorial. Inheritance would be the natural solution for such an issue, unfortunately, generated C++ constructors don't accept indirect instances. For example, if we have a C++ parent class called `Shape` and we have a JavaScript child class called `Line`, we won't be able to initialize a new instance of the `Line` class. Here's a demonstration:\n\n```js\nclass JSLine extends CPPShape {}\nconst line = new JSLine(); // Throws error\n```\n\nThere are 3 ways to implement inheritance when interacting with C++ classes:\n\n- Define an interface when using EMBind. This is the official way but rather complicated, since it requires us to define an extra layer for our wrapper. More information can be found [here](https://kripken.github.io/emscripten-site/docs/porting/connecting_cpp_and_javascript/embind.html#abstract-methods).\n- Extending the prototype of exported C++ classes directly, which is not really an inheritance.\n- Using a proxy class, which is the easiest and cleanest solution of all, but it is not really mentioned anywhere. At the same time, I didn't find any restriction regards that.\n\nWe're gonna use the 3rd method in the list above, because as I said, it's the easiest and cleanest of all. First I will try to explain what I meant by saying \"proxy class\". If you're an intermediate JavaScript developer, you probably know that constructors can be overridden by returning a value explicitly. By doing that, we can actually bypass Emscripten's prohibitions, we can just return the newly created C++ instance and extend it in specific. Proxy classes actually take it a step further by providing a middle-class which will then inject a new link to the prototype chain of the returned instance.\n\n```js\nclass JSLine {\n  constructor() {\n    const line = new CPPShape();\n    return line;\n  }\n}\n\nconst line = new JSLine(); // Legal!\n```\n\n> More information about the code snippet above can be found [here](https://www.bennadel.com/blog/2522-providing-a-return-value-in-a-javascript-constructor.htm).\n\nI believe that as we go through this tutorial, the concept will get much clearer. The utility function of the proxy class should look like so:\n\n[{]: <helper> (diffStep 7.14)\n\n#### [Step 7.14: Add proxy utility method](https://github.com/DAB0mB/radial-snake/commit/06e615e)\n\n##### Changed resources&#x2F;scripts&#x2F;utils.js\n```diff\n@@ -20,5 +20,18 @@\n â”Š20â”Š20â”Š  // Overload handling\n â”Š21â”Š21â”Š  compare(context, num, method, precision = method) {\n â”Š22â”Š22â”Š    return CPP.Utils.compare(context, num, method, precision);\n+â”Š  â”Š23â”Š  },\n+â”Š  â”Š24â”Š\n+â”Š  â”Š25â”Š  proxy(Class) {\n+â”Š  â”Š26â”Š    return class extends Class {\n+â”Š  â”Š27â”Š      constructor() {\n+â”Š  â”Š28â”Š        // Initialize original class\n+â”Š  â”Š29â”Š        let that = new Class(...arguments);\n+â”Š  â”Š30â”Š        // Inject caller's prototype into the prototype chain\n+â”Š  â”Š31â”Š        Object.setPrototypeOf(that, new.target.prototype);\n+â”Š  â”Š32â”Š        // Will original instance will be the substitute for 'this'\n+â”Š  â”Š33â”Š        return that;\n+â”Š  â”Š34â”Š      }\n+â”Š  â”Š35â”Š    }\n â”Š23â”Š36â”Š  }\n â”Š24â”Š37â”Š});ðŸš«â†µ\n```\n\n[}]: #\n\nIf you'll take a look at the following line:\n\n```js\nObject.setPrototypeOf(that, new.target.prototype);\n```\n\nThis is where the magic actually happens! It enables inheritance for explicitly returned objects; This way we can safely extend C++ classes. Accordingly, our new JavaScript line class should look like so:\n\n[{]: <helper> (diffStep 7.15)\n\n#### [Step 7.15: Extend CPP line class](https://github.com/DAB0mB/radial-snake/commit/66acf9d)\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;geometry&#x2F;line.js\n```diff\n@@ -1,46 +1,10 @@\n-â”Š 1â”Š  â”ŠEngine.Geometry.Line = class Line {\n-â”Š 2â”Š  â”Š  // x1 - The first point's x value\n-â”Š 3â”Š  â”Š  // y1 - The first point's y value\n-â”Š 4â”Š  â”Š  // x1 - The second point's x value\n-â”Š 5â”Š  â”Š  // y2 - The second point's y value\n-â”Š 6â”Š  â”Š  constructor(x1, y1, x2, y2) {\n-â”Š 7â”Š  â”Š    this.x1 = Utils.trim(x1, 9);\n-â”Š 8â”Š  â”Š    this.y1 = Utils.trim(y1, 9);\n-â”Š 9â”Š  â”Š    this.x2 = Utils.trim(x2, 9);\n-â”Š10â”Š  â”Š    this.y2 = Utils.trim(y2, 9);\n-â”Š11â”Š  â”Š  }\n-â”Š12â”Š  â”Š\n+â”Š  â”Š 1â”ŠEngine.Geometry.Line = class Line extends Utils.proxy(CPP.Geometry.Line) {\n â”Š13â”Š 2â”Š  // Draws the line on the given context\n â”Š14â”Š 3â”Š  draw(context) {\n â”Š15â”Š 4â”Š    context.moveTo(this.x1, this.y1);\n â”Š16â”Š 5â”Š    context.lineTo(this.x2, this.y2);\n â”Š17â”Š 6â”Š  }\n â”Š18â”Š 7â”Š\n-â”Š19â”Š  â”Š  // Gets the matching x value for a given y value\n-â”Š20â”Š  â”Š  getX(y) {\n-â”Š21â”Š  â”Š    let x = Utils.trim((((y - this.y1) * (this.x2 - this.x1)) / (this.y2 - this.y1)) + this.x1, 9);\n-â”Š22â”Š  â”Š    if (isNaN(x) || Utils.isBetween(x, this.x1, this.x2)) return x;\n-â”Š23â”Š  â”Š  }\n-â”Š24â”Š  â”Š\n-â”Š25â”Š  â”Š  // Gets the matching y value for a given x value\n-â”Š26â”Š  â”Š  getY(x) {\n-â”Š27â”Š  â”Š    let y = Utils.trim((((x - this.x1) * (this.y2 - this.y1)) / (this.x2 - this.x1)) + this.y1, 9);\n-â”Š28â”Š  â”Š    if (isNaN(y) || Utils.isBetween(y, this.y1, this.y2)) return y;\n-â”Š29â”Š  â”Š  }\n-â”Š30â”Š  â”Š\n-â”Š31â”Š  â”Š  // Returns if line has given point\n-â”Š32â”Š  â”Š  hasPoint(x, y) {\n-â”Š33â”Š  â”Š    if (!this.boundsHavePoint(x, y)) return false;\n-â”Š34â”Š  â”Š    let m = Utils.trim((this.y2 - this.y1) / (this.x2 - this.x1), 9);\n-â”Š35â”Š  â”Š    return (y - this.y1) / (x - this.x1) == m;\n-â”Š36â”Š  â”Š  }\n-â”Š37â”Š  â”Š\n-â”Š38â”Š  â”Š  // Returns if given point is contained by the bounds aka cage of line\n-â”Š39â”Š  â”Š  boundsHavePoint(x, y) {\n-â”Š40â”Š  â”Š    return Utils.isBetween(x, this.x1, this.x2) &&\n-â”Š41â”Š  â”Š           Utils.isBetween(y, this.y1, this.y2);\n-â”Š42â”Š  â”Š  }\n-â”Š43â”Š  â”Š\n â”Š44â”Š 8â”Š  getIntersection(shape) {\n â”Š45â”Š 9â”Š    if (shape instanceof Engine.Geometry.Line)\n â”Š46â”Š10â”Š      return this.getLineIntersection(shape);\n```\n```diff\n@@ -50,23 +14,6 @@\n â”Š50â”Š14â”Š      return this.getPolygonIntersection(shape);\n â”Š51â”Š15â”Š  }\n â”Š52â”Š16â”Š\n-â”Š53â”Š  â”Š  // line - line intersection method\n-â”Š54â”Š  â”Š  getLineIntersection(line) {\n-â”Š55â”Š  â”Š    // Escape if lines are parallel\n-â”Š56â”Š  â”Š    if (!(((this.x1 - this.x2) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * (line.x1 - line.x2)))) return;\n-â”Š57â”Š  â”Š\n-â”Š58â”Š  â”Š    // Intersection point formula\n-â”Š59â”Š  â”Š    let x = Utils.trim(((((this.x1 * this.y2) - (this.y1 * this.x2)) * (line.x1 - line.x2)) - ((this.x1 - this.x2) * ((line.x1 * line.y2) - (line.y1 * line.x2)))) /\n-â”Š60â”Š  â”Š        (((this.x1 - this.x2) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * (line.x1 - line.x2))), 9);\n-â”Š61â”Š  â”Š    let y = Utils.trim(((((this.x1 * this.y2) - (this.y1 * this.x2)) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * ((line.x1 * line.y2) - (line.y1 * line.x2)))) /\n-â”Š62â”Š  â”Š        (((this.x1 - this.x2) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * (line.x1 - line.x2))), 9);\n-â”Š63â”Š  â”Š\n-â”Š64â”Š  â”Š    if (Utils.isBetween(x, this.x1, this.x2) && Utils.isBetween(x, line.x1, line.x2) &&\n-â”Š65â”Š  â”Š        Utils.isBetween(y, this.y1, this.y2) && Utils.isBetween(y, line.y1, line.y2)) {\n-â”Š66â”Š  â”Š      return { x, y };\n-â”Š67â”Š  â”Š    }\n-â”Š68â”Š  â”Š  }\n-â”Š69â”Š  â”Š\n â”Š70â”Š17â”Š  // line - circle intersection method\n â”Š71â”Š18â”Š  getCircleIntersection(circle) {\n â”Š72â”Š19â”Š    return circle.getLineIntersection(this);\n```\n\n[}]: #\n\nBy now, our tests should pass. Accept, there is memory leak we need to handle. But you probably ask yourself - \"What memory leak? It's JavaScript man! Have you ever heard of something called garbage collector?!\". Well, this is not the case when compiling C++ code with Emscripten. You see, Emscripten uses asm.js, which is a subset for JavaScript built exactly for these proposes, enabling C++ modules run on the browser. This is how the [WebGL](https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API) project actually started, an almost complete conversion from the famous C++ [OpenGL](https://www.opengl.org/) to JavaScript. Part of what asm.js does, it disables the garbage collector, and instead, it holds raw pointers, just like in C++. Since returned class instances are pointers with unknown lifespans, they need to be disposed manually, using the `delete` method (identical to how we clear memory from the Heap in C++). Let's dispose unused test data by calling the `delete` method as just mentioned:\n\n[{]: <helper> (diffStep 7.16)\n\n#### [Step 7.16: Delete line instances in tests](https://github.com/DAB0mB/radial-snake/commit/f181da4)\n\n##### Changed resources&#x2F;scripts&#x2F;specs&#x2F;engine&#x2F;geometry&#x2F;circle.js\n```diff\n@@ -111,6 +111,8 @@\n â”Š111â”Š111â”Š          { x: 6, y: 1 },\n â”Š112â”Š112â”Š          { x: -4, y: 1 }\n â”Š113â”Š113â”Š        ]);\n+â”Š   â”Š114â”Š\n+â”Š   â”Š115â”Š        line.delete();\n â”Š114â”Š116â”Š      });\n â”Š115â”Š117â”Š    });\n â”Š116â”Š118â”Š\n```\n```diff\n@@ -121,6 +123,8 @@\n â”Š121â”Š123â”Š        expect(this.circle.getLineIntersection(line)).toEqual([\n â”Š122â”Š124â”Š          { x: -4, y: 1 }\n â”Š123â”Š125â”Š        ]);\n+â”Š   â”Š126â”Š\n+â”Š   â”Š127â”Š        line.delete();\n â”Š124â”Š128â”Š      });\n â”Š125â”Š129â”Š    });\n â”Š126â”Š130â”Š\n```\n```diff\n@@ -131,6 +135,8 @@\n â”Š131â”Š135â”Š        expect(this.circle.getLineIntersection(line)).toEqual([\n â”Š132â”Š136â”Š          { x: 1, y: 6 }\n â”Š133â”Š137â”Š        ]);\n+â”Š   â”Š138â”Š\n+â”Š   â”Š139â”Š        line.delete();\n â”Š134â”Š140â”Š      });\n â”Š135â”Š141â”Š    });\n â”Š136â”Š142â”Š\n```\n```diff\n@@ -138,6 +144,7 @@\n â”Š138â”Š144â”Š      it(\"returns nothing\", function() {\n â”Š139â”Š145â”Š        let line = new Engine.Geometry.Line(-10, 10, 10, 10);\n â”Š140â”Š146â”Š        expect(this.circle.getLineIntersection(line)).toBeUndefined();\n+â”Š   â”Š147â”Š        line.delete();\n â”Š141â”Š148â”Š      });\n â”Š142â”Š149â”Š    });\n â”Š143â”Š150â”Š  });\n```\n\n##### Changed resources&#x2F;scripts&#x2F;specs&#x2F;engine&#x2F;geometry&#x2F;line.js\n```diff\n@@ -3,6 +3,10 @@\n â”Š 3â”Š 3â”Š    this.line = new Engine.Geometry.Line(-5, -5, 5, 5);\n â”Š 4â”Š 4â”Š  });\n â”Š 5â”Š 5â”Š\n+â”Š  â”Š 6â”Š  afterEach(function () {\n+â”Š  â”Š 7â”Š    this.line.delete();\n+â”Š  â”Š 8â”Š  });\n+â”Š  â”Š 9â”Š\n â”Š 6â”Š10â”Š  describe(\"getX method\", function() {\n â”Š 7â”Š11â”Š    describe(\"given inranged y\", function() {\n â”Š 8â”Š12â”Š      it(\"returns x\", function() {\n```\n```diff\n@@ -58,6 +62,8 @@\n â”Š58â”Š62â”Š          x: 1,\n â”Š59â”Š63â”Š          y: 1\n â”Š60â”Š64â”Š        });\n+â”Š  â”Š65â”Š\n+â”Š  â”Š66â”Š        line.delete();\n â”Š61â”Š67â”Š      });\n â”Š62â”Š68â”Š    });\n â”Š63â”Š69â”Š\n```\n```diff\n@@ -65,6 +71,7 @@\n â”Š65â”Š71â”Š      it(\"returns nothing\", function() {\n â”Š66â”Š72â”Š        let line = new Engine.Geometry.Line(-5, -6, 5, 4);\n â”Š67â”Š73â”Š        expect(this.line.getLineIntersection(line)).toBeUndefined();\n+â”Š  â”Š74â”Š        line.delete();\n â”Š68â”Š75â”Š      });\n â”Š69â”Š76â”Š    });\n â”Š70â”Š77â”Š\n```\n```diff\n@@ -72,6 +79,7 @@\n â”Š72â”Š79â”Š      it(\"returns nothing\", function() {\n â”Š73â”Š80â”Š        let line = new Engine.Geometry.Line(10, 10, 10, 15);\n â”Š74â”Š81â”Š        expect(this.line.getLineIntersection(line)).toBeUndefined();\n+â”Š  â”Š82â”Š        line.delete();\n â”Š75â”Š83â”Š      });\n â”Š76â”Š84â”Š    });\n â”Š77â”Š85â”Š  });\n```\n\n##### Changed resources&#x2F;scripts&#x2F;specs&#x2F;engine&#x2F;geometry&#x2F;polygon.js\n```diff\n@@ -35,6 +35,8 @@\n â”Š35â”Š35â”Š          { x: 5, y: 4 },\n â”Š36â”Š36â”Š          { x: 0, y: 1 }\n â”Š37â”Š37â”Š        ]);\n+â”Š  â”Š38â”Š\n+â”Š  â”Š39â”Š        line.delete();\n â”Š38â”Š40â”Š      });\n â”Š39â”Š41â”Š    });\n â”Š40â”Š42â”Š\n```\n```diff\n@@ -43,6 +45,8 @@\n â”Š43â”Š45â”Š        let line = new Engine.Geometry.Line(10, 11, 15, 14);\n â”Š44â”Š46â”Š\n â”Š45â”Š47â”Š        expect(this.polygon.getLineIntersection(line)).toBeUndefined();\n+â”Š  â”Š48â”Š\n+â”Š  â”Š49â”Š        line.delete();\n â”Š46â”Š50â”Š      });\n â”Š47â”Š51â”Š    });\n â”Š48â”Š52â”Š  });\n```\n\n[}]: #\n\nSince our game also uses polygons, which is made of an abstract number of lines, its test-data needs to be disposed as well. First, we will add a `delete` method to the polygon class, which will simply go though all its bounds and delete each of its lines:\n\n[{]: <helper> (diffStep 7.17)\n\n#### [Step 7.17: Add polygon deletion method](https://github.com/DAB0mB/radial-snake/commit/1c9447f)\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;geometry&#x2F;polygon.js\n```diff\n@@ -5,6 +5,10 @@\n â”Š 5â”Š 5â”Š    this.bounds = bounds.map(coords => new Engine.Geometry.Line(...coords));\n â”Š 6â”Š 6â”Š  }\n â”Š 7â”Š 7â”Š\n+â”Š  â”Š 8â”Š  delete() {\n+â”Š  â”Š 9â”Š    this.bounds.forEach(bound => bound.delete());\n+â”Š  â”Š10â”Š  }\n+â”Š  â”Š11â”Š\n â”Š 8â”Š12â”Š  // Returns if polygon has given point\n â”Š 9â”Š13â”Š  hasPoint(x, y) {\n â”Š10â”Š14â”Š    // Run check for each bound\n```\n\n[}]: #\n\nNow we can conveniently delete unused polygons in the tests:\n\n[{]: <helper> (diffStep 7.18)\n\n#### [Step 7.18: Delete polygon instances in tests](https://github.com/DAB0mB/radial-snake/commit/48024bc)\n\n##### Changed resources&#x2F;scripts&#x2F;specs&#x2F;engine&#x2F;geometry&#x2F;polygon.js\n```diff\n@@ -8,6 +8,10 @@\n â”Š 8â”Š 8â”Š    );\n â”Š 9â”Š 9â”Š  });\n â”Š10â”Š10â”Š\n+â”Š  â”Š11â”Š  afterEach(function () {\n+â”Š  â”Š12â”Š    this.polygon.delete();\n+â”Š  â”Š13â”Š  });\n+â”Š  â”Š14â”Š\n â”Š11â”Š15â”Š  describe(\"hasPoint method\", function() {\n â”Š12â”Š16â”Š    describe(\"given contained point\", function() {\n â”Š13â”Š17â”Š      it(\"returns true\", function() {\n```\n\n[}]: #\n\nMoving on, we have the circle class to transform. The process is almost the identical to how we transformed the line class, so it's gonna be way easier now. We first start by translating our code from JavaScript to C++:\n\n[{]: <helper> (diffStep 7.19)\n\n#### [Step 7.19: Add base circle CPP module](https://github.com/DAB0mB/radial-snake/commit/1a3fa58)\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;geometry&#x2F;circle.cpp\n```diff\n@@ -0,0 +1,202 @@\n+â”Š   â”Š  1â”Š\n+â”Š   â”Š  2â”Š#include <algorithm>\n+â”Š   â”Š  3â”Š#include <cmath>\n+â”Š   â”Š  4â”Š#include <vector>\n+â”Š   â”Š  5â”Š#include \"../nullable.h\"\n+â”Š   â”Š  6â”Š#include \"../utils.h\"\n+â”Š   â”Š  7â”Š#include \"point.h\"\n+â”Š   â”Š  8â”Š#include \"line.h\"\n+â”Š   â”Š  9â”Š\n+â”Š   â”Š 10â”Šnamespace geometry {\n+â”Š   â”Š 11â”Š  // x - The x value of the circle's center\n+â”Š   â”Š 12â”Š  // y - The y value of the circle's center\n+â”Š   â”Š 13â”Š  // r - The radius of the center\n+â”Š   â”Š 14â”Š  // rad1 - The first radian of the circle, not necessarily its beginning\n+â”Š   â”Š 15â”Š  // rad2 - The second radian of the circle, not necessarily its beginning\n+â”Š   â”Š 16â”Š  Circle::Circle(double x, double y, double r, double rad1, double rad2) {\n+â”Š   â”Š 17â”Š    _x = utils::trim(x, 9);\n+â”Š   â”Š 18â”Š    _y = utils::trim(y, 9);\n+â”Š   â”Š 19â”Š    _r = utils::trim(r, 9);\n+â”Š   â”Š 20â”Š\n+â”Š   â”Š 21â”Š    // Trimming mode is done based on which radian represents the ending and which radian\n+â”Š   â”Š 22â”Š    // represents the ending\n+â”Š   â”Š 23â”Š    if (rad1 > rad2) {\n+â”Š   â”Š 24â”Š      _rad1 = utils::trim(rad1, 9, \"floor\");\n+â”Š   â”Š 25â”Š      _rad2 = utils::trim(rad2, 9, \"ceil\");\n+â”Š   â”Š 26â”Š    }\n+â”Š   â”Š 27â”Š    else {\n+â”Š   â”Š 28â”Š      _rad1 = utils::trim(rad1, 9, \"ceil\");\n+â”Š   â”Š 29â”Š      _rad2 = utils::trim(rad2, 9, \"floor\");\n+â”Š   â”Š 30â”Š    }\n+â”Š   â”Š 31â”Š  }\n+â”Š   â”Š 32â”Š\n+â”Š   â”Š 33â”Š  // Gets the matching x value for the given radian\n+â”Š   â”Š 34â”Š  Nullable<double> Circle::getMatchingX(double rad) {\n+â”Š   â”Š 35â”Š    if (!utils::chain(rad)->trim(9)->isBetween(_rad1, _rad2)->result()) {\n+â”Š   â”Š 36â”Š      return Nullable<double>();\n+â”Š   â”Š 37â”Š    }\n+â”Š   â”Š 38â”Š\n+â”Š   â”Š 39â”Š    return Nullable<double>(utils::trim((_r * std::cos(rad)) + _x, 9));\n+â”Š   â”Š 40â”Š  }\n+â”Š   â”Š 41â”Š\n+â”Š   â”Š 42â”Š  // Gets the matching y value for the given radian\n+â”Š   â”Š 43â”Š  Nullable<double> Circle::getMatchingY(double rad) {\n+â”Š   â”Š 44â”Š    if (!utils::chain(rad)->trim(9)->isBetween(_rad1, _rad2)->result()) {\n+â”Š   â”Š 45â”Š      return Nullable<double>();\n+â”Š   â”Š 46â”Š    }\n+â”Š   â”Š 47â”Š\n+â”Š   â”Š 48â”Š    return Nullable<double>(utils::trim((_r * std::sin(rad)) + _y, 9));\n+â”Š   â”Š 49â”Š  }\n+â”Š   â”Š 50â”Š\n+â”Š   â”Š 51â”Š  // Gets the matching point for the given radian\n+â”Š   â”Š 52â”Š  Nullable<Point> Circle::getMatchingPoint(double rad) {\n+â”Š   â”Š 53â”Š    if (!utils::isBetween(rad, _rad1, _rad2)) {\n+â”Š   â”Š 54â”Š      return Nullable<Point>();\n+â”Š   â”Š 55â”Š    }\n+â”Š   â”Š 56â”Š\n+â”Š   â”Š 57â”Š    return Nullable<Point>({\n+â”Š   â”Š 58â”Š      utils::trim((_r * std::cos(rad)) + _x, 9),\n+â”Š   â”Š 59â”Š      utils::trim((_r * std::sin(rad)) + _y, 9)\n+â”Š   â”Š 60â”Š    });\n+â”Š   â”Š 61â”Š  }\n+â”Š   â”Š 62â”Š\n+â”Š   â”Š 63â”Š  // Gets the matching radian for the given point\n+â”Š   â”Š 64â”Š  Nullable<double> Circle::getMatchingRad(double x, double y) {\n+â”Š   â”Š 65â”Š    double rad = std::atan2(y - _y, x - _x);\n+â”Š   â”Š 66â”Š\n+â”Š   â”Š 67â”Š    // If calculated radian is in circle's radian range, return it\n+â”Š   â”Š 68â”Š    if (!std::isnan(rad) && utils::isBetween(rad, _rad1, _rad2)) {\n+â”Š   â”Š 69â”Š      return Nullable<double>(rad);\n+â”Š   â”Š 70â”Š    }\n+â”Š   â”Š 71â”Š\n+â”Š   â”Š 72â”Š    // The calculated radian can still be in the circle's radian range in case one\n+â”Š   â”Š 73â”Š    // of the radians is greater than 2 PIEs\n+â”Š   â”Š 74â”Š    double greatestRad = std::abs(_rad1) > std::abs(_rad2) ? _rad1 : _rad2;\n+â”Š   â”Š 75â”Š\n+â”Š   â”Š 76â”Š    // Check if the absolute radian is in the circle's radian range\n+â”Š   â”Š 77â”Š    if (utils::chain(rad + (2 * M_PI * std::floor(greatestRad / (2 * M_PI))))\n+â”Š   â”Š 78â”Š        ->trim(9)->isBetween(_rad1, _rad2)->result() ||\n+â”Š   â”Š 79â”Š        utils::chain(rad + (2 * M_PI * std::ceil(greatestRad / (2 * M_PI))))\n+â”Š   â”Š 80â”Š        ->trim(9)->isBetween(_rad1, _rad2)->result()) {\n+â”Š   â”Š 81â”Š      return Nullable<double>(rad);\n+â”Š   â”Š 82â”Š    }\n+â”Š   â”Š 83â”Š\n+â”Š   â”Š 84â”Š    return Nullable<double>();\n+â”Š   â”Š 85â”Š  }\n+â”Š   â”Š 86â”Š\n+â”Š   â”Š 87â”Š  // Returns if circle has given points\n+â”Š   â”Š 88â”Š  bool Circle::hasPoint(double x, double y) {\n+â”Š   â”Š 89â”Š    return getMatchingRad(x, y).hasValue();\n+â”Š   â”Š 90â”Š  }\n+â”Š   â”Š 91â”Š\n+â”Š   â”Š 92â”Š  // circle - circle intersection method\n+â”Š   â”Š 93â”Š  Nullable<std::vector<Point>> Circle::getIntersection(Circle circle) {\n+â”Š   â”Š 94â”Š    double dx = circle._x - _x;\n+â”Š   â”Š 95â”Š    double dy = circle._y - _y;\n+â”Š   â”Š 96â”Š    double d = std::sqrt(std::pow(dx, 2) + std::pow(dy, 2));\n+â”Š   â”Š 97â”Š\n+â”Š   â”Š 98â”Š    if (d > _r + circle._r ||\n+â”Š   â”Š 99â”Š       d < std::abs(_r - circle._r)) {\n+â”Š   â”Š100â”Š      return Nullable<std::vector<Point>>();\n+â”Š   â”Š101â”Š    }\n+â”Š   â”Š102â”Š\n+â”Š   â”Š103â”Š    double a = ((std::pow(_r, 2) - std::pow(circle._r, 2)) + std::pow(d, 2)) / (2 * d);\n+â”Š   â”Š104â”Š    double x = _x + ((dx * a) / d);\n+â”Š   â”Š105â”Š    double y = _y + ((dy * a) / d);\n+â”Š   â”Š106â”Š    double h = std::sqrt(std::pow(_r, 2) - std::pow(a, 2));\n+â”Š   â”Š107â”Š    double rx = (- dy * h) / d;\n+â”Š   â”Š108â”Š    double ry = (dx * h) / d;\n+â”Š   â”Š109â”Š\n+â”Š   â”Š110â”Š    std::vector<Point> interPoints(2);\n+â”Š   â”Š111â”Š    interPoints.at(0).x = x + rx;\n+â”Š   â”Š112â”Š    interPoints.at(0).y = y + ry;\n+â”Š   â”Š113â”Š    interPoints.at(1).x = x - rx;\n+â”Š   â”Š114â”Š    interPoints.at(1).y = y - ry;\n+â”Š   â”Š115â”Š\n+â”Š   â”Š116â”Š    for (unsigned i = 0; i < interPoints.size(); i++) {\n+â”Š   â”Š117â”Š      Point& point = interPoints.at(i);\n+â”Š   â”Š118â”Š      point.x = utils::trim(point.x, 9);\n+â”Š   â”Š119â”Š      point.y = utils::trim(point.y, 9);\n+â”Š   â”Š120â”Š    }\n+â”Š   â”Š121â”Š\n+â”Š   â”Š122â”Š    auto pointsBegin = std::unique(interPoints.begin(), interPoints.end(),\n+â”Š   â”Š123â”Š      [](Point pointA, Point pointB) {\n+â”Š   â”Š124â”Š        return pointA.x == pointB.x && pointA.y == pointB.y;\n+â”Š   â”Š125â”Š      }\n+â”Š   â”Š126â”Š    );\n+â”Š   â”Š127â”Š\n+â”Š   â”Š128â”Š    interPoints.erase(pointsBegin, interPoints.end());\n+â”Š   â”Š129â”Š\n+â”Š   â”Š130â”Š    std::vector<Circle> circles = { *this, circle };\n+â”Š   â”Š131â”Š\n+â”Š   â”Š132â”Š    std::for_each(circles.begin(), circles.end(), [&interPoints](Circle circle) {\n+â”Š   â”Š133â”Š      auto pointsBegin = std::remove_if(interPoints.begin(), interPoints.end(),\n+â”Š   â”Š134â”Š        [&circle](Point point) {\n+â”Š   â”Š135â”Š          return !circle.hasPoint(point.x, point.y);\n+â”Š   â”Š136â”Š        }\n+â”Š   â”Š137â”Š      );\n+â”Š   â”Š138â”Š\n+â”Š   â”Š139â”Š      interPoints.erase(pointsBegin, interPoints.end());\n+â”Š   â”Š140â”Š    });\n+â”Š   â”Š141â”Š\n+â”Š   â”Š142â”Š    if (interPoints.size()) {\n+â”Š   â”Š143â”Š      return Nullable<std::vector<Point>>(interPoints);\n+â”Š   â”Š144â”Š    }\n+â”Š   â”Š145â”Š\n+â”Š   â”Š146â”Š    return Nullable<std::vector<Point>>();\n+â”Š   â”Š147â”Š  }\n+â”Š   â”Š148â”Š\n+â”Š   â”Š149â”Š  // circle - line intersection method\n+â”Š   â”Š150â”Š  Nullable<std::vector<Point>> Circle::getIntersection(Line line) {\n+â”Š   â”Š151â”Š    double x1 = line._x1 - _x;\n+â”Š   â”Š152â”Š    double x2 = line._x2 - _x;\n+â”Š   â”Š153â”Š    double y1 = line._y1 - _y;\n+â”Š   â”Š154â”Š    double y2 = line._y2 - _y;\n+â”Š   â”Š155â”Š    double dx = x2 - x1;\n+â”Š   â”Š156â”Š    double dy = y2 - y1;\n+â”Š   â”Š157â”Š    double d = std::sqrt(std::pow(dx, 2) + std::pow(dy, 2));\n+â”Š   â”Š158â”Š    double h = (x1 * y2) - (x2 * y1);\n+â”Š   â”Š159â”Š    double delta = (std::pow(_r, 2) * std::pow(d, 2)) - std::pow(h, 2);\n+â”Š   â”Š160â”Š\n+â”Š   â”Š161â”Š    if (delta < 0) Nullable<std::vector<Point>>();\n+â”Š   â”Š162â”Š\n+â”Š   â”Š163â”Š    double sign = dy / std::abs(dy); if (std::isnan(sign)) sign = 1;\n+â”Š   â”Š164â”Š    double sqrtx = sign * dx * std::sqrt(delta);\n+â”Š   â”Š165â”Š    double sqrty = std::abs(dy) * std::sqrt(delta);\n+â”Š   â”Š166â”Š\n+â”Š   â”Š167â”Š    std::vector<Point> interPoints(2);\n+â”Š   â”Š168â”Š    interPoints.at(0).x = (((h * dy) + sqrtx) / std::pow(d, 2)) + _x;\n+â”Š   â”Š169â”Š    interPoints.at(0).y = (((-h * dx) + sqrty) / std::pow(d, 2)) + _y;\n+â”Š   â”Š170â”Š    interPoints.at(1).x = (((h * dy) - sqrtx) / std::pow(d, 2)) + _x;\n+â”Š   â”Š171â”Š    interPoints.at(1).y = (((-h * dx) - sqrty) / std::pow(d, 2)) + _y;\n+â”Š   â”Š172â”Š\n+â”Š   â”Š173â”Š    for (unsigned i = 0; i < interPoints.size(); i++) {\n+â”Š   â”Š174â”Š      Point& point = interPoints.at(i);\n+â”Š   â”Š175â”Š      point.x = utils::trim(point.x, 9);\n+â”Š   â”Š176â”Š      point.y = utils::trim(point.y, 9);\n+â”Š   â”Š177â”Š    }\n+â”Š   â”Š178â”Š\n+â”Š   â”Š179â”Š    auto pointsBegin = std::remove_if(interPoints.begin(), interPoints.end(),\n+â”Š   â”Š180â”Š      [this, &line](Point point) {\n+â”Š   â”Š181â”Š        return !hasPoint(point.x, point.y) ||\n+â”Š   â”Š182â”Š          !line.boundsHavePoint(point.x, point.y);\n+â”Š   â”Š183â”Š      }\n+â”Š   â”Š184â”Š    );\n+â”Š   â”Š185â”Š\n+â”Š   â”Š186â”Š    interPoints.erase(pointsBegin, interPoints.end());\n+â”Š   â”Š187â”Š\n+â”Š   â”Š188â”Š    pointsBegin = std::unique(interPoints.begin(), interPoints.end(),\n+â”Š   â”Š189â”Š      [](Point pointA, Point pointB) {\n+â”Š   â”Š190â”Š        return pointA.x == pointB.x && pointA.y == pointB.y;\n+â”Š   â”Š191â”Š      }\n+â”Š   â”Š192â”Š    );\n+â”Š   â”Š193â”Š\n+â”Š   â”Š194â”Š    interPoints.erase(pointsBegin, interPoints.end());\n+â”Š   â”Š195â”Š\n+â”Š   â”Š196â”Š    if (interPoints.size()) {\n+â”Š   â”Š197â”Š      return Nullable<std::vector<Point>>(interPoints);\n+â”Š   â”Š198â”Š    }\n+â”Š   â”Š199â”Š\n+â”Š   â”Š200â”Š    return Nullable<std::vector<Point>>();\n+â”Š   â”Š201â”Š  }\n+â”Š   â”Š202â”Š}ðŸš«â†µ\n```\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;geometry&#x2F;circle.h\n```diff\n@@ -0,0 +1,35 @@\n+â”Š  â”Š 1â”Š#pragma once\n+â”Š  â”Š 2â”Š\n+â”Š  â”Š 3â”Š#include <vector>\n+â”Š  â”Š 4â”Š#include \"../nullable.h\"\n+â”Š  â”Š 5â”Š#include \"point.h\"\n+â”Š  â”Š 6â”Š#include \"line.h\"\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Šnamespace geometry {\n+â”Š  â”Š 9â”Š  class Line;\n+â”Š  â”Š10â”Š\n+â”Š  â”Š11â”Š  class Circle {\n+â”Š  â”Š12â”Š  public:\n+â”Š  â”Š13â”Š    double _x;\n+â”Š  â”Š14â”Š    double _y;\n+â”Š  â”Š15â”Š    double _r;\n+â”Š  â”Š16â”Š    double _rad1;\n+â”Š  â”Š17â”Š    double _rad2;\n+â”Š  â”Š18â”Š\n+â”Š  â”Š19â”Š    Circle(double x, double y, double r, double rad1, double rad2);\n+â”Š  â”Š20â”Š\n+â”Š  â”Š21â”Š    Nullable<double> getMatchingX(double rad);\n+â”Š  â”Š22â”Š\n+â”Š  â”Š23â”Š    Nullable<double> getMatchingY(double rad);\n+â”Š  â”Š24â”Š\n+â”Š  â”Š25â”Š    Nullable<Point> getMatchingPoint(double rad);\n+â”Š  â”Š26â”Š\n+â”Š  â”Š27â”Š    Nullable<double> getMatchingRad(double x, double y);\n+â”Š  â”Š28â”Š\n+â”Š  â”Š29â”Š    bool hasPoint(double x, double y);\n+â”Š  â”Š30â”Š\n+â”Š  â”Š31â”Š    Nullable<std::vector<Point>> getIntersection(Circle circle);\n+â”Š  â”Š32â”Š\n+â”Š  â”Š33â”Š    Nullable<std::vector<Point>> getIntersection(Line line);\n+â”Š  â”Š34â”Š  };\n+â”Š  â”Š35â”Š}ðŸš«â†µ\n```\n\n##### Changed resources&#x2F;cpp&#x2F;src&#x2F;index.cpp\n```diff\n@@ -1,3 +1,4 @@\n â”Š1â”Š1â”Š#include \"nullable.cpp\"\n â”Š2â”Š2â”Š#include \"utils.cpp\"\n-â”Š3â”Š â”Š#include \"geometry/line.cpp\"ðŸš«â†µ\n+â”Š â”Š3â”Š#include \"geometry/line.cpp\"\n+â”Š â”Š4â”Š#include \"geometry/circle.cpp\"ðŸš«â†µ\n```\n\n[}]: #\n\nSecond, we need to wrap our code using EMBind:\n\n[{]: <helper> (diffStep 7.2)\n\n#### [Step 7.2: Add base utility CPP module](https://github.com/DAB0mB/radial-snake/commit/6dba512)\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;utils.cpp\n```diff\n@@ -0,0 +1,73 @@\n+â”Š  â”Š 1â”Š#include <cfloat>\n+â”Š  â”Š 2â”Š#include <cmath>\n+â”Š  â”Š 3â”Š#include <string>\n+â”Š  â”Š 4â”Š#include \"utils.h\"\n+â”Š  â”Š 5â”Š\n+â”Š  â”Š 6â”Šnamespace utils {\n+â”Š  â”Š 7â”Š  // Fixed modulo method which can calculate modulo of negative numbers properly\n+â”Š  â”Š 8â”Š  // e.g. (-803).mod(800) returns 797\n+â”Š  â”Š 9â”Š  double mod(double context, double num) {\n+â”Š  â”Š10â”Š    return std::fmod((std::fmod(context, num) + num), num);\n+â”Š  â”Š11â”Š  }\n+â”Š  â”Š12â”Š\n+â”Š  â”Š13â”Š  // Trims number and leaves the number of decimals specified.\n+â”Š  â”Š14â”Š  // The \"mode\" argument specifies which math function should be invoked\n+â”Š  â”Š15â”Š  // right after the number has been trimmed.\n+â”Š  â”Š16â”Š  // e.g. 12.12345.trim(3, \"ceil\") returns 12.124\n+â”Š  â”Š17â”Š  double trim(double context, int decimals, const std::string mode) {\n+â”Š  â”Š18â”Š    double accumulator = context * std::pow(10, decimals);\n+â”Š  â”Š19â”Š\n+â”Š  â”Š20â”Š    if (mode.compare(\"ceil\") == 0)\n+â”Š  â”Š21â”Š      accumulator = std::ceil(accumulator);\n+â”Š  â”Š22â”Š    else if (mode.compare(\"floor\") == 0)\n+â”Š  â”Š23â”Š      accumulator = std::floor(accumulator);\n+â”Š  â”Š24â”Š    else\n+â”Š  â”Š25â”Š      accumulator = std::round(accumulator);\n+â”Š  â”Š26â”Š\n+â”Š  â”Š27â”Š    return accumulator / std::pow(10, decimals);\n+â”Š  â”Š28â”Š  }\n+â”Š  â”Š29â”Š\n+â”Š  â”Š30â”Š  // Tells if number is in specified range based on given precision.\n+â”Š  â”Š31â”Š  // See the \"compare\" method for more information about precision\n+â”Š  â”Š32â”Š  bool isBetween(double context, double num1, double num2, const std::string precision) {\n+â”Š  â”Š33â”Š    return compare(context, std::min(num1, num2), \">=\", precision) &&\n+â”Š  â”Š34â”Š           compare(context, std::max(num1, num2), \"<=\", precision);\n+â”Š  â”Š35â”Š  }\n+â”Š  â”Š36â”Š\n+â”Š  â”Š37â”Š  bool compare(double context, double num, const std::string precision) {\n+â”Š  â”Š38â”Š    return compare(context, num, \"==\", precision);\n+â”Š  â”Š39â”Š  }\n+â”Š  â”Š40â”Š\n+â”Š  â”Š41â”Š  // Initiates comparison operator between context number and a given number, only here\n+â”Š  â”Š42â”Š  // a precision can be specified\n+â”Š  â”Š43â”Š  bool compare(double context, double num, const std::string method, const std::string precision) {\n+â”Š  â”Š44â”Š    // Fixed precision, \"almost equal\" with a deviation of Îµ\n+â”Š  â”Š45â”Š    if (precision.compare(\"f\") == 0) {\n+â”Š  â”Š46â”Š      if (method.compare(\"<\") == 0 ||\n+â”Š  â”Š47â”Š          method.compare(\"<=\") == 0)\n+â”Š  â”Š48â”Š        return context <= num + DBL_EPSILON;\n+â”Š  â”Š49â”Š      if (method.compare(\">\") == 0 ||\n+â”Š  â”Š50â”Š          method.compare(\">=\") == 0)\n+â”Š  â”Š51â”Š        return context >= num - DBL_EPSILON;\n+â”Š  â”Š52â”Š      return std::abs(context - num) <= DBL_EPSILON;\n+â”Š  â”Š53â”Š    }\n+â”Š  â”Š54â”Š    // Pixel precision, round comparison\n+â”Š  â”Š55â”Š    else if (precision.compare(\"px\") == 0) {\n+â”Š  â”Š56â”Š      if (method.compare(\"<\") == 0 ||\n+â”Š  â”Š57â”Š          method.compare(\"<=\") == 0)\n+â”Š  â”Š58â”Š        return std::round(context) <= std::round(num);\n+â”Š  â”Š59â”Š      if (method.compare(\">\") == 0 ||\n+â”Š  â”Š60â”Š          method.compare(\">=\") == 0)\n+â”Š  â”Š61â”Š        return std::round(context) >= std::round(num);\n+â”Š  â”Š62â”Š      return std::round(context) == std::round(num);\n+â”Š  â”Š63â”Š    }\n+â”Š  â”Š64â”Š    // Exact precision\n+â”Š  â”Š65â”Š    else {\n+â”Š  â”Š66â”Š      if (method.compare(\"<\") == 0) return context < num;\n+â”Š  â”Š67â”Š      if (method.compare(\"<=\") == 0) return context <= num;\n+â”Š  â”Š68â”Š      if (method.compare(\">\") == 0) return context > num;\n+â”Š  â”Š69â”Š      if (method.compare(\">=\") == 0) return context >= num;\n+â”Š  â”Š70â”Š      return context == num;\n+â”Š  â”Š71â”Š    }\n+â”Š  â”Š72â”Š  }\n+â”Š  â”Š73â”Š}ðŸš«â†µ\n```\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;utils.h\n```diff\n@@ -0,0 +1,15 @@\n+â”Š  â”Š 1â”Š#pragma once\n+â”Š  â”Š 2â”Š\n+â”Š  â”Š 3â”Š#include <string>\n+â”Š  â”Š 4â”Š\n+â”Š  â”Š 5â”Šnamespace utils {\n+â”Š  â”Š 6â”Š  double mod(double context, double num);\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Š  double trim(double context, int decimals, const std::string mode = \"round\");\n+â”Š  â”Š 9â”Š\n+â”Š  â”Š10â”Š  bool isBetween(double context, double num1, double num2, const std::string precision = \"exact\");\n+â”Š  â”Š11â”Š\n+â”Š  â”Š12â”Š  bool compare(double context, double num, const std::string precision = \"exact\");\n+â”Š  â”Š13â”Š\n+â”Š  â”Š14â”Š  bool compare(double context, double num, const std::string method, const std::string precision);\n+â”Š  â”Š15â”Š}ðŸš«â†µ\n```\n\n[}]: #\n\nAnd finally, we will extend the C++ in our JavaScript circle:\n\n[{]: <helper> (diffStep 7.21)\n\n#### [Step 7.21: Extend CPP circle class](https://github.com/DAB0mB/radial-snake/commit/d05cf32)\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;geometry&#x2F;circle.js\n```diff\n@@ -1,83 +1,9 @@\n-â”Š 1â”Š  â”ŠEngine.Geometry.Circle = class Circle {\n-â”Š 2â”Š  â”Š  // x - The x value of the circle's center\n-â”Š 3â”Š  â”Š  // y - The y value of the circle's center\n-â”Š 4â”Š  â”Š  // r - The radius of the center\n-â”Š 5â”Š  â”Š  // rad1 - The first radian of the circle, not necessarily its beginning\n-â”Š 6â”Š  â”Š  // rad2 - The second radian of the circle, not necessarily its beginning\n-â”Š 7â”Š  â”Š  constructor(x, y, r, rad1, rad2) {\n-â”Š 8â”Š  â”Š    this.x = Utils.trim(x, 9);\n-â”Š 9â”Š  â”Š    this.y = Utils.trim(y, 9);\n-â”Š10â”Š  â”Š    this.r = Utils.trim(r, 9);\n-â”Š11â”Š  â”Š\n-â”Š12â”Š  â”Š    // Trimming mode is done based on which radian represents the ending and which radian\n-â”Š13â”Š  â”Š    // represents the ending\n-â”Š14â”Š  â”Š    if (rad1 > rad2) {\n-â”Š15â”Š  â”Š      this.rad1 = Utils.trim(rad1, 9, \"floor\");\n-â”Š16â”Š  â”Š      this.rad2 = Utils.trim(rad2, 9, \"ceil\");\n-â”Š17â”Š  â”Š    }\n-â”Š18â”Š  â”Š    else {\n-â”Š19â”Š  â”Š      this.rad1 = Utils.trim(rad1, 9, \"ceil\");\n-â”Š20â”Š  â”Š      this.rad2 = Utils.trim(rad2, 9, \"floor\");\n-â”Š21â”Š  â”Š    }\n-â”Š22â”Š  â”Š  }\n-â”Š23â”Š  â”Š\n+â”Š  â”Š 1â”ŠEngine.Geometry.Circle = class Circle extends Utils.proxy(CPP.Geometry.Circle) {\n â”Š24â”Š 2â”Š  // Draws the circle on the given context\n â”Š25â”Š 3â”Š  draw(context) {\n â”Š26â”Š 4â”Š    context.arc(this.x, this.y, this.r, this.rad1, this.rad2);\n â”Š27â”Š 5â”Š  }\n â”Š28â”Š 6â”Š\n-â”Š29â”Š  â”Š  // Gets the matching x value for the given radian\n-â”Š30â”Š  â”Š  getX(rad) {\n-â”Š31â”Š  â”Š    if (!Utils(rad).trim(9).isBetween(this.rad1, this.rad2).value()) return;\n-â”Š32â”Š  â”Š    return Utils.trim((this.r * Math.cos(rad)) + this.x, 9);\n-â”Š33â”Š  â”Š  }\n-â”Š34â”Š  â”Š\n-â”Š35â”Š  â”Š  // Gets the matching y value for the given radian\n-â”Š36â”Š  â”Š  getY(rad) {\n-â”Š37â”Š  â”Š    if (!Utils(rad).trim(9).isBetween(this.rad1, this.rad2).value()) return;\n-â”Š38â”Š  â”Š    return Utils.trim((this.r * Math.sin(rad)) + this.y, 9);\n-â”Š39â”Š  â”Š  }\n-â”Š40â”Š  â”Š\n-â”Š41â”Š  â”Š  // Gets the matching point for the given radian\n-â”Š42â”Š  â”Š  getPoint(rad) {\n-â”Š43â”Š  â”Š    if (!Utils.isBetween(rad, this.rad1, this.rad2)) return;\n-â”Š44â”Š  â”Š\n-â”Š45â”Š  â”Š    return {\n-â”Š46â”Š  â”Š      x: Utils.trim((this.r * Math.cos(rad)) + this.x, 9),\n-â”Š47â”Š  â”Š      y: Utils.trim((this.r * Math.sin(rad)) + this.y, 9)\n-â”Š48â”Š  â”Š    };\n-â”Š49â”Š  â”Š  }\n-â”Š50â”Š  â”Š\n-â”Š51â”Š  â”Š  // Gets the matching radian for the given point\n-â”Š52â”Š  â”Š  getRad(x, y) {\n-â”Š53â”Š  â”Š    let rad = Math.atan2(y - this.y, x - this.x);\n-â”Š54â”Š  â”Š\n-â”Š55â”Š  â”Š    // If calculated radian is in circle's radian range, return it\n-â”Š56â”Š  â”Š    if (rad != null && Utils.isBetween(rad, this.rad1, this.rad2)) {\n-â”Š57â”Š  â”Š      return rad;\n-â”Š58â”Š  â”Š    }\n-â”Š59â”Š  â”Š\n-â”Š60â”Š  â”Š    // The calculated radian can still be in the circle's radian range in case one\n-â”Š61â”Š  â”Š    // of the radians is greater than 2 PIEs\n-â”Š62â”Š  â”Š    if (Math.abs(this.rad1) > Math.abs(this.rad2)) {\n-â”Š63â”Š  â”Š      var greatestRad = this.rad1;\n-â”Š64â”Š  â”Š    }\n-â”Š65â”Š  â”Š    else {\n-â”Š66â”Š  â”Š      var greatestRad = this.rad2;\n-â”Š67â”Š  â”Š    }\n-â”Š68â”Š  â”Š\n-â”Š69â”Š  â”Š    // Check if the absolute radian is in the circle's radian range\n-â”Š70â”Š  â”Š    if (Utils(rad + (2 * Math.PI * Math.floor(greatestRad / (2 * Math.PI)))).trim(9).isBetween(this.rad1, this.rad2).value() ||\n-â”Š71â”Š  â”Š        Utils(rad + (2 * Math.PI * Math.ceil(greatestRad / (2 * Math.PI)))).trim(9).isBetween(this.rad1, this.rad2).value()) {\n-â”Š72â”Š  â”Š      return rad;\n-â”Š73â”Š  â”Š    }\n-â”Š74â”Š  â”Š  }\n-â”Š75â”Š  â”Š\n-â”Š76â”Š  â”Š  // Returns if circle has given points\n-â”Š77â”Š  â”Š  hasPoint(x, y) {\n-â”Š78â”Š  â”Š    return this.getRad(x, y) != null;\n-â”Š79â”Š  â”Š  }\n-â”Š80â”Š  â”Š\n â”Š81â”Š 7â”Š  getIntersection(shape) {\n â”Š82â”Š 8â”Š    if (shape instanceof Engine.Geometry.Line)\n â”Š83â”Š 9â”Š      return this.getLineIntersection(shape);\n```\n```diff\n@@ -87,86 +13,6 @@\n â”Š 87â”Š 13â”Š      return this.getPolygonIntersection(shape);\n â”Š 88â”Š 14â”Š  }\n â”Š 89â”Š 15â”Š\n-â”Š 90â”Š   â”Š  // circle - circle intersection method\n-â”Š 91â”Š   â”Š  getCircleIntersection(circle) {\n-â”Š 92â”Š   â”Š    let dx = circle.x - this.x;\n-â”Š 93â”Š   â”Š    let dy = circle.y - this.y;\n-â”Š 94â”Š   â”Š    let d = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\n-â”Š 95â”Š   â”Š\n-â”Š 96â”Š   â”Š    if (d > this.r + circle.r ||\n-â”Š 97â”Š   â”Š       d < Math.abs(this.r - circle.r)) {\n-â”Š 98â”Š   â”Š      return;\n-â”Š 99â”Š   â”Š    }\n-â”Š100â”Š   â”Š\n-â”Š101â”Š   â”Š    let a = ((Math.pow(this.r, 2) - Math.pow(circle.r, 2)) + Math.pow(d, 2)) / (2 * d);\n-â”Š102â”Š   â”Š    let x = this.x + ((dx * a) / d);\n-â”Š103â”Š   â”Š    let y = this.y + ((dy * a) / d);\n-â”Š104â”Š   â”Š    let h = Math.sqrt(Math.pow(this.r, 2) - Math.pow(a, 2));\n-â”Š105â”Š   â”Š    let rx = (- dy * h) / d;\n-â”Š106â”Š   â”Š    let ry = (dx * h) / d;\n-â”Š107â”Š   â”Š\n-â”Š108â”Š   â”Š    let interPoints = [\n-â”Š109â”Š   â”Š      {\n-â”Š110â”Š   â”Š        x: x + rx,\n-â”Š111â”Š   â”Š        y: y + ry\n-â”Š112â”Š   â”Š      },\n-â”Š113â”Š   â”Š      {\n-â”Š114â”Š   â”Š        x: x - rx,\n-â”Š115â”Š   â”Š        y: y - ry\n-â”Š116â”Š   â”Š      }\n-â”Š117â”Š   â”Š    ]\n-â”Š118â”Š   â”Š    .map(point => ({\n-â”Š119â”Š   â”Š        x: Utils.trim(point.x, 9),\n-â”Š120â”Š   â”Š        y: Utils.trim(point.y, 9)\n-â”Š121â”Š   â”Š     }));\n-â”Š122â”Š   â”Š\n-â”Š123â”Š   â”Š    interPoints = _.uniq(interPoints, point => `(${point.x}, ${point.y})`);\n-â”Š124â”Š   â”Š\n-â”Š125â”Š   â”Š    [this, circle].forEach(function(circle) {\n-â”Š126â”Š   â”Š      interPoints = interPoints.filter(point => circle.hasPoint(point.x, point.y));\n-â”Š127â”Š   â”Š    });\n-â”Š128â”Š   â”Š\n-â”Š129â”Š   â”Š    if (interPoints.length > 0) return interPoints;\n-â”Š130â”Š   â”Š  }\n-â”Š131â”Š   â”Š\n-â”Š132â”Š   â”Š  // circle - line intersection method\n-â”Š133â”Š   â”Š  getLineIntersection(line) {\n-â”Š134â”Š   â”Š    let x1 = line.x1 - this.x;\n-â”Š135â”Š   â”Š    let x2 = line.x2 - this.x;\n-â”Š136â”Š   â”Š    let y1 = line.y1 - this.y;\n-â”Š137â”Š   â”Š    let y2 = line.y2 - this.y;\n-â”Š138â”Š   â”Š    let dx = x2 - x1;\n-â”Š139â”Š   â”Š    let dy = y2 - y1;\n-â”Š140â”Š   â”Š    let d = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\n-â”Š141â”Š   â”Š    let h = (x1 * y2) - (x2 * y1);\n-â”Š142â”Š   â”Š    let delta = (Math.pow(this.r, 2) * Math.pow(d, 2)) - Math.pow(h, 2);\n-â”Š143â”Š   â”Š\n-â”Š144â”Š   â”Š    if (delta < 0) return;\n-â”Š145â”Š   â”Š\n-â”Š146â”Š   â”Š    let interPoints = [\n-â”Š147â”Š   â”Š      {\n-â”Š148â”Š   â”Š        x: (((h * dy) + (((dy / Math.abs(dy)) || 1) * dx * Math.sqrt(delta))) / Math.pow(d, 2)) + this.x,\n-â”Š149â”Š   â”Š        y: (((-h * dx) + (Math.abs(dy) * Math.sqrt(delta))) / Math.pow(d, 2)) + this.y\n-â”Š150â”Š   â”Š      },\n-â”Š151â”Š   â”Š      {\n-â”Š152â”Š   â”Š        x: (((h * dy) - (((dy / Math.abs(dy)) || 1) * dx * Math.sqrt(delta))) / Math.pow(d, 2)) + this.x,\n-â”Š153â”Š   â”Š        y: (((-h * dx) - (Math.abs(dy) * Math.sqrt(delta))) / Math.pow(d, 2)) + this.y\n-â”Š154â”Š   â”Š      }\n-â”Š155â”Š   â”Š    ]\n-â”Š156â”Š   â”Š    .map(point => ({\n-â”Š157â”Š   â”Š        x: Utils.trim(point.x, 9),\n-â”Š158â”Š   â”Š        y: Utils.trim(point.y, 9)\n-â”Š159â”Š   â”Š    }))\n-â”Š160â”Š   â”Š    .filter(point => {\n-â”Š161â”Š   â”Š      return this.hasPoint(point.x, point.y) &&\n-â”Š162â”Š   â”Š        line.boundsHavePoint(point.x, point.y);\n-â”Š163â”Š   â”Š    });\n-â”Š164â”Š   â”Š\n-â”Š165â”Š   â”Š    interPoints = _.uniq(interPoints, point => `(${point.x}, ${point.y})`);\n-â”Š166â”Š   â”Š\n-â”Š167â”Š   â”Š    if (interPoints.length > 0) return interPoints;\n-â”Š168â”Š   â”Š  }\n-â”Š169â”Š   â”Š\n â”Š170â”Š 16â”Š  // circle - polygon intersection method\n â”Š171â”Š 17â”Š  getPolygonIntersection(polygon) {\n â”Š172â”Š 18â”Š    return polygon.getCircleIntersection(this);\n```\n\n[}]: #\n\nWe also need to update the line class to contain a reference to the newly created line-intersection method, so it can be invoked from both a line or a circle bi-directionally:\n\n[{]: <helper> (diffStep 7.22)\n\n#### [Step 7.22: Add line-circle intersection method](https://github.com/DAB0mB/radial-snake/commit/84f5f4d)\n\n##### Changed resources&#x2F;cpp&#x2F;src&#x2F;geometry&#x2F;line.cpp\n```diff\n@@ -4,6 +4,7 @@\n â”Š 4â”Š 4â”Š#include \"../nullable.h\"\n â”Š 5â”Š 5â”Š#include \"../utils.h\"\n â”Š 6â”Š 6â”Š#include \"point.h\"\n+â”Š  â”Š 7â”Š#include \"circle.h\"\n â”Š 7â”Š 8â”Š#include \"line.h\"\n â”Š 8â”Š 9â”Š\n â”Š 9â”Š10â”Šnamespace geometry {\n```\n```diff\n@@ -100,6 +101,11 @@\n â”Š100â”Š101â”Š    return Nullable<Point>();\n â”Š101â”Š102â”Š  }\n â”Š102â”Š103â”Š\n+â”Š   â”Š104â”Š  // circle - circle intersection method\n+â”Š   â”Š105â”Š  Nullable<std::vector<Point>> Line::getIntersection(Circle circle) {\n+â”Š   â”Š106â”Š    return circle.getIntersection(*this);\n+â”Š   â”Š107â”Š  }\n+â”Š   â”Š108â”Š\n â”Š103â”Š109â”Š  emscripten::val EMLine::getMatchingX(double y) {\n â”Š104â”Š110â”Š    Nullable<double> nullableX = Line::getMatchingX(y);\n â”Š105â”Š111â”Š    return nullableX.hasValue() ?\n```\n```diff\n@@ -126,6 +132,10 @@\n â”Š126â”Š132â”Š    emPoint.set(\"y\", emscripten::val(point.y));\n â”Š127â”Š133â”Š    return emPoint;\n â”Š128â”Š134â”Š  }\n+â”Š   â”Š135â”Š\n+â”Š   â”Š136â”Š  emscripten::val EMLine::getIntersection(EMCircle emCircle) {\n+â”Š   â”Š137â”Š    return emCircle.getIntersection(*this);\n+â”Š   â”Š138â”Š  }\n â”Š129â”Š139â”Š}\n â”Š130â”Š140â”Š\n â”Š131â”Š141â”ŠEMSCRIPTEN_BINDINGS(geometry_line_module) {\n```\n```diff\n@@ -146,5 +156,10 @@\n â”Š146â”Š156â”Š      emscripten::select_overload<emscripten::val(geometry::EMLine)>(\n â”Š147â”Š157â”Š        &geometry::EMLine::getIntersection\n â”Š148â”Š158â”Š      )\n+â”Š   â”Š159â”Š    )\n+â”Š   â”Š160â”Š    .function(\"getCircleIntersection\",\n+â”Š   â”Š161â”Š      emscripten::select_overload<emscripten::val(geometry::EMCircle)>(\n+â”Š   â”Š162â”Š        &geometry::EMLine::getIntersection\n+â”Š   â”Š163â”Š      )\n â”Š149â”Š164â”Š    );\n â”Š150â”Š165â”Š}ðŸš«â†µ\n```\n\n##### Changed resources&#x2F;cpp&#x2F;src&#x2F;geometry&#x2F;line.h\n```diff\n@@ -4,6 +4,7 @@\n â”Š 4â”Š 4â”Š#include <emscripten/val.h>\n â”Š 5â”Š 5â”Š#include \"../nullable.h\"\n â”Š 6â”Š 6â”Š#include \"point.h\"\n+â”Š  â”Š 7â”Š#include \"circle.h\"\n â”Š 7â”Š 8â”Š\n â”Š 8â”Š 9â”Šnamespace geometry {\n â”Š 9â”Š10â”Š  class Circle;\n```\n```diff\n@@ -27,6 +28,8 @@\n â”Š27â”Š28â”Š    bool boundsHavePoint(double x, double y);\n â”Š28â”Š29â”Š\n â”Š29â”Š30â”Š    Nullable<Point> getIntersection(Line line);\n+â”Š  â”Š31â”Š\n+â”Š  â”Š32â”Š    Nullable<std::vector<Point>> getIntersection(Circle circle);\n â”Š30â”Š33â”Š  };\n â”Š31â”Š34â”Š\n â”Š32â”Š35â”Š  class EMLine : public Line {\n```\n```diff\n@@ -38,5 +41,7 @@\n â”Š38â”Š41â”Š    emscripten::val getMatchingY(double x);\n â”Š39â”Š42â”Š\n â”Š40â”Š43â”Š    emscripten::val getIntersection(EMLine line);\n+â”Š  â”Š44â”Š\n+â”Š  â”Š45â”Š    emscripten::val getIntersection(EMCircle circle);\n â”Š41â”Š46â”Š  };\n â”Š42â”Š47â”Š}ðŸš«â†µ\n```\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;geometry&#x2F;line.js\n```diff\n@@ -14,11 +14,6 @@\n â”Š14â”Š14â”Š      return this.getPolygonIntersection(shape);\n â”Š15â”Š15â”Š  }\n â”Š16â”Š16â”Š\n-â”Š17â”Š  â”Š  // line - circle intersection method\n-â”Š18â”Š  â”Š  getCircleIntersection(circle) {\n-â”Š19â”Š  â”Š    return circle.getLineIntersection(this);\n-â”Š20â”Š  â”Š  }\n-â”Š21â”Š  â”Š\n â”Š22â”Š17â”Š  // line - polygon intersection method\n â”Š23â”Š18â”Š  getPolygonIntersection(polygon) {\n â”Š24â”Š19â”Š    return polygon.getLineIntersection(this);\n```\n\n[}]: #\n\nNow, before running the tests, be sure to disposed unused circle test-data:\n\n[{]: <helper> (diffStep 7.23)\n\n#### [Step 7.23: Delete circle instances in tests](https://github.com/DAB0mB/radial-snake/commit/e953fae)\n\n##### Changed resources&#x2F;scripts&#x2F;specs&#x2F;engine&#x2F;geometry&#x2F;circle.js\n```diff\n@@ -3,6 +3,10 @@\n â”Š 3â”Š 3â”Š    this.circle = new Engine.Geometry.Circle(1, 1, 5, 0, 1.5 * Math.PI);\n â”Š 4â”Š 4â”Š  });\n â”Š 5â”Š 5â”Š\n+â”Š  â”Š 6â”Š  afterEach(function () {\n+â”Š  â”Š 7â”Š    this.circle.delete();\n+â”Š  â”Š 8â”Š  });\n+â”Š  â”Š 9â”Š\n â”Š 6â”Š10â”Š  describe(\"getX method\", function() {\n â”Š 7â”Š11â”Š    describe(\"given inranged rad\", function() {\n â”Š 8â”Š12â”Š      it(\"returns x\", function() {\n```\n```diff\n@@ -64,6 +68,8 @@\n â”Š64â”Š68â”Š          { x: -2, y: -3 },\n â”Š65â”Š69â”Š          { x: -2, y: 5 }\n â”Š66â”Š70â”Š        ]);\n+â”Š  â”Š71â”Š\n+â”Š  â”Š72â”Š        circle.delete();\n â”Š67â”Š73â”Š      });\n â”Š68â”Š74â”Š    });\n â”Š69â”Š75â”Š\n```\n```diff\n@@ -74,6 +80,8 @@\n â”Š74â”Š80â”Š        expect(this.circle.getCircleIntersection(circle)).toEqual([\n â”Š75â”Š81â”Š          { x: -2, y: 5 }\n â”Š76â”Š82â”Š        ]);\n+â”Š  â”Š83â”Š\n+â”Š  â”Š84â”Š        circle.delete();\n â”Š77â”Š85â”Š      });\n â”Š78â”Š86â”Š    });\n â”Š79â”Š87â”Š\n```\n```diff\n@@ -84,6 +92,8 @@\n â”Š84â”Š92â”Š        expect(this.circle.getCircleIntersection(circle)).toEqual([\n â”Š85â”Š93â”Š          { x: -4, y: 1 }\n â”Š86â”Š94â”Š        ]);\n+â”Š  â”Š95â”Š\n+â”Š  â”Š96â”Š        circle.delete();\n â”Š87â”Š97â”Š      });\n â”Š88â”Š98â”Š    });\n â”Š89â”Š99â”Š\n```\n```diff\n@@ -91,6 +101,7 @@\n â”Š 91â”Š101â”Š      it(\"returns nothing\", function() {\n â”Š 92â”Š102â”Š        let circle = new Engine.Geometry.Circle(10, 10, 2, 0, 2 * Math.PI);\n â”Š 93â”Š103â”Š        expect(this.circle.getCircleIntersection(circle)).toBeUndefined();\n+â”Š   â”Š104â”Š        circle.delete();\n â”Š 94â”Š105â”Š      });\n â”Š 95â”Š106â”Š    });\n â”Š 96â”Š107â”Š\n```\n```diff\n@@ -98,6 +109,7 @@\n â”Š 98â”Š109â”Š      it(\"nothing\", function() {\n â”Š 99â”Š110â”Š        let circle = new Engine.Geometry.Circle(1, 1, 2, 0, 2 * Math.PI);\n â”Š100â”Š111â”Š        expect(this.circle.getCircleIntersection(circle)).toBeUndefined();\n+â”Š   â”Š112â”Š        circle.delete();\n â”Š101â”Š113â”Š      });\n â”Š102â”Š114â”Š    });\n â”Š103â”Š115â”Š  });\n```\n\n##### Changed resources&#x2F;scripts&#x2F;specs&#x2F;engine&#x2F;geometry&#x2F;polygon.js\n```diff\n@@ -64,6 +64,8 @@\n â”Š64â”Š64â”Š          { x: 2, y: 0 },\n â”Š65â”Š65â”Š          { x: 0, y: 2 }\n â”Š66â”Š66â”Š        ]);\n+â”Š  â”Š67â”Š\n+â”Š  â”Š68â”Š        circle.delete();\n â”Š67â”Š69â”Š      });\n â”Š68â”Š70â”Š    });\n â”Š69â”Š71â”Š\n```\n```diff\n@@ -74,6 +76,8 @@\n â”Š74â”Š76â”Š        expect(this.polygon.getCircleIntersection(circle)).toEqual([\n â”Š75â”Š77â”Š          { x: 2, y: 0 }\n â”Š76â”Š78â”Š        ]);\n+â”Š  â”Š79â”Š\n+â”Š  â”Š80â”Š        circle.delete();\n â”Š77â”Š81â”Š      });\n â”Š78â”Š82â”Š    });\n â”Š79â”Š83â”Š\n```\n```diff\n@@ -84,6 +88,8 @@\n â”Š84â”Š88â”Š        expect(this.polygon.getCircleIntersection(circle)).toEqual([\n â”Š85â”Š89â”Š          { x: 0, y: 3 }\n â”Š86â”Š90â”Š        ]);\n+â”Š  â”Š91â”Š\n+â”Š  â”Š92â”Š        circle.delete();\n â”Š87â”Š93â”Š      });\n â”Š88â”Š94â”Š    });\n â”Š89â”Š95â”Š\n```\n```diff\n@@ -91,6 +97,7 @@\n â”Š 91â”Š 97â”Š      it(\"returns nothing\", function() {\n â”Š 92â”Š 98â”Š        let circle = new Engine.Geometry.Circle(10, 10, 2, 0, 2 * Math.PI);\n â”Š 93â”Š 99â”Š        expect(this.polygon.getCircleIntersection(circle)).toBeUndefined();\n+â”Š   â”Š100â”Š        circle.delete();\n â”Š 94â”Š101â”Š      });\n â”Š 95â”Š102â”Š    });\n â”Š 96â”Š103â”Š\n```\n```diff\n@@ -98,6 +105,7 @@\n â”Š 98â”Š105â”Š      it(\"nothing\", function() {\n â”Š 99â”Š106â”Š        let circle = new Engine.Geometry.Circle(2.5, 2.5, 2, 0, 2 * Math.PI);\n â”Š100â”Š107â”Š        expect(this.polygon.getCircleIntersection(circle)).toBeUndefined();\n+â”Š   â”Š108â”Š        circle.delete();\n â”Š101â”Š109â”Š      });\n â”Š102â”Š110â”Š    });\n â”Š103â”Š111â”Š  });\n```\n\n[}]: #\n\nOur C++ code should be finished now, and all the tests should be passing. The only thing left to do would be applying it to our game. Like any other application, we first need to reference the script file so it can be loaded, in this case, the C++ bundle script:\n\n[{]: <helper> (diffStep 7.24)\n\n#### [Step 7.24: Load CPP bundle in game](https://github.com/DAB0mB/radial-snake/commit/a2c0d46)\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -8,6 +8,7 @@\n â”Š 8â”Š 8â”Š    <script type=\"text/javascript\" src=\"/libs/underscore.js\"></script>\n â”Š 9â”Š 9â”Š\n â”Š10â”Š10â”Š    <!-- Scripts -->\n+â”Š  â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/cpp.bundle.js\"></script>\n â”Š11â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/utils.js\"></script>\n â”Š12â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/geometry/line.js\"></script>\n```\n\n[}]: #\n\nAnd now we need to make sure to dispose the geometry shapes correctly so we won't experience any unnecessary memory leaks. Most of our disposals should go to the snake entity, since it's made out of shapes; So we will add a `delete` method to the snake entity and we will dispose it whenever a match is finished:\n\n[{]: <helper> (diffStep 7.25)\n\n#### [Step 7.25: Delete shape instances in game](https://github.com/DAB0mB/radial-snake/commit/ae58323)\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;game.js\n```diff\n@@ -95,6 +95,7 @@\n â”Š 95â”Š 95â”Š  changeScreen(Screen, ...screenArgs) {\n â”Š 96â”Š 96â”Š    // If there is a screen defined, dispose it first\n â”Š 97â”Š 97â”Š    if (this.screen) {\n+â”Š   â”Š 98â”Š      this.screen.delete();\n â”Š 98â”Š 99â”Š      this.unloadScreen();\n â”Š 99â”Š100â”Š      this.screen.disposeEventListeners();\n â”Š100â”Š101â”Š    }\n```\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;layer.js\n```diff\n@@ -23,6 +23,9 @@\n â”Š23â”Š23â”Š    this.canvas = screen.game.canvas;\n â”Š24â”Š24â”Š  }\n â”Š25â”Š25â”Š\n+â”Š  â”Š26â”Š  delete() {\n+â”Š  â”Š27â”Š  }\n+â”Š  â”Š28â”Š\n â”Š26â”Š29â”Š  update(span) {\n â”Š27â”Š30â”Š  }\n â”Š28â”Š31â”Š\n```\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;screen.js\n```diff\n@@ -28,6 +28,13 @@\n â”Š28â”Š28â”Š    return this;\n â”Š29â”Š29â”Š  }\n â”Š30â”Š30â”Š\n+â”Š  â”Š31â”Š   // Delete all layers. Same as 'unload', only it disposes memory rather than assets\n+â”Š  â”Š32â”Š  delete() {\n+â”Š  â”Š33â”Š    this.layers.forEach(layer => {\n+â”Š  â”Š34â”Š      layer.delete();\n+â”Š  â”Š35â”Š    });\n+â”Š  â”Š36â”Š  }\n+â”Š  â”Š37â”Š\n â”Š31â”Š38â”Š  // Updates each layer\n â”Š32â”Š39â”Š  update(span) {\n â”Š33â”Š40â”Š    this.layers.forEach(layer => {\n```\n```diff\n@@ -61,6 +68,7 @@\n â”Š61â”Š68â”Š  removeLayer(layer) {\n â”Š62â”Š69â”Š    this.layers = _.without(this.layers, layer);\n â”Š63â”Š70â”Š    layer.disposeEventListeners();\n+â”Š  â”Š71â”Š    layer.delete();\n â”Š64â”Š72â”Š  }\n â”Š65â”Š73â”Š\n â”Š66â”Š74â”Š  initEventListeners() {\n```\n\n##### Changed resources&#x2F;scripts&#x2F;game&#x2F;entities&#x2F;snake.js\n```diff\n@@ -31,6 +31,10 @@\n â”Š31â”Š31â”Š    }\n â”Š32â”Š32â”Š  }\n â”Š33â”Š33â”Š\n+â”Š  â”Š34â”Š  delete() {\n+â”Š  â”Š35â”Š    this.shapes.forEach(shape => shape.delete());\n+â”Š  â”Š36â”Š  }\n+â”Š  â”Š37â”Š\n â”Š34â”Š38â”Š  draw(context) {\n â”Š35â”Š39â”Š    // Draw all shapes in the shapes array\n â”Š36â”Š40â”Š    this.shapes.forEach(shape => {\n```\n```diff\n@@ -229,6 +233,8 @@\n â”Š229â”Š233â”Š      [0, height, 0, 0]\n â”Š230â”Š234â”Š    );\n â”Š231â”Š235â”Š\n-â”Š232â”Š   â”Š    return canvasPolygon.getIntersection(this.lastBit);\n+â”Š   â”Š236â”Š    let result = canvasPolygon.getIntersection(this.lastBit);\n+â”Š   â”Š237â”Š    canvasPolygon.delete();\n+â”Š   â”Š238â”Š    return result;\n â”Š233â”Š239â”Š  }\n â”Š234â”Š240â”Š};ðŸš«â†µ\n```\n\n##### Changed resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;play&#x2F;snake.js\n```diff\n@@ -43,6 +43,10 @@\n â”Š43â”Š43â”Š    screen.appendLayer(Game.Screens.Play.Score, this.snakes);\n â”Š44â”Š44â”Š  }\n â”Š45â”Š45â”Š\n+â”Š  â”Š46â”Š  unload() {\n+â”Š  â”Š47â”Š    this.snakes.forEach(snake => snake.delete());\n+â”Š  â”Š48â”Š  }\n+â”Š  â”Š49â”Š\n â”Š46â”Š50â”Š  draw(context) {\n â”Š47â”Š51â”Š    // Draw each snake in the snakes array\n â”Š48â”Š52â”Š    this.snakes.forEach(snake => snake.draw(context));\n```\n\n[}]: #\n\nCongratulations! You've created a C++ cross JavaScript game. There shouldn't be any significant difference between the C++ version of the game and the JavaScript version on most machines, since the game is very small and barely requires any processing power. You'll probably notice the difference when starting to extend the game by adding terrains or more snakes.\n\nOne might ask - \"How much faster does my game actually run?\". The short answer is - around 50%. Why did I run into this conclusion? Well, take a look at the following JavaScript code snippet, for calculating Fibonacci of 42:\n\n```js\nfunction fib(x) {\n  if (x < 2) {\n    return 1;\n  }\n  else {\n    return fib(x - 1) + fib(x - 2);\n  }\n}\n```\n\nThe same code snippet should look almost identical written in C++:\n\n```cpp\nint fib(int x) {\n  if (x < 2) {\n    return 1;\n  }\n  else {\n    return fib(x - 1) + fib(x - 2);\n  }\n}\n```\n\nHowever, the run-times are completely different! I compared the average of 10 runs in 3 different environments, and I received the following results:\n\n![chart](https://cloud.githubusercontent.com/assets/7648874/22802494/2591025e-eef8-11e6-9679-10b5bca0ef30.png)\n\nAs you can see, the generated C++ is much faster, and to be precise, 57% faster! Surprisingly, I didn't have any significant difference between Emscripten generated C++ and natively compiled executable.\n\nC++ is more complex to write, but it certainly has its advantages over JavaScript. Remember, now that you know that you have the possibility to run C++ in the browser, make sure to use it, but never overdo it, always find the right balance between readability and performance.\n\n> *Sources:*\n> - *https://kripken.github.io/emscripten-site/docs/introducing_emscripten/index.html*\n> - *http://www.crunchy.com/?q=content/emscripten-perfectly-cromulent-compiler*\n> - *http://stackoverflow.com/questions/2354725/what-exactly-is-llvm*"
          }
        ]
      },
      {
        "releaseVersion": "0.1.5",
        "releaseDate": "2018-06-20 18:50:00 +0800",
        "tagName": "master@0.1.5",
        "tagRevision": "8d6fa2214280e0c1e4ccb912be7ae6b195426a67",
        "historyRevision": "487213110f946c6b181cfd665d2c98c0fc680356",
        "changesDiff": "diff --git a/package.json b/package.json\nindex 8b27d5a..a927901 100644\n--- a/package.json\n+++ b/package.json\n@@ -1,6 +1,10 @@\n {\n   \"name\": \"radial-snake\",\n   \"description\": \"A tutorial for creating a Tron-style game\",\n+  \"repository\": {\n+    \"type\": \"git\",\n+    \"url\": \"https://DAB0mB@github.com/DAB0mB/radial-snake.git\"\n+  },\n   \"private\": true,\n   \"scripts\": {\n     \"serve\": \"npm run build && nodemon server.js\",\n",
        "manuals": [
          {
            "manualTitle": "How to implement a game engine in JavaScript and build a Tron-style game",
            "stepRevision": "08b88f5a9d7b2d3ba4c8a67a1433218ef6a6a3a5",
            "manualView": "![snake-demo-full-small](https://cloud.githubusercontent.com/assets/7648874/21073892/ae331a8a-bed2-11e6-9141-9554f9bb808b.gif)\n\nThis tutorial will guide you through the following steps:\n\n- [**Step 1**](https://github.com/DAB0mB/radial-snake/blob/master/.tortilla/manuals/views/step1.md) - Creating a server\n- [**Step 2**](https://github.com/DAB0mB/radial-snake/blob/master/.tortilla/manuals/views/step2.md) - Creating a game engine basis\n- [**Step 3**](https://github.com/DAB0mB/radial-snake/blob/master/.tortilla/manuals/views/step3.md) - Creating a splash screen using a keyframe animation engine\n- [**Step 4**](https://github.com/DAB0mB/radial-snake/blob/master/.tortilla/manuals/views/step4.md) - Creating a main menu screen using a font engine\n- [**Step 5**](https://github.com/DAB0mB/radial-snake/blob/master/.tortilla/manuals/views/step5.md) - Creating a snake and related geometry shapes\n- [**Step 6**](https://github.com/DAB0mB/radial-snake/blob/master/.tortilla/manuals/views/step6.md) - Creating a complex game screen with multiple layers\n- [**Step 7**](https://github.com/DAB0mB/radial-snake/blob/master/.tortilla/manuals/views/step7.md) - Bonus! Re-implementing geometry in C++\n\nMake sure you have the following software installed:\n\n- NodeJS with an ECMAScript 2015 support (v6.0.0 and above).\n- Any web-browser which supports ECMAScript 2015, with a preference for Google Chrome.\n\n> The final project is a hybrid of C++ and JavaScript. A JavaScript **only** version of this tutorial is available [here](https://github.com/DAB0mB/radial-snake/tree/master%40step6%400.1.3).\n\nThis tutorial is mostly based on pure JavaScript, so people can have a deeper understanding of the language and its dynamics. In addition, this tutorial makes a great practice on how to build a nice architecture for complex systems, which can then be expanded and maintained with ease. Yes, it is specifically designed for games, but I truly believe that video games can easily get messed up if not planned and designed properly in terms of object oriented relationships. They are naturally more complicated then any web-app you gonna see out there, so if you can create a game engine and understand its flow, creating a web-app would be a piece of cake for you. By the end of this tutorial, your general sense for programming should be enhanced greatly.\n\nSo hopefully that I got you pumped up by now, let's get started!"
          },
          {
            "manualTitle": "Step 1: Creating a server",
            "stepRevision": "1aed2194c509617dbe79447e2615aa34728262bc",
            "manualView": "The first thing we will learn to do would be creating a server so we can serve our assets. We will be using [HapiJS](https://hapijs.com/) to build a REST API, although this step can be implemented with any library you'd want, like [ExpressJS](http://expressjs.com/) or [Connect](https://www.senchalabs.github.com/connect) etc. Let's install it then:\n\n    $ npm install hapi --save\n\nWe will start by setting up a basis for our server, and we will expand it as we go further in this step. A general boiler plate should look like so:\n\n[{]: <helper> (diffStep 1.2)\n\n#### [Step 1.2: Add server basis](https://github.com/DAB0mB/radial-snake/commit/8ff8805)\n\n##### Added server.js\n```diff\n@@ -0,0 +1,36 @@\n+â”Š  â”Š 1â”Šconst Hapi = require(\"hapi\");\n+â”Š  â”Š 2â”Š\n+â”Š  â”Š 3â”Šlet port = 8000;\n+â”Š  â”Š 4â”Š\n+â”Š  â”Š 5â”Š// Initialize a new server\n+â”Š  â”Š 6â”Šlet server = new Hapi.Server();\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Šserver.connection({ port: process.env.PORT || port });\n+â”Š  â”Š 9â”Š\n+â”Š  â”Š10â”Š// Report each response made\n+â”Š  â”Š11â”Šserver.ext(\"onPreResponse\", (req, rep) => {\n+â”Š  â”Š12â”Š  let res = req.response;\n+â”Š  â”Š13â”Š\n+â”Š  â”Š14â”Š  console.log(\"Outcoming response:\");\n+â”Š  â”Š15â”Š  console.log(`in: ${new Date}`);\n+â”Š  â”Š16â”Š  console.log(`to: ${req.info.remoteAddress}`);\n+â”Š  â”Š17â”Š  console.log(`method: ${req.method}`);\n+â”Š  â”Š18â”Š  console.log(`url: ${req.url.path}`);\n+â”Š  â”Š19â”Š  console.log(`status: ${res.statusCode || res.output.statusCode}`);\n+â”Š  â”Š20â”Š  console.log();\n+â”Š  â”Š21â”Š\n+â”Š  â”Š22â”Š  rep.continue();\n+â”Š  â”Š23â”Š});\n+â”Š  â”Š24â”Š\n+â”Š  â”Š25â”Š// Print message once started\n+â”Š  â”Š26â”Šserver.start((err) => {\n+â”Š  â”Š27â”Š  if (err) throw err;\n+â”Š  â”Š28â”Š\n+â”Š  â”Š29â”Š  console.log();\n+â”Š  â”Š30â”Š  console.log(\"---------- -------- ------ ---- --\");\n+â”Š  â”Š31â”Š  console.log(\"----- ---- --- -- -\");\n+â”Š  â”Š32â”Š  console.log(`Server running at ${port}`);\n+â”Š  â”Š33â”Š  console.log(\"----- ---- --- -- -\");\n+â”Š  â”Š34â”Š  console.log(\"---------- -------- ------ ---- --\");\n+â”Š  â”Š35â”Š  console.log();\n+â”Š  â”Š36â”Š});ðŸš«â†µ\n```\n\n[}]: #\n\nWe simply initialize a new server which will connect to port `8000` by default, unless we defined an environment variable called `PORT`. Once the server is started, and whenever there is an outcoming response, a message will be printed to the console.\n\n> More information and configuration options regards HapiJS's API can be found in this [here](https://hapijs.com/).\n\nNow that the basis is ready, we want a convenient way to launch it. Repetitive scripts are usually defined in the `package.json` file under the `scripts` field. To start the server, we gonna create a simple script called `serve`:\n\n[{]: <helper> (diffStep 1.3)\n\n#### [Step 1.3: Add serve npm script](https://github.com/DAB0mB/radial-snake/commit/6e7d691)\n\n##### Changed package.json\n```diff\n@@ -6,6 +6,9 @@\n â”Š 6â”Š 6â”Š    \"url\": \"https://DAB0mB@github.com/DAB0mB/radial-snake.git\"\n â”Š 7â”Š 7â”Š  },\n â”Š 8â”Š 8â”Š  \"private\": true,\n+â”Š  â”Š 9â”Š  \"scripts\": {\n+â”Š  â”Š10â”Š    \"serve\": \"node server.js\"\n+â”Š  â”Š11â”Š  },\n â”Š 9â”Š12â”Š  \"dependencies\": {\n â”Š10â”Š13â”Š    \"hapi\": \"^16.0.1\"\n â”Š11â”Š14â”Š  }\n```\n\n[}]: #\n\nTo run this script, we will simply need to type the following:\n\n    $ npm run serve\n\nThis will run our server, and you should see the following message printed to the console:\n\n```\n---------- -------- ------ ---- --\n----- ---- --- -- -\nServer running at 8000\n----- ---- --- -- -\n---------- -------- ------ ---- --\n```\n\n> As for now, nothing happens, because we didn't define any handlers for HTTP requests. I will get to it in a bit, stay with me.\n\nThe main disadvantage of starting a server directly with node is that we have no listeners for changes in our files, so if we want the served files to be updated, we will have to restart our server anytime we make a change. To avoid that, we gonna use [nodemon](https://nodemon.io/), which is a simple utility that can monitor changes is source files and automatically restart our server. To install it, type the following:\n\n    $ sudo npm install nodemon -g\n\nNow that we have it, we will need to update our `serve` npm script to use `nodemon` instead of `node`:\n\n[{]: <helper> (diffStep 1.4)\n\n#### [Step 1.4: Change serve npm script to use nodemon](https://github.com/DAB0mB/radial-snake/commit/a238294)\n\n##### Changed package.json\n```diff\n@@ -7,7 +7,7 @@\n â”Š 7â”Š 7â”Š  },\n â”Š 8â”Š 8â”Š  \"private\": true,\n â”Š 9â”Š 9â”Š  \"scripts\": {\n-â”Š10â”Š  â”Š    \"serve\": \"node server.js\"\n+â”Š  â”Š10â”Š    \"serve\": \"nodemon server.js\"\n â”Š11â”Š11â”Š  },\n â”Š12â”Š12â”Š  \"dependencies\": {\n â”Š13â”Š13â”Š    \"hapi\": \"^16.0.1\"\n```\n\n[}]: #\n\nThe basis for our server is pretty much complete. From now on we gonna build stuff on top of it and extend our server. I'd like to add a small attachment to our server. I want that the IP address of the current computer will be printed to the console once the server is started. For this, we first gonna create a helper which we gonna call `ip_grabber`:\n\n[{]: <helper> (diffStep 1.5)\n\n#### [Step 1.5: Add ip_grabber helper](https://github.com/DAB0mB/radial-snake/commit/8ff1d1c)\n\n##### Added helpers&#x2F;ip_grabber.js\n```diff\n@@ -0,0 +1,23 @@\n+â”Š  â”Š 1â”Šconst Os = require(\"os\");\n+â”Š  â”Š 2â”Š\n+â”Š  â”Š 3â”Š// Grab local IP address of which the NodeJS process runs on\n+â”Š  â”Š 4â”Šfunction local() {\n+â”Š  â”Š 5â”Š  let interfaces = Os.networkInterfaces();\n+â”Š  â”Š 6â”Š  let addresses = [];\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Š  for (let k in interfaces) {\n+â”Š  â”Š 9â”Š    for (let k2 in interfaces[k]) {\n+â”Š  â”Š10â”Š      let address = interfaces[k][k2];\n+â”Š  â”Š11â”Š\n+â”Š  â”Š12â”Š      if (address.family == \"IPv4\" && !address.internal) {\n+â”Š  â”Š13â”Š        addresses.push(address.address);\n+â”Š  â”Š14â”Š      }\n+â”Š  â”Š15â”Š    }\n+â”Š  â”Š16â”Š  }\n+â”Š  â”Š17â”Š\n+â”Š  â”Š18â”Š  return addresses[0];\n+â”Š  â”Š19â”Š}\n+â”Š  â”Š20â”Š\n+â”Š  â”Š21â”Šmodule.exports = {\n+â”Š  â”Š22â”Š  local\n+â”Š  â”Š23â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nThis module simply goes through the available network interfaces and grabs the IP address of the default gateway using the `os` module. Now that we have it, let's import it in the server's entry file and use the `local` method to grab the IP address and report it once the server is started:\n\n[{]: <helper> (diffStep 1.6)\n\n#### [Step 1.6: Print IP address once server is started](https://github.com/DAB0mB/radial-snake/commit/18ed984)\n\n##### Changed server.js\n```diff\n@@ -1,5 +1,7 @@\n â”Š1â”Š1â”Šconst Hapi = require(\"hapi\");\n+â”Š â”Š2â”Šconst IpGrabber = require(\"./helpers/ip_grabber\");\n â”Š2â”Š3â”Š\n+â”Š â”Š4â”Šlet localIp = IpGrabber.local();\n â”Š3â”Š5â”Šlet port = 8000;\n â”Š4â”Š6â”Š\n â”Š5â”Š7â”Š// Initialize a new server\n```\n```diff\n@@ -29,7 +31,7 @@\n â”Š29â”Š31â”Š  console.log();\n â”Š30â”Š32â”Š  console.log(\"---------- -------- ------ ---- --\");\n â”Š31â”Š33â”Š  console.log(\"----- ---- --- -- -\");\n-â”Š32â”Š  â”Š  console.log(`Server running at ${port}`);\n+â”Š  â”Š34â”Š  console.log(`Server running at ${localIp}:${port}`);\n â”Š33â”Š35â”Š  console.log(\"----- ---- --- -- -\");\n â”Š34â”Š36â”Š  console.log(\"---------- -------- ------ ---- --\");\n â”Š35â”Š37â”Š  console.log();\n```\n\n[}]: #\n\nBy now you should have the following message printed to the console once you start the server:\n\n```\n---------- -------- ------ ---- --\n----- ---- --- -- -\nServer running at 95.221.122.30:8000\n----- ---- --- -- -\n---------- -------- ------ ---- --\n```\n\n> Instead of `95.221.122.30` you should have the IP address which is right for you.\n\nNow comes the most important part - handling HTTP requests! Because what does a server worth if it doesn't know how to handle anything? When using `HapiJS`, we can separate extensions to our server in different modules, and eventually register them as plug-ins. So the first plug-in is gonna be the routes batch for the endpoints - it will take care of serving file requests as is, and basically turning local directories into public ones. This is useful because our game is going to be dependent on many assets like textures, images, fonts, and so on... But before I go into the implementation part we first need to install a couple of libraries which will help us with the task. The first one is going to be `async`, which will take care of managing the control flow of asynchronous code:\n\n    $ npm install async --save\n\nAnd the second library is going to be `inert`, which is a `HapiJS` plug-in which will give us the ability to serve files from local directories:\n\n    $ npm install inert --save\n\nNow that we're set, let's implement the `endpoints` routes batch:\n\n[{]: <helper> (diffStep 1.8)\n\n#### [Step 1.8: Add endpoints routes](https://github.com/DAB0mB/radial-snake/commit/9c22408)\n\n##### Added routes&#x2F;endpoints.js\n```diff\n@@ -0,0 +1,80 @@\n+â”Š  â”Š 1â”Šconst Pack = require(\"../package.json\");\n+â”Š  â”Š 2â”Š\n+â”Š  â”Š 3â”Šregister.attributes = {\n+â”Š  â”Š 4â”Š  name: \"endpoints\",\n+â”Š  â”Š 5â”Š  version: Pack.version\n+â”Š  â”Š 6â”Š};\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Šfunction register(server, options, next) {\n+â”Š  â”Š 9â”Š  // Scripts endpoint\n+â”Š  â”Š10â”Š  server.route({\n+â”Š  â”Š11â”Š    method: \"GET\",\n+â”Š  â”Š12â”Š    path: \"/scripts/{path*}\",\n+â”Š  â”Š13â”Š    handler: {\n+â”Š  â”Š14â”Š      directory: {\n+â”Š  â”Š15â”Š        path: \"./resources/scripts/\"\n+â”Š  â”Š16â”Š      }\n+â”Š  â”Š17â”Š    }\n+â”Š  â”Š18â”Š  });\n+â”Š  â”Š19â”Š\n+â”Š  â”Š20â”Š  // Style-sheets endpoint\n+â”Š  â”Š21â”Š  server.route({\n+â”Š  â”Š22â”Š    method: \"GET\",\n+â”Š  â”Š23â”Š    path: \"/styles/{path*}\",\n+â”Š  â”Š24â”Š    handler: {\n+â”Š  â”Š25â”Š      directory: {\n+â”Š  â”Š26â”Š        path: \"./resources/styles/\"\n+â”Š  â”Š27â”Š      }\n+â”Š  â”Š28â”Š    }\n+â”Š  â”Š29â”Š  });\n+â”Š  â”Š30â”Š\n+â”Š  â”Š31â”Š  // Libraries endpoint\n+â”Š  â”Š32â”Š  server.route({\n+â”Š  â”Š33â”Š    method: \"GET\",\n+â”Š  â”Š34â”Š    path: \"/libs/{path*}\",\n+â”Š  â”Š35â”Š    handler: {\n+â”Š  â”Š36â”Š      directory: {\n+â”Š  â”Š37â”Š        path: \"./resources/libs/\"\n+â”Š  â”Š38â”Š      }\n+â”Š  â”Š39â”Š    }\n+â”Š  â”Š40â”Š  });\n+â”Š  â”Š41â”Š\n+â”Š  â”Š42â”Š  // Images endpoint\n+â”Š  â”Š43â”Š  server.route({\n+â”Š  â”Š44â”Š    method: \"GET\",\n+â”Š  â”Š45â”Š    path: \"/images/{path*}\",\n+â”Š  â”Š46â”Š    handler: {\n+â”Š  â”Š47â”Š      directory: {\n+â”Š  â”Š48â”Š        path: \"./resources/images/\"\n+â”Š  â”Š49â”Š      }\n+â”Š  â”Š50â”Š    }\n+â”Š  â”Š51â”Š  });\n+â”Š  â”Š52â”Š\n+â”Š  â”Š53â”Š  // Textures endpoint\n+â”Š  â”Š54â”Š  server.route({\n+â”Š  â”Š55â”Š    method: \"GET\",\n+â”Š  â”Š56â”Š    path: \"/textures/{path*}\",\n+â”Š  â”Š57â”Š    handler: {\n+â”Š  â”Š58â”Š      directory: {\n+â”Š  â”Š59â”Š        path: \"./resources/assets/textures/\"\n+â”Š  â”Š60â”Š      }\n+â”Š  â”Š61â”Š    }\n+â”Š  â”Š62â”Š  });\n+â”Š  â”Š63â”Š\n+â”Š  â”Š64â”Š  // Fonts endpoint\n+â”Š  â”Š65â”Š  server.route({\n+â”Š  â”Š66â”Š    method: \"GET\",\n+â”Š  â”Š67â”Š    path: \"/fonts/{path*}\",\n+â”Š  â”Š68â”Š    handler: {\n+â”Š  â”Š69â”Š      directory: {\n+â”Š  â”Š70â”Š        path: \"./resources/assets/fonts/\"\n+â”Š  â”Š71â”Š      }\n+â”Š  â”Š72â”Š    }\n+â”Š  â”Š73â”Š  });\n+â”Š  â”Š74â”Š\n+â”Š  â”Š75â”Š  next();\n+â”Š  â”Š76â”Š}\n+â”Š  â”Š77â”Š\n+â”Š  â”Š78â”Šmodule.exports = {\n+â”Š  â”Š79â”Š  register\n+â”Š  â”Š80â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nThis module actually represents a classic structure of a `HapiJS` plug-in. It should export a `name` for debugging proposes, a `version`, and a `register` function, which will take care of registering extensions to our server; in this case, these are the endpoints routes. To make this plug-in (Or any other plug-in) work, we need to register it. The registration is an asynchronous operation, thus we gonna handle it using `async`:\n\n[{]: <helper> (diffStep 1.9)\n\n#### [Step 1.9: Register ednpoints routes](https://github.com/DAB0mB/radial-snake/commit/bba460f)\n\n##### Changed server.js\n```diff\n@@ -1,11 +1,23 @@\n+â”Š  â”Š 1â”Šconst Async = require(\"async\");\n â”Š 1â”Š 2â”Šconst Hapi = require(\"hapi\");\n+â”Š  â”Š 3â”Šconst Inert = require(\"inert\");\n+â”Š  â”Š 4â”Šconst Endpoints = require(\"./routes/endpoints\");\n â”Š 2â”Š 5â”Šconst IpGrabber = require(\"./helpers/ip_grabber\");\n â”Š 3â”Š 6â”Š\n â”Š 4â”Š 7â”Šlet localIp = IpGrabber.local();\n â”Š 5â”Š 8â”Šlet port = 8000;\n â”Š 6â”Š 9â”Š\n â”Š 7â”Š10â”Š// Initialize a new server\n-â”Š 8â”Š  â”Šlet server = new Hapi.Server();\n+â”Š  â”Š11â”Šlet server = new Hapi.Server({\n+â”Š  â”Š12â”Š  connections: {\n+â”Š  â”Š13â”Š    routes: {\n+â”Š  â”Š14â”Š      files: {\n+â”Š  â”Š15â”Š        // Served files will be relative to current directory\n+â”Š  â”Š16â”Š        relativeTo: __dirname\n+â”Š  â”Š17â”Š      }\n+â”Š  â”Š18â”Š    }\n+â”Š  â”Š19â”Š  }\n+â”Š  â”Š20â”Š});\n â”Š 9â”Š21â”Š\n â”Š10â”Š22â”Šserver.connection({ port: process.env.PORT || port });\n â”Š11â”Š23â”Š\n```\n```diff\n@@ -24,8 +36,14 @@\n â”Š24â”Š36â”Š  rep.continue();\n â”Š25â”Š37â”Š});\n â”Š26â”Š38â”Š\n+â”Š  â”Š39â”Š// Register all routes and plug-ins\n+â”Š  â”Š40â”ŠAsync.series([\n+â”Š  â”Š41â”Š  next => server.register(Inert, next),\n+â”Š  â”Š42â”Š  next => server.register(Endpoints, next),\n+â”Š  â”Š43â”Š  // Once registrations are finished, start the server\n+â”Š  â”Š44â”Š  next => server.start(next)\n â”Š27â”Š45â”Š// Print message once started\n-â”Š28â”Š  â”Šserver.start((err) => {\n+â”Š  â”Š46â”Š], (err) => {\n â”Š29â”Š47â”Š  if (err) throw err;\n â”Š30â”Š48â”Š\n â”Š31â”Š49â”Š  console.log();\n```\n\n[}]: #\n\nOnce all the plug-ins have been registered, we gonna start our server as we previously did. Note that we also registered the `inert` plug-in, because as I said earlier, that's what gives us the ability to handle files requests.\n\nLastly, I want to create the `pages` routes batch, which will be responsible for serving pages in our application as listed above:\n\n- The `/` route will serve us the `game.html` file.\n- The `/test` route will serve us the `spec_runner.html` file.\n\nBy the name of each route and file you can probably what each one should do. The thing is, we don't want everyone to be able to access the `spec_runner.html` file, or the `game.html` file if in the middle of development. For this, we're going to create a new helper which will be responsible for handling permissions. So first we gonna install an npm package called `boom` which has the ability to format `permission denied` HTTP errors:\n\n    $ npm install boom --save\n\nAnd now we gonna implement the module itself:\n\n[{]: <helper> (diffStep 1.11)\n\n#### [Step 1.11: Add permitter helper](https://github.com/DAB0mB/radial-snake/commit/d26a5d7)\n\n##### Added helpers&#x2F;permitter.js\n```diff\n@@ -0,0 +1,29 @@\n+â”Š  â”Š 1â”Šconst Boom = require(\"boom\");\n+â”Š  â”Š 2â”Šconst Hapi = require(\"hapi\");\n+â”Š  â”Š 3â”Šconst IpGrabber = require(\"./ip_grabber\");\n+â”Š  â”Š 4â”Š\n+â”Š  â”Š 5â”Š// These addresses will be permitted by default\n+â”Š  â”Š 6â”Šconst defaultPermissions = [\n+â”Š  â”Š 7â”Š  IpGrabber.local(), \"127.0.0.1\", \"localhost\"\n+â”Š  â”Š 8â”Š];\n+â”Š  â”Š 9â”Š\n+â”Š  â”Š10â”Š// Manage file permissions\n+â”Š  â”Š11â”Šfunction file(path, permissions, req, rep) {\n+â”Š  â”Š12â”Š  // Apply default permissions\n+â”Š  â”Š13â”Š  permissions = permissions.concat(defaultPermissions);\n+â”Š  â”Š14â”Š  // Request address\n+â”Š  â”Š15â”Š  let remoteAddress = req.info.remoteAddress;\n+â”Š  â”Š16â”Š\n+â”Š  â”Š17â”Š  // If not permitted, reply error\n+â”Š  â”Š18â”Š  if (permissions.indexOf(remoteAddress) == -1) {\n+â”Š  â”Š19â”Š    let err = new Boom.forbidden(\"Missing permissions\");\n+â”Š  â”Š20â”Š    return rep(err);\n+â”Š  â”Š21â”Š  }\n+â”Š  â”Š22â”Š\n+â”Š  â”Š23â”Š  // If permitted, reply file\n+â”Š  â”Š24â”Š  rep.file(path);\n+â”Š  â”Š25â”Š}\n+â”Š  â”Š26â”Š\n+â”Š  â”Š27â”Šmodule.exports = {\n+â”Š  â”Š28â”Š  file\n+â”Š  â”Š29â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nThe default permitted IP address would be the current computer's IP address. Extra IP permissions can be provided with the invocation of the `file` method. If the requesting IP is not listed in the permissions list, an error is gonna be replied instead of the requested file. Now that we have our \"permitter\" ready, let's implement the `pages` routes batch, only we're gonna pass the requests through the black-list, for the reason mentioned above:\n\n[{]: <helper> (diffStep 1.12)\n\n#### [Step 1.12: Add pages routes](https://github.com/DAB0mB/radial-snake/commit/11860e9)\n\n##### Added routes&#x2F;pages.js\n```diff\n@@ -0,0 +1,35 @@\n+â”Š  â”Š 1â”Šconst Hapi = require(\"hapi\");\n+â”Š  â”Š 2â”Šconst Pack = require(\"../package.json\");\n+â”Š  â”Š 3â”Šconst Permitter = require(\"../helpers/permitter\");\n+â”Š  â”Š 4â”Š\n+â”Š  â”Š 5â”Šregister.attributes = {\n+â”Š  â”Š 6â”Š  name: \"pages\",\n+â”Š  â”Š 7â”Š  version: Pack.version\n+â”Š  â”Š 8â”Š};\n+â”Š  â”Š 9â”Š\n+â”Š  â”Š10â”Šfunction register(server, options, next) {\n+â”Š  â”Š11â”Š  server.route({ method: \"GET\", path: \"/\", handler: getGame });\n+â”Š  â”Š12â”Š  server.route({ method: \"GET\", path: \"/test\", handler: getSpecRunner });\n+â”Š  â”Š13â”Š\n+â”Š  â”Š14â”Š  next();\n+â”Š  â”Š15â”Š}\n+â”Š  â”Š16â”Š\n+â”Š  â”Š17â”Š// Serve game page\n+â”Š  â”Š18â”Šfunction getGame(req, rep) {\n+â”Š  â”Š19â”Š  let path = \"./views/game.html\";\n+â”Š  â”Š20â”Š  let permissions = [];\n+â”Š  â”Š21â”Š\n+â”Š  â”Š22â”Š  Permitter.file(path, permissions, req, rep);\n+â”Š  â”Š23â”Š}\n+â”Š  â”Š24â”Š\n+â”Š  â”Š25â”Š// Serve test page\n+â”Š  â”Š26â”Šfunction getSpecRunner(req, rep) {\n+â”Š  â”Š27â”Š  let path = \"./views/spec_runner.html\";\n+â”Š  â”Š28â”Š  let permissions = [];\n+â”Š  â”Š29â”Š\n+â”Š  â”Š30â”Š  Permitter.file(path, permissions, req, rep);\n+â”Š  â”Š31â”Š}\n+â”Š  â”Š32â”Š\n+â”Š  â”Š33â”Šmodule.exports = {\n+â”Š  â”Š34â”Š  register\n+â”Š  â”Š35â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nNow the only thing left to do would be registering the plug-in we've just created:\n\n[{]: <helper> (diffStep 1.13)\n\n#### [Step 1.13: Register pages routes](https://github.com/DAB0mB/radial-snake/commit/ed50bef)\n\n##### Changed server.js\n```diff\n@@ -2,6 +2,7 @@\n â”Š2â”Š2â”Šconst Hapi = require(\"hapi\");\n â”Š3â”Š3â”Šconst Inert = require(\"inert\");\n â”Š4â”Š4â”Šconst Endpoints = require(\"./routes/endpoints\");\n+â”Š â”Š5â”Šconst Pages = require(\"./routes/pages\");\n â”Š5â”Š6â”Šconst IpGrabber = require(\"./helpers/ip_grabber\");\n â”Š6â”Š7â”Š\n â”Š7â”Š8â”Šlet localIp = IpGrabber.local();\n```\n```diff\n@@ -40,6 +41,7 @@\n â”Š40â”Š41â”ŠAsync.series([\n â”Š41â”Š42â”Š  next => server.register(Inert, next),\n â”Š42â”Š43â”Š  next => server.register(Endpoints, next),\n+â”Š  â”Š44â”Š  next => server.register(Pages, next),\n â”Š43â”Š45â”Š  // Once registrations are finished, start the server\n â”Š44â”Š46â”Š  next => server.start(next)\n â”Š45â”Š47â”Š// Print message once started\n```\n\n[}]: #\n\nAnd that's it for the current step! In the next steps we will start storing files and assets in our public directories and implement all the necessary scripts, so our server is not running in vain."
          },
          {
            "manualTitle": "Step 2: Creating a game engine basis",
            "stepRevision": "a3e901039dc5db535111da14305175182f9f346c",
            "manualView": "Like any other JavaScript-based application, we should have an entry view written in HTML. However, in our application, the only visible element is going to be an [HTMLCanvas](https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API). The canvas is exactly what it sounds like - a blank white surface which we can draw things on top of it. As we go further with this tutorial, we will learn more about the canvas and dive into its API and how to use it. Now that you got the general idea, let's create the HTML file:\n\n[{]: <helper> (diffStep 2.1)\n\n#### [Step 2.1: Create basic game view](https://github.com/DAB0mB/radial-snake/commit/254f06f)\n\n##### Added views&#x2F;game.html\n```diff\n@@ -0,0 +1,10 @@\n+â”Š  â”Š 1â”Š<!DOCTYPE html>\n+â”Š  â”Š 2â”Š<html>\n+â”Š  â”Š 3â”Š  <head>\n+â”Š  â”Š 4â”Š    <title>radial snake</title>\n+â”Š  â”Š 5â”Š  </head>\n+â”Š  â”Š 6â”Š\n+â”Š  â”Š 7â”Š  <body>\n+â”Š  â”Š 8â”Š    <canvas id=\"gameCanvas\" tabindex=\"0\"></canvas>\n+â”Š  â”Š 9â”Š  </body>\n+â”Š  â”Š10â”Š</html>ðŸš«â†µ\n```\n\n[}]: #\n\nIn the previous step we've already set the route for this file, so if you'd like to run the game, simply start the server by typing `npm run serve`, and navigate to the address presented on the screen (Should be `localhost:8000` by default).\n\n> From now on I'm going to assume the server is running in the background, so I won't repeat the instruction above\n\nJust to make sure that the canvas is visible and not blended into the background, we will draw a black border around using a simple style-sheet:\n\n[{]: <helper> (diffStep 2.2)\n\n#### [Step 2.2: Create basic game stylesheet](https://github.com/DAB0mB/radial-snake/commit/44fe5aa)\n\n##### Added resources&#x2F;styles&#x2F;game.css\n```diff\n@@ -0,0 +1,6 @@\n+â”Š â”Š1â”Š#gameCanvas {\n+â”Š â”Š2â”Š  display: block;\n+â”Š â”Š3â”Š  margin: auto;\n+â”Š â”Š4â”Š  border-style: solid;\n+â”Š â”Š5â”Š  border-width: 1px;\n+â”Š â”Š6â”Š}ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -2,6 +2,9 @@\n â”Š 2â”Š 2â”Š<html>\n â”Š 3â”Š 3â”Š  <head>\n â”Š 4â”Š 4â”Š    <title>radial snake</title>\n+â”Š  â”Š 5â”Š\n+â”Š  â”Š 6â”Š    <!-- Styles -->\n+â”Š  â”Š 7â”Š    <link rel=\"stylesheet\" type=\"text/css\" href=\"/styles/game.css\">\n â”Š 5â”Š 8â”Š  </head>\n â”Š 6â”Š 9â”Š\n â”Š 7â”Š10â”Š  <body>\n```\n\n[}]: #\n\n> Note that every asset we create should be declared in the HTML file in order for it to take effect\n\nTo build this project we're also gonna use two very famous utility libraries called [JQuery](http://jquery.com/) and [Underscore](http://underscorejs.org/) which will make our lives a bit easier. Third-party libraries should be located in a directory called `libs`, according to the routes-map we created in the previous step. To set these libraries up, type the following commands in series:\n\n    resources$ mkdir libs\n    resources$ cd libs\n    resources/libs$ wget raw.githubusercontent.com/dab0mb/radial-snake/master/resources/libs/underscore.js\n    resources/libs$ wget raw.githubusercontent.com/dab0mb/radial-snake/master/resources/libs/jquery-2.1.1.js\n\nAnd load them in the game's HTML file's header:\n\n[{]: <helper> (diffStep 2.3 files=\"views/game.html\")\n\n#### [Step 2.3: Add jquery and underscore libs](https://github.com/DAB0mB/radial-snake/commit/085ca6b)\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -3,6 +3,10 @@\n â”Š 3â”Š 3â”Š  <head>\n â”Š 4â”Š 4â”Š    <title>radial snake</title>\n â”Š 5â”Š 5â”Š\n+â”Š  â”Š 6â”Š    <!-- Libs -->\n+â”Š  â”Š 7â”Š    <script type=\"text/javascript\" src=\"/libs/jquery-2.1.1.js\"></script>\n+â”Š  â”Š 8â”Š    <script type=\"text/javascript\" src=\"/libs/underscore.js\"></script>\n+â”Š  â”Š 9â”Š\n â”Š 6â”Š10â”Š    <!-- Styles -->\n â”Š 7â”Š11â”Š    <link rel=\"stylesheet\" type=\"text/css\" href=\"/styles/game.css\">\n â”Š 8â”Š12â”Š  </head>\n```\n\n[}]: #\n\nNow, we're finally going to build the game engine. At first, it's gonna be very basic simple, but further in this tutorial we're going to extend it and add some pretty neat features. When creating an application, of any kind, you don't want to garbage the global scope, so it can stay clean without any conflicts. Therefore, we're going to create an initial namespace for our game engine called `Engine`, which is going to contain all our game engine's classes and entities:\n\n[{]: <helper> (diffStep 2.4)\n\n#### [Step 2.4: Add engine namespace](https://github.com/DAB0mB/radial-snake/commit/3d52525)\n\n##### Added resources&#x2F;scripts&#x2F;namespaces.js\n```diff\n@@ -0,0 +1 @@\n+â”Š â”Š1â”ŠEngine = {};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -7,6 +7,9 @@\n â”Š 7â”Š 7â”Š    <script type=\"text/javascript\" src=\"/libs/jquery-2.1.1.js\"></script>\n â”Š 8â”Š 8â”Š    <script type=\"text/javascript\" src=\"/libs/underscore.js\"></script>\n â”Š 9â”Š 9â”Š\n+â”Š  â”Š10â”Š    <!-- Scripts -->\n+â”Š  â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n+â”Š  â”Š12â”Š\n â”Š10â”Š13â”Š    <!-- Styles -->\n â”Š11â”Š14â”Š    <link rel=\"stylesheet\" type=\"text/css\" href=\"/styles/game.css\">\n â”Š12â”Š15â”Š  </head>\n```\n\n[}]: #\n\nThe first thing we're going to define in the namespace we've just created would be the game loop. The game loop is the central code of your game, split into different parts. Generally, these are: update and draw.\n\nThe main purpose of the update phase is to prepare all objects to be drawn, so this is where all the geometry code, coordinate updates, score changes, animation refreshments and other similar operations belong. This is also where the input will be captured and processed.\n\nWhen everything is properly updated and ready, we enter the draw phase where all this information is put on the screen. This function should contain all the code to manage and draw the levels, shapes, score board and so on.\n\n![game-loop](https://cloud.githubusercontent.com/assets/7648874/21332964/4b80ef4e-c633-11e6-946a-0c5870d2f9c9.png)\n\n> You can find plenty of details and information about what \"game loop\" means simply by typing in on Google.\n\nA game loop can wear many forms, but the concept is gonna be the same, plus-minus. This is how our game loop is going to loop like:\n\n[{]: <helper> (diffStep 2.5)\n\n#### [Step 2.5: Create a game basis](https://github.com/DAB0mB/radial-snake/commit/1b7fcf9)\n\n##### Added resources&#x2F;scripts&#x2F;engine&#x2F;game.js\n```diff\n@@ -0,0 +1,99 @@\n+â”Š  â”Š 1â”ŠEngine.Game = class Game {\n+â”Š  â”Š 2â”Š  // The frequency of which each frame will be drawn in milliseconds\n+â”Š  â”Š 3â”Š  get fps() {\n+â”Š  â”Š 4â”Š    return 1000 / 60;\n+â”Š  â”Š 5â”Š  }\n+â”Š  â”Š 6â”Š\n+â”Š  â”Š 7â”Š  // Game's run speed.\n+â”Š  â”Š 8â”Š  // A lower value will make it run slower and a higher value will make it run faster\n+â”Š  â”Š 9â”Š  get speed() {\n+â”Š  â”Š10â”Š    return 1;\n+â”Š  â”Š11â”Š  }\n+â”Š  â”Š12â”Š\n+â”Š  â”Š13â”Š  constructor(canvas) {\n+â”Š  â”Š14â”Š    this.canvas = canvas;\n+â”Š  â”Š15â”Š    this.lastUpdate = this.creation = new Date().getTime();\n+â”Š  â”Š16â”Š\n+â”Š  â”Š17â”Š    // Canvas dimensions must be set programmatically otherwise you might encounter some\n+â”Š  â”Š18â”Š    // unexpected behaviors\n+â”Š  â”Š19â”Š    canvas.width = 1280;\n+â”Š  â”Š20â”Š    canvas.height = 720;\n+â”Š  â”Š21â”Š    // Canvas will be focused once game page is loaded so all events will automatically\n+â”Š  â”Š22â”Š    // be captured by it\n+â”Š  â”Š23â”Š    canvas.focus();\n+â”Š  â”Š24â”Š\n+â”Š  â”Š25â”Š    // We want to focus on the canvas once we press on it\n+â”Š  â”Š26â”Š    canvas.addEventListener(\"mousedown\", canvas.focus.bind(canvas), false);\n+â”Š  â”Š27â”Š\n+â”Š  â”Š28â”Š    this.assets = {};\n+â”Š  â”Š29â”Š    this.events = new Map();\n+â”Š  â”Š30â”Š    this.context = canvas.getContext(\"2d\");\n+â”Š  â”Š31â”Š    this.bufferedCanvas = document.createElement(\"canvas\");\n+â”Š  â”Š32â”Š    this.bufferedContext = this.bufferedCanvas.getContext(\"2d\");\n+â”Š  â”Š33â”Š    this.bufferedCanvas.width = canvas.width;\n+â”Š  â”Š34â”Š    this.bufferedCanvas.height = canvas.height;\n+â”Š  â”Š35â”Š  }\n+â”Š  â”Š36â”Š\n+â”Š  â”Š37â”Š  draw() {\n+â”Š  â”Š38â”Š    // Draw a black screen by default\n+â”Š  â”Š39â”Š    this.context.restore();\n+â”Š  â”Š40â”Š    this.context.fillStyle = \"black\";\n+â”Š  â”Š41â”Š    this.context.save();\n+â”Š  â”Š42â”Š    this.context.beginPath();\n+â”Š  â”Š43â”Š    this.context.rect(0, 0, this.canvas.width, this.canvas.height);\n+â”Š  â”Š44â”Š    this.context.fill();\n+â”Š  â”Š45â”Š  }\n+â”Š  â”Š46â”Š\n+â”Š  â”Š47â”Š  update() {\n+â”Š  â”Š48â”Š    // Calculate the time elapsed\n+â”Š  â”Š49â”Š    let lastUpdate = this.lastUpdate;\n+â”Š  â”Š50â”Š    let currUpdate = this.lastUpdate = new Date().getTime();\n+â”Š  â”Š51â”Š    let span = currUpdate - lastUpdate;\n+â”Š  â”Š52â”Š    this.updateScreen(span / this.speed);\n+â”Š  â”Š53â”Š  }\n+â”Š  â”Š54â”Š\n+â”Š  â”Š55â”Š  // The main loop of the game\n+â”Š  â”Š56â”Š  loop() {\n+â”Š  â”Š57â”Š    // If paused, don't run loop. The canvas will remain as is\n+â”Š  â”Š58â”Š    if (!this.playing) return;\n+â”Š  â”Š59â”Š\n+â”Š  â”Š60â”Š    setTimeout(() => {\n+â”Š  â”Š61â”Š      this.draw();\n+â”Š  â”Š62â”Š      this.update();\n+â”Š  â”Š63â”Š      this.loop();\n+â”Š  â”Š64â”Š    }, this.fps);\n+â”Š  â”Š65â”Š  }\n+â”Š  â”Š66â”Š\n+â”Š  â”Š67â”Š  play() {\n+â”Š  â”Š68â”Š    this.playing = true;\n+â”Š  â”Š69â”Š    this.loop();\n+â”Š  â”Š70â”Š  }\n+â”Š  â”Š71â”Š\n+â”Š  â”Š72â”Š  pause() {\n+â”Š  â”Š73â”Š    this.playing = false;\n+â”Š  â”Š74â”Š  }\n+â”Š  â”Š75â”Š\n+â”Š  â”Š76â”Š  // Defines global assets\n+â”Š  â”Š77â”Š  extendAssets(assets) {\n+â”Š  â”Š78â”Š    _.extend(this.assets, assets);\n+â”Š  â”Š79â”Š  }\n+â”Š  â”Š80â”Š\n+â”Š  â”Š81â”Š  // Disposes global assets\n+â”Š  â”Š82â”Š  clearAssets() {\n+â”Š  â”Š83â”Š    this.assets = {};\n+â”Š  â”Š84â”Š  }\n+â”Š  â”Š85â”Š\n+â”Š  â”Š86â”Š  // Adds event listener for game canvas\n+â”Š  â”Š87â”Š  addEventListener(type, listener, target) {\n+â”Š  â”Š88â”Š    let boundListener = listener.bind(target);\n+â”Š  â”Š89â”Š    this.events.set(listener, boundListener);\n+â”Š  â”Š90â”Š    this.canvas.addEventListener(type, boundListener, false);\n+â”Š  â”Š91â”Š  }\n+â”Š  â”Š92â”Š\n+â”Š  â”Š93â”Š  // Removes event listener from game canvas\n+â”Š  â”Š94â”Š  removeEventListener(type, listener) {\n+â”Š  â”Š95â”Š    let boundListener = this.events.get(listener);\n+â”Š  â”Š96â”Š    this.events.delete(listener);\n+â”Š  â”Š97â”Š    this.canvas.removeEventListener(type, boundListener, false);\n+â”Š  â”Š98â”Š  }\n+â”Š  â”Š99â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -9,6 +9,7 @@\n â”Š 9â”Š 9â”Š\n â”Š10â”Š10â”Š    <!-- Scripts -->\n â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n+â”Š  â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š12â”Š13â”Š\n â”Š13â”Š14â”Š    <!-- Styles -->\n â”Š14â”Š15â”Š    <link rel=\"stylesheet\" type=\"text/css\" href=\"/styles/game.css\">\n```\n\n[}]: #\n\nThe only thing it's doing right now is drawing a black background, but we're soon going to learn how to take advantage of this game-loop to draw stuff of our own. I'd like to point out that there is no need to implement a [double-buffer](https://en.wikipedia.org/wiki/Multiple_buffering) (A method similar to React's [virtual DOM](https://www.npmjs.com/package/react-dom)) when it comes to `HTMLCanvas` elements, since `HTML5` already does that for us. To start running the game, we first need to wait for the DOM content to initialize, and once it's ready we gonna create a new game instance and call the `play` method:\n\n[{]: <helper> (diffStep 2.6)\n\n#### [Step 2.6: Create game entry point](https://github.com/DAB0mB/radial-snake/commit/30e75df)\n\n##### Added resources&#x2F;scripts&#x2F;main.js\n```diff\n@@ -0,0 +1,4 @@\n+â”Š â”Š1â”Šdocument.addEventListener(\"DOMContentLoaded\", function(event) {\n+â”Š â”Š2â”Š  let game = new Engine.Game(document.getElementById(\"gameCanvas\"), false);\n+â”Š â”Š3â”Š  game.play();\n+â”Š â”Š4â”Š});ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -10,6 +10,7 @@\n â”Š10â”Š10â”Š    <!-- Scripts -->\n â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n â”Š12â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n+â”Š  â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n â”Š13â”Š14â”Š\n â”Š14â”Š15â”Š    <!-- Styles -->\n â”Š15â”Š16â”Š    <link rel=\"stylesheet\" type=\"text/css\" href=\"/styles/game.css\">\n```\n\n[}]: #\n\nThis will take control over the canvas and will draw a new picture every 17ms, which is 60fps (Frames per second). As for now you're only going to see a black canvas, but I promise the final result is not going to disappoint you.\n\nThe next thing we're gonna do would be adding a 'key state' manager, which will store a flag for each key pressed on the keyboard. Once we press the key, the flag's value would be `true`, and once we release it, its value would turn into `false`. This way we have an easy way to track all the key presses without registering a specific event listener for each key press we wanna track:\n\n[{]: <helper> (diffStep 2.7)\n\n#### [Step 2.7: Add key states manager](https://github.com/DAB0mB/radial-snake/commit/831b058)\n\n##### Added resources&#x2F;scripts&#x2F;engine&#x2F;key_states.js\n```diff\n@@ -0,0 +1,20 @@\n+â”Š  â”Š 1â”ŠEngine.KeyStates = class KeyStates {\n+â”Š  â”Š 2â”Š  constructor() {\n+â”Š  â”Š 3â”Š    // We will have 255 states, each one represents an ascii code matching its index\n+â”Š  â”Š 4â”Š    this.states = new Array(255);\n+â”Š  â”Š 5â”Š  }\n+â”Š  â”Š 6â”Š\n+â”Š  â”Š 7â”Š  get(k) {\n+â”Š  â”Š 8â”Š    return this.states[k];\n+â”Š  â”Š 9â”Š  }\n+â”Š  â”Š10â”Š\n+â”Š  â”Š11â”Š  // This should be called once we press a key\n+â”Š  â”Š12â”Š  add(k) {\n+â”Š  â”Š13â”Š    this.states[k] = true;\n+â”Š  â”Š14â”Š  }\n+â”Š  â”Š15â”Š\n+â”Š  â”Š16â”Š  // This should be called once we release a key\n+â”Š  â”Š17â”Š  remove(k) {\n+â”Š  â”Š18â”Š    this.states[k] = false;\n+â”Š  â”Š19â”Š  }\n+â”Š  â”Š20â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -9,6 +9,7 @@\n â”Š 9â”Š 9â”Š\n â”Š10â”Š10â”Š    <!-- Scripts -->\n â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n+â”Š  â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/key_states.js\"></script>\n â”Š12â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n```\n\n[}]: #\n\nNow that we have the key state manager, we will initialize a new instance as part of our game's essentials, and we will create a global event listener for key presses; Each time a key is pressed, the key state manager will update itself:\n\n[{]: <helper> (diffStep 2.8)\n\n#### [Step 2.8: Register key presses](https://github.com/DAB0mB/radial-snake/commit/9f55501)\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;game.js\n```diff\n@@ -14,7 +14,7 @@\n â”Š14â”Š14â”Š    this.canvas = canvas;\n â”Š15â”Š15â”Š    this.lastUpdate = this.creation = new Date().getTime();\n â”Š16â”Š16â”Š\n-â”Š17â”Š  â”Š    // Canvas dimensions must be set programmatically otherwise you might encounter some\n+â”Š  â”Š17â”Š    // Canvas dimensions must be set programmatically, otherwise you might encounter some\n â”Š18â”Š18â”Š    // unexpected behaviors\n â”Š19â”Š19â”Š    canvas.width = 1280;\n â”Š20â”Š20â”Š    canvas.height = 720;\n```\n```diff\n@@ -24,9 +24,13 @@\n â”Š24â”Š24â”Š\n â”Š25â”Š25â”Š    // We want to focus on the canvas once we press on it\n â”Š26â”Š26â”Š    canvas.addEventListener(\"mousedown\", canvas.focus.bind(canvas), false);\n+â”Š  â”Š27â”Š    // Key flags will be registered by the \"KeyStates\" instance\n+â”Š  â”Š28â”Š    canvas.addEventListener(\"keydown\", onKeyDown.bind(this), false);\n+â”Š  â”Š29â”Š    canvas.addEventListener(\"keyup\", onKeyUp.bind(this), false);\n â”Š27â”Š30â”Š\n â”Š28â”Š31â”Š    this.assets = {};\n â”Š29â”Š32â”Š    this.events = new Map();\n+â”Š  â”Š33â”Š    this.keyStates = new Engine.KeyStates();\n â”Š30â”Š34â”Š    this.context = canvas.getContext(\"2d\");\n â”Š31â”Š35â”Š    this.bufferedCanvas = document.createElement(\"canvas\");\n â”Š32â”Š36â”Š    this.bufferedContext = this.bufferedCanvas.getContext(\"2d\");\n```\n```diff\n@@ -96,4 +100,19 @@\n â”Š 96â”Š100â”Š    this.events.delete(listener);\n â”Š 97â”Š101â”Š    this.canvas.removeEventListener(type, boundListener, false);\n â”Š 98â”Š102â”Š  }\n-â”Š 99â”Š   â”Š};ðŸš«â†µ\n+â”Š   â”Š103â”Š};\n+â”Š   â”Š104â”Š\n+â”Š   â”Š105â”Šfunction onKeyDown(e) {\n+â”Š   â”Š106â”Š  // Once we're focused on the canvas, we want nothing else to happen\n+â”Š   â”Š107â”Š  // besides events the game is listening to. For example, when we press\n+â”Š   â”Š108â”Š  // the arrow keys, this will prevent the screen from scrolling\n+â”Š   â”Š109â”Š  e.preventDefault();\n+â”Š   â”Š110â”Š  // Register key press\n+â”Š   â”Š111â”Š  this.keyStates.add(e.keyCode);\n+â”Š   â”Š112â”Š}\n+â”Š   â”Š113â”Š\n+â”Š   â”Š114â”Šfunction onKeyUp(e) {\n+â”Š   â”Š115â”Š  e.preventDefault();\n+â”Š   â”Š116â”Š  // Register key release\n+â”Š   â”Š117â”Š  this.keyStates.remove(e.keyCode);\n+â”Š   â”Š118â”Š}\n```\n\n[}]: #\n\nA 2D game's view might get complex as we go through with its development and add more logic and entities into it. Having only one `draw` method and only one `update` method is not enough, and if you think of it, it might easily get buffed up into ridiculous dimensions, which is not the way to go. I'd like to introduce you into a new methodology which involves `screens` and `layers`:\n\n- **screen** - Will literally be used whenever we want to show a new screen in our game e.g. 'splash' screen and 'main menu' screen. A screen consists of multiple layers, and will be used as their communicator; All the relevant assets and logic will be initialized inside it.\n- **layer** - similar to Photoshop's layer system, any time we want to add something to the view we add new layers on top or beneath of each other.\n\n![screen-layer](https://cloud.githubusercontent.com/assets/7648874/21487708/9b366efe-cbb7-11e6-8669-3212e440871a.png)\n\nAs I said earlier, the purpose of the screens and the layers is just to split the task of updating and drawing and updating, so we can have logical segments; So the `layer` class should mainly consist of a `draw` and an `update` method:\n\n[{]: <helper> (diffStep 2.9)\n\n#### [Step 2.9: Add screen layer](https://github.com/DAB0mB/radial-snake/commit/736ab08)\n\n##### Added resources&#x2F;scripts&#x2F;engine&#x2F;layer.js\n```diff\n@@ -0,0 +1,43 @@\n+â”Š  â”Š 1â”ŠEngine.Layer = class Layer {\n+â”Š  â”Š 2â”Š  // The dimensions of the layer are correlated to dimensions of the canvas\n+â”Š  â”Š 3â”Š  get width() {\n+â”Š  â”Š 4â”Š    return this.canvas.width;\n+â”Š  â”Š 5â”Š  }\n+â”Š  â”Š 6â”Š\n+â”Š  â”Š 7â”Š  get height() {\n+â”Š  â”Š 8â”Š    return this.canvas.height;\n+â”Š  â”Š 9â”Š  }\n+â”Š  â”Š10â”Š\n+â”Š  â”Š11â”Š  // A hash of \"eventName\" : \"handlerName\" which should be overrided by user\n+â”Š  â”Š12â”Š  get events() {\n+â”Š  â”Š13â”Š    return {};\n+â”Š  â”Š14â”Š  }\n+â”Š  â”Š15â”Š\n+â”Š  â”Š16â”Š  constructor(screen) {\n+â”Š  â”Š17â”Š    this.age = 0;\n+â”Š  â”Š18â”Š    this.creation = new Date().getTime();\n+â”Š  â”Š19â”Š    this.screen = screen;\n+â”Š  â”Š20â”Š    this.game = screen.game;\n+â”Š  â”Š21â”Š    this.assets = screen.assets;\n+â”Š  â”Š22â”Š    this.keyStates = screen.keyStates;\n+â”Š  â”Š23â”Š    this.canvas = screen.game.canvas;\n+â”Š  â”Š24â”Š  }\n+â”Š  â”Š25â”Š\n+â”Š  â”Š26â”Š  update(span) {\n+â”Š  â”Š27â”Š  }\n+â”Š  â”Š28â”Š\n+â”Š  â”Š29â”Š  draw(context) {\n+â”Š  â”Š30â”Š  }\n+â”Š  â”Š31â”Š\n+â”Š  â”Š32â”Š  initEventListeners() {\n+â”Š  â”Š33â”Š    _.each(this.events, (listener, event) => {\n+â”Š  â”Š34â”Š      this.game.addEventListener(event, this[listener], this);\n+â”Š  â”Š35â”Š    });\n+â”Š  â”Š36â”Š  }\n+â”Š  â”Š37â”Š\n+â”Š  â”Š38â”Š  disposeEventListeners() {\n+â”Š  â”Š39â”Š    _.each(this.events, (listener, event) => {\n+â”Š  â”Š40â”Š      this.game.removeEventListener(event, this[listener]);\n+â”Š  â”Š41â”Š    });\n+â”Š  â”Š42â”Š  }\n+â”Š  â”Š43â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -10,6 +10,7 @@\n â”Š10â”Š10â”Š    <!-- Scripts -->\n â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n â”Š12â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/key_states.js\"></script>\n+â”Š  â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/layer.js\"></script>\n â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š14â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n```\n\n[}]: #\n\nSame thing for the screen, it only has a `draw` and `update` methods, only it has a stack of layers, which can either be added or removed:\n\n[{]: <helper> (diffStep 2.1)\n\n#### [Step 2.1: Create basic game view](https://github.com/DAB0mB/radial-snake/commit/254f06f)\n\n##### Added views&#x2F;game.html\n```diff\n@@ -0,0 +1,10 @@\n+â”Š  â”Š 1â”Š<!DOCTYPE html>\n+â”Š  â”Š 2â”Š<html>\n+â”Š  â”Š 3â”Š  <head>\n+â”Š  â”Š 4â”Š    <title>radial snake</title>\n+â”Š  â”Š 5â”Š  </head>\n+â”Š  â”Š 6â”Š\n+â”Š  â”Š 7â”Š  <body>\n+â”Š  â”Š 8â”Š    <canvas id=\"gameCanvas\" tabindex=\"0\"></canvas>\n+â”Š  â”Š 9â”Š  </body>\n+â”Š  â”Š10â”Š</html>ðŸš«â†µ\n```\n\n[}]: #\n\nNow that we have the `screen` class available for us, let's apply it to the main game loop:\n\n[{]: <helper> (diffStep 2.11)\n\n#### [Step 2.11: Draw and update screen in game loop](https://github.com/DAB0mB/radial-snake/commit/9f34754)\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;game.js\n```diff\n@@ -30,6 +30,7 @@\n â”Š30â”Š30â”Š\n â”Š31â”Š31â”Š    this.assets = {};\n â”Š32â”Š32â”Š    this.events = new Map();\n+â”Š  â”Š33â”Š    this.screen = new Engine.Screen(this);\n â”Š33â”Š34â”Š    this.keyStates = new Engine.KeyStates();\n â”Š34â”Š35â”Š    this.context = canvas.getContext(\"2d\");\n â”Š35â”Š36â”Š    this.bufferedCanvas = document.createElement(\"canvas\");\n```\n```diff\n@@ -46,6 +47,13 @@\n â”Š46â”Š47â”Š    this.context.beginPath();\n â”Š47â”Š48â”Š    this.context.rect(0, 0, this.canvas.width, this.canvas.height);\n â”Š48â”Š49â”Š    this.context.fill();\n+â”Š  â”Š50â”Š    this.drawScreen(this.context);\n+â”Š  â”Š51â”Š  }\n+â”Š  â”Š52â”Š\n+â”Š  â”Š53â”Š  drawScreen(context) {\n+â”Š  â”Š54â”Š    // If screen's assets are not yet loaded, don't draw it\n+â”Š  â”Š55â”Š    if (this.screen.loading) return;\n+â”Š  â”Š56â”Š    if (this.screen.draw) this.screen.draw(context);\n â”Š49â”Š57â”Š  }\n â”Š50â”Š58â”Š\n â”Š51â”Š59â”Š  update() {\n```\n```diff\n@@ -56,6 +64,13 @@\n â”Š56â”Š64â”Š    this.updateScreen(span / this.speed);\n â”Š57â”Š65â”Š  }\n â”Š58â”Š66â”Š\n+â”Š  â”Š67â”Š  updateScreen(span) {\n+â”Š  â”Š68â”Š    this.screen.age += span;\n+â”Š  â”Š69â”Š    // If screen's assets are not yet loaded, don't update it\n+â”Š  â”Š70â”Š    if (this.screen.loading) return;\n+â”Š  â”Š71â”Š    if (this.screen.update) this.screen.update(span);\n+â”Š  â”Š72â”Š  }\n+â”Š  â”Š73â”Š\n â”Š59â”Š74â”Š  // The main loop of the game\n â”Š60â”Š75â”Š  loop() {\n â”Š61â”Š76â”Š    // If paused, don't run loop. The canvas will remain as is\n```\n\n[}]: #\n\nThis step looks kind of useless for now, unless we will have the ability to change screens as we please. Any time a screen is changed, it should be loaded with its necessary assets e.g textures, sounds, fonts, etc. The assets loading is an asynchronous operation whose logic might get a bit messy if not managed properly. To make it easier, we're going to define an assets loader, which will help us load assets asynchronously:\n\n[{]: <helper> (diffStep 2.12)\n\n#### [Step 2.12: Add assets loader](https://github.com/DAB0mB/radial-snake/commit/d8895f8)\n\n##### Added resources&#x2F;scripts&#x2F;engine&#x2F;assets_loader.js\n```diff\n@@ -0,0 +1,13 @@\n+â”Š  â”Š 1â”ŠEngine.AssetsLoader = class AssetsLoader {\n+â”Š  â”Š 2â”Š  constructor(next) {\n+â”Š  â”Š 3â”Š    this.next = next;\n+â”Š  â”Š 4â”Š  }\n+â”Š  â”Š 5â”Š\n+â”Š  â”Š 6â”Š  // Load texture\n+â”Š  â”Š 7â”Š  texture(path) {\n+â”Š  â”Š 8â”Š    let image = new Image();\n+â”Š  â”Š 9â”Š    image.onload = this.next();\n+â”Š  â”Š10â”Š    image.src = `${path}.png`;\n+â”Š  â”Š11â”Š    return image;\n+â”Š  â”Š12â”Š  }\n+â”Š  â”Š13â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -12,6 +12,7 @@\n â”Š12â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/key_states.js\"></script>\n â”Š13â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/layer.js\"></script>\n â”Š14â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/screen.js\"></script>\n+â”Š  â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/assets_loader.js\"></script>\n â”Š15â”Š16â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š16â”Š17â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n```\n\n[}]: #\n\n> As for now the `assets loader` only has the ability to load textures, but we will extend it as we go further in this tutorial, no need to overdo it.\n\nNow that we have the `assets loader` we can add the ability to change a screen. Whenever we change a screen, the old screen's assets should be unloaded, and the new screen's assets should be loaded using the `assets loader`:\n\n[{]: <helper> (diffStep 2.13)\n\n#### [Step 2.13: Add the ability to change and load screen](https://github.com/DAB0mB/radial-snake/commit/90aab03)\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;game.js\n```diff\n@@ -92,6 +92,61 @@\n â”Š 92â”Š 92â”Š    this.playing = false;\n â”Š 93â”Š 93â”Š  }\n â”Š 94â”Š 94â”Š\n+â”Š   â”Š 95â”Š  changeScreen(Screen, ...screenArgs) {\n+â”Š   â”Š 96â”Š    // If there is a screen defined, dispose it first\n+â”Š   â”Š 97â”Š    if (this.screen) {\n+â”Š   â”Š 98â”Š      this.unloadScreen();\n+â”Š   â”Š 99â”Š      this.screen.disposeEventListeners();\n+â”Š   â”Š100â”Š    }\n+â”Š   â”Š101â”Š\n+â”Š   â”Š102â”Š    this.screen = new Screen(this, ...screenArgs);\n+â”Š   â”Š103â”Š\n+â”Š   â”Š104â”Š    // Load screen assets\n+â”Š   â”Š105â”Š    this.loadScreen(() => {\n+â”Š   â”Š106â”Š      // Once assets are loaded, initialize event listeners\n+â”Š   â”Š107â”Š      this.screen.initEventListeners();\n+â”Š   â”Š108â”Š      // The \"initialize\" method is exactly the same as the constructor, only it runs\n+â”Š   â”Š109â”Š      // once assets are available and event listeners are registered\n+â”Š   â”Š110â”Š      this.screen.initialize(this, ...screenArgs);\n+â”Š   â”Š111â”Š    });\n+â”Š   â”Š112â”Š  }\n+â”Š   â”Š113â”Š\n+â”Š   â”Š114â”Š  // Loads screen assets and invokes callback once loading is finished\n+â”Š   â”Š115â”Š  loadScreen(callback = _.noop) {\n+â”Š   â”Š116â”Š    if (!this.screen.load) return callback();\n+â”Š   â”Š117â”Š\n+â”Š   â”Š118â”Š    this.screen.loading = true;\n+â”Š   â”Š119â”Š    // The number of assets to load\n+â”Š   â”Š120â”Š    let loadsize = 0;\n+â”Š   â”Š121â”Š    let onload;\n+â”Š   â”Š122â”Š\n+â”Š   â”Š123â”Š    // This object can load assets\n+â”Š   â”Š124â”Š    let assetsLoader = new Engine.AssetsLoader(() => {\n+â”Š   â”Š125â”Š      loadsize++;\n+â”Š   â”Š126â”Š      return () => onload();\n+â”Š   â”Š127â”Š    });\n+â”Š   â”Š128â”Š\n+â”Š   â”Š129â”Š    // The \"load\" method returns the assets loaded by the screen\n+â”Š   â”Š130â”Š    let screenAssets = this.screen.load(assetsLoader);\n+â”Š   â”Š131â”Š\n+â”Š   â”Š132â”Š    // We use the \"after\" method because we want the following callback to be invoked\n+â”Š   â”Š133â”Š    // only once all assets are loaded\n+â”Š   â”Š134â”Š    onload = _.after(loadsize, () => {\n+â”Š   â”Š135â”Š      delete this.screen.loading;\n+â”Š   â”Š136â”Š      callback();\n+â”Š   â”Š137â”Š    });\n+â”Š   â”Š138â”Š\n+â”Š   â”Š139â”Š    // The returned assets will be available on screen's assets object\n+â”Š   â”Š140â”Š    _.extend(this.screen.assets, screenAssets);\n+â”Š   â”Š141â”Š  }\n+â”Š   â”Š142â”Š\n+â”Š   â”Š143â”Š  // Disposes screen assets\n+â”Š   â”Š144â”Š  unloadScreen() {\n+â”Š   â”Š145â”Š    if (!this.screen.unload) return;\n+â”Š   â”Š146â”Š    let assetsNames = this.screen.unload();\n+â”Š   â”Š147â”Š    _.omit(this.assets, assetsNames);\n+â”Š   â”Š148â”Š  }\n+â”Š   â”Š149â”Š\n â”Š 95â”Š150â”Š  // Defines global assets\n â”Š 96â”Š151â”Š  extendAssets(assets) {\n â”Š 97â”Š152â”Š    _.extend(this.assets, assets);\n```\n\n[}]: #\n\nLet's add a test screen just so we can get the hang of it. The test screen will only print a message to the canvas:\n\n[{]: <helper> (diffStep 2.14)\n\n#### [Step 2.14: Add test screen](https://github.com/DAB0mB/radial-snake/commit/85776e8)\n\n##### Added resources&#x2F;scripts&#x2F;test_screen.js\n```diff\n@@ -0,0 +1,10 @@\n+â”Š  â”Š 1â”Šclass TestScreen extends Engine.Screen {\n+â”Š  â”Š 2â”Š  draw(context) {\n+â”Š  â”Š 3â”Š    // A 20px sized \"Georgia\" font (Available natively)\n+â”Š  â”Š 4â”Š    context.font = \"20px Georgia\";\n+â”Š  â”Š 5â”Š    // The text should be colored white\n+â”Š  â”Š 6â”Š    context.fillStyle = \"white\";\n+â”Š  â”Š 7â”Š    // Draw the following message 50px from the left and 50px from the top\n+â”Š  â”Š 8â”Š    context.fillText(\"This is a Test Screen\", 50, 50);\n+â”Š  â”Š 9â”Š  }\n+â”Š  â”Š10â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -14,6 +14,7 @@\n â”Š14â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/screen.js\"></script>\n â”Š15â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/assets_loader.js\"></script>\n â”Š16â”Š16â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n+â”Š  â”Š17â”Š    <script type=\"text/javascript\" src=\"/scripts/test_screen.js\"></script>\n â”Š17â”Š18â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n â”Š18â”Š19â”Š\n â”Š19â”Š20â”Š    <!-- Styles -->\n```\n\n[}]: #\n\nNow we will use the test screen by changing to it as we create an instance of the game:\n\n[{]: <helper> (diffStep 2.15)\n\n#### [Step 2.15: Set test screen as the initial screen](https://github.com/DAB0mB/radial-snake/commit/203d084)\n\n##### Changed resources&#x2F;scripts&#x2F;main.js\n```diff\n@@ -1,4 +1,5 @@\n â”Š1â”Š1â”Šdocument.addEventListener(\"DOMContentLoaded\", function(event) {\n â”Š2â”Š2â”Š  let game = new Engine.Game(document.getElementById(\"gameCanvas\"), false);\n+â”Š â”Š3â”Š  game.changeScreen(TestScreen);\n â”Š3â”Š4â”Š  game.play();\n â”Š4â”Š5â”Š});ðŸš«â†µ\n```\n\n[}]: #\n\nOnce you will load the application you should see a black canvas with a white text saying:\n\n    This is a test screen\n\nIt means our screen system works and you may proceed to the next step, where we're gonna create our first screen :-)"
          },
          {
            "manualTitle": "Step 3: Creating a splash screen using a keyframe animation engine",
            "stepRevision": "4b2431bbc910f8945e5fd86aa964fec3ede8761c",
            "manualView": "![snake-demo-splash-small](https://cloud.githubusercontent.com/assets/7648874/21074086/a19fa9ce-bed6-11e6-9060-2ce94c215712.gif)\n\nIn this step we will be creating the `splash` screen - the initial screen that should be shown once we launch the game. Our splash is consisted of a random logo animation as presented in the `gif` file above. The \"splash\" effect can be achieved using 2 concepts:\n\n- A sprite class - Which will present the logo texture in different dimensions, angles and rotations.\n- A key-frame animation - Which will draw an animation automatically along the time axis using key-frames - each is a sprite representation of the texture in a specific time point.\n\nSo first thing first, we will start by implementing the sprite class:\n\n[{]: <helper> (diffStep 3.1)\n\n#### [Step 3.1: Create &#x27;Sprite&#x27; class](https://github.com/DAB0mB/radial-snake/commit/a32a711)\n\n##### Added resources&#x2F;scripts&#x2F;engine&#x2F;sprite.js\n```diff\n@@ -0,0 +1,58 @@\n+â”Š  â”Š 1â”ŠEngine.Sprite = class Sprite {\n+â”Š  â”Š 2â”Š  // An easy representation of a sprite on a canvas, with a set of convenient tools\n+â”Š  â”Š 3â”Š  // for alignment and coloring\n+â”Š  â”Š 4â”Š  constructor(texture) {\n+â”Š  â”Š 5â”Š    this.texture = texture;\n+â”Š  â”Š 6â”Š    this.x = 0;\n+â”Š  â”Š 7â”Š    this.y = 0;\n+â”Š  â”Š 8â”Š    this.width = texture.width;\n+â”Š  â”Š 9â”Š    this.height = texture.height;\n+â”Š  â”Š10â”Š    this.pivot = { x: 0, y: 0 };\n+â”Š  â”Š11â”Š    this.opacity = 1;\n+â”Š  â”Š12â”Š  }\n+â”Š  â”Š13â”Š\n+â”Š  â”Š14â”Š  draw(context, offsetX = 0, offsetY = 0) {\n+â”Š  â”Š15â”Š    context.save();\n+â”Š  â”Š16â”Š    context.globalAlpha = this.opacity;\n+â”Š  â”Š17â”Š\n+â”Š  â”Š18â”Š    // The following switch-case can also be seen as a list of all possible\n+â”Š  â”Š19â”Š    // alignment modes\n+â”Š  â”Š20â”Š    switch (this.align) {\n+â”Š  â”Š21â”Š      case \"top-left\": case \"left-top\": this.pivot = { x: 0, y: 0 }; break;\n+â”Š  â”Š22â”Š      case \"top-right\": case \"right-top\": this.pivot = { x: this.width, y: 0 }; break;\n+â”Š  â”Š23â”Š      case \"bottom-left\": case \"left-bottom\": this.pivot = { x: 0, y: this.height }; break;\n+â”Š  â”Š24â”Š      case \"bottom-right\": case \"right-bottom\": this.pivot = { x: this.width, y: this.height }; break;\n+â”Š  â”Š25â”Š      case \"middle\": case \"center\": this.pivot = { x: this.width / 2, y: this.height / 2 }; break;\n+â”Š  â”Š26â”Š      case \"left\": this.pivot = { x: 0, y: this.height / 2 }; break;\n+â”Š  â”Š27â”Š      case \"top\": this.pivot = { x: this.width / 2, y: 0 }; break;\n+â”Š  â”Š28â”Š      case \"right\": this.pivot = { x: this.width, y: this.height / 2 }; break;\n+â”Š  â”Š29â”Š      case \"bottom\": this.pivot = { x: this.width / 2, y: this.height }; break;\n+â”Š  â”Š30â”Š    }\n+â”Š  â”Š31â”Š\n+â”Š  â”Š32â”Š    context.drawImage(\n+â”Š  â”Š33â”Š      this.texture,\n+â”Š  â”Š34â”Š      (this.x - this.pivot.x) + offsetX,\n+â”Š  â”Š35â”Š      (this.y - this.pivot.y) + offsetY,\n+â”Š  â”Š36â”Š      this.width,\n+â”Š  â”Š37â”Š      this.height\n+â”Š  â”Š38â”Š    );\n+â”Š  â”Š39â”Š\n+â”Š  â”Š40â”Š    context.restore();\n+â”Š  â”Š41â”Š  }\n+â”Š  â”Š42â”Š\n+â”Š  â”Š43â”Š  // A sprite property (key) can also be resized based on a given percentage.\n+â”Š  â”Š44â”Š  // The 'relative' argument represents the whole of which the percents are gonna be\n+â”Š  â”Š45â”Š  // calculated from, and the 'adapters' argument is an array of property names which\n+â”Š  â”Š46â”Š  // gonna adapt themselves based on the changes made in the given key.\n+â”Š  â”Š47â”Š  // Usually 'width' goes along with ['height'] adapters, if we\n+â”Š  â”Š48â”Š  // want to keep their original ratio\n+â”Š  â”Š49â”Š  setPercentage(key, relative, percents, ...adapters) {\n+â”Š  â”Š50â”Š    let oldVal = this[key];\n+â”Š  â”Š51â”Š    let newVal = this[key] = (percents * relative) / 100;\n+â”Š  â”Š52â”Š    let ratio = newVal / oldVal;\n+â”Š  â”Š53â”Š\n+â”Š  â”Š54â”Š    adapters.forEach(adapter => {\n+â”Š  â”Š55â”Š      this[adapter] *= ratio;\n+â”Š  â”Š56â”Š    });\n+â”Š  â”Š57â”Š  }\n+â”Š  â”Š58â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -9,6 +9,7 @@\n â”Š 9â”Š 9â”Š\n â”Š10â”Š10â”Š    <!-- Scripts -->\n â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n+â”Š  â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/sprite.js\"></script>\n â”Š12â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/key_states.js\"></script>\n â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/layer.js\"></script>\n â”Š14â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/screen.js\"></script>\n```\n\n[}]: #\n\nAnd we will download the logo which will be presented in the splash screen using the sprite class:\n\n    resources$ mkdir assets\n    resources$ cd assets\n    resources/assets$ mkdir textures\n    resources/assets$ cd textures\n    resources/assets/textures$ wget raw.githubusercontent.com/dab0mb/radial-snake/master/resources/assets/textures/splash.png\n\n> Any logo can that you desired can be used instead! But to ease things up I already provided you with one as a sample\n\nNow we will create the initial splash screen, where we only gonna show a sprite of the logo in the middle of the screen, with no animation applied yet. We will first define a dedicated `Screens` module under the `Game` namespace:\n\n[{]: <helper> (diffStep 3.3)\n\n#### [Step 3.3: Create a &#x27;Game&#x27; namespace with a &#x27;Screens&#x27; module](https://github.com/DAB0mB/radial-snake/commit/ae85a96)\n\n##### Changed resources&#x2F;scripts&#x2F;namespaces.js\n```diff\n@@ -1 +1,5 @@\n+â”Š â”Š1â”ŠGame = {\n+â”Š â”Š2â”Š  Screens: {}\n+â”Š â”Š3â”Š};\n+â”Š â”Š4â”Š\n â”Š1â”Š5â”ŠEngine = {};ðŸš«â†µ\n```\n\n[}]: #\n\nAnd we can go ahead and implement the screen itself:\n\n[{]: <helper> (diffStep 3.4)\n\n#### [Step 3.4: Create initial splash screen](https://github.com/DAB0mB/radial-snake/commit/4dd73f3)\n\n##### Added resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;splash&#x2F;index.js\n```diff\n@@ -0,0 +1,19 @@\n+â”Š  â”Š 1â”ŠGame.Screens.Splash = class Splash extends Engine.Screen {\n+â”Š  â”Š 2â”Š  initialize() {\n+â”Š  â”Š 3â”Š    // Create splash sprite and set its properties\n+â”Š  â”Š 4â”Š    this.splashSprite = new Engine.Sprite(this.assets.splashTexture);\n+â”Š  â”Š 5â”Š    this.splashSprite.align = \"center\";\n+â”Š  â”Š 6â”Š    this.splashSprite.x = this.width / 2;\n+â”Š  â”Š 7â”Š  }\n+â”Š  â”Š 8â”Š\n+â”Š  â”Š 9â”Š  load(assetsLoader) {\n+â”Š  â”Š10â”Š    // These are local assets which will be disposed along with the screen\n+â”Š  â”Š11â”Š    return {\n+â”Š  â”Š12â”Š      splashTexture: assetsLoader.texture(\"/textures/splash\")\n+â”Š  â”Š13â”Š    };\n+â”Š  â”Š14â”Š  }\n+â”Š  â”Š15â”Š\n+â”Š  â”Š16â”Š  draw(context) {\n+â”Š  â”Š17â”Š    this.splashSprite.draw(context);\n+â”Š  â”Š18â”Š  }\n+â”Š  â”Š19â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -16,6 +16,7 @@\n â”Š16â”Š16â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/assets_loader.js\"></script>\n â”Š17â”Š17â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š18â”Š18â”Š    <script type=\"text/javascript\" src=\"/scripts/test_screen.js\"></script>\n+â”Š  â”Š19â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/splash/index.js\"></script>\n â”Š19â”Š20â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n â”Š20â”Š21â”Š\n â”Š21â”Š22â”Š    <!-- Styles -->\n```\n\n[}]: #\n\nNow we can set the splash screen as the initial screen in the entry script file:\n\n[{]: <helper> (diffStep 3.5)\n\n#### [Step 3.5: Set splash screen as the initial game screen](https://github.com/DAB0mB/radial-snake/commit/3576ff8)\n\n##### Changed resources&#x2F;scripts&#x2F;main.js\n```diff\n@@ -1,5 +1,5 @@\n â”Š1â”Š1â”Šdocument.addEventListener(\"DOMContentLoaded\", function(event) {\n â”Š2â”Š2â”Š  let game = new Engine.Game(document.getElementById(\"gameCanvas\"), false);\n-â”Š3â”Š â”Š  game.changeScreen(TestScreen);\n+â”Š â”Š3â”Š  game.changeScreen(Game.Screens.Splash);\n â”Š4â”Š4â”Š  game.play();\n â”Š5â”Š5â”Š});ðŸš«â†µ\n```\n\n[}]: #\n\nAnd we will get rid of the unnecessary test screen since we make no use of it any longer:\n\n    $ rm resources/scripts/test_screen.js\n\nWe will now proceed into the next stage where we will be implementing the key-frame animation engine as said at the beginning of the step. We first need to define an `Animations` module, since we can have multiple types of animation strategy like [sprite-atlas animation](http://www.joshmorony.com/how-to-create-animations-in-phaser-with-a-texture-atlas/), not necessarily a key-frame animation:\n\n[{]: <helper> (diffStep 3.7)\n\n#### [Step 3.7: Add &#x27;Animations&#x27; module to &#x27;Engine&#x27; namespace](https://github.com/DAB0mB/radial-snake/commit/ffe800c)\n\n##### Changed resources&#x2F;scripts&#x2F;namespaces.js\n```diff\n@@ -2,4 +2,6 @@\n â”Š2â”Š2â”Š  Screens: {}\n â”Š3â”Š3â”Š};\n â”Š4â”Š4â”Š\n-â”Š5â”Š â”ŠEngine = {};ðŸš«â†µ\n+â”Š â”Š5â”ŠEngine = {\n+â”Š â”Š6â”Š  Animations: {}\n+â”Š â”Š7â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nInside the newly created module we will create the key-frame animation engine. The key-frame animation consists of the following methods:\n\n- update - Updates the animation.\n- draw - Draws the current animation frame on the provided canvas context.\n- play - Enables update operations.\n- pause - Disables update operations.\n\n[{]: <helper> (diffStep 3.8)\n\n#### [Step 3.8: Create a key-frame animation engine](https://github.com/DAB0mB/radial-snake/commit/64c58fb)\n\n##### Added resources&#x2F;scripts&#x2F;engine&#x2F;animations&#x2F;keyframe.js\n```diff\n@@ -0,0 +1,142 @@\n+â”Š   â”Š  1â”ŠEngine.Animations.Keyframe = class Keyframe {\n+â”Š   â”Š  2â”Š  constructor(sprite, keyframes) {\n+â”Š   â”Š  3â”Š    this.sprite = sprite;\n+â”Š   â”Š  4â”Š    // The key-frames array contains objects with the properties of the\n+â”Š   â”Š  5â”Š    // sprite at the current time-point, e.g. width of 100 and height of 200\n+â”Š   â”Š  6â”Š    this.keyframes = keyframes;\n+â”Š   â”Š  7â”Š    this.age = 0;\n+â”Š   â”Š  8â”Š    this.frame = 0;\n+â”Š   â”Š  9â”Š    // This flag determines what's gonna happen to the animation once\n+â”Š   â”Š 10â”Š    // it's finished playing\n+â”Š   â”Š 11â”Š    this.repetitionMode = \"none\";\n+â”Š   â”Š 12â”Š    this.lastKeyframe = _.last(keyframes);\n+â”Š   â”Š 13â”Š    this.lastFrame = this.lastKeyframe.frame;\n+â”Š   â”Š 14â”Š\n+â”Š   â”Š 15â”Š    // These are the properties which we can animate\n+â”Š   â”Š 16â”Š    this.animables = [\n+â”Š   â”Š 17â”Š      \"x\", \"y\", \"width\", \"height\", \"opacity\"\n+â”Š   â”Š 18â”Š    ];\n+â”Š   â”Š 19â”Š\n+â”Š   â”Š 20â”Š    // Set a map whose keys represent animatable properties and values represent an array\n+â”Š   â”Š 21â”Š    // with relevant key-frames to its belonging property\n+â”Š   â”Š 22â”Š    this.trimmedKeyframes = this.animables.reduce((trimmedKeyframes, key) => {\n+â”Š   â”Š 23â”Š      trimmedKeyframes[key] = keyframes.filter(keyframe => keyframe[key] != null);\n+â”Š   â”Š 24â”Š      return trimmedKeyframes;\n+â”Š   â”Š 25â”Š    }, {});\n+â”Š   â”Š 26â”Š\n+â”Š   â”Š 27â”Š    // Set initial properties on sprite based on initial key-frame\n+â”Š   â”Š 28â”Š    _.each(keyframes[0], (value, key) => {\n+â”Š   â”Š 29â”Š      if (this.animables.includes(key)) sprite[key] = value;\n+â”Š   â”Š 30â”Š    });\n+â”Š   â”Š 31â”Š  }\n+â”Š   â”Š 32â”Š\n+â”Š   â”Š 33â”Š  draw(context, offsetX, offsetY) {\n+â”Š   â”Š 34â”Š    this.sprite.draw(context, offsetX, offsetY);\n+â”Š   â”Š 35â”Š  }\n+â”Š   â”Š 36â”Š\n+â”Š   â”Š 37â”Š  update(span) {\n+â”Š   â”Š 38â”Š    if (!this.playing) return;\n+â”Š   â”Š 39â”Š\n+â”Š   â”Š 40â”Š    this.age += span;\n+â”Š   â”Š 41â”Š\n+â”Š   â”Š 42â”Š    switch (this.repetitionMode) {\n+â”Š   â”Š 43â”Š      // After one cycle animation would stop\n+â”Š   â”Š 44â”Š      case \"none\":\n+â”Š   â”Š 45â”Š        this.frame += span;\n+â”Š   â”Š 46â”Š\n+â”Š   â”Š 47â”Š        if (this.frame > this.lastFrame) {\n+â”Š   â”Š 48â”Š          this.frame = this.lastFrame;\n+â”Š   â”Š 49â”Š          this.playing = false;\n+â”Š   â”Š 50â”Š        }\n+â”Š   â”Š 51â”Š\n+â”Š   â”Š 52â”Š        break;\n+â”Š   â”Š 53â”Š\n+â”Š   â”Š 54â”Š      // Once finished, replay from the beginning\n+â”Š   â”Š 55â”Š      case \"cyclic\":\n+â”Š   â”Š 56â”Š        this.frame = this.age % this.lastFrame;\n+â”Š   â”Š 57â”Š        break;\n+â”Š   â”Š 58â”Š\n+â”Š   â”Š 59â”Š      // Once finished, play backwards, and so on\n+â”Š   â”Š 60â”Š      case \"full\":\n+â”Š   â”Š 61â”Š        this.frame = this.age % this.lastFrame;\n+â”Š   â”Š 62â”Š        let animationComplete = (this.age / this.lastFrame) % 2 >= 1;\n+â”Š   â”Š 63â”Š        if (animationComplete) this.frame = this.lastFrame - this.frame;\n+â”Š   â”Š 64â”Š        break;\n+â”Š   â”Š 65â”Š    }\n+â”Š   â”Š 66â”Š\n+â”Š   â”Š 67â”Š    // Update sprite properties based on given key-frame's easing mode\n+â”Š   â”Š 68â”Š    this.animables.forEach(key => {\n+â”Š   â”Š 69â”Š      let motion = this.getKeyframeMotion(key);\n+â”Š   â”Š 70â”Š\n+â”Š   â”Š 71â”Š      if (motion)\n+â”Š   â”Š 72â”Š        this.sprite[key] = this.calculateRelativeValue(motion, key);\n+â”Š   â”Š 73â”Š    });\n+â”Š   â”Š 74â”Š  }\n+â”Š   â”Š 75â”Š\n+â”Š   â”Š 76â”Š  play() {\n+â”Š   â”Š 77â”Š    this.playing = true;\n+â”Š   â”Š 78â”Š  }\n+â”Š   â”Š 79â”Š\n+â”Š   â”Š 80â”Š  pause() {\n+â”Š   â”Š 81â”Š    this.playing = false;\n+â”Š   â”Š 82â”Š  }\n+â”Š   â”Š 83â”Š\n+â”Š   â”Š 84â”Š  // Gets motion for current refresh\n+â”Š   â”Š 85â”Š  getKeyframeMotion(key) {\n+â”Š   â”Š 86â”Š    let keyframes = this.trimmedKeyframes[key];\n+â”Š   â”Š 87â”Š\n+â”Š   â”Š 88â”Š    // If no key-frames defined, motion is idle\n+â”Š   â”Š 89â”Š    if (keyframes == null) return;\n+â”Š   â”Š 90â”Š    // If there is only one key frame, motion is idle\n+â”Š   â”Š 91â”Š    if (keyframes.length < 2) return;\n+â”Š   â”Š 92â”Š    // If last frame reached, motion is idle\n+â”Š   â”Š 93â”Š    if (this.frame > _.last(keyframes).frame) return;\n+â”Š   â”Š 94â”Š\n+â”Š   â”Š 95â”Š    let start = this.findStartKeyframe(keyframes);\n+â”Š   â”Š 96â”Š    let end = this.findEndKeyframe(keyframes);\n+â”Š   â”Š 97â”Š    let ratio = this.getKeyframesRatio(start, end);\n+â”Š   â”Š 98â”Š\n+â”Š   â”Š 99â”Š    return { start, end, ratio };\n+â”Š   â”Š100â”Š  }\n+â”Š   â”Š101â”Š\n+â”Š   â”Š102â”Š  // Gets the movement ratio\n+â”Š   â”Š103â”Š  getKeyframesRatio(start, end) {\n+â”Š   â”Š104â”Š    return (this.frame - start.frame) / (end.frame - start.frame);\n+â”Š   â”Š105â”Š  }\n+â”Š   â”Š106â”Š\n+â”Š   â”Š107â”Š  // Get property end value based on current frame\n+â”Š   â”Š108â”Š  findEndKeyframe(keyframes) {\n+â”Š   â”Š109â”Š    return _.find(keyframes, keyframe =>\n+â”Š   â”Š110â”Š      keyframe.frame >= (this.frame || 1)\n+â”Š   â”Š111â”Š    );\n+â”Š   â”Š112â”Š  }\n+â”Š   â”Š113â”Š\n+â”Š   â”Š114â”Š  // Get property start value based on current frame\n+â”Š   â”Š115â”Š  findStartKeyframe(keyframes) {\n+â”Š   â”Š116â”Š    let resultIndex;\n+â”Š   â”Š117â”Š\n+â”Š   â”Š118â”Š    keyframes.some((keyframe, currIndex) => {\n+â”Š   â”Š119â”Š      if (keyframe.frame >= (this.frame || 1)) {\n+â”Š   â”Š120â”Š        resultIndex = currIndex;\n+â”Š   â”Š121â”Š        return true;\n+â”Š   â”Š122â”Š      }\n+â”Š   â”Š123â”Š    });\n+â”Š   â”Š124â”Š\n+â”Š   â”Š125â”Š    return keyframes[resultIndex - 1];\n+â”Š   â”Š126â”Š  }\n+â”Š   â”Š127â”Š\n+â”Š   â”Š128â”Š  // Get a recalculated property value relative to provided easing mode\n+â”Š   â”Š129â”Š  calculateRelativeValue(motion, key) {\n+â”Š   â”Š130â”Š    let a = motion.start[key];\n+â”Š   â”Š131â”Š    let b = motion.end[key];\n+â”Š   â”Š132â”Š    let r = motion.ratio;\n+â”Š   â”Š133â”Š    let easing = r > 0 ? motion.start.easing : motion.end.easing;\n+â”Š   â”Š134â”Š\n+â”Š   â”Š135â”Š    switch (easing) {\n+â”Š   â”Š136â”Š      case \"in\": r = Math.sin((r * Math.PI) / 2); break;\n+â”Š   â”Š137â”Š      case \"out\": r = Math.cos((r * Math.PI) / 2); break;\n+â”Š   â”Š138â”Š    }\n+â”Š   â”Š139â”Š\n+â”Š   â”Š140â”Š    return ((b - a) * r) + a;\n+â”Š   â”Š141â”Š  }\n+â”Š   â”Š142â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -10,6 +10,7 @@\n â”Š10â”Š10â”Š    <!-- Scripts -->\n â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n â”Š12â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/sprite.js\"></script>\n+â”Š  â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/animations/keyframe.js\"></script>\n â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/key_states.js\"></script>\n â”Š14â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/layer.js\"></script>\n â”Š15â”Š16â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/screen.js\"></script>\n```\n\n[}]: #\n\nWhen initializing a new instance of the key-frame animation, we should invoke it with the desired sprite, and an array of key-frames. What exactly does a single key-frame represents? The properties of the sprite at that specific time point. In addition, a key-frame can be set with an [easing mode](https://css-tricks.com/ease-out-in-ease-in-out/) of `in` and `out`. By default, the animation would be linear.\n\nBased on the `repitationMode` property, three things can happen to the animation once finished:\n\n- `none` - The animation will play once, and then stop. It will appear as a static sprite.\n- `cyclic` - The animation will repeat itself from the beginning, over and over again until stopped manually.\n- `full` - The animation will play itself backwards, and then forwards, backwards, forwards, and so on.\n\nThanks to the key-frame animation engine, we can apply it to the splash screen to show a beautifully animated logo rather than showing a static image. So in addition to the logo sprite, we will initialize a key-frame animation as well:\n\n[{]: <helper> (diffStep 3.9)\n\n#### [Step 3.9: Apply key-frame animation to splash screen](https://github.com/DAB0mB/radial-snake/commit/8ca47e5)\n\n##### Changed resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;splash&#x2F;index.js\n```diff\n@@ -1,9 +1,34 @@\n â”Š 1â”Š 1â”ŠGame.Screens.Splash = class Splash extends Engine.Screen {\n â”Š 2â”Š 2â”Š  initialize() {\n â”Š 3â”Š 3â”Š    // Create splash sprite and set its properties\n-â”Š 4â”Š  â”Š    this.splashSprite = new Engine.Sprite(this.assets.splashTexture);\n-â”Š 5â”Š  â”Š    this.splashSprite.align = \"center\";\n-â”Š 6â”Š  â”Š    this.splashSprite.x = this.width / 2;\n+â”Š  â”Š 4â”Š    let splashSprite = new Engine.Sprite(this.assets.splashTexture);\n+â”Š  â”Š 5â”Š    splashSprite.align = \"center\";\n+â”Š  â”Š 6â”Š    splashSprite.x = this.width / 2;\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Š    // Create splash sprite animation\n+â”Š  â”Š 9â”Š    this.splashAnim = new Engine.Animations.Keyframe(splashSprite, [\n+â”Š  â”Š10â”Š      {\n+â”Š  â”Š11â”Š        y: (this.height / 2) - 30,\n+â”Š  â”Š12â”Š        width: splashSprite.width / 4,\n+â”Š  â”Š13â”Š        height: splashSprite.height / 4,\n+â”Š  â”Š14â”Š        opacity: 0,\n+â”Š  â”Š15â”Š        easing: \"in\",\n+â”Š  â”Š16â”Š        frame: 0\n+â”Š  â”Š17â”Š      },\n+â”Š  â”Š18â”Š      {\n+â”Š  â”Š19â”Š        y: this.height / 2,\n+â”Š  â”Š20â”Š        width: (splashSprite.width / 3) + (splashSprite.width * 0.05),\n+â”Š  â”Š21â”Š        height: (splashSprite.height / 3) + (splashSprite.height * 0.05),\n+â”Š  â”Š22â”Š        opacity: 1,\n+â”Š  â”Š23â”Š        frame: 3000\n+â”Š  â”Š24â”Š      },\n+â”Š  â”Š25â”Š      {\n+â”Š  â”Š26â”Š        frame: 3500\n+â”Š  â”Š27â”Š      }\n+â”Š  â”Š28â”Š    ]);\n+â”Š  â”Š29â”Š\n+â”Š  â”Š30â”Š    // Start playing animation\n+â”Š  â”Š31â”Š    this.splashAnim.play();\n â”Š 7â”Š32â”Š  }\n â”Š 8â”Š33â”Š\n â”Š 9â”Š34â”Š  load(assetsLoader) {\n```\n```diff\n@@ -14,6 +39,10 @@\n â”Š14â”Š39â”Š  }\n â”Š15â”Š40â”Š\n â”Š16â”Š41â”Š  draw(context) {\n-â”Š17â”Š  â”Š    this.splashSprite.draw(context);\n+â”Š  â”Š42â”Š    this.splashAnim.draw(context);\n+â”Š  â”Š43â”Š  }\n+â”Š  â”Š44â”Š\n+â”Š  â”Š45â”Š  update(span) {\n+â”Š  â”Š46â”Š    this.splashAnim.update(span);\n â”Š18â”Š47â”Š  }\n â”Š19â”Š48â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nThe following key-frames illustrate the nodes of the animation we've just created:\n\n    width: 0\n    height: 0\n    opacity: 0\n\n![logo-empty](https://cloud.githubusercontent.com/assets/7648874/21583394/ee7a1dec-d065-11e6-80ce-fdd37c4b5dbb.png)\n\n    width: 225\n    height: 175\n    opacity: 1\n\n![logo-half](https://cloud.githubusercontent.com/assets/7648874/21583396/ee9bdf68-d065-11e6-95fb-4cf5ed58a9de.png)\n\n    width: 342\n    height: 266\n    opacity: 1\n\n![logo-full](https://cloud.githubusercontent.com/assets/7648874/21583395/ee7b3754-d065-11e6-9646-476d196a6412.png)"
          },
          {
            "manualTitle": "Step 4: Creating a main menu screen using a font engine",
            "stepRevision": "f88428bffcdf2bcf269b9cc15837cc40e0ed9caf",
            "manualView": "![snake-demo-menu-small](https://cloud.githubusercontent.com/assets/7648874/21074099/e72a81bc-bed6-11e6-98cb-329dc12a4b06.gif)\n\nIn this step we will be creating the main menu screen as shown above. The main menu screen is a simple screen which will show the logo of the game and an instruction text saying `Press a key to start`. We will be using a simple texture to show the game-logo and we will use the key-frame animation engine to show a flickering animation of the instruction text. The instruction text is the main part of this step, since it is made out of a font file (`.ttf`) and the text is auto-generated, a general solution which can serve us in many situations. We will start by implementing the main menu using static assets, which means that we will use a texture to show the instructions text, and later on we will implement the generic solution I've just mentioned. First, we will download the necessary assets:\n\n    resources/assets/textures$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/assets/textures/instructions.png\n    resources/assets/textures$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/assets/textures/logo.png\n\nAnd then we will implement the initial main menu screen:\n\n[{]: <helper> (diffStep 4.2)\n\n#### [Step 4.2: Create initial main menu screen](https://github.com/DAB0mB/radial-snake/commit/ed79de7)\n\n##### Added resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;menu&#x2F;index.js\n```diff\n@@ -0,0 +1,44 @@\n+â”Š  â”Š 1â”ŠGame.Screens.Menu = class Menu extends Engine.Screen {\n+â”Š  â”Š 2â”Š  initialize() {\n+â”Š  â”Š 3â”Š    // Initialize snake logo sprite\n+â”Š  â”Š 4â”Š    this.logoSprite = new Engine.Sprite(this.assets.logoTexture);\n+â”Š  â”Š 5â”Š    this.logoSprite.setPercentage(\"width\", this.width, 30, \"height\");\n+â”Š  â”Š 6â”Š\n+â”Š  â”Š 7â”Š    // Initialize instructions sprite\n+â”Š  â”Š 8â”Š    let instructionsSprite = new Engine.Sprite(this.assets.instructionsTexture);\n+â”Š  â”Š 9â”Š    instructionsSprite.align = \"center\";\n+â”Š  â”Š10â”Š    instructionsSprite.setPercentage(\"width\", this.width, 35, \"height\");\n+â”Š  â”Š11â”Š    instructionsSprite.x = this.width / 2;\n+â”Š  â”Š12â”Š    instructionsSprite.y = this.height / 2;\n+â”Š  â”Š13â”Š\n+â”Š  â”Š14â”Š    // Create flickering animation for instructions sprite\n+â”Š  â”Š15â”Š    this.instructionsAnim = new Engine.Animations.Keyframe(instructionsSprite, [\n+â”Š  â”Š16â”Š      {\n+â”Š  â”Š17â”Š        opacity: 1,\n+â”Š  â”Š18â”Š        frame: 0\n+â”Š  â”Š19â”Š      },\n+â”Š  â”Š20â”Š      {\n+â”Š  â”Š21â”Š        opacity: 0,\n+â”Š  â”Š22â”Š        frame: 2000\n+â”Š  â”Š23â”Š      }\n+â”Š  â”Š24â”Š    ]);\n+â”Š  â”Š25â”Š\n+â”Š  â”Š26â”Š    // Play it repeatedly, back and forth\n+â”Š  â”Š27â”Š    this.instructionsAnim.repetitionMode = \"full\";\n+â”Š  â”Š28â”Š    this.instructionsAnim.play();\n+â”Š  â”Š29â”Š  }\n+â”Š  â”Š30â”Š\n+â”Š  â”Š31â”Š  unload() {\n+â”Š  â”Š32â”Š    // Dispose the following assets to prevent memory leaks\n+â”Š  â”Š33â”Š    return [\"logoTexture\", \"instructionsTexture\"];\n+â”Š  â”Š34â”Š  }\n+â”Š  â”Š35â”Š\n+â”Š  â”Š36â”Š  draw(context) {\n+â”Š  â”Š37â”Š    this.logoSprite.draw(context);\n+â”Š  â”Š38â”Š    this.instructionsAnim.draw(context);\n+â”Š  â”Š39â”Š  }\n+â”Š  â”Š40â”Š\n+â”Š  â”Š41â”Š  update(span) {\n+â”Š  â”Š42â”Š    this.instructionsAnim.update(span);\n+â”Š  â”Š43â”Š  }\n+â”Š  â”Š44â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -16,6 +16,7 @@\n â”Š16â”Š16â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/screen.js\"></script>\n â”Š17â”Š17â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/assets_loader.js\"></script>\n â”Š18â”Š18â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n+â”Š  â”Š19â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/menu/index.js\"></script>\n â”Š19â”Š20â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/splash/index.js\"></script>\n â”Š20â”Š21â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n```\n\n[}]: #\n\nThis screen is dependent on several assets which we will load during \"splash screen time\", to save some loading time and for a smooth experience. The main menu screen will be shown automatically once the splash animation has been finished:\n\n[{]: <helper> (diffStep 4.3)\n\n#### [Step 4.3: Queue main menu screen](https://github.com/DAB0mB/radial-snake/commit/cd83a30)\n\n##### Changed resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;splash&#x2F;index.js\n```diff\n@@ -32,10 +32,21 @@\n â”Š32â”Š32â”Š  }\n â”Š33â”Š33â”Š\n â”Š34â”Š34â”Š  load(assetsLoader) {\n+â”Š  â”Š35â”Š    // Load assets\n+â”Š  â”Š36â”Š    let instructionsTexture = assetsLoader.texture(\"/textures/instrucitons\");\n+â”Š  â”Š37â”Š    let logoTexture = assetsLoader.texture(\"/textures/logo\");\n+â”Š  â”Š38â”Š    let splashTexture = assetsLoader.texture(\"/textures/splash\");\n+â”Š  â”Š39â”Š\n+â”Š  â”Š40â”Š    // These are global assets which will be shared among all screens until manually\n+â”Š  â”Š41â”Š    // disposed. We use the time gap created by the splash animation to load necessary\n+â”Š  â”Š42â”Š    // assets without wasting any time\n+â”Š  â”Š43â”Š    this.game.extendAssets({\n+â”Š  â”Š44â”Š      instructionsTexture,\n+â”Š  â”Š45â”Š      logoTexture\n+â”Š  â”Š46â”Š    });\n+â”Š  â”Š47â”Š\n â”Š35â”Š48â”Š    // These are local assets which will be disposed along with the screen\n-â”Š36â”Š  â”Š    return {\n-â”Š37â”Š  â”Š      splashTexture: assetsLoader.texture(\"/textures/splash\")\n-â”Š38â”Š  â”Š    };\n+â”Š  â”Š49â”Š    return { splashTexture };\n â”Š39â”Š50â”Š  }\n â”Š40â”Š51â”Š\n â”Š41â”Š52â”Š  draw(context) {\n```\n```diff\n@@ -43,6 +54,12 @@\n â”Š43â”Š54â”Š  }\n â”Š44â”Š55â”Š\n â”Š45â”Š56â”Š  update(span) {\n-â”Š46â”Š  â”Š    this.splashAnim.update(span);\n+â”Š  â”Š57â”Š    if (this.splashAnim.playing) {\n+â”Š  â”Š58â”Š      this.splashAnim.update(span);\n+â”Š  â”Š59â”Š    }\n+â”Š  â”Š60â”Š    // Once animation has stopped play switch to main menu\n+â”Š  â”Š61â”Š    else {\n+â”Š  â”Š62â”Š      this.game.changeScreen(Game.Screens.Menu);\n+â”Š  â”Š63â”Š    }\n â”Š47â”Š64â”Š  }\n â”Š48â”Š65â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nBy now if you launch the application you should see the main menu screen as described in the beginning. But event though it works, we're not yet finished. We still need to convert the instruction texture into an auto-generated font texture. Obviously, this requires us to download the desired `ttf` file:\n\n    resources/assets/fonts$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/assets/fonts/minecraftia.ttf\n\n> Any font file can be used here, but to save time and effort I already provided you with one\n\n`ttf` is the most common format, but since we're using JavaScript, it would make sense to convert it into a `json` file, and that's exactly what we're going to do. There's a very convenient software called [font-builder](https://github.com/andryblack/fontbuilder), and it can cut fonts, store them in `png` files, along with some user-specified meta-data stored in an `xml` file.\n\n![font-builder](https://camo.githubusercontent.com/b2c95cda825c783f5399d9197599848c33cdfcc8/687474703a2f2f7777772e67616d656465762e72752f66696c65732f696d616765732f73637265656e312e6a706567)\n\nGo over to this website: https://github.com/andryblack/fontbuilder.\nFetch a copy of the `font-builder` repo, and try to convert the `minecraftia.ttf` file into a `png` file. If you want to skip this step, although I wouldn't recommend it, you can download the following files which I already generated myself:\n\n    resources/assets/fonts$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/assets/fonts/minecraftia.png\n    resources/assets/fonts$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/assets/fonts/minecraftia.xml\n\nAs promised, we will be working with a `json` file, not a `ttf` file and not an `xml` file. For this task we will be implementing a font-parser module, which will simply take all the meta-data in the `xml` file and put it into a nice `json` schema:\n\n[{]: <helper> (diffStep 4.6)\n\n#### [Step 4.6: Create font parser so we can convert &#x27;xml&#x27; font format to &#x27;json&#x27;](https://github.com/DAB0mB/radial-snake/commit/66044e9)\n\n##### Added helpers&#x2F;font_parser.js\n```diff\n@@ -0,0 +1,102 @@\n+â”Š   â”Š  1â”Šconst _ = require(\"underscore\");\n+â”Š   â”Š  2â”Šconst Async = require(\"async\");\n+â”Š   â”Š  3â”Šconst Fs = require(\"fs\");\n+â”Š   â”Š  4â”Šconst Path = require(\"path\");\n+â”Š   â”Š  5â”Šconst { DOMParser } = require(\"xmldom\");\n+â”Š   â”Š  6â”Š\n+â”Š   â”Š  7â”Šif (module === require.main) {\n+â”Š   â”Š  8â”Š  let fonstDir = Path.resolve(__dirname, \"../resources/assets/fonts\");\n+â”Š   â”Š  9â”Š  xmlsToJsons(fonstDir, err => { if (err) throw err });\n+â”Š   â”Š 10â”Š}\n+â”Š   â”Š 11â”Š\n+â”Š   â”Š 12â”Š// Gets a dir path containing font xmls and converts them all to jsons\n+â”Š   â”Š 13â”Šfunction xmlsToJsons(path, callback = _.noop) {\n+â”Š   â”Š 14â”Š  Fs.readdir(path, (err, files) => {\n+â”Š   â”Š 15â”Š    if (err) return callback(err);\n+â”Š   â”Š 16â”Š\n+â”Š   â”Š 17â”Š    // Remove all extensions\n+â”Š   â”Š 18â”Š    fileNames = _.uniq(files.map(file => file.split(\".\")[0]));\n+â”Š   â”Š 19â”Š\n+â”Š   â”Š 20â”Š    // Convert each xml individually\n+â”Š   â”Š 21â”Š    Async.each(fileNames, (fileName, next) => {\n+â”Š   â”Š 22â”Š      xmlToJson(`${path}/${fileName}`, next);\n+â”Š   â”Š 23â”Š    },\n+â”Š   â”Š 24â”Š    (err) => {\n+â”Š   â”Š 25â”Š      if (!err) console.log(\n+â”Š   â”Š 26â”Š        'All fonts have been successfully parsed!'\n+â”Š   â”Š 27â”Š      );\n+â”Š   â”Š 28â”Š\n+â”Š   â”Š 29â”Š      callback(err);\n+â”Š   â”Š 30â”Š    });\n+â”Š   â”Š 31â”Š  });\n+â”Š   â”Š 32â”Š}\n+â”Š   â”Š 33â”Š\n+â”Š   â”Š 34â”Š// Gets a font xml and converts it to json\n+â”Š   â”Š 35â”Šfunction xmlToJson(path, callback = _.noop) {\n+â”Š   â”Š 36â”Š  Async.waterfall([\n+â”Š   â”Š 37â”Š    (next) => {\n+â”Š   â”Š 38â”Š      Fs.readFile(`${path}.xml`, function(err, xmlBuffer) {\n+â”Š   â”Š 39â”Š        if (err) return next(err);\n+â”Š   â”Š 40â”Š\n+â”Š   â”Š 41â”Š        let json = {\n+â”Š   â”Š 42â”Š          chars: {}\n+â”Š   â”Š 43â”Š        };\n+â”Š   â”Š 44â”Š\n+â”Š   â”Š 45â”Š        let xml = xmlBuffer.toString();\n+â”Š   â”Š 46â”Š        let doc = new DOMParser().parseFromString(xml);\n+â”Š   â”Š 47â”Š        let fontDoc = doc.getElementsByTagName(\"Font\")[0];\n+â”Š   â”Š 48â”Š        let charsDoc = fontDoc.getElementsByTagName(\"Char\");\n+â”Š   â”Š 49â”Š\n+â”Š   â”Š 50â”Š        // Compose meta-data about font like size and family\n+â”Š   â”Š 51â”Š        _.each(fontDoc.attributes, (attr) => {\n+â”Š   â”Š 52â”Š          json[attr.name] = parseInt(attr.value) || attr.value;\n+â”Š   â”Š 53â”Š        });\n+â”Š   â”Š 54â”Š\n+â”Š   â”Š 55â”Š        // Compose data about each character in font\n+â”Š   â”Š 56â”Š        _.each(charsDoc, (charDoc) => {\n+â”Š   â”Š 57â”Š          let charCode = charDoc.getAttribute(\"code\");\n+â”Š   â”Š 58â”Š\n+â”Š   â”Š 59â”Š          let char = json.chars[charCode] = {\n+â”Š   â”Š 60â”Š            rect: rect = {},\n+â”Š   â”Š 61â”Š            offset: offset = {},\n+â”Š   â”Š 62â”Š            width: parseInt(charDoc.getAttribute(\"width\"))\n+â”Š   â”Š 63â”Š          };\n+â”Š   â”Š 64â”Š\n+â”Š   â”Š 65â”Š          [\n+â”Š   â”Š 66â”Š            rect.x,\n+â”Š   â”Š 67â”Š            rect.y,\n+â”Š   â”Š 68â”Š            rect.width,\n+â”Š   â”Š 69â”Š            rect.height\n+â”Š   â”Š 70â”Š          ] = extractIntegers(charDoc.getAttribute(\"rect\"));\n+â”Š   â”Š 71â”Š\n+â”Š   â”Š 72â”Š          [offset.x, offset.y] = extractIntegers(charDoc.getAttribute(\"offset\"));\n+â”Š   â”Š 73â”Š        });\n+â”Š   â”Š 74â”Š\n+â”Š   â”Š 75â”Š        next(null, JSON.stringify(json, null, 2));\n+â”Š   â”Š 76â”Š      });\n+â”Š   â”Š 77â”Š    },\n+â”Š   â”Š 78â”Š    (json, next) => {\n+â”Š   â”Š 79â”Š      // Once finished, write json into file\n+â”Š   â”Š 80â”Š      Fs.writeFile(path + \".json\", json, (err) => {\n+â”Š   â”Š 81â”Š        next(err);\n+â”Š   â”Š 82â”Š      });\n+â”Š   â”Š 83â”Š    }\n+â”Š   â”Š 84â”Š  ], (err) => {\n+â”Š   â”Š 85â”Š    if (!err) console.log(\n+â”Š   â”Š 86â”Š      `Font ${path} has been successfully parsed...`\n+â”Š   â”Š 87â”Š    );\n+â”Š   â”Š 88â”Š\n+â”Š   â”Š 89â”Š    callback(err);\n+â”Š   â”Š 90â”Š  });\n+â”Š   â”Š 91â”Š};\n+â”Š   â”Š 92â”Š\n+â”Š   â”Š 93â”Š// Converts an string of numbers to array of numbers\n+â”Š   â”Š 94â”Š// e.g. extractIntegers(\"1 2 3\") -> [1, 2, 3]\n+â”Š   â”Š 95â”Šfunction extractIntegers(srcstr) {\n+â”Š   â”Š 96â”Š  return srcstr.split(\" \").map((substr) => parseInt(substr));\n+â”Š   â”Š 97â”Š}\n+â”Š   â”Š 98â”Š\n+â”Š   â”Š 99â”Šmodule.exports = {\n+â”Š   â”Š100â”Š  xmlToJson,\n+â”Š   â”Š101â”Š  xmlsToJsons\n+â”Š   â”Š102â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nThis script will take everything that's in the `fonts` dir and parser it as mentioned above. Before we can user this script we will need to install some NPM dependencies like so:\n\n    $ npm install --save underscore\n    $ npm install --save xmldom\n\nAnd instead of running the parser manually over and over again whenever we wanna use it, we will use the following `NPM` script instead:\n\n[{]: <helper> (diffStep 4.8)\n\n#### [Step 4.8: Add font parsing npm scripts](https://github.com/DAB0mB/radial-snake/commit/7a1cf81)\n\n##### Changed package.json\n```diff\n@@ -7,7 +7,8 @@\n â”Š 7â”Š 7â”Š  },\n â”Š 8â”Š 8â”Š  \"private\": true,\n â”Š 9â”Š 9â”Š  \"scripts\": {\n-â”Š10â”Š  â”Š    \"serve\": \"nodemon server.js\"\n+â”Š  â”Š10â”Š    \"serve\": \"npm run parse:fonts && nodemon server.js\",\n+â”Š  â”Š11â”Š    \"build:fonts\": \"node helpers/font_parser.js\"\n â”Š11â”Š12â”Š  },\n â”Š12â”Š13â”Š  \"dependencies\": {\n â”Š13â”Š14â”Š    \"async\": \"^2.1.4\",\n```\n\n[}]: #\n\nWe don't want the generated fonts to be included by `git` since they are going to automatically regenerate themselves, therefore we gonna add the following ignore rule:\n\n[{]: <helper> (diffStep 4.9)\n\n#### [Step 4.9: Add rule to to git-ignore parsed fonts](https://github.com/DAB0mB/radial-snake/commit/bbf7647)\n\n##### Changed .gitignore\n```diff\n@@ -1,2 +1,3 @@\n â”Š1â”Š1â”Šnode_modules\n-â”Š2â”Š â”Šnpm-debug.logðŸš«â†µ\n+â”Š â”Š2â”Šnpm-debug.log\n+â”Š â”Š3â”Šresources/assets/fonts/*.jsonðŸš«â†µ\n```\n\n[}]: #\n\nNow we will build our `minecraftia` font by simply running:\n\n    $ npm run build:fonts\n\nAnd voila! We have a freshly created `json` file which we can work with. You can also get it from here:\n\n    resources/assets/fonts$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/assets/fonts/minecraftia.json\n\nNow that we have our assets finally ready we can go ahead and focus on extending the engine which powers up our game. We need some sort of a generic font-engine which will know how to load a font file and create a text-sprite out of it. First we will implement a class called `Restorable`, which shares the same restore API as the CanvasRenderingContext2D and will give us the ability to save and restore the font's state (More information can be found [here](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/restore)):\n\n[{]: <helper> (diffStep 4.11)\n\n#### [Step 4.11: Add &#x27;Restorable&#x27; class](https://github.com/DAB0mB/radial-snake/commit/8239c01)\n\n##### Added resources&#x2F;scripts&#x2F;engine&#x2F;restorable.js\n```diff\n@@ -0,0 +1,21 @@\n+â”Š  â”Š 1â”ŠEngine.Restorable = class Restorable {\n+â”Š  â”Š 2â”Š  // Acts the same as canvas's save() and restore() API.\n+â”Š  â”Š 3â”Š  // 'restorable' props are defined in the constructor\n+â”Š  â”Š 4â”Š  constructor(...restorableProps) {\n+â”Š  â”Š 5â”Š    this._restorableProps = restorableProps;\n+â”Š  â”Š 6â”Š    this._restorableStates = [];\n+â”Š  â”Š 7â”Š  }\n+â”Š  â”Š 8â”Š\n+â”Š  â”Š 9â”Š  // Save current state in the stack\n+â”Š  â”Š10â”Š  save() {\n+â”Š  â”Š11â”Š    this._restorableStates.push(this._restorableProps.reduce((state, prop) => {\n+â”Š  â”Š12â”Š      state[prop] = this[prop];\n+â”Š  â”Š13â”Š      return state;\n+â”Š  â”Š14â”Š    }, {}));\n+â”Š  â”Š15â”Š  }\n+â”Š  â”Š16â”Š\n+â”Š  â”Š17â”Š  // Pop most recent state and apply it\n+â”Š  â”Š18â”Š  restore() {\n+â”Š  â”Š19â”Š    _.extend(this, this._restorableStates.pop());\n+â”Š  â”Š20â”Š  }\n+â”Š  â”Š21â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -9,6 +9,7 @@\n â”Š 9â”Š 9â”Š\n â”Š10â”Š10â”Š    <!-- Scripts -->\n â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n+â”Š  â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/restorable.js\"></script>\n â”Š12â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/sprite.js\"></script>\n â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/animations/keyframe.js\"></script>\n â”Š14â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/key_states.js\"></script>\n```\n\n[}]: #\n\nAnd now we can go ahead and implement the font class itself:\n\n[{]: <helper> (diffStep 4.12)\n\n#### [Step 4.12: Create font engine](https://github.com/DAB0mB/radial-snake/commit/7a1f2c7)\n\n##### Added resources&#x2F;scripts&#x2F;engine&#x2F;font.js\n```diff\n@@ -0,0 +1,133 @@\n+â”Š   â”Š  1â”ŠEngine.Font = class Font extends Engine.Restorable {\n+â”Š   â”Š  2â”Š  // The src property acts just line native image's src property.\n+â”Š   â”Š  3â”Š  // Once finished loading, the onload() callback will be invoked\n+â”Š   â”Š  4â”Š  get src() {\n+â”Š   â”Š  5â”Š    return this._src;\n+â”Š   â”Š  6â”Š  }\n+â”Š   â”Š  7â”Š\n+â”Š   â”Š  8â”Š  set src(src) {\n+â”Š   â”Š  9â”Š    this._src = src;\n+â”Š   â”Š 10â”Š\n+â”Š   â”Š 11â”Š    // The font is actually an image, therefore we have 2 onload callbacks.\n+â”Š   â”Š 12â”Š    // The first one is the native one which will always be run,\n+â”Š   â”Š 13â”Š    // and the second one is a user defined one\n+â”Š   â”Š 14â”Š    if (this.onload) var done = _.after(2, this.onload);\n+â”Š   â”Š 15â”Š\n+â”Š   â”Š 16â”Š    this.atlas = new Image();\n+â”Š   â”Š 17â”Š    this.atlas.onload = done;\n+â”Š   â”Š 18â”Š    this.atlas.src = `${src}.png`;\n+â”Š   â”Š 19â”Š\n+â”Š   â”Š 20â”Š    // Get json based on the given src property\n+â”Š   â”Š 21â”Š    $.getJSON(`${src}.json`, data => {\n+â”Š   â”Š 22â”Š      this.data = data;\n+â”Š   â”Š 23â”Š      if (done) done();\n+â”Š   â”Š 24â”Š    });\n+â”Š   â”Š 25â”Š\n+â”Š   â”Š 26â”Š    return this._src;\n+â”Š   â”Š 27â”Š  }\n+â”Š   â”Š 28â”Š\n+â”Š   â”Š 29â”Š  constructor() {\n+â”Š   â”Š 30â”Š    // The color property is the only restorable property\n+â”Š   â”Š 31â”Š    super(\"color\");\n+â”Š   â”Š 32â”Š    this.charSpritesCache = {};\n+â”Š   â”Š 33â”Š  }\n+â”Š   â”Š 34â”Š\n+â”Š   â”Š 35â”Š  // Creates a texture out of the font with the given text\n+â”Š   â”Š 36â”Š  createTexture(text, options = {}) {\n+â”Š   â”Š 37â”Š    let { noOffsets, noSpaces } = options;\n+â”Š   â”Š 38â”Š    let canvas = document.createElement(\"canvas\");\n+â”Š   â”Š 39â”Š    let context = canvas.getContext(\"2d\");\n+â”Š   â”Š 40â”Š    let height = canvas.height = this.data.height;\n+â”Š   â”Š 41â”Š\n+â”Š   â”Š 42â”Š    // Calculates the width of the canvas based on the text and the font\n+â”Š   â”Š 43â”Š    let width = canvas.width = _.reduce(text, (width, c) => {\n+â”Š   â”Š 44â”Š      // No-space option means that the characters will be\n+â”Š   â”Š 45â”Š      // drawn with no any space between them\n+â”Š   â”Š 46â”Š      if (noSpaces) {\n+â”Š   â”Š 47â”Š        return width + this.getCharSprite(c).width;\n+â”Š   â”Š 48â”Š      }\n+â”Š   â”Š 49â”Š\n+â”Š   â”Š 50â”Š      return width + this.data.chars[c].width;\n+â”Š   â”Š 51â”Š    }, 0);\n+â”Š   â”Š 52â”Š\n+â”Š   â”Š 53â”Š    // A custom size can be specified for a font as well\n+â”Š   â”Š 54â”Š    if (this.size) {\n+â”Š   â”Š 55â”Š      let ratio = this.size / this.data.size;\n+â”Š   â”Š 56â”Š      canvas.height *= ratio;\n+â”Š   â”Š 57â”Š      canvas.width *= ratio;\n+â”Š   â”Š 58â”Š      context.scale(ratio, ratio);\n+â”Š   â”Š 59â”Š    }\n+â”Š   â”Š 60â”Š\n+â”Š   â”Š 61â”Š    // No we are going to draw each char on the canvas individually,\n+â”Š   â”Š 62â”Š    // naturally, there should be an offset after we draw each character.\n+â”Š   â”Š 63â”Š    // This variable will be used to calculate the offset\n+â”Š   â”Š 64â”Š    let offset = 0;\n+â”Š   â”Š 65â”Š\n+â”Š   â”Š 66â”Š    // Get for each char\n+â”Š   â”Š 67â”Š    _.map(text, (char) => {\n+â”Š   â”Š 68â”Š      return this.getCharSprite(char);\n+â”Š   â”Š 69â”Š    })\n+â”Š   â”Š 70â”Š    // Start drawing each char on the canvas\n+â”Š   â”Š 71â”Š    .forEach((charSprite, index) => {\n+â”Š   â”Š 72â”Š      let charData = this.data.chars[text.charAt(index)];\n+â”Š   â”Š 73â”Š\n+â”Š   â”Š 74â”Š      // Each char in the font xml has a native offset in addition to its rectangle.\n+â”Š   â”Š 75â”Š      // This option will disable the calculation of the native offset\n+â”Š   â”Š 76â”Š      if (noOffsets) {\n+â”Š   â”Š 77â”Š        charSprite.draw(context, offset);\n+â”Š   â”Š 78â”Š      }\n+â”Š   â”Š 79â”Š      else {\n+â”Š   â”Š 80â”Š        charSprite.draw(context, offset + charData.offset.x, charData.offset.y);\n+â”Š   â”Š 81â”Š      }\n+â”Š   â”Š 82â”Š\n+â”Š   â”Š 83â”Š      if (noSpaces) {\n+â”Š   â”Š 84â”Š        offset += charSprite.width;\n+â”Š   â”Š 85â”Š      }\n+â”Š   â”Š 86â”Š      else {\n+â”Š   â”Š 87â”Š        offset += charData.width;\n+â”Š   â”Š 88â”Š      }\n+â”Š   â”Š 89â”Š\n+â”Š   â”Š 90â”Š      // A color for the font can be specified as well\n+â”Š   â”Š 91â”Š      if (this.color) {\n+â”Š   â”Š 92â”Š        let overlayCanvas = document.createElement(\"canvas\");\n+â”Š   â”Š 93â”Š        let overlayContext = overlayCanvas.getContext(\"2d\");\n+â”Š   â”Š 94â”Š        overlayCanvas.width = width;\n+â”Š   â”Š 95â”Š        overlayCanvas.height = height;\n+â”Š   â”Š 96â”Š        overlayContext.beginPath();\n+â”Š   â”Š 97â”Š        overlayContext.rect(0, 0, width, height);\n+â”Š   â”Š 98â”Š        overlayContext.fillStyle = this.color;\n+â”Š   â”Š 99â”Š        overlayContext.fill();\n+â”Š   â”Š100â”Š\n+â”Š   â”Š101â”Š        context.save();\n+â”Š   â”Š102â”Š        context.globalCompositeOperation = \"source-in\";\n+â”Š   â”Š103â”Š        context.drawImage(overlayCanvas, 0, 0);\n+â”Š   â”Š104â”Š        context.restore();\n+â”Š   â”Š105â”Š      }\n+â”Š   â”Š106â”Š    });\n+â”Š   â”Š107â”Š\n+â”Š   â”Š108â”Š    // The canvas will be treated like an image\n+â”Š   â”Š109â”Š    return canvas;\n+â”Š   â”Š110â”Š  }\n+â”Š   â”Š111â”Š\n+â”Š   â”Š112â”Š  // Gets a sprite of the given char, using the current font\n+â”Š   â”Š113â”Š  getCharSprite(char) {\n+â”Š   â”Š114â”Š    // If char is already stored in cache, abort calculation and return it\n+â”Š   â”Š115â”Š    if (this.charSpritesCache[char]) return this.charSpritesCache[char];\n+â”Š   â”Š116â”Š\n+â”Š   â”Š117â”Š    // This data is fetched by the given json\n+â”Š   â”Š118â”Š    let { x, y, width, height } = this.data.chars[char].rect;\n+â”Š   â”Š119â”Š    // Creating a canvas which we will use to draw on,\n+â”Š   â”Š120â”Š    // but it is used exactly like an image afterwards\n+â”Š   â”Š121â”Š    let canvas = document.createElement(\"canvas\");\n+â”Š   â”Š122â”Š    let context = canvas.getContext(\"2d\");\n+â”Š   â”Š123â”Š\n+â”Š   â”Š124â”Š    // The canvas will have the same dimensions as the font\n+â”Š   â”Š125â”Š    canvas.width = width;\n+â”Š   â”Š126â”Š    canvas.height = height;\n+â”Š   â”Š127â”Š    // Draw a cropped image from the atlas, this image contains the char font\n+â”Š   â”Š128â”Š    context.drawImage(this.atlas, x, y, width, height, 0, 0, width, height);\n+â”Š   â”Š129â”Š\n+â”Š   â”Š130â”Š    // Store in cache and return it\n+â”Š   â”Š131â”Š    return this.charSpritesCache[char] = new Engine.Sprite(canvas);\n+â”Š   â”Š132â”Š  }\n+â”Š   â”Š133â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -10,6 +10,7 @@\n â”Š10â”Š10â”Š    <!-- Scripts -->\n â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n â”Š12â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/restorable.js\"></script>\n+â”Š  â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/font.js\"></script>\n â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/sprite.js\"></script>\n â”Š14â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/animations/keyframe.js\"></script>\n â”Š15â”Š16â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/key_states.js\"></script>\n```\n\n[}]: #\n\nThe font API shares a similar API as [HTMLImageElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/Image), once we set the `src` property the font will start loading itself, and the `onload` user-defined callback should be called once finished. Another neat feature would be the `createTexture` method, which takes a string as its first argument, representing the text that we would like to generate, and returns an instance of the `Sprite` class.\n\nWe will also be adding the option to load some font assets in our asset-loader:\n\n[{]: <helper> (diffStep 4.13)\n\n#### [Step 4.13: Add a font loading option to &#x27;AssetLoader&#x27;](https://github.com/DAB0mB/radial-snake/commit/a9d73cc)\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;assets_loader.js\n```diff\n@@ -10,4 +10,12 @@\n â”Š10â”Š10â”Š    image.src = `${path}.png`;\n â”Š11â”Š11â”Š    return image;\n â”Š12â”Š12â”Š  }\n+â”Š  â”Š13â”Š\n+â”Š  â”Š14â”Š  // Load font\n+â”Š  â”Š15â”Š  font(path) {\n+â”Š  â”Š16â”Š    let font = new Engine.Font();\n+â”Š  â”Š17â”Š    font.onload = this.next();\n+â”Š  â”Š18â”Š    font.src = path;\n+â”Š  â”Š19â”Š    return font;\n+â”Š  â”Š20â”Š  }\n â”Š13â”Š21â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nAnd replace the instructions texture loading with a `minecraftia` font loading in the initial splash screen:\n\n[{]: <helper> (diffStep 4.14)\n\n#### [Step 4.14: Load &#x27;minecraftia&#x27; font in splash screen](https://github.com/DAB0mB/radial-snake/commit/231a68f)\n\n##### Changed resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;splash&#x2F;index.js\n```diff\n@@ -33,7 +33,7 @@\n â”Š33â”Š33â”Š\n â”Š34â”Š34â”Š  load(assetsLoader) {\n â”Š35â”Š35â”Š    // Load assets\n-â”Š36â”Š  â”Š    let instructionsTexture = assetsLoader.texture(\"/textures/instrucitons\");\n+â”Š  â”Š36â”Š    let minecraftiaFont = assetsLoader.font(\"/fonts/minecraftia\");\n â”Š37â”Š37â”Š    let logoTexture = assetsLoader.texture(\"/textures/logo\");\n â”Š38â”Š38â”Š    let splashTexture = assetsLoader.texture(\"/textures/splash\");\n â”Š39â”Š39â”Š\n```\n```diff\n@@ -41,7 +41,7 @@\n â”Š41â”Š41â”Š    // disposed. We use the time gap created by the splash animation to load necessary\n â”Š42â”Š42â”Š    // assets without wasting any time\n â”Š43â”Š43â”Š    this.game.extendAssets({\n-â”Š44â”Š  â”Š      instructionsTexture,\n+â”Š  â”Š44â”Š      minecraftiaFont,\n â”Š45â”Š45â”Š      logoTexture\n â”Š46â”Š46â”Š    });\n```\n\n[}]: #\n\nNow it can use us in the main menu screen where we will create a text-sprite saying `Press a key to start`, just like the instruction sprite we're about to replace:\n\n[{]: <helper> (diffStep 4.15)\n\n#### [Step 4.15: Replace texture usage with font usage in main menu screen](https://github.com/DAB0mB/radial-snake/commit/a769b81)\n\n##### Changed resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;menu&#x2F;index.js\n```diff\n@@ -5,7 +5,8 @@\n â”Š 5â”Š 5â”Š    this.logoSprite.setPercentage(\"width\", this.width, 30, \"height\");\n â”Š 6â”Š 6â”Š\n â”Š 7â”Š 7â”Š    // Initialize instructions sprite\n-â”Š 8â”Š  â”Š    let instructionsSprite = new Engine.Sprite(this.assets.instructionsTexture);\n+â”Š  â”Š 8â”Š    let instructionsTexture = this.assets.minecraftiaFont.createTexture(\"Press a key to start\");\n+â”Š  â”Š 9â”Š    let instructionsSprite = new Engine.Sprite(instructionsTexture);\n â”Š 9â”Š10â”Š    instructionsSprite.align = \"center\";\n â”Š10â”Š11â”Š    instructionsSprite.setPercentage(\"width\", this.width, 35, \"height\");\n â”Š11â”Š12â”Š    instructionsSprite.x = this.width / 2;\n```\n```diff\n@@ -30,7 +31,7 @@\n â”Š30â”Š31â”Š\n â”Š31â”Š32â”Š  unload() {\n â”Š32â”Š33â”Š    // Dispose the following assets to prevent memory leaks\n-â”Š33â”Š  â”Š    return [\"logoTexture\", \"instructionsTexture\"];\n+â”Š  â”Š34â”Š    return \"logoTexture\";\n â”Š34â”Š35â”Š  }\n â”Š35â”Š36â”Š\n â”Š36â”Š37â”Š  draw(context) {\n```\n```diff\n@@ -41,4 +42,8 @@\n â”Š41â”Š42â”Š  update(span) {\n â”Š42â”Š43â”Š    this.instructionsAnim.update(span);\n â”Š43â”Š44â”Š  }\n+â”Š  â”Š45â”Š\n+â”Š  â”Š46â”Š  update(span) {\n+â”Š  â”Š47â”Š    this.instructionsAnim.update(span);\n+â”Š  â”Š48â”Š  }\n â”Š44â”Š49â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nIt shouldn't look any different from the beginning of the step where we manually drew the instruction texture, but in the next steps we will be using the font-engine a lot, and you will be thankful for what we've just did."
          },
          {
            "manualTitle": "Step 5: Creating a snake and related geometry shapes",
            "stepRevision": "ad178e03e276b088c96d6f67889db379ad201e3e",
            "manualView": "![snake-illustrate](https://cloud.githubusercontent.com/assets/7648874/21074115/46ef4466-bed7-11e6-9d5d-12fa6d43147b.gif)\n\nIn this step we will be creating all the necessary geometry shapes to form a snake; we're basically implementing the right infrastructure so in the next step we will be able to implement the game screen with ease. What exactly do I mean by \"geometry shapes\"? Well, our snake will be made out of circles, and lines. If we don't press any buttons at all, the snake should move forward at a straight line, and once we press on one of the arrow keys, the snake should move in a circular motion. Not only we want to draw the screen on the canvas, we also want to be able to detect collision with other snakes, since this is a \"Tron\" style game where we gonna fight against an opponent.\n\nKeep in mind that a computer's precision is limited due its [binary representation in memory](https://en.wikipedia.org/wiki/Memory_cell_(binary)). We need to take into consideration that there might be a significant deviation when detecting collisions and intersections between geometry shapes, especially when elapsed time is not always guaranteed to stay precise. To handle these deviation issues, we're gonna create some utility functions and place then in a new module called `Utils`:\n\n[{]: <helper> (diffStep 5.1)\n\n#### [Step 5.1: Create utilities module](https://github.com/DAB0mB/radial-snake/commit/58ae99a)\n\n##### Added resources&#x2F;scripts&#x2F;utils.js\n```diff\n@@ -0,0 +1,68 @@\n+â”Š  â”Š 1â”Š// A wrapper function for our utilities which will enable chaining\n+â”Š  â”Š 2â”Š// e.g. Utils().mod().trim().isBetween()...\n+â”Š  â”Š 3â”ŠUtils = function Utils(context) {\n+â”Š  â”Š 4â”Š  const chain = {};\n+â”Š  â”Š 5â”Š\n+â”Š  â”Š 6â”Š  Object.keys(Utils).forEach((utilName) => {\n+â”Š  â”Š 7â”Š    chain[utilName] = (...args) => {\n+â”Š  â”Š 8â”Š      const result = Utils[utilName](context, ...args);\n+â”Š  â”Š 9â”Š      return Utils(result);\n+â”Š  â”Š10â”Š    };\n+â”Š  â”Š11â”Š  });\n+â”Š  â”Š12â”Š\n+â”Š  â”Š13â”Š  // Returns the result of the chaining\n+â”Š  â”Š14â”Š  chain.value = () => context;\n+â”Š  â”Š15â”Š\n+â”Š  â”Š16â”Š  return chain;\n+â”Š  â”Š17â”Š};\n+â”Š  â”Š18â”Š\n+â”Š  â”Š19â”Š// Fixed modulo method which can calculate modulo of negative numbers properly\n+â”Š  â”Š20â”Š// e.g. (-803).mod(800) returns 797\n+â”Š  â”Š21â”ŠUtils.mod = function (context, num) {\n+â”Š  â”Š22â”Š  return ((context % num) + num) % num;\n+â”Š  â”Š23â”Š};\n+â”Š  â”Š24â”Š\n+â”Š  â”Š25â”Š// Trims number and leaves the number of decimals specified.\n+â”Š  â”Š26â”Š// The \"mode\" argument specifies which math function should be invoked\n+â”Š  â”Š27â”Š// right after the number has been trimmed.\n+â”Š  â”Š28â”Š// e.g. 12.12345.trim(3, \"ceil\") returns 12.124\n+â”Š  â”Š29â”ŠUtils.trim = function (context, decimals, mode = \"round\") {\n+â”Š  â”Š30â”Š  return Math[mode](context * Math.pow(10, decimals)) / Math.pow(10, decimals);\n+â”Š  â”Š31â”Š};\n+â”Š  â”Š32â”Š\n+â”Š  â”Š33â”Š// Tells if number is in specified range based on given precision.\n+â”Š  â”Š34â”Š// See the \"compare\" method for more information about precision\n+â”Š  â”Š35â”ŠUtils.isBetween = function (context, num1, num2, precision) {\n+â”Š  â”Š36â”Š  return Utils.compare(context, Math.min(num1, num2), \">=\", precision) &&\n+â”Š  â”Š37â”Š         Utils.compare(context, Math.max(num1, num2), \"<=\", precision);\n+â”Š  â”Š38â”Š};\n+â”Š  â”Š39â”Š\n+â”Š  â”Š40â”Š// Initiates comparison operator between context number and a given number, only here\n+â”Š  â”Š41â”Š// a precision can be specified\n+â”Š  â”Š42â”ŠUtils.compare = function (context, num, method, precision = method) {\n+â”Š  â”Š43â”Š  switch (precision) {\n+â”Š  â”Š44â”Š    // Fixed precision, \"almost equal\" with a deviation of Îµ\n+â”Š  â”Š45â”Š    case \"f\":\n+â”Š  â”Š46â”Š      switch (method) {\n+â”Š  â”Š47â”Š        case \"<\": case \"<=\": return context <= num + Number.EPSILON;\n+â”Š  â”Š48â”Š        case \">\": case \">=\": return context >= num - Number.EPSILON;\n+â”Š  â”Š49â”Š        default: return Math.abs(context - num) <= Number.EPSILON;\n+â”Š  â”Š50â”Š      }\n+â”Š  â”Š51â”Š    // Pixel precision, round comparison\n+â”Š  â”Š52â”Š    case \"px\":\n+â”Š  â”Š53â”Š      switch (method) {\n+â”Š  â”Š54â”Š        case \"<\": case \"<=\": return Math.round(context) <= Math.round(num);\n+â”Š  â”Š55â”Š        case \">\": case \">=\": return Math.round(context) >= Math.round(num);\n+â”Š  â”Š56â”Š        default: return Math.round(context) == Math.round(num);\n+â”Š  â”Š57â”Š      }\n+â”Š  â”Š58â”Š    // Exact precision\n+â”Š  â”Š59â”Š    default:\n+â”Š  â”Š60â”Š      switch (method) {\n+â”Š  â”Š61â”Š        case \"<\": return context < num;\n+â”Š  â”Š62â”Š        case \"<=\": return context <= num;\n+â”Š  â”Š63â”Š        case \">\": return context > num;\n+â”Š  â”Š64â”Š        case \">=\": return context >= num;\n+â”Š  â”Š65â”Š        default: return context === num;\n+â”Š  â”Š66â”Š      }\n+â”Š  â”Š67â”Š  }\n+â”Š  â”Š68â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -8,6 +8,7 @@\n â”Š 8â”Š 8â”Š    <script type=\"text/javascript\" src=\"/libs/underscore.js\"></script>\n â”Š 9â”Š 9â”Š\n â”Š10â”Š10â”Š    <!-- Scripts -->\n+â”Š  â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/utils.js\"></script>\n â”Š11â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n â”Š12â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/restorable.js\"></script>\n â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/font.js\"></script>\n```\n\n[}]: #\n\nNow we would like to start implementing the first class representation for a line, and for that we're requires to add a new module called `Geometry` to the `Engine` namespace:\n\n[{]: <helper> (diffStep 5.2)\n\n#### [Step 5.2: Add &#x27;Shapes&#x27; module to &#x27;Engine&#x27; namespace](https://github.com/DAB0mB/radial-snake/commit/4ed2788)\n\n##### Changed resources&#x2F;scripts&#x2F;namespaces.js\n```diff\n@@ -3,5 +3,6 @@\n â”Š3â”Š3â”Š};\n â”Š4â”Š4â”Š\n â”Š5â”Š5â”ŠEngine = {\n-â”Š6â”Š â”Š  Animations: {}\n+â”Š â”Š6â”Š  Animations: {},\n+â”Š â”Š7â”Š  Geometry: {}\n â”Š7â”Š8â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nAnd now that we have this module available to use, we can go ahead and implement our first geometry shape class - `Line`:\n\n[{]: <helper> (diffStep 5.3)\n\n#### [Step 5.3: Create &#x27;Line&#x27; class](https://github.com/DAB0mB/radial-snake/commit/fb38ab5)\n\n##### Added resources&#x2F;scripts&#x2F;engine&#x2F;geometry&#x2F;line.js\n```diff\n@@ -0,0 +1,65 @@\n+â”Š  â”Š 1â”ŠEngine.Geometry.Line = class Line {\n+â”Š  â”Š 2â”Š  // x1 - The first point's x value\n+â”Š  â”Š 3â”Š  // y1 - The first point's y value\n+â”Š  â”Š 4â”Š  // x1 - The second point's x value\n+â”Š  â”Š 5â”Š  // y2 - The second point's y value\n+â”Š  â”Š 6â”Š  constructor(x1, y1, x2, y2) {\n+â”Š  â”Š 7â”Š    this.x1 = Utils.trim(x1, 9);\n+â”Š  â”Š 8â”Š    this.y1 = Utils.trim(y1, 9);\n+â”Š  â”Š 9â”Š    this.x2 = Utils.trim(x2, 9);\n+â”Š  â”Š10â”Š    this.y2 = Utils.trim(y2, 9);\n+â”Š  â”Š11â”Š  }\n+â”Š  â”Š12â”Š\n+â”Š  â”Š13â”Š  // Draws the line on the given context\n+â”Š  â”Š14â”Š  draw(context) {\n+â”Š  â”Š15â”Š    context.moveTo(this.x1, this.y1);\n+â”Š  â”Š16â”Š    context.lineTo(this.x2, this.y2);\n+â”Š  â”Š17â”Š  }\n+â”Š  â”Š18â”Š\n+â”Š  â”Š19â”Š  // Gets the matching x value for a given y value\n+â”Š  â”Š20â”Š  getX(y) {\n+â”Š  â”Š21â”Š    let x = Utils.trim((((y - this.y1) * (this.x2 - this.x1)) / (this.y2 - this.y1)) + this.x1, 9);\n+â”Š  â”Š22â”Š    if (isNaN(x) || Utils.isBetween(x, this.x1, this.x2)) return x;\n+â”Š  â”Š23â”Š  }\n+â”Š  â”Š24â”Š\n+â”Š  â”Š25â”Š  // Gets the matching y value for a given x value\n+â”Š  â”Š26â”Š  getY(x) {\n+â”Š  â”Š27â”Š    let y = Utils.trim((((x - this.x1) * (this.y2 - this.y1)) / (this.x2 - this.x1)) + this.y1, 9);\n+â”Š  â”Š28â”Š    if (isNaN(y) || Utils.isBetween(y, this.y1, this.y2)) return y;\n+â”Š  â”Š29â”Š  }\n+â”Š  â”Š30â”Š\n+â”Š  â”Š31â”Š  // Returns if line has given point\n+â”Š  â”Š32â”Š  hasPoint(x, y) {\n+â”Š  â”Š33â”Š    if (!this.boundsHavePoint(x, y)) return false;\n+â”Š  â”Š34â”Š    let m = Utils.trim((this.y2 - this.y1) / (this.x2 - this.x1), 9);\n+â”Š  â”Š35â”Š    return (y - this.y1) / (x - this.x1) == m;\n+â”Š  â”Š36â”Š  }\n+â”Š  â”Š37â”Š\n+â”Š  â”Š38â”Š  // Returns if given point is contained by the bounds aka cage of line\n+â”Š  â”Š39â”Š  boundsHavePoint(x, y) {\n+â”Š  â”Š40â”Š    return Utils.isBetween(x, this.x1, this.x2) &&\n+â”Š  â”Š41â”Š           Utils.isBetween(y, this.y1, this.y2);\n+â”Š  â”Š42â”Š  }\n+â”Š  â”Š43â”Š\n+â”Š  â”Š44â”Š  getIntersection(shape) {\n+â”Š  â”Š45â”Š    if (shape instanceof Engine.Geometry.Line)\n+â”Š  â”Š46â”Š      return this.getLineIntersection(shape);\n+â”Š  â”Š47â”Š  }\n+â”Š  â”Š48â”Š\n+â”Š  â”Š49â”Š  // line - line intersection method\n+â”Š  â”Š50â”Š  getLineIntersection(line) {\n+â”Š  â”Š51â”Š    // Escape if lines are parallel\n+â”Š  â”Š52â”Š    if (!(((this.x1 - this.x2) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * (line.x1 - line.x2)))) return;\n+â”Š  â”Š53â”Š\n+â”Š  â”Š54â”Š    // Intersection point formula\n+â”Š  â”Š55â”Š    let x = Utils.trim(((((this.x1 * this.y2) - (this.y1 * this.x2)) * (line.x1 - line.x2)) - ((this.x1 - this.x2) * ((line.x1 * line.y2) - (line.y1 * line.x2)))) /\n+â”Š  â”Š56â”Š        (((this.x1 - this.x2) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * (line.x1 - line.x2))), 9);\n+â”Š  â”Š57â”Š    let y = Utils.trim(((((this.x1 * this.y2) - (this.y1 * this.x2)) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * ((line.x1 * line.y2) - (line.y1 * line.x2)))) /\n+â”Š  â”Š58â”Š        (((this.x1 - this.x2) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * (line.x1 - line.x2))), 9);\n+â”Š  â”Š59â”Š\n+â”Š  â”Š60â”Š    if (Utils.isBetween(x, this.x1, this.x2) && Utils.isBetween(x, line.x1, line.x2) &&\n+â”Š  â”Š61â”Š        Utils.isBetween(y, this.y1, this.y2) && Utils.isBetween(y, line.y1, line.y2)) {\n+â”Š  â”Š62â”Š      return { x, y };\n+â”Š  â”Š63â”Š    }\n+â”Š  â”Š64â”Š  }\n+â”Š  â”Š65â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -10,6 +10,7 @@\n â”Š10â”Š10â”Š    <!-- Scripts -->\n â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/utils.js\"></script>\n â”Š12â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n+â”Š  â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/geometry/line.js\"></script>\n â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/restorable.js\"></script>\n â”Š14â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/font.js\"></script>\n â”Š15â”Š16â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/sprite.js\"></script>\n```\n\n[}]: #\n\nYou can go through the comments of the step above which will guide you through the programmatic aspect of it, but I think it's more important to understand the concept of a line in 2D space. A line is made out of two points, usually represented as `(x1, y1)` and `(x2, y2)`. The slope of the line, usually represented as `m`, can be determined using these two points based on the following formula:\n\n![slope](https://cloud.githubusercontent.com/assets/7648874/21788249/b4c7e41c-d6b4-11e6-9c17-baff66ec6bc8.png)\n\nOnce we have two lines whose `m` is different (Unparalleled) and there is no intersection between the points of which they are represented with (In which case they are united), there must be an intersection point. The intersection point can be found using the following formula:\n\n![line-line](https://cloud.githubusercontent.com/assets/7648874/21787164/c9d83bf0-d6ae-11e6-9846-4fc013eebab3.png)\n\n![line-line-illustration](https://cloud.githubusercontent.com/assets/7648874/21790864/56725cf0-d6c6-11e6-916b-50b1fc0b87af.png)\n\n> See reference: http://mathworld.wolfram.com/Line-LineIntersection.html.\n\nObviously we have some logic here which needs to be tested. To test our `Line` class, we will be using a testing framework called [Jasmine](https://jasmine.github.io/). We first need to download `Jasmine`'s essentials in order for it to work:\n\n    resources/libs$ mkdir jasmine\n    resources/libs$ cd jasmine\n    resources/libs/jasmine$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/libs/jasmine/boot.js\n    resources/libs/jasmine$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/libs/jasmine/console.js\n    resources/libs/jasmine$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/libs/jasmine/jasmine-html.js\n    resources/libs/jasmine$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/libs/jasmine/jasmine.css\n    resources/libs/jasmine$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/libs/jasmine/jasmine.js\n    resources/libs/jasmine$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/libs/jasmine/jasmine_favicon.png\n\nThese essentials should be loaded in a newly created view where we're gonna see our specs running:\n\n[{]: <helper> (diffStep 5.5)\n\n#### [Step 5.5: Create specs runner view](https://github.com/DAB0mB/radial-snake/commit/150be1a)\n\n##### Added views&#x2F;spec_runner.html\n```diff\n@@ -0,0 +1,27 @@\n+â”Š  â”Š 1â”Š\n+â”Š  â”Š 2â”Š<!DOCTYPE html>\n+â”Š  â”Š 3â”Š<html>\n+â”Š  â”Š 4â”Š  <head>\n+â”Š  â”Š 5â”Š    <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n+â”Š  â”Š 6â”Š    <title>Jasmine Spec Runner v2.0.1</title>\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Š    <!-- Jasmine -->\n+â”Š  â”Š 9â”Š    <script type=\"text/javascript\" src=\"libs/jasmine/jasmine.js\"></script>\n+â”Š  â”Š10â”Š    <script type=\"text/javascript\" src=\"libs/jasmine/jasmine-html.js\"></script>\n+â”Š  â”Š11â”Š    <script type=\"text/javascript\" src=\"libs/jasmine/boot.js\"></script>\n+â”Š  â”Š12â”Š    <link rel=\"shortcut icon\" type=\"image/png\" href=\"libs/jasmine/jasmine_favicon.png\">\n+â”Š  â”Š13â”Š    <link rel=\"stylesheet\" type=\"text/css\" href=\"libs/jasmine/jasmine.css\">\n+â”Š  â”Š14â”Š\n+â”Š  â”Š15â”Š    <!-- Libs -->\n+â”Š  â”Š16â”Š    <script type=\"text/javascript\" src=\"libs/underscore.js\"></script>\n+â”Š  â”Š17â”Š\n+â”Š  â”Š18â”Š    <!-- Scripts -->\n+â”Š  â”Š19â”Š    <script type=\"text/javascript\" src=\"scripts/utils.js\"></script>\n+â”Š  â”Š20â”Š    <script type=\"text/javascript\" src=\"scripts/namespaces.js\"></script>\n+â”Š  â”Š21â”Š\n+â”Š  â”Š22â”Š    <!-- Specs -->\n+â”Š  â”Š23â”Š  </head>\n+â”Š  â”Š24â”Š\n+â”Š  â”Š25â”Š  <body>\n+â”Š  â”Š26â”Š  </body>\n+â”Š  â”Š27â”Š</html>ðŸš«â†µ\n```\n\n[}]: #\n\nNow once we'll navigate to the `/test` sub-route (`localhost:8000/test` by default) we should be provided with the spec runner. As for now there are no specs implemented at all, which brings us to the next stage - Implementing tests for `Line` class:\n\n[{]: <helper> (diffStep 5.6)\n\n#### [Step 5.6: Create &#x27;Line&#x27; class tests](https://github.com/DAB0mB/radial-snake/commit/c052752)\n\n##### Added resources&#x2F;scripts&#x2F;specs&#x2F;engine&#x2F;geometry&#x2F;line.js\n```diff\n@@ -0,0 +1,78 @@\n+â”Š  â”Š 1â”Šdescribe(\"Engine.Geometry.Line class\", function() {\n+â”Š  â”Š 2â”Š  beforeEach(function() {\n+â”Š  â”Š 3â”Š    this.line = new Engine.Geometry.Line(-5, -5, 5, 5);\n+â”Š  â”Š 4â”Š  });\n+â”Š  â”Š 5â”Š\n+â”Š  â”Š 6â”Š  describe(\"getX method\", function() {\n+â”Š  â”Š 7â”Š    describe(\"given inranged y\", function() {\n+â”Š  â”Š 8â”Š      it(\"returns x\", function() {\n+â”Š  â”Š 9â”Š        expect(this.line.getX(1)).toBeCloseTo(1);\n+â”Š  â”Š10â”Š      });\n+â”Š  â”Š11â”Š    });\n+â”Š  â”Š12â”Š\n+â”Š  â”Š13â”Š    describe(\"given outranged y\", function() {\n+â”Š  â”Š14â”Š      it(\"returns nothing\", function() {\n+â”Š  â”Š15â”Š        expect(this.line.getX(10)).toBeUndefined();\n+â”Š  â”Š16â”Š      });\n+â”Š  â”Š17â”Š    });\n+â”Š  â”Š18â”Š  });\n+â”Š  â”Š19â”Š\n+â”Š  â”Š20â”Š  describe(\"getY method\", function() {\n+â”Š  â”Š21â”Š    describe(\"given inranged x\", function() {\n+â”Š  â”Š22â”Š      it(\"returns y\", function() {\n+â”Š  â”Š23â”Š        expect(this.line.getY(1)).toBeCloseTo(1);\n+â”Š  â”Š24â”Š      });\n+â”Š  â”Š25â”Š    });\n+â”Š  â”Š26â”Š\n+â”Š  â”Š27â”Š    describe(\"given outranged x\", function() {\n+â”Š  â”Š28â”Š      it(\"returns nothing\", function() {\n+â”Š  â”Š29â”Š        expect(this.line.getY(10)).toBeUndefined();\n+â”Š  â”Š30â”Š      });\n+â”Š  â”Š31â”Š    });\n+â”Š  â”Š32â”Š  });\n+â”Š  â”Š33â”Š\n+â”Š  â”Š34â”Š  describe(\"hasPoint method\", function() {\n+â”Š  â”Š35â”Š    describe(\"given contained point\", function() {\n+â”Š  â”Š36â”Š      it(\"returns true\", function() {\n+â”Š  â”Š37â”Š        let x = 1;\n+â”Š  â”Š38â”Š        let y = 1;\n+â”Š  â”Š39â”Š        expect(this.line.hasPoint(x, y)).toBeTruthy();\n+â”Š  â”Š40â”Š      });\n+â”Š  â”Š41â”Š    });\n+â”Š  â”Š42â”Š\n+â”Š  â”Š43â”Š    describe(\"given uncontained point\", function() {\n+â”Š  â”Š44â”Š      it(\"returns false\", function() {\n+â”Š  â”Š45â”Š        let x = 10;\n+â”Š  â”Š46â”Š        let y = 10;\n+â”Š  â”Š47â”Š        expect(this.line.hasPoint(x, y)).toBeFalsy();\n+â”Š  â”Š48â”Š      });\n+â”Š  â”Š49â”Š    });\n+â”Š  â”Š50â”Š  });\n+â”Š  â”Š51â”Š\n+â”Š  â”Š52â”Š  describe(\"getLineIntersection method\", function() {\n+â”Š  â”Š53â”Š    describe(\"given intersecting line\", function() {\n+â”Š  â”Š54â”Š      it(\"returns intersection point\", function() {\n+â”Š  â”Š55â”Š        let line = new Engine.Geometry.Line(1, -5, 1, 5);\n+â”Š  â”Š56â”Š\n+â”Š  â”Š57â”Š        expect(this.line.getLineIntersection(line)).toEqual({\n+â”Š  â”Š58â”Š          x: 1,\n+â”Š  â”Š59â”Š          y: 1\n+â”Š  â”Š60â”Š        });\n+â”Š  â”Š61â”Š      });\n+â”Š  â”Š62â”Š    });\n+â”Š  â”Š63â”Š\n+â”Š  â”Š64â”Š    describe(\"given parallel line\", function() {\n+â”Š  â”Š65â”Š      it(\"returns nothing\", function() {\n+â”Š  â”Š66â”Š        let line = new Engine.Geometry.Line(-5, -6, 5, 4);\n+â”Š  â”Š67â”Š        expect(this.line.getLineIntersection(line)).toBeUndefined();\n+â”Š  â”Š68â”Š      });\n+â”Š  â”Š69â”Š    });\n+â”Š  â”Š70â”Š\n+â”Š  â”Š71â”Š    describe(\"given outranged line\", function() {\n+â”Š  â”Š72â”Š      it(\"returns nothing\", function() {\n+â”Š  â”Š73â”Š        let line = new Engine.Geometry.Line(10, 10, 10, 15);\n+â”Š  â”Š74â”Š        expect(this.line.getLineIntersection(line)).toBeUndefined();\n+â”Š  â”Š75â”Š      });\n+â”Š  â”Š76â”Š    });\n+â”Š  â”Š77â”Š  });\n+â”Š  â”Š78â”Š});ðŸš«â†µ\n```\n\n##### Changed views&#x2F;spec_runner.html\n```diff\n@@ -18,8 +18,10 @@\n â”Š18â”Š18â”Š    <!-- Scripts -->\n â”Š19â”Š19â”Š    <script type=\"text/javascript\" src=\"scripts/utils.js\"></script>\n â”Š20â”Š20â”Š    <script type=\"text/javascript\" src=\"scripts/namespaces.js\"></script>\n+â”Š  â”Š21â”Š    <script type=\"text/javascript\" src=\"scripts/engine/geometry/line.js\"></script>\n â”Š21â”Š22â”Š\n â”Š22â”Š23â”Š    <!-- Specs -->\n+â”Š  â”Š24â”Š    <script type=\"text/javascript\" src=\"scripts/specs/engine/geometry/line.js\"></script>\n â”Š23â”Š25â”Š  </head>\n â”Š24â”Š26â”Š\n â”Š25â”Š27â”Š  <body>\n```\n\n[}]: #\n\nNow if you'll refresh the spec runner page you should be able to a green screen indicating all tests have passed (Assuming the tutorial is updated and you followed it correctly). As introduced at the beginning of the step, the snake is also dependent on circles, whose representing class should look like so:\n\n[{]: <helper> (diffStep 5.7)\n\n#### [Step 5.7: Create &#x27;Circle&#x27; class](https://github.com/DAB0mB/radial-snake/commit/f9c5723)\n\n##### Added resources&#x2F;scripts&#x2F;engine&#x2F;geometry&#x2F;circle.js\n```diff\n@@ -0,0 +1,167 @@\n+â”Š   â”Š  1â”ŠEngine.Geometry.Circle = class Circle {\n+â”Š   â”Š  2â”Š  // x - The x value of the circle's center\n+â”Š   â”Š  3â”Š  // y - The y value of the circle's center\n+â”Š   â”Š  4â”Š  // r - The radius of the center\n+â”Š   â”Š  5â”Š  // rad1 - The first radian of the circle, not necessarily its beginning\n+â”Š   â”Š  6â”Š  // rad2 - The second radian of the circle, not necessarily its beginning\n+â”Š   â”Š  7â”Š  constructor(x, y, r, rad1, rad2) {\n+â”Š   â”Š  8â”Š    this.x = Utils.trim(x, 9);\n+â”Š   â”Š  9â”Š    this.y = Utils.trim(y, 9);\n+â”Š   â”Š 10â”Š    this.r = Utils.trim(r, 9);\n+â”Š   â”Š 11â”Š\n+â”Š   â”Š 12â”Š    // Trimming mode is done based on which radian represents the ending and which radian\n+â”Š   â”Š 13â”Š    // represents the ending\n+â”Š   â”Š 14â”Š    if (rad1 > rad2) {\n+â”Š   â”Š 15â”Š      this.rad1 = Utils.trim(rad1, 9, \"floor\");\n+â”Š   â”Š 16â”Š      this.rad2 = Utils.trim(rad2, 9, \"ceil\");\n+â”Š   â”Š 17â”Š    }\n+â”Š   â”Š 18â”Š    else {\n+â”Š   â”Š 19â”Š      this.rad1 = Utils.trim(rad1, 9, \"ceil\");\n+â”Š   â”Š 20â”Š      this.rad2 = Utils.trim(rad2, 9, \"floor\");\n+â”Š   â”Š 21â”Š    }\n+â”Š   â”Š 22â”Š  }\n+â”Š   â”Š 23â”Š\n+â”Š   â”Š 24â”Š  // Draws the circle on the given context\n+â”Š   â”Š 25â”Š  draw(context) {\n+â”Š   â”Š 26â”Š    context.arc(this.x, this.y, this.r, this.rad1, this.rad2);\n+â”Š   â”Š 27â”Š  }\n+â”Š   â”Š 28â”Š\n+â”Š   â”Š 29â”Š  // Gets the matching x value for the given radian\n+â”Š   â”Š 30â”Š  getX(rad) {\n+â”Š   â”Š 31â”Š    if (!Utils(rad).trim(9).isBetween(this.rad1, this.rad2).value()) return;\n+â”Š   â”Š 32â”Š    return Utils.trim((this.r * Math.cos(rad)) + this.x, 9);\n+â”Š   â”Š 33â”Š  }\n+â”Š   â”Š 34â”Š\n+â”Š   â”Š 35â”Š  // Gets the matching y value for the given radian\n+â”Š   â”Š 36â”Š  getY(rad) {\n+â”Š   â”Š 37â”Š    if (!Utils(rad).trim(9).isBetween(this.rad1, this.rad2).value()) return;\n+â”Š   â”Š 38â”Š    return Utils.trim((this.r * Math.sin(rad)) + this.y, 9);\n+â”Š   â”Š 39â”Š  }\n+â”Š   â”Š 40â”Š\n+â”Š   â”Š 41â”Š  // Gets the matching point for the given radian\n+â”Š   â”Š 42â”Š  getPoint(rad) {\n+â”Š   â”Š 43â”Š    if (!Utils.isBetween(rad, this.rad1, this.rad2)) return;\n+â”Š   â”Š 44â”Š\n+â”Š   â”Š 45â”Š    return {\n+â”Š   â”Š 46â”Š      x: Utils.trim((this.r * Math.cos(rad)) + this.x, 9),\n+â”Š   â”Š 47â”Š      y: Utils.trim((this.r * Math.sin(rad)) + this.y, 9)\n+â”Š   â”Š 48â”Š    };\n+â”Š   â”Š 49â”Š  }\n+â”Š   â”Š 50â”Š\n+â”Š   â”Š 51â”Š  // Gets the matching radian for the given point\n+â”Š   â”Š 52â”Š  getRad(x, y) {\n+â”Š   â”Š 53â”Š    let rad = Math.atan2(y - this.y, x - this.x);\n+â”Š   â”Š 54â”Š\n+â”Š   â”Š 55â”Š    // If calculated radian is in circle's radian range, return it\n+â”Š   â”Š 56â”Š    if (rad != null && Utils.isBetween(rad, this.rad1, this.rad2)) {\n+â”Š   â”Š 57â”Š      return rad;\n+â”Š   â”Š 58â”Š    }\n+â”Š   â”Š 59â”Š\n+â”Š   â”Š 60â”Š    // The calculated radian can still be in the circle's radian range in case one\n+â”Š   â”Š 61â”Š    // of the radians is greater than 2 PIEs\n+â”Š   â”Š 62â”Š    if (Math.abs(this.rad1) > Math.abs(this.rad2)) {\n+â”Š   â”Š 63â”Š      var greatestRad = this.rad1;\n+â”Š   â”Š 64â”Š    }\n+â”Š   â”Š 65â”Š    else {\n+â”Š   â”Š 66â”Š      var greatestRad = this.rad2;\n+â”Š   â”Š 67â”Š    }\n+â”Š   â”Š 68â”Š\n+â”Š   â”Š 69â”Š    // Check if the absolute radian is in the circle's radian range\n+â”Š   â”Š 70â”Š    if (Utils(rad + (2 * Math.PI * Math.floor(greatestRad / (2 * Math.PI)))).trim(9).isBetween(this.rad1, this.rad2).value() ||\n+â”Š   â”Š 71â”Š        Utils(rad + (2 * Math.PI * Math.ceil(greatestRad / (2 * Math.PI)))).trim(9).isBetween(this.rad1, this.rad2).value()) {\n+â”Š   â”Š 72â”Š      return rad;\n+â”Š   â”Š 73â”Š    }\n+â”Š   â”Š 74â”Š  }\n+â”Š   â”Š 75â”Š\n+â”Š   â”Š 76â”Š  // Returns if circle has given points\n+â”Š   â”Š 77â”Š  hasPoint(x, y) {\n+â”Š   â”Š 78â”Š    return this.getRad(x, y) != null;\n+â”Š   â”Š 79â”Š  }\n+â”Š   â”Š 80â”Š\n+â”Š   â”Š 81â”Š  getIntersection(shape) {\n+â”Š   â”Š 82â”Š    if (shape instanceof Engine.Geometry.Line)\n+â”Š   â”Š 83â”Š      return this.getLineIntersection(shape);\n+â”Š   â”Š 84â”Š    if (shape instanceof Engine.Geometry.Circle)\n+â”Š   â”Š 85â”Š      return this.getCircleIntersection(shape);\n+â”Š   â”Š 86â”Š  }\n+â”Š   â”Š 87â”Š\n+â”Š   â”Š 88â”Š  // circle - circle intersection method\n+â”Š   â”Š 89â”Š  getCircleIntersection(circle) {\n+â”Š   â”Š 90â”Š    let dx = circle.x - this.x;\n+â”Š   â”Š 91â”Š    let dy = circle.y - this.y;\n+â”Š   â”Š 92â”Š    let d = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\n+â”Š   â”Š 93â”Š\n+â”Š   â”Š 94â”Š    if (d > this.r + circle.r ||\n+â”Š   â”Š 95â”Š       d < Math.abs(this.r - circle.r)) {\n+â”Š   â”Š 96â”Š      return;\n+â”Š   â”Š 97â”Š    }\n+â”Š   â”Š 98â”Š\n+â”Š   â”Š 99â”Š    let a = ((Math.pow(this.r, 2) - Math.pow(circle.r, 2)) + Math.pow(d, 2)) / (2 * d);\n+â”Š   â”Š100â”Š    let x = this.x + ((dx * a) / d);\n+â”Š   â”Š101â”Š    let y = this.y + ((dy * a) / d);\n+â”Š   â”Š102â”Š    let h = Math.sqrt(Math.pow(this.r, 2) - Math.pow(a, 2));\n+â”Š   â”Š103â”Š    let rx = (- dy * h) / d;\n+â”Š   â”Š104â”Š    let ry = (dx * h) / d;\n+â”Š   â”Š105â”Š\n+â”Š   â”Š106â”Š    let interPoints = [\n+â”Š   â”Š107â”Š      {\n+â”Š   â”Š108â”Š        x: x + rx,\n+â”Š   â”Š109â”Š        y: y + ry\n+â”Š   â”Š110â”Š      },\n+â”Š   â”Š111â”Š      {\n+â”Š   â”Š112â”Š        x: x - rx,\n+â”Š   â”Š113â”Š        y: y - ry\n+â”Š   â”Š114â”Š      }\n+â”Š   â”Š115â”Š    ]\n+â”Š   â”Š116â”Š    .map(point => ({\n+â”Š   â”Š117â”Š        x: Utils.trim(point.x, 9),\n+â”Š   â”Š118â”Š        y: Utils.trim(point.y, 9)\n+â”Š   â”Š119â”Š     }));\n+â”Š   â”Š120â”Š\n+â”Š   â”Š121â”Š    interPoints = _.uniq(interPoints, point => `(${point.x}, ${point.y})`);\n+â”Š   â”Š122â”Š\n+â”Š   â”Š123â”Š    [this, circle].forEach(function(circle) {\n+â”Š   â”Š124â”Š      interPoints = interPoints.filter(point => circle.hasPoint(point.x, point.y));\n+â”Š   â”Š125â”Š    });\n+â”Š   â”Š126â”Š\n+â”Š   â”Š127â”Š    if (interPoints.length > 0) return interPoints;\n+â”Š   â”Š128â”Š  }\n+â”Š   â”Š129â”Š\n+â”Š   â”Š130â”Š  // circle - line intersection method\n+â”Š   â”Š131â”Š  getLineIntersection(line) {\n+â”Š   â”Š132â”Š    let x1 = line.x1 - this.x;\n+â”Š   â”Š133â”Š    let x2 = line.x2 - this.x;\n+â”Š   â”Š134â”Š    let y1 = line.y1 - this.y;\n+â”Š   â”Š135â”Š    let y2 = line.y2 - this.y;\n+â”Š   â”Š136â”Š    let dx = x2 - x1;\n+â”Š   â”Š137â”Š    let dy = y2 - y1;\n+â”Š   â”Š138â”Š    let d = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\n+â”Š   â”Š139â”Š    let h = (x1 * y2) - (x2 * y1);\n+â”Š   â”Š140â”Š    let delta = (Math.pow(this.r, 2) * Math.pow(d, 2)) - Math.pow(h, 2);\n+â”Š   â”Š141â”Š\n+â”Š   â”Š142â”Š    if (delta < 0) return;\n+â”Š   â”Š143â”Š\n+â”Š   â”Š144â”Š    let interPoints = [\n+â”Š   â”Š145â”Š      {\n+â”Š   â”Š146â”Š        x: (((h * dy) + (((dy / Math.abs(dy)) || 1) * dx * Math.sqrt(delta))) / Math.pow(d, 2)) + this.x,\n+â”Š   â”Š147â”Š        y: (((-h * dx) + (Math.abs(dy) * Math.sqrt(delta))) / Math.pow(d, 2)) + this.y\n+â”Š   â”Š148â”Š      },\n+â”Š   â”Š149â”Š      {\n+â”Š   â”Š150â”Š        x: (((h * dy) - (((dy / Math.abs(dy)) || 1) * dx * Math.sqrt(delta))) / Math.pow(d, 2)) + this.x,\n+â”Š   â”Š151â”Š        y: (((-h * dx) - (Math.abs(dy) * Math.sqrt(delta))) / Math.pow(d, 2)) + this.y\n+â”Š   â”Š152â”Š      }\n+â”Š   â”Š153â”Š    ]\n+â”Š   â”Š154â”Š    .map(point => ({\n+â”Š   â”Š155â”Š        x: Utils.trim(point.x, 9),\n+â”Š   â”Š156â”Š        y: Utils.trim(point.y, 9)\n+â”Š   â”Š157â”Š    }))\n+â”Š   â”Š158â”Š    .filter(point => {\n+â”Š   â”Š159â”Š      return this.hasPoint(point.x, point.y) &&\n+â”Š   â”Š160â”Š        line.boundsHavePoint(point.x, point.y);\n+â”Š   â”Š161â”Š    });\n+â”Š   â”Š162â”Š\n+â”Š   â”Š163â”Š    interPoints = _.uniq(interPoints, point => `(${point.x}, ${point.y})`);\n+â”Š   â”Š164â”Š\n+â”Š   â”Š165â”Š    if (interPoints.length > 0) return interPoints;\n+â”Š   â”Š166â”Š  }\n+â”Š   â”Š167â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -11,6 +11,7 @@\n â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/utils.js\"></script>\n â”Š12â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n â”Š13â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/geometry/line.js\"></script>\n+â”Š  â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/geometry/circle.js\"></script>\n â”Š14â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/restorable.js\"></script>\n â”Š15â”Š16â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/font.js\"></script>\n â”Š16â”Š17â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/sprite.js\"></script>\n```\n\n[}]: #\n\nJust like a line, a circle can be presented using variables as well. The center of the circle is represented as `(x, y)` and its radius is represented as `r`. Remember that our circle doesn't necessarily have to be a full one, therefore we limit its range using two radians - `rad1` and `rad2`. The formula for representing a circle in a 2D space looks like this:\n\n![circle-formula](https://cloud.githubusercontent.com/assets/7648874/21829783/84a54574-d77f-11e6-9b87-3fb0f073bb8d.png)\n\n![circle-circle-illustration](https://cloud.githubusercontent.com/assets/7648874/21790842/3a73408c-d6c6-11e6-8bdd-9c73355e6ebb.png)\n\n> `a` and `b` represent the offsets from the `x` and the `y` axes respectively.\n> See reference: http://mathworld.wolfram.com/Circle-CircleIntersection.html.\n\nTo find intersection between two circles, we simply calculate the solution for two equations with two variables. Given that a line can be represented in a 2D space using the following formula:\n\n![line-formula](https://cloud.githubusercontent.com/assets/7648874/21790671/1609c050-d6c5-11e6-8bd7-16cc306f5eea.png)\n\n![circle-line-illustration](https://cloud.githubusercontent.com/assets/7648874/21790810/1a052086-d6c6-11e6-9c5c-24298fedb043.png)\n\n> `n` represents the intersection value with the `y` axis.\n> See reference: http://mathworld.wolfram.com/Circle-LineIntersection.html.\n\nwe can find the intersection between a circle and line by solving the systems formed by the equations of both. We also want the line-circle algorithm to be available for any `Line` instance, therefore we gonna add the following delegate on the `Line` prototype:\n\n[{]: <helper> (diffStep 5.8)\n\n#### [Step 5.8: Delegate circle intersection methods](https://github.com/DAB0mB/radial-snake/commit/19828bf)\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;geometry&#x2F;line.js\n```diff\n@@ -44,6 +44,8 @@\n â”Š44â”Š44â”Š  getIntersection(shape) {\n â”Š45â”Š45â”Š    if (shape instanceof Engine.Geometry.Line)\n â”Š46â”Š46â”Š      return this.getLineIntersection(shape);\n+â”Š  â”Š47â”Š    if (shape instanceof Engine.Geometry.Circle)\n+â”Š  â”Š48â”Š      return this.getCircleIntersection(shape);\n â”Š47â”Š49â”Š  }\n â”Š48â”Š50â”Š\n â”Š49â”Š51â”Š  // line - line intersection method\n```\n```diff\n@@ -62,4 +64,9 @@\n â”Š62â”Š64â”Š      return { x, y };\n â”Š63â”Š65â”Š    }\n â”Š64â”Š66â”Š  }\n+â”Š  â”Š67â”Š\n+â”Š  â”Š68â”Š  // line - circle intersection method\n+â”Š  â”Š69â”Š  getCircleIntersection(circle) {\n+â”Š  â”Š70â”Š    return circle.getLineIntersection(this);\n+â”Š  â”Š71â”Š  }\n â”Š65â”Š72â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nThen again a newly created geometry shape class should be tested against different scenarios:\n\n[{]: <helper> (diffStep 5.9)\n\n#### [Step 5.9: Create &#x27;Circle&#x27; class tests](https://github.com/DAB0mB/radial-snake/commit/1d98a6e)\n\n##### Added resources&#x2F;scripts&#x2F;specs&#x2F;engine&#x2F;geometry&#x2F;circle.js\n```diff\n@@ -0,0 +1,144 @@\n+â”Š   â”Š  1â”Šdescribe(\"Engine.Geometry.Circle class\", function() {\n+â”Š   â”Š  2â”Š  beforeEach(function() {\n+â”Š   â”Š  3â”Š    this.circle = new Engine.Geometry.Circle(1, 1, 5, 0, 1.5 * Math.PI);\n+â”Š   â”Š  4â”Š  });\n+â”Š   â”Š  5â”Š\n+â”Š   â”Š  6â”Š  describe(\"getX method\", function() {\n+â”Š   â”Š  7â”Š    describe(\"given inranged rad\", function() {\n+â”Š   â”Š  8â”Š      it(\"returns x\", function() {\n+â”Š   â”Š  9â”Š        expect(this.circle.getX(0 * Math.PI)).toBeCloseTo(6);\n+â”Š   â”Š 10â”Š        expect(this.circle.getX(0.5 * Math.PI)).toBeCloseTo(1);\n+â”Š   â”Š 11â”Š        expect(this.circle.getX(1 * Math.PI)).toBeCloseTo(-4);\n+â”Š   â”Š 12â”Š        expect(this.circle.getX(1.5 * Math.PI)).toBeCloseTo(1);\n+â”Š   â”Š 13â”Š      });\n+â”Š   â”Š 14â”Š    });\n+â”Š   â”Š 15â”Š\n+â”Š   â”Š 16â”Š    describe(\"given outranged rad\", function() {\n+â”Š   â”Š 17â”Š      it(\"returns nothing\", function() {\n+â”Š   â”Š 18â”Š        expect(this.circle.getX(2 * Math.PI)).toBeUndefined();\n+â”Š   â”Š 19â”Š      });\n+â”Š   â”Š 20â”Š    });\n+â”Š   â”Š 21â”Š  });\n+â”Š   â”Š 22â”Š\n+â”Š   â”Š 23â”Š  describe(\"getY method\", function() {\n+â”Š   â”Š 24â”Š    describe(\"given inranged rad\", function() {\n+â”Š   â”Š 25â”Š      it(\"returns y\", function() {\n+â”Š   â”Š 26â”Š        expect(this.circle.getY(0 * Math.PI)).toBeCloseTo(1);\n+â”Š   â”Š 27â”Š        expect(this.circle.getY(0.5 * Math.PI)).toBeCloseTo(6);\n+â”Š   â”Š 28â”Š        expect(this.circle.getY(1 * Math.PI)).toBeCloseTo(1);\n+â”Š   â”Š 29â”Š        expect(this.circle.getY(1.5 * Math.PI)).toBeCloseTo(-4);\n+â”Š   â”Š 30â”Š      });\n+â”Š   â”Š 31â”Š    });\n+â”Š   â”Š 32â”Š\n+â”Š   â”Š 33â”Š    describe(\"given outranged rad\", function() {\n+â”Š   â”Š 34â”Š      it(\"returns nothing\", function() {\n+â”Š   â”Š 35â”Š        expect(this.circle.getY(2 * Math.PI)).toBeUndefined();\n+â”Š   â”Š 36â”Š      });\n+â”Š   â”Š 37â”Š    });\n+â”Š   â”Š 38â”Š  });\n+â”Š   â”Š 39â”Š\n+â”Š   â”Š 40â”Š  describe(\"getRad method\", function() {\n+â”Š   â”Š 41â”Š    describe(\"given inranged point\", function() {\n+â”Š   â”Š 42â”Š      it(\"returns rad\", function() {\n+â”Š   â”Š 43â”Š        let x = -3.0450849718747346;\n+â”Š   â”Š 44â”Š        let y = 3.9389262614623686;\n+â”Š   â”Š 45â”Š        expect(this.circle.getRad(x, y)).toBeCloseTo(0.8 * Math.PI);\n+â”Š   â”Š 46â”Š      });\n+â”Š   â”Š 47â”Š    });\n+â”Š   â”Š 48â”Š\n+â”Š   â”Š 49â”Š    describe(\"given outranged point\", function() {\n+â”Š   â”Š 50â”Š      it(\"returns nothing\", function() {\n+â”Š   â”Š 51â”Š        let x = 5.045084971874736;\n+â”Š   â”Š 52â”Š        let y = -1.9389262614623664;\n+â”Š   â”Š 53â”Š        expect(this.circle.getRad(x, y)).toBeUndefined();\n+â”Š   â”Š 54â”Š      });\n+â”Š   â”Š 55â”Š    });\n+â”Š   â”Š 56â”Š  });\n+â”Š   â”Š 57â”Š\n+â”Š   â”Š 58â”Š  describe(\"getCircleIntersection method\", function() {\n+â”Š   â”Š 59â”Š    describe(\"given circle with 2 intersection points\", function() {\n+â”Š   â”Š 60â”Š      it(\"returns array with intersection points\", function() {\n+â”Š   â”Š 61â”Š        let circle = new Engine.Geometry.Circle(-5, 1, 5, 0, 2 * Math.PI);\n+â”Š   â”Š 62â”Š\n+â”Š   â”Š 63â”Š        expect(this.circle.getCircleIntersection(circle)).toEqual([\n+â”Š   â”Š 64â”Š          { x: -2, y: -3 },\n+â”Š   â”Š 65â”Š          { x: -2, y: 5 }\n+â”Š   â”Š 66â”Š        ]);\n+â”Š   â”Š 67â”Š      });\n+â”Š   â”Š 68â”Š    });\n+â”Š   â”Š 69â”Š\n+â”Š   â”Š 70â”Š    describe(\"given circle with 1 intersection points\", function() {\n+â”Š   â”Š 71â”Š      it(\"returns array with intersection point\", function() {\n+â”Š   â”Š 72â”Š        let circle = new Engine.Geometry.Circle(-5, 1, 5, 0, 1 * Math.PI);\n+â”Š   â”Š 73â”Š\n+â”Š   â”Š 74â”Š        expect(this.circle.getCircleIntersection(circle)).toEqual([\n+â”Š   â”Š 75â”Š          { x: -2, y: 5 }\n+â”Š   â”Š 76â”Š        ]);\n+â”Š   â”Š 77â”Š      });\n+â”Š   â”Š 78â”Š    });\n+â”Š   â”Š 79â”Š\n+â”Š   â”Š 80â”Š    describe(\"given kissing circle\", function() {\n+â”Š   â”Š 81â”Š      it(\"returns array with intersection point\", function() {\n+â”Š   â”Š 82â”Š        let circle = new Engine.Geometry.Circle(-9, 1, 5, 0, 2 * Math.PI);\n+â”Š   â”Š 83â”Š\n+â”Š   â”Š 84â”Š        expect(this.circle.getCircleIntersection(circle)).toEqual([\n+â”Š   â”Š 85â”Š          { x: -4, y: 1 }\n+â”Š   â”Š 86â”Š        ]);\n+â”Š   â”Š 87â”Š      });\n+â”Š   â”Š 88â”Š    });\n+â”Š   â”Š 89â”Š\n+â”Š   â”Š 90â”Š    describe(\"given outer circle\", function() {\n+â”Š   â”Š 91â”Š      it(\"returns nothing\", function() {\n+â”Š   â”Š 92â”Š        let circle = new Engine.Geometry.Circle(10, 10, 2, 0, 2 * Math.PI);\n+â”Š   â”Š 93â”Š        expect(this.circle.getCircleIntersection(circle)).toBeUndefined();\n+â”Š   â”Š 94â”Š      });\n+â”Š   â”Š 95â”Š    });\n+â”Š   â”Š 96â”Š\n+â”Š   â”Š 97â”Š    describe(\"given inner circle\", function() {\n+â”Š   â”Š 98â”Š      it(\"nothing\", function() {\n+â”Š   â”Š 99â”Š        let circle = new Engine.Geometry.Circle(1, 1, 2, 0, 2 * Math.PI);\n+â”Š   â”Š100â”Š        expect(this.circle.getCircleIntersection(circle)).toBeUndefined();\n+â”Š   â”Š101â”Š      });\n+â”Š   â”Š102â”Š    });\n+â”Š   â”Š103â”Š  });\n+â”Š   â”Š104â”Š\n+â”Š   â”Š105â”Š  describe(\"getLineIntersection method\", function() {\n+â”Š   â”Š106â”Š    describe(\"given line with 2 intersection points\", function() {\n+â”Š   â”Š107â”Š      it(\"returns array with intersection points\", function() {\n+â”Š   â”Š108â”Š        let line = new Engine.Geometry.Line(-10, 1, 10, 1);\n+â”Š   â”Š109â”Š\n+â”Š   â”Š110â”Š        expect(this.circle.getLineIntersection(line)).toEqual([\n+â”Š   â”Š111â”Š          { x: 6, y: 1 },\n+â”Š   â”Š112â”Š          { x: -4, y: 1 }\n+â”Š   â”Š113â”Š        ]);\n+â”Š   â”Š114â”Š      });\n+â”Š   â”Š115â”Š    });\n+â”Š   â”Š116â”Š\n+â”Š   â”Š117â”Š    describe(\"given line with 1 intersection point\", function() {\n+â”Š   â”Š118â”Š      it(\"returns array with intersection point\", function() {\n+â”Š   â”Š119â”Š        let line = new Engine.Geometry.Line(-10, 1, 1, 1);\n+â”Š   â”Š120â”Š\n+â”Š   â”Š121â”Š        expect(this.circle.getLineIntersection(line)).toEqual([\n+â”Š   â”Š122â”Š          { x: -4, y: 1 }\n+â”Š   â”Š123â”Š        ]);\n+â”Š   â”Š124â”Š      });\n+â”Š   â”Š125â”Š    });\n+â”Š   â”Š126â”Š\n+â”Š   â”Š127â”Š    describe(\"given kissing line\", function() {\n+â”Š   â”Š128â”Š      it(\"returns array with intersection point\", function() {\n+â”Š   â”Š129â”Š        let line = new Engine.Geometry.Line(-10, 6, 10, 6);\n+â”Š   â”Š130â”Š\n+â”Š   â”Š131â”Š        expect(this.circle.getLineIntersection(line)).toEqual([\n+â”Š   â”Š132â”Š          { x: 1, y: 6 }\n+â”Š   â”Š133â”Š        ]);\n+â”Š   â”Š134â”Š      });\n+â”Š   â”Š135â”Š    });\n+â”Š   â”Š136â”Š\n+â”Š   â”Š137â”Š    describe(\"given outranged line\", function() {\n+â”Š   â”Š138â”Š      it(\"returns nothing\", function() {\n+â”Š   â”Š139â”Š        let line = new Engine.Geometry.Line(-10, 10, 10, 10);\n+â”Š   â”Š140â”Š        expect(this.circle.getLineIntersection(line)).toBeUndefined();\n+â”Š   â”Š141â”Š      });\n+â”Š   â”Š142â”Š    });\n+â”Š   â”Š143â”Š  });\n+â”Š   â”Š144â”Š});ðŸš«â†µ\n```\n\n##### Changed views&#x2F;spec_runner.html\n```diff\n@@ -19,9 +19,11 @@\n â”Š19â”Š19â”Š    <script type=\"text/javascript\" src=\"scripts/utils.js\"></script>\n â”Š20â”Š20â”Š    <script type=\"text/javascript\" src=\"scripts/namespaces.js\"></script>\n â”Š21â”Š21â”Š    <script type=\"text/javascript\" src=\"scripts/engine/geometry/line.js\"></script>\n+â”Š  â”Š22â”Š    <script type=\"text/javascript\" src=\"scripts/engine/geometry/circle.js\"></script>\n â”Š22â”Š23â”Š\n â”Š23â”Š24â”Š    <!-- Specs -->\n â”Š24â”Š25â”Š    <script type=\"text/javascript\" src=\"scripts/specs/engine/geometry/line.js\"></script>\n+â”Š  â”Š26â”Š    <script type=\"text/javascript\" src=\"scripts/specs/engine/geometry/circle.js\"></script>\n â”Š25â”Š27â”Š  </head>\n â”Š26â”Š28â”Š\n â”Š27â”Š29â”Š  <body>\n```\n\n[}]: #\n\nOur final shape in the geometry module would be a polygon. Why a polygon? Since I'm planning to make the snake's movement circular, which means that once the snake hits a random boundary, he will reappear from the other side of the canvas. The collision detection between the snake and the canvas would be done using a polygon - which is simply made out of 4 lines:\n\n[{]: <helper> (diffStep 5.1)\n\n#### [Step 5.1: Create utilities module](https://github.com/DAB0mB/radial-snake/commit/58ae99a)\n\n##### Added resources&#x2F;scripts&#x2F;utils.js\n```diff\n@@ -0,0 +1,68 @@\n+â”Š  â”Š 1â”Š// A wrapper function for our utilities which will enable chaining\n+â”Š  â”Š 2â”Š// e.g. Utils().mod().trim().isBetween()...\n+â”Š  â”Š 3â”ŠUtils = function Utils(context) {\n+â”Š  â”Š 4â”Š  const chain = {};\n+â”Š  â”Š 5â”Š\n+â”Š  â”Š 6â”Š  Object.keys(Utils).forEach((utilName) => {\n+â”Š  â”Š 7â”Š    chain[utilName] = (...args) => {\n+â”Š  â”Š 8â”Š      const result = Utils[utilName](context, ...args);\n+â”Š  â”Š 9â”Š      return Utils(result);\n+â”Š  â”Š10â”Š    };\n+â”Š  â”Š11â”Š  });\n+â”Š  â”Š12â”Š\n+â”Š  â”Š13â”Š  // Returns the result of the chaining\n+â”Š  â”Š14â”Š  chain.value = () => context;\n+â”Š  â”Š15â”Š\n+â”Š  â”Š16â”Š  return chain;\n+â”Š  â”Š17â”Š};\n+â”Š  â”Š18â”Š\n+â”Š  â”Š19â”Š// Fixed modulo method which can calculate modulo of negative numbers properly\n+â”Š  â”Š20â”Š// e.g. (-803).mod(800) returns 797\n+â”Š  â”Š21â”ŠUtils.mod = function (context, num) {\n+â”Š  â”Š22â”Š  return ((context % num) + num) % num;\n+â”Š  â”Š23â”Š};\n+â”Š  â”Š24â”Š\n+â”Š  â”Š25â”Š// Trims number and leaves the number of decimals specified.\n+â”Š  â”Š26â”Š// The \"mode\" argument specifies which math function should be invoked\n+â”Š  â”Š27â”Š// right after the number has been trimmed.\n+â”Š  â”Š28â”Š// e.g. 12.12345.trim(3, \"ceil\") returns 12.124\n+â”Š  â”Š29â”ŠUtils.trim = function (context, decimals, mode = \"round\") {\n+â”Š  â”Š30â”Š  return Math[mode](context * Math.pow(10, decimals)) / Math.pow(10, decimals);\n+â”Š  â”Š31â”Š};\n+â”Š  â”Š32â”Š\n+â”Š  â”Š33â”Š// Tells if number is in specified range based on given precision.\n+â”Š  â”Š34â”Š// See the \"compare\" method for more information about precision\n+â”Š  â”Š35â”ŠUtils.isBetween = function (context, num1, num2, precision) {\n+â”Š  â”Š36â”Š  return Utils.compare(context, Math.min(num1, num2), \">=\", precision) &&\n+â”Š  â”Š37â”Š         Utils.compare(context, Math.max(num1, num2), \"<=\", precision);\n+â”Š  â”Š38â”Š};\n+â”Š  â”Š39â”Š\n+â”Š  â”Š40â”Š// Initiates comparison operator between context number and a given number, only here\n+â”Š  â”Š41â”Š// a precision can be specified\n+â”Š  â”Š42â”ŠUtils.compare = function (context, num, method, precision = method) {\n+â”Š  â”Š43â”Š  switch (precision) {\n+â”Š  â”Š44â”Š    // Fixed precision, \"almost equal\" with a deviation of Îµ\n+â”Š  â”Š45â”Š    case \"f\":\n+â”Š  â”Š46â”Š      switch (method) {\n+â”Š  â”Š47â”Š        case \"<\": case \"<=\": return context <= num + Number.EPSILON;\n+â”Š  â”Š48â”Š        case \">\": case \">=\": return context >= num - Number.EPSILON;\n+â”Š  â”Š49â”Š        default: return Math.abs(context - num) <= Number.EPSILON;\n+â”Š  â”Š50â”Š      }\n+â”Š  â”Š51â”Š    // Pixel precision, round comparison\n+â”Š  â”Š52â”Š    case \"px\":\n+â”Š  â”Š53â”Š      switch (method) {\n+â”Š  â”Š54â”Š        case \"<\": case \"<=\": return Math.round(context) <= Math.round(num);\n+â”Š  â”Š55â”Š        case \">\": case \">=\": return Math.round(context) >= Math.round(num);\n+â”Š  â”Š56â”Š        default: return Math.round(context) == Math.round(num);\n+â”Š  â”Š57â”Š      }\n+â”Š  â”Š58â”Š    // Exact precision\n+â”Š  â”Š59â”Š    default:\n+â”Š  â”Š60â”Š      switch (method) {\n+â”Š  â”Š61â”Š        case \"<\": return context < num;\n+â”Š  â”Š62â”Š        case \"<=\": return context <= num;\n+â”Š  â”Š63â”Š        case \">\": return context > num;\n+â”Š  â”Š64â”Š        case \">=\": return context >= num;\n+â”Š  â”Š65â”Š        default: return context === num;\n+â”Š  â”Š66â”Š      }\n+â”Š  â”Š67â”Š  }\n+â”Š  â”Š68â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -8,6 +8,7 @@\n â”Š 8â”Š 8â”Š    <script type=\"text/javascript\" src=\"/libs/underscore.js\"></script>\n â”Š 9â”Š 9â”Š\n â”Š10â”Š10â”Š    <!-- Scripts -->\n+â”Š  â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/utils.js\"></script>\n â”Š11â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n â”Š12â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/restorable.js\"></script>\n â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/font.js\"></script>\n```\n\n[}]: #\n\nAgain we will delegate the newly created intersection methods in the `Line` class and `Circle` class:\n\n[{]: <helper> (diffStep 5.11)\n\n#### [Step 5.11: Delegate polygon intersection methods](https://github.com/DAB0mB/radial-snake/commit/d42a5d9)\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;geometry&#x2F;circle.js\n```diff\n@@ -83,6 +83,8 @@\n â”Š83â”Š83â”Š      return this.getLineIntersection(shape);\n â”Š84â”Š84â”Š    if (shape instanceof Engine.Geometry.Circle)\n â”Š85â”Š85â”Š      return this.getCircleIntersection(shape);\n+â”Š  â”Š86â”Š    if (shape instanceof Engine.Geometry.Polygon)\n+â”Š  â”Š87â”Š      return this.getPolygonIntersection(shape);\n â”Š86â”Š88â”Š  }\n â”Š87â”Š89â”Š\n â”Š88â”Š90â”Š  // circle - circle intersection method\n```\n```diff\n@@ -164,4 +166,9 @@\n â”Š164â”Š166â”Š\n â”Š165â”Š167â”Š    if (interPoints.length > 0) return interPoints;\n â”Š166â”Š168â”Š  }\n+â”Š   â”Š169â”Š\n+â”Š   â”Š170â”Š  // circle - polygon intersection method\n+â”Š   â”Š171â”Š  getPolygonIntersection(polygon) {\n+â”Š   â”Š172â”Š    return polygon.getCircleIntersection(this);\n+â”Š   â”Š173â”Š  }\n â”Š167â”Š174â”Š};ðŸš«â†µ\n```\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;geometry&#x2F;line.js\n```diff\n@@ -46,6 +46,8 @@\n â”Š46â”Š46â”Š      return this.getLineIntersection(shape);\n â”Š47â”Š47â”Š    if (shape instanceof Engine.Geometry.Circle)\n â”Š48â”Š48â”Š      return this.getCircleIntersection(shape);\n+â”Š  â”Š49â”Š    if (shape instanceof Engine.Geometry.Polygon)\n+â”Š  â”Š50â”Š      return this.getPolygonIntersection(shape);\n â”Š49â”Š51â”Š  }\n â”Š50â”Š52â”Š\n â”Š51â”Š53â”Š  // line - line intersection method\n```\n```diff\n@@ -69,4 +71,9 @@\n â”Š69â”Š71â”Š  getCircleIntersection(circle) {\n â”Š70â”Š72â”Š    return circle.getLineIntersection(this);\n â”Š71â”Š73â”Š  }\n+â”Š  â”Š74â”Š\n+â”Š  â”Š75â”Š  // line - polygon intersection method\n+â”Š  â”Š76â”Š  getPolygonIntersection(polygon) {\n+â”Š  â”Š77â”Š    return polygon.getLineIntersection(this);\n+â”Š  â”Š78â”Š  }\n â”Š72â”Š79â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nNow we will create a some tests to make sure our newly created polygon works properly:\n\n[{]: <helper> (diffStep 5.12)\n\n#### [Step 5.12: Create &#x27;Polygon&#x27; class tests](https://github.com/DAB0mB/radial-snake/commit/f3f890b)\n\n##### Added resources&#x2F;scripts&#x2F;specs&#x2F;engine&#x2F;geometry&#x2F;polygon.js\n```diff\n@@ -0,0 +1,96 @@\n+â”Š  â”Š 1â”Šdescribe(\"Engine.Geometry.Polygon class\", function() {\n+â”Š  â”Š 2â”Š  beforeEach(function() {\n+â”Š  â”Š 3â”Š    this.polygon = new Engine.Geometry.Polygon(\n+â”Š  â”Š 4â”Š      [0, 0, 5, 0],\n+â”Š  â”Š 5â”Š      [5, 0, 5, 5],\n+â”Š  â”Š 6â”Š      [5, 5, 0, 5],\n+â”Š  â”Š 7â”Š      [0, 5, 0, 0]\n+â”Š  â”Š 8â”Š    );\n+â”Š  â”Š 9â”Š  });\n+â”Š  â”Š10â”Š\n+â”Š  â”Š11â”Š  describe(\"hasPoint method\", function() {\n+â”Š  â”Š12â”Š    describe(\"given contained point\", function() {\n+â”Š  â”Š13â”Š      it(\"returns true\", function() {\n+â”Š  â”Š14â”Š        let x = 5;\n+â”Š  â”Š15â”Š        let y = 3;\n+â”Š  â”Š16â”Š        expect(this.polygon.hasPoint(x, y)).toBeTruthy();\n+â”Š  â”Š17â”Š      });\n+â”Š  â”Š18â”Š    });\n+â”Š  â”Š19â”Š\n+â”Š  â”Š20â”Š    describe(\"given outranged point\", function() {\n+â”Š  â”Š21â”Š      it(\"returns false\", function() {\n+â”Š  â”Š22â”Š        let x = 10;\n+â”Š  â”Š23â”Š        let y = 10;\n+â”Š  â”Š24â”Š        expect(this.polygon.hasPoint(x, y)).toBeFalsy();\n+â”Š  â”Š25â”Š      });\n+â”Š  â”Š26â”Š    });\n+â”Š  â”Š27â”Š  });\n+â”Š  â”Š28â”Š\n+â”Š  â”Š29â”Š  describe(\"getLineIntersection method\", function() {\n+â”Š  â”Š30â”Š    describe(\"given intersecting line\", function() {\n+â”Š  â”Š31â”Š      it(\"returns intersection point\", function() {\n+â”Š  â”Š32â”Š        let line = new Engine.Geometry.Line(0, 1, 5, 4);\n+â”Š  â”Š33â”Š\n+â”Š  â”Š34â”Š        expect(this.polygon.getLineIntersection(line)).toEqual([\n+â”Š  â”Š35â”Š          { x: 5, y: 4 },\n+â”Š  â”Š36â”Š          { x: 0, y: 1 }\n+â”Š  â”Š37â”Š        ]);\n+â”Š  â”Š38â”Š      });\n+â”Š  â”Š39â”Š    });\n+â”Š  â”Š40â”Š\n+â”Š  â”Š41â”Š    describe(\"given outranged line\", function() {\n+â”Š  â”Š42â”Š      it(\"returns nothing\", function() {\n+â”Š  â”Š43â”Š        let line = new Engine.Geometry.Line(10, 11, 15, 14);\n+â”Š  â”Š44â”Š\n+â”Š  â”Š45â”Š        expect(this.polygon.getLineIntersection(line)).toBeUndefined();\n+â”Š  â”Š46â”Š      });\n+â”Š  â”Š47â”Š    });\n+â”Š  â”Š48â”Š  });\n+â”Š  â”Š49â”Š\n+â”Š  â”Š50â”Š  describe(\"getCircleIntersection method\", function() {\n+â”Š  â”Š51â”Š    describe(\"given circle with 2 intersection points\", function() {\n+â”Š  â”Š52â”Š      it(\"returns array with intersection points\", function() {\n+â”Š  â”Š53â”Š        let circle = new Engine.Geometry.Circle(0, 0, 2, 0, 2 * Math.PI);\n+â”Š  â”Š54â”Š\n+â”Š  â”Š55â”Š        expect(this.polygon.getCircleIntersection(circle)).toEqual([\n+â”Š  â”Š56â”Š          { x: 2, y: 0 },\n+â”Š  â”Š57â”Š          { x: 0, y: 2 }\n+â”Š  â”Š58â”Š        ]);\n+â”Š  â”Š59â”Š      });\n+â”Š  â”Š60â”Š    });\n+â”Š  â”Š61â”Š\n+â”Š  â”Š62â”Š    describe(\"given circle with 1 intersection points\", function() {\n+â”Š  â”Š63â”Š      it(\"returns array with intersection point\", function() {\n+â”Š  â”Š64â”Š        let circle = new Engine.Geometry.Circle(0, 0, 2, 0, 0.25 * Math.PI);\n+â”Š  â”Š65â”Š\n+â”Š  â”Š66â”Š        expect(this.polygon.getCircleIntersection(circle)).toEqual([\n+â”Š  â”Š67â”Š          { x: 2, y: 0 }\n+â”Š  â”Š68â”Š        ]);\n+â”Š  â”Š69â”Š      });\n+â”Š  â”Š70â”Š    });\n+â”Š  â”Š71â”Š\n+â”Š  â”Š72â”Š    describe(\"given kissing circle\", function() {\n+â”Š  â”Š73â”Š      it(\"returns array with intersection point\", function() {\n+â”Š  â”Š74â”Š        let circle = new Engine.Geometry.Circle(-3, 3, 3, 0, 2 * Math.PI);\n+â”Š  â”Š75â”Š\n+â”Š  â”Š76â”Š        expect(this.polygon.getCircleIntersection(circle)).toEqual([\n+â”Š  â”Š77â”Š          { x: 0, y: 3 }\n+â”Š  â”Š78â”Š        ]);\n+â”Š  â”Š79â”Š      });\n+â”Š  â”Š80â”Š    });\n+â”Š  â”Š81â”Š\n+â”Š  â”Š82â”Š    describe(\"given outer circle\", function() {\n+â”Š  â”Š83â”Š      it(\"returns nothing\", function() {\n+â”Š  â”Š84â”Š        let circle = new Engine.Geometry.Circle(10, 10, 2, 0, 2 * Math.PI);\n+â”Š  â”Š85â”Š        expect(this.polygon.getCircleIntersection(circle)).toBeUndefined();\n+â”Š  â”Š86â”Š      });\n+â”Š  â”Š87â”Š    });\n+â”Š  â”Š88â”Š\n+â”Š  â”Š89â”Š    describe(\"given inner circle\", function() {\n+â”Š  â”Š90â”Š      it(\"nothing\", function() {\n+â”Š  â”Š91â”Š        let circle = new Engine.Geometry.Circle(2.5, 2.5, 2, 0, 2 * Math.PI);\n+â”Š  â”Š92â”Š        expect(this.polygon.getCircleIntersection(circle)).toBeUndefined();\n+â”Š  â”Š93â”Š      });\n+â”Š  â”Š94â”Š    });\n+â”Š  â”Š95â”Š  });\n+â”Š  â”Š96â”Š});ðŸš«â†µ\n```\n\n##### Changed views&#x2F;spec_runner.html\n```diff\n@@ -20,10 +20,12 @@\n â”Š20â”Š20â”Š    <script type=\"text/javascript\" src=\"scripts/namespaces.js\"></script>\n â”Š21â”Š21â”Š    <script type=\"text/javascript\" src=\"scripts/engine/geometry/line.js\"></script>\n â”Š22â”Š22â”Š    <script type=\"text/javascript\" src=\"scripts/engine/geometry/circle.js\"></script>\n+â”Š  â”Š23â”Š    <script type=\"text/javascript\" src=\"scripts/engine/geometry/polygon.js\"></script>\n â”Š23â”Š24â”Š\n â”Š24â”Š25â”Š    <!-- Specs -->\n â”Š25â”Š26â”Š    <script type=\"text/javascript\" src=\"scripts/specs/engine/geometry/line.js\"></script>\n â”Š26â”Š27â”Š    <script type=\"text/javascript\" src=\"scripts/specs/engine/geometry/circle.js\"></script>\n+â”Š  â”Š28â”Š    <script type=\"text/javascript\" src=\"scripts/specs/engine/geometry/polygon.js\"></script>\n â”Š27â”Š29â”Š  </head>\n â”Š28â”Š30â”Š\n â”Š29â”Š31â”Š  <body>\n```\n\n[}]: #\n\nAt last, all the necessary geometry shapes are implemented and ready to use. We will now focus on the snake itself. Since our game can potentially have infinite number of entities, not necessarily just a snake, we will add the a new module under the `Game` namespace called `Entities`:\n\n[{]: <helper> (diffStep 5.13)\n\n#### [Step 5.13: Add &#x27;Entities&#x27; module to &#x27;Game&#x27; namespace](https://github.com/DAB0mB/radial-snake/commit/a0bed8c)\n\n##### Changed resources&#x2F;scripts&#x2F;namespaces.js\n```diff\n@@ -1,4 +1,5 @@\n â”Š1â”Š1â”ŠGame = {\n+â”Š â”Š2â”Š  Entities: {},\n â”Š2â”Š3â”Š  Screens: {}\n â”Š3â”Š4â”Š};\n```\n\n[}]: #\n\nAnd now we can add the `Snake` class:\n\n[{]: <helper> (diffStep 5.14)\n\n#### [Step 5.14: Create &#x27;Snake&#x27; class](https://github.com/DAB0mB/radial-snake/commit/b938ba7)\n\n##### Added resources&#x2F;scripts&#x2F;game&#x2F;entities&#x2F;snake.js\n```diff\n@@ -0,0 +1,234 @@\n+â”Š   â”Š  1â”ŠGame.Entities.Snake = class Snake {\n+â”Š   â”Š  2â”Š  // Represents a snake data-structure which will eventually appear on screen.\n+â”Š   â”Š  3â”Š  // All the properties provided to the constructor are the initial values of\n+â”Š   â”Š  4â”Š  // the snake\n+â”Š   â”Š  5â”Š  constructor(x, y, r, rad, v, color, keyStates, options) {\n+â”Š   â”Š  6â”Š    this.x = x;\n+â”Š   â”Š  7â”Š    this.y = y;\n+â”Š   â”Š  8â”Š    this.r = r;\n+â”Š   â”Š  9â”Š    this.rad = rad;\n+â”Š   â”Š 10â”Š    this.v = v;\n+â”Š   â”Š 11â”Š    this.color = color;\n+â”Š   â”Š 12â”Š    this.keyStates = keyStates;\n+â”Š   â”Š 13â”Š    // A snake is made out of many geometry shapes\n+â”Š   â”Š 14â”Š    this.shapes = [];\n+â”Š   â”Š 15â”Š    // A snake starts with a line\n+â”Š   â”Š 16â”Š    this.currentShape = new Engine.Geometry.Line(x, y, x, y);\n+â”Š   â”Š 17â”Š    this.shapes.push(this.currentShape);\n+â”Š   â”Š 18â”Š    // A score can be provided in case we want to reserve previous scores from\n+â”Š   â”Š 19â”Š    // recent matches\n+â”Š   â”Š 20â”Š    this.score = options.score || 0;\n+â”Š   â”Š 21â”Š\n+â”Š   â”Š 22â”Š    // Custom keys can be specified\n+â”Š   â”Š 23â”Š    if (options.keys && options.keys) {\n+â”Š   â”Š 24â”Š      this.leftKey = options.keys.left;\n+â”Š   â”Š 25â”Š      this.rightKey = options.keys.right;\n+â”Š   â”Š 26â”Š    }\n+â”Š   â”Š 27â”Š    // Left and right arrow keys will be used by default\n+â”Š   â”Š 28â”Š    else {\n+â”Š   â”Š 29â”Š      this.leftKey = 37; // Left arrow\n+â”Š   â”Š 30â”Š      this.rightKey = 39; // Right arrow\n+â”Š   â”Š 31â”Š    }\n+â”Š   â”Š 32â”Š  }\n+â”Š   â”Š 33â”Š\n+â”Š   â”Š 34â”Š  draw(context) {\n+â”Š   â”Š 35â”Š    // Draw all shapes in the shapes array\n+â”Š   â”Š 36â”Š    this.shapes.forEach(shape => {\n+â”Š   â”Š 37â”Š      context.save();\n+â”Š   â”Š 38â”Š      context.strokeStyle = this.color;\n+â”Š   â”Š 39â”Š      context.lineWidth = 3;\n+â”Š   â”Š 40â”Š      context.beginPath();\n+â”Š   â”Š 41â”Š\n+â”Š   â”Š 42â”Š      // Each shape has its own unique drawing method\n+â”Š   â”Š 43â”Š      shape.draw(context);\n+â”Š   â”Š 44â”Š\n+â”Š   â”Š 45â”Š      context.stroke();\n+â”Š   â”Š 46â”Š      context.restore();\n+â”Š   â”Š 47â”Š    });\n+â”Š   â”Š 48â”Š  }\n+â”Š   â”Š 49â”Š\n+â”Š   â”Š 50â”Š  update(span, width, height) {\n+â”Š   â”Š 51â”Š    // Progress made based on elapsed time and velocity\n+â”Š   â”Š 52â”Š    let step = (this.v * span) / 1000;\n+â”Š   â”Š 53â”Š\n+â”Š   â”Š 54â”Š    this.updateShapes(step, width, height);\n+â”Š   â”Š 55â”Š    this.cycleThrough(step, width, height);\n+â”Š   â”Š 56â”Š  }\n+â”Š   â”Š 57â”Š\n+â”Š   â”Š 58â”Š  // Updates shapes array based on progress made\n+â”Š   â”Š 59â”Š  updateShapes(step, width, height, options = {}) {\n+â”Š   â”Š 60â”Š    this.updateCurrentShape(step, options);\n+â”Š   â”Š 61â”Š    this.updateDirection(step, options);\n+â”Š   â”Š 62â”Š  }\n+â”Š   â”Š 63â”Š\n+â”Š   â”Š 64â”Š  // Updates current shape\n+â”Š   â”Š 65â”Š  updateCurrentShape(step, options) {\n+â”Š   â”Š 66â”Š    if (this.currentShape instanceof Engine.Geometry.Line)\n+â”Š   â”Š 67â”Š      return this.updateCurrentLine(options);\n+â”Š   â”Š 68â”Š    if (this.currentShape instanceof Engine.Geometry.Circle)\n+â”Š   â”Š 69â”Š      return this.updateCurrentCircle(options);\n+â”Š   â”Š 70â”Š  }\n+â”Š   â”Š 71â”Š\n+â”Š   â”Š 72â”Š  // Updates current shape in case it is a line\n+â”Š   â”Š 73â”Š  updateCurrentLine(options) {\n+â”Š   â”Š 74â”Š    let lastX = options.lastX || this.x;\n+â”Š   â”Š 75â”Š    let lastY = options.lastY || this.y;\n+â”Š   â”Š 76â”Š    this.x = options.x || this.currentShape.x2;\n+â”Š   â”Š 77â”Š    this.y = options.y || this.currentShape.y2;\n+â”Š   â”Š 78â”Š    this.lastBit = new Engine.Geometry.Line(lastX, lastY, this.x, this.y);\n+â”Š   â”Š 79â”Š  }\n+â”Š   â”Š 80â”Š\n+â”Š   â”Š 81â”Š  // Updates current shape in case it is a circle\n+â”Š   â”Š 82â”Š  updateCurrentCircle(options) {\n+â”Š   â”Š 83â”Š    let lastX = options.lastX || this.currentShape.x;\n+â”Š   â”Š 84â”Š    let lastY = options.lastY || this.currentShape.y;\n+â”Š   â”Š 85â”Š    let lastR = options.lastR || this.currentShape.r;\n+â”Š   â”Š 86â”Š\n+â”Š   â”Š 87â”Š    // Update logic for left rotation\n+â”Š   â”Š 88â”Š    if (this.direction == \"left\") {\n+â”Š   â”Š 89â”Š      let lastRad = this.rad + (0.5 * Math.PI);\n+â”Š   â”Š 90â”Š      let currentShapePoint = this.currentShape.getPoint(this.currentShape.rad1);\n+â”Š   â”Š 91â”Š      this.x = options.x || currentShapePoint.x;\n+â”Š   â”Š 92â”Š      this.y = options.y || currentShapePoint.y;\n+â”Š   â”Š 93â”Š      this.rad = this.currentShape.rad1 - (0.5 * Math.PI);\n+â”Š   â”Š 94â”Š      this.lastBit = new Engine.Geometry.Circle(lastX, lastY, lastR, this.currentShape.rad1, lastRad);\n+â”Š   â”Š 95â”Š    }\n+â”Š   â”Š 96â”Š    // Update logic for right rotation\n+â”Š   â”Š 97â”Š    else {\n+â”Š   â”Š 98â”Š      let lastRad = this.rad - (0.5 * Math.PI);\n+â”Š   â”Š 99â”Š      let currentShapePoint = this.currentShape.getPoint(this.currentShape.rad2);\n+â”Š   â”Š100â”Š      this.x = options.x || currentShapePoint.x;\n+â”Š   â”Š101â”Š      this.y = options.y || currentShapePoint.y;\n+â”Š   â”Š102â”Š      this.rad = this.currentShape.rad2 + (0.5 * Math.PI);\n+â”Š   â”Š103â”Š      this.lastBit = new Engine.Geometry.Circle(lastX, lastY, lastR, lastRad, this.currentShape.rad2);\n+â”Š   â”Š104â”Š    }\n+â”Š   â”Š105â”Š  }\n+â”Š   â”Š106â”Š\n+â”Š   â”Š107â”Š  updateDirection(step, options) {\n+â”Š   â”Š108â”Š    // Update the direction based on pressed key\n+â”Š   â”Š109â”Š    if (this.keyStates.get(this.leftKey))\n+â”Š   â”Š110â”Š      var direction = \"left\";\n+â”Š   â”Š111â”Š    else if (this.keyStates.get(this.rightKey))\n+â”Š   â”Š112â”Š      var direction = \"right\";\n+â”Š   â”Š113â”Š\n+â”Š   â”Š114â”Š    this.changeDirection(step, direction, options);\n+â”Š   â”Š115â”Š    this.continueDirection(step, direction, options);\n+â”Š   â”Š116â”Š  }\n+â”Š   â”Š117â”Š\n+â”Š   â”Š118â”Š  // Change the recent shape type according to the given direction\n+â”Š   â”Š119â”Š  changeDirection(step, direction, options) {\n+â”Š   â”Š120â”Š    // If there is no change in direction, abort, unless we force it\n+â”Š   â”Š121â”Š    if (direction == this.direction && !options.force) return;\n+â”Š   â”Š122â”Š\n+â”Š   â”Š123â”Š    this.direction = direction;\n+â”Š   â”Š124â”Š\n+â”Š   â”Š125â”Š    // This will push a new shape with new properties, based on the direction\n+â”Š   â”Š126â”Š    switch (direction) {\n+â”Š   â”Š127â”Š      case \"left\":\n+â”Š   â”Š128â”Š        var angle = this.rad - (0.5 * Math.PI);\n+â”Š   â”Š129â”Š        var rad = this.rad + (0.5 * Math.PI);\n+â”Š   â”Š130â”Š        var x = this.x + (this.r * Math.cos(angle));\n+â”Š   â”Š131â”Š        var y = this.y + (this.r * Math.sin(angle));\n+â”Š   â”Š132â”Š        this.currentShape = new Engine.Geometry.Circle(x, y, this.r, rad, rad);\n+â”Š   â”Š133â”Š        break;\n+â”Š   â”Š134â”Š      case \"right\":\n+â”Š   â”Š135â”Š        angle = this.rad + (0.5 * Math.PI);\n+â”Š   â”Š136â”Š        rad = this.rad - (0.5 * Math.PI);\n+â”Š   â”Š137â”Š        x = this.x + (this.r * Math.cos(angle));\n+â”Š   â”Š138â”Š        y = this.y + (this.r * Math.sin(angle));\n+â”Š   â”Š139â”Š        this.currentShape = new Engine.Geometry.Circle(x, y, this.r, rad, rad);\n+â”Š   â”Š140â”Š        break;\n+â”Š   â”Š141â”Š      default:\n+â”Š   â”Š142â”Š        this.currentShape = new Engine.Geometry.Line(this.x, this.y, this.x, this.y);\n+â”Š   â”Š143â”Š    }\n+â”Š   â”Š144â”Š\n+â”Š   â”Š145â”Š    this.shapes.push(this.currentShape);\n+â”Š   â”Š146â”Š  }\n+â”Š   â”Š147â”Š\n+â”Š   â”Š148â”Š  // Extend the recent shape based on progress made\n+â”Š   â”Š149â”Š  continueDirection(step, direction) {\n+â”Š   â”Š150â”Š    switch (direction) {\n+â”Š   â”Š151â”Š      case \"left\":\n+â”Š   â”Š152â”Š        this.currentShape.rad1 -= step / this.r;\n+â”Š   â”Š153â”Š        break;\n+â”Š   â”Š154â”Š      case \"right\":\n+â”Š   â”Š155â”Š        this.currentShape.rad2 += step / this.r;\n+â”Š   â”Š156â”Š        break;\n+â”Š   â”Š157â”Š      default:\n+â”Š   â”Š158â”Š        this.currentShape.x2 += step * Math.cos(this.rad);\n+â”Š   â”Š159â”Š        this.currentShape.y2 += step * Math.sin(this.rad);\n+â”Š   â”Š160â”Š    }\n+â”Š   â”Š161â”Š  }\n+â”Š   â”Š162â”Š\n+â”Š   â”Š163â”Š  // Handles case where snake is out limits and we need to render it from\n+â”Š   â”Š164â”Š  // the other side of the canvas\n+â”Š   â”Š165â”Š  cycleThrough(step, width, height) {\n+â”Š   â”Š166â”Š    let intersectionPoint = this.getCanvasIntersection(width, height);\n+â”Š   â”Š167â”Š\n+â”Š   â”Š168â”Š    if (!intersectionPoint) return;\n+â”Š   â”Š169â”Š\n+â”Š   â”Š170â”Š    intersectionPoint = intersectionPoint[0];\n+â”Š   â”Š171â”Š\n+â”Š   â”Š172â”Š    // Re-calculate position based on canvas bounds\n+â”Š   â”Š173â”Š    if (intersectionPoint.x % width == 0)\n+â”Š   â”Š174â”Š      this.x = Utils.mod(this.x - width, width);\n+â”Š   â”Š175â”Š    if (intersectionPoint.y % height == 0)\n+â”Š   â”Š176â”Š      this.y = Utils.mod(this.y - height, height);\n+â”Š   â”Š177â”Š\n+â”Š   â”Š178â”Š    // Update shapes again based on custom properties\n+â”Š   â”Š179â”Š    this.updateShapes(step, width, height, {\n+â”Š   â”Š180â”Š      force: true,\n+â”Š   â”Š181â”Š      lastX: this.x,\n+â”Š   â”Š182â”Š      lastY: this.y,\n+â”Š   â”Š183â”Š      x: this.x,\n+â”Š   â”Š184â”Š      y: this.y\n+â”Š   â”Š185â”Š    });\n+â”Š   â”Š186â”Š  }\n+â”Š   â”Š187â”Š\n+â”Š   â”Š188â”Š  // Gets intersection points between last bit and own shapes\n+â”Š   â”Š189â”Š  getSelfIntersection() {\n+â”Š   â”Š190â”Š    if (this.currentShape instanceof Engine.Geometry.Circle &&\n+â”Š   â”Š191â”Š       Math.abs(this.currentShape.rad1 - this.currentShape.rad2) >= 2 * Math.PI) {\n+â”Š   â”Š192â”Š      if (this.direction == \"left\")\n+â”Š   â”Š193â”Š        var rad = this.currentShape.rad1;\n+â”Š   â”Š194â”Š      else\n+â”Š   â”Š195â”Š        var rad = this.currentShape.rad2;\n+â”Š   â”Š196â”Š\n+â”Š   â”Š197â”Š      return this.currentShape.getPoint(rad);\n+â”Š   â”Š198â”Š    }\n+â”Š   â”Š199â”Š\n+â”Š   â”Š200â”Š    let result;\n+â”Š   â”Š201â”Š\n+â”Š   â”Š202â”Š    this.shapes.slice(0, -2).some(shape =>\n+â”Š   â”Š203â”Š      result = this.lastBit.getIntersection(shape)\n+â”Š   â”Š204â”Š    );\n+â”Š   â”Š205â”Š\n+â”Š   â”Š206â”Š    return result;\n+â”Š   â”Š207â”Š  }\n+â”Š   â”Š208â”Š\n+â”Š   â”Š209â”Š  // Returns intersection points between snakes\n+â”Š   â”Š210â”Š  getSnakeIntersection(snake) {\n+â”Š   â”Š211â”Š    let result;\n+â”Š   â”Š212â”Š\n+â”Š   â”Š213â”Š    snake.shapes.some(shape =>\n+â”Š   â”Š214â”Š      // Only last bit is relevant, if we reached this point it means that\n+â”Š   â”Š215â”Š      // previous intersection will definitely fail\n+â”Š   â”Š216â”Š      result = this.lastBit.getIntersection(shape)\n+â”Š   â”Š217â”Š    );\n+â”Š   â”Š218â”Š\n+â”Š   â”Š219â”Š    return result;\n+â”Š   â”Š220â”Š  }\n+â”Š   â”Š221â”Š\n+â”Š   â”Š222â”Š  // Returns intersection points between snake and canvas\n+â”Š   â”Š223â”Š  getCanvasIntersection(width, height) {\n+â”Š   â”Š224â”Š    // Canvas polygon\n+â”Š   â”Š225â”Š    let canvasPolygon = new Engine.Geometry.Polygon(\n+â”Š   â”Š226â”Š      [0, 0, width, 0],\n+â”Š   â”Š227â”Š      [width, 0, width, height],\n+â”Š   â”Š228â”Š      [width, height, 0, height],\n+â”Š   â”Š229â”Š      [0, height, 0, 0]\n+â”Š   â”Š230â”Š    );\n+â”Š   â”Š231â”Š\n+â”Š   â”Š232â”Š    return canvasPolygon.getIntersection(this.lastBit);\n+â”Š   â”Š233â”Š  }\n+â”Š   â”Š234â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -22,6 +22,7 @@\n â”Š22â”Š22â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/screen.js\"></script>\n â”Š23â”Š23â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/assets_loader.js\"></script>\n â”Š24â”Š24â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n+â”Š  â”Š25â”Š    <script type=\"text/javascript\" src=\"/scripts/game/entities/snake.js\"></script>\n â”Š25â”Š26â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/menu/index.js\"></script>\n â”Š26â”Š27â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/splash/index.js\"></script>\n â”Š27â”Š28â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n```\n\n[}]: #\n\nThis class is titled with most complexity out of everything we did so far in this step. You can follow the code accompanied by comments regard it, but I'd also like to explain the key concepts. As said earlier, the `Snake` is simply made out of shapes; In this case - lines and circles.\n\nThe `draw` method just goes through this array and draws whatever shape it's currently looping through. Regardless of its type, every shape is provided with a `draw` method of its own, all shapes share the same interface, therefore we can just draw them regularly and the snake should be drawn automatically.\n\nThe `update` method updates the last bit only according to its type, the time elapsed and the speed of the snake. For example, the last bit of the snake is a line, and 5 seconds have passed at a speed of 5 meters per second, our line should be extended by 5 meters long. Same principle applies to circle extension only based on radians. The last bit's type might be changed according to the current input; e.g. if the `right` key is held the last bit would turn into a circle, and once released it would turn into a straight line.\n\nNote that besides shapes extension, collision detection should also be made. The embedded is the collision detection between the snake and the canvas, which means that any time the snake collides with the canvas's boundaries the last bit should be redrawn from the opposite side of the canvas. In addition, we've implemented intersection methods for self collision detection and collision detection between rivals, which should be used externally by the hosting screen.\n\nIn the next step we will be implementing the game screen where we will make use of the `Snake` class we've just created, and see how it works in action."
          },
          {
            "manualTitle": "Step 6: Creating a complex game screen with multiple layers",
            "stepRevision": "c27bb0d7806aab70ec489ccd9bbff182d1053dda",
            "manualView": "![snake-demo-game-small](https://cloud.githubusercontent.com/assets/7648874/21074124/8b7cd724-bed7-11e6-9f91-2a211630ac78.gif)\n\nIn this step we will be using the `Snake` class we've just created in the previous step to form the actual game screen - called the `Play` screen. The play screen is a complex screen made out multiple layers as following:\n\n- **`Ready` layer** - Displays a message at the beginning of each match.\n- **`Snake` layer** - Displays the the competitors' snakes.\n- **`Score` layer** - Displays the score board.\n- **`Win` layer** - Displays the winner at the end of each match.\n\nAs we go further with this step, we will give a deeper explanation about each layer and how they interact with each other; As for let's start with the `Play` screen's basis. Regardless of what the `Play` screen should contain at the final result, we want to have the ability to abort the match whenever we press the `Escape` key, therefore, the initial implementation should look like this:\n\n[{]: <helper> (diffStep 6.1)\n\n#### [Step 6.1: Create &#x27;Play&#x27; screen](https://github.com/DAB0mB/radial-snake/commit/e17a45f)\n\n##### Added resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;play&#x2F;index.js\n```diff\n@@ -0,0 +1,14 @@\n+â”Š  â”Š 1â”ŠGame.Screens.Play = class Play extends Engine.Screen {\n+â”Š  â”Š 2â”Š  get events() {\n+â”Š  â”Š 3â”Š    return {\n+â”Š  â”Š 4â”Š      \"keydown\": \"onKeyDown\"\n+â”Š  â”Š 5â”Š    }\n+â”Š  â”Š 6â”Š  }\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Š  onKeyDown() {\n+â”Š  â”Š 9â”Š    // Once escape is pressed, return to main menu screen\n+â”Š  â”Š10â”Š    if (this.keyStates.get(27)) {\n+â”Š  â”Š11â”Š      this.game.changeScreen(Game.Screens.Menu);\n+â”Š  â”Š12â”Š    }\n+â”Š  â”Š13â”Š  }\n+â”Š  â”Š14â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -23,6 +23,7 @@\n â”Š23â”Š23â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/assets_loader.js\"></script>\n â”Š24â”Š24â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š25â”Š25â”Š    <script type=\"text/javascript\" src=\"/scripts/game/entities/snake.js\"></script>\n+â”Š  â”Š26â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/index.js\"></script>\n â”Š26â”Š27â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/menu/index.js\"></script>\n â”Š27â”Š28â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/splash/index.js\"></script>\n â”Š28â”Š29â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n```\n\n[}]: #\n\nNow that we have the `Play` screen, we need to hook it to the `Menu` screen, so whenever we press a key, we will be proceeded to it:\n\n[{]: <helper> (diffStep 6.2)\n\n#### [Step 6.2: Hook &#x27;Play&#x27; screen to &#x27;menu&#x27; screen](https://github.com/DAB0mB/radial-snake/commit/495b9ee)\n\n##### Changed resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;menu&#x2F;index.js\n```diff\n@@ -1,4 +1,10 @@\n â”Š 1â”Š 1â”ŠGame.Screens.Menu = class Menu extends Engine.Screen {\n+â”Š  â”Š 2â”Š  get events() {\n+â”Š  â”Š 3â”Š    return {\n+â”Š  â”Š 4â”Š      \"keydown\": \"onKeyDown\"\n+â”Š  â”Š 5â”Š    }\n+â”Š  â”Š 6â”Š  }\n+â”Š  â”Š 7â”Š\n â”Š 2â”Š 8â”Š  initialize() {\n â”Š 3â”Š 9â”Š    // Initialize snake logo sprite\n â”Š 4â”Š10â”Š    this.logoSprite = new Engine.Sprite(this.assets.logoTexture);\n```\n```diff\n@@ -40,10 +46,18 @@\n â”Š40â”Š46â”Š  }\n â”Š41â”Š47â”Š\n â”Š42â”Š48â”Š  update(span) {\n-â”Š43â”Š  â”Š    this.instructionsAnim.update(span);\n+â”Š  â”Š49â”Š    // On key press, proceed to play screen\n+â”Š  â”Š50â”Š    if (this.keyPressed) {\n+â”Š  â”Š51â”Š      this.game.changeScreen(Game.Screens.Play);\n+â”Š  â”Š52â”Š    }\n+â”Š  â”Š53â”Š    // Else, just update animation\n+â”Š  â”Š54â”Š    else {\n+â”Š  â”Š55â”Š      this.instructionsAnim.update(span);\n+â”Š  â”Š56â”Š    }\n â”Š44â”Š57â”Š  }\n â”Š45â”Š58â”Š\n-â”Š46â”Š  â”Š  update(span) {\n-â”Š47â”Š  â”Š    this.instructionsAnim.update(span);\n+â”Š  â”Š59â”Š  // Register key press\n+â”Š  â”Š60â”Š  onKeyDown(e) {\n+â”Š  â”Š61â”Š    this.keyPressed = true;\n â”Š48â”Š62â”Š  }\n â”Š49â”Š63â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nBy now there shouldn't be anything special. Once you're at the main menu, just press a key as instructed, and you shall see a black screen, which is actually the `Play` screen we've just created; And once you'll press the `Escape` key, you should be receded to the main menu.\n\nThe next stage would be displaying a `Ready` message on the screen, and whenever a key is pressed, the message should fade away using a key-frame animation, and the match should start in the background:\n\n[{]: <helper> (diffStep 6.3)\n\n#### [Step 6.3: Create &#x27;Ready&#x27; layer](https://github.com/DAB0mB/radial-snake/commit/551962d)\n\n##### Added resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;play&#x2F;ready.js\n```diff\n@@ -0,0 +1,59 @@\n+â”Š  â”Š 1â”ŠGame.Screens.Play.Ready = class Ready extends Engine.Layer {\n+â”Š  â”Š 2â”Š  get events() {\n+â”Š  â”Š 3â”Š    return {\n+â”Š  â”Š 4â”Š      \"keydown\": \"onKeyDown\"\n+â”Š  â”Š 5â”Š    };\n+â”Š  â”Š 6â”Š  }\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Š  constructor(screen, snakes) {\n+â”Š  â”Š 9â”Š    super(screen);\n+â”Š  â”Š10â”Š\n+â”Š  â”Š11â”Š    this.snakes = snakes;\n+â”Š  â”Š12â”Š\n+â”Š  â”Š13â”Š    // Create \"ready\" sprite and set its properties\n+â”Š  â”Š14â”Š    let readyTexture = this.assets.minecraftiaFont.createTexture(\"Ready\");\n+â”Š  â”Š15â”Š    let readySprite = new Engine.Sprite(readyTexture);\n+â”Š  â”Š16â”Š    readySprite.align = \"center\";\n+â”Š  â”Š17â”Š    readySprite.setPercentage(\"width\", this.width, 15, \"height\");\n+â”Š  â”Š18â”Š\n+â”Š  â”Š19â”Š    // Create fade out animation for \"ready\" sprite\n+â”Š  â”Š20â”Š    this.readyAnim = new Engine.Animations.Keyframe(readySprite, [\n+â”Š  â”Š21â”Š      {\n+â”Š  â”Š22â”Š        x: this.width / 2,\n+â”Š  â”Š23â”Š        y: this.height / 2,\n+â”Š  â”Š24â”Š        opacity: 1,\n+â”Š  â”Š25â”Š        frame: 0\n+â”Š  â”Š26â”Š      },\n+â”Š  â”Š27â”Š      {\n+â”Š  â”Š28â”Š        y: this.height / 3,\n+â”Š  â”Š29â”Š        opacity: 0,\n+â”Š  â”Š30â”Š        frame: 700\n+â”Š  â”Š31â”Š      }\n+â”Š  â”Š32â”Š    ]);\n+â”Š  â”Š33â”Š  }\n+â”Š  â”Š34â”Š\n+â”Š  â”Š35â”Š  draw(context) {\n+â”Š  â”Š36â”Š    this.readyAnim.draw(context);\n+â”Š  â”Š37â”Š  }\n+â”Š  â”Š38â”Š\n+â”Š  â”Š39â”Š  update(span) {\n+â”Š  â”Š40â”Š    if (!this.ready) return;\n+â”Š  â”Š41â”Š\n+â”Š  â”Š42â”Š    if (this.readyAnim.playing) {\n+â”Š  â”Š43â”Š      this.readyAnim.update(span);\n+â”Š  â”Š44â”Š    }\n+â”Š  â”Š45â”Š    // Once animation is finished, dispose layer\n+â”Š  â”Š46â”Š    else {\n+â”Š  â”Š47â”Š      this.screen.removeLayer(this);\n+â”Š  â”Š48â”Š    }\n+â”Š  â”Š49â”Š  }\n+â”Š  â”Š50â”Š\n+â”Š  â”Š51â”Š  onKeyDown() {\n+â”Š  â”Š52â”Š    // One time event\n+â”Š  â”Š53â”Š    this.disposeEventListeners()\n+â”Š  â”Š54â”Š\n+â”Š  â”Š55â”Š    // This will start playing the animation\n+â”Š  â”Š56â”Š    this.ready = true;\n+â”Š  â”Š57â”Š    this.readyAnim.play();\n+â”Š  â”Š58â”Š  }\n+â”Š  â”Š59â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -24,6 +24,7 @@\n â”Š24â”Š24â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š25â”Š25â”Š    <script type=\"text/javascript\" src=\"/scripts/game/entities/snake.js\"></script>\n â”Š26â”Š26â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/index.js\"></script>\n+â”Š  â”Š27â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/ready.js\"></script>\n â”Š27â”Š28â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/menu/index.js\"></script>\n â”Š28â”Š29â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/splash/index.js\"></script>\n â”Š29â”Š30â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n```\n\n[}]: #\n\nIn order to hook the `Ready` layer to the `Play` screen, we will just push a new instance of it to the layers stack, using the screen's `appendLayer` method. Note that the order of the layer is super critic! Since if we push a new layer it means it will be drawn on top of any previous layer. To \"shift\" a layer to the layers stack, we can simply use the `prependLayer` method instead. Without further due, this is how our hook should look like:\n\n[{]: <helper> (diffStep 6.4)\n\n#### [Step 6.4: Hook &#x27;Ready&#x27; layer to &#x27;Play&#x27; screen](https://github.com/DAB0mB/radial-snake/commit/b461464)\n\n##### Changed resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;play&#x2F;index.js\n```diff\n@@ -5,6 +5,11 @@\n â”Š 5â”Š 5â”Š    }\n â”Š 6â”Š 6â”Š  }\n â”Š 7â”Š 7â”Š\n+â”Š  â”Š 8â”Š  // The ready screen will be the initial screen\n+â”Š  â”Š 9â”Š  initialize(game, snakes) {\n+â”Š  â”Š10â”Š    this.appendLayer(Game.Screens.Play.Ready, snakes);\n+â”Š  â”Š11â”Š  }\n+â”Š  â”Š12â”Š\n â”Š 8â”Š13â”Š  onKeyDown() {\n â”Š 9â”Š14â”Š    // Once escape is pressed, return to main menu screen\n â”Š10â”Š15â”Š    if (this.keyStates.get(27)) {\n```\n\n[}]: #\n\nNow if you'll launch the game and start a new match, you should see a white `Ready` message in the middle of the screen. Up next, would be the `Snake` layer, which will simply initialize 2 new `Snake` instances, and take care of drawing and updating them:\n\n[{]: <helper> (diffStep 6.5)\n\n#### [Step 6.5: Create &#x27;snake&#x27; layer](https://github.com/DAB0mB/radial-snake/commit/a36d7f2)\n\n##### Added resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;play&#x2F;snake.js\n```diff\n@@ -0,0 +1,79 @@\n+â”Š  â”Š 1â”ŠGame.Screens.Play.Snake = class Snake extends Engine.Layer {\n+â”Š  â”Š 2â”Š  constructor(screen, snakes = []) {\n+â”Š  â”Š 3â”Š    super(screen);\n+â”Š  â”Š 4â”Š\n+â”Š  â”Š 5â”Š    // Red snake\n+â”Š  â”Š 6â”Š    this.snakes = [\n+â”Š  â”Š 7â”Š      new Game.Entities.Snake(\n+â”Š  â”Š 8â”Š        this.width / 4,\n+â”Š  â”Š 9â”Š        this.height / 4,\n+â”Š  â”Š10â”Š        50,\n+â”Š  â”Š11â”Š        Math.PI / 4,\n+â”Š  â”Š12â”Š        100,\n+â”Š  â”Š13â”Š        \"FireBrick\",\n+â”Š  â”Š14â”Š        this.keyStates,\n+â”Š  â”Š15â”Š        {\n+â”Š  â”Š16â”Š          // Use score from previous matches\n+â”Š  â”Š17â”Š          score: snakes[0] && snakes[0].score,\n+â”Š  â”Š18â”Š          keys: {\n+â”Š  â”Š19â”Š            left: 37, // Left key\n+â”Š  â”Š20â”Š            right: 39 // RIght key\n+â”Š  â”Š21â”Š        }\n+â”Š  â”Š22â”Š      }),\n+â”Š  â”Š23â”Š\n+â”Š  â”Š24â”Š      // Blue snake\n+â”Š  â”Š25â”Š      new Game.Entities.Snake(\n+â”Š  â”Š26â”Š        (this.width / 4) * 3,\n+â”Š  â”Š27â”Š        (this.height / 4) * 3,\n+â”Š  â”Š28â”Š        50,\n+â”Š  â”Š29â”Š        (-Math.PI / 4) * 3,\n+â”Š  â”Š30â”Š        100,\n+â”Š  â”Š31â”Š        \"DodgerBlue\",\n+â”Š  â”Š32â”Š        this.keyStates,\n+â”Š  â”Š33â”Š        {\n+â”Š  â”Š34â”Š          score: snakes[1] && snakes[1].score,\n+â”Š  â”Š35â”Š          keys: {\n+â”Š  â”Š36â”Š            left: 65, // 'a' key\n+â”Š  â”Š37â”Š            right: 68 // 'b' key\n+â”Š  â”Š38â”Š        }\n+â”Š  â”Š39â”Š      })\n+â”Š  â”Š40â”Š    ];\n+â”Š  â”Š41â”Š  }\n+â”Š  â”Š42â”Š\n+â”Š  â”Š43â”Š  draw(context) {\n+â”Š  â”Š44â”Š    // Draw each snake in the snakes array\n+â”Š  â”Š45â”Š    this.snakes.forEach(snake => snake.draw(context));\n+â”Š  â”Š46â”Š  }\n+â”Š  â”Š47â”Š\n+â”Š  â”Š48â”Š  update(span) {\n+â”Š  â”Š49â”Š    if (!this.snakes.length) return;\n+â”Š  â”Š50â”Š\n+â”Š  â”Š51â”Š    // Storing original snakes array for future use, since it might get changed\n+â”Š  â”Š52â”Š    let snakes = this.snakes.slice();\n+â”Š  â”Š53â”Š\n+â”Š  â”Š54â”Š    snakes.forEach((snake, index) => {\n+â”Š  â”Š55â”Š      snake.update(span, this.width, this.height);\n+â”Š  â”Š56â”Š      // Disqualify if intersected with self\n+â”Š  â”Š57â”Š      if (snake.getSelfIntersection()) return this.snakes.splice(index, 1);\n+â”Š  â”Š58â”Š\n+â”Š  â”Š59â”Š      snakes.forEach((opponent) => {\n+â”Š  â”Š60â”Š        // Don't scan for intersection with self, obviously this will always be true\n+â”Š  â”Š61â”Š        if (opponent === snake) return;\n+â”Š  â”Š62â”Š        // Disqualify if intersected with opponent\n+â”Š  â”Š63â”Š        if (snake.getSnakeIntersection(opponent)) this.snakes.splice(index, 1);\n+â”Š  â”Š64â”Š      });\n+â”Š  â”Š65â”Š    });\n+â”Š  â”Š66â”Š\n+â”Š  â”Š67â”Š    // There can be only one winner, or a tie (very rare, most likely not to happen)\n+â”Š  â”Š68â”Š    // If the match is already finished, skip the next steps since they are not relevant\n+â”Š  â”Š69â”Š    if (this.snakes.length > 1 || this.matchFinished) return;\n+â”Š  â”Š70â”Š\n+â”Š  â”Š71â”Š    // The winner is the \"last snake standing\"\n+â”Š  â”Š72â”Š    let winner = this.snakes[0];\n+â”Š  â”Š73â”Š    // If this is not a tie, which is a very rare case, increase the winner's score\n+â”Š  â”Š74â”Š    if (winner) winner.score++;\n+â”Š  â”Š75â”Š\n+â”Š  â”Š76â”Š    // Indicates whether we should update the score counter or not\n+â”Š  â”Š77â”Š    this.matchFinished = true;\n+â”Š  â”Š78â”Š  }\n+â”Š  â”Š79â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -24,6 +24,7 @@\n â”Š24â”Š24â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š25â”Š25â”Š    <script type=\"text/javascript\" src=\"/scripts/game/entities/snake.js\"></script>\n â”Š26â”Š26â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/index.js\"></script>\n+â”Š  â”Š27â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/snake.js\"></script>\n â”Š27â”Š28â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/ready.js\"></script>\n â”Š28â”Š29â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/menu/index.js\"></script>\n â”Š29â”Š30â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/splash/index.js\"></script>\n```\n\n[}]: #\n\nOnce pressing a key in the `Ready` layer, not only we want to display an animation, but we also want the match to start in the background, thus, we gonna push a new instance of the `Snake` layer we've just created like so:\n\n[{]: <helper> (diffStep 6.6)\n\n#### [Step 6.6: Hook &#x27;snake&#x27; layer to &#x27;ready&#x27; layer](https://github.com/DAB0mB/radial-snake/commit/982db7b)\n\n##### Changed resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;play&#x2F;ready.js\n```diff\n@@ -55,5 +55,8 @@\n â”Š55â”Š55â”Š    // This will start playing the animation\n â”Š56â”Š56â”Š    this.ready = true;\n â”Š57â”Š57â”Š    this.readyAnim.play();\n+â”Š  â”Š58â”Š\n+â”Š  â”Š59â”Š    // Start the game in the background\n+â”Š  â”Š60â”Š    this.screen.prependLayer(Game.Screens.Play.Snake, this.snakes);\n â”Š58â”Š61â”Š  }\n â”Š59â”Š62â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nNote that the layer is pushed when the animation starts and not once finished; This would give a nice smooth feeling to our game-flow. If you'll test out the game, you would discover that the match is actually playable! The first snake (Red) snake should be controlled by the arrow keys, and the second snake (Blue) should be controlled by the letter keys `a`, `s`, `d` and `w`. So far, the snakes function great, but you can probably tell that whenever a match is finished, it feels a bit dull. There's no indication of winning, and there's no score board to present the score of each competitor, which brings us to the next stage - Implementing the `Score` layer.\n\nThe `Score` layer is a simple layer which takes the 2 snakes as a parameter and displays their scores at the top of the screen:\n\n[{]: <helper> (diffStep 6.7)\n\n#### [Step 6.7: Create &#x27;Score&#x27; layer](https://github.com/DAB0mB/radial-snake/commit/6ec4cac)\n\n##### Added resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;play&#x2F;score.js\n```diff\n@@ -0,0 +1,66 @@\n+â”Š  â”Š 1â”ŠGame.Screens.Play.Score = class Score extends Engine.Layer {\n+â”Š  â”Š 2â”Š  constructor(screen, snakes) {\n+â”Š  â”Š 3â”Š    super(screen);\n+â”Š  â”Š 4â”Š\n+â”Š  â”Š 5â”Š    this.snakes = snakes;\n+â”Š  â”Š 6â”Š    this.scoreSprites = [];\n+â”Š  â”Š 7â”Š    this.scores = [];\n+â”Š  â”Š 8â”Š\n+â”Š  â”Š 9â”Š    // It's important to match indexes to each snake since the number of snakes\n+â”Š  â”Š10â”Š    // can be reduced along the way as we play\n+â”Š  â”Š11â”Š    snakes.forEach((snake, index) => {\n+â”Š  â”Š12â”Š      snake.index = index;\n+â”Š  â”Š13â”Š    });\n+â”Š  â”Š14â”Š  }\n+â”Š  â”Š15â”Š\n+â”Š  â”Š16â”Š  draw(context) {\n+â”Š  â”Š17â”Š    this.scoreSprites.forEach((scoreSprite) => {\n+â”Š  â”Š18â”Š      scoreSprite.draw(context);\n+â”Š  â”Š19â”Š    });\n+â”Š  â”Š20â”Š  }\n+â”Š  â”Š21â”Š\n+â”Š  â”Š22â”Š  update(span) {\n+â”Š  â”Š23â”Š    this.snakes.forEach(snake => {\n+â”Š  â”Š24â”Š      let index = snake.index;\n+â”Š  â”Š25â”Š      if (this.scores[index] == snake.score) return;\n+â”Š  â”Š26â”Š\n+â”Š  â”Š27â”Š      // The sprite might be changed along the way so it's important to recreate it\n+â”Š  â”Š28â”Š      // over and over again. If no change was made the cache will be used by the engine\n+â”Š  â”Š29â”Š      this.scoreSprites[index] = this.createScoreSprite(snake);\n+â”Š  â”Š30â”Š      this.scores[index] = snake.score;\n+â”Š  â”Š31â”Š    });\n+â”Š  â”Š32â”Š  }\n+â”Š  â”Š33â”Š\n+â”Š  â”Š34â”Š  createScoreSprite(snake) {\n+â”Š  â”Š35â”Š    let minecraftiaFont = this.assets.minecraftiaFont;\n+â”Š  â”Š36â”Š    minecraftiaFont.save();\n+â”Š  â”Š37â”Š    minecraftiaFont.color = snake.color;\n+â”Š  â”Š38â”Š\n+â”Š  â”Š39â”Š    // Create a score sprite for the snake\n+â”Š  â”Š40â”Š    let scoreTexture = minecraftiaFont.createTexture(`${snake.score}`, {\n+â”Š  â”Š41â”Š      noOffsets: true,\n+â”Š  â”Š42â”Š      noSpaces: true\n+â”Š  â”Š43â”Š    });\n+â”Š  â”Š44â”Š\n+â”Š  â”Š45â”Š    let scoreSprite = new Engine.Sprite(scoreTexture);\n+â”Š  â”Š46â”Š\n+â”Š  â”Š47â”Š    // Size of score board is dynamic to screen size\n+â”Š  â”Š48â”Š    scoreSprite.setPercentage(\"width\", this.width, 4, \"height\");\n+â”Š  â”Š49â”Š\n+â”Š  â”Š50â”Š    // Set alignment modes.\n+â”Š  â”Š51â”Š    // Once we add more snakes we should add more cases here\n+â”Š  â”Š52â”Š    switch (snake.index) {\n+â”Š  â”Š53â”Š      case 0:\n+â”Š  â”Š54â”Š        scoreSprite.align = \"top-left\";\n+â”Š  â”Š55â”Š        break;\n+â”Š  â”Š56â”Š      case 1:\n+â”Š  â”Š57â”Š        scoreSprite.align = \"top-right\";\n+â”Š  â”Š58â”Š        scoreSprite.x = this.width;\n+â”Š  â”Š59â”Š        break;\n+â”Š  â”Š60â”Š    }\n+â”Š  â”Š61â”Š\n+â”Š  â”Š62â”Š    // Restore the font to its original color\n+â”Š  â”Š63â”Š    minecraftiaFont.restore();\n+â”Š  â”Š64â”Š    return scoreSprite;\n+â”Š  â”Š65â”Š  }\n+â”Š  â”Š66â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -24,6 +24,7 @@\n â”Š24â”Š24â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š25â”Š25â”Š    <script type=\"text/javascript\" src=\"/scripts/game/entities/snake.js\"></script>\n â”Š26â”Š26â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/index.js\"></script>\n+â”Š  â”Š27â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/score.js\"></script>\n â”Š27â”Š28â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/snake.js\"></script>\n â”Š28â”Š29â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/ready.js\"></script>\n â”Š29â”Š30â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/menu/index.js\"></script>\n```\n\n[}]: #\n\n> Note that the current score board is suitable for two players, but can easily be modified to support as much players as you want if done correctly.\n\nThe `Score` board should be appended to the layers stack as soon as the `Snake` layers is initialized, so it would be available to us once the match is started:\n\n[{]: <helper> (diffStep 6.8)\n\n#### [Step 6.8: Hook &#x27;Score&#x27; layer to &#x27;Snake&#x27; layer](https://github.com/DAB0mB/radial-snake/commit/feb4a0b)\n\n##### Changed resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;play&#x2F;snake.js\n```diff\n@@ -38,6 +38,9 @@\n â”Š38â”Š38â”Š        }\n â”Š39â”Š39â”Š      })\n â”Š40â”Š40â”Š    ];\n+â”Š  â”Š41â”Š\n+â”Š  â”Š42â”Š    // Show score board for newly created snakes\n+â”Š  â”Š43â”Š    screen.appendLayer(Game.Screens.Play.Score, this.snakes);\n â”Š41â”Š44â”Š  }\n â”Š42â”Š45â”Š\n â”Š43â”Š46â”Š  draw(context) {\n```\n\n[}]: #\n\nNow we're one layer further from completing the `Play` screen, the only thing missing is the `Win` layer, which should present the winner once the match is finished:\n\n[{]: <helper> (diffStep 6.9)\n\n#### [Step 6.9: Create &#x27;Win&#x27; layer](https://github.com/DAB0mB/radial-snake/commit/3476384)\n\n##### Added resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;play&#x2F;win.js\n```diff\n@@ -0,0 +1,43 @@\n+â”Š  â”Š 1â”ŠGame.Screens.Play.Win = class Win extends Engine.Layer {\n+â”Š  â”Š 2â”Š  constructor(screen, snakes, winner) {\n+â”Š  â”Š 3â”Š    super(screen);\n+â”Š  â”Š 4â”Š\n+â”Š  â”Š 5â”Š    this.snakes = snakes;\n+â”Š  â”Š 6â”Š    this.winner = winner;\n+â”Š  â”Š 7â”Š    // ttl stands for \"time to live\", which means, this layer is going to be\n+â”Š  â”Š 8â”Š    // disposed after 3 seconds\n+â”Š  â”Š 9â”Š    this.ttl = 3000;\n+â”Š  â”Š10â”Š\n+â”Š  â”Š11â”Š    // If there is a winner\n+â”Š  â”Š12â”Š    if (this.winner) {\n+â”Š  â”Š13â”Š      // Message could be something like \"RED SNAKE WINS\"\n+â”Š  â”Š14â”Š      var text = `${this.winner.color.toUpperCase()} SNAKE WINS`;\n+â”Š  â”Š15â”Š      var percent = 40;\n+â”Š  â”Š16â”Š    }\n+â”Š  â”Š17â”Š    // If there is a tie\n+â”Š  â”Š18â”Š    else {\n+â”Š  â”Š19â”Š      var text = 'TIE';\n+â”Š  â”Š20â”Š      var percent = 15;\n+â”Š  â”Š21â”Š    }\n+â”Š  â”Š22â”Š\n+â”Š  â”Š23â”Š    // Create winner sprite and set its properties\n+â”Š  â”Š24â”Š    let winnerTexture = this.assets.minecraftiaFont.createTexture(text);\n+â”Š  â”Š25â”Š    this.winnerSprite = new Engine.Sprite(winnerTexture);\n+â”Š  â”Š26â”Š    this.winnerSprite.align = \"center\";\n+â”Š  â”Š27â”Š    this.winnerSprite.setPercentage(\"width\", this.width, percent, \"height\");\n+â”Š  â”Š28â”Š    this.winnerSprite.x = this.width / 2;\n+â”Š  â”Š29â”Š    this.winnerSprite.y = this.height / 2;\n+â”Š  â”Š30â”Š  }\n+â”Š  â”Š31â”Š\n+â”Š  â”Š32â”Š  draw(context) {\n+â”Š  â”Š33â”Š    this.winnerSprite.draw(context);\n+â”Š  â”Š34â”Š  }\n+â”Š  â”Š35â”Š\n+â”Š  â”Š36â”Š  update(span) {\n+â”Š  â”Š37â”Š    // If limit not yet reached, abort\n+â”Š  â”Š38â”Š    if (this.age < this.ttl) return;\n+â”Š  â”Š39â”Š\n+â”Š  â”Š40â”Š    // Show \"ready\" message all over again, only this time use the updated score board\n+â”Š  â”Š41â”Š    this.screen.game.changeScreen(Game.Screens.Play, this.snakes);\n+â”Š  â”Š42â”Š  }\n+â”Š  â”Š43â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -24,6 +24,7 @@\n â”Š24â”Š24â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š25â”Š25â”Š    <script type=\"text/javascript\" src=\"/scripts/game/entities/snake.js\"></script>\n â”Š26â”Š26â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/index.js\"></script>\n+â”Š  â”Š27â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/win.js\"></script>\n â”Š27â”Š28â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/score.js\"></script>\n â”Š28â”Š29â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/snake.js\"></script>\n â”Š29â”Š30â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/ready.js\"></script>\n```\n\n[}]: #\n\nNote how we use the `changeScreen` method once the `Win` layer has reached its age limit (Time to live, aka `ttl`); This would clear the layers stack and restart the `Play` screen, so we can start a new match all-over, only this time we will pass the `Snake` instances to reserve the original scores. The `Win` layer should be presented whenever a collision has been detected between the snakes:\n\n[{]: <helper> (diffStep 6.1)\n\n#### [Step 6.1: Create &#x27;Play&#x27; screen](https://github.com/DAB0mB/radial-snake/commit/e17a45f)\n\n##### Added resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;play&#x2F;index.js\n```diff\n@@ -0,0 +1,14 @@\n+â”Š  â”Š 1â”ŠGame.Screens.Play = class Play extends Engine.Screen {\n+â”Š  â”Š 2â”Š  get events() {\n+â”Š  â”Š 3â”Š    return {\n+â”Š  â”Š 4â”Š      \"keydown\": \"onKeyDown\"\n+â”Š  â”Š 5â”Š    }\n+â”Š  â”Š 6â”Š  }\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Š  onKeyDown() {\n+â”Š  â”Š 9â”Š    // Once escape is pressed, return to main menu screen\n+â”Š  â”Š10â”Š    if (this.keyStates.get(27)) {\n+â”Š  â”Š11â”Š      this.game.changeScreen(Game.Screens.Menu);\n+â”Š  â”Š12â”Š    }\n+â”Š  â”Š13â”Š  }\n+â”Š  â”Š14â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -23,6 +23,7 @@\n â”Š23â”Š23â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/assets_loader.js\"></script>\n â”Š24â”Š24â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š25â”Š25â”Š    <script type=\"text/javascript\" src=\"/scripts/game/entities/snake.js\"></script>\n+â”Š  â”Š26â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/index.js\"></script>\n â”Š26â”Š27â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/menu/index.js\"></script>\n â”Š27â”Š28â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/splash/index.js\"></script>\n â”Š28â”Š29â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n```\n\n[}]: #\n\nThat's it folks, the `Play` screen is finished, and you can play as much matches as you'd feel like.\n\nAlthough the game is finished, it can still be optimized using `C++`. To discover more on hooking efficiency and how we can hook `C++` to the browser, see the next step."
          },
          {
            "manualTitle": "Step 7: Bonus! Re-implementing geometry in C++",
            "stepRevision": "cea4cffcc2f5e801020ed13ef8f1edde608c85f3",
            "manualView": "> This step is part of a bigger tutorial series where we learn how to create a game engine and implement a Tron-style game in JavaScript. The base project for the following step is available [here](https://github.com/DAB0mB/radial-snake/tree/step6).\n\nSo far I covered up pretty much everything I planned. I showed you how to create a game engine, including a font generator, an animation player and a screening system. On top of that, we've learned how to structure and organize our code well, so if in the future we'd like to extend our game by adding more screens or capabilities, we can do that with ease. Indeed, we've went through lots of great stuff, and if you've reached this point I give you my thumbs up. If so far this wasn't enough, in this step we will be focusing on optimization, and making our game engine run faster (a lot, faster). Obviously, when talking about optimizations, the first thing you would probably think of is how we can make our algorithms efficient by using minimum number of operations. While this is true, we will be actually focusing on optimizing our code using C++.\n\nUnlike JavaScript, which is a dynamic scripting file executed by an interpreter, C++ is a general purpose language which compiles into executables. Naturally, executables are much faster than scripts, since they don't have to be interpreted, and they can approach the hardware and memory much faster. In C++, we have to explicitly define our data-types, meaning that variables don't have to be parsed during run-time. While explicit variables definition is C++'s biggest drawback, it's also one of its biggest advantages. The mere fact that variables can be handled much faster, makes code much more efficient.\n\nAccordingly, we can conclude that the programming language we're using plays a very important role when it comes to efficiency. So how exactly are we going to integrate C++ into the browser? We're going to do that by using a compiler called - [Emscripten](http://kripken.github.io/emscripten-site/).\n\n![emscripten](https://cloud.githubusercontent.com/assets/7648874/22675449/ee6d7e9c-eccc-11e6-9570-1dd5d982ee66.png)\n\nEmscripten is an Open Source [LLVM](https://en.wikipedia.org/wiki/LLVM) to JavaScript compiler. Using Emscripten you can:\n\n- Compile C and C++ code into JavaScript\n- Compile any other code that can be translated into LLVM bitcode into JavaScript.\n- Compile the C/C++ runtimes of other languages into JavaScript, and then run code in those other languages in an indirect way (this has been done for Python and Lua)!\n\nLLVM is a library that is used to construct, optimize and produce intermediate and/or binary machine code. LLVM can be used as a compiler framework, where you provide the \"front end\" (parser and lexer) and the \"back end\" (code that converts LLVM's representation to actual machine code). LLVM can also act as a JIT compiler - it has support for x86/x86_64 and PPC/PPC64 assembly generation with fast code optimizations aimed for compilation speed.\n\nEmscripten operates by taking LLVM code and converting it into a subset of JavaScript called asm.js that can run anywhere that JavaScript can run (usually the browser, but also Node.js, etc.) and is easy for browsers to optimize. This means that you can basically write web applications in any language that has an LLVM compiler.\n\n![emscripten-flow](https://cloud.githubusercontent.com/assets/7648874/22675751/b244b76c-ecce-11e6-917e-f7039ed4b340.png)\n\nIn order to use Emscripten you will first have to install it. I recommend you to follow Emscripten's official installation instructions at their website over [here](https://kripken.github.io/emscripten-site/docs/getting_started/downloads.html). Installing Emscripten might be a bit tiring for some, I know for me it was, but if you're hyped about writing native code in the browser as much as I do, take as much time as needed to install it, and bare with me.\n\nAssuming that you have Emscripten installed, we can get right to business. The goal for this step is to re-implement our geometry namespace in C++, and to be more specific, the circle class and line class. We will start by creating an entry file for our C++ code under the path `resources/cpp/src/index.cpp`:\n\n    $ mkdir resources/cpp\n    $ mkdir resources/cpp/src\n    $ touch resources/cpp/src/index.cpp\n\nFrom now on, every C++ file that we would like to run in the browser should be included in the `index.cpp` file we've just created, otherwise it's not going to appear anywhere. The first stage for re-implementing our geometry would be re-writing the utility module, since our geometry is heavily based on it; Therefore the firs inclusion in our `index.cpp` file would be the following:\n\n[{]: <helper> (diffStep 7.1)\n\n#### [Step 7.1: Add CPP entry script](https://github.com/DAB0mB/radial-snake/commit/2f35323)\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;index.cpp\n```diff\n@@ -0,0 +1 @@\n+â”Š â”Š1â”Š#include \"utils.cpp\"ðŸš«â†µ\n```\n\n[}]: #\n\nFollowing that, we will create the `utils.cpp` module included above, which is a direct translation from C++ to JavaScript for the `utils.js` we've created earlier in this tutorial.\n\n[{]: <helper> (diffStep 7.2)\n\n#### [Step 7.2: Add base utility CPP module](https://github.com/DAB0mB/radial-snake/commit/6dba512)\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;utils.cpp\n```diff\n@@ -0,0 +1,73 @@\n+â”Š  â”Š 1â”Š#include <cfloat>\n+â”Š  â”Š 2â”Š#include <cmath>\n+â”Š  â”Š 3â”Š#include <string>\n+â”Š  â”Š 4â”Š#include \"utils.h\"\n+â”Š  â”Š 5â”Š\n+â”Š  â”Š 6â”Šnamespace utils {\n+â”Š  â”Š 7â”Š  // Fixed modulo method which can calculate modulo of negative numbers properly\n+â”Š  â”Š 8â”Š  // e.g. (-803).mod(800) returns 797\n+â”Š  â”Š 9â”Š  double mod(double context, double num) {\n+â”Š  â”Š10â”Š    return std::fmod((std::fmod(context, num) + num), num);\n+â”Š  â”Š11â”Š  }\n+â”Š  â”Š12â”Š\n+â”Š  â”Š13â”Š  // Trims number and leaves the number of decimals specified.\n+â”Š  â”Š14â”Š  // The \"mode\" argument specifies which math function should be invoked\n+â”Š  â”Š15â”Š  // right after the number has been trimmed.\n+â”Š  â”Š16â”Š  // e.g. 12.12345.trim(3, \"ceil\") returns 12.124\n+â”Š  â”Š17â”Š  double trim(double context, int decimals, const std::string mode) {\n+â”Š  â”Š18â”Š    double accumulator = context * std::pow(10, decimals);\n+â”Š  â”Š19â”Š\n+â”Š  â”Š20â”Š    if (mode.compare(\"ceil\") == 0)\n+â”Š  â”Š21â”Š      accumulator = std::ceil(accumulator);\n+â”Š  â”Š22â”Š    else if (mode.compare(\"floor\") == 0)\n+â”Š  â”Š23â”Š      accumulator = std::floor(accumulator);\n+â”Š  â”Š24â”Š    else\n+â”Š  â”Š25â”Š      accumulator = std::round(accumulator);\n+â”Š  â”Š26â”Š\n+â”Š  â”Š27â”Š    return accumulator / std::pow(10, decimals);\n+â”Š  â”Š28â”Š  }\n+â”Š  â”Š29â”Š\n+â”Š  â”Š30â”Š  // Tells if number is in specified range based on given precision.\n+â”Š  â”Š31â”Š  // See the \"compare\" method for more information about precision\n+â”Š  â”Š32â”Š  bool isBetween(double context, double num1, double num2, const std::string precision) {\n+â”Š  â”Š33â”Š    return compare(context, std::min(num1, num2), \">=\", precision) &&\n+â”Š  â”Š34â”Š           compare(context, std::max(num1, num2), \"<=\", precision);\n+â”Š  â”Š35â”Š  }\n+â”Š  â”Š36â”Š\n+â”Š  â”Š37â”Š  bool compare(double context, double num, const std::string precision) {\n+â”Š  â”Š38â”Š    return compare(context, num, \"==\", precision);\n+â”Š  â”Š39â”Š  }\n+â”Š  â”Š40â”Š\n+â”Š  â”Š41â”Š  // Initiates comparison operator between context number and a given number, only here\n+â”Š  â”Š42â”Š  // a precision can be specified\n+â”Š  â”Š43â”Š  bool compare(double context, double num, const std::string method, const std::string precision) {\n+â”Š  â”Š44â”Š    // Fixed precision, \"almost equal\" with a deviation of Îµ\n+â”Š  â”Š45â”Š    if (precision.compare(\"f\") == 0) {\n+â”Š  â”Š46â”Š      if (method.compare(\"<\") == 0 ||\n+â”Š  â”Š47â”Š          method.compare(\"<=\") == 0)\n+â”Š  â”Š48â”Š        return context <= num + DBL_EPSILON;\n+â”Š  â”Š49â”Š      if (method.compare(\">\") == 0 ||\n+â”Š  â”Š50â”Š          method.compare(\">=\") == 0)\n+â”Š  â”Š51â”Š        return context >= num - DBL_EPSILON;\n+â”Š  â”Š52â”Š      return std::abs(context - num) <= DBL_EPSILON;\n+â”Š  â”Š53â”Š    }\n+â”Š  â”Š54â”Š    // Pixel precision, round comparison\n+â”Š  â”Š55â”Š    else if (precision.compare(\"px\") == 0) {\n+â”Š  â”Š56â”Š      if (method.compare(\"<\") == 0 ||\n+â”Š  â”Š57â”Š          method.compare(\"<=\") == 0)\n+â”Š  â”Š58â”Š        return std::round(context) <= std::round(num);\n+â”Š  â”Š59â”Š      if (method.compare(\">\") == 0 ||\n+â”Š  â”Š60â”Š          method.compare(\">=\") == 0)\n+â”Š  â”Š61â”Š        return std::round(context) >= std::round(num);\n+â”Š  â”Š62â”Š      return std::round(context) == std::round(num);\n+â”Š  â”Š63â”Š    }\n+â”Š  â”Š64â”Š    // Exact precision\n+â”Š  â”Š65â”Š    else {\n+â”Š  â”Š66â”Š      if (method.compare(\"<\") == 0) return context < num;\n+â”Š  â”Š67â”Š      if (method.compare(\"<=\") == 0) return context <= num;\n+â”Š  â”Š68â”Š      if (method.compare(\">\") == 0) return context > num;\n+â”Š  â”Š69â”Š      if (method.compare(\">=\") == 0) return context >= num;\n+â”Š  â”Š70â”Š      return context == num;\n+â”Š  â”Š71â”Š    }\n+â”Š  â”Š72â”Š  }\n+â”Š  â”Š73â”Š}ðŸš«â†µ\n```\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;utils.h\n```diff\n@@ -0,0 +1,15 @@\n+â”Š  â”Š 1â”Š#pragma once\n+â”Š  â”Š 2â”Š\n+â”Š  â”Š 3â”Š#include <string>\n+â”Š  â”Š 4â”Š\n+â”Š  â”Š 5â”Šnamespace utils {\n+â”Š  â”Š 6â”Š  double mod(double context, double num);\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Š  double trim(double context, int decimals, const std::string mode = \"round\");\n+â”Š  â”Š 9â”Š\n+â”Š  â”Š10â”Š  bool isBetween(double context, double num1, double num2, const std::string precision = \"exact\");\n+â”Š  â”Š11â”Š\n+â”Š  â”Š12â”Š  bool compare(double context, double num, const std::string precision = \"exact\");\n+â”Š  â”Š13â”Š\n+â”Š  â”Š14â”Š  bool compare(double context, double num, const std::string method, const std::string precision);\n+â”Š  â”Š15â”Š}ðŸš«â†µ\n```\n\n[}]: #\n\nThe module above should work by itself when interacting with it inside the C++ scope, but that's not what we're striving for. We want this module to be available for use in our JavaScript project. This requires us to wrap our code in such a way the the Emscripten compiler will know how to compile it. Apart from providing a compiler, Emscripten provides us with functions and macros that will help use bind our C++ code to the JavaScript environment. These functionalities are packed in a single library which can be imported in our C++ code, and it is called [Embind](https://kripken.github.io/emscripten-site/docs/porting/connecting_cpp_and_javascript/embind.html) (probably stands for \"Emscripten bind\"). Using EMBind, let's wrap our utils module accordingly:\n\n[{]: <helper> (diffStep 7.3)\n\n#### [Step 7.3: EMBind CPP utils](https://github.com/DAB0mB/radial-snake/commit/0f34332)\n\n##### Changed resources&#x2F;cpp&#x2F;src&#x2F;utils.cpp\n```diff\n@@ -1,6 +1,7 @@\n â”Š1â”Š1â”Š#include <cfloat>\n â”Š2â”Š2â”Š#include <cmath>\n â”Š3â”Š3â”Š#include <string>\n+â”Š â”Š4â”Š#include <emscripten/bind.h>\n â”Š4â”Š5â”Š#include \"utils.h\"\n â”Š5â”Š6â”Š\n â”Š6â”Š7â”Šnamespace utils {\n```\n```diff\n@@ -70,4 +71,15 @@\n â”Š70â”Š71â”Š      return context == num;\n â”Š71â”Š72â”Š    }\n â”Š72â”Š73â”Š  }\n+â”Š  â”Š74â”Š}\n+â”Š  â”Š75â”Š\n+â”Š  â”Š76â”ŠEMSCRIPTEN_BINDINGS(utils_module) {\n+â”Š  â”Š77â”Š  emscripten::function(\"utils_mod\", &utils::mod);\n+â”Š  â”Š78â”Š  emscripten::function(\"utils_trim\", &utils::trim);\n+â”Š  â”Š79â”Š  emscripten::function(\"utils_isBetween\", &utils::isBetween);\n+â”Š  â”Š80â”Š  emscripten::function(\"utils_compare\",\n+â”Š  â”Š81â”Š    emscripten::select_overload<bool(double, double, const std::string, const std::string)>(\n+â”Š  â”Š82â”Š      &utils::compare\n+â”Š  â”Š83â”Š    )\n+â”Š  â”Š84â”Š  );\n â”Š73â”Š85â”Š}ðŸš«â†µ\n```\n\n[}]: #\n\nAfter a while you'll get used for Embind's API. If you'll look at it, it's self explanatory and easy to understand. Bound objects will be available the JavaScript environment will be available under an object named `Module`, e.g. the C++ method `mod` will be available for use as `Module.utils_mod`. Bound functions should have supported return types and argument types, meaning that if we're using a custom structure as a return type or an argument type, we first need to wrap it using EMBind, otherwise the compiler won't know how to handle it. A list of natively supported data-types can be found [here](https://kripken.github.io/emscripten-site/docs/porting/connecting_cpp_and_javascript/embind.html#built-in-type-conversions).\n\nEven though we've wrapped our C++ code and hypothetically it can already be used in the browser, I'd go for a second wrapper, since the compiled code doesn't have the optimal architecture. Right now we will have to approach C++ utility functions using `Module.utils_foo`. Instead, I'd like it to be `CPP.Utils.foo`, since it's clearer this way. The output of the Emscripten compiler can be wrapped with JavaScript code, using a prefix and a suffix, defined in 2 separate files respectively, called `pre.js` and `post.js`:\n\n[{]: <helper> (diffStep 7.4)\n\n#### [Step 7.4: Create CPP wrappers](https://github.com/DAB0mB/radial-snake/commit/cc28a34)\n\n##### Added resources&#x2F;cpp&#x2F;post.js\n```diff\n@@ -0,0 +1,10 @@\n+â”Š  â”Š 1â”Šreturn {\n+â”Š  â”Š 2â”Š  Utils: {\n+â”Š  â”Š 3â”Š    mod: Module.utils_mod,\n+â”Š  â”Š 4â”Š    trim: Module.utils_trim,\n+â”Š  â”Š 5â”Š    isBetween: Module.utils_isBetween,\n+â”Š  â”Š 6â”Š    compare: Module.utils_compare\n+â”Š  â”Š 7â”Š  }\n+â”Š  â”Š 8â”Š};\n+â”Š  â”Š 9â”Š\n+â”Š  â”Š10â”Š})();ðŸš«â†µ\n```\n\n##### Added resources&#x2F;cpp&#x2F;pre.js\n```diff\n@@ -0,0 +1 @@\n+â”Š â”Š1â”ŠCPP = (function() {ðŸš«â†µ\n```\n\n[}]: #\n\nWhat we've done in the code snippet above, we've created an anonymous function which calls itself, and inside we've exported a new namespace called `CPP` (C++). This way we can keep the generated code encapsulated, without worrying about spamming the global object.\n\nAfter creating a wrapper, I'd also recommend you to integrate the generated C++ code into existing namespaces, meaning that if for example we would like to approach the `CPP.Utils.foo` method, it could be done using `Utils.foo`. This way existing code won't have to be changed, and extra wrapping logic can be applied with ease, like the chaining logic implemented in the `Utils` namespace:\n\n[{]: <helper> (diffStep 7.5)\n\n#### [Step 7.5: Bind CPP utils to JS utils](https://github.com/DAB0mB/radial-snake/commit/0a67d50)\n\n##### Changed resources&#x2F;scripts&#x2F;utils.js\n```diff\n@@ -16,53 +16,9 @@\n â”Š16â”Š16â”Š  return chain;\n â”Š17â”Š17â”Š};\n â”Š18â”Š18â”Š\n-â”Š19â”Š  â”Š// Fixed modulo method which can calculate modulo of negative numbers properly\n-â”Š20â”Š  â”Š// e.g. (-803).mod(800) returns 797\n-â”Š21â”Š  â”ŠUtils.mod = function (context, num) {\n-â”Š22â”Š  â”Š  return ((context % num) + num) % num;\n-â”Š23â”Š  â”Š};\n-â”Š24â”Š  â”Š\n-â”Š25â”Š  â”Š// Trims number and leaves the number of decimals specified.\n-â”Š26â”Š  â”Š// The \"mode\" argument specifies which math function should be invoked\n-â”Š27â”Š  â”Š// right after the number has been trimmed.\n-â”Š28â”Š  â”Š// e.g. 12.12345.trim(3, \"ceil\") returns 12.124\n-â”Š29â”Š  â”ŠUtils.trim = function (context, decimals, mode = \"round\") {\n-â”Š30â”Š  â”Š  return Math[mode](context * Math.pow(10, decimals)) / Math.pow(10, decimals);\n-â”Š31â”Š  â”Š};\n-â”Š32â”Š  â”Š\n-â”Š33â”Š  â”Š// Tells if number is in specified range based on given precision.\n-â”Š34â”Š  â”Š// See the \"compare\" method for more information about precision\n-â”Š35â”Š  â”ŠUtils.isBetween = function (context, num1, num2, precision) {\n-â”Š36â”Š  â”Š  return Utils.compare(context, Math.min(num1, num2), \">=\", precision) &&\n-â”Š37â”Š  â”Š         Utils.compare(context, Math.max(num1, num2), \"<=\", precision);\n-â”Š38â”Š  â”Š};\n-â”Š39â”Š  â”Š\n-â”Š40â”Š  â”Š// Initiates comparison operator between context number and a given number, only here\n-â”Š41â”Š  â”Š// a precision can be specified\n-â”Š42â”Š  â”ŠUtils.compare = function (context, num, method, precision = method) {\n-â”Š43â”Š  â”Š  switch (precision) {\n-â”Š44â”Š  â”Š    // Fixed precision, \"almost equal\" with a deviation of Îµ\n-â”Š45â”Š  â”Š    case \"f\":\n-â”Š46â”Š  â”Š      switch (method) {\n-â”Š47â”Š  â”Š        case \"<\": case \"<=\": return context <= num + Number.EPSILON;\n-â”Š48â”Š  â”Š        case \">\": case \">=\": return context >= num - Number.EPSILON;\n-â”Š49â”Š  â”Š        default: return Math.abs(context - num) <= Number.EPSILON;\n-â”Š50â”Š  â”Š      }\n-â”Š51â”Š  â”Š    // Pixel precision, round comparison\n-â”Š52â”Š  â”Š    case \"px\":\n-â”Š53â”Š  â”Š      switch (method) {\n-â”Š54â”Š  â”Š        case \"<\": case \"<=\": return Math.round(context) <= Math.round(num);\n-â”Š55â”Š  â”Š        case \">\": case \">=\": return Math.round(context) >= Math.round(num);\n-â”Š56â”Š  â”Š        default: return Math.round(context) == Math.round(num);\n-â”Š57â”Š  â”Š      }\n-â”Š58â”Š  â”Š    // Exact precision\n-â”Š59â”Š  â”Š    default:\n-â”Š60â”Š  â”Š      switch (method) {\n-â”Š61â”Š  â”Š        case \"<\": return context < num;\n-â”Š62â”Š  â”Š        case \"<=\": return context <= num;\n-â”Š63â”Š  â”Š        case \">\": return context > num;\n-â”Š64â”Š  â”Š        case \">=\": return context >= num;\n-â”Š65â”Š  â”Š        default: return context === num;\n-â”Š66â”Š  â”Š      }\n+â”Š  â”Š19â”ŠObject.assign(Utils, CPP.Utils, {\n+â”Š  â”Š20â”Š  // Overload handling\n+â”Š  â”Š21â”Š  compare(context, num, method, precision = method) {\n+â”Š  â”Š22â”Š    return CPP.Utils.compare(context, num, method, precision);\n â”Š67â”Š23â”Š  }\n-â”Š68â”Š  â”Š};ðŸš«â†µ\n+â”Š  â”Š24â”Š});ðŸš«â†µ\n```\n\n[}]: #\n\nWhenever launching the compiler, the generated code should be outputted somewhere. I've decided to go with the path `resources/scripts/cpp.bundle.js`, but it doesn't matter how the file is gonna be called, as long as it's defined under the `scripts` dir, otherwise we won't be able to load it. Also, we need to make sure that we set a git-ignore rule for the generated file, since there's no reason for us to upload it to the git-host if we're planning on compiling it:\n\n[{]: <helper> (diffStep 7.5)\n\n#### [Step 7.5: Bind CPP utils to JS utils](https://github.com/DAB0mB/radial-snake/commit/0a67d50)\n\n##### Changed resources&#x2F;scripts&#x2F;utils.js\n```diff\n@@ -16,53 +16,9 @@\n â”Š16â”Š16â”Š  return chain;\n â”Š17â”Š17â”Š};\n â”Š18â”Š18â”Š\n-â”Š19â”Š  â”Š// Fixed modulo method which can calculate modulo of negative numbers properly\n-â”Š20â”Š  â”Š// e.g. (-803).mod(800) returns 797\n-â”Š21â”Š  â”ŠUtils.mod = function (context, num) {\n-â”Š22â”Š  â”Š  return ((context % num) + num) % num;\n-â”Š23â”Š  â”Š};\n-â”Š24â”Š  â”Š\n-â”Š25â”Š  â”Š// Trims number and leaves the number of decimals specified.\n-â”Š26â”Š  â”Š// The \"mode\" argument specifies which math function should be invoked\n-â”Š27â”Š  â”Š// right after the number has been trimmed.\n-â”Š28â”Š  â”Š// e.g. 12.12345.trim(3, \"ceil\") returns 12.124\n-â”Š29â”Š  â”ŠUtils.trim = function (context, decimals, mode = \"round\") {\n-â”Š30â”Š  â”Š  return Math[mode](context * Math.pow(10, decimals)) / Math.pow(10, decimals);\n-â”Š31â”Š  â”Š};\n-â”Š32â”Š  â”Š\n-â”Š33â”Š  â”Š// Tells if number is in specified range based on given precision.\n-â”Š34â”Š  â”Š// See the \"compare\" method for more information about precision\n-â”Š35â”Š  â”ŠUtils.isBetween = function (context, num1, num2, precision) {\n-â”Š36â”Š  â”Š  return Utils.compare(context, Math.min(num1, num2), \">=\", precision) &&\n-â”Š37â”Š  â”Š         Utils.compare(context, Math.max(num1, num2), \"<=\", precision);\n-â”Š38â”Š  â”Š};\n-â”Š39â”Š  â”Š\n-â”Š40â”Š  â”Š// Initiates comparison operator between context number and a given number, only here\n-â”Š41â”Š  â”Š// a precision can be specified\n-â”Š42â”Š  â”ŠUtils.compare = function (context, num, method, precision = method) {\n-â”Š43â”Š  â”Š  switch (precision) {\n-â”Š44â”Š  â”Š    // Fixed precision, \"almost equal\" with a deviation of Îµ\n-â”Š45â”Š  â”Š    case \"f\":\n-â”Š46â”Š  â”Š      switch (method) {\n-â”Š47â”Š  â”Š        case \"<\": case \"<=\": return context <= num + Number.EPSILON;\n-â”Š48â”Š  â”Š        case \">\": case \">=\": return context >= num - Number.EPSILON;\n-â”Š49â”Š  â”Š        default: return Math.abs(context - num) <= Number.EPSILON;\n-â”Š50â”Š  â”Š      }\n-â”Š51â”Š  â”Š    // Pixel precision, round comparison\n-â”Š52â”Š  â”Š    case \"px\":\n-â”Š53â”Š  â”Š      switch (method) {\n-â”Š54â”Š  â”Š        case \"<\": case \"<=\": return Math.round(context) <= Math.round(num);\n-â”Š55â”Š  â”Š        case \">\": case \">=\": return Math.round(context) >= Math.round(num);\n-â”Š56â”Š  â”Š        default: return Math.round(context) == Math.round(num);\n-â”Š57â”Š  â”Š      }\n-â”Š58â”Š  â”Š    // Exact precision\n-â”Š59â”Š  â”Š    default:\n-â”Š60â”Š  â”Š      switch (method) {\n-â”Š61â”Š  â”Š        case \"<\": return context < num;\n-â”Š62â”Š  â”Š        case \"<=\": return context <= num;\n-â”Š63â”Š  â”Š        case \">\": return context > num;\n-â”Š64â”Š  â”Š        case \">=\": return context >= num;\n-â”Š65â”Š  â”Š        default: return context === num;\n-â”Š66â”Š  â”Š      }\n+â”Š  â”Š19â”ŠObject.assign(Utils, CPP.Utils, {\n+â”Š  â”Š20â”Š  // Overload handling\n+â”Š  â”Š21â”Š  compare(context, num, method, precision = method) {\n+â”Š  â”Š22â”Š    return CPP.Utils.compare(context, num, method, precision);\n â”Š67â”Š23â”Š  }\n-â”Š68â”Š  â”Š};ðŸš«â†µ\n+â”Š  â”Š24â”Š});ðŸš«â†µ\n```\n\n[}]: #\n\nTo compile our C++ code and turn it into JavaScript, we'll need to run the following command:\n\n    $ emcc -O1 --pre-js resources/cpp/pre.js --post-js resources/cpp/post.js --bind -o resources/scripts/cpp.bundle.js resources/cpp/src/index.cpp\n\nHere's a detailed list with explanations regards the arguments vector we've just passed:\n\n- `-01` - Optimization level 1. The higher the index, the more optimized our code is gonna be, but less readable.\n- `--pre-js` - Specifies a JavaScript prefix for the compiled code.\n- `--post-js` - Specifies a JavaScript postfix for the compiled code.\n- `--bind` - Tells the compiler to use Embind\n- `-o` - The output path.\n\n> More informations regards Emscripten's CLI can be found [here](https://kripken.github.io/emscripten-site/docs/tools_reference/emcc.html).\n\nYou don't have to memorize the compilation command we've just typed, because we're gonna save it as an NPM script called `build:cpp`:\n\n[{]: <helper> (diffStep 7.6)\n\n#### [Step 7.6: Add ignore rule to CPP bundle](https://github.com/DAB0mB/radial-snake/commit/f4a75cf)\n\n##### Changed .gitignore\n```diff\n@@ -1,3 +1,4 @@\n â”Š1â”Š1â”Šnode_modules\n â”Š2â”Š2â”Šnpm-debug.log\n-â”Š3â”Š â”Šresources/assets/fonts/*.jsonðŸš«â†µ\n+â”Š â”Š3â”Šresources/assets/fonts/*.json\n+â”Š â”Š4â”Šresources/scripts/cpp.bundle.jsðŸš«â†µ\n```\n\n[}]: #\n\nNow if you'd like to compile the C++ code just run:\n\n    $ npm run build:cpp\n\nMoreover, the code should be compiled automatically any time you start the serer using the command:\n\n    $ npm run serve\n\nWe always have to be on the alert and run our tests against modules we've just translated from JavaScript to C++. This will guarantee that once we run the game we won't stumble upon any defect whatsoever. Before running the tests, be sure to import the C++ bundle in the HTML file's header:\n\n[{]: <helper> (diffStep 7.8)\n\n#### [Step 7.8: Load CPP bundle in spec runner](https://github.com/DAB0mB/radial-snake/commit/0d1bd08)\n\n##### Changed views&#x2F;spec_runner.html\n```diff\n@@ -16,6 +16,7 @@\n â”Š16â”Š16â”Š    <script type=\"text/javascript\" src=\"libs/underscore.js\"></script>\n â”Š17â”Š17â”Š\n â”Š18â”Š18â”Š    <!-- Scripts -->\n+â”Š  â”Š19â”Š    <script type=\"text/javascript\" src=\"scripts/cpp.bundle.js\"></script>\n â”Š19â”Š20â”Š    <script type=\"text/javascript\" src=\"scripts/utils.js\"></script>\n â”Š20â”Š21â”Š    <script type=\"text/javascript\" src=\"scripts/namespaces.js\"></script>\n â”Š21â”Š22â”Š    <script type=\"text/javascript\" src=\"scripts/engine/geometry/line.js\"></script>\n```\n\n[}]: #\n\nNow we can run the tests by running the following command:\n\n    $ npm run test\n\nAt this point **all our tests should pass**. If they don't, it means our newly created utility module is not working properly, and you will have to repeat the previous steps until you get it right.\n\nUp next, we gonna translate the geometry line class to C++. Since it's gonna be translated almost identically, we will have to make sure that all the necessary assets are gonna be available for our class before proceeding. The first thing we will have to do would be making sure that the utility functions are chainable directly from C++ as well. To do that, we will create a chain class which should return a new instance of it whenever we're about to chain the upcoming utility method. Once calling `result()`, the accumulator should be returned:\n\n[{]: <helper> (diffStep 7.9)\n\n#### [Step 7.9: Add chaining method to CPP utils](https://github.com/DAB0mB/radial-snake/commit/0927eea)\n\n##### Changed resources&#x2F;cpp&#x2F;src&#x2F;utils.cpp\n```diff\n@@ -5,6 +5,61 @@\n â”Š 5â”Š 5â”Š#include \"utils.h\"\n â”Š 6â”Š 6â”Š\n â”Š 7â”Š 7â”Šnamespace utils {\n+â”Š  â”Š 8â”Š  template<typename T>\n+â”Š  â”Š 9â”Š  Chain<T>::Chain(T accumulator): _accumulator(accumulator) {\n+â”Š  â”Š10â”Š  }\n+â”Š  â”Š11â”Š\n+â”Š  â”Š12â”Š  template<>\n+â”Š  â”Š13â”Š  Chain<double>* Chain<double>::mod(double num) {\n+â”Š  â”Š14â”Š    double result = utils::mod(_accumulator, num);\n+â”Š  â”Š15â”Š    Chain<double>* chain = new Chain<double>(result);\n+â”Š  â”Š16â”Š    delete this;\n+â”Š  â”Š17â”Š    return chain;\n+â”Š  â”Š18â”Š  }\n+â”Š  â”Š19â”Š\n+â”Š  â”Š20â”Š  template<>\n+â”Š  â”Š21â”Š  Chain<double>* Chain<double>::trim(int decimals, const std::string mode) {\n+â”Š  â”Š22â”Š    double result = utils::trim(_accumulator, decimals, mode);\n+â”Š  â”Š23â”Š    Chain<double>* chain = new Chain<double>(result);\n+â”Š  â”Š24â”Š    delete this;\n+â”Š  â”Š25â”Š    return chain;\n+â”Š  â”Š26â”Š  }\n+â”Š  â”Š27â”Š\n+â”Š  â”Š28â”Š  template<>\n+â”Š  â”Š29â”Š  Chain<bool>* Chain<double>::isBetween(double num1, double num2, const std::string precision) {\n+â”Š  â”Š30â”Š    bool result = utils::isBetween(_accumulator, num1, num2, precision);\n+â”Š  â”Š31â”Š    Chain<bool>* chain = new Chain<bool>(result);\n+â”Š  â”Š32â”Š    delete this;\n+â”Š  â”Š33â”Š    return chain;\n+â”Š  â”Š34â”Š  }\n+â”Š  â”Š35â”Š\n+â”Š  â”Š36â”Š  template<>\n+â”Š  â”Š37â”Š  Chain<bool>* Chain<double>::compare(double num, const std::string precision) {\n+â”Š  â”Š38â”Š    bool result = utils::compare(_accumulator, num, precision);\n+â”Š  â”Š39â”Š    Chain<bool>* chain = new Chain<bool>(result);\n+â”Š  â”Š40â”Š    delete this;\n+â”Š  â”Š41â”Š    return chain;\n+â”Š  â”Š42â”Š  }\n+â”Š  â”Š43â”Š\n+â”Š  â”Š44â”Š  template<>\n+â”Š  â”Š45â”Š  Chain<bool>* Chain<double>::compare(double num, const std::string method, const std::string precision) {\n+â”Š  â”Š46â”Š    bool result = utils::compare(_accumulator, num, method, precision);\n+â”Š  â”Š47â”Š    Chain<bool>* chain = new Chain<bool>(result);\n+â”Š  â”Š48â”Š    delete this;\n+â”Š  â”Š49â”Š    return chain;\n+â”Š  â”Š50â”Š  }\n+â”Š  â”Š51â”Š\n+â”Š  â”Š52â”Š  template<typename T>\n+â”Š  â”Š53â”Š  T Chain<T>::result() {\n+â”Š  â”Š54â”Š    delete this;\n+â”Š  â”Š55â”Š    return _accumulator;\n+â”Š  â”Š56â”Š  }\n+â”Š  â”Š57â”Š\n+â”Š  â”Š58â”Š  template<typename T>\n+â”Š  â”Š59â”Š  Chain<T>* chain(T accumulator) {\n+â”Š  â”Š60â”Š    return new Chain<T>(accumulator);\n+â”Š  â”Š61â”Š  }\n+â”Š  â”Š62â”Š\n â”Š 8â”Š63â”Š  // Fixed modulo method which can calculate modulo of negative numbers properly\n â”Š 9â”Š64â”Š  // e.g. (-803).mod(800) returns 797\n â”Š10â”Š65â”Š  double mod(double context, double num) {\n```\n\n##### Changed resources&#x2F;cpp&#x2F;src&#x2F;utils.h\n```diff\n@@ -3,6 +3,30 @@\n â”Š 3â”Š 3â”Š#include <string>\n â”Š 4â”Š 4â”Š\n â”Š 5â”Š 5â”Šnamespace utils {\n+â”Š  â”Š 6â”Š  template<typename T>\n+â”Š  â”Š 7â”Š  class Chain {\n+â”Š  â”Š 8â”Š  private:\n+â”Š  â”Š 9â”Š    T _accumulator;\n+â”Š  â”Š10â”Š\n+â”Š  â”Š11â”Š  public:\n+â”Š  â”Š12â”Š    Chain(T accumulator);\n+â”Š  â”Š13â”Š\n+â”Š  â”Š14â”Š    Chain<double>* mod(double num);\n+â”Š  â”Š15â”Š\n+â”Š  â”Š16â”Š    Chain<double>* trim(int decimals, const std::string mode = \"round\");\n+â”Š  â”Š17â”Š\n+â”Š  â”Š18â”Š    Chain<bool>* isBetween(double num1, double num2, const std::string precision = \"exact\");\n+â”Š  â”Š19â”Š\n+â”Š  â”Š20â”Š    Chain<bool>* compare(double num, const std::string precision = \"exact\");\n+â”Š  â”Š21â”Š\n+â”Š  â”Š22â”Š    Chain<bool>* compare(double num, const std::string method, const std::string precision);\n+â”Š  â”Š23â”Š\n+â”Š  â”Š24â”Š    T result();\n+â”Š  â”Š25â”Š  };\n+â”Š  â”Š26â”Š\n+â”Š  â”Š27â”Š  template<typename T>\n+â”Š  â”Š28â”Š  Chain<T>* chain(T accumulator);\n+â”Š  â”Š29â”Š\n â”Š 6â”Š30â”Š  double mod(double context, double num);\n â”Š 7â”Š31â”Š\n â”Š 8â”Š32â”Š  double trim(double context, int decimals, const std::string mode = \"round\");\n```\n\n[}]: #\n\n> Note that when coding in C++ we have to make sure that the objects are being disposed when not needed anymore, otherwise we will have some unnecessary memory leaks.\n\n2D shapes are presented in space using points with 2 values - `x` (axis) and `y` axis, therefore, we will create the appropriate point structure:\n\n[{]: <helper> (diffStep 7.1)\n\n#### [Step 7.1: Add CPP entry script](https://github.com/DAB0mB/radial-snake/commit/2f35323)\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;index.cpp\n```diff\n@@ -0,0 +1 @@\n+â”Š â”Š1â”Š#include \"utils.cpp\"ðŸš«â†µ\n```\n\n[}]: #\n\nReturned values can either be `null` (`undefined`) or not. Since there's no built in nullable-values mechanism in C++ (up until C++17), we're gonna create one of our own:\n\n[{]: <helper> (diffStep 7.11)\n\n#### [Step 7.11: Add nullable class](https://github.com/DAB0mB/radial-snake/commit/41b2f7c)\n\n##### Changed resources&#x2F;cpp&#x2F;src&#x2F;index.cpp\n```diff\n@@ -1 +1,2 @@\n+â”Š â”Š1â”Š#include \"nullable.cpp\"\n â”Š1â”Š2â”Š#include \"utils.cpp\"ðŸš«â†µ\n```\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;nullable.cpp\n```diff\n@@ -0,0 +1,37 @@\n+â”Š  â”Š 1â”Š#include \"nullable.h\"\n+â”Š  â”Š 2â”Š\n+â”Š  â”Š 3â”Štemplate <typename T>\n+â”Š  â”Š 4â”ŠNullable<T>::Nullable(T value): _value(value), _initialized(true) {\n+â”Š  â”Š 5â”Š\n+â”Š  â”Š 6â”Š}\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Štemplate <typename T>\n+â”Š  â”Š 9â”ŠNullable<T>::Nullable(): _initialized(false) {\n+â”Š  â”Š10â”Š\n+â”Š  â”Š11â”Š}\n+â”Š  â”Š12â”Š\n+â”Š  â”Š13â”Štemplate <typename T>\n+â”Š  â”Š14â”ŠT Nullable<T>::getValue() const {\n+â”Š  â”Š15â”Š  return _value;\n+â”Š  â”Š16â”Š}\n+â”Š  â”Š17â”Š\n+â”Š  â”Š18â”Štemplate <typename T>\n+â”Š  â”Š19â”Švoid Nullable<T>::setValue(T value) {\n+â”Š  â”Š20â”Š  _value = value;\n+â”Š  â”Š21â”Š  _initialized = true;\n+â”Š  â”Š22â”Š}\n+â”Š  â”Š23â”Š\n+â”Š  â”Š24â”Štemplate <typename T>\n+â”Š  â”Š25â”Švoid Nullable<T>::resetValue() {\n+â”Š  â”Š26â”Š  _initialized = false;\n+â”Š  â”Š27â”Š}\n+â”Š  â”Š28â”Š\n+â”Š  â”Š29â”Štemplate <typename T>\n+â”Š  â”Š30â”Šbool Nullable<T>::hasValue() const {\n+â”Š  â”Š31â”Š  return _initialized == true;\n+â”Š  â”Š32â”Š}\n+â”Š  â”Š33â”Š\n+â”Š  â”Š34â”Štemplate <typename T>\n+â”Š  â”Š35â”Šbool Nullable<T>::isNull() const {\n+â”Š  â”Š36â”Š  return _initialized == false;\n+â”Š  â”Š37â”Š}ðŸš«â†µ\n```\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;nullable.h\n```diff\n@@ -0,0 +1,23 @@\n+â”Š  â”Š 1â”Š#pragma once\n+â”Š  â”Š 2â”Š\n+â”Š  â”Š 3â”Štemplate <typename T>\n+â”Š  â”Š 4â”Šclass Nullable {\n+â”Š  â”Š 5â”Šprivate:\n+â”Š  â”Š 6â”Š  T _value;\n+â”Š  â”Š 7â”Š  bool _initialized;\n+â”Š  â”Š 8â”Š\n+â”Š  â”Š 9â”Špublic:\n+â”Š  â”Š10â”Š  Nullable(T value);\n+â”Š  â”Š11â”Š\n+â”Š  â”Š12â”Š  Nullable();\n+â”Š  â”Š13â”Š\n+â”Š  â”Š14â”Š  T getValue() const;\n+â”Š  â”Š15â”Š\n+â”Š  â”Š16â”Š  void setValue(T value);\n+â”Š  â”Š17â”Š\n+â”Š  â”Š18â”Š  void resetValue();\n+â”Š  â”Š19â”Š\n+â”Š  â”Š20â”Š  bool hasValue() const;\n+â”Š  â”Š21â”Š\n+â”Š  â”Š22â”Š  bool isNull() const;\n+â”Š  â”Š23â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nNow that all the necessary assets for the line class are ready, we can go ahead and create it:\n\n[{]: <helper> (diffStep 7.12)\n\n#### [Step 7.12: Add base line CPP module](https://github.com/DAB0mB/radial-snake/commit/9d17554)\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;geometry&#x2F;line.cpp\n```diff\n@@ -0,0 +1,99 @@\n+â”Š  â”Š 1â”Š#include \"../nullable.h\"\n+â”Š  â”Š 2â”Š#include \"../utils.h\"\n+â”Š  â”Š 3â”Š#include \"point.h\"\n+â”Š  â”Š 4â”Š#include \"line.h\"\n+â”Š  â”Š 5â”Š\n+â”Š  â”Š 6â”Šnamespace geometry {\n+â”Š  â”Š 7â”Š  // x1 - The first point's x value\n+â”Š  â”Š 8â”Š  // y1 - The first point's y value\n+â”Š  â”Š 9â”Š  // x1 - The second point's x value\n+â”Š  â”Š10â”Š  // y2 - The second point's y value\n+â”Š  â”Š11â”Š  Line::Line(double x1, double y1, double x2, double y2) {\n+â”Š  â”Š12â”Š    _x1 = utils::trim(x1, 9);\n+â”Š  â”Š13â”Š    _y1 = utils::trim(y1, 9);\n+â”Š  â”Š14â”Š    _x2 = utils::trim(x2, 9);\n+â”Š  â”Š15â”Š    _y2 = utils::trim(y2, 9);\n+â”Š  â”Š16â”Š  }\n+â”Š  â”Š17â”Š\n+â”Š  â”Š18â”Š  // Gets the matching x value for a given y value\n+â”Š  â”Š19â”Š  Nullable<double> Line::getMatchingX(double y) {\n+â”Š  â”Š20â”Š    // If an error was thrown it means we divided a number by zero,\n+â”Š  â”Š21â”Š    // in which case there is not intersection point\n+â”Š  â”Š22â”Š    double x = utils::trim(\n+â”Š  â”Š23â”Š      (((y - _y1) * (_x2 - _x1)) /\n+â”Š  â”Š24â”Š       (_y2 - _y1)) + _x1\n+â”Š  â”Š25â”Š    , 9, \"exact\");\n+â”Š  â”Š26â”Š\n+â”Š  â”Š27â”Š    // Check if result is in values range\n+â”Š  â”Š28â”Š    if (utils::isBetween(x, _x1, _x2, \"round\")) {\n+â”Š  â”Š29â”Š      return Nullable<double>(x);\n+â”Š  â”Š30â”Š    }\n+â”Š  â”Š31â”Š\n+â”Š  â”Š32â”Š    return Nullable<double>();\n+â”Š  â”Š33â”Š  }\n+â”Š  â”Š34â”Š\n+â”Š  â”Š35â”Š  // Gets the matching y value for a given x value\n+â”Š  â”Š36â”Š  Nullable<double> Line::getMatchingY(double x) {\n+â”Š  â”Š37â”Š    // If an error was thrown it means we divided a number by zero,\n+â”Š  â”Š38â”Š    // in which case there is not intersection point\n+â”Š  â”Š39â”Š    double y = utils::trim(\n+â”Š  â”Š40â”Š      (((x - _x1) * (_y2 - _y1)) /\n+â”Š  â”Š41â”Š       (_x2 - _x1)) + _y1\n+â”Š  â”Š42â”Š    , 9, \"exact\");\n+â”Š  â”Š43â”Š\n+â”Š  â”Š44â”Š    // Check if result is in values range\n+â”Š  â”Š45â”Š    if (utils::isBetween(y, _y1, _y2, \"round\")) {\n+â”Š  â”Š46â”Š      return Nullable<double>(y);\n+â”Š  â”Š47â”Š    }\n+â”Š  â”Š48â”Š\n+â”Š  â”Š49â”Š    return Nullable<double>();\n+â”Š  â”Š50â”Š  }\n+â”Š  â”Š51â”Š\n+â”Š  â”Š52â”Š  // Returns if line has given point\n+â”Š  â”Š53â”Š  bool Line::hasPoint(double x, double y) {\n+â”Š  â”Š54â”Š    if (!boundsHavePoint(x, y)) return 0;\n+â”Š  â”Š55â”Š\n+â”Š  â”Š56â”Š    double m = utils::trim(\n+â”Š  â”Š57â”Š      (_y2 - _y1) / (_x2 - _x1),\n+â”Š  â”Š58â”Š    9, \"exact\");\n+â”Š  â”Š59â”Š\n+â”Š  â”Š60â”Š    return (y - _y1) / (x - _x1) == m;\n+â”Š  â”Š61â”Š  }\n+â”Š  â”Š62â”Š\n+â”Š  â”Š63â”Š  // Returns if given point is contained by the bounds aka cage of line\n+â”Š  â”Š64â”Š  bool Line::boundsHavePoint(double x, double y) {\n+â”Š  â”Š65â”Š    return utils::isBetween(x, _x1, _x2, \"round\") &&\n+â”Š  â”Š66â”Š           utils::isBetween(y, _y1, _y2, \"round\");\n+â”Š  â”Š67â”Š  }\n+â”Š  â”Š68â”Š\n+â”Š  â”Š69â”Š  // line - line intersection method\n+â”Š  â”Š70â”Š  Nullable<Point> Line::getIntersection(Line line) {\n+â”Š  â”Š71â”Š    // Escape if lines are parallel\n+â”Š  â”Š72â”Š    if (!(((_x1 - _x2) * (line._y1 - line._y2)) -\n+â”Š  â”Š73â”Š          ((_y1 - _y2) * (line._x1 - line._x2))))\n+â”Š  â”Š74â”Š      return Nullable<Point>();\n+â”Š  â”Š75â”Š\n+â”Š  â”Š76â”Š    // Intersection point formula\n+â”Š  â”Š77â”Š    double x = utils::trim(\n+â”Š  â”Š78â”Š      ((((_x1 * _y2) - (_y1 * _x2)) * (line._x1 - line._x2)) -\n+â”Š  â”Š79â”Š       ((_x1 - _x2) * ((line._x1 * line._y2) - (line._y1 * line._x2)))) /\n+â”Š  â”Š80â”Š      (((_x1 - _x2) * (line._y1 - line._y2)) - ((_y1 - _y2) *\n+â”Š  â”Š81â”Š        (line._x1 - line._x2)))\n+â”Š  â”Š82â”Š    , 9, \"exact\");\n+â”Š  â”Š83â”Š    double y = utils::trim(\n+â”Š  â”Š84â”Š      ((((_x1 * _y2) - (_y1 * _x2)) * (line._y1 - line._y2)) -\n+â”Š  â”Š85â”Š       ((_y1 - _y2) * ((line._x1 * line._y2) - (line._y1 * line._x2)))) /\n+â”Š  â”Š86â”Š      (((_x1 - _x2) * (line._y1 - line._y2)) - ((_y1 - _y2) *\n+â”Š  â”Š87â”Š        (line._x1 - line._x2)))\n+â”Š  â”Š88â”Š    , 9, \"exact\");\n+â”Š  â”Š89â”Š\n+â”Š  â”Š90â”Š    if (utils::isBetween(x, _x1, _x2, \"round\") &&\n+â”Š  â”Š91â”Š        utils::isBetween(x, line._x1, line._x2, \"round\") &&\n+â”Š  â”Š92â”Š        utils::isBetween(y, _y1, _y2, \"round\") &&\n+â”Š  â”Š93â”Š        utils::isBetween(y, line._y1, line._y2, \"round\")) {\n+â”Š  â”Š94â”Š      return Nullable<Point>({ x, y });\n+â”Š  â”Š95â”Š    }\n+â”Š  â”Š96â”Š\n+â”Š  â”Š97â”Š    return Nullable<Point>();\n+â”Š  â”Š98â”Š  }\n+â”Š  â”Š99â”Š}ðŸš«â†µ\n```\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;geometry&#x2F;line.h\n```diff\n@@ -0,0 +1,30 @@\n+â”Š  â”Š 1â”Š#pragma once\n+â”Š  â”Š 2â”Š\n+â”Š  â”Š 3â”Š#include <vector>\n+â”Š  â”Š 4â”Š#include \"../nullable.h\"\n+â”Š  â”Š 5â”Š#include \"point.h\"\n+â”Š  â”Š 6â”Š\n+â”Š  â”Š 7â”Šnamespace geometry {\n+â”Š  â”Š 8â”Š  class Circle;\n+â”Š  â”Š 9â”Š  class EMCircle;\n+â”Š  â”Š10â”Š\n+â”Š  â”Š11â”Š  class Line {\n+â”Š  â”Š12â”Š  public:\n+â”Š  â”Š13â”Š    double _x1;\n+â”Š  â”Š14â”Š    double _y1;\n+â”Š  â”Š15â”Š    double _x2;\n+â”Š  â”Š16â”Š    double _y2;\n+â”Š  â”Š17â”Š\n+â”Š  â”Š18â”Š    Line(double x1, double y1, double x2, double y2);\n+â”Š  â”Š19â”Š\n+â”Š  â”Š20â”Š    Nullable<double> getMatchingX(double y);\n+â”Š  â”Š21â”Š\n+â”Š  â”Š22â”Š    Nullable<double> getMatchingY(double x);\n+â”Š  â”Š23â”Š\n+â”Š  â”Š24â”Š    bool hasPoint(double x, double y);\n+â”Š  â”Š25â”Š\n+â”Š  â”Š26â”Š    bool boundsHavePoint(double x, double y);\n+â”Š  â”Š27â”Š\n+â”Š  â”Š28â”Š    Nullable<Point> getIntersection(Line line);\n+â”Š  â”Š29â”Š  };\n+â”Š  â”Š30â”Š}ðŸš«â†µ\n```\n\n##### Changed resources&#x2F;cpp&#x2F;src&#x2F;index.cpp\n```diff\n@@ -1,2 +1,3 @@\n â”Š1â”Š1â”Š#include \"nullable.cpp\"\n-â”Š2â”Š â”Š#include \"utils.cpp\"ðŸš«â†µ\n+â”Š â”Š2â”Š#include \"utils.cpp\"\n+â”Š â”Š3â”Š#include \"geometry/line.cpp\"ðŸš«â†µ\n```\n\n[}]: #\n\nAfter creating our C++, we will also need to bind it using EMBind:\n\n[{]: <helper> (diffStep 7.13)\n\n#### [Step 7.13: EMBind CPP line](https://github.com/DAB0mB/radial-snake/commit/8920ddf)\n\n##### Changed resources&#x2F;cpp&#x2F;post.js\n```diff\n@@ -4,6 +4,10 @@\n â”Š 4â”Š 4â”Š    trim: Module.utils_trim,\n â”Š 5â”Š 5â”Š    isBetween: Module.utils_isBetween,\n â”Š 6â”Š 6â”Š    compare: Module.utils_compare\n+â”Š  â”Š 7â”Š  },\n+â”Š  â”Š 8â”Š\n+â”Š  â”Š 9â”Š  Geometry: {\n+â”Š  â”Š10â”Š    Line: Module.geometry_line\n â”Š 7â”Š11â”Š  }\n â”Š 8â”Š12â”Š};\n â”Š 9â”Š13â”Š\n```\n\n##### Changed resources&#x2F;cpp&#x2F;src&#x2F;geometry&#x2F;line.cpp\n```diff\n@@ -1,3 +1,6 @@\n+â”Š â”Š1â”Š#include <vector>\n+â”Š â”Š2â”Š#include <emscripten/bind.h>\n+â”Š â”Š3â”Š#include <emscripten/val.h>\n â”Š1â”Š4â”Š#include \"../nullable.h\"\n â”Š2â”Š5â”Š#include \"../utils.h\"\n â”Š3â”Š6â”Š#include \"point.h\"\n```\n```diff\n@@ -96,4 +99,52 @@\n â”Š 96â”Š 99â”Š\n â”Š 97â”Š100â”Š    return Nullable<Point>();\n â”Š 98â”Š101â”Š  }\n+â”Š   â”Š102â”Š\n+â”Š   â”Š103â”Š  emscripten::val EMLine::getMatchingX(double y) {\n+â”Š   â”Š104â”Š    Nullable<double> nullableX = Line::getMatchingX(y);\n+â”Š   â”Š105â”Š    return nullableX.hasValue() ?\n+â”Š   â”Š106â”Š      emscripten::val(nullableX.getValue()) :\n+â”Š   â”Š107â”Š      emscripten::val::undefined();\n+â”Š   â”Š108â”Š  }\n+â”Š   â”Š109â”Š\n+â”Š   â”Š110â”Š  emscripten::val EMLine::getMatchingY(double x) {\n+â”Š   â”Š111â”Š    Nullable<double> nullableY = Line::getMatchingY(x);\n+â”Š   â”Š112â”Š    return nullableY.hasValue() ?\n+â”Š   â”Š113â”Š      emscripten::val(nullableY.getValue()) :\n+â”Š   â”Š114â”Š      emscripten::val::undefined();\n+â”Š   â”Š115â”Š  }\n+â”Š   â”Š116â”Š\n+â”Š   â”Š117â”Š  emscripten::val EMLine::getIntersection(EMLine emLine) {\n+â”Š   â”Š118â”Š    Line line = Line(emLine._x1, emLine._y1, emLine._x2, emLine._y2);\n+â”Š   â”Š119â”Š    Nullable<Point> nullablePoint = Line::getIntersection(line);\n+â”Š   â”Š120â”Š\n+â”Š   â”Š121â”Š    if (nullablePoint.isNull()) return emscripten::val::undefined();\n+â”Š   â”Š122â”Š\n+â”Š   â”Š123â”Š    Point point = nullablePoint.getValue();\n+â”Š   â”Š124â”Š    emscripten::val emPoint = emscripten::val::object();\n+â”Š   â”Š125â”Š    emPoint.set(\"x\", emscripten::val(point.x));\n+â”Š   â”Š126â”Š    emPoint.set(\"y\", emscripten::val(point.y));\n+â”Š   â”Š127â”Š    return emPoint;\n+â”Š   â”Š128â”Š  }\n+â”Š   â”Š129â”Š}\n+â”Š   â”Š130â”Š\n+â”Š   â”Š131â”ŠEMSCRIPTEN_BINDINGS(geometry_line_module) {\n+â”Š   â”Š132â”Š  emscripten::class_<geometry::Line>(\"geometry_line_base\")\n+â”Š   â”Š133â”Š    .constructor<double, double, double, double>()\n+â”Š   â”Š134â”Š    .property<double>(\"x1\", &geometry::Line::_x1)\n+â”Š   â”Š135â”Š    .property<double>(\"y1\", &geometry::Line::_y1)\n+â”Š   â”Š136â”Š    .property<double>(\"x2\", &geometry::Line::_x2)\n+â”Š   â”Š137â”Š    .property<double>(\"y2\", &geometry::Line::_y2)\n+â”Š   â”Š138â”Š    .function(\"hasPoint\", &geometry::Line::hasPoint)\n+â”Š   â”Š139â”Š    .function(\"boundsHavePoint\", &geometry::Line::boundsHavePoint);\n+â”Š   â”Š140â”Š\n+â”Š   â”Š141â”Š  emscripten::class_<geometry::EMLine, emscripten::base<geometry::Line>>(\"geometry_line\")\n+â”Š   â”Š142â”Š    .constructor<double, double, double, double>()\n+â”Š   â”Š143â”Š    .function(\"getX\", &geometry::EMLine::getMatchingX)\n+â”Š   â”Š144â”Š    .function(\"getY\", &geometry::EMLine::getMatchingY)\n+â”Š   â”Š145â”Š    .function(\"getLineIntersection\",\n+â”Š   â”Š146â”Š      emscripten::select_overload<emscripten::val(geometry::EMLine)>(\n+â”Š   â”Š147â”Š        &geometry::EMLine::getIntersection\n+â”Š   â”Š148â”Š      )\n+â”Š   â”Š149â”Š    );\n â”Š 99â”Š150â”Š}ðŸš«â†µ\n```\n\n##### Changed resources&#x2F;cpp&#x2F;src&#x2F;geometry&#x2F;line.h\n```diff\n@@ -1,6 +1,7 @@\n â”Š1â”Š1â”Š#pragma once\n â”Š2â”Š2â”Š\n â”Š3â”Š3â”Š#include <vector>\n+â”Š â”Š4â”Š#include <emscripten/val.h>\n â”Š4â”Š5â”Š#include \"../nullable.h\"\n â”Š5â”Š6â”Š#include \"point.h\"\n â”Š6â”Š7â”Š\n```\n```diff\n@@ -27,4 +28,15 @@\n â”Š27â”Š28â”Š\n â”Š28â”Š29â”Š    Nullable<Point> getIntersection(Line line);\n â”Š29â”Š30â”Š  };\n+â”Š  â”Š31â”Š\n+â”Š  â”Š32â”Š  class EMLine : public Line {\n+â”Š  â”Š33â”Š  public:\n+â”Š  â”Š34â”Š    using Line::Line;\n+â”Š  â”Š35â”Š\n+â”Š  â”Š36â”Š    emscripten::val getMatchingX(double y);\n+â”Š  â”Š37â”Š\n+â”Š  â”Š38â”Š    emscripten::val getMatchingY(double x);\n+â”Š  â”Š39â”Š\n+â”Š  â”Š40â”Š    emscripten::val getIntersection(EMLine line);\n+â”Š  â”Š41â”Š  };\n â”Š30â”Š42â”Š}ðŸš«â†µ\n```\n\n[}]: #\n\nIn the code snippet above, you can see that we used a special data-type called `val` (`emscripten::val`). `val` means that just like JavaScript, that function can return values that are not necessarily of the same data-type; For instance, the `getMatchingY` function can either return a `number` or `undefined`. If you'll take a look at the `getIntersection(Line)` method you'll notice that instead of returning the raw point structure, I chose to build a JavaScript object using the `object` data type (`emscripten::object`). `object` behaves exactly like a native JavaScript `Object`, and it can save us some precious work of binding which sometimes might be just too much.\n\nIf you'll compare the C++ version of the line class to the JavaScript line class you'll notice that the `draw` and `getIntersection` methods are missing (when we used EMBind we renamed `getIntersection` to `getLineIntersection` because overloadings are forbidden). In addition, Emscripten's API exposes some additional class methods for generated C++ classes, like the `delete` method, which we will shed light on further in this tutorial. Inheritance would be the natural solution for such an issue, unfortunately, generated C++ constructors don't accept indirect instances. For example, if we have a C++ parent class called `Shape` and we have a JavaScript child class called `Line`, we won't be able to initialize a new instance of the `Line` class. Here's a demonstration:\n\n```js\nclass JSLine extends CPPShape {}\nconst line = new JSLine(); // Throws error\n```\n\nThere are 3 ways to implement inheritance when interacting with C++ classes:\n\n- Define an interface when using EMBind. This is the official way but rather complicated, since it requires us to define an extra layer for our wrapper. More information can be found [here](https://kripken.github.io/emscripten-site/docs/porting/connecting_cpp_and_javascript/embind.html#abstract-methods).\n- Extending the prototype of exported C++ classes directly, which is not really an inheritance.\n- Using a proxy class, which is the easiest and cleanest solution of all, but it is not really mentioned anywhere. At the same time, I didn't find any restriction regards that.\n\nWe're gonna use the 3rd method in the list above, because as I said, it's the easiest and cleanest of all. First I will try to explain what I meant by saying \"proxy class\". If you're an intermediate JavaScript developer, you probably know that constructors can be overridden by returning a value explicitly. By doing that, we can actually bypass Emscripten's prohibitions, we can just return the newly created C++ instance and extend it in specific. Proxy classes actually take it a step further by providing a middle-class which will then inject a new link to the prototype chain of the returned instance.\n\n```js\nclass JSLine {\n  constructor() {\n    const line = new CPPShape();\n    return line;\n  }\n}\n\nconst line = new JSLine(); // Legal!\n```\n\n> More information about the code snippet above can be found [here](https://www.bennadel.com/blog/2522-providing-a-return-value-in-a-javascript-constructor.htm).\n\nI believe that as we go through this tutorial, the concept will get much clearer. The utility function of the proxy class should look like so:\n\n[{]: <helper> (diffStep 7.14)\n\n#### [Step 7.14: Add proxy utility method](https://github.com/DAB0mB/radial-snake/commit/06e615e)\n\n##### Changed resources&#x2F;scripts&#x2F;utils.js\n```diff\n@@ -20,5 +20,18 @@\n â”Š20â”Š20â”Š  // Overload handling\n â”Š21â”Š21â”Š  compare(context, num, method, precision = method) {\n â”Š22â”Š22â”Š    return CPP.Utils.compare(context, num, method, precision);\n+â”Š  â”Š23â”Š  },\n+â”Š  â”Š24â”Š\n+â”Š  â”Š25â”Š  proxy(Class) {\n+â”Š  â”Š26â”Š    return class extends Class {\n+â”Š  â”Š27â”Š      constructor() {\n+â”Š  â”Š28â”Š        // Initialize original class\n+â”Š  â”Š29â”Š        let that = new Class(...arguments);\n+â”Š  â”Š30â”Š        // Inject caller's prototype into the prototype chain\n+â”Š  â”Š31â”Š        Object.setPrototypeOf(that, new.target.prototype);\n+â”Š  â”Š32â”Š        // Will original instance will be the substitute for 'this'\n+â”Š  â”Š33â”Š        return that;\n+â”Š  â”Š34â”Š      }\n+â”Š  â”Š35â”Š    }\n â”Š23â”Š36â”Š  }\n â”Š24â”Š37â”Š});ðŸš«â†µ\n```\n\n[}]: #\n\nIf you'll take a look at the following line:\n\n```js\nObject.setPrototypeOf(that, new.target.prototype);\n```\n\nThis is where the magic actually happens! It enables inheritance for explicitly returned objects; This way we can safely extend C++ classes. Accordingly, our new JavaScript line class should look like so:\n\n[{]: <helper> (diffStep 7.15)\n\n#### [Step 7.15: Extend CPP line class](https://github.com/DAB0mB/radial-snake/commit/66acf9d)\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;geometry&#x2F;line.js\n```diff\n@@ -1,46 +1,10 @@\n-â”Š 1â”Š  â”ŠEngine.Geometry.Line = class Line {\n-â”Š 2â”Š  â”Š  // x1 - The first point's x value\n-â”Š 3â”Š  â”Š  // y1 - The first point's y value\n-â”Š 4â”Š  â”Š  // x1 - The second point's x value\n-â”Š 5â”Š  â”Š  // y2 - The second point's y value\n-â”Š 6â”Š  â”Š  constructor(x1, y1, x2, y2) {\n-â”Š 7â”Š  â”Š    this.x1 = Utils.trim(x1, 9);\n-â”Š 8â”Š  â”Š    this.y1 = Utils.trim(y1, 9);\n-â”Š 9â”Š  â”Š    this.x2 = Utils.trim(x2, 9);\n-â”Š10â”Š  â”Š    this.y2 = Utils.trim(y2, 9);\n-â”Š11â”Š  â”Š  }\n-â”Š12â”Š  â”Š\n+â”Š  â”Š 1â”ŠEngine.Geometry.Line = class Line extends Utils.proxy(CPP.Geometry.Line) {\n â”Š13â”Š 2â”Š  // Draws the line on the given context\n â”Š14â”Š 3â”Š  draw(context) {\n â”Š15â”Š 4â”Š    context.moveTo(this.x1, this.y1);\n â”Š16â”Š 5â”Š    context.lineTo(this.x2, this.y2);\n â”Š17â”Š 6â”Š  }\n â”Š18â”Š 7â”Š\n-â”Š19â”Š  â”Š  // Gets the matching x value for a given y value\n-â”Š20â”Š  â”Š  getX(y) {\n-â”Š21â”Š  â”Š    let x = Utils.trim((((y - this.y1) * (this.x2 - this.x1)) / (this.y2 - this.y1)) + this.x1, 9);\n-â”Š22â”Š  â”Š    if (isNaN(x) || Utils.isBetween(x, this.x1, this.x2)) return x;\n-â”Š23â”Š  â”Š  }\n-â”Š24â”Š  â”Š\n-â”Š25â”Š  â”Š  // Gets the matching y value for a given x value\n-â”Š26â”Š  â”Š  getY(x) {\n-â”Š27â”Š  â”Š    let y = Utils.trim((((x - this.x1) * (this.y2 - this.y1)) / (this.x2 - this.x1)) + this.y1, 9);\n-â”Š28â”Š  â”Š    if (isNaN(y) || Utils.isBetween(y, this.y1, this.y2)) return y;\n-â”Š29â”Š  â”Š  }\n-â”Š30â”Š  â”Š\n-â”Š31â”Š  â”Š  // Returns if line has given point\n-â”Š32â”Š  â”Š  hasPoint(x, y) {\n-â”Š33â”Š  â”Š    if (!this.boundsHavePoint(x, y)) return false;\n-â”Š34â”Š  â”Š    let m = Utils.trim((this.y2 - this.y1) / (this.x2 - this.x1), 9);\n-â”Š35â”Š  â”Š    return (y - this.y1) / (x - this.x1) == m;\n-â”Š36â”Š  â”Š  }\n-â”Š37â”Š  â”Š\n-â”Š38â”Š  â”Š  // Returns if given point is contained by the bounds aka cage of line\n-â”Š39â”Š  â”Š  boundsHavePoint(x, y) {\n-â”Š40â”Š  â”Š    return Utils.isBetween(x, this.x1, this.x2) &&\n-â”Š41â”Š  â”Š           Utils.isBetween(y, this.y1, this.y2);\n-â”Š42â”Š  â”Š  }\n-â”Š43â”Š  â”Š\n â”Š44â”Š 8â”Š  getIntersection(shape) {\n â”Š45â”Š 9â”Š    if (shape instanceof Engine.Geometry.Line)\n â”Š46â”Š10â”Š      return this.getLineIntersection(shape);\n```\n```diff\n@@ -50,23 +14,6 @@\n â”Š50â”Š14â”Š      return this.getPolygonIntersection(shape);\n â”Š51â”Š15â”Š  }\n â”Š52â”Š16â”Š\n-â”Š53â”Š  â”Š  // line - line intersection method\n-â”Š54â”Š  â”Š  getLineIntersection(line) {\n-â”Š55â”Š  â”Š    // Escape if lines are parallel\n-â”Š56â”Š  â”Š    if (!(((this.x1 - this.x2) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * (line.x1 - line.x2)))) return;\n-â”Š57â”Š  â”Š\n-â”Š58â”Š  â”Š    // Intersection point formula\n-â”Š59â”Š  â”Š    let x = Utils.trim(((((this.x1 * this.y2) - (this.y1 * this.x2)) * (line.x1 - line.x2)) - ((this.x1 - this.x2) * ((line.x1 * line.y2) - (line.y1 * line.x2)))) /\n-â”Š60â”Š  â”Š        (((this.x1 - this.x2) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * (line.x1 - line.x2))), 9);\n-â”Š61â”Š  â”Š    let y = Utils.trim(((((this.x1 * this.y2) - (this.y1 * this.x2)) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * ((line.x1 * line.y2) - (line.y1 * line.x2)))) /\n-â”Š62â”Š  â”Š        (((this.x1 - this.x2) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * (line.x1 - line.x2))), 9);\n-â”Š63â”Š  â”Š\n-â”Š64â”Š  â”Š    if (Utils.isBetween(x, this.x1, this.x2) && Utils.isBetween(x, line.x1, line.x2) &&\n-â”Š65â”Š  â”Š        Utils.isBetween(y, this.y1, this.y2) && Utils.isBetween(y, line.y1, line.y2)) {\n-â”Š66â”Š  â”Š      return { x, y };\n-â”Š67â”Š  â”Š    }\n-â”Š68â”Š  â”Š  }\n-â”Š69â”Š  â”Š\n â”Š70â”Š17â”Š  // line - circle intersection method\n â”Š71â”Š18â”Š  getCircleIntersection(circle) {\n â”Š72â”Š19â”Š    return circle.getLineIntersection(this);\n```\n\n[}]: #\n\nBy now, our tests should pass. Accept, there is memory leak we need to handle. But you probably ask yourself - \"What memory leak? It's JavaScript man! Have you ever heard of something called garbage collector?!\". Well, this is not the case when compiling C++ code with Emscripten. You see, Emscripten uses asm.js, which is a subset for JavaScript built exactly for these proposes, enabling C++ modules run on the browser. This is how the [WebGL](https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API) project actually started, an almost complete conversion from the famous C++ [OpenGL](https://www.opengl.org/) to JavaScript. Part of what asm.js does, it disables the garbage collector, and instead, it holds raw pointers, just like in C++. Since returned class instances are pointers with unknown lifespans, they need to be disposed manually, using the `delete` method (identical to how we clear memory from the Heap in C++). Let's dispose unused test data by calling the `delete` method as just mentioned:\n\n[{]: <helper> (diffStep 7.16)\n\n#### [Step 7.16: Delete line instances in tests](https://github.com/DAB0mB/radial-snake/commit/f181da4)\n\n##### Changed resources&#x2F;scripts&#x2F;specs&#x2F;engine&#x2F;geometry&#x2F;circle.js\n```diff\n@@ -111,6 +111,8 @@\n â”Š111â”Š111â”Š          { x: 6, y: 1 },\n â”Š112â”Š112â”Š          { x: -4, y: 1 }\n â”Š113â”Š113â”Š        ]);\n+â”Š   â”Š114â”Š\n+â”Š   â”Š115â”Š        line.delete();\n â”Š114â”Š116â”Š      });\n â”Š115â”Š117â”Š    });\n â”Š116â”Š118â”Š\n```\n```diff\n@@ -121,6 +123,8 @@\n â”Š121â”Š123â”Š        expect(this.circle.getLineIntersection(line)).toEqual([\n â”Š122â”Š124â”Š          { x: -4, y: 1 }\n â”Š123â”Š125â”Š        ]);\n+â”Š   â”Š126â”Š\n+â”Š   â”Š127â”Š        line.delete();\n â”Š124â”Š128â”Š      });\n â”Š125â”Š129â”Š    });\n â”Š126â”Š130â”Š\n```\n```diff\n@@ -131,6 +135,8 @@\n â”Š131â”Š135â”Š        expect(this.circle.getLineIntersection(line)).toEqual([\n â”Š132â”Š136â”Š          { x: 1, y: 6 }\n â”Š133â”Š137â”Š        ]);\n+â”Š   â”Š138â”Š\n+â”Š   â”Š139â”Š        line.delete();\n â”Š134â”Š140â”Š      });\n â”Š135â”Š141â”Š    });\n â”Š136â”Š142â”Š\n```\n```diff\n@@ -138,6 +144,7 @@\n â”Š138â”Š144â”Š      it(\"returns nothing\", function() {\n â”Š139â”Š145â”Š        let line = new Engine.Geometry.Line(-10, 10, 10, 10);\n â”Š140â”Š146â”Š        expect(this.circle.getLineIntersection(line)).toBeUndefined();\n+â”Š   â”Š147â”Š        line.delete();\n â”Š141â”Š148â”Š      });\n â”Š142â”Š149â”Š    });\n â”Š143â”Š150â”Š  });\n```\n\n##### Changed resources&#x2F;scripts&#x2F;specs&#x2F;engine&#x2F;geometry&#x2F;line.js\n```diff\n@@ -3,6 +3,10 @@\n â”Š 3â”Š 3â”Š    this.line = new Engine.Geometry.Line(-5, -5, 5, 5);\n â”Š 4â”Š 4â”Š  });\n â”Š 5â”Š 5â”Š\n+â”Š  â”Š 6â”Š  afterEach(function () {\n+â”Š  â”Š 7â”Š    this.line.delete();\n+â”Š  â”Š 8â”Š  });\n+â”Š  â”Š 9â”Š\n â”Š 6â”Š10â”Š  describe(\"getX method\", function() {\n â”Š 7â”Š11â”Š    describe(\"given inranged y\", function() {\n â”Š 8â”Š12â”Š      it(\"returns x\", function() {\n```\n```diff\n@@ -58,6 +62,8 @@\n â”Š58â”Š62â”Š          x: 1,\n â”Š59â”Š63â”Š          y: 1\n â”Š60â”Š64â”Š        });\n+â”Š  â”Š65â”Š\n+â”Š  â”Š66â”Š        line.delete();\n â”Š61â”Š67â”Š      });\n â”Š62â”Š68â”Š    });\n â”Š63â”Š69â”Š\n```\n```diff\n@@ -65,6 +71,7 @@\n â”Š65â”Š71â”Š      it(\"returns nothing\", function() {\n â”Š66â”Š72â”Š        let line = new Engine.Geometry.Line(-5, -6, 5, 4);\n â”Š67â”Š73â”Š        expect(this.line.getLineIntersection(line)).toBeUndefined();\n+â”Š  â”Š74â”Š        line.delete();\n â”Š68â”Š75â”Š      });\n â”Š69â”Š76â”Š    });\n â”Š70â”Š77â”Š\n```\n```diff\n@@ -72,6 +79,7 @@\n â”Š72â”Š79â”Š      it(\"returns nothing\", function() {\n â”Š73â”Š80â”Š        let line = new Engine.Geometry.Line(10, 10, 10, 15);\n â”Š74â”Š81â”Š        expect(this.line.getLineIntersection(line)).toBeUndefined();\n+â”Š  â”Š82â”Š        line.delete();\n â”Š75â”Š83â”Š      });\n â”Š76â”Š84â”Š    });\n â”Š77â”Š85â”Š  });\n```\n\n##### Changed resources&#x2F;scripts&#x2F;specs&#x2F;engine&#x2F;geometry&#x2F;polygon.js\n```diff\n@@ -35,6 +35,8 @@\n â”Š35â”Š35â”Š          { x: 5, y: 4 },\n â”Š36â”Š36â”Š          { x: 0, y: 1 }\n â”Š37â”Š37â”Š        ]);\n+â”Š  â”Š38â”Š\n+â”Š  â”Š39â”Š        line.delete();\n â”Š38â”Š40â”Š      });\n â”Š39â”Š41â”Š    });\n â”Š40â”Š42â”Š\n```\n```diff\n@@ -43,6 +45,8 @@\n â”Š43â”Š45â”Š        let line = new Engine.Geometry.Line(10, 11, 15, 14);\n â”Š44â”Š46â”Š\n â”Š45â”Š47â”Š        expect(this.polygon.getLineIntersection(line)).toBeUndefined();\n+â”Š  â”Š48â”Š\n+â”Š  â”Š49â”Š        line.delete();\n â”Š46â”Š50â”Š      });\n â”Š47â”Š51â”Š    });\n â”Š48â”Š52â”Š  });\n```\n\n[}]: #\n\nSince our game also uses polygons, which is made of an abstract number of lines, its test-data needs to be disposed as well. First, we will add a `delete` method to the polygon class, which will simply go though all its bounds and delete each of its lines:\n\n[{]: <helper> (diffStep 7.17)\n\n#### [Step 7.17: Add polygon deletion method](https://github.com/DAB0mB/radial-snake/commit/1c9447f)\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;geometry&#x2F;polygon.js\n```diff\n@@ -5,6 +5,10 @@\n â”Š 5â”Š 5â”Š    this.bounds = bounds.map(coords => new Engine.Geometry.Line(...coords));\n â”Š 6â”Š 6â”Š  }\n â”Š 7â”Š 7â”Š\n+â”Š  â”Š 8â”Š  delete() {\n+â”Š  â”Š 9â”Š    this.bounds.forEach(bound => bound.delete());\n+â”Š  â”Š10â”Š  }\n+â”Š  â”Š11â”Š\n â”Š 8â”Š12â”Š  // Returns if polygon has given point\n â”Š 9â”Š13â”Š  hasPoint(x, y) {\n â”Š10â”Š14â”Š    // Run check for each bound\n```\n\n[}]: #\n\nNow we can conveniently delete unused polygons in the tests:\n\n[{]: <helper> (diffStep 7.18)\n\n#### [Step 7.18: Delete polygon instances in tests](https://github.com/DAB0mB/radial-snake/commit/48024bc)\n\n##### Changed resources&#x2F;scripts&#x2F;specs&#x2F;engine&#x2F;geometry&#x2F;polygon.js\n```diff\n@@ -8,6 +8,10 @@\n â”Š 8â”Š 8â”Š    );\n â”Š 9â”Š 9â”Š  });\n â”Š10â”Š10â”Š\n+â”Š  â”Š11â”Š  afterEach(function () {\n+â”Š  â”Š12â”Š    this.polygon.delete();\n+â”Š  â”Š13â”Š  });\n+â”Š  â”Š14â”Š\n â”Š11â”Š15â”Š  describe(\"hasPoint method\", function() {\n â”Š12â”Š16â”Š    describe(\"given contained point\", function() {\n â”Š13â”Š17â”Š      it(\"returns true\", function() {\n```\n\n[}]: #\n\nMoving on, we have the circle class to transform. The process is almost the identical to how we transformed the line class, so it's gonna be way easier now. We first start by translating our code from JavaScript to C++:\n\n[{]: <helper> (diffStep 7.19)\n\n#### [Step 7.19: Add base circle CPP module](https://github.com/DAB0mB/radial-snake/commit/1a3fa58)\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;geometry&#x2F;circle.cpp\n```diff\n@@ -0,0 +1,202 @@\n+â”Š   â”Š  1â”Š\n+â”Š   â”Š  2â”Š#include <algorithm>\n+â”Š   â”Š  3â”Š#include <cmath>\n+â”Š   â”Š  4â”Š#include <vector>\n+â”Š   â”Š  5â”Š#include \"../nullable.h\"\n+â”Š   â”Š  6â”Š#include \"../utils.h\"\n+â”Š   â”Š  7â”Š#include \"point.h\"\n+â”Š   â”Š  8â”Š#include \"line.h\"\n+â”Š   â”Š  9â”Š\n+â”Š   â”Š 10â”Šnamespace geometry {\n+â”Š   â”Š 11â”Š  // x - The x value of the circle's center\n+â”Š   â”Š 12â”Š  // y - The y value of the circle's center\n+â”Š   â”Š 13â”Š  // r - The radius of the center\n+â”Š   â”Š 14â”Š  // rad1 - The first radian of the circle, not necessarily its beginning\n+â”Š   â”Š 15â”Š  // rad2 - The second radian of the circle, not necessarily its beginning\n+â”Š   â”Š 16â”Š  Circle::Circle(double x, double y, double r, double rad1, double rad2) {\n+â”Š   â”Š 17â”Š    _x = utils::trim(x, 9);\n+â”Š   â”Š 18â”Š    _y = utils::trim(y, 9);\n+â”Š   â”Š 19â”Š    _r = utils::trim(r, 9);\n+â”Š   â”Š 20â”Š\n+â”Š   â”Š 21â”Š    // Trimming mode is done based on which radian represents the ending and which radian\n+â”Š   â”Š 22â”Š    // represents the ending\n+â”Š   â”Š 23â”Š    if (rad1 > rad2) {\n+â”Š   â”Š 24â”Š      _rad1 = utils::trim(rad1, 9, \"floor\");\n+â”Š   â”Š 25â”Š      _rad2 = utils::trim(rad2, 9, \"ceil\");\n+â”Š   â”Š 26â”Š    }\n+â”Š   â”Š 27â”Š    else {\n+â”Š   â”Š 28â”Š      _rad1 = utils::trim(rad1, 9, \"ceil\");\n+â”Š   â”Š 29â”Š      _rad2 = utils::trim(rad2, 9, \"floor\");\n+â”Š   â”Š 30â”Š    }\n+â”Š   â”Š 31â”Š  }\n+â”Š   â”Š 32â”Š\n+â”Š   â”Š 33â”Š  // Gets the matching x value for the given radian\n+â”Š   â”Š 34â”Š  Nullable<double> Circle::getMatchingX(double rad) {\n+â”Š   â”Š 35â”Š    if (!utils::chain(rad)->trim(9)->isBetween(_rad1, _rad2)->result()) {\n+â”Š   â”Š 36â”Š      return Nullable<double>();\n+â”Š   â”Š 37â”Š    }\n+â”Š   â”Š 38â”Š\n+â”Š   â”Š 39â”Š    return Nullable<double>(utils::trim((_r * std::cos(rad)) + _x, 9));\n+â”Š   â”Š 40â”Š  }\n+â”Š   â”Š 41â”Š\n+â”Š   â”Š 42â”Š  // Gets the matching y value for the given radian\n+â”Š   â”Š 43â”Š  Nullable<double> Circle::getMatchingY(double rad) {\n+â”Š   â”Š 44â”Š    if (!utils::chain(rad)->trim(9)->isBetween(_rad1, _rad2)->result()) {\n+â”Š   â”Š 45â”Š      return Nullable<double>();\n+â”Š   â”Š 46â”Š    }\n+â”Š   â”Š 47â”Š\n+â”Š   â”Š 48â”Š    return Nullable<double>(utils::trim((_r * std::sin(rad)) + _y, 9));\n+â”Š   â”Š 49â”Š  }\n+â”Š   â”Š 50â”Š\n+â”Š   â”Š 51â”Š  // Gets the matching point for the given radian\n+â”Š   â”Š 52â”Š  Nullable<Point> Circle::getMatchingPoint(double rad) {\n+â”Š   â”Š 53â”Š    if (!utils::isBetween(rad, _rad1, _rad2)) {\n+â”Š   â”Š 54â”Š      return Nullable<Point>();\n+â”Š   â”Š 55â”Š    }\n+â”Š   â”Š 56â”Š\n+â”Š   â”Š 57â”Š    return Nullable<Point>({\n+â”Š   â”Š 58â”Š      utils::trim((_r * std::cos(rad)) + _x, 9),\n+â”Š   â”Š 59â”Š      utils::trim((_r * std::sin(rad)) + _y, 9)\n+â”Š   â”Š 60â”Š    });\n+â”Š   â”Š 61â”Š  }\n+â”Š   â”Š 62â”Š\n+â”Š   â”Š 63â”Š  // Gets the matching radian for the given point\n+â”Š   â”Š 64â”Š  Nullable<double> Circle::getMatchingRad(double x, double y) {\n+â”Š   â”Š 65â”Š    double rad = std::atan2(y - _y, x - _x);\n+â”Š   â”Š 66â”Š\n+â”Š   â”Š 67â”Š    // If calculated radian is in circle's radian range, return it\n+â”Š   â”Š 68â”Š    if (!std::isnan(rad) && utils::isBetween(rad, _rad1, _rad2)) {\n+â”Š   â”Š 69â”Š      return Nullable<double>(rad);\n+â”Š   â”Š 70â”Š    }\n+â”Š   â”Š 71â”Š\n+â”Š   â”Š 72â”Š    // The calculated radian can still be in the circle's radian range in case one\n+â”Š   â”Š 73â”Š    // of the radians is greater than 2 PIEs\n+â”Š   â”Š 74â”Š    double greatestRad = std::abs(_rad1) > std::abs(_rad2) ? _rad1 : _rad2;\n+â”Š   â”Š 75â”Š\n+â”Š   â”Š 76â”Š    // Check if the absolute radian is in the circle's radian range\n+â”Š   â”Š 77â”Š    if (utils::chain(rad + (2 * M_PI * std::floor(greatestRad / (2 * M_PI))))\n+â”Š   â”Š 78â”Š        ->trim(9)->isBetween(_rad1, _rad2)->result() ||\n+â”Š   â”Š 79â”Š        utils::chain(rad + (2 * M_PI * std::ceil(greatestRad / (2 * M_PI))))\n+â”Š   â”Š 80â”Š        ->trim(9)->isBetween(_rad1, _rad2)->result()) {\n+â”Š   â”Š 81â”Š      return Nullable<double>(rad);\n+â”Š   â”Š 82â”Š    }\n+â”Š   â”Š 83â”Š\n+â”Š   â”Š 84â”Š    return Nullable<double>();\n+â”Š   â”Š 85â”Š  }\n+â”Š   â”Š 86â”Š\n+â”Š   â”Š 87â”Š  // Returns if circle has given points\n+â”Š   â”Š 88â”Š  bool Circle::hasPoint(double x, double y) {\n+â”Š   â”Š 89â”Š    return getMatchingRad(x, y).hasValue();\n+â”Š   â”Š 90â”Š  }\n+â”Š   â”Š 91â”Š\n+â”Š   â”Š 92â”Š  // circle - circle intersection method\n+â”Š   â”Š 93â”Š  Nullable<std::vector<Point>> Circle::getIntersection(Circle circle) {\n+â”Š   â”Š 94â”Š    double dx = circle._x - _x;\n+â”Š   â”Š 95â”Š    double dy = circle._y - _y;\n+â”Š   â”Š 96â”Š    double d = std::sqrt(std::pow(dx, 2) + std::pow(dy, 2));\n+â”Š   â”Š 97â”Š\n+â”Š   â”Š 98â”Š    if (d > _r + circle._r ||\n+â”Š   â”Š 99â”Š       d < std::abs(_r - circle._r)) {\n+â”Š   â”Š100â”Š      return Nullable<std::vector<Point>>();\n+â”Š   â”Š101â”Š    }\n+â”Š   â”Š102â”Š\n+â”Š   â”Š103â”Š    double a = ((std::pow(_r, 2) - std::pow(circle._r, 2)) + std::pow(d, 2)) / (2 * d);\n+â”Š   â”Š104â”Š    double x = _x + ((dx * a) / d);\n+â”Š   â”Š105â”Š    double y = _y + ((dy * a) / d);\n+â”Š   â”Š106â”Š    double h = std::sqrt(std::pow(_r, 2) - std::pow(a, 2));\n+â”Š   â”Š107â”Š    double rx = (- dy * h) / d;\n+â”Š   â”Š108â”Š    double ry = (dx * h) / d;\n+â”Š   â”Š109â”Š\n+â”Š   â”Š110â”Š    std::vector<Point> interPoints(2);\n+â”Š   â”Š111â”Š    interPoints.at(0).x = x + rx;\n+â”Š   â”Š112â”Š    interPoints.at(0).y = y + ry;\n+â”Š   â”Š113â”Š    interPoints.at(1).x = x - rx;\n+â”Š   â”Š114â”Š    interPoints.at(1).y = y - ry;\n+â”Š   â”Š115â”Š\n+â”Š   â”Š116â”Š    for (unsigned i = 0; i < interPoints.size(); i++) {\n+â”Š   â”Š117â”Š      Point& point = interPoints.at(i);\n+â”Š   â”Š118â”Š      point.x = utils::trim(point.x, 9);\n+â”Š   â”Š119â”Š      point.y = utils::trim(point.y, 9);\n+â”Š   â”Š120â”Š    }\n+â”Š   â”Š121â”Š\n+â”Š   â”Š122â”Š    auto pointsBegin = std::unique(interPoints.begin(), interPoints.end(),\n+â”Š   â”Š123â”Š      [](Point pointA, Point pointB) {\n+â”Š   â”Š124â”Š        return pointA.x == pointB.x && pointA.y == pointB.y;\n+â”Š   â”Š125â”Š      }\n+â”Š   â”Š126â”Š    );\n+â”Š   â”Š127â”Š\n+â”Š   â”Š128â”Š    interPoints.erase(pointsBegin, interPoints.end());\n+â”Š   â”Š129â”Š\n+â”Š   â”Š130â”Š    std::vector<Circle> circles = { *this, circle };\n+â”Š   â”Š131â”Š\n+â”Š   â”Š132â”Š    std::for_each(circles.begin(), circles.end(), [&interPoints](Circle circle) {\n+â”Š   â”Š133â”Š      auto pointsBegin = std::remove_if(interPoints.begin(), interPoints.end(),\n+â”Š   â”Š134â”Š        [&circle](Point point) {\n+â”Š   â”Š135â”Š          return !circle.hasPoint(point.x, point.y);\n+â”Š   â”Š136â”Š        }\n+â”Š   â”Š137â”Š      );\n+â”Š   â”Š138â”Š\n+â”Š   â”Š139â”Š      interPoints.erase(pointsBegin, interPoints.end());\n+â”Š   â”Š140â”Š    });\n+â”Š   â”Š141â”Š\n+â”Š   â”Š142â”Š    if (interPoints.size()) {\n+â”Š   â”Š143â”Š      return Nullable<std::vector<Point>>(interPoints);\n+â”Š   â”Š144â”Š    }\n+â”Š   â”Š145â”Š\n+â”Š   â”Š146â”Š    return Nullable<std::vector<Point>>();\n+â”Š   â”Š147â”Š  }\n+â”Š   â”Š148â”Š\n+â”Š   â”Š149â”Š  // circle - line intersection method\n+â”Š   â”Š150â”Š  Nullable<std::vector<Point>> Circle::getIntersection(Line line) {\n+â”Š   â”Š151â”Š    double x1 = line._x1 - _x;\n+â”Š   â”Š152â”Š    double x2 = line._x2 - _x;\n+â”Š   â”Š153â”Š    double y1 = line._y1 - _y;\n+â”Š   â”Š154â”Š    double y2 = line._y2 - _y;\n+â”Š   â”Š155â”Š    double dx = x2 - x1;\n+â”Š   â”Š156â”Š    double dy = y2 - y1;\n+â”Š   â”Š157â”Š    double d = std::sqrt(std::pow(dx, 2) + std::pow(dy, 2));\n+â”Š   â”Š158â”Š    double h = (x1 * y2) - (x2 * y1);\n+â”Š   â”Š159â”Š    double delta = (std::pow(_r, 2) * std::pow(d, 2)) - std::pow(h, 2);\n+â”Š   â”Š160â”Š\n+â”Š   â”Š161â”Š    if (delta < 0) Nullable<std::vector<Point>>();\n+â”Š   â”Š162â”Š\n+â”Š   â”Š163â”Š    double sign = dy / std::abs(dy); if (std::isnan(sign)) sign = 1;\n+â”Š   â”Š164â”Š    double sqrtx = sign * dx * std::sqrt(delta);\n+â”Š   â”Š165â”Š    double sqrty = std::abs(dy) * std::sqrt(delta);\n+â”Š   â”Š166â”Š\n+â”Š   â”Š167â”Š    std::vector<Point> interPoints(2);\n+â”Š   â”Š168â”Š    interPoints.at(0).x = (((h * dy) + sqrtx) / std::pow(d, 2)) + _x;\n+â”Š   â”Š169â”Š    interPoints.at(0).y = (((-h * dx) + sqrty) / std::pow(d, 2)) + _y;\n+â”Š   â”Š170â”Š    interPoints.at(1).x = (((h * dy) - sqrtx) / std::pow(d, 2)) + _x;\n+â”Š   â”Š171â”Š    interPoints.at(1).y = (((-h * dx) - sqrty) / std::pow(d, 2)) + _y;\n+â”Š   â”Š172â”Š\n+â”Š   â”Š173â”Š    for (unsigned i = 0; i < interPoints.size(); i++) {\n+â”Š   â”Š174â”Š      Point& point = interPoints.at(i);\n+â”Š   â”Š175â”Š      point.x = utils::trim(point.x, 9);\n+â”Š   â”Š176â”Š      point.y = utils::trim(point.y, 9);\n+â”Š   â”Š177â”Š    }\n+â”Š   â”Š178â”Š\n+â”Š   â”Š179â”Š    auto pointsBegin = std::remove_if(interPoints.begin(), interPoints.end(),\n+â”Š   â”Š180â”Š      [this, &line](Point point) {\n+â”Š   â”Š181â”Š        return !hasPoint(point.x, point.y) ||\n+â”Š   â”Š182â”Š          !line.boundsHavePoint(point.x, point.y);\n+â”Š   â”Š183â”Š      }\n+â”Š   â”Š184â”Š    );\n+â”Š   â”Š185â”Š\n+â”Š   â”Š186â”Š    interPoints.erase(pointsBegin, interPoints.end());\n+â”Š   â”Š187â”Š\n+â”Š   â”Š188â”Š    pointsBegin = std::unique(interPoints.begin(), interPoints.end(),\n+â”Š   â”Š189â”Š      [](Point pointA, Point pointB) {\n+â”Š   â”Š190â”Š        return pointA.x == pointB.x && pointA.y == pointB.y;\n+â”Š   â”Š191â”Š      }\n+â”Š   â”Š192â”Š    );\n+â”Š   â”Š193â”Š\n+â”Š   â”Š194â”Š    interPoints.erase(pointsBegin, interPoints.end());\n+â”Š   â”Š195â”Š\n+â”Š   â”Š196â”Š    if (interPoints.size()) {\n+â”Š   â”Š197â”Š      return Nullable<std::vector<Point>>(interPoints);\n+â”Š   â”Š198â”Š    }\n+â”Š   â”Š199â”Š\n+â”Š   â”Š200â”Š    return Nullable<std::vector<Point>>();\n+â”Š   â”Š201â”Š  }\n+â”Š   â”Š202â”Š}ðŸš«â†µ\n```\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;geometry&#x2F;circle.h\n```diff\n@@ -0,0 +1,35 @@\n+â”Š  â”Š 1â”Š#pragma once\n+â”Š  â”Š 2â”Š\n+â”Š  â”Š 3â”Š#include <vector>\n+â”Š  â”Š 4â”Š#include \"../nullable.h\"\n+â”Š  â”Š 5â”Š#include \"point.h\"\n+â”Š  â”Š 6â”Š#include \"line.h\"\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Šnamespace geometry {\n+â”Š  â”Š 9â”Š  class Line;\n+â”Š  â”Š10â”Š\n+â”Š  â”Š11â”Š  class Circle {\n+â”Š  â”Š12â”Š  public:\n+â”Š  â”Š13â”Š    double _x;\n+â”Š  â”Š14â”Š    double _y;\n+â”Š  â”Š15â”Š    double _r;\n+â”Š  â”Š16â”Š    double _rad1;\n+â”Š  â”Š17â”Š    double _rad2;\n+â”Š  â”Š18â”Š\n+â”Š  â”Š19â”Š    Circle(double x, double y, double r, double rad1, double rad2);\n+â”Š  â”Š20â”Š\n+â”Š  â”Š21â”Š    Nullable<double> getMatchingX(double rad);\n+â”Š  â”Š22â”Š\n+â”Š  â”Š23â”Š    Nullable<double> getMatchingY(double rad);\n+â”Š  â”Š24â”Š\n+â”Š  â”Š25â”Š    Nullable<Point> getMatchingPoint(double rad);\n+â”Š  â”Š26â”Š\n+â”Š  â”Š27â”Š    Nullable<double> getMatchingRad(double x, double y);\n+â”Š  â”Š28â”Š\n+â”Š  â”Š29â”Š    bool hasPoint(double x, double y);\n+â”Š  â”Š30â”Š\n+â”Š  â”Š31â”Š    Nullable<std::vector<Point>> getIntersection(Circle circle);\n+â”Š  â”Š32â”Š\n+â”Š  â”Š33â”Š    Nullable<std::vector<Point>> getIntersection(Line line);\n+â”Š  â”Š34â”Š  };\n+â”Š  â”Š35â”Š}ðŸš«â†µ\n```\n\n##### Changed resources&#x2F;cpp&#x2F;src&#x2F;index.cpp\n```diff\n@@ -1,3 +1,4 @@\n â”Š1â”Š1â”Š#include \"nullable.cpp\"\n â”Š2â”Š2â”Š#include \"utils.cpp\"\n-â”Š3â”Š â”Š#include \"geometry/line.cpp\"ðŸš«â†µ\n+â”Š â”Š3â”Š#include \"geometry/line.cpp\"\n+â”Š â”Š4â”Š#include \"geometry/circle.cpp\"ðŸš«â†µ\n```\n\n[}]: #\n\nSecond, we need to wrap our code using EMBind:\n\n[{]: <helper> (diffStep 7.2)\n\n#### [Step 7.2: Add base utility CPP module](https://github.com/DAB0mB/radial-snake/commit/6dba512)\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;utils.cpp\n```diff\n@@ -0,0 +1,73 @@\n+â”Š  â”Š 1â”Š#include <cfloat>\n+â”Š  â”Š 2â”Š#include <cmath>\n+â”Š  â”Š 3â”Š#include <string>\n+â”Š  â”Š 4â”Š#include \"utils.h\"\n+â”Š  â”Š 5â”Š\n+â”Š  â”Š 6â”Šnamespace utils {\n+â”Š  â”Š 7â”Š  // Fixed modulo method which can calculate modulo of negative numbers properly\n+â”Š  â”Š 8â”Š  // e.g. (-803).mod(800) returns 797\n+â”Š  â”Š 9â”Š  double mod(double context, double num) {\n+â”Š  â”Š10â”Š    return std::fmod((std::fmod(context, num) + num), num);\n+â”Š  â”Š11â”Š  }\n+â”Š  â”Š12â”Š\n+â”Š  â”Š13â”Š  // Trims number and leaves the number of decimals specified.\n+â”Š  â”Š14â”Š  // The \"mode\" argument specifies which math function should be invoked\n+â”Š  â”Š15â”Š  // right after the number has been trimmed.\n+â”Š  â”Š16â”Š  // e.g. 12.12345.trim(3, \"ceil\") returns 12.124\n+â”Š  â”Š17â”Š  double trim(double context, int decimals, const std::string mode) {\n+â”Š  â”Š18â”Š    double accumulator = context * std::pow(10, decimals);\n+â”Š  â”Š19â”Š\n+â”Š  â”Š20â”Š    if (mode.compare(\"ceil\") == 0)\n+â”Š  â”Š21â”Š      accumulator = std::ceil(accumulator);\n+â”Š  â”Š22â”Š    else if (mode.compare(\"floor\") == 0)\n+â”Š  â”Š23â”Š      accumulator = std::floor(accumulator);\n+â”Š  â”Š24â”Š    else\n+â”Š  â”Š25â”Š      accumulator = std::round(accumulator);\n+â”Š  â”Š26â”Š\n+â”Š  â”Š27â”Š    return accumulator / std::pow(10, decimals);\n+â”Š  â”Š28â”Š  }\n+â”Š  â”Š29â”Š\n+â”Š  â”Š30â”Š  // Tells if number is in specified range based on given precision.\n+â”Š  â”Š31â”Š  // See the \"compare\" method for more information about precision\n+â”Š  â”Š32â”Š  bool isBetween(double context, double num1, double num2, const std::string precision) {\n+â”Š  â”Š33â”Š    return compare(context, std::min(num1, num2), \">=\", precision) &&\n+â”Š  â”Š34â”Š           compare(context, std::max(num1, num2), \"<=\", precision);\n+â”Š  â”Š35â”Š  }\n+â”Š  â”Š36â”Š\n+â”Š  â”Š37â”Š  bool compare(double context, double num, const std::string precision) {\n+â”Š  â”Š38â”Š    return compare(context, num, \"==\", precision);\n+â”Š  â”Š39â”Š  }\n+â”Š  â”Š40â”Š\n+â”Š  â”Š41â”Š  // Initiates comparison operator between context number and a given number, only here\n+â”Š  â”Š42â”Š  // a precision can be specified\n+â”Š  â”Š43â”Š  bool compare(double context, double num, const std::string method, const std::string precision) {\n+â”Š  â”Š44â”Š    // Fixed precision, \"almost equal\" with a deviation of Îµ\n+â”Š  â”Š45â”Š    if (precision.compare(\"f\") == 0) {\n+â”Š  â”Š46â”Š      if (method.compare(\"<\") == 0 ||\n+â”Š  â”Š47â”Š          method.compare(\"<=\") == 0)\n+â”Š  â”Š48â”Š        return context <= num + DBL_EPSILON;\n+â”Š  â”Š49â”Š      if (method.compare(\">\") == 0 ||\n+â”Š  â”Š50â”Š          method.compare(\">=\") == 0)\n+â”Š  â”Š51â”Š        return context >= num - DBL_EPSILON;\n+â”Š  â”Š52â”Š      return std::abs(context - num) <= DBL_EPSILON;\n+â”Š  â”Š53â”Š    }\n+â”Š  â”Š54â”Š    // Pixel precision, round comparison\n+â”Š  â”Š55â”Š    else if (precision.compare(\"px\") == 0) {\n+â”Š  â”Š56â”Š      if (method.compare(\"<\") == 0 ||\n+â”Š  â”Š57â”Š          method.compare(\"<=\") == 0)\n+â”Š  â”Š58â”Š        return std::round(context) <= std::round(num);\n+â”Š  â”Š59â”Š      if (method.compare(\">\") == 0 ||\n+â”Š  â”Š60â”Š          method.compare(\">=\") == 0)\n+â”Š  â”Š61â”Š        return std::round(context) >= std::round(num);\n+â”Š  â”Š62â”Š      return std::round(context) == std::round(num);\n+â”Š  â”Š63â”Š    }\n+â”Š  â”Š64â”Š    // Exact precision\n+â”Š  â”Š65â”Š    else {\n+â”Š  â”Š66â”Š      if (method.compare(\"<\") == 0) return context < num;\n+â”Š  â”Š67â”Š      if (method.compare(\"<=\") == 0) return context <= num;\n+â”Š  â”Š68â”Š      if (method.compare(\">\") == 0) return context > num;\n+â”Š  â”Š69â”Š      if (method.compare(\">=\") == 0) return context >= num;\n+â”Š  â”Š70â”Š      return context == num;\n+â”Š  â”Š71â”Š    }\n+â”Š  â”Š72â”Š  }\n+â”Š  â”Š73â”Š}ðŸš«â†µ\n```\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;utils.h\n```diff\n@@ -0,0 +1,15 @@\n+â”Š  â”Š 1â”Š#pragma once\n+â”Š  â”Š 2â”Š\n+â”Š  â”Š 3â”Š#include <string>\n+â”Š  â”Š 4â”Š\n+â”Š  â”Š 5â”Šnamespace utils {\n+â”Š  â”Š 6â”Š  double mod(double context, double num);\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Š  double trim(double context, int decimals, const std::string mode = \"round\");\n+â”Š  â”Š 9â”Š\n+â”Š  â”Š10â”Š  bool isBetween(double context, double num1, double num2, const std::string precision = \"exact\");\n+â”Š  â”Š11â”Š\n+â”Š  â”Š12â”Š  bool compare(double context, double num, const std::string precision = \"exact\");\n+â”Š  â”Š13â”Š\n+â”Š  â”Š14â”Š  bool compare(double context, double num, const std::string method, const std::string precision);\n+â”Š  â”Š15â”Š}ðŸš«â†µ\n```\n\n[}]: #\n\nAnd finally, we will extend the C++ in our JavaScript circle:\n\n[{]: <helper> (diffStep 7.21)\n\n#### [Step 7.21: Extend CPP circle class](https://github.com/DAB0mB/radial-snake/commit/d05cf32)\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;geometry&#x2F;circle.js\n```diff\n@@ -1,83 +1,9 @@\n-â”Š 1â”Š  â”ŠEngine.Geometry.Circle = class Circle {\n-â”Š 2â”Š  â”Š  // x - The x value of the circle's center\n-â”Š 3â”Š  â”Š  // y - The y value of the circle's center\n-â”Š 4â”Š  â”Š  // r - The radius of the center\n-â”Š 5â”Š  â”Š  // rad1 - The first radian of the circle, not necessarily its beginning\n-â”Š 6â”Š  â”Š  // rad2 - The second radian of the circle, not necessarily its beginning\n-â”Š 7â”Š  â”Š  constructor(x, y, r, rad1, rad2) {\n-â”Š 8â”Š  â”Š    this.x = Utils.trim(x, 9);\n-â”Š 9â”Š  â”Š    this.y = Utils.trim(y, 9);\n-â”Š10â”Š  â”Š    this.r = Utils.trim(r, 9);\n-â”Š11â”Š  â”Š\n-â”Š12â”Š  â”Š    // Trimming mode is done based on which radian represents the ending and which radian\n-â”Š13â”Š  â”Š    // represents the ending\n-â”Š14â”Š  â”Š    if (rad1 > rad2) {\n-â”Š15â”Š  â”Š      this.rad1 = Utils.trim(rad1, 9, \"floor\");\n-â”Š16â”Š  â”Š      this.rad2 = Utils.trim(rad2, 9, \"ceil\");\n-â”Š17â”Š  â”Š    }\n-â”Š18â”Š  â”Š    else {\n-â”Š19â”Š  â”Š      this.rad1 = Utils.trim(rad1, 9, \"ceil\");\n-â”Š20â”Š  â”Š      this.rad2 = Utils.trim(rad2, 9, \"floor\");\n-â”Š21â”Š  â”Š    }\n-â”Š22â”Š  â”Š  }\n-â”Š23â”Š  â”Š\n+â”Š  â”Š 1â”ŠEngine.Geometry.Circle = class Circle extends Utils.proxy(CPP.Geometry.Circle) {\n â”Š24â”Š 2â”Š  // Draws the circle on the given context\n â”Š25â”Š 3â”Š  draw(context) {\n â”Š26â”Š 4â”Š    context.arc(this.x, this.y, this.r, this.rad1, this.rad2);\n â”Š27â”Š 5â”Š  }\n â”Š28â”Š 6â”Š\n-â”Š29â”Š  â”Š  // Gets the matching x value for the given radian\n-â”Š30â”Š  â”Š  getX(rad) {\n-â”Š31â”Š  â”Š    if (!Utils(rad).trim(9).isBetween(this.rad1, this.rad2).value()) return;\n-â”Š32â”Š  â”Š    return Utils.trim((this.r * Math.cos(rad)) + this.x, 9);\n-â”Š33â”Š  â”Š  }\n-â”Š34â”Š  â”Š\n-â”Š35â”Š  â”Š  // Gets the matching y value for the given radian\n-â”Š36â”Š  â”Š  getY(rad) {\n-â”Š37â”Š  â”Š    if (!Utils(rad).trim(9).isBetween(this.rad1, this.rad2).value()) return;\n-â”Š38â”Š  â”Š    return Utils.trim((this.r * Math.sin(rad)) + this.y, 9);\n-â”Š39â”Š  â”Š  }\n-â”Š40â”Š  â”Š\n-â”Š41â”Š  â”Š  // Gets the matching point for the given radian\n-â”Š42â”Š  â”Š  getPoint(rad) {\n-â”Š43â”Š  â”Š    if (!Utils.isBetween(rad, this.rad1, this.rad2)) return;\n-â”Š44â”Š  â”Š\n-â”Š45â”Š  â”Š    return {\n-â”Š46â”Š  â”Š      x: Utils.trim((this.r * Math.cos(rad)) + this.x, 9),\n-â”Š47â”Š  â”Š      y: Utils.trim((this.r * Math.sin(rad)) + this.y, 9)\n-â”Š48â”Š  â”Š    };\n-â”Š49â”Š  â”Š  }\n-â”Š50â”Š  â”Š\n-â”Š51â”Š  â”Š  // Gets the matching radian for the given point\n-â”Š52â”Š  â”Š  getRad(x, y) {\n-â”Š53â”Š  â”Š    let rad = Math.atan2(y - this.y, x - this.x);\n-â”Š54â”Š  â”Š\n-â”Š55â”Š  â”Š    // If calculated radian is in circle's radian range, return it\n-â”Š56â”Š  â”Š    if (rad != null && Utils.isBetween(rad, this.rad1, this.rad2)) {\n-â”Š57â”Š  â”Š      return rad;\n-â”Š58â”Š  â”Š    }\n-â”Š59â”Š  â”Š\n-â”Š60â”Š  â”Š    // The calculated radian can still be in the circle's radian range in case one\n-â”Š61â”Š  â”Š    // of the radians is greater than 2 PIEs\n-â”Š62â”Š  â”Š    if (Math.abs(this.rad1) > Math.abs(this.rad2)) {\n-â”Š63â”Š  â”Š      var greatestRad = this.rad1;\n-â”Š64â”Š  â”Š    }\n-â”Š65â”Š  â”Š    else {\n-â”Š66â”Š  â”Š      var greatestRad = this.rad2;\n-â”Š67â”Š  â”Š    }\n-â”Š68â”Š  â”Š\n-â”Š69â”Š  â”Š    // Check if the absolute radian is in the circle's radian range\n-â”Š70â”Š  â”Š    if (Utils(rad + (2 * Math.PI * Math.floor(greatestRad / (2 * Math.PI)))).trim(9).isBetween(this.rad1, this.rad2).value() ||\n-â”Š71â”Š  â”Š        Utils(rad + (2 * Math.PI * Math.ceil(greatestRad / (2 * Math.PI)))).trim(9).isBetween(this.rad1, this.rad2).value()) {\n-â”Š72â”Š  â”Š      return rad;\n-â”Š73â”Š  â”Š    }\n-â”Š74â”Š  â”Š  }\n-â”Š75â”Š  â”Š\n-â”Š76â”Š  â”Š  // Returns if circle has given points\n-â”Š77â”Š  â”Š  hasPoint(x, y) {\n-â”Š78â”Š  â”Š    return this.getRad(x, y) != null;\n-â”Š79â”Š  â”Š  }\n-â”Š80â”Š  â”Š\n â”Š81â”Š 7â”Š  getIntersection(shape) {\n â”Š82â”Š 8â”Š    if (shape instanceof Engine.Geometry.Line)\n â”Š83â”Š 9â”Š      return this.getLineIntersection(shape);\n```\n```diff\n@@ -87,86 +13,6 @@\n â”Š 87â”Š 13â”Š      return this.getPolygonIntersection(shape);\n â”Š 88â”Š 14â”Š  }\n â”Š 89â”Š 15â”Š\n-â”Š 90â”Š   â”Š  // circle - circle intersection method\n-â”Š 91â”Š   â”Š  getCircleIntersection(circle) {\n-â”Š 92â”Š   â”Š    let dx = circle.x - this.x;\n-â”Š 93â”Š   â”Š    let dy = circle.y - this.y;\n-â”Š 94â”Š   â”Š    let d = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\n-â”Š 95â”Š   â”Š\n-â”Š 96â”Š   â”Š    if (d > this.r + circle.r ||\n-â”Š 97â”Š   â”Š       d < Math.abs(this.r - circle.r)) {\n-â”Š 98â”Š   â”Š      return;\n-â”Š 99â”Š   â”Š    }\n-â”Š100â”Š   â”Š\n-â”Š101â”Š   â”Š    let a = ((Math.pow(this.r, 2) - Math.pow(circle.r, 2)) + Math.pow(d, 2)) / (2 * d);\n-â”Š102â”Š   â”Š    let x = this.x + ((dx * a) / d);\n-â”Š103â”Š   â”Š    let y = this.y + ((dy * a) / d);\n-â”Š104â”Š   â”Š    let h = Math.sqrt(Math.pow(this.r, 2) - Math.pow(a, 2));\n-â”Š105â”Š   â”Š    let rx = (- dy * h) / d;\n-â”Š106â”Š   â”Š    let ry = (dx * h) / d;\n-â”Š107â”Š   â”Š\n-â”Š108â”Š   â”Š    let interPoints = [\n-â”Š109â”Š   â”Š      {\n-â”Š110â”Š   â”Š        x: x + rx,\n-â”Š111â”Š   â”Š        y: y + ry\n-â”Š112â”Š   â”Š      },\n-â”Š113â”Š   â”Š      {\n-â”Š114â”Š   â”Š        x: x - rx,\n-â”Š115â”Š   â”Š        y: y - ry\n-â”Š116â”Š   â”Š      }\n-â”Š117â”Š   â”Š    ]\n-â”Š118â”Š   â”Š    .map(point => ({\n-â”Š119â”Š   â”Š        x: Utils.trim(point.x, 9),\n-â”Š120â”Š   â”Š        y: Utils.trim(point.y, 9)\n-â”Š121â”Š   â”Š     }));\n-â”Š122â”Š   â”Š\n-â”Š123â”Š   â”Š    interPoints = _.uniq(interPoints, point => `(${point.x}, ${point.y})`);\n-â”Š124â”Š   â”Š\n-â”Š125â”Š   â”Š    [this, circle].forEach(function(circle) {\n-â”Š126â”Š   â”Š      interPoints = interPoints.filter(point => circle.hasPoint(point.x, point.y));\n-â”Š127â”Š   â”Š    });\n-â”Š128â”Š   â”Š\n-â”Š129â”Š   â”Š    if (interPoints.length > 0) return interPoints;\n-â”Š130â”Š   â”Š  }\n-â”Š131â”Š   â”Š\n-â”Š132â”Š   â”Š  // circle - line intersection method\n-â”Š133â”Š   â”Š  getLineIntersection(line) {\n-â”Š134â”Š   â”Š    let x1 = line.x1 - this.x;\n-â”Š135â”Š   â”Š    let x2 = line.x2 - this.x;\n-â”Š136â”Š   â”Š    let y1 = line.y1 - this.y;\n-â”Š137â”Š   â”Š    let y2 = line.y2 - this.y;\n-â”Š138â”Š   â”Š    let dx = x2 - x1;\n-â”Š139â”Š   â”Š    let dy = y2 - y1;\n-â”Š140â”Š   â”Š    let d = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\n-â”Š141â”Š   â”Š    let h = (x1 * y2) - (x2 * y1);\n-â”Š142â”Š   â”Š    let delta = (Math.pow(this.r, 2) * Math.pow(d, 2)) - Math.pow(h, 2);\n-â”Š143â”Š   â”Š\n-â”Š144â”Š   â”Š    if (delta < 0) return;\n-â”Š145â”Š   â”Š\n-â”Š146â”Š   â”Š    let interPoints = [\n-â”Š147â”Š   â”Š      {\n-â”Š148â”Š   â”Š        x: (((h * dy) + (((dy / Math.abs(dy)) || 1) * dx * Math.sqrt(delta))) / Math.pow(d, 2)) + this.x,\n-â”Š149â”Š   â”Š        y: (((-h * dx) + (Math.abs(dy) * Math.sqrt(delta))) / Math.pow(d, 2)) + this.y\n-â”Š150â”Š   â”Š      },\n-â”Š151â”Š   â”Š      {\n-â”Š152â”Š   â”Š        x: (((h * dy) - (((dy / Math.abs(dy)) || 1) * dx * Math.sqrt(delta))) / Math.pow(d, 2)) + this.x,\n-â”Š153â”Š   â”Š        y: (((-h * dx) - (Math.abs(dy) * Math.sqrt(delta))) / Math.pow(d, 2)) + this.y\n-â”Š154â”Š   â”Š      }\n-â”Š155â”Š   â”Š    ]\n-â”Š156â”Š   â”Š    .map(point => ({\n-â”Š157â”Š   â”Š        x: Utils.trim(point.x, 9),\n-â”Š158â”Š   â”Š        y: Utils.trim(point.y, 9)\n-â”Š159â”Š   â”Š    }))\n-â”Š160â”Š   â”Š    .filter(point => {\n-â”Š161â”Š   â”Š      return this.hasPoint(point.x, point.y) &&\n-â”Š162â”Š   â”Š        line.boundsHavePoint(point.x, point.y);\n-â”Š163â”Š   â”Š    });\n-â”Š164â”Š   â”Š\n-â”Š165â”Š   â”Š    interPoints = _.uniq(interPoints, point => `(${point.x}, ${point.y})`);\n-â”Š166â”Š   â”Š\n-â”Š167â”Š   â”Š    if (interPoints.length > 0) return interPoints;\n-â”Š168â”Š   â”Š  }\n-â”Š169â”Š   â”Š\n â”Š170â”Š 16â”Š  // circle - polygon intersection method\n â”Š171â”Š 17â”Š  getPolygonIntersection(polygon) {\n â”Š172â”Š 18â”Š    return polygon.getCircleIntersection(this);\n```\n\n[}]: #\n\nWe also need to update the line class to contain a reference to the newly created line-intersection method, so it can be invoked from both a line or a circle bi-directionally:\n\n[{]: <helper> (diffStep 7.22)\n\n#### [Step 7.22: Add line-circle intersection method](https://github.com/DAB0mB/radial-snake/commit/84f5f4d)\n\n##### Changed resources&#x2F;cpp&#x2F;src&#x2F;geometry&#x2F;line.cpp\n```diff\n@@ -4,6 +4,7 @@\n â”Š 4â”Š 4â”Š#include \"../nullable.h\"\n â”Š 5â”Š 5â”Š#include \"../utils.h\"\n â”Š 6â”Š 6â”Š#include \"point.h\"\n+â”Š  â”Š 7â”Š#include \"circle.h\"\n â”Š 7â”Š 8â”Š#include \"line.h\"\n â”Š 8â”Š 9â”Š\n â”Š 9â”Š10â”Šnamespace geometry {\n```\n```diff\n@@ -100,6 +101,11 @@\n â”Š100â”Š101â”Š    return Nullable<Point>();\n â”Š101â”Š102â”Š  }\n â”Š102â”Š103â”Š\n+â”Š   â”Š104â”Š  // circle - circle intersection method\n+â”Š   â”Š105â”Š  Nullable<std::vector<Point>> Line::getIntersection(Circle circle) {\n+â”Š   â”Š106â”Š    return circle.getIntersection(*this);\n+â”Š   â”Š107â”Š  }\n+â”Š   â”Š108â”Š\n â”Š103â”Š109â”Š  emscripten::val EMLine::getMatchingX(double y) {\n â”Š104â”Š110â”Š    Nullable<double> nullableX = Line::getMatchingX(y);\n â”Š105â”Š111â”Š    return nullableX.hasValue() ?\n```\n```diff\n@@ -126,6 +132,10 @@\n â”Š126â”Š132â”Š    emPoint.set(\"y\", emscripten::val(point.y));\n â”Š127â”Š133â”Š    return emPoint;\n â”Š128â”Š134â”Š  }\n+â”Š   â”Š135â”Š\n+â”Š   â”Š136â”Š  emscripten::val EMLine::getIntersection(EMCircle emCircle) {\n+â”Š   â”Š137â”Š    return emCircle.getIntersection(*this);\n+â”Š   â”Š138â”Š  }\n â”Š129â”Š139â”Š}\n â”Š130â”Š140â”Š\n â”Š131â”Š141â”ŠEMSCRIPTEN_BINDINGS(geometry_line_module) {\n```\n```diff\n@@ -146,5 +156,10 @@\n â”Š146â”Š156â”Š      emscripten::select_overload<emscripten::val(geometry::EMLine)>(\n â”Š147â”Š157â”Š        &geometry::EMLine::getIntersection\n â”Š148â”Š158â”Š      )\n+â”Š   â”Š159â”Š    )\n+â”Š   â”Š160â”Š    .function(\"getCircleIntersection\",\n+â”Š   â”Š161â”Š      emscripten::select_overload<emscripten::val(geometry::EMCircle)>(\n+â”Š   â”Š162â”Š        &geometry::EMLine::getIntersection\n+â”Š   â”Š163â”Š      )\n â”Š149â”Š164â”Š    );\n â”Š150â”Š165â”Š}ðŸš«â†µ\n```\n\n##### Changed resources&#x2F;cpp&#x2F;src&#x2F;geometry&#x2F;line.h\n```diff\n@@ -4,6 +4,7 @@\n â”Š 4â”Š 4â”Š#include <emscripten/val.h>\n â”Š 5â”Š 5â”Š#include \"../nullable.h\"\n â”Š 6â”Š 6â”Š#include \"point.h\"\n+â”Š  â”Š 7â”Š#include \"circle.h\"\n â”Š 7â”Š 8â”Š\n â”Š 8â”Š 9â”Šnamespace geometry {\n â”Š 9â”Š10â”Š  class Circle;\n```\n```diff\n@@ -27,6 +28,8 @@\n â”Š27â”Š28â”Š    bool boundsHavePoint(double x, double y);\n â”Š28â”Š29â”Š\n â”Š29â”Š30â”Š    Nullable<Point> getIntersection(Line line);\n+â”Š  â”Š31â”Š\n+â”Š  â”Š32â”Š    Nullable<std::vector<Point>> getIntersection(Circle circle);\n â”Š30â”Š33â”Š  };\n â”Š31â”Š34â”Š\n â”Š32â”Š35â”Š  class EMLine : public Line {\n```\n```diff\n@@ -38,5 +41,7 @@\n â”Š38â”Š41â”Š    emscripten::val getMatchingY(double x);\n â”Š39â”Š42â”Š\n â”Š40â”Š43â”Š    emscripten::val getIntersection(EMLine line);\n+â”Š  â”Š44â”Š\n+â”Š  â”Š45â”Š    emscripten::val getIntersection(EMCircle circle);\n â”Š41â”Š46â”Š  };\n â”Š42â”Š47â”Š}ðŸš«â†µ\n```\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;geometry&#x2F;line.js\n```diff\n@@ -14,11 +14,6 @@\n â”Š14â”Š14â”Š      return this.getPolygonIntersection(shape);\n â”Š15â”Š15â”Š  }\n â”Š16â”Š16â”Š\n-â”Š17â”Š  â”Š  // line - circle intersection method\n-â”Š18â”Š  â”Š  getCircleIntersection(circle) {\n-â”Š19â”Š  â”Š    return circle.getLineIntersection(this);\n-â”Š20â”Š  â”Š  }\n-â”Š21â”Š  â”Š\n â”Š22â”Š17â”Š  // line - polygon intersection method\n â”Š23â”Š18â”Š  getPolygonIntersection(polygon) {\n â”Š24â”Š19â”Š    return polygon.getLineIntersection(this);\n```\n\n[}]: #\n\nNow, before running the tests, be sure to disposed unused circle test-data:\n\n[{]: <helper> (diffStep 7.23)\n\n#### [Step 7.23: Delete circle instances in tests](https://github.com/DAB0mB/radial-snake/commit/e953fae)\n\n##### Changed resources&#x2F;scripts&#x2F;specs&#x2F;engine&#x2F;geometry&#x2F;circle.js\n```diff\n@@ -3,6 +3,10 @@\n â”Š 3â”Š 3â”Š    this.circle = new Engine.Geometry.Circle(1, 1, 5, 0, 1.5 * Math.PI);\n â”Š 4â”Š 4â”Š  });\n â”Š 5â”Š 5â”Š\n+â”Š  â”Š 6â”Š  afterEach(function () {\n+â”Š  â”Š 7â”Š    this.circle.delete();\n+â”Š  â”Š 8â”Š  });\n+â”Š  â”Š 9â”Š\n â”Š 6â”Š10â”Š  describe(\"getX method\", function() {\n â”Š 7â”Š11â”Š    describe(\"given inranged rad\", function() {\n â”Š 8â”Š12â”Š      it(\"returns x\", function() {\n```\n```diff\n@@ -64,6 +68,8 @@\n â”Š64â”Š68â”Š          { x: -2, y: -3 },\n â”Š65â”Š69â”Š          { x: -2, y: 5 }\n â”Š66â”Š70â”Š        ]);\n+â”Š  â”Š71â”Š\n+â”Š  â”Š72â”Š        circle.delete();\n â”Š67â”Š73â”Š      });\n â”Š68â”Š74â”Š    });\n â”Š69â”Š75â”Š\n```\n```diff\n@@ -74,6 +80,8 @@\n â”Š74â”Š80â”Š        expect(this.circle.getCircleIntersection(circle)).toEqual([\n â”Š75â”Š81â”Š          { x: -2, y: 5 }\n â”Š76â”Š82â”Š        ]);\n+â”Š  â”Š83â”Š\n+â”Š  â”Š84â”Š        circle.delete();\n â”Š77â”Š85â”Š      });\n â”Š78â”Š86â”Š    });\n â”Š79â”Š87â”Š\n```\n```diff\n@@ -84,6 +92,8 @@\n â”Š84â”Š92â”Š        expect(this.circle.getCircleIntersection(circle)).toEqual([\n â”Š85â”Š93â”Š          { x: -4, y: 1 }\n â”Š86â”Š94â”Š        ]);\n+â”Š  â”Š95â”Š\n+â”Š  â”Š96â”Š        circle.delete();\n â”Š87â”Š97â”Š      });\n â”Š88â”Š98â”Š    });\n â”Š89â”Š99â”Š\n```\n```diff\n@@ -91,6 +101,7 @@\n â”Š 91â”Š101â”Š      it(\"returns nothing\", function() {\n â”Š 92â”Š102â”Š        let circle = new Engine.Geometry.Circle(10, 10, 2, 0, 2 * Math.PI);\n â”Š 93â”Š103â”Š        expect(this.circle.getCircleIntersection(circle)).toBeUndefined();\n+â”Š   â”Š104â”Š        circle.delete();\n â”Š 94â”Š105â”Š      });\n â”Š 95â”Š106â”Š    });\n â”Š 96â”Š107â”Š\n```\n```diff\n@@ -98,6 +109,7 @@\n â”Š 98â”Š109â”Š      it(\"nothing\", function() {\n â”Š 99â”Š110â”Š        let circle = new Engine.Geometry.Circle(1, 1, 2, 0, 2 * Math.PI);\n â”Š100â”Š111â”Š        expect(this.circle.getCircleIntersection(circle)).toBeUndefined();\n+â”Š   â”Š112â”Š        circle.delete();\n â”Š101â”Š113â”Š      });\n â”Š102â”Š114â”Š    });\n â”Š103â”Š115â”Š  });\n```\n\n##### Changed resources&#x2F;scripts&#x2F;specs&#x2F;engine&#x2F;geometry&#x2F;polygon.js\n```diff\n@@ -64,6 +64,8 @@\n â”Š64â”Š64â”Š          { x: 2, y: 0 },\n â”Š65â”Š65â”Š          { x: 0, y: 2 }\n â”Š66â”Š66â”Š        ]);\n+â”Š  â”Š67â”Š\n+â”Š  â”Š68â”Š        circle.delete();\n â”Š67â”Š69â”Š      });\n â”Š68â”Š70â”Š    });\n â”Š69â”Š71â”Š\n```\n```diff\n@@ -74,6 +76,8 @@\n â”Š74â”Š76â”Š        expect(this.polygon.getCircleIntersection(circle)).toEqual([\n â”Š75â”Š77â”Š          { x: 2, y: 0 }\n â”Š76â”Š78â”Š        ]);\n+â”Š  â”Š79â”Š\n+â”Š  â”Š80â”Š        circle.delete();\n â”Š77â”Š81â”Š      });\n â”Š78â”Š82â”Š    });\n â”Š79â”Š83â”Š\n```\n```diff\n@@ -84,6 +88,8 @@\n â”Š84â”Š88â”Š        expect(this.polygon.getCircleIntersection(circle)).toEqual([\n â”Š85â”Š89â”Š          { x: 0, y: 3 }\n â”Š86â”Š90â”Š        ]);\n+â”Š  â”Š91â”Š\n+â”Š  â”Š92â”Š        circle.delete();\n â”Š87â”Š93â”Š      });\n â”Š88â”Š94â”Š    });\n â”Š89â”Š95â”Š\n```\n```diff\n@@ -91,6 +97,7 @@\n â”Š 91â”Š 97â”Š      it(\"returns nothing\", function() {\n â”Š 92â”Š 98â”Š        let circle = new Engine.Geometry.Circle(10, 10, 2, 0, 2 * Math.PI);\n â”Š 93â”Š 99â”Š        expect(this.polygon.getCircleIntersection(circle)).toBeUndefined();\n+â”Š   â”Š100â”Š        circle.delete();\n â”Š 94â”Š101â”Š      });\n â”Š 95â”Š102â”Š    });\n â”Š 96â”Š103â”Š\n```\n```diff\n@@ -98,6 +105,7 @@\n â”Š 98â”Š105â”Š      it(\"nothing\", function() {\n â”Š 99â”Š106â”Š        let circle = new Engine.Geometry.Circle(2.5, 2.5, 2, 0, 2 * Math.PI);\n â”Š100â”Š107â”Š        expect(this.polygon.getCircleIntersection(circle)).toBeUndefined();\n+â”Š   â”Š108â”Š        circle.delete();\n â”Š101â”Š109â”Š      });\n â”Š102â”Š110â”Š    });\n â”Š103â”Š111â”Š  });\n```\n\n[}]: #\n\nOur C++ code should be finished now, and all the tests should be passing. The only thing left to do would be applying it to our game. Like any other application, we first need to reference the script file so it can be loaded, in this case, the C++ bundle script:\n\n[{]: <helper> (diffStep 7.24)\n\n#### [Step 7.24: Load CPP bundle in game](https://github.com/DAB0mB/radial-snake/commit/a2c0d46)\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -8,6 +8,7 @@\n â”Š 8â”Š 8â”Š    <script type=\"text/javascript\" src=\"/libs/underscore.js\"></script>\n â”Š 9â”Š 9â”Š\n â”Š10â”Š10â”Š    <!-- Scripts -->\n+â”Š  â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/cpp.bundle.js\"></script>\n â”Š11â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/utils.js\"></script>\n â”Š12â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/geometry/line.js\"></script>\n```\n\n[}]: #\n\nAnd now we need to make sure to dispose the geometry shapes correctly so we won't experience any unnecessary memory leaks. Most of our disposals should go to the snake entity, since it's made out of shapes; So we will add a `delete` method to the snake entity and we will dispose it whenever a match is finished:\n\n[{]: <helper> (diffStep 7.25)\n\n#### [Step 7.25: Delete shape instances in game](https://github.com/DAB0mB/radial-snake/commit/ae58323)\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;game.js\n```diff\n@@ -95,6 +95,7 @@\n â”Š 95â”Š 95â”Š  changeScreen(Screen, ...screenArgs) {\n â”Š 96â”Š 96â”Š    // If there is a screen defined, dispose it first\n â”Š 97â”Š 97â”Š    if (this.screen) {\n+â”Š   â”Š 98â”Š      this.screen.delete();\n â”Š 98â”Š 99â”Š      this.unloadScreen();\n â”Š 99â”Š100â”Š      this.screen.disposeEventListeners();\n â”Š100â”Š101â”Š    }\n```\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;layer.js\n```diff\n@@ -23,6 +23,9 @@\n â”Š23â”Š23â”Š    this.canvas = screen.game.canvas;\n â”Š24â”Š24â”Š  }\n â”Š25â”Š25â”Š\n+â”Š  â”Š26â”Š  delete() {\n+â”Š  â”Š27â”Š  }\n+â”Š  â”Š28â”Š\n â”Š26â”Š29â”Š  update(span) {\n â”Š27â”Š30â”Š  }\n â”Š28â”Š31â”Š\n```\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;screen.js\n```diff\n@@ -28,6 +28,13 @@\n â”Š28â”Š28â”Š    return this;\n â”Š29â”Š29â”Š  }\n â”Š30â”Š30â”Š\n+â”Š  â”Š31â”Š   // Delete all layers. Same as 'unload', only it disposes memory rather than assets\n+â”Š  â”Š32â”Š  delete() {\n+â”Š  â”Š33â”Š    this.layers.forEach(layer => {\n+â”Š  â”Š34â”Š      layer.delete();\n+â”Š  â”Š35â”Š    });\n+â”Š  â”Š36â”Š  }\n+â”Š  â”Š37â”Š\n â”Š31â”Š38â”Š  // Updates each layer\n â”Š32â”Š39â”Š  update(span) {\n â”Š33â”Š40â”Š    this.layers.forEach(layer => {\n```\n```diff\n@@ -61,6 +68,7 @@\n â”Š61â”Š68â”Š  removeLayer(layer) {\n â”Š62â”Š69â”Š    this.layers = _.without(this.layers, layer);\n â”Š63â”Š70â”Š    layer.disposeEventListeners();\n+â”Š  â”Š71â”Š    layer.delete();\n â”Š64â”Š72â”Š  }\n â”Š65â”Š73â”Š\n â”Š66â”Š74â”Š  initEventListeners() {\n```\n\n##### Changed resources&#x2F;scripts&#x2F;game&#x2F;entities&#x2F;snake.js\n```diff\n@@ -31,6 +31,10 @@\n â”Š31â”Š31â”Š    }\n â”Š32â”Š32â”Š  }\n â”Š33â”Š33â”Š\n+â”Š  â”Š34â”Š  delete() {\n+â”Š  â”Š35â”Š    this.shapes.forEach(shape => shape.delete());\n+â”Š  â”Š36â”Š  }\n+â”Š  â”Š37â”Š\n â”Š34â”Š38â”Š  draw(context) {\n â”Š35â”Š39â”Š    // Draw all shapes in the shapes array\n â”Š36â”Š40â”Š    this.shapes.forEach(shape => {\n```\n```diff\n@@ -229,6 +233,8 @@\n â”Š229â”Š233â”Š      [0, height, 0, 0]\n â”Š230â”Š234â”Š    );\n â”Š231â”Š235â”Š\n-â”Š232â”Š   â”Š    return canvasPolygon.getIntersection(this.lastBit);\n+â”Š   â”Š236â”Š    let result = canvasPolygon.getIntersection(this.lastBit);\n+â”Š   â”Š237â”Š    canvasPolygon.delete();\n+â”Š   â”Š238â”Š    return result;\n â”Š233â”Š239â”Š  }\n â”Š234â”Š240â”Š};ðŸš«â†µ\n```\n\n##### Changed resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;play&#x2F;snake.js\n```diff\n@@ -43,6 +43,10 @@\n â”Š43â”Š43â”Š    screen.appendLayer(Game.Screens.Play.Score, this.snakes);\n â”Š44â”Š44â”Š  }\n â”Š45â”Š45â”Š\n+â”Š  â”Š46â”Š  unload() {\n+â”Š  â”Š47â”Š    this.snakes.forEach(snake => snake.delete());\n+â”Š  â”Š48â”Š  }\n+â”Š  â”Š49â”Š\n â”Š46â”Š50â”Š  draw(context) {\n â”Š47â”Š51â”Š    // Draw each snake in the snakes array\n â”Š48â”Š52â”Š    this.snakes.forEach(snake => snake.draw(context));\n```\n\n[}]: #\n\nCongratulations! You've created a C++ cross JavaScript game. There shouldn't be any significant difference between the C++ version of the game and the JavaScript version on most machines, since the game is very small and barely requires any processing power. You'll probably notice the difference when starting to extend the game by adding terrains or more snakes.\n\nOne might ask - \"How much faster does my game actually run?\". The short answer is - around 50%. Why did I run into this conclusion? Well, take a look at the following JavaScript code snippet, for calculating Fibonacci of 42:\n\n```js\nfunction fib(x) {\n  if (x < 2) {\n    return 1;\n  }\n  else {\n    return fib(x - 1) + fib(x - 2);\n  }\n}\n```\n\nThe same code snippet should look almost identical written in C++:\n\n```cpp\nint fib(int x) {\n  if (x < 2) {\n    return 1;\n  }\n  else {\n    return fib(x - 1) + fib(x - 2);\n  }\n}\n```\n\nHowever, the run-times are completely different! I compared the average of 10 runs in 3 different environments, and I received the following results:\n\n![chart](https://cloud.githubusercontent.com/assets/7648874/22802494/2591025e-eef8-11e6-9679-10b5bca0ef30.png)\n\nAs you can see, the generated C++ is much faster, and to be precise, 57% faster! Surprisingly, I didn't have any significant difference between Emscripten generated C++ and natively compiled executable.\n\nC++ is more complex to write, but it certainly has its advantages over JavaScript. Remember, now that you know that you have the possibility to run C++ in the browser, make sure to use it, but never overdo it, always find the right balance between readability and performance.\n\n> *Sources:*\n> - *https://kripken.github.io/emscripten-site/docs/introducing_emscripten/index.html*\n> - *http://www.crunchy.com/?q=content/emscripten-perfectly-cromulent-compiler*\n> - *http://stackoverflow.com/questions/2354725/what-exactly-is-llvm*"
          }
        ]
      },
      {
        "releaseVersion": "0.1.4",
        "releaseDate": "2018-06-20 18:45:34 +0800",
        "tagName": "master@0.1.4",
        "tagRevision": "15f35e435e0099d9abdbb3eb2c633cba8bbe12ed",
        "historyRevision": "06644498e39f4fbc3696173073c131860aa2d097",
        "changesDiff": "",
        "manuals": [
          {
            "manualTitle": "How to implement a game engine in JavaScript and build a Tron-style game",
            "stepRevision": "08b88f5a9d7b2d3ba4c8a67a1433218ef6a6a3a5",
            "manualView": "![snake-demo-full-small](https://cloud.githubusercontent.com/assets/7648874/21073892/ae331a8a-bed2-11e6-9141-9554f9bb808b.gif)\n\nThis tutorial will guide you through the following steps:\n\n- [**Step 1**](https://github.com/DAB0mB/radial-snake/blob/master/.tortilla/manuals/views/step1.md) - Creating a server\n- [**Step 2**](https://github.com/DAB0mB/radial-snake/blob/master/.tortilla/manuals/views/step2.md) - Creating a game engine basis\n- [**Step 3**](https://github.com/DAB0mB/radial-snake/blob/master/.tortilla/manuals/views/step3.md) - Creating a splash screen using a keyframe animation engine\n- [**Step 4**](https://github.com/DAB0mB/radial-snake/blob/master/.tortilla/manuals/views/step4.md) - Creating a main menu screen using a font engine\n- [**Step 5**](https://github.com/DAB0mB/radial-snake/blob/master/.tortilla/manuals/views/step5.md) - Creating a snake and related geometry shapes\n- [**Step 6**](https://github.com/DAB0mB/radial-snake/blob/master/.tortilla/manuals/views/step6.md) - Creating a complex game screen with multiple layers\n- [**Step 7**](https://github.com/DAB0mB/radial-snake/blob/master/.tortilla/manuals/views/step7.md) - Bonus! Re-implementing geometry in C++\n\nMake sure you have the following software installed:\n\n- NodeJS with an ECMAScript 2015 support (v6.0.0 and above).\n- Any web-browser which supports ECMAScript 2015, with a preference for Google Chrome.\n\n> The final project is a hybrid of C++ and JavaScript. A JavaScript **only** version of this tutorial is available [here](https://github.com/DAB0mB/radial-snake/tree/master%40step6%400.1.3).\n\nThis tutorial is mostly based on pure JavaScript, so people can have a deeper understanding of the language and its dynamics. In addition, this tutorial makes a great practice on how to build a nice architecture for complex systems, which can then be expanded and maintained with ease. Yes, it is specifically designed for games, but I truly believe that video games can easily get messed up if not planned and designed properly in terms of object oriented relationships. They are naturally more complicated then any web-app you gonna see out there, so if you can create a game engine and understand its flow, creating a web-app would be a piece of cake for you. By the end of this tutorial, your general sense for programming should be enhanced greatly.\n\nSo hopefully that I got you pumped up by now, let's get started!"
          },
          {
            "manualTitle": "Step 1: Creating a server",
            "stepRevision": "1aed2194c509617dbe79447e2615aa34728262bc",
            "manualView": "The first thing we will learn to do would be creating a server so we can serve our assets. We will be using [HapiJS](https://hapijs.com/) to build a REST API, although this step can be implemented with any library you'd want, like [ExpressJS](http://expressjs.com/) or [Connect](https://www.senchalabs.github.com/connect) etc. Let's install it then:\n\n    $ npm install hapi --save\n\nWe will start by setting up a basis for our server, and we will expand it as we go further in this step. A general boiler plate should look like so:\n\n[{]: <helper> (diffStep 1.2)\n\n#### [Step 1.2: Add server basis](https://github.com/DAB0mB/radial-snake/commit/8ff8805)\n\n##### Added server.js\n```diff\n@@ -0,0 +1,36 @@\n+â”Š  â”Š 1â”Šconst Hapi = require(\"hapi\");\n+â”Š  â”Š 2â”Š\n+â”Š  â”Š 3â”Šlet port = 8000;\n+â”Š  â”Š 4â”Š\n+â”Š  â”Š 5â”Š// Initialize a new server\n+â”Š  â”Š 6â”Šlet server = new Hapi.Server();\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Šserver.connection({ port: process.env.PORT || port });\n+â”Š  â”Š 9â”Š\n+â”Š  â”Š10â”Š// Report each response made\n+â”Š  â”Š11â”Šserver.ext(\"onPreResponse\", (req, rep) => {\n+â”Š  â”Š12â”Š  let res = req.response;\n+â”Š  â”Š13â”Š\n+â”Š  â”Š14â”Š  console.log(\"Outcoming response:\");\n+â”Š  â”Š15â”Š  console.log(`in: ${new Date}`);\n+â”Š  â”Š16â”Š  console.log(`to: ${req.info.remoteAddress}`);\n+â”Š  â”Š17â”Š  console.log(`method: ${req.method}`);\n+â”Š  â”Š18â”Š  console.log(`url: ${req.url.path}`);\n+â”Š  â”Š19â”Š  console.log(`status: ${res.statusCode || res.output.statusCode}`);\n+â”Š  â”Š20â”Š  console.log();\n+â”Š  â”Š21â”Š\n+â”Š  â”Š22â”Š  rep.continue();\n+â”Š  â”Š23â”Š});\n+â”Š  â”Š24â”Š\n+â”Š  â”Š25â”Š// Print message once started\n+â”Š  â”Š26â”Šserver.start((err) => {\n+â”Š  â”Š27â”Š  if (err) throw err;\n+â”Š  â”Š28â”Š\n+â”Š  â”Š29â”Š  console.log();\n+â”Š  â”Š30â”Š  console.log(\"---------- -------- ------ ---- --\");\n+â”Š  â”Š31â”Š  console.log(\"----- ---- --- -- -\");\n+â”Š  â”Š32â”Š  console.log(`Server running at ${port}`);\n+â”Š  â”Š33â”Š  console.log(\"----- ---- --- -- -\");\n+â”Š  â”Š34â”Š  console.log(\"---------- -------- ------ ---- --\");\n+â”Š  â”Š35â”Š  console.log();\n+â”Š  â”Š36â”Š});ðŸš«â†µ\n```\n\n[}]: #\n\nWe simply initialize a new server which will connect to port `8000` by default, unless we defined an environment variable called `PORT`. Once the server is started, and whenever there is an outcoming response, a message will be printed to the console.\n\n> More information and configuration options regards HapiJS's API can be found in this [here](https://hapijs.com/).\n\nNow that the basis is ready, we want a convenient way to launch it. Repetitive scripts are usually defined in the `package.json` file under the `scripts` field. To start the server, we gonna create a simple script called `serve`:\n\n[{]: <helper> (diffStep 1.3)\n\n#### [Step 1.3: Add serve npm script](https://github.com/DAB0mB/radial-snake/commit/6e7d691)\n\n##### Changed package.json\n```diff\n@@ -6,6 +6,9 @@\n â”Š 6â”Š 6â”Š    \"url\": \"https://DAB0mB@github.com/DAB0mB/radial-snake.git\"\n â”Š 7â”Š 7â”Š  },\n â”Š 8â”Š 8â”Š  \"private\": true,\n+â”Š  â”Š 9â”Š  \"scripts\": {\n+â”Š  â”Š10â”Š    \"serve\": \"node server.js\"\n+â”Š  â”Š11â”Š  },\n â”Š 9â”Š12â”Š  \"dependencies\": {\n â”Š10â”Š13â”Š    \"hapi\": \"^16.0.1\"\n â”Š11â”Š14â”Š  }\n```\n\n[}]: #\n\nTo run this script, we will simply need to type the following:\n\n    $ npm run serve\n\nThis will run our server, and you should see the following message printed to the console:\n\n```\n---------- -------- ------ ---- --\n----- ---- --- -- -\nServer running at 8000\n----- ---- --- -- -\n---------- -------- ------ ---- --\n```\n\n> As for now, nothing happens, because we didn't define any handlers for HTTP requests. I will get to it in a bit, stay with me.\n\nThe main disadvantage of starting a server directly with node is that we have no listeners for changes in our files, so if we want the served files to be updated, we will have to restart our server anytime we make a change. To avoid that, we gonna use [nodemon](https://nodemon.io/), which is a simple utility that can monitor changes is source files and automatically restart our server. To install it, type the following:\n\n    $ sudo npm install nodemon -g\n\nNow that we have it, we will need to update our `serve` npm script to use `nodemon` instead of `node`:\n\n[{]: <helper> (diffStep 1.4)\n\n#### [Step 1.4: Change serve npm script to use nodemon](https://github.com/DAB0mB/radial-snake/commit/a238294)\n\n##### Changed package.json\n```diff\n@@ -7,7 +7,7 @@\n â”Š 7â”Š 7â”Š  },\n â”Š 8â”Š 8â”Š  \"private\": true,\n â”Š 9â”Š 9â”Š  \"scripts\": {\n-â”Š10â”Š  â”Š    \"serve\": \"node server.js\"\n+â”Š  â”Š10â”Š    \"serve\": \"nodemon server.js\"\n â”Š11â”Š11â”Š  },\n â”Š12â”Š12â”Š  \"dependencies\": {\n â”Š13â”Š13â”Š    \"hapi\": \"^16.0.1\"\n```\n\n[}]: #\n\nThe basis for our server is pretty much complete. From now on we gonna build stuff on top of it and extend our server. I'd like to add a small attachment to our server. I want that the IP address of the current computer will be printed to the console once the server is started. For this, we first gonna create a helper which we gonna call `ip_grabber`:\n\n[{]: <helper> (diffStep 1.5)\n\n#### [Step 1.5: Add ip_grabber helper](https://github.com/DAB0mB/radial-snake/commit/8ff1d1c)\n\n##### Added helpers&#x2F;ip_grabber.js\n```diff\n@@ -0,0 +1,23 @@\n+â”Š  â”Š 1â”Šconst Os = require(\"os\");\n+â”Š  â”Š 2â”Š\n+â”Š  â”Š 3â”Š// Grab local IP address of which the NodeJS process runs on\n+â”Š  â”Š 4â”Šfunction local() {\n+â”Š  â”Š 5â”Š  let interfaces = Os.networkInterfaces();\n+â”Š  â”Š 6â”Š  let addresses = [];\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Š  for (let k in interfaces) {\n+â”Š  â”Š 9â”Š    for (let k2 in interfaces[k]) {\n+â”Š  â”Š10â”Š      let address = interfaces[k][k2];\n+â”Š  â”Š11â”Š\n+â”Š  â”Š12â”Š      if (address.family == \"IPv4\" && !address.internal) {\n+â”Š  â”Š13â”Š        addresses.push(address.address);\n+â”Š  â”Š14â”Š      }\n+â”Š  â”Š15â”Š    }\n+â”Š  â”Š16â”Š  }\n+â”Š  â”Š17â”Š\n+â”Š  â”Š18â”Š  return addresses[0];\n+â”Š  â”Š19â”Š}\n+â”Š  â”Š20â”Š\n+â”Š  â”Š21â”Šmodule.exports = {\n+â”Š  â”Š22â”Š  local\n+â”Š  â”Š23â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nThis module simply goes through the available network interfaces and grabs the IP address of the default gateway using the `os` module. Now that we have it, let's import it in the server's entry file and use the `local` method to grab the IP address and report it once the server is started:\n\n[{]: <helper> (diffStep 1.6)\n\n#### [Step 1.6: Print IP address once server is started](https://github.com/DAB0mB/radial-snake/commit/18ed984)\n\n##### Changed server.js\n```diff\n@@ -1,5 +1,7 @@\n â”Š1â”Š1â”Šconst Hapi = require(\"hapi\");\n+â”Š â”Š2â”Šconst IpGrabber = require(\"./helpers/ip_grabber\");\n â”Š2â”Š3â”Š\n+â”Š â”Š4â”Šlet localIp = IpGrabber.local();\n â”Š3â”Š5â”Šlet port = 8000;\n â”Š4â”Š6â”Š\n â”Š5â”Š7â”Š// Initialize a new server\n```\n```diff\n@@ -29,7 +31,7 @@\n â”Š29â”Š31â”Š  console.log();\n â”Š30â”Š32â”Š  console.log(\"---------- -------- ------ ---- --\");\n â”Š31â”Š33â”Š  console.log(\"----- ---- --- -- -\");\n-â”Š32â”Š  â”Š  console.log(`Server running at ${port}`);\n+â”Š  â”Š34â”Š  console.log(`Server running at ${localIp}:${port}`);\n â”Š33â”Š35â”Š  console.log(\"----- ---- --- -- -\");\n â”Š34â”Š36â”Š  console.log(\"---------- -------- ------ ---- --\");\n â”Š35â”Š37â”Š  console.log();\n```\n\n[}]: #\n\nBy now you should have the following message printed to the console once you start the server:\n\n```\n---------- -------- ------ ---- --\n----- ---- --- -- -\nServer running at 95.221.122.30:8000\n----- ---- --- -- -\n---------- -------- ------ ---- --\n```\n\n> Instead of `95.221.122.30` you should have the IP address which is right for you.\n\nNow comes the most important part - handling HTTP requests! Because what does a server worth if it doesn't know how to handle anything? When using `HapiJS`, we can separate extensions to our server in different modules, and eventually register them as plug-ins. So the first plug-in is gonna be the routes batch for the endpoints - it will take care of serving file requests as is, and basically turning local directories into public ones. This is useful because our game is going to be dependent on many assets like textures, images, fonts, and so on... But before I go into the implementation part we first need to install a couple of libraries which will help us with the task. The first one is going to be `async`, which will take care of managing the control flow of asynchronous code:\n\n    $ npm install async --save\n\nAnd the second library is going to be `inert`, which is a `HapiJS` plug-in which will give us the ability to serve files from local directories:\n\n    $ npm install inert --save\n\nNow that we're set, let's implement the `endpoints` routes batch:\n\n[{]: <helper> (diffStep 1.8)\n\n#### [Step 1.8: Add endpoints routes](https://github.com/DAB0mB/radial-snake/commit/9c22408)\n\n##### Added routes&#x2F;endpoints.js\n```diff\n@@ -0,0 +1,80 @@\n+â”Š  â”Š 1â”Šconst Pack = require(\"../package.json\");\n+â”Š  â”Š 2â”Š\n+â”Š  â”Š 3â”Šregister.attributes = {\n+â”Š  â”Š 4â”Š  name: \"endpoints\",\n+â”Š  â”Š 5â”Š  version: Pack.version\n+â”Š  â”Š 6â”Š};\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Šfunction register(server, options, next) {\n+â”Š  â”Š 9â”Š  // Scripts endpoint\n+â”Š  â”Š10â”Š  server.route({\n+â”Š  â”Š11â”Š    method: \"GET\",\n+â”Š  â”Š12â”Š    path: \"/scripts/{path*}\",\n+â”Š  â”Š13â”Š    handler: {\n+â”Š  â”Š14â”Š      directory: {\n+â”Š  â”Š15â”Š        path: \"./resources/scripts/\"\n+â”Š  â”Š16â”Š      }\n+â”Š  â”Š17â”Š    }\n+â”Š  â”Š18â”Š  });\n+â”Š  â”Š19â”Š\n+â”Š  â”Š20â”Š  // Style-sheets endpoint\n+â”Š  â”Š21â”Š  server.route({\n+â”Š  â”Š22â”Š    method: \"GET\",\n+â”Š  â”Š23â”Š    path: \"/styles/{path*}\",\n+â”Š  â”Š24â”Š    handler: {\n+â”Š  â”Š25â”Š      directory: {\n+â”Š  â”Š26â”Š        path: \"./resources/styles/\"\n+â”Š  â”Š27â”Š      }\n+â”Š  â”Š28â”Š    }\n+â”Š  â”Š29â”Š  });\n+â”Š  â”Š30â”Š\n+â”Š  â”Š31â”Š  // Libraries endpoint\n+â”Š  â”Š32â”Š  server.route({\n+â”Š  â”Š33â”Š    method: \"GET\",\n+â”Š  â”Š34â”Š    path: \"/libs/{path*}\",\n+â”Š  â”Š35â”Š    handler: {\n+â”Š  â”Š36â”Š      directory: {\n+â”Š  â”Š37â”Š        path: \"./resources/libs/\"\n+â”Š  â”Š38â”Š      }\n+â”Š  â”Š39â”Š    }\n+â”Š  â”Š40â”Š  });\n+â”Š  â”Š41â”Š\n+â”Š  â”Š42â”Š  // Images endpoint\n+â”Š  â”Š43â”Š  server.route({\n+â”Š  â”Š44â”Š    method: \"GET\",\n+â”Š  â”Š45â”Š    path: \"/images/{path*}\",\n+â”Š  â”Š46â”Š    handler: {\n+â”Š  â”Š47â”Š      directory: {\n+â”Š  â”Š48â”Š        path: \"./resources/images/\"\n+â”Š  â”Š49â”Š      }\n+â”Š  â”Š50â”Š    }\n+â”Š  â”Š51â”Š  });\n+â”Š  â”Š52â”Š\n+â”Š  â”Š53â”Š  // Textures endpoint\n+â”Š  â”Š54â”Š  server.route({\n+â”Š  â”Š55â”Š    method: \"GET\",\n+â”Š  â”Š56â”Š    path: \"/textures/{path*}\",\n+â”Š  â”Š57â”Š    handler: {\n+â”Š  â”Š58â”Š      directory: {\n+â”Š  â”Š59â”Š        path: \"./resources/assets/textures/\"\n+â”Š  â”Š60â”Š      }\n+â”Š  â”Š61â”Š    }\n+â”Š  â”Š62â”Š  });\n+â”Š  â”Š63â”Š\n+â”Š  â”Š64â”Š  // Fonts endpoint\n+â”Š  â”Š65â”Š  server.route({\n+â”Š  â”Š66â”Š    method: \"GET\",\n+â”Š  â”Š67â”Š    path: \"/fonts/{path*}\",\n+â”Š  â”Š68â”Š    handler: {\n+â”Š  â”Š69â”Š      directory: {\n+â”Š  â”Š70â”Š        path: \"./resources/assets/fonts/\"\n+â”Š  â”Š71â”Š      }\n+â”Š  â”Š72â”Š    }\n+â”Š  â”Š73â”Š  });\n+â”Š  â”Š74â”Š\n+â”Š  â”Š75â”Š  next();\n+â”Š  â”Š76â”Š}\n+â”Š  â”Š77â”Š\n+â”Š  â”Š78â”Šmodule.exports = {\n+â”Š  â”Š79â”Š  register\n+â”Š  â”Š80â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nThis module actually represents a classic structure of a `HapiJS` plug-in. It should export a `name` for debugging proposes, a `version`, and a `register` function, which will take care of registering extensions to our server; in this case, these are the endpoints routes. To make this plug-in (Or any other plug-in) work, we need to register it. The registration is an asynchronous operation, thus we gonna handle it using `async`:\n\n[{]: <helper> (diffStep 1.9)\n\n#### [Step 1.9: Register ednpoints routes](https://github.com/DAB0mB/radial-snake/commit/bba460f)\n\n##### Changed server.js\n```diff\n@@ -1,11 +1,23 @@\n+â”Š  â”Š 1â”Šconst Async = require(\"async\");\n â”Š 1â”Š 2â”Šconst Hapi = require(\"hapi\");\n+â”Š  â”Š 3â”Šconst Inert = require(\"inert\");\n+â”Š  â”Š 4â”Šconst Endpoints = require(\"./routes/endpoints\");\n â”Š 2â”Š 5â”Šconst IpGrabber = require(\"./helpers/ip_grabber\");\n â”Š 3â”Š 6â”Š\n â”Š 4â”Š 7â”Šlet localIp = IpGrabber.local();\n â”Š 5â”Š 8â”Šlet port = 8000;\n â”Š 6â”Š 9â”Š\n â”Š 7â”Š10â”Š// Initialize a new server\n-â”Š 8â”Š  â”Šlet server = new Hapi.Server();\n+â”Š  â”Š11â”Šlet server = new Hapi.Server({\n+â”Š  â”Š12â”Š  connections: {\n+â”Š  â”Š13â”Š    routes: {\n+â”Š  â”Š14â”Š      files: {\n+â”Š  â”Š15â”Š        // Served files will be relative to current directory\n+â”Š  â”Š16â”Š        relativeTo: __dirname\n+â”Š  â”Š17â”Š      }\n+â”Š  â”Š18â”Š    }\n+â”Š  â”Š19â”Š  }\n+â”Š  â”Š20â”Š});\n â”Š 9â”Š21â”Š\n â”Š10â”Š22â”Šserver.connection({ port: process.env.PORT || port });\n â”Š11â”Š23â”Š\n```\n```diff\n@@ -24,8 +36,14 @@\n â”Š24â”Š36â”Š  rep.continue();\n â”Š25â”Š37â”Š});\n â”Š26â”Š38â”Š\n+â”Š  â”Š39â”Š// Register all routes and plug-ins\n+â”Š  â”Š40â”ŠAsync.series([\n+â”Š  â”Š41â”Š  next => server.register(Inert, next),\n+â”Š  â”Š42â”Š  next => server.register(Endpoints, next),\n+â”Š  â”Š43â”Š  // Once registrations are finished, start the server\n+â”Š  â”Š44â”Š  next => server.start(next)\n â”Š27â”Š45â”Š// Print message once started\n-â”Š28â”Š  â”Šserver.start((err) => {\n+â”Š  â”Š46â”Š], (err) => {\n â”Š29â”Š47â”Š  if (err) throw err;\n â”Š30â”Š48â”Š\n â”Š31â”Š49â”Š  console.log();\n```\n\n[}]: #\n\nOnce all the plug-ins have been registered, we gonna start our server as we previously did. Note that we also registered the `inert` plug-in, because as I said earlier, that's what gives us the ability to handle files requests.\n\nLastly, I want to create the `pages` routes batch, which will be responsible for serving pages in our application as listed above:\n\n- The `/` route will serve us the `game.html` file.\n- The `/test` route will serve us the `spec_runner.html` file.\n\nBy the name of each route and file you can probably what each one should do. The thing is, we don't want everyone to be able to access the `spec_runner.html` file, or the `game.html` file if in the middle of development. For this, we're going to create a new helper which will be responsible for handling permissions. So first we gonna install an npm package called `boom` which has the ability to format `permission denied` HTTP errors:\n\n    $ npm install boom --save\n\nAnd now we gonna implement the module itself:\n\n[{]: <helper> (diffStep 1.11)\n\n#### [Step 1.11: Add permitter helper](https://github.com/DAB0mB/radial-snake/commit/d26a5d7)\n\n##### Added helpers&#x2F;permitter.js\n```diff\n@@ -0,0 +1,29 @@\n+â”Š  â”Š 1â”Šconst Boom = require(\"boom\");\n+â”Š  â”Š 2â”Šconst Hapi = require(\"hapi\");\n+â”Š  â”Š 3â”Šconst IpGrabber = require(\"./ip_grabber\");\n+â”Š  â”Š 4â”Š\n+â”Š  â”Š 5â”Š// These addresses will be permitted by default\n+â”Š  â”Š 6â”Šconst defaultPermissions = [\n+â”Š  â”Š 7â”Š  IpGrabber.local(), \"127.0.0.1\", \"localhost\"\n+â”Š  â”Š 8â”Š];\n+â”Š  â”Š 9â”Š\n+â”Š  â”Š10â”Š// Manage file permissions\n+â”Š  â”Š11â”Šfunction file(path, permissions, req, rep) {\n+â”Š  â”Š12â”Š  // Apply default permissions\n+â”Š  â”Š13â”Š  permissions = permissions.concat(defaultPermissions);\n+â”Š  â”Š14â”Š  // Request address\n+â”Š  â”Š15â”Š  let remoteAddress = req.info.remoteAddress;\n+â”Š  â”Š16â”Š\n+â”Š  â”Š17â”Š  // If not permitted, reply error\n+â”Š  â”Š18â”Š  if (permissions.indexOf(remoteAddress) == -1) {\n+â”Š  â”Š19â”Š    let err = new Boom.forbidden(\"Missing permissions\");\n+â”Š  â”Š20â”Š    return rep(err);\n+â”Š  â”Š21â”Š  }\n+â”Š  â”Š22â”Š\n+â”Š  â”Š23â”Š  // If permitted, reply file\n+â”Š  â”Š24â”Š  rep.file(path);\n+â”Š  â”Š25â”Š}\n+â”Š  â”Š26â”Š\n+â”Š  â”Š27â”Šmodule.exports = {\n+â”Š  â”Š28â”Š  file\n+â”Š  â”Š29â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nThe default permitted IP address would be the current computer's IP address. Extra IP permissions can be provided with the invocation of the `file` method. If the requesting IP is not listed in the permissions list, an error is gonna be replied instead of the requested file. Now that we have our \"permitter\" ready, let's implement the `pages` routes batch, only we're gonna pass the requests through the black-list, for the reason mentioned above:\n\n[{]: <helper> (diffStep 1.12)\n\n#### [Step 1.12: Add pages routes](https://github.com/DAB0mB/radial-snake/commit/11860e9)\n\n##### Added routes&#x2F;pages.js\n```diff\n@@ -0,0 +1,35 @@\n+â”Š  â”Š 1â”Šconst Hapi = require(\"hapi\");\n+â”Š  â”Š 2â”Šconst Pack = require(\"../package.json\");\n+â”Š  â”Š 3â”Šconst Permitter = require(\"../helpers/permitter\");\n+â”Š  â”Š 4â”Š\n+â”Š  â”Š 5â”Šregister.attributes = {\n+â”Š  â”Š 6â”Š  name: \"pages\",\n+â”Š  â”Š 7â”Š  version: Pack.version\n+â”Š  â”Š 8â”Š};\n+â”Š  â”Š 9â”Š\n+â”Š  â”Š10â”Šfunction register(server, options, next) {\n+â”Š  â”Š11â”Š  server.route({ method: \"GET\", path: \"/\", handler: getGame });\n+â”Š  â”Š12â”Š  server.route({ method: \"GET\", path: \"/test\", handler: getSpecRunner });\n+â”Š  â”Š13â”Š\n+â”Š  â”Š14â”Š  next();\n+â”Š  â”Š15â”Š}\n+â”Š  â”Š16â”Š\n+â”Š  â”Š17â”Š// Serve game page\n+â”Š  â”Š18â”Šfunction getGame(req, rep) {\n+â”Š  â”Š19â”Š  let path = \"./views/game.html\";\n+â”Š  â”Š20â”Š  let permissions = [];\n+â”Š  â”Š21â”Š\n+â”Š  â”Š22â”Š  Permitter.file(path, permissions, req, rep);\n+â”Š  â”Š23â”Š}\n+â”Š  â”Š24â”Š\n+â”Š  â”Š25â”Š// Serve test page\n+â”Š  â”Š26â”Šfunction getSpecRunner(req, rep) {\n+â”Š  â”Š27â”Š  let path = \"./views/spec_runner.html\";\n+â”Š  â”Š28â”Š  let permissions = [];\n+â”Š  â”Š29â”Š\n+â”Š  â”Š30â”Š  Permitter.file(path, permissions, req, rep);\n+â”Š  â”Š31â”Š}\n+â”Š  â”Š32â”Š\n+â”Š  â”Š33â”Šmodule.exports = {\n+â”Š  â”Š34â”Š  register\n+â”Š  â”Š35â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nNow the only thing left to do would be registering the plug-in we've just created:\n\n[{]: <helper> (diffStep 1.13)\n\n#### [Step 1.13: Register pages routes](https://github.com/DAB0mB/radial-snake/commit/ed50bef)\n\n##### Changed server.js\n```diff\n@@ -2,6 +2,7 @@\n â”Š2â”Š2â”Šconst Hapi = require(\"hapi\");\n â”Š3â”Š3â”Šconst Inert = require(\"inert\");\n â”Š4â”Š4â”Šconst Endpoints = require(\"./routes/endpoints\");\n+â”Š â”Š5â”Šconst Pages = require(\"./routes/pages\");\n â”Š5â”Š6â”Šconst IpGrabber = require(\"./helpers/ip_grabber\");\n â”Š6â”Š7â”Š\n â”Š7â”Š8â”Šlet localIp = IpGrabber.local();\n```\n```diff\n@@ -40,6 +41,7 @@\n â”Š40â”Š41â”ŠAsync.series([\n â”Š41â”Š42â”Š  next => server.register(Inert, next),\n â”Š42â”Š43â”Š  next => server.register(Endpoints, next),\n+â”Š  â”Š44â”Š  next => server.register(Pages, next),\n â”Š43â”Š45â”Š  // Once registrations are finished, start the server\n â”Š44â”Š46â”Š  next => server.start(next)\n â”Š45â”Š47â”Š// Print message once started\n```\n\n[}]: #\n\nAnd that's it for the current step! In the next steps we will start storing files and assets in our public directories and implement all the necessary scripts, so our server is not running in vain."
          },
          {
            "manualTitle": "Step 2: Creating a game engine basis",
            "stepRevision": "a3e901039dc5db535111da14305175182f9f346c",
            "manualView": "Like any other JavaScript-based application, we should have an entry view written in HTML. However, in our application, the only visible element is going to be an [HTMLCanvas](https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API). The canvas is exactly what it sounds like - a blank white surface which we can draw things on top of it. As we go further with this tutorial, we will learn more about the canvas and dive into its API and how to use it. Now that you got the general idea, let's create the HTML file:\n\n[{]: <helper> (diffStep 2.1)\n\n#### [Step 2.1: Create basic game view](https://github.com/DAB0mB/radial-snake/commit/254f06f)\n\n##### Added views&#x2F;game.html\n```diff\n@@ -0,0 +1,10 @@\n+â”Š  â”Š 1â”Š<!DOCTYPE html>\n+â”Š  â”Š 2â”Š<html>\n+â”Š  â”Š 3â”Š  <head>\n+â”Š  â”Š 4â”Š    <title>radial snake</title>\n+â”Š  â”Š 5â”Š  </head>\n+â”Š  â”Š 6â”Š\n+â”Š  â”Š 7â”Š  <body>\n+â”Š  â”Š 8â”Š    <canvas id=\"gameCanvas\" tabindex=\"0\"></canvas>\n+â”Š  â”Š 9â”Š  </body>\n+â”Š  â”Š10â”Š</html>ðŸš«â†µ\n```\n\n[}]: #\n\nIn the previous step we've already set the route for this file, so if you'd like to run the game, simply start the server by typing `npm run serve`, and navigate to the address presented on the screen (Should be `localhost:8000` by default).\n\n> From now on I'm going to assume the server is running in the background, so I won't repeat the instruction above\n\nJust to make sure that the canvas is visible and not blended into the background, we will draw a black border around using a simple style-sheet:\n\n[{]: <helper> (diffStep 2.2)\n\n#### [Step 2.2: Create basic game stylesheet](https://github.com/DAB0mB/radial-snake/commit/44fe5aa)\n\n##### Added resources&#x2F;styles&#x2F;game.css\n```diff\n@@ -0,0 +1,6 @@\n+â”Š â”Š1â”Š#gameCanvas {\n+â”Š â”Š2â”Š  display: block;\n+â”Š â”Š3â”Š  margin: auto;\n+â”Š â”Š4â”Š  border-style: solid;\n+â”Š â”Š5â”Š  border-width: 1px;\n+â”Š â”Š6â”Š}ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -2,6 +2,9 @@\n â”Š 2â”Š 2â”Š<html>\n â”Š 3â”Š 3â”Š  <head>\n â”Š 4â”Š 4â”Š    <title>radial snake</title>\n+â”Š  â”Š 5â”Š\n+â”Š  â”Š 6â”Š    <!-- Styles -->\n+â”Š  â”Š 7â”Š    <link rel=\"stylesheet\" type=\"text/css\" href=\"/styles/game.css\">\n â”Š 5â”Š 8â”Š  </head>\n â”Š 6â”Š 9â”Š\n â”Š 7â”Š10â”Š  <body>\n```\n\n[}]: #\n\n> Note that every asset we create should be declared in the HTML file in order for it to take effect\n\nTo build this project we're also gonna use two very famous utility libraries called [JQuery](http://jquery.com/) and [Underscore](http://underscorejs.org/) which will make our lives a bit easier. Third-party libraries should be located in a directory called `libs`, according to the routes-map we created in the previous step. To set these libraries up, type the following commands in series:\n\n    resources$ mkdir libs\n    resources$ cd libs\n    resources/libs$ wget raw.githubusercontent.com/dab0mb/radial-snake/master/resources/libs/underscore.js\n    resources/libs$ wget raw.githubusercontent.com/dab0mb/radial-snake/master/resources/libs/jquery-2.1.1.js\n\nAnd load them in the game's HTML file's header:\n\n[{]: <helper> (diffStep 2.3 files=\"views/game.html\")\n\n#### [Step 2.3: Add jquery and underscore libs](https://github.com/DAB0mB/radial-snake/commit/085ca6b)\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -3,6 +3,10 @@\n â”Š 3â”Š 3â”Š  <head>\n â”Š 4â”Š 4â”Š    <title>radial snake</title>\n â”Š 5â”Š 5â”Š\n+â”Š  â”Š 6â”Š    <!-- Libs -->\n+â”Š  â”Š 7â”Š    <script type=\"text/javascript\" src=\"/libs/jquery-2.1.1.js\"></script>\n+â”Š  â”Š 8â”Š    <script type=\"text/javascript\" src=\"/libs/underscore.js\"></script>\n+â”Š  â”Š 9â”Š\n â”Š 6â”Š10â”Š    <!-- Styles -->\n â”Š 7â”Š11â”Š    <link rel=\"stylesheet\" type=\"text/css\" href=\"/styles/game.css\">\n â”Š 8â”Š12â”Š  </head>\n```\n\n[}]: #\n\nNow, we're finally going to build the game engine. At first, it's gonna be very basic simple, but further in this tutorial we're going to extend it and add some pretty neat features. When creating an application, of any kind, you don't want to garbage the global scope, so it can stay clean without any conflicts. Therefore, we're going to create an initial namespace for our game engine called `Engine`, which is going to contain all our game engine's classes and entities:\n\n[{]: <helper> (diffStep 2.4)\n\n#### [Step 2.4: Add engine namespace](https://github.com/DAB0mB/radial-snake/commit/3d52525)\n\n##### Added resources&#x2F;scripts&#x2F;namespaces.js\n```diff\n@@ -0,0 +1 @@\n+â”Š â”Š1â”ŠEngine = {};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -7,6 +7,9 @@\n â”Š 7â”Š 7â”Š    <script type=\"text/javascript\" src=\"/libs/jquery-2.1.1.js\"></script>\n â”Š 8â”Š 8â”Š    <script type=\"text/javascript\" src=\"/libs/underscore.js\"></script>\n â”Š 9â”Š 9â”Š\n+â”Š  â”Š10â”Š    <!-- Scripts -->\n+â”Š  â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n+â”Š  â”Š12â”Š\n â”Š10â”Š13â”Š    <!-- Styles -->\n â”Š11â”Š14â”Š    <link rel=\"stylesheet\" type=\"text/css\" href=\"/styles/game.css\">\n â”Š12â”Š15â”Š  </head>\n```\n\n[}]: #\n\nThe first thing we're going to define in the namespace we've just created would be the game loop. The game loop is the central code of your game, split into different parts. Generally, these are: update and draw.\n\nThe main purpose of the update phase is to prepare all objects to be drawn, so this is where all the geometry code, coordinate updates, score changes, animation refreshments and other similar operations belong. This is also where the input will be captured and processed.\n\nWhen everything is properly updated and ready, we enter the draw phase where all this information is put on the screen. This function should contain all the code to manage and draw the levels, shapes, score board and so on.\n\n![game-loop](https://cloud.githubusercontent.com/assets/7648874/21332964/4b80ef4e-c633-11e6-946a-0c5870d2f9c9.png)\n\n> You can find plenty of details and information about what \"game loop\" means simply by typing in on Google.\n\nA game loop can wear many forms, but the concept is gonna be the same, plus-minus. This is how our game loop is going to loop like:\n\n[{]: <helper> (diffStep 2.5)\n\n#### [Step 2.5: Create a game basis](https://github.com/DAB0mB/radial-snake/commit/1b7fcf9)\n\n##### Added resources&#x2F;scripts&#x2F;engine&#x2F;game.js\n```diff\n@@ -0,0 +1,99 @@\n+â”Š  â”Š 1â”ŠEngine.Game = class Game {\n+â”Š  â”Š 2â”Š  // The frequency of which each frame will be drawn in milliseconds\n+â”Š  â”Š 3â”Š  get fps() {\n+â”Š  â”Š 4â”Š    return 1000 / 60;\n+â”Š  â”Š 5â”Š  }\n+â”Š  â”Š 6â”Š\n+â”Š  â”Š 7â”Š  // Game's run speed.\n+â”Š  â”Š 8â”Š  // A lower value will make it run slower and a higher value will make it run faster\n+â”Š  â”Š 9â”Š  get speed() {\n+â”Š  â”Š10â”Š    return 1;\n+â”Š  â”Š11â”Š  }\n+â”Š  â”Š12â”Š\n+â”Š  â”Š13â”Š  constructor(canvas) {\n+â”Š  â”Š14â”Š    this.canvas = canvas;\n+â”Š  â”Š15â”Š    this.lastUpdate = this.creation = new Date().getTime();\n+â”Š  â”Š16â”Š\n+â”Š  â”Š17â”Š    // Canvas dimensions must be set programmatically otherwise you might encounter some\n+â”Š  â”Š18â”Š    // unexpected behaviors\n+â”Š  â”Š19â”Š    canvas.width = 1280;\n+â”Š  â”Š20â”Š    canvas.height = 720;\n+â”Š  â”Š21â”Š    // Canvas will be focused once game page is loaded so all events will automatically\n+â”Š  â”Š22â”Š    // be captured by it\n+â”Š  â”Š23â”Š    canvas.focus();\n+â”Š  â”Š24â”Š\n+â”Š  â”Š25â”Š    // We want to focus on the canvas once we press on it\n+â”Š  â”Š26â”Š    canvas.addEventListener(\"mousedown\", canvas.focus.bind(canvas), false);\n+â”Š  â”Š27â”Š\n+â”Š  â”Š28â”Š    this.assets = {};\n+â”Š  â”Š29â”Š    this.events = new Map();\n+â”Š  â”Š30â”Š    this.context = canvas.getContext(\"2d\");\n+â”Š  â”Š31â”Š    this.bufferedCanvas = document.createElement(\"canvas\");\n+â”Š  â”Š32â”Š    this.bufferedContext = this.bufferedCanvas.getContext(\"2d\");\n+â”Š  â”Š33â”Š    this.bufferedCanvas.width = canvas.width;\n+â”Š  â”Š34â”Š    this.bufferedCanvas.height = canvas.height;\n+â”Š  â”Š35â”Š  }\n+â”Š  â”Š36â”Š\n+â”Š  â”Š37â”Š  draw() {\n+â”Š  â”Š38â”Š    // Draw a black screen by default\n+â”Š  â”Š39â”Š    this.context.restore();\n+â”Š  â”Š40â”Š    this.context.fillStyle = \"black\";\n+â”Š  â”Š41â”Š    this.context.save();\n+â”Š  â”Š42â”Š    this.context.beginPath();\n+â”Š  â”Š43â”Š    this.context.rect(0, 0, this.canvas.width, this.canvas.height);\n+â”Š  â”Š44â”Š    this.context.fill();\n+â”Š  â”Š45â”Š  }\n+â”Š  â”Š46â”Š\n+â”Š  â”Š47â”Š  update() {\n+â”Š  â”Š48â”Š    // Calculate the time elapsed\n+â”Š  â”Š49â”Š    let lastUpdate = this.lastUpdate;\n+â”Š  â”Š50â”Š    let currUpdate = this.lastUpdate = new Date().getTime();\n+â”Š  â”Š51â”Š    let span = currUpdate - lastUpdate;\n+â”Š  â”Š52â”Š    this.updateScreen(span / this.speed);\n+â”Š  â”Š53â”Š  }\n+â”Š  â”Š54â”Š\n+â”Š  â”Š55â”Š  // The main loop of the game\n+â”Š  â”Š56â”Š  loop() {\n+â”Š  â”Š57â”Š    // If paused, don't run loop. The canvas will remain as is\n+â”Š  â”Š58â”Š    if (!this.playing) return;\n+â”Š  â”Š59â”Š\n+â”Š  â”Š60â”Š    setTimeout(() => {\n+â”Š  â”Š61â”Š      this.draw();\n+â”Š  â”Š62â”Š      this.update();\n+â”Š  â”Š63â”Š      this.loop();\n+â”Š  â”Š64â”Š    }, this.fps);\n+â”Š  â”Š65â”Š  }\n+â”Š  â”Š66â”Š\n+â”Š  â”Š67â”Š  play() {\n+â”Š  â”Š68â”Š    this.playing = true;\n+â”Š  â”Š69â”Š    this.loop();\n+â”Š  â”Š70â”Š  }\n+â”Š  â”Š71â”Š\n+â”Š  â”Š72â”Š  pause() {\n+â”Š  â”Š73â”Š    this.playing = false;\n+â”Š  â”Š74â”Š  }\n+â”Š  â”Š75â”Š\n+â”Š  â”Š76â”Š  // Defines global assets\n+â”Š  â”Š77â”Š  extendAssets(assets) {\n+â”Š  â”Š78â”Š    _.extend(this.assets, assets);\n+â”Š  â”Š79â”Š  }\n+â”Š  â”Š80â”Š\n+â”Š  â”Š81â”Š  // Disposes global assets\n+â”Š  â”Š82â”Š  clearAssets() {\n+â”Š  â”Š83â”Š    this.assets = {};\n+â”Š  â”Š84â”Š  }\n+â”Š  â”Š85â”Š\n+â”Š  â”Š86â”Š  // Adds event listener for game canvas\n+â”Š  â”Š87â”Š  addEventListener(type, listener, target) {\n+â”Š  â”Š88â”Š    let boundListener = listener.bind(target);\n+â”Š  â”Š89â”Š    this.events.set(listener, boundListener);\n+â”Š  â”Š90â”Š    this.canvas.addEventListener(type, boundListener, false);\n+â”Š  â”Š91â”Š  }\n+â”Š  â”Š92â”Š\n+â”Š  â”Š93â”Š  // Removes event listener from game canvas\n+â”Š  â”Š94â”Š  removeEventListener(type, listener) {\n+â”Š  â”Š95â”Š    let boundListener = this.events.get(listener);\n+â”Š  â”Š96â”Š    this.events.delete(listener);\n+â”Š  â”Š97â”Š    this.canvas.removeEventListener(type, boundListener, false);\n+â”Š  â”Š98â”Š  }\n+â”Š  â”Š99â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -9,6 +9,7 @@\n â”Š 9â”Š 9â”Š\n â”Š10â”Š10â”Š    <!-- Scripts -->\n â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n+â”Š  â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š12â”Š13â”Š\n â”Š13â”Š14â”Š    <!-- Styles -->\n â”Š14â”Š15â”Š    <link rel=\"stylesheet\" type=\"text/css\" href=\"/styles/game.css\">\n```\n\n[}]: #\n\nThe only thing it's doing right now is drawing a black background, but we're soon going to learn how to take advantage of this game-loop to draw stuff of our own. I'd like to point out that there is no need to implement a [double-buffer](https://en.wikipedia.org/wiki/Multiple_buffering) (A method similar to React's [virtual DOM](https://www.npmjs.com/package/react-dom)) when it comes to `HTMLCanvas` elements, since `HTML5` already does that for us. To start running the game, we first need to wait for the DOM content to initialize, and once it's ready we gonna create a new game instance and call the `play` method:\n\n[{]: <helper> (diffStep 2.6)\n\n#### [Step 2.6: Create game entry point](https://github.com/DAB0mB/radial-snake/commit/30e75df)\n\n##### Added resources&#x2F;scripts&#x2F;main.js\n```diff\n@@ -0,0 +1,4 @@\n+â”Š â”Š1â”Šdocument.addEventListener(\"DOMContentLoaded\", function(event) {\n+â”Š â”Š2â”Š  let game = new Engine.Game(document.getElementById(\"gameCanvas\"), false);\n+â”Š â”Š3â”Š  game.play();\n+â”Š â”Š4â”Š});ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -10,6 +10,7 @@\n â”Š10â”Š10â”Š    <!-- Scripts -->\n â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n â”Š12â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n+â”Š  â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n â”Š13â”Š14â”Š\n â”Š14â”Š15â”Š    <!-- Styles -->\n â”Š15â”Š16â”Š    <link rel=\"stylesheet\" type=\"text/css\" href=\"/styles/game.css\">\n```\n\n[}]: #\n\nThis will take control over the canvas and will draw a new picture every 17ms, which is 60fps (Frames per second). As for now you're only going to see a black canvas, but I promise the final result is not going to disappoint you.\n\nThe next thing we're gonna do would be adding a 'key state' manager, which will store a flag for each key pressed on the keyboard. Once we press the key, the flag's value would be `true`, and once we release it, its value would turn into `false`. This way we have an easy way to track all the key presses without registering a specific event listener for each key press we wanna track:\n\n[{]: <helper> (diffStep 2.7)\n\n#### [Step 2.7: Add key states manager](https://github.com/DAB0mB/radial-snake/commit/831b058)\n\n##### Added resources&#x2F;scripts&#x2F;engine&#x2F;key_states.js\n```diff\n@@ -0,0 +1,20 @@\n+â”Š  â”Š 1â”ŠEngine.KeyStates = class KeyStates {\n+â”Š  â”Š 2â”Š  constructor() {\n+â”Š  â”Š 3â”Š    // We will have 255 states, each one represents an ascii code matching its index\n+â”Š  â”Š 4â”Š    this.states = new Array(255);\n+â”Š  â”Š 5â”Š  }\n+â”Š  â”Š 6â”Š\n+â”Š  â”Š 7â”Š  get(k) {\n+â”Š  â”Š 8â”Š    return this.states[k];\n+â”Š  â”Š 9â”Š  }\n+â”Š  â”Š10â”Š\n+â”Š  â”Š11â”Š  // This should be called once we press a key\n+â”Š  â”Š12â”Š  add(k) {\n+â”Š  â”Š13â”Š    this.states[k] = true;\n+â”Š  â”Š14â”Š  }\n+â”Š  â”Š15â”Š\n+â”Š  â”Š16â”Š  // This should be called once we release a key\n+â”Š  â”Š17â”Š  remove(k) {\n+â”Š  â”Š18â”Š    this.states[k] = false;\n+â”Š  â”Š19â”Š  }\n+â”Š  â”Š20â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -9,6 +9,7 @@\n â”Š 9â”Š 9â”Š\n â”Š10â”Š10â”Š    <!-- Scripts -->\n â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n+â”Š  â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/key_states.js\"></script>\n â”Š12â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n```\n\n[}]: #\n\nNow that we have the key state manager, we will initialize a new instance as part of our game's essentials, and we will create a global event listener for key presses; Each time a key is pressed, the key state manager will update itself:\n\n[{]: <helper> (diffStep 2.8)\n\n#### [Step 2.8: Register key presses](https://github.com/DAB0mB/radial-snake/commit/9f55501)\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;game.js\n```diff\n@@ -14,7 +14,7 @@\n â”Š14â”Š14â”Š    this.canvas = canvas;\n â”Š15â”Š15â”Š    this.lastUpdate = this.creation = new Date().getTime();\n â”Š16â”Š16â”Š\n-â”Š17â”Š  â”Š    // Canvas dimensions must be set programmatically otherwise you might encounter some\n+â”Š  â”Š17â”Š    // Canvas dimensions must be set programmatically, otherwise you might encounter some\n â”Š18â”Š18â”Š    // unexpected behaviors\n â”Š19â”Š19â”Š    canvas.width = 1280;\n â”Š20â”Š20â”Š    canvas.height = 720;\n```\n```diff\n@@ -24,9 +24,13 @@\n â”Š24â”Š24â”Š\n â”Š25â”Š25â”Š    // We want to focus on the canvas once we press on it\n â”Š26â”Š26â”Š    canvas.addEventListener(\"mousedown\", canvas.focus.bind(canvas), false);\n+â”Š  â”Š27â”Š    // Key flags will be registered by the \"KeyStates\" instance\n+â”Š  â”Š28â”Š    canvas.addEventListener(\"keydown\", onKeyDown.bind(this), false);\n+â”Š  â”Š29â”Š    canvas.addEventListener(\"keyup\", onKeyUp.bind(this), false);\n â”Š27â”Š30â”Š\n â”Š28â”Š31â”Š    this.assets = {};\n â”Š29â”Š32â”Š    this.events = new Map();\n+â”Š  â”Š33â”Š    this.keyStates = new Engine.KeyStates();\n â”Š30â”Š34â”Š    this.context = canvas.getContext(\"2d\");\n â”Š31â”Š35â”Š    this.bufferedCanvas = document.createElement(\"canvas\");\n â”Š32â”Š36â”Š    this.bufferedContext = this.bufferedCanvas.getContext(\"2d\");\n```\n```diff\n@@ -96,4 +100,19 @@\n â”Š 96â”Š100â”Š    this.events.delete(listener);\n â”Š 97â”Š101â”Š    this.canvas.removeEventListener(type, boundListener, false);\n â”Š 98â”Š102â”Š  }\n-â”Š 99â”Š   â”Š};ðŸš«â†µ\n+â”Š   â”Š103â”Š};\n+â”Š   â”Š104â”Š\n+â”Š   â”Š105â”Šfunction onKeyDown(e) {\n+â”Š   â”Š106â”Š  // Once we're focused on the canvas, we want nothing else to happen\n+â”Š   â”Š107â”Š  // besides events the game is listening to. For example, when we press\n+â”Š   â”Š108â”Š  // the arrow keys, this will prevent the screen from scrolling\n+â”Š   â”Š109â”Š  e.preventDefault();\n+â”Š   â”Š110â”Š  // Register key press\n+â”Š   â”Š111â”Š  this.keyStates.add(e.keyCode);\n+â”Š   â”Š112â”Š}\n+â”Š   â”Š113â”Š\n+â”Š   â”Š114â”Šfunction onKeyUp(e) {\n+â”Š   â”Š115â”Š  e.preventDefault();\n+â”Š   â”Š116â”Š  // Register key release\n+â”Š   â”Š117â”Š  this.keyStates.remove(e.keyCode);\n+â”Š   â”Š118â”Š}\n```\n\n[}]: #\n\nA 2D game's view might get complex as we go through with its development and add more logic and entities into it. Having only one `draw` method and only one `update` method is not enough, and if you think of it, it might easily get buffed up into ridiculous dimensions, which is not the way to go. I'd like to introduce you into a new methodology which involves `screens` and `layers`:\n\n- **screen** - Will literally be used whenever we want to show a new screen in our game e.g. 'splash' screen and 'main menu' screen. A screen consists of multiple layers, and will be used as their communicator; All the relevant assets and logic will be initialized inside it.\n- **layer** - similar to Photoshop's layer system, any time we want to add something to the view we add new layers on top or beneath of each other.\n\n![screen-layer](https://cloud.githubusercontent.com/assets/7648874/21487708/9b366efe-cbb7-11e6-8669-3212e440871a.png)\n\nAs I said earlier, the purpose of the screens and the layers is just to split the task of updating and drawing and updating, so we can have logical segments; So the `layer` class should mainly consist of a `draw` and an `update` method:\n\n[{]: <helper> (diffStep 2.9)\n\n#### [Step 2.9: Add screen layer](https://github.com/DAB0mB/radial-snake/commit/736ab08)\n\n##### Added resources&#x2F;scripts&#x2F;engine&#x2F;layer.js\n```diff\n@@ -0,0 +1,43 @@\n+â”Š  â”Š 1â”ŠEngine.Layer = class Layer {\n+â”Š  â”Š 2â”Š  // The dimensions of the layer are correlated to dimensions of the canvas\n+â”Š  â”Š 3â”Š  get width() {\n+â”Š  â”Š 4â”Š    return this.canvas.width;\n+â”Š  â”Š 5â”Š  }\n+â”Š  â”Š 6â”Š\n+â”Š  â”Š 7â”Š  get height() {\n+â”Š  â”Š 8â”Š    return this.canvas.height;\n+â”Š  â”Š 9â”Š  }\n+â”Š  â”Š10â”Š\n+â”Š  â”Š11â”Š  // A hash of \"eventName\" : \"handlerName\" which should be overrided by user\n+â”Š  â”Š12â”Š  get events() {\n+â”Š  â”Š13â”Š    return {};\n+â”Š  â”Š14â”Š  }\n+â”Š  â”Š15â”Š\n+â”Š  â”Š16â”Š  constructor(screen) {\n+â”Š  â”Š17â”Š    this.age = 0;\n+â”Š  â”Š18â”Š    this.creation = new Date().getTime();\n+â”Š  â”Š19â”Š    this.screen = screen;\n+â”Š  â”Š20â”Š    this.game = screen.game;\n+â”Š  â”Š21â”Š    this.assets = screen.assets;\n+â”Š  â”Š22â”Š    this.keyStates = screen.keyStates;\n+â”Š  â”Š23â”Š    this.canvas = screen.game.canvas;\n+â”Š  â”Š24â”Š  }\n+â”Š  â”Š25â”Š\n+â”Š  â”Š26â”Š  update(span) {\n+â”Š  â”Š27â”Š  }\n+â”Š  â”Š28â”Š\n+â”Š  â”Š29â”Š  draw(context) {\n+â”Š  â”Š30â”Š  }\n+â”Š  â”Š31â”Š\n+â”Š  â”Š32â”Š  initEventListeners() {\n+â”Š  â”Š33â”Š    _.each(this.events, (listener, event) => {\n+â”Š  â”Š34â”Š      this.game.addEventListener(event, this[listener], this);\n+â”Š  â”Š35â”Š    });\n+â”Š  â”Š36â”Š  }\n+â”Š  â”Š37â”Š\n+â”Š  â”Š38â”Š  disposeEventListeners() {\n+â”Š  â”Š39â”Š    _.each(this.events, (listener, event) => {\n+â”Š  â”Š40â”Š      this.game.removeEventListener(event, this[listener]);\n+â”Š  â”Š41â”Š    });\n+â”Š  â”Š42â”Š  }\n+â”Š  â”Š43â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -10,6 +10,7 @@\n â”Š10â”Š10â”Š    <!-- Scripts -->\n â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n â”Š12â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/key_states.js\"></script>\n+â”Š  â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/layer.js\"></script>\n â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š14â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n```\n\n[}]: #\n\nSame thing for the screen, it only has a `draw` and `update` methods, only it has a stack of layers, which can either be added or removed:\n\n[{]: <helper> (diffStep 2.1)\n\n#### [Step 2.1: Create basic game view](https://github.com/DAB0mB/radial-snake/commit/254f06f)\n\n##### Added views&#x2F;game.html\n```diff\n@@ -0,0 +1,10 @@\n+â”Š  â”Š 1â”Š<!DOCTYPE html>\n+â”Š  â”Š 2â”Š<html>\n+â”Š  â”Š 3â”Š  <head>\n+â”Š  â”Š 4â”Š    <title>radial snake</title>\n+â”Š  â”Š 5â”Š  </head>\n+â”Š  â”Š 6â”Š\n+â”Š  â”Š 7â”Š  <body>\n+â”Š  â”Š 8â”Š    <canvas id=\"gameCanvas\" tabindex=\"0\"></canvas>\n+â”Š  â”Š 9â”Š  </body>\n+â”Š  â”Š10â”Š</html>ðŸš«â†µ\n```\n\n[}]: #\n\nNow that we have the `screen` class available for us, let's apply it to the main game loop:\n\n[{]: <helper> (diffStep 2.11)\n\n#### [Step 2.11: Draw and update screen in game loop](https://github.com/DAB0mB/radial-snake/commit/9f34754)\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;game.js\n```diff\n@@ -30,6 +30,7 @@\n â”Š30â”Š30â”Š\n â”Š31â”Š31â”Š    this.assets = {};\n â”Š32â”Š32â”Š    this.events = new Map();\n+â”Š  â”Š33â”Š    this.screen = new Engine.Screen(this);\n â”Š33â”Š34â”Š    this.keyStates = new Engine.KeyStates();\n â”Š34â”Š35â”Š    this.context = canvas.getContext(\"2d\");\n â”Š35â”Š36â”Š    this.bufferedCanvas = document.createElement(\"canvas\");\n```\n```diff\n@@ -46,6 +47,13 @@\n â”Š46â”Š47â”Š    this.context.beginPath();\n â”Š47â”Š48â”Š    this.context.rect(0, 0, this.canvas.width, this.canvas.height);\n â”Š48â”Š49â”Š    this.context.fill();\n+â”Š  â”Š50â”Š    this.drawScreen(this.context);\n+â”Š  â”Š51â”Š  }\n+â”Š  â”Š52â”Š\n+â”Š  â”Š53â”Š  drawScreen(context) {\n+â”Š  â”Š54â”Š    // If screen's assets are not yet loaded, don't draw it\n+â”Š  â”Š55â”Š    if (this.screen.loading) return;\n+â”Š  â”Š56â”Š    if (this.screen.draw) this.screen.draw(context);\n â”Š49â”Š57â”Š  }\n â”Š50â”Š58â”Š\n â”Š51â”Š59â”Š  update() {\n```\n```diff\n@@ -56,6 +64,13 @@\n â”Š56â”Š64â”Š    this.updateScreen(span / this.speed);\n â”Š57â”Š65â”Š  }\n â”Š58â”Š66â”Š\n+â”Š  â”Š67â”Š  updateScreen(span) {\n+â”Š  â”Š68â”Š    this.screen.age += span;\n+â”Š  â”Š69â”Š    // If screen's assets are not yet loaded, don't update it\n+â”Š  â”Š70â”Š    if (this.screen.loading) return;\n+â”Š  â”Š71â”Š    if (this.screen.update) this.screen.update(span);\n+â”Š  â”Š72â”Š  }\n+â”Š  â”Š73â”Š\n â”Š59â”Š74â”Š  // The main loop of the game\n â”Š60â”Š75â”Š  loop() {\n â”Š61â”Š76â”Š    // If paused, don't run loop. The canvas will remain as is\n```\n\n[}]: #\n\nThis step looks kind of useless for now, unless we will have the ability to change screens as we please. Any time a screen is changed, it should be loaded with its necessary assets e.g textures, sounds, fonts, etc. The assets loading is an asynchronous operation whose logic might get a bit messy if not managed properly. To make it easier, we're going to define an assets loader, which will help us load assets asynchronously:\n\n[{]: <helper> (diffStep 2.12)\n\n#### [Step 2.12: Add assets loader](https://github.com/DAB0mB/radial-snake/commit/d8895f8)\n\n##### Added resources&#x2F;scripts&#x2F;engine&#x2F;assets_loader.js\n```diff\n@@ -0,0 +1,13 @@\n+â”Š  â”Š 1â”ŠEngine.AssetsLoader = class AssetsLoader {\n+â”Š  â”Š 2â”Š  constructor(next) {\n+â”Š  â”Š 3â”Š    this.next = next;\n+â”Š  â”Š 4â”Š  }\n+â”Š  â”Š 5â”Š\n+â”Š  â”Š 6â”Š  // Load texture\n+â”Š  â”Š 7â”Š  texture(path) {\n+â”Š  â”Š 8â”Š    let image = new Image();\n+â”Š  â”Š 9â”Š    image.onload = this.next();\n+â”Š  â”Š10â”Š    image.src = `${path}.png`;\n+â”Š  â”Š11â”Š    return image;\n+â”Š  â”Š12â”Š  }\n+â”Š  â”Š13â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -12,6 +12,7 @@\n â”Š12â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/key_states.js\"></script>\n â”Š13â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/layer.js\"></script>\n â”Š14â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/screen.js\"></script>\n+â”Š  â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/assets_loader.js\"></script>\n â”Š15â”Š16â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š16â”Š17â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n```\n\n[}]: #\n\n> As for now the `assets loader` only has the ability to load textures, but we will extend it as we go further in this tutorial, no need to overdo it.\n\nNow that we have the `assets loader` we can add the ability to change a screen. Whenever we change a screen, the old screen's assets should be unloaded, and the new screen's assets should be loaded using the `assets loader`:\n\n[{]: <helper> (diffStep 2.13)\n\n#### [Step 2.13: Add the ability to change and load screen](https://github.com/DAB0mB/radial-snake/commit/90aab03)\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;game.js\n```diff\n@@ -92,6 +92,61 @@\n â”Š 92â”Š 92â”Š    this.playing = false;\n â”Š 93â”Š 93â”Š  }\n â”Š 94â”Š 94â”Š\n+â”Š   â”Š 95â”Š  changeScreen(Screen, ...screenArgs) {\n+â”Š   â”Š 96â”Š    // If there is a screen defined, dispose it first\n+â”Š   â”Š 97â”Š    if (this.screen) {\n+â”Š   â”Š 98â”Š      this.unloadScreen();\n+â”Š   â”Š 99â”Š      this.screen.disposeEventListeners();\n+â”Š   â”Š100â”Š    }\n+â”Š   â”Š101â”Š\n+â”Š   â”Š102â”Š    this.screen = new Screen(this, ...screenArgs);\n+â”Š   â”Š103â”Š\n+â”Š   â”Š104â”Š    // Load screen assets\n+â”Š   â”Š105â”Š    this.loadScreen(() => {\n+â”Š   â”Š106â”Š      // Once assets are loaded, initialize event listeners\n+â”Š   â”Š107â”Š      this.screen.initEventListeners();\n+â”Š   â”Š108â”Š      // The \"initialize\" method is exactly the same as the constructor, only it runs\n+â”Š   â”Š109â”Š      // once assets are available and event listeners are registered\n+â”Š   â”Š110â”Š      this.screen.initialize(this, ...screenArgs);\n+â”Š   â”Š111â”Š    });\n+â”Š   â”Š112â”Š  }\n+â”Š   â”Š113â”Š\n+â”Š   â”Š114â”Š  // Loads screen assets and invokes callback once loading is finished\n+â”Š   â”Š115â”Š  loadScreen(callback = _.noop) {\n+â”Š   â”Š116â”Š    if (!this.screen.load) return callback();\n+â”Š   â”Š117â”Š\n+â”Š   â”Š118â”Š    this.screen.loading = true;\n+â”Š   â”Š119â”Š    // The number of assets to load\n+â”Š   â”Š120â”Š    let loadsize = 0;\n+â”Š   â”Š121â”Š    let onload;\n+â”Š   â”Š122â”Š\n+â”Š   â”Š123â”Š    // This object can load assets\n+â”Š   â”Š124â”Š    let assetsLoader = new Engine.AssetsLoader(() => {\n+â”Š   â”Š125â”Š      loadsize++;\n+â”Š   â”Š126â”Š      return () => onload();\n+â”Š   â”Š127â”Š    });\n+â”Š   â”Š128â”Š\n+â”Š   â”Š129â”Š    // The \"load\" method returns the assets loaded by the screen\n+â”Š   â”Š130â”Š    let screenAssets = this.screen.load(assetsLoader);\n+â”Š   â”Š131â”Š\n+â”Š   â”Š132â”Š    // We use the \"after\" method because we want the following callback to be invoked\n+â”Š   â”Š133â”Š    // only once all assets are loaded\n+â”Š   â”Š134â”Š    onload = _.after(loadsize, () => {\n+â”Š   â”Š135â”Š      delete this.screen.loading;\n+â”Š   â”Š136â”Š      callback();\n+â”Š   â”Š137â”Š    });\n+â”Š   â”Š138â”Š\n+â”Š   â”Š139â”Š    // The returned assets will be available on screen's assets object\n+â”Š   â”Š140â”Š    _.extend(this.screen.assets, screenAssets);\n+â”Š   â”Š141â”Š  }\n+â”Š   â”Š142â”Š\n+â”Š   â”Š143â”Š  // Disposes screen assets\n+â”Š   â”Š144â”Š  unloadScreen() {\n+â”Š   â”Š145â”Š    if (!this.screen.unload) return;\n+â”Š   â”Š146â”Š    let assetsNames = this.screen.unload();\n+â”Š   â”Š147â”Š    _.omit(this.assets, assetsNames);\n+â”Š   â”Š148â”Š  }\n+â”Š   â”Š149â”Š\n â”Š 95â”Š150â”Š  // Defines global assets\n â”Š 96â”Š151â”Š  extendAssets(assets) {\n â”Š 97â”Š152â”Š    _.extend(this.assets, assets);\n```\n\n[}]: #\n\nLet's add a test screen just so we can get the hang of it. The test screen will only print a message to the canvas:\n\n[{]: <helper> (diffStep 2.14)\n\n#### [Step 2.14: Add test screen](https://github.com/DAB0mB/radial-snake/commit/85776e8)\n\n##### Added resources&#x2F;scripts&#x2F;test_screen.js\n```diff\n@@ -0,0 +1,10 @@\n+â”Š  â”Š 1â”Šclass TestScreen extends Engine.Screen {\n+â”Š  â”Š 2â”Š  draw(context) {\n+â”Š  â”Š 3â”Š    // A 20px sized \"Georgia\" font (Available natively)\n+â”Š  â”Š 4â”Š    context.font = \"20px Georgia\";\n+â”Š  â”Š 5â”Š    // The text should be colored white\n+â”Š  â”Š 6â”Š    context.fillStyle = \"white\";\n+â”Š  â”Š 7â”Š    // Draw the following message 50px from the left and 50px from the top\n+â”Š  â”Š 8â”Š    context.fillText(\"This is a Test Screen\", 50, 50);\n+â”Š  â”Š 9â”Š  }\n+â”Š  â”Š10â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -14,6 +14,7 @@\n â”Š14â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/screen.js\"></script>\n â”Š15â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/assets_loader.js\"></script>\n â”Š16â”Š16â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n+â”Š  â”Š17â”Š    <script type=\"text/javascript\" src=\"/scripts/test_screen.js\"></script>\n â”Š17â”Š18â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n â”Š18â”Š19â”Š\n â”Š19â”Š20â”Š    <!-- Styles -->\n```\n\n[}]: #\n\nNow we will use the test screen by changing to it as we create an instance of the game:\n\n[{]: <helper> (diffStep 2.15)\n\n#### [Step 2.15: Set test screen as the initial screen](https://github.com/DAB0mB/radial-snake/commit/203d084)\n\n##### Changed resources&#x2F;scripts&#x2F;main.js\n```diff\n@@ -1,4 +1,5 @@\n â”Š1â”Š1â”Šdocument.addEventListener(\"DOMContentLoaded\", function(event) {\n â”Š2â”Š2â”Š  let game = new Engine.Game(document.getElementById(\"gameCanvas\"), false);\n+â”Š â”Š3â”Š  game.changeScreen(TestScreen);\n â”Š3â”Š4â”Š  game.play();\n â”Š4â”Š5â”Š});ðŸš«â†µ\n```\n\n[}]: #\n\nOnce you will load the application you should see a black canvas with a white text saying:\n\n    This is a test screen\n\nIt means our screen system works and you may proceed to the next step, where we're gonna create our first screen :-)"
          },
          {
            "manualTitle": "Step 3: Creating a splash screen using a keyframe animation engine",
            "stepRevision": "4b2431bbc910f8945e5fd86aa964fec3ede8761c",
            "manualView": "![snake-demo-splash-small](https://cloud.githubusercontent.com/assets/7648874/21074086/a19fa9ce-bed6-11e6-9060-2ce94c215712.gif)\n\nIn this step we will be creating the `splash` screen - the initial screen that should be shown once we launch the game. Our splash is consisted of a random logo animation as presented in the `gif` file above. The \"splash\" effect can be achieved using 2 concepts:\n\n- A sprite class - Which will present the logo texture in different dimensions, angles and rotations.\n- A key-frame animation - Which will draw an animation automatically along the time axis using key-frames - each is a sprite representation of the texture in a specific time point.\n\nSo first thing first, we will start by implementing the sprite class:\n\n[{]: <helper> (diffStep 3.1)\n\n#### [Step 3.1: Create &#x27;Sprite&#x27; class](https://github.com/DAB0mB/radial-snake/commit/a32a711)\n\n##### Added resources&#x2F;scripts&#x2F;engine&#x2F;sprite.js\n```diff\n@@ -0,0 +1,58 @@\n+â”Š  â”Š 1â”ŠEngine.Sprite = class Sprite {\n+â”Š  â”Š 2â”Š  // An easy representation of a sprite on a canvas, with a set of convenient tools\n+â”Š  â”Š 3â”Š  // for alignment and coloring\n+â”Š  â”Š 4â”Š  constructor(texture) {\n+â”Š  â”Š 5â”Š    this.texture = texture;\n+â”Š  â”Š 6â”Š    this.x = 0;\n+â”Š  â”Š 7â”Š    this.y = 0;\n+â”Š  â”Š 8â”Š    this.width = texture.width;\n+â”Š  â”Š 9â”Š    this.height = texture.height;\n+â”Š  â”Š10â”Š    this.pivot = { x: 0, y: 0 };\n+â”Š  â”Š11â”Š    this.opacity = 1;\n+â”Š  â”Š12â”Š  }\n+â”Š  â”Š13â”Š\n+â”Š  â”Š14â”Š  draw(context, offsetX = 0, offsetY = 0) {\n+â”Š  â”Š15â”Š    context.save();\n+â”Š  â”Š16â”Š    context.globalAlpha = this.opacity;\n+â”Š  â”Š17â”Š\n+â”Š  â”Š18â”Š    // The following switch-case can also be seen as a list of all possible\n+â”Š  â”Š19â”Š    // alignment modes\n+â”Š  â”Š20â”Š    switch (this.align) {\n+â”Š  â”Š21â”Š      case \"top-left\": case \"left-top\": this.pivot = { x: 0, y: 0 }; break;\n+â”Š  â”Š22â”Š      case \"top-right\": case \"right-top\": this.pivot = { x: this.width, y: 0 }; break;\n+â”Š  â”Š23â”Š      case \"bottom-left\": case \"left-bottom\": this.pivot = { x: 0, y: this.height }; break;\n+â”Š  â”Š24â”Š      case \"bottom-right\": case \"right-bottom\": this.pivot = { x: this.width, y: this.height }; break;\n+â”Š  â”Š25â”Š      case \"middle\": case \"center\": this.pivot = { x: this.width / 2, y: this.height / 2 }; break;\n+â”Š  â”Š26â”Š      case \"left\": this.pivot = { x: 0, y: this.height / 2 }; break;\n+â”Š  â”Š27â”Š      case \"top\": this.pivot = { x: this.width / 2, y: 0 }; break;\n+â”Š  â”Š28â”Š      case \"right\": this.pivot = { x: this.width, y: this.height / 2 }; break;\n+â”Š  â”Š29â”Š      case \"bottom\": this.pivot = { x: this.width / 2, y: this.height }; break;\n+â”Š  â”Š30â”Š    }\n+â”Š  â”Š31â”Š\n+â”Š  â”Š32â”Š    context.drawImage(\n+â”Š  â”Š33â”Š      this.texture,\n+â”Š  â”Š34â”Š      (this.x - this.pivot.x) + offsetX,\n+â”Š  â”Š35â”Š      (this.y - this.pivot.y) + offsetY,\n+â”Š  â”Š36â”Š      this.width,\n+â”Š  â”Š37â”Š      this.height\n+â”Š  â”Š38â”Š    );\n+â”Š  â”Š39â”Š\n+â”Š  â”Š40â”Š    context.restore();\n+â”Š  â”Š41â”Š  }\n+â”Š  â”Š42â”Š\n+â”Š  â”Š43â”Š  // A sprite property (key) can also be resized based on a given percentage.\n+â”Š  â”Š44â”Š  // The 'relative' argument represents the whole of which the percents are gonna be\n+â”Š  â”Š45â”Š  // calculated from, and the 'adapters' argument is an array of property names which\n+â”Š  â”Š46â”Š  // gonna adapt themselves based on the changes made in the given key.\n+â”Š  â”Š47â”Š  // Usually 'width' goes along with ['height'] adapters, if we\n+â”Š  â”Š48â”Š  // want to keep their original ratio\n+â”Š  â”Š49â”Š  setPercentage(key, relative, percents, ...adapters) {\n+â”Š  â”Š50â”Š    let oldVal = this[key];\n+â”Š  â”Š51â”Š    let newVal = this[key] = (percents * relative) / 100;\n+â”Š  â”Š52â”Š    let ratio = newVal / oldVal;\n+â”Š  â”Š53â”Š\n+â”Š  â”Š54â”Š    adapters.forEach(adapter => {\n+â”Š  â”Š55â”Š      this[adapter] *= ratio;\n+â”Š  â”Š56â”Š    });\n+â”Š  â”Š57â”Š  }\n+â”Š  â”Š58â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -9,6 +9,7 @@\n â”Š 9â”Š 9â”Š\n â”Š10â”Š10â”Š    <!-- Scripts -->\n â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n+â”Š  â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/sprite.js\"></script>\n â”Š12â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/key_states.js\"></script>\n â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/layer.js\"></script>\n â”Š14â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/screen.js\"></script>\n```\n\n[}]: #\n\nAnd we will download the logo which will be presented in the splash screen using the sprite class:\n\n    resources$ mkdir assets\n    resources$ cd assets\n    resources/assets$ mkdir textures\n    resources/assets$ cd textures\n    resources/assets/textures$ wget raw.githubusercontent.com/dab0mb/radial-snake/master/resources/assets/textures/splash.png\n\n> Any logo can that you desired can be used instead! But to ease things up I already provided you with one as a sample\n\nNow we will create the initial splash screen, where we only gonna show a sprite of the logo in the middle of the screen, with no animation applied yet. We will first define a dedicated `Screens` module under the `Game` namespace:\n\n[{]: <helper> (diffStep 3.3)\n\n#### [Step 3.3: Create a &#x27;Game&#x27; namespace with a &#x27;Screens&#x27; module](https://github.com/DAB0mB/radial-snake/commit/ae85a96)\n\n##### Changed resources&#x2F;scripts&#x2F;namespaces.js\n```diff\n@@ -1 +1,5 @@\n+â”Š â”Š1â”ŠGame = {\n+â”Š â”Š2â”Š  Screens: {}\n+â”Š â”Š3â”Š};\n+â”Š â”Š4â”Š\n â”Š1â”Š5â”ŠEngine = {};ðŸš«â†µ\n```\n\n[}]: #\n\nAnd we can go ahead and implement the screen itself:\n\n[{]: <helper> (diffStep 3.4)\n\n#### [Step 3.4: Create initial splash screen](https://github.com/DAB0mB/radial-snake/commit/4dd73f3)\n\n##### Added resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;splash&#x2F;index.js\n```diff\n@@ -0,0 +1,19 @@\n+â”Š  â”Š 1â”ŠGame.Screens.Splash = class Splash extends Engine.Screen {\n+â”Š  â”Š 2â”Š  initialize() {\n+â”Š  â”Š 3â”Š    // Create splash sprite and set its properties\n+â”Š  â”Š 4â”Š    this.splashSprite = new Engine.Sprite(this.assets.splashTexture);\n+â”Š  â”Š 5â”Š    this.splashSprite.align = \"center\";\n+â”Š  â”Š 6â”Š    this.splashSprite.x = this.width / 2;\n+â”Š  â”Š 7â”Š  }\n+â”Š  â”Š 8â”Š\n+â”Š  â”Š 9â”Š  load(assetsLoader) {\n+â”Š  â”Š10â”Š    // These are local assets which will be disposed along with the screen\n+â”Š  â”Š11â”Š    return {\n+â”Š  â”Š12â”Š      splashTexture: assetsLoader.texture(\"/textures/splash\")\n+â”Š  â”Š13â”Š    };\n+â”Š  â”Š14â”Š  }\n+â”Š  â”Š15â”Š\n+â”Š  â”Š16â”Š  draw(context) {\n+â”Š  â”Š17â”Š    this.splashSprite.draw(context);\n+â”Š  â”Š18â”Š  }\n+â”Š  â”Š19â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -16,6 +16,7 @@\n â”Š16â”Š16â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/assets_loader.js\"></script>\n â”Š17â”Š17â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š18â”Š18â”Š    <script type=\"text/javascript\" src=\"/scripts/test_screen.js\"></script>\n+â”Š  â”Š19â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/splash/index.js\"></script>\n â”Š19â”Š20â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n â”Š20â”Š21â”Š\n â”Š21â”Š22â”Š    <!-- Styles -->\n```\n\n[}]: #\n\nNow we can set the splash screen as the initial screen in the entry script file:\n\n[{]: <helper> (diffStep 3.5)\n\n#### [Step 3.5: Set splash screen as the initial game screen](https://github.com/DAB0mB/radial-snake/commit/3576ff8)\n\n##### Changed resources&#x2F;scripts&#x2F;main.js\n```diff\n@@ -1,5 +1,5 @@\n â”Š1â”Š1â”Šdocument.addEventListener(\"DOMContentLoaded\", function(event) {\n â”Š2â”Š2â”Š  let game = new Engine.Game(document.getElementById(\"gameCanvas\"), false);\n-â”Š3â”Š â”Š  game.changeScreen(TestScreen);\n+â”Š â”Š3â”Š  game.changeScreen(Game.Screens.Splash);\n â”Š4â”Š4â”Š  game.play();\n â”Š5â”Š5â”Š});ðŸš«â†µ\n```\n\n[}]: #\n\nAnd we will get rid of the unnecessary test screen since we make no use of it any longer:\n\n    $ rm resources/scripts/test_screen.js\n\nWe will now proceed into the next stage where we will be implementing the key-frame animation engine as said at the beginning of the step. We first need to define an `Animations` module, since we can have multiple types of animation strategy like [sprite-atlas animation](http://www.joshmorony.com/how-to-create-animations-in-phaser-with-a-texture-atlas/), not necessarily a key-frame animation:\n\n[{]: <helper> (diffStep 3.7)\n\n#### [Step 3.7: Add &#x27;Animations&#x27; module to &#x27;Engine&#x27; namespace](https://github.com/DAB0mB/radial-snake/commit/ffe800c)\n\n##### Changed resources&#x2F;scripts&#x2F;namespaces.js\n```diff\n@@ -2,4 +2,6 @@\n â”Š2â”Š2â”Š  Screens: {}\n â”Š3â”Š3â”Š};\n â”Š4â”Š4â”Š\n-â”Š5â”Š â”ŠEngine = {};ðŸš«â†µ\n+â”Š â”Š5â”ŠEngine = {\n+â”Š â”Š6â”Š  Animations: {}\n+â”Š â”Š7â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nInside the newly created module we will create the key-frame animation engine. The key-frame animation consists of the following methods:\n\n- update - Updates the animation.\n- draw - Draws the current animation frame on the provided canvas context.\n- play - Enables update operations.\n- pause - Disables update operations.\n\n[{]: <helper> (diffStep 3.8)\n\n#### [Step 3.8: Create a key-frame animation engine](https://github.com/DAB0mB/radial-snake/commit/64c58fb)\n\n##### Added resources&#x2F;scripts&#x2F;engine&#x2F;animations&#x2F;keyframe.js\n```diff\n@@ -0,0 +1,142 @@\n+â”Š   â”Š  1â”ŠEngine.Animations.Keyframe = class Keyframe {\n+â”Š   â”Š  2â”Š  constructor(sprite, keyframes) {\n+â”Š   â”Š  3â”Š    this.sprite = sprite;\n+â”Š   â”Š  4â”Š    // The key-frames array contains objects with the properties of the\n+â”Š   â”Š  5â”Š    // sprite at the current time-point, e.g. width of 100 and height of 200\n+â”Š   â”Š  6â”Š    this.keyframes = keyframes;\n+â”Š   â”Š  7â”Š    this.age = 0;\n+â”Š   â”Š  8â”Š    this.frame = 0;\n+â”Š   â”Š  9â”Š    // This flag determines what's gonna happen to the animation once\n+â”Š   â”Š 10â”Š    // it's finished playing\n+â”Š   â”Š 11â”Š    this.repetitionMode = \"none\";\n+â”Š   â”Š 12â”Š    this.lastKeyframe = _.last(keyframes);\n+â”Š   â”Š 13â”Š    this.lastFrame = this.lastKeyframe.frame;\n+â”Š   â”Š 14â”Š\n+â”Š   â”Š 15â”Š    // These are the properties which we can animate\n+â”Š   â”Š 16â”Š    this.animables = [\n+â”Š   â”Š 17â”Š      \"x\", \"y\", \"width\", \"height\", \"opacity\"\n+â”Š   â”Š 18â”Š    ];\n+â”Š   â”Š 19â”Š\n+â”Š   â”Š 20â”Š    // Set a map whose keys represent animatable properties and values represent an array\n+â”Š   â”Š 21â”Š    // with relevant key-frames to its belonging property\n+â”Š   â”Š 22â”Š    this.trimmedKeyframes = this.animables.reduce((trimmedKeyframes, key) => {\n+â”Š   â”Š 23â”Š      trimmedKeyframes[key] = keyframes.filter(keyframe => keyframe[key] != null);\n+â”Š   â”Š 24â”Š      return trimmedKeyframes;\n+â”Š   â”Š 25â”Š    }, {});\n+â”Š   â”Š 26â”Š\n+â”Š   â”Š 27â”Š    // Set initial properties on sprite based on initial key-frame\n+â”Š   â”Š 28â”Š    _.each(keyframes[0], (value, key) => {\n+â”Š   â”Š 29â”Š      if (this.animables.includes(key)) sprite[key] = value;\n+â”Š   â”Š 30â”Š    });\n+â”Š   â”Š 31â”Š  }\n+â”Š   â”Š 32â”Š\n+â”Š   â”Š 33â”Š  draw(context, offsetX, offsetY) {\n+â”Š   â”Š 34â”Š    this.sprite.draw(context, offsetX, offsetY);\n+â”Š   â”Š 35â”Š  }\n+â”Š   â”Š 36â”Š\n+â”Š   â”Š 37â”Š  update(span) {\n+â”Š   â”Š 38â”Š    if (!this.playing) return;\n+â”Š   â”Š 39â”Š\n+â”Š   â”Š 40â”Š    this.age += span;\n+â”Š   â”Š 41â”Š\n+â”Š   â”Š 42â”Š    switch (this.repetitionMode) {\n+â”Š   â”Š 43â”Š      // After one cycle animation would stop\n+â”Š   â”Š 44â”Š      case \"none\":\n+â”Š   â”Š 45â”Š        this.frame += span;\n+â”Š   â”Š 46â”Š\n+â”Š   â”Š 47â”Š        if (this.frame > this.lastFrame) {\n+â”Š   â”Š 48â”Š          this.frame = this.lastFrame;\n+â”Š   â”Š 49â”Š          this.playing = false;\n+â”Š   â”Š 50â”Š        }\n+â”Š   â”Š 51â”Š\n+â”Š   â”Š 52â”Š        break;\n+â”Š   â”Š 53â”Š\n+â”Š   â”Š 54â”Š      // Once finished, replay from the beginning\n+â”Š   â”Š 55â”Š      case \"cyclic\":\n+â”Š   â”Š 56â”Š        this.frame = this.age % this.lastFrame;\n+â”Š   â”Š 57â”Š        break;\n+â”Š   â”Š 58â”Š\n+â”Š   â”Š 59â”Š      // Once finished, play backwards, and so on\n+â”Š   â”Š 60â”Š      case \"full\":\n+â”Š   â”Š 61â”Š        this.frame = this.age % this.lastFrame;\n+â”Š   â”Š 62â”Š        let animationComplete = (this.age / this.lastFrame) % 2 >= 1;\n+â”Š   â”Š 63â”Š        if (animationComplete) this.frame = this.lastFrame - this.frame;\n+â”Š   â”Š 64â”Š        break;\n+â”Š   â”Š 65â”Š    }\n+â”Š   â”Š 66â”Š\n+â”Š   â”Š 67â”Š    // Update sprite properties based on given key-frame's easing mode\n+â”Š   â”Š 68â”Š    this.animables.forEach(key => {\n+â”Š   â”Š 69â”Š      let motion = this.getKeyframeMotion(key);\n+â”Š   â”Š 70â”Š\n+â”Š   â”Š 71â”Š      if (motion)\n+â”Š   â”Š 72â”Š        this.sprite[key] = this.calculateRelativeValue(motion, key);\n+â”Š   â”Š 73â”Š    });\n+â”Š   â”Š 74â”Š  }\n+â”Š   â”Š 75â”Š\n+â”Š   â”Š 76â”Š  play() {\n+â”Š   â”Š 77â”Š    this.playing = true;\n+â”Š   â”Š 78â”Š  }\n+â”Š   â”Š 79â”Š\n+â”Š   â”Š 80â”Š  pause() {\n+â”Š   â”Š 81â”Š    this.playing = false;\n+â”Š   â”Š 82â”Š  }\n+â”Š   â”Š 83â”Š\n+â”Š   â”Š 84â”Š  // Gets motion for current refresh\n+â”Š   â”Š 85â”Š  getKeyframeMotion(key) {\n+â”Š   â”Š 86â”Š    let keyframes = this.trimmedKeyframes[key];\n+â”Š   â”Š 87â”Š\n+â”Š   â”Š 88â”Š    // If no key-frames defined, motion is idle\n+â”Š   â”Š 89â”Š    if (keyframes == null) return;\n+â”Š   â”Š 90â”Š    // If there is only one key frame, motion is idle\n+â”Š   â”Š 91â”Š    if (keyframes.length < 2) return;\n+â”Š   â”Š 92â”Š    // If last frame reached, motion is idle\n+â”Š   â”Š 93â”Š    if (this.frame > _.last(keyframes).frame) return;\n+â”Š   â”Š 94â”Š\n+â”Š   â”Š 95â”Š    let start = this.findStartKeyframe(keyframes);\n+â”Š   â”Š 96â”Š    let end = this.findEndKeyframe(keyframes);\n+â”Š   â”Š 97â”Š    let ratio = this.getKeyframesRatio(start, end);\n+â”Š   â”Š 98â”Š\n+â”Š   â”Š 99â”Š    return { start, end, ratio };\n+â”Š   â”Š100â”Š  }\n+â”Š   â”Š101â”Š\n+â”Š   â”Š102â”Š  // Gets the movement ratio\n+â”Š   â”Š103â”Š  getKeyframesRatio(start, end) {\n+â”Š   â”Š104â”Š    return (this.frame - start.frame) / (end.frame - start.frame);\n+â”Š   â”Š105â”Š  }\n+â”Š   â”Š106â”Š\n+â”Š   â”Š107â”Š  // Get property end value based on current frame\n+â”Š   â”Š108â”Š  findEndKeyframe(keyframes) {\n+â”Š   â”Š109â”Š    return _.find(keyframes, keyframe =>\n+â”Š   â”Š110â”Š      keyframe.frame >= (this.frame || 1)\n+â”Š   â”Š111â”Š    );\n+â”Š   â”Š112â”Š  }\n+â”Š   â”Š113â”Š\n+â”Š   â”Š114â”Š  // Get property start value based on current frame\n+â”Š   â”Š115â”Š  findStartKeyframe(keyframes) {\n+â”Š   â”Š116â”Š    let resultIndex;\n+â”Š   â”Š117â”Š\n+â”Š   â”Š118â”Š    keyframes.some((keyframe, currIndex) => {\n+â”Š   â”Š119â”Š      if (keyframe.frame >= (this.frame || 1)) {\n+â”Š   â”Š120â”Š        resultIndex = currIndex;\n+â”Š   â”Š121â”Š        return true;\n+â”Š   â”Š122â”Š      }\n+â”Š   â”Š123â”Š    });\n+â”Š   â”Š124â”Š\n+â”Š   â”Š125â”Š    return keyframes[resultIndex - 1];\n+â”Š   â”Š126â”Š  }\n+â”Š   â”Š127â”Š\n+â”Š   â”Š128â”Š  // Get a recalculated property value relative to provided easing mode\n+â”Š   â”Š129â”Š  calculateRelativeValue(motion, key) {\n+â”Š   â”Š130â”Š    let a = motion.start[key];\n+â”Š   â”Š131â”Š    let b = motion.end[key];\n+â”Š   â”Š132â”Š    let r = motion.ratio;\n+â”Š   â”Š133â”Š    let easing = r > 0 ? motion.start.easing : motion.end.easing;\n+â”Š   â”Š134â”Š\n+â”Š   â”Š135â”Š    switch (easing) {\n+â”Š   â”Š136â”Š      case \"in\": r = Math.sin((r * Math.PI) / 2); break;\n+â”Š   â”Š137â”Š      case \"out\": r = Math.cos((r * Math.PI) / 2); break;\n+â”Š   â”Š138â”Š    }\n+â”Š   â”Š139â”Š\n+â”Š   â”Š140â”Š    return ((b - a) * r) + a;\n+â”Š   â”Š141â”Š  }\n+â”Š   â”Š142â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -10,6 +10,7 @@\n â”Š10â”Š10â”Š    <!-- Scripts -->\n â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n â”Š12â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/sprite.js\"></script>\n+â”Š  â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/animations/keyframe.js\"></script>\n â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/key_states.js\"></script>\n â”Š14â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/layer.js\"></script>\n â”Š15â”Š16â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/screen.js\"></script>\n```\n\n[}]: #\n\nWhen initializing a new instance of the key-frame animation, we should invoke it with the desired sprite, and an array of key-frames. What exactly does a single key-frame represents? The properties of the sprite at that specific time point. In addition, a key-frame can be set with an [easing mode](https://css-tricks.com/ease-out-in-ease-in-out/) of `in` and `out`. By default, the animation would be linear.\n\nBased on the `repitationMode` property, three things can happen to the animation once finished:\n\n- `none` - The animation will play once, and then stop. It will appear as a static sprite.\n- `cyclic` - The animation will repeat itself from the beginning, over and over again until stopped manually.\n- `full` - The animation will play itself backwards, and then forwards, backwards, forwards, and so on.\n\nThanks to the key-frame animation engine, we can apply it to the splash screen to show a beautifully animated logo rather than showing a static image. So in addition to the logo sprite, we will initialize a key-frame animation as well:\n\n[{]: <helper> (diffStep 3.9)\n\n#### [Step 3.9: Apply key-frame animation to splash screen](https://github.com/DAB0mB/radial-snake/commit/8ca47e5)\n\n##### Changed resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;splash&#x2F;index.js\n```diff\n@@ -1,9 +1,34 @@\n â”Š 1â”Š 1â”ŠGame.Screens.Splash = class Splash extends Engine.Screen {\n â”Š 2â”Š 2â”Š  initialize() {\n â”Š 3â”Š 3â”Š    // Create splash sprite and set its properties\n-â”Š 4â”Š  â”Š    this.splashSprite = new Engine.Sprite(this.assets.splashTexture);\n-â”Š 5â”Š  â”Š    this.splashSprite.align = \"center\";\n-â”Š 6â”Š  â”Š    this.splashSprite.x = this.width / 2;\n+â”Š  â”Š 4â”Š    let splashSprite = new Engine.Sprite(this.assets.splashTexture);\n+â”Š  â”Š 5â”Š    splashSprite.align = \"center\";\n+â”Š  â”Š 6â”Š    splashSprite.x = this.width / 2;\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Š    // Create splash sprite animation\n+â”Š  â”Š 9â”Š    this.splashAnim = new Engine.Animations.Keyframe(splashSprite, [\n+â”Š  â”Š10â”Š      {\n+â”Š  â”Š11â”Š        y: (this.height / 2) - 30,\n+â”Š  â”Š12â”Š        width: splashSprite.width / 4,\n+â”Š  â”Š13â”Š        height: splashSprite.height / 4,\n+â”Š  â”Š14â”Š        opacity: 0,\n+â”Š  â”Š15â”Š        easing: \"in\",\n+â”Š  â”Š16â”Š        frame: 0\n+â”Š  â”Š17â”Š      },\n+â”Š  â”Š18â”Š      {\n+â”Š  â”Š19â”Š        y: this.height / 2,\n+â”Š  â”Š20â”Š        width: (splashSprite.width / 3) + (splashSprite.width * 0.05),\n+â”Š  â”Š21â”Š        height: (splashSprite.height / 3) + (splashSprite.height * 0.05),\n+â”Š  â”Š22â”Š        opacity: 1,\n+â”Š  â”Š23â”Š        frame: 3000\n+â”Š  â”Š24â”Š      },\n+â”Š  â”Š25â”Š      {\n+â”Š  â”Š26â”Š        frame: 3500\n+â”Š  â”Š27â”Š      }\n+â”Š  â”Š28â”Š    ]);\n+â”Š  â”Š29â”Š\n+â”Š  â”Š30â”Š    // Start playing animation\n+â”Š  â”Š31â”Š    this.splashAnim.play();\n â”Š 7â”Š32â”Š  }\n â”Š 8â”Š33â”Š\n â”Š 9â”Š34â”Š  load(assetsLoader) {\n```\n```diff\n@@ -14,6 +39,10 @@\n â”Š14â”Š39â”Š  }\n â”Š15â”Š40â”Š\n â”Š16â”Š41â”Š  draw(context) {\n-â”Š17â”Š  â”Š    this.splashSprite.draw(context);\n+â”Š  â”Š42â”Š    this.splashAnim.draw(context);\n+â”Š  â”Š43â”Š  }\n+â”Š  â”Š44â”Š\n+â”Š  â”Š45â”Š  update(span) {\n+â”Š  â”Š46â”Š    this.splashAnim.update(span);\n â”Š18â”Š47â”Š  }\n â”Š19â”Š48â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nThe following key-frames illustrate the nodes of the animation we've just created:\n\n    width: 0\n    height: 0\n    opacity: 0\n\n![logo-empty](https://cloud.githubusercontent.com/assets/7648874/21583394/ee7a1dec-d065-11e6-80ce-fdd37c4b5dbb.png)\n\n    width: 225\n    height: 175\n    opacity: 1\n\n![logo-half](https://cloud.githubusercontent.com/assets/7648874/21583396/ee9bdf68-d065-11e6-95fb-4cf5ed58a9de.png)\n\n    width: 342\n    height: 266\n    opacity: 1\n\n![logo-full](https://cloud.githubusercontent.com/assets/7648874/21583395/ee7b3754-d065-11e6-9646-476d196a6412.png)"
          },
          {
            "manualTitle": "Step 4: Creating a main menu screen using a font engine",
            "stepRevision": "f88428bffcdf2bcf269b9cc15837cc40e0ed9caf",
            "manualView": "![snake-demo-menu-small](https://cloud.githubusercontent.com/assets/7648874/21074099/e72a81bc-bed6-11e6-98cb-329dc12a4b06.gif)\n\nIn this step we will be creating the main menu screen as shown above. The main menu screen is a simple screen which will show the logo of the game and an instruction text saying `Press a key to start`. We will be using a simple texture to show the game-logo and we will use the key-frame animation engine to show a flickering animation of the instruction text. The instruction text is the main part of this step, since it is made out of a font file (`.ttf`) and the text is auto-generated, a general solution which can serve us in many situations. We will start by implementing the main menu using static assets, which means that we will use a texture to show the instructions text, and later on we will implement the generic solution I've just mentioned. First, we will download the necessary assets:\n\n    resources/assets/textures$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/assets/textures/instructions.png\n    resources/assets/textures$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/assets/textures/logo.png\n\nAnd then we will implement the initial main menu screen:\n\n[{]: <helper> (diffStep 4.2)\n\n#### [Step 4.2: Create initial main menu screen](https://github.com/DAB0mB/radial-snake/commit/ed79de7)\n\n##### Added resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;menu&#x2F;index.js\n```diff\n@@ -0,0 +1,44 @@\n+â”Š  â”Š 1â”ŠGame.Screens.Menu = class Menu extends Engine.Screen {\n+â”Š  â”Š 2â”Š  initialize() {\n+â”Š  â”Š 3â”Š    // Initialize snake logo sprite\n+â”Š  â”Š 4â”Š    this.logoSprite = new Engine.Sprite(this.assets.logoTexture);\n+â”Š  â”Š 5â”Š    this.logoSprite.setPercentage(\"width\", this.width, 30, \"height\");\n+â”Š  â”Š 6â”Š\n+â”Š  â”Š 7â”Š    // Initialize instructions sprite\n+â”Š  â”Š 8â”Š    let instructionsSprite = new Engine.Sprite(this.assets.instructionsTexture);\n+â”Š  â”Š 9â”Š    instructionsSprite.align = \"center\";\n+â”Š  â”Š10â”Š    instructionsSprite.setPercentage(\"width\", this.width, 35, \"height\");\n+â”Š  â”Š11â”Š    instructionsSprite.x = this.width / 2;\n+â”Š  â”Š12â”Š    instructionsSprite.y = this.height / 2;\n+â”Š  â”Š13â”Š\n+â”Š  â”Š14â”Š    // Create flickering animation for instructions sprite\n+â”Š  â”Š15â”Š    this.instructionsAnim = new Engine.Animations.Keyframe(instructionsSprite, [\n+â”Š  â”Š16â”Š      {\n+â”Š  â”Š17â”Š        opacity: 1,\n+â”Š  â”Š18â”Š        frame: 0\n+â”Š  â”Š19â”Š      },\n+â”Š  â”Š20â”Š      {\n+â”Š  â”Š21â”Š        opacity: 0,\n+â”Š  â”Š22â”Š        frame: 2000\n+â”Š  â”Š23â”Š      }\n+â”Š  â”Š24â”Š    ]);\n+â”Š  â”Š25â”Š\n+â”Š  â”Š26â”Š    // Play it repeatedly, back and forth\n+â”Š  â”Š27â”Š    this.instructionsAnim.repetitionMode = \"full\";\n+â”Š  â”Š28â”Š    this.instructionsAnim.play();\n+â”Š  â”Š29â”Š  }\n+â”Š  â”Š30â”Š\n+â”Š  â”Š31â”Š  unload() {\n+â”Š  â”Š32â”Š    // Dispose the following assets to prevent memory leaks\n+â”Š  â”Š33â”Š    return [\"logoTexture\", \"instructionsTexture\"];\n+â”Š  â”Š34â”Š  }\n+â”Š  â”Š35â”Š\n+â”Š  â”Š36â”Š  draw(context) {\n+â”Š  â”Š37â”Š    this.logoSprite.draw(context);\n+â”Š  â”Š38â”Š    this.instructionsAnim.draw(context);\n+â”Š  â”Š39â”Š  }\n+â”Š  â”Š40â”Š\n+â”Š  â”Š41â”Š  update(span) {\n+â”Š  â”Š42â”Š    this.instructionsAnim.update(span);\n+â”Š  â”Š43â”Š  }\n+â”Š  â”Š44â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -16,6 +16,7 @@\n â”Š16â”Š16â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/screen.js\"></script>\n â”Š17â”Š17â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/assets_loader.js\"></script>\n â”Š18â”Š18â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n+â”Š  â”Š19â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/menu/index.js\"></script>\n â”Š19â”Š20â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/splash/index.js\"></script>\n â”Š20â”Š21â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n```\n\n[}]: #\n\nThis screen is dependent on several assets which we will load during \"splash screen time\", to save some loading time and for a smooth experience. The main menu screen will be shown automatically once the splash animation has been finished:\n\n[{]: <helper> (diffStep 4.3)\n\n#### [Step 4.3: Queue main menu screen](https://github.com/DAB0mB/radial-snake/commit/cd83a30)\n\n##### Changed resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;splash&#x2F;index.js\n```diff\n@@ -32,10 +32,21 @@\n â”Š32â”Š32â”Š  }\n â”Š33â”Š33â”Š\n â”Š34â”Š34â”Š  load(assetsLoader) {\n+â”Š  â”Š35â”Š    // Load assets\n+â”Š  â”Š36â”Š    let instructionsTexture = assetsLoader.texture(\"/textures/instrucitons\");\n+â”Š  â”Š37â”Š    let logoTexture = assetsLoader.texture(\"/textures/logo\");\n+â”Š  â”Š38â”Š    let splashTexture = assetsLoader.texture(\"/textures/splash\");\n+â”Š  â”Š39â”Š\n+â”Š  â”Š40â”Š    // These are global assets which will be shared among all screens until manually\n+â”Š  â”Š41â”Š    // disposed. We use the time gap created by the splash animation to load necessary\n+â”Š  â”Š42â”Š    // assets without wasting any time\n+â”Š  â”Š43â”Š    this.game.extendAssets({\n+â”Š  â”Š44â”Š      instructionsTexture,\n+â”Š  â”Š45â”Š      logoTexture\n+â”Š  â”Š46â”Š    });\n+â”Š  â”Š47â”Š\n â”Š35â”Š48â”Š    // These are local assets which will be disposed along with the screen\n-â”Š36â”Š  â”Š    return {\n-â”Š37â”Š  â”Š      splashTexture: assetsLoader.texture(\"/textures/splash\")\n-â”Š38â”Š  â”Š    };\n+â”Š  â”Š49â”Š    return { splashTexture };\n â”Š39â”Š50â”Š  }\n â”Š40â”Š51â”Š\n â”Š41â”Š52â”Š  draw(context) {\n```\n```diff\n@@ -43,6 +54,12 @@\n â”Š43â”Š54â”Š  }\n â”Š44â”Š55â”Š\n â”Š45â”Š56â”Š  update(span) {\n-â”Š46â”Š  â”Š    this.splashAnim.update(span);\n+â”Š  â”Š57â”Š    if (this.splashAnim.playing) {\n+â”Š  â”Š58â”Š      this.splashAnim.update(span);\n+â”Š  â”Š59â”Š    }\n+â”Š  â”Š60â”Š    // Once animation has stopped play switch to main menu\n+â”Š  â”Š61â”Š    else {\n+â”Š  â”Š62â”Š      this.game.changeScreen(Game.Screens.Menu);\n+â”Š  â”Š63â”Š    }\n â”Š47â”Š64â”Š  }\n â”Š48â”Š65â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nBy now if you launch the application you should see the main menu screen as described in the beginning. But event though it works, we're not yet finished. We still need to convert the instruction texture into an auto-generated font texture. Obviously, this requires us to download the desired `ttf` file:\n\n    resources/assets/fonts$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/assets/fonts/minecraftia.ttf\n\n> Any font file can be used here, but to save time and effort I already provided you with one\n\n`ttf` is the most common format, but since we're using JavaScript, it would make sense to convert it into a `json` file, and that's exactly what we're going to do. There's a very convenient software called [font-builder](https://github.com/andryblack/fontbuilder), and it can cut fonts, store them in `png` files, along with some user-specified meta-data stored in an `xml` file.\n\n![font-builder](https://camo.githubusercontent.com/b2c95cda825c783f5399d9197599848c33cdfcc8/687474703a2f2f7777772e67616d656465762e72752f66696c65732f696d616765732f73637265656e312e6a706567)\n\nGo over to this website: https://github.com/andryblack/fontbuilder.\nFetch a copy of the `font-builder` repo, and try to convert the `minecraftia.ttf` file into a `png` file. If you want to skip this step, although I wouldn't recommend it, you can download the following files which I already generated myself:\n\n    resources/assets/fonts$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/assets/fonts/minecraftia.png\n    resources/assets/fonts$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/assets/fonts/minecraftia.xml\n\nAs promised, we will be working with a `json` file, not a `ttf` file and not an `xml` file. For this task we will be implementing a font-parser module, which will simply take all the meta-data in the `xml` file and put it into a nice `json` schema:\n\n[{]: <helper> (diffStep 4.6)\n\n#### [Step 4.6: Create font parser so we can convert &#x27;xml&#x27; font format to &#x27;json&#x27;](https://github.com/DAB0mB/radial-snake/commit/66044e9)\n\n##### Added helpers&#x2F;font_parser.js\n```diff\n@@ -0,0 +1,102 @@\n+â”Š   â”Š  1â”Šconst _ = require(\"underscore\");\n+â”Š   â”Š  2â”Šconst Async = require(\"async\");\n+â”Š   â”Š  3â”Šconst Fs = require(\"fs\");\n+â”Š   â”Š  4â”Šconst Path = require(\"path\");\n+â”Š   â”Š  5â”Šconst { DOMParser } = require(\"xmldom\");\n+â”Š   â”Š  6â”Š\n+â”Š   â”Š  7â”Šif (module === require.main) {\n+â”Š   â”Š  8â”Š  let fonstDir = Path.resolve(__dirname, \"../resources/assets/fonts\");\n+â”Š   â”Š  9â”Š  xmlsToJsons(fonstDir, err => { if (err) throw err });\n+â”Š   â”Š 10â”Š}\n+â”Š   â”Š 11â”Š\n+â”Š   â”Š 12â”Š// Gets a dir path containing font xmls and converts them all to jsons\n+â”Š   â”Š 13â”Šfunction xmlsToJsons(path, callback = _.noop) {\n+â”Š   â”Š 14â”Š  Fs.readdir(path, (err, files) => {\n+â”Š   â”Š 15â”Š    if (err) return callback(err);\n+â”Š   â”Š 16â”Š\n+â”Š   â”Š 17â”Š    // Remove all extensions\n+â”Š   â”Š 18â”Š    fileNames = _.uniq(files.map(file => file.split(\".\")[0]));\n+â”Š   â”Š 19â”Š\n+â”Š   â”Š 20â”Š    // Convert each xml individually\n+â”Š   â”Š 21â”Š    Async.each(fileNames, (fileName, next) => {\n+â”Š   â”Š 22â”Š      xmlToJson(`${path}/${fileName}`, next);\n+â”Š   â”Š 23â”Š    },\n+â”Š   â”Š 24â”Š    (err) => {\n+â”Š   â”Š 25â”Š      if (!err) console.log(\n+â”Š   â”Š 26â”Š        'All fonts have been successfully parsed!'\n+â”Š   â”Š 27â”Š      );\n+â”Š   â”Š 28â”Š\n+â”Š   â”Š 29â”Š      callback(err);\n+â”Š   â”Š 30â”Š    });\n+â”Š   â”Š 31â”Š  });\n+â”Š   â”Š 32â”Š}\n+â”Š   â”Š 33â”Š\n+â”Š   â”Š 34â”Š// Gets a font xml and converts it to json\n+â”Š   â”Š 35â”Šfunction xmlToJson(path, callback = _.noop) {\n+â”Š   â”Š 36â”Š  Async.waterfall([\n+â”Š   â”Š 37â”Š    (next) => {\n+â”Š   â”Š 38â”Š      Fs.readFile(`${path}.xml`, function(err, xmlBuffer) {\n+â”Š   â”Š 39â”Š        if (err) return next(err);\n+â”Š   â”Š 40â”Š\n+â”Š   â”Š 41â”Š        let json = {\n+â”Š   â”Š 42â”Š          chars: {}\n+â”Š   â”Š 43â”Š        };\n+â”Š   â”Š 44â”Š\n+â”Š   â”Š 45â”Š        let xml = xmlBuffer.toString();\n+â”Š   â”Š 46â”Š        let doc = new DOMParser().parseFromString(xml);\n+â”Š   â”Š 47â”Š        let fontDoc = doc.getElementsByTagName(\"Font\")[0];\n+â”Š   â”Š 48â”Š        let charsDoc = fontDoc.getElementsByTagName(\"Char\");\n+â”Š   â”Š 49â”Š\n+â”Š   â”Š 50â”Š        // Compose meta-data about font like size and family\n+â”Š   â”Š 51â”Š        _.each(fontDoc.attributes, (attr) => {\n+â”Š   â”Š 52â”Š          json[attr.name] = parseInt(attr.value) || attr.value;\n+â”Š   â”Š 53â”Š        });\n+â”Š   â”Š 54â”Š\n+â”Š   â”Š 55â”Š        // Compose data about each character in font\n+â”Š   â”Š 56â”Š        _.each(charsDoc, (charDoc) => {\n+â”Š   â”Š 57â”Š          let charCode = charDoc.getAttribute(\"code\");\n+â”Š   â”Š 58â”Š\n+â”Š   â”Š 59â”Š          let char = json.chars[charCode] = {\n+â”Š   â”Š 60â”Š            rect: rect = {},\n+â”Š   â”Š 61â”Š            offset: offset = {},\n+â”Š   â”Š 62â”Š            width: parseInt(charDoc.getAttribute(\"width\"))\n+â”Š   â”Š 63â”Š          };\n+â”Š   â”Š 64â”Š\n+â”Š   â”Š 65â”Š          [\n+â”Š   â”Š 66â”Š            rect.x,\n+â”Š   â”Š 67â”Š            rect.y,\n+â”Š   â”Š 68â”Š            rect.width,\n+â”Š   â”Š 69â”Š            rect.height\n+â”Š   â”Š 70â”Š          ] = extractIntegers(charDoc.getAttribute(\"rect\"));\n+â”Š   â”Š 71â”Š\n+â”Š   â”Š 72â”Š          [offset.x, offset.y] = extractIntegers(charDoc.getAttribute(\"offset\"));\n+â”Š   â”Š 73â”Š        });\n+â”Š   â”Š 74â”Š\n+â”Š   â”Š 75â”Š        next(null, JSON.stringify(json, null, 2));\n+â”Š   â”Š 76â”Š      });\n+â”Š   â”Š 77â”Š    },\n+â”Š   â”Š 78â”Š    (json, next) => {\n+â”Š   â”Š 79â”Š      // Once finished, write json into file\n+â”Š   â”Š 80â”Š      Fs.writeFile(path + \".json\", json, (err) => {\n+â”Š   â”Š 81â”Š        next(err);\n+â”Š   â”Š 82â”Š      });\n+â”Š   â”Š 83â”Š    }\n+â”Š   â”Š 84â”Š  ], (err) => {\n+â”Š   â”Š 85â”Š    if (!err) console.log(\n+â”Š   â”Š 86â”Š      `Font ${path} has been successfully parsed...`\n+â”Š   â”Š 87â”Š    );\n+â”Š   â”Š 88â”Š\n+â”Š   â”Š 89â”Š    callback(err);\n+â”Š   â”Š 90â”Š  });\n+â”Š   â”Š 91â”Š};\n+â”Š   â”Š 92â”Š\n+â”Š   â”Š 93â”Š// Converts an string of numbers to array of numbers\n+â”Š   â”Š 94â”Š// e.g. extractIntegers(\"1 2 3\") -> [1, 2, 3]\n+â”Š   â”Š 95â”Šfunction extractIntegers(srcstr) {\n+â”Š   â”Š 96â”Š  return srcstr.split(\" \").map((substr) => parseInt(substr));\n+â”Š   â”Š 97â”Š}\n+â”Š   â”Š 98â”Š\n+â”Š   â”Š 99â”Šmodule.exports = {\n+â”Š   â”Š100â”Š  xmlToJson,\n+â”Š   â”Š101â”Š  xmlsToJsons\n+â”Š   â”Š102â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nThis script will take everything that's in the `fonts` dir and parser it as mentioned above. Before we can user this script we will need to install some NPM dependencies like so:\n\n    $ npm install --save underscore\n    $ npm install --save xmldom\n\nAnd instead of running the parser manually over and over again whenever we wanna use it, we will use the following `NPM` script instead:\n\n[{]: <helper> (diffStep 4.8)\n\n#### [Step 4.8: Add font parsing npm scripts](https://github.com/DAB0mB/radial-snake/commit/7a1cf81)\n\n##### Changed package.json\n```diff\n@@ -7,7 +7,8 @@\n â”Š 7â”Š 7â”Š  },\n â”Š 8â”Š 8â”Š  \"private\": true,\n â”Š 9â”Š 9â”Š  \"scripts\": {\n-â”Š10â”Š  â”Š    \"serve\": \"nodemon server.js\"\n+â”Š  â”Š10â”Š    \"serve\": \"npm run parse:fonts && nodemon server.js\",\n+â”Š  â”Š11â”Š    \"build:fonts\": \"node helpers/font_parser.js\"\n â”Š11â”Š12â”Š  },\n â”Š12â”Š13â”Š  \"dependencies\": {\n â”Š13â”Š14â”Š    \"async\": \"^2.1.4\",\n```\n\n[}]: #\n\nWe don't want the generated fonts to be included by `git` since they are going to automatically regenerate themselves, therefore we gonna add the following ignore rule:\n\n[{]: <helper> (diffStep 4.9)\n\n#### [Step 4.9: Add rule to to git-ignore parsed fonts](https://github.com/DAB0mB/radial-snake/commit/bbf7647)\n\n##### Changed .gitignore\n```diff\n@@ -1,2 +1,3 @@\n â”Š1â”Š1â”Šnode_modules\n-â”Š2â”Š â”Šnpm-debug.logðŸš«â†µ\n+â”Š â”Š2â”Šnpm-debug.log\n+â”Š â”Š3â”Šresources/assets/fonts/*.jsonðŸš«â†µ\n```\n\n[}]: #\n\nNow we will build our `minecraftia` font by simply running:\n\n    $ npm run build:fonts\n\nAnd voila! We have a freshly created `json` file which we can work with. You can also get it from here:\n\n    resources/assets/fonts$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/assets/fonts/minecraftia.json\n\nNow that we have our assets finally ready we can go ahead and focus on extending the engine which powers up our game. We need some sort of a generic font-engine which will know how to load a font file and create a text-sprite out of it. First we will implement a class called `Restorable`, which shares the same restore API as the CanvasRenderingContext2D and will give us the ability to save and restore the font's state (More information can be found [here](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/restore)):\n\n[{]: <helper> (diffStep 4.11)\n\n#### [Step 4.11: Add &#x27;Restorable&#x27; class](https://github.com/DAB0mB/radial-snake/commit/8239c01)\n\n##### Added resources&#x2F;scripts&#x2F;engine&#x2F;restorable.js\n```diff\n@@ -0,0 +1,21 @@\n+â”Š  â”Š 1â”ŠEngine.Restorable = class Restorable {\n+â”Š  â”Š 2â”Š  // Acts the same as canvas's save() and restore() API.\n+â”Š  â”Š 3â”Š  // 'restorable' props are defined in the constructor\n+â”Š  â”Š 4â”Š  constructor(...restorableProps) {\n+â”Š  â”Š 5â”Š    this._restorableProps = restorableProps;\n+â”Š  â”Š 6â”Š    this._restorableStates = [];\n+â”Š  â”Š 7â”Š  }\n+â”Š  â”Š 8â”Š\n+â”Š  â”Š 9â”Š  // Save current state in the stack\n+â”Š  â”Š10â”Š  save() {\n+â”Š  â”Š11â”Š    this._restorableStates.push(this._restorableProps.reduce((state, prop) => {\n+â”Š  â”Š12â”Š      state[prop] = this[prop];\n+â”Š  â”Š13â”Š      return state;\n+â”Š  â”Š14â”Š    }, {}));\n+â”Š  â”Š15â”Š  }\n+â”Š  â”Š16â”Š\n+â”Š  â”Š17â”Š  // Pop most recent state and apply it\n+â”Š  â”Š18â”Š  restore() {\n+â”Š  â”Š19â”Š    _.extend(this, this._restorableStates.pop());\n+â”Š  â”Š20â”Š  }\n+â”Š  â”Š21â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -9,6 +9,7 @@\n â”Š 9â”Š 9â”Š\n â”Š10â”Š10â”Š    <!-- Scripts -->\n â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n+â”Š  â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/restorable.js\"></script>\n â”Š12â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/sprite.js\"></script>\n â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/animations/keyframe.js\"></script>\n â”Š14â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/key_states.js\"></script>\n```\n\n[}]: #\n\nAnd now we can go ahead and implement the font class itself:\n\n[{]: <helper> (diffStep 4.12)\n\n#### [Step 4.12: Create font engine](https://github.com/DAB0mB/radial-snake/commit/7a1f2c7)\n\n##### Added resources&#x2F;scripts&#x2F;engine&#x2F;font.js\n```diff\n@@ -0,0 +1,133 @@\n+â”Š   â”Š  1â”ŠEngine.Font = class Font extends Engine.Restorable {\n+â”Š   â”Š  2â”Š  // The src property acts just line native image's src property.\n+â”Š   â”Š  3â”Š  // Once finished loading, the onload() callback will be invoked\n+â”Š   â”Š  4â”Š  get src() {\n+â”Š   â”Š  5â”Š    return this._src;\n+â”Š   â”Š  6â”Š  }\n+â”Š   â”Š  7â”Š\n+â”Š   â”Š  8â”Š  set src(src) {\n+â”Š   â”Š  9â”Š    this._src = src;\n+â”Š   â”Š 10â”Š\n+â”Š   â”Š 11â”Š    // The font is actually an image, therefore we have 2 onload callbacks.\n+â”Š   â”Š 12â”Š    // The first one is the native one which will always be run,\n+â”Š   â”Š 13â”Š    // and the second one is a user defined one\n+â”Š   â”Š 14â”Š    if (this.onload) var done = _.after(2, this.onload);\n+â”Š   â”Š 15â”Š\n+â”Š   â”Š 16â”Š    this.atlas = new Image();\n+â”Š   â”Š 17â”Š    this.atlas.onload = done;\n+â”Š   â”Š 18â”Š    this.atlas.src = `${src}.png`;\n+â”Š   â”Š 19â”Š\n+â”Š   â”Š 20â”Š    // Get json based on the given src property\n+â”Š   â”Š 21â”Š    $.getJSON(`${src}.json`, data => {\n+â”Š   â”Š 22â”Š      this.data = data;\n+â”Š   â”Š 23â”Š      if (done) done();\n+â”Š   â”Š 24â”Š    });\n+â”Š   â”Š 25â”Š\n+â”Š   â”Š 26â”Š    return this._src;\n+â”Š   â”Š 27â”Š  }\n+â”Š   â”Š 28â”Š\n+â”Š   â”Š 29â”Š  constructor() {\n+â”Š   â”Š 30â”Š    // The color property is the only restorable property\n+â”Š   â”Š 31â”Š    super(\"color\");\n+â”Š   â”Š 32â”Š    this.charSpritesCache = {};\n+â”Š   â”Š 33â”Š  }\n+â”Š   â”Š 34â”Š\n+â”Š   â”Š 35â”Š  // Creates a texture out of the font with the given text\n+â”Š   â”Š 36â”Š  createTexture(text, options = {}) {\n+â”Š   â”Š 37â”Š    let { noOffsets, noSpaces } = options;\n+â”Š   â”Š 38â”Š    let canvas = document.createElement(\"canvas\");\n+â”Š   â”Š 39â”Š    let context = canvas.getContext(\"2d\");\n+â”Š   â”Š 40â”Š    let height = canvas.height = this.data.height;\n+â”Š   â”Š 41â”Š\n+â”Š   â”Š 42â”Š    // Calculates the width of the canvas based on the text and the font\n+â”Š   â”Š 43â”Š    let width = canvas.width = _.reduce(text, (width, c) => {\n+â”Š   â”Š 44â”Š      // No-space option means that the characters will be\n+â”Š   â”Š 45â”Š      // drawn with no any space between them\n+â”Š   â”Š 46â”Š      if (noSpaces) {\n+â”Š   â”Š 47â”Š        return width + this.getCharSprite(c).width;\n+â”Š   â”Š 48â”Š      }\n+â”Š   â”Š 49â”Š\n+â”Š   â”Š 50â”Š      return width + this.data.chars[c].width;\n+â”Š   â”Š 51â”Š    }, 0);\n+â”Š   â”Š 52â”Š\n+â”Š   â”Š 53â”Š    // A custom size can be specified for a font as well\n+â”Š   â”Š 54â”Š    if (this.size) {\n+â”Š   â”Š 55â”Š      let ratio = this.size / this.data.size;\n+â”Š   â”Š 56â”Š      canvas.height *= ratio;\n+â”Š   â”Š 57â”Š      canvas.width *= ratio;\n+â”Š   â”Š 58â”Š      context.scale(ratio, ratio);\n+â”Š   â”Š 59â”Š    }\n+â”Š   â”Š 60â”Š\n+â”Š   â”Š 61â”Š    // No we are going to draw each char on the canvas individually,\n+â”Š   â”Š 62â”Š    // naturally, there should be an offset after we draw each character.\n+â”Š   â”Š 63â”Š    // This variable will be used to calculate the offset\n+â”Š   â”Š 64â”Š    let offset = 0;\n+â”Š   â”Š 65â”Š\n+â”Š   â”Š 66â”Š    // Get for each char\n+â”Š   â”Š 67â”Š    _.map(text, (char) => {\n+â”Š   â”Š 68â”Š      return this.getCharSprite(char);\n+â”Š   â”Š 69â”Š    })\n+â”Š   â”Š 70â”Š    // Start drawing each char on the canvas\n+â”Š   â”Š 71â”Š    .forEach((charSprite, index) => {\n+â”Š   â”Š 72â”Š      let charData = this.data.chars[text.charAt(index)];\n+â”Š   â”Š 73â”Š\n+â”Š   â”Š 74â”Š      // Each char in the font xml has a native offset in addition to its rectangle.\n+â”Š   â”Š 75â”Š      // This option will disable the calculation of the native offset\n+â”Š   â”Š 76â”Š      if (noOffsets) {\n+â”Š   â”Š 77â”Š        charSprite.draw(context, offset);\n+â”Š   â”Š 78â”Š      }\n+â”Š   â”Š 79â”Š      else {\n+â”Š   â”Š 80â”Š        charSprite.draw(context, offset + charData.offset.x, charData.offset.y);\n+â”Š   â”Š 81â”Š      }\n+â”Š   â”Š 82â”Š\n+â”Š   â”Š 83â”Š      if (noSpaces) {\n+â”Š   â”Š 84â”Š        offset += charSprite.width;\n+â”Š   â”Š 85â”Š      }\n+â”Š   â”Š 86â”Š      else {\n+â”Š   â”Š 87â”Š        offset += charData.width;\n+â”Š   â”Š 88â”Š      }\n+â”Š   â”Š 89â”Š\n+â”Š   â”Š 90â”Š      // A color for the font can be specified as well\n+â”Š   â”Š 91â”Š      if (this.color) {\n+â”Š   â”Š 92â”Š        let overlayCanvas = document.createElement(\"canvas\");\n+â”Š   â”Š 93â”Š        let overlayContext = overlayCanvas.getContext(\"2d\");\n+â”Š   â”Š 94â”Š        overlayCanvas.width = width;\n+â”Š   â”Š 95â”Š        overlayCanvas.height = height;\n+â”Š   â”Š 96â”Š        overlayContext.beginPath();\n+â”Š   â”Š 97â”Š        overlayContext.rect(0, 0, width, height);\n+â”Š   â”Š 98â”Š        overlayContext.fillStyle = this.color;\n+â”Š   â”Š 99â”Š        overlayContext.fill();\n+â”Š   â”Š100â”Š\n+â”Š   â”Š101â”Š        context.save();\n+â”Š   â”Š102â”Š        context.globalCompositeOperation = \"source-in\";\n+â”Š   â”Š103â”Š        context.drawImage(overlayCanvas, 0, 0);\n+â”Š   â”Š104â”Š        context.restore();\n+â”Š   â”Š105â”Š      }\n+â”Š   â”Š106â”Š    });\n+â”Š   â”Š107â”Š\n+â”Š   â”Š108â”Š    // The canvas will be treated like an image\n+â”Š   â”Š109â”Š    return canvas;\n+â”Š   â”Š110â”Š  }\n+â”Š   â”Š111â”Š\n+â”Š   â”Š112â”Š  // Gets a sprite of the given char, using the current font\n+â”Š   â”Š113â”Š  getCharSprite(char) {\n+â”Š   â”Š114â”Š    // If char is already stored in cache, abort calculation and return it\n+â”Š   â”Š115â”Š    if (this.charSpritesCache[char]) return this.charSpritesCache[char];\n+â”Š   â”Š116â”Š\n+â”Š   â”Š117â”Š    // This data is fetched by the given json\n+â”Š   â”Š118â”Š    let { x, y, width, height } = this.data.chars[char].rect;\n+â”Š   â”Š119â”Š    // Creating a canvas which we will use to draw on,\n+â”Š   â”Š120â”Š    // but it is used exactly like an image afterwards\n+â”Š   â”Š121â”Š    let canvas = document.createElement(\"canvas\");\n+â”Š   â”Š122â”Š    let context = canvas.getContext(\"2d\");\n+â”Š   â”Š123â”Š\n+â”Š   â”Š124â”Š    // The canvas will have the same dimensions as the font\n+â”Š   â”Š125â”Š    canvas.width = width;\n+â”Š   â”Š126â”Š    canvas.height = height;\n+â”Š   â”Š127â”Š    // Draw a cropped image from the atlas, this image contains the char font\n+â”Š   â”Š128â”Š    context.drawImage(this.atlas, x, y, width, height, 0, 0, width, height);\n+â”Š   â”Š129â”Š\n+â”Š   â”Š130â”Š    // Store in cache and return it\n+â”Š   â”Š131â”Š    return this.charSpritesCache[char] = new Engine.Sprite(canvas);\n+â”Š   â”Š132â”Š  }\n+â”Š   â”Š133â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -10,6 +10,7 @@\n â”Š10â”Š10â”Š    <!-- Scripts -->\n â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n â”Š12â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/restorable.js\"></script>\n+â”Š  â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/font.js\"></script>\n â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/sprite.js\"></script>\n â”Š14â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/animations/keyframe.js\"></script>\n â”Š15â”Š16â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/key_states.js\"></script>\n```\n\n[}]: #\n\nThe font API shares a similar API as [HTMLImageElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/Image), once we set the `src` property the font will start loading itself, and the `onload` user-defined callback should be called once finished. Another neat feature would be the `createTexture` method, which takes a string as its first argument, representing the text that we would like to generate, and returns an instance of the `Sprite` class.\n\nWe will also be adding the option to load some font assets in our asset-loader:\n\n[{]: <helper> (diffStep 4.13)\n\n#### [Step 4.13: Add a font loading option to &#x27;AssetLoader&#x27;](https://github.com/DAB0mB/radial-snake/commit/a9d73cc)\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;assets_loader.js\n```diff\n@@ -10,4 +10,12 @@\n â”Š10â”Š10â”Š    image.src = `${path}.png`;\n â”Š11â”Š11â”Š    return image;\n â”Š12â”Š12â”Š  }\n+â”Š  â”Š13â”Š\n+â”Š  â”Š14â”Š  // Load font\n+â”Š  â”Š15â”Š  font(path) {\n+â”Š  â”Š16â”Š    let font = new Engine.Font();\n+â”Š  â”Š17â”Š    font.onload = this.next();\n+â”Š  â”Š18â”Š    font.src = path;\n+â”Š  â”Š19â”Š    return font;\n+â”Š  â”Š20â”Š  }\n â”Š13â”Š21â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nAnd replace the instructions texture loading with a `minecraftia` font loading in the initial splash screen:\n\n[{]: <helper> (diffStep 4.14)\n\n#### [Step 4.14: Load &#x27;minecraftia&#x27; font in splash screen](https://github.com/DAB0mB/radial-snake/commit/231a68f)\n\n##### Changed resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;splash&#x2F;index.js\n```diff\n@@ -33,7 +33,7 @@\n â”Š33â”Š33â”Š\n â”Š34â”Š34â”Š  load(assetsLoader) {\n â”Š35â”Š35â”Š    // Load assets\n-â”Š36â”Š  â”Š    let instructionsTexture = assetsLoader.texture(\"/textures/instrucitons\");\n+â”Š  â”Š36â”Š    let minecraftiaFont = assetsLoader.font(\"/fonts/minecraftia\");\n â”Š37â”Š37â”Š    let logoTexture = assetsLoader.texture(\"/textures/logo\");\n â”Š38â”Š38â”Š    let splashTexture = assetsLoader.texture(\"/textures/splash\");\n â”Š39â”Š39â”Š\n```\n```diff\n@@ -41,7 +41,7 @@\n â”Š41â”Š41â”Š    // disposed. We use the time gap created by the splash animation to load necessary\n â”Š42â”Š42â”Š    // assets without wasting any time\n â”Š43â”Š43â”Š    this.game.extendAssets({\n-â”Š44â”Š  â”Š      instructionsTexture,\n+â”Š  â”Š44â”Š      minecraftiaFont,\n â”Š45â”Š45â”Š      logoTexture\n â”Š46â”Š46â”Š    });\n```\n\n[}]: #\n\nNow it can use us in the main menu screen where we will create a text-sprite saying `Press a key to start`, just like the instruction sprite we're about to replace:\n\n[{]: <helper> (diffStep 4.15)\n\n#### [Step 4.15: Replace texture usage with font usage in main menu screen](https://github.com/DAB0mB/radial-snake/commit/a769b81)\n\n##### Changed resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;menu&#x2F;index.js\n```diff\n@@ -5,7 +5,8 @@\n â”Š 5â”Š 5â”Š    this.logoSprite.setPercentage(\"width\", this.width, 30, \"height\");\n â”Š 6â”Š 6â”Š\n â”Š 7â”Š 7â”Š    // Initialize instructions sprite\n-â”Š 8â”Š  â”Š    let instructionsSprite = new Engine.Sprite(this.assets.instructionsTexture);\n+â”Š  â”Š 8â”Š    let instructionsTexture = this.assets.minecraftiaFont.createTexture(\"Press a key to start\");\n+â”Š  â”Š 9â”Š    let instructionsSprite = new Engine.Sprite(instructionsTexture);\n â”Š 9â”Š10â”Š    instructionsSprite.align = \"center\";\n â”Š10â”Š11â”Š    instructionsSprite.setPercentage(\"width\", this.width, 35, \"height\");\n â”Š11â”Š12â”Š    instructionsSprite.x = this.width / 2;\n```\n```diff\n@@ -30,7 +31,7 @@\n â”Š30â”Š31â”Š\n â”Š31â”Š32â”Š  unload() {\n â”Š32â”Š33â”Š    // Dispose the following assets to prevent memory leaks\n-â”Š33â”Š  â”Š    return [\"logoTexture\", \"instructionsTexture\"];\n+â”Š  â”Š34â”Š    return \"logoTexture\";\n â”Š34â”Š35â”Š  }\n â”Š35â”Š36â”Š\n â”Š36â”Š37â”Š  draw(context) {\n```\n```diff\n@@ -41,4 +42,8 @@\n â”Š41â”Š42â”Š  update(span) {\n â”Š42â”Š43â”Š    this.instructionsAnim.update(span);\n â”Š43â”Š44â”Š  }\n+â”Š  â”Š45â”Š\n+â”Š  â”Š46â”Š  update(span) {\n+â”Š  â”Š47â”Š    this.instructionsAnim.update(span);\n+â”Š  â”Š48â”Š  }\n â”Š44â”Š49â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nIt shouldn't look any different from the beginning of the step where we manually drew the instruction texture, but in the next steps we will be using the font-engine a lot, and you will be thankful for what we've just did."
          },
          {
            "manualTitle": "Step 5: Creating a snake and related geometry shapes",
            "stepRevision": "ad178e03e276b088c96d6f67889db379ad201e3e",
            "manualView": "![snake-illustrate](https://cloud.githubusercontent.com/assets/7648874/21074115/46ef4466-bed7-11e6-9d5d-12fa6d43147b.gif)\n\nIn this step we will be creating all the necessary geometry shapes to form a snake; we're basically implementing the right infrastructure so in the next step we will be able to implement the game screen with ease. What exactly do I mean by \"geometry shapes\"? Well, our snake will be made out of circles, and lines. If we don't press any buttons at all, the snake should move forward at a straight line, and once we press on one of the arrow keys, the snake should move in a circular motion. Not only we want to draw the screen on the canvas, we also want to be able to detect collision with other snakes, since this is a \"Tron\" style game where we gonna fight against an opponent.\n\nKeep in mind that a computer's precision is limited due its [binary representation in memory](https://en.wikipedia.org/wiki/Memory_cell_(binary)). We need to take into consideration that there might be a significant deviation when detecting collisions and intersections between geometry shapes, especially when elapsed time is not always guaranteed to stay precise. To handle these deviation issues, we're gonna create some utility functions and place then in a new module called `Utils`:\n\n[{]: <helper> (diffStep 5.1)\n\n#### [Step 5.1: Create utilities module](https://github.com/DAB0mB/radial-snake/commit/58ae99a)\n\n##### Added resources&#x2F;scripts&#x2F;utils.js\n```diff\n@@ -0,0 +1,68 @@\n+â”Š  â”Š 1â”Š// A wrapper function for our utilities which will enable chaining\n+â”Š  â”Š 2â”Š// e.g. Utils().mod().trim().isBetween()...\n+â”Š  â”Š 3â”ŠUtils = function Utils(context) {\n+â”Š  â”Š 4â”Š  const chain = {};\n+â”Š  â”Š 5â”Š\n+â”Š  â”Š 6â”Š  Object.keys(Utils).forEach((utilName) => {\n+â”Š  â”Š 7â”Š    chain[utilName] = (...args) => {\n+â”Š  â”Š 8â”Š      const result = Utils[utilName](context, ...args);\n+â”Š  â”Š 9â”Š      return Utils(result);\n+â”Š  â”Š10â”Š    };\n+â”Š  â”Š11â”Š  });\n+â”Š  â”Š12â”Š\n+â”Š  â”Š13â”Š  // Returns the result of the chaining\n+â”Š  â”Š14â”Š  chain.value = () => context;\n+â”Š  â”Š15â”Š\n+â”Š  â”Š16â”Š  return chain;\n+â”Š  â”Š17â”Š};\n+â”Š  â”Š18â”Š\n+â”Š  â”Š19â”Š// Fixed modulo method which can calculate modulo of negative numbers properly\n+â”Š  â”Š20â”Š// e.g. (-803).mod(800) returns 797\n+â”Š  â”Š21â”ŠUtils.mod = function (context, num) {\n+â”Š  â”Š22â”Š  return ((context % num) + num) % num;\n+â”Š  â”Š23â”Š};\n+â”Š  â”Š24â”Š\n+â”Š  â”Š25â”Š// Trims number and leaves the number of decimals specified.\n+â”Š  â”Š26â”Š// The \"mode\" argument specifies which math function should be invoked\n+â”Š  â”Š27â”Š// right after the number has been trimmed.\n+â”Š  â”Š28â”Š// e.g. 12.12345.trim(3, \"ceil\") returns 12.124\n+â”Š  â”Š29â”ŠUtils.trim = function (context, decimals, mode = \"round\") {\n+â”Š  â”Š30â”Š  return Math[mode](context * Math.pow(10, decimals)) / Math.pow(10, decimals);\n+â”Š  â”Š31â”Š};\n+â”Š  â”Š32â”Š\n+â”Š  â”Š33â”Š// Tells if number is in specified range based on given precision.\n+â”Š  â”Š34â”Š// See the \"compare\" method for more information about precision\n+â”Š  â”Š35â”ŠUtils.isBetween = function (context, num1, num2, precision) {\n+â”Š  â”Š36â”Š  return Utils.compare(context, Math.min(num1, num2), \">=\", precision) &&\n+â”Š  â”Š37â”Š         Utils.compare(context, Math.max(num1, num2), \"<=\", precision);\n+â”Š  â”Š38â”Š};\n+â”Š  â”Š39â”Š\n+â”Š  â”Š40â”Š// Initiates comparison operator between context number and a given number, only here\n+â”Š  â”Š41â”Š// a precision can be specified\n+â”Š  â”Š42â”ŠUtils.compare = function (context, num, method, precision = method) {\n+â”Š  â”Š43â”Š  switch (precision) {\n+â”Š  â”Š44â”Š    // Fixed precision, \"almost equal\" with a deviation of Îµ\n+â”Š  â”Š45â”Š    case \"f\":\n+â”Š  â”Š46â”Š      switch (method) {\n+â”Š  â”Š47â”Š        case \"<\": case \"<=\": return context <= num + Number.EPSILON;\n+â”Š  â”Š48â”Š        case \">\": case \">=\": return context >= num - Number.EPSILON;\n+â”Š  â”Š49â”Š        default: return Math.abs(context - num) <= Number.EPSILON;\n+â”Š  â”Š50â”Š      }\n+â”Š  â”Š51â”Š    // Pixel precision, round comparison\n+â”Š  â”Š52â”Š    case \"px\":\n+â”Š  â”Š53â”Š      switch (method) {\n+â”Š  â”Š54â”Š        case \"<\": case \"<=\": return Math.round(context) <= Math.round(num);\n+â”Š  â”Š55â”Š        case \">\": case \">=\": return Math.round(context) >= Math.round(num);\n+â”Š  â”Š56â”Š        default: return Math.round(context) == Math.round(num);\n+â”Š  â”Š57â”Š      }\n+â”Š  â”Š58â”Š    // Exact precision\n+â”Š  â”Š59â”Š    default:\n+â”Š  â”Š60â”Š      switch (method) {\n+â”Š  â”Š61â”Š        case \"<\": return context < num;\n+â”Š  â”Š62â”Š        case \"<=\": return context <= num;\n+â”Š  â”Š63â”Š        case \">\": return context > num;\n+â”Š  â”Š64â”Š        case \">=\": return context >= num;\n+â”Š  â”Š65â”Š        default: return context === num;\n+â”Š  â”Š66â”Š      }\n+â”Š  â”Š67â”Š  }\n+â”Š  â”Š68â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -8,6 +8,7 @@\n â”Š 8â”Š 8â”Š    <script type=\"text/javascript\" src=\"/libs/underscore.js\"></script>\n â”Š 9â”Š 9â”Š\n â”Š10â”Š10â”Š    <!-- Scripts -->\n+â”Š  â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/utils.js\"></script>\n â”Š11â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n â”Š12â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/restorable.js\"></script>\n â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/font.js\"></script>\n```\n\n[}]: #\n\nNow we would like to start implementing the first class representation for a line, and for that we're requires to add a new module called `Geometry` to the `Engine` namespace:\n\n[{]: <helper> (diffStep 5.2)\n\n#### [Step 5.2: Add &#x27;Shapes&#x27; module to &#x27;Engine&#x27; namespace](https://github.com/DAB0mB/radial-snake/commit/4ed2788)\n\n##### Changed resources&#x2F;scripts&#x2F;namespaces.js\n```diff\n@@ -3,5 +3,6 @@\n â”Š3â”Š3â”Š};\n â”Š4â”Š4â”Š\n â”Š5â”Š5â”ŠEngine = {\n-â”Š6â”Š â”Š  Animations: {}\n+â”Š â”Š6â”Š  Animations: {},\n+â”Š â”Š7â”Š  Geometry: {}\n â”Š7â”Š8â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nAnd now that we have this module available to use, we can go ahead and implement our first geometry shape class - `Line`:\n\n[{]: <helper> (diffStep 5.3)\n\n#### [Step 5.3: Create &#x27;Line&#x27; class](https://github.com/DAB0mB/radial-snake/commit/fb38ab5)\n\n##### Added resources&#x2F;scripts&#x2F;engine&#x2F;geometry&#x2F;line.js\n```diff\n@@ -0,0 +1,65 @@\n+â”Š  â”Š 1â”ŠEngine.Geometry.Line = class Line {\n+â”Š  â”Š 2â”Š  // x1 - The first point's x value\n+â”Š  â”Š 3â”Š  // y1 - The first point's y value\n+â”Š  â”Š 4â”Š  // x1 - The second point's x value\n+â”Š  â”Š 5â”Š  // y2 - The second point's y value\n+â”Š  â”Š 6â”Š  constructor(x1, y1, x2, y2) {\n+â”Š  â”Š 7â”Š    this.x1 = Utils.trim(x1, 9);\n+â”Š  â”Š 8â”Š    this.y1 = Utils.trim(y1, 9);\n+â”Š  â”Š 9â”Š    this.x2 = Utils.trim(x2, 9);\n+â”Š  â”Š10â”Š    this.y2 = Utils.trim(y2, 9);\n+â”Š  â”Š11â”Š  }\n+â”Š  â”Š12â”Š\n+â”Š  â”Š13â”Š  // Draws the line on the given context\n+â”Š  â”Š14â”Š  draw(context) {\n+â”Š  â”Š15â”Š    context.moveTo(this.x1, this.y1);\n+â”Š  â”Š16â”Š    context.lineTo(this.x2, this.y2);\n+â”Š  â”Š17â”Š  }\n+â”Š  â”Š18â”Š\n+â”Š  â”Š19â”Š  // Gets the matching x value for a given y value\n+â”Š  â”Š20â”Š  getX(y) {\n+â”Š  â”Š21â”Š    let x = Utils.trim((((y - this.y1) * (this.x2 - this.x1)) / (this.y2 - this.y1)) + this.x1, 9);\n+â”Š  â”Š22â”Š    if (isNaN(x) || Utils.isBetween(x, this.x1, this.x2)) return x;\n+â”Š  â”Š23â”Š  }\n+â”Š  â”Š24â”Š\n+â”Š  â”Š25â”Š  // Gets the matching y value for a given x value\n+â”Š  â”Š26â”Š  getY(x) {\n+â”Š  â”Š27â”Š    let y = Utils.trim((((x - this.x1) * (this.y2 - this.y1)) / (this.x2 - this.x1)) + this.y1, 9);\n+â”Š  â”Š28â”Š    if (isNaN(y) || Utils.isBetween(y, this.y1, this.y2)) return y;\n+â”Š  â”Š29â”Š  }\n+â”Š  â”Š30â”Š\n+â”Š  â”Š31â”Š  // Returns if line has given point\n+â”Š  â”Š32â”Š  hasPoint(x, y) {\n+â”Š  â”Š33â”Š    if (!this.boundsHavePoint(x, y)) return false;\n+â”Š  â”Š34â”Š    let m = Utils.trim((this.y2 - this.y1) / (this.x2 - this.x1), 9);\n+â”Š  â”Š35â”Š    return (y - this.y1) / (x - this.x1) == m;\n+â”Š  â”Š36â”Š  }\n+â”Š  â”Š37â”Š\n+â”Š  â”Š38â”Š  // Returns if given point is contained by the bounds aka cage of line\n+â”Š  â”Š39â”Š  boundsHavePoint(x, y) {\n+â”Š  â”Š40â”Š    return Utils.isBetween(x, this.x1, this.x2) &&\n+â”Š  â”Š41â”Š           Utils.isBetween(y, this.y1, this.y2);\n+â”Š  â”Š42â”Š  }\n+â”Š  â”Š43â”Š\n+â”Š  â”Š44â”Š  getIntersection(shape) {\n+â”Š  â”Š45â”Š    if (shape instanceof Engine.Geometry.Line)\n+â”Š  â”Š46â”Š      return this.getLineIntersection(shape);\n+â”Š  â”Š47â”Š  }\n+â”Š  â”Š48â”Š\n+â”Š  â”Š49â”Š  // line - line intersection method\n+â”Š  â”Š50â”Š  getLineIntersection(line) {\n+â”Š  â”Š51â”Š    // Escape if lines are parallel\n+â”Š  â”Š52â”Š    if (!(((this.x1 - this.x2) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * (line.x1 - line.x2)))) return;\n+â”Š  â”Š53â”Š\n+â”Š  â”Š54â”Š    // Intersection point formula\n+â”Š  â”Š55â”Š    let x = Utils.trim(((((this.x1 * this.y2) - (this.y1 * this.x2)) * (line.x1 - line.x2)) - ((this.x1 - this.x2) * ((line.x1 * line.y2) - (line.y1 * line.x2)))) /\n+â”Š  â”Š56â”Š        (((this.x1 - this.x2) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * (line.x1 - line.x2))), 9);\n+â”Š  â”Š57â”Š    let y = Utils.trim(((((this.x1 * this.y2) - (this.y1 * this.x2)) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * ((line.x1 * line.y2) - (line.y1 * line.x2)))) /\n+â”Š  â”Š58â”Š        (((this.x1 - this.x2) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * (line.x1 - line.x2))), 9);\n+â”Š  â”Š59â”Š\n+â”Š  â”Š60â”Š    if (Utils.isBetween(x, this.x1, this.x2) && Utils.isBetween(x, line.x1, line.x2) &&\n+â”Š  â”Š61â”Š        Utils.isBetween(y, this.y1, this.y2) && Utils.isBetween(y, line.y1, line.y2)) {\n+â”Š  â”Š62â”Š      return { x, y };\n+â”Š  â”Š63â”Š    }\n+â”Š  â”Š64â”Š  }\n+â”Š  â”Š65â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -10,6 +10,7 @@\n â”Š10â”Š10â”Š    <!-- Scripts -->\n â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/utils.js\"></script>\n â”Š12â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n+â”Š  â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/geometry/line.js\"></script>\n â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/restorable.js\"></script>\n â”Š14â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/font.js\"></script>\n â”Š15â”Š16â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/sprite.js\"></script>\n```\n\n[}]: #\n\nYou can go through the comments of the step above which will guide you through the programmatic aspect of it, but I think it's more important to understand the concept of a line in 2D space. A line is made out of two points, usually represented as `(x1, y1)` and `(x2, y2)`. The slope of the line, usually represented as `m`, can be determined using these two points based on the following formula:\n\n![slope](https://cloud.githubusercontent.com/assets/7648874/21788249/b4c7e41c-d6b4-11e6-9c17-baff66ec6bc8.png)\n\nOnce we have two lines whose `m` is different (Unparalleled) and there is no intersection between the points of which they are represented with (In which case they are united), there must be an intersection point. The intersection point can be found using the following formula:\n\n![line-line](https://cloud.githubusercontent.com/assets/7648874/21787164/c9d83bf0-d6ae-11e6-9846-4fc013eebab3.png)\n\n![line-line-illustration](https://cloud.githubusercontent.com/assets/7648874/21790864/56725cf0-d6c6-11e6-916b-50b1fc0b87af.png)\n\n> See reference: http://mathworld.wolfram.com/Line-LineIntersection.html.\n\nObviously we have some logic here which needs to be tested. To test our `Line` class, we will be using a testing framework called [Jasmine](https://jasmine.github.io/). We first need to download `Jasmine`'s essentials in order for it to work:\n\n    resources/libs$ mkdir jasmine\n    resources/libs$ cd jasmine\n    resources/libs/jasmine$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/libs/jasmine/boot.js\n    resources/libs/jasmine$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/libs/jasmine/console.js\n    resources/libs/jasmine$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/libs/jasmine/jasmine-html.js\n    resources/libs/jasmine$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/libs/jasmine/jasmine.css\n    resources/libs/jasmine$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/libs/jasmine/jasmine.js\n    resources/libs/jasmine$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/libs/jasmine/jasmine_favicon.png\n\nThese essentials should be loaded in a newly created view where we're gonna see our specs running:\n\n[{]: <helper> (diffStep 5.5)\n\n#### [Step 5.5: Create specs runner view](https://github.com/DAB0mB/radial-snake/commit/150be1a)\n\n##### Added views&#x2F;spec_runner.html\n```diff\n@@ -0,0 +1,27 @@\n+â”Š  â”Š 1â”Š\n+â”Š  â”Š 2â”Š<!DOCTYPE html>\n+â”Š  â”Š 3â”Š<html>\n+â”Š  â”Š 4â”Š  <head>\n+â”Š  â”Š 5â”Š    <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n+â”Š  â”Š 6â”Š    <title>Jasmine Spec Runner v2.0.1</title>\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Š    <!-- Jasmine -->\n+â”Š  â”Š 9â”Š    <script type=\"text/javascript\" src=\"libs/jasmine/jasmine.js\"></script>\n+â”Š  â”Š10â”Š    <script type=\"text/javascript\" src=\"libs/jasmine/jasmine-html.js\"></script>\n+â”Š  â”Š11â”Š    <script type=\"text/javascript\" src=\"libs/jasmine/boot.js\"></script>\n+â”Š  â”Š12â”Š    <link rel=\"shortcut icon\" type=\"image/png\" href=\"libs/jasmine/jasmine_favicon.png\">\n+â”Š  â”Š13â”Š    <link rel=\"stylesheet\" type=\"text/css\" href=\"libs/jasmine/jasmine.css\">\n+â”Š  â”Š14â”Š\n+â”Š  â”Š15â”Š    <!-- Libs -->\n+â”Š  â”Š16â”Š    <script type=\"text/javascript\" src=\"libs/underscore.js\"></script>\n+â”Š  â”Š17â”Š\n+â”Š  â”Š18â”Š    <!-- Scripts -->\n+â”Š  â”Š19â”Š    <script type=\"text/javascript\" src=\"scripts/utils.js\"></script>\n+â”Š  â”Š20â”Š    <script type=\"text/javascript\" src=\"scripts/namespaces.js\"></script>\n+â”Š  â”Š21â”Š\n+â”Š  â”Š22â”Š    <!-- Specs -->\n+â”Š  â”Š23â”Š  </head>\n+â”Š  â”Š24â”Š\n+â”Š  â”Š25â”Š  <body>\n+â”Š  â”Š26â”Š  </body>\n+â”Š  â”Š27â”Š</html>ðŸš«â†µ\n```\n\n[}]: #\n\nNow once we'll navigate to the `/test` sub-route (`localhost:8000/test` by default) we should be provided with the spec runner. As for now there are no specs implemented at all, which brings us to the next stage - Implementing tests for `Line` class:\n\n[{]: <helper> (diffStep 5.6)\n\n#### [Step 5.6: Create &#x27;Line&#x27; class tests](https://github.com/DAB0mB/radial-snake/commit/c052752)\n\n##### Added resources&#x2F;scripts&#x2F;specs&#x2F;engine&#x2F;geometry&#x2F;line.js\n```diff\n@@ -0,0 +1,78 @@\n+â”Š  â”Š 1â”Šdescribe(\"Engine.Geometry.Line class\", function() {\n+â”Š  â”Š 2â”Š  beforeEach(function() {\n+â”Š  â”Š 3â”Š    this.line = new Engine.Geometry.Line(-5, -5, 5, 5);\n+â”Š  â”Š 4â”Š  });\n+â”Š  â”Š 5â”Š\n+â”Š  â”Š 6â”Š  describe(\"getX method\", function() {\n+â”Š  â”Š 7â”Š    describe(\"given inranged y\", function() {\n+â”Š  â”Š 8â”Š      it(\"returns x\", function() {\n+â”Š  â”Š 9â”Š        expect(this.line.getX(1)).toBeCloseTo(1);\n+â”Š  â”Š10â”Š      });\n+â”Š  â”Š11â”Š    });\n+â”Š  â”Š12â”Š\n+â”Š  â”Š13â”Š    describe(\"given outranged y\", function() {\n+â”Š  â”Š14â”Š      it(\"returns nothing\", function() {\n+â”Š  â”Š15â”Š        expect(this.line.getX(10)).toBeUndefined();\n+â”Š  â”Š16â”Š      });\n+â”Š  â”Š17â”Š    });\n+â”Š  â”Š18â”Š  });\n+â”Š  â”Š19â”Š\n+â”Š  â”Š20â”Š  describe(\"getY method\", function() {\n+â”Š  â”Š21â”Š    describe(\"given inranged x\", function() {\n+â”Š  â”Š22â”Š      it(\"returns y\", function() {\n+â”Š  â”Š23â”Š        expect(this.line.getY(1)).toBeCloseTo(1);\n+â”Š  â”Š24â”Š      });\n+â”Š  â”Š25â”Š    });\n+â”Š  â”Š26â”Š\n+â”Š  â”Š27â”Š    describe(\"given outranged x\", function() {\n+â”Š  â”Š28â”Š      it(\"returns nothing\", function() {\n+â”Š  â”Š29â”Š        expect(this.line.getY(10)).toBeUndefined();\n+â”Š  â”Š30â”Š      });\n+â”Š  â”Š31â”Š    });\n+â”Š  â”Š32â”Š  });\n+â”Š  â”Š33â”Š\n+â”Š  â”Š34â”Š  describe(\"hasPoint method\", function() {\n+â”Š  â”Š35â”Š    describe(\"given contained point\", function() {\n+â”Š  â”Š36â”Š      it(\"returns true\", function() {\n+â”Š  â”Š37â”Š        let x = 1;\n+â”Š  â”Š38â”Š        let y = 1;\n+â”Š  â”Š39â”Š        expect(this.line.hasPoint(x, y)).toBeTruthy();\n+â”Š  â”Š40â”Š      });\n+â”Š  â”Š41â”Š    });\n+â”Š  â”Š42â”Š\n+â”Š  â”Š43â”Š    describe(\"given uncontained point\", function() {\n+â”Š  â”Š44â”Š      it(\"returns false\", function() {\n+â”Š  â”Š45â”Š        let x = 10;\n+â”Š  â”Š46â”Š        let y = 10;\n+â”Š  â”Š47â”Š        expect(this.line.hasPoint(x, y)).toBeFalsy();\n+â”Š  â”Š48â”Š      });\n+â”Š  â”Š49â”Š    });\n+â”Š  â”Š50â”Š  });\n+â”Š  â”Š51â”Š\n+â”Š  â”Š52â”Š  describe(\"getLineIntersection method\", function() {\n+â”Š  â”Š53â”Š    describe(\"given intersecting line\", function() {\n+â”Š  â”Š54â”Š      it(\"returns intersection point\", function() {\n+â”Š  â”Š55â”Š        let line = new Engine.Geometry.Line(1, -5, 1, 5);\n+â”Š  â”Š56â”Š\n+â”Š  â”Š57â”Š        expect(this.line.getLineIntersection(line)).toEqual({\n+â”Š  â”Š58â”Š          x: 1,\n+â”Š  â”Š59â”Š          y: 1\n+â”Š  â”Š60â”Š        });\n+â”Š  â”Š61â”Š      });\n+â”Š  â”Š62â”Š    });\n+â”Š  â”Š63â”Š\n+â”Š  â”Š64â”Š    describe(\"given parallel line\", function() {\n+â”Š  â”Š65â”Š      it(\"returns nothing\", function() {\n+â”Š  â”Š66â”Š        let line = new Engine.Geometry.Line(-5, -6, 5, 4);\n+â”Š  â”Š67â”Š        expect(this.line.getLineIntersection(line)).toBeUndefined();\n+â”Š  â”Š68â”Š      });\n+â”Š  â”Š69â”Š    });\n+â”Š  â”Š70â”Š\n+â”Š  â”Š71â”Š    describe(\"given outranged line\", function() {\n+â”Š  â”Š72â”Š      it(\"returns nothing\", function() {\n+â”Š  â”Š73â”Š        let line = new Engine.Geometry.Line(10, 10, 10, 15);\n+â”Š  â”Š74â”Š        expect(this.line.getLineIntersection(line)).toBeUndefined();\n+â”Š  â”Š75â”Š      });\n+â”Š  â”Š76â”Š    });\n+â”Š  â”Š77â”Š  });\n+â”Š  â”Š78â”Š});ðŸš«â†µ\n```\n\n##### Changed views&#x2F;spec_runner.html\n```diff\n@@ -18,8 +18,10 @@\n â”Š18â”Š18â”Š    <!-- Scripts -->\n â”Š19â”Š19â”Š    <script type=\"text/javascript\" src=\"scripts/utils.js\"></script>\n â”Š20â”Š20â”Š    <script type=\"text/javascript\" src=\"scripts/namespaces.js\"></script>\n+â”Š  â”Š21â”Š    <script type=\"text/javascript\" src=\"scripts/engine/geometry/line.js\"></script>\n â”Š21â”Š22â”Š\n â”Š22â”Š23â”Š    <!-- Specs -->\n+â”Š  â”Š24â”Š    <script type=\"text/javascript\" src=\"scripts/specs/engine/geometry/line.js\"></script>\n â”Š23â”Š25â”Š  </head>\n â”Š24â”Š26â”Š\n â”Š25â”Š27â”Š  <body>\n```\n\n[}]: #\n\nNow if you'll refresh the spec runner page you should be able to a green screen indicating all tests have passed (Assuming the tutorial is updated and you followed it correctly). As introduced at the beginning of the step, the snake is also dependent on circles, whose representing class should look like so:\n\n[{]: <helper> (diffStep 5.7)\n\n#### [Step 5.7: Create &#x27;Circle&#x27; class](https://github.com/DAB0mB/radial-snake/commit/f9c5723)\n\n##### Added resources&#x2F;scripts&#x2F;engine&#x2F;geometry&#x2F;circle.js\n```diff\n@@ -0,0 +1,167 @@\n+â”Š   â”Š  1â”ŠEngine.Geometry.Circle = class Circle {\n+â”Š   â”Š  2â”Š  // x - The x value of the circle's center\n+â”Š   â”Š  3â”Š  // y - The y value of the circle's center\n+â”Š   â”Š  4â”Š  // r - The radius of the center\n+â”Š   â”Š  5â”Š  // rad1 - The first radian of the circle, not necessarily its beginning\n+â”Š   â”Š  6â”Š  // rad2 - The second radian of the circle, not necessarily its beginning\n+â”Š   â”Š  7â”Š  constructor(x, y, r, rad1, rad2) {\n+â”Š   â”Š  8â”Š    this.x = Utils.trim(x, 9);\n+â”Š   â”Š  9â”Š    this.y = Utils.trim(y, 9);\n+â”Š   â”Š 10â”Š    this.r = Utils.trim(r, 9);\n+â”Š   â”Š 11â”Š\n+â”Š   â”Š 12â”Š    // Trimming mode is done based on which radian represents the ending and which radian\n+â”Š   â”Š 13â”Š    // represents the ending\n+â”Š   â”Š 14â”Š    if (rad1 > rad2) {\n+â”Š   â”Š 15â”Š      this.rad1 = Utils.trim(rad1, 9, \"floor\");\n+â”Š   â”Š 16â”Š      this.rad2 = Utils.trim(rad2, 9, \"ceil\");\n+â”Š   â”Š 17â”Š    }\n+â”Š   â”Š 18â”Š    else {\n+â”Š   â”Š 19â”Š      this.rad1 = Utils.trim(rad1, 9, \"ceil\");\n+â”Š   â”Š 20â”Š      this.rad2 = Utils.trim(rad2, 9, \"floor\");\n+â”Š   â”Š 21â”Š    }\n+â”Š   â”Š 22â”Š  }\n+â”Š   â”Š 23â”Š\n+â”Š   â”Š 24â”Š  // Draws the circle on the given context\n+â”Š   â”Š 25â”Š  draw(context) {\n+â”Š   â”Š 26â”Š    context.arc(this.x, this.y, this.r, this.rad1, this.rad2);\n+â”Š   â”Š 27â”Š  }\n+â”Š   â”Š 28â”Š\n+â”Š   â”Š 29â”Š  // Gets the matching x value for the given radian\n+â”Š   â”Š 30â”Š  getX(rad) {\n+â”Š   â”Š 31â”Š    if (!Utils(rad).trim(9).isBetween(this.rad1, this.rad2).value()) return;\n+â”Š   â”Š 32â”Š    return Utils.trim((this.r * Math.cos(rad)) + this.x, 9);\n+â”Š   â”Š 33â”Š  }\n+â”Š   â”Š 34â”Š\n+â”Š   â”Š 35â”Š  // Gets the matching y value for the given radian\n+â”Š   â”Š 36â”Š  getY(rad) {\n+â”Š   â”Š 37â”Š    if (!Utils(rad).trim(9).isBetween(this.rad1, this.rad2).value()) return;\n+â”Š   â”Š 38â”Š    return Utils.trim((this.r * Math.sin(rad)) + this.y, 9);\n+â”Š   â”Š 39â”Š  }\n+â”Š   â”Š 40â”Š\n+â”Š   â”Š 41â”Š  // Gets the matching point for the given radian\n+â”Š   â”Š 42â”Š  getPoint(rad) {\n+â”Š   â”Š 43â”Š    if (!Utils.isBetween(rad, this.rad1, this.rad2)) return;\n+â”Š   â”Š 44â”Š\n+â”Š   â”Š 45â”Š    return {\n+â”Š   â”Š 46â”Š      x: Utils.trim((this.r * Math.cos(rad)) + this.x, 9),\n+â”Š   â”Š 47â”Š      y: Utils.trim((this.r * Math.sin(rad)) + this.y, 9)\n+â”Š   â”Š 48â”Š    };\n+â”Š   â”Š 49â”Š  }\n+â”Š   â”Š 50â”Š\n+â”Š   â”Š 51â”Š  // Gets the matching radian for the given point\n+â”Š   â”Š 52â”Š  getRad(x, y) {\n+â”Š   â”Š 53â”Š    let rad = Math.atan2(y - this.y, x - this.x);\n+â”Š   â”Š 54â”Š\n+â”Š   â”Š 55â”Š    // If calculated radian is in circle's radian range, return it\n+â”Š   â”Š 56â”Š    if (rad != null && Utils.isBetween(rad, this.rad1, this.rad2)) {\n+â”Š   â”Š 57â”Š      return rad;\n+â”Š   â”Š 58â”Š    }\n+â”Š   â”Š 59â”Š\n+â”Š   â”Š 60â”Š    // The calculated radian can still be in the circle's radian range in case one\n+â”Š   â”Š 61â”Š    // of the radians is greater than 2 PIEs\n+â”Š   â”Š 62â”Š    if (Math.abs(this.rad1) > Math.abs(this.rad2)) {\n+â”Š   â”Š 63â”Š      var greatestRad = this.rad1;\n+â”Š   â”Š 64â”Š    }\n+â”Š   â”Š 65â”Š    else {\n+â”Š   â”Š 66â”Š      var greatestRad = this.rad2;\n+â”Š   â”Š 67â”Š    }\n+â”Š   â”Š 68â”Š\n+â”Š   â”Š 69â”Š    // Check if the absolute radian is in the circle's radian range\n+â”Š   â”Š 70â”Š    if (Utils(rad + (2 * Math.PI * Math.floor(greatestRad / (2 * Math.PI)))).trim(9).isBetween(this.rad1, this.rad2).value() ||\n+â”Š   â”Š 71â”Š        Utils(rad + (2 * Math.PI * Math.ceil(greatestRad / (2 * Math.PI)))).trim(9).isBetween(this.rad1, this.rad2).value()) {\n+â”Š   â”Š 72â”Š      return rad;\n+â”Š   â”Š 73â”Š    }\n+â”Š   â”Š 74â”Š  }\n+â”Š   â”Š 75â”Š\n+â”Š   â”Š 76â”Š  // Returns if circle has given points\n+â”Š   â”Š 77â”Š  hasPoint(x, y) {\n+â”Š   â”Š 78â”Š    return this.getRad(x, y) != null;\n+â”Š   â”Š 79â”Š  }\n+â”Š   â”Š 80â”Š\n+â”Š   â”Š 81â”Š  getIntersection(shape) {\n+â”Š   â”Š 82â”Š    if (shape instanceof Engine.Geometry.Line)\n+â”Š   â”Š 83â”Š      return this.getLineIntersection(shape);\n+â”Š   â”Š 84â”Š    if (shape instanceof Engine.Geometry.Circle)\n+â”Š   â”Š 85â”Š      return this.getCircleIntersection(shape);\n+â”Š   â”Š 86â”Š  }\n+â”Š   â”Š 87â”Š\n+â”Š   â”Š 88â”Š  // circle - circle intersection method\n+â”Š   â”Š 89â”Š  getCircleIntersection(circle) {\n+â”Š   â”Š 90â”Š    let dx = circle.x - this.x;\n+â”Š   â”Š 91â”Š    let dy = circle.y - this.y;\n+â”Š   â”Š 92â”Š    let d = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\n+â”Š   â”Š 93â”Š\n+â”Š   â”Š 94â”Š    if (d > this.r + circle.r ||\n+â”Š   â”Š 95â”Š       d < Math.abs(this.r - circle.r)) {\n+â”Š   â”Š 96â”Š      return;\n+â”Š   â”Š 97â”Š    }\n+â”Š   â”Š 98â”Š\n+â”Š   â”Š 99â”Š    let a = ((Math.pow(this.r, 2) - Math.pow(circle.r, 2)) + Math.pow(d, 2)) / (2 * d);\n+â”Š   â”Š100â”Š    let x = this.x + ((dx * a) / d);\n+â”Š   â”Š101â”Š    let y = this.y + ((dy * a) / d);\n+â”Š   â”Š102â”Š    let h = Math.sqrt(Math.pow(this.r, 2) - Math.pow(a, 2));\n+â”Š   â”Š103â”Š    let rx = (- dy * h) / d;\n+â”Š   â”Š104â”Š    let ry = (dx * h) / d;\n+â”Š   â”Š105â”Š\n+â”Š   â”Š106â”Š    let interPoints = [\n+â”Š   â”Š107â”Š      {\n+â”Š   â”Š108â”Š        x: x + rx,\n+â”Š   â”Š109â”Š        y: y + ry\n+â”Š   â”Š110â”Š      },\n+â”Š   â”Š111â”Š      {\n+â”Š   â”Š112â”Š        x: x - rx,\n+â”Š   â”Š113â”Š        y: y - ry\n+â”Š   â”Š114â”Š      }\n+â”Š   â”Š115â”Š    ]\n+â”Š   â”Š116â”Š    .map(point => ({\n+â”Š   â”Š117â”Š        x: Utils.trim(point.x, 9),\n+â”Š   â”Š118â”Š        y: Utils.trim(point.y, 9)\n+â”Š   â”Š119â”Š     }));\n+â”Š   â”Š120â”Š\n+â”Š   â”Š121â”Š    interPoints = _.uniq(interPoints, point => `(${point.x}, ${point.y})`);\n+â”Š   â”Š122â”Š\n+â”Š   â”Š123â”Š    [this, circle].forEach(function(circle) {\n+â”Š   â”Š124â”Š      interPoints = interPoints.filter(point => circle.hasPoint(point.x, point.y));\n+â”Š   â”Š125â”Š    });\n+â”Š   â”Š126â”Š\n+â”Š   â”Š127â”Š    if (interPoints.length > 0) return interPoints;\n+â”Š   â”Š128â”Š  }\n+â”Š   â”Š129â”Š\n+â”Š   â”Š130â”Š  // circle - line intersection method\n+â”Š   â”Š131â”Š  getLineIntersection(line) {\n+â”Š   â”Š132â”Š    let x1 = line.x1 - this.x;\n+â”Š   â”Š133â”Š    let x2 = line.x2 - this.x;\n+â”Š   â”Š134â”Š    let y1 = line.y1 - this.y;\n+â”Š   â”Š135â”Š    let y2 = line.y2 - this.y;\n+â”Š   â”Š136â”Š    let dx = x2 - x1;\n+â”Š   â”Š137â”Š    let dy = y2 - y1;\n+â”Š   â”Š138â”Š    let d = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\n+â”Š   â”Š139â”Š    let h = (x1 * y2) - (x2 * y1);\n+â”Š   â”Š140â”Š    let delta = (Math.pow(this.r, 2) * Math.pow(d, 2)) - Math.pow(h, 2);\n+â”Š   â”Š141â”Š\n+â”Š   â”Š142â”Š    if (delta < 0) return;\n+â”Š   â”Š143â”Š\n+â”Š   â”Š144â”Š    let interPoints = [\n+â”Š   â”Š145â”Š      {\n+â”Š   â”Š146â”Š        x: (((h * dy) + (((dy / Math.abs(dy)) || 1) * dx * Math.sqrt(delta))) / Math.pow(d, 2)) + this.x,\n+â”Š   â”Š147â”Š        y: (((-h * dx) + (Math.abs(dy) * Math.sqrt(delta))) / Math.pow(d, 2)) + this.y\n+â”Š   â”Š148â”Š      },\n+â”Š   â”Š149â”Š      {\n+â”Š   â”Š150â”Š        x: (((h * dy) - (((dy / Math.abs(dy)) || 1) * dx * Math.sqrt(delta))) / Math.pow(d, 2)) + this.x,\n+â”Š   â”Š151â”Š        y: (((-h * dx) - (Math.abs(dy) * Math.sqrt(delta))) / Math.pow(d, 2)) + this.y\n+â”Š   â”Š152â”Š      }\n+â”Š   â”Š153â”Š    ]\n+â”Š   â”Š154â”Š    .map(point => ({\n+â”Š   â”Š155â”Š        x: Utils.trim(point.x, 9),\n+â”Š   â”Š156â”Š        y: Utils.trim(point.y, 9)\n+â”Š   â”Š157â”Š    }))\n+â”Š   â”Š158â”Š    .filter(point => {\n+â”Š   â”Š159â”Š      return this.hasPoint(point.x, point.y) &&\n+â”Š   â”Š160â”Š        line.boundsHavePoint(point.x, point.y);\n+â”Š   â”Š161â”Š    });\n+â”Š   â”Š162â”Š\n+â”Š   â”Š163â”Š    interPoints = _.uniq(interPoints, point => `(${point.x}, ${point.y})`);\n+â”Š   â”Š164â”Š\n+â”Š   â”Š165â”Š    if (interPoints.length > 0) return interPoints;\n+â”Š   â”Š166â”Š  }\n+â”Š   â”Š167â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -11,6 +11,7 @@\n â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/utils.js\"></script>\n â”Š12â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n â”Š13â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/geometry/line.js\"></script>\n+â”Š  â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/geometry/circle.js\"></script>\n â”Š14â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/restorable.js\"></script>\n â”Š15â”Š16â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/font.js\"></script>\n â”Š16â”Š17â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/sprite.js\"></script>\n```\n\n[}]: #\n\nJust like a line, a circle can be presented using variables as well. The center of the circle is represented as `(x, y)` and its radius is represented as `r`. Remember that our circle doesn't necessarily have to be a full one, therefore we limit its range using two radians - `rad1` and `rad2`. The formula for representing a circle in a 2D space looks like this:\n\n![circle-formula](https://cloud.githubusercontent.com/assets/7648874/21829783/84a54574-d77f-11e6-9b87-3fb0f073bb8d.png)\n\n![circle-circle-illustration](https://cloud.githubusercontent.com/assets/7648874/21790842/3a73408c-d6c6-11e6-8bdd-9c73355e6ebb.png)\n\n> `a` and `b` represent the offsets from the `x` and the `y` axes respectively.\n> See reference: http://mathworld.wolfram.com/Circle-CircleIntersection.html.\n\nTo find intersection between two circles, we simply calculate the solution for two equations with two variables. Given that a line can be represented in a 2D space using the following formula:\n\n![line-formula](https://cloud.githubusercontent.com/assets/7648874/21790671/1609c050-d6c5-11e6-8bd7-16cc306f5eea.png)\n\n![circle-line-illustration](https://cloud.githubusercontent.com/assets/7648874/21790810/1a052086-d6c6-11e6-9c5c-24298fedb043.png)\n\n> `n` represents the intersection value with the `y` axis.\n> See reference: http://mathworld.wolfram.com/Circle-LineIntersection.html.\n\nwe can find the intersection between a circle and line by solving the systems formed by the equations of both. We also want the line-circle algorithm to be available for any `Line` instance, therefore we gonna add the following delegate on the `Line` prototype:\n\n[{]: <helper> (diffStep 5.8)\n\n#### [Step 5.8: Delegate circle intersection methods](https://github.com/DAB0mB/radial-snake/commit/19828bf)\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;geometry&#x2F;line.js\n```diff\n@@ -44,6 +44,8 @@\n â”Š44â”Š44â”Š  getIntersection(shape) {\n â”Š45â”Š45â”Š    if (shape instanceof Engine.Geometry.Line)\n â”Š46â”Š46â”Š      return this.getLineIntersection(shape);\n+â”Š  â”Š47â”Š    if (shape instanceof Engine.Geometry.Circle)\n+â”Š  â”Š48â”Š      return this.getCircleIntersection(shape);\n â”Š47â”Š49â”Š  }\n â”Š48â”Š50â”Š\n â”Š49â”Š51â”Š  // line - line intersection method\n```\n```diff\n@@ -62,4 +64,9 @@\n â”Š62â”Š64â”Š      return { x, y };\n â”Š63â”Š65â”Š    }\n â”Š64â”Š66â”Š  }\n+â”Š  â”Š67â”Š\n+â”Š  â”Š68â”Š  // line - circle intersection method\n+â”Š  â”Š69â”Š  getCircleIntersection(circle) {\n+â”Š  â”Š70â”Š    return circle.getLineIntersection(this);\n+â”Š  â”Š71â”Š  }\n â”Š65â”Š72â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nThen again a newly created geometry shape class should be tested against different scenarios:\n\n[{]: <helper> (diffStep 5.9)\n\n#### [Step 5.9: Create &#x27;Circle&#x27; class tests](https://github.com/DAB0mB/radial-snake/commit/1d98a6e)\n\n##### Added resources&#x2F;scripts&#x2F;specs&#x2F;engine&#x2F;geometry&#x2F;circle.js\n```diff\n@@ -0,0 +1,144 @@\n+â”Š   â”Š  1â”Šdescribe(\"Engine.Geometry.Circle class\", function() {\n+â”Š   â”Š  2â”Š  beforeEach(function() {\n+â”Š   â”Š  3â”Š    this.circle = new Engine.Geometry.Circle(1, 1, 5, 0, 1.5 * Math.PI);\n+â”Š   â”Š  4â”Š  });\n+â”Š   â”Š  5â”Š\n+â”Š   â”Š  6â”Š  describe(\"getX method\", function() {\n+â”Š   â”Š  7â”Š    describe(\"given inranged rad\", function() {\n+â”Š   â”Š  8â”Š      it(\"returns x\", function() {\n+â”Š   â”Š  9â”Š        expect(this.circle.getX(0 * Math.PI)).toBeCloseTo(6);\n+â”Š   â”Š 10â”Š        expect(this.circle.getX(0.5 * Math.PI)).toBeCloseTo(1);\n+â”Š   â”Š 11â”Š        expect(this.circle.getX(1 * Math.PI)).toBeCloseTo(-4);\n+â”Š   â”Š 12â”Š        expect(this.circle.getX(1.5 * Math.PI)).toBeCloseTo(1);\n+â”Š   â”Š 13â”Š      });\n+â”Š   â”Š 14â”Š    });\n+â”Š   â”Š 15â”Š\n+â”Š   â”Š 16â”Š    describe(\"given outranged rad\", function() {\n+â”Š   â”Š 17â”Š      it(\"returns nothing\", function() {\n+â”Š   â”Š 18â”Š        expect(this.circle.getX(2 * Math.PI)).toBeUndefined();\n+â”Š   â”Š 19â”Š      });\n+â”Š   â”Š 20â”Š    });\n+â”Š   â”Š 21â”Š  });\n+â”Š   â”Š 22â”Š\n+â”Š   â”Š 23â”Š  describe(\"getY method\", function() {\n+â”Š   â”Š 24â”Š    describe(\"given inranged rad\", function() {\n+â”Š   â”Š 25â”Š      it(\"returns y\", function() {\n+â”Š   â”Š 26â”Š        expect(this.circle.getY(0 * Math.PI)).toBeCloseTo(1);\n+â”Š   â”Š 27â”Š        expect(this.circle.getY(0.5 * Math.PI)).toBeCloseTo(6);\n+â”Š   â”Š 28â”Š        expect(this.circle.getY(1 * Math.PI)).toBeCloseTo(1);\n+â”Š   â”Š 29â”Š        expect(this.circle.getY(1.5 * Math.PI)).toBeCloseTo(-4);\n+â”Š   â”Š 30â”Š      });\n+â”Š   â”Š 31â”Š    });\n+â”Š   â”Š 32â”Š\n+â”Š   â”Š 33â”Š    describe(\"given outranged rad\", function() {\n+â”Š   â”Š 34â”Š      it(\"returns nothing\", function() {\n+â”Š   â”Š 35â”Š        expect(this.circle.getY(2 * Math.PI)).toBeUndefined();\n+â”Š   â”Š 36â”Š      });\n+â”Š   â”Š 37â”Š    });\n+â”Š   â”Š 38â”Š  });\n+â”Š   â”Š 39â”Š\n+â”Š   â”Š 40â”Š  describe(\"getRad method\", function() {\n+â”Š   â”Š 41â”Š    describe(\"given inranged point\", function() {\n+â”Š   â”Š 42â”Š      it(\"returns rad\", function() {\n+â”Š   â”Š 43â”Š        let x = -3.0450849718747346;\n+â”Š   â”Š 44â”Š        let y = 3.9389262614623686;\n+â”Š   â”Š 45â”Š        expect(this.circle.getRad(x, y)).toBeCloseTo(0.8 * Math.PI);\n+â”Š   â”Š 46â”Š      });\n+â”Š   â”Š 47â”Š    });\n+â”Š   â”Š 48â”Š\n+â”Š   â”Š 49â”Š    describe(\"given outranged point\", function() {\n+â”Š   â”Š 50â”Š      it(\"returns nothing\", function() {\n+â”Š   â”Š 51â”Š        let x = 5.045084971874736;\n+â”Š   â”Š 52â”Š        let y = -1.9389262614623664;\n+â”Š   â”Š 53â”Š        expect(this.circle.getRad(x, y)).toBeUndefined();\n+â”Š   â”Š 54â”Š      });\n+â”Š   â”Š 55â”Š    });\n+â”Š   â”Š 56â”Š  });\n+â”Š   â”Š 57â”Š\n+â”Š   â”Š 58â”Š  describe(\"getCircleIntersection method\", function() {\n+â”Š   â”Š 59â”Š    describe(\"given circle with 2 intersection points\", function() {\n+â”Š   â”Š 60â”Š      it(\"returns array with intersection points\", function() {\n+â”Š   â”Š 61â”Š        let circle = new Engine.Geometry.Circle(-5, 1, 5, 0, 2 * Math.PI);\n+â”Š   â”Š 62â”Š\n+â”Š   â”Š 63â”Š        expect(this.circle.getCircleIntersection(circle)).toEqual([\n+â”Š   â”Š 64â”Š          { x: -2, y: -3 },\n+â”Š   â”Š 65â”Š          { x: -2, y: 5 }\n+â”Š   â”Š 66â”Š        ]);\n+â”Š   â”Š 67â”Š      });\n+â”Š   â”Š 68â”Š    });\n+â”Š   â”Š 69â”Š\n+â”Š   â”Š 70â”Š    describe(\"given circle with 1 intersection points\", function() {\n+â”Š   â”Š 71â”Š      it(\"returns array with intersection point\", function() {\n+â”Š   â”Š 72â”Š        let circle = new Engine.Geometry.Circle(-5, 1, 5, 0, 1 * Math.PI);\n+â”Š   â”Š 73â”Š\n+â”Š   â”Š 74â”Š        expect(this.circle.getCircleIntersection(circle)).toEqual([\n+â”Š   â”Š 75â”Š          { x: -2, y: 5 }\n+â”Š   â”Š 76â”Š        ]);\n+â”Š   â”Š 77â”Š      });\n+â”Š   â”Š 78â”Š    });\n+â”Š   â”Š 79â”Š\n+â”Š   â”Š 80â”Š    describe(\"given kissing circle\", function() {\n+â”Š   â”Š 81â”Š      it(\"returns array with intersection point\", function() {\n+â”Š   â”Š 82â”Š        let circle = new Engine.Geometry.Circle(-9, 1, 5, 0, 2 * Math.PI);\n+â”Š   â”Š 83â”Š\n+â”Š   â”Š 84â”Š        expect(this.circle.getCircleIntersection(circle)).toEqual([\n+â”Š   â”Š 85â”Š          { x: -4, y: 1 }\n+â”Š   â”Š 86â”Š        ]);\n+â”Š   â”Š 87â”Š      });\n+â”Š   â”Š 88â”Š    });\n+â”Š   â”Š 89â”Š\n+â”Š   â”Š 90â”Š    describe(\"given outer circle\", function() {\n+â”Š   â”Š 91â”Š      it(\"returns nothing\", function() {\n+â”Š   â”Š 92â”Š        let circle = new Engine.Geometry.Circle(10, 10, 2, 0, 2 * Math.PI);\n+â”Š   â”Š 93â”Š        expect(this.circle.getCircleIntersection(circle)).toBeUndefined();\n+â”Š   â”Š 94â”Š      });\n+â”Š   â”Š 95â”Š    });\n+â”Š   â”Š 96â”Š\n+â”Š   â”Š 97â”Š    describe(\"given inner circle\", function() {\n+â”Š   â”Š 98â”Š      it(\"nothing\", function() {\n+â”Š   â”Š 99â”Š        let circle = new Engine.Geometry.Circle(1, 1, 2, 0, 2 * Math.PI);\n+â”Š   â”Š100â”Š        expect(this.circle.getCircleIntersection(circle)).toBeUndefined();\n+â”Š   â”Š101â”Š      });\n+â”Š   â”Š102â”Š    });\n+â”Š   â”Š103â”Š  });\n+â”Š   â”Š104â”Š\n+â”Š   â”Š105â”Š  describe(\"getLineIntersection method\", function() {\n+â”Š   â”Š106â”Š    describe(\"given line with 2 intersection points\", function() {\n+â”Š   â”Š107â”Š      it(\"returns array with intersection points\", function() {\n+â”Š   â”Š108â”Š        let line = new Engine.Geometry.Line(-10, 1, 10, 1);\n+â”Š   â”Š109â”Š\n+â”Š   â”Š110â”Š        expect(this.circle.getLineIntersection(line)).toEqual([\n+â”Š   â”Š111â”Š          { x: 6, y: 1 },\n+â”Š   â”Š112â”Š          { x: -4, y: 1 }\n+â”Š   â”Š113â”Š        ]);\n+â”Š   â”Š114â”Š      });\n+â”Š   â”Š115â”Š    });\n+â”Š   â”Š116â”Š\n+â”Š   â”Š117â”Š    describe(\"given line with 1 intersection point\", function() {\n+â”Š   â”Š118â”Š      it(\"returns array with intersection point\", function() {\n+â”Š   â”Š119â”Š        let line = new Engine.Geometry.Line(-10, 1, 1, 1);\n+â”Š   â”Š120â”Š\n+â”Š   â”Š121â”Š        expect(this.circle.getLineIntersection(line)).toEqual([\n+â”Š   â”Š122â”Š          { x: -4, y: 1 }\n+â”Š   â”Š123â”Š        ]);\n+â”Š   â”Š124â”Š      });\n+â”Š   â”Š125â”Š    });\n+â”Š   â”Š126â”Š\n+â”Š   â”Š127â”Š    describe(\"given kissing line\", function() {\n+â”Š   â”Š128â”Š      it(\"returns array with intersection point\", function() {\n+â”Š   â”Š129â”Š        let line = new Engine.Geometry.Line(-10, 6, 10, 6);\n+â”Š   â”Š130â”Š\n+â”Š   â”Š131â”Š        expect(this.circle.getLineIntersection(line)).toEqual([\n+â”Š   â”Š132â”Š          { x: 1, y: 6 }\n+â”Š   â”Š133â”Š        ]);\n+â”Š   â”Š134â”Š      });\n+â”Š   â”Š135â”Š    });\n+â”Š   â”Š136â”Š\n+â”Š   â”Š137â”Š    describe(\"given outranged line\", function() {\n+â”Š   â”Š138â”Š      it(\"returns nothing\", function() {\n+â”Š   â”Š139â”Š        let line = new Engine.Geometry.Line(-10, 10, 10, 10);\n+â”Š   â”Š140â”Š        expect(this.circle.getLineIntersection(line)).toBeUndefined();\n+â”Š   â”Š141â”Š      });\n+â”Š   â”Š142â”Š    });\n+â”Š   â”Š143â”Š  });\n+â”Š   â”Š144â”Š});ðŸš«â†µ\n```\n\n##### Changed views&#x2F;spec_runner.html\n```diff\n@@ -19,9 +19,11 @@\n â”Š19â”Š19â”Š    <script type=\"text/javascript\" src=\"scripts/utils.js\"></script>\n â”Š20â”Š20â”Š    <script type=\"text/javascript\" src=\"scripts/namespaces.js\"></script>\n â”Š21â”Š21â”Š    <script type=\"text/javascript\" src=\"scripts/engine/geometry/line.js\"></script>\n+â”Š  â”Š22â”Š    <script type=\"text/javascript\" src=\"scripts/engine/geometry/circle.js\"></script>\n â”Š22â”Š23â”Š\n â”Š23â”Š24â”Š    <!-- Specs -->\n â”Š24â”Š25â”Š    <script type=\"text/javascript\" src=\"scripts/specs/engine/geometry/line.js\"></script>\n+â”Š  â”Š26â”Š    <script type=\"text/javascript\" src=\"scripts/specs/engine/geometry/circle.js\"></script>\n â”Š25â”Š27â”Š  </head>\n â”Š26â”Š28â”Š\n â”Š27â”Š29â”Š  <body>\n```\n\n[}]: #\n\nOur final shape in the geometry module would be a polygon. Why a polygon? Since I'm planning to make the snake's movement circular, which means that once the snake hits a random boundary, he will reappear from the other side of the canvas. The collision detection between the snake and the canvas would be done using a polygon - which is simply made out of 4 lines:\n\n[{]: <helper> (diffStep 5.1)\n\n#### [Step 5.1: Create utilities module](https://github.com/DAB0mB/radial-snake/commit/58ae99a)\n\n##### Added resources&#x2F;scripts&#x2F;utils.js\n```diff\n@@ -0,0 +1,68 @@\n+â”Š  â”Š 1â”Š// A wrapper function for our utilities which will enable chaining\n+â”Š  â”Š 2â”Š// e.g. Utils().mod().trim().isBetween()...\n+â”Š  â”Š 3â”ŠUtils = function Utils(context) {\n+â”Š  â”Š 4â”Š  const chain = {};\n+â”Š  â”Š 5â”Š\n+â”Š  â”Š 6â”Š  Object.keys(Utils).forEach((utilName) => {\n+â”Š  â”Š 7â”Š    chain[utilName] = (...args) => {\n+â”Š  â”Š 8â”Š      const result = Utils[utilName](context, ...args);\n+â”Š  â”Š 9â”Š      return Utils(result);\n+â”Š  â”Š10â”Š    };\n+â”Š  â”Š11â”Š  });\n+â”Š  â”Š12â”Š\n+â”Š  â”Š13â”Š  // Returns the result of the chaining\n+â”Š  â”Š14â”Š  chain.value = () => context;\n+â”Š  â”Š15â”Š\n+â”Š  â”Š16â”Š  return chain;\n+â”Š  â”Š17â”Š};\n+â”Š  â”Š18â”Š\n+â”Š  â”Š19â”Š// Fixed modulo method which can calculate modulo of negative numbers properly\n+â”Š  â”Š20â”Š// e.g. (-803).mod(800) returns 797\n+â”Š  â”Š21â”ŠUtils.mod = function (context, num) {\n+â”Š  â”Š22â”Š  return ((context % num) + num) % num;\n+â”Š  â”Š23â”Š};\n+â”Š  â”Š24â”Š\n+â”Š  â”Š25â”Š// Trims number and leaves the number of decimals specified.\n+â”Š  â”Š26â”Š// The \"mode\" argument specifies which math function should be invoked\n+â”Š  â”Š27â”Š// right after the number has been trimmed.\n+â”Š  â”Š28â”Š// e.g. 12.12345.trim(3, \"ceil\") returns 12.124\n+â”Š  â”Š29â”ŠUtils.trim = function (context, decimals, mode = \"round\") {\n+â”Š  â”Š30â”Š  return Math[mode](context * Math.pow(10, decimals)) / Math.pow(10, decimals);\n+â”Š  â”Š31â”Š};\n+â”Š  â”Š32â”Š\n+â”Š  â”Š33â”Š// Tells if number is in specified range based on given precision.\n+â”Š  â”Š34â”Š// See the \"compare\" method for more information about precision\n+â”Š  â”Š35â”ŠUtils.isBetween = function (context, num1, num2, precision) {\n+â”Š  â”Š36â”Š  return Utils.compare(context, Math.min(num1, num2), \">=\", precision) &&\n+â”Š  â”Š37â”Š         Utils.compare(context, Math.max(num1, num2), \"<=\", precision);\n+â”Š  â”Š38â”Š};\n+â”Š  â”Š39â”Š\n+â”Š  â”Š40â”Š// Initiates comparison operator between context number and a given number, only here\n+â”Š  â”Š41â”Š// a precision can be specified\n+â”Š  â”Š42â”ŠUtils.compare = function (context, num, method, precision = method) {\n+â”Š  â”Š43â”Š  switch (precision) {\n+â”Š  â”Š44â”Š    // Fixed precision, \"almost equal\" with a deviation of Îµ\n+â”Š  â”Š45â”Š    case \"f\":\n+â”Š  â”Š46â”Š      switch (method) {\n+â”Š  â”Š47â”Š        case \"<\": case \"<=\": return context <= num + Number.EPSILON;\n+â”Š  â”Š48â”Š        case \">\": case \">=\": return context >= num - Number.EPSILON;\n+â”Š  â”Š49â”Š        default: return Math.abs(context - num) <= Number.EPSILON;\n+â”Š  â”Š50â”Š      }\n+â”Š  â”Š51â”Š    // Pixel precision, round comparison\n+â”Š  â”Š52â”Š    case \"px\":\n+â”Š  â”Š53â”Š      switch (method) {\n+â”Š  â”Š54â”Š        case \"<\": case \"<=\": return Math.round(context) <= Math.round(num);\n+â”Š  â”Š55â”Š        case \">\": case \">=\": return Math.round(context) >= Math.round(num);\n+â”Š  â”Š56â”Š        default: return Math.round(context) == Math.round(num);\n+â”Š  â”Š57â”Š      }\n+â”Š  â”Š58â”Š    // Exact precision\n+â”Š  â”Š59â”Š    default:\n+â”Š  â”Š60â”Š      switch (method) {\n+â”Š  â”Š61â”Š        case \"<\": return context < num;\n+â”Š  â”Š62â”Š        case \"<=\": return context <= num;\n+â”Š  â”Š63â”Š        case \">\": return context > num;\n+â”Š  â”Š64â”Š        case \">=\": return context >= num;\n+â”Š  â”Š65â”Š        default: return context === num;\n+â”Š  â”Š66â”Š      }\n+â”Š  â”Š67â”Š  }\n+â”Š  â”Š68â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -8,6 +8,7 @@\n â”Š 8â”Š 8â”Š    <script type=\"text/javascript\" src=\"/libs/underscore.js\"></script>\n â”Š 9â”Š 9â”Š\n â”Š10â”Š10â”Š    <!-- Scripts -->\n+â”Š  â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/utils.js\"></script>\n â”Š11â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n â”Š12â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/restorable.js\"></script>\n â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/font.js\"></script>\n```\n\n[}]: #\n\nAgain we will delegate the newly created intersection methods in the `Line` class and `Circle` class:\n\n[{]: <helper> (diffStep 5.11)\n\n#### [Step 5.11: Delegate polygon intersection methods](https://github.com/DAB0mB/radial-snake/commit/d42a5d9)\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;geometry&#x2F;circle.js\n```diff\n@@ -83,6 +83,8 @@\n â”Š83â”Š83â”Š      return this.getLineIntersection(shape);\n â”Š84â”Š84â”Š    if (shape instanceof Engine.Geometry.Circle)\n â”Š85â”Š85â”Š      return this.getCircleIntersection(shape);\n+â”Š  â”Š86â”Š    if (shape instanceof Engine.Geometry.Polygon)\n+â”Š  â”Š87â”Š      return this.getPolygonIntersection(shape);\n â”Š86â”Š88â”Š  }\n â”Š87â”Š89â”Š\n â”Š88â”Š90â”Š  // circle - circle intersection method\n```\n```diff\n@@ -164,4 +166,9 @@\n â”Š164â”Š166â”Š\n â”Š165â”Š167â”Š    if (interPoints.length > 0) return interPoints;\n â”Š166â”Š168â”Š  }\n+â”Š   â”Š169â”Š\n+â”Š   â”Š170â”Š  // circle - polygon intersection method\n+â”Š   â”Š171â”Š  getPolygonIntersection(polygon) {\n+â”Š   â”Š172â”Š    return polygon.getCircleIntersection(this);\n+â”Š   â”Š173â”Š  }\n â”Š167â”Š174â”Š};ðŸš«â†µ\n```\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;geometry&#x2F;line.js\n```diff\n@@ -46,6 +46,8 @@\n â”Š46â”Š46â”Š      return this.getLineIntersection(shape);\n â”Š47â”Š47â”Š    if (shape instanceof Engine.Geometry.Circle)\n â”Š48â”Š48â”Š      return this.getCircleIntersection(shape);\n+â”Š  â”Š49â”Š    if (shape instanceof Engine.Geometry.Polygon)\n+â”Š  â”Š50â”Š      return this.getPolygonIntersection(shape);\n â”Š49â”Š51â”Š  }\n â”Š50â”Š52â”Š\n â”Š51â”Š53â”Š  // line - line intersection method\n```\n```diff\n@@ -69,4 +71,9 @@\n â”Š69â”Š71â”Š  getCircleIntersection(circle) {\n â”Š70â”Š72â”Š    return circle.getLineIntersection(this);\n â”Š71â”Š73â”Š  }\n+â”Š  â”Š74â”Š\n+â”Š  â”Š75â”Š  // line - polygon intersection method\n+â”Š  â”Š76â”Š  getPolygonIntersection(polygon) {\n+â”Š  â”Š77â”Š    return polygon.getLineIntersection(this);\n+â”Š  â”Š78â”Š  }\n â”Š72â”Š79â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nNow we will create a some tests to make sure our newly created polygon works properly:\n\n[{]: <helper> (diffStep 5.12)\n\n#### [Step 5.12: Create &#x27;Polygon&#x27; class tests](https://github.com/DAB0mB/radial-snake/commit/f3f890b)\n\n##### Added resources&#x2F;scripts&#x2F;specs&#x2F;engine&#x2F;geometry&#x2F;polygon.js\n```diff\n@@ -0,0 +1,96 @@\n+â”Š  â”Š 1â”Šdescribe(\"Engine.Geometry.Polygon class\", function() {\n+â”Š  â”Š 2â”Š  beforeEach(function() {\n+â”Š  â”Š 3â”Š    this.polygon = new Engine.Geometry.Polygon(\n+â”Š  â”Š 4â”Š      [0, 0, 5, 0],\n+â”Š  â”Š 5â”Š      [5, 0, 5, 5],\n+â”Š  â”Š 6â”Š      [5, 5, 0, 5],\n+â”Š  â”Š 7â”Š      [0, 5, 0, 0]\n+â”Š  â”Š 8â”Š    );\n+â”Š  â”Š 9â”Š  });\n+â”Š  â”Š10â”Š\n+â”Š  â”Š11â”Š  describe(\"hasPoint method\", function() {\n+â”Š  â”Š12â”Š    describe(\"given contained point\", function() {\n+â”Š  â”Š13â”Š      it(\"returns true\", function() {\n+â”Š  â”Š14â”Š        let x = 5;\n+â”Š  â”Š15â”Š        let y = 3;\n+â”Š  â”Š16â”Š        expect(this.polygon.hasPoint(x, y)).toBeTruthy();\n+â”Š  â”Š17â”Š      });\n+â”Š  â”Š18â”Š    });\n+â”Š  â”Š19â”Š\n+â”Š  â”Š20â”Š    describe(\"given outranged point\", function() {\n+â”Š  â”Š21â”Š      it(\"returns false\", function() {\n+â”Š  â”Š22â”Š        let x = 10;\n+â”Š  â”Š23â”Š        let y = 10;\n+â”Š  â”Š24â”Š        expect(this.polygon.hasPoint(x, y)).toBeFalsy();\n+â”Š  â”Š25â”Š      });\n+â”Š  â”Š26â”Š    });\n+â”Š  â”Š27â”Š  });\n+â”Š  â”Š28â”Š\n+â”Š  â”Š29â”Š  describe(\"getLineIntersection method\", function() {\n+â”Š  â”Š30â”Š    describe(\"given intersecting line\", function() {\n+â”Š  â”Š31â”Š      it(\"returns intersection point\", function() {\n+â”Š  â”Š32â”Š        let line = new Engine.Geometry.Line(0, 1, 5, 4);\n+â”Š  â”Š33â”Š\n+â”Š  â”Š34â”Š        expect(this.polygon.getLineIntersection(line)).toEqual([\n+â”Š  â”Š35â”Š          { x: 5, y: 4 },\n+â”Š  â”Š36â”Š          { x: 0, y: 1 }\n+â”Š  â”Š37â”Š        ]);\n+â”Š  â”Š38â”Š      });\n+â”Š  â”Š39â”Š    });\n+â”Š  â”Š40â”Š\n+â”Š  â”Š41â”Š    describe(\"given outranged line\", function() {\n+â”Š  â”Š42â”Š      it(\"returns nothing\", function() {\n+â”Š  â”Š43â”Š        let line = new Engine.Geometry.Line(10, 11, 15, 14);\n+â”Š  â”Š44â”Š\n+â”Š  â”Š45â”Š        expect(this.polygon.getLineIntersection(line)).toBeUndefined();\n+â”Š  â”Š46â”Š      });\n+â”Š  â”Š47â”Š    });\n+â”Š  â”Š48â”Š  });\n+â”Š  â”Š49â”Š\n+â”Š  â”Š50â”Š  describe(\"getCircleIntersection method\", function() {\n+â”Š  â”Š51â”Š    describe(\"given circle with 2 intersection points\", function() {\n+â”Š  â”Š52â”Š      it(\"returns array with intersection points\", function() {\n+â”Š  â”Š53â”Š        let circle = new Engine.Geometry.Circle(0, 0, 2, 0, 2 * Math.PI);\n+â”Š  â”Š54â”Š\n+â”Š  â”Š55â”Š        expect(this.polygon.getCircleIntersection(circle)).toEqual([\n+â”Š  â”Š56â”Š          { x: 2, y: 0 },\n+â”Š  â”Š57â”Š          { x: 0, y: 2 }\n+â”Š  â”Š58â”Š        ]);\n+â”Š  â”Š59â”Š      });\n+â”Š  â”Š60â”Š    });\n+â”Š  â”Š61â”Š\n+â”Š  â”Š62â”Š    describe(\"given circle with 1 intersection points\", function() {\n+â”Š  â”Š63â”Š      it(\"returns array with intersection point\", function() {\n+â”Š  â”Š64â”Š        let circle = new Engine.Geometry.Circle(0, 0, 2, 0, 0.25 * Math.PI);\n+â”Š  â”Š65â”Š\n+â”Š  â”Š66â”Š        expect(this.polygon.getCircleIntersection(circle)).toEqual([\n+â”Š  â”Š67â”Š          { x: 2, y: 0 }\n+â”Š  â”Š68â”Š        ]);\n+â”Š  â”Š69â”Š      });\n+â”Š  â”Š70â”Š    });\n+â”Š  â”Š71â”Š\n+â”Š  â”Š72â”Š    describe(\"given kissing circle\", function() {\n+â”Š  â”Š73â”Š      it(\"returns array with intersection point\", function() {\n+â”Š  â”Š74â”Š        let circle = new Engine.Geometry.Circle(-3, 3, 3, 0, 2 * Math.PI);\n+â”Š  â”Š75â”Š\n+â”Š  â”Š76â”Š        expect(this.polygon.getCircleIntersection(circle)).toEqual([\n+â”Š  â”Š77â”Š          { x: 0, y: 3 }\n+â”Š  â”Š78â”Š        ]);\n+â”Š  â”Š79â”Š      });\n+â”Š  â”Š80â”Š    });\n+â”Š  â”Š81â”Š\n+â”Š  â”Š82â”Š    describe(\"given outer circle\", function() {\n+â”Š  â”Š83â”Š      it(\"returns nothing\", function() {\n+â”Š  â”Š84â”Š        let circle = new Engine.Geometry.Circle(10, 10, 2, 0, 2 * Math.PI);\n+â”Š  â”Š85â”Š        expect(this.polygon.getCircleIntersection(circle)).toBeUndefined();\n+â”Š  â”Š86â”Š      });\n+â”Š  â”Š87â”Š    });\n+â”Š  â”Š88â”Š\n+â”Š  â”Š89â”Š    describe(\"given inner circle\", function() {\n+â”Š  â”Š90â”Š      it(\"nothing\", function() {\n+â”Š  â”Š91â”Š        let circle = new Engine.Geometry.Circle(2.5, 2.5, 2, 0, 2 * Math.PI);\n+â”Š  â”Š92â”Š        expect(this.polygon.getCircleIntersection(circle)).toBeUndefined();\n+â”Š  â”Š93â”Š      });\n+â”Š  â”Š94â”Š    });\n+â”Š  â”Š95â”Š  });\n+â”Š  â”Š96â”Š});ðŸš«â†µ\n```\n\n##### Changed views&#x2F;spec_runner.html\n```diff\n@@ -20,10 +20,12 @@\n â”Š20â”Š20â”Š    <script type=\"text/javascript\" src=\"scripts/namespaces.js\"></script>\n â”Š21â”Š21â”Š    <script type=\"text/javascript\" src=\"scripts/engine/geometry/line.js\"></script>\n â”Š22â”Š22â”Š    <script type=\"text/javascript\" src=\"scripts/engine/geometry/circle.js\"></script>\n+â”Š  â”Š23â”Š    <script type=\"text/javascript\" src=\"scripts/engine/geometry/polygon.js\"></script>\n â”Š23â”Š24â”Š\n â”Š24â”Š25â”Š    <!-- Specs -->\n â”Š25â”Š26â”Š    <script type=\"text/javascript\" src=\"scripts/specs/engine/geometry/line.js\"></script>\n â”Š26â”Š27â”Š    <script type=\"text/javascript\" src=\"scripts/specs/engine/geometry/circle.js\"></script>\n+â”Š  â”Š28â”Š    <script type=\"text/javascript\" src=\"scripts/specs/engine/geometry/polygon.js\"></script>\n â”Š27â”Š29â”Š  </head>\n â”Š28â”Š30â”Š\n â”Š29â”Š31â”Š  <body>\n```\n\n[}]: #\n\nAt last, all the necessary geometry shapes are implemented and ready to use. We will now focus on the snake itself. Since our game can potentially have infinite number of entities, not necessarily just a snake, we will add the a new module under the `Game` namespace called `Entities`:\n\n[{]: <helper> (diffStep 5.13)\n\n#### [Step 5.13: Add &#x27;Entities&#x27; module to &#x27;Game&#x27; namespace](https://github.com/DAB0mB/radial-snake/commit/a0bed8c)\n\n##### Changed resources&#x2F;scripts&#x2F;namespaces.js\n```diff\n@@ -1,4 +1,5 @@\n â”Š1â”Š1â”ŠGame = {\n+â”Š â”Š2â”Š  Entities: {},\n â”Š2â”Š3â”Š  Screens: {}\n â”Š3â”Š4â”Š};\n```\n\n[}]: #\n\nAnd now we can add the `Snake` class:\n\n[{]: <helper> (diffStep 5.14)\n\n#### [Step 5.14: Create &#x27;Snake&#x27; class](https://github.com/DAB0mB/radial-snake/commit/b938ba7)\n\n##### Added resources&#x2F;scripts&#x2F;game&#x2F;entities&#x2F;snake.js\n```diff\n@@ -0,0 +1,234 @@\n+â”Š   â”Š  1â”ŠGame.Entities.Snake = class Snake {\n+â”Š   â”Š  2â”Š  // Represents a snake data-structure which will eventually appear on screen.\n+â”Š   â”Š  3â”Š  // All the properties provided to the constructor are the initial values of\n+â”Š   â”Š  4â”Š  // the snake\n+â”Š   â”Š  5â”Š  constructor(x, y, r, rad, v, color, keyStates, options) {\n+â”Š   â”Š  6â”Š    this.x = x;\n+â”Š   â”Š  7â”Š    this.y = y;\n+â”Š   â”Š  8â”Š    this.r = r;\n+â”Š   â”Š  9â”Š    this.rad = rad;\n+â”Š   â”Š 10â”Š    this.v = v;\n+â”Š   â”Š 11â”Š    this.color = color;\n+â”Š   â”Š 12â”Š    this.keyStates = keyStates;\n+â”Š   â”Š 13â”Š    // A snake is made out of many geometry shapes\n+â”Š   â”Š 14â”Š    this.shapes = [];\n+â”Š   â”Š 15â”Š    // A snake starts with a line\n+â”Š   â”Š 16â”Š    this.currentShape = new Engine.Geometry.Line(x, y, x, y);\n+â”Š   â”Š 17â”Š    this.shapes.push(this.currentShape);\n+â”Š   â”Š 18â”Š    // A score can be provided in case we want to reserve previous scores from\n+â”Š   â”Š 19â”Š    // recent matches\n+â”Š   â”Š 20â”Š    this.score = options.score || 0;\n+â”Š   â”Š 21â”Š\n+â”Š   â”Š 22â”Š    // Custom keys can be specified\n+â”Š   â”Š 23â”Š    if (options.keys && options.keys) {\n+â”Š   â”Š 24â”Š      this.leftKey = options.keys.left;\n+â”Š   â”Š 25â”Š      this.rightKey = options.keys.right;\n+â”Š   â”Š 26â”Š    }\n+â”Š   â”Š 27â”Š    // Left and right arrow keys will be used by default\n+â”Š   â”Š 28â”Š    else {\n+â”Š   â”Š 29â”Š      this.leftKey = 37; // Left arrow\n+â”Š   â”Š 30â”Š      this.rightKey = 39; // Right arrow\n+â”Š   â”Š 31â”Š    }\n+â”Š   â”Š 32â”Š  }\n+â”Š   â”Š 33â”Š\n+â”Š   â”Š 34â”Š  draw(context) {\n+â”Š   â”Š 35â”Š    // Draw all shapes in the shapes array\n+â”Š   â”Š 36â”Š    this.shapes.forEach(shape => {\n+â”Š   â”Š 37â”Š      context.save();\n+â”Š   â”Š 38â”Š      context.strokeStyle = this.color;\n+â”Š   â”Š 39â”Š      context.lineWidth = 3;\n+â”Š   â”Š 40â”Š      context.beginPath();\n+â”Š   â”Š 41â”Š\n+â”Š   â”Š 42â”Š      // Each shape has its own unique drawing method\n+â”Š   â”Š 43â”Š      shape.draw(context);\n+â”Š   â”Š 44â”Š\n+â”Š   â”Š 45â”Š      context.stroke();\n+â”Š   â”Š 46â”Š      context.restore();\n+â”Š   â”Š 47â”Š    });\n+â”Š   â”Š 48â”Š  }\n+â”Š   â”Š 49â”Š\n+â”Š   â”Š 50â”Š  update(span, width, height) {\n+â”Š   â”Š 51â”Š    // Progress made based on elapsed time and velocity\n+â”Š   â”Š 52â”Š    let step = (this.v * span) / 1000;\n+â”Š   â”Š 53â”Š\n+â”Š   â”Š 54â”Š    this.updateShapes(step, width, height);\n+â”Š   â”Š 55â”Š    this.cycleThrough(step, width, height);\n+â”Š   â”Š 56â”Š  }\n+â”Š   â”Š 57â”Š\n+â”Š   â”Š 58â”Š  // Updates shapes array based on progress made\n+â”Š   â”Š 59â”Š  updateShapes(step, width, height, options = {}) {\n+â”Š   â”Š 60â”Š    this.updateCurrentShape(step, options);\n+â”Š   â”Š 61â”Š    this.updateDirection(step, options);\n+â”Š   â”Š 62â”Š  }\n+â”Š   â”Š 63â”Š\n+â”Š   â”Š 64â”Š  // Updates current shape\n+â”Š   â”Š 65â”Š  updateCurrentShape(step, options) {\n+â”Š   â”Š 66â”Š    if (this.currentShape instanceof Engine.Geometry.Line)\n+â”Š   â”Š 67â”Š      return this.updateCurrentLine(options);\n+â”Š   â”Š 68â”Š    if (this.currentShape instanceof Engine.Geometry.Circle)\n+â”Š   â”Š 69â”Š      return this.updateCurrentCircle(options);\n+â”Š   â”Š 70â”Š  }\n+â”Š   â”Š 71â”Š\n+â”Š   â”Š 72â”Š  // Updates current shape in case it is a line\n+â”Š   â”Š 73â”Š  updateCurrentLine(options) {\n+â”Š   â”Š 74â”Š    let lastX = options.lastX || this.x;\n+â”Š   â”Š 75â”Š    let lastY = options.lastY || this.y;\n+â”Š   â”Š 76â”Š    this.x = options.x || this.currentShape.x2;\n+â”Š   â”Š 77â”Š    this.y = options.y || this.currentShape.y2;\n+â”Š   â”Š 78â”Š    this.lastBit = new Engine.Geometry.Line(lastX, lastY, this.x, this.y);\n+â”Š   â”Š 79â”Š  }\n+â”Š   â”Š 80â”Š\n+â”Š   â”Š 81â”Š  // Updates current shape in case it is a circle\n+â”Š   â”Š 82â”Š  updateCurrentCircle(options) {\n+â”Š   â”Š 83â”Š    let lastX = options.lastX || this.currentShape.x;\n+â”Š   â”Š 84â”Š    let lastY = options.lastY || this.currentShape.y;\n+â”Š   â”Š 85â”Š    let lastR = options.lastR || this.currentShape.r;\n+â”Š   â”Š 86â”Š\n+â”Š   â”Š 87â”Š    // Update logic for left rotation\n+â”Š   â”Š 88â”Š    if (this.direction == \"left\") {\n+â”Š   â”Š 89â”Š      let lastRad = this.rad + (0.5 * Math.PI);\n+â”Š   â”Š 90â”Š      let currentShapePoint = this.currentShape.getPoint(this.currentShape.rad1);\n+â”Š   â”Š 91â”Š      this.x = options.x || currentShapePoint.x;\n+â”Š   â”Š 92â”Š      this.y = options.y || currentShapePoint.y;\n+â”Š   â”Š 93â”Š      this.rad = this.currentShape.rad1 - (0.5 * Math.PI);\n+â”Š   â”Š 94â”Š      this.lastBit = new Engine.Geometry.Circle(lastX, lastY, lastR, this.currentShape.rad1, lastRad);\n+â”Š   â”Š 95â”Š    }\n+â”Š   â”Š 96â”Š    // Update logic for right rotation\n+â”Š   â”Š 97â”Š    else {\n+â”Š   â”Š 98â”Š      let lastRad = this.rad - (0.5 * Math.PI);\n+â”Š   â”Š 99â”Š      let currentShapePoint = this.currentShape.getPoint(this.currentShape.rad2);\n+â”Š   â”Š100â”Š      this.x = options.x || currentShapePoint.x;\n+â”Š   â”Š101â”Š      this.y = options.y || currentShapePoint.y;\n+â”Š   â”Š102â”Š      this.rad = this.currentShape.rad2 + (0.5 * Math.PI);\n+â”Š   â”Š103â”Š      this.lastBit = new Engine.Geometry.Circle(lastX, lastY, lastR, lastRad, this.currentShape.rad2);\n+â”Š   â”Š104â”Š    }\n+â”Š   â”Š105â”Š  }\n+â”Š   â”Š106â”Š\n+â”Š   â”Š107â”Š  updateDirection(step, options) {\n+â”Š   â”Š108â”Š    // Update the direction based on pressed key\n+â”Š   â”Š109â”Š    if (this.keyStates.get(this.leftKey))\n+â”Š   â”Š110â”Š      var direction = \"left\";\n+â”Š   â”Š111â”Š    else if (this.keyStates.get(this.rightKey))\n+â”Š   â”Š112â”Š      var direction = \"right\";\n+â”Š   â”Š113â”Š\n+â”Š   â”Š114â”Š    this.changeDirection(step, direction, options);\n+â”Š   â”Š115â”Š    this.continueDirection(step, direction, options);\n+â”Š   â”Š116â”Š  }\n+â”Š   â”Š117â”Š\n+â”Š   â”Š118â”Š  // Change the recent shape type according to the given direction\n+â”Š   â”Š119â”Š  changeDirection(step, direction, options) {\n+â”Š   â”Š120â”Š    // If there is no change in direction, abort, unless we force it\n+â”Š   â”Š121â”Š    if (direction == this.direction && !options.force) return;\n+â”Š   â”Š122â”Š\n+â”Š   â”Š123â”Š    this.direction = direction;\n+â”Š   â”Š124â”Š\n+â”Š   â”Š125â”Š    // This will push a new shape with new properties, based on the direction\n+â”Š   â”Š126â”Š    switch (direction) {\n+â”Š   â”Š127â”Š      case \"left\":\n+â”Š   â”Š128â”Š        var angle = this.rad - (0.5 * Math.PI);\n+â”Š   â”Š129â”Š        var rad = this.rad + (0.5 * Math.PI);\n+â”Š   â”Š130â”Š        var x = this.x + (this.r * Math.cos(angle));\n+â”Š   â”Š131â”Š        var y = this.y + (this.r * Math.sin(angle));\n+â”Š   â”Š132â”Š        this.currentShape = new Engine.Geometry.Circle(x, y, this.r, rad, rad);\n+â”Š   â”Š133â”Š        break;\n+â”Š   â”Š134â”Š      case \"right\":\n+â”Š   â”Š135â”Š        angle = this.rad + (0.5 * Math.PI);\n+â”Š   â”Š136â”Š        rad = this.rad - (0.5 * Math.PI);\n+â”Š   â”Š137â”Š        x = this.x + (this.r * Math.cos(angle));\n+â”Š   â”Š138â”Š        y = this.y + (this.r * Math.sin(angle));\n+â”Š   â”Š139â”Š        this.currentShape = new Engine.Geometry.Circle(x, y, this.r, rad, rad);\n+â”Š   â”Š140â”Š        break;\n+â”Š   â”Š141â”Š      default:\n+â”Š   â”Š142â”Š        this.currentShape = new Engine.Geometry.Line(this.x, this.y, this.x, this.y);\n+â”Š   â”Š143â”Š    }\n+â”Š   â”Š144â”Š\n+â”Š   â”Š145â”Š    this.shapes.push(this.currentShape);\n+â”Š   â”Š146â”Š  }\n+â”Š   â”Š147â”Š\n+â”Š   â”Š148â”Š  // Extend the recent shape based on progress made\n+â”Š   â”Š149â”Š  continueDirection(step, direction) {\n+â”Š   â”Š150â”Š    switch (direction) {\n+â”Š   â”Š151â”Š      case \"left\":\n+â”Š   â”Š152â”Š        this.currentShape.rad1 -= step / this.r;\n+â”Š   â”Š153â”Š        break;\n+â”Š   â”Š154â”Š      case \"right\":\n+â”Š   â”Š155â”Š        this.currentShape.rad2 += step / this.r;\n+â”Š   â”Š156â”Š        break;\n+â”Š   â”Š157â”Š      default:\n+â”Š   â”Š158â”Š        this.currentShape.x2 += step * Math.cos(this.rad);\n+â”Š   â”Š159â”Š        this.currentShape.y2 += step * Math.sin(this.rad);\n+â”Š   â”Š160â”Š    }\n+â”Š   â”Š161â”Š  }\n+â”Š   â”Š162â”Š\n+â”Š   â”Š163â”Š  // Handles case where snake is out limits and we need to render it from\n+â”Š   â”Š164â”Š  // the other side of the canvas\n+â”Š   â”Š165â”Š  cycleThrough(step, width, height) {\n+â”Š   â”Š166â”Š    let intersectionPoint = this.getCanvasIntersection(width, height);\n+â”Š   â”Š167â”Š\n+â”Š   â”Š168â”Š    if (!intersectionPoint) return;\n+â”Š   â”Š169â”Š\n+â”Š   â”Š170â”Š    intersectionPoint = intersectionPoint[0];\n+â”Š   â”Š171â”Š\n+â”Š   â”Š172â”Š    // Re-calculate position based on canvas bounds\n+â”Š   â”Š173â”Š    if (intersectionPoint.x % width == 0)\n+â”Š   â”Š174â”Š      this.x = Utils.mod(this.x - width, width);\n+â”Š   â”Š175â”Š    if (intersectionPoint.y % height == 0)\n+â”Š   â”Š176â”Š      this.y = Utils.mod(this.y - height, height);\n+â”Š   â”Š177â”Š\n+â”Š   â”Š178â”Š    // Update shapes again based on custom properties\n+â”Š   â”Š179â”Š    this.updateShapes(step, width, height, {\n+â”Š   â”Š180â”Š      force: true,\n+â”Š   â”Š181â”Š      lastX: this.x,\n+â”Š   â”Š182â”Š      lastY: this.y,\n+â”Š   â”Š183â”Š      x: this.x,\n+â”Š   â”Š184â”Š      y: this.y\n+â”Š   â”Š185â”Š    });\n+â”Š   â”Š186â”Š  }\n+â”Š   â”Š187â”Š\n+â”Š   â”Š188â”Š  // Gets intersection points between last bit and own shapes\n+â”Š   â”Š189â”Š  getSelfIntersection() {\n+â”Š   â”Š190â”Š    if (this.currentShape instanceof Engine.Geometry.Circle &&\n+â”Š   â”Š191â”Š       Math.abs(this.currentShape.rad1 - this.currentShape.rad2) >= 2 * Math.PI) {\n+â”Š   â”Š192â”Š      if (this.direction == \"left\")\n+â”Š   â”Š193â”Š        var rad = this.currentShape.rad1;\n+â”Š   â”Š194â”Š      else\n+â”Š   â”Š195â”Š        var rad = this.currentShape.rad2;\n+â”Š   â”Š196â”Š\n+â”Š   â”Š197â”Š      return this.currentShape.getPoint(rad);\n+â”Š   â”Š198â”Š    }\n+â”Š   â”Š199â”Š\n+â”Š   â”Š200â”Š    let result;\n+â”Š   â”Š201â”Š\n+â”Š   â”Š202â”Š    this.shapes.slice(0, -2).some(shape =>\n+â”Š   â”Š203â”Š      result = this.lastBit.getIntersection(shape)\n+â”Š   â”Š204â”Š    );\n+â”Š   â”Š205â”Š\n+â”Š   â”Š206â”Š    return result;\n+â”Š   â”Š207â”Š  }\n+â”Š   â”Š208â”Š\n+â”Š   â”Š209â”Š  // Returns intersection points between snakes\n+â”Š   â”Š210â”Š  getSnakeIntersection(snake) {\n+â”Š   â”Š211â”Š    let result;\n+â”Š   â”Š212â”Š\n+â”Š   â”Š213â”Š    snake.shapes.some(shape =>\n+â”Š   â”Š214â”Š      // Only last bit is relevant, if we reached this point it means that\n+â”Š   â”Š215â”Š      // previous intersection will definitely fail\n+â”Š   â”Š216â”Š      result = this.lastBit.getIntersection(shape)\n+â”Š   â”Š217â”Š    );\n+â”Š   â”Š218â”Š\n+â”Š   â”Š219â”Š    return result;\n+â”Š   â”Š220â”Š  }\n+â”Š   â”Š221â”Š\n+â”Š   â”Š222â”Š  // Returns intersection points between snake and canvas\n+â”Š   â”Š223â”Š  getCanvasIntersection(width, height) {\n+â”Š   â”Š224â”Š    // Canvas polygon\n+â”Š   â”Š225â”Š    let canvasPolygon = new Engine.Geometry.Polygon(\n+â”Š   â”Š226â”Š      [0, 0, width, 0],\n+â”Š   â”Š227â”Š      [width, 0, width, height],\n+â”Š   â”Š228â”Š      [width, height, 0, height],\n+â”Š   â”Š229â”Š      [0, height, 0, 0]\n+â”Š   â”Š230â”Š    );\n+â”Š   â”Š231â”Š\n+â”Š   â”Š232â”Š    return canvasPolygon.getIntersection(this.lastBit);\n+â”Š   â”Š233â”Š  }\n+â”Š   â”Š234â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -22,6 +22,7 @@\n â”Š22â”Š22â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/screen.js\"></script>\n â”Š23â”Š23â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/assets_loader.js\"></script>\n â”Š24â”Š24â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n+â”Š  â”Š25â”Š    <script type=\"text/javascript\" src=\"/scripts/game/entities/snake.js\"></script>\n â”Š25â”Š26â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/menu/index.js\"></script>\n â”Š26â”Š27â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/splash/index.js\"></script>\n â”Š27â”Š28â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n```\n\n[}]: #\n\nThis class is titled with most complexity out of everything we did so far in this step. You can follow the code accompanied by comments regard it, but I'd also like to explain the key concepts. As said earlier, the `Snake` is simply made out of shapes; In this case - lines and circles.\n\nThe `draw` method just goes through this array and draws whatever shape it's currently looping through. Regardless of its type, every shape is provided with a `draw` method of its own, all shapes share the same interface, therefore we can just draw them regularly and the snake should be drawn automatically.\n\nThe `update` method updates the last bit only according to its type, the time elapsed and the speed of the snake. For example, the last bit of the snake is a line, and 5 seconds have passed at a speed of 5 meters per second, our line should be extended by 5 meters long. Same principle applies to circle extension only based on radians. The last bit's type might be changed according to the current input; e.g. if the `right` key is held the last bit would turn into a circle, and once released it would turn into a straight line.\n\nNote that besides shapes extension, collision detection should also be made. The embedded is the collision detection between the snake and the canvas, which means that any time the snake collides with the canvas's boundaries the last bit should be redrawn from the opposite side of the canvas. In addition, we've implemented intersection methods for self collision detection and collision detection between rivals, which should be used externally by the hosting screen.\n\nIn the next step we will be implementing the game screen where we will make use of the `Snake` class we've just created, and see how it works in action."
          },
          {
            "manualTitle": "Step 6: Creating a complex game screen with multiple layers",
            "stepRevision": "c27bb0d7806aab70ec489ccd9bbff182d1053dda",
            "manualView": "![snake-demo-game-small](https://cloud.githubusercontent.com/assets/7648874/21074124/8b7cd724-bed7-11e6-9f91-2a211630ac78.gif)\n\nIn this step we will be using the `Snake` class we've just created in the previous step to form the actual game screen - called the `Play` screen. The play screen is a complex screen made out multiple layers as following:\n\n- **`Ready` layer** - Displays a message at the beginning of each match.\n- **`Snake` layer** - Displays the the competitors' snakes.\n- **`Score` layer** - Displays the score board.\n- **`Win` layer** - Displays the winner at the end of each match.\n\nAs we go further with this step, we will give a deeper explanation about each layer and how they interact with each other; As for let's start with the `Play` screen's basis. Regardless of what the `Play` screen should contain at the final result, we want to have the ability to abort the match whenever we press the `Escape` key, therefore, the initial implementation should look like this:\n\n[{]: <helper> (diffStep 6.1)\n\n#### [Step 6.1: Create &#x27;Play&#x27; screen](https://github.com/DAB0mB/radial-snake/commit/e17a45f)\n\n##### Added resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;play&#x2F;index.js\n```diff\n@@ -0,0 +1,14 @@\n+â”Š  â”Š 1â”ŠGame.Screens.Play = class Play extends Engine.Screen {\n+â”Š  â”Š 2â”Š  get events() {\n+â”Š  â”Š 3â”Š    return {\n+â”Š  â”Š 4â”Š      \"keydown\": \"onKeyDown\"\n+â”Š  â”Š 5â”Š    }\n+â”Š  â”Š 6â”Š  }\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Š  onKeyDown() {\n+â”Š  â”Š 9â”Š    // Once escape is pressed, return to main menu screen\n+â”Š  â”Š10â”Š    if (this.keyStates.get(27)) {\n+â”Š  â”Š11â”Š      this.game.changeScreen(Game.Screens.Menu);\n+â”Š  â”Š12â”Š    }\n+â”Š  â”Š13â”Š  }\n+â”Š  â”Š14â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -23,6 +23,7 @@\n â”Š23â”Š23â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/assets_loader.js\"></script>\n â”Š24â”Š24â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š25â”Š25â”Š    <script type=\"text/javascript\" src=\"/scripts/game/entities/snake.js\"></script>\n+â”Š  â”Š26â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/index.js\"></script>\n â”Š26â”Š27â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/menu/index.js\"></script>\n â”Š27â”Š28â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/splash/index.js\"></script>\n â”Š28â”Š29â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n```\n\n[}]: #\n\nNow that we have the `Play` screen, we need to hook it to the `Menu` screen, so whenever we press a key, we will be proceeded to it:\n\n[{]: <helper> (diffStep 6.2)\n\n#### [Step 6.2: Hook &#x27;Play&#x27; screen to &#x27;menu&#x27; screen](https://github.com/DAB0mB/radial-snake/commit/495b9ee)\n\n##### Changed resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;menu&#x2F;index.js\n```diff\n@@ -1,4 +1,10 @@\n â”Š 1â”Š 1â”ŠGame.Screens.Menu = class Menu extends Engine.Screen {\n+â”Š  â”Š 2â”Š  get events() {\n+â”Š  â”Š 3â”Š    return {\n+â”Š  â”Š 4â”Š      \"keydown\": \"onKeyDown\"\n+â”Š  â”Š 5â”Š    }\n+â”Š  â”Š 6â”Š  }\n+â”Š  â”Š 7â”Š\n â”Š 2â”Š 8â”Š  initialize() {\n â”Š 3â”Š 9â”Š    // Initialize snake logo sprite\n â”Š 4â”Š10â”Š    this.logoSprite = new Engine.Sprite(this.assets.logoTexture);\n```\n```diff\n@@ -40,10 +46,18 @@\n â”Š40â”Š46â”Š  }\n â”Š41â”Š47â”Š\n â”Š42â”Š48â”Š  update(span) {\n-â”Š43â”Š  â”Š    this.instructionsAnim.update(span);\n+â”Š  â”Š49â”Š    // On key press, proceed to play screen\n+â”Š  â”Š50â”Š    if (this.keyPressed) {\n+â”Š  â”Š51â”Š      this.game.changeScreen(Game.Screens.Play);\n+â”Š  â”Š52â”Š    }\n+â”Š  â”Š53â”Š    // Else, just update animation\n+â”Š  â”Š54â”Š    else {\n+â”Š  â”Š55â”Š      this.instructionsAnim.update(span);\n+â”Š  â”Š56â”Š    }\n â”Š44â”Š57â”Š  }\n â”Š45â”Š58â”Š\n-â”Š46â”Š  â”Š  update(span) {\n-â”Š47â”Š  â”Š    this.instructionsAnim.update(span);\n+â”Š  â”Š59â”Š  // Register key press\n+â”Š  â”Š60â”Š  onKeyDown(e) {\n+â”Š  â”Š61â”Š    this.keyPressed = true;\n â”Š48â”Š62â”Š  }\n â”Š49â”Š63â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nBy now there shouldn't be anything special. Once you're at the main menu, just press a key as instructed, and you shall see a black screen, which is actually the `Play` screen we've just created; And once you'll press the `Escape` key, you should be receded to the main menu.\n\nThe next stage would be displaying a `Ready` message on the screen, and whenever a key is pressed, the message should fade away using a key-frame animation, and the match should start in the background:\n\n[{]: <helper> (diffStep 6.3)\n\n#### [Step 6.3: Create &#x27;Ready&#x27; layer](https://github.com/DAB0mB/radial-snake/commit/551962d)\n\n##### Added resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;play&#x2F;ready.js\n```diff\n@@ -0,0 +1,59 @@\n+â”Š  â”Š 1â”ŠGame.Screens.Play.Ready = class Ready extends Engine.Layer {\n+â”Š  â”Š 2â”Š  get events() {\n+â”Š  â”Š 3â”Š    return {\n+â”Š  â”Š 4â”Š      \"keydown\": \"onKeyDown\"\n+â”Š  â”Š 5â”Š    };\n+â”Š  â”Š 6â”Š  }\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Š  constructor(screen, snakes) {\n+â”Š  â”Š 9â”Š    super(screen);\n+â”Š  â”Š10â”Š\n+â”Š  â”Š11â”Š    this.snakes = snakes;\n+â”Š  â”Š12â”Š\n+â”Š  â”Š13â”Š    // Create \"ready\" sprite and set its properties\n+â”Š  â”Š14â”Š    let readyTexture = this.assets.minecraftiaFont.createTexture(\"Ready\");\n+â”Š  â”Š15â”Š    let readySprite = new Engine.Sprite(readyTexture);\n+â”Š  â”Š16â”Š    readySprite.align = \"center\";\n+â”Š  â”Š17â”Š    readySprite.setPercentage(\"width\", this.width, 15, \"height\");\n+â”Š  â”Š18â”Š\n+â”Š  â”Š19â”Š    // Create fade out animation for \"ready\" sprite\n+â”Š  â”Š20â”Š    this.readyAnim = new Engine.Animations.Keyframe(readySprite, [\n+â”Š  â”Š21â”Š      {\n+â”Š  â”Š22â”Š        x: this.width / 2,\n+â”Š  â”Š23â”Š        y: this.height / 2,\n+â”Š  â”Š24â”Š        opacity: 1,\n+â”Š  â”Š25â”Š        frame: 0\n+â”Š  â”Š26â”Š      },\n+â”Š  â”Š27â”Š      {\n+â”Š  â”Š28â”Š        y: this.height / 3,\n+â”Š  â”Š29â”Š        opacity: 0,\n+â”Š  â”Š30â”Š        frame: 700\n+â”Š  â”Š31â”Š      }\n+â”Š  â”Š32â”Š    ]);\n+â”Š  â”Š33â”Š  }\n+â”Š  â”Š34â”Š\n+â”Š  â”Š35â”Š  draw(context) {\n+â”Š  â”Š36â”Š    this.readyAnim.draw(context);\n+â”Š  â”Š37â”Š  }\n+â”Š  â”Š38â”Š\n+â”Š  â”Š39â”Š  update(span) {\n+â”Š  â”Š40â”Š    if (!this.ready) return;\n+â”Š  â”Š41â”Š\n+â”Š  â”Š42â”Š    if (this.readyAnim.playing) {\n+â”Š  â”Š43â”Š      this.readyAnim.update(span);\n+â”Š  â”Š44â”Š    }\n+â”Š  â”Š45â”Š    // Once animation is finished, dispose layer\n+â”Š  â”Š46â”Š    else {\n+â”Š  â”Š47â”Š      this.screen.removeLayer(this);\n+â”Š  â”Š48â”Š    }\n+â”Š  â”Š49â”Š  }\n+â”Š  â”Š50â”Š\n+â”Š  â”Š51â”Š  onKeyDown() {\n+â”Š  â”Š52â”Š    // One time event\n+â”Š  â”Š53â”Š    this.disposeEventListeners()\n+â”Š  â”Š54â”Š\n+â”Š  â”Š55â”Š    // This will start playing the animation\n+â”Š  â”Š56â”Š    this.ready = true;\n+â”Š  â”Š57â”Š    this.readyAnim.play();\n+â”Š  â”Š58â”Š  }\n+â”Š  â”Š59â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -24,6 +24,7 @@\n â”Š24â”Š24â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š25â”Š25â”Š    <script type=\"text/javascript\" src=\"/scripts/game/entities/snake.js\"></script>\n â”Š26â”Š26â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/index.js\"></script>\n+â”Š  â”Š27â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/ready.js\"></script>\n â”Š27â”Š28â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/menu/index.js\"></script>\n â”Š28â”Š29â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/splash/index.js\"></script>\n â”Š29â”Š30â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n```\n\n[}]: #\n\nIn order to hook the `Ready` layer to the `Play` screen, we will just push a new instance of it to the layers stack, using the screen's `appendLayer` method. Note that the order of the layer is super critic! Since if we push a new layer it means it will be drawn on top of any previous layer. To \"shift\" a layer to the layers stack, we can simply use the `prependLayer` method instead. Without further due, this is how our hook should look like:\n\n[{]: <helper> (diffStep 6.4)\n\n#### [Step 6.4: Hook &#x27;Ready&#x27; layer to &#x27;Play&#x27; screen](https://github.com/DAB0mB/radial-snake/commit/b461464)\n\n##### Changed resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;play&#x2F;index.js\n```diff\n@@ -5,6 +5,11 @@\n â”Š 5â”Š 5â”Š    }\n â”Š 6â”Š 6â”Š  }\n â”Š 7â”Š 7â”Š\n+â”Š  â”Š 8â”Š  // The ready screen will be the initial screen\n+â”Š  â”Š 9â”Š  initialize(game, snakes) {\n+â”Š  â”Š10â”Š    this.appendLayer(Game.Screens.Play.Ready, snakes);\n+â”Š  â”Š11â”Š  }\n+â”Š  â”Š12â”Š\n â”Š 8â”Š13â”Š  onKeyDown() {\n â”Š 9â”Š14â”Š    // Once escape is pressed, return to main menu screen\n â”Š10â”Š15â”Š    if (this.keyStates.get(27)) {\n```\n\n[}]: #\n\nNow if you'll launch the game and start a new match, you should see a white `Ready` message in the middle of the screen. Up next, would be the `Snake` layer, which will simply initialize 2 new `Snake` instances, and take care of drawing and updating them:\n\n[{]: <helper> (diffStep 6.5)\n\n#### [Step 6.5: Create &#x27;snake&#x27; layer](https://github.com/DAB0mB/radial-snake/commit/a36d7f2)\n\n##### Added resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;play&#x2F;snake.js\n```diff\n@@ -0,0 +1,79 @@\n+â”Š  â”Š 1â”ŠGame.Screens.Play.Snake = class Snake extends Engine.Layer {\n+â”Š  â”Š 2â”Š  constructor(screen, snakes = []) {\n+â”Š  â”Š 3â”Š    super(screen);\n+â”Š  â”Š 4â”Š\n+â”Š  â”Š 5â”Š    // Red snake\n+â”Š  â”Š 6â”Š    this.snakes = [\n+â”Š  â”Š 7â”Š      new Game.Entities.Snake(\n+â”Š  â”Š 8â”Š        this.width / 4,\n+â”Š  â”Š 9â”Š        this.height / 4,\n+â”Š  â”Š10â”Š        50,\n+â”Š  â”Š11â”Š        Math.PI / 4,\n+â”Š  â”Š12â”Š        100,\n+â”Š  â”Š13â”Š        \"FireBrick\",\n+â”Š  â”Š14â”Š        this.keyStates,\n+â”Š  â”Š15â”Š        {\n+â”Š  â”Š16â”Š          // Use score from previous matches\n+â”Š  â”Š17â”Š          score: snakes[0] && snakes[0].score,\n+â”Š  â”Š18â”Š          keys: {\n+â”Š  â”Š19â”Š            left: 37, // Left key\n+â”Š  â”Š20â”Š            right: 39 // RIght key\n+â”Š  â”Š21â”Š        }\n+â”Š  â”Š22â”Š      }),\n+â”Š  â”Š23â”Š\n+â”Š  â”Š24â”Š      // Blue snake\n+â”Š  â”Š25â”Š      new Game.Entities.Snake(\n+â”Š  â”Š26â”Š        (this.width / 4) * 3,\n+â”Š  â”Š27â”Š        (this.height / 4) * 3,\n+â”Š  â”Š28â”Š        50,\n+â”Š  â”Š29â”Š        (-Math.PI / 4) * 3,\n+â”Š  â”Š30â”Š        100,\n+â”Š  â”Š31â”Š        \"DodgerBlue\",\n+â”Š  â”Š32â”Š        this.keyStates,\n+â”Š  â”Š33â”Š        {\n+â”Š  â”Š34â”Š          score: snakes[1] && snakes[1].score,\n+â”Š  â”Š35â”Š          keys: {\n+â”Š  â”Š36â”Š            left: 65, // 'a' key\n+â”Š  â”Š37â”Š            right: 68 // 'b' key\n+â”Š  â”Š38â”Š        }\n+â”Š  â”Š39â”Š      })\n+â”Š  â”Š40â”Š    ];\n+â”Š  â”Š41â”Š  }\n+â”Š  â”Š42â”Š\n+â”Š  â”Š43â”Š  draw(context) {\n+â”Š  â”Š44â”Š    // Draw each snake in the snakes array\n+â”Š  â”Š45â”Š    this.snakes.forEach(snake => snake.draw(context));\n+â”Š  â”Š46â”Š  }\n+â”Š  â”Š47â”Š\n+â”Š  â”Š48â”Š  update(span) {\n+â”Š  â”Š49â”Š    if (!this.snakes.length) return;\n+â”Š  â”Š50â”Š\n+â”Š  â”Š51â”Š    // Storing original snakes array for future use, since it might get changed\n+â”Š  â”Š52â”Š    let snakes = this.snakes.slice();\n+â”Š  â”Š53â”Š\n+â”Š  â”Š54â”Š    snakes.forEach((snake, index) => {\n+â”Š  â”Š55â”Š      snake.update(span, this.width, this.height);\n+â”Š  â”Š56â”Š      // Disqualify if intersected with self\n+â”Š  â”Š57â”Š      if (snake.getSelfIntersection()) return this.snakes.splice(index, 1);\n+â”Š  â”Š58â”Š\n+â”Š  â”Š59â”Š      snakes.forEach((opponent) => {\n+â”Š  â”Š60â”Š        // Don't scan for intersection with self, obviously this will always be true\n+â”Š  â”Š61â”Š        if (opponent === snake) return;\n+â”Š  â”Š62â”Š        // Disqualify if intersected with opponent\n+â”Š  â”Š63â”Š        if (snake.getSnakeIntersection(opponent)) this.snakes.splice(index, 1);\n+â”Š  â”Š64â”Š      });\n+â”Š  â”Š65â”Š    });\n+â”Š  â”Š66â”Š\n+â”Š  â”Š67â”Š    // There can be only one winner, or a tie (very rare, most likely not to happen)\n+â”Š  â”Š68â”Š    // If the match is already finished, skip the next steps since they are not relevant\n+â”Š  â”Š69â”Š    if (this.snakes.length > 1 || this.matchFinished) return;\n+â”Š  â”Š70â”Š\n+â”Š  â”Š71â”Š    // The winner is the \"last snake standing\"\n+â”Š  â”Š72â”Š    let winner = this.snakes[0];\n+â”Š  â”Š73â”Š    // If this is not a tie, which is a very rare case, increase the winner's score\n+â”Š  â”Š74â”Š    if (winner) winner.score++;\n+â”Š  â”Š75â”Š\n+â”Š  â”Š76â”Š    // Indicates whether we should update the score counter or not\n+â”Š  â”Š77â”Š    this.matchFinished = true;\n+â”Š  â”Š78â”Š  }\n+â”Š  â”Š79â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -24,6 +24,7 @@\n â”Š24â”Š24â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š25â”Š25â”Š    <script type=\"text/javascript\" src=\"/scripts/game/entities/snake.js\"></script>\n â”Š26â”Š26â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/index.js\"></script>\n+â”Š  â”Š27â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/snake.js\"></script>\n â”Š27â”Š28â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/ready.js\"></script>\n â”Š28â”Š29â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/menu/index.js\"></script>\n â”Š29â”Š30â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/splash/index.js\"></script>\n```\n\n[}]: #\n\nOnce pressing a key in the `Ready` layer, not only we want to display an animation, but we also want the match to start in the background, thus, we gonna push a new instance of the `Snake` layer we've just created like so:\n\n[{]: <helper> (diffStep 6.6)\n\n#### [Step 6.6: Hook &#x27;snake&#x27; layer to &#x27;ready&#x27; layer](https://github.com/DAB0mB/radial-snake/commit/982db7b)\n\n##### Changed resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;play&#x2F;ready.js\n```diff\n@@ -55,5 +55,8 @@\n â”Š55â”Š55â”Š    // This will start playing the animation\n â”Š56â”Š56â”Š    this.ready = true;\n â”Š57â”Š57â”Š    this.readyAnim.play();\n+â”Š  â”Š58â”Š\n+â”Š  â”Š59â”Š    // Start the game in the background\n+â”Š  â”Š60â”Š    this.screen.prependLayer(Game.Screens.Play.Snake, this.snakes);\n â”Š58â”Š61â”Š  }\n â”Š59â”Š62â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nNote that the layer is pushed when the animation starts and not once finished; This would give a nice smooth feeling to our game-flow. If you'll test out the game, you would discover that the match is actually playable! The first snake (Red) snake should be controlled by the arrow keys, and the second snake (Blue) should be controlled by the letter keys `a`, `s`, `d` and `w`. So far, the snakes function great, but you can probably tell that whenever a match is finished, it feels a bit dull. There's no indication of winning, and there's no score board to present the score of each competitor, which brings us to the next stage - Implementing the `Score` layer.\n\nThe `Score` layer is a simple layer which takes the 2 snakes as a parameter and displays their scores at the top of the screen:\n\n[{]: <helper> (diffStep 6.7)\n\n#### [Step 6.7: Create &#x27;Score&#x27; layer](https://github.com/DAB0mB/radial-snake/commit/6ec4cac)\n\n##### Added resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;play&#x2F;score.js\n```diff\n@@ -0,0 +1,66 @@\n+â”Š  â”Š 1â”ŠGame.Screens.Play.Score = class Score extends Engine.Layer {\n+â”Š  â”Š 2â”Š  constructor(screen, snakes) {\n+â”Š  â”Š 3â”Š    super(screen);\n+â”Š  â”Š 4â”Š\n+â”Š  â”Š 5â”Š    this.snakes = snakes;\n+â”Š  â”Š 6â”Š    this.scoreSprites = [];\n+â”Š  â”Š 7â”Š    this.scores = [];\n+â”Š  â”Š 8â”Š\n+â”Š  â”Š 9â”Š    // It's important to match indexes to each snake since the number of snakes\n+â”Š  â”Š10â”Š    // can be reduced along the way as we play\n+â”Š  â”Š11â”Š    snakes.forEach((snake, index) => {\n+â”Š  â”Š12â”Š      snake.index = index;\n+â”Š  â”Š13â”Š    });\n+â”Š  â”Š14â”Š  }\n+â”Š  â”Š15â”Š\n+â”Š  â”Š16â”Š  draw(context) {\n+â”Š  â”Š17â”Š    this.scoreSprites.forEach((scoreSprite) => {\n+â”Š  â”Š18â”Š      scoreSprite.draw(context);\n+â”Š  â”Š19â”Š    });\n+â”Š  â”Š20â”Š  }\n+â”Š  â”Š21â”Š\n+â”Š  â”Š22â”Š  update(span) {\n+â”Š  â”Š23â”Š    this.snakes.forEach(snake => {\n+â”Š  â”Š24â”Š      let index = snake.index;\n+â”Š  â”Š25â”Š      if (this.scores[index] == snake.score) return;\n+â”Š  â”Š26â”Š\n+â”Š  â”Š27â”Š      // The sprite might be changed along the way so it's important to recreate it\n+â”Š  â”Š28â”Š      // over and over again. If no change was made the cache will be used by the engine\n+â”Š  â”Š29â”Š      this.scoreSprites[index] = this.createScoreSprite(snake);\n+â”Š  â”Š30â”Š      this.scores[index] = snake.score;\n+â”Š  â”Š31â”Š    });\n+â”Š  â”Š32â”Š  }\n+â”Š  â”Š33â”Š\n+â”Š  â”Š34â”Š  createScoreSprite(snake) {\n+â”Š  â”Š35â”Š    let minecraftiaFont = this.assets.minecraftiaFont;\n+â”Š  â”Š36â”Š    minecraftiaFont.save();\n+â”Š  â”Š37â”Š    minecraftiaFont.color = snake.color;\n+â”Š  â”Š38â”Š\n+â”Š  â”Š39â”Š    // Create a score sprite for the snake\n+â”Š  â”Š40â”Š    let scoreTexture = minecraftiaFont.createTexture(`${snake.score}`, {\n+â”Š  â”Š41â”Š      noOffsets: true,\n+â”Š  â”Š42â”Š      noSpaces: true\n+â”Š  â”Š43â”Š    });\n+â”Š  â”Š44â”Š\n+â”Š  â”Š45â”Š    let scoreSprite = new Engine.Sprite(scoreTexture);\n+â”Š  â”Š46â”Š\n+â”Š  â”Š47â”Š    // Size of score board is dynamic to screen size\n+â”Š  â”Š48â”Š    scoreSprite.setPercentage(\"width\", this.width, 4, \"height\");\n+â”Š  â”Š49â”Š\n+â”Š  â”Š50â”Š    // Set alignment modes.\n+â”Š  â”Š51â”Š    // Once we add more snakes we should add more cases here\n+â”Š  â”Š52â”Š    switch (snake.index) {\n+â”Š  â”Š53â”Š      case 0:\n+â”Š  â”Š54â”Š        scoreSprite.align = \"top-left\";\n+â”Š  â”Š55â”Š        break;\n+â”Š  â”Š56â”Š      case 1:\n+â”Š  â”Š57â”Š        scoreSprite.align = \"top-right\";\n+â”Š  â”Š58â”Š        scoreSprite.x = this.width;\n+â”Š  â”Š59â”Š        break;\n+â”Š  â”Š60â”Š    }\n+â”Š  â”Š61â”Š\n+â”Š  â”Š62â”Š    // Restore the font to its original color\n+â”Š  â”Š63â”Š    minecraftiaFont.restore();\n+â”Š  â”Š64â”Š    return scoreSprite;\n+â”Š  â”Š65â”Š  }\n+â”Š  â”Š66â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -24,6 +24,7 @@\n â”Š24â”Š24â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š25â”Š25â”Š    <script type=\"text/javascript\" src=\"/scripts/game/entities/snake.js\"></script>\n â”Š26â”Š26â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/index.js\"></script>\n+â”Š  â”Š27â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/score.js\"></script>\n â”Š27â”Š28â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/snake.js\"></script>\n â”Š28â”Š29â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/ready.js\"></script>\n â”Š29â”Š30â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/menu/index.js\"></script>\n```\n\n[}]: #\n\n> Note that the current score board is suitable for two players, but can easily be modified to support as much players as you want if done correctly.\n\nThe `Score` board should be appended to the layers stack as soon as the `Snake` layers is initialized, so it would be available to us once the match is started:\n\n[{]: <helper> (diffStep 6.8)\n\n#### [Step 6.8: Hook &#x27;Score&#x27; layer to &#x27;Snake&#x27; layer](https://github.com/DAB0mB/radial-snake/commit/feb4a0b)\n\n##### Changed resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;play&#x2F;snake.js\n```diff\n@@ -38,6 +38,9 @@\n â”Š38â”Š38â”Š        }\n â”Š39â”Š39â”Š      })\n â”Š40â”Š40â”Š    ];\n+â”Š  â”Š41â”Š\n+â”Š  â”Š42â”Š    // Show score board for newly created snakes\n+â”Š  â”Š43â”Š    screen.appendLayer(Game.Screens.Play.Score, this.snakes);\n â”Š41â”Š44â”Š  }\n â”Š42â”Š45â”Š\n â”Š43â”Š46â”Š  draw(context) {\n```\n\n[}]: #\n\nNow we're one layer further from completing the `Play` screen, the only thing missing is the `Win` layer, which should present the winner once the match is finished:\n\n[{]: <helper> (diffStep 6.9)\n\n#### [Step 6.9: Create &#x27;Win&#x27; layer](https://github.com/DAB0mB/radial-snake/commit/3476384)\n\n##### Added resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;play&#x2F;win.js\n```diff\n@@ -0,0 +1,43 @@\n+â”Š  â”Š 1â”ŠGame.Screens.Play.Win = class Win extends Engine.Layer {\n+â”Š  â”Š 2â”Š  constructor(screen, snakes, winner) {\n+â”Š  â”Š 3â”Š    super(screen);\n+â”Š  â”Š 4â”Š\n+â”Š  â”Š 5â”Š    this.snakes = snakes;\n+â”Š  â”Š 6â”Š    this.winner = winner;\n+â”Š  â”Š 7â”Š    // ttl stands for \"time to live\", which means, this layer is going to be\n+â”Š  â”Š 8â”Š    // disposed after 3 seconds\n+â”Š  â”Š 9â”Š    this.ttl = 3000;\n+â”Š  â”Š10â”Š\n+â”Š  â”Š11â”Š    // If there is a winner\n+â”Š  â”Š12â”Š    if (this.winner) {\n+â”Š  â”Š13â”Š      // Message could be something like \"RED SNAKE WINS\"\n+â”Š  â”Š14â”Š      var text = `${this.winner.color.toUpperCase()} SNAKE WINS`;\n+â”Š  â”Š15â”Š      var percent = 40;\n+â”Š  â”Š16â”Š    }\n+â”Š  â”Š17â”Š    // If there is a tie\n+â”Š  â”Š18â”Š    else {\n+â”Š  â”Š19â”Š      var text = 'TIE';\n+â”Š  â”Š20â”Š      var percent = 15;\n+â”Š  â”Š21â”Š    }\n+â”Š  â”Š22â”Š\n+â”Š  â”Š23â”Š    // Create winner sprite and set its properties\n+â”Š  â”Š24â”Š    let winnerTexture = this.assets.minecraftiaFont.createTexture(text);\n+â”Š  â”Š25â”Š    this.winnerSprite = new Engine.Sprite(winnerTexture);\n+â”Š  â”Š26â”Š    this.winnerSprite.align = \"center\";\n+â”Š  â”Š27â”Š    this.winnerSprite.setPercentage(\"width\", this.width, percent, \"height\");\n+â”Š  â”Š28â”Š    this.winnerSprite.x = this.width / 2;\n+â”Š  â”Š29â”Š    this.winnerSprite.y = this.height / 2;\n+â”Š  â”Š30â”Š  }\n+â”Š  â”Š31â”Š\n+â”Š  â”Š32â”Š  draw(context) {\n+â”Š  â”Š33â”Š    this.winnerSprite.draw(context);\n+â”Š  â”Š34â”Š  }\n+â”Š  â”Š35â”Š\n+â”Š  â”Š36â”Š  update(span) {\n+â”Š  â”Š37â”Š    // If limit not yet reached, abort\n+â”Š  â”Š38â”Š    if (this.age < this.ttl) return;\n+â”Š  â”Š39â”Š\n+â”Š  â”Š40â”Š    // Show \"ready\" message all over again, only this time use the updated score board\n+â”Š  â”Š41â”Š    this.screen.game.changeScreen(Game.Screens.Play, this.snakes);\n+â”Š  â”Š42â”Š  }\n+â”Š  â”Š43â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -24,6 +24,7 @@\n â”Š24â”Š24â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š25â”Š25â”Š    <script type=\"text/javascript\" src=\"/scripts/game/entities/snake.js\"></script>\n â”Š26â”Š26â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/index.js\"></script>\n+â”Š  â”Š27â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/win.js\"></script>\n â”Š27â”Š28â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/score.js\"></script>\n â”Š28â”Š29â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/snake.js\"></script>\n â”Š29â”Š30â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/ready.js\"></script>\n```\n\n[}]: #\n\nNote how we use the `changeScreen` method once the `Win` layer has reached its age limit (Time to live, aka `ttl`); This would clear the layers stack and restart the `Play` screen, so we can start a new match all-over, only this time we will pass the `Snake` instances to reserve the original scores. The `Win` layer should be presented whenever a collision has been detected between the snakes:\n\n[{]: <helper> (diffStep 6.1)\n\n#### [Step 6.1: Create &#x27;Play&#x27; screen](https://github.com/DAB0mB/radial-snake/commit/e17a45f)\n\n##### Added resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;play&#x2F;index.js\n```diff\n@@ -0,0 +1,14 @@\n+â”Š  â”Š 1â”ŠGame.Screens.Play = class Play extends Engine.Screen {\n+â”Š  â”Š 2â”Š  get events() {\n+â”Š  â”Š 3â”Š    return {\n+â”Š  â”Š 4â”Š      \"keydown\": \"onKeyDown\"\n+â”Š  â”Š 5â”Š    }\n+â”Š  â”Š 6â”Š  }\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Š  onKeyDown() {\n+â”Š  â”Š 9â”Š    // Once escape is pressed, return to main menu screen\n+â”Š  â”Š10â”Š    if (this.keyStates.get(27)) {\n+â”Š  â”Š11â”Š      this.game.changeScreen(Game.Screens.Menu);\n+â”Š  â”Š12â”Š    }\n+â”Š  â”Š13â”Š  }\n+â”Š  â”Š14â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -23,6 +23,7 @@\n â”Š23â”Š23â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/assets_loader.js\"></script>\n â”Š24â”Š24â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š25â”Š25â”Š    <script type=\"text/javascript\" src=\"/scripts/game/entities/snake.js\"></script>\n+â”Š  â”Š26â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/index.js\"></script>\n â”Š26â”Š27â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/menu/index.js\"></script>\n â”Š27â”Š28â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/splash/index.js\"></script>\n â”Š28â”Š29â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n```\n\n[}]: #\n\nThat's it folks, the `Play` screen is finished, and you can play as much matches as you'd feel like.\n\nAlthough the game is finished, it can still be optimized using `C++`. To discover more on hooking efficiency and how we can hook `C++` to the browser, see the next step."
          },
          {
            "manualTitle": "Step 7: Bonus! Re-implementing geometry in C++",
            "stepRevision": "cea4cffcc2f5e801020ed13ef8f1edde608c85f3",
            "manualView": "> This step is part of a bigger tutorial series where we learn how to create a game engine and implement a Tron-style game in JavaScript. The base project for the following step is available [here](https://github.com/DAB0mB/radial-snake/tree/step6).\n\nSo far I covered up pretty much everything I planned. I showed you how to create a game engine, including a font generator, an animation player and a screening system. On top of that, we've learned how to structure and organize our code well, so if in the future we'd like to extend our game by adding more screens or capabilities, we can do that with ease. Indeed, we've went through lots of great stuff, and if you've reached this point I give you my thumbs up. If so far this wasn't enough, in this step we will be focusing on optimization, and making our game engine run faster (a lot, faster). Obviously, when talking about optimizations, the first thing you would probably think of is how we can make our algorithms efficient by using minimum number of operations. While this is true, we will be actually focusing on optimizing our code using C++.\n\nUnlike JavaScript, which is a dynamic scripting file executed by an interpreter, C++ is a general purpose language which compiles into executables. Naturally, executables are much faster than scripts, since they don't have to be interpreted, and they can approach the hardware and memory much faster. In C++, we have to explicitly define our data-types, meaning that variables don't have to be parsed during run-time. While explicit variables definition is C++'s biggest drawback, it's also one of its biggest advantages. The mere fact that variables can be handled much faster, makes code much more efficient.\n\nAccordingly, we can conclude that the programming language we're using plays a very important role when it comes to efficiency. So how exactly are we going to integrate C++ into the browser? We're going to do that by using a compiler called - [Emscripten](http://kripken.github.io/emscripten-site/).\n\n![emscripten](https://cloud.githubusercontent.com/assets/7648874/22675449/ee6d7e9c-eccc-11e6-9570-1dd5d982ee66.png)\n\nEmscripten is an Open Source [LLVM](https://en.wikipedia.org/wiki/LLVM) to JavaScript compiler. Using Emscripten you can:\n\n- Compile C and C++ code into JavaScript\n- Compile any other code that can be translated into LLVM bitcode into JavaScript.\n- Compile the C/C++ runtimes of other languages into JavaScript, and then run code in those other languages in an indirect way (this has been done for Python and Lua)!\n\nLLVM is a library that is used to construct, optimize and produce intermediate and/or binary machine code. LLVM can be used as a compiler framework, where you provide the \"front end\" (parser and lexer) and the \"back end\" (code that converts LLVM's representation to actual machine code). LLVM can also act as a JIT compiler - it has support for x86/x86_64 and PPC/PPC64 assembly generation with fast code optimizations aimed for compilation speed.\n\nEmscripten operates by taking LLVM code and converting it into a subset of JavaScript called asm.js that can run anywhere that JavaScript can run (usually the browser, but also Node.js, etc.) and is easy for browsers to optimize. This means that you can basically write web applications in any language that has an LLVM compiler.\n\n![emscripten-flow](https://cloud.githubusercontent.com/assets/7648874/22675751/b244b76c-ecce-11e6-917e-f7039ed4b340.png)\n\nIn order to use Emscripten you will first have to install it. I recommend you to follow Emscripten's official installation instructions at their website over [here](https://kripken.github.io/emscripten-site/docs/getting_started/downloads.html). Installing Emscripten might be a bit tiring for some, I know for me it was, but if you're hyped about writing native code in the browser as much as I do, take as much time as needed to install it, and bare with me.\n\nAssuming that you have Emscripten installed, we can get right to business. The goal for this step is to re-implement our geometry namespace in C++, and to be more specific, the circle class and line class. We will start by creating an entry file for our C++ code under the path `resources/cpp/src/index.cpp`:\n\n    $ mkdir resources/cpp\n    $ mkdir resources/cpp/src\n    $ touch resources/cpp/src/index.cpp\n\nFrom now on, every C++ file that we would like to run in the browser should be included in the `index.cpp` file we've just created, otherwise it's not going to appear anywhere. The first stage for re-implementing our geometry would be re-writing the utility module, since our geometry is heavily based on it; Therefore the firs inclusion in our `index.cpp` file would be the following:\n\n[{]: <helper> (diffStep 7.1)\n\n#### [Step 7.1: Add CPP entry script](https://github.com/DAB0mB/radial-snake/commit/2f35323)\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;index.cpp\n```diff\n@@ -0,0 +1 @@\n+â”Š â”Š1â”Š#include \"utils.cpp\"ðŸš«â†µ\n```\n\n[}]: #\n\nFollowing that, we will create the `utils.cpp` module included above, which is a direct translation from C++ to JavaScript for the `utils.js` we've created earlier in this tutorial.\n\n[{]: <helper> (diffStep 7.2)\n\n#### [Step 7.2: Add base utility CPP module](https://github.com/DAB0mB/radial-snake/commit/6dba512)\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;utils.cpp\n```diff\n@@ -0,0 +1,73 @@\n+â”Š  â”Š 1â”Š#include <cfloat>\n+â”Š  â”Š 2â”Š#include <cmath>\n+â”Š  â”Š 3â”Š#include <string>\n+â”Š  â”Š 4â”Š#include \"utils.h\"\n+â”Š  â”Š 5â”Š\n+â”Š  â”Š 6â”Šnamespace utils {\n+â”Š  â”Š 7â”Š  // Fixed modulo method which can calculate modulo of negative numbers properly\n+â”Š  â”Š 8â”Š  // e.g. (-803).mod(800) returns 797\n+â”Š  â”Š 9â”Š  double mod(double context, double num) {\n+â”Š  â”Š10â”Š    return std::fmod((std::fmod(context, num) + num), num);\n+â”Š  â”Š11â”Š  }\n+â”Š  â”Š12â”Š\n+â”Š  â”Š13â”Š  // Trims number and leaves the number of decimals specified.\n+â”Š  â”Š14â”Š  // The \"mode\" argument specifies which math function should be invoked\n+â”Š  â”Š15â”Š  // right after the number has been trimmed.\n+â”Š  â”Š16â”Š  // e.g. 12.12345.trim(3, \"ceil\") returns 12.124\n+â”Š  â”Š17â”Š  double trim(double context, int decimals, const std::string mode) {\n+â”Š  â”Š18â”Š    double accumulator = context * std::pow(10, decimals);\n+â”Š  â”Š19â”Š\n+â”Š  â”Š20â”Š    if (mode.compare(\"ceil\") == 0)\n+â”Š  â”Š21â”Š      accumulator = std::ceil(accumulator);\n+â”Š  â”Š22â”Š    else if (mode.compare(\"floor\") == 0)\n+â”Š  â”Š23â”Š      accumulator = std::floor(accumulator);\n+â”Š  â”Š24â”Š    else\n+â”Š  â”Š25â”Š      accumulator = std::round(accumulator);\n+â”Š  â”Š26â”Š\n+â”Š  â”Š27â”Š    return accumulator / std::pow(10, decimals);\n+â”Š  â”Š28â”Š  }\n+â”Š  â”Š29â”Š\n+â”Š  â”Š30â”Š  // Tells if number is in specified range based on given precision.\n+â”Š  â”Š31â”Š  // See the \"compare\" method for more information about precision\n+â”Š  â”Š32â”Š  bool isBetween(double context, double num1, double num2, const std::string precision) {\n+â”Š  â”Š33â”Š    return compare(context, std::min(num1, num2), \">=\", precision) &&\n+â”Š  â”Š34â”Š           compare(context, std::max(num1, num2), \"<=\", precision);\n+â”Š  â”Š35â”Š  }\n+â”Š  â”Š36â”Š\n+â”Š  â”Š37â”Š  bool compare(double context, double num, const std::string precision) {\n+â”Š  â”Š38â”Š    return compare(context, num, \"==\", precision);\n+â”Š  â”Š39â”Š  }\n+â”Š  â”Š40â”Š\n+â”Š  â”Š41â”Š  // Initiates comparison operator between context number and a given number, only here\n+â”Š  â”Š42â”Š  // a precision can be specified\n+â”Š  â”Š43â”Š  bool compare(double context, double num, const std::string method, const std::string precision) {\n+â”Š  â”Š44â”Š    // Fixed precision, \"almost equal\" with a deviation of Îµ\n+â”Š  â”Š45â”Š    if (precision.compare(\"f\") == 0) {\n+â”Š  â”Š46â”Š      if (method.compare(\"<\") == 0 ||\n+â”Š  â”Š47â”Š          method.compare(\"<=\") == 0)\n+â”Š  â”Š48â”Š        return context <= num + DBL_EPSILON;\n+â”Š  â”Š49â”Š      if (method.compare(\">\") == 0 ||\n+â”Š  â”Š50â”Š          method.compare(\">=\") == 0)\n+â”Š  â”Š51â”Š        return context >= num - DBL_EPSILON;\n+â”Š  â”Š52â”Š      return std::abs(context - num) <= DBL_EPSILON;\n+â”Š  â”Š53â”Š    }\n+â”Š  â”Š54â”Š    // Pixel precision, round comparison\n+â”Š  â”Š55â”Š    else if (precision.compare(\"px\") == 0) {\n+â”Š  â”Š56â”Š      if (method.compare(\"<\") == 0 ||\n+â”Š  â”Š57â”Š          method.compare(\"<=\") == 0)\n+â”Š  â”Š58â”Š        return std::round(context) <= std::round(num);\n+â”Š  â”Š59â”Š      if (method.compare(\">\") == 0 ||\n+â”Š  â”Š60â”Š          method.compare(\">=\") == 0)\n+â”Š  â”Š61â”Š        return std::round(context) >= std::round(num);\n+â”Š  â”Š62â”Š      return std::round(context) == std::round(num);\n+â”Š  â”Š63â”Š    }\n+â”Š  â”Š64â”Š    // Exact precision\n+â”Š  â”Š65â”Š    else {\n+â”Š  â”Š66â”Š      if (method.compare(\"<\") == 0) return context < num;\n+â”Š  â”Š67â”Š      if (method.compare(\"<=\") == 0) return context <= num;\n+â”Š  â”Š68â”Š      if (method.compare(\">\") == 0) return context > num;\n+â”Š  â”Š69â”Š      if (method.compare(\">=\") == 0) return context >= num;\n+â”Š  â”Š70â”Š      return context == num;\n+â”Š  â”Š71â”Š    }\n+â”Š  â”Š72â”Š  }\n+â”Š  â”Š73â”Š}ðŸš«â†µ\n```\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;utils.h\n```diff\n@@ -0,0 +1,15 @@\n+â”Š  â”Š 1â”Š#pragma once\n+â”Š  â”Š 2â”Š\n+â”Š  â”Š 3â”Š#include <string>\n+â”Š  â”Š 4â”Š\n+â”Š  â”Š 5â”Šnamespace utils {\n+â”Š  â”Š 6â”Š  double mod(double context, double num);\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Š  double trim(double context, int decimals, const std::string mode = \"round\");\n+â”Š  â”Š 9â”Š\n+â”Š  â”Š10â”Š  bool isBetween(double context, double num1, double num2, const std::string precision = \"exact\");\n+â”Š  â”Š11â”Š\n+â”Š  â”Š12â”Š  bool compare(double context, double num, const std::string precision = \"exact\");\n+â”Š  â”Š13â”Š\n+â”Š  â”Š14â”Š  bool compare(double context, double num, const std::string method, const std::string precision);\n+â”Š  â”Š15â”Š}ðŸš«â†µ\n```\n\n[}]: #\n\nThe module above should work by itself when interacting with it inside the C++ scope, but that's not what we're striving for. We want this module to be available for use in our JavaScript project. This requires us to wrap our code in such a way the the Emscripten compiler will know how to compile it. Apart from providing a compiler, Emscripten provides us with functions and macros that will help use bind our C++ code to the JavaScript environment. These functionalities are packed in a single library which can be imported in our C++ code, and it is called [Embind](https://kripken.github.io/emscripten-site/docs/porting/connecting_cpp_and_javascript/embind.html) (probably stands for \"Emscripten bind\"). Using EMBind, let's wrap our utils module accordingly:\n\n[{]: <helper> (diffStep 7.3)\n\n#### [Step 7.3: EMBind CPP utils](https://github.com/DAB0mB/radial-snake/commit/0f34332)\n\n##### Changed resources&#x2F;cpp&#x2F;src&#x2F;utils.cpp\n```diff\n@@ -1,6 +1,7 @@\n â”Š1â”Š1â”Š#include <cfloat>\n â”Š2â”Š2â”Š#include <cmath>\n â”Š3â”Š3â”Š#include <string>\n+â”Š â”Š4â”Š#include <emscripten/bind.h>\n â”Š4â”Š5â”Š#include \"utils.h\"\n â”Š5â”Š6â”Š\n â”Š6â”Š7â”Šnamespace utils {\n```\n```diff\n@@ -70,4 +71,15 @@\n â”Š70â”Š71â”Š      return context == num;\n â”Š71â”Š72â”Š    }\n â”Š72â”Š73â”Š  }\n+â”Š  â”Š74â”Š}\n+â”Š  â”Š75â”Š\n+â”Š  â”Š76â”ŠEMSCRIPTEN_BINDINGS(utils_module) {\n+â”Š  â”Š77â”Š  emscripten::function(\"utils_mod\", &utils::mod);\n+â”Š  â”Š78â”Š  emscripten::function(\"utils_trim\", &utils::trim);\n+â”Š  â”Š79â”Š  emscripten::function(\"utils_isBetween\", &utils::isBetween);\n+â”Š  â”Š80â”Š  emscripten::function(\"utils_compare\",\n+â”Š  â”Š81â”Š    emscripten::select_overload<bool(double, double, const std::string, const std::string)>(\n+â”Š  â”Š82â”Š      &utils::compare\n+â”Š  â”Š83â”Š    )\n+â”Š  â”Š84â”Š  );\n â”Š73â”Š85â”Š}ðŸš«â†µ\n```\n\n[}]: #\n\nAfter a while you'll get used for Embind's API. If you'll look at it, it's self explanatory and easy to understand. Bound objects will be available the JavaScript environment will be available under an object named `Module`, e.g. the C++ method `mod` will be available for use as `Module.utils_mod`. Bound functions should have supported return types and argument types, meaning that if we're using a custom structure as a return type or an argument type, we first need to wrap it using EMBind, otherwise the compiler won't know how to handle it. A list of natively supported data-types can be found [here](https://kripken.github.io/emscripten-site/docs/porting/connecting_cpp_and_javascript/embind.html#built-in-type-conversions).\n\nEven though we've wrapped our C++ code and hypothetically it can already be used in the browser, I'd go for a second wrapper, since the compiled code doesn't have the optimal architecture. Right now we will have to approach C++ utility functions using `Module.utils_foo`. Instead, I'd like it to be `CPP.Utils.foo`, since it's clearer this way. The output of the Emscripten compiler can be wrapped with JavaScript code, using a prefix and a suffix, defined in 2 separate files respectively, called `pre.js` and `post.js`:\n\n[{]: <helper> (diffStep 7.4)\n\n#### [Step 7.4: Create CPP wrappers](https://github.com/DAB0mB/radial-snake/commit/cc28a34)\n\n##### Added resources&#x2F;cpp&#x2F;post.js\n```diff\n@@ -0,0 +1,10 @@\n+â”Š  â”Š 1â”Šreturn {\n+â”Š  â”Š 2â”Š  Utils: {\n+â”Š  â”Š 3â”Š    mod: Module.utils_mod,\n+â”Š  â”Š 4â”Š    trim: Module.utils_trim,\n+â”Š  â”Š 5â”Š    isBetween: Module.utils_isBetween,\n+â”Š  â”Š 6â”Š    compare: Module.utils_compare\n+â”Š  â”Š 7â”Š  }\n+â”Š  â”Š 8â”Š};\n+â”Š  â”Š 9â”Š\n+â”Š  â”Š10â”Š})();ðŸš«â†µ\n```\n\n##### Added resources&#x2F;cpp&#x2F;pre.js\n```diff\n@@ -0,0 +1 @@\n+â”Š â”Š1â”ŠCPP = (function() {ðŸš«â†µ\n```\n\n[}]: #\n\nWhat we've done in the code snippet above, we've created an anonymous function which calls itself, and inside we've exported a new namespace called `CPP` (C++). This way we can keep the generated code encapsulated, without worrying about spamming the global object.\n\nAfter creating a wrapper, I'd also recommend you to integrate the generated C++ code into existing namespaces, meaning that if for example we would like to approach the `CPP.Utils.foo` method, it could be done using `Utils.foo`. This way existing code won't have to be changed, and extra wrapping logic can be applied with ease, like the chaining logic implemented in the `Utils` namespace:\n\n[{]: <helper> (diffStep 7.5)\n\n#### [Step 7.5: Bind CPP utils to JS utils](https://github.com/DAB0mB/radial-snake/commit/0a67d50)\n\n##### Changed resources&#x2F;scripts&#x2F;utils.js\n```diff\n@@ -16,53 +16,9 @@\n â”Š16â”Š16â”Š  return chain;\n â”Š17â”Š17â”Š};\n â”Š18â”Š18â”Š\n-â”Š19â”Š  â”Š// Fixed modulo method which can calculate modulo of negative numbers properly\n-â”Š20â”Š  â”Š// e.g. (-803).mod(800) returns 797\n-â”Š21â”Š  â”ŠUtils.mod = function (context, num) {\n-â”Š22â”Š  â”Š  return ((context % num) + num) % num;\n-â”Š23â”Š  â”Š};\n-â”Š24â”Š  â”Š\n-â”Š25â”Š  â”Š// Trims number and leaves the number of decimals specified.\n-â”Š26â”Š  â”Š// The \"mode\" argument specifies which math function should be invoked\n-â”Š27â”Š  â”Š// right after the number has been trimmed.\n-â”Š28â”Š  â”Š// e.g. 12.12345.trim(3, \"ceil\") returns 12.124\n-â”Š29â”Š  â”ŠUtils.trim = function (context, decimals, mode = \"round\") {\n-â”Š30â”Š  â”Š  return Math[mode](context * Math.pow(10, decimals)) / Math.pow(10, decimals);\n-â”Š31â”Š  â”Š};\n-â”Š32â”Š  â”Š\n-â”Š33â”Š  â”Š// Tells if number is in specified range based on given precision.\n-â”Š34â”Š  â”Š// See the \"compare\" method for more information about precision\n-â”Š35â”Š  â”ŠUtils.isBetween = function (context, num1, num2, precision) {\n-â”Š36â”Š  â”Š  return Utils.compare(context, Math.min(num1, num2), \">=\", precision) &&\n-â”Š37â”Š  â”Š         Utils.compare(context, Math.max(num1, num2), \"<=\", precision);\n-â”Š38â”Š  â”Š};\n-â”Š39â”Š  â”Š\n-â”Š40â”Š  â”Š// Initiates comparison operator between context number and a given number, only here\n-â”Š41â”Š  â”Š// a precision can be specified\n-â”Š42â”Š  â”ŠUtils.compare = function (context, num, method, precision = method) {\n-â”Š43â”Š  â”Š  switch (precision) {\n-â”Š44â”Š  â”Š    // Fixed precision, \"almost equal\" with a deviation of Îµ\n-â”Š45â”Š  â”Š    case \"f\":\n-â”Š46â”Š  â”Š      switch (method) {\n-â”Š47â”Š  â”Š        case \"<\": case \"<=\": return context <= num + Number.EPSILON;\n-â”Š48â”Š  â”Š        case \">\": case \">=\": return context >= num - Number.EPSILON;\n-â”Š49â”Š  â”Š        default: return Math.abs(context - num) <= Number.EPSILON;\n-â”Š50â”Š  â”Š      }\n-â”Š51â”Š  â”Š    // Pixel precision, round comparison\n-â”Š52â”Š  â”Š    case \"px\":\n-â”Š53â”Š  â”Š      switch (method) {\n-â”Š54â”Š  â”Š        case \"<\": case \"<=\": return Math.round(context) <= Math.round(num);\n-â”Š55â”Š  â”Š        case \">\": case \">=\": return Math.round(context) >= Math.round(num);\n-â”Š56â”Š  â”Š        default: return Math.round(context) == Math.round(num);\n-â”Š57â”Š  â”Š      }\n-â”Š58â”Š  â”Š    // Exact precision\n-â”Š59â”Š  â”Š    default:\n-â”Š60â”Š  â”Š      switch (method) {\n-â”Š61â”Š  â”Š        case \"<\": return context < num;\n-â”Š62â”Š  â”Š        case \"<=\": return context <= num;\n-â”Š63â”Š  â”Š        case \">\": return context > num;\n-â”Š64â”Š  â”Š        case \">=\": return context >= num;\n-â”Š65â”Š  â”Š        default: return context === num;\n-â”Š66â”Š  â”Š      }\n+â”Š  â”Š19â”ŠObject.assign(Utils, CPP.Utils, {\n+â”Š  â”Š20â”Š  // Overload handling\n+â”Š  â”Š21â”Š  compare(context, num, method, precision = method) {\n+â”Š  â”Š22â”Š    return CPP.Utils.compare(context, num, method, precision);\n â”Š67â”Š23â”Š  }\n-â”Š68â”Š  â”Š};ðŸš«â†µ\n+â”Š  â”Š24â”Š});ðŸš«â†µ\n```\n\n[}]: #\n\nWhenever launching the compiler, the generated code should be outputted somewhere. I've decided to go with the path `resources/scripts/cpp.bundle.js`, but it doesn't matter how the file is gonna be called, as long as it's defined under the `scripts` dir, otherwise we won't be able to load it. Also, we need to make sure that we set a git-ignore rule for the generated file, since there's no reason for us to upload it to the git-host if we're planning on compiling it:\n\n[{]: <helper> (diffStep 7.5)\n\n#### [Step 7.5: Bind CPP utils to JS utils](https://github.com/DAB0mB/radial-snake/commit/0a67d50)\n\n##### Changed resources&#x2F;scripts&#x2F;utils.js\n```diff\n@@ -16,53 +16,9 @@\n â”Š16â”Š16â”Š  return chain;\n â”Š17â”Š17â”Š};\n â”Š18â”Š18â”Š\n-â”Š19â”Š  â”Š// Fixed modulo method which can calculate modulo of negative numbers properly\n-â”Š20â”Š  â”Š// e.g. (-803).mod(800) returns 797\n-â”Š21â”Š  â”ŠUtils.mod = function (context, num) {\n-â”Š22â”Š  â”Š  return ((context % num) + num) % num;\n-â”Š23â”Š  â”Š};\n-â”Š24â”Š  â”Š\n-â”Š25â”Š  â”Š// Trims number and leaves the number of decimals specified.\n-â”Š26â”Š  â”Š// The \"mode\" argument specifies which math function should be invoked\n-â”Š27â”Š  â”Š// right after the number has been trimmed.\n-â”Š28â”Š  â”Š// e.g. 12.12345.trim(3, \"ceil\") returns 12.124\n-â”Š29â”Š  â”ŠUtils.trim = function (context, decimals, mode = \"round\") {\n-â”Š30â”Š  â”Š  return Math[mode](context * Math.pow(10, decimals)) / Math.pow(10, decimals);\n-â”Š31â”Š  â”Š};\n-â”Š32â”Š  â”Š\n-â”Š33â”Š  â”Š// Tells if number is in specified range based on given precision.\n-â”Š34â”Š  â”Š// See the \"compare\" method for more information about precision\n-â”Š35â”Š  â”ŠUtils.isBetween = function (context, num1, num2, precision) {\n-â”Š36â”Š  â”Š  return Utils.compare(context, Math.min(num1, num2), \">=\", precision) &&\n-â”Š37â”Š  â”Š         Utils.compare(context, Math.max(num1, num2), \"<=\", precision);\n-â”Š38â”Š  â”Š};\n-â”Š39â”Š  â”Š\n-â”Š40â”Š  â”Š// Initiates comparison operator between context number and a given number, only here\n-â”Š41â”Š  â”Š// a precision can be specified\n-â”Š42â”Š  â”ŠUtils.compare = function (context, num, method, precision = method) {\n-â”Š43â”Š  â”Š  switch (precision) {\n-â”Š44â”Š  â”Š    // Fixed precision, \"almost equal\" with a deviation of Îµ\n-â”Š45â”Š  â”Š    case \"f\":\n-â”Š46â”Š  â”Š      switch (method) {\n-â”Š47â”Š  â”Š        case \"<\": case \"<=\": return context <= num + Number.EPSILON;\n-â”Š48â”Š  â”Š        case \">\": case \">=\": return context >= num - Number.EPSILON;\n-â”Š49â”Š  â”Š        default: return Math.abs(context - num) <= Number.EPSILON;\n-â”Š50â”Š  â”Š      }\n-â”Š51â”Š  â”Š    // Pixel precision, round comparison\n-â”Š52â”Š  â”Š    case \"px\":\n-â”Š53â”Š  â”Š      switch (method) {\n-â”Š54â”Š  â”Š        case \"<\": case \"<=\": return Math.round(context) <= Math.round(num);\n-â”Š55â”Š  â”Š        case \">\": case \">=\": return Math.round(context) >= Math.round(num);\n-â”Š56â”Š  â”Š        default: return Math.round(context) == Math.round(num);\n-â”Š57â”Š  â”Š      }\n-â”Š58â”Š  â”Š    // Exact precision\n-â”Š59â”Š  â”Š    default:\n-â”Š60â”Š  â”Š      switch (method) {\n-â”Š61â”Š  â”Š        case \"<\": return context < num;\n-â”Š62â”Š  â”Š        case \"<=\": return context <= num;\n-â”Š63â”Š  â”Š        case \">\": return context > num;\n-â”Š64â”Š  â”Š        case \">=\": return context >= num;\n-â”Š65â”Š  â”Š        default: return context === num;\n-â”Š66â”Š  â”Š      }\n+â”Š  â”Š19â”ŠObject.assign(Utils, CPP.Utils, {\n+â”Š  â”Š20â”Š  // Overload handling\n+â”Š  â”Š21â”Š  compare(context, num, method, precision = method) {\n+â”Š  â”Š22â”Š    return CPP.Utils.compare(context, num, method, precision);\n â”Š67â”Š23â”Š  }\n-â”Š68â”Š  â”Š};ðŸš«â†µ\n+â”Š  â”Š24â”Š});ðŸš«â†µ\n```\n\n[}]: #\n\nTo compile our C++ code and turn it into JavaScript, we'll need to run the following command:\n\n    $ emcc -O1 --pre-js resources/cpp/pre.js --post-js resources/cpp/post.js --bind -o resources/scripts/cpp.bundle.js resources/cpp/src/index.cpp\n\nHere's a detailed list with explanations regards the arguments vector we've just passed:\n\n- `-01` - Optimization level 1. The higher the index, the more optimized our code is gonna be, but less readable.\n- `--pre-js` - Specifies a JavaScript prefix for the compiled code.\n- `--post-js` - Specifies a JavaScript postfix for the compiled code.\n- `--bind` - Tells the compiler to use Embind\n- `-o` - The output path.\n\n> More informations regards Emscripten's CLI can be found [here](https://kripken.github.io/emscripten-site/docs/tools_reference/emcc.html).\n\nYou don't have to memorize the compilation command we've just typed, because we're gonna save it as an NPM script called `build:cpp`:\n\n[{]: <helper> (diffStep 7.6)\n\n#### [Step 7.6: Add ignore rule to CPP bundle](https://github.com/DAB0mB/radial-snake/commit/f4a75cf)\n\n##### Changed .gitignore\n```diff\n@@ -1,3 +1,4 @@\n â”Š1â”Š1â”Šnode_modules\n â”Š2â”Š2â”Šnpm-debug.log\n-â”Š3â”Š â”Šresources/assets/fonts/*.jsonðŸš«â†µ\n+â”Š â”Š3â”Šresources/assets/fonts/*.json\n+â”Š â”Š4â”Šresources/scripts/cpp.bundle.jsðŸš«â†µ\n```\n\n[}]: #\n\nNow if you'd like to compile the C++ code just run:\n\n    $ npm run build:cpp\n\nMoreover, the code should be compiled automatically any time you start the serer using the command:\n\n    $ npm run serve\n\nWe always have to be on the alert and run our tests against modules we've just translated from JavaScript to C++. This will guarantee that once we run the game we won't stumble upon any defect whatsoever. Before running the tests, be sure to import the C++ bundle in the HTML file's header:\n\n[{]: <helper> (diffStep 7.8)\n\n#### [Step 7.8: Load CPP bundle in spec runner](https://github.com/DAB0mB/radial-snake/commit/0d1bd08)\n\n##### Changed views&#x2F;spec_runner.html\n```diff\n@@ -16,6 +16,7 @@\n â”Š16â”Š16â”Š    <script type=\"text/javascript\" src=\"libs/underscore.js\"></script>\n â”Š17â”Š17â”Š\n â”Š18â”Š18â”Š    <!-- Scripts -->\n+â”Š  â”Š19â”Š    <script type=\"text/javascript\" src=\"scripts/cpp.bundle.js\"></script>\n â”Š19â”Š20â”Š    <script type=\"text/javascript\" src=\"scripts/utils.js\"></script>\n â”Š20â”Š21â”Š    <script type=\"text/javascript\" src=\"scripts/namespaces.js\"></script>\n â”Š21â”Š22â”Š    <script type=\"text/javascript\" src=\"scripts/engine/geometry/line.js\"></script>\n```\n\n[}]: #\n\nNow we can run the tests by running the following command:\n\n    $ npm run test\n\nAt this point **all our tests should pass**. If they don't, it means our newly created utility module is not working properly, and you will have to repeat the previous steps until you get it right.\n\nUp next, we gonna translate the geometry line class to C++. Since it's gonna be translated almost identically, we will have to make sure that all the necessary assets are gonna be available for our class before proceeding. The first thing we will have to do would be making sure that the utility functions are chainable directly from C++ as well. To do that, we will create a chain class which should return a new instance of it whenever we're about to chain the upcoming utility method. Once calling `result()`, the accumulator should be returned:\n\n[{]: <helper> (diffStep 7.9)\n\n#### [Step 7.9: Add chaining method to CPP utils](https://github.com/DAB0mB/radial-snake/commit/0927eea)\n\n##### Changed resources&#x2F;cpp&#x2F;src&#x2F;utils.cpp\n```diff\n@@ -5,6 +5,61 @@\n â”Š 5â”Š 5â”Š#include \"utils.h\"\n â”Š 6â”Š 6â”Š\n â”Š 7â”Š 7â”Šnamespace utils {\n+â”Š  â”Š 8â”Š  template<typename T>\n+â”Š  â”Š 9â”Š  Chain<T>::Chain(T accumulator): _accumulator(accumulator) {\n+â”Š  â”Š10â”Š  }\n+â”Š  â”Š11â”Š\n+â”Š  â”Š12â”Š  template<>\n+â”Š  â”Š13â”Š  Chain<double>* Chain<double>::mod(double num) {\n+â”Š  â”Š14â”Š    double result = utils::mod(_accumulator, num);\n+â”Š  â”Š15â”Š    Chain<double>* chain = new Chain<double>(result);\n+â”Š  â”Š16â”Š    delete this;\n+â”Š  â”Š17â”Š    return chain;\n+â”Š  â”Š18â”Š  }\n+â”Š  â”Š19â”Š\n+â”Š  â”Š20â”Š  template<>\n+â”Š  â”Š21â”Š  Chain<double>* Chain<double>::trim(int decimals, const std::string mode) {\n+â”Š  â”Š22â”Š    double result = utils::trim(_accumulator, decimals, mode);\n+â”Š  â”Š23â”Š    Chain<double>* chain = new Chain<double>(result);\n+â”Š  â”Š24â”Š    delete this;\n+â”Š  â”Š25â”Š    return chain;\n+â”Š  â”Š26â”Š  }\n+â”Š  â”Š27â”Š\n+â”Š  â”Š28â”Š  template<>\n+â”Š  â”Š29â”Š  Chain<bool>* Chain<double>::isBetween(double num1, double num2, const std::string precision) {\n+â”Š  â”Š30â”Š    bool result = utils::isBetween(_accumulator, num1, num2, precision);\n+â”Š  â”Š31â”Š    Chain<bool>* chain = new Chain<bool>(result);\n+â”Š  â”Š32â”Š    delete this;\n+â”Š  â”Š33â”Š    return chain;\n+â”Š  â”Š34â”Š  }\n+â”Š  â”Š35â”Š\n+â”Š  â”Š36â”Š  template<>\n+â”Š  â”Š37â”Š  Chain<bool>* Chain<double>::compare(double num, const std::string precision) {\n+â”Š  â”Š38â”Š    bool result = utils::compare(_accumulator, num, precision);\n+â”Š  â”Š39â”Š    Chain<bool>* chain = new Chain<bool>(result);\n+â”Š  â”Š40â”Š    delete this;\n+â”Š  â”Š41â”Š    return chain;\n+â”Š  â”Š42â”Š  }\n+â”Š  â”Š43â”Š\n+â”Š  â”Š44â”Š  template<>\n+â”Š  â”Š45â”Š  Chain<bool>* Chain<double>::compare(double num, const std::string method, const std::string precision) {\n+â”Š  â”Š46â”Š    bool result = utils::compare(_accumulator, num, method, precision);\n+â”Š  â”Š47â”Š    Chain<bool>* chain = new Chain<bool>(result);\n+â”Š  â”Š48â”Š    delete this;\n+â”Š  â”Š49â”Š    return chain;\n+â”Š  â”Š50â”Š  }\n+â”Š  â”Š51â”Š\n+â”Š  â”Š52â”Š  template<typename T>\n+â”Š  â”Š53â”Š  T Chain<T>::result() {\n+â”Š  â”Š54â”Š    delete this;\n+â”Š  â”Š55â”Š    return _accumulator;\n+â”Š  â”Š56â”Š  }\n+â”Š  â”Š57â”Š\n+â”Š  â”Š58â”Š  template<typename T>\n+â”Š  â”Š59â”Š  Chain<T>* chain(T accumulator) {\n+â”Š  â”Š60â”Š    return new Chain<T>(accumulator);\n+â”Š  â”Š61â”Š  }\n+â”Š  â”Š62â”Š\n â”Š 8â”Š63â”Š  // Fixed modulo method which can calculate modulo of negative numbers properly\n â”Š 9â”Š64â”Š  // e.g. (-803).mod(800) returns 797\n â”Š10â”Š65â”Š  double mod(double context, double num) {\n```\n\n##### Changed resources&#x2F;cpp&#x2F;src&#x2F;utils.h\n```diff\n@@ -3,6 +3,30 @@\n â”Š 3â”Š 3â”Š#include <string>\n â”Š 4â”Š 4â”Š\n â”Š 5â”Š 5â”Šnamespace utils {\n+â”Š  â”Š 6â”Š  template<typename T>\n+â”Š  â”Š 7â”Š  class Chain {\n+â”Š  â”Š 8â”Š  private:\n+â”Š  â”Š 9â”Š    T _accumulator;\n+â”Š  â”Š10â”Š\n+â”Š  â”Š11â”Š  public:\n+â”Š  â”Š12â”Š    Chain(T accumulator);\n+â”Š  â”Š13â”Š\n+â”Š  â”Š14â”Š    Chain<double>* mod(double num);\n+â”Š  â”Š15â”Š\n+â”Š  â”Š16â”Š    Chain<double>* trim(int decimals, const std::string mode = \"round\");\n+â”Š  â”Š17â”Š\n+â”Š  â”Š18â”Š    Chain<bool>* isBetween(double num1, double num2, const std::string precision = \"exact\");\n+â”Š  â”Š19â”Š\n+â”Š  â”Š20â”Š    Chain<bool>* compare(double num, const std::string precision = \"exact\");\n+â”Š  â”Š21â”Š\n+â”Š  â”Š22â”Š    Chain<bool>* compare(double num, const std::string method, const std::string precision);\n+â”Š  â”Š23â”Š\n+â”Š  â”Š24â”Š    T result();\n+â”Š  â”Š25â”Š  };\n+â”Š  â”Š26â”Š\n+â”Š  â”Š27â”Š  template<typename T>\n+â”Š  â”Š28â”Š  Chain<T>* chain(T accumulator);\n+â”Š  â”Š29â”Š\n â”Š 6â”Š30â”Š  double mod(double context, double num);\n â”Š 7â”Š31â”Š\n â”Š 8â”Š32â”Š  double trim(double context, int decimals, const std::string mode = \"round\");\n```\n\n[}]: #\n\n> Note that when coding in C++ we have to make sure that the objects are being disposed when not needed anymore, otherwise we will have some unnecessary memory leaks.\n\n2D shapes are presented in space using points with 2 values - `x` (axis) and `y` axis, therefore, we will create the appropriate point structure:\n\n[{]: <helper> (diffStep 7.1)\n\n#### [Step 7.1: Add CPP entry script](https://github.com/DAB0mB/radial-snake/commit/2f35323)\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;index.cpp\n```diff\n@@ -0,0 +1 @@\n+â”Š â”Š1â”Š#include \"utils.cpp\"ðŸš«â†µ\n```\n\n[}]: #\n\nReturned values can either be `null` (`undefined`) or not. Since there's no built in nullable-values mechanism in C++ (up until C++17), we're gonna create one of our own:\n\n[{]: <helper> (diffStep 7.11)\n\n#### [Step 7.11: Add nullable class](https://github.com/DAB0mB/radial-snake/commit/41b2f7c)\n\n##### Changed resources&#x2F;cpp&#x2F;src&#x2F;index.cpp\n```diff\n@@ -1 +1,2 @@\n+â”Š â”Š1â”Š#include \"nullable.cpp\"\n â”Š1â”Š2â”Š#include \"utils.cpp\"ðŸš«â†µ\n```\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;nullable.cpp\n```diff\n@@ -0,0 +1,37 @@\n+â”Š  â”Š 1â”Š#include \"nullable.h\"\n+â”Š  â”Š 2â”Š\n+â”Š  â”Š 3â”Štemplate <typename T>\n+â”Š  â”Š 4â”ŠNullable<T>::Nullable(T value): _value(value), _initialized(true) {\n+â”Š  â”Š 5â”Š\n+â”Š  â”Š 6â”Š}\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Štemplate <typename T>\n+â”Š  â”Š 9â”ŠNullable<T>::Nullable(): _initialized(false) {\n+â”Š  â”Š10â”Š\n+â”Š  â”Š11â”Š}\n+â”Š  â”Š12â”Š\n+â”Š  â”Š13â”Štemplate <typename T>\n+â”Š  â”Š14â”ŠT Nullable<T>::getValue() const {\n+â”Š  â”Š15â”Š  return _value;\n+â”Š  â”Š16â”Š}\n+â”Š  â”Š17â”Š\n+â”Š  â”Š18â”Štemplate <typename T>\n+â”Š  â”Š19â”Švoid Nullable<T>::setValue(T value) {\n+â”Š  â”Š20â”Š  _value = value;\n+â”Š  â”Š21â”Š  _initialized = true;\n+â”Š  â”Š22â”Š}\n+â”Š  â”Š23â”Š\n+â”Š  â”Š24â”Štemplate <typename T>\n+â”Š  â”Š25â”Švoid Nullable<T>::resetValue() {\n+â”Š  â”Š26â”Š  _initialized = false;\n+â”Š  â”Š27â”Š}\n+â”Š  â”Š28â”Š\n+â”Š  â”Š29â”Štemplate <typename T>\n+â”Š  â”Š30â”Šbool Nullable<T>::hasValue() const {\n+â”Š  â”Š31â”Š  return _initialized == true;\n+â”Š  â”Š32â”Š}\n+â”Š  â”Š33â”Š\n+â”Š  â”Š34â”Štemplate <typename T>\n+â”Š  â”Š35â”Šbool Nullable<T>::isNull() const {\n+â”Š  â”Š36â”Š  return _initialized == false;\n+â”Š  â”Š37â”Š}ðŸš«â†µ\n```\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;nullable.h\n```diff\n@@ -0,0 +1,23 @@\n+â”Š  â”Š 1â”Š#pragma once\n+â”Š  â”Š 2â”Š\n+â”Š  â”Š 3â”Štemplate <typename T>\n+â”Š  â”Š 4â”Šclass Nullable {\n+â”Š  â”Š 5â”Šprivate:\n+â”Š  â”Š 6â”Š  T _value;\n+â”Š  â”Š 7â”Š  bool _initialized;\n+â”Š  â”Š 8â”Š\n+â”Š  â”Š 9â”Špublic:\n+â”Š  â”Š10â”Š  Nullable(T value);\n+â”Š  â”Š11â”Š\n+â”Š  â”Š12â”Š  Nullable();\n+â”Š  â”Š13â”Š\n+â”Š  â”Š14â”Š  T getValue() const;\n+â”Š  â”Š15â”Š\n+â”Š  â”Š16â”Š  void setValue(T value);\n+â”Š  â”Š17â”Š\n+â”Š  â”Š18â”Š  void resetValue();\n+â”Š  â”Š19â”Š\n+â”Š  â”Š20â”Š  bool hasValue() const;\n+â”Š  â”Š21â”Š\n+â”Š  â”Š22â”Š  bool isNull() const;\n+â”Š  â”Š23â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nNow that all the necessary assets for the line class are ready, we can go ahead and create it:\n\n[{]: <helper> (diffStep 7.12)\n\n#### [Step 7.12: Add base line CPP module](https://github.com/DAB0mB/radial-snake/commit/9d17554)\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;geometry&#x2F;line.cpp\n```diff\n@@ -0,0 +1,99 @@\n+â”Š  â”Š 1â”Š#include \"../nullable.h\"\n+â”Š  â”Š 2â”Š#include \"../utils.h\"\n+â”Š  â”Š 3â”Š#include \"point.h\"\n+â”Š  â”Š 4â”Š#include \"line.h\"\n+â”Š  â”Š 5â”Š\n+â”Š  â”Š 6â”Šnamespace geometry {\n+â”Š  â”Š 7â”Š  // x1 - The first point's x value\n+â”Š  â”Š 8â”Š  // y1 - The first point's y value\n+â”Š  â”Š 9â”Š  // x1 - The second point's x value\n+â”Š  â”Š10â”Š  // y2 - The second point's y value\n+â”Š  â”Š11â”Š  Line::Line(double x1, double y1, double x2, double y2) {\n+â”Š  â”Š12â”Š    _x1 = utils::trim(x1, 9);\n+â”Š  â”Š13â”Š    _y1 = utils::trim(y1, 9);\n+â”Š  â”Š14â”Š    _x2 = utils::trim(x2, 9);\n+â”Š  â”Š15â”Š    _y2 = utils::trim(y2, 9);\n+â”Š  â”Š16â”Š  }\n+â”Š  â”Š17â”Š\n+â”Š  â”Š18â”Š  // Gets the matching x value for a given y value\n+â”Š  â”Š19â”Š  Nullable<double> Line::getMatchingX(double y) {\n+â”Š  â”Š20â”Š    // If an error was thrown it means we divided a number by zero,\n+â”Š  â”Š21â”Š    // in which case there is not intersection point\n+â”Š  â”Š22â”Š    double x = utils::trim(\n+â”Š  â”Š23â”Š      (((y - _y1) * (_x2 - _x1)) /\n+â”Š  â”Š24â”Š       (_y2 - _y1)) + _x1\n+â”Š  â”Š25â”Š    , 9, \"exact\");\n+â”Š  â”Š26â”Š\n+â”Š  â”Š27â”Š    // Check if result is in values range\n+â”Š  â”Š28â”Š    if (utils::isBetween(x, _x1, _x2, \"round\")) {\n+â”Š  â”Š29â”Š      return Nullable<double>(x);\n+â”Š  â”Š30â”Š    }\n+â”Š  â”Š31â”Š\n+â”Š  â”Š32â”Š    return Nullable<double>();\n+â”Š  â”Š33â”Š  }\n+â”Š  â”Š34â”Š\n+â”Š  â”Š35â”Š  // Gets the matching y value for a given x value\n+â”Š  â”Š36â”Š  Nullable<double> Line::getMatchingY(double x) {\n+â”Š  â”Š37â”Š    // If an error was thrown it means we divided a number by zero,\n+â”Š  â”Š38â”Š    // in which case there is not intersection point\n+â”Š  â”Š39â”Š    double y = utils::trim(\n+â”Š  â”Š40â”Š      (((x - _x1) * (_y2 - _y1)) /\n+â”Š  â”Š41â”Š       (_x2 - _x1)) + _y1\n+â”Š  â”Š42â”Š    , 9, \"exact\");\n+â”Š  â”Š43â”Š\n+â”Š  â”Š44â”Š    // Check if result is in values range\n+â”Š  â”Š45â”Š    if (utils::isBetween(y, _y1, _y2, \"round\")) {\n+â”Š  â”Š46â”Š      return Nullable<double>(y);\n+â”Š  â”Š47â”Š    }\n+â”Š  â”Š48â”Š\n+â”Š  â”Š49â”Š    return Nullable<double>();\n+â”Š  â”Š50â”Š  }\n+â”Š  â”Š51â”Š\n+â”Š  â”Š52â”Š  // Returns if line has given point\n+â”Š  â”Š53â”Š  bool Line::hasPoint(double x, double y) {\n+â”Š  â”Š54â”Š    if (!boundsHavePoint(x, y)) return 0;\n+â”Š  â”Š55â”Š\n+â”Š  â”Š56â”Š    double m = utils::trim(\n+â”Š  â”Š57â”Š      (_y2 - _y1) / (_x2 - _x1),\n+â”Š  â”Š58â”Š    9, \"exact\");\n+â”Š  â”Š59â”Š\n+â”Š  â”Š60â”Š    return (y - _y1) / (x - _x1) == m;\n+â”Š  â”Š61â”Š  }\n+â”Š  â”Š62â”Š\n+â”Š  â”Š63â”Š  // Returns if given point is contained by the bounds aka cage of line\n+â”Š  â”Š64â”Š  bool Line::boundsHavePoint(double x, double y) {\n+â”Š  â”Š65â”Š    return utils::isBetween(x, _x1, _x2, \"round\") &&\n+â”Š  â”Š66â”Š           utils::isBetween(y, _y1, _y2, \"round\");\n+â”Š  â”Š67â”Š  }\n+â”Š  â”Š68â”Š\n+â”Š  â”Š69â”Š  // line - line intersection method\n+â”Š  â”Š70â”Š  Nullable<Point> Line::getIntersection(Line line) {\n+â”Š  â”Š71â”Š    // Escape if lines are parallel\n+â”Š  â”Š72â”Š    if (!(((_x1 - _x2) * (line._y1 - line._y2)) -\n+â”Š  â”Š73â”Š          ((_y1 - _y2) * (line._x1 - line._x2))))\n+â”Š  â”Š74â”Š      return Nullable<Point>();\n+â”Š  â”Š75â”Š\n+â”Š  â”Š76â”Š    // Intersection point formula\n+â”Š  â”Š77â”Š    double x = utils::trim(\n+â”Š  â”Š78â”Š      ((((_x1 * _y2) - (_y1 * _x2)) * (line._x1 - line._x2)) -\n+â”Š  â”Š79â”Š       ((_x1 - _x2) * ((line._x1 * line._y2) - (line._y1 * line._x2)))) /\n+â”Š  â”Š80â”Š      (((_x1 - _x2) * (line._y1 - line._y2)) - ((_y1 - _y2) *\n+â”Š  â”Š81â”Š        (line._x1 - line._x2)))\n+â”Š  â”Š82â”Š    , 9, \"exact\");\n+â”Š  â”Š83â”Š    double y = utils::trim(\n+â”Š  â”Š84â”Š      ((((_x1 * _y2) - (_y1 * _x2)) * (line._y1 - line._y2)) -\n+â”Š  â”Š85â”Š       ((_y1 - _y2) * ((line._x1 * line._y2) - (line._y1 * line._x2)))) /\n+â”Š  â”Š86â”Š      (((_x1 - _x2) * (line._y1 - line._y2)) - ((_y1 - _y2) *\n+â”Š  â”Š87â”Š        (line._x1 - line._x2)))\n+â”Š  â”Š88â”Š    , 9, \"exact\");\n+â”Š  â”Š89â”Š\n+â”Š  â”Š90â”Š    if (utils::isBetween(x, _x1, _x2, \"round\") &&\n+â”Š  â”Š91â”Š        utils::isBetween(x, line._x1, line._x2, \"round\") &&\n+â”Š  â”Š92â”Š        utils::isBetween(y, _y1, _y2, \"round\") &&\n+â”Š  â”Š93â”Š        utils::isBetween(y, line._y1, line._y2, \"round\")) {\n+â”Š  â”Š94â”Š      return Nullable<Point>({ x, y });\n+â”Š  â”Š95â”Š    }\n+â”Š  â”Š96â”Š\n+â”Š  â”Š97â”Š    return Nullable<Point>();\n+â”Š  â”Š98â”Š  }\n+â”Š  â”Š99â”Š}ðŸš«â†µ\n```\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;geometry&#x2F;line.h\n```diff\n@@ -0,0 +1,30 @@\n+â”Š  â”Š 1â”Š#pragma once\n+â”Š  â”Š 2â”Š\n+â”Š  â”Š 3â”Š#include <vector>\n+â”Š  â”Š 4â”Š#include \"../nullable.h\"\n+â”Š  â”Š 5â”Š#include \"point.h\"\n+â”Š  â”Š 6â”Š\n+â”Š  â”Š 7â”Šnamespace geometry {\n+â”Š  â”Š 8â”Š  class Circle;\n+â”Š  â”Š 9â”Š  class EMCircle;\n+â”Š  â”Š10â”Š\n+â”Š  â”Š11â”Š  class Line {\n+â”Š  â”Š12â”Š  public:\n+â”Š  â”Š13â”Š    double _x1;\n+â”Š  â”Š14â”Š    double _y1;\n+â”Š  â”Š15â”Š    double _x2;\n+â”Š  â”Š16â”Š    double _y2;\n+â”Š  â”Š17â”Š\n+â”Š  â”Š18â”Š    Line(double x1, double y1, double x2, double y2);\n+â”Š  â”Š19â”Š\n+â”Š  â”Š20â”Š    Nullable<double> getMatchingX(double y);\n+â”Š  â”Š21â”Š\n+â”Š  â”Š22â”Š    Nullable<double> getMatchingY(double x);\n+â”Š  â”Š23â”Š\n+â”Š  â”Š24â”Š    bool hasPoint(double x, double y);\n+â”Š  â”Š25â”Š\n+â”Š  â”Š26â”Š    bool boundsHavePoint(double x, double y);\n+â”Š  â”Š27â”Š\n+â”Š  â”Š28â”Š    Nullable<Point> getIntersection(Line line);\n+â”Š  â”Š29â”Š  };\n+â”Š  â”Š30â”Š}ðŸš«â†µ\n```\n\n##### Changed resources&#x2F;cpp&#x2F;src&#x2F;index.cpp\n```diff\n@@ -1,2 +1,3 @@\n â”Š1â”Š1â”Š#include \"nullable.cpp\"\n-â”Š2â”Š â”Š#include \"utils.cpp\"ðŸš«â†µ\n+â”Š â”Š2â”Š#include \"utils.cpp\"\n+â”Š â”Š3â”Š#include \"geometry/line.cpp\"ðŸš«â†µ\n```\n\n[}]: #\n\nAfter creating our C++, we will also need to bind it using EMBind:\n\n[{]: <helper> (diffStep 7.13)\n\n#### [Step 7.13: EMBind CPP line](https://github.com/DAB0mB/radial-snake/commit/8920ddf)\n\n##### Changed resources&#x2F;cpp&#x2F;post.js\n```diff\n@@ -4,6 +4,10 @@\n â”Š 4â”Š 4â”Š    trim: Module.utils_trim,\n â”Š 5â”Š 5â”Š    isBetween: Module.utils_isBetween,\n â”Š 6â”Š 6â”Š    compare: Module.utils_compare\n+â”Š  â”Š 7â”Š  },\n+â”Š  â”Š 8â”Š\n+â”Š  â”Š 9â”Š  Geometry: {\n+â”Š  â”Š10â”Š    Line: Module.geometry_line\n â”Š 7â”Š11â”Š  }\n â”Š 8â”Š12â”Š};\n â”Š 9â”Š13â”Š\n```\n\n##### Changed resources&#x2F;cpp&#x2F;src&#x2F;geometry&#x2F;line.cpp\n```diff\n@@ -1,3 +1,6 @@\n+â”Š â”Š1â”Š#include <vector>\n+â”Š â”Š2â”Š#include <emscripten/bind.h>\n+â”Š â”Š3â”Š#include <emscripten/val.h>\n â”Š1â”Š4â”Š#include \"../nullable.h\"\n â”Š2â”Š5â”Š#include \"../utils.h\"\n â”Š3â”Š6â”Š#include \"point.h\"\n```\n```diff\n@@ -96,4 +99,52 @@\n â”Š 96â”Š 99â”Š\n â”Š 97â”Š100â”Š    return Nullable<Point>();\n â”Š 98â”Š101â”Š  }\n+â”Š   â”Š102â”Š\n+â”Š   â”Š103â”Š  emscripten::val EMLine::getMatchingX(double y) {\n+â”Š   â”Š104â”Š    Nullable<double> nullableX = Line::getMatchingX(y);\n+â”Š   â”Š105â”Š    return nullableX.hasValue() ?\n+â”Š   â”Š106â”Š      emscripten::val(nullableX.getValue()) :\n+â”Š   â”Š107â”Š      emscripten::val::undefined();\n+â”Š   â”Š108â”Š  }\n+â”Š   â”Š109â”Š\n+â”Š   â”Š110â”Š  emscripten::val EMLine::getMatchingY(double x) {\n+â”Š   â”Š111â”Š    Nullable<double> nullableY = Line::getMatchingY(x);\n+â”Š   â”Š112â”Š    return nullableY.hasValue() ?\n+â”Š   â”Š113â”Š      emscripten::val(nullableY.getValue()) :\n+â”Š   â”Š114â”Š      emscripten::val::undefined();\n+â”Š   â”Š115â”Š  }\n+â”Š   â”Š116â”Š\n+â”Š   â”Š117â”Š  emscripten::val EMLine::getIntersection(EMLine emLine) {\n+â”Š   â”Š118â”Š    Line line = Line(emLine._x1, emLine._y1, emLine._x2, emLine._y2);\n+â”Š   â”Š119â”Š    Nullable<Point> nullablePoint = Line::getIntersection(line);\n+â”Š   â”Š120â”Š\n+â”Š   â”Š121â”Š    if (nullablePoint.isNull()) return emscripten::val::undefined();\n+â”Š   â”Š122â”Š\n+â”Š   â”Š123â”Š    Point point = nullablePoint.getValue();\n+â”Š   â”Š124â”Š    emscripten::val emPoint = emscripten::val::object();\n+â”Š   â”Š125â”Š    emPoint.set(\"x\", emscripten::val(point.x));\n+â”Š   â”Š126â”Š    emPoint.set(\"y\", emscripten::val(point.y));\n+â”Š   â”Š127â”Š    return emPoint;\n+â”Š   â”Š128â”Š  }\n+â”Š   â”Š129â”Š}\n+â”Š   â”Š130â”Š\n+â”Š   â”Š131â”ŠEMSCRIPTEN_BINDINGS(geometry_line_module) {\n+â”Š   â”Š132â”Š  emscripten::class_<geometry::Line>(\"geometry_line_base\")\n+â”Š   â”Š133â”Š    .constructor<double, double, double, double>()\n+â”Š   â”Š134â”Š    .property<double>(\"x1\", &geometry::Line::_x1)\n+â”Š   â”Š135â”Š    .property<double>(\"y1\", &geometry::Line::_y1)\n+â”Š   â”Š136â”Š    .property<double>(\"x2\", &geometry::Line::_x2)\n+â”Š   â”Š137â”Š    .property<double>(\"y2\", &geometry::Line::_y2)\n+â”Š   â”Š138â”Š    .function(\"hasPoint\", &geometry::Line::hasPoint)\n+â”Š   â”Š139â”Š    .function(\"boundsHavePoint\", &geometry::Line::boundsHavePoint);\n+â”Š   â”Š140â”Š\n+â”Š   â”Š141â”Š  emscripten::class_<geometry::EMLine, emscripten::base<geometry::Line>>(\"geometry_line\")\n+â”Š   â”Š142â”Š    .constructor<double, double, double, double>()\n+â”Š   â”Š143â”Š    .function(\"getX\", &geometry::EMLine::getMatchingX)\n+â”Š   â”Š144â”Š    .function(\"getY\", &geometry::EMLine::getMatchingY)\n+â”Š   â”Š145â”Š    .function(\"getLineIntersection\",\n+â”Š   â”Š146â”Š      emscripten::select_overload<emscripten::val(geometry::EMLine)>(\n+â”Š   â”Š147â”Š        &geometry::EMLine::getIntersection\n+â”Š   â”Š148â”Š      )\n+â”Š   â”Š149â”Š    );\n â”Š 99â”Š150â”Š}ðŸš«â†µ\n```\n\n##### Changed resources&#x2F;cpp&#x2F;src&#x2F;geometry&#x2F;line.h\n```diff\n@@ -1,6 +1,7 @@\n â”Š1â”Š1â”Š#pragma once\n â”Š2â”Š2â”Š\n â”Š3â”Š3â”Š#include <vector>\n+â”Š â”Š4â”Š#include <emscripten/val.h>\n â”Š4â”Š5â”Š#include \"../nullable.h\"\n â”Š5â”Š6â”Š#include \"point.h\"\n â”Š6â”Š7â”Š\n```\n```diff\n@@ -27,4 +28,15 @@\n â”Š27â”Š28â”Š\n â”Š28â”Š29â”Š    Nullable<Point> getIntersection(Line line);\n â”Š29â”Š30â”Š  };\n+â”Š  â”Š31â”Š\n+â”Š  â”Š32â”Š  class EMLine : public Line {\n+â”Š  â”Š33â”Š  public:\n+â”Š  â”Š34â”Š    using Line::Line;\n+â”Š  â”Š35â”Š\n+â”Š  â”Š36â”Š    emscripten::val getMatchingX(double y);\n+â”Š  â”Š37â”Š\n+â”Š  â”Š38â”Š    emscripten::val getMatchingY(double x);\n+â”Š  â”Š39â”Š\n+â”Š  â”Š40â”Š    emscripten::val getIntersection(EMLine line);\n+â”Š  â”Š41â”Š  };\n â”Š30â”Š42â”Š}ðŸš«â†µ\n```\n\n[}]: #\n\nIn the code snippet above, you can see that we used a special data-type called `val` (`emscripten::val`). `val` means that just like JavaScript, that function can return values that are not necessarily of the same data-type; For instance, the `getMatchingY` function can either return a `number` or `undefined`. If you'll take a look at the `getIntersection(Line)` method you'll notice that instead of returning the raw point structure, I chose to build a JavaScript object using the `object` data type (`emscripten::object`). `object` behaves exactly like a native JavaScript `Object`, and it can save us some precious work of binding which sometimes might be just too much.\n\nIf you'll compare the C++ version of the line class to the JavaScript line class you'll notice that the `draw` and `getIntersection` methods are missing (when we used EMBind we renamed `getIntersection` to `getLineIntersection` because overloadings are forbidden). In addition, Emscripten's API exposes some additional class methods for generated C++ classes, like the `delete` method, which we will shed light on further in this tutorial. Inheritance would be the natural solution for such an issue, unfortunately, generated C++ constructors don't accept indirect instances. For example, if we have a C++ parent class called `Shape` and we have a JavaScript child class called `Line`, we won't be able to initialize a new instance of the `Line` class. Here's a demonstration:\n\n```js\nclass JSLine extends CPPShape {}\nconst line = new JSLine(); // Throws error\n```\n\nThere are 3 ways to implement inheritance when interacting with C++ classes:\n\n- Define an interface when using EMBind. This is the official way but rather complicated, since it requires us to define an extra layer for our wrapper. More information can be found [here](https://kripken.github.io/emscripten-site/docs/porting/connecting_cpp_and_javascript/embind.html#abstract-methods).\n- Extending the prototype of exported C++ classes directly, which is not really an inheritance.\n- Using a proxy class, which is the easiest and cleanest solution of all, but it is not really mentioned anywhere. At the same time, I didn't find any restriction regards that.\n\nWe're gonna use the 3rd method in the list above, because as I said, it's the easiest and cleanest of all. First I will try to explain what I meant by saying \"proxy class\". If you're an intermediate JavaScript developer, you probably know that constructors can be overridden by returning a value explicitly. By doing that, we can actually bypass Emscripten's prohibitions, we can just return the newly created C++ instance and extend it in specific. Proxy classes actually take it a step further by providing a middle-class which will then inject a new link to the prototype chain of the returned instance.\n\n```js\nclass JSLine {\n  constructor() {\n    const line = new CPPShape();\n    return line;\n  }\n}\n\nconst line = new JSLine(); // Legal!\n```\n\n> More information about the code snippet above can be found [here](https://www.bennadel.com/blog/2522-providing-a-return-value-in-a-javascript-constructor.htm).\n\nI believe that as we go through this tutorial, the concept will get much clearer. The utility function of the proxy class should look like so:\n\n[{]: <helper> (diffStep 7.14)\n\n#### [Step 7.14: Add proxy utility method](https://github.com/DAB0mB/radial-snake/commit/06e615e)\n\n##### Changed resources&#x2F;scripts&#x2F;utils.js\n```diff\n@@ -20,5 +20,18 @@\n â”Š20â”Š20â”Š  // Overload handling\n â”Š21â”Š21â”Š  compare(context, num, method, precision = method) {\n â”Š22â”Š22â”Š    return CPP.Utils.compare(context, num, method, precision);\n+â”Š  â”Š23â”Š  },\n+â”Š  â”Š24â”Š\n+â”Š  â”Š25â”Š  proxy(Class) {\n+â”Š  â”Š26â”Š    return class extends Class {\n+â”Š  â”Š27â”Š      constructor() {\n+â”Š  â”Š28â”Š        // Initialize original class\n+â”Š  â”Š29â”Š        let that = new Class(...arguments);\n+â”Š  â”Š30â”Š        // Inject caller's prototype into the prototype chain\n+â”Š  â”Š31â”Š        Object.setPrototypeOf(that, new.target.prototype);\n+â”Š  â”Š32â”Š        // Will original instance will be the substitute for 'this'\n+â”Š  â”Š33â”Š        return that;\n+â”Š  â”Š34â”Š      }\n+â”Š  â”Š35â”Š    }\n â”Š23â”Š36â”Š  }\n â”Š24â”Š37â”Š});ðŸš«â†µ\n```\n\n[}]: #\n\nIf you'll take a look at the following line:\n\n```js\nObject.setPrototypeOf(that, new.target.prototype);\n```\n\nThis is where the magic actually happens! It enables inheritance for explicitly returned objects; This way we can safely extend C++ classes. Accordingly, our new JavaScript line class should look like so:\n\n[{]: <helper> (diffStep 7.15)\n\n#### [Step 7.15: Extend CPP line class](https://github.com/DAB0mB/radial-snake/commit/66acf9d)\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;geometry&#x2F;line.js\n```diff\n@@ -1,46 +1,10 @@\n-â”Š 1â”Š  â”ŠEngine.Geometry.Line = class Line {\n-â”Š 2â”Š  â”Š  // x1 - The first point's x value\n-â”Š 3â”Š  â”Š  // y1 - The first point's y value\n-â”Š 4â”Š  â”Š  // x1 - The second point's x value\n-â”Š 5â”Š  â”Š  // y2 - The second point's y value\n-â”Š 6â”Š  â”Š  constructor(x1, y1, x2, y2) {\n-â”Š 7â”Š  â”Š    this.x1 = Utils.trim(x1, 9);\n-â”Š 8â”Š  â”Š    this.y1 = Utils.trim(y1, 9);\n-â”Š 9â”Š  â”Š    this.x2 = Utils.trim(x2, 9);\n-â”Š10â”Š  â”Š    this.y2 = Utils.trim(y2, 9);\n-â”Š11â”Š  â”Š  }\n-â”Š12â”Š  â”Š\n+â”Š  â”Š 1â”ŠEngine.Geometry.Line = class Line extends Utils.proxy(CPP.Geometry.Line) {\n â”Š13â”Š 2â”Š  // Draws the line on the given context\n â”Š14â”Š 3â”Š  draw(context) {\n â”Š15â”Š 4â”Š    context.moveTo(this.x1, this.y1);\n â”Š16â”Š 5â”Š    context.lineTo(this.x2, this.y2);\n â”Š17â”Š 6â”Š  }\n â”Š18â”Š 7â”Š\n-â”Š19â”Š  â”Š  // Gets the matching x value for a given y value\n-â”Š20â”Š  â”Š  getX(y) {\n-â”Š21â”Š  â”Š    let x = Utils.trim((((y - this.y1) * (this.x2 - this.x1)) / (this.y2 - this.y1)) + this.x1, 9);\n-â”Š22â”Š  â”Š    if (isNaN(x) || Utils.isBetween(x, this.x1, this.x2)) return x;\n-â”Š23â”Š  â”Š  }\n-â”Š24â”Š  â”Š\n-â”Š25â”Š  â”Š  // Gets the matching y value for a given x value\n-â”Š26â”Š  â”Š  getY(x) {\n-â”Š27â”Š  â”Š    let y = Utils.trim((((x - this.x1) * (this.y2 - this.y1)) / (this.x2 - this.x1)) + this.y1, 9);\n-â”Š28â”Š  â”Š    if (isNaN(y) || Utils.isBetween(y, this.y1, this.y2)) return y;\n-â”Š29â”Š  â”Š  }\n-â”Š30â”Š  â”Š\n-â”Š31â”Š  â”Š  // Returns if line has given point\n-â”Š32â”Š  â”Š  hasPoint(x, y) {\n-â”Š33â”Š  â”Š    if (!this.boundsHavePoint(x, y)) return false;\n-â”Š34â”Š  â”Š    let m = Utils.trim((this.y2 - this.y1) / (this.x2 - this.x1), 9);\n-â”Š35â”Š  â”Š    return (y - this.y1) / (x - this.x1) == m;\n-â”Š36â”Š  â”Š  }\n-â”Š37â”Š  â”Š\n-â”Š38â”Š  â”Š  // Returns if given point is contained by the bounds aka cage of line\n-â”Š39â”Š  â”Š  boundsHavePoint(x, y) {\n-â”Š40â”Š  â”Š    return Utils.isBetween(x, this.x1, this.x2) &&\n-â”Š41â”Š  â”Š           Utils.isBetween(y, this.y1, this.y2);\n-â”Š42â”Š  â”Š  }\n-â”Š43â”Š  â”Š\n â”Š44â”Š 8â”Š  getIntersection(shape) {\n â”Š45â”Š 9â”Š    if (shape instanceof Engine.Geometry.Line)\n â”Š46â”Š10â”Š      return this.getLineIntersection(shape);\n```\n```diff\n@@ -50,23 +14,6 @@\n â”Š50â”Š14â”Š      return this.getPolygonIntersection(shape);\n â”Š51â”Š15â”Š  }\n â”Š52â”Š16â”Š\n-â”Š53â”Š  â”Š  // line - line intersection method\n-â”Š54â”Š  â”Š  getLineIntersection(line) {\n-â”Š55â”Š  â”Š    // Escape if lines are parallel\n-â”Š56â”Š  â”Š    if (!(((this.x1 - this.x2) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * (line.x1 - line.x2)))) return;\n-â”Š57â”Š  â”Š\n-â”Š58â”Š  â”Š    // Intersection point formula\n-â”Š59â”Š  â”Š    let x = Utils.trim(((((this.x1 * this.y2) - (this.y1 * this.x2)) * (line.x1 - line.x2)) - ((this.x1 - this.x2) * ((line.x1 * line.y2) - (line.y1 * line.x2)))) /\n-â”Š60â”Š  â”Š        (((this.x1 - this.x2) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * (line.x1 - line.x2))), 9);\n-â”Š61â”Š  â”Š    let y = Utils.trim(((((this.x1 * this.y2) - (this.y1 * this.x2)) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * ((line.x1 * line.y2) - (line.y1 * line.x2)))) /\n-â”Š62â”Š  â”Š        (((this.x1 - this.x2) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * (line.x1 - line.x2))), 9);\n-â”Š63â”Š  â”Š\n-â”Š64â”Š  â”Š    if (Utils.isBetween(x, this.x1, this.x2) && Utils.isBetween(x, line.x1, line.x2) &&\n-â”Š65â”Š  â”Š        Utils.isBetween(y, this.y1, this.y2) && Utils.isBetween(y, line.y1, line.y2)) {\n-â”Š66â”Š  â”Š      return { x, y };\n-â”Š67â”Š  â”Š    }\n-â”Š68â”Š  â”Š  }\n-â”Š69â”Š  â”Š\n â”Š70â”Š17â”Š  // line - circle intersection method\n â”Š71â”Š18â”Š  getCircleIntersection(circle) {\n â”Š72â”Š19â”Š    return circle.getLineIntersection(this);\n```\n\n[}]: #\n\nBy now, our tests should pass. Accept, there is memory leak we need to handle. But you probably ask yourself - \"What memory leak? It's JavaScript man! Have you ever heard of something called garbage collector?!\". Well, this is not the case when compiling C++ code with Emscripten. You see, Emscripten uses asm.js, which is a subset for JavaScript built exactly for these proposes, enabling C++ modules run on the browser. This is how the [WebGL](https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API) project actually started, an almost complete conversion from the famous C++ [OpenGL](https://www.opengl.org/) to JavaScript. Part of what asm.js does, it disables the garbage collector, and instead, it holds raw pointers, just like in C++. Since returned class instances are pointers with unknown lifespans, they need to be disposed manually, using the `delete` method (identical to how we clear memory from the Heap in C++). Let's dispose unused test data by calling the `delete` method as just mentioned:\n\n[{]: <helper> (diffStep 7.16)\n\n#### [Step 7.16: Delete line instances in tests](https://github.com/DAB0mB/radial-snake/commit/f181da4)\n\n##### Changed resources&#x2F;scripts&#x2F;specs&#x2F;engine&#x2F;geometry&#x2F;circle.js\n```diff\n@@ -111,6 +111,8 @@\n â”Š111â”Š111â”Š          { x: 6, y: 1 },\n â”Š112â”Š112â”Š          { x: -4, y: 1 }\n â”Š113â”Š113â”Š        ]);\n+â”Š   â”Š114â”Š\n+â”Š   â”Š115â”Š        line.delete();\n â”Š114â”Š116â”Š      });\n â”Š115â”Š117â”Š    });\n â”Š116â”Š118â”Š\n```\n```diff\n@@ -121,6 +123,8 @@\n â”Š121â”Š123â”Š        expect(this.circle.getLineIntersection(line)).toEqual([\n â”Š122â”Š124â”Š          { x: -4, y: 1 }\n â”Š123â”Š125â”Š        ]);\n+â”Š   â”Š126â”Š\n+â”Š   â”Š127â”Š        line.delete();\n â”Š124â”Š128â”Š      });\n â”Š125â”Š129â”Š    });\n â”Š126â”Š130â”Š\n```\n```diff\n@@ -131,6 +135,8 @@\n â”Š131â”Š135â”Š        expect(this.circle.getLineIntersection(line)).toEqual([\n â”Š132â”Š136â”Š          { x: 1, y: 6 }\n â”Š133â”Š137â”Š        ]);\n+â”Š   â”Š138â”Š\n+â”Š   â”Š139â”Š        line.delete();\n â”Š134â”Š140â”Š      });\n â”Š135â”Š141â”Š    });\n â”Š136â”Š142â”Š\n```\n```diff\n@@ -138,6 +144,7 @@\n â”Š138â”Š144â”Š      it(\"returns nothing\", function() {\n â”Š139â”Š145â”Š        let line = new Engine.Geometry.Line(-10, 10, 10, 10);\n â”Š140â”Š146â”Š        expect(this.circle.getLineIntersection(line)).toBeUndefined();\n+â”Š   â”Š147â”Š        line.delete();\n â”Š141â”Š148â”Š      });\n â”Š142â”Š149â”Š    });\n â”Š143â”Š150â”Š  });\n```\n\n##### Changed resources&#x2F;scripts&#x2F;specs&#x2F;engine&#x2F;geometry&#x2F;line.js\n```diff\n@@ -3,6 +3,10 @@\n â”Š 3â”Š 3â”Š    this.line = new Engine.Geometry.Line(-5, -5, 5, 5);\n â”Š 4â”Š 4â”Š  });\n â”Š 5â”Š 5â”Š\n+â”Š  â”Š 6â”Š  afterEach(function () {\n+â”Š  â”Š 7â”Š    this.line.delete();\n+â”Š  â”Š 8â”Š  });\n+â”Š  â”Š 9â”Š\n â”Š 6â”Š10â”Š  describe(\"getX method\", function() {\n â”Š 7â”Š11â”Š    describe(\"given inranged y\", function() {\n â”Š 8â”Š12â”Š      it(\"returns x\", function() {\n```\n```diff\n@@ -58,6 +62,8 @@\n â”Š58â”Š62â”Š          x: 1,\n â”Š59â”Š63â”Š          y: 1\n â”Š60â”Š64â”Š        });\n+â”Š  â”Š65â”Š\n+â”Š  â”Š66â”Š        line.delete();\n â”Š61â”Š67â”Š      });\n â”Š62â”Š68â”Š    });\n â”Š63â”Š69â”Š\n```\n```diff\n@@ -65,6 +71,7 @@\n â”Š65â”Š71â”Š      it(\"returns nothing\", function() {\n â”Š66â”Š72â”Š        let line = new Engine.Geometry.Line(-5, -6, 5, 4);\n â”Š67â”Š73â”Š        expect(this.line.getLineIntersection(line)).toBeUndefined();\n+â”Š  â”Š74â”Š        line.delete();\n â”Š68â”Š75â”Š      });\n â”Š69â”Š76â”Š    });\n â”Š70â”Š77â”Š\n```\n```diff\n@@ -72,6 +79,7 @@\n â”Š72â”Š79â”Š      it(\"returns nothing\", function() {\n â”Š73â”Š80â”Š        let line = new Engine.Geometry.Line(10, 10, 10, 15);\n â”Š74â”Š81â”Š        expect(this.line.getLineIntersection(line)).toBeUndefined();\n+â”Š  â”Š82â”Š        line.delete();\n â”Š75â”Š83â”Š      });\n â”Š76â”Š84â”Š    });\n â”Š77â”Š85â”Š  });\n```\n\n##### Changed resources&#x2F;scripts&#x2F;specs&#x2F;engine&#x2F;geometry&#x2F;polygon.js\n```diff\n@@ -35,6 +35,8 @@\n â”Š35â”Š35â”Š          { x: 5, y: 4 },\n â”Š36â”Š36â”Š          { x: 0, y: 1 }\n â”Š37â”Š37â”Š        ]);\n+â”Š  â”Š38â”Š\n+â”Š  â”Š39â”Š        line.delete();\n â”Š38â”Š40â”Š      });\n â”Š39â”Š41â”Š    });\n â”Š40â”Š42â”Š\n```\n```diff\n@@ -43,6 +45,8 @@\n â”Š43â”Š45â”Š        let line = new Engine.Geometry.Line(10, 11, 15, 14);\n â”Š44â”Š46â”Š\n â”Š45â”Š47â”Š        expect(this.polygon.getLineIntersection(line)).toBeUndefined();\n+â”Š  â”Š48â”Š\n+â”Š  â”Š49â”Š        line.delete();\n â”Š46â”Š50â”Š      });\n â”Š47â”Š51â”Š    });\n â”Š48â”Š52â”Š  });\n```\n\n[}]: #\n\nSince our game also uses polygons, which is made of an abstract number of lines, its test-data needs to be disposed as well. First, we will add a `delete` method to the polygon class, which will simply go though all its bounds and delete each of its lines:\n\n[{]: <helper> (diffStep 7.17)\n\n#### [Step 7.17: Add polygon deletion method](https://github.com/DAB0mB/radial-snake/commit/1c9447f)\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;geometry&#x2F;polygon.js\n```diff\n@@ -5,6 +5,10 @@\n â”Š 5â”Š 5â”Š    this.bounds = bounds.map(coords => new Engine.Geometry.Line(...coords));\n â”Š 6â”Š 6â”Š  }\n â”Š 7â”Š 7â”Š\n+â”Š  â”Š 8â”Š  delete() {\n+â”Š  â”Š 9â”Š    this.bounds.forEach(bound => bound.delete());\n+â”Š  â”Š10â”Š  }\n+â”Š  â”Š11â”Š\n â”Š 8â”Š12â”Š  // Returns if polygon has given point\n â”Š 9â”Š13â”Š  hasPoint(x, y) {\n â”Š10â”Š14â”Š    // Run check for each bound\n```\n\n[}]: #\n\nNow we can conveniently delete unused polygons in the tests:\n\n[{]: <helper> (diffStep 7.18)\n\n#### [Step 7.18: Delete polygon instances in tests](https://github.com/DAB0mB/radial-snake/commit/48024bc)\n\n##### Changed resources&#x2F;scripts&#x2F;specs&#x2F;engine&#x2F;geometry&#x2F;polygon.js\n```diff\n@@ -8,6 +8,10 @@\n â”Š 8â”Š 8â”Š    );\n â”Š 9â”Š 9â”Š  });\n â”Š10â”Š10â”Š\n+â”Š  â”Š11â”Š  afterEach(function () {\n+â”Š  â”Š12â”Š    this.polygon.delete();\n+â”Š  â”Š13â”Š  });\n+â”Š  â”Š14â”Š\n â”Š11â”Š15â”Š  describe(\"hasPoint method\", function() {\n â”Š12â”Š16â”Š    describe(\"given contained point\", function() {\n â”Š13â”Š17â”Š      it(\"returns true\", function() {\n```\n\n[}]: #\n\nMoving on, we have the circle class to transform. The process is almost the identical to how we transformed the line class, so it's gonna be way easier now. We first start by translating our code from JavaScript to C++:\n\n[{]: <helper> (diffStep 7.19)\n\n#### [Step 7.19: Add base circle CPP module](https://github.com/DAB0mB/radial-snake/commit/1a3fa58)\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;geometry&#x2F;circle.cpp\n```diff\n@@ -0,0 +1,202 @@\n+â”Š   â”Š  1â”Š\n+â”Š   â”Š  2â”Š#include <algorithm>\n+â”Š   â”Š  3â”Š#include <cmath>\n+â”Š   â”Š  4â”Š#include <vector>\n+â”Š   â”Š  5â”Š#include \"../nullable.h\"\n+â”Š   â”Š  6â”Š#include \"../utils.h\"\n+â”Š   â”Š  7â”Š#include \"point.h\"\n+â”Š   â”Š  8â”Š#include \"line.h\"\n+â”Š   â”Š  9â”Š\n+â”Š   â”Š 10â”Šnamespace geometry {\n+â”Š   â”Š 11â”Š  // x - The x value of the circle's center\n+â”Š   â”Š 12â”Š  // y - The y value of the circle's center\n+â”Š   â”Š 13â”Š  // r - The radius of the center\n+â”Š   â”Š 14â”Š  // rad1 - The first radian of the circle, not necessarily its beginning\n+â”Š   â”Š 15â”Š  // rad2 - The second radian of the circle, not necessarily its beginning\n+â”Š   â”Š 16â”Š  Circle::Circle(double x, double y, double r, double rad1, double rad2) {\n+â”Š   â”Š 17â”Š    _x = utils::trim(x, 9);\n+â”Š   â”Š 18â”Š    _y = utils::trim(y, 9);\n+â”Š   â”Š 19â”Š    _r = utils::trim(r, 9);\n+â”Š   â”Š 20â”Š\n+â”Š   â”Š 21â”Š    // Trimming mode is done based on which radian represents the ending and which radian\n+â”Š   â”Š 22â”Š    // represents the ending\n+â”Š   â”Š 23â”Š    if (rad1 > rad2) {\n+â”Š   â”Š 24â”Š      _rad1 = utils::trim(rad1, 9, \"floor\");\n+â”Š   â”Š 25â”Š      _rad2 = utils::trim(rad2, 9, \"ceil\");\n+â”Š   â”Š 26â”Š    }\n+â”Š   â”Š 27â”Š    else {\n+â”Š   â”Š 28â”Š      _rad1 = utils::trim(rad1, 9, \"ceil\");\n+â”Š   â”Š 29â”Š      _rad2 = utils::trim(rad2, 9, \"floor\");\n+â”Š   â”Š 30â”Š    }\n+â”Š   â”Š 31â”Š  }\n+â”Š   â”Š 32â”Š\n+â”Š   â”Š 33â”Š  // Gets the matching x value for the given radian\n+â”Š   â”Š 34â”Š  Nullable<double> Circle::getMatchingX(double rad) {\n+â”Š   â”Š 35â”Š    if (!utils::chain(rad)->trim(9)->isBetween(_rad1, _rad2)->result()) {\n+â”Š   â”Š 36â”Š      return Nullable<double>();\n+â”Š   â”Š 37â”Š    }\n+â”Š   â”Š 38â”Š\n+â”Š   â”Š 39â”Š    return Nullable<double>(utils::trim((_r * std::cos(rad)) + _x, 9));\n+â”Š   â”Š 40â”Š  }\n+â”Š   â”Š 41â”Š\n+â”Š   â”Š 42â”Š  // Gets the matching y value for the given radian\n+â”Š   â”Š 43â”Š  Nullable<double> Circle::getMatchingY(double rad) {\n+â”Š   â”Š 44â”Š    if (!utils::chain(rad)->trim(9)->isBetween(_rad1, _rad2)->result()) {\n+â”Š   â”Š 45â”Š      return Nullable<double>();\n+â”Š   â”Š 46â”Š    }\n+â”Š   â”Š 47â”Š\n+â”Š   â”Š 48â”Š    return Nullable<double>(utils::trim((_r * std::sin(rad)) + _y, 9));\n+â”Š   â”Š 49â”Š  }\n+â”Š   â”Š 50â”Š\n+â”Š   â”Š 51â”Š  // Gets the matching point for the given radian\n+â”Š   â”Š 52â”Š  Nullable<Point> Circle::getMatchingPoint(double rad) {\n+â”Š   â”Š 53â”Š    if (!utils::isBetween(rad, _rad1, _rad2)) {\n+â”Š   â”Š 54â”Š      return Nullable<Point>();\n+â”Š   â”Š 55â”Š    }\n+â”Š   â”Š 56â”Š\n+â”Š   â”Š 57â”Š    return Nullable<Point>({\n+â”Š   â”Š 58â”Š      utils::trim((_r * std::cos(rad)) + _x, 9),\n+â”Š   â”Š 59â”Š      utils::trim((_r * std::sin(rad)) + _y, 9)\n+â”Š   â”Š 60â”Š    });\n+â”Š   â”Š 61â”Š  }\n+â”Š   â”Š 62â”Š\n+â”Š   â”Š 63â”Š  // Gets the matching radian for the given point\n+â”Š   â”Š 64â”Š  Nullable<double> Circle::getMatchingRad(double x, double y) {\n+â”Š   â”Š 65â”Š    double rad = std::atan2(y - _y, x - _x);\n+â”Š   â”Š 66â”Š\n+â”Š   â”Š 67â”Š    // If calculated radian is in circle's radian range, return it\n+â”Š   â”Š 68â”Š    if (!std::isnan(rad) && utils::isBetween(rad, _rad1, _rad2)) {\n+â”Š   â”Š 69â”Š      return Nullable<double>(rad);\n+â”Š   â”Š 70â”Š    }\n+â”Š   â”Š 71â”Š\n+â”Š   â”Š 72â”Š    // The calculated radian can still be in the circle's radian range in case one\n+â”Š   â”Š 73â”Š    // of the radians is greater than 2 PIEs\n+â”Š   â”Š 74â”Š    double greatestRad = std::abs(_rad1) > std::abs(_rad2) ? _rad1 : _rad2;\n+â”Š   â”Š 75â”Š\n+â”Š   â”Š 76â”Š    // Check if the absolute radian is in the circle's radian range\n+â”Š   â”Š 77â”Š    if (utils::chain(rad + (2 * M_PI * std::floor(greatestRad / (2 * M_PI))))\n+â”Š   â”Š 78â”Š        ->trim(9)->isBetween(_rad1, _rad2)->result() ||\n+â”Š   â”Š 79â”Š        utils::chain(rad + (2 * M_PI * std::ceil(greatestRad / (2 * M_PI))))\n+â”Š   â”Š 80â”Š        ->trim(9)->isBetween(_rad1, _rad2)->result()) {\n+â”Š   â”Š 81â”Š      return Nullable<double>(rad);\n+â”Š   â”Š 82â”Š    }\n+â”Š   â”Š 83â”Š\n+â”Š   â”Š 84â”Š    return Nullable<double>();\n+â”Š   â”Š 85â”Š  }\n+â”Š   â”Š 86â”Š\n+â”Š   â”Š 87â”Š  // Returns if circle has given points\n+â”Š   â”Š 88â”Š  bool Circle::hasPoint(double x, double y) {\n+â”Š   â”Š 89â”Š    return getMatchingRad(x, y).hasValue();\n+â”Š   â”Š 90â”Š  }\n+â”Š   â”Š 91â”Š\n+â”Š   â”Š 92â”Š  // circle - circle intersection method\n+â”Š   â”Š 93â”Š  Nullable<std::vector<Point>> Circle::getIntersection(Circle circle) {\n+â”Š   â”Š 94â”Š    double dx = circle._x - _x;\n+â”Š   â”Š 95â”Š    double dy = circle._y - _y;\n+â”Š   â”Š 96â”Š    double d = std::sqrt(std::pow(dx, 2) + std::pow(dy, 2));\n+â”Š   â”Š 97â”Š\n+â”Š   â”Š 98â”Š    if (d > _r + circle._r ||\n+â”Š   â”Š 99â”Š       d < std::abs(_r - circle._r)) {\n+â”Š   â”Š100â”Š      return Nullable<std::vector<Point>>();\n+â”Š   â”Š101â”Š    }\n+â”Š   â”Š102â”Š\n+â”Š   â”Š103â”Š    double a = ((std::pow(_r, 2) - std::pow(circle._r, 2)) + std::pow(d, 2)) / (2 * d);\n+â”Š   â”Š104â”Š    double x = _x + ((dx * a) / d);\n+â”Š   â”Š105â”Š    double y = _y + ((dy * a) / d);\n+â”Š   â”Š106â”Š    double h = std::sqrt(std::pow(_r, 2) - std::pow(a, 2));\n+â”Š   â”Š107â”Š    double rx = (- dy * h) / d;\n+â”Š   â”Š108â”Š    double ry = (dx * h) / d;\n+â”Š   â”Š109â”Š\n+â”Š   â”Š110â”Š    std::vector<Point> interPoints(2);\n+â”Š   â”Š111â”Š    interPoints.at(0).x = x + rx;\n+â”Š   â”Š112â”Š    interPoints.at(0).y = y + ry;\n+â”Š   â”Š113â”Š    interPoints.at(1).x = x - rx;\n+â”Š   â”Š114â”Š    interPoints.at(1).y = y - ry;\n+â”Š   â”Š115â”Š\n+â”Š   â”Š116â”Š    for (unsigned i = 0; i < interPoints.size(); i++) {\n+â”Š   â”Š117â”Š      Point& point = interPoints.at(i);\n+â”Š   â”Š118â”Š      point.x = utils::trim(point.x, 9);\n+â”Š   â”Š119â”Š      point.y = utils::trim(point.y, 9);\n+â”Š   â”Š120â”Š    }\n+â”Š   â”Š121â”Š\n+â”Š   â”Š122â”Š    auto pointsBegin = std::unique(interPoints.begin(), interPoints.end(),\n+â”Š   â”Š123â”Š      [](Point pointA, Point pointB) {\n+â”Š   â”Š124â”Š        return pointA.x == pointB.x && pointA.y == pointB.y;\n+â”Š   â”Š125â”Š      }\n+â”Š   â”Š126â”Š    );\n+â”Š   â”Š127â”Š\n+â”Š   â”Š128â”Š    interPoints.erase(pointsBegin, interPoints.end());\n+â”Š   â”Š129â”Š\n+â”Š   â”Š130â”Š    std::vector<Circle> circles = { *this, circle };\n+â”Š   â”Š131â”Š\n+â”Š   â”Š132â”Š    std::for_each(circles.begin(), circles.end(), [&interPoints](Circle circle) {\n+â”Š   â”Š133â”Š      auto pointsBegin = std::remove_if(interPoints.begin(), interPoints.end(),\n+â”Š   â”Š134â”Š        [&circle](Point point) {\n+â”Š   â”Š135â”Š          return !circle.hasPoint(point.x, point.y);\n+â”Š   â”Š136â”Š        }\n+â”Š   â”Š137â”Š      );\n+â”Š   â”Š138â”Š\n+â”Š   â”Š139â”Š      interPoints.erase(pointsBegin, interPoints.end());\n+â”Š   â”Š140â”Š    });\n+â”Š   â”Š141â”Š\n+â”Š   â”Š142â”Š    if (interPoints.size()) {\n+â”Š   â”Š143â”Š      return Nullable<std::vector<Point>>(interPoints);\n+â”Š   â”Š144â”Š    }\n+â”Š   â”Š145â”Š\n+â”Š   â”Š146â”Š    return Nullable<std::vector<Point>>();\n+â”Š   â”Š147â”Š  }\n+â”Š   â”Š148â”Š\n+â”Š   â”Š149â”Š  // circle - line intersection method\n+â”Š   â”Š150â”Š  Nullable<std::vector<Point>> Circle::getIntersection(Line line) {\n+â”Š   â”Š151â”Š    double x1 = line._x1 - _x;\n+â”Š   â”Š152â”Š    double x2 = line._x2 - _x;\n+â”Š   â”Š153â”Š    double y1 = line._y1 - _y;\n+â”Š   â”Š154â”Š    double y2 = line._y2 - _y;\n+â”Š   â”Š155â”Š    double dx = x2 - x1;\n+â”Š   â”Š156â”Š    double dy = y2 - y1;\n+â”Š   â”Š157â”Š    double d = std::sqrt(std::pow(dx, 2) + std::pow(dy, 2));\n+â”Š   â”Š158â”Š    double h = (x1 * y2) - (x2 * y1);\n+â”Š   â”Š159â”Š    double delta = (std::pow(_r, 2) * std::pow(d, 2)) - std::pow(h, 2);\n+â”Š   â”Š160â”Š\n+â”Š   â”Š161â”Š    if (delta < 0) Nullable<std::vector<Point>>();\n+â”Š   â”Š162â”Š\n+â”Š   â”Š163â”Š    double sign = dy / std::abs(dy); if (std::isnan(sign)) sign = 1;\n+â”Š   â”Š164â”Š    double sqrtx = sign * dx * std::sqrt(delta);\n+â”Š   â”Š165â”Š    double sqrty = std::abs(dy) * std::sqrt(delta);\n+â”Š   â”Š166â”Š\n+â”Š   â”Š167â”Š    std::vector<Point> interPoints(2);\n+â”Š   â”Š168â”Š    interPoints.at(0).x = (((h * dy) + sqrtx) / std::pow(d, 2)) + _x;\n+â”Š   â”Š169â”Š    interPoints.at(0).y = (((-h * dx) + sqrty) / std::pow(d, 2)) + _y;\n+â”Š   â”Š170â”Š    interPoints.at(1).x = (((h * dy) - sqrtx) / std::pow(d, 2)) + _x;\n+â”Š   â”Š171â”Š    interPoints.at(1).y = (((-h * dx) - sqrty) / std::pow(d, 2)) + _y;\n+â”Š   â”Š172â”Š\n+â”Š   â”Š173â”Š    for (unsigned i = 0; i < interPoints.size(); i++) {\n+â”Š   â”Š174â”Š      Point& point = interPoints.at(i);\n+â”Š   â”Š175â”Š      point.x = utils::trim(point.x, 9);\n+â”Š   â”Š176â”Š      point.y = utils::trim(point.y, 9);\n+â”Š   â”Š177â”Š    }\n+â”Š   â”Š178â”Š\n+â”Š   â”Š179â”Š    auto pointsBegin = std::remove_if(interPoints.begin(), interPoints.end(),\n+â”Š   â”Š180â”Š      [this, &line](Point point) {\n+â”Š   â”Š181â”Š        return !hasPoint(point.x, point.y) ||\n+â”Š   â”Š182â”Š          !line.boundsHavePoint(point.x, point.y);\n+â”Š   â”Š183â”Š      }\n+â”Š   â”Š184â”Š    );\n+â”Š   â”Š185â”Š\n+â”Š   â”Š186â”Š    interPoints.erase(pointsBegin, interPoints.end());\n+â”Š   â”Š187â”Š\n+â”Š   â”Š188â”Š    pointsBegin = std::unique(interPoints.begin(), interPoints.end(),\n+â”Š   â”Š189â”Š      [](Point pointA, Point pointB) {\n+â”Š   â”Š190â”Š        return pointA.x == pointB.x && pointA.y == pointB.y;\n+â”Š   â”Š191â”Š      }\n+â”Š   â”Š192â”Š    );\n+â”Š   â”Š193â”Š\n+â”Š   â”Š194â”Š    interPoints.erase(pointsBegin, interPoints.end());\n+â”Š   â”Š195â”Š\n+â”Š   â”Š196â”Š    if (interPoints.size()) {\n+â”Š   â”Š197â”Š      return Nullable<std::vector<Point>>(interPoints);\n+â”Š   â”Š198â”Š    }\n+â”Š   â”Š199â”Š\n+â”Š   â”Š200â”Š    return Nullable<std::vector<Point>>();\n+â”Š   â”Š201â”Š  }\n+â”Š   â”Š202â”Š}ðŸš«â†µ\n```\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;geometry&#x2F;circle.h\n```diff\n@@ -0,0 +1,35 @@\n+â”Š  â”Š 1â”Š#pragma once\n+â”Š  â”Š 2â”Š\n+â”Š  â”Š 3â”Š#include <vector>\n+â”Š  â”Š 4â”Š#include \"../nullable.h\"\n+â”Š  â”Š 5â”Š#include \"point.h\"\n+â”Š  â”Š 6â”Š#include \"line.h\"\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Šnamespace geometry {\n+â”Š  â”Š 9â”Š  class Line;\n+â”Š  â”Š10â”Š\n+â”Š  â”Š11â”Š  class Circle {\n+â”Š  â”Š12â”Š  public:\n+â”Š  â”Š13â”Š    double _x;\n+â”Š  â”Š14â”Š    double _y;\n+â”Š  â”Š15â”Š    double _r;\n+â”Š  â”Š16â”Š    double _rad1;\n+â”Š  â”Š17â”Š    double _rad2;\n+â”Š  â”Š18â”Š\n+â”Š  â”Š19â”Š    Circle(double x, double y, double r, double rad1, double rad2);\n+â”Š  â”Š20â”Š\n+â”Š  â”Š21â”Š    Nullable<double> getMatchingX(double rad);\n+â”Š  â”Š22â”Š\n+â”Š  â”Š23â”Š    Nullable<double> getMatchingY(double rad);\n+â”Š  â”Š24â”Š\n+â”Š  â”Š25â”Š    Nullable<Point> getMatchingPoint(double rad);\n+â”Š  â”Š26â”Š\n+â”Š  â”Š27â”Š    Nullable<double> getMatchingRad(double x, double y);\n+â”Š  â”Š28â”Š\n+â”Š  â”Š29â”Š    bool hasPoint(double x, double y);\n+â”Š  â”Š30â”Š\n+â”Š  â”Š31â”Š    Nullable<std::vector<Point>> getIntersection(Circle circle);\n+â”Š  â”Š32â”Š\n+â”Š  â”Š33â”Š    Nullable<std::vector<Point>> getIntersection(Line line);\n+â”Š  â”Š34â”Š  };\n+â”Š  â”Š35â”Š}ðŸš«â†µ\n```\n\n##### Changed resources&#x2F;cpp&#x2F;src&#x2F;index.cpp\n```diff\n@@ -1,3 +1,4 @@\n â”Š1â”Š1â”Š#include \"nullable.cpp\"\n â”Š2â”Š2â”Š#include \"utils.cpp\"\n-â”Š3â”Š â”Š#include \"geometry/line.cpp\"ðŸš«â†µ\n+â”Š â”Š3â”Š#include \"geometry/line.cpp\"\n+â”Š â”Š4â”Š#include \"geometry/circle.cpp\"ðŸš«â†µ\n```\n\n[}]: #\n\nSecond, we need to wrap our code using EMBind:\n\n[{]: <helper> (diffStep 7.2)\n\n#### [Step 7.2: Add base utility CPP module](https://github.com/DAB0mB/radial-snake/commit/6dba512)\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;utils.cpp\n```diff\n@@ -0,0 +1,73 @@\n+â”Š  â”Š 1â”Š#include <cfloat>\n+â”Š  â”Š 2â”Š#include <cmath>\n+â”Š  â”Š 3â”Š#include <string>\n+â”Š  â”Š 4â”Š#include \"utils.h\"\n+â”Š  â”Š 5â”Š\n+â”Š  â”Š 6â”Šnamespace utils {\n+â”Š  â”Š 7â”Š  // Fixed modulo method which can calculate modulo of negative numbers properly\n+â”Š  â”Š 8â”Š  // e.g. (-803).mod(800) returns 797\n+â”Š  â”Š 9â”Š  double mod(double context, double num) {\n+â”Š  â”Š10â”Š    return std::fmod((std::fmod(context, num) + num), num);\n+â”Š  â”Š11â”Š  }\n+â”Š  â”Š12â”Š\n+â”Š  â”Š13â”Š  // Trims number and leaves the number of decimals specified.\n+â”Š  â”Š14â”Š  // The \"mode\" argument specifies which math function should be invoked\n+â”Š  â”Š15â”Š  // right after the number has been trimmed.\n+â”Š  â”Š16â”Š  // e.g. 12.12345.trim(3, \"ceil\") returns 12.124\n+â”Š  â”Š17â”Š  double trim(double context, int decimals, const std::string mode) {\n+â”Š  â”Š18â”Š    double accumulator = context * std::pow(10, decimals);\n+â”Š  â”Š19â”Š\n+â”Š  â”Š20â”Š    if (mode.compare(\"ceil\") == 0)\n+â”Š  â”Š21â”Š      accumulator = std::ceil(accumulator);\n+â”Š  â”Š22â”Š    else if (mode.compare(\"floor\") == 0)\n+â”Š  â”Š23â”Š      accumulator = std::floor(accumulator);\n+â”Š  â”Š24â”Š    else\n+â”Š  â”Š25â”Š      accumulator = std::round(accumulator);\n+â”Š  â”Š26â”Š\n+â”Š  â”Š27â”Š    return accumulator / std::pow(10, decimals);\n+â”Š  â”Š28â”Š  }\n+â”Š  â”Š29â”Š\n+â”Š  â”Š30â”Š  // Tells if number is in specified range based on given precision.\n+â”Š  â”Š31â”Š  // See the \"compare\" method for more information about precision\n+â”Š  â”Š32â”Š  bool isBetween(double context, double num1, double num2, const std::string precision) {\n+â”Š  â”Š33â”Š    return compare(context, std::min(num1, num2), \">=\", precision) &&\n+â”Š  â”Š34â”Š           compare(context, std::max(num1, num2), \"<=\", precision);\n+â”Š  â”Š35â”Š  }\n+â”Š  â”Š36â”Š\n+â”Š  â”Š37â”Š  bool compare(double context, double num, const std::string precision) {\n+â”Š  â”Š38â”Š    return compare(context, num, \"==\", precision);\n+â”Š  â”Š39â”Š  }\n+â”Š  â”Š40â”Š\n+â”Š  â”Š41â”Š  // Initiates comparison operator between context number and a given number, only here\n+â”Š  â”Š42â”Š  // a precision can be specified\n+â”Š  â”Š43â”Š  bool compare(double context, double num, const std::string method, const std::string precision) {\n+â”Š  â”Š44â”Š    // Fixed precision, \"almost equal\" with a deviation of Îµ\n+â”Š  â”Š45â”Š    if (precision.compare(\"f\") == 0) {\n+â”Š  â”Š46â”Š      if (method.compare(\"<\") == 0 ||\n+â”Š  â”Š47â”Š          method.compare(\"<=\") == 0)\n+â”Š  â”Š48â”Š        return context <= num + DBL_EPSILON;\n+â”Š  â”Š49â”Š      if (method.compare(\">\") == 0 ||\n+â”Š  â”Š50â”Š          method.compare(\">=\") == 0)\n+â”Š  â”Š51â”Š        return context >= num - DBL_EPSILON;\n+â”Š  â”Š52â”Š      return std::abs(context - num) <= DBL_EPSILON;\n+â”Š  â”Š53â”Š    }\n+â”Š  â”Š54â”Š    // Pixel precision, round comparison\n+â”Š  â”Š55â”Š    else if (precision.compare(\"px\") == 0) {\n+â”Š  â”Š56â”Š      if (method.compare(\"<\") == 0 ||\n+â”Š  â”Š57â”Š          method.compare(\"<=\") == 0)\n+â”Š  â”Š58â”Š        return std::round(context) <= std::round(num);\n+â”Š  â”Š59â”Š      if (method.compare(\">\") == 0 ||\n+â”Š  â”Š60â”Š          method.compare(\">=\") == 0)\n+â”Š  â”Š61â”Š        return std::round(context) >= std::round(num);\n+â”Š  â”Š62â”Š      return std::round(context) == std::round(num);\n+â”Š  â”Š63â”Š    }\n+â”Š  â”Š64â”Š    // Exact precision\n+â”Š  â”Š65â”Š    else {\n+â”Š  â”Š66â”Š      if (method.compare(\"<\") == 0) return context < num;\n+â”Š  â”Š67â”Š      if (method.compare(\"<=\") == 0) return context <= num;\n+â”Š  â”Š68â”Š      if (method.compare(\">\") == 0) return context > num;\n+â”Š  â”Š69â”Š      if (method.compare(\">=\") == 0) return context >= num;\n+â”Š  â”Š70â”Š      return context == num;\n+â”Š  â”Š71â”Š    }\n+â”Š  â”Š72â”Š  }\n+â”Š  â”Š73â”Š}ðŸš«â†µ\n```\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;utils.h\n```diff\n@@ -0,0 +1,15 @@\n+â”Š  â”Š 1â”Š#pragma once\n+â”Š  â”Š 2â”Š\n+â”Š  â”Š 3â”Š#include <string>\n+â”Š  â”Š 4â”Š\n+â”Š  â”Š 5â”Šnamespace utils {\n+â”Š  â”Š 6â”Š  double mod(double context, double num);\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Š  double trim(double context, int decimals, const std::string mode = \"round\");\n+â”Š  â”Š 9â”Š\n+â”Š  â”Š10â”Š  bool isBetween(double context, double num1, double num2, const std::string precision = \"exact\");\n+â”Š  â”Š11â”Š\n+â”Š  â”Š12â”Š  bool compare(double context, double num, const std::string precision = \"exact\");\n+â”Š  â”Š13â”Š\n+â”Š  â”Š14â”Š  bool compare(double context, double num, const std::string method, const std::string precision);\n+â”Š  â”Š15â”Š}ðŸš«â†µ\n```\n\n[}]: #\n\nAnd finally, we will extend the C++ in our JavaScript circle:\n\n[{]: <helper> (diffStep 7.21)\n\n#### [Step 7.21: Extend CPP circle class](https://github.com/DAB0mB/radial-snake/commit/d05cf32)\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;geometry&#x2F;circle.js\n```diff\n@@ -1,83 +1,9 @@\n-â”Š 1â”Š  â”ŠEngine.Geometry.Circle = class Circle {\n-â”Š 2â”Š  â”Š  // x - The x value of the circle's center\n-â”Š 3â”Š  â”Š  // y - The y value of the circle's center\n-â”Š 4â”Š  â”Š  // r - The radius of the center\n-â”Š 5â”Š  â”Š  // rad1 - The first radian of the circle, not necessarily its beginning\n-â”Š 6â”Š  â”Š  // rad2 - The second radian of the circle, not necessarily its beginning\n-â”Š 7â”Š  â”Š  constructor(x, y, r, rad1, rad2) {\n-â”Š 8â”Š  â”Š    this.x = Utils.trim(x, 9);\n-â”Š 9â”Š  â”Š    this.y = Utils.trim(y, 9);\n-â”Š10â”Š  â”Š    this.r = Utils.trim(r, 9);\n-â”Š11â”Š  â”Š\n-â”Š12â”Š  â”Š    // Trimming mode is done based on which radian represents the ending and which radian\n-â”Š13â”Š  â”Š    // represents the ending\n-â”Š14â”Š  â”Š    if (rad1 > rad2) {\n-â”Š15â”Š  â”Š      this.rad1 = Utils.trim(rad1, 9, \"floor\");\n-â”Š16â”Š  â”Š      this.rad2 = Utils.trim(rad2, 9, \"ceil\");\n-â”Š17â”Š  â”Š    }\n-â”Š18â”Š  â”Š    else {\n-â”Š19â”Š  â”Š      this.rad1 = Utils.trim(rad1, 9, \"ceil\");\n-â”Š20â”Š  â”Š      this.rad2 = Utils.trim(rad2, 9, \"floor\");\n-â”Š21â”Š  â”Š    }\n-â”Š22â”Š  â”Š  }\n-â”Š23â”Š  â”Š\n+â”Š  â”Š 1â”ŠEngine.Geometry.Circle = class Circle extends Utils.proxy(CPP.Geometry.Circle) {\n â”Š24â”Š 2â”Š  // Draws the circle on the given context\n â”Š25â”Š 3â”Š  draw(context) {\n â”Š26â”Š 4â”Š    context.arc(this.x, this.y, this.r, this.rad1, this.rad2);\n â”Š27â”Š 5â”Š  }\n â”Š28â”Š 6â”Š\n-â”Š29â”Š  â”Š  // Gets the matching x value for the given radian\n-â”Š30â”Š  â”Š  getX(rad) {\n-â”Š31â”Š  â”Š    if (!Utils(rad).trim(9).isBetween(this.rad1, this.rad2).value()) return;\n-â”Š32â”Š  â”Š    return Utils.trim((this.r * Math.cos(rad)) + this.x, 9);\n-â”Š33â”Š  â”Š  }\n-â”Š34â”Š  â”Š\n-â”Š35â”Š  â”Š  // Gets the matching y value for the given radian\n-â”Š36â”Š  â”Š  getY(rad) {\n-â”Š37â”Š  â”Š    if (!Utils(rad).trim(9).isBetween(this.rad1, this.rad2).value()) return;\n-â”Š38â”Š  â”Š    return Utils.trim((this.r * Math.sin(rad)) + this.y, 9);\n-â”Š39â”Š  â”Š  }\n-â”Š40â”Š  â”Š\n-â”Š41â”Š  â”Š  // Gets the matching point for the given radian\n-â”Š42â”Š  â”Š  getPoint(rad) {\n-â”Š43â”Š  â”Š    if (!Utils.isBetween(rad, this.rad1, this.rad2)) return;\n-â”Š44â”Š  â”Š\n-â”Š45â”Š  â”Š    return {\n-â”Š46â”Š  â”Š      x: Utils.trim((this.r * Math.cos(rad)) + this.x, 9),\n-â”Š47â”Š  â”Š      y: Utils.trim((this.r * Math.sin(rad)) + this.y, 9)\n-â”Š48â”Š  â”Š    };\n-â”Š49â”Š  â”Š  }\n-â”Š50â”Š  â”Š\n-â”Š51â”Š  â”Š  // Gets the matching radian for the given point\n-â”Š52â”Š  â”Š  getRad(x, y) {\n-â”Š53â”Š  â”Š    let rad = Math.atan2(y - this.y, x - this.x);\n-â”Š54â”Š  â”Š\n-â”Š55â”Š  â”Š    // If calculated radian is in circle's radian range, return it\n-â”Š56â”Š  â”Š    if (rad != null && Utils.isBetween(rad, this.rad1, this.rad2)) {\n-â”Š57â”Š  â”Š      return rad;\n-â”Š58â”Š  â”Š    }\n-â”Š59â”Š  â”Š\n-â”Š60â”Š  â”Š    // The calculated radian can still be in the circle's radian range in case one\n-â”Š61â”Š  â”Š    // of the radians is greater than 2 PIEs\n-â”Š62â”Š  â”Š    if (Math.abs(this.rad1) > Math.abs(this.rad2)) {\n-â”Š63â”Š  â”Š      var greatestRad = this.rad1;\n-â”Š64â”Š  â”Š    }\n-â”Š65â”Š  â”Š    else {\n-â”Š66â”Š  â”Š      var greatestRad = this.rad2;\n-â”Š67â”Š  â”Š    }\n-â”Š68â”Š  â”Š\n-â”Š69â”Š  â”Š    // Check if the absolute radian is in the circle's radian range\n-â”Š70â”Š  â”Š    if (Utils(rad + (2 * Math.PI * Math.floor(greatestRad / (2 * Math.PI)))).trim(9).isBetween(this.rad1, this.rad2).value() ||\n-â”Š71â”Š  â”Š        Utils(rad + (2 * Math.PI * Math.ceil(greatestRad / (2 * Math.PI)))).trim(9).isBetween(this.rad1, this.rad2).value()) {\n-â”Š72â”Š  â”Š      return rad;\n-â”Š73â”Š  â”Š    }\n-â”Š74â”Š  â”Š  }\n-â”Š75â”Š  â”Š\n-â”Š76â”Š  â”Š  // Returns if circle has given points\n-â”Š77â”Š  â”Š  hasPoint(x, y) {\n-â”Š78â”Š  â”Š    return this.getRad(x, y) != null;\n-â”Š79â”Š  â”Š  }\n-â”Š80â”Š  â”Š\n â”Š81â”Š 7â”Š  getIntersection(shape) {\n â”Š82â”Š 8â”Š    if (shape instanceof Engine.Geometry.Line)\n â”Š83â”Š 9â”Š      return this.getLineIntersection(shape);\n```\n```diff\n@@ -87,86 +13,6 @@\n â”Š 87â”Š 13â”Š      return this.getPolygonIntersection(shape);\n â”Š 88â”Š 14â”Š  }\n â”Š 89â”Š 15â”Š\n-â”Š 90â”Š   â”Š  // circle - circle intersection method\n-â”Š 91â”Š   â”Š  getCircleIntersection(circle) {\n-â”Š 92â”Š   â”Š    let dx = circle.x - this.x;\n-â”Š 93â”Š   â”Š    let dy = circle.y - this.y;\n-â”Š 94â”Š   â”Š    let d = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\n-â”Š 95â”Š   â”Š\n-â”Š 96â”Š   â”Š    if (d > this.r + circle.r ||\n-â”Š 97â”Š   â”Š       d < Math.abs(this.r - circle.r)) {\n-â”Š 98â”Š   â”Š      return;\n-â”Š 99â”Š   â”Š    }\n-â”Š100â”Š   â”Š\n-â”Š101â”Š   â”Š    let a = ((Math.pow(this.r, 2) - Math.pow(circle.r, 2)) + Math.pow(d, 2)) / (2 * d);\n-â”Š102â”Š   â”Š    let x = this.x + ((dx * a) / d);\n-â”Š103â”Š   â”Š    let y = this.y + ((dy * a) / d);\n-â”Š104â”Š   â”Š    let h = Math.sqrt(Math.pow(this.r, 2) - Math.pow(a, 2));\n-â”Š105â”Š   â”Š    let rx = (- dy * h) / d;\n-â”Š106â”Š   â”Š    let ry = (dx * h) / d;\n-â”Š107â”Š   â”Š\n-â”Š108â”Š   â”Š    let interPoints = [\n-â”Š109â”Š   â”Š      {\n-â”Š110â”Š   â”Š        x: x + rx,\n-â”Š111â”Š   â”Š        y: y + ry\n-â”Š112â”Š   â”Š      },\n-â”Š113â”Š   â”Š      {\n-â”Š114â”Š   â”Š        x: x - rx,\n-â”Š115â”Š   â”Š        y: y - ry\n-â”Š116â”Š   â”Š      }\n-â”Š117â”Š   â”Š    ]\n-â”Š118â”Š   â”Š    .map(point => ({\n-â”Š119â”Š   â”Š        x: Utils.trim(point.x, 9),\n-â”Š120â”Š   â”Š        y: Utils.trim(point.y, 9)\n-â”Š121â”Š   â”Š     }));\n-â”Š122â”Š   â”Š\n-â”Š123â”Š   â”Š    interPoints = _.uniq(interPoints, point => `(${point.x}, ${point.y})`);\n-â”Š124â”Š   â”Š\n-â”Š125â”Š   â”Š    [this, circle].forEach(function(circle) {\n-â”Š126â”Š   â”Š      interPoints = interPoints.filter(point => circle.hasPoint(point.x, point.y));\n-â”Š127â”Š   â”Š    });\n-â”Š128â”Š   â”Š\n-â”Š129â”Š   â”Š    if (interPoints.length > 0) return interPoints;\n-â”Š130â”Š   â”Š  }\n-â”Š131â”Š   â”Š\n-â”Š132â”Š   â”Š  // circle - line intersection method\n-â”Š133â”Š   â”Š  getLineIntersection(line) {\n-â”Š134â”Š   â”Š    let x1 = line.x1 - this.x;\n-â”Š135â”Š   â”Š    let x2 = line.x2 - this.x;\n-â”Š136â”Š   â”Š    let y1 = line.y1 - this.y;\n-â”Š137â”Š   â”Š    let y2 = line.y2 - this.y;\n-â”Š138â”Š   â”Š    let dx = x2 - x1;\n-â”Š139â”Š   â”Š    let dy = y2 - y1;\n-â”Š140â”Š   â”Š    let d = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\n-â”Š141â”Š   â”Š    let h = (x1 * y2) - (x2 * y1);\n-â”Š142â”Š   â”Š    let delta = (Math.pow(this.r, 2) * Math.pow(d, 2)) - Math.pow(h, 2);\n-â”Š143â”Š   â”Š\n-â”Š144â”Š   â”Š    if (delta < 0) return;\n-â”Š145â”Š   â”Š\n-â”Š146â”Š   â”Š    let interPoints = [\n-â”Š147â”Š   â”Š      {\n-â”Š148â”Š   â”Š        x: (((h * dy) + (((dy / Math.abs(dy)) || 1) * dx * Math.sqrt(delta))) / Math.pow(d, 2)) + this.x,\n-â”Š149â”Š   â”Š        y: (((-h * dx) + (Math.abs(dy) * Math.sqrt(delta))) / Math.pow(d, 2)) + this.y\n-â”Š150â”Š   â”Š      },\n-â”Š151â”Š   â”Š      {\n-â”Š152â”Š   â”Š        x: (((h * dy) - (((dy / Math.abs(dy)) || 1) * dx * Math.sqrt(delta))) / Math.pow(d, 2)) + this.x,\n-â”Š153â”Š   â”Š        y: (((-h * dx) - (Math.abs(dy) * Math.sqrt(delta))) / Math.pow(d, 2)) + this.y\n-â”Š154â”Š   â”Š      }\n-â”Š155â”Š   â”Š    ]\n-â”Š156â”Š   â”Š    .map(point => ({\n-â”Š157â”Š   â”Š        x: Utils.trim(point.x, 9),\n-â”Š158â”Š   â”Š        y: Utils.trim(point.y, 9)\n-â”Š159â”Š   â”Š    }))\n-â”Š160â”Š   â”Š    .filter(point => {\n-â”Š161â”Š   â”Š      return this.hasPoint(point.x, point.y) &&\n-â”Š162â”Š   â”Š        line.boundsHavePoint(point.x, point.y);\n-â”Š163â”Š   â”Š    });\n-â”Š164â”Š   â”Š\n-â”Š165â”Š   â”Š    interPoints = _.uniq(interPoints, point => `(${point.x}, ${point.y})`);\n-â”Š166â”Š   â”Š\n-â”Š167â”Š   â”Š    if (interPoints.length > 0) return interPoints;\n-â”Š168â”Š   â”Š  }\n-â”Š169â”Š   â”Š\n â”Š170â”Š 16â”Š  // circle - polygon intersection method\n â”Š171â”Š 17â”Š  getPolygonIntersection(polygon) {\n â”Š172â”Š 18â”Š    return polygon.getCircleIntersection(this);\n```\n\n[}]: #\n\nWe also need to update the line class to contain a reference to the newly created line-intersection method, so it can be invoked from both a line or a circle bi-directionally:\n\n[{]: <helper> (diffStep 7.22)\n\n#### [Step 7.22: Add line-circle intersection method](https://github.com/DAB0mB/radial-snake/commit/84f5f4d)\n\n##### Changed resources&#x2F;cpp&#x2F;src&#x2F;geometry&#x2F;line.cpp\n```diff\n@@ -4,6 +4,7 @@\n â”Š 4â”Š 4â”Š#include \"../nullable.h\"\n â”Š 5â”Š 5â”Š#include \"../utils.h\"\n â”Š 6â”Š 6â”Š#include \"point.h\"\n+â”Š  â”Š 7â”Š#include \"circle.h\"\n â”Š 7â”Š 8â”Š#include \"line.h\"\n â”Š 8â”Š 9â”Š\n â”Š 9â”Š10â”Šnamespace geometry {\n```\n```diff\n@@ -100,6 +101,11 @@\n â”Š100â”Š101â”Š    return Nullable<Point>();\n â”Š101â”Š102â”Š  }\n â”Š102â”Š103â”Š\n+â”Š   â”Š104â”Š  // circle - circle intersection method\n+â”Š   â”Š105â”Š  Nullable<std::vector<Point>> Line::getIntersection(Circle circle) {\n+â”Š   â”Š106â”Š    return circle.getIntersection(*this);\n+â”Š   â”Š107â”Š  }\n+â”Š   â”Š108â”Š\n â”Š103â”Š109â”Š  emscripten::val EMLine::getMatchingX(double y) {\n â”Š104â”Š110â”Š    Nullable<double> nullableX = Line::getMatchingX(y);\n â”Š105â”Š111â”Š    return nullableX.hasValue() ?\n```\n```diff\n@@ -126,6 +132,10 @@\n â”Š126â”Š132â”Š    emPoint.set(\"y\", emscripten::val(point.y));\n â”Š127â”Š133â”Š    return emPoint;\n â”Š128â”Š134â”Š  }\n+â”Š   â”Š135â”Š\n+â”Š   â”Š136â”Š  emscripten::val EMLine::getIntersection(EMCircle emCircle) {\n+â”Š   â”Š137â”Š    return emCircle.getIntersection(*this);\n+â”Š   â”Š138â”Š  }\n â”Š129â”Š139â”Š}\n â”Š130â”Š140â”Š\n â”Š131â”Š141â”ŠEMSCRIPTEN_BINDINGS(geometry_line_module) {\n```\n```diff\n@@ -146,5 +156,10 @@\n â”Š146â”Š156â”Š      emscripten::select_overload<emscripten::val(geometry::EMLine)>(\n â”Š147â”Š157â”Š        &geometry::EMLine::getIntersection\n â”Š148â”Š158â”Š      )\n+â”Š   â”Š159â”Š    )\n+â”Š   â”Š160â”Š    .function(\"getCircleIntersection\",\n+â”Š   â”Š161â”Š      emscripten::select_overload<emscripten::val(geometry::EMCircle)>(\n+â”Š   â”Š162â”Š        &geometry::EMLine::getIntersection\n+â”Š   â”Š163â”Š      )\n â”Š149â”Š164â”Š    );\n â”Š150â”Š165â”Š}ðŸš«â†µ\n```\n\n##### Changed resources&#x2F;cpp&#x2F;src&#x2F;geometry&#x2F;line.h\n```diff\n@@ -4,6 +4,7 @@\n â”Š 4â”Š 4â”Š#include <emscripten/val.h>\n â”Š 5â”Š 5â”Š#include \"../nullable.h\"\n â”Š 6â”Š 6â”Š#include \"point.h\"\n+â”Š  â”Š 7â”Š#include \"circle.h\"\n â”Š 7â”Š 8â”Š\n â”Š 8â”Š 9â”Šnamespace geometry {\n â”Š 9â”Š10â”Š  class Circle;\n```\n```diff\n@@ -27,6 +28,8 @@\n â”Š27â”Š28â”Š    bool boundsHavePoint(double x, double y);\n â”Š28â”Š29â”Š\n â”Š29â”Š30â”Š    Nullable<Point> getIntersection(Line line);\n+â”Š  â”Š31â”Š\n+â”Š  â”Š32â”Š    Nullable<std::vector<Point>> getIntersection(Circle circle);\n â”Š30â”Š33â”Š  };\n â”Š31â”Š34â”Š\n â”Š32â”Š35â”Š  class EMLine : public Line {\n```\n```diff\n@@ -38,5 +41,7 @@\n â”Š38â”Š41â”Š    emscripten::val getMatchingY(double x);\n â”Š39â”Š42â”Š\n â”Š40â”Š43â”Š    emscripten::val getIntersection(EMLine line);\n+â”Š  â”Š44â”Š\n+â”Š  â”Š45â”Š    emscripten::val getIntersection(EMCircle circle);\n â”Š41â”Š46â”Š  };\n â”Š42â”Š47â”Š}ðŸš«â†µ\n```\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;geometry&#x2F;line.js\n```diff\n@@ -14,11 +14,6 @@\n â”Š14â”Š14â”Š      return this.getPolygonIntersection(shape);\n â”Š15â”Š15â”Š  }\n â”Š16â”Š16â”Š\n-â”Š17â”Š  â”Š  // line - circle intersection method\n-â”Š18â”Š  â”Š  getCircleIntersection(circle) {\n-â”Š19â”Š  â”Š    return circle.getLineIntersection(this);\n-â”Š20â”Š  â”Š  }\n-â”Š21â”Š  â”Š\n â”Š22â”Š17â”Š  // line - polygon intersection method\n â”Š23â”Š18â”Š  getPolygonIntersection(polygon) {\n â”Š24â”Š19â”Š    return polygon.getLineIntersection(this);\n```\n\n[}]: #\n\nNow, before running the tests, be sure to disposed unused circle test-data:\n\n[{]: <helper> (diffStep 7.23)\n\n#### [Step 7.23: Delete circle instances in tests](https://github.com/DAB0mB/radial-snake/commit/e953fae)\n\n##### Changed resources&#x2F;scripts&#x2F;specs&#x2F;engine&#x2F;geometry&#x2F;circle.js\n```diff\n@@ -3,6 +3,10 @@\n â”Š 3â”Š 3â”Š    this.circle = new Engine.Geometry.Circle(1, 1, 5, 0, 1.5 * Math.PI);\n â”Š 4â”Š 4â”Š  });\n â”Š 5â”Š 5â”Š\n+â”Š  â”Š 6â”Š  afterEach(function () {\n+â”Š  â”Š 7â”Š    this.circle.delete();\n+â”Š  â”Š 8â”Š  });\n+â”Š  â”Š 9â”Š\n â”Š 6â”Š10â”Š  describe(\"getX method\", function() {\n â”Š 7â”Š11â”Š    describe(\"given inranged rad\", function() {\n â”Š 8â”Š12â”Š      it(\"returns x\", function() {\n```\n```diff\n@@ -64,6 +68,8 @@\n â”Š64â”Š68â”Š          { x: -2, y: -3 },\n â”Š65â”Š69â”Š          { x: -2, y: 5 }\n â”Š66â”Š70â”Š        ]);\n+â”Š  â”Š71â”Š\n+â”Š  â”Š72â”Š        circle.delete();\n â”Š67â”Š73â”Š      });\n â”Š68â”Š74â”Š    });\n â”Š69â”Š75â”Š\n```\n```diff\n@@ -74,6 +80,8 @@\n â”Š74â”Š80â”Š        expect(this.circle.getCircleIntersection(circle)).toEqual([\n â”Š75â”Š81â”Š          { x: -2, y: 5 }\n â”Š76â”Š82â”Š        ]);\n+â”Š  â”Š83â”Š\n+â”Š  â”Š84â”Š        circle.delete();\n â”Š77â”Š85â”Š      });\n â”Š78â”Š86â”Š    });\n â”Š79â”Š87â”Š\n```\n```diff\n@@ -84,6 +92,8 @@\n â”Š84â”Š92â”Š        expect(this.circle.getCircleIntersection(circle)).toEqual([\n â”Š85â”Š93â”Š          { x: -4, y: 1 }\n â”Š86â”Š94â”Š        ]);\n+â”Š  â”Š95â”Š\n+â”Š  â”Š96â”Š        circle.delete();\n â”Š87â”Š97â”Š      });\n â”Š88â”Š98â”Š    });\n â”Š89â”Š99â”Š\n```\n```diff\n@@ -91,6 +101,7 @@\n â”Š 91â”Š101â”Š      it(\"returns nothing\", function() {\n â”Š 92â”Š102â”Š        let circle = new Engine.Geometry.Circle(10, 10, 2, 0, 2 * Math.PI);\n â”Š 93â”Š103â”Š        expect(this.circle.getCircleIntersection(circle)).toBeUndefined();\n+â”Š   â”Š104â”Š        circle.delete();\n â”Š 94â”Š105â”Š      });\n â”Š 95â”Š106â”Š    });\n â”Š 96â”Š107â”Š\n```\n```diff\n@@ -98,6 +109,7 @@\n â”Š 98â”Š109â”Š      it(\"nothing\", function() {\n â”Š 99â”Š110â”Š        let circle = new Engine.Geometry.Circle(1, 1, 2, 0, 2 * Math.PI);\n â”Š100â”Š111â”Š        expect(this.circle.getCircleIntersection(circle)).toBeUndefined();\n+â”Š   â”Š112â”Š        circle.delete();\n â”Š101â”Š113â”Š      });\n â”Š102â”Š114â”Š    });\n â”Š103â”Š115â”Š  });\n```\n\n##### Changed resources&#x2F;scripts&#x2F;specs&#x2F;engine&#x2F;geometry&#x2F;polygon.js\n```diff\n@@ -64,6 +64,8 @@\n â”Š64â”Š64â”Š          { x: 2, y: 0 },\n â”Š65â”Š65â”Š          { x: 0, y: 2 }\n â”Š66â”Š66â”Š        ]);\n+â”Š  â”Š67â”Š\n+â”Š  â”Š68â”Š        circle.delete();\n â”Š67â”Š69â”Š      });\n â”Š68â”Š70â”Š    });\n â”Š69â”Š71â”Š\n```\n```diff\n@@ -74,6 +76,8 @@\n â”Š74â”Š76â”Š        expect(this.polygon.getCircleIntersection(circle)).toEqual([\n â”Š75â”Š77â”Š          { x: 2, y: 0 }\n â”Š76â”Š78â”Š        ]);\n+â”Š  â”Š79â”Š\n+â”Š  â”Š80â”Š        circle.delete();\n â”Š77â”Š81â”Š      });\n â”Š78â”Š82â”Š    });\n â”Š79â”Š83â”Š\n```\n```diff\n@@ -84,6 +88,8 @@\n â”Š84â”Š88â”Š        expect(this.polygon.getCircleIntersection(circle)).toEqual([\n â”Š85â”Š89â”Š          { x: 0, y: 3 }\n â”Š86â”Š90â”Š        ]);\n+â”Š  â”Š91â”Š\n+â”Š  â”Š92â”Š        circle.delete();\n â”Š87â”Š93â”Š      });\n â”Š88â”Š94â”Š    });\n â”Š89â”Š95â”Š\n```\n```diff\n@@ -91,6 +97,7 @@\n â”Š 91â”Š 97â”Š      it(\"returns nothing\", function() {\n â”Š 92â”Š 98â”Š        let circle = new Engine.Geometry.Circle(10, 10, 2, 0, 2 * Math.PI);\n â”Š 93â”Š 99â”Š        expect(this.polygon.getCircleIntersection(circle)).toBeUndefined();\n+â”Š   â”Š100â”Š        circle.delete();\n â”Š 94â”Š101â”Š      });\n â”Š 95â”Š102â”Š    });\n â”Š 96â”Š103â”Š\n```\n```diff\n@@ -98,6 +105,7 @@\n â”Š 98â”Š105â”Š      it(\"nothing\", function() {\n â”Š 99â”Š106â”Š        let circle = new Engine.Geometry.Circle(2.5, 2.5, 2, 0, 2 * Math.PI);\n â”Š100â”Š107â”Š        expect(this.polygon.getCircleIntersection(circle)).toBeUndefined();\n+â”Š   â”Š108â”Š        circle.delete();\n â”Š101â”Š109â”Š      });\n â”Š102â”Š110â”Š    });\n â”Š103â”Š111â”Š  });\n```\n\n[}]: #\n\nOur C++ code should be finished now, and all the tests should be passing. The only thing left to do would be applying it to our game. Like any other application, we first need to reference the script file so it can be loaded, in this case, the C++ bundle script:\n\n[{]: <helper> (diffStep 7.24)\n\n#### [Step 7.24: Load CPP bundle in game](https://github.com/DAB0mB/radial-snake/commit/a2c0d46)\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -8,6 +8,7 @@\n â”Š 8â”Š 8â”Š    <script type=\"text/javascript\" src=\"/libs/underscore.js\"></script>\n â”Š 9â”Š 9â”Š\n â”Š10â”Š10â”Š    <!-- Scripts -->\n+â”Š  â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/cpp.bundle.js\"></script>\n â”Š11â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/utils.js\"></script>\n â”Š12â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/geometry/line.js\"></script>\n```\n\n[}]: #\n\nAnd now we need to make sure to dispose the geometry shapes correctly so we won't experience any unnecessary memory leaks. Most of our disposals should go to the snake entity, since it's made out of shapes; So we will add a `delete` method to the snake entity and we will dispose it whenever a match is finished:\n\n[{]: <helper> (diffStep 7.25)\n\n#### [Step 7.25: Delete shape instances in game](https://github.com/DAB0mB/radial-snake/commit/ae58323)\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;game.js\n```diff\n@@ -95,6 +95,7 @@\n â”Š 95â”Š 95â”Š  changeScreen(Screen, ...screenArgs) {\n â”Š 96â”Š 96â”Š    // If there is a screen defined, dispose it first\n â”Š 97â”Š 97â”Š    if (this.screen) {\n+â”Š   â”Š 98â”Š      this.screen.delete();\n â”Š 98â”Š 99â”Š      this.unloadScreen();\n â”Š 99â”Š100â”Š      this.screen.disposeEventListeners();\n â”Š100â”Š101â”Š    }\n```\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;layer.js\n```diff\n@@ -23,6 +23,9 @@\n â”Š23â”Š23â”Š    this.canvas = screen.game.canvas;\n â”Š24â”Š24â”Š  }\n â”Š25â”Š25â”Š\n+â”Š  â”Š26â”Š  delete() {\n+â”Š  â”Š27â”Š  }\n+â”Š  â”Š28â”Š\n â”Š26â”Š29â”Š  update(span) {\n â”Š27â”Š30â”Š  }\n â”Š28â”Š31â”Š\n```\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;screen.js\n```diff\n@@ -28,6 +28,13 @@\n â”Š28â”Š28â”Š    return this;\n â”Š29â”Š29â”Š  }\n â”Š30â”Š30â”Š\n+â”Š  â”Š31â”Š   // Delete all layers. Same as 'unload', only it disposes memory rather than assets\n+â”Š  â”Š32â”Š  delete() {\n+â”Š  â”Š33â”Š    this.layers.forEach(layer => {\n+â”Š  â”Š34â”Š      layer.delete();\n+â”Š  â”Š35â”Š    });\n+â”Š  â”Š36â”Š  }\n+â”Š  â”Š37â”Š\n â”Š31â”Š38â”Š  // Updates each layer\n â”Š32â”Š39â”Š  update(span) {\n â”Š33â”Š40â”Š    this.layers.forEach(layer => {\n```\n```diff\n@@ -61,6 +68,7 @@\n â”Š61â”Š68â”Š  removeLayer(layer) {\n â”Š62â”Š69â”Š    this.layers = _.without(this.layers, layer);\n â”Š63â”Š70â”Š    layer.disposeEventListeners();\n+â”Š  â”Š71â”Š    layer.delete();\n â”Š64â”Š72â”Š  }\n â”Š65â”Š73â”Š\n â”Š66â”Š74â”Š  initEventListeners() {\n```\n\n##### Changed resources&#x2F;scripts&#x2F;game&#x2F;entities&#x2F;snake.js\n```diff\n@@ -31,6 +31,10 @@\n â”Š31â”Š31â”Š    }\n â”Š32â”Š32â”Š  }\n â”Š33â”Š33â”Š\n+â”Š  â”Š34â”Š  delete() {\n+â”Š  â”Š35â”Š    this.shapes.forEach(shape => shape.delete());\n+â”Š  â”Š36â”Š  }\n+â”Š  â”Š37â”Š\n â”Š34â”Š38â”Š  draw(context) {\n â”Š35â”Š39â”Š    // Draw all shapes in the shapes array\n â”Š36â”Š40â”Š    this.shapes.forEach(shape => {\n```\n```diff\n@@ -229,6 +233,8 @@\n â”Š229â”Š233â”Š      [0, height, 0, 0]\n â”Š230â”Š234â”Š    );\n â”Š231â”Š235â”Š\n-â”Š232â”Š   â”Š    return canvasPolygon.getIntersection(this.lastBit);\n+â”Š   â”Š236â”Š    let result = canvasPolygon.getIntersection(this.lastBit);\n+â”Š   â”Š237â”Š    canvasPolygon.delete();\n+â”Š   â”Š238â”Š    return result;\n â”Š233â”Š239â”Š  }\n â”Š234â”Š240â”Š};ðŸš«â†µ\n```\n\n##### Changed resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;play&#x2F;snake.js\n```diff\n@@ -43,6 +43,10 @@\n â”Š43â”Š43â”Š    screen.appendLayer(Game.Screens.Play.Score, this.snakes);\n â”Š44â”Š44â”Š  }\n â”Š45â”Š45â”Š\n+â”Š  â”Š46â”Š  unload() {\n+â”Š  â”Š47â”Š    this.snakes.forEach(snake => snake.delete());\n+â”Š  â”Š48â”Š  }\n+â”Š  â”Š49â”Š\n â”Š46â”Š50â”Š  draw(context) {\n â”Š47â”Š51â”Š    // Draw each snake in the snakes array\n â”Š48â”Š52â”Š    this.snakes.forEach(snake => snake.draw(context));\n```\n\n[}]: #\n\nCongratulations! You've created a C++ cross JavaScript game. There shouldn't be any significant difference between the C++ version of the game and the JavaScript version on most machines, since the game is very small and barely requires any processing power. You'll probably notice the difference when starting to extend the game by adding terrains or more snakes.\n\nOne might ask - \"How much faster does my game actually run?\". The short answer is - around 50%. Why did I run into this conclusion? Well, take a look at the following JavaScript code snippet, for calculating Fibonacci of 42:\n\n```js\nfunction fib(x) {\n  if (x < 2) {\n    return 1;\n  }\n  else {\n    return fib(x - 1) + fib(x - 2);\n  }\n}\n```\n\nThe same code snippet should look almost identical written in C++:\n\n```cpp\nint fib(int x) {\n  if (x < 2) {\n    return 1;\n  }\n  else {\n    return fib(x - 1) + fib(x - 2);\n  }\n}\n```\n\nHowever, the run-times are completely different! I compared the average of 10 runs in 3 different environments, and I received the following results:\n\n![chart](https://cloud.githubusercontent.com/assets/7648874/22802494/2591025e-eef8-11e6-9679-10b5bca0ef30.png)\n\nAs you can see, the generated C++ is much faster, and to be precise, 57% faster! Surprisingly, I didn't have any significant difference between Emscripten generated C++ and natively compiled executable.\n\nC++ is more complex to write, but it certainly has its advantages over JavaScript. Remember, now that you know that you have the possibility to run C++ in the browser, make sure to use it, but never overdo it, always find the right balance between readability and performance.\n\n> *Sources:*\n> - *https://kripken.github.io/emscripten-site/docs/introducing_emscripten/index.html*\n> - *http://www.crunchy.com/?q=content/emscripten-perfectly-cromulent-compiler*\n> - *http://stackoverflow.com/questions/2354725/what-exactly-is-llvm*"
          }
        ]
      },
      {
        "releaseVersion": "0.1.3",
        "releaseDate": "2017-04-23 02:36:35 -0200",
        "tagName": "master@0.1.3",
        "tagRevision": "c69695f7f85ac663117d7376f30a0f9c86ca6f75",
        "historyRevision": "8b8973ecb7717162b5b2ccfa3d5b55d83240ccfa",
        "changesDiff": "",
        "manuals": [
          {
            "manualTitle": "How to implement a game engine in JavaScript and build a Tron-style game",
            "stepRevision": "08b88f5a9d7b2d3ba4c8a67a1433218ef6a6a3a5",
            "manualView": "![snake-demo-full-small](https://cloud.githubusercontent.com/assets/7648874/21073892/ae331a8a-bed2-11e6-9141-9554f9bb808b.gif)\n\nThis tutorial will guide you through the following steps:\n\n- [**Step 1**](https://github.com/DAB0mB/radial-snake/blob/master/.tortilla/manuals/views/step1.md) - Creating a server\n- [**Step 2**](https://github.com/DAB0mB/radial-snake/blob/master/.tortilla/manuals/views/step2.md) - Creating a game engine basis\n- [**Step 3**](https://github.com/DAB0mB/radial-snake/blob/master/.tortilla/manuals/views/step3.md) - Creating a splash screen using a keyframe animation engine\n- [**Step 4**](https://github.com/DAB0mB/radial-snake/blob/master/.tortilla/manuals/views/step4.md) - Creating a main menu screen using a font engine\n- [**Step 5**](https://github.com/DAB0mB/radial-snake/blob/master/.tortilla/manuals/views/step5.md) - Creating a snake and related geometry shapes\n- [**Step 6**](https://github.com/DAB0mB/radial-snake/blob/master/.tortilla/manuals/views/step6.md) - Creating a complex game screen with multiple layers\n- [**Step 7**](https://github.com/DAB0mB/radial-snake/blob/master/.tortilla/manuals/views/step7.md) - Bonus! Re-implementing geometry in C++\n\nMake sure you have the following software installed:\n\n- NodeJS with an ECMAScript 2015 support (v6.0.0 and above).\n- Any web-browser which supports ECMAScript 2015, with a preference for Google Chrome.\n\n> The final project is a hybrid of C++ and JavaScript. A JavaScript **only** version of this tutorial is available [here](https://github.com/DAB0mB/radial-snake/tree/master%40step6%400.1.3).\n\nThis tutorial is mostly based on pure JavaScript, so people can have a deeper understanding of the language and its dynamics. In addition, this tutorial makes a great practice on how to build a nice architecture for complex systems, which can then be expanded and maintained with ease. Yes, it is specifically designed for games, but I truly believe that video games can easily get messed up if not planned and designed properly in terms of object oriented relationships. They are naturally more complicated then any web-app you gonna see out there, so if you can create a game engine and understand its flow, creating a web-app would be a piece of cake for you. By the end of this tutorial, your general sense for programming should be enhanced greatly.\n\nSo hopefully that I got you pumped up by now, let's get started!"
          },
          {
            "manualTitle": "Step 1: Creating a server",
            "stepRevision": "1aed2194c509617dbe79447e2615aa34728262bc",
            "manualView": "The first thing we will learn to do would be creating a server so we can serve our assets. We will be using [HapiJS](https://hapijs.com/) to build a REST API, although this step can be implemented with any library you'd want, like [ExpressJS](http://expressjs.com/) or [Connect](https://www.senchalabs.github.com/connect) etc. Let's install it then:\n\n    $ npm install hapi --save\n\nWe will start by setting up a basis for our server, and we will expand it as we go further in this step. A general boiler plate should look like so:\n\n[{]: <helper> (diffStep 1.2)\n\n#### [Step 1.2: Add server basis](https://github.com/DAB0mB/radial-snake/commit/8ff8805)\n\n##### Added server.js\n```diff\n@@ -0,0 +1,36 @@\n+â”Š  â”Š 1â”Šconst Hapi = require(\"hapi\");\n+â”Š  â”Š 2â”Š\n+â”Š  â”Š 3â”Šlet port = 8000;\n+â”Š  â”Š 4â”Š\n+â”Š  â”Š 5â”Š// Initialize a new server\n+â”Š  â”Š 6â”Šlet server = new Hapi.Server();\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Šserver.connection({ port: process.env.PORT || port });\n+â”Š  â”Š 9â”Š\n+â”Š  â”Š10â”Š// Report each response made\n+â”Š  â”Š11â”Šserver.ext(\"onPreResponse\", (req, rep) => {\n+â”Š  â”Š12â”Š  let res = req.response;\n+â”Š  â”Š13â”Š\n+â”Š  â”Š14â”Š  console.log(\"Outcoming response:\");\n+â”Š  â”Š15â”Š  console.log(`in: ${new Date}`);\n+â”Š  â”Š16â”Š  console.log(`to: ${req.info.remoteAddress}`);\n+â”Š  â”Š17â”Š  console.log(`method: ${req.method}`);\n+â”Š  â”Š18â”Š  console.log(`url: ${req.url.path}`);\n+â”Š  â”Š19â”Š  console.log(`status: ${res.statusCode || res.output.statusCode}`);\n+â”Š  â”Š20â”Š  console.log();\n+â”Š  â”Š21â”Š\n+â”Š  â”Š22â”Š  rep.continue();\n+â”Š  â”Š23â”Š});\n+â”Š  â”Š24â”Š\n+â”Š  â”Š25â”Š// Print message once started\n+â”Š  â”Š26â”Šserver.start((err) => {\n+â”Š  â”Š27â”Š  if (err) throw err;\n+â”Š  â”Š28â”Š\n+â”Š  â”Š29â”Š  console.log();\n+â”Š  â”Š30â”Š  console.log(\"---------- -------- ------ ---- --\");\n+â”Š  â”Š31â”Š  console.log(\"----- ---- --- -- -\");\n+â”Š  â”Š32â”Š  console.log(`Server running at ${port}`);\n+â”Š  â”Š33â”Š  console.log(\"----- ---- --- -- -\");\n+â”Š  â”Š34â”Š  console.log(\"---------- -------- ------ ---- --\");\n+â”Š  â”Š35â”Š  console.log();\n+â”Š  â”Š36â”Š});ðŸš«â†µ\n```\n\n[}]: #\n\nWe simply initialize a new server which will connect to port `8000` by default, unless we defined an environment variable called `PORT`. Once the server is started, and whenever there is an outcoming response, a message will be printed to the console.\n\n> More information and configuration options regards HapiJS's API can be found in this [here](https://hapijs.com/).\n\nNow that the basis is ready, we want a convenient way to launch it. Repetitive scripts are usually defined in the `package.json` file under the `scripts` field. To start the server, we gonna create a simple script called `serve`:\n\n[{]: <helper> (diffStep 1.3)\n\n#### [Step 1.3: Add serve npm script](https://github.com/DAB0mB/radial-snake/commit/6e7d691)\n\n##### Changed package.json\n```diff\n@@ -6,6 +6,9 @@\n â”Š 6â”Š 6â”Š    \"url\": \"https://DAB0mB@github.com/DAB0mB/radial-snake.git\"\n â”Š 7â”Š 7â”Š  },\n â”Š 8â”Š 8â”Š  \"private\": true,\n+â”Š  â”Š 9â”Š  \"scripts\": {\n+â”Š  â”Š10â”Š    \"serve\": \"node server.js\"\n+â”Š  â”Š11â”Š  },\n â”Š 9â”Š12â”Š  \"dependencies\": {\n â”Š10â”Š13â”Š    \"hapi\": \"^16.0.1\"\n â”Š11â”Š14â”Š  }\n```\n\n[}]: #\n\nTo run this script, we will simply need to type the following:\n\n    $ npm run serve\n\nThis will run our server, and you should see the following message printed to the console:\n\n```\n---------- -------- ------ ---- --\n----- ---- --- -- -\nServer running at 8000\n----- ---- --- -- -\n---------- -------- ------ ---- --\n```\n\n> As for now, nothing happens, because we didn't define any handlers for HTTP requests. I will get to it in a bit, stay with me.\n\nThe main disadvantage of starting a server directly with node is that we have no listeners for changes in our files, so if we want the served files to be updated, we will have to restart our server anytime we make a change. To avoid that, we gonna use [nodemon](https://nodemon.io/), which is a simple utility that can monitor changes is source files and automatically restart our server. To install it, type the following:\n\n    $ sudo npm install nodemon -g\n\nNow that we have it, we will need to update our `serve` npm script to use `nodemon` instead of `node`:\n\n[{]: <helper> (diffStep 1.4)\n\n#### [Step 1.4: Change serve npm script to use nodemon](https://github.com/DAB0mB/radial-snake/commit/a238294)\n\n##### Changed package.json\n```diff\n@@ -7,7 +7,7 @@\n â”Š 7â”Š 7â”Š  },\n â”Š 8â”Š 8â”Š  \"private\": true,\n â”Š 9â”Š 9â”Š  \"scripts\": {\n-â”Š10â”Š  â”Š    \"serve\": \"node server.js\"\n+â”Š  â”Š10â”Š    \"serve\": \"nodemon server.js\"\n â”Š11â”Š11â”Š  },\n â”Š12â”Š12â”Š  \"dependencies\": {\n â”Š13â”Š13â”Š    \"hapi\": \"^16.0.1\"\n```\n\n[}]: #\n\nThe basis for our server is pretty much complete. From now on we gonna build stuff on top of it and extend our server. I'd like to add a small attachment to our server. I want that the IP address of the current computer will be printed to the console once the server is started. For this, we first gonna create a helper which we gonna call `ip_grabber`:\n\n[{]: <helper> (diffStep 1.5)\n\n#### [Step 1.5: Add ip_grabber helper](https://github.com/DAB0mB/radial-snake/commit/8ff1d1c)\n\n##### Added helpers&#x2F;ip_grabber.js\n```diff\n@@ -0,0 +1,23 @@\n+â”Š  â”Š 1â”Šconst Os = require(\"os\");\n+â”Š  â”Š 2â”Š\n+â”Š  â”Š 3â”Š// Grab local IP address of which the NodeJS process runs on\n+â”Š  â”Š 4â”Šfunction local() {\n+â”Š  â”Š 5â”Š  let interfaces = Os.networkInterfaces();\n+â”Š  â”Š 6â”Š  let addresses = [];\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Š  for (let k in interfaces) {\n+â”Š  â”Š 9â”Š    for (let k2 in interfaces[k]) {\n+â”Š  â”Š10â”Š      let address = interfaces[k][k2];\n+â”Š  â”Š11â”Š\n+â”Š  â”Š12â”Š      if (address.family == \"IPv4\" && !address.internal) {\n+â”Š  â”Š13â”Š        addresses.push(address.address);\n+â”Š  â”Š14â”Š      }\n+â”Š  â”Š15â”Š    }\n+â”Š  â”Š16â”Š  }\n+â”Š  â”Š17â”Š\n+â”Š  â”Š18â”Š  return addresses[0];\n+â”Š  â”Š19â”Š}\n+â”Š  â”Š20â”Š\n+â”Š  â”Š21â”Šmodule.exports = {\n+â”Š  â”Š22â”Š  local\n+â”Š  â”Š23â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nThis module simply goes through the available network interfaces and grabs the IP address of the default gateway using the `os` module. Now that we have it, let's import it in the server's entry file and use the `local` method to grab the IP address and report it once the server is started:\n\n[{]: <helper> (diffStep 1.6)\n\n#### [Step 1.6: Print IP address once server is started](https://github.com/DAB0mB/radial-snake/commit/18ed984)\n\n##### Changed server.js\n```diff\n@@ -1,5 +1,7 @@\n â”Š1â”Š1â”Šconst Hapi = require(\"hapi\");\n+â”Š â”Š2â”Šconst IpGrabber = require(\"./helpers/ip_grabber\");\n â”Š2â”Š3â”Š\n+â”Š â”Š4â”Šlet localIp = IpGrabber.local();\n â”Š3â”Š5â”Šlet port = 8000;\n â”Š4â”Š6â”Š\n â”Š5â”Š7â”Š// Initialize a new server\n```\n```diff\n@@ -29,7 +31,7 @@\n â”Š29â”Š31â”Š  console.log();\n â”Š30â”Š32â”Š  console.log(\"---------- -------- ------ ---- --\");\n â”Š31â”Š33â”Š  console.log(\"----- ---- --- -- -\");\n-â”Š32â”Š  â”Š  console.log(`Server running at ${port}`);\n+â”Š  â”Š34â”Š  console.log(`Server running at ${localIp}:${port}`);\n â”Š33â”Š35â”Š  console.log(\"----- ---- --- -- -\");\n â”Š34â”Š36â”Š  console.log(\"---------- -------- ------ ---- --\");\n â”Š35â”Š37â”Š  console.log();\n```\n\n[}]: #\n\nBy now you should have the following message printed to the console once you start the server:\n\n```\n---------- -------- ------ ---- --\n----- ---- --- -- -\nServer running at 95.221.122.30:8000\n----- ---- --- -- -\n---------- -------- ------ ---- --\n```\n\n> Instead of `95.221.122.30` you should have the IP address which is right for you.\n\nNow comes the most important part - handling HTTP requests! Because what does a server worth if it doesn't know how to handle anything? When using `HapiJS`, we can separate extensions to our server in different modules, and eventually register them as plug-ins. So the first plug-in is gonna be the routes batch for the endpoints - it will take care of serving file requests as is, and basically turning local directories into public ones. This is useful because our game is going to be dependent on many assets like textures, images, fonts, and so on... But before I go into the implementation part we first need to install a couple of libraries which will help us with the task. The first one is going to be `async`, which will take care of managing the control flow of asynchronous code:\n\n    $ npm install async --save\n\nAnd the second library is going to be `inert`, which is a `HapiJS` plug-in which will give us the ability to serve files from local directories:\n\n    $ npm install inert --save\n\nNow that we're set, let's implement the `endpoints` routes batch:\n\n[{]: <helper> (diffStep 1.8)\n\n#### [Step 1.8: Add endpoints routes](https://github.com/DAB0mB/radial-snake/commit/9c22408)\n\n##### Added routes&#x2F;endpoints.js\n```diff\n@@ -0,0 +1,80 @@\n+â”Š  â”Š 1â”Šconst Pack = require(\"../package.json\");\n+â”Š  â”Š 2â”Š\n+â”Š  â”Š 3â”Šregister.attributes = {\n+â”Š  â”Š 4â”Š  name: \"endpoints\",\n+â”Š  â”Š 5â”Š  version: Pack.version\n+â”Š  â”Š 6â”Š};\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Šfunction register(server, options, next) {\n+â”Š  â”Š 9â”Š  // Scripts endpoint\n+â”Š  â”Š10â”Š  server.route({\n+â”Š  â”Š11â”Š    method: \"GET\",\n+â”Š  â”Š12â”Š    path: \"/scripts/{path*}\",\n+â”Š  â”Š13â”Š    handler: {\n+â”Š  â”Š14â”Š      directory: {\n+â”Š  â”Š15â”Š        path: \"./resources/scripts/\"\n+â”Š  â”Š16â”Š      }\n+â”Š  â”Š17â”Š    }\n+â”Š  â”Š18â”Š  });\n+â”Š  â”Š19â”Š\n+â”Š  â”Š20â”Š  // Style-sheets endpoint\n+â”Š  â”Š21â”Š  server.route({\n+â”Š  â”Š22â”Š    method: \"GET\",\n+â”Š  â”Š23â”Š    path: \"/styles/{path*}\",\n+â”Š  â”Š24â”Š    handler: {\n+â”Š  â”Š25â”Š      directory: {\n+â”Š  â”Š26â”Š        path: \"./resources/styles/\"\n+â”Š  â”Š27â”Š      }\n+â”Š  â”Š28â”Š    }\n+â”Š  â”Š29â”Š  });\n+â”Š  â”Š30â”Š\n+â”Š  â”Š31â”Š  // Libraries endpoint\n+â”Š  â”Š32â”Š  server.route({\n+â”Š  â”Š33â”Š    method: \"GET\",\n+â”Š  â”Š34â”Š    path: \"/libs/{path*}\",\n+â”Š  â”Š35â”Š    handler: {\n+â”Š  â”Š36â”Š      directory: {\n+â”Š  â”Š37â”Š        path: \"./resources/libs/\"\n+â”Š  â”Š38â”Š      }\n+â”Š  â”Š39â”Š    }\n+â”Š  â”Š40â”Š  });\n+â”Š  â”Š41â”Š\n+â”Š  â”Š42â”Š  // Images endpoint\n+â”Š  â”Š43â”Š  server.route({\n+â”Š  â”Š44â”Š    method: \"GET\",\n+â”Š  â”Š45â”Š    path: \"/images/{path*}\",\n+â”Š  â”Š46â”Š    handler: {\n+â”Š  â”Š47â”Š      directory: {\n+â”Š  â”Š48â”Š        path: \"./resources/images/\"\n+â”Š  â”Š49â”Š      }\n+â”Š  â”Š50â”Š    }\n+â”Š  â”Š51â”Š  });\n+â”Š  â”Š52â”Š\n+â”Š  â”Š53â”Š  // Textures endpoint\n+â”Š  â”Š54â”Š  server.route({\n+â”Š  â”Š55â”Š    method: \"GET\",\n+â”Š  â”Š56â”Š    path: \"/textures/{path*}\",\n+â”Š  â”Š57â”Š    handler: {\n+â”Š  â”Š58â”Š      directory: {\n+â”Š  â”Š59â”Š        path: \"./resources/assets/textures/\"\n+â”Š  â”Š60â”Š      }\n+â”Š  â”Š61â”Š    }\n+â”Š  â”Š62â”Š  });\n+â”Š  â”Š63â”Š\n+â”Š  â”Š64â”Š  // Fonts endpoint\n+â”Š  â”Š65â”Š  server.route({\n+â”Š  â”Š66â”Š    method: \"GET\",\n+â”Š  â”Š67â”Š    path: \"/fonts/{path*}\",\n+â”Š  â”Š68â”Š    handler: {\n+â”Š  â”Š69â”Š      directory: {\n+â”Š  â”Š70â”Š        path: \"./resources/assets/fonts/\"\n+â”Š  â”Š71â”Š      }\n+â”Š  â”Š72â”Š    }\n+â”Š  â”Š73â”Š  });\n+â”Š  â”Š74â”Š\n+â”Š  â”Š75â”Š  next();\n+â”Š  â”Š76â”Š}\n+â”Š  â”Š77â”Š\n+â”Š  â”Š78â”Šmodule.exports = {\n+â”Š  â”Š79â”Š  register\n+â”Š  â”Š80â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nThis module actually represents a classic structure of a `HapiJS` plug-in. It should export a `name` for debugging proposes, a `version`, and a `register` function, which will take care of registering extensions to our server; in this case, these are the endpoints routes. To make this plug-in (Or any other plug-in) work, we need to register it. The registration is an asynchronous operation, thus we gonna handle it using `async`:\n\n[{]: <helper> (diffStep 1.9)\n\n#### [Step 1.9: Register ednpoints routes](https://github.com/DAB0mB/radial-snake/commit/bba460f)\n\n##### Changed server.js\n```diff\n@@ -1,11 +1,23 @@\n+â”Š  â”Š 1â”Šconst Async = require(\"async\");\n â”Š 1â”Š 2â”Šconst Hapi = require(\"hapi\");\n+â”Š  â”Š 3â”Šconst Inert = require(\"inert\");\n+â”Š  â”Š 4â”Šconst Endpoints = require(\"./routes/endpoints\");\n â”Š 2â”Š 5â”Šconst IpGrabber = require(\"./helpers/ip_grabber\");\n â”Š 3â”Š 6â”Š\n â”Š 4â”Š 7â”Šlet localIp = IpGrabber.local();\n â”Š 5â”Š 8â”Šlet port = 8000;\n â”Š 6â”Š 9â”Š\n â”Š 7â”Š10â”Š// Initialize a new server\n-â”Š 8â”Š  â”Šlet server = new Hapi.Server();\n+â”Š  â”Š11â”Šlet server = new Hapi.Server({\n+â”Š  â”Š12â”Š  connections: {\n+â”Š  â”Š13â”Š    routes: {\n+â”Š  â”Š14â”Š      files: {\n+â”Š  â”Š15â”Š        // Served files will be relative to current directory\n+â”Š  â”Š16â”Š        relativeTo: __dirname\n+â”Š  â”Š17â”Š      }\n+â”Š  â”Š18â”Š    }\n+â”Š  â”Š19â”Š  }\n+â”Š  â”Š20â”Š});\n â”Š 9â”Š21â”Š\n â”Š10â”Š22â”Šserver.connection({ port: process.env.PORT || port });\n â”Š11â”Š23â”Š\n```\n```diff\n@@ -24,8 +36,14 @@\n â”Š24â”Š36â”Š  rep.continue();\n â”Š25â”Š37â”Š});\n â”Š26â”Š38â”Š\n+â”Š  â”Š39â”Š// Register all routes and plug-ins\n+â”Š  â”Š40â”ŠAsync.series([\n+â”Š  â”Š41â”Š  next => server.register(Inert, next),\n+â”Š  â”Š42â”Š  next => server.register(Endpoints, next),\n+â”Š  â”Š43â”Š  // Once registrations are finished, start the server\n+â”Š  â”Š44â”Š  next => server.start(next)\n â”Š27â”Š45â”Š// Print message once started\n-â”Š28â”Š  â”Šserver.start((err) => {\n+â”Š  â”Š46â”Š], (err) => {\n â”Š29â”Š47â”Š  if (err) throw err;\n â”Š30â”Š48â”Š\n â”Š31â”Š49â”Š  console.log();\n```\n\n[}]: #\n\nOnce all the plug-ins have been registered, we gonna start our server as we previously did. Note that we also registered the `inert` plug-in, because as I said earlier, that's what gives us the ability to handle files requests.\n\nLastly, I want to create the `pages` routes batch, which will be responsible for serving pages in our application as listed above:\n\n- The `/` route will serve us the `game.html` file.\n- The `/test` route will serve us the `spec_runner.html` file.\n\nBy the name of each route and file you can probably what each one should do. The thing is, we don't want everyone to be able to access the `spec_runner.html` file, or the `game.html` file if in the middle of development. For this, we're going to create a new helper which will be responsible for handling permissions. So first we gonna install an npm package called `boom` which has the ability to format `permission denied` HTTP errors:\n\n    $ npm install boom --save\n\nAnd now we gonna implement the module itself:\n\n[{]: <helper> (diffStep 1.11)\n\n#### [Step 1.11: Add permitter helper](https://github.com/DAB0mB/radial-snake/commit/d26a5d7)\n\n##### Added helpers&#x2F;permitter.js\n```diff\n@@ -0,0 +1,29 @@\n+â”Š  â”Š 1â”Šconst Boom = require(\"boom\");\n+â”Š  â”Š 2â”Šconst Hapi = require(\"hapi\");\n+â”Š  â”Š 3â”Šconst IpGrabber = require(\"./ip_grabber\");\n+â”Š  â”Š 4â”Š\n+â”Š  â”Š 5â”Š// These addresses will be permitted by default\n+â”Š  â”Š 6â”Šconst defaultPermissions = [\n+â”Š  â”Š 7â”Š  IpGrabber.local(), \"127.0.0.1\", \"localhost\"\n+â”Š  â”Š 8â”Š];\n+â”Š  â”Š 9â”Š\n+â”Š  â”Š10â”Š// Manage file permissions\n+â”Š  â”Š11â”Šfunction file(path, permissions, req, rep) {\n+â”Š  â”Š12â”Š  // Apply default permissions\n+â”Š  â”Š13â”Š  permissions = permissions.concat(defaultPermissions);\n+â”Š  â”Š14â”Š  // Request address\n+â”Š  â”Š15â”Š  let remoteAddress = req.info.remoteAddress;\n+â”Š  â”Š16â”Š\n+â”Š  â”Š17â”Š  // If not permitted, reply error\n+â”Š  â”Š18â”Š  if (permissions.indexOf(remoteAddress) == -1) {\n+â”Š  â”Š19â”Š    let err = new Boom.forbidden(\"Missing permissions\");\n+â”Š  â”Š20â”Š    return rep(err);\n+â”Š  â”Š21â”Š  }\n+â”Š  â”Š22â”Š\n+â”Š  â”Š23â”Š  // If permitted, reply file\n+â”Š  â”Š24â”Š  rep.file(path);\n+â”Š  â”Š25â”Š}\n+â”Š  â”Š26â”Š\n+â”Š  â”Š27â”Šmodule.exports = {\n+â”Š  â”Š28â”Š  file\n+â”Š  â”Š29â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nThe default permitted IP address would be the current computer's IP address. Extra IP permissions can be provided with the invocation of the `file` method. If the requesting IP is not listed in the permissions list, an error is gonna be replied instead of the requested file. Now that we have our \"permitter\" ready, let's implement the `pages` routes batch, only we're gonna pass the requests through the black-list, for the reason mentioned above:\n\n[{]: <helper> (diffStep 1.12)\n\n#### [Step 1.12: Add pages routes](https://github.com/DAB0mB/radial-snake/commit/11860e9)\n\n##### Added routes&#x2F;pages.js\n```diff\n@@ -0,0 +1,35 @@\n+â”Š  â”Š 1â”Šconst Hapi = require(\"hapi\");\n+â”Š  â”Š 2â”Šconst Pack = require(\"../package.json\");\n+â”Š  â”Š 3â”Šconst Permitter = require(\"../helpers/permitter\");\n+â”Š  â”Š 4â”Š\n+â”Š  â”Š 5â”Šregister.attributes = {\n+â”Š  â”Š 6â”Š  name: \"pages\",\n+â”Š  â”Š 7â”Š  version: Pack.version\n+â”Š  â”Š 8â”Š};\n+â”Š  â”Š 9â”Š\n+â”Š  â”Š10â”Šfunction register(server, options, next) {\n+â”Š  â”Š11â”Š  server.route({ method: \"GET\", path: \"/\", handler: getGame });\n+â”Š  â”Š12â”Š  server.route({ method: \"GET\", path: \"/test\", handler: getSpecRunner });\n+â”Š  â”Š13â”Š\n+â”Š  â”Š14â”Š  next();\n+â”Š  â”Š15â”Š}\n+â”Š  â”Š16â”Š\n+â”Š  â”Š17â”Š// Serve game page\n+â”Š  â”Š18â”Šfunction getGame(req, rep) {\n+â”Š  â”Š19â”Š  let path = \"./views/game.html\";\n+â”Š  â”Š20â”Š  let permissions = [];\n+â”Š  â”Š21â”Š\n+â”Š  â”Š22â”Š  Permitter.file(path, permissions, req, rep);\n+â”Š  â”Š23â”Š}\n+â”Š  â”Š24â”Š\n+â”Š  â”Š25â”Š// Serve test page\n+â”Š  â”Š26â”Šfunction getSpecRunner(req, rep) {\n+â”Š  â”Š27â”Š  let path = \"./views/spec_runner.html\";\n+â”Š  â”Š28â”Š  let permissions = [];\n+â”Š  â”Š29â”Š\n+â”Š  â”Š30â”Š  Permitter.file(path, permissions, req, rep);\n+â”Š  â”Š31â”Š}\n+â”Š  â”Š32â”Š\n+â”Š  â”Š33â”Šmodule.exports = {\n+â”Š  â”Š34â”Š  register\n+â”Š  â”Š35â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nNow the only thing left to do would be registering the plug-in we've just created:\n\n[{]: <helper> (diffStep 1.13)\n\n#### [Step 1.13: Register pages routes](https://github.com/DAB0mB/radial-snake/commit/ed50bef)\n\n##### Changed server.js\n```diff\n@@ -2,6 +2,7 @@\n â”Š2â”Š2â”Šconst Hapi = require(\"hapi\");\n â”Š3â”Š3â”Šconst Inert = require(\"inert\");\n â”Š4â”Š4â”Šconst Endpoints = require(\"./routes/endpoints\");\n+â”Š â”Š5â”Šconst Pages = require(\"./routes/pages\");\n â”Š5â”Š6â”Šconst IpGrabber = require(\"./helpers/ip_grabber\");\n â”Š6â”Š7â”Š\n â”Š7â”Š8â”Šlet localIp = IpGrabber.local();\n```\n```diff\n@@ -40,6 +41,7 @@\n â”Š40â”Š41â”ŠAsync.series([\n â”Š41â”Š42â”Š  next => server.register(Inert, next),\n â”Š42â”Š43â”Š  next => server.register(Endpoints, next),\n+â”Š  â”Š44â”Š  next => server.register(Pages, next),\n â”Š43â”Š45â”Š  // Once registrations are finished, start the server\n â”Š44â”Š46â”Š  next => server.start(next)\n â”Š45â”Š47â”Š// Print message once started\n```\n\n[}]: #\n\nAnd that's it for the current step! In the next steps we will start storing files and assets in our public directories and implement all the necessary scripts, so our server is not running in vain."
          },
          {
            "manualTitle": "Step 2: Creating a game engine basis",
            "stepRevision": "a3e901039dc5db535111da14305175182f9f346c",
            "manualView": "Like any other JavaScript-based application, we should have an entry view written in HTML. However, in our application, the only visible element is going to be an [HTMLCanvas](https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API). The canvas is exactly what it sounds like - a blank white surface which we can draw things on top of it. As we go further with this tutorial, we will learn more about the canvas and dive into its API and how to use it. Now that you got the general idea, let's create the HTML file:\n\n[{]: <helper> (diffStep 2.1)\n\n#### [Step 2.1: Create basic game view](https://github.com/DAB0mB/radial-snake/commit/254f06f)\n\n##### Added views&#x2F;game.html\n```diff\n@@ -0,0 +1,10 @@\n+â”Š  â”Š 1â”Š<!DOCTYPE html>\n+â”Š  â”Š 2â”Š<html>\n+â”Š  â”Š 3â”Š  <head>\n+â”Š  â”Š 4â”Š    <title>radial snake</title>\n+â”Š  â”Š 5â”Š  </head>\n+â”Š  â”Š 6â”Š\n+â”Š  â”Š 7â”Š  <body>\n+â”Š  â”Š 8â”Š    <canvas id=\"gameCanvas\" tabindex=\"0\"></canvas>\n+â”Š  â”Š 9â”Š  </body>\n+â”Š  â”Š10â”Š</html>ðŸš«â†µ\n```\n\n[}]: #\n\nIn the previous step we've already set the route for this file, so if you'd like to run the game, simply start the server by typing `npm run serve`, and navigate to the address presented on the screen (Should be `localhost:8000` by default).\n\n> From now on I'm going to assume the server is running in the background, so I won't repeat the instruction above\n\nJust to make sure that the canvas is visible and not blended into the background, we will draw a black border around using a simple style-sheet:\n\n[{]: <helper> (diffStep 2.2)\n\n#### [Step 2.2: Create basic game stylesheet](https://github.com/DAB0mB/radial-snake/commit/44fe5aa)\n\n##### Added resources&#x2F;styles&#x2F;game.css\n```diff\n@@ -0,0 +1,6 @@\n+â”Š â”Š1â”Š#gameCanvas {\n+â”Š â”Š2â”Š  display: block;\n+â”Š â”Š3â”Š  margin: auto;\n+â”Š â”Š4â”Š  border-style: solid;\n+â”Š â”Š5â”Š  border-width: 1px;\n+â”Š â”Š6â”Š}ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -2,6 +2,9 @@\n â”Š 2â”Š 2â”Š<html>\n â”Š 3â”Š 3â”Š  <head>\n â”Š 4â”Š 4â”Š    <title>radial snake</title>\n+â”Š  â”Š 5â”Š\n+â”Š  â”Š 6â”Š    <!-- Styles -->\n+â”Š  â”Š 7â”Š    <link rel=\"stylesheet\" type=\"text/css\" href=\"/styles/game.css\">\n â”Š 5â”Š 8â”Š  </head>\n â”Š 6â”Š 9â”Š\n â”Š 7â”Š10â”Š  <body>\n```\n\n[}]: #\n\n> Note that every asset we create should be declared in the HTML file in order for it to take effect\n\nTo build this project we're also gonna use two very famous utility libraries called [JQuery](http://jquery.com/) and [Underscore](http://underscorejs.org/) which will make our lives a bit easier. Third-party libraries should be located in a directory called `libs`, according to the routes-map we created in the previous step. To set these libraries up, type the following commands in series:\n\n    resources$ mkdir libs\n    resources$ cd libs\n    resources/libs$ wget raw.githubusercontent.com/dab0mb/radial-snake/master/resources/libs/underscore.js\n    resources/libs$ wget raw.githubusercontent.com/dab0mb/radial-snake/master/resources/libs/jquery-2.1.1.js\n\nAnd load them in the game's HTML file's header:\n\n[{]: <helper> (diffStep 2.3 files=\"views/game.html\")\n\n#### [Step 2.3: Add jquery and underscore libs](https://github.com/DAB0mB/radial-snake/commit/085ca6b)\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -3,6 +3,10 @@\n â”Š 3â”Š 3â”Š  <head>\n â”Š 4â”Š 4â”Š    <title>radial snake</title>\n â”Š 5â”Š 5â”Š\n+â”Š  â”Š 6â”Š    <!-- Libs -->\n+â”Š  â”Š 7â”Š    <script type=\"text/javascript\" src=\"/libs/jquery-2.1.1.js\"></script>\n+â”Š  â”Š 8â”Š    <script type=\"text/javascript\" src=\"/libs/underscore.js\"></script>\n+â”Š  â”Š 9â”Š\n â”Š 6â”Š10â”Š    <!-- Styles -->\n â”Š 7â”Š11â”Š    <link rel=\"stylesheet\" type=\"text/css\" href=\"/styles/game.css\">\n â”Š 8â”Š12â”Š  </head>\n```\n\n[}]: #\n\nNow, we're finally going to build the game engine. At first, it's gonna be very basic simple, but further in this tutorial we're going to extend it and add some pretty neat features. When creating an application, of any kind, you don't want to garbage the global scope, so it can stay clean without any conflicts. Therefore, we're going to create an initial namespace for our game engine called `Engine`, which is going to contain all our game engine's classes and entities:\n\n[{]: <helper> (diffStep 2.4)\n\n#### [Step 2.4: Add engine namespace](https://github.com/DAB0mB/radial-snake/commit/3d52525)\n\n##### Added resources&#x2F;scripts&#x2F;namespaces.js\n```diff\n@@ -0,0 +1 @@\n+â”Š â”Š1â”ŠEngine = {};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -7,6 +7,9 @@\n â”Š 7â”Š 7â”Š    <script type=\"text/javascript\" src=\"/libs/jquery-2.1.1.js\"></script>\n â”Š 8â”Š 8â”Š    <script type=\"text/javascript\" src=\"/libs/underscore.js\"></script>\n â”Š 9â”Š 9â”Š\n+â”Š  â”Š10â”Š    <!-- Scripts -->\n+â”Š  â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n+â”Š  â”Š12â”Š\n â”Š10â”Š13â”Š    <!-- Styles -->\n â”Š11â”Š14â”Š    <link rel=\"stylesheet\" type=\"text/css\" href=\"/styles/game.css\">\n â”Š12â”Š15â”Š  </head>\n```\n\n[}]: #\n\nThe first thing we're going to define in the namespace we've just created would be the game loop. The game loop is the central code of your game, split into different parts. Generally, these are: update and draw.\n\nThe main purpose of the update phase is to prepare all objects to be drawn, so this is where all the geometry code, coordinate updates, score changes, animation refreshments and other similar operations belong. This is also where the input will be captured and processed.\n\nWhen everything is properly updated and ready, we enter the draw phase where all this information is put on the screen. This function should contain all the code to manage and draw the levels, shapes, score board and so on.\n\n![game-loop](https://cloud.githubusercontent.com/assets/7648874/21332964/4b80ef4e-c633-11e6-946a-0c5870d2f9c9.png)\n\n> You can find plenty of details and information about what \"game loop\" means simply by typing in on Google.\n\nA game loop can wear many forms, but the concept is gonna be the same, plus-minus. This is how our game loop is going to loop like:\n\n[{]: <helper> (diffStep 2.5)\n\n#### [Step 2.5: Create a game basis](https://github.com/DAB0mB/radial-snake/commit/1b7fcf9)\n\n##### Added resources&#x2F;scripts&#x2F;engine&#x2F;game.js\n```diff\n@@ -0,0 +1,99 @@\n+â”Š  â”Š 1â”ŠEngine.Game = class Game {\n+â”Š  â”Š 2â”Š  // The frequency of which each frame will be drawn in milliseconds\n+â”Š  â”Š 3â”Š  get fps() {\n+â”Š  â”Š 4â”Š    return 1000 / 60;\n+â”Š  â”Š 5â”Š  }\n+â”Š  â”Š 6â”Š\n+â”Š  â”Š 7â”Š  // Game's run speed.\n+â”Š  â”Š 8â”Š  // A lower value will make it run slower and a higher value will make it run faster\n+â”Š  â”Š 9â”Š  get speed() {\n+â”Š  â”Š10â”Š    return 1;\n+â”Š  â”Š11â”Š  }\n+â”Š  â”Š12â”Š\n+â”Š  â”Š13â”Š  constructor(canvas) {\n+â”Š  â”Š14â”Š    this.canvas = canvas;\n+â”Š  â”Š15â”Š    this.lastUpdate = this.creation = new Date().getTime();\n+â”Š  â”Š16â”Š\n+â”Š  â”Š17â”Š    // Canvas dimensions must be set programmatically otherwise you might encounter some\n+â”Š  â”Š18â”Š    // unexpected behaviors\n+â”Š  â”Š19â”Š    canvas.width = 1280;\n+â”Š  â”Š20â”Š    canvas.height = 720;\n+â”Š  â”Š21â”Š    // Canvas will be focused once game page is loaded so all events will automatically\n+â”Š  â”Š22â”Š    // be captured by it\n+â”Š  â”Š23â”Š    canvas.focus();\n+â”Š  â”Š24â”Š\n+â”Š  â”Š25â”Š    // We want to focus on the canvas once we press on it\n+â”Š  â”Š26â”Š    canvas.addEventListener(\"mousedown\", canvas.focus.bind(canvas), false);\n+â”Š  â”Š27â”Š\n+â”Š  â”Š28â”Š    this.assets = {};\n+â”Š  â”Š29â”Š    this.events = new Map();\n+â”Š  â”Š30â”Š    this.context = canvas.getContext(\"2d\");\n+â”Š  â”Š31â”Š    this.bufferedCanvas = document.createElement(\"canvas\");\n+â”Š  â”Š32â”Š    this.bufferedContext = this.bufferedCanvas.getContext(\"2d\");\n+â”Š  â”Š33â”Š    this.bufferedCanvas.width = canvas.width;\n+â”Š  â”Š34â”Š    this.bufferedCanvas.height = canvas.height;\n+â”Š  â”Š35â”Š  }\n+â”Š  â”Š36â”Š\n+â”Š  â”Š37â”Š  draw() {\n+â”Š  â”Š38â”Š    // Draw a black screen by default\n+â”Š  â”Š39â”Š    this.context.restore();\n+â”Š  â”Š40â”Š    this.context.fillStyle = \"black\";\n+â”Š  â”Š41â”Š    this.context.save();\n+â”Š  â”Š42â”Š    this.context.beginPath();\n+â”Š  â”Š43â”Š    this.context.rect(0, 0, this.canvas.width, this.canvas.height);\n+â”Š  â”Š44â”Š    this.context.fill();\n+â”Š  â”Š45â”Š  }\n+â”Š  â”Š46â”Š\n+â”Š  â”Š47â”Š  update() {\n+â”Š  â”Š48â”Š    // Calculate the time elapsed\n+â”Š  â”Š49â”Š    let lastUpdate = this.lastUpdate;\n+â”Š  â”Š50â”Š    let currUpdate = this.lastUpdate = new Date().getTime();\n+â”Š  â”Š51â”Š    let span = currUpdate - lastUpdate;\n+â”Š  â”Š52â”Š    this.updateScreen(span / this.speed);\n+â”Š  â”Š53â”Š  }\n+â”Š  â”Š54â”Š\n+â”Š  â”Š55â”Š  // The main loop of the game\n+â”Š  â”Š56â”Š  loop() {\n+â”Š  â”Š57â”Š    // If paused, don't run loop. The canvas will remain as is\n+â”Š  â”Š58â”Š    if (!this.playing) return;\n+â”Š  â”Š59â”Š\n+â”Š  â”Š60â”Š    setTimeout(() => {\n+â”Š  â”Š61â”Š      this.draw();\n+â”Š  â”Š62â”Š      this.update();\n+â”Š  â”Š63â”Š      this.loop();\n+â”Š  â”Š64â”Š    }, this.fps);\n+â”Š  â”Š65â”Š  }\n+â”Š  â”Š66â”Š\n+â”Š  â”Š67â”Š  play() {\n+â”Š  â”Š68â”Š    this.playing = true;\n+â”Š  â”Š69â”Š    this.loop();\n+â”Š  â”Š70â”Š  }\n+â”Š  â”Š71â”Š\n+â”Š  â”Š72â”Š  pause() {\n+â”Š  â”Š73â”Š    this.playing = false;\n+â”Š  â”Š74â”Š  }\n+â”Š  â”Š75â”Š\n+â”Š  â”Š76â”Š  // Defines global assets\n+â”Š  â”Š77â”Š  extendAssets(assets) {\n+â”Š  â”Š78â”Š    _.extend(this.assets, assets);\n+â”Š  â”Š79â”Š  }\n+â”Š  â”Š80â”Š\n+â”Š  â”Š81â”Š  // Disposes global assets\n+â”Š  â”Š82â”Š  clearAssets() {\n+â”Š  â”Š83â”Š    this.assets = {};\n+â”Š  â”Š84â”Š  }\n+â”Š  â”Š85â”Š\n+â”Š  â”Š86â”Š  // Adds event listener for game canvas\n+â”Š  â”Š87â”Š  addEventListener(type, listener, target) {\n+â”Š  â”Š88â”Š    let boundListener = listener.bind(target);\n+â”Š  â”Š89â”Š    this.events.set(listener, boundListener);\n+â”Š  â”Š90â”Š    this.canvas.addEventListener(type, boundListener, false);\n+â”Š  â”Š91â”Š  }\n+â”Š  â”Š92â”Š\n+â”Š  â”Š93â”Š  // Removes event listener from game canvas\n+â”Š  â”Š94â”Š  removeEventListener(type, listener) {\n+â”Š  â”Š95â”Š    let boundListener = this.events.get(listener);\n+â”Š  â”Š96â”Š    this.events.delete(listener);\n+â”Š  â”Š97â”Š    this.canvas.removeEventListener(type, boundListener, false);\n+â”Š  â”Š98â”Š  }\n+â”Š  â”Š99â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -9,6 +9,7 @@\n â”Š 9â”Š 9â”Š\n â”Š10â”Š10â”Š    <!-- Scripts -->\n â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n+â”Š  â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š12â”Š13â”Š\n â”Š13â”Š14â”Š    <!-- Styles -->\n â”Š14â”Š15â”Š    <link rel=\"stylesheet\" type=\"text/css\" href=\"/styles/game.css\">\n```\n\n[}]: #\n\nThe only thing it's doing right now is drawing a black background, but we're soon going to learn how to take advantage of this game-loop to draw stuff of our own. I'd like to point out that there is no need to implement a [double-buffer](https://en.wikipedia.org/wiki/Multiple_buffering) (A method similar to React's [virtual DOM](https://www.npmjs.com/package/react-dom)) when it comes to `HTMLCanvas` elements, since `HTML5` already does that for us. To start running the game, we first need to wait for the DOM content to initialize, and once it's ready we gonna create a new game instance and call the `play` method:\n\n[{]: <helper> (diffStep 2.6)\n\n#### [Step 2.6: Create game entry point](https://github.com/DAB0mB/radial-snake/commit/30e75df)\n\n##### Added resources&#x2F;scripts&#x2F;main.js\n```diff\n@@ -0,0 +1,4 @@\n+â”Š â”Š1â”Šdocument.addEventListener(\"DOMContentLoaded\", function(event) {\n+â”Š â”Š2â”Š  let game = new Engine.Game(document.getElementById(\"gameCanvas\"), false);\n+â”Š â”Š3â”Š  game.play();\n+â”Š â”Š4â”Š});ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -10,6 +10,7 @@\n â”Š10â”Š10â”Š    <!-- Scripts -->\n â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n â”Š12â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n+â”Š  â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n â”Š13â”Š14â”Š\n â”Š14â”Š15â”Š    <!-- Styles -->\n â”Š15â”Š16â”Š    <link rel=\"stylesheet\" type=\"text/css\" href=\"/styles/game.css\">\n```\n\n[}]: #\n\nThis will take control over the canvas and will draw a new picture every 17ms, which is 60fps (Frames per second). As for now you're only going to see a black canvas, but I promise the final result is not going to disappoint you.\n\nThe next thing we're gonna do would be adding a 'key state' manager, which will store a flag for each key pressed on the keyboard. Once we press the key, the flag's value would be `true`, and once we release it, its value would turn into `false`. This way we have an easy way to track all the key presses without registering a specific event listener for each key press we wanna track:\n\n[{]: <helper> (diffStep 2.7)\n\n#### [Step 2.7: Add key states manager](https://github.com/DAB0mB/radial-snake/commit/831b058)\n\n##### Added resources&#x2F;scripts&#x2F;engine&#x2F;key_states.js\n```diff\n@@ -0,0 +1,20 @@\n+â”Š  â”Š 1â”ŠEngine.KeyStates = class KeyStates {\n+â”Š  â”Š 2â”Š  constructor() {\n+â”Š  â”Š 3â”Š    // We will have 255 states, each one represents an ascii code matching its index\n+â”Š  â”Š 4â”Š    this.states = new Array(255);\n+â”Š  â”Š 5â”Š  }\n+â”Š  â”Š 6â”Š\n+â”Š  â”Š 7â”Š  get(k) {\n+â”Š  â”Š 8â”Š    return this.states[k];\n+â”Š  â”Š 9â”Š  }\n+â”Š  â”Š10â”Š\n+â”Š  â”Š11â”Š  // This should be called once we press a key\n+â”Š  â”Š12â”Š  add(k) {\n+â”Š  â”Š13â”Š    this.states[k] = true;\n+â”Š  â”Š14â”Š  }\n+â”Š  â”Š15â”Š\n+â”Š  â”Š16â”Š  // This should be called once we release a key\n+â”Š  â”Š17â”Š  remove(k) {\n+â”Š  â”Š18â”Š    this.states[k] = false;\n+â”Š  â”Š19â”Š  }\n+â”Š  â”Š20â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -9,6 +9,7 @@\n â”Š 9â”Š 9â”Š\n â”Š10â”Š10â”Š    <!-- Scripts -->\n â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n+â”Š  â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/key_states.js\"></script>\n â”Š12â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n```\n\n[}]: #\n\nNow that we have the key state manager, we will initialize a new instance as part of our game's essentials, and we will create a global event listener for key presses; Each time a key is pressed, the key state manager will update itself:\n\n[{]: <helper> (diffStep 2.8)\n\n#### [Step 2.8: Register key presses](https://github.com/DAB0mB/radial-snake/commit/9f55501)\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;game.js\n```diff\n@@ -14,7 +14,7 @@\n â”Š14â”Š14â”Š    this.canvas = canvas;\n â”Š15â”Š15â”Š    this.lastUpdate = this.creation = new Date().getTime();\n â”Š16â”Š16â”Š\n-â”Š17â”Š  â”Š    // Canvas dimensions must be set programmatically otherwise you might encounter some\n+â”Š  â”Š17â”Š    // Canvas dimensions must be set programmatically, otherwise you might encounter some\n â”Š18â”Š18â”Š    // unexpected behaviors\n â”Š19â”Š19â”Š    canvas.width = 1280;\n â”Š20â”Š20â”Š    canvas.height = 720;\n```\n```diff\n@@ -24,9 +24,13 @@\n â”Š24â”Š24â”Š\n â”Š25â”Š25â”Š    // We want to focus on the canvas once we press on it\n â”Š26â”Š26â”Š    canvas.addEventListener(\"mousedown\", canvas.focus.bind(canvas), false);\n+â”Š  â”Š27â”Š    // Key flags will be registered by the \"KeyStates\" instance\n+â”Š  â”Š28â”Š    canvas.addEventListener(\"keydown\", onKeyDown.bind(this), false);\n+â”Š  â”Š29â”Š    canvas.addEventListener(\"keyup\", onKeyUp.bind(this), false);\n â”Š27â”Š30â”Š\n â”Š28â”Š31â”Š    this.assets = {};\n â”Š29â”Š32â”Š    this.events = new Map();\n+â”Š  â”Š33â”Š    this.keyStates = new Engine.KeyStates();\n â”Š30â”Š34â”Š    this.context = canvas.getContext(\"2d\");\n â”Š31â”Š35â”Š    this.bufferedCanvas = document.createElement(\"canvas\");\n â”Š32â”Š36â”Š    this.bufferedContext = this.bufferedCanvas.getContext(\"2d\");\n```\n```diff\n@@ -96,4 +100,19 @@\n â”Š 96â”Š100â”Š    this.events.delete(listener);\n â”Š 97â”Š101â”Š    this.canvas.removeEventListener(type, boundListener, false);\n â”Š 98â”Š102â”Š  }\n-â”Š 99â”Š   â”Š};ðŸš«â†µ\n+â”Š   â”Š103â”Š};\n+â”Š   â”Š104â”Š\n+â”Š   â”Š105â”Šfunction onKeyDown(e) {\n+â”Š   â”Š106â”Š  // Once we're focused on the canvas, we want nothing else to happen\n+â”Š   â”Š107â”Š  // besides events the game is listening to. For example, when we press\n+â”Š   â”Š108â”Š  // the arrow keys, this will prevent the screen from scrolling\n+â”Š   â”Š109â”Š  e.preventDefault();\n+â”Š   â”Š110â”Š  // Register key press\n+â”Š   â”Š111â”Š  this.keyStates.add(e.keyCode);\n+â”Š   â”Š112â”Š}\n+â”Š   â”Š113â”Š\n+â”Š   â”Š114â”Šfunction onKeyUp(e) {\n+â”Š   â”Š115â”Š  e.preventDefault();\n+â”Š   â”Š116â”Š  // Register key release\n+â”Š   â”Š117â”Š  this.keyStates.remove(e.keyCode);\n+â”Š   â”Š118â”Š}\n```\n\n[}]: #\n\nA 2D game's view might get complex as we go through with its development and add more logic and entities into it. Having only one `draw` method and only one `update` method is not enough, and if you think of it, it might easily get buffed up into ridiculous dimensions, which is not the way to go. I'd like to introduce you into a new methodology which involves `screens` and `layers`:\n\n- **screen** - Will literally be used whenever we want to show a new screen in our game e.g. 'splash' screen and 'main menu' screen. A screen consists of multiple layers, and will be used as their communicator; All the relevant assets and logic will be initialized inside it.\n- **layer** - similar to Photoshop's layer system, any time we want to add something to the view we add new layers on top or beneath of each other.\n\n![screen-layer](https://cloud.githubusercontent.com/assets/7648874/21487708/9b366efe-cbb7-11e6-8669-3212e440871a.png)\n\nAs I said earlier, the purpose of the screens and the layers is just to split the task of updating and drawing and updating, so we can have logical segments; So the `layer` class should mainly consist of a `draw` and an `update` method:\n\n[{]: <helper> (diffStep 2.9)\n\n#### [Step 2.9: Add screen layer](https://github.com/DAB0mB/radial-snake/commit/736ab08)\n\n##### Added resources&#x2F;scripts&#x2F;engine&#x2F;layer.js\n```diff\n@@ -0,0 +1,43 @@\n+â”Š  â”Š 1â”ŠEngine.Layer = class Layer {\n+â”Š  â”Š 2â”Š  // The dimensions of the layer are correlated to dimensions of the canvas\n+â”Š  â”Š 3â”Š  get width() {\n+â”Š  â”Š 4â”Š    return this.canvas.width;\n+â”Š  â”Š 5â”Š  }\n+â”Š  â”Š 6â”Š\n+â”Š  â”Š 7â”Š  get height() {\n+â”Š  â”Š 8â”Š    return this.canvas.height;\n+â”Š  â”Š 9â”Š  }\n+â”Š  â”Š10â”Š\n+â”Š  â”Š11â”Š  // A hash of \"eventName\" : \"handlerName\" which should be overrided by user\n+â”Š  â”Š12â”Š  get events() {\n+â”Š  â”Š13â”Š    return {};\n+â”Š  â”Š14â”Š  }\n+â”Š  â”Š15â”Š\n+â”Š  â”Š16â”Š  constructor(screen) {\n+â”Š  â”Š17â”Š    this.age = 0;\n+â”Š  â”Š18â”Š    this.creation = new Date().getTime();\n+â”Š  â”Š19â”Š    this.screen = screen;\n+â”Š  â”Š20â”Š    this.game = screen.game;\n+â”Š  â”Š21â”Š    this.assets = screen.assets;\n+â”Š  â”Š22â”Š    this.keyStates = screen.keyStates;\n+â”Š  â”Š23â”Š    this.canvas = screen.game.canvas;\n+â”Š  â”Š24â”Š  }\n+â”Š  â”Š25â”Š\n+â”Š  â”Š26â”Š  update(span) {\n+â”Š  â”Š27â”Š  }\n+â”Š  â”Š28â”Š\n+â”Š  â”Š29â”Š  draw(context) {\n+â”Š  â”Š30â”Š  }\n+â”Š  â”Š31â”Š\n+â”Š  â”Š32â”Š  initEventListeners() {\n+â”Š  â”Š33â”Š    _.each(this.events, (listener, event) => {\n+â”Š  â”Š34â”Š      this.game.addEventListener(event, this[listener], this);\n+â”Š  â”Š35â”Š    });\n+â”Š  â”Š36â”Š  }\n+â”Š  â”Š37â”Š\n+â”Š  â”Š38â”Š  disposeEventListeners() {\n+â”Š  â”Š39â”Š    _.each(this.events, (listener, event) => {\n+â”Š  â”Š40â”Š      this.game.removeEventListener(event, this[listener]);\n+â”Š  â”Š41â”Š    });\n+â”Š  â”Š42â”Š  }\n+â”Š  â”Š43â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -10,6 +10,7 @@\n â”Š10â”Š10â”Š    <!-- Scripts -->\n â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n â”Š12â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/key_states.js\"></script>\n+â”Š  â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/layer.js\"></script>\n â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š14â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n```\n\n[}]: #\n\nSame thing for the screen, it only has a `draw` and `update` methods, only it has a stack of layers, which can either be added or removed:\n\n[{]: <helper> (diffStep 2.1)\n\n#### [Step 2.1: Create basic game view](https://github.com/DAB0mB/radial-snake/commit/254f06f)\n\n##### Added views&#x2F;game.html\n```diff\n@@ -0,0 +1,10 @@\n+â”Š  â”Š 1â”Š<!DOCTYPE html>\n+â”Š  â”Š 2â”Š<html>\n+â”Š  â”Š 3â”Š  <head>\n+â”Š  â”Š 4â”Š    <title>radial snake</title>\n+â”Š  â”Š 5â”Š  </head>\n+â”Š  â”Š 6â”Š\n+â”Š  â”Š 7â”Š  <body>\n+â”Š  â”Š 8â”Š    <canvas id=\"gameCanvas\" tabindex=\"0\"></canvas>\n+â”Š  â”Š 9â”Š  </body>\n+â”Š  â”Š10â”Š</html>ðŸš«â†µ\n```\n\n[}]: #\n\nNow that we have the `screen` class available for us, let's apply it to the main game loop:\n\n[{]: <helper> (diffStep 2.11)\n\n#### [Step 2.11: Draw and update screen in game loop](https://github.com/DAB0mB/radial-snake/commit/9f34754)\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;game.js\n```diff\n@@ -30,6 +30,7 @@\n â”Š30â”Š30â”Š\n â”Š31â”Š31â”Š    this.assets = {};\n â”Š32â”Š32â”Š    this.events = new Map();\n+â”Š  â”Š33â”Š    this.screen = new Engine.Screen(this);\n â”Š33â”Š34â”Š    this.keyStates = new Engine.KeyStates();\n â”Š34â”Š35â”Š    this.context = canvas.getContext(\"2d\");\n â”Š35â”Š36â”Š    this.bufferedCanvas = document.createElement(\"canvas\");\n```\n```diff\n@@ -46,6 +47,13 @@\n â”Š46â”Š47â”Š    this.context.beginPath();\n â”Š47â”Š48â”Š    this.context.rect(0, 0, this.canvas.width, this.canvas.height);\n â”Š48â”Š49â”Š    this.context.fill();\n+â”Š  â”Š50â”Š    this.drawScreen(this.context);\n+â”Š  â”Š51â”Š  }\n+â”Š  â”Š52â”Š\n+â”Š  â”Š53â”Š  drawScreen(context) {\n+â”Š  â”Š54â”Š    // If screen's assets are not yet loaded, don't draw it\n+â”Š  â”Š55â”Š    if (this.screen.loading) return;\n+â”Š  â”Š56â”Š    if (this.screen.draw) this.screen.draw(context);\n â”Š49â”Š57â”Š  }\n â”Š50â”Š58â”Š\n â”Š51â”Š59â”Š  update() {\n```\n```diff\n@@ -56,6 +64,13 @@\n â”Š56â”Š64â”Š    this.updateScreen(span / this.speed);\n â”Š57â”Š65â”Š  }\n â”Š58â”Š66â”Š\n+â”Š  â”Š67â”Š  updateScreen(span) {\n+â”Š  â”Š68â”Š    this.screen.age += span;\n+â”Š  â”Š69â”Š    // If screen's assets are not yet loaded, don't update it\n+â”Š  â”Š70â”Š    if (this.screen.loading) return;\n+â”Š  â”Š71â”Š    if (this.screen.update) this.screen.update(span);\n+â”Š  â”Š72â”Š  }\n+â”Š  â”Š73â”Š\n â”Š59â”Š74â”Š  // The main loop of the game\n â”Š60â”Š75â”Š  loop() {\n â”Š61â”Š76â”Š    // If paused, don't run loop. The canvas will remain as is\n```\n\n[}]: #\n\nThis step looks kind of useless for now, unless we will have the ability to change screens as we please. Any time a screen is changed, it should be loaded with its necessary assets e.g textures, sounds, fonts, etc. The assets loading is an asynchronous operation whose logic might get a bit messy if not managed properly. To make it easier, we're going to define an assets loader, which will help us load assets asynchronously:\n\n[{]: <helper> (diffStep 2.12)\n\n#### [Step 2.12: Add assets loader](https://github.com/DAB0mB/radial-snake/commit/d8895f8)\n\n##### Added resources&#x2F;scripts&#x2F;engine&#x2F;assets_loader.js\n```diff\n@@ -0,0 +1,13 @@\n+â”Š  â”Š 1â”ŠEngine.AssetsLoader = class AssetsLoader {\n+â”Š  â”Š 2â”Š  constructor(next) {\n+â”Š  â”Š 3â”Š    this.next = next;\n+â”Š  â”Š 4â”Š  }\n+â”Š  â”Š 5â”Š\n+â”Š  â”Š 6â”Š  // Load texture\n+â”Š  â”Š 7â”Š  texture(path) {\n+â”Š  â”Š 8â”Š    let image = new Image();\n+â”Š  â”Š 9â”Š    image.onload = this.next();\n+â”Š  â”Š10â”Š    image.src = `${path}.png`;\n+â”Š  â”Š11â”Š    return image;\n+â”Š  â”Š12â”Š  }\n+â”Š  â”Š13â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -12,6 +12,7 @@\n â”Š12â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/key_states.js\"></script>\n â”Š13â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/layer.js\"></script>\n â”Š14â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/screen.js\"></script>\n+â”Š  â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/assets_loader.js\"></script>\n â”Š15â”Š16â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š16â”Š17â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n```\n\n[}]: #\n\n> As for now the `assets loader` only has the ability to load textures, but we will extend it as we go further in this tutorial, no need to overdo it.\n\nNow that we have the `assets loader` we can add the ability to change a screen. Whenever we change a screen, the old screen's assets should be unloaded, and the new screen's assets should be loaded using the `assets loader`:\n\n[{]: <helper> (diffStep 2.13)\n\n#### [Step 2.13: Add the ability to change and load screen](https://github.com/DAB0mB/radial-snake/commit/90aab03)\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;game.js\n```diff\n@@ -92,6 +92,61 @@\n â”Š 92â”Š 92â”Š    this.playing = false;\n â”Š 93â”Š 93â”Š  }\n â”Š 94â”Š 94â”Š\n+â”Š   â”Š 95â”Š  changeScreen(Screen, ...screenArgs) {\n+â”Š   â”Š 96â”Š    // If there is a screen defined, dispose it first\n+â”Š   â”Š 97â”Š    if (this.screen) {\n+â”Š   â”Š 98â”Š      this.unloadScreen();\n+â”Š   â”Š 99â”Š      this.screen.disposeEventListeners();\n+â”Š   â”Š100â”Š    }\n+â”Š   â”Š101â”Š\n+â”Š   â”Š102â”Š    this.screen = new Screen(this, ...screenArgs);\n+â”Š   â”Š103â”Š\n+â”Š   â”Š104â”Š    // Load screen assets\n+â”Š   â”Š105â”Š    this.loadScreen(() => {\n+â”Š   â”Š106â”Š      // Once assets are loaded, initialize event listeners\n+â”Š   â”Š107â”Š      this.screen.initEventListeners();\n+â”Š   â”Š108â”Š      // The \"initialize\" method is exactly the same as the constructor, only it runs\n+â”Š   â”Š109â”Š      // once assets are available and event listeners are registered\n+â”Š   â”Š110â”Š      this.screen.initialize(this, ...screenArgs);\n+â”Š   â”Š111â”Š    });\n+â”Š   â”Š112â”Š  }\n+â”Š   â”Š113â”Š\n+â”Š   â”Š114â”Š  // Loads screen assets and invokes callback once loading is finished\n+â”Š   â”Š115â”Š  loadScreen(callback = _.noop) {\n+â”Š   â”Š116â”Š    if (!this.screen.load) return callback();\n+â”Š   â”Š117â”Š\n+â”Š   â”Š118â”Š    this.screen.loading = true;\n+â”Š   â”Š119â”Š    // The number of assets to load\n+â”Š   â”Š120â”Š    let loadsize = 0;\n+â”Š   â”Š121â”Š    let onload;\n+â”Š   â”Š122â”Š\n+â”Š   â”Š123â”Š    // This object can load assets\n+â”Š   â”Š124â”Š    let assetsLoader = new Engine.AssetsLoader(() => {\n+â”Š   â”Š125â”Š      loadsize++;\n+â”Š   â”Š126â”Š      return () => onload();\n+â”Š   â”Š127â”Š    });\n+â”Š   â”Š128â”Š\n+â”Š   â”Š129â”Š    // The \"load\" method returns the assets loaded by the screen\n+â”Š   â”Š130â”Š    let screenAssets = this.screen.load(assetsLoader);\n+â”Š   â”Š131â”Š\n+â”Š   â”Š132â”Š    // We use the \"after\" method because we want the following callback to be invoked\n+â”Š   â”Š133â”Š    // only once all assets are loaded\n+â”Š   â”Š134â”Š    onload = _.after(loadsize, () => {\n+â”Š   â”Š135â”Š      delete this.screen.loading;\n+â”Š   â”Š136â”Š      callback();\n+â”Š   â”Š137â”Š    });\n+â”Š   â”Š138â”Š\n+â”Š   â”Š139â”Š    // The returned assets will be available on screen's assets object\n+â”Š   â”Š140â”Š    _.extend(this.screen.assets, screenAssets);\n+â”Š   â”Š141â”Š  }\n+â”Š   â”Š142â”Š\n+â”Š   â”Š143â”Š  // Disposes screen assets\n+â”Š   â”Š144â”Š  unloadScreen() {\n+â”Š   â”Š145â”Š    if (!this.screen.unload) return;\n+â”Š   â”Š146â”Š    let assetsNames = this.screen.unload();\n+â”Š   â”Š147â”Š    _.omit(this.assets, assetsNames);\n+â”Š   â”Š148â”Š  }\n+â”Š   â”Š149â”Š\n â”Š 95â”Š150â”Š  // Defines global assets\n â”Š 96â”Š151â”Š  extendAssets(assets) {\n â”Š 97â”Š152â”Š    _.extend(this.assets, assets);\n```\n\n[}]: #\n\nLet's add a test screen just so we can get the hang of it. The test screen will only print a message to the canvas:\n\n[{]: <helper> (diffStep 2.14)\n\n#### [Step 2.14: Add test screen](https://github.com/DAB0mB/radial-snake/commit/85776e8)\n\n##### Added resources&#x2F;scripts&#x2F;test_screen.js\n```diff\n@@ -0,0 +1,10 @@\n+â”Š  â”Š 1â”Šclass TestScreen extends Engine.Screen {\n+â”Š  â”Š 2â”Š  draw(context) {\n+â”Š  â”Š 3â”Š    // A 20px sized \"Georgia\" font (Available natively)\n+â”Š  â”Š 4â”Š    context.font = \"20px Georgia\";\n+â”Š  â”Š 5â”Š    // The text should be colored white\n+â”Š  â”Š 6â”Š    context.fillStyle = \"white\";\n+â”Š  â”Š 7â”Š    // Draw the following message 50px from the left and 50px from the top\n+â”Š  â”Š 8â”Š    context.fillText(\"This is a Test Screen\", 50, 50);\n+â”Š  â”Š 9â”Š  }\n+â”Š  â”Š10â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -14,6 +14,7 @@\n â”Š14â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/screen.js\"></script>\n â”Š15â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/assets_loader.js\"></script>\n â”Š16â”Š16â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n+â”Š  â”Š17â”Š    <script type=\"text/javascript\" src=\"/scripts/test_screen.js\"></script>\n â”Š17â”Š18â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n â”Š18â”Š19â”Š\n â”Š19â”Š20â”Š    <!-- Styles -->\n```\n\n[}]: #\n\nNow we will use the test screen by changing to it as we create an instance of the game:\n\n[{]: <helper> (diffStep 2.15)\n\n#### [Step 2.15: Set test screen as the initial screen](https://github.com/DAB0mB/radial-snake/commit/203d084)\n\n##### Changed resources&#x2F;scripts&#x2F;main.js\n```diff\n@@ -1,4 +1,5 @@\n â”Š1â”Š1â”Šdocument.addEventListener(\"DOMContentLoaded\", function(event) {\n â”Š2â”Š2â”Š  let game = new Engine.Game(document.getElementById(\"gameCanvas\"), false);\n+â”Š â”Š3â”Š  game.changeScreen(TestScreen);\n â”Š3â”Š4â”Š  game.play();\n â”Š4â”Š5â”Š});ðŸš«â†µ\n```\n\n[}]: #\n\nOnce you will load the application you should see a black canvas with a white text saying:\n\n    This is a test screen\n\nIt means our screen system works and you may proceed to the next step, where we're gonna create our first screen :-)"
          },
          {
            "manualTitle": "Step 3: Creating a splash screen using a keyframe animation engine",
            "stepRevision": "4b2431bbc910f8945e5fd86aa964fec3ede8761c",
            "manualView": "![snake-demo-splash-small](https://cloud.githubusercontent.com/assets/7648874/21074086/a19fa9ce-bed6-11e6-9060-2ce94c215712.gif)\n\nIn this step we will be creating the `splash` screen - the initial screen that should be shown once we launch the game. Our splash is consisted of a random logo animation as presented in the `gif` file above. The \"splash\" effect can be achieved using 2 concepts:\n\n- A sprite class - Which will present the logo texture in different dimensions, angles and rotations.\n- A key-frame animation - Which will draw an animation automatically along the time axis using key-frames - each is a sprite representation of the texture in a specific time point.\n\nSo first thing first, we will start by implementing the sprite class:\n\n[{]: <helper> (diffStep 3.1)\n\n#### [Step 3.1: Create &#x27;Sprite&#x27; class](https://github.com/DAB0mB/radial-snake/commit/a32a711)\n\n##### Added resources&#x2F;scripts&#x2F;engine&#x2F;sprite.js\n```diff\n@@ -0,0 +1,58 @@\n+â”Š  â”Š 1â”ŠEngine.Sprite = class Sprite {\n+â”Š  â”Š 2â”Š  // An easy representation of a sprite on a canvas, with a set of convenient tools\n+â”Š  â”Š 3â”Š  // for alignment and coloring\n+â”Š  â”Š 4â”Š  constructor(texture) {\n+â”Š  â”Š 5â”Š    this.texture = texture;\n+â”Š  â”Š 6â”Š    this.x = 0;\n+â”Š  â”Š 7â”Š    this.y = 0;\n+â”Š  â”Š 8â”Š    this.width = texture.width;\n+â”Š  â”Š 9â”Š    this.height = texture.height;\n+â”Š  â”Š10â”Š    this.pivot = { x: 0, y: 0 };\n+â”Š  â”Š11â”Š    this.opacity = 1;\n+â”Š  â”Š12â”Š  }\n+â”Š  â”Š13â”Š\n+â”Š  â”Š14â”Š  draw(context, offsetX = 0, offsetY = 0) {\n+â”Š  â”Š15â”Š    context.save();\n+â”Š  â”Š16â”Š    context.globalAlpha = this.opacity;\n+â”Š  â”Š17â”Š\n+â”Š  â”Š18â”Š    // The following switch-case can also be seen as a list of all possible\n+â”Š  â”Š19â”Š    // alignment modes\n+â”Š  â”Š20â”Š    switch (this.align) {\n+â”Š  â”Š21â”Š      case \"top-left\": case \"left-top\": this.pivot = { x: 0, y: 0 }; break;\n+â”Š  â”Š22â”Š      case \"top-right\": case \"right-top\": this.pivot = { x: this.width, y: 0 }; break;\n+â”Š  â”Š23â”Š      case \"bottom-left\": case \"left-bottom\": this.pivot = { x: 0, y: this.height }; break;\n+â”Š  â”Š24â”Š      case \"bottom-right\": case \"right-bottom\": this.pivot = { x: this.width, y: this.height }; break;\n+â”Š  â”Š25â”Š      case \"middle\": case \"center\": this.pivot = { x: this.width / 2, y: this.height / 2 }; break;\n+â”Š  â”Š26â”Š      case \"left\": this.pivot = { x: 0, y: this.height / 2 }; break;\n+â”Š  â”Š27â”Š      case \"top\": this.pivot = { x: this.width / 2, y: 0 }; break;\n+â”Š  â”Š28â”Š      case \"right\": this.pivot = { x: this.width, y: this.height / 2 }; break;\n+â”Š  â”Š29â”Š      case \"bottom\": this.pivot = { x: this.width / 2, y: this.height }; break;\n+â”Š  â”Š30â”Š    }\n+â”Š  â”Š31â”Š\n+â”Š  â”Š32â”Š    context.drawImage(\n+â”Š  â”Š33â”Š      this.texture,\n+â”Š  â”Š34â”Š      (this.x - this.pivot.x) + offsetX,\n+â”Š  â”Š35â”Š      (this.y - this.pivot.y) + offsetY,\n+â”Š  â”Š36â”Š      this.width,\n+â”Š  â”Š37â”Š      this.height\n+â”Š  â”Š38â”Š    );\n+â”Š  â”Š39â”Š\n+â”Š  â”Š40â”Š    context.restore();\n+â”Š  â”Š41â”Š  }\n+â”Š  â”Š42â”Š\n+â”Š  â”Š43â”Š  // A sprite property (key) can also be resized based on a given percentage.\n+â”Š  â”Š44â”Š  // The 'relative' argument represents the whole of which the percents are gonna be\n+â”Š  â”Š45â”Š  // calculated from, and the 'adapters' argument is an array of property names which\n+â”Š  â”Š46â”Š  // gonna adapt themselves based on the changes made in the given key.\n+â”Š  â”Š47â”Š  // Usually 'width' goes along with ['height'] adapters, if we\n+â”Š  â”Š48â”Š  // want to keep their original ratio\n+â”Š  â”Š49â”Š  setPercentage(key, relative, percents, ...adapters) {\n+â”Š  â”Š50â”Š    let oldVal = this[key];\n+â”Š  â”Š51â”Š    let newVal = this[key] = (percents * relative) / 100;\n+â”Š  â”Š52â”Š    let ratio = newVal / oldVal;\n+â”Š  â”Š53â”Š\n+â”Š  â”Š54â”Š    adapters.forEach(adapter => {\n+â”Š  â”Š55â”Š      this[adapter] *= ratio;\n+â”Š  â”Š56â”Š    });\n+â”Š  â”Š57â”Š  }\n+â”Š  â”Š58â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -9,6 +9,7 @@\n â”Š 9â”Š 9â”Š\n â”Š10â”Š10â”Š    <!-- Scripts -->\n â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n+â”Š  â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/sprite.js\"></script>\n â”Š12â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/key_states.js\"></script>\n â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/layer.js\"></script>\n â”Š14â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/screen.js\"></script>\n```\n\n[}]: #\n\nAnd we will download the logo which will be presented in the splash screen using the sprite class:\n\n    resources$ mkdir assets\n    resources$ cd assets\n    resources/assets$ mkdir textures\n    resources/assets$ cd textures\n    resources/assets/textures$ wget raw.githubusercontent.com/dab0mb/radial-snake/master/resources/assets/textures/splash.png\n\n> Any logo can that you desired can be used instead! But to ease things up I already provided you with one as a sample\n\nNow we will create the initial splash screen, where we only gonna show a sprite of the logo in the middle of the screen, with no animation applied yet. We will first define a dedicated `Screens` module under the `Game` namespace:\n\n[{]: <helper> (diffStep 3.3)\n\n#### [Step 3.3: Create a &#x27;Game&#x27; namespace with a &#x27;Screens&#x27; module](https://github.com/DAB0mB/radial-snake/commit/ae85a96)\n\n##### Changed resources&#x2F;scripts&#x2F;namespaces.js\n```diff\n@@ -1 +1,5 @@\n+â”Š â”Š1â”ŠGame = {\n+â”Š â”Š2â”Š  Screens: {}\n+â”Š â”Š3â”Š};\n+â”Š â”Š4â”Š\n â”Š1â”Š5â”ŠEngine = {};ðŸš«â†µ\n```\n\n[}]: #\n\nAnd we can go ahead and implement the screen itself:\n\n[{]: <helper> (diffStep 3.4)\n\n#### [Step 3.4: Create initial splash screen](https://github.com/DAB0mB/radial-snake/commit/4dd73f3)\n\n##### Added resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;splash&#x2F;index.js\n```diff\n@@ -0,0 +1,19 @@\n+â”Š  â”Š 1â”ŠGame.Screens.Splash = class Splash extends Engine.Screen {\n+â”Š  â”Š 2â”Š  initialize() {\n+â”Š  â”Š 3â”Š    // Create splash sprite and set its properties\n+â”Š  â”Š 4â”Š    this.splashSprite = new Engine.Sprite(this.assets.splashTexture);\n+â”Š  â”Š 5â”Š    this.splashSprite.align = \"center\";\n+â”Š  â”Š 6â”Š    this.splashSprite.x = this.width / 2;\n+â”Š  â”Š 7â”Š  }\n+â”Š  â”Š 8â”Š\n+â”Š  â”Š 9â”Š  load(assetsLoader) {\n+â”Š  â”Š10â”Š    // These are local assets which will be disposed along with the screen\n+â”Š  â”Š11â”Š    return {\n+â”Š  â”Š12â”Š      splashTexture: assetsLoader.texture(\"/textures/splash\")\n+â”Š  â”Š13â”Š    };\n+â”Š  â”Š14â”Š  }\n+â”Š  â”Š15â”Š\n+â”Š  â”Š16â”Š  draw(context) {\n+â”Š  â”Š17â”Š    this.splashSprite.draw(context);\n+â”Š  â”Š18â”Š  }\n+â”Š  â”Š19â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -16,6 +16,7 @@\n â”Š16â”Š16â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/assets_loader.js\"></script>\n â”Š17â”Š17â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š18â”Š18â”Š    <script type=\"text/javascript\" src=\"/scripts/test_screen.js\"></script>\n+â”Š  â”Š19â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/splash/index.js\"></script>\n â”Š19â”Š20â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n â”Š20â”Š21â”Š\n â”Š21â”Š22â”Š    <!-- Styles -->\n```\n\n[}]: #\n\nNow we can set the splash screen as the initial screen in the entry script file:\n\n[{]: <helper> (diffStep 3.5)\n\n#### [Step 3.5: Set splash screen as the initial game screen](https://github.com/DAB0mB/radial-snake/commit/3576ff8)\n\n##### Changed resources&#x2F;scripts&#x2F;main.js\n```diff\n@@ -1,5 +1,5 @@\n â”Š1â”Š1â”Šdocument.addEventListener(\"DOMContentLoaded\", function(event) {\n â”Š2â”Š2â”Š  let game = new Engine.Game(document.getElementById(\"gameCanvas\"), false);\n-â”Š3â”Š â”Š  game.changeScreen(TestScreen);\n+â”Š â”Š3â”Š  game.changeScreen(Game.Screens.Splash);\n â”Š4â”Š4â”Š  game.play();\n â”Š5â”Š5â”Š});ðŸš«â†µ\n```\n\n[}]: #\n\nAnd we will get rid of the unnecessary test screen since we make no use of it any longer:\n\n    $ rm resources/scripts/test_screen.js\n\nWe will now proceed into the next stage where we will be implementing the key-frame animation engine as said at the beginning of the step. We first need to define an `Animations` module, since we can have multiple types of animation strategy like [sprite-atlas animation](http://www.joshmorony.com/how-to-create-animations-in-phaser-with-a-texture-atlas/), not necessarily a key-frame animation:\n\n[{]: <helper> (diffStep 3.7)\n\n#### [Step 3.7: Add &#x27;Animations&#x27; module to &#x27;Engine&#x27; namespace](https://github.com/DAB0mB/radial-snake/commit/ffe800c)\n\n##### Changed resources&#x2F;scripts&#x2F;namespaces.js\n```diff\n@@ -2,4 +2,6 @@\n â”Š2â”Š2â”Š  Screens: {}\n â”Š3â”Š3â”Š};\n â”Š4â”Š4â”Š\n-â”Š5â”Š â”ŠEngine = {};ðŸš«â†µ\n+â”Š â”Š5â”ŠEngine = {\n+â”Š â”Š6â”Š  Animations: {}\n+â”Š â”Š7â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nInside the newly created module we will create the key-frame animation engine. The key-frame animation consists of the following methods:\n\n- update - Updates the animation.\n- draw - Draws the current animation frame on the provided canvas context.\n- play - Enables update operations.\n- pause - Disables update operations.\n\n[{]: <helper> (diffStep 3.8)\n\n#### [Step 3.8: Create a key-frame animation engine](https://github.com/DAB0mB/radial-snake/commit/64c58fb)\n\n##### Added resources&#x2F;scripts&#x2F;engine&#x2F;animations&#x2F;keyframe.js\n```diff\n@@ -0,0 +1,142 @@\n+â”Š   â”Š  1â”ŠEngine.Animations.Keyframe = class Keyframe {\n+â”Š   â”Š  2â”Š  constructor(sprite, keyframes) {\n+â”Š   â”Š  3â”Š    this.sprite = sprite;\n+â”Š   â”Š  4â”Š    // The key-frames array contains objects with the properties of the\n+â”Š   â”Š  5â”Š    // sprite at the current time-point, e.g. width of 100 and height of 200\n+â”Š   â”Š  6â”Š    this.keyframes = keyframes;\n+â”Š   â”Š  7â”Š    this.age = 0;\n+â”Š   â”Š  8â”Š    this.frame = 0;\n+â”Š   â”Š  9â”Š    // This flag determines what's gonna happen to the animation once\n+â”Š   â”Š 10â”Š    // it's finished playing\n+â”Š   â”Š 11â”Š    this.repetitionMode = \"none\";\n+â”Š   â”Š 12â”Š    this.lastKeyframe = _.last(keyframes);\n+â”Š   â”Š 13â”Š    this.lastFrame = this.lastKeyframe.frame;\n+â”Š   â”Š 14â”Š\n+â”Š   â”Š 15â”Š    // These are the properties which we can animate\n+â”Š   â”Š 16â”Š    this.animables = [\n+â”Š   â”Š 17â”Š      \"x\", \"y\", \"width\", \"height\", \"opacity\"\n+â”Š   â”Š 18â”Š    ];\n+â”Š   â”Š 19â”Š\n+â”Š   â”Š 20â”Š    // Set a map whose keys represent animatable properties and values represent an array\n+â”Š   â”Š 21â”Š    // with relevant key-frames to its belonging property\n+â”Š   â”Š 22â”Š    this.trimmedKeyframes = this.animables.reduce((trimmedKeyframes, key) => {\n+â”Š   â”Š 23â”Š      trimmedKeyframes[key] = keyframes.filter(keyframe => keyframe[key] != null);\n+â”Š   â”Š 24â”Š      return trimmedKeyframes;\n+â”Š   â”Š 25â”Š    }, {});\n+â”Š   â”Š 26â”Š\n+â”Š   â”Š 27â”Š    // Set initial properties on sprite based on initial key-frame\n+â”Š   â”Š 28â”Š    _.each(keyframes[0], (value, key) => {\n+â”Š   â”Š 29â”Š      if (this.animables.includes(key)) sprite[key] = value;\n+â”Š   â”Š 30â”Š    });\n+â”Š   â”Š 31â”Š  }\n+â”Š   â”Š 32â”Š\n+â”Š   â”Š 33â”Š  draw(context, offsetX, offsetY) {\n+â”Š   â”Š 34â”Š    this.sprite.draw(context, offsetX, offsetY);\n+â”Š   â”Š 35â”Š  }\n+â”Š   â”Š 36â”Š\n+â”Š   â”Š 37â”Š  update(span) {\n+â”Š   â”Š 38â”Š    if (!this.playing) return;\n+â”Š   â”Š 39â”Š\n+â”Š   â”Š 40â”Š    this.age += span;\n+â”Š   â”Š 41â”Š\n+â”Š   â”Š 42â”Š    switch (this.repetitionMode) {\n+â”Š   â”Š 43â”Š      // After one cycle animation would stop\n+â”Š   â”Š 44â”Š      case \"none\":\n+â”Š   â”Š 45â”Š        this.frame += span;\n+â”Š   â”Š 46â”Š\n+â”Š   â”Š 47â”Š        if (this.frame > this.lastFrame) {\n+â”Š   â”Š 48â”Š          this.frame = this.lastFrame;\n+â”Š   â”Š 49â”Š          this.playing = false;\n+â”Š   â”Š 50â”Š        }\n+â”Š   â”Š 51â”Š\n+â”Š   â”Š 52â”Š        break;\n+â”Š   â”Š 53â”Š\n+â”Š   â”Š 54â”Š      // Once finished, replay from the beginning\n+â”Š   â”Š 55â”Š      case \"cyclic\":\n+â”Š   â”Š 56â”Š        this.frame = this.age % this.lastFrame;\n+â”Š   â”Š 57â”Š        break;\n+â”Š   â”Š 58â”Š\n+â”Š   â”Š 59â”Š      // Once finished, play backwards, and so on\n+â”Š   â”Š 60â”Š      case \"full\":\n+â”Š   â”Š 61â”Š        this.frame = this.age % this.lastFrame;\n+â”Š   â”Š 62â”Š        let animationComplete = (this.age / this.lastFrame) % 2 >= 1;\n+â”Š   â”Š 63â”Š        if (animationComplete) this.frame = this.lastFrame - this.frame;\n+â”Š   â”Š 64â”Š        break;\n+â”Š   â”Š 65â”Š    }\n+â”Š   â”Š 66â”Š\n+â”Š   â”Š 67â”Š    // Update sprite properties based on given key-frame's easing mode\n+â”Š   â”Š 68â”Š    this.animables.forEach(key => {\n+â”Š   â”Š 69â”Š      let motion = this.getKeyframeMotion(key);\n+â”Š   â”Š 70â”Š\n+â”Š   â”Š 71â”Š      if (motion)\n+â”Š   â”Š 72â”Š        this.sprite[key] = this.calculateRelativeValue(motion, key);\n+â”Š   â”Š 73â”Š    });\n+â”Š   â”Š 74â”Š  }\n+â”Š   â”Š 75â”Š\n+â”Š   â”Š 76â”Š  play() {\n+â”Š   â”Š 77â”Š    this.playing = true;\n+â”Š   â”Š 78â”Š  }\n+â”Š   â”Š 79â”Š\n+â”Š   â”Š 80â”Š  pause() {\n+â”Š   â”Š 81â”Š    this.playing = false;\n+â”Š   â”Š 82â”Š  }\n+â”Š   â”Š 83â”Š\n+â”Š   â”Š 84â”Š  // Gets motion for current refresh\n+â”Š   â”Š 85â”Š  getKeyframeMotion(key) {\n+â”Š   â”Š 86â”Š    let keyframes = this.trimmedKeyframes[key];\n+â”Š   â”Š 87â”Š\n+â”Š   â”Š 88â”Š    // If no key-frames defined, motion is idle\n+â”Š   â”Š 89â”Š    if (keyframes == null) return;\n+â”Š   â”Š 90â”Š    // If there is only one key frame, motion is idle\n+â”Š   â”Š 91â”Š    if (keyframes.length < 2) return;\n+â”Š   â”Š 92â”Š    // If last frame reached, motion is idle\n+â”Š   â”Š 93â”Š    if (this.frame > _.last(keyframes).frame) return;\n+â”Š   â”Š 94â”Š\n+â”Š   â”Š 95â”Š    let start = this.findStartKeyframe(keyframes);\n+â”Š   â”Š 96â”Š    let end = this.findEndKeyframe(keyframes);\n+â”Š   â”Š 97â”Š    let ratio = this.getKeyframesRatio(start, end);\n+â”Š   â”Š 98â”Š\n+â”Š   â”Š 99â”Š    return { start, end, ratio };\n+â”Š   â”Š100â”Š  }\n+â”Š   â”Š101â”Š\n+â”Š   â”Š102â”Š  // Gets the movement ratio\n+â”Š   â”Š103â”Š  getKeyframesRatio(start, end) {\n+â”Š   â”Š104â”Š    return (this.frame - start.frame) / (end.frame - start.frame);\n+â”Š   â”Š105â”Š  }\n+â”Š   â”Š106â”Š\n+â”Š   â”Š107â”Š  // Get property end value based on current frame\n+â”Š   â”Š108â”Š  findEndKeyframe(keyframes) {\n+â”Š   â”Š109â”Š    return _.find(keyframes, keyframe =>\n+â”Š   â”Š110â”Š      keyframe.frame >= (this.frame || 1)\n+â”Š   â”Š111â”Š    );\n+â”Š   â”Š112â”Š  }\n+â”Š   â”Š113â”Š\n+â”Š   â”Š114â”Š  // Get property start value based on current frame\n+â”Š   â”Š115â”Š  findStartKeyframe(keyframes) {\n+â”Š   â”Š116â”Š    let resultIndex;\n+â”Š   â”Š117â”Š\n+â”Š   â”Š118â”Š    keyframes.some((keyframe, currIndex) => {\n+â”Š   â”Š119â”Š      if (keyframe.frame >= (this.frame || 1)) {\n+â”Š   â”Š120â”Š        resultIndex = currIndex;\n+â”Š   â”Š121â”Š        return true;\n+â”Š   â”Š122â”Š      }\n+â”Š   â”Š123â”Š    });\n+â”Š   â”Š124â”Š\n+â”Š   â”Š125â”Š    return keyframes[resultIndex - 1];\n+â”Š   â”Š126â”Š  }\n+â”Š   â”Š127â”Š\n+â”Š   â”Š128â”Š  // Get a recalculated property value relative to provided easing mode\n+â”Š   â”Š129â”Š  calculateRelativeValue(motion, key) {\n+â”Š   â”Š130â”Š    let a = motion.start[key];\n+â”Š   â”Š131â”Š    let b = motion.end[key];\n+â”Š   â”Š132â”Š    let r = motion.ratio;\n+â”Š   â”Š133â”Š    let easing = r > 0 ? motion.start.easing : motion.end.easing;\n+â”Š   â”Š134â”Š\n+â”Š   â”Š135â”Š    switch (easing) {\n+â”Š   â”Š136â”Š      case \"in\": r = Math.sin((r * Math.PI) / 2); break;\n+â”Š   â”Š137â”Š      case \"out\": r = Math.cos((r * Math.PI) / 2); break;\n+â”Š   â”Š138â”Š    }\n+â”Š   â”Š139â”Š\n+â”Š   â”Š140â”Š    return ((b - a) * r) + a;\n+â”Š   â”Š141â”Š  }\n+â”Š   â”Š142â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -10,6 +10,7 @@\n â”Š10â”Š10â”Š    <!-- Scripts -->\n â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n â”Š12â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/sprite.js\"></script>\n+â”Š  â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/animations/keyframe.js\"></script>\n â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/key_states.js\"></script>\n â”Š14â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/layer.js\"></script>\n â”Š15â”Š16â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/screen.js\"></script>\n```\n\n[}]: #\n\nWhen initializing a new instance of the key-frame animation, we should invoke it with the desired sprite, and an array of key-frames. What exactly does a single key-frame represents? The properties of the sprite at that specific time point. In addition, a key-frame can be set with an [easing mode](https://css-tricks.com/ease-out-in-ease-in-out/) of `in` and `out`. By default, the animation would be linear.\n\nBased on the `repitationMode` property, three things can happen to the animation once finished:\n\n- `none` - The animation will play once, and then stop. It will appear as a static sprite.\n- `cyclic` - The animation will repeat itself from the beginning, over and over again until stopped manually.\n- `full` - The animation will play itself backwards, and then forwards, backwards, forwards, and so on.\n\nThanks to the key-frame animation engine, we can apply it to the splash screen to show a beautifully animated logo rather than showing a static image. So in addition to the logo sprite, we will initialize a key-frame animation as well:\n\n[{]: <helper> (diffStep 3.9)\n\n#### [Step 3.9: Apply key-frame animation to splash screen](https://github.com/DAB0mB/radial-snake/commit/8ca47e5)\n\n##### Changed resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;splash&#x2F;index.js\n```diff\n@@ -1,9 +1,34 @@\n â”Š 1â”Š 1â”ŠGame.Screens.Splash = class Splash extends Engine.Screen {\n â”Š 2â”Š 2â”Š  initialize() {\n â”Š 3â”Š 3â”Š    // Create splash sprite and set its properties\n-â”Š 4â”Š  â”Š    this.splashSprite = new Engine.Sprite(this.assets.splashTexture);\n-â”Š 5â”Š  â”Š    this.splashSprite.align = \"center\";\n-â”Š 6â”Š  â”Š    this.splashSprite.x = this.width / 2;\n+â”Š  â”Š 4â”Š    let splashSprite = new Engine.Sprite(this.assets.splashTexture);\n+â”Š  â”Š 5â”Š    splashSprite.align = \"center\";\n+â”Š  â”Š 6â”Š    splashSprite.x = this.width / 2;\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Š    // Create splash sprite animation\n+â”Š  â”Š 9â”Š    this.splashAnim = new Engine.Animations.Keyframe(splashSprite, [\n+â”Š  â”Š10â”Š      {\n+â”Š  â”Š11â”Š        y: (this.height / 2) - 30,\n+â”Š  â”Š12â”Š        width: splashSprite.width / 4,\n+â”Š  â”Š13â”Š        height: splashSprite.height / 4,\n+â”Š  â”Š14â”Š        opacity: 0,\n+â”Š  â”Š15â”Š        easing: \"in\",\n+â”Š  â”Š16â”Š        frame: 0\n+â”Š  â”Š17â”Š      },\n+â”Š  â”Š18â”Š      {\n+â”Š  â”Š19â”Š        y: this.height / 2,\n+â”Š  â”Š20â”Š        width: (splashSprite.width / 3) + (splashSprite.width * 0.05),\n+â”Š  â”Š21â”Š        height: (splashSprite.height / 3) + (splashSprite.height * 0.05),\n+â”Š  â”Š22â”Š        opacity: 1,\n+â”Š  â”Š23â”Š        frame: 3000\n+â”Š  â”Š24â”Š      },\n+â”Š  â”Š25â”Š      {\n+â”Š  â”Š26â”Š        frame: 3500\n+â”Š  â”Š27â”Š      }\n+â”Š  â”Š28â”Š    ]);\n+â”Š  â”Š29â”Š\n+â”Š  â”Š30â”Š    // Start playing animation\n+â”Š  â”Š31â”Š    this.splashAnim.play();\n â”Š 7â”Š32â”Š  }\n â”Š 8â”Š33â”Š\n â”Š 9â”Š34â”Š  load(assetsLoader) {\n```\n```diff\n@@ -14,6 +39,10 @@\n â”Š14â”Š39â”Š  }\n â”Š15â”Š40â”Š\n â”Š16â”Š41â”Š  draw(context) {\n-â”Š17â”Š  â”Š    this.splashSprite.draw(context);\n+â”Š  â”Š42â”Š    this.splashAnim.draw(context);\n+â”Š  â”Š43â”Š  }\n+â”Š  â”Š44â”Š\n+â”Š  â”Š45â”Š  update(span) {\n+â”Š  â”Š46â”Š    this.splashAnim.update(span);\n â”Š18â”Š47â”Š  }\n â”Š19â”Š48â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nThe following key-frames illustrate the nodes of the animation we've just created:\n\n    width: 0\n    height: 0\n    opacity: 0\n\n![logo-empty](https://cloud.githubusercontent.com/assets/7648874/21583394/ee7a1dec-d065-11e6-80ce-fdd37c4b5dbb.png)\n\n    width: 225\n    height: 175\n    opacity: 1\n\n![logo-half](https://cloud.githubusercontent.com/assets/7648874/21583396/ee9bdf68-d065-11e6-95fb-4cf5ed58a9de.png)\n\n    width: 342\n    height: 266\n    opacity: 1\n\n![logo-full](https://cloud.githubusercontent.com/assets/7648874/21583395/ee7b3754-d065-11e6-9646-476d196a6412.png)"
          },
          {
            "manualTitle": "Step 4: Creating a main menu screen using a font engine",
            "stepRevision": "f88428bffcdf2bcf269b9cc15837cc40e0ed9caf",
            "manualView": "![snake-demo-menu-small](https://cloud.githubusercontent.com/assets/7648874/21074099/e72a81bc-bed6-11e6-98cb-329dc12a4b06.gif)\n\nIn this step we will be creating the main menu screen as shown above. The main menu screen is a simple screen which will show the logo of the game and an instruction text saying `Press a key to start`. We will be using a simple texture to show the game-logo and we will use the key-frame animation engine to show a flickering animation of the instruction text. The instruction text is the main part of this step, since it is made out of a font file (`.ttf`) and the text is auto-generated, a general solution which can serve us in many situations. We will start by implementing the main menu using static assets, which means that we will use a texture to show the instructions text, and later on we will implement the generic solution I've just mentioned. First, we will download the necessary assets:\n\n    resources/assets/textures$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/assets/textures/instructions.png\n    resources/assets/textures$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/assets/textures/logo.png\n\nAnd then we will implement the initial main menu screen:\n\n[{]: <helper> (diffStep 4.2)\n\n#### [Step 4.2: Create initial main menu screen](https://github.com/DAB0mB/radial-snake/commit/ed79de7)\n\n##### Added resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;menu&#x2F;index.js\n```diff\n@@ -0,0 +1,44 @@\n+â”Š  â”Š 1â”ŠGame.Screens.Menu = class Menu extends Engine.Screen {\n+â”Š  â”Š 2â”Š  initialize() {\n+â”Š  â”Š 3â”Š    // Initialize snake logo sprite\n+â”Š  â”Š 4â”Š    this.logoSprite = new Engine.Sprite(this.assets.logoTexture);\n+â”Š  â”Š 5â”Š    this.logoSprite.setPercentage(\"width\", this.width, 30, \"height\");\n+â”Š  â”Š 6â”Š\n+â”Š  â”Š 7â”Š    // Initialize instructions sprite\n+â”Š  â”Š 8â”Š    let instructionsSprite = new Engine.Sprite(this.assets.instructionsTexture);\n+â”Š  â”Š 9â”Š    instructionsSprite.align = \"center\";\n+â”Š  â”Š10â”Š    instructionsSprite.setPercentage(\"width\", this.width, 35, \"height\");\n+â”Š  â”Š11â”Š    instructionsSprite.x = this.width / 2;\n+â”Š  â”Š12â”Š    instructionsSprite.y = this.height / 2;\n+â”Š  â”Š13â”Š\n+â”Š  â”Š14â”Š    // Create flickering animation for instructions sprite\n+â”Š  â”Š15â”Š    this.instructionsAnim = new Engine.Animations.Keyframe(instructionsSprite, [\n+â”Š  â”Š16â”Š      {\n+â”Š  â”Š17â”Š        opacity: 1,\n+â”Š  â”Š18â”Š        frame: 0\n+â”Š  â”Š19â”Š      },\n+â”Š  â”Š20â”Š      {\n+â”Š  â”Š21â”Š        opacity: 0,\n+â”Š  â”Š22â”Š        frame: 2000\n+â”Š  â”Š23â”Š      }\n+â”Š  â”Š24â”Š    ]);\n+â”Š  â”Š25â”Š\n+â”Š  â”Š26â”Š    // Play it repeatedly, back and forth\n+â”Š  â”Š27â”Š    this.instructionsAnim.repetitionMode = \"full\";\n+â”Š  â”Š28â”Š    this.instructionsAnim.play();\n+â”Š  â”Š29â”Š  }\n+â”Š  â”Š30â”Š\n+â”Š  â”Š31â”Š  unload() {\n+â”Š  â”Š32â”Š    // Dispose the following assets to prevent memory leaks\n+â”Š  â”Š33â”Š    return [\"logoTexture\", \"instructionsTexture\"];\n+â”Š  â”Š34â”Š  }\n+â”Š  â”Š35â”Š\n+â”Š  â”Š36â”Š  draw(context) {\n+â”Š  â”Š37â”Š    this.logoSprite.draw(context);\n+â”Š  â”Š38â”Š    this.instructionsAnim.draw(context);\n+â”Š  â”Š39â”Š  }\n+â”Š  â”Š40â”Š\n+â”Š  â”Š41â”Š  update(span) {\n+â”Š  â”Š42â”Š    this.instructionsAnim.update(span);\n+â”Š  â”Š43â”Š  }\n+â”Š  â”Š44â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -16,6 +16,7 @@\n â”Š16â”Š16â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/screen.js\"></script>\n â”Š17â”Š17â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/assets_loader.js\"></script>\n â”Š18â”Š18â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n+â”Š  â”Š19â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/menu/index.js\"></script>\n â”Š19â”Š20â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/splash/index.js\"></script>\n â”Š20â”Š21â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n```\n\n[}]: #\n\nThis screen is dependent on several assets which we will load during \"splash screen time\", to save some loading time and for a smooth experience. The main menu screen will be shown automatically once the splash animation has been finished:\n\n[{]: <helper> (diffStep 4.3)\n\n#### [Step 4.3: Queue main menu screen](https://github.com/DAB0mB/radial-snake/commit/cd83a30)\n\n##### Changed resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;splash&#x2F;index.js\n```diff\n@@ -32,10 +32,21 @@\n â”Š32â”Š32â”Š  }\n â”Š33â”Š33â”Š\n â”Š34â”Š34â”Š  load(assetsLoader) {\n+â”Š  â”Š35â”Š    // Load assets\n+â”Š  â”Š36â”Š    let instructionsTexture = assetsLoader.texture(\"/textures/instrucitons\");\n+â”Š  â”Š37â”Š    let logoTexture = assetsLoader.texture(\"/textures/logo\");\n+â”Š  â”Š38â”Š    let splashTexture = assetsLoader.texture(\"/textures/splash\");\n+â”Š  â”Š39â”Š\n+â”Š  â”Š40â”Š    // These are global assets which will be shared among all screens until manually\n+â”Š  â”Š41â”Š    // disposed. We use the time gap created by the splash animation to load necessary\n+â”Š  â”Š42â”Š    // assets without wasting any time\n+â”Š  â”Š43â”Š    this.game.extendAssets({\n+â”Š  â”Š44â”Š      instructionsTexture,\n+â”Š  â”Š45â”Š      logoTexture\n+â”Š  â”Š46â”Š    });\n+â”Š  â”Š47â”Š\n â”Š35â”Š48â”Š    // These are local assets which will be disposed along with the screen\n-â”Š36â”Š  â”Š    return {\n-â”Š37â”Š  â”Š      splashTexture: assetsLoader.texture(\"/textures/splash\")\n-â”Š38â”Š  â”Š    };\n+â”Š  â”Š49â”Š    return { splashTexture };\n â”Š39â”Š50â”Š  }\n â”Š40â”Š51â”Š\n â”Š41â”Š52â”Š  draw(context) {\n```\n```diff\n@@ -43,6 +54,12 @@\n â”Š43â”Š54â”Š  }\n â”Š44â”Š55â”Š\n â”Š45â”Š56â”Š  update(span) {\n-â”Š46â”Š  â”Š    this.splashAnim.update(span);\n+â”Š  â”Š57â”Š    if (this.splashAnim.playing) {\n+â”Š  â”Š58â”Š      this.splashAnim.update(span);\n+â”Š  â”Š59â”Š    }\n+â”Š  â”Š60â”Š    // Once animation has stopped play switch to main menu\n+â”Š  â”Š61â”Š    else {\n+â”Š  â”Š62â”Š      this.game.changeScreen(Game.Screens.Menu);\n+â”Š  â”Š63â”Š    }\n â”Š47â”Š64â”Š  }\n â”Š48â”Š65â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nBy now if you launch the application you should see the main menu screen as described in the beginning. But event though it works, we're not yet finished. We still need to convert the instruction texture into an auto-generated font texture. Obviously, this requires us to download the desired `ttf` file:\n\n    resources/assets/fonts$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/assets/fonts/minecraftia.ttf\n\n> Any font file can be used here, but to save time and effort I already provided you with one\n\n`ttf` is the most common format, but since we're using JavaScript, it would make sense to convert it into a `json` file, and that's exactly what we're going to do. There's a very convenient software called [font-builder](https://github.com/andryblack/fontbuilder), and it can cut fonts, store them in `png` files, along with some user-specified meta-data stored in an `xml` file.\n\n![font-builder](https://camo.githubusercontent.com/b2c95cda825c783f5399d9197599848c33cdfcc8/687474703a2f2f7777772e67616d656465762e72752f66696c65732f696d616765732f73637265656e312e6a706567)\n\nGo over to this website: https://github.com/andryblack/fontbuilder.\nFetch a copy of the `font-builder` repo, and try to convert the `minecraftia.ttf` file into a `png` file. If you want to skip this step, although I wouldn't recommend it, you can download the following files which I already generated myself:\n\n    resources/assets/fonts$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/assets/fonts/minecraftia.png\n    resources/assets/fonts$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/assets/fonts/minecraftia.xml\n\nAs promised, we will be working with a `json` file, not a `ttf` file and not an `xml` file. For this task we will be implementing a font-parser module, which will simply take all the meta-data in the `xml` file and put it into a nice `json` schema:\n\n[{]: <helper> (diffStep 4.6)\n\n#### [Step 4.6: Create font parser so we can convert &#x27;xml&#x27; font format to &#x27;json&#x27;](https://github.com/DAB0mB/radial-snake/commit/66044e9)\n\n##### Added helpers&#x2F;font_parser.js\n```diff\n@@ -0,0 +1,102 @@\n+â”Š   â”Š  1â”Šconst _ = require(\"underscore\");\n+â”Š   â”Š  2â”Šconst Async = require(\"async\");\n+â”Š   â”Š  3â”Šconst Fs = require(\"fs\");\n+â”Š   â”Š  4â”Šconst Path = require(\"path\");\n+â”Š   â”Š  5â”Šconst { DOMParser } = require(\"xmldom\");\n+â”Š   â”Š  6â”Š\n+â”Š   â”Š  7â”Šif (module === require.main) {\n+â”Š   â”Š  8â”Š  let fonstDir = Path.resolve(__dirname, \"../resources/assets/fonts\");\n+â”Š   â”Š  9â”Š  xmlsToJsons(fonstDir, err => { if (err) throw err });\n+â”Š   â”Š 10â”Š}\n+â”Š   â”Š 11â”Š\n+â”Š   â”Š 12â”Š// Gets a dir path containing font xmls and converts them all to jsons\n+â”Š   â”Š 13â”Šfunction xmlsToJsons(path, callback = _.noop) {\n+â”Š   â”Š 14â”Š  Fs.readdir(path, (err, files) => {\n+â”Š   â”Š 15â”Š    if (err) return callback(err);\n+â”Š   â”Š 16â”Š\n+â”Š   â”Š 17â”Š    // Remove all extensions\n+â”Š   â”Š 18â”Š    fileNames = _.uniq(files.map(file => file.split(\".\")[0]));\n+â”Š   â”Š 19â”Š\n+â”Š   â”Š 20â”Š    // Convert each xml individually\n+â”Š   â”Š 21â”Š    Async.each(fileNames, (fileName, next) => {\n+â”Š   â”Š 22â”Š      xmlToJson(`${path}/${fileName}`, next);\n+â”Š   â”Š 23â”Š    },\n+â”Š   â”Š 24â”Š    (err) => {\n+â”Š   â”Š 25â”Š      if (!err) console.log(\n+â”Š   â”Š 26â”Š        'All fonts have been successfully parsed!'\n+â”Š   â”Š 27â”Š      );\n+â”Š   â”Š 28â”Š\n+â”Š   â”Š 29â”Š      callback(err);\n+â”Š   â”Š 30â”Š    });\n+â”Š   â”Š 31â”Š  });\n+â”Š   â”Š 32â”Š}\n+â”Š   â”Š 33â”Š\n+â”Š   â”Š 34â”Š// Gets a font xml and converts it to json\n+â”Š   â”Š 35â”Šfunction xmlToJson(path, callback = _.noop) {\n+â”Š   â”Š 36â”Š  Async.waterfall([\n+â”Š   â”Š 37â”Š    (next) => {\n+â”Š   â”Š 38â”Š      Fs.readFile(`${path}.xml`, function(err, xmlBuffer) {\n+â”Š   â”Š 39â”Š        if (err) return next(err);\n+â”Š   â”Š 40â”Š\n+â”Š   â”Š 41â”Š        let json = {\n+â”Š   â”Š 42â”Š          chars: {}\n+â”Š   â”Š 43â”Š        };\n+â”Š   â”Š 44â”Š\n+â”Š   â”Š 45â”Š        let xml = xmlBuffer.toString();\n+â”Š   â”Š 46â”Š        let doc = new DOMParser().parseFromString(xml);\n+â”Š   â”Š 47â”Š        let fontDoc = doc.getElementsByTagName(\"Font\")[0];\n+â”Š   â”Š 48â”Š        let charsDoc = fontDoc.getElementsByTagName(\"Char\");\n+â”Š   â”Š 49â”Š\n+â”Š   â”Š 50â”Š        // Compose meta-data about font like size and family\n+â”Š   â”Š 51â”Š        _.each(fontDoc.attributes, (attr) => {\n+â”Š   â”Š 52â”Š          json[attr.name] = parseInt(attr.value) || attr.value;\n+â”Š   â”Š 53â”Š        });\n+â”Š   â”Š 54â”Š\n+â”Š   â”Š 55â”Š        // Compose data about each character in font\n+â”Š   â”Š 56â”Š        _.each(charsDoc, (charDoc) => {\n+â”Š   â”Š 57â”Š          let charCode = charDoc.getAttribute(\"code\");\n+â”Š   â”Š 58â”Š\n+â”Š   â”Š 59â”Š          let char = json.chars[charCode] = {\n+â”Š   â”Š 60â”Š            rect: rect = {},\n+â”Š   â”Š 61â”Š            offset: offset = {},\n+â”Š   â”Š 62â”Š            width: parseInt(charDoc.getAttribute(\"width\"))\n+â”Š   â”Š 63â”Š          };\n+â”Š   â”Š 64â”Š\n+â”Š   â”Š 65â”Š          [\n+â”Š   â”Š 66â”Š            rect.x,\n+â”Š   â”Š 67â”Š            rect.y,\n+â”Š   â”Š 68â”Š            rect.width,\n+â”Š   â”Š 69â”Š            rect.height\n+â”Š   â”Š 70â”Š          ] = extractIntegers(charDoc.getAttribute(\"rect\"));\n+â”Š   â”Š 71â”Š\n+â”Š   â”Š 72â”Š          [offset.x, offset.y] = extractIntegers(charDoc.getAttribute(\"offset\"));\n+â”Š   â”Š 73â”Š        });\n+â”Š   â”Š 74â”Š\n+â”Š   â”Š 75â”Š        next(null, JSON.stringify(json, null, 2));\n+â”Š   â”Š 76â”Š      });\n+â”Š   â”Š 77â”Š    },\n+â”Š   â”Š 78â”Š    (json, next) => {\n+â”Š   â”Š 79â”Š      // Once finished, write json into file\n+â”Š   â”Š 80â”Š      Fs.writeFile(path + \".json\", json, (err) => {\n+â”Š   â”Š 81â”Š        next(err);\n+â”Š   â”Š 82â”Š      });\n+â”Š   â”Š 83â”Š    }\n+â”Š   â”Š 84â”Š  ], (err) => {\n+â”Š   â”Š 85â”Š    if (!err) console.log(\n+â”Š   â”Š 86â”Š      `Font ${path} has been successfully parsed...`\n+â”Š   â”Š 87â”Š    );\n+â”Š   â”Š 88â”Š\n+â”Š   â”Š 89â”Š    callback(err);\n+â”Š   â”Š 90â”Š  });\n+â”Š   â”Š 91â”Š};\n+â”Š   â”Š 92â”Š\n+â”Š   â”Š 93â”Š// Converts an string of numbers to array of numbers\n+â”Š   â”Š 94â”Š// e.g. extractIntegers(\"1 2 3\") -> [1, 2, 3]\n+â”Š   â”Š 95â”Šfunction extractIntegers(srcstr) {\n+â”Š   â”Š 96â”Š  return srcstr.split(\" \").map((substr) => parseInt(substr));\n+â”Š   â”Š 97â”Š}\n+â”Š   â”Š 98â”Š\n+â”Š   â”Š 99â”Šmodule.exports = {\n+â”Š   â”Š100â”Š  xmlToJson,\n+â”Š   â”Š101â”Š  xmlsToJsons\n+â”Š   â”Š102â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nThis script will take everything that's in the `fonts` dir and parser it as mentioned above. Before we can user this script we will need to install some NPM dependencies like so:\n\n    $ npm install --save underscore\n    $ npm install --save xmldom\n\nAnd instead of running the parser manually over and over again whenever we wanna use it, we will use the following `NPM` script instead:\n\n[{]: <helper> (diffStep 4.8)\n\n#### [Step 4.8: Add font parsing npm scripts](https://github.com/DAB0mB/radial-snake/commit/7a1cf81)\n\n##### Changed package.json\n```diff\n@@ -7,7 +7,8 @@\n â”Š 7â”Š 7â”Š  },\n â”Š 8â”Š 8â”Š  \"private\": true,\n â”Š 9â”Š 9â”Š  \"scripts\": {\n-â”Š10â”Š  â”Š    \"serve\": \"nodemon server.js\"\n+â”Š  â”Š10â”Š    \"serve\": \"npm run parse:fonts && nodemon server.js\",\n+â”Š  â”Š11â”Š    \"build:fonts\": \"node helpers/font_parser.js\"\n â”Š11â”Š12â”Š  },\n â”Š12â”Š13â”Š  \"dependencies\": {\n â”Š13â”Š14â”Š    \"async\": \"^2.1.4\",\n```\n\n[}]: #\n\nWe don't want the generated fonts to be included by `git` since they are going to automatically regenerate themselves, therefore we gonna add the following ignore rule:\n\n[{]: <helper> (diffStep 4.9)\n\n#### [Step 4.9: Add rule to to git-ignore parsed fonts](https://github.com/DAB0mB/radial-snake/commit/bbf7647)\n\n##### Changed .gitignore\n```diff\n@@ -1,2 +1,3 @@\n â”Š1â”Š1â”Šnode_modules\n-â”Š2â”Š â”Šnpm-debug.logðŸš«â†µ\n+â”Š â”Š2â”Šnpm-debug.log\n+â”Š â”Š3â”Šresources/assets/fonts/*.jsonðŸš«â†µ\n```\n\n[}]: #\n\nNow we will build our `minecraftia` font by simply running:\n\n    $ npm run build:fonts\n\nAnd voila! We have a freshly created `json` file which we can work with. You can also get it from here:\n\n    resources/assets/fonts$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/assets/fonts/minecraftia.json\n\nNow that we have our assets finally ready we can go ahead and focus on extending the engine which powers up our game. We need some sort of a generic font-engine which will know how to load a font file and create a text-sprite out of it. First we will implement a class called `Restorable`, which shares the same restore API as the CanvasRenderingContext2D and will give us the ability to save and restore the font's state (More information can be found [here](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/restore)):\n\n[{]: <helper> (diffStep 4.11)\n\n#### [Step 4.11: Add &#x27;Restorable&#x27; class](https://github.com/DAB0mB/radial-snake/commit/8239c01)\n\n##### Added resources&#x2F;scripts&#x2F;engine&#x2F;restorable.js\n```diff\n@@ -0,0 +1,21 @@\n+â”Š  â”Š 1â”ŠEngine.Restorable = class Restorable {\n+â”Š  â”Š 2â”Š  // Acts the same as canvas's save() and restore() API.\n+â”Š  â”Š 3â”Š  // 'restorable' props are defined in the constructor\n+â”Š  â”Š 4â”Š  constructor(...restorableProps) {\n+â”Š  â”Š 5â”Š    this._restorableProps = restorableProps;\n+â”Š  â”Š 6â”Š    this._restorableStates = [];\n+â”Š  â”Š 7â”Š  }\n+â”Š  â”Š 8â”Š\n+â”Š  â”Š 9â”Š  // Save current state in the stack\n+â”Š  â”Š10â”Š  save() {\n+â”Š  â”Š11â”Š    this._restorableStates.push(this._restorableProps.reduce((state, prop) => {\n+â”Š  â”Š12â”Š      state[prop] = this[prop];\n+â”Š  â”Š13â”Š      return state;\n+â”Š  â”Š14â”Š    }, {}));\n+â”Š  â”Š15â”Š  }\n+â”Š  â”Š16â”Š\n+â”Š  â”Š17â”Š  // Pop most recent state and apply it\n+â”Š  â”Š18â”Š  restore() {\n+â”Š  â”Š19â”Š    _.extend(this, this._restorableStates.pop());\n+â”Š  â”Š20â”Š  }\n+â”Š  â”Š21â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -9,6 +9,7 @@\n â”Š 9â”Š 9â”Š\n â”Š10â”Š10â”Š    <!-- Scripts -->\n â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n+â”Š  â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/restorable.js\"></script>\n â”Š12â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/sprite.js\"></script>\n â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/animations/keyframe.js\"></script>\n â”Š14â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/key_states.js\"></script>\n```\n\n[}]: #\n\nAnd now we can go ahead and implement the font class itself:\n\n[{]: <helper> (diffStep 4.12)\n\n#### [Step 4.12: Create font engine](https://github.com/DAB0mB/radial-snake/commit/7a1f2c7)\n\n##### Added resources&#x2F;scripts&#x2F;engine&#x2F;font.js\n```diff\n@@ -0,0 +1,133 @@\n+â”Š   â”Š  1â”ŠEngine.Font = class Font extends Engine.Restorable {\n+â”Š   â”Š  2â”Š  // The src property acts just line native image's src property.\n+â”Š   â”Š  3â”Š  // Once finished loading, the onload() callback will be invoked\n+â”Š   â”Š  4â”Š  get src() {\n+â”Š   â”Š  5â”Š    return this._src;\n+â”Š   â”Š  6â”Š  }\n+â”Š   â”Š  7â”Š\n+â”Š   â”Š  8â”Š  set src(src) {\n+â”Š   â”Š  9â”Š    this._src = src;\n+â”Š   â”Š 10â”Š\n+â”Š   â”Š 11â”Š    // The font is actually an image, therefore we have 2 onload callbacks.\n+â”Š   â”Š 12â”Š    // The first one is the native one which will always be run,\n+â”Š   â”Š 13â”Š    // and the second one is a user defined one\n+â”Š   â”Š 14â”Š    if (this.onload) var done = _.after(2, this.onload);\n+â”Š   â”Š 15â”Š\n+â”Š   â”Š 16â”Š    this.atlas = new Image();\n+â”Š   â”Š 17â”Š    this.atlas.onload = done;\n+â”Š   â”Š 18â”Š    this.atlas.src = `${src}.png`;\n+â”Š   â”Š 19â”Š\n+â”Š   â”Š 20â”Š    // Get json based on the given src property\n+â”Š   â”Š 21â”Š    $.getJSON(`${src}.json`, data => {\n+â”Š   â”Š 22â”Š      this.data = data;\n+â”Š   â”Š 23â”Š      if (done) done();\n+â”Š   â”Š 24â”Š    });\n+â”Š   â”Š 25â”Š\n+â”Š   â”Š 26â”Š    return this._src;\n+â”Š   â”Š 27â”Š  }\n+â”Š   â”Š 28â”Š\n+â”Š   â”Š 29â”Š  constructor() {\n+â”Š   â”Š 30â”Š    // The color property is the only restorable property\n+â”Š   â”Š 31â”Š    super(\"color\");\n+â”Š   â”Š 32â”Š    this.charSpritesCache = {};\n+â”Š   â”Š 33â”Š  }\n+â”Š   â”Š 34â”Š\n+â”Š   â”Š 35â”Š  // Creates a texture out of the font with the given text\n+â”Š   â”Š 36â”Š  createTexture(text, options = {}) {\n+â”Š   â”Š 37â”Š    let { noOffsets, noSpaces } = options;\n+â”Š   â”Š 38â”Š    let canvas = document.createElement(\"canvas\");\n+â”Š   â”Š 39â”Š    let context = canvas.getContext(\"2d\");\n+â”Š   â”Š 40â”Š    let height = canvas.height = this.data.height;\n+â”Š   â”Š 41â”Š\n+â”Š   â”Š 42â”Š    // Calculates the width of the canvas based on the text and the font\n+â”Š   â”Š 43â”Š    let width = canvas.width = _.reduce(text, (width, c) => {\n+â”Š   â”Š 44â”Š      // No-space option means that the characters will be\n+â”Š   â”Š 45â”Š      // drawn with no any space between them\n+â”Š   â”Š 46â”Š      if (noSpaces) {\n+â”Š   â”Š 47â”Š        return width + this.getCharSprite(c).width;\n+â”Š   â”Š 48â”Š      }\n+â”Š   â”Š 49â”Š\n+â”Š   â”Š 50â”Š      return width + this.data.chars[c].width;\n+â”Š   â”Š 51â”Š    }, 0);\n+â”Š   â”Š 52â”Š\n+â”Š   â”Š 53â”Š    // A custom size can be specified for a font as well\n+â”Š   â”Š 54â”Š    if (this.size) {\n+â”Š   â”Š 55â”Š      let ratio = this.size / this.data.size;\n+â”Š   â”Š 56â”Š      canvas.height *= ratio;\n+â”Š   â”Š 57â”Š      canvas.width *= ratio;\n+â”Š   â”Š 58â”Š      context.scale(ratio, ratio);\n+â”Š   â”Š 59â”Š    }\n+â”Š   â”Š 60â”Š\n+â”Š   â”Š 61â”Š    // No we are going to draw each char on the canvas individually,\n+â”Š   â”Š 62â”Š    // naturally, there should be an offset after we draw each character.\n+â”Š   â”Š 63â”Š    // This variable will be used to calculate the offset\n+â”Š   â”Š 64â”Š    let offset = 0;\n+â”Š   â”Š 65â”Š\n+â”Š   â”Š 66â”Š    // Get for each char\n+â”Š   â”Š 67â”Š    _.map(text, (char) => {\n+â”Š   â”Š 68â”Š      return this.getCharSprite(char);\n+â”Š   â”Š 69â”Š    })\n+â”Š   â”Š 70â”Š    // Start drawing each char on the canvas\n+â”Š   â”Š 71â”Š    .forEach((charSprite, index) => {\n+â”Š   â”Š 72â”Š      let charData = this.data.chars[text.charAt(index)];\n+â”Š   â”Š 73â”Š\n+â”Š   â”Š 74â”Š      // Each char in the font xml has a native offset in addition to its rectangle.\n+â”Š   â”Š 75â”Š      // This option will disable the calculation of the native offset\n+â”Š   â”Š 76â”Š      if (noOffsets) {\n+â”Š   â”Š 77â”Š        charSprite.draw(context, offset);\n+â”Š   â”Š 78â”Š      }\n+â”Š   â”Š 79â”Š      else {\n+â”Š   â”Š 80â”Š        charSprite.draw(context, offset + charData.offset.x, charData.offset.y);\n+â”Š   â”Š 81â”Š      }\n+â”Š   â”Š 82â”Š\n+â”Š   â”Š 83â”Š      if (noSpaces) {\n+â”Š   â”Š 84â”Š        offset += charSprite.width;\n+â”Š   â”Š 85â”Š      }\n+â”Š   â”Š 86â”Š      else {\n+â”Š   â”Š 87â”Š        offset += charData.width;\n+â”Š   â”Š 88â”Š      }\n+â”Š   â”Š 89â”Š\n+â”Š   â”Š 90â”Š      // A color for the font can be specified as well\n+â”Š   â”Š 91â”Š      if (this.color) {\n+â”Š   â”Š 92â”Š        let overlayCanvas = document.createElement(\"canvas\");\n+â”Š   â”Š 93â”Š        let overlayContext = overlayCanvas.getContext(\"2d\");\n+â”Š   â”Š 94â”Š        overlayCanvas.width = width;\n+â”Š   â”Š 95â”Š        overlayCanvas.height = height;\n+â”Š   â”Š 96â”Š        overlayContext.beginPath();\n+â”Š   â”Š 97â”Š        overlayContext.rect(0, 0, width, height);\n+â”Š   â”Š 98â”Š        overlayContext.fillStyle = this.color;\n+â”Š   â”Š 99â”Š        overlayContext.fill();\n+â”Š   â”Š100â”Š\n+â”Š   â”Š101â”Š        context.save();\n+â”Š   â”Š102â”Š        context.globalCompositeOperation = \"source-in\";\n+â”Š   â”Š103â”Š        context.drawImage(overlayCanvas, 0, 0);\n+â”Š   â”Š104â”Š        context.restore();\n+â”Š   â”Š105â”Š      }\n+â”Š   â”Š106â”Š    });\n+â”Š   â”Š107â”Š\n+â”Š   â”Š108â”Š    // The canvas will be treated like an image\n+â”Š   â”Š109â”Š    return canvas;\n+â”Š   â”Š110â”Š  }\n+â”Š   â”Š111â”Š\n+â”Š   â”Š112â”Š  // Gets a sprite of the given char, using the current font\n+â”Š   â”Š113â”Š  getCharSprite(char) {\n+â”Š   â”Š114â”Š    // If char is already stored in cache, abort calculation and return it\n+â”Š   â”Š115â”Š    if (this.charSpritesCache[char]) return this.charSpritesCache[char];\n+â”Š   â”Š116â”Š\n+â”Š   â”Š117â”Š    // This data is fetched by the given json\n+â”Š   â”Š118â”Š    let { x, y, width, height } = this.data.chars[char].rect;\n+â”Š   â”Š119â”Š    // Creating a canvas which we will use to draw on,\n+â”Š   â”Š120â”Š    // but it is used exactly like an image afterwards\n+â”Š   â”Š121â”Š    let canvas = document.createElement(\"canvas\");\n+â”Š   â”Š122â”Š    let context = canvas.getContext(\"2d\");\n+â”Š   â”Š123â”Š\n+â”Š   â”Š124â”Š    // The canvas will have the same dimensions as the font\n+â”Š   â”Š125â”Š    canvas.width = width;\n+â”Š   â”Š126â”Š    canvas.height = height;\n+â”Š   â”Š127â”Š    // Draw a cropped image from the atlas, this image contains the char font\n+â”Š   â”Š128â”Š    context.drawImage(this.atlas, x, y, width, height, 0, 0, width, height);\n+â”Š   â”Š129â”Š\n+â”Š   â”Š130â”Š    // Store in cache and return it\n+â”Š   â”Š131â”Š    return this.charSpritesCache[char] = new Engine.Sprite(canvas);\n+â”Š   â”Š132â”Š  }\n+â”Š   â”Š133â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -10,6 +10,7 @@\n â”Š10â”Š10â”Š    <!-- Scripts -->\n â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n â”Š12â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/restorable.js\"></script>\n+â”Š  â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/font.js\"></script>\n â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/sprite.js\"></script>\n â”Š14â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/animations/keyframe.js\"></script>\n â”Š15â”Š16â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/key_states.js\"></script>\n```\n\n[}]: #\n\nThe font API shares a similar API as [HTMLImageElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/Image), once we set the `src` property the font will start loading itself, and the `onload` user-defined callback should be called once finished. Another neat feature would be the `createTexture` method, which takes a string as its first argument, representing the text that we would like to generate, and returns an instance of the `Sprite` class.\n\nWe will also be adding the option to load some font assets in our asset-loader:\n\n[{]: <helper> (diffStep 4.13)\n\n#### [Step 4.13: Add a font loading option to &#x27;AssetLoader&#x27;](https://github.com/DAB0mB/radial-snake/commit/a9d73cc)\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;assets_loader.js\n```diff\n@@ -10,4 +10,12 @@\n â”Š10â”Š10â”Š    image.src = `${path}.png`;\n â”Š11â”Š11â”Š    return image;\n â”Š12â”Š12â”Š  }\n+â”Š  â”Š13â”Š\n+â”Š  â”Š14â”Š  // Load font\n+â”Š  â”Š15â”Š  font(path) {\n+â”Š  â”Š16â”Š    let font = new Engine.Font();\n+â”Š  â”Š17â”Š    font.onload = this.next();\n+â”Š  â”Š18â”Š    font.src = path;\n+â”Š  â”Š19â”Š    return font;\n+â”Š  â”Š20â”Š  }\n â”Š13â”Š21â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nAnd replace the instructions texture loading with a `minecraftia` font loading in the initial splash screen:\n\n[{]: <helper> (diffStep 4.14)\n\n#### [Step 4.14: Load &#x27;minecraftia&#x27; font in splash screen](https://github.com/DAB0mB/radial-snake/commit/231a68f)\n\n##### Changed resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;splash&#x2F;index.js\n```diff\n@@ -33,7 +33,7 @@\n â”Š33â”Š33â”Š\n â”Š34â”Š34â”Š  load(assetsLoader) {\n â”Š35â”Š35â”Š    // Load assets\n-â”Š36â”Š  â”Š    let instructionsTexture = assetsLoader.texture(\"/textures/instrucitons\");\n+â”Š  â”Š36â”Š    let minecraftiaFont = assetsLoader.font(\"/fonts/minecraftia\");\n â”Š37â”Š37â”Š    let logoTexture = assetsLoader.texture(\"/textures/logo\");\n â”Š38â”Š38â”Š    let splashTexture = assetsLoader.texture(\"/textures/splash\");\n â”Š39â”Š39â”Š\n```\n```diff\n@@ -41,7 +41,7 @@\n â”Š41â”Š41â”Š    // disposed. We use the time gap created by the splash animation to load necessary\n â”Š42â”Š42â”Š    // assets without wasting any time\n â”Š43â”Š43â”Š    this.game.extendAssets({\n-â”Š44â”Š  â”Š      instructionsTexture,\n+â”Š  â”Š44â”Š      minecraftiaFont,\n â”Š45â”Š45â”Š      logoTexture\n â”Š46â”Š46â”Š    });\n```\n\n[}]: #\n\nNow it can use us in the main menu screen where we will create a text-sprite saying `Press a key to start`, just like the instruction sprite we're about to replace:\n\n[{]: <helper> (diffStep 4.15)\n\n#### [Step 4.15: Replace texture usage with font usage in main menu screen](https://github.com/DAB0mB/radial-snake/commit/a769b81)\n\n##### Changed resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;menu&#x2F;index.js\n```diff\n@@ -5,7 +5,8 @@\n â”Š 5â”Š 5â”Š    this.logoSprite.setPercentage(\"width\", this.width, 30, \"height\");\n â”Š 6â”Š 6â”Š\n â”Š 7â”Š 7â”Š    // Initialize instructions sprite\n-â”Š 8â”Š  â”Š    let instructionsSprite = new Engine.Sprite(this.assets.instructionsTexture);\n+â”Š  â”Š 8â”Š    let instructionsTexture = this.assets.minecraftiaFont.createTexture(\"Press a key to start\");\n+â”Š  â”Š 9â”Š    let instructionsSprite = new Engine.Sprite(instructionsTexture);\n â”Š 9â”Š10â”Š    instructionsSprite.align = \"center\";\n â”Š10â”Š11â”Š    instructionsSprite.setPercentage(\"width\", this.width, 35, \"height\");\n â”Š11â”Š12â”Š    instructionsSprite.x = this.width / 2;\n```\n```diff\n@@ -30,7 +31,7 @@\n â”Š30â”Š31â”Š\n â”Š31â”Š32â”Š  unload() {\n â”Š32â”Š33â”Š    // Dispose the following assets to prevent memory leaks\n-â”Š33â”Š  â”Š    return [\"logoTexture\", \"instructionsTexture\"];\n+â”Š  â”Š34â”Š    return \"logoTexture\";\n â”Š34â”Š35â”Š  }\n â”Š35â”Š36â”Š\n â”Š36â”Š37â”Š  draw(context) {\n```\n```diff\n@@ -41,4 +42,8 @@\n â”Š41â”Š42â”Š  update(span) {\n â”Š42â”Š43â”Š    this.instructionsAnim.update(span);\n â”Š43â”Š44â”Š  }\n+â”Š  â”Š45â”Š\n+â”Š  â”Š46â”Š  update(span) {\n+â”Š  â”Š47â”Š    this.instructionsAnim.update(span);\n+â”Š  â”Š48â”Š  }\n â”Š44â”Š49â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nIt shouldn't look any different from the beginning of the step where we manually drew the instruction texture, but in the next steps we will be using the font-engine a lot, and you will be thankful for what we've just did."
          },
          {
            "manualTitle": "Step 5: Creating a snake and related geometry shapes",
            "stepRevision": "ad178e03e276b088c96d6f67889db379ad201e3e",
            "manualView": "![snake-illustrate](https://cloud.githubusercontent.com/assets/7648874/21074115/46ef4466-bed7-11e6-9d5d-12fa6d43147b.gif)\n\nIn this step we will be creating all the necessary geometry shapes to form a snake; we're basically implementing the right infrastructure so in the next step we will be able to implement the game screen with ease. What exactly do I mean by \"geometry shapes\"? Well, our snake will be made out of circles, and lines. If we don't press any buttons at all, the snake should move forward at a straight line, and once we press on one of the arrow keys, the snake should move in a circular motion. Not only we want to draw the screen on the canvas, we also want to be able to detect collision with other snakes, since this is a \"Tron\" style game where we gonna fight against an opponent.\n\nKeep in mind that a computer's precision is limited due its [binary representation in memory](https://en.wikipedia.org/wiki/Memory_cell_(binary)). We need to take into consideration that there might be a significant deviation when detecting collisions and intersections between geometry shapes, especially when elapsed time is not always guaranteed to stay precise. To handle these deviation issues, we're gonna create some utility functions and place then in a new module called `Utils`:\n\n[{]: <helper> (diffStep 5.1)\n\n#### [Step 5.1: Create utilities module](https://github.com/DAB0mB/radial-snake/commit/58ae99a)\n\n##### Added resources&#x2F;scripts&#x2F;utils.js\n```diff\n@@ -0,0 +1,68 @@\n+â”Š  â”Š 1â”Š// A wrapper function for our utilities which will enable chaining\n+â”Š  â”Š 2â”Š// e.g. Utils().mod().trim().isBetween()...\n+â”Š  â”Š 3â”ŠUtils = function Utils(context) {\n+â”Š  â”Š 4â”Š  const chain = {};\n+â”Š  â”Š 5â”Š\n+â”Š  â”Š 6â”Š  Object.keys(Utils).forEach((utilName) => {\n+â”Š  â”Š 7â”Š    chain[utilName] = (...args) => {\n+â”Š  â”Š 8â”Š      const result = Utils[utilName](context, ...args);\n+â”Š  â”Š 9â”Š      return Utils(result);\n+â”Š  â”Š10â”Š    };\n+â”Š  â”Š11â”Š  });\n+â”Š  â”Š12â”Š\n+â”Š  â”Š13â”Š  // Returns the result of the chaining\n+â”Š  â”Š14â”Š  chain.value = () => context;\n+â”Š  â”Š15â”Š\n+â”Š  â”Š16â”Š  return chain;\n+â”Š  â”Š17â”Š};\n+â”Š  â”Š18â”Š\n+â”Š  â”Š19â”Š// Fixed modulo method which can calculate modulo of negative numbers properly\n+â”Š  â”Š20â”Š// e.g. (-803).mod(800) returns 797\n+â”Š  â”Š21â”ŠUtils.mod = function (context, num) {\n+â”Š  â”Š22â”Š  return ((context % num) + num) % num;\n+â”Š  â”Š23â”Š};\n+â”Š  â”Š24â”Š\n+â”Š  â”Š25â”Š// Trims number and leaves the number of decimals specified.\n+â”Š  â”Š26â”Š// The \"mode\" argument specifies which math function should be invoked\n+â”Š  â”Š27â”Š// right after the number has been trimmed.\n+â”Š  â”Š28â”Š// e.g. 12.12345.trim(3, \"ceil\") returns 12.124\n+â”Š  â”Š29â”ŠUtils.trim = function (context, decimals, mode = \"round\") {\n+â”Š  â”Š30â”Š  return Math[mode](context * Math.pow(10, decimals)) / Math.pow(10, decimals);\n+â”Š  â”Š31â”Š};\n+â”Š  â”Š32â”Š\n+â”Š  â”Š33â”Š// Tells if number is in specified range based on given precision.\n+â”Š  â”Š34â”Š// See the \"compare\" method for more information about precision\n+â”Š  â”Š35â”ŠUtils.isBetween = function (context, num1, num2, precision) {\n+â”Š  â”Š36â”Š  return Utils.compare(context, Math.min(num1, num2), \">=\", precision) &&\n+â”Š  â”Š37â”Š         Utils.compare(context, Math.max(num1, num2), \"<=\", precision);\n+â”Š  â”Š38â”Š};\n+â”Š  â”Š39â”Š\n+â”Š  â”Š40â”Š// Initiates comparison operator between context number and a given number, only here\n+â”Š  â”Š41â”Š// a precision can be specified\n+â”Š  â”Š42â”ŠUtils.compare = function (context, num, method, precision = method) {\n+â”Š  â”Š43â”Š  switch (precision) {\n+â”Š  â”Š44â”Š    // Fixed precision, \"almost equal\" with a deviation of Îµ\n+â”Š  â”Š45â”Š    case \"f\":\n+â”Š  â”Š46â”Š      switch (method) {\n+â”Š  â”Š47â”Š        case \"<\": case \"<=\": return context <= num + Number.EPSILON;\n+â”Š  â”Š48â”Š        case \">\": case \">=\": return context >= num - Number.EPSILON;\n+â”Š  â”Š49â”Š        default: return Math.abs(context - num) <= Number.EPSILON;\n+â”Š  â”Š50â”Š      }\n+â”Š  â”Š51â”Š    // Pixel precision, round comparison\n+â”Š  â”Š52â”Š    case \"px\":\n+â”Š  â”Š53â”Š      switch (method) {\n+â”Š  â”Š54â”Š        case \"<\": case \"<=\": return Math.round(context) <= Math.round(num);\n+â”Š  â”Š55â”Š        case \">\": case \">=\": return Math.round(context) >= Math.round(num);\n+â”Š  â”Š56â”Š        default: return Math.round(context) == Math.round(num);\n+â”Š  â”Š57â”Š      }\n+â”Š  â”Š58â”Š    // Exact precision\n+â”Š  â”Š59â”Š    default:\n+â”Š  â”Š60â”Š      switch (method) {\n+â”Š  â”Š61â”Š        case \"<\": return context < num;\n+â”Š  â”Š62â”Š        case \"<=\": return context <= num;\n+â”Š  â”Š63â”Š        case \">\": return context > num;\n+â”Š  â”Š64â”Š        case \">=\": return context >= num;\n+â”Š  â”Š65â”Š        default: return context === num;\n+â”Š  â”Š66â”Š      }\n+â”Š  â”Š67â”Š  }\n+â”Š  â”Š68â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -8,6 +8,7 @@\n â”Š 8â”Š 8â”Š    <script type=\"text/javascript\" src=\"/libs/underscore.js\"></script>\n â”Š 9â”Š 9â”Š\n â”Š10â”Š10â”Š    <!-- Scripts -->\n+â”Š  â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/utils.js\"></script>\n â”Š11â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n â”Š12â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/restorable.js\"></script>\n â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/font.js\"></script>\n```\n\n[}]: #\n\nNow we would like to start implementing the first class representation for a line, and for that we're requires to add a new module called `Geometry` to the `Engine` namespace:\n\n[{]: <helper> (diffStep 5.2)\n\n#### [Step 5.2: Add &#x27;Shapes&#x27; module to &#x27;Engine&#x27; namespace](https://github.com/DAB0mB/radial-snake/commit/4ed2788)\n\n##### Changed resources&#x2F;scripts&#x2F;namespaces.js\n```diff\n@@ -3,5 +3,6 @@\n â”Š3â”Š3â”Š};\n â”Š4â”Š4â”Š\n â”Š5â”Š5â”ŠEngine = {\n-â”Š6â”Š â”Š  Animations: {}\n+â”Š â”Š6â”Š  Animations: {},\n+â”Š â”Š7â”Š  Geometry: {}\n â”Š7â”Š8â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nAnd now that we have this module available to use, we can go ahead and implement our first geometry shape class - `Line`:\n\n[{]: <helper> (diffStep 5.3)\n\n#### [Step 5.3: Create &#x27;Line&#x27; class](https://github.com/DAB0mB/radial-snake/commit/fb38ab5)\n\n##### Added resources&#x2F;scripts&#x2F;engine&#x2F;geometry&#x2F;line.js\n```diff\n@@ -0,0 +1,65 @@\n+â”Š  â”Š 1â”ŠEngine.Geometry.Line = class Line {\n+â”Š  â”Š 2â”Š  // x1 - The first point's x value\n+â”Š  â”Š 3â”Š  // y1 - The first point's y value\n+â”Š  â”Š 4â”Š  // x1 - The second point's x value\n+â”Š  â”Š 5â”Š  // y2 - The second point's y value\n+â”Š  â”Š 6â”Š  constructor(x1, y1, x2, y2) {\n+â”Š  â”Š 7â”Š    this.x1 = Utils.trim(x1, 9);\n+â”Š  â”Š 8â”Š    this.y1 = Utils.trim(y1, 9);\n+â”Š  â”Š 9â”Š    this.x2 = Utils.trim(x2, 9);\n+â”Š  â”Š10â”Š    this.y2 = Utils.trim(y2, 9);\n+â”Š  â”Š11â”Š  }\n+â”Š  â”Š12â”Š\n+â”Š  â”Š13â”Š  // Draws the line on the given context\n+â”Š  â”Š14â”Š  draw(context) {\n+â”Š  â”Š15â”Š    context.moveTo(this.x1, this.y1);\n+â”Š  â”Š16â”Š    context.lineTo(this.x2, this.y2);\n+â”Š  â”Š17â”Š  }\n+â”Š  â”Š18â”Š\n+â”Š  â”Š19â”Š  // Gets the matching x value for a given y value\n+â”Š  â”Š20â”Š  getX(y) {\n+â”Š  â”Š21â”Š    let x = Utils.trim((((y - this.y1) * (this.x2 - this.x1)) / (this.y2 - this.y1)) + this.x1, 9);\n+â”Š  â”Š22â”Š    if (isNaN(x) || Utils.isBetween(x, this.x1, this.x2)) return x;\n+â”Š  â”Š23â”Š  }\n+â”Š  â”Š24â”Š\n+â”Š  â”Š25â”Š  // Gets the matching y value for a given x value\n+â”Š  â”Š26â”Š  getY(x) {\n+â”Š  â”Š27â”Š    let y = Utils.trim((((x - this.x1) * (this.y2 - this.y1)) / (this.x2 - this.x1)) + this.y1, 9);\n+â”Š  â”Š28â”Š    if (isNaN(y) || Utils.isBetween(y, this.y1, this.y2)) return y;\n+â”Š  â”Š29â”Š  }\n+â”Š  â”Š30â”Š\n+â”Š  â”Š31â”Š  // Returns if line has given point\n+â”Š  â”Š32â”Š  hasPoint(x, y) {\n+â”Š  â”Š33â”Š    if (!this.boundsHavePoint(x, y)) return false;\n+â”Š  â”Š34â”Š    let m = Utils.trim((this.y2 - this.y1) / (this.x2 - this.x1), 9);\n+â”Š  â”Š35â”Š    return (y - this.y1) / (x - this.x1) == m;\n+â”Š  â”Š36â”Š  }\n+â”Š  â”Š37â”Š\n+â”Š  â”Š38â”Š  // Returns if given point is contained by the bounds aka cage of line\n+â”Š  â”Š39â”Š  boundsHavePoint(x, y) {\n+â”Š  â”Š40â”Š    return Utils.isBetween(x, this.x1, this.x2) &&\n+â”Š  â”Š41â”Š           Utils.isBetween(y, this.y1, this.y2);\n+â”Š  â”Š42â”Š  }\n+â”Š  â”Š43â”Š\n+â”Š  â”Š44â”Š  getIntersection(shape) {\n+â”Š  â”Š45â”Š    if (shape instanceof Engine.Geometry.Line)\n+â”Š  â”Š46â”Š      return this.getLineIntersection(shape);\n+â”Š  â”Š47â”Š  }\n+â”Š  â”Š48â”Š\n+â”Š  â”Š49â”Š  // line - line intersection method\n+â”Š  â”Š50â”Š  getLineIntersection(line) {\n+â”Š  â”Š51â”Š    // Escape if lines are parallel\n+â”Š  â”Š52â”Š    if (!(((this.x1 - this.x2) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * (line.x1 - line.x2)))) return;\n+â”Š  â”Š53â”Š\n+â”Š  â”Š54â”Š    // Intersection point formula\n+â”Š  â”Š55â”Š    let x = Utils.trim(((((this.x1 * this.y2) - (this.y1 * this.x2)) * (line.x1 - line.x2)) - ((this.x1 - this.x2) * ((line.x1 * line.y2) - (line.y1 * line.x2)))) /\n+â”Š  â”Š56â”Š        (((this.x1 - this.x2) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * (line.x1 - line.x2))), 9);\n+â”Š  â”Š57â”Š    let y = Utils.trim(((((this.x1 * this.y2) - (this.y1 * this.x2)) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * ((line.x1 * line.y2) - (line.y1 * line.x2)))) /\n+â”Š  â”Š58â”Š        (((this.x1 - this.x2) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * (line.x1 - line.x2))), 9);\n+â”Š  â”Š59â”Š\n+â”Š  â”Š60â”Š    if (Utils.isBetween(x, this.x1, this.x2) && Utils.isBetween(x, line.x1, line.x2) &&\n+â”Š  â”Š61â”Š        Utils.isBetween(y, this.y1, this.y2) && Utils.isBetween(y, line.y1, line.y2)) {\n+â”Š  â”Š62â”Š      return { x, y };\n+â”Š  â”Š63â”Š    }\n+â”Š  â”Š64â”Š  }\n+â”Š  â”Š65â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -10,6 +10,7 @@\n â”Š10â”Š10â”Š    <!-- Scripts -->\n â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/utils.js\"></script>\n â”Š12â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n+â”Š  â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/geometry/line.js\"></script>\n â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/restorable.js\"></script>\n â”Š14â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/font.js\"></script>\n â”Š15â”Š16â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/sprite.js\"></script>\n```\n\n[}]: #\n\nYou can go through the comments of the step above which will guide you through the programmatic aspect of it, but I think it's more important to understand the concept of a line in 2D space. A line is made out of two points, usually represented as `(x1, y1)` and `(x2, y2)`. The slope of the line, usually represented as `m`, can be determined using these two points based on the following formula:\n\n![slope](https://cloud.githubusercontent.com/assets/7648874/21788249/b4c7e41c-d6b4-11e6-9c17-baff66ec6bc8.png)\n\nOnce we have two lines whose `m` is different (Unparalleled) and there is no intersection between the points of which they are represented with (In which case they are united), there must be an intersection point. The intersection point can be found using the following formula:\n\n![line-line](https://cloud.githubusercontent.com/assets/7648874/21787164/c9d83bf0-d6ae-11e6-9846-4fc013eebab3.png)\n\n![line-line-illustration](https://cloud.githubusercontent.com/assets/7648874/21790864/56725cf0-d6c6-11e6-916b-50b1fc0b87af.png)\n\n> See reference: http://mathworld.wolfram.com/Line-LineIntersection.html.\n\nObviously we have some logic here which needs to be tested. To test our `Line` class, we will be using a testing framework called [Jasmine](https://jasmine.github.io/). We first need to download `Jasmine`'s essentials in order for it to work:\n\n    resources/libs$ mkdir jasmine\n    resources/libs$ cd jasmine\n    resources/libs/jasmine$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/libs/jasmine/boot.js\n    resources/libs/jasmine$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/libs/jasmine/console.js\n    resources/libs/jasmine$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/libs/jasmine/jasmine-html.js\n    resources/libs/jasmine$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/libs/jasmine/jasmine.css\n    resources/libs/jasmine$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/libs/jasmine/jasmine.js\n    resources/libs/jasmine$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/libs/jasmine/jasmine_favicon.png\n\nThese essentials should be loaded in a newly created view where we're gonna see our specs running:\n\n[{]: <helper> (diffStep 5.5)\n\n#### [Step 5.5: Create specs runner view](https://github.com/DAB0mB/radial-snake/commit/150be1a)\n\n##### Added views&#x2F;spec_runner.html\n```diff\n@@ -0,0 +1,27 @@\n+â”Š  â”Š 1â”Š\n+â”Š  â”Š 2â”Š<!DOCTYPE html>\n+â”Š  â”Š 3â”Š<html>\n+â”Š  â”Š 4â”Š  <head>\n+â”Š  â”Š 5â”Š    <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n+â”Š  â”Š 6â”Š    <title>Jasmine Spec Runner v2.0.1</title>\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Š    <!-- Jasmine -->\n+â”Š  â”Š 9â”Š    <script type=\"text/javascript\" src=\"libs/jasmine/jasmine.js\"></script>\n+â”Š  â”Š10â”Š    <script type=\"text/javascript\" src=\"libs/jasmine/jasmine-html.js\"></script>\n+â”Š  â”Š11â”Š    <script type=\"text/javascript\" src=\"libs/jasmine/boot.js\"></script>\n+â”Š  â”Š12â”Š    <link rel=\"shortcut icon\" type=\"image/png\" href=\"libs/jasmine/jasmine_favicon.png\">\n+â”Š  â”Š13â”Š    <link rel=\"stylesheet\" type=\"text/css\" href=\"libs/jasmine/jasmine.css\">\n+â”Š  â”Š14â”Š\n+â”Š  â”Š15â”Š    <!-- Libs -->\n+â”Š  â”Š16â”Š    <script type=\"text/javascript\" src=\"libs/underscore.js\"></script>\n+â”Š  â”Š17â”Š\n+â”Š  â”Š18â”Š    <!-- Scripts -->\n+â”Š  â”Š19â”Š    <script type=\"text/javascript\" src=\"scripts/utils.js\"></script>\n+â”Š  â”Š20â”Š    <script type=\"text/javascript\" src=\"scripts/namespaces.js\"></script>\n+â”Š  â”Š21â”Š\n+â”Š  â”Š22â”Š    <!-- Specs -->\n+â”Š  â”Š23â”Š  </head>\n+â”Š  â”Š24â”Š\n+â”Š  â”Š25â”Š  <body>\n+â”Š  â”Š26â”Š  </body>\n+â”Š  â”Š27â”Š</html>ðŸš«â†µ\n```\n\n[}]: #\n\nNow once we'll navigate to the `/test` sub-route (`localhost:8000/test` by default) we should be provided with the spec runner. As for now there are no specs implemented at all, which brings us to the next stage - Implementing tests for `Line` class:\n\n[{]: <helper> (diffStep 5.6)\n\n#### [Step 5.6: Create &#x27;Line&#x27; class tests](https://github.com/DAB0mB/radial-snake/commit/c052752)\n\n##### Added resources&#x2F;scripts&#x2F;specs&#x2F;engine&#x2F;geometry&#x2F;line.js\n```diff\n@@ -0,0 +1,78 @@\n+â”Š  â”Š 1â”Šdescribe(\"Engine.Geometry.Line class\", function() {\n+â”Š  â”Š 2â”Š  beforeEach(function() {\n+â”Š  â”Š 3â”Š    this.line = new Engine.Geometry.Line(-5, -5, 5, 5);\n+â”Š  â”Š 4â”Š  });\n+â”Š  â”Š 5â”Š\n+â”Š  â”Š 6â”Š  describe(\"getX method\", function() {\n+â”Š  â”Š 7â”Š    describe(\"given inranged y\", function() {\n+â”Š  â”Š 8â”Š      it(\"returns x\", function() {\n+â”Š  â”Š 9â”Š        expect(this.line.getX(1)).toBeCloseTo(1);\n+â”Š  â”Š10â”Š      });\n+â”Š  â”Š11â”Š    });\n+â”Š  â”Š12â”Š\n+â”Š  â”Š13â”Š    describe(\"given outranged y\", function() {\n+â”Š  â”Š14â”Š      it(\"returns nothing\", function() {\n+â”Š  â”Š15â”Š        expect(this.line.getX(10)).toBeUndefined();\n+â”Š  â”Š16â”Š      });\n+â”Š  â”Š17â”Š    });\n+â”Š  â”Š18â”Š  });\n+â”Š  â”Š19â”Š\n+â”Š  â”Š20â”Š  describe(\"getY method\", function() {\n+â”Š  â”Š21â”Š    describe(\"given inranged x\", function() {\n+â”Š  â”Š22â”Š      it(\"returns y\", function() {\n+â”Š  â”Š23â”Š        expect(this.line.getY(1)).toBeCloseTo(1);\n+â”Š  â”Š24â”Š      });\n+â”Š  â”Š25â”Š    });\n+â”Š  â”Š26â”Š\n+â”Š  â”Š27â”Š    describe(\"given outranged x\", function() {\n+â”Š  â”Š28â”Š      it(\"returns nothing\", function() {\n+â”Š  â”Š29â”Š        expect(this.line.getY(10)).toBeUndefined();\n+â”Š  â”Š30â”Š      });\n+â”Š  â”Š31â”Š    });\n+â”Š  â”Š32â”Š  });\n+â”Š  â”Š33â”Š\n+â”Š  â”Š34â”Š  describe(\"hasPoint method\", function() {\n+â”Š  â”Š35â”Š    describe(\"given contained point\", function() {\n+â”Š  â”Š36â”Š      it(\"returns true\", function() {\n+â”Š  â”Š37â”Š        let x = 1;\n+â”Š  â”Š38â”Š        let y = 1;\n+â”Š  â”Š39â”Š        expect(this.line.hasPoint(x, y)).toBeTruthy();\n+â”Š  â”Š40â”Š      });\n+â”Š  â”Š41â”Š    });\n+â”Š  â”Š42â”Š\n+â”Š  â”Š43â”Š    describe(\"given uncontained point\", function() {\n+â”Š  â”Š44â”Š      it(\"returns false\", function() {\n+â”Š  â”Š45â”Š        let x = 10;\n+â”Š  â”Š46â”Š        let y = 10;\n+â”Š  â”Š47â”Š        expect(this.line.hasPoint(x, y)).toBeFalsy();\n+â”Š  â”Š48â”Š      });\n+â”Š  â”Š49â”Š    });\n+â”Š  â”Š50â”Š  });\n+â”Š  â”Š51â”Š\n+â”Š  â”Š52â”Š  describe(\"getLineIntersection method\", function() {\n+â”Š  â”Š53â”Š    describe(\"given intersecting line\", function() {\n+â”Š  â”Š54â”Š      it(\"returns intersection point\", function() {\n+â”Š  â”Š55â”Š        let line = new Engine.Geometry.Line(1, -5, 1, 5);\n+â”Š  â”Š56â”Š\n+â”Š  â”Š57â”Š        expect(this.line.getLineIntersection(line)).toEqual({\n+â”Š  â”Š58â”Š          x: 1,\n+â”Š  â”Š59â”Š          y: 1\n+â”Š  â”Š60â”Š        });\n+â”Š  â”Š61â”Š      });\n+â”Š  â”Š62â”Š    });\n+â”Š  â”Š63â”Š\n+â”Š  â”Š64â”Š    describe(\"given parallel line\", function() {\n+â”Š  â”Š65â”Š      it(\"returns nothing\", function() {\n+â”Š  â”Š66â”Š        let line = new Engine.Geometry.Line(-5, -6, 5, 4);\n+â”Š  â”Š67â”Š        expect(this.line.getLineIntersection(line)).toBeUndefined();\n+â”Š  â”Š68â”Š      });\n+â”Š  â”Š69â”Š    });\n+â”Š  â”Š70â”Š\n+â”Š  â”Š71â”Š    describe(\"given outranged line\", function() {\n+â”Š  â”Š72â”Š      it(\"returns nothing\", function() {\n+â”Š  â”Š73â”Š        let line = new Engine.Geometry.Line(10, 10, 10, 15);\n+â”Š  â”Š74â”Š        expect(this.line.getLineIntersection(line)).toBeUndefined();\n+â”Š  â”Š75â”Š      });\n+â”Š  â”Š76â”Š    });\n+â”Š  â”Š77â”Š  });\n+â”Š  â”Š78â”Š});ðŸš«â†µ\n```\n\n##### Changed views&#x2F;spec_runner.html\n```diff\n@@ -18,8 +18,10 @@\n â”Š18â”Š18â”Š    <!-- Scripts -->\n â”Š19â”Š19â”Š    <script type=\"text/javascript\" src=\"scripts/utils.js\"></script>\n â”Š20â”Š20â”Š    <script type=\"text/javascript\" src=\"scripts/namespaces.js\"></script>\n+â”Š  â”Š21â”Š    <script type=\"text/javascript\" src=\"scripts/engine/geometry/line.js\"></script>\n â”Š21â”Š22â”Š\n â”Š22â”Š23â”Š    <!-- Specs -->\n+â”Š  â”Š24â”Š    <script type=\"text/javascript\" src=\"scripts/specs/engine/geometry/line.js\"></script>\n â”Š23â”Š25â”Š  </head>\n â”Š24â”Š26â”Š\n â”Š25â”Š27â”Š  <body>\n```\n\n[}]: #\n\nNow if you'll refresh the spec runner page you should be able to a green screen indicating all tests have passed (Assuming the tutorial is updated and you followed it correctly). As introduced at the beginning of the step, the snake is also dependent on circles, whose representing class should look like so:\n\n[{]: <helper> (diffStep 5.7)\n\n#### [Step 5.7: Create &#x27;Circle&#x27; class](https://github.com/DAB0mB/radial-snake/commit/f9c5723)\n\n##### Added resources&#x2F;scripts&#x2F;engine&#x2F;geometry&#x2F;circle.js\n```diff\n@@ -0,0 +1,167 @@\n+â”Š   â”Š  1â”ŠEngine.Geometry.Circle = class Circle {\n+â”Š   â”Š  2â”Š  // x - The x value of the circle's center\n+â”Š   â”Š  3â”Š  // y - The y value of the circle's center\n+â”Š   â”Š  4â”Š  // r - The radius of the center\n+â”Š   â”Š  5â”Š  // rad1 - The first radian of the circle, not necessarily its beginning\n+â”Š   â”Š  6â”Š  // rad2 - The second radian of the circle, not necessarily its beginning\n+â”Š   â”Š  7â”Š  constructor(x, y, r, rad1, rad2) {\n+â”Š   â”Š  8â”Š    this.x = Utils.trim(x, 9);\n+â”Š   â”Š  9â”Š    this.y = Utils.trim(y, 9);\n+â”Š   â”Š 10â”Š    this.r = Utils.trim(r, 9);\n+â”Š   â”Š 11â”Š\n+â”Š   â”Š 12â”Š    // Trimming mode is done based on which radian represents the ending and which radian\n+â”Š   â”Š 13â”Š    // represents the ending\n+â”Š   â”Š 14â”Š    if (rad1 > rad2) {\n+â”Š   â”Š 15â”Š      this.rad1 = Utils.trim(rad1, 9, \"floor\");\n+â”Š   â”Š 16â”Š      this.rad2 = Utils.trim(rad2, 9, \"ceil\");\n+â”Š   â”Š 17â”Š    }\n+â”Š   â”Š 18â”Š    else {\n+â”Š   â”Š 19â”Š      this.rad1 = Utils.trim(rad1, 9, \"ceil\");\n+â”Š   â”Š 20â”Š      this.rad2 = Utils.trim(rad2, 9, \"floor\");\n+â”Š   â”Š 21â”Š    }\n+â”Š   â”Š 22â”Š  }\n+â”Š   â”Š 23â”Š\n+â”Š   â”Š 24â”Š  // Draws the circle on the given context\n+â”Š   â”Š 25â”Š  draw(context) {\n+â”Š   â”Š 26â”Š    context.arc(this.x, this.y, this.r, this.rad1, this.rad2);\n+â”Š   â”Š 27â”Š  }\n+â”Š   â”Š 28â”Š\n+â”Š   â”Š 29â”Š  // Gets the matching x value for the given radian\n+â”Š   â”Š 30â”Š  getX(rad) {\n+â”Š   â”Š 31â”Š    if (!Utils(rad).trim(9).isBetween(this.rad1, this.rad2).value()) return;\n+â”Š   â”Š 32â”Š    return Utils.trim((this.r * Math.cos(rad)) + this.x, 9);\n+â”Š   â”Š 33â”Š  }\n+â”Š   â”Š 34â”Š\n+â”Š   â”Š 35â”Š  // Gets the matching y value for the given radian\n+â”Š   â”Š 36â”Š  getY(rad) {\n+â”Š   â”Š 37â”Š    if (!Utils(rad).trim(9).isBetween(this.rad1, this.rad2).value()) return;\n+â”Š   â”Š 38â”Š    return Utils.trim((this.r * Math.sin(rad)) + this.y, 9);\n+â”Š   â”Š 39â”Š  }\n+â”Š   â”Š 40â”Š\n+â”Š   â”Š 41â”Š  // Gets the matching point for the given radian\n+â”Š   â”Š 42â”Š  getPoint(rad) {\n+â”Š   â”Š 43â”Š    if (!Utils.isBetween(rad, this.rad1, this.rad2)) return;\n+â”Š   â”Š 44â”Š\n+â”Š   â”Š 45â”Š    return {\n+â”Š   â”Š 46â”Š      x: Utils.trim((this.r * Math.cos(rad)) + this.x, 9),\n+â”Š   â”Š 47â”Š      y: Utils.trim((this.r * Math.sin(rad)) + this.y, 9)\n+â”Š   â”Š 48â”Š    };\n+â”Š   â”Š 49â”Š  }\n+â”Š   â”Š 50â”Š\n+â”Š   â”Š 51â”Š  // Gets the matching radian for the given point\n+â”Š   â”Š 52â”Š  getRad(x, y) {\n+â”Š   â”Š 53â”Š    let rad = Math.atan2(y - this.y, x - this.x);\n+â”Š   â”Š 54â”Š\n+â”Š   â”Š 55â”Š    // If calculated radian is in circle's radian range, return it\n+â”Š   â”Š 56â”Š    if (rad != null && Utils.isBetween(rad, this.rad1, this.rad2)) {\n+â”Š   â”Š 57â”Š      return rad;\n+â”Š   â”Š 58â”Š    }\n+â”Š   â”Š 59â”Š\n+â”Š   â”Š 60â”Š    // The calculated radian can still be in the circle's radian range in case one\n+â”Š   â”Š 61â”Š    // of the radians is greater than 2 PIEs\n+â”Š   â”Š 62â”Š    if (Math.abs(this.rad1) > Math.abs(this.rad2)) {\n+â”Š   â”Š 63â”Š      var greatestRad = this.rad1;\n+â”Š   â”Š 64â”Š    }\n+â”Š   â”Š 65â”Š    else {\n+â”Š   â”Š 66â”Š      var greatestRad = this.rad2;\n+â”Š   â”Š 67â”Š    }\n+â”Š   â”Š 68â”Š\n+â”Š   â”Š 69â”Š    // Check if the absolute radian is in the circle's radian range\n+â”Š   â”Š 70â”Š    if (Utils(rad + (2 * Math.PI * Math.floor(greatestRad / (2 * Math.PI)))).trim(9).isBetween(this.rad1, this.rad2).value() ||\n+â”Š   â”Š 71â”Š        Utils(rad + (2 * Math.PI * Math.ceil(greatestRad / (2 * Math.PI)))).trim(9).isBetween(this.rad1, this.rad2).value()) {\n+â”Š   â”Š 72â”Š      return rad;\n+â”Š   â”Š 73â”Š    }\n+â”Š   â”Š 74â”Š  }\n+â”Š   â”Š 75â”Š\n+â”Š   â”Š 76â”Š  // Returns if circle has given points\n+â”Š   â”Š 77â”Š  hasPoint(x, y) {\n+â”Š   â”Š 78â”Š    return this.getRad(x, y) != null;\n+â”Š   â”Š 79â”Š  }\n+â”Š   â”Š 80â”Š\n+â”Š   â”Š 81â”Š  getIntersection(shape) {\n+â”Š   â”Š 82â”Š    if (shape instanceof Engine.Geometry.Line)\n+â”Š   â”Š 83â”Š      return this.getLineIntersection(shape);\n+â”Š   â”Š 84â”Š    if (shape instanceof Engine.Geometry.Circle)\n+â”Š   â”Š 85â”Š      return this.getCircleIntersection(shape);\n+â”Š   â”Š 86â”Š  }\n+â”Š   â”Š 87â”Š\n+â”Š   â”Š 88â”Š  // circle - circle intersection method\n+â”Š   â”Š 89â”Š  getCircleIntersection(circle) {\n+â”Š   â”Š 90â”Š    let dx = circle.x - this.x;\n+â”Š   â”Š 91â”Š    let dy = circle.y - this.y;\n+â”Š   â”Š 92â”Š    let d = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\n+â”Š   â”Š 93â”Š\n+â”Š   â”Š 94â”Š    if (d > this.r + circle.r ||\n+â”Š   â”Š 95â”Š       d < Math.abs(this.r - circle.r)) {\n+â”Š   â”Š 96â”Š      return;\n+â”Š   â”Š 97â”Š    }\n+â”Š   â”Š 98â”Š\n+â”Š   â”Š 99â”Š    let a = ((Math.pow(this.r, 2) - Math.pow(circle.r, 2)) + Math.pow(d, 2)) / (2 * d);\n+â”Š   â”Š100â”Š    let x = this.x + ((dx * a) / d);\n+â”Š   â”Š101â”Š    let y = this.y + ((dy * a) / d);\n+â”Š   â”Š102â”Š    let h = Math.sqrt(Math.pow(this.r, 2) - Math.pow(a, 2));\n+â”Š   â”Š103â”Š    let rx = (- dy * h) / d;\n+â”Š   â”Š104â”Š    let ry = (dx * h) / d;\n+â”Š   â”Š105â”Š\n+â”Š   â”Š106â”Š    let interPoints = [\n+â”Š   â”Š107â”Š      {\n+â”Š   â”Š108â”Š        x: x + rx,\n+â”Š   â”Š109â”Š        y: y + ry\n+â”Š   â”Š110â”Š      },\n+â”Š   â”Š111â”Š      {\n+â”Š   â”Š112â”Š        x: x - rx,\n+â”Š   â”Š113â”Š        y: y - ry\n+â”Š   â”Š114â”Š      }\n+â”Š   â”Š115â”Š    ]\n+â”Š   â”Š116â”Š    .map(point => ({\n+â”Š   â”Š117â”Š        x: Utils.trim(point.x, 9),\n+â”Š   â”Š118â”Š        y: Utils.trim(point.y, 9)\n+â”Š   â”Š119â”Š     }));\n+â”Š   â”Š120â”Š\n+â”Š   â”Š121â”Š    interPoints = _.uniq(interPoints, point => `(${point.x}, ${point.y})`);\n+â”Š   â”Š122â”Š\n+â”Š   â”Š123â”Š    [this, circle].forEach(function(circle) {\n+â”Š   â”Š124â”Š      interPoints = interPoints.filter(point => circle.hasPoint(point.x, point.y));\n+â”Š   â”Š125â”Š    });\n+â”Š   â”Š126â”Š\n+â”Š   â”Š127â”Š    if (interPoints.length > 0) return interPoints;\n+â”Š   â”Š128â”Š  }\n+â”Š   â”Š129â”Š\n+â”Š   â”Š130â”Š  // circle - line intersection method\n+â”Š   â”Š131â”Š  getLineIntersection(line) {\n+â”Š   â”Š132â”Š    let x1 = line.x1 - this.x;\n+â”Š   â”Š133â”Š    let x2 = line.x2 - this.x;\n+â”Š   â”Š134â”Š    let y1 = line.y1 - this.y;\n+â”Š   â”Š135â”Š    let y2 = line.y2 - this.y;\n+â”Š   â”Š136â”Š    let dx = x2 - x1;\n+â”Š   â”Š137â”Š    let dy = y2 - y1;\n+â”Š   â”Š138â”Š    let d = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\n+â”Š   â”Š139â”Š    let h = (x1 * y2) - (x2 * y1);\n+â”Š   â”Š140â”Š    let delta = (Math.pow(this.r, 2) * Math.pow(d, 2)) - Math.pow(h, 2);\n+â”Š   â”Š141â”Š\n+â”Š   â”Š142â”Š    if (delta < 0) return;\n+â”Š   â”Š143â”Š\n+â”Š   â”Š144â”Š    let interPoints = [\n+â”Š   â”Š145â”Š      {\n+â”Š   â”Š146â”Š        x: (((h * dy) + (((dy / Math.abs(dy)) || 1) * dx * Math.sqrt(delta))) / Math.pow(d, 2)) + this.x,\n+â”Š   â”Š147â”Š        y: (((-h * dx) + (Math.abs(dy) * Math.sqrt(delta))) / Math.pow(d, 2)) + this.y\n+â”Š   â”Š148â”Š      },\n+â”Š   â”Š149â”Š      {\n+â”Š   â”Š150â”Š        x: (((h * dy) - (((dy / Math.abs(dy)) || 1) * dx * Math.sqrt(delta))) / Math.pow(d, 2)) + this.x,\n+â”Š   â”Š151â”Š        y: (((-h * dx) - (Math.abs(dy) * Math.sqrt(delta))) / Math.pow(d, 2)) + this.y\n+â”Š   â”Š152â”Š      }\n+â”Š   â”Š153â”Š    ]\n+â”Š   â”Š154â”Š    .map(point => ({\n+â”Š   â”Š155â”Š        x: Utils.trim(point.x, 9),\n+â”Š   â”Š156â”Š        y: Utils.trim(point.y, 9)\n+â”Š   â”Š157â”Š    }))\n+â”Š   â”Š158â”Š    .filter(point => {\n+â”Š   â”Š159â”Š      return this.hasPoint(point.x, point.y) &&\n+â”Š   â”Š160â”Š        line.boundsHavePoint(point.x, point.y);\n+â”Š   â”Š161â”Š    });\n+â”Š   â”Š162â”Š\n+â”Š   â”Š163â”Š    interPoints = _.uniq(interPoints, point => `(${point.x}, ${point.y})`);\n+â”Š   â”Š164â”Š\n+â”Š   â”Š165â”Š    if (interPoints.length > 0) return interPoints;\n+â”Š   â”Š166â”Š  }\n+â”Š   â”Š167â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -11,6 +11,7 @@\n â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/utils.js\"></script>\n â”Š12â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n â”Š13â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/geometry/line.js\"></script>\n+â”Š  â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/geometry/circle.js\"></script>\n â”Š14â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/restorable.js\"></script>\n â”Š15â”Š16â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/font.js\"></script>\n â”Š16â”Š17â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/sprite.js\"></script>\n```\n\n[}]: #\n\nJust like a line, a circle can be presented using variables as well. The center of the circle is represented as `(x, y)` and its radius is represented as `r`. Remember that our circle doesn't necessarily have to be a full one, therefore we limit its range using two radians - `rad1` and `rad2`. The formula for representing a circle in a 2D space looks like this:\n\n![circle-formula](https://cloud.githubusercontent.com/assets/7648874/21829783/84a54574-d77f-11e6-9b87-3fb0f073bb8d.png)\n\n![circle-circle-illustration](https://cloud.githubusercontent.com/assets/7648874/21790842/3a73408c-d6c6-11e6-8bdd-9c73355e6ebb.png)\n\n> `a` and `b` represent the offsets from the `x` and the `y` axes respectively.\n> See reference: http://mathworld.wolfram.com/Circle-CircleIntersection.html.\n\nTo find intersection between two circles, we simply calculate the solution for two equations with two variables. Given that a line can be represented in a 2D space using the following formula:\n\n![line-formula](https://cloud.githubusercontent.com/assets/7648874/21790671/1609c050-d6c5-11e6-8bd7-16cc306f5eea.png)\n\n![circle-line-illustration](https://cloud.githubusercontent.com/assets/7648874/21790810/1a052086-d6c6-11e6-9c5c-24298fedb043.png)\n\n> `n` represents the intersection value with the `y` axis.\n> See reference: http://mathworld.wolfram.com/Circle-LineIntersection.html.\n\nwe can find the intersection between a circle and line by solving the systems formed by the equations of both. We also want the line-circle algorithm to be available for any `Line` instance, therefore we gonna add the following delegate on the `Line` prototype:\n\n[{]: <helper> (diffStep 5.8)\n\n#### [Step 5.8: Delegate circle intersection methods](https://github.com/DAB0mB/radial-snake/commit/19828bf)\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;geometry&#x2F;line.js\n```diff\n@@ -44,6 +44,8 @@\n â”Š44â”Š44â”Š  getIntersection(shape) {\n â”Š45â”Š45â”Š    if (shape instanceof Engine.Geometry.Line)\n â”Š46â”Š46â”Š      return this.getLineIntersection(shape);\n+â”Š  â”Š47â”Š    if (shape instanceof Engine.Geometry.Circle)\n+â”Š  â”Š48â”Š      return this.getCircleIntersection(shape);\n â”Š47â”Š49â”Š  }\n â”Š48â”Š50â”Š\n â”Š49â”Š51â”Š  // line - line intersection method\n```\n```diff\n@@ -62,4 +64,9 @@\n â”Š62â”Š64â”Š      return { x, y };\n â”Š63â”Š65â”Š    }\n â”Š64â”Š66â”Š  }\n+â”Š  â”Š67â”Š\n+â”Š  â”Š68â”Š  // line - circle intersection method\n+â”Š  â”Š69â”Š  getCircleIntersection(circle) {\n+â”Š  â”Š70â”Š    return circle.getLineIntersection(this);\n+â”Š  â”Š71â”Š  }\n â”Š65â”Š72â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nThen again a newly created geometry shape class should be tested against different scenarios:\n\n[{]: <helper> (diffStep 5.9)\n\n#### [Step 5.9: Create &#x27;Circle&#x27; class tests](https://github.com/DAB0mB/radial-snake/commit/1d98a6e)\n\n##### Added resources&#x2F;scripts&#x2F;specs&#x2F;engine&#x2F;geometry&#x2F;circle.js\n```diff\n@@ -0,0 +1,144 @@\n+â”Š   â”Š  1â”Šdescribe(\"Engine.Geometry.Circle class\", function() {\n+â”Š   â”Š  2â”Š  beforeEach(function() {\n+â”Š   â”Š  3â”Š    this.circle = new Engine.Geometry.Circle(1, 1, 5, 0, 1.5 * Math.PI);\n+â”Š   â”Š  4â”Š  });\n+â”Š   â”Š  5â”Š\n+â”Š   â”Š  6â”Š  describe(\"getX method\", function() {\n+â”Š   â”Š  7â”Š    describe(\"given inranged rad\", function() {\n+â”Š   â”Š  8â”Š      it(\"returns x\", function() {\n+â”Š   â”Š  9â”Š        expect(this.circle.getX(0 * Math.PI)).toBeCloseTo(6);\n+â”Š   â”Š 10â”Š        expect(this.circle.getX(0.5 * Math.PI)).toBeCloseTo(1);\n+â”Š   â”Š 11â”Š        expect(this.circle.getX(1 * Math.PI)).toBeCloseTo(-4);\n+â”Š   â”Š 12â”Š        expect(this.circle.getX(1.5 * Math.PI)).toBeCloseTo(1);\n+â”Š   â”Š 13â”Š      });\n+â”Š   â”Š 14â”Š    });\n+â”Š   â”Š 15â”Š\n+â”Š   â”Š 16â”Š    describe(\"given outranged rad\", function() {\n+â”Š   â”Š 17â”Š      it(\"returns nothing\", function() {\n+â”Š   â”Š 18â”Š        expect(this.circle.getX(2 * Math.PI)).toBeUndefined();\n+â”Š   â”Š 19â”Š      });\n+â”Š   â”Š 20â”Š    });\n+â”Š   â”Š 21â”Š  });\n+â”Š   â”Š 22â”Š\n+â”Š   â”Š 23â”Š  describe(\"getY method\", function() {\n+â”Š   â”Š 24â”Š    describe(\"given inranged rad\", function() {\n+â”Š   â”Š 25â”Š      it(\"returns y\", function() {\n+â”Š   â”Š 26â”Š        expect(this.circle.getY(0 * Math.PI)).toBeCloseTo(1);\n+â”Š   â”Š 27â”Š        expect(this.circle.getY(0.5 * Math.PI)).toBeCloseTo(6);\n+â”Š   â”Š 28â”Š        expect(this.circle.getY(1 * Math.PI)).toBeCloseTo(1);\n+â”Š   â”Š 29â”Š        expect(this.circle.getY(1.5 * Math.PI)).toBeCloseTo(-4);\n+â”Š   â”Š 30â”Š      });\n+â”Š   â”Š 31â”Š    });\n+â”Š   â”Š 32â”Š\n+â”Š   â”Š 33â”Š    describe(\"given outranged rad\", function() {\n+â”Š   â”Š 34â”Š      it(\"returns nothing\", function() {\n+â”Š   â”Š 35â”Š        expect(this.circle.getY(2 * Math.PI)).toBeUndefined();\n+â”Š   â”Š 36â”Š      });\n+â”Š   â”Š 37â”Š    });\n+â”Š   â”Š 38â”Š  });\n+â”Š   â”Š 39â”Š\n+â”Š   â”Š 40â”Š  describe(\"getRad method\", function() {\n+â”Š   â”Š 41â”Š    describe(\"given inranged point\", function() {\n+â”Š   â”Š 42â”Š      it(\"returns rad\", function() {\n+â”Š   â”Š 43â”Š        let x = -3.0450849718747346;\n+â”Š   â”Š 44â”Š        let y = 3.9389262614623686;\n+â”Š   â”Š 45â”Š        expect(this.circle.getRad(x, y)).toBeCloseTo(0.8 * Math.PI);\n+â”Š   â”Š 46â”Š      });\n+â”Š   â”Š 47â”Š    });\n+â”Š   â”Š 48â”Š\n+â”Š   â”Š 49â”Š    describe(\"given outranged point\", function() {\n+â”Š   â”Š 50â”Š      it(\"returns nothing\", function() {\n+â”Š   â”Š 51â”Š        let x = 5.045084971874736;\n+â”Š   â”Š 52â”Š        let y = -1.9389262614623664;\n+â”Š   â”Š 53â”Š        expect(this.circle.getRad(x, y)).toBeUndefined();\n+â”Š   â”Š 54â”Š      });\n+â”Š   â”Š 55â”Š    });\n+â”Š   â”Š 56â”Š  });\n+â”Š   â”Š 57â”Š\n+â”Š   â”Š 58â”Š  describe(\"getCircleIntersection method\", function() {\n+â”Š   â”Š 59â”Š    describe(\"given circle with 2 intersection points\", function() {\n+â”Š   â”Š 60â”Š      it(\"returns array with intersection points\", function() {\n+â”Š   â”Š 61â”Š        let circle = new Engine.Geometry.Circle(-5, 1, 5, 0, 2 * Math.PI);\n+â”Š   â”Š 62â”Š\n+â”Š   â”Š 63â”Š        expect(this.circle.getCircleIntersection(circle)).toEqual([\n+â”Š   â”Š 64â”Š          { x: -2, y: -3 },\n+â”Š   â”Š 65â”Š          { x: -2, y: 5 }\n+â”Š   â”Š 66â”Š        ]);\n+â”Š   â”Š 67â”Š      });\n+â”Š   â”Š 68â”Š    });\n+â”Š   â”Š 69â”Š\n+â”Š   â”Š 70â”Š    describe(\"given circle with 1 intersection points\", function() {\n+â”Š   â”Š 71â”Š      it(\"returns array with intersection point\", function() {\n+â”Š   â”Š 72â”Š        let circle = new Engine.Geometry.Circle(-5, 1, 5, 0, 1 * Math.PI);\n+â”Š   â”Š 73â”Š\n+â”Š   â”Š 74â”Š        expect(this.circle.getCircleIntersection(circle)).toEqual([\n+â”Š   â”Š 75â”Š          { x: -2, y: 5 }\n+â”Š   â”Š 76â”Š        ]);\n+â”Š   â”Š 77â”Š      });\n+â”Š   â”Š 78â”Š    });\n+â”Š   â”Š 79â”Š\n+â”Š   â”Š 80â”Š    describe(\"given kissing circle\", function() {\n+â”Š   â”Š 81â”Š      it(\"returns array with intersection point\", function() {\n+â”Š   â”Š 82â”Š        let circle = new Engine.Geometry.Circle(-9, 1, 5, 0, 2 * Math.PI);\n+â”Š   â”Š 83â”Š\n+â”Š   â”Š 84â”Š        expect(this.circle.getCircleIntersection(circle)).toEqual([\n+â”Š   â”Š 85â”Š          { x: -4, y: 1 }\n+â”Š   â”Š 86â”Š        ]);\n+â”Š   â”Š 87â”Š      });\n+â”Š   â”Š 88â”Š    });\n+â”Š   â”Š 89â”Š\n+â”Š   â”Š 90â”Š    describe(\"given outer circle\", function() {\n+â”Š   â”Š 91â”Š      it(\"returns nothing\", function() {\n+â”Š   â”Š 92â”Š        let circle = new Engine.Geometry.Circle(10, 10, 2, 0, 2 * Math.PI);\n+â”Š   â”Š 93â”Š        expect(this.circle.getCircleIntersection(circle)).toBeUndefined();\n+â”Š   â”Š 94â”Š      });\n+â”Š   â”Š 95â”Š    });\n+â”Š   â”Š 96â”Š\n+â”Š   â”Š 97â”Š    describe(\"given inner circle\", function() {\n+â”Š   â”Š 98â”Š      it(\"nothing\", function() {\n+â”Š   â”Š 99â”Š        let circle = new Engine.Geometry.Circle(1, 1, 2, 0, 2 * Math.PI);\n+â”Š   â”Š100â”Š        expect(this.circle.getCircleIntersection(circle)).toBeUndefined();\n+â”Š   â”Š101â”Š      });\n+â”Š   â”Š102â”Š    });\n+â”Š   â”Š103â”Š  });\n+â”Š   â”Š104â”Š\n+â”Š   â”Š105â”Š  describe(\"getLineIntersection method\", function() {\n+â”Š   â”Š106â”Š    describe(\"given line with 2 intersection points\", function() {\n+â”Š   â”Š107â”Š      it(\"returns array with intersection points\", function() {\n+â”Š   â”Š108â”Š        let line = new Engine.Geometry.Line(-10, 1, 10, 1);\n+â”Š   â”Š109â”Š\n+â”Š   â”Š110â”Š        expect(this.circle.getLineIntersection(line)).toEqual([\n+â”Š   â”Š111â”Š          { x: 6, y: 1 },\n+â”Š   â”Š112â”Š          { x: -4, y: 1 }\n+â”Š   â”Š113â”Š        ]);\n+â”Š   â”Š114â”Š      });\n+â”Š   â”Š115â”Š    });\n+â”Š   â”Š116â”Š\n+â”Š   â”Š117â”Š    describe(\"given line with 1 intersection point\", function() {\n+â”Š   â”Š118â”Š      it(\"returns array with intersection point\", function() {\n+â”Š   â”Š119â”Š        let line = new Engine.Geometry.Line(-10, 1, 1, 1);\n+â”Š   â”Š120â”Š\n+â”Š   â”Š121â”Š        expect(this.circle.getLineIntersection(line)).toEqual([\n+â”Š   â”Š122â”Š          { x: -4, y: 1 }\n+â”Š   â”Š123â”Š        ]);\n+â”Š   â”Š124â”Š      });\n+â”Š   â”Š125â”Š    });\n+â”Š   â”Š126â”Š\n+â”Š   â”Š127â”Š    describe(\"given kissing line\", function() {\n+â”Š   â”Š128â”Š      it(\"returns array with intersection point\", function() {\n+â”Š   â”Š129â”Š        let line = new Engine.Geometry.Line(-10, 6, 10, 6);\n+â”Š   â”Š130â”Š\n+â”Š   â”Š131â”Š        expect(this.circle.getLineIntersection(line)).toEqual([\n+â”Š   â”Š132â”Š          { x: 1, y: 6 }\n+â”Š   â”Š133â”Š        ]);\n+â”Š   â”Š134â”Š      });\n+â”Š   â”Š135â”Š    });\n+â”Š   â”Š136â”Š\n+â”Š   â”Š137â”Š    describe(\"given outranged line\", function() {\n+â”Š   â”Š138â”Š      it(\"returns nothing\", function() {\n+â”Š   â”Š139â”Š        let line = new Engine.Geometry.Line(-10, 10, 10, 10);\n+â”Š   â”Š140â”Š        expect(this.circle.getLineIntersection(line)).toBeUndefined();\n+â”Š   â”Š141â”Š      });\n+â”Š   â”Š142â”Š    });\n+â”Š   â”Š143â”Š  });\n+â”Š   â”Š144â”Š});ðŸš«â†µ\n```\n\n##### Changed views&#x2F;spec_runner.html\n```diff\n@@ -19,9 +19,11 @@\n â”Š19â”Š19â”Š    <script type=\"text/javascript\" src=\"scripts/utils.js\"></script>\n â”Š20â”Š20â”Š    <script type=\"text/javascript\" src=\"scripts/namespaces.js\"></script>\n â”Š21â”Š21â”Š    <script type=\"text/javascript\" src=\"scripts/engine/geometry/line.js\"></script>\n+â”Š  â”Š22â”Š    <script type=\"text/javascript\" src=\"scripts/engine/geometry/circle.js\"></script>\n â”Š22â”Š23â”Š\n â”Š23â”Š24â”Š    <!-- Specs -->\n â”Š24â”Š25â”Š    <script type=\"text/javascript\" src=\"scripts/specs/engine/geometry/line.js\"></script>\n+â”Š  â”Š26â”Š    <script type=\"text/javascript\" src=\"scripts/specs/engine/geometry/circle.js\"></script>\n â”Š25â”Š27â”Š  </head>\n â”Š26â”Š28â”Š\n â”Š27â”Š29â”Š  <body>\n```\n\n[}]: #\n\nOur final shape in the geometry module would be a polygon. Why a polygon? Since I'm planning to make the snake's movement circular, which means that once the snake hits a random boundary, he will reappear from the other side of the canvas. The collision detection between the snake and the canvas would be done using a polygon - which is simply made out of 4 lines:\n\n[{]: <helper> (diffStep 5.1)\n\n#### [Step 5.1: Create utilities module](https://github.com/DAB0mB/radial-snake/commit/58ae99a)\n\n##### Added resources&#x2F;scripts&#x2F;utils.js\n```diff\n@@ -0,0 +1,68 @@\n+â”Š  â”Š 1â”Š// A wrapper function for our utilities which will enable chaining\n+â”Š  â”Š 2â”Š// e.g. Utils().mod().trim().isBetween()...\n+â”Š  â”Š 3â”ŠUtils = function Utils(context) {\n+â”Š  â”Š 4â”Š  const chain = {};\n+â”Š  â”Š 5â”Š\n+â”Š  â”Š 6â”Š  Object.keys(Utils).forEach((utilName) => {\n+â”Š  â”Š 7â”Š    chain[utilName] = (...args) => {\n+â”Š  â”Š 8â”Š      const result = Utils[utilName](context, ...args);\n+â”Š  â”Š 9â”Š      return Utils(result);\n+â”Š  â”Š10â”Š    };\n+â”Š  â”Š11â”Š  });\n+â”Š  â”Š12â”Š\n+â”Š  â”Š13â”Š  // Returns the result of the chaining\n+â”Š  â”Š14â”Š  chain.value = () => context;\n+â”Š  â”Š15â”Š\n+â”Š  â”Š16â”Š  return chain;\n+â”Š  â”Š17â”Š};\n+â”Š  â”Š18â”Š\n+â”Š  â”Š19â”Š// Fixed modulo method which can calculate modulo of negative numbers properly\n+â”Š  â”Š20â”Š// e.g. (-803).mod(800) returns 797\n+â”Š  â”Š21â”ŠUtils.mod = function (context, num) {\n+â”Š  â”Š22â”Š  return ((context % num) + num) % num;\n+â”Š  â”Š23â”Š};\n+â”Š  â”Š24â”Š\n+â”Š  â”Š25â”Š// Trims number and leaves the number of decimals specified.\n+â”Š  â”Š26â”Š// The \"mode\" argument specifies which math function should be invoked\n+â”Š  â”Š27â”Š// right after the number has been trimmed.\n+â”Š  â”Š28â”Š// e.g. 12.12345.trim(3, \"ceil\") returns 12.124\n+â”Š  â”Š29â”ŠUtils.trim = function (context, decimals, mode = \"round\") {\n+â”Š  â”Š30â”Š  return Math[mode](context * Math.pow(10, decimals)) / Math.pow(10, decimals);\n+â”Š  â”Š31â”Š};\n+â”Š  â”Š32â”Š\n+â”Š  â”Š33â”Š// Tells if number is in specified range based on given precision.\n+â”Š  â”Š34â”Š// See the \"compare\" method for more information about precision\n+â”Š  â”Š35â”ŠUtils.isBetween = function (context, num1, num2, precision) {\n+â”Š  â”Š36â”Š  return Utils.compare(context, Math.min(num1, num2), \">=\", precision) &&\n+â”Š  â”Š37â”Š         Utils.compare(context, Math.max(num1, num2), \"<=\", precision);\n+â”Š  â”Š38â”Š};\n+â”Š  â”Š39â”Š\n+â”Š  â”Š40â”Š// Initiates comparison operator between context number and a given number, only here\n+â”Š  â”Š41â”Š// a precision can be specified\n+â”Š  â”Š42â”ŠUtils.compare = function (context, num, method, precision = method) {\n+â”Š  â”Š43â”Š  switch (precision) {\n+â”Š  â”Š44â”Š    // Fixed precision, \"almost equal\" with a deviation of Îµ\n+â”Š  â”Š45â”Š    case \"f\":\n+â”Š  â”Š46â”Š      switch (method) {\n+â”Š  â”Š47â”Š        case \"<\": case \"<=\": return context <= num + Number.EPSILON;\n+â”Š  â”Š48â”Š        case \">\": case \">=\": return context >= num - Number.EPSILON;\n+â”Š  â”Š49â”Š        default: return Math.abs(context - num) <= Number.EPSILON;\n+â”Š  â”Š50â”Š      }\n+â”Š  â”Š51â”Š    // Pixel precision, round comparison\n+â”Š  â”Š52â”Š    case \"px\":\n+â”Š  â”Š53â”Š      switch (method) {\n+â”Š  â”Š54â”Š        case \"<\": case \"<=\": return Math.round(context) <= Math.round(num);\n+â”Š  â”Š55â”Š        case \">\": case \">=\": return Math.round(context) >= Math.round(num);\n+â”Š  â”Š56â”Š        default: return Math.round(context) == Math.round(num);\n+â”Š  â”Š57â”Š      }\n+â”Š  â”Š58â”Š    // Exact precision\n+â”Š  â”Š59â”Š    default:\n+â”Š  â”Š60â”Š      switch (method) {\n+â”Š  â”Š61â”Š        case \"<\": return context < num;\n+â”Š  â”Š62â”Š        case \"<=\": return context <= num;\n+â”Š  â”Š63â”Š        case \">\": return context > num;\n+â”Š  â”Š64â”Š        case \">=\": return context >= num;\n+â”Š  â”Š65â”Š        default: return context === num;\n+â”Š  â”Š66â”Š      }\n+â”Š  â”Š67â”Š  }\n+â”Š  â”Š68â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -8,6 +8,7 @@\n â”Š 8â”Š 8â”Š    <script type=\"text/javascript\" src=\"/libs/underscore.js\"></script>\n â”Š 9â”Š 9â”Š\n â”Š10â”Š10â”Š    <!-- Scripts -->\n+â”Š  â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/utils.js\"></script>\n â”Š11â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n â”Š12â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/restorable.js\"></script>\n â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/font.js\"></script>\n```\n\n[}]: #\n\nAgain we will delegate the newly created intersection methods in the `Line` class and `Circle` class:\n\n[{]: <helper> (diffStep 5.11)\n\n#### [Step 5.11: Delegate polygon intersection methods](https://github.com/DAB0mB/radial-snake/commit/d42a5d9)\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;geometry&#x2F;circle.js\n```diff\n@@ -83,6 +83,8 @@\n â”Š83â”Š83â”Š      return this.getLineIntersection(shape);\n â”Š84â”Š84â”Š    if (shape instanceof Engine.Geometry.Circle)\n â”Š85â”Š85â”Š      return this.getCircleIntersection(shape);\n+â”Š  â”Š86â”Š    if (shape instanceof Engine.Geometry.Polygon)\n+â”Š  â”Š87â”Š      return this.getPolygonIntersection(shape);\n â”Š86â”Š88â”Š  }\n â”Š87â”Š89â”Š\n â”Š88â”Š90â”Š  // circle - circle intersection method\n```\n```diff\n@@ -164,4 +166,9 @@\n â”Š164â”Š166â”Š\n â”Š165â”Š167â”Š    if (interPoints.length > 0) return interPoints;\n â”Š166â”Š168â”Š  }\n+â”Š   â”Š169â”Š\n+â”Š   â”Š170â”Š  // circle - polygon intersection method\n+â”Š   â”Š171â”Š  getPolygonIntersection(polygon) {\n+â”Š   â”Š172â”Š    return polygon.getCircleIntersection(this);\n+â”Š   â”Š173â”Š  }\n â”Š167â”Š174â”Š};ðŸš«â†µ\n```\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;geometry&#x2F;line.js\n```diff\n@@ -46,6 +46,8 @@\n â”Š46â”Š46â”Š      return this.getLineIntersection(shape);\n â”Š47â”Š47â”Š    if (shape instanceof Engine.Geometry.Circle)\n â”Š48â”Š48â”Š      return this.getCircleIntersection(shape);\n+â”Š  â”Š49â”Š    if (shape instanceof Engine.Geometry.Polygon)\n+â”Š  â”Š50â”Š      return this.getPolygonIntersection(shape);\n â”Š49â”Š51â”Š  }\n â”Š50â”Š52â”Š\n â”Š51â”Š53â”Š  // line - line intersection method\n```\n```diff\n@@ -69,4 +71,9 @@\n â”Š69â”Š71â”Š  getCircleIntersection(circle) {\n â”Š70â”Š72â”Š    return circle.getLineIntersection(this);\n â”Š71â”Š73â”Š  }\n+â”Š  â”Š74â”Š\n+â”Š  â”Š75â”Š  // line - polygon intersection method\n+â”Š  â”Š76â”Š  getPolygonIntersection(polygon) {\n+â”Š  â”Š77â”Š    return polygon.getLineIntersection(this);\n+â”Š  â”Š78â”Š  }\n â”Š72â”Š79â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nNow we will create a some tests to make sure our newly created polygon works properly:\n\n[{]: <helper> (diffStep 5.12)\n\n#### [Step 5.12: Create &#x27;Polygon&#x27; class tests](https://github.com/DAB0mB/radial-snake/commit/f3f890b)\n\n##### Added resources&#x2F;scripts&#x2F;specs&#x2F;engine&#x2F;geometry&#x2F;polygon.js\n```diff\n@@ -0,0 +1,96 @@\n+â”Š  â”Š 1â”Šdescribe(\"Engine.Geometry.Polygon class\", function() {\n+â”Š  â”Š 2â”Š  beforeEach(function() {\n+â”Š  â”Š 3â”Š    this.polygon = new Engine.Geometry.Polygon(\n+â”Š  â”Š 4â”Š      [0, 0, 5, 0],\n+â”Š  â”Š 5â”Š      [5, 0, 5, 5],\n+â”Š  â”Š 6â”Š      [5, 5, 0, 5],\n+â”Š  â”Š 7â”Š      [0, 5, 0, 0]\n+â”Š  â”Š 8â”Š    );\n+â”Š  â”Š 9â”Š  });\n+â”Š  â”Š10â”Š\n+â”Š  â”Š11â”Š  describe(\"hasPoint method\", function() {\n+â”Š  â”Š12â”Š    describe(\"given contained point\", function() {\n+â”Š  â”Š13â”Š      it(\"returns true\", function() {\n+â”Š  â”Š14â”Š        let x = 5;\n+â”Š  â”Š15â”Š        let y = 3;\n+â”Š  â”Š16â”Š        expect(this.polygon.hasPoint(x, y)).toBeTruthy();\n+â”Š  â”Š17â”Š      });\n+â”Š  â”Š18â”Š    });\n+â”Š  â”Š19â”Š\n+â”Š  â”Š20â”Š    describe(\"given outranged point\", function() {\n+â”Š  â”Š21â”Š      it(\"returns false\", function() {\n+â”Š  â”Š22â”Š        let x = 10;\n+â”Š  â”Š23â”Š        let y = 10;\n+â”Š  â”Š24â”Š        expect(this.polygon.hasPoint(x, y)).toBeFalsy();\n+â”Š  â”Š25â”Š      });\n+â”Š  â”Š26â”Š    });\n+â”Š  â”Š27â”Š  });\n+â”Š  â”Š28â”Š\n+â”Š  â”Š29â”Š  describe(\"getLineIntersection method\", function() {\n+â”Š  â”Š30â”Š    describe(\"given intersecting line\", function() {\n+â”Š  â”Š31â”Š      it(\"returns intersection point\", function() {\n+â”Š  â”Š32â”Š        let line = new Engine.Geometry.Line(0, 1, 5, 4);\n+â”Š  â”Š33â”Š\n+â”Š  â”Š34â”Š        expect(this.polygon.getLineIntersection(line)).toEqual([\n+â”Š  â”Š35â”Š          { x: 5, y: 4 },\n+â”Š  â”Š36â”Š          { x: 0, y: 1 }\n+â”Š  â”Š37â”Š        ]);\n+â”Š  â”Š38â”Š      });\n+â”Š  â”Š39â”Š    });\n+â”Š  â”Š40â”Š\n+â”Š  â”Š41â”Š    describe(\"given outranged line\", function() {\n+â”Š  â”Š42â”Š      it(\"returns nothing\", function() {\n+â”Š  â”Š43â”Š        let line = new Engine.Geometry.Line(10, 11, 15, 14);\n+â”Š  â”Š44â”Š\n+â”Š  â”Š45â”Š        expect(this.polygon.getLineIntersection(line)).toBeUndefined();\n+â”Š  â”Š46â”Š      });\n+â”Š  â”Š47â”Š    });\n+â”Š  â”Š48â”Š  });\n+â”Š  â”Š49â”Š\n+â”Š  â”Š50â”Š  describe(\"getCircleIntersection method\", function() {\n+â”Š  â”Š51â”Š    describe(\"given circle with 2 intersection points\", function() {\n+â”Š  â”Š52â”Š      it(\"returns array with intersection points\", function() {\n+â”Š  â”Š53â”Š        let circle = new Engine.Geometry.Circle(0, 0, 2, 0, 2 * Math.PI);\n+â”Š  â”Š54â”Š\n+â”Š  â”Š55â”Š        expect(this.polygon.getCircleIntersection(circle)).toEqual([\n+â”Š  â”Š56â”Š          { x: 2, y: 0 },\n+â”Š  â”Š57â”Š          { x: 0, y: 2 }\n+â”Š  â”Š58â”Š        ]);\n+â”Š  â”Š59â”Š      });\n+â”Š  â”Š60â”Š    });\n+â”Š  â”Š61â”Š\n+â”Š  â”Š62â”Š    describe(\"given circle with 1 intersection points\", function() {\n+â”Š  â”Š63â”Š      it(\"returns array with intersection point\", function() {\n+â”Š  â”Š64â”Š        let circle = new Engine.Geometry.Circle(0, 0, 2, 0, 0.25 * Math.PI);\n+â”Š  â”Š65â”Š\n+â”Š  â”Š66â”Š        expect(this.polygon.getCircleIntersection(circle)).toEqual([\n+â”Š  â”Š67â”Š          { x: 2, y: 0 }\n+â”Š  â”Š68â”Š        ]);\n+â”Š  â”Š69â”Š      });\n+â”Š  â”Š70â”Š    });\n+â”Š  â”Š71â”Š\n+â”Š  â”Š72â”Š    describe(\"given kissing circle\", function() {\n+â”Š  â”Š73â”Š      it(\"returns array with intersection point\", function() {\n+â”Š  â”Š74â”Š        let circle = new Engine.Geometry.Circle(-3, 3, 3, 0, 2 * Math.PI);\n+â”Š  â”Š75â”Š\n+â”Š  â”Š76â”Š        expect(this.polygon.getCircleIntersection(circle)).toEqual([\n+â”Š  â”Š77â”Š          { x: 0, y: 3 }\n+â”Š  â”Š78â”Š        ]);\n+â”Š  â”Š79â”Š      });\n+â”Š  â”Š80â”Š    });\n+â”Š  â”Š81â”Š\n+â”Š  â”Š82â”Š    describe(\"given outer circle\", function() {\n+â”Š  â”Š83â”Š      it(\"returns nothing\", function() {\n+â”Š  â”Š84â”Š        let circle = new Engine.Geometry.Circle(10, 10, 2, 0, 2 * Math.PI);\n+â”Š  â”Š85â”Š        expect(this.polygon.getCircleIntersection(circle)).toBeUndefined();\n+â”Š  â”Š86â”Š      });\n+â”Š  â”Š87â”Š    });\n+â”Š  â”Š88â”Š\n+â”Š  â”Š89â”Š    describe(\"given inner circle\", function() {\n+â”Š  â”Š90â”Š      it(\"nothing\", function() {\n+â”Š  â”Š91â”Š        let circle = new Engine.Geometry.Circle(2.5, 2.5, 2, 0, 2 * Math.PI);\n+â”Š  â”Š92â”Š        expect(this.polygon.getCircleIntersection(circle)).toBeUndefined();\n+â”Š  â”Š93â”Š      });\n+â”Š  â”Š94â”Š    });\n+â”Š  â”Š95â”Š  });\n+â”Š  â”Š96â”Š});ðŸš«â†µ\n```\n\n##### Changed views&#x2F;spec_runner.html\n```diff\n@@ -20,10 +20,12 @@\n â”Š20â”Š20â”Š    <script type=\"text/javascript\" src=\"scripts/namespaces.js\"></script>\n â”Š21â”Š21â”Š    <script type=\"text/javascript\" src=\"scripts/engine/geometry/line.js\"></script>\n â”Š22â”Š22â”Š    <script type=\"text/javascript\" src=\"scripts/engine/geometry/circle.js\"></script>\n+â”Š  â”Š23â”Š    <script type=\"text/javascript\" src=\"scripts/engine/geometry/polygon.js\"></script>\n â”Š23â”Š24â”Š\n â”Š24â”Š25â”Š    <!-- Specs -->\n â”Š25â”Š26â”Š    <script type=\"text/javascript\" src=\"scripts/specs/engine/geometry/line.js\"></script>\n â”Š26â”Š27â”Š    <script type=\"text/javascript\" src=\"scripts/specs/engine/geometry/circle.js\"></script>\n+â”Š  â”Š28â”Š    <script type=\"text/javascript\" src=\"scripts/specs/engine/geometry/polygon.js\"></script>\n â”Š27â”Š29â”Š  </head>\n â”Š28â”Š30â”Š\n â”Š29â”Š31â”Š  <body>\n```\n\n[}]: #\n\nAt last, all the necessary geometry shapes are implemented and ready to use. We will now focus on the snake itself. Since our game can potentially have infinite number of entities, not necessarily just a snake, we will add the a new module under the `Game` namespace called `Entities`:\n\n[{]: <helper> (diffStep 5.13)\n\n#### [Step 5.13: Add &#x27;Entities&#x27; module to &#x27;Game&#x27; namespace](https://github.com/DAB0mB/radial-snake/commit/a0bed8c)\n\n##### Changed resources&#x2F;scripts&#x2F;namespaces.js\n```diff\n@@ -1,4 +1,5 @@\n â”Š1â”Š1â”ŠGame = {\n+â”Š â”Š2â”Š  Entities: {},\n â”Š2â”Š3â”Š  Screens: {}\n â”Š3â”Š4â”Š};\n```\n\n[}]: #\n\nAnd now we can add the `Snake` class:\n\n[{]: <helper> (diffStep 5.14)\n\n#### [Step 5.14: Create &#x27;Snake&#x27; class](https://github.com/DAB0mB/radial-snake/commit/b938ba7)\n\n##### Added resources&#x2F;scripts&#x2F;game&#x2F;entities&#x2F;snake.js\n```diff\n@@ -0,0 +1,234 @@\n+â”Š   â”Š  1â”ŠGame.Entities.Snake = class Snake {\n+â”Š   â”Š  2â”Š  // Represents a snake data-structure which will eventually appear on screen.\n+â”Š   â”Š  3â”Š  // All the properties provided to the constructor are the initial values of\n+â”Š   â”Š  4â”Š  // the snake\n+â”Š   â”Š  5â”Š  constructor(x, y, r, rad, v, color, keyStates, options) {\n+â”Š   â”Š  6â”Š    this.x = x;\n+â”Š   â”Š  7â”Š    this.y = y;\n+â”Š   â”Š  8â”Š    this.r = r;\n+â”Š   â”Š  9â”Š    this.rad = rad;\n+â”Š   â”Š 10â”Š    this.v = v;\n+â”Š   â”Š 11â”Š    this.color = color;\n+â”Š   â”Š 12â”Š    this.keyStates = keyStates;\n+â”Š   â”Š 13â”Š    // A snake is made out of many geometry shapes\n+â”Š   â”Š 14â”Š    this.shapes = [];\n+â”Š   â”Š 15â”Š    // A snake starts with a line\n+â”Š   â”Š 16â”Š    this.currentShape = new Engine.Geometry.Line(x, y, x, y);\n+â”Š   â”Š 17â”Š    this.shapes.push(this.currentShape);\n+â”Š   â”Š 18â”Š    // A score can be provided in case we want to reserve previous scores from\n+â”Š   â”Š 19â”Š    // recent matches\n+â”Š   â”Š 20â”Š    this.score = options.score || 0;\n+â”Š   â”Š 21â”Š\n+â”Š   â”Š 22â”Š    // Custom keys can be specified\n+â”Š   â”Š 23â”Š    if (options.keys && options.keys) {\n+â”Š   â”Š 24â”Š      this.leftKey = options.keys.left;\n+â”Š   â”Š 25â”Š      this.rightKey = options.keys.right;\n+â”Š   â”Š 26â”Š    }\n+â”Š   â”Š 27â”Š    // Left and right arrow keys will be used by default\n+â”Š   â”Š 28â”Š    else {\n+â”Š   â”Š 29â”Š      this.leftKey = 37; // Left arrow\n+â”Š   â”Š 30â”Š      this.rightKey = 39; // Right arrow\n+â”Š   â”Š 31â”Š    }\n+â”Š   â”Š 32â”Š  }\n+â”Š   â”Š 33â”Š\n+â”Š   â”Š 34â”Š  draw(context) {\n+â”Š   â”Š 35â”Š    // Draw all shapes in the shapes array\n+â”Š   â”Š 36â”Š    this.shapes.forEach(shape => {\n+â”Š   â”Š 37â”Š      context.save();\n+â”Š   â”Š 38â”Š      context.strokeStyle = this.color;\n+â”Š   â”Š 39â”Š      context.lineWidth = 3;\n+â”Š   â”Š 40â”Š      context.beginPath();\n+â”Š   â”Š 41â”Š\n+â”Š   â”Š 42â”Š      // Each shape has its own unique drawing method\n+â”Š   â”Š 43â”Š      shape.draw(context);\n+â”Š   â”Š 44â”Š\n+â”Š   â”Š 45â”Š      context.stroke();\n+â”Š   â”Š 46â”Š      context.restore();\n+â”Š   â”Š 47â”Š    });\n+â”Š   â”Š 48â”Š  }\n+â”Š   â”Š 49â”Š\n+â”Š   â”Š 50â”Š  update(span, width, height) {\n+â”Š   â”Š 51â”Š    // Progress made based on elapsed time and velocity\n+â”Š   â”Š 52â”Š    let step = (this.v * span) / 1000;\n+â”Š   â”Š 53â”Š\n+â”Š   â”Š 54â”Š    this.updateShapes(step, width, height);\n+â”Š   â”Š 55â”Š    this.cycleThrough(step, width, height);\n+â”Š   â”Š 56â”Š  }\n+â”Š   â”Š 57â”Š\n+â”Š   â”Š 58â”Š  // Updates shapes array based on progress made\n+â”Š   â”Š 59â”Š  updateShapes(step, width, height, options = {}) {\n+â”Š   â”Š 60â”Š    this.updateCurrentShape(step, options);\n+â”Š   â”Š 61â”Š    this.updateDirection(step, options);\n+â”Š   â”Š 62â”Š  }\n+â”Š   â”Š 63â”Š\n+â”Š   â”Š 64â”Š  // Updates current shape\n+â”Š   â”Š 65â”Š  updateCurrentShape(step, options) {\n+â”Š   â”Š 66â”Š    if (this.currentShape instanceof Engine.Geometry.Line)\n+â”Š   â”Š 67â”Š      return this.updateCurrentLine(options);\n+â”Š   â”Š 68â”Š    if (this.currentShape instanceof Engine.Geometry.Circle)\n+â”Š   â”Š 69â”Š      return this.updateCurrentCircle(options);\n+â”Š   â”Š 70â”Š  }\n+â”Š   â”Š 71â”Š\n+â”Š   â”Š 72â”Š  // Updates current shape in case it is a line\n+â”Š   â”Š 73â”Š  updateCurrentLine(options) {\n+â”Š   â”Š 74â”Š    let lastX = options.lastX || this.x;\n+â”Š   â”Š 75â”Š    let lastY = options.lastY || this.y;\n+â”Š   â”Š 76â”Š    this.x = options.x || this.currentShape.x2;\n+â”Š   â”Š 77â”Š    this.y = options.y || this.currentShape.y2;\n+â”Š   â”Š 78â”Š    this.lastBit = new Engine.Geometry.Line(lastX, lastY, this.x, this.y);\n+â”Š   â”Š 79â”Š  }\n+â”Š   â”Š 80â”Š\n+â”Š   â”Š 81â”Š  // Updates current shape in case it is a circle\n+â”Š   â”Š 82â”Š  updateCurrentCircle(options) {\n+â”Š   â”Š 83â”Š    let lastX = options.lastX || this.currentShape.x;\n+â”Š   â”Š 84â”Š    let lastY = options.lastY || this.currentShape.y;\n+â”Š   â”Š 85â”Š    let lastR = options.lastR || this.currentShape.r;\n+â”Š   â”Š 86â”Š\n+â”Š   â”Š 87â”Š    // Update logic for left rotation\n+â”Š   â”Š 88â”Š    if (this.direction == \"left\") {\n+â”Š   â”Š 89â”Š      let lastRad = this.rad + (0.5 * Math.PI);\n+â”Š   â”Š 90â”Š      let currentShapePoint = this.currentShape.getPoint(this.currentShape.rad1);\n+â”Š   â”Š 91â”Š      this.x = options.x || currentShapePoint.x;\n+â”Š   â”Š 92â”Š      this.y = options.y || currentShapePoint.y;\n+â”Š   â”Š 93â”Š      this.rad = this.currentShape.rad1 - (0.5 * Math.PI);\n+â”Š   â”Š 94â”Š      this.lastBit = new Engine.Geometry.Circle(lastX, lastY, lastR, this.currentShape.rad1, lastRad);\n+â”Š   â”Š 95â”Š    }\n+â”Š   â”Š 96â”Š    // Update logic for right rotation\n+â”Š   â”Š 97â”Š    else {\n+â”Š   â”Š 98â”Š      let lastRad = this.rad - (0.5 * Math.PI);\n+â”Š   â”Š 99â”Š      let currentShapePoint = this.currentShape.getPoint(this.currentShape.rad2);\n+â”Š   â”Š100â”Š      this.x = options.x || currentShapePoint.x;\n+â”Š   â”Š101â”Š      this.y = options.y || currentShapePoint.y;\n+â”Š   â”Š102â”Š      this.rad = this.currentShape.rad2 + (0.5 * Math.PI);\n+â”Š   â”Š103â”Š      this.lastBit = new Engine.Geometry.Circle(lastX, lastY, lastR, lastRad, this.currentShape.rad2);\n+â”Š   â”Š104â”Š    }\n+â”Š   â”Š105â”Š  }\n+â”Š   â”Š106â”Š\n+â”Š   â”Š107â”Š  updateDirection(step, options) {\n+â”Š   â”Š108â”Š    // Update the direction based on pressed key\n+â”Š   â”Š109â”Š    if (this.keyStates.get(this.leftKey))\n+â”Š   â”Š110â”Š      var direction = \"left\";\n+â”Š   â”Š111â”Š    else if (this.keyStates.get(this.rightKey))\n+â”Š   â”Š112â”Š      var direction = \"right\";\n+â”Š   â”Š113â”Š\n+â”Š   â”Š114â”Š    this.changeDirection(step, direction, options);\n+â”Š   â”Š115â”Š    this.continueDirection(step, direction, options);\n+â”Š   â”Š116â”Š  }\n+â”Š   â”Š117â”Š\n+â”Š   â”Š118â”Š  // Change the recent shape type according to the given direction\n+â”Š   â”Š119â”Š  changeDirection(step, direction, options) {\n+â”Š   â”Š120â”Š    // If there is no change in direction, abort, unless we force it\n+â”Š   â”Š121â”Š    if (direction == this.direction && !options.force) return;\n+â”Š   â”Š122â”Š\n+â”Š   â”Š123â”Š    this.direction = direction;\n+â”Š   â”Š124â”Š\n+â”Š   â”Š125â”Š    // This will push a new shape with new properties, based on the direction\n+â”Š   â”Š126â”Š    switch (direction) {\n+â”Š   â”Š127â”Š      case \"left\":\n+â”Š   â”Š128â”Š        var angle = this.rad - (0.5 * Math.PI);\n+â”Š   â”Š129â”Š        var rad = this.rad + (0.5 * Math.PI);\n+â”Š   â”Š130â”Š        var x = this.x + (this.r * Math.cos(angle));\n+â”Š   â”Š131â”Š        var y = this.y + (this.r * Math.sin(angle));\n+â”Š   â”Š132â”Š        this.currentShape = new Engine.Geometry.Circle(x, y, this.r, rad, rad);\n+â”Š   â”Š133â”Š        break;\n+â”Š   â”Š134â”Š      case \"right\":\n+â”Š   â”Š135â”Š        angle = this.rad + (0.5 * Math.PI);\n+â”Š   â”Š136â”Š        rad = this.rad - (0.5 * Math.PI);\n+â”Š   â”Š137â”Š        x = this.x + (this.r * Math.cos(angle));\n+â”Š   â”Š138â”Š        y = this.y + (this.r * Math.sin(angle));\n+â”Š   â”Š139â”Š        this.currentShape = new Engine.Geometry.Circle(x, y, this.r, rad, rad);\n+â”Š   â”Š140â”Š        break;\n+â”Š   â”Š141â”Š      default:\n+â”Š   â”Š142â”Š        this.currentShape = new Engine.Geometry.Line(this.x, this.y, this.x, this.y);\n+â”Š   â”Š143â”Š    }\n+â”Š   â”Š144â”Š\n+â”Š   â”Š145â”Š    this.shapes.push(this.currentShape);\n+â”Š   â”Š146â”Š  }\n+â”Š   â”Š147â”Š\n+â”Š   â”Š148â”Š  // Extend the recent shape based on progress made\n+â”Š   â”Š149â”Š  continueDirection(step, direction) {\n+â”Š   â”Š150â”Š    switch (direction) {\n+â”Š   â”Š151â”Š      case \"left\":\n+â”Š   â”Š152â”Š        this.currentShape.rad1 -= step / this.r;\n+â”Š   â”Š153â”Š        break;\n+â”Š   â”Š154â”Š      case \"right\":\n+â”Š   â”Š155â”Š        this.currentShape.rad2 += step / this.r;\n+â”Š   â”Š156â”Š        break;\n+â”Š   â”Š157â”Š      default:\n+â”Š   â”Š158â”Š        this.currentShape.x2 += step * Math.cos(this.rad);\n+â”Š   â”Š159â”Š        this.currentShape.y2 += step * Math.sin(this.rad);\n+â”Š   â”Š160â”Š    }\n+â”Š   â”Š161â”Š  }\n+â”Š   â”Š162â”Š\n+â”Š   â”Š163â”Š  // Handles case where snake is out limits and we need to render it from\n+â”Š   â”Š164â”Š  // the other side of the canvas\n+â”Š   â”Š165â”Š  cycleThrough(step, width, height) {\n+â”Š   â”Š166â”Š    let intersectionPoint = this.getCanvasIntersection(width, height);\n+â”Š   â”Š167â”Š\n+â”Š   â”Š168â”Š    if (!intersectionPoint) return;\n+â”Š   â”Š169â”Š\n+â”Š   â”Š170â”Š    intersectionPoint = intersectionPoint[0];\n+â”Š   â”Š171â”Š\n+â”Š   â”Š172â”Š    // Re-calculate position based on canvas bounds\n+â”Š   â”Š173â”Š    if (intersectionPoint.x % width == 0)\n+â”Š   â”Š174â”Š      this.x = Utils.mod(this.x - width, width);\n+â”Š   â”Š175â”Š    if (intersectionPoint.y % height == 0)\n+â”Š   â”Š176â”Š      this.y = Utils.mod(this.y - height, height);\n+â”Š   â”Š177â”Š\n+â”Š   â”Š178â”Š    // Update shapes again based on custom properties\n+â”Š   â”Š179â”Š    this.updateShapes(step, width, height, {\n+â”Š   â”Š180â”Š      force: true,\n+â”Š   â”Š181â”Š      lastX: this.x,\n+â”Š   â”Š182â”Š      lastY: this.y,\n+â”Š   â”Š183â”Š      x: this.x,\n+â”Š   â”Š184â”Š      y: this.y\n+â”Š   â”Š185â”Š    });\n+â”Š   â”Š186â”Š  }\n+â”Š   â”Š187â”Š\n+â”Š   â”Š188â”Š  // Gets intersection points between last bit and own shapes\n+â”Š   â”Š189â”Š  getSelfIntersection() {\n+â”Š   â”Š190â”Š    if (this.currentShape instanceof Engine.Geometry.Circle &&\n+â”Š   â”Š191â”Š       Math.abs(this.currentShape.rad1 - this.currentShape.rad2) >= 2 * Math.PI) {\n+â”Š   â”Š192â”Š      if (this.direction == \"left\")\n+â”Š   â”Š193â”Š        var rad = this.currentShape.rad1;\n+â”Š   â”Š194â”Š      else\n+â”Š   â”Š195â”Š        var rad = this.currentShape.rad2;\n+â”Š   â”Š196â”Š\n+â”Š   â”Š197â”Š      return this.currentShape.getPoint(rad);\n+â”Š   â”Š198â”Š    }\n+â”Š   â”Š199â”Š\n+â”Š   â”Š200â”Š    let result;\n+â”Š   â”Š201â”Š\n+â”Š   â”Š202â”Š    this.shapes.slice(0, -2).some(shape =>\n+â”Š   â”Š203â”Š      result = this.lastBit.getIntersection(shape)\n+â”Š   â”Š204â”Š    );\n+â”Š   â”Š205â”Š\n+â”Š   â”Š206â”Š    return result;\n+â”Š   â”Š207â”Š  }\n+â”Š   â”Š208â”Š\n+â”Š   â”Š209â”Š  // Returns intersection points between snakes\n+â”Š   â”Š210â”Š  getSnakeIntersection(snake) {\n+â”Š   â”Š211â”Š    let result;\n+â”Š   â”Š212â”Š\n+â”Š   â”Š213â”Š    snake.shapes.some(shape =>\n+â”Š   â”Š214â”Š      // Only last bit is relevant, if we reached this point it means that\n+â”Š   â”Š215â”Š      // previous intersection will definitely fail\n+â”Š   â”Š216â”Š      result = this.lastBit.getIntersection(shape)\n+â”Š   â”Š217â”Š    );\n+â”Š   â”Š218â”Š\n+â”Š   â”Š219â”Š    return result;\n+â”Š   â”Š220â”Š  }\n+â”Š   â”Š221â”Š\n+â”Š   â”Š222â”Š  // Returns intersection points between snake and canvas\n+â”Š   â”Š223â”Š  getCanvasIntersection(width, height) {\n+â”Š   â”Š224â”Š    // Canvas polygon\n+â”Š   â”Š225â”Š    let canvasPolygon = new Engine.Geometry.Polygon(\n+â”Š   â”Š226â”Š      [0, 0, width, 0],\n+â”Š   â”Š227â”Š      [width, 0, width, height],\n+â”Š   â”Š228â”Š      [width, height, 0, height],\n+â”Š   â”Š229â”Š      [0, height, 0, 0]\n+â”Š   â”Š230â”Š    );\n+â”Š   â”Š231â”Š\n+â”Š   â”Š232â”Š    return canvasPolygon.getIntersection(this.lastBit);\n+â”Š   â”Š233â”Š  }\n+â”Š   â”Š234â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -22,6 +22,7 @@\n â”Š22â”Š22â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/screen.js\"></script>\n â”Š23â”Š23â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/assets_loader.js\"></script>\n â”Š24â”Š24â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n+â”Š  â”Š25â”Š    <script type=\"text/javascript\" src=\"/scripts/game/entities/snake.js\"></script>\n â”Š25â”Š26â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/menu/index.js\"></script>\n â”Š26â”Š27â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/splash/index.js\"></script>\n â”Š27â”Š28â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n```\n\n[}]: #\n\nThis class is titled with most complexity out of everything we did so far in this step. You can follow the code accompanied by comments regard it, but I'd also like to explain the key concepts. As said earlier, the `Snake` is simply made out of shapes; In this case - lines and circles.\n\nThe `draw` method just goes through this array and draws whatever shape it's currently looping through. Regardless of its type, every shape is provided with a `draw` method of its own, all shapes share the same interface, therefore we can just draw them regularly and the snake should be drawn automatically.\n\nThe `update` method updates the last bit only according to its type, the time elapsed and the speed of the snake. For example, the last bit of the snake is a line, and 5 seconds have passed at a speed of 5 meters per second, our line should be extended by 5 meters long. Same principle applies to circle extension only based on radians. The last bit's type might be changed according to the current input; e.g. if the `right` key is held the last bit would turn into a circle, and once released it would turn into a straight line.\n\nNote that besides shapes extension, collision detection should also be made. The embedded is the collision detection between the snake and the canvas, which means that any time the snake collides with the canvas's boundaries the last bit should be redrawn from the opposite side of the canvas. In addition, we've implemented intersection methods for self collision detection and collision detection between rivals, which should be used externally by the hosting screen.\n\nIn the next step we will be implementing the game screen where we will make use of the `Snake` class we've just created, and see how it works in action."
          },
          {
            "manualTitle": "Step 6: Creating a complex game screen with multiple layers",
            "stepRevision": "c27bb0d7806aab70ec489ccd9bbff182d1053dda",
            "manualView": "![snake-demo-game-small](https://cloud.githubusercontent.com/assets/7648874/21074124/8b7cd724-bed7-11e6-9f91-2a211630ac78.gif)\n\nIn this step we will be using the `Snake` class we've just created in the previous step to form the actual game screen - called the `Play` screen. The play screen is a complex screen made out multiple layers as following:\n\n- **`Ready` layer** - Displays a message at the beginning of each match.\n- **`Snake` layer** - Displays the the competitors' snakes.\n- **`Score` layer** - Displays the score board.\n- **`Win` layer** - Displays the winner at the end of each match.\n\nAs we go further with this step, we will give a deeper explanation about each layer and how they interact with each other; As for let's start with the `Play` screen's basis. Regardless of what the `Play` screen should contain at the final result, we want to have the ability to abort the match whenever we press the `Escape` key, therefore, the initial implementation should look like this:\n\n[{]: <helper> (diffStep 6.1)\n\n#### [Step 6.1: Create &#x27;Play&#x27; screen](https://github.com/DAB0mB/radial-snake/commit/e17a45f)\n\n##### Added resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;play&#x2F;index.js\n```diff\n@@ -0,0 +1,14 @@\n+â”Š  â”Š 1â”ŠGame.Screens.Play = class Play extends Engine.Screen {\n+â”Š  â”Š 2â”Š  get events() {\n+â”Š  â”Š 3â”Š    return {\n+â”Š  â”Š 4â”Š      \"keydown\": \"onKeyDown\"\n+â”Š  â”Š 5â”Š    }\n+â”Š  â”Š 6â”Š  }\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Š  onKeyDown() {\n+â”Š  â”Š 9â”Š    // Once escape is pressed, return to main menu screen\n+â”Š  â”Š10â”Š    if (this.keyStates.get(27)) {\n+â”Š  â”Š11â”Š      this.game.changeScreen(Game.Screens.Menu);\n+â”Š  â”Š12â”Š    }\n+â”Š  â”Š13â”Š  }\n+â”Š  â”Š14â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -23,6 +23,7 @@\n â”Š23â”Š23â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/assets_loader.js\"></script>\n â”Š24â”Š24â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š25â”Š25â”Š    <script type=\"text/javascript\" src=\"/scripts/game/entities/snake.js\"></script>\n+â”Š  â”Š26â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/index.js\"></script>\n â”Š26â”Š27â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/menu/index.js\"></script>\n â”Š27â”Š28â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/splash/index.js\"></script>\n â”Š28â”Š29â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n```\n\n[}]: #\n\nNow that we have the `Play` screen, we need to hook it to the `Menu` screen, so whenever we press a key, we will be proceeded to it:\n\n[{]: <helper> (diffStep 6.2)\n\n#### [Step 6.2: Hook &#x27;Play&#x27; screen to &#x27;menu&#x27; screen](https://github.com/DAB0mB/radial-snake/commit/495b9ee)\n\n##### Changed resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;menu&#x2F;index.js\n```diff\n@@ -1,4 +1,10 @@\n â”Š 1â”Š 1â”ŠGame.Screens.Menu = class Menu extends Engine.Screen {\n+â”Š  â”Š 2â”Š  get events() {\n+â”Š  â”Š 3â”Š    return {\n+â”Š  â”Š 4â”Š      \"keydown\": \"onKeyDown\"\n+â”Š  â”Š 5â”Š    }\n+â”Š  â”Š 6â”Š  }\n+â”Š  â”Š 7â”Š\n â”Š 2â”Š 8â”Š  initialize() {\n â”Š 3â”Š 9â”Š    // Initialize snake logo sprite\n â”Š 4â”Š10â”Š    this.logoSprite = new Engine.Sprite(this.assets.logoTexture);\n```\n```diff\n@@ -40,10 +46,18 @@\n â”Š40â”Š46â”Š  }\n â”Š41â”Š47â”Š\n â”Š42â”Š48â”Š  update(span) {\n-â”Š43â”Š  â”Š    this.instructionsAnim.update(span);\n+â”Š  â”Š49â”Š    // On key press, proceed to play screen\n+â”Š  â”Š50â”Š    if (this.keyPressed) {\n+â”Š  â”Š51â”Š      this.game.changeScreen(Game.Screens.Play);\n+â”Š  â”Š52â”Š    }\n+â”Š  â”Š53â”Š    // Else, just update animation\n+â”Š  â”Š54â”Š    else {\n+â”Š  â”Š55â”Š      this.instructionsAnim.update(span);\n+â”Š  â”Š56â”Š    }\n â”Š44â”Š57â”Š  }\n â”Š45â”Š58â”Š\n-â”Š46â”Š  â”Š  update(span) {\n-â”Š47â”Š  â”Š    this.instructionsAnim.update(span);\n+â”Š  â”Š59â”Š  // Register key press\n+â”Š  â”Š60â”Š  onKeyDown(e) {\n+â”Š  â”Š61â”Š    this.keyPressed = true;\n â”Š48â”Š62â”Š  }\n â”Š49â”Š63â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nBy now there shouldn't be anything special. Once you're at the main menu, just press a key as instructed, and you shall see a black screen, which is actually the `Play` screen we've just created; And once you'll press the `Escape` key, you should be receded to the main menu.\n\nThe next stage would be displaying a `Ready` message on the screen, and whenever a key is pressed, the message should fade away using a key-frame animation, and the match should start in the background:\n\n[{]: <helper> (diffStep 6.3)\n\n#### [Step 6.3: Create &#x27;Ready&#x27; layer](https://github.com/DAB0mB/radial-snake/commit/551962d)\n\n##### Added resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;play&#x2F;ready.js\n```diff\n@@ -0,0 +1,59 @@\n+â”Š  â”Š 1â”ŠGame.Screens.Play.Ready = class Ready extends Engine.Layer {\n+â”Š  â”Š 2â”Š  get events() {\n+â”Š  â”Š 3â”Š    return {\n+â”Š  â”Š 4â”Š      \"keydown\": \"onKeyDown\"\n+â”Š  â”Š 5â”Š    };\n+â”Š  â”Š 6â”Š  }\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Š  constructor(screen, snakes) {\n+â”Š  â”Š 9â”Š    super(screen);\n+â”Š  â”Š10â”Š\n+â”Š  â”Š11â”Š    this.snakes = snakes;\n+â”Š  â”Š12â”Š\n+â”Š  â”Š13â”Š    // Create \"ready\" sprite and set its properties\n+â”Š  â”Š14â”Š    let readyTexture = this.assets.minecraftiaFont.createTexture(\"Ready\");\n+â”Š  â”Š15â”Š    let readySprite = new Engine.Sprite(readyTexture);\n+â”Š  â”Š16â”Š    readySprite.align = \"center\";\n+â”Š  â”Š17â”Š    readySprite.setPercentage(\"width\", this.width, 15, \"height\");\n+â”Š  â”Š18â”Š\n+â”Š  â”Š19â”Š    // Create fade out animation for \"ready\" sprite\n+â”Š  â”Š20â”Š    this.readyAnim = new Engine.Animations.Keyframe(readySprite, [\n+â”Š  â”Š21â”Š      {\n+â”Š  â”Š22â”Š        x: this.width / 2,\n+â”Š  â”Š23â”Š        y: this.height / 2,\n+â”Š  â”Š24â”Š        opacity: 1,\n+â”Š  â”Š25â”Š        frame: 0\n+â”Š  â”Š26â”Š      },\n+â”Š  â”Š27â”Š      {\n+â”Š  â”Š28â”Š        y: this.height / 3,\n+â”Š  â”Š29â”Š        opacity: 0,\n+â”Š  â”Š30â”Š        frame: 700\n+â”Š  â”Š31â”Š      }\n+â”Š  â”Š32â”Š    ]);\n+â”Š  â”Š33â”Š  }\n+â”Š  â”Š34â”Š\n+â”Š  â”Š35â”Š  draw(context) {\n+â”Š  â”Š36â”Š    this.readyAnim.draw(context);\n+â”Š  â”Š37â”Š  }\n+â”Š  â”Š38â”Š\n+â”Š  â”Š39â”Š  update(span) {\n+â”Š  â”Š40â”Š    if (!this.ready) return;\n+â”Š  â”Š41â”Š\n+â”Š  â”Š42â”Š    if (this.readyAnim.playing) {\n+â”Š  â”Š43â”Š      this.readyAnim.update(span);\n+â”Š  â”Š44â”Š    }\n+â”Š  â”Š45â”Š    // Once animation is finished, dispose layer\n+â”Š  â”Š46â”Š    else {\n+â”Š  â”Š47â”Š      this.screen.removeLayer(this);\n+â”Š  â”Š48â”Š    }\n+â”Š  â”Š49â”Š  }\n+â”Š  â”Š50â”Š\n+â”Š  â”Š51â”Š  onKeyDown() {\n+â”Š  â”Š52â”Š    // One time event\n+â”Š  â”Š53â”Š    this.disposeEventListeners()\n+â”Š  â”Š54â”Š\n+â”Š  â”Š55â”Š    // This will start playing the animation\n+â”Š  â”Š56â”Š    this.ready = true;\n+â”Š  â”Š57â”Š    this.readyAnim.play();\n+â”Š  â”Š58â”Š  }\n+â”Š  â”Š59â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -24,6 +24,7 @@\n â”Š24â”Š24â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š25â”Š25â”Š    <script type=\"text/javascript\" src=\"/scripts/game/entities/snake.js\"></script>\n â”Š26â”Š26â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/index.js\"></script>\n+â”Š  â”Š27â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/ready.js\"></script>\n â”Š27â”Š28â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/menu/index.js\"></script>\n â”Š28â”Š29â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/splash/index.js\"></script>\n â”Š29â”Š30â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n```\n\n[}]: #\n\nIn order to hook the `Ready` layer to the `Play` screen, we will just push a new instance of it to the layers stack, using the screen's `appendLayer` method. Note that the order of the layer is super critic! Since if we push a new layer it means it will be drawn on top of any previous layer. To \"shift\" a layer to the layers stack, we can simply use the `prependLayer` method instead. Without further due, this is how our hook should look like:\n\n[{]: <helper> (diffStep 6.4)\n\n#### [Step 6.4: Hook &#x27;Ready&#x27; layer to &#x27;Play&#x27; screen](https://github.com/DAB0mB/radial-snake/commit/b461464)\n\n##### Changed resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;play&#x2F;index.js\n```diff\n@@ -5,6 +5,11 @@\n â”Š 5â”Š 5â”Š    }\n â”Š 6â”Š 6â”Š  }\n â”Š 7â”Š 7â”Š\n+â”Š  â”Š 8â”Š  // The ready screen will be the initial screen\n+â”Š  â”Š 9â”Š  initialize(game, snakes) {\n+â”Š  â”Š10â”Š    this.appendLayer(Game.Screens.Play.Ready, snakes);\n+â”Š  â”Š11â”Š  }\n+â”Š  â”Š12â”Š\n â”Š 8â”Š13â”Š  onKeyDown() {\n â”Š 9â”Š14â”Š    // Once escape is pressed, return to main menu screen\n â”Š10â”Š15â”Š    if (this.keyStates.get(27)) {\n```\n\n[}]: #\n\nNow if you'll launch the game and start a new match, you should see a white `Ready` message in the middle of the screen. Up next, would be the `Snake` layer, which will simply initialize 2 new `Snake` instances, and take care of drawing and updating them:\n\n[{]: <helper> (diffStep 6.5)\n\n#### [Step 6.5: Create &#x27;snake&#x27; layer](https://github.com/DAB0mB/radial-snake/commit/a36d7f2)\n\n##### Added resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;play&#x2F;snake.js\n```diff\n@@ -0,0 +1,79 @@\n+â”Š  â”Š 1â”ŠGame.Screens.Play.Snake = class Snake extends Engine.Layer {\n+â”Š  â”Š 2â”Š  constructor(screen, snakes = []) {\n+â”Š  â”Š 3â”Š    super(screen);\n+â”Š  â”Š 4â”Š\n+â”Š  â”Š 5â”Š    // Red snake\n+â”Š  â”Š 6â”Š    this.snakes = [\n+â”Š  â”Š 7â”Š      new Game.Entities.Snake(\n+â”Š  â”Š 8â”Š        this.width / 4,\n+â”Š  â”Š 9â”Š        this.height / 4,\n+â”Š  â”Š10â”Š        50,\n+â”Š  â”Š11â”Š        Math.PI / 4,\n+â”Š  â”Š12â”Š        100,\n+â”Š  â”Š13â”Š        \"FireBrick\",\n+â”Š  â”Š14â”Š        this.keyStates,\n+â”Š  â”Š15â”Š        {\n+â”Š  â”Š16â”Š          // Use score from previous matches\n+â”Š  â”Š17â”Š          score: snakes[0] && snakes[0].score,\n+â”Š  â”Š18â”Š          keys: {\n+â”Š  â”Š19â”Š            left: 37, // Left key\n+â”Š  â”Š20â”Š            right: 39 // RIght key\n+â”Š  â”Š21â”Š        }\n+â”Š  â”Š22â”Š      }),\n+â”Š  â”Š23â”Š\n+â”Š  â”Š24â”Š      // Blue snake\n+â”Š  â”Š25â”Š      new Game.Entities.Snake(\n+â”Š  â”Š26â”Š        (this.width / 4) * 3,\n+â”Š  â”Š27â”Š        (this.height / 4) * 3,\n+â”Š  â”Š28â”Š        50,\n+â”Š  â”Š29â”Š        (-Math.PI / 4) * 3,\n+â”Š  â”Š30â”Š        100,\n+â”Š  â”Š31â”Š        \"DodgerBlue\",\n+â”Š  â”Š32â”Š        this.keyStates,\n+â”Š  â”Š33â”Š        {\n+â”Š  â”Š34â”Š          score: snakes[1] && snakes[1].score,\n+â”Š  â”Š35â”Š          keys: {\n+â”Š  â”Š36â”Š            left: 65, // 'a' key\n+â”Š  â”Š37â”Š            right: 68 // 'b' key\n+â”Š  â”Š38â”Š        }\n+â”Š  â”Š39â”Š      })\n+â”Š  â”Š40â”Š    ];\n+â”Š  â”Š41â”Š  }\n+â”Š  â”Š42â”Š\n+â”Š  â”Š43â”Š  draw(context) {\n+â”Š  â”Š44â”Š    // Draw each snake in the snakes array\n+â”Š  â”Š45â”Š    this.snakes.forEach(snake => snake.draw(context));\n+â”Š  â”Š46â”Š  }\n+â”Š  â”Š47â”Š\n+â”Š  â”Š48â”Š  update(span) {\n+â”Š  â”Š49â”Š    if (!this.snakes.length) return;\n+â”Š  â”Š50â”Š\n+â”Š  â”Š51â”Š    // Storing original snakes array for future use, since it might get changed\n+â”Š  â”Š52â”Š    let snakes = this.snakes.slice();\n+â”Š  â”Š53â”Š\n+â”Š  â”Š54â”Š    snakes.forEach((snake, index) => {\n+â”Š  â”Š55â”Š      snake.update(span, this.width, this.height);\n+â”Š  â”Š56â”Š      // Disqualify if intersected with self\n+â”Š  â”Š57â”Š      if (snake.getSelfIntersection()) return this.snakes.splice(index, 1);\n+â”Š  â”Š58â”Š\n+â”Š  â”Š59â”Š      snakes.forEach((opponent) => {\n+â”Š  â”Š60â”Š        // Don't scan for intersection with self, obviously this will always be true\n+â”Š  â”Š61â”Š        if (opponent === snake) return;\n+â”Š  â”Š62â”Š        // Disqualify if intersected with opponent\n+â”Š  â”Š63â”Š        if (snake.getSnakeIntersection(opponent)) this.snakes.splice(index, 1);\n+â”Š  â”Š64â”Š      });\n+â”Š  â”Š65â”Š    });\n+â”Š  â”Š66â”Š\n+â”Š  â”Š67â”Š    // There can be only one winner, or a tie (very rare, most likely not to happen)\n+â”Š  â”Š68â”Š    // If the match is already finished, skip the next steps since they are not relevant\n+â”Š  â”Š69â”Š    if (this.snakes.length > 1 || this.matchFinished) return;\n+â”Š  â”Š70â”Š\n+â”Š  â”Š71â”Š    // The winner is the \"last snake standing\"\n+â”Š  â”Š72â”Š    let winner = this.snakes[0];\n+â”Š  â”Š73â”Š    // If this is not a tie, which is a very rare case, increase the winner's score\n+â”Š  â”Š74â”Š    if (winner) winner.score++;\n+â”Š  â”Š75â”Š\n+â”Š  â”Š76â”Š    // Indicates whether we should update the score counter or not\n+â”Š  â”Š77â”Š    this.matchFinished = true;\n+â”Š  â”Š78â”Š  }\n+â”Š  â”Š79â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -24,6 +24,7 @@\n â”Š24â”Š24â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š25â”Š25â”Š    <script type=\"text/javascript\" src=\"/scripts/game/entities/snake.js\"></script>\n â”Š26â”Š26â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/index.js\"></script>\n+â”Š  â”Š27â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/snake.js\"></script>\n â”Š27â”Š28â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/ready.js\"></script>\n â”Š28â”Š29â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/menu/index.js\"></script>\n â”Š29â”Š30â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/splash/index.js\"></script>\n```\n\n[}]: #\n\nOnce pressing a key in the `Ready` layer, not only we want to display an animation, but we also want the match to start in the background, thus, we gonna push a new instance of the `Snake` layer we've just created like so:\n\n[{]: <helper> (diffStep 6.6)\n\n#### [Step 6.6: Hook &#x27;snake&#x27; layer to &#x27;ready&#x27; layer](https://github.com/DAB0mB/radial-snake/commit/982db7b)\n\n##### Changed resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;play&#x2F;ready.js\n```diff\n@@ -55,5 +55,8 @@\n â”Š55â”Š55â”Š    // This will start playing the animation\n â”Š56â”Š56â”Š    this.ready = true;\n â”Š57â”Š57â”Š    this.readyAnim.play();\n+â”Š  â”Š58â”Š\n+â”Š  â”Š59â”Š    // Start the game in the background\n+â”Š  â”Š60â”Š    this.screen.prependLayer(Game.Screens.Play.Snake, this.snakes);\n â”Š58â”Š61â”Š  }\n â”Š59â”Š62â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nNote that the layer is pushed when the animation starts and not once finished; This would give a nice smooth feeling to our game-flow. If you'll test out the game, you would discover that the match is actually playable! The first snake (Red) snake should be controlled by the arrow keys, and the second snake (Blue) should be controlled by the letter keys `a`, `s`, `d` and `w`. So far, the snakes function great, but you can probably tell that whenever a match is finished, it feels a bit dull. There's no indication of winning, and there's no score board to present the score of each competitor, which brings us to the next stage - Implementing the `Score` layer.\n\nThe `Score` layer is a simple layer which takes the 2 snakes as a parameter and displays their scores at the top of the screen:\n\n[{]: <helper> (diffStep 6.7)\n\n#### [Step 6.7: Create &#x27;Score&#x27; layer](https://github.com/DAB0mB/radial-snake/commit/6ec4cac)\n\n##### Added resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;play&#x2F;score.js\n```diff\n@@ -0,0 +1,66 @@\n+â”Š  â”Š 1â”ŠGame.Screens.Play.Score = class Score extends Engine.Layer {\n+â”Š  â”Š 2â”Š  constructor(screen, snakes) {\n+â”Š  â”Š 3â”Š    super(screen);\n+â”Š  â”Š 4â”Š\n+â”Š  â”Š 5â”Š    this.snakes = snakes;\n+â”Š  â”Š 6â”Š    this.scoreSprites = [];\n+â”Š  â”Š 7â”Š    this.scores = [];\n+â”Š  â”Š 8â”Š\n+â”Š  â”Š 9â”Š    // It's important to match indexes to each snake since the number of snakes\n+â”Š  â”Š10â”Š    // can be reduced along the way as we play\n+â”Š  â”Š11â”Š    snakes.forEach((snake, index) => {\n+â”Š  â”Š12â”Š      snake.index = index;\n+â”Š  â”Š13â”Š    });\n+â”Š  â”Š14â”Š  }\n+â”Š  â”Š15â”Š\n+â”Š  â”Š16â”Š  draw(context) {\n+â”Š  â”Š17â”Š    this.scoreSprites.forEach((scoreSprite) => {\n+â”Š  â”Š18â”Š      scoreSprite.draw(context);\n+â”Š  â”Š19â”Š    });\n+â”Š  â”Š20â”Š  }\n+â”Š  â”Š21â”Š\n+â”Š  â”Š22â”Š  update(span) {\n+â”Š  â”Š23â”Š    this.snakes.forEach(snake => {\n+â”Š  â”Š24â”Š      let index = snake.index;\n+â”Š  â”Š25â”Š      if (this.scores[index] == snake.score) return;\n+â”Š  â”Š26â”Š\n+â”Š  â”Š27â”Š      // The sprite might be changed along the way so it's important to recreate it\n+â”Š  â”Š28â”Š      // over and over again. If no change was made the cache will be used by the engine\n+â”Š  â”Š29â”Š      this.scoreSprites[index] = this.createScoreSprite(snake);\n+â”Š  â”Š30â”Š      this.scores[index] = snake.score;\n+â”Š  â”Š31â”Š    });\n+â”Š  â”Š32â”Š  }\n+â”Š  â”Š33â”Š\n+â”Š  â”Š34â”Š  createScoreSprite(snake) {\n+â”Š  â”Š35â”Š    let minecraftiaFont = this.assets.minecraftiaFont;\n+â”Š  â”Š36â”Š    minecraftiaFont.save();\n+â”Š  â”Š37â”Š    minecraftiaFont.color = snake.color;\n+â”Š  â”Š38â”Š\n+â”Š  â”Š39â”Š    // Create a score sprite for the snake\n+â”Š  â”Š40â”Š    let scoreTexture = minecraftiaFont.createTexture(`${snake.score}`, {\n+â”Š  â”Š41â”Š      noOffsets: true,\n+â”Š  â”Š42â”Š      noSpaces: true\n+â”Š  â”Š43â”Š    });\n+â”Š  â”Š44â”Š\n+â”Š  â”Š45â”Š    let scoreSprite = new Engine.Sprite(scoreTexture);\n+â”Š  â”Š46â”Š\n+â”Š  â”Š47â”Š    // Size of score board is dynamic to screen size\n+â”Š  â”Š48â”Š    scoreSprite.setPercentage(\"width\", this.width, 4, \"height\");\n+â”Š  â”Š49â”Š\n+â”Š  â”Š50â”Š    // Set alignment modes.\n+â”Š  â”Š51â”Š    // Once we add more snakes we should add more cases here\n+â”Š  â”Š52â”Š    switch (snake.index) {\n+â”Š  â”Š53â”Š      case 0:\n+â”Š  â”Š54â”Š        scoreSprite.align = \"top-left\";\n+â”Š  â”Š55â”Š        break;\n+â”Š  â”Š56â”Š      case 1:\n+â”Š  â”Š57â”Š        scoreSprite.align = \"top-right\";\n+â”Š  â”Š58â”Š        scoreSprite.x = this.width;\n+â”Š  â”Š59â”Š        break;\n+â”Š  â”Š60â”Š    }\n+â”Š  â”Š61â”Š\n+â”Š  â”Š62â”Š    // Restore the font to its original color\n+â”Š  â”Š63â”Š    minecraftiaFont.restore();\n+â”Š  â”Š64â”Š    return scoreSprite;\n+â”Š  â”Š65â”Š  }\n+â”Š  â”Š66â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -24,6 +24,7 @@\n â”Š24â”Š24â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š25â”Š25â”Š    <script type=\"text/javascript\" src=\"/scripts/game/entities/snake.js\"></script>\n â”Š26â”Š26â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/index.js\"></script>\n+â”Š  â”Š27â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/score.js\"></script>\n â”Š27â”Š28â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/snake.js\"></script>\n â”Š28â”Š29â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/ready.js\"></script>\n â”Š29â”Š30â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/menu/index.js\"></script>\n```\n\n[}]: #\n\n> Note that the current score board is suitable for two players, but can easily be modified to support as much players as you want if done correctly.\n\nThe `Score` board should be appended to the layers stack as soon as the `Snake` layers is initialized, so it would be available to us once the match is started:\n\n[{]: <helper> (diffStep 6.8)\n\n#### [Step 6.8: Hook &#x27;Score&#x27; layer to &#x27;Snake&#x27; layer](https://github.com/DAB0mB/radial-snake/commit/feb4a0b)\n\n##### Changed resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;play&#x2F;snake.js\n```diff\n@@ -38,6 +38,9 @@\n â”Š38â”Š38â”Š        }\n â”Š39â”Š39â”Š      })\n â”Š40â”Š40â”Š    ];\n+â”Š  â”Š41â”Š\n+â”Š  â”Š42â”Š    // Show score board for newly created snakes\n+â”Š  â”Š43â”Š    screen.appendLayer(Game.Screens.Play.Score, this.snakes);\n â”Š41â”Š44â”Š  }\n â”Š42â”Š45â”Š\n â”Š43â”Š46â”Š  draw(context) {\n```\n\n[}]: #\n\nNow we're one layer further from completing the `Play` screen, the only thing missing is the `Win` layer, which should present the winner once the match is finished:\n\n[{]: <helper> (diffStep 6.9)\n\n#### [Step 6.9: Create &#x27;Win&#x27; layer](https://github.com/DAB0mB/radial-snake/commit/3476384)\n\n##### Added resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;play&#x2F;win.js\n```diff\n@@ -0,0 +1,43 @@\n+â”Š  â”Š 1â”ŠGame.Screens.Play.Win = class Win extends Engine.Layer {\n+â”Š  â”Š 2â”Š  constructor(screen, snakes, winner) {\n+â”Š  â”Š 3â”Š    super(screen);\n+â”Š  â”Š 4â”Š\n+â”Š  â”Š 5â”Š    this.snakes = snakes;\n+â”Š  â”Š 6â”Š    this.winner = winner;\n+â”Š  â”Š 7â”Š    // ttl stands for \"time to live\", which means, this layer is going to be\n+â”Š  â”Š 8â”Š    // disposed after 3 seconds\n+â”Š  â”Š 9â”Š    this.ttl = 3000;\n+â”Š  â”Š10â”Š\n+â”Š  â”Š11â”Š    // If there is a winner\n+â”Š  â”Š12â”Š    if (this.winner) {\n+â”Š  â”Š13â”Š      // Message could be something like \"RED SNAKE WINS\"\n+â”Š  â”Š14â”Š      var text = `${this.winner.color.toUpperCase()} SNAKE WINS`;\n+â”Š  â”Š15â”Š      var percent = 40;\n+â”Š  â”Š16â”Š    }\n+â”Š  â”Š17â”Š    // If there is a tie\n+â”Š  â”Š18â”Š    else {\n+â”Š  â”Š19â”Š      var text = 'TIE';\n+â”Š  â”Š20â”Š      var percent = 15;\n+â”Š  â”Š21â”Š    }\n+â”Š  â”Š22â”Š\n+â”Š  â”Š23â”Š    // Create winner sprite and set its properties\n+â”Š  â”Š24â”Š    let winnerTexture = this.assets.minecraftiaFont.createTexture(text);\n+â”Š  â”Š25â”Š    this.winnerSprite = new Engine.Sprite(winnerTexture);\n+â”Š  â”Š26â”Š    this.winnerSprite.align = \"center\";\n+â”Š  â”Š27â”Š    this.winnerSprite.setPercentage(\"width\", this.width, percent, \"height\");\n+â”Š  â”Š28â”Š    this.winnerSprite.x = this.width / 2;\n+â”Š  â”Š29â”Š    this.winnerSprite.y = this.height / 2;\n+â”Š  â”Š30â”Š  }\n+â”Š  â”Š31â”Š\n+â”Š  â”Š32â”Š  draw(context) {\n+â”Š  â”Š33â”Š    this.winnerSprite.draw(context);\n+â”Š  â”Š34â”Š  }\n+â”Š  â”Š35â”Š\n+â”Š  â”Š36â”Š  update(span) {\n+â”Š  â”Š37â”Š    // If limit not yet reached, abort\n+â”Š  â”Š38â”Š    if (this.age < this.ttl) return;\n+â”Š  â”Š39â”Š\n+â”Š  â”Š40â”Š    // Show \"ready\" message all over again, only this time use the updated score board\n+â”Š  â”Š41â”Š    this.screen.game.changeScreen(Game.Screens.Play, this.snakes);\n+â”Š  â”Š42â”Š  }\n+â”Š  â”Š43â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -24,6 +24,7 @@\n â”Š24â”Š24â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š25â”Š25â”Š    <script type=\"text/javascript\" src=\"/scripts/game/entities/snake.js\"></script>\n â”Š26â”Š26â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/index.js\"></script>\n+â”Š  â”Š27â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/win.js\"></script>\n â”Š27â”Š28â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/score.js\"></script>\n â”Š28â”Š29â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/snake.js\"></script>\n â”Š29â”Š30â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/ready.js\"></script>\n```\n\n[}]: #\n\nNote how we use the `changeScreen` method once the `Win` layer has reached its age limit (Time to live, aka `ttl`); This would clear the layers stack and restart the `Play` screen, so we can start a new match all-over, only this time we will pass the `Snake` instances to reserve the original scores. The `Win` layer should be presented whenever a collision has been detected between the snakes:\n\n[{]: <helper> (diffStep 6.1)\n\n#### [Step 6.1: Create &#x27;Play&#x27; screen](https://github.com/DAB0mB/radial-snake/commit/e17a45f)\n\n##### Added resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;play&#x2F;index.js\n```diff\n@@ -0,0 +1,14 @@\n+â”Š  â”Š 1â”ŠGame.Screens.Play = class Play extends Engine.Screen {\n+â”Š  â”Š 2â”Š  get events() {\n+â”Š  â”Š 3â”Š    return {\n+â”Š  â”Š 4â”Š      \"keydown\": \"onKeyDown\"\n+â”Š  â”Š 5â”Š    }\n+â”Š  â”Š 6â”Š  }\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Š  onKeyDown() {\n+â”Š  â”Š 9â”Š    // Once escape is pressed, return to main menu screen\n+â”Š  â”Š10â”Š    if (this.keyStates.get(27)) {\n+â”Š  â”Š11â”Š      this.game.changeScreen(Game.Screens.Menu);\n+â”Š  â”Š12â”Š    }\n+â”Š  â”Š13â”Š  }\n+â”Š  â”Š14â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -23,6 +23,7 @@\n â”Š23â”Š23â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/assets_loader.js\"></script>\n â”Š24â”Š24â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š25â”Š25â”Š    <script type=\"text/javascript\" src=\"/scripts/game/entities/snake.js\"></script>\n+â”Š  â”Š26â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/index.js\"></script>\n â”Š26â”Š27â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/menu/index.js\"></script>\n â”Š27â”Š28â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/splash/index.js\"></script>\n â”Š28â”Š29â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n```\n\n[}]: #\n\nThat's it folks, the `Play` screen is finished, and you can play as much matches as you'd feel like.\n\nAlthough the game is finished, it can still be optimized using `C++`. To discover more on hooking efficiency and how we can hook `C++` to the browser, see the next step."
          },
          {
            "manualTitle": "Step 7: Bonus! Re-implementing geometry in C++",
            "stepRevision": "cea4cffcc2f5e801020ed13ef8f1edde608c85f3",
            "manualView": "> This step is part of a bigger tutorial series where we learn how to create a game engine and implement a Tron-style game in JavaScript. The base project for the following step is available [here](https://github.com/DAB0mB/radial-snake/tree/step6).\n\nSo far I covered up pretty much everything I planned. I showed you how to create a game engine, including a font generator, an animation player and a screening system. On top of that, we've learned how to structure and organize our code well, so if in the future we'd like to extend our game by adding more screens or capabilities, we can do that with ease. Indeed, we've went through lots of great stuff, and if you've reached this point I give you my thumbs up. If so far this wasn't enough, in this step we will be focusing on optimization, and making our game engine run faster (a lot, faster). Obviously, when talking about optimizations, the first thing you would probably think of is how we can make our algorithms efficient by using minimum number of operations. While this is true, we will be actually focusing on optimizing our code using C++.\n\nUnlike JavaScript, which is a dynamic scripting file executed by an interpreter, C++ is a general purpose language which compiles into executables. Naturally, executables are much faster than scripts, since they don't have to be interpreted, and they can approach the hardware and memory much faster. In C++, we have to explicitly define our data-types, meaning that variables don't have to be parsed during run-time. While explicit variables definition is C++'s biggest drawback, it's also one of its biggest advantages. The mere fact that variables can be handled much faster, makes code much more efficient.\n\nAccordingly, we can conclude that the programming language we're using plays a very important role when it comes to efficiency. So how exactly are we going to integrate C++ into the browser? We're going to do that by using a compiler called - [Emscripten](http://kripken.github.io/emscripten-site/).\n\n![emscripten](https://cloud.githubusercontent.com/assets/7648874/22675449/ee6d7e9c-eccc-11e6-9570-1dd5d982ee66.png)\n\nEmscripten is an Open Source [LLVM](https://en.wikipedia.org/wiki/LLVM) to JavaScript compiler. Using Emscripten you can:\n\n- Compile C and C++ code into JavaScript\n- Compile any other code that can be translated into LLVM bitcode into JavaScript.\n- Compile the C/C++ runtimes of other languages into JavaScript, and then run code in those other languages in an indirect way (this has been done for Python and Lua)!\n\nLLVM is a library that is used to construct, optimize and produce intermediate and/or binary machine code. LLVM can be used as a compiler framework, where you provide the \"front end\" (parser and lexer) and the \"back end\" (code that converts LLVM's representation to actual machine code). LLVM can also act as a JIT compiler - it has support for x86/x86_64 and PPC/PPC64 assembly generation with fast code optimizations aimed for compilation speed.\n\nEmscripten operates by taking LLVM code and converting it into a subset of JavaScript called asm.js that can run anywhere that JavaScript can run (usually the browser, but also Node.js, etc.) and is easy for browsers to optimize. This means that you can basically write web applications in any language that has an LLVM compiler.\n\n![emscripten-flow](https://cloud.githubusercontent.com/assets/7648874/22675751/b244b76c-ecce-11e6-917e-f7039ed4b340.png)\n\nIn order to use Emscripten you will first have to install it. I recommend you to follow Emscripten's official installation instructions at their website over [here](https://kripken.github.io/emscripten-site/docs/getting_started/downloads.html). Installing Emscripten might be a bit tiring for some, I know for me it was, but if you're hyped about writing native code in the browser as much as I do, take as much time as needed to install it, and bare with me.\n\nAssuming that you have Emscripten installed, we can get right to business. The goal for this step is to re-implement our geometry namespace in C++, and to be more specific, the circle class and line class. We will start by creating an entry file for our C++ code under the path `resources/cpp/src/index.cpp`:\n\n    $ mkdir resources/cpp\n    $ mkdir resources/cpp/src\n    $ touch resources/cpp/src/index.cpp\n\nFrom now on, every C++ file that we would like to run in the browser should be included in the `index.cpp` file we've just created, otherwise it's not going to appear anywhere. The first stage for re-implementing our geometry would be re-writing the utility module, since our geometry is heavily based on it; Therefore the firs inclusion in our `index.cpp` file would be the following:\n\n[{]: <helper> (diffStep 7.1)\n\n#### [Step 7.1: Add CPP entry script](https://github.com/DAB0mB/radial-snake/commit/2f35323)\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;index.cpp\n```diff\n@@ -0,0 +1 @@\n+â”Š â”Š1â”Š#include \"utils.cpp\"ðŸš«â†µ\n```\n\n[}]: #\n\nFollowing that, we will create the `utils.cpp` module included above, which is a direct translation from C++ to JavaScript for the `utils.js` we've created earlier in this tutorial.\n\n[{]: <helper> (diffStep 7.2)\n\n#### [Step 7.2: Add base utility CPP module](https://github.com/DAB0mB/radial-snake/commit/6dba512)\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;utils.cpp\n```diff\n@@ -0,0 +1,73 @@\n+â”Š  â”Š 1â”Š#include <cfloat>\n+â”Š  â”Š 2â”Š#include <cmath>\n+â”Š  â”Š 3â”Š#include <string>\n+â”Š  â”Š 4â”Š#include \"utils.h\"\n+â”Š  â”Š 5â”Š\n+â”Š  â”Š 6â”Šnamespace utils {\n+â”Š  â”Š 7â”Š  // Fixed modulo method which can calculate modulo of negative numbers properly\n+â”Š  â”Š 8â”Š  // e.g. (-803).mod(800) returns 797\n+â”Š  â”Š 9â”Š  double mod(double context, double num) {\n+â”Š  â”Š10â”Š    return std::fmod((std::fmod(context, num) + num), num);\n+â”Š  â”Š11â”Š  }\n+â”Š  â”Š12â”Š\n+â”Š  â”Š13â”Š  // Trims number and leaves the number of decimals specified.\n+â”Š  â”Š14â”Š  // The \"mode\" argument specifies which math function should be invoked\n+â”Š  â”Š15â”Š  // right after the number has been trimmed.\n+â”Š  â”Š16â”Š  // e.g. 12.12345.trim(3, \"ceil\") returns 12.124\n+â”Š  â”Š17â”Š  double trim(double context, int decimals, const std::string mode) {\n+â”Š  â”Š18â”Š    double accumulator = context * std::pow(10, decimals);\n+â”Š  â”Š19â”Š\n+â”Š  â”Š20â”Š    if (mode.compare(\"ceil\") == 0)\n+â”Š  â”Š21â”Š      accumulator = std::ceil(accumulator);\n+â”Š  â”Š22â”Š    else if (mode.compare(\"floor\") == 0)\n+â”Š  â”Š23â”Š      accumulator = std::floor(accumulator);\n+â”Š  â”Š24â”Š    else\n+â”Š  â”Š25â”Š      accumulator = std::round(accumulator);\n+â”Š  â”Š26â”Š\n+â”Š  â”Š27â”Š    return accumulator / std::pow(10, decimals);\n+â”Š  â”Š28â”Š  }\n+â”Š  â”Š29â”Š\n+â”Š  â”Š30â”Š  // Tells if number is in specified range based on given precision.\n+â”Š  â”Š31â”Š  // See the \"compare\" method for more information about precision\n+â”Š  â”Š32â”Š  bool isBetween(double context, double num1, double num2, const std::string precision) {\n+â”Š  â”Š33â”Š    return compare(context, std::min(num1, num2), \">=\", precision) &&\n+â”Š  â”Š34â”Š           compare(context, std::max(num1, num2), \"<=\", precision);\n+â”Š  â”Š35â”Š  }\n+â”Š  â”Š36â”Š\n+â”Š  â”Š37â”Š  bool compare(double context, double num, const std::string precision) {\n+â”Š  â”Š38â”Š    return compare(context, num, \"==\", precision);\n+â”Š  â”Š39â”Š  }\n+â”Š  â”Š40â”Š\n+â”Š  â”Š41â”Š  // Initiates comparison operator between context number and a given number, only here\n+â”Š  â”Š42â”Š  // a precision can be specified\n+â”Š  â”Š43â”Š  bool compare(double context, double num, const std::string method, const std::string precision) {\n+â”Š  â”Š44â”Š    // Fixed precision, \"almost equal\" with a deviation of Îµ\n+â”Š  â”Š45â”Š    if (precision.compare(\"f\") == 0) {\n+â”Š  â”Š46â”Š      if (method.compare(\"<\") == 0 ||\n+â”Š  â”Š47â”Š          method.compare(\"<=\") == 0)\n+â”Š  â”Š48â”Š        return context <= num + DBL_EPSILON;\n+â”Š  â”Š49â”Š      if (method.compare(\">\") == 0 ||\n+â”Š  â”Š50â”Š          method.compare(\">=\") == 0)\n+â”Š  â”Š51â”Š        return context >= num - DBL_EPSILON;\n+â”Š  â”Š52â”Š      return std::abs(context - num) <= DBL_EPSILON;\n+â”Š  â”Š53â”Š    }\n+â”Š  â”Š54â”Š    // Pixel precision, round comparison\n+â”Š  â”Š55â”Š    else if (precision.compare(\"px\") == 0) {\n+â”Š  â”Š56â”Š      if (method.compare(\"<\") == 0 ||\n+â”Š  â”Š57â”Š          method.compare(\"<=\") == 0)\n+â”Š  â”Š58â”Š        return std::round(context) <= std::round(num);\n+â”Š  â”Š59â”Š      if (method.compare(\">\") == 0 ||\n+â”Š  â”Š60â”Š          method.compare(\">=\") == 0)\n+â”Š  â”Š61â”Š        return std::round(context) >= std::round(num);\n+â”Š  â”Š62â”Š      return std::round(context) == std::round(num);\n+â”Š  â”Š63â”Š    }\n+â”Š  â”Š64â”Š    // Exact precision\n+â”Š  â”Š65â”Š    else {\n+â”Š  â”Š66â”Š      if (method.compare(\"<\") == 0) return context < num;\n+â”Š  â”Š67â”Š      if (method.compare(\"<=\") == 0) return context <= num;\n+â”Š  â”Š68â”Š      if (method.compare(\">\") == 0) return context > num;\n+â”Š  â”Š69â”Š      if (method.compare(\">=\") == 0) return context >= num;\n+â”Š  â”Š70â”Š      return context == num;\n+â”Š  â”Š71â”Š    }\n+â”Š  â”Š72â”Š  }\n+â”Š  â”Š73â”Š}ðŸš«â†µ\n```\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;utils.h\n```diff\n@@ -0,0 +1,15 @@\n+â”Š  â”Š 1â”Š#pragma once\n+â”Š  â”Š 2â”Š\n+â”Š  â”Š 3â”Š#include <string>\n+â”Š  â”Š 4â”Š\n+â”Š  â”Š 5â”Šnamespace utils {\n+â”Š  â”Š 6â”Š  double mod(double context, double num);\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Š  double trim(double context, int decimals, const std::string mode = \"round\");\n+â”Š  â”Š 9â”Š\n+â”Š  â”Š10â”Š  bool isBetween(double context, double num1, double num2, const std::string precision = \"exact\");\n+â”Š  â”Š11â”Š\n+â”Š  â”Š12â”Š  bool compare(double context, double num, const std::string precision = \"exact\");\n+â”Š  â”Š13â”Š\n+â”Š  â”Š14â”Š  bool compare(double context, double num, const std::string method, const std::string precision);\n+â”Š  â”Š15â”Š}ðŸš«â†µ\n```\n\n[}]: #\n\nThe module above should work by itself when interacting with it inside the C++ scope, but that's not what we're striving for. We want this module to be available for use in our JavaScript project. This requires us to wrap our code in such a way the the Emscripten compiler will know how to compile it. Apart from providing a compiler, Emscripten provides us with functions and macros that will help use bind our C++ code to the JavaScript environment. These functionalities are packed in a single library which can be imported in our C++ code, and it is called [Embind](https://kripken.github.io/emscripten-site/docs/porting/connecting_cpp_and_javascript/embind.html) (probably stands for \"Emscripten bind\"). Using EMBind, let's wrap our utils module accordingly:\n\n[{]: <helper> (diffStep 7.3)\n\n#### [Step 7.3: EMBind CPP utils](https://github.com/DAB0mB/radial-snake/commit/0f34332)\n\n##### Changed resources&#x2F;cpp&#x2F;src&#x2F;utils.cpp\n```diff\n@@ -1,6 +1,7 @@\n â”Š1â”Š1â”Š#include <cfloat>\n â”Š2â”Š2â”Š#include <cmath>\n â”Š3â”Š3â”Š#include <string>\n+â”Š â”Š4â”Š#include <emscripten/bind.h>\n â”Š4â”Š5â”Š#include \"utils.h\"\n â”Š5â”Š6â”Š\n â”Š6â”Š7â”Šnamespace utils {\n```\n```diff\n@@ -70,4 +71,15 @@\n â”Š70â”Š71â”Š      return context == num;\n â”Š71â”Š72â”Š    }\n â”Š72â”Š73â”Š  }\n+â”Š  â”Š74â”Š}\n+â”Š  â”Š75â”Š\n+â”Š  â”Š76â”ŠEMSCRIPTEN_BINDINGS(utils_module) {\n+â”Š  â”Š77â”Š  emscripten::function(\"utils_mod\", &utils::mod);\n+â”Š  â”Š78â”Š  emscripten::function(\"utils_trim\", &utils::trim);\n+â”Š  â”Š79â”Š  emscripten::function(\"utils_isBetween\", &utils::isBetween);\n+â”Š  â”Š80â”Š  emscripten::function(\"utils_compare\",\n+â”Š  â”Š81â”Š    emscripten::select_overload<bool(double, double, const std::string, const std::string)>(\n+â”Š  â”Š82â”Š      &utils::compare\n+â”Š  â”Š83â”Š    )\n+â”Š  â”Š84â”Š  );\n â”Š73â”Š85â”Š}ðŸš«â†µ\n```\n\n[}]: #\n\nAfter a while you'll get used for Embind's API. If you'll look at it, it's self explanatory and easy to understand. Bound objects will be available the JavaScript environment will be available under an object named `Module`, e.g. the C++ method `mod` will be available for use as `Module.utils_mod`. Bound functions should have supported return types and argument types, meaning that if we're using a custom structure as a return type or an argument type, we first need to wrap it using EMBind, otherwise the compiler won't know how to handle it. A list of natively supported data-types can be found [here](https://kripken.github.io/emscripten-site/docs/porting/connecting_cpp_and_javascript/embind.html#built-in-type-conversions).\n\nEven though we've wrapped our C++ code and hypothetically it can already be used in the browser, I'd go for a second wrapper, since the compiled code doesn't have the optimal architecture. Right now we will have to approach C++ utility functions using `Module.utils_foo`. Instead, I'd like it to be `CPP.Utils.foo`, since it's clearer this way. The output of the Emscripten compiler can be wrapped with JavaScript code, using a prefix and a suffix, defined in 2 separate files respectively, called `pre.js` and `post.js`:\n\n[{]: <helper> (diffStep 7.4)\n\n#### [Step 7.4: Create CPP wrappers](https://github.com/DAB0mB/radial-snake/commit/cc28a34)\n\n##### Added resources&#x2F;cpp&#x2F;post.js\n```diff\n@@ -0,0 +1,10 @@\n+â”Š  â”Š 1â”Šreturn {\n+â”Š  â”Š 2â”Š  Utils: {\n+â”Š  â”Š 3â”Š    mod: Module.utils_mod,\n+â”Š  â”Š 4â”Š    trim: Module.utils_trim,\n+â”Š  â”Š 5â”Š    isBetween: Module.utils_isBetween,\n+â”Š  â”Š 6â”Š    compare: Module.utils_compare\n+â”Š  â”Š 7â”Š  }\n+â”Š  â”Š 8â”Š};\n+â”Š  â”Š 9â”Š\n+â”Š  â”Š10â”Š})();ðŸš«â†µ\n```\n\n##### Added resources&#x2F;cpp&#x2F;pre.js\n```diff\n@@ -0,0 +1 @@\n+â”Š â”Š1â”ŠCPP = (function() {ðŸš«â†µ\n```\n\n[}]: #\n\nWhat we've done in the code snippet above, we've created an anonymous function which calls itself, and inside we've exported a new namespace called `CPP` (C++). This way we can keep the generated code encapsulated, without worrying about spamming the global object.\n\nAfter creating a wrapper, I'd also recommend you to integrate the generated C++ code into existing namespaces, meaning that if for example we would like to approach the `CPP.Utils.foo` method, it could be done using `Utils.foo`. This way existing code won't have to be changed, and extra wrapping logic can be applied with ease, like the chaining logic implemented in the `Utils` namespace:\n\n[{]: <helper> (diffStep 7.5)\n\n#### [Step 7.5: Bind CPP utils to JS utils](https://github.com/DAB0mB/radial-snake/commit/0a67d50)\n\n##### Changed resources&#x2F;scripts&#x2F;utils.js\n```diff\n@@ -16,53 +16,9 @@\n â”Š16â”Š16â”Š  return chain;\n â”Š17â”Š17â”Š};\n â”Š18â”Š18â”Š\n-â”Š19â”Š  â”Š// Fixed modulo method which can calculate modulo of negative numbers properly\n-â”Š20â”Š  â”Š// e.g. (-803).mod(800) returns 797\n-â”Š21â”Š  â”ŠUtils.mod = function (context, num) {\n-â”Š22â”Š  â”Š  return ((context % num) + num) % num;\n-â”Š23â”Š  â”Š};\n-â”Š24â”Š  â”Š\n-â”Š25â”Š  â”Š// Trims number and leaves the number of decimals specified.\n-â”Š26â”Š  â”Š// The \"mode\" argument specifies which math function should be invoked\n-â”Š27â”Š  â”Š// right after the number has been trimmed.\n-â”Š28â”Š  â”Š// e.g. 12.12345.trim(3, \"ceil\") returns 12.124\n-â”Š29â”Š  â”ŠUtils.trim = function (context, decimals, mode = \"round\") {\n-â”Š30â”Š  â”Š  return Math[mode](context * Math.pow(10, decimals)) / Math.pow(10, decimals);\n-â”Š31â”Š  â”Š};\n-â”Š32â”Š  â”Š\n-â”Š33â”Š  â”Š// Tells if number is in specified range based on given precision.\n-â”Š34â”Š  â”Š// See the \"compare\" method for more information about precision\n-â”Š35â”Š  â”ŠUtils.isBetween = function (context, num1, num2, precision) {\n-â”Š36â”Š  â”Š  return Utils.compare(context, Math.min(num1, num2), \">=\", precision) &&\n-â”Š37â”Š  â”Š         Utils.compare(context, Math.max(num1, num2), \"<=\", precision);\n-â”Š38â”Š  â”Š};\n-â”Š39â”Š  â”Š\n-â”Š40â”Š  â”Š// Initiates comparison operator between context number and a given number, only here\n-â”Š41â”Š  â”Š// a precision can be specified\n-â”Š42â”Š  â”ŠUtils.compare = function (context, num, method, precision = method) {\n-â”Š43â”Š  â”Š  switch (precision) {\n-â”Š44â”Š  â”Š    // Fixed precision, \"almost equal\" with a deviation of Îµ\n-â”Š45â”Š  â”Š    case \"f\":\n-â”Š46â”Š  â”Š      switch (method) {\n-â”Š47â”Š  â”Š        case \"<\": case \"<=\": return context <= num + Number.EPSILON;\n-â”Š48â”Š  â”Š        case \">\": case \">=\": return context >= num - Number.EPSILON;\n-â”Š49â”Š  â”Š        default: return Math.abs(context - num) <= Number.EPSILON;\n-â”Š50â”Š  â”Š      }\n-â”Š51â”Š  â”Š    // Pixel precision, round comparison\n-â”Š52â”Š  â”Š    case \"px\":\n-â”Š53â”Š  â”Š      switch (method) {\n-â”Š54â”Š  â”Š        case \"<\": case \"<=\": return Math.round(context) <= Math.round(num);\n-â”Š55â”Š  â”Š        case \">\": case \">=\": return Math.round(context) >= Math.round(num);\n-â”Š56â”Š  â”Š        default: return Math.round(context) == Math.round(num);\n-â”Š57â”Š  â”Š      }\n-â”Š58â”Š  â”Š    // Exact precision\n-â”Š59â”Š  â”Š    default:\n-â”Š60â”Š  â”Š      switch (method) {\n-â”Š61â”Š  â”Š        case \"<\": return context < num;\n-â”Š62â”Š  â”Š        case \"<=\": return context <= num;\n-â”Š63â”Š  â”Š        case \">\": return context > num;\n-â”Š64â”Š  â”Š        case \">=\": return context >= num;\n-â”Š65â”Š  â”Š        default: return context === num;\n-â”Š66â”Š  â”Š      }\n+â”Š  â”Š19â”ŠObject.assign(Utils, CPP.Utils, {\n+â”Š  â”Š20â”Š  // Overload handling\n+â”Š  â”Š21â”Š  compare(context, num, method, precision = method) {\n+â”Š  â”Š22â”Š    return CPP.Utils.compare(context, num, method, precision);\n â”Š67â”Š23â”Š  }\n-â”Š68â”Š  â”Š};ðŸš«â†µ\n+â”Š  â”Š24â”Š});ðŸš«â†µ\n```\n\n[}]: #\n\nWhenever launching the compiler, the generated code should be outputted somewhere. I've decided to go with the path `resources/scripts/cpp.bundle.js`, but it doesn't matter how the file is gonna be called, as long as it's defined under the `scripts` dir, otherwise we won't be able to load it. Also, we need to make sure that we set a git-ignore rule for the generated file, since there's no reason for us to upload it to the git-host if we're planning on compiling it:\n\n[{]: <helper> (diffStep 7.5)\n\n#### [Step 7.5: Bind CPP utils to JS utils](https://github.com/DAB0mB/radial-snake/commit/0a67d50)\n\n##### Changed resources&#x2F;scripts&#x2F;utils.js\n```diff\n@@ -16,53 +16,9 @@\n â”Š16â”Š16â”Š  return chain;\n â”Š17â”Š17â”Š};\n â”Š18â”Š18â”Š\n-â”Š19â”Š  â”Š// Fixed modulo method which can calculate modulo of negative numbers properly\n-â”Š20â”Š  â”Š// e.g. (-803).mod(800) returns 797\n-â”Š21â”Š  â”ŠUtils.mod = function (context, num) {\n-â”Š22â”Š  â”Š  return ((context % num) + num) % num;\n-â”Š23â”Š  â”Š};\n-â”Š24â”Š  â”Š\n-â”Š25â”Š  â”Š// Trims number and leaves the number of decimals specified.\n-â”Š26â”Š  â”Š// The \"mode\" argument specifies which math function should be invoked\n-â”Š27â”Š  â”Š// right after the number has been trimmed.\n-â”Š28â”Š  â”Š// e.g. 12.12345.trim(3, \"ceil\") returns 12.124\n-â”Š29â”Š  â”ŠUtils.trim = function (context, decimals, mode = \"round\") {\n-â”Š30â”Š  â”Š  return Math[mode](context * Math.pow(10, decimals)) / Math.pow(10, decimals);\n-â”Š31â”Š  â”Š};\n-â”Š32â”Š  â”Š\n-â”Š33â”Š  â”Š// Tells if number is in specified range based on given precision.\n-â”Š34â”Š  â”Š// See the \"compare\" method for more information about precision\n-â”Š35â”Š  â”ŠUtils.isBetween = function (context, num1, num2, precision) {\n-â”Š36â”Š  â”Š  return Utils.compare(context, Math.min(num1, num2), \">=\", precision) &&\n-â”Š37â”Š  â”Š         Utils.compare(context, Math.max(num1, num2), \"<=\", precision);\n-â”Š38â”Š  â”Š};\n-â”Š39â”Š  â”Š\n-â”Š40â”Š  â”Š// Initiates comparison operator between context number and a given number, only here\n-â”Š41â”Š  â”Š// a precision can be specified\n-â”Š42â”Š  â”ŠUtils.compare = function (context, num, method, precision = method) {\n-â”Š43â”Š  â”Š  switch (precision) {\n-â”Š44â”Š  â”Š    // Fixed precision, \"almost equal\" with a deviation of Îµ\n-â”Š45â”Š  â”Š    case \"f\":\n-â”Š46â”Š  â”Š      switch (method) {\n-â”Š47â”Š  â”Š        case \"<\": case \"<=\": return context <= num + Number.EPSILON;\n-â”Š48â”Š  â”Š        case \">\": case \">=\": return context >= num - Number.EPSILON;\n-â”Š49â”Š  â”Š        default: return Math.abs(context - num) <= Number.EPSILON;\n-â”Š50â”Š  â”Š      }\n-â”Š51â”Š  â”Š    // Pixel precision, round comparison\n-â”Š52â”Š  â”Š    case \"px\":\n-â”Š53â”Š  â”Š      switch (method) {\n-â”Š54â”Š  â”Š        case \"<\": case \"<=\": return Math.round(context) <= Math.round(num);\n-â”Š55â”Š  â”Š        case \">\": case \">=\": return Math.round(context) >= Math.round(num);\n-â”Š56â”Š  â”Š        default: return Math.round(context) == Math.round(num);\n-â”Š57â”Š  â”Š      }\n-â”Š58â”Š  â”Š    // Exact precision\n-â”Š59â”Š  â”Š    default:\n-â”Š60â”Š  â”Š      switch (method) {\n-â”Š61â”Š  â”Š        case \"<\": return context < num;\n-â”Š62â”Š  â”Š        case \"<=\": return context <= num;\n-â”Š63â”Š  â”Š        case \">\": return context > num;\n-â”Š64â”Š  â”Š        case \">=\": return context >= num;\n-â”Š65â”Š  â”Š        default: return context === num;\n-â”Š66â”Š  â”Š      }\n+â”Š  â”Š19â”ŠObject.assign(Utils, CPP.Utils, {\n+â”Š  â”Š20â”Š  // Overload handling\n+â”Š  â”Š21â”Š  compare(context, num, method, precision = method) {\n+â”Š  â”Š22â”Š    return CPP.Utils.compare(context, num, method, precision);\n â”Š67â”Š23â”Š  }\n-â”Š68â”Š  â”Š};ðŸš«â†µ\n+â”Š  â”Š24â”Š});ðŸš«â†µ\n```\n\n[}]: #\n\nTo compile our C++ code and turn it into JavaScript, we'll need to run the following command:\n\n    $ emcc -O1 --pre-js resources/cpp/pre.js --post-js resources/cpp/post.js --bind -o resources/scripts/cpp.bundle.js resources/cpp/src/index.cpp\n\nHere's a detailed list with explanations regards the arguments vector we've just passed:\n\n- `-01` - Optimization level 1. The higher the index, the more optimized our code is gonna be, but less readable.\n- `--pre-js` - Specifies a JavaScript prefix for the compiled code.\n- `--post-js` - Specifies a JavaScript postfix for the compiled code.\n- `--bind` - Tells the compiler to use Embind\n- `-o` - The output path.\n\n> More informations regards Emscripten's CLI can be found [here](https://kripken.github.io/emscripten-site/docs/tools_reference/emcc.html).\n\nYou don't have to memorize the compilation command we've just typed, because we're gonna save it as an NPM script called `build:cpp`:\n\n[{]: <helper> (diffStep 7.6)\n\n#### [Step 7.6: Add ignore rule to CPP bundle](https://github.com/DAB0mB/radial-snake/commit/f4a75cf)\n\n##### Changed .gitignore\n```diff\n@@ -1,3 +1,4 @@\n â”Š1â”Š1â”Šnode_modules\n â”Š2â”Š2â”Šnpm-debug.log\n-â”Š3â”Š â”Šresources/assets/fonts/*.jsonðŸš«â†µ\n+â”Š â”Š3â”Šresources/assets/fonts/*.json\n+â”Š â”Š4â”Šresources/scripts/cpp.bundle.jsðŸš«â†µ\n```\n\n[}]: #\n\nNow if you'd like to compile the C++ code just run:\n\n    $ npm run build:cpp\n\nMoreover, the code should be compiled automatically any time you start the serer using the command:\n\n    $ npm run serve\n\nWe always have to be on the alert and run our tests against modules we've just translated from JavaScript to C++. This will guarantee that once we run the game we won't stumble upon any defect whatsoever. Before running the tests, be sure to import the C++ bundle in the HTML file's header:\n\n[{]: <helper> (diffStep 7.8)\n\n#### [Step 7.8: Load CPP bundle in spec runner](https://github.com/DAB0mB/radial-snake/commit/0d1bd08)\n\n##### Changed views&#x2F;spec_runner.html\n```diff\n@@ -16,6 +16,7 @@\n â”Š16â”Š16â”Š    <script type=\"text/javascript\" src=\"libs/underscore.js\"></script>\n â”Š17â”Š17â”Š\n â”Š18â”Š18â”Š    <!-- Scripts -->\n+â”Š  â”Š19â”Š    <script type=\"text/javascript\" src=\"scripts/cpp.bundle.js\"></script>\n â”Š19â”Š20â”Š    <script type=\"text/javascript\" src=\"scripts/utils.js\"></script>\n â”Š20â”Š21â”Š    <script type=\"text/javascript\" src=\"scripts/namespaces.js\"></script>\n â”Š21â”Š22â”Š    <script type=\"text/javascript\" src=\"scripts/engine/geometry/line.js\"></script>\n```\n\n[}]: #\n\nNow we can run the tests by running the following command:\n\n    $ npm run test\n\nAt this point **all our tests should pass**. If they don't, it means our newly created utility module is not working properly, and you will have to repeat the previous steps until you get it right.\n\nUp next, we gonna translate the geometry line class to C++. Since it's gonna be translated almost identically, we will have to make sure that all the necessary assets are gonna be available for our class before proceeding. The first thing we will have to do would be making sure that the utility functions are chainable directly from C++ as well. To do that, we will create a chain class which should return a new instance of it whenever we're about to chain the upcoming utility method. Once calling `result()`, the accumulator should be returned:\n\n[{]: <helper> (diffStep 7.9)\n\n#### [Step 7.9: Add chaining method to CPP utils](https://github.com/DAB0mB/radial-snake/commit/0927eea)\n\n##### Changed resources&#x2F;cpp&#x2F;src&#x2F;utils.cpp\n```diff\n@@ -5,6 +5,61 @@\n â”Š 5â”Š 5â”Š#include \"utils.h\"\n â”Š 6â”Š 6â”Š\n â”Š 7â”Š 7â”Šnamespace utils {\n+â”Š  â”Š 8â”Š  template<typename T>\n+â”Š  â”Š 9â”Š  Chain<T>::Chain(T accumulator): _accumulator(accumulator) {\n+â”Š  â”Š10â”Š  }\n+â”Š  â”Š11â”Š\n+â”Š  â”Š12â”Š  template<>\n+â”Š  â”Š13â”Š  Chain<double>* Chain<double>::mod(double num) {\n+â”Š  â”Š14â”Š    double result = utils::mod(_accumulator, num);\n+â”Š  â”Š15â”Š    Chain<double>* chain = new Chain<double>(result);\n+â”Š  â”Š16â”Š    delete this;\n+â”Š  â”Š17â”Š    return chain;\n+â”Š  â”Š18â”Š  }\n+â”Š  â”Š19â”Š\n+â”Š  â”Š20â”Š  template<>\n+â”Š  â”Š21â”Š  Chain<double>* Chain<double>::trim(int decimals, const std::string mode) {\n+â”Š  â”Š22â”Š    double result = utils::trim(_accumulator, decimals, mode);\n+â”Š  â”Š23â”Š    Chain<double>* chain = new Chain<double>(result);\n+â”Š  â”Š24â”Š    delete this;\n+â”Š  â”Š25â”Š    return chain;\n+â”Š  â”Š26â”Š  }\n+â”Š  â”Š27â”Š\n+â”Š  â”Š28â”Š  template<>\n+â”Š  â”Š29â”Š  Chain<bool>* Chain<double>::isBetween(double num1, double num2, const std::string precision) {\n+â”Š  â”Š30â”Š    bool result = utils::isBetween(_accumulator, num1, num2, precision);\n+â”Š  â”Š31â”Š    Chain<bool>* chain = new Chain<bool>(result);\n+â”Š  â”Š32â”Š    delete this;\n+â”Š  â”Š33â”Š    return chain;\n+â”Š  â”Š34â”Š  }\n+â”Š  â”Š35â”Š\n+â”Š  â”Š36â”Š  template<>\n+â”Š  â”Š37â”Š  Chain<bool>* Chain<double>::compare(double num, const std::string precision) {\n+â”Š  â”Š38â”Š    bool result = utils::compare(_accumulator, num, precision);\n+â”Š  â”Š39â”Š    Chain<bool>* chain = new Chain<bool>(result);\n+â”Š  â”Š40â”Š    delete this;\n+â”Š  â”Š41â”Š    return chain;\n+â”Š  â”Š42â”Š  }\n+â”Š  â”Š43â”Š\n+â”Š  â”Š44â”Š  template<>\n+â”Š  â”Š45â”Š  Chain<bool>* Chain<double>::compare(double num, const std::string method, const std::string precision) {\n+â”Š  â”Š46â”Š    bool result = utils::compare(_accumulator, num, method, precision);\n+â”Š  â”Š47â”Š    Chain<bool>* chain = new Chain<bool>(result);\n+â”Š  â”Š48â”Š    delete this;\n+â”Š  â”Š49â”Š    return chain;\n+â”Š  â”Š50â”Š  }\n+â”Š  â”Š51â”Š\n+â”Š  â”Š52â”Š  template<typename T>\n+â”Š  â”Š53â”Š  T Chain<T>::result() {\n+â”Š  â”Š54â”Š    delete this;\n+â”Š  â”Š55â”Š    return _accumulator;\n+â”Š  â”Š56â”Š  }\n+â”Š  â”Š57â”Š\n+â”Š  â”Š58â”Š  template<typename T>\n+â”Š  â”Š59â”Š  Chain<T>* chain(T accumulator) {\n+â”Š  â”Š60â”Š    return new Chain<T>(accumulator);\n+â”Š  â”Š61â”Š  }\n+â”Š  â”Š62â”Š\n â”Š 8â”Š63â”Š  // Fixed modulo method which can calculate modulo of negative numbers properly\n â”Š 9â”Š64â”Š  // e.g. (-803).mod(800) returns 797\n â”Š10â”Š65â”Š  double mod(double context, double num) {\n```\n\n##### Changed resources&#x2F;cpp&#x2F;src&#x2F;utils.h\n```diff\n@@ -3,6 +3,30 @@\n â”Š 3â”Š 3â”Š#include <string>\n â”Š 4â”Š 4â”Š\n â”Š 5â”Š 5â”Šnamespace utils {\n+â”Š  â”Š 6â”Š  template<typename T>\n+â”Š  â”Š 7â”Š  class Chain {\n+â”Š  â”Š 8â”Š  private:\n+â”Š  â”Š 9â”Š    T _accumulator;\n+â”Š  â”Š10â”Š\n+â”Š  â”Š11â”Š  public:\n+â”Š  â”Š12â”Š    Chain(T accumulator);\n+â”Š  â”Š13â”Š\n+â”Š  â”Š14â”Š    Chain<double>* mod(double num);\n+â”Š  â”Š15â”Š\n+â”Š  â”Š16â”Š    Chain<double>* trim(int decimals, const std::string mode = \"round\");\n+â”Š  â”Š17â”Š\n+â”Š  â”Š18â”Š    Chain<bool>* isBetween(double num1, double num2, const std::string precision = \"exact\");\n+â”Š  â”Š19â”Š\n+â”Š  â”Š20â”Š    Chain<bool>* compare(double num, const std::string precision = \"exact\");\n+â”Š  â”Š21â”Š\n+â”Š  â”Š22â”Š    Chain<bool>* compare(double num, const std::string method, const std::string precision);\n+â”Š  â”Š23â”Š\n+â”Š  â”Š24â”Š    T result();\n+â”Š  â”Š25â”Š  };\n+â”Š  â”Š26â”Š\n+â”Š  â”Š27â”Š  template<typename T>\n+â”Š  â”Š28â”Š  Chain<T>* chain(T accumulator);\n+â”Š  â”Š29â”Š\n â”Š 6â”Š30â”Š  double mod(double context, double num);\n â”Š 7â”Š31â”Š\n â”Š 8â”Š32â”Š  double trim(double context, int decimals, const std::string mode = \"round\");\n```\n\n[}]: #\n\n> Note that when coding in C++ we have to make sure that the objects are being disposed when not needed anymore, otherwise we will have some unnecessary memory leaks.\n\n2D shapes are presented in space using points with 2 values - `x` (axis) and `y` axis, therefore, we will create the appropriate point structure:\n\n[{]: <helper> (diffStep 7.1)\n\n#### [Step 7.1: Add CPP entry script](https://github.com/DAB0mB/radial-snake/commit/2f35323)\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;index.cpp\n```diff\n@@ -0,0 +1 @@\n+â”Š â”Š1â”Š#include \"utils.cpp\"ðŸš«â†µ\n```\n\n[}]: #\n\nReturned values can either be `null` (`undefined`) or not. Since there's no built in nullable-values mechanism in C++ (up until C++17), we're gonna create one of our own:\n\n[{]: <helper> (diffStep 7.11)\n\n#### [Step 7.11: Add nullable class](https://github.com/DAB0mB/radial-snake/commit/41b2f7c)\n\n##### Changed resources&#x2F;cpp&#x2F;src&#x2F;index.cpp\n```diff\n@@ -1 +1,2 @@\n+â”Š â”Š1â”Š#include \"nullable.cpp\"\n â”Š1â”Š2â”Š#include \"utils.cpp\"ðŸš«â†µ\n```\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;nullable.cpp\n```diff\n@@ -0,0 +1,37 @@\n+â”Š  â”Š 1â”Š#include \"nullable.h\"\n+â”Š  â”Š 2â”Š\n+â”Š  â”Š 3â”Štemplate <typename T>\n+â”Š  â”Š 4â”ŠNullable<T>::Nullable(T value): _value(value), _initialized(true) {\n+â”Š  â”Š 5â”Š\n+â”Š  â”Š 6â”Š}\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Štemplate <typename T>\n+â”Š  â”Š 9â”ŠNullable<T>::Nullable(): _initialized(false) {\n+â”Š  â”Š10â”Š\n+â”Š  â”Š11â”Š}\n+â”Š  â”Š12â”Š\n+â”Š  â”Š13â”Štemplate <typename T>\n+â”Š  â”Š14â”ŠT Nullable<T>::getValue() const {\n+â”Š  â”Š15â”Š  return _value;\n+â”Š  â”Š16â”Š}\n+â”Š  â”Š17â”Š\n+â”Š  â”Š18â”Štemplate <typename T>\n+â”Š  â”Š19â”Švoid Nullable<T>::setValue(T value) {\n+â”Š  â”Š20â”Š  _value = value;\n+â”Š  â”Š21â”Š  _initialized = true;\n+â”Š  â”Š22â”Š}\n+â”Š  â”Š23â”Š\n+â”Š  â”Š24â”Štemplate <typename T>\n+â”Š  â”Š25â”Švoid Nullable<T>::resetValue() {\n+â”Š  â”Š26â”Š  _initialized = false;\n+â”Š  â”Š27â”Š}\n+â”Š  â”Š28â”Š\n+â”Š  â”Š29â”Štemplate <typename T>\n+â”Š  â”Š30â”Šbool Nullable<T>::hasValue() const {\n+â”Š  â”Š31â”Š  return _initialized == true;\n+â”Š  â”Š32â”Š}\n+â”Š  â”Š33â”Š\n+â”Š  â”Š34â”Štemplate <typename T>\n+â”Š  â”Š35â”Šbool Nullable<T>::isNull() const {\n+â”Š  â”Š36â”Š  return _initialized == false;\n+â”Š  â”Š37â”Š}ðŸš«â†µ\n```\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;nullable.h\n```diff\n@@ -0,0 +1,23 @@\n+â”Š  â”Š 1â”Š#pragma once\n+â”Š  â”Š 2â”Š\n+â”Š  â”Š 3â”Štemplate <typename T>\n+â”Š  â”Š 4â”Šclass Nullable {\n+â”Š  â”Š 5â”Šprivate:\n+â”Š  â”Š 6â”Š  T _value;\n+â”Š  â”Š 7â”Š  bool _initialized;\n+â”Š  â”Š 8â”Š\n+â”Š  â”Š 9â”Špublic:\n+â”Š  â”Š10â”Š  Nullable(T value);\n+â”Š  â”Š11â”Š\n+â”Š  â”Š12â”Š  Nullable();\n+â”Š  â”Š13â”Š\n+â”Š  â”Š14â”Š  T getValue() const;\n+â”Š  â”Š15â”Š\n+â”Š  â”Š16â”Š  void setValue(T value);\n+â”Š  â”Š17â”Š\n+â”Š  â”Š18â”Š  void resetValue();\n+â”Š  â”Š19â”Š\n+â”Š  â”Š20â”Š  bool hasValue() const;\n+â”Š  â”Š21â”Š\n+â”Š  â”Š22â”Š  bool isNull() const;\n+â”Š  â”Š23â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nNow that all the necessary assets for the line class are ready, we can go ahead and create it:\n\n[{]: <helper> (diffStep 7.12)\n\n#### [Step 7.12: Add base line CPP module](https://github.com/DAB0mB/radial-snake/commit/9d17554)\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;geometry&#x2F;line.cpp\n```diff\n@@ -0,0 +1,99 @@\n+â”Š  â”Š 1â”Š#include \"../nullable.h\"\n+â”Š  â”Š 2â”Š#include \"../utils.h\"\n+â”Š  â”Š 3â”Š#include \"point.h\"\n+â”Š  â”Š 4â”Š#include \"line.h\"\n+â”Š  â”Š 5â”Š\n+â”Š  â”Š 6â”Šnamespace geometry {\n+â”Š  â”Š 7â”Š  // x1 - The first point's x value\n+â”Š  â”Š 8â”Š  // y1 - The first point's y value\n+â”Š  â”Š 9â”Š  // x1 - The second point's x value\n+â”Š  â”Š10â”Š  // y2 - The second point's y value\n+â”Š  â”Š11â”Š  Line::Line(double x1, double y1, double x2, double y2) {\n+â”Š  â”Š12â”Š    _x1 = utils::trim(x1, 9);\n+â”Š  â”Š13â”Š    _y1 = utils::trim(y1, 9);\n+â”Š  â”Š14â”Š    _x2 = utils::trim(x2, 9);\n+â”Š  â”Š15â”Š    _y2 = utils::trim(y2, 9);\n+â”Š  â”Š16â”Š  }\n+â”Š  â”Š17â”Š\n+â”Š  â”Š18â”Š  // Gets the matching x value for a given y value\n+â”Š  â”Š19â”Š  Nullable<double> Line::getMatchingX(double y) {\n+â”Š  â”Š20â”Š    // If an error was thrown it means we divided a number by zero,\n+â”Š  â”Š21â”Š    // in which case there is not intersection point\n+â”Š  â”Š22â”Š    double x = utils::trim(\n+â”Š  â”Š23â”Š      (((y - _y1) * (_x2 - _x1)) /\n+â”Š  â”Š24â”Š       (_y2 - _y1)) + _x1\n+â”Š  â”Š25â”Š    , 9, \"exact\");\n+â”Š  â”Š26â”Š\n+â”Š  â”Š27â”Š    // Check if result is in values range\n+â”Š  â”Š28â”Š    if (utils::isBetween(x, _x1, _x2, \"round\")) {\n+â”Š  â”Š29â”Š      return Nullable<double>(x);\n+â”Š  â”Š30â”Š    }\n+â”Š  â”Š31â”Š\n+â”Š  â”Š32â”Š    return Nullable<double>();\n+â”Š  â”Š33â”Š  }\n+â”Š  â”Š34â”Š\n+â”Š  â”Š35â”Š  // Gets the matching y value for a given x value\n+â”Š  â”Š36â”Š  Nullable<double> Line::getMatchingY(double x) {\n+â”Š  â”Š37â”Š    // If an error was thrown it means we divided a number by zero,\n+â”Š  â”Š38â”Š    // in which case there is not intersection point\n+â”Š  â”Š39â”Š    double y = utils::trim(\n+â”Š  â”Š40â”Š      (((x - _x1) * (_y2 - _y1)) /\n+â”Š  â”Š41â”Š       (_x2 - _x1)) + _y1\n+â”Š  â”Š42â”Š    , 9, \"exact\");\n+â”Š  â”Š43â”Š\n+â”Š  â”Š44â”Š    // Check if result is in values range\n+â”Š  â”Š45â”Š    if (utils::isBetween(y, _y1, _y2, \"round\")) {\n+â”Š  â”Š46â”Š      return Nullable<double>(y);\n+â”Š  â”Š47â”Š    }\n+â”Š  â”Š48â”Š\n+â”Š  â”Š49â”Š    return Nullable<double>();\n+â”Š  â”Š50â”Š  }\n+â”Š  â”Š51â”Š\n+â”Š  â”Š52â”Š  // Returns if line has given point\n+â”Š  â”Š53â”Š  bool Line::hasPoint(double x, double y) {\n+â”Š  â”Š54â”Š    if (!boundsHavePoint(x, y)) return 0;\n+â”Š  â”Š55â”Š\n+â”Š  â”Š56â”Š    double m = utils::trim(\n+â”Š  â”Š57â”Š      (_y2 - _y1) / (_x2 - _x1),\n+â”Š  â”Š58â”Š    9, \"exact\");\n+â”Š  â”Š59â”Š\n+â”Š  â”Š60â”Š    return (y - _y1) / (x - _x1) == m;\n+â”Š  â”Š61â”Š  }\n+â”Š  â”Š62â”Š\n+â”Š  â”Š63â”Š  // Returns if given point is contained by the bounds aka cage of line\n+â”Š  â”Š64â”Š  bool Line::boundsHavePoint(double x, double y) {\n+â”Š  â”Š65â”Š    return utils::isBetween(x, _x1, _x2, \"round\") &&\n+â”Š  â”Š66â”Š           utils::isBetween(y, _y1, _y2, \"round\");\n+â”Š  â”Š67â”Š  }\n+â”Š  â”Š68â”Š\n+â”Š  â”Š69â”Š  // line - line intersection method\n+â”Š  â”Š70â”Š  Nullable<Point> Line::getIntersection(Line line) {\n+â”Š  â”Š71â”Š    // Escape if lines are parallel\n+â”Š  â”Š72â”Š    if (!(((_x1 - _x2) * (line._y1 - line._y2)) -\n+â”Š  â”Š73â”Š          ((_y1 - _y2) * (line._x1 - line._x2))))\n+â”Š  â”Š74â”Š      return Nullable<Point>();\n+â”Š  â”Š75â”Š\n+â”Š  â”Š76â”Š    // Intersection point formula\n+â”Š  â”Š77â”Š    double x = utils::trim(\n+â”Š  â”Š78â”Š      ((((_x1 * _y2) - (_y1 * _x2)) * (line._x1 - line._x2)) -\n+â”Š  â”Š79â”Š       ((_x1 - _x2) * ((line._x1 * line._y2) - (line._y1 * line._x2)))) /\n+â”Š  â”Š80â”Š      (((_x1 - _x2) * (line._y1 - line._y2)) - ((_y1 - _y2) *\n+â”Š  â”Š81â”Š        (line._x1 - line._x2)))\n+â”Š  â”Š82â”Š    , 9, \"exact\");\n+â”Š  â”Š83â”Š    double y = utils::trim(\n+â”Š  â”Š84â”Š      ((((_x1 * _y2) - (_y1 * _x2)) * (line._y1 - line._y2)) -\n+â”Š  â”Š85â”Š       ((_y1 - _y2) * ((line._x1 * line._y2) - (line._y1 * line._x2)))) /\n+â”Š  â”Š86â”Š      (((_x1 - _x2) * (line._y1 - line._y2)) - ((_y1 - _y2) *\n+â”Š  â”Š87â”Š        (line._x1 - line._x2)))\n+â”Š  â”Š88â”Š    , 9, \"exact\");\n+â”Š  â”Š89â”Š\n+â”Š  â”Š90â”Š    if (utils::isBetween(x, _x1, _x2, \"round\") &&\n+â”Š  â”Š91â”Š        utils::isBetween(x, line._x1, line._x2, \"round\") &&\n+â”Š  â”Š92â”Š        utils::isBetween(y, _y1, _y2, \"round\") &&\n+â”Š  â”Š93â”Š        utils::isBetween(y, line._y1, line._y2, \"round\")) {\n+â”Š  â”Š94â”Š      return Nullable<Point>({ x, y });\n+â”Š  â”Š95â”Š    }\n+â”Š  â”Š96â”Š\n+â”Š  â”Š97â”Š    return Nullable<Point>();\n+â”Š  â”Š98â”Š  }\n+â”Š  â”Š99â”Š}ðŸš«â†µ\n```\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;geometry&#x2F;line.h\n```diff\n@@ -0,0 +1,30 @@\n+â”Š  â”Š 1â”Š#pragma once\n+â”Š  â”Š 2â”Š\n+â”Š  â”Š 3â”Š#include <vector>\n+â”Š  â”Š 4â”Š#include \"../nullable.h\"\n+â”Š  â”Š 5â”Š#include \"point.h\"\n+â”Š  â”Š 6â”Š\n+â”Š  â”Š 7â”Šnamespace geometry {\n+â”Š  â”Š 8â”Š  class Circle;\n+â”Š  â”Š 9â”Š  class EMCircle;\n+â”Š  â”Š10â”Š\n+â”Š  â”Š11â”Š  class Line {\n+â”Š  â”Š12â”Š  public:\n+â”Š  â”Š13â”Š    double _x1;\n+â”Š  â”Š14â”Š    double _y1;\n+â”Š  â”Š15â”Š    double _x2;\n+â”Š  â”Š16â”Š    double _y2;\n+â”Š  â”Š17â”Š\n+â”Š  â”Š18â”Š    Line(double x1, double y1, double x2, double y2);\n+â”Š  â”Š19â”Š\n+â”Š  â”Š20â”Š    Nullable<double> getMatchingX(double y);\n+â”Š  â”Š21â”Š\n+â”Š  â”Š22â”Š    Nullable<double> getMatchingY(double x);\n+â”Š  â”Š23â”Š\n+â”Š  â”Š24â”Š    bool hasPoint(double x, double y);\n+â”Š  â”Š25â”Š\n+â”Š  â”Š26â”Š    bool boundsHavePoint(double x, double y);\n+â”Š  â”Š27â”Š\n+â”Š  â”Š28â”Š    Nullable<Point> getIntersection(Line line);\n+â”Š  â”Š29â”Š  };\n+â”Š  â”Š30â”Š}ðŸš«â†µ\n```\n\n##### Changed resources&#x2F;cpp&#x2F;src&#x2F;index.cpp\n```diff\n@@ -1,2 +1,3 @@\n â”Š1â”Š1â”Š#include \"nullable.cpp\"\n-â”Š2â”Š â”Š#include \"utils.cpp\"ðŸš«â†µ\n+â”Š â”Š2â”Š#include \"utils.cpp\"\n+â”Š â”Š3â”Š#include \"geometry/line.cpp\"ðŸš«â†µ\n```\n\n[}]: #\n\nAfter creating our C++, we will also need to bind it using EMBind:\n\n[{]: <helper> (diffStep 7.13)\n\n#### [Step 7.13: EMBind CPP line](https://github.com/DAB0mB/radial-snake/commit/8920ddf)\n\n##### Changed resources&#x2F;cpp&#x2F;post.js\n```diff\n@@ -4,6 +4,10 @@\n â”Š 4â”Š 4â”Š    trim: Module.utils_trim,\n â”Š 5â”Š 5â”Š    isBetween: Module.utils_isBetween,\n â”Š 6â”Š 6â”Š    compare: Module.utils_compare\n+â”Š  â”Š 7â”Š  },\n+â”Š  â”Š 8â”Š\n+â”Š  â”Š 9â”Š  Geometry: {\n+â”Š  â”Š10â”Š    Line: Module.geometry_line\n â”Š 7â”Š11â”Š  }\n â”Š 8â”Š12â”Š};\n â”Š 9â”Š13â”Š\n```\n\n##### Changed resources&#x2F;cpp&#x2F;src&#x2F;geometry&#x2F;line.cpp\n```diff\n@@ -1,3 +1,6 @@\n+â”Š â”Š1â”Š#include <vector>\n+â”Š â”Š2â”Š#include <emscripten/bind.h>\n+â”Š â”Š3â”Š#include <emscripten/val.h>\n â”Š1â”Š4â”Š#include \"../nullable.h\"\n â”Š2â”Š5â”Š#include \"../utils.h\"\n â”Š3â”Š6â”Š#include \"point.h\"\n```\n```diff\n@@ -96,4 +99,52 @@\n â”Š 96â”Š 99â”Š\n â”Š 97â”Š100â”Š    return Nullable<Point>();\n â”Š 98â”Š101â”Š  }\n+â”Š   â”Š102â”Š\n+â”Š   â”Š103â”Š  emscripten::val EMLine::getMatchingX(double y) {\n+â”Š   â”Š104â”Š    Nullable<double> nullableX = Line::getMatchingX(y);\n+â”Š   â”Š105â”Š    return nullableX.hasValue() ?\n+â”Š   â”Š106â”Š      emscripten::val(nullableX.getValue()) :\n+â”Š   â”Š107â”Š      emscripten::val::undefined();\n+â”Š   â”Š108â”Š  }\n+â”Š   â”Š109â”Š\n+â”Š   â”Š110â”Š  emscripten::val EMLine::getMatchingY(double x) {\n+â”Š   â”Š111â”Š    Nullable<double> nullableY = Line::getMatchingY(x);\n+â”Š   â”Š112â”Š    return nullableY.hasValue() ?\n+â”Š   â”Š113â”Š      emscripten::val(nullableY.getValue()) :\n+â”Š   â”Š114â”Š      emscripten::val::undefined();\n+â”Š   â”Š115â”Š  }\n+â”Š   â”Š116â”Š\n+â”Š   â”Š117â”Š  emscripten::val EMLine::getIntersection(EMLine emLine) {\n+â”Š   â”Š118â”Š    Line line = Line(emLine._x1, emLine._y1, emLine._x2, emLine._y2);\n+â”Š   â”Š119â”Š    Nullable<Point> nullablePoint = Line::getIntersection(line);\n+â”Š   â”Š120â”Š\n+â”Š   â”Š121â”Š    if (nullablePoint.isNull()) return emscripten::val::undefined();\n+â”Š   â”Š122â”Š\n+â”Š   â”Š123â”Š    Point point = nullablePoint.getValue();\n+â”Š   â”Š124â”Š    emscripten::val emPoint = emscripten::val::object();\n+â”Š   â”Š125â”Š    emPoint.set(\"x\", emscripten::val(point.x));\n+â”Š   â”Š126â”Š    emPoint.set(\"y\", emscripten::val(point.y));\n+â”Š   â”Š127â”Š    return emPoint;\n+â”Š   â”Š128â”Š  }\n+â”Š   â”Š129â”Š}\n+â”Š   â”Š130â”Š\n+â”Š   â”Š131â”ŠEMSCRIPTEN_BINDINGS(geometry_line_module) {\n+â”Š   â”Š132â”Š  emscripten::class_<geometry::Line>(\"geometry_line_base\")\n+â”Š   â”Š133â”Š    .constructor<double, double, double, double>()\n+â”Š   â”Š134â”Š    .property<double>(\"x1\", &geometry::Line::_x1)\n+â”Š   â”Š135â”Š    .property<double>(\"y1\", &geometry::Line::_y1)\n+â”Š   â”Š136â”Š    .property<double>(\"x2\", &geometry::Line::_x2)\n+â”Š   â”Š137â”Š    .property<double>(\"y2\", &geometry::Line::_y2)\n+â”Š   â”Š138â”Š    .function(\"hasPoint\", &geometry::Line::hasPoint)\n+â”Š   â”Š139â”Š    .function(\"boundsHavePoint\", &geometry::Line::boundsHavePoint);\n+â”Š   â”Š140â”Š\n+â”Š   â”Š141â”Š  emscripten::class_<geometry::EMLine, emscripten::base<geometry::Line>>(\"geometry_line\")\n+â”Š   â”Š142â”Š    .constructor<double, double, double, double>()\n+â”Š   â”Š143â”Š    .function(\"getX\", &geometry::EMLine::getMatchingX)\n+â”Š   â”Š144â”Š    .function(\"getY\", &geometry::EMLine::getMatchingY)\n+â”Š   â”Š145â”Š    .function(\"getLineIntersection\",\n+â”Š   â”Š146â”Š      emscripten::select_overload<emscripten::val(geometry::EMLine)>(\n+â”Š   â”Š147â”Š        &geometry::EMLine::getIntersection\n+â”Š   â”Š148â”Š      )\n+â”Š   â”Š149â”Š    );\n â”Š 99â”Š150â”Š}ðŸš«â†µ\n```\n\n##### Changed resources&#x2F;cpp&#x2F;src&#x2F;geometry&#x2F;line.h\n```diff\n@@ -1,6 +1,7 @@\n â”Š1â”Š1â”Š#pragma once\n â”Š2â”Š2â”Š\n â”Š3â”Š3â”Š#include <vector>\n+â”Š â”Š4â”Š#include <emscripten/val.h>\n â”Š4â”Š5â”Š#include \"../nullable.h\"\n â”Š5â”Š6â”Š#include \"point.h\"\n â”Š6â”Š7â”Š\n```\n```diff\n@@ -27,4 +28,15 @@\n â”Š27â”Š28â”Š\n â”Š28â”Š29â”Š    Nullable<Point> getIntersection(Line line);\n â”Š29â”Š30â”Š  };\n+â”Š  â”Š31â”Š\n+â”Š  â”Š32â”Š  class EMLine : public Line {\n+â”Š  â”Š33â”Š  public:\n+â”Š  â”Š34â”Š    using Line::Line;\n+â”Š  â”Š35â”Š\n+â”Š  â”Š36â”Š    emscripten::val getMatchingX(double y);\n+â”Š  â”Š37â”Š\n+â”Š  â”Š38â”Š    emscripten::val getMatchingY(double x);\n+â”Š  â”Š39â”Š\n+â”Š  â”Š40â”Š    emscripten::val getIntersection(EMLine line);\n+â”Š  â”Š41â”Š  };\n â”Š30â”Š42â”Š}ðŸš«â†µ\n```\n\n[}]: #\n\nIn the code snippet above, you can see that we used a special data-type called `val` (`emscripten::val`). `val` means that just like JavaScript, that function can return values that are not necessarily of the same data-type; For instance, the `getMatchingY` function can either return a `number` or `undefined`. If you'll take a look at the `getIntersection(Line)` method you'll notice that instead of returning the raw point structure, I chose to build a JavaScript object using the `object` data type (`emscripten::object`). `object` behaves exactly like a native JavaScript `Object`, and it can save us some precious work of binding which sometimes might be just too much.\n\nIf you'll compare the C++ version of the line class to the JavaScript line class you'll notice that the `draw` and `getIntersection` methods are missing (when we used EMBind we renamed `getIntersection` to `getLineIntersection` because overloadings are forbidden). In addition, Emscripten's API exposes some additional class methods for generated C++ classes, like the `delete` method, which we will shed light on further in this tutorial. Inheritance would be the natural solution for such an issue, unfortunately, generated C++ constructors don't accept indirect instances. For example, if we have a C++ parent class called `Shape` and we have a JavaScript child class called `Line`, we won't be able to initialize a new instance of the `Line` class. Here's a demonstration:\n\n```js\nclass JSLine extends CPPShape {}\nconst line = new JSLine(); // Throws error\n```\n\nThere are 3 ways to implement inheritance when interacting with C++ classes:\n\n- Define an interface when using EMBind. This is the official way but rather complicated, since it requires us to define an extra layer for our wrapper. More information can be found [here](https://kripken.github.io/emscripten-site/docs/porting/connecting_cpp_and_javascript/embind.html#abstract-methods).\n- Extending the prototype of exported C++ classes directly, which is not really an inheritance.\n- Using a proxy class, which is the easiest and cleanest solution of all, but it is not really mentioned anywhere. At the same time, I didn't find any restriction regards that.\n\nWe're gonna use the 3rd method in the list above, because as I said, it's the easiest and cleanest of all. First I will try to explain what I meant by saying \"proxy class\". If you're an intermediate JavaScript developer, you probably know that constructors can be overridden by returning a value explicitly. By doing that, we can actually bypass Emscripten's prohibitions, we can just return the newly created C++ instance and extend it in specific. Proxy classes actually take it a step further by providing a middle-class which will then inject a new link to the prototype chain of the returned instance.\n\n```js\nclass JSLine {\n  constructor() {\n    const line = new CPPShape();\n    return line;\n  }\n}\n\nconst line = new JSLine(); // Legal!\n```\n\n> More information about the code snippet above can be found [here](https://www.bennadel.com/blog/2522-providing-a-return-value-in-a-javascript-constructor.htm).\n\nI believe that as we go through this tutorial, the concept will get much clearer. The utility function of the proxy class should look like so:\n\n[{]: <helper> (diffStep 7.14)\n\n#### [Step 7.14: Add proxy utility method](https://github.com/DAB0mB/radial-snake/commit/06e615e)\n\n##### Changed resources&#x2F;scripts&#x2F;utils.js\n```diff\n@@ -20,5 +20,18 @@\n â”Š20â”Š20â”Š  // Overload handling\n â”Š21â”Š21â”Š  compare(context, num, method, precision = method) {\n â”Š22â”Š22â”Š    return CPP.Utils.compare(context, num, method, precision);\n+â”Š  â”Š23â”Š  },\n+â”Š  â”Š24â”Š\n+â”Š  â”Š25â”Š  proxy(Class) {\n+â”Š  â”Š26â”Š    return class extends Class {\n+â”Š  â”Š27â”Š      constructor() {\n+â”Š  â”Š28â”Š        // Initialize original class\n+â”Š  â”Š29â”Š        let that = new Class(...arguments);\n+â”Š  â”Š30â”Š        // Inject caller's prototype into the prototype chain\n+â”Š  â”Š31â”Š        Object.setPrototypeOf(that, new.target.prototype);\n+â”Š  â”Š32â”Š        // Will original instance will be the substitute for 'this'\n+â”Š  â”Š33â”Š        return that;\n+â”Š  â”Š34â”Š      }\n+â”Š  â”Š35â”Š    }\n â”Š23â”Š36â”Š  }\n â”Š24â”Š37â”Š});ðŸš«â†µ\n```\n\n[}]: #\n\nIf you'll take a look at the following line:\n\n```js\nObject.setPrototypeOf(that, new.target.prototype);\n```\n\nThis is where the magic actually happens! It enables inheritance for explicitly returned objects; This way we can safely extend C++ classes. Accordingly, our new JavaScript line class should look like so:\n\n[{]: <helper> (diffStep 7.15)\n\n#### [Step 7.15: Extend CPP line class](https://github.com/DAB0mB/radial-snake/commit/66acf9d)\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;geometry&#x2F;line.js\n```diff\n@@ -1,46 +1,10 @@\n-â”Š 1â”Š  â”ŠEngine.Geometry.Line = class Line {\n-â”Š 2â”Š  â”Š  // x1 - The first point's x value\n-â”Š 3â”Š  â”Š  // y1 - The first point's y value\n-â”Š 4â”Š  â”Š  // x1 - The second point's x value\n-â”Š 5â”Š  â”Š  // y2 - The second point's y value\n-â”Š 6â”Š  â”Š  constructor(x1, y1, x2, y2) {\n-â”Š 7â”Š  â”Š    this.x1 = Utils.trim(x1, 9);\n-â”Š 8â”Š  â”Š    this.y1 = Utils.trim(y1, 9);\n-â”Š 9â”Š  â”Š    this.x2 = Utils.trim(x2, 9);\n-â”Š10â”Š  â”Š    this.y2 = Utils.trim(y2, 9);\n-â”Š11â”Š  â”Š  }\n-â”Š12â”Š  â”Š\n+â”Š  â”Š 1â”ŠEngine.Geometry.Line = class Line extends Utils.proxy(CPP.Geometry.Line) {\n â”Š13â”Š 2â”Š  // Draws the line on the given context\n â”Š14â”Š 3â”Š  draw(context) {\n â”Š15â”Š 4â”Š    context.moveTo(this.x1, this.y1);\n â”Š16â”Š 5â”Š    context.lineTo(this.x2, this.y2);\n â”Š17â”Š 6â”Š  }\n â”Š18â”Š 7â”Š\n-â”Š19â”Š  â”Š  // Gets the matching x value for a given y value\n-â”Š20â”Š  â”Š  getX(y) {\n-â”Š21â”Š  â”Š    let x = Utils.trim((((y - this.y1) * (this.x2 - this.x1)) / (this.y2 - this.y1)) + this.x1, 9);\n-â”Š22â”Š  â”Š    if (isNaN(x) || Utils.isBetween(x, this.x1, this.x2)) return x;\n-â”Š23â”Š  â”Š  }\n-â”Š24â”Š  â”Š\n-â”Š25â”Š  â”Š  // Gets the matching y value for a given x value\n-â”Š26â”Š  â”Š  getY(x) {\n-â”Š27â”Š  â”Š    let y = Utils.trim((((x - this.x1) * (this.y2 - this.y1)) / (this.x2 - this.x1)) + this.y1, 9);\n-â”Š28â”Š  â”Š    if (isNaN(y) || Utils.isBetween(y, this.y1, this.y2)) return y;\n-â”Š29â”Š  â”Š  }\n-â”Š30â”Š  â”Š\n-â”Š31â”Š  â”Š  // Returns if line has given point\n-â”Š32â”Š  â”Š  hasPoint(x, y) {\n-â”Š33â”Š  â”Š    if (!this.boundsHavePoint(x, y)) return false;\n-â”Š34â”Š  â”Š    let m = Utils.trim((this.y2 - this.y1) / (this.x2 - this.x1), 9);\n-â”Š35â”Š  â”Š    return (y - this.y1) / (x - this.x1) == m;\n-â”Š36â”Š  â”Š  }\n-â”Š37â”Š  â”Š\n-â”Š38â”Š  â”Š  // Returns if given point is contained by the bounds aka cage of line\n-â”Š39â”Š  â”Š  boundsHavePoint(x, y) {\n-â”Š40â”Š  â”Š    return Utils.isBetween(x, this.x1, this.x2) &&\n-â”Š41â”Š  â”Š           Utils.isBetween(y, this.y1, this.y2);\n-â”Š42â”Š  â”Š  }\n-â”Š43â”Š  â”Š\n â”Š44â”Š 8â”Š  getIntersection(shape) {\n â”Š45â”Š 9â”Š    if (shape instanceof Engine.Geometry.Line)\n â”Š46â”Š10â”Š      return this.getLineIntersection(shape);\n```\n```diff\n@@ -50,23 +14,6 @@\n â”Š50â”Š14â”Š      return this.getPolygonIntersection(shape);\n â”Š51â”Š15â”Š  }\n â”Š52â”Š16â”Š\n-â”Š53â”Š  â”Š  // line - line intersection method\n-â”Š54â”Š  â”Š  getLineIntersection(line) {\n-â”Š55â”Š  â”Š    // Escape if lines are parallel\n-â”Š56â”Š  â”Š    if (!(((this.x1 - this.x2) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * (line.x1 - line.x2)))) return;\n-â”Š57â”Š  â”Š\n-â”Š58â”Š  â”Š    // Intersection point formula\n-â”Š59â”Š  â”Š    let x = Utils.trim(((((this.x1 * this.y2) - (this.y1 * this.x2)) * (line.x1 - line.x2)) - ((this.x1 - this.x2) * ((line.x1 * line.y2) - (line.y1 * line.x2)))) /\n-â”Š60â”Š  â”Š        (((this.x1 - this.x2) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * (line.x1 - line.x2))), 9);\n-â”Š61â”Š  â”Š    let y = Utils.trim(((((this.x1 * this.y2) - (this.y1 * this.x2)) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * ((line.x1 * line.y2) - (line.y1 * line.x2)))) /\n-â”Š62â”Š  â”Š        (((this.x1 - this.x2) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * (line.x1 - line.x2))), 9);\n-â”Š63â”Š  â”Š\n-â”Š64â”Š  â”Š    if (Utils.isBetween(x, this.x1, this.x2) && Utils.isBetween(x, line.x1, line.x2) &&\n-â”Š65â”Š  â”Š        Utils.isBetween(y, this.y1, this.y2) && Utils.isBetween(y, line.y1, line.y2)) {\n-â”Š66â”Š  â”Š      return { x, y };\n-â”Š67â”Š  â”Š    }\n-â”Š68â”Š  â”Š  }\n-â”Š69â”Š  â”Š\n â”Š70â”Š17â”Š  // line - circle intersection method\n â”Š71â”Š18â”Š  getCircleIntersection(circle) {\n â”Š72â”Š19â”Š    return circle.getLineIntersection(this);\n```\n\n[}]: #\n\nBy now, our tests should pass. Accept, there is memory leak we need to handle. But you probably ask yourself - \"What memory leak? It's JavaScript man! Have you ever heard of something called garbage collector?!\". Well, this is not the case when compiling C++ code with Emscripten. You see, Emscripten uses asm.js, which is a subset for JavaScript built exactly for these proposes, enabling C++ modules run on the browser. This is how the [WebGL](https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API) project actually started, an almost complete conversion from the famous C++ [OpenGL](https://www.opengl.org/) to JavaScript. Part of what asm.js does, it disables the garbage collector, and instead, it holds raw pointers, just like in C++. Since returned class instances are pointers with unknown lifespans, they need to be disposed manually, using the `delete` method (identical to how we clear memory from the Heap in C++). Let's dispose unused test data by calling the `delete` method as just mentioned:\n\n[{]: <helper> (diffStep 7.16)\n\n#### [Step 7.16: Delete line instances in tests](https://github.com/DAB0mB/radial-snake/commit/f181da4)\n\n##### Changed resources&#x2F;scripts&#x2F;specs&#x2F;engine&#x2F;geometry&#x2F;circle.js\n```diff\n@@ -111,6 +111,8 @@\n â”Š111â”Š111â”Š          { x: 6, y: 1 },\n â”Š112â”Š112â”Š          { x: -4, y: 1 }\n â”Š113â”Š113â”Š        ]);\n+â”Š   â”Š114â”Š\n+â”Š   â”Š115â”Š        line.delete();\n â”Š114â”Š116â”Š      });\n â”Š115â”Š117â”Š    });\n â”Š116â”Š118â”Š\n```\n```diff\n@@ -121,6 +123,8 @@\n â”Š121â”Š123â”Š        expect(this.circle.getLineIntersection(line)).toEqual([\n â”Š122â”Š124â”Š          { x: -4, y: 1 }\n â”Š123â”Š125â”Š        ]);\n+â”Š   â”Š126â”Š\n+â”Š   â”Š127â”Š        line.delete();\n â”Š124â”Š128â”Š      });\n â”Š125â”Š129â”Š    });\n â”Š126â”Š130â”Š\n```\n```diff\n@@ -131,6 +135,8 @@\n â”Š131â”Š135â”Š        expect(this.circle.getLineIntersection(line)).toEqual([\n â”Š132â”Š136â”Š          { x: 1, y: 6 }\n â”Š133â”Š137â”Š        ]);\n+â”Š   â”Š138â”Š\n+â”Š   â”Š139â”Š        line.delete();\n â”Š134â”Š140â”Š      });\n â”Š135â”Š141â”Š    });\n â”Š136â”Š142â”Š\n```\n```diff\n@@ -138,6 +144,7 @@\n â”Š138â”Š144â”Š      it(\"returns nothing\", function() {\n â”Š139â”Š145â”Š        let line = new Engine.Geometry.Line(-10, 10, 10, 10);\n â”Š140â”Š146â”Š        expect(this.circle.getLineIntersection(line)).toBeUndefined();\n+â”Š   â”Š147â”Š        line.delete();\n â”Š141â”Š148â”Š      });\n â”Š142â”Š149â”Š    });\n â”Š143â”Š150â”Š  });\n```\n\n##### Changed resources&#x2F;scripts&#x2F;specs&#x2F;engine&#x2F;geometry&#x2F;line.js\n```diff\n@@ -3,6 +3,10 @@\n â”Š 3â”Š 3â”Š    this.line = new Engine.Geometry.Line(-5, -5, 5, 5);\n â”Š 4â”Š 4â”Š  });\n â”Š 5â”Š 5â”Š\n+â”Š  â”Š 6â”Š  afterEach(function () {\n+â”Š  â”Š 7â”Š    this.line.delete();\n+â”Š  â”Š 8â”Š  });\n+â”Š  â”Š 9â”Š\n â”Š 6â”Š10â”Š  describe(\"getX method\", function() {\n â”Š 7â”Š11â”Š    describe(\"given inranged y\", function() {\n â”Š 8â”Š12â”Š      it(\"returns x\", function() {\n```\n```diff\n@@ -58,6 +62,8 @@\n â”Š58â”Š62â”Š          x: 1,\n â”Š59â”Š63â”Š          y: 1\n â”Š60â”Š64â”Š        });\n+â”Š  â”Š65â”Š\n+â”Š  â”Š66â”Š        line.delete();\n â”Š61â”Š67â”Š      });\n â”Š62â”Š68â”Š    });\n â”Š63â”Š69â”Š\n```\n```diff\n@@ -65,6 +71,7 @@\n â”Š65â”Š71â”Š      it(\"returns nothing\", function() {\n â”Š66â”Š72â”Š        let line = new Engine.Geometry.Line(-5, -6, 5, 4);\n â”Š67â”Š73â”Š        expect(this.line.getLineIntersection(line)).toBeUndefined();\n+â”Š  â”Š74â”Š        line.delete();\n â”Š68â”Š75â”Š      });\n â”Š69â”Š76â”Š    });\n â”Š70â”Š77â”Š\n```\n```diff\n@@ -72,6 +79,7 @@\n â”Š72â”Š79â”Š      it(\"returns nothing\", function() {\n â”Š73â”Š80â”Š        let line = new Engine.Geometry.Line(10, 10, 10, 15);\n â”Š74â”Š81â”Š        expect(this.line.getLineIntersection(line)).toBeUndefined();\n+â”Š  â”Š82â”Š        line.delete();\n â”Š75â”Š83â”Š      });\n â”Š76â”Š84â”Š    });\n â”Š77â”Š85â”Š  });\n```\n\n##### Changed resources&#x2F;scripts&#x2F;specs&#x2F;engine&#x2F;geometry&#x2F;polygon.js\n```diff\n@@ -35,6 +35,8 @@\n â”Š35â”Š35â”Š          { x: 5, y: 4 },\n â”Š36â”Š36â”Š          { x: 0, y: 1 }\n â”Š37â”Š37â”Š        ]);\n+â”Š  â”Š38â”Š\n+â”Š  â”Š39â”Š        line.delete();\n â”Š38â”Š40â”Š      });\n â”Š39â”Š41â”Š    });\n â”Š40â”Š42â”Š\n```\n```diff\n@@ -43,6 +45,8 @@\n â”Š43â”Š45â”Š        let line = new Engine.Geometry.Line(10, 11, 15, 14);\n â”Š44â”Š46â”Š\n â”Š45â”Š47â”Š        expect(this.polygon.getLineIntersection(line)).toBeUndefined();\n+â”Š  â”Š48â”Š\n+â”Š  â”Š49â”Š        line.delete();\n â”Š46â”Š50â”Š      });\n â”Š47â”Š51â”Š    });\n â”Š48â”Š52â”Š  });\n```\n\n[}]: #\n\nSince our game also uses polygons, which is made of an abstract number of lines, its test-data needs to be disposed as well. First, we will add a `delete` method to the polygon class, which will simply go though all its bounds and delete each of its lines:\n\n[{]: <helper> (diffStep 7.17)\n\n#### [Step 7.17: Add polygon deletion method](https://github.com/DAB0mB/radial-snake/commit/1c9447f)\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;geometry&#x2F;polygon.js\n```diff\n@@ -5,6 +5,10 @@\n â”Š 5â”Š 5â”Š    this.bounds = bounds.map(coords => new Engine.Geometry.Line(...coords));\n â”Š 6â”Š 6â”Š  }\n â”Š 7â”Š 7â”Š\n+â”Š  â”Š 8â”Š  delete() {\n+â”Š  â”Š 9â”Š    this.bounds.forEach(bound => bound.delete());\n+â”Š  â”Š10â”Š  }\n+â”Š  â”Š11â”Š\n â”Š 8â”Š12â”Š  // Returns if polygon has given point\n â”Š 9â”Š13â”Š  hasPoint(x, y) {\n â”Š10â”Š14â”Š    // Run check for each bound\n```\n\n[}]: #\n\nNow we can conveniently delete unused polygons in the tests:\n\n[{]: <helper> (diffStep 7.18)\n\n#### [Step 7.18: Delete polygon instances in tests](https://github.com/DAB0mB/radial-snake/commit/48024bc)\n\n##### Changed resources&#x2F;scripts&#x2F;specs&#x2F;engine&#x2F;geometry&#x2F;polygon.js\n```diff\n@@ -8,6 +8,10 @@\n â”Š 8â”Š 8â”Š    );\n â”Š 9â”Š 9â”Š  });\n â”Š10â”Š10â”Š\n+â”Š  â”Š11â”Š  afterEach(function () {\n+â”Š  â”Š12â”Š    this.polygon.delete();\n+â”Š  â”Š13â”Š  });\n+â”Š  â”Š14â”Š\n â”Š11â”Š15â”Š  describe(\"hasPoint method\", function() {\n â”Š12â”Š16â”Š    describe(\"given contained point\", function() {\n â”Š13â”Š17â”Š      it(\"returns true\", function() {\n```\n\n[}]: #\n\nMoving on, we have the circle class to transform. The process is almost the identical to how we transformed the line class, so it's gonna be way easier now. We first start by translating our code from JavaScript to C++:\n\n[{]: <helper> (diffStep 7.19)\n\n#### [Step 7.19: Add base circle CPP module](https://github.com/DAB0mB/radial-snake/commit/1a3fa58)\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;geometry&#x2F;circle.cpp\n```diff\n@@ -0,0 +1,202 @@\n+â”Š   â”Š  1â”Š\n+â”Š   â”Š  2â”Š#include <algorithm>\n+â”Š   â”Š  3â”Š#include <cmath>\n+â”Š   â”Š  4â”Š#include <vector>\n+â”Š   â”Š  5â”Š#include \"../nullable.h\"\n+â”Š   â”Š  6â”Š#include \"../utils.h\"\n+â”Š   â”Š  7â”Š#include \"point.h\"\n+â”Š   â”Š  8â”Š#include \"line.h\"\n+â”Š   â”Š  9â”Š\n+â”Š   â”Š 10â”Šnamespace geometry {\n+â”Š   â”Š 11â”Š  // x - The x value of the circle's center\n+â”Š   â”Š 12â”Š  // y - The y value of the circle's center\n+â”Š   â”Š 13â”Š  // r - The radius of the center\n+â”Š   â”Š 14â”Š  // rad1 - The first radian of the circle, not necessarily its beginning\n+â”Š   â”Š 15â”Š  // rad2 - The second radian of the circle, not necessarily its beginning\n+â”Š   â”Š 16â”Š  Circle::Circle(double x, double y, double r, double rad1, double rad2) {\n+â”Š   â”Š 17â”Š    _x = utils::trim(x, 9);\n+â”Š   â”Š 18â”Š    _y = utils::trim(y, 9);\n+â”Š   â”Š 19â”Š    _r = utils::trim(r, 9);\n+â”Š   â”Š 20â”Š\n+â”Š   â”Š 21â”Š    // Trimming mode is done based on which radian represents the ending and which radian\n+â”Š   â”Š 22â”Š    // represents the ending\n+â”Š   â”Š 23â”Š    if (rad1 > rad2) {\n+â”Š   â”Š 24â”Š      _rad1 = utils::trim(rad1, 9, \"floor\");\n+â”Š   â”Š 25â”Š      _rad2 = utils::trim(rad2, 9, \"ceil\");\n+â”Š   â”Š 26â”Š    }\n+â”Š   â”Š 27â”Š    else {\n+â”Š   â”Š 28â”Š      _rad1 = utils::trim(rad1, 9, \"ceil\");\n+â”Š   â”Š 29â”Š      _rad2 = utils::trim(rad2, 9, \"floor\");\n+â”Š   â”Š 30â”Š    }\n+â”Š   â”Š 31â”Š  }\n+â”Š   â”Š 32â”Š\n+â”Š   â”Š 33â”Š  // Gets the matching x value for the given radian\n+â”Š   â”Š 34â”Š  Nullable<double> Circle::getMatchingX(double rad) {\n+â”Š   â”Š 35â”Š    if (!utils::chain(rad)->trim(9)->isBetween(_rad1, _rad2)->result()) {\n+â”Š   â”Š 36â”Š      return Nullable<double>();\n+â”Š   â”Š 37â”Š    }\n+â”Š   â”Š 38â”Š\n+â”Š   â”Š 39â”Š    return Nullable<double>(utils::trim((_r * std::cos(rad)) + _x, 9));\n+â”Š   â”Š 40â”Š  }\n+â”Š   â”Š 41â”Š\n+â”Š   â”Š 42â”Š  // Gets the matching y value for the given radian\n+â”Š   â”Š 43â”Š  Nullable<double> Circle::getMatchingY(double rad) {\n+â”Š   â”Š 44â”Š    if (!utils::chain(rad)->trim(9)->isBetween(_rad1, _rad2)->result()) {\n+â”Š   â”Š 45â”Š      return Nullable<double>();\n+â”Š   â”Š 46â”Š    }\n+â”Š   â”Š 47â”Š\n+â”Š   â”Š 48â”Š    return Nullable<double>(utils::trim((_r * std::sin(rad)) + _y, 9));\n+â”Š   â”Š 49â”Š  }\n+â”Š   â”Š 50â”Š\n+â”Š   â”Š 51â”Š  // Gets the matching point for the given radian\n+â”Š   â”Š 52â”Š  Nullable<Point> Circle::getMatchingPoint(double rad) {\n+â”Š   â”Š 53â”Š    if (!utils::isBetween(rad, _rad1, _rad2)) {\n+â”Š   â”Š 54â”Š      return Nullable<Point>();\n+â”Š   â”Š 55â”Š    }\n+â”Š   â”Š 56â”Š\n+â”Š   â”Š 57â”Š    return Nullable<Point>({\n+â”Š   â”Š 58â”Š      utils::trim((_r * std::cos(rad)) + _x, 9),\n+â”Š   â”Š 59â”Š      utils::trim((_r * std::sin(rad)) + _y, 9)\n+â”Š   â”Š 60â”Š    });\n+â”Š   â”Š 61â”Š  }\n+â”Š   â”Š 62â”Š\n+â”Š   â”Š 63â”Š  // Gets the matching radian for the given point\n+â”Š   â”Š 64â”Š  Nullable<double> Circle::getMatchingRad(double x, double y) {\n+â”Š   â”Š 65â”Š    double rad = std::atan2(y - _y, x - _x);\n+â”Š   â”Š 66â”Š\n+â”Š   â”Š 67â”Š    // If calculated radian is in circle's radian range, return it\n+â”Š   â”Š 68â”Š    if (!std::isnan(rad) && utils::isBetween(rad, _rad1, _rad2)) {\n+â”Š   â”Š 69â”Š      return Nullable<double>(rad);\n+â”Š   â”Š 70â”Š    }\n+â”Š   â”Š 71â”Š\n+â”Š   â”Š 72â”Š    // The calculated radian can still be in the circle's radian range in case one\n+â”Š   â”Š 73â”Š    // of the radians is greater than 2 PIEs\n+â”Š   â”Š 74â”Š    double greatestRad = std::abs(_rad1) > std::abs(_rad2) ? _rad1 : _rad2;\n+â”Š   â”Š 75â”Š\n+â”Š   â”Š 76â”Š    // Check if the absolute radian is in the circle's radian range\n+â”Š   â”Š 77â”Š    if (utils::chain(rad + (2 * M_PI * std::floor(greatestRad / (2 * M_PI))))\n+â”Š   â”Š 78â”Š        ->trim(9)->isBetween(_rad1, _rad2)->result() ||\n+â”Š   â”Š 79â”Š        utils::chain(rad + (2 * M_PI * std::ceil(greatestRad / (2 * M_PI))))\n+â”Š   â”Š 80â”Š        ->trim(9)->isBetween(_rad1, _rad2)->result()) {\n+â”Š   â”Š 81â”Š      return Nullable<double>(rad);\n+â”Š   â”Š 82â”Š    }\n+â”Š   â”Š 83â”Š\n+â”Š   â”Š 84â”Š    return Nullable<double>();\n+â”Š   â”Š 85â”Š  }\n+â”Š   â”Š 86â”Š\n+â”Š   â”Š 87â”Š  // Returns if circle has given points\n+â”Š   â”Š 88â”Š  bool Circle::hasPoint(double x, double y) {\n+â”Š   â”Š 89â”Š    return getMatchingRad(x, y).hasValue();\n+â”Š   â”Š 90â”Š  }\n+â”Š   â”Š 91â”Š\n+â”Š   â”Š 92â”Š  // circle - circle intersection method\n+â”Š   â”Š 93â”Š  Nullable<std::vector<Point>> Circle::getIntersection(Circle circle) {\n+â”Š   â”Š 94â”Š    double dx = circle._x - _x;\n+â”Š   â”Š 95â”Š    double dy = circle._y - _y;\n+â”Š   â”Š 96â”Š    double d = std::sqrt(std::pow(dx, 2) + std::pow(dy, 2));\n+â”Š   â”Š 97â”Š\n+â”Š   â”Š 98â”Š    if (d > _r + circle._r ||\n+â”Š   â”Š 99â”Š       d < std::abs(_r - circle._r)) {\n+â”Š   â”Š100â”Š      return Nullable<std::vector<Point>>();\n+â”Š   â”Š101â”Š    }\n+â”Š   â”Š102â”Š\n+â”Š   â”Š103â”Š    double a = ((std::pow(_r, 2) - std::pow(circle._r, 2)) + std::pow(d, 2)) / (2 * d);\n+â”Š   â”Š104â”Š    double x = _x + ((dx * a) / d);\n+â”Š   â”Š105â”Š    double y = _y + ((dy * a) / d);\n+â”Š   â”Š106â”Š    double h = std::sqrt(std::pow(_r, 2) - std::pow(a, 2));\n+â”Š   â”Š107â”Š    double rx = (- dy * h) / d;\n+â”Š   â”Š108â”Š    double ry = (dx * h) / d;\n+â”Š   â”Š109â”Š\n+â”Š   â”Š110â”Š    std::vector<Point> interPoints(2);\n+â”Š   â”Š111â”Š    interPoints.at(0).x = x + rx;\n+â”Š   â”Š112â”Š    interPoints.at(0).y = y + ry;\n+â”Š   â”Š113â”Š    interPoints.at(1).x = x - rx;\n+â”Š   â”Š114â”Š    interPoints.at(1).y = y - ry;\n+â”Š   â”Š115â”Š\n+â”Š   â”Š116â”Š    for (unsigned i = 0; i < interPoints.size(); i++) {\n+â”Š   â”Š117â”Š      Point& point = interPoints.at(i);\n+â”Š   â”Š118â”Š      point.x = utils::trim(point.x, 9);\n+â”Š   â”Š119â”Š      point.y = utils::trim(point.y, 9);\n+â”Š   â”Š120â”Š    }\n+â”Š   â”Š121â”Š\n+â”Š   â”Š122â”Š    auto pointsBegin = std::unique(interPoints.begin(), interPoints.end(),\n+â”Š   â”Š123â”Š      [](Point pointA, Point pointB) {\n+â”Š   â”Š124â”Š        return pointA.x == pointB.x && pointA.y == pointB.y;\n+â”Š   â”Š125â”Š      }\n+â”Š   â”Š126â”Š    );\n+â”Š   â”Š127â”Š\n+â”Š   â”Š128â”Š    interPoints.erase(pointsBegin, interPoints.end());\n+â”Š   â”Š129â”Š\n+â”Š   â”Š130â”Š    std::vector<Circle> circles = { *this, circle };\n+â”Š   â”Š131â”Š\n+â”Š   â”Š132â”Š    std::for_each(circles.begin(), circles.end(), [&interPoints](Circle circle) {\n+â”Š   â”Š133â”Š      auto pointsBegin = std::remove_if(interPoints.begin(), interPoints.end(),\n+â”Š   â”Š134â”Š        [&circle](Point point) {\n+â”Š   â”Š135â”Š          return !circle.hasPoint(point.x, point.y);\n+â”Š   â”Š136â”Š        }\n+â”Š   â”Š137â”Š      );\n+â”Š   â”Š138â”Š\n+â”Š   â”Š139â”Š      interPoints.erase(pointsBegin, interPoints.end());\n+â”Š   â”Š140â”Š    });\n+â”Š   â”Š141â”Š\n+â”Š   â”Š142â”Š    if (interPoints.size()) {\n+â”Š   â”Š143â”Š      return Nullable<std::vector<Point>>(interPoints);\n+â”Š   â”Š144â”Š    }\n+â”Š   â”Š145â”Š\n+â”Š   â”Š146â”Š    return Nullable<std::vector<Point>>();\n+â”Š   â”Š147â”Š  }\n+â”Š   â”Š148â”Š\n+â”Š   â”Š149â”Š  // circle - line intersection method\n+â”Š   â”Š150â”Š  Nullable<std::vector<Point>> Circle::getIntersection(Line line) {\n+â”Š   â”Š151â”Š    double x1 = line._x1 - _x;\n+â”Š   â”Š152â”Š    double x2 = line._x2 - _x;\n+â”Š   â”Š153â”Š    double y1 = line._y1 - _y;\n+â”Š   â”Š154â”Š    double y2 = line._y2 - _y;\n+â”Š   â”Š155â”Š    double dx = x2 - x1;\n+â”Š   â”Š156â”Š    double dy = y2 - y1;\n+â”Š   â”Š157â”Š    double d = std::sqrt(std::pow(dx, 2) + std::pow(dy, 2));\n+â”Š   â”Š158â”Š    double h = (x1 * y2) - (x2 * y1);\n+â”Š   â”Š159â”Š    double delta = (std::pow(_r, 2) * std::pow(d, 2)) - std::pow(h, 2);\n+â”Š   â”Š160â”Š\n+â”Š   â”Š161â”Š    if (delta < 0) Nullable<std::vector<Point>>();\n+â”Š   â”Š162â”Š\n+â”Š   â”Š163â”Š    double sign = dy / std::abs(dy); if (std::isnan(sign)) sign = 1;\n+â”Š   â”Š164â”Š    double sqrtx = sign * dx * std::sqrt(delta);\n+â”Š   â”Š165â”Š    double sqrty = std::abs(dy) * std::sqrt(delta);\n+â”Š   â”Š166â”Š\n+â”Š   â”Š167â”Š    std::vector<Point> interPoints(2);\n+â”Š   â”Š168â”Š    interPoints.at(0).x = (((h * dy) + sqrtx) / std::pow(d, 2)) + _x;\n+â”Š   â”Š169â”Š    interPoints.at(0).y = (((-h * dx) + sqrty) / std::pow(d, 2)) + _y;\n+â”Š   â”Š170â”Š    interPoints.at(1).x = (((h * dy) - sqrtx) / std::pow(d, 2)) + _x;\n+â”Š   â”Š171â”Š    interPoints.at(1).y = (((-h * dx) - sqrty) / std::pow(d, 2)) + _y;\n+â”Š   â”Š172â”Š\n+â”Š   â”Š173â”Š    for (unsigned i = 0; i < interPoints.size(); i++) {\n+â”Š   â”Š174â”Š      Point& point = interPoints.at(i);\n+â”Š   â”Š175â”Š      point.x = utils::trim(point.x, 9);\n+â”Š   â”Š176â”Š      point.y = utils::trim(point.y, 9);\n+â”Š   â”Š177â”Š    }\n+â”Š   â”Š178â”Š\n+â”Š   â”Š179â”Š    auto pointsBegin = std::remove_if(interPoints.begin(), interPoints.end(),\n+â”Š   â”Š180â”Š      [this, &line](Point point) {\n+â”Š   â”Š181â”Š        return !hasPoint(point.x, point.y) ||\n+â”Š   â”Š182â”Š          !line.boundsHavePoint(point.x, point.y);\n+â”Š   â”Š183â”Š      }\n+â”Š   â”Š184â”Š    );\n+â”Š   â”Š185â”Š\n+â”Š   â”Š186â”Š    interPoints.erase(pointsBegin, interPoints.end());\n+â”Š   â”Š187â”Š\n+â”Š   â”Š188â”Š    pointsBegin = std::unique(interPoints.begin(), interPoints.end(),\n+â”Š   â”Š189â”Š      [](Point pointA, Point pointB) {\n+â”Š   â”Š190â”Š        return pointA.x == pointB.x && pointA.y == pointB.y;\n+â”Š   â”Š191â”Š      }\n+â”Š   â”Š192â”Š    );\n+â”Š   â”Š193â”Š\n+â”Š   â”Š194â”Š    interPoints.erase(pointsBegin, interPoints.end());\n+â”Š   â”Š195â”Š\n+â”Š   â”Š196â”Š    if (interPoints.size()) {\n+â”Š   â”Š197â”Š      return Nullable<std::vector<Point>>(interPoints);\n+â”Š   â”Š198â”Š    }\n+â”Š   â”Š199â”Š\n+â”Š   â”Š200â”Š    return Nullable<std::vector<Point>>();\n+â”Š   â”Š201â”Š  }\n+â”Š   â”Š202â”Š}ðŸš«â†µ\n```\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;geometry&#x2F;circle.h\n```diff\n@@ -0,0 +1,35 @@\n+â”Š  â”Š 1â”Š#pragma once\n+â”Š  â”Š 2â”Š\n+â”Š  â”Š 3â”Š#include <vector>\n+â”Š  â”Š 4â”Š#include \"../nullable.h\"\n+â”Š  â”Š 5â”Š#include \"point.h\"\n+â”Š  â”Š 6â”Š#include \"line.h\"\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Šnamespace geometry {\n+â”Š  â”Š 9â”Š  class Line;\n+â”Š  â”Š10â”Š\n+â”Š  â”Š11â”Š  class Circle {\n+â”Š  â”Š12â”Š  public:\n+â”Š  â”Š13â”Š    double _x;\n+â”Š  â”Š14â”Š    double _y;\n+â”Š  â”Š15â”Š    double _r;\n+â”Š  â”Š16â”Š    double _rad1;\n+â”Š  â”Š17â”Š    double _rad2;\n+â”Š  â”Š18â”Š\n+â”Š  â”Š19â”Š    Circle(double x, double y, double r, double rad1, double rad2);\n+â”Š  â”Š20â”Š\n+â”Š  â”Š21â”Š    Nullable<double> getMatchingX(double rad);\n+â”Š  â”Š22â”Š\n+â”Š  â”Š23â”Š    Nullable<double> getMatchingY(double rad);\n+â”Š  â”Š24â”Š\n+â”Š  â”Š25â”Š    Nullable<Point> getMatchingPoint(double rad);\n+â”Š  â”Š26â”Š\n+â”Š  â”Š27â”Š    Nullable<double> getMatchingRad(double x, double y);\n+â”Š  â”Š28â”Š\n+â”Š  â”Š29â”Š    bool hasPoint(double x, double y);\n+â”Š  â”Š30â”Š\n+â”Š  â”Š31â”Š    Nullable<std::vector<Point>> getIntersection(Circle circle);\n+â”Š  â”Š32â”Š\n+â”Š  â”Š33â”Š    Nullable<std::vector<Point>> getIntersection(Line line);\n+â”Š  â”Š34â”Š  };\n+â”Š  â”Š35â”Š}ðŸš«â†µ\n```\n\n##### Changed resources&#x2F;cpp&#x2F;src&#x2F;index.cpp\n```diff\n@@ -1,3 +1,4 @@\n â”Š1â”Š1â”Š#include \"nullable.cpp\"\n â”Š2â”Š2â”Š#include \"utils.cpp\"\n-â”Š3â”Š â”Š#include \"geometry/line.cpp\"ðŸš«â†µ\n+â”Š â”Š3â”Š#include \"geometry/line.cpp\"\n+â”Š â”Š4â”Š#include \"geometry/circle.cpp\"ðŸš«â†µ\n```\n\n[}]: #\n\nSecond, we need to wrap our code using EMBind:\n\n[{]: <helper> (diffStep 7.2)\n\n#### [Step 7.2: Add base utility CPP module](https://github.com/DAB0mB/radial-snake/commit/6dba512)\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;utils.cpp\n```diff\n@@ -0,0 +1,73 @@\n+â”Š  â”Š 1â”Š#include <cfloat>\n+â”Š  â”Š 2â”Š#include <cmath>\n+â”Š  â”Š 3â”Š#include <string>\n+â”Š  â”Š 4â”Š#include \"utils.h\"\n+â”Š  â”Š 5â”Š\n+â”Š  â”Š 6â”Šnamespace utils {\n+â”Š  â”Š 7â”Š  // Fixed modulo method which can calculate modulo of negative numbers properly\n+â”Š  â”Š 8â”Š  // e.g. (-803).mod(800) returns 797\n+â”Š  â”Š 9â”Š  double mod(double context, double num) {\n+â”Š  â”Š10â”Š    return std::fmod((std::fmod(context, num) + num), num);\n+â”Š  â”Š11â”Š  }\n+â”Š  â”Š12â”Š\n+â”Š  â”Š13â”Š  // Trims number and leaves the number of decimals specified.\n+â”Š  â”Š14â”Š  // The \"mode\" argument specifies which math function should be invoked\n+â”Š  â”Š15â”Š  // right after the number has been trimmed.\n+â”Š  â”Š16â”Š  // e.g. 12.12345.trim(3, \"ceil\") returns 12.124\n+â”Š  â”Š17â”Š  double trim(double context, int decimals, const std::string mode) {\n+â”Š  â”Š18â”Š    double accumulator = context * std::pow(10, decimals);\n+â”Š  â”Š19â”Š\n+â”Š  â”Š20â”Š    if (mode.compare(\"ceil\") == 0)\n+â”Š  â”Š21â”Š      accumulator = std::ceil(accumulator);\n+â”Š  â”Š22â”Š    else if (mode.compare(\"floor\") == 0)\n+â”Š  â”Š23â”Š      accumulator = std::floor(accumulator);\n+â”Š  â”Š24â”Š    else\n+â”Š  â”Š25â”Š      accumulator = std::round(accumulator);\n+â”Š  â”Š26â”Š\n+â”Š  â”Š27â”Š    return accumulator / std::pow(10, decimals);\n+â”Š  â”Š28â”Š  }\n+â”Š  â”Š29â”Š\n+â”Š  â”Š30â”Š  // Tells if number is in specified range based on given precision.\n+â”Š  â”Š31â”Š  // See the \"compare\" method for more information about precision\n+â”Š  â”Š32â”Š  bool isBetween(double context, double num1, double num2, const std::string precision) {\n+â”Š  â”Š33â”Š    return compare(context, std::min(num1, num2), \">=\", precision) &&\n+â”Š  â”Š34â”Š           compare(context, std::max(num1, num2), \"<=\", precision);\n+â”Š  â”Š35â”Š  }\n+â”Š  â”Š36â”Š\n+â”Š  â”Š37â”Š  bool compare(double context, double num, const std::string precision) {\n+â”Š  â”Š38â”Š    return compare(context, num, \"==\", precision);\n+â”Š  â”Š39â”Š  }\n+â”Š  â”Š40â”Š\n+â”Š  â”Š41â”Š  // Initiates comparison operator between context number and a given number, only here\n+â”Š  â”Š42â”Š  // a precision can be specified\n+â”Š  â”Š43â”Š  bool compare(double context, double num, const std::string method, const std::string precision) {\n+â”Š  â”Š44â”Š    // Fixed precision, \"almost equal\" with a deviation of Îµ\n+â”Š  â”Š45â”Š    if (precision.compare(\"f\") == 0) {\n+â”Š  â”Š46â”Š      if (method.compare(\"<\") == 0 ||\n+â”Š  â”Š47â”Š          method.compare(\"<=\") == 0)\n+â”Š  â”Š48â”Š        return context <= num + DBL_EPSILON;\n+â”Š  â”Š49â”Š      if (method.compare(\">\") == 0 ||\n+â”Š  â”Š50â”Š          method.compare(\">=\") == 0)\n+â”Š  â”Š51â”Š        return context >= num - DBL_EPSILON;\n+â”Š  â”Š52â”Š      return std::abs(context - num) <= DBL_EPSILON;\n+â”Š  â”Š53â”Š    }\n+â”Š  â”Š54â”Š    // Pixel precision, round comparison\n+â”Š  â”Š55â”Š    else if (precision.compare(\"px\") == 0) {\n+â”Š  â”Š56â”Š      if (method.compare(\"<\") == 0 ||\n+â”Š  â”Š57â”Š          method.compare(\"<=\") == 0)\n+â”Š  â”Š58â”Š        return std::round(context) <= std::round(num);\n+â”Š  â”Š59â”Š      if (method.compare(\">\") == 0 ||\n+â”Š  â”Š60â”Š          method.compare(\">=\") == 0)\n+â”Š  â”Š61â”Š        return std::round(context) >= std::round(num);\n+â”Š  â”Š62â”Š      return std::round(context) == std::round(num);\n+â”Š  â”Š63â”Š    }\n+â”Š  â”Š64â”Š    // Exact precision\n+â”Š  â”Š65â”Š    else {\n+â”Š  â”Š66â”Š      if (method.compare(\"<\") == 0) return context < num;\n+â”Š  â”Š67â”Š      if (method.compare(\"<=\") == 0) return context <= num;\n+â”Š  â”Š68â”Š      if (method.compare(\">\") == 0) return context > num;\n+â”Š  â”Š69â”Š      if (method.compare(\">=\") == 0) return context >= num;\n+â”Š  â”Š70â”Š      return context == num;\n+â”Š  â”Š71â”Š    }\n+â”Š  â”Š72â”Š  }\n+â”Š  â”Š73â”Š}ðŸš«â†µ\n```\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;utils.h\n```diff\n@@ -0,0 +1,15 @@\n+â”Š  â”Š 1â”Š#pragma once\n+â”Š  â”Š 2â”Š\n+â”Š  â”Š 3â”Š#include <string>\n+â”Š  â”Š 4â”Š\n+â”Š  â”Š 5â”Šnamespace utils {\n+â”Š  â”Š 6â”Š  double mod(double context, double num);\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Š  double trim(double context, int decimals, const std::string mode = \"round\");\n+â”Š  â”Š 9â”Š\n+â”Š  â”Š10â”Š  bool isBetween(double context, double num1, double num2, const std::string precision = \"exact\");\n+â”Š  â”Š11â”Š\n+â”Š  â”Š12â”Š  bool compare(double context, double num, const std::string precision = \"exact\");\n+â”Š  â”Š13â”Š\n+â”Š  â”Š14â”Š  bool compare(double context, double num, const std::string method, const std::string precision);\n+â”Š  â”Š15â”Š}ðŸš«â†µ\n```\n\n[}]: #\n\nAnd finally, we will extend the C++ in our JavaScript circle:\n\n[{]: <helper> (diffStep 7.21)\n\n#### [Step 7.21: Extend CPP circle class](https://github.com/DAB0mB/radial-snake/commit/d05cf32)\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;geometry&#x2F;circle.js\n```diff\n@@ -1,83 +1,9 @@\n-â”Š 1â”Š  â”ŠEngine.Geometry.Circle = class Circle {\n-â”Š 2â”Š  â”Š  // x - The x value of the circle's center\n-â”Š 3â”Š  â”Š  // y - The y value of the circle's center\n-â”Š 4â”Š  â”Š  // r - The radius of the center\n-â”Š 5â”Š  â”Š  // rad1 - The first radian of the circle, not necessarily its beginning\n-â”Š 6â”Š  â”Š  // rad2 - The second radian of the circle, not necessarily its beginning\n-â”Š 7â”Š  â”Š  constructor(x, y, r, rad1, rad2) {\n-â”Š 8â”Š  â”Š    this.x = Utils.trim(x, 9);\n-â”Š 9â”Š  â”Š    this.y = Utils.trim(y, 9);\n-â”Š10â”Š  â”Š    this.r = Utils.trim(r, 9);\n-â”Š11â”Š  â”Š\n-â”Š12â”Š  â”Š    // Trimming mode is done based on which radian represents the ending and which radian\n-â”Š13â”Š  â”Š    // represents the ending\n-â”Š14â”Š  â”Š    if (rad1 > rad2) {\n-â”Š15â”Š  â”Š      this.rad1 = Utils.trim(rad1, 9, \"floor\");\n-â”Š16â”Š  â”Š      this.rad2 = Utils.trim(rad2, 9, \"ceil\");\n-â”Š17â”Š  â”Š    }\n-â”Š18â”Š  â”Š    else {\n-â”Š19â”Š  â”Š      this.rad1 = Utils.trim(rad1, 9, \"ceil\");\n-â”Š20â”Š  â”Š      this.rad2 = Utils.trim(rad2, 9, \"floor\");\n-â”Š21â”Š  â”Š    }\n-â”Š22â”Š  â”Š  }\n-â”Š23â”Š  â”Š\n+â”Š  â”Š 1â”ŠEngine.Geometry.Circle = class Circle extends Utils.proxy(CPP.Geometry.Circle) {\n â”Š24â”Š 2â”Š  // Draws the circle on the given context\n â”Š25â”Š 3â”Š  draw(context) {\n â”Š26â”Š 4â”Š    context.arc(this.x, this.y, this.r, this.rad1, this.rad2);\n â”Š27â”Š 5â”Š  }\n â”Š28â”Š 6â”Š\n-â”Š29â”Š  â”Š  // Gets the matching x value for the given radian\n-â”Š30â”Š  â”Š  getX(rad) {\n-â”Š31â”Š  â”Š    if (!Utils(rad).trim(9).isBetween(this.rad1, this.rad2).value()) return;\n-â”Š32â”Š  â”Š    return Utils.trim((this.r * Math.cos(rad)) + this.x, 9);\n-â”Š33â”Š  â”Š  }\n-â”Š34â”Š  â”Š\n-â”Š35â”Š  â”Š  // Gets the matching y value for the given radian\n-â”Š36â”Š  â”Š  getY(rad) {\n-â”Š37â”Š  â”Š    if (!Utils(rad).trim(9).isBetween(this.rad1, this.rad2).value()) return;\n-â”Š38â”Š  â”Š    return Utils.trim((this.r * Math.sin(rad)) + this.y, 9);\n-â”Š39â”Š  â”Š  }\n-â”Š40â”Š  â”Š\n-â”Š41â”Š  â”Š  // Gets the matching point for the given radian\n-â”Š42â”Š  â”Š  getPoint(rad) {\n-â”Š43â”Š  â”Š    if (!Utils.isBetween(rad, this.rad1, this.rad2)) return;\n-â”Š44â”Š  â”Š\n-â”Š45â”Š  â”Š    return {\n-â”Š46â”Š  â”Š      x: Utils.trim((this.r * Math.cos(rad)) + this.x, 9),\n-â”Š47â”Š  â”Š      y: Utils.trim((this.r * Math.sin(rad)) + this.y, 9)\n-â”Š48â”Š  â”Š    };\n-â”Š49â”Š  â”Š  }\n-â”Š50â”Š  â”Š\n-â”Š51â”Š  â”Š  // Gets the matching radian for the given point\n-â”Š52â”Š  â”Š  getRad(x, y) {\n-â”Š53â”Š  â”Š    let rad = Math.atan2(y - this.y, x - this.x);\n-â”Š54â”Š  â”Š\n-â”Š55â”Š  â”Š    // If calculated radian is in circle's radian range, return it\n-â”Š56â”Š  â”Š    if (rad != null && Utils.isBetween(rad, this.rad1, this.rad2)) {\n-â”Š57â”Š  â”Š      return rad;\n-â”Š58â”Š  â”Š    }\n-â”Š59â”Š  â”Š\n-â”Š60â”Š  â”Š    // The calculated radian can still be in the circle's radian range in case one\n-â”Š61â”Š  â”Š    // of the radians is greater than 2 PIEs\n-â”Š62â”Š  â”Š    if (Math.abs(this.rad1) > Math.abs(this.rad2)) {\n-â”Š63â”Š  â”Š      var greatestRad = this.rad1;\n-â”Š64â”Š  â”Š    }\n-â”Š65â”Š  â”Š    else {\n-â”Š66â”Š  â”Š      var greatestRad = this.rad2;\n-â”Š67â”Š  â”Š    }\n-â”Š68â”Š  â”Š\n-â”Š69â”Š  â”Š    // Check if the absolute radian is in the circle's radian range\n-â”Š70â”Š  â”Š    if (Utils(rad + (2 * Math.PI * Math.floor(greatestRad / (2 * Math.PI)))).trim(9).isBetween(this.rad1, this.rad2).value() ||\n-â”Š71â”Š  â”Š        Utils(rad + (2 * Math.PI * Math.ceil(greatestRad / (2 * Math.PI)))).trim(9).isBetween(this.rad1, this.rad2).value()) {\n-â”Š72â”Š  â”Š      return rad;\n-â”Š73â”Š  â”Š    }\n-â”Š74â”Š  â”Š  }\n-â”Š75â”Š  â”Š\n-â”Š76â”Š  â”Š  // Returns if circle has given points\n-â”Š77â”Š  â”Š  hasPoint(x, y) {\n-â”Š78â”Š  â”Š    return this.getRad(x, y) != null;\n-â”Š79â”Š  â”Š  }\n-â”Š80â”Š  â”Š\n â”Š81â”Š 7â”Š  getIntersection(shape) {\n â”Š82â”Š 8â”Š    if (shape instanceof Engine.Geometry.Line)\n â”Š83â”Š 9â”Š      return this.getLineIntersection(shape);\n```\n```diff\n@@ -87,86 +13,6 @@\n â”Š 87â”Š 13â”Š      return this.getPolygonIntersection(shape);\n â”Š 88â”Š 14â”Š  }\n â”Š 89â”Š 15â”Š\n-â”Š 90â”Š   â”Š  // circle - circle intersection method\n-â”Š 91â”Š   â”Š  getCircleIntersection(circle) {\n-â”Š 92â”Š   â”Š    let dx = circle.x - this.x;\n-â”Š 93â”Š   â”Š    let dy = circle.y - this.y;\n-â”Š 94â”Š   â”Š    let d = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\n-â”Š 95â”Š   â”Š\n-â”Š 96â”Š   â”Š    if (d > this.r + circle.r ||\n-â”Š 97â”Š   â”Š       d < Math.abs(this.r - circle.r)) {\n-â”Š 98â”Š   â”Š      return;\n-â”Š 99â”Š   â”Š    }\n-â”Š100â”Š   â”Š\n-â”Š101â”Š   â”Š    let a = ((Math.pow(this.r, 2) - Math.pow(circle.r, 2)) + Math.pow(d, 2)) / (2 * d);\n-â”Š102â”Š   â”Š    let x = this.x + ((dx * a) / d);\n-â”Š103â”Š   â”Š    let y = this.y + ((dy * a) / d);\n-â”Š104â”Š   â”Š    let h = Math.sqrt(Math.pow(this.r, 2) - Math.pow(a, 2));\n-â”Š105â”Š   â”Š    let rx = (- dy * h) / d;\n-â”Š106â”Š   â”Š    let ry = (dx * h) / d;\n-â”Š107â”Š   â”Š\n-â”Š108â”Š   â”Š    let interPoints = [\n-â”Š109â”Š   â”Š      {\n-â”Š110â”Š   â”Š        x: x + rx,\n-â”Š111â”Š   â”Š        y: y + ry\n-â”Š112â”Š   â”Š      },\n-â”Š113â”Š   â”Š      {\n-â”Š114â”Š   â”Š        x: x - rx,\n-â”Š115â”Š   â”Š        y: y - ry\n-â”Š116â”Š   â”Š      }\n-â”Š117â”Š   â”Š    ]\n-â”Š118â”Š   â”Š    .map(point => ({\n-â”Š119â”Š   â”Š        x: Utils.trim(point.x, 9),\n-â”Š120â”Š   â”Š        y: Utils.trim(point.y, 9)\n-â”Š121â”Š   â”Š     }));\n-â”Š122â”Š   â”Š\n-â”Š123â”Š   â”Š    interPoints = _.uniq(interPoints, point => `(${point.x}, ${point.y})`);\n-â”Š124â”Š   â”Š\n-â”Š125â”Š   â”Š    [this, circle].forEach(function(circle) {\n-â”Š126â”Š   â”Š      interPoints = interPoints.filter(point => circle.hasPoint(point.x, point.y));\n-â”Š127â”Š   â”Š    });\n-â”Š128â”Š   â”Š\n-â”Š129â”Š   â”Š    if (interPoints.length > 0) return interPoints;\n-â”Š130â”Š   â”Š  }\n-â”Š131â”Š   â”Š\n-â”Š132â”Š   â”Š  // circle - line intersection method\n-â”Š133â”Š   â”Š  getLineIntersection(line) {\n-â”Š134â”Š   â”Š    let x1 = line.x1 - this.x;\n-â”Š135â”Š   â”Š    let x2 = line.x2 - this.x;\n-â”Š136â”Š   â”Š    let y1 = line.y1 - this.y;\n-â”Š137â”Š   â”Š    let y2 = line.y2 - this.y;\n-â”Š138â”Š   â”Š    let dx = x2 - x1;\n-â”Š139â”Š   â”Š    let dy = y2 - y1;\n-â”Š140â”Š   â”Š    let d = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\n-â”Š141â”Š   â”Š    let h = (x1 * y2) - (x2 * y1);\n-â”Š142â”Š   â”Š    let delta = (Math.pow(this.r, 2) * Math.pow(d, 2)) - Math.pow(h, 2);\n-â”Š143â”Š   â”Š\n-â”Š144â”Š   â”Š    if (delta < 0) return;\n-â”Š145â”Š   â”Š\n-â”Š146â”Š   â”Š    let interPoints = [\n-â”Š147â”Š   â”Š      {\n-â”Š148â”Š   â”Š        x: (((h * dy) + (((dy / Math.abs(dy)) || 1) * dx * Math.sqrt(delta))) / Math.pow(d, 2)) + this.x,\n-â”Š149â”Š   â”Š        y: (((-h * dx) + (Math.abs(dy) * Math.sqrt(delta))) / Math.pow(d, 2)) + this.y\n-â”Š150â”Š   â”Š      },\n-â”Š151â”Š   â”Š      {\n-â”Š152â”Š   â”Š        x: (((h * dy) - (((dy / Math.abs(dy)) || 1) * dx * Math.sqrt(delta))) / Math.pow(d, 2)) + this.x,\n-â”Š153â”Š   â”Š        y: (((-h * dx) - (Math.abs(dy) * Math.sqrt(delta))) / Math.pow(d, 2)) + this.y\n-â”Š154â”Š   â”Š      }\n-â”Š155â”Š   â”Š    ]\n-â”Š156â”Š   â”Š    .map(point => ({\n-â”Š157â”Š   â”Š        x: Utils.trim(point.x, 9),\n-â”Š158â”Š   â”Š        y: Utils.trim(point.y, 9)\n-â”Š159â”Š   â”Š    }))\n-â”Š160â”Š   â”Š    .filter(point => {\n-â”Š161â”Š   â”Š      return this.hasPoint(point.x, point.y) &&\n-â”Š162â”Š   â”Š        line.boundsHavePoint(point.x, point.y);\n-â”Š163â”Š   â”Š    });\n-â”Š164â”Š   â”Š\n-â”Š165â”Š   â”Š    interPoints = _.uniq(interPoints, point => `(${point.x}, ${point.y})`);\n-â”Š166â”Š   â”Š\n-â”Š167â”Š   â”Š    if (interPoints.length > 0) return interPoints;\n-â”Š168â”Š   â”Š  }\n-â”Š169â”Š   â”Š\n â”Š170â”Š 16â”Š  // circle - polygon intersection method\n â”Š171â”Š 17â”Š  getPolygonIntersection(polygon) {\n â”Š172â”Š 18â”Š    return polygon.getCircleIntersection(this);\n```\n\n[}]: #\n\nWe also need to update the line class to contain a reference to the newly created line-intersection method, so it can be invoked from both a line or a circle bi-directionally:\n\n[{]: <helper> (diffStep 7.22)\n\n#### [Step 7.22: Add line-circle intersection method](https://github.com/DAB0mB/radial-snake/commit/84f5f4d)\n\n##### Changed resources&#x2F;cpp&#x2F;src&#x2F;geometry&#x2F;line.cpp\n```diff\n@@ -4,6 +4,7 @@\n â”Š 4â”Š 4â”Š#include \"../nullable.h\"\n â”Š 5â”Š 5â”Š#include \"../utils.h\"\n â”Š 6â”Š 6â”Š#include \"point.h\"\n+â”Š  â”Š 7â”Š#include \"circle.h\"\n â”Š 7â”Š 8â”Š#include \"line.h\"\n â”Š 8â”Š 9â”Š\n â”Š 9â”Š10â”Šnamespace geometry {\n```\n```diff\n@@ -100,6 +101,11 @@\n â”Š100â”Š101â”Š    return Nullable<Point>();\n â”Š101â”Š102â”Š  }\n â”Š102â”Š103â”Š\n+â”Š   â”Š104â”Š  // circle - circle intersection method\n+â”Š   â”Š105â”Š  Nullable<std::vector<Point>> Line::getIntersection(Circle circle) {\n+â”Š   â”Š106â”Š    return circle.getIntersection(*this);\n+â”Š   â”Š107â”Š  }\n+â”Š   â”Š108â”Š\n â”Š103â”Š109â”Š  emscripten::val EMLine::getMatchingX(double y) {\n â”Š104â”Š110â”Š    Nullable<double> nullableX = Line::getMatchingX(y);\n â”Š105â”Š111â”Š    return nullableX.hasValue() ?\n```\n```diff\n@@ -126,6 +132,10 @@\n â”Š126â”Š132â”Š    emPoint.set(\"y\", emscripten::val(point.y));\n â”Š127â”Š133â”Š    return emPoint;\n â”Š128â”Š134â”Š  }\n+â”Š   â”Š135â”Š\n+â”Š   â”Š136â”Š  emscripten::val EMLine::getIntersection(EMCircle emCircle) {\n+â”Š   â”Š137â”Š    return emCircle.getIntersection(*this);\n+â”Š   â”Š138â”Š  }\n â”Š129â”Š139â”Š}\n â”Š130â”Š140â”Š\n â”Š131â”Š141â”ŠEMSCRIPTEN_BINDINGS(geometry_line_module) {\n```\n```diff\n@@ -146,5 +156,10 @@\n â”Š146â”Š156â”Š      emscripten::select_overload<emscripten::val(geometry::EMLine)>(\n â”Š147â”Š157â”Š        &geometry::EMLine::getIntersection\n â”Š148â”Š158â”Š      )\n+â”Š   â”Š159â”Š    )\n+â”Š   â”Š160â”Š    .function(\"getCircleIntersection\",\n+â”Š   â”Š161â”Š      emscripten::select_overload<emscripten::val(geometry::EMCircle)>(\n+â”Š   â”Š162â”Š        &geometry::EMLine::getIntersection\n+â”Š   â”Š163â”Š      )\n â”Š149â”Š164â”Š    );\n â”Š150â”Š165â”Š}ðŸš«â†µ\n```\n\n##### Changed resources&#x2F;cpp&#x2F;src&#x2F;geometry&#x2F;line.h\n```diff\n@@ -4,6 +4,7 @@\n â”Š 4â”Š 4â”Š#include <emscripten/val.h>\n â”Š 5â”Š 5â”Š#include \"../nullable.h\"\n â”Š 6â”Š 6â”Š#include \"point.h\"\n+â”Š  â”Š 7â”Š#include \"circle.h\"\n â”Š 7â”Š 8â”Š\n â”Š 8â”Š 9â”Šnamespace geometry {\n â”Š 9â”Š10â”Š  class Circle;\n```\n```diff\n@@ -27,6 +28,8 @@\n â”Š27â”Š28â”Š    bool boundsHavePoint(double x, double y);\n â”Š28â”Š29â”Š\n â”Š29â”Š30â”Š    Nullable<Point> getIntersection(Line line);\n+â”Š  â”Š31â”Š\n+â”Š  â”Š32â”Š    Nullable<std::vector<Point>> getIntersection(Circle circle);\n â”Š30â”Š33â”Š  };\n â”Š31â”Š34â”Š\n â”Š32â”Š35â”Š  class EMLine : public Line {\n```\n```diff\n@@ -38,5 +41,7 @@\n â”Š38â”Š41â”Š    emscripten::val getMatchingY(double x);\n â”Š39â”Š42â”Š\n â”Š40â”Š43â”Š    emscripten::val getIntersection(EMLine line);\n+â”Š  â”Š44â”Š\n+â”Š  â”Š45â”Š    emscripten::val getIntersection(EMCircle circle);\n â”Š41â”Š46â”Š  };\n â”Š42â”Š47â”Š}ðŸš«â†µ\n```\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;geometry&#x2F;line.js\n```diff\n@@ -14,11 +14,6 @@\n â”Š14â”Š14â”Š      return this.getPolygonIntersection(shape);\n â”Š15â”Š15â”Š  }\n â”Š16â”Š16â”Š\n-â”Š17â”Š  â”Š  // line - circle intersection method\n-â”Š18â”Š  â”Š  getCircleIntersection(circle) {\n-â”Š19â”Š  â”Š    return circle.getLineIntersection(this);\n-â”Š20â”Š  â”Š  }\n-â”Š21â”Š  â”Š\n â”Š22â”Š17â”Š  // line - polygon intersection method\n â”Š23â”Š18â”Š  getPolygonIntersection(polygon) {\n â”Š24â”Š19â”Š    return polygon.getLineIntersection(this);\n```\n\n[}]: #\n\nNow, before running the tests, be sure to disposed unused circle test-data:\n\n[{]: <helper> (diffStep 7.23)\n\n#### [Step 7.23: Delete circle instances in tests](https://github.com/DAB0mB/radial-snake/commit/e953fae)\n\n##### Changed resources&#x2F;scripts&#x2F;specs&#x2F;engine&#x2F;geometry&#x2F;circle.js\n```diff\n@@ -3,6 +3,10 @@\n â”Š 3â”Š 3â”Š    this.circle = new Engine.Geometry.Circle(1, 1, 5, 0, 1.5 * Math.PI);\n â”Š 4â”Š 4â”Š  });\n â”Š 5â”Š 5â”Š\n+â”Š  â”Š 6â”Š  afterEach(function () {\n+â”Š  â”Š 7â”Š    this.circle.delete();\n+â”Š  â”Š 8â”Š  });\n+â”Š  â”Š 9â”Š\n â”Š 6â”Š10â”Š  describe(\"getX method\", function() {\n â”Š 7â”Š11â”Š    describe(\"given inranged rad\", function() {\n â”Š 8â”Š12â”Š      it(\"returns x\", function() {\n```\n```diff\n@@ -64,6 +68,8 @@\n â”Š64â”Š68â”Š          { x: -2, y: -3 },\n â”Š65â”Š69â”Š          { x: -2, y: 5 }\n â”Š66â”Š70â”Š        ]);\n+â”Š  â”Š71â”Š\n+â”Š  â”Š72â”Š        circle.delete();\n â”Š67â”Š73â”Š      });\n â”Š68â”Š74â”Š    });\n â”Š69â”Š75â”Š\n```\n```diff\n@@ -74,6 +80,8 @@\n â”Š74â”Š80â”Š        expect(this.circle.getCircleIntersection(circle)).toEqual([\n â”Š75â”Š81â”Š          { x: -2, y: 5 }\n â”Š76â”Š82â”Š        ]);\n+â”Š  â”Š83â”Š\n+â”Š  â”Š84â”Š        circle.delete();\n â”Š77â”Š85â”Š      });\n â”Š78â”Š86â”Š    });\n â”Š79â”Š87â”Š\n```\n```diff\n@@ -84,6 +92,8 @@\n â”Š84â”Š92â”Š        expect(this.circle.getCircleIntersection(circle)).toEqual([\n â”Š85â”Š93â”Š          { x: -4, y: 1 }\n â”Š86â”Š94â”Š        ]);\n+â”Š  â”Š95â”Š\n+â”Š  â”Š96â”Š        circle.delete();\n â”Š87â”Š97â”Š      });\n â”Š88â”Š98â”Š    });\n â”Š89â”Š99â”Š\n```\n```diff\n@@ -91,6 +101,7 @@\n â”Š 91â”Š101â”Š      it(\"returns nothing\", function() {\n â”Š 92â”Š102â”Š        let circle = new Engine.Geometry.Circle(10, 10, 2, 0, 2 * Math.PI);\n â”Š 93â”Š103â”Š        expect(this.circle.getCircleIntersection(circle)).toBeUndefined();\n+â”Š   â”Š104â”Š        circle.delete();\n â”Š 94â”Š105â”Š      });\n â”Š 95â”Š106â”Š    });\n â”Š 96â”Š107â”Š\n```\n```diff\n@@ -98,6 +109,7 @@\n â”Š 98â”Š109â”Š      it(\"nothing\", function() {\n â”Š 99â”Š110â”Š        let circle = new Engine.Geometry.Circle(1, 1, 2, 0, 2 * Math.PI);\n â”Š100â”Š111â”Š        expect(this.circle.getCircleIntersection(circle)).toBeUndefined();\n+â”Š   â”Š112â”Š        circle.delete();\n â”Š101â”Š113â”Š      });\n â”Š102â”Š114â”Š    });\n â”Š103â”Š115â”Š  });\n```\n\n##### Changed resources&#x2F;scripts&#x2F;specs&#x2F;engine&#x2F;geometry&#x2F;polygon.js\n```diff\n@@ -64,6 +64,8 @@\n â”Š64â”Š64â”Š          { x: 2, y: 0 },\n â”Š65â”Š65â”Š          { x: 0, y: 2 }\n â”Š66â”Š66â”Š        ]);\n+â”Š  â”Š67â”Š\n+â”Š  â”Š68â”Š        circle.delete();\n â”Š67â”Š69â”Š      });\n â”Š68â”Š70â”Š    });\n â”Š69â”Š71â”Š\n```\n```diff\n@@ -74,6 +76,8 @@\n â”Š74â”Š76â”Š        expect(this.polygon.getCircleIntersection(circle)).toEqual([\n â”Š75â”Š77â”Š          { x: 2, y: 0 }\n â”Š76â”Š78â”Š        ]);\n+â”Š  â”Š79â”Š\n+â”Š  â”Š80â”Š        circle.delete();\n â”Š77â”Š81â”Š      });\n â”Š78â”Š82â”Š    });\n â”Š79â”Š83â”Š\n```\n```diff\n@@ -84,6 +88,8 @@\n â”Š84â”Š88â”Š        expect(this.polygon.getCircleIntersection(circle)).toEqual([\n â”Š85â”Š89â”Š          { x: 0, y: 3 }\n â”Š86â”Š90â”Š        ]);\n+â”Š  â”Š91â”Š\n+â”Š  â”Š92â”Š        circle.delete();\n â”Š87â”Š93â”Š      });\n â”Š88â”Š94â”Š    });\n â”Š89â”Š95â”Š\n```\n```diff\n@@ -91,6 +97,7 @@\n â”Š 91â”Š 97â”Š      it(\"returns nothing\", function() {\n â”Š 92â”Š 98â”Š        let circle = new Engine.Geometry.Circle(10, 10, 2, 0, 2 * Math.PI);\n â”Š 93â”Š 99â”Š        expect(this.polygon.getCircleIntersection(circle)).toBeUndefined();\n+â”Š   â”Š100â”Š        circle.delete();\n â”Š 94â”Š101â”Š      });\n â”Š 95â”Š102â”Š    });\n â”Š 96â”Š103â”Š\n```\n```diff\n@@ -98,6 +105,7 @@\n â”Š 98â”Š105â”Š      it(\"nothing\", function() {\n â”Š 99â”Š106â”Š        let circle = new Engine.Geometry.Circle(2.5, 2.5, 2, 0, 2 * Math.PI);\n â”Š100â”Š107â”Š        expect(this.polygon.getCircleIntersection(circle)).toBeUndefined();\n+â”Š   â”Š108â”Š        circle.delete();\n â”Š101â”Š109â”Š      });\n â”Š102â”Š110â”Š    });\n â”Š103â”Š111â”Š  });\n```\n\n[}]: #\n\nOur C++ code should be finished now, and all the tests should be passing. The only thing left to do would be applying it to our game. Like any other application, we first need to reference the script file so it can be loaded, in this case, the C++ bundle script:\n\n[{]: <helper> (diffStep 7.24)\n\n#### [Step 7.24: Load CPP bundle in game](https://github.com/DAB0mB/radial-snake/commit/a2c0d46)\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -8,6 +8,7 @@\n â”Š 8â”Š 8â”Š    <script type=\"text/javascript\" src=\"/libs/underscore.js\"></script>\n â”Š 9â”Š 9â”Š\n â”Š10â”Š10â”Š    <!-- Scripts -->\n+â”Š  â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/cpp.bundle.js\"></script>\n â”Š11â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/utils.js\"></script>\n â”Š12â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/geometry/line.js\"></script>\n```\n\n[}]: #\n\nAnd now we need to make sure to dispose the geometry shapes correctly so we won't experience any unnecessary memory leaks. Most of our disposals should go to the snake entity, since it's made out of shapes; So we will add a `delete` method to the snake entity and we will dispose it whenever a match is finished:\n\n[{]: <helper> (diffStep 7.25)\n\n#### [Step 7.25: Delete shape instances in game](https://github.com/DAB0mB/radial-snake/commit/ae58323)\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;game.js\n```diff\n@@ -95,6 +95,7 @@\n â”Š 95â”Š 95â”Š  changeScreen(Screen, ...screenArgs) {\n â”Š 96â”Š 96â”Š    // If there is a screen defined, dispose it first\n â”Š 97â”Š 97â”Š    if (this.screen) {\n+â”Š   â”Š 98â”Š      this.screen.delete();\n â”Š 98â”Š 99â”Š      this.unloadScreen();\n â”Š 99â”Š100â”Š      this.screen.disposeEventListeners();\n â”Š100â”Š101â”Š    }\n```\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;layer.js\n```diff\n@@ -23,6 +23,9 @@\n â”Š23â”Š23â”Š    this.canvas = screen.game.canvas;\n â”Š24â”Š24â”Š  }\n â”Š25â”Š25â”Š\n+â”Š  â”Š26â”Š  delete() {\n+â”Š  â”Š27â”Š  }\n+â”Š  â”Š28â”Š\n â”Š26â”Š29â”Š  update(span) {\n â”Š27â”Š30â”Š  }\n â”Š28â”Š31â”Š\n```\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;screen.js\n```diff\n@@ -28,6 +28,13 @@\n â”Š28â”Š28â”Š    return this;\n â”Š29â”Š29â”Š  }\n â”Š30â”Š30â”Š\n+â”Š  â”Š31â”Š   // Delete all layers. Same as 'unload', only it disposes memory rather than assets\n+â”Š  â”Š32â”Š  delete() {\n+â”Š  â”Š33â”Š    this.layers.forEach(layer => {\n+â”Š  â”Š34â”Š      layer.delete();\n+â”Š  â”Š35â”Š    });\n+â”Š  â”Š36â”Š  }\n+â”Š  â”Š37â”Š\n â”Š31â”Š38â”Š  // Updates each layer\n â”Š32â”Š39â”Š  update(span) {\n â”Š33â”Š40â”Š    this.layers.forEach(layer => {\n```\n```diff\n@@ -61,6 +68,7 @@\n â”Š61â”Š68â”Š  removeLayer(layer) {\n â”Š62â”Š69â”Š    this.layers = _.without(this.layers, layer);\n â”Š63â”Š70â”Š    layer.disposeEventListeners();\n+â”Š  â”Š71â”Š    layer.delete();\n â”Š64â”Š72â”Š  }\n â”Š65â”Š73â”Š\n â”Š66â”Š74â”Š  initEventListeners() {\n```\n\n##### Changed resources&#x2F;scripts&#x2F;game&#x2F;entities&#x2F;snake.js\n```diff\n@@ -31,6 +31,10 @@\n â”Š31â”Š31â”Š    }\n â”Š32â”Š32â”Š  }\n â”Š33â”Š33â”Š\n+â”Š  â”Š34â”Š  delete() {\n+â”Š  â”Š35â”Š    this.shapes.forEach(shape => shape.delete());\n+â”Š  â”Š36â”Š  }\n+â”Š  â”Š37â”Š\n â”Š34â”Š38â”Š  draw(context) {\n â”Š35â”Š39â”Š    // Draw all shapes in the shapes array\n â”Š36â”Š40â”Š    this.shapes.forEach(shape => {\n```\n```diff\n@@ -229,6 +233,8 @@\n â”Š229â”Š233â”Š      [0, height, 0, 0]\n â”Š230â”Š234â”Š    );\n â”Š231â”Š235â”Š\n-â”Š232â”Š   â”Š    return canvasPolygon.getIntersection(this.lastBit);\n+â”Š   â”Š236â”Š    let result = canvasPolygon.getIntersection(this.lastBit);\n+â”Š   â”Š237â”Š    canvasPolygon.delete();\n+â”Š   â”Š238â”Š    return result;\n â”Š233â”Š239â”Š  }\n â”Š234â”Š240â”Š};ðŸš«â†µ\n```\n\n##### Changed resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;play&#x2F;snake.js\n```diff\n@@ -43,6 +43,10 @@\n â”Š43â”Š43â”Š    screen.appendLayer(Game.Screens.Play.Score, this.snakes);\n â”Š44â”Š44â”Š  }\n â”Š45â”Š45â”Š\n+â”Š  â”Š46â”Š  unload() {\n+â”Š  â”Š47â”Š    this.snakes.forEach(snake => snake.delete());\n+â”Š  â”Š48â”Š  }\n+â”Š  â”Š49â”Š\n â”Š46â”Š50â”Š  draw(context) {\n â”Š47â”Š51â”Š    // Draw each snake in the snakes array\n â”Š48â”Š52â”Š    this.snakes.forEach(snake => snake.draw(context));\n```\n\n[}]: #\n\nCongratulations! You've created a C++ cross JavaScript game. There shouldn't be any significant difference between the C++ version of the game and the JavaScript version on most machines, since the game is very small and barely requires any processing power. You'll probably notice the difference when starting to extend the game by adding terrains or more snakes.\n\nOne might ask - \"How much faster does my game actually run?\". The short answer is - around 50%. Why did I run into this conclusion? Well, take a look at the following JavaScript code snippet, for calculating Fibonacci of 42:\n\n```js\nfunction fib(x) {\n  if (x < 2) {\n    return 1;\n  }\n  else {\n    return fib(x - 1) + fib(x - 2);\n  }\n}\n```\n\nThe same code snippet should look almost identical written in C++:\n\n```cpp\nint fib(int x) {\n  if (x < 2) {\n    return 1;\n  }\n  else {\n    return fib(x - 1) + fib(x - 2);\n  }\n}\n```\n\nHowever, the run-times are completely different! I compared the average of 10 runs in 3 different environments, and I received the following results:\n\n![chart](https://cloud.githubusercontent.com/assets/7648874/22802494/2591025e-eef8-11e6-9679-10b5bca0ef30.png)\n\nAs you can see, the generated C++ is much faster, and to be precise, 57% faster! Surprisingly, I didn't have any significant difference between Emscripten generated C++ and natively compiled executable.\n\nC++ is more complex to write, but it certainly has its advantages over JavaScript. Remember, now that you know that you have the possibility to run C++ in the browser, make sure to use it, but never overdo it, always find the right balance between readability and performance.\n\n> *Sources:*\n> - *https://kripken.github.io/emscripten-site/docs/introducing_emscripten/index.html*\n> - *http://www.crunchy.com/?q=content/emscripten-perfectly-cromulent-compiler*\n> - *http://stackoverflow.com/questions/2354725/what-exactly-is-llvm*"
          }
        ]
      },
      {
        "releaseVersion": "0.1.2",
        "releaseDate": "2017-04-23 02:33:01 -0200",
        "tagName": "master@0.1.2",
        "tagRevision": "965026a0ad8dcb1a673e812aa58104c34149636a",
        "historyRevision": "e0ebdd9379acc65035a1729541d56ee60d4b73d2",
        "changesDiff": "",
        "manuals": [
          {
            "manualTitle": "How to implement a game engine in JavaScript and build a Tron-style game",
            "stepRevision": "08b88f5a9d7b2d3ba4c8a67a1433218ef6a6a3a5",
            "manualView": "![snake-demo-full-small](https://cloud.githubusercontent.com/assets/7648874/21073892/ae331a8a-bed2-11e6-9141-9554f9bb808b.gif)\n\nThis tutorial will guide you through the following steps:\n\n- [**Step 1**](https://github.com/DAB0mB/radial-snake/blob/master/.tortilla/manuals/views/step1.md) - Creating a server\n- [**Step 2**](https://github.com/DAB0mB/radial-snake/blob/master/.tortilla/manuals/views/step2.md) - Creating a game engine basis\n- [**Step 3**](https://github.com/DAB0mB/radial-snake/blob/master/.tortilla/manuals/views/step3.md) - Creating a splash screen using a keyframe animation engine\n- [**Step 4**](https://github.com/DAB0mB/radial-snake/blob/master/.tortilla/manuals/views/step4.md) - Creating a main menu screen using a font engine\n- [**Step 5**](https://github.com/DAB0mB/radial-snake/blob/master/.tortilla/manuals/views/step5.md) - Creating a snake and related geometry shapes\n- [**Step 6**](https://github.com/DAB0mB/radial-snake/blob/master/.tortilla/manuals/views/step6.md) - Creating a complex game screen with multiple layers\n- [**Step 7**](https://github.com/DAB0mB/radial-snake/blob/master/.tortilla/manuals/views/step7.md) - Bonus! Re-implementing geometry in C++\n\nMake sure you have the following software installed:\n\n- NodeJS with an ECMAScript 2015 support (v6.0.0 and above).\n- Any web-browser which supports ECMAScript 2015, with a preference for Google Chrome.\n\n> The final project is a hybrid of C++ and JavaScript. A JavaScript **only** version of this tutorial is available [here](https://github.com/DAB0mB/radial-snake/tree/master%40step6%400.1.3).\n\nThis tutorial is mostly based on pure JavaScript, so people can have a deeper understanding of the language and its dynamics. In addition, this tutorial makes a great practice on how to build a nice architecture for complex systems, which can then be expanded and maintained with ease. Yes, it is specifically designed for games, but I truly believe that video games can easily get messed up if not planned and designed properly in terms of object oriented relationships. They are naturally more complicated then any web-app you gonna see out there, so if you can create a game engine and understand its flow, creating a web-app would be a piece of cake for you. By the end of this tutorial, your general sense for programming should be enhanced greatly.\n\nSo hopefully that I got you pumped up by now, let's get started!"
          },
          {
            "manualTitle": "Step 1: Creating a server",
            "stepRevision": "1aed2194c509617dbe79447e2615aa34728262bc",
            "manualView": "The first thing we will learn to do would be creating a server so we can serve our assets. We will be using [HapiJS](https://hapijs.com/) to build a REST API, although this step can be implemented with any library you'd want, like [ExpressJS](http://expressjs.com/) or [Connect](https://www.senchalabs.github.com/connect) etc. Let's install it then:\n\n    $ npm install hapi --save\n\nWe will start by setting up a basis for our server, and we will expand it as we go further in this step. A general boiler plate should look like so:\n\n[{]: <helper> (diffStep 1.2)\n\n#### [Step 1.2: Add server basis](https://github.com/DAB0mB/radial-snake/commit/8ff8805)\n\n##### Added server.js\n```diff\n@@ -0,0 +1,36 @@\n+â”Š  â”Š 1â”Šconst Hapi = require(\"hapi\");\n+â”Š  â”Š 2â”Š\n+â”Š  â”Š 3â”Šlet port = 8000;\n+â”Š  â”Š 4â”Š\n+â”Š  â”Š 5â”Š// Initialize a new server\n+â”Š  â”Š 6â”Šlet server = new Hapi.Server();\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Šserver.connection({ port: process.env.PORT || port });\n+â”Š  â”Š 9â”Š\n+â”Š  â”Š10â”Š// Report each response made\n+â”Š  â”Š11â”Šserver.ext(\"onPreResponse\", (req, rep) => {\n+â”Š  â”Š12â”Š  let res = req.response;\n+â”Š  â”Š13â”Š\n+â”Š  â”Š14â”Š  console.log(\"Outcoming response:\");\n+â”Š  â”Š15â”Š  console.log(`in: ${new Date}`);\n+â”Š  â”Š16â”Š  console.log(`to: ${req.info.remoteAddress}`);\n+â”Š  â”Š17â”Š  console.log(`method: ${req.method}`);\n+â”Š  â”Š18â”Š  console.log(`url: ${req.url.path}`);\n+â”Š  â”Š19â”Š  console.log(`status: ${res.statusCode || res.output.statusCode}`);\n+â”Š  â”Š20â”Š  console.log();\n+â”Š  â”Š21â”Š\n+â”Š  â”Š22â”Š  rep.continue();\n+â”Š  â”Š23â”Š});\n+â”Š  â”Š24â”Š\n+â”Š  â”Š25â”Š// Print message once started\n+â”Š  â”Š26â”Šserver.start((err) => {\n+â”Š  â”Š27â”Š  if (err) throw err;\n+â”Š  â”Š28â”Š\n+â”Š  â”Š29â”Š  console.log();\n+â”Š  â”Š30â”Š  console.log(\"---------- -------- ------ ---- --\");\n+â”Š  â”Š31â”Š  console.log(\"----- ---- --- -- -\");\n+â”Š  â”Š32â”Š  console.log(`Server running at ${port}`);\n+â”Š  â”Š33â”Š  console.log(\"----- ---- --- -- -\");\n+â”Š  â”Š34â”Š  console.log(\"---------- -------- ------ ---- --\");\n+â”Š  â”Š35â”Š  console.log();\n+â”Š  â”Š36â”Š});ðŸš«â†µ\n```\n\n[}]: #\n\nWe simply initialize a new server which will connect to port `8000` by default, unless we defined an environment variable called `PORT`. Once the server is started, and whenever there is an outcoming response, a message will be printed to the console.\n\n> More information and configuration options regards HapiJS's API can be found in this [here](https://hapijs.com/).\n\nNow that the basis is ready, we want a convenient way to launch it. Repetitive scripts are usually defined in the `package.json` file under the `scripts` field. To start the server, we gonna create a simple script called `serve`:\n\n[{]: <helper> (diffStep 1.3)\n\n#### [Step 1.3: Add serve npm script](https://github.com/DAB0mB/radial-snake/commit/6e7d691)\n\n##### Changed package.json\n```diff\n@@ -6,6 +6,9 @@\n â”Š 6â”Š 6â”Š    \"url\": \"https://DAB0mB@github.com/DAB0mB/radial-snake.git\"\n â”Š 7â”Š 7â”Š  },\n â”Š 8â”Š 8â”Š  \"private\": true,\n+â”Š  â”Š 9â”Š  \"scripts\": {\n+â”Š  â”Š10â”Š    \"serve\": \"node server.js\"\n+â”Š  â”Š11â”Š  },\n â”Š 9â”Š12â”Š  \"dependencies\": {\n â”Š10â”Š13â”Š    \"hapi\": \"^16.0.1\"\n â”Š11â”Š14â”Š  }\n```\n\n[}]: #\n\nTo run this script, we will simply need to type the following:\n\n    $ npm run serve\n\nThis will run our server, and you should see the following message printed to the console:\n\n```\n---------- -------- ------ ---- --\n----- ---- --- -- -\nServer running at 8000\n----- ---- --- -- -\n---------- -------- ------ ---- --\n```\n\n> As for now, nothing happens, because we didn't define any handlers for HTTP requests. I will get to it in a bit, stay with me.\n\nThe main disadvantage of starting a server directly with node is that we have no listeners for changes in our files, so if we want the served files to be updated, we will have to restart our server anytime we make a change. To avoid that, we gonna use [nodemon](https://nodemon.io/), which is a simple utility that can monitor changes is source files and automatically restart our server. To install it, type the following:\n\n    $ sudo npm install nodemon -g\n\nNow that we have it, we will need to update our `serve` npm script to use `nodemon` instead of `node`:\n\n[{]: <helper> (diffStep 1.4)\n\n#### [Step 1.4: Change serve npm script to use nodemon](https://github.com/DAB0mB/radial-snake/commit/a238294)\n\n##### Changed package.json\n```diff\n@@ -7,7 +7,7 @@\n â”Š 7â”Š 7â”Š  },\n â”Š 8â”Š 8â”Š  \"private\": true,\n â”Š 9â”Š 9â”Š  \"scripts\": {\n-â”Š10â”Š  â”Š    \"serve\": \"node server.js\"\n+â”Š  â”Š10â”Š    \"serve\": \"nodemon server.js\"\n â”Š11â”Š11â”Š  },\n â”Š12â”Š12â”Š  \"dependencies\": {\n â”Š13â”Š13â”Š    \"hapi\": \"^16.0.1\"\n```\n\n[}]: #\n\nThe basis for our server is pretty much complete. From now on we gonna build stuff on top of it and extend our server. I'd like to add a small attachment to our server. I want that the IP address of the current computer will be printed to the console once the server is started. For this, we first gonna create a helper which we gonna call `ip_grabber`:\n\n[{]: <helper> (diffStep 1.5)\n\n#### [Step 1.5: Add ip_grabber helper](https://github.com/DAB0mB/radial-snake/commit/8ff1d1c)\n\n##### Added helpers&#x2F;ip_grabber.js\n```diff\n@@ -0,0 +1,23 @@\n+â”Š  â”Š 1â”Šconst Os = require(\"os\");\n+â”Š  â”Š 2â”Š\n+â”Š  â”Š 3â”Š// Grab local IP address of which the NodeJS process runs on\n+â”Š  â”Š 4â”Šfunction local() {\n+â”Š  â”Š 5â”Š  let interfaces = Os.networkInterfaces();\n+â”Š  â”Š 6â”Š  let addresses = [];\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Š  for (let k in interfaces) {\n+â”Š  â”Š 9â”Š    for (let k2 in interfaces[k]) {\n+â”Š  â”Š10â”Š      let address = interfaces[k][k2];\n+â”Š  â”Š11â”Š\n+â”Š  â”Š12â”Š      if (address.family == \"IPv4\" && !address.internal) {\n+â”Š  â”Š13â”Š        addresses.push(address.address);\n+â”Š  â”Š14â”Š      }\n+â”Š  â”Š15â”Š    }\n+â”Š  â”Š16â”Š  }\n+â”Š  â”Š17â”Š\n+â”Š  â”Š18â”Š  return addresses[0];\n+â”Š  â”Š19â”Š}\n+â”Š  â”Š20â”Š\n+â”Š  â”Š21â”Šmodule.exports = {\n+â”Š  â”Š22â”Š  local\n+â”Š  â”Š23â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nThis module simply goes through the available network interfaces and grabs the IP address of the default gateway using the `os` module. Now that we have it, let's import it in the server's entry file and use the `local` method to grab the IP address and report it once the server is started:\n\n[{]: <helper> (diffStep 1.6)\n\n#### [Step 1.6: Print IP address once server is started](https://github.com/DAB0mB/radial-snake/commit/18ed984)\n\n##### Changed server.js\n```diff\n@@ -1,5 +1,7 @@\n â”Š1â”Š1â”Šconst Hapi = require(\"hapi\");\n+â”Š â”Š2â”Šconst IpGrabber = require(\"./helpers/ip_grabber\");\n â”Š2â”Š3â”Š\n+â”Š â”Š4â”Šlet localIp = IpGrabber.local();\n â”Š3â”Š5â”Šlet port = 8000;\n â”Š4â”Š6â”Š\n â”Š5â”Š7â”Š// Initialize a new server\n```\n```diff\n@@ -29,7 +31,7 @@\n â”Š29â”Š31â”Š  console.log();\n â”Š30â”Š32â”Š  console.log(\"---------- -------- ------ ---- --\");\n â”Š31â”Š33â”Š  console.log(\"----- ---- --- -- -\");\n-â”Š32â”Š  â”Š  console.log(`Server running at ${port}`);\n+â”Š  â”Š34â”Š  console.log(`Server running at ${localIp}:${port}`);\n â”Š33â”Š35â”Š  console.log(\"----- ---- --- -- -\");\n â”Š34â”Š36â”Š  console.log(\"---------- -------- ------ ---- --\");\n â”Š35â”Š37â”Š  console.log();\n```\n\n[}]: #\n\nBy now you should have the following message printed to the console once you start the server:\n\n```\n---------- -------- ------ ---- --\n----- ---- --- -- -\nServer running at 95.221.122.30:8000\n----- ---- --- -- -\n---------- -------- ------ ---- --\n```\n\n> Instead of `95.221.122.30` you should have the IP address which is right for you.\n\nNow comes the most important part - handling HTTP requests! Because what does a server worth if it doesn't know how to handle anything? When using `HapiJS`, we can separate extensions to our server in different modules, and eventually register them as plug-ins. So the first plug-in is gonna be the routes batch for the endpoints - it will take care of serving file requests as is, and basically turning local directories into public ones. This is useful because our game is going to be dependent on many assets like textures, images, fonts, and so on... But before I go into the implementation part we first need to install a couple of libraries which will help us with the task. The first one is going to be `async`, which will take care of managing the control flow of asynchronous code:\n\n    $ npm install async --save\n\nAnd the second library is going to be `inert`, which is a `HapiJS` plug-in which will give us the ability to serve files from local directories:\n\n    $ npm install inert --save\n\nNow that we're set, let's implement the `endpoints` routes batch:\n\n[{]: <helper> (diffStep 1.8)\n\n#### [Step 1.8: Add endpoints routes](https://github.com/DAB0mB/radial-snake/commit/9c22408)\n\n##### Added routes&#x2F;endpoints.js\n```diff\n@@ -0,0 +1,80 @@\n+â”Š  â”Š 1â”Šconst Pack = require(\"../package.json\");\n+â”Š  â”Š 2â”Š\n+â”Š  â”Š 3â”Šregister.attributes = {\n+â”Š  â”Š 4â”Š  name: \"endpoints\",\n+â”Š  â”Š 5â”Š  version: Pack.version\n+â”Š  â”Š 6â”Š};\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Šfunction register(server, options, next) {\n+â”Š  â”Š 9â”Š  // Scripts endpoint\n+â”Š  â”Š10â”Š  server.route({\n+â”Š  â”Š11â”Š    method: \"GET\",\n+â”Š  â”Š12â”Š    path: \"/scripts/{path*}\",\n+â”Š  â”Š13â”Š    handler: {\n+â”Š  â”Š14â”Š      directory: {\n+â”Š  â”Š15â”Š        path: \"./resources/scripts/\"\n+â”Š  â”Š16â”Š      }\n+â”Š  â”Š17â”Š    }\n+â”Š  â”Š18â”Š  });\n+â”Š  â”Š19â”Š\n+â”Š  â”Š20â”Š  // Style-sheets endpoint\n+â”Š  â”Š21â”Š  server.route({\n+â”Š  â”Š22â”Š    method: \"GET\",\n+â”Š  â”Š23â”Š    path: \"/styles/{path*}\",\n+â”Š  â”Š24â”Š    handler: {\n+â”Š  â”Š25â”Š      directory: {\n+â”Š  â”Š26â”Š        path: \"./resources/styles/\"\n+â”Š  â”Š27â”Š      }\n+â”Š  â”Š28â”Š    }\n+â”Š  â”Š29â”Š  });\n+â”Š  â”Š30â”Š\n+â”Š  â”Š31â”Š  // Libraries endpoint\n+â”Š  â”Š32â”Š  server.route({\n+â”Š  â”Š33â”Š    method: \"GET\",\n+â”Š  â”Š34â”Š    path: \"/libs/{path*}\",\n+â”Š  â”Š35â”Š    handler: {\n+â”Š  â”Š36â”Š      directory: {\n+â”Š  â”Š37â”Š        path: \"./resources/libs/\"\n+â”Š  â”Š38â”Š      }\n+â”Š  â”Š39â”Š    }\n+â”Š  â”Š40â”Š  });\n+â”Š  â”Š41â”Š\n+â”Š  â”Š42â”Š  // Images endpoint\n+â”Š  â”Š43â”Š  server.route({\n+â”Š  â”Š44â”Š    method: \"GET\",\n+â”Š  â”Š45â”Š    path: \"/images/{path*}\",\n+â”Š  â”Š46â”Š    handler: {\n+â”Š  â”Š47â”Š      directory: {\n+â”Š  â”Š48â”Š        path: \"./resources/images/\"\n+â”Š  â”Š49â”Š      }\n+â”Š  â”Š50â”Š    }\n+â”Š  â”Š51â”Š  });\n+â”Š  â”Š52â”Š\n+â”Š  â”Š53â”Š  // Textures endpoint\n+â”Š  â”Š54â”Š  server.route({\n+â”Š  â”Š55â”Š    method: \"GET\",\n+â”Š  â”Š56â”Š    path: \"/textures/{path*}\",\n+â”Š  â”Š57â”Š    handler: {\n+â”Š  â”Š58â”Š      directory: {\n+â”Š  â”Š59â”Š        path: \"./resources/assets/textures/\"\n+â”Š  â”Š60â”Š      }\n+â”Š  â”Š61â”Š    }\n+â”Š  â”Š62â”Š  });\n+â”Š  â”Š63â”Š\n+â”Š  â”Š64â”Š  // Fonts endpoint\n+â”Š  â”Š65â”Š  server.route({\n+â”Š  â”Š66â”Š    method: \"GET\",\n+â”Š  â”Š67â”Š    path: \"/fonts/{path*}\",\n+â”Š  â”Š68â”Š    handler: {\n+â”Š  â”Š69â”Š      directory: {\n+â”Š  â”Š70â”Š        path: \"./resources/assets/fonts/\"\n+â”Š  â”Š71â”Š      }\n+â”Š  â”Š72â”Š    }\n+â”Š  â”Š73â”Š  });\n+â”Š  â”Š74â”Š\n+â”Š  â”Š75â”Š  next();\n+â”Š  â”Š76â”Š}\n+â”Š  â”Š77â”Š\n+â”Š  â”Š78â”Šmodule.exports = {\n+â”Š  â”Š79â”Š  register\n+â”Š  â”Š80â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nThis module actually represents a classic structure of a `HapiJS` plug-in. It should export a `name` for debugging proposes, a `version`, and a `register` function, which will take care of registering extensions to our server; in this case, these are the endpoints routes. To make this plug-in (Or any other plug-in) work, we need to register it. The registration is an asynchronous operation, thus we gonna handle it using `async`:\n\n[{]: <helper> (diffStep 1.9)\n\n#### [Step 1.9: Register ednpoints routes](https://github.com/DAB0mB/radial-snake/commit/bba460f)\n\n##### Changed server.js\n```diff\n@@ -1,11 +1,23 @@\n+â”Š  â”Š 1â”Šconst Async = require(\"async\");\n â”Š 1â”Š 2â”Šconst Hapi = require(\"hapi\");\n+â”Š  â”Š 3â”Šconst Inert = require(\"inert\");\n+â”Š  â”Š 4â”Šconst Endpoints = require(\"./routes/endpoints\");\n â”Š 2â”Š 5â”Šconst IpGrabber = require(\"./helpers/ip_grabber\");\n â”Š 3â”Š 6â”Š\n â”Š 4â”Š 7â”Šlet localIp = IpGrabber.local();\n â”Š 5â”Š 8â”Šlet port = 8000;\n â”Š 6â”Š 9â”Š\n â”Š 7â”Š10â”Š// Initialize a new server\n-â”Š 8â”Š  â”Šlet server = new Hapi.Server();\n+â”Š  â”Š11â”Šlet server = new Hapi.Server({\n+â”Š  â”Š12â”Š  connections: {\n+â”Š  â”Š13â”Š    routes: {\n+â”Š  â”Š14â”Š      files: {\n+â”Š  â”Š15â”Š        // Served files will be relative to current directory\n+â”Š  â”Š16â”Š        relativeTo: __dirname\n+â”Š  â”Š17â”Š      }\n+â”Š  â”Š18â”Š    }\n+â”Š  â”Š19â”Š  }\n+â”Š  â”Š20â”Š});\n â”Š 9â”Š21â”Š\n â”Š10â”Š22â”Šserver.connection({ port: process.env.PORT || port });\n â”Š11â”Š23â”Š\n```\n```diff\n@@ -24,8 +36,14 @@\n â”Š24â”Š36â”Š  rep.continue();\n â”Š25â”Š37â”Š});\n â”Š26â”Š38â”Š\n+â”Š  â”Š39â”Š// Register all routes and plug-ins\n+â”Š  â”Š40â”ŠAsync.series([\n+â”Š  â”Š41â”Š  next => server.register(Inert, next),\n+â”Š  â”Š42â”Š  next => server.register(Endpoints, next),\n+â”Š  â”Š43â”Š  // Once registrations are finished, start the server\n+â”Š  â”Š44â”Š  next => server.start(next)\n â”Š27â”Š45â”Š// Print message once started\n-â”Š28â”Š  â”Šserver.start((err) => {\n+â”Š  â”Š46â”Š], (err) => {\n â”Š29â”Š47â”Š  if (err) throw err;\n â”Š30â”Š48â”Š\n â”Š31â”Š49â”Š  console.log();\n```\n\n[}]: #\n\nOnce all the plug-ins have been registered, we gonna start our server as we previously did. Note that we also registered the `inert` plug-in, because as I said earlier, that's what gives us the ability to handle files requests.\n\nLastly, I want to create the `pages` routes batch, which will be responsible for serving pages in our application as listed above:\n\n- The `/` route will serve us the `game.html` file.\n- The `/test` route will serve us the `spec_runner.html` file.\n\nBy the name of each route and file you can probably what each one should do. The thing is, we don't want everyone to be able to access the `spec_runner.html` file, or the `game.html` file if in the middle of development. For this, we're going to create a new helper which will be responsible for handling permissions. So first we gonna install an npm package called `boom` which has the ability to format `permission denied` HTTP errors:\n\n    $ npm install boom --save\n\nAnd now we gonna implement the module itself:\n\n[{]: <helper> (diffStep 1.11)\n\n#### [Step 1.11: Add permitter helper](https://github.com/DAB0mB/radial-snake/commit/d26a5d7)\n\n##### Added helpers&#x2F;permitter.js\n```diff\n@@ -0,0 +1,29 @@\n+â”Š  â”Š 1â”Šconst Boom = require(\"boom\");\n+â”Š  â”Š 2â”Šconst Hapi = require(\"hapi\");\n+â”Š  â”Š 3â”Šconst IpGrabber = require(\"./ip_grabber\");\n+â”Š  â”Š 4â”Š\n+â”Š  â”Š 5â”Š// These addresses will be permitted by default\n+â”Š  â”Š 6â”Šconst defaultPermissions = [\n+â”Š  â”Š 7â”Š  IpGrabber.local(), \"127.0.0.1\", \"localhost\"\n+â”Š  â”Š 8â”Š];\n+â”Š  â”Š 9â”Š\n+â”Š  â”Š10â”Š// Manage file permissions\n+â”Š  â”Š11â”Šfunction file(path, permissions, req, rep) {\n+â”Š  â”Š12â”Š  // Apply default permissions\n+â”Š  â”Š13â”Š  permissions = permissions.concat(defaultPermissions);\n+â”Š  â”Š14â”Š  // Request address\n+â”Š  â”Š15â”Š  let remoteAddress = req.info.remoteAddress;\n+â”Š  â”Š16â”Š\n+â”Š  â”Š17â”Š  // If not permitted, reply error\n+â”Š  â”Š18â”Š  if (permissions.indexOf(remoteAddress) == -1) {\n+â”Š  â”Š19â”Š    let err = new Boom.forbidden(\"Missing permissions\");\n+â”Š  â”Š20â”Š    return rep(err);\n+â”Š  â”Š21â”Š  }\n+â”Š  â”Š22â”Š\n+â”Š  â”Š23â”Š  // If permitted, reply file\n+â”Š  â”Š24â”Š  rep.file(path);\n+â”Š  â”Š25â”Š}\n+â”Š  â”Š26â”Š\n+â”Š  â”Š27â”Šmodule.exports = {\n+â”Š  â”Š28â”Š  file\n+â”Š  â”Š29â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nThe default permitted IP address would be the current computer's IP address. Extra IP permissions can be provided with the invocation of the `file` method. If the requesting IP is not listed in the permissions list, an error is gonna be replied instead of the requested file. Now that we have our \"permitter\" ready, let's implement the `pages` routes batch, only we're gonna pass the requests through the black-list, for the reason mentioned above:\n\n[{]: <helper> (diffStep 1.12)\n\n#### [Step 1.12: Add pages routes](https://github.com/DAB0mB/radial-snake/commit/11860e9)\n\n##### Added routes&#x2F;pages.js\n```diff\n@@ -0,0 +1,35 @@\n+â”Š  â”Š 1â”Šconst Hapi = require(\"hapi\");\n+â”Š  â”Š 2â”Šconst Pack = require(\"../package.json\");\n+â”Š  â”Š 3â”Šconst Permitter = require(\"../helpers/permitter\");\n+â”Š  â”Š 4â”Š\n+â”Š  â”Š 5â”Šregister.attributes = {\n+â”Š  â”Š 6â”Š  name: \"pages\",\n+â”Š  â”Š 7â”Š  version: Pack.version\n+â”Š  â”Š 8â”Š};\n+â”Š  â”Š 9â”Š\n+â”Š  â”Š10â”Šfunction register(server, options, next) {\n+â”Š  â”Š11â”Š  server.route({ method: \"GET\", path: \"/\", handler: getGame });\n+â”Š  â”Š12â”Š  server.route({ method: \"GET\", path: \"/test\", handler: getSpecRunner });\n+â”Š  â”Š13â”Š\n+â”Š  â”Š14â”Š  next();\n+â”Š  â”Š15â”Š}\n+â”Š  â”Š16â”Š\n+â”Š  â”Š17â”Š// Serve game page\n+â”Š  â”Š18â”Šfunction getGame(req, rep) {\n+â”Š  â”Š19â”Š  let path = \"./views/game.html\";\n+â”Š  â”Š20â”Š  let permissions = [];\n+â”Š  â”Š21â”Š\n+â”Š  â”Š22â”Š  Permitter.file(path, permissions, req, rep);\n+â”Š  â”Š23â”Š}\n+â”Š  â”Š24â”Š\n+â”Š  â”Š25â”Š// Serve test page\n+â”Š  â”Š26â”Šfunction getSpecRunner(req, rep) {\n+â”Š  â”Š27â”Š  let path = \"./views/spec_runner.html\";\n+â”Š  â”Š28â”Š  let permissions = [];\n+â”Š  â”Š29â”Š\n+â”Š  â”Š30â”Š  Permitter.file(path, permissions, req, rep);\n+â”Š  â”Š31â”Š}\n+â”Š  â”Š32â”Š\n+â”Š  â”Š33â”Šmodule.exports = {\n+â”Š  â”Š34â”Š  register\n+â”Š  â”Š35â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nNow the only thing left to do would be registering the plug-in we've just created:\n\n[{]: <helper> (diffStep 1.13)\n\n#### [Step 1.13: Register pages routes](https://github.com/DAB0mB/radial-snake/commit/ed50bef)\n\n##### Changed server.js\n```diff\n@@ -2,6 +2,7 @@\n â”Š2â”Š2â”Šconst Hapi = require(\"hapi\");\n â”Š3â”Š3â”Šconst Inert = require(\"inert\");\n â”Š4â”Š4â”Šconst Endpoints = require(\"./routes/endpoints\");\n+â”Š â”Š5â”Šconst Pages = require(\"./routes/pages\");\n â”Š5â”Š6â”Šconst IpGrabber = require(\"./helpers/ip_grabber\");\n â”Š6â”Š7â”Š\n â”Š7â”Š8â”Šlet localIp = IpGrabber.local();\n```\n```diff\n@@ -40,6 +41,7 @@\n â”Š40â”Š41â”ŠAsync.series([\n â”Š41â”Š42â”Š  next => server.register(Inert, next),\n â”Š42â”Š43â”Š  next => server.register(Endpoints, next),\n+â”Š  â”Š44â”Š  next => server.register(Pages, next),\n â”Š43â”Š45â”Š  // Once registrations are finished, start the server\n â”Š44â”Š46â”Š  next => server.start(next)\n â”Š45â”Š47â”Š// Print message once started\n```\n\n[}]: #\n\nAnd that's it for the current step! In the next steps we will start storing files and assets in our public directories and implement all the necessary scripts, so our server is not running in vain."
          },
          {
            "manualTitle": "Step 2: Creating a game engine basis",
            "stepRevision": "a3e901039dc5db535111da14305175182f9f346c",
            "manualView": "Like any other JavaScript-based application, we should have an entry view written in HTML. However, in our application, the only visible element is going to be an [HTMLCanvas](https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API). The canvas is exactly what it sounds like - a blank white surface which we can draw things on top of it. As we go further with this tutorial, we will learn more about the canvas and dive into its API and how to use it. Now that you got the general idea, let's create the HTML file:\n\n[{]: <helper> (diffStep 2.1)\n\n#### [Step 2.1: Create basic game view](https://github.com/DAB0mB/radial-snake/commit/254f06f)\n\n##### Added views&#x2F;game.html\n```diff\n@@ -0,0 +1,10 @@\n+â”Š  â”Š 1â”Š<!DOCTYPE html>\n+â”Š  â”Š 2â”Š<html>\n+â”Š  â”Š 3â”Š  <head>\n+â”Š  â”Š 4â”Š    <title>radial snake</title>\n+â”Š  â”Š 5â”Š  </head>\n+â”Š  â”Š 6â”Š\n+â”Š  â”Š 7â”Š  <body>\n+â”Š  â”Š 8â”Š    <canvas id=\"gameCanvas\" tabindex=\"0\"></canvas>\n+â”Š  â”Š 9â”Š  </body>\n+â”Š  â”Š10â”Š</html>ðŸš«â†µ\n```\n\n[}]: #\n\nIn the previous step we've already set the route for this file, so if you'd like to run the game, simply start the server by typing `npm run serve`, and navigate to the address presented on the screen (Should be `localhost:8000` by default).\n\n> From now on I'm going to assume the server is running in the background, so I won't repeat the instruction above\n\nJust to make sure that the canvas is visible and not blended into the background, we will draw a black border around using a simple style-sheet:\n\n[{]: <helper> (diffStep 2.2)\n\n#### [Step 2.2: Create basic game stylesheet](https://github.com/DAB0mB/radial-snake/commit/44fe5aa)\n\n##### Added resources&#x2F;styles&#x2F;game.css\n```diff\n@@ -0,0 +1,6 @@\n+â”Š â”Š1â”Š#gameCanvas {\n+â”Š â”Š2â”Š  display: block;\n+â”Š â”Š3â”Š  margin: auto;\n+â”Š â”Š4â”Š  border-style: solid;\n+â”Š â”Š5â”Š  border-width: 1px;\n+â”Š â”Š6â”Š}ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -2,6 +2,9 @@\n â”Š 2â”Š 2â”Š<html>\n â”Š 3â”Š 3â”Š  <head>\n â”Š 4â”Š 4â”Š    <title>radial snake</title>\n+â”Š  â”Š 5â”Š\n+â”Š  â”Š 6â”Š    <!-- Styles -->\n+â”Š  â”Š 7â”Š    <link rel=\"stylesheet\" type=\"text/css\" href=\"/styles/game.css\">\n â”Š 5â”Š 8â”Š  </head>\n â”Š 6â”Š 9â”Š\n â”Š 7â”Š10â”Š  <body>\n```\n\n[}]: #\n\n> Note that every asset we create should be declared in the HTML file in order for it to take effect\n\nTo build this project we're also gonna use two very famous utility libraries called [JQuery](http://jquery.com/) and [Underscore](http://underscorejs.org/) which will make our lives a bit easier. Third-party libraries should be located in a directory called `libs`, according to the routes-map we created in the previous step. To set these libraries up, type the following commands in series:\n\n    resources$ mkdir libs\n    resources$ cd libs\n    resources/libs$ wget raw.githubusercontent.com/dab0mb/radial-snake/master/resources/libs/underscore.js\n    resources/libs$ wget raw.githubusercontent.com/dab0mb/radial-snake/master/resources/libs/jquery-2.1.1.js\n\nAnd load them in the game's HTML file's header:\n\n[{]: <helper> (diffStep 2.3 files=\"views/game.html\")\n\n#### [Step 2.3: Add jquery and underscore libs](https://github.com/DAB0mB/radial-snake/commit/085ca6b)\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -3,6 +3,10 @@\n â”Š 3â”Š 3â”Š  <head>\n â”Š 4â”Š 4â”Š    <title>radial snake</title>\n â”Š 5â”Š 5â”Š\n+â”Š  â”Š 6â”Š    <!-- Libs -->\n+â”Š  â”Š 7â”Š    <script type=\"text/javascript\" src=\"/libs/jquery-2.1.1.js\"></script>\n+â”Š  â”Š 8â”Š    <script type=\"text/javascript\" src=\"/libs/underscore.js\"></script>\n+â”Š  â”Š 9â”Š\n â”Š 6â”Š10â”Š    <!-- Styles -->\n â”Š 7â”Š11â”Š    <link rel=\"stylesheet\" type=\"text/css\" href=\"/styles/game.css\">\n â”Š 8â”Š12â”Š  </head>\n```\n\n[}]: #\n\nNow, we're finally going to build the game engine. At first, it's gonna be very basic simple, but further in this tutorial we're going to extend it and add some pretty neat features. When creating an application, of any kind, you don't want to garbage the global scope, so it can stay clean without any conflicts. Therefore, we're going to create an initial namespace for our game engine called `Engine`, which is going to contain all our game engine's classes and entities:\n\n[{]: <helper> (diffStep 2.4)\n\n#### [Step 2.4: Add engine namespace](https://github.com/DAB0mB/radial-snake/commit/3d52525)\n\n##### Added resources&#x2F;scripts&#x2F;namespaces.js\n```diff\n@@ -0,0 +1 @@\n+â”Š â”Š1â”ŠEngine = {};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -7,6 +7,9 @@\n â”Š 7â”Š 7â”Š    <script type=\"text/javascript\" src=\"/libs/jquery-2.1.1.js\"></script>\n â”Š 8â”Š 8â”Š    <script type=\"text/javascript\" src=\"/libs/underscore.js\"></script>\n â”Š 9â”Š 9â”Š\n+â”Š  â”Š10â”Š    <!-- Scripts -->\n+â”Š  â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n+â”Š  â”Š12â”Š\n â”Š10â”Š13â”Š    <!-- Styles -->\n â”Š11â”Š14â”Š    <link rel=\"stylesheet\" type=\"text/css\" href=\"/styles/game.css\">\n â”Š12â”Š15â”Š  </head>\n```\n\n[}]: #\n\nThe first thing we're going to define in the namespace we've just created would be the game loop. The game loop is the central code of your game, split into different parts. Generally, these are: update and draw.\n\nThe main purpose of the update phase is to prepare all objects to be drawn, so this is where all the geometry code, coordinate updates, score changes, animation refreshments and other similar operations belong. This is also where the input will be captured and processed.\n\nWhen everything is properly updated and ready, we enter the draw phase where all this information is put on the screen. This function should contain all the code to manage and draw the levels, shapes, score board and so on.\n\n![game-loop](https://cloud.githubusercontent.com/assets/7648874/21332964/4b80ef4e-c633-11e6-946a-0c5870d2f9c9.png)\n\n> You can find plenty of details and information about what \"game loop\" means simply by typing in on Google.\n\nA game loop can wear many forms, but the concept is gonna be the same, plus-minus. This is how our game loop is going to loop like:\n\n[{]: <helper> (diffStep 2.5)\n\n#### [Step 2.5: Create a game basis](https://github.com/DAB0mB/radial-snake/commit/1b7fcf9)\n\n##### Added resources&#x2F;scripts&#x2F;engine&#x2F;game.js\n```diff\n@@ -0,0 +1,99 @@\n+â”Š  â”Š 1â”ŠEngine.Game = class Game {\n+â”Š  â”Š 2â”Š  // The frequency of which each frame will be drawn in milliseconds\n+â”Š  â”Š 3â”Š  get fps() {\n+â”Š  â”Š 4â”Š    return 1000 / 60;\n+â”Š  â”Š 5â”Š  }\n+â”Š  â”Š 6â”Š\n+â”Š  â”Š 7â”Š  // Game's run speed.\n+â”Š  â”Š 8â”Š  // A lower value will make it run slower and a higher value will make it run faster\n+â”Š  â”Š 9â”Š  get speed() {\n+â”Š  â”Š10â”Š    return 1;\n+â”Š  â”Š11â”Š  }\n+â”Š  â”Š12â”Š\n+â”Š  â”Š13â”Š  constructor(canvas) {\n+â”Š  â”Š14â”Š    this.canvas = canvas;\n+â”Š  â”Š15â”Š    this.lastUpdate = this.creation = new Date().getTime();\n+â”Š  â”Š16â”Š\n+â”Š  â”Š17â”Š    // Canvas dimensions must be set programmatically otherwise you might encounter some\n+â”Š  â”Š18â”Š    // unexpected behaviors\n+â”Š  â”Š19â”Š    canvas.width = 1280;\n+â”Š  â”Š20â”Š    canvas.height = 720;\n+â”Š  â”Š21â”Š    // Canvas will be focused once game page is loaded so all events will automatically\n+â”Š  â”Š22â”Š    // be captured by it\n+â”Š  â”Š23â”Š    canvas.focus();\n+â”Š  â”Š24â”Š\n+â”Š  â”Š25â”Š    // We want to focus on the canvas once we press on it\n+â”Š  â”Š26â”Š    canvas.addEventListener(\"mousedown\", canvas.focus.bind(canvas), false);\n+â”Š  â”Š27â”Š\n+â”Š  â”Š28â”Š    this.assets = {};\n+â”Š  â”Š29â”Š    this.events = new Map();\n+â”Š  â”Š30â”Š    this.context = canvas.getContext(\"2d\");\n+â”Š  â”Š31â”Š    this.bufferedCanvas = document.createElement(\"canvas\");\n+â”Š  â”Š32â”Š    this.bufferedContext = this.bufferedCanvas.getContext(\"2d\");\n+â”Š  â”Š33â”Š    this.bufferedCanvas.width = canvas.width;\n+â”Š  â”Š34â”Š    this.bufferedCanvas.height = canvas.height;\n+â”Š  â”Š35â”Š  }\n+â”Š  â”Š36â”Š\n+â”Š  â”Š37â”Š  draw() {\n+â”Š  â”Š38â”Š    // Draw a black screen by default\n+â”Š  â”Š39â”Š    this.context.restore();\n+â”Š  â”Š40â”Š    this.context.fillStyle = \"black\";\n+â”Š  â”Š41â”Š    this.context.save();\n+â”Š  â”Š42â”Š    this.context.beginPath();\n+â”Š  â”Š43â”Š    this.context.rect(0, 0, this.canvas.width, this.canvas.height);\n+â”Š  â”Š44â”Š    this.context.fill();\n+â”Š  â”Š45â”Š  }\n+â”Š  â”Š46â”Š\n+â”Š  â”Š47â”Š  update() {\n+â”Š  â”Š48â”Š    // Calculate the time elapsed\n+â”Š  â”Š49â”Š    let lastUpdate = this.lastUpdate;\n+â”Š  â”Š50â”Š    let currUpdate = this.lastUpdate = new Date().getTime();\n+â”Š  â”Š51â”Š    let span = currUpdate - lastUpdate;\n+â”Š  â”Š52â”Š    this.updateScreen(span / this.speed);\n+â”Š  â”Š53â”Š  }\n+â”Š  â”Š54â”Š\n+â”Š  â”Š55â”Š  // The main loop of the game\n+â”Š  â”Š56â”Š  loop() {\n+â”Š  â”Š57â”Š    // If paused, don't run loop. The canvas will remain as is\n+â”Š  â”Š58â”Š    if (!this.playing) return;\n+â”Š  â”Š59â”Š\n+â”Š  â”Š60â”Š    setTimeout(() => {\n+â”Š  â”Š61â”Š      this.draw();\n+â”Š  â”Š62â”Š      this.update();\n+â”Š  â”Š63â”Š      this.loop();\n+â”Š  â”Š64â”Š    }, this.fps);\n+â”Š  â”Š65â”Š  }\n+â”Š  â”Š66â”Š\n+â”Š  â”Š67â”Š  play() {\n+â”Š  â”Š68â”Š    this.playing = true;\n+â”Š  â”Š69â”Š    this.loop();\n+â”Š  â”Š70â”Š  }\n+â”Š  â”Š71â”Š\n+â”Š  â”Š72â”Š  pause() {\n+â”Š  â”Š73â”Š    this.playing = false;\n+â”Š  â”Š74â”Š  }\n+â”Š  â”Š75â”Š\n+â”Š  â”Š76â”Š  // Defines global assets\n+â”Š  â”Š77â”Š  extendAssets(assets) {\n+â”Š  â”Š78â”Š    _.extend(this.assets, assets);\n+â”Š  â”Š79â”Š  }\n+â”Š  â”Š80â”Š\n+â”Š  â”Š81â”Š  // Disposes global assets\n+â”Š  â”Š82â”Š  clearAssets() {\n+â”Š  â”Š83â”Š    this.assets = {};\n+â”Š  â”Š84â”Š  }\n+â”Š  â”Š85â”Š\n+â”Š  â”Š86â”Š  // Adds event listener for game canvas\n+â”Š  â”Š87â”Š  addEventListener(type, listener, target) {\n+â”Š  â”Š88â”Š    let boundListener = listener.bind(target);\n+â”Š  â”Š89â”Š    this.events.set(listener, boundListener);\n+â”Š  â”Š90â”Š    this.canvas.addEventListener(type, boundListener, false);\n+â”Š  â”Š91â”Š  }\n+â”Š  â”Š92â”Š\n+â”Š  â”Š93â”Š  // Removes event listener from game canvas\n+â”Š  â”Š94â”Š  removeEventListener(type, listener) {\n+â”Š  â”Š95â”Š    let boundListener = this.events.get(listener);\n+â”Š  â”Š96â”Š    this.events.delete(listener);\n+â”Š  â”Š97â”Š    this.canvas.removeEventListener(type, boundListener, false);\n+â”Š  â”Š98â”Š  }\n+â”Š  â”Š99â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -9,6 +9,7 @@\n â”Š 9â”Š 9â”Š\n â”Š10â”Š10â”Š    <!-- Scripts -->\n â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n+â”Š  â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š12â”Š13â”Š\n â”Š13â”Š14â”Š    <!-- Styles -->\n â”Š14â”Š15â”Š    <link rel=\"stylesheet\" type=\"text/css\" href=\"/styles/game.css\">\n```\n\n[}]: #\n\nThe only thing it's doing right now is drawing a black background, but we're soon going to learn how to take advantage of this game-loop to draw stuff of our own. I'd like to point out that there is no need to implement a [double-buffer](https://en.wikipedia.org/wiki/Multiple_buffering) (A method similar to React's [virtual DOM](https://www.npmjs.com/package/react-dom)) when it comes to `HTMLCanvas` elements, since `HTML5` already does that for us. To start running the game, we first need to wait for the DOM content to initialize, and once it's ready we gonna create a new game instance and call the `play` method:\n\n[{]: <helper> (diffStep 2.6)\n\n#### [Step 2.6: Create game entry point](https://github.com/DAB0mB/radial-snake/commit/30e75df)\n\n##### Added resources&#x2F;scripts&#x2F;main.js\n```diff\n@@ -0,0 +1,4 @@\n+â”Š â”Š1â”Šdocument.addEventListener(\"DOMContentLoaded\", function(event) {\n+â”Š â”Š2â”Š  let game = new Engine.Game(document.getElementById(\"gameCanvas\"), false);\n+â”Š â”Š3â”Š  game.play();\n+â”Š â”Š4â”Š});ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -10,6 +10,7 @@\n â”Š10â”Š10â”Š    <!-- Scripts -->\n â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n â”Š12â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n+â”Š  â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n â”Š13â”Š14â”Š\n â”Š14â”Š15â”Š    <!-- Styles -->\n â”Š15â”Š16â”Š    <link rel=\"stylesheet\" type=\"text/css\" href=\"/styles/game.css\">\n```\n\n[}]: #\n\nThis will take control over the canvas and will draw a new picture every 17ms, which is 60fps (Frames per second). As for now you're only going to see a black canvas, but I promise the final result is not going to disappoint you.\n\nThe next thing we're gonna do would be adding a 'key state' manager, which will store a flag for each key pressed on the keyboard. Once we press the key, the flag's value would be `true`, and once we release it, its value would turn into `false`. This way we have an easy way to track all the key presses without registering a specific event listener for each key press we wanna track:\n\n[{]: <helper> (diffStep 2.7)\n\n#### [Step 2.7: Add key states manager](https://github.com/DAB0mB/radial-snake/commit/831b058)\n\n##### Added resources&#x2F;scripts&#x2F;engine&#x2F;key_states.js\n```diff\n@@ -0,0 +1,20 @@\n+â”Š  â”Š 1â”ŠEngine.KeyStates = class KeyStates {\n+â”Š  â”Š 2â”Š  constructor() {\n+â”Š  â”Š 3â”Š    // We will have 255 states, each one represents an ascii code matching its index\n+â”Š  â”Š 4â”Š    this.states = new Array(255);\n+â”Š  â”Š 5â”Š  }\n+â”Š  â”Š 6â”Š\n+â”Š  â”Š 7â”Š  get(k) {\n+â”Š  â”Š 8â”Š    return this.states[k];\n+â”Š  â”Š 9â”Š  }\n+â”Š  â”Š10â”Š\n+â”Š  â”Š11â”Š  // This should be called once we press a key\n+â”Š  â”Š12â”Š  add(k) {\n+â”Š  â”Š13â”Š    this.states[k] = true;\n+â”Š  â”Š14â”Š  }\n+â”Š  â”Š15â”Š\n+â”Š  â”Š16â”Š  // This should be called once we release a key\n+â”Š  â”Š17â”Š  remove(k) {\n+â”Š  â”Š18â”Š    this.states[k] = false;\n+â”Š  â”Š19â”Š  }\n+â”Š  â”Š20â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -9,6 +9,7 @@\n â”Š 9â”Š 9â”Š\n â”Š10â”Š10â”Š    <!-- Scripts -->\n â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n+â”Š  â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/key_states.js\"></script>\n â”Š12â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n```\n\n[}]: #\n\nNow that we have the key state manager, we will initialize a new instance as part of our game's essentials, and we will create a global event listener for key presses; Each time a key is pressed, the key state manager will update itself:\n\n[{]: <helper> (diffStep 2.8)\n\n#### [Step 2.8: Register key presses](https://github.com/DAB0mB/radial-snake/commit/9f55501)\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;game.js\n```diff\n@@ -14,7 +14,7 @@\n â”Š14â”Š14â”Š    this.canvas = canvas;\n â”Š15â”Š15â”Š    this.lastUpdate = this.creation = new Date().getTime();\n â”Š16â”Š16â”Š\n-â”Š17â”Š  â”Š    // Canvas dimensions must be set programmatically otherwise you might encounter some\n+â”Š  â”Š17â”Š    // Canvas dimensions must be set programmatically, otherwise you might encounter some\n â”Š18â”Š18â”Š    // unexpected behaviors\n â”Š19â”Š19â”Š    canvas.width = 1280;\n â”Š20â”Š20â”Š    canvas.height = 720;\n```\n```diff\n@@ -24,9 +24,13 @@\n â”Š24â”Š24â”Š\n â”Š25â”Š25â”Š    // We want to focus on the canvas once we press on it\n â”Š26â”Š26â”Š    canvas.addEventListener(\"mousedown\", canvas.focus.bind(canvas), false);\n+â”Š  â”Š27â”Š    // Key flags will be registered by the \"KeyStates\" instance\n+â”Š  â”Š28â”Š    canvas.addEventListener(\"keydown\", onKeyDown.bind(this), false);\n+â”Š  â”Š29â”Š    canvas.addEventListener(\"keyup\", onKeyUp.bind(this), false);\n â”Š27â”Š30â”Š\n â”Š28â”Š31â”Š    this.assets = {};\n â”Š29â”Š32â”Š    this.events = new Map();\n+â”Š  â”Š33â”Š    this.keyStates = new Engine.KeyStates();\n â”Š30â”Š34â”Š    this.context = canvas.getContext(\"2d\");\n â”Š31â”Š35â”Š    this.bufferedCanvas = document.createElement(\"canvas\");\n â”Š32â”Š36â”Š    this.bufferedContext = this.bufferedCanvas.getContext(\"2d\");\n```\n```diff\n@@ -96,4 +100,19 @@\n â”Š 96â”Š100â”Š    this.events.delete(listener);\n â”Š 97â”Š101â”Š    this.canvas.removeEventListener(type, boundListener, false);\n â”Š 98â”Š102â”Š  }\n-â”Š 99â”Š   â”Š};ðŸš«â†µ\n+â”Š   â”Š103â”Š};\n+â”Š   â”Š104â”Š\n+â”Š   â”Š105â”Šfunction onKeyDown(e) {\n+â”Š   â”Š106â”Š  // Once we're focused on the canvas, we want nothing else to happen\n+â”Š   â”Š107â”Š  // besides events the game is listening to. For example, when we press\n+â”Š   â”Š108â”Š  // the arrow keys, this will prevent the screen from scrolling\n+â”Š   â”Š109â”Š  e.preventDefault();\n+â”Š   â”Š110â”Š  // Register key press\n+â”Š   â”Š111â”Š  this.keyStates.add(e.keyCode);\n+â”Š   â”Š112â”Š}\n+â”Š   â”Š113â”Š\n+â”Š   â”Š114â”Šfunction onKeyUp(e) {\n+â”Š   â”Š115â”Š  e.preventDefault();\n+â”Š   â”Š116â”Š  // Register key release\n+â”Š   â”Š117â”Š  this.keyStates.remove(e.keyCode);\n+â”Š   â”Š118â”Š}\n```\n\n[}]: #\n\nA 2D game's view might get complex as we go through with its development and add more logic and entities into it. Having only one `draw` method and only one `update` method is not enough, and if you think of it, it might easily get buffed up into ridiculous dimensions, which is not the way to go. I'd like to introduce you into a new methodology which involves `screens` and `layers`:\n\n- **screen** - Will literally be used whenever we want to show a new screen in our game e.g. 'splash' screen and 'main menu' screen. A screen consists of multiple layers, and will be used as their communicator; All the relevant assets and logic will be initialized inside it.\n- **layer** - similar to Photoshop's layer system, any time we want to add something to the view we add new layers on top or beneath of each other.\n\n![screen-layer](https://cloud.githubusercontent.com/assets/7648874/21487708/9b366efe-cbb7-11e6-8669-3212e440871a.png)\n\nAs I said earlier, the purpose of the screens and the layers is just to split the task of updating and drawing and updating, so we can have logical segments; So the `layer` class should mainly consist of a `draw` and an `update` method:\n\n[{]: <helper> (diffStep 2.9)\n\n#### [Step 2.9: Add screen layer](https://github.com/DAB0mB/radial-snake/commit/736ab08)\n\n##### Added resources&#x2F;scripts&#x2F;engine&#x2F;layer.js\n```diff\n@@ -0,0 +1,43 @@\n+â”Š  â”Š 1â”ŠEngine.Layer = class Layer {\n+â”Š  â”Š 2â”Š  // The dimensions of the layer are correlated to dimensions of the canvas\n+â”Š  â”Š 3â”Š  get width() {\n+â”Š  â”Š 4â”Š    return this.canvas.width;\n+â”Š  â”Š 5â”Š  }\n+â”Š  â”Š 6â”Š\n+â”Š  â”Š 7â”Š  get height() {\n+â”Š  â”Š 8â”Š    return this.canvas.height;\n+â”Š  â”Š 9â”Š  }\n+â”Š  â”Š10â”Š\n+â”Š  â”Š11â”Š  // A hash of \"eventName\" : \"handlerName\" which should be overrided by user\n+â”Š  â”Š12â”Š  get events() {\n+â”Š  â”Š13â”Š    return {};\n+â”Š  â”Š14â”Š  }\n+â”Š  â”Š15â”Š\n+â”Š  â”Š16â”Š  constructor(screen) {\n+â”Š  â”Š17â”Š    this.age = 0;\n+â”Š  â”Š18â”Š    this.creation = new Date().getTime();\n+â”Š  â”Š19â”Š    this.screen = screen;\n+â”Š  â”Š20â”Š    this.game = screen.game;\n+â”Š  â”Š21â”Š    this.assets = screen.assets;\n+â”Š  â”Š22â”Š    this.keyStates = screen.keyStates;\n+â”Š  â”Š23â”Š    this.canvas = screen.game.canvas;\n+â”Š  â”Š24â”Š  }\n+â”Š  â”Š25â”Š\n+â”Š  â”Š26â”Š  update(span) {\n+â”Š  â”Š27â”Š  }\n+â”Š  â”Š28â”Š\n+â”Š  â”Š29â”Š  draw(context) {\n+â”Š  â”Š30â”Š  }\n+â”Š  â”Š31â”Š\n+â”Š  â”Š32â”Š  initEventListeners() {\n+â”Š  â”Š33â”Š    _.each(this.events, (listener, event) => {\n+â”Š  â”Š34â”Š      this.game.addEventListener(event, this[listener], this);\n+â”Š  â”Š35â”Š    });\n+â”Š  â”Š36â”Š  }\n+â”Š  â”Š37â”Š\n+â”Š  â”Š38â”Š  disposeEventListeners() {\n+â”Š  â”Š39â”Š    _.each(this.events, (listener, event) => {\n+â”Š  â”Š40â”Š      this.game.removeEventListener(event, this[listener]);\n+â”Š  â”Š41â”Š    });\n+â”Š  â”Š42â”Š  }\n+â”Š  â”Š43â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -10,6 +10,7 @@\n â”Š10â”Š10â”Š    <!-- Scripts -->\n â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n â”Š12â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/key_states.js\"></script>\n+â”Š  â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/layer.js\"></script>\n â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š14â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n```\n\n[}]: #\n\nSame thing for the screen, it only has a `draw` and `update` methods, only it has a stack of layers, which can either be added or removed:\n\n[{]: <helper> (diffStep 2.1)\n\n#### [Step 2.1: Create basic game view](https://github.com/DAB0mB/radial-snake/commit/254f06f)\n\n##### Added views&#x2F;game.html\n```diff\n@@ -0,0 +1,10 @@\n+â”Š  â”Š 1â”Š<!DOCTYPE html>\n+â”Š  â”Š 2â”Š<html>\n+â”Š  â”Š 3â”Š  <head>\n+â”Š  â”Š 4â”Š    <title>radial snake</title>\n+â”Š  â”Š 5â”Š  </head>\n+â”Š  â”Š 6â”Š\n+â”Š  â”Š 7â”Š  <body>\n+â”Š  â”Š 8â”Š    <canvas id=\"gameCanvas\" tabindex=\"0\"></canvas>\n+â”Š  â”Š 9â”Š  </body>\n+â”Š  â”Š10â”Š</html>ðŸš«â†µ\n```\n\n[}]: #\n\nNow that we have the `screen` class available for us, let's apply it to the main game loop:\n\n[{]: <helper> (diffStep 2.11)\n\n#### [Step 2.11: Draw and update screen in game loop](https://github.com/DAB0mB/radial-snake/commit/9f34754)\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;game.js\n```diff\n@@ -30,6 +30,7 @@\n â”Š30â”Š30â”Š\n â”Š31â”Š31â”Š    this.assets = {};\n â”Š32â”Š32â”Š    this.events = new Map();\n+â”Š  â”Š33â”Š    this.screen = new Engine.Screen(this);\n â”Š33â”Š34â”Š    this.keyStates = new Engine.KeyStates();\n â”Š34â”Š35â”Š    this.context = canvas.getContext(\"2d\");\n â”Š35â”Š36â”Š    this.bufferedCanvas = document.createElement(\"canvas\");\n```\n```diff\n@@ -46,6 +47,13 @@\n â”Š46â”Š47â”Š    this.context.beginPath();\n â”Š47â”Š48â”Š    this.context.rect(0, 0, this.canvas.width, this.canvas.height);\n â”Š48â”Š49â”Š    this.context.fill();\n+â”Š  â”Š50â”Š    this.drawScreen(this.context);\n+â”Š  â”Š51â”Š  }\n+â”Š  â”Š52â”Š\n+â”Š  â”Š53â”Š  drawScreen(context) {\n+â”Š  â”Š54â”Š    // If screen's assets are not yet loaded, don't draw it\n+â”Š  â”Š55â”Š    if (this.screen.loading) return;\n+â”Š  â”Š56â”Š    if (this.screen.draw) this.screen.draw(context);\n â”Š49â”Š57â”Š  }\n â”Š50â”Š58â”Š\n â”Š51â”Š59â”Š  update() {\n```\n```diff\n@@ -56,6 +64,13 @@\n â”Š56â”Š64â”Š    this.updateScreen(span / this.speed);\n â”Š57â”Š65â”Š  }\n â”Š58â”Š66â”Š\n+â”Š  â”Š67â”Š  updateScreen(span) {\n+â”Š  â”Š68â”Š    this.screen.age += span;\n+â”Š  â”Š69â”Š    // If screen's assets are not yet loaded, don't update it\n+â”Š  â”Š70â”Š    if (this.screen.loading) return;\n+â”Š  â”Š71â”Š    if (this.screen.update) this.screen.update(span);\n+â”Š  â”Š72â”Š  }\n+â”Š  â”Š73â”Š\n â”Š59â”Š74â”Š  // The main loop of the game\n â”Š60â”Š75â”Š  loop() {\n â”Š61â”Š76â”Š    // If paused, don't run loop. The canvas will remain as is\n```\n\n[}]: #\n\nThis step looks kind of useless for now, unless we will have the ability to change screens as we please. Any time a screen is changed, it should be loaded with its necessary assets e.g textures, sounds, fonts, etc. The assets loading is an asynchronous operation whose logic might get a bit messy if not managed properly. To make it easier, we're going to define an assets loader, which will help us load assets asynchronously:\n\n[{]: <helper> (diffStep 2.12)\n\n#### [Step 2.12: Add assets loader](https://github.com/DAB0mB/radial-snake/commit/d8895f8)\n\n##### Added resources&#x2F;scripts&#x2F;engine&#x2F;assets_loader.js\n```diff\n@@ -0,0 +1,13 @@\n+â”Š  â”Š 1â”ŠEngine.AssetsLoader = class AssetsLoader {\n+â”Š  â”Š 2â”Š  constructor(next) {\n+â”Š  â”Š 3â”Š    this.next = next;\n+â”Š  â”Š 4â”Š  }\n+â”Š  â”Š 5â”Š\n+â”Š  â”Š 6â”Š  // Load texture\n+â”Š  â”Š 7â”Š  texture(path) {\n+â”Š  â”Š 8â”Š    let image = new Image();\n+â”Š  â”Š 9â”Š    image.onload = this.next();\n+â”Š  â”Š10â”Š    image.src = `${path}.png`;\n+â”Š  â”Š11â”Š    return image;\n+â”Š  â”Š12â”Š  }\n+â”Š  â”Š13â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -12,6 +12,7 @@\n â”Š12â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/key_states.js\"></script>\n â”Š13â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/layer.js\"></script>\n â”Š14â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/screen.js\"></script>\n+â”Š  â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/assets_loader.js\"></script>\n â”Š15â”Š16â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š16â”Š17â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n```\n\n[}]: #\n\n> As for now the `assets loader` only has the ability to load textures, but we will extend it as we go further in this tutorial, no need to overdo it.\n\nNow that we have the `assets loader` we can add the ability to change a screen. Whenever we change a screen, the old screen's assets should be unloaded, and the new screen's assets should be loaded using the `assets loader`:\n\n[{]: <helper> (diffStep 2.13)\n\n#### [Step 2.13: Add the ability to change and load screen](https://github.com/DAB0mB/radial-snake/commit/90aab03)\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;game.js\n```diff\n@@ -92,6 +92,61 @@\n â”Š 92â”Š 92â”Š    this.playing = false;\n â”Š 93â”Š 93â”Š  }\n â”Š 94â”Š 94â”Š\n+â”Š   â”Š 95â”Š  changeScreen(Screen, ...screenArgs) {\n+â”Š   â”Š 96â”Š    // If there is a screen defined, dispose it first\n+â”Š   â”Š 97â”Š    if (this.screen) {\n+â”Š   â”Š 98â”Š      this.unloadScreen();\n+â”Š   â”Š 99â”Š      this.screen.disposeEventListeners();\n+â”Š   â”Š100â”Š    }\n+â”Š   â”Š101â”Š\n+â”Š   â”Š102â”Š    this.screen = new Screen(this, ...screenArgs);\n+â”Š   â”Š103â”Š\n+â”Š   â”Š104â”Š    // Load screen assets\n+â”Š   â”Š105â”Š    this.loadScreen(() => {\n+â”Š   â”Š106â”Š      // Once assets are loaded, initialize event listeners\n+â”Š   â”Š107â”Š      this.screen.initEventListeners();\n+â”Š   â”Š108â”Š      // The \"initialize\" method is exactly the same as the constructor, only it runs\n+â”Š   â”Š109â”Š      // once assets are available and event listeners are registered\n+â”Š   â”Š110â”Š      this.screen.initialize(this, ...screenArgs);\n+â”Š   â”Š111â”Š    });\n+â”Š   â”Š112â”Š  }\n+â”Š   â”Š113â”Š\n+â”Š   â”Š114â”Š  // Loads screen assets and invokes callback once loading is finished\n+â”Š   â”Š115â”Š  loadScreen(callback = _.noop) {\n+â”Š   â”Š116â”Š    if (!this.screen.load) return callback();\n+â”Š   â”Š117â”Š\n+â”Š   â”Š118â”Š    this.screen.loading = true;\n+â”Š   â”Š119â”Š    // The number of assets to load\n+â”Š   â”Š120â”Š    let loadsize = 0;\n+â”Š   â”Š121â”Š    let onload;\n+â”Š   â”Š122â”Š\n+â”Š   â”Š123â”Š    // This object can load assets\n+â”Š   â”Š124â”Š    let assetsLoader = new Engine.AssetsLoader(() => {\n+â”Š   â”Š125â”Š      loadsize++;\n+â”Š   â”Š126â”Š      return () => onload();\n+â”Š   â”Š127â”Š    });\n+â”Š   â”Š128â”Š\n+â”Š   â”Š129â”Š    // The \"load\" method returns the assets loaded by the screen\n+â”Š   â”Š130â”Š    let screenAssets = this.screen.load(assetsLoader);\n+â”Š   â”Š131â”Š\n+â”Š   â”Š132â”Š    // We use the \"after\" method because we want the following callback to be invoked\n+â”Š   â”Š133â”Š    // only once all assets are loaded\n+â”Š   â”Š134â”Š    onload = _.after(loadsize, () => {\n+â”Š   â”Š135â”Š      delete this.screen.loading;\n+â”Š   â”Š136â”Š      callback();\n+â”Š   â”Š137â”Š    });\n+â”Š   â”Š138â”Š\n+â”Š   â”Š139â”Š    // The returned assets will be available on screen's assets object\n+â”Š   â”Š140â”Š    _.extend(this.screen.assets, screenAssets);\n+â”Š   â”Š141â”Š  }\n+â”Š   â”Š142â”Š\n+â”Š   â”Š143â”Š  // Disposes screen assets\n+â”Š   â”Š144â”Š  unloadScreen() {\n+â”Š   â”Š145â”Š    if (!this.screen.unload) return;\n+â”Š   â”Š146â”Š    let assetsNames = this.screen.unload();\n+â”Š   â”Š147â”Š    _.omit(this.assets, assetsNames);\n+â”Š   â”Š148â”Š  }\n+â”Š   â”Š149â”Š\n â”Š 95â”Š150â”Š  // Defines global assets\n â”Š 96â”Š151â”Š  extendAssets(assets) {\n â”Š 97â”Š152â”Š    _.extend(this.assets, assets);\n```\n\n[}]: #\n\nLet's add a test screen just so we can get the hang of it. The test screen will only print a message to the canvas:\n\n[{]: <helper> (diffStep 2.14)\n\n#### [Step 2.14: Add test screen](https://github.com/DAB0mB/radial-snake/commit/85776e8)\n\n##### Added resources&#x2F;scripts&#x2F;test_screen.js\n```diff\n@@ -0,0 +1,10 @@\n+â”Š  â”Š 1â”Šclass TestScreen extends Engine.Screen {\n+â”Š  â”Š 2â”Š  draw(context) {\n+â”Š  â”Š 3â”Š    // A 20px sized \"Georgia\" font (Available natively)\n+â”Š  â”Š 4â”Š    context.font = \"20px Georgia\";\n+â”Š  â”Š 5â”Š    // The text should be colored white\n+â”Š  â”Š 6â”Š    context.fillStyle = \"white\";\n+â”Š  â”Š 7â”Š    // Draw the following message 50px from the left and 50px from the top\n+â”Š  â”Š 8â”Š    context.fillText(\"This is a Test Screen\", 50, 50);\n+â”Š  â”Š 9â”Š  }\n+â”Š  â”Š10â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -14,6 +14,7 @@\n â”Š14â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/screen.js\"></script>\n â”Š15â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/assets_loader.js\"></script>\n â”Š16â”Š16â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n+â”Š  â”Š17â”Š    <script type=\"text/javascript\" src=\"/scripts/test_screen.js\"></script>\n â”Š17â”Š18â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n â”Š18â”Š19â”Š\n â”Š19â”Š20â”Š    <!-- Styles -->\n```\n\n[}]: #\n\nNow we will use the test screen by changing to it as we create an instance of the game:\n\n[{]: <helper> (diffStep 2.15)\n\n#### [Step 2.15: Set test screen as the initial screen](https://github.com/DAB0mB/radial-snake/commit/203d084)\n\n##### Changed resources&#x2F;scripts&#x2F;main.js\n```diff\n@@ -1,4 +1,5 @@\n â”Š1â”Š1â”Šdocument.addEventListener(\"DOMContentLoaded\", function(event) {\n â”Š2â”Š2â”Š  let game = new Engine.Game(document.getElementById(\"gameCanvas\"), false);\n+â”Š â”Š3â”Š  game.changeScreen(TestScreen);\n â”Š3â”Š4â”Š  game.play();\n â”Š4â”Š5â”Š});ðŸš«â†µ\n```\n\n[}]: #\n\nOnce you will load the application you should see a black canvas with a white text saying:\n\n    This is a test screen\n\nIt means our screen system works and you may proceed to the next step, where we're gonna create our first screen :-)"
          },
          {
            "manualTitle": "Step 3: Creating a splash screen using a keyframe animation engine",
            "stepRevision": "4b2431bbc910f8945e5fd86aa964fec3ede8761c",
            "manualView": "![snake-demo-splash-small](https://cloud.githubusercontent.com/assets/7648874/21074086/a19fa9ce-bed6-11e6-9060-2ce94c215712.gif)\n\nIn this step we will be creating the `splash` screen - the initial screen that should be shown once we launch the game. Our splash is consisted of a random logo animation as presented in the `gif` file above. The \"splash\" effect can be achieved using 2 concepts:\n\n- A sprite class - Which will present the logo texture in different dimensions, angles and rotations.\n- A key-frame animation - Which will draw an animation automatically along the time axis using key-frames - each is a sprite representation of the texture in a specific time point.\n\nSo first thing first, we will start by implementing the sprite class:\n\n[{]: <helper> (diffStep 3.1)\n\n#### [Step 3.1: Create &#x27;Sprite&#x27; class](https://github.com/DAB0mB/radial-snake/commit/a32a711)\n\n##### Added resources&#x2F;scripts&#x2F;engine&#x2F;sprite.js\n```diff\n@@ -0,0 +1,58 @@\n+â”Š  â”Š 1â”ŠEngine.Sprite = class Sprite {\n+â”Š  â”Š 2â”Š  // An easy representation of a sprite on a canvas, with a set of convenient tools\n+â”Š  â”Š 3â”Š  // for alignment and coloring\n+â”Š  â”Š 4â”Š  constructor(texture) {\n+â”Š  â”Š 5â”Š    this.texture = texture;\n+â”Š  â”Š 6â”Š    this.x = 0;\n+â”Š  â”Š 7â”Š    this.y = 0;\n+â”Š  â”Š 8â”Š    this.width = texture.width;\n+â”Š  â”Š 9â”Š    this.height = texture.height;\n+â”Š  â”Š10â”Š    this.pivot = { x: 0, y: 0 };\n+â”Š  â”Š11â”Š    this.opacity = 1;\n+â”Š  â”Š12â”Š  }\n+â”Š  â”Š13â”Š\n+â”Š  â”Š14â”Š  draw(context, offsetX = 0, offsetY = 0) {\n+â”Š  â”Š15â”Š    context.save();\n+â”Š  â”Š16â”Š    context.globalAlpha = this.opacity;\n+â”Š  â”Š17â”Š\n+â”Š  â”Š18â”Š    // The following switch-case can also be seen as a list of all possible\n+â”Š  â”Š19â”Š    // alignment modes\n+â”Š  â”Š20â”Š    switch (this.align) {\n+â”Š  â”Š21â”Š      case \"top-left\": case \"left-top\": this.pivot = { x: 0, y: 0 }; break;\n+â”Š  â”Š22â”Š      case \"top-right\": case \"right-top\": this.pivot = { x: this.width, y: 0 }; break;\n+â”Š  â”Š23â”Š      case \"bottom-left\": case \"left-bottom\": this.pivot = { x: 0, y: this.height }; break;\n+â”Š  â”Š24â”Š      case \"bottom-right\": case \"right-bottom\": this.pivot = { x: this.width, y: this.height }; break;\n+â”Š  â”Š25â”Š      case \"middle\": case \"center\": this.pivot = { x: this.width / 2, y: this.height / 2 }; break;\n+â”Š  â”Š26â”Š      case \"left\": this.pivot = { x: 0, y: this.height / 2 }; break;\n+â”Š  â”Š27â”Š      case \"top\": this.pivot = { x: this.width / 2, y: 0 }; break;\n+â”Š  â”Š28â”Š      case \"right\": this.pivot = { x: this.width, y: this.height / 2 }; break;\n+â”Š  â”Š29â”Š      case \"bottom\": this.pivot = { x: this.width / 2, y: this.height }; break;\n+â”Š  â”Š30â”Š    }\n+â”Š  â”Š31â”Š\n+â”Š  â”Š32â”Š    context.drawImage(\n+â”Š  â”Š33â”Š      this.texture,\n+â”Š  â”Š34â”Š      (this.x - this.pivot.x) + offsetX,\n+â”Š  â”Š35â”Š      (this.y - this.pivot.y) + offsetY,\n+â”Š  â”Š36â”Š      this.width,\n+â”Š  â”Š37â”Š      this.height\n+â”Š  â”Š38â”Š    );\n+â”Š  â”Š39â”Š\n+â”Š  â”Š40â”Š    context.restore();\n+â”Š  â”Š41â”Š  }\n+â”Š  â”Š42â”Š\n+â”Š  â”Š43â”Š  // A sprite property (key) can also be resized based on a given percentage.\n+â”Š  â”Š44â”Š  // The 'relative' argument represents the whole of which the percents are gonna be\n+â”Š  â”Š45â”Š  // calculated from, and the 'adapters' argument is an array of property names which\n+â”Š  â”Š46â”Š  // gonna adapt themselves based on the changes made in the given key.\n+â”Š  â”Š47â”Š  // Usually 'width' goes along with ['height'] adapters, if we\n+â”Š  â”Š48â”Š  // want to keep their original ratio\n+â”Š  â”Š49â”Š  setPercentage(key, relative, percents, ...adapters) {\n+â”Š  â”Š50â”Š    let oldVal = this[key];\n+â”Š  â”Š51â”Š    let newVal = this[key] = (percents * relative) / 100;\n+â”Š  â”Š52â”Š    let ratio = newVal / oldVal;\n+â”Š  â”Š53â”Š\n+â”Š  â”Š54â”Š    adapters.forEach(adapter => {\n+â”Š  â”Š55â”Š      this[adapter] *= ratio;\n+â”Š  â”Š56â”Š    });\n+â”Š  â”Š57â”Š  }\n+â”Š  â”Š58â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -9,6 +9,7 @@\n â”Š 9â”Š 9â”Š\n â”Š10â”Š10â”Š    <!-- Scripts -->\n â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n+â”Š  â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/sprite.js\"></script>\n â”Š12â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/key_states.js\"></script>\n â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/layer.js\"></script>\n â”Š14â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/screen.js\"></script>\n```\n\n[}]: #\n\nAnd we will download the logo which will be presented in the splash screen using the sprite class:\n\n    resources$ mkdir assets\n    resources$ cd assets\n    resources/assets$ mkdir textures\n    resources/assets$ cd textures\n    resources/assets/textures$ wget raw.githubusercontent.com/dab0mb/radial-snake/master/resources/assets/textures/splash.png\n\n> Any logo can that you desired can be used instead! But to ease things up I already provided you with one as a sample\n\nNow we will create the initial splash screen, where we only gonna show a sprite of the logo in the middle of the screen, with no animation applied yet. We will first define a dedicated `Screens` module under the `Game` namespace:\n\n[{]: <helper> (diffStep 3.3)\n\n#### [Step 3.3: Create a &#x27;Game&#x27; namespace with a &#x27;Screens&#x27; module](https://github.com/DAB0mB/radial-snake/commit/ae85a96)\n\n##### Changed resources&#x2F;scripts&#x2F;namespaces.js\n```diff\n@@ -1 +1,5 @@\n+â”Š â”Š1â”ŠGame = {\n+â”Š â”Š2â”Š  Screens: {}\n+â”Š â”Š3â”Š};\n+â”Š â”Š4â”Š\n â”Š1â”Š5â”ŠEngine = {};ðŸš«â†µ\n```\n\n[}]: #\n\nAnd we can go ahead and implement the screen itself:\n\n[{]: <helper> (diffStep 3.4)\n\n#### [Step 3.4: Create initial splash screen](https://github.com/DAB0mB/radial-snake/commit/4dd73f3)\n\n##### Added resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;splash&#x2F;index.js\n```diff\n@@ -0,0 +1,19 @@\n+â”Š  â”Š 1â”ŠGame.Screens.Splash = class Splash extends Engine.Screen {\n+â”Š  â”Š 2â”Š  initialize() {\n+â”Š  â”Š 3â”Š    // Create splash sprite and set its properties\n+â”Š  â”Š 4â”Š    this.splashSprite = new Engine.Sprite(this.assets.splashTexture);\n+â”Š  â”Š 5â”Š    this.splashSprite.align = \"center\";\n+â”Š  â”Š 6â”Š    this.splashSprite.x = this.width / 2;\n+â”Š  â”Š 7â”Š  }\n+â”Š  â”Š 8â”Š\n+â”Š  â”Š 9â”Š  load(assetsLoader) {\n+â”Š  â”Š10â”Š    // These are local assets which will be disposed along with the screen\n+â”Š  â”Š11â”Š    return {\n+â”Š  â”Š12â”Š      splashTexture: assetsLoader.texture(\"/textures/splash\")\n+â”Š  â”Š13â”Š    };\n+â”Š  â”Š14â”Š  }\n+â”Š  â”Š15â”Š\n+â”Š  â”Š16â”Š  draw(context) {\n+â”Š  â”Š17â”Š    this.splashSprite.draw(context);\n+â”Š  â”Š18â”Š  }\n+â”Š  â”Š19â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -16,6 +16,7 @@\n â”Š16â”Š16â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/assets_loader.js\"></script>\n â”Š17â”Š17â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š18â”Š18â”Š    <script type=\"text/javascript\" src=\"/scripts/test_screen.js\"></script>\n+â”Š  â”Š19â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/splash/index.js\"></script>\n â”Š19â”Š20â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n â”Š20â”Š21â”Š\n â”Š21â”Š22â”Š    <!-- Styles -->\n```\n\n[}]: #\n\nNow we can set the splash screen as the initial screen in the entry script file:\n\n[{]: <helper> (diffStep 3.5)\n\n#### [Step 3.5: Set splash screen as the initial game screen](https://github.com/DAB0mB/radial-snake/commit/3576ff8)\n\n##### Changed resources&#x2F;scripts&#x2F;main.js\n```diff\n@@ -1,5 +1,5 @@\n â”Š1â”Š1â”Šdocument.addEventListener(\"DOMContentLoaded\", function(event) {\n â”Š2â”Š2â”Š  let game = new Engine.Game(document.getElementById(\"gameCanvas\"), false);\n-â”Š3â”Š â”Š  game.changeScreen(TestScreen);\n+â”Š â”Š3â”Š  game.changeScreen(Game.Screens.Splash);\n â”Š4â”Š4â”Š  game.play();\n â”Š5â”Š5â”Š});ðŸš«â†µ\n```\n\n[}]: #\n\nAnd we will get rid of the unnecessary test screen since we make no use of it any longer:\n\n    $ rm resources/scripts/test_screen.js\n\nWe will now proceed into the next stage where we will be implementing the key-frame animation engine as said at the beginning of the step. We first need to define an `Animations` module, since we can have multiple types of animation strategy like [sprite-atlas animation](http://www.joshmorony.com/how-to-create-animations-in-phaser-with-a-texture-atlas/), not necessarily a key-frame animation:\n\n[{]: <helper> (diffStep 3.7)\n\n#### [Step 3.7: Add &#x27;Animations&#x27; module to &#x27;Engine&#x27; namespace](https://github.com/DAB0mB/radial-snake/commit/ffe800c)\n\n##### Changed resources&#x2F;scripts&#x2F;namespaces.js\n```diff\n@@ -2,4 +2,6 @@\n â”Š2â”Š2â”Š  Screens: {}\n â”Š3â”Š3â”Š};\n â”Š4â”Š4â”Š\n-â”Š5â”Š â”ŠEngine = {};ðŸš«â†µ\n+â”Š â”Š5â”ŠEngine = {\n+â”Š â”Š6â”Š  Animations: {}\n+â”Š â”Š7â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nInside the newly created module we will create the key-frame animation engine. The key-frame animation consists of the following methods:\n\n- update - Updates the animation.\n- draw - Draws the current animation frame on the provided canvas context.\n- play - Enables update operations.\n- pause - Disables update operations.\n\n[{]: <helper> (diffStep 3.8)\n\n#### [Step 3.8: Create a key-frame animation engine](https://github.com/DAB0mB/radial-snake/commit/64c58fb)\n\n##### Added resources&#x2F;scripts&#x2F;engine&#x2F;animations&#x2F;keyframe.js\n```diff\n@@ -0,0 +1,142 @@\n+â”Š   â”Š  1â”ŠEngine.Animations.Keyframe = class Keyframe {\n+â”Š   â”Š  2â”Š  constructor(sprite, keyframes) {\n+â”Š   â”Š  3â”Š    this.sprite = sprite;\n+â”Š   â”Š  4â”Š    // The key-frames array contains objects with the properties of the\n+â”Š   â”Š  5â”Š    // sprite at the current time-point, e.g. width of 100 and height of 200\n+â”Š   â”Š  6â”Š    this.keyframes = keyframes;\n+â”Š   â”Š  7â”Š    this.age = 0;\n+â”Š   â”Š  8â”Š    this.frame = 0;\n+â”Š   â”Š  9â”Š    // This flag determines what's gonna happen to the animation once\n+â”Š   â”Š 10â”Š    // it's finished playing\n+â”Š   â”Š 11â”Š    this.repetitionMode = \"none\";\n+â”Š   â”Š 12â”Š    this.lastKeyframe = _.last(keyframes);\n+â”Š   â”Š 13â”Š    this.lastFrame = this.lastKeyframe.frame;\n+â”Š   â”Š 14â”Š\n+â”Š   â”Š 15â”Š    // These are the properties which we can animate\n+â”Š   â”Š 16â”Š    this.animables = [\n+â”Š   â”Š 17â”Š      \"x\", \"y\", \"width\", \"height\", \"opacity\"\n+â”Š   â”Š 18â”Š    ];\n+â”Š   â”Š 19â”Š\n+â”Š   â”Š 20â”Š    // Set a map whose keys represent animatable properties and values represent an array\n+â”Š   â”Š 21â”Š    // with relevant key-frames to its belonging property\n+â”Š   â”Š 22â”Š    this.trimmedKeyframes = this.animables.reduce((trimmedKeyframes, key) => {\n+â”Š   â”Š 23â”Š      trimmedKeyframes[key] = keyframes.filter(keyframe => keyframe[key] != null);\n+â”Š   â”Š 24â”Š      return trimmedKeyframes;\n+â”Š   â”Š 25â”Š    }, {});\n+â”Š   â”Š 26â”Š\n+â”Š   â”Š 27â”Š    // Set initial properties on sprite based on initial key-frame\n+â”Š   â”Š 28â”Š    _.each(keyframes[0], (value, key) => {\n+â”Š   â”Š 29â”Š      if (this.animables.includes(key)) sprite[key] = value;\n+â”Š   â”Š 30â”Š    });\n+â”Š   â”Š 31â”Š  }\n+â”Š   â”Š 32â”Š\n+â”Š   â”Š 33â”Š  draw(context, offsetX, offsetY) {\n+â”Š   â”Š 34â”Š    this.sprite.draw(context, offsetX, offsetY);\n+â”Š   â”Š 35â”Š  }\n+â”Š   â”Š 36â”Š\n+â”Š   â”Š 37â”Š  update(span) {\n+â”Š   â”Š 38â”Š    if (!this.playing) return;\n+â”Š   â”Š 39â”Š\n+â”Š   â”Š 40â”Š    this.age += span;\n+â”Š   â”Š 41â”Š\n+â”Š   â”Š 42â”Š    switch (this.repetitionMode) {\n+â”Š   â”Š 43â”Š      // After one cycle animation would stop\n+â”Š   â”Š 44â”Š      case \"none\":\n+â”Š   â”Š 45â”Š        this.frame += span;\n+â”Š   â”Š 46â”Š\n+â”Š   â”Š 47â”Š        if (this.frame > this.lastFrame) {\n+â”Š   â”Š 48â”Š          this.frame = this.lastFrame;\n+â”Š   â”Š 49â”Š          this.playing = false;\n+â”Š   â”Š 50â”Š        }\n+â”Š   â”Š 51â”Š\n+â”Š   â”Š 52â”Š        break;\n+â”Š   â”Š 53â”Š\n+â”Š   â”Š 54â”Š      // Once finished, replay from the beginning\n+â”Š   â”Š 55â”Š      case \"cyclic\":\n+â”Š   â”Š 56â”Š        this.frame = this.age % this.lastFrame;\n+â”Š   â”Š 57â”Š        break;\n+â”Š   â”Š 58â”Š\n+â”Š   â”Š 59â”Š      // Once finished, play backwards, and so on\n+â”Š   â”Š 60â”Š      case \"full\":\n+â”Š   â”Š 61â”Š        this.frame = this.age % this.lastFrame;\n+â”Š   â”Š 62â”Š        let animationComplete = (this.age / this.lastFrame) % 2 >= 1;\n+â”Š   â”Š 63â”Š        if (animationComplete) this.frame = this.lastFrame - this.frame;\n+â”Š   â”Š 64â”Š        break;\n+â”Š   â”Š 65â”Š    }\n+â”Š   â”Š 66â”Š\n+â”Š   â”Š 67â”Š    // Update sprite properties based on given key-frame's easing mode\n+â”Š   â”Š 68â”Š    this.animables.forEach(key => {\n+â”Š   â”Š 69â”Š      let motion = this.getKeyframeMotion(key);\n+â”Š   â”Š 70â”Š\n+â”Š   â”Š 71â”Š      if (motion)\n+â”Š   â”Š 72â”Š        this.sprite[key] = this.calculateRelativeValue(motion, key);\n+â”Š   â”Š 73â”Š    });\n+â”Š   â”Š 74â”Š  }\n+â”Š   â”Š 75â”Š\n+â”Š   â”Š 76â”Š  play() {\n+â”Š   â”Š 77â”Š    this.playing = true;\n+â”Š   â”Š 78â”Š  }\n+â”Š   â”Š 79â”Š\n+â”Š   â”Š 80â”Š  pause() {\n+â”Š   â”Š 81â”Š    this.playing = false;\n+â”Š   â”Š 82â”Š  }\n+â”Š   â”Š 83â”Š\n+â”Š   â”Š 84â”Š  // Gets motion for current refresh\n+â”Š   â”Š 85â”Š  getKeyframeMotion(key) {\n+â”Š   â”Š 86â”Š    let keyframes = this.trimmedKeyframes[key];\n+â”Š   â”Š 87â”Š\n+â”Š   â”Š 88â”Š    // If no key-frames defined, motion is idle\n+â”Š   â”Š 89â”Š    if (keyframes == null) return;\n+â”Š   â”Š 90â”Š    // If there is only one key frame, motion is idle\n+â”Š   â”Š 91â”Š    if (keyframes.length < 2) return;\n+â”Š   â”Š 92â”Š    // If last frame reached, motion is idle\n+â”Š   â”Š 93â”Š    if (this.frame > _.last(keyframes).frame) return;\n+â”Š   â”Š 94â”Š\n+â”Š   â”Š 95â”Š    let start = this.findStartKeyframe(keyframes);\n+â”Š   â”Š 96â”Š    let end = this.findEndKeyframe(keyframes);\n+â”Š   â”Š 97â”Š    let ratio = this.getKeyframesRatio(start, end);\n+â”Š   â”Š 98â”Š\n+â”Š   â”Š 99â”Š    return { start, end, ratio };\n+â”Š   â”Š100â”Š  }\n+â”Š   â”Š101â”Š\n+â”Š   â”Š102â”Š  // Gets the movement ratio\n+â”Š   â”Š103â”Š  getKeyframesRatio(start, end) {\n+â”Š   â”Š104â”Š    return (this.frame - start.frame) / (end.frame - start.frame);\n+â”Š   â”Š105â”Š  }\n+â”Š   â”Š106â”Š\n+â”Š   â”Š107â”Š  // Get property end value based on current frame\n+â”Š   â”Š108â”Š  findEndKeyframe(keyframes) {\n+â”Š   â”Š109â”Š    return _.find(keyframes, keyframe =>\n+â”Š   â”Š110â”Š      keyframe.frame >= (this.frame || 1)\n+â”Š   â”Š111â”Š    );\n+â”Š   â”Š112â”Š  }\n+â”Š   â”Š113â”Š\n+â”Š   â”Š114â”Š  // Get property start value based on current frame\n+â”Š   â”Š115â”Š  findStartKeyframe(keyframes) {\n+â”Š   â”Š116â”Š    let resultIndex;\n+â”Š   â”Š117â”Š\n+â”Š   â”Š118â”Š    keyframes.some((keyframe, currIndex) => {\n+â”Š   â”Š119â”Š      if (keyframe.frame >= (this.frame || 1)) {\n+â”Š   â”Š120â”Š        resultIndex = currIndex;\n+â”Š   â”Š121â”Š        return true;\n+â”Š   â”Š122â”Š      }\n+â”Š   â”Š123â”Š    });\n+â”Š   â”Š124â”Š\n+â”Š   â”Š125â”Š    return keyframes[resultIndex - 1];\n+â”Š   â”Š126â”Š  }\n+â”Š   â”Š127â”Š\n+â”Š   â”Š128â”Š  // Get a recalculated property value relative to provided easing mode\n+â”Š   â”Š129â”Š  calculateRelativeValue(motion, key) {\n+â”Š   â”Š130â”Š    let a = motion.start[key];\n+â”Š   â”Š131â”Š    let b = motion.end[key];\n+â”Š   â”Š132â”Š    let r = motion.ratio;\n+â”Š   â”Š133â”Š    let easing = r > 0 ? motion.start.easing : motion.end.easing;\n+â”Š   â”Š134â”Š\n+â”Š   â”Š135â”Š    switch (easing) {\n+â”Š   â”Š136â”Š      case \"in\": r = Math.sin((r * Math.PI) / 2); break;\n+â”Š   â”Š137â”Š      case \"out\": r = Math.cos((r * Math.PI) / 2); break;\n+â”Š   â”Š138â”Š    }\n+â”Š   â”Š139â”Š\n+â”Š   â”Š140â”Š    return ((b - a) * r) + a;\n+â”Š   â”Š141â”Š  }\n+â”Š   â”Š142â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -10,6 +10,7 @@\n â”Š10â”Š10â”Š    <!-- Scripts -->\n â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n â”Š12â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/sprite.js\"></script>\n+â”Š  â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/animations/keyframe.js\"></script>\n â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/key_states.js\"></script>\n â”Š14â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/layer.js\"></script>\n â”Š15â”Š16â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/screen.js\"></script>\n```\n\n[}]: #\n\nWhen initializing a new instance of the key-frame animation, we should invoke it with the desired sprite, and an array of key-frames. What exactly does a single key-frame represents? The properties of the sprite at that specific time point. In addition, a key-frame can be set with an [easing mode](https://css-tricks.com/ease-out-in-ease-in-out/) of `in` and `out`. By default, the animation would be linear.\n\nBased on the `repitationMode` property, three things can happen to the animation once finished:\n\n- `none` - The animation will play once, and then stop. It will appear as a static sprite.\n- `cyclic` - The animation will repeat itself from the beginning, over and over again until stopped manually.\n- `full` - The animation will play itself backwards, and then forwards, backwards, forwards, and so on.\n\nThanks to the key-frame animation engine, we can apply it to the splash screen to show a beautifully animated logo rather than showing a static image. So in addition to the logo sprite, we will initialize a key-frame animation as well:\n\n[{]: <helper> (diffStep 3.9)\n\n#### [Step 3.9: Apply key-frame animation to splash screen](https://github.com/DAB0mB/radial-snake/commit/8ca47e5)\n\n##### Changed resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;splash&#x2F;index.js\n```diff\n@@ -1,9 +1,34 @@\n â”Š 1â”Š 1â”ŠGame.Screens.Splash = class Splash extends Engine.Screen {\n â”Š 2â”Š 2â”Š  initialize() {\n â”Š 3â”Š 3â”Š    // Create splash sprite and set its properties\n-â”Š 4â”Š  â”Š    this.splashSprite = new Engine.Sprite(this.assets.splashTexture);\n-â”Š 5â”Š  â”Š    this.splashSprite.align = \"center\";\n-â”Š 6â”Š  â”Š    this.splashSprite.x = this.width / 2;\n+â”Š  â”Š 4â”Š    let splashSprite = new Engine.Sprite(this.assets.splashTexture);\n+â”Š  â”Š 5â”Š    splashSprite.align = \"center\";\n+â”Š  â”Š 6â”Š    splashSprite.x = this.width / 2;\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Š    // Create splash sprite animation\n+â”Š  â”Š 9â”Š    this.splashAnim = new Engine.Animations.Keyframe(splashSprite, [\n+â”Š  â”Š10â”Š      {\n+â”Š  â”Š11â”Š        y: (this.height / 2) - 30,\n+â”Š  â”Š12â”Š        width: splashSprite.width / 4,\n+â”Š  â”Š13â”Š        height: splashSprite.height / 4,\n+â”Š  â”Š14â”Š        opacity: 0,\n+â”Š  â”Š15â”Š        easing: \"in\",\n+â”Š  â”Š16â”Š        frame: 0\n+â”Š  â”Š17â”Š      },\n+â”Š  â”Š18â”Š      {\n+â”Š  â”Š19â”Š        y: this.height / 2,\n+â”Š  â”Š20â”Š        width: (splashSprite.width / 3) + (splashSprite.width * 0.05),\n+â”Š  â”Š21â”Š        height: (splashSprite.height / 3) + (splashSprite.height * 0.05),\n+â”Š  â”Š22â”Š        opacity: 1,\n+â”Š  â”Š23â”Š        frame: 3000\n+â”Š  â”Š24â”Š      },\n+â”Š  â”Š25â”Š      {\n+â”Š  â”Š26â”Š        frame: 3500\n+â”Š  â”Š27â”Š      }\n+â”Š  â”Š28â”Š    ]);\n+â”Š  â”Š29â”Š\n+â”Š  â”Š30â”Š    // Start playing animation\n+â”Š  â”Š31â”Š    this.splashAnim.play();\n â”Š 7â”Š32â”Š  }\n â”Š 8â”Š33â”Š\n â”Š 9â”Š34â”Š  load(assetsLoader) {\n```\n```diff\n@@ -14,6 +39,10 @@\n â”Š14â”Š39â”Š  }\n â”Š15â”Š40â”Š\n â”Š16â”Š41â”Š  draw(context) {\n-â”Š17â”Š  â”Š    this.splashSprite.draw(context);\n+â”Š  â”Š42â”Š    this.splashAnim.draw(context);\n+â”Š  â”Š43â”Š  }\n+â”Š  â”Š44â”Š\n+â”Š  â”Š45â”Š  update(span) {\n+â”Š  â”Š46â”Š    this.splashAnim.update(span);\n â”Š18â”Š47â”Š  }\n â”Š19â”Š48â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nThe following key-frames illustrate the nodes of the animation we've just created:\n\n    width: 0\n    height: 0\n    opacity: 0\n\n![logo-empty](https://cloud.githubusercontent.com/assets/7648874/21583394/ee7a1dec-d065-11e6-80ce-fdd37c4b5dbb.png)\n\n    width: 225\n    height: 175\n    opacity: 1\n\n![logo-half](https://cloud.githubusercontent.com/assets/7648874/21583396/ee9bdf68-d065-11e6-95fb-4cf5ed58a9de.png)\n\n    width: 342\n    height: 266\n    opacity: 1\n\n![logo-full](https://cloud.githubusercontent.com/assets/7648874/21583395/ee7b3754-d065-11e6-9646-476d196a6412.png)"
          },
          {
            "manualTitle": "Step 4: Creating a main menu screen using a font engine",
            "stepRevision": "f88428bffcdf2bcf269b9cc15837cc40e0ed9caf",
            "manualView": "![snake-demo-menu-small](https://cloud.githubusercontent.com/assets/7648874/21074099/e72a81bc-bed6-11e6-98cb-329dc12a4b06.gif)\n\nIn this step we will be creating the main menu screen as shown above. The main menu screen is a simple screen which will show the logo of the game and an instruction text saying `Press a key to start`. We will be using a simple texture to show the game-logo and we will use the key-frame animation engine to show a flickering animation of the instruction text. The instruction text is the main part of this step, since it is made out of a font file (`.ttf`) and the text is auto-generated, a general solution which can serve us in many situations. We will start by implementing the main menu using static assets, which means that we will use a texture to show the instructions text, and later on we will implement the generic solution I've just mentioned. First, we will download the necessary assets:\n\n    resources/assets/textures$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/assets/textures/instructions.png\n    resources/assets/textures$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/assets/textures/logo.png\n\nAnd then we will implement the initial main menu screen:\n\n[{]: <helper> (diffStep 4.2)\n\n#### [Step 4.2: Create initial main menu screen](https://github.com/DAB0mB/radial-snake/commit/ed79de7)\n\n##### Added resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;menu&#x2F;index.js\n```diff\n@@ -0,0 +1,44 @@\n+â”Š  â”Š 1â”ŠGame.Screens.Menu = class Menu extends Engine.Screen {\n+â”Š  â”Š 2â”Š  initialize() {\n+â”Š  â”Š 3â”Š    // Initialize snake logo sprite\n+â”Š  â”Š 4â”Š    this.logoSprite = new Engine.Sprite(this.assets.logoTexture);\n+â”Š  â”Š 5â”Š    this.logoSprite.setPercentage(\"width\", this.width, 30, \"height\");\n+â”Š  â”Š 6â”Š\n+â”Š  â”Š 7â”Š    // Initialize instructions sprite\n+â”Š  â”Š 8â”Š    let instructionsSprite = new Engine.Sprite(this.assets.instructionsTexture);\n+â”Š  â”Š 9â”Š    instructionsSprite.align = \"center\";\n+â”Š  â”Š10â”Š    instructionsSprite.setPercentage(\"width\", this.width, 35, \"height\");\n+â”Š  â”Š11â”Š    instructionsSprite.x = this.width / 2;\n+â”Š  â”Š12â”Š    instructionsSprite.y = this.height / 2;\n+â”Š  â”Š13â”Š\n+â”Š  â”Š14â”Š    // Create flickering animation for instructions sprite\n+â”Š  â”Š15â”Š    this.instructionsAnim = new Engine.Animations.Keyframe(instructionsSprite, [\n+â”Š  â”Š16â”Š      {\n+â”Š  â”Š17â”Š        opacity: 1,\n+â”Š  â”Š18â”Š        frame: 0\n+â”Š  â”Š19â”Š      },\n+â”Š  â”Š20â”Š      {\n+â”Š  â”Š21â”Š        opacity: 0,\n+â”Š  â”Š22â”Š        frame: 2000\n+â”Š  â”Š23â”Š      }\n+â”Š  â”Š24â”Š    ]);\n+â”Š  â”Š25â”Š\n+â”Š  â”Š26â”Š    // Play it repeatedly, back and forth\n+â”Š  â”Š27â”Š    this.instructionsAnim.repetitionMode = \"full\";\n+â”Š  â”Š28â”Š    this.instructionsAnim.play();\n+â”Š  â”Š29â”Š  }\n+â”Š  â”Š30â”Š\n+â”Š  â”Š31â”Š  unload() {\n+â”Š  â”Š32â”Š    // Dispose the following assets to prevent memory leaks\n+â”Š  â”Š33â”Š    return [\"logoTexture\", \"instructionsTexture\"];\n+â”Š  â”Š34â”Š  }\n+â”Š  â”Š35â”Š\n+â”Š  â”Š36â”Š  draw(context) {\n+â”Š  â”Š37â”Š    this.logoSprite.draw(context);\n+â”Š  â”Š38â”Š    this.instructionsAnim.draw(context);\n+â”Š  â”Š39â”Š  }\n+â”Š  â”Š40â”Š\n+â”Š  â”Š41â”Š  update(span) {\n+â”Š  â”Š42â”Š    this.instructionsAnim.update(span);\n+â”Š  â”Š43â”Š  }\n+â”Š  â”Š44â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -16,6 +16,7 @@\n â”Š16â”Š16â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/screen.js\"></script>\n â”Š17â”Š17â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/assets_loader.js\"></script>\n â”Š18â”Š18â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n+â”Š  â”Š19â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/menu/index.js\"></script>\n â”Š19â”Š20â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/splash/index.js\"></script>\n â”Š20â”Š21â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n```\n\n[}]: #\n\nThis screen is dependent on several assets which we will load during \"splash screen time\", to save some loading time and for a smooth experience. The main menu screen will be shown automatically once the splash animation has been finished:\n\n[{]: <helper> (diffStep 4.3)\n\n#### [Step 4.3: Queue main menu screen](https://github.com/DAB0mB/radial-snake/commit/cd83a30)\n\n##### Changed resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;splash&#x2F;index.js\n```diff\n@@ -32,10 +32,21 @@\n â”Š32â”Š32â”Š  }\n â”Š33â”Š33â”Š\n â”Š34â”Š34â”Š  load(assetsLoader) {\n+â”Š  â”Š35â”Š    // Load assets\n+â”Š  â”Š36â”Š    let instructionsTexture = assetsLoader.texture(\"/textures/instrucitons\");\n+â”Š  â”Š37â”Š    let logoTexture = assetsLoader.texture(\"/textures/logo\");\n+â”Š  â”Š38â”Š    let splashTexture = assetsLoader.texture(\"/textures/splash\");\n+â”Š  â”Š39â”Š\n+â”Š  â”Š40â”Š    // These are global assets which will be shared among all screens until manually\n+â”Š  â”Š41â”Š    // disposed. We use the time gap created by the splash animation to load necessary\n+â”Š  â”Š42â”Š    // assets without wasting any time\n+â”Š  â”Š43â”Š    this.game.extendAssets({\n+â”Š  â”Š44â”Š      instructionsTexture,\n+â”Š  â”Š45â”Š      logoTexture\n+â”Š  â”Š46â”Š    });\n+â”Š  â”Š47â”Š\n â”Š35â”Š48â”Š    // These are local assets which will be disposed along with the screen\n-â”Š36â”Š  â”Š    return {\n-â”Š37â”Š  â”Š      splashTexture: assetsLoader.texture(\"/textures/splash\")\n-â”Š38â”Š  â”Š    };\n+â”Š  â”Š49â”Š    return { splashTexture };\n â”Š39â”Š50â”Š  }\n â”Š40â”Š51â”Š\n â”Š41â”Š52â”Š  draw(context) {\n```\n```diff\n@@ -43,6 +54,12 @@\n â”Š43â”Š54â”Š  }\n â”Š44â”Š55â”Š\n â”Š45â”Š56â”Š  update(span) {\n-â”Š46â”Š  â”Š    this.splashAnim.update(span);\n+â”Š  â”Š57â”Š    if (this.splashAnim.playing) {\n+â”Š  â”Š58â”Š      this.splashAnim.update(span);\n+â”Š  â”Š59â”Š    }\n+â”Š  â”Š60â”Š    // Once animation has stopped play switch to main menu\n+â”Š  â”Š61â”Š    else {\n+â”Š  â”Š62â”Š      this.game.changeScreen(Game.Screens.Menu);\n+â”Š  â”Š63â”Š    }\n â”Š47â”Š64â”Š  }\n â”Š48â”Š65â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nBy now if you launch the application you should see the main menu screen as described in the beginning. But event though it works, we're not yet finished. We still need to convert the instruction texture into an auto-generated font texture. Obviously, this requires us to download the desired `ttf` file:\n\n    resources/assets/fonts$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/assets/fonts/minecraftia.ttf\n\n> Any font file can be used here, but to save time and effort I already provided you with one\n\n`ttf` is the most common format, but since we're using JavaScript, it would make sense to convert it into a `json` file, and that's exactly what we're going to do. There's a very convenient software called [font-builder](https://github.com/andryblack/fontbuilder), and it can cut fonts, store them in `png` files, along with some user-specified meta-data stored in an `xml` file.\n\n![font-builder](https://camo.githubusercontent.com/b2c95cda825c783f5399d9197599848c33cdfcc8/687474703a2f2f7777772e67616d656465762e72752f66696c65732f696d616765732f73637265656e312e6a706567)\n\nGo over to this website: https://github.com/andryblack/fontbuilder.\nFetch a copy of the `font-builder` repo, and try to convert the `minecraftia.ttf` file into a `png` file. If you want to skip this step, although I wouldn't recommend it, you can download the following files which I already generated myself:\n\n    resources/assets/fonts$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/assets/fonts/minecraftia.png\n    resources/assets/fonts$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/assets/fonts/minecraftia.xml\n\nAs promised, we will be working with a `json` file, not a `ttf` file and not an `xml` file. For this task we will be implementing a font-parser module, which will simply take all the meta-data in the `xml` file and put it into a nice `json` schema:\n\n[{]: <helper> (diffStep 4.6)\n\n#### [Step 4.6: Create font parser so we can convert &#x27;xml&#x27; font format to &#x27;json&#x27;](https://github.com/DAB0mB/radial-snake/commit/66044e9)\n\n##### Added helpers&#x2F;font_parser.js\n```diff\n@@ -0,0 +1,102 @@\n+â”Š   â”Š  1â”Šconst _ = require(\"underscore\");\n+â”Š   â”Š  2â”Šconst Async = require(\"async\");\n+â”Š   â”Š  3â”Šconst Fs = require(\"fs\");\n+â”Š   â”Š  4â”Šconst Path = require(\"path\");\n+â”Š   â”Š  5â”Šconst { DOMParser } = require(\"xmldom\");\n+â”Š   â”Š  6â”Š\n+â”Š   â”Š  7â”Šif (module === require.main) {\n+â”Š   â”Š  8â”Š  let fonstDir = Path.resolve(__dirname, \"../resources/assets/fonts\");\n+â”Š   â”Š  9â”Š  xmlsToJsons(fonstDir, err => { if (err) throw err });\n+â”Š   â”Š 10â”Š}\n+â”Š   â”Š 11â”Š\n+â”Š   â”Š 12â”Š// Gets a dir path containing font xmls and converts them all to jsons\n+â”Š   â”Š 13â”Šfunction xmlsToJsons(path, callback = _.noop) {\n+â”Š   â”Š 14â”Š  Fs.readdir(path, (err, files) => {\n+â”Š   â”Š 15â”Š    if (err) return callback(err);\n+â”Š   â”Š 16â”Š\n+â”Š   â”Š 17â”Š    // Remove all extensions\n+â”Š   â”Š 18â”Š    fileNames = _.uniq(files.map(file => file.split(\".\")[0]));\n+â”Š   â”Š 19â”Š\n+â”Š   â”Š 20â”Š    // Convert each xml individually\n+â”Š   â”Š 21â”Š    Async.each(fileNames, (fileName, next) => {\n+â”Š   â”Š 22â”Š      xmlToJson(`${path}/${fileName}`, next);\n+â”Š   â”Š 23â”Š    },\n+â”Š   â”Š 24â”Š    (err) => {\n+â”Š   â”Š 25â”Š      if (!err) console.log(\n+â”Š   â”Š 26â”Š        'All fonts have been successfully parsed!'\n+â”Š   â”Š 27â”Š      );\n+â”Š   â”Š 28â”Š\n+â”Š   â”Š 29â”Š      callback(err);\n+â”Š   â”Š 30â”Š    });\n+â”Š   â”Š 31â”Š  });\n+â”Š   â”Š 32â”Š}\n+â”Š   â”Š 33â”Š\n+â”Š   â”Š 34â”Š// Gets a font xml and converts it to json\n+â”Š   â”Š 35â”Šfunction xmlToJson(path, callback = _.noop) {\n+â”Š   â”Š 36â”Š  Async.waterfall([\n+â”Š   â”Š 37â”Š    (next) => {\n+â”Š   â”Š 38â”Š      Fs.readFile(`${path}.xml`, function(err, xmlBuffer) {\n+â”Š   â”Š 39â”Š        if (err) return next(err);\n+â”Š   â”Š 40â”Š\n+â”Š   â”Š 41â”Š        let json = {\n+â”Š   â”Š 42â”Š          chars: {}\n+â”Š   â”Š 43â”Š        };\n+â”Š   â”Š 44â”Š\n+â”Š   â”Š 45â”Š        let xml = xmlBuffer.toString();\n+â”Š   â”Š 46â”Š        let doc = new DOMParser().parseFromString(xml);\n+â”Š   â”Š 47â”Š        let fontDoc = doc.getElementsByTagName(\"Font\")[0];\n+â”Š   â”Š 48â”Š        let charsDoc = fontDoc.getElementsByTagName(\"Char\");\n+â”Š   â”Š 49â”Š\n+â”Š   â”Š 50â”Š        // Compose meta-data about font like size and family\n+â”Š   â”Š 51â”Š        _.each(fontDoc.attributes, (attr) => {\n+â”Š   â”Š 52â”Š          json[attr.name] = parseInt(attr.value) || attr.value;\n+â”Š   â”Š 53â”Š        });\n+â”Š   â”Š 54â”Š\n+â”Š   â”Š 55â”Š        // Compose data about each character in font\n+â”Š   â”Š 56â”Š        _.each(charsDoc, (charDoc) => {\n+â”Š   â”Š 57â”Š          let charCode = charDoc.getAttribute(\"code\");\n+â”Š   â”Š 58â”Š\n+â”Š   â”Š 59â”Š          let char = json.chars[charCode] = {\n+â”Š   â”Š 60â”Š            rect: rect = {},\n+â”Š   â”Š 61â”Š            offset: offset = {},\n+â”Š   â”Š 62â”Š            width: parseInt(charDoc.getAttribute(\"width\"))\n+â”Š   â”Š 63â”Š          };\n+â”Š   â”Š 64â”Š\n+â”Š   â”Š 65â”Š          [\n+â”Š   â”Š 66â”Š            rect.x,\n+â”Š   â”Š 67â”Š            rect.y,\n+â”Š   â”Š 68â”Š            rect.width,\n+â”Š   â”Š 69â”Š            rect.height\n+â”Š   â”Š 70â”Š          ] = extractIntegers(charDoc.getAttribute(\"rect\"));\n+â”Š   â”Š 71â”Š\n+â”Š   â”Š 72â”Š          [offset.x, offset.y] = extractIntegers(charDoc.getAttribute(\"offset\"));\n+â”Š   â”Š 73â”Š        });\n+â”Š   â”Š 74â”Š\n+â”Š   â”Š 75â”Š        next(null, JSON.stringify(json, null, 2));\n+â”Š   â”Š 76â”Š      });\n+â”Š   â”Š 77â”Š    },\n+â”Š   â”Š 78â”Š    (json, next) => {\n+â”Š   â”Š 79â”Š      // Once finished, write json into file\n+â”Š   â”Š 80â”Š      Fs.writeFile(path + \".json\", json, (err) => {\n+â”Š   â”Š 81â”Š        next(err);\n+â”Š   â”Š 82â”Š      });\n+â”Š   â”Š 83â”Š    }\n+â”Š   â”Š 84â”Š  ], (err) => {\n+â”Š   â”Š 85â”Š    if (!err) console.log(\n+â”Š   â”Š 86â”Š      `Font ${path} has been successfully parsed...`\n+â”Š   â”Š 87â”Š    );\n+â”Š   â”Š 88â”Š\n+â”Š   â”Š 89â”Š    callback(err);\n+â”Š   â”Š 90â”Š  });\n+â”Š   â”Š 91â”Š};\n+â”Š   â”Š 92â”Š\n+â”Š   â”Š 93â”Š// Converts an string of numbers to array of numbers\n+â”Š   â”Š 94â”Š// e.g. extractIntegers(\"1 2 3\") -> [1, 2, 3]\n+â”Š   â”Š 95â”Šfunction extractIntegers(srcstr) {\n+â”Š   â”Š 96â”Š  return srcstr.split(\" \").map((substr) => parseInt(substr));\n+â”Š   â”Š 97â”Š}\n+â”Š   â”Š 98â”Š\n+â”Š   â”Š 99â”Šmodule.exports = {\n+â”Š   â”Š100â”Š  xmlToJson,\n+â”Š   â”Š101â”Š  xmlsToJsons\n+â”Š   â”Š102â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nThis script will take everything that's in the `fonts` dir and parser it as mentioned above. Before we can user this script we will need to install some NPM dependencies like so:\n\n    $ npm install --save underscore\n    $ npm install --save xmldom\n\nAnd instead of running the parser manually over and over again whenever we wanna use it, we will use the following `NPM` script instead:\n\n[{]: <helper> (diffStep 4.8)\n\n#### [Step 4.8: Add font parsing npm scripts](https://github.com/DAB0mB/radial-snake/commit/7a1cf81)\n\n##### Changed package.json\n```diff\n@@ -7,7 +7,8 @@\n â”Š 7â”Š 7â”Š  },\n â”Š 8â”Š 8â”Š  \"private\": true,\n â”Š 9â”Š 9â”Š  \"scripts\": {\n-â”Š10â”Š  â”Š    \"serve\": \"nodemon server.js\"\n+â”Š  â”Š10â”Š    \"serve\": \"npm run parse:fonts && nodemon server.js\",\n+â”Š  â”Š11â”Š    \"build:fonts\": \"node helpers/font_parser.js\"\n â”Š11â”Š12â”Š  },\n â”Š12â”Š13â”Š  \"dependencies\": {\n â”Š13â”Š14â”Š    \"async\": \"^2.1.4\",\n```\n\n[}]: #\n\nWe don't want the generated fonts to be included by `git` since they are going to automatically regenerate themselves, therefore we gonna add the following ignore rule:\n\n[{]: <helper> (diffStep 4.9)\n\n#### [Step 4.9: Add rule to to git-ignore parsed fonts](https://github.com/DAB0mB/radial-snake/commit/bbf7647)\n\n##### Changed .gitignore\n```diff\n@@ -1,2 +1,3 @@\n â”Š1â”Š1â”Šnode_modules\n-â”Š2â”Š â”Šnpm-debug.logðŸš«â†µ\n+â”Š â”Š2â”Šnpm-debug.log\n+â”Š â”Š3â”Šresources/assets/fonts/*.jsonðŸš«â†µ\n```\n\n[}]: #\n\nNow we will build our `minecraftia` font by simply running:\n\n    $ npm run build:fonts\n\nAnd voila! We have a freshly created `json` file which we can work with. You can also get it from here:\n\n    resources/assets/fonts$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/assets/fonts/minecraftia.json\n\nNow that we have our assets finally ready we can go ahead and focus on extending the engine which powers up our game. We need some sort of a generic font-engine which will know how to load a font file and create a text-sprite out of it. First we will implement a class called `Restorable`, which shares the same restore API as the CanvasRenderingContext2D and will give us the ability to save and restore the font's state (More information can be found [here](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/restore)):\n\n[{]: <helper> (diffStep 4.11)\n\n#### [Step 4.11: Add &#x27;Restorable&#x27; class](https://github.com/DAB0mB/radial-snake/commit/8239c01)\n\n##### Added resources&#x2F;scripts&#x2F;engine&#x2F;restorable.js\n```diff\n@@ -0,0 +1,21 @@\n+â”Š  â”Š 1â”ŠEngine.Restorable = class Restorable {\n+â”Š  â”Š 2â”Š  // Acts the same as canvas's save() and restore() API.\n+â”Š  â”Š 3â”Š  // 'restorable' props are defined in the constructor\n+â”Š  â”Š 4â”Š  constructor(...restorableProps) {\n+â”Š  â”Š 5â”Š    this._restorableProps = restorableProps;\n+â”Š  â”Š 6â”Š    this._restorableStates = [];\n+â”Š  â”Š 7â”Š  }\n+â”Š  â”Š 8â”Š\n+â”Š  â”Š 9â”Š  // Save current state in the stack\n+â”Š  â”Š10â”Š  save() {\n+â”Š  â”Š11â”Š    this._restorableStates.push(this._restorableProps.reduce((state, prop) => {\n+â”Š  â”Š12â”Š      state[prop] = this[prop];\n+â”Š  â”Š13â”Š      return state;\n+â”Š  â”Š14â”Š    }, {}));\n+â”Š  â”Š15â”Š  }\n+â”Š  â”Š16â”Š\n+â”Š  â”Š17â”Š  // Pop most recent state and apply it\n+â”Š  â”Š18â”Š  restore() {\n+â”Š  â”Š19â”Š    _.extend(this, this._restorableStates.pop());\n+â”Š  â”Š20â”Š  }\n+â”Š  â”Š21â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -9,6 +9,7 @@\n â”Š 9â”Š 9â”Š\n â”Š10â”Š10â”Š    <!-- Scripts -->\n â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n+â”Š  â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/restorable.js\"></script>\n â”Š12â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/sprite.js\"></script>\n â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/animations/keyframe.js\"></script>\n â”Š14â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/key_states.js\"></script>\n```\n\n[}]: #\n\nAnd now we can go ahead and implement the font class itself:\n\n[{]: <helper> (diffStep 4.12)\n\n#### [Step 4.12: Create font engine](https://github.com/DAB0mB/radial-snake/commit/7a1f2c7)\n\n##### Added resources&#x2F;scripts&#x2F;engine&#x2F;font.js\n```diff\n@@ -0,0 +1,133 @@\n+â”Š   â”Š  1â”ŠEngine.Font = class Font extends Engine.Restorable {\n+â”Š   â”Š  2â”Š  // The src property acts just line native image's src property.\n+â”Š   â”Š  3â”Š  // Once finished loading, the onload() callback will be invoked\n+â”Š   â”Š  4â”Š  get src() {\n+â”Š   â”Š  5â”Š    return this._src;\n+â”Š   â”Š  6â”Š  }\n+â”Š   â”Š  7â”Š\n+â”Š   â”Š  8â”Š  set src(src) {\n+â”Š   â”Š  9â”Š    this._src = src;\n+â”Š   â”Š 10â”Š\n+â”Š   â”Š 11â”Š    // The font is actually an image, therefore we have 2 onload callbacks.\n+â”Š   â”Š 12â”Š    // The first one is the native one which will always be run,\n+â”Š   â”Š 13â”Š    // and the second one is a user defined one\n+â”Š   â”Š 14â”Š    if (this.onload) var done = _.after(2, this.onload);\n+â”Š   â”Š 15â”Š\n+â”Š   â”Š 16â”Š    this.atlas = new Image();\n+â”Š   â”Š 17â”Š    this.atlas.onload = done;\n+â”Š   â”Š 18â”Š    this.atlas.src = `${src}.png`;\n+â”Š   â”Š 19â”Š\n+â”Š   â”Š 20â”Š    // Get json based on the given src property\n+â”Š   â”Š 21â”Š    $.getJSON(`${src}.json`, data => {\n+â”Š   â”Š 22â”Š      this.data = data;\n+â”Š   â”Š 23â”Š      if (done) done();\n+â”Š   â”Š 24â”Š    });\n+â”Š   â”Š 25â”Š\n+â”Š   â”Š 26â”Š    return this._src;\n+â”Š   â”Š 27â”Š  }\n+â”Š   â”Š 28â”Š\n+â”Š   â”Š 29â”Š  constructor() {\n+â”Š   â”Š 30â”Š    // The color property is the only restorable property\n+â”Š   â”Š 31â”Š    super(\"color\");\n+â”Š   â”Š 32â”Š    this.charSpritesCache = {};\n+â”Š   â”Š 33â”Š  }\n+â”Š   â”Š 34â”Š\n+â”Š   â”Š 35â”Š  // Creates a texture out of the font with the given text\n+â”Š   â”Š 36â”Š  createTexture(text, options = {}) {\n+â”Š   â”Š 37â”Š    let { noOffsets, noSpaces } = options;\n+â”Š   â”Š 38â”Š    let canvas = document.createElement(\"canvas\");\n+â”Š   â”Š 39â”Š    let context = canvas.getContext(\"2d\");\n+â”Š   â”Š 40â”Š    let height = canvas.height = this.data.height;\n+â”Š   â”Š 41â”Š\n+â”Š   â”Š 42â”Š    // Calculates the width of the canvas based on the text and the font\n+â”Š   â”Š 43â”Š    let width = canvas.width = _.reduce(text, (width, c) => {\n+â”Š   â”Š 44â”Š      // No-space option means that the characters will be\n+â”Š   â”Š 45â”Š      // drawn with no any space between them\n+â”Š   â”Š 46â”Š      if (noSpaces) {\n+â”Š   â”Š 47â”Š        return width + this.getCharSprite(c).width;\n+â”Š   â”Š 48â”Š      }\n+â”Š   â”Š 49â”Š\n+â”Š   â”Š 50â”Š      return width + this.data.chars[c].width;\n+â”Š   â”Š 51â”Š    }, 0);\n+â”Š   â”Š 52â”Š\n+â”Š   â”Š 53â”Š    // A custom size can be specified for a font as well\n+â”Š   â”Š 54â”Š    if (this.size) {\n+â”Š   â”Š 55â”Š      let ratio = this.size / this.data.size;\n+â”Š   â”Š 56â”Š      canvas.height *= ratio;\n+â”Š   â”Š 57â”Š      canvas.width *= ratio;\n+â”Š   â”Š 58â”Š      context.scale(ratio, ratio);\n+â”Š   â”Š 59â”Š    }\n+â”Š   â”Š 60â”Š\n+â”Š   â”Š 61â”Š    // No we are going to draw each char on the canvas individually,\n+â”Š   â”Š 62â”Š    // naturally, there should be an offset after we draw each character.\n+â”Š   â”Š 63â”Š    // This variable will be used to calculate the offset\n+â”Š   â”Š 64â”Š    let offset = 0;\n+â”Š   â”Š 65â”Š\n+â”Š   â”Š 66â”Š    // Get for each char\n+â”Š   â”Š 67â”Š    _.map(text, (char) => {\n+â”Š   â”Š 68â”Š      return this.getCharSprite(char);\n+â”Š   â”Š 69â”Š    })\n+â”Š   â”Š 70â”Š    // Start drawing each char on the canvas\n+â”Š   â”Š 71â”Š    .forEach((charSprite, index) => {\n+â”Š   â”Š 72â”Š      let charData = this.data.chars[text.charAt(index)];\n+â”Š   â”Š 73â”Š\n+â”Š   â”Š 74â”Š      // Each char in the font xml has a native offset in addition to its rectangle.\n+â”Š   â”Š 75â”Š      // This option will disable the calculation of the native offset\n+â”Š   â”Š 76â”Š      if (noOffsets) {\n+â”Š   â”Š 77â”Š        charSprite.draw(context, offset);\n+â”Š   â”Š 78â”Š      }\n+â”Š   â”Š 79â”Š      else {\n+â”Š   â”Š 80â”Š        charSprite.draw(context, offset + charData.offset.x, charData.offset.y);\n+â”Š   â”Š 81â”Š      }\n+â”Š   â”Š 82â”Š\n+â”Š   â”Š 83â”Š      if (noSpaces) {\n+â”Š   â”Š 84â”Š        offset += charSprite.width;\n+â”Š   â”Š 85â”Š      }\n+â”Š   â”Š 86â”Š      else {\n+â”Š   â”Š 87â”Š        offset += charData.width;\n+â”Š   â”Š 88â”Š      }\n+â”Š   â”Š 89â”Š\n+â”Š   â”Š 90â”Š      // A color for the font can be specified as well\n+â”Š   â”Š 91â”Š      if (this.color) {\n+â”Š   â”Š 92â”Š        let overlayCanvas = document.createElement(\"canvas\");\n+â”Š   â”Š 93â”Š        let overlayContext = overlayCanvas.getContext(\"2d\");\n+â”Š   â”Š 94â”Š        overlayCanvas.width = width;\n+â”Š   â”Š 95â”Š        overlayCanvas.height = height;\n+â”Š   â”Š 96â”Š        overlayContext.beginPath();\n+â”Š   â”Š 97â”Š        overlayContext.rect(0, 0, width, height);\n+â”Š   â”Š 98â”Š        overlayContext.fillStyle = this.color;\n+â”Š   â”Š 99â”Š        overlayContext.fill();\n+â”Š   â”Š100â”Š\n+â”Š   â”Š101â”Š        context.save();\n+â”Š   â”Š102â”Š        context.globalCompositeOperation = \"source-in\";\n+â”Š   â”Š103â”Š        context.drawImage(overlayCanvas, 0, 0);\n+â”Š   â”Š104â”Š        context.restore();\n+â”Š   â”Š105â”Š      }\n+â”Š   â”Š106â”Š    });\n+â”Š   â”Š107â”Š\n+â”Š   â”Š108â”Š    // The canvas will be treated like an image\n+â”Š   â”Š109â”Š    return canvas;\n+â”Š   â”Š110â”Š  }\n+â”Š   â”Š111â”Š\n+â”Š   â”Š112â”Š  // Gets a sprite of the given char, using the current font\n+â”Š   â”Š113â”Š  getCharSprite(char) {\n+â”Š   â”Š114â”Š    // If char is already stored in cache, abort calculation and return it\n+â”Š   â”Š115â”Š    if (this.charSpritesCache[char]) return this.charSpritesCache[char];\n+â”Š   â”Š116â”Š\n+â”Š   â”Š117â”Š    // This data is fetched by the given json\n+â”Š   â”Š118â”Š    let { x, y, width, height } = this.data.chars[char].rect;\n+â”Š   â”Š119â”Š    // Creating a canvas which we will use to draw on,\n+â”Š   â”Š120â”Š    // but it is used exactly like an image afterwards\n+â”Š   â”Š121â”Š    let canvas = document.createElement(\"canvas\");\n+â”Š   â”Š122â”Š    let context = canvas.getContext(\"2d\");\n+â”Š   â”Š123â”Š\n+â”Š   â”Š124â”Š    // The canvas will have the same dimensions as the font\n+â”Š   â”Š125â”Š    canvas.width = width;\n+â”Š   â”Š126â”Š    canvas.height = height;\n+â”Š   â”Š127â”Š    // Draw a cropped image from the atlas, this image contains the char font\n+â”Š   â”Š128â”Š    context.drawImage(this.atlas, x, y, width, height, 0, 0, width, height);\n+â”Š   â”Š129â”Š\n+â”Š   â”Š130â”Š    // Store in cache and return it\n+â”Š   â”Š131â”Š    return this.charSpritesCache[char] = new Engine.Sprite(canvas);\n+â”Š   â”Š132â”Š  }\n+â”Š   â”Š133â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -10,6 +10,7 @@\n â”Š10â”Š10â”Š    <!-- Scripts -->\n â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n â”Š12â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/restorable.js\"></script>\n+â”Š  â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/font.js\"></script>\n â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/sprite.js\"></script>\n â”Š14â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/animations/keyframe.js\"></script>\n â”Š15â”Š16â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/key_states.js\"></script>\n```\n\n[}]: #\n\nThe font API shares a similar API as [HTMLImageElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/Image), once we set the `src` property the font will start loading itself, and the `onload` user-defined callback should be called once finished. Another neat feature would be the `createTexture` method, which takes a string as its first argument, representing the text that we would like to generate, and returns an instance of the `Sprite` class.\n\nWe will also be adding the option to load some font assets in our asset-loader:\n\n[{]: <helper> (diffStep 4.13)\n\n#### [Step 4.13: Add a font loading option to &#x27;AssetLoader&#x27;](https://github.com/DAB0mB/radial-snake/commit/a9d73cc)\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;assets_loader.js\n```diff\n@@ -10,4 +10,12 @@\n â”Š10â”Š10â”Š    image.src = `${path}.png`;\n â”Š11â”Š11â”Š    return image;\n â”Š12â”Š12â”Š  }\n+â”Š  â”Š13â”Š\n+â”Š  â”Š14â”Š  // Load font\n+â”Š  â”Š15â”Š  font(path) {\n+â”Š  â”Š16â”Š    let font = new Engine.Font();\n+â”Š  â”Š17â”Š    font.onload = this.next();\n+â”Š  â”Š18â”Š    font.src = path;\n+â”Š  â”Š19â”Š    return font;\n+â”Š  â”Š20â”Š  }\n â”Š13â”Š21â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nAnd replace the instructions texture loading with a `minecraftia` font loading in the initial splash screen:\n\n[{]: <helper> (diffStep 4.14)\n\n#### [Step 4.14: Load &#x27;minecraftia&#x27; font in splash screen](https://github.com/DAB0mB/radial-snake/commit/231a68f)\n\n##### Changed resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;splash&#x2F;index.js\n```diff\n@@ -33,7 +33,7 @@\n â”Š33â”Š33â”Š\n â”Š34â”Š34â”Š  load(assetsLoader) {\n â”Š35â”Š35â”Š    // Load assets\n-â”Š36â”Š  â”Š    let instructionsTexture = assetsLoader.texture(\"/textures/instrucitons\");\n+â”Š  â”Š36â”Š    let minecraftiaFont = assetsLoader.font(\"/fonts/minecraftia\");\n â”Š37â”Š37â”Š    let logoTexture = assetsLoader.texture(\"/textures/logo\");\n â”Š38â”Š38â”Š    let splashTexture = assetsLoader.texture(\"/textures/splash\");\n â”Š39â”Š39â”Š\n```\n```diff\n@@ -41,7 +41,7 @@\n â”Š41â”Š41â”Š    // disposed. We use the time gap created by the splash animation to load necessary\n â”Š42â”Š42â”Š    // assets without wasting any time\n â”Š43â”Š43â”Š    this.game.extendAssets({\n-â”Š44â”Š  â”Š      instructionsTexture,\n+â”Š  â”Š44â”Š      minecraftiaFont,\n â”Š45â”Š45â”Š      logoTexture\n â”Š46â”Š46â”Š    });\n```\n\n[}]: #\n\nNow it can use us in the main menu screen where we will create a text-sprite saying `Press a key to start`, just like the instruction sprite we're about to replace:\n\n[{]: <helper> (diffStep 4.15)\n\n#### [Step 4.15: Replace texture usage with font usage in main menu screen](https://github.com/DAB0mB/radial-snake/commit/a769b81)\n\n##### Changed resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;menu&#x2F;index.js\n```diff\n@@ -5,7 +5,8 @@\n â”Š 5â”Š 5â”Š    this.logoSprite.setPercentage(\"width\", this.width, 30, \"height\");\n â”Š 6â”Š 6â”Š\n â”Š 7â”Š 7â”Š    // Initialize instructions sprite\n-â”Š 8â”Š  â”Š    let instructionsSprite = new Engine.Sprite(this.assets.instructionsTexture);\n+â”Š  â”Š 8â”Š    let instructionsTexture = this.assets.minecraftiaFont.createTexture(\"Press a key to start\");\n+â”Š  â”Š 9â”Š    let instructionsSprite = new Engine.Sprite(instructionsTexture);\n â”Š 9â”Š10â”Š    instructionsSprite.align = \"center\";\n â”Š10â”Š11â”Š    instructionsSprite.setPercentage(\"width\", this.width, 35, \"height\");\n â”Š11â”Š12â”Š    instructionsSprite.x = this.width / 2;\n```\n```diff\n@@ -30,7 +31,7 @@\n â”Š30â”Š31â”Š\n â”Š31â”Š32â”Š  unload() {\n â”Š32â”Š33â”Š    // Dispose the following assets to prevent memory leaks\n-â”Š33â”Š  â”Š    return [\"logoTexture\", \"instructionsTexture\"];\n+â”Š  â”Š34â”Š    return \"logoTexture\";\n â”Š34â”Š35â”Š  }\n â”Š35â”Š36â”Š\n â”Š36â”Š37â”Š  draw(context) {\n```\n```diff\n@@ -41,4 +42,8 @@\n â”Š41â”Š42â”Š  update(span) {\n â”Š42â”Š43â”Š    this.instructionsAnim.update(span);\n â”Š43â”Š44â”Š  }\n+â”Š  â”Š45â”Š\n+â”Š  â”Š46â”Š  update(span) {\n+â”Š  â”Š47â”Š    this.instructionsAnim.update(span);\n+â”Š  â”Š48â”Š  }\n â”Š44â”Š49â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nIt shouldn't look any different from the beginning of the step where we manually drew the instruction texture, but in the next steps we will be using the font-engine a lot, and you will be thankful for what we've just did."
          },
          {
            "manualTitle": "Step 5: Creating a snake and related geometry shapes",
            "stepRevision": "ad178e03e276b088c96d6f67889db379ad201e3e",
            "manualView": "![snake-illustrate](https://cloud.githubusercontent.com/assets/7648874/21074115/46ef4466-bed7-11e6-9d5d-12fa6d43147b.gif)\n\nIn this step we will be creating all the necessary geometry shapes to form a snake; we're basically implementing the right infrastructure so in the next step we will be able to implement the game screen with ease. What exactly do I mean by \"geometry shapes\"? Well, our snake will be made out of circles, and lines. If we don't press any buttons at all, the snake should move forward at a straight line, and once we press on one of the arrow keys, the snake should move in a circular motion. Not only we want to draw the screen on the canvas, we also want to be able to detect collision with other snakes, since this is a \"Tron\" style game where we gonna fight against an opponent.\n\nKeep in mind that a computer's precision is limited due its [binary representation in memory](https://en.wikipedia.org/wiki/Memory_cell_(binary)). We need to take into consideration that there might be a significant deviation when detecting collisions and intersections between geometry shapes, especially when elapsed time is not always guaranteed to stay precise. To handle these deviation issues, we're gonna create some utility functions and place then in a new module called `Utils`:\n\n[{]: <helper> (diffStep 5.1)\n\n#### [Step 5.1: Create utilities module](https://github.com/DAB0mB/radial-snake/commit/58ae99a)\n\n##### Added resources&#x2F;scripts&#x2F;utils.js\n```diff\n@@ -0,0 +1,68 @@\n+â”Š  â”Š 1â”Š// A wrapper function for our utilities which will enable chaining\n+â”Š  â”Š 2â”Š// e.g. Utils().mod().trim().isBetween()...\n+â”Š  â”Š 3â”ŠUtils = function Utils(context) {\n+â”Š  â”Š 4â”Š  const chain = {};\n+â”Š  â”Š 5â”Š\n+â”Š  â”Š 6â”Š  Object.keys(Utils).forEach((utilName) => {\n+â”Š  â”Š 7â”Š    chain[utilName] = (...args) => {\n+â”Š  â”Š 8â”Š      const result = Utils[utilName](context, ...args);\n+â”Š  â”Š 9â”Š      return Utils(result);\n+â”Š  â”Š10â”Š    };\n+â”Š  â”Š11â”Š  });\n+â”Š  â”Š12â”Š\n+â”Š  â”Š13â”Š  // Returns the result of the chaining\n+â”Š  â”Š14â”Š  chain.value = () => context;\n+â”Š  â”Š15â”Š\n+â”Š  â”Š16â”Š  return chain;\n+â”Š  â”Š17â”Š};\n+â”Š  â”Š18â”Š\n+â”Š  â”Š19â”Š// Fixed modulo method which can calculate modulo of negative numbers properly\n+â”Š  â”Š20â”Š// e.g. (-803).mod(800) returns 797\n+â”Š  â”Š21â”ŠUtils.mod = function (context, num) {\n+â”Š  â”Š22â”Š  return ((context % num) + num) % num;\n+â”Š  â”Š23â”Š};\n+â”Š  â”Š24â”Š\n+â”Š  â”Š25â”Š// Trims number and leaves the number of decimals specified.\n+â”Š  â”Š26â”Š// The \"mode\" argument specifies which math function should be invoked\n+â”Š  â”Š27â”Š// right after the number has been trimmed.\n+â”Š  â”Š28â”Š// e.g. 12.12345.trim(3, \"ceil\") returns 12.124\n+â”Š  â”Š29â”ŠUtils.trim = function (context, decimals, mode = \"round\") {\n+â”Š  â”Š30â”Š  return Math[mode](context * Math.pow(10, decimals)) / Math.pow(10, decimals);\n+â”Š  â”Š31â”Š};\n+â”Š  â”Š32â”Š\n+â”Š  â”Š33â”Š// Tells if number is in specified range based on given precision.\n+â”Š  â”Š34â”Š// See the \"compare\" method for more information about precision\n+â”Š  â”Š35â”ŠUtils.isBetween = function (context, num1, num2, precision) {\n+â”Š  â”Š36â”Š  return Utils.compare(context, Math.min(num1, num2), \">=\", precision) &&\n+â”Š  â”Š37â”Š         Utils.compare(context, Math.max(num1, num2), \"<=\", precision);\n+â”Š  â”Š38â”Š};\n+â”Š  â”Š39â”Š\n+â”Š  â”Š40â”Š// Initiates comparison operator between context number and a given number, only here\n+â”Š  â”Š41â”Š// a precision can be specified\n+â”Š  â”Š42â”ŠUtils.compare = function (context, num, method, precision = method) {\n+â”Š  â”Š43â”Š  switch (precision) {\n+â”Š  â”Š44â”Š    // Fixed precision, \"almost equal\" with a deviation of Îµ\n+â”Š  â”Š45â”Š    case \"f\":\n+â”Š  â”Š46â”Š      switch (method) {\n+â”Š  â”Š47â”Š        case \"<\": case \"<=\": return context <= num + Number.EPSILON;\n+â”Š  â”Š48â”Š        case \">\": case \">=\": return context >= num - Number.EPSILON;\n+â”Š  â”Š49â”Š        default: return Math.abs(context - num) <= Number.EPSILON;\n+â”Š  â”Š50â”Š      }\n+â”Š  â”Š51â”Š    // Pixel precision, round comparison\n+â”Š  â”Š52â”Š    case \"px\":\n+â”Š  â”Š53â”Š      switch (method) {\n+â”Š  â”Š54â”Š        case \"<\": case \"<=\": return Math.round(context) <= Math.round(num);\n+â”Š  â”Š55â”Š        case \">\": case \">=\": return Math.round(context) >= Math.round(num);\n+â”Š  â”Š56â”Š        default: return Math.round(context) == Math.round(num);\n+â”Š  â”Š57â”Š      }\n+â”Š  â”Š58â”Š    // Exact precision\n+â”Š  â”Š59â”Š    default:\n+â”Š  â”Š60â”Š      switch (method) {\n+â”Š  â”Š61â”Š        case \"<\": return context < num;\n+â”Š  â”Š62â”Š        case \"<=\": return context <= num;\n+â”Š  â”Š63â”Š        case \">\": return context > num;\n+â”Š  â”Š64â”Š        case \">=\": return context >= num;\n+â”Š  â”Š65â”Š        default: return context === num;\n+â”Š  â”Š66â”Š      }\n+â”Š  â”Š67â”Š  }\n+â”Š  â”Š68â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -8,6 +8,7 @@\n â”Š 8â”Š 8â”Š    <script type=\"text/javascript\" src=\"/libs/underscore.js\"></script>\n â”Š 9â”Š 9â”Š\n â”Š10â”Š10â”Š    <!-- Scripts -->\n+â”Š  â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/utils.js\"></script>\n â”Š11â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n â”Š12â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/restorable.js\"></script>\n â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/font.js\"></script>\n```\n\n[}]: #\n\nNow we would like to start implementing the first class representation for a line, and for that we're requires to add a new module called `Geometry` to the `Engine` namespace:\n\n[{]: <helper> (diffStep 5.2)\n\n#### [Step 5.2: Add &#x27;Shapes&#x27; module to &#x27;Engine&#x27; namespace](https://github.com/DAB0mB/radial-snake/commit/4ed2788)\n\n##### Changed resources&#x2F;scripts&#x2F;namespaces.js\n```diff\n@@ -3,5 +3,6 @@\n â”Š3â”Š3â”Š};\n â”Š4â”Š4â”Š\n â”Š5â”Š5â”ŠEngine = {\n-â”Š6â”Š â”Š  Animations: {}\n+â”Š â”Š6â”Š  Animations: {},\n+â”Š â”Š7â”Š  Geometry: {}\n â”Š7â”Š8â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nAnd now that we have this module available to use, we can go ahead and implement our first geometry shape class - `Line`:\n\n[{]: <helper> (diffStep 5.3)\n\n#### [Step 5.3: Create &#x27;Line&#x27; class](https://github.com/DAB0mB/radial-snake/commit/fb38ab5)\n\n##### Added resources&#x2F;scripts&#x2F;engine&#x2F;geometry&#x2F;line.js\n```diff\n@@ -0,0 +1,65 @@\n+â”Š  â”Š 1â”ŠEngine.Geometry.Line = class Line {\n+â”Š  â”Š 2â”Š  // x1 - The first point's x value\n+â”Š  â”Š 3â”Š  // y1 - The first point's y value\n+â”Š  â”Š 4â”Š  // x1 - The second point's x value\n+â”Š  â”Š 5â”Š  // y2 - The second point's y value\n+â”Š  â”Š 6â”Š  constructor(x1, y1, x2, y2) {\n+â”Š  â”Š 7â”Š    this.x1 = Utils.trim(x1, 9);\n+â”Š  â”Š 8â”Š    this.y1 = Utils.trim(y1, 9);\n+â”Š  â”Š 9â”Š    this.x2 = Utils.trim(x2, 9);\n+â”Š  â”Š10â”Š    this.y2 = Utils.trim(y2, 9);\n+â”Š  â”Š11â”Š  }\n+â”Š  â”Š12â”Š\n+â”Š  â”Š13â”Š  // Draws the line on the given context\n+â”Š  â”Š14â”Š  draw(context) {\n+â”Š  â”Š15â”Š    context.moveTo(this.x1, this.y1);\n+â”Š  â”Š16â”Š    context.lineTo(this.x2, this.y2);\n+â”Š  â”Š17â”Š  }\n+â”Š  â”Š18â”Š\n+â”Š  â”Š19â”Š  // Gets the matching x value for a given y value\n+â”Š  â”Š20â”Š  getX(y) {\n+â”Š  â”Š21â”Š    let x = Utils.trim((((y - this.y1) * (this.x2 - this.x1)) / (this.y2 - this.y1)) + this.x1, 9);\n+â”Š  â”Š22â”Š    if (isNaN(x) || Utils.isBetween(x, this.x1, this.x2)) return x;\n+â”Š  â”Š23â”Š  }\n+â”Š  â”Š24â”Š\n+â”Š  â”Š25â”Š  // Gets the matching y value for a given x value\n+â”Š  â”Š26â”Š  getY(x) {\n+â”Š  â”Š27â”Š    let y = Utils.trim((((x - this.x1) * (this.y2 - this.y1)) / (this.x2 - this.x1)) + this.y1, 9);\n+â”Š  â”Š28â”Š    if (isNaN(y) || Utils.isBetween(y, this.y1, this.y2)) return y;\n+â”Š  â”Š29â”Š  }\n+â”Š  â”Š30â”Š\n+â”Š  â”Š31â”Š  // Returns if line has given point\n+â”Š  â”Š32â”Š  hasPoint(x, y) {\n+â”Š  â”Š33â”Š    if (!this.boundsHavePoint(x, y)) return false;\n+â”Š  â”Š34â”Š    let m = Utils.trim((this.y2 - this.y1) / (this.x2 - this.x1), 9);\n+â”Š  â”Š35â”Š    return (y - this.y1) / (x - this.x1) == m;\n+â”Š  â”Š36â”Š  }\n+â”Š  â”Š37â”Š\n+â”Š  â”Š38â”Š  // Returns if given point is contained by the bounds aka cage of line\n+â”Š  â”Š39â”Š  boundsHavePoint(x, y) {\n+â”Š  â”Š40â”Š    return Utils.isBetween(x, this.x1, this.x2) &&\n+â”Š  â”Š41â”Š           Utils.isBetween(y, this.y1, this.y2);\n+â”Š  â”Š42â”Š  }\n+â”Š  â”Š43â”Š\n+â”Š  â”Š44â”Š  getIntersection(shape) {\n+â”Š  â”Š45â”Š    if (shape instanceof Engine.Geometry.Line)\n+â”Š  â”Š46â”Š      return this.getLineIntersection(shape);\n+â”Š  â”Š47â”Š  }\n+â”Š  â”Š48â”Š\n+â”Š  â”Š49â”Š  // line - line intersection method\n+â”Š  â”Š50â”Š  getLineIntersection(line) {\n+â”Š  â”Š51â”Š    // Escape if lines are parallel\n+â”Š  â”Š52â”Š    if (!(((this.x1 - this.x2) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * (line.x1 - line.x2)))) return;\n+â”Š  â”Š53â”Š\n+â”Š  â”Š54â”Š    // Intersection point formula\n+â”Š  â”Š55â”Š    let x = Utils.trim(((((this.x1 * this.y2) - (this.y1 * this.x2)) * (line.x1 - line.x2)) - ((this.x1 - this.x2) * ((line.x1 * line.y2) - (line.y1 * line.x2)))) /\n+â”Š  â”Š56â”Š        (((this.x1 - this.x2) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * (line.x1 - line.x2))), 9);\n+â”Š  â”Š57â”Š    let y = Utils.trim(((((this.x1 * this.y2) - (this.y1 * this.x2)) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * ((line.x1 * line.y2) - (line.y1 * line.x2)))) /\n+â”Š  â”Š58â”Š        (((this.x1 - this.x2) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * (line.x1 - line.x2))), 9);\n+â”Š  â”Š59â”Š\n+â”Š  â”Š60â”Š    if (Utils.isBetween(x, this.x1, this.x2) && Utils.isBetween(x, line.x1, line.x2) &&\n+â”Š  â”Š61â”Š        Utils.isBetween(y, this.y1, this.y2) && Utils.isBetween(y, line.y1, line.y2)) {\n+â”Š  â”Š62â”Š      return { x, y };\n+â”Š  â”Š63â”Š    }\n+â”Š  â”Š64â”Š  }\n+â”Š  â”Š65â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -10,6 +10,7 @@\n â”Š10â”Š10â”Š    <!-- Scripts -->\n â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/utils.js\"></script>\n â”Š12â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n+â”Š  â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/geometry/line.js\"></script>\n â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/restorable.js\"></script>\n â”Š14â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/font.js\"></script>\n â”Š15â”Š16â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/sprite.js\"></script>\n```\n\n[}]: #\n\nYou can go through the comments of the step above which will guide you through the programmatic aspect of it, but I think it's more important to understand the concept of a line in 2D space. A line is made out of two points, usually represented as `(x1, y1)` and `(x2, y2)`. The slope of the line, usually represented as `m`, can be determined using these two points based on the following formula:\n\n![slope](https://cloud.githubusercontent.com/assets/7648874/21788249/b4c7e41c-d6b4-11e6-9c17-baff66ec6bc8.png)\n\nOnce we have two lines whose `m` is different (Unparalleled) and there is no intersection between the points of which they are represented with (In which case they are united), there must be an intersection point. The intersection point can be found using the following formula:\n\n![line-line](https://cloud.githubusercontent.com/assets/7648874/21787164/c9d83bf0-d6ae-11e6-9846-4fc013eebab3.png)\n\n![line-line-illustration](https://cloud.githubusercontent.com/assets/7648874/21790864/56725cf0-d6c6-11e6-916b-50b1fc0b87af.png)\n\n> See reference: http://mathworld.wolfram.com/Line-LineIntersection.html.\n\nObviously we have some logic here which needs to be tested. To test our `Line` class, we will be using a testing framework called [Jasmine](https://jasmine.github.io/). We first need to download `Jasmine`'s essentials in order for it to work:\n\n    resources/libs$ mkdir jasmine\n    resources/libs$ cd jasmine\n    resources/libs/jasmine$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/libs/jasmine/boot.js\n    resources/libs/jasmine$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/libs/jasmine/console.js\n    resources/libs/jasmine$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/libs/jasmine/jasmine-html.js\n    resources/libs/jasmine$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/libs/jasmine/jasmine.css\n    resources/libs/jasmine$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/libs/jasmine/jasmine.js\n    resources/libs/jasmine$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/libs/jasmine/jasmine_favicon.png\n\nThese essentials should be loaded in a newly created view where we're gonna see our specs running:\n\n[{]: <helper> (diffStep 5.5)\n\n#### [Step 5.5: Create specs runner view](https://github.com/DAB0mB/radial-snake/commit/150be1a)\n\n##### Added views&#x2F;spec_runner.html\n```diff\n@@ -0,0 +1,27 @@\n+â”Š  â”Š 1â”Š\n+â”Š  â”Š 2â”Š<!DOCTYPE html>\n+â”Š  â”Š 3â”Š<html>\n+â”Š  â”Š 4â”Š  <head>\n+â”Š  â”Š 5â”Š    <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n+â”Š  â”Š 6â”Š    <title>Jasmine Spec Runner v2.0.1</title>\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Š    <!-- Jasmine -->\n+â”Š  â”Š 9â”Š    <script type=\"text/javascript\" src=\"libs/jasmine/jasmine.js\"></script>\n+â”Š  â”Š10â”Š    <script type=\"text/javascript\" src=\"libs/jasmine/jasmine-html.js\"></script>\n+â”Š  â”Š11â”Š    <script type=\"text/javascript\" src=\"libs/jasmine/boot.js\"></script>\n+â”Š  â”Š12â”Š    <link rel=\"shortcut icon\" type=\"image/png\" href=\"libs/jasmine/jasmine_favicon.png\">\n+â”Š  â”Š13â”Š    <link rel=\"stylesheet\" type=\"text/css\" href=\"libs/jasmine/jasmine.css\">\n+â”Š  â”Š14â”Š\n+â”Š  â”Š15â”Š    <!-- Libs -->\n+â”Š  â”Š16â”Š    <script type=\"text/javascript\" src=\"libs/underscore.js\"></script>\n+â”Š  â”Š17â”Š\n+â”Š  â”Š18â”Š    <!-- Scripts -->\n+â”Š  â”Š19â”Š    <script type=\"text/javascript\" src=\"scripts/utils.js\"></script>\n+â”Š  â”Š20â”Š    <script type=\"text/javascript\" src=\"scripts/namespaces.js\"></script>\n+â”Š  â”Š21â”Š\n+â”Š  â”Š22â”Š    <!-- Specs -->\n+â”Š  â”Š23â”Š  </head>\n+â”Š  â”Š24â”Š\n+â”Š  â”Š25â”Š  <body>\n+â”Š  â”Š26â”Š  </body>\n+â”Š  â”Š27â”Š</html>ðŸš«â†µ\n```\n\n[}]: #\n\nNow once we'll navigate to the `/test` sub-route (`localhost:8000/test` by default) we should be provided with the spec runner. As for now there are no specs implemented at all, which brings us to the next stage - Implementing tests for `Line` class:\n\n[{]: <helper> (diffStep 5.6)\n\n#### [Step 5.6: Create &#x27;Line&#x27; class tests](https://github.com/DAB0mB/radial-snake/commit/c052752)\n\n##### Added resources&#x2F;scripts&#x2F;specs&#x2F;engine&#x2F;geometry&#x2F;line.js\n```diff\n@@ -0,0 +1,78 @@\n+â”Š  â”Š 1â”Šdescribe(\"Engine.Geometry.Line class\", function() {\n+â”Š  â”Š 2â”Š  beforeEach(function() {\n+â”Š  â”Š 3â”Š    this.line = new Engine.Geometry.Line(-5, -5, 5, 5);\n+â”Š  â”Š 4â”Š  });\n+â”Š  â”Š 5â”Š\n+â”Š  â”Š 6â”Š  describe(\"getX method\", function() {\n+â”Š  â”Š 7â”Š    describe(\"given inranged y\", function() {\n+â”Š  â”Š 8â”Š      it(\"returns x\", function() {\n+â”Š  â”Š 9â”Š        expect(this.line.getX(1)).toBeCloseTo(1);\n+â”Š  â”Š10â”Š      });\n+â”Š  â”Š11â”Š    });\n+â”Š  â”Š12â”Š\n+â”Š  â”Š13â”Š    describe(\"given outranged y\", function() {\n+â”Š  â”Š14â”Š      it(\"returns nothing\", function() {\n+â”Š  â”Š15â”Š        expect(this.line.getX(10)).toBeUndefined();\n+â”Š  â”Š16â”Š      });\n+â”Š  â”Š17â”Š    });\n+â”Š  â”Š18â”Š  });\n+â”Š  â”Š19â”Š\n+â”Š  â”Š20â”Š  describe(\"getY method\", function() {\n+â”Š  â”Š21â”Š    describe(\"given inranged x\", function() {\n+â”Š  â”Š22â”Š      it(\"returns y\", function() {\n+â”Š  â”Š23â”Š        expect(this.line.getY(1)).toBeCloseTo(1);\n+â”Š  â”Š24â”Š      });\n+â”Š  â”Š25â”Š    });\n+â”Š  â”Š26â”Š\n+â”Š  â”Š27â”Š    describe(\"given outranged x\", function() {\n+â”Š  â”Š28â”Š      it(\"returns nothing\", function() {\n+â”Š  â”Š29â”Š        expect(this.line.getY(10)).toBeUndefined();\n+â”Š  â”Š30â”Š      });\n+â”Š  â”Š31â”Š    });\n+â”Š  â”Š32â”Š  });\n+â”Š  â”Š33â”Š\n+â”Š  â”Š34â”Š  describe(\"hasPoint method\", function() {\n+â”Š  â”Š35â”Š    describe(\"given contained point\", function() {\n+â”Š  â”Š36â”Š      it(\"returns true\", function() {\n+â”Š  â”Š37â”Š        let x = 1;\n+â”Š  â”Š38â”Š        let y = 1;\n+â”Š  â”Š39â”Š        expect(this.line.hasPoint(x, y)).toBeTruthy();\n+â”Š  â”Š40â”Š      });\n+â”Š  â”Š41â”Š    });\n+â”Š  â”Š42â”Š\n+â”Š  â”Š43â”Š    describe(\"given uncontained point\", function() {\n+â”Š  â”Š44â”Š      it(\"returns false\", function() {\n+â”Š  â”Š45â”Š        let x = 10;\n+â”Š  â”Š46â”Š        let y = 10;\n+â”Š  â”Š47â”Š        expect(this.line.hasPoint(x, y)).toBeFalsy();\n+â”Š  â”Š48â”Š      });\n+â”Š  â”Š49â”Š    });\n+â”Š  â”Š50â”Š  });\n+â”Š  â”Š51â”Š\n+â”Š  â”Š52â”Š  describe(\"getLineIntersection method\", function() {\n+â”Š  â”Š53â”Š    describe(\"given intersecting line\", function() {\n+â”Š  â”Š54â”Š      it(\"returns intersection point\", function() {\n+â”Š  â”Š55â”Š        let line = new Engine.Geometry.Line(1, -5, 1, 5);\n+â”Š  â”Š56â”Š\n+â”Š  â”Š57â”Š        expect(this.line.getLineIntersection(line)).toEqual({\n+â”Š  â”Š58â”Š          x: 1,\n+â”Š  â”Š59â”Š          y: 1\n+â”Š  â”Š60â”Š        });\n+â”Š  â”Š61â”Š      });\n+â”Š  â”Š62â”Š    });\n+â”Š  â”Š63â”Š\n+â”Š  â”Š64â”Š    describe(\"given parallel line\", function() {\n+â”Š  â”Š65â”Š      it(\"returns nothing\", function() {\n+â”Š  â”Š66â”Š        let line = new Engine.Geometry.Line(-5, -6, 5, 4);\n+â”Š  â”Š67â”Š        expect(this.line.getLineIntersection(line)).toBeUndefined();\n+â”Š  â”Š68â”Š      });\n+â”Š  â”Š69â”Š    });\n+â”Š  â”Š70â”Š\n+â”Š  â”Š71â”Š    describe(\"given outranged line\", function() {\n+â”Š  â”Š72â”Š      it(\"returns nothing\", function() {\n+â”Š  â”Š73â”Š        let line = new Engine.Geometry.Line(10, 10, 10, 15);\n+â”Š  â”Š74â”Š        expect(this.line.getLineIntersection(line)).toBeUndefined();\n+â”Š  â”Š75â”Š      });\n+â”Š  â”Š76â”Š    });\n+â”Š  â”Š77â”Š  });\n+â”Š  â”Š78â”Š});ðŸš«â†µ\n```\n\n##### Changed views&#x2F;spec_runner.html\n```diff\n@@ -18,8 +18,10 @@\n â”Š18â”Š18â”Š    <!-- Scripts -->\n â”Š19â”Š19â”Š    <script type=\"text/javascript\" src=\"scripts/utils.js\"></script>\n â”Š20â”Š20â”Š    <script type=\"text/javascript\" src=\"scripts/namespaces.js\"></script>\n+â”Š  â”Š21â”Š    <script type=\"text/javascript\" src=\"scripts/engine/geometry/line.js\"></script>\n â”Š21â”Š22â”Š\n â”Š22â”Š23â”Š    <!-- Specs -->\n+â”Š  â”Š24â”Š    <script type=\"text/javascript\" src=\"scripts/specs/engine/geometry/line.js\"></script>\n â”Š23â”Š25â”Š  </head>\n â”Š24â”Š26â”Š\n â”Š25â”Š27â”Š  <body>\n```\n\n[}]: #\n\nNow if you'll refresh the spec runner page you should be able to a green screen indicating all tests have passed (Assuming the tutorial is updated and you followed it correctly). As introduced at the beginning of the step, the snake is also dependent on circles, whose representing class should look like so:\n\n[{]: <helper> (diffStep 5.7)\n\n#### [Step 5.7: Create &#x27;Circle&#x27; class](https://github.com/DAB0mB/radial-snake/commit/f9c5723)\n\n##### Added resources&#x2F;scripts&#x2F;engine&#x2F;geometry&#x2F;circle.js\n```diff\n@@ -0,0 +1,167 @@\n+â”Š   â”Š  1â”ŠEngine.Geometry.Circle = class Circle {\n+â”Š   â”Š  2â”Š  // x - The x value of the circle's center\n+â”Š   â”Š  3â”Š  // y - The y value of the circle's center\n+â”Š   â”Š  4â”Š  // r - The radius of the center\n+â”Š   â”Š  5â”Š  // rad1 - The first radian of the circle, not necessarily its beginning\n+â”Š   â”Š  6â”Š  // rad2 - The second radian of the circle, not necessarily its beginning\n+â”Š   â”Š  7â”Š  constructor(x, y, r, rad1, rad2) {\n+â”Š   â”Š  8â”Š    this.x = Utils.trim(x, 9);\n+â”Š   â”Š  9â”Š    this.y = Utils.trim(y, 9);\n+â”Š   â”Š 10â”Š    this.r = Utils.trim(r, 9);\n+â”Š   â”Š 11â”Š\n+â”Š   â”Š 12â”Š    // Trimming mode is done based on which radian represents the ending and which radian\n+â”Š   â”Š 13â”Š    // represents the ending\n+â”Š   â”Š 14â”Š    if (rad1 > rad2) {\n+â”Š   â”Š 15â”Š      this.rad1 = Utils.trim(rad1, 9, \"floor\");\n+â”Š   â”Š 16â”Š      this.rad2 = Utils.trim(rad2, 9, \"ceil\");\n+â”Š   â”Š 17â”Š    }\n+â”Š   â”Š 18â”Š    else {\n+â”Š   â”Š 19â”Š      this.rad1 = Utils.trim(rad1, 9, \"ceil\");\n+â”Š   â”Š 20â”Š      this.rad2 = Utils.trim(rad2, 9, \"floor\");\n+â”Š   â”Š 21â”Š    }\n+â”Š   â”Š 22â”Š  }\n+â”Š   â”Š 23â”Š\n+â”Š   â”Š 24â”Š  // Draws the circle on the given context\n+â”Š   â”Š 25â”Š  draw(context) {\n+â”Š   â”Š 26â”Š    context.arc(this.x, this.y, this.r, this.rad1, this.rad2);\n+â”Š   â”Š 27â”Š  }\n+â”Š   â”Š 28â”Š\n+â”Š   â”Š 29â”Š  // Gets the matching x value for the given radian\n+â”Š   â”Š 30â”Š  getX(rad) {\n+â”Š   â”Š 31â”Š    if (!Utils(rad).trim(9).isBetween(this.rad1, this.rad2).value()) return;\n+â”Š   â”Š 32â”Š    return Utils.trim((this.r * Math.cos(rad)) + this.x, 9);\n+â”Š   â”Š 33â”Š  }\n+â”Š   â”Š 34â”Š\n+â”Š   â”Š 35â”Š  // Gets the matching y value for the given radian\n+â”Š   â”Š 36â”Š  getY(rad) {\n+â”Š   â”Š 37â”Š    if (!Utils(rad).trim(9).isBetween(this.rad1, this.rad2).value()) return;\n+â”Š   â”Š 38â”Š    return Utils.trim((this.r * Math.sin(rad)) + this.y, 9);\n+â”Š   â”Š 39â”Š  }\n+â”Š   â”Š 40â”Š\n+â”Š   â”Š 41â”Š  // Gets the matching point for the given radian\n+â”Š   â”Š 42â”Š  getPoint(rad) {\n+â”Š   â”Š 43â”Š    if (!Utils.isBetween(rad, this.rad1, this.rad2)) return;\n+â”Š   â”Š 44â”Š\n+â”Š   â”Š 45â”Š    return {\n+â”Š   â”Š 46â”Š      x: Utils.trim((this.r * Math.cos(rad)) + this.x, 9),\n+â”Š   â”Š 47â”Š      y: Utils.trim((this.r * Math.sin(rad)) + this.y, 9)\n+â”Š   â”Š 48â”Š    };\n+â”Š   â”Š 49â”Š  }\n+â”Š   â”Š 50â”Š\n+â”Š   â”Š 51â”Š  // Gets the matching radian for the given point\n+â”Š   â”Š 52â”Š  getRad(x, y) {\n+â”Š   â”Š 53â”Š    let rad = Math.atan2(y - this.y, x - this.x);\n+â”Š   â”Š 54â”Š\n+â”Š   â”Š 55â”Š    // If calculated radian is in circle's radian range, return it\n+â”Š   â”Š 56â”Š    if (rad != null && Utils.isBetween(rad, this.rad1, this.rad2)) {\n+â”Š   â”Š 57â”Š      return rad;\n+â”Š   â”Š 58â”Š    }\n+â”Š   â”Š 59â”Š\n+â”Š   â”Š 60â”Š    // The calculated radian can still be in the circle's radian range in case one\n+â”Š   â”Š 61â”Š    // of the radians is greater than 2 PIEs\n+â”Š   â”Š 62â”Š    if (Math.abs(this.rad1) > Math.abs(this.rad2)) {\n+â”Š   â”Š 63â”Š      var greatestRad = this.rad1;\n+â”Š   â”Š 64â”Š    }\n+â”Š   â”Š 65â”Š    else {\n+â”Š   â”Š 66â”Š      var greatestRad = this.rad2;\n+â”Š   â”Š 67â”Š    }\n+â”Š   â”Š 68â”Š\n+â”Š   â”Š 69â”Š    // Check if the absolute radian is in the circle's radian range\n+â”Š   â”Š 70â”Š    if (Utils(rad + (2 * Math.PI * Math.floor(greatestRad / (2 * Math.PI)))).trim(9).isBetween(this.rad1, this.rad2).value() ||\n+â”Š   â”Š 71â”Š        Utils(rad + (2 * Math.PI * Math.ceil(greatestRad / (2 * Math.PI)))).trim(9).isBetween(this.rad1, this.rad2).value()) {\n+â”Š   â”Š 72â”Š      return rad;\n+â”Š   â”Š 73â”Š    }\n+â”Š   â”Š 74â”Š  }\n+â”Š   â”Š 75â”Š\n+â”Š   â”Š 76â”Š  // Returns if circle has given points\n+â”Š   â”Š 77â”Š  hasPoint(x, y) {\n+â”Š   â”Š 78â”Š    return this.getRad(x, y) != null;\n+â”Š   â”Š 79â”Š  }\n+â”Š   â”Š 80â”Š\n+â”Š   â”Š 81â”Š  getIntersection(shape) {\n+â”Š   â”Š 82â”Š    if (shape instanceof Engine.Geometry.Line)\n+â”Š   â”Š 83â”Š      return this.getLineIntersection(shape);\n+â”Š   â”Š 84â”Š    if (shape instanceof Engine.Geometry.Circle)\n+â”Š   â”Š 85â”Š      return this.getCircleIntersection(shape);\n+â”Š   â”Š 86â”Š  }\n+â”Š   â”Š 87â”Š\n+â”Š   â”Š 88â”Š  // circle - circle intersection method\n+â”Š   â”Š 89â”Š  getCircleIntersection(circle) {\n+â”Š   â”Š 90â”Š    let dx = circle.x - this.x;\n+â”Š   â”Š 91â”Š    let dy = circle.y - this.y;\n+â”Š   â”Š 92â”Š    let d = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\n+â”Š   â”Š 93â”Š\n+â”Š   â”Š 94â”Š    if (d > this.r + circle.r ||\n+â”Š   â”Š 95â”Š       d < Math.abs(this.r - circle.r)) {\n+â”Š   â”Š 96â”Š      return;\n+â”Š   â”Š 97â”Š    }\n+â”Š   â”Š 98â”Š\n+â”Š   â”Š 99â”Š    let a = ((Math.pow(this.r, 2) - Math.pow(circle.r, 2)) + Math.pow(d, 2)) / (2 * d);\n+â”Š   â”Š100â”Š    let x = this.x + ((dx * a) / d);\n+â”Š   â”Š101â”Š    let y = this.y + ((dy * a) / d);\n+â”Š   â”Š102â”Š    let h = Math.sqrt(Math.pow(this.r, 2) - Math.pow(a, 2));\n+â”Š   â”Š103â”Š    let rx = (- dy * h) / d;\n+â”Š   â”Š104â”Š    let ry = (dx * h) / d;\n+â”Š   â”Š105â”Š\n+â”Š   â”Š106â”Š    let interPoints = [\n+â”Š   â”Š107â”Š      {\n+â”Š   â”Š108â”Š        x: x + rx,\n+â”Š   â”Š109â”Š        y: y + ry\n+â”Š   â”Š110â”Š      },\n+â”Š   â”Š111â”Š      {\n+â”Š   â”Š112â”Š        x: x - rx,\n+â”Š   â”Š113â”Š        y: y - ry\n+â”Š   â”Š114â”Š      }\n+â”Š   â”Š115â”Š    ]\n+â”Š   â”Š116â”Š    .map(point => ({\n+â”Š   â”Š117â”Š        x: Utils.trim(point.x, 9),\n+â”Š   â”Š118â”Š        y: Utils.trim(point.y, 9)\n+â”Š   â”Š119â”Š     }));\n+â”Š   â”Š120â”Š\n+â”Š   â”Š121â”Š    interPoints = _.uniq(interPoints, point => `(${point.x}, ${point.y})`);\n+â”Š   â”Š122â”Š\n+â”Š   â”Š123â”Š    [this, circle].forEach(function(circle) {\n+â”Š   â”Š124â”Š      interPoints = interPoints.filter(point => circle.hasPoint(point.x, point.y));\n+â”Š   â”Š125â”Š    });\n+â”Š   â”Š126â”Š\n+â”Š   â”Š127â”Š    if (interPoints.length > 0) return interPoints;\n+â”Š   â”Š128â”Š  }\n+â”Š   â”Š129â”Š\n+â”Š   â”Š130â”Š  // circle - line intersection method\n+â”Š   â”Š131â”Š  getLineIntersection(line) {\n+â”Š   â”Š132â”Š    let x1 = line.x1 - this.x;\n+â”Š   â”Š133â”Š    let x2 = line.x2 - this.x;\n+â”Š   â”Š134â”Š    let y1 = line.y1 - this.y;\n+â”Š   â”Š135â”Š    let y2 = line.y2 - this.y;\n+â”Š   â”Š136â”Š    let dx = x2 - x1;\n+â”Š   â”Š137â”Š    let dy = y2 - y1;\n+â”Š   â”Š138â”Š    let d = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\n+â”Š   â”Š139â”Š    let h = (x1 * y2) - (x2 * y1);\n+â”Š   â”Š140â”Š    let delta = (Math.pow(this.r, 2) * Math.pow(d, 2)) - Math.pow(h, 2);\n+â”Š   â”Š141â”Š\n+â”Š   â”Š142â”Š    if (delta < 0) return;\n+â”Š   â”Š143â”Š\n+â”Š   â”Š144â”Š    let interPoints = [\n+â”Š   â”Š145â”Š      {\n+â”Š   â”Š146â”Š        x: (((h * dy) + (((dy / Math.abs(dy)) || 1) * dx * Math.sqrt(delta))) / Math.pow(d, 2)) + this.x,\n+â”Š   â”Š147â”Š        y: (((-h * dx) + (Math.abs(dy) * Math.sqrt(delta))) / Math.pow(d, 2)) + this.y\n+â”Š   â”Š148â”Š      },\n+â”Š   â”Š149â”Š      {\n+â”Š   â”Š150â”Š        x: (((h * dy) - (((dy / Math.abs(dy)) || 1) * dx * Math.sqrt(delta))) / Math.pow(d, 2)) + this.x,\n+â”Š   â”Š151â”Š        y: (((-h * dx) - (Math.abs(dy) * Math.sqrt(delta))) / Math.pow(d, 2)) + this.y\n+â”Š   â”Š152â”Š      }\n+â”Š   â”Š153â”Š    ]\n+â”Š   â”Š154â”Š    .map(point => ({\n+â”Š   â”Š155â”Š        x: Utils.trim(point.x, 9),\n+â”Š   â”Š156â”Š        y: Utils.trim(point.y, 9)\n+â”Š   â”Š157â”Š    }))\n+â”Š   â”Š158â”Š    .filter(point => {\n+â”Š   â”Š159â”Š      return this.hasPoint(point.x, point.y) &&\n+â”Š   â”Š160â”Š        line.boundsHavePoint(point.x, point.y);\n+â”Š   â”Š161â”Š    });\n+â”Š   â”Š162â”Š\n+â”Š   â”Š163â”Š    interPoints = _.uniq(interPoints, point => `(${point.x}, ${point.y})`);\n+â”Š   â”Š164â”Š\n+â”Š   â”Š165â”Š    if (interPoints.length > 0) return interPoints;\n+â”Š   â”Š166â”Š  }\n+â”Š   â”Š167â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -11,6 +11,7 @@\n â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/utils.js\"></script>\n â”Š12â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n â”Š13â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/geometry/line.js\"></script>\n+â”Š  â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/geometry/circle.js\"></script>\n â”Š14â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/restorable.js\"></script>\n â”Š15â”Š16â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/font.js\"></script>\n â”Š16â”Š17â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/sprite.js\"></script>\n```\n\n[}]: #\n\nJust like a line, a circle can be presented using variables as well. The center of the circle is represented as `(x, y)` and its radius is represented as `r`. Remember that our circle doesn't necessarily have to be a full one, therefore we limit its range using two radians - `rad1` and `rad2`. The formula for representing a circle in a 2D space looks like this:\n\n![circle-formula](https://cloud.githubusercontent.com/assets/7648874/21829783/84a54574-d77f-11e6-9b87-3fb0f073bb8d.png)\n\n![circle-circle-illustration](https://cloud.githubusercontent.com/assets/7648874/21790842/3a73408c-d6c6-11e6-8bdd-9c73355e6ebb.png)\n\n> `a` and `b` represent the offsets from the `x` and the `y` axes respectively.\n> See reference: http://mathworld.wolfram.com/Circle-CircleIntersection.html.\n\nTo find intersection between two circles, we simply calculate the solution for two equations with two variables. Given that a line can be represented in a 2D space using the following formula:\n\n![line-formula](https://cloud.githubusercontent.com/assets/7648874/21790671/1609c050-d6c5-11e6-8bd7-16cc306f5eea.png)\n\n![circle-line-illustration](https://cloud.githubusercontent.com/assets/7648874/21790810/1a052086-d6c6-11e6-9c5c-24298fedb043.png)\n\n> `n` represents the intersection value with the `y` axis.\n> See reference: http://mathworld.wolfram.com/Circle-LineIntersection.html.\n\nwe can find the intersection between a circle and line by solving the systems formed by the equations of both. We also want the line-circle algorithm to be available for any `Line` instance, therefore we gonna add the following delegate on the `Line` prototype:\n\n[{]: <helper> (diffStep 5.8)\n\n#### [Step 5.8: Delegate circle intersection methods](https://github.com/DAB0mB/radial-snake/commit/19828bf)\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;geometry&#x2F;line.js\n```diff\n@@ -44,6 +44,8 @@\n â”Š44â”Š44â”Š  getIntersection(shape) {\n â”Š45â”Š45â”Š    if (shape instanceof Engine.Geometry.Line)\n â”Š46â”Š46â”Š      return this.getLineIntersection(shape);\n+â”Š  â”Š47â”Š    if (shape instanceof Engine.Geometry.Circle)\n+â”Š  â”Š48â”Š      return this.getCircleIntersection(shape);\n â”Š47â”Š49â”Š  }\n â”Š48â”Š50â”Š\n â”Š49â”Š51â”Š  // line - line intersection method\n```\n```diff\n@@ -62,4 +64,9 @@\n â”Š62â”Š64â”Š      return { x, y };\n â”Š63â”Š65â”Š    }\n â”Š64â”Š66â”Š  }\n+â”Š  â”Š67â”Š\n+â”Š  â”Š68â”Š  // line - circle intersection method\n+â”Š  â”Š69â”Š  getCircleIntersection(circle) {\n+â”Š  â”Š70â”Š    return circle.getLineIntersection(this);\n+â”Š  â”Š71â”Š  }\n â”Š65â”Š72â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nThen again a newly created geometry shape class should be tested against different scenarios:\n\n[{]: <helper> (diffStep 5.9)\n\n#### [Step 5.9: Create &#x27;Circle&#x27; class tests](https://github.com/DAB0mB/radial-snake/commit/1d98a6e)\n\n##### Added resources&#x2F;scripts&#x2F;specs&#x2F;engine&#x2F;geometry&#x2F;circle.js\n```diff\n@@ -0,0 +1,144 @@\n+â”Š   â”Š  1â”Šdescribe(\"Engine.Geometry.Circle class\", function() {\n+â”Š   â”Š  2â”Š  beforeEach(function() {\n+â”Š   â”Š  3â”Š    this.circle = new Engine.Geometry.Circle(1, 1, 5, 0, 1.5 * Math.PI);\n+â”Š   â”Š  4â”Š  });\n+â”Š   â”Š  5â”Š\n+â”Š   â”Š  6â”Š  describe(\"getX method\", function() {\n+â”Š   â”Š  7â”Š    describe(\"given inranged rad\", function() {\n+â”Š   â”Š  8â”Š      it(\"returns x\", function() {\n+â”Š   â”Š  9â”Š        expect(this.circle.getX(0 * Math.PI)).toBeCloseTo(6);\n+â”Š   â”Š 10â”Š        expect(this.circle.getX(0.5 * Math.PI)).toBeCloseTo(1);\n+â”Š   â”Š 11â”Š        expect(this.circle.getX(1 * Math.PI)).toBeCloseTo(-4);\n+â”Š   â”Š 12â”Š        expect(this.circle.getX(1.5 * Math.PI)).toBeCloseTo(1);\n+â”Š   â”Š 13â”Š      });\n+â”Š   â”Š 14â”Š    });\n+â”Š   â”Š 15â”Š\n+â”Š   â”Š 16â”Š    describe(\"given outranged rad\", function() {\n+â”Š   â”Š 17â”Š      it(\"returns nothing\", function() {\n+â”Š   â”Š 18â”Š        expect(this.circle.getX(2 * Math.PI)).toBeUndefined();\n+â”Š   â”Š 19â”Š      });\n+â”Š   â”Š 20â”Š    });\n+â”Š   â”Š 21â”Š  });\n+â”Š   â”Š 22â”Š\n+â”Š   â”Š 23â”Š  describe(\"getY method\", function() {\n+â”Š   â”Š 24â”Š    describe(\"given inranged rad\", function() {\n+â”Š   â”Š 25â”Š      it(\"returns y\", function() {\n+â”Š   â”Š 26â”Š        expect(this.circle.getY(0 * Math.PI)).toBeCloseTo(1);\n+â”Š   â”Š 27â”Š        expect(this.circle.getY(0.5 * Math.PI)).toBeCloseTo(6);\n+â”Š   â”Š 28â”Š        expect(this.circle.getY(1 * Math.PI)).toBeCloseTo(1);\n+â”Š   â”Š 29â”Š        expect(this.circle.getY(1.5 * Math.PI)).toBeCloseTo(-4);\n+â”Š   â”Š 30â”Š      });\n+â”Š   â”Š 31â”Š    });\n+â”Š   â”Š 32â”Š\n+â”Š   â”Š 33â”Š    describe(\"given outranged rad\", function() {\n+â”Š   â”Š 34â”Š      it(\"returns nothing\", function() {\n+â”Š   â”Š 35â”Š        expect(this.circle.getY(2 * Math.PI)).toBeUndefined();\n+â”Š   â”Š 36â”Š      });\n+â”Š   â”Š 37â”Š    });\n+â”Š   â”Š 38â”Š  });\n+â”Š   â”Š 39â”Š\n+â”Š   â”Š 40â”Š  describe(\"getRad method\", function() {\n+â”Š   â”Š 41â”Š    describe(\"given inranged point\", function() {\n+â”Š   â”Š 42â”Š      it(\"returns rad\", function() {\n+â”Š   â”Š 43â”Š        let x = -3.0450849718747346;\n+â”Š   â”Š 44â”Š        let y = 3.9389262614623686;\n+â”Š   â”Š 45â”Š        expect(this.circle.getRad(x, y)).toBeCloseTo(0.8 * Math.PI);\n+â”Š   â”Š 46â”Š      });\n+â”Š   â”Š 47â”Š    });\n+â”Š   â”Š 48â”Š\n+â”Š   â”Š 49â”Š    describe(\"given outranged point\", function() {\n+â”Š   â”Š 50â”Š      it(\"returns nothing\", function() {\n+â”Š   â”Š 51â”Š        let x = 5.045084971874736;\n+â”Š   â”Š 52â”Š        let y = -1.9389262614623664;\n+â”Š   â”Š 53â”Š        expect(this.circle.getRad(x, y)).toBeUndefined();\n+â”Š   â”Š 54â”Š      });\n+â”Š   â”Š 55â”Š    });\n+â”Š   â”Š 56â”Š  });\n+â”Š   â”Š 57â”Š\n+â”Š   â”Š 58â”Š  describe(\"getCircleIntersection method\", function() {\n+â”Š   â”Š 59â”Š    describe(\"given circle with 2 intersection points\", function() {\n+â”Š   â”Š 60â”Š      it(\"returns array with intersection points\", function() {\n+â”Š   â”Š 61â”Š        let circle = new Engine.Geometry.Circle(-5, 1, 5, 0, 2 * Math.PI);\n+â”Š   â”Š 62â”Š\n+â”Š   â”Š 63â”Š        expect(this.circle.getCircleIntersection(circle)).toEqual([\n+â”Š   â”Š 64â”Š          { x: -2, y: -3 },\n+â”Š   â”Š 65â”Š          { x: -2, y: 5 }\n+â”Š   â”Š 66â”Š        ]);\n+â”Š   â”Š 67â”Š      });\n+â”Š   â”Š 68â”Š    });\n+â”Š   â”Š 69â”Š\n+â”Š   â”Š 70â”Š    describe(\"given circle with 1 intersection points\", function() {\n+â”Š   â”Š 71â”Š      it(\"returns array with intersection point\", function() {\n+â”Š   â”Š 72â”Š        let circle = new Engine.Geometry.Circle(-5, 1, 5, 0, 1 * Math.PI);\n+â”Š   â”Š 73â”Š\n+â”Š   â”Š 74â”Š        expect(this.circle.getCircleIntersection(circle)).toEqual([\n+â”Š   â”Š 75â”Š          { x: -2, y: 5 }\n+â”Š   â”Š 76â”Š        ]);\n+â”Š   â”Š 77â”Š      });\n+â”Š   â”Š 78â”Š    });\n+â”Š   â”Š 79â”Š\n+â”Š   â”Š 80â”Š    describe(\"given kissing circle\", function() {\n+â”Š   â”Š 81â”Š      it(\"returns array with intersection point\", function() {\n+â”Š   â”Š 82â”Š        let circle = new Engine.Geometry.Circle(-9, 1, 5, 0, 2 * Math.PI);\n+â”Š   â”Š 83â”Š\n+â”Š   â”Š 84â”Š        expect(this.circle.getCircleIntersection(circle)).toEqual([\n+â”Š   â”Š 85â”Š          { x: -4, y: 1 }\n+â”Š   â”Š 86â”Š        ]);\n+â”Š   â”Š 87â”Š      });\n+â”Š   â”Š 88â”Š    });\n+â”Š   â”Š 89â”Š\n+â”Š   â”Š 90â”Š    describe(\"given outer circle\", function() {\n+â”Š   â”Š 91â”Š      it(\"returns nothing\", function() {\n+â”Š   â”Š 92â”Š        let circle = new Engine.Geometry.Circle(10, 10, 2, 0, 2 * Math.PI);\n+â”Š   â”Š 93â”Š        expect(this.circle.getCircleIntersection(circle)).toBeUndefined();\n+â”Š   â”Š 94â”Š      });\n+â”Š   â”Š 95â”Š    });\n+â”Š   â”Š 96â”Š\n+â”Š   â”Š 97â”Š    describe(\"given inner circle\", function() {\n+â”Š   â”Š 98â”Š      it(\"nothing\", function() {\n+â”Š   â”Š 99â”Š        let circle = new Engine.Geometry.Circle(1, 1, 2, 0, 2 * Math.PI);\n+â”Š   â”Š100â”Š        expect(this.circle.getCircleIntersection(circle)).toBeUndefined();\n+â”Š   â”Š101â”Š      });\n+â”Š   â”Š102â”Š    });\n+â”Š   â”Š103â”Š  });\n+â”Š   â”Š104â”Š\n+â”Š   â”Š105â”Š  describe(\"getLineIntersection method\", function() {\n+â”Š   â”Š106â”Š    describe(\"given line with 2 intersection points\", function() {\n+â”Š   â”Š107â”Š      it(\"returns array with intersection points\", function() {\n+â”Š   â”Š108â”Š        let line = new Engine.Geometry.Line(-10, 1, 10, 1);\n+â”Š   â”Š109â”Š\n+â”Š   â”Š110â”Š        expect(this.circle.getLineIntersection(line)).toEqual([\n+â”Š   â”Š111â”Š          { x: 6, y: 1 },\n+â”Š   â”Š112â”Š          { x: -4, y: 1 }\n+â”Š   â”Š113â”Š        ]);\n+â”Š   â”Š114â”Š      });\n+â”Š   â”Š115â”Š    });\n+â”Š   â”Š116â”Š\n+â”Š   â”Š117â”Š    describe(\"given line with 1 intersection point\", function() {\n+â”Š   â”Š118â”Š      it(\"returns array with intersection point\", function() {\n+â”Š   â”Š119â”Š        let line = new Engine.Geometry.Line(-10, 1, 1, 1);\n+â”Š   â”Š120â”Š\n+â”Š   â”Š121â”Š        expect(this.circle.getLineIntersection(line)).toEqual([\n+â”Š   â”Š122â”Š          { x: -4, y: 1 }\n+â”Š   â”Š123â”Š        ]);\n+â”Š   â”Š124â”Š      });\n+â”Š   â”Š125â”Š    });\n+â”Š   â”Š126â”Š\n+â”Š   â”Š127â”Š    describe(\"given kissing line\", function() {\n+â”Š   â”Š128â”Š      it(\"returns array with intersection point\", function() {\n+â”Š   â”Š129â”Š        let line = new Engine.Geometry.Line(-10, 6, 10, 6);\n+â”Š   â”Š130â”Š\n+â”Š   â”Š131â”Š        expect(this.circle.getLineIntersection(line)).toEqual([\n+â”Š   â”Š132â”Š          { x: 1, y: 6 }\n+â”Š   â”Š133â”Š        ]);\n+â”Š   â”Š134â”Š      });\n+â”Š   â”Š135â”Š    });\n+â”Š   â”Š136â”Š\n+â”Š   â”Š137â”Š    describe(\"given outranged line\", function() {\n+â”Š   â”Š138â”Š      it(\"returns nothing\", function() {\n+â”Š   â”Š139â”Š        let line = new Engine.Geometry.Line(-10, 10, 10, 10);\n+â”Š   â”Š140â”Š        expect(this.circle.getLineIntersection(line)).toBeUndefined();\n+â”Š   â”Š141â”Š      });\n+â”Š   â”Š142â”Š    });\n+â”Š   â”Š143â”Š  });\n+â”Š   â”Š144â”Š});ðŸš«â†µ\n```\n\n##### Changed views&#x2F;spec_runner.html\n```diff\n@@ -19,9 +19,11 @@\n â”Š19â”Š19â”Š    <script type=\"text/javascript\" src=\"scripts/utils.js\"></script>\n â”Š20â”Š20â”Š    <script type=\"text/javascript\" src=\"scripts/namespaces.js\"></script>\n â”Š21â”Š21â”Š    <script type=\"text/javascript\" src=\"scripts/engine/geometry/line.js\"></script>\n+â”Š  â”Š22â”Š    <script type=\"text/javascript\" src=\"scripts/engine/geometry/circle.js\"></script>\n â”Š22â”Š23â”Š\n â”Š23â”Š24â”Š    <!-- Specs -->\n â”Š24â”Š25â”Š    <script type=\"text/javascript\" src=\"scripts/specs/engine/geometry/line.js\"></script>\n+â”Š  â”Š26â”Š    <script type=\"text/javascript\" src=\"scripts/specs/engine/geometry/circle.js\"></script>\n â”Š25â”Š27â”Š  </head>\n â”Š26â”Š28â”Š\n â”Š27â”Š29â”Š  <body>\n```\n\n[}]: #\n\nOur final shape in the geometry module would be a polygon. Why a polygon? Since I'm planning to make the snake's movement circular, which means that once the snake hits a random boundary, he will reappear from the other side of the canvas. The collision detection between the snake and the canvas would be done using a polygon - which is simply made out of 4 lines:\n\n[{]: <helper> (diffStep 5.1)\n\n#### [Step 5.1: Create utilities module](https://github.com/DAB0mB/radial-snake/commit/58ae99a)\n\n##### Added resources&#x2F;scripts&#x2F;utils.js\n```diff\n@@ -0,0 +1,68 @@\n+â”Š  â”Š 1â”Š// A wrapper function for our utilities which will enable chaining\n+â”Š  â”Š 2â”Š// e.g. Utils().mod().trim().isBetween()...\n+â”Š  â”Š 3â”ŠUtils = function Utils(context) {\n+â”Š  â”Š 4â”Š  const chain = {};\n+â”Š  â”Š 5â”Š\n+â”Š  â”Š 6â”Š  Object.keys(Utils).forEach((utilName) => {\n+â”Š  â”Š 7â”Š    chain[utilName] = (...args) => {\n+â”Š  â”Š 8â”Š      const result = Utils[utilName](context, ...args);\n+â”Š  â”Š 9â”Š      return Utils(result);\n+â”Š  â”Š10â”Š    };\n+â”Š  â”Š11â”Š  });\n+â”Š  â”Š12â”Š\n+â”Š  â”Š13â”Š  // Returns the result of the chaining\n+â”Š  â”Š14â”Š  chain.value = () => context;\n+â”Š  â”Š15â”Š\n+â”Š  â”Š16â”Š  return chain;\n+â”Š  â”Š17â”Š};\n+â”Š  â”Š18â”Š\n+â”Š  â”Š19â”Š// Fixed modulo method which can calculate modulo of negative numbers properly\n+â”Š  â”Š20â”Š// e.g. (-803).mod(800) returns 797\n+â”Š  â”Š21â”ŠUtils.mod = function (context, num) {\n+â”Š  â”Š22â”Š  return ((context % num) + num) % num;\n+â”Š  â”Š23â”Š};\n+â”Š  â”Š24â”Š\n+â”Š  â”Š25â”Š// Trims number and leaves the number of decimals specified.\n+â”Š  â”Š26â”Š// The \"mode\" argument specifies which math function should be invoked\n+â”Š  â”Š27â”Š// right after the number has been trimmed.\n+â”Š  â”Š28â”Š// e.g. 12.12345.trim(3, \"ceil\") returns 12.124\n+â”Š  â”Š29â”ŠUtils.trim = function (context, decimals, mode = \"round\") {\n+â”Š  â”Š30â”Š  return Math[mode](context * Math.pow(10, decimals)) / Math.pow(10, decimals);\n+â”Š  â”Š31â”Š};\n+â”Š  â”Š32â”Š\n+â”Š  â”Š33â”Š// Tells if number is in specified range based on given precision.\n+â”Š  â”Š34â”Š// See the \"compare\" method for more information about precision\n+â”Š  â”Š35â”ŠUtils.isBetween = function (context, num1, num2, precision) {\n+â”Š  â”Š36â”Š  return Utils.compare(context, Math.min(num1, num2), \">=\", precision) &&\n+â”Š  â”Š37â”Š         Utils.compare(context, Math.max(num1, num2), \"<=\", precision);\n+â”Š  â”Š38â”Š};\n+â”Š  â”Š39â”Š\n+â”Š  â”Š40â”Š// Initiates comparison operator between context number and a given number, only here\n+â”Š  â”Š41â”Š// a precision can be specified\n+â”Š  â”Š42â”ŠUtils.compare = function (context, num, method, precision = method) {\n+â”Š  â”Š43â”Š  switch (precision) {\n+â”Š  â”Š44â”Š    // Fixed precision, \"almost equal\" with a deviation of Îµ\n+â”Š  â”Š45â”Š    case \"f\":\n+â”Š  â”Š46â”Š      switch (method) {\n+â”Š  â”Š47â”Š        case \"<\": case \"<=\": return context <= num + Number.EPSILON;\n+â”Š  â”Š48â”Š        case \">\": case \">=\": return context >= num - Number.EPSILON;\n+â”Š  â”Š49â”Š        default: return Math.abs(context - num) <= Number.EPSILON;\n+â”Š  â”Š50â”Š      }\n+â”Š  â”Š51â”Š    // Pixel precision, round comparison\n+â”Š  â”Š52â”Š    case \"px\":\n+â”Š  â”Š53â”Š      switch (method) {\n+â”Š  â”Š54â”Š        case \"<\": case \"<=\": return Math.round(context) <= Math.round(num);\n+â”Š  â”Š55â”Š        case \">\": case \">=\": return Math.round(context) >= Math.round(num);\n+â”Š  â”Š56â”Š        default: return Math.round(context) == Math.round(num);\n+â”Š  â”Š57â”Š      }\n+â”Š  â”Š58â”Š    // Exact precision\n+â”Š  â”Š59â”Š    default:\n+â”Š  â”Š60â”Š      switch (method) {\n+â”Š  â”Š61â”Š        case \"<\": return context < num;\n+â”Š  â”Š62â”Š        case \"<=\": return context <= num;\n+â”Š  â”Š63â”Š        case \">\": return context > num;\n+â”Š  â”Š64â”Š        case \">=\": return context >= num;\n+â”Š  â”Š65â”Š        default: return context === num;\n+â”Š  â”Š66â”Š      }\n+â”Š  â”Š67â”Š  }\n+â”Š  â”Š68â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -8,6 +8,7 @@\n â”Š 8â”Š 8â”Š    <script type=\"text/javascript\" src=\"/libs/underscore.js\"></script>\n â”Š 9â”Š 9â”Š\n â”Š10â”Š10â”Š    <!-- Scripts -->\n+â”Š  â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/utils.js\"></script>\n â”Š11â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n â”Š12â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/restorable.js\"></script>\n â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/font.js\"></script>\n```\n\n[}]: #\n\nAgain we will delegate the newly created intersection methods in the `Line` class and `Circle` class:\n\n[{]: <helper> (diffStep 5.11)\n\n#### [Step 5.11: Delegate polygon intersection methods](https://github.com/DAB0mB/radial-snake/commit/d42a5d9)\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;geometry&#x2F;circle.js\n```diff\n@@ -83,6 +83,8 @@\n â”Š83â”Š83â”Š      return this.getLineIntersection(shape);\n â”Š84â”Š84â”Š    if (shape instanceof Engine.Geometry.Circle)\n â”Š85â”Š85â”Š      return this.getCircleIntersection(shape);\n+â”Š  â”Š86â”Š    if (shape instanceof Engine.Geometry.Polygon)\n+â”Š  â”Š87â”Š      return this.getPolygonIntersection(shape);\n â”Š86â”Š88â”Š  }\n â”Š87â”Š89â”Š\n â”Š88â”Š90â”Š  // circle - circle intersection method\n```\n```diff\n@@ -164,4 +166,9 @@\n â”Š164â”Š166â”Š\n â”Š165â”Š167â”Š    if (interPoints.length > 0) return interPoints;\n â”Š166â”Š168â”Š  }\n+â”Š   â”Š169â”Š\n+â”Š   â”Š170â”Š  // circle - polygon intersection method\n+â”Š   â”Š171â”Š  getPolygonIntersection(polygon) {\n+â”Š   â”Š172â”Š    return polygon.getCircleIntersection(this);\n+â”Š   â”Š173â”Š  }\n â”Š167â”Š174â”Š};ðŸš«â†µ\n```\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;geometry&#x2F;line.js\n```diff\n@@ -46,6 +46,8 @@\n â”Š46â”Š46â”Š      return this.getLineIntersection(shape);\n â”Š47â”Š47â”Š    if (shape instanceof Engine.Geometry.Circle)\n â”Š48â”Š48â”Š      return this.getCircleIntersection(shape);\n+â”Š  â”Š49â”Š    if (shape instanceof Engine.Geometry.Polygon)\n+â”Š  â”Š50â”Š      return this.getPolygonIntersection(shape);\n â”Š49â”Š51â”Š  }\n â”Š50â”Š52â”Š\n â”Š51â”Š53â”Š  // line - line intersection method\n```\n```diff\n@@ -69,4 +71,9 @@\n â”Š69â”Š71â”Š  getCircleIntersection(circle) {\n â”Š70â”Š72â”Š    return circle.getLineIntersection(this);\n â”Š71â”Š73â”Š  }\n+â”Š  â”Š74â”Š\n+â”Š  â”Š75â”Š  // line - polygon intersection method\n+â”Š  â”Š76â”Š  getPolygonIntersection(polygon) {\n+â”Š  â”Š77â”Š    return polygon.getLineIntersection(this);\n+â”Š  â”Š78â”Š  }\n â”Š72â”Š79â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nNow we will create a some tests to make sure our newly created polygon works properly:\n\n[{]: <helper> (diffStep 5.12)\n\n#### [Step 5.12: Create &#x27;Polygon&#x27; class tests](https://github.com/DAB0mB/radial-snake/commit/f3f890b)\n\n##### Added resources&#x2F;scripts&#x2F;specs&#x2F;engine&#x2F;geometry&#x2F;polygon.js\n```diff\n@@ -0,0 +1,96 @@\n+â”Š  â”Š 1â”Šdescribe(\"Engine.Geometry.Polygon class\", function() {\n+â”Š  â”Š 2â”Š  beforeEach(function() {\n+â”Š  â”Š 3â”Š    this.polygon = new Engine.Geometry.Polygon(\n+â”Š  â”Š 4â”Š      [0, 0, 5, 0],\n+â”Š  â”Š 5â”Š      [5, 0, 5, 5],\n+â”Š  â”Š 6â”Š      [5, 5, 0, 5],\n+â”Š  â”Š 7â”Š      [0, 5, 0, 0]\n+â”Š  â”Š 8â”Š    );\n+â”Š  â”Š 9â”Š  });\n+â”Š  â”Š10â”Š\n+â”Š  â”Š11â”Š  describe(\"hasPoint method\", function() {\n+â”Š  â”Š12â”Š    describe(\"given contained point\", function() {\n+â”Š  â”Š13â”Š      it(\"returns true\", function() {\n+â”Š  â”Š14â”Š        let x = 5;\n+â”Š  â”Š15â”Š        let y = 3;\n+â”Š  â”Š16â”Š        expect(this.polygon.hasPoint(x, y)).toBeTruthy();\n+â”Š  â”Š17â”Š      });\n+â”Š  â”Š18â”Š    });\n+â”Š  â”Š19â”Š\n+â”Š  â”Š20â”Š    describe(\"given outranged point\", function() {\n+â”Š  â”Š21â”Š      it(\"returns false\", function() {\n+â”Š  â”Š22â”Š        let x = 10;\n+â”Š  â”Š23â”Š        let y = 10;\n+â”Š  â”Š24â”Š        expect(this.polygon.hasPoint(x, y)).toBeFalsy();\n+â”Š  â”Š25â”Š      });\n+â”Š  â”Š26â”Š    });\n+â”Š  â”Š27â”Š  });\n+â”Š  â”Š28â”Š\n+â”Š  â”Š29â”Š  describe(\"getLineIntersection method\", function() {\n+â”Š  â”Š30â”Š    describe(\"given intersecting line\", function() {\n+â”Š  â”Š31â”Š      it(\"returns intersection point\", function() {\n+â”Š  â”Š32â”Š        let line = new Engine.Geometry.Line(0, 1, 5, 4);\n+â”Š  â”Š33â”Š\n+â”Š  â”Š34â”Š        expect(this.polygon.getLineIntersection(line)).toEqual([\n+â”Š  â”Š35â”Š          { x: 5, y: 4 },\n+â”Š  â”Š36â”Š          { x: 0, y: 1 }\n+â”Š  â”Š37â”Š        ]);\n+â”Š  â”Š38â”Š      });\n+â”Š  â”Š39â”Š    });\n+â”Š  â”Š40â”Š\n+â”Š  â”Š41â”Š    describe(\"given outranged line\", function() {\n+â”Š  â”Š42â”Š      it(\"returns nothing\", function() {\n+â”Š  â”Š43â”Š        let line = new Engine.Geometry.Line(10, 11, 15, 14);\n+â”Š  â”Š44â”Š\n+â”Š  â”Š45â”Š        expect(this.polygon.getLineIntersection(line)).toBeUndefined();\n+â”Š  â”Š46â”Š      });\n+â”Š  â”Š47â”Š    });\n+â”Š  â”Š48â”Š  });\n+â”Š  â”Š49â”Š\n+â”Š  â”Š50â”Š  describe(\"getCircleIntersection method\", function() {\n+â”Š  â”Š51â”Š    describe(\"given circle with 2 intersection points\", function() {\n+â”Š  â”Š52â”Š      it(\"returns array with intersection points\", function() {\n+â”Š  â”Š53â”Š        let circle = new Engine.Geometry.Circle(0, 0, 2, 0, 2 * Math.PI);\n+â”Š  â”Š54â”Š\n+â”Š  â”Š55â”Š        expect(this.polygon.getCircleIntersection(circle)).toEqual([\n+â”Š  â”Š56â”Š          { x: 2, y: 0 },\n+â”Š  â”Š57â”Š          { x: 0, y: 2 }\n+â”Š  â”Š58â”Š        ]);\n+â”Š  â”Š59â”Š      });\n+â”Š  â”Š60â”Š    });\n+â”Š  â”Š61â”Š\n+â”Š  â”Š62â”Š    describe(\"given circle with 1 intersection points\", function() {\n+â”Š  â”Š63â”Š      it(\"returns array with intersection point\", function() {\n+â”Š  â”Š64â”Š        let circle = new Engine.Geometry.Circle(0, 0, 2, 0, 0.25 * Math.PI);\n+â”Š  â”Š65â”Š\n+â”Š  â”Š66â”Š        expect(this.polygon.getCircleIntersection(circle)).toEqual([\n+â”Š  â”Š67â”Š          { x: 2, y: 0 }\n+â”Š  â”Š68â”Š        ]);\n+â”Š  â”Š69â”Š      });\n+â”Š  â”Š70â”Š    });\n+â”Š  â”Š71â”Š\n+â”Š  â”Š72â”Š    describe(\"given kissing circle\", function() {\n+â”Š  â”Š73â”Š      it(\"returns array with intersection point\", function() {\n+â”Š  â”Š74â”Š        let circle = new Engine.Geometry.Circle(-3, 3, 3, 0, 2 * Math.PI);\n+â”Š  â”Š75â”Š\n+â”Š  â”Š76â”Š        expect(this.polygon.getCircleIntersection(circle)).toEqual([\n+â”Š  â”Š77â”Š          { x: 0, y: 3 }\n+â”Š  â”Š78â”Š        ]);\n+â”Š  â”Š79â”Š      });\n+â”Š  â”Š80â”Š    });\n+â”Š  â”Š81â”Š\n+â”Š  â”Š82â”Š    describe(\"given outer circle\", function() {\n+â”Š  â”Š83â”Š      it(\"returns nothing\", function() {\n+â”Š  â”Š84â”Š        let circle = new Engine.Geometry.Circle(10, 10, 2, 0, 2 * Math.PI);\n+â”Š  â”Š85â”Š        expect(this.polygon.getCircleIntersection(circle)).toBeUndefined();\n+â”Š  â”Š86â”Š      });\n+â”Š  â”Š87â”Š    });\n+â”Š  â”Š88â”Š\n+â”Š  â”Š89â”Š    describe(\"given inner circle\", function() {\n+â”Š  â”Š90â”Š      it(\"nothing\", function() {\n+â”Š  â”Š91â”Š        let circle = new Engine.Geometry.Circle(2.5, 2.5, 2, 0, 2 * Math.PI);\n+â”Š  â”Š92â”Š        expect(this.polygon.getCircleIntersection(circle)).toBeUndefined();\n+â”Š  â”Š93â”Š      });\n+â”Š  â”Š94â”Š    });\n+â”Š  â”Š95â”Š  });\n+â”Š  â”Š96â”Š});ðŸš«â†µ\n```\n\n##### Changed views&#x2F;spec_runner.html\n```diff\n@@ -20,10 +20,12 @@\n â”Š20â”Š20â”Š    <script type=\"text/javascript\" src=\"scripts/namespaces.js\"></script>\n â”Š21â”Š21â”Š    <script type=\"text/javascript\" src=\"scripts/engine/geometry/line.js\"></script>\n â”Š22â”Š22â”Š    <script type=\"text/javascript\" src=\"scripts/engine/geometry/circle.js\"></script>\n+â”Š  â”Š23â”Š    <script type=\"text/javascript\" src=\"scripts/engine/geometry/polygon.js\"></script>\n â”Š23â”Š24â”Š\n â”Š24â”Š25â”Š    <!-- Specs -->\n â”Š25â”Š26â”Š    <script type=\"text/javascript\" src=\"scripts/specs/engine/geometry/line.js\"></script>\n â”Š26â”Š27â”Š    <script type=\"text/javascript\" src=\"scripts/specs/engine/geometry/circle.js\"></script>\n+â”Š  â”Š28â”Š    <script type=\"text/javascript\" src=\"scripts/specs/engine/geometry/polygon.js\"></script>\n â”Š27â”Š29â”Š  </head>\n â”Š28â”Š30â”Š\n â”Š29â”Š31â”Š  <body>\n```\n\n[}]: #\n\nAt last, all the necessary geometry shapes are implemented and ready to use. We will now focus on the snake itself. Since our game can potentially have infinite number of entities, not necessarily just a snake, we will add the a new module under the `Game` namespace called `Entities`:\n\n[{]: <helper> (diffStep 5.13)\n\n#### [Step 5.13: Add &#x27;Entities&#x27; module to &#x27;Game&#x27; namespace](https://github.com/DAB0mB/radial-snake/commit/a0bed8c)\n\n##### Changed resources&#x2F;scripts&#x2F;namespaces.js\n```diff\n@@ -1,4 +1,5 @@\n â”Š1â”Š1â”ŠGame = {\n+â”Š â”Š2â”Š  Entities: {},\n â”Š2â”Š3â”Š  Screens: {}\n â”Š3â”Š4â”Š};\n```\n\n[}]: #\n\nAnd now we can add the `Snake` class:\n\n[{]: <helper> (diffStep 5.14)\n\n#### [Step 5.14: Create &#x27;Snake&#x27; class](https://github.com/DAB0mB/radial-snake/commit/b938ba7)\n\n##### Added resources&#x2F;scripts&#x2F;game&#x2F;entities&#x2F;snake.js\n```diff\n@@ -0,0 +1,234 @@\n+â”Š   â”Š  1â”ŠGame.Entities.Snake = class Snake {\n+â”Š   â”Š  2â”Š  // Represents a snake data-structure which will eventually appear on screen.\n+â”Š   â”Š  3â”Š  // All the properties provided to the constructor are the initial values of\n+â”Š   â”Š  4â”Š  // the snake\n+â”Š   â”Š  5â”Š  constructor(x, y, r, rad, v, color, keyStates, options) {\n+â”Š   â”Š  6â”Š    this.x = x;\n+â”Š   â”Š  7â”Š    this.y = y;\n+â”Š   â”Š  8â”Š    this.r = r;\n+â”Š   â”Š  9â”Š    this.rad = rad;\n+â”Š   â”Š 10â”Š    this.v = v;\n+â”Š   â”Š 11â”Š    this.color = color;\n+â”Š   â”Š 12â”Š    this.keyStates = keyStates;\n+â”Š   â”Š 13â”Š    // A snake is made out of many geometry shapes\n+â”Š   â”Š 14â”Š    this.shapes = [];\n+â”Š   â”Š 15â”Š    // A snake starts with a line\n+â”Š   â”Š 16â”Š    this.currentShape = new Engine.Geometry.Line(x, y, x, y);\n+â”Š   â”Š 17â”Š    this.shapes.push(this.currentShape);\n+â”Š   â”Š 18â”Š    // A score can be provided in case we want to reserve previous scores from\n+â”Š   â”Š 19â”Š    // recent matches\n+â”Š   â”Š 20â”Š    this.score = options.score || 0;\n+â”Š   â”Š 21â”Š\n+â”Š   â”Š 22â”Š    // Custom keys can be specified\n+â”Š   â”Š 23â”Š    if (options.keys && options.keys) {\n+â”Š   â”Š 24â”Š      this.leftKey = options.keys.left;\n+â”Š   â”Š 25â”Š      this.rightKey = options.keys.right;\n+â”Š   â”Š 26â”Š    }\n+â”Š   â”Š 27â”Š    // Left and right arrow keys will be used by default\n+â”Š   â”Š 28â”Š    else {\n+â”Š   â”Š 29â”Š      this.leftKey = 37; // Left arrow\n+â”Š   â”Š 30â”Š      this.rightKey = 39; // Right arrow\n+â”Š   â”Š 31â”Š    }\n+â”Š   â”Š 32â”Š  }\n+â”Š   â”Š 33â”Š\n+â”Š   â”Š 34â”Š  draw(context) {\n+â”Š   â”Š 35â”Š    // Draw all shapes in the shapes array\n+â”Š   â”Š 36â”Š    this.shapes.forEach(shape => {\n+â”Š   â”Š 37â”Š      context.save();\n+â”Š   â”Š 38â”Š      context.strokeStyle = this.color;\n+â”Š   â”Š 39â”Š      context.lineWidth = 3;\n+â”Š   â”Š 40â”Š      context.beginPath();\n+â”Š   â”Š 41â”Š\n+â”Š   â”Š 42â”Š      // Each shape has its own unique drawing method\n+â”Š   â”Š 43â”Š      shape.draw(context);\n+â”Š   â”Š 44â”Š\n+â”Š   â”Š 45â”Š      context.stroke();\n+â”Š   â”Š 46â”Š      context.restore();\n+â”Š   â”Š 47â”Š    });\n+â”Š   â”Š 48â”Š  }\n+â”Š   â”Š 49â”Š\n+â”Š   â”Š 50â”Š  update(span, width, height) {\n+â”Š   â”Š 51â”Š    // Progress made based on elapsed time and velocity\n+â”Š   â”Š 52â”Š    let step = (this.v * span) / 1000;\n+â”Š   â”Š 53â”Š\n+â”Š   â”Š 54â”Š    this.updateShapes(step, width, height);\n+â”Š   â”Š 55â”Š    this.cycleThrough(step, width, height);\n+â”Š   â”Š 56â”Š  }\n+â”Š   â”Š 57â”Š\n+â”Š   â”Š 58â”Š  // Updates shapes array based on progress made\n+â”Š   â”Š 59â”Š  updateShapes(step, width, height, options = {}) {\n+â”Š   â”Š 60â”Š    this.updateCurrentShape(step, options);\n+â”Š   â”Š 61â”Š    this.updateDirection(step, options);\n+â”Š   â”Š 62â”Š  }\n+â”Š   â”Š 63â”Š\n+â”Š   â”Š 64â”Š  // Updates current shape\n+â”Š   â”Š 65â”Š  updateCurrentShape(step, options) {\n+â”Š   â”Š 66â”Š    if (this.currentShape instanceof Engine.Geometry.Line)\n+â”Š   â”Š 67â”Š      return this.updateCurrentLine(options);\n+â”Š   â”Š 68â”Š    if (this.currentShape instanceof Engine.Geometry.Circle)\n+â”Š   â”Š 69â”Š      return this.updateCurrentCircle(options);\n+â”Š   â”Š 70â”Š  }\n+â”Š   â”Š 71â”Š\n+â”Š   â”Š 72â”Š  // Updates current shape in case it is a line\n+â”Š   â”Š 73â”Š  updateCurrentLine(options) {\n+â”Š   â”Š 74â”Š    let lastX = options.lastX || this.x;\n+â”Š   â”Š 75â”Š    let lastY = options.lastY || this.y;\n+â”Š   â”Š 76â”Š    this.x = options.x || this.currentShape.x2;\n+â”Š   â”Š 77â”Š    this.y = options.y || this.currentShape.y2;\n+â”Š   â”Š 78â”Š    this.lastBit = new Engine.Geometry.Line(lastX, lastY, this.x, this.y);\n+â”Š   â”Š 79â”Š  }\n+â”Š   â”Š 80â”Š\n+â”Š   â”Š 81â”Š  // Updates current shape in case it is a circle\n+â”Š   â”Š 82â”Š  updateCurrentCircle(options) {\n+â”Š   â”Š 83â”Š    let lastX = options.lastX || this.currentShape.x;\n+â”Š   â”Š 84â”Š    let lastY = options.lastY || this.currentShape.y;\n+â”Š   â”Š 85â”Š    let lastR = options.lastR || this.currentShape.r;\n+â”Š   â”Š 86â”Š\n+â”Š   â”Š 87â”Š    // Update logic for left rotation\n+â”Š   â”Š 88â”Š    if (this.direction == \"left\") {\n+â”Š   â”Š 89â”Š      let lastRad = this.rad + (0.5 * Math.PI);\n+â”Š   â”Š 90â”Š      let currentShapePoint = this.currentShape.getPoint(this.currentShape.rad1);\n+â”Š   â”Š 91â”Š      this.x = options.x || currentShapePoint.x;\n+â”Š   â”Š 92â”Š      this.y = options.y || currentShapePoint.y;\n+â”Š   â”Š 93â”Š      this.rad = this.currentShape.rad1 - (0.5 * Math.PI);\n+â”Š   â”Š 94â”Š      this.lastBit = new Engine.Geometry.Circle(lastX, lastY, lastR, this.currentShape.rad1, lastRad);\n+â”Š   â”Š 95â”Š    }\n+â”Š   â”Š 96â”Š    // Update logic for right rotation\n+â”Š   â”Š 97â”Š    else {\n+â”Š   â”Š 98â”Š      let lastRad = this.rad - (0.5 * Math.PI);\n+â”Š   â”Š 99â”Š      let currentShapePoint = this.currentShape.getPoint(this.currentShape.rad2);\n+â”Š   â”Š100â”Š      this.x = options.x || currentShapePoint.x;\n+â”Š   â”Š101â”Š      this.y = options.y || currentShapePoint.y;\n+â”Š   â”Š102â”Š      this.rad = this.currentShape.rad2 + (0.5 * Math.PI);\n+â”Š   â”Š103â”Š      this.lastBit = new Engine.Geometry.Circle(lastX, lastY, lastR, lastRad, this.currentShape.rad2);\n+â”Š   â”Š104â”Š    }\n+â”Š   â”Š105â”Š  }\n+â”Š   â”Š106â”Š\n+â”Š   â”Š107â”Š  updateDirection(step, options) {\n+â”Š   â”Š108â”Š    // Update the direction based on pressed key\n+â”Š   â”Š109â”Š    if (this.keyStates.get(this.leftKey))\n+â”Š   â”Š110â”Š      var direction = \"left\";\n+â”Š   â”Š111â”Š    else if (this.keyStates.get(this.rightKey))\n+â”Š   â”Š112â”Š      var direction = \"right\";\n+â”Š   â”Š113â”Š\n+â”Š   â”Š114â”Š    this.changeDirection(step, direction, options);\n+â”Š   â”Š115â”Š    this.continueDirection(step, direction, options);\n+â”Š   â”Š116â”Š  }\n+â”Š   â”Š117â”Š\n+â”Š   â”Š118â”Š  // Change the recent shape type according to the given direction\n+â”Š   â”Š119â”Š  changeDirection(step, direction, options) {\n+â”Š   â”Š120â”Š    // If there is no change in direction, abort, unless we force it\n+â”Š   â”Š121â”Š    if (direction == this.direction && !options.force) return;\n+â”Š   â”Š122â”Š\n+â”Š   â”Š123â”Š    this.direction = direction;\n+â”Š   â”Š124â”Š\n+â”Š   â”Š125â”Š    // This will push a new shape with new properties, based on the direction\n+â”Š   â”Š126â”Š    switch (direction) {\n+â”Š   â”Š127â”Š      case \"left\":\n+â”Š   â”Š128â”Š        var angle = this.rad - (0.5 * Math.PI);\n+â”Š   â”Š129â”Š        var rad = this.rad + (0.5 * Math.PI);\n+â”Š   â”Š130â”Š        var x = this.x + (this.r * Math.cos(angle));\n+â”Š   â”Š131â”Š        var y = this.y + (this.r * Math.sin(angle));\n+â”Š   â”Š132â”Š        this.currentShape = new Engine.Geometry.Circle(x, y, this.r, rad, rad);\n+â”Š   â”Š133â”Š        break;\n+â”Š   â”Š134â”Š      case \"right\":\n+â”Š   â”Š135â”Š        angle = this.rad + (0.5 * Math.PI);\n+â”Š   â”Š136â”Š        rad = this.rad - (0.5 * Math.PI);\n+â”Š   â”Š137â”Š        x = this.x + (this.r * Math.cos(angle));\n+â”Š   â”Š138â”Š        y = this.y + (this.r * Math.sin(angle));\n+â”Š   â”Š139â”Š        this.currentShape = new Engine.Geometry.Circle(x, y, this.r, rad, rad);\n+â”Š   â”Š140â”Š        break;\n+â”Š   â”Š141â”Š      default:\n+â”Š   â”Š142â”Š        this.currentShape = new Engine.Geometry.Line(this.x, this.y, this.x, this.y);\n+â”Š   â”Š143â”Š    }\n+â”Š   â”Š144â”Š\n+â”Š   â”Š145â”Š    this.shapes.push(this.currentShape);\n+â”Š   â”Š146â”Š  }\n+â”Š   â”Š147â”Š\n+â”Š   â”Š148â”Š  // Extend the recent shape based on progress made\n+â”Š   â”Š149â”Š  continueDirection(step, direction) {\n+â”Š   â”Š150â”Š    switch (direction) {\n+â”Š   â”Š151â”Š      case \"left\":\n+â”Š   â”Š152â”Š        this.currentShape.rad1 -= step / this.r;\n+â”Š   â”Š153â”Š        break;\n+â”Š   â”Š154â”Š      case \"right\":\n+â”Š   â”Š155â”Š        this.currentShape.rad2 += step / this.r;\n+â”Š   â”Š156â”Š        break;\n+â”Š   â”Š157â”Š      default:\n+â”Š   â”Š158â”Š        this.currentShape.x2 += step * Math.cos(this.rad);\n+â”Š   â”Š159â”Š        this.currentShape.y2 += step * Math.sin(this.rad);\n+â”Š   â”Š160â”Š    }\n+â”Š   â”Š161â”Š  }\n+â”Š   â”Š162â”Š\n+â”Š   â”Š163â”Š  // Handles case where snake is out limits and we need to render it from\n+â”Š   â”Š164â”Š  // the other side of the canvas\n+â”Š   â”Š165â”Š  cycleThrough(step, width, height) {\n+â”Š   â”Š166â”Š    let intersectionPoint = this.getCanvasIntersection(width, height);\n+â”Š   â”Š167â”Š\n+â”Š   â”Š168â”Š    if (!intersectionPoint) return;\n+â”Š   â”Š169â”Š\n+â”Š   â”Š170â”Š    intersectionPoint = intersectionPoint[0];\n+â”Š   â”Š171â”Š\n+â”Š   â”Š172â”Š    // Re-calculate position based on canvas bounds\n+â”Š   â”Š173â”Š    if (intersectionPoint.x % width == 0)\n+â”Š   â”Š174â”Š      this.x = Utils.mod(this.x - width, width);\n+â”Š   â”Š175â”Š    if (intersectionPoint.y % height == 0)\n+â”Š   â”Š176â”Š      this.y = Utils.mod(this.y - height, height);\n+â”Š   â”Š177â”Š\n+â”Š   â”Š178â”Š    // Update shapes again based on custom properties\n+â”Š   â”Š179â”Š    this.updateShapes(step, width, height, {\n+â”Š   â”Š180â”Š      force: true,\n+â”Š   â”Š181â”Š      lastX: this.x,\n+â”Š   â”Š182â”Š      lastY: this.y,\n+â”Š   â”Š183â”Š      x: this.x,\n+â”Š   â”Š184â”Š      y: this.y\n+â”Š   â”Š185â”Š    });\n+â”Š   â”Š186â”Š  }\n+â”Š   â”Š187â”Š\n+â”Š   â”Š188â”Š  // Gets intersection points between last bit and own shapes\n+â”Š   â”Š189â”Š  getSelfIntersection() {\n+â”Š   â”Š190â”Š    if (this.currentShape instanceof Engine.Geometry.Circle &&\n+â”Š   â”Š191â”Š       Math.abs(this.currentShape.rad1 - this.currentShape.rad2) >= 2 * Math.PI) {\n+â”Š   â”Š192â”Š      if (this.direction == \"left\")\n+â”Š   â”Š193â”Š        var rad = this.currentShape.rad1;\n+â”Š   â”Š194â”Š      else\n+â”Š   â”Š195â”Š        var rad = this.currentShape.rad2;\n+â”Š   â”Š196â”Š\n+â”Š   â”Š197â”Š      return this.currentShape.getPoint(rad);\n+â”Š   â”Š198â”Š    }\n+â”Š   â”Š199â”Š\n+â”Š   â”Š200â”Š    let result;\n+â”Š   â”Š201â”Š\n+â”Š   â”Š202â”Š    this.shapes.slice(0, -2).some(shape =>\n+â”Š   â”Š203â”Š      result = this.lastBit.getIntersection(shape)\n+â”Š   â”Š204â”Š    );\n+â”Š   â”Š205â”Š\n+â”Š   â”Š206â”Š    return result;\n+â”Š   â”Š207â”Š  }\n+â”Š   â”Š208â”Š\n+â”Š   â”Š209â”Š  // Returns intersection points between snakes\n+â”Š   â”Š210â”Š  getSnakeIntersection(snake) {\n+â”Š   â”Š211â”Š    let result;\n+â”Š   â”Š212â”Š\n+â”Š   â”Š213â”Š    snake.shapes.some(shape =>\n+â”Š   â”Š214â”Š      // Only last bit is relevant, if we reached this point it means that\n+â”Š   â”Š215â”Š      // previous intersection will definitely fail\n+â”Š   â”Š216â”Š      result = this.lastBit.getIntersection(shape)\n+â”Š   â”Š217â”Š    );\n+â”Š   â”Š218â”Š\n+â”Š   â”Š219â”Š    return result;\n+â”Š   â”Š220â”Š  }\n+â”Š   â”Š221â”Š\n+â”Š   â”Š222â”Š  // Returns intersection points between snake and canvas\n+â”Š   â”Š223â”Š  getCanvasIntersection(width, height) {\n+â”Š   â”Š224â”Š    // Canvas polygon\n+â”Š   â”Š225â”Š    let canvasPolygon = new Engine.Geometry.Polygon(\n+â”Š   â”Š226â”Š      [0, 0, width, 0],\n+â”Š   â”Š227â”Š      [width, 0, width, height],\n+â”Š   â”Š228â”Š      [width, height, 0, height],\n+â”Š   â”Š229â”Š      [0, height, 0, 0]\n+â”Š   â”Š230â”Š    );\n+â”Š   â”Š231â”Š\n+â”Š   â”Š232â”Š    return canvasPolygon.getIntersection(this.lastBit);\n+â”Š   â”Š233â”Š  }\n+â”Š   â”Š234â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -22,6 +22,7 @@\n â”Š22â”Š22â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/screen.js\"></script>\n â”Š23â”Š23â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/assets_loader.js\"></script>\n â”Š24â”Š24â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n+â”Š  â”Š25â”Š    <script type=\"text/javascript\" src=\"/scripts/game/entities/snake.js\"></script>\n â”Š25â”Š26â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/menu/index.js\"></script>\n â”Š26â”Š27â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/splash/index.js\"></script>\n â”Š27â”Š28â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n```\n\n[}]: #\n\nThis class is titled with most complexity out of everything we did so far in this step. You can follow the code accompanied by comments regard it, but I'd also like to explain the key concepts. As said earlier, the `Snake` is simply made out of shapes; In this case - lines and circles.\n\nThe `draw` method just goes through this array and draws whatever shape it's currently looping through. Regardless of its type, every shape is provided with a `draw` method of its own, all shapes share the same interface, therefore we can just draw them regularly and the snake should be drawn automatically.\n\nThe `update` method updates the last bit only according to its type, the time elapsed and the speed of the snake. For example, the last bit of the snake is a line, and 5 seconds have passed at a speed of 5 meters per second, our line should be extended by 5 meters long. Same principle applies to circle extension only based on radians. The last bit's type might be changed according to the current input; e.g. if the `right` key is held the last bit would turn into a circle, and once released it would turn into a straight line.\n\nNote that besides shapes extension, collision detection should also be made. The embedded is the collision detection between the snake and the canvas, which means that any time the snake collides with the canvas's boundaries the last bit should be redrawn from the opposite side of the canvas. In addition, we've implemented intersection methods for self collision detection and collision detection between rivals, which should be used externally by the hosting screen.\n\nIn the next step we will be implementing the game screen where we will make use of the `Snake` class we've just created, and see how it works in action."
          },
          {
            "manualTitle": "Step 6: Creating a complex game screen with multiple layers",
            "stepRevision": "c27bb0d7806aab70ec489ccd9bbff182d1053dda",
            "manualView": "![snake-demo-game-small](https://cloud.githubusercontent.com/assets/7648874/21074124/8b7cd724-bed7-11e6-9f91-2a211630ac78.gif)\n\nIn this step we will be using the `Snake` class we've just created in the previous step to form the actual game screen - called the `Play` screen. The play screen is a complex screen made out multiple layers as following:\n\n- **`Ready` layer** - Displays a message at the beginning of each match.\n- **`Snake` layer** - Displays the the competitors' snakes.\n- **`Score` layer** - Displays the score board.\n- **`Win` layer** - Displays the winner at the end of each match.\n\nAs we go further with this step, we will give a deeper explanation about each layer and how they interact with each other; As for let's start with the `Play` screen's basis. Regardless of what the `Play` screen should contain at the final result, we want to have the ability to abort the match whenever we press the `Escape` key, therefore, the initial implementation should look like this:\n\n[{]: <helper> (diffStep 6.1)\n\n#### [Step 6.1: Create &#x27;Play&#x27; screen](https://github.com/DAB0mB/radial-snake/commit/e17a45f)\n\n##### Added resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;play&#x2F;index.js\n```diff\n@@ -0,0 +1,14 @@\n+â”Š  â”Š 1â”ŠGame.Screens.Play = class Play extends Engine.Screen {\n+â”Š  â”Š 2â”Š  get events() {\n+â”Š  â”Š 3â”Š    return {\n+â”Š  â”Š 4â”Š      \"keydown\": \"onKeyDown\"\n+â”Š  â”Š 5â”Š    }\n+â”Š  â”Š 6â”Š  }\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Š  onKeyDown() {\n+â”Š  â”Š 9â”Š    // Once escape is pressed, return to main menu screen\n+â”Š  â”Š10â”Š    if (this.keyStates.get(27)) {\n+â”Š  â”Š11â”Š      this.game.changeScreen(Game.Screens.Menu);\n+â”Š  â”Š12â”Š    }\n+â”Š  â”Š13â”Š  }\n+â”Š  â”Š14â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -23,6 +23,7 @@\n â”Š23â”Š23â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/assets_loader.js\"></script>\n â”Š24â”Š24â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š25â”Š25â”Š    <script type=\"text/javascript\" src=\"/scripts/game/entities/snake.js\"></script>\n+â”Š  â”Š26â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/index.js\"></script>\n â”Š26â”Š27â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/menu/index.js\"></script>\n â”Š27â”Š28â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/splash/index.js\"></script>\n â”Š28â”Š29â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n```\n\n[}]: #\n\nNow that we have the `Play` screen, we need to hook it to the `Menu` screen, so whenever we press a key, we will be proceeded to it:\n\n[{]: <helper> (diffStep 6.2)\n\n#### [Step 6.2: Hook &#x27;Play&#x27; screen to &#x27;menu&#x27; screen](https://github.com/DAB0mB/radial-snake/commit/495b9ee)\n\n##### Changed resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;menu&#x2F;index.js\n```diff\n@@ -1,4 +1,10 @@\n â”Š 1â”Š 1â”ŠGame.Screens.Menu = class Menu extends Engine.Screen {\n+â”Š  â”Š 2â”Š  get events() {\n+â”Š  â”Š 3â”Š    return {\n+â”Š  â”Š 4â”Š      \"keydown\": \"onKeyDown\"\n+â”Š  â”Š 5â”Š    }\n+â”Š  â”Š 6â”Š  }\n+â”Š  â”Š 7â”Š\n â”Š 2â”Š 8â”Š  initialize() {\n â”Š 3â”Š 9â”Š    // Initialize snake logo sprite\n â”Š 4â”Š10â”Š    this.logoSprite = new Engine.Sprite(this.assets.logoTexture);\n```\n```diff\n@@ -40,10 +46,18 @@\n â”Š40â”Š46â”Š  }\n â”Š41â”Š47â”Š\n â”Š42â”Š48â”Š  update(span) {\n-â”Š43â”Š  â”Š    this.instructionsAnim.update(span);\n+â”Š  â”Š49â”Š    // On key press, proceed to play screen\n+â”Š  â”Š50â”Š    if (this.keyPressed) {\n+â”Š  â”Š51â”Š      this.game.changeScreen(Game.Screens.Play);\n+â”Š  â”Š52â”Š    }\n+â”Š  â”Š53â”Š    // Else, just update animation\n+â”Š  â”Š54â”Š    else {\n+â”Š  â”Š55â”Š      this.instructionsAnim.update(span);\n+â”Š  â”Š56â”Š    }\n â”Š44â”Š57â”Š  }\n â”Š45â”Š58â”Š\n-â”Š46â”Š  â”Š  update(span) {\n-â”Š47â”Š  â”Š    this.instructionsAnim.update(span);\n+â”Š  â”Š59â”Š  // Register key press\n+â”Š  â”Š60â”Š  onKeyDown(e) {\n+â”Š  â”Š61â”Š    this.keyPressed = true;\n â”Š48â”Š62â”Š  }\n â”Š49â”Š63â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nBy now there shouldn't be anything special. Once you're at the main menu, just press a key as instructed, and you shall see a black screen, which is actually the `Play` screen we've just created; And once you'll press the `Escape` key, you should be receded to the main menu.\n\nThe next stage would be displaying a `Ready` message on the screen, and whenever a key is pressed, the message should fade away using a key-frame animation, and the match should start in the background:\n\n[{]: <helper> (diffStep 6.3)\n\n#### [Step 6.3: Create &#x27;Ready&#x27; layer](https://github.com/DAB0mB/radial-snake/commit/551962d)\n\n##### Added resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;play&#x2F;ready.js\n```diff\n@@ -0,0 +1,59 @@\n+â”Š  â”Š 1â”ŠGame.Screens.Play.Ready = class Ready extends Engine.Layer {\n+â”Š  â”Š 2â”Š  get events() {\n+â”Š  â”Š 3â”Š    return {\n+â”Š  â”Š 4â”Š      \"keydown\": \"onKeyDown\"\n+â”Š  â”Š 5â”Š    };\n+â”Š  â”Š 6â”Š  }\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Š  constructor(screen, snakes) {\n+â”Š  â”Š 9â”Š    super(screen);\n+â”Š  â”Š10â”Š\n+â”Š  â”Š11â”Š    this.snakes = snakes;\n+â”Š  â”Š12â”Š\n+â”Š  â”Š13â”Š    // Create \"ready\" sprite and set its properties\n+â”Š  â”Š14â”Š    let readyTexture = this.assets.minecraftiaFont.createTexture(\"Ready\");\n+â”Š  â”Š15â”Š    let readySprite = new Engine.Sprite(readyTexture);\n+â”Š  â”Š16â”Š    readySprite.align = \"center\";\n+â”Š  â”Š17â”Š    readySprite.setPercentage(\"width\", this.width, 15, \"height\");\n+â”Š  â”Š18â”Š\n+â”Š  â”Š19â”Š    // Create fade out animation for \"ready\" sprite\n+â”Š  â”Š20â”Š    this.readyAnim = new Engine.Animations.Keyframe(readySprite, [\n+â”Š  â”Š21â”Š      {\n+â”Š  â”Š22â”Š        x: this.width / 2,\n+â”Š  â”Š23â”Š        y: this.height / 2,\n+â”Š  â”Š24â”Š        opacity: 1,\n+â”Š  â”Š25â”Š        frame: 0\n+â”Š  â”Š26â”Š      },\n+â”Š  â”Š27â”Š      {\n+â”Š  â”Š28â”Š        y: this.height / 3,\n+â”Š  â”Š29â”Š        opacity: 0,\n+â”Š  â”Š30â”Š        frame: 700\n+â”Š  â”Š31â”Š      }\n+â”Š  â”Š32â”Š    ]);\n+â”Š  â”Š33â”Š  }\n+â”Š  â”Š34â”Š\n+â”Š  â”Š35â”Š  draw(context) {\n+â”Š  â”Š36â”Š    this.readyAnim.draw(context);\n+â”Š  â”Š37â”Š  }\n+â”Š  â”Š38â”Š\n+â”Š  â”Š39â”Š  update(span) {\n+â”Š  â”Š40â”Š    if (!this.ready) return;\n+â”Š  â”Š41â”Š\n+â”Š  â”Š42â”Š    if (this.readyAnim.playing) {\n+â”Š  â”Š43â”Š      this.readyAnim.update(span);\n+â”Š  â”Š44â”Š    }\n+â”Š  â”Š45â”Š    // Once animation is finished, dispose layer\n+â”Š  â”Š46â”Š    else {\n+â”Š  â”Š47â”Š      this.screen.removeLayer(this);\n+â”Š  â”Š48â”Š    }\n+â”Š  â”Š49â”Š  }\n+â”Š  â”Š50â”Š\n+â”Š  â”Š51â”Š  onKeyDown() {\n+â”Š  â”Š52â”Š    // One time event\n+â”Š  â”Š53â”Š    this.disposeEventListeners()\n+â”Š  â”Š54â”Š\n+â”Š  â”Š55â”Š    // This will start playing the animation\n+â”Š  â”Š56â”Š    this.ready = true;\n+â”Š  â”Š57â”Š    this.readyAnim.play();\n+â”Š  â”Š58â”Š  }\n+â”Š  â”Š59â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -24,6 +24,7 @@\n â”Š24â”Š24â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š25â”Š25â”Š    <script type=\"text/javascript\" src=\"/scripts/game/entities/snake.js\"></script>\n â”Š26â”Š26â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/index.js\"></script>\n+â”Š  â”Š27â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/ready.js\"></script>\n â”Š27â”Š28â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/menu/index.js\"></script>\n â”Š28â”Š29â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/splash/index.js\"></script>\n â”Š29â”Š30â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n```\n\n[}]: #\n\nIn order to hook the `Ready` layer to the `Play` screen, we will just push a new instance of it to the layers stack, using the screen's `appendLayer` method. Note that the order of the layer is super critic! Since if we push a new layer it means it will be drawn on top of any previous layer. To \"shift\" a layer to the layers stack, we can simply use the `prependLayer` method instead. Without further due, this is how our hook should look like:\n\n[{]: <helper> (diffStep 6.4)\n\n#### [Step 6.4: Hook &#x27;Ready&#x27; layer to &#x27;Play&#x27; screen](https://github.com/DAB0mB/radial-snake/commit/b461464)\n\n##### Changed resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;play&#x2F;index.js\n```diff\n@@ -5,6 +5,11 @@\n â”Š 5â”Š 5â”Š    }\n â”Š 6â”Š 6â”Š  }\n â”Š 7â”Š 7â”Š\n+â”Š  â”Š 8â”Š  // The ready screen will be the initial screen\n+â”Š  â”Š 9â”Š  initialize(game, snakes) {\n+â”Š  â”Š10â”Š    this.appendLayer(Game.Screens.Play.Ready, snakes);\n+â”Š  â”Š11â”Š  }\n+â”Š  â”Š12â”Š\n â”Š 8â”Š13â”Š  onKeyDown() {\n â”Š 9â”Š14â”Š    // Once escape is pressed, return to main menu screen\n â”Š10â”Š15â”Š    if (this.keyStates.get(27)) {\n```\n\n[}]: #\n\nNow if you'll launch the game and start a new match, you should see a white `Ready` message in the middle of the screen. Up next, would be the `Snake` layer, which will simply initialize 2 new `Snake` instances, and take care of drawing and updating them:\n\n[{]: <helper> (diffStep 6.5)\n\n#### [Step 6.5: Create &#x27;snake&#x27; layer](https://github.com/DAB0mB/radial-snake/commit/a36d7f2)\n\n##### Added resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;play&#x2F;snake.js\n```diff\n@@ -0,0 +1,79 @@\n+â”Š  â”Š 1â”ŠGame.Screens.Play.Snake = class Snake extends Engine.Layer {\n+â”Š  â”Š 2â”Š  constructor(screen, snakes = []) {\n+â”Š  â”Š 3â”Š    super(screen);\n+â”Š  â”Š 4â”Š\n+â”Š  â”Š 5â”Š    // Red snake\n+â”Š  â”Š 6â”Š    this.snakes = [\n+â”Š  â”Š 7â”Š      new Game.Entities.Snake(\n+â”Š  â”Š 8â”Š        this.width / 4,\n+â”Š  â”Š 9â”Š        this.height / 4,\n+â”Š  â”Š10â”Š        50,\n+â”Š  â”Š11â”Š        Math.PI / 4,\n+â”Š  â”Š12â”Š        100,\n+â”Š  â”Š13â”Š        \"FireBrick\",\n+â”Š  â”Š14â”Š        this.keyStates,\n+â”Š  â”Š15â”Š        {\n+â”Š  â”Š16â”Š          // Use score from previous matches\n+â”Š  â”Š17â”Š          score: snakes[0] && snakes[0].score,\n+â”Š  â”Š18â”Š          keys: {\n+â”Š  â”Š19â”Š            left: 37, // Left key\n+â”Š  â”Š20â”Š            right: 39 // RIght key\n+â”Š  â”Š21â”Š        }\n+â”Š  â”Š22â”Š      }),\n+â”Š  â”Š23â”Š\n+â”Š  â”Š24â”Š      // Blue snake\n+â”Š  â”Š25â”Š      new Game.Entities.Snake(\n+â”Š  â”Š26â”Š        (this.width / 4) * 3,\n+â”Š  â”Š27â”Š        (this.height / 4) * 3,\n+â”Š  â”Š28â”Š        50,\n+â”Š  â”Š29â”Š        (-Math.PI / 4) * 3,\n+â”Š  â”Š30â”Š        100,\n+â”Š  â”Š31â”Š        \"DodgerBlue\",\n+â”Š  â”Š32â”Š        this.keyStates,\n+â”Š  â”Š33â”Š        {\n+â”Š  â”Š34â”Š          score: snakes[1] && snakes[1].score,\n+â”Š  â”Š35â”Š          keys: {\n+â”Š  â”Š36â”Š            left: 65, // 'a' key\n+â”Š  â”Š37â”Š            right: 68 // 'b' key\n+â”Š  â”Š38â”Š        }\n+â”Š  â”Š39â”Š      })\n+â”Š  â”Š40â”Š    ];\n+â”Š  â”Š41â”Š  }\n+â”Š  â”Š42â”Š\n+â”Š  â”Š43â”Š  draw(context) {\n+â”Š  â”Š44â”Š    // Draw each snake in the snakes array\n+â”Š  â”Š45â”Š    this.snakes.forEach(snake => snake.draw(context));\n+â”Š  â”Š46â”Š  }\n+â”Š  â”Š47â”Š\n+â”Š  â”Š48â”Š  update(span) {\n+â”Š  â”Š49â”Š    if (!this.snakes.length) return;\n+â”Š  â”Š50â”Š\n+â”Š  â”Š51â”Š    // Storing original snakes array for future use, since it might get changed\n+â”Š  â”Š52â”Š    let snakes = this.snakes.slice();\n+â”Š  â”Š53â”Š\n+â”Š  â”Š54â”Š    snakes.forEach((snake, index) => {\n+â”Š  â”Š55â”Š      snake.update(span, this.width, this.height);\n+â”Š  â”Š56â”Š      // Disqualify if intersected with self\n+â”Š  â”Š57â”Š      if (snake.getSelfIntersection()) return this.snakes.splice(index, 1);\n+â”Š  â”Š58â”Š\n+â”Š  â”Š59â”Š      snakes.forEach((opponent) => {\n+â”Š  â”Š60â”Š        // Don't scan for intersection with self, obviously this will always be true\n+â”Š  â”Š61â”Š        if (opponent === snake) return;\n+â”Š  â”Š62â”Š        // Disqualify if intersected with opponent\n+â”Š  â”Š63â”Š        if (snake.getSnakeIntersection(opponent)) this.snakes.splice(index, 1);\n+â”Š  â”Š64â”Š      });\n+â”Š  â”Š65â”Š    });\n+â”Š  â”Š66â”Š\n+â”Š  â”Š67â”Š    // There can be only one winner, or a tie (very rare, most likely not to happen)\n+â”Š  â”Š68â”Š    // If the match is already finished, skip the next steps since they are not relevant\n+â”Š  â”Š69â”Š    if (this.snakes.length > 1 || this.matchFinished) return;\n+â”Š  â”Š70â”Š\n+â”Š  â”Š71â”Š    // The winner is the \"last snake standing\"\n+â”Š  â”Š72â”Š    let winner = this.snakes[0];\n+â”Š  â”Š73â”Š    // If this is not a tie, which is a very rare case, increase the winner's score\n+â”Š  â”Š74â”Š    if (winner) winner.score++;\n+â”Š  â”Š75â”Š\n+â”Š  â”Š76â”Š    // Indicates whether we should update the score counter or not\n+â”Š  â”Š77â”Š    this.matchFinished = true;\n+â”Š  â”Š78â”Š  }\n+â”Š  â”Š79â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -24,6 +24,7 @@\n â”Š24â”Š24â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š25â”Š25â”Š    <script type=\"text/javascript\" src=\"/scripts/game/entities/snake.js\"></script>\n â”Š26â”Š26â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/index.js\"></script>\n+â”Š  â”Š27â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/snake.js\"></script>\n â”Š27â”Š28â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/ready.js\"></script>\n â”Š28â”Š29â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/menu/index.js\"></script>\n â”Š29â”Š30â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/splash/index.js\"></script>\n```\n\n[}]: #\n\nOnce pressing a key in the `Ready` layer, not only we want to display an animation, but we also want the match to start in the background, thus, we gonna push a new instance of the `Snake` layer we've just created like so:\n\n[{]: <helper> (diffStep 6.6)\n\n#### [Step 6.6: Hook &#x27;snake&#x27; layer to &#x27;ready&#x27; layer](https://github.com/DAB0mB/radial-snake/commit/982db7b)\n\n##### Changed resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;play&#x2F;ready.js\n```diff\n@@ -55,5 +55,8 @@\n â”Š55â”Š55â”Š    // This will start playing the animation\n â”Š56â”Š56â”Š    this.ready = true;\n â”Š57â”Š57â”Š    this.readyAnim.play();\n+â”Š  â”Š58â”Š\n+â”Š  â”Š59â”Š    // Start the game in the background\n+â”Š  â”Š60â”Š    this.screen.prependLayer(Game.Screens.Play.Snake, this.snakes);\n â”Š58â”Š61â”Š  }\n â”Š59â”Š62â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nNote that the layer is pushed when the animation starts and not once finished; This would give a nice smooth feeling to our game-flow. If you'll test out the game, you would discover that the match is actually playable! The first snake (Red) snake should be controlled by the arrow keys, and the second snake (Blue) should be controlled by the letter keys `a`, `s`, `d` and `w`. So far, the snakes function great, but you can probably tell that whenever a match is finished, it feels a bit dull. There's no indication of winning, and there's no score board to present the score of each competitor, which brings us to the next stage - Implementing the `Score` layer.\n\nThe `Score` layer is a simple layer which takes the 2 snakes as a parameter and displays their scores at the top of the screen:\n\n[{]: <helper> (diffStep 6.7)\n\n#### [Step 6.7: Create &#x27;Score&#x27; layer](https://github.com/DAB0mB/radial-snake/commit/6ec4cac)\n\n##### Added resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;play&#x2F;score.js\n```diff\n@@ -0,0 +1,66 @@\n+â”Š  â”Š 1â”ŠGame.Screens.Play.Score = class Score extends Engine.Layer {\n+â”Š  â”Š 2â”Š  constructor(screen, snakes) {\n+â”Š  â”Š 3â”Š    super(screen);\n+â”Š  â”Š 4â”Š\n+â”Š  â”Š 5â”Š    this.snakes = snakes;\n+â”Š  â”Š 6â”Š    this.scoreSprites = [];\n+â”Š  â”Š 7â”Š    this.scores = [];\n+â”Š  â”Š 8â”Š\n+â”Š  â”Š 9â”Š    // It's important to match indexes to each snake since the number of snakes\n+â”Š  â”Š10â”Š    // can be reduced along the way as we play\n+â”Š  â”Š11â”Š    snakes.forEach((snake, index) => {\n+â”Š  â”Š12â”Š      snake.index = index;\n+â”Š  â”Š13â”Š    });\n+â”Š  â”Š14â”Š  }\n+â”Š  â”Š15â”Š\n+â”Š  â”Š16â”Š  draw(context) {\n+â”Š  â”Š17â”Š    this.scoreSprites.forEach((scoreSprite) => {\n+â”Š  â”Š18â”Š      scoreSprite.draw(context);\n+â”Š  â”Š19â”Š    });\n+â”Š  â”Š20â”Š  }\n+â”Š  â”Š21â”Š\n+â”Š  â”Š22â”Š  update(span) {\n+â”Š  â”Š23â”Š    this.snakes.forEach(snake => {\n+â”Š  â”Š24â”Š      let index = snake.index;\n+â”Š  â”Š25â”Š      if (this.scores[index] == snake.score) return;\n+â”Š  â”Š26â”Š\n+â”Š  â”Š27â”Š      // The sprite might be changed along the way so it's important to recreate it\n+â”Š  â”Š28â”Š      // over and over again. If no change was made the cache will be used by the engine\n+â”Š  â”Š29â”Š      this.scoreSprites[index] = this.createScoreSprite(snake);\n+â”Š  â”Š30â”Š      this.scores[index] = snake.score;\n+â”Š  â”Š31â”Š    });\n+â”Š  â”Š32â”Š  }\n+â”Š  â”Š33â”Š\n+â”Š  â”Š34â”Š  createScoreSprite(snake) {\n+â”Š  â”Š35â”Š    let minecraftiaFont = this.assets.minecraftiaFont;\n+â”Š  â”Š36â”Š    minecraftiaFont.save();\n+â”Š  â”Š37â”Š    minecraftiaFont.color = snake.color;\n+â”Š  â”Š38â”Š\n+â”Š  â”Š39â”Š    // Create a score sprite for the snake\n+â”Š  â”Š40â”Š    let scoreTexture = minecraftiaFont.createTexture(`${snake.score}`, {\n+â”Š  â”Š41â”Š      noOffsets: true,\n+â”Š  â”Š42â”Š      noSpaces: true\n+â”Š  â”Š43â”Š    });\n+â”Š  â”Š44â”Š\n+â”Š  â”Š45â”Š    let scoreSprite = new Engine.Sprite(scoreTexture);\n+â”Š  â”Š46â”Š\n+â”Š  â”Š47â”Š    // Size of score board is dynamic to screen size\n+â”Š  â”Š48â”Š    scoreSprite.setPercentage(\"width\", this.width, 4, \"height\");\n+â”Š  â”Š49â”Š\n+â”Š  â”Š50â”Š    // Set alignment modes.\n+â”Š  â”Š51â”Š    // Once we add more snakes we should add more cases here\n+â”Š  â”Š52â”Š    switch (snake.index) {\n+â”Š  â”Š53â”Š      case 0:\n+â”Š  â”Š54â”Š        scoreSprite.align = \"top-left\";\n+â”Š  â”Š55â”Š        break;\n+â”Š  â”Š56â”Š      case 1:\n+â”Š  â”Š57â”Š        scoreSprite.align = \"top-right\";\n+â”Š  â”Š58â”Š        scoreSprite.x = this.width;\n+â”Š  â”Š59â”Š        break;\n+â”Š  â”Š60â”Š    }\n+â”Š  â”Š61â”Š\n+â”Š  â”Š62â”Š    // Restore the font to its original color\n+â”Š  â”Š63â”Š    minecraftiaFont.restore();\n+â”Š  â”Š64â”Š    return scoreSprite;\n+â”Š  â”Š65â”Š  }\n+â”Š  â”Š66â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -24,6 +24,7 @@\n â”Š24â”Š24â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š25â”Š25â”Š    <script type=\"text/javascript\" src=\"/scripts/game/entities/snake.js\"></script>\n â”Š26â”Š26â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/index.js\"></script>\n+â”Š  â”Š27â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/score.js\"></script>\n â”Š27â”Š28â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/snake.js\"></script>\n â”Š28â”Š29â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/ready.js\"></script>\n â”Š29â”Š30â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/menu/index.js\"></script>\n```\n\n[}]: #\n\n> Note that the current score board is suitable for two players, but can easily be modified to support as much players as you want if done correctly.\n\nThe `Score` board should be appended to the layers stack as soon as the `Snake` layers is initialized, so it would be available to us once the match is started:\n\n[{]: <helper> (diffStep 6.8)\n\n#### [Step 6.8: Hook &#x27;Score&#x27; layer to &#x27;Snake&#x27; layer](https://github.com/DAB0mB/radial-snake/commit/feb4a0b)\n\n##### Changed resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;play&#x2F;snake.js\n```diff\n@@ -38,6 +38,9 @@\n â”Š38â”Š38â”Š        }\n â”Š39â”Š39â”Š      })\n â”Š40â”Š40â”Š    ];\n+â”Š  â”Š41â”Š\n+â”Š  â”Š42â”Š    // Show score board for newly created snakes\n+â”Š  â”Š43â”Š    screen.appendLayer(Game.Screens.Play.Score, this.snakes);\n â”Š41â”Š44â”Š  }\n â”Š42â”Š45â”Š\n â”Š43â”Š46â”Š  draw(context) {\n```\n\n[}]: #\n\nNow we're one layer further from completing the `Play` screen, the only thing missing is the `Win` layer, which should present the winner once the match is finished:\n\n[{]: <helper> (diffStep 6.9)\n\n#### [Step 6.9: Create &#x27;Win&#x27; layer](https://github.com/DAB0mB/radial-snake/commit/3476384)\n\n##### Added resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;play&#x2F;win.js\n```diff\n@@ -0,0 +1,43 @@\n+â”Š  â”Š 1â”ŠGame.Screens.Play.Win = class Win extends Engine.Layer {\n+â”Š  â”Š 2â”Š  constructor(screen, snakes, winner) {\n+â”Š  â”Š 3â”Š    super(screen);\n+â”Š  â”Š 4â”Š\n+â”Š  â”Š 5â”Š    this.snakes = snakes;\n+â”Š  â”Š 6â”Š    this.winner = winner;\n+â”Š  â”Š 7â”Š    // ttl stands for \"time to live\", which means, this layer is going to be\n+â”Š  â”Š 8â”Š    // disposed after 3 seconds\n+â”Š  â”Š 9â”Š    this.ttl = 3000;\n+â”Š  â”Š10â”Š\n+â”Š  â”Š11â”Š    // If there is a winner\n+â”Š  â”Š12â”Š    if (this.winner) {\n+â”Š  â”Š13â”Š      // Message could be something like \"RED SNAKE WINS\"\n+â”Š  â”Š14â”Š      var text = `${this.winner.color.toUpperCase()} SNAKE WINS`;\n+â”Š  â”Š15â”Š      var percent = 40;\n+â”Š  â”Š16â”Š    }\n+â”Š  â”Š17â”Š    // If there is a tie\n+â”Š  â”Š18â”Š    else {\n+â”Š  â”Š19â”Š      var text = 'TIE';\n+â”Š  â”Š20â”Š      var percent = 15;\n+â”Š  â”Š21â”Š    }\n+â”Š  â”Š22â”Š\n+â”Š  â”Š23â”Š    // Create winner sprite and set its properties\n+â”Š  â”Š24â”Š    let winnerTexture = this.assets.minecraftiaFont.createTexture(text);\n+â”Š  â”Š25â”Š    this.winnerSprite = new Engine.Sprite(winnerTexture);\n+â”Š  â”Š26â”Š    this.winnerSprite.align = \"center\";\n+â”Š  â”Š27â”Š    this.winnerSprite.setPercentage(\"width\", this.width, percent, \"height\");\n+â”Š  â”Š28â”Š    this.winnerSprite.x = this.width / 2;\n+â”Š  â”Š29â”Š    this.winnerSprite.y = this.height / 2;\n+â”Š  â”Š30â”Š  }\n+â”Š  â”Š31â”Š\n+â”Š  â”Š32â”Š  draw(context) {\n+â”Š  â”Š33â”Š    this.winnerSprite.draw(context);\n+â”Š  â”Š34â”Š  }\n+â”Š  â”Š35â”Š\n+â”Š  â”Š36â”Š  update(span) {\n+â”Š  â”Š37â”Š    // If limit not yet reached, abort\n+â”Š  â”Š38â”Š    if (this.age < this.ttl) return;\n+â”Š  â”Š39â”Š\n+â”Š  â”Š40â”Š    // Show \"ready\" message all over again, only this time use the updated score board\n+â”Š  â”Š41â”Š    this.screen.game.changeScreen(Game.Screens.Play, this.snakes);\n+â”Š  â”Š42â”Š  }\n+â”Š  â”Š43â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -24,6 +24,7 @@\n â”Š24â”Š24â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š25â”Š25â”Š    <script type=\"text/javascript\" src=\"/scripts/game/entities/snake.js\"></script>\n â”Š26â”Š26â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/index.js\"></script>\n+â”Š  â”Š27â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/win.js\"></script>\n â”Š27â”Š28â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/score.js\"></script>\n â”Š28â”Š29â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/snake.js\"></script>\n â”Š29â”Š30â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/ready.js\"></script>\n```\n\n[}]: #\n\nNote how we use the `changeScreen` method once the `Win` layer has reached its age limit (Time to live, aka `ttl`); This would clear the layers stack and restart the `Play` screen, so we can start a new match all-over, only this time we will pass the `Snake` instances to reserve the original scores. The `Win` layer should be presented whenever a collision has been detected between the snakes:\n\n[{]: <helper> (diffStep 6.1)\n\n#### [Step 6.1: Create &#x27;Play&#x27; screen](https://github.com/DAB0mB/radial-snake/commit/e17a45f)\n\n##### Added resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;play&#x2F;index.js\n```diff\n@@ -0,0 +1,14 @@\n+â”Š  â”Š 1â”ŠGame.Screens.Play = class Play extends Engine.Screen {\n+â”Š  â”Š 2â”Š  get events() {\n+â”Š  â”Š 3â”Š    return {\n+â”Š  â”Š 4â”Š      \"keydown\": \"onKeyDown\"\n+â”Š  â”Š 5â”Š    }\n+â”Š  â”Š 6â”Š  }\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Š  onKeyDown() {\n+â”Š  â”Š 9â”Š    // Once escape is pressed, return to main menu screen\n+â”Š  â”Š10â”Š    if (this.keyStates.get(27)) {\n+â”Š  â”Š11â”Š      this.game.changeScreen(Game.Screens.Menu);\n+â”Š  â”Š12â”Š    }\n+â”Š  â”Š13â”Š  }\n+â”Š  â”Š14â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -23,6 +23,7 @@\n â”Š23â”Š23â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/assets_loader.js\"></script>\n â”Š24â”Š24â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š25â”Š25â”Š    <script type=\"text/javascript\" src=\"/scripts/game/entities/snake.js\"></script>\n+â”Š  â”Š26â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/index.js\"></script>\n â”Š26â”Š27â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/menu/index.js\"></script>\n â”Š27â”Š28â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/splash/index.js\"></script>\n â”Š28â”Š29â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n```\n\n[}]: #\n\nThat's it folks, the `Play` screen is finished, and you can play as much matches as you'd feel like.\n\nAlthough the game is finished, it can still be optimized using `C++`. To discover more on hooking efficiency and how we can hook `C++` to the browser, see the next step."
          },
          {
            "manualTitle": "Step 7: Bonus! Re-implementing geometry in C++",
            "stepRevision": "cea4cffcc2f5e801020ed13ef8f1edde608c85f3",
            "manualView": "> This step is part of a bigger tutorial series where we learn how to create a game engine and implement a Tron-style game in JavaScript. The base project for the following step is available [here](https://github.com/DAB0mB/radial-snake/tree/step6).\n\nSo far I covered up pretty much everything I planned. I showed you how to create a game engine, including a font generator, an animation player and a screening system. On top of that, we've learned how to structure and organize our code well, so if in the future we'd like to extend our game by adding more screens or capabilities, we can do that with ease. Indeed, we've went through lots of great stuff, and if you've reached this point I give you my thumbs up. If so far this wasn't enough, in this step we will be focusing on optimization, and making our game engine run faster (a lot, faster). Obviously, when talking about optimizations, the first thing you would probably think of is how we can make our algorithms efficient by using minimum number of operations. While this is true, we will be actually focusing on optimizing our code using C++.\n\nUnlike JavaScript, which is a dynamic scripting file executed by an interpreter, C++ is a general purpose language which compiles into executables. Naturally, executables are much faster than scripts, since they don't have to be interpreted, and they can approach the hardware and memory much faster. In C++, we have to explicitly define our data-types, meaning that variables don't have to be parsed during run-time. While explicit variables definition is C++'s biggest drawback, it's also one of its biggest advantages. The mere fact that variables can be handled much faster, makes code much more efficient.\n\nAccordingly, we can conclude that the programming language we're using plays a very important role when it comes to efficiency. So how exactly are we going to integrate C++ into the browser? We're going to do that by using a compiler called - [Emscripten](http://kripken.github.io/emscripten-site/).\n\n![emscripten](https://cloud.githubusercontent.com/assets/7648874/22675449/ee6d7e9c-eccc-11e6-9570-1dd5d982ee66.png)\n\nEmscripten is an Open Source [LLVM](https://en.wikipedia.org/wiki/LLVM) to JavaScript compiler. Using Emscripten you can:\n\n- Compile C and C++ code into JavaScript\n- Compile any other code that can be translated into LLVM bitcode into JavaScript.\n- Compile the C/C++ runtimes of other languages into JavaScript, and then run code in those other languages in an indirect way (this has been done for Python and Lua)!\n\nLLVM is a library that is used to construct, optimize and produce intermediate and/or binary machine code. LLVM can be used as a compiler framework, where you provide the \"front end\" (parser and lexer) and the \"back end\" (code that converts LLVM's representation to actual machine code). LLVM can also act as a JIT compiler - it has support for x86/x86_64 and PPC/PPC64 assembly generation with fast code optimizations aimed for compilation speed.\n\nEmscripten operates by taking LLVM code and converting it into a subset of JavaScript called asm.js that can run anywhere that JavaScript can run (usually the browser, but also Node.js, etc.) and is easy for browsers to optimize. This means that you can basically write web applications in any language that has an LLVM compiler.\n\n![emscripten-flow](https://cloud.githubusercontent.com/assets/7648874/22675751/b244b76c-ecce-11e6-917e-f7039ed4b340.png)\n\nIn order to use Emscripten you will first have to install it. I recommend you to follow Emscripten's official installation instructions at their website over [here](https://kripken.github.io/emscripten-site/docs/getting_started/downloads.html). Installing Emscripten might be a bit tiring for some, I know for me it was, but if you're hyped about writing native code in the browser as much as I do, take as much time as needed to install it, and bare with me.\n\nAssuming that you have Emscripten installed, we can get right to business. The goal for this step is to re-implement our geometry namespace in C++, and to be more specific, the circle class and line class. We will start by creating an entry file for our C++ code under the path `resources/cpp/src/index.cpp`:\n\n    $ mkdir resources/cpp\n    $ mkdir resources/cpp/src\n    $ touch resources/cpp/src/index.cpp\n\nFrom now on, every C++ file that we would like to run in the browser should be included in the `index.cpp` file we've just created, otherwise it's not going to appear anywhere. The first stage for re-implementing our geometry would be re-writing the utility module, since our geometry is heavily based on it; Therefore the firs inclusion in our `index.cpp` file would be the following:\n\n[{]: <helper> (diffStep 7.1)\n\n#### [Step 7.1: Add CPP entry script](https://github.com/DAB0mB/radial-snake/commit/2f35323)\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;index.cpp\n```diff\n@@ -0,0 +1 @@\n+â”Š â”Š1â”Š#include \"utils.cpp\"ðŸš«â†µ\n```\n\n[}]: #\n\nFollowing that, we will create the `utils.cpp` module included above, which is a direct translation from C++ to JavaScript for the `utils.js` we've created earlier in this tutorial.\n\n[{]: <helper> (diffStep 7.2)\n\n#### [Step 7.2: Add base utility CPP module](https://github.com/DAB0mB/radial-snake/commit/6dba512)\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;utils.cpp\n```diff\n@@ -0,0 +1,73 @@\n+â”Š  â”Š 1â”Š#include <cfloat>\n+â”Š  â”Š 2â”Š#include <cmath>\n+â”Š  â”Š 3â”Š#include <string>\n+â”Š  â”Š 4â”Š#include \"utils.h\"\n+â”Š  â”Š 5â”Š\n+â”Š  â”Š 6â”Šnamespace utils {\n+â”Š  â”Š 7â”Š  // Fixed modulo method which can calculate modulo of negative numbers properly\n+â”Š  â”Š 8â”Š  // e.g. (-803).mod(800) returns 797\n+â”Š  â”Š 9â”Š  double mod(double context, double num) {\n+â”Š  â”Š10â”Š    return std::fmod((std::fmod(context, num) + num), num);\n+â”Š  â”Š11â”Š  }\n+â”Š  â”Š12â”Š\n+â”Š  â”Š13â”Š  // Trims number and leaves the number of decimals specified.\n+â”Š  â”Š14â”Š  // The \"mode\" argument specifies which math function should be invoked\n+â”Š  â”Š15â”Š  // right after the number has been trimmed.\n+â”Š  â”Š16â”Š  // e.g. 12.12345.trim(3, \"ceil\") returns 12.124\n+â”Š  â”Š17â”Š  double trim(double context, int decimals, const std::string mode) {\n+â”Š  â”Š18â”Š    double accumulator = context * std::pow(10, decimals);\n+â”Š  â”Š19â”Š\n+â”Š  â”Š20â”Š    if (mode.compare(\"ceil\") == 0)\n+â”Š  â”Š21â”Š      accumulator = std::ceil(accumulator);\n+â”Š  â”Š22â”Š    else if (mode.compare(\"floor\") == 0)\n+â”Š  â”Š23â”Š      accumulator = std::floor(accumulator);\n+â”Š  â”Š24â”Š    else\n+â”Š  â”Š25â”Š      accumulator = std::round(accumulator);\n+â”Š  â”Š26â”Š\n+â”Š  â”Š27â”Š    return accumulator / std::pow(10, decimals);\n+â”Š  â”Š28â”Š  }\n+â”Š  â”Š29â”Š\n+â”Š  â”Š30â”Š  // Tells if number is in specified range based on given precision.\n+â”Š  â”Š31â”Š  // See the \"compare\" method for more information about precision\n+â”Š  â”Š32â”Š  bool isBetween(double context, double num1, double num2, const std::string precision) {\n+â”Š  â”Š33â”Š    return compare(context, std::min(num1, num2), \">=\", precision) &&\n+â”Š  â”Š34â”Š           compare(context, std::max(num1, num2), \"<=\", precision);\n+â”Š  â”Š35â”Š  }\n+â”Š  â”Š36â”Š\n+â”Š  â”Š37â”Š  bool compare(double context, double num, const std::string precision) {\n+â”Š  â”Š38â”Š    return compare(context, num, \"==\", precision);\n+â”Š  â”Š39â”Š  }\n+â”Š  â”Š40â”Š\n+â”Š  â”Š41â”Š  // Initiates comparison operator between context number and a given number, only here\n+â”Š  â”Š42â”Š  // a precision can be specified\n+â”Š  â”Š43â”Š  bool compare(double context, double num, const std::string method, const std::string precision) {\n+â”Š  â”Š44â”Š    // Fixed precision, \"almost equal\" with a deviation of Îµ\n+â”Š  â”Š45â”Š    if (precision.compare(\"f\") == 0) {\n+â”Š  â”Š46â”Š      if (method.compare(\"<\") == 0 ||\n+â”Š  â”Š47â”Š          method.compare(\"<=\") == 0)\n+â”Š  â”Š48â”Š        return context <= num + DBL_EPSILON;\n+â”Š  â”Š49â”Š      if (method.compare(\">\") == 0 ||\n+â”Š  â”Š50â”Š          method.compare(\">=\") == 0)\n+â”Š  â”Š51â”Š        return context >= num - DBL_EPSILON;\n+â”Š  â”Š52â”Š      return std::abs(context - num) <= DBL_EPSILON;\n+â”Š  â”Š53â”Š    }\n+â”Š  â”Š54â”Š    // Pixel precision, round comparison\n+â”Š  â”Š55â”Š    else if (precision.compare(\"px\") == 0) {\n+â”Š  â”Š56â”Š      if (method.compare(\"<\") == 0 ||\n+â”Š  â”Š57â”Š          method.compare(\"<=\") == 0)\n+â”Š  â”Š58â”Š        return std::round(context) <= std::round(num);\n+â”Š  â”Š59â”Š      if (method.compare(\">\") == 0 ||\n+â”Š  â”Š60â”Š          method.compare(\">=\") == 0)\n+â”Š  â”Š61â”Š        return std::round(context) >= std::round(num);\n+â”Š  â”Š62â”Š      return std::round(context) == std::round(num);\n+â”Š  â”Š63â”Š    }\n+â”Š  â”Š64â”Š    // Exact precision\n+â”Š  â”Š65â”Š    else {\n+â”Š  â”Š66â”Š      if (method.compare(\"<\") == 0) return context < num;\n+â”Š  â”Š67â”Š      if (method.compare(\"<=\") == 0) return context <= num;\n+â”Š  â”Š68â”Š      if (method.compare(\">\") == 0) return context > num;\n+â”Š  â”Š69â”Š      if (method.compare(\">=\") == 0) return context >= num;\n+â”Š  â”Š70â”Š      return context == num;\n+â”Š  â”Š71â”Š    }\n+â”Š  â”Š72â”Š  }\n+â”Š  â”Š73â”Š}ðŸš«â†µ\n```\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;utils.h\n```diff\n@@ -0,0 +1,15 @@\n+â”Š  â”Š 1â”Š#pragma once\n+â”Š  â”Š 2â”Š\n+â”Š  â”Š 3â”Š#include <string>\n+â”Š  â”Š 4â”Š\n+â”Š  â”Š 5â”Šnamespace utils {\n+â”Š  â”Š 6â”Š  double mod(double context, double num);\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Š  double trim(double context, int decimals, const std::string mode = \"round\");\n+â”Š  â”Š 9â”Š\n+â”Š  â”Š10â”Š  bool isBetween(double context, double num1, double num2, const std::string precision = \"exact\");\n+â”Š  â”Š11â”Š\n+â”Š  â”Š12â”Š  bool compare(double context, double num, const std::string precision = \"exact\");\n+â”Š  â”Š13â”Š\n+â”Š  â”Š14â”Š  bool compare(double context, double num, const std::string method, const std::string precision);\n+â”Š  â”Š15â”Š}ðŸš«â†µ\n```\n\n[}]: #\n\nThe module above should work by itself when interacting with it inside the C++ scope, but that's not what we're striving for. We want this module to be available for use in our JavaScript project. This requires us to wrap our code in such a way the the Emscripten compiler will know how to compile it. Apart from providing a compiler, Emscripten provides us with functions and macros that will help use bind our C++ code to the JavaScript environment. These functionalities are packed in a single library which can be imported in our C++ code, and it is called [Embind](https://kripken.github.io/emscripten-site/docs/porting/connecting_cpp_and_javascript/embind.html) (probably stands for \"Emscripten bind\"). Using EMBind, let's wrap our utils module accordingly:\n\n[{]: <helper> (diffStep 7.3)\n\n#### [Step 7.3: EMBind CPP utils](https://github.com/DAB0mB/radial-snake/commit/0f34332)\n\n##### Changed resources&#x2F;cpp&#x2F;src&#x2F;utils.cpp\n```diff\n@@ -1,6 +1,7 @@\n â”Š1â”Š1â”Š#include <cfloat>\n â”Š2â”Š2â”Š#include <cmath>\n â”Š3â”Š3â”Š#include <string>\n+â”Š â”Š4â”Š#include <emscripten/bind.h>\n â”Š4â”Š5â”Š#include \"utils.h\"\n â”Š5â”Š6â”Š\n â”Š6â”Š7â”Šnamespace utils {\n```\n```diff\n@@ -70,4 +71,15 @@\n â”Š70â”Š71â”Š      return context == num;\n â”Š71â”Š72â”Š    }\n â”Š72â”Š73â”Š  }\n+â”Š  â”Š74â”Š}\n+â”Š  â”Š75â”Š\n+â”Š  â”Š76â”ŠEMSCRIPTEN_BINDINGS(utils_module) {\n+â”Š  â”Š77â”Š  emscripten::function(\"utils_mod\", &utils::mod);\n+â”Š  â”Š78â”Š  emscripten::function(\"utils_trim\", &utils::trim);\n+â”Š  â”Š79â”Š  emscripten::function(\"utils_isBetween\", &utils::isBetween);\n+â”Š  â”Š80â”Š  emscripten::function(\"utils_compare\",\n+â”Š  â”Š81â”Š    emscripten::select_overload<bool(double, double, const std::string, const std::string)>(\n+â”Š  â”Š82â”Š      &utils::compare\n+â”Š  â”Š83â”Š    )\n+â”Š  â”Š84â”Š  );\n â”Š73â”Š85â”Š}ðŸš«â†µ\n```\n\n[}]: #\n\nAfter a while you'll get used for Embind's API. If you'll look at it, it's self explanatory and easy to understand. Bound objects will be available the JavaScript environment will be available under an object named `Module`, e.g. the C++ method `mod` will be available for use as `Module.utils_mod`. Bound functions should have supported return types and argument types, meaning that if we're using a custom structure as a return type or an argument type, we first need to wrap it using EMBind, otherwise the compiler won't know how to handle it. A list of natively supported data-types can be found [here](https://kripken.github.io/emscripten-site/docs/porting/connecting_cpp_and_javascript/embind.html#built-in-type-conversions).\n\nEven though we've wrapped our C++ code and hypothetically it can already be used in the browser, I'd go for a second wrapper, since the compiled code doesn't have the optimal architecture. Right now we will have to approach C++ utility functions using `Module.utils_foo`. Instead, I'd like it to be `CPP.Utils.foo`, since it's clearer this way. The output of the Emscripten compiler can be wrapped with JavaScript code, using a prefix and a suffix, defined in 2 separate files respectively, called `pre.js` and `post.js`:\n\n[{]: <helper> (diffStep 7.4)\n\n#### [Step 7.4: Create CPP wrappers](https://github.com/DAB0mB/radial-snake/commit/cc28a34)\n\n##### Added resources&#x2F;cpp&#x2F;post.js\n```diff\n@@ -0,0 +1,10 @@\n+â”Š  â”Š 1â”Šreturn {\n+â”Š  â”Š 2â”Š  Utils: {\n+â”Š  â”Š 3â”Š    mod: Module.utils_mod,\n+â”Š  â”Š 4â”Š    trim: Module.utils_trim,\n+â”Š  â”Š 5â”Š    isBetween: Module.utils_isBetween,\n+â”Š  â”Š 6â”Š    compare: Module.utils_compare\n+â”Š  â”Š 7â”Š  }\n+â”Š  â”Š 8â”Š};\n+â”Š  â”Š 9â”Š\n+â”Š  â”Š10â”Š})();ðŸš«â†µ\n```\n\n##### Added resources&#x2F;cpp&#x2F;pre.js\n```diff\n@@ -0,0 +1 @@\n+â”Š â”Š1â”ŠCPP = (function() {ðŸš«â†µ\n```\n\n[}]: #\n\nWhat we've done in the code snippet above, we've created an anonymous function which calls itself, and inside we've exported a new namespace called `CPP` (C++). This way we can keep the generated code encapsulated, without worrying about spamming the global object.\n\nAfter creating a wrapper, I'd also recommend you to integrate the generated C++ code into existing namespaces, meaning that if for example we would like to approach the `CPP.Utils.foo` method, it could be done using `Utils.foo`. This way existing code won't have to be changed, and extra wrapping logic can be applied with ease, like the chaining logic implemented in the `Utils` namespace:\n\n[{]: <helper> (diffStep 7.5)\n\n#### [Step 7.5: Bind CPP utils to JS utils](https://github.com/DAB0mB/radial-snake/commit/0a67d50)\n\n##### Changed resources&#x2F;scripts&#x2F;utils.js\n```diff\n@@ -16,53 +16,9 @@\n â”Š16â”Š16â”Š  return chain;\n â”Š17â”Š17â”Š};\n â”Š18â”Š18â”Š\n-â”Š19â”Š  â”Š// Fixed modulo method which can calculate modulo of negative numbers properly\n-â”Š20â”Š  â”Š// e.g. (-803).mod(800) returns 797\n-â”Š21â”Š  â”ŠUtils.mod = function (context, num) {\n-â”Š22â”Š  â”Š  return ((context % num) + num) % num;\n-â”Š23â”Š  â”Š};\n-â”Š24â”Š  â”Š\n-â”Š25â”Š  â”Š// Trims number and leaves the number of decimals specified.\n-â”Š26â”Š  â”Š// The \"mode\" argument specifies which math function should be invoked\n-â”Š27â”Š  â”Š// right after the number has been trimmed.\n-â”Š28â”Š  â”Š// e.g. 12.12345.trim(3, \"ceil\") returns 12.124\n-â”Š29â”Š  â”ŠUtils.trim = function (context, decimals, mode = \"round\") {\n-â”Š30â”Š  â”Š  return Math[mode](context * Math.pow(10, decimals)) / Math.pow(10, decimals);\n-â”Š31â”Š  â”Š};\n-â”Š32â”Š  â”Š\n-â”Š33â”Š  â”Š// Tells if number is in specified range based on given precision.\n-â”Š34â”Š  â”Š// See the \"compare\" method for more information about precision\n-â”Š35â”Š  â”ŠUtils.isBetween = function (context, num1, num2, precision) {\n-â”Š36â”Š  â”Š  return Utils.compare(context, Math.min(num1, num2), \">=\", precision) &&\n-â”Š37â”Š  â”Š         Utils.compare(context, Math.max(num1, num2), \"<=\", precision);\n-â”Š38â”Š  â”Š};\n-â”Š39â”Š  â”Š\n-â”Š40â”Š  â”Š// Initiates comparison operator between context number and a given number, only here\n-â”Š41â”Š  â”Š// a precision can be specified\n-â”Š42â”Š  â”ŠUtils.compare = function (context, num, method, precision = method) {\n-â”Š43â”Š  â”Š  switch (precision) {\n-â”Š44â”Š  â”Š    // Fixed precision, \"almost equal\" with a deviation of Îµ\n-â”Š45â”Š  â”Š    case \"f\":\n-â”Š46â”Š  â”Š      switch (method) {\n-â”Š47â”Š  â”Š        case \"<\": case \"<=\": return context <= num + Number.EPSILON;\n-â”Š48â”Š  â”Š        case \">\": case \">=\": return context >= num - Number.EPSILON;\n-â”Š49â”Š  â”Š        default: return Math.abs(context - num) <= Number.EPSILON;\n-â”Š50â”Š  â”Š      }\n-â”Š51â”Š  â”Š    // Pixel precision, round comparison\n-â”Š52â”Š  â”Š    case \"px\":\n-â”Š53â”Š  â”Š      switch (method) {\n-â”Š54â”Š  â”Š        case \"<\": case \"<=\": return Math.round(context) <= Math.round(num);\n-â”Š55â”Š  â”Š        case \">\": case \">=\": return Math.round(context) >= Math.round(num);\n-â”Š56â”Š  â”Š        default: return Math.round(context) == Math.round(num);\n-â”Š57â”Š  â”Š      }\n-â”Š58â”Š  â”Š    // Exact precision\n-â”Š59â”Š  â”Š    default:\n-â”Š60â”Š  â”Š      switch (method) {\n-â”Š61â”Š  â”Š        case \"<\": return context < num;\n-â”Š62â”Š  â”Š        case \"<=\": return context <= num;\n-â”Š63â”Š  â”Š        case \">\": return context > num;\n-â”Š64â”Š  â”Š        case \">=\": return context >= num;\n-â”Š65â”Š  â”Š        default: return context === num;\n-â”Š66â”Š  â”Š      }\n+â”Š  â”Š19â”ŠObject.assign(Utils, CPP.Utils, {\n+â”Š  â”Š20â”Š  // Overload handling\n+â”Š  â”Š21â”Š  compare(context, num, method, precision = method) {\n+â”Š  â”Š22â”Š    return CPP.Utils.compare(context, num, method, precision);\n â”Š67â”Š23â”Š  }\n-â”Š68â”Š  â”Š};ðŸš«â†µ\n+â”Š  â”Š24â”Š});ðŸš«â†µ\n```\n\n[}]: #\n\nWhenever launching the compiler, the generated code should be outputted somewhere. I've decided to go with the path `resources/scripts/cpp.bundle.js`, but it doesn't matter how the file is gonna be called, as long as it's defined under the `scripts` dir, otherwise we won't be able to load it. Also, we need to make sure that we set a git-ignore rule for the generated file, since there's no reason for us to upload it to the git-host if we're planning on compiling it:\n\n[{]: <helper> (diffStep 7.5)\n\n#### [Step 7.5: Bind CPP utils to JS utils](https://github.com/DAB0mB/radial-snake/commit/0a67d50)\n\n##### Changed resources&#x2F;scripts&#x2F;utils.js\n```diff\n@@ -16,53 +16,9 @@\n â”Š16â”Š16â”Š  return chain;\n â”Š17â”Š17â”Š};\n â”Š18â”Š18â”Š\n-â”Š19â”Š  â”Š// Fixed modulo method which can calculate modulo of negative numbers properly\n-â”Š20â”Š  â”Š// e.g. (-803).mod(800) returns 797\n-â”Š21â”Š  â”ŠUtils.mod = function (context, num) {\n-â”Š22â”Š  â”Š  return ((context % num) + num) % num;\n-â”Š23â”Š  â”Š};\n-â”Š24â”Š  â”Š\n-â”Š25â”Š  â”Š// Trims number and leaves the number of decimals specified.\n-â”Š26â”Š  â”Š// The \"mode\" argument specifies which math function should be invoked\n-â”Š27â”Š  â”Š// right after the number has been trimmed.\n-â”Š28â”Š  â”Š// e.g. 12.12345.trim(3, \"ceil\") returns 12.124\n-â”Š29â”Š  â”ŠUtils.trim = function (context, decimals, mode = \"round\") {\n-â”Š30â”Š  â”Š  return Math[mode](context * Math.pow(10, decimals)) / Math.pow(10, decimals);\n-â”Š31â”Š  â”Š};\n-â”Š32â”Š  â”Š\n-â”Š33â”Š  â”Š// Tells if number is in specified range based on given precision.\n-â”Š34â”Š  â”Š// See the \"compare\" method for more information about precision\n-â”Š35â”Š  â”ŠUtils.isBetween = function (context, num1, num2, precision) {\n-â”Š36â”Š  â”Š  return Utils.compare(context, Math.min(num1, num2), \">=\", precision) &&\n-â”Š37â”Š  â”Š         Utils.compare(context, Math.max(num1, num2), \"<=\", precision);\n-â”Š38â”Š  â”Š};\n-â”Š39â”Š  â”Š\n-â”Š40â”Š  â”Š// Initiates comparison operator between context number and a given number, only here\n-â”Š41â”Š  â”Š// a precision can be specified\n-â”Š42â”Š  â”ŠUtils.compare = function (context, num, method, precision = method) {\n-â”Š43â”Š  â”Š  switch (precision) {\n-â”Š44â”Š  â”Š    // Fixed precision, \"almost equal\" with a deviation of Îµ\n-â”Š45â”Š  â”Š    case \"f\":\n-â”Š46â”Š  â”Š      switch (method) {\n-â”Š47â”Š  â”Š        case \"<\": case \"<=\": return context <= num + Number.EPSILON;\n-â”Š48â”Š  â”Š        case \">\": case \">=\": return context >= num - Number.EPSILON;\n-â”Š49â”Š  â”Š        default: return Math.abs(context - num) <= Number.EPSILON;\n-â”Š50â”Š  â”Š      }\n-â”Š51â”Š  â”Š    // Pixel precision, round comparison\n-â”Š52â”Š  â”Š    case \"px\":\n-â”Š53â”Š  â”Š      switch (method) {\n-â”Š54â”Š  â”Š        case \"<\": case \"<=\": return Math.round(context) <= Math.round(num);\n-â”Š55â”Š  â”Š        case \">\": case \">=\": return Math.round(context) >= Math.round(num);\n-â”Š56â”Š  â”Š        default: return Math.round(context) == Math.round(num);\n-â”Š57â”Š  â”Š      }\n-â”Š58â”Š  â”Š    // Exact precision\n-â”Š59â”Š  â”Š    default:\n-â”Š60â”Š  â”Š      switch (method) {\n-â”Š61â”Š  â”Š        case \"<\": return context < num;\n-â”Š62â”Š  â”Š        case \"<=\": return context <= num;\n-â”Š63â”Š  â”Š        case \">\": return context > num;\n-â”Š64â”Š  â”Š        case \">=\": return context >= num;\n-â”Š65â”Š  â”Š        default: return context === num;\n-â”Š66â”Š  â”Š      }\n+â”Š  â”Š19â”ŠObject.assign(Utils, CPP.Utils, {\n+â”Š  â”Š20â”Š  // Overload handling\n+â”Š  â”Š21â”Š  compare(context, num, method, precision = method) {\n+â”Š  â”Š22â”Š    return CPP.Utils.compare(context, num, method, precision);\n â”Š67â”Š23â”Š  }\n-â”Š68â”Š  â”Š};ðŸš«â†µ\n+â”Š  â”Š24â”Š});ðŸš«â†µ\n```\n\n[}]: #\n\nTo compile our C++ code and turn it into JavaScript, we'll need to run the following command:\n\n    $ emcc -O1 --pre-js resources/cpp/pre.js --post-js resources/cpp/post.js --bind -o resources/scripts/cpp.bundle.js resources/cpp/src/index.cpp\n\nHere's a detailed list with explanations regards the arguments vector we've just passed:\n\n- `-01` - Optimization level 1. The higher the index, the more optimized our code is gonna be, but less readable.\n- `--pre-js` - Specifies a JavaScript prefix for the compiled code.\n- `--post-js` - Specifies a JavaScript postfix for the compiled code.\n- `--bind` - Tells the compiler to use Embind\n- `-o` - The output path.\n\n> More informations regards Emscripten's CLI can be found [here](https://kripken.github.io/emscripten-site/docs/tools_reference/emcc.html).\n\nYou don't have to memorize the compilation command we've just typed, because we're gonna save it as an NPM script called `build:cpp`:\n\n[{]: <helper> (diffStep 7.6)\n\n#### [Step 7.6: Add ignore rule to CPP bundle](https://github.com/DAB0mB/radial-snake/commit/f4a75cf)\n\n##### Changed .gitignore\n```diff\n@@ -1,3 +1,4 @@\n â”Š1â”Š1â”Šnode_modules\n â”Š2â”Š2â”Šnpm-debug.log\n-â”Š3â”Š â”Šresources/assets/fonts/*.jsonðŸš«â†µ\n+â”Š â”Š3â”Šresources/assets/fonts/*.json\n+â”Š â”Š4â”Šresources/scripts/cpp.bundle.jsðŸš«â†µ\n```\n\n[}]: #\n\nNow if you'd like to compile the C++ code just run:\n\n    $ npm run build:cpp\n\nMoreover, the code should be compiled automatically any time you start the serer using the command:\n\n    $ npm run serve\n\nWe always have to be on the alert and run our tests against modules we've just translated from JavaScript to C++. This will guarantee that once we run the game we won't stumble upon any defect whatsoever. Before running the tests, be sure to import the C++ bundle in the HTML file's header:\n\n[{]: <helper> (diffStep 7.8)\n\n#### [Step 7.8: Load CPP bundle in spec runner](https://github.com/DAB0mB/radial-snake/commit/0d1bd08)\n\n##### Changed views&#x2F;spec_runner.html\n```diff\n@@ -16,6 +16,7 @@\n â”Š16â”Š16â”Š    <script type=\"text/javascript\" src=\"libs/underscore.js\"></script>\n â”Š17â”Š17â”Š\n â”Š18â”Š18â”Š    <!-- Scripts -->\n+â”Š  â”Š19â”Š    <script type=\"text/javascript\" src=\"scripts/cpp.bundle.js\"></script>\n â”Š19â”Š20â”Š    <script type=\"text/javascript\" src=\"scripts/utils.js\"></script>\n â”Š20â”Š21â”Š    <script type=\"text/javascript\" src=\"scripts/namespaces.js\"></script>\n â”Š21â”Š22â”Š    <script type=\"text/javascript\" src=\"scripts/engine/geometry/line.js\"></script>\n```\n\n[}]: #\n\nNow we can run the tests by running the following command:\n\n    $ npm run test\n\nAt this point **all our tests should pass**. If they don't, it means our newly created utility module is not working properly, and you will have to repeat the previous steps until you get it right.\n\nUp next, we gonna translate the geometry line class to C++. Since it's gonna be translated almost identically, we will have to make sure that all the necessary assets are gonna be available for our class before proceeding. The first thing we will have to do would be making sure that the utility functions are chainable directly from C++ as well. To do that, we will create a chain class which should return a new instance of it whenever we're about to chain the upcoming utility method. Once calling `result()`, the accumulator should be returned:\n\n[{]: <helper> (diffStep 7.9)\n\n#### [Step 7.9: Add chaining method to CPP utils](https://github.com/DAB0mB/radial-snake/commit/0927eea)\n\n##### Changed resources&#x2F;cpp&#x2F;src&#x2F;utils.cpp\n```diff\n@@ -5,6 +5,61 @@\n â”Š 5â”Š 5â”Š#include \"utils.h\"\n â”Š 6â”Š 6â”Š\n â”Š 7â”Š 7â”Šnamespace utils {\n+â”Š  â”Š 8â”Š  template<typename T>\n+â”Š  â”Š 9â”Š  Chain<T>::Chain(T accumulator): _accumulator(accumulator) {\n+â”Š  â”Š10â”Š  }\n+â”Š  â”Š11â”Š\n+â”Š  â”Š12â”Š  template<>\n+â”Š  â”Š13â”Š  Chain<double>* Chain<double>::mod(double num) {\n+â”Š  â”Š14â”Š    double result = utils::mod(_accumulator, num);\n+â”Š  â”Š15â”Š    Chain<double>* chain = new Chain<double>(result);\n+â”Š  â”Š16â”Š    delete this;\n+â”Š  â”Š17â”Š    return chain;\n+â”Š  â”Š18â”Š  }\n+â”Š  â”Š19â”Š\n+â”Š  â”Š20â”Š  template<>\n+â”Š  â”Š21â”Š  Chain<double>* Chain<double>::trim(int decimals, const std::string mode) {\n+â”Š  â”Š22â”Š    double result = utils::trim(_accumulator, decimals, mode);\n+â”Š  â”Š23â”Š    Chain<double>* chain = new Chain<double>(result);\n+â”Š  â”Š24â”Š    delete this;\n+â”Š  â”Š25â”Š    return chain;\n+â”Š  â”Š26â”Š  }\n+â”Š  â”Š27â”Š\n+â”Š  â”Š28â”Š  template<>\n+â”Š  â”Š29â”Š  Chain<bool>* Chain<double>::isBetween(double num1, double num2, const std::string precision) {\n+â”Š  â”Š30â”Š    bool result = utils::isBetween(_accumulator, num1, num2, precision);\n+â”Š  â”Š31â”Š    Chain<bool>* chain = new Chain<bool>(result);\n+â”Š  â”Š32â”Š    delete this;\n+â”Š  â”Š33â”Š    return chain;\n+â”Š  â”Š34â”Š  }\n+â”Š  â”Š35â”Š\n+â”Š  â”Š36â”Š  template<>\n+â”Š  â”Š37â”Š  Chain<bool>* Chain<double>::compare(double num, const std::string precision) {\n+â”Š  â”Š38â”Š    bool result = utils::compare(_accumulator, num, precision);\n+â”Š  â”Š39â”Š    Chain<bool>* chain = new Chain<bool>(result);\n+â”Š  â”Š40â”Š    delete this;\n+â”Š  â”Š41â”Š    return chain;\n+â”Š  â”Š42â”Š  }\n+â”Š  â”Š43â”Š\n+â”Š  â”Š44â”Š  template<>\n+â”Š  â”Š45â”Š  Chain<bool>* Chain<double>::compare(double num, const std::string method, const std::string precision) {\n+â”Š  â”Š46â”Š    bool result = utils::compare(_accumulator, num, method, precision);\n+â”Š  â”Š47â”Š    Chain<bool>* chain = new Chain<bool>(result);\n+â”Š  â”Š48â”Š    delete this;\n+â”Š  â”Š49â”Š    return chain;\n+â”Š  â”Š50â”Š  }\n+â”Š  â”Š51â”Š\n+â”Š  â”Š52â”Š  template<typename T>\n+â”Š  â”Š53â”Š  T Chain<T>::result() {\n+â”Š  â”Š54â”Š    delete this;\n+â”Š  â”Š55â”Š    return _accumulator;\n+â”Š  â”Š56â”Š  }\n+â”Š  â”Š57â”Š\n+â”Š  â”Š58â”Š  template<typename T>\n+â”Š  â”Š59â”Š  Chain<T>* chain(T accumulator) {\n+â”Š  â”Š60â”Š    return new Chain<T>(accumulator);\n+â”Š  â”Š61â”Š  }\n+â”Š  â”Š62â”Š\n â”Š 8â”Š63â”Š  // Fixed modulo method which can calculate modulo of negative numbers properly\n â”Š 9â”Š64â”Š  // e.g. (-803).mod(800) returns 797\n â”Š10â”Š65â”Š  double mod(double context, double num) {\n```\n\n##### Changed resources&#x2F;cpp&#x2F;src&#x2F;utils.h\n```diff\n@@ -3,6 +3,30 @@\n â”Š 3â”Š 3â”Š#include <string>\n â”Š 4â”Š 4â”Š\n â”Š 5â”Š 5â”Šnamespace utils {\n+â”Š  â”Š 6â”Š  template<typename T>\n+â”Š  â”Š 7â”Š  class Chain {\n+â”Š  â”Š 8â”Š  private:\n+â”Š  â”Š 9â”Š    T _accumulator;\n+â”Š  â”Š10â”Š\n+â”Š  â”Š11â”Š  public:\n+â”Š  â”Š12â”Š    Chain(T accumulator);\n+â”Š  â”Š13â”Š\n+â”Š  â”Š14â”Š    Chain<double>* mod(double num);\n+â”Š  â”Š15â”Š\n+â”Š  â”Š16â”Š    Chain<double>* trim(int decimals, const std::string mode = \"round\");\n+â”Š  â”Š17â”Š\n+â”Š  â”Š18â”Š    Chain<bool>* isBetween(double num1, double num2, const std::string precision = \"exact\");\n+â”Š  â”Š19â”Š\n+â”Š  â”Š20â”Š    Chain<bool>* compare(double num, const std::string precision = \"exact\");\n+â”Š  â”Š21â”Š\n+â”Š  â”Š22â”Š    Chain<bool>* compare(double num, const std::string method, const std::string precision);\n+â”Š  â”Š23â”Š\n+â”Š  â”Š24â”Š    T result();\n+â”Š  â”Š25â”Š  };\n+â”Š  â”Š26â”Š\n+â”Š  â”Š27â”Š  template<typename T>\n+â”Š  â”Š28â”Š  Chain<T>* chain(T accumulator);\n+â”Š  â”Š29â”Š\n â”Š 6â”Š30â”Š  double mod(double context, double num);\n â”Š 7â”Š31â”Š\n â”Š 8â”Š32â”Š  double trim(double context, int decimals, const std::string mode = \"round\");\n```\n\n[}]: #\n\n> Note that when coding in C++ we have to make sure that the objects are being disposed when not needed anymore, otherwise we will have some unnecessary memory leaks.\n\n2D shapes are presented in space using points with 2 values - `x` (axis) and `y` axis, therefore, we will create the appropriate point structure:\n\n[{]: <helper> (diffStep 7.1)\n\n#### [Step 7.1: Add CPP entry script](https://github.com/DAB0mB/radial-snake/commit/2f35323)\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;index.cpp\n```diff\n@@ -0,0 +1 @@\n+â”Š â”Š1â”Š#include \"utils.cpp\"ðŸš«â†µ\n```\n\n[}]: #\n\nReturned values can either be `null` (`undefined`) or not. Since there's no built in nullable-values mechanism in C++ (up until C++17), we're gonna create one of our own:\n\n[{]: <helper> (diffStep 7.11)\n\n#### [Step 7.11: Add nullable class](https://github.com/DAB0mB/radial-snake/commit/41b2f7c)\n\n##### Changed resources&#x2F;cpp&#x2F;src&#x2F;index.cpp\n```diff\n@@ -1 +1,2 @@\n+â”Š â”Š1â”Š#include \"nullable.cpp\"\n â”Š1â”Š2â”Š#include \"utils.cpp\"ðŸš«â†µ\n```\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;nullable.cpp\n```diff\n@@ -0,0 +1,37 @@\n+â”Š  â”Š 1â”Š#include \"nullable.h\"\n+â”Š  â”Š 2â”Š\n+â”Š  â”Š 3â”Štemplate <typename T>\n+â”Š  â”Š 4â”ŠNullable<T>::Nullable(T value): _value(value), _initialized(true) {\n+â”Š  â”Š 5â”Š\n+â”Š  â”Š 6â”Š}\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Štemplate <typename T>\n+â”Š  â”Š 9â”ŠNullable<T>::Nullable(): _initialized(false) {\n+â”Š  â”Š10â”Š\n+â”Š  â”Š11â”Š}\n+â”Š  â”Š12â”Š\n+â”Š  â”Š13â”Štemplate <typename T>\n+â”Š  â”Š14â”ŠT Nullable<T>::getValue() const {\n+â”Š  â”Š15â”Š  return _value;\n+â”Š  â”Š16â”Š}\n+â”Š  â”Š17â”Š\n+â”Š  â”Š18â”Štemplate <typename T>\n+â”Š  â”Š19â”Švoid Nullable<T>::setValue(T value) {\n+â”Š  â”Š20â”Š  _value = value;\n+â”Š  â”Š21â”Š  _initialized = true;\n+â”Š  â”Š22â”Š}\n+â”Š  â”Š23â”Š\n+â”Š  â”Š24â”Štemplate <typename T>\n+â”Š  â”Š25â”Švoid Nullable<T>::resetValue() {\n+â”Š  â”Š26â”Š  _initialized = false;\n+â”Š  â”Š27â”Š}\n+â”Š  â”Š28â”Š\n+â”Š  â”Š29â”Štemplate <typename T>\n+â”Š  â”Š30â”Šbool Nullable<T>::hasValue() const {\n+â”Š  â”Š31â”Š  return _initialized == true;\n+â”Š  â”Š32â”Š}\n+â”Š  â”Š33â”Š\n+â”Š  â”Š34â”Štemplate <typename T>\n+â”Š  â”Š35â”Šbool Nullable<T>::isNull() const {\n+â”Š  â”Š36â”Š  return _initialized == false;\n+â”Š  â”Š37â”Š}ðŸš«â†µ\n```\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;nullable.h\n```diff\n@@ -0,0 +1,23 @@\n+â”Š  â”Š 1â”Š#pragma once\n+â”Š  â”Š 2â”Š\n+â”Š  â”Š 3â”Štemplate <typename T>\n+â”Š  â”Š 4â”Šclass Nullable {\n+â”Š  â”Š 5â”Šprivate:\n+â”Š  â”Š 6â”Š  T _value;\n+â”Š  â”Š 7â”Š  bool _initialized;\n+â”Š  â”Š 8â”Š\n+â”Š  â”Š 9â”Špublic:\n+â”Š  â”Š10â”Š  Nullable(T value);\n+â”Š  â”Š11â”Š\n+â”Š  â”Š12â”Š  Nullable();\n+â”Š  â”Š13â”Š\n+â”Š  â”Š14â”Š  T getValue() const;\n+â”Š  â”Š15â”Š\n+â”Š  â”Š16â”Š  void setValue(T value);\n+â”Š  â”Š17â”Š\n+â”Š  â”Š18â”Š  void resetValue();\n+â”Š  â”Š19â”Š\n+â”Š  â”Š20â”Š  bool hasValue() const;\n+â”Š  â”Š21â”Š\n+â”Š  â”Š22â”Š  bool isNull() const;\n+â”Š  â”Š23â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nNow that all the necessary assets for the line class are ready, we can go ahead and create it:\n\n[{]: <helper> (diffStep 7.12)\n\n#### [Step 7.12: Add base line CPP module](https://github.com/DAB0mB/radial-snake/commit/9d17554)\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;geometry&#x2F;line.cpp\n```diff\n@@ -0,0 +1,99 @@\n+â”Š  â”Š 1â”Š#include \"../nullable.h\"\n+â”Š  â”Š 2â”Š#include \"../utils.h\"\n+â”Š  â”Š 3â”Š#include \"point.h\"\n+â”Š  â”Š 4â”Š#include \"line.h\"\n+â”Š  â”Š 5â”Š\n+â”Š  â”Š 6â”Šnamespace geometry {\n+â”Š  â”Š 7â”Š  // x1 - The first point's x value\n+â”Š  â”Š 8â”Š  // y1 - The first point's y value\n+â”Š  â”Š 9â”Š  // x1 - The second point's x value\n+â”Š  â”Š10â”Š  // y2 - The second point's y value\n+â”Š  â”Š11â”Š  Line::Line(double x1, double y1, double x2, double y2) {\n+â”Š  â”Š12â”Š    _x1 = utils::trim(x1, 9);\n+â”Š  â”Š13â”Š    _y1 = utils::trim(y1, 9);\n+â”Š  â”Š14â”Š    _x2 = utils::trim(x2, 9);\n+â”Š  â”Š15â”Š    _y2 = utils::trim(y2, 9);\n+â”Š  â”Š16â”Š  }\n+â”Š  â”Š17â”Š\n+â”Š  â”Š18â”Š  // Gets the matching x value for a given y value\n+â”Š  â”Š19â”Š  Nullable<double> Line::getMatchingX(double y) {\n+â”Š  â”Š20â”Š    // If an error was thrown it means we divided a number by zero,\n+â”Š  â”Š21â”Š    // in which case there is not intersection point\n+â”Š  â”Š22â”Š    double x = utils::trim(\n+â”Š  â”Š23â”Š      (((y - _y1) * (_x2 - _x1)) /\n+â”Š  â”Š24â”Š       (_y2 - _y1)) + _x1\n+â”Š  â”Š25â”Š    , 9, \"exact\");\n+â”Š  â”Š26â”Š\n+â”Š  â”Š27â”Š    // Check if result is in values range\n+â”Š  â”Š28â”Š    if (utils::isBetween(x, _x1, _x2, \"round\")) {\n+â”Š  â”Š29â”Š      return Nullable<double>(x);\n+â”Š  â”Š30â”Š    }\n+â”Š  â”Š31â”Š\n+â”Š  â”Š32â”Š    return Nullable<double>();\n+â”Š  â”Š33â”Š  }\n+â”Š  â”Š34â”Š\n+â”Š  â”Š35â”Š  // Gets the matching y value for a given x value\n+â”Š  â”Š36â”Š  Nullable<double> Line::getMatchingY(double x) {\n+â”Š  â”Š37â”Š    // If an error was thrown it means we divided a number by zero,\n+â”Š  â”Š38â”Š    // in which case there is not intersection point\n+â”Š  â”Š39â”Š    double y = utils::trim(\n+â”Š  â”Š40â”Š      (((x - _x1) * (_y2 - _y1)) /\n+â”Š  â”Š41â”Š       (_x2 - _x1)) + _y1\n+â”Š  â”Š42â”Š    , 9, \"exact\");\n+â”Š  â”Š43â”Š\n+â”Š  â”Š44â”Š    // Check if result is in values range\n+â”Š  â”Š45â”Š    if (utils::isBetween(y, _y1, _y2, \"round\")) {\n+â”Š  â”Š46â”Š      return Nullable<double>(y);\n+â”Š  â”Š47â”Š    }\n+â”Š  â”Š48â”Š\n+â”Š  â”Š49â”Š    return Nullable<double>();\n+â”Š  â”Š50â”Š  }\n+â”Š  â”Š51â”Š\n+â”Š  â”Š52â”Š  // Returns if line has given point\n+â”Š  â”Š53â”Š  bool Line::hasPoint(double x, double y) {\n+â”Š  â”Š54â”Š    if (!boundsHavePoint(x, y)) return 0;\n+â”Š  â”Š55â”Š\n+â”Š  â”Š56â”Š    double m = utils::trim(\n+â”Š  â”Š57â”Š      (_y2 - _y1) / (_x2 - _x1),\n+â”Š  â”Š58â”Š    9, \"exact\");\n+â”Š  â”Š59â”Š\n+â”Š  â”Š60â”Š    return (y - _y1) / (x - _x1) == m;\n+â”Š  â”Š61â”Š  }\n+â”Š  â”Š62â”Š\n+â”Š  â”Š63â”Š  // Returns if given point is contained by the bounds aka cage of line\n+â”Š  â”Š64â”Š  bool Line::boundsHavePoint(double x, double y) {\n+â”Š  â”Š65â”Š    return utils::isBetween(x, _x1, _x2, \"round\") &&\n+â”Š  â”Š66â”Š           utils::isBetween(y, _y1, _y2, \"round\");\n+â”Š  â”Š67â”Š  }\n+â”Š  â”Š68â”Š\n+â”Š  â”Š69â”Š  // line - line intersection method\n+â”Š  â”Š70â”Š  Nullable<Point> Line::getIntersection(Line line) {\n+â”Š  â”Š71â”Š    // Escape if lines are parallel\n+â”Š  â”Š72â”Š    if (!(((_x1 - _x2) * (line._y1 - line._y2)) -\n+â”Š  â”Š73â”Š          ((_y1 - _y2) * (line._x1 - line._x2))))\n+â”Š  â”Š74â”Š      return Nullable<Point>();\n+â”Š  â”Š75â”Š\n+â”Š  â”Š76â”Š    // Intersection point formula\n+â”Š  â”Š77â”Š    double x = utils::trim(\n+â”Š  â”Š78â”Š      ((((_x1 * _y2) - (_y1 * _x2)) * (line._x1 - line._x2)) -\n+â”Š  â”Š79â”Š       ((_x1 - _x2) * ((line._x1 * line._y2) - (line._y1 * line._x2)))) /\n+â”Š  â”Š80â”Š      (((_x1 - _x2) * (line._y1 - line._y2)) - ((_y1 - _y2) *\n+â”Š  â”Š81â”Š        (line._x1 - line._x2)))\n+â”Š  â”Š82â”Š    , 9, \"exact\");\n+â”Š  â”Š83â”Š    double y = utils::trim(\n+â”Š  â”Š84â”Š      ((((_x1 * _y2) - (_y1 * _x2)) * (line._y1 - line._y2)) -\n+â”Š  â”Š85â”Š       ((_y1 - _y2) * ((line._x1 * line._y2) - (line._y1 * line._x2)))) /\n+â”Š  â”Š86â”Š      (((_x1 - _x2) * (line._y1 - line._y2)) - ((_y1 - _y2) *\n+â”Š  â”Š87â”Š        (line._x1 - line._x2)))\n+â”Š  â”Š88â”Š    , 9, \"exact\");\n+â”Š  â”Š89â”Š\n+â”Š  â”Š90â”Š    if (utils::isBetween(x, _x1, _x2, \"round\") &&\n+â”Š  â”Š91â”Š        utils::isBetween(x, line._x1, line._x2, \"round\") &&\n+â”Š  â”Š92â”Š        utils::isBetween(y, _y1, _y2, \"round\") &&\n+â”Š  â”Š93â”Š        utils::isBetween(y, line._y1, line._y2, \"round\")) {\n+â”Š  â”Š94â”Š      return Nullable<Point>({ x, y });\n+â”Š  â”Š95â”Š    }\n+â”Š  â”Š96â”Š\n+â”Š  â”Š97â”Š    return Nullable<Point>();\n+â”Š  â”Š98â”Š  }\n+â”Š  â”Š99â”Š}ðŸš«â†µ\n```\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;geometry&#x2F;line.h\n```diff\n@@ -0,0 +1,30 @@\n+â”Š  â”Š 1â”Š#pragma once\n+â”Š  â”Š 2â”Š\n+â”Š  â”Š 3â”Š#include <vector>\n+â”Š  â”Š 4â”Š#include \"../nullable.h\"\n+â”Š  â”Š 5â”Š#include \"point.h\"\n+â”Š  â”Š 6â”Š\n+â”Š  â”Š 7â”Šnamespace geometry {\n+â”Š  â”Š 8â”Š  class Circle;\n+â”Š  â”Š 9â”Š  class EMCircle;\n+â”Š  â”Š10â”Š\n+â”Š  â”Š11â”Š  class Line {\n+â”Š  â”Š12â”Š  public:\n+â”Š  â”Š13â”Š    double _x1;\n+â”Š  â”Š14â”Š    double _y1;\n+â”Š  â”Š15â”Š    double _x2;\n+â”Š  â”Š16â”Š    double _y2;\n+â”Š  â”Š17â”Š\n+â”Š  â”Š18â”Š    Line(double x1, double y1, double x2, double y2);\n+â”Š  â”Š19â”Š\n+â”Š  â”Š20â”Š    Nullable<double> getMatchingX(double y);\n+â”Š  â”Š21â”Š\n+â”Š  â”Š22â”Š    Nullable<double> getMatchingY(double x);\n+â”Š  â”Š23â”Š\n+â”Š  â”Š24â”Š    bool hasPoint(double x, double y);\n+â”Š  â”Š25â”Š\n+â”Š  â”Š26â”Š    bool boundsHavePoint(double x, double y);\n+â”Š  â”Š27â”Š\n+â”Š  â”Š28â”Š    Nullable<Point> getIntersection(Line line);\n+â”Š  â”Š29â”Š  };\n+â”Š  â”Š30â”Š}ðŸš«â†µ\n```\n\n##### Changed resources&#x2F;cpp&#x2F;src&#x2F;index.cpp\n```diff\n@@ -1,2 +1,3 @@\n â”Š1â”Š1â”Š#include \"nullable.cpp\"\n-â”Š2â”Š â”Š#include \"utils.cpp\"ðŸš«â†µ\n+â”Š â”Š2â”Š#include \"utils.cpp\"\n+â”Š â”Š3â”Š#include \"geometry/line.cpp\"ðŸš«â†µ\n```\n\n[}]: #\n\nAfter creating our C++, we will also need to bind it using EMBind:\n\n[{]: <helper> (diffStep 7.13)\n\n#### [Step 7.13: EMBind CPP line](https://github.com/DAB0mB/radial-snake/commit/8920ddf)\n\n##### Changed resources&#x2F;cpp&#x2F;post.js\n```diff\n@@ -4,6 +4,10 @@\n â”Š 4â”Š 4â”Š    trim: Module.utils_trim,\n â”Š 5â”Š 5â”Š    isBetween: Module.utils_isBetween,\n â”Š 6â”Š 6â”Š    compare: Module.utils_compare\n+â”Š  â”Š 7â”Š  },\n+â”Š  â”Š 8â”Š\n+â”Š  â”Š 9â”Š  Geometry: {\n+â”Š  â”Š10â”Š    Line: Module.geometry_line\n â”Š 7â”Š11â”Š  }\n â”Š 8â”Š12â”Š};\n â”Š 9â”Š13â”Š\n```\n\n##### Changed resources&#x2F;cpp&#x2F;src&#x2F;geometry&#x2F;line.cpp\n```diff\n@@ -1,3 +1,6 @@\n+â”Š â”Š1â”Š#include <vector>\n+â”Š â”Š2â”Š#include <emscripten/bind.h>\n+â”Š â”Š3â”Š#include <emscripten/val.h>\n â”Š1â”Š4â”Š#include \"../nullable.h\"\n â”Š2â”Š5â”Š#include \"../utils.h\"\n â”Š3â”Š6â”Š#include \"point.h\"\n```\n```diff\n@@ -96,4 +99,52 @@\n â”Š 96â”Š 99â”Š\n â”Š 97â”Š100â”Š    return Nullable<Point>();\n â”Š 98â”Š101â”Š  }\n+â”Š   â”Š102â”Š\n+â”Š   â”Š103â”Š  emscripten::val EMLine::getMatchingX(double y) {\n+â”Š   â”Š104â”Š    Nullable<double> nullableX = Line::getMatchingX(y);\n+â”Š   â”Š105â”Š    return nullableX.hasValue() ?\n+â”Š   â”Š106â”Š      emscripten::val(nullableX.getValue()) :\n+â”Š   â”Š107â”Š      emscripten::val::undefined();\n+â”Š   â”Š108â”Š  }\n+â”Š   â”Š109â”Š\n+â”Š   â”Š110â”Š  emscripten::val EMLine::getMatchingY(double x) {\n+â”Š   â”Š111â”Š    Nullable<double> nullableY = Line::getMatchingY(x);\n+â”Š   â”Š112â”Š    return nullableY.hasValue() ?\n+â”Š   â”Š113â”Š      emscripten::val(nullableY.getValue()) :\n+â”Š   â”Š114â”Š      emscripten::val::undefined();\n+â”Š   â”Š115â”Š  }\n+â”Š   â”Š116â”Š\n+â”Š   â”Š117â”Š  emscripten::val EMLine::getIntersection(EMLine emLine) {\n+â”Š   â”Š118â”Š    Line line = Line(emLine._x1, emLine._y1, emLine._x2, emLine._y2);\n+â”Š   â”Š119â”Š    Nullable<Point> nullablePoint = Line::getIntersection(line);\n+â”Š   â”Š120â”Š\n+â”Š   â”Š121â”Š    if (nullablePoint.isNull()) return emscripten::val::undefined();\n+â”Š   â”Š122â”Š\n+â”Š   â”Š123â”Š    Point point = nullablePoint.getValue();\n+â”Š   â”Š124â”Š    emscripten::val emPoint = emscripten::val::object();\n+â”Š   â”Š125â”Š    emPoint.set(\"x\", emscripten::val(point.x));\n+â”Š   â”Š126â”Š    emPoint.set(\"y\", emscripten::val(point.y));\n+â”Š   â”Š127â”Š    return emPoint;\n+â”Š   â”Š128â”Š  }\n+â”Š   â”Š129â”Š}\n+â”Š   â”Š130â”Š\n+â”Š   â”Š131â”ŠEMSCRIPTEN_BINDINGS(geometry_line_module) {\n+â”Š   â”Š132â”Š  emscripten::class_<geometry::Line>(\"geometry_line_base\")\n+â”Š   â”Š133â”Š    .constructor<double, double, double, double>()\n+â”Š   â”Š134â”Š    .property<double>(\"x1\", &geometry::Line::_x1)\n+â”Š   â”Š135â”Š    .property<double>(\"y1\", &geometry::Line::_y1)\n+â”Š   â”Š136â”Š    .property<double>(\"x2\", &geometry::Line::_x2)\n+â”Š   â”Š137â”Š    .property<double>(\"y2\", &geometry::Line::_y2)\n+â”Š   â”Š138â”Š    .function(\"hasPoint\", &geometry::Line::hasPoint)\n+â”Š   â”Š139â”Š    .function(\"boundsHavePoint\", &geometry::Line::boundsHavePoint);\n+â”Š   â”Š140â”Š\n+â”Š   â”Š141â”Š  emscripten::class_<geometry::EMLine, emscripten::base<geometry::Line>>(\"geometry_line\")\n+â”Š   â”Š142â”Š    .constructor<double, double, double, double>()\n+â”Š   â”Š143â”Š    .function(\"getX\", &geometry::EMLine::getMatchingX)\n+â”Š   â”Š144â”Š    .function(\"getY\", &geometry::EMLine::getMatchingY)\n+â”Š   â”Š145â”Š    .function(\"getLineIntersection\",\n+â”Š   â”Š146â”Š      emscripten::select_overload<emscripten::val(geometry::EMLine)>(\n+â”Š   â”Š147â”Š        &geometry::EMLine::getIntersection\n+â”Š   â”Š148â”Š      )\n+â”Š   â”Š149â”Š    );\n â”Š 99â”Š150â”Š}ðŸš«â†µ\n```\n\n##### Changed resources&#x2F;cpp&#x2F;src&#x2F;geometry&#x2F;line.h\n```diff\n@@ -1,6 +1,7 @@\n â”Š1â”Š1â”Š#pragma once\n â”Š2â”Š2â”Š\n â”Š3â”Š3â”Š#include <vector>\n+â”Š â”Š4â”Š#include <emscripten/val.h>\n â”Š4â”Š5â”Š#include \"../nullable.h\"\n â”Š5â”Š6â”Š#include \"point.h\"\n â”Š6â”Š7â”Š\n```\n```diff\n@@ -27,4 +28,15 @@\n â”Š27â”Š28â”Š\n â”Š28â”Š29â”Š    Nullable<Point> getIntersection(Line line);\n â”Š29â”Š30â”Š  };\n+â”Š  â”Š31â”Š\n+â”Š  â”Š32â”Š  class EMLine : public Line {\n+â”Š  â”Š33â”Š  public:\n+â”Š  â”Š34â”Š    using Line::Line;\n+â”Š  â”Š35â”Š\n+â”Š  â”Š36â”Š    emscripten::val getMatchingX(double y);\n+â”Š  â”Š37â”Š\n+â”Š  â”Š38â”Š    emscripten::val getMatchingY(double x);\n+â”Š  â”Š39â”Š\n+â”Š  â”Š40â”Š    emscripten::val getIntersection(EMLine line);\n+â”Š  â”Š41â”Š  };\n â”Š30â”Š42â”Š}ðŸš«â†µ\n```\n\n[}]: #\n\nIn the code snippet above, you can see that we used a special data-type called `val` (`emscripten::val`). `val` means that just like JavaScript, that function can return values that are not necessarily of the same data-type; For instance, the `getMatchingY` function can either return a `number` or `undefined`. If you'll take a look at the `getIntersection(Line)` method you'll notice that instead of returning the raw point structure, I chose to build a JavaScript object using the `object` data type (`emscripten::object`). `object` behaves exactly like a native JavaScript `Object`, and it can save us some precious work of binding which sometimes might be just too much.\n\nIf you'll compare the C++ version of the line class to the JavaScript line class you'll notice that the `draw` and `getIntersection` methods are missing (when we used EMBind we renamed `getIntersection` to `getLineIntersection` because overloadings are forbidden). In addition, Emscripten's API exposes some additional class methods for generated C++ classes, like the `delete` method, which we will shed light on further in this tutorial. Inheritance would be the natural solution for such an issue, unfortunately, generated C++ constructors don't accept indirect instances. For example, if we have a C++ parent class called `Shape` and we have a JavaScript child class called `Line`, we won't be able to initialize a new instance of the `Line` class. Here's a demonstration:\n\n```js\nclass JSLine extends CPPShape {}\nconst line = new JSLine(); // Throws error\n```\n\nThere are 3 ways to implement inheritance when interacting with C++ classes:\n\n- Define an interface when using EMBind. This is the official way but rather complicated, since it requires us to define an extra layer for our wrapper. More information can be found [here](https://kripken.github.io/emscripten-site/docs/porting/connecting_cpp_and_javascript/embind.html#abstract-methods).\n- Extending the prototype of exported C++ classes directly, which is not really an inheritance.\n- Using a proxy class, which is the easiest and cleanest solution of all, but it is not really mentioned anywhere. At the same time, I didn't find any restriction regards that.\n\nWe're gonna use the 3rd method in the list above, because as I said, it's the easiest and cleanest of all. First I will try to explain what I meant by saying \"proxy class\". If you're an intermediate JavaScript developer, you probably know that constructors can be overridden by returning a value explicitly. By doing that, we can actually bypass Emscripten's prohibitions, we can just return the newly created C++ instance and extend it in specific. Proxy classes actually take it a step further by providing a middle-class which will then inject a new link to the prototype chain of the returned instance.\n\n```js\nclass JSLine {\n  constructor() {\n    const line = new CPPShape();\n    return line;\n  }\n}\n\nconst line = new JSLine(); // Legal!\n```\n\n> More information about the code snippet above can be found [here](https://www.bennadel.com/blog/2522-providing-a-return-value-in-a-javascript-constructor.htm).\n\nI believe that as we go through this tutorial, the concept will get much clearer. The utility function of the proxy class should look like so:\n\n[{]: <helper> (diffStep 7.14)\n\n#### [Step 7.14: Add proxy utility method](https://github.com/DAB0mB/radial-snake/commit/06e615e)\n\n##### Changed resources&#x2F;scripts&#x2F;utils.js\n```diff\n@@ -20,5 +20,18 @@\n â”Š20â”Š20â”Š  // Overload handling\n â”Š21â”Š21â”Š  compare(context, num, method, precision = method) {\n â”Š22â”Š22â”Š    return CPP.Utils.compare(context, num, method, precision);\n+â”Š  â”Š23â”Š  },\n+â”Š  â”Š24â”Š\n+â”Š  â”Š25â”Š  proxy(Class) {\n+â”Š  â”Š26â”Š    return class extends Class {\n+â”Š  â”Š27â”Š      constructor() {\n+â”Š  â”Š28â”Š        // Initialize original class\n+â”Š  â”Š29â”Š        let that = new Class(...arguments);\n+â”Š  â”Š30â”Š        // Inject caller's prototype into the prototype chain\n+â”Š  â”Š31â”Š        Object.setPrototypeOf(that, new.target.prototype);\n+â”Š  â”Š32â”Š        // Will original instance will be the substitute for 'this'\n+â”Š  â”Š33â”Š        return that;\n+â”Š  â”Š34â”Š      }\n+â”Š  â”Š35â”Š    }\n â”Š23â”Š36â”Š  }\n â”Š24â”Š37â”Š});ðŸš«â†µ\n```\n\n[}]: #\n\nIf you'll take a look at the following line:\n\n```js\nObject.setPrototypeOf(that, new.target.prototype);\n```\n\nThis is where the magic actually happens! It enables inheritance for explicitly returned objects; This way we can safely extend C++ classes. Accordingly, our new JavaScript line class should look like so:\n\n[{]: <helper> (diffStep 7.15)\n\n#### [Step 7.15: Extend CPP line class](https://github.com/DAB0mB/radial-snake/commit/66acf9d)\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;geometry&#x2F;line.js\n```diff\n@@ -1,46 +1,10 @@\n-â”Š 1â”Š  â”ŠEngine.Geometry.Line = class Line {\n-â”Š 2â”Š  â”Š  // x1 - The first point's x value\n-â”Š 3â”Š  â”Š  // y1 - The first point's y value\n-â”Š 4â”Š  â”Š  // x1 - The second point's x value\n-â”Š 5â”Š  â”Š  // y2 - The second point's y value\n-â”Š 6â”Š  â”Š  constructor(x1, y1, x2, y2) {\n-â”Š 7â”Š  â”Š    this.x1 = Utils.trim(x1, 9);\n-â”Š 8â”Š  â”Š    this.y1 = Utils.trim(y1, 9);\n-â”Š 9â”Š  â”Š    this.x2 = Utils.trim(x2, 9);\n-â”Š10â”Š  â”Š    this.y2 = Utils.trim(y2, 9);\n-â”Š11â”Š  â”Š  }\n-â”Š12â”Š  â”Š\n+â”Š  â”Š 1â”ŠEngine.Geometry.Line = class Line extends Utils.proxy(CPP.Geometry.Line) {\n â”Š13â”Š 2â”Š  // Draws the line on the given context\n â”Š14â”Š 3â”Š  draw(context) {\n â”Š15â”Š 4â”Š    context.moveTo(this.x1, this.y1);\n â”Š16â”Š 5â”Š    context.lineTo(this.x2, this.y2);\n â”Š17â”Š 6â”Š  }\n â”Š18â”Š 7â”Š\n-â”Š19â”Š  â”Š  // Gets the matching x value for a given y value\n-â”Š20â”Š  â”Š  getX(y) {\n-â”Š21â”Š  â”Š    let x = Utils.trim((((y - this.y1) * (this.x2 - this.x1)) / (this.y2 - this.y1)) + this.x1, 9);\n-â”Š22â”Š  â”Š    if (isNaN(x) || Utils.isBetween(x, this.x1, this.x2)) return x;\n-â”Š23â”Š  â”Š  }\n-â”Š24â”Š  â”Š\n-â”Š25â”Š  â”Š  // Gets the matching y value for a given x value\n-â”Š26â”Š  â”Š  getY(x) {\n-â”Š27â”Š  â”Š    let y = Utils.trim((((x - this.x1) * (this.y2 - this.y1)) / (this.x2 - this.x1)) + this.y1, 9);\n-â”Š28â”Š  â”Š    if (isNaN(y) || Utils.isBetween(y, this.y1, this.y2)) return y;\n-â”Š29â”Š  â”Š  }\n-â”Š30â”Š  â”Š\n-â”Š31â”Š  â”Š  // Returns if line has given point\n-â”Š32â”Š  â”Š  hasPoint(x, y) {\n-â”Š33â”Š  â”Š    if (!this.boundsHavePoint(x, y)) return false;\n-â”Š34â”Š  â”Š    let m = Utils.trim((this.y2 - this.y1) / (this.x2 - this.x1), 9);\n-â”Š35â”Š  â”Š    return (y - this.y1) / (x - this.x1) == m;\n-â”Š36â”Š  â”Š  }\n-â”Š37â”Š  â”Š\n-â”Š38â”Š  â”Š  // Returns if given point is contained by the bounds aka cage of line\n-â”Š39â”Š  â”Š  boundsHavePoint(x, y) {\n-â”Š40â”Š  â”Š    return Utils.isBetween(x, this.x1, this.x2) &&\n-â”Š41â”Š  â”Š           Utils.isBetween(y, this.y1, this.y2);\n-â”Š42â”Š  â”Š  }\n-â”Š43â”Š  â”Š\n â”Š44â”Š 8â”Š  getIntersection(shape) {\n â”Š45â”Š 9â”Š    if (shape instanceof Engine.Geometry.Line)\n â”Š46â”Š10â”Š      return this.getLineIntersection(shape);\n```\n```diff\n@@ -50,23 +14,6 @@\n â”Š50â”Š14â”Š      return this.getPolygonIntersection(shape);\n â”Š51â”Š15â”Š  }\n â”Š52â”Š16â”Š\n-â”Š53â”Š  â”Š  // line - line intersection method\n-â”Š54â”Š  â”Š  getLineIntersection(line) {\n-â”Š55â”Š  â”Š    // Escape if lines are parallel\n-â”Š56â”Š  â”Š    if (!(((this.x1 - this.x2) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * (line.x1 - line.x2)))) return;\n-â”Š57â”Š  â”Š\n-â”Š58â”Š  â”Š    // Intersection point formula\n-â”Š59â”Š  â”Š    let x = Utils.trim(((((this.x1 * this.y2) - (this.y1 * this.x2)) * (line.x1 - line.x2)) - ((this.x1 - this.x2) * ((line.x1 * line.y2) - (line.y1 * line.x2)))) /\n-â”Š60â”Š  â”Š        (((this.x1 - this.x2) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * (line.x1 - line.x2))), 9);\n-â”Š61â”Š  â”Š    let y = Utils.trim(((((this.x1 * this.y2) - (this.y1 * this.x2)) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * ((line.x1 * line.y2) - (line.y1 * line.x2)))) /\n-â”Š62â”Š  â”Š        (((this.x1 - this.x2) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * (line.x1 - line.x2))), 9);\n-â”Š63â”Š  â”Š\n-â”Š64â”Š  â”Š    if (Utils.isBetween(x, this.x1, this.x2) && Utils.isBetween(x, line.x1, line.x2) &&\n-â”Š65â”Š  â”Š        Utils.isBetween(y, this.y1, this.y2) && Utils.isBetween(y, line.y1, line.y2)) {\n-â”Š66â”Š  â”Š      return { x, y };\n-â”Š67â”Š  â”Š    }\n-â”Š68â”Š  â”Š  }\n-â”Š69â”Š  â”Š\n â”Š70â”Š17â”Š  // line - circle intersection method\n â”Š71â”Š18â”Š  getCircleIntersection(circle) {\n â”Š72â”Š19â”Š    return circle.getLineIntersection(this);\n```\n\n[}]: #\n\nBy now, our tests should pass. Accept, there is memory leak we need to handle. But you probably ask yourself - \"What memory leak? It's JavaScript man! Have you ever heard of something called garbage collector?!\". Well, this is not the case when compiling C++ code with Emscripten. You see, Emscripten uses asm.js, which is a subset for JavaScript built exactly for these proposes, enabling C++ modules run on the browser. This is how the [WebGL](https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API) project actually started, an almost complete conversion from the famous C++ [OpenGL](https://www.opengl.org/) to JavaScript. Part of what asm.js does, it disables the garbage collector, and instead, it holds raw pointers, just like in C++. Since returned class instances are pointers with unknown lifespans, they need to be disposed manually, using the `delete` method (identical to how we clear memory from the Heap in C++). Let's dispose unused test data by calling the `delete` method as just mentioned:\n\n[{]: <helper> (diffStep 7.16)\n\n#### [Step 7.16: Delete line instances in tests](https://github.com/DAB0mB/radial-snake/commit/f181da4)\n\n##### Changed resources&#x2F;scripts&#x2F;specs&#x2F;engine&#x2F;geometry&#x2F;circle.js\n```diff\n@@ -111,6 +111,8 @@\n â”Š111â”Š111â”Š          { x: 6, y: 1 },\n â”Š112â”Š112â”Š          { x: -4, y: 1 }\n â”Š113â”Š113â”Š        ]);\n+â”Š   â”Š114â”Š\n+â”Š   â”Š115â”Š        line.delete();\n â”Š114â”Š116â”Š      });\n â”Š115â”Š117â”Š    });\n â”Š116â”Š118â”Š\n```\n```diff\n@@ -121,6 +123,8 @@\n â”Š121â”Š123â”Š        expect(this.circle.getLineIntersection(line)).toEqual([\n â”Š122â”Š124â”Š          { x: -4, y: 1 }\n â”Š123â”Š125â”Š        ]);\n+â”Š   â”Š126â”Š\n+â”Š   â”Š127â”Š        line.delete();\n â”Š124â”Š128â”Š      });\n â”Š125â”Š129â”Š    });\n â”Š126â”Š130â”Š\n```\n```diff\n@@ -131,6 +135,8 @@\n â”Š131â”Š135â”Š        expect(this.circle.getLineIntersection(line)).toEqual([\n â”Š132â”Š136â”Š          { x: 1, y: 6 }\n â”Š133â”Š137â”Š        ]);\n+â”Š   â”Š138â”Š\n+â”Š   â”Š139â”Š        line.delete();\n â”Š134â”Š140â”Š      });\n â”Š135â”Š141â”Š    });\n â”Š136â”Š142â”Š\n```\n```diff\n@@ -138,6 +144,7 @@\n â”Š138â”Š144â”Š      it(\"returns nothing\", function() {\n â”Š139â”Š145â”Š        let line = new Engine.Geometry.Line(-10, 10, 10, 10);\n â”Š140â”Š146â”Š        expect(this.circle.getLineIntersection(line)).toBeUndefined();\n+â”Š   â”Š147â”Š        line.delete();\n â”Š141â”Š148â”Š      });\n â”Š142â”Š149â”Š    });\n â”Š143â”Š150â”Š  });\n```\n\n##### Changed resources&#x2F;scripts&#x2F;specs&#x2F;engine&#x2F;geometry&#x2F;line.js\n```diff\n@@ -3,6 +3,10 @@\n â”Š 3â”Š 3â”Š    this.line = new Engine.Geometry.Line(-5, -5, 5, 5);\n â”Š 4â”Š 4â”Š  });\n â”Š 5â”Š 5â”Š\n+â”Š  â”Š 6â”Š  afterEach(function () {\n+â”Š  â”Š 7â”Š    this.line.delete();\n+â”Š  â”Š 8â”Š  });\n+â”Š  â”Š 9â”Š\n â”Š 6â”Š10â”Š  describe(\"getX method\", function() {\n â”Š 7â”Š11â”Š    describe(\"given inranged y\", function() {\n â”Š 8â”Š12â”Š      it(\"returns x\", function() {\n```\n```diff\n@@ -58,6 +62,8 @@\n â”Š58â”Š62â”Š          x: 1,\n â”Š59â”Š63â”Š          y: 1\n â”Š60â”Š64â”Š        });\n+â”Š  â”Š65â”Š\n+â”Š  â”Š66â”Š        line.delete();\n â”Š61â”Š67â”Š      });\n â”Š62â”Š68â”Š    });\n â”Š63â”Š69â”Š\n```\n```diff\n@@ -65,6 +71,7 @@\n â”Š65â”Š71â”Š      it(\"returns nothing\", function() {\n â”Š66â”Š72â”Š        let line = new Engine.Geometry.Line(-5, -6, 5, 4);\n â”Š67â”Š73â”Š        expect(this.line.getLineIntersection(line)).toBeUndefined();\n+â”Š  â”Š74â”Š        line.delete();\n â”Š68â”Š75â”Š      });\n â”Š69â”Š76â”Š    });\n â”Š70â”Š77â”Š\n```\n```diff\n@@ -72,6 +79,7 @@\n â”Š72â”Š79â”Š      it(\"returns nothing\", function() {\n â”Š73â”Š80â”Š        let line = new Engine.Geometry.Line(10, 10, 10, 15);\n â”Š74â”Š81â”Š        expect(this.line.getLineIntersection(line)).toBeUndefined();\n+â”Š  â”Š82â”Š        line.delete();\n â”Š75â”Š83â”Š      });\n â”Š76â”Š84â”Š    });\n â”Š77â”Š85â”Š  });\n```\n\n##### Changed resources&#x2F;scripts&#x2F;specs&#x2F;engine&#x2F;geometry&#x2F;polygon.js\n```diff\n@@ -35,6 +35,8 @@\n â”Š35â”Š35â”Š          { x: 5, y: 4 },\n â”Š36â”Š36â”Š          { x: 0, y: 1 }\n â”Š37â”Š37â”Š        ]);\n+â”Š  â”Š38â”Š\n+â”Š  â”Š39â”Š        line.delete();\n â”Š38â”Š40â”Š      });\n â”Š39â”Š41â”Š    });\n â”Š40â”Š42â”Š\n```\n```diff\n@@ -43,6 +45,8 @@\n â”Š43â”Š45â”Š        let line = new Engine.Geometry.Line(10, 11, 15, 14);\n â”Š44â”Š46â”Š\n â”Š45â”Š47â”Š        expect(this.polygon.getLineIntersection(line)).toBeUndefined();\n+â”Š  â”Š48â”Š\n+â”Š  â”Š49â”Š        line.delete();\n â”Š46â”Š50â”Š      });\n â”Š47â”Š51â”Š    });\n â”Š48â”Š52â”Š  });\n```\n\n[}]: #\n\nSince our game also uses polygons, which is made of an abstract number of lines, its test-data needs to be disposed as well. First, we will add a `delete` method to the polygon class, which will simply go though all its bounds and delete each of its lines:\n\n[{]: <helper> (diffStep 7.17)\n\n#### [Step 7.17: Add polygon deletion method](https://github.com/DAB0mB/radial-snake/commit/1c9447f)\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;geometry&#x2F;polygon.js\n```diff\n@@ -5,6 +5,10 @@\n â”Š 5â”Š 5â”Š    this.bounds = bounds.map(coords => new Engine.Geometry.Line(...coords));\n â”Š 6â”Š 6â”Š  }\n â”Š 7â”Š 7â”Š\n+â”Š  â”Š 8â”Š  delete() {\n+â”Š  â”Š 9â”Š    this.bounds.forEach(bound => bound.delete());\n+â”Š  â”Š10â”Š  }\n+â”Š  â”Š11â”Š\n â”Š 8â”Š12â”Š  // Returns if polygon has given point\n â”Š 9â”Š13â”Š  hasPoint(x, y) {\n â”Š10â”Š14â”Š    // Run check for each bound\n```\n\n[}]: #\n\nNow we can conveniently delete unused polygons in the tests:\n\n[{]: <helper> (diffStep 7.18)\n\n#### [Step 7.18: Delete polygon instances in tests](https://github.com/DAB0mB/radial-snake/commit/48024bc)\n\n##### Changed resources&#x2F;scripts&#x2F;specs&#x2F;engine&#x2F;geometry&#x2F;polygon.js\n```diff\n@@ -8,6 +8,10 @@\n â”Š 8â”Š 8â”Š    );\n â”Š 9â”Š 9â”Š  });\n â”Š10â”Š10â”Š\n+â”Š  â”Š11â”Š  afterEach(function () {\n+â”Š  â”Š12â”Š    this.polygon.delete();\n+â”Š  â”Š13â”Š  });\n+â”Š  â”Š14â”Š\n â”Š11â”Š15â”Š  describe(\"hasPoint method\", function() {\n â”Š12â”Š16â”Š    describe(\"given contained point\", function() {\n â”Š13â”Š17â”Š      it(\"returns true\", function() {\n```\n\n[}]: #\n\nMoving on, we have the circle class to transform. The process is almost the identical to how we transformed the line class, so it's gonna be way easier now. We first start by translating our code from JavaScript to C++:\n\n[{]: <helper> (diffStep 7.19)\n\n#### [Step 7.19: Add base circle CPP module](https://github.com/DAB0mB/radial-snake/commit/1a3fa58)\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;geometry&#x2F;circle.cpp\n```diff\n@@ -0,0 +1,202 @@\n+â”Š   â”Š  1â”Š\n+â”Š   â”Š  2â”Š#include <algorithm>\n+â”Š   â”Š  3â”Š#include <cmath>\n+â”Š   â”Š  4â”Š#include <vector>\n+â”Š   â”Š  5â”Š#include \"../nullable.h\"\n+â”Š   â”Š  6â”Š#include \"../utils.h\"\n+â”Š   â”Š  7â”Š#include \"point.h\"\n+â”Š   â”Š  8â”Š#include \"line.h\"\n+â”Š   â”Š  9â”Š\n+â”Š   â”Š 10â”Šnamespace geometry {\n+â”Š   â”Š 11â”Š  // x - The x value of the circle's center\n+â”Š   â”Š 12â”Š  // y - The y value of the circle's center\n+â”Š   â”Š 13â”Š  // r - The radius of the center\n+â”Š   â”Š 14â”Š  // rad1 - The first radian of the circle, not necessarily its beginning\n+â”Š   â”Š 15â”Š  // rad2 - The second radian of the circle, not necessarily its beginning\n+â”Š   â”Š 16â”Š  Circle::Circle(double x, double y, double r, double rad1, double rad2) {\n+â”Š   â”Š 17â”Š    _x = utils::trim(x, 9);\n+â”Š   â”Š 18â”Š    _y = utils::trim(y, 9);\n+â”Š   â”Š 19â”Š    _r = utils::trim(r, 9);\n+â”Š   â”Š 20â”Š\n+â”Š   â”Š 21â”Š    // Trimming mode is done based on which radian represents the ending and which radian\n+â”Š   â”Š 22â”Š    // represents the ending\n+â”Š   â”Š 23â”Š    if (rad1 > rad2) {\n+â”Š   â”Š 24â”Š      _rad1 = utils::trim(rad1, 9, \"floor\");\n+â”Š   â”Š 25â”Š      _rad2 = utils::trim(rad2, 9, \"ceil\");\n+â”Š   â”Š 26â”Š    }\n+â”Š   â”Š 27â”Š    else {\n+â”Š   â”Š 28â”Š      _rad1 = utils::trim(rad1, 9, \"ceil\");\n+â”Š   â”Š 29â”Š      _rad2 = utils::trim(rad2, 9, \"floor\");\n+â”Š   â”Š 30â”Š    }\n+â”Š   â”Š 31â”Š  }\n+â”Š   â”Š 32â”Š\n+â”Š   â”Š 33â”Š  // Gets the matching x value for the given radian\n+â”Š   â”Š 34â”Š  Nullable<double> Circle::getMatchingX(double rad) {\n+â”Š   â”Š 35â”Š    if (!utils::chain(rad)->trim(9)->isBetween(_rad1, _rad2)->result()) {\n+â”Š   â”Š 36â”Š      return Nullable<double>();\n+â”Š   â”Š 37â”Š    }\n+â”Š   â”Š 38â”Š\n+â”Š   â”Š 39â”Š    return Nullable<double>(utils::trim((_r * std::cos(rad)) + _x, 9));\n+â”Š   â”Š 40â”Š  }\n+â”Š   â”Š 41â”Š\n+â”Š   â”Š 42â”Š  // Gets the matching y value for the given radian\n+â”Š   â”Š 43â”Š  Nullable<double> Circle::getMatchingY(double rad) {\n+â”Š   â”Š 44â”Š    if (!utils::chain(rad)->trim(9)->isBetween(_rad1, _rad2)->result()) {\n+â”Š   â”Š 45â”Š      return Nullable<double>();\n+â”Š   â”Š 46â”Š    }\n+â”Š   â”Š 47â”Š\n+â”Š   â”Š 48â”Š    return Nullable<double>(utils::trim((_r * std::sin(rad)) + _y, 9));\n+â”Š   â”Š 49â”Š  }\n+â”Š   â”Š 50â”Š\n+â”Š   â”Š 51â”Š  // Gets the matching point for the given radian\n+â”Š   â”Š 52â”Š  Nullable<Point> Circle::getMatchingPoint(double rad) {\n+â”Š   â”Š 53â”Š    if (!utils::isBetween(rad, _rad1, _rad2)) {\n+â”Š   â”Š 54â”Š      return Nullable<Point>();\n+â”Š   â”Š 55â”Š    }\n+â”Š   â”Š 56â”Š\n+â”Š   â”Š 57â”Š    return Nullable<Point>({\n+â”Š   â”Š 58â”Š      utils::trim((_r * std::cos(rad)) + _x, 9),\n+â”Š   â”Š 59â”Š      utils::trim((_r * std::sin(rad)) + _y, 9)\n+â”Š   â”Š 60â”Š    });\n+â”Š   â”Š 61â”Š  }\n+â”Š   â”Š 62â”Š\n+â”Š   â”Š 63â”Š  // Gets the matching radian for the given point\n+â”Š   â”Š 64â”Š  Nullable<double> Circle::getMatchingRad(double x, double y) {\n+â”Š   â”Š 65â”Š    double rad = std::atan2(y - _y, x - _x);\n+â”Š   â”Š 66â”Š\n+â”Š   â”Š 67â”Š    // If calculated radian is in circle's radian range, return it\n+â”Š   â”Š 68â”Š    if (!std::isnan(rad) && utils::isBetween(rad, _rad1, _rad2)) {\n+â”Š   â”Š 69â”Š      return Nullable<double>(rad);\n+â”Š   â”Š 70â”Š    }\n+â”Š   â”Š 71â”Š\n+â”Š   â”Š 72â”Š    // The calculated radian can still be in the circle's radian range in case one\n+â”Š   â”Š 73â”Š    // of the radians is greater than 2 PIEs\n+â”Š   â”Š 74â”Š    double greatestRad = std::abs(_rad1) > std::abs(_rad2) ? _rad1 : _rad2;\n+â”Š   â”Š 75â”Š\n+â”Š   â”Š 76â”Š    // Check if the absolute radian is in the circle's radian range\n+â”Š   â”Š 77â”Š    if (utils::chain(rad + (2 * M_PI * std::floor(greatestRad / (2 * M_PI))))\n+â”Š   â”Š 78â”Š        ->trim(9)->isBetween(_rad1, _rad2)->result() ||\n+â”Š   â”Š 79â”Š        utils::chain(rad + (2 * M_PI * std::ceil(greatestRad / (2 * M_PI))))\n+â”Š   â”Š 80â”Š        ->trim(9)->isBetween(_rad1, _rad2)->result()) {\n+â”Š   â”Š 81â”Š      return Nullable<double>(rad);\n+â”Š   â”Š 82â”Š    }\n+â”Š   â”Š 83â”Š\n+â”Š   â”Š 84â”Š    return Nullable<double>();\n+â”Š   â”Š 85â”Š  }\n+â”Š   â”Š 86â”Š\n+â”Š   â”Š 87â”Š  // Returns if circle has given points\n+â”Š   â”Š 88â”Š  bool Circle::hasPoint(double x, double y) {\n+â”Š   â”Š 89â”Š    return getMatchingRad(x, y).hasValue();\n+â”Š   â”Š 90â”Š  }\n+â”Š   â”Š 91â”Š\n+â”Š   â”Š 92â”Š  // circle - circle intersection method\n+â”Š   â”Š 93â”Š  Nullable<std::vector<Point>> Circle::getIntersection(Circle circle) {\n+â”Š   â”Š 94â”Š    double dx = circle._x - _x;\n+â”Š   â”Š 95â”Š    double dy = circle._y - _y;\n+â”Š   â”Š 96â”Š    double d = std::sqrt(std::pow(dx, 2) + std::pow(dy, 2));\n+â”Š   â”Š 97â”Š\n+â”Š   â”Š 98â”Š    if (d > _r + circle._r ||\n+â”Š   â”Š 99â”Š       d < std::abs(_r - circle._r)) {\n+â”Š   â”Š100â”Š      return Nullable<std::vector<Point>>();\n+â”Š   â”Š101â”Š    }\n+â”Š   â”Š102â”Š\n+â”Š   â”Š103â”Š    double a = ((std::pow(_r, 2) - std::pow(circle._r, 2)) + std::pow(d, 2)) / (2 * d);\n+â”Š   â”Š104â”Š    double x = _x + ((dx * a) / d);\n+â”Š   â”Š105â”Š    double y = _y + ((dy * a) / d);\n+â”Š   â”Š106â”Š    double h = std::sqrt(std::pow(_r, 2) - std::pow(a, 2));\n+â”Š   â”Š107â”Š    double rx = (- dy * h) / d;\n+â”Š   â”Š108â”Š    double ry = (dx * h) / d;\n+â”Š   â”Š109â”Š\n+â”Š   â”Š110â”Š    std::vector<Point> interPoints(2);\n+â”Š   â”Š111â”Š    interPoints.at(0).x = x + rx;\n+â”Š   â”Š112â”Š    interPoints.at(0).y = y + ry;\n+â”Š   â”Š113â”Š    interPoints.at(1).x = x - rx;\n+â”Š   â”Š114â”Š    interPoints.at(1).y = y - ry;\n+â”Š   â”Š115â”Š\n+â”Š   â”Š116â”Š    for (unsigned i = 0; i < interPoints.size(); i++) {\n+â”Š   â”Š117â”Š      Point& point = interPoints.at(i);\n+â”Š   â”Š118â”Š      point.x = utils::trim(point.x, 9);\n+â”Š   â”Š119â”Š      point.y = utils::trim(point.y, 9);\n+â”Š   â”Š120â”Š    }\n+â”Š   â”Š121â”Š\n+â”Š   â”Š122â”Š    auto pointsBegin = std::unique(interPoints.begin(), interPoints.end(),\n+â”Š   â”Š123â”Š      [](Point pointA, Point pointB) {\n+â”Š   â”Š124â”Š        return pointA.x == pointB.x && pointA.y == pointB.y;\n+â”Š   â”Š125â”Š      }\n+â”Š   â”Š126â”Š    );\n+â”Š   â”Š127â”Š\n+â”Š   â”Š128â”Š    interPoints.erase(pointsBegin, interPoints.end());\n+â”Š   â”Š129â”Š\n+â”Š   â”Š130â”Š    std::vector<Circle> circles = { *this, circle };\n+â”Š   â”Š131â”Š\n+â”Š   â”Š132â”Š    std::for_each(circles.begin(), circles.end(), [&interPoints](Circle circle) {\n+â”Š   â”Š133â”Š      auto pointsBegin = std::remove_if(interPoints.begin(), interPoints.end(),\n+â”Š   â”Š134â”Š        [&circle](Point point) {\n+â”Š   â”Š135â”Š          return !circle.hasPoint(point.x, point.y);\n+â”Š   â”Š136â”Š        }\n+â”Š   â”Š137â”Š      );\n+â”Š   â”Š138â”Š\n+â”Š   â”Š139â”Š      interPoints.erase(pointsBegin, interPoints.end());\n+â”Š   â”Š140â”Š    });\n+â”Š   â”Š141â”Š\n+â”Š   â”Š142â”Š    if (interPoints.size()) {\n+â”Š   â”Š143â”Š      return Nullable<std::vector<Point>>(interPoints);\n+â”Š   â”Š144â”Š    }\n+â”Š   â”Š145â”Š\n+â”Š   â”Š146â”Š    return Nullable<std::vector<Point>>();\n+â”Š   â”Š147â”Š  }\n+â”Š   â”Š148â”Š\n+â”Š   â”Š149â”Š  // circle - line intersection method\n+â”Š   â”Š150â”Š  Nullable<std::vector<Point>> Circle::getIntersection(Line line) {\n+â”Š   â”Š151â”Š    double x1 = line._x1 - _x;\n+â”Š   â”Š152â”Š    double x2 = line._x2 - _x;\n+â”Š   â”Š153â”Š    double y1 = line._y1 - _y;\n+â”Š   â”Š154â”Š    double y2 = line._y2 - _y;\n+â”Š   â”Š155â”Š    double dx = x2 - x1;\n+â”Š   â”Š156â”Š    double dy = y2 - y1;\n+â”Š   â”Š157â”Š    double d = std::sqrt(std::pow(dx, 2) + std::pow(dy, 2));\n+â”Š   â”Š158â”Š    double h = (x1 * y2) - (x2 * y1);\n+â”Š   â”Š159â”Š    double delta = (std::pow(_r, 2) * std::pow(d, 2)) - std::pow(h, 2);\n+â”Š   â”Š160â”Š\n+â”Š   â”Š161â”Š    if (delta < 0) Nullable<std::vector<Point>>();\n+â”Š   â”Š162â”Š\n+â”Š   â”Š163â”Š    double sign = dy / std::abs(dy); if (std::isnan(sign)) sign = 1;\n+â”Š   â”Š164â”Š    double sqrtx = sign * dx * std::sqrt(delta);\n+â”Š   â”Š165â”Š    double sqrty = std::abs(dy) * std::sqrt(delta);\n+â”Š   â”Š166â”Š\n+â”Š   â”Š167â”Š    std::vector<Point> interPoints(2);\n+â”Š   â”Š168â”Š    interPoints.at(0).x = (((h * dy) + sqrtx) / std::pow(d, 2)) + _x;\n+â”Š   â”Š169â”Š    interPoints.at(0).y = (((-h * dx) + sqrty) / std::pow(d, 2)) + _y;\n+â”Š   â”Š170â”Š    interPoints.at(1).x = (((h * dy) - sqrtx) / std::pow(d, 2)) + _x;\n+â”Š   â”Š171â”Š    interPoints.at(1).y = (((-h * dx) - sqrty) / std::pow(d, 2)) + _y;\n+â”Š   â”Š172â”Š\n+â”Š   â”Š173â”Š    for (unsigned i = 0; i < interPoints.size(); i++) {\n+â”Š   â”Š174â”Š      Point& point = interPoints.at(i);\n+â”Š   â”Š175â”Š      point.x = utils::trim(point.x, 9);\n+â”Š   â”Š176â”Š      point.y = utils::trim(point.y, 9);\n+â”Š   â”Š177â”Š    }\n+â”Š   â”Š178â”Š\n+â”Š   â”Š179â”Š    auto pointsBegin = std::remove_if(interPoints.begin(), interPoints.end(),\n+â”Š   â”Š180â”Š      [this, &line](Point point) {\n+â”Š   â”Š181â”Š        return !hasPoint(point.x, point.y) ||\n+â”Š   â”Š182â”Š          !line.boundsHavePoint(point.x, point.y);\n+â”Š   â”Š183â”Š      }\n+â”Š   â”Š184â”Š    );\n+â”Š   â”Š185â”Š\n+â”Š   â”Š186â”Š    interPoints.erase(pointsBegin, interPoints.end());\n+â”Š   â”Š187â”Š\n+â”Š   â”Š188â”Š    pointsBegin = std::unique(interPoints.begin(), interPoints.end(),\n+â”Š   â”Š189â”Š      [](Point pointA, Point pointB) {\n+â”Š   â”Š190â”Š        return pointA.x == pointB.x && pointA.y == pointB.y;\n+â”Š   â”Š191â”Š      }\n+â”Š   â”Š192â”Š    );\n+â”Š   â”Š193â”Š\n+â”Š   â”Š194â”Š    interPoints.erase(pointsBegin, interPoints.end());\n+â”Š   â”Š195â”Š\n+â”Š   â”Š196â”Š    if (interPoints.size()) {\n+â”Š   â”Š197â”Š      return Nullable<std::vector<Point>>(interPoints);\n+â”Š   â”Š198â”Š    }\n+â”Š   â”Š199â”Š\n+â”Š   â”Š200â”Š    return Nullable<std::vector<Point>>();\n+â”Š   â”Š201â”Š  }\n+â”Š   â”Š202â”Š}ðŸš«â†µ\n```\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;geometry&#x2F;circle.h\n```diff\n@@ -0,0 +1,35 @@\n+â”Š  â”Š 1â”Š#pragma once\n+â”Š  â”Š 2â”Š\n+â”Š  â”Š 3â”Š#include <vector>\n+â”Š  â”Š 4â”Š#include \"../nullable.h\"\n+â”Š  â”Š 5â”Š#include \"point.h\"\n+â”Š  â”Š 6â”Š#include \"line.h\"\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Šnamespace geometry {\n+â”Š  â”Š 9â”Š  class Line;\n+â”Š  â”Š10â”Š\n+â”Š  â”Š11â”Š  class Circle {\n+â”Š  â”Š12â”Š  public:\n+â”Š  â”Š13â”Š    double _x;\n+â”Š  â”Š14â”Š    double _y;\n+â”Š  â”Š15â”Š    double _r;\n+â”Š  â”Š16â”Š    double _rad1;\n+â”Š  â”Š17â”Š    double _rad2;\n+â”Š  â”Š18â”Š\n+â”Š  â”Š19â”Š    Circle(double x, double y, double r, double rad1, double rad2);\n+â”Š  â”Š20â”Š\n+â”Š  â”Š21â”Š    Nullable<double> getMatchingX(double rad);\n+â”Š  â”Š22â”Š\n+â”Š  â”Š23â”Š    Nullable<double> getMatchingY(double rad);\n+â”Š  â”Š24â”Š\n+â”Š  â”Š25â”Š    Nullable<Point> getMatchingPoint(double rad);\n+â”Š  â”Š26â”Š\n+â”Š  â”Š27â”Š    Nullable<double> getMatchingRad(double x, double y);\n+â”Š  â”Š28â”Š\n+â”Š  â”Š29â”Š    bool hasPoint(double x, double y);\n+â”Š  â”Š30â”Š\n+â”Š  â”Š31â”Š    Nullable<std::vector<Point>> getIntersection(Circle circle);\n+â”Š  â”Š32â”Š\n+â”Š  â”Š33â”Š    Nullable<std::vector<Point>> getIntersection(Line line);\n+â”Š  â”Š34â”Š  };\n+â”Š  â”Š35â”Š}ðŸš«â†µ\n```\n\n##### Changed resources&#x2F;cpp&#x2F;src&#x2F;index.cpp\n```diff\n@@ -1,3 +1,4 @@\n â”Š1â”Š1â”Š#include \"nullable.cpp\"\n â”Š2â”Š2â”Š#include \"utils.cpp\"\n-â”Š3â”Š â”Š#include \"geometry/line.cpp\"ðŸš«â†µ\n+â”Š â”Š3â”Š#include \"geometry/line.cpp\"\n+â”Š â”Š4â”Š#include \"geometry/circle.cpp\"ðŸš«â†µ\n```\n\n[}]: #\n\nSecond, we need to wrap our code using EMBind:\n\n[{]: <helper> (diffStep 7.2)\n\n#### [Step 7.2: Add base utility CPP module](https://github.com/DAB0mB/radial-snake/commit/6dba512)\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;utils.cpp\n```diff\n@@ -0,0 +1,73 @@\n+â”Š  â”Š 1â”Š#include <cfloat>\n+â”Š  â”Š 2â”Š#include <cmath>\n+â”Š  â”Š 3â”Š#include <string>\n+â”Š  â”Š 4â”Š#include \"utils.h\"\n+â”Š  â”Š 5â”Š\n+â”Š  â”Š 6â”Šnamespace utils {\n+â”Š  â”Š 7â”Š  // Fixed modulo method which can calculate modulo of negative numbers properly\n+â”Š  â”Š 8â”Š  // e.g. (-803).mod(800) returns 797\n+â”Š  â”Š 9â”Š  double mod(double context, double num) {\n+â”Š  â”Š10â”Š    return std::fmod((std::fmod(context, num) + num), num);\n+â”Š  â”Š11â”Š  }\n+â”Š  â”Š12â”Š\n+â”Š  â”Š13â”Š  // Trims number and leaves the number of decimals specified.\n+â”Š  â”Š14â”Š  // The \"mode\" argument specifies which math function should be invoked\n+â”Š  â”Š15â”Š  // right after the number has been trimmed.\n+â”Š  â”Š16â”Š  // e.g. 12.12345.trim(3, \"ceil\") returns 12.124\n+â”Š  â”Š17â”Š  double trim(double context, int decimals, const std::string mode) {\n+â”Š  â”Š18â”Š    double accumulator = context * std::pow(10, decimals);\n+â”Š  â”Š19â”Š\n+â”Š  â”Š20â”Š    if (mode.compare(\"ceil\") == 0)\n+â”Š  â”Š21â”Š      accumulator = std::ceil(accumulator);\n+â”Š  â”Š22â”Š    else if (mode.compare(\"floor\") == 0)\n+â”Š  â”Š23â”Š      accumulator = std::floor(accumulator);\n+â”Š  â”Š24â”Š    else\n+â”Š  â”Š25â”Š      accumulator = std::round(accumulator);\n+â”Š  â”Š26â”Š\n+â”Š  â”Š27â”Š    return accumulator / std::pow(10, decimals);\n+â”Š  â”Š28â”Š  }\n+â”Š  â”Š29â”Š\n+â”Š  â”Š30â”Š  // Tells if number is in specified range based on given precision.\n+â”Š  â”Š31â”Š  // See the \"compare\" method for more information about precision\n+â”Š  â”Š32â”Š  bool isBetween(double context, double num1, double num2, const std::string precision) {\n+â”Š  â”Š33â”Š    return compare(context, std::min(num1, num2), \">=\", precision) &&\n+â”Š  â”Š34â”Š           compare(context, std::max(num1, num2), \"<=\", precision);\n+â”Š  â”Š35â”Š  }\n+â”Š  â”Š36â”Š\n+â”Š  â”Š37â”Š  bool compare(double context, double num, const std::string precision) {\n+â”Š  â”Š38â”Š    return compare(context, num, \"==\", precision);\n+â”Š  â”Š39â”Š  }\n+â”Š  â”Š40â”Š\n+â”Š  â”Š41â”Š  // Initiates comparison operator between context number and a given number, only here\n+â”Š  â”Š42â”Š  // a precision can be specified\n+â”Š  â”Š43â”Š  bool compare(double context, double num, const std::string method, const std::string precision) {\n+â”Š  â”Š44â”Š    // Fixed precision, \"almost equal\" with a deviation of Îµ\n+â”Š  â”Š45â”Š    if (precision.compare(\"f\") == 0) {\n+â”Š  â”Š46â”Š      if (method.compare(\"<\") == 0 ||\n+â”Š  â”Š47â”Š          method.compare(\"<=\") == 0)\n+â”Š  â”Š48â”Š        return context <= num + DBL_EPSILON;\n+â”Š  â”Š49â”Š      if (method.compare(\">\") == 0 ||\n+â”Š  â”Š50â”Š          method.compare(\">=\") == 0)\n+â”Š  â”Š51â”Š        return context >= num - DBL_EPSILON;\n+â”Š  â”Š52â”Š      return std::abs(context - num) <= DBL_EPSILON;\n+â”Š  â”Š53â”Š    }\n+â”Š  â”Š54â”Š    // Pixel precision, round comparison\n+â”Š  â”Š55â”Š    else if (precision.compare(\"px\") == 0) {\n+â”Š  â”Š56â”Š      if (method.compare(\"<\") == 0 ||\n+â”Š  â”Š57â”Š          method.compare(\"<=\") == 0)\n+â”Š  â”Š58â”Š        return std::round(context) <= std::round(num);\n+â”Š  â”Š59â”Š      if (method.compare(\">\") == 0 ||\n+â”Š  â”Š60â”Š          method.compare(\">=\") == 0)\n+â”Š  â”Š61â”Š        return std::round(context) >= std::round(num);\n+â”Š  â”Š62â”Š      return std::round(context) == std::round(num);\n+â”Š  â”Š63â”Š    }\n+â”Š  â”Š64â”Š    // Exact precision\n+â”Š  â”Š65â”Š    else {\n+â”Š  â”Š66â”Š      if (method.compare(\"<\") == 0) return context < num;\n+â”Š  â”Š67â”Š      if (method.compare(\"<=\") == 0) return context <= num;\n+â”Š  â”Š68â”Š      if (method.compare(\">\") == 0) return context > num;\n+â”Š  â”Š69â”Š      if (method.compare(\">=\") == 0) return context >= num;\n+â”Š  â”Š70â”Š      return context == num;\n+â”Š  â”Š71â”Š    }\n+â”Š  â”Š72â”Š  }\n+â”Š  â”Š73â”Š}ðŸš«â†µ\n```\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;utils.h\n```diff\n@@ -0,0 +1,15 @@\n+â”Š  â”Š 1â”Š#pragma once\n+â”Š  â”Š 2â”Š\n+â”Š  â”Š 3â”Š#include <string>\n+â”Š  â”Š 4â”Š\n+â”Š  â”Š 5â”Šnamespace utils {\n+â”Š  â”Š 6â”Š  double mod(double context, double num);\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Š  double trim(double context, int decimals, const std::string mode = \"round\");\n+â”Š  â”Š 9â”Š\n+â”Š  â”Š10â”Š  bool isBetween(double context, double num1, double num2, const std::string precision = \"exact\");\n+â”Š  â”Š11â”Š\n+â”Š  â”Š12â”Š  bool compare(double context, double num, const std::string precision = \"exact\");\n+â”Š  â”Š13â”Š\n+â”Š  â”Š14â”Š  bool compare(double context, double num, const std::string method, const std::string precision);\n+â”Š  â”Š15â”Š}ðŸš«â†µ\n```\n\n[}]: #\n\nAnd finally, we will extend the C++ in our JavaScript circle:\n\n[{]: <helper> (diffStep 7.21)\n\n#### [Step 7.21: Extend CPP circle class](https://github.com/DAB0mB/radial-snake/commit/d05cf32)\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;geometry&#x2F;circle.js\n```diff\n@@ -1,83 +1,9 @@\n-â”Š 1â”Š  â”ŠEngine.Geometry.Circle = class Circle {\n-â”Š 2â”Š  â”Š  // x - The x value of the circle's center\n-â”Š 3â”Š  â”Š  // y - The y value of the circle's center\n-â”Š 4â”Š  â”Š  // r - The radius of the center\n-â”Š 5â”Š  â”Š  // rad1 - The first radian of the circle, not necessarily its beginning\n-â”Š 6â”Š  â”Š  // rad2 - The second radian of the circle, not necessarily its beginning\n-â”Š 7â”Š  â”Š  constructor(x, y, r, rad1, rad2) {\n-â”Š 8â”Š  â”Š    this.x = Utils.trim(x, 9);\n-â”Š 9â”Š  â”Š    this.y = Utils.trim(y, 9);\n-â”Š10â”Š  â”Š    this.r = Utils.trim(r, 9);\n-â”Š11â”Š  â”Š\n-â”Š12â”Š  â”Š    // Trimming mode is done based on which radian represents the ending and which radian\n-â”Š13â”Š  â”Š    // represents the ending\n-â”Š14â”Š  â”Š    if (rad1 > rad2) {\n-â”Š15â”Š  â”Š      this.rad1 = Utils.trim(rad1, 9, \"floor\");\n-â”Š16â”Š  â”Š      this.rad2 = Utils.trim(rad2, 9, \"ceil\");\n-â”Š17â”Š  â”Š    }\n-â”Š18â”Š  â”Š    else {\n-â”Š19â”Š  â”Š      this.rad1 = Utils.trim(rad1, 9, \"ceil\");\n-â”Š20â”Š  â”Š      this.rad2 = Utils.trim(rad2, 9, \"floor\");\n-â”Š21â”Š  â”Š    }\n-â”Š22â”Š  â”Š  }\n-â”Š23â”Š  â”Š\n+â”Š  â”Š 1â”ŠEngine.Geometry.Circle = class Circle extends Utils.proxy(CPP.Geometry.Circle) {\n â”Š24â”Š 2â”Š  // Draws the circle on the given context\n â”Š25â”Š 3â”Š  draw(context) {\n â”Š26â”Š 4â”Š    context.arc(this.x, this.y, this.r, this.rad1, this.rad2);\n â”Š27â”Š 5â”Š  }\n â”Š28â”Š 6â”Š\n-â”Š29â”Š  â”Š  // Gets the matching x value for the given radian\n-â”Š30â”Š  â”Š  getX(rad) {\n-â”Š31â”Š  â”Š    if (!Utils(rad).trim(9).isBetween(this.rad1, this.rad2).value()) return;\n-â”Š32â”Š  â”Š    return Utils.trim((this.r * Math.cos(rad)) + this.x, 9);\n-â”Š33â”Š  â”Š  }\n-â”Š34â”Š  â”Š\n-â”Š35â”Š  â”Š  // Gets the matching y value for the given radian\n-â”Š36â”Š  â”Š  getY(rad) {\n-â”Š37â”Š  â”Š    if (!Utils(rad).trim(9).isBetween(this.rad1, this.rad2).value()) return;\n-â”Š38â”Š  â”Š    return Utils.trim((this.r * Math.sin(rad)) + this.y, 9);\n-â”Š39â”Š  â”Š  }\n-â”Š40â”Š  â”Š\n-â”Š41â”Š  â”Š  // Gets the matching point for the given radian\n-â”Š42â”Š  â”Š  getPoint(rad) {\n-â”Š43â”Š  â”Š    if (!Utils.isBetween(rad, this.rad1, this.rad2)) return;\n-â”Š44â”Š  â”Š\n-â”Š45â”Š  â”Š    return {\n-â”Š46â”Š  â”Š      x: Utils.trim((this.r * Math.cos(rad)) + this.x, 9),\n-â”Š47â”Š  â”Š      y: Utils.trim((this.r * Math.sin(rad)) + this.y, 9)\n-â”Š48â”Š  â”Š    };\n-â”Š49â”Š  â”Š  }\n-â”Š50â”Š  â”Š\n-â”Š51â”Š  â”Š  // Gets the matching radian for the given point\n-â”Š52â”Š  â”Š  getRad(x, y) {\n-â”Š53â”Š  â”Š    let rad = Math.atan2(y - this.y, x - this.x);\n-â”Š54â”Š  â”Š\n-â”Š55â”Š  â”Š    // If calculated radian is in circle's radian range, return it\n-â”Š56â”Š  â”Š    if (rad != null && Utils.isBetween(rad, this.rad1, this.rad2)) {\n-â”Š57â”Š  â”Š      return rad;\n-â”Š58â”Š  â”Š    }\n-â”Š59â”Š  â”Š\n-â”Š60â”Š  â”Š    // The calculated radian can still be in the circle's radian range in case one\n-â”Š61â”Š  â”Š    // of the radians is greater than 2 PIEs\n-â”Š62â”Š  â”Š    if (Math.abs(this.rad1) > Math.abs(this.rad2)) {\n-â”Š63â”Š  â”Š      var greatestRad = this.rad1;\n-â”Š64â”Š  â”Š    }\n-â”Š65â”Š  â”Š    else {\n-â”Š66â”Š  â”Š      var greatestRad = this.rad2;\n-â”Š67â”Š  â”Š    }\n-â”Š68â”Š  â”Š\n-â”Š69â”Š  â”Š    // Check if the absolute radian is in the circle's radian range\n-â”Š70â”Š  â”Š    if (Utils(rad + (2 * Math.PI * Math.floor(greatestRad / (2 * Math.PI)))).trim(9).isBetween(this.rad1, this.rad2).value() ||\n-â”Š71â”Š  â”Š        Utils(rad + (2 * Math.PI * Math.ceil(greatestRad / (2 * Math.PI)))).trim(9).isBetween(this.rad1, this.rad2).value()) {\n-â”Š72â”Š  â”Š      return rad;\n-â”Š73â”Š  â”Š    }\n-â”Š74â”Š  â”Š  }\n-â”Š75â”Š  â”Š\n-â”Š76â”Š  â”Š  // Returns if circle has given points\n-â”Š77â”Š  â”Š  hasPoint(x, y) {\n-â”Š78â”Š  â”Š    return this.getRad(x, y) != null;\n-â”Š79â”Š  â”Š  }\n-â”Š80â”Š  â”Š\n â”Š81â”Š 7â”Š  getIntersection(shape) {\n â”Š82â”Š 8â”Š    if (shape instanceof Engine.Geometry.Line)\n â”Š83â”Š 9â”Š      return this.getLineIntersection(shape);\n```\n```diff\n@@ -87,86 +13,6 @@\n â”Š 87â”Š 13â”Š      return this.getPolygonIntersection(shape);\n â”Š 88â”Š 14â”Š  }\n â”Š 89â”Š 15â”Š\n-â”Š 90â”Š   â”Š  // circle - circle intersection method\n-â”Š 91â”Š   â”Š  getCircleIntersection(circle) {\n-â”Š 92â”Š   â”Š    let dx = circle.x - this.x;\n-â”Š 93â”Š   â”Š    let dy = circle.y - this.y;\n-â”Š 94â”Š   â”Š    let d = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\n-â”Š 95â”Š   â”Š\n-â”Š 96â”Š   â”Š    if (d > this.r + circle.r ||\n-â”Š 97â”Š   â”Š       d < Math.abs(this.r - circle.r)) {\n-â”Š 98â”Š   â”Š      return;\n-â”Š 99â”Š   â”Š    }\n-â”Š100â”Š   â”Š\n-â”Š101â”Š   â”Š    let a = ((Math.pow(this.r, 2) - Math.pow(circle.r, 2)) + Math.pow(d, 2)) / (2 * d);\n-â”Š102â”Š   â”Š    let x = this.x + ((dx * a) / d);\n-â”Š103â”Š   â”Š    let y = this.y + ((dy * a) / d);\n-â”Š104â”Š   â”Š    let h = Math.sqrt(Math.pow(this.r, 2) - Math.pow(a, 2));\n-â”Š105â”Š   â”Š    let rx = (- dy * h) / d;\n-â”Š106â”Š   â”Š    let ry = (dx * h) / d;\n-â”Š107â”Š   â”Š\n-â”Š108â”Š   â”Š    let interPoints = [\n-â”Š109â”Š   â”Š      {\n-â”Š110â”Š   â”Š        x: x + rx,\n-â”Š111â”Š   â”Š        y: y + ry\n-â”Š112â”Š   â”Š      },\n-â”Š113â”Š   â”Š      {\n-â”Š114â”Š   â”Š        x: x - rx,\n-â”Š115â”Š   â”Š        y: y - ry\n-â”Š116â”Š   â”Š      }\n-â”Š117â”Š   â”Š    ]\n-â”Š118â”Š   â”Š    .map(point => ({\n-â”Š119â”Š   â”Š        x: Utils.trim(point.x, 9),\n-â”Š120â”Š   â”Š        y: Utils.trim(point.y, 9)\n-â”Š121â”Š   â”Š     }));\n-â”Š122â”Š   â”Š\n-â”Š123â”Š   â”Š    interPoints = _.uniq(interPoints, point => `(${point.x}, ${point.y})`);\n-â”Š124â”Š   â”Š\n-â”Š125â”Š   â”Š    [this, circle].forEach(function(circle) {\n-â”Š126â”Š   â”Š      interPoints = interPoints.filter(point => circle.hasPoint(point.x, point.y));\n-â”Š127â”Š   â”Š    });\n-â”Š128â”Š   â”Š\n-â”Š129â”Š   â”Š    if (interPoints.length > 0) return interPoints;\n-â”Š130â”Š   â”Š  }\n-â”Š131â”Š   â”Š\n-â”Š132â”Š   â”Š  // circle - line intersection method\n-â”Š133â”Š   â”Š  getLineIntersection(line) {\n-â”Š134â”Š   â”Š    let x1 = line.x1 - this.x;\n-â”Š135â”Š   â”Š    let x2 = line.x2 - this.x;\n-â”Š136â”Š   â”Š    let y1 = line.y1 - this.y;\n-â”Š137â”Š   â”Š    let y2 = line.y2 - this.y;\n-â”Š138â”Š   â”Š    let dx = x2 - x1;\n-â”Š139â”Š   â”Š    let dy = y2 - y1;\n-â”Š140â”Š   â”Š    let d = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\n-â”Š141â”Š   â”Š    let h = (x1 * y2) - (x2 * y1);\n-â”Š142â”Š   â”Š    let delta = (Math.pow(this.r, 2) * Math.pow(d, 2)) - Math.pow(h, 2);\n-â”Š143â”Š   â”Š\n-â”Š144â”Š   â”Š    if (delta < 0) return;\n-â”Š145â”Š   â”Š\n-â”Š146â”Š   â”Š    let interPoints = [\n-â”Š147â”Š   â”Š      {\n-â”Š148â”Š   â”Š        x: (((h * dy) + (((dy / Math.abs(dy)) || 1) * dx * Math.sqrt(delta))) / Math.pow(d, 2)) + this.x,\n-â”Š149â”Š   â”Š        y: (((-h * dx) + (Math.abs(dy) * Math.sqrt(delta))) / Math.pow(d, 2)) + this.y\n-â”Š150â”Š   â”Š      },\n-â”Š151â”Š   â”Š      {\n-â”Š152â”Š   â”Š        x: (((h * dy) - (((dy / Math.abs(dy)) || 1) * dx * Math.sqrt(delta))) / Math.pow(d, 2)) + this.x,\n-â”Š153â”Š   â”Š        y: (((-h * dx) - (Math.abs(dy) * Math.sqrt(delta))) / Math.pow(d, 2)) + this.y\n-â”Š154â”Š   â”Š      }\n-â”Š155â”Š   â”Š    ]\n-â”Š156â”Š   â”Š    .map(point => ({\n-â”Š157â”Š   â”Š        x: Utils.trim(point.x, 9),\n-â”Š158â”Š   â”Š        y: Utils.trim(point.y, 9)\n-â”Š159â”Š   â”Š    }))\n-â”Š160â”Š   â”Š    .filter(point => {\n-â”Š161â”Š   â”Š      return this.hasPoint(point.x, point.y) &&\n-â”Š162â”Š   â”Š        line.boundsHavePoint(point.x, point.y);\n-â”Š163â”Š   â”Š    });\n-â”Š164â”Š   â”Š\n-â”Š165â”Š   â”Š    interPoints = _.uniq(interPoints, point => `(${point.x}, ${point.y})`);\n-â”Š166â”Š   â”Š\n-â”Š167â”Š   â”Š    if (interPoints.length > 0) return interPoints;\n-â”Š168â”Š   â”Š  }\n-â”Š169â”Š   â”Š\n â”Š170â”Š 16â”Š  // circle - polygon intersection method\n â”Š171â”Š 17â”Š  getPolygonIntersection(polygon) {\n â”Š172â”Š 18â”Š    return polygon.getCircleIntersection(this);\n```\n\n[}]: #\n\nWe also need to update the line class to contain a reference to the newly created line-intersection method, so it can be invoked from both a line or a circle bi-directionally:\n\n[{]: <helper> (diffStep 7.22)\n\n#### [Step 7.22: Add line-circle intersection method](https://github.com/DAB0mB/radial-snake/commit/84f5f4d)\n\n##### Changed resources&#x2F;cpp&#x2F;src&#x2F;geometry&#x2F;line.cpp\n```diff\n@@ -4,6 +4,7 @@\n â”Š 4â”Š 4â”Š#include \"../nullable.h\"\n â”Š 5â”Š 5â”Š#include \"../utils.h\"\n â”Š 6â”Š 6â”Š#include \"point.h\"\n+â”Š  â”Š 7â”Š#include \"circle.h\"\n â”Š 7â”Š 8â”Š#include \"line.h\"\n â”Š 8â”Š 9â”Š\n â”Š 9â”Š10â”Šnamespace geometry {\n```\n```diff\n@@ -100,6 +101,11 @@\n â”Š100â”Š101â”Š    return Nullable<Point>();\n â”Š101â”Š102â”Š  }\n â”Š102â”Š103â”Š\n+â”Š   â”Š104â”Š  // circle - circle intersection method\n+â”Š   â”Š105â”Š  Nullable<std::vector<Point>> Line::getIntersection(Circle circle) {\n+â”Š   â”Š106â”Š    return circle.getIntersection(*this);\n+â”Š   â”Š107â”Š  }\n+â”Š   â”Š108â”Š\n â”Š103â”Š109â”Š  emscripten::val EMLine::getMatchingX(double y) {\n â”Š104â”Š110â”Š    Nullable<double> nullableX = Line::getMatchingX(y);\n â”Š105â”Š111â”Š    return nullableX.hasValue() ?\n```\n```diff\n@@ -126,6 +132,10 @@\n â”Š126â”Š132â”Š    emPoint.set(\"y\", emscripten::val(point.y));\n â”Š127â”Š133â”Š    return emPoint;\n â”Š128â”Š134â”Š  }\n+â”Š   â”Š135â”Š\n+â”Š   â”Š136â”Š  emscripten::val EMLine::getIntersection(EMCircle emCircle) {\n+â”Š   â”Š137â”Š    return emCircle.getIntersection(*this);\n+â”Š   â”Š138â”Š  }\n â”Š129â”Š139â”Š}\n â”Š130â”Š140â”Š\n â”Š131â”Š141â”ŠEMSCRIPTEN_BINDINGS(geometry_line_module) {\n```\n```diff\n@@ -146,5 +156,10 @@\n â”Š146â”Š156â”Š      emscripten::select_overload<emscripten::val(geometry::EMLine)>(\n â”Š147â”Š157â”Š        &geometry::EMLine::getIntersection\n â”Š148â”Š158â”Š      )\n+â”Š   â”Š159â”Š    )\n+â”Š   â”Š160â”Š    .function(\"getCircleIntersection\",\n+â”Š   â”Š161â”Š      emscripten::select_overload<emscripten::val(geometry::EMCircle)>(\n+â”Š   â”Š162â”Š        &geometry::EMLine::getIntersection\n+â”Š   â”Š163â”Š      )\n â”Š149â”Š164â”Š    );\n â”Š150â”Š165â”Š}ðŸš«â†µ\n```\n\n##### Changed resources&#x2F;cpp&#x2F;src&#x2F;geometry&#x2F;line.h\n```diff\n@@ -4,6 +4,7 @@\n â”Š 4â”Š 4â”Š#include <emscripten/val.h>\n â”Š 5â”Š 5â”Š#include \"../nullable.h\"\n â”Š 6â”Š 6â”Š#include \"point.h\"\n+â”Š  â”Š 7â”Š#include \"circle.h\"\n â”Š 7â”Š 8â”Š\n â”Š 8â”Š 9â”Šnamespace geometry {\n â”Š 9â”Š10â”Š  class Circle;\n```\n```diff\n@@ -27,6 +28,8 @@\n â”Š27â”Š28â”Š    bool boundsHavePoint(double x, double y);\n â”Š28â”Š29â”Š\n â”Š29â”Š30â”Š    Nullable<Point> getIntersection(Line line);\n+â”Š  â”Š31â”Š\n+â”Š  â”Š32â”Š    Nullable<std::vector<Point>> getIntersection(Circle circle);\n â”Š30â”Š33â”Š  };\n â”Š31â”Š34â”Š\n â”Š32â”Š35â”Š  class EMLine : public Line {\n```\n```diff\n@@ -38,5 +41,7 @@\n â”Š38â”Š41â”Š    emscripten::val getMatchingY(double x);\n â”Š39â”Š42â”Š\n â”Š40â”Š43â”Š    emscripten::val getIntersection(EMLine line);\n+â”Š  â”Š44â”Š\n+â”Š  â”Š45â”Š    emscripten::val getIntersection(EMCircle circle);\n â”Š41â”Š46â”Š  };\n â”Š42â”Š47â”Š}ðŸš«â†µ\n```\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;geometry&#x2F;line.js\n```diff\n@@ -14,11 +14,6 @@\n â”Š14â”Š14â”Š      return this.getPolygonIntersection(shape);\n â”Š15â”Š15â”Š  }\n â”Š16â”Š16â”Š\n-â”Š17â”Š  â”Š  // line - circle intersection method\n-â”Š18â”Š  â”Š  getCircleIntersection(circle) {\n-â”Š19â”Š  â”Š    return circle.getLineIntersection(this);\n-â”Š20â”Š  â”Š  }\n-â”Š21â”Š  â”Š\n â”Š22â”Š17â”Š  // line - polygon intersection method\n â”Š23â”Š18â”Š  getPolygonIntersection(polygon) {\n â”Š24â”Š19â”Š    return polygon.getLineIntersection(this);\n```\n\n[}]: #\n\nNow, before running the tests, be sure to disposed unused circle test-data:\n\n[{]: <helper> (diffStep 7.23)\n\n#### [Step 7.23: Delete circle instances in tests](https://github.com/DAB0mB/radial-snake/commit/e953fae)\n\n##### Changed resources&#x2F;scripts&#x2F;specs&#x2F;engine&#x2F;geometry&#x2F;circle.js\n```diff\n@@ -3,6 +3,10 @@\n â”Š 3â”Š 3â”Š    this.circle = new Engine.Geometry.Circle(1, 1, 5, 0, 1.5 * Math.PI);\n â”Š 4â”Š 4â”Š  });\n â”Š 5â”Š 5â”Š\n+â”Š  â”Š 6â”Š  afterEach(function () {\n+â”Š  â”Š 7â”Š    this.circle.delete();\n+â”Š  â”Š 8â”Š  });\n+â”Š  â”Š 9â”Š\n â”Š 6â”Š10â”Š  describe(\"getX method\", function() {\n â”Š 7â”Š11â”Š    describe(\"given inranged rad\", function() {\n â”Š 8â”Š12â”Š      it(\"returns x\", function() {\n```\n```diff\n@@ -64,6 +68,8 @@\n â”Š64â”Š68â”Š          { x: -2, y: -3 },\n â”Š65â”Š69â”Š          { x: -2, y: 5 }\n â”Š66â”Š70â”Š        ]);\n+â”Š  â”Š71â”Š\n+â”Š  â”Š72â”Š        circle.delete();\n â”Š67â”Š73â”Š      });\n â”Š68â”Š74â”Š    });\n â”Š69â”Š75â”Š\n```\n```diff\n@@ -74,6 +80,8 @@\n â”Š74â”Š80â”Š        expect(this.circle.getCircleIntersection(circle)).toEqual([\n â”Š75â”Š81â”Š          { x: -2, y: 5 }\n â”Š76â”Š82â”Š        ]);\n+â”Š  â”Š83â”Š\n+â”Š  â”Š84â”Š        circle.delete();\n â”Š77â”Š85â”Š      });\n â”Š78â”Š86â”Š    });\n â”Š79â”Š87â”Š\n```\n```diff\n@@ -84,6 +92,8 @@\n â”Š84â”Š92â”Š        expect(this.circle.getCircleIntersection(circle)).toEqual([\n â”Š85â”Š93â”Š          { x: -4, y: 1 }\n â”Š86â”Š94â”Š        ]);\n+â”Š  â”Š95â”Š\n+â”Š  â”Š96â”Š        circle.delete();\n â”Š87â”Š97â”Š      });\n â”Š88â”Š98â”Š    });\n â”Š89â”Š99â”Š\n```\n```diff\n@@ -91,6 +101,7 @@\n â”Š 91â”Š101â”Š      it(\"returns nothing\", function() {\n â”Š 92â”Š102â”Š        let circle = new Engine.Geometry.Circle(10, 10, 2, 0, 2 * Math.PI);\n â”Š 93â”Š103â”Š        expect(this.circle.getCircleIntersection(circle)).toBeUndefined();\n+â”Š   â”Š104â”Š        circle.delete();\n â”Š 94â”Š105â”Š      });\n â”Š 95â”Š106â”Š    });\n â”Š 96â”Š107â”Š\n```\n```diff\n@@ -98,6 +109,7 @@\n â”Š 98â”Š109â”Š      it(\"nothing\", function() {\n â”Š 99â”Š110â”Š        let circle = new Engine.Geometry.Circle(1, 1, 2, 0, 2 * Math.PI);\n â”Š100â”Š111â”Š        expect(this.circle.getCircleIntersection(circle)).toBeUndefined();\n+â”Š   â”Š112â”Š        circle.delete();\n â”Š101â”Š113â”Š      });\n â”Š102â”Š114â”Š    });\n â”Š103â”Š115â”Š  });\n```\n\n##### Changed resources&#x2F;scripts&#x2F;specs&#x2F;engine&#x2F;geometry&#x2F;polygon.js\n```diff\n@@ -64,6 +64,8 @@\n â”Š64â”Š64â”Š          { x: 2, y: 0 },\n â”Š65â”Š65â”Š          { x: 0, y: 2 }\n â”Š66â”Š66â”Š        ]);\n+â”Š  â”Š67â”Š\n+â”Š  â”Š68â”Š        circle.delete();\n â”Š67â”Š69â”Š      });\n â”Š68â”Š70â”Š    });\n â”Š69â”Š71â”Š\n```\n```diff\n@@ -74,6 +76,8 @@\n â”Š74â”Š76â”Š        expect(this.polygon.getCircleIntersection(circle)).toEqual([\n â”Š75â”Š77â”Š          { x: 2, y: 0 }\n â”Š76â”Š78â”Š        ]);\n+â”Š  â”Š79â”Š\n+â”Š  â”Š80â”Š        circle.delete();\n â”Š77â”Š81â”Š      });\n â”Š78â”Š82â”Š    });\n â”Š79â”Š83â”Š\n```\n```diff\n@@ -84,6 +88,8 @@\n â”Š84â”Š88â”Š        expect(this.polygon.getCircleIntersection(circle)).toEqual([\n â”Š85â”Š89â”Š          { x: 0, y: 3 }\n â”Š86â”Š90â”Š        ]);\n+â”Š  â”Š91â”Š\n+â”Š  â”Š92â”Š        circle.delete();\n â”Š87â”Š93â”Š      });\n â”Š88â”Š94â”Š    });\n â”Š89â”Š95â”Š\n```\n```diff\n@@ -91,6 +97,7 @@\n â”Š 91â”Š 97â”Š      it(\"returns nothing\", function() {\n â”Š 92â”Š 98â”Š        let circle = new Engine.Geometry.Circle(10, 10, 2, 0, 2 * Math.PI);\n â”Š 93â”Š 99â”Š        expect(this.polygon.getCircleIntersection(circle)).toBeUndefined();\n+â”Š   â”Š100â”Š        circle.delete();\n â”Š 94â”Š101â”Š      });\n â”Š 95â”Š102â”Š    });\n â”Š 96â”Š103â”Š\n```\n```diff\n@@ -98,6 +105,7 @@\n â”Š 98â”Š105â”Š      it(\"nothing\", function() {\n â”Š 99â”Š106â”Š        let circle = new Engine.Geometry.Circle(2.5, 2.5, 2, 0, 2 * Math.PI);\n â”Š100â”Š107â”Š        expect(this.polygon.getCircleIntersection(circle)).toBeUndefined();\n+â”Š   â”Š108â”Š        circle.delete();\n â”Š101â”Š109â”Š      });\n â”Š102â”Š110â”Š    });\n â”Š103â”Š111â”Š  });\n```\n\n[}]: #\n\nOur C++ code should be finished now, and all the tests should be passing. The only thing left to do would be applying it to our game. Like any other application, we first need to reference the script file so it can be loaded, in this case, the C++ bundle script:\n\n[{]: <helper> (diffStep 7.24)\n\n#### [Step 7.24: Load CPP bundle in game](https://github.com/DAB0mB/radial-snake/commit/a2c0d46)\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -8,6 +8,7 @@\n â”Š 8â”Š 8â”Š    <script type=\"text/javascript\" src=\"/libs/underscore.js\"></script>\n â”Š 9â”Š 9â”Š\n â”Š10â”Š10â”Š    <!-- Scripts -->\n+â”Š  â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/cpp.bundle.js\"></script>\n â”Š11â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/utils.js\"></script>\n â”Š12â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/geometry/line.js\"></script>\n```\n\n[}]: #\n\nAnd now we need to make sure to dispose the geometry shapes correctly so we won't experience any unnecessary memory leaks. Most of our disposals should go to the snake entity, since it's made out of shapes; So we will add a `delete` method to the snake entity and we will dispose it whenever a match is finished:\n\n[{]: <helper> (diffStep 7.25)\n\n#### [Step 7.25: Delete shape instances in game](https://github.com/DAB0mB/radial-snake/commit/ae58323)\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;game.js\n```diff\n@@ -95,6 +95,7 @@\n â”Š 95â”Š 95â”Š  changeScreen(Screen, ...screenArgs) {\n â”Š 96â”Š 96â”Š    // If there is a screen defined, dispose it first\n â”Š 97â”Š 97â”Š    if (this.screen) {\n+â”Š   â”Š 98â”Š      this.screen.delete();\n â”Š 98â”Š 99â”Š      this.unloadScreen();\n â”Š 99â”Š100â”Š      this.screen.disposeEventListeners();\n â”Š100â”Š101â”Š    }\n```\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;layer.js\n```diff\n@@ -23,6 +23,9 @@\n â”Š23â”Š23â”Š    this.canvas = screen.game.canvas;\n â”Š24â”Š24â”Š  }\n â”Š25â”Š25â”Š\n+â”Š  â”Š26â”Š  delete() {\n+â”Š  â”Š27â”Š  }\n+â”Š  â”Š28â”Š\n â”Š26â”Š29â”Š  update(span) {\n â”Š27â”Š30â”Š  }\n â”Š28â”Š31â”Š\n```\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;screen.js\n```diff\n@@ -28,6 +28,13 @@\n â”Š28â”Š28â”Š    return this;\n â”Š29â”Š29â”Š  }\n â”Š30â”Š30â”Š\n+â”Š  â”Š31â”Š   // Delete all layers. Same as 'unload', only it disposes memory rather than assets\n+â”Š  â”Š32â”Š  delete() {\n+â”Š  â”Š33â”Š    this.layers.forEach(layer => {\n+â”Š  â”Š34â”Š      layer.delete();\n+â”Š  â”Š35â”Š    });\n+â”Š  â”Š36â”Š  }\n+â”Š  â”Š37â”Š\n â”Š31â”Š38â”Š  // Updates each layer\n â”Š32â”Š39â”Š  update(span) {\n â”Š33â”Š40â”Š    this.layers.forEach(layer => {\n```\n```diff\n@@ -61,6 +68,7 @@\n â”Š61â”Š68â”Š  removeLayer(layer) {\n â”Š62â”Š69â”Š    this.layers = _.without(this.layers, layer);\n â”Š63â”Š70â”Š    layer.disposeEventListeners();\n+â”Š  â”Š71â”Š    layer.delete();\n â”Š64â”Š72â”Š  }\n â”Š65â”Š73â”Š\n â”Š66â”Š74â”Š  initEventListeners() {\n```\n\n##### Changed resources&#x2F;scripts&#x2F;game&#x2F;entities&#x2F;snake.js\n```diff\n@@ -31,6 +31,10 @@\n â”Š31â”Š31â”Š    }\n â”Š32â”Š32â”Š  }\n â”Š33â”Š33â”Š\n+â”Š  â”Š34â”Š  delete() {\n+â”Š  â”Š35â”Š    this.shapes.forEach(shape => shape.delete());\n+â”Š  â”Š36â”Š  }\n+â”Š  â”Š37â”Š\n â”Š34â”Š38â”Š  draw(context) {\n â”Š35â”Š39â”Š    // Draw all shapes in the shapes array\n â”Š36â”Š40â”Š    this.shapes.forEach(shape => {\n```\n```diff\n@@ -229,6 +233,8 @@\n â”Š229â”Š233â”Š      [0, height, 0, 0]\n â”Š230â”Š234â”Š    );\n â”Š231â”Š235â”Š\n-â”Š232â”Š   â”Š    return canvasPolygon.getIntersection(this.lastBit);\n+â”Š   â”Š236â”Š    let result = canvasPolygon.getIntersection(this.lastBit);\n+â”Š   â”Š237â”Š    canvasPolygon.delete();\n+â”Š   â”Š238â”Š    return result;\n â”Š233â”Š239â”Š  }\n â”Š234â”Š240â”Š};ðŸš«â†µ\n```\n\n##### Changed resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;play&#x2F;snake.js\n```diff\n@@ -43,6 +43,10 @@\n â”Š43â”Š43â”Š    screen.appendLayer(Game.Screens.Play.Score, this.snakes);\n â”Š44â”Š44â”Š  }\n â”Š45â”Š45â”Š\n+â”Š  â”Š46â”Š  unload() {\n+â”Š  â”Š47â”Š    this.snakes.forEach(snake => snake.delete());\n+â”Š  â”Š48â”Š  }\n+â”Š  â”Š49â”Š\n â”Š46â”Š50â”Š  draw(context) {\n â”Š47â”Š51â”Š    // Draw each snake in the snakes array\n â”Š48â”Š52â”Š    this.snakes.forEach(snake => snake.draw(context));\n```\n\n[}]: #\n\nCongratulations! You've created a C++ cross JavaScript game. There shouldn't be any significant difference between the C++ version of the game and the JavaScript version on most machines, since the game is very small and barely requires any processing power. You'll probably notice the difference when starting to extend the game by adding terrains or more snakes.\n\nOne might ask - \"How much faster does my game actually run?\". The short answer is - around 50%. Why did I run into this conclusion? Well, take a look at the following JavaScript code snippet, for calculating Fibonacci of 42:\n\n```js\nfunction fib(x) {\n  if (x < 2) {\n    return 1;\n  }\n  else {\n    return fib(x - 1) + fib(x - 2);\n  }\n}\n```\n\nThe same code snippet should look almost identical written in C++:\n\n```cpp\nint fib(int x) {\n  if (x < 2) {\n    return 1;\n  }\n  else {\n    return fib(x - 1) + fib(x - 2);\n  }\n}\n```\n\nHowever, the run-times are completely different! I compared the average of 10 runs in 3 different environments, and I received the following results:\n\n![chart](https://cloud.githubusercontent.com/assets/7648874/22802494/2591025e-eef8-11e6-9679-10b5bca0ef30.png)\n\nAs you can see, the generated C++ is much faster, and to be precise, 57% faster! Surprisingly, I didn't have any significant difference between Emscripten generated C++ and natively compiled executable.\n\nC++ is more complex to write, but it certainly has its advantages over JavaScript. Remember, now that you know that you have the possibility to run C++ in the browser, make sure to use it, but never overdo it, always find the right balance between readability and performance.\n\n> *Sources:*\n> - *https://kripken.github.io/emscripten-site/docs/introducing_emscripten/index.html*\n> - *http://www.crunchy.com/?q=content/emscripten-perfectly-cromulent-compiler*\n> - *http://stackoverflow.com/questions/2354725/what-exactly-is-llvm*"
          }
        ]
      },
      {
        "releaseVersion": "0.1.1",
        "releaseDate": "2017-04-23 02:26:55 -0200",
        "tagName": "master@0.1.1",
        "tagRevision": "c97e2ed6ba8fa19764bd936f381005499bb9e531",
        "historyRevision": "7accb991dd3a15a7f796e3bbe11a9e2fbfc2ce9b",
        "changesDiff": "diff --git a/manuals/templates/root.md b/manuals/templates/root.md\ndeleted file mode 100644\nindex a040321..0000000\n--- a/manuals/templates/root.md\n+++ /dev/null\n@@ -1,23 +0,0 @@\n-![snake-demo-full-small](https://cloud.githubusercontent.com/assets/7648874/21073892/ae331a8a-bed2-11e6-9141-9554f9bb808b.gif)\n-\n-This tutorial will guide you through the following steps:\n-\n-- [**Step 1**](https://github.com/DAB0mB/radial-snake/blob/master/manuals/views/step1.md) - Creating a server\n-- [**Step 2**](https://github.com/DAB0mB/radial-snake/blob/master/manuals/views/step2.md) - Creating a game engine basis\n-- [**Step 3**](https://github.com/DAB0mB/radial-snake/blob/master/manuals/views/step3.md) - Creating a splash screen using a keyframe animation engine\n-- [**Step 4**](https://github.com/DAB0mB/radial-snake/blob/master/manuals/views/step4.md) - Creating a main menu screen using a font engine\n-- [**Step 5**](https://github.com/DAB0mB/radial-snake/blob/master/manuals/views/step5.md) - Creating a snake and related geometry shapes\n-- [**Step 6**](https://github.com/DAB0mB/radial-snake/blob/master/manuals/views/step6.md) - Creating a complex game screen with multiple layers\n-- [**Step 7**](https://github.com/DAB0mB/radial-snake/blob/master/manuals/views/step7.md) - Bonus! Re-implementing geometry in C++\n-- [**Step 8**](https://github.com/DAB0mB/radial-snake/blob/master/manuals/views/step8.md) - Step 8: What's next?\n-\n-Make sure you have the following software installed:\n-\n-- NodeJS with an ECMAScript 2015 support (v6.0.0 and above).\n-- Any web-browser which supports ECMAScript 2015, with a preference for Google Chrome.\n-\n-> The final project is a hybrid of C++ and JavaScript. A JavaScript **only** version of this tutorial is available [here](https://github.com/DAB0mB/radial-snake/tree/step6).\n-\n-This tutorial is mostly based on pure JavaScript, so people can have a deeper understanding of the language and its dynamics. In addition, this tutorial makes a great practice on how to build a nice architecture for complex systems, which can then be expanded and maintained with ease. Yes, it is specifically designed for games, but I truly believe that video games can easily get messed up if not planned and designed properly in terms of object oriented relationships. They are naturally more complicated then any web-app you gonna see out there, so if you can create a game engine and understand its flow, creating a web-app would be a piece of cake for you. By the end of this tutorial, your general sense for programming should be enhanced greatly.\n-\n-So hopefully that I got you pumped up by now, let's get started!\n\\ No newline at end of file\ndiff --git a/manuals/templates/step1.md b/manuals/templates/step1.md\ndeleted file mode 100644\nindex a1ebbb7..0000000\n--- a/manuals/templates/step1.md\n+++ /dev/null\n@@ -1,100 +0,0 @@\n-The first thing we will learn to do would be creating a server so we can serve our assets. We will be using [HapiJS](https://hapijs.com/) to build a REST API, although this step can be implemented with any library you'd want, like [ExpressJS](http://expressjs.com/) or [Connect](https://www.senchalabs.github.com/connect) etc. Let's install it then:\n-\n-    $ npm install hapi --save\n-\n-We will start by setting up a basis for our server, and we will expand it as we go further in this step. A general boiler plate should look like so:\n-\n-{{{diff_step 1.2}}}\n-\n-We simply initialize a new server which will connect to port `8000` by default, unless we defined an environment variable called `PORT`. Once the server is started, and whenever there is an outcoming response, a message will be printed to the console.\n-\n-> More information and configuration options regards HapiJS's API can be found in this [here](https://hapijs.com/).\n-\n-Now that the basis is ready, we want a convenient way to launch it. Repetitive scripts are usually defined in the `package.json` file under the `scripts` field. To start the server, we gonna create a simple script called `serve`:\n-\n-{{{diff_step 1.3}}}\n-\n-To run this script, we will simply need to type the following:\n-\n-    $ npm run serve\n-\n-This will run our server, and you should see the following message printed to the console:\n-\n-```\n----------- -------- ------ ---- --\n------ ---- --- -- -\n-Server running at 8000\n------ ---- --- -- -\n----------- -------- ------ ---- --\n-```\n-\n-> As for now, nothing happens, because we didn't define any handlers for HTTP requests. I will get to it in a bit, stay with me.\n-\n-The main disadvantage of starting a server directly with node is that we have no listeners for changes in our files, so if we want the served files to be updated, we will have to restart our server anytime we make a change. To avoid that, we gonna use [nodemon](https://nodemon.io/), which is a simple utility that can monitor changes is source files and automatically restart our server. To install it, type the following:\n-\n-    $ sudo npm install nodemon -g\n-\n-Now that we have it, we will need to update our `serve` npm script to use `nodemon` instead of `node`:\n-\n-{{{diff_step 1.4}}}\n-\n-The basis for our server is pretty much complete. From now on we gonna build stuff on top of it and extend our server. I'd like to add a small attachment to our server. I want that the IP address of the current computer will be printed to the console once the server is started. For this, we first gonna create a helper which we gonna call `ip_grabber`:\n-\n-{{{diff_step 1.5}}}\n-\n-This module simply goes through the available network interfaces and grabs the IP address of the default gateway using the `os` module. Now that we have it, let's import it in the server's entry file and use the `local` method to grab the IP address and report it once the server is started:\n-\n-{{{diff_step 1.6}}}\n-\n-By now you should have the following message printed to the console once you start the server:\n-\n-```\n----------- -------- ------ ---- --\n------ ---- --- -- -\n-Server running at 95.221.122.30:8000\n------ ---- --- -- -\n----------- -------- ------ ---- --\n-```\n-\n-> Instead of `95.221.122.30` you should have the IP address which is right for you.\n-\n-Now comes the most important part - handling HTTP requests! Because what does a server worth if it doesn't know how to handle anything? When using `HapiJS`, we can separate extensions to our server in different modules, and eventually register them as plug-ins. So the first plug-in is gonna be the routes batch for the endpoints - it will take care of serving file requests as is, and basically turning local directories into public ones. This is useful because our game is going to be dependent on many assets like textures, images, fonts, and so on... But before I go into the implementation part we first need to install a couple of libraries which will help us with the task. The first one is going to be `async`, which will take care of managing the control flow of asynchronous code:\n-\n-    $ npm install async --save\n-\n-And the second library is going to be `inert`, which is a `HapiJS` plug-in which will give us the ability to serve files from local directories:\n-\n-    $ npm install inert --save\n-\n-Now that we're set, let's implement the `endpoints` routes batch:\n-\n-{{{diff_step 1.8}}}\n-\n-This module actually represents a classic structure of a `HapiJS` plug-in. It should export a `name` for debugging proposes, a `version`, and a `register` function, which will take care of registering extensions to our server; in this case, these are the endpoints routes. To make this plug-in (Or any other plug-in) work, we need to register it. The registration is an asynchronous operation, thus we gonna handle it using `async`:\n-\n-{{{diff_step 1.9}}}\n-\n-Once all the plug-ins have been registered, we gonna start our server as we previously did. Note that we also registered the `inert` plug-in, because as I said earlier, that's what gives us the ability to handle files requests.\n-\n-Lastly, I want to create the `pages` routes batch, which will be responsible for serving pages in our application as listed above:\n-\n-- The `/` route will serve us the `game.html` file.\n-- The `/test` route will serve us the `spec_runner.html` file.\n-\n-By the name of each route and file you can probably what each one should do. The thing is, we don't want everyone to be able to access the `spec_runner.html` file, or the `game.html` file if in the middle of development. For this, we're going to create a new helper which will be responsible for handling permissions. So first we gonna install an npm package called `boom` which has the ability to format `permission denied` HTTP errors:\n-\n-    $ npm install boom --save\n-\n-And now we gonna implement the module itself:\n-\n-{{{diff_step 1.11}}}\n-\n-The default permitted IP address would be the current computer's IP address. Extra IP permissions can be provided with the invocation of the `file` method. If the requesting IP is not listed in the permissions list, an error is gonna be replied instead of the requested file. Now that we have our \"permitter\" ready, let's implement the `pages` routes batch, only we're gonna pass the requests through the black-list, for the reason mentioned above:\n-\n-{{{diff_step 1.12}}}\n-\n-Now the only thing left to do would be registering the plug-in we've just created:\n-\n-{{{diff_step 1.13}}}\n-\n-And that's it for the current step! In the next steps we will start storing files and assets in our public directories and implement all the necessary scripts, so our server is not running in vain.\n\\ No newline at end of file\ndiff --git a/manuals/templates/step2.md b/manuals/templates/step2.md\ndeleted file mode 100644\nindex 73ceadf..0000000\n--- a/manuals/templates/step2.md\n+++ /dev/null\n@@ -1,99 +0,0 @@\n-Like any other JavaScript-based application, we should have an entry view written in HTML. However, in our application, the only visible element is going to be an [HTMLCanvas](https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API). The canvas is exactly what it sounds like - a blank white surface which we can draw things on top of it. As we go further with this tutorial, we will learn more about the canvas and dive into its API and how to use it. Now that you got the general idea, let's create the HTML file:\n-\n-{{{diff_step 2.1}}}\n-\n-In the previous step we've already set the route for this file, so if you'd like to run the game, simply start the server by typing `npm run serve`, and navigate to the address presented on the screen (Should be `localhost:8000` by default).\n-\n-> From now on I'm going to assume the server is running in the background, so I won't repeat the instruction above\n-\n-Just to make sure that the canvas is visible and not blended into the background, we will draw a black border around using a simple style-sheet:\n-\n-{{{diff_step 2.2}}}\n-\n-> Note that every asset we create should be declared in the HTML file in order for it to take effect\n-\n-To build this project we're also gonna use two very famous utility libraries called [JQuery](http://jquery.com/) and [Underscore](http://underscorejs.org/) which will make our lives a bit easier. Third-party libraries should be located in a directory called `libs`, according to the routes-map we created in the previous step. To set these libraries up, type the following commands in series:\n-\n-    resources$ mkdir libs\n-    resources$ cd libs\n-    resources/libs$ wget raw.githubusercontent.com/dab0mb/radial-snake/master/resources/libs/underscore.js\n-    resources/libs$ wget raw.githubusercontent.com/dab0mb/radial-snake/master/resources/libs/jquery-2.1.1.js\n-\n-And load them in the game's HTML file's header:\n-\n-{{{diff_step 2.3 views/game.html}}}\n-\n-Now, we're finally going to build the game engine. At first, it's gonna be very basic simple, but further in this tutorial we're going to extend it and add some pretty neat features. When creating an application, of any kind, you don't want to garbage the global scope, so it can stay clean without any conflicts. Therefore, we're going to create an initial namespace for our game engine called `Engine`, which is going to contain all our game engine's classes and entities:\n-\n-{{{diff_step 2.4}}}\n-\n-The first thing we're going to define in the namespace we've just created would be the game loop. The game loop is the central code of your game, split into different parts. Generally, these are: update and draw.\n-\n-The main purpose of the update phase is to prepare all objects to be drawn, so this is where all the geometry code, coordinate updates, score changes, animation refreshments and other similar operations belong. This is also where the input will be captured and processed.\n-\n-When everything is properly updated and ready, we enter the draw phase where all this information is put on the screen. This function should contain all the code to manage and draw the levels, shapes, score board and so on.\n-\n-![game-loop](https://cloud.githubusercontent.com/assets/7648874/21332964/4b80ef4e-c633-11e6-946a-0c5870d2f9c9.png)\n-\n-> You can find plenty of details and information about what \"game loop\" means simply by typing in on Google.\n-\n-A game loop can wear many forms, but the concept is gonna be the same, plus-minus. This is how our game loop is going to loop like:\n-\n-{{{diff_step 2.5}}}\n-\n-The only thing it's doing right now is drawing a black background, but we're soon going to learn how to take advantage of this game-loop to draw stuff of our own. I'd like to point out that there is no need to implement a [double-buffer](https://en.wikipedia.org/wiki/Multiple_buffering) (A method similar to React's [virtual DOM](https://www.npmjs.com/package/react-dom)) when it comes to `HTMLCanvas` elements, since `HTML5` already does that for us. To start running the game, we first need to wait for the DOM content to initialize, and once it's ready we gonna create a new game instance and call the `play` method:\n-\n-{{{diff_step 2.6}}}\n-\n-This will take control over the canvas and will draw a new picture every 17ms, which is 60fps (Frames per second). As for now you're only going to see a black canvas, but I promise the final result is not going to disappoint you.\n-\n-The next thing we're gonna do would be adding a 'key state' manager, which will store a flag for each key pressed on the keyboard. Once we press the key, the flag's value would be `true`, and once we release it, its value would turn into `false`. This way we have an easy way to track all the key presses without registering a specific event listener for each key press we wanna track:\n-\n-{{{diff_step 2.7}}}\n-\n-Now that we have the key state manager, we will initialize a new instance as part of our game's essentials, and we will create a global event listener for key presses; Each time a key is pressed, the key state manager will update itself:\n-\n-{{{diff_step 2.8}}}\n-\n-A 2D game's view might get complex as we go through with its development and add more logic and entities into it. Having only one `draw` method and only one `update` method is not enough, and if you think of it, it might easily get buffed up into ridiculous dimensions, which is not the way to go. I'd like to introduce you into a new methodology which involves `screens` and `layers`:\n-\n-- **screen** - Will literally be used whenever we want to show a new screen in our game e.g. 'splash' screen and 'main menu' screen. A screen consists of multiple layers, and will be used as their communicator; All the relevant assets and logic will be initialized inside it.\n-- **layer** - similar to Photoshop's layer system, any time we want to add something to the view we add new layers on top or beneath of each other.\n-\n-![screen-layer](https://cloud.githubusercontent.com/assets/7648874/21487708/9b366efe-cbb7-11e6-8669-3212e440871a.png)\n-\n-As I said earlier, the purpose of the screens and the layers is just to split the task of updating and drawing and updating, so we can have logical segments; So the `layer` class should mainly consist of a `draw` and an `update` method:\n-\n-{{{diff_step 2.9}}}\n-\n-Same thing for the screen, it only has a `draw` and `update` methods, only it has a stack of layers, which can either be added or removed:\n-\n-{{{diff_step 2.10}}}\n-\n-Now that we have the `screen` class available for us, let's apply it to the main game loop:\n-\n-{{{diff_step 2.11}}}\n-\n-This step looks kind of useless for now, unless we will have the ability to change screens as we please. Any time a screen is changed, it should be loaded with its necessary assets e.g textures, sounds, fonts, etc. The assets loading is an asynchronous operation whose logic might get a bit messy if not managed properly. To make it easier, we're going to define an assets loader, which will help us load assets asynchronously:\n-\n-{{{diff_step 2.12}}}\n-\n-> As for now the `assets loader` only has the ability to load textures, but we will extend it as we go further in this tutorial, no need to overdo it.\n-\n-Now that we have the `assets loader` we can add the ability to change a screen. Whenever we change a screen, the old screen's assets should be unloaded, and the new screen's assets should be loaded using the `assets loader`:\n-\n-{{{diff_step 2.13}}}\n-\n-Let's add a test screen just so we can get the hang of it. The test screen will only print a message to the canvas:\n-\n-{{{diff_step 2.14}}}\n-\n-Now we will use the test screen by changing to it as we create an instance of the game:\n-\n-{{{diff_step 2.15}}}\n-\n-Once you will load the application you should see a black canvas with a white text saying:\n-\n-    This is a test screen\n-\n-It means our screen system works and you may proceed to the next step, where we're gonna create our first screen :-)\n\\ No newline at end of file\ndiff --git a/manuals/templates/step3.md b/manuals/templates/step3.md\ndeleted file mode 100644\nindex 7b5cff5..0000000\n--- a/manuals/templates/step3.md\n+++ /dev/null\n@@ -1,81 +0,0 @@\n-![snake-demo-splash-small](https://cloud.githubusercontent.com/assets/7648874/21074086/a19fa9ce-bed6-11e6-9060-2ce94c215712.gif)\n-\n-In this step we will be creating the `splash` screen - the initial screen that should be shown once we launch the game. Our splash is consisted of a random logo animation as presented in the `gif` file above. The \"splash\" effect can be achieved using 2 concepts:\n-\n-- A sprite class - Which will present the logo texture in different dimensions, angles and rotations.\n-- A key-frame animation - Which will draw an animation automatically along the time axis using key-frames - each is a sprite representation of the texture in a specific time point.\n-\n-So first thing first, we will start by implementing the sprite class:\n-\n-{{{diff_step 3.1}}}\n-\n-And we will download the logo which will be presented in the splash screen using the sprite class:\n-\n-    resources$ mkdir assets\n-    resources$ cd assets\n-    resources/assets$ mkdir textures\n-    resources/assets$ cd textures\n-    resources/assets/textures$ wget raw.githubusercontent.com/dab0mb/radial-snake/master/resources/assets/textures/splash.png\n-\n-> Any logo can that you desired can be used instead! But to ease things up I already provided you with one as a sample\n-\n-Now we will create the initial splash screen, where we only gonna show a sprite of the logo in the middle of the screen, with no animation applied yet. We will first define a dedicated `Screens` module under the `Game` namespace:\n-\n-{{{diff_step 3.3}}}\n-\n-And we can go ahead and implement the screen itself:\n-\n-{{{diff_step 3.4}}}\n-\n-Now we can set the splash screen as the initial screen in the entry script file:\n-\n-{{{diff_step 3.5}}}\n-\n-And we will get rid of the unnecessary test screen since we make no use of it any longer:\n-\n-    $ rm resources/scripts/test_screen.js\n-\n-We will now proceed into the next stage where we will be implementing the key-frame animation engine as said at the beginning of the step. We first need to define an `Animations` module, since we can have multiple types of animation strategy like [sprite-atlas animation](http://www.joshmorony.com/how-to-create-animations-in-phaser-with-a-texture-atlas/), not necessarily a key-frame animation:\n-\n-{{{diff_step 3.7}}}\n-\n-Inside the newly created module we will create the key-frame animation engine. The key-frame animation consists of the following methods:\n-\n-- update - Updates the animation.\n-- draw - Draws the current animation frame on the provided canvas context.\n-- play - Enables update operations.\n-- pause - Disables update operations.\n-\n-{{{diff_step 3.8}}}\n-\n-When initializing a new instance of the key-frame animation, we should invoke it with the desired sprite, and an array of key-frames. What exactly does a single key-frame represents? The properties of the sprite at that specific time point. In addition, a key-frame can be set with an [easing mode](https://css-tricks.com/ease-out-in-ease-in-out/) of `in` and `out`. By default, the animation would be linear.\n-\n-Based on the `repitationMode` property, three things can happen to the animation once finished:\n-\n-- `none` - The animation will play once, and then stop. It will appear as a static sprite.\n-- `cyclic` - The animation will repeat itself from the beginning, over and over again until stopped manually.\n-- `full` - The animation will play itself backwards, and then forwards, backwards, forwards, and so on.\n-\n-Thanks to the key-frame animation engine, we can apply it to the splash screen to show a beautifully animated logo rather than showing a static image. So in addition to the logo sprite, we will initialize a key-frame animation as well:\n-\n-{{{diff_step 3.9}}}\n-\n-The following key-frames illustrate the nodes of the animation we've just created:\n-\n-    width: 0\n-    height: 0\n-    opacity: 0\n-\n-![logo-empty](https://cloud.githubusercontent.com/assets/7648874/21583394/ee7a1dec-d065-11e6-80ce-fdd37c4b5dbb.png)\n-\n-    width: 225\n-    height: 175\n-    opacity: 1\n-\n-![logo-half](https://cloud.githubusercontent.com/assets/7648874/21583396/ee9bdf68-d065-11e6-95fb-4cf5ed58a9de.png)\n-\n-    width: 342\n-    height: 266\n-    opacity: 1\n-\n-![logo-full](https://cloud.githubusercontent.com/assets/7648874/21583395/ee7b3754-d065-11e6-9646-476d196a6412.png)\n\\ No newline at end of file\ndiff --git a/manuals/templates/step4.md b/manuals/templates/step4.md\ndeleted file mode 100644\nindex 8c18390..0000000\n--- a/manuals/templates/step4.md\n+++ /dev/null\n@@ -1,79 +0,0 @@\n-![snake-demo-menu-small](https://cloud.githubusercontent.com/assets/7648874/21074099/e72a81bc-bed6-11e6-98cb-329dc12a4b06.gif)\n-\n-In this step we will be creating the main menu screen as shown above. The main menu screen is a simple screen which will show the logo of the game and an instruction text saying `Press a key to start`. We will be using a simple texture to show the game-logo and we will use the key-frame animation engine to show a flickering animation of the instruction text. The instruction text is the main part of this step, since it is made out of a font file (`.ttf`) and the text is auto-generated, a general solution which can serve us in many situations. We will start by implementing the main menu using static assets, which means that we will use a texture to show the instructions text, and later on we will implement the generic solution I've just mentioned. First, we will download the necessary assets:\n-\n-    resources/assets/textures$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/assets/textures/instructions.png\n-    resources/assets/textures$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/assets/textures/logo.png\n-\n-And then we will implement the initial main menu screen:\n-\n-{{{diff_step 4.2}}}\n-\n-This screen is dependent on several assets which we will load during \"splash screen time\", to save some loading time and for a smooth experience. The main menu screen will be shown automatically once the splash animation has been finished:\n-\n-{{{diff_step 4.3}}}\n-\n-By now if you launch the application you should see the main menu screen as described in the beginning. But event though it works, we're not yet finished. We still need to convert the instruction texture into an auto-generated font texture. Obviously, this requires us to download the desired `ttf` file:\n-\n-    resources/assets/fonts$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/assets/fonts/minecraftia.ttf\n-\n-> Any font file can be used here, but to save time and effort I already provided you with one\n-\n-`ttf` is the most common format, but since we're using JavaScript, it would make sense to convert it into a `json` file, and that's exactly what we're going to do. There's a very convenient software called [font-builder](https://github.com/andryblack/fontbuilder), and it can cut fonts, store them in `png` files, along with some user-specified meta-data stored in an `xml` file.\n-\n-![font-builder](https://camo.githubusercontent.com/b2c95cda825c783f5399d9197599848c33cdfcc8/687474703a2f2f7777772e67616d656465762e72752f66696c65732f696d616765732f73637265656e312e6a706567)\n-\n-Go over to this website: https://github.com/andryblack/fontbuilder.\n-Fetch a copy of the `font-builder` repo, and try to convert the `minecraftia.ttf` file into a `png` file. If you want to skip this step, although I wouldn't recommend it, you can download the following files which I already generated myself:\n-\n-    resources/assets/fonts$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/assets/fonts/minecraftia.png\n-    resources/assets/fonts$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/assets/fonts/minecraftia.xml\n-\n-As promised, we will be working with a `json` file, not a `ttf` file and not an `xml` file. For this task we will be implementing a font-parser module, which will simply take all the meta-data in the `xml` file and put it into a nice `json` schema:\n-\n-{{{diff_step 4.6}}}\n-\n-This script will take everything that's in the `fonts` dir and parser it as mentioned above. Before we can user this script we will need to install some NPM dependencies like so:\n-\n-    $ npm install --save underscore\n-    $ npm install --save xmldom\n-\n-And instead of running the parser manually over and over again whenever we wanna use it, we will use the following `NPM` script instead:\n-\n-{{{diff_step 4.8}}}\n-\n-We don't want the generated fonts to be included by `git` since they are going to automatically regenerate themselves, therefore we gonna add the following ignore rule:\n-\n-{{{diff_step 4.9}}}\n-\n-Now we will build our `minecraftia` font by simply running:\n-\n-    $ npm run build:fonts\n-\n-And voila! We have a freshly created `json` file which we can work with. You can also get it from here:\n-\n-    resources/assets/fonts$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/assets/fonts/minecraftia.json\n-\n-Now that we have our assets finally ready we can go ahead and focus on extending the engine which powers up our game. We need some sort of a generic font-engine which will know how to load a font file and create a text-sprite out of it. First we will implement a class called `Restorable`, which shares the same restore API as the CanvasRenderingContext2D and will give us the ability to save and restore the font's state (More information can be found [here](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/restore)):\n-\n-{{{diff_step 4.11}}}\n-\n-And now we can go ahead and implement the font class itself:\n-\n-{{{diff_step 4.12}}}\n-\n-The font API shares a similar API as [HTMLImageElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/Image), once we set the `src` property the font will start loading itself, and the `onload` user-defined callback should be called once finished. Another neat feature would be the `createTexture` method, which takes a string as its first argument, representing the text that we would like to generate, and returns an instance of the `Sprite` class.\n-\n-We will also be adding the option to load some font assets in our asset-loader:\n-\n-{{{diff_step 4.13}}}\n-\n-And replace the instructions texture loading with a `minecraftia` font loading in the initial splash screen:\n-\n-{{{diff_step 4.14}}}\n-\n-Now it can use us in the main menu screen where we will create a text-sprite saying `Press a key to start`, just like the instruction sprite we're about to replace:\n-\n-{{{diff_step 4.15}}}\n-\n-It shouldn't look any different from the beginning of the step where we manually drew the instruction texture, but in the next steps we will be using the font-engine a lot, and you will be thankful for what we've just did.\n\\ No newline at end of file\ndiff --git a/manuals/templates/step5.md b/manuals/templates/step5.md\ndeleted file mode 100644\nindex 2c11ac8..0000000\n--- a/manuals/templates/step5.md\n+++ /dev/null\n@@ -1,106 +0,0 @@\n-![snake-illustrate](https://cloud.githubusercontent.com/assets/7648874/21074115/46ef4466-bed7-11e6-9d5d-12fa6d43147b.gif)\n-\n-In this step we will be creating all the necessary geometry shapes to form a snake; we're basically implementing the right infrastructure so in the next step we will be able to implement the game screen with ease. What exactly do I mean by \"geometry shapes\"? Well, our snake will be made out of circles, and lines. If we don't press any buttons at all, the snake should move forward at a straight line, and once we press on one of the arrow keys, the snake should move in a circular motion. Not only we want to draw the screen on the canvas, we also want to be able to detect collision with other snakes, since this is a \"Tron\" style game where we gonna fight against an opponent.\n-\n-Keep in mind that a computer's precision is limited due its [binary representation in memory](https://en.wikipedia.org/wiki/Memory_cell_(binary)). We need to take into consideration that there might be a significant deviation when detecting collisions and intersections between geometry shapes, especially when elapsed time is not always guaranteed to stay precise. To handle these deviation issues, we're gonna create some utility functions and place then in a new module called `Utils`:\n-\n-{{{diff_step 5.1}}}\n-\n-Now we would like to start implementing the first class representation for a line, and for that we're requires to add a new module called `Geometry` to the `Engine` namespace:\n-\n-{{{diff_step 5.2}}}\n-\n-And now that we have this module available to use, we can go ahead and implement our first geometry shape class - `Line`:\n-\n-{{{diff_step 5.3}}}\n-\n-You can go through the comments of the step above which will guide you through the programmatic aspect of it, but I think it's more important to understand the concept of a line in 2D space. A line is made out of two points, usually represented as `(x1, y1)` and `(x2, y2)`. The slope of the line, usually represented as `m`, can be determined using these two points based on the following formula:\n-\n-![slope](https://cloud.githubusercontent.com/assets/7648874/21788249/b4c7e41c-d6b4-11e6-9c17-baff66ec6bc8.png)\n-\n-Once we have two lines whose `m` is different (Unparalleled) and there is no intersection between the points of which they are represented with (In which case they are united), there must be an intersection point. The intersection point can be found using the following formula:\n-\n-![line-line](https://cloud.githubusercontent.com/assets/7648874/21787164/c9d83bf0-d6ae-11e6-9846-4fc013eebab3.png)\n-\n-![line-line-illustration](https://cloud.githubusercontent.com/assets/7648874/21790864/56725cf0-d6c6-11e6-916b-50b1fc0b87af.png)\n-\n-> See reference: http://mathworld.wolfram.com/Line-LineIntersection.html.\n-\n-Obviously we have some logic here which needs to be tested. To test our `Line` class, we will be using a testing framework called [Jasmine](https://jasmine.github.io/). We first need to download `Jasmine`'s essentials in order for it to work:\n-\n-    resources/libs$ mkdir jasmine\n-    resources/libs$ cd jasmine\n-    resources/libs/jasmine$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/libs/jasmine/boot.js\n-    resources/libs/jasmine$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/libs/jasmine/console.js\n-    resources/libs/jasmine$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/libs/jasmine/jasmine-html.js\n-    resources/libs/jasmine$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/libs/jasmine/jasmine.css\n-    resources/libs/jasmine$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/libs/jasmine/jasmine.js\n-    resources/libs/jasmine$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/libs/jasmine/jasmine_favicon.png\n-\n-These essentials should be loaded in a newly created view where we're gonna see our specs running:\n-\n-{{{diff_step 5.5}}}\n-\n-Now once we'll navigate to the `/test` sub-route (`localhost:8000/test` by default) we should be provided with the spec runner. As for now there are no specs implemented at all, which brings us to the next stage - Implementing tests for `Line` class:\n-\n-{{{diff_step 5.6}}}\n-\n-Now if you'll refresh the spec runner page you should be able to a green screen indicating all tests have passed (Assuming the tutorial is updated and you followed it correctly). As introduced at the beginning of the step, the snake is also dependent on circles, whose representing class should look like so:\n-\n-{{{diff_step 5.7}}}\n-\n-Just like a line, a circle can be presented using variables as well. The center of the circle is represented as `(x, y)` and its radius is represented as `r`. Remember that our circle doesn't necessarily have to be a full one, therefore we limit its range using two radians - `rad1` and `rad2`. The formula for representing a circle in a 2D space looks like this:\n-\n-![circle-formula](https://cloud.githubusercontent.com/assets/7648874/21829783/84a54574-d77f-11e6-9b87-3fb0f073bb8d.png)\n-\n-![circle-circle-illustration](https://cloud.githubusercontent.com/assets/7648874/21790842/3a73408c-d6c6-11e6-8bdd-9c73355e6ebb.png)\n-\n-> `a` and `b` represent the offsets from the `x` and the `y` axes respectively.\n-> See reference: http://mathworld.wolfram.com/Circle-CircleIntersection.html.\n-\n-To find intersection between two circles, we simply calculate the solution for two equations with two variables. Given that a line can be represented in a 2D space using the following formula:\n-\n-![line-formula](https://cloud.githubusercontent.com/assets/7648874/21790671/1609c050-d6c5-11e6-8bd7-16cc306f5eea.png)\n-\n-![circle-line-illustration](https://cloud.githubusercontent.com/assets/7648874/21790810/1a052086-d6c6-11e6-9c5c-24298fedb043.png)\n-\n-> `n` represents the intersection value with the `y` axis.\n-> See reference: http://mathworld.wolfram.com/Circle-LineIntersection.html.\n-\n-we can find the intersection between a circle and line by solving the systems formed by the equations of both. We also want the line-circle algorithm to be available for any `Line` instance, therefore we gonna add the following delegate on the `Line` prototype:\n-\n-{{{diff_step 5.8}}}\n-\n-Then again a newly created geometry shape class should be tested against different scenarios:\n-\n-{{{diff_step 5.9}}}\n-\n-Our final shape in the geometry module would be a polygon. Why a polygon? Since I'm planning to make the snake's movement circular, which means that once the snake hits a random boundary, he will reappear from the other side of the canvas. The collision detection between the snake and the canvas would be done using a polygon - which is simply made out of 4 lines:\n-\n-{{{diff_step 5.10}}}\n-\n-Again we will delegate the newly created intersection methods in the `Line` class and `Circle` class:\n-\n-{{{diff_step 5.11}}}\n-\n-Now we will create a some tests to make sure our newly created polygon works properly:\n-\n-{{{diff_step 5.12}}}\n-\n-At last, all the necessary geometry shapes are implemented and ready to use. We will now focus on the snake itself. Since our game can potentially have infinite number of entities, not necessarily just a snake, we will add the a new module under the `Game` namespace called `Entities`:\n-\n-{{{diff_step 5.13}}}\n-\n-And now we can add the `Snake` class:\n-\n-{{{diff_step 5.14}}}\n-\n-This class is titled with most complexity out of everything we did so far in this step. You can follow the code accompanied by comments regard it, but I'd also like to explain the key concepts. As said earlier, the `Snake` is simply made out of shapes; In this case - lines and circles.\n-\n-The `draw` method just goes through this array and draws whatever shape it's currently looping through. Regardless of its type, every shape is provided with a `draw` method of its own, all shapes share the same interface, therefore we can just draw them regularly and the snake should be drawn automatically.\n-\n-The `update` method updates the last bit only according to its type, the time elapsed and the speed of the snake. For example, the last bit of the snake is a line, and 5 seconds have passed at a speed of 5 meters per second, our line should be extended by 5 meters long. Same principle applies to circle extension only based on radians. The last bit's type might be changed according to the current input; e.g. if the `right` key is held the last bit would turn into a circle, and once released it would turn into a straight line.\n-\n-Note that besides shapes extension, collision detection should also be made. The embedded is the collision detection between the snake and the canvas, which means that any time the snake collides with the canvas's boundaries the last bit should be redrawn from the opposite side of the canvas. In addition, we've implemented intersection methods for self collision detection and collision detection between rivals, which should be used externally by the hosting screen.\n-\n-In the next step we will be implementing the game screen where we will make use of the `Snake` class we've just created, and see how it works in action.\n\\ No newline at end of file\ndiff --git a/manuals/templates/step6.md b/manuals/templates/step6.md\ndeleted file mode 100644\nindex 646f23b..0000000\n--- a/manuals/templates/step6.md\n+++ /dev/null\n@@ -1,58 +0,0 @@\n-![snake-demo-game-small](https://cloud.githubusercontent.com/assets/7648874/21074124/8b7cd724-bed7-11e6-9f91-2a211630ac78.gif)\n-\n-In this step we will be using the `Snake` class we've just created in the previous step to form the actual game screen - called the `Play` screen. The play screen is a complex screen made out multiple layers as following:\n-\n-- **`Ready` layer** - Displays a message at the beginning of each match.\n-- **`Snake` layer** - Displays the the competitors' snakes.\n-- **`Score` layer** - Displays the score board.\n-- **`Win` layer** - Displays the winner at the end of each match.\n-\n-As we go further with this step, we will give a deeper explanation about each layer and how they interact with each other; As for let's start with the `Play` screen's basis. Regardless of what the `Play` screen should contain at the final result, we want to have the ability to abort the match whenever we press the `Escape` key, therefore, the initial implementation should look like this:\n-\n-{{{diff_step 6.1}}}\n-\n-Now that we have the `Play` screen, we need to hook it to the `Menu` screen, so whenever we press a key, we will be proceeded to it:\n-\n-{{{diff_step 6.2}}}\n-\n-By now there shouldn't be anything special. Once you're at the main menu, just press a key as instructed, and you shall see a black screen, which is actually the `Play` screen we've just created; And once you'll press the `Escape` key, you should be receded to the main menu.\n-\n-The next stage would be displaying a `Ready` message on the screen, and whenever a key is pressed, the message should fade away using a key-frame animation, and the match should start in the background:\n-\n-{{{diff_step 6.3}}}\n-\n-In order to hook the `Ready` layer to the `Play` screen, we will just push a new instance of it to the layers stack, using the screen's `appendLayer` method. Note that the order of the layer is super critic! Since if we push a new layer it means it will be drawn on top of any previous layer. To \"shift\" a layer to the layers stack, we can simply use the `prependLayer` method instead. Without further due, this is how our hook should look like:\n-\n-{{{diff_step 6.4}}}\n-\n-Now if you'll launch the game and start a new match, you should see a white `Ready` message in the middle of the screen. Up next, would be the `Snake` layer, which will simply initialize 2 new `Snake` instances, and take care of drawing and updating them:\n-\n-{{{diff_step 6.5}}}\n-\n-Once pressing a key in the `Ready` layer, not only we want to display an animation, but we also want the match to start in the background, thus, we gonna push a new instance of the `Snake` layer we've just created like so:\n-\n-{{{diff_step 6.6}}}\n-\n-Note that the layer is pushed when the animation starts and not once finished; This would give a nice smooth feeling to our game-flow. If you'll test out the game, you would discover that the match is actually playable! The first snake (Red) snake should be controlled by the arrow keys, and the second snake (Blue) should be controlled by the letter keys `a`, `s`, `d` and `w`. So far, the snakes function great, but you can probably tell that whenever a match is finished, it feels a bit dull. There's no indication of winning, and there's no score board to present the score of each competitor, which brings us to the next stage - Implementing the `Score` layer.\n-\n-The `Score` layer is a simple layer which takes the 2 snakes as a parameter and displays their scores at the top of the screen:\n-\n-{{{diff_step 6.7}}}\n-\n-> Note that the current score board is suitable for two players, but can easily be modified to support as much players as you want if done correctly.\n-\n-The `Score` board should be appended to the layers stack as soon as the `Snake` layers is initialized, so it would be available to us once the match is started:\n-\n-{{{diff_step 6.8}}}\n-\n-Now we're one layer further from completing the `Play` screen, the only thing missing is the `Win` layer, which should present the winner once the match is finished:\n-\n-{{{diff_step 6.9}}}\n-\n-Note how we use the `changeScreen` method once the `Win` layer has reached its age limit (Time to live, aka `ttl`); This would clear the layers stack and restart the `Play` screen, so we can start a new match all-over, only this time we will pass the `Snake` instances to reserve the original scores. The `Win` layer should be presented whenever a collision has been detected between the snakes:\n-\n-{{{diff_step 6.10}}}\n-\n-That's it folks, the `Play` screen is finished, and you can play as much matches as you'd feel like.\n-\n-Although the game is finished, it can still be optimized using `C++`. To discover more on hooking efficiency and how we can hook `C++` to the browser, see the next step.\n\\ No newline at end of file\ndiff --git a/manuals/templates/step7.md b/manuals/templates/step7.md\ndeleted file mode 100644\nindex 476a795..0000000\n--- a/manuals/templates/step7.md\n+++ /dev/null\n@@ -1,240 +0,0 @@\n-> This step is part of a bigger tutorial series where we learn how to create a game engine and implement a Tron-style game in JavaScript. The base project for the following step is available [here](https://github.com/DAB0mB/radial-snake/tree/step6).\n-\n-So far I covered up pretty much everything I planned. I showed you how to create a game engine, including a font generator, an animation player and a screening system. On top of that, we've learned how to structure and organize our code well, so if in the future we'd like to extend our game by adding more screens or capabilities, we can do that with ease. Indeed, we've went through lots of great stuff, and if you've reached this point I give you my thumbs up. If so far this wasn't enough, in this step we will be focusing on optimization, and making our game engine run faster (a lot, faster). Obviously, when talking about optimizations, the first thing you would probably think of is how we can make our algorithms efficient by using minimum number of operations. While this is true, we will be actually focusing on optimizing our code using C++.\n-\n-Unlike JavaScript, which is a dynamic scripting file executed by an interpreter, C++ is a general purpose language which compiles into executables. Naturally, executables are much faster than scripts, since they don't have to be interpreted, and they can approach the hardware and memory much faster. In C++, we have to explicitly define our data-types, meaning that variables don't have to be parsed during run-time. While explicit variables definition is C++'s biggest drawback, it's also one of its biggest advantages. The mere fact that variables can be handled much faster, makes code much more efficient.\n-\n-Accordingly, we can conclude that the programming language we're using plays a very important role when it comes to efficiency. So how exactly are we going to integrate C++ into the browser? We're going to do that by using a compiler called - [Emscripten](http://kripken.github.io/emscripten-site/).\n-\n-![emscripten](https://cloud.githubusercontent.com/assets/7648874/22675449/ee6d7e9c-eccc-11e6-9570-1dd5d982ee66.png)\n-\n-Emscripten is an Open Source [LLVM](https://en.wikipedia.org/wiki/LLVM) to JavaScript compiler. Using Emscripten you can:\n-\n-- Compile C and C++ code into JavaScript\n-- Compile any other code that can be translated into LLVM bitcode into JavaScript.\n-- Compile the C/C++ runtimes of other languages into JavaScript, and then run code in those other languages in an indirect way (this has been done for Python and Lua)!\n-\n-LLVM is a library that is used to construct, optimize and produce intermediate and/or binary machine code. LLVM can be used as a compiler framework, where you provide the \"front end\" (parser and lexer) and the \"back end\" (code that converts LLVM's representation to actual machine code). LLVM can also act as a JIT compiler - it has support for x86/x86_64 and PPC/PPC64 assembly generation with fast code optimizations aimed for compilation speed.\n-\n-Emscripten operates by taking LLVM code and converting it into a subset of JavaScript called asm.js that can run anywhere that JavaScript can run (usually the browser, but also Node.js, etc.) and is easy for browsers to optimize. This means that you can basically write web applications in any language that has an LLVM compiler.\n-\n-![emscripten-flow](https://cloud.githubusercontent.com/assets/7648874/22675751/b244b76c-ecce-11e6-917e-f7039ed4b340.png)\n-\n-In order to use Emscripten you will first have to install it. I recommend you to follow Emscripten's official installation instructions at their website over [here](https://kripken.github.io/emscripten-site/docs/getting_started/downloads.html). Installing Emscripten might be a bit tiring for some, I know for me it was, but if you're hyped about writing native code in the browser as much as I do, take as much time as needed to install it, and bare with me.\n-\n-Assuming that you have Emscripten installed, we can get right to business. The goal for this step is to re-implement our geometry namespace in C++, and to be more specific, the circle class and line class. We will start by creating an entry file for our C++ code under the path `resources/cpp/src/index.cpp`:\n-\n-    $ mkdir resources/cpp\n-    $ mkdir resources/cpp/src\n-    $ touch resources/cpp/src/index.cpp\n-\n-From now on, every C++ file that we would like to run in the browser should be included in the `index.cpp` file we've just created, otherwise it's not going to appear anywhere. The first stage for re-implementing our geometry would be re-writing the utility module, since our geometry is heavily based on it; Therefore the firs inclusion in our `index.cpp` file would be the following:\n-\n-{{{diff_step 7.1}}}\n-\n-Following that, we will create the `utils.cpp` module included above, which is a direct translation from C++ to JavaScript for the `utils.js` we've created earlier in this tutorial.\n-\n-{{{diff_step 7.2}}}\n-\n-The module above should work by itself when interacting with it inside the C++ scope, but that's not what we're striving for. We want this module to be available for use in our JavaScript project. This requires us to wrap our code in such a way the the Emscripten compiler will know how to compile it. Apart from providing a compiler, Emscripten provides us with functions and macros that will help use bind our C++ code to the JavaScript environment. These functionalities are packed in a single library which can be imported in our C++ code, and it is called [Embind](https://kripken.github.io/emscripten-site/docs/porting/connecting_cpp_and_javascript/embind.html) (probably stands for \"Emscripten bind\"). Using EMBind, let's wrap our utils module accordingly:\n-\n-{{{diff_step 7.3}}}\n-\n-After a while you'll get used for Embind's API. If you'll look at it, it's self explanatory and easy to understand. Bound objects will be available the JavaScript environment will be available under an object named `Module`, e.g. the C++ method `mod` will be available for use as `Module.utils_mod`. Bound functions should have supported return types and argument types, meaning that if we're using a custom structure as a return type or an argument type, we first need to wrap it using EMBind, otherwise the compiler won't know how to handle it. A list of natively supported data-types can be found [here](https://kripken.github.io/emscripten-site/docs/porting/connecting_cpp_and_javascript/embind.html#built-in-type-conversions).\n-\n-Even though we've wrapped our C++ code and hypothetically it can already be used in the browser, I'd go for a second wrapper, since the compiled code doesn't have the optimal architecture. Right now we will have to approach C++ utility functions using `Module.utils_foo`. Instead, I'd like it to be `CPP.Utils.foo`, since it's clearer this way. The output of the Emscripten compiler can be wrapped with JavaScript code, using a prefix and a suffix, defined in 2 separate files respectively, called `pre.js` and `post.js`:\n-\n-{{{diff_step 7.4}}}\n-\n-What we've done in the code snippet above, we've created an anonymous function which calls itself, and inside we've exported a new namespace called `CPP` (C++). This way we can keep the generated code encapsulated, without worrying about spamming the global object.\n-\n-After creating a wrapper, I'd also recommend you to integrate the generated C++ code into existing namespaces, meaning that if for example we would like to approach the `CPP.Utils.foo` method, it could be done using `Utils.foo`. This way existing code won't have to be changed, and extra wrapping logic can be applied with ease, like the chaining logic implemented in the `Utils` namespace:\n-\n-{{{diff_step 7.5}}}\n-\n-Whenever launching the compiler, the generated code should be outputted somewhere. I've decided to go with the path `resources/scripts/cpp.bundle.js`, but it doesn't matter how the file is gonna be called, as long as it's defined under the `scripts` dir, otherwise we won't be able to load it. Also, we need to make sure that we set a git-ignore rule for the generated file, since there's no reason for us to upload it to the git-host if we're planning on compiling it:\n-\n-{{{diff_step 7.5}}}\n-\n-To compile our C++ code and turn it into JavaScript, we'll need to run the following command:\n-\n-    $ emcc -O1 --pre-js resources/cpp/pre.js --post-js resources/cpp/post.js --bind -o resources/scripts/cpp.bundle.js resources/cpp/src/index.cpp\n-\n-Here's a detailed list with explanations regards the arguments vector we've just passed:\n-\n-- `-01` - Optimization level 1. The higher the index, the more optimized our code is gonna be, but less readable.\n-- `--pre-js` - Specifies a JavaScript prefix for the compiled code.\n-- `--post-js` - Specifies a JavaScript postfix for the compiled code.\n-- `--bind` - Tells the compiler to use Embind\n-- `-o` - The output path.\n-\n-> More informations regards Emscripten's CLI can be found [here](https://kripken.github.io/emscripten-site/docs/tools_reference/emcc.html).\n-\n-You don't have to memorize the compilation command we've just typed, because we're gonna save it as an NPM script called `build:cpp`:\n-\n-{{{diff_step 7.6}}}\n-\n-Now if you'd like to compile the C++ code just run:\n-\n-    $ npm run build:cpp\n-\n-Moreover, the code should be compiled automatically any time you start the serer using the command:\n-\n-    $ npm run serve\n-\n-We always have to be on the alert and run our tests against modules we've just translated from JavaScript to C++. This will guarantee that once we run the game we won't stumble upon any defect whatsoever. Before running the tests, be sure to import the C++ bundle in the HTML file's header:\n-\n-{{{diff_step 7.8}}}\n-\n-Now we can run the tests by running the following command:\n-\n-    $ npm run test\n-\n-At this point **all our tests should pass**. If they don't, it means our newly created utility module is not working properly, and you will have to repeat the previous steps until you get it right.\n-\n-Up next, we gonna translate the geometry line class to C++. Since it's gonna be translated almost identically, we will have to make sure that all the necessary assets are gonna be available for our class before proceeding. The first thing we will have to do would be making sure that the utility functions are chainable directly from C++ as well. To do that, we will create a chain class which should return a new instance of it whenever we're about to chain the upcoming utility method. Once calling `result()`, the accumulator should be returned:\n-\n-{{{diff_step 7.9}}}\n-\n-> Note that when coding in C++ we have to make sure that the objects are being disposed when not needed anymore, otherwise we will have some unnecessary memory leaks.\n-\n-2D shapes are presented in space using points with 2 values - `x` (axis) and `y` axis, therefore, we will create the appropriate point structure:\n-\n-{{{diff_step 7.10}}}\n-\n-Returned values can either be `null` (`undefined`) or not. Since there's no built in nullable-values mechanism in C++ (up until C++17), we're gonna create one of our own:\n-\n-{{{diff_step 7.11}}}\n-\n-Now that all the necessary assets for the line class are ready, we can go ahead and create it:\n-\n-{{{diff_step 7.12}}}\n-\n-After creating our C++, we will also need to bind it using EMBind:\n-\n-{{{diff_step 7.13}}}\n-\n-In the code snippet above, you can see that we used a special data-type called `val` (`emscripten::val`). `val` means that just like JavaScript, that function can return values that are not necessarily of the same data-type; For instance, the `getMatchingY` function can either return a `number` or `undefined`. If you'll take a look at the `getIntersection(Line)` method you'll notice that instead of returning the raw point structure, I chose to build a JavaScript object using the `object` data type (`emscripten::object`). `object` behaves exactly like a native JavaScript `Object`, and it can save us some precious work of binding which sometimes might be just too much.\n-\n-If you'll compare the C++ version of the line class to the JavaScript line class you'll notice that the `draw` and `getIntersection` methods are missing (when we used EMBind we renamed `getIntersection` to `getLineIntersection` because overloadings are forbidden). In addition, Emscripten's API exposes some additional class methods for generated C++ classes, like the `delete` method, which we will shed light on further in this tutorial. Inheritance would be the natural solution for such an issue, unfortunately, generated C++ constructors don't accept indirect instances. For example, if we have a C++ parent class called `Shape` and we have a JavaScript child class called `Line`, we won't be able to initialize a new instance of the `Line` class. Here's a demonstration:\n-\n-```js\n-class JSLine extends CPPShape {}\n-const line = new JSLine(); // Throws error\n-```\n-\n-There are 3 ways to implement inheritance when interacting with C++ classes:\n-\n-- Define an interface when using EMBind. This is the official way but rather complicated, since it requires us to define an extra layer for our wrapper. More information can be found [here](https://kripken.github.io/emscripten-site/docs/porting/connecting_cpp_and_javascript/embind.html#abstract-methods).\n-- Extending the prototype of exported C++ classes directly, which is not really an inheritance.\n-- Using a proxy class, which is the easiest and cleanest solution of all, but it is not really mentioned anywhere. At the same time, I didn't find any restriction regards that.\n-\n-We're gonna use the 3rd method in the list above, because as I said, it's the easiest and cleanest of all. First I will try to explain what I meant by saying \"proxy class\". If you're an intermediate JavaScript developer, you probably know that constructors can be overridden by returning a value explicitly. By doing that, we can actually bypass Emscripten's prohibitions, we can just return the newly created C++ instance and extend it in specific. Proxy classes actually take it a step further by providing a middle-class which will then inject a new link to the prototype chain of the returned instance.\n-\n-```js\n-class JSLine {\n-  constructor() {\n-    const line = new CPPShape();\n-    return line;\n-  }\n-}\n-\n-const line = new JSLine(); // Legal!\n-```\n-\n-> More information about the code snippet above can be found [here](https://www.bennadel.com/blog/2522-providing-a-return-value-in-a-javascript-constructor.htm).\n-\n-I believe that as we go through this tutorial, the concept will get much clearer. The utility function of the proxy class should look like so:\n-\n-{{{diff_step 7.14}}}\n-\n-If you'll take a look at the following line:\n-\n-```js\n-Object.setPrototypeOf(that, new.target.prototype);\n-```\n-\n-This is where the magic actually happens! It enables inheritance for explicitly returned objects; This way we can safely extend C++ classes. Accordingly, our new JavaScript line class should look like so:\n-\n-{{{diff_step 7.15}}}\n-\n-By now, our tests should pass. Accept, there is memory leak we need to handle. But you probably ask yourself - \"What memory leak? It's JavaScript man! Have you ever heard of something called garbage collector?!\". Well, this is not the case when compiling C++ code with Emscripten. You see, Emscripten uses asm.js, which is a subset for JavaScript built exactly for these proposes, enabling C++ modules run on the browser. This is how the [WebGL](https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API) project actually started, an almost complete conversion from the famous C++ [OpenGL](https://www.opengl.org/) to JavaScript. Part of what asm.js does, it disables the garbage collector, and instead, it holds raw pointers, just like in C++. Since returned class instances are pointers with unknown lifespans, they need to be disposed manually, using the `delete` method (identical to how we clear memory from the Heap in C++). Let's dispose unused test data by calling the `delete` method as just mentioned:\n-\n-{{{diff_step 7.16}}}\n-\n-Since our game also uses polygons, which is made of an abstract number of lines, its test-data needs to be disposed as well. First, we will add a `delete` method to the polygon class, which will simply go though all its bounds and delete each of its lines:\n-\n-{{{diff_step 7.17}}}\n-\n-Now we can conveniently delete unused polygons in the tests:\n-\n-{{{diff_step 7.18}}}\n-\n-Moving on, we have the circle class to transform. The process is almost the identical to how we transformed the line class, so it's gonna be way easier now. We first start by translating our code from JavaScript to C++:\n-\n-{{{diff_step 7.19}}}\n-\n-Second, we need to wrap our code using EMBind:\n-\n-{{{diff_step 7.20}}}\n-\n-And finally, we will extend the C++ in our JavaScript circle:\n-\n-{{{diff_step 7.21}}}\n-\n-We also need to update the line class to contain a reference to the newly created line-intersection method, so it can be invoked from both a line or a circle bi-directionally:\n-\n-{{{diff_step 7.22}}}\n-\n-Now, before running the tests, be sure to disposed unused circle test-data:\n-\n-{{{diff_step 7.23}}}\n-\n-Our C++ code should be finished now, and all the tests should be passing. The only thing left to do would be applying it to our game. Like any other application, we first need to reference the script file so it can be loaded, in this case, the C++ bundle script:\n-\n-{{{diff_step 7.24}}}\n-\n-And now we need to make sure to dispose the geometry shapes correctly so we won't experience any unnecessary memory leaks. Most of our disposals should go to the snake entity, since it's made out of shapes; So we will add a `delete` method to the snake entity and we will dispose it whenever a match is finished:\n-\n-{{{diff_step 7.25}}}\n-\n-Congratulations! You've created a C++ cross JavaScript game. There shouldn't be any significant difference between the C++ version of the game and the JavaScript version on most machines, since the game is very small and barely requires any processing power. You'll probably notice the difference when starting to extend the game by adding terrains or more snakes.\n-\n-One might ask - \"How much faster does my game actually run?\". The short answer is - around 50%. Why did I run into this conclusion? Well, take a look at the following JavaScript code snippet, for calculating Fibonacci of 42:\n-\n-```js\n-function fib(x) {\n-  if (x < 2) {\n-    return 1;\n-  }\n-  else {\n-    return fib(x - 1) + fib(x - 2);\n-  }\n-}\n-```\n-\n-The same code snippet should look almost identical written in C++:\n-\n-```cpp\n-int fib(int x) {\n-  if (x < 2) {\n-    return 1;\n-  }\n-  else {\n-    return fib(x - 1) + fib(x - 2);\n-  }\n-}\n-```\n-\n-However, the run-times are completely different! I compared the average of 10 runs in 3 different environments, and I received the following results:\n-\n-![chart](https://cloud.githubusercontent.com/assets/7648874/22802494/2591025e-eef8-11e6-9679-10b5bca0ef30.png)\n-\n-As you can see, the generated C++ is much faster, and to be precise, 57% faster! Surprisingly, I didn't have any significant difference between Emscripten generated C++ and natively compiled executable.\n-\n-C++ is more complex to write, but it certainly has its advantages over JavaScript. Remember, now that you know that you have the possibility to run C++ in the browser, make sure to use it, but never overdo it, always find the right balance between readability and performance.\n-\n-> *Sources:*\n-> - *https://kripken.github.io/emscripten-site/docs/introducing_emscripten/index.html*\n-> - *http://www.crunchy.com/?q=content/emscripten-perfectly-cromulent-compiler*\n-> - *http://stackoverflow.com/questions/2354725/what-exactly-is-llvm*\ndiff --git a/manuals/templates/step8.md b/manuals/templates/step8.md\ndeleted file mode 100644\nindex 607c84b..0000000\n--- a/manuals/templates/step8.md\n+++ /dev/null\n@@ -1,14 +0,0 @@\n-That was it y'all, hopefully you like this tutorial. Definitely a refresher when you have all these high-level frameworks out there.\n-\n-Check out my previous tutorial on how to write a native add-on to `NodeJS` using `C++`: https://github.com/DAB0mB/node-distance-addon\n-\n-Be sure to â˜…*â˜…***â˜…STARâ˜…***â˜…*â˜… this repository: https://github.com/DAB0mB/radial-snake.\n-\n-If you have any suggestions, issues, and things you'd like to ask, be sure to open an issue in the issues section: https://github.com/DAB0mB/radial-snake/issues\n-\n-For more awesome tutorials and upcoming projects, please follow me on:\n-\n-- **Github** - https://github.com/DAB0mB\n-- **Twitter** - https://twitter.com/eytan_manor\n-\n-Stay frosty 'til next time. Peace â˜®.\n\\ No newline at end of file\ndiff --git a/manuals/views/root.md b/manuals/views/root.md\ndeleted file mode 120000\nindex fe84005..0000000\n--- a/manuals/views/root.md\n+++ /dev/null\n@@ -1 +0,0 @@\n-../../README.md\n\\ No newline at end of file\ndiff --git a/manuals/views/step1.md b/manuals/views/step1.md\ndeleted file mode 100644\nindex fd103b2..0000000\n--- a/manuals/views/step1.md\n+++ /dev/null\n@@ -1,478 +0,0 @@\n-[{]: <region> (header)\n-# Step 1: Creating a server\n-[}]: #\n-[{]: <region> (body)\n-The first thing we will learn to do would be creating a server so we can serve our assets. We will be using [HapiJS](https://hapijs.com/) to build a REST API, although this step can be implemented with any library you'd want, like [ExpressJS](http://expressjs.com/) or [Connect](https://www.senchalabs.github.com/connect) etc. Let's install it then:\n-\n-    $ npm install hapi --save\n-\n-We will start by setting up a basis for our server, and we will expand it as we go further in this step. A general boiler plate should look like so:\n-\n-[{]: <helper> (diff_step 1.2)\n-#### Step 1.2: Add server basis\n-\n-##### Added server.js\n-```diff\n-@@ -0,0 +1,36 @@\n-+â”Š  â”Š 1â”Šconst Hapi = require(\"hapi\");\n-+â”Š  â”Š 2â”Š\n-+â”Š  â”Š 3â”Šlet port = 8000;\n-+â”Š  â”Š 4â”Š\n-+â”Š  â”Š 5â”Š// Initialize a new server\n-+â”Š  â”Š 6â”Šlet server = new Hapi.Server();\n-+â”Š  â”Š 7â”Š\n-+â”Š  â”Š 8â”Šserver.connection({ port: process.env.PORT || port });\n-+â”Š  â”Š 9â”Š\n-+â”Š  â”Š10â”Š// Report each response made\n-+â”Š  â”Š11â”Šserver.ext(\"onPreResponse\", (req, rep) => {\n-+â”Š  â”Š12â”Š  let res = req.response;\n-+â”Š  â”Š13â”Š\n-+â”Š  â”Š14â”Š  console.log(\"Outcoming response:\");\n-+â”Š  â”Š15â”Š  console.log(`in: ${new Date}`);\n-+â”Š  â”Š16â”Š  console.log(`to: ${req.info.remoteAddress}`);\n-+â”Š  â”Š17â”Š  console.log(`method: ${req.method}`);\n-+â”Š  â”Š18â”Š  console.log(`url: ${req.url.path}`);\n-+â”Š  â”Š19â”Š  console.log(`status: ${res.statusCode || res.output.statusCode}`);\n-+â”Š  â”Š20â”Š  console.log();\n-+â”Š  â”Š21â”Š\n-+â”Š  â”Š22â”Š  rep.continue();\n-+â”Š  â”Š23â”Š});\n-+â”Š  â”Š24â”Š\n-+â”Š  â”Š25â”Š// Print message once started\n-+â”Š  â”Š26â”Šserver.start((err) => {\n-+â”Š  â”Š27â”Š  if (err) throw err;\n-+â”Š  â”Š28â”Š\n-+â”Š  â”Š29â”Š  console.log();\n-+â”Š  â”Š30â”Š  console.log(\"---------- -------- ------ ---- --\");\n-+â”Š  â”Š31â”Š  console.log(\"----- ---- --- -- -\");\n-+â”Š  â”Š32â”Š  console.log(`Server running at ${port}`);\n-+â”Š  â”Š33â”Š  console.log(\"----- ---- --- -- -\");\n-+â”Š  â”Š34â”Š  console.log(\"---------- -------- ------ ---- --\");\n-+â”Š  â”Š35â”Š  console.log();\n-+â”Š  â”Š36â”Š});ðŸš«â†µ\n-```\n-[}]: #\n-\n-We simply initialize a new server which will connect to port `8000` by default, unless we defined an environment variable called `PORT`. Once the server is started, and whenever there is an outcoming response, a message will be printed to the console.\n-\n-> More information and configuration options regards HapiJS's API can be found in this [here](https://hapijs.com/).\n-\n-Now that the basis is ready, we want a convenient way to launch it. Repetitive scripts are usually defined in the `package.json` file under the `scripts` field. To start the server, we gonna create a simple script called `serve`:\n-\n-[{]: <helper> (diff_step 1.3)\n-#### Step 1.3: Add serve npm script\n-\n-##### Changed package.json\n-```diff\n-@@ -2,6 +2,9 @@\n- â”Š 2â”Š 2â”Š  \"name\": \"radial-snake\",\n- â”Š 3â”Š 3â”Š  \"description\": \"A tutorial for creating a Tron-style game\",\n- â”Š 4â”Š 4â”Š  \"private\": true,\n-+â”Š  â”Š 5â”Š  \"scripts\": {\n-+â”Š  â”Š 6â”Š    \"serve\": \"node server.js\"\n-+â”Š  â”Š 7â”Š  },\n- â”Š 5â”Š 8â”Š  \"dependencies\": {\n- â”Š 6â”Š 9â”Š    \"hapi\": \"^16.0.1\"\n- â”Š 7â”Š10â”Š  }\n-```\n-[}]: #\n-\n-To run this script, we will simply need to type the following:\n-\n-    $ npm run serve\n-\n-This will run our server, and you should see the following message printed to the console:\n-\n-```\n----------- -------- ------ ---- --\n------ ---- --- -- -\n-Server running at 8000\n------ ---- --- -- -\n----------- -------- ------ ---- --\n-```\n-\n-> As for now, nothing happens, because we didn't define any handlers for HTTP requests. I will get to it in a bit, stay with me.\n-\n-The main disadvantage of starting a server directly with node is that we have no listeners for changes in our files, so if we want the served files to be updated, we will have to restart our server anytime we make a change. To avoid that, we gonna use [nodemon](https://nodemon.io/), which is a simple utility that can monitor changes is source files and automatically restart our server. To install it, type the following:\n-\n-    $ sudo npm install nodemon -g\n-\n-Now that we have it, we will need to update our `serve` npm script to use `nodemon` instead of `node`:\n-\n-[{]: <helper> (diff_step 1.4)\n-#### Step 1.4: Change serve npm script to use nodemon\n-\n-##### Changed package.json\n-```diff\n-@@ -3,7 +3,7 @@\n- â”Š3â”Š3â”Š  \"description\": \"A tutorial for creating a Tron-style game\",\n- â”Š4â”Š4â”Š  \"private\": true,\n- â”Š5â”Š5â”Š  \"scripts\": {\n--â”Š6â”Š â”Š    \"serve\": \"node server.js\"\n-+â”Š â”Š6â”Š    \"serve\": \"nodemon server.js\"\n- â”Š7â”Š7â”Š  },\n- â”Š8â”Š8â”Š  \"dependencies\": {\n- â”Š9â”Š9â”Š    \"hapi\": \"^16.0.1\"\n-```\n-[}]: #\n-\n-The basis for our server is pretty much complete. From now on we gonna build stuff on top of it and extend our server. I'd like to add a small attachment to our server. I want that the IP address of the current computer will be printed to the console once the server is started. For this, we first gonna create a helper which we gonna call `ip_grabber`:\n-\n-[{]: <helper> (diff_step 1.5)\n-#### Step 1.5: Add ip_grabber helper\n-\n-##### Added helpers/ip_grabber.js\n-```diff\n-@@ -0,0 +1,23 @@\n-+â”Š  â”Š 1â”Šconst Os = require(\"os\");\n-+â”Š  â”Š 2â”Š\n-+â”Š  â”Š 3â”Š// Grab local IP address of which the NodeJS process runs on\n-+â”Š  â”Š 4â”Šfunction local() {\n-+â”Š  â”Š 5â”Š  let interfaces = Os.networkInterfaces();\n-+â”Š  â”Š 6â”Š  let addresses = [];\n-+â”Š  â”Š 7â”Š\n-+â”Š  â”Š 8â”Š  for (let k in interfaces) {\n-+â”Š  â”Š 9â”Š    for (let k2 in interfaces[k]) {\n-+â”Š  â”Š10â”Š      let address = interfaces[k][k2];\n-+â”Š  â”Š11â”Š\n-+â”Š  â”Š12â”Š      if (address.family == \"IPv4\" && !address.internal) {\n-+â”Š  â”Š13â”Š        addresses.push(address.address);\n-+â”Š  â”Š14â”Š      }\n-+â”Š  â”Š15â”Š    }\n-+â”Š  â”Š16â”Š  }\n-+â”Š  â”Š17â”Š\n-+â”Š  â”Š18â”Š  return addresses[0];\n-+â”Š  â”Š19â”Š}\n-+â”Š  â”Š20â”Š\n-+â”Š  â”Š21â”Šmodule.exports = {\n-+â”Š  â”Š22â”Š  local\n-+â”Š  â”Š23â”Š};ðŸš«â†µ\n-```\n-[}]: #\n-\n-This module simply goes through the available network interfaces and grabs the IP address of the default gateway using the `os` module. Now that we have it, let's import it in the server's entry file and use the `local` method to grab the IP address and report it once the server is started:\n-\n-[{]: <helper> (diff_step 1.6)\n-#### Step 1.6: Print IP address once server is started\n-\n-##### Changed server.js\n-```diff\n-@@ -1,5 +1,7 @@\n- â”Š1â”Š1â”Šconst Hapi = require(\"hapi\");\n-+â”Š â”Š2â”Šconst IpGrabber = require(\"./helpers/ip_grabber\");\n- â”Š2â”Š3â”Š\n-+â”Š â”Š4â”Šlet localIp = IpGrabber.local();\n- â”Š3â”Š5â”Šlet port = 8000;\n- â”Š4â”Š6â”Š\n- â”Š5â”Š7â”Š// Initialize a new server\n-```\n-```diff\n-@@ -29,7 +31,7 @@\n- â”Š29â”Š31â”Š  console.log();\n- â”Š30â”Š32â”Š  console.log(\"---------- -------- ------ ---- --\");\n- â”Š31â”Š33â”Š  console.log(\"----- ---- --- -- -\");\n--â”Š32â”Š  â”Š  console.log(`Server running at ${port}`);\n-+â”Š  â”Š34â”Š  console.log(`Server running at ${localIp}:${port}`);\n- â”Š33â”Š35â”Š  console.log(\"----- ---- --- -- -\");\n- â”Š34â”Š36â”Š  console.log(\"---------- -------- ------ ---- --\");\n- â”Š35â”Š37â”Š  console.log();\n-```\n-[}]: #\n-\n-By now you should have the following message printed to the console once you start the server:\n-\n-```\n----------- -------- ------ ---- --\n------ ---- --- -- -\n-Server running at 95.221.122.30:8000\n------ ---- --- -- -\n----------- -------- ------ ---- --\n-```\n-\n-> Instead of `95.221.122.30` you should have the IP address which is right for you.\n-\n-Now comes the most important part - handling HTTP requests! Because what does a server worth if it doesn't know how to handle anything? When using `HapiJS`, we can separate extensions to our server in different modules, and eventually register them as plug-ins. So the first plug-in is gonna be the routes batch for the endpoints - it will take care of serving file requests as is, and basically turning local directories into public ones. This is useful because our game is going to be dependent on many assets like textures, images, fonts, and so on... But before I go into the implementation part we first need to install a couple of libraries which will help us with the task. The first one is going to be `async`, which will take care of managing the control flow of asynchronous code:\n-\n-    $ npm install async --save\n-\n-And the second library is going to be `inert`, which is a `HapiJS` plug-in which will give us the ability to serve files from local directories:\n-\n-    $ npm install inert --save\n-\n-Now that we're set, let's implement the `endpoints` routes batch:\n-\n-[{]: <helper> (diff_step 1.8)\n-#### Step 1.8: Add endpoints routes\n-\n-##### Added routes/endpoints.js\n-```diff\n-@@ -0,0 +1,80 @@\n-+â”Š  â”Š 1â”Šconst Pack = require(\"../package.json\");\n-+â”Š  â”Š 2â”Š\n-+â”Š  â”Š 3â”Šregister.attributes = {\n-+â”Š  â”Š 4â”Š  name: \"endpoints\",\n-+â”Š  â”Š 5â”Š  version: Pack.version\n-+â”Š  â”Š 6â”Š};\n-+â”Š  â”Š 7â”Š\n-+â”Š  â”Š 8â”Šfunction register(server, options, next) {\n-+â”Š  â”Š 9â”Š  // Scripts endpoint\n-+â”Š  â”Š10â”Š  server.route({\n-+â”Š  â”Š11â”Š    method: \"GET\",\n-+â”Š  â”Š12â”Š    path: \"/scripts/{path*}\",\n-+â”Š  â”Š13â”Š    handler: {\n-+â”Š  â”Š14â”Š      directory: {\n-+â”Š  â”Š15â”Š        path: \"./resources/scripts/\"\n-+â”Š  â”Š16â”Š      }\n-+â”Š  â”Š17â”Š    }\n-+â”Š  â”Š18â”Š  });\n-+â”Š  â”Š19â”Š\n-+â”Š  â”Š20â”Š  // Style-sheets endpoint\n-+â”Š  â”Š21â”Š  server.route({\n-+â”Š  â”Š22â”Š    method: \"GET\",\n-+â”Š  â”Š23â”Š    path: \"/styles/{path*}\",\n-+â”Š  â”Š24â”Š    handler: {\n-+â”Š  â”Š25â”Š      directory: {\n-+â”Š  â”Š26â”Š        path: \"./resources/styles/\"\n-+â”Š  â”Š27â”Š      }\n-+â”Š  â”Š28â”Š    }\n-+â”Š  â”Š29â”Š  });\n-+â”Š  â”Š30â”Š\n-+â”Š  â”Š31â”Š  // Libraries endpoint\n-+â”Š  â”Š32â”Š  server.route({\n-+â”Š  â”Š33â”Š    method: \"GET\",\n-+â”Š  â”Š34â”Š    path: \"/libs/{path*}\",\n-+â”Š  â”Š35â”Š    handler: {\n-+â”Š  â”Š36â”Š      directory: {\n-+â”Š  â”Š37â”Š        path: \"./resources/libs/\"\n-+â”Š  â”Š38â”Š      }\n-+â”Š  â”Š39â”Š    }\n-+â”Š  â”Š40â”Š  });\n-+â”Š  â”Š41â”Š\n-+â”Š  â”Š42â”Š  // Images endpoint\n-+â”Š  â”Š43â”Š  server.route({\n-+â”Š  â”Š44â”Š    method: \"GET\",\n-+â”Š  â”Š45â”Š    path: \"/images/{path*}\",\n-+â”Š  â”Š46â”Š    handler: {\n-+â”Š  â”Š47â”Š      directory: {\n-+â”Š  â”Š48â”Š        path: \"./resources/images/\"\n-+â”Š  â”Š49â”Š      }\n-+â”Š  â”Š50â”Š    }\n-+â”Š  â”Š51â”Š  });\n-+â”Š  â”Š52â”Š\n-+â”Š  â”Š53â”Š  // Textures endpoint\n-+â”Š  â”Š54â”Š  server.route({\n-+â”Š  â”Š55â”Š    method: \"GET\",\n-+â”Š  â”Š56â”Š    path: \"/textures/{path*}\",\n-+â”Š  â”Š57â”Š    handler: {\n-+â”Š  â”Š58â”Š      directory: {\n-+â”Š  â”Š59â”Š        path: \"./resources/assets/textures/\"\n-+â”Š  â”Š60â”Š      }\n-+â”Š  â”Š61â”Š    }\n-+â”Š  â”Š62â”Š  });\n-+â”Š  â”Š63â”Š\n-+â”Š  â”Š64â”Š  // Fonts endpoint\n-+â”Š  â”Š65â”Š  server.route({\n-+â”Š  â”Š66â”Š    method: \"GET\",\n-+â”Š  â”Š67â”Š    path: \"/fonts/{path*}\",\n-+â”Š  â”Š68â”Š    handler: {\n-+â”Š  â”Š69â”Š      directory: {\n-+â”Š  â”Š70â”Š        path: \"./resources/assets/fonts/\"\n-+â”Š  â”Š71â”Š      }\n-+â”Š  â”Š72â”Š    }\n-+â”Š  â”Š73â”Š  });\n-+â”Š  â”Š74â”Š\n-+â”Š  â”Š75â”Š  next();\n-+â”Š  â”Š76â”Š}\n-+â”Š  â”Š77â”Š\n-+â”Š  â”Š78â”Šmodule.exports = {\n-+â”Š  â”Š79â”Š  register\n-+â”Š  â”Š80â”Š};ðŸš«â†µ\n-```\n-[}]: #\n-\n-This module actually represents a classic structure of a `HapiJS` plug-in. It should export a `name` for debugging proposes, a `version`, and a `register` function, which will take care of registering extensions to our server; in this case, these are the endpoints routes. To make this plug-in (Or any other plug-in) work, we need to register it. The registration is an asynchronous operation, thus we gonna handle it using `async`:\n-\n-[{]: <helper> (diff_step 1.9)\n-#### Step 1.9: Register ednpoints routes\n-\n-##### Changed server.js\n-```diff\n-@@ -1,11 +1,23 @@\n-+â”Š  â”Š 1â”Šconst Async = require(\"async\");\n- â”Š 1â”Š 2â”Šconst Hapi = require(\"hapi\");\n-+â”Š  â”Š 3â”Šconst Inert = require(\"inert\");\n-+â”Š  â”Š 4â”Šconst Endpoints = require(\"./routes/endpoints\");\n- â”Š 2â”Š 5â”Šconst IpGrabber = require(\"./helpers/ip_grabber\");\n- â”Š 3â”Š 6â”Š\n- â”Š 4â”Š 7â”Šlet localIp = IpGrabber.local();\n- â”Š 5â”Š 8â”Šlet port = 8000;\n- â”Š 6â”Š 9â”Š\n- â”Š 7â”Š10â”Š// Initialize a new server\n--â”Š 8â”Š  â”Šlet server = new Hapi.Server();\n-+â”Š  â”Š11â”Šlet server = new Hapi.Server({\n-+â”Š  â”Š12â”Š  connections: {\n-+â”Š  â”Š13â”Š    routes: {\n-+â”Š  â”Š14â”Š      files: {\n-+â”Š  â”Š15â”Š        // Served files will be relative to current directory\n-+â”Š  â”Š16â”Š        relativeTo: __dirname\n-+â”Š  â”Š17â”Š      }\n-+â”Š  â”Š18â”Š    }\n-+â”Š  â”Š19â”Š  }\n-+â”Š  â”Š20â”Š});\n- â”Š 9â”Š21â”Š\n- â”Š10â”Š22â”Šserver.connection({ port: process.env.PORT || port });\n- â”Š11â”Š23â”Š\n-```\n-```diff\n-@@ -24,8 +36,14 @@\n- â”Š24â”Š36â”Š  rep.continue();\n- â”Š25â”Š37â”Š});\n- â”Š26â”Š38â”Š\n-+â”Š  â”Š39â”Š// Register all routes and plug-ins\n-+â”Š  â”Š40â”ŠAsync.series([\n-+â”Š  â”Š41â”Š  next => server.register(Inert, next),\n-+â”Š  â”Š42â”Š  next => server.register(Endpoints, next),\n-+â”Š  â”Š43â”Š  // Once registrations are finished, start the server\n-+â”Š  â”Š44â”Š  next => server.start(next)\n- â”Š27â”Š45â”Š// Print message once started\n--â”Š28â”Š  â”Šserver.start((err) => {\n-+â”Š  â”Š46â”Š], (err) => {\n- â”Š29â”Š47â”Š  if (err) throw err;\n- â”Š30â”Š48â”Š\n- â”Š31â”Š49â”Š  console.log();\n-```\n-[}]: #\n-\n-Once all the plug-ins have been registered, we gonna start our server as we previously did. Note that we also registered the `inert` plug-in, because as I said earlier, that's what gives us the ability to handle files requests.\n-\n-Lastly, I want to create the `pages` routes batch, which will be responsible for serving pages in our application as listed above:\n-\n-- The `/` route will serve us the `game.html` file.\n-- The `/test` route will serve us the `spec_runner.html` file.\n-\n-By the name of each route and file you can probably what each one should do. The thing is, we don't want everyone to be able to access the `spec_runner.html` file, or the `game.html` file if in the middle of development. For this, we're going to create a new helper which will be responsible for handling permissions. So first we gonna install an npm package called `boom` which has the ability to format `permission denied` HTTP errors:\n-\n-    $ npm install boom --save\n-\n-And now we gonna implement the module itself:\n-\n-[{]: <helper> (diff_step 1.11)\n-#### Step 1.11: Add permitter helper\n-\n-##### Added helpers/permitter.js\n-```diff\n-@@ -0,0 +1,29 @@\n-+â”Š  â”Š 1â”Šconst Boom = require(\"boom\");\n-+â”Š  â”Š 2â”Šconst Hapi = require(\"hapi\");\n-+â”Š  â”Š 3â”Šconst IpGrabber = require(\"./ip_grabber\");\n-+â”Š  â”Š 4â”Š\n-+â”Š  â”Š 5â”Š// These addresses will be permitted by default\n-+â”Š  â”Š 6â”Šconst defaultPermissions = [\n-+â”Š  â”Š 7â”Š  IpGrabber.local(), \"127.0.0.1\", \"localhost\"\n-+â”Š  â”Š 8â”Š];\n-+â”Š  â”Š 9â”Š\n-+â”Š  â”Š10â”Š// Manage file permissions\n-+â”Š  â”Š11â”Šfunction file(path, permissions, req, rep) {\n-+â”Š  â”Š12â”Š  // Apply default permissions\n-+â”Š  â”Š13â”Š  permissions = permissions.concat(defaultPermissions);\n-+â”Š  â”Š14â”Š  // Request address\n-+â”Š  â”Š15â”Š  let remoteAddress = req.info.remoteAddress;\n-+â”Š  â”Š16â”Š\n-+â”Š  â”Š17â”Š  // If not permitted, reply error\n-+â”Š  â”Š18â”Š  if (permissions.indexOf(remoteAddress) == -1) {\n-+â”Š  â”Š19â”Š    let err = new Boom.forbidden(\"Missing permissions\");\n-+â”Š  â”Š20â”Š    return rep(err);\n-+â”Š  â”Š21â”Š  }\n-+â”Š  â”Š22â”Š\n-+â”Š  â”Š23â”Š  // If permitted, reply file\n-+â”Š  â”Š24â”Š  rep.file(path);\n-+â”Š  â”Š25â”Š}\n-+â”Š  â”Š26â”Š\n-+â”Š  â”Š27â”Šmodule.exports = {\n-+â”Š  â”Š28â”Š  file\n-+â”Š  â”Š29â”Š};ðŸš«â†µ\n-```\n-[}]: #\n-\n-The default permitted IP address would be the current computer's IP address. Extra IP permissions can be provided with the invocation of the `file` method. If the requesting IP is not listed in the permissions list, an error is gonna be replied instead of the requested file. Now that we have our \"permitter\" ready, let's implement the `pages` routes batch, only we're gonna pass the requests through the black-list, for the reason mentioned above:\n-\n-[{]: <helper> (diff_step 1.12)\n-#### Step 1.12: Add pages routes\n-\n-##### Added routes/pages.js\n-```diff\n-@@ -0,0 +1,35 @@\n-+â”Š  â”Š 1â”Šconst Hapi = require(\"hapi\");\n-+â”Š  â”Š 2â”Šconst Pack = require(\"../package.json\");\n-+â”Š  â”Š 3â”Šconst Permitter = require(\"../helpers/permitter\");\n-+â”Š  â”Š 4â”Š\n-+â”Š  â”Š 5â”Šregister.attributes = {\n-+â”Š  â”Š 6â”Š  name: \"pages\",\n-+â”Š  â”Š 7â”Š  version: Pack.version\n-+â”Š  â”Š 8â”Š};\n-+â”Š  â”Š 9â”Š\n-+â”Š  â”Š10â”Šfunction register(server, options, next) {\n-+â”Š  â”Š11â”Š  server.route({ method: \"GET\", path: \"/\", handler: getGame });\n-+â”Š  â”Š12â”Š  server.route({ method: \"GET\", path: \"/test\", handler: getSpecRunner });\n-+â”Š  â”Š13â”Š\n-+â”Š  â”Š14â”Š  next();\n-+â”Š  â”Š15â”Š}\n-+â”Š  â”Š16â”Š\n-+â”Š  â”Š17â”Š// Serve game page\n-+â”Š  â”Š18â”Šfunction getGame(req, rep) {\n-+â”Š  â”Š19â”Š  let path = \"./views/game.html\";\n-+â”Š  â”Š20â”Š  let permissions = [];\n-+â”Š  â”Š21â”Š\n-+â”Š  â”Š22â”Š  Permitter.file(path, permissions, req, rep);\n-+â”Š  â”Š23â”Š}\n-+â”Š  â”Š24â”Š\n-+â”Š  â”Š25â”Š// Serve test page\n-+â”Š  â”Š26â”Šfunction getSpecRunner(req, rep) {\n-+â”Š  â”Š27â”Š  let path = \"./views/spec_runner.html\";\n-+â”Š  â”Š28â”Š  let permissions = [];\n-+â”Š  â”Š29â”Š\n-+â”Š  â”Š30â”Š  Permitter.file(path, permissions, req, rep);\n-+â”Š  â”Š31â”Š}\n-+â”Š  â”Š32â”Š\n-+â”Š  â”Š33â”Šmodule.exports = {\n-+â”Š  â”Š34â”Š  register\n-+â”Š  â”Š35â”Š};ðŸš«â†µ\n-```\n-[}]: #\n-\n-Now the only thing left to do would be registering the plug-in we've just created:\n-\n-[{]: <helper> (diff_step 1.13)\n-#### Step 1.13: Register pages routes\n-\n-##### Changed server.js\n-```diff\n-@@ -2,6 +2,7 @@\n- â”Š2â”Š2â”Šconst Hapi = require(\"hapi\");\n- â”Š3â”Š3â”Šconst Inert = require(\"inert\");\n- â”Š4â”Š4â”Šconst Endpoints = require(\"./routes/endpoints\");\n-+â”Š â”Š5â”Šconst Pages = require(\"./routes/pages\");\n- â”Š5â”Š6â”Šconst IpGrabber = require(\"./helpers/ip_grabber\");\n- â”Š6â”Š7â”Š\n- â”Š7â”Š8â”Šlet localIp = IpGrabber.local();\n-```\n-```diff\n-@@ -40,6 +41,7 @@\n- â”Š40â”Š41â”ŠAsync.series([\n- â”Š41â”Š42â”Š  next => server.register(Inert, next),\n- â”Š42â”Š43â”Š  next => server.register(Endpoints, next),\n-+â”Š  â”Š44â”Š  next => server.register(Pages, next),\n- â”Š43â”Š45â”Š  // Once registrations are finished, start the server\n- â”Š44â”Š46â”Š  next => server.start(next)\n- â”Š45â”Š47â”Š// Print message once started\n-```\n-[}]: #\n-\n-And that's it for the current step! In the next steps we will start storing files and assets in our public directories and implement all the necessary scripts, so our server is not running in vain.\n-[}]: #\n-[{]: <region> (footer)\n-[{]: <helper> (nav_step)\n-| [< Intro](../../README.md) | [Next Step >](step2.md) |\n-|:--------------------------------|--------------------------------:|\n-[}]: #\n-[}]: #\n\\ No newline at end of file\ndiff --git a/manuals/views/step2.md b/manuals/views/step2.md\ndeleted file mode 100644\nindex e60dd6e..0000000\n--- a/manuals/views/step2.md\n+++ /dev/null\n@@ -1,776 +0,0 @@\n-[{]: <region> (header)\n-# Step 2: Creating a game engine basis\n-[}]: #\n-[{]: <region> (body)\n-Like any other JavaScript-based application, we should have an entry view written in HTML. However, in our application, the only visible element is going to be an [HTMLCanvas](https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API). The canvas is exactly what it sounds like - a blank white surface which we can draw things on top of it. As we go further with this tutorial, we will learn more about the canvas and dive into its API and how to use it. Now that you got the general idea, let's create the HTML file:\n-\n-[{]: <helper> (diff_step 2.1)\n-#### Step 2.1: Create basic game view\n-\n-##### Added views/game.html\n-```diff\n-@@ -0,0 +1,10 @@\n-+â”Š  â”Š 1â”Š<!DOCTYPE html>\n-+â”Š  â”Š 2â”Š<html>\n-+â”Š  â”Š 3â”Š  <head>\n-+â”Š  â”Š 4â”Š    <title>radial snake</title>\n-+â”Š  â”Š 5â”Š  </head>\n-+â”Š  â”Š 6â”Š\n-+â”Š  â”Š 7â”Š  <body>\n-+â”Š  â”Š 8â”Š    <canvas id=\"gameCanvas\" tabindex=\"0\"></canvas>\n-+â”Š  â”Š 9â”Š  </body>\n-+â”Š  â”Š10â”Š</html>ðŸš«â†µ\n-```\n-[}]: #\n-\n-In the previous step we've already set the route for this file, so if you'd like to run the game, simply start the server by typing `npm run serve`, and navigate to the address presented on the screen (Should be `localhost:8000` by default).\n-\n-> From now on I'm going to assume the server is running in the background, so I won't repeat the instruction above\n-\n-Just to make sure that the canvas is visible and not blended into the background, we will draw a black border around using a simple style-sheet:\n-\n-[{]: <helper> (diff_step 2.2)\n-#### Step 2.2: Create basic game stylesheet\n-\n-##### Added resources/styles/game.css\n-```diff\n-@@ -0,0 +1,6 @@\n-+â”Š â”Š1â”Š#gameCanvas {\n-+â”Š â”Š2â”Š  display: block;\n-+â”Š â”Š3â”Š  margin: auto;\n-+â”Š â”Š4â”Š  border-style: solid;\n-+â”Š â”Š5â”Š  border-width: 1px;\n-+â”Š â”Š6â”Š}ðŸš«â†µ\n-```\n-\n-##### Changed views/game.html\n-```diff\n-@@ -2,6 +2,9 @@\n- â”Š 2â”Š 2â”Š<html>\n- â”Š 3â”Š 3â”Š  <head>\n- â”Š 4â”Š 4â”Š    <title>radial snake</title>\n-+â”Š  â”Š 5â”Š\n-+â”Š  â”Š 6â”Š    <!-- Styles -->\n-+â”Š  â”Š 7â”Š    <link rel=\"stylesheet\" type=\"text/css\" href=\"/styles/game.css\">\n- â”Š 5â”Š 8â”Š  </head>\n- â”Š 6â”Š 9â”Š\n- â”Š 7â”Š10â”Š  <body>\n-```\n-[}]: #\n-\n-> Note that every asset we create should be declared in the HTML file in order for it to take effect\n-\n-To build this project we're also gonna use two very famous utility libraries called [JQuery](http://jquery.com/) and [Underscore](http://underscorejs.org/) which will make our lives a bit easier. Third-party libraries should be located in a directory called `libs`, according to the routes-map we created in the previous step. To set these libraries up, type the following commands in series:\n-\n-    resources$ mkdir libs\n-    resources$ cd libs\n-    resources/libs$ wget raw.githubusercontent.com/dab0mb/radial-snake/master/resources/libs/underscore.js\n-    resources/libs$ wget raw.githubusercontent.com/dab0mb/radial-snake/master/resources/libs/jquery-2.1.1.js\n-\n-And load them in the game's HTML file's header:\n-\n-[{]: <helper> (diff_step 2.3 views/game.html)\n-#### Step 2.3: Add jquery and underscore libs\n-\n-##### Changed views/game.html\n-```diff\n-@@ -3,6 +3,10 @@\n- â”Š 3â”Š 3â”Š  <head>\n- â”Š 4â”Š 4â”Š    <title>radial snake</title>\n- â”Š 5â”Š 5â”Š\n-+â”Š  â”Š 6â”Š    <!-- Libs -->\n-+â”Š  â”Š 7â”Š    <script type=\"text/javascript\" src=\"/libs/jquery-2.1.1.js\"></script>\n-+â”Š  â”Š 8â”Š    <script type=\"text/javascript\" src=\"/libs/underscore.js\"></script>\n-+â”Š  â”Š 9â”Š\n- â”Š 6â”Š10â”Š    <!-- Styles -->\n- â”Š 7â”Š11â”Š    <link rel=\"stylesheet\" type=\"text/css\" href=\"/styles/game.css\">\n- â”Š 8â”Š12â”Š  </head>\n-```\n-[}]: #\n-\n-Now, we're finally going to build the game engine. At first, it's gonna be very basic simple, but further in this tutorial we're going to extend it and add some pretty neat features. When creating an application, of any kind, you don't want to garbage the global scope, so it can stay clean without any conflicts. Therefore, we're going to create an initial namespace for our game engine called `Engine`, which is going to contain all our game engine's classes and entities:\n-\n-[{]: <helper> (diff_step 2.4)\n-#### Step 2.4: Add engine namespace\n-\n-##### Added resources/scripts/namespaces.js\n-```diff\n-@@ -0,0 +1 @@\n-+â”Š â”Š1â”ŠEngine = {};ðŸš«â†µ\n-```\n-\n-##### Changed views/game.html\n-```diff\n-@@ -7,6 +7,9 @@\n- â”Š 7â”Š 7â”Š    <script type=\"text/javascript\" src=\"/libs/jquery-2.1.1.js\"></script>\n- â”Š 8â”Š 8â”Š    <script type=\"text/javascript\" src=\"/libs/underscore.js\"></script>\n- â”Š 9â”Š 9â”Š\n-+â”Š  â”Š10â”Š    <!-- Scripts -->\n-+â”Š  â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n-+â”Š  â”Š12â”Š\n- â”Š10â”Š13â”Š    <!-- Styles -->\n- â”Š11â”Š14â”Š    <link rel=\"stylesheet\" type=\"text/css\" href=\"/styles/game.css\">\n- â”Š12â”Š15â”Š  </head>\n-```\n-[}]: #\n-\n-The first thing we're going to define in the namespace we've just created would be the game loop. The game loop is the central code of your game, split into different parts. Generally, these are: update and draw.\n-\n-The main purpose of the update phase is to prepare all objects to be drawn, so this is where all the geometry code, coordinate updates, score changes, animation refreshments and other similar operations belong. This is also where the input will be captured and processed.\n-\n-When everything is properly updated and ready, we enter the draw phase where all this information is put on the screen. This function should contain all the code to manage and draw the levels, shapes, score board and so on.\n-\n-![game-loop](https://cloud.githubusercontent.com/assets/7648874/21332964/4b80ef4e-c633-11e6-946a-0c5870d2f9c9.png)\n-\n-> You can find plenty of details and information about what \"game loop\" means simply by typing in on Google.\n-\n-A game loop can wear many forms, but the concept is gonna be the same, plus-minus. This is how our game loop is going to loop like:\n-\n-[{]: <helper> (diff_step 2.5)\n-#### Step 2.5: Create a game basis\n-\n-##### Added resources/scripts/engine/game.js\n-```diff\n-@@ -0,0 +1,99 @@\n-+â”Š  â”Š 1â”ŠEngine.Game = class Game {\n-+â”Š  â”Š 2â”Š  // The frequency of which each frame will be drawn in milliseconds\n-+â”Š  â”Š 3â”Š  get fps() {\n-+â”Š  â”Š 4â”Š    return 1000 / 60;\n-+â”Š  â”Š 5â”Š  }\n-+â”Š  â”Š 6â”Š\n-+â”Š  â”Š 7â”Š  // Game's run speed.\n-+â”Š  â”Š 8â”Š  // A lower value will make it run slower and a higher value will make it run faster\n-+â”Š  â”Š 9â”Š  get speed() {\n-+â”Š  â”Š10â”Š    return 1;\n-+â”Š  â”Š11â”Š  }\n-+â”Š  â”Š12â”Š\n-+â”Š  â”Š13â”Š  constructor(canvas) {\n-+â”Š  â”Š14â”Š    this.canvas = canvas;\n-+â”Š  â”Š15â”Š    this.lastUpdate = this.creation = new Date().getTime();\n-+â”Š  â”Š16â”Š\n-+â”Š  â”Š17â”Š    // Canvas dimensions must be set programmatically otherwise you might encounter some\n-+â”Š  â”Š18â”Š    // unexpected behaviors\n-+â”Š  â”Š19â”Š    canvas.width = 1280;\n-+â”Š  â”Š20â”Š    canvas.height = 720;\n-+â”Š  â”Š21â”Š    // Canvas will be focused once game page is loaded so all events will automatically\n-+â”Š  â”Š22â”Š    // be captured by it\n-+â”Š  â”Š23â”Š    canvas.focus();\n-+â”Š  â”Š24â”Š\n-+â”Š  â”Š25â”Š    // We want to focus on the canvas once we press on it\n-+â”Š  â”Š26â”Š    canvas.addEventListener(\"mousedown\", canvas.focus.bind(canvas), false);\n-+â”Š  â”Š27â”Š\n-+â”Š  â”Š28â”Š    this.assets = {};\n-+â”Š  â”Š29â”Š    this.events = new Map();\n-+â”Š  â”Š30â”Š    this.context = canvas.getContext(\"2d\");\n-+â”Š  â”Š31â”Š    this.bufferedCanvas = document.createElement(\"canvas\");\n-+â”Š  â”Š32â”Š    this.bufferedContext = this.bufferedCanvas.getContext(\"2d\");\n-+â”Š  â”Š33â”Š    this.bufferedCanvas.width = canvas.width;\n-+â”Š  â”Š34â”Š    this.bufferedCanvas.height = canvas.height;\n-+â”Š  â”Š35â”Š  }\n-+â”Š  â”Š36â”Š\n-+â”Š  â”Š37â”Š  draw() {\n-+â”Š  â”Š38â”Š    // Draw a black screen by default\n-+â”Š  â”Š39â”Š    this.context.restore();\n-+â”Š  â”Š40â”Š    this.context.fillStyle = \"black\";\n-+â”Š  â”Š41â”Š    this.context.save();\n-+â”Š  â”Š42â”Š    this.context.beginPath();\n-+â”Š  â”Š43â”Š    this.context.rect(0, 0, this.canvas.width, this.canvas.height);\n-+â”Š  â”Š44â”Š    this.context.fill();\n-+â”Š  â”Š45â”Š  }\n-+â”Š  â”Š46â”Š\n-+â”Š  â”Š47â”Š  update() {\n-+â”Š  â”Š48â”Š    // Calculate the time elapsed\n-+â”Š  â”Š49â”Š    let lastUpdate = this.lastUpdate;\n-+â”Š  â”Š50â”Š    let currUpdate = this.lastUpdate = new Date().getTime();\n-+â”Š  â”Š51â”Š    let span = currUpdate - lastUpdate;\n-+â”Š  â”Š52â”Š    this.updateScreen(span / this.speed);\n-+â”Š  â”Š53â”Š  }\n-+â”Š  â”Š54â”Š\n-+â”Š  â”Š55â”Š  // The main loop of the game\n-+â”Š  â”Š56â”Š  loop() {\n-+â”Š  â”Š57â”Š    // If paused, don't run loop. The canvas will remain as is\n-+â”Š  â”Š58â”Š    if (!this.playing) return;\n-+â”Š  â”Š59â”Š\n-+â”Š  â”Š60â”Š    setTimeout(() => {\n-+â”Š  â”Š61â”Š      this.draw();\n-+â”Š  â”Š62â”Š      this.update();\n-+â”Š  â”Š63â”Š      this.loop();\n-+â”Š  â”Š64â”Š    }, this.fps);\n-+â”Š  â”Š65â”Š  }\n-+â”Š  â”Š66â”Š\n-+â”Š  â”Š67â”Š  play() {\n-+â”Š  â”Š68â”Š    this.playing = true;\n-+â”Š  â”Š69â”Š    this.loop();\n-+â”Š  â”Š70â”Š  }\n-+â”Š  â”Š71â”Š\n-+â”Š  â”Š72â”Š  pause() {\n-+â”Š  â”Š73â”Š    this.playing = false;\n-+â”Š  â”Š74â”Š  }\n-+â”Š  â”Š75â”Š\n-+â”Š  â”Š76â”Š  // Defines global assets\n-+â”Š  â”Š77â”Š  extendAssets(assets) {\n-+â”Š  â”Š78â”Š    _.extend(this.assets, assets);\n-+â”Š  â”Š79â”Š  }\n-+â”Š  â”Š80â”Š\n-+â”Š  â”Š81â”Š  // Disposes global assets\n-+â”Š  â”Š82â”Š  clearAssets() {\n-+â”Š  â”Š83â”Š    this.assets = {};\n-+â”Š  â”Š84â”Š  }\n-+â”Š  â”Š85â”Š\n-+â”Š  â”Š86â”Š  // Adds event listener for game canvas\n-+â”Š  â”Š87â”Š  addEventListener(type, listener, target) {\n-+â”Š  â”Š88â”Š    let boundListener = listener.bind(target);\n-+â”Š  â”Š89â”Š    this.events.set(listener, boundListener);\n-+â”Š  â”Š90â”Š    this.canvas.addEventListener(type, boundListener, false);\n-+â”Š  â”Š91â”Š  }\n-+â”Š  â”Š92â”Š\n-+â”Š  â”Š93â”Š  // Removes event listener from game canvas\n-+â”Š  â”Š94â”Š  removeEventListener(type, listener) {\n-+â”Š  â”Š95â”Š    let boundListener = this.events.get(listener);\n-+â”Š  â”Š96â”Š    this.events.delete(listener);\n-+â”Š  â”Š97â”Š    this.canvas.removeEventListener(type, boundListener, false);\n-+â”Š  â”Š98â”Š  }\n-+â”Š  â”Š99â”Š};ðŸš«â†µ\n-```\n-\n-##### Changed views/game.html\n-```diff\n-@@ -9,6 +9,7 @@\n- â”Š 9â”Š 9â”Š\n- â”Š10â”Š10â”Š    <!-- Scripts -->\n- â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n-+â”Š  â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n- â”Š12â”Š13â”Š\n- â”Š13â”Š14â”Š    <!-- Styles -->\n- â”Š14â”Š15â”Š    <link rel=\"stylesheet\" type=\"text/css\" href=\"/styles/game.css\">\n-```\n-[}]: #\n-\n-The only thing it's doing right now is drawing a black background, but we're soon going to learn how to take advantage of this game-loop to draw stuff of our own. I'd like to point out that there is no need to implement a [double-buffer](https://en.wikipedia.org/wiki/Multiple_buffering) (A method similar to React's [virtual DOM](https://www.npmjs.com/package/react-dom)) when it comes to `HTMLCanvas` elements, since `HTML5` already does that for us. To start running the game, we first need to wait for the DOM content to initialize, and once it's ready we gonna create a new game instance and call the `play` method:\n-\n-[{]: <helper> (diff_step 2.6)\n-#### Step 2.6: Create game entry point\n-\n-##### Added resources/scripts/main.js\n-```diff\n-@@ -0,0 +1,4 @@\n-+â”Š â”Š1â”Šdocument.addEventListener(\"DOMContentLoaded\", function(event) {\n-+â”Š â”Š2â”Š  let game = new Engine.Game(document.getElementById(\"gameCanvas\"), false);\n-+â”Š â”Š3â”Š  game.play();\n-+â”Š â”Š4â”Š});ðŸš«â†µ\n-```\n-\n-##### Changed views/game.html\n-```diff\n-@@ -10,6 +10,7 @@\n- â”Š10â”Š10â”Š    <!-- Scripts -->\n- â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n- â”Š12â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n-+â”Š  â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n- â”Š13â”Š14â”Š\n- â”Š14â”Š15â”Š    <!-- Styles -->\n- â”Š15â”Š16â”Š    <link rel=\"stylesheet\" type=\"text/css\" href=\"/styles/game.css\">\n-```\n-[}]: #\n-\n-This will take control over the canvas and will draw a new picture every 17ms, which is 60fps (Frames per second). As for now you're only going to see a black canvas, but I promise the final result is not going to disappoint you.\n-\n-The next thing we're gonna do would be adding a 'key state' manager, which will store a flag for each key pressed on the keyboard. Once we press the key, the flag's value would be `true`, and once we release it, its value would turn into `false`. This way we have an easy way to track all the key presses without registering a specific event listener for each key press we wanna track:\n-\n-[{]: <helper> (diff_step 2.7)\n-#### Step 2.7: Add key states manager\n-\n-##### Added resources/scripts/engine/key_states.js\n-```diff\n-@@ -0,0 +1,20 @@\n-+â”Š  â”Š 1â”ŠEngine.KeyStates = class KeyStates {\n-+â”Š  â”Š 2â”Š  constructor() {\n-+â”Š  â”Š 3â”Š    // We will have 255 states, each one represents an ascii code matching its index\n-+â”Š  â”Š 4â”Š    this.states = new Array(255);\n-+â”Š  â”Š 5â”Š  }\n-+â”Š  â”Š 6â”Š\n-+â”Š  â”Š 7â”Š  get(k) {\n-+â”Š  â”Š 8â”Š    return this.states[k];\n-+â”Š  â”Š 9â”Š  }\n-+â”Š  â”Š10â”Š\n-+â”Š  â”Š11â”Š  // This should be called once we press a key\n-+â”Š  â”Š12â”Š  add(k) {\n-+â”Š  â”Š13â”Š    this.states[k] = true;\n-+â”Š  â”Š14â”Š  }\n-+â”Š  â”Š15â”Š\n-+â”Š  â”Š16â”Š  // This should be called once we release a key\n-+â”Š  â”Š17â”Š  remove(k) {\n-+â”Š  â”Š18â”Š    this.states[k] = false;\n-+â”Š  â”Š19â”Š  }\n-+â”Š  â”Š20â”Š};ðŸš«â†µ\n-```\n-\n-##### Changed views/game.html\n-```diff\n-@@ -9,6 +9,7 @@\n- â”Š 9â”Š 9â”Š\n- â”Š10â”Š10â”Š    <!-- Scripts -->\n- â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n-+â”Š  â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/key_states.js\"></script>\n- â”Š12â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n- â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n-```\n-[}]: #\n-\n-Now that we have the key state manager, we will initialize a new instance as part of our game's essentials, and we will create a global event listener for key presses; Each time a key is pressed, the key state manager will update itself:\n-\n-[{]: <helper> (diff_step 2.8)\n-#### Step 2.8: Register key presses\n-\n-##### Changed resources/scripts/engine/game.js\n-```diff\n-@@ -14,7 +14,7 @@\n- â”Š14â”Š14â”Š    this.canvas = canvas;\n- â”Š15â”Š15â”Š    this.lastUpdate = this.creation = new Date().getTime();\n- â”Š16â”Š16â”Š\n--â”Š17â”Š  â”Š    // Canvas dimensions must be set programmatically otherwise you might encounter some\n-+â”Š  â”Š17â”Š    // Canvas dimensions must be set programmatically, otherwise you might encounter some\n- â”Š18â”Š18â”Š    // unexpected behaviors\n- â”Š19â”Š19â”Š    canvas.width = 1280;\n- â”Š20â”Š20â”Š    canvas.height = 720;\n-```\n-```diff\n-@@ -24,9 +24,13 @@\n- â”Š24â”Š24â”Š\n- â”Š25â”Š25â”Š    // We want to focus on the canvas once we press on it\n- â”Š26â”Š26â”Š    canvas.addEventListener(\"mousedown\", canvas.focus.bind(canvas), false);\n-+â”Š  â”Š27â”Š    // Key flags will be registered by the \"KeyStates\" instance\n-+â”Š  â”Š28â”Š    canvas.addEventListener(\"keydown\", onKeyDown.bind(this), false);\n-+â”Š  â”Š29â”Š    canvas.addEventListener(\"keyup\", onKeyUp.bind(this), false);\n- â”Š27â”Š30â”Š\n- â”Š28â”Š31â”Š    this.assets = {};\n- â”Š29â”Š32â”Š    this.events = new Map();\n-+â”Š  â”Š33â”Š    this.keyStates = new Engine.KeyStates();\n- â”Š30â”Š34â”Š    this.context = canvas.getContext(\"2d\");\n- â”Š31â”Š35â”Š    this.bufferedCanvas = document.createElement(\"canvas\");\n- â”Š32â”Š36â”Š    this.bufferedContext = this.bufferedCanvas.getContext(\"2d\");\n-```\n-```diff\n-@@ -96,4 +100,19 @@\n- â”Š 96â”Š100â”Š    this.events.delete(listener);\n- â”Š 97â”Š101â”Š    this.canvas.removeEventListener(type, boundListener, false);\n- â”Š 98â”Š102â”Š  }\n--â”Š 99â”Š   â”Š};ðŸš«â†µ\n-+â”Š   â”Š103â”Š};\n-+â”Š   â”Š104â”Š\n-+â”Š   â”Š105â”Šfunction onKeyDown(e) {\n-+â”Š   â”Š106â”Š  // Once we're focused on the canvas, we want nothing else to happen\n-+â”Š   â”Š107â”Š  // besides events the game is listening to. For example, when we press\n-+â”Š   â”Š108â”Š  // the arrow keys, this will prevent the screen from scrolling\n-+â”Š   â”Š109â”Š  e.preventDefault();\n-+â”Š   â”Š110â”Š  // Register key press\n-+â”Š   â”Š111â”Š  this.keyStates.add(e.keyCode);\n-+â”Š   â”Š112â”Š}\n-+â”Š   â”Š113â”Š\n-+â”Š   â”Š114â”Šfunction onKeyUp(e) {\n-+â”Š   â”Š115â”Š  e.preventDefault();\n-+â”Š   â”Š116â”Š  // Register key release\n-+â”Š   â”Š117â”Š  this.keyStates.remove(e.keyCode);\n-+â”Š   â”Š118â”Š}\n-```\n-[}]: #\n-\n-A 2D game's view might get complex as we go through with its development and add more logic and entities into it. Having only one `draw` method and only one `update` method is not enough, and if you think of it, it might easily get buffed up into ridiculous dimensions, which is not the way to go. I'd like to introduce you into a new methodology which involves `screens` and `layers`:\n-\n-- **screen** - Will literally be used whenever we want to show a new screen in our game e.g. 'splash' screen and 'main menu' screen. A screen consists of multiple layers, and will be used as their communicator; All the relevant assets and logic will be initialized inside it.\n-- **layer** - similar to Photoshop's layer system, any time we want to add something to the view we add new layers on top or beneath of each other.\n-\n-![screen-layer](https://cloud.githubusercontent.com/assets/7648874/21487708/9b366efe-cbb7-11e6-8669-3212e440871a.png)\n-\n-As I said earlier, the purpose of the screens and the layers is just to split the task of updating and drawing and updating, so we can have logical segments; So the `layer` class should mainly consist of a `draw` and an `update` method:\n-\n-[{]: <helper> (diff_step 2.9)\n-#### Step 2.9: Add screen layer\n-\n-##### Added resources/scripts/engine/layer.js\n-```diff\n-@@ -0,0 +1,43 @@\n-+â”Š  â”Š 1â”ŠEngine.Layer = class Layer {\n-+â”Š  â”Š 2â”Š  // The dimensions of the layer are correlated to dimensions of the canvas\n-+â”Š  â”Š 3â”Š  get width() {\n-+â”Š  â”Š 4â”Š    return this.canvas.width;\n-+â”Š  â”Š 5â”Š  }\n-+â”Š  â”Š 6â”Š\n-+â”Š  â”Š 7â”Š  get height() {\n-+â”Š  â”Š 8â”Š    return this.canvas.height;\n-+â”Š  â”Š 9â”Š  }\n-+â”Š  â”Š10â”Š\n-+â”Š  â”Š11â”Š  // A hash of \"eventName\" : \"handlerName\" which should be overrided by user\n-+â”Š  â”Š12â”Š  get events() {\n-+â”Š  â”Š13â”Š    return {};\n-+â”Š  â”Š14â”Š  }\n-+â”Š  â”Š15â”Š\n-+â”Š  â”Š16â”Š  constructor(screen) {\n-+â”Š  â”Š17â”Š    this.age = 0;\n-+â”Š  â”Š18â”Š    this.creation = new Date().getTime();\n-+â”Š  â”Š19â”Š    this.screen = screen;\n-+â”Š  â”Š20â”Š    this.game = screen.game;\n-+â”Š  â”Š21â”Š    this.assets = screen.assets;\n-+â”Š  â”Š22â”Š    this.keyStates = screen.keyStates;\n-+â”Š  â”Š23â”Š    this.canvas = screen.game.canvas;\n-+â”Š  â”Š24â”Š  }\n-+â”Š  â”Š25â”Š\n-+â”Š  â”Š26â”Š  update(span) {\n-+â”Š  â”Š27â”Š  }\n-+â”Š  â”Š28â”Š\n-+â”Š  â”Š29â”Š  draw(context) {\n-+â”Š  â”Š30â”Š  }\n-+â”Š  â”Š31â”Š\n-+â”Š  â”Š32â”Š  initEventListeners() {\n-+â”Š  â”Š33â”Š    _.each(this.events, (listener, event) => {\n-+â”Š  â”Š34â”Š      this.game.addEventListener(event, this[listener], this);\n-+â”Š  â”Š35â”Š    });\n-+â”Š  â”Š36â”Š  }\n-+â”Š  â”Š37â”Š\n-+â”Š  â”Š38â”Š  disposeEventListeners() {\n-+â”Š  â”Š39â”Š    _.each(this.events, (listener, event) => {\n-+â”Š  â”Š40â”Š      this.game.removeEventListener(event, this[listener]);\n-+â”Š  â”Š41â”Š    });\n-+â”Š  â”Š42â”Š  }\n-+â”Š  â”Š43â”Š};ðŸš«â†µ\n-```\n-\n-##### Changed views/game.html\n-```diff\n-@@ -10,6 +10,7 @@\n- â”Š10â”Š10â”Š    <!-- Scripts -->\n- â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n- â”Š12â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/key_states.js\"></script>\n-+â”Š  â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/layer.js\"></script>\n- â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n- â”Š14â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n-```\n-[}]: #\n-\n-Same thing for the screen, it only has a `draw` and `update` methods, only it has a stack of layers, which can either be added or removed:\n-\n-[{]: <helper> (diff_step 2.10)\n-#### Step 2.10: Add game screen\n-\n-##### Added resources/scripts/engine/screen.js\n-```diff\n-@@ -0,0 +1,85 @@\n-+â”Š  â”Š 1â”ŠEngine.Screen = class Screen {\n-+â”Š  â”Š 2â”Š  // The dimensions of the screen are correlated to dimensions of the canvas\n-+â”Š  â”Š 3â”Š  get width() {\n-+â”Š  â”Š 4â”Š    return this.canvas.width;\n-+â”Š  â”Š 5â”Š  }\n-+â”Š  â”Š 6â”Š\n-+â”Š  â”Š 7â”Š  get height() {\n-+â”Š  â”Š 8â”Š    return this.canvas.height;\n-+â”Š  â”Š 9â”Š  }\n-+â”Š  â”Š10â”Š\n-+â”Š  â”Š11â”Š  // A hash of \"eventName\" : \"handlerName\" which should be overrided by user\n-+â”Š  â”Š12â”Š  get events() {\n-+â”Š  â”Š13â”Š    return {};\n-+â”Š  â”Š14â”Š  }\n-+â”Š  â”Š15â”Š\n-+â”Š  â”Š16â”Š  constructor(game) {\n-+â”Š  â”Š17â”Š    this.age = 0;\n-+â”Š  â”Š18â”Š    this.creation = new Date().getTime();\n-+â”Š  â”Š19â”Š    this.game = game;\n-+â”Š  â”Š20â”Š    this.canvas = game.canvas;\n-+â”Š  â”Š21â”Š    this.keyStates = game.keyStates;\n-+â”Š  â”Š22â”Š    this.assets = _.clone(game.assets);\n-+â”Š  â”Š23â”Š    this.layers = [];\n-+â”Š  â”Š24â”Š  }\n-+â”Š  â”Š25â”Š\n-+â”Š  â”Š26â”Š  // A custom initialization function should be implemented by child-class\n-+â”Š  â”Š27â”Š  initialize() {\n-+â”Š  â”Š28â”Š    return this;\n-+â”Š  â”Š29â”Š  }\n-+â”Š  â”Š30â”Š\n-+â”Š  â”Š31â”Š  // Updates each layer\n-+â”Š  â”Š32â”Š  update(span) {\n-+â”Š  â”Š33â”Š    this.layers.forEach(layer => {\n-+â”Š  â”Š34â”Š      layer.age += span;\n-+â”Š  â”Š35â”Š      layer.update(span);\n-+â”Š  â”Š36â”Š    });\n-+â”Š  â”Š37â”Š  }\n-+â”Š  â”Š38â”Š\n-+â”Š  â”Š39â”Š  // Draws each layer\n-+â”Š  â”Š40â”Š  draw(context) {\n-+â”Š  â”Š41â”Š    this.layers.forEach(layer => {\n-+â”Š  â”Š42â”Š      layer.draw(context);\n-+â”Š  â”Š43â”Š    });\n-+â”Š  â”Š44â”Š  }\n-+â”Š  â”Š45â”Š\n-+â”Š  â”Š46â”Š  // Push a new layer to the top of the layers stack\n-+â”Š  â”Š47â”Š  appendLayer(Layer, ...layerArgs) {\n-+â”Š  â”Š48â”Š    let layer = new Layer(this, ...layerArgs);\n-+â”Š  â”Š49â”Š    this.layers.push(layer);\n-+â”Š  â”Š50â”Š    layer.initEventListeners();\n-+â”Š  â”Š51â”Š  }\n-+â”Š  â”Š52â”Š\n-+â”Š  â”Š53â”Š  // Push a new layer to the bottom of the layers stack\n-+â”Š  â”Š54â”Š  prependLayer(Layer, ...layerArgs) {\n-+â”Š  â”Š55â”Š    let layer = new Layer(this, ...layerArgs);\n-+â”Š  â”Š56â”Š    this.layers.unshift(layer);\n-+â”Š  â”Š57â”Š    layer.initEventListeners();\n-+â”Š  â”Š58â”Š  }\n-+â”Š  â”Š59â”Š\n-+â”Š  â”Š60â”Š  // Removes the given layer from the layers stack\n-+â”Š  â”Š61â”Š  removeLayer(layer) {\n-+â”Š  â”Š62â”Š    this.layers = _.without(this.layers, layer);\n-+â”Š  â”Š63â”Š    layer.disposeEventListeners();\n-+â”Š  â”Š64â”Š  }\n-+â”Š  â”Š65â”Š\n-+â”Š  â”Š66â”Š  initEventListeners() {\n-+â”Š  â”Š67â”Š    _.each(this.events, (listener, event) => {\n-+â”Š  â”Š68â”Š      this.game.addEventListener(event, this[listener], this);\n-+â”Š  â”Š69â”Š    });\n-+â”Š  â”Š70â”Š\n-+â”Š  â”Š71â”Š    this.layers.forEach(layer => {\n-+â”Š  â”Š72â”Š      layer.initEventListeners();\n-+â”Š  â”Š73â”Š    });\n-+â”Š  â”Š74â”Š  }\n-+â”Š  â”Š75â”Š\n-+â”Š  â”Š76â”Š  disposeEventListeners() {\n-+â”Š  â”Š77â”Š    _.each(this.events, (listener, event) => {\n-+â”Š  â”Š78â”Š      this.game.removeEventListener(event, this[listener], this);\n-+â”Š  â”Š79â”Š    });\n-+â”Š  â”Š80â”Š\n-+â”Š  â”Š81â”Š    this.layers.forEach(layer => {\n-+â”Š  â”Š82â”Š      layer.disposeEventListeners();\n-+â”Š  â”Š83â”Š    });\n-+â”Š  â”Š84â”Š  }\n-+â”Š  â”Š85â”Š};ðŸš«â†µ\n-```\n-\n-##### Changed views/game.html\n-```diff\n-@@ -11,6 +11,7 @@\n- â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n- â”Š12â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/key_states.js\"></script>\n- â”Š13â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/layer.js\"></script>\n-+â”Š  â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/screen.js\"></script>\n- â”Š14â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n- â”Š15â”Š16â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n-```\n-[}]: #\n-\n-Now that we have the `screen` class available for us, let's apply it to the main game loop:\n-\n-[{]: <helper> (diff_step 2.11)\n-#### Step 2.11: Draw and update screen in game loop\n-\n-##### Changed resources/scripts/engine/game.js\n-```diff\n-@@ -30,6 +30,7 @@\n- â”Š30â”Š30â”Š\n- â”Š31â”Š31â”Š    this.assets = {};\n- â”Š32â”Š32â”Š    this.events = new Map();\n-+â”Š  â”Š33â”Š    this.screen = new Engine.Screen(this);\n- â”Š33â”Š34â”Š    this.keyStates = new Engine.KeyStates();\n- â”Š34â”Š35â”Š    this.context = canvas.getContext(\"2d\");\n- â”Š35â”Š36â”Š    this.bufferedCanvas = document.createElement(\"canvas\");\n-```\n-```diff\n-@@ -46,6 +47,13 @@\n- â”Š46â”Š47â”Š    this.context.beginPath();\n- â”Š47â”Š48â”Š    this.context.rect(0, 0, this.canvas.width, this.canvas.height);\n- â”Š48â”Š49â”Š    this.context.fill();\n-+â”Š  â”Š50â”Š    this.drawScreen(this.context);\n-+â”Š  â”Š51â”Š  }\n-+â”Š  â”Š52â”Š\n-+â”Š  â”Š53â”Š  drawScreen(context) {\n-+â”Š  â”Š54â”Š    // If screen's assets are not yet loaded, don't draw it\n-+â”Š  â”Š55â”Š    if (this.screen.loading) return;\n-+â”Š  â”Š56â”Š    if (this.screen.draw) this.screen.draw(context);\n- â”Š49â”Š57â”Š  }\n- â”Š50â”Š58â”Š\n- â”Š51â”Š59â”Š  update() {\n-```\n-```diff\n-@@ -56,6 +64,13 @@\n- â”Š56â”Š64â”Š    this.updateScreen(span / this.speed);\n- â”Š57â”Š65â”Š  }\n- â”Š58â”Š66â”Š\n-+â”Š  â”Š67â”Š  updateScreen(span) {\n-+â”Š  â”Š68â”Š    this.screen.age += span;\n-+â”Š  â”Š69â”Š    // If screen's assets are not yet loaded, don't update it\n-+â”Š  â”Š70â”Š    if (this.screen.loading) return;\n-+â”Š  â”Š71â”Š    if (this.screen.update) this.screen.update(span);\n-+â”Š  â”Š72â”Š  }\n-+â”Š  â”Š73â”Š\n- â”Š59â”Š74â”Š  // The main loop of the game\n- â”Š60â”Š75â”Š  loop() {\n- â”Š61â”Š76â”Š    // If paused, don't run loop. The canvas will remain as is\n-```\n-[}]: #\n-\n-This step looks kind of useless for now, unless we will have the ability to change screens as we please. Any time a screen is changed, it should be loaded with its necessary assets e.g textures, sounds, fonts, etc. The assets loading is an asynchronous operation whose logic might get a bit messy if not managed properly. To make it easier, we're going to define an assets loader, which will help us load assets asynchronously:\n-\n-[{]: <helper> (diff_step 2.12)\n-#### Step 2.12: Add assets loader\n-\n-##### Added resources/scripts/engine/assets_loader.js\n-```diff\n-@@ -0,0 +1,13 @@\n-+â”Š  â”Š 1â”ŠEngine.AssetsLoader = class AssetsLoader {\n-+â”Š  â”Š 2â”Š  constructor(next) {\n-+â”Š  â”Š 3â”Š    this.next = next;\n-+â”Š  â”Š 4â”Š  }\n-+â”Š  â”Š 5â”Š\n-+â”Š  â”Š 6â”Š  // Load texture\n-+â”Š  â”Š 7â”Š  texture(path) {\n-+â”Š  â”Š 8â”Š    let image = new Image();\n-+â”Š  â”Š 9â”Š    image.onload = this.next();\n-+â”Š  â”Š10â”Š    image.src = `${path}.png`;\n-+â”Š  â”Š11â”Š    return image;\n-+â”Š  â”Š12â”Š  }\n-+â”Š  â”Š13â”Š};ðŸš«â†µ\n-```\n-\n-##### Changed views/game.html\n-```diff\n-@@ -12,6 +12,7 @@\n- â”Š12â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/key_states.js\"></script>\n- â”Š13â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/layer.js\"></script>\n- â”Š14â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/screen.js\"></script>\n-+â”Š  â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/assets_loader.js\"></script>\n- â”Š15â”Š16â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n- â”Š16â”Š17â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n-```\n-[}]: #\n-\n-> As for now the `assets loader` only has the ability to load textures, but we will extend it as we go further in this tutorial, no need to overdo it.\n-\n-Now that we have the `assets loader` we can add the ability to change a screen. Whenever we change a screen, the old screen's assets should be unloaded, and the new screen's assets should be loaded using the `assets loader`:\n-\n-[{]: <helper> (diff_step 2.13)\n-#### Step 2.13: Add the ability to change and load screen\n-\n-##### Changed resources/scripts/engine/game.js\n-```diff\n-@@ -92,6 +92,61 @@\n- â”Š 92â”Š 92â”Š    this.playing = false;\n- â”Š 93â”Š 93â”Š  }\n- â”Š 94â”Š 94â”Š\n-+â”Š   â”Š 95â”Š  changeScreen(Screen, ...screenArgs) {\n-+â”Š   â”Š 96â”Š    // If there is a screen defined, dispose it first\n-+â”Š   â”Š 97â”Š    if (this.screen) {\n-+â”Š   â”Š 98â”Š      this.unloadScreen();\n-+â”Š   â”Š 99â”Š      this.screen.disposeEventListeners();\n-+â”Š   â”Š100â”Š    }\n-+â”Š   â”Š101â”Š\n-+â”Š   â”Š102â”Š    this.screen = new Screen(this, ...screenArgs);\n-+â”Š   â”Š103â”Š\n-+â”Š   â”Š104â”Š    // Load screen assets\n-+â”Š   â”Š105â”Š    this.loadScreen(() => {\n-+â”Š   â”Š106â”Š      // Once assets are loaded, initialize event listeners\n-+â”Š   â”Š107â”Š      this.screen.initEventListeners();\n-+â”Š   â”Š108â”Š      // The \"initialize\" method is exactly the same as the constructor, only it runs\n-+â”Š   â”Š109â”Š      // once assets are available and event listeners are registered\n-+â”Š   â”Š110â”Š      this.screen.initialize(this, ...screenArgs);\n-+â”Š   â”Š111â”Š    });\n-+â”Š   â”Š112â”Š  }\n-+â”Š   â”Š113â”Š\n-+â”Š   â”Š114â”Š  // Loads screen assets and invokes callback once loading is finished\n-+â”Š   â”Š115â”Š  loadScreen(callback = _.noop) {\n-+â”Š   â”Š116â”Š    if (!this.screen.load) return callback();\n-+â”Š   â”Š117â”Š\n-+â”Š   â”Š118â”Š    this.screen.loading = true;\n-+â”Š   â”Š119â”Š    // The number of assets to load\n-+â”Š   â”Š120â”Š    let loadsize = 0;\n-+â”Š   â”Š121â”Š    let onload;\n-+â”Š   â”Š122â”Š\n-+â”Š   â”Š123â”Š    // This object can load assets\n-+â”Š   â”Š124â”Š    let assetsLoader = new Engine.AssetsLoader(() => {\n-+â”Š   â”Š125â”Š      loadsize++;\n-+â”Š   â”Š126â”Š      return () => onload();\n-+â”Š   â”Š127â”Š    });\n-+â”Š   â”Š128â”Š\n-+â”Š   â”Š129â”Š    // The \"load\" method returns the assets loaded by the screen\n-+â”Š   â”Š130â”Š    let screenAssets = this.screen.load(assetsLoader);\n-+â”Š   â”Š131â”Š\n-+â”Š   â”Š132â”Š    // We use the \"after\" method because we want the following callback to be invoked\n-+â”Š   â”Š133â”Š    // only once all assets are loaded\n-+â”Š   â”Š134â”Š    onload = _.after(loadsize, () => {\n-+â”Š   â”Š135â”Š      delete this.screen.loading;\n-+â”Š   â”Š136â”Š      callback();\n-+â”Š   â”Š137â”Š    });\n-+â”Š   â”Š138â”Š\n-+â”Š   â”Š139â”Š    // The returned assets will be available on screen's assets object\n-+â”Š   â”Š140â”Š    _.extend(this.screen.assets, screenAssets);\n-+â”Š   â”Š141â”Š  }\n-+â”Š   â”Š142â”Š\n-+â”Š   â”Š143â”Š  // Disposes screen assets\n-+â”Š   â”Š144â”Š  unloadScreen() {\n-+â”Š   â”Š145â”Š    if (!this.screen.unload) return;\n-+â”Š   â”Š146â”Š    let assetsNames = this.screen.unload();\n-+â”Š   â”Š147â”Š    _.omit(this.assets, assetsNames);\n-+â”Š   â”Š148â”Š  }\n-+â”Š   â”Š149â”Š\n- â”Š 95â”Š150â”Š  // Defines global assets\n- â”Š 96â”Š151â”Š  extendAssets(assets) {\n- â”Š 97â”Š152â”Š    _.extend(this.assets, assets);\n-```\n-[}]: #\n-\n-Let's add a test screen just so we can get the hang of it. The test screen will only print a message to the canvas:\n-\n-[{]: <helper> (diff_step 2.14)\n-#### Step 2.14: Add test screen\n-\n-##### Added resources/scripts/test_screen.js\n-```diff\n-@@ -0,0 +1,10 @@\n-+â”Š  â”Š 1â”Šclass TestScreen extends Engine.Screen {\n-+â”Š  â”Š 2â”Š  draw(context) {\n-+â”Š  â”Š 3â”Š    // A 20px sized \"Georgia\" font (Available natively)\n-+â”Š  â”Š 4â”Š    context.font = \"20px Georgia\";\n-+â”Š  â”Š 5â”Š    // The text should be colored white\n-+â”Š  â”Š 6â”Š    context.fillStyle = \"white\";\n-+â”Š  â”Š 7â”Š    // Draw the following message 50px from the left and 50px from the top\n-+â”Š  â”Š 8â”Š    context.fillText(\"This is a Test Screen\", 50, 50);\n-+â”Š  â”Š 9â”Š  }\n-+â”Š  â”Š10â”Š};ðŸš«â†µ\n-```\n-\n-##### Changed views/game.html\n-```diff\n-@@ -14,6 +14,7 @@\n- â”Š14â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/screen.js\"></script>\n- â”Š15â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/assets_loader.js\"></script>\n- â”Š16â”Š16â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n-+â”Š  â”Š17â”Š    <script type=\"text/javascript\" src=\"/scripts/test_screen.js\"></script>\n- â”Š17â”Š18â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n- â”Š18â”Š19â”Š\n- â”Š19â”Š20â”Š    <!-- Styles -->\n-```\n-[}]: #\n-\n-Now we will use the test screen by changing to it as we create an instance of the game:\n-\n-[{]: <helper> (diff_step 2.15)\n-#### Step 2.15: Set test screen as the initial screen\n-\n-##### Changed resources/scripts/main.js\n-```diff\n-@@ -1,4 +1,5 @@\n- â”Š1â”Š1â”Šdocument.addEventListener(\"DOMContentLoaded\", function(event) {\n- â”Š2â”Š2â”Š  let game = new Engine.Game(document.getElementById(\"gameCanvas\"), false);\n-+â”Š â”Š3â”Š  game.changeScreen(TestScreen);\n- â”Š3â”Š4â”Š  game.play();\n- â”Š4â”Š5â”Š});ðŸš«â†µ\n-```\n-[}]: #\n-\n-Once you will load the application you should see a black canvas with a white text saying:\n-\n-    This is a test screen\n-\n-It means our screen system works and you may proceed to the next step, where we're gonna create our first screen :-)\n-[}]: #\n-[{]: <region> (footer)\n-[{]: <helper> (nav_step)\n-| [< Previous Step](step1.md) | [Next Step >](step3.md) |\n-|:--------------------------------|--------------------------------:|\n-[}]: #\n-[}]: #\n\\ No newline at end of file\ndiff --git a/manuals/views/step3.md b/manuals/views/step3.md\ndeleted file mode 100644\nindex 2ad11a0..0000000\n--- a/manuals/views/step3.md\n+++ /dev/null\n@@ -1,465 +0,0 @@\n-[{]: <region> (header)\n-# Step 3: Creating a splash screen using a keyframe animation engine\n-[}]: #\n-[{]: <region> (body)\n-![snake-demo-splash-small](https://cloud.githubusercontent.com/assets/7648874/21074086/a19fa9ce-bed6-11e6-9060-2ce94c215712.gif)\n-\n-In this step we will be creating the `splash` screen - the initial screen that should be shown once we launch the game. Our splash is consisted of a random logo animation as presented in the `gif` file above. The \"splash\" effect can be achieved using 2 concepts:\n-\n-- A sprite class - Which will present the logo texture in different dimensions, angles and rotations.\n-- A key-frame animation - Which will draw an animation automatically along the time axis using key-frames - each is a sprite representation of the texture in a specific time point.\n-\n-So first thing first, we will start by implementing the sprite class:\n-\n-[{]: <helper> (diff_step 3.1)\n-#### Step 3.1: Create 'Sprite' class\n-\n-##### Added resources/scripts/engine/sprite.js\n-```diff\n-@@ -0,0 +1,58 @@\n-+â”Š  â”Š 1â”ŠEngine.Sprite = class Sprite {\n-+â”Š  â”Š 2â”Š  // An easy representation of a sprite on a canvas, with a set of convenient tools\n-+â”Š  â”Š 3â”Š  // for alignment and coloring\n-+â”Š  â”Š 4â”Š  constructor(texture) {\n-+â”Š  â”Š 5â”Š    this.texture = texture;\n-+â”Š  â”Š 6â”Š    this.x = 0;\n-+â”Š  â”Š 7â”Š    this.y = 0;\n-+â”Š  â”Š 8â”Š    this.width = texture.width;\n-+â”Š  â”Š 9â”Š    this.height = texture.height;\n-+â”Š  â”Š10â”Š    this.pivot = { x: 0, y: 0 };\n-+â”Š  â”Š11â”Š    this.opacity = 1;\n-+â”Š  â”Š12â”Š  }\n-+â”Š  â”Š13â”Š\n-+â”Š  â”Š14â”Š  draw(context, offsetX = 0, offsetY = 0) {\n-+â”Š  â”Š15â”Š    context.save();\n-+â”Š  â”Š16â”Š    context.globalAlpha = this.opacity;\n-+â”Š  â”Š17â”Š\n-+â”Š  â”Š18â”Š    // The following switch-case can also be seen as a list of all possible\n-+â”Š  â”Š19â”Š    // alignment modes\n-+â”Š  â”Š20â”Š    switch (this.align) {\n-+â”Š  â”Š21â”Š      case \"top-left\": case \"left-top\": this.pivot = { x: 0, y: 0 }; break;\n-+â”Š  â”Š22â”Š      case \"top-right\": case \"right-top\": this.pivot = { x: this.width, y: 0 }; break;\n-+â”Š  â”Š23â”Š      case \"bottom-left\": case \"left-bottom\": this.pivot = { x: 0, y: this.height }; break;\n-+â”Š  â”Š24â”Š      case \"bottom-right\": case \"right-bottom\": this.pivot = { x: this.width, y: this.height }; break;\n-+â”Š  â”Š25â”Š      case \"middle\": case \"center\": this.pivot = { x: this.width / 2, y: this.height / 2 }; break;\n-+â”Š  â”Š26â”Š      case \"left\": this.pivot = { x: 0, y: this.height / 2 }; break;\n-+â”Š  â”Š27â”Š      case \"top\": this.pivot = { x: this.width / 2, y: 0 }; break;\n-+â”Š  â”Š28â”Š      case \"right\": this.pivot = { x: this.width, y: this.height / 2 }; break;\n-+â”Š  â”Š29â”Š      case \"bottom\": this.pivot = { x: this.width / 2, y: this.height }; break;\n-+â”Š  â”Š30â”Š    }\n-+â”Š  â”Š31â”Š\n-+â”Š  â”Š32â”Š    context.drawImage(\n-+â”Š  â”Š33â”Š      this.texture,\n-+â”Š  â”Š34â”Š      (this.x - this.pivot.x) + offsetX,\n-+â”Š  â”Š35â”Š      (this.y - this.pivot.y) + offsetY,\n-+â”Š  â”Š36â”Š      this.width,\n-+â”Š  â”Š37â”Š      this.height\n-+â”Š  â”Š38â”Š    );\n-+â”Š  â”Š39â”Š\n-+â”Š  â”Š40â”Š    context.restore();\n-+â”Š  â”Š41â”Š  }\n-+â”Š  â”Š42â”Š\n-+â”Š  â”Š43â”Š  // A sprite property (key) can also be resized based on a given percentage.\n-+â”Š  â”Š44â”Š  // The 'relative' argument represents the whole of which the percents are gonna be\n-+â”Š  â”Š45â”Š  // calculated from, and the 'adapters' argument is an array of property names which\n-+â”Š  â”Š46â”Š  // gonna adapt themselves based on the changes made in the given key.\n-+â”Š  â”Š47â”Š  // Usually 'width' goes along with ['height'] adapters, if we\n-+â”Š  â”Š48â”Š  // want to keep their original ratio\n-+â”Š  â”Š49â”Š  setPercentage(key, relative, percents, ...adapters) {\n-+â”Š  â”Š50â”Š    let oldVal = this[key];\n-+â”Š  â”Š51â”Š    let newVal = this[key] = (percents * relative) / 100;\n-+â”Š  â”Š52â”Š    let ratio = newVal / oldVal;\n-+â”Š  â”Š53â”Š\n-+â”Š  â”Š54â”Š    adapters.forEach(adapter => {\n-+â”Š  â”Š55â”Š      this[adapter] *= ratio;\n-+â”Š  â”Š56â”Š    });\n-+â”Š  â”Š57â”Š  }\n-+â”Š  â”Š58â”Š};ðŸš«â†µ\n-```\n-\n-##### Changed views/game.html\n-```diff\n-@@ -9,6 +9,7 @@\n- â”Š 9â”Š 9â”Š\n- â”Š10â”Š10â”Š    <!-- Scripts -->\n- â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n-+â”Š  â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/sprite.js\"></script>\n- â”Š12â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/key_states.js\"></script>\n- â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/layer.js\"></script>\n- â”Š14â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/screen.js\"></script>\n-```\n-[}]: #\n-\n-And we will download the logo which will be presented in the splash screen using the sprite class:\n-\n-    resources$ mkdir assets\n-    resources$ cd assets\n-    resources/assets$ mkdir textures\n-    resources/assets$ cd textures\n-    resources/assets/textures$ wget raw.githubusercontent.com/dab0mb/radial-snake/master/resources/assets/textures/splash.png\n-\n-> Any logo can that you desired can be used instead! But to ease things up I already provided you with one as a sample\n-\n-Now we will create the initial splash screen, where we only gonna show a sprite of the logo in the middle of the screen, with no animation applied yet. We will first define a dedicated `Screens` module under the `Game` namespace:\n-\n-[{]: <helper> (diff_step 3.3)\n-#### Step 3.3: Create a 'Game' namespace with a 'Screens' module\n-\n-##### Changed resources/scripts/namespaces.js\n-```diff\n-@@ -1 +1,5 @@\n-+â”Š â”Š1â”ŠGame = {\n-+â”Š â”Š2â”Š  Screens: {}\n-+â”Š â”Š3â”Š};\n-+â”Š â”Š4â”Š\n- â”Š1â”Š5â”ŠEngine = {};ðŸš«â†µ\n-```\n-[}]: #\n-\n-And we can go ahead and implement the screen itself:\n-\n-[{]: <helper> (diff_step 3.4)\n-#### Step 3.4: Create initial splash screen\n-\n-##### Added resources/scripts/game/screens/splash/index.js\n-```diff\n-@@ -0,0 +1,19 @@\n-+â”Š  â”Š 1â”ŠGame.Screens.Splash = class Splash extends Engine.Screen {\n-+â”Š  â”Š 2â”Š  initialize() {\n-+â”Š  â”Š 3â”Š    // Create splash sprite and set its properties\n-+â”Š  â”Š 4â”Š    this.splashSprite = new Engine.Sprite(this.assets.splashTexture);\n-+â”Š  â”Š 5â”Š    this.splashSprite.align = \"center\";\n-+â”Š  â”Š 6â”Š    this.splashSprite.x = this.width / 2;\n-+â”Š  â”Š 7â”Š  }\n-+â”Š  â”Š 8â”Š\n-+â”Š  â”Š 9â”Š  load(assetsLoader) {\n-+â”Š  â”Š10â”Š    // These are local assets which will be disposed along with the screen\n-+â”Š  â”Š11â”Š    return {\n-+â”Š  â”Š12â”Š      splashTexture: assetsLoader.texture(\"/textures/splash\")\n-+â”Š  â”Š13â”Š    };\n-+â”Š  â”Š14â”Š  }\n-+â”Š  â”Š15â”Š\n-+â”Š  â”Š16â”Š  draw(context) {\n-+â”Š  â”Š17â”Š    this.splashSprite.draw(context);\n-+â”Š  â”Š18â”Š  }\n-+â”Š  â”Š19â”Š};ðŸš«â†µ\n-```\n-\n-##### Changed views/game.html\n-```diff\n-@@ -16,6 +16,7 @@\n- â”Š16â”Š16â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/assets_loader.js\"></script>\n- â”Š17â”Š17â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n- â”Š18â”Š18â”Š    <script type=\"text/javascript\" src=\"/scripts/test_screen.js\"></script>\n-+â”Š  â”Š19â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/splash/index.js\"></script>\n- â”Š19â”Š20â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n- â”Š20â”Š21â”Š\n- â”Š21â”Š22â”Š    <!-- Styles -->\n-```\n-[}]: #\n-\n-Now we can set the splash screen as the initial screen in the entry script file:\n-\n-[{]: <helper> (diff_step 3.5)\n-#### Step 3.5: Set splash screen as the initial game screen\n-\n-##### Changed resources/scripts/main.js\n-```diff\n-@@ -1,5 +1,5 @@\n- â”Š1â”Š1â”Šdocument.addEventListener(\"DOMContentLoaded\", function(event) {\n- â”Š2â”Š2â”Š  let game = new Engine.Game(document.getElementById(\"gameCanvas\"), false);\n--â”Š3â”Š â”Š  game.changeScreen(TestScreen);\n-+â”Š â”Š3â”Š  game.changeScreen(Game.Screens.Splash);\n- â”Š4â”Š4â”Š  game.play();\n- â”Š5â”Š5â”Š});ðŸš«â†µ\n-```\n-[}]: #\n-\n-And we will get rid of the unnecessary test screen since we make no use of it any longer:\n-\n-    $ rm resources/scripts/test_screen.js\n-\n-We will now proceed into the next stage where we will be implementing the key-frame animation engine as said at the beginning of the step. We first need to define an `Animations` module, since we can have multiple types of animation strategy like [sprite-atlas animation](http://www.joshmorony.com/how-to-create-animations-in-phaser-with-a-texture-atlas/), not necessarily a key-frame animation:\n-\n-[{]: <helper> (diff_step 3.7)\n-#### Step 3.7: Add 'Animations' module to 'Engine' namespace\n-\n-##### Changed resources/scripts/namespaces.js\n-```diff\n-@@ -2,4 +2,6 @@\n- â”Š2â”Š2â”Š  Screens: {}\n- â”Š3â”Š3â”Š};\n- â”Š4â”Š4â”Š\n--â”Š5â”Š â”ŠEngine = {};ðŸš«â†µ\n-+â”Š â”Š5â”ŠEngine = {\n-+â”Š â”Š6â”Š  Animations: {}\n-+â”Š â”Š7â”Š};ðŸš«â†µ\n-```\n-[}]: #\n-\n-Inside the newly created module we will create the key-frame animation engine. The key-frame animation consists of the following methods:\n-\n-- update - Updates the animation.\n-- draw - Draws the current animation frame on the provided canvas context.\n-- play - Enables update operations.\n-- pause - Disables update operations.\n-\n-[{]: <helper> (diff_step 3.8)\n-#### Step 3.8: Create a key-frame animation engine\n-\n-##### Added resources/scripts/engine/animations/keyframe.js\n-```diff\n-@@ -0,0 +1,142 @@\n-+â”Š   â”Š  1â”ŠEngine.Animations.Keyframe = class Keyframe {\n-+â”Š   â”Š  2â”Š  constructor(sprite, keyframes) {\n-+â”Š   â”Š  3â”Š    this.sprite = sprite;\n-+â”Š   â”Š  4â”Š    // The key-frames array contains objects with the properties of the\n-+â”Š   â”Š  5â”Š    // sprite at the current time-point, e.g. width of 100 and height of 200\n-+â”Š   â”Š  6â”Š    this.keyframes = keyframes;\n-+â”Š   â”Š  7â”Š    this.age = 0;\n-+â”Š   â”Š  8â”Š    this.frame = 0;\n-+â”Š   â”Š  9â”Š    // This flag determines what's gonna happen to the animation once\n-+â”Š   â”Š 10â”Š    // it's finished playing\n-+â”Š   â”Š 11â”Š    this.repetitionMode = \"none\";\n-+â”Š   â”Š 12â”Š    this.lastKeyframe = _.last(keyframes);\n-+â”Š   â”Š 13â”Š    this.lastFrame = this.lastKeyframe.frame;\n-+â”Š   â”Š 14â”Š\n-+â”Š   â”Š 15â”Š    // These are the properties which we can animate\n-+â”Š   â”Š 16â”Š    this.animables = [\n-+â”Š   â”Š 17â”Š      \"x\", \"y\", \"width\", \"height\", \"opacity\"\n-+â”Š   â”Š 18â”Š    ];\n-+â”Š   â”Š 19â”Š\n-+â”Š   â”Š 20â”Š    // Set a map whose keys represent animatable properties and values represent an array\n-+â”Š   â”Š 21â”Š    // with relevant key-frames to its belonging property\n-+â”Š   â”Š 22â”Š    this.trimmedKeyframes = this.animables.reduce((trimmedKeyframes, key) => {\n-+â”Š   â”Š 23â”Š      trimmedKeyframes[key] = keyframes.filter(keyframe => keyframe[key] != null);\n-+â”Š   â”Š 24â”Š      return trimmedKeyframes;\n-+â”Š   â”Š 25â”Š    }, {});\n-+â”Š   â”Š 26â”Š\n-+â”Š   â”Š 27â”Š    // Set initial properties on sprite based on initial key-frame\n-+â”Š   â”Š 28â”Š    _.each(keyframes[0], (value, key) => {\n-+â”Š   â”Š 29â”Š      if (this.animables.includes(key)) sprite[key] = value;\n-+â”Š   â”Š 30â”Š    });\n-+â”Š   â”Š 31â”Š  }\n-+â”Š   â”Š 32â”Š\n-+â”Š   â”Š 33â”Š  draw(context, offsetX, offsetY) {\n-+â”Š   â”Š 34â”Š    this.sprite.draw(context, offsetX, offsetY);\n-+â”Š   â”Š 35â”Š  }\n-+â”Š   â”Š 36â”Š\n-+â”Š   â”Š 37â”Š  update(span) {\n-+â”Š   â”Š 38â”Š    if (!this.playing) return;\n-+â”Š   â”Š 39â”Š\n-+â”Š   â”Š 40â”Š    this.age += span;\n-+â”Š   â”Š 41â”Š\n-+â”Š   â”Š 42â”Š    switch (this.repetitionMode) {\n-+â”Š   â”Š 43â”Š      // After one cycle animation would stop\n-+â”Š   â”Š 44â”Š      case \"none\":\n-+â”Š   â”Š 45â”Š        this.frame += span;\n-+â”Š   â”Š 46â”Š\n-+â”Š   â”Š 47â”Š        if (this.frame > this.lastFrame) {\n-+â”Š   â”Š 48â”Š          this.frame = this.lastFrame;\n-+â”Š   â”Š 49â”Š          this.playing = false;\n-+â”Š   â”Š 50â”Š        }\n-+â”Š   â”Š 51â”Š\n-+â”Š   â”Š 52â”Š        break;\n-+â”Š   â”Š 53â”Š\n-+â”Š   â”Š 54â”Š      // Once finished, replay from the beginning\n-+â”Š   â”Š 55â”Š      case \"cyclic\":\n-+â”Š   â”Š 56â”Š        this.frame = this.age % this.lastFrame;\n-+â”Š   â”Š 57â”Š        break;\n-+â”Š   â”Š 58â”Š\n-+â”Š   â”Š 59â”Š      // Once finished, play backwards, and so on\n-+â”Š   â”Š 60â”Š      case \"full\":\n-+â”Š   â”Š 61â”Š        this.frame = this.age % this.lastFrame;\n-+â”Š   â”Š 62â”Š        let animationComplete = (this.age / this.lastFrame) % 2 >= 1;\n-+â”Š   â”Š 63â”Š        if (animationComplete) this.frame = this.lastFrame - this.frame;\n-+â”Š   â”Š 64â”Š        break;\n-+â”Š   â”Š 65â”Š    }\n-+â”Š   â”Š 66â”Š\n-+â”Š   â”Š 67â”Š    // Update sprite properties based on given key-frame's easing mode\n-+â”Š   â”Š 68â”Š    this.animables.forEach(key => {\n-+â”Š   â”Š 69â”Š      let motion = this.getKeyframeMotion(key);\n-+â”Š   â”Š 70â”Š\n-+â”Š   â”Š 71â”Š      if (motion)\n-+â”Š   â”Š 72â”Š        this.sprite[key] = this.calculateRelativeValue(motion, key);\n-+â”Š   â”Š 73â”Š    });\n-+â”Š   â”Š 74â”Š  }\n-+â”Š   â”Š 75â”Š\n-+â”Š   â”Š 76â”Š  play() {\n-+â”Š   â”Š 77â”Š    this.playing = true;\n-+â”Š   â”Š 78â”Š  }\n-+â”Š   â”Š 79â”Š\n-+â”Š   â”Š 80â”Š  pause() {\n-+â”Š   â”Š 81â”Š    this.playing = false;\n-+â”Š   â”Š 82â”Š  }\n-+â”Š   â”Š 83â”Š\n-+â”Š   â”Š 84â”Š  // Gets motion for current refresh\n-+â”Š   â”Š 85â”Š  getKeyframeMotion(key) {\n-+â”Š   â”Š 86â”Š    let keyframes = this.trimmedKeyframes[key];\n-+â”Š   â”Š 87â”Š\n-+â”Š   â”Š 88â”Š    // If no key-frames defined, motion is idle\n-+â”Š   â”Š 89â”Š    if (keyframes == null) return;\n-+â”Š   â”Š 90â”Š    // If there is only one key frame, motion is idle\n-+â”Š   â”Š 91â”Š    if (keyframes.length < 2) return;\n-+â”Š   â”Š 92â”Š    // If last frame reached, motion is idle\n-+â”Š   â”Š 93â”Š    if (this.frame > _.last(keyframes).frame) return;\n-+â”Š   â”Š 94â”Š\n-+â”Š   â”Š 95â”Š    let start = this.findStartKeyframe(keyframes);\n-+â”Š   â”Š 96â”Š    let end = this.findEndKeyframe(keyframes);\n-+â”Š   â”Š 97â”Š    let ratio = this.getKeyframesRatio(start, end);\n-+â”Š   â”Š 98â”Š\n-+â”Š   â”Š 99â”Š    return { start, end, ratio };\n-+â”Š   â”Š100â”Š  }\n-+â”Š   â”Š101â”Š\n-+â”Š   â”Š102â”Š  // Gets the movement ratio\n-+â”Š   â”Š103â”Š  getKeyframesRatio(start, end) {\n-+â”Š   â”Š104â”Š    return (this.frame - start.frame) / (end.frame - start.frame);\n-+â”Š   â”Š105â”Š  }\n-+â”Š   â”Š106â”Š\n-+â”Š   â”Š107â”Š  // Get property end value based on current frame\n-+â”Š   â”Š108â”Š  findEndKeyframe(keyframes) {\n-+â”Š   â”Š109â”Š    return _.find(keyframes, keyframe =>\n-+â”Š   â”Š110â”Š      keyframe.frame >= (this.frame || 1)\n-+â”Š   â”Š111â”Š    );\n-+â”Š   â”Š112â”Š  }\n-+â”Š   â”Š113â”Š\n-+â”Š   â”Š114â”Š  // Get property start value based on current frame\n-+â”Š   â”Š115â”Š  findStartKeyframe(keyframes) {\n-+â”Š   â”Š116â”Š    let resultIndex;\n-+â”Š   â”Š117â”Š\n-+â”Š   â”Š118â”Š    keyframes.some((keyframe, currIndex) => {\n-+â”Š   â”Š119â”Š      if (keyframe.frame >= (this.frame || 1)) {\n-+â”Š   â”Š120â”Š        resultIndex = currIndex;\n-+â”Š   â”Š121â”Š        return true;\n-+â”Š   â”Š122â”Š      }\n-+â”Š   â”Š123â”Š    });\n-+â”Š   â”Š124â”Š\n-+â”Š   â”Š125â”Š    return keyframes[resultIndex - 1];\n-+â”Š   â”Š126â”Š  }\n-+â”Š   â”Š127â”Š\n-+â”Š   â”Š128â”Š  // Get a recalculated property value relative to provided easing mode\n-+â”Š   â”Š129â”Š  calculateRelativeValue(motion, key) {\n-+â”Š   â”Š130â”Š    let a = motion.start[key];\n-+â”Š   â”Š131â”Š    let b = motion.end[key];\n-+â”Š   â”Š132â”Š    let r = motion.ratio;\n-+â”Š   â”Š133â”Š    let easing = r > 0 ? motion.start.easing : motion.end.easing;\n-+â”Š   â”Š134â”Š\n-+â”Š   â”Š135â”Š    switch (easing) {\n-+â”Š   â”Š136â”Š      case \"in\": r = Math.sin((r * Math.PI) / 2); break;\n-+â”Š   â”Š137â”Š      case \"out\": r = Math.cos((r * Math.PI) / 2); break;\n-+â”Š   â”Š138â”Š    }\n-+â”Š   â”Š139â”Š\n-+â”Š   â”Š140â”Š    return ((b - a) * r) + a;\n-+â”Š   â”Š141â”Š  }\n-+â”Š   â”Š142â”Š};ðŸš«â†µ\n-```\n-\n-##### Changed views/game.html\n-```diff\n-@@ -10,6 +10,7 @@\n- â”Š10â”Š10â”Š    <!-- Scripts -->\n- â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n- â”Š12â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/sprite.js\"></script>\n-+â”Š  â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/animations/keyframe.js\"></script>\n- â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/key_states.js\"></script>\n- â”Š14â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/layer.js\"></script>\n- â”Š15â”Š16â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/screen.js\"></script>\n-```\n-[}]: #\n-\n-When initializing a new instance of the key-frame animation, we should invoke it with the desired sprite, and an array of key-frames. What exactly does a single key-frame represents? The properties of the sprite at that specific time point. In addition, a key-frame can be set with an [easing mode](https://css-tricks.com/ease-out-in-ease-in-out/) of `in` and `out`. By default, the animation would be linear.\n-\n-Based on the `repitationMode` property, three things can happen to the animation once finished:\n-\n-- `none` - The animation will play once, and then stop. It will appear as a static sprite.\n-- `cyclic` - The animation will repeat itself from the beginning, over and over again until stopped manually.\n-- `full` - The animation will play itself backwards, and then forwards, backwards, forwards, and so on.\n-\n-Thanks to the key-frame animation engine, we can apply it to the splash screen to show a beautifully animated logo rather than showing a static image. So in addition to the logo sprite, we will initialize a key-frame animation as well:\n-\n-[{]: <helper> (diff_step 3.9)\n-#### Step 3.9: Apply key-frame animation to splash screen\n-\n-##### Changed resources/scripts/game/screens/splash/index.js\n-```diff\n-@@ -1,9 +1,34 @@\n- â”Š 1â”Š 1â”ŠGame.Screens.Splash = class Splash extends Engine.Screen {\n- â”Š 2â”Š 2â”Š  initialize() {\n- â”Š 3â”Š 3â”Š    // Create splash sprite and set its properties\n--â”Š 4â”Š  â”Š    this.splashSprite = new Engine.Sprite(this.assets.splashTexture);\n--â”Š 5â”Š  â”Š    this.splashSprite.align = \"center\";\n--â”Š 6â”Š  â”Š    this.splashSprite.x = this.width / 2;\n-+â”Š  â”Š 4â”Š    let splashSprite = new Engine.Sprite(this.assets.splashTexture);\n-+â”Š  â”Š 5â”Š    splashSprite.align = \"center\";\n-+â”Š  â”Š 6â”Š    splashSprite.x = this.width / 2;\n-+â”Š  â”Š 7â”Š\n-+â”Š  â”Š 8â”Š    // Create splash sprite animation\n-+â”Š  â”Š 9â”Š    this.splashAnim = new Engine.Animations.Keyframe(splashSprite, [\n-+â”Š  â”Š10â”Š      {\n-+â”Š  â”Š11â”Š        y: (this.height / 2) - 30,\n-+â”Š  â”Š12â”Š        width: splashSprite.width / 4,\n-+â”Š  â”Š13â”Š        height: splashSprite.height / 4,\n-+â”Š  â”Š14â”Š        opacity: 0,\n-+â”Š  â”Š15â”Š        easing: \"in\",\n-+â”Š  â”Š16â”Š        frame: 0\n-+â”Š  â”Š17â”Š      },\n-+â”Š  â”Š18â”Š      {\n-+â”Š  â”Š19â”Š        y: this.height / 2,\n-+â”Š  â”Š20â”Š        width: (splashSprite.width / 3) + (splashSprite.width * 0.05),\n-+â”Š  â”Š21â”Š        height: (splashSprite.height / 3) + (splashSprite.height * 0.05),\n-+â”Š  â”Š22â”Š        opacity: 1,\n-+â”Š  â”Š23â”Š        frame: 3000\n-+â”Š  â”Š24â”Š      },\n-+â”Š  â”Š25â”Š      {\n-+â”Š  â”Š26â”Š        frame: 3500\n-+â”Š  â”Š27â”Š      }\n-+â”Š  â”Š28â”Š    ]);\n-+â”Š  â”Š29â”Š\n-+â”Š  â”Š30â”Š    // Start playing animation\n-+â”Š  â”Š31â”Š    this.splashAnim.play();\n- â”Š 7â”Š32â”Š  }\n- â”Š 8â”Š33â”Š\n- â”Š 9â”Š34â”Š  load(assetsLoader) {\n-```\n-```diff\n-@@ -14,6 +39,10 @@\n- â”Š14â”Š39â”Š  }\n- â”Š15â”Š40â”Š\n- â”Š16â”Š41â”Š  draw(context) {\n--â”Š17â”Š  â”Š    this.splashSprite.draw(context);\n-+â”Š  â”Š42â”Š    this.splashAnim.draw(context);\n-+â”Š  â”Š43â”Š  }\n-+â”Š  â”Š44â”Š\n-+â”Š  â”Š45â”Š  update(span) {\n-+â”Š  â”Š46â”Š    this.splashAnim.update(span);\n- â”Š18â”Š47â”Š  }\n- â”Š19â”Š48â”Š};ðŸš«â†µ\n-```\n-[}]: #\n-\n-The following key-frames illustrate the nodes of the animation we've just created:\n-\n-    width: 0\n-    height: 0\n-    opacity: 0\n-\n-![logo-empty](https://cloud.githubusercontent.com/assets/7648874/21583394/ee7a1dec-d065-11e6-80ce-fdd37c4b5dbb.png)\n-\n-    width: 225\n-    height: 175\n-    opacity: 1\n-\n-![logo-half](https://cloud.githubusercontent.com/assets/7648874/21583396/ee9bdf68-d065-11e6-95fb-4cf5ed58a9de.png)\n-\n-    width: 342\n-    height: 266\n-    opacity: 1\n-\n-![logo-full](https://cloud.githubusercontent.com/assets/7648874/21583395/ee7b3754-d065-11e6-9646-476d196a6412.png)\n-[}]: #\n-[{]: <region> (footer)\n-[{]: <helper> (nav_step)\n-| [< Previous Step](step2.md) | [Next Step >](step4.md) |\n-|:--------------------------------|--------------------------------:|\n-[}]: #\n-[}]: #\n\\ No newline at end of file\ndiff --git a/manuals/views/step4.md b/manuals/views/step4.md\ndeleted file mode 100644\nindex 72bc8d2..0000000\n--- a/manuals/views/step4.md\n+++ /dev/null\n@@ -1,609 +0,0 @@\n-[{]: <region> (header)\n-# Step 4: Creating a main menu screen using a font engine\n-[}]: #\n-[{]: <region> (body)\n-![snake-demo-menu-small](https://cloud.githubusercontent.com/assets/7648874/21074099/e72a81bc-bed6-11e6-98cb-329dc12a4b06.gif)\n-\n-In this step we will be creating the main menu screen as shown above. The main menu screen is a simple screen which will show the logo of the game and an instruction text saying `Press a key to start`. We will be using a simple texture to show the game-logo and we will use the key-frame animation engine to show a flickering animation of the instruction text. The instruction text is the main part of this step, since it is made out of a font file (`.ttf`) and the text is auto-generated, a general solution which can serve us in many situations. We will start by implementing the main menu using static assets, which means that we will use a texture to show the instructions text, and later on we will implement the generic solution I've just mentioned. First, we will download the necessary assets:\n-\n-    resources/assets/textures$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/assets/textures/instructions.png\n-    resources/assets/textures$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/assets/textures/logo.png\n-\n-And then we will implement the initial main menu screen:\n-\n-[{]: <helper> (diff_step 4.2)\n-#### Step 4.2: Create initial main menu screen\n-\n-##### Added resources/scripts/game/screens/menu/index.js\n-```diff\n-@@ -0,0 +1,44 @@\n-+â”Š  â”Š 1â”ŠGame.Screens.Menu = class Menu extends Engine.Screen {\n-+â”Š  â”Š 2â”Š  initialize() {\n-+â”Š  â”Š 3â”Š    // Initialize snake logo sprite\n-+â”Š  â”Š 4â”Š    this.logoSprite = new Engine.Sprite(this.assets.logoTexture);\n-+â”Š  â”Š 5â”Š    this.logoSprite.setPercentage(\"width\", this.width, 30, \"height\");\n-+â”Š  â”Š 6â”Š\n-+â”Š  â”Š 7â”Š    // Initialize instructions sprite\n-+â”Š  â”Š 8â”Š    let instructionsSprite = new Engine.Sprite(this.assets.instructionsTexture);\n-+â”Š  â”Š 9â”Š    instructionsSprite.align = \"center\";\n-+â”Š  â”Š10â”Š    instructionsSprite.setPercentage(\"width\", this.width, 35, \"height\");\n-+â”Š  â”Š11â”Š    instructionsSprite.x = this.width / 2;\n-+â”Š  â”Š12â”Š    instructionsSprite.y = this.height / 2;\n-+â”Š  â”Š13â”Š\n-+â”Š  â”Š14â”Š    // Create flickering animation for instructions sprite\n-+â”Š  â”Š15â”Š    this.instructionsAnim = new Engine.Animations.Keyframe(instructionsSprite, [\n-+â”Š  â”Š16â”Š      {\n-+â”Š  â”Š17â”Š        opacity: 1,\n-+â”Š  â”Š18â”Š        frame: 0\n-+â”Š  â”Š19â”Š      },\n-+â”Š  â”Š20â”Š      {\n-+â”Š  â”Š21â”Š        opacity: 0,\n-+â”Š  â”Š22â”Š        frame: 2000\n-+â”Š  â”Š23â”Š      }\n-+â”Š  â”Š24â”Š    ]);\n-+â”Š  â”Š25â”Š\n-+â”Š  â”Š26â”Š    // Play it repeatedly, back and forth\n-+â”Š  â”Š27â”Š    this.instructionsAnim.repetitionMode = \"full\";\n-+â”Š  â”Š28â”Š    this.instructionsAnim.play();\n-+â”Š  â”Š29â”Š  }\n-+â”Š  â”Š30â”Š\n-+â”Š  â”Š31â”Š  unload() {\n-+â”Š  â”Š32â”Š    // Dispose the following assets to prevent memory leaks\n-+â”Š  â”Š33â”Š    return [\"logoTexture\", \"instructionsTexture\"];\n-+â”Š  â”Š34â”Š  }\n-+â”Š  â”Š35â”Š\n-+â”Š  â”Š36â”Š  draw(context) {\n-+â”Š  â”Š37â”Š    this.logoSprite.draw(context);\n-+â”Š  â”Š38â”Š    this.instructionsAnim.draw(context);\n-+â”Š  â”Š39â”Š  }\n-+â”Š  â”Š40â”Š\n-+â”Š  â”Š41â”Š  update(span) {\n-+â”Š  â”Š42â”Š    this.instructionsAnim.update(span);\n-+â”Š  â”Š43â”Š  }\n-+â”Š  â”Š44â”Š};ðŸš«â†µ\n-```\n-\n-##### Changed views/game.html\n-```diff\n-@@ -16,6 +16,7 @@\n- â”Š16â”Š16â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/screen.js\"></script>\n- â”Š17â”Š17â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/assets_loader.js\"></script>\n- â”Š18â”Š18â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n-+â”Š  â”Š19â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/menu/index.js\"></script>\n- â”Š19â”Š20â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/splash/index.js\"></script>\n- â”Š20â”Š21â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n-```\n-[}]: #\n-\n-This screen is dependent on several assets which we will load during \"splash screen time\", to save some loading time and for a smooth experience. The main menu screen will be shown automatically once the splash animation has been finished:\n-\n-[{]: <helper> (diff_step 4.3)\n-#### Step 4.3: Queue main menu screen\n-\n-##### Changed resources/scripts/game/screens/splash/index.js\n-```diff\n-@@ -32,10 +32,21 @@\n- â”Š32â”Š32â”Š  }\n- â”Š33â”Š33â”Š\n- â”Š34â”Š34â”Š  load(assetsLoader) {\n-+â”Š  â”Š35â”Š    // Load assets\n-+â”Š  â”Š36â”Š    let instructionsTexture = assetsLoader.texture(\"/textures/instrucitons\");\n-+â”Š  â”Š37â”Š    let logoTexture = assetsLoader.texture(\"/textures/logo\");\n-+â”Š  â”Š38â”Š    let splashTexture = assetsLoader.texture(\"/textures/splash\");\n-+â”Š  â”Š39â”Š\n-+â”Š  â”Š40â”Š    // These are global assets which will be shared among all screens until manually\n-+â”Š  â”Š41â”Š    // disposed. We use the time gap created by the splash animation to load necessary\n-+â”Š  â”Š42â”Š    // assets without wasting any time\n-+â”Š  â”Š43â”Š    this.game.extendAssets({\n-+â”Š  â”Š44â”Š      instructionsTexture,\n-+â”Š  â”Š45â”Š      logoTexture\n-+â”Š  â”Š46â”Š    });\n-+â”Š  â”Š47â”Š\n- â”Š35â”Š48â”Š    // These are local assets which will be disposed along with the screen\n--â”Š36â”Š  â”Š    return {\n--â”Š37â”Š  â”Š      splashTexture: assetsLoader.texture(\"/textures/splash\")\n--â”Š38â”Š  â”Š    };\n-+â”Š  â”Š49â”Š    return { splashTexture };\n- â”Š39â”Š50â”Š  }\n- â”Š40â”Š51â”Š\n- â”Š41â”Š52â”Š  draw(context) {\n-```\n-```diff\n-@@ -43,6 +54,12 @@\n- â”Š43â”Š54â”Š  }\n- â”Š44â”Š55â”Š\n- â”Š45â”Š56â”Š  update(span) {\n--â”Š46â”Š  â”Š    this.splashAnim.update(span);\n-+â”Š  â”Š57â”Š    if (this.splashAnim.playing) {\n-+â”Š  â”Š58â”Š      this.splashAnim.update(span);\n-+â”Š  â”Š59â”Š    }\n-+â”Š  â”Š60â”Š    // Once animation has stopped play switch to main menu\n-+â”Š  â”Š61â”Š    else {\n-+â”Š  â”Š62â”Š      this.game.changeScreen(Game.Screens.Menu);\n-+â”Š  â”Š63â”Š    }\n- â”Š47â”Š64â”Š  }\n- â”Š48â”Š65â”Š};ðŸš«â†µ\n-```\n-[}]: #\n-\n-By now if you launch the application you should see the main menu screen as described in the beginning. But event though it works, we're not yet finished. We still need to convert the instruction texture into an auto-generated font texture. Obviously, this requires us to download the desired `ttf` file:\n-\n-    resources/assets/fonts$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/assets/fonts/minecraftia.ttf\n-\n-> Any font file can be used here, but to save time and effort I already provided you with one\n-\n-`ttf` is the most common format, but since we're using JavaScript, it would make sense to convert it into a `json` file, and that's exactly what we're going to do. There's a very convenient software called [font-builder](https://github.com/andryblack/fontbuilder), and it can cut fonts, store them in `png` files, along with some user-specified meta-data stored in an `xml` file.\n-\n-![font-builder](https://camo.githubusercontent.com/b2c95cda825c783f5399d9197599848c33cdfcc8/687474703a2f2f7777772e67616d656465762e72752f66696c65732f696d616765732f73637265656e312e6a706567)\n-\n-Go over to this website: https://github.com/andryblack/fontbuilder.\n-Fetch a copy of the `font-builder` repo, and try to convert the `minecraftia.ttf` file into a `png` file. If you want to skip this step, although I wouldn't recommend it, you can download the following files which I already generated myself:\n-\n-    resources/assets/fonts$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/assets/fonts/minecraftia.png\n-    resources/assets/fonts$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/assets/fonts/minecraftia.xml\n-\n-As promised, we will be working with a `json` file, not a `ttf` file and not an `xml` file. For this task we will be implementing a font-parser module, which will simply take all the meta-data in the `xml` file and put it into a nice `json` schema:\n-\n-[{]: <helper> (diff_step 4.6)\n-#### Step 4.6: Create font parser so we can convert 'xml' font format to 'json'\n-\n-##### Added helpers/font_parser.js\n-```diff\n-@@ -0,0 +1,102 @@\n-+â”Š   â”Š  1â”Šconst _ = require(\"underscore\");\n-+â”Š   â”Š  2â”Šconst Async = require(\"async\");\n-+â”Š   â”Š  3â”Šconst Fs = require(\"fs\");\n-+â”Š   â”Š  4â”Šconst Path = require(\"path\");\n-+â”Š   â”Š  5â”Šconst { DOMParser } = require(\"xmldom\");\n-+â”Š   â”Š  6â”Š\n-+â”Š   â”Š  7â”Šif (module === require.main) {\n-+â”Š   â”Š  8â”Š  let fonstDir = Path.resolve(__dirname, \"../resources/assets/fonts\");\n-+â”Š   â”Š  9â”Š  xmlsToJsons(fonstDir, err => { if (err) throw err });\n-+â”Š   â”Š 10â”Š}\n-+â”Š   â”Š 11â”Š\n-+â”Š   â”Š 12â”Š// Gets a dir path containing font xmls and converts them all to jsons\n-+â”Š   â”Š 13â”Šfunction xmlsToJsons(path, callback = _.noop) {\n-+â”Š   â”Š 14â”Š  Fs.readdir(path, (err, files) => {\n-+â”Š   â”Š 15â”Š    if (err) return callback(err);\n-+â”Š   â”Š 16â”Š\n-+â”Š   â”Š 17â”Š    // Remove all extensions\n-+â”Š   â”Š 18â”Š    fileNames = _.uniq(files.map(file => file.split(\".\")[0]));\n-+â”Š   â”Š 19â”Š\n-+â”Š   â”Š 20â”Š    // Convert each xml individually\n-+â”Š   â”Š 21â”Š    Async.each(fileNames, (fileName, next) => {\n-+â”Š   â”Š 22â”Š      xmlToJson(`${path}/${fileName}`, next);\n-+â”Š   â”Š 23â”Š    },\n-+â”Š   â”Š 24â”Š    (err) => {\n-+â”Š   â”Š 25â”Š      if (!err) console.log(\n-+â”Š   â”Š 26â”Š        'All fonts have been successfully parsed!'\n-+â”Š   â”Š 27â”Š      );\n-+â”Š   â”Š 28â”Š\n-+â”Š   â”Š 29â”Š      callback(err);\n-+â”Š   â”Š 30â”Š    });\n-+â”Š   â”Š 31â”Š  });\n-+â”Š   â”Š 32â”Š}\n-+â”Š   â”Š 33â”Š\n-+â”Š   â”Š 34â”Š// Gets a font xml and converts it to json\n-+â”Š   â”Š 35â”Šfunction xmlToJson(path, callback = _.noop) {\n-+â”Š   â”Š 36â”Š  Async.waterfall([\n-+â”Š   â”Š 37â”Š    (next) => {\n-+â”Š   â”Š 38â”Š      Fs.readFile(`${path}.xml`, function(err, xmlBuffer) {\n-+â”Š   â”Š 39â”Š        if (err) return next(err);\n-+â”Š   â”Š 40â”Š\n-+â”Š   â”Š 41â”Š        let json = {\n-+â”Š   â”Š 42â”Š          chars: {}\n-+â”Š   â”Š 43â”Š        };\n-+â”Š   â”Š 44â”Š\n-+â”Š   â”Š 45â”Š        let xml = xmlBuffer.toString();\n-+â”Š   â”Š 46â”Š        let doc = new DOMParser().parseFromString(xml);\n-+â”Š   â”Š 47â”Š        let fontDoc = doc.getElementsByTagName(\"Font\")[0];\n-+â”Š   â”Š 48â”Š        let charsDoc = fontDoc.getElementsByTagName(\"Char\");\n-+â”Š   â”Š 49â”Š\n-+â”Š   â”Š 50â”Š        // Compose meta-data about font like size and family\n-+â”Š   â”Š 51â”Š        _.each(fontDoc.attributes, (attr) => {\n-+â”Š   â”Š 52â”Š          json[attr.name] = parseInt(attr.value) || attr.value;\n-+â”Š   â”Š 53â”Š        });\n-+â”Š   â”Š 54â”Š\n-+â”Š   â”Š 55â”Š        // Compose data about each character in font\n-+â”Š   â”Š 56â”Š        _.each(charsDoc, (charDoc) => {\n-+â”Š   â”Š 57â”Š          let charCode = charDoc.getAttribute(\"code\");\n-+â”Š   â”Š 58â”Š\n-+â”Š   â”Š 59â”Š          let char = json.chars[charCode] = {\n-+â”Š   â”Š 60â”Š            rect: rect = {},\n-+â”Š   â”Š 61â”Š            offset: offset = {},\n-+â”Š   â”Š 62â”Š            width: parseInt(charDoc.getAttribute(\"width\"))\n-+â”Š   â”Š 63â”Š          };\n-+â”Š   â”Š 64â”Š\n-+â”Š   â”Š 65â”Š          [\n-+â”Š   â”Š 66â”Š            rect.x,\n-+â”Š   â”Š 67â”Š            rect.y,\n-+â”Š   â”Š 68â”Š            rect.width,\n-+â”Š   â”Š 69â”Š            rect.height\n-+â”Š   â”Š 70â”Š          ] = extractIntegers(charDoc.getAttribute(\"rect\"));\n-+â”Š   â”Š 71â”Š\n-+â”Š   â”Š 72â”Š          [offset.x, offset.y] = extractIntegers(charDoc.getAttribute(\"offset\"));\n-+â”Š   â”Š 73â”Š        });\n-+â”Š   â”Š 74â”Š\n-+â”Š   â”Š 75â”Š        next(null, JSON.stringify(json, null, 2));\n-+â”Š   â”Š 76â”Š      });\n-+â”Š   â”Š 77â”Š    },\n-+â”Š   â”Š 78â”Š    (json, next) => {\n-+â”Š   â”Š 79â”Š      // Once finished, write json into file\n-+â”Š   â”Š 80â”Š      Fs.writeFile(path + \".json\", json, (err) => {\n-+â”Š   â”Š 81â”Š        next(err);\n-+â”Š   â”Š 82â”Š      });\n-+â”Š   â”Š 83â”Š    }\n-+â”Š   â”Š 84â”Š  ], (err) => {\n-+â”Š   â”Š 85â”Š    if (!err) console.log(\n-+â”Š   â”Š 86â”Š      `Font ${path} has been successfully parsed...`\n-+â”Š   â”Š 87â”Š    );\n-+â”Š   â”Š 88â”Š\n-+â”Š   â”Š 89â”Š    callback(err);\n-+â”Š   â”Š 90â”Š  });\n-+â”Š   â”Š 91â”Š};\n-+â”Š   â”Š 92â”Š\n-+â”Š   â”Š 93â”Š// Converts an string of numbers to array of numbers\n-+â”Š   â”Š 94â”Š// e.g. extractIntegers(\"1 2 3\") -> [1, 2, 3]\n-+â”Š   â”Š 95â”Šfunction extractIntegers(srcstr) {\n-+â”Š   â”Š 96â”Š  return srcstr.split(\" \").map((substr) => parseInt(substr));\n-+â”Š   â”Š 97â”Š}\n-+â”Š   â”Š 98â”Š\n-+â”Š   â”Š 99â”Šmodule.exports = {\n-+â”Š   â”Š100â”Š  xmlToJson,\n-+â”Š   â”Š101â”Š  xmlsToJsons\n-+â”Š   â”Š102â”Š};ðŸš«â†µ\n-```\n-[}]: #\n-\n-This script will take everything that's in the `fonts` dir and parser it as mentioned above. Before we can user this script we will need to install some NPM dependencies like so:\n-\n-    $ npm install --save underscore\n-    $ npm install --save xmldom\n-\n-And instead of running the parser manually over and over again whenever we wanna use it, we will use the following `NPM` script instead:\n-\n-[{]: <helper> (diff_step 4.8)\n-#### Step 4.8: Add font parsing npm scripts\n-\n-##### Changed package.json\n-```diff\n-@@ -3,7 +3,8 @@\n- â”Š 3â”Š 3â”Š  \"description\": \"A tutorial for creating a Tron-style game\",\n- â”Š 4â”Š 4â”Š  \"private\": true,\n- â”Š 5â”Š 5â”Š  \"scripts\": {\n--â”Š 6â”Š  â”Š    \"serve\": \"nodemon server.js\"\n-+â”Š  â”Š 6â”Š    \"serve\": \"npm run parse:fonts && nodemon server.js\",\n-+â”Š  â”Š 7â”Š    \"build:fonts\": \"node helpers/font_parser.js\"\n- â”Š 7â”Š 8â”Š  },\n- â”Š 8â”Š 9â”Š  \"dependencies\": {\n- â”Š 9â”Š10â”Š    \"async\": \"^2.1.4\",\n-```\n-[}]: #\n-\n-We don't want the generated fonts to be included by `git` since they are going to automatically regenerate themselves, therefore we gonna add the following ignore rule:\n-\n-[{]: <helper> (diff_step 4.9)\n-#### Step 4.9: Add rule to to git-ignore parsed fonts\n-\n-##### Changed .gitignore\n-```diff\n-@@ -1,2 +1,3 @@\n- â”Š1â”Š1â”Šnode_modules\n--â”Š2â”Š â”Šnpm-debug.logðŸš«â†µ\n-+â”Š â”Š2â”Šnpm-debug.log\n-+â”Š â”Š3â”Šresources/assets/fonts/*.jsonðŸš«â†µ\n-```\n-[}]: #\n-\n-Now we will build our `minecraftia` font by simply running:\n-\n-    $ npm run build:fonts\n-\n-And voila! We have a freshly created `json` file which we can work with. You can also get it from here:\n-\n-    resources/assets/fonts$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/assets/fonts/minecraftia.json\n-\n-Now that we have our assets finally ready we can go ahead and focus on extending the engine which powers up our game. We need some sort of a generic font-engine which will know how to load a font file and create a text-sprite out of it. First we will implement a class called `Restorable`, which shares the same restore API as the CanvasRenderingContext2D and will give us the ability to save and restore the font's state (More information can be found [here](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/restore)):\n-\n-[{]: <helper> (diff_step 4.11)\n-#### Step 4.11: Add 'Restorable' class\n-\n-##### Added resources/scripts/engine/restorable.js\n-```diff\n-@@ -0,0 +1,21 @@\n-+â”Š  â”Š 1â”ŠEngine.Restorable = class Restorable {\n-+â”Š  â”Š 2â”Š  // Acts the same as canvas's save() and restore() API.\n-+â”Š  â”Š 3â”Š  // 'restorable' props are defined in the constructor\n-+â”Š  â”Š 4â”Š  constructor(...restorableProps) {\n-+â”Š  â”Š 5â”Š    this._restorableProps = restorableProps;\n-+â”Š  â”Š 6â”Š    this._restorableStates = [];\n-+â”Š  â”Š 7â”Š  }\n-+â”Š  â”Š 8â”Š\n-+â”Š  â”Š 9â”Š  // Save current state in the stack\n-+â”Š  â”Š10â”Š  save() {\n-+â”Š  â”Š11â”Š    this._restorableStates.push(this._restorableProps.reduce((state, prop) => {\n-+â”Š  â”Š12â”Š      state[prop] = this[prop];\n-+â”Š  â”Š13â”Š      return state;\n-+â”Š  â”Š14â”Š    }, {}));\n-+â”Š  â”Š15â”Š  }\n-+â”Š  â”Š16â”Š\n-+â”Š  â”Š17â”Š  // Pop most recent state and apply it\n-+â”Š  â”Š18â”Š  restore() {\n-+â”Š  â”Š19â”Š    _.extend(this, this._restorableStates.pop());\n-+â”Š  â”Š20â”Š  }\n-+â”Š  â”Š21â”Š};ðŸš«â†µ\n-```\n-\n-##### Changed views/game.html\n-```diff\n-@@ -9,6 +9,7 @@\n- â”Š 9â”Š 9â”Š\n- â”Š10â”Š10â”Š    <!-- Scripts -->\n- â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n-+â”Š  â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/restorable.js\"></script>\n- â”Š12â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/sprite.js\"></script>\n- â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/animations/keyframe.js\"></script>\n- â”Š14â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/key_states.js\"></script>\n-```\n-[}]: #\n-\n-And now we can go ahead and implement the font class itself:\n-\n-[{]: <helper> (diff_step 4.12)\n-#### Step 4.12: Create font engine\n-\n-##### Added resources/scripts/engine/font.js\n-```diff\n-@@ -0,0 +1,133 @@\n-+â”Š   â”Š  1â”ŠEngine.Font = class Font extends Engine.Restorable {\n-+â”Š   â”Š  2â”Š  // The src property acts just line native image's src property.\n-+â”Š   â”Š  3â”Š  // Once finished loading, the onload() callback will be invoked\n-+â”Š   â”Š  4â”Š  get src() {\n-+â”Š   â”Š  5â”Š    return this._src;\n-+â”Š   â”Š  6â”Š  }\n-+â”Š   â”Š  7â”Š\n-+â”Š   â”Š  8â”Š  set src(src) {\n-+â”Š   â”Š  9â”Š    this._src = src;\n-+â”Š   â”Š 10â”Š\n-+â”Š   â”Š 11â”Š    // The font is actually an image, therefore we have 2 onload callbacks.\n-+â”Š   â”Š 12â”Š    // The first one is the native one which will always be run,\n-+â”Š   â”Š 13â”Š    // and the second one is a user defined one\n-+â”Š   â”Š 14â”Š    if (this.onload) var done = _.after(2, this.onload);\n-+â”Š   â”Š 15â”Š\n-+â”Š   â”Š 16â”Š    this.atlas = new Image();\n-+â”Š   â”Š 17â”Š    this.atlas.onload = done;\n-+â”Š   â”Š 18â”Š    this.atlas.src = `${src}.png`;\n-+â”Š   â”Š 19â”Š\n-+â”Š   â”Š 20â”Š    // Get json based on the given src property\n-+â”Š   â”Š 21â”Š    $.getJSON(`${src}.json`, data => {\n-+â”Š   â”Š 22â”Š      this.data = data;\n-+â”Š   â”Š 23â”Š      if (done) done();\n-+â”Š   â”Š 24â”Š    });\n-+â”Š   â”Š 25â”Š\n-+â”Š   â”Š 26â”Š    return this._src;\n-+â”Š   â”Š 27â”Š  }\n-+â”Š   â”Š 28â”Š\n-+â”Š   â”Š 29â”Š  constructor() {\n-+â”Š   â”Š 30â”Š    // The color property is the only restorable property\n-+â”Š   â”Š 31â”Š    super(\"color\");\n-+â”Š   â”Š 32â”Š    this.charSpritesCache = {};\n-+â”Š   â”Š 33â”Š  }\n-+â”Š   â”Š 34â”Š\n-+â”Š   â”Š 35â”Š  // Creates a texture out of the font with the given text\n-+â”Š   â”Š 36â”Š  createTexture(text, options = {}) {\n-+â”Š   â”Š 37â”Š    let { noOffsets, noSpaces } = options;\n-+â”Š   â”Š 38â”Š    let canvas = document.createElement(\"canvas\");\n-+â”Š   â”Š 39â”Š    let context = canvas.getContext(\"2d\");\n-+â”Š   â”Š 40â”Š    let height = canvas.height = this.data.height;\n-+â”Š   â”Š 41â”Š\n-+â”Š   â”Š 42â”Š    // Calculates the width of the canvas based on the text and the font\n-+â”Š   â”Š 43â”Š    let width = canvas.width = _.reduce(text, (width, c) => {\n-+â”Š   â”Š 44â”Š      // No-space option means that the characters will be\n-+â”Š   â”Š 45â”Š      // drawn with no any space between them\n-+â”Š   â”Š 46â”Š      if (noSpaces) {\n-+â”Š   â”Š 47â”Š        return width + this.getCharSprite(c).width;\n-+â”Š   â”Š 48â”Š      }\n-+â”Š   â”Š 49â”Š\n-+â”Š   â”Š 50â”Š      return width + this.data.chars[c].width;\n-+â”Š   â”Š 51â”Š    }, 0);\n-+â”Š   â”Š 52â”Š\n-+â”Š   â”Š 53â”Š    // A custom size can be specified for a font as well\n-+â”Š   â”Š 54â”Š    if (this.size) {\n-+â”Š   â”Š 55â”Š      let ratio = this.size / this.data.size;\n-+â”Š   â”Š 56â”Š      canvas.height *= ratio;\n-+â”Š   â”Š 57â”Š      canvas.width *= ratio;\n-+â”Š   â”Š 58â”Š      context.scale(ratio, ratio);\n-+â”Š   â”Š 59â”Š    }\n-+â”Š   â”Š 60â”Š\n-+â”Š   â”Š 61â”Š    // No we are going to draw each char on the canvas individually,\n-+â”Š   â”Š 62â”Š    // naturally, there should be an offset after we draw each character.\n-+â”Š   â”Š 63â”Š    // This variable will be used to calculate the offset\n-+â”Š   â”Š 64â”Š    let offset = 0;\n-+â”Š   â”Š 65â”Š\n-+â”Š   â”Š 66â”Š    // Get for each char\n-+â”Š   â”Š 67â”Š    _.map(text, (char) => {\n-+â”Š   â”Š 68â”Š      return this.getCharSprite(char);\n-+â”Š   â”Š 69â”Š    })\n-+â”Š   â”Š 70â”Š    // Start drawing each char on the canvas\n-+â”Š   â”Š 71â”Š    .forEach((charSprite, index) => {\n-+â”Š   â”Š 72â”Š      let charData = this.data.chars[text.charAt(index)];\n-+â”Š   â”Š 73â”Š\n-+â”Š   â”Š 74â”Š      // Each char in the font xml has a native offset in addition to its rectangle.\n-+â”Š   â”Š 75â”Š      // This option will disable the calculation of the native offset\n-+â”Š   â”Š 76â”Š      if (noOffsets) {\n-+â”Š   â”Š 77â”Š        charSprite.draw(context, offset);\n-+â”Š   â”Š 78â”Š      }\n-+â”Š   â”Š 79â”Š      else {\n-+â”Š   â”Š 80â”Š        charSprite.draw(context, offset + charData.offset.x, charData.offset.y);\n-+â”Š   â”Š 81â”Š      }\n-+â”Š   â”Š 82â”Š\n-+â”Š   â”Š 83â”Š      if (noSpaces) {\n-+â”Š   â”Š 84â”Š        offset += charSprite.width;\n-+â”Š   â”Š 85â”Š      }\n-+â”Š   â”Š 86â”Š      else {\n-+â”Š   â”Š 87â”Š        offset += charData.width;\n-+â”Š   â”Š 88â”Š      }\n-+â”Š   â”Š 89â”Š\n-+â”Š   â”Š 90â”Š      // A color for the font can be specified as well\n-+â”Š   â”Š 91â”Š      if (this.color) {\n-+â”Š   â”Š 92â”Š        let overlayCanvas = document.createElement(\"canvas\");\n-+â”Š   â”Š 93â”Š        let overlayContext = overlayCanvas.getContext(\"2d\");\n-+â”Š   â”Š 94â”Š        overlayCanvas.width = width;\n-+â”Š   â”Š 95â”Š        overlayCanvas.height = height;\n-+â”Š   â”Š 96â”Š        overlayContext.beginPath();\n-+â”Š   â”Š 97â”Š        overlayContext.rect(0, 0, width, height);\n-+â”Š   â”Š 98â”Š        overlayContext.fillStyle = this.color;\n-+â”Š   â”Š 99â”Š        overlayContext.fill();\n-+â”Š   â”Š100â”Š\n-+â”Š   â”Š101â”Š        context.save();\n-+â”Š   â”Š102â”Š        context.globalCompositeOperation = \"source-in\";\n-+â”Š   â”Š103â”Š        context.drawImage(overlayCanvas, 0, 0);\n-+â”Š   â”Š104â”Š        context.restore();\n-+â”Š   â”Š105â”Š      }\n-+â”Š   â”Š106â”Š    });\n-+â”Š   â”Š107â”Š\n-+â”Š   â”Š108â”Š    // The canvas will be treated like an image\n-+â”Š   â”Š109â”Š    return canvas;\n-+â”Š   â”Š110â”Š  }\n-+â”Š   â”Š111â”Š\n-+â”Š   â”Š112â”Š  // Gets a sprite of the given char, using the current font\n-+â”Š   â”Š113â”Š  getCharSprite(char) {\n-+â”Š   â”Š114â”Š    // If char is already stored in cache, abort calculation and return it\n-+â”Š   â”Š115â”Š    if (this.charSpritesCache[char]) return this.charSpritesCache[char];\n-+â”Š   â”Š116â”Š\n-+â”Š   â”Š117â”Š    // This data is fetched by the given json\n-+â”Š   â”Š118â”Š    let { x, y, width, height } = this.data.chars[char].rect;\n-+â”Š   â”Š119â”Š    // Creating a canvas which we will use to draw on,\n-+â”Š   â”Š120â”Š    // but it is used exactly like an image afterwards\n-+â”Š   â”Š121â”Š    let canvas = document.createElement(\"canvas\");\n-+â”Š   â”Š122â”Š    let context = canvas.getContext(\"2d\");\n-+â”Š   â”Š123â”Š\n-+â”Š   â”Š124â”Š    // The canvas will have the same dimensions as the font\n-+â”Š   â”Š125â”Š    canvas.width = width;\n-+â”Š   â”Š126â”Š    canvas.height = height;\n-+â”Š   â”Š127â”Š    // Draw a cropped image from the atlas, this image contains the char font\n-+â”Š   â”Š128â”Š    context.drawImage(this.atlas, x, y, width, height, 0, 0, width, height);\n-+â”Š   â”Š129â”Š\n-+â”Š   â”Š130â”Š    // Store in cache and return it\n-+â”Š   â”Š131â”Š    return this.charSpritesCache[char] = new Engine.Sprite(canvas);\n-+â”Š   â”Š132â”Š  }\n-+â”Š   â”Š133â”Š};ðŸš«â†µ\n-```\n-\n-##### Changed views/game.html\n-```diff\n-@@ -10,6 +10,7 @@\n- â”Š10â”Š10â”Š    <!-- Scripts -->\n- â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n- â”Š12â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/restorable.js\"></script>\n-+â”Š  â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/font.js\"></script>\n- â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/sprite.js\"></script>\n- â”Š14â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/animations/keyframe.js\"></script>\n- â”Š15â”Š16â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/key_states.js\"></script>\n-```\n-[}]: #\n-\n-The font API shares a similar API as [HTMLImageElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/Image), once we set the `src` property the font will start loading itself, and the `onload` user-defined callback should be called once finished. Another neat feature would be the `createTexture` method, which takes a string as its first argument, representing the text that we would like to generate, and returns an instance of the `Sprite` class.\n-\n-We will also be adding the option to load some font assets in our asset-loader:\n-\n-[{]: <helper> (diff_step 4.13)\n-#### Step 4.13: Add a font loading option to 'AssetLoader'\n-\n-##### Changed resources/scripts/engine/assets_loader.js\n-```diff\n-@@ -10,4 +10,12 @@\n- â”Š10â”Š10â”Š    image.src = `${path}.png`;\n- â”Š11â”Š11â”Š    return image;\n- â”Š12â”Š12â”Š  }\n-+â”Š  â”Š13â”Š\n-+â”Š  â”Š14â”Š  // Load font\n-+â”Š  â”Š15â”Š  font(path) {\n-+â”Š  â”Š16â”Š    let font = new Engine.Font();\n-+â”Š  â”Š17â”Š    font.onload = this.next();\n-+â”Š  â”Š18â”Š    font.src = path;\n-+â”Š  â”Š19â”Š    return font;\n-+â”Š  â”Š20â”Š  }\n- â”Š13â”Š21â”Š};ðŸš«â†µ\n-```\n-[}]: #\n-\n-And replace the instructions texture loading with a `minecraftia` font loading in the initial splash screen:\n-\n-[{]: <helper> (diff_step 4.14)\n-#### Step 4.14: Load 'minecraftia' font in splash screen\n-\n-##### Changed resources/scripts/game/screens/splash/index.js\n-```diff\n-@@ -33,7 +33,7 @@\n- â”Š33â”Š33â”Š\n- â”Š34â”Š34â”Š  load(assetsLoader) {\n- â”Š35â”Š35â”Š    // Load assets\n--â”Š36â”Š  â”Š    let instructionsTexture = assetsLoader.texture(\"/textures/instrucitons\");\n-+â”Š  â”Š36â”Š    let minecraftiaFont = assetsLoader.font(\"/fonts/minecraftia\");\n- â”Š37â”Š37â”Š    let logoTexture = assetsLoader.texture(\"/textures/logo\");\n- â”Š38â”Š38â”Š    let splashTexture = assetsLoader.texture(\"/textures/splash\");\n- â”Š39â”Š39â”Š\n-```\n-```diff\n-@@ -41,7 +41,7 @@\n- â”Š41â”Š41â”Š    // disposed. We use the time gap created by the splash animation to load necessary\n- â”Š42â”Š42â”Š    // assets without wasting any time\n- â”Š43â”Š43â”Š    this.game.extendAssets({\n--â”Š44â”Š  â”Š      instructionsTexture,\n-+â”Š  â”Š44â”Š      minecraftiaFont,\n- â”Š45â”Š45â”Š      logoTexture\n- â”Š46â”Š46â”Š    });\n-```\n-[}]: #\n-\n-Now it can use us in the main menu screen where we will create a text-sprite saying `Press a key to start`, just like the instruction sprite we're about to replace:\n-\n-[{]: <helper> (diff_step 4.15)\n-#### Step 4.15: Replace texture usage with font usage in main menu screen\n-\n-##### Changed resources/scripts/game/screens/menu/index.js\n-```diff\n-@@ -5,7 +5,8 @@\n- â”Š 5â”Š 5â”Š    this.logoSprite.setPercentage(\"width\", this.width, 30, \"height\");\n- â”Š 6â”Š 6â”Š\n- â”Š 7â”Š 7â”Š    // Initialize instructions sprite\n--â”Š 8â”Š  â”Š    let instructionsSprite = new Engine.Sprite(this.assets.instructionsTexture);\n-+â”Š  â”Š 8â”Š    let instructionsTexture = this.assets.minecraftiaFont.createTexture(\"Press a key to start\");\n-+â”Š  â”Š 9â”Š    let instructionsSprite = new Engine.Sprite(instructionsTexture);\n- â”Š 9â”Š10â”Š    instructionsSprite.align = \"center\";\n- â”Š10â”Š11â”Š    instructionsSprite.setPercentage(\"width\", this.width, 35, \"height\");\n- â”Š11â”Š12â”Š    instructionsSprite.x = this.width / 2;\n-```\n-```diff\n-@@ -30,7 +31,7 @@\n- â”Š30â”Š31â”Š\n- â”Š31â”Š32â”Š  unload() {\n- â”Š32â”Š33â”Š    // Dispose the following assets to prevent memory leaks\n--â”Š33â”Š  â”Š    return [\"logoTexture\", \"instructionsTexture\"];\n-+â”Š  â”Š34â”Š    return \"logoTexture\";\n- â”Š34â”Š35â”Š  }\n- â”Š35â”Š36â”Š\n- â”Š36â”Š37â”Š  draw(context) {\n-```\n-```diff\n-@@ -41,4 +42,8 @@\n- â”Š41â”Š42â”Š  update(span) {\n- â”Š42â”Š43â”Š    this.instructionsAnim.update(span);\n- â”Š43â”Š44â”Š  }\n-+â”Š  â”Š45â”Š\n-+â”Š  â”Š46â”Š  update(span) {\n-+â”Š  â”Š47â”Š    this.instructionsAnim.update(span);\n-+â”Š  â”Š48â”Š  }\n- â”Š44â”Š49â”Š};ðŸš«â†µ\n-```\n-[}]: #\n-\n-It shouldn't look any different from the beginning of the step where we manually drew the instruction texture, but in the next steps we will be using the font-engine a lot, and you will be thankful for what we've just did.\n-[}]: #\n-[{]: <region> (footer)\n-[{]: <helper> (nav_step)\n-| [< Previous Step](step3.md) | [Next Step >](step5.md) |\n-|:--------------------------------|--------------------------------:|\n-[}]: #\n-[}]: #\n\\ No newline at end of file\ndiff --git a/manuals/views/step5.md b/manuals/views/step5.md\ndeleted file mode 100644\nindex 9d7cac6..0000000\n--- a/manuals/views/step5.md\n+++ /dev/null\n@@ -1,1329 +0,0 @@\n-[{]: <region> (header)\n-# Step 5: Creating a snake and related geometry shapes\n-[}]: #\n-[{]: <region> (body)\n-![snake-illustrate](https://cloud.githubusercontent.com/assets/7648874/21074115/46ef4466-bed7-11e6-9d5d-12fa6d43147b.gif)\n-\n-In this step we will be creating all the necessary geometry shapes to form a snake; we're basically implementing the right infrastructure so in the next step we will be able to implement the game screen with ease. What exactly do I mean by \"geometry shapes\"? Well, our snake will be made out of circles, and lines. If we don't press any buttons at all, the snake should move forward at a straight line, and once we press on one of the arrow keys, the snake should move in a circular motion. Not only we want to draw the screen on the canvas, we also want to be able to detect collision with other snakes, since this is a \"Tron\" style game where we gonna fight against an opponent.\n-\n-Keep in mind that a computer's precision is limited due its [binary representation in memory](https://en.wikipedia.org/wiki/Memory_cell_(binary)). We need to take into consideration that there might be a significant deviation when detecting collisions and intersections between geometry shapes, especially when elapsed time is not always guaranteed to stay precise. To handle these deviation issues, we're gonna create some utility functions and place then in a new module called `Utils`:\n-\n-[{]: <helper> (diff_step 5.1)\n-#### Step 5.1: Create utilities module\n-\n-##### Added resources/scripts/utils.js\n-```diff\n-@@ -0,0 +1,68 @@\n-+â”Š  â”Š 1â”Š// A wrapper function for our utilities which will enable chaining\n-+â”Š  â”Š 2â”Š// e.g. Utils().mod().trim().isBetween()...\n-+â”Š  â”Š 3â”ŠUtils = function Utils(context) {\n-+â”Š  â”Š 4â”Š  const chain = {};\n-+â”Š  â”Š 5â”Š\n-+â”Š  â”Š 6â”Š  Object.keys(Utils).forEach((utilName) => {\n-+â”Š  â”Š 7â”Š    chain[utilName] = (...args) => {\n-+â”Š  â”Š 8â”Š      const result = Utils[utilName](context, ...args);\n-+â”Š  â”Š 9â”Š      return Utils(result);\n-+â”Š  â”Š10â”Š    };\n-+â”Š  â”Š11â”Š  });\n-+â”Š  â”Š12â”Š\n-+â”Š  â”Š13â”Š  // Returns the result of the chaining\n-+â”Š  â”Š14â”Š  chain.value = () => context;\n-+â”Š  â”Š15â”Š\n-+â”Š  â”Š16â”Š  return chain;\n-+â”Š  â”Š17â”Š};\n-+â”Š  â”Š18â”Š\n-+â”Š  â”Š19â”Š// Fixed modulo method which can calculate modulo of negative numbers properly\n-+â”Š  â”Š20â”Š// e.g. (-803).mod(800) returns 797\n-+â”Š  â”Š21â”ŠUtils.mod = function (context, num) {\n-+â”Š  â”Š22â”Š  return ((context % num) + num) % num;\n-+â”Š  â”Š23â”Š};\n-+â”Š  â”Š24â”Š\n-+â”Š  â”Š25â”Š// Trims number and leaves the number of decimals specified.\n-+â”Š  â”Š26â”Š// The \"mode\" argument specifies which math function should be invoked\n-+â”Š  â”Š27â”Š// right after the number has been trimmed.\n-+â”Š  â”Š28â”Š// e.g. 12.12345.trim(3, \"ceil\") returns 12.124\n-+â”Š  â”Š29â”ŠUtils.trim = function (context, decimals, mode = \"round\") {\n-+â”Š  â”Š30â”Š  return Math[mode](context * Math.pow(10, decimals)) / Math.pow(10, decimals);\n-+â”Š  â”Š31â”Š};\n-+â”Š  â”Š32â”Š\n-+â”Š  â”Š33â”Š// Tells if number is in specified range based on given precision.\n-+â”Š  â”Š34â”Š// See the \"compare\" method for more information about precision\n-+â”Š  â”Š35â”ŠUtils.isBetween = function (context, num1, num2, precision) {\n-+â”Š  â”Š36â”Š  return Utils.compare(context, Math.min(num1, num2), \">=\", precision) &&\n-+â”Š  â”Š37â”Š         Utils.compare(context, Math.max(num1, num2), \"<=\", precision);\n-+â”Š  â”Š38â”Š};\n-+â”Š  â”Š39â”Š\n-+â”Š  â”Š40â”Š// Initiates comparison operator between context number and a given number, only here\n-+â”Š  â”Š41â”Š// a precision can be specified\n-+â”Š  â”Š42â”ŠUtils.compare = function (context, num, method, precision = method) {\n-+â”Š  â”Š43â”Š  switch (precision) {\n-+â”Š  â”Š44â”Š    // Fixed precision, \"almost equal\" with a deviation of Îµ\n-+â”Š  â”Š45â”Š    case \"f\":\n-+â”Š  â”Š46â”Š      switch (method) {\n-+â”Š  â”Š47â”Š        case \"<\": case \"<=\": return context <= num + Number.EPSILON;\n-+â”Š  â”Š48â”Š        case \">\": case \">=\": return context >= num - Number.EPSILON;\n-+â”Š  â”Š49â”Š        default: return Math.abs(context - num) <= Number.EPSILON;\n-+â”Š  â”Š50â”Š      }\n-+â”Š  â”Š51â”Š    // Pixel precision, round comparison\n-+â”Š  â”Š52â”Š    case \"px\":\n-+â”Š  â”Š53â”Š      switch (method) {\n-+â”Š  â”Š54â”Š        case \"<\": case \"<=\": return Math.round(context) <= Math.round(num);\n-+â”Š  â”Š55â”Š        case \">\": case \">=\": return Math.round(context) >= Math.round(num);\n-+â”Š  â”Š56â”Š        default: return Math.round(context) == Math.round(num);\n-+â”Š  â”Š57â”Š      }\n-+â”Š  â”Š58â”Š    // Exact precision\n-+â”Š  â”Š59â”Š    default:\n-+â”Š  â”Š60â”Š      switch (method) {\n-+â”Š  â”Š61â”Š        case \"<\": return context < num;\n-+â”Š  â”Š62â”Š        case \"<=\": return context <= num;\n-+â”Š  â”Š63â”Š        case \">\": return context > num;\n-+â”Š  â”Š64â”Š        case \">=\": return context >= num;\n-+â”Š  â”Š65â”Š        default: return context === num;\n-+â”Š  â”Š66â”Š      }\n-+â”Š  â”Š67â”Š  }\n-+â”Š  â”Š68â”Š};ðŸš«â†µ\n-```\n-\n-##### Changed views/game.html\n-```diff\n-@@ -8,6 +8,7 @@\n- â”Š 8â”Š 8â”Š    <script type=\"text/javascript\" src=\"/libs/underscore.js\"></script>\n- â”Š 9â”Š 9â”Š\n- â”Š10â”Š10â”Š    <!-- Scripts -->\n-+â”Š  â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/utils.js\"></script>\n- â”Š11â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n- â”Š12â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/restorable.js\"></script>\n- â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/font.js\"></script>\n-```\n-[}]: #\n-\n-Now we would like to start implementing the first class representation for a line, and for that we're requires to add a new module called `Geometry` to the `Engine` namespace:\n-\n-[{]: <helper> (diff_step 5.2)\n-#### Step 5.2: Add 'Shapes' module to 'Engine' namespace\n-\n-##### Changed resources/scripts/namespaces.js\n-```diff\n-@@ -3,5 +3,6 @@\n- â”Š3â”Š3â”Š};\n- â”Š4â”Š4â”Š\n- â”Š5â”Š5â”ŠEngine = {\n--â”Š6â”Š â”Š  Animations: {}\n-+â”Š â”Š6â”Š  Animations: {},\n-+â”Š â”Š7â”Š  Geometry: {}\n- â”Š7â”Š8â”Š};ðŸš«â†µ\n-```\n-[}]: #\n-\n-And now that we have this module available to use, we can go ahead and implement our first geometry shape class - `Line`:\n-\n-[{]: <helper> (diff_step 5.3)\n-#### Step 5.3: Create 'Line' class\n-\n-##### Added resources/scripts/engine/geometry/line.js\n-```diff\n-@@ -0,0 +1,65 @@\n-+â”Š  â”Š 1â”ŠEngine.Geometry.Line = class Line {\n-+â”Š  â”Š 2â”Š  // x1 - The first point's x value\n-+â”Š  â”Š 3â”Š  // y1 - The first point's y value\n-+â”Š  â”Š 4â”Š  // x1 - The second point's x value\n-+â”Š  â”Š 5â”Š  // y2 - The second point's y value\n-+â”Š  â”Š 6â”Š  constructor(x1, y1, x2, y2) {\n-+â”Š  â”Š 7â”Š    this.x1 = Utils.trim(x1, 9);\n-+â”Š  â”Š 8â”Š    this.y1 = Utils.trim(y1, 9);\n-+â”Š  â”Š 9â”Š    this.x2 = Utils.trim(x2, 9);\n-+â”Š  â”Š10â”Š    this.y2 = Utils.trim(y2, 9);\n-+â”Š  â”Š11â”Š  }\n-+â”Š  â”Š12â”Š\n-+â”Š  â”Š13â”Š  // Draws the line on the given context\n-+â”Š  â”Š14â”Š  draw(context) {\n-+â”Š  â”Š15â”Š    context.moveTo(this.x1, this.y1);\n-+â”Š  â”Š16â”Š    context.lineTo(this.x2, this.y2);\n-+â”Š  â”Š17â”Š  }\n-+â”Š  â”Š18â”Š\n-+â”Š  â”Š19â”Š  // Gets the matching x value for a given y value\n-+â”Š  â”Š20â”Š  getX(y) {\n-+â”Š  â”Š21â”Š    let x = Utils.trim((((y - this.y1) * (this.x2 - this.x1)) / (this.y2 - this.y1)) + this.x1, 9);\n-+â”Š  â”Š22â”Š    if (isNaN(x) || Utils.isBetween(x, this.x1, this.x2)) return x;\n-+â”Š  â”Š23â”Š  }\n-+â”Š  â”Š24â”Š\n-+â”Š  â”Š25â”Š  // Gets the matching y value for a given x value\n-+â”Š  â”Š26â”Š  getY(x) {\n-+â”Š  â”Š27â”Š    let y = Utils.trim((((x - this.x1) * (this.y2 - this.y1)) / (this.x2 - this.x1)) + this.y1, 9);\n-+â”Š  â”Š28â”Š    if (isNaN(y) || Utils.isBetween(y, this.y1, this.y2)) return y;\n-+â”Š  â”Š29â”Š  }\n-+â”Š  â”Š30â”Š\n-+â”Š  â”Š31â”Š  // Returns if line has given point\n-+â”Š  â”Š32â”Š  hasPoint(x, y) {\n-+â”Š  â”Š33â”Š    if (!this.boundsHavePoint(x, y)) return false;\n-+â”Š  â”Š34â”Š    let m = Utils.trim((this.y2 - this.y1) / (this.x2 - this.x1), 9);\n-+â”Š  â”Š35â”Š    return (y - this.y1) / (x - this.x1) == m;\n-+â”Š  â”Š36â”Š  }\n-+â”Š  â”Š37â”Š\n-+â”Š  â”Š38â”Š  // Returns if given point is contained by the bounds aka cage of line\n-+â”Š  â”Š39â”Š  boundsHavePoint(x, y) {\n-+â”Š  â”Š40â”Š    return Utils.isBetween(x, this.x1, this.x2) &&\n-+â”Š  â”Š41â”Š           Utils.isBetween(y, this.y1, this.y2);\n-+â”Š  â”Š42â”Š  }\n-+â”Š  â”Š43â”Š\n-+â”Š  â”Š44â”Š  getIntersection(shape) {\n-+â”Š  â”Š45â”Š    if (shape instanceof Engine.Geometry.Line)\n-+â”Š  â”Š46â”Š      return this.getLineIntersection(shape);\n-+â”Š  â”Š47â”Š  }\n-+â”Š  â”Š48â”Š\n-+â”Š  â”Š49â”Š  // line - line intersection method\n-+â”Š  â”Š50â”Š  getLineIntersection(line) {\n-+â”Š  â”Š51â”Š    // Escape if lines are parallel\n-+â”Š  â”Š52â”Š    if (!(((this.x1 - this.x2) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * (line.x1 - line.x2)))) return;\n-+â”Š  â”Š53â”Š\n-+â”Š  â”Š54â”Š    // Intersection point formula\n-+â”Š  â”Š55â”Š    let x = Utils.trim(((((this.x1 * this.y2) - (this.y1 * this.x2)) * (line.x1 - line.x2)) - ((this.x1 - this.x2) * ((line.x1 * line.y2) - (line.y1 * line.x2)))) /\n-+â”Š  â”Š56â”Š        (((this.x1 - this.x2) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * (line.x1 - line.x2))), 9);\n-+â”Š  â”Š57â”Š    let y = Utils.trim(((((this.x1 * this.y2) - (this.y1 * this.x2)) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * ((line.x1 * line.y2) - (line.y1 * line.x2)))) /\n-+â”Š  â”Š58â”Š        (((this.x1 - this.x2) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * (line.x1 - line.x2))), 9);\n-+â”Š  â”Š59â”Š\n-+â”Š  â”Š60â”Š    if (Utils.isBetween(x, this.x1, this.x2) && Utils.isBetween(x, line.x1, line.x2) &&\n-+â”Š  â”Š61â”Š        Utils.isBetween(y, this.y1, this.y2) && Utils.isBetween(y, line.y1, line.y2)) {\n-+â”Š  â”Š62â”Š      return { x, y };\n-+â”Š  â”Š63â”Š    }\n-+â”Š  â”Š64â”Š  }\n-+â”Š  â”Š65â”Š};ðŸš«â†µ\n-```\n-\n-##### Changed views/game.html\n-```diff\n-@@ -10,6 +10,7 @@\n- â”Š10â”Š10â”Š    <!-- Scripts -->\n- â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/utils.js\"></script>\n- â”Š12â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n-+â”Š  â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/geometry/line.js\"></script>\n- â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/restorable.js\"></script>\n- â”Š14â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/font.js\"></script>\n- â”Š15â”Š16â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/sprite.js\"></script>\n-```\n-[}]: #\n-\n-You can go through the comments of the step above which will guide you through the programmatic aspect of it, but I think it's more important to understand the concept of a line in 2D space. A line is made out of two points, usually represented as `(x1, y1)` and `(x2, y2)`. The slope of the line, usually represented as `m`, can be determined using these two points based on the following formula:\n-\n-![slope](https://cloud.githubusercontent.com/assets/7648874/21788249/b4c7e41c-d6b4-11e6-9c17-baff66ec6bc8.png)\n-\n-Once we have two lines whose `m` is different (Unparalleled) and there is no intersection between the points of which they are represented with (In which case they are united), there must be an intersection point. The intersection point can be found using the following formula:\n-\n-![line-line](https://cloud.githubusercontent.com/assets/7648874/21787164/c9d83bf0-d6ae-11e6-9846-4fc013eebab3.png)\n-\n-![line-line-illustration](https://cloud.githubusercontent.com/assets/7648874/21790864/56725cf0-d6c6-11e6-916b-50b1fc0b87af.png)\n-\n-> See reference: http://mathworld.wolfram.com/Line-LineIntersection.html.\n-\n-Obviously we have some logic here which needs to be tested. To test our `Line` class, we will be using a testing framework called [Jasmine](https://jasmine.github.io/). We first need to download `Jasmine`'s essentials in order for it to work:\n-\n-    resources/libs$ mkdir jasmine\n-    resources/libs$ cd jasmine\n-    resources/libs/jasmine$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/libs/jasmine/boot.js\n-    resources/libs/jasmine$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/libs/jasmine/console.js\n-    resources/libs/jasmine$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/libs/jasmine/jasmine-html.js\n-    resources/libs/jasmine$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/libs/jasmine/jasmine.css\n-    resources/libs/jasmine$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/libs/jasmine/jasmine.js\n-    resources/libs/jasmine$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/libs/jasmine/jasmine_favicon.png\n-\n-These essentials should be loaded in a newly created view where we're gonna see our specs running:\n-\n-[{]: <helper> (diff_step 5.5)\n-#### Step 5.5: Create specs runner view\n-\n-##### Added views/spec_runner.html\n-```diff\n-@@ -0,0 +1,27 @@\n-+â”Š  â”Š 1â”Š\n-+â”Š  â”Š 2â”Š<!DOCTYPE html>\n-+â”Š  â”Š 3â”Š<html>\n-+â”Š  â”Š 4â”Š  <head>\n-+â”Š  â”Š 5â”Š    <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n-+â”Š  â”Š 6â”Š    <title>Jasmine Spec Runner v2.0.1</title>\n-+â”Š  â”Š 7â”Š\n-+â”Š  â”Š 8â”Š    <!-- Jasmine -->\n-+â”Š  â”Š 9â”Š    <script type=\"text/javascript\" src=\"libs/jasmine/jasmine.js\"></script>\n-+â”Š  â”Š10â”Š    <script type=\"text/javascript\" src=\"libs/jasmine/jasmine-html.js\"></script>\n-+â”Š  â”Š11â”Š    <script type=\"text/javascript\" src=\"libs/jasmine/boot.js\"></script>\n-+â”Š  â”Š12â”Š    <link rel=\"shortcut icon\" type=\"image/png\" href=\"libs/jasmine/jasmine_favicon.png\">\n-+â”Š  â”Š13â”Š    <link rel=\"stylesheet\" type=\"text/css\" href=\"libs/jasmine/jasmine.css\">\n-+â”Š  â”Š14â”Š\n-+â”Š  â”Š15â”Š    <!-- Libs -->\n-+â”Š  â”Š16â”Š    <script type=\"text/javascript\" src=\"libs/underscore.js\"></script>\n-+â”Š  â”Š17â”Š\n-+â”Š  â”Š18â”Š    <!-- Scripts -->\n-+â”Š  â”Š19â”Š    <script type=\"text/javascript\" src=\"scripts/utils.js\"></script>\n-+â”Š  â”Š20â”Š    <script type=\"text/javascript\" src=\"scripts/namespaces.js\"></script>\n-+â”Š  â”Š21â”Š\n-+â”Š  â”Š22â”Š    <!-- Specs -->\n-+â”Š  â”Š23â”Š  </head>\n-+â”Š  â”Š24â”Š\n-+â”Š  â”Š25â”Š  <body>\n-+â”Š  â”Š26â”Š  </body>\n-+â”Š  â”Š27â”Š</html>ðŸš«â†µ\n-```\n-[}]: #\n-\n-Now once we'll navigate to the `/test` sub-route (`localhost:8000/test` by default) we should be provided with the spec runner. As for now there are no specs implemented at all, which brings us to the next stage - Implementing tests for `Line` class:\n-\n-[{]: <helper> (diff_step 5.6)\n-#### Step 5.6: Create 'Line' class tests\n-\n-##### Added resources/scripts/specs/engine/geometry/line.js\n-```diff\n-@@ -0,0 +1,78 @@\n-+â”Š  â”Š 1â”Šdescribe(\"Engine.Geometry.Line class\", function() {\n-+â”Š  â”Š 2â”Š  beforeEach(function() {\n-+â”Š  â”Š 3â”Š    this.line = new Engine.Geometry.Line(-5, -5, 5, 5);\n-+â”Š  â”Š 4â”Š  });\n-+â”Š  â”Š 5â”Š\n-+â”Š  â”Š 6â”Š  describe(\"getX method\", function() {\n-+â”Š  â”Š 7â”Š    describe(\"given inranged y\", function() {\n-+â”Š  â”Š 8â”Š      it(\"returns x\", function() {\n-+â”Š  â”Š 9â”Š        expect(this.line.getX(1)).toBeCloseTo(1);\n-+â”Š  â”Š10â”Š      });\n-+â”Š  â”Š11â”Š    });\n-+â”Š  â”Š12â”Š\n-+â”Š  â”Š13â”Š    describe(\"given outranged y\", function() {\n-+â”Š  â”Š14â”Š      it(\"returns nothing\", function() {\n-+â”Š  â”Š15â”Š        expect(this.line.getX(10)).toBeUndefined();\n-+â”Š  â”Š16â”Š      });\n-+â”Š  â”Š17â”Š    });\n-+â”Š  â”Š18â”Š  });\n-+â”Š  â”Š19â”Š\n-+â”Š  â”Š20â”Š  describe(\"getY method\", function() {\n-+â”Š  â”Š21â”Š    describe(\"given inranged x\", function() {\n-+â”Š  â”Š22â”Š      it(\"returns y\", function() {\n-+â”Š  â”Š23â”Š        expect(this.line.getY(1)).toBeCloseTo(1);\n-+â”Š  â”Š24â”Š      });\n-+â”Š  â”Š25â”Š    });\n-+â”Š  â”Š26â”Š\n-+â”Š  â”Š27â”Š    describe(\"given outranged x\", function() {\n-+â”Š  â”Š28â”Š      it(\"returns nothing\", function() {\n-+â”Š  â”Š29â”Š        expect(this.line.getY(10)).toBeUndefined();\n-+â”Š  â”Š30â”Š      });\n-+â”Š  â”Š31â”Š    });\n-+â”Š  â”Š32â”Š  });\n-+â”Š  â”Š33â”Š\n-+â”Š  â”Š34â”Š  describe(\"hasPoint method\", function() {\n-+â”Š  â”Š35â”Š    describe(\"given contained point\", function() {\n-+â”Š  â”Š36â”Š      it(\"returns true\", function() {\n-+â”Š  â”Š37â”Š        let x = 1;\n-+â”Š  â”Š38â”Š        let y = 1;\n-+â”Š  â”Š39â”Š        expect(this.line.hasPoint(x, y)).toBeTruthy();\n-+â”Š  â”Š40â”Š      });\n-+â”Š  â”Š41â”Š    });\n-+â”Š  â”Š42â”Š\n-+â”Š  â”Š43â”Š    describe(\"given uncontained point\", function() {\n-+â”Š  â”Š44â”Š      it(\"returns false\", function() {\n-+â”Š  â”Š45â”Š        let x = 10;\n-+â”Š  â”Š46â”Š        let y = 10;\n-+â”Š  â”Š47â”Š        expect(this.line.hasPoint(x, y)).toBeFalsy();\n-+â”Š  â”Š48â”Š      });\n-+â”Š  â”Š49â”Š    });\n-+â”Š  â”Š50â”Š  });\n-+â”Š  â”Š51â”Š\n-+â”Š  â”Š52â”Š  describe(\"getLineIntersection method\", function() {\n-+â”Š  â”Š53â”Š    describe(\"given intersecting line\", function() {\n-+â”Š  â”Š54â”Š      it(\"returns intersection point\", function() {\n-+â”Š  â”Š55â”Š        let line = new Engine.Geometry.Line(1, -5, 1, 5);\n-+â”Š  â”Š56â”Š\n-+â”Š  â”Š57â”Š        expect(this.line.getLineIntersection(line)).toEqual({\n-+â”Š  â”Š58â”Š          x: 1,\n-+â”Š  â”Š59â”Š          y: 1\n-+â”Š  â”Š60â”Š        });\n-+â”Š  â”Š61â”Š      });\n-+â”Š  â”Š62â”Š    });\n-+â”Š  â”Š63â”Š\n-+â”Š  â”Š64â”Š    describe(\"given parallel line\", function() {\n-+â”Š  â”Š65â”Š      it(\"returns nothing\", function() {\n-+â”Š  â”Š66â”Š        let line = new Engine.Geometry.Line(-5, -6, 5, 4);\n-+â”Š  â”Š67â”Š        expect(this.line.getLineIntersection(line)).toBeUndefined();\n-+â”Š  â”Š68â”Š      });\n-+â”Š  â”Š69â”Š    });\n-+â”Š  â”Š70â”Š\n-+â”Š  â”Š71â”Š    describe(\"given outranged line\", function() {\n-+â”Š  â”Š72â”Š      it(\"returns nothing\", function() {\n-+â”Š  â”Š73â”Š        let line = new Engine.Geometry.Line(10, 10, 10, 15);\n-+â”Š  â”Š74â”Š        expect(this.line.getLineIntersection(line)).toBeUndefined();\n-+â”Š  â”Š75â”Š      });\n-+â”Š  â”Š76â”Š    });\n-+â”Š  â”Š77â”Š  });\n-+â”Š  â”Š78â”Š});ðŸš«â†µ\n-```\n-\n-##### Changed views/spec_runner.html\n-```diff\n-@@ -18,8 +18,10 @@\n- â”Š18â”Š18â”Š    <!-- Scripts -->\n- â”Š19â”Š19â”Š    <script type=\"text/javascript\" src=\"scripts/utils.js\"></script>\n- â”Š20â”Š20â”Š    <script type=\"text/javascript\" src=\"scripts/namespaces.js\"></script>\n-+â”Š  â”Š21â”Š    <script type=\"text/javascript\" src=\"scripts/engine/geometry/line.js\"></script>\n- â”Š21â”Š22â”Š\n- â”Š22â”Š23â”Š    <!-- Specs -->\n-+â”Š  â”Š24â”Š    <script type=\"text/javascript\" src=\"scripts/specs/engine/geometry/line.js\"></script>\n- â”Š23â”Š25â”Š  </head>\n- â”Š24â”Š26â”Š\n- â”Š25â”Š27â”Š  <body>\n-```\n-[}]: #\n-\n-Now if you'll refresh the spec runner page you should be able to a green screen indicating all tests have passed (Assuming the tutorial is updated and you followed it correctly). As introduced at the beginning of the step, the snake is also dependent on circles, whose representing class should look like so:\n-\n-[{]: <helper> (diff_step 5.7)\n-#### Step 5.7: Create 'Circle' class\n-\n-##### Added resources/scripts/engine/geometry/circle.js\n-```diff\n-@@ -0,0 +1,167 @@\n-+â”Š   â”Š  1â”ŠEngine.Geometry.Circle = class Circle {\n-+â”Š   â”Š  2â”Š  // x - The x value of the circle's center\n-+â”Š   â”Š  3â”Š  // y - The y value of the circle's center\n-+â”Š   â”Š  4â”Š  // r - The radius of the center\n-+â”Š   â”Š  5â”Š  // rad1 - The first radian of the circle, not necessarily its beginning\n-+â”Š   â”Š  6â”Š  // rad2 - The second radian of the circle, not necessarily its beginning\n-+â”Š   â”Š  7â”Š  constructor(x, y, r, rad1, rad2) {\n-+â”Š   â”Š  8â”Š    this.x = Utils.trim(x, 9);\n-+â”Š   â”Š  9â”Š    this.y = Utils.trim(y, 9);\n-+â”Š   â”Š 10â”Š    this.r = Utils.trim(r, 9);\n-+â”Š   â”Š 11â”Š\n-+â”Š   â”Š 12â”Š    // Trimming mode is done based on which radian represents the ending and which radian\n-+â”Š   â”Š 13â”Š    // represents the ending\n-+â”Š   â”Š 14â”Š    if (rad1 > rad2) {\n-+â”Š   â”Š 15â”Š      this.rad1 = Utils.trim(rad1, 9, \"floor\");\n-+â”Š   â”Š 16â”Š      this.rad2 = Utils.trim(rad2, 9, \"ceil\");\n-+â”Š   â”Š 17â”Š    }\n-+â”Š   â”Š 18â”Š    else {\n-+â”Š   â”Š 19â”Š      this.rad1 = Utils.trim(rad1, 9, \"ceil\");\n-+â”Š   â”Š 20â”Š      this.rad2 = Utils.trim(rad2, 9, \"floor\");\n-+â”Š   â”Š 21â”Š    }\n-+â”Š   â”Š 22â”Š  }\n-+â”Š   â”Š 23â”Š\n-+â”Š   â”Š 24â”Š  // Draws the circle on the given context\n-+â”Š   â”Š 25â”Š  draw(context) {\n-+â”Š   â”Š 26â”Š    context.arc(this.x, this.y, this.r, this.rad1, this.rad2);\n-+â”Š   â”Š 27â”Š  }\n-+â”Š   â”Š 28â”Š\n-+â”Š   â”Š 29â”Š  // Gets the matching x value for the given radian\n-+â”Š   â”Š 30â”Š  getX(rad) {\n-+â”Š   â”Š 31â”Š    if (!Utils(rad).trim(9).isBetween(this.rad1, this.rad2).value()) return;\n-+â”Š   â”Š 32â”Š    return Utils.trim((this.r * Math.cos(rad)) + this.x, 9);\n-+â”Š   â”Š 33â”Š  }\n-+â”Š   â”Š 34â”Š\n-+â”Š   â”Š 35â”Š  // Gets the matching y value for the given radian\n-+â”Š   â”Š 36â”Š  getY(rad) {\n-+â”Š   â”Š 37â”Š    if (!Utils(rad).trim(9).isBetween(this.rad1, this.rad2).value()) return;\n-+â”Š   â”Š 38â”Š    return Utils.trim((this.r * Math.sin(rad)) + this.y, 9);\n-+â”Š   â”Š 39â”Š  }\n-+â”Š   â”Š 40â”Š\n-+â”Š   â”Š 41â”Š  // Gets the matching point for the given radian\n-+â”Š   â”Š 42â”Š  getPoint(rad) {\n-+â”Š   â”Š 43â”Š    if (!Utils.isBetween(rad, this.rad1, this.rad2)) return;\n-+â”Š   â”Š 44â”Š\n-+â”Š   â”Š 45â”Š    return {\n-+â”Š   â”Š 46â”Š      x: Utils.trim((this.r * Math.cos(rad)) + this.x, 9),\n-+â”Š   â”Š 47â”Š      y: Utils.trim((this.r * Math.sin(rad)) + this.y, 9)\n-+â”Š   â”Š 48â”Š    };\n-+â”Š   â”Š 49â”Š  }\n-+â”Š   â”Š 50â”Š\n-+â”Š   â”Š 51â”Š  // Gets the matching radian for the given point\n-+â”Š   â”Š 52â”Š  getRad(x, y) {\n-+â”Š   â”Š 53â”Š    let rad = Math.atan2(y - this.y, x - this.x);\n-+â”Š   â”Š 54â”Š\n-+â”Š   â”Š 55â”Š    // If calculated radian is in circle's radian range, return it\n-+â”Š   â”Š 56â”Š    if (rad != null && Utils.isBetween(rad, this.rad1, this.rad2)) {\n-+â”Š   â”Š 57â”Š      return rad;\n-+â”Š   â”Š 58â”Š    }\n-+â”Š   â”Š 59â”Š\n-+â”Š   â”Š 60â”Š    // The calculated radian can still be in the circle's radian range in case one\n-+â”Š   â”Š 61â”Š    // of the radians is greater than 2 PIEs\n-+â”Š   â”Š 62â”Š    if (Math.abs(this.rad1) > Math.abs(this.rad2)) {\n-+â”Š   â”Š 63â”Š      var greatestRad = this.rad1;\n-+â”Š   â”Š 64â”Š    }\n-+â”Š   â”Š 65â”Š    else {\n-+â”Š   â”Š 66â”Š      var greatestRad = this.rad2;\n-+â”Š   â”Š 67â”Š    }\n-+â”Š   â”Š 68â”Š\n-+â”Š   â”Š 69â”Š    // Check if the absolute radian is in the circle's radian range\n-+â”Š   â”Š 70â”Š    if (Utils(rad + (2 * Math.PI * Math.floor(greatestRad / (2 * Math.PI)))).trim(9).isBetween(this.rad1, this.rad2).value() ||\n-+â”Š   â”Š 71â”Š        Utils(rad + (2 * Math.PI * Math.ceil(greatestRad / (2 * Math.PI)))).trim(9).isBetween(this.rad1, this.rad2).value()) {\n-+â”Š   â”Š 72â”Š      return rad;\n-+â”Š   â”Š 73â”Š    }\n-+â”Š   â”Š 74â”Š  }\n-+â”Š   â”Š 75â”Š\n-+â”Š   â”Š 76â”Š  // Returns if circle has given points\n-+â”Š   â”Š 77â”Š  hasPoint(x, y) {\n-+â”Š   â”Š 78â”Š    return this.getRad(x, y) != null;\n-+â”Š   â”Š 79â”Š  }\n-+â”Š   â”Š 80â”Š\n-+â”Š   â”Š 81â”Š  getIntersection(shape) {\n-+â”Š   â”Š 82â”Š    if (shape instanceof Engine.Geometry.Line)\n-+â”Š   â”Š 83â”Š      return this.getLineIntersection(shape);\n-+â”Š   â”Š 84â”Š    if (shape instanceof Engine.Geometry.Circle)\n-+â”Š   â”Š 85â”Š      return this.getCircleIntersection(shape);\n-+â”Š   â”Š 86â”Š  }\n-+â”Š   â”Š 87â”Š\n-+â”Š   â”Š 88â”Š  // circle - circle intersection method\n-+â”Š   â”Š 89â”Š  getCircleIntersection(circle) {\n-+â”Š   â”Š 90â”Š    let dx = circle.x - this.x;\n-+â”Š   â”Š 91â”Š    let dy = circle.y - this.y;\n-+â”Š   â”Š 92â”Š    let d = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\n-+â”Š   â”Š 93â”Š\n-+â”Š   â”Š 94â”Š    if (d > this.r + circle.r ||\n-+â”Š   â”Š 95â”Š       d < Math.abs(this.r - circle.r)) {\n-+â”Š   â”Š 96â”Š      return;\n-+â”Š   â”Š 97â”Š    }\n-+â”Š   â”Š 98â”Š\n-+â”Š   â”Š 99â”Š    let a = ((Math.pow(this.r, 2) - Math.pow(circle.r, 2)) + Math.pow(d, 2)) / (2 * d);\n-+â”Š   â”Š100â”Š    let x = this.x + ((dx * a) / d);\n-+â”Š   â”Š101â”Š    let y = this.y + ((dy * a) / d);\n-+â”Š   â”Š102â”Š    let h = Math.sqrt(Math.pow(this.r, 2) - Math.pow(a, 2));\n-+â”Š   â”Š103â”Š    let rx = (- dy * h) / d;\n-+â”Š   â”Š104â”Š    let ry = (dx * h) / d;\n-+â”Š   â”Š105â”Š\n-+â”Š   â”Š106â”Š    let interPoints = [\n-+â”Š   â”Š107â”Š      {\n-+â”Š   â”Š108â”Š        x: x + rx,\n-+â”Š   â”Š109â”Š        y: y + ry\n-+â”Š   â”Š110â”Š      },\n-+â”Š   â”Š111â”Š      {\n-+â”Š   â”Š112â”Š        x: x - rx,\n-+â”Š   â”Š113â”Š        y: y - ry\n-+â”Š   â”Š114â”Š      }\n-+â”Š   â”Š115â”Š    ]\n-+â”Š   â”Š116â”Š    .map(point => ({\n-+â”Š   â”Š117â”Š        x: Utils.trim(point.x, 9),\n-+â”Š   â”Š118â”Š        y: Utils.trim(point.y, 9)\n-+â”Š   â”Š119â”Š     }));\n-+â”Š   â”Š120â”Š\n-+â”Š   â”Š121â”Š    interPoints = _.uniq(interPoints, point => `(${point.x}, ${point.y})`);\n-+â”Š   â”Š122â”Š\n-+â”Š   â”Š123â”Š    [this, circle].forEach(function(circle) {\n-+â”Š   â”Š124â”Š      interPoints = interPoints.filter(point => circle.hasPoint(point.x, point.y));\n-+â”Š   â”Š125â”Š    });\n-+â”Š   â”Š126â”Š\n-+â”Š   â”Š127â”Š    if (interPoints.length > 0) return interPoints;\n-+â”Š   â”Š128â”Š  }\n-+â”Š   â”Š129â”Š\n-+â”Š   â”Š130â”Š  // circle - line intersection method\n-+â”Š   â”Š131â”Š  getLineIntersection(line) {\n-+â”Š   â”Š132â”Š    let x1 = line.x1 - this.x;\n-+â”Š   â”Š133â”Š    let x2 = line.x2 - this.x;\n-+â”Š   â”Š134â”Š    let y1 = line.y1 - this.y;\n-+â”Š   â”Š135â”Š    let y2 = line.y2 - this.y;\n-+â”Š   â”Š136â”Š    let dx = x2 - x1;\n-+â”Š   â”Š137â”Š    let dy = y2 - y1;\n-+â”Š   â”Š138â”Š    let d = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\n-+â”Š   â”Š139â”Š    let h = (x1 * y2) - (x2 * y1);\n-+â”Š   â”Š140â”Š    let delta = (Math.pow(this.r, 2) * Math.pow(d, 2)) - Math.pow(h, 2);\n-+â”Š   â”Š141â”Š\n-+â”Š   â”Š142â”Š    if (delta < 0) return;\n-+â”Š   â”Š143â”Š\n-+â”Š   â”Š144â”Š    let interPoints = [\n-+â”Š   â”Š145â”Š      {\n-+â”Š   â”Š146â”Š        x: (((h * dy) + (((dy / Math.abs(dy)) || 1) * dx * Math.sqrt(delta))) / Math.pow(d, 2)) + this.x,\n-+â”Š   â”Š147â”Š        y: (((-h * dx) + (Math.abs(dy) * Math.sqrt(delta))) / Math.pow(d, 2)) + this.y\n-+â”Š   â”Š148â”Š      },\n-+â”Š   â”Š149â”Š      {\n-+â”Š   â”Š150â”Š        x: (((h * dy) - (((dy / Math.abs(dy)) || 1) * dx * Math.sqrt(delta))) / Math.pow(d, 2)) + this.x,\n-+â”Š   â”Š151â”Š        y: (((-h * dx) - (Math.abs(dy) * Math.sqrt(delta))) / Math.pow(d, 2)) + this.y\n-+â”Š   â”Š152â”Š      }\n-+â”Š   â”Š153â”Š    ]\n-+â”Š   â”Š154â”Š    .map(point => ({\n-+â”Š   â”Š155â”Š        x: Utils.trim(point.x, 9),\n-+â”Š   â”Š156â”Š        y: Utils.trim(point.y, 9)\n-+â”Š   â”Š157â”Š    }))\n-+â”Š   â”Š158â”Š    .filter(point => {\n-+â”Š   â”Š159â”Š      return this.hasPoint(point.x, point.y) &&\n-+â”Š   â”Š160â”Š        line.boundsHavePoint(point.x, point.y);\n-+â”Š   â”Š161â”Š    });\n-+â”Š   â”Š162â”Š\n-+â”Š   â”Š163â”Š    interPoints = _.uniq(interPoints, point => `(${point.x}, ${point.y})`);\n-+â”Š   â”Š164â”Š\n-+â”Š   â”Š165â”Š    if (interPoints.length > 0) return interPoints;\n-+â”Š   â”Š166â”Š  }\n-+â”Š   â”Š167â”Š};ðŸš«â†µ\n-```\n-\n-##### Changed views/game.html\n-```diff\n-@@ -11,6 +11,7 @@\n- â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/utils.js\"></script>\n- â”Š12â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n- â”Š13â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/geometry/line.js\"></script>\n-+â”Š  â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/geometry/circle.js\"></script>\n- â”Š14â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/restorable.js\"></script>\n- â”Š15â”Š16â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/font.js\"></script>\n- â”Š16â”Š17â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/sprite.js\"></script>\n-```\n-[}]: #\n-\n-Just like a line, a circle can be presented using variables as well. The center of the circle is represented as `(x, y)` and its radius is represented as `r`. Remember that our circle doesn't necessarily have to be a full one, therefore we limit its range using two radians - `rad1` and `rad2`. The formula for representing a circle in a 2D space looks like this:\n-\n-![circle-formula](https://cloud.githubusercontent.com/assets/7648874/21829783/84a54574-d77f-11e6-9b87-3fb0f073bb8d.png)\n-\n-![circle-circle-illustration](https://cloud.githubusercontent.com/assets/7648874/21790842/3a73408c-d6c6-11e6-8bdd-9c73355e6ebb.png)\n-\n-> `a` and `b` represent the offsets from the `x` and the `y` axes respectively.\n-> See reference: http://mathworld.wolfram.com/Circle-CircleIntersection.html.\n-\n-To find intersection between two circles, we simply calculate the solution for two equations with two variables. Given that a line can be represented in a 2D space using the following formula:\n-\n-![line-formula](https://cloud.githubusercontent.com/assets/7648874/21790671/1609c050-d6c5-11e6-8bd7-16cc306f5eea.png)\n-\n-![circle-line-illustration](https://cloud.githubusercontent.com/assets/7648874/21790810/1a052086-d6c6-11e6-9c5c-24298fedb043.png)\n-\n-> `n` represents the intersection value with the `y` axis.\n-> See reference: http://mathworld.wolfram.com/Circle-LineIntersection.html.\n-\n-we can find the intersection between a circle and line by solving the systems formed by the equations of both. We also want the line-circle algorithm to be available for any `Line` instance, therefore we gonna add the following delegate on the `Line` prototype:\n-\n-[{]: <helper> (diff_step 5.8)\n-#### Step 5.8: Delegate circle intersection methods\n-\n-##### Changed resources/scripts/engine/geometry/line.js\n-```diff\n-@@ -44,6 +44,8 @@\n- â”Š44â”Š44â”Š  getIntersection(shape) {\n- â”Š45â”Š45â”Š    if (shape instanceof Engine.Geometry.Line)\n- â”Š46â”Š46â”Š      return this.getLineIntersection(shape);\n-+â”Š  â”Š47â”Š    if (shape instanceof Engine.Geometry.Circle)\n-+â”Š  â”Š48â”Š      return this.getCircleIntersection(shape);\n- â”Š47â”Š49â”Š  }\n- â”Š48â”Š50â”Š\n- â”Š49â”Š51â”Š  // line - line intersection method\n-```\n-```diff\n-@@ -62,4 +64,9 @@\n- â”Š62â”Š64â”Š      return { x, y };\n- â”Š63â”Š65â”Š    }\n- â”Š64â”Š66â”Š  }\n-+â”Š  â”Š67â”Š\n-+â”Š  â”Š68â”Š  // line - circle intersection method\n-+â”Š  â”Š69â”Š  getCircleIntersection(circle) {\n-+â”Š  â”Š70â”Š    return circle.getLineIntersection(this);\n-+â”Š  â”Š71â”Š  }\n- â”Š65â”Š72â”Š};ðŸš«â†µ\n-```\n-[}]: #\n-\n-Then again a newly created geometry shape class should be tested against different scenarios:\n-\n-[{]: <helper> (diff_step 5.9)\n-#### Step 5.9: Create 'Circle' class tests\n-\n-##### Added resources/scripts/specs/engine/geometry/circle.js\n-```diff\n-@@ -0,0 +1,144 @@\n-+â”Š   â”Š  1â”Šdescribe(\"Engine.Geometry.Circle class\", function() {\n-+â”Š   â”Š  2â”Š  beforeEach(function() {\n-+â”Š   â”Š  3â”Š    this.circle = new Engine.Geometry.Circle(1, 1, 5, 0, 1.5 * Math.PI);\n-+â”Š   â”Š  4â”Š  });\n-+â”Š   â”Š  5â”Š\n-+â”Š   â”Š  6â”Š  describe(\"getX method\", function() {\n-+â”Š   â”Š  7â”Š    describe(\"given inranged rad\", function() {\n-+â”Š   â”Š  8â”Š      it(\"returns x\", function() {\n-+â”Š   â”Š  9â”Š        expect(this.circle.getX(0 * Math.PI)).toBeCloseTo(6);\n-+â”Š   â”Š 10â”Š        expect(this.circle.getX(0.5 * Math.PI)).toBeCloseTo(1);\n-+â”Š   â”Š 11â”Š        expect(this.circle.getX(1 * Math.PI)).toBeCloseTo(-4);\n-+â”Š   â”Š 12â”Š        expect(this.circle.getX(1.5 * Math.PI)).toBeCloseTo(1);\n-+â”Š   â”Š 13â”Š      });\n-+â”Š   â”Š 14â”Š    });\n-+â”Š   â”Š 15â”Š\n-+â”Š   â”Š 16â”Š    describe(\"given outranged rad\", function() {\n-+â”Š   â”Š 17â”Š      it(\"returns nothing\", function() {\n-+â”Š   â”Š 18â”Š        expect(this.circle.getX(2 * Math.PI)).toBeUndefined();\n-+â”Š   â”Š 19â”Š      });\n-+â”Š   â”Š 20â”Š    });\n-+â”Š   â”Š 21â”Š  });\n-+â”Š   â”Š 22â”Š\n-+â”Š   â”Š 23â”Š  describe(\"getY method\", function() {\n-+â”Š   â”Š 24â”Š    describe(\"given inranged rad\", function() {\n-+â”Š   â”Š 25â”Š      it(\"returns y\", function() {\n-+â”Š   â”Š 26â”Š        expect(this.circle.getY(0 * Math.PI)).toBeCloseTo(1);\n-+â”Š   â”Š 27â”Š        expect(this.circle.getY(0.5 * Math.PI)).toBeCloseTo(6);\n-+â”Š   â”Š 28â”Š        expect(this.circle.getY(1 * Math.PI)).toBeCloseTo(1);\n-+â”Š   â”Š 29â”Š        expect(this.circle.getY(1.5 * Math.PI)).toBeCloseTo(-4);\n-+â”Š   â”Š 30â”Š      });\n-+â”Š   â”Š 31â”Š    });\n-+â”Š   â”Š 32â”Š\n-+â”Š   â”Š 33â”Š    describe(\"given outranged rad\", function() {\n-+â”Š   â”Š 34â”Š      it(\"returns nothing\", function() {\n-+â”Š   â”Š 35â”Š        expect(this.circle.getY(2 * Math.PI)).toBeUndefined();\n-+â”Š   â”Š 36â”Š      });\n-+â”Š   â”Š 37â”Š    });\n-+â”Š   â”Š 38â”Š  });\n-+â”Š   â”Š 39â”Š\n-+â”Š   â”Š 40â”Š  describe(\"getRad method\", function() {\n-+â”Š   â”Š 41â”Š    describe(\"given inranged point\", function() {\n-+â”Š   â”Š 42â”Š      it(\"returns rad\", function() {\n-+â”Š   â”Š 43â”Š        let x = -3.0450849718747346;\n-+â”Š   â”Š 44â”Š        let y = 3.9389262614623686;\n-+â”Š   â”Š 45â”Š        expect(this.circle.getRad(x, y)).toBeCloseTo(0.8 * Math.PI);\n-+â”Š   â”Š 46â”Š      });\n-+â”Š   â”Š 47â”Š    });\n-+â”Š   â”Š 48â”Š\n-+â”Š   â”Š 49â”Š    describe(\"given outranged point\", function() {\n-+â”Š   â”Š 50â”Š      it(\"returns nothing\", function() {\n-+â”Š   â”Š 51â”Š        let x = 5.045084971874736;\n-+â”Š   â”Š 52â”Š        let y = -1.9389262614623664;\n-+â”Š   â”Š 53â”Š        expect(this.circle.getRad(x, y)).toBeUndefined();\n-+â”Š   â”Š 54â”Š      });\n-+â”Š   â”Š 55â”Š    });\n-+â”Š   â”Š 56â”Š  });\n-+â”Š   â”Š 57â”Š\n-+â”Š   â”Š 58â”Š  describe(\"getCircleIntersection method\", function() {\n-+â”Š   â”Š 59â”Š    describe(\"given circle with 2 intersection points\", function() {\n-+â”Š   â”Š 60â”Š      it(\"returns array with intersection points\", function() {\n-+â”Š   â”Š 61â”Š        let circle = new Engine.Geometry.Circle(-5, 1, 5, 0, 2 * Math.PI);\n-+â”Š   â”Š 62â”Š\n-+â”Š   â”Š 63â”Š        expect(this.circle.getCircleIntersection(circle)).toEqual([\n-+â”Š   â”Š 64â”Š          { x: -2, y: -3 },\n-+â”Š   â”Š 65â”Š          { x: -2, y: 5 }\n-+â”Š   â”Š 66â”Š        ]);\n-+â”Š   â”Š 67â”Š      });\n-+â”Š   â”Š 68â”Š    });\n-+â”Š   â”Š 69â”Š\n-+â”Š   â”Š 70â”Š    describe(\"given circle with 1 intersection points\", function() {\n-+â”Š   â”Š 71â”Š      it(\"returns array with intersection point\", function() {\n-+â”Š   â”Š 72â”Š        let circle = new Engine.Geometry.Circle(-5, 1, 5, 0, 1 * Math.PI);\n-+â”Š   â”Š 73â”Š\n-+â”Š   â”Š 74â”Š        expect(this.circle.getCircleIntersection(circle)).toEqual([\n-+â”Š   â”Š 75â”Š          { x: -2, y: 5 }\n-+â”Š   â”Š 76â”Š        ]);\n-+â”Š   â”Š 77â”Š      });\n-+â”Š   â”Š 78â”Š    });\n-+â”Š   â”Š 79â”Š\n-+â”Š   â”Š 80â”Š    describe(\"given kissing circle\", function() {\n-+â”Š   â”Š 81â”Š      it(\"returns array with intersection point\", function() {\n-+â”Š   â”Š 82â”Š        let circle = new Engine.Geometry.Circle(-9, 1, 5, 0, 2 * Math.PI);\n-+â”Š   â”Š 83â”Š\n-+â”Š   â”Š 84â”Š        expect(this.circle.getCircleIntersection(circle)).toEqual([\n-+â”Š   â”Š 85â”Š          { x: -4, y: 1 }\n-+â”Š   â”Š 86â”Š        ]);\n-+â”Š   â”Š 87â”Š      });\n-+â”Š   â”Š 88â”Š    });\n-+â”Š   â”Š 89â”Š\n-+â”Š   â”Š 90â”Š    describe(\"given outer circle\", function() {\n-+â”Š   â”Š 91â”Š      it(\"returns nothing\", function() {\n-+â”Š   â”Š 92â”Š        let circle = new Engine.Geometry.Circle(10, 10, 2, 0, 2 * Math.PI);\n-+â”Š   â”Š 93â”Š        expect(this.circle.getCircleIntersection(circle)).toBeUndefined();\n-+â”Š   â”Š 94â”Š      });\n-+â”Š   â”Š 95â”Š    });\n-+â”Š   â”Š 96â”Š\n-+â”Š   â”Š 97â”Š    describe(\"given inner circle\", function() {\n-+â”Š   â”Š 98â”Š      it(\"nothing\", function() {\n-+â”Š   â”Š 99â”Š        let circle = new Engine.Geometry.Circle(1, 1, 2, 0, 2 * Math.PI);\n-+â”Š   â”Š100â”Š        expect(this.circle.getCircleIntersection(circle)).toBeUndefined();\n-+â”Š   â”Š101â”Š      });\n-+â”Š   â”Š102â”Š    });\n-+â”Š   â”Š103â”Š  });\n-+â”Š   â”Š104â”Š\n-+â”Š   â”Š105â”Š  describe(\"getLineIntersection method\", function() {\n-+â”Š   â”Š106â”Š    describe(\"given line with 2 intersection points\", function() {\n-+â”Š   â”Š107â”Š      it(\"returns array with intersection points\", function() {\n-+â”Š   â”Š108â”Š        let line = new Engine.Geometry.Line(-10, 1, 10, 1);\n-+â”Š   â”Š109â”Š\n-+â”Š   â”Š110â”Š        expect(this.circle.getLineIntersection(line)).toEqual([\n-+â”Š   â”Š111â”Š          { x: 6, y: 1 },\n-+â”Š   â”Š112â”Š          { x: -4, y: 1 }\n-+â”Š   â”Š113â”Š        ]);\n-+â”Š   â”Š114â”Š      });\n-+â”Š   â”Š115â”Š    });\n-+â”Š   â”Š116â”Š\n-+â”Š   â”Š117â”Š    describe(\"given line with 1 intersection point\", function() {\n-+â”Š   â”Š118â”Š      it(\"returns array with intersection point\", function() {\n-+â”Š   â”Š119â”Š        let line = new Engine.Geometry.Line(-10, 1, 1, 1);\n-+â”Š   â”Š120â”Š\n-+â”Š   â”Š121â”Š        expect(this.circle.getLineIntersection(line)).toEqual([\n-+â”Š   â”Š122â”Š          { x: -4, y: 1 }\n-+â”Š   â”Š123â”Š        ]);\n-+â”Š   â”Š124â”Š      });\n-+â”Š   â”Š125â”Š    });\n-+â”Š   â”Š126â”Š\n-+â”Š   â”Š127â”Š    describe(\"given kissing line\", function() {\n-+â”Š   â”Š128â”Š      it(\"returns array with intersection point\", function() {\n-+â”Š   â”Š129â”Š        let line = new Engine.Geometry.Line(-10, 6, 10, 6);\n-+â”Š   â”Š130â”Š\n-+â”Š   â”Š131â”Š        expect(this.circle.getLineIntersection(line)).toEqual([\n-+â”Š   â”Š132â”Š          { x: 1, y: 6 }\n-+â”Š   â”Š133â”Š        ]);\n-+â”Š   â”Š134â”Š      });\n-+â”Š   â”Š135â”Š    });\n-+â”Š   â”Š136â”Š\n-+â”Š   â”Š137â”Š    describe(\"given outranged line\", function() {\n-+â”Š   â”Š138â”Š      it(\"returns nothing\", function() {\n-+â”Š   â”Š139â”Š        let line = new Engine.Geometry.Line(-10, 10, 10, 10);\n-+â”Š   â”Š140â”Š        expect(this.circle.getLineIntersection(line)).toBeUndefined();\n-+â”Š   â”Š141â”Š      });\n-+â”Š   â”Š142â”Š    });\n-+â”Š   â”Š143â”Š  });\n-+â”Š   â”Š144â”Š});ðŸš«â†µ\n-```\n-\n-##### Changed views/spec_runner.html\n-```diff\n-@@ -19,9 +19,11 @@\n- â”Š19â”Š19â”Š    <script type=\"text/javascript\" src=\"scripts/utils.js\"></script>\n- â”Š20â”Š20â”Š    <script type=\"text/javascript\" src=\"scripts/namespaces.js\"></script>\n- â”Š21â”Š21â”Š    <script type=\"text/javascript\" src=\"scripts/engine/geometry/line.js\"></script>\n-+â”Š  â”Š22â”Š    <script type=\"text/javascript\" src=\"scripts/engine/geometry/circle.js\"></script>\n- â”Š22â”Š23â”Š\n- â”Š23â”Š24â”Š    <!-- Specs -->\n- â”Š24â”Š25â”Š    <script type=\"text/javascript\" src=\"scripts/specs/engine/geometry/line.js\"></script>\n-+â”Š  â”Š26â”Š    <script type=\"text/javascript\" src=\"scripts/specs/engine/geometry/circle.js\"></script>\n- â”Š25â”Š27â”Š  </head>\n- â”Š26â”Š28â”Š\n- â”Š27â”Š29â”Š  <body>\n-```\n-[}]: #\n-\n-Our final shape in the geometry module would be a polygon. Why a polygon? Since I'm planning to make the snake's movement circular, which means that once the snake hits a random boundary, he will reappear from the other side of the canvas. The collision detection between the snake and the canvas would be done using a polygon - which is simply made out of 4 lines:\n-\n-[{]: <helper> (diff_step 5.10)\n-#### Step 5.10: Create 'Polygon' class\n-\n-##### Added resources/scripts/engine/geometry/polygon.js\n-```diff\n-@@ -0,0 +1,58 @@\n-+â”Š  â”Š 1â”ŠEngine.Geometry.Polygon = class Polygon {\n-+â”Š  â”Š 2â”Š  // bounds - an array of arrays. Each sub-array represents the arguments vector which\n-+â”Š  â”Š 3â”Š  // will be invoked by the line's construction method\n-+â”Š  â”Š 4â”Š  constructor(...bounds) {\n-+â”Š  â”Š 5â”Š    this.bounds = bounds.map(coords => new Engine.Geometry.Line(...coords));\n-+â”Š  â”Š 6â”Š  }\n-+â”Š  â”Š 7â”Š\n-+â”Š  â”Š 8â”Š  // Returns if polygon has given point\n-+â”Š  â”Š 9â”Š  hasPoint(x, y) {\n-+â”Š  â”Š10â”Š    // Run check for each bound\n-+â”Š  â”Š11â”Š    return this.bounds.some(bound => bound.hasPoint(x, y));\n-+â”Š  â”Š12â”Š  }\n-+â”Š  â”Š13â”Š\n-+â”Š  â”Š14â”Š  getIntersection(shape) {\n-+â”Š  â”Š15â”Š    if (shape instanceof Engine.Geometry.Line)\n-+â”Š  â”Š16â”Š      return this.getLineIntersection(shape);\n-+â”Š  â”Š17â”Š    if (shape instanceof Engine.Geometry.Circle)\n-+â”Š  â”Š18â”Š      return this.getCircleIntersection(shape);\n-+â”Š  â”Š19â”Š    if (shape instanceof Engine.Geometry.Polygon)\n-+â”Š  â”Š20â”Š      return this.getPolygonIntersection(shape);\n-+â”Š  â”Š21â”Š  }\n-+â”Š  â”Š22â”Š\n-+â”Š  â”Š23â”Š  // polygon - line intersection method\n-+â”Š  â”Š24â”Š  getLineIntersection(line) {\n-+â”Š  â”Š25â”Š    // line - line intersection for each bound\n-+â”Š  â”Š26â”Š    let result = this.bounds.reduce((result, bound) => {\n-+â”Š  â”Š27â”Š      let intersection = line.getLineIntersection(bound);\n-+â”Š  â”Š28â”Š      if (intersection) result = result.concat(intersection);\n-+â”Š  â”Š29â”Š      return result;\n-+â”Š  â”Š30â”Š    }, []);\n-+â”Š  â”Š31â”Š\n-+â”Š  â”Š32â”Š    if (result.length) return result;\n-+â”Š  â”Š33â”Š  }\n-+â”Š  â”Š34â”Š\n-+â”Š  â”Š35â”Š  // polygon - circle intersection method\n-+â”Š  â”Š36â”Š  getCircleIntersection(circle) {\n-+â”Š  â”Š37â”Š    // line - circle intersection for each bound\n-+â”Š  â”Š38â”Š    let result = this.bounds.reduce((result, bound) => {\n-+â”Š  â”Š39â”Š      let intersection = circle.getLineIntersection(bound);\n-+â”Š  â”Š40â”Š      if (intersection) result = result.concat(intersection);\n-+â”Š  â”Š41â”Š      return result;\n-+â”Š  â”Š42â”Š    }, []);\n-+â”Š  â”Š43â”Š\n-+â”Š  â”Š44â”Š    if (result.length) return result;\n-+â”Š  â”Š45â”Š  }\n-+â”Š  â”Š46â”Š\n-+â”Š  â”Š47â”Š  // polygon - polygon intersection method\n-+â”Š  â”Š48â”Š  getPolygonIntersection(polygon) {\n-+â”Š  â”Š49â”Š    // line - polygon intersection for each bound\n-+â”Š  â”Š50â”Š    let result = this.bounds.reduce((result, bound) => {\n-+â”Š  â”Š51â”Š      let intersection = polygon.getLineIntersection(bound);\n-+â”Š  â”Š52â”Š      if (intersection) result = result.concat(intersection);\n-+â”Š  â”Š53â”Š      return result;\n-+â”Š  â”Š54â”Š    }, []);\n-+â”Š  â”Š55â”Š\n-+â”Š  â”Š56â”Š    if (result.length) return result;\n-+â”Š  â”Š57â”Š  }\n-+â”Š  â”Š58â”Š};ðŸš«â†µ\n-```\n-\n-##### Changed views/game.html\n-```diff\n-@@ -12,6 +12,7 @@\n- â”Š12â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n- â”Š13â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/geometry/line.js\"></script>\n- â”Š14â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/geometry/circle.js\"></script>\n-+â”Š  â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/geometry/polygon.js\"></script>\n- â”Š15â”Š16â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/restorable.js\"></script>\n- â”Š16â”Š17â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/font.js\"></script>\n- â”Š17â”Š18â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/sprite.js\"></script>\n-```\n-[}]: #\n-\n-Again we will delegate the newly created intersection methods in the `Line` class and `Circle` class:\n-\n-[{]: <helper> (diff_step 5.11)\n-#### Step 5.11: Delegate polygon intersection methods\n-\n-##### Changed resources/scripts/engine/geometry/circle.js\n-```diff\n-@@ -83,6 +83,8 @@\n- â”Š83â”Š83â”Š      return this.getLineIntersection(shape);\n- â”Š84â”Š84â”Š    if (shape instanceof Engine.Geometry.Circle)\n- â”Š85â”Š85â”Š      return this.getCircleIntersection(shape);\n-+â”Š  â”Š86â”Š    if (shape instanceof Engine.Geometry.Polygon)\n-+â”Š  â”Š87â”Š      return this.getPolygonIntersection(shape);\n- â”Š86â”Š88â”Š  }\n- â”Š87â”Š89â”Š\n- â”Š88â”Š90â”Š  // circle - circle intersection method\n-```\n-```diff\n-@@ -164,4 +166,9 @@\n- â”Š164â”Š166â”Š\n- â”Š165â”Š167â”Š    if (interPoints.length > 0) return interPoints;\n- â”Š166â”Š168â”Š  }\n-+â”Š   â”Š169â”Š\n-+â”Š   â”Š170â”Š  // circle - polygon intersection method\n-+â”Š   â”Š171â”Š  getPolygonIntersection(polygon) {\n-+â”Š   â”Š172â”Š    return polygon.getCircleIntersection(this);\n-+â”Š   â”Š173â”Š  }\n- â”Š167â”Š174â”Š};ðŸš«â†µ\n-```\n-\n-##### Changed resources/scripts/engine/geometry/line.js\n-```diff\n-@@ -46,6 +46,8 @@\n- â”Š46â”Š46â”Š      return this.getLineIntersection(shape);\n- â”Š47â”Š47â”Š    if (shape instanceof Engine.Geometry.Circle)\n- â”Š48â”Š48â”Š      return this.getCircleIntersection(shape);\n-+â”Š  â”Š49â”Š    if (shape instanceof Engine.Geometry.Polygon)\n-+â”Š  â”Š50â”Š      return this.getPolygonIntersection(shape);\n- â”Š49â”Š51â”Š  }\n- â”Š50â”Š52â”Š\n- â”Š51â”Š53â”Š  // line - line intersection method\n-```\n-```diff\n-@@ -69,4 +71,9 @@\n- â”Š69â”Š71â”Š  getCircleIntersection(circle) {\n- â”Š70â”Š72â”Š    return circle.getLineIntersection(this);\n- â”Š71â”Š73â”Š  }\n-+â”Š  â”Š74â”Š\n-+â”Š  â”Š75â”Š  // line - polygon intersection method\n-+â”Š  â”Š76â”Š  getPolygonIntersection(polygon) {\n-+â”Š  â”Š77â”Š    return polygon.getLineIntersection(this);\n-+â”Š  â”Š78â”Š  }\n- â”Š72â”Š79â”Š};ðŸš«â†µ\n-```\n-[}]: #\n-\n-Now we will create a some tests to make sure our newly created polygon works properly:\n-\n-[{]: <helper> (diff_step 5.12)\n-#### Step 5.12: Create 'Polygon' class tests\n-\n-##### Added resources/scripts/specs/engine/geometry/polygon.js\n-```diff\n-@@ -0,0 +1,96 @@\n-+â”Š  â”Š 1â”Šdescribe(\"Engine.Geometry.Polygon class\", function() {\n-+â”Š  â”Š 2â”Š  beforeEach(function() {\n-+â”Š  â”Š 3â”Š    this.polygon = new Engine.Geometry.Polygon(\n-+â”Š  â”Š 4â”Š      [0, 0, 5, 0],\n-+â”Š  â”Š 5â”Š      [5, 0, 5, 5],\n-+â”Š  â”Š 6â”Š      [5, 5, 0, 5],\n-+â”Š  â”Š 7â”Š      [0, 5, 0, 0]\n-+â”Š  â”Š 8â”Š    );\n-+â”Š  â”Š 9â”Š  });\n-+â”Š  â”Š10â”Š\n-+â”Š  â”Š11â”Š  describe(\"hasPoint method\", function() {\n-+â”Š  â”Š12â”Š    describe(\"given contained point\", function() {\n-+â”Š  â”Š13â”Š      it(\"returns true\", function() {\n-+â”Š  â”Š14â”Š        let x = 5;\n-+â”Š  â”Š15â”Š        let y = 3;\n-+â”Š  â”Š16â”Š        expect(this.polygon.hasPoint(x, y)).toBeTruthy();\n-+â”Š  â”Š17â”Š      });\n-+â”Š  â”Š18â”Š    });\n-+â”Š  â”Š19â”Š\n-+â”Š  â”Š20â”Š    describe(\"given outranged point\", function() {\n-+â”Š  â”Š21â”Š      it(\"returns false\", function() {\n-+â”Š  â”Š22â”Š        let x = 10;\n-+â”Š  â”Š23â”Š        let y = 10;\n-+â”Š  â”Š24â”Š        expect(this.polygon.hasPoint(x, y)).toBeFalsy();\n-+â”Š  â”Š25â”Š      });\n-+â”Š  â”Š26â”Š    });\n-+â”Š  â”Š27â”Š  });\n-+â”Š  â”Š28â”Š\n-+â”Š  â”Š29â”Š  describe(\"getLineIntersection method\", function() {\n-+â”Š  â”Š30â”Š    describe(\"given intersecting line\", function() {\n-+â”Š  â”Š31â”Š      it(\"returns intersection point\", function() {\n-+â”Š  â”Š32â”Š        let line = new Engine.Geometry.Line(0, 1, 5, 4);\n-+â”Š  â”Š33â”Š\n-+â”Š  â”Š34â”Š        expect(this.polygon.getLineIntersection(line)).toEqual([\n-+â”Š  â”Š35â”Š          { x: 5, y: 4 },\n-+â”Š  â”Š36â”Š          { x: 0, y: 1 }\n-+â”Š  â”Š37â”Š        ]);\n-+â”Š  â”Š38â”Š      });\n-+â”Š  â”Š39â”Š    });\n-+â”Š  â”Š40â”Š\n-+â”Š  â”Š41â”Š    describe(\"given outranged line\", function() {\n-+â”Š  â”Š42â”Š      it(\"returns nothing\", function() {\n-+â”Š  â”Š43â”Š        let line = new Engine.Geometry.Line(10, 11, 15, 14);\n-+â”Š  â”Š44â”Š\n-+â”Š  â”Š45â”Š        expect(this.polygon.getLineIntersection(line)).toBeUndefined();\n-+â”Š  â”Š46â”Š      });\n-+â”Š  â”Š47â”Š    });\n-+â”Š  â”Š48â”Š  });\n-+â”Š  â”Š49â”Š\n-+â”Š  â”Š50â”Š  describe(\"getCircleIntersection method\", function() {\n-+â”Š  â”Š51â”Š    describe(\"given circle with 2 intersection points\", function() {\n-+â”Š  â”Š52â”Š      it(\"returns array with intersection points\", function() {\n-+â”Š  â”Š53â”Š        let circle = new Engine.Geometry.Circle(0, 0, 2, 0, 2 * Math.PI);\n-+â”Š  â”Š54â”Š\n-+â”Š  â”Š55â”Š        expect(this.polygon.getCircleIntersection(circle)).toEqual([\n-+â”Š  â”Š56â”Š          { x: 2, y: 0 },\n-+â”Š  â”Š57â”Š          { x: 0, y: 2 }\n-+â”Š  â”Š58â”Š        ]);\n-+â”Š  â”Š59â”Š      });\n-+â”Š  â”Š60â”Š    });\n-+â”Š  â”Š61â”Š\n-+â”Š  â”Š62â”Š    describe(\"given circle with 1 intersection points\", function() {\n-+â”Š  â”Š63â”Š      it(\"returns array with intersection point\", function() {\n-+â”Š  â”Š64â”Š        let circle = new Engine.Geometry.Circle(0, 0, 2, 0, 0.25 * Math.PI);\n-+â”Š  â”Š65â”Š\n-+â”Š  â”Š66â”Š        expect(this.polygon.getCircleIntersection(circle)).toEqual([\n-+â”Š  â”Š67â”Š          { x: 2, y: 0 }\n-+â”Š  â”Š68â”Š        ]);\n-+â”Š  â”Š69â”Š      });\n-+â”Š  â”Š70â”Š    });\n-+â”Š  â”Š71â”Š\n-+â”Š  â”Š72â”Š    describe(\"given kissing circle\", function() {\n-+â”Š  â”Š73â”Š      it(\"returns array with intersection point\", function() {\n-+â”Š  â”Š74â”Š        let circle = new Engine.Geometry.Circle(-3, 3, 3, 0, 2 * Math.PI);\n-+â”Š  â”Š75â”Š\n-+â”Š  â”Š76â”Š        expect(this.polygon.getCircleIntersection(circle)).toEqual([\n-+â”Š  â”Š77â”Š          { x: 0, y: 3 }\n-+â”Š  â”Š78â”Š        ]);\n-+â”Š  â”Š79â”Š      });\n-+â”Š  â”Š80â”Š    });\n-+â”Š  â”Š81â”Š\n-+â”Š  â”Š82â”Š    describe(\"given outer circle\", function() {\n-+â”Š  â”Š83â”Š      it(\"returns nothing\", function() {\n-+â”Š  â”Š84â”Š        let circle = new Engine.Geometry.Circle(10, 10, 2, 0, 2 * Math.PI);\n-+â”Š  â”Š85â”Š        expect(this.polygon.getCircleIntersection(circle)).toBeUndefined();\n-+â”Š  â”Š86â”Š      });\n-+â”Š  â”Š87â”Š    });\n-+â”Š  â”Š88â”Š\n-+â”Š  â”Š89â”Š    describe(\"given inner circle\", function() {\n-+â”Š  â”Š90â”Š      it(\"nothing\", function() {\n-+â”Š  â”Š91â”Š        let circle = new Engine.Geometry.Circle(2.5, 2.5, 2, 0, 2 * Math.PI);\n-+â”Š  â”Š92â”Š        expect(this.polygon.getCircleIntersection(circle)).toBeUndefined();\n-+â”Š  â”Š93â”Š      });\n-+â”Š  â”Š94â”Š    });\n-+â”Š  â”Š95â”Š  });\n-+â”Š  â”Š96â”Š});ðŸš«â†µ\n-```\n-\n-##### Changed views/spec_runner.html\n-```diff\n-@@ -20,10 +20,12 @@\n- â”Š20â”Š20â”Š    <script type=\"text/javascript\" src=\"scripts/namespaces.js\"></script>\n- â”Š21â”Š21â”Š    <script type=\"text/javascript\" src=\"scripts/engine/geometry/line.js\"></script>\n- â”Š22â”Š22â”Š    <script type=\"text/javascript\" src=\"scripts/engine/geometry/circle.js\"></script>\n-+â”Š  â”Š23â”Š    <script type=\"text/javascript\" src=\"scripts/engine/geometry/polygon.js\"></script>\n- â”Š23â”Š24â”Š\n- â”Š24â”Š25â”Š    <!-- Specs -->\n- â”Š25â”Š26â”Š    <script type=\"text/javascript\" src=\"scripts/specs/engine/geometry/line.js\"></script>\n- â”Š26â”Š27â”Š    <script type=\"text/javascript\" src=\"scripts/specs/engine/geometry/circle.js\"></script>\n-+â”Š  â”Š28â”Š    <script type=\"text/javascript\" src=\"scripts/specs/engine/geometry/polygon.js\"></script>\n- â”Š27â”Š29â”Š  </head>\n- â”Š28â”Š30â”Š\n- â”Š29â”Š31â”Š  <body>\n-```\n-[}]: #\n-\n-At last, all the necessary geometry shapes are implemented and ready to use. We will now focus on the snake itself. Since our game can potentially have infinite number of entities, not necessarily just a snake, we will add the a new module under the `Game` namespace called `Entities`:\n-\n-[{]: <helper> (diff_step 5.13)\n-#### Step 5.13: Add 'Entities' module to 'Game' namespace\n-\n-##### Changed resources/scripts/namespaces.js\n-```diff\n-@@ -1,4 +1,5 @@\n- â”Š1â”Š1â”ŠGame = {\n-+â”Š â”Š2â”Š  Entities: {},\n- â”Š2â”Š3â”Š  Screens: {}\n- â”Š3â”Š4â”Š};\n-```\n-[}]: #\n-\n-And now we can add the `Snake` class:\n-\n-[{]: <helper> (diff_step 5.14)\n-#### Step 5.14: Create 'Snake' class\n-\n-##### Added resources/scripts/game/entities/snake.js\n-```diff\n-@@ -0,0 +1,234 @@\n-+â”Š   â”Š  1â”ŠGame.Entities.Snake = class Snake {\n-+â”Š   â”Š  2â”Š  // Represents a snake data-structure which will eventually appear on screen.\n-+â”Š   â”Š  3â”Š  // All the properties provided to the constructor are the initial values of\n-+â”Š   â”Š  4â”Š  // the snake\n-+â”Š   â”Š  5â”Š  constructor(x, y, r, rad, v, color, keyStates, options) {\n-+â”Š   â”Š  6â”Š    this.x = x;\n-+â”Š   â”Š  7â”Š    this.y = y;\n-+â”Š   â”Š  8â”Š    this.r = r;\n-+â”Š   â”Š  9â”Š    this.rad = rad;\n-+â”Š   â”Š 10â”Š    this.v = v;\n-+â”Š   â”Š 11â”Š    this.color = color;\n-+â”Š   â”Š 12â”Š    this.keyStates = keyStates;\n-+â”Š   â”Š 13â”Š    // A snake is made out of many geometry shapes\n-+â”Š   â”Š 14â”Š    this.shapes = [];\n-+â”Š   â”Š 15â”Š    // A snake starts with a line\n-+â”Š   â”Š 16â”Š    this.currentShape = new Engine.Geometry.Line(x, y, x, y);\n-+â”Š   â”Š 17â”Š    this.shapes.push(this.currentShape);\n-+â”Š   â”Š 18â”Š    // A score can be provided in case we want to reserve previous scores from\n-+â”Š   â”Š 19â”Š    // recent matches\n-+â”Š   â”Š 20â”Š    this.score = options.score || 0;\n-+â”Š   â”Š 21â”Š\n-+â”Š   â”Š 22â”Š    // Custom keys can be specified\n-+â”Š   â”Š 23â”Š    if (options.keys && options.keys) {\n-+â”Š   â”Š 24â”Š      this.leftKey = options.keys.left;\n-+â”Š   â”Š 25â”Š      this.rightKey = options.keys.right;\n-+â”Š   â”Š 26â”Š    }\n-+â”Š   â”Š 27â”Š    // Left and right arrow keys will be used by default\n-+â”Š   â”Š 28â”Š    else {\n-+â”Š   â”Š 29â”Š      this.leftKey = 37; // Left arrow\n-+â”Š   â”Š 30â”Š      this.rightKey = 39; // Right arrow\n-+â”Š   â”Š 31â”Š    }\n-+â”Š   â”Š 32â”Š  }\n-+â”Š   â”Š 33â”Š\n-+â”Š   â”Š 34â”Š  draw(context) {\n-+â”Š   â”Š 35â”Š    // Draw all shapes in the shapes array\n-+â”Š   â”Š 36â”Š    this.shapes.forEach(shape => {\n-+â”Š   â”Š 37â”Š      context.save();\n-+â”Š   â”Š 38â”Š      context.strokeStyle = this.color;\n-+â”Š   â”Š 39â”Š      context.lineWidth = 3;\n-+â”Š   â”Š 40â”Š      context.beginPath();\n-+â”Š   â”Š 41â”Š\n-+â”Š   â”Š 42â”Š      // Each shape has its own unique drawing method\n-+â”Š   â”Š 43â”Š      shape.draw(context);\n-+â”Š   â”Š 44â”Š\n-+â”Š   â”Š 45â”Š      context.stroke();\n-+â”Š   â”Š 46â”Š      context.restore();\n-+â”Š   â”Š 47â”Š    });\n-+â”Š   â”Š 48â”Š  }\n-+â”Š   â”Š 49â”Š\n-+â”Š   â”Š 50â”Š  update(span, width, height) {\n-+â”Š   â”Š 51â”Š    // Progress made based on elapsed time and velocity\n-+â”Š   â”Š 52â”Š    let step = (this.v * span) / 1000;\n-+â”Š   â”Š 53â”Š\n-+â”Š   â”Š 54â”Š    this.updateShapes(step, width, height);\n-+â”Š   â”Š 55â”Š    this.cycleThrough(step, width, height);\n-+â”Š   â”Š 56â”Š  }\n-+â”Š   â”Š 57â”Š\n-+â”Š   â”Š 58â”Š  // Updates shapes array based on progress made\n-+â”Š   â”Š 59â”Š  updateShapes(step, width, height, options = {}) {\n-+â”Š   â”Š 60â”Š    this.updateCurrentShape(step, options);\n-+â”Š   â”Š 61â”Š    this.updateDirection(step, options);\n-+â”Š   â”Š 62â”Š  }\n-+â”Š   â”Š 63â”Š\n-+â”Š   â”Š 64â”Š  // Updates current shape\n-+â”Š   â”Š 65â”Š  updateCurrentShape(step, options) {\n-+â”Š   â”Š 66â”Š    if (this.currentShape instanceof Engine.Geometry.Line)\n-+â”Š   â”Š 67â”Š      return this.updateCurrentLine(options);\n-+â”Š   â”Š 68â”Š    if (this.currentShape instanceof Engine.Geometry.Circle)\n-+â”Š   â”Š 69â”Š      return this.updateCurrentCircle(options);\n-+â”Š   â”Š 70â”Š  }\n-+â”Š   â”Š 71â”Š\n-+â”Š   â”Š 72â”Š  // Updates current shape in case it is a line\n-+â”Š   â”Š 73â”Š  updateCurrentLine(options) {\n-+â”Š   â”Š 74â”Š    let lastX = options.lastX || this.x;\n-+â”Š   â”Š 75â”Š    let lastY = options.lastY || this.y;\n-+â”Š   â”Š 76â”Š    this.x = options.x || this.currentShape.x2;\n-+â”Š   â”Š 77â”Š    this.y = options.y || this.currentShape.y2;\n-+â”Š   â”Š 78â”Š    this.lastBit = new Engine.Geometry.Line(lastX, lastY, this.x, this.y);\n-+â”Š   â”Š 79â”Š  }\n-+â”Š   â”Š 80â”Š\n-+â”Š   â”Š 81â”Š  // Updates current shape in case it is a circle\n-+â”Š   â”Š 82â”Š  updateCurrentCircle(options) {\n-+â”Š   â”Š 83â”Š    let lastX = options.lastX || this.currentShape.x;\n-+â”Š   â”Š 84â”Š    let lastY = options.lastY || this.currentShape.y;\n-+â”Š   â”Š 85â”Š    let lastR = options.lastR || this.currentShape.r;\n-+â”Š   â”Š 86â”Š\n-+â”Š   â”Š 87â”Š    // Update logic for left rotation\n-+â”Š   â”Š 88â”Š    if (this.direction == \"left\") {\n-+â”Š   â”Š 89â”Š      let lastRad = this.rad + (0.5 * Math.PI);\n-+â”Š   â”Š 90â”Š      let currentShapePoint = this.currentShape.getPoint(this.currentShape.rad1);\n-+â”Š   â”Š 91â”Š      this.x = options.x || currentShapePoint.x;\n-+â”Š   â”Š 92â”Š      this.y = options.y || currentShapePoint.y;\n-+â”Š   â”Š 93â”Š      this.rad = this.currentShape.rad1 - (0.5 * Math.PI);\n-+â”Š   â”Š 94â”Š      this.lastBit = new Engine.Geometry.Circle(lastX, lastY, lastR, this.currentShape.rad1, lastRad);\n-+â”Š   â”Š 95â”Š    }\n-+â”Š   â”Š 96â”Š    // Update logic for right rotation\n-+â”Š   â”Š 97â”Š    else {\n-+â”Š   â”Š 98â”Š      let lastRad = this.rad - (0.5 * Math.PI);\n-+â”Š   â”Š 99â”Š      let currentShapePoint = this.currentShape.getPoint(this.currentShape.rad2);\n-+â”Š   â”Š100â”Š      this.x = options.x || currentShapePoint.x;\n-+â”Š   â”Š101â”Š      this.y = options.y || currentShapePoint.y;\n-+â”Š   â”Š102â”Š      this.rad = this.currentShape.rad2 + (0.5 * Math.PI);\n-+â”Š   â”Š103â”Š      this.lastBit = new Engine.Geometry.Circle(lastX, lastY, lastR, lastRad, this.currentShape.rad2);\n-+â”Š   â”Š104â”Š    }\n-+â”Š   â”Š105â”Š  }\n-+â”Š   â”Š106â”Š\n-+â”Š   â”Š107â”Š  updateDirection(step, options) {\n-+â”Š   â”Š108â”Š    // Update the direction based on pressed key\n-+â”Š   â”Š109â”Š    if (this.keyStates.get(this.leftKey))\n-+â”Š   â”Š110â”Š      var direction = \"left\";\n-+â”Š   â”Š111â”Š    else if (this.keyStates.get(this.rightKey))\n-+â”Š   â”Š112â”Š      var direction = \"right\";\n-+â”Š   â”Š113â”Š\n-+â”Š   â”Š114â”Š    this.changeDirection(step, direction, options);\n-+â”Š   â”Š115â”Š    this.continueDirection(step, direction, options);\n-+â”Š   â”Š116â”Š  }\n-+â”Š   â”Š117â”Š\n-+â”Š   â”Š118â”Š  // Change the recent shape type according to the given direction\n-+â”Š   â”Š119â”Š  changeDirection(step, direction, options) {\n-+â”Š   â”Š120â”Š    // If there is no change in direction, abort, unless we force it\n-+â”Š   â”Š121â”Š    if (direction == this.direction && !options.force) return;\n-+â”Š   â”Š122â”Š\n-+â”Š   â”Š123â”Š    this.direction = direction;\n-+â”Š   â”Š124â”Š\n-+â”Š   â”Š125â”Š    // This will push a new shape with new properties, based on the direction\n-+â”Š   â”Š126â”Š    switch (direction) {\n-+â”Š   â”Š127â”Š      case \"left\":\n-+â”Š   â”Š128â”Š        var angle = this.rad - (0.5 * Math.PI);\n-+â”Š   â”Š129â”Š        var rad = this.rad + (0.5 * Math.PI);\n-+â”Š   â”Š130â”Š        var x = this.x + (this.r * Math.cos(angle));\n-+â”Š   â”Š131â”Š        var y = this.y + (this.r * Math.sin(angle));\n-+â”Š   â”Š132â”Š        this.currentShape = new Engine.Geometry.Circle(x, y, this.r, rad, rad);\n-+â”Š   â”Š133â”Š        break;\n-+â”Š   â”Š134â”Š      case \"right\":\n-+â”Š   â”Š135â”Š        angle = this.rad + (0.5 * Math.PI);\n-+â”Š   â”Š136â”Š        rad = this.rad - (0.5 * Math.PI);\n-+â”Š   â”Š137â”Š        x = this.x + (this.r * Math.cos(angle));\n-+â”Š   â”Š138â”Š        y = this.y + (this.r * Math.sin(angle));\n-+â”Š   â”Š139â”Š        this.currentShape = new Engine.Geometry.Circle(x, y, this.r, rad, rad);\n-+â”Š   â”Š140â”Š        break;\n-+â”Š   â”Š141â”Š      default:\n-+â”Š   â”Š142â”Š        this.currentShape = new Engine.Geometry.Line(this.x, this.y, this.x, this.y);\n-+â”Š   â”Š143â”Š    }\n-+â”Š   â”Š144â”Š\n-+â”Š   â”Š145â”Š    this.shapes.push(this.currentShape);\n-+â”Š   â”Š146â”Š  }\n-+â”Š   â”Š147â”Š\n-+â”Š   â”Š148â”Š  // Extend the recent shape based on progress made\n-+â”Š   â”Š149â”Š  continueDirection(step, direction) {\n-+â”Š   â”Š150â”Š    switch (direction) {\n-+â”Š   â”Š151â”Š      case \"left\":\n-+â”Š   â”Š152â”Š        this.currentShape.rad1 -= step / this.r;\n-+â”Š   â”Š153â”Š        break;\n-+â”Š   â”Š154â”Š      case \"right\":\n-+â”Š   â”Š155â”Š        this.currentShape.rad2 += step / this.r;\n-+â”Š   â”Š156â”Š        break;\n-+â”Š   â”Š157â”Š      default:\n-+â”Š   â”Š158â”Š        this.currentShape.x2 += step * Math.cos(this.rad);\n-+â”Š   â”Š159â”Š        this.currentShape.y2 += step * Math.sin(this.rad);\n-+â”Š   â”Š160â”Š    }\n-+â”Š   â”Š161â”Š  }\n-+â”Š   â”Š162â”Š\n-+â”Š   â”Š163â”Š  // Handles case where snake is out limits and we need to render it from\n-+â”Š   â”Š164â”Š  // the other side of the canvas\n-+â”Š   â”Š165â”Š  cycleThrough(step, width, height) {\n-+â”Š   â”Š166â”Š    let intersectionPoint = this.getCanvasIntersection(width, height);\n-+â”Š   â”Š167â”Š\n-+â”Š   â”Š168â”Š    if (!intersectionPoint) return;\n-+â”Š   â”Š169â”Š\n-+â”Š   â”Š170â”Š    intersectionPoint = intersectionPoint[0];\n-+â”Š   â”Š171â”Š\n-+â”Š   â”Š172â”Š    // Re-calculate position based on canvas bounds\n-+â”Š   â”Š173â”Š    if (intersectionPoint.x % width == 0)\n-+â”Š   â”Š174â”Š      this.x = Utils.mod(this.x - width, width);\n-+â”Š   â”Š175â”Š    if (intersectionPoint.y % height == 0)\n-+â”Š   â”Š176â”Š      this.y = Utils.mod(this.y - height, height);\n-+â”Š   â”Š177â”Š\n-+â”Š   â”Š178â”Š    // Update shapes again based on custom properties\n-+â”Š   â”Š179â”Š    this.updateShapes(step, width, height, {\n-+â”Š   â”Š180â”Š      force: true,\n-+â”Š   â”Š181â”Š      lastX: this.x,\n-+â”Š   â”Š182â”Š      lastY: this.y,\n-+â”Š   â”Š183â”Š      x: this.x,\n-+â”Š   â”Š184â”Š      y: this.y\n-+â”Š   â”Š185â”Š    });\n-+â”Š   â”Š186â”Š  }\n-+â”Š   â”Š187â”Š\n-+â”Š   â”Š188â”Š  // Gets intersection points between last bit and own shapes\n-+â”Š   â”Š189â”Š  getSelfIntersection() {\n-+â”Š   â”Š190â”Š    if (this.currentShape instanceof Engine.Geometry.Circle &&\n-+â”Š   â”Š191â”Š       Math.abs(this.currentShape.rad1 - this.currentShape.rad2) >= 2 * Math.PI) {\n-+â”Š   â”Š192â”Š      if (this.direction == \"left\")\n-+â”Š   â”Š193â”Š        var rad = this.currentShape.rad1;\n-+â”Š   â”Š194â”Š      else\n-+â”Š   â”Š195â”Š        var rad = this.currentShape.rad2;\n-+â”Š   â”Š196â”Š\n-+â”Š   â”Š197â”Š      return this.currentShape.getPoint(rad);\n-+â”Š   â”Š198â”Š    }\n-+â”Š   â”Š199â”Š\n-+â”Š   â”Š200â”Š    let result;\n-+â”Š   â”Š201â”Š\n-+â”Š   â”Š202â”Š    this.shapes.slice(0, -2).some(shape =>\n-+â”Š   â”Š203â”Š      result = this.lastBit.getIntersection(shape)\n-+â”Š   â”Š204â”Š    );\n-+â”Š   â”Š205â”Š\n-+â”Š   â”Š206â”Š    return result;\n-+â”Š   â”Š207â”Š  }\n-+â”Š   â”Š208â”Š\n-+â”Š   â”Š209â”Š  // Returns intersection points between snakes\n-+â”Š   â”Š210â”Š  getSnakeIntersection(snake) {\n-+â”Š   â”Š211â”Š    let result;\n-+â”Š   â”Š212â”Š\n-+â”Š   â”Š213â”Š    snake.shapes.some(shape =>\n-+â”Š   â”Š214â”Š      // Only last bit is relevant, if we reached this point it means that\n-+â”Š   â”Š215â”Š      // previous intersection will definitely fail\n-+â”Š   â”Š216â”Š      result = this.lastBit.getIntersection(shape)\n-+â”Š   â”Š217â”Š    );\n-+â”Š   â”Š218â”Š\n-+â”Š   â”Š219â”Š    return result;\n-+â”Š   â”Š220â”Š  }\n-+â”Š   â”Š221â”Š\n-+â”Š   â”Š222â”Š  // Returns intersection points between snake and canvas\n-+â”Š   â”Š223â”Š  getCanvasIntersection(width, height) {\n-+â”Š   â”Š224â”Š    // Canvas polygon\n-+â”Š   â”Š225â”Š    let canvasPolygon = new Engine.Geometry.Polygon(\n-+â”Š   â”Š226â”Š      [0, 0, width, 0],\n-+â”Š   â”Š227â”Š      [width, 0, width, height],\n-+â”Š   â”Š228â”Š      [width, height, 0, height],\n-+â”Š   â”Š229â”Š      [0, height, 0, 0]\n-+â”Š   â”Š230â”Š    );\n-+â”Š   â”Š231â”Š\n-+â”Š   â”Š232â”Š    return canvasPolygon.getIntersection(this.lastBit);\n-+â”Š   â”Š233â”Š  }\n-+â”Š   â”Š234â”Š};ðŸš«â†µ\n-```\n-\n-##### Changed views/game.html\n-```diff\n-@@ -22,6 +22,7 @@\n- â”Š22â”Š22â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/screen.js\"></script>\n- â”Š23â”Š23â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/assets_loader.js\"></script>\n- â”Š24â”Š24â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n-+â”Š  â”Š25â”Š    <script type=\"text/javascript\" src=\"/scripts/game/entities/snake.js\"></script>\n- â”Š25â”Š26â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/menu/index.js\"></script>\n- â”Š26â”Š27â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/splash/index.js\"></script>\n- â”Š27â”Š28â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n-```\n-[}]: #\n-\n-This class is titled with most complexity out of everything we did so far in this step. You can follow the code accompanied by comments regard it, but I'd also like to explain the key concepts. As said earlier, the `Snake` is simply made out of shapes; In this case - lines and circles.\n-\n-The `draw` method just goes through this array and draws whatever shape it's currently looping through. Regardless of its type, every shape is provided with a `draw` method of its own, all shapes share the same interface, therefore we can just draw them regularly and the snake should be drawn automatically.\n-\n-The `update` method updates the last bit only according to its type, the time elapsed and the speed of the snake. For example, the last bit of the snake is a line, and 5 seconds have passed at a speed of 5 meters per second, our line should be extended by 5 meters long. Same principle applies to circle extension only based on radians. The last bit's type might be changed according to the current input; e.g. if the `right` key is held the last bit would turn into a circle, and once released it would turn into a straight line.\n-\n-Note that besides shapes extension, collision detection should also be made. The embedded is the collision detection between the snake and the canvas, which means that any time the snake collides with the canvas's boundaries the last bit should be redrawn from the opposite side of the canvas. In addition, we've implemented intersection methods for self collision detection and collision detection between rivals, which should be used externally by the hosting screen.\n-\n-In the next step we will be implementing the game screen where we will make use of the `Snake` class we've just created, and see how it works in action.\n-[}]: #\n-[{]: <region> (footer)\n-[{]: <helper> (nav_step)\n-| [< Previous Step](step4.md) | [Next Step >](step6.md) |\n-|:--------------------------------|--------------------------------:|\n-[}]: #\n-[}]: #\n\\ No newline at end of file\ndiff --git a/manuals/views/step6.md b/manuals/views/step6.md\ndeleted file mode 100644\nindex fc0f724..0000000\n--- a/manuals/views/step6.md\n+++ /dev/null\n@@ -1,536 +0,0 @@\n-[{]: <region> (header)\n-# Step 6: Creating a complex game screen with multiple layers\n-[}]: #\n-[{]: <region> (body)\n-![snake-demo-game-small](https://cloud.githubusercontent.com/assets/7648874/21074124/8b7cd724-bed7-11e6-9f91-2a211630ac78.gif)\n-\n-In this step we will be using the `Snake` class we've just created in the previous step to form the actual game screen - called the `Play` screen. The play screen is a complex screen made out multiple layers as following:\n-\n-- **`Ready` layer** - Displays a message at the beginning of each match.\n-- **`Snake` layer** - Displays the the competitors' snakes.\n-- **`Score` layer** - Displays the score board.\n-- **`Win` layer** - Displays the winner at the end of each match.\n-\n-As we go further with this step, we will give a deeper explanation about each layer and how they interact with each other; As for let's start with the `Play` screen's basis. Regardless of what the `Play` screen should contain at the final result, we want to have the ability to abort the match whenever we press the `Escape` key, therefore, the initial implementation should look like this:\n-\n-[{]: <helper> (diff_step 6.1)\n-#### Step 6.1: Create 'Play' screen\n-\n-##### Added resources/scripts/game/screens/play/index.js\n-```diff\n-@@ -0,0 +1,14 @@\n-+â”Š  â”Š 1â”ŠGame.Screens.Play = class Play extends Engine.Screen {\n-+â”Š  â”Š 2â”Š  get events() {\n-+â”Š  â”Š 3â”Š    return {\n-+â”Š  â”Š 4â”Š      \"keydown\": \"onKeyDown\"\n-+â”Š  â”Š 5â”Š    }\n-+â”Š  â”Š 6â”Š  }\n-+â”Š  â”Š 7â”Š\n-+â”Š  â”Š 8â”Š  onKeyDown() {\n-+â”Š  â”Š 9â”Š    // Once escape is pressed, return to main menu screen\n-+â”Š  â”Š10â”Š    if (this.keyStates.get(27)) {\n-+â”Š  â”Š11â”Š      this.game.changeScreen(Game.Screens.Menu);\n-+â”Š  â”Š12â”Š    }\n-+â”Š  â”Š13â”Š  }\n-+â”Š  â”Š14â”Š};ðŸš«â†µ\n-```\n-\n-##### Changed views/game.html\n-```diff\n-@@ -23,6 +23,7 @@\n- â”Š23â”Š23â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/assets_loader.js\"></script>\n- â”Š24â”Š24â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n- â”Š25â”Š25â”Š    <script type=\"text/javascript\" src=\"/scripts/game/entities/snake.js\"></script>\n-+â”Š  â”Š26â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/index.js\"></script>\n- â”Š26â”Š27â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/menu/index.js\"></script>\n- â”Š27â”Š28â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/splash/index.js\"></script>\n- â”Š28â”Š29â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n-```\n-[}]: #\n-\n-Now that we have the `Play` screen, we need to hook it to the `Menu` screen, so whenever we press a key, we will be proceeded to it:\n-\n-[{]: <helper> (diff_step 6.2)\n-#### Step 6.2: Hook 'Play' screen to 'menu' screen\n-\n-##### Changed resources/scripts/game/screens/menu/index.js\n-```diff\n-@@ -1,4 +1,10 @@\n- â”Š 1â”Š 1â”ŠGame.Screens.Menu = class Menu extends Engine.Screen {\n-+â”Š  â”Š 2â”Š  get events() {\n-+â”Š  â”Š 3â”Š    return {\n-+â”Š  â”Š 4â”Š      \"keydown\": \"onKeyDown\"\n-+â”Š  â”Š 5â”Š    }\n-+â”Š  â”Š 6â”Š  }\n-+â”Š  â”Š 7â”Š\n- â”Š 2â”Š 8â”Š  initialize() {\n- â”Š 3â”Š 9â”Š    // Initialize snake logo sprite\n- â”Š 4â”Š10â”Š    this.logoSprite = new Engine.Sprite(this.assets.logoTexture);\n-```\n-```diff\n-@@ -40,10 +46,18 @@\n- â”Š40â”Š46â”Š  }\n- â”Š41â”Š47â”Š\n- â”Š42â”Š48â”Š  update(span) {\n--â”Š43â”Š  â”Š    this.instructionsAnim.update(span);\n-+â”Š  â”Š49â”Š    // On key press, proceed to play screen\n-+â”Š  â”Š50â”Š    if (this.keyPressed) {\n-+â”Š  â”Š51â”Š      this.game.changeScreen(Game.Screens.Play);\n-+â”Š  â”Š52â”Š    }\n-+â”Š  â”Š53â”Š    // Else, just update animation\n-+â”Š  â”Š54â”Š    else {\n-+â”Š  â”Š55â”Š      this.instructionsAnim.update(span);\n-+â”Š  â”Š56â”Š    }\n- â”Š44â”Š57â”Š  }\n- â”Š45â”Š58â”Š\n--â”Š46â”Š  â”Š  update(span) {\n--â”Š47â”Š  â”Š    this.instructionsAnim.update(span);\n-+â”Š  â”Š59â”Š  // Register key press\n-+â”Š  â”Š60â”Š  onKeyDown(e) {\n-+â”Š  â”Š61â”Š    this.keyPressed = true;\n- â”Š48â”Š62â”Š  }\n- â”Š49â”Š63â”Š};ðŸš«â†µ\n-```\n-[}]: #\n-\n-By now there shouldn't be anything special. Once you're at the main menu, just press a key as instructed, and you shall see a black screen, which is actually the `Play` screen we've just created; And once you'll press the `Escape` key, you should be receded to the main menu.\n-\n-The next stage would be displaying a `Ready` message on the screen, and whenever a key is pressed, the message should fade away using a key-frame animation, and the match should start in the background:\n-\n-[{]: <helper> (diff_step 6.3)\n-#### Step 6.3: Create 'Ready' layer\n-\n-##### Added resources/scripts/game/screens/play/ready.js\n-```diff\n-@@ -0,0 +1,59 @@\n-+â”Š  â”Š 1â”ŠGame.Screens.Play.Ready = class Ready extends Engine.Layer {\n-+â”Š  â”Š 2â”Š  get events() {\n-+â”Š  â”Š 3â”Š    return {\n-+â”Š  â”Š 4â”Š      \"keydown\": \"onKeyDown\"\n-+â”Š  â”Š 5â”Š    };\n-+â”Š  â”Š 6â”Š  }\n-+â”Š  â”Š 7â”Š\n-+â”Š  â”Š 8â”Š  constructor(screen, snakes) {\n-+â”Š  â”Š 9â”Š    super(screen);\n-+â”Š  â”Š10â”Š\n-+â”Š  â”Š11â”Š    this.snakes = snakes;\n-+â”Š  â”Š12â”Š\n-+â”Š  â”Š13â”Š    // Create \"ready\" sprite and set its properties\n-+â”Š  â”Š14â”Š    let readyTexture = this.assets.minecraftiaFont.createTexture(\"Ready\");\n-+â”Š  â”Š15â”Š    let readySprite = new Engine.Sprite(readyTexture);\n-+â”Š  â”Š16â”Š    readySprite.align = \"center\";\n-+â”Š  â”Š17â”Š    readySprite.setPercentage(\"width\", this.width, 15, \"height\");\n-+â”Š  â”Š18â”Š\n-+â”Š  â”Š19â”Š    // Create fade out animation for \"ready\" sprite\n-+â”Š  â”Š20â”Š    this.readyAnim = new Engine.Animations.Keyframe(readySprite, [\n-+â”Š  â”Š21â”Š      {\n-+â”Š  â”Š22â”Š        x: this.width / 2,\n-+â”Š  â”Š23â”Š        y: this.height / 2,\n-+â”Š  â”Š24â”Š        opacity: 1,\n-+â”Š  â”Š25â”Š        frame: 0\n-+â”Š  â”Š26â”Š      },\n-+â”Š  â”Š27â”Š      {\n-+â”Š  â”Š28â”Š        y: this.height / 3,\n-+â”Š  â”Š29â”Š        opacity: 0,\n-+â”Š  â”Š30â”Š        frame: 700\n-+â”Š  â”Š31â”Š      }\n-+â”Š  â”Š32â”Š    ]);\n-+â”Š  â”Š33â”Š  }\n-+â”Š  â”Š34â”Š\n-+â”Š  â”Š35â”Š  draw(context) {\n-+â”Š  â”Š36â”Š    this.readyAnim.draw(context);\n-+â”Š  â”Š37â”Š  }\n-+â”Š  â”Š38â”Š\n-+â”Š  â”Š39â”Š  update(span) {\n-+â”Š  â”Š40â”Š    if (!this.ready) return;\n-+â”Š  â”Š41â”Š\n-+â”Š  â”Š42â”Š    if (this.readyAnim.playing) {\n-+â”Š  â”Š43â”Š      this.readyAnim.update(span);\n-+â”Š  â”Š44â”Š    }\n-+â”Š  â”Š45â”Š    // Once animation is finished, dispose layer\n-+â”Š  â”Š46â”Š    else {\n-+â”Š  â”Š47â”Š      this.screen.removeLayer(this);\n-+â”Š  â”Š48â”Š    }\n-+â”Š  â”Š49â”Š  }\n-+â”Š  â”Š50â”Š\n-+â”Š  â”Š51â”Š  onKeyDown() {\n-+â”Š  â”Š52â”Š    // One time event\n-+â”Š  â”Š53â”Š    this.disposeEventListeners()\n-+â”Š  â”Š54â”Š\n-+â”Š  â”Š55â”Š    // This will start playing the animation\n-+â”Š  â”Š56â”Š    this.ready = true;\n-+â”Š  â”Š57â”Š    this.readyAnim.play();\n-+â”Š  â”Š58â”Š  }\n-+â”Š  â”Š59â”Š};ðŸš«â†µ\n-```\n-\n-##### Changed views/game.html\n-```diff\n-@@ -24,6 +24,7 @@\n- â”Š24â”Š24â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n- â”Š25â”Š25â”Š    <script type=\"text/javascript\" src=\"/scripts/game/entities/snake.js\"></script>\n- â”Š26â”Š26â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/index.js\"></script>\n-+â”Š  â”Š27â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/ready.js\"></script>\n- â”Š27â”Š28â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/menu/index.js\"></script>\n- â”Š28â”Š29â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/splash/index.js\"></script>\n- â”Š29â”Š30â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n-```\n-[}]: #\n-\n-In order to hook the `Ready` layer to the `Play` screen, we will just push a new instance of it to the layers stack, using the screen's `appendLayer` method. Note that the order of the layer is super critic! Since if we push a new layer it means it will be drawn on top of any previous layer. To \"shift\" a layer to the layers stack, we can simply use the `prependLayer` method instead. Without further due, this is how our hook should look like:\n-\n-[{]: <helper> (diff_step 6.4)\n-#### Step 6.4: Hook 'Ready' layer to 'Play' screen\n-\n-##### Changed resources/scripts/game/screens/play/index.js\n-```diff\n-@@ -5,6 +5,11 @@\n- â”Š 5â”Š 5â”Š    }\n- â”Š 6â”Š 6â”Š  }\n- â”Š 7â”Š 7â”Š\n-+â”Š  â”Š 8â”Š  // The ready screen will be the initial screen\n-+â”Š  â”Š 9â”Š  initialize(game, snakes) {\n-+â”Š  â”Š10â”Š    this.appendLayer(Game.Screens.Play.Ready, snakes);\n-+â”Š  â”Š11â”Š  }\n-+â”Š  â”Š12â”Š\n- â”Š 8â”Š13â”Š  onKeyDown() {\n- â”Š 9â”Š14â”Š    // Once escape is pressed, return to main menu screen\n- â”Š10â”Š15â”Š    if (this.keyStates.get(27)) {\n-```\n-[}]: #\n-\n-Now if you'll launch the game and start a new match, you should see a white `Ready` message in the middle of the screen. Up next, would be the `Snake` layer, which will simply initialize 2 new `Snake` instances, and take care of drawing and updating them:\n-\n-[{]: <helper> (diff_step 6.5)\n-#### Step 6.5: Create 'snake' layer\n-\n-##### Added resources/scripts/game/screens/play/snake.js\n-```diff\n-@@ -0,0 +1,79 @@\n-+â”Š  â”Š 1â”ŠGame.Screens.Play.Snake = class Snake extends Engine.Layer {\n-+â”Š  â”Š 2â”Š  constructor(screen, snakes = []) {\n-+â”Š  â”Š 3â”Š    super(screen);\n-+â”Š  â”Š 4â”Š\n-+â”Š  â”Š 5â”Š    // Red snake\n-+â”Š  â”Š 6â”Š    this.snakes = [\n-+â”Š  â”Š 7â”Š      new Game.Entities.Snake(\n-+â”Š  â”Š 8â”Š        this.width / 4,\n-+â”Š  â”Š 9â”Š        this.height / 4,\n-+â”Š  â”Š10â”Š        50,\n-+â”Š  â”Š11â”Š        Math.PI / 4,\n-+â”Š  â”Š12â”Š        100,\n-+â”Š  â”Š13â”Š        \"FireBrick\",\n-+â”Š  â”Š14â”Š        this.keyStates,\n-+â”Š  â”Š15â”Š        {\n-+â”Š  â”Š16â”Š          // Use score from previous matches\n-+â”Š  â”Š17â”Š          score: snakes[0] && snakes[0].score,\n-+â”Š  â”Š18â”Š          keys: {\n-+â”Š  â”Š19â”Š            left: 37, // Left key\n-+â”Š  â”Š20â”Š            right: 39 // RIght key\n-+â”Š  â”Š21â”Š        }\n-+â”Š  â”Š22â”Š      }),\n-+â”Š  â”Š23â”Š\n-+â”Š  â”Š24â”Š      // Blue snake\n-+â”Š  â”Š25â”Š      new Game.Entities.Snake(\n-+â”Š  â”Š26â”Š        (this.width / 4) * 3,\n-+â”Š  â”Š27â”Š        (this.height / 4) * 3,\n-+â”Š  â”Š28â”Š        50,\n-+â”Š  â”Š29â”Š        (-Math.PI / 4) * 3,\n-+â”Š  â”Š30â”Š        100,\n-+â”Š  â”Š31â”Š        \"DodgerBlue\",\n-+â”Š  â”Š32â”Š        this.keyStates,\n-+â”Š  â”Š33â”Š        {\n-+â”Š  â”Š34â”Š          score: snakes[1] && snakes[1].score,\n-+â”Š  â”Š35â”Š          keys: {\n-+â”Š  â”Š36â”Š            left: 65, // 'a' key\n-+â”Š  â”Š37â”Š            right: 68 // 'b' key\n-+â”Š  â”Š38â”Š        }\n-+â”Š  â”Š39â”Š      })\n-+â”Š  â”Š40â”Š    ];\n-+â”Š  â”Š41â”Š  }\n-+â”Š  â”Š42â”Š\n-+â”Š  â”Š43â”Š  draw(context) {\n-+â”Š  â”Š44â”Š    // Draw each snake in the snakes array\n-+â”Š  â”Š45â”Š    this.snakes.forEach(snake => snake.draw(context));\n-+â”Š  â”Š46â”Š  }\n-+â”Š  â”Š47â”Š\n-+â”Š  â”Š48â”Š  update(span) {\n-+â”Š  â”Š49â”Š    if (!this.snakes.length) return;\n-+â”Š  â”Š50â”Š\n-+â”Š  â”Š51â”Š    // Storing original snakes array for future use, since it might get changed\n-+â”Š  â”Š52â”Š    let snakes = this.snakes.slice();\n-+â”Š  â”Š53â”Š\n-+â”Š  â”Š54â”Š    snakes.forEach((snake, index) => {\n-+â”Š  â”Š55â”Š      snake.update(span, this.width, this.height);\n-+â”Š  â”Š56â”Š      // Disqualify if intersected with self\n-+â”Š  â”Š57â”Š      if (snake.getSelfIntersection()) return this.snakes.splice(index, 1);\n-+â”Š  â”Š58â”Š\n-+â”Š  â”Š59â”Š      snakes.forEach((opponent) => {\n-+â”Š  â”Š60â”Š        // Don't scan for intersection with self, obviously this will always be true\n-+â”Š  â”Š61â”Š        if (opponent === snake) return;\n-+â”Š  â”Š62â”Š        // Disqualify if intersected with opponent\n-+â”Š  â”Š63â”Š        if (snake.getSnakeIntersection(opponent)) this.snakes.splice(index, 1);\n-+â”Š  â”Š64â”Š      });\n-+â”Š  â”Š65â”Š    });\n-+â”Š  â”Š66â”Š\n-+â”Š  â”Š67â”Š    // There can be only one winner, or a tie (very rare, most likely not to happen)\n-+â”Š  â”Š68â”Š    // If the match is already finished, skip the next steps since they are not relevant\n-+â”Š  â”Š69â”Š    if (this.snakes.length > 1 || this.matchFinished) return;\n-+â”Š  â”Š70â”Š\n-+â”Š  â”Š71â”Š    // The winner is the \"last snake standing\"\n-+â”Š  â”Š72â”Š    let winner = this.snakes[0];\n-+â”Š  â”Š73â”Š    // If this is not a tie, which is a very rare case, increase the winner's score\n-+â”Š  â”Š74â”Š    if (winner) winner.score++;\n-+â”Š  â”Š75â”Š\n-+â”Š  â”Š76â”Š    // Indicates whether we should update the score counter or not\n-+â”Š  â”Š77â”Š    this.matchFinished = true;\n-+â”Š  â”Š78â”Š  }\n-+â”Š  â”Š79â”Š};ðŸš«â†µ\n-```\n-\n-##### Changed views/game.html\n-```diff\n-@@ -24,6 +24,7 @@\n- â”Š24â”Š24â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n- â”Š25â”Š25â”Š    <script type=\"text/javascript\" src=\"/scripts/game/entities/snake.js\"></script>\n- â”Š26â”Š26â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/index.js\"></script>\n-+â”Š  â”Š27â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/snake.js\"></script>\n- â”Š27â”Š28â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/ready.js\"></script>\n- â”Š28â”Š29â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/menu/index.js\"></script>\n- â”Š29â”Š30â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/splash/index.js\"></script>\n-```\n-[}]: #\n-\n-Once pressing a key in the `Ready` layer, not only we want to display an animation, but we also want the match to start in the background, thus, we gonna push a new instance of the `Snake` layer we've just created like so:\n-\n-[{]: <helper> (diff_step 6.6)\n-#### Step 6.6: Hook 'snake' layer to 'ready' layer\n-\n-##### Changed resources/scripts/game/screens/play/ready.js\n-```diff\n-@@ -55,5 +55,8 @@\n- â”Š55â”Š55â”Š    // This will start playing the animation\n- â”Š56â”Š56â”Š    this.ready = true;\n- â”Š57â”Š57â”Š    this.readyAnim.play();\n-+â”Š  â”Š58â”Š\n-+â”Š  â”Š59â”Š    // Start the game in the background\n-+â”Š  â”Š60â”Š    this.screen.prependLayer(Game.Screens.Play.Snake, this.snakes);\n- â”Š58â”Š61â”Š  }\n- â”Š59â”Š62â”Š};ðŸš«â†µ\n-```\n-[}]: #\n-\n-Note that the layer is pushed when the animation starts and not once finished; This would give a nice smooth feeling to our game-flow. If you'll test out the game, you would discover that the match is actually playable! The first snake (Red) snake should be controlled by the arrow keys, and the second snake (Blue) should be controlled by the letter keys `a`, `s`, `d` and `w`. So far, the snakes function great, but you can probably tell that whenever a match is finished, it feels a bit dull. There's no indication of winning, and there's no score board to present the score of each competitor, which brings us to the next stage - Implementing the `Score` layer.\n-\n-The `Score` layer is a simple layer which takes the 2 snakes as a parameter and displays their scores at the top of the screen:\n-\n-[{]: <helper> (diff_step 6.7)\n-#### Step 6.7: Create 'Score' layer\n-\n-##### Added resources/scripts/game/screens/play/score.js\n-```diff\n-@@ -0,0 +1,66 @@\n-+â”Š  â”Š 1â”ŠGame.Screens.Play.Score = class Score extends Engine.Layer {\n-+â”Š  â”Š 2â”Š  constructor(screen, snakes) {\n-+â”Š  â”Š 3â”Š    super(screen);\n-+â”Š  â”Š 4â”Š\n-+â”Š  â”Š 5â”Š    this.snakes = snakes;\n-+â”Š  â”Š 6â”Š    this.scoreSprites = [];\n-+â”Š  â”Š 7â”Š    this.scores = [];\n-+â”Š  â”Š 8â”Š\n-+â”Š  â”Š 9â”Š    // It's important to match indexes to each snake since the number of snakes\n-+â”Š  â”Š10â”Š    // can be reduced along the way as we play\n-+â”Š  â”Š11â”Š    snakes.forEach((snake, index) => {\n-+â”Š  â”Š12â”Š      snake.index = index;\n-+â”Š  â”Š13â”Š    });\n-+â”Š  â”Š14â”Š  }\n-+â”Š  â”Š15â”Š\n-+â”Š  â”Š16â”Š  draw(context) {\n-+â”Š  â”Š17â”Š    this.scoreSprites.forEach((scoreSprite) => {\n-+â”Š  â”Š18â”Š      scoreSprite.draw(context);\n-+â”Š  â”Š19â”Š    });\n-+â”Š  â”Š20â”Š  }\n-+â”Š  â”Š21â”Š\n-+â”Š  â”Š22â”Š  update(span) {\n-+â”Š  â”Š23â”Š    this.snakes.forEach(snake => {\n-+â”Š  â”Š24â”Š      let index = snake.index;\n-+â”Š  â”Š25â”Š      if (this.scores[index] == snake.score) return;\n-+â”Š  â”Š26â”Š\n-+â”Š  â”Š27â”Š      // The sprite might be changed along the way so it's important to recreate it\n-+â”Š  â”Š28â”Š      // over and over again. If no change was made the cache will be used by the engine\n-+â”Š  â”Š29â”Š      this.scoreSprites[index] = this.createScoreSprite(snake);\n-+â”Š  â”Š30â”Š      this.scores[index] = snake.score;\n-+â”Š  â”Š31â”Š    });\n-+â”Š  â”Š32â”Š  }\n-+â”Š  â”Š33â”Š\n-+â”Š  â”Š34â”Š  createScoreSprite(snake) {\n-+â”Š  â”Š35â”Š    let minecraftiaFont = this.assets.minecraftiaFont;\n-+â”Š  â”Š36â”Š    minecraftiaFont.save();\n-+â”Š  â”Š37â”Š    minecraftiaFont.color = snake.color;\n-+â”Š  â”Š38â”Š\n-+â”Š  â”Š39â”Š    // Create a score sprite for the snake\n-+â”Š  â”Š40â”Š    let scoreTexture = minecraftiaFont.createTexture(`${snake.score}`, {\n-+â”Š  â”Š41â”Š      noOffsets: true,\n-+â”Š  â”Š42â”Š      noSpaces: true\n-+â”Š  â”Š43â”Š    });\n-+â”Š  â”Š44â”Š\n-+â”Š  â”Š45â”Š    let scoreSprite = new Engine.Sprite(scoreTexture);\n-+â”Š  â”Š46â”Š\n-+â”Š  â”Š47â”Š    // Size of score board is dynamic to screen size\n-+â”Š  â”Š48â”Š    scoreSprite.setPercentage(\"width\", this.width, 4, \"height\");\n-+â”Š  â”Š49â”Š\n-+â”Š  â”Š50â”Š    // Set alignment modes.\n-+â”Š  â”Š51â”Š    // Once we add more snakes we should add more cases here\n-+â”Š  â”Š52â”Š    switch (snake.index) {\n-+â”Š  â”Š53â”Š      case 0:\n-+â”Š  â”Š54â”Š        scoreSprite.align = \"top-left\";\n-+â”Š  â”Š55â”Š        break;\n-+â”Š  â”Š56â”Š      case 1:\n-+â”Š  â”Š57â”Š        scoreSprite.align = \"top-right\";\n-+â”Š  â”Š58â”Š        scoreSprite.x = this.width;\n-+â”Š  â”Š59â”Š        break;\n-+â”Š  â”Š60â”Š    }\n-+â”Š  â”Š61â”Š\n-+â”Š  â”Š62â”Š    // Restore the font to its original color\n-+â”Š  â”Š63â”Š    minecraftiaFont.restore();\n-+â”Š  â”Š64â”Š    return scoreSprite;\n-+â”Š  â”Š65â”Š  }\n-+â”Š  â”Š66â”Š};ðŸš«â†µ\n-```\n-\n-##### Changed views/game.html\n-```diff\n-@@ -24,6 +24,7 @@\n- â”Š24â”Š24â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n- â”Š25â”Š25â”Š    <script type=\"text/javascript\" src=\"/scripts/game/entities/snake.js\"></script>\n- â”Š26â”Š26â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/index.js\"></script>\n-+â”Š  â”Š27â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/score.js\"></script>\n- â”Š27â”Š28â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/snake.js\"></script>\n- â”Š28â”Š29â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/ready.js\"></script>\n- â”Š29â”Š30â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/menu/index.js\"></script>\n-```\n-[}]: #\n-\n-> Note that the current score board is suitable for two players, but can easily be modified to support as much players as you want if done correctly.\n-\n-The `Score` board should be appended to the layers stack as soon as the `Snake` layers is initialized, so it would be available to us once the match is started:\n-\n-[{]: <helper> (diff_step 6.8)\n-#### Step 6.8: Hook 'Score' layer to 'Snake' layer\n-\n-##### Changed resources/scripts/game/screens/play/snake.js\n-```diff\n-@@ -38,6 +38,9 @@\n- â”Š38â”Š38â”Š        }\n- â”Š39â”Š39â”Š      })\n- â”Š40â”Š40â”Š    ];\n-+â”Š  â”Š41â”Š\n-+â”Š  â”Š42â”Š    // Show score board for newly created snakes\n-+â”Š  â”Š43â”Š    screen.appendLayer(Game.Screens.Play.Score, this.snakes);\n- â”Š41â”Š44â”Š  }\n- â”Š42â”Š45â”Š\n- â”Š43â”Š46â”Š  draw(context) {\n-```\n-[}]: #\n-\n-Now we're one layer further from completing the `Play` screen, the only thing missing is the `Win` layer, which should present the winner once the match is finished:\n-\n-[{]: <helper> (diff_step 6.9)\n-#### Step 6.9: Create 'Win' layer\n-\n-##### Added resources/scripts/game/screens/play/win.js\n-```diff\n-@@ -0,0 +1,43 @@\n-+â”Š  â”Š 1â”ŠGame.Screens.Play.Win = class Win extends Engine.Layer {\n-+â”Š  â”Š 2â”Š  constructor(screen, snakes, winner) {\n-+â”Š  â”Š 3â”Š    super(screen);\n-+â”Š  â”Š 4â”Š\n-+â”Š  â”Š 5â”Š    this.snakes = snakes;\n-+â”Š  â”Š 6â”Š    this.winner = winner;\n-+â”Š  â”Š 7â”Š    // ttl stands for \"time to live\", which means, this layer is going to be\n-+â”Š  â”Š 8â”Š    // disposed after 3 seconds\n-+â”Š  â”Š 9â”Š    this.ttl = 3000;\n-+â”Š  â”Š10â”Š\n-+â”Š  â”Š11â”Š    // If there is a winner\n-+â”Š  â”Š12â”Š    if (this.winner) {\n-+â”Š  â”Š13â”Š      // Message could be something like \"RED SNAKE WINS\"\n-+â”Š  â”Š14â”Š      var text = `${this.winner.color.toUpperCase()} SNAKE WINS`;\n-+â”Š  â”Š15â”Š      var percent = 40;\n-+â”Š  â”Š16â”Š    }\n-+â”Š  â”Š17â”Š    // If there is a tie\n-+â”Š  â”Š18â”Š    else {\n-+â”Š  â”Š19â”Š      var text = 'TIE';\n-+â”Š  â”Š20â”Š      var percent = 15;\n-+â”Š  â”Š21â”Š    }\n-+â”Š  â”Š22â”Š\n-+â”Š  â”Š23â”Š    // Create winner sprite and set its properties\n-+â”Š  â”Š24â”Š    let winnerTexture = this.assets.minecraftiaFont.createTexture(text);\n-+â”Š  â”Š25â”Š    this.winnerSprite = new Engine.Sprite(winnerTexture);\n-+â”Š  â”Š26â”Š    this.winnerSprite.align = \"center\";\n-+â”Š  â”Š27â”Š    this.winnerSprite.setPercentage(\"width\", this.width, percent, \"height\");\n-+â”Š  â”Š28â”Š    this.winnerSprite.x = this.width / 2;\n-+â”Š  â”Š29â”Š    this.winnerSprite.y = this.height / 2;\n-+â”Š  â”Š30â”Š  }\n-+â”Š  â”Š31â”Š\n-+â”Š  â”Š32â”Š  draw(context) {\n-+â”Š  â”Š33â”Š    this.winnerSprite.draw(context);\n-+â”Š  â”Š34â”Š  }\n-+â”Š  â”Š35â”Š\n-+â”Š  â”Š36â”Š  update(span) {\n-+â”Š  â”Š37â”Š    // If limit not yet reached, abort\n-+â”Š  â”Š38â”Š    if (this.age < this.ttl) return;\n-+â”Š  â”Š39â”Š\n-+â”Š  â”Š40â”Š    // Show \"ready\" message all over again, only this time use the updated score board\n-+â”Š  â”Š41â”Š    this.screen.game.changeScreen(Game.Screens.Play, this.snakes);\n-+â”Š  â”Š42â”Š  }\n-+â”Š  â”Š43â”Š};ðŸš«â†µ\n-```\n-\n-##### Changed views/game.html\n-```diff\n-@@ -24,6 +24,7 @@\n- â”Š24â”Š24â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n- â”Š25â”Š25â”Š    <script type=\"text/javascript\" src=\"/scripts/game/entities/snake.js\"></script>\n- â”Š26â”Š26â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/index.js\"></script>\n-+â”Š  â”Š27â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/win.js\"></script>\n- â”Š27â”Š28â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/score.js\"></script>\n- â”Š28â”Š29â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/snake.js\"></script>\n- â”Š29â”Š30â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/ready.js\"></script>\n-```\n-[}]: #\n-\n-Note how we use the `changeScreen` method once the `Win` layer has reached its age limit (Time to live, aka `ttl`); This would clear the layers stack and restart the `Play` screen, so we can start a new match all-over, only this time we will pass the `Snake` instances to reserve the original scores. The `Win` layer should be presented whenever a collision has been detected between the snakes:\n-\n-[{]: <helper> (diff_step 6.10)\n-#### Step 6.10: Hook 'Win' layer to 'Snake' layer\n-\n-##### Changed resources/scripts/game/screens/play/snake.js\n-```diff\n-@@ -76,7 +76,13 @@\n- â”Š76â”Š76â”Š    // If this is not a tie, which is a very rare case, increase the winner's score\n- â”Š77â”Š77â”Š    if (winner) winner.score++;\n- â”Š78â”Š78â”Š\n--â”Š79â”Š  â”Š    // Indicates whether we should update the score counter or not\n-+â”Š  â”Š79â”Š    // Show a message saying the result (e.g., \"red snake wins\")\n-+â”Š  â”Š80â”Š    this.screen.appendLayer(Game.Screens.Play.Win, snakes, winner);\n-+â”Š  â”Š81â”Š\n-+â”Š  â”Š82â”Š    // Indicates whether we should update the score counter or not.\n-+â”Š  â”Š83â”Š    // In addition, will prevent from the 'winner' message from appearing multiple times,\n-+â”Š  â”Š84â”Š    // otherwise memory is gonna be wasted despite the fact that we're not going to see\n-+â”Š  â”Š85â”Š    // any visual difference\n- â”Š80â”Š86â”Š    this.matchFinished = true;\n- â”Š81â”Š87â”Š  }\n- â”Š82â”Š88â”Š};ðŸš«â†µ\n-```\n-[}]: #\n-\n-That's it folks, the `Play` screen is finished, and you can play as much matches as you'd feel like.\n-\n-Although the game is finished, it can still be optimized using `C++`. To discover more on hooking efficiency and how we can hook `C++` to the browser, see the next step.\n-[}]: #\n-[{]: <region> (footer)\n-[{]: <helper> (nav_step)\n-| [< Previous Step](step5.md) | [Next Step >](step7.md) |\n-|:--------------------------------|--------------------------------:|\n-[}]: #\n-[}]: #\n\\ No newline at end of file\ndiff --git a/manuals/views/step7.md b/manuals/views/step7.md\ndeleted file mode 100644\nindex 3d3d3e3..0000000\n--- a/manuals/views/step7.md\n+++ /dev/null\n@@ -1,2249 +0,0 @@\n-[{]: <region> (header)\n-# Step 7: Bonus! Re-implementing geometry in C++\n-[}]: #\n-[{]: <region> (body)\n-> This step is part of a bigger tutorial series where we learn how to create a game engine and implement a Tron-style game in JavaScript. The base project for the following step is available [here](https://github.com/DAB0mB/radial-snake/tree/step6).\n-\n-So far I covered up pretty much everything I planned. I showed you how to create a game engine, including a font generator, an animation player and a screening system. On top of that, we've learned how to structure and organize our code well, so if in the future we'd like to extend our game by adding more screens or capabilities, we can do that with ease. Indeed, we've went through lots of great stuff, and if you've reached this point I give you my thumbs up. If so far this wasn't enough, in this step we will be focusing on optimization, and making our game engine run faster (a lot, faster). Obviously, when talking about optimizations, the first thing you would probably think of is how we can make our algorithms efficient by using minimum number of operations. While this is true, we will be actually focusing on optimizing our code using C++.\n-\n-Unlike JavaScript, which is a dynamic scripting file executed by an interpreter, C++ is a general purpose language which compiles into executables. Naturally, executables are much faster than scripts, since they don't have to be interpreted, and they can approach the hardware and memory much faster. In C++, we have to explicitly define our data-types, meaning that variables don't have to be parsed during run-time. While explicit variables definition is C++'s biggest drawback, it's also one of its biggest advantages. The mere fact that variables can be handled much faster, makes code much more efficient.\n-\n-Accordingly, we can conclude that the programming language we're using plays a very important role when it comes to efficiency. So how exactly are we going to integrate C++ into the browser? We're going to do that by using a compiler called - [Emscripten](http://kripken.github.io/emscripten-site/).\n-\n-![emscripten](https://cloud.githubusercontent.com/assets/7648874/22675449/ee6d7e9c-eccc-11e6-9570-1dd5d982ee66.png)\n-\n-Emscripten is an Open Source [LLVM](https://en.wikipedia.org/wiki/LLVM) to JavaScript compiler. Using Emscripten you can:\n-\n-- Compile C and C++ code into JavaScript\n-- Compile any other code that can be translated into LLVM bitcode into JavaScript.\n-- Compile the C/C++ runtimes of other languages into JavaScript, and then run code in those other languages in an indirect way (this has been done for Python and Lua)!\n-\n-LLVM is a library that is used to construct, optimize and produce intermediate and/or binary machine code. LLVM can be used as a compiler framework, where you provide the \"front end\" (parser and lexer) and the \"back end\" (code that converts LLVM's representation to actual machine code). LLVM can also act as a JIT compiler - it has support for x86/x86_64 and PPC/PPC64 assembly generation with fast code optimizations aimed for compilation speed.\n-\n-Emscripten operates by taking LLVM code and converting it into a subset of JavaScript called asm.js that can run anywhere that JavaScript can run (usually the browser, but also Node.js, etc.) and is easy for browsers to optimize. This means that you can basically write web applications in any language that has an LLVM compiler.\n-\n-![emscripten-flow](https://cloud.githubusercontent.com/assets/7648874/22675751/b244b76c-ecce-11e6-917e-f7039ed4b340.png)\n-\n-In order to use Emscripten you will first have to install it. I recommend you to follow Emscripten's official installation instructions at their website over [here](https://kripken.github.io/emscripten-site/docs/getting_started/downloads.html). Installing Emscripten might be a bit tiring for some, I know for me it was, but if you're hyped about writing native code in the browser as much as I do, take as much time as needed to install it, and bare with me.\n-\n-Assuming that you have Emscripten installed, we can get right to business. The goal for this step is to re-implement our geometry namespace in C++, and to be more specific, the circle class and line class. We will start by creating an entry file for our C++ code under the path `resources/cpp/src/index.cpp`:\n-\n-    $ mkdir resources/cpp\n-    $ mkdir resources/cpp/src\n-    $ touch resources/cpp/src/index.cpp\n-\n-From now on, every C++ file that we would like to run in the browser should be included in the `index.cpp` file we've just created, otherwise it's not going to appear anywhere. The first stage for re-implementing our geometry would be re-writing the utility module, since our geometry is heavily based on it; Therefore the firs inclusion in our `index.cpp` file would be the following:\n-\n-[{]: <helper> (diff_step 7.1)\n-#### Step 7.1: Add CPP entry script\n-\n-##### Added resources/cpp/src/index.cpp\n-```diff\n-@@ -0,0 +1 @@\n-+â”Š â”Š1â”Š#include \"utils.cpp\"ðŸš«â†µ\n-```\n-[}]: #\n-\n-Following that, we will create the `utils.cpp` module included above, which is a direct translation from C++ to JavaScript for the `utils.js` we've created earlier in this tutorial.\n-\n-[{]: <helper> (diff_step 7.2)\n-#### Step 7.2: Add base utility CPP module\n-\n-##### Added resources/cpp/src/utils.cpp\n-```diff\n-@@ -0,0 +1,73 @@\n-+â”Š  â”Š 1â”Š#include <cfloat>\n-+â”Š  â”Š 2â”Š#include <cmath>\n-+â”Š  â”Š 3â”Š#include <string>\n-+â”Š  â”Š 4â”Š#include \"utils.h\"\n-+â”Š  â”Š 5â”Š\n-+â”Š  â”Š 6â”Šnamespace utils {\n-+â”Š  â”Š 7â”Š  // Fixed modulo method which can calculate modulo of negative numbers properly\n-+â”Š  â”Š 8â”Š  // e.g. (-803).mod(800) returns 797\n-+â”Š  â”Š 9â”Š  double mod(double context, double num) {\n-+â”Š  â”Š10â”Š    return std::fmod((std::fmod(context, num) + num), num);\n-+â”Š  â”Š11â”Š  }\n-+â”Š  â”Š12â”Š\n-+â”Š  â”Š13â”Š  // Trims number and leaves the number of decimals specified.\n-+â”Š  â”Š14â”Š  // The \"mode\" argument specifies which math function should be invoked\n-+â”Š  â”Š15â”Š  // right after the number has been trimmed.\n-+â”Š  â”Š16â”Š  // e.g. 12.12345.trim(3, \"ceil\") returns 12.124\n-+â”Š  â”Š17â”Š  double trim(double context, int decimals, const std::string mode) {\n-+â”Š  â”Š18â”Š    double accumulator = context * std::pow(10, decimals);\n-+â”Š  â”Š19â”Š\n-+â”Š  â”Š20â”Š    if (mode.compare(\"ceil\") == 0)\n-+â”Š  â”Š21â”Š      accumulator = std::ceil(accumulator);\n-+â”Š  â”Š22â”Š    else if (mode.compare(\"floor\") == 0)\n-+â”Š  â”Š23â”Š      accumulator = std::floor(accumulator);\n-+â”Š  â”Š24â”Š    else\n-+â”Š  â”Š25â”Š      accumulator = std::round(accumulator);\n-+â”Š  â”Š26â”Š\n-+â”Š  â”Š27â”Š    return accumulator / std::pow(10, decimals);\n-+â”Š  â”Š28â”Š  }\n-+â”Š  â”Š29â”Š\n-+â”Š  â”Š30â”Š  // Tells if number is in specified range based on given precision.\n-+â”Š  â”Š31â”Š  // See the \"compare\" method for more information about precision\n-+â”Š  â”Š32â”Š  bool isBetween(double context, double num1, double num2, const std::string precision) {\n-+â”Š  â”Š33â”Š    return compare(context, std::min(num1, num2), \">=\", precision) &&\n-+â”Š  â”Š34â”Š           compare(context, std::max(num1, num2), \"<=\", precision);\n-+â”Š  â”Š35â”Š  }\n-+â”Š  â”Š36â”Š\n-+â”Š  â”Š37â”Š  bool compare(double context, double num, const std::string precision) {\n-+â”Š  â”Š38â”Š    return compare(context, num, \"==\", precision);\n-+â”Š  â”Š39â”Š  }\n-+â”Š  â”Š40â”Š\n-+â”Š  â”Š41â”Š  // Initiates comparison operator between context number and a given number, only here\n-+â”Š  â”Š42â”Š  // a precision can be specified\n-+â”Š  â”Š43â”Š  bool compare(double context, double num, const std::string method, const std::string precision) {\n-+â”Š  â”Š44â”Š    // Fixed precision, \"almost equal\" with a deviation of Îµ\n-+â”Š  â”Š45â”Š    if (precision.compare(\"f\") == 0) {\n-+â”Š  â”Š46â”Š      if (method.compare(\"<\") == 0 ||\n-+â”Š  â”Š47â”Š          method.compare(\"<=\") == 0)\n-+â”Š  â”Š48â”Š        return context <= num + DBL_EPSILON;\n-+â”Š  â”Š49â”Š      if (method.compare(\">\") == 0 ||\n-+â”Š  â”Š50â”Š          method.compare(\">=\") == 0)\n-+â”Š  â”Š51â”Š        return context >= num - DBL_EPSILON;\n-+â”Š  â”Š52â”Š      return std::abs(context - num) <= DBL_EPSILON;\n-+â”Š  â”Š53â”Š    }\n-+â”Š  â”Š54â”Š    // Pixel precision, round comparison\n-+â”Š  â”Š55â”Š    else if (precision.compare(\"px\") == 0) {\n-+â”Š  â”Š56â”Š      if (method.compare(\"<\") == 0 ||\n-+â”Š  â”Š57â”Š          method.compare(\"<=\") == 0)\n-+â”Š  â”Š58â”Š        return std::round(context) <= std::round(num);\n-+â”Š  â”Š59â”Š      if (method.compare(\">\") == 0 ||\n-+â”Š  â”Š60â”Š          method.compare(\">=\") == 0)\n-+â”Š  â”Š61â”Š        return std::round(context) >= std::round(num);\n-+â”Š  â”Š62â”Š      return std::round(context) == std::round(num);\n-+â”Š  â”Š63â”Š    }\n-+â”Š  â”Š64â”Š    // Exact precision\n-+â”Š  â”Š65â”Š    else {\n-+â”Š  â”Š66â”Š      if (method.compare(\"<\") == 0) return context < num;\n-+â”Š  â”Š67â”Š      if (method.compare(\"<=\") == 0) return context <= num;\n-+â”Š  â”Š68â”Š      if (method.compare(\">\") == 0) return context > num;\n-+â”Š  â”Š69â”Š      if (method.compare(\">=\") == 0) return context >= num;\n-+â”Š  â”Š70â”Š      return context == num;\n-+â”Š  â”Š71â”Š    }\n-+â”Š  â”Š72â”Š  }\n-+â”Š  â”Š73â”Š}ðŸš«â†µ\n-```\n-\n-##### Added resources/cpp/src/utils.h\n-```diff\n-@@ -0,0 +1,15 @@\n-+â”Š  â”Š 1â”Š#pragma once\n-+â”Š  â”Š 2â”Š\n-+â”Š  â”Š 3â”Š#include <string>\n-+â”Š  â”Š 4â”Š\n-+â”Š  â”Š 5â”Šnamespace utils {\n-+â”Š  â”Š 6â”Š  double mod(double context, double num);\n-+â”Š  â”Š 7â”Š\n-+â”Š  â”Š 8â”Š  double trim(double context, int decimals, const std::string mode = \"round\");\n-+â”Š  â”Š 9â”Š\n-+â”Š  â”Š10â”Š  bool isBetween(double context, double num1, double num2, const std::string precision = \"exact\");\n-+â”Š  â”Š11â”Š\n-+â”Š  â”Š12â”Š  bool compare(double context, double num, const std::string precision = \"exact\");\n-+â”Š  â”Š13â”Š\n-+â”Š  â”Š14â”Š  bool compare(double context, double num, const std::string method, const std::string precision);\n-+â”Š  â”Š15â”Š}ðŸš«â†µ\n-```\n-[}]: #\n-\n-The module above should work by itself when interacting with it inside the C++ scope, but that's not what we're striving for. We want this module to be available for use in our JavaScript project. This requires us to wrap our code in such a way the the Emscripten compiler will know how to compile it. Apart from providing a compiler, Emscripten provides us with functions and macros that will help use bind our C++ code to the JavaScript environment. These functionalities are packed in a single library which can be imported in our C++ code, and it is called [Embind](https://kripken.github.io/emscripten-site/docs/porting/connecting_cpp_and_javascript/embind.html) (probably stands for \"Emscripten bind\"). Using EMBind, let's wrap our utils module accordingly:\n-\n-[{]: <helper> (diff_step 7.3)\n-#### Step 7.3: EMBind CPP utils\n-\n-##### Changed resources/cpp/src/utils.cpp\n-```diff\n-@@ -1,6 +1,7 @@\n- â”Š1â”Š1â”Š#include <cfloat>\n- â”Š2â”Š2â”Š#include <cmath>\n- â”Š3â”Š3â”Š#include <string>\n-+â”Š â”Š4â”Š#include <emscripten/bind.h>\n- â”Š4â”Š5â”Š#include \"utils.h\"\n- â”Š5â”Š6â”Š\n- â”Š6â”Š7â”Šnamespace utils {\n-```\n-```diff\n-@@ -70,4 +71,15 @@\n- â”Š70â”Š71â”Š      return context == num;\n- â”Š71â”Š72â”Š    }\n- â”Š72â”Š73â”Š  }\n-+â”Š  â”Š74â”Š}\n-+â”Š  â”Š75â”Š\n-+â”Š  â”Š76â”ŠEMSCRIPTEN_BINDINGS(utils_module) {\n-+â”Š  â”Š77â”Š  emscripten::function(\"utils_mod\", &utils::mod);\n-+â”Š  â”Š78â”Š  emscripten::function(\"utils_trim\", &utils::trim);\n-+â”Š  â”Š79â”Š  emscripten::function(\"utils_isBetween\", &utils::isBetween);\n-+â”Š  â”Š80â”Š  emscripten::function(\"utils_compare\",\n-+â”Š  â”Š81â”Š    emscripten::select_overload<bool(double, double, const std::string, const std::string)>(\n-+â”Š  â”Š82â”Š      &utils::compare\n-+â”Š  â”Š83â”Š    )\n-+â”Š  â”Š84â”Š  );\n- â”Š73â”Š85â”Š}ðŸš«â†µ\n-```\n-[}]: #\n-\n-After a while you'll get used for Embind's API. If you'll look at it, it's self explanatory and easy to understand. Bound objects will be available the JavaScript environment will be available under an object named `Module`, e.g. the C++ method `mod` will be available for use as `Module.utils_mod`. Bound functions should have supported return types and argument types, meaning that if we're using a custom structure as a return type or an argument type, we first need to wrap it using EMBind, otherwise the compiler won't know how to handle it. A list of natively supported data-types can be found [here](https://kripken.github.io/emscripten-site/docs/porting/connecting_cpp_and_javascript/embind.html#built-in-type-conversions).\n-\n-Even though we've wrapped our C++ code and hypothetically it can already be used in the browser, I'd go for a second wrapper, since the compiled code doesn't have the optimal architecture. Right now we will have to approach C++ utility functions using `Module.utils_foo`. Instead, I'd like it to be `CPP.Utils.foo`, since it's clearer this way. The output of the Emscripten compiler can be wrapped with JavaScript code, using a prefix and a suffix, defined in 2 separate files respectively, called `pre.js` and `post.js`:\n-\n-[{]: <helper> (diff_step 7.4)\n-#### Step 7.4: Create CPP wrappers\n-\n-##### Added resources/cpp/post.js\n-```diff\n-@@ -0,0 +1,10 @@\n-+â”Š  â”Š 1â”Šreturn {\n-+â”Š  â”Š 2â”Š  Utils: {\n-+â”Š  â”Š 3â”Š    mod: Module.utils_mod,\n-+â”Š  â”Š 4â”Š    trim: Module.utils_trim,\n-+â”Š  â”Š 5â”Š    isBetween: Module.utils_isBetween,\n-+â”Š  â”Š 6â”Š    compare: Module.utils_compare\n-+â”Š  â”Š 7â”Š  }\n-+â”Š  â”Š 8â”Š};\n-+â”Š  â”Š 9â”Š\n-+â”Š  â”Š10â”Š})();ðŸš«â†µ\n-```\n-\n-##### Added resources/cpp/pre.js\n-```diff\n-@@ -0,0 +1 @@\n-+â”Š â”Š1â”ŠCPP = (function() {ðŸš«â†µ\n-```\n-[}]: #\n-\n-What we've done in the code snippet above, we've created an anonymous function which calls itself, and inside we've exported a new namespace called `CPP` (C++). This way we can keep the generated code encapsulated, without worrying about spamming the global object.\n-\n-After creating a wrapper, I'd also recommend you to integrate the generated C++ code into existing namespaces, meaning that if for example we would like to approach the `CPP.Utils.foo` method, it could be done using `Utils.foo`. This way existing code won't have to be changed, and extra wrapping logic can be applied with ease, like the chaining logic implemented in the `Utils` namespace:\n-\n-[{]: <helper> (diff_step 7.5)\n-#### Step 7.5: Bind CPP utils to JS utils\n-\n-##### Changed resources/scripts/utils.js\n-```diff\n-@@ -16,53 +16,9 @@\n- â”Š16â”Š16â”Š  return chain;\n- â”Š17â”Š17â”Š};\n- â”Š18â”Š18â”Š\n--â”Š19â”Š  â”Š// Fixed modulo method which can calculate modulo of negative numbers properly\n--â”Š20â”Š  â”Š// e.g. (-803).mod(800) returns 797\n--â”Š21â”Š  â”ŠUtils.mod = function (context, num) {\n--â”Š22â”Š  â”Š  return ((context % num) + num) % num;\n--â”Š23â”Š  â”Š};\n--â”Š24â”Š  â”Š\n--â”Š25â”Š  â”Š// Trims number and leaves the number of decimals specified.\n--â”Š26â”Š  â”Š// The \"mode\" argument specifies which math function should be invoked\n--â”Š27â”Š  â”Š// right after the number has been trimmed.\n--â”Š28â”Š  â”Š// e.g. 12.12345.trim(3, \"ceil\") returns 12.124\n--â”Š29â”Š  â”ŠUtils.trim = function (context, decimals, mode = \"round\") {\n--â”Š30â”Š  â”Š  return Math[mode](context * Math.pow(10, decimals)) / Math.pow(10, decimals);\n--â”Š31â”Š  â”Š};\n--â”Š32â”Š  â”Š\n--â”Š33â”Š  â”Š// Tells if number is in specified range based on given precision.\n--â”Š34â”Š  â”Š// See the \"compare\" method for more information about precision\n--â”Š35â”Š  â”ŠUtils.isBetween = function (context, num1, num2, precision) {\n--â”Š36â”Š  â”Š  return Utils.compare(context, Math.min(num1, num2), \">=\", precision) &&\n--â”Š37â”Š  â”Š         Utils.compare(context, Math.max(num1, num2), \"<=\", precision);\n--â”Š38â”Š  â”Š};\n--â”Š39â”Š  â”Š\n--â”Š40â”Š  â”Š// Initiates comparison operator between context number and a given number, only here\n--â”Š41â”Š  â”Š// a precision can be specified\n--â”Š42â”Š  â”ŠUtils.compare = function (context, num, method, precision = method) {\n--â”Š43â”Š  â”Š  switch (precision) {\n--â”Š44â”Š  â”Š    // Fixed precision, \"almost equal\" with a deviation of Îµ\n--â”Š45â”Š  â”Š    case \"f\":\n--â”Š46â”Š  â”Š      switch (method) {\n--â”Š47â”Š  â”Š        case \"<\": case \"<=\": return context <= num + Number.EPSILON;\n--â”Š48â”Š  â”Š        case \">\": case \">=\": return context >= num - Number.EPSILON;\n--â”Š49â”Š  â”Š        default: return Math.abs(context - num) <= Number.EPSILON;\n--â”Š50â”Š  â”Š      }\n--â”Š51â”Š  â”Š    // Pixel precision, round comparison\n--â”Š52â”Š  â”Š    case \"px\":\n--â”Š53â”Š  â”Š      switch (method) {\n--â”Š54â”Š  â”Š        case \"<\": case \"<=\": return Math.round(context) <= Math.round(num);\n--â”Š55â”Š  â”Š        case \">\": case \">=\": return Math.round(context) >= Math.round(num);\n--â”Š56â”Š  â”Š        default: return Math.round(context) == Math.round(num);\n--â”Š57â”Š  â”Š      }\n--â”Š58â”Š  â”Š    // Exact precision\n--â”Š59â”Š  â”Š    default:\n--â”Š60â”Š  â”Š      switch (method) {\n--â”Š61â”Š  â”Š        case \"<\": return context < num;\n--â”Š62â”Š  â”Š        case \"<=\": return context <= num;\n--â”Š63â”Š  â”Š        case \">\": return context > num;\n--â”Š64â”Š  â”Š        case \">=\": return context >= num;\n--â”Š65â”Š  â”Š        default: return context === num;\n--â”Š66â”Š  â”Š      }\n-+â”Š  â”Š19â”ŠObject.assign(Utils, CPP.Utils, {\n-+â”Š  â”Š20â”Š  // Overload handling\n-+â”Š  â”Š21â”Š  compare(context, num, method, precision = method) {\n-+â”Š  â”Š22â”Š    return CPP.Utils.compare(context, num, method, precision);\n- â”Š67â”Š23â”Š  }\n--â”Š68â”Š  â”Š};ðŸš«â†µ\n-+â”Š  â”Š24â”Š});ðŸš«â†µ\n-```\n-[}]: #\n-\n-Whenever launching the compiler, the generated code should be outputted somewhere. I've decided to go with the path `resources/scripts/cpp.bundle.js`, but it doesn't matter how the file is gonna be called, as long as it's defined under the `scripts` dir, otherwise we won't be able to load it. Also, we need to make sure that we set a git-ignore rule for the generated file, since there's no reason for us to upload it to the git-host if we're planning on compiling it:\n-\n-[{]: <helper> (diff_step 7.5)\n-#### Step 7.5: Bind CPP utils to JS utils\n-\n-##### Changed resources/scripts/utils.js\n-```diff\n-@@ -16,53 +16,9 @@\n- â”Š16â”Š16â”Š  return chain;\n- â”Š17â”Š17â”Š};\n- â”Š18â”Š18â”Š\n--â”Š19â”Š  â”Š// Fixed modulo method which can calculate modulo of negative numbers properly\n--â”Š20â”Š  â”Š// e.g. (-803).mod(800) returns 797\n--â”Š21â”Š  â”ŠUtils.mod = function (context, num) {\n--â”Š22â”Š  â”Š  return ((context % num) + num) % num;\n--â”Š23â”Š  â”Š};\n--â”Š24â”Š  â”Š\n--â”Š25â”Š  â”Š// Trims number and leaves the number of decimals specified.\n--â”Š26â”Š  â”Š// The \"mode\" argument specifies which math function should be invoked\n--â”Š27â”Š  â”Š// right after the number has been trimmed.\n--â”Š28â”Š  â”Š// e.g. 12.12345.trim(3, \"ceil\") returns 12.124\n--â”Š29â”Š  â”ŠUtils.trim = function (context, decimals, mode = \"round\") {\n--â”Š30â”Š  â”Š  return Math[mode](context * Math.pow(10, decimals)) / Math.pow(10, decimals);\n--â”Š31â”Š  â”Š};\n--â”Š32â”Š  â”Š\n--â”Š33â”Š  â”Š// Tells if number is in specified range based on given precision.\n--â”Š34â”Š  â”Š// See the \"compare\" method for more information about precision\n--â”Š35â”Š  â”ŠUtils.isBetween = function (context, num1, num2, precision) {\n--â”Š36â”Š  â”Š  return Utils.compare(context, Math.min(num1, num2), \">=\", precision) &&\n--â”Š37â”Š  â”Š         Utils.compare(context, Math.max(num1, num2), \"<=\", precision);\n--â”Š38â”Š  â”Š};\n--â”Š39â”Š  â”Š\n--â”Š40â”Š  â”Š// Initiates comparison operator between context number and a given number, only here\n--â”Š41â”Š  â”Š// a precision can be specified\n--â”Š42â”Š  â”ŠUtils.compare = function (context, num, method, precision = method) {\n--â”Š43â”Š  â”Š  switch (precision) {\n--â”Š44â”Š  â”Š    // Fixed precision, \"almost equal\" with a deviation of Îµ\n--â”Š45â”Š  â”Š    case \"f\":\n--â”Š46â”Š  â”Š      switch (method) {\n--â”Š47â”Š  â”Š        case \"<\": case \"<=\": return context <= num + Number.EPSILON;\n--â”Š48â”Š  â”Š        case \">\": case \">=\": return context >= num - Number.EPSILON;\n--â”Š49â”Š  â”Š        default: return Math.abs(context - num) <= Number.EPSILON;\n--â”Š50â”Š  â”Š      }\n--â”Š51â”Š  â”Š    // Pixel precision, round comparison\n--â”Š52â”Š  â”Š    case \"px\":\n--â”Š53â”Š  â”Š      switch (method) {\n--â”Š54â”Š  â”Š        case \"<\": case \"<=\": return Math.round(context) <= Math.round(num);\n--â”Š55â”Š  â”Š        case \">\": case \">=\": return Math.round(context) >= Math.round(num);\n--â”Š56â”Š  â”Š        default: return Math.round(context) == Math.round(num);\n--â”Š57â”Š  â”Š      }\n--â”Š58â”Š  â”Š    // Exact precision\n--â”Š59â”Š  â”Š    default:\n--â”Š60â”Š  â”Š      switch (method) {\n--â”Š61â”Š  â”Š        case \"<\": return context < num;\n--â”Š62â”Š  â”Š        case \"<=\": return context <= num;\n--â”Š63â”Š  â”Š        case \">\": return context > num;\n--â”Š64â”Š  â”Š        case \">=\": return context >= num;\n--â”Š65â”Š  â”Š        default: return context === num;\n--â”Š66â”Š  â”Š      }\n-+â”Š  â”Š19â”ŠObject.assign(Utils, CPP.Utils, {\n-+â”Š  â”Š20â”Š  // Overload handling\n-+â”Š  â”Š21â”Š  compare(context, num, method, precision = method) {\n-+â”Š  â”Š22â”Š    return CPP.Utils.compare(context, num, method, precision);\n- â”Š67â”Š23â”Š  }\n--â”Š68â”Š  â”Š};ðŸš«â†µ\n-+â”Š  â”Š24â”Š});ðŸš«â†µ\n-```\n-[}]: #\n-\n-To compile our C++ code and turn it into JavaScript, we'll need to run the following command:\n-\n-    $ emcc -O1 --pre-js resources/cpp/pre.js --post-js resources/cpp/post.js --bind -o resources/scripts/cpp.bundle.js resources/cpp/src/index.cpp\n-\n-Here's a detailed list with explanations regards the arguments vector we've just passed:\n-\n-- `-01` - Optimization level 1. The higher the index, the more optimized our code is gonna be, but less readable.\n-- `--pre-js` - Specifies a JavaScript prefix for the compiled code.\n-- `--post-js` - Specifies a JavaScript postfix for the compiled code.\n-- `--bind` - Tells the compiler to use Embind\n-- `-o` - The output path.\n-\n-> More informations regards Emscripten's CLI can be found [here](https://kripken.github.io/emscripten-site/docs/tools_reference/emcc.html).\n-\n-You don't have to memorize the compilation command we've just typed, because we're gonna save it as an NPM script called `build:cpp`:\n-\n-[{]: <helper> (diff_step 7.6)\n-#### Step 7.6: Add ignore rule to CPP bundle\n-\n-##### Changed .gitignore\n-```diff\n-@@ -1,3 +1,4 @@\n- â”Š1â”Š1â”Šnode_modules\n- â”Š2â”Š2â”Šnpm-debug.log\n--â”Š3â”Š â”Šresources/assets/fonts/*.jsonðŸš«â†µ\n-+â”Š â”Š3â”Šresources/assets/fonts/*.json\n-+â”Š â”Š4â”Šresources/scripts/cpp.bundle.jsðŸš«â†µ\n-```\n-[}]: #\n-\n-Now if you'd like to compile the C++ code just run:\n-\n-    $ npm run build:cpp\n-\n-Moreover, the code should be compiled automatically any time you start the serer using the command:\n-\n-    $ npm run serve\n-\n-We always have to be on the alert and run our tests against modules we've just translated from JavaScript to C++. This will guarantee that once we run the game we won't stumble upon any defect whatsoever. Before running the tests, be sure to import the C++ bundle in the HTML file's header:\n-\n-[{]: <helper> (diff_step 7.8)\n-#### Step 7.8: Load CPP bundle in spec runner\n-\n-##### Changed views/spec_runner.html\n-```diff\n-@@ -16,6 +16,7 @@\n- â”Š16â”Š16â”Š    <script type=\"text/javascript\" src=\"libs/underscore.js\"></script>\n- â”Š17â”Š17â”Š\n- â”Š18â”Š18â”Š    <!-- Scripts -->\n-+â”Š  â”Š19â”Š    <script type=\"text/javascript\" src=\"scripts/cpp.bundle.js\"></script>\n- â”Š19â”Š20â”Š    <script type=\"text/javascript\" src=\"scripts/utils.js\"></script>\n- â”Š20â”Š21â”Š    <script type=\"text/javascript\" src=\"scripts/namespaces.js\"></script>\n- â”Š21â”Š22â”Š    <script type=\"text/javascript\" src=\"scripts/engine/geometry/line.js\"></script>\n-```\n-[}]: #\n-\n-Now we can run the tests by running the following command:\n-\n-    $ npm run test\n-\n-At this point **all our tests should pass**. If they don't, it means our newly created utility module is not working properly, and you will have to repeat the previous steps until you get it right.\n-\n-Up next, we gonna translate the geometry line class to C++. Since it's gonna be translated almost identically, we will have to make sure that all the necessary assets are gonna be available for our class before proceeding. The first thing we will have to do would be making sure that the utility functions are chainable directly from C++ as well. To do that, we will create a chain class which should return a new instance of it whenever we're about to chain the upcoming utility method. Once calling `result()`, the accumulator should be returned:\n-\n-[{]: <helper> (diff_step 7.9)\n-#### Step 7.9: Add chaining method to CPP utils\n-\n-##### Changed resources/cpp/src/utils.cpp\n-```diff\n-@@ -5,6 +5,61 @@\n- â”Š 5â”Š 5â”Š#include \"utils.h\"\n- â”Š 6â”Š 6â”Š\n- â”Š 7â”Š 7â”Šnamespace utils {\n-+â”Š  â”Š 8â”Š  template<typename T>\n-+â”Š  â”Š 9â”Š  Chain<T>::Chain(T accumulator): _accumulator(accumulator) {\n-+â”Š  â”Š10â”Š  }\n-+â”Š  â”Š11â”Š\n-+â”Š  â”Š12â”Š  template<>\n-+â”Š  â”Š13â”Š  Chain<double>* Chain<double>::mod(double num) {\n-+â”Š  â”Š14â”Š    double result = utils::mod(_accumulator, num);\n-+â”Š  â”Š15â”Š    Chain<double>* chain = new Chain<double>(result);\n-+â”Š  â”Š16â”Š    delete this;\n-+â”Š  â”Š17â”Š    return chain;\n-+â”Š  â”Š18â”Š  }\n-+â”Š  â”Š19â”Š\n-+â”Š  â”Š20â”Š  template<>\n-+â”Š  â”Š21â”Š  Chain<double>* Chain<double>::trim(int decimals, const std::string mode) {\n-+â”Š  â”Š22â”Š    double result = utils::trim(_accumulator, decimals, mode);\n-+â”Š  â”Š23â”Š    Chain<double>* chain = new Chain<double>(result);\n-+â”Š  â”Š24â”Š    delete this;\n-+â”Š  â”Š25â”Š    return chain;\n-+â”Š  â”Š26â”Š  }\n-+â”Š  â”Š27â”Š\n-+â”Š  â”Š28â”Š  template<>\n-+â”Š  â”Š29â”Š  Chain<bool>* Chain<double>::isBetween(double num1, double num2, const std::string precision) {\n-+â”Š  â”Š30â”Š    bool result = utils::isBetween(_accumulator, num1, num2, precision);\n-+â”Š  â”Š31â”Š    Chain<bool>* chain = new Chain<bool>(result);\n-+â”Š  â”Š32â”Š    delete this;\n-+â”Š  â”Š33â”Š    return chain;\n-+â”Š  â”Š34â”Š  }\n-+â”Š  â”Š35â”Š\n-+â”Š  â”Š36â”Š  template<>\n-+â”Š  â”Š37â”Š  Chain<bool>* Chain<double>::compare(double num, const std::string precision) {\n-+â”Š  â”Š38â”Š    bool result = utils::compare(_accumulator, num, precision);\n-+â”Š  â”Š39â”Š    Chain<bool>* chain = new Chain<bool>(result);\n-+â”Š  â”Š40â”Š    delete this;\n-+â”Š  â”Š41â”Š    return chain;\n-+â”Š  â”Š42â”Š  }\n-+â”Š  â”Š43â”Š\n-+â”Š  â”Š44â”Š  template<>\n-+â”Š  â”Š45â”Š  Chain<bool>* Chain<double>::compare(double num, const std::string method, const std::string precision) {\n-+â”Š  â”Š46â”Š    bool result = utils::compare(_accumulator, num, method, precision);\n-+â”Š  â”Š47â”Š    Chain<bool>* chain = new Chain<bool>(result);\n-+â”Š  â”Š48â”Š    delete this;\n-+â”Š  â”Š49â”Š    return chain;\n-+â”Š  â”Š50â”Š  }\n-+â”Š  â”Š51â”Š\n-+â”Š  â”Š52â”Š  template<typename T>\n-+â”Š  â”Š53â”Š  T Chain<T>::result() {\n-+â”Š  â”Š54â”Š    delete this;\n-+â”Š  â”Š55â”Š    return _accumulator;\n-+â”Š  â”Š56â”Š  }\n-+â”Š  â”Š57â”Š\n-+â”Š  â”Š58â”Š  template<typename T>\n-+â”Š  â”Š59â”Š  Chain<T>* chain(T accumulator) {\n-+â”Š  â”Š60â”Š    return new Chain<T>(accumulator);\n-+â”Š  â”Š61â”Š  }\n-+â”Š  â”Š62â”Š\n- â”Š 8â”Š63â”Š  // Fixed modulo method which can calculate modulo of negative numbers properly\n- â”Š 9â”Š64â”Š  // e.g. (-803).mod(800) returns 797\n- â”Š10â”Š65â”Š  double mod(double context, double num) {\n-```\n-\n-##### Changed resources/cpp/src/utils.h\n-```diff\n-@@ -3,6 +3,30 @@\n- â”Š 3â”Š 3â”Š#include <string>\n- â”Š 4â”Š 4â”Š\n- â”Š 5â”Š 5â”Šnamespace utils {\n-+â”Š  â”Š 6â”Š  template<typename T>\n-+â”Š  â”Š 7â”Š  class Chain {\n-+â”Š  â”Š 8â”Š  private:\n-+â”Š  â”Š 9â”Š    T _accumulator;\n-+â”Š  â”Š10â”Š\n-+â”Š  â”Š11â”Š  public:\n-+â”Š  â”Š12â”Š    Chain(T accumulator);\n-+â”Š  â”Š13â”Š\n-+â”Š  â”Š14â”Š    Chain<double>* mod(double num);\n-+â”Š  â”Š15â”Š\n-+â”Š  â”Š16â”Š    Chain<double>* trim(int decimals, const std::string mode = \"round\");\n-+â”Š  â”Š17â”Š\n-+â”Š  â”Š18â”Š    Chain<bool>* isBetween(double num1, double num2, const std::string precision = \"exact\");\n-+â”Š  â”Š19â”Š\n-+â”Š  â”Š20â”Š    Chain<bool>* compare(double num, const std::string precision = \"exact\");\n-+â”Š  â”Š21â”Š\n-+â”Š  â”Š22â”Š    Chain<bool>* compare(double num, const std::string method, const std::string precision);\n-+â”Š  â”Š23â”Š\n-+â”Š  â”Š24â”Š    T result();\n-+â”Š  â”Š25â”Š  };\n-+â”Š  â”Š26â”Š\n-+â”Š  â”Š27â”Š  template<typename T>\n-+â”Š  â”Š28â”Š  Chain<T>* chain(T accumulator);\n-+â”Š  â”Š29â”Š\n- â”Š 6â”Š30â”Š  double mod(double context, double num);\n- â”Š 7â”Š31â”Š\n- â”Š 8â”Š32â”Š  double trim(double context, int decimals, const std::string mode = \"round\");\n-```\n-[}]: #\n-\n-> Note that when coding in C++ we have to make sure that the objects are being disposed when not needed anymore, otherwise we will have some unnecessary memory leaks.\n-\n-2D shapes are presented in space using points with 2 values - `x` (axis) and `y` axis, therefore, we will create the appropriate point structure:\n-\n-[{]: <helper> (diff_step 7.10)\n-#### Step 7.10: Add point struct\n-\n-##### Added resources/cpp/src/geometry/point.h\n-```diff\n-@@ -0,0 +1,8 @@\n-+â”Š â”Š1â”Š#pragma once\n-+â”Š â”Š2â”Š\n-+â”Š â”Š3â”Šnamespace geometry {\n-+â”Š â”Š4â”Š  struct Point {\n-+â”Š â”Š5â”Š    double x;\n-+â”Š â”Š6â”Š    double y;\n-+â”Š â”Š7â”Š  };\n-+â”Š â”Š8â”Š}ðŸš«â†µ\n-```\n-[}]: #\n-\n-Returned values can either be `null` (`undefined`) or not. Since there's no built in nullable-values mechanism in C++ (up until C++17), we're gonna create one of our own:\n-\n-[{]: <helper> (diff_step 7.11)\n-#### Step 7.11: Add nullable class\n-\n-##### Changed resources/cpp/src/index.cpp\n-```diff\n-@@ -1 +1,2 @@\n-+â”Š â”Š1â”Š#include \"nullable.cpp\"\n- â”Š1â”Š2â”Š#include \"utils.cpp\"ðŸš«â†µ\n-```\n-\n-##### Added resources/cpp/src/nullable.cpp\n-```diff\n-@@ -0,0 +1,37 @@\n-+â”Š  â”Š 1â”Š#include \"nullable.h\"\n-+â”Š  â”Š 2â”Š\n-+â”Š  â”Š 3â”Štemplate <typename T>\n-+â”Š  â”Š 4â”ŠNullable<T>::Nullable(T value): _value(value), _initialized(true) {\n-+â”Š  â”Š 5â”Š\n-+â”Š  â”Š 6â”Š}\n-+â”Š  â”Š 7â”Š\n-+â”Š  â”Š 8â”Štemplate <typename T>\n-+â”Š  â”Š 9â”ŠNullable<T>::Nullable(): _initialized(false) {\n-+â”Š  â”Š10â”Š\n-+â”Š  â”Š11â”Š}\n-+â”Š  â”Š12â”Š\n-+â”Š  â”Š13â”Štemplate <typename T>\n-+â”Š  â”Š14â”ŠT Nullable<T>::getValue() const {\n-+â”Š  â”Š15â”Š  return _value;\n-+â”Š  â”Š16â”Š}\n-+â”Š  â”Š17â”Š\n-+â”Š  â”Š18â”Štemplate <typename T>\n-+â”Š  â”Š19â”Švoid Nullable<T>::setValue(T value) {\n-+â”Š  â”Š20â”Š  _value = value;\n-+â”Š  â”Š21â”Š  _initialized = true;\n-+â”Š  â”Š22â”Š}\n-+â”Š  â”Š23â”Š\n-+â”Š  â”Š24â”Štemplate <typename T>\n-+â”Š  â”Š25â”Švoid Nullable<T>::resetValue() {\n-+â”Š  â”Š26â”Š  _initialized = false;\n-+â”Š  â”Š27â”Š}\n-+â”Š  â”Š28â”Š\n-+â”Š  â”Š29â”Štemplate <typename T>\n-+â”Š  â”Š30â”Šbool Nullable<T>::hasValue() const {\n-+â”Š  â”Š31â”Š  return _initialized == true;\n-+â”Š  â”Š32â”Š}\n-+â”Š  â”Š33â”Š\n-+â”Š  â”Š34â”Štemplate <typename T>\n-+â”Š  â”Š35â”Šbool Nullable<T>::isNull() const {\n-+â”Š  â”Š36â”Š  return _initialized == false;\n-+â”Š  â”Š37â”Š}ðŸš«â†µ\n-```\n-\n-##### Added resources/cpp/src/nullable.h\n-```diff\n-@@ -0,0 +1,23 @@\n-+â”Š  â”Š 1â”Š#pragma once\n-+â”Š  â”Š 2â”Š\n-+â”Š  â”Š 3â”Štemplate <typename T>\n-+â”Š  â”Š 4â”Šclass Nullable {\n-+â”Š  â”Š 5â”Šprivate:\n-+â”Š  â”Š 6â”Š  T _value;\n-+â”Š  â”Š 7â”Š  bool _initialized;\n-+â”Š  â”Š 8â”Š\n-+â”Š  â”Š 9â”Špublic:\n-+â”Š  â”Š10â”Š  Nullable(T value);\n-+â”Š  â”Š11â”Š\n-+â”Š  â”Š12â”Š  Nullable();\n-+â”Š  â”Š13â”Š\n-+â”Š  â”Š14â”Š  T getValue() const;\n-+â”Š  â”Š15â”Š\n-+â”Š  â”Š16â”Š  void setValue(T value);\n-+â”Š  â”Š17â”Š\n-+â”Š  â”Š18â”Š  void resetValue();\n-+â”Š  â”Š19â”Š\n-+â”Š  â”Š20â”Š  bool hasValue() const;\n-+â”Š  â”Š21â”Š\n-+â”Š  â”Š22â”Š  bool isNull() const;\n-+â”Š  â”Š23â”Š};ðŸš«â†µ\n-```\n-[}]: #\n-\n-Now that all the necessary assets for the line class are ready, we can go ahead and create it:\n-\n-[{]: <helper> (diff_step 7.12)\n-#### Step 7.12: Add base line CPP module\n-\n-##### Added resources/cpp/src/geometry/line.cpp\n-```diff\n-@@ -0,0 +1,99 @@\n-+â”Š  â”Š 1â”Š#include \"../nullable.h\"\n-+â”Š  â”Š 2â”Š#include \"../utils.h\"\n-+â”Š  â”Š 3â”Š#include \"point.h\"\n-+â”Š  â”Š 4â”Š#include \"line.h\"\n-+â”Š  â”Š 5â”Š\n-+â”Š  â”Š 6â”Šnamespace geometry {\n-+â”Š  â”Š 7â”Š  // x1 - The first point's x value\n-+â”Š  â”Š 8â”Š  // y1 - The first point's y value\n-+â”Š  â”Š 9â”Š  // x1 - The second point's x value\n-+â”Š  â”Š10â”Š  // y2 - The second point's y value\n-+â”Š  â”Š11â”Š  Line::Line(double x1, double y1, double x2, double y2) {\n-+â”Š  â”Š12â”Š    _x1 = utils::trim(x1, 9);\n-+â”Š  â”Š13â”Š    _y1 = utils::trim(y1, 9);\n-+â”Š  â”Š14â”Š    _x2 = utils::trim(x2, 9);\n-+â”Š  â”Š15â”Š    _y2 = utils::trim(y2, 9);\n-+â”Š  â”Š16â”Š  }\n-+â”Š  â”Š17â”Š\n-+â”Š  â”Š18â”Š  // Gets the matching x value for a given y value\n-+â”Š  â”Š19â”Š  Nullable<double> Line::getMatchingX(double y) {\n-+â”Š  â”Š20â”Š    // If an error was thrown it means we divided a number by zero,\n-+â”Š  â”Š21â”Š    // in which case there is not intersection point\n-+â”Š  â”Š22â”Š    double x = utils::trim(\n-+â”Š  â”Š23â”Š      (((y - _y1) * (_x2 - _x1)) /\n-+â”Š  â”Š24â”Š       (_y2 - _y1)) + _x1\n-+â”Š  â”Š25â”Š    , 9, \"exact\");\n-+â”Š  â”Š26â”Š\n-+â”Š  â”Š27â”Š    // Check if result is in values range\n-+â”Š  â”Š28â”Š    if (utils::isBetween(x, _x1, _x2, \"round\")) {\n-+â”Š  â”Š29â”Š      return Nullable<double>(x);\n-+â”Š  â”Š30â”Š    }\n-+â”Š  â”Š31â”Š\n-+â”Š  â”Š32â”Š    return Nullable<double>();\n-+â”Š  â”Š33â”Š  }\n-+â”Š  â”Š34â”Š\n-+â”Š  â”Š35â”Š  // Gets the matching y value for a given x value\n-+â”Š  â”Š36â”Š  Nullable<double> Line::getMatchingY(double x) {\n-+â”Š  â”Š37â”Š    // If an error was thrown it means we divided a number by zero,\n-+â”Š  â”Š38â”Š    // in which case there is not intersection point\n-+â”Š  â”Š39â”Š    double y = utils::trim(\n-+â”Š  â”Š40â”Š      (((x - _x1) * (_y2 - _y1)) /\n-+â”Š  â”Š41â”Š       (_x2 - _x1)) + _y1\n-+â”Š  â”Š42â”Š    , 9, \"exact\");\n-+â”Š  â”Š43â”Š\n-+â”Š  â”Š44â”Š    // Check if result is in values range\n-+â”Š  â”Š45â”Š    if (utils::isBetween(y, _y1, _y2, \"round\")) {\n-+â”Š  â”Š46â”Š      return Nullable<double>(y);\n-+â”Š  â”Š47â”Š    }\n-+â”Š  â”Š48â”Š\n-+â”Š  â”Š49â”Š    return Nullable<double>();\n-+â”Š  â”Š50â”Š  }\n-+â”Š  â”Š51â”Š\n-+â”Š  â”Š52â”Š  // Returns if line has given point\n-+â”Š  â”Š53â”Š  bool Line::hasPoint(double x, double y) {\n-+â”Š  â”Š54â”Š    if (!boundsHavePoint(x, y)) return 0;\n-+â”Š  â”Š55â”Š\n-+â”Š  â”Š56â”Š    double m = utils::trim(\n-+â”Š  â”Š57â”Š      (_y2 - _y1) / (_x2 - _x1),\n-+â”Š  â”Š58â”Š    9, \"exact\");\n-+â”Š  â”Š59â”Š\n-+â”Š  â”Š60â”Š    return (y - _y1) / (x - _x1) == m;\n-+â”Š  â”Š61â”Š  }\n-+â”Š  â”Š62â”Š\n-+â”Š  â”Š63â”Š  // Returns if given point is contained by the bounds aka cage of line\n-+â”Š  â”Š64â”Š  bool Line::boundsHavePoint(double x, double y) {\n-+â”Š  â”Š65â”Š    return utils::isBetween(x, _x1, _x2, \"round\") &&\n-+â”Š  â”Š66â”Š           utils::isBetween(y, _y1, _y2, \"round\");\n-+â”Š  â”Š67â”Š  }\n-+â”Š  â”Š68â”Š\n-+â”Š  â”Š69â”Š  // line - line intersection method\n-+â”Š  â”Š70â”Š  Nullable<Point> Line::getIntersection(Line line) {\n-+â”Š  â”Š71â”Š    // Escape if lines are parallel\n-+â”Š  â”Š72â”Š    if (!(((_x1 - _x2) * (line._y1 - line._y2)) -\n-+â”Š  â”Š73â”Š          ((_y1 - _y2) * (line._x1 - line._x2))))\n-+â”Š  â”Š74â”Š      return Nullable<Point>();\n-+â”Š  â”Š75â”Š\n-+â”Š  â”Š76â”Š    // Intersection point formula\n-+â”Š  â”Š77â”Š    double x = utils::trim(\n-+â”Š  â”Š78â”Š      ((((_x1 * _y2) - (_y1 * _x2)) * (line._x1 - line._x2)) -\n-+â”Š  â”Š79â”Š       ((_x1 - _x2) * ((line._x1 * line._y2) - (line._y1 * line._x2)))) /\n-+â”Š  â”Š80â”Š      (((_x1 - _x2) * (line._y1 - line._y2)) - ((_y1 - _y2) *\n-+â”Š  â”Š81â”Š        (line._x1 - line._x2)))\n-+â”Š  â”Š82â”Š    , 9, \"exact\");\n-+â”Š  â”Š83â”Š    double y = utils::trim(\n-+â”Š  â”Š84â”Š      ((((_x1 * _y2) - (_y1 * _x2)) * (line._y1 - line._y2)) -\n-+â”Š  â”Š85â”Š       ((_y1 - _y2) * ((line._x1 * line._y2) - (line._y1 * line._x2)))) /\n-+â”Š  â”Š86â”Š      (((_x1 - _x2) * (line._y1 - line._y2)) - ((_y1 - _y2) *\n-+â”Š  â”Š87â”Š        (line._x1 - line._x2)))\n-+â”Š  â”Š88â”Š    , 9, \"exact\");\n-+â”Š  â”Š89â”Š\n-+â”Š  â”Š90â”Š    if (utils::isBetween(x, _x1, _x2, \"round\") &&\n-+â”Š  â”Š91â”Š        utils::isBetween(x, line._x1, line._x2, \"round\") &&\n-+â”Š  â”Š92â”Š        utils::isBetween(y, _y1, _y2, \"round\") &&\n-+â”Š  â”Š93â”Š        utils::isBetween(y, line._y1, line._y2, \"round\")) {\n-+â”Š  â”Š94â”Š      return Nullable<Point>({ x, y });\n-+â”Š  â”Š95â”Š    }\n-+â”Š  â”Š96â”Š\n-+â”Š  â”Š97â”Š    return Nullable<Point>();\n-+â”Š  â”Š98â”Š  }\n-+â”Š  â”Š99â”Š}ðŸš«â†µ\n-```\n-\n-##### Added resources/cpp/src/geometry/line.h\n-```diff\n-@@ -0,0 +1,30 @@\n-+â”Š  â”Š 1â”Š#pragma once\n-+â”Š  â”Š 2â”Š\n-+â”Š  â”Š 3â”Š#include <vector>\n-+â”Š  â”Š 4â”Š#include \"../nullable.h\"\n-+â”Š  â”Š 5â”Š#include \"point.h\"\n-+â”Š  â”Š 6â”Š\n-+â”Š  â”Š 7â”Šnamespace geometry {\n-+â”Š  â”Š 8â”Š  class Circle;\n-+â”Š  â”Š 9â”Š  class EMCircle;\n-+â”Š  â”Š10â”Š\n-+â”Š  â”Š11â”Š  class Line {\n-+â”Š  â”Š12â”Š  public:\n-+â”Š  â”Š13â”Š    double _x1;\n-+â”Š  â”Š14â”Š    double _y1;\n-+â”Š  â”Š15â”Š    double _x2;\n-+â”Š  â”Š16â”Š    double _y2;\n-+â”Š  â”Š17â”Š\n-+â”Š  â”Š18â”Š    Line(double x1, double y1, double x2, double y2);\n-+â”Š  â”Š19â”Š\n-+â”Š  â”Š20â”Š    Nullable<double> getMatchingX(double y);\n-+â”Š  â”Š21â”Š\n-+â”Š  â”Š22â”Š    Nullable<double> getMatchingY(double x);\n-+â”Š  â”Š23â”Š\n-+â”Š  â”Š24â”Š    bool hasPoint(double x, double y);\n-+â”Š  â”Š25â”Š\n-+â”Š  â”Š26â”Š    bool boundsHavePoint(double x, double y);\n-+â”Š  â”Š27â”Š\n-+â”Š  â”Š28â”Š    Nullable<Point> getIntersection(Line line);\n-+â”Š  â”Š29â”Š  };\n-+â”Š  â”Š30â”Š}ðŸš«â†µ\n-```\n-\n-##### Changed resources/cpp/src/index.cpp\n-```diff\n-@@ -1,2 +1,3 @@\n- â”Š1â”Š1â”Š#include \"nullable.cpp\"\n--â”Š2â”Š â”Š#include \"utils.cpp\"ðŸš«â†µ\n-+â”Š â”Š2â”Š#include \"utils.cpp\"\n-+â”Š â”Š3â”Š#include \"geometry/line.cpp\"ðŸš«â†µ\n-```\n-[}]: #\n-\n-After creating our C++, we will also need to bind it using EMBind:\n-\n-[{]: <helper> (diff_step 7.13)\n-#### Step 7.13: EMBind CPP line\n-\n-##### Changed resources/cpp/post.js\n-```diff\n-@@ -4,6 +4,10 @@\n- â”Š 4â”Š 4â”Š    trim: Module.utils_trim,\n- â”Š 5â”Š 5â”Š    isBetween: Module.utils_isBetween,\n- â”Š 6â”Š 6â”Š    compare: Module.utils_compare\n-+â”Š  â”Š 7â”Š  },\n-+â”Š  â”Š 8â”Š\n-+â”Š  â”Š 9â”Š  Geometry: {\n-+â”Š  â”Š10â”Š    Line: Module.geometry_line\n- â”Š 7â”Š11â”Š  }\n- â”Š 8â”Š12â”Š};\n- â”Š 9â”Š13â”Š\n-```\n-\n-##### Changed resources/cpp/src/geometry/line.cpp\n-```diff\n-@@ -1,3 +1,6 @@\n-+â”Š â”Š1â”Š#include <vector>\n-+â”Š â”Š2â”Š#include <emscripten/bind.h>\n-+â”Š â”Š3â”Š#include <emscripten/val.h>\n- â”Š1â”Š4â”Š#include \"../nullable.h\"\n- â”Š2â”Š5â”Š#include \"../utils.h\"\n- â”Š3â”Š6â”Š#include \"point.h\"\n-```\n-```diff\n-@@ -96,4 +99,52 @@\n- â”Š 96â”Š 99â”Š\n- â”Š 97â”Š100â”Š    return Nullable<Point>();\n- â”Š 98â”Š101â”Š  }\n-+â”Š   â”Š102â”Š\n-+â”Š   â”Š103â”Š  emscripten::val EMLine::getMatchingX(double y) {\n-+â”Š   â”Š104â”Š    Nullable<double> nullableX = Line::getMatchingX(y);\n-+â”Š   â”Š105â”Š    return nullableX.hasValue() ?\n-+â”Š   â”Š106â”Š      emscripten::val(nullableX.getValue()) :\n-+â”Š   â”Š107â”Š      emscripten::val::undefined();\n-+â”Š   â”Š108â”Š  }\n-+â”Š   â”Š109â”Š\n-+â”Š   â”Š110â”Š  emscripten::val EMLine::getMatchingY(double x) {\n-+â”Š   â”Š111â”Š    Nullable<double> nullableY = Line::getMatchingY(x);\n-+â”Š   â”Š112â”Š    return nullableY.hasValue() ?\n-+â”Š   â”Š113â”Š      emscripten::val(nullableY.getValue()) :\n-+â”Š   â”Š114â”Š      emscripten::val::undefined();\n-+â”Š   â”Š115â”Š  }\n-+â”Š   â”Š116â”Š\n-+â”Š   â”Š117â”Š  emscripten::val EMLine::getIntersection(EMLine emLine) {\n-+â”Š   â”Š118â”Š    Line line = Line(emLine._x1, emLine._y1, emLine._x2, emLine._y2);\n-+â”Š   â”Š119â”Š    Nullable<Point> nullablePoint = Line::getIntersection(line);\n-+â”Š   â”Š120â”Š\n-+â”Š   â”Š121â”Š    if (nullablePoint.isNull()) return emscripten::val::undefined();\n-+â”Š   â”Š122â”Š\n-+â”Š   â”Š123â”Š    Point point = nullablePoint.getValue();\n-+â”Š   â”Š124â”Š    emscripten::val emPoint = emscripten::val::object();\n-+â”Š   â”Š125â”Š    emPoint.set(\"x\", emscripten::val(point.x));\n-+â”Š   â”Š126â”Š    emPoint.set(\"y\", emscripten::val(point.y));\n-+â”Š   â”Š127â”Š    return emPoint;\n-+â”Š   â”Š128â”Š  }\n-+â”Š   â”Š129â”Š}\n-+â”Š   â”Š130â”Š\n-+â”Š   â”Š131â”ŠEMSCRIPTEN_BINDINGS(geometry_line_module) {\n-+â”Š   â”Š132â”Š  emscripten::class_<geometry::Line>(\"geometry_line_base\")\n-+â”Š   â”Š133â”Š    .constructor<double, double, double, double>()\n-+â”Š   â”Š134â”Š    .property<double>(\"x1\", &geometry::Line::_x1)\n-+â”Š   â”Š135â”Š    .property<double>(\"y1\", &geometry::Line::_y1)\n-+â”Š   â”Š136â”Š    .property<double>(\"x2\", &geometry::Line::_x2)\n-+â”Š   â”Š137â”Š    .property<double>(\"y2\", &geometry::Line::_y2)\n-+â”Š   â”Š138â”Š    .function(\"hasPoint\", &geometry::Line::hasPoint)\n-+â”Š   â”Š139â”Š    .function(\"boundsHavePoint\", &geometry::Line::boundsHavePoint);\n-+â”Š   â”Š140â”Š\n-+â”Š   â”Š141â”Š  emscripten::class_<geometry::EMLine, emscripten::base<geometry::Line>>(\"geometry_line\")\n-+â”Š   â”Š142â”Š    .constructor<double, double, double, double>()\n-+â”Š   â”Š143â”Š    .function(\"getX\", &geometry::EMLine::getMatchingX)\n-+â”Š   â”Š144â”Š    .function(\"getY\", &geometry::EMLine::getMatchingY)\n-+â”Š   â”Š145â”Š    .function(\"getLineIntersection\",\n-+â”Š   â”Š146â”Š      emscripten::select_overload<emscripten::val(geometry::EMLine)>(\n-+â”Š   â”Š147â”Š        &geometry::EMLine::getIntersection\n-+â”Š   â”Š148â”Š      )\n-+â”Š   â”Š149â”Š    );\n- â”Š 99â”Š150â”Š}ðŸš«â†µ\n-```\n-\n-##### Changed resources/cpp/src/geometry/line.h\n-```diff\n-@@ -1,6 +1,7 @@\n- â”Š1â”Š1â”Š#pragma once\n- â”Š2â”Š2â”Š\n- â”Š3â”Š3â”Š#include <vector>\n-+â”Š â”Š4â”Š#include <emscripten/val.h>\n- â”Š4â”Š5â”Š#include \"../nullable.h\"\n- â”Š5â”Š6â”Š#include \"point.h\"\n- â”Š6â”Š7â”Š\n-```\n-```diff\n-@@ -27,4 +28,15 @@\n- â”Š27â”Š28â”Š\n- â”Š28â”Š29â”Š    Nullable<Point> getIntersection(Line line);\n- â”Š29â”Š30â”Š  };\n-+â”Š  â”Š31â”Š\n-+â”Š  â”Š32â”Š  class EMLine : public Line {\n-+â”Š  â”Š33â”Š  public:\n-+â”Š  â”Š34â”Š    using Line::Line;\n-+â”Š  â”Š35â”Š\n-+â”Š  â”Š36â”Š    emscripten::val getMatchingX(double y);\n-+â”Š  â”Š37â”Š\n-+â”Š  â”Š38â”Š    emscripten::val getMatchingY(double x);\n-+â”Š  â”Š39â”Š\n-+â”Š  â”Š40â”Š    emscripten::val getIntersection(EMLine line);\n-+â”Š  â”Š41â”Š  };\n- â”Š30â”Š42â”Š}ðŸš«â†µ\n-```\n-[}]: #\n-\n-In the code snippet above, you can see that we used a special data-type called `val` (`emscripten::val`). `val` means that just like JavaScript, that function can return values that are not necessarily of the same data-type; For instance, the `getMatchingY` function can either return a `number` or `undefined`. If you'll take a look at the `getIntersection(Line)` method you'll notice that instead of returning the raw point structure, I chose to build a JavaScript object using the `object` data type (`emscripten::object`). `object` behaves exactly like a native JavaScript `Object`, and it can save us some precious work of binding which sometimes might be just too much.\n-\n-If you'll compare the C++ version of the line class to the JavaScript line class you'll notice that the `draw` and `getIntersection` methods are missing (when we used EMBind we renamed `getIntersection` to `getLineIntersection` because overloadings are forbidden). In addition, Emscripten's API exposes some additional class methods for generated C++ classes, like the `delete` method, which we will shed light on further in this tutorial. Inheritance would be the natural solution for such an issue, unfortunately, generated C++ constructors don't accept indirect instances. For example, if we have a C++ parent class called `Shape` and we have a JavaScript child class called `Line`, we won't be able to initialize a new instance of the `Line` class. Here's a demonstration:\n-\n-```js\n-class JSLine extends CPPShape {}\n-const line = new JSLine(); // Throws error\n-```\n-\n-There are 3 ways to implement inheritance when interacting with C++ classes:\n-\n-- Define an interface when using EMBind. This is the official way but rather complicated, since it requires us to define an extra layer for our wrapper. More information can be found [here](https://kripken.github.io/emscripten-site/docs/porting/connecting_cpp_and_javascript/embind.html#abstract-methods).\n-- Extending the prototype of exported C++ classes directly, which is not really an inheritance.\n-- Using a proxy class, which is the easiest and cleanest solution of all, but it is not really mentioned anywhere. At the same time, I didn't find any restriction regards that.\n-\n-We're gonna use the 3rd method in the list above, because as I said, it's the easiest and cleanest of all. First I will try to explain what I meant by saying \"proxy class\". If you're an intermediate JavaScript developer, you probably know that constructors can be overridden by returning a value explicitly. By doing that, we can actually bypass Emscripten's prohibitions, we can just return the newly created C++ instance and extend it in specific. Proxy classes actually take it a step further by providing a middle-class which will then inject a new link to the prototype chain of the returned instance.\n-\n-```js\n-class JSLine {\n-  constructor() {\n-    const line = new CPPShape();\n-    return line;\n-  }\n-}\n-\n-const line = new JSLine(); // Legal!\n-```\n-\n-> More information about the code snippet above can be found [here](https://www.bennadel.com/blog/2522-providing-a-return-value-in-a-javascript-constructor.htm).\n-\n-I believe that as we go through this tutorial, the concept will get much clearer. The utility function of the proxy class should look like so:\n-\n-[{]: <helper> (diff_step 7.14)\n-#### Step 7.14: Add proxy utility method\n-\n-##### Changed resources/scripts/utils.js\n-```diff\n-@@ -20,5 +20,18 @@\n- â”Š20â”Š20â”Š  // Overload handling\n- â”Š21â”Š21â”Š  compare(context, num, method, precision = method) {\n- â”Š22â”Š22â”Š    return CPP.Utils.compare(context, num, method, precision);\n-+â”Š  â”Š23â”Š  },\n-+â”Š  â”Š24â”Š\n-+â”Š  â”Š25â”Š  proxy(Class) {\n-+â”Š  â”Š26â”Š    return class extends Class {\n-+â”Š  â”Š27â”Š      constructor() {\n-+â”Š  â”Š28â”Š        // Initialize original class\n-+â”Š  â”Š29â”Š        let that = new Class(...arguments);\n-+â”Š  â”Š30â”Š        // Inject caller's prototype into the prototype chain\n-+â”Š  â”Š31â”Š        Object.setPrototypeOf(that, new.target.prototype);\n-+â”Š  â”Š32â”Š        // Will original instance will be the substitute for 'this'\n-+â”Š  â”Š33â”Š        return that;\n-+â”Š  â”Š34â”Š      }\n-+â”Š  â”Š35â”Š    }\n- â”Š23â”Š36â”Š  }\n- â”Š24â”Š37â”Š});ðŸš«â†µ\n-```\n-[}]: #\n-\n-If you'll take a look at the following line:\n-\n-```js\n-Object.setPrototypeOf(that, new.target.prototype);\n-```\n-\n-This is where the magic actually happens! It enables inheritance for explicitly returned objects; This way we can safely extend C++ classes. Accordingly, our new JavaScript line class should look like so:\n-\n-[{]: <helper> (diff_step 7.15)\n-#### Step 7.15: Extend CPP line class\n-\n-##### Changed resources/scripts/engine/geometry/line.js\n-```diff\n-@@ -1,46 +1,10 @@\n--â”Š 1â”Š  â”ŠEngine.Geometry.Line = class Line {\n--â”Š 2â”Š  â”Š  // x1 - The first point's x value\n--â”Š 3â”Š  â”Š  // y1 - The first point's y value\n--â”Š 4â”Š  â”Š  // x1 - The second point's x value\n--â”Š 5â”Š  â”Š  // y2 - The second point's y value\n--â”Š 6â”Š  â”Š  constructor(x1, y1, x2, y2) {\n--â”Š 7â”Š  â”Š    this.x1 = Utils.trim(x1, 9);\n--â”Š 8â”Š  â”Š    this.y1 = Utils.trim(y1, 9);\n--â”Š 9â”Š  â”Š    this.x2 = Utils.trim(x2, 9);\n--â”Š10â”Š  â”Š    this.y2 = Utils.trim(y2, 9);\n--â”Š11â”Š  â”Š  }\n--â”Š12â”Š  â”Š\n-+â”Š  â”Š 1â”ŠEngine.Geometry.Line = class Line extends Utils.proxy(CPP.Geometry.Line) {\n- â”Š13â”Š 2â”Š  // Draws the line on the given context\n- â”Š14â”Š 3â”Š  draw(context) {\n- â”Š15â”Š 4â”Š    context.moveTo(this.x1, this.y1);\n- â”Š16â”Š 5â”Š    context.lineTo(this.x2, this.y2);\n- â”Š17â”Š 6â”Š  }\n- â”Š18â”Š 7â”Š\n--â”Š19â”Š  â”Š  // Gets the matching x value for a given y value\n--â”Š20â”Š  â”Š  getX(y) {\n--â”Š21â”Š  â”Š    let x = Utils.trim((((y - this.y1) * (this.x2 - this.x1)) / (this.y2 - this.y1)) + this.x1, 9);\n--â”Š22â”Š  â”Š    if (isNaN(x) || Utils.isBetween(x, this.x1, this.x2)) return x;\n--â”Š23â”Š  â”Š  }\n--â”Š24â”Š  â”Š\n--â”Š25â”Š  â”Š  // Gets the matching y value for a given x value\n--â”Š26â”Š  â”Š  getY(x) {\n--â”Š27â”Š  â”Š    let y = Utils.trim((((x - this.x1) * (this.y2 - this.y1)) / (this.x2 - this.x1)) + this.y1, 9);\n--â”Š28â”Š  â”Š    if (isNaN(y) || Utils.isBetween(y, this.y1, this.y2)) return y;\n--â”Š29â”Š  â”Š  }\n--â”Š30â”Š  â”Š\n--â”Š31â”Š  â”Š  // Returns if line has given point\n--â”Š32â”Š  â”Š  hasPoint(x, y) {\n--â”Š33â”Š  â”Š    if (!this.boundsHavePoint(x, y)) return false;\n--â”Š34â”Š  â”Š    let m = Utils.trim((this.y2 - this.y1) / (this.x2 - this.x1), 9);\n--â”Š35â”Š  â”Š    return (y - this.y1) / (x - this.x1) == m;\n--â”Š36â”Š  â”Š  }\n--â”Š37â”Š  â”Š\n--â”Š38â”Š  â”Š  // Returns if given point is contained by the bounds aka cage of line\n--â”Š39â”Š  â”Š  boundsHavePoint(x, y) {\n--â”Š40â”Š  â”Š    return Utils.isBetween(x, this.x1, this.x2) &&\n--â”Š41â”Š  â”Š           Utils.isBetween(y, this.y1, this.y2);\n--â”Š42â”Š  â”Š  }\n--â”Š43â”Š  â”Š\n- â”Š44â”Š 8â”Š  getIntersection(shape) {\n- â”Š45â”Š 9â”Š    if (shape instanceof Engine.Geometry.Line)\n- â”Š46â”Š10â”Š      return this.getLineIntersection(shape);\n-```\n-```diff\n-@@ -50,23 +14,6 @@\n- â”Š50â”Š14â”Š      return this.getPolygonIntersection(shape);\n- â”Š51â”Š15â”Š  }\n- â”Š52â”Š16â”Š\n--â”Š53â”Š  â”Š  // line - line intersection method\n--â”Š54â”Š  â”Š  getLineIntersection(line) {\n--â”Š55â”Š  â”Š    // Escape if lines are parallel\n--â”Š56â”Š  â”Š    if (!(((this.x1 - this.x2) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * (line.x1 - line.x2)))) return;\n--â”Š57â”Š  â”Š\n--â”Š58â”Š  â”Š    // Intersection point formula\n--â”Š59â”Š  â”Š    let x = Utils.trim(((((this.x1 * this.y2) - (this.y1 * this.x2)) * (line.x1 - line.x2)) - ((this.x1 - this.x2) * ((line.x1 * line.y2) - (line.y1 * line.x2)))) /\n--â”Š60â”Š  â”Š        (((this.x1 - this.x2) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * (line.x1 - line.x2))), 9);\n--â”Š61â”Š  â”Š    let y = Utils.trim(((((this.x1 * this.y2) - (this.y1 * this.x2)) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * ((line.x1 * line.y2) - (line.y1 * line.x2)))) /\n--â”Š62â”Š  â”Š        (((this.x1 - this.x2) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * (line.x1 - line.x2))), 9);\n--â”Š63â”Š  â”Š\n--â”Š64â”Š  â”Š    if (Utils.isBetween(x, this.x1, this.x2) && Utils.isBetween(x, line.x1, line.x2) &&\n--â”Š65â”Š  â”Š        Utils.isBetween(y, this.y1, this.y2) && Utils.isBetween(y, line.y1, line.y2)) {\n--â”Š66â”Š  â”Š      return { x, y };\n--â”Š67â”Š  â”Š    }\n--â”Š68â”Š  â”Š  }\n--â”Š69â”Š  â”Š\n- â”Š70â”Š17â”Š  // line - circle intersection method\n- â”Š71â”Š18â”Š  getCircleIntersection(circle) {\n- â”Š72â”Š19â”Š    return circle.getLineIntersection(this);\n-```\n-[}]: #\n-\n-By now, our tests should pass. Accept, there is memory leak we need to handle. But you probably ask yourself - \"What memory leak? It's JavaScript man! Have you ever heard of something called garbage collector?!\". Well, this is not the case when compiling C++ code with Emscripten. You see, Emscripten uses asm.js, which is a subset for JavaScript built exactly for these proposes, enabling C++ modules run on the browser. This is how the [WebGL](https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API) project actually started, an almost complete conversion from the famous C++ [OpenGL](https://www.opengl.org/) to JavaScript. Part of what asm.js does, it disables the garbage collector, and instead, it holds raw pointers, just like in C++. Since returned class instances are pointers with unknown lifespans, they need to be disposed manually, using the `delete` method (identical to how we clear memory from the Heap in C++). Let's dispose unused test data by calling the `delete` method as just mentioned:\n-\n-[{]: <helper> (diff_step 7.16)\n-#### Step 7.16: Delete line instances in tests\n-\n-##### Changed resources/scripts/specs/engine/geometry/circle.js\n-```diff\n-@@ -111,6 +111,8 @@\n- â”Š111â”Š111â”Š          { x: 6, y: 1 },\n- â”Š112â”Š112â”Š          { x: -4, y: 1 }\n- â”Š113â”Š113â”Š        ]);\n-+â”Š   â”Š114â”Š\n-+â”Š   â”Š115â”Š        line.delete();\n- â”Š114â”Š116â”Š      });\n- â”Š115â”Š117â”Š    });\n- â”Š116â”Š118â”Š\n-```\n-```diff\n-@@ -121,6 +123,8 @@\n- â”Š121â”Š123â”Š        expect(this.circle.getLineIntersection(line)).toEqual([\n- â”Š122â”Š124â”Š          { x: -4, y: 1 }\n- â”Š123â”Š125â”Š        ]);\n-+â”Š   â”Š126â”Š\n-+â”Š   â”Š127â”Š        line.delete();\n- â”Š124â”Š128â”Š      });\n- â”Š125â”Š129â”Š    });\n- â”Š126â”Š130â”Š\n-```\n-```diff\n-@@ -131,6 +135,8 @@\n- â”Š131â”Š135â”Š        expect(this.circle.getLineIntersection(line)).toEqual([\n- â”Š132â”Š136â”Š          { x: 1, y: 6 }\n- â”Š133â”Š137â”Š        ]);\n-+â”Š   â”Š138â”Š\n-+â”Š   â”Š139â”Š        line.delete();\n- â”Š134â”Š140â”Š      });\n- â”Š135â”Š141â”Š    });\n- â”Š136â”Š142â”Š\n-```\n-```diff\n-@@ -138,6 +144,7 @@\n- â”Š138â”Š144â”Š      it(\"returns nothing\", function() {\n- â”Š139â”Š145â”Š        let line = new Engine.Geometry.Line(-10, 10, 10, 10);\n- â”Š140â”Š146â”Š        expect(this.circle.getLineIntersection(line)).toBeUndefined();\n-+â”Š   â”Š147â”Š        line.delete();\n- â”Š141â”Š148â”Š      });\n- â”Š142â”Š149â”Š    });\n- â”Š143â”Š150â”Š  });\n-```\n-\n-##### Changed resources/scripts/specs/engine/geometry/line.js\n-```diff\n-@@ -3,6 +3,10 @@\n- â”Š 3â”Š 3â”Š    this.line = new Engine.Geometry.Line(-5, -5, 5, 5);\n- â”Š 4â”Š 4â”Š  });\n- â”Š 5â”Š 5â”Š\n-+â”Š  â”Š 6â”Š  afterEach(function () {\n-+â”Š  â”Š 7â”Š    this.line.delete();\n-+â”Š  â”Š 8â”Š  });\n-+â”Š  â”Š 9â”Š\n- â”Š 6â”Š10â”Š  describe(\"getX method\", function() {\n- â”Š 7â”Š11â”Š    describe(\"given inranged y\", function() {\n- â”Š 8â”Š12â”Š      it(\"returns x\", function() {\n-```\n-```diff\n-@@ -58,6 +62,8 @@\n- â”Š58â”Š62â”Š          x: 1,\n- â”Š59â”Š63â”Š          y: 1\n- â”Š60â”Š64â”Š        });\n-+â”Š  â”Š65â”Š\n-+â”Š  â”Š66â”Š        line.delete();\n- â”Š61â”Š67â”Š      });\n- â”Š62â”Š68â”Š    });\n- â”Š63â”Š69â”Š\n-```\n-```diff\n-@@ -65,6 +71,7 @@\n- â”Š65â”Š71â”Š      it(\"returns nothing\", function() {\n- â”Š66â”Š72â”Š        let line = new Engine.Geometry.Line(-5, -6, 5, 4);\n- â”Š67â”Š73â”Š        expect(this.line.getLineIntersection(line)).toBeUndefined();\n-+â”Š  â”Š74â”Š        line.delete();\n- â”Š68â”Š75â”Š      });\n- â”Š69â”Š76â”Š    });\n- â”Š70â”Š77â”Š\n-```\n-```diff\n-@@ -72,6 +79,7 @@\n- â”Š72â”Š79â”Š      it(\"returns nothing\", function() {\n- â”Š73â”Š80â”Š        let line = new Engine.Geometry.Line(10, 10, 10, 15);\n- â”Š74â”Š81â”Š        expect(this.line.getLineIntersection(line)).toBeUndefined();\n-+â”Š  â”Š82â”Š        line.delete();\n- â”Š75â”Š83â”Š      });\n- â”Š76â”Š84â”Š    });\n- â”Š77â”Š85â”Š  });\n-```\n-\n-##### Changed resources/scripts/specs/engine/geometry/polygon.js\n-```diff\n-@@ -35,6 +35,8 @@\n- â”Š35â”Š35â”Š          { x: 5, y: 4 },\n- â”Š36â”Š36â”Š          { x: 0, y: 1 }\n- â”Š37â”Š37â”Š        ]);\n-+â”Š  â”Š38â”Š\n-+â”Š  â”Š39â”Š        line.delete();\n- â”Š38â”Š40â”Š      });\n- â”Š39â”Š41â”Š    });\n- â”Š40â”Š42â”Š\n-```\n-```diff\n-@@ -43,6 +45,8 @@\n- â”Š43â”Š45â”Š        let line = new Engine.Geometry.Line(10, 11, 15, 14);\n- â”Š44â”Š46â”Š\n- â”Š45â”Š47â”Š        expect(this.polygon.getLineIntersection(line)).toBeUndefined();\n-+â”Š  â”Š48â”Š\n-+â”Š  â”Š49â”Š        line.delete();\n- â”Š46â”Š50â”Š      });\n- â”Š47â”Š51â”Š    });\n- â”Š48â”Š52â”Š  });\n-```\n-[}]: #\n-\n-Since our game also uses polygons, which is made of an abstract number of lines, its test-data needs to be disposed as well. First, we will add a `delete` method to the polygon class, which will simply go though all its bounds and delete each of its lines:\n-\n-[{]: <helper> (diff_step 7.17)\n-#### Step 7.17: Add polygon deletion method\n-\n-##### Changed resources/scripts/engine/geometry/polygon.js\n-```diff\n-@@ -5,6 +5,10 @@\n- â”Š 5â”Š 5â”Š    this.bounds = bounds.map(coords => new Engine.Geometry.Line(...coords));\n- â”Š 6â”Š 6â”Š  }\n- â”Š 7â”Š 7â”Š\n-+â”Š  â”Š 8â”Š  delete() {\n-+â”Š  â”Š 9â”Š    this.bounds.forEach(bound => bound.delete());\n-+â”Š  â”Š10â”Š  }\n-+â”Š  â”Š11â”Š\n- â”Š 8â”Š12â”Š  // Returns if polygon has given point\n- â”Š 9â”Š13â”Š  hasPoint(x, y) {\n- â”Š10â”Š14â”Š    // Run check for each bound\n-```\n-[}]: #\n-\n-Now we can conveniently delete unused polygons in the tests:\n-\n-[{]: <helper> (diff_step 7.18)\n-#### Step 7.18: Delete polygon instances in tests\n-\n-##### Changed resources/scripts/specs/engine/geometry/polygon.js\n-```diff\n-@@ -8,6 +8,10 @@\n- â”Š 8â”Š 8â”Š    );\n- â”Š 9â”Š 9â”Š  });\n- â”Š10â”Š10â”Š\n-+â”Š  â”Š11â”Š  afterEach(function () {\n-+â”Š  â”Š12â”Š    this.polygon.delete();\n-+â”Š  â”Š13â”Š  });\n-+â”Š  â”Š14â”Š\n- â”Š11â”Š15â”Š  describe(\"hasPoint method\", function() {\n- â”Š12â”Š16â”Š    describe(\"given contained point\", function() {\n- â”Š13â”Š17â”Š      it(\"returns true\", function() {\n-```\n-[}]: #\n-\n-Moving on, we have the circle class to transform. The process is almost the identical to how we transformed the line class, so it's gonna be way easier now. We first start by translating our code from JavaScript to C++:\n-\n-[{]: <helper> (diff_step 7.19)\n-#### Step 7.19: Add base circle CPP module\n-\n-##### Added resources/cpp/src/geometry/circle.cpp\n-```diff\n-@@ -0,0 +1,202 @@\n-+â”Š   â”Š  1â”Š\n-+â”Š   â”Š  2â”Š#include <algorithm>\n-+â”Š   â”Š  3â”Š#include <cmath>\n-+â”Š   â”Š  4â”Š#include <vector>\n-+â”Š   â”Š  5â”Š#include \"../nullable.h\"\n-+â”Š   â”Š  6â”Š#include \"../utils.h\"\n-+â”Š   â”Š  7â”Š#include \"point.h\"\n-+â”Š   â”Š  8â”Š#include \"line.h\"\n-+â”Š   â”Š  9â”Š\n-+â”Š   â”Š 10â”Šnamespace geometry {\n-+â”Š   â”Š 11â”Š  // x - The x value of the circle's center\n-+â”Š   â”Š 12â”Š  // y - The y value of the circle's center\n-+â”Š   â”Š 13â”Š  // r - The radius of the center\n-+â”Š   â”Š 14â”Š  // rad1 - The first radian of the circle, not necessarily its beginning\n-+â”Š   â”Š 15â”Š  // rad2 - The second radian of the circle, not necessarily its beginning\n-+â”Š   â”Š 16â”Š  Circle::Circle(double x, double y, double r, double rad1, double rad2) {\n-+â”Š   â”Š 17â”Š    _x = utils::trim(x, 9);\n-+â”Š   â”Š 18â”Š    _y = utils::trim(y, 9);\n-+â”Š   â”Š 19â”Š    _r = utils::trim(r, 9);\n-+â”Š   â”Š 20â”Š\n-+â”Š   â”Š 21â”Š    // Trimming mode is done based on which radian represents the ending and which radian\n-+â”Š   â”Š 22â”Š    // represents the ending\n-+â”Š   â”Š 23â”Š    if (rad1 > rad2) {\n-+â”Š   â”Š 24â”Š      _rad1 = utils::trim(rad1, 9, \"floor\");\n-+â”Š   â”Š 25â”Š      _rad2 = utils::trim(rad2, 9, \"ceil\");\n-+â”Š   â”Š 26â”Š    }\n-+â”Š   â”Š 27â”Š    else {\n-+â”Š   â”Š 28â”Š      _rad1 = utils::trim(rad1, 9, \"ceil\");\n-+â”Š   â”Š 29â”Š      _rad2 = utils::trim(rad2, 9, \"floor\");\n-+â”Š   â”Š 30â”Š    }\n-+â”Š   â”Š 31â”Š  }\n-+â”Š   â”Š 32â”Š\n-+â”Š   â”Š 33â”Š  // Gets the matching x value for the given radian\n-+â”Š   â”Š 34â”Š  Nullable<double> Circle::getMatchingX(double rad) {\n-+â”Š   â”Š 35â”Š    if (!utils::chain(rad)->trim(9)->isBetween(_rad1, _rad2)->result()) {\n-+â”Š   â”Š 36â”Š      return Nullable<double>();\n-+â”Š   â”Š 37â”Š    }\n-+â”Š   â”Š 38â”Š\n-+â”Š   â”Š 39â”Š    return Nullable<double>(utils::trim((_r * std::cos(rad)) + _x, 9));\n-+â”Š   â”Š 40â”Š  }\n-+â”Š   â”Š 41â”Š\n-+â”Š   â”Š 42â”Š  // Gets the matching y value for the given radian\n-+â”Š   â”Š 43â”Š  Nullable<double> Circle::getMatchingY(double rad) {\n-+â”Š   â”Š 44â”Š    if (!utils::chain(rad)->trim(9)->isBetween(_rad1, _rad2)->result()) {\n-+â”Š   â”Š 45â”Š      return Nullable<double>();\n-+â”Š   â”Š 46â”Š    }\n-+â”Š   â”Š 47â”Š\n-+â”Š   â”Š 48â”Š    return Nullable<double>(utils::trim((_r * std::sin(rad)) + _y, 9));\n-+â”Š   â”Š 49â”Š  }\n-+â”Š   â”Š 50â”Š\n-+â”Š   â”Š 51â”Š  // Gets the matching point for the given radian\n-+â”Š   â”Š 52â”Š  Nullable<Point> Circle::getMatchingPoint(double rad) {\n-+â”Š   â”Š 53â”Š    if (!utils::isBetween(rad, _rad1, _rad2)) {\n-+â”Š   â”Š 54â”Š      return Nullable<Point>();\n-+â”Š   â”Š 55â”Š    }\n-+â”Š   â”Š 56â”Š\n-+â”Š   â”Š 57â”Š    return Nullable<Point>({\n-+â”Š   â”Š 58â”Š      utils::trim((_r * std::cos(rad)) + _x, 9),\n-+â”Š   â”Š 59â”Š      utils::trim((_r * std::sin(rad)) + _y, 9)\n-+â”Š   â”Š 60â”Š    });\n-+â”Š   â”Š 61â”Š  }\n-+â”Š   â”Š 62â”Š\n-+â”Š   â”Š 63â”Š  // Gets the matching radian for the given point\n-+â”Š   â”Š 64â”Š  Nullable<double> Circle::getMatchingRad(double x, double y) {\n-+â”Š   â”Š 65â”Š    double rad = std::atan2(y - _y, x - _x);\n-+â”Š   â”Š 66â”Š\n-+â”Š   â”Š 67â”Š    // If calculated radian is in circle's radian range, return it\n-+â”Š   â”Š 68â”Š    if (!std::isnan(rad) && utils::isBetween(rad, _rad1, _rad2)) {\n-+â”Š   â”Š 69â”Š      return Nullable<double>(rad);\n-+â”Š   â”Š 70â”Š    }\n-+â”Š   â”Š 71â”Š\n-+â”Š   â”Š 72â”Š    // The calculated radian can still be in the circle's radian range in case one\n-+â”Š   â”Š 73â”Š    // of the radians is greater than 2 PIEs\n-+â”Š   â”Š 74â”Š    double greatestRad = std::abs(_rad1) > std::abs(_rad2) ? _rad1 : _rad2;\n-+â”Š   â”Š 75â”Š\n-+â”Š   â”Š 76â”Š    // Check if the absolute radian is in the circle's radian range\n-+â”Š   â”Š 77â”Š    if (utils::chain(rad + (2 * M_PI * std::floor(greatestRad / (2 * M_PI))))\n-+â”Š   â”Š 78â”Š        ->trim(9)->isBetween(_rad1, _rad2)->result() ||\n-+â”Š   â”Š 79â”Š        utils::chain(rad + (2 * M_PI * std::ceil(greatestRad / (2 * M_PI))))\n-+â”Š   â”Š 80â”Š        ->trim(9)->isBetween(_rad1, _rad2)->result()) {\n-+â”Š   â”Š 81â”Š      return Nullable<double>(rad);\n-+â”Š   â”Š 82â”Š    }\n-+â”Š   â”Š 83â”Š\n-+â”Š   â”Š 84â”Š    return Nullable<double>();\n-+â”Š   â”Š 85â”Š  }\n-+â”Š   â”Š 86â”Š\n-+â”Š   â”Š 87â”Š  // Returns if circle has given points\n-+â”Š   â”Š 88â”Š  bool Circle::hasPoint(double x, double y) {\n-+â”Š   â”Š 89â”Š    return getMatchingRad(x, y).hasValue();\n-+â”Š   â”Š 90â”Š  }\n-+â”Š   â”Š 91â”Š\n-+â”Š   â”Š 92â”Š  // circle - circle intersection method\n-+â”Š   â”Š 93â”Š  Nullable<std::vector<Point>> Circle::getIntersection(Circle circle) {\n-+â”Š   â”Š 94â”Š    double dx = circle._x - _x;\n-+â”Š   â”Š 95â”Š    double dy = circle._y - _y;\n-+â”Š   â”Š 96â”Š    double d = std::sqrt(std::pow(dx, 2) + std::pow(dy, 2));\n-+â”Š   â”Š 97â”Š\n-+â”Š   â”Š 98â”Š    if (d > _r + circle._r ||\n-+â”Š   â”Š 99â”Š       d < std::abs(_r - circle._r)) {\n-+â”Š   â”Š100â”Š      return Nullable<std::vector<Point>>();\n-+â”Š   â”Š101â”Š    }\n-+â”Š   â”Š102â”Š\n-+â”Š   â”Š103â”Š    double a = ((std::pow(_r, 2) - std::pow(circle._r, 2)) + std::pow(d, 2)) / (2 * d);\n-+â”Š   â”Š104â”Š    double x = _x + ((dx * a) / d);\n-+â”Š   â”Š105â”Š    double y = _y + ((dy * a) / d);\n-+â”Š   â”Š106â”Š    double h = std::sqrt(std::pow(_r, 2) - std::pow(a, 2));\n-+â”Š   â”Š107â”Š    double rx = (- dy * h) / d;\n-+â”Š   â”Š108â”Š    double ry = (dx * h) / d;\n-+â”Š   â”Š109â”Š\n-+â”Š   â”Š110â”Š    std::vector<Point> interPoints(2);\n-+â”Š   â”Š111â”Š    interPoints.at(0).x = x + rx;\n-+â”Š   â”Š112â”Š    interPoints.at(0).y = y + ry;\n-+â”Š   â”Š113â”Š    interPoints.at(1).x = x - rx;\n-+â”Š   â”Š114â”Š    interPoints.at(1).y = y - ry;\n-+â”Š   â”Š115â”Š\n-+â”Š   â”Š116â”Š    for (unsigned i = 0; i < interPoints.size(); i++) {\n-+â”Š   â”Š117â”Š      Point& point = interPoints.at(i);\n-+â”Š   â”Š118â”Š      point.x = utils::trim(point.x, 9);\n-+â”Š   â”Š119â”Š      point.y = utils::trim(point.y, 9);\n-+â”Š   â”Š120â”Š    }\n-+â”Š   â”Š121â”Š\n-+â”Š   â”Š122â”Š    auto pointsBegin = std::unique(interPoints.begin(), interPoints.end(),\n-+â”Š   â”Š123â”Š      [](Point pointA, Point pointB) {\n-+â”Š   â”Š124â”Š        return pointA.x == pointB.x && pointA.y == pointB.y;\n-+â”Š   â”Š125â”Š      }\n-+â”Š   â”Š126â”Š    );\n-+â”Š   â”Š127â”Š\n-+â”Š   â”Š128â”Š    interPoints.erase(pointsBegin, interPoints.end());\n-+â”Š   â”Š129â”Š\n-+â”Š   â”Š130â”Š    std::vector<Circle> circles = { *this, circle };\n-+â”Š   â”Š131â”Š\n-+â”Š   â”Š132â”Š    std::for_each(circles.begin(), circles.end(), [&interPoints](Circle circle) {\n-+â”Š   â”Š133â”Š      auto pointsBegin = std::remove_if(interPoints.begin(), interPoints.end(),\n-+â”Š   â”Š134â”Š        [&circle](Point point) {\n-+â”Š   â”Š135â”Š          return !circle.hasPoint(point.x, point.y);\n-+â”Š   â”Š136â”Š        }\n-+â”Š   â”Š137â”Š      );\n-+â”Š   â”Š138â”Š\n-+â”Š   â”Š139â”Š      interPoints.erase(pointsBegin, interPoints.end());\n-+â”Š   â”Š140â”Š    });\n-+â”Š   â”Š141â”Š\n-+â”Š   â”Š142â”Š    if (interPoints.size()) {\n-+â”Š   â”Š143â”Š      return Nullable<std::vector<Point>>(interPoints);\n-+â”Š   â”Š144â”Š    }\n-+â”Š   â”Š145â”Š\n-+â”Š   â”Š146â”Š    return Nullable<std::vector<Point>>();\n-+â”Š   â”Š147â”Š  }\n-+â”Š   â”Š148â”Š\n-+â”Š   â”Š149â”Š  // circle - line intersection method\n-+â”Š   â”Š150â”Š  Nullable<std::vector<Point>> Circle::getIntersection(Line line) {\n-+â”Š   â”Š151â”Š    double x1 = line._x1 - _x;\n-+â”Š   â”Š152â”Š    double x2 = line._x2 - _x;\n-+â”Š   â”Š153â”Š    double y1 = line._y1 - _y;\n-+â”Š   â”Š154â”Š    double y2 = line._y2 - _y;\n-+â”Š   â”Š155â”Š    double dx = x2 - x1;\n-+â”Š   â”Š156â”Š    double dy = y2 - y1;\n-+â”Š   â”Š157â”Š    double d = std::sqrt(std::pow(dx, 2) + std::pow(dy, 2));\n-+â”Š   â”Š158â”Š    double h = (x1 * y2) - (x2 * y1);\n-+â”Š   â”Š159â”Š    double delta = (std::pow(_r, 2) * std::pow(d, 2)) - std::pow(h, 2);\n-+â”Š   â”Š160â”Š\n-+â”Š   â”Š161â”Š    if (delta < 0) Nullable<std::vector<Point>>();\n-+â”Š   â”Š162â”Š\n-+â”Š   â”Š163â”Š    double sign = dy / std::abs(dy); if (std::isnan(sign)) sign = 1;\n-+â”Š   â”Š164â”Š    double sqrtx = sign * dx * std::sqrt(delta);\n-+â”Š   â”Š165â”Š    double sqrty = std::abs(dy) * std::sqrt(delta);\n-+â”Š   â”Š166â”Š\n-+â”Š   â”Š167â”Š    std::vector<Point> interPoints(2);\n-+â”Š   â”Š168â”Š    interPoints.at(0).x = (((h * dy) + sqrtx) / std::pow(d, 2)) + _x;\n-+â”Š   â”Š169â”Š    interPoints.at(0).y = (((-h * dx) + sqrty) / std::pow(d, 2)) + _y;\n-+â”Š   â”Š170â”Š    interPoints.at(1).x = (((h * dy) - sqrtx) / std::pow(d, 2)) + _x;\n-+â”Š   â”Š171â”Š    interPoints.at(1).y = (((-h * dx) - sqrty) / std::pow(d, 2)) + _y;\n-+â”Š   â”Š172â”Š\n-+â”Š   â”Š173â”Š    for (unsigned i = 0; i < interPoints.size(); i++) {\n-+â”Š   â”Š174â”Š      Point& point = interPoints.at(i);\n-+â”Š   â”Š175â”Š      point.x = utils::trim(point.x, 9);\n-+â”Š   â”Š176â”Š      point.y = utils::trim(point.y, 9);\n-+â”Š   â”Š177â”Š    }\n-+â”Š   â”Š178â”Š\n-+â”Š   â”Š179â”Š    auto pointsBegin = std::remove_if(interPoints.begin(), interPoints.end(),\n-+â”Š   â”Š180â”Š      [this, &line](Point point) {\n-+â”Š   â”Š181â”Š        return !hasPoint(point.x, point.y) ||\n-+â”Š   â”Š182â”Š          !line.boundsHavePoint(point.x, point.y);\n-+â”Š   â”Š183â”Š      }\n-+â”Š   â”Š184â”Š    );\n-+â”Š   â”Š185â”Š\n-+â”Š   â”Š186â”Š    interPoints.erase(pointsBegin, interPoints.end());\n-+â”Š   â”Š187â”Š\n-+â”Š   â”Š188â”Š    pointsBegin = std::unique(interPoints.begin(), interPoints.end(),\n-+â”Š   â”Š189â”Š      [](Point pointA, Point pointB) {\n-+â”Š   â”Š190â”Š        return pointA.x == pointB.x && pointA.y == pointB.y;\n-+â”Š   â”Š191â”Š      }\n-+â”Š   â”Š192â”Š    );\n-+â”Š   â”Š193â”Š\n-+â”Š   â”Š194â”Š    interPoints.erase(pointsBegin, interPoints.end());\n-+â”Š   â”Š195â”Š\n-+â”Š   â”Š196â”Š    if (interPoints.size()) {\n-+â”Š   â”Š197â”Š      return Nullable<std::vector<Point>>(interPoints);\n-+â”Š   â”Š198â”Š    }\n-+â”Š   â”Š199â”Š\n-+â”Š   â”Š200â”Š    return Nullable<std::vector<Point>>();\n-+â”Š   â”Š201â”Š  }\n-+â”Š   â”Š202â”Š}ðŸš«â†µ\n-```\n-\n-##### Added resources/cpp/src/geometry/circle.h\n-```diff\n-@@ -0,0 +1,35 @@\n-+â”Š  â”Š 1â”Š#pragma once\n-+â”Š  â”Š 2â”Š\n-+â”Š  â”Š 3â”Š#include <vector>\n-+â”Š  â”Š 4â”Š#include \"../nullable.h\"\n-+â”Š  â”Š 5â”Š#include \"point.h\"\n-+â”Š  â”Š 6â”Š#include \"line.h\"\n-+â”Š  â”Š 7â”Š\n-+â”Š  â”Š 8â”Šnamespace geometry {\n-+â”Š  â”Š 9â”Š  class Line;\n-+â”Š  â”Š10â”Š\n-+â”Š  â”Š11â”Š  class Circle {\n-+â”Š  â”Š12â”Š  public:\n-+â”Š  â”Š13â”Š    double _x;\n-+â”Š  â”Š14â”Š    double _y;\n-+â”Š  â”Š15â”Š    double _r;\n-+â”Š  â”Š16â”Š    double _rad1;\n-+â”Š  â”Š17â”Š    double _rad2;\n-+â”Š  â”Š18â”Š\n-+â”Š  â”Š19â”Š    Circle(double x, double y, double r, double rad1, double rad2);\n-+â”Š  â”Š20â”Š\n-+â”Š  â”Š21â”Š    Nullable<double> getMatchingX(double rad);\n-+â”Š  â”Š22â”Š\n-+â”Š  â”Š23â”Š    Nullable<double> getMatchingY(double rad);\n-+â”Š  â”Š24â”Š\n-+â”Š  â”Š25â”Š    Nullable<Point> getMatchingPoint(double rad);\n-+â”Š  â”Š26â”Š\n-+â”Š  â”Š27â”Š    Nullable<double> getMatchingRad(double x, double y);\n-+â”Š  â”Š28â”Š\n-+â”Š  â”Š29â”Š    bool hasPoint(double x, double y);\n-+â”Š  â”Š30â”Š\n-+â”Š  â”Š31â”Š    Nullable<std::vector<Point>> getIntersection(Circle circle);\n-+â”Š  â”Š32â”Š\n-+â”Š  â”Š33â”Š    Nullable<std::vector<Point>> getIntersection(Line line);\n-+â”Š  â”Š34â”Š  };\n-+â”Š  â”Š35â”Š}ðŸš«â†µ\n-```\n-\n-##### Changed resources/cpp/src/index.cpp\n-```diff\n-@@ -1,3 +1,4 @@\n- â”Š1â”Š1â”Š#include \"nullable.cpp\"\n- â”Š2â”Š2â”Š#include \"utils.cpp\"\n--â”Š3â”Š â”Š#include \"geometry/line.cpp\"ðŸš«â†µ\n-+â”Š â”Š3â”Š#include \"geometry/line.cpp\"\n-+â”Š â”Š4â”Š#include \"geometry/circle.cpp\"ðŸš«â†µ\n-```\n-[}]: #\n-\n-Second, we need to wrap our code using EMBind:\n-\n-[{]: <helper> (diff_step 7.20)\n-#### Step 7.20: EMBind CPP circle\n-\n-##### Changed resources/cpp/post.js\n-```diff\n-@@ -7,7 +7,8 @@\n- â”Š 7â”Š 7â”Š  },\n- â”Š 8â”Š 8â”Š\n- â”Š 9â”Š 9â”Š  Geometry: {\n--â”Š10â”Š  â”Š    Line: Module.geometry_line\n-+â”Š  â”Š10â”Š    Line: Module.geometry_line,\n-+â”Š  â”Š11â”Š    Circle: Module.geometry_circle\n- â”Š11â”Š12â”Š  }\n- â”Š12â”Š13â”Š};\n- â”Š13â”Š14â”Š\n-```\n-\n-##### Changed resources/cpp/src/geometry/circle.cpp\n-```diff\n-@@ -1,7 +1,8 @@\n--â”Š1â”Š â”Š\n- â”Š2â”Š1â”Š#include <algorithm>\n- â”Š3â”Š2â”Š#include <cmath>\n- â”Š4â”Š3â”Š#include <vector>\n-+â”Š â”Š4â”Š#include <emscripten/bind.h>\n-+â”Š â”Š5â”Š#include <emscripten/val.h>\n- â”Š5â”Š6â”Š#include \"../nullable.h\"\n- â”Š6â”Š7â”Š#include \"../utils.h\"\n- â”Š7â”Š8â”Š#include \"point.h\"\n-```\n-```diff\n-@@ -199,4 +200,107 @@\n- â”Š199â”Š200â”Š\n- â”Š200â”Š201â”Š    return Nullable<std::vector<Point>>();\n- â”Š201â”Š202â”Š  }\n-+â”Š   â”Š203â”Š\n-+â”Š   â”Š204â”Š  emscripten::val EMCircle::getMatchingX(double y) {\n-+â”Š   â”Š205â”Š    Nullable<double> nullableX = Circle::getMatchingX(y);\n-+â”Š   â”Š206â”Š    return nullableX.hasValue() ?\n-+â”Š   â”Š207â”Š      emscripten::val(nullableX.getValue()) :\n-+â”Š   â”Š208â”Š      emscripten::val::undefined();\n-+â”Š   â”Š209â”Š  }\n-+â”Š   â”Š210â”Š\n-+â”Š   â”Š211â”Š  emscripten::val EMCircle::getMatchingY(double x) {\n-+â”Š   â”Š212â”Š    Nullable<double> nullableY = Circle::getMatchingY(x);\n-+â”Š   â”Š213â”Š    return nullableY.hasValue() ?\n-+â”Š   â”Š214â”Š      emscripten::val(nullableY.getValue()) :\n-+â”Š   â”Š215â”Š      emscripten::val::undefined();\n-+â”Š   â”Š216â”Š  }\n-+â”Š   â”Š217â”Š\n-+â”Š   â”Š218â”Š  emscripten::val EMCircle::getMatchingPoint(double rad) {\n-+â”Š   â”Š219â”Š    Nullable<Point> nullablePoint = Circle::getMatchingPoint(rad);\n-+â”Š   â”Š220â”Š\n-+â”Š   â”Š221â”Š    if (nullablePoint.isNull()) return emscripten::val::undefined();\n-+â”Š   â”Š222â”Š\n-+â”Š   â”Š223â”Š    Point point = nullablePoint.getValue();\n-+â”Š   â”Š224â”Š    emscripten::val emPoint = emscripten::val::object();\n-+â”Š   â”Š225â”Š    emPoint.set(\"x\", emscripten::val(point.x));\n-+â”Š   â”Š226â”Š    emPoint.set(\"y\", emscripten::val(point.y));\n-+â”Š   â”Š227â”Š    return emPoint;\n-+â”Š   â”Š228â”Š  }\n-+â”Š   â”Š229â”Š\n-+â”Š   â”Š230â”Š  emscripten::val EMCircle::getMatchingRad(double x, double y) {\n-+â”Š   â”Š231â”Š    Nullable<double> nullableRad = Circle::getMatchingRad(x, y);\n-+â”Š   â”Š232â”Š    return nullableRad.hasValue() ?\n-+â”Š   â”Š233â”Š      emscripten::val(nullableRad.getValue()) :\n-+â”Š   â”Š234â”Š      emscripten::val::undefined();\n-+â”Š   â”Š235â”Š  }\n-+â”Š   â”Š236â”Š\n-+â”Š   â”Š237â”Š  emscripten::val EMCircle::getIntersection(EMLine emLine) {\n-+â”Š   â”Š238â”Š    Line line = Line(emLine._x1, emLine._y1, emLine._x2, emLine._y2);\n-+â”Š   â”Š239â”Š    Nullable<std::vector<Point>> nullablePoints = Circle::getIntersection(line);\n-+â”Š   â”Š240â”Š\n-+â”Š   â”Š241â”Š    if (nullablePoints.isNull()) return emscripten::val::undefined();\n-+â”Š   â”Š242â”Š\n-+â”Š   â”Š243â”Š    std::vector<Point> points = nullablePoints.getValue();\n-+â”Š   â”Š244â”Š    emscripten::val emPoints = emscripten::val::array();\n-+â”Š   â”Š245â”Š\n-+â”Š   â”Š246â”Š    for (unsigned i = 0; i < points.size(); i++) {\n-+â”Š   â”Š247â”Š      Point point = points.at(i);\n-+â”Š   â”Š248â”Š      emscripten::val emPoint = emscripten::val::object();\n-+â”Š   â”Š249â”Š      emPoint.set(\"x\", emscripten::val(point.x));\n-+â”Š   â”Š250â”Š      emPoint.set(\"y\", emscripten::val(point.y));\n-+â”Š   â”Š251â”Š      emPoints.set(i, emPoint);\n-+â”Š   â”Š252â”Š    }\n-+â”Š   â”Š253â”Š\n-+â”Š   â”Š254â”Š    return emPoints;\n-+â”Š   â”Š255â”Š  }\n-+â”Š   â”Š256â”Š\n-+â”Š   â”Š257â”Š  emscripten::val EMCircle::getIntersection(EMCircle emCircle) {\n-+â”Š   â”Š258â”Š    Circle circle = Circle(\n-+â”Š   â”Š259â”Š      emCircle._x, emCircle._y, emCircle._r, emCircle._rad1, emCircle._rad2\n-+â”Š   â”Š260â”Š    );\n-+â”Š   â”Š261â”Š    Nullable<std::vector<Point>> nullablePoints = Circle::getIntersection(circle);\n-+â”Š   â”Š262â”Š\n-+â”Š   â”Š263â”Š    if (nullablePoints.isNull()) return emscripten::val::undefined();\n-+â”Š   â”Š264â”Š\n-+â”Š   â”Š265â”Š    std::vector<Point> points = nullablePoints.getValue();\n-+â”Š   â”Š266â”Š    emscripten::val emPoints = emscripten::val::array();\n-+â”Š   â”Š267â”Š\n-+â”Š   â”Š268â”Š    for (unsigned i = 0; i < points.size(); i++) {\n-+â”Š   â”Š269â”Š      Point point = points.at(i);\n-+â”Š   â”Š270â”Š      emscripten::val emPoint = emscripten::val::object();\n-+â”Š   â”Š271â”Š      emPoint.set(\"x\", emscripten::val(point.x));\n-+â”Š   â”Š272â”Š      emPoint.set(\"y\", emscripten::val(point.y));\n-+â”Š   â”Š273â”Š      emPoints.set(i, emPoint);\n-+â”Š   â”Š274â”Š    }\n-+â”Š   â”Š275â”Š\n-+â”Š   â”Š276â”Š    return emPoints;\n-+â”Š   â”Š277â”Š  }\n-+â”Š   â”Š278â”Š}\n-+â”Š   â”Š279â”Š\n-+â”Š   â”Š280â”ŠEMSCRIPTEN_BINDINGS(geometry_circle_module) {\n-+â”Š   â”Š281â”Š  emscripten::class_<geometry::Circle>(\"geometry_circle_base\")\n-+â”Š   â”Š282â”Š    .constructor<double, double, double, double, double>()\n-+â”Š   â”Š283â”Š    .property<double>(\"x\", &geometry::Circle::_x)\n-+â”Š   â”Š284â”Š    .property<double>(\"y\", &geometry::Circle::_y)\n-+â”Š   â”Š285â”Š    .property<double>(\"r\", &geometry::Circle::_r)\n-+â”Š   â”Š286â”Š    .property<double>(\"rad1\", &geometry::Circle::_rad1)\n-+â”Š   â”Š287â”Š    .property<double>(\"rad2\", &geometry::Circle::_rad2)\n-+â”Š   â”Š288â”Š    .function(\"hasPoint\", &geometry::Circle::hasPoint);\n-+â”Š   â”Š289â”Š\n-+â”Š   â”Š290â”Š  emscripten::class_<geometry::EMCircle, emscripten::base<geometry::Circle>>(\"geometry_circle\")\n-+â”Š   â”Š291â”Š    .constructor<double, double, double, double, double>()\n-+â”Š   â”Š292â”Š    .function(\"getX\", &geometry::EMCircle::getMatchingX)\n-+â”Š   â”Š293â”Š    .function(\"getY\", &geometry::EMCircle::getMatchingY)\n-+â”Š   â”Š294â”Š    .function(\"getPoint\", &geometry::EMCircle::getMatchingPoint)\n-+â”Š   â”Š295â”Š    .function(\"getRad\", &geometry::EMCircle::getMatchingRad)\n-+â”Š   â”Š296â”Š    .function(\"getLineIntersection\",\n-+â”Š   â”Š297â”Š      emscripten::select_overload<emscripten::val(geometry::EMLine)>(\n-+â”Š   â”Š298â”Š        &geometry::EMCircle::getIntersection\n-+â”Š   â”Š299â”Š      )\n-+â”Š   â”Š300â”Š    )\n-+â”Š   â”Š301â”Š    .function(\"getCircleIntersection\",\n-+â”Š   â”Š302â”Š      emscripten::select_overload<emscripten::val(geometry::EMCircle)>(\n-+â”Š   â”Š303â”Š        &geometry::EMCircle::getIntersection\n-+â”Š   â”Š304â”Š      )\n-+â”Š   â”Š305â”Š    );\n- â”Š202â”Š306â”Š}ðŸš«â†µ\n-```\n-\n-##### Changed resources/cpp/src/geometry/circle.h\n-```diff\n-@@ -1,12 +1,14 @@\n- â”Š 1â”Š 1â”Š#pragma once\n- â”Š 2â”Š 2â”Š\n- â”Š 3â”Š 3â”Š#include <vector>\n-+â”Š  â”Š 4â”Š#include <emscripten/val.h>\n- â”Š 4â”Š 5â”Š#include \"../nullable.h\"\n- â”Š 5â”Š 6â”Š#include \"point.h\"\n- â”Š 6â”Š 7â”Š#include \"line.h\"\n- â”Š 7â”Š 8â”Š\n- â”Š 8â”Š 9â”Šnamespace geometry {\n- â”Š 9â”Š10â”Š  class Line;\n-+â”Š  â”Š11â”Š  class EMLine;\n- â”Š10â”Š12â”Š\n- â”Š11â”Š13â”Š  class Circle {\n- â”Š12â”Š14â”Š  public:\n-```\n-```diff\n-@@ -32,4 +34,21 @@\n- â”Š32â”Š34â”Š\n- â”Š33â”Š35â”Š    Nullable<std::vector<Point>> getIntersection(Line line);\n- â”Š34â”Š36â”Š  };\n-+â”Š  â”Š37â”Š\n-+â”Š  â”Š38â”Š  class EMCircle : public Circle {\n-+â”Š  â”Š39â”Š  public:\n-+â”Š  â”Š40â”Š    using Circle::Circle;\n-+â”Š  â”Š41â”Š\n-+â”Š  â”Š42â”Š    emscripten::val getMatchingX(double y);\n-+â”Š  â”Š43â”Š\n-+â”Š  â”Š44â”Š    emscripten::val getMatchingY(double x);\n-+â”Š  â”Š45â”Š\n-+â”Š  â”Š46â”Š    emscripten::val getMatchingPoint(double rad);\n-+â”Š  â”Š47â”Š\n-+â”Š  â”Š48â”Š    emscripten::val getMatchingRad(double x, double y);\n-+â”Š  â”Š49â”Š\n-+â”Š  â”Š50â”Š    emscripten::val getIntersection(EMLine line);\n-+â”Š  â”Š51â”Š\n-+â”Š  â”Š52â”Š    emscripten::val getIntersection(EMCircle circle);\n-+â”Š  â”Š53â”Š  };\n- â”Š35â”Š54â”Š}ðŸš«â†µ\n-```\n-[}]: #\n-\n-And finally, we will extend the C++ in our JavaScript circle:\n-\n-[{]: <helper> (diff_step 7.21)\n-#### Step 7.21: Extend CPP circle class\n-\n-##### Changed resources/scripts/engine/geometry/circle.js\n-```diff\n-@@ -1,83 +1,9 @@\n--â”Š 1â”Š  â”ŠEngine.Geometry.Circle = class Circle {\n--â”Š 2â”Š  â”Š  // x - The x value of the circle's center\n--â”Š 3â”Š  â”Š  // y - The y value of the circle's center\n--â”Š 4â”Š  â”Š  // r - The radius of the center\n--â”Š 5â”Š  â”Š  // rad1 - The first radian of the circle, not necessarily its beginning\n--â”Š 6â”Š  â”Š  // rad2 - The second radian of the circle, not necessarily its beginning\n--â”Š 7â”Š  â”Š  constructor(x, y, r, rad1, rad2) {\n--â”Š 8â”Š  â”Š    this.x = Utils.trim(x, 9);\n--â”Š 9â”Š  â”Š    this.y = Utils.trim(y, 9);\n--â”Š10â”Š  â”Š    this.r = Utils.trim(r, 9);\n--â”Š11â”Š  â”Š\n--â”Š12â”Š  â”Š    // Trimming mode is done based on which radian represents the ending and which radian\n--â”Š13â”Š  â”Š    // represents the ending\n--â”Š14â”Š  â”Š    if (rad1 > rad2) {\n--â”Š15â”Š  â”Š      this.rad1 = Utils.trim(rad1, 9, \"floor\");\n--â”Š16â”Š  â”Š      this.rad2 = Utils.trim(rad2, 9, \"ceil\");\n--â”Š17â”Š  â”Š    }\n--â”Š18â”Š  â”Š    else {\n--â”Š19â”Š  â”Š      this.rad1 = Utils.trim(rad1, 9, \"ceil\");\n--â”Š20â”Š  â”Š      this.rad2 = Utils.trim(rad2, 9, \"floor\");\n--â”Š21â”Š  â”Š    }\n--â”Š22â”Š  â”Š  }\n--â”Š23â”Š  â”Š\n-+â”Š  â”Š 1â”ŠEngine.Geometry.Circle = class Circle extends Utils.proxy(CPP.Geometry.Circle) {\n- â”Š24â”Š 2â”Š  // Draws the circle on the given context\n- â”Š25â”Š 3â”Š  draw(context) {\n- â”Š26â”Š 4â”Š    context.arc(this.x, this.y, this.r, this.rad1, this.rad2);\n- â”Š27â”Š 5â”Š  }\n- â”Š28â”Š 6â”Š\n--â”Š29â”Š  â”Š  // Gets the matching x value for the given radian\n--â”Š30â”Š  â”Š  getX(rad) {\n--â”Š31â”Š  â”Š    if (!Utils(rad).trim(9).isBetween(this.rad1, this.rad2).value()) return;\n--â”Š32â”Š  â”Š    return Utils.trim((this.r * Math.cos(rad)) + this.x, 9);\n--â”Š33â”Š  â”Š  }\n--â”Š34â”Š  â”Š\n--â”Š35â”Š  â”Š  // Gets the matching y value for the given radian\n--â”Š36â”Š  â”Š  getY(rad) {\n--â”Š37â”Š  â”Š    if (!Utils(rad).trim(9).isBetween(this.rad1, this.rad2).value()) return;\n--â”Š38â”Š  â”Š    return Utils.trim((this.r * Math.sin(rad)) + this.y, 9);\n--â”Š39â”Š  â”Š  }\n--â”Š40â”Š  â”Š\n--â”Š41â”Š  â”Š  // Gets the matching point for the given radian\n--â”Š42â”Š  â”Š  getPoint(rad) {\n--â”Š43â”Š  â”Š    if (!Utils.isBetween(rad, this.rad1, this.rad2)) return;\n--â”Š44â”Š  â”Š\n--â”Š45â”Š  â”Š    return {\n--â”Š46â”Š  â”Š      x: Utils.trim((this.r * Math.cos(rad)) + this.x, 9),\n--â”Š47â”Š  â”Š      y: Utils.trim((this.r * Math.sin(rad)) + this.y, 9)\n--â”Š48â”Š  â”Š    };\n--â”Š49â”Š  â”Š  }\n--â”Š50â”Š  â”Š\n--â”Š51â”Š  â”Š  // Gets the matching radian for the given point\n--â”Š52â”Š  â”Š  getRad(x, y) {\n--â”Š53â”Š  â”Š    let rad = Math.atan2(y - this.y, x - this.x);\n--â”Š54â”Š  â”Š\n--â”Š55â”Š  â”Š    // If calculated radian is in circle's radian range, return it\n--â”Š56â”Š  â”Š    if (rad != null && Utils.isBetween(rad, this.rad1, this.rad2)) {\n--â”Š57â”Š  â”Š      return rad;\n--â”Š58â”Š  â”Š    }\n--â”Š59â”Š  â”Š\n--â”Š60â”Š  â”Š    // The calculated radian can still be in the circle's radian range in case one\n--â”Š61â”Š  â”Š    // of the radians is greater than 2 PIEs\n--â”Š62â”Š  â”Š    if (Math.abs(this.rad1) > Math.abs(this.rad2)) {\n--â”Š63â”Š  â”Š      var greatestRad = this.rad1;\n--â”Š64â”Š  â”Š    }\n--â”Š65â”Š  â”Š    else {\n--â”Š66â”Š  â”Š      var greatestRad = this.rad2;\n--â”Š67â”Š  â”Š    }\n--â”Š68â”Š  â”Š\n--â”Š69â”Š  â”Š    // Check if the absolute radian is in the circle's radian range\n--â”Š70â”Š  â”Š    if (Utils(rad + (2 * Math.PI * Math.floor(greatestRad / (2 * Math.PI)))).trim(9).isBetween(this.rad1, this.rad2).value() ||\n--â”Š71â”Š  â”Š        Utils(rad + (2 * Math.PI * Math.ceil(greatestRad / (2 * Math.PI)))).trim(9).isBetween(this.rad1, this.rad2).value()) {\n--â”Š72â”Š  â”Š      return rad;\n--â”Š73â”Š  â”Š    }\n--â”Š74â”Š  â”Š  }\n--â”Š75â”Š  â”Š\n--â”Š76â”Š  â”Š  // Returns if circle has given points\n--â”Š77â”Š  â”Š  hasPoint(x, y) {\n--â”Š78â”Š  â”Š    return this.getRad(x, y) != null;\n--â”Š79â”Š  â”Š  }\n--â”Š80â”Š  â”Š\n- â”Š81â”Š 7â”Š  getIntersection(shape) {\n- â”Š82â”Š 8â”Š    if (shape instanceof Engine.Geometry.Line)\n- â”Š83â”Š 9â”Š      return this.getLineIntersection(shape);\n-```\n-```diff\n-@@ -87,86 +13,6 @@\n- â”Š 87â”Š 13â”Š      return this.getPolygonIntersection(shape);\n- â”Š 88â”Š 14â”Š  }\n- â”Š 89â”Š 15â”Š\n--â”Š 90â”Š   â”Š  // circle - circle intersection method\n--â”Š 91â”Š   â”Š  getCircleIntersection(circle) {\n--â”Š 92â”Š   â”Š    let dx = circle.x - this.x;\n--â”Š 93â”Š   â”Š    let dy = circle.y - this.y;\n--â”Š 94â”Š   â”Š    let d = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\n--â”Š 95â”Š   â”Š\n--â”Š 96â”Š   â”Š    if (d > this.r + circle.r ||\n--â”Š 97â”Š   â”Š       d < Math.abs(this.r - circle.r)) {\n--â”Š 98â”Š   â”Š      return;\n--â”Š 99â”Š   â”Š    }\n--â”Š100â”Š   â”Š\n--â”Š101â”Š   â”Š    let a = ((Math.pow(this.r, 2) - Math.pow(circle.r, 2)) + Math.pow(d, 2)) / (2 * d);\n--â”Š102â”Š   â”Š    let x = this.x + ((dx * a) / d);\n--â”Š103â”Š   â”Š    let y = this.y + ((dy * a) / d);\n--â”Š104â”Š   â”Š    let h = Math.sqrt(Math.pow(this.r, 2) - Math.pow(a, 2));\n--â”Š105â”Š   â”Š    let rx = (- dy * h) / d;\n--â”Š106â”Š   â”Š    let ry = (dx * h) / d;\n--â”Š107â”Š   â”Š\n--â”Š108â”Š   â”Š    let interPoints = [\n--â”Š109â”Š   â”Š      {\n--â”Š110â”Š   â”Š        x: x + rx,\n--â”Š111â”Š   â”Š        y: y + ry\n--â”Š112â”Š   â”Š      },\n--â”Š113â”Š   â”Š      {\n--â”Š114â”Š   â”Š        x: x - rx,\n--â”Š115â”Š   â”Š        y: y - ry\n--â”Š116â”Š   â”Š      }\n--â”Š117â”Š   â”Š    ]\n--â”Š118â”Š   â”Š    .map(point => ({\n--â”Š119â”Š   â”Š        x: Utils.trim(point.x, 9),\n--â”Š120â”Š   â”Š        y: Utils.trim(point.y, 9)\n--â”Š121â”Š   â”Š     }));\n--â”Š122â”Š   â”Š\n--â”Š123â”Š   â”Š    interPoints = _.uniq(interPoints, point => `(${point.x}, ${point.y})`);\n--â”Š124â”Š   â”Š\n--â”Š125â”Š   â”Š    [this, circle].forEach(function(circle) {\n--â”Š126â”Š   â”Š      interPoints = interPoints.filter(point => circle.hasPoint(point.x, point.y));\n--â”Š127â”Š   â”Š    });\n--â”Š128â”Š   â”Š\n--â”Š129â”Š   â”Š    if (interPoints.length > 0) return interPoints;\n--â”Š130â”Š   â”Š  }\n--â”Š131â”Š   â”Š\n--â”Š132â”Š   â”Š  // circle - line intersection method\n--â”Š133â”Š   â”Š  getLineIntersection(line) {\n--â”Š134â”Š   â”Š    let x1 = line.x1 - this.x;\n--â”Š135â”Š   â”Š    let x2 = line.x2 - this.x;\n--â”Š136â”Š   â”Š    let y1 = line.y1 - this.y;\n--â”Š137â”Š   â”Š    let y2 = line.y2 - this.y;\n--â”Š138â”Š   â”Š    let dx = x2 - x1;\n--â”Š139â”Š   â”Š    let dy = y2 - y1;\n--â”Š140â”Š   â”Š    let d = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\n--â”Š141â”Š   â”Š    let h = (x1 * y2) - (x2 * y1);\n--â”Š142â”Š   â”Š    let delta = (Math.pow(this.r, 2) * Math.pow(d, 2)) - Math.pow(h, 2);\n--â”Š143â”Š   â”Š\n--â”Š144â”Š   â”Š    if (delta < 0) return;\n--â”Š145â”Š   â”Š\n--â”Š146â”Š   â”Š    let interPoints = [\n--â”Š147â”Š   â”Š      {\n--â”Š148â”Š   â”Š        x: (((h * dy) + (((dy / Math.abs(dy)) || 1) * dx * Math.sqrt(delta))) / Math.pow(d, 2)) + this.x,\n--â”Š149â”Š   â”Š        y: (((-h * dx) + (Math.abs(dy) * Math.sqrt(delta))) / Math.pow(d, 2)) + this.y\n--â”Š150â”Š   â”Š      },\n--â”Š151â”Š   â”Š      {\n--â”Š152â”Š   â”Š        x: (((h * dy) - (((dy / Math.abs(dy)) || 1) * dx * Math.sqrt(delta))) / Math.pow(d, 2)) + this.x,\n--â”Š153â”Š   â”Š        y: (((-h * dx) - (Math.abs(dy) * Math.sqrt(delta))) / Math.pow(d, 2)) + this.y\n--â”Š154â”Š   â”Š      }\n--â”Š155â”Š   â”Š    ]\n--â”Š156â”Š   â”Š    .map(point => ({\n--â”Š157â”Š   â”Š        x: Utils.trim(point.x, 9),\n--â”Š158â”Š   â”Š        y: Utils.trim(point.y, 9)\n--â”Š159â”Š   â”Š    }))\n--â”Š160â”Š   â”Š    .filter(point => {\n--â”Š161â”Š   â”Š      return this.hasPoint(point.x, point.y) &&\n--â”Š162â”Š   â”Š        line.boundsHavePoint(point.x, point.y);\n--â”Š163â”Š   â”Š    });\n--â”Š164â”Š   â”Š\n--â”Š165â”Š   â”Š    interPoints = _.uniq(interPoints, point => `(${point.x}, ${point.y})`);\n--â”Š166â”Š   â”Š\n--â”Š167â”Š   â”Š    if (interPoints.length > 0) return interPoints;\n--â”Š168â”Š   â”Š  }\n--â”Š169â”Š   â”Š\n- â”Š170â”Š 16â”Š  // circle - polygon intersection method\n- â”Š171â”Š 17â”Š  getPolygonIntersection(polygon) {\n- â”Š172â”Š 18â”Š    return polygon.getCircleIntersection(this);\n-```\n-[}]: #\n-\n-We also need to update the line class to contain a reference to the newly created line-intersection method, so it can be invoked from both a line or a circle bi-directionally:\n-\n-[{]: <helper> (diff_step 7.22)\n-#### Step 7.22: Add line-circle intersection method\n-\n-##### Changed resources/cpp/src/geometry/line.cpp\n-```diff\n-@@ -4,6 +4,7 @@\n- â”Š 4â”Š 4â”Š#include \"../nullable.h\"\n- â”Š 5â”Š 5â”Š#include \"../utils.h\"\n- â”Š 6â”Š 6â”Š#include \"point.h\"\n-+â”Š  â”Š 7â”Š#include \"circle.h\"\n- â”Š 7â”Š 8â”Š#include \"line.h\"\n- â”Š 8â”Š 9â”Š\n- â”Š 9â”Š10â”Šnamespace geometry {\n-```\n-```diff\n-@@ -100,6 +101,11 @@\n- â”Š100â”Š101â”Š    return Nullable<Point>();\n- â”Š101â”Š102â”Š  }\n- â”Š102â”Š103â”Š\n-+â”Š   â”Š104â”Š  // circle - circle intersection method\n-+â”Š   â”Š105â”Š  Nullable<std::vector<Point>> Line::getIntersection(Circle circle) {\n-+â”Š   â”Š106â”Š    return circle.getIntersection(*this);\n-+â”Š   â”Š107â”Š  }\n-+â”Š   â”Š108â”Š\n- â”Š103â”Š109â”Š  emscripten::val EMLine::getMatchingX(double y) {\n- â”Š104â”Š110â”Š    Nullable<double> nullableX = Line::getMatchingX(y);\n- â”Š105â”Š111â”Š    return nullableX.hasValue() ?\n-```\n-```diff\n-@@ -126,6 +132,10 @@\n- â”Š126â”Š132â”Š    emPoint.set(\"y\", emscripten::val(point.y));\n- â”Š127â”Š133â”Š    return emPoint;\n- â”Š128â”Š134â”Š  }\n-+â”Š   â”Š135â”Š\n-+â”Š   â”Š136â”Š  emscripten::val EMLine::getIntersection(EMCircle emCircle) {\n-+â”Š   â”Š137â”Š    return emCircle.getIntersection(*this);\n-+â”Š   â”Š138â”Š  }\n- â”Š129â”Š139â”Š}\n- â”Š130â”Š140â”Š\n- â”Š131â”Š141â”ŠEMSCRIPTEN_BINDINGS(geometry_line_module) {\n-```\n-```diff\n-@@ -146,5 +156,10 @@\n- â”Š146â”Š156â”Š      emscripten::select_overload<emscripten::val(geometry::EMLine)>(\n- â”Š147â”Š157â”Š        &geometry::EMLine::getIntersection\n- â”Š148â”Š158â”Š      )\n-+â”Š   â”Š159â”Š    )\n-+â”Š   â”Š160â”Š    .function(\"getCircleIntersection\",\n-+â”Š   â”Š161â”Š      emscripten::select_overload<emscripten::val(geometry::EMCircle)>(\n-+â”Š   â”Š162â”Š        &geometry::EMLine::getIntersection\n-+â”Š   â”Š163â”Š      )\n- â”Š149â”Š164â”Š    );\n- â”Š150â”Š165â”Š}ðŸš«â†µ\n-```\n-\n-##### Changed resources/cpp/src/geometry/line.h\n-```diff\n-@@ -4,6 +4,7 @@\n- â”Š 4â”Š 4â”Š#include <emscripten/val.h>\n- â”Š 5â”Š 5â”Š#include \"../nullable.h\"\n- â”Š 6â”Š 6â”Š#include \"point.h\"\n-+â”Š  â”Š 7â”Š#include \"circle.h\"\n- â”Š 7â”Š 8â”Š\n- â”Š 8â”Š 9â”Šnamespace geometry {\n- â”Š 9â”Š10â”Š  class Circle;\n-```\n-```diff\n-@@ -27,6 +28,8 @@\n- â”Š27â”Š28â”Š    bool boundsHavePoint(double x, double y);\n- â”Š28â”Š29â”Š\n- â”Š29â”Š30â”Š    Nullable<Point> getIntersection(Line line);\n-+â”Š  â”Š31â”Š\n-+â”Š  â”Š32â”Š    Nullable<std::vector<Point>> getIntersection(Circle circle);\n- â”Š30â”Š33â”Š  };\n- â”Š31â”Š34â”Š\n- â”Š32â”Š35â”Š  class EMLine : public Line {\n-```\n-```diff\n-@@ -38,5 +41,7 @@\n- â”Š38â”Š41â”Š    emscripten::val getMatchingY(double x);\n- â”Š39â”Š42â”Š\n- â”Š40â”Š43â”Š    emscripten::val getIntersection(EMLine line);\n-+â”Š  â”Š44â”Š\n-+â”Š  â”Š45â”Š    emscripten::val getIntersection(EMCircle circle);\n- â”Š41â”Š46â”Š  };\n- â”Š42â”Š47â”Š}ðŸš«â†µ\n-```\n-\n-##### Changed resources/scripts/engine/geometry/line.js\n-```diff\n-@@ -14,11 +14,6 @@\n- â”Š14â”Š14â”Š      return this.getPolygonIntersection(shape);\n- â”Š15â”Š15â”Š  }\n- â”Š16â”Š16â”Š\n--â”Š17â”Š  â”Š  // line - circle intersection method\n--â”Š18â”Š  â”Š  getCircleIntersection(circle) {\n--â”Š19â”Š  â”Š    return circle.getLineIntersection(this);\n--â”Š20â”Š  â”Š  }\n--â”Š21â”Š  â”Š\n- â”Š22â”Š17â”Š  // line - polygon intersection method\n- â”Š23â”Š18â”Š  getPolygonIntersection(polygon) {\n- â”Š24â”Š19â”Š    return polygon.getLineIntersection(this);\n-```\n-[}]: #\n-\n-Now, before running the tests, be sure to disposed unused circle test-data:\n-\n-[{]: <helper> (diff_step 7.23)\n-#### Step 7.23: Delete circle instances in tests\n-\n-##### Changed resources/scripts/specs/engine/geometry/circle.js\n-```diff\n-@@ -3,6 +3,10 @@\n- â”Š 3â”Š 3â”Š    this.circle = new Engine.Geometry.Circle(1, 1, 5, 0, 1.5 * Math.PI);\n- â”Š 4â”Š 4â”Š  });\n- â”Š 5â”Š 5â”Š\n-+â”Š  â”Š 6â”Š  afterEach(function () {\n-+â”Š  â”Š 7â”Š    this.circle.delete();\n-+â”Š  â”Š 8â”Š  });\n-+â”Š  â”Š 9â”Š\n- â”Š 6â”Š10â”Š  describe(\"getX method\", function() {\n- â”Š 7â”Š11â”Š    describe(\"given inranged rad\", function() {\n- â”Š 8â”Š12â”Š      it(\"returns x\", function() {\n-```\n-```diff\n-@@ -64,6 +68,8 @@\n- â”Š64â”Š68â”Š          { x: -2, y: -3 },\n- â”Š65â”Š69â”Š          { x: -2, y: 5 }\n- â”Š66â”Š70â”Š        ]);\n-+â”Š  â”Š71â”Š\n-+â”Š  â”Š72â”Š        circle.delete();\n- â”Š67â”Š73â”Š      });\n- â”Š68â”Š74â”Š    });\n- â”Š69â”Š75â”Š\n-```\n-```diff\n-@@ -74,6 +80,8 @@\n- â”Š74â”Š80â”Š        expect(this.circle.getCircleIntersection(circle)).toEqual([\n- â”Š75â”Š81â”Š          { x: -2, y: 5 }\n- â”Š76â”Š82â”Š        ]);\n-+â”Š  â”Š83â”Š\n-+â”Š  â”Š84â”Š        circle.delete();\n- â”Š77â”Š85â”Š      });\n- â”Š78â”Š86â”Š    });\n- â”Š79â”Š87â”Š\n-```\n-```diff\n-@@ -84,6 +92,8 @@\n- â”Š84â”Š92â”Š        expect(this.circle.getCircleIntersection(circle)).toEqual([\n- â”Š85â”Š93â”Š          { x: -4, y: 1 }\n- â”Š86â”Š94â”Š        ]);\n-+â”Š  â”Š95â”Š\n-+â”Š  â”Š96â”Š        circle.delete();\n- â”Š87â”Š97â”Š      });\n- â”Š88â”Š98â”Š    });\n- â”Š89â”Š99â”Š\n-```\n-```diff\n-@@ -91,6 +101,7 @@\n- â”Š 91â”Š101â”Š      it(\"returns nothing\", function() {\n- â”Š 92â”Š102â”Š        let circle = new Engine.Geometry.Circle(10, 10, 2, 0, 2 * Math.PI);\n- â”Š 93â”Š103â”Š        expect(this.circle.getCircleIntersection(circle)).toBeUndefined();\n-+â”Š   â”Š104â”Š        circle.delete();\n- â”Š 94â”Š105â”Š      });\n- â”Š 95â”Š106â”Š    });\n- â”Š 96â”Š107â”Š\n-```\n-```diff\n-@@ -98,6 +109,7 @@\n- â”Š 98â”Š109â”Š      it(\"nothing\", function() {\n- â”Š 99â”Š110â”Š        let circle = new Engine.Geometry.Circle(1, 1, 2, 0, 2 * Math.PI);\n- â”Š100â”Š111â”Š        expect(this.circle.getCircleIntersection(circle)).toBeUndefined();\n-+â”Š   â”Š112â”Š        circle.delete();\n- â”Š101â”Š113â”Š      });\n- â”Š102â”Š114â”Š    });\n- â”Š103â”Š115â”Š  });\n-```\n-\n-##### Changed resources/scripts/specs/engine/geometry/polygon.js\n-```diff\n-@@ -64,6 +64,8 @@\n- â”Š64â”Š64â”Š          { x: 2, y: 0 },\n- â”Š65â”Š65â”Š          { x: 0, y: 2 }\n- â”Š66â”Š66â”Š        ]);\n-+â”Š  â”Š67â”Š\n-+â”Š  â”Š68â”Š        circle.delete();\n- â”Š67â”Š69â”Š      });\n- â”Š68â”Š70â”Š    });\n- â”Š69â”Š71â”Š\n-```\n-```diff\n-@@ -74,6 +76,8 @@\n- â”Š74â”Š76â”Š        expect(this.polygon.getCircleIntersection(circle)).toEqual([\n- â”Š75â”Š77â”Š          { x: 2, y: 0 }\n- â”Š76â”Š78â”Š        ]);\n-+â”Š  â”Š79â”Š\n-+â”Š  â”Š80â”Š        circle.delete();\n- â”Š77â”Š81â”Š      });\n- â”Š78â”Š82â”Š    });\n- â”Š79â”Š83â”Š\n-```\n-```diff\n-@@ -84,6 +88,8 @@\n- â”Š84â”Š88â”Š        expect(this.polygon.getCircleIntersection(circle)).toEqual([\n- â”Š85â”Š89â”Š          { x: 0, y: 3 }\n- â”Š86â”Š90â”Š        ]);\n-+â”Š  â”Š91â”Š\n-+â”Š  â”Š92â”Š        circle.delete();\n- â”Š87â”Š93â”Š      });\n- â”Š88â”Š94â”Š    });\n- â”Š89â”Š95â”Š\n-```\n-```diff\n-@@ -91,6 +97,7 @@\n- â”Š 91â”Š 97â”Š      it(\"returns nothing\", function() {\n- â”Š 92â”Š 98â”Š        let circle = new Engine.Geometry.Circle(10, 10, 2, 0, 2 * Math.PI);\n- â”Š 93â”Š 99â”Š        expect(this.polygon.getCircleIntersection(circle)).toBeUndefined();\n-+â”Š   â”Š100â”Š        circle.delete();\n- â”Š 94â”Š101â”Š      });\n- â”Š 95â”Š102â”Š    });\n- â”Š 96â”Š103â”Š\n-```\n-```diff\n-@@ -98,6 +105,7 @@\n- â”Š 98â”Š105â”Š      it(\"nothing\", function() {\n- â”Š 99â”Š106â”Š        let circle = new Engine.Geometry.Circle(2.5, 2.5, 2, 0, 2 * Math.PI);\n- â”Š100â”Š107â”Š        expect(this.polygon.getCircleIntersection(circle)).toBeUndefined();\n-+â”Š   â”Š108â”Š        circle.delete();\n- â”Š101â”Š109â”Š      });\n- â”Š102â”Š110â”Š    });\n- â”Š103â”Š111â”Š  });\n-```\n-[}]: #\n-\n-Our C++ code should be finished now, and all the tests should be passing. The only thing left to do would be applying it to our game. Like any other application, we first need to reference the script file so it can be loaded, in this case, the C++ bundle script:\n-\n-[{]: <helper> (diff_step 7.24)\n-#### Step 7.24: Load CPP bundle in game\n-\n-##### Changed views/game.html\n-```diff\n-@@ -8,6 +8,7 @@\n- â”Š 8â”Š 8â”Š    <script type=\"text/javascript\" src=\"/libs/underscore.js\"></script>\n- â”Š 9â”Š 9â”Š\n- â”Š10â”Š10â”Š    <!-- Scripts -->\n-+â”Š  â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/cpp.bundle.js\"></script>\n- â”Š11â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/utils.js\"></script>\n- â”Š12â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n- â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/geometry/line.js\"></script>\n-```\n-[}]: #\n-\n-And now we need to make sure to dispose the geometry shapes correctly so we won't experience any unnecessary memory leaks. Most of our disposals should go to the snake entity, since it's made out of shapes; So we will add a `delete` method to the snake entity and we will dispose it whenever a match is finished:\n-\n-[{]: <helper> (diff_step 7.25)\n-#### Step 7.25: Delete shape instances in game\n-\n-##### Changed resources/scripts/engine/game.js\n-```diff\n-@@ -95,6 +95,7 @@\n- â”Š 95â”Š 95â”Š  changeScreen(Screen, ...screenArgs) {\n- â”Š 96â”Š 96â”Š    // If there is a screen defined, dispose it first\n- â”Š 97â”Š 97â”Š    if (this.screen) {\n-+â”Š   â”Š 98â”Š      this.screen.delete();\n- â”Š 98â”Š 99â”Š      this.unloadScreen();\n- â”Š 99â”Š100â”Š      this.screen.disposeEventListeners();\n- â”Š100â”Š101â”Š    }\n-```\n-\n-##### Changed resources/scripts/engine/layer.js\n-```diff\n-@@ -23,6 +23,9 @@\n- â”Š23â”Š23â”Š    this.canvas = screen.game.canvas;\n- â”Š24â”Š24â”Š  }\n- â”Š25â”Š25â”Š\n-+â”Š  â”Š26â”Š  delete() {\n-+â”Š  â”Š27â”Š  }\n-+â”Š  â”Š28â”Š\n- â”Š26â”Š29â”Š  update(span) {\n- â”Š27â”Š30â”Š  }\n- â”Š28â”Š31â”Š\n-```\n-\n-##### Changed resources/scripts/engine/screen.js\n-```diff\n-@@ -28,6 +28,13 @@\n- â”Š28â”Š28â”Š    return this;\n- â”Š29â”Š29â”Š  }\n- â”Š30â”Š30â”Š\n-+â”Š  â”Š31â”Š   // Delete all layers. Same as 'unload', only it disposes memory rather than assets\n-+â”Š  â”Š32â”Š  delete() {\n-+â”Š  â”Š33â”Š    this.layers.forEach(layer => {\n-+â”Š  â”Š34â”Š      layer.delete();\n-+â”Š  â”Š35â”Š    });\n-+â”Š  â”Š36â”Š  }\n-+â”Š  â”Š37â”Š\n- â”Š31â”Š38â”Š  // Updates each layer\n- â”Š32â”Š39â”Š  update(span) {\n- â”Š33â”Š40â”Š    this.layers.forEach(layer => {\n-```\n-```diff\n-@@ -61,6 +68,7 @@\n- â”Š61â”Š68â”Š  removeLayer(layer) {\n- â”Š62â”Š69â”Š    this.layers = _.without(this.layers, layer);\n- â”Š63â”Š70â”Š    layer.disposeEventListeners();\n-+â”Š  â”Š71â”Š    layer.delete();\n- â”Š64â”Š72â”Š  }\n- â”Š65â”Š73â”Š\n- â”Š66â”Š74â”Š  initEventListeners() {\n-```\n-\n-##### Changed resources/scripts/game/entities/snake.js\n-```diff\n-@@ -31,6 +31,10 @@\n- â”Š31â”Š31â”Š    }\n- â”Š32â”Š32â”Š  }\n- â”Š33â”Š33â”Š\n-+â”Š  â”Š34â”Š  delete() {\n-+â”Š  â”Š35â”Š    this.shapes.forEach(shape => shape.delete());\n-+â”Š  â”Š36â”Š  }\n-+â”Š  â”Š37â”Š\n- â”Š34â”Š38â”Š  draw(context) {\n- â”Š35â”Š39â”Š    // Draw all shapes in the shapes array\n- â”Š36â”Š40â”Š    this.shapes.forEach(shape => {\n-```\n-```diff\n-@@ -229,6 +233,8 @@\n- â”Š229â”Š233â”Š      [0, height, 0, 0]\n- â”Š230â”Š234â”Š    );\n- â”Š231â”Š235â”Š\n--â”Š232â”Š   â”Š    return canvasPolygon.getIntersection(this.lastBit);\n-+â”Š   â”Š236â”Š    let result = canvasPolygon.getIntersection(this.lastBit);\n-+â”Š   â”Š237â”Š    canvasPolygon.delete();\n-+â”Š   â”Š238â”Š    return result;\n- â”Š233â”Š239â”Š  }\n- â”Š234â”Š240â”Š};ðŸš«â†µ\n-```\n-\n-##### Changed resources/scripts/game/screens/play/snake.js\n-```diff\n-@@ -43,6 +43,10 @@\n- â”Š43â”Š43â”Š    screen.appendLayer(Game.Screens.Play.Score, this.snakes);\n- â”Š44â”Š44â”Š  }\n- â”Š45â”Š45â”Š\n-+â”Š  â”Š46â”Š  unload() {\n-+â”Š  â”Š47â”Š    this.snakes.forEach(snake => snake.delete());\n-+â”Š  â”Š48â”Š  }\n-+â”Š  â”Š49â”Š\n- â”Š46â”Š50â”Š  draw(context) {\n- â”Š47â”Š51â”Š    // Draw each snake in the snakes array\n- â”Š48â”Š52â”Š    this.snakes.forEach(snake => snake.draw(context));\n-```\n-[}]: #\n-\n-Congratulations! You've created a C++ cross JavaScript game. There shouldn't be any significant difference between the C++ version of the game and the JavaScript version on most machines, since the game is very small and barely requires any processing power. You'll probably notice the difference when starting to extend the game by adding terrains or more snakes.\n-\n-One might ask - \"How much faster does my game actually run?\". The short answer is - around 50%. Why did I run into this conclusion? Well, take a look at the following JavaScript code snippet, for calculating Fibonacci of 42:\n-\n-```js\n-function fib(x) {\n-  if (x < 2) {\n-    return 1;\n-  }\n-  else {\n-    return fib(x - 1) + fib(x - 2);\n-  }\n-}\n-```\n-\n-The same code snippet should look almost identical written in C++:\n-\n-```cpp\n-int fib(int x) {\n-  if (x < 2) {\n-    return 1;\n-  }\n-  else {\n-    return fib(x - 1) + fib(x - 2);\n-  }\n-}\n-```\n-\n-However, the run-times are completely different! I compared the average of 10 runs in 3 different environments, and I received the following results:\n-\n-![chart](https://cloud.githubusercontent.com/assets/7648874/22802494/2591025e-eef8-11e6-9679-10b5bca0ef30.png)\n-\n-As you can see, the generated C++ is much faster, and to be precise, 57% faster! Surprisingly, I didn't have any significant difference between Emscripten generated C++ and natively compiled executable.\n-\n-C++ is more complex to write, but it certainly has its advantages over JavaScript. Remember, now that you know that you have the possibility to run C++ in the browser, make sure to use it, but never overdo it, always find the right balance between readability and performance.\n-\n-> *Sources:*\n-> - *https://kripken.github.io/emscripten-site/docs/introducing_emscripten/index.html*\n-> - *http://www.crunchy.com/?q=content/emscripten-perfectly-cromulent-compiler*\n-> - *http://stackoverflow.com/questions/2354725/what-exactly-is-llvm*\n-\n-[}]: #\n-[{]: <region> (footer)\n-[{]: <helper> (nav_step)\n-| [< Previous Step](step6.md) | [Next Step >](step8.md) |\n-|:--------------------------------|--------------------------------:|\n-[}]: #\n-[}]: #\n\\ No newline at end of file\ndiff --git a/manuals/views/step8.md b/manuals/views/step8.md\ndeleted file mode 100644\nindex bc8bfaf..0000000\n--- a/manuals/views/step8.md\n+++ /dev/null\n@@ -1,25 +0,0 @@\n-[{]: <region> (header)\n-# Step 8: What's next?\n-[}]: #\n-[{]: <region> (body)\n-That was it y'all, hopefully you like this tutorial. Definitely a refresher when you have all these high-level frameworks out there.\n-\n-Check out my previous tutorial on how to write a native add-on to `NodeJS` using `C++`: https://github.com/DAB0mB/node-distance-addon\n-\n-Be sure to â˜…*â˜…***â˜…STARâ˜…***â˜…*â˜… this repository: https://github.com/DAB0mB/radial-snake.\n-\n-If you have any suggestions, issues, and things you'd like to ask, be sure to open an issue in the issues section: https://github.com/DAB0mB/radial-snake/issues\n-\n-For more awesome tutorials and upcoming projects, please follow me on:\n-\n-- **Github** - https://github.com/DAB0mB\n-- **Twitter** - https://twitter.com/eytan_manor\n-\n-Stay frosty 'til next time. Peace â˜®.\n-[}]: #\n-[{]: <region> (footer)\n-[{]: <helper> (nav_step)\n-| [< Previous Step](step7.md) |\n-|:----------------------|\n-[}]: #\n-[}]: #\n\\ No newline at end of file\n",
        "manuals": [
          {
            "manualTitle": "How to implement a game engine in JavaScript and build a Tron-style game",
            "stepRevision": "08b88f5a9d7b2d3ba4c8a67a1433218ef6a6a3a5",
            "manualView": "![snake-demo-full-small](https://cloud.githubusercontent.com/assets/7648874/21073892/ae331a8a-bed2-11e6-9141-9554f9bb808b.gif)\n\nThis tutorial will guide you through the following steps:\n\n- [**Step 1**](https://github.com/DAB0mB/radial-snake/blob/master/.tortilla/manuals/views/step1.md) - Creating a server\n- [**Step 2**](https://github.com/DAB0mB/radial-snake/blob/master/.tortilla/manuals/views/step2.md) - Creating a game engine basis\n- [**Step 3**](https://github.com/DAB0mB/radial-snake/blob/master/.tortilla/manuals/views/step3.md) - Creating a splash screen using a keyframe animation engine\n- [**Step 4**](https://github.com/DAB0mB/radial-snake/blob/master/.tortilla/manuals/views/step4.md) - Creating a main menu screen using a font engine\n- [**Step 5**](https://github.com/DAB0mB/radial-snake/blob/master/.tortilla/manuals/views/step5.md) - Creating a snake and related geometry shapes\n- [**Step 6**](https://github.com/DAB0mB/radial-snake/blob/master/.tortilla/manuals/views/step6.md) - Creating a complex game screen with multiple layers\n- [**Step 7**](https://github.com/DAB0mB/radial-snake/blob/master/.tortilla/manuals/views/step7.md) - Bonus! Re-implementing geometry in C++\n\nMake sure you have the following software installed:\n\n- NodeJS with an ECMAScript 2015 support (v6.0.0 and above).\n- Any web-browser which supports ECMAScript 2015, with a preference for Google Chrome.\n\n> The final project is a hybrid of C++ and JavaScript. A JavaScript **only** version of this tutorial is available [here](https://github.com/DAB0mB/radial-snake/tree/master%40step6%400.1.3).\n\nThis tutorial is mostly based on pure JavaScript, so people can have a deeper understanding of the language and its dynamics. In addition, this tutorial makes a great practice on how to build a nice architecture for complex systems, which can then be expanded and maintained with ease. Yes, it is specifically designed for games, but I truly believe that video games can easily get messed up if not planned and designed properly in terms of object oriented relationships. They are naturally more complicated then any web-app you gonna see out there, so if you can create a game engine and understand its flow, creating a web-app would be a piece of cake for you. By the end of this tutorial, your general sense for programming should be enhanced greatly.\n\nSo hopefully that I got you pumped up by now, let's get started!"
          },
          {
            "manualTitle": "Step 1: Creating a server",
            "stepRevision": "1aed2194c509617dbe79447e2615aa34728262bc",
            "manualView": "The first thing we will learn to do would be creating a server so we can serve our assets. We will be using [HapiJS](https://hapijs.com/) to build a REST API, although this step can be implemented with any library you'd want, like [ExpressJS](http://expressjs.com/) or [Connect](https://www.senchalabs.github.com/connect) etc. Let's install it then:\n\n    $ npm install hapi --save\n\nWe will start by setting up a basis for our server, and we will expand it as we go further in this step. A general boiler plate should look like so:\n\n[{]: <helper> (diffStep 1.2)\n\n#### [Step 1.2: Add server basis](https://github.com/DAB0mB/radial-snake/commit/8ff8805)\n\n##### Added server.js\n```diff\n@@ -0,0 +1,36 @@\n+â”Š  â”Š 1â”Šconst Hapi = require(\"hapi\");\n+â”Š  â”Š 2â”Š\n+â”Š  â”Š 3â”Šlet port = 8000;\n+â”Š  â”Š 4â”Š\n+â”Š  â”Š 5â”Š// Initialize a new server\n+â”Š  â”Š 6â”Šlet server = new Hapi.Server();\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Šserver.connection({ port: process.env.PORT || port });\n+â”Š  â”Š 9â”Š\n+â”Š  â”Š10â”Š// Report each response made\n+â”Š  â”Š11â”Šserver.ext(\"onPreResponse\", (req, rep) => {\n+â”Š  â”Š12â”Š  let res = req.response;\n+â”Š  â”Š13â”Š\n+â”Š  â”Š14â”Š  console.log(\"Outcoming response:\");\n+â”Š  â”Š15â”Š  console.log(`in: ${new Date}`);\n+â”Š  â”Š16â”Š  console.log(`to: ${req.info.remoteAddress}`);\n+â”Š  â”Š17â”Š  console.log(`method: ${req.method}`);\n+â”Š  â”Š18â”Š  console.log(`url: ${req.url.path}`);\n+â”Š  â”Š19â”Š  console.log(`status: ${res.statusCode || res.output.statusCode}`);\n+â”Š  â”Š20â”Š  console.log();\n+â”Š  â”Š21â”Š\n+â”Š  â”Š22â”Š  rep.continue();\n+â”Š  â”Š23â”Š});\n+â”Š  â”Š24â”Š\n+â”Š  â”Š25â”Š// Print message once started\n+â”Š  â”Š26â”Šserver.start((err) => {\n+â”Š  â”Š27â”Š  if (err) throw err;\n+â”Š  â”Š28â”Š\n+â”Š  â”Š29â”Š  console.log();\n+â”Š  â”Š30â”Š  console.log(\"---------- -------- ------ ---- --\");\n+â”Š  â”Š31â”Š  console.log(\"----- ---- --- -- -\");\n+â”Š  â”Š32â”Š  console.log(`Server running at ${port}`);\n+â”Š  â”Š33â”Š  console.log(\"----- ---- --- -- -\");\n+â”Š  â”Š34â”Š  console.log(\"---------- -------- ------ ---- --\");\n+â”Š  â”Š35â”Š  console.log();\n+â”Š  â”Š36â”Š});ðŸš«â†µ\n```\n\n[}]: #\n\nWe simply initialize a new server which will connect to port `8000` by default, unless we defined an environment variable called `PORT`. Once the server is started, and whenever there is an outcoming response, a message will be printed to the console.\n\n> More information and configuration options regards HapiJS's API can be found in this [here](https://hapijs.com/).\n\nNow that the basis is ready, we want a convenient way to launch it. Repetitive scripts are usually defined in the `package.json` file under the `scripts` field. To start the server, we gonna create a simple script called `serve`:\n\n[{]: <helper> (diffStep 1.3)\n\n#### [Step 1.3: Add serve npm script](https://github.com/DAB0mB/radial-snake/commit/6e7d691)\n\n##### Changed package.json\n```diff\n@@ -6,6 +6,9 @@\n â”Š 6â”Š 6â”Š    \"url\": \"https://DAB0mB@github.com/DAB0mB/radial-snake.git\"\n â”Š 7â”Š 7â”Š  },\n â”Š 8â”Š 8â”Š  \"private\": true,\n+â”Š  â”Š 9â”Š  \"scripts\": {\n+â”Š  â”Š10â”Š    \"serve\": \"node server.js\"\n+â”Š  â”Š11â”Š  },\n â”Š 9â”Š12â”Š  \"dependencies\": {\n â”Š10â”Š13â”Š    \"hapi\": \"^16.0.1\"\n â”Š11â”Š14â”Š  }\n```\n\n[}]: #\n\nTo run this script, we will simply need to type the following:\n\n    $ npm run serve\n\nThis will run our server, and you should see the following message printed to the console:\n\n```\n---------- -------- ------ ---- --\n----- ---- --- -- -\nServer running at 8000\n----- ---- --- -- -\n---------- -------- ------ ---- --\n```\n\n> As for now, nothing happens, because we didn't define any handlers for HTTP requests. I will get to it in a bit, stay with me.\n\nThe main disadvantage of starting a server directly with node is that we have no listeners for changes in our files, so if we want the served files to be updated, we will have to restart our server anytime we make a change. To avoid that, we gonna use [nodemon](https://nodemon.io/), which is a simple utility that can monitor changes is source files and automatically restart our server. To install it, type the following:\n\n    $ sudo npm install nodemon -g\n\nNow that we have it, we will need to update our `serve` npm script to use `nodemon` instead of `node`:\n\n[{]: <helper> (diffStep 1.4)\n\n#### [Step 1.4: Change serve npm script to use nodemon](https://github.com/DAB0mB/radial-snake/commit/a238294)\n\n##### Changed package.json\n```diff\n@@ -7,7 +7,7 @@\n â”Š 7â”Š 7â”Š  },\n â”Š 8â”Š 8â”Š  \"private\": true,\n â”Š 9â”Š 9â”Š  \"scripts\": {\n-â”Š10â”Š  â”Š    \"serve\": \"node server.js\"\n+â”Š  â”Š10â”Š    \"serve\": \"nodemon server.js\"\n â”Š11â”Š11â”Š  },\n â”Š12â”Š12â”Š  \"dependencies\": {\n â”Š13â”Š13â”Š    \"hapi\": \"^16.0.1\"\n```\n\n[}]: #\n\nThe basis for our server is pretty much complete. From now on we gonna build stuff on top of it and extend our server. I'd like to add a small attachment to our server. I want that the IP address of the current computer will be printed to the console once the server is started. For this, we first gonna create a helper which we gonna call `ip_grabber`:\n\n[{]: <helper> (diffStep 1.5)\n\n#### [Step 1.5: Add ip_grabber helper](https://github.com/DAB0mB/radial-snake/commit/8ff1d1c)\n\n##### Added helpers&#x2F;ip_grabber.js\n```diff\n@@ -0,0 +1,23 @@\n+â”Š  â”Š 1â”Šconst Os = require(\"os\");\n+â”Š  â”Š 2â”Š\n+â”Š  â”Š 3â”Š// Grab local IP address of which the NodeJS process runs on\n+â”Š  â”Š 4â”Šfunction local() {\n+â”Š  â”Š 5â”Š  let interfaces = Os.networkInterfaces();\n+â”Š  â”Š 6â”Š  let addresses = [];\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Š  for (let k in interfaces) {\n+â”Š  â”Š 9â”Š    for (let k2 in interfaces[k]) {\n+â”Š  â”Š10â”Š      let address = interfaces[k][k2];\n+â”Š  â”Š11â”Š\n+â”Š  â”Š12â”Š      if (address.family == \"IPv4\" && !address.internal) {\n+â”Š  â”Š13â”Š        addresses.push(address.address);\n+â”Š  â”Š14â”Š      }\n+â”Š  â”Š15â”Š    }\n+â”Š  â”Š16â”Š  }\n+â”Š  â”Š17â”Š\n+â”Š  â”Š18â”Š  return addresses[0];\n+â”Š  â”Š19â”Š}\n+â”Š  â”Š20â”Š\n+â”Š  â”Š21â”Šmodule.exports = {\n+â”Š  â”Š22â”Š  local\n+â”Š  â”Š23â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nThis module simply goes through the available network interfaces and grabs the IP address of the default gateway using the `os` module. Now that we have it, let's import it in the server's entry file and use the `local` method to grab the IP address and report it once the server is started:\n\n[{]: <helper> (diffStep 1.6)\n\n#### [Step 1.6: Print IP address once server is started](https://github.com/DAB0mB/radial-snake/commit/18ed984)\n\n##### Changed server.js\n```diff\n@@ -1,5 +1,7 @@\n â”Š1â”Š1â”Šconst Hapi = require(\"hapi\");\n+â”Š â”Š2â”Šconst IpGrabber = require(\"./helpers/ip_grabber\");\n â”Š2â”Š3â”Š\n+â”Š â”Š4â”Šlet localIp = IpGrabber.local();\n â”Š3â”Š5â”Šlet port = 8000;\n â”Š4â”Š6â”Š\n â”Š5â”Š7â”Š// Initialize a new server\n```\n```diff\n@@ -29,7 +31,7 @@\n â”Š29â”Š31â”Š  console.log();\n â”Š30â”Š32â”Š  console.log(\"---------- -------- ------ ---- --\");\n â”Š31â”Š33â”Š  console.log(\"----- ---- --- -- -\");\n-â”Š32â”Š  â”Š  console.log(`Server running at ${port}`);\n+â”Š  â”Š34â”Š  console.log(`Server running at ${localIp}:${port}`);\n â”Š33â”Š35â”Š  console.log(\"----- ---- --- -- -\");\n â”Š34â”Š36â”Š  console.log(\"---------- -------- ------ ---- --\");\n â”Š35â”Š37â”Š  console.log();\n```\n\n[}]: #\n\nBy now you should have the following message printed to the console once you start the server:\n\n```\n---------- -------- ------ ---- --\n----- ---- --- -- -\nServer running at 95.221.122.30:8000\n----- ---- --- -- -\n---------- -------- ------ ---- --\n```\n\n> Instead of `95.221.122.30` you should have the IP address which is right for you.\n\nNow comes the most important part - handling HTTP requests! Because what does a server worth if it doesn't know how to handle anything? When using `HapiJS`, we can separate extensions to our server in different modules, and eventually register them as plug-ins. So the first plug-in is gonna be the routes batch for the endpoints - it will take care of serving file requests as is, and basically turning local directories into public ones. This is useful because our game is going to be dependent on many assets like textures, images, fonts, and so on... But before I go into the implementation part we first need to install a couple of libraries which will help us with the task. The first one is going to be `async`, which will take care of managing the control flow of asynchronous code:\n\n    $ npm install async --save\n\nAnd the second library is going to be `inert`, which is a `HapiJS` plug-in which will give us the ability to serve files from local directories:\n\n    $ npm install inert --save\n\nNow that we're set, let's implement the `endpoints` routes batch:\n\n[{]: <helper> (diffStep 1.8)\n\n#### [Step 1.8: Add endpoints routes](https://github.com/DAB0mB/radial-snake/commit/9c22408)\n\n##### Added routes&#x2F;endpoints.js\n```diff\n@@ -0,0 +1,80 @@\n+â”Š  â”Š 1â”Šconst Pack = require(\"../package.json\");\n+â”Š  â”Š 2â”Š\n+â”Š  â”Š 3â”Šregister.attributes = {\n+â”Š  â”Š 4â”Š  name: \"endpoints\",\n+â”Š  â”Š 5â”Š  version: Pack.version\n+â”Š  â”Š 6â”Š};\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Šfunction register(server, options, next) {\n+â”Š  â”Š 9â”Š  // Scripts endpoint\n+â”Š  â”Š10â”Š  server.route({\n+â”Š  â”Š11â”Š    method: \"GET\",\n+â”Š  â”Š12â”Š    path: \"/scripts/{path*}\",\n+â”Š  â”Š13â”Š    handler: {\n+â”Š  â”Š14â”Š      directory: {\n+â”Š  â”Š15â”Š        path: \"./resources/scripts/\"\n+â”Š  â”Š16â”Š      }\n+â”Š  â”Š17â”Š    }\n+â”Š  â”Š18â”Š  });\n+â”Š  â”Š19â”Š\n+â”Š  â”Š20â”Š  // Style-sheets endpoint\n+â”Š  â”Š21â”Š  server.route({\n+â”Š  â”Š22â”Š    method: \"GET\",\n+â”Š  â”Š23â”Š    path: \"/styles/{path*}\",\n+â”Š  â”Š24â”Š    handler: {\n+â”Š  â”Š25â”Š      directory: {\n+â”Š  â”Š26â”Š        path: \"./resources/styles/\"\n+â”Š  â”Š27â”Š      }\n+â”Š  â”Š28â”Š    }\n+â”Š  â”Š29â”Š  });\n+â”Š  â”Š30â”Š\n+â”Š  â”Š31â”Š  // Libraries endpoint\n+â”Š  â”Š32â”Š  server.route({\n+â”Š  â”Š33â”Š    method: \"GET\",\n+â”Š  â”Š34â”Š    path: \"/libs/{path*}\",\n+â”Š  â”Š35â”Š    handler: {\n+â”Š  â”Š36â”Š      directory: {\n+â”Š  â”Š37â”Š        path: \"./resources/libs/\"\n+â”Š  â”Š38â”Š      }\n+â”Š  â”Š39â”Š    }\n+â”Š  â”Š40â”Š  });\n+â”Š  â”Š41â”Š\n+â”Š  â”Š42â”Š  // Images endpoint\n+â”Š  â”Š43â”Š  server.route({\n+â”Š  â”Š44â”Š    method: \"GET\",\n+â”Š  â”Š45â”Š    path: \"/images/{path*}\",\n+â”Š  â”Š46â”Š    handler: {\n+â”Š  â”Š47â”Š      directory: {\n+â”Š  â”Š48â”Š        path: \"./resources/images/\"\n+â”Š  â”Š49â”Š      }\n+â”Š  â”Š50â”Š    }\n+â”Š  â”Š51â”Š  });\n+â”Š  â”Š52â”Š\n+â”Š  â”Š53â”Š  // Textures endpoint\n+â”Š  â”Š54â”Š  server.route({\n+â”Š  â”Š55â”Š    method: \"GET\",\n+â”Š  â”Š56â”Š    path: \"/textures/{path*}\",\n+â”Š  â”Š57â”Š    handler: {\n+â”Š  â”Š58â”Š      directory: {\n+â”Š  â”Š59â”Š        path: \"./resources/assets/textures/\"\n+â”Š  â”Š60â”Š      }\n+â”Š  â”Š61â”Š    }\n+â”Š  â”Š62â”Š  });\n+â”Š  â”Š63â”Š\n+â”Š  â”Š64â”Š  // Fonts endpoint\n+â”Š  â”Š65â”Š  server.route({\n+â”Š  â”Š66â”Š    method: \"GET\",\n+â”Š  â”Š67â”Š    path: \"/fonts/{path*}\",\n+â”Š  â”Š68â”Š    handler: {\n+â”Š  â”Š69â”Š      directory: {\n+â”Š  â”Š70â”Š        path: \"./resources/assets/fonts/\"\n+â”Š  â”Š71â”Š      }\n+â”Š  â”Š72â”Š    }\n+â”Š  â”Š73â”Š  });\n+â”Š  â”Š74â”Š\n+â”Š  â”Š75â”Š  next();\n+â”Š  â”Š76â”Š}\n+â”Š  â”Š77â”Š\n+â”Š  â”Š78â”Šmodule.exports = {\n+â”Š  â”Š79â”Š  register\n+â”Š  â”Š80â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nThis module actually represents a classic structure of a `HapiJS` plug-in. It should export a `name` for debugging proposes, a `version`, and a `register` function, which will take care of registering extensions to our server; in this case, these are the endpoints routes. To make this plug-in (Or any other plug-in) work, we need to register it. The registration is an asynchronous operation, thus we gonna handle it using `async`:\n\n[{]: <helper> (diffStep 1.9)\n\n#### [Step 1.9: Register ednpoints routes](https://github.com/DAB0mB/radial-snake/commit/bba460f)\n\n##### Changed server.js\n```diff\n@@ -1,11 +1,23 @@\n+â”Š  â”Š 1â”Šconst Async = require(\"async\");\n â”Š 1â”Š 2â”Šconst Hapi = require(\"hapi\");\n+â”Š  â”Š 3â”Šconst Inert = require(\"inert\");\n+â”Š  â”Š 4â”Šconst Endpoints = require(\"./routes/endpoints\");\n â”Š 2â”Š 5â”Šconst IpGrabber = require(\"./helpers/ip_grabber\");\n â”Š 3â”Š 6â”Š\n â”Š 4â”Š 7â”Šlet localIp = IpGrabber.local();\n â”Š 5â”Š 8â”Šlet port = 8000;\n â”Š 6â”Š 9â”Š\n â”Š 7â”Š10â”Š// Initialize a new server\n-â”Š 8â”Š  â”Šlet server = new Hapi.Server();\n+â”Š  â”Š11â”Šlet server = new Hapi.Server({\n+â”Š  â”Š12â”Š  connections: {\n+â”Š  â”Š13â”Š    routes: {\n+â”Š  â”Š14â”Š      files: {\n+â”Š  â”Š15â”Š        // Served files will be relative to current directory\n+â”Š  â”Š16â”Š        relativeTo: __dirname\n+â”Š  â”Š17â”Š      }\n+â”Š  â”Š18â”Š    }\n+â”Š  â”Š19â”Š  }\n+â”Š  â”Š20â”Š});\n â”Š 9â”Š21â”Š\n â”Š10â”Š22â”Šserver.connection({ port: process.env.PORT || port });\n â”Š11â”Š23â”Š\n```\n```diff\n@@ -24,8 +36,14 @@\n â”Š24â”Š36â”Š  rep.continue();\n â”Š25â”Š37â”Š});\n â”Š26â”Š38â”Š\n+â”Š  â”Š39â”Š// Register all routes and plug-ins\n+â”Š  â”Š40â”ŠAsync.series([\n+â”Š  â”Š41â”Š  next => server.register(Inert, next),\n+â”Š  â”Š42â”Š  next => server.register(Endpoints, next),\n+â”Š  â”Š43â”Š  // Once registrations are finished, start the server\n+â”Š  â”Š44â”Š  next => server.start(next)\n â”Š27â”Š45â”Š// Print message once started\n-â”Š28â”Š  â”Šserver.start((err) => {\n+â”Š  â”Š46â”Š], (err) => {\n â”Š29â”Š47â”Š  if (err) throw err;\n â”Š30â”Š48â”Š\n â”Š31â”Š49â”Š  console.log();\n```\n\n[}]: #\n\nOnce all the plug-ins have been registered, we gonna start our server as we previously did. Note that we also registered the `inert` plug-in, because as I said earlier, that's what gives us the ability to handle files requests.\n\nLastly, I want to create the `pages` routes batch, which will be responsible for serving pages in our application as listed above:\n\n- The `/` route will serve us the `game.html` file.\n- The `/test` route will serve us the `spec_runner.html` file.\n\nBy the name of each route and file you can probably what each one should do. The thing is, we don't want everyone to be able to access the `spec_runner.html` file, or the `game.html` file if in the middle of development. For this, we're going to create a new helper which will be responsible for handling permissions. So first we gonna install an npm package called `boom` which has the ability to format `permission denied` HTTP errors:\n\n    $ npm install boom --save\n\nAnd now we gonna implement the module itself:\n\n[{]: <helper> (diffStep 1.11)\n\n#### [Step 1.11: Add permitter helper](https://github.com/DAB0mB/radial-snake/commit/d26a5d7)\n\n##### Added helpers&#x2F;permitter.js\n```diff\n@@ -0,0 +1,29 @@\n+â”Š  â”Š 1â”Šconst Boom = require(\"boom\");\n+â”Š  â”Š 2â”Šconst Hapi = require(\"hapi\");\n+â”Š  â”Š 3â”Šconst IpGrabber = require(\"./ip_grabber\");\n+â”Š  â”Š 4â”Š\n+â”Š  â”Š 5â”Š// These addresses will be permitted by default\n+â”Š  â”Š 6â”Šconst defaultPermissions = [\n+â”Š  â”Š 7â”Š  IpGrabber.local(), \"127.0.0.1\", \"localhost\"\n+â”Š  â”Š 8â”Š];\n+â”Š  â”Š 9â”Š\n+â”Š  â”Š10â”Š// Manage file permissions\n+â”Š  â”Š11â”Šfunction file(path, permissions, req, rep) {\n+â”Š  â”Š12â”Š  // Apply default permissions\n+â”Š  â”Š13â”Š  permissions = permissions.concat(defaultPermissions);\n+â”Š  â”Š14â”Š  // Request address\n+â”Š  â”Š15â”Š  let remoteAddress = req.info.remoteAddress;\n+â”Š  â”Š16â”Š\n+â”Š  â”Š17â”Š  // If not permitted, reply error\n+â”Š  â”Š18â”Š  if (permissions.indexOf(remoteAddress) == -1) {\n+â”Š  â”Š19â”Š    let err = new Boom.forbidden(\"Missing permissions\");\n+â”Š  â”Š20â”Š    return rep(err);\n+â”Š  â”Š21â”Š  }\n+â”Š  â”Š22â”Š\n+â”Š  â”Š23â”Š  // If permitted, reply file\n+â”Š  â”Š24â”Š  rep.file(path);\n+â”Š  â”Š25â”Š}\n+â”Š  â”Š26â”Š\n+â”Š  â”Š27â”Šmodule.exports = {\n+â”Š  â”Š28â”Š  file\n+â”Š  â”Š29â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nThe default permitted IP address would be the current computer's IP address. Extra IP permissions can be provided with the invocation of the `file` method. If the requesting IP is not listed in the permissions list, an error is gonna be replied instead of the requested file. Now that we have our \"permitter\" ready, let's implement the `pages` routes batch, only we're gonna pass the requests through the black-list, for the reason mentioned above:\n\n[{]: <helper> (diffStep 1.12)\n\n#### [Step 1.12: Add pages routes](https://github.com/DAB0mB/radial-snake/commit/11860e9)\n\n##### Added routes&#x2F;pages.js\n```diff\n@@ -0,0 +1,35 @@\n+â”Š  â”Š 1â”Šconst Hapi = require(\"hapi\");\n+â”Š  â”Š 2â”Šconst Pack = require(\"../package.json\");\n+â”Š  â”Š 3â”Šconst Permitter = require(\"../helpers/permitter\");\n+â”Š  â”Š 4â”Š\n+â”Š  â”Š 5â”Šregister.attributes = {\n+â”Š  â”Š 6â”Š  name: \"pages\",\n+â”Š  â”Š 7â”Š  version: Pack.version\n+â”Š  â”Š 8â”Š};\n+â”Š  â”Š 9â”Š\n+â”Š  â”Š10â”Šfunction register(server, options, next) {\n+â”Š  â”Š11â”Š  server.route({ method: \"GET\", path: \"/\", handler: getGame });\n+â”Š  â”Š12â”Š  server.route({ method: \"GET\", path: \"/test\", handler: getSpecRunner });\n+â”Š  â”Š13â”Š\n+â”Š  â”Š14â”Š  next();\n+â”Š  â”Š15â”Š}\n+â”Š  â”Š16â”Š\n+â”Š  â”Š17â”Š// Serve game page\n+â”Š  â”Š18â”Šfunction getGame(req, rep) {\n+â”Š  â”Š19â”Š  let path = \"./views/game.html\";\n+â”Š  â”Š20â”Š  let permissions = [];\n+â”Š  â”Š21â”Š\n+â”Š  â”Š22â”Š  Permitter.file(path, permissions, req, rep);\n+â”Š  â”Š23â”Š}\n+â”Š  â”Š24â”Š\n+â”Š  â”Š25â”Š// Serve test page\n+â”Š  â”Š26â”Šfunction getSpecRunner(req, rep) {\n+â”Š  â”Š27â”Š  let path = \"./views/spec_runner.html\";\n+â”Š  â”Š28â”Š  let permissions = [];\n+â”Š  â”Š29â”Š\n+â”Š  â”Š30â”Š  Permitter.file(path, permissions, req, rep);\n+â”Š  â”Š31â”Š}\n+â”Š  â”Š32â”Š\n+â”Š  â”Š33â”Šmodule.exports = {\n+â”Š  â”Š34â”Š  register\n+â”Š  â”Š35â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nNow the only thing left to do would be registering the plug-in we've just created:\n\n[{]: <helper> (diffStep 1.13)\n\n#### [Step 1.13: Register pages routes](https://github.com/DAB0mB/radial-snake/commit/ed50bef)\n\n##### Changed server.js\n```diff\n@@ -2,6 +2,7 @@\n â”Š2â”Š2â”Šconst Hapi = require(\"hapi\");\n â”Š3â”Š3â”Šconst Inert = require(\"inert\");\n â”Š4â”Š4â”Šconst Endpoints = require(\"./routes/endpoints\");\n+â”Š â”Š5â”Šconst Pages = require(\"./routes/pages\");\n â”Š5â”Š6â”Šconst IpGrabber = require(\"./helpers/ip_grabber\");\n â”Š6â”Š7â”Š\n â”Š7â”Š8â”Šlet localIp = IpGrabber.local();\n```\n```diff\n@@ -40,6 +41,7 @@\n â”Š40â”Š41â”ŠAsync.series([\n â”Š41â”Š42â”Š  next => server.register(Inert, next),\n â”Š42â”Š43â”Š  next => server.register(Endpoints, next),\n+â”Š  â”Š44â”Š  next => server.register(Pages, next),\n â”Š43â”Š45â”Š  // Once registrations are finished, start the server\n â”Š44â”Š46â”Š  next => server.start(next)\n â”Š45â”Š47â”Š// Print message once started\n```\n\n[}]: #\n\nAnd that's it for the current step! In the next steps we will start storing files and assets in our public directories and implement all the necessary scripts, so our server is not running in vain."
          },
          {
            "manualTitle": "Step 2: Creating a game engine basis",
            "stepRevision": "a3e901039dc5db535111da14305175182f9f346c",
            "manualView": "Like any other JavaScript-based application, we should have an entry view written in HTML. However, in our application, the only visible element is going to be an [HTMLCanvas](https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API). The canvas is exactly what it sounds like - a blank white surface which we can draw things on top of it. As we go further with this tutorial, we will learn more about the canvas and dive into its API and how to use it. Now that you got the general idea, let's create the HTML file:\n\n[{]: <helper> (diffStep 2.1)\n\n#### [Step 2.1: Create basic game view](https://github.com/DAB0mB/radial-snake/commit/254f06f)\n\n##### Added views&#x2F;game.html\n```diff\n@@ -0,0 +1,10 @@\n+â”Š  â”Š 1â”Š<!DOCTYPE html>\n+â”Š  â”Š 2â”Š<html>\n+â”Š  â”Š 3â”Š  <head>\n+â”Š  â”Š 4â”Š    <title>radial snake</title>\n+â”Š  â”Š 5â”Š  </head>\n+â”Š  â”Š 6â”Š\n+â”Š  â”Š 7â”Š  <body>\n+â”Š  â”Š 8â”Š    <canvas id=\"gameCanvas\" tabindex=\"0\"></canvas>\n+â”Š  â”Š 9â”Š  </body>\n+â”Š  â”Š10â”Š</html>ðŸš«â†µ\n```\n\n[}]: #\n\nIn the previous step we've already set the route for this file, so if you'd like to run the game, simply start the server by typing `npm run serve`, and navigate to the address presented on the screen (Should be `localhost:8000` by default).\n\n> From now on I'm going to assume the server is running in the background, so I won't repeat the instruction above\n\nJust to make sure that the canvas is visible and not blended into the background, we will draw a black border around using a simple style-sheet:\n\n[{]: <helper> (diffStep 2.2)\n\n#### [Step 2.2: Create basic game stylesheet](https://github.com/DAB0mB/radial-snake/commit/44fe5aa)\n\n##### Added resources&#x2F;styles&#x2F;game.css\n```diff\n@@ -0,0 +1,6 @@\n+â”Š â”Š1â”Š#gameCanvas {\n+â”Š â”Š2â”Š  display: block;\n+â”Š â”Š3â”Š  margin: auto;\n+â”Š â”Š4â”Š  border-style: solid;\n+â”Š â”Š5â”Š  border-width: 1px;\n+â”Š â”Š6â”Š}ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -2,6 +2,9 @@\n â”Š 2â”Š 2â”Š<html>\n â”Š 3â”Š 3â”Š  <head>\n â”Š 4â”Š 4â”Š    <title>radial snake</title>\n+â”Š  â”Š 5â”Š\n+â”Š  â”Š 6â”Š    <!-- Styles -->\n+â”Š  â”Š 7â”Š    <link rel=\"stylesheet\" type=\"text/css\" href=\"/styles/game.css\">\n â”Š 5â”Š 8â”Š  </head>\n â”Š 6â”Š 9â”Š\n â”Š 7â”Š10â”Š  <body>\n```\n\n[}]: #\n\n> Note that every asset we create should be declared in the HTML file in order for it to take effect\n\nTo build this project we're also gonna use two very famous utility libraries called [JQuery](http://jquery.com/) and [Underscore](http://underscorejs.org/) which will make our lives a bit easier. Third-party libraries should be located in a directory called `libs`, according to the routes-map we created in the previous step. To set these libraries up, type the following commands in series:\n\n    resources$ mkdir libs\n    resources$ cd libs\n    resources/libs$ wget raw.githubusercontent.com/dab0mb/radial-snake/master/resources/libs/underscore.js\n    resources/libs$ wget raw.githubusercontent.com/dab0mb/radial-snake/master/resources/libs/jquery-2.1.1.js\n\nAnd load them in the game's HTML file's header:\n\n[{]: <helper> (diffStep 2.3 files=\"views/game.html\")\n\n#### [Step 2.3: Add jquery and underscore libs](https://github.com/DAB0mB/radial-snake/commit/085ca6b)\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -3,6 +3,10 @@\n â”Š 3â”Š 3â”Š  <head>\n â”Š 4â”Š 4â”Š    <title>radial snake</title>\n â”Š 5â”Š 5â”Š\n+â”Š  â”Š 6â”Š    <!-- Libs -->\n+â”Š  â”Š 7â”Š    <script type=\"text/javascript\" src=\"/libs/jquery-2.1.1.js\"></script>\n+â”Š  â”Š 8â”Š    <script type=\"text/javascript\" src=\"/libs/underscore.js\"></script>\n+â”Š  â”Š 9â”Š\n â”Š 6â”Š10â”Š    <!-- Styles -->\n â”Š 7â”Š11â”Š    <link rel=\"stylesheet\" type=\"text/css\" href=\"/styles/game.css\">\n â”Š 8â”Š12â”Š  </head>\n```\n\n[}]: #\n\nNow, we're finally going to build the game engine. At first, it's gonna be very basic simple, but further in this tutorial we're going to extend it and add some pretty neat features. When creating an application, of any kind, you don't want to garbage the global scope, so it can stay clean without any conflicts. Therefore, we're going to create an initial namespace for our game engine called `Engine`, which is going to contain all our game engine's classes and entities:\n\n[{]: <helper> (diffStep 2.4)\n\n#### [Step 2.4: Add engine namespace](https://github.com/DAB0mB/radial-snake/commit/3d52525)\n\n##### Added resources&#x2F;scripts&#x2F;namespaces.js\n```diff\n@@ -0,0 +1 @@\n+â”Š â”Š1â”ŠEngine = {};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -7,6 +7,9 @@\n â”Š 7â”Š 7â”Š    <script type=\"text/javascript\" src=\"/libs/jquery-2.1.1.js\"></script>\n â”Š 8â”Š 8â”Š    <script type=\"text/javascript\" src=\"/libs/underscore.js\"></script>\n â”Š 9â”Š 9â”Š\n+â”Š  â”Š10â”Š    <!-- Scripts -->\n+â”Š  â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n+â”Š  â”Š12â”Š\n â”Š10â”Š13â”Š    <!-- Styles -->\n â”Š11â”Š14â”Š    <link rel=\"stylesheet\" type=\"text/css\" href=\"/styles/game.css\">\n â”Š12â”Š15â”Š  </head>\n```\n\n[}]: #\n\nThe first thing we're going to define in the namespace we've just created would be the game loop. The game loop is the central code of your game, split into different parts. Generally, these are: update and draw.\n\nThe main purpose of the update phase is to prepare all objects to be drawn, so this is where all the geometry code, coordinate updates, score changes, animation refreshments and other similar operations belong. This is also where the input will be captured and processed.\n\nWhen everything is properly updated and ready, we enter the draw phase where all this information is put on the screen. This function should contain all the code to manage and draw the levels, shapes, score board and so on.\n\n![game-loop](https://cloud.githubusercontent.com/assets/7648874/21332964/4b80ef4e-c633-11e6-946a-0c5870d2f9c9.png)\n\n> You can find plenty of details and information about what \"game loop\" means simply by typing in on Google.\n\nA game loop can wear many forms, but the concept is gonna be the same, plus-minus. This is how our game loop is going to loop like:\n\n[{]: <helper> (diffStep 2.5)\n\n#### [Step 2.5: Create a game basis](https://github.com/DAB0mB/radial-snake/commit/1b7fcf9)\n\n##### Added resources&#x2F;scripts&#x2F;engine&#x2F;game.js\n```diff\n@@ -0,0 +1,99 @@\n+â”Š  â”Š 1â”ŠEngine.Game = class Game {\n+â”Š  â”Š 2â”Š  // The frequency of which each frame will be drawn in milliseconds\n+â”Š  â”Š 3â”Š  get fps() {\n+â”Š  â”Š 4â”Š    return 1000 / 60;\n+â”Š  â”Š 5â”Š  }\n+â”Š  â”Š 6â”Š\n+â”Š  â”Š 7â”Š  // Game's run speed.\n+â”Š  â”Š 8â”Š  // A lower value will make it run slower and a higher value will make it run faster\n+â”Š  â”Š 9â”Š  get speed() {\n+â”Š  â”Š10â”Š    return 1;\n+â”Š  â”Š11â”Š  }\n+â”Š  â”Š12â”Š\n+â”Š  â”Š13â”Š  constructor(canvas) {\n+â”Š  â”Š14â”Š    this.canvas = canvas;\n+â”Š  â”Š15â”Š    this.lastUpdate = this.creation = new Date().getTime();\n+â”Š  â”Š16â”Š\n+â”Š  â”Š17â”Š    // Canvas dimensions must be set programmatically otherwise you might encounter some\n+â”Š  â”Š18â”Š    // unexpected behaviors\n+â”Š  â”Š19â”Š    canvas.width = 1280;\n+â”Š  â”Š20â”Š    canvas.height = 720;\n+â”Š  â”Š21â”Š    // Canvas will be focused once game page is loaded so all events will automatically\n+â”Š  â”Š22â”Š    // be captured by it\n+â”Š  â”Š23â”Š    canvas.focus();\n+â”Š  â”Š24â”Š\n+â”Š  â”Š25â”Š    // We want to focus on the canvas once we press on it\n+â”Š  â”Š26â”Š    canvas.addEventListener(\"mousedown\", canvas.focus.bind(canvas), false);\n+â”Š  â”Š27â”Š\n+â”Š  â”Š28â”Š    this.assets = {};\n+â”Š  â”Š29â”Š    this.events = new Map();\n+â”Š  â”Š30â”Š    this.context = canvas.getContext(\"2d\");\n+â”Š  â”Š31â”Š    this.bufferedCanvas = document.createElement(\"canvas\");\n+â”Š  â”Š32â”Š    this.bufferedContext = this.bufferedCanvas.getContext(\"2d\");\n+â”Š  â”Š33â”Š    this.bufferedCanvas.width = canvas.width;\n+â”Š  â”Š34â”Š    this.bufferedCanvas.height = canvas.height;\n+â”Š  â”Š35â”Š  }\n+â”Š  â”Š36â”Š\n+â”Š  â”Š37â”Š  draw() {\n+â”Š  â”Š38â”Š    // Draw a black screen by default\n+â”Š  â”Š39â”Š    this.context.restore();\n+â”Š  â”Š40â”Š    this.context.fillStyle = \"black\";\n+â”Š  â”Š41â”Š    this.context.save();\n+â”Š  â”Š42â”Š    this.context.beginPath();\n+â”Š  â”Š43â”Š    this.context.rect(0, 0, this.canvas.width, this.canvas.height);\n+â”Š  â”Š44â”Š    this.context.fill();\n+â”Š  â”Š45â”Š  }\n+â”Š  â”Š46â”Š\n+â”Š  â”Š47â”Š  update() {\n+â”Š  â”Š48â”Š    // Calculate the time elapsed\n+â”Š  â”Š49â”Š    let lastUpdate = this.lastUpdate;\n+â”Š  â”Š50â”Š    let currUpdate = this.lastUpdate = new Date().getTime();\n+â”Š  â”Š51â”Š    let span = currUpdate - lastUpdate;\n+â”Š  â”Š52â”Š    this.updateScreen(span / this.speed);\n+â”Š  â”Š53â”Š  }\n+â”Š  â”Š54â”Š\n+â”Š  â”Š55â”Š  // The main loop of the game\n+â”Š  â”Š56â”Š  loop() {\n+â”Š  â”Š57â”Š    // If paused, don't run loop. The canvas will remain as is\n+â”Š  â”Š58â”Š    if (!this.playing) return;\n+â”Š  â”Š59â”Š\n+â”Š  â”Š60â”Š    setTimeout(() => {\n+â”Š  â”Š61â”Š      this.draw();\n+â”Š  â”Š62â”Š      this.update();\n+â”Š  â”Š63â”Š      this.loop();\n+â”Š  â”Š64â”Š    }, this.fps);\n+â”Š  â”Š65â”Š  }\n+â”Š  â”Š66â”Š\n+â”Š  â”Š67â”Š  play() {\n+â”Š  â”Š68â”Š    this.playing = true;\n+â”Š  â”Š69â”Š    this.loop();\n+â”Š  â”Š70â”Š  }\n+â”Š  â”Š71â”Š\n+â”Š  â”Š72â”Š  pause() {\n+â”Š  â”Š73â”Š    this.playing = false;\n+â”Š  â”Š74â”Š  }\n+â”Š  â”Š75â”Š\n+â”Š  â”Š76â”Š  // Defines global assets\n+â”Š  â”Š77â”Š  extendAssets(assets) {\n+â”Š  â”Š78â”Š    _.extend(this.assets, assets);\n+â”Š  â”Š79â”Š  }\n+â”Š  â”Š80â”Š\n+â”Š  â”Š81â”Š  // Disposes global assets\n+â”Š  â”Š82â”Š  clearAssets() {\n+â”Š  â”Š83â”Š    this.assets = {};\n+â”Š  â”Š84â”Š  }\n+â”Š  â”Š85â”Š\n+â”Š  â”Š86â”Š  // Adds event listener for game canvas\n+â”Š  â”Š87â”Š  addEventListener(type, listener, target) {\n+â”Š  â”Š88â”Š    let boundListener = listener.bind(target);\n+â”Š  â”Š89â”Š    this.events.set(listener, boundListener);\n+â”Š  â”Š90â”Š    this.canvas.addEventListener(type, boundListener, false);\n+â”Š  â”Š91â”Š  }\n+â”Š  â”Š92â”Š\n+â”Š  â”Š93â”Š  // Removes event listener from game canvas\n+â”Š  â”Š94â”Š  removeEventListener(type, listener) {\n+â”Š  â”Š95â”Š    let boundListener = this.events.get(listener);\n+â”Š  â”Š96â”Š    this.events.delete(listener);\n+â”Š  â”Š97â”Š    this.canvas.removeEventListener(type, boundListener, false);\n+â”Š  â”Š98â”Š  }\n+â”Š  â”Š99â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -9,6 +9,7 @@\n â”Š 9â”Š 9â”Š\n â”Š10â”Š10â”Š    <!-- Scripts -->\n â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n+â”Š  â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š12â”Š13â”Š\n â”Š13â”Š14â”Š    <!-- Styles -->\n â”Š14â”Š15â”Š    <link rel=\"stylesheet\" type=\"text/css\" href=\"/styles/game.css\">\n```\n\n[}]: #\n\nThe only thing it's doing right now is drawing a black background, but we're soon going to learn how to take advantage of this game-loop to draw stuff of our own. I'd like to point out that there is no need to implement a [double-buffer](https://en.wikipedia.org/wiki/Multiple_buffering) (A method similar to React's [virtual DOM](https://www.npmjs.com/package/react-dom)) when it comes to `HTMLCanvas` elements, since `HTML5` already does that for us. To start running the game, we first need to wait for the DOM content to initialize, and once it's ready we gonna create a new game instance and call the `play` method:\n\n[{]: <helper> (diffStep 2.6)\n\n#### [Step 2.6: Create game entry point](https://github.com/DAB0mB/radial-snake/commit/30e75df)\n\n##### Added resources&#x2F;scripts&#x2F;main.js\n```diff\n@@ -0,0 +1,4 @@\n+â”Š â”Š1â”Šdocument.addEventListener(\"DOMContentLoaded\", function(event) {\n+â”Š â”Š2â”Š  let game = new Engine.Game(document.getElementById(\"gameCanvas\"), false);\n+â”Š â”Š3â”Š  game.play();\n+â”Š â”Š4â”Š});ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -10,6 +10,7 @@\n â”Š10â”Š10â”Š    <!-- Scripts -->\n â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n â”Š12â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n+â”Š  â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n â”Š13â”Š14â”Š\n â”Š14â”Š15â”Š    <!-- Styles -->\n â”Š15â”Š16â”Š    <link rel=\"stylesheet\" type=\"text/css\" href=\"/styles/game.css\">\n```\n\n[}]: #\n\nThis will take control over the canvas and will draw a new picture every 17ms, which is 60fps (Frames per second). As for now you're only going to see a black canvas, but I promise the final result is not going to disappoint you.\n\nThe next thing we're gonna do would be adding a 'key state' manager, which will store a flag for each key pressed on the keyboard. Once we press the key, the flag's value would be `true`, and once we release it, its value would turn into `false`. This way we have an easy way to track all the key presses without registering a specific event listener for each key press we wanna track:\n\n[{]: <helper> (diffStep 2.7)\n\n#### [Step 2.7: Add key states manager](https://github.com/DAB0mB/radial-snake/commit/831b058)\n\n##### Added resources&#x2F;scripts&#x2F;engine&#x2F;key_states.js\n```diff\n@@ -0,0 +1,20 @@\n+â”Š  â”Š 1â”ŠEngine.KeyStates = class KeyStates {\n+â”Š  â”Š 2â”Š  constructor() {\n+â”Š  â”Š 3â”Š    // We will have 255 states, each one represents an ascii code matching its index\n+â”Š  â”Š 4â”Š    this.states = new Array(255);\n+â”Š  â”Š 5â”Š  }\n+â”Š  â”Š 6â”Š\n+â”Š  â”Š 7â”Š  get(k) {\n+â”Š  â”Š 8â”Š    return this.states[k];\n+â”Š  â”Š 9â”Š  }\n+â”Š  â”Š10â”Š\n+â”Š  â”Š11â”Š  // This should be called once we press a key\n+â”Š  â”Š12â”Š  add(k) {\n+â”Š  â”Š13â”Š    this.states[k] = true;\n+â”Š  â”Š14â”Š  }\n+â”Š  â”Š15â”Š\n+â”Š  â”Š16â”Š  // This should be called once we release a key\n+â”Š  â”Š17â”Š  remove(k) {\n+â”Š  â”Š18â”Š    this.states[k] = false;\n+â”Š  â”Š19â”Š  }\n+â”Š  â”Š20â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -9,6 +9,7 @@\n â”Š 9â”Š 9â”Š\n â”Š10â”Š10â”Š    <!-- Scripts -->\n â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n+â”Š  â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/key_states.js\"></script>\n â”Š12â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n```\n\n[}]: #\n\nNow that we have the key state manager, we will initialize a new instance as part of our game's essentials, and we will create a global event listener for key presses; Each time a key is pressed, the key state manager will update itself:\n\n[{]: <helper> (diffStep 2.8)\n\n#### [Step 2.8: Register key presses](https://github.com/DAB0mB/radial-snake/commit/9f55501)\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;game.js\n```diff\n@@ -14,7 +14,7 @@\n â”Š14â”Š14â”Š    this.canvas = canvas;\n â”Š15â”Š15â”Š    this.lastUpdate = this.creation = new Date().getTime();\n â”Š16â”Š16â”Š\n-â”Š17â”Š  â”Š    // Canvas dimensions must be set programmatically otherwise you might encounter some\n+â”Š  â”Š17â”Š    // Canvas dimensions must be set programmatically, otherwise you might encounter some\n â”Š18â”Š18â”Š    // unexpected behaviors\n â”Š19â”Š19â”Š    canvas.width = 1280;\n â”Š20â”Š20â”Š    canvas.height = 720;\n```\n```diff\n@@ -24,9 +24,13 @@\n â”Š24â”Š24â”Š\n â”Š25â”Š25â”Š    // We want to focus on the canvas once we press on it\n â”Š26â”Š26â”Š    canvas.addEventListener(\"mousedown\", canvas.focus.bind(canvas), false);\n+â”Š  â”Š27â”Š    // Key flags will be registered by the \"KeyStates\" instance\n+â”Š  â”Š28â”Š    canvas.addEventListener(\"keydown\", onKeyDown.bind(this), false);\n+â”Š  â”Š29â”Š    canvas.addEventListener(\"keyup\", onKeyUp.bind(this), false);\n â”Š27â”Š30â”Š\n â”Š28â”Š31â”Š    this.assets = {};\n â”Š29â”Š32â”Š    this.events = new Map();\n+â”Š  â”Š33â”Š    this.keyStates = new Engine.KeyStates();\n â”Š30â”Š34â”Š    this.context = canvas.getContext(\"2d\");\n â”Š31â”Š35â”Š    this.bufferedCanvas = document.createElement(\"canvas\");\n â”Š32â”Š36â”Š    this.bufferedContext = this.bufferedCanvas.getContext(\"2d\");\n```\n```diff\n@@ -96,4 +100,19 @@\n â”Š 96â”Š100â”Š    this.events.delete(listener);\n â”Š 97â”Š101â”Š    this.canvas.removeEventListener(type, boundListener, false);\n â”Š 98â”Š102â”Š  }\n-â”Š 99â”Š   â”Š};ðŸš«â†µ\n+â”Š   â”Š103â”Š};\n+â”Š   â”Š104â”Š\n+â”Š   â”Š105â”Šfunction onKeyDown(e) {\n+â”Š   â”Š106â”Š  // Once we're focused on the canvas, we want nothing else to happen\n+â”Š   â”Š107â”Š  // besides events the game is listening to. For example, when we press\n+â”Š   â”Š108â”Š  // the arrow keys, this will prevent the screen from scrolling\n+â”Š   â”Š109â”Š  e.preventDefault();\n+â”Š   â”Š110â”Š  // Register key press\n+â”Š   â”Š111â”Š  this.keyStates.add(e.keyCode);\n+â”Š   â”Š112â”Š}\n+â”Š   â”Š113â”Š\n+â”Š   â”Š114â”Šfunction onKeyUp(e) {\n+â”Š   â”Š115â”Š  e.preventDefault();\n+â”Š   â”Š116â”Š  // Register key release\n+â”Š   â”Š117â”Š  this.keyStates.remove(e.keyCode);\n+â”Š   â”Š118â”Š}\n```\n\n[}]: #\n\nA 2D game's view might get complex as we go through with its development and add more logic and entities into it. Having only one `draw` method and only one `update` method is not enough, and if you think of it, it might easily get buffed up into ridiculous dimensions, which is not the way to go. I'd like to introduce you into a new methodology which involves `screens` and `layers`:\n\n- **screen** - Will literally be used whenever we want to show a new screen in our game e.g. 'splash' screen and 'main menu' screen. A screen consists of multiple layers, and will be used as their communicator; All the relevant assets and logic will be initialized inside it.\n- **layer** - similar to Photoshop's layer system, any time we want to add something to the view we add new layers on top or beneath of each other.\n\n![screen-layer](https://cloud.githubusercontent.com/assets/7648874/21487708/9b366efe-cbb7-11e6-8669-3212e440871a.png)\n\nAs I said earlier, the purpose of the screens and the layers is just to split the task of updating and drawing and updating, so we can have logical segments; So the `layer` class should mainly consist of a `draw` and an `update` method:\n\n[{]: <helper> (diffStep 2.9)\n\n#### [Step 2.9: Add screen layer](https://github.com/DAB0mB/radial-snake/commit/736ab08)\n\n##### Added resources&#x2F;scripts&#x2F;engine&#x2F;layer.js\n```diff\n@@ -0,0 +1,43 @@\n+â”Š  â”Š 1â”ŠEngine.Layer = class Layer {\n+â”Š  â”Š 2â”Š  // The dimensions of the layer are correlated to dimensions of the canvas\n+â”Š  â”Š 3â”Š  get width() {\n+â”Š  â”Š 4â”Š    return this.canvas.width;\n+â”Š  â”Š 5â”Š  }\n+â”Š  â”Š 6â”Š\n+â”Š  â”Š 7â”Š  get height() {\n+â”Š  â”Š 8â”Š    return this.canvas.height;\n+â”Š  â”Š 9â”Š  }\n+â”Š  â”Š10â”Š\n+â”Š  â”Š11â”Š  // A hash of \"eventName\" : \"handlerName\" which should be overrided by user\n+â”Š  â”Š12â”Š  get events() {\n+â”Š  â”Š13â”Š    return {};\n+â”Š  â”Š14â”Š  }\n+â”Š  â”Š15â”Š\n+â”Š  â”Š16â”Š  constructor(screen) {\n+â”Š  â”Š17â”Š    this.age = 0;\n+â”Š  â”Š18â”Š    this.creation = new Date().getTime();\n+â”Š  â”Š19â”Š    this.screen = screen;\n+â”Š  â”Š20â”Š    this.game = screen.game;\n+â”Š  â”Š21â”Š    this.assets = screen.assets;\n+â”Š  â”Š22â”Š    this.keyStates = screen.keyStates;\n+â”Š  â”Š23â”Š    this.canvas = screen.game.canvas;\n+â”Š  â”Š24â”Š  }\n+â”Š  â”Š25â”Š\n+â”Š  â”Š26â”Š  update(span) {\n+â”Š  â”Š27â”Š  }\n+â”Š  â”Š28â”Š\n+â”Š  â”Š29â”Š  draw(context) {\n+â”Š  â”Š30â”Š  }\n+â”Š  â”Š31â”Š\n+â”Š  â”Š32â”Š  initEventListeners() {\n+â”Š  â”Š33â”Š    _.each(this.events, (listener, event) => {\n+â”Š  â”Š34â”Š      this.game.addEventListener(event, this[listener], this);\n+â”Š  â”Š35â”Š    });\n+â”Š  â”Š36â”Š  }\n+â”Š  â”Š37â”Š\n+â”Š  â”Š38â”Š  disposeEventListeners() {\n+â”Š  â”Š39â”Š    _.each(this.events, (listener, event) => {\n+â”Š  â”Š40â”Š      this.game.removeEventListener(event, this[listener]);\n+â”Š  â”Š41â”Š    });\n+â”Š  â”Š42â”Š  }\n+â”Š  â”Š43â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -10,6 +10,7 @@\n â”Š10â”Š10â”Š    <!-- Scripts -->\n â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n â”Š12â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/key_states.js\"></script>\n+â”Š  â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/layer.js\"></script>\n â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š14â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n```\n\n[}]: #\n\nSame thing for the screen, it only has a `draw` and `update` methods, only it has a stack of layers, which can either be added or removed:\n\n[{]: <helper> (diffStep 2.1)\n\n#### [Step 2.1: Create basic game view](https://github.com/DAB0mB/radial-snake/commit/254f06f)\n\n##### Added views&#x2F;game.html\n```diff\n@@ -0,0 +1,10 @@\n+â”Š  â”Š 1â”Š<!DOCTYPE html>\n+â”Š  â”Š 2â”Š<html>\n+â”Š  â”Š 3â”Š  <head>\n+â”Š  â”Š 4â”Š    <title>radial snake</title>\n+â”Š  â”Š 5â”Š  </head>\n+â”Š  â”Š 6â”Š\n+â”Š  â”Š 7â”Š  <body>\n+â”Š  â”Š 8â”Š    <canvas id=\"gameCanvas\" tabindex=\"0\"></canvas>\n+â”Š  â”Š 9â”Š  </body>\n+â”Š  â”Š10â”Š</html>ðŸš«â†µ\n```\n\n[}]: #\n\nNow that we have the `screen` class available for us, let's apply it to the main game loop:\n\n[{]: <helper> (diffStep 2.11)\n\n#### [Step 2.11: Draw and update screen in game loop](https://github.com/DAB0mB/radial-snake/commit/9f34754)\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;game.js\n```diff\n@@ -30,6 +30,7 @@\n â”Š30â”Š30â”Š\n â”Š31â”Š31â”Š    this.assets = {};\n â”Š32â”Š32â”Š    this.events = new Map();\n+â”Š  â”Š33â”Š    this.screen = new Engine.Screen(this);\n â”Š33â”Š34â”Š    this.keyStates = new Engine.KeyStates();\n â”Š34â”Š35â”Š    this.context = canvas.getContext(\"2d\");\n â”Š35â”Š36â”Š    this.bufferedCanvas = document.createElement(\"canvas\");\n```\n```diff\n@@ -46,6 +47,13 @@\n â”Š46â”Š47â”Š    this.context.beginPath();\n â”Š47â”Š48â”Š    this.context.rect(0, 0, this.canvas.width, this.canvas.height);\n â”Š48â”Š49â”Š    this.context.fill();\n+â”Š  â”Š50â”Š    this.drawScreen(this.context);\n+â”Š  â”Š51â”Š  }\n+â”Š  â”Š52â”Š\n+â”Š  â”Š53â”Š  drawScreen(context) {\n+â”Š  â”Š54â”Š    // If screen's assets are not yet loaded, don't draw it\n+â”Š  â”Š55â”Š    if (this.screen.loading) return;\n+â”Š  â”Š56â”Š    if (this.screen.draw) this.screen.draw(context);\n â”Š49â”Š57â”Š  }\n â”Š50â”Š58â”Š\n â”Š51â”Š59â”Š  update() {\n```\n```diff\n@@ -56,6 +64,13 @@\n â”Š56â”Š64â”Š    this.updateScreen(span / this.speed);\n â”Š57â”Š65â”Š  }\n â”Š58â”Š66â”Š\n+â”Š  â”Š67â”Š  updateScreen(span) {\n+â”Š  â”Š68â”Š    this.screen.age += span;\n+â”Š  â”Š69â”Š    // If screen's assets are not yet loaded, don't update it\n+â”Š  â”Š70â”Š    if (this.screen.loading) return;\n+â”Š  â”Š71â”Š    if (this.screen.update) this.screen.update(span);\n+â”Š  â”Š72â”Š  }\n+â”Š  â”Š73â”Š\n â”Š59â”Š74â”Š  // The main loop of the game\n â”Š60â”Š75â”Š  loop() {\n â”Š61â”Š76â”Š    // If paused, don't run loop. The canvas will remain as is\n```\n\n[}]: #\n\nThis step looks kind of useless for now, unless we will have the ability to change screens as we please. Any time a screen is changed, it should be loaded with its necessary assets e.g textures, sounds, fonts, etc. The assets loading is an asynchronous operation whose logic might get a bit messy if not managed properly. To make it easier, we're going to define an assets loader, which will help us load assets asynchronously:\n\n[{]: <helper> (diffStep 2.12)\n\n#### [Step 2.12: Add assets loader](https://github.com/DAB0mB/radial-snake/commit/d8895f8)\n\n##### Added resources&#x2F;scripts&#x2F;engine&#x2F;assets_loader.js\n```diff\n@@ -0,0 +1,13 @@\n+â”Š  â”Š 1â”ŠEngine.AssetsLoader = class AssetsLoader {\n+â”Š  â”Š 2â”Š  constructor(next) {\n+â”Š  â”Š 3â”Š    this.next = next;\n+â”Š  â”Š 4â”Š  }\n+â”Š  â”Š 5â”Š\n+â”Š  â”Š 6â”Š  // Load texture\n+â”Š  â”Š 7â”Š  texture(path) {\n+â”Š  â”Š 8â”Š    let image = new Image();\n+â”Š  â”Š 9â”Š    image.onload = this.next();\n+â”Š  â”Š10â”Š    image.src = `${path}.png`;\n+â”Š  â”Š11â”Š    return image;\n+â”Š  â”Š12â”Š  }\n+â”Š  â”Š13â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -12,6 +12,7 @@\n â”Š12â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/key_states.js\"></script>\n â”Š13â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/layer.js\"></script>\n â”Š14â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/screen.js\"></script>\n+â”Š  â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/assets_loader.js\"></script>\n â”Š15â”Š16â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š16â”Š17â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n```\n\n[}]: #\n\n> As for now the `assets loader` only has the ability to load textures, but we will extend it as we go further in this tutorial, no need to overdo it.\n\nNow that we have the `assets loader` we can add the ability to change a screen. Whenever we change a screen, the old screen's assets should be unloaded, and the new screen's assets should be loaded using the `assets loader`:\n\n[{]: <helper> (diffStep 2.13)\n\n#### [Step 2.13: Add the ability to change and load screen](https://github.com/DAB0mB/radial-snake/commit/90aab03)\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;game.js\n```diff\n@@ -92,6 +92,61 @@\n â”Š 92â”Š 92â”Š    this.playing = false;\n â”Š 93â”Š 93â”Š  }\n â”Š 94â”Š 94â”Š\n+â”Š   â”Š 95â”Š  changeScreen(Screen, ...screenArgs) {\n+â”Š   â”Š 96â”Š    // If there is a screen defined, dispose it first\n+â”Š   â”Š 97â”Š    if (this.screen) {\n+â”Š   â”Š 98â”Š      this.unloadScreen();\n+â”Š   â”Š 99â”Š      this.screen.disposeEventListeners();\n+â”Š   â”Š100â”Š    }\n+â”Š   â”Š101â”Š\n+â”Š   â”Š102â”Š    this.screen = new Screen(this, ...screenArgs);\n+â”Š   â”Š103â”Š\n+â”Š   â”Š104â”Š    // Load screen assets\n+â”Š   â”Š105â”Š    this.loadScreen(() => {\n+â”Š   â”Š106â”Š      // Once assets are loaded, initialize event listeners\n+â”Š   â”Š107â”Š      this.screen.initEventListeners();\n+â”Š   â”Š108â”Š      // The \"initialize\" method is exactly the same as the constructor, only it runs\n+â”Š   â”Š109â”Š      // once assets are available and event listeners are registered\n+â”Š   â”Š110â”Š      this.screen.initialize(this, ...screenArgs);\n+â”Š   â”Š111â”Š    });\n+â”Š   â”Š112â”Š  }\n+â”Š   â”Š113â”Š\n+â”Š   â”Š114â”Š  // Loads screen assets and invokes callback once loading is finished\n+â”Š   â”Š115â”Š  loadScreen(callback = _.noop) {\n+â”Š   â”Š116â”Š    if (!this.screen.load) return callback();\n+â”Š   â”Š117â”Š\n+â”Š   â”Š118â”Š    this.screen.loading = true;\n+â”Š   â”Š119â”Š    // The number of assets to load\n+â”Š   â”Š120â”Š    let loadsize = 0;\n+â”Š   â”Š121â”Š    let onload;\n+â”Š   â”Š122â”Š\n+â”Š   â”Š123â”Š    // This object can load assets\n+â”Š   â”Š124â”Š    let assetsLoader = new Engine.AssetsLoader(() => {\n+â”Š   â”Š125â”Š      loadsize++;\n+â”Š   â”Š126â”Š      return () => onload();\n+â”Š   â”Š127â”Š    });\n+â”Š   â”Š128â”Š\n+â”Š   â”Š129â”Š    // The \"load\" method returns the assets loaded by the screen\n+â”Š   â”Š130â”Š    let screenAssets = this.screen.load(assetsLoader);\n+â”Š   â”Š131â”Š\n+â”Š   â”Š132â”Š    // We use the \"after\" method because we want the following callback to be invoked\n+â”Š   â”Š133â”Š    // only once all assets are loaded\n+â”Š   â”Š134â”Š    onload = _.after(loadsize, () => {\n+â”Š   â”Š135â”Š      delete this.screen.loading;\n+â”Š   â”Š136â”Š      callback();\n+â”Š   â”Š137â”Š    });\n+â”Š   â”Š138â”Š\n+â”Š   â”Š139â”Š    // The returned assets will be available on screen's assets object\n+â”Š   â”Š140â”Š    _.extend(this.screen.assets, screenAssets);\n+â”Š   â”Š141â”Š  }\n+â”Š   â”Š142â”Š\n+â”Š   â”Š143â”Š  // Disposes screen assets\n+â”Š   â”Š144â”Š  unloadScreen() {\n+â”Š   â”Š145â”Š    if (!this.screen.unload) return;\n+â”Š   â”Š146â”Š    let assetsNames = this.screen.unload();\n+â”Š   â”Š147â”Š    _.omit(this.assets, assetsNames);\n+â”Š   â”Š148â”Š  }\n+â”Š   â”Š149â”Š\n â”Š 95â”Š150â”Š  // Defines global assets\n â”Š 96â”Š151â”Š  extendAssets(assets) {\n â”Š 97â”Š152â”Š    _.extend(this.assets, assets);\n```\n\n[}]: #\n\nLet's add a test screen just so we can get the hang of it. The test screen will only print a message to the canvas:\n\n[{]: <helper> (diffStep 2.14)\n\n#### [Step 2.14: Add test screen](https://github.com/DAB0mB/radial-snake/commit/85776e8)\n\n##### Added resources&#x2F;scripts&#x2F;test_screen.js\n```diff\n@@ -0,0 +1,10 @@\n+â”Š  â”Š 1â”Šclass TestScreen extends Engine.Screen {\n+â”Š  â”Š 2â”Š  draw(context) {\n+â”Š  â”Š 3â”Š    // A 20px sized \"Georgia\" font (Available natively)\n+â”Š  â”Š 4â”Š    context.font = \"20px Georgia\";\n+â”Š  â”Š 5â”Š    // The text should be colored white\n+â”Š  â”Š 6â”Š    context.fillStyle = \"white\";\n+â”Š  â”Š 7â”Š    // Draw the following message 50px from the left and 50px from the top\n+â”Š  â”Š 8â”Š    context.fillText(\"This is a Test Screen\", 50, 50);\n+â”Š  â”Š 9â”Š  }\n+â”Š  â”Š10â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -14,6 +14,7 @@\n â”Š14â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/screen.js\"></script>\n â”Š15â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/assets_loader.js\"></script>\n â”Š16â”Š16â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n+â”Š  â”Š17â”Š    <script type=\"text/javascript\" src=\"/scripts/test_screen.js\"></script>\n â”Š17â”Š18â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n â”Š18â”Š19â”Š\n â”Š19â”Š20â”Š    <!-- Styles -->\n```\n\n[}]: #\n\nNow we will use the test screen by changing to it as we create an instance of the game:\n\n[{]: <helper> (diffStep 2.15)\n\n#### [Step 2.15: Set test screen as the initial screen](https://github.com/DAB0mB/radial-snake/commit/203d084)\n\n##### Changed resources&#x2F;scripts&#x2F;main.js\n```diff\n@@ -1,4 +1,5 @@\n â”Š1â”Š1â”Šdocument.addEventListener(\"DOMContentLoaded\", function(event) {\n â”Š2â”Š2â”Š  let game = new Engine.Game(document.getElementById(\"gameCanvas\"), false);\n+â”Š â”Š3â”Š  game.changeScreen(TestScreen);\n â”Š3â”Š4â”Š  game.play();\n â”Š4â”Š5â”Š});ðŸš«â†µ\n```\n\n[}]: #\n\nOnce you will load the application you should see a black canvas with a white text saying:\n\n    This is a test screen\n\nIt means our screen system works and you may proceed to the next step, where we're gonna create our first screen :-)"
          },
          {
            "manualTitle": "Step 3: Creating a splash screen using a keyframe animation engine",
            "stepRevision": "4b2431bbc910f8945e5fd86aa964fec3ede8761c",
            "manualView": "![snake-demo-splash-small](https://cloud.githubusercontent.com/assets/7648874/21074086/a19fa9ce-bed6-11e6-9060-2ce94c215712.gif)\n\nIn this step we will be creating the `splash` screen - the initial screen that should be shown once we launch the game. Our splash is consisted of a random logo animation as presented in the `gif` file above. The \"splash\" effect can be achieved using 2 concepts:\n\n- A sprite class - Which will present the logo texture in different dimensions, angles and rotations.\n- A key-frame animation - Which will draw an animation automatically along the time axis using key-frames - each is a sprite representation of the texture in a specific time point.\n\nSo first thing first, we will start by implementing the sprite class:\n\n[{]: <helper> (diffStep 3.1)\n\n#### [Step 3.1: Create &#x27;Sprite&#x27; class](https://github.com/DAB0mB/radial-snake/commit/a32a711)\n\n##### Added resources&#x2F;scripts&#x2F;engine&#x2F;sprite.js\n```diff\n@@ -0,0 +1,58 @@\n+â”Š  â”Š 1â”ŠEngine.Sprite = class Sprite {\n+â”Š  â”Š 2â”Š  // An easy representation of a sprite on a canvas, with a set of convenient tools\n+â”Š  â”Š 3â”Š  // for alignment and coloring\n+â”Š  â”Š 4â”Š  constructor(texture) {\n+â”Š  â”Š 5â”Š    this.texture = texture;\n+â”Š  â”Š 6â”Š    this.x = 0;\n+â”Š  â”Š 7â”Š    this.y = 0;\n+â”Š  â”Š 8â”Š    this.width = texture.width;\n+â”Š  â”Š 9â”Š    this.height = texture.height;\n+â”Š  â”Š10â”Š    this.pivot = { x: 0, y: 0 };\n+â”Š  â”Š11â”Š    this.opacity = 1;\n+â”Š  â”Š12â”Š  }\n+â”Š  â”Š13â”Š\n+â”Š  â”Š14â”Š  draw(context, offsetX = 0, offsetY = 0) {\n+â”Š  â”Š15â”Š    context.save();\n+â”Š  â”Š16â”Š    context.globalAlpha = this.opacity;\n+â”Š  â”Š17â”Š\n+â”Š  â”Š18â”Š    // The following switch-case can also be seen as a list of all possible\n+â”Š  â”Š19â”Š    // alignment modes\n+â”Š  â”Š20â”Š    switch (this.align) {\n+â”Š  â”Š21â”Š      case \"top-left\": case \"left-top\": this.pivot = { x: 0, y: 0 }; break;\n+â”Š  â”Š22â”Š      case \"top-right\": case \"right-top\": this.pivot = { x: this.width, y: 0 }; break;\n+â”Š  â”Š23â”Š      case \"bottom-left\": case \"left-bottom\": this.pivot = { x: 0, y: this.height }; break;\n+â”Š  â”Š24â”Š      case \"bottom-right\": case \"right-bottom\": this.pivot = { x: this.width, y: this.height }; break;\n+â”Š  â”Š25â”Š      case \"middle\": case \"center\": this.pivot = { x: this.width / 2, y: this.height / 2 }; break;\n+â”Š  â”Š26â”Š      case \"left\": this.pivot = { x: 0, y: this.height / 2 }; break;\n+â”Š  â”Š27â”Š      case \"top\": this.pivot = { x: this.width / 2, y: 0 }; break;\n+â”Š  â”Š28â”Š      case \"right\": this.pivot = { x: this.width, y: this.height / 2 }; break;\n+â”Š  â”Š29â”Š      case \"bottom\": this.pivot = { x: this.width / 2, y: this.height }; break;\n+â”Š  â”Š30â”Š    }\n+â”Š  â”Š31â”Š\n+â”Š  â”Š32â”Š    context.drawImage(\n+â”Š  â”Š33â”Š      this.texture,\n+â”Š  â”Š34â”Š      (this.x - this.pivot.x) + offsetX,\n+â”Š  â”Š35â”Š      (this.y - this.pivot.y) + offsetY,\n+â”Š  â”Š36â”Š      this.width,\n+â”Š  â”Š37â”Š      this.height\n+â”Š  â”Š38â”Š    );\n+â”Š  â”Š39â”Š\n+â”Š  â”Š40â”Š    context.restore();\n+â”Š  â”Š41â”Š  }\n+â”Š  â”Š42â”Š\n+â”Š  â”Š43â”Š  // A sprite property (key) can also be resized based on a given percentage.\n+â”Š  â”Š44â”Š  // The 'relative' argument represents the whole of which the percents are gonna be\n+â”Š  â”Š45â”Š  // calculated from, and the 'adapters' argument is an array of property names which\n+â”Š  â”Š46â”Š  // gonna adapt themselves based on the changes made in the given key.\n+â”Š  â”Š47â”Š  // Usually 'width' goes along with ['height'] adapters, if we\n+â”Š  â”Š48â”Š  // want to keep their original ratio\n+â”Š  â”Š49â”Š  setPercentage(key, relative, percents, ...adapters) {\n+â”Š  â”Š50â”Š    let oldVal = this[key];\n+â”Š  â”Š51â”Š    let newVal = this[key] = (percents * relative) / 100;\n+â”Š  â”Š52â”Š    let ratio = newVal / oldVal;\n+â”Š  â”Š53â”Š\n+â”Š  â”Š54â”Š    adapters.forEach(adapter => {\n+â”Š  â”Š55â”Š      this[adapter] *= ratio;\n+â”Š  â”Š56â”Š    });\n+â”Š  â”Š57â”Š  }\n+â”Š  â”Š58â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -9,6 +9,7 @@\n â”Š 9â”Š 9â”Š\n â”Š10â”Š10â”Š    <!-- Scripts -->\n â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n+â”Š  â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/sprite.js\"></script>\n â”Š12â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/key_states.js\"></script>\n â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/layer.js\"></script>\n â”Š14â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/screen.js\"></script>\n```\n\n[}]: #\n\nAnd we will download the logo which will be presented in the splash screen using the sprite class:\n\n    resources$ mkdir assets\n    resources$ cd assets\n    resources/assets$ mkdir textures\n    resources/assets$ cd textures\n    resources/assets/textures$ wget raw.githubusercontent.com/dab0mb/radial-snake/master/resources/assets/textures/splash.png\n\n> Any logo can that you desired can be used instead! But to ease things up I already provided you with one as a sample\n\nNow we will create the initial splash screen, where we only gonna show a sprite of the logo in the middle of the screen, with no animation applied yet. We will first define a dedicated `Screens` module under the `Game` namespace:\n\n[{]: <helper> (diffStep 3.3)\n\n#### [Step 3.3: Create a &#x27;Game&#x27; namespace with a &#x27;Screens&#x27; module](https://github.com/DAB0mB/radial-snake/commit/ae85a96)\n\n##### Changed resources&#x2F;scripts&#x2F;namespaces.js\n```diff\n@@ -1 +1,5 @@\n+â”Š â”Š1â”ŠGame = {\n+â”Š â”Š2â”Š  Screens: {}\n+â”Š â”Š3â”Š};\n+â”Š â”Š4â”Š\n â”Š1â”Š5â”ŠEngine = {};ðŸš«â†µ\n```\n\n[}]: #\n\nAnd we can go ahead and implement the screen itself:\n\n[{]: <helper> (diffStep 3.4)\n\n#### [Step 3.4: Create initial splash screen](https://github.com/DAB0mB/radial-snake/commit/4dd73f3)\n\n##### Added resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;splash&#x2F;index.js\n```diff\n@@ -0,0 +1,19 @@\n+â”Š  â”Š 1â”ŠGame.Screens.Splash = class Splash extends Engine.Screen {\n+â”Š  â”Š 2â”Š  initialize() {\n+â”Š  â”Š 3â”Š    // Create splash sprite and set its properties\n+â”Š  â”Š 4â”Š    this.splashSprite = new Engine.Sprite(this.assets.splashTexture);\n+â”Š  â”Š 5â”Š    this.splashSprite.align = \"center\";\n+â”Š  â”Š 6â”Š    this.splashSprite.x = this.width / 2;\n+â”Š  â”Š 7â”Š  }\n+â”Š  â”Š 8â”Š\n+â”Š  â”Š 9â”Š  load(assetsLoader) {\n+â”Š  â”Š10â”Š    // These are local assets which will be disposed along with the screen\n+â”Š  â”Š11â”Š    return {\n+â”Š  â”Š12â”Š      splashTexture: assetsLoader.texture(\"/textures/splash\")\n+â”Š  â”Š13â”Š    };\n+â”Š  â”Š14â”Š  }\n+â”Š  â”Š15â”Š\n+â”Š  â”Š16â”Š  draw(context) {\n+â”Š  â”Š17â”Š    this.splashSprite.draw(context);\n+â”Š  â”Š18â”Š  }\n+â”Š  â”Š19â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -16,6 +16,7 @@\n â”Š16â”Š16â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/assets_loader.js\"></script>\n â”Š17â”Š17â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š18â”Š18â”Š    <script type=\"text/javascript\" src=\"/scripts/test_screen.js\"></script>\n+â”Š  â”Š19â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/splash/index.js\"></script>\n â”Š19â”Š20â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n â”Š20â”Š21â”Š\n â”Š21â”Š22â”Š    <!-- Styles -->\n```\n\n[}]: #\n\nNow we can set the splash screen as the initial screen in the entry script file:\n\n[{]: <helper> (diffStep 3.5)\n\n#### [Step 3.5: Set splash screen as the initial game screen](https://github.com/DAB0mB/radial-snake/commit/3576ff8)\n\n##### Changed resources&#x2F;scripts&#x2F;main.js\n```diff\n@@ -1,5 +1,5 @@\n â”Š1â”Š1â”Šdocument.addEventListener(\"DOMContentLoaded\", function(event) {\n â”Š2â”Š2â”Š  let game = new Engine.Game(document.getElementById(\"gameCanvas\"), false);\n-â”Š3â”Š â”Š  game.changeScreen(TestScreen);\n+â”Š â”Š3â”Š  game.changeScreen(Game.Screens.Splash);\n â”Š4â”Š4â”Š  game.play();\n â”Š5â”Š5â”Š});ðŸš«â†µ\n```\n\n[}]: #\n\nAnd we will get rid of the unnecessary test screen since we make no use of it any longer:\n\n    $ rm resources/scripts/test_screen.js\n\nWe will now proceed into the next stage where we will be implementing the key-frame animation engine as said at the beginning of the step. We first need to define an `Animations` module, since we can have multiple types of animation strategy like [sprite-atlas animation](http://www.joshmorony.com/how-to-create-animations-in-phaser-with-a-texture-atlas/), not necessarily a key-frame animation:\n\n[{]: <helper> (diffStep 3.7)\n\n#### [Step 3.7: Add &#x27;Animations&#x27; module to &#x27;Engine&#x27; namespace](https://github.com/DAB0mB/radial-snake/commit/ffe800c)\n\n##### Changed resources&#x2F;scripts&#x2F;namespaces.js\n```diff\n@@ -2,4 +2,6 @@\n â”Š2â”Š2â”Š  Screens: {}\n â”Š3â”Š3â”Š};\n â”Š4â”Š4â”Š\n-â”Š5â”Š â”ŠEngine = {};ðŸš«â†µ\n+â”Š â”Š5â”ŠEngine = {\n+â”Š â”Š6â”Š  Animations: {}\n+â”Š â”Š7â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nInside the newly created module we will create the key-frame animation engine. The key-frame animation consists of the following methods:\n\n- update - Updates the animation.\n- draw - Draws the current animation frame on the provided canvas context.\n- play - Enables update operations.\n- pause - Disables update operations.\n\n[{]: <helper> (diffStep 3.8)\n\n#### [Step 3.8: Create a key-frame animation engine](https://github.com/DAB0mB/radial-snake/commit/64c58fb)\n\n##### Added resources&#x2F;scripts&#x2F;engine&#x2F;animations&#x2F;keyframe.js\n```diff\n@@ -0,0 +1,142 @@\n+â”Š   â”Š  1â”ŠEngine.Animations.Keyframe = class Keyframe {\n+â”Š   â”Š  2â”Š  constructor(sprite, keyframes) {\n+â”Š   â”Š  3â”Š    this.sprite = sprite;\n+â”Š   â”Š  4â”Š    // The key-frames array contains objects with the properties of the\n+â”Š   â”Š  5â”Š    // sprite at the current time-point, e.g. width of 100 and height of 200\n+â”Š   â”Š  6â”Š    this.keyframes = keyframes;\n+â”Š   â”Š  7â”Š    this.age = 0;\n+â”Š   â”Š  8â”Š    this.frame = 0;\n+â”Š   â”Š  9â”Š    // This flag determines what's gonna happen to the animation once\n+â”Š   â”Š 10â”Š    // it's finished playing\n+â”Š   â”Š 11â”Š    this.repetitionMode = \"none\";\n+â”Š   â”Š 12â”Š    this.lastKeyframe = _.last(keyframes);\n+â”Š   â”Š 13â”Š    this.lastFrame = this.lastKeyframe.frame;\n+â”Š   â”Š 14â”Š\n+â”Š   â”Š 15â”Š    // These are the properties which we can animate\n+â”Š   â”Š 16â”Š    this.animables = [\n+â”Š   â”Š 17â”Š      \"x\", \"y\", \"width\", \"height\", \"opacity\"\n+â”Š   â”Š 18â”Š    ];\n+â”Š   â”Š 19â”Š\n+â”Š   â”Š 20â”Š    // Set a map whose keys represent animatable properties and values represent an array\n+â”Š   â”Š 21â”Š    // with relevant key-frames to its belonging property\n+â”Š   â”Š 22â”Š    this.trimmedKeyframes = this.animables.reduce((trimmedKeyframes, key) => {\n+â”Š   â”Š 23â”Š      trimmedKeyframes[key] = keyframes.filter(keyframe => keyframe[key] != null);\n+â”Š   â”Š 24â”Š      return trimmedKeyframes;\n+â”Š   â”Š 25â”Š    }, {});\n+â”Š   â”Š 26â”Š\n+â”Š   â”Š 27â”Š    // Set initial properties on sprite based on initial key-frame\n+â”Š   â”Š 28â”Š    _.each(keyframes[0], (value, key) => {\n+â”Š   â”Š 29â”Š      if (this.animables.includes(key)) sprite[key] = value;\n+â”Š   â”Š 30â”Š    });\n+â”Š   â”Š 31â”Š  }\n+â”Š   â”Š 32â”Š\n+â”Š   â”Š 33â”Š  draw(context, offsetX, offsetY) {\n+â”Š   â”Š 34â”Š    this.sprite.draw(context, offsetX, offsetY);\n+â”Š   â”Š 35â”Š  }\n+â”Š   â”Š 36â”Š\n+â”Š   â”Š 37â”Š  update(span) {\n+â”Š   â”Š 38â”Š    if (!this.playing) return;\n+â”Š   â”Š 39â”Š\n+â”Š   â”Š 40â”Š    this.age += span;\n+â”Š   â”Š 41â”Š\n+â”Š   â”Š 42â”Š    switch (this.repetitionMode) {\n+â”Š   â”Š 43â”Š      // After one cycle animation would stop\n+â”Š   â”Š 44â”Š      case \"none\":\n+â”Š   â”Š 45â”Š        this.frame += span;\n+â”Š   â”Š 46â”Š\n+â”Š   â”Š 47â”Š        if (this.frame > this.lastFrame) {\n+â”Š   â”Š 48â”Š          this.frame = this.lastFrame;\n+â”Š   â”Š 49â”Š          this.playing = false;\n+â”Š   â”Š 50â”Š        }\n+â”Š   â”Š 51â”Š\n+â”Š   â”Š 52â”Š        break;\n+â”Š   â”Š 53â”Š\n+â”Š   â”Š 54â”Š      // Once finished, replay from the beginning\n+â”Š   â”Š 55â”Š      case \"cyclic\":\n+â”Š   â”Š 56â”Š        this.frame = this.age % this.lastFrame;\n+â”Š   â”Š 57â”Š        break;\n+â”Š   â”Š 58â”Š\n+â”Š   â”Š 59â”Š      // Once finished, play backwards, and so on\n+â”Š   â”Š 60â”Š      case \"full\":\n+â”Š   â”Š 61â”Š        this.frame = this.age % this.lastFrame;\n+â”Š   â”Š 62â”Š        let animationComplete = (this.age / this.lastFrame) % 2 >= 1;\n+â”Š   â”Š 63â”Š        if (animationComplete) this.frame = this.lastFrame - this.frame;\n+â”Š   â”Š 64â”Š        break;\n+â”Š   â”Š 65â”Š    }\n+â”Š   â”Š 66â”Š\n+â”Š   â”Š 67â”Š    // Update sprite properties based on given key-frame's easing mode\n+â”Š   â”Š 68â”Š    this.animables.forEach(key => {\n+â”Š   â”Š 69â”Š      let motion = this.getKeyframeMotion(key);\n+â”Š   â”Š 70â”Š\n+â”Š   â”Š 71â”Š      if (motion)\n+â”Š   â”Š 72â”Š        this.sprite[key] = this.calculateRelativeValue(motion, key);\n+â”Š   â”Š 73â”Š    });\n+â”Š   â”Š 74â”Š  }\n+â”Š   â”Š 75â”Š\n+â”Š   â”Š 76â”Š  play() {\n+â”Š   â”Š 77â”Š    this.playing = true;\n+â”Š   â”Š 78â”Š  }\n+â”Š   â”Š 79â”Š\n+â”Š   â”Š 80â”Š  pause() {\n+â”Š   â”Š 81â”Š    this.playing = false;\n+â”Š   â”Š 82â”Š  }\n+â”Š   â”Š 83â”Š\n+â”Š   â”Š 84â”Š  // Gets motion for current refresh\n+â”Š   â”Š 85â”Š  getKeyframeMotion(key) {\n+â”Š   â”Š 86â”Š    let keyframes = this.trimmedKeyframes[key];\n+â”Š   â”Š 87â”Š\n+â”Š   â”Š 88â”Š    // If no key-frames defined, motion is idle\n+â”Š   â”Š 89â”Š    if (keyframes == null) return;\n+â”Š   â”Š 90â”Š    // If there is only one key frame, motion is idle\n+â”Š   â”Š 91â”Š    if (keyframes.length < 2) return;\n+â”Š   â”Š 92â”Š    // If last frame reached, motion is idle\n+â”Š   â”Š 93â”Š    if (this.frame > _.last(keyframes).frame) return;\n+â”Š   â”Š 94â”Š\n+â”Š   â”Š 95â”Š    let start = this.findStartKeyframe(keyframes);\n+â”Š   â”Š 96â”Š    let end = this.findEndKeyframe(keyframes);\n+â”Š   â”Š 97â”Š    let ratio = this.getKeyframesRatio(start, end);\n+â”Š   â”Š 98â”Š\n+â”Š   â”Š 99â”Š    return { start, end, ratio };\n+â”Š   â”Š100â”Š  }\n+â”Š   â”Š101â”Š\n+â”Š   â”Š102â”Š  // Gets the movement ratio\n+â”Š   â”Š103â”Š  getKeyframesRatio(start, end) {\n+â”Š   â”Š104â”Š    return (this.frame - start.frame) / (end.frame - start.frame);\n+â”Š   â”Š105â”Š  }\n+â”Š   â”Š106â”Š\n+â”Š   â”Š107â”Š  // Get property end value based on current frame\n+â”Š   â”Š108â”Š  findEndKeyframe(keyframes) {\n+â”Š   â”Š109â”Š    return _.find(keyframes, keyframe =>\n+â”Š   â”Š110â”Š      keyframe.frame >= (this.frame || 1)\n+â”Š   â”Š111â”Š    );\n+â”Š   â”Š112â”Š  }\n+â”Š   â”Š113â”Š\n+â”Š   â”Š114â”Š  // Get property start value based on current frame\n+â”Š   â”Š115â”Š  findStartKeyframe(keyframes) {\n+â”Š   â”Š116â”Š    let resultIndex;\n+â”Š   â”Š117â”Š\n+â”Š   â”Š118â”Š    keyframes.some((keyframe, currIndex) => {\n+â”Š   â”Š119â”Š      if (keyframe.frame >= (this.frame || 1)) {\n+â”Š   â”Š120â”Š        resultIndex = currIndex;\n+â”Š   â”Š121â”Š        return true;\n+â”Š   â”Š122â”Š      }\n+â”Š   â”Š123â”Š    });\n+â”Š   â”Š124â”Š\n+â”Š   â”Š125â”Š    return keyframes[resultIndex - 1];\n+â”Š   â”Š126â”Š  }\n+â”Š   â”Š127â”Š\n+â”Š   â”Š128â”Š  // Get a recalculated property value relative to provided easing mode\n+â”Š   â”Š129â”Š  calculateRelativeValue(motion, key) {\n+â”Š   â”Š130â”Š    let a = motion.start[key];\n+â”Š   â”Š131â”Š    let b = motion.end[key];\n+â”Š   â”Š132â”Š    let r = motion.ratio;\n+â”Š   â”Š133â”Š    let easing = r > 0 ? motion.start.easing : motion.end.easing;\n+â”Š   â”Š134â”Š\n+â”Š   â”Š135â”Š    switch (easing) {\n+â”Š   â”Š136â”Š      case \"in\": r = Math.sin((r * Math.PI) / 2); break;\n+â”Š   â”Š137â”Š      case \"out\": r = Math.cos((r * Math.PI) / 2); break;\n+â”Š   â”Š138â”Š    }\n+â”Š   â”Š139â”Š\n+â”Š   â”Š140â”Š    return ((b - a) * r) + a;\n+â”Š   â”Š141â”Š  }\n+â”Š   â”Š142â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -10,6 +10,7 @@\n â”Š10â”Š10â”Š    <!-- Scripts -->\n â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n â”Š12â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/sprite.js\"></script>\n+â”Š  â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/animations/keyframe.js\"></script>\n â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/key_states.js\"></script>\n â”Š14â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/layer.js\"></script>\n â”Š15â”Š16â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/screen.js\"></script>\n```\n\n[}]: #\n\nWhen initializing a new instance of the key-frame animation, we should invoke it with the desired sprite, and an array of key-frames. What exactly does a single key-frame represents? The properties of the sprite at that specific time point. In addition, a key-frame can be set with an [easing mode](https://css-tricks.com/ease-out-in-ease-in-out/) of `in` and `out`. By default, the animation would be linear.\n\nBased on the `repitationMode` property, three things can happen to the animation once finished:\n\n- `none` - The animation will play once, and then stop. It will appear as a static sprite.\n- `cyclic` - The animation will repeat itself from the beginning, over and over again until stopped manually.\n- `full` - The animation will play itself backwards, and then forwards, backwards, forwards, and so on.\n\nThanks to the key-frame animation engine, we can apply it to the splash screen to show a beautifully animated logo rather than showing a static image. So in addition to the logo sprite, we will initialize a key-frame animation as well:\n\n[{]: <helper> (diffStep 3.9)\n\n#### [Step 3.9: Apply key-frame animation to splash screen](https://github.com/DAB0mB/radial-snake/commit/8ca47e5)\n\n##### Changed resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;splash&#x2F;index.js\n```diff\n@@ -1,9 +1,34 @@\n â”Š 1â”Š 1â”ŠGame.Screens.Splash = class Splash extends Engine.Screen {\n â”Š 2â”Š 2â”Š  initialize() {\n â”Š 3â”Š 3â”Š    // Create splash sprite and set its properties\n-â”Š 4â”Š  â”Š    this.splashSprite = new Engine.Sprite(this.assets.splashTexture);\n-â”Š 5â”Š  â”Š    this.splashSprite.align = \"center\";\n-â”Š 6â”Š  â”Š    this.splashSprite.x = this.width / 2;\n+â”Š  â”Š 4â”Š    let splashSprite = new Engine.Sprite(this.assets.splashTexture);\n+â”Š  â”Š 5â”Š    splashSprite.align = \"center\";\n+â”Š  â”Š 6â”Š    splashSprite.x = this.width / 2;\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Š    // Create splash sprite animation\n+â”Š  â”Š 9â”Š    this.splashAnim = new Engine.Animations.Keyframe(splashSprite, [\n+â”Š  â”Š10â”Š      {\n+â”Š  â”Š11â”Š        y: (this.height / 2) - 30,\n+â”Š  â”Š12â”Š        width: splashSprite.width / 4,\n+â”Š  â”Š13â”Š        height: splashSprite.height / 4,\n+â”Š  â”Š14â”Š        opacity: 0,\n+â”Š  â”Š15â”Š        easing: \"in\",\n+â”Š  â”Š16â”Š        frame: 0\n+â”Š  â”Š17â”Š      },\n+â”Š  â”Š18â”Š      {\n+â”Š  â”Š19â”Š        y: this.height / 2,\n+â”Š  â”Š20â”Š        width: (splashSprite.width / 3) + (splashSprite.width * 0.05),\n+â”Š  â”Š21â”Š        height: (splashSprite.height / 3) + (splashSprite.height * 0.05),\n+â”Š  â”Š22â”Š        opacity: 1,\n+â”Š  â”Š23â”Š        frame: 3000\n+â”Š  â”Š24â”Š      },\n+â”Š  â”Š25â”Š      {\n+â”Š  â”Š26â”Š        frame: 3500\n+â”Š  â”Š27â”Š      }\n+â”Š  â”Š28â”Š    ]);\n+â”Š  â”Š29â”Š\n+â”Š  â”Š30â”Š    // Start playing animation\n+â”Š  â”Š31â”Š    this.splashAnim.play();\n â”Š 7â”Š32â”Š  }\n â”Š 8â”Š33â”Š\n â”Š 9â”Š34â”Š  load(assetsLoader) {\n```\n```diff\n@@ -14,6 +39,10 @@\n â”Š14â”Š39â”Š  }\n â”Š15â”Š40â”Š\n â”Š16â”Š41â”Š  draw(context) {\n-â”Š17â”Š  â”Š    this.splashSprite.draw(context);\n+â”Š  â”Š42â”Š    this.splashAnim.draw(context);\n+â”Š  â”Š43â”Š  }\n+â”Š  â”Š44â”Š\n+â”Š  â”Š45â”Š  update(span) {\n+â”Š  â”Š46â”Š    this.splashAnim.update(span);\n â”Š18â”Š47â”Š  }\n â”Š19â”Š48â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nThe following key-frames illustrate the nodes of the animation we've just created:\n\n    width: 0\n    height: 0\n    opacity: 0\n\n![logo-empty](https://cloud.githubusercontent.com/assets/7648874/21583394/ee7a1dec-d065-11e6-80ce-fdd37c4b5dbb.png)\n\n    width: 225\n    height: 175\n    opacity: 1\n\n![logo-half](https://cloud.githubusercontent.com/assets/7648874/21583396/ee9bdf68-d065-11e6-95fb-4cf5ed58a9de.png)\n\n    width: 342\n    height: 266\n    opacity: 1\n\n![logo-full](https://cloud.githubusercontent.com/assets/7648874/21583395/ee7b3754-d065-11e6-9646-476d196a6412.png)"
          },
          {
            "manualTitle": "Step 4: Creating a main menu screen using a font engine",
            "stepRevision": "f88428bffcdf2bcf269b9cc15837cc40e0ed9caf",
            "manualView": "![snake-demo-menu-small](https://cloud.githubusercontent.com/assets/7648874/21074099/e72a81bc-bed6-11e6-98cb-329dc12a4b06.gif)\n\nIn this step we will be creating the main menu screen as shown above. The main menu screen is a simple screen which will show the logo of the game and an instruction text saying `Press a key to start`. We will be using a simple texture to show the game-logo and we will use the key-frame animation engine to show a flickering animation of the instruction text. The instruction text is the main part of this step, since it is made out of a font file (`.ttf`) and the text is auto-generated, a general solution which can serve us in many situations. We will start by implementing the main menu using static assets, which means that we will use a texture to show the instructions text, and later on we will implement the generic solution I've just mentioned. First, we will download the necessary assets:\n\n    resources/assets/textures$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/assets/textures/instructions.png\n    resources/assets/textures$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/assets/textures/logo.png\n\nAnd then we will implement the initial main menu screen:\n\n[{]: <helper> (diffStep 4.2)\n\n#### [Step 4.2: Create initial main menu screen](https://github.com/DAB0mB/radial-snake/commit/ed79de7)\n\n##### Added resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;menu&#x2F;index.js\n```diff\n@@ -0,0 +1,44 @@\n+â”Š  â”Š 1â”ŠGame.Screens.Menu = class Menu extends Engine.Screen {\n+â”Š  â”Š 2â”Š  initialize() {\n+â”Š  â”Š 3â”Š    // Initialize snake logo sprite\n+â”Š  â”Š 4â”Š    this.logoSprite = new Engine.Sprite(this.assets.logoTexture);\n+â”Š  â”Š 5â”Š    this.logoSprite.setPercentage(\"width\", this.width, 30, \"height\");\n+â”Š  â”Š 6â”Š\n+â”Š  â”Š 7â”Š    // Initialize instructions sprite\n+â”Š  â”Š 8â”Š    let instructionsSprite = new Engine.Sprite(this.assets.instructionsTexture);\n+â”Š  â”Š 9â”Š    instructionsSprite.align = \"center\";\n+â”Š  â”Š10â”Š    instructionsSprite.setPercentage(\"width\", this.width, 35, \"height\");\n+â”Š  â”Š11â”Š    instructionsSprite.x = this.width / 2;\n+â”Š  â”Š12â”Š    instructionsSprite.y = this.height / 2;\n+â”Š  â”Š13â”Š\n+â”Š  â”Š14â”Š    // Create flickering animation for instructions sprite\n+â”Š  â”Š15â”Š    this.instructionsAnim = new Engine.Animations.Keyframe(instructionsSprite, [\n+â”Š  â”Š16â”Š      {\n+â”Š  â”Š17â”Š        opacity: 1,\n+â”Š  â”Š18â”Š        frame: 0\n+â”Š  â”Š19â”Š      },\n+â”Š  â”Š20â”Š      {\n+â”Š  â”Š21â”Š        opacity: 0,\n+â”Š  â”Š22â”Š        frame: 2000\n+â”Š  â”Š23â”Š      }\n+â”Š  â”Š24â”Š    ]);\n+â”Š  â”Š25â”Š\n+â”Š  â”Š26â”Š    // Play it repeatedly, back and forth\n+â”Š  â”Š27â”Š    this.instructionsAnim.repetitionMode = \"full\";\n+â”Š  â”Š28â”Š    this.instructionsAnim.play();\n+â”Š  â”Š29â”Š  }\n+â”Š  â”Š30â”Š\n+â”Š  â”Š31â”Š  unload() {\n+â”Š  â”Š32â”Š    // Dispose the following assets to prevent memory leaks\n+â”Š  â”Š33â”Š    return [\"logoTexture\", \"instructionsTexture\"];\n+â”Š  â”Š34â”Š  }\n+â”Š  â”Š35â”Š\n+â”Š  â”Š36â”Š  draw(context) {\n+â”Š  â”Š37â”Š    this.logoSprite.draw(context);\n+â”Š  â”Š38â”Š    this.instructionsAnim.draw(context);\n+â”Š  â”Š39â”Š  }\n+â”Š  â”Š40â”Š\n+â”Š  â”Š41â”Š  update(span) {\n+â”Š  â”Š42â”Š    this.instructionsAnim.update(span);\n+â”Š  â”Š43â”Š  }\n+â”Š  â”Š44â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -16,6 +16,7 @@\n â”Š16â”Š16â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/screen.js\"></script>\n â”Š17â”Š17â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/assets_loader.js\"></script>\n â”Š18â”Š18â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n+â”Š  â”Š19â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/menu/index.js\"></script>\n â”Š19â”Š20â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/splash/index.js\"></script>\n â”Š20â”Š21â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n```\n\n[}]: #\n\nThis screen is dependent on several assets which we will load during \"splash screen time\", to save some loading time and for a smooth experience. The main menu screen will be shown automatically once the splash animation has been finished:\n\n[{]: <helper> (diffStep 4.3)\n\n#### [Step 4.3: Queue main menu screen](https://github.com/DAB0mB/radial-snake/commit/cd83a30)\n\n##### Changed resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;splash&#x2F;index.js\n```diff\n@@ -32,10 +32,21 @@\n â”Š32â”Š32â”Š  }\n â”Š33â”Š33â”Š\n â”Š34â”Š34â”Š  load(assetsLoader) {\n+â”Š  â”Š35â”Š    // Load assets\n+â”Š  â”Š36â”Š    let instructionsTexture = assetsLoader.texture(\"/textures/instrucitons\");\n+â”Š  â”Š37â”Š    let logoTexture = assetsLoader.texture(\"/textures/logo\");\n+â”Š  â”Š38â”Š    let splashTexture = assetsLoader.texture(\"/textures/splash\");\n+â”Š  â”Š39â”Š\n+â”Š  â”Š40â”Š    // These are global assets which will be shared among all screens until manually\n+â”Š  â”Š41â”Š    // disposed. We use the time gap created by the splash animation to load necessary\n+â”Š  â”Š42â”Š    // assets without wasting any time\n+â”Š  â”Š43â”Š    this.game.extendAssets({\n+â”Š  â”Š44â”Š      instructionsTexture,\n+â”Š  â”Š45â”Š      logoTexture\n+â”Š  â”Š46â”Š    });\n+â”Š  â”Š47â”Š\n â”Š35â”Š48â”Š    // These are local assets which will be disposed along with the screen\n-â”Š36â”Š  â”Š    return {\n-â”Š37â”Š  â”Š      splashTexture: assetsLoader.texture(\"/textures/splash\")\n-â”Š38â”Š  â”Š    };\n+â”Š  â”Š49â”Š    return { splashTexture };\n â”Š39â”Š50â”Š  }\n â”Š40â”Š51â”Š\n â”Š41â”Š52â”Š  draw(context) {\n```\n```diff\n@@ -43,6 +54,12 @@\n â”Š43â”Š54â”Š  }\n â”Š44â”Š55â”Š\n â”Š45â”Š56â”Š  update(span) {\n-â”Š46â”Š  â”Š    this.splashAnim.update(span);\n+â”Š  â”Š57â”Š    if (this.splashAnim.playing) {\n+â”Š  â”Š58â”Š      this.splashAnim.update(span);\n+â”Š  â”Š59â”Š    }\n+â”Š  â”Š60â”Š    // Once animation has stopped play switch to main menu\n+â”Š  â”Š61â”Š    else {\n+â”Š  â”Š62â”Š      this.game.changeScreen(Game.Screens.Menu);\n+â”Š  â”Š63â”Š    }\n â”Š47â”Š64â”Š  }\n â”Š48â”Š65â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nBy now if you launch the application you should see the main menu screen as described in the beginning. But event though it works, we're not yet finished. We still need to convert the instruction texture into an auto-generated font texture. Obviously, this requires us to download the desired `ttf` file:\n\n    resources/assets/fonts$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/assets/fonts/minecraftia.ttf\n\n> Any font file can be used here, but to save time and effort I already provided you with one\n\n`ttf` is the most common format, but since we're using JavaScript, it would make sense to convert it into a `json` file, and that's exactly what we're going to do. There's a very convenient software called [font-builder](https://github.com/andryblack/fontbuilder), and it can cut fonts, store them in `png` files, along with some user-specified meta-data stored in an `xml` file.\n\n![font-builder](https://camo.githubusercontent.com/b2c95cda825c783f5399d9197599848c33cdfcc8/687474703a2f2f7777772e67616d656465762e72752f66696c65732f696d616765732f73637265656e312e6a706567)\n\nGo over to this website: https://github.com/andryblack/fontbuilder.\nFetch a copy of the `font-builder` repo, and try to convert the `minecraftia.ttf` file into a `png` file. If you want to skip this step, although I wouldn't recommend it, you can download the following files which I already generated myself:\n\n    resources/assets/fonts$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/assets/fonts/minecraftia.png\n    resources/assets/fonts$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/assets/fonts/minecraftia.xml\n\nAs promised, we will be working with a `json` file, not a `ttf` file and not an `xml` file. For this task we will be implementing a font-parser module, which will simply take all the meta-data in the `xml` file and put it into a nice `json` schema:\n\n[{]: <helper> (diffStep 4.6)\n\n#### [Step 4.6: Create font parser so we can convert &#x27;xml&#x27; font format to &#x27;json&#x27;](https://github.com/DAB0mB/radial-snake/commit/66044e9)\n\n##### Added helpers&#x2F;font_parser.js\n```diff\n@@ -0,0 +1,102 @@\n+â”Š   â”Š  1â”Šconst _ = require(\"underscore\");\n+â”Š   â”Š  2â”Šconst Async = require(\"async\");\n+â”Š   â”Š  3â”Šconst Fs = require(\"fs\");\n+â”Š   â”Š  4â”Šconst Path = require(\"path\");\n+â”Š   â”Š  5â”Šconst { DOMParser } = require(\"xmldom\");\n+â”Š   â”Š  6â”Š\n+â”Š   â”Š  7â”Šif (module === require.main) {\n+â”Š   â”Š  8â”Š  let fonstDir = Path.resolve(__dirname, \"../resources/assets/fonts\");\n+â”Š   â”Š  9â”Š  xmlsToJsons(fonstDir, err => { if (err) throw err });\n+â”Š   â”Š 10â”Š}\n+â”Š   â”Š 11â”Š\n+â”Š   â”Š 12â”Š// Gets a dir path containing font xmls and converts them all to jsons\n+â”Š   â”Š 13â”Šfunction xmlsToJsons(path, callback = _.noop) {\n+â”Š   â”Š 14â”Š  Fs.readdir(path, (err, files) => {\n+â”Š   â”Š 15â”Š    if (err) return callback(err);\n+â”Š   â”Š 16â”Š\n+â”Š   â”Š 17â”Š    // Remove all extensions\n+â”Š   â”Š 18â”Š    fileNames = _.uniq(files.map(file => file.split(\".\")[0]));\n+â”Š   â”Š 19â”Š\n+â”Š   â”Š 20â”Š    // Convert each xml individually\n+â”Š   â”Š 21â”Š    Async.each(fileNames, (fileName, next) => {\n+â”Š   â”Š 22â”Š      xmlToJson(`${path}/${fileName}`, next);\n+â”Š   â”Š 23â”Š    },\n+â”Š   â”Š 24â”Š    (err) => {\n+â”Š   â”Š 25â”Š      if (!err) console.log(\n+â”Š   â”Š 26â”Š        'All fonts have been successfully parsed!'\n+â”Š   â”Š 27â”Š      );\n+â”Š   â”Š 28â”Š\n+â”Š   â”Š 29â”Š      callback(err);\n+â”Š   â”Š 30â”Š    });\n+â”Š   â”Š 31â”Š  });\n+â”Š   â”Š 32â”Š}\n+â”Š   â”Š 33â”Š\n+â”Š   â”Š 34â”Š// Gets a font xml and converts it to json\n+â”Š   â”Š 35â”Šfunction xmlToJson(path, callback = _.noop) {\n+â”Š   â”Š 36â”Š  Async.waterfall([\n+â”Š   â”Š 37â”Š    (next) => {\n+â”Š   â”Š 38â”Š      Fs.readFile(`${path}.xml`, function(err, xmlBuffer) {\n+â”Š   â”Š 39â”Š        if (err) return next(err);\n+â”Š   â”Š 40â”Š\n+â”Š   â”Š 41â”Š        let json = {\n+â”Š   â”Š 42â”Š          chars: {}\n+â”Š   â”Š 43â”Š        };\n+â”Š   â”Š 44â”Š\n+â”Š   â”Š 45â”Š        let xml = xmlBuffer.toString();\n+â”Š   â”Š 46â”Š        let doc = new DOMParser().parseFromString(xml);\n+â”Š   â”Š 47â”Š        let fontDoc = doc.getElementsByTagName(\"Font\")[0];\n+â”Š   â”Š 48â”Š        let charsDoc = fontDoc.getElementsByTagName(\"Char\");\n+â”Š   â”Š 49â”Š\n+â”Š   â”Š 50â”Š        // Compose meta-data about font like size and family\n+â”Š   â”Š 51â”Š        _.each(fontDoc.attributes, (attr) => {\n+â”Š   â”Š 52â”Š          json[attr.name] = parseInt(attr.value) || attr.value;\n+â”Š   â”Š 53â”Š        });\n+â”Š   â”Š 54â”Š\n+â”Š   â”Š 55â”Š        // Compose data about each character in font\n+â”Š   â”Š 56â”Š        _.each(charsDoc, (charDoc) => {\n+â”Š   â”Š 57â”Š          let charCode = charDoc.getAttribute(\"code\");\n+â”Š   â”Š 58â”Š\n+â”Š   â”Š 59â”Š          let char = json.chars[charCode] = {\n+â”Š   â”Š 60â”Š            rect: rect = {},\n+â”Š   â”Š 61â”Š            offset: offset = {},\n+â”Š   â”Š 62â”Š            width: parseInt(charDoc.getAttribute(\"width\"))\n+â”Š   â”Š 63â”Š          };\n+â”Š   â”Š 64â”Š\n+â”Š   â”Š 65â”Š          [\n+â”Š   â”Š 66â”Š            rect.x,\n+â”Š   â”Š 67â”Š            rect.y,\n+â”Š   â”Š 68â”Š            rect.width,\n+â”Š   â”Š 69â”Š            rect.height\n+â”Š   â”Š 70â”Š          ] = extractIntegers(charDoc.getAttribute(\"rect\"));\n+â”Š   â”Š 71â”Š\n+â”Š   â”Š 72â”Š          [offset.x, offset.y] = extractIntegers(charDoc.getAttribute(\"offset\"));\n+â”Š   â”Š 73â”Š        });\n+â”Š   â”Š 74â”Š\n+â”Š   â”Š 75â”Š        next(null, JSON.stringify(json, null, 2));\n+â”Š   â”Š 76â”Š      });\n+â”Š   â”Š 77â”Š    },\n+â”Š   â”Š 78â”Š    (json, next) => {\n+â”Š   â”Š 79â”Š      // Once finished, write json into file\n+â”Š   â”Š 80â”Š      Fs.writeFile(path + \".json\", json, (err) => {\n+â”Š   â”Š 81â”Š        next(err);\n+â”Š   â”Š 82â”Š      });\n+â”Š   â”Š 83â”Š    }\n+â”Š   â”Š 84â”Š  ], (err) => {\n+â”Š   â”Š 85â”Š    if (!err) console.log(\n+â”Š   â”Š 86â”Š      `Font ${path} has been successfully parsed...`\n+â”Š   â”Š 87â”Š    );\n+â”Š   â”Š 88â”Š\n+â”Š   â”Š 89â”Š    callback(err);\n+â”Š   â”Š 90â”Š  });\n+â”Š   â”Š 91â”Š};\n+â”Š   â”Š 92â”Š\n+â”Š   â”Š 93â”Š// Converts an string of numbers to array of numbers\n+â”Š   â”Š 94â”Š// e.g. extractIntegers(\"1 2 3\") -> [1, 2, 3]\n+â”Š   â”Š 95â”Šfunction extractIntegers(srcstr) {\n+â”Š   â”Š 96â”Š  return srcstr.split(\" \").map((substr) => parseInt(substr));\n+â”Š   â”Š 97â”Š}\n+â”Š   â”Š 98â”Š\n+â”Š   â”Š 99â”Šmodule.exports = {\n+â”Š   â”Š100â”Š  xmlToJson,\n+â”Š   â”Š101â”Š  xmlsToJsons\n+â”Š   â”Š102â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nThis script will take everything that's in the `fonts` dir and parser it as mentioned above. Before we can user this script we will need to install some NPM dependencies like so:\n\n    $ npm install --save underscore\n    $ npm install --save xmldom\n\nAnd instead of running the parser manually over and over again whenever we wanna use it, we will use the following `NPM` script instead:\n\n[{]: <helper> (diffStep 4.8)\n\n#### [Step 4.8: Add font parsing npm scripts](https://github.com/DAB0mB/radial-snake/commit/7a1cf81)\n\n##### Changed package.json\n```diff\n@@ -7,7 +7,8 @@\n â”Š 7â”Š 7â”Š  },\n â”Š 8â”Š 8â”Š  \"private\": true,\n â”Š 9â”Š 9â”Š  \"scripts\": {\n-â”Š10â”Š  â”Š    \"serve\": \"nodemon server.js\"\n+â”Š  â”Š10â”Š    \"serve\": \"npm run parse:fonts && nodemon server.js\",\n+â”Š  â”Š11â”Š    \"build:fonts\": \"node helpers/font_parser.js\"\n â”Š11â”Š12â”Š  },\n â”Š12â”Š13â”Š  \"dependencies\": {\n â”Š13â”Š14â”Š    \"async\": \"^2.1.4\",\n```\n\n[}]: #\n\nWe don't want the generated fonts to be included by `git` since they are going to automatically regenerate themselves, therefore we gonna add the following ignore rule:\n\n[{]: <helper> (diffStep 4.9)\n\n#### [Step 4.9: Add rule to to git-ignore parsed fonts](https://github.com/DAB0mB/radial-snake/commit/bbf7647)\n\n##### Changed .gitignore\n```diff\n@@ -1,2 +1,3 @@\n â”Š1â”Š1â”Šnode_modules\n-â”Š2â”Š â”Šnpm-debug.logðŸš«â†µ\n+â”Š â”Š2â”Šnpm-debug.log\n+â”Š â”Š3â”Šresources/assets/fonts/*.jsonðŸš«â†µ\n```\n\n[}]: #\n\nNow we will build our `minecraftia` font by simply running:\n\n    $ npm run build:fonts\n\nAnd voila! We have a freshly created `json` file which we can work with. You can also get it from here:\n\n    resources/assets/fonts$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/assets/fonts/minecraftia.json\n\nNow that we have our assets finally ready we can go ahead and focus on extending the engine which powers up our game. We need some sort of a generic font-engine which will know how to load a font file and create a text-sprite out of it. First we will implement a class called `Restorable`, which shares the same restore API as the CanvasRenderingContext2D and will give us the ability to save and restore the font's state (More information can be found [here](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/restore)):\n\n[{]: <helper> (diffStep 4.11)\n\n#### [Step 4.11: Add &#x27;Restorable&#x27; class](https://github.com/DAB0mB/radial-snake/commit/8239c01)\n\n##### Added resources&#x2F;scripts&#x2F;engine&#x2F;restorable.js\n```diff\n@@ -0,0 +1,21 @@\n+â”Š  â”Š 1â”ŠEngine.Restorable = class Restorable {\n+â”Š  â”Š 2â”Š  // Acts the same as canvas's save() and restore() API.\n+â”Š  â”Š 3â”Š  // 'restorable' props are defined in the constructor\n+â”Š  â”Š 4â”Š  constructor(...restorableProps) {\n+â”Š  â”Š 5â”Š    this._restorableProps = restorableProps;\n+â”Š  â”Š 6â”Š    this._restorableStates = [];\n+â”Š  â”Š 7â”Š  }\n+â”Š  â”Š 8â”Š\n+â”Š  â”Š 9â”Š  // Save current state in the stack\n+â”Š  â”Š10â”Š  save() {\n+â”Š  â”Š11â”Š    this._restorableStates.push(this._restorableProps.reduce((state, prop) => {\n+â”Š  â”Š12â”Š      state[prop] = this[prop];\n+â”Š  â”Š13â”Š      return state;\n+â”Š  â”Š14â”Š    }, {}));\n+â”Š  â”Š15â”Š  }\n+â”Š  â”Š16â”Š\n+â”Š  â”Š17â”Š  // Pop most recent state and apply it\n+â”Š  â”Š18â”Š  restore() {\n+â”Š  â”Š19â”Š    _.extend(this, this._restorableStates.pop());\n+â”Š  â”Š20â”Š  }\n+â”Š  â”Š21â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -9,6 +9,7 @@\n â”Š 9â”Š 9â”Š\n â”Š10â”Š10â”Š    <!-- Scripts -->\n â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n+â”Š  â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/restorable.js\"></script>\n â”Š12â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/sprite.js\"></script>\n â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/animations/keyframe.js\"></script>\n â”Š14â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/key_states.js\"></script>\n```\n\n[}]: #\n\nAnd now we can go ahead and implement the font class itself:\n\n[{]: <helper> (diffStep 4.12)\n\n#### [Step 4.12: Create font engine](https://github.com/DAB0mB/radial-snake/commit/7a1f2c7)\n\n##### Added resources&#x2F;scripts&#x2F;engine&#x2F;font.js\n```diff\n@@ -0,0 +1,133 @@\n+â”Š   â”Š  1â”ŠEngine.Font = class Font extends Engine.Restorable {\n+â”Š   â”Š  2â”Š  // The src property acts just line native image's src property.\n+â”Š   â”Š  3â”Š  // Once finished loading, the onload() callback will be invoked\n+â”Š   â”Š  4â”Š  get src() {\n+â”Š   â”Š  5â”Š    return this._src;\n+â”Š   â”Š  6â”Š  }\n+â”Š   â”Š  7â”Š\n+â”Š   â”Š  8â”Š  set src(src) {\n+â”Š   â”Š  9â”Š    this._src = src;\n+â”Š   â”Š 10â”Š\n+â”Š   â”Š 11â”Š    // The font is actually an image, therefore we have 2 onload callbacks.\n+â”Š   â”Š 12â”Š    // The first one is the native one which will always be run,\n+â”Š   â”Š 13â”Š    // and the second one is a user defined one\n+â”Š   â”Š 14â”Š    if (this.onload) var done = _.after(2, this.onload);\n+â”Š   â”Š 15â”Š\n+â”Š   â”Š 16â”Š    this.atlas = new Image();\n+â”Š   â”Š 17â”Š    this.atlas.onload = done;\n+â”Š   â”Š 18â”Š    this.atlas.src = `${src}.png`;\n+â”Š   â”Š 19â”Š\n+â”Š   â”Š 20â”Š    // Get json based on the given src property\n+â”Š   â”Š 21â”Š    $.getJSON(`${src}.json`, data => {\n+â”Š   â”Š 22â”Š      this.data = data;\n+â”Š   â”Š 23â”Š      if (done) done();\n+â”Š   â”Š 24â”Š    });\n+â”Š   â”Š 25â”Š\n+â”Š   â”Š 26â”Š    return this._src;\n+â”Š   â”Š 27â”Š  }\n+â”Š   â”Š 28â”Š\n+â”Š   â”Š 29â”Š  constructor() {\n+â”Š   â”Š 30â”Š    // The color property is the only restorable property\n+â”Š   â”Š 31â”Š    super(\"color\");\n+â”Š   â”Š 32â”Š    this.charSpritesCache = {};\n+â”Š   â”Š 33â”Š  }\n+â”Š   â”Š 34â”Š\n+â”Š   â”Š 35â”Š  // Creates a texture out of the font with the given text\n+â”Š   â”Š 36â”Š  createTexture(text, options = {}) {\n+â”Š   â”Š 37â”Š    let { noOffsets, noSpaces } = options;\n+â”Š   â”Š 38â”Š    let canvas = document.createElement(\"canvas\");\n+â”Š   â”Š 39â”Š    let context = canvas.getContext(\"2d\");\n+â”Š   â”Š 40â”Š    let height = canvas.height = this.data.height;\n+â”Š   â”Š 41â”Š\n+â”Š   â”Š 42â”Š    // Calculates the width of the canvas based on the text and the font\n+â”Š   â”Š 43â”Š    let width = canvas.width = _.reduce(text, (width, c) => {\n+â”Š   â”Š 44â”Š      // No-space option means that the characters will be\n+â”Š   â”Š 45â”Š      // drawn with no any space between them\n+â”Š   â”Š 46â”Š      if (noSpaces) {\n+â”Š   â”Š 47â”Š        return width + this.getCharSprite(c).width;\n+â”Š   â”Š 48â”Š      }\n+â”Š   â”Š 49â”Š\n+â”Š   â”Š 50â”Š      return width + this.data.chars[c].width;\n+â”Š   â”Š 51â”Š    }, 0);\n+â”Š   â”Š 52â”Š\n+â”Š   â”Š 53â”Š    // A custom size can be specified for a font as well\n+â”Š   â”Š 54â”Š    if (this.size) {\n+â”Š   â”Š 55â”Š      let ratio = this.size / this.data.size;\n+â”Š   â”Š 56â”Š      canvas.height *= ratio;\n+â”Š   â”Š 57â”Š      canvas.width *= ratio;\n+â”Š   â”Š 58â”Š      context.scale(ratio, ratio);\n+â”Š   â”Š 59â”Š    }\n+â”Š   â”Š 60â”Š\n+â”Š   â”Š 61â”Š    // No we are going to draw each char on the canvas individually,\n+â”Š   â”Š 62â”Š    // naturally, there should be an offset after we draw each character.\n+â”Š   â”Š 63â”Š    // This variable will be used to calculate the offset\n+â”Š   â”Š 64â”Š    let offset = 0;\n+â”Š   â”Š 65â”Š\n+â”Š   â”Š 66â”Š    // Get for each char\n+â”Š   â”Š 67â”Š    _.map(text, (char) => {\n+â”Š   â”Š 68â”Š      return this.getCharSprite(char);\n+â”Š   â”Š 69â”Š    })\n+â”Š   â”Š 70â”Š    // Start drawing each char on the canvas\n+â”Š   â”Š 71â”Š    .forEach((charSprite, index) => {\n+â”Š   â”Š 72â”Š      let charData = this.data.chars[text.charAt(index)];\n+â”Š   â”Š 73â”Š\n+â”Š   â”Š 74â”Š      // Each char in the font xml has a native offset in addition to its rectangle.\n+â”Š   â”Š 75â”Š      // This option will disable the calculation of the native offset\n+â”Š   â”Š 76â”Š      if (noOffsets) {\n+â”Š   â”Š 77â”Š        charSprite.draw(context, offset);\n+â”Š   â”Š 78â”Š      }\n+â”Š   â”Š 79â”Š      else {\n+â”Š   â”Š 80â”Š        charSprite.draw(context, offset + charData.offset.x, charData.offset.y);\n+â”Š   â”Š 81â”Š      }\n+â”Š   â”Š 82â”Š\n+â”Š   â”Š 83â”Š      if (noSpaces) {\n+â”Š   â”Š 84â”Š        offset += charSprite.width;\n+â”Š   â”Š 85â”Š      }\n+â”Š   â”Š 86â”Š      else {\n+â”Š   â”Š 87â”Š        offset += charData.width;\n+â”Š   â”Š 88â”Š      }\n+â”Š   â”Š 89â”Š\n+â”Š   â”Š 90â”Š      // A color for the font can be specified as well\n+â”Š   â”Š 91â”Š      if (this.color) {\n+â”Š   â”Š 92â”Š        let overlayCanvas = document.createElement(\"canvas\");\n+â”Š   â”Š 93â”Š        let overlayContext = overlayCanvas.getContext(\"2d\");\n+â”Š   â”Š 94â”Š        overlayCanvas.width = width;\n+â”Š   â”Š 95â”Š        overlayCanvas.height = height;\n+â”Š   â”Š 96â”Š        overlayContext.beginPath();\n+â”Š   â”Š 97â”Š        overlayContext.rect(0, 0, width, height);\n+â”Š   â”Š 98â”Š        overlayContext.fillStyle = this.color;\n+â”Š   â”Š 99â”Š        overlayContext.fill();\n+â”Š   â”Š100â”Š\n+â”Š   â”Š101â”Š        context.save();\n+â”Š   â”Š102â”Š        context.globalCompositeOperation = \"source-in\";\n+â”Š   â”Š103â”Š        context.drawImage(overlayCanvas, 0, 0);\n+â”Š   â”Š104â”Š        context.restore();\n+â”Š   â”Š105â”Š      }\n+â”Š   â”Š106â”Š    });\n+â”Š   â”Š107â”Š\n+â”Š   â”Š108â”Š    // The canvas will be treated like an image\n+â”Š   â”Š109â”Š    return canvas;\n+â”Š   â”Š110â”Š  }\n+â”Š   â”Š111â”Š\n+â”Š   â”Š112â”Š  // Gets a sprite of the given char, using the current font\n+â”Š   â”Š113â”Š  getCharSprite(char) {\n+â”Š   â”Š114â”Š    // If char is already stored in cache, abort calculation and return it\n+â”Š   â”Š115â”Š    if (this.charSpritesCache[char]) return this.charSpritesCache[char];\n+â”Š   â”Š116â”Š\n+â”Š   â”Š117â”Š    // This data is fetched by the given json\n+â”Š   â”Š118â”Š    let { x, y, width, height } = this.data.chars[char].rect;\n+â”Š   â”Š119â”Š    // Creating a canvas which we will use to draw on,\n+â”Š   â”Š120â”Š    // but it is used exactly like an image afterwards\n+â”Š   â”Š121â”Š    let canvas = document.createElement(\"canvas\");\n+â”Š   â”Š122â”Š    let context = canvas.getContext(\"2d\");\n+â”Š   â”Š123â”Š\n+â”Š   â”Š124â”Š    // The canvas will have the same dimensions as the font\n+â”Š   â”Š125â”Š    canvas.width = width;\n+â”Š   â”Š126â”Š    canvas.height = height;\n+â”Š   â”Š127â”Š    // Draw a cropped image from the atlas, this image contains the char font\n+â”Š   â”Š128â”Š    context.drawImage(this.atlas, x, y, width, height, 0, 0, width, height);\n+â”Š   â”Š129â”Š\n+â”Š   â”Š130â”Š    // Store in cache and return it\n+â”Š   â”Š131â”Š    return this.charSpritesCache[char] = new Engine.Sprite(canvas);\n+â”Š   â”Š132â”Š  }\n+â”Š   â”Š133â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -10,6 +10,7 @@\n â”Š10â”Š10â”Š    <!-- Scripts -->\n â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n â”Š12â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/restorable.js\"></script>\n+â”Š  â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/font.js\"></script>\n â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/sprite.js\"></script>\n â”Š14â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/animations/keyframe.js\"></script>\n â”Š15â”Š16â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/key_states.js\"></script>\n```\n\n[}]: #\n\nThe font API shares a similar API as [HTMLImageElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/Image), once we set the `src` property the font will start loading itself, and the `onload` user-defined callback should be called once finished. Another neat feature would be the `createTexture` method, which takes a string as its first argument, representing the text that we would like to generate, and returns an instance of the `Sprite` class.\n\nWe will also be adding the option to load some font assets in our asset-loader:\n\n[{]: <helper> (diffStep 4.13)\n\n#### [Step 4.13: Add a font loading option to &#x27;AssetLoader&#x27;](https://github.com/DAB0mB/radial-snake/commit/a9d73cc)\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;assets_loader.js\n```diff\n@@ -10,4 +10,12 @@\n â”Š10â”Š10â”Š    image.src = `${path}.png`;\n â”Š11â”Š11â”Š    return image;\n â”Š12â”Š12â”Š  }\n+â”Š  â”Š13â”Š\n+â”Š  â”Š14â”Š  // Load font\n+â”Š  â”Š15â”Š  font(path) {\n+â”Š  â”Š16â”Š    let font = new Engine.Font();\n+â”Š  â”Š17â”Š    font.onload = this.next();\n+â”Š  â”Š18â”Š    font.src = path;\n+â”Š  â”Š19â”Š    return font;\n+â”Š  â”Š20â”Š  }\n â”Š13â”Š21â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nAnd replace the instructions texture loading with a `minecraftia` font loading in the initial splash screen:\n\n[{]: <helper> (diffStep 4.14)\n\n#### [Step 4.14: Load &#x27;minecraftia&#x27; font in splash screen](https://github.com/DAB0mB/radial-snake/commit/231a68f)\n\n##### Changed resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;splash&#x2F;index.js\n```diff\n@@ -33,7 +33,7 @@\n â”Š33â”Š33â”Š\n â”Š34â”Š34â”Š  load(assetsLoader) {\n â”Š35â”Š35â”Š    // Load assets\n-â”Š36â”Š  â”Š    let instructionsTexture = assetsLoader.texture(\"/textures/instrucitons\");\n+â”Š  â”Š36â”Š    let minecraftiaFont = assetsLoader.font(\"/fonts/minecraftia\");\n â”Š37â”Š37â”Š    let logoTexture = assetsLoader.texture(\"/textures/logo\");\n â”Š38â”Š38â”Š    let splashTexture = assetsLoader.texture(\"/textures/splash\");\n â”Š39â”Š39â”Š\n```\n```diff\n@@ -41,7 +41,7 @@\n â”Š41â”Š41â”Š    // disposed. We use the time gap created by the splash animation to load necessary\n â”Š42â”Š42â”Š    // assets without wasting any time\n â”Š43â”Š43â”Š    this.game.extendAssets({\n-â”Š44â”Š  â”Š      instructionsTexture,\n+â”Š  â”Š44â”Š      minecraftiaFont,\n â”Š45â”Š45â”Š      logoTexture\n â”Š46â”Š46â”Š    });\n```\n\n[}]: #\n\nNow it can use us in the main menu screen where we will create a text-sprite saying `Press a key to start`, just like the instruction sprite we're about to replace:\n\n[{]: <helper> (diffStep 4.15)\n\n#### [Step 4.15: Replace texture usage with font usage in main menu screen](https://github.com/DAB0mB/radial-snake/commit/a769b81)\n\n##### Changed resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;menu&#x2F;index.js\n```diff\n@@ -5,7 +5,8 @@\n â”Š 5â”Š 5â”Š    this.logoSprite.setPercentage(\"width\", this.width, 30, \"height\");\n â”Š 6â”Š 6â”Š\n â”Š 7â”Š 7â”Š    // Initialize instructions sprite\n-â”Š 8â”Š  â”Š    let instructionsSprite = new Engine.Sprite(this.assets.instructionsTexture);\n+â”Š  â”Š 8â”Š    let instructionsTexture = this.assets.minecraftiaFont.createTexture(\"Press a key to start\");\n+â”Š  â”Š 9â”Š    let instructionsSprite = new Engine.Sprite(instructionsTexture);\n â”Š 9â”Š10â”Š    instructionsSprite.align = \"center\";\n â”Š10â”Š11â”Š    instructionsSprite.setPercentage(\"width\", this.width, 35, \"height\");\n â”Š11â”Š12â”Š    instructionsSprite.x = this.width / 2;\n```\n```diff\n@@ -30,7 +31,7 @@\n â”Š30â”Š31â”Š\n â”Š31â”Š32â”Š  unload() {\n â”Š32â”Š33â”Š    // Dispose the following assets to prevent memory leaks\n-â”Š33â”Š  â”Š    return [\"logoTexture\", \"instructionsTexture\"];\n+â”Š  â”Š34â”Š    return \"logoTexture\";\n â”Š34â”Š35â”Š  }\n â”Š35â”Š36â”Š\n â”Š36â”Š37â”Š  draw(context) {\n```\n```diff\n@@ -41,4 +42,8 @@\n â”Š41â”Š42â”Š  update(span) {\n â”Š42â”Š43â”Š    this.instructionsAnim.update(span);\n â”Š43â”Š44â”Š  }\n+â”Š  â”Š45â”Š\n+â”Š  â”Š46â”Š  update(span) {\n+â”Š  â”Š47â”Š    this.instructionsAnim.update(span);\n+â”Š  â”Š48â”Š  }\n â”Š44â”Š49â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nIt shouldn't look any different from the beginning of the step where we manually drew the instruction texture, but in the next steps we will be using the font-engine a lot, and you will be thankful for what we've just did."
          },
          {
            "manualTitle": "Step 5: Creating a snake and related geometry shapes",
            "stepRevision": "ad178e03e276b088c96d6f67889db379ad201e3e",
            "manualView": "![snake-illustrate](https://cloud.githubusercontent.com/assets/7648874/21074115/46ef4466-bed7-11e6-9d5d-12fa6d43147b.gif)\n\nIn this step we will be creating all the necessary geometry shapes to form a snake; we're basically implementing the right infrastructure so in the next step we will be able to implement the game screen with ease. What exactly do I mean by \"geometry shapes\"? Well, our snake will be made out of circles, and lines. If we don't press any buttons at all, the snake should move forward at a straight line, and once we press on one of the arrow keys, the snake should move in a circular motion. Not only we want to draw the screen on the canvas, we also want to be able to detect collision with other snakes, since this is a \"Tron\" style game where we gonna fight against an opponent.\n\nKeep in mind that a computer's precision is limited due its [binary representation in memory](https://en.wikipedia.org/wiki/Memory_cell_(binary)). We need to take into consideration that there might be a significant deviation when detecting collisions and intersections between geometry shapes, especially when elapsed time is not always guaranteed to stay precise. To handle these deviation issues, we're gonna create some utility functions and place then in a new module called `Utils`:\n\n[{]: <helper> (diffStep 5.1)\n\n#### [Step 5.1: Create utilities module](https://github.com/DAB0mB/radial-snake/commit/58ae99a)\n\n##### Added resources&#x2F;scripts&#x2F;utils.js\n```diff\n@@ -0,0 +1,68 @@\n+â”Š  â”Š 1â”Š// A wrapper function for our utilities which will enable chaining\n+â”Š  â”Š 2â”Š// e.g. Utils().mod().trim().isBetween()...\n+â”Š  â”Š 3â”ŠUtils = function Utils(context) {\n+â”Š  â”Š 4â”Š  const chain = {};\n+â”Š  â”Š 5â”Š\n+â”Š  â”Š 6â”Š  Object.keys(Utils).forEach((utilName) => {\n+â”Š  â”Š 7â”Š    chain[utilName] = (...args) => {\n+â”Š  â”Š 8â”Š      const result = Utils[utilName](context, ...args);\n+â”Š  â”Š 9â”Š      return Utils(result);\n+â”Š  â”Š10â”Š    };\n+â”Š  â”Š11â”Š  });\n+â”Š  â”Š12â”Š\n+â”Š  â”Š13â”Š  // Returns the result of the chaining\n+â”Š  â”Š14â”Š  chain.value = () => context;\n+â”Š  â”Š15â”Š\n+â”Š  â”Š16â”Š  return chain;\n+â”Š  â”Š17â”Š};\n+â”Š  â”Š18â”Š\n+â”Š  â”Š19â”Š// Fixed modulo method which can calculate modulo of negative numbers properly\n+â”Š  â”Š20â”Š// e.g. (-803).mod(800) returns 797\n+â”Š  â”Š21â”ŠUtils.mod = function (context, num) {\n+â”Š  â”Š22â”Š  return ((context % num) + num) % num;\n+â”Š  â”Š23â”Š};\n+â”Š  â”Š24â”Š\n+â”Š  â”Š25â”Š// Trims number and leaves the number of decimals specified.\n+â”Š  â”Š26â”Š// The \"mode\" argument specifies which math function should be invoked\n+â”Š  â”Š27â”Š// right after the number has been trimmed.\n+â”Š  â”Š28â”Š// e.g. 12.12345.trim(3, \"ceil\") returns 12.124\n+â”Š  â”Š29â”ŠUtils.trim = function (context, decimals, mode = \"round\") {\n+â”Š  â”Š30â”Š  return Math[mode](context * Math.pow(10, decimals)) / Math.pow(10, decimals);\n+â”Š  â”Š31â”Š};\n+â”Š  â”Š32â”Š\n+â”Š  â”Š33â”Š// Tells if number is in specified range based on given precision.\n+â”Š  â”Š34â”Š// See the \"compare\" method for more information about precision\n+â”Š  â”Š35â”ŠUtils.isBetween = function (context, num1, num2, precision) {\n+â”Š  â”Š36â”Š  return Utils.compare(context, Math.min(num1, num2), \">=\", precision) &&\n+â”Š  â”Š37â”Š         Utils.compare(context, Math.max(num1, num2), \"<=\", precision);\n+â”Š  â”Š38â”Š};\n+â”Š  â”Š39â”Š\n+â”Š  â”Š40â”Š// Initiates comparison operator between context number and a given number, only here\n+â”Š  â”Š41â”Š// a precision can be specified\n+â”Š  â”Š42â”ŠUtils.compare = function (context, num, method, precision = method) {\n+â”Š  â”Š43â”Š  switch (precision) {\n+â”Š  â”Š44â”Š    // Fixed precision, \"almost equal\" with a deviation of Îµ\n+â”Š  â”Š45â”Š    case \"f\":\n+â”Š  â”Š46â”Š      switch (method) {\n+â”Š  â”Š47â”Š        case \"<\": case \"<=\": return context <= num + Number.EPSILON;\n+â”Š  â”Š48â”Š        case \">\": case \">=\": return context >= num - Number.EPSILON;\n+â”Š  â”Š49â”Š        default: return Math.abs(context - num) <= Number.EPSILON;\n+â”Š  â”Š50â”Š      }\n+â”Š  â”Š51â”Š    // Pixel precision, round comparison\n+â”Š  â”Š52â”Š    case \"px\":\n+â”Š  â”Š53â”Š      switch (method) {\n+â”Š  â”Š54â”Š        case \"<\": case \"<=\": return Math.round(context) <= Math.round(num);\n+â”Š  â”Š55â”Š        case \">\": case \">=\": return Math.round(context) >= Math.round(num);\n+â”Š  â”Š56â”Š        default: return Math.round(context) == Math.round(num);\n+â”Š  â”Š57â”Š      }\n+â”Š  â”Š58â”Š    // Exact precision\n+â”Š  â”Š59â”Š    default:\n+â”Š  â”Š60â”Š      switch (method) {\n+â”Š  â”Š61â”Š        case \"<\": return context < num;\n+â”Š  â”Š62â”Š        case \"<=\": return context <= num;\n+â”Š  â”Š63â”Š        case \">\": return context > num;\n+â”Š  â”Š64â”Š        case \">=\": return context >= num;\n+â”Š  â”Š65â”Š        default: return context === num;\n+â”Š  â”Š66â”Š      }\n+â”Š  â”Š67â”Š  }\n+â”Š  â”Š68â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -8,6 +8,7 @@\n â”Š 8â”Š 8â”Š    <script type=\"text/javascript\" src=\"/libs/underscore.js\"></script>\n â”Š 9â”Š 9â”Š\n â”Š10â”Š10â”Š    <!-- Scripts -->\n+â”Š  â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/utils.js\"></script>\n â”Š11â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n â”Š12â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/restorable.js\"></script>\n â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/font.js\"></script>\n```\n\n[}]: #\n\nNow we would like to start implementing the first class representation for a line, and for that we're requires to add a new module called `Geometry` to the `Engine` namespace:\n\n[{]: <helper> (diffStep 5.2)\n\n#### [Step 5.2: Add &#x27;Shapes&#x27; module to &#x27;Engine&#x27; namespace](https://github.com/DAB0mB/radial-snake/commit/4ed2788)\n\n##### Changed resources&#x2F;scripts&#x2F;namespaces.js\n```diff\n@@ -3,5 +3,6 @@\n â”Š3â”Š3â”Š};\n â”Š4â”Š4â”Š\n â”Š5â”Š5â”ŠEngine = {\n-â”Š6â”Š â”Š  Animations: {}\n+â”Š â”Š6â”Š  Animations: {},\n+â”Š â”Š7â”Š  Geometry: {}\n â”Š7â”Š8â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nAnd now that we have this module available to use, we can go ahead and implement our first geometry shape class - `Line`:\n\n[{]: <helper> (diffStep 5.3)\n\n#### [Step 5.3: Create &#x27;Line&#x27; class](https://github.com/DAB0mB/radial-snake/commit/fb38ab5)\n\n##### Added resources&#x2F;scripts&#x2F;engine&#x2F;geometry&#x2F;line.js\n```diff\n@@ -0,0 +1,65 @@\n+â”Š  â”Š 1â”ŠEngine.Geometry.Line = class Line {\n+â”Š  â”Š 2â”Š  // x1 - The first point's x value\n+â”Š  â”Š 3â”Š  // y1 - The first point's y value\n+â”Š  â”Š 4â”Š  // x1 - The second point's x value\n+â”Š  â”Š 5â”Š  // y2 - The second point's y value\n+â”Š  â”Š 6â”Š  constructor(x1, y1, x2, y2) {\n+â”Š  â”Š 7â”Š    this.x1 = Utils.trim(x1, 9);\n+â”Š  â”Š 8â”Š    this.y1 = Utils.trim(y1, 9);\n+â”Š  â”Š 9â”Š    this.x2 = Utils.trim(x2, 9);\n+â”Š  â”Š10â”Š    this.y2 = Utils.trim(y2, 9);\n+â”Š  â”Š11â”Š  }\n+â”Š  â”Š12â”Š\n+â”Š  â”Š13â”Š  // Draws the line on the given context\n+â”Š  â”Š14â”Š  draw(context) {\n+â”Š  â”Š15â”Š    context.moveTo(this.x1, this.y1);\n+â”Š  â”Š16â”Š    context.lineTo(this.x2, this.y2);\n+â”Š  â”Š17â”Š  }\n+â”Š  â”Š18â”Š\n+â”Š  â”Š19â”Š  // Gets the matching x value for a given y value\n+â”Š  â”Š20â”Š  getX(y) {\n+â”Š  â”Š21â”Š    let x = Utils.trim((((y - this.y1) * (this.x2 - this.x1)) / (this.y2 - this.y1)) + this.x1, 9);\n+â”Š  â”Š22â”Š    if (isNaN(x) || Utils.isBetween(x, this.x1, this.x2)) return x;\n+â”Š  â”Š23â”Š  }\n+â”Š  â”Š24â”Š\n+â”Š  â”Š25â”Š  // Gets the matching y value for a given x value\n+â”Š  â”Š26â”Š  getY(x) {\n+â”Š  â”Š27â”Š    let y = Utils.trim((((x - this.x1) * (this.y2 - this.y1)) / (this.x2 - this.x1)) + this.y1, 9);\n+â”Š  â”Š28â”Š    if (isNaN(y) || Utils.isBetween(y, this.y1, this.y2)) return y;\n+â”Š  â”Š29â”Š  }\n+â”Š  â”Š30â”Š\n+â”Š  â”Š31â”Š  // Returns if line has given point\n+â”Š  â”Š32â”Š  hasPoint(x, y) {\n+â”Š  â”Š33â”Š    if (!this.boundsHavePoint(x, y)) return false;\n+â”Š  â”Š34â”Š    let m = Utils.trim((this.y2 - this.y1) / (this.x2 - this.x1), 9);\n+â”Š  â”Š35â”Š    return (y - this.y1) / (x - this.x1) == m;\n+â”Š  â”Š36â”Š  }\n+â”Š  â”Š37â”Š\n+â”Š  â”Š38â”Š  // Returns if given point is contained by the bounds aka cage of line\n+â”Š  â”Š39â”Š  boundsHavePoint(x, y) {\n+â”Š  â”Š40â”Š    return Utils.isBetween(x, this.x1, this.x2) &&\n+â”Š  â”Š41â”Š           Utils.isBetween(y, this.y1, this.y2);\n+â”Š  â”Š42â”Š  }\n+â”Š  â”Š43â”Š\n+â”Š  â”Š44â”Š  getIntersection(shape) {\n+â”Š  â”Š45â”Š    if (shape instanceof Engine.Geometry.Line)\n+â”Š  â”Š46â”Š      return this.getLineIntersection(shape);\n+â”Š  â”Š47â”Š  }\n+â”Š  â”Š48â”Š\n+â”Š  â”Š49â”Š  // line - line intersection method\n+â”Š  â”Š50â”Š  getLineIntersection(line) {\n+â”Š  â”Š51â”Š    // Escape if lines are parallel\n+â”Š  â”Š52â”Š    if (!(((this.x1 - this.x2) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * (line.x1 - line.x2)))) return;\n+â”Š  â”Š53â”Š\n+â”Š  â”Š54â”Š    // Intersection point formula\n+â”Š  â”Š55â”Š    let x = Utils.trim(((((this.x1 * this.y2) - (this.y1 * this.x2)) * (line.x1 - line.x2)) - ((this.x1 - this.x2) * ((line.x1 * line.y2) - (line.y1 * line.x2)))) /\n+â”Š  â”Š56â”Š        (((this.x1 - this.x2) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * (line.x1 - line.x2))), 9);\n+â”Š  â”Š57â”Š    let y = Utils.trim(((((this.x1 * this.y2) - (this.y1 * this.x2)) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * ((line.x1 * line.y2) - (line.y1 * line.x2)))) /\n+â”Š  â”Š58â”Š        (((this.x1 - this.x2) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * (line.x1 - line.x2))), 9);\n+â”Š  â”Š59â”Š\n+â”Š  â”Š60â”Š    if (Utils.isBetween(x, this.x1, this.x2) && Utils.isBetween(x, line.x1, line.x2) &&\n+â”Š  â”Š61â”Š        Utils.isBetween(y, this.y1, this.y2) && Utils.isBetween(y, line.y1, line.y2)) {\n+â”Š  â”Š62â”Š      return { x, y };\n+â”Š  â”Š63â”Š    }\n+â”Š  â”Š64â”Š  }\n+â”Š  â”Š65â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -10,6 +10,7 @@\n â”Š10â”Š10â”Š    <!-- Scripts -->\n â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/utils.js\"></script>\n â”Š12â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n+â”Š  â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/geometry/line.js\"></script>\n â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/restorable.js\"></script>\n â”Š14â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/font.js\"></script>\n â”Š15â”Š16â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/sprite.js\"></script>\n```\n\n[}]: #\n\nYou can go through the comments of the step above which will guide you through the programmatic aspect of it, but I think it's more important to understand the concept of a line in 2D space. A line is made out of two points, usually represented as `(x1, y1)` and `(x2, y2)`. The slope of the line, usually represented as `m`, can be determined using these two points based on the following formula:\n\n![slope](https://cloud.githubusercontent.com/assets/7648874/21788249/b4c7e41c-d6b4-11e6-9c17-baff66ec6bc8.png)\n\nOnce we have two lines whose `m` is different (Unparalleled) and there is no intersection between the points of which they are represented with (In which case they are united), there must be an intersection point. The intersection point can be found using the following formula:\n\n![line-line](https://cloud.githubusercontent.com/assets/7648874/21787164/c9d83bf0-d6ae-11e6-9846-4fc013eebab3.png)\n\n![line-line-illustration](https://cloud.githubusercontent.com/assets/7648874/21790864/56725cf0-d6c6-11e6-916b-50b1fc0b87af.png)\n\n> See reference: http://mathworld.wolfram.com/Line-LineIntersection.html.\n\nObviously we have some logic here which needs to be tested. To test our `Line` class, we will be using a testing framework called [Jasmine](https://jasmine.github.io/). We first need to download `Jasmine`'s essentials in order for it to work:\n\n    resources/libs$ mkdir jasmine\n    resources/libs$ cd jasmine\n    resources/libs/jasmine$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/libs/jasmine/boot.js\n    resources/libs/jasmine$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/libs/jasmine/console.js\n    resources/libs/jasmine$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/libs/jasmine/jasmine-html.js\n    resources/libs/jasmine$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/libs/jasmine/jasmine.css\n    resources/libs/jasmine$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/libs/jasmine/jasmine.js\n    resources/libs/jasmine$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/libs/jasmine/jasmine_favicon.png\n\nThese essentials should be loaded in a newly created view where we're gonna see our specs running:\n\n[{]: <helper> (diffStep 5.5)\n\n#### [Step 5.5: Create specs runner view](https://github.com/DAB0mB/radial-snake/commit/150be1a)\n\n##### Added views&#x2F;spec_runner.html\n```diff\n@@ -0,0 +1,27 @@\n+â”Š  â”Š 1â”Š\n+â”Š  â”Š 2â”Š<!DOCTYPE html>\n+â”Š  â”Š 3â”Š<html>\n+â”Š  â”Š 4â”Š  <head>\n+â”Š  â”Š 5â”Š    <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n+â”Š  â”Š 6â”Š    <title>Jasmine Spec Runner v2.0.1</title>\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Š    <!-- Jasmine -->\n+â”Š  â”Š 9â”Š    <script type=\"text/javascript\" src=\"libs/jasmine/jasmine.js\"></script>\n+â”Š  â”Š10â”Š    <script type=\"text/javascript\" src=\"libs/jasmine/jasmine-html.js\"></script>\n+â”Š  â”Š11â”Š    <script type=\"text/javascript\" src=\"libs/jasmine/boot.js\"></script>\n+â”Š  â”Š12â”Š    <link rel=\"shortcut icon\" type=\"image/png\" href=\"libs/jasmine/jasmine_favicon.png\">\n+â”Š  â”Š13â”Š    <link rel=\"stylesheet\" type=\"text/css\" href=\"libs/jasmine/jasmine.css\">\n+â”Š  â”Š14â”Š\n+â”Š  â”Š15â”Š    <!-- Libs -->\n+â”Š  â”Š16â”Š    <script type=\"text/javascript\" src=\"libs/underscore.js\"></script>\n+â”Š  â”Š17â”Š\n+â”Š  â”Š18â”Š    <!-- Scripts -->\n+â”Š  â”Š19â”Š    <script type=\"text/javascript\" src=\"scripts/utils.js\"></script>\n+â”Š  â”Š20â”Š    <script type=\"text/javascript\" src=\"scripts/namespaces.js\"></script>\n+â”Š  â”Š21â”Š\n+â”Š  â”Š22â”Š    <!-- Specs -->\n+â”Š  â”Š23â”Š  </head>\n+â”Š  â”Š24â”Š\n+â”Š  â”Š25â”Š  <body>\n+â”Š  â”Š26â”Š  </body>\n+â”Š  â”Š27â”Š</html>ðŸš«â†µ\n```\n\n[}]: #\n\nNow once we'll navigate to the `/test` sub-route (`localhost:8000/test` by default) we should be provided with the spec runner. As for now there are no specs implemented at all, which brings us to the next stage - Implementing tests for `Line` class:\n\n[{]: <helper> (diffStep 5.6)\n\n#### [Step 5.6: Create &#x27;Line&#x27; class tests](https://github.com/DAB0mB/radial-snake/commit/c052752)\n\n##### Added resources&#x2F;scripts&#x2F;specs&#x2F;engine&#x2F;geometry&#x2F;line.js\n```diff\n@@ -0,0 +1,78 @@\n+â”Š  â”Š 1â”Šdescribe(\"Engine.Geometry.Line class\", function() {\n+â”Š  â”Š 2â”Š  beforeEach(function() {\n+â”Š  â”Š 3â”Š    this.line = new Engine.Geometry.Line(-5, -5, 5, 5);\n+â”Š  â”Š 4â”Š  });\n+â”Š  â”Š 5â”Š\n+â”Š  â”Š 6â”Š  describe(\"getX method\", function() {\n+â”Š  â”Š 7â”Š    describe(\"given inranged y\", function() {\n+â”Š  â”Š 8â”Š      it(\"returns x\", function() {\n+â”Š  â”Š 9â”Š        expect(this.line.getX(1)).toBeCloseTo(1);\n+â”Š  â”Š10â”Š      });\n+â”Š  â”Š11â”Š    });\n+â”Š  â”Š12â”Š\n+â”Š  â”Š13â”Š    describe(\"given outranged y\", function() {\n+â”Š  â”Š14â”Š      it(\"returns nothing\", function() {\n+â”Š  â”Š15â”Š        expect(this.line.getX(10)).toBeUndefined();\n+â”Š  â”Š16â”Š      });\n+â”Š  â”Š17â”Š    });\n+â”Š  â”Š18â”Š  });\n+â”Š  â”Š19â”Š\n+â”Š  â”Š20â”Š  describe(\"getY method\", function() {\n+â”Š  â”Š21â”Š    describe(\"given inranged x\", function() {\n+â”Š  â”Š22â”Š      it(\"returns y\", function() {\n+â”Š  â”Š23â”Š        expect(this.line.getY(1)).toBeCloseTo(1);\n+â”Š  â”Š24â”Š      });\n+â”Š  â”Š25â”Š    });\n+â”Š  â”Š26â”Š\n+â”Š  â”Š27â”Š    describe(\"given outranged x\", function() {\n+â”Š  â”Š28â”Š      it(\"returns nothing\", function() {\n+â”Š  â”Š29â”Š        expect(this.line.getY(10)).toBeUndefined();\n+â”Š  â”Š30â”Š      });\n+â”Š  â”Š31â”Š    });\n+â”Š  â”Š32â”Š  });\n+â”Š  â”Š33â”Š\n+â”Š  â”Š34â”Š  describe(\"hasPoint method\", function() {\n+â”Š  â”Š35â”Š    describe(\"given contained point\", function() {\n+â”Š  â”Š36â”Š      it(\"returns true\", function() {\n+â”Š  â”Š37â”Š        let x = 1;\n+â”Š  â”Š38â”Š        let y = 1;\n+â”Š  â”Š39â”Š        expect(this.line.hasPoint(x, y)).toBeTruthy();\n+â”Š  â”Š40â”Š      });\n+â”Š  â”Š41â”Š    });\n+â”Š  â”Š42â”Š\n+â”Š  â”Š43â”Š    describe(\"given uncontained point\", function() {\n+â”Š  â”Š44â”Š      it(\"returns false\", function() {\n+â”Š  â”Š45â”Š        let x = 10;\n+â”Š  â”Š46â”Š        let y = 10;\n+â”Š  â”Š47â”Š        expect(this.line.hasPoint(x, y)).toBeFalsy();\n+â”Š  â”Š48â”Š      });\n+â”Š  â”Š49â”Š    });\n+â”Š  â”Š50â”Š  });\n+â”Š  â”Š51â”Š\n+â”Š  â”Š52â”Š  describe(\"getLineIntersection method\", function() {\n+â”Š  â”Š53â”Š    describe(\"given intersecting line\", function() {\n+â”Š  â”Š54â”Š      it(\"returns intersection point\", function() {\n+â”Š  â”Š55â”Š        let line = new Engine.Geometry.Line(1, -5, 1, 5);\n+â”Š  â”Š56â”Š\n+â”Š  â”Š57â”Š        expect(this.line.getLineIntersection(line)).toEqual({\n+â”Š  â”Š58â”Š          x: 1,\n+â”Š  â”Š59â”Š          y: 1\n+â”Š  â”Š60â”Š        });\n+â”Š  â”Š61â”Š      });\n+â”Š  â”Š62â”Š    });\n+â”Š  â”Š63â”Š\n+â”Š  â”Š64â”Š    describe(\"given parallel line\", function() {\n+â”Š  â”Š65â”Š      it(\"returns nothing\", function() {\n+â”Š  â”Š66â”Š        let line = new Engine.Geometry.Line(-5, -6, 5, 4);\n+â”Š  â”Š67â”Š        expect(this.line.getLineIntersection(line)).toBeUndefined();\n+â”Š  â”Š68â”Š      });\n+â”Š  â”Š69â”Š    });\n+â”Š  â”Š70â”Š\n+â”Š  â”Š71â”Š    describe(\"given outranged line\", function() {\n+â”Š  â”Š72â”Š      it(\"returns nothing\", function() {\n+â”Š  â”Š73â”Š        let line = new Engine.Geometry.Line(10, 10, 10, 15);\n+â”Š  â”Š74â”Š        expect(this.line.getLineIntersection(line)).toBeUndefined();\n+â”Š  â”Š75â”Š      });\n+â”Š  â”Š76â”Š    });\n+â”Š  â”Š77â”Š  });\n+â”Š  â”Š78â”Š});ðŸš«â†µ\n```\n\n##### Changed views&#x2F;spec_runner.html\n```diff\n@@ -18,8 +18,10 @@\n â”Š18â”Š18â”Š    <!-- Scripts -->\n â”Š19â”Š19â”Š    <script type=\"text/javascript\" src=\"scripts/utils.js\"></script>\n â”Š20â”Š20â”Š    <script type=\"text/javascript\" src=\"scripts/namespaces.js\"></script>\n+â”Š  â”Š21â”Š    <script type=\"text/javascript\" src=\"scripts/engine/geometry/line.js\"></script>\n â”Š21â”Š22â”Š\n â”Š22â”Š23â”Š    <!-- Specs -->\n+â”Š  â”Š24â”Š    <script type=\"text/javascript\" src=\"scripts/specs/engine/geometry/line.js\"></script>\n â”Š23â”Š25â”Š  </head>\n â”Š24â”Š26â”Š\n â”Š25â”Š27â”Š  <body>\n```\n\n[}]: #\n\nNow if you'll refresh the spec runner page you should be able to a green screen indicating all tests have passed (Assuming the tutorial is updated and you followed it correctly). As introduced at the beginning of the step, the snake is also dependent on circles, whose representing class should look like so:\n\n[{]: <helper> (diffStep 5.7)\n\n#### [Step 5.7: Create &#x27;Circle&#x27; class](https://github.com/DAB0mB/radial-snake/commit/f9c5723)\n\n##### Added resources&#x2F;scripts&#x2F;engine&#x2F;geometry&#x2F;circle.js\n```diff\n@@ -0,0 +1,167 @@\n+â”Š   â”Š  1â”ŠEngine.Geometry.Circle = class Circle {\n+â”Š   â”Š  2â”Š  // x - The x value of the circle's center\n+â”Š   â”Š  3â”Š  // y - The y value of the circle's center\n+â”Š   â”Š  4â”Š  // r - The radius of the center\n+â”Š   â”Š  5â”Š  // rad1 - The first radian of the circle, not necessarily its beginning\n+â”Š   â”Š  6â”Š  // rad2 - The second radian of the circle, not necessarily its beginning\n+â”Š   â”Š  7â”Š  constructor(x, y, r, rad1, rad2) {\n+â”Š   â”Š  8â”Š    this.x = Utils.trim(x, 9);\n+â”Š   â”Š  9â”Š    this.y = Utils.trim(y, 9);\n+â”Š   â”Š 10â”Š    this.r = Utils.trim(r, 9);\n+â”Š   â”Š 11â”Š\n+â”Š   â”Š 12â”Š    // Trimming mode is done based on which radian represents the ending and which radian\n+â”Š   â”Š 13â”Š    // represents the ending\n+â”Š   â”Š 14â”Š    if (rad1 > rad2) {\n+â”Š   â”Š 15â”Š      this.rad1 = Utils.trim(rad1, 9, \"floor\");\n+â”Š   â”Š 16â”Š      this.rad2 = Utils.trim(rad2, 9, \"ceil\");\n+â”Š   â”Š 17â”Š    }\n+â”Š   â”Š 18â”Š    else {\n+â”Š   â”Š 19â”Š      this.rad1 = Utils.trim(rad1, 9, \"ceil\");\n+â”Š   â”Š 20â”Š      this.rad2 = Utils.trim(rad2, 9, \"floor\");\n+â”Š   â”Š 21â”Š    }\n+â”Š   â”Š 22â”Š  }\n+â”Š   â”Š 23â”Š\n+â”Š   â”Š 24â”Š  // Draws the circle on the given context\n+â”Š   â”Š 25â”Š  draw(context) {\n+â”Š   â”Š 26â”Š    context.arc(this.x, this.y, this.r, this.rad1, this.rad2);\n+â”Š   â”Š 27â”Š  }\n+â”Š   â”Š 28â”Š\n+â”Š   â”Š 29â”Š  // Gets the matching x value for the given radian\n+â”Š   â”Š 30â”Š  getX(rad) {\n+â”Š   â”Š 31â”Š    if (!Utils(rad).trim(9).isBetween(this.rad1, this.rad2).value()) return;\n+â”Š   â”Š 32â”Š    return Utils.trim((this.r * Math.cos(rad)) + this.x, 9);\n+â”Š   â”Š 33â”Š  }\n+â”Š   â”Š 34â”Š\n+â”Š   â”Š 35â”Š  // Gets the matching y value for the given radian\n+â”Š   â”Š 36â”Š  getY(rad) {\n+â”Š   â”Š 37â”Š    if (!Utils(rad).trim(9).isBetween(this.rad1, this.rad2).value()) return;\n+â”Š   â”Š 38â”Š    return Utils.trim((this.r * Math.sin(rad)) + this.y, 9);\n+â”Š   â”Š 39â”Š  }\n+â”Š   â”Š 40â”Š\n+â”Š   â”Š 41â”Š  // Gets the matching point for the given radian\n+â”Š   â”Š 42â”Š  getPoint(rad) {\n+â”Š   â”Š 43â”Š    if (!Utils.isBetween(rad, this.rad1, this.rad2)) return;\n+â”Š   â”Š 44â”Š\n+â”Š   â”Š 45â”Š    return {\n+â”Š   â”Š 46â”Š      x: Utils.trim((this.r * Math.cos(rad)) + this.x, 9),\n+â”Š   â”Š 47â”Š      y: Utils.trim((this.r * Math.sin(rad)) + this.y, 9)\n+â”Š   â”Š 48â”Š    };\n+â”Š   â”Š 49â”Š  }\n+â”Š   â”Š 50â”Š\n+â”Š   â”Š 51â”Š  // Gets the matching radian for the given point\n+â”Š   â”Š 52â”Š  getRad(x, y) {\n+â”Š   â”Š 53â”Š    let rad = Math.atan2(y - this.y, x - this.x);\n+â”Š   â”Š 54â”Š\n+â”Š   â”Š 55â”Š    // If calculated radian is in circle's radian range, return it\n+â”Š   â”Š 56â”Š    if (rad != null && Utils.isBetween(rad, this.rad1, this.rad2)) {\n+â”Š   â”Š 57â”Š      return rad;\n+â”Š   â”Š 58â”Š    }\n+â”Š   â”Š 59â”Š\n+â”Š   â”Š 60â”Š    // The calculated radian can still be in the circle's radian range in case one\n+â”Š   â”Š 61â”Š    // of the radians is greater than 2 PIEs\n+â”Š   â”Š 62â”Š    if (Math.abs(this.rad1) > Math.abs(this.rad2)) {\n+â”Š   â”Š 63â”Š      var greatestRad = this.rad1;\n+â”Š   â”Š 64â”Š    }\n+â”Š   â”Š 65â”Š    else {\n+â”Š   â”Š 66â”Š      var greatestRad = this.rad2;\n+â”Š   â”Š 67â”Š    }\n+â”Š   â”Š 68â”Š\n+â”Š   â”Š 69â”Š    // Check if the absolute radian is in the circle's radian range\n+â”Š   â”Š 70â”Š    if (Utils(rad + (2 * Math.PI * Math.floor(greatestRad / (2 * Math.PI)))).trim(9).isBetween(this.rad1, this.rad2).value() ||\n+â”Š   â”Š 71â”Š        Utils(rad + (2 * Math.PI * Math.ceil(greatestRad / (2 * Math.PI)))).trim(9).isBetween(this.rad1, this.rad2).value()) {\n+â”Š   â”Š 72â”Š      return rad;\n+â”Š   â”Š 73â”Š    }\n+â”Š   â”Š 74â”Š  }\n+â”Š   â”Š 75â”Š\n+â”Š   â”Š 76â”Š  // Returns if circle has given points\n+â”Š   â”Š 77â”Š  hasPoint(x, y) {\n+â”Š   â”Š 78â”Š    return this.getRad(x, y) != null;\n+â”Š   â”Š 79â”Š  }\n+â”Š   â”Š 80â”Š\n+â”Š   â”Š 81â”Š  getIntersection(shape) {\n+â”Š   â”Š 82â”Š    if (shape instanceof Engine.Geometry.Line)\n+â”Š   â”Š 83â”Š      return this.getLineIntersection(shape);\n+â”Š   â”Š 84â”Š    if (shape instanceof Engine.Geometry.Circle)\n+â”Š   â”Š 85â”Š      return this.getCircleIntersection(shape);\n+â”Š   â”Š 86â”Š  }\n+â”Š   â”Š 87â”Š\n+â”Š   â”Š 88â”Š  // circle - circle intersection method\n+â”Š   â”Š 89â”Š  getCircleIntersection(circle) {\n+â”Š   â”Š 90â”Š    let dx = circle.x - this.x;\n+â”Š   â”Š 91â”Š    let dy = circle.y - this.y;\n+â”Š   â”Š 92â”Š    let d = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\n+â”Š   â”Š 93â”Š\n+â”Š   â”Š 94â”Š    if (d > this.r + circle.r ||\n+â”Š   â”Š 95â”Š       d < Math.abs(this.r - circle.r)) {\n+â”Š   â”Š 96â”Š      return;\n+â”Š   â”Š 97â”Š    }\n+â”Š   â”Š 98â”Š\n+â”Š   â”Š 99â”Š    let a = ((Math.pow(this.r, 2) - Math.pow(circle.r, 2)) + Math.pow(d, 2)) / (2 * d);\n+â”Š   â”Š100â”Š    let x = this.x + ((dx * a) / d);\n+â”Š   â”Š101â”Š    let y = this.y + ((dy * a) / d);\n+â”Š   â”Š102â”Š    let h = Math.sqrt(Math.pow(this.r, 2) - Math.pow(a, 2));\n+â”Š   â”Š103â”Š    let rx = (- dy * h) / d;\n+â”Š   â”Š104â”Š    let ry = (dx * h) / d;\n+â”Š   â”Š105â”Š\n+â”Š   â”Š106â”Š    let interPoints = [\n+â”Š   â”Š107â”Š      {\n+â”Š   â”Š108â”Š        x: x + rx,\n+â”Š   â”Š109â”Š        y: y + ry\n+â”Š   â”Š110â”Š      },\n+â”Š   â”Š111â”Š      {\n+â”Š   â”Š112â”Š        x: x - rx,\n+â”Š   â”Š113â”Š        y: y - ry\n+â”Š   â”Š114â”Š      }\n+â”Š   â”Š115â”Š    ]\n+â”Š   â”Š116â”Š    .map(point => ({\n+â”Š   â”Š117â”Š        x: Utils.trim(point.x, 9),\n+â”Š   â”Š118â”Š        y: Utils.trim(point.y, 9)\n+â”Š   â”Š119â”Š     }));\n+â”Š   â”Š120â”Š\n+â”Š   â”Š121â”Š    interPoints = _.uniq(interPoints, point => `(${point.x}, ${point.y})`);\n+â”Š   â”Š122â”Š\n+â”Š   â”Š123â”Š    [this, circle].forEach(function(circle) {\n+â”Š   â”Š124â”Š      interPoints = interPoints.filter(point => circle.hasPoint(point.x, point.y));\n+â”Š   â”Š125â”Š    });\n+â”Š   â”Š126â”Š\n+â”Š   â”Š127â”Š    if (interPoints.length > 0) return interPoints;\n+â”Š   â”Š128â”Š  }\n+â”Š   â”Š129â”Š\n+â”Š   â”Š130â”Š  // circle - line intersection method\n+â”Š   â”Š131â”Š  getLineIntersection(line) {\n+â”Š   â”Š132â”Š    let x1 = line.x1 - this.x;\n+â”Š   â”Š133â”Š    let x2 = line.x2 - this.x;\n+â”Š   â”Š134â”Š    let y1 = line.y1 - this.y;\n+â”Š   â”Š135â”Š    let y2 = line.y2 - this.y;\n+â”Š   â”Š136â”Š    let dx = x2 - x1;\n+â”Š   â”Š137â”Š    let dy = y2 - y1;\n+â”Š   â”Š138â”Š    let d = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\n+â”Š   â”Š139â”Š    let h = (x1 * y2) - (x2 * y1);\n+â”Š   â”Š140â”Š    let delta = (Math.pow(this.r, 2) * Math.pow(d, 2)) - Math.pow(h, 2);\n+â”Š   â”Š141â”Š\n+â”Š   â”Š142â”Š    if (delta < 0) return;\n+â”Š   â”Š143â”Š\n+â”Š   â”Š144â”Š    let interPoints = [\n+â”Š   â”Š145â”Š      {\n+â”Š   â”Š146â”Š        x: (((h * dy) + (((dy / Math.abs(dy)) || 1) * dx * Math.sqrt(delta))) / Math.pow(d, 2)) + this.x,\n+â”Š   â”Š147â”Š        y: (((-h * dx) + (Math.abs(dy) * Math.sqrt(delta))) / Math.pow(d, 2)) + this.y\n+â”Š   â”Š148â”Š      },\n+â”Š   â”Š149â”Š      {\n+â”Š   â”Š150â”Š        x: (((h * dy) - (((dy / Math.abs(dy)) || 1) * dx * Math.sqrt(delta))) / Math.pow(d, 2)) + this.x,\n+â”Š   â”Š151â”Š        y: (((-h * dx) - (Math.abs(dy) * Math.sqrt(delta))) / Math.pow(d, 2)) + this.y\n+â”Š   â”Š152â”Š      }\n+â”Š   â”Š153â”Š    ]\n+â”Š   â”Š154â”Š    .map(point => ({\n+â”Š   â”Š155â”Š        x: Utils.trim(point.x, 9),\n+â”Š   â”Š156â”Š        y: Utils.trim(point.y, 9)\n+â”Š   â”Š157â”Š    }))\n+â”Š   â”Š158â”Š    .filter(point => {\n+â”Š   â”Š159â”Š      return this.hasPoint(point.x, point.y) &&\n+â”Š   â”Š160â”Š        line.boundsHavePoint(point.x, point.y);\n+â”Š   â”Š161â”Š    });\n+â”Š   â”Š162â”Š\n+â”Š   â”Š163â”Š    interPoints = _.uniq(interPoints, point => `(${point.x}, ${point.y})`);\n+â”Š   â”Š164â”Š\n+â”Š   â”Š165â”Š    if (interPoints.length > 0) return interPoints;\n+â”Š   â”Š166â”Š  }\n+â”Š   â”Š167â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -11,6 +11,7 @@\n â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/utils.js\"></script>\n â”Š12â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n â”Š13â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/geometry/line.js\"></script>\n+â”Š  â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/geometry/circle.js\"></script>\n â”Š14â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/restorable.js\"></script>\n â”Š15â”Š16â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/font.js\"></script>\n â”Š16â”Š17â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/sprite.js\"></script>\n```\n\n[}]: #\n\nJust like a line, a circle can be presented using variables as well. The center of the circle is represented as `(x, y)` and its radius is represented as `r`. Remember that our circle doesn't necessarily have to be a full one, therefore we limit its range using two radians - `rad1` and `rad2`. The formula for representing a circle in a 2D space looks like this:\n\n![circle-formula](https://cloud.githubusercontent.com/assets/7648874/21829783/84a54574-d77f-11e6-9b87-3fb0f073bb8d.png)\n\n![circle-circle-illustration](https://cloud.githubusercontent.com/assets/7648874/21790842/3a73408c-d6c6-11e6-8bdd-9c73355e6ebb.png)\n\n> `a` and `b` represent the offsets from the `x` and the `y` axes respectively.\n> See reference: http://mathworld.wolfram.com/Circle-CircleIntersection.html.\n\nTo find intersection between two circles, we simply calculate the solution for two equations with two variables. Given that a line can be represented in a 2D space using the following formula:\n\n![line-formula](https://cloud.githubusercontent.com/assets/7648874/21790671/1609c050-d6c5-11e6-8bd7-16cc306f5eea.png)\n\n![circle-line-illustration](https://cloud.githubusercontent.com/assets/7648874/21790810/1a052086-d6c6-11e6-9c5c-24298fedb043.png)\n\n> `n` represents the intersection value with the `y` axis.\n> See reference: http://mathworld.wolfram.com/Circle-LineIntersection.html.\n\nwe can find the intersection between a circle and line by solving the systems formed by the equations of both. We also want the line-circle algorithm to be available for any `Line` instance, therefore we gonna add the following delegate on the `Line` prototype:\n\n[{]: <helper> (diffStep 5.8)\n\n#### [Step 5.8: Delegate circle intersection methods](https://github.com/DAB0mB/radial-snake/commit/19828bf)\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;geometry&#x2F;line.js\n```diff\n@@ -44,6 +44,8 @@\n â”Š44â”Š44â”Š  getIntersection(shape) {\n â”Š45â”Š45â”Š    if (shape instanceof Engine.Geometry.Line)\n â”Š46â”Š46â”Š      return this.getLineIntersection(shape);\n+â”Š  â”Š47â”Š    if (shape instanceof Engine.Geometry.Circle)\n+â”Š  â”Š48â”Š      return this.getCircleIntersection(shape);\n â”Š47â”Š49â”Š  }\n â”Š48â”Š50â”Š\n â”Š49â”Š51â”Š  // line - line intersection method\n```\n```diff\n@@ -62,4 +64,9 @@\n â”Š62â”Š64â”Š      return { x, y };\n â”Š63â”Š65â”Š    }\n â”Š64â”Š66â”Š  }\n+â”Š  â”Š67â”Š\n+â”Š  â”Š68â”Š  // line - circle intersection method\n+â”Š  â”Š69â”Š  getCircleIntersection(circle) {\n+â”Š  â”Š70â”Š    return circle.getLineIntersection(this);\n+â”Š  â”Š71â”Š  }\n â”Š65â”Š72â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nThen again a newly created geometry shape class should be tested against different scenarios:\n\n[{]: <helper> (diffStep 5.9)\n\n#### [Step 5.9: Create &#x27;Circle&#x27; class tests](https://github.com/DAB0mB/radial-snake/commit/1d98a6e)\n\n##### Added resources&#x2F;scripts&#x2F;specs&#x2F;engine&#x2F;geometry&#x2F;circle.js\n```diff\n@@ -0,0 +1,144 @@\n+â”Š   â”Š  1â”Šdescribe(\"Engine.Geometry.Circle class\", function() {\n+â”Š   â”Š  2â”Š  beforeEach(function() {\n+â”Š   â”Š  3â”Š    this.circle = new Engine.Geometry.Circle(1, 1, 5, 0, 1.5 * Math.PI);\n+â”Š   â”Š  4â”Š  });\n+â”Š   â”Š  5â”Š\n+â”Š   â”Š  6â”Š  describe(\"getX method\", function() {\n+â”Š   â”Š  7â”Š    describe(\"given inranged rad\", function() {\n+â”Š   â”Š  8â”Š      it(\"returns x\", function() {\n+â”Š   â”Š  9â”Š        expect(this.circle.getX(0 * Math.PI)).toBeCloseTo(6);\n+â”Š   â”Š 10â”Š        expect(this.circle.getX(0.5 * Math.PI)).toBeCloseTo(1);\n+â”Š   â”Š 11â”Š        expect(this.circle.getX(1 * Math.PI)).toBeCloseTo(-4);\n+â”Š   â”Š 12â”Š        expect(this.circle.getX(1.5 * Math.PI)).toBeCloseTo(1);\n+â”Š   â”Š 13â”Š      });\n+â”Š   â”Š 14â”Š    });\n+â”Š   â”Š 15â”Š\n+â”Š   â”Š 16â”Š    describe(\"given outranged rad\", function() {\n+â”Š   â”Š 17â”Š      it(\"returns nothing\", function() {\n+â”Š   â”Š 18â”Š        expect(this.circle.getX(2 * Math.PI)).toBeUndefined();\n+â”Š   â”Š 19â”Š      });\n+â”Š   â”Š 20â”Š    });\n+â”Š   â”Š 21â”Š  });\n+â”Š   â”Š 22â”Š\n+â”Š   â”Š 23â”Š  describe(\"getY method\", function() {\n+â”Š   â”Š 24â”Š    describe(\"given inranged rad\", function() {\n+â”Š   â”Š 25â”Š      it(\"returns y\", function() {\n+â”Š   â”Š 26â”Š        expect(this.circle.getY(0 * Math.PI)).toBeCloseTo(1);\n+â”Š   â”Š 27â”Š        expect(this.circle.getY(0.5 * Math.PI)).toBeCloseTo(6);\n+â”Š   â”Š 28â”Š        expect(this.circle.getY(1 * Math.PI)).toBeCloseTo(1);\n+â”Š   â”Š 29â”Š        expect(this.circle.getY(1.5 * Math.PI)).toBeCloseTo(-4);\n+â”Š   â”Š 30â”Š      });\n+â”Š   â”Š 31â”Š    });\n+â”Š   â”Š 32â”Š\n+â”Š   â”Š 33â”Š    describe(\"given outranged rad\", function() {\n+â”Š   â”Š 34â”Š      it(\"returns nothing\", function() {\n+â”Š   â”Š 35â”Š        expect(this.circle.getY(2 * Math.PI)).toBeUndefined();\n+â”Š   â”Š 36â”Š      });\n+â”Š   â”Š 37â”Š    });\n+â”Š   â”Š 38â”Š  });\n+â”Š   â”Š 39â”Š\n+â”Š   â”Š 40â”Š  describe(\"getRad method\", function() {\n+â”Š   â”Š 41â”Š    describe(\"given inranged point\", function() {\n+â”Š   â”Š 42â”Š      it(\"returns rad\", function() {\n+â”Š   â”Š 43â”Š        let x = -3.0450849718747346;\n+â”Š   â”Š 44â”Š        let y = 3.9389262614623686;\n+â”Š   â”Š 45â”Š        expect(this.circle.getRad(x, y)).toBeCloseTo(0.8 * Math.PI);\n+â”Š   â”Š 46â”Š      });\n+â”Š   â”Š 47â”Š    });\n+â”Š   â”Š 48â”Š\n+â”Š   â”Š 49â”Š    describe(\"given outranged point\", function() {\n+â”Š   â”Š 50â”Š      it(\"returns nothing\", function() {\n+â”Š   â”Š 51â”Š        let x = 5.045084971874736;\n+â”Š   â”Š 52â”Š        let y = -1.9389262614623664;\n+â”Š   â”Š 53â”Š        expect(this.circle.getRad(x, y)).toBeUndefined();\n+â”Š   â”Š 54â”Š      });\n+â”Š   â”Š 55â”Š    });\n+â”Š   â”Š 56â”Š  });\n+â”Š   â”Š 57â”Š\n+â”Š   â”Š 58â”Š  describe(\"getCircleIntersection method\", function() {\n+â”Š   â”Š 59â”Š    describe(\"given circle with 2 intersection points\", function() {\n+â”Š   â”Š 60â”Š      it(\"returns array with intersection points\", function() {\n+â”Š   â”Š 61â”Š        let circle = new Engine.Geometry.Circle(-5, 1, 5, 0, 2 * Math.PI);\n+â”Š   â”Š 62â”Š\n+â”Š   â”Š 63â”Š        expect(this.circle.getCircleIntersection(circle)).toEqual([\n+â”Š   â”Š 64â”Š          { x: -2, y: -3 },\n+â”Š   â”Š 65â”Š          { x: -2, y: 5 }\n+â”Š   â”Š 66â”Š        ]);\n+â”Š   â”Š 67â”Š      });\n+â”Š   â”Š 68â”Š    });\n+â”Š   â”Š 69â”Š\n+â”Š   â”Š 70â”Š    describe(\"given circle with 1 intersection points\", function() {\n+â”Š   â”Š 71â”Š      it(\"returns array with intersection point\", function() {\n+â”Š   â”Š 72â”Š        let circle = new Engine.Geometry.Circle(-5, 1, 5, 0, 1 * Math.PI);\n+â”Š   â”Š 73â”Š\n+â”Š   â”Š 74â”Š        expect(this.circle.getCircleIntersection(circle)).toEqual([\n+â”Š   â”Š 75â”Š          { x: -2, y: 5 }\n+â”Š   â”Š 76â”Š        ]);\n+â”Š   â”Š 77â”Š      });\n+â”Š   â”Š 78â”Š    });\n+â”Š   â”Š 79â”Š\n+â”Š   â”Š 80â”Š    describe(\"given kissing circle\", function() {\n+â”Š   â”Š 81â”Š      it(\"returns array with intersection point\", function() {\n+â”Š   â”Š 82â”Š        let circle = new Engine.Geometry.Circle(-9, 1, 5, 0, 2 * Math.PI);\n+â”Š   â”Š 83â”Š\n+â”Š   â”Š 84â”Š        expect(this.circle.getCircleIntersection(circle)).toEqual([\n+â”Š   â”Š 85â”Š          { x: -4, y: 1 }\n+â”Š   â”Š 86â”Š        ]);\n+â”Š   â”Š 87â”Š      });\n+â”Š   â”Š 88â”Š    });\n+â”Š   â”Š 89â”Š\n+â”Š   â”Š 90â”Š    describe(\"given outer circle\", function() {\n+â”Š   â”Š 91â”Š      it(\"returns nothing\", function() {\n+â”Š   â”Š 92â”Š        let circle = new Engine.Geometry.Circle(10, 10, 2, 0, 2 * Math.PI);\n+â”Š   â”Š 93â”Š        expect(this.circle.getCircleIntersection(circle)).toBeUndefined();\n+â”Š   â”Š 94â”Š      });\n+â”Š   â”Š 95â”Š    });\n+â”Š   â”Š 96â”Š\n+â”Š   â”Š 97â”Š    describe(\"given inner circle\", function() {\n+â”Š   â”Š 98â”Š      it(\"nothing\", function() {\n+â”Š   â”Š 99â”Š        let circle = new Engine.Geometry.Circle(1, 1, 2, 0, 2 * Math.PI);\n+â”Š   â”Š100â”Š        expect(this.circle.getCircleIntersection(circle)).toBeUndefined();\n+â”Š   â”Š101â”Š      });\n+â”Š   â”Š102â”Š    });\n+â”Š   â”Š103â”Š  });\n+â”Š   â”Š104â”Š\n+â”Š   â”Š105â”Š  describe(\"getLineIntersection method\", function() {\n+â”Š   â”Š106â”Š    describe(\"given line with 2 intersection points\", function() {\n+â”Š   â”Š107â”Š      it(\"returns array with intersection points\", function() {\n+â”Š   â”Š108â”Š        let line = new Engine.Geometry.Line(-10, 1, 10, 1);\n+â”Š   â”Š109â”Š\n+â”Š   â”Š110â”Š        expect(this.circle.getLineIntersection(line)).toEqual([\n+â”Š   â”Š111â”Š          { x: 6, y: 1 },\n+â”Š   â”Š112â”Š          { x: -4, y: 1 }\n+â”Š   â”Š113â”Š        ]);\n+â”Š   â”Š114â”Š      });\n+â”Š   â”Š115â”Š    });\n+â”Š   â”Š116â”Š\n+â”Š   â”Š117â”Š    describe(\"given line with 1 intersection point\", function() {\n+â”Š   â”Š118â”Š      it(\"returns array with intersection point\", function() {\n+â”Š   â”Š119â”Š        let line = new Engine.Geometry.Line(-10, 1, 1, 1);\n+â”Š   â”Š120â”Š\n+â”Š   â”Š121â”Š        expect(this.circle.getLineIntersection(line)).toEqual([\n+â”Š   â”Š122â”Š          { x: -4, y: 1 }\n+â”Š   â”Š123â”Š        ]);\n+â”Š   â”Š124â”Š      });\n+â”Š   â”Š125â”Š    });\n+â”Š   â”Š126â”Š\n+â”Š   â”Š127â”Š    describe(\"given kissing line\", function() {\n+â”Š   â”Š128â”Š      it(\"returns array with intersection point\", function() {\n+â”Š   â”Š129â”Š        let line = new Engine.Geometry.Line(-10, 6, 10, 6);\n+â”Š   â”Š130â”Š\n+â”Š   â”Š131â”Š        expect(this.circle.getLineIntersection(line)).toEqual([\n+â”Š   â”Š132â”Š          { x: 1, y: 6 }\n+â”Š   â”Š133â”Š        ]);\n+â”Š   â”Š134â”Š      });\n+â”Š   â”Š135â”Š    });\n+â”Š   â”Š136â”Š\n+â”Š   â”Š137â”Š    describe(\"given outranged line\", function() {\n+â”Š   â”Š138â”Š      it(\"returns nothing\", function() {\n+â”Š   â”Š139â”Š        let line = new Engine.Geometry.Line(-10, 10, 10, 10);\n+â”Š   â”Š140â”Š        expect(this.circle.getLineIntersection(line)).toBeUndefined();\n+â”Š   â”Š141â”Š      });\n+â”Š   â”Š142â”Š    });\n+â”Š   â”Š143â”Š  });\n+â”Š   â”Š144â”Š});ðŸš«â†µ\n```\n\n##### Changed views&#x2F;spec_runner.html\n```diff\n@@ -19,9 +19,11 @@\n â”Š19â”Š19â”Š    <script type=\"text/javascript\" src=\"scripts/utils.js\"></script>\n â”Š20â”Š20â”Š    <script type=\"text/javascript\" src=\"scripts/namespaces.js\"></script>\n â”Š21â”Š21â”Š    <script type=\"text/javascript\" src=\"scripts/engine/geometry/line.js\"></script>\n+â”Š  â”Š22â”Š    <script type=\"text/javascript\" src=\"scripts/engine/geometry/circle.js\"></script>\n â”Š22â”Š23â”Š\n â”Š23â”Š24â”Š    <!-- Specs -->\n â”Š24â”Š25â”Š    <script type=\"text/javascript\" src=\"scripts/specs/engine/geometry/line.js\"></script>\n+â”Š  â”Š26â”Š    <script type=\"text/javascript\" src=\"scripts/specs/engine/geometry/circle.js\"></script>\n â”Š25â”Š27â”Š  </head>\n â”Š26â”Š28â”Š\n â”Š27â”Š29â”Š  <body>\n```\n\n[}]: #\n\nOur final shape in the geometry module would be a polygon. Why a polygon? Since I'm planning to make the snake's movement circular, which means that once the snake hits a random boundary, he will reappear from the other side of the canvas. The collision detection between the snake and the canvas would be done using a polygon - which is simply made out of 4 lines:\n\n[{]: <helper> (diffStep 5.1)\n\n#### [Step 5.1: Create utilities module](https://github.com/DAB0mB/radial-snake/commit/58ae99a)\n\n##### Added resources&#x2F;scripts&#x2F;utils.js\n```diff\n@@ -0,0 +1,68 @@\n+â”Š  â”Š 1â”Š// A wrapper function for our utilities which will enable chaining\n+â”Š  â”Š 2â”Š// e.g. Utils().mod().trim().isBetween()...\n+â”Š  â”Š 3â”ŠUtils = function Utils(context) {\n+â”Š  â”Š 4â”Š  const chain = {};\n+â”Š  â”Š 5â”Š\n+â”Š  â”Š 6â”Š  Object.keys(Utils).forEach((utilName) => {\n+â”Š  â”Š 7â”Š    chain[utilName] = (...args) => {\n+â”Š  â”Š 8â”Š      const result = Utils[utilName](context, ...args);\n+â”Š  â”Š 9â”Š      return Utils(result);\n+â”Š  â”Š10â”Š    };\n+â”Š  â”Š11â”Š  });\n+â”Š  â”Š12â”Š\n+â”Š  â”Š13â”Š  // Returns the result of the chaining\n+â”Š  â”Š14â”Š  chain.value = () => context;\n+â”Š  â”Š15â”Š\n+â”Š  â”Š16â”Š  return chain;\n+â”Š  â”Š17â”Š};\n+â”Š  â”Š18â”Š\n+â”Š  â”Š19â”Š// Fixed modulo method which can calculate modulo of negative numbers properly\n+â”Š  â”Š20â”Š// e.g. (-803).mod(800) returns 797\n+â”Š  â”Š21â”ŠUtils.mod = function (context, num) {\n+â”Š  â”Š22â”Š  return ((context % num) + num) % num;\n+â”Š  â”Š23â”Š};\n+â”Š  â”Š24â”Š\n+â”Š  â”Š25â”Š// Trims number and leaves the number of decimals specified.\n+â”Š  â”Š26â”Š// The \"mode\" argument specifies which math function should be invoked\n+â”Š  â”Š27â”Š// right after the number has been trimmed.\n+â”Š  â”Š28â”Š// e.g. 12.12345.trim(3, \"ceil\") returns 12.124\n+â”Š  â”Š29â”ŠUtils.trim = function (context, decimals, mode = \"round\") {\n+â”Š  â”Š30â”Š  return Math[mode](context * Math.pow(10, decimals)) / Math.pow(10, decimals);\n+â”Š  â”Š31â”Š};\n+â”Š  â”Š32â”Š\n+â”Š  â”Š33â”Š// Tells if number is in specified range based on given precision.\n+â”Š  â”Š34â”Š// See the \"compare\" method for more information about precision\n+â”Š  â”Š35â”ŠUtils.isBetween = function (context, num1, num2, precision) {\n+â”Š  â”Š36â”Š  return Utils.compare(context, Math.min(num1, num2), \">=\", precision) &&\n+â”Š  â”Š37â”Š         Utils.compare(context, Math.max(num1, num2), \"<=\", precision);\n+â”Š  â”Š38â”Š};\n+â”Š  â”Š39â”Š\n+â”Š  â”Š40â”Š// Initiates comparison operator between context number and a given number, only here\n+â”Š  â”Š41â”Š// a precision can be specified\n+â”Š  â”Š42â”ŠUtils.compare = function (context, num, method, precision = method) {\n+â”Š  â”Š43â”Š  switch (precision) {\n+â”Š  â”Š44â”Š    // Fixed precision, \"almost equal\" with a deviation of Îµ\n+â”Š  â”Š45â”Š    case \"f\":\n+â”Š  â”Š46â”Š      switch (method) {\n+â”Š  â”Š47â”Š        case \"<\": case \"<=\": return context <= num + Number.EPSILON;\n+â”Š  â”Š48â”Š        case \">\": case \">=\": return context >= num - Number.EPSILON;\n+â”Š  â”Š49â”Š        default: return Math.abs(context - num) <= Number.EPSILON;\n+â”Š  â”Š50â”Š      }\n+â”Š  â”Š51â”Š    // Pixel precision, round comparison\n+â”Š  â”Š52â”Š    case \"px\":\n+â”Š  â”Š53â”Š      switch (method) {\n+â”Š  â”Š54â”Š        case \"<\": case \"<=\": return Math.round(context) <= Math.round(num);\n+â”Š  â”Š55â”Š        case \">\": case \">=\": return Math.round(context) >= Math.round(num);\n+â”Š  â”Š56â”Š        default: return Math.round(context) == Math.round(num);\n+â”Š  â”Š57â”Š      }\n+â”Š  â”Š58â”Š    // Exact precision\n+â”Š  â”Š59â”Š    default:\n+â”Š  â”Š60â”Š      switch (method) {\n+â”Š  â”Š61â”Š        case \"<\": return context < num;\n+â”Š  â”Š62â”Š        case \"<=\": return context <= num;\n+â”Š  â”Š63â”Š        case \">\": return context > num;\n+â”Š  â”Š64â”Š        case \">=\": return context >= num;\n+â”Š  â”Š65â”Š        default: return context === num;\n+â”Š  â”Š66â”Š      }\n+â”Š  â”Š67â”Š  }\n+â”Š  â”Š68â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -8,6 +8,7 @@\n â”Š 8â”Š 8â”Š    <script type=\"text/javascript\" src=\"/libs/underscore.js\"></script>\n â”Š 9â”Š 9â”Š\n â”Š10â”Š10â”Š    <!-- Scripts -->\n+â”Š  â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/utils.js\"></script>\n â”Š11â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n â”Š12â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/restorable.js\"></script>\n â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/font.js\"></script>\n```\n\n[}]: #\n\nAgain we will delegate the newly created intersection methods in the `Line` class and `Circle` class:\n\n[{]: <helper> (diffStep 5.11)\n\n#### [Step 5.11: Delegate polygon intersection methods](https://github.com/DAB0mB/radial-snake/commit/d42a5d9)\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;geometry&#x2F;circle.js\n```diff\n@@ -83,6 +83,8 @@\n â”Š83â”Š83â”Š      return this.getLineIntersection(shape);\n â”Š84â”Š84â”Š    if (shape instanceof Engine.Geometry.Circle)\n â”Š85â”Š85â”Š      return this.getCircleIntersection(shape);\n+â”Š  â”Š86â”Š    if (shape instanceof Engine.Geometry.Polygon)\n+â”Š  â”Š87â”Š      return this.getPolygonIntersection(shape);\n â”Š86â”Š88â”Š  }\n â”Š87â”Š89â”Š\n â”Š88â”Š90â”Š  // circle - circle intersection method\n```\n```diff\n@@ -164,4 +166,9 @@\n â”Š164â”Š166â”Š\n â”Š165â”Š167â”Š    if (interPoints.length > 0) return interPoints;\n â”Š166â”Š168â”Š  }\n+â”Š   â”Š169â”Š\n+â”Š   â”Š170â”Š  // circle - polygon intersection method\n+â”Š   â”Š171â”Š  getPolygonIntersection(polygon) {\n+â”Š   â”Š172â”Š    return polygon.getCircleIntersection(this);\n+â”Š   â”Š173â”Š  }\n â”Š167â”Š174â”Š};ðŸš«â†µ\n```\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;geometry&#x2F;line.js\n```diff\n@@ -46,6 +46,8 @@\n â”Š46â”Š46â”Š      return this.getLineIntersection(shape);\n â”Š47â”Š47â”Š    if (shape instanceof Engine.Geometry.Circle)\n â”Š48â”Š48â”Š      return this.getCircleIntersection(shape);\n+â”Š  â”Š49â”Š    if (shape instanceof Engine.Geometry.Polygon)\n+â”Š  â”Š50â”Š      return this.getPolygonIntersection(shape);\n â”Š49â”Š51â”Š  }\n â”Š50â”Š52â”Š\n â”Š51â”Š53â”Š  // line - line intersection method\n```\n```diff\n@@ -69,4 +71,9 @@\n â”Š69â”Š71â”Š  getCircleIntersection(circle) {\n â”Š70â”Š72â”Š    return circle.getLineIntersection(this);\n â”Š71â”Š73â”Š  }\n+â”Š  â”Š74â”Š\n+â”Š  â”Š75â”Š  // line - polygon intersection method\n+â”Š  â”Š76â”Š  getPolygonIntersection(polygon) {\n+â”Š  â”Š77â”Š    return polygon.getLineIntersection(this);\n+â”Š  â”Š78â”Š  }\n â”Š72â”Š79â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nNow we will create a some tests to make sure our newly created polygon works properly:\n\n[{]: <helper> (diffStep 5.12)\n\n#### [Step 5.12: Create &#x27;Polygon&#x27; class tests](https://github.com/DAB0mB/radial-snake/commit/f3f890b)\n\n##### Added resources&#x2F;scripts&#x2F;specs&#x2F;engine&#x2F;geometry&#x2F;polygon.js\n```diff\n@@ -0,0 +1,96 @@\n+â”Š  â”Š 1â”Šdescribe(\"Engine.Geometry.Polygon class\", function() {\n+â”Š  â”Š 2â”Š  beforeEach(function() {\n+â”Š  â”Š 3â”Š    this.polygon = new Engine.Geometry.Polygon(\n+â”Š  â”Š 4â”Š      [0, 0, 5, 0],\n+â”Š  â”Š 5â”Š      [5, 0, 5, 5],\n+â”Š  â”Š 6â”Š      [5, 5, 0, 5],\n+â”Š  â”Š 7â”Š      [0, 5, 0, 0]\n+â”Š  â”Š 8â”Š    );\n+â”Š  â”Š 9â”Š  });\n+â”Š  â”Š10â”Š\n+â”Š  â”Š11â”Š  describe(\"hasPoint method\", function() {\n+â”Š  â”Š12â”Š    describe(\"given contained point\", function() {\n+â”Š  â”Š13â”Š      it(\"returns true\", function() {\n+â”Š  â”Š14â”Š        let x = 5;\n+â”Š  â”Š15â”Š        let y = 3;\n+â”Š  â”Š16â”Š        expect(this.polygon.hasPoint(x, y)).toBeTruthy();\n+â”Š  â”Š17â”Š      });\n+â”Š  â”Š18â”Š    });\n+â”Š  â”Š19â”Š\n+â”Š  â”Š20â”Š    describe(\"given outranged point\", function() {\n+â”Š  â”Š21â”Š      it(\"returns false\", function() {\n+â”Š  â”Š22â”Š        let x = 10;\n+â”Š  â”Š23â”Š        let y = 10;\n+â”Š  â”Š24â”Š        expect(this.polygon.hasPoint(x, y)).toBeFalsy();\n+â”Š  â”Š25â”Š      });\n+â”Š  â”Š26â”Š    });\n+â”Š  â”Š27â”Š  });\n+â”Š  â”Š28â”Š\n+â”Š  â”Š29â”Š  describe(\"getLineIntersection method\", function() {\n+â”Š  â”Š30â”Š    describe(\"given intersecting line\", function() {\n+â”Š  â”Š31â”Š      it(\"returns intersection point\", function() {\n+â”Š  â”Š32â”Š        let line = new Engine.Geometry.Line(0, 1, 5, 4);\n+â”Š  â”Š33â”Š\n+â”Š  â”Š34â”Š        expect(this.polygon.getLineIntersection(line)).toEqual([\n+â”Š  â”Š35â”Š          { x: 5, y: 4 },\n+â”Š  â”Š36â”Š          { x: 0, y: 1 }\n+â”Š  â”Š37â”Š        ]);\n+â”Š  â”Š38â”Š      });\n+â”Š  â”Š39â”Š    });\n+â”Š  â”Š40â”Š\n+â”Š  â”Š41â”Š    describe(\"given outranged line\", function() {\n+â”Š  â”Š42â”Š      it(\"returns nothing\", function() {\n+â”Š  â”Š43â”Š        let line = new Engine.Geometry.Line(10, 11, 15, 14);\n+â”Š  â”Š44â”Š\n+â”Š  â”Š45â”Š        expect(this.polygon.getLineIntersection(line)).toBeUndefined();\n+â”Š  â”Š46â”Š      });\n+â”Š  â”Š47â”Š    });\n+â”Š  â”Š48â”Š  });\n+â”Š  â”Š49â”Š\n+â”Š  â”Š50â”Š  describe(\"getCircleIntersection method\", function() {\n+â”Š  â”Š51â”Š    describe(\"given circle with 2 intersection points\", function() {\n+â”Š  â”Š52â”Š      it(\"returns array with intersection points\", function() {\n+â”Š  â”Š53â”Š        let circle = new Engine.Geometry.Circle(0, 0, 2, 0, 2 * Math.PI);\n+â”Š  â”Š54â”Š\n+â”Š  â”Š55â”Š        expect(this.polygon.getCircleIntersection(circle)).toEqual([\n+â”Š  â”Š56â”Š          { x: 2, y: 0 },\n+â”Š  â”Š57â”Š          { x: 0, y: 2 }\n+â”Š  â”Š58â”Š        ]);\n+â”Š  â”Š59â”Š      });\n+â”Š  â”Š60â”Š    });\n+â”Š  â”Š61â”Š\n+â”Š  â”Š62â”Š    describe(\"given circle with 1 intersection points\", function() {\n+â”Š  â”Š63â”Š      it(\"returns array with intersection point\", function() {\n+â”Š  â”Š64â”Š        let circle = new Engine.Geometry.Circle(0, 0, 2, 0, 0.25 * Math.PI);\n+â”Š  â”Š65â”Š\n+â”Š  â”Š66â”Š        expect(this.polygon.getCircleIntersection(circle)).toEqual([\n+â”Š  â”Š67â”Š          { x: 2, y: 0 }\n+â”Š  â”Š68â”Š        ]);\n+â”Š  â”Š69â”Š      });\n+â”Š  â”Š70â”Š    });\n+â”Š  â”Š71â”Š\n+â”Š  â”Š72â”Š    describe(\"given kissing circle\", function() {\n+â”Š  â”Š73â”Š      it(\"returns array with intersection point\", function() {\n+â”Š  â”Š74â”Š        let circle = new Engine.Geometry.Circle(-3, 3, 3, 0, 2 * Math.PI);\n+â”Š  â”Š75â”Š\n+â”Š  â”Š76â”Š        expect(this.polygon.getCircleIntersection(circle)).toEqual([\n+â”Š  â”Š77â”Š          { x: 0, y: 3 }\n+â”Š  â”Š78â”Š        ]);\n+â”Š  â”Š79â”Š      });\n+â”Š  â”Š80â”Š    });\n+â”Š  â”Š81â”Š\n+â”Š  â”Š82â”Š    describe(\"given outer circle\", function() {\n+â”Š  â”Š83â”Š      it(\"returns nothing\", function() {\n+â”Š  â”Š84â”Š        let circle = new Engine.Geometry.Circle(10, 10, 2, 0, 2 * Math.PI);\n+â”Š  â”Š85â”Š        expect(this.polygon.getCircleIntersection(circle)).toBeUndefined();\n+â”Š  â”Š86â”Š      });\n+â”Š  â”Š87â”Š    });\n+â”Š  â”Š88â”Š\n+â”Š  â”Š89â”Š    describe(\"given inner circle\", function() {\n+â”Š  â”Š90â”Š      it(\"nothing\", function() {\n+â”Š  â”Š91â”Š        let circle = new Engine.Geometry.Circle(2.5, 2.5, 2, 0, 2 * Math.PI);\n+â”Š  â”Š92â”Š        expect(this.polygon.getCircleIntersection(circle)).toBeUndefined();\n+â”Š  â”Š93â”Š      });\n+â”Š  â”Š94â”Š    });\n+â”Š  â”Š95â”Š  });\n+â”Š  â”Š96â”Š});ðŸš«â†µ\n```\n\n##### Changed views&#x2F;spec_runner.html\n```diff\n@@ -20,10 +20,12 @@\n â”Š20â”Š20â”Š    <script type=\"text/javascript\" src=\"scripts/namespaces.js\"></script>\n â”Š21â”Š21â”Š    <script type=\"text/javascript\" src=\"scripts/engine/geometry/line.js\"></script>\n â”Š22â”Š22â”Š    <script type=\"text/javascript\" src=\"scripts/engine/geometry/circle.js\"></script>\n+â”Š  â”Š23â”Š    <script type=\"text/javascript\" src=\"scripts/engine/geometry/polygon.js\"></script>\n â”Š23â”Š24â”Š\n â”Š24â”Š25â”Š    <!-- Specs -->\n â”Š25â”Š26â”Š    <script type=\"text/javascript\" src=\"scripts/specs/engine/geometry/line.js\"></script>\n â”Š26â”Š27â”Š    <script type=\"text/javascript\" src=\"scripts/specs/engine/geometry/circle.js\"></script>\n+â”Š  â”Š28â”Š    <script type=\"text/javascript\" src=\"scripts/specs/engine/geometry/polygon.js\"></script>\n â”Š27â”Š29â”Š  </head>\n â”Š28â”Š30â”Š\n â”Š29â”Š31â”Š  <body>\n```\n\n[}]: #\n\nAt last, all the necessary geometry shapes are implemented and ready to use. We will now focus on the snake itself. Since our game can potentially have infinite number of entities, not necessarily just a snake, we will add the a new module under the `Game` namespace called `Entities`:\n\n[{]: <helper> (diffStep 5.13)\n\n#### [Step 5.13: Add &#x27;Entities&#x27; module to &#x27;Game&#x27; namespace](https://github.com/DAB0mB/radial-snake/commit/a0bed8c)\n\n##### Changed resources&#x2F;scripts&#x2F;namespaces.js\n```diff\n@@ -1,4 +1,5 @@\n â”Š1â”Š1â”ŠGame = {\n+â”Š â”Š2â”Š  Entities: {},\n â”Š2â”Š3â”Š  Screens: {}\n â”Š3â”Š4â”Š};\n```\n\n[}]: #\n\nAnd now we can add the `Snake` class:\n\n[{]: <helper> (diffStep 5.14)\n\n#### [Step 5.14: Create &#x27;Snake&#x27; class](https://github.com/DAB0mB/radial-snake/commit/b938ba7)\n\n##### Added resources&#x2F;scripts&#x2F;game&#x2F;entities&#x2F;snake.js\n```diff\n@@ -0,0 +1,234 @@\n+â”Š   â”Š  1â”ŠGame.Entities.Snake = class Snake {\n+â”Š   â”Š  2â”Š  // Represents a snake data-structure which will eventually appear on screen.\n+â”Š   â”Š  3â”Š  // All the properties provided to the constructor are the initial values of\n+â”Š   â”Š  4â”Š  // the snake\n+â”Š   â”Š  5â”Š  constructor(x, y, r, rad, v, color, keyStates, options) {\n+â”Š   â”Š  6â”Š    this.x = x;\n+â”Š   â”Š  7â”Š    this.y = y;\n+â”Š   â”Š  8â”Š    this.r = r;\n+â”Š   â”Š  9â”Š    this.rad = rad;\n+â”Š   â”Š 10â”Š    this.v = v;\n+â”Š   â”Š 11â”Š    this.color = color;\n+â”Š   â”Š 12â”Š    this.keyStates = keyStates;\n+â”Š   â”Š 13â”Š    // A snake is made out of many geometry shapes\n+â”Š   â”Š 14â”Š    this.shapes = [];\n+â”Š   â”Š 15â”Š    // A snake starts with a line\n+â”Š   â”Š 16â”Š    this.currentShape = new Engine.Geometry.Line(x, y, x, y);\n+â”Š   â”Š 17â”Š    this.shapes.push(this.currentShape);\n+â”Š   â”Š 18â”Š    // A score can be provided in case we want to reserve previous scores from\n+â”Š   â”Š 19â”Š    // recent matches\n+â”Š   â”Š 20â”Š    this.score = options.score || 0;\n+â”Š   â”Š 21â”Š\n+â”Š   â”Š 22â”Š    // Custom keys can be specified\n+â”Š   â”Š 23â”Š    if (options.keys && options.keys) {\n+â”Š   â”Š 24â”Š      this.leftKey = options.keys.left;\n+â”Š   â”Š 25â”Š      this.rightKey = options.keys.right;\n+â”Š   â”Š 26â”Š    }\n+â”Š   â”Š 27â”Š    // Left and right arrow keys will be used by default\n+â”Š   â”Š 28â”Š    else {\n+â”Š   â”Š 29â”Š      this.leftKey = 37; // Left arrow\n+â”Š   â”Š 30â”Š      this.rightKey = 39; // Right arrow\n+â”Š   â”Š 31â”Š    }\n+â”Š   â”Š 32â”Š  }\n+â”Š   â”Š 33â”Š\n+â”Š   â”Š 34â”Š  draw(context) {\n+â”Š   â”Š 35â”Š    // Draw all shapes in the shapes array\n+â”Š   â”Š 36â”Š    this.shapes.forEach(shape => {\n+â”Š   â”Š 37â”Š      context.save();\n+â”Š   â”Š 38â”Š      context.strokeStyle = this.color;\n+â”Š   â”Š 39â”Š      context.lineWidth = 3;\n+â”Š   â”Š 40â”Š      context.beginPath();\n+â”Š   â”Š 41â”Š\n+â”Š   â”Š 42â”Š      // Each shape has its own unique drawing method\n+â”Š   â”Š 43â”Š      shape.draw(context);\n+â”Š   â”Š 44â”Š\n+â”Š   â”Š 45â”Š      context.stroke();\n+â”Š   â”Š 46â”Š      context.restore();\n+â”Š   â”Š 47â”Š    });\n+â”Š   â”Š 48â”Š  }\n+â”Š   â”Š 49â”Š\n+â”Š   â”Š 50â”Š  update(span, width, height) {\n+â”Š   â”Š 51â”Š    // Progress made based on elapsed time and velocity\n+â”Š   â”Š 52â”Š    let step = (this.v * span) / 1000;\n+â”Š   â”Š 53â”Š\n+â”Š   â”Š 54â”Š    this.updateShapes(step, width, height);\n+â”Š   â”Š 55â”Š    this.cycleThrough(step, width, height);\n+â”Š   â”Š 56â”Š  }\n+â”Š   â”Š 57â”Š\n+â”Š   â”Š 58â”Š  // Updates shapes array based on progress made\n+â”Š   â”Š 59â”Š  updateShapes(step, width, height, options = {}) {\n+â”Š   â”Š 60â”Š    this.updateCurrentShape(step, options);\n+â”Š   â”Š 61â”Š    this.updateDirection(step, options);\n+â”Š   â”Š 62â”Š  }\n+â”Š   â”Š 63â”Š\n+â”Š   â”Š 64â”Š  // Updates current shape\n+â”Š   â”Š 65â”Š  updateCurrentShape(step, options) {\n+â”Š   â”Š 66â”Š    if (this.currentShape instanceof Engine.Geometry.Line)\n+â”Š   â”Š 67â”Š      return this.updateCurrentLine(options);\n+â”Š   â”Š 68â”Š    if (this.currentShape instanceof Engine.Geometry.Circle)\n+â”Š   â”Š 69â”Š      return this.updateCurrentCircle(options);\n+â”Š   â”Š 70â”Š  }\n+â”Š   â”Š 71â”Š\n+â”Š   â”Š 72â”Š  // Updates current shape in case it is a line\n+â”Š   â”Š 73â”Š  updateCurrentLine(options) {\n+â”Š   â”Š 74â”Š    let lastX = options.lastX || this.x;\n+â”Š   â”Š 75â”Š    let lastY = options.lastY || this.y;\n+â”Š   â”Š 76â”Š    this.x = options.x || this.currentShape.x2;\n+â”Š   â”Š 77â”Š    this.y = options.y || this.currentShape.y2;\n+â”Š   â”Š 78â”Š    this.lastBit = new Engine.Geometry.Line(lastX, lastY, this.x, this.y);\n+â”Š   â”Š 79â”Š  }\n+â”Š   â”Š 80â”Š\n+â”Š   â”Š 81â”Š  // Updates current shape in case it is a circle\n+â”Š   â”Š 82â”Š  updateCurrentCircle(options) {\n+â”Š   â”Š 83â”Š    let lastX = options.lastX || this.currentShape.x;\n+â”Š   â”Š 84â”Š    let lastY = options.lastY || this.currentShape.y;\n+â”Š   â”Š 85â”Š    let lastR = options.lastR || this.currentShape.r;\n+â”Š   â”Š 86â”Š\n+â”Š   â”Š 87â”Š    // Update logic for left rotation\n+â”Š   â”Š 88â”Š    if (this.direction == \"left\") {\n+â”Š   â”Š 89â”Š      let lastRad = this.rad + (0.5 * Math.PI);\n+â”Š   â”Š 90â”Š      let currentShapePoint = this.currentShape.getPoint(this.currentShape.rad1);\n+â”Š   â”Š 91â”Š      this.x = options.x || currentShapePoint.x;\n+â”Š   â”Š 92â”Š      this.y = options.y || currentShapePoint.y;\n+â”Š   â”Š 93â”Š      this.rad = this.currentShape.rad1 - (0.5 * Math.PI);\n+â”Š   â”Š 94â”Š      this.lastBit = new Engine.Geometry.Circle(lastX, lastY, lastR, this.currentShape.rad1, lastRad);\n+â”Š   â”Š 95â”Š    }\n+â”Š   â”Š 96â”Š    // Update logic for right rotation\n+â”Š   â”Š 97â”Š    else {\n+â”Š   â”Š 98â”Š      let lastRad = this.rad - (0.5 * Math.PI);\n+â”Š   â”Š 99â”Š      let currentShapePoint = this.currentShape.getPoint(this.currentShape.rad2);\n+â”Š   â”Š100â”Š      this.x = options.x || currentShapePoint.x;\n+â”Š   â”Š101â”Š      this.y = options.y || currentShapePoint.y;\n+â”Š   â”Š102â”Š      this.rad = this.currentShape.rad2 + (0.5 * Math.PI);\n+â”Š   â”Š103â”Š      this.lastBit = new Engine.Geometry.Circle(lastX, lastY, lastR, lastRad, this.currentShape.rad2);\n+â”Š   â”Š104â”Š    }\n+â”Š   â”Š105â”Š  }\n+â”Š   â”Š106â”Š\n+â”Š   â”Š107â”Š  updateDirection(step, options) {\n+â”Š   â”Š108â”Š    // Update the direction based on pressed key\n+â”Š   â”Š109â”Š    if (this.keyStates.get(this.leftKey))\n+â”Š   â”Š110â”Š      var direction = \"left\";\n+â”Š   â”Š111â”Š    else if (this.keyStates.get(this.rightKey))\n+â”Š   â”Š112â”Š      var direction = \"right\";\n+â”Š   â”Š113â”Š\n+â”Š   â”Š114â”Š    this.changeDirection(step, direction, options);\n+â”Š   â”Š115â”Š    this.continueDirection(step, direction, options);\n+â”Š   â”Š116â”Š  }\n+â”Š   â”Š117â”Š\n+â”Š   â”Š118â”Š  // Change the recent shape type according to the given direction\n+â”Š   â”Š119â”Š  changeDirection(step, direction, options) {\n+â”Š   â”Š120â”Š    // If there is no change in direction, abort, unless we force it\n+â”Š   â”Š121â”Š    if (direction == this.direction && !options.force) return;\n+â”Š   â”Š122â”Š\n+â”Š   â”Š123â”Š    this.direction = direction;\n+â”Š   â”Š124â”Š\n+â”Š   â”Š125â”Š    // This will push a new shape with new properties, based on the direction\n+â”Š   â”Š126â”Š    switch (direction) {\n+â”Š   â”Š127â”Š      case \"left\":\n+â”Š   â”Š128â”Š        var angle = this.rad - (0.5 * Math.PI);\n+â”Š   â”Š129â”Š        var rad = this.rad + (0.5 * Math.PI);\n+â”Š   â”Š130â”Š        var x = this.x + (this.r * Math.cos(angle));\n+â”Š   â”Š131â”Š        var y = this.y + (this.r * Math.sin(angle));\n+â”Š   â”Š132â”Š        this.currentShape = new Engine.Geometry.Circle(x, y, this.r, rad, rad);\n+â”Š   â”Š133â”Š        break;\n+â”Š   â”Š134â”Š      case \"right\":\n+â”Š   â”Š135â”Š        angle = this.rad + (0.5 * Math.PI);\n+â”Š   â”Š136â”Š        rad = this.rad - (0.5 * Math.PI);\n+â”Š   â”Š137â”Š        x = this.x + (this.r * Math.cos(angle));\n+â”Š   â”Š138â”Š        y = this.y + (this.r * Math.sin(angle));\n+â”Š   â”Š139â”Š        this.currentShape = new Engine.Geometry.Circle(x, y, this.r, rad, rad);\n+â”Š   â”Š140â”Š        break;\n+â”Š   â”Š141â”Š      default:\n+â”Š   â”Š142â”Š        this.currentShape = new Engine.Geometry.Line(this.x, this.y, this.x, this.y);\n+â”Š   â”Š143â”Š    }\n+â”Š   â”Š144â”Š\n+â”Š   â”Š145â”Š    this.shapes.push(this.currentShape);\n+â”Š   â”Š146â”Š  }\n+â”Š   â”Š147â”Š\n+â”Š   â”Š148â”Š  // Extend the recent shape based on progress made\n+â”Š   â”Š149â”Š  continueDirection(step, direction) {\n+â”Š   â”Š150â”Š    switch (direction) {\n+â”Š   â”Š151â”Š      case \"left\":\n+â”Š   â”Š152â”Š        this.currentShape.rad1 -= step / this.r;\n+â”Š   â”Š153â”Š        break;\n+â”Š   â”Š154â”Š      case \"right\":\n+â”Š   â”Š155â”Š        this.currentShape.rad2 += step / this.r;\n+â”Š   â”Š156â”Š        break;\n+â”Š   â”Š157â”Š      default:\n+â”Š   â”Š158â”Š        this.currentShape.x2 += step * Math.cos(this.rad);\n+â”Š   â”Š159â”Š        this.currentShape.y2 += step * Math.sin(this.rad);\n+â”Š   â”Š160â”Š    }\n+â”Š   â”Š161â”Š  }\n+â”Š   â”Š162â”Š\n+â”Š   â”Š163â”Š  // Handles case where snake is out limits and we need to render it from\n+â”Š   â”Š164â”Š  // the other side of the canvas\n+â”Š   â”Š165â”Š  cycleThrough(step, width, height) {\n+â”Š   â”Š166â”Š    let intersectionPoint = this.getCanvasIntersection(width, height);\n+â”Š   â”Š167â”Š\n+â”Š   â”Š168â”Š    if (!intersectionPoint) return;\n+â”Š   â”Š169â”Š\n+â”Š   â”Š170â”Š    intersectionPoint = intersectionPoint[0];\n+â”Š   â”Š171â”Š\n+â”Š   â”Š172â”Š    // Re-calculate position based on canvas bounds\n+â”Š   â”Š173â”Š    if (intersectionPoint.x % width == 0)\n+â”Š   â”Š174â”Š      this.x = Utils.mod(this.x - width, width);\n+â”Š   â”Š175â”Š    if (intersectionPoint.y % height == 0)\n+â”Š   â”Š176â”Š      this.y = Utils.mod(this.y - height, height);\n+â”Š   â”Š177â”Š\n+â”Š   â”Š178â”Š    // Update shapes again based on custom properties\n+â”Š   â”Š179â”Š    this.updateShapes(step, width, height, {\n+â”Š   â”Š180â”Š      force: true,\n+â”Š   â”Š181â”Š      lastX: this.x,\n+â”Š   â”Š182â”Š      lastY: this.y,\n+â”Š   â”Š183â”Š      x: this.x,\n+â”Š   â”Š184â”Š      y: this.y\n+â”Š   â”Š185â”Š    });\n+â”Š   â”Š186â”Š  }\n+â”Š   â”Š187â”Š\n+â”Š   â”Š188â”Š  // Gets intersection points between last bit and own shapes\n+â”Š   â”Š189â”Š  getSelfIntersection() {\n+â”Š   â”Š190â”Š    if (this.currentShape instanceof Engine.Geometry.Circle &&\n+â”Š   â”Š191â”Š       Math.abs(this.currentShape.rad1 - this.currentShape.rad2) >= 2 * Math.PI) {\n+â”Š   â”Š192â”Š      if (this.direction == \"left\")\n+â”Š   â”Š193â”Š        var rad = this.currentShape.rad1;\n+â”Š   â”Š194â”Š      else\n+â”Š   â”Š195â”Š        var rad = this.currentShape.rad2;\n+â”Š   â”Š196â”Š\n+â”Š   â”Š197â”Š      return this.currentShape.getPoint(rad);\n+â”Š   â”Š198â”Š    }\n+â”Š   â”Š199â”Š\n+â”Š   â”Š200â”Š    let result;\n+â”Š   â”Š201â”Š\n+â”Š   â”Š202â”Š    this.shapes.slice(0, -2).some(shape =>\n+â”Š   â”Š203â”Š      result = this.lastBit.getIntersection(shape)\n+â”Š   â”Š204â”Š    );\n+â”Š   â”Š205â”Š\n+â”Š   â”Š206â”Š    return result;\n+â”Š   â”Š207â”Š  }\n+â”Š   â”Š208â”Š\n+â”Š   â”Š209â”Š  // Returns intersection points between snakes\n+â”Š   â”Š210â”Š  getSnakeIntersection(snake) {\n+â”Š   â”Š211â”Š    let result;\n+â”Š   â”Š212â”Š\n+â”Š   â”Š213â”Š    snake.shapes.some(shape =>\n+â”Š   â”Š214â”Š      // Only last bit is relevant, if we reached this point it means that\n+â”Š   â”Š215â”Š      // previous intersection will definitely fail\n+â”Š   â”Š216â”Š      result = this.lastBit.getIntersection(shape)\n+â”Š   â”Š217â”Š    );\n+â”Š   â”Š218â”Š\n+â”Š   â”Š219â”Š    return result;\n+â”Š   â”Š220â”Š  }\n+â”Š   â”Š221â”Š\n+â”Š   â”Š222â”Š  // Returns intersection points between snake and canvas\n+â”Š   â”Š223â”Š  getCanvasIntersection(width, height) {\n+â”Š   â”Š224â”Š    // Canvas polygon\n+â”Š   â”Š225â”Š    let canvasPolygon = new Engine.Geometry.Polygon(\n+â”Š   â”Š226â”Š      [0, 0, width, 0],\n+â”Š   â”Š227â”Š      [width, 0, width, height],\n+â”Š   â”Š228â”Š      [width, height, 0, height],\n+â”Š   â”Š229â”Š      [0, height, 0, 0]\n+â”Š   â”Š230â”Š    );\n+â”Š   â”Š231â”Š\n+â”Š   â”Š232â”Š    return canvasPolygon.getIntersection(this.lastBit);\n+â”Š   â”Š233â”Š  }\n+â”Š   â”Š234â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -22,6 +22,7 @@\n â”Š22â”Š22â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/screen.js\"></script>\n â”Š23â”Š23â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/assets_loader.js\"></script>\n â”Š24â”Š24â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n+â”Š  â”Š25â”Š    <script type=\"text/javascript\" src=\"/scripts/game/entities/snake.js\"></script>\n â”Š25â”Š26â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/menu/index.js\"></script>\n â”Š26â”Š27â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/splash/index.js\"></script>\n â”Š27â”Š28â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n```\n\n[}]: #\n\nThis class is titled with most complexity out of everything we did so far in this step. You can follow the code accompanied by comments regard it, but I'd also like to explain the key concepts. As said earlier, the `Snake` is simply made out of shapes; In this case - lines and circles.\n\nThe `draw` method just goes through this array and draws whatever shape it's currently looping through. Regardless of its type, every shape is provided with a `draw` method of its own, all shapes share the same interface, therefore we can just draw them regularly and the snake should be drawn automatically.\n\nThe `update` method updates the last bit only according to its type, the time elapsed and the speed of the snake. For example, the last bit of the snake is a line, and 5 seconds have passed at a speed of 5 meters per second, our line should be extended by 5 meters long. Same principle applies to circle extension only based on radians. The last bit's type might be changed according to the current input; e.g. if the `right` key is held the last bit would turn into a circle, and once released it would turn into a straight line.\n\nNote that besides shapes extension, collision detection should also be made. The embedded is the collision detection between the snake and the canvas, which means that any time the snake collides with the canvas's boundaries the last bit should be redrawn from the opposite side of the canvas. In addition, we've implemented intersection methods for self collision detection and collision detection between rivals, which should be used externally by the hosting screen.\n\nIn the next step we will be implementing the game screen where we will make use of the `Snake` class we've just created, and see how it works in action."
          },
          {
            "manualTitle": "Step 6: Creating a complex game screen with multiple layers",
            "stepRevision": "c27bb0d7806aab70ec489ccd9bbff182d1053dda",
            "manualView": "![snake-demo-game-small](https://cloud.githubusercontent.com/assets/7648874/21074124/8b7cd724-bed7-11e6-9f91-2a211630ac78.gif)\n\nIn this step we will be using the `Snake` class we've just created in the previous step to form the actual game screen - called the `Play` screen. The play screen is a complex screen made out multiple layers as following:\n\n- **`Ready` layer** - Displays a message at the beginning of each match.\n- **`Snake` layer** - Displays the the competitors' snakes.\n- **`Score` layer** - Displays the score board.\n- **`Win` layer** - Displays the winner at the end of each match.\n\nAs we go further with this step, we will give a deeper explanation about each layer and how they interact with each other; As for let's start with the `Play` screen's basis. Regardless of what the `Play` screen should contain at the final result, we want to have the ability to abort the match whenever we press the `Escape` key, therefore, the initial implementation should look like this:\n\n[{]: <helper> (diffStep 6.1)\n\n#### [Step 6.1: Create &#x27;Play&#x27; screen](https://github.com/DAB0mB/radial-snake/commit/e17a45f)\n\n##### Added resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;play&#x2F;index.js\n```diff\n@@ -0,0 +1,14 @@\n+â”Š  â”Š 1â”ŠGame.Screens.Play = class Play extends Engine.Screen {\n+â”Š  â”Š 2â”Š  get events() {\n+â”Š  â”Š 3â”Š    return {\n+â”Š  â”Š 4â”Š      \"keydown\": \"onKeyDown\"\n+â”Š  â”Š 5â”Š    }\n+â”Š  â”Š 6â”Š  }\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Š  onKeyDown() {\n+â”Š  â”Š 9â”Š    // Once escape is pressed, return to main menu screen\n+â”Š  â”Š10â”Š    if (this.keyStates.get(27)) {\n+â”Š  â”Š11â”Š      this.game.changeScreen(Game.Screens.Menu);\n+â”Š  â”Š12â”Š    }\n+â”Š  â”Š13â”Š  }\n+â”Š  â”Š14â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -23,6 +23,7 @@\n â”Š23â”Š23â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/assets_loader.js\"></script>\n â”Š24â”Š24â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š25â”Š25â”Š    <script type=\"text/javascript\" src=\"/scripts/game/entities/snake.js\"></script>\n+â”Š  â”Š26â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/index.js\"></script>\n â”Š26â”Š27â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/menu/index.js\"></script>\n â”Š27â”Š28â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/splash/index.js\"></script>\n â”Š28â”Š29â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n```\n\n[}]: #\n\nNow that we have the `Play` screen, we need to hook it to the `Menu` screen, so whenever we press a key, we will be proceeded to it:\n\n[{]: <helper> (diffStep 6.2)\n\n#### [Step 6.2: Hook &#x27;Play&#x27; screen to &#x27;menu&#x27; screen](https://github.com/DAB0mB/radial-snake/commit/495b9ee)\n\n##### Changed resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;menu&#x2F;index.js\n```diff\n@@ -1,4 +1,10 @@\n â”Š 1â”Š 1â”ŠGame.Screens.Menu = class Menu extends Engine.Screen {\n+â”Š  â”Š 2â”Š  get events() {\n+â”Š  â”Š 3â”Š    return {\n+â”Š  â”Š 4â”Š      \"keydown\": \"onKeyDown\"\n+â”Š  â”Š 5â”Š    }\n+â”Š  â”Š 6â”Š  }\n+â”Š  â”Š 7â”Š\n â”Š 2â”Š 8â”Š  initialize() {\n â”Š 3â”Š 9â”Š    // Initialize snake logo sprite\n â”Š 4â”Š10â”Š    this.logoSprite = new Engine.Sprite(this.assets.logoTexture);\n```\n```diff\n@@ -40,10 +46,18 @@\n â”Š40â”Š46â”Š  }\n â”Š41â”Š47â”Š\n â”Š42â”Š48â”Š  update(span) {\n-â”Š43â”Š  â”Š    this.instructionsAnim.update(span);\n+â”Š  â”Š49â”Š    // On key press, proceed to play screen\n+â”Š  â”Š50â”Š    if (this.keyPressed) {\n+â”Š  â”Š51â”Š      this.game.changeScreen(Game.Screens.Play);\n+â”Š  â”Š52â”Š    }\n+â”Š  â”Š53â”Š    // Else, just update animation\n+â”Š  â”Š54â”Š    else {\n+â”Š  â”Š55â”Š      this.instructionsAnim.update(span);\n+â”Š  â”Š56â”Š    }\n â”Š44â”Š57â”Š  }\n â”Š45â”Š58â”Š\n-â”Š46â”Š  â”Š  update(span) {\n-â”Š47â”Š  â”Š    this.instructionsAnim.update(span);\n+â”Š  â”Š59â”Š  // Register key press\n+â”Š  â”Š60â”Š  onKeyDown(e) {\n+â”Š  â”Š61â”Š    this.keyPressed = true;\n â”Š48â”Š62â”Š  }\n â”Š49â”Š63â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nBy now there shouldn't be anything special. Once you're at the main menu, just press a key as instructed, and you shall see a black screen, which is actually the `Play` screen we've just created; And once you'll press the `Escape` key, you should be receded to the main menu.\n\nThe next stage would be displaying a `Ready` message on the screen, and whenever a key is pressed, the message should fade away using a key-frame animation, and the match should start in the background:\n\n[{]: <helper> (diffStep 6.3)\n\n#### [Step 6.3: Create &#x27;Ready&#x27; layer](https://github.com/DAB0mB/radial-snake/commit/551962d)\n\n##### Added resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;play&#x2F;ready.js\n```diff\n@@ -0,0 +1,59 @@\n+â”Š  â”Š 1â”ŠGame.Screens.Play.Ready = class Ready extends Engine.Layer {\n+â”Š  â”Š 2â”Š  get events() {\n+â”Š  â”Š 3â”Š    return {\n+â”Š  â”Š 4â”Š      \"keydown\": \"onKeyDown\"\n+â”Š  â”Š 5â”Š    };\n+â”Š  â”Š 6â”Š  }\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Š  constructor(screen, snakes) {\n+â”Š  â”Š 9â”Š    super(screen);\n+â”Š  â”Š10â”Š\n+â”Š  â”Š11â”Š    this.snakes = snakes;\n+â”Š  â”Š12â”Š\n+â”Š  â”Š13â”Š    // Create \"ready\" sprite and set its properties\n+â”Š  â”Š14â”Š    let readyTexture = this.assets.minecraftiaFont.createTexture(\"Ready\");\n+â”Š  â”Š15â”Š    let readySprite = new Engine.Sprite(readyTexture);\n+â”Š  â”Š16â”Š    readySprite.align = \"center\";\n+â”Š  â”Š17â”Š    readySprite.setPercentage(\"width\", this.width, 15, \"height\");\n+â”Š  â”Š18â”Š\n+â”Š  â”Š19â”Š    // Create fade out animation for \"ready\" sprite\n+â”Š  â”Š20â”Š    this.readyAnim = new Engine.Animations.Keyframe(readySprite, [\n+â”Š  â”Š21â”Š      {\n+â”Š  â”Š22â”Š        x: this.width / 2,\n+â”Š  â”Š23â”Š        y: this.height / 2,\n+â”Š  â”Š24â”Š        opacity: 1,\n+â”Š  â”Š25â”Š        frame: 0\n+â”Š  â”Š26â”Š      },\n+â”Š  â”Š27â”Š      {\n+â”Š  â”Š28â”Š        y: this.height / 3,\n+â”Š  â”Š29â”Š        opacity: 0,\n+â”Š  â”Š30â”Š        frame: 700\n+â”Š  â”Š31â”Š      }\n+â”Š  â”Š32â”Š    ]);\n+â”Š  â”Š33â”Š  }\n+â”Š  â”Š34â”Š\n+â”Š  â”Š35â”Š  draw(context) {\n+â”Š  â”Š36â”Š    this.readyAnim.draw(context);\n+â”Š  â”Š37â”Š  }\n+â”Š  â”Š38â”Š\n+â”Š  â”Š39â”Š  update(span) {\n+â”Š  â”Š40â”Š    if (!this.ready) return;\n+â”Š  â”Š41â”Š\n+â”Š  â”Š42â”Š    if (this.readyAnim.playing) {\n+â”Š  â”Š43â”Š      this.readyAnim.update(span);\n+â”Š  â”Š44â”Š    }\n+â”Š  â”Š45â”Š    // Once animation is finished, dispose layer\n+â”Š  â”Š46â”Š    else {\n+â”Š  â”Š47â”Š      this.screen.removeLayer(this);\n+â”Š  â”Š48â”Š    }\n+â”Š  â”Š49â”Š  }\n+â”Š  â”Š50â”Š\n+â”Š  â”Š51â”Š  onKeyDown() {\n+â”Š  â”Š52â”Š    // One time event\n+â”Š  â”Š53â”Š    this.disposeEventListeners()\n+â”Š  â”Š54â”Š\n+â”Š  â”Š55â”Š    // This will start playing the animation\n+â”Š  â”Š56â”Š    this.ready = true;\n+â”Š  â”Š57â”Š    this.readyAnim.play();\n+â”Š  â”Š58â”Š  }\n+â”Š  â”Š59â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -24,6 +24,7 @@\n â”Š24â”Š24â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š25â”Š25â”Š    <script type=\"text/javascript\" src=\"/scripts/game/entities/snake.js\"></script>\n â”Š26â”Š26â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/index.js\"></script>\n+â”Š  â”Š27â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/ready.js\"></script>\n â”Š27â”Š28â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/menu/index.js\"></script>\n â”Š28â”Š29â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/splash/index.js\"></script>\n â”Š29â”Š30â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n```\n\n[}]: #\n\nIn order to hook the `Ready` layer to the `Play` screen, we will just push a new instance of it to the layers stack, using the screen's `appendLayer` method. Note that the order of the layer is super critic! Since if we push a new layer it means it will be drawn on top of any previous layer. To \"shift\" a layer to the layers stack, we can simply use the `prependLayer` method instead. Without further due, this is how our hook should look like:\n\n[{]: <helper> (diffStep 6.4)\n\n#### [Step 6.4: Hook &#x27;Ready&#x27; layer to &#x27;Play&#x27; screen](https://github.com/DAB0mB/radial-snake/commit/b461464)\n\n##### Changed resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;play&#x2F;index.js\n```diff\n@@ -5,6 +5,11 @@\n â”Š 5â”Š 5â”Š    }\n â”Š 6â”Š 6â”Š  }\n â”Š 7â”Š 7â”Š\n+â”Š  â”Š 8â”Š  // The ready screen will be the initial screen\n+â”Š  â”Š 9â”Š  initialize(game, snakes) {\n+â”Š  â”Š10â”Š    this.appendLayer(Game.Screens.Play.Ready, snakes);\n+â”Š  â”Š11â”Š  }\n+â”Š  â”Š12â”Š\n â”Š 8â”Š13â”Š  onKeyDown() {\n â”Š 9â”Š14â”Š    // Once escape is pressed, return to main menu screen\n â”Š10â”Š15â”Š    if (this.keyStates.get(27)) {\n```\n\n[}]: #\n\nNow if you'll launch the game and start a new match, you should see a white `Ready` message in the middle of the screen. Up next, would be the `Snake` layer, which will simply initialize 2 new `Snake` instances, and take care of drawing and updating them:\n\n[{]: <helper> (diffStep 6.5)\n\n#### [Step 6.5: Create &#x27;snake&#x27; layer](https://github.com/DAB0mB/radial-snake/commit/a36d7f2)\n\n##### Added resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;play&#x2F;snake.js\n```diff\n@@ -0,0 +1,79 @@\n+â”Š  â”Š 1â”ŠGame.Screens.Play.Snake = class Snake extends Engine.Layer {\n+â”Š  â”Š 2â”Š  constructor(screen, snakes = []) {\n+â”Š  â”Š 3â”Š    super(screen);\n+â”Š  â”Š 4â”Š\n+â”Š  â”Š 5â”Š    // Red snake\n+â”Š  â”Š 6â”Š    this.snakes = [\n+â”Š  â”Š 7â”Š      new Game.Entities.Snake(\n+â”Š  â”Š 8â”Š        this.width / 4,\n+â”Š  â”Š 9â”Š        this.height / 4,\n+â”Š  â”Š10â”Š        50,\n+â”Š  â”Š11â”Š        Math.PI / 4,\n+â”Š  â”Š12â”Š        100,\n+â”Š  â”Š13â”Š        \"FireBrick\",\n+â”Š  â”Š14â”Š        this.keyStates,\n+â”Š  â”Š15â”Š        {\n+â”Š  â”Š16â”Š          // Use score from previous matches\n+â”Š  â”Š17â”Š          score: snakes[0] && snakes[0].score,\n+â”Š  â”Š18â”Š          keys: {\n+â”Š  â”Š19â”Š            left: 37, // Left key\n+â”Š  â”Š20â”Š            right: 39 // RIght key\n+â”Š  â”Š21â”Š        }\n+â”Š  â”Š22â”Š      }),\n+â”Š  â”Š23â”Š\n+â”Š  â”Š24â”Š      // Blue snake\n+â”Š  â”Š25â”Š      new Game.Entities.Snake(\n+â”Š  â”Š26â”Š        (this.width / 4) * 3,\n+â”Š  â”Š27â”Š        (this.height / 4) * 3,\n+â”Š  â”Š28â”Š        50,\n+â”Š  â”Š29â”Š        (-Math.PI / 4) * 3,\n+â”Š  â”Š30â”Š        100,\n+â”Š  â”Š31â”Š        \"DodgerBlue\",\n+â”Š  â”Š32â”Š        this.keyStates,\n+â”Š  â”Š33â”Š        {\n+â”Š  â”Š34â”Š          score: snakes[1] && snakes[1].score,\n+â”Š  â”Š35â”Š          keys: {\n+â”Š  â”Š36â”Š            left: 65, // 'a' key\n+â”Š  â”Š37â”Š            right: 68 // 'b' key\n+â”Š  â”Š38â”Š        }\n+â”Š  â”Š39â”Š      })\n+â”Š  â”Š40â”Š    ];\n+â”Š  â”Š41â”Š  }\n+â”Š  â”Š42â”Š\n+â”Š  â”Š43â”Š  draw(context) {\n+â”Š  â”Š44â”Š    // Draw each snake in the snakes array\n+â”Š  â”Š45â”Š    this.snakes.forEach(snake => snake.draw(context));\n+â”Š  â”Š46â”Š  }\n+â”Š  â”Š47â”Š\n+â”Š  â”Š48â”Š  update(span) {\n+â”Š  â”Š49â”Š    if (!this.snakes.length) return;\n+â”Š  â”Š50â”Š\n+â”Š  â”Š51â”Š    // Storing original snakes array for future use, since it might get changed\n+â”Š  â”Š52â”Š    let snakes = this.snakes.slice();\n+â”Š  â”Š53â”Š\n+â”Š  â”Š54â”Š    snakes.forEach((snake, index) => {\n+â”Š  â”Š55â”Š      snake.update(span, this.width, this.height);\n+â”Š  â”Š56â”Š      // Disqualify if intersected with self\n+â”Š  â”Š57â”Š      if (snake.getSelfIntersection()) return this.snakes.splice(index, 1);\n+â”Š  â”Š58â”Š\n+â”Š  â”Š59â”Š      snakes.forEach((opponent) => {\n+â”Š  â”Š60â”Š        // Don't scan for intersection with self, obviously this will always be true\n+â”Š  â”Š61â”Š        if (opponent === snake) return;\n+â”Š  â”Š62â”Š        // Disqualify if intersected with opponent\n+â”Š  â”Š63â”Š        if (snake.getSnakeIntersection(opponent)) this.snakes.splice(index, 1);\n+â”Š  â”Š64â”Š      });\n+â”Š  â”Š65â”Š    });\n+â”Š  â”Š66â”Š\n+â”Š  â”Š67â”Š    // There can be only one winner, or a tie (very rare, most likely not to happen)\n+â”Š  â”Š68â”Š    // If the match is already finished, skip the next steps since they are not relevant\n+â”Š  â”Š69â”Š    if (this.snakes.length > 1 || this.matchFinished) return;\n+â”Š  â”Š70â”Š\n+â”Š  â”Š71â”Š    // The winner is the \"last snake standing\"\n+â”Š  â”Š72â”Š    let winner = this.snakes[0];\n+â”Š  â”Š73â”Š    // If this is not a tie, which is a very rare case, increase the winner's score\n+â”Š  â”Š74â”Š    if (winner) winner.score++;\n+â”Š  â”Š75â”Š\n+â”Š  â”Š76â”Š    // Indicates whether we should update the score counter or not\n+â”Š  â”Š77â”Š    this.matchFinished = true;\n+â”Š  â”Š78â”Š  }\n+â”Š  â”Š79â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -24,6 +24,7 @@\n â”Š24â”Š24â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š25â”Š25â”Š    <script type=\"text/javascript\" src=\"/scripts/game/entities/snake.js\"></script>\n â”Š26â”Š26â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/index.js\"></script>\n+â”Š  â”Š27â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/snake.js\"></script>\n â”Š27â”Š28â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/ready.js\"></script>\n â”Š28â”Š29â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/menu/index.js\"></script>\n â”Š29â”Š30â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/splash/index.js\"></script>\n```\n\n[}]: #\n\nOnce pressing a key in the `Ready` layer, not only we want to display an animation, but we also want the match to start in the background, thus, we gonna push a new instance of the `Snake` layer we've just created like so:\n\n[{]: <helper> (diffStep 6.6)\n\n#### [Step 6.6: Hook &#x27;snake&#x27; layer to &#x27;ready&#x27; layer](https://github.com/DAB0mB/radial-snake/commit/982db7b)\n\n##### Changed resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;play&#x2F;ready.js\n```diff\n@@ -55,5 +55,8 @@\n â”Š55â”Š55â”Š    // This will start playing the animation\n â”Š56â”Š56â”Š    this.ready = true;\n â”Š57â”Š57â”Š    this.readyAnim.play();\n+â”Š  â”Š58â”Š\n+â”Š  â”Š59â”Š    // Start the game in the background\n+â”Š  â”Š60â”Š    this.screen.prependLayer(Game.Screens.Play.Snake, this.snakes);\n â”Š58â”Š61â”Š  }\n â”Š59â”Š62â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nNote that the layer is pushed when the animation starts and not once finished; This would give a nice smooth feeling to our game-flow. If you'll test out the game, you would discover that the match is actually playable! The first snake (Red) snake should be controlled by the arrow keys, and the second snake (Blue) should be controlled by the letter keys `a`, `s`, `d` and `w`. So far, the snakes function great, but you can probably tell that whenever a match is finished, it feels a bit dull. There's no indication of winning, and there's no score board to present the score of each competitor, which brings us to the next stage - Implementing the `Score` layer.\n\nThe `Score` layer is a simple layer which takes the 2 snakes as a parameter and displays their scores at the top of the screen:\n\n[{]: <helper> (diffStep 6.7)\n\n#### [Step 6.7: Create &#x27;Score&#x27; layer](https://github.com/DAB0mB/radial-snake/commit/6ec4cac)\n\n##### Added resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;play&#x2F;score.js\n```diff\n@@ -0,0 +1,66 @@\n+â”Š  â”Š 1â”ŠGame.Screens.Play.Score = class Score extends Engine.Layer {\n+â”Š  â”Š 2â”Š  constructor(screen, snakes) {\n+â”Š  â”Š 3â”Š    super(screen);\n+â”Š  â”Š 4â”Š\n+â”Š  â”Š 5â”Š    this.snakes = snakes;\n+â”Š  â”Š 6â”Š    this.scoreSprites = [];\n+â”Š  â”Š 7â”Š    this.scores = [];\n+â”Š  â”Š 8â”Š\n+â”Š  â”Š 9â”Š    // It's important to match indexes to each snake since the number of snakes\n+â”Š  â”Š10â”Š    // can be reduced along the way as we play\n+â”Š  â”Š11â”Š    snakes.forEach((snake, index) => {\n+â”Š  â”Š12â”Š      snake.index = index;\n+â”Š  â”Š13â”Š    });\n+â”Š  â”Š14â”Š  }\n+â”Š  â”Š15â”Š\n+â”Š  â”Š16â”Š  draw(context) {\n+â”Š  â”Š17â”Š    this.scoreSprites.forEach((scoreSprite) => {\n+â”Š  â”Š18â”Š      scoreSprite.draw(context);\n+â”Š  â”Š19â”Š    });\n+â”Š  â”Š20â”Š  }\n+â”Š  â”Š21â”Š\n+â”Š  â”Š22â”Š  update(span) {\n+â”Š  â”Š23â”Š    this.snakes.forEach(snake => {\n+â”Š  â”Š24â”Š      let index = snake.index;\n+â”Š  â”Š25â”Š      if (this.scores[index] == snake.score) return;\n+â”Š  â”Š26â”Š\n+â”Š  â”Š27â”Š      // The sprite might be changed along the way so it's important to recreate it\n+â”Š  â”Š28â”Š      // over and over again. If no change was made the cache will be used by the engine\n+â”Š  â”Š29â”Š      this.scoreSprites[index] = this.createScoreSprite(snake);\n+â”Š  â”Š30â”Š      this.scores[index] = snake.score;\n+â”Š  â”Š31â”Š    });\n+â”Š  â”Š32â”Š  }\n+â”Š  â”Š33â”Š\n+â”Š  â”Š34â”Š  createScoreSprite(snake) {\n+â”Š  â”Š35â”Š    let minecraftiaFont = this.assets.minecraftiaFont;\n+â”Š  â”Š36â”Š    minecraftiaFont.save();\n+â”Š  â”Š37â”Š    minecraftiaFont.color = snake.color;\n+â”Š  â”Š38â”Š\n+â”Š  â”Š39â”Š    // Create a score sprite for the snake\n+â”Š  â”Š40â”Š    let scoreTexture = minecraftiaFont.createTexture(`${snake.score}`, {\n+â”Š  â”Š41â”Š      noOffsets: true,\n+â”Š  â”Š42â”Š      noSpaces: true\n+â”Š  â”Š43â”Š    });\n+â”Š  â”Š44â”Š\n+â”Š  â”Š45â”Š    let scoreSprite = new Engine.Sprite(scoreTexture);\n+â”Š  â”Š46â”Š\n+â”Š  â”Š47â”Š    // Size of score board is dynamic to screen size\n+â”Š  â”Š48â”Š    scoreSprite.setPercentage(\"width\", this.width, 4, \"height\");\n+â”Š  â”Š49â”Š\n+â”Š  â”Š50â”Š    // Set alignment modes.\n+â”Š  â”Š51â”Š    // Once we add more snakes we should add more cases here\n+â”Š  â”Š52â”Š    switch (snake.index) {\n+â”Š  â”Š53â”Š      case 0:\n+â”Š  â”Š54â”Š        scoreSprite.align = \"top-left\";\n+â”Š  â”Š55â”Š        break;\n+â”Š  â”Š56â”Š      case 1:\n+â”Š  â”Š57â”Š        scoreSprite.align = \"top-right\";\n+â”Š  â”Š58â”Š        scoreSprite.x = this.width;\n+â”Š  â”Š59â”Š        break;\n+â”Š  â”Š60â”Š    }\n+â”Š  â”Š61â”Š\n+â”Š  â”Š62â”Š    // Restore the font to its original color\n+â”Š  â”Š63â”Š    minecraftiaFont.restore();\n+â”Š  â”Š64â”Š    return scoreSprite;\n+â”Š  â”Š65â”Š  }\n+â”Š  â”Š66â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -24,6 +24,7 @@\n â”Š24â”Š24â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š25â”Š25â”Š    <script type=\"text/javascript\" src=\"/scripts/game/entities/snake.js\"></script>\n â”Š26â”Š26â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/index.js\"></script>\n+â”Š  â”Š27â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/score.js\"></script>\n â”Š27â”Š28â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/snake.js\"></script>\n â”Š28â”Š29â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/ready.js\"></script>\n â”Š29â”Š30â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/menu/index.js\"></script>\n```\n\n[}]: #\n\n> Note that the current score board is suitable for two players, but can easily be modified to support as much players as you want if done correctly.\n\nThe `Score` board should be appended to the layers stack as soon as the `Snake` layers is initialized, so it would be available to us once the match is started:\n\n[{]: <helper> (diffStep 6.8)\n\n#### [Step 6.8: Hook &#x27;Score&#x27; layer to &#x27;Snake&#x27; layer](https://github.com/DAB0mB/radial-snake/commit/feb4a0b)\n\n##### Changed resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;play&#x2F;snake.js\n```diff\n@@ -38,6 +38,9 @@\n â”Š38â”Š38â”Š        }\n â”Š39â”Š39â”Š      })\n â”Š40â”Š40â”Š    ];\n+â”Š  â”Š41â”Š\n+â”Š  â”Š42â”Š    // Show score board for newly created snakes\n+â”Š  â”Š43â”Š    screen.appendLayer(Game.Screens.Play.Score, this.snakes);\n â”Š41â”Š44â”Š  }\n â”Š42â”Š45â”Š\n â”Š43â”Š46â”Š  draw(context) {\n```\n\n[}]: #\n\nNow we're one layer further from completing the `Play` screen, the only thing missing is the `Win` layer, which should present the winner once the match is finished:\n\n[{]: <helper> (diffStep 6.9)\n\n#### [Step 6.9: Create &#x27;Win&#x27; layer](https://github.com/DAB0mB/radial-snake/commit/3476384)\n\n##### Added resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;play&#x2F;win.js\n```diff\n@@ -0,0 +1,43 @@\n+â”Š  â”Š 1â”ŠGame.Screens.Play.Win = class Win extends Engine.Layer {\n+â”Š  â”Š 2â”Š  constructor(screen, snakes, winner) {\n+â”Š  â”Š 3â”Š    super(screen);\n+â”Š  â”Š 4â”Š\n+â”Š  â”Š 5â”Š    this.snakes = snakes;\n+â”Š  â”Š 6â”Š    this.winner = winner;\n+â”Š  â”Š 7â”Š    // ttl stands for \"time to live\", which means, this layer is going to be\n+â”Š  â”Š 8â”Š    // disposed after 3 seconds\n+â”Š  â”Š 9â”Š    this.ttl = 3000;\n+â”Š  â”Š10â”Š\n+â”Š  â”Š11â”Š    // If there is a winner\n+â”Š  â”Š12â”Š    if (this.winner) {\n+â”Š  â”Š13â”Š      // Message could be something like \"RED SNAKE WINS\"\n+â”Š  â”Š14â”Š      var text = `${this.winner.color.toUpperCase()} SNAKE WINS`;\n+â”Š  â”Š15â”Š      var percent = 40;\n+â”Š  â”Š16â”Š    }\n+â”Š  â”Š17â”Š    // If there is a tie\n+â”Š  â”Š18â”Š    else {\n+â”Š  â”Š19â”Š      var text = 'TIE';\n+â”Š  â”Š20â”Š      var percent = 15;\n+â”Š  â”Š21â”Š    }\n+â”Š  â”Š22â”Š\n+â”Š  â”Š23â”Š    // Create winner sprite and set its properties\n+â”Š  â”Š24â”Š    let winnerTexture = this.assets.minecraftiaFont.createTexture(text);\n+â”Š  â”Š25â”Š    this.winnerSprite = new Engine.Sprite(winnerTexture);\n+â”Š  â”Š26â”Š    this.winnerSprite.align = \"center\";\n+â”Š  â”Š27â”Š    this.winnerSprite.setPercentage(\"width\", this.width, percent, \"height\");\n+â”Š  â”Š28â”Š    this.winnerSprite.x = this.width / 2;\n+â”Š  â”Š29â”Š    this.winnerSprite.y = this.height / 2;\n+â”Š  â”Š30â”Š  }\n+â”Š  â”Š31â”Š\n+â”Š  â”Š32â”Š  draw(context) {\n+â”Š  â”Š33â”Š    this.winnerSprite.draw(context);\n+â”Š  â”Š34â”Š  }\n+â”Š  â”Š35â”Š\n+â”Š  â”Š36â”Š  update(span) {\n+â”Š  â”Š37â”Š    // If limit not yet reached, abort\n+â”Š  â”Š38â”Š    if (this.age < this.ttl) return;\n+â”Š  â”Š39â”Š\n+â”Š  â”Š40â”Š    // Show \"ready\" message all over again, only this time use the updated score board\n+â”Š  â”Š41â”Š    this.screen.game.changeScreen(Game.Screens.Play, this.snakes);\n+â”Š  â”Š42â”Š  }\n+â”Š  â”Š43â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -24,6 +24,7 @@\n â”Š24â”Š24â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š25â”Š25â”Š    <script type=\"text/javascript\" src=\"/scripts/game/entities/snake.js\"></script>\n â”Š26â”Š26â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/index.js\"></script>\n+â”Š  â”Š27â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/win.js\"></script>\n â”Š27â”Š28â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/score.js\"></script>\n â”Š28â”Š29â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/snake.js\"></script>\n â”Š29â”Š30â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/ready.js\"></script>\n```\n\n[}]: #\n\nNote how we use the `changeScreen` method once the `Win` layer has reached its age limit (Time to live, aka `ttl`); This would clear the layers stack and restart the `Play` screen, so we can start a new match all-over, only this time we will pass the `Snake` instances to reserve the original scores. The `Win` layer should be presented whenever a collision has been detected between the snakes:\n\n[{]: <helper> (diffStep 6.1)\n\n#### [Step 6.1: Create &#x27;Play&#x27; screen](https://github.com/DAB0mB/radial-snake/commit/e17a45f)\n\n##### Added resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;play&#x2F;index.js\n```diff\n@@ -0,0 +1,14 @@\n+â”Š  â”Š 1â”ŠGame.Screens.Play = class Play extends Engine.Screen {\n+â”Š  â”Š 2â”Š  get events() {\n+â”Š  â”Š 3â”Š    return {\n+â”Š  â”Š 4â”Š      \"keydown\": \"onKeyDown\"\n+â”Š  â”Š 5â”Š    }\n+â”Š  â”Š 6â”Š  }\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Š  onKeyDown() {\n+â”Š  â”Š 9â”Š    // Once escape is pressed, return to main menu screen\n+â”Š  â”Š10â”Š    if (this.keyStates.get(27)) {\n+â”Š  â”Š11â”Š      this.game.changeScreen(Game.Screens.Menu);\n+â”Š  â”Š12â”Š    }\n+â”Š  â”Š13â”Š  }\n+â”Š  â”Š14â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -23,6 +23,7 @@\n â”Š23â”Š23â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/assets_loader.js\"></script>\n â”Š24â”Š24â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š25â”Š25â”Š    <script type=\"text/javascript\" src=\"/scripts/game/entities/snake.js\"></script>\n+â”Š  â”Š26â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/index.js\"></script>\n â”Š26â”Š27â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/menu/index.js\"></script>\n â”Š27â”Š28â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/splash/index.js\"></script>\n â”Š28â”Š29â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n```\n\n[}]: #\n\nThat's it folks, the `Play` screen is finished, and you can play as much matches as you'd feel like.\n\nAlthough the game is finished, it can still be optimized using `C++`. To discover more on hooking efficiency and how we can hook `C++` to the browser, see the next step."
          },
          {
            "manualTitle": "Step 7: Bonus! Re-implementing geometry in C++",
            "stepRevision": "cea4cffcc2f5e801020ed13ef8f1edde608c85f3",
            "manualView": "> This step is part of a bigger tutorial series where we learn how to create a game engine and implement a Tron-style game in JavaScript. The base project for the following step is available [here](https://github.com/DAB0mB/radial-snake/tree/step6).\n\nSo far I covered up pretty much everything I planned. I showed you how to create a game engine, including a font generator, an animation player and a screening system. On top of that, we've learned how to structure and organize our code well, so if in the future we'd like to extend our game by adding more screens or capabilities, we can do that with ease. Indeed, we've went through lots of great stuff, and if you've reached this point I give you my thumbs up. If so far this wasn't enough, in this step we will be focusing on optimization, and making our game engine run faster (a lot, faster). Obviously, when talking about optimizations, the first thing you would probably think of is how we can make our algorithms efficient by using minimum number of operations. While this is true, we will be actually focusing on optimizing our code using C++.\n\nUnlike JavaScript, which is a dynamic scripting file executed by an interpreter, C++ is a general purpose language which compiles into executables. Naturally, executables are much faster than scripts, since they don't have to be interpreted, and they can approach the hardware and memory much faster. In C++, we have to explicitly define our data-types, meaning that variables don't have to be parsed during run-time. While explicit variables definition is C++'s biggest drawback, it's also one of its biggest advantages. The mere fact that variables can be handled much faster, makes code much more efficient.\n\nAccordingly, we can conclude that the programming language we're using plays a very important role when it comes to efficiency. So how exactly are we going to integrate C++ into the browser? We're going to do that by using a compiler called - [Emscripten](http://kripken.github.io/emscripten-site/).\n\n![emscripten](https://cloud.githubusercontent.com/assets/7648874/22675449/ee6d7e9c-eccc-11e6-9570-1dd5d982ee66.png)\n\nEmscripten is an Open Source [LLVM](https://en.wikipedia.org/wiki/LLVM) to JavaScript compiler. Using Emscripten you can:\n\n- Compile C and C++ code into JavaScript\n- Compile any other code that can be translated into LLVM bitcode into JavaScript.\n- Compile the C/C++ runtimes of other languages into JavaScript, and then run code in those other languages in an indirect way (this has been done for Python and Lua)!\n\nLLVM is a library that is used to construct, optimize and produce intermediate and/or binary machine code. LLVM can be used as a compiler framework, where you provide the \"front end\" (parser and lexer) and the \"back end\" (code that converts LLVM's representation to actual machine code). LLVM can also act as a JIT compiler - it has support for x86/x86_64 and PPC/PPC64 assembly generation with fast code optimizations aimed for compilation speed.\n\nEmscripten operates by taking LLVM code and converting it into a subset of JavaScript called asm.js that can run anywhere that JavaScript can run (usually the browser, but also Node.js, etc.) and is easy for browsers to optimize. This means that you can basically write web applications in any language that has an LLVM compiler.\n\n![emscripten-flow](https://cloud.githubusercontent.com/assets/7648874/22675751/b244b76c-ecce-11e6-917e-f7039ed4b340.png)\n\nIn order to use Emscripten you will first have to install it. I recommend you to follow Emscripten's official installation instructions at their website over [here](https://kripken.github.io/emscripten-site/docs/getting_started/downloads.html). Installing Emscripten might be a bit tiring for some, I know for me it was, but if you're hyped about writing native code in the browser as much as I do, take as much time as needed to install it, and bare with me.\n\nAssuming that you have Emscripten installed, we can get right to business. The goal for this step is to re-implement our geometry namespace in C++, and to be more specific, the circle class and line class. We will start by creating an entry file for our C++ code under the path `resources/cpp/src/index.cpp`:\n\n    $ mkdir resources/cpp\n    $ mkdir resources/cpp/src\n    $ touch resources/cpp/src/index.cpp\n\nFrom now on, every C++ file that we would like to run in the browser should be included in the `index.cpp` file we've just created, otherwise it's not going to appear anywhere. The first stage for re-implementing our geometry would be re-writing the utility module, since our geometry is heavily based on it; Therefore the firs inclusion in our `index.cpp` file would be the following:\n\n[{]: <helper> (diffStep 7.1)\n\n#### [Step 7.1: Add CPP entry script](https://github.com/DAB0mB/radial-snake/commit/2f35323)\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;index.cpp\n```diff\n@@ -0,0 +1 @@\n+â”Š â”Š1â”Š#include \"utils.cpp\"ðŸš«â†µ\n```\n\n[}]: #\n\nFollowing that, we will create the `utils.cpp` module included above, which is a direct translation from C++ to JavaScript for the `utils.js` we've created earlier in this tutorial.\n\n[{]: <helper> (diffStep 7.2)\n\n#### [Step 7.2: Add base utility CPP module](https://github.com/DAB0mB/radial-snake/commit/6dba512)\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;utils.cpp\n```diff\n@@ -0,0 +1,73 @@\n+â”Š  â”Š 1â”Š#include <cfloat>\n+â”Š  â”Š 2â”Š#include <cmath>\n+â”Š  â”Š 3â”Š#include <string>\n+â”Š  â”Š 4â”Š#include \"utils.h\"\n+â”Š  â”Š 5â”Š\n+â”Š  â”Š 6â”Šnamespace utils {\n+â”Š  â”Š 7â”Š  // Fixed modulo method which can calculate modulo of negative numbers properly\n+â”Š  â”Š 8â”Š  // e.g. (-803).mod(800) returns 797\n+â”Š  â”Š 9â”Š  double mod(double context, double num) {\n+â”Š  â”Š10â”Š    return std::fmod((std::fmod(context, num) + num), num);\n+â”Š  â”Š11â”Š  }\n+â”Š  â”Š12â”Š\n+â”Š  â”Š13â”Š  // Trims number and leaves the number of decimals specified.\n+â”Š  â”Š14â”Š  // The \"mode\" argument specifies which math function should be invoked\n+â”Š  â”Š15â”Š  // right after the number has been trimmed.\n+â”Š  â”Š16â”Š  // e.g. 12.12345.trim(3, \"ceil\") returns 12.124\n+â”Š  â”Š17â”Š  double trim(double context, int decimals, const std::string mode) {\n+â”Š  â”Š18â”Š    double accumulator = context * std::pow(10, decimals);\n+â”Š  â”Š19â”Š\n+â”Š  â”Š20â”Š    if (mode.compare(\"ceil\") == 0)\n+â”Š  â”Š21â”Š      accumulator = std::ceil(accumulator);\n+â”Š  â”Š22â”Š    else if (mode.compare(\"floor\") == 0)\n+â”Š  â”Š23â”Š      accumulator = std::floor(accumulator);\n+â”Š  â”Š24â”Š    else\n+â”Š  â”Š25â”Š      accumulator = std::round(accumulator);\n+â”Š  â”Š26â”Š\n+â”Š  â”Š27â”Š    return accumulator / std::pow(10, decimals);\n+â”Š  â”Š28â”Š  }\n+â”Š  â”Š29â”Š\n+â”Š  â”Š30â”Š  // Tells if number is in specified range based on given precision.\n+â”Š  â”Š31â”Š  // See the \"compare\" method for more information about precision\n+â”Š  â”Š32â”Š  bool isBetween(double context, double num1, double num2, const std::string precision) {\n+â”Š  â”Š33â”Š    return compare(context, std::min(num1, num2), \">=\", precision) &&\n+â”Š  â”Š34â”Š           compare(context, std::max(num1, num2), \"<=\", precision);\n+â”Š  â”Š35â”Š  }\n+â”Š  â”Š36â”Š\n+â”Š  â”Š37â”Š  bool compare(double context, double num, const std::string precision) {\n+â”Š  â”Š38â”Š    return compare(context, num, \"==\", precision);\n+â”Š  â”Š39â”Š  }\n+â”Š  â”Š40â”Š\n+â”Š  â”Š41â”Š  // Initiates comparison operator between context number and a given number, only here\n+â”Š  â”Š42â”Š  // a precision can be specified\n+â”Š  â”Š43â”Š  bool compare(double context, double num, const std::string method, const std::string precision) {\n+â”Š  â”Š44â”Š    // Fixed precision, \"almost equal\" with a deviation of Îµ\n+â”Š  â”Š45â”Š    if (precision.compare(\"f\") == 0) {\n+â”Š  â”Š46â”Š      if (method.compare(\"<\") == 0 ||\n+â”Š  â”Š47â”Š          method.compare(\"<=\") == 0)\n+â”Š  â”Š48â”Š        return context <= num + DBL_EPSILON;\n+â”Š  â”Š49â”Š      if (method.compare(\">\") == 0 ||\n+â”Š  â”Š50â”Š          method.compare(\">=\") == 0)\n+â”Š  â”Š51â”Š        return context >= num - DBL_EPSILON;\n+â”Š  â”Š52â”Š      return std::abs(context - num) <= DBL_EPSILON;\n+â”Š  â”Š53â”Š    }\n+â”Š  â”Š54â”Š    // Pixel precision, round comparison\n+â”Š  â”Š55â”Š    else if (precision.compare(\"px\") == 0) {\n+â”Š  â”Š56â”Š      if (method.compare(\"<\") == 0 ||\n+â”Š  â”Š57â”Š          method.compare(\"<=\") == 0)\n+â”Š  â”Š58â”Š        return std::round(context) <= std::round(num);\n+â”Š  â”Š59â”Š      if (method.compare(\">\") == 0 ||\n+â”Š  â”Š60â”Š          method.compare(\">=\") == 0)\n+â”Š  â”Š61â”Š        return std::round(context) >= std::round(num);\n+â”Š  â”Š62â”Š      return std::round(context) == std::round(num);\n+â”Š  â”Š63â”Š    }\n+â”Š  â”Š64â”Š    // Exact precision\n+â”Š  â”Š65â”Š    else {\n+â”Š  â”Š66â”Š      if (method.compare(\"<\") == 0) return context < num;\n+â”Š  â”Š67â”Š      if (method.compare(\"<=\") == 0) return context <= num;\n+â”Š  â”Š68â”Š      if (method.compare(\">\") == 0) return context > num;\n+â”Š  â”Š69â”Š      if (method.compare(\">=\") == 0) return context >= num;\n+â”Š  â”Š70â”Š      return context == num;\n+â”Š  â”Š71â”Š    }\n+â”Š  â”Š72â”Š  }\n+â”Š  â”Š73â”Š}ðŸš«â†µ\n```\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;utils.h\n```diff\n@@ -0,0 +1,15 @@\n+â”Š  â”Š 1â”Š#pragma once\n+â”Š  â”Š 2â”Š\n+â”Š  â”Š 3â”Š#include <string>\n+â”Š  â”Š 4â”Š\n+â”Š  â”Š 5â”Šnamespace utils {\n+â”Š  â”Š 6â”Š  double mod(double context, double num);\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Š  double trim(double context, int decimals, const std::string mode = \"round\");\n+â”Š  â”Š 9â”Š\n+â”Š  â”Š10â”Š  bool isBetween(double context, double num1, double num2, const std::string precision = \"exact\");\n+â”Š  â”Š11â”Š\n+â”Š  â”Š12â”Š  bool compare(double context, double num, const std::string precision = \"exact\");\n+â”Š  â”Š13â”Š\n+â”Š  â”Š14â”Š  bool compare(double context, double num, const std::string method, const std::string precision);\n+â”Š  â”Š15â”Š}ðŸš«â†µ\n```\n\n[}]: #\n\nThe module above should work by itself when interacting with it inside the C++ scope, but that's not what we're striving for. We want this module to be available for use in our JavaScript project. This requires us to wrap our code in such a way the the Emscripten compiler will know how to compile it. Apart from providing a compiler, Emscripten provides us with functions and macros that will help use bind our C++ code to the JavaScript environment. These functionalities are packed in a single library which can be imported in our C++ code, and it is called [Embind](https://kripken.github.io/emscripten-site/docs/porting/connecting_cpp_and_javascript/embind.html) (probably stands for \"Emscripten bind\"). Using EMBind, let's wrap our utils module accordingly:\n\n[{]: <helper> (diffStep 7.3)\n\n#### [Step 7.3: EMBind CPP utils](https://github.com/DAB0mB/radial-snake/commit/0f34332)\n\n##### Changed resources&#x2F;cpp&#x2F;src&#x2F;utils.cpp\n```diff\n@@ -1,6 +1,7 @@\n â”Š1â”Š1â”Š#include <cfloat>\n â”Š2â”Š2â”Š#include <cmath>\n â”Š3â”Š3â”Š#include <string>\n+â”Š â”Š4â”Š#include <emscripten/bind.h>\n â”Š4â”Š5â”Š#include \"utils.h\"\n â”Š5â”Š6â”Š\n â”Š6â”Š7â”Šnamespace utils {\n```\n```diff\n@@ -70,4 +71,15 @@\n â”Š70â”Š71â”Š      return context == num;\n â”Š71â”Š72â”Š    }\n â”Š72â”Š73â”Š  }\n+â”Š  â”Š74â”Š}\n+â”Š  â”Š75â”Š\n+â”Š  â”Š76â”ŠEMSCRIPTEN_BINDINGS(utils_module) {\n+â”Š  â”Š77â”Š  emscripten::function(\"utils_mod\", &utils::mod);\n+â”Š  â”Š78â”Š  emscripten::function(\"utils_trim\", &utils::trim);\n+â”Š  â”Š79â”Š  emscripten::function(\"utils_isBetween\", &utils::isBetween);\n+â”Š  â”Š80â”Š  emscripten::function(\"utils_compare\",\n+â”Š  â”Š81â”Š    emscripten::select_overload<bool(double, double, const std::string, const std::string)>(\n+â”Š  â”Š82â”Š      &utils::compare\n+â”Š  â”Š83â”Š    )\n+â”Š  â”Š84â”Š  );\n â”Š73â”Š85â”Š}ðŸš«â†µ\n```\n\n[}]: #\n\nAfter a while you'll get used for Embind's API. If you'll look at it, it's self explanatory and easy to understand. Bound objects will be available the JavaScript environment will be available under an object named `Module`, e.g. the C++ method `mod` will be available for use as `Module.utils_mod`. Bound functions should have supported return types and argument types, meaning that if we're using a custom structure as a return type or an argument type, we first need to wrap it using EMBind, otherwise the compiler won't know how to handle it. A list of natively supported data-types can be found [here](https://kripken.github.io/emscripten-site/docs/porting/connecting_cpp_and_javascript/embind.html#built-in-type-conversions).\n\nEven though we've wrapped our C++ code and hypothetically it can already be used in the browser, I'd go for a second wrapper, since the compiled code doesn't have the optimal architecture. Right now we will have to approach C++ utility functions using `Module.utils_foo`. Instead, I'd like it to be `CPP.Utils.foo`, since it's clearer this way. The output of the Emscripten compiler can be wrapped with JavaScript code, using a prefix and a suffix, defined in 2 separate files respectively, called `pre.js` and `post.js`:\n\n[{]: <helper> (diffStep 7.4)\n\n#### [Step 7.4: Create CPP wrappers](https://github.com/DAB0mB/radial-snake/commit/cc28a34)\n\n##### Added resources&#x2F;cpp&#x2F;post.js\n```diff\n@@ -0,0 +1,10 @@\n+â”Š  â”Š 1â”Šreturn {\n+â”Š  â”Š 2â”Š  Utils: {\n+â”Š  â”Š 3â”Š    mod: Module.utils_mod,\n+â”Š  â”Š 4â”Š    trim: Module.utils_trim,\n+â”Š  â”Š 5â”Š    isBetween: Module.utils_isBetween,\n+â”Š  â”Š 6â”Š    compare: Module.utils_compare\n+â”Š  â”Š 7â”Š  }\n+â”Š  â”Š 8â”Š};\n+â”Š  â”Š 9â”Š\n+â”Š  â”Š10â”Š})();ðŸš«â†µ\n```\n\n##### Added resources&#x2F;cpp&#x2F;pre.js\n```diff\n@@ -0,0 +1 @@\n+â”Š â”Š1â”ŠCPP = (function() {ðŸš«â†µ\n```\n\n[}]: #\n\nWhat we've done in the code snippet above, we've created an anonymous function which calls itself, and inside we've exported a new namespace called `CPP` (C++). This way we can keep the generated code encapsulated, without worrying about spamming the global object.\n\nAfter creating a wrapper, I'd also recommend you to integrate the generated C++ code into existing namespaces, meaning that if for example we would like to approach the `CPP.Utils.foo` method, it could be done using `Utils.foo`. This way existing code won't have to be changed, and extra wrapping logic can be applied with ease, like the chaining logic implemented in the `Utils` namespace:\n\n[{]: <helper> (diffStep 7.5)\n\n#### [Step 7.5: Bind CPP utils to JS utils](https://github.com/DAB0mB/radial-snake/commit/0a67d50)\n\n##### Changed resources&#x2F;scripts&#x2F;utils.js\n```diff\n@@ -16,53 +16,9 @@\n â”Š16â”Š16â”Š  return chain;\n â”Š17â”Š17â”Š};\n â”Š18â”Š18â”Š\n-â”Š19â”Š  â”Š// Fixed modulo method which can calculate modulo of negative numbers properly\n-â”Š20â”Š  â”Š// e.g. (-803).mod(800) returns 797\n-â”Š21â”Š  â”ŠUtils.mod = function (context, num) {\n-â”Š22â”Š  â”Š  return ((context % num) + num) % num;\n-â”Š23â”Š  â”Š};\n-â”Š24â”Š  â”Š\n-â”Š25â”Š  â”Š// Trims number and leaves the number of decimals specified.\n-â”Š26â”Š  â”Š// The \"mode\" argument specifies which math function should be invoked\n-â”Š27â”Š  â”Š// right after the number has been trimmed.\n-â”Š28â”Š  â”Š// e.g. 12.12345.trim(3, \"ceil\") returns 12.124\n-â”Š29â”Š  â”ŠUtils.trim = function (context, decimals, mode = \"round\") {\n-â”Š30â”Š  â”Š  return Math[mode](context * Math.pow(10, decimals)) / Math.pow(10, decimals);\n-â”Š31â”Š  â”Š};\n-â”Š32â”Š  â”Š\n-â”Š33â”Š  â”Š// Tells if number is in specified range based on given precision.\n-â”Š34â”Š  â”Š// See the \"compare\" method for more information about precision\n-â”Š35â”Š  â”ŠUtils.isBetween = function (context, num1, num2, precision) {\n-â”Š36â”Š  â”Š  return Utils.compare(context, Math.min(num1, num2), \">=\", precision) &&\n-â”Š37â”Š  â”Š         Utils.compare(context, Math.max(num1, num2), \"<=\", precision);\n-â”Š38â”Š  â”Š};\n-â”Š39â”Š  â”Š\n-â”Š40â”Š  â”Š// Initiates comparison operator between context number and a given number, only here\n-â”Š41â”Š  â”Š// a precision can be specified\n-â”Š42â”Š  â”ŠUtils.compare = function (context, num, method, precision = method) {\n-â”Š43â”Š  â”Š  switch (precision) {\n-â”Š44â”Š  â”Š    // Fixed precision, \"almost equal\" with a deviation of Îµ\n-â”Š45â”Š  â”Š    case \"f\":\n-â”Š46â”Š  â”Š      switch (method) {\n-â”Š47â”Š  â”Š        case \"<\": case \"<=\": return context <= num + Number.EPSILON;\n-â”Š48â”Š  â”Š        case \">\": case \">=\": return context >= num - Number.EPSILON;\n-â”Š49â”Š  â”Š        default: return Math.abs(context - num) <= Number.EPSILON;\n-â”Š50â”Š  â”Š      }\n-â”Š51â”Š  â”Š    // Pixel precision, round comparison\n-â”Š52â”Š  â”Š    case \"px\":\n-â”Š53â”Š  â”Š      switch (method) {\n-â”Š54â”Š  â”Š        case \"<\": case \"<=\": return Math.round(context) <= Math.round(num);\n-â”Š55â”Š  â”Š        case \">\": case \">=\": return Math.round(context) >= Math.round(num);\n-â”Š56â”Š  â”Š        default: return Math.round(context) == Math.round(num);\n-â”Š57â”Š  â”Š      }\n-â”Š58â”Š  â”Š    // Exact precision\n-â”Š59â”Š  â”Š    default:\n-â”Š60â”Š  â”Š      switch (method) {\n-â”Š61â”Š  â”Š        case \"<\": return context < num;\n-â”Š62â”Š  â”Š        case \"<=\": return context <= num;\n-â”Š63â”Š  â”Š        case \">\": return context > num;\n-â”Š64â”Š  â”Š        case \">=\": return context >= num;\n-â”Š65â”Š  â”Š        default: return context === num;\n-â”Š66â”Š  â”Š      }\n+â”Š  â”Š19â”ŠObject.assign(Utils, CPP.Utils, {\n+â”Š  â”Š20â”Š  // Overload handling\n+â”Š  â”Š21â”Š  compare(context, num, method, precision = method) {\n+â”Š  â”Š22â”Š    return CPP.Utils.compare(context, num, method, precision);\n â”Š67â”Š23â”Š  }\n-â”Š68â”Š  â”Š};ðŸš«â†µ\n+â”Š  â”Š24â”Š});ðŸš«â†µ\n```\n\n[}]: #\n\nWhenever launching the compiler, the generated code should be outputted somewhere. I've decided to go with the path `resources/scripts/cpp.bundle.js`, but it doesn't matter how the file is gonna be called, as long as it's defined under the `scripts` dir, otherwise we won't be able to load it. Also, we need to make sure that we set a git-ignore rule for the generated file, since there's no reason for us to upload it to the git-host if we're planning on compiling it:\n\n[{]: <helper> (diffStep 7.5)\n\n#### [Step 7.5: Bind CPP utils to JS utils](https://github.com/DAB0mB/radial-snake/commit/0a67d50)\n\n##### Changed resources&#x2F;scripts&#x2F;utils.js\n```diff\n@@ -16,53 +16,9 @@\n â”Š16â”Š16â”Š  return chain;\n â”Š17â”Š17â”Š};\n â”Š18â”Š18â”Š\n-â”Š19â”Š  â”Š// Fixed modulo method which can calculate modulo of negative numbers properly\n-â”Š20â”Š  â”Š// e.g. (-803).mod(800) returns 797\n-â”Š21â”Š  â”ŠUtils.mod = function (context, num) {\n-â”Š22â”Š  â”Š  return ((context % num) + num) % num;\n-â”Š23â”Š  â”Š};\n-â”Š24â”Š  â”Š\n-â”Š25â”Š  â”Š// Trims number and leaves the number of decimals specified.\n-â”Š26â”Š  â”Š// The \"mode\" argument specifies which math function should be invoked\n-â”Š27â”Š  â”Š// right after the number has been trimmed.\n-â”Š28â”Š  â”Š// e.g. 12.12345.trim(3, \"ceil\") returns 12.124\n-â”Š29â”Š  â”ŠUtils.trim = function (context, decimals, mode = \"round\") {\n-â”Š30â”Š  â”Š  return Math[mode](context * Math.pow(10, decimals)) / Math.pow(10, decimals);\n-â”Š31â”Š  â”Š};\n-â”Š32â”Š  â”Š\n-â”Š33â”Š  â”Š// Tells if number is in specified range based on given precision.\n-â”Š34â”Š  â”Š// See the \"compare\" method for more information about precision\n-â”Š35â”Š  â”ŠUtils.isBetween = function (context, num1, num2, precision) {\n-â”Š36â”Š  â”Š  return Utils.compare(context, Math.min(num1, num2), \">=\", precision) &&\n-â”Š37â”Š  â”Š         Utils.compare(context, Math.max(num1, num2), \"<=\", precision);\n-â”Š38â”Š  â”Š};\n-â”Š39â”Š  â”Š\n-â”Š40â”Š  â”Š// Initiates comparison operator between context number and a given number, only here\n-â”Š41â”Š  â”Š// a precision can be specified\n-â”Š42â”Š  â”ŠUtils.compare = function (context, num, method, precision = method) {\n-â”Š43â”Š  â”Š  switch (precision) {\n-â”Š44â”Š  â”Š    // Fixed precision, \"almost equal\" with a deviation of Îµ\n-â”Š45â”Š  â”Š    case \"f\":\n-â”Š46â”Š  â”Š      switch (method) {\n-â”Š47â”Š  â”Š        case \"<\": case \"<=\": return context <= num + Number.EPSILON;\n-â”Š48â”Š  â”Š        case \">\": case \">=\": return context >= num - Number.EPSILON;\n-â”Š49â”Š  â”Š        default: return Math.abs(context - num) <= Number.EPSILON;\n-â”Š50â”Š  â”Š      }\n-â”Š51â”Š  â”Š    // Pixel precision, round comparison\n-â”Š52â”Š  â”Š    case \"px\":\n-â”Š53â”Š  â”Š      switch (method) {\n-â”Š54â”Š  â”Š        case \"<\": case \"<=\": return Math.round(context) <= Math.round(num);\n-â”Š55â”Š  â”Š        case \">\": case \">=\": return Math.round(context) >= Math.round(num);\n-â”Š56â”Š  â”Š        default: return Math.round(context) == Math.round(num);\n-â”Š57â”Š  â”Š      }\n-â”Š58â”Š  â”Š    // Exact precision\n-â”Š59â”Š  â”Š    default:\n-â”Š60â”Š  â”Š      switch (method) {\n-â”Š61â”Š  â”Š        case \"<\": return context < num;\n-â”Š62â”Š  â”Š        case \"<=\": return context <= num;\n-â”Š63â”Š  â”Š        case \">\": return context > num;\n-â”Š64â”Š  â”Š        case \">=\": return context >= num;\n-â”Š65â”Š  â”Š        default: return context === num;\n-â”Š66â”Š  â”Š      }\n+â”Š  â”Š19â”ŠObject.assign(Utils, CPP.Utils, {\n+â”Š  â”Š20â”Š  // Overload handling\n+â”Š  â”Š21â”Š  compare(context, num, method, precision = method) {\n+â”Š  â”Š22â”Š    return CPP.Utils.compare(context, num, method, precision);\n â”Š67â”Š23â”Š  }\n-â”Š68â”Š  â”Š};ðŸš«â†µ\n+â”Š  â”Š24â”Š});ðŸš«â†µ\n```\n\n[}]: #\n\nTo compile our C++ code and turn it into JavaScript, we'll need to run the following command:\n\n    $ emcc -O1 --pre-js resources/cpp/pre.js --post-js resources/cpp/post.js --bind -o resources/scripts/cpp.bundle.js resources/cpp/src/index.cpp\n\nHere's a detailed list with explanations regards the arguments vector we've just passed:\n\n- `-01` - Optimization level 1. The higher the index, the more optimized our code is gonna be, but less readable.\n- `--pre-js` - Specifies a JavaScript prefix for the compiled code.\n- `--post-js` - Specifies a JavaScript postfix for the compiled code.\n- `--bind` - Tells the compiler to use Embind\n- `-o` - The output path.\n\n> More informations regards Emscripten's CLI can be found [here](https://kripken.github.io/emscripten-site/docs/tools_reference/emcc.html).\n\nYou don't have to memorize the compilation command we've just typed, because we're gonna save it as an NPM script called `build:cpp`:\n\n[{]: <helper> (diffStep 7.6)\n\n#### [Step 7.6: Add ignore rule to CPP bundle](https://github.com/DAB0mB/radial-snake/commit/f4a75cf)\n\n##### Changed .gitignore\n```diff\n@@ -1,3 +1,4 @@\n â”Š1â”Š1â”Šnode_modules\n â”Š2â”Š2â”Šnpm-debug.log\n-â”Š3â”Š â”Šresources/assets/fonts/*.jsonðŸš«â†µ\n+â”Š â”Š3â”Šresources/assets/fonts/*.json\n+â”Š â”Š4â”Šresources/scripts/cpp.bundle.jsðŸš«â†µ\n```\n\n[}]: #\n\nNow if you'd like to compile the C++ code just run:\n\n    $ npm run build:cpp\n\nMoreover, the code should be compiled automatically any time you start the serer using the command:\n\n    $ npm run serve\n\nWe always have to be on the alert and run our tests against modules we've just translated from JavaScript to C++. This will guarantee that once we run the game we won't stumble upon any defect whatsoever. Before running the tests, be sure to import the C++ bundle in the HTML file's header:\n\n[{]: <helper> (diffStep 7.8)\n\n#### [Step 7.8: Load CPP bundle in spec runner](https://github.com/DAB0mB/radial-snake/commit/0d1bd08)\n\n##### Changed views&#x2F;spec_runner.html\n```diff\n@@ -16,6 +16,7 @@\n â”Š16â”Š16â”Š    <script type=\"text/javascript\" src=\"libs/underscore.js\"></script>\n â”Š17â”Š17â”Š\n â”Š18â”Š18â”Š    <!-- Scripts -->\n+â”Š  â”Š19â”Š    <script type=\"text/javascript\" src=\"scripts/cpp.bundle.js\"></script>\n â”Š19â”Š20â”Š    <script type=\"text/javascript\" src=\"scripts/utils.js\"></script>\n â”Š20â”Š21â”Š    <script type=\"text/javascript\" src=\"scripts/namespaces.js\"></script>\n â”Š21â”Š22â”Š    <script type=\"text/javascript\" src=\"scripts/engine/geometry/line.js\"></script>\n```\n\n[}]: #\n\nNow we can run the tests by running the following command:\n\n    $ npm run test\n\nAt this point **all our tests should pass**. If they don't, it means our newly created utility module is not working properly, and you will have to repeat the previous steps until you get it right.\n\nUp next, we gonna translate the geometry line class to C++. Since it's gonna be translated almost identically, we will have to make sure that all the necessary assets are gonna be available for our class before proceeding. The first thing we will have to do would be making sure that the utility functions are chainable directly from C++ as well. To do that, we will create a chain class which should return a new instance of it whenever we're about to chain the upcoming utility method. Once calling `result()`, the accumulator should be returned:\n\n[{]: <helper> (diffStep 7.9)\n\n#### [Step 7.9: Add chaining method to CPP utils](https://github.com/DAB0mB/radial-snake/commit/0927eea)\n\n##### Changed resources&#x2F;cpp&#x2F;src&#x2F;utils.cpp\n```diff\n@@ -5,6 +5,61 @@\n â”Š 5â”Š 5â”Š#include \"utils.h\"\n â”Š 6â”Š 6â”Š\n â”Š 7â”Š 7â”Šnamespace utils {\n+â”Š  â”Š 8â”Š  template<typename T>\n+â”Š  â”Š 9â”Š  Chain<T>::Chain(T accumulator): _accumulator(accumulator) {\n+â”Š  â”Š10â”Š  }\n+â”Š  â”Š11â”Š\n+â”Š  â”Š12â”Š  template<>\n+â”Š  â”Š13â”Š  Chain<double>* Chain<double>::mod(double num) {\n+â”Š  â”Š14â”Š    double result = utils::mod(_accumulator, num);\n+â”Š  â”Š15â”Š    Chain<double>* chain = new Chain<double>(result);\n+â”Š  â”Š16â”Š    delete this;\n+â”Š  â”Š17â”Š    return chain;\n+â”Š  â”Š18â”Š  }\n+â”Š  â”Š19â”Š\n+â”Š  â”Š20â”Š  template<>\n+â”Š  â”Š21â”Š  Chain<double>* Chain<double>::trim(int decimals, const std::string mode) {\n+â”Š  â”Š22â”Š    double result = utils::trim(_accumulator, decimals, mode);\n+â”Š  â”Š23â”Š    Chain<double>* chain = new Chain<double>(result);\n+â”Š  â”Š24â”Š    delete this;\n+â”Š  â”Š25â”Š    return chain;\n+â”Š  â”Š26â”Š  }\n+â”Š  â”Š27â”Š\n+â”Š  â”Š28â”Š  template<>\n+â”Š  â”Š29â”Š  Chain<bool>* Chain<double>::isBetween(double num1, double num2, const std::string precision) {\n+â”Š  â”Š30â”Š    bool result = utils::isBetween(_accumulator, num1, num2, precision);\n+â”Š  â”Š31â”Š    Chain<bool>* chain = new Chain<bool>(result);\n+â”Š  â”Š32â”Š    delete this;\n+â”Š  â”Š33â”Š    return chain;\n+â”Š  â”Š34â”Š  }\n+â”Š  â”Š35â”Š\n+â”Š  â”Š36â”Š  template<>\n+â”Š  â”Š37â”Š  Chain<bool>* Chain<double>::compare(double num, const std::string precision) {\n+â”Š  â”Š38â”Š    bool result = utils::compare(_accumulator, num, precision);\n+â”Š  â”Š39â”Š    Chain<bool>* chain = new Chain<bool>(result);\n+â”Š  â”Š40â”Š    delete this;\n+â”Š  â”Š41â”Š    return chain;\n+â”Š  â”Š42â”Š  }\n+â”Š  â”Š43â”Š\n+â”Š  â”Š44â”Š  template<>\n+â”Š  â”Š45â”Š  Chain<bool>* Chain<double>::compare(double num, const std::string method, const std::string precision) {\n+â”Š  â”Š46â”Š    bool result = utils::compare(_accumulator, num, method, precision);\n+â”Š  â”Š47â”Š    Chain<bool>* chain = new Chain<bool>(result);\n+â”Š  â”Š48â”Š    delete this;\n+â”Š  â”Š49â”Š    return chain;\n+â”Š  â”Š50â”Š  }\n+â”Š  â”Š51â”Š\n+â”Š  â”Š52â”Š  template<typename T>\n+â”Š  â”Š53â”Š  T Chain<T>::result() {\n+â”Š  â”Š54â”Š    delete this;\n+â”Š  â”Š55â”Š    return _accumulator;\n+â”Š  â”Š56â”Š  }\n+â”Š  â”Š57â”Š\n+â”Š  â”Š58â”Š  template<typename T>\n+â”Š  â”Š59â”Š  Chain<T>* chain(T accumulator) {\n+â”Š  â”Š60â”Š    return new Chain<T>(accumulator);\n+â”Š  â”Š61â”Š  }\n+â”Š  â”Š62â”Š\n â”Š 8â”Š63â”Š  // Fixed modulo method which can calculate modulo of negative numbers properly\n â”Š 9â”Š64â”Š  // e.g. (-803).mod(800) returns 797\n â”Š10â”Š65â”Š  double mod(double context, double num) {\n```\n\n##### Changed resources&#x2F;cpp&#x2F;src&#x2F;utils.h\n```diff\n@@ -3,6 +3,30 @@\n â”Š 3â”Š 3â”Š#include <string>\n â”Š 4â”Š 4â”Š\n â”Š 5â”Š 5â”Šnamespace utils {\n+â”Š  â”Š 6â”Š  template<typename T>\n+â”Š  â”Š 7â”Š  class Chain {\n+â”Š  â”Š 8â”Š  private:\n+â”Š  â”Š 9â”Š    T _accumulator;\n+â”Š  â”Š10â”Š\n+â”Š  â”Š11â”Š  public:\n+â”Š  â”Š12â”Š    Chain(T accumulator);\n+â”Š  â”Š13â”Š\n+â”Š  â”Š14â”Š    Chain<double>* mod(double num);\n+â”Š  â”Š15â”Š\n+â”Š  â”Š16â”Š    Chain<double>* trim(int decimals, const std::string mode = \"round\");\n+â”Š  â”Š17â”Š\n+â”Š  â”Š18â”Š    Chain<bool>* isBetween(double num1, double num2, const std::string precision = \"exact\");\n+â”Š  â”Š19â”Š\n+â”Š  â”Š20â”Š    Chain<bool>* compare(double num, const std::string precision = \"exact\");\n+â”Š  â”Š21â”Š\n+â”Š  â”Š22â”Š    Chain<bool>* compare(double num, const std::string method, const std::string precision);\n+â”Š  â”Š23â”Š\n+â”Š  â”Š24â”Š    T result();\n+â”Š  â”Š25â”Š  };\n+â”Š  â”Š26â”Š\n+â”Š  â”Š27â”Š  template<typename T>\n+â”Š  â”Š28â”Š  Chain<T>* chain(T accumulator);\n+â”Š  â”Š29â”Š\n â”Š 6â”Š30â”Š  double mod(double context, double num);\n â”Š 7â”Š31â”Š\n â”Š 8â”Š32â”Š  double trim(double context, int decimals, const std::string mode = \"round\");\n```\n\n[}]: #\n\n> Note that when coding in C++ we have to make sure that the objects are being disposed when not needed anymore, otherwise we will have some unnecessary memory leaks.\n\n2D shapes are presented in space using points with 2 values - `x` (axis) and `y` axis, therefore, we will create the appropriate point structure:\n\n[{]: <helper> (diffStep 7.1)\n\n#### [Step 7.1: Add CPP entry script](https://github.com/DAB0mB/radial-snake/commit/2f35323)\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;index.cpp\n```diff\n@@ -0,0 +1 @@\n+â”Š â”Š1â”Š#include \"utils.cpp\"ðŸš«â†µ\n```\n\n[}]: #\n\nReturned values can either be `null` (`undefined`) or not. Since there's no built in nullable-values mechanism in C++ (up until C++17), we're gonna create one of our own:\n\n[{]: <helper> (diffStep 7.11)\n\n#### [Step 7.11: Add nullable class](https://github.com/DAB0mB/radial-snake/commit/41b2f7c)\n\n##### Changed resources&#x2F;cpp&#x2F;src&#x2F;index.cpp\n```diff\n@@ -1 +1,2 @@\n+â”Š â”Š1â”Š#include \"nullable.cpp\"\n â”Š1â”Š2â”Š#include \"utils.cpp\"ðŸš«â†µ\n```\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;nullable.cpp\n```diff\n@@ -0,0 +1,37 @@\n+â”Š  â”Š 1â”Š#include \"nullable.h\"\n+â”Š  â”Š 2â”Š\n+â”Š  â”Š 3â”Štemplate <typename T>\n+â”Š  â”Š 4â”ŠNullable<T>::Nullable(T value): _value(value), _initialized(true) {\n+â”Š  â”Š 5â”Š\n+â”Š  â”Š 6â”Š}\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Štemplate <typename T>\n+â”Š  â”Š 9â”ŠNullable<T>::Nullable(): _initialized(false) {\n+â”Š  â”Š10â”Š\n+â”Š  â”Š11â”Š}\n+â”Š  â”Š12â”Š\n+â”Š  â”Š13â”Štemplate <typename T>\n+â”Š  â”Š14â”ŠT Nullable<T>::getValue() const {\n+â”Š  â”Š15â”Š  return _value;\n+â”Š  â”Š16â”Š}\n+â”Š  â”Š17â”Š\n+â”Š  â”Š18â”Štemplate <typename T>\n+â”Š  â”Š19â”Švoid Nullable<T>::setValue(T value) {\n+â”Š  â”Š20â”Š  _value = value;\n+â”Š  â”Š21â”Š  _initialized = true;\n+â”Š  â”Š22â”Š}\n+â”Š  â”Š23â”Š\n+â”Š  â”Š24â”Štemplate <typename T>\n+â”Š  â”Š25â”Švoid Nullable<T>::resetValue() {\n+â”Š  â”Š26â”Š  _initialized = false;\n+â”Š  â”Š27â”Š}\n+â”Š  â”Š28â”Š\n+â”Š  â”Š29â”Štemplate <typename T>\n+â”Š  â”Š30â”Šbool Nullable<T>::hasValue() const {\n+â”Š  â”Š31â”Š  return _initialized == true;\n+â”Š  â”Š32â”Š}\n+â”Š  â”Š33â”Š\n+â”Š  â”Š34â”Štemplate <typename T>\n+â”Š  â”Š35â”Šbool Nullable<T>::isNull() const {\n+â”Š  â”Š36â”Š  return _initialized == false;\n+â”Š  â”Š37â”Š}ðŸš«â†µ\n```\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;nullable.h\n```diff\n@@ -0,0 +1,23 @@\n+â”Š  â”Š 1â”Š#pragma once\n+â”Š  â”Š 2â”Š\n+â”Š  â”Š 3â”Štemplate <typename T>\n+â”Š  â”Š 4â”Šclass Nullable {\n+â”Š  â”Š 5â”Šprivate:\n+â”Š  â”Š 6â”Š  T _value;\n+â”Š  â”Š 7â”Š  bool _initialized;\n+â”Š  â”Š 8â”Š\n+â”Š  â”Š 9â”Špublic:\n+â”Š  â”Š10â”Š  Nullable(T value);\n+â”Š  â”Š11â”Š\n+â”Š  â”Š12â”Š  Nullable();\n+â”Š  â”Š13â”Š\n+â”Š  â”Š14â”Š  T getValue() const;\n+â”Š  â”Š15â”Š\n+â”Š  â”Š16â”Š  void setValue(T value);\n+â”Š  â”Š17â”Š\n+â”Š  â”Š18â”Š  void resetValue();\n+â”Š  â”Š19â”Š\n+â”Š  â”Š20â”Š  bool hasValue() const;\n+â”Š  â”Š21â”Š\n+â”Š  â”Š22â”Š  bool isNull() const;\n+â”Š  â”Š23â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nNow that all the necessary assets for the line class are ready, we can go ahead and create it:\n\n[{]: <helper> (diffStep 7.12)\n\n#### [Step 7.12: Add base line CPP module](https://github.com/DAB0mB/radial-snake/commit/9d17554)\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;geometry&#x2F;line.cpp\n```diff\n@@ -0,0 +1,99 @@\n+â”Š  â”Š 1â”Š#include \"../nullable.h\"\n+â”Š  â”Š 2â”Š#include \"../utils.h\"\n+â”Š  â”Š 3â”Š#include \"point.h\"\n+â”Š  â”Š 4â”Š#include \"line.h\"\n+â”Š  â”Š 5â”Š\n+â”Š  â”Š 6â”Šnamespace geometry {\n+â”Š  â”Š 7â”Š  // x1 - The first point's x value\n+â”Š  â”Š 8â”Š  // y1 - The first point's y value\n+â”Š  â”Š 9â”Š  // x1 - The second point's x value\n+â”Š  â”Š10â”Š  // y2 - The second point's y value\n+â”Š  â”Š11â”Š  Line::Line(double x1, double y1, double x2, double y2) {\n+â”Š  â”Š12â”Š    _x1 = utils::trim(x1, 9);\n+â”Š  â”Š13â”Š    _y1 = utils::trim(y1, 9);\n+â”Š  â”Š14â”Š    _x2 = utils::trim(x2, 9);\n+â”Š  â”Š15â”Š    _y2 = utils::trim(y2, 9);\n+â”Š  â”Š16â”Š  }\n+â”Š  â”Š17â”Š\n+â”Š  â”Š18â”Š  // Gets the matching x value for a given y value\n+â”Š  â”Š19â”Š  Nullable<double> Line::getMatchingX(double y) {\n+â”Š  â”Š20â”Š    // If an error was thrown it means we divided a number by zero,\n+â”Š  â”Š21â”Š    // in which case there is not intersection point\n+â”Š  â”Š22â”Š    double x = utils::trim(\n+â”Š  â”Š23â”Š      (((y - _y1) * (_x2 - _x1)) /\n+â”Š  â”Š24â”Š       (_y2 - _y1)) + _x1\n+â”Š  â”Š25â”Š    , 9, \"exact\");\n+â”Š  â”Š26â”Š\n+â”Š  â”Š27â”Š    // Check if result is in values range\n+â”Š  â”Š28â”Š    if (utils::isBetween(x, _x1, _x2, \"round\")) {\n+â”Š  â”Š29â”Š      return Nullable<double>(x);\n+â”Š  â”Š30â”Š    }\n+â”Š  â”Š31â”Š\n+â”Š  â”Š32â”Š    return Nullable<double>();\n+â”Š  â”Š33â”Š  }\n+â”Š  â”Š34â”Š\n+â”Š  â”Š35â”Š  // Gets the matching y value for a given x value\n+â”Š  â”Š36â”Š  Nullable<double> Line::getMatchingY(double x) {\n+â”Š  â”Š37â”Š    // If an error was thrown it means we divided a number by zero,\n+â”Š  â”Š38â”Š    // in which case there is not intersection point\n+â”Š  â”Š39â”Š    double y = utils::trim(\n+â”Š  â”Š40â”Š      (((x - _x1) * (_y2 - _y1)) /\n+â”Š  â”Š41â”Š       (_x2 - _x1)) + _y1\n+â”Š  â”Š42â”Š    , 9, \"exact\");\n+â”Š  â”Š43â”Š\n+â”Š  â”Š44â”Š    // Check if result is in values range\n+â”Š  â”Š45â”Š    if (utils::isBetween(y, _y1, _y2, \"round\")) {\n+â”Š  â”Š46â”Š      return Nullable<double>(y);\n+â”Š  â”Š47â”Š    }\n+â”Š  â”Š48â”Š\n+â”Š  â”Š49â”Š    return Nullable<double>();\n+â”Š  â”Š50â”Š  }\n+â”Š  â”Š51â”Š\n+â”Š  â”Š52â”Š  // Returns if line has given point\n+â”Š  â”Š53â”Š  bool Line::hasPoint(double x, double y) {\n+â”Š  â”Š54â”Š    if (!boundsHavePoint(x, y)) return 0;\n+â”Š  â”Š55â”Š\n+â”Š  â”Š56â”Š    double m = utils::trim(\n+â”Š  â”Š57â”Š      (_y2 - _y1) / (_x2 - _x1),\n+â”Š  â”Š58â”Š    9, \"exact\");\n+â”Š  â”Š59â”Š\n+â”Š  â”Š60â”Š    return (y - _y1) / (x - _x1) == m;\n+â”Š  â”Š61â”Š  }\n+â”Š  â”Š62â”Š\n+â”Š  â”Š63â”Š  // Returns if given point is contained by the bounds aka cage of line\n+â”Š  â”Š64â”Š  bool Line::boundsHavePoint(double x, double y) {\n+â”Š  â”Š65â”Š    return utils::isBetween(x, _x1, _x2, \"round\") &&\n+â”Š  â”Š66â”Š           utils::isBetween(y, _y1, _y2, \"round\");\n+â”Š  â”Š67â”Š  }\n+â”Š  â”Š68â”Š\n+â”Š  â”Š69â”Š  // line - line intersection method\n+â”Š  â”Š70â”Š  Nullable<Point> Line::getIntersection(Line line) {\n+â”Š  â”Š71â”Š    // Escape if lines are parallel\n+â”Š  â”Š72â”Š    if (!(((_x1 - _x2) * (line._y1 - line._y2)) -\n+â”Š  â”Š73â”Š          ((_y1 - _y2) * (line._x1 - line._x2))))\n+â”Š  â”Š74â”Š      return Nullable<Point>();\n+â”Š  â”Š75â”Š\n+â”Š  â”Š76â”Š    // Intersection point formula\n+â”Š  â”Š77â”Š    double x = utils::trim(\n+â”Š  â”Š78â”Š      ((((_x1 * _y2) - (_y1 * _x2)) * (line._x1 - line._x2)) -\n+â”Š  â”Š79â”Š       ((_x1 - _x2) * ((line._x1 * line._y2) - (line._y1 * line._x2)))) /\n+â”Š  â”Š80â”Š      (((_x1 - _x2) * (line._y1 - line._y2)) - ((_y1 - _y2) *\n+â”Š  â”Š81â”Š        (line._x1 - line._x2)))\n+â”Š  â”Š82â”Š    , 9, \"exact\");\n+â”Š  â”Š83â”Š    double y = utils::trim(\n+â”Š  â”Š84â”Š      ((((_x1 * _y2) - (_y1 * _x2)) * (line._y1 - line._y2)) -\n+â”Š  â”Š85â”Š       ((_y1 - _y2) * ((line._x1 * line._y2) - (line._y1 * line._x2)))) /\n+â”Š  â”Š86â”Š      (((_x1 - _x2) * (line._y1 - line._y2)) - ((_y1 - _y2) *\n+â”Š  â”Š87â”Š        (line._x1 - line._x2)))\n+â”Š  â”Š88â”Š    , 9, \"exact\");\n+â”Š  â”Š89â”Š\n+â”Š  â”Š90â”Š    if (utils::isBetween(x, _x1, _x2, \"round\") &&\n+â”Š  â”Š91â”Š        utils::isBetween(x, line._x1, line._x2, \"round\") &&\n+â”Š  â”Š92â”Š        utils::isBetween(y, _y1, _y2, \"round\") &&\n+â”Š  â”Š93â”Š        utils::isBetween(y, line._y1, line._y2, \"round\")) {\n+â”Š  â”Š94â”Š      return Nullable<Point>({ x, y });\n+â”Š  â”Š95â”Š    }\n+â”Š  â”Š96â”Š\n+â”Š  â”Š97â”Š    return Nullable<Point>();\n+â”Š  â”Š98â”Š  }\n+â”Š  â”Š99â”Š}ðŸš«â†µ\n```\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;geometry&#x2F;line.h\n```diff\n@@ -0,0 +1,30 @@\n+â”Š  â”Š 1â”Š#pragma once\n+â”Š  â”Š 2â”Š\n+â”Š  â”Š 3â”Š#include <vector>\n+â”Š  â”Š 4â”Š#include \"../nullable.h\"\n+â”Š  â”Š 5â”Š#include \"point.h\"\n+â”Š  â”Š 6â”Š\n+â”Š  â”Š 7â”Šnamespace geometry {\n+â”Š  â”Š 8â”Š  class Circle;\n+â”Š  â”Š 9â”Š  class EMCircle;\n+â”Š  â”Š10â”Š\n+â”Š  â”Š11â”Š  class Line {\n+â”Š  â”Š12â”Š  public:\n+â”Š  â”Š13â”Š    double _x1;\n+â”Š  â”Š14â”Š    double _y1;\n+â”Š  â”Š15â”Š    double _x2;\n+â”Š  â”Š16â”Š    double _y2;\n+â”Š  â”Š17â”Š\n+â”Š  â”Š18â”Š    Line(double x1, double y1, double x2, double y2);\n+â”Š  â”Š19â”Š\n+â”Š  â”Š20â”Š    Nullable<double> getMatchingX(double y);\n+â”Š  â”Š21â”Š\n+â”Š  â”Š22â”Š    Nullable<double> getMatchingY(double x);\n+â”Š  â”Š23â”Š\n+â”Š  â”Š24â”Š    bool hasPoint(double x, double y);\n+â”Š  â”Š25â”Š\n+â”Š  â”Š26â”Š    bool boundsHavePoint(double x, double y);\n+â”Š  â”Š27â”Š\n+â”Š  â”Š28â”Š    Nullable<Point> getIntersection(Line line);\n+â”Š  â”Š29â”Š  };\n+â”Š  â”Š30â”Š}ðŸš«â†µ\n```\n\n##### Changed resources&#x2F;cpp&#x2F;src&#x2F;index.cpp\n```diff\n@@ -1,2 +1,3 @@\n â”Š1â”Š1â”Š#include \"nullable.cpp\"\n-â”Š2â”Š â”Š#include \"utils.cpp\"ðŸš«â†µ\n+â”Š â”Š2â”Š#include \"utils.cpp\"\n+â”Š â”Š3â”Š#include \"geometry/line.cpp\"ðŸš«â†µ\n```\n\n[}]: #\n\nAfter creating our C++, we will also need to bind it using EMBind:\n\n[{]: <helper> (diffStep 7.13)\n\n#### [Step 7.13: EMBind CPP line](https://github.com/DAB0mB/radial-snake/commit/8920ddf)\n\n##### Changed resources&#x2F;cpp&#x2F;post.js\n```diff\n@@ -4,6 +4,10 @@\n â”Š 4â”Š 4â”Š    trim: Module.utils_trim,\n â”Š 5â”Š 5â”Š    isBetween: Module.utils_isBetween,\n â”Š 6â”Š 6â”Š    compare: Module.utils_compare\n+â”Š  â”Š 7â”Š  },\n+â”Š  â”Š 8â”Š\n+â”Š  â”Š 9â”Š  Geometry: {\n+â”Š  â”Š10â”Š    Line: Module.geometry_line\n â”Š 7â”Š11â”Š  }\n â”Š 8â”Š12â”Š};\n â”Š 9â”Š13â”Š\n```\n\n##### Changed resources&#x2F;cpp&#x2F;src&#x2F;geometry&#x2F;line.cpp\n```diff\n@@ -1,3 +1,6 @@\n+â”Š â”Š1â”Š#include <vector>\n+â”Š â”Š2â”Š#include <emscripten/bind.h>\n+â”Š â”Š3â”Š#include <emscripten/val.h>\n â”Š1â”Š4â”Š#include \"../nullable.h\"\n â”Š2â”Š5â”Š#include \"../utils.h\"\n â”Š3â”Š6â”Š#include \"point.h\"\n```\n```diff\n@@ -96,4 +99,52 @@\n â”Š 96â”Š 99â”Š\n â”Š 97â”Š100â”Š    return Nullable<Point>();\n â”Š 98â”Š101â”Š  }\n+â”Š   â”Š102â”Š\n+â”Š   â”Š103â”Š  emscripten::val EMLine::getMatchingX(double y) {\n+â”Š   â”Š104â”Š    Nullable<double> nullableX = Line::getMatchingX(y);\n+â”Š   â”Š105â”Š    return nullableX.hasValue() ?\n+â”Š   â”Š106â”Š      emscripten::val(nullableX.getValue()) :\n+â”Š   â”Š107â”Š      emscripten::val::undefined();\n+â”Š   â”Š108â”Š  }\n+â”Š   â”Š109â”Š\n+â”Š   â”Š110â”Š  emscripten::val EMLine::getMatchingY(double x) {\n+â”Š   â”Š111â”Š    Nullable<double> nullableY = Line::getMatchingY(x);\n+â”Š   â”Š112â”Š    return nullableY.hasValue() ?\n+â”Š   â”Š113â”Š      emscripten::val(nullableY.getValue()) :\n+â”Š   â”Š114â”Š      emscripten::val::undefined();\n+â”Š   â”Š115â”Š  }\n+â”Š   â”Š116â”Š\n+â”Š   â”Š117â”Š  emscripten::val EMLine::getIntersection(EMLine emLine) {\n+â”Š   â”Š118â”Š    Line line = Line(emLine._x1, emLine._y1, emLine._x2, emLine._y2);\n+â”Š   â”Š119â”Š    Nullable<Point> nullablePoint = Line::getIntersection(line);\n+â”Š   â”Š120â”Š\n+â”Š   â”Š121â”Š    if (nullablePoint.isNull()) return emscripten::val::undefined();\n+â”Š   â”Š122â”Š\n+â”Š   â”Š123â”Š    Point point = nullablePoint.getValue();\n+â”Š   â”Š124â”Š    emscripten::val emPoint = emscripten::val::object();\n+â”Š   â”Š125â”Š    emPoint.set(\"x\", emscripten::val(point.x));\n+â”Š   â”Š126â”Š    emPoint.set(\"y\", emscripten::val(point.y));\n+â”Š   â”Š127â”Š    return emPoint;\n+â”Š   â”Š128â”Š  }\n+â”Š   â”Š129â”Š}\n+â”Š   â”Š130â”Š\n+â”Š   â”Š131â”ŠEMSCRIPTEN_BINDINGS(geometry_line_module) {\n+â”Š   â”Š132â”Š  emscripten::class_<geometry::Line>(\"geometry_line_base\")\n+â”Š   â”Š133â”Š    .constructor<double, double, double, double>()\n+â”Š   â”Š134â”Š    .property<double>(\"x1\", &geometry::Line::_x1)\n+â”Š   â”Š135â”Š    .property<double>(\"y1\", &geometry::Line::_y1)\n+â”Š   â”Š136â”Š    .property<double>(\"x2\", &geometry::Line::_x2)\n+â”Š   â”Š137â”Š    .property<double>(\"y2\", &geometry::Line::_y2)\n+â”Š   â”Š138â”Š    .function(\"hasPoint\", &geometry::Line::hasPoint)\n+â”Š   â”Š139â”Š    .function(\"boundsHavePoint\", &geometry::Line::boundsHavePoint);\n+â”Š   â”Š140â”Š\n+â”Š   â”Š141â”Š  emscripten::class_<geometry::EMLine, emscripten::base<geometry::Line>>(\"geometry_line\")\n+â”Š   â”Š142â”Š    .constructor<double, double, double, double>()\n+â”Š   â”Š143â”Š    .function(\"getX\", &geometry::EMLine::getMatchingX)\n+â”Š   â”Š144â”Š    .function(\"getY\", &geometry::EMLine::getMatchingY)\n+â”Š   â”Š145â”Š    .function(\"getLineIntersection\",\n+â”Š   â”Š146â”Š      emscripten::select_overload<emscripten::val(geometry::EMLine)>(\n+â”Š   â”Š147â”Š        &geometry::EMLine::getIntersection\n+â”Š   â”Š148â”Š      )\n+â”Š   â”Š149â”Š    );\n â”Š 99â”Š150â”Š}ðŸš«â†µ\n```\n\n##### Changed resources&#x2F;cpp&#x2F;src&#x2F;geometry&#x2F;line.h\n```diff\n@@ -1,6 +1,7 @@\n â”Š1â”Š1â”Š#pragma once\n â”Š2â”Š2â”Š\n â”Š3â”Š3â”Š#include <vector>\n+â”Š â”Š4â”Š#include <emscripten/val.h>\n â”Š4â”Š5â”Š#include \"../nullable.h\"\n â”Š5â”Š6â”Š#include \"point.h\"\n â”Š6â”Š7â”Š\n```\n```diff\n@@ -27,4 +28,15 @@\n â”Š27â”Š28â”Š\n â”Š28â”Š29â”Š    Nullable<Point> getIntersection(Line line);\n â”Š29â”Š30â”Š  };\n+â”Š  â”Š31â”Š\n+â”Š  â”Š32â”Š  class EMLine : public Line {\n+â”Š  â”Š33â”Š  public:\n+â”Š  â”Š34â”Š    using Line::Line;\n+â”Š  â”Š35â”Š\n+â”Š  â”Š36â”Š    emscripten::val getMatchingX(double y);\n+â”Š  â”Š37â”Š\n+â”Š  â”Š38â”Š    emscripten::val getMatchingY(double x);\n+â”Š  â”Š39â”Š\n+â”Š  â”Š40â”Š    emscripten::val getIntersection(EMLine line);\n+â”Š  â”Š41â”Š  };\n â”Š30â”Š42â”Š}ðŸš«â†µ\n```\n\n[}]: #\n\nIn the code snippet above, you can see that we used a special data-type called `val` (`emscripten::val`). `val` means that just like JavaScript, that function can return values that are not necessarily of the same data-type; For instance, the `getMatchingY` function can either return a `number` or `undefined`. If you'll take a look at the `getIntersection(Line)` method you'll notice that instead of returning the raw point structure, I chose to build a JavaScript object using the `object` data type (`emscripten::object`). `object` behaves exactly like a native JavaScript `Object`, and it can save us some precious work of binding which sometimes might be just too much.\n\nIf you'll compare the C++ version of the line class to the JavaScript line class you'll notice that the `draw` and `getIntersection` methods are missing (when we used EMBind we renamed `getIntersection` to `getLineIntersection` because overloadings are forbidden). In addition, Emscripten's API exposes some additional class methods for generated C++ classes, like the `delete` method, which we will shed light on further in this tutorial. Inheritance would be the natural solution for such an issue, unfortunately, generated C++ constructors don't accept indirect instances. For example, if we have a C++ parent class called `Shape` and we have a JavaScript child class called `Line`, we won't be able to initialize a new instance of the `Line` class. Here's a demonstration:\n\n```js\nclass JSLine extends CPPShape {}\nconst line = new JSLine(); // Throws error\n```\n\nThere are 3 ways to implement inheritance when interacting with C++ classes:\n\n- Define an interface when using EMBind. This is the official way but rather complicated, since it requires us to define an extra layer for our wrapper. More information can be found [here](https://kripken.github.io/emscripten-site/docs/porting/connecting_cpp_and_javascript/embind.html#abstract-methods).\n- Extending the prototype of exported C++ classes directly, which is not really an inheritance.\n- Using a proxy class, which is the easiest and cleanest solution of all, but it is not really mentioned anywhere. At the same time, I didn't find any restriction regards that.\n\nWe're gonna use the 3rd method in the list above, because as I said, it's the easiest and cleanest of all. First I will try to explain what I meant by saying \"proxy class\". If you're an intermediate JavaScript developer, you probably know that constructors can be overridden by returning a value explicitly. By doing that, we can actually bypass Emscripten's prohibitions, we can just return the newly created C++ instance and extend it in specific. Proxy classes actually take it a step further by providing a middle-class which will then inject a new link to the prototype chain of the returned instance.\n\n```js\nclass JSLine {\n  constructor() {\n    const line = new CPPShape();\n    return line;\n  }\n}\n\nconst line = new JSLine(); // Legal!\n```\n\n> More information about the code snippet above can be found [here](https://www.bennadel.com/blog/2522-providing-a-return-value-in-a-javascript-constructor.htm).\n\nI believe that as we go through this tutorial, the concept will get much clearer. The utility function of the proxy class should look like so:\n\n[{]: <helper> (diffStep 7.14)\n\n#### [Step 7.14: Add proxy utility method](https://github.com/DAB0mB/radial-snake/commit/06e615e)\n\n##### Changed resources&#x2F;scripts&#x2F;utils.js\n```diff\n@@ -20,5 +20,18 @@\n â”Š20â”Š20â”Š  // Overload handling\n â”Š21â”Š21â”Š  compare(context, num, method, precision = method) {\n â”Š22â”Š22â”Š    return CPP.Utils.compare(context, num, method, precision);\n+â”Š  â”Š23â”Š  },\n+â”Š  â”Š24â”Š\n+â”Š  â”Š25â”Š  proxy(Class) {\n+â”Š  â”Š26â”Š    return class extends Class {\n+â”Š  â”Š27â”Š      constructor() {\n+â”Š  â”Š28â”Š        // Initialize original class\n+â”Š  â”Š29â”Š        let that = new Class(...arguments);\n+â”Š  â”Š30â”Š        // Inject caller's prototype into the prototype chain\n+â”Š  â”Š31â”Š        Object.setPrototypeOf(that, new.target.prototype);\n+â”Š  â”Š32â”Š        // Will original instance will be the substitute for 'this'\n+â”Š  â”Š33â”Š        return that;\n+â”Š  â”Š34â”Š      }\n+â”Š  â”Š35â”Š    }\n â”Š23â”Š36â”Š  }\n â”Š24â”Š37â”Š});ðŸš«â†µ\n```\n\n[}]: #\n\nIf you'll take a look at the following line:\n\n```js\nObject.setPrototypeOf(that, new.target.prototype);\n```\n\nThis is where the magic actually happens! It enables inheritance for explicitly returned objects; This way we can safely extend C++ classes. Accordingly, our new JavaScript line class should look like so:\n\n[{]: <helper> (diffStep 7.15)\n\n#### [Step 7.15: Extend CPP line class](https://github.com/DAB0mB/radial-snake/commit/66acf9d)\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;geometry&#x2F;line.js\n```diff\n@@ -1,46 +1,10 @@\n-â”Š 1â”Š  â”ŠEngine.Geometry.Line = class Line {\n-â”Š 2â”Š  â”Š  // x1 - The first point's x value\n-â”Š 3â”Š  â”Š  // y1 - The first point's y value\n-â”Š 4â”Š  â”Š  // x1 - The second point's x value\n-â”Š 5â”Š  â”Š  // y2 - The second point's y value\n-â”Š 6â”Š  â”Š  constructor(x1, y1, x2, y2) {\n-â”Š 7â”Š  â”Š    this.x1 = Utils.trim(x1, 9);\n-â”Š 8â”Š  â”Š    this.y1 = Utils.trim(y1, 9);\n-â”Š 9â”Š  â”Š    this.x2 = Utils.trim(x2, 9);\n-â”Š10â”Š  â”Š    this.y2 = Utils.trim(y2, 9);\n-â”Š11â”Š  â”Š  }\n-â”Š12â”Š  â”Š\n+â”Š  â”Š 1â”ŠEngine.Geometry.Line = class Line extends Utils.proxy(CPP.Geometry.Line) {\n â”Š13â”Š 2â”Š  // Draws the line on the given context\n â”Š14â”Š 3â”Š  draw(context) {\n â”Š15â”Š 4â”Š    context.moveTo(this.x1, this.y1);\n â”Š16â”Š 5â”Š    context.lineTo(this.x2, this.y2);\n â”Š17â”Š 6â”Š  }\n â”Š18â”Š 7â”Š\n-â”Š19â”Š  â”Š  // Gets the matching x value for a given y value\n-â”Š20â”Š  â”Š  getX(y) {\n-â”Š21â”Š  â”Š    let x = Utils.trim((((y - this.y1) * (this.x2 - this.x1)) / (this.y2 - this.y1)) + this.x1, 9);\n-â”Š22â”Š  â”Š    if (isNaN(x) || Utils.isBetween(x, this.x1, this.x2)) return x;\n-â”Š23â”Š  â”Š  }\n-â”Š24â”Š  â”Š\n-â”Š25â”Š  â”Š  // Gets the matching y value for a given x value\n-â”Š26â”Š  â”Š  getY(x) {\n-â”Š27â”Š  â”Š    let y = Utils.trim((((x - this.x1) * (this.y2 - this.y1)) / (this.x2 - this.x1)) + this.y1, 9);\n-â”Š28â”Š  â”Š    if (isNaN(y) || Utils.isBetween(y, this.y1, this.y2)) return y;\n-â”Š29â”Š  â”Š  }\n-â”Š30â”Š  â”Š\n-â”Š31â”Š  â”Š  // Returns if line has given point\n-â”Š32â”Š  â”Š  hasPoint(x, y) {\n-â”Š33â”Š  â”Š    if (!this.boundsHavePoint(x, y)) return false;\n-â”Š34â”Š  â”Š    let m = Utils.trim((this.y2 - this.y1) / (this.x2 - this.x1), 9);\n-â”Š35â”Š  â”Š    return (y - this.y1) / (x - this.x1) == m;\n-â”Š36â”Š  â”Š  }\n-â”Š37â”Š  â”Š\n-â”Š38â”Š  â”Š  // Returns if given point is contained by the bounds aka cage of line\n-â”Š39â”Š  â”Š  boundsHavePoint(x, y) {\n-â”Š40â”Š  â”Š    return Utils.isBetween(x, this.x1, this.x2) &&\n-â”Š41â”Š  â”Š           Utils.isBetween(y, this.y1, this.y2);\n-â”Š42â”Š  â”Š  }\n-â”Š43â”Š  â”Š\n â”Š44â”Š 8â”Š  getIntersection(shape) {\n â”Š45â”Š 9â”Š    if (shape instanceof Engine.Geometry.Line)\n â”Š46â”Š10â”Š      return this.getLineIntersection(shape);\n```\n```diff\n@@ -50,23 +14,6 @@\n â”Š50â”Š14â”Š      return this.getPolygonIntersection(shape);\n â”Š51â”Š15â”Š  }\n â”Š52â”Š16â”Š\n-â”Š53â”Š  â”Š  // line - line intersection method\n-â”Š54â”Š  â”Š  getLineIntersection(line) {\n-â”Š55â”Š  â”Š    // Escape if lines are parallel\n-â”Š56â”Š  â”Š    if (!(((this.x1 - this.x2) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * (line.x1 - line.x2)))) return;\n-â”Š57â”Š  â”Š\n-â”Š58â”Š  â”Š    // Intersection point formula\n-â”Š59â”Š  â”Š    let x = Utils.trim(((((this.x1 * this.y2) - (this.y1 * this.x2)) * (line.x1 - line.x2)) - ((this.x1 - this.x2) * ((line.x1 * line.y2) - (line.y1 * line.x2)))) /\n-â”Š60â”Š  â”Š        (((this.x1 - this.x2) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * (line.x1 - line.x2))), 9);\n-â”Š61â”Š  â”Š    let y = Utils.trim(((((this.x1 * this.y2) - (this.y1 * this.x2)) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * ((line.x1 * line.y2) - (line.y1 * line.x2)))) /\n-â”Š62â”Š  â”Š        (((this.x1 - this.x2) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * (line.x1 - line.x2))), 9);\n-â”Š63â”Š  â”Š\n-â”Š64â”Š  â”Š    if (Utils.isBetween(x, this.x1, this.x2) && Utils.isBetween(x, line.x1, line.x2) &&\n-â”Š65â”Š  â”Š        Utils.isBetween(y, this.y1, this.y2) && Utils.isBetween(y, line.y1, line.y2)) {\n-â”Š66â”Š  â”Š      return { x, y };\n-â”Š67â”Š  â”Š    }\n-â”Š68â”Š  â”Š  }\n-â”Š69â”Š  â”Š\n â”Š70â”Š17â”Š  // line - circle intersection method\n â”Š71â”Š18â”Š  getCircleIntersection(circle) {\n â”Š72â”Š19â”Š    return circle.getLineIntersection(this);\n```\n\n[}]: #\n\nBy now, our tests should pass. Accept, there is memory leak we need to handle. But you probably ask yourself - \"What memory leak? It's JavaScript man! Have you ever heard of something called garbage collector?!\". Well, this is not the case when compiling C++ code with Emscripten. You see, Emscripten uses asm.js, which is a subset for JavaScript built exactly for these proposes, enabling C++ modules run on the browser. This is how the [WebGL](https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API) project actually started, an almost complete conversion from the famous C++ [OpenGL](https://www.opengl.org/) to JavaScript. Part of what asm.js does, it disables the garbage collector, and instead, it holds raw pointers, just like in C++. Since returned class instances are pointers with unknown lifespans, they need to be disposed manually, using the `delete` method (identical to how we clear memory from the Heap in C++). Let's dispose unused test data by calling the `delete` method as just mentioned:\n\n[{]: <helper> (diffStep 7.16)\n\n#### [Step 7.16: Delete line instances in tests](https://github.com/DAB0mB/radial-snake/commit/f181da4)\n\n##### Changed resources&#x2F;scripts&#x2F;specs&#x2F;engine&#x2F;geometry&#x2F;circle.js\n```diff\n@@ -111,6 +111,8 @@\n â”Š111â”Š111â”Š          { x: 6, y: 1 },\n â”Š112â”Š112â”Š          { x: -4, y: 1 }\n â”Š113â”Š113â”Š        ]);\n+â”Š   â”Š114â”Š\n+â”Š   â”Š115â”Š        line.delete();\n â”Š114â”Š116â”Š      });\n â”Š115â”Š117â”Š    });\n â”Š116â”Š118â”Š\n```\n```diff\n@@ -121,6 +123,8 @@\n â”Š121â”Š123â”Š        expect(this.circle.getLineIntersection(line)).toEqual([\n â”Š122â”Š124â”Š          { x: -4, y: 1 }\n â”Š123â”Š125â”Š        ]);\n+â”Š   â”Š126â”Š\n+â”Š   â”Š127â”Š        line.delete();\n â”Š124â”Š128â”Š      });\n â”Š125â”Š129â”Š    });\n â”Š126â”Š130â”Š\n```\n```diff\n@@ -131,6 +135,8 @@\n â”Š131â”Š135â”Š        expect(this.circle.getLineIntersection(line)).toEqual([\n â”Š132â”Š136â”Š          { x: 1, y: 6 }\n â”Š133â”Š137â”Š        ]);\n+â”Š   â”Š138â”Š\n+â”Š   â”Š139â”Š        line.delete();\n â”Š134â”Š140â”Š      });\n â”Š135â”Š141â”Š    });\n â”Š136â”Š142â”Š\n```\n```diff\n@@ -138,6 +144,7 @@\n â”Š138â”Š144â”Š      it(\"returns nothing\", function() {\n â”Š139â”Š145â”Š        let line = new Engine.Geometry.Line(-10, 10, 10, 10);\n â”Š140â”Š146â”Š        expect(this.circle.getLineIntersection(line)).toBeUndefined();\n+â”Š   â”Š147â”Š        line.delete();\n â”Š141â”Š148â”Š      });\n â”Š142â”Š149â”Š    });\n â”Š143â”Š150â”Š  });\n```\n\n##### Changed resources&#x2F;scripts&#x2F;specs&#x2F;engine&#x2F;geometry&#x2F;line.js\n```diff\n@@ -3,6 +3,10 @@\n â”Š 3â”Š 3â”Š    this.line = new Engine.Geometry.Line(-5, -5, 5, 5);\n â”Š 4â”Š 4â”Š  });\n â”Š 5â”Š 5â”Š\n+â”Š  â”Š 6â”Š  afterEach(function () {\n+â”Š  â”Š 7â”Š    this.line.delete();\n+â”Š  â”Š 8â”Š  });\n+â”Š  â”Š 9â”Š\n â”Š 6â”Š10â”Š  describe(\"getX method\", function() {\n â”Š 7â”Š11â”Š    describe(\"given inranged y\", function() {\n â”Š 8â”Š12â”Š      it(\"returns x\", function() {\n```\n```diff\n@@ -58,6 +62,8 @@\n â”Š58â”Š62â”Š          x: 1,\n â”Š59â”Š63â”Š          y: 1\n â”Š60â”Š64â”Š        });\n+â”Š  â”Š65â”Š\n+â”Š  â”Š66â”Š        line.delete();\n â”Š61â”Š67â”Š      });\n â”Š62â”Š68â”Š    });\n â”Š63â”Š69â”Š\n```\n```diff\n@@ -65,6 +71,7 @@\n â”Š65â”Š71â”Š      it(\"returns nothing\", function() {\n â”Š66â”Š72â”Š        let line = new Engine.Geometry.Line(-5, -6, 5, 4);\n â”Š67â”Š73â”Š        expect(this.line.getLineIntersection(line)).toBeUndefined();\n+â”Š  â”Š74â”Š        line.delete();\n â”Š68â”Š75â”Š      });\n â”Š69â”Š76â”Š    });\n â”Š70â”Š77â”Š\n```\n```diff\n@@ -72,6 +79,7 @@\n â”Š72â”Š79â”Š      it(\"returns nothing\", function() {\n â”Š73â”Š80â”Š        let line = new Engine.Geometry.Line(10, 10, 10, 15);\n â”Š74â”Š81â”Š        expect(this.line.getLineIntersection(line)).toBeUndefined();\n+â”Š  â”Š82â”Š        line.delete();\n â”Š75â”Š83â”Š      });\n â”Š76â”Š84â”Š    });\n â”Š77â”Š85â”Š  });\n```\n\n##### Changed resources&#x2F;scripts&#x2F;specs&#x2F;engine&#x2F;geometry&#x2F;polygon.js\n```diff\n@@ -35,6 +35,8 @@\n â”Š35â”Š35â”Š          { x: 5, y: 4 },\n â”Š36â”Š36â”Š          { x: 0, y: 1 }\n â”Š37â”Š37â”Š        ]);\n+â”Š  â”Š38â”Š\n+â”Š  â”Š39â”Š        line.delete();\n â”Š38â”Š40â”Š      });\n â”Š39â”Š41â”Š    });\n â”Š40â”Š42â”Š\n```\n```diff\n@@ -43,6 +45,8 @@\n â”Š43â”Š45â”Š        let line = new Engine.Geometry.Line(10, 11, 15, 14);\n â”Š44â”Š46â”Š\n â”Š45â”Š47â”Š        expect(this.polygon.getLineIntersection(line)).toBeUndefined();\n+â”Š  â”Š48â”Š\n+â”Š  â”Š49â”Š        line.delete();\n â”Š46â”Š50â”Š      });\n â”Š47â”Š51â”Š    });\n â”Š48â”Š52â”Š  });\n```\n\n[}]: #\n\nSince our game also uses polygons, which is made of an abstract number of lines, its test-data needs to be disposed as well. First, we will add a `delete` method to the polygon class, which will simply go though all its bounds and delete each of its lines:\n\n[{]: <helper> (diffStep 7.17)\n\n#### [Step 7.17: Add polygon deletion method](https://github.com/DAB0mB/radial-snake/commit/1c9447f)\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;geometry&#x2F;polygon.js\n```diff\n@@ -5,6 +5,10 @@\n â”Š 5â”Š 5â”Š    this.bounds = bounds.map(coords => new Engine.Geometry.Line(...coords));\n â”Š 6â”Š 6â”Š  }\n â”Š 7â”Š 7â”Š\n+â”Š  â”Š 8â”Š  delete() {\n+â”Š  â”Š 9â”Š    this.bounds.forEach(bound => bound.delete());\n+â”Š  â”Š10â”Š  }\n+â”Š  â”Š11â”Š\n â”Š 8â”Š12â”Š  // Returns if polygon has given point\n â”Š 9â”Š13â”Š  hasPoint(x, y) {\n â”Š10â”Š14â”Š    // Run check for each bound\n```\n\n[}]: #\n\nNow we can conveniently delete unused polygons in the tests:\n\n[{]: <helper> (diffStep 7.18)\n\n#### [Step 7.18: Delete polygon instances in tests](https://github.com/DAB0mB/radial-snake/commit/48024bc)\n\n##### Changed resources&#x2F;scripts&#x2F;specs&#x2F;engine&#x2F;geometry&#x2F;polygon.js\n```diff\n@@ -8,6 +8,10 @@\n â”Š 8â”Š 8â”Š    );\n â”Š 9â”Š 9â”Š  });\n â”Š10â”Š10â”Š\n+â”Š  â”Š11â”Š  afterEach(function () {\n+â”Š  â”Š12â”Š    this.polygon.delete();\n+â”Š  â”Š13â”Š  });\n+â”Š  â”Š14â”Š\n â”Š11â”Š15â”Š  describe(\"hasPoint method\", function() {\n â”Š12â”Š16â”Š    describe(\"given contained point\", function() {\n â”Š13â”Š17â”Š      it(\"returns true\", function() {\n```\n\n[}]: #\n\nMoving on, we have the circle class to transform. The process is almost the identical to how we transformed the line class, so it's gonna be way easier now. We first start by translating our code from JavaScript to C++:\n\n[{]: <helper> (diffStep 7.19)\n\n#### [Step 7.19: Add base circle CPP module](https://github.com/DAB0mB/radial-snake/commit/1a3fa58)\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;geometry&#x2F;circle.cpp\n```diff\n@@ -0,0 +1,202 @@\n+â”Š   â”Š  1â”Š\n+â”Š   â”Š  2â”Š#include <algorithm>\n+â”Š   â”Š  3â”Š#include <cmath>\n+â”Š   â”Š  4â”Š#include <vector>\n+â”Š   â”Š  5â”Š#include \"../nullable.h\"\n+â”Š   â”Š  6â”Š#include \"../utils.h\"\n+â”Š   â”Š  7â”Š#include \"point.h\"\n+â”Š   â”Š  8â”Š#include \"line.h\"\n+â”Š   â”Š  9â”Š\n+â”Š   â”Š 10â”Šnamespace geometry {\n+â”Š   â”Š 11â”Š  // x - The x value of the circle's center\n+â”Š   â”Š 12â”Š  // y - The y value of the circle's center\n+â”Š   â”Š 13â”Š  // r - The radius of the center\n+â”Š   â”Š 14â”Š  // rad1 - The first radian of the circle, not necessarily its beginning\n+â”Š   â”Š 15â”Š  // rad2 - The second radian of the circle, not necessarily its beginning\n+â”Š   â”Š 16â”Š  Circle::Circle(double x, double y, double r, double rad1, double rad2) {\n+â”Š   â”Š 17â”Š    _x = utils::trim(x, 9);\n+â”Š   â”Š 18â”Š    _y = utils::trim(y, 9);\n+â”Š   â”Š 19â”Š    _r = utils::trim(r, 9);\n+â”Š   â”Š 20â”Š\n+â”Š   â”Š 21â”Š    // Trimming mode is done based on which radian represents the ending and which radian\n+â”Š   â”Š 22â”Š    // represents the ending\n+â”Š   â”Š 23â”Š    if (rad1 > rad2) {\n+â”Š   â”Š 24â”Š      _rad1 = utils::trim(rad1, 9, \"floor\");\n+â”Š   â”Š 25â”Š      _rad2 = utils::trim(rad2, 9, \"ceil\");\n+â”Š   â”Š 26â”Š    }\n+â”Š   â”Š 27â”Š    else {\n+â”Š   â”Š 28â”Š      _rad1 = utils::trim(rad1, 9, \"ceil\");\n+â”Š   â”Š 29â”Š      _rad2 = utils::trim(rad2, 9, \"floor\");\n+â”Š   â”Š 30â”Š    }\n+â”Š   â”Š 31â”Š  }\n+â”Š   â”Š 32â”Š\n+â”Š   â”Š 33â”Š  // Gets the matching x value for the given radian\n+â”Š   â”Š 34â”Š  Nullable<double> Circle::getMatchingX(double rad) {\n+â”Š   â”Š 35â”Š    if (!utils::chain(rad)->trim(9)->isBetween(_rad1, _rad2)->result()) {\n+â”Š   â”Š 36â”Š      return Nullable<double>();\n+â”Š   â”Š 37â”Š    }\n+â”Š   â”Š 38â”Š\n+â”Š   â”Š 39â”Š    return Nullable<double>(utils::trim((_r * std::cos(rad)) + _x, 9));\n+â”Š   â”Š 40â”Š  }\n+â”Š   â”Š 41â”Š\n+â”Š   â”Š 42â”Š  // Gets the matching y value for the given radian\n+â”Š   â”Š 43â”Š  Nullable<double> Circle::getMatchingY(double rad) {\n+â”Š   â”Š 44â”Š    if (!utils::chain(rad)->trim(9)->isBetween(_rad1, _rad2)->result()) {\n+â”Š   â”Š 45â”Š      return Nullable<double>();\n+â”Š   â”Š 46â”Š    }\n+â”Š   â”Š 47â”Š\n+â”Š   â”Š 48â”Š    return Nullable<double>(utils::trim((_r * std::sin(rad)) + _y, 9));\n+â”Š   â”Š 49â”Š  }\n+â”Š   â”Š 50â”Š\n+â”Š   â”Š 51â”Š  // Gets the matching point for the given radian\n+â”Š   â”Š 52â”Š  Nullable<Point> Circle::getMatchingPoint(double rad) {\n+â”Š   â”Š 53â”Š    if (!utils::isBetween(rad, _rad1, _rad2)) {\n+â”Š   â”Š 54â”Š      return Nullable<Point>();\n+â”Š   â”Š 55â”Š    }\n+â”Š   â”Š 56â”Š\n+â”Š   â”Š 57â”Š    return Nullable<Point>({\n+â”Š   â”Š 58â”Š      utils::trim((_r * std::cos(rad)) + _x, 9),\n+â”Š   â”Š 59â”Š      utils::trim((_r * std::sin(rad)) + _y, 9)\n+â”Š   â”Š 60â”Š    });\n+â”Š   â”Š 61â”Š  }\n+â”Š   â”Š 62â”Š\n+â”Š   â”Š 63â”Š  // Gets the matching radian for the given point\n+â”Š   â”Š 64â”Š  Nullable<double> Circle::getMatchingRad(double x, double y) {\n+â”Š   â”Š 65â”Š    double rad = std::atan2(y - _y, x - _x);\n+â”Š   â”Š 66â”Š\n+â”Š   â”Š 67â”Š    // If calculated radian is in circle's radian range, return it\n+â”Š   â”Š 68â”Š    if (!std::isnan(rad) && utils::isBetween(rad, _rad1, _rad2)) {\n+â”Š   â”Š 69â”Š      return Nullable<double>(rad);\n+â”Š   â”Š 70â”Š    }\n+â”Š   â”Š 71â”Š\n+â”Š   â”Š 72â”Š    // The calculated radian can still be in the circle's radian range in case one\n+â”Š   â”Š 73â”Š    // of the radians is greater than 2 PIEs\n+â”Š   â”Š 74â”Š    double greatestRad = std::abs(_rad1) > std::abs(_rad2) ? _rad1 : _rad2;\n+â”Š   â”Š 75â”Š\n+â”Š   â”Š 76â”Š    // Check if the absolute radian is in the circle's radian range\n+â”Š   â”Š 77â”Š    if (utils::chain(rad + (2 * M_PI * std::floor(greatestRad / (2 * M_PI))))\n+â”Š   â”Š 78â”Š        ->trim(9)->isBetween(_rad1, _rad2)->result() ||\n+â”Š   â”Š 79â”Š        utils::chain(rad + (2 * M_PI * std::ceil(greatestRad / (2 * M_PI))))\n+â”Š   â”Š 80â”Š        ->trim(9)->isBetween(_rad1, _rad2)->result()) {\n+â”Š   â”Š 81â”Š      return Nullable<double>(rad);\n+â”Š   â”Š 82â”Š    }\n+â”Š   â”Š 83â”Š\n+â”Š   â”Š 84â”Š    return Nullable<double>();\n+â”Š   â”Š 85â”Š  }\n+â”Š   â”Š 86â”Š\n+â”Š   â”Š 87â”Š  // Returns if circle has given points\n+â”Š   â”Š 88â”Š  bool Circle::hasPoint(double x, double y) {\n+â”Š   â”Š 89â”Š    return getMatchingRad(x, y).hasValue();\n+â”Š   â”Š 90â”Š  }\n+â”Š   â”Š 91â”Š\n+â”Š   â”Š 92â”Š  // circle - circle intersection method\n+â”Š   â”Š 93â”Š  Nullable<std::vector<Point>> Circle::getIntersection(Circle circle) {\n+â”Š   â”Š 94â”Š    double dx = circle._x - _x;\n+â”Š   â”Š 95â”Š    double dy = circle._y - _y;\n+â”Š   â”Š 96â”Š    double d = std::sqrt(std::pow(dx, 2) + std::pow(dy, 2));\n+â”Š   â”Š 97â”Š\n+â”Š   â”Š 98â”Š    if (d > _r + circle._r ||\n+â”Š   â”Š 99â”Š       d < std::abs(_r - circle._r)) {\n+â”Š   â”Š100â”Š      return Nullable<std::vector<Point>>();\n+â”Š   â”Š101â”Š    }\n+â”Š   â”Š102â”Š\n+â”Š   â”Š103â”Š    double a = ((std::pow(_r, 2) - std::pow(circle._r, 2)) + std::pow(d, 2)) / (2 * d);\n+â”Š   â”Š104â”Š    double x = _x + ((dx * a) / d);\n+â”Š   â”Š105â”Š    double y = _y + ((dy * a) / d);\n+â”Š   â”Š106â”Š    double h = std::sqrt(std::pow(_r, 2) - std::pow(a, 2));\n+â”Š   â”Š107â”Š    double rx = (- dy * h) / d;\n+â”Š   â”Š108â”Š    double ry = (dx * h) / d;\n+â”Š   â”Š109â”Š\n+â”Š   â”Š110â”Š    std::vector<Point> interPoints(2);\n+â”Š   â”Š111â”Š    interPoints.at(0).x = x + rx;\n+â”Š   â”Š112â”Š    interPoints.at(0).y = y + ry;\n+â”Š   â”Š113â”Š    interPoints.at(1).x = x - rx;\n+â”Š   â”Š114â”Š    interPoints.at(1).y = y - ry;\n+â”Š   â”Š115â”Š\n+â”Š   â”Š116â”Š    for (unsigned i = 0; i < interPoints.size(); i++) {\n+â”Š   â”Š117â”Š      Point& point = interPoints.at(i);\n+â”Š   â”Š118â”Š      point.x = utils::trim(point.x, 9);\n+â”Š   â”Š119â”Š      point.y = utils::trim(point.y, 9);\n+â”Š   â”Š120â”Š    }\n+â”Š   â”Š121â”Š\n+â”Š   â”Š122â”Š    auto pointsBegin = std::unique(interPoints.begin(), interPoints.end(),\n+â”Š   â”Š123â”Š      [](Point pointA, Point pointB) {\n+â”Š   â”Š124â”Š        return pointA.x == pointB.x && pointA.y == pointB.y;\n+â”Š   â”Š125â”Š      }\n+â”Š   â”Š126â”Š    );\n+â”Š   â”Š127â”Š\n+â”Š   â”Š128â”Š    interPoints.erase(pointsBegin, interPoints.end());\n+â”Š   â”Š129â”Š\n+â”Š   â”Š130â”Š    std::vector<Circle> circles = { *this, circle };\n+â”Š   â”Š131â”Š\n+â”Š   â”Š132â”Š    std::for_each(circles.begin(), circles.end(), [&interPoints](Circle circle) {\n+â”Š   â”Š133â”Š      auto pointsBegin = std::remove_if(interPoints.begin(), interPoints.end(),\n+â”Š   â”Š134â”Š        [&circle](Point point) {\n+â”Š   â”Š135â”Š          return !circle.hasPoint(point.x, point.y);\n+â”Š   â”Š136â”Š        }\n+â”Š   â”Š137â”Š      );\n+â”Š   â”Š138â”Š\n+â”Š   â”Š139â”Š      interPoints.erase(pointsBegin, interPoints.end());\n+â”Š   â”Š140â”Š    });\n+â”Š   â”Š141â”Š\n+â”Š   â”Š142â”Š    if (interPoints.size()) {\n+â”Š   â”Š143â”Š      return Nullable<std::vector<Point>>(interPoints);\n+â”Š   â”Š144â”Š    }\n+â”Š   â”Š145â”Š\n+â”Š   â”Š146â”Š    return Nullable<std::vector<Point>>();\n+â”Š   â”Š147â”Š  }\n+â”Š   â”Š148â”Š\n+â”Š   â”Š149â”Š  // circle - line intersection method\n+â”Š   â”Š150â”Š  Nullable<std::vector<Point>> Circle::getIntersection(Line line) {\n+â”Š   â”Š151â”Š    double x1 = line._x1 - _x;\n+â”Š   â”Š152â”Š    double x2 = line._x2 - _x;\n+â”Š   â”Š153â”Š    double y1 = line._y1 - _y;\n+â”Š   â”Š154â”Š    double y2 = line._y2 - _y;\n+â”Š   â”Š155â”Š    double dx = x2 - x1;\n+â”Š   â”Š156â”Š    double dy = y2 - y1;\n+â”Š   â”Š157â”Š    double d = std::sqrt(std::pow(dx, 2) + std::pow(dy, 2));\n+â”Š   â”Š158â”Š    double h = (x1 * y2) - (x2 * y1);\n+â”Š   â”Š159â”Š    double delta = (std::pow(_r, 2) * std::pow(d, 2)) - std::pow(h, 2);\n+â”Š   â”Š160â”Š\n+â”Š   â”Š161â”Š    if (delta < 0) Nullable<std::vector<Point>>();\n+â”Š   â”Š162â”Š\n+â”Š   â”Š163â”Š    double sign = dy / std::abs(dy); if (std::isnan(sign)) sign = 1;\n+â”Š   â”Š164â”Š    double sqrtx = sign * dx * std::sqrt(delta);\n+â”Š   â”Š165â”Š    double sqrty = std::abs(dy) * std::sqrt(delta);\n+â”Š   â”Š166â”Š\n+â”Š   â”Š167â”Š    std::vector<Point> interPoints(2);\n+â”Š   â”Š168â”Š    interPoints.at(0).x = (((h * dy) + sqrtx) / std::pow(d, 2)) + _x;\n+â”Š   â”Š169â”Š    interPoints.at(0).y = (((-h * dx) + sqrty) / std::pow(d, 2)) + _y;\n+â”Š   â”Š170â”Š    interPoints.at(1).x = (((h * dy) - sqrtx) / std::pow(d, 2)) + _x;\n+â”Š   â”Š171â”Š    interPoints.at(1).y = (((-h * dx) - sqrty) / std::pow(d, 2)) + _y;\n+â”Š   â”Š172â”Š\n+â”Š   â”Š173â”Š    for (unsigned i = 0; i < interPoints.size(); i++) {\n+â”Š   â”Š174â”Š      Point& point = interPoints.at(i);\n+â”Š   â”Š175â”Š      point.x = utils::trim(point.x, 9);\n+â”Š   â”Š176â”Š      point.y = utils::trim(point.y, 9);\n+â”Š   â”Š177â”Š    }\n+â”Š   â”Š178â”Š\n+â”Š   â”Š179â”Š    auto pointsBegin = std::remove_if(interPoints.begin(), interPoints.end(),\n+â”Š   â”Š180â”Š      [this, &line](Point point) {\n+â”Š   â”Š181â”Š        return !hasPoint(point.x, point.y) ||\n+â”Š   â”Š182â”Š          !line.boundsHavePoint(point.x, point.y);\n+â”Š   â”Š183â”Š      }\n+â”Š   â”Š184â”Š    );\n+â”Š   â”Š185â”Š\n+â”Š   â”Š186â”Š    interPoints.erase(pointsBegin, interPoints.end());\n+â”Š   â”Š187â”Š\n+â”Š   â”Š188â”Š    pointsBegin = std::unique(interPoints.begin(), interPoints.end(),\n+â”Š   â”Š189â”Š      [](Point pointA, Point pointB) {\n+â”Š   â”Š190â”Š        return pointA.x == pointB.x && pointA.y == pointB.y;\n+â”Š   â”Š191â”Š      }\n+â”Š   â”Š192â”Š    );\n+â”Š   â”Š193â”Š\n+â”Š   â”Š194â”Š    interPoints.erase(pointsBegin, interPoints.end());\n+â”Š   â”Š195â”Š\n+â”Š   â”Š196â”Š    if (interPoints.size()) {\n+â”Š   â”Š197â”Š      return Nullable<std::vector<Point>>(interPoints);\n+â”Š   â”Š198â”Š    }\n+â”Š   â”Š199â”Š\n+â”Š   â”Š200â”Š    return Nullable<std::vector<Point>>();\n+â”Š   â”Š201â”Š  }\n+â”Š   â”Š202â”Š}ðŸš«â†µ\n```\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;geometry&#x2F;circle.h\n```diff\n@@ -0,0 +1,35 @@\n+â”Š  â”Š 1â”Š#pragma once\n+â”Š  â”Š 2â”Š\n+â”Š  â”Š 3â”Š#include <vector>\n+â”Š  â”Š 4â”Š#include \"../nullable.h\"\n+â”Š  â”Š 5â”Š#include \"point.h\"\n+â”Š  â”Š 6â”Š#include \"line.h\"\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Šnamespace geometry {\n+â”Š  â”Š 9â”Š  class Line;\n+â”Š  â”Š10â”Š\n+â”Š  â”Š11â”Š  class Circle {\n+â”Š  â”Š12â”Š  public:\n+â”Š  â”Š13â”Š    double _x;\n+â”Š  â”Š14â”Š    double _y;\n+â”Š  â”Š15â”Š    double _r;\n+â”Š  â”Š16â”Š    double _rad1;\n+â”Š  â”Š17â”Š    double _rad2;\n+â”Š  â”Š18â”Š\n+â”Š  â”Š19â”Š    Circle(double x, double y, double r, double rad1, double rad2);\n+â”Š  â”Š20â”Š\n+â”Š  â”Š21â”Š    Nullable<double> getMatchingX(double rad);\n+â”Š  â”Š22â”Š\n+â”Š  â”Š23â”Š    Nullable<double> getMatchingY(double rad);\n+â”Š  â”Š24â”Š\n+â”Š  â”Š25â”Š    Nullable<Point> getMatchingPoint(double rad);\n+â”Š  â”Š26â”Š\n+â”Š  â”Š27â”Š    Nullable<double> getMatchingRad(double x, double y);\n+â”Š  â”Š28â”Š\n+â”Š  â”Š29â”Š    bool hasPoint(double x, double y);\n+â”Š  â”Š30â”Š\n+â”Š  â”Š31â”Š    Nullable<std::vector<Point>> getIntersection(Circle circle);\n+â”Š  â”Š32â”Š\n+â”Š  â”Š33â”Š    Nullable<std::vector<Point>> getIntersection(Line line);\n+â”Š  â”Š34â”Š  };\n+â”Š  â”Š35â”Š}ðŸš«â†µ\n```\n\n##### Changed resources&#x2F;cpp&#x2F;src&#x2F;index.cpp\n```diff\n@@ -1,3 +1,4 @@\n â”Š1â”Š1â”Š#include \"nullable.cpp\"\n â”Š2â”Š2â”Š#include \"utils.cpp\"\n-â”Š3â”Š â”Š#include \"geometry/line.cpp\"ðŸš«â†µ\n+â”Š â”Š3â”Š#include \"geometry/line.cpp\"\n+â”Š â”Š4â”Š#include \"geometry/circle.cpp\"ðŸš«â†µ\n```\n\n[}]: #\n\nSecond, we need to wrap our code using EMBind:\n\n[{]: <helper> (diffStep 7.2)\n\n#### [Step 7.2: Add base utility CPP module](https://github.com/DAB0mB/radial-snake/commit/6dba512)\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;utils.cpp\n```diff\n@@ -0,0 +1,73 @@\n+â”Š  â”Š 1â”Š#include <cfloat>\n+â”Š  â”Š 2â”Š#include <cmath>\n+â”Š  â”Š 3â”Š#include <string>\n+â”Š  â”Š 4â”Š#include \"utils.h\"\n+â”Š  â”Š 5â”Š\n+â”Š  â”Š 6â”Šnamespace utils {\n+â”Š  â”Š 7â”Š  // Fixed modulo method which can calculate modulo of negative numbers properly\n+â”Š  â”Š 8â”Š  // e.g. (-803).mod(800) returns 797\n+â”Š  â”Š 9â”Š  double mod(double context, double num) {\n+â”Š  â”Š10â”Š    return std::fmod((std::fmod(context, num) + num), num);\n+â”Š  â”Š11â”Š  }\n+â”Š  â”Š12â”Š\n+â”Š  â”Š13â”Š  // Trims number and leaves the number of decimals specified.\n+â”Š  â”Š14â”Š  // The \"mode\" argument specifies which math function should be invoked\n+â”Š  â”Š15â”Š  // right after the number has been trimmed.\n+â”Š  â”Š16â”Š  // e.g. 12.12345.trim(3, \"ceil\") returns 12.124\n+â”Š  â”Š17â”Š  double trim(double context, int decimals, const std::string mode) {\n+â”Š  â”Š18â”Š    double accumulator = context * std::pow(10, decimals);\n+â”Š  â”Š19â”Š\n+â”Š  â”Š20â”Š    if (mode.compare(\"ceil\") == 0)\n+â”Š  â”Š21â”Š      accumulator = std::ceil(accumulator);\n+â”Š  â”Š22â”Š    else if (mode.compare(\"floor\") == 0)\n+â”Š  â”Š23â”Š      accumulator = std::floor(accumulator);\n+â”Š  â”Š24â”Š    else\n+â”Š  â”Š25â”Š      accumulator = std::round(accumulator);\n+â”Š  â”Š26â”Š\n+â”Š  â”Š27â”Š    return accumulator / std::pow(10, decimals);\n+â”Š  â”Š28â”Š  }\n+â”Š  â”Š29â”Š\n+â”Š  â”Š30â”Š  // Tells if number is in specified range based on given precision.\n+â”Š  â”Š31â”Š  // See the \"compare\" method for more information about precision\n+â”Š  â”Š32â”Š  bool isBetween(double context, double num1, double num2, const std::string precision) {\n+â”Š  â”Š33â”Š    return compare(context, std::min(num1, num2), \">=\", precision) &&\n+â”Š  â”Š34â”Š           compare(context, std::max(num1, num2), \"<=\", precision);\n+â”Š  â”Š35â”Š  }\n+â”Š  â”Š36â”Š\n+â”Š  â”Š37â”Š  bool compare(double context, double num, const std::string precision) {\n+â”Š  â”Š38â”Š    return compare(context, num, \"==\", precision);\n+â”Š  â”Š39â”Š  }\n+â”Š  â”Š40â”Š\n+â”Š  â”Š41â”Š  // Initiates comparison operator between context number and a given number, only here\n+â”Š  â”Š42â”Š  // a precision can be specified\n+â”Š  â”Š43â”Š  bool compare(double context, double num, const std::string method, const std::string precision) {\n+â”Š  â”Š44â”Š    // Fixed precision, \"almost equal\" with a deviation of Îµ\n+â”Š  â”Š45â”Š    if (precision.compare(\"f\") == 0) {\n+â”Š  â”Š46â”Š      if (method.compare(\"<\") == 0 ||\n+â”Š  â”Š47â”Š          method.compare(\"<=\") == 0)\n+â”Š  â”Š48â”Š        return context <= num + DBL_EPSILON;\n+â”Š  â”Š49â”Š      if (method.compare(\">\") == 0 ||\n+â”Š  â”Š50â”Š          method.compare(\">=\") == 0)\n+â”Š  â”Š51â”Š        return context >= num - DBL_EPSILON;\n+â”Š  â”Š52â”Š      return std::abs(context - num) <= DBL_EPSILON;\n+â”Š  â”Š53â”Š    }\n+â”Š  â”Š54â”Š    // Pixel precision, round comparison\n+â”Š  â”Š55â”Š    else if (precision.compare(\"px\") == 0) {\n+â”Š  â”Š56â”Š      if (method.compare(\"<\") == 0 ||\n+â”Š  â”Š57â”Š          method.compare(\"<=\") == 0)\n+â”Š  â”Š58â”Š        return std::round(context) <= std::round(num);\n+â”Š  â”Š59â”Š      if (method.compare(\">\") == 0 ||\n+â”Š  â”Š60â”Š          method.compare(\">=\") == 0)\n+â”Š  â”Š61â”Š        return std::round(context) >= std::round(num);\n+â”Š  â”Š62â”Š      return std::round(context) == std::round(num);\n+â”Š  â”Š63â”Š    }\n+â”Š  â”Š64â”Š    // Exact precision\n+â”Š  â”Š65â”Š    else {\n+â”Š  â”Š66â”Š      if (method.compare(\"<\") == 0) return context < num;\n+â”Š  â”Š67â”Š      if (method.compare(\"<=\") == 0) return context <= num;\n+â”Š  â”Š68â”Š      if (method.compare(\">\") == 0) return context > num;\n+â”Š  â”Š69â”Š      if (method.compare(\">=\") == 0) return context >= num;\n+â”Š  â”Š70â”Š      return context == num;\n+â”Š  â”Š71â”Š    }\n+â”Š  â”Š72â”Š  }\n+â”Š  â”Š73â”Š}ðŸš«â†µ\n```\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;utils.h\n```diff\n@@ -0,0 +1,15 @@\n+â”Š  â”Š 1â”Š#pragma once\n+â”Š  â”Š 2â”Š\n+â”Š  â”Š 3â”Š#include <string>\n+â”Š  â”Š 4â”Š\n+â”Š  â”Š 5â”Šnamespace utils {\n+â”Š  â”Š 6â”Š  double mod(double context, double num);\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Š  double trim(double context, int decimals, const std::string mode = \"round\");\n+â”Š  â”Š 9â”Š\n+â”Š  â”Š10â”Š  bool isBetween(double context, double num1, double num2, const std::string precision = \"exact\");\n+â”Š  â”Š11â”Š\n+â”Š  â”Š12â”Š  bool compare(double context, double num, const std::string precision = \"exact\");\n+â”Š  â”Š13â”Š\n+â”Š  â”Š14â”Š  bool compare(double context, double num, const std::string method, const std::string precision);\n+â”Š  â”Š15â”Š}ðŸš«â†µ\n```\n\n[}]: #\n\nAnd finally, we will extend the C++ in our JavaScript circle:\n\n[{]: <helper> (diffStep 7.21)\n\n#### [Step 7.21: Extend CPP circle class](https://github.com/DAB0mB/radial-snake/commit/d05cf32)\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;geometry&#x2F;circle.js\n```diff\n@@ -1,83 +1,9 @@\n-â”Š 1â”Š  â”ŠEngine.Geometry.Circle = class Circle {\n-â”Š 2â”Š  â”Š  // x - The x value of the circle's center\n-â”Š 3â”Š  â”Š  // y - The y value of the circle's center\n-â”Š 4â”Š  â”Š  // r - The radius of the center\n-â”Š 5â”Š  â”Š  // rad1 - The first radian of the circle, not necessarily its beginning\n-â”Š 6â”Š  â”Š  // rad2 - The second radian of the circle, not necessarily its beginning\n-â”Š 7â”Š  â”Š  constructor(x, y, r, rad1, rad2) {\n-â”Š 8â”Š  â”Š    this.x = Utils.trim(x, 9);\n-â”Š 9â”Š  â”Š    this.y = Utils.trim(y, 9);\n-â”Š10â”Š  â”Š    this.r = Utils.trim(r, 9);\n-â”Š11â”Š  â”Š\n-â”Š12â”Š  â”Š    // Trimming mode is done based on which radian represents the ending and which radian\n-â”Š13â”Š  â”Š    // represents the ending\n-â”Š14â”Š  â”Š    if (rad1 > rad2) {\n-â”Š15â”Š  â”Š      this.rad1 = Utils.trim(rad1, 9, \"floor\");\n-â”Š16â”Š  â”Š      this.rad2 = Utils.trim(rad2, 9, \"ceil\");\n-â”Š17â”Š  â”Š    }\n-â”Š18â”Š  â”Š    else {\n-â”Š19â”Š  â”Š      this.rad1 = Utils.trim(rad1, 9, \"ceil\");\n-â”Š20â”Š  â”Š      this.rad2 = Utils.trim(rad2, 9, \"floor\");\n-â”Š21â”Š  â”Š    }\n-â”Š22â”Š  â”Š  }\n-â”Š23â”Š  â”Š\n+â”Š  â”Š 1â”ŠEngine.Geometry.Circle = class Circle extends Utils.proxy(CPP.Geometry.Circle) {\n â”Š24â”Š 2â”Š  // Draws the circle on the given context\n â”Š25â”Š 3â”Š  draw(context) {\n â”Š26â”Š 4â”Š    context.arc(this.x, this.y, this.r, this.rad1, this.rad2);\n â”Š27â”Š 5â”Š  }\n â”Š28â”Š 6â”Š\n-â”Š29â”Š  â”Š  // Gets the matching x value for the given radian\n-â”Š30â”Š  â”Š  getX(rad) {\n-â”Š31â”Š  â”Š    if (!Utils(rad).trim(9).isBetween(this.rad1, this.rad2).value()) return;\n-â”Š32â”Š  â”Š    return Utils.trim((this.r * Math.cos(rad)) + this.x, 9);\n-â”Š33â”Š  â”Š  }\n-â”Š34â”Š  â”Š\n-â”Š35â”Š  â”Š  // Gets the matching y value for the given radian\n-â”Š36â”Š  â”Š  getY(rad) {\n-â”Š37â”Š  â”Š    if (!Utils(rad).trim(9).isBetween(this.rad1, this.rad2).value()) return;\n-â”Š38â”Š  â”Š    return Utils.trim((this.r * Math.sin(rad)) + this.y, 9);\n-â”Š39â”Š  â”Š  }\n-â”Š40â”Š  â”Š\n-â”Š41â”Š  â”Š  // Gets the matching point for the given radian\n-â”Š42â”Š  â”Š  getPoint(rad) {\n-â”Š43â”Š  â”Š    if (!Utils.isBetween(rad, this.rad1, this.rad2)) return;\n-â”Š44â”Š  â”Š\n-â”Š45â”Š  â”Š    return {\n-â”Š46â”Š  â”Š      x: Utils.trim((this.r * Math.cos(rad)) + this.x, 9),\n-â”Š47â”Š  â”Š      y: Utils.trim((this.r * Math.sin(rad)) + this.y, 9)\n-â”Š48â”Š  â”Š    };\n-â”Š49â”Š  â”Š  }\n-â”Š50â”Š  â”Š\n-â”Š51â”Š  â”Š  // Gets the matching radian for the given point\n-â”Š52â”Š  â”Š  getRad(x, y) {\n-â”Š53â”Š  â”Š    let rad = Math.atan2(y - this.y, x - this.x);\n-â”Š54â”Š  â”Š\n-â”Š55â”Š  â”Š    // If calculated radian is in circle's radian range, return it\n-â”Š56â”Š  â”Š    if (rad != null && Utils.isBetween(rad, this.rad1, this.rad2)) {\n-â”Š57â”Š  â”Š      return rad;\n-â”Š58â”Š  â”Š    }\n-â”Š59â”Š  â”Š\n-â”Š60â”Š  â”Š    // The calculated radian can still be in the circle's radian range in case one\n-â”Š61â”Š  â”Š    // of the radians is greater than 2 PIEs\n-â”Š62â”Š  â”Š    if (Math.abs(this.rad1) > Math.abs(this.rad2)) {\n-â”Š63â”Š  â”Š      var greatestRad = this.rad1;\n-â”Š64â”Š  â”Š    }\n-â”Š65â”Š  â”Š    else {\n-â”Š66â”Š  â”Š      var greatestRad = this.rad2;\n-â”Š67â”Š  â”Š    }\n-â”Š68â”Š  â”Š\n-â”Š69â”Š  â”Š    // Check if the absolute radian is in the circle's radian range\n-â”Š70â”Š  â”Š    if (Utils(rad + (2 * Math.PI * Math.floor(greatestRad / (2 * Math.PI)))).trim(9).isBetween(this.rad1, this.rad2).value() ||\n-â”Š71â”Š  â”Š        Utils(rad + (2 * Math.PI * Math.ceil(greatestRad / (2 * Math.PI)))).trim(9).isBetween(this.rad1, this.rad2).value()) {\n-â”Š72â”Š  â”Š      return rad;\n-â”Š73â”Š  â”Š    }\n-â”Š74â”Š  â”Š  }\n-â”Š75â”Š  â”Š\n-â”Š76â”Š  â”Š  // Returns if circle has given points\n-â”Š77â”Š  â”Š  hasPoint(x, y) {\n-â”Š78â”Š  â”Š    return this.getRad(x, y) != null;\n-â”Š79â”Š  â”Š  }\n-â”Š80â”Š  â”Š\n â”Š81â”Š 7â”Š  getIntersection(shape) {\n â”Š82â”Š 8â”Š    if (shape instanceof Engine.Geometry.Line)\n â”Š83â”Š 9â”Š      return this.getLineIntersection(shape);\n```\n```diff\n@@ -87,86 +13,6 @@\n â”Š 87â”Š 13â”Š      return this.getPolygonIntersection(shape);\n â”Š 88â”Š 14â”Š  }\n â”Š 89â”Š 15â”Š\n-â”Š 90â”Š   â”Š  // circle - circle intersection method\n-â”Š 91â”Š   â”Š  getCircleIntersection(circle) {\n-â”Š 92â”Š   â”Š    let dx = circle.x - this.x;\n-â”Š 93â”Š   â”Š    let dy = circle.y - this.y;\n-â”Š 94â”Š   â”Š    let d = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\n-â”Š 95â”Š   â”Š\n-â”Š 96â”Š   â”Š    if (d > this.r + circle.r ||\n-â”Š 97â”Š   â”Š       d < Math.abs(this.r - circle.r)) {\n-â”Š 98â”Š   â”Š      return;\n-â”Š 99â”Š   â”Š    }\n-â”Š100â”Š   â”Š\n-â”Š101â”Š   â”Š    let a = ((Math.pow(this.r, 2) - Math.pow(circle.r, 2)) + Math.pow(d, 2)) / (2 * d);\n-â”Š102â”Š   â”Š    let x = this.x + ((dx * a) / d);\n-â”Š103â”Š   â”Š    let y = this.y + ((dy * a) / d);\n-â”Š104â”Š   â”Š    let h = Math.sqrt(Math.pow(this.r, 2) - Math.pow(a, 2));\n-â”Š105â”Š   â”Š    let rx = (- dy * h) / d;\n-â”Š106â”Š   â”Š    let ry = (dx * h) / d;\n-â”Š107â”Š   â”Š\n-â”Š108â”Š   â”Š    let interPoints = [\n-â”Š109â”Š   â”Š      {\n-â”Š110â”Š   â”Š        x: x + rx,\n-â”Š111â”Š   â”Š        y: y + ry\n-â”Š112â”Š   â”Š      },\n-â”Š113â”Š   â”Š      {\n-â”Š114â”Š   â”Š        x: x - rx,\n-â”Š115â”Š   â”Š        y: y - ry\n-â”Š116â”Š   â”Š      }\n-â”Š117â”Š   â”Š    ]\n-â”Š118â”Š   â”Š    .map(point => ({\n-â”Š119â”Š   â”Š        x: Utils.trim(point.x, 9),\n-â”Š120â”Š   â”Š        y: Utils.trim(point.y, 9)\n-â”Š121â”Š   â”Š     }));\n-â”Š122â”Š   â”Š\n-â”Š123â”Š   â”Š    interPoints = _.uniq(interPoints, point => `(${point.x}, ${point.y})`);\n-â”Š124â”Š   â”Š\n-â”Š125â”Š   â”Š    [this, circle].forEach(function(circle) {\n-â”Š126â”Š   â”Š      interPoints = interPoints.filter(point => circle.hasPoint(point.x, point.y));\n-â”Š127â”Š   â”Š    });\n-â”Š128â”Š   â”Š\n-â”Š129â”Š   â”Š    if (interPoints.length > 0) return interPoints;\n-â”Š130â”Š   â”Š  }\n-â”Š131â”Š   â”Š\n-â”Š132â”Š   â”Š  // circle - line intersection method\n-â”Š133â”Š   â”Š  getLineIntersection(line) {\n-â”Š134â”Š   â”Š    let x1 = line.x1 - this.x;\n-â”Š135â”Š   â”Š    let x2 = line.x2 - this.x;\n-â”Š136â”Š   â”Š    let y1 = line.y1 - this.y;\n-â”Š137â”Š   â”Š    let y2 = line.y2 - this.y;\n-â”Š138â”Š   â”Š    let dx = x2 - x1;\n-â”Š139â”Š   â”Š    let dy = y2 - y1;\n-â”Š140â”Š   â”Š    let d = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\n-â”Š141â”Š   â”Š    let h = (x1 * y2) - (x2 * y1);\n-â”Š142â”Š   â”Š    let delta = (Math.pow(this.r, 2) * Math.pow(d, 2)) - Math.pow(h, 2);\n-â”Š143â”Š   â”Š\n-â”Š144â”Š   â”Š    if (delta < 0) return;\n-â”Š145â”Š   â”Š\n-â”Š146â”Š   â”Š    let interPoints = [\n-â”Š147â”Š   â”Š      {\n-â”Š148â”Š   â”Š        x: (((h * dy) + (((dy / Math.abs(dy)) || 1) * dx * Math.sqrt(delta))) / Math.pow(d, 2)) + this.x,\n-â”Š149â”Š   â”Š        y: (((-h * dx) + (Math.abs(dy) * Math.sqrt(delta))) / Math.pow(d, 2)) + this.y\n-â”Š150â”Š   â”Š      },\n-â”Š151â”Š   â”Š      {\n-â”Š152â”Š   â”Š        x: (((h * dy) - (((dy / Math.abs(dy)) || 1) * dx * Math.sqrt(delta))) / Math.pow(d, 2)) + this.x,\n-â”Š153â”Š   â”Š        y: (((-h * dx) - (Math.abs(dy) * Math.sqrt(delta))) / Math.pow(d, 2)) + this.y\n-â”Š154â”Š   â”Š      }\n-â”Š155â”Š   â”Š    ]\n-â”Š156â”Š   â”Š    .map(point => ({\n-â”Š157â”Š   â”Š        x: Utils.trim(point.x, 9),\n-â”Š158â”Š   â”Š        y: Utils.trim(point.y, 9)\n-â”Š159â”Š   â”Š    }))\n-â”Š160â”Š   â”Š    .filter(point => {\n-â”Š161â”Š   â”Š      return this.hasPoint(point.x, point.y) &&\n-â”Š162â”Š   â”Š        line.boundsHavePoint(point.x, point.y);\n-â”Š163â”Š   â”Š    });\n-â”Š164â”Š   â”Š\n-â”Š165â”Š   â”Š    interPoints = _.uniq(interPoints, point => `(${point.x}, ${point.y})`);\n-â”Š166â”Š   â”Š\n-â”Š167â”Š   â”Š    if (interPoints.length > 0) return interPoints;\n-â”Š168â”Š   â”Š  }\n-â”Š169â”Š   â”Š\n â”Š170â”Š 16â”Š  // circle - polygon intersection method\n â”Š171â”Š 17â”Š  getPolygonIntersection(polygon) {\n â”Š172â”Š 18â”Š    return polygon.getCircleIntersection(this);\n```\n\n[}]: #\n\nWe also need to update the line class to contain a reference to the newly created line-intersection method, so it can be invoked from both a line or a circle bi-directionally:\n\n[{]: <helper> (diffStep 7.22)\n\n#### [Step 7.22: Add line-circle intersection method](https://github.com/DAB0mB/radial-snake/commit/84f5f4d)\n\n##### Changed resources&#x2F;cpp&#x2F;src&#x2F;geometry&#x2F;line.cpp\n```diff\n@@ -4,6 +4,7 @@\n â”Š 4â”Š 4â”Š#include \"../nullable.h\"\n â”Š 5â”Š 5â”Š#include \"../utils.h\"\n â”Š 6â”Š 6â”Š#include \"point.h\"\n+â”Š  â”Š 7â”Š#include \"circle.h\"\n â”Š 7â”Š 8â”Š#include \"line.h\"\n â”Š 8â”Š 9â”Š\n â”Š 9â”Š10â”Šnamespace geometry {\n```\n```diff\n@@ -100,6 +101,11 @@\n â”Š100â”Š101â”Š    return Nullable<Point>();\n â”Š101â”Š102â”Š  }\n â”Š102â”Š103â”Š\n+â”Š   â”Š104â”Š  // circle - circle intersection method\n+â”Š   â”Š105â”Š  Nullable<std::vector<Point>> Line::getIntersection(Circle circle) {\n+â”Š   â”Š106â”Š    return circle.getIntersection(*this);\n+â”Š   â”Š107â”Š  }\n+â”Š   â”Š108â”Š\n â”Š103â”Š109â”Š  emscripten::val EMLine::getMatchingX(double y) {\n â”Š104â”Š110â”Š    Nullable<double> nullableX = Line::getMatchingX(y);\n â”Š105â”Š111â”Š    return nullableX.hasValue() ?\n```\n```diff\n@@ -126,6 +132,10 @@\n â”Š126â”Š132â”Š    emPoint.set(\"y\", emscripten::val(point.y));\n â”Š127â”Š133â”Š    return emPoint;\n â”Š128â”Š134â”Š  }\n+â”Š   â”Š135â”Š\n+â”Š   â”Š136â”Š  emscripten::val EMLine::getIntersection(EMCircle emCircle) {\n+â”Š   â”Š137â”Š    return emCircle.getIntersection(*this);\n+â”Š   â”Š138â”Š  }\n â”Š129â”Š139â”Š}\n â”Š130â”Š140â”Š\n â”Š131â”Š141â”ŠEMSCRIPTEN_BINDINGS(geometry_line_module) {\n```\n```diff\n@@ -146,5 +156,10 @@\n â”Š146â”Š156â”Š      emscripten::select_overload<emscripten::val(geometry::EMLine)>(\n â”Š147â”Š157â”Š        &geometry::EMLine::getIntersection\n â”Š148â”Š158â”Š      )\n+â”Š   â”Š159â”Š    )\n+â”Š   â”Š160â”Š    .function(\"getCircleIntersection\",\n+â”Š   â”Š161â”Š      emscripten::select_overload<emscripten::val(geometry::EMCircle)>(\n+â”Š   â”Š162â”Š        &geometry::EMLine::getIntersection\n+â”Š   â”Š163â”Š      )\n â”Š149â”Š164â”Š    );\n â”Š150â”Š165â”Š}ðŸš«â†µ\n```\n\n##### Changed resources&#x2F;cpp&#x2F;src&#x2F;geometry&#x2F;line.h\n```diff\n@@ -4,6 +4,7 @@\n â”Š 4â”Š 4â”Š#include <emscripten/val.h>\n â”Š 5â”Š 5â”Š#include \"../nullable.h\"\n â”Š 6â”Š 6â”Š#include \"point.h\"\n+â”Š  â”Š 7â”Š#include \"circle.h\"\n â”Š 7â”Š 8â”Š\n â”Š 8â”Š 9â”Šnamespace geometry {\n â”Š 9â”Š10â”Š  class Circle;\n```\n```diff\n@@ -27,6 +28,8 @@\n â”Š27â”Š28â”Š    bool boundsHavePoint(double x, double y);\n â”Š28â”Š29â”Š\n â”Š29â”Š30â”Š    Nullable<Point> getIntersection(Line line);\n+â”Š  â”Š31â”Š\n+â”Š  â”Š32â”Š    Nullable<std::vector<Point>> getIntersection(Circle circle);\n â”Š30â”Š33â”Š  };\n â”Š31â”Š34â”Š\n â”Š32â”Š35â”Š  class EMLine : public Line {\n```\n```diff\n@@ -38,5 +41,7 @@\n â”Š38â”Š41â”Š    emscripten::val getMatchingY(double x);\n â”Š39â”Š42â”Š\n â”Š40â”Š43â”Š    emscripten::val getIntersection(EMLine line);\n+â”Š  â”Š44â”Š\n+â”Š  â”Š45â”Š    emscripten::val getIntersection(EMCircle circle);\n â”Š41â”Š46â”Š  };\n â”Š42â”Š47â”Š}ðŸš«â†µ\n```\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;geometry&#x2F;line.js\n```diff\n@@ -14,11 +14,6 @@\n â”Š14â”Š14â”Š      return this.getPolygonIntersection(shape);\n â”Š15â”Š15â”Š  }\n â”Š16â”Š16â”Š\n-â”Š17â”Š  â”Š  // line - circle intersection method\n-â”Š18â”Š  â”Š  getCircleIntersection(circle) {\n-â”Š19â”Š  â”Š    return circle.getLineIntersection(this);\n-â”Š20â”Š  â”Š  }\n-â”Š21â”Š  â”Š\n â”Š22â”Š17â”Š  // line - polygon intersection method\n â”Š23â”Š18â”Š  getPolygonIntersection(polygon) {\n â”Š24â”Š19â”Š    return polygon.getLineIntersection(this);\n```\n\n[}]: #\n\nNow, before running the tests, be sure to disposed unused circle test-data:\n\n[{]: <helper> (diffStep 7.23)\n\n#### [Step 7.23: Delete circle instances in tests](https://github.com/DAB0mB/radial-snake/commit/e953fae)\n\n##### Changed resources&#x2F;scripts&#x2F;specs&#x2F;engine&#x2F;geometry&#x2F;circle.js\n```diff\n@@ -3,6 +3,10 @@\n â”Š 3â”Š 3â”Š    this.circle = new Engine.Geometry.Circle(1, 1, 5, 0, 1.5 * Math.PI);\n â”Š 4â”Š 4â”Š  });\n â”Š 5â”Š 5â”Š\n+â”Š  â”Š 6â”Š  afterEach(function () {\n+â”Š  â”Š 7â”Š    this.circle.delete();\n+â”Š  â”Š 8â”Š  });\n+â”Š  â”Š 9â”Š\n â”Š 6â”Š10â”Š  describe(\"getX method\", function() {\n â”Š 7â”Š11â”Š    describe(\"given inranged rad\", function() {\n â”Š 8â”Š12â”Š      it(\"returns x\", function() {\n```\n```diff\n@@ -64,6 +68,8 @@\n â”Š64â”Š68â”Š          { x: -2, y: -3 },\n â”Š65â”Š69â”Š          { x: -2, y: 5 }\n â”Š66â”Š70â”Š        ]);\n+â”Š  â”Š71â”Š\n+â”Š  â”Š72â”Š        circle.delete();\n â”Š67â”Š73â”Š      });\n â”Š68â”Š74â”Š    });\n â”Š69â”Š75â”Š\n```\n```diff\n@@ -74,6 +80,8 @@\n â”Š74â”Š80â”Š        expect(this.circle.getCircleIntersection(circle)).toEqual([\n â”Š75â”Š81â”Š          { x: -2, y: 5 }\n â”Š76â”Š82â”Š        ]);\n+â”Š  â”Š83â”Š\n+â”Š  â”Š84â”Š        circle.delete();\n â”Š77â”Š85â”Š      });\n â”Š78â”Š86â”Š    });\n â”Š79â”Š87â”Š\n```\n```diff\n@@ -84,6 +92,8 @@\n â”Š84â”Š92â”Š        expect(this.circle.getCircleIntersection(circle)).toEqual([\n â”Š85â”Š93â”Š          { x: -4, y: 1 }\n â”Š86â”Š94â”Š        ]);\n+â”Š  â”Š95â”Š\n+â”Š  â”Š96â”Š        circle.delete();\n â”Š87â”Š97â”Š      });\n â”Š88â”Š98â”Š    });\n â”Š89â”Š99â”Š\n```\n```diff\n@@ -91,6 +101,7 @@\n â”Š 91â”Š101â”Š      it(\"returns nothing\", function() {\n â”Š 92â”Š102â”Š        let circle = new Engine.Geometry.Circle(10, 10, 2, 0, 2 * Math.PI);\n â”Š 93â”Š103â”Š        expect(this.circle.getCircleIntersection(circle)).toBeUndefined();\n+â”Š   â”Š104â”Š        circle.delete();\n â”Š 94â”Š105â”Š      });\n â”Š 95â”Š106â”Š    });\n â”Š 96â”Š107â”Š\n```\n```diff\n@@ -98,6 +109,7 @@\n â”Š 98â”Š109â”Š      it(\"nothing\", function() {\n â”Š 99â”Š110â”Š        let circle = new Engine.Geometry.Circle(1, 1, 2, 0, 2 * Math.PI);\n â”Š100â”Š111â”Š        expect(this.circle.getCircleIntersection(circle)).toBeUndefined();\n+â”Š   â”Š112â”Š        circle.delete();\n â”Š101â”Š113â”Š      });\n â”Š102â”Š114â”Š    });\n â”Š103â”Š115â”Š  });\n```\n\n##### Changed resources&#x2F;scripts&#x2F;specs&#x2F;engine&#x2F;geometry&#x2F;polygon.js\n```diff\n@@ -64,6 +64,8 @@\n â”Š64â”Š64â”Š          { x: 2, y: 0 },\n â”Š65â”Š65â”Š          { x: 0, y: 2 }\n â”Š66â”Š66â”Š        ]);\n+â”Š  â”Š67â”Š\n+â”Š  â”Š68â”Š        circle.delete();\n â”Š67â”Š69â”Š      });\n â”Š68â”Š70â”Š    });\n â”Š69â”Š71â”Š\n```\n```diff\n@@ -74,6 +76,8 @@\n â”Š74â”Š76â”Š        expect(this.polygon.getCircleIntersection(circle)).toEqual([\n â”Š75â”Š77â”Š          { x: 2, y: 0 }\n â”Š76â”Š78â”Š        ]);\n+â”Š  â”Š79â”Š\n+â”Š  â”Š80â”Š        circle.delete();\n â”Š77â”Š81â”Š      });\n â”Š78â”Š82â”Š    });\n â”Š79â”Š83â”Š\n```\n```diff\n@@ -84,6 +88,8 @@\n â”Š84â”Š88â”Š        expect(this.polygon.getCircleIntersection(circle)).toEqual([\n â”Š85â”Š89â”Š          { x: 0, y: 3 }\n â”Š86â”Š90â”Š        ]);\n+â”Š  â”Š91â”Š\n+â”Š  â”Š92â”Š        circle.delete();\n â”Š87â”Š93â”Š      });\n â”Š88â”Š94â”Š    });\n â”Š89â”Š95â”Š\n```\n```diff\n@@ -91,6 +97,7 @@\n â”Š 91â”Š 97â”Š      it(\"returns nothing\", function() {\n â”Š 92â”Š 98â”Š        let circle = new Engine.Geometry.Circle(10, 10, 2, 0, 2 * Math.PI);\n â”Š 93â”Š 99â”Š        expect(this.polygon.getCircleIntersection(circle)).toBeUndefined();\n+â”Š   â”Š100â”Š        circle.delete();\n â”Š 94â”Š101â”Š      });\n â”Š 95â”Š102â”Š    });\n â”Š 96â”Š103â”Š\n```\n```diff\n@@ -98,6 +105,7 @@\n â”Š 98â”Š105â”Š      it(\"nothing\", function() {\n â”Š 99â”Š106â”Š        let circle = new Engine.Geometry.Circle(2.5, 2.5, 2, 0, 2 * Math.PI);\n â”Š100â”Š107â”Š        expect(this.polygon.getCircleIntersection(circle)).toBeUndefined();\n+â”Š   â”Š108â”Š        circle.delete();\n â”Š101â”Š109â”Š      });\n â”Š102â”Š110â”Š    });\n â”Š103â”Š111â”Š  });\n```\n\n[}]: #\n\nOur C++ code should be finished now, and all the tests should be passing. The only thing left to do would be applying it to our game. Like any other application, we first need to reference the script file so it can be loaded, in this case, the C++ bundle script:\n\n[{]: <helper> (diffStep 7.24)\n\n#### [Step 7.24: Load CPP bundle in game](https://github.com/DAB0mB/radial-snake/commit/a2c0d46)\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -8,6 +8,7 @@\n â”Š 8â”Š 8â”Š    <script type=\"text/javascript\" src=\"/libs/underscore.js\"></script>\n â”Š 9â”Š 9â”Š\n â”Š10â”Š10â”Š    <!-- Scripts -->\n+â”Š  â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/cpp.bundle.js\"></script>\n â”Š11â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/utils.js\"></script>\n â”Š12â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/geometry/line.js\"></script>\n```\n\n[}]: #\n\nAnd now we need to make sure to dispose the geometry shapes correctly so we won't experience any unnecessary memory leaks. Most of our disposals should go to the snake entity, since it's made out of shapes; So we will add a `delete` method to the snake entity and we will dispose it whenever a match is finished:\n\n[{]: <helper> (diffStep 7.25)\n\n#### [Step 7.25: Delete shape instances in game](https://github.com/DAB0mB/radial-snake/commit/ae58323)\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;game.js\n```diff\n@@ -95,6 +95,7 @@\n â”Š 95â”Š 95â”Š  changeScreen(Screen, ...screenArgs) {\n â”Š 96â”Š 96â”Š    // If there is a screen defined, dispose it first\n â”Š 97â”Š 97â”Š    if (this.screen) {\n+â”Š   â”Š 98â”Š      this.screen.delete();\n â”Š 98â”Š 99â”Š      this.unloadScreen();\n â”Š 99â”Š100â”Š      this.screen.disposeEventListeners();\n â”Š100â”Š101â”Š    }\n```\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;layer.js\n```diff\n@@ -23,6 +23,9 @@\n â”Š23â”Š23â”Š    this.canvas = screen.game.canvas;\n â”Š24â”Š24â”Š  }\n â”Š25â”Š25â”Š\n+â”Š  â”Š26â”Š  delete() {\n+â”Š  â”Š27â”Š  }\n+â”Š  â”Š28â”Š\n â”Š26â”Š29â”Š  update(span) {\n â”Š27â”Š30â”Š  }\n â”Š28â”Š31â”Š\n```\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;screen.js\n```diff\n@@ -28,6 +28,13 @@\n â”Š28â”Š28â”Š    return this;\n â”Š29â”Š29â”Š  }\n â”Š30â”Š30â”Š\n+â”Š  â”Š31â”Š   // Delete all layers. Same as 'unload', only it disposes memory rather than assets\n+â”Š  â”Š32â”Š  delete() {\n+â”Š  â”Š33â”Š    this.layers.forEach(layer => {\n+â”Š  â”Š34â”Š      layer.delete();\n+â”Š  â”Š35â”Š    });\n+â”Š  â”Š36â”Š  }\n+â”Š  â”Š37â”Š\n â”Š31â”Š38â”Š  // Updates each layer\n â”Š32â”Š39â”Š  update(span) {\n â”Š33â”Š40â”Š    this.layers.forEach(layer => {\n```\n```diff\n@@ -61,6 +68,7 @@\n â”Š61â”Š68â”Š  removeLayer(layer) {\n â”Š62â”Š69â”Š    this.layers = _.without(this.layers, layer);\n â”Š63â”Š70â”Š    layer.disposeEventListeners();\n+â”Š  â”Š71â”Š    layer.delete();\n â”Š64â”Š72â”Š  }\n â”Š65â”Š73â”Š\n â”Š66â”Š74â”Š  initEventListeners() {\n```\n\n##### Changed resources&#x2F;scripts&#x2F;game&#x2F;entities&#x2F;snake.js\n```diff\n@@ -31,6 +31,10 @@\n â”Š31â”Š31â”Š    }\n â”Š32â”Š32â”Š  }\n â”Š33â”Š33â”Š\n+â”Š  â”Š34â”Š  delete() {\n+â”Š  â”Š35â”Š    this.shapes.forEach(shape => shape.delete());\n+â”Š  â”Š36â”Š  }\n+â”Š  â”Š37â”Š\n â”Š34â”Š38â”Š  draw(context) {\n â”Š35â”Š39â”Š    // Draw all shapes in the shapes array\n â”Š36â”Š40â”Š    this.shapes.forEach(shape => {\n```\n```diff\n@@ -229,6 +233,8 @@\n â”Š229â”Š233â”Š      [0, height, 0, 0]\n â”Š230â”Š234â”Š    );\n â”Š231â”Š235â”Š\n-â”Š232â”Š   â”Š    return canvasPolygon.getIntersection(this.lastBit);\n+â”Š   â”Š236â”Š    let result = canvasPolygon.getIntersection(this.lastBit);\n+â”Š   â”Š237â”Š    canvasPolygon.delete();\n+â”Š   â”Š238â”Š    return result;\n â”Š233â”Š239â”Š  }\n â”Š234â”Š240â”Š};ðŸš«â†µ\n```\n\n##### Changed resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;play&#x2F;snake.js\n```diff\n@@ -43,6 +43,10 @@\n â”Š43â”Š43â”Š    screen.appendLayer(Game.Screens.Play.Score, this.snakes);\n â”Š44â”Š44â”Š  }\n â”Š45â”Š45â”Š\n+â”Š  â”Š46â”Š  unload() {\n+â”Š  â”Š47â”Š    this.snakes.forEach(snake => snake.delete());\n+â”Š  â”Š48â”Š  }\n+â”Š  â”Š49â”Š\n â”Š46â”Š50â”Š  draw(context) {\n â”Š47â”Š51â”Š    // Draw each snake in the snakes array\n â”Š48â”Š52â”Š    this.snakes.forEach(snake => snake.draw(context));\n```\n\n[}]: #\n\nCongratulations! You've created a C++ cross JavaScript game. There shouldn't be any significant difference between the C++ version of the game and the JavaScript version on most machines, since the game is very small and barely requires any processing power. You'll probably notice the difference when starting to extend the game by adding terrains or more snakes.\n\nOne might ask - \"How much faster does my game actually run?\". The short answer is - around 50%. Why did I run into this conclusion? Well, take a look at the following JavaScript code snippet, for calculating Fibonacci of 42:\n\n```js\nfunction fib(x) {\n  if (x < 2) {\n    return 1;\n  }\n  else {\n    return fib(x - 1) + fib(x - 2);\n  }\n}\n```\n\nThe same code snippet should look almost identical written in C++:\n\n```cpp\nint fib(int x) {\n  if (x < 2) {\n    return 1;\n  }\n  else {\n    return fib(x - 1) + fib(x - 2);\n  }\n}\n```\n\nHowever, the run-times are completely different! I compared the average of 10 runs in 3 different environments, and I received the following results:\n\n![chart](https://cloud.githubusercontent.com/assets/7648874/22802494/2591025e-eef8-11e6-9679-10b5bca0ef30.png)\n\nAs you can see, the generated C++ is much faster, and to be precise, 57% faster! Surprisingly, I didn't have any significant difference between Emscripten generated C++ and natively compiled executable.\n\nC++ is more complex to write, but it certainly has its advantages over JavaScript. Remember, now that you know that you have the possibility to run C++ in the browser, make sure to use it, but never overdo it, always find the right balance between readability and performance.\n\n> *Sources:*\n> - *https://kripken.github.io/emscripten-site/docs/introducing_emscripten/index.html*\n> - *http://www.crunchy.com/?q=content/emscripten-perfectly-cromulent-compiler*\n> - *http://stackoverflow.com/questions/2354725/what-exactly-is-llvm*"
          }
        ]
      },
      {
        "releaseVersion": "0.1.0",
        "releaseDate": "2017-02-10 22:25:13 -0200",
        "tagName": "master@0.1.0",
        "tagRevision": "4757b21855dc427d65f5b866b73bed00db84e559",
        "historyRevision": "1b7aafcd0c64a5b78437d32e76925dd67d9b9b19",
        "changesDiff": "diff --git a/.gitignore b/.gitignore\nindex 5171c54..da0043f 100644\n--- a/.gitignore\n+++ b/.gitignore\n@@ -1,2 +1,4 @@\n node_modules\n-npm-debug.log\n\\ No newline at end of file\n+npm-debug.log\n+resources/assets/fonts/*.json\n+resources/scripts/cpp.bundle.js\n\\ No newline at end of file\ndiff --git a/manuals/templates/root.md b/manuals/templates/root.md\nindex 8588e1f..a040321 100644\n--- a/manuals/templates/root.md\n+++ b/manuals/templates/root.md\n@@ -16,7 +16,7 @@ Make sure you have the following software installed:\n - NodeJS with an ECMAScript 2015 support (v6.0.0 and above).\n - Any web-browser which supports ECMAScript 2015, with a preference for Google Chrome.\n \n-> The final result is presented in the GIF file above.\n+> The final project is a hybrid of C++ and JavaScript. A JavaScript **only** version of this tutorial is available [here](https://github.com/DAB0mB/radial-snake/tree/step6).\n \n This tutorial is mostly based on pure JavaScript, so people can have a deeper understanding of the language and its dynamics. In addition, this tutorial makes a great practice on how to build a nice architecture for complex systems, which can then be expanded and maintained with ease. Yes, it is specifically designed for games, but I truly believe that video games can easily get messed up if not planned and designed properly in terms of object oriented relationships. They are naturally more complicated then any web-app you gonna see out there, so if you can create a game engine and understand its flow, creating a web-app would be a piece of cake for you. By the end of this tutorial, your general sense for programming should be enhanced greatly.\n \ndiff --git a/manuals/templates/step2.md b/manuals/templates/step2.md\nindex cfcbb81..73ceadf 100644\n--- a/manuals/templates/step2.md\n+++ b/manuals/templates/step2.md\n@@ -41,7 +41,7 @@ A game loop can wear many forms, but the concept is gonna be the same, plus-minu\n \n {{{diff_step 2.5}}}\n \n-The only thing it's doing right now is only drawing a black background, but we're soon going to learn how to take advantage of this game-loop to draw stuff of our own. I want to point out that there is no need to implement a [double-buffer](https://en.wikipedia.org/wiki/Multiple_buffering) (A method similar to React's [virtual DOM](https://www.npmjs.com/package/react-dom)) when it comes to `HTMLCanvas` elements, since `HTML5` already does that for us. To start running the game, we first need to wait for the DOM content to initialize, and once it's ready we gonna create a new game instance and call the `play` method:\n+The only thing it's doing right now is drawing a black background, but we're soon going to learn how to take advantage of this game-loop to draw stuff of our own. I'd like to point out that there is no need to implement a [double-buffer](https://en.wikipedia.org/wiki/Multiple_buffering) (A method similar to React's [virtual DOM](https://www.npmjs.com/package/react-dom)) when it comes to `HTMLCanvas` elements, since `HTML5` already does that for us. To start running the game, we first need to wait for the DOM content to initialize, and once it's ready we gonna create a new game instance and call the `play` method:\n \n {{{diff_step 2.6}}}\n \ndiff --git a/manuals/templates/step4.md b/manuals/templates/step4.md\nindex f25f04b..8c18390 100644\n--- a/manuals/templates/step4.md\n+++ b/manuals/templates/step4.md\n@@ -38,13 +38,17 @@ This script will take everything that's in the `fonts` dir and parser it as ment\n     $ npm install --save underscore\n     $ npm install --save xmldom\n \n-And instead of running the parser manually over and over again whenever we wanna use it, we will add an NPM script called `parse:fonts`:\n+And instead of running the parser manually over and over again whenever we wanna use it, we will use the following `NPM` script instead:\n \n {{{diff_step 4.8}}}\n \n+We don't want the generated fonts to be included by `git` since they are going to automatically regenerate themselves, therefore we gonna add the following ignore rule:\n+\n+{{{diff_step 4.9}}}\n+\n Now we will build our `minecraftia` font by simply running:\n \n-    $ npm run parse:fonts\n+    $ npm run build:fonts\n \n And voila! We have a freshly created `json` file which we can work with. You can also get it from here:\n \n@@ -52,24 +56,24 @@ And voila! We have a freshly created `json` file which we can work with. You can\n \n Now that we have our assets finally ready we can go ahead and focus on extending the engine which powers up our game. We need some sort of a generic font-engine which will know how to load a font file and create a text-sprite out of it. First we will implement a class called `Restorable`, which shares the same restore API as the CanvasRenderingContext2D and will give us the ability to save and restore the font's state (More information can be found [here](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/restore)):\n \n-{{{diff_step 4.10}}}\n+{{{diff_step 4.11}}}\n \n And now we can go ahead and implement the font class itself:\n \n-{{{diff_step 4.11}}}\n+{{{diff_step 4.12}}}\n \n The font API shares a similar API as [HTMLImageElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/Image), once we set the `src` property the font will start loading itself, and the `onload` user-defined callback should be called once finished. Another neat feature would be the `createTexture` method, which takes a string as its first argument, representing the text that we would like to generate, and returns an instance of the `Sprite` class.\n \n We will also be adding the option to load some font assets in our asset-loader:\n \n-{{{diff_step 4.12}}}\n+{{{diff_step 4.13}}}\n \n And replace the instructions texture loading with a `minecraftia` font loading in the initial splash screen:\n \n-{{{diff_step 4.13}}}\n+{{{diff_step 4.14}}}\n \n Now it can use us in the main menu screen where we will create a text-sprite saying `Press a key to start`, just like the instruction sprite we're about to replace:\n \n-{{{diff_step 4.14}}}\n+{{{diff_step 4.15}}}\n \n It shouldn't look any different from the beginning of the step where we manually drew the instruction texture, but in the next steps we will be using the font-engine a lot, and you will be thankful for what we've just did.\n\\ No newline at end of file\ndiff --git a/manuals/templates/step7.md b/manuals/templates/step7.md\nindex 800619a..476a795 100644\n--- a/manuals/templates/step7.md\n+++ b/manuals/templates/step7.md\n@@ -1,3 +1,240 @@\n-### TBA ###\n+> This step is part of a bigger tutorial series where we learn how to create a game engine and implement a Tron-style game in JavaScript. The base project for the following step is available [here](https://github.com/DAB0mB/radial-snake/tree/step6).\n \n-Oops! It looks that this step is not yet implemented. Stay tuned for upcoming updates.\n\\ No newline at end of file\n+So far I covered up pretty much everything I planned. I showed you how to create a game engine, including a font generator, an animation player and a screening system. On top of that, we've learned how to structure and organize our code well, so if in the future we'd like to extend our game by adding more screens or capabilities, we can do that with ease. Indeed, we've went through lots of great stuff, and if you've reached this point I give you my thumbs up. If so far this wasn't enough, in this step we will be focusing on optimization, and making our game engine run faster (a lot, faster). Obviously, when talking about optimizations, the first thing you would probably think of is how we can make our algorithms efficient by using minimum number of operations. While this is true, we will be actually focusing on optimizing our code using C++.\n+\n+Unlike JavaScript, which is a dynamic scripting file executed by an interpreter, C++ is a general purpose language which compiles into executables. Naturally, executables are much faster than scripts, since they don't have to be interpreted, and they can approach the hardware and memory much faster. In C++, we have to explicitly define our data-types, meaning that variables don't have to be parsed during run-time. While explicit variables definition is C++'s biggest drawback, it's also one of its biggest advantages. The mere fact that variables can be handled much faster, makes code much more efficient.\n+\n+Accordingly, we can conclude that the programming language we're using plays a very important role when it comes to efficiency. So how exactly are we going to integrate C++ into the browser? We're going to do that by using a compiler called - [Emscripten](http://kripken.github.io/emscripten-site/).\n+\n+![emscripten](https://cloud.githubusercontent.com/assets/7648874/22675449/ee6d7e9c-eccc-11e6-9570-1dd5d982ee66.png)\n+\n+Emscripten is an Open Source [LLVM](https://en.wikipedia.org/wiki/LLVM) to JavaScript compiler. Using Emscripten you can:\n+\n+- Compile C and C++ code into JavaScript\n+- Compile any other code that can be translated into LLVM bitcode into JavaScript.\n+- Compile the C/C++ runtimes of other languages into JavaScript, and then run code in those other languages in an indirect way (this has been done for Python and Lua)!\n+\n+LLVM is a library that is used to construct, optimize and produce intermediate and/or binary machine code. LLVM can be used as a compiler framework, where you provide the \"front end\" (parser and lexer) and the \"back end\" (code that converts LLVM's representation to actual machine code). LLVM can also act as a JIT compiler - it has support for x86/x86_64 and PPC/PPC64 assembly generation with fast code optimizations aimed for compilation speed.\n+\n+Emscripten operates by taking LLVM code and converting it into a subset of JavaScript called asm.js that can run anywhere that JavaScript can run (usually the browser, but also Node.js, etc.) and is easy for browsers to optimize. This means that you can basically write web applications in any language that has an LLVM compiler.\n+\n+![emscripten-flow](https://cloud.githubusercontent.com/assets/7648874/22675751/b244b76c-ecce-11e6-917e-f7039ed4b340.png)\n+\n+In order to use Emscripten you will first have to install it. I recommend you to follow Emscripten's official installation instructions at their website over [here](https://kripken.github.io/emscripten-site/docs/getting_started/downloads.html). Installing Emscripten might be a bit tiring for some, I know for me it was, but if you're hyped about writing native code in the browser as much as I do, take as much time as needed to install it, and bare with me.\n+\n+Assuming that you have Emscripten installed, we can get right to business. The goal for this step is to re-implement our geometry namespace in C++, and to be more specific, the circle class and line class. We will start by creating an entry file for our C++ code under the path `resources/cpp/src/index.cpp`:\n+\n+    $ mkdir resources/cpp\n+    $ mkdir resources/cpp/src\n+    $ touch resources/cpp/src/index.cpp\n+\n+From now on, every C++ file that we would like to run in the browser should be included in the `index.cpp` file we've just created, otherwise it's not going to appear anywhere. The first stage for re-implementing our geometry would be re-writing the utility module, since our geometry is heavily based on it; Therefore the firs inclusion in our `index.cpp` file would be the following:\n+\n+{{{diff_step 7.1}}}\n+\n+Following that, we will create the `utils.cpp` module included above, which is a direct translation from C++ to JavaScript for the `utils.js` we've created earlier in this tutorial.\n+\n+{{{diff_step 7.2}}}\n+\n+The module above should work by itself when interacting with it inside the C++ scope, but that's not what we're striving for. We want this module to be available for use in our JavaScript project. This requires us to wrap our code in such a way the the Emscripten compiler will know how to compile it. Apart from providing a compiler, Emscripten provides us with functions and macros that will help use bind our C++ code to the JavaScript environment. These functionalities are packed in a single library which can be imported in our C++ code, and it is called [Embind](https://kripken.github.io/emscripten-site/docs/porting/connecting_cpp_and_javascript/embind.html) (probably stands for \"Emscripten bind\"). Using EMBind, let's wrap our utils module accordingly:\n+\n+{{{diff_step 7.3}}}\n+\n+After a while you'll get used for Embind's API. If you'll look at it, it's self explanatory and easy to understand. Bound objects will be available the JavaScript environment will be available under an object named `Module`, e.g. the C++ method `mod` will be available for use as `Module.utils_mod`. Bound functions should have supported return types and argument types, meaning that if we're using a custom structure as a return type or an argument type, we first need to wrap it using EMBind, otherwise the compiler won't know how to handle it. A list of natively supported data-types can be found [here](https://kripken.github.io/emscripten-site/docs/porting/connecting_cpp_and_javascript/embind.html#built-in-type-conversions).\n+\n+Even though we've wrapped our C++ code and hypothetically it can already be used in the browser, I'd go for a second wrapper, since the compiled code doesn't have the optimal architecture. Right now we will have to approach C++ utility functions using `Module.utils_foo`. Instead, I'd like it to be `CPP.Utils.foo`, since it's clearer this way. The output of the Emscripten compiler can be wrapped with JavaScript code, using a prefix and a suffix, defined in 2 separate files respectively, called `pre.js` and `post.js`:\n+\n+{{{diff_step 7.4}}}\n+\n+What we've done in the code snippet above, we've created an anonymous function which calls itself, and inside we've exported a new namespace called `CPP` (C++). This way we can keep the generated code encapsulated, without worrying about spamming the global object.\n+\n+After creating a wrapper, I'd also recommend you to integrate the generated C++ code into existing namespaces, meaning that if for example we would like to approach the `CPP.Utils.foo` method, it could be done using `Utils.foo`. This way existing code won't have to be changed, and extra wrapping logic can be applied with ease, like the chaining logic implemented in the `Utils` namespace:\n+\n+{{{diff_step 7.5}}}\n+\n+Whenever launching the compiler, the generated code should be outputted somewhere. I've decided to go with the path `resources/scripts/cpp.bundle.js`, but it doesn't matter how the file is gonna be called, as long as it's defined under the `scripts` dir, otherwise we won't be able to load it. Also, we need to make sure that we set a git-ignore rule for the generated file, since there's no reason for us to upload it to the git-host if we're planning on compiling it:\n+\n+{{{diff_step 7.5}}}\n+\n+To compile our C++ code and turn it into JavaScript, we'll need to run the following command:\n+\n+    $ emcc -O1 --pre-js resources/cpp/pre.js --post-js resources/cpp/post.js --bind -o resources/scripts/cpp.bundle.js resources/cpp/src/index.cpp\n+\n+Here's a detailed list with explanations regards the arguments vector we've just passed:\n+\n+- `-01` - Optimization level 1. The higher the index, the more optimized our code is gonna be, but less readable.\n+- `--pre-js` - Specifies a JavaScript prefix for the compiled code.\n+- `--post-js` - Specifies a JavaScript postfix for the compiled code.\n+- `--bind` - Tells the compiler to use Embind\n+- `-o` - The output path.\n+\n+> More informations regards Emscripten's CLI can be found [here](https://kripken.github.io/emscripten-site/docs/tools_reference/emcc.html).\n+\n+You don't have to memorize the compilation command we've just typed, because we're gonna save it as an NPM script called `build:cpp`:\n+\n+{{{diff_step 7.6}}}\n+\n+Now if you'd like to compile the C++ code just run:\n+\n+    $ npm run build:cpp\n+\n+Moreover, the code should be compiled automatically any time you start the serer using the command:\n+\n+    $ npm run serve\n+\n+We always have to be on the alert and run our tests against modules we've just translated from JavaScript to C++. This will guarantee that once we run the game we won't stumble upon any defect whatsoever. Before running the tests, be sure to import the C++ bundle in the HTML file's header:\n+\n+{{{diff_step 7.8}}}\n+\n+Now we can run the tests by running the following command:\n+\n+    $ npm run test\n+\n+At this point **all our tests should pass**. If they don't, it means our newly created utility module is not working properly, and you will have to repeat the previous steps until you get it right.\n+\n+Up next, we gonna translate the geometry line class to C++. Since it's gonna be translated almost identically, we will have to make sure that all the necessary assets are gonna be available for our class before proceeding. The first thing we will have to do would be making sure that the utility functions are chainable directly from C++ as well. To do that, we will create a chain class which should return a new instance of it whenever we're about to chain the upcoming utility method. Once calling `result()`, the accumulator should be returned:\n+\n+{{{diff_step 7.9}}}\n+\n+> Note that when coding in C++ we have to make sure that the objects are being disposed when not needed anymore, otherwise we will have some unnecessary memory leaks.\n+\n+2D shapes are presented in space using points with 2 values - `x` (axis) and `y` axis, therefore, we will create the appropriate point structure:\n+\n+{{{diff_step 7.10}}}\n+\n+Returned values can either be `null` (`undefined`) or not. Since there's no built in nullable-values mechanism in C++ (up until C++17), we're gonna create one of our own:\n+\n+{{{diff_step 7.11}}}\n+\n+Now that all the necessary assets for the line class are ready, we can go ahead and create it:\n+\n+{{{diff_step 7.12}}}\n+\n+After creating our C++, we will also need to bind it using EMBind:\n+\n+{{{diff_step 7.13}}}\n+\n+In the code snippet above, you can see that we used a special data-type called `val` (`emscripten::val`). `val` means that just like JavaScript, that function can return values that are not necessarily of the same data-type; For instance, the `getMatchingY` function can either return a `number` or `undefined`. If you'll take a look at the `getIntersection(Line)` method you'll notice that instead of returning the raw point structure, I chose to build a JavaScript object using the `object` data type (`emscripten::object`). `object` behaves exactly like a native JavaScript `Object`, and it can save us some precious work of binding which sometimes might be just too much.\n+\n+If you'll compare the C++ version of the line class to the JavaScript line class you'll notice that the `draw` and `getIntersection` methods are missing (when we used EMBind we renamed `getIntersection` to `getLineIntersection` because overloadings are forbidden). In addition, Emscripten's API exposes some additional class methods for generated C++ classes, like the `delete` method, which we will shed light on further in this tutorial. Inheritance would be the natural solution for such an issue, unfortunately, generated C++ constructors don't accept indirect instances. For example, if we have a C++ parent class called `Shape` and we have a JavaScript child class called `Line`, we won't be able to initialize a new instance of the `Line` class. Here's a demonstration:\n+\n+```js\n+class JSLine extends CPPShape {}\n+const line = new JSLine(); // Throws error\n+```\n+\n+There are 3 ways to implement inheritance when interacting with C++ classes:\n+\n+- Define an interface when using EMBind. This is the official way but rather complicated, since it requires us to define an extra layer for our wrapper. More information can be found [here](https://kripken.github.io/emscripten-site/docs/porting/connecting_cpp_and_javascript/embind.html#abstract-methods).\n+- Extending the prototype of exported C++ classes directly, which is not really an inheritance.\n+- Using a proxy class, which is the easiest and cleanest solution of all, but it is not really mentioned anywhere. At the same time, I didn't find any restriction regards that.\n+\n+We're gonna use the 3rd method in the list above, because as I said, it's the easiest and cleanest of all. First I will try to explain what I meant by saying \"proxy class\". If you're an intermediate JavaScript developer, you probably know that constructors can be overridden by returning a value explicitly. By doing that, we can actually bypass Emscripten's prohibitions, we can just return the newly created C++ instance and extend it in specific. Proxy classes actually take it a step further by providing a middle-class which will then inject a new link to the prototype chain of the returned instance.\n+\n+```js\n+class JSLine {\n+  constructor() {\n+    const line = new CPPShape();\n+    return line;\n+  }\n+}\n+\n+const line = new JSLine(); // Legal!\n+```\n+\n+> More information about the code snippet above can be found [here](https://www.bennadel.com/blog/2522-providing-a-return-value-in-a-javascript-constructor.htm).\n+\n+I believe that as we go through this tutorial, the concept will get much clearer. The utility function of the proxy class should look like so:\n+\n+{{{diff_step 7.14}}}\n+\n+If you'll take a look at the following line:\n+\n+```js\n+Object.setPrototypeOf(that, new.target.prototype);\n+```\n+\n+This is where the magic actually happens! It enables inheritance for explicitly returned objects; This way we can safely extend C++ classes. Accordingly, our new JavaScript line class should look like so:\n+\n+{{{diff_step 7.15}}}\n+\n+By now, our tests should pass. Accept, there is memory leak we need to handle. But you probably ask yourself - \"What memory leak? It's JavaScript man! Have you ever heard of something called garbage collector?!\". Well, this is not the case when compiling C++ code with Emscripten. You see, Emscripten uses asm.js, which is a subset for JavaScript built exactly for these proposes, enabling C++ modules run on the browser. This is how the [WebGL](https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API) project actually started, an almost complete conversion from the famous C++ [OpenGL](https://www.opengl.org/) to JavaScript. Part of what asm.js does, it disables the garbage collector, and instead, it holds raw pointers, just like in C++. Since returned class instances are pointers with unknown lifespans, they need to be disposed manually, using the `delete` method (identical to how we clear memory from the Heap in C++). Let's dispose unused test data by calling the `delete` method as just mentioned:\n+\n+{{{diff_step 7.16}}}\n+\n+Since our game also uses polygons, which is made of an abstract number of lines, its test-data needs to be disposed as well. First, we will add a `delete` method to the polygon class, which will simply go though all its bounds and delete each of its lines:\n+\n+{{{diff_step 7.17}}}\n+\n+Now we can conveniently delete unused polygons in the tests:\n+\n+{{{diff_step 7.18}}}\n+\n+Moving on, we have the circle class to transform. The process is almost the identical to how we transformed the line class, so it's gonna be way easier now. We first start by translating our code from JavaScript to C++:\n+\n+{{{diff_step 7.19}}}\n+\n+Second, we need to wrap our code using EMBind:\n+\n+{{{diff_step 7.20}}}\n+\n+And finally, we will extend the C++ in our JavaScript circle:\n+\n+{{{diff_step 7.21}}}\n+\n+We also need to update the line class to contain a reference to the newly created line-intersection method, so it can be invoked from both a line or a circle bi-directionally:\n+\n+{{{diff_step 7.22}}}\n+\n+Now, before running the tests, be sure to disposed unused circle test-data:\n+\n+{{{diff_step 7.23}}}\n+\n+Our C++ code should be finished now, and all the tests should be passing. The only thing left to do would be applying it to our game. Like any other application, we first need to reference the script file so it can be loaded, in this case, the C++ bundle script:\n+\n+{{{diff_step 7.24}}}\n+\n+And now we need to make sure to dispose the geometry shapes correctly so we won't experience any unnecessary memory leaks. Most of our disposals should go to the snake entity, since it's made out of shapes; So we will add a `delete` method to the snake entity and we will dispose it whenever a match is finished:\n+\n+{{{diff_step 7.25}}}\n+\n+Congratulations! You've created a C++ cross JavaScript game. There shouldn't be any significant difference between the C++ version of the game and the JavaScript version on most machines, since the game is very small and barely requires any processing power. You'll probably notice the difference when starting to extend the game by adding terrains or more snakes.\n+\n+One might ask - \"How much faster does my game actually run?\". The short answer is - around 50%. Why did I run into this conclusion? Well, take a look at the following JavaScript code snippet, for calculating Fibonacci of 42:\n+\n+```js\n+function fib(x) {\n+  if (x < 2) {\n+    return 1;\n+  }\n+  else {\n+    return fib(x - 1) + fib(x - 2);\n+  }\n+}\n+```\n+\n+The same code snippet should look almost identical written in C++:\n+\n+```cpp\n+int fib(int x) {\n+  if (x < 2) {\n+    return 1;\n+  }\n+  else {\n+    return fib(x - 1) + fib(x - 2);\n+  }\n+}\n+```\n+\n+However, the run-times are completely different! I compared the average of 10 runs in 3 different environments, and I received the following results:\n+\n+![chart](https://cloud.githubusercontent.com/assets/7648874/22802494/2591025e-eef8-11e6-9679-10b5bca0ef30.png)\n+\n+As you can see, the generated C++ is much faster, and to be precise, 57% faster! Surprisingly, I didn't have any significant difference between Emscripten generated C++ and natively compiled executable.\n+\n+C++ is more complex to write, but it certainly has its advantages over JavaScript. Remember, now that you know that you have the possibility to run C++ in the browser, make sure to use it, but never overdo it, always find the right balance between readability and performance.\n+\n+> *Sources:*\n+> - *https://kripken.github.io/emscripten-site/docs/introducing_emscripten/index.html*\n+> - *http://www.crunchy.com/?q=content/emscripten-perfectly-cromulent-compiler*\n+> - *http://stackoverflow.com/questions/2354725/what-exactly-is-llvm*\ndiff --git a/manuals/views/step2.md b/manuals/views/step2.md\nindex 3b947ce..e60dd6e 100644\n--- a/manuals/views/step2.md\n+++ b/manuals/views/step2.md\n@@ -246,7 +246,7 @@ A game loop can wear many forms, but the concept is gonna be the same, plus-minu\n ```\n [}]: #\n \n-The only thing it's doing right now is only drawing a black background, but we're soon going to learn how to take advantage of this game-loop to draw stuff of our own. I want to point out that there is no need to implement a [double-buffer](https://en.wikipedia.org/wiki/Multiple_buffering) (A method similar to React's [virtual DOM](https://www.npmjs.com/package/react-dom)) when it comes to `HTMLCanvas` elements, since `HTML5` already does that for us. To start running the game, we first need to wait for the DOM content to initialize, and once it's ready we gonna create a new game instance and call the `play` method:\n+The only thing it's doing right now is drawing a black background, but we're soon going to learn how to take advantage of this game-loop to draw stuff of our own. I'd like to point out that there is no need to implement a [double-buffer](https://en.wikipedia.org/wiki/Multiple_buffering) (A method similar to React's [virtual DOM](https://www.npmjs.com/package/react-dom)) when it comes to `HTMLCanvas` elements, since `HTML5` already does that for us. To start running the game, we first need to wait for the DOM content to initialize, and once it's ready we gonna create a new game instance and call the `play` method:\n \n [{]: <helper> (diff_step 2.6)\n #### Step 2.6: Create game entry point\n@@ -571,43 +571,36 @@ Now that we have the `screen` class available for us, let's apply it to the main\n  â”Š35â”Š36â”Š    this.bufferedCanvas = document.createElement(\"canvas\");\n ```\n ```diff\n-@@ -39,13 +40,19 @@\n- â”Š39â”Š40â”Š  }\n- â”Š40â”Š41â”Š\n- â”Š41â”Š42â”Š  draw() {\n--â”Š42â”Š  â”Š    // Draw a black screen by default\n- â”Š43â”Š43â”Š    this.context.restore();\n- â”Š44â”Š44â”Š    this.context.fillStyle = \"black\";\n- â”Š45â”Š45â”Š    this.context.save();\n- â”Š46â”Š46â”Š    this.context.beginPath();\n- â”Š47â”Š47â”Š    this.context.rect(0, 0, this.canvas.width, this.canvas.height);\n- â”Š48â”Š48â”Š    this.context.fill();\n-+â”Š  â”Š49â”Š    this.drawScreen(this.context);\n-+â”Š  â”Š50â”Š  }\n-+â”Š  â”Š51â”Š\n-+â”Š  â”Š52â”Š  drawScreen(context) {\n-+â”Š  â”Š53â”Š    // If screen's assets are not yet loaded, don't draw it\n-+â”Š  â”Š54â”Š    if (this.screen.loading) return;\n-+â”Š  â”Š55â”Š    if (this.screen.draw) this.screen.draw(context);\n- â”Š49â”Š56â”Š  }\n- â”Š50â”Š57â”Š\n- â”Š51â”Š58â”Š  update() {\n+@@ -46,6 +47,13 @@\n+ â”Š46â”Š47â”Š    this.context.beginPath();\n+ â”Š47â”Š48â”Š    this.context.rect(0, 0, this.canvas.width, this.canvas.height);\n+ â”Š48â”Š49â”Š    this.context.fill();\n++â”Š  â”Š50â”Š    this.drawScreen(this.context);\n++â”Š  â”Š51â”Š  }\n++â”Š  â”Š52â”Š\n++â”Š  â”Š53â”Š  drawScreen(context) {\n++â”Š  â”Š54â”Š    // If screen's assets are not yet loaded, don't draw it\n++â”Š  â”Š55â”Š    if (this.screen.loading) return;\n++â”Š  â”Š56â”Š    if (this.screen.draw) this.screen.draw(context);\n+ â”Š49â”Š57â”Š  }\n+ â”Š50â”Š58â”Š\n+ â”Š51â”Š59â”Š  update() {\n ```\n ```diff\n-@@ -56,6 +63,13 @@\n- â”Š56â”Š63â”Š    this.updateScreen(span / this.speed);\n- â”Š57â”Š64â”Š  }\n- â”Š58â”Š65â”Š\n-+â”Š  â”Š66â”Š  updateScreen(span) {\n-+â”Š  â”Š67â”Š    this.screen.age += span;\n-+â”Š  â”Š68â”Š    // If screen's assets are not yet loaded, don't update it\n-+â”Š  â”Š69â”Š    if (this.screen.loading) return;\n-+â”Š  â”Š70â”Š    if (this.screen.update) this.screen.update(span);\n-+â”Š  â”Š71â”Š  }\n-+â”Š  â”Š72â”Š\n- â”Š59â”Š73â”Š  // The main loop of the game\n- â”Š60â”Š74â”Š  loop() {\n- â”Š61â”Š75â”Š    // If paused, don't run loop. The canvas will remain as is\n+@@ -56,6 +64,13 @@\n+ â”Š56â”Š64â”Š    this.updateScreen(span / this.speed);\n+ â”Š57â”Š65â”Š  }\n+ â”Š58â”Š66â”Š\n++â”Š  â”Š67â”Š  updateScreen(span) {\n++â”Š  â”Š68â”Š    this.screen.age += span;\n++â”Š  â”Š69â”Š    // If screen's assets are not yet loaded, don't update it\n++â”Š  â”Š70â”Š    if (this.screen.loading) return;\n++â”Š  â”Š71â”Š    if (this.screen.update) this.screen.update(span);\n++â”Š  â”Š72â”Š  }\n++â”Š  â”Š73â”Š\n+ â”Š59â”Š74â”Š  // The main loop of the game\n+ â”Š60â”Š75â”Š  loop() {\n+ â”Š61â”Š76â”Š    // If paused, don't run loop. The canvas will remain as is\n ```\n [}]: #\n \n@@ -655,65 +648,68 @@ Now that we have the `assets loader` we can add the ability to change a screen.\n \n ##### Changed resources/scripts/engine/game.js\n ```diff\n-@@ -91,6 +91,58 @@\n- â”Š 91â”Š 91â”Š    this.playing = false;\n- â”Š 92â”Š 92â”Š  }\n- â”Š 93â”Š 93â”Š\n-+â”Š   â”Š 94â”Š  changeScreen(Screen, ...screenArgs) {\n-+â”Š   â”Š 95â”Š    // If there is a screen defined, dispose it first\n-+â”Š   â”Š 96â”Š    if (this.screen) {\n-+â”Š   â”Š 97â”Š      this.unloadScreen();\n-+â”Š   â”Š 98â”Š      this.screen.disposeEventListeners();\n-+â”Š   â”Š 99â”Š    }\n-+â”Š   â”Š100â”Š\n-+â”Š   â”Š101â”Š    this.screen = new Screen(this, ...screenArgs);\n-+â”Š   â”Š102â”Š\n-+â”Š   â”Š103â”Š    // Load screen assets\n-+â”Š   â”Š104â”Š    this.loadScreen(() => {\n-+â”Š   â”Š105â”Š      // Once assets are loaded, initialize event listeners\n-+â”Š   â”Š106â”Š      this.screen.initEventListeners();\n-+â”Š   â”Š107â”Š      // The \"initialize\" method is exactly the same as the constructor, only it runs\n-+â”Š   â”Š108â”Š      // once assets are available and event listeners are registered\n-+â”Š   â”Š109â”Š      this.screen.initialize(this, ...screenArgs);\n-+â”Š   â”Š110â”Š    });\n-+â”Š   â”Š111â”Š  }\n-+â”Š   â”Š112â”Š\n-+â”Š   â”Š113â”Š  // Loads screen assets and invokes callback once loading is finished\n-+â”Š   â”Š114â”Š  loadScreen(callback = _.noop) {\n-+â”Š   â”Š115â”Š    if (!this.screen.load) return callback();\n-+â”Š   â”Š116â”Š\n-+â”Š   â”Š117â”Š    this.screen.loading = true;\n-+â”Š   â”Š118â”Š    // The number of assets to load\n-+â”Š   â”Š119â”Š    let loadsize = 0;\n-+â”Š   â”Š120â”Š\n-+â”Š   â”Š121â”Š    // We use the \"after\" method because we want the following callback to be invoked\n-+â”Š   â”Š122â”Š    // only once all assets are loaded\n-+â”Š   â”Š123â”Š    let onload = _.after(loadsize, () => {\n-+â”Š   â”Š124â”Š      delete this.screen.loading;\n-+â”Š   â”Š125â”Š      callback();\n-+â”Š   â”Š126â”Š    });\n-+â”Š   â”Š127â”Š\n-+â”Š   â”Š128â”Š    // This object can load assets\n-+â”Š   â”Š129â”Š    let assetsLoader = new Engine.AssetsLoader(() => {\n-+â”Š   â”Š130â”Š      loadsize++;\n-+â”Š   â”Š131â”Š      return () => onload();\n-+â”Š   â”Š132â”Š    });\n-+â”Š   â”Š133â”Š\n-+â”Š   â”Š134â”Š    // The \"load\" method returns the assets loaded by the screen\n-+â”Š   â”Š135â”Š    let screenAssets = this.screen.load(assetsLoader);\n-+â”Š   â”Š136â”Š    // The returned assets will be available on screen's assets object\n-+â”Š   â”Š137â”Š    _.extend(this.screen.assets, screenAssets);\n-+â”Š   â”Š138â”Š  }\n-+â”Š   â”Š139â”Š\n-+â”Š   â”Š140â”Š  // Disposes screen assets\n-+â”Š   â”Š141â”Š  unloadScreen() {\n-+â”Š   â”Š142â”Š    let assetsNames = this.screen.unload && this.screen.unload();\n-+â”Š   â”Š143â”Š    _.omit(this.assets, assetsNames);\n-+â”Š   â”Š144â”Š  }\n-+â”Š   â”Š145â”Š\n- â”Š 94â”Š146â”Š  // Defines global assets\n- â”Š 95â”Š147â”Š  extendAssets(assets) {\n- â”Š 96â”Š148â”Š    _.extend(this.assets, assets);\n+@@ -92,6 +92,61 @@\n+ â”Š 92â”Š 92â”Š    this.playing = false;\n+ â”Š 93â”Š 93â”Š  }\n+ â”Š 94â”Š 94â”Š\n++â”Š   â”Š 95â”Š  changeScreen(Screen, ...screenArgs) {\n++â”Š   â”Š 96â”Š    // If there is a screen defined, dispose it first\n++â”Š   â”Š 97â”Š    if (this.screen) {\n++â”Š   â”Š 98â”Š      this.unloadScreen();\n++â”Š   â”Š 99â”Š      this.screen.disposeEventListeners();\n++â”Š   â”Š100â”Š    }\n++â”Š   â”Š101â”Š\n++â”Š   â”Š102â”Š    this.screen = new Screen(this, ...screenArgs);\n++â”Š   â”Š103â”Š\n++â”Š   â”Š104â”Š    // Load screen assets\n++â”Š   â”Š105â”Š    this.loadScreen(() => {\n++â”Š   â”Š106â”Š      // Once assets are loaded, initialize event listeners\n++â”Š   â”Š107â”Š      this.screen.initEventListeners();\n++â”Š   â”Š108â”Š      // The \"initialize\" method is exactly the same as the constructor, only it runs\n++â”Š   â”Š109â”Š      // once assets are available and event listeners are registered\n++â”Š   â”Š110â”Š      this.screen.initialize(this, ...screenArgs);\n++â”Š   â”Š111â”Š    });\n++â”Š   â”Š112â”Š  }\n++â”Š   â”Š113â”Š\n++â”Š   â”Š114â”Š  // Loads screen assets and invokes callback once loading is finished\n++â”Š   â”Š115â”Š  loadScreen(callback = _.noop) {\n++â”Š   â”Š116â”Š    if (!this.screen.load) return callback();\n++â”Š   â”Š117â”Š\n++â”Š   â”Š118â”Š    this.screen.loading = true;\n++â”Š   â”Š119â”Š    // The number of assets to load\n++â”Š   â”Š120â”Š    let loadsize = 0;\n++â”Š   â”Š121â”Š    let onload;\n++â”Š   â”Š122â”Š\n++â”Š   â”Š123â”Š    // This object can load assets\n++â”Š   â”Š124â”Š    let assetsLoader = new Engine.AssetsLoader(() => {\n++â”Š   â”Š125â”Š      loadsize++;\n++â”Š   â”Š126â”Š      return () => onload();\n++â”Š   â”Š127â”Š    });\n++â”Š   â”Š128â”Š\n++â”Š   â”Š129â”Š    // The \"load\" method returns the assets loaded by the screen\n++â”Š   â”Š130â”Š    let screenAssets = this.screen.load(assetsLoader);\n++â”Š   â”Š131â”Š\n++â”Š   â”Š132â”Š    // We use the \"after\" method because we want the following callback to be invoked\n++â”Š   â”Š133â”Š    // only once all assets are loaded\n++â”Š   â”Š134â”Š    onload = _.after(loadsize, () => {\n++â”Š   â”Š135â”Š      delete this.screen.loading;\n++â”Š   â”Š136â”Š      callback();\n++â”Š   â”Š137â”Š    });\n++â”Š   â”Š138â”Š\n++â”Š   â”Š139â”Š    // The returned assets will be available on screen's assets object\n++â”Š   â”Š140â”Š    _.extend(this.screen.assets, screenAssets);\n++â”Š   â”Š141â”Š  }\n++â”Š   â”Š142â”Š\n++â”Š   â”Š143â”Š  // Disposes screen assets\n++â”Š   â”Š144â”Š  unloadScreen() {\n++â”Š   â”Š145â”Š    if (!this.screen.unload) return;\n++â”Š   â”Š146â”Š    let assetsNames = this.screen.unload();\n++â”Š   â”Š147â”Š    _.omit(this.assets, assetsNames);\n++â”Š   â”Š148â”Š  }\n++â”Š   â”Š149â”Š\n+ â”Š 95â”Š150â”Š  // Defines global assets\n+ â”Š 96â”Š151â”Š  extendAssets(assets) {\n+ â”Š 97â”Š152â”Š    _.extend(this.assets, assets);\n ```\n [}]: #\n \ndiff --git a/manuals/views/step4.md b/manuals/views/step4.md\nindex 5e20563..72bc8d2 100644\n--- a/manuals/views/step4.md\n+++ b/manuals/views/step4.md\n@@ -260,7 +260,7 @@ This script will take everything that's in the `fonts` dir and parser it as ment\n     $ npm install --save underscore\n     $ npm install --save xmldom\n \n-And instead of running the parser manually over and over again whenever we wanna use it, we will add an NPM script called `parse:fonts`:\n+And instead of running the parser manually over and over again whenever we wanna use it, we will use the following `NPM` script instead:\n \n [{]: <helper> (diff_step 4.8)\n #### Step 4.8: Add font parsing npm scripts\n@@ -273,16 +273,31 @@ And instead of running the parser manually over and over again whenever we wanna\n  â”Š 5â”Š 5â”Š  \"scripts\": {\n -â”Š 6â”Š  â”Š    \"serve\": \"nodemon server.js\"\n +â”Š  â”Š 6â”Š    \"serve\": \"npm run parse:fonts && nodemon server.js\",\n-+â”Š  â”Š 7â”Š    \"parse:fonts\": \"node helpers/font_parser.js\"\n++â”Š  â”Š 7â”Š    \"build:fonts\": \"node helpers/font_parser.js\"\n  â”Š 7â”Š 8â”Š  },\n  â”Š 8â”Š 9â”Š  \"dependencies\": {\n  â”Š 9â”Š10â”Š    \"async\": \"^2.1.4\",\n ```\n [}]: #\n \n+We don't want the generated fonts to be included by `git` since they are going to automatically regenerate themselves, therefore we gonna add the following ignore rule:\n+\n+[{]: <helper> (diff_step 4.9)\n+#### Step 4.9: Add rule to to git-ignore parsed fonts\n+\n+##### Changed .gitignore\n+```diff\n+@@ -1,2 +1,3 @@\n+ â”Š1â”Š1â”Šnode_modules\n+-â”Š2â”Š â”Šnpm-debug.logðŸš«â†µ\n++â”Š â”Š2â”Šnpm-debug.log\n++â”Š â”Š3â”Šresources/assets/fonts/*.jsonðŸš«â†µ\n+```\n+[}]: #\n+\n Now we will build our `minecraftia` font by simply running:\n \n-    $ npm run parse:fonts\n+    $ npm run build:fonts\n \n And voila! We have a freshly created `json` file which we can work with. You can also get it from here:\n \n@@ -290,8 +305,8 @@ And voila! We have a freshly created `json` file which we can work with. You can\n \n Now that we have our assets finally ready we can go ahead and focus on extending the engine which powers up our game. We need some sort of a generic font-engine which will know how to load a font file and create a text-sprite out of it. First we will implement a class called `Restorable`, which shares the same restore API as the CanvasRenderingContext2D and will give us the ability to save and restore the font's state (More information can be found [here](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/restore)):\n \n-[{]: <helper> (diff_step 4.10)\n-#### Step 4.10: Add 'Restorable' class\n+[{]: <helper> (diff_step 4.11)\n+#### Step 4.11: Add 'Restorable' class\n \n ##### Added resources/scripts/engine/restorable.js\n ```diff\n@@ -334,8 +349,8 @@ Now that we have our assets finally ready we can go ahead and focus on extending\n \n And now we can go ahead and implement the font class itself:\n \n-[{]: <helper> (diff_step 4.11)\n-#### Step 4.11: Create font engine\n+[{]: <helper> (diff_step 4.12)\n+#### Step 4.12: Create font engine\n \n ##### Added resources/scripts/engine/font.js\n ```diff\n@@ -492,8 +507,8 @@ The font API shares a similar API as [HTMLImageElement](https://developer.mozill\n \n We will also be adding the option to load some font assets in our asset-loader:\n \n-[{]: <helper> (diff_step 4.12)\n-#### Step 4.12: Add a font loading option to 'AssetLoader'\n+[{]: <helper> (diff_step 4.13)\n+#### Step 4.13: Add a font loading option to 'AssetLoader'\n \n ##### Changed resources/scripts/engine/assets_loader.js\n ```diff\n@@ -515,8 +530,8 @@ We will also be adding the option to load some font assets in our asset-loader:\n \n And replace the instructions texture loading with a `minecraftia` font loading in the initial splash screen:\n \n-[{]: <helper> (diff_step 4.13)\n-#### Step 4.13: Load 'minecraftia' font in splash screen\n+[{]: <helper> (diff_step 4.14)\n+#### Step 4.14: Load 'minecraftia' font in splash screen\n \n ##### Changed resources/scripts/game/screens/splash/index.js\n ```diff\n@@ -544,8 +559,8 @@ And replace the instructions texture loading with a `minecraftia` font loading i\n \n Now it can use us in the main menu screen where we will create a text-sprite saying `Press a key to start`, just like the instruction sprite we're about to replace:\n \n-[{]: <helper> (diff_step 4.14)\n-#### Step 4.14: Replace texture usage with font usage in main menu screen\n+[{]: <helper> (diff_step 4.15)\n+#### Step 4.15: Replace texture usage with font usage in main menu screen\n \n ##### Changed resources/scripts/game/screens/menu/index.js\n ```diff\ndiff --git a/manuals/views/step5.md b/manuals/views/step5.md\nindex 4c80cd5..9d7cac6 100644\n--- a/manuals/views/step5.md\n+++ b/manuals/views/step5.md\n@@ -13,7 +13,7 @@ Keep in mind that a computer's precision is limited due its [binary representati\n \n ##### Added resources/scripts/utils.js\n ```diff\n-@@ -0,0 +1,78 @@\n+@@ -0,0 +1,68 @@\n +â”Š  â”Š 1â”Š// A wrapper function for our utilities which will enable chaining\n +â”Š  â”Š 2â”Š// e.g. Utils().mod().trim().isBetween()...\n +â”Š  â”Š 3â”ŠUtils = function Utils(context) {\n@@ -55,43 +55,33 @@ Keep in mind that a computer's precision is limited due its [binary representati\n +â”Š  â”Š39â”Š\n +â”Š  â”Š40â”Š// Initiates comparison operator between context number and a given number, only here\n +â”Š  â”Š41â”Š// a precision can be specified\n-+â”Š  â”Š42â”ŠUtils.compare = function (context, num, method, precision) {\n-+â”Š  â”Š43â”Š  switch (arguments.length) {\n-+â”Š  â”Š44â”Š    case 2:\n-+â”Š  â”Š45â”Š      var precision = arguments[1];\n-+â”Š  â”Š46â”Š      break;\n-+â”Š  â”Š47â”Š    case 3:\n-+â”Š  â”Š48â”Š      var method = arguments[1];\n-+â”Š  â”Š49â”Š      precision = arguments[2];\n-+â”Š  â”Š50â”Š      break;\n-+â”Š  â”Š51â”Š  }\n-+â”Š  â”Š52â”Š\n-+â”Š  â”Š53â”Š  switch (precision) {\n-+â”Š  â”Š54â”Š    // Fixed precision, \"almost equal\" with a deviation of Îµ\n-+â”Š  â”Š55â”Š    case \"f\":\n-+â”Š  â”Š56â”Š      switch (method) {\n-+â”Š  â”Š57â”Š        case \"<\": case \"<=\": return context <= num + Number.EPSILON;\n-+â”Š  â”Š58â”Š        case \">\": case \">=\": return context >= num - Number.EPSILON;\n-+â”Š  â”Š59â”Š        default: return Math.abs(context - num) <= Number.EPSILON;\n-+â”Š  â”Š60â”Š      }\n-+â”Š  â”Š61â”Š    // Pixel precision, round comparison\n-+â”Š  â”Š62â”Š    case \"px\":\n-+â”Š  â”Š63â”Š      switch (method) {\n-+â”Š  â”Š64â”Š        case \"<\": case \"<=\": return Math.round(context) <= Math.round(num);\n-+â”Š  â”Š65â”Š        case \">\": case \">=\": return Math.round(context) >= Math.round(num);\n-+â”Š  â”Š66â”Š        default: return Math.round(context) == Math.round(num);\n-+â”Š  â”Š67â”Š      }\n-+â”Š  â”Š68â”Š    // Exact precision\n-+â”Š  â”Š69â”Š    default:\n-+â”Š  â”Š70â”Š      switch (method) {\n-+â”Š  â”Š71â”Š        case \"<\": return context < num;\n-+â”Š  â”Š72â”Š        case \"<=\": return context <= num;\n-+â”Š  â”Š73â”Š        case \">\": return context > num;\n-+â”Š  â”Š74â”Š        case \">=\": return context >= num;\n-+â”Š  â”Š75â”Š        default: return context === num;\n-+â”Š  â”Š76â”Š      }\n-+â”Š  â”Š77â”Š  }\n-+â”Š  â”Š78â”Š};ðŸš«â†µ\n++â”Š  â”Š42â”ŠUtils.compare = function (context, num, method, precision = method) {\n++â”Š  â”Š43â”Š  switch (precision) {\n++â”Š  â”Š44â”Š    // Fixed precision, \"almost equal\" with a deviation of Îµ\n++â”Š  â”Š45â”Š    case \"f\":\n++â”Š  â”Š46â”Š      switch (method) {\n++â”Š  â”Š47â”Š        case \"<\": case \"<=\": return context <= num + Number.EPSILON;\n++â”Š  â”Š48â”Š        case \">\": case \">=\": return context >= num - Number.EPSILON;\n++â”Š  â”Š49â”Š        default: return Math.abs(context - num) <= Number.EPSILON;\n++â”Š  â”Š50â”Š      }\n++â”Š  â”Š51â”Š    // Pixel precision, round comparison\n++â”Š  â”Š52â”Š    case \"px\":\n++â”Š  â”Š53â”Š      switch (method) {\n++â”Š  â”Š54â”Š        case \"<\": case \"<=\": return Math.round(context) <= Math.round(num);\n++â”Š  â”Š55â”Š        case \">\": case \">=\": return Math.round(context) >= Math.round(num);\n++â”Š  â”Š56â”Š        default: return Math.round(context) == Math.round(num);\n++â”Š  â”Š57â”Š      }\n++â”Š  â”Š58â”Š    // Exact precision\n++â”Š  â”Š59â”Š    default:\n++â”Š  â”Š60â”Š      switch (method) {\n++â”Š  â”Š61â”Š        case \"<\": return context < num;\n++â”Š  â”Š62â”Š        case \"<=\": return context <= num;\n++â”Š  â”Š63â”Š        case \">\": return context > num;\n++â”Š  â”Š64â”Š        case \">=\": return context >= num;\n++â”Š  â”Š65â”Š        default: return context === num;\n++â”Š  â”Š66â”Š      }\n++â”Š  â”Š67â”Š  }\n++â”Š  â”Š68â”Š};ðŸš«â†µ\n ```\n \n ##### Changed views/game.html\n@@ -968,7 +958,7 @@ Now we will create a some tests to make sure our newly created polygon works pro\n +â”Š  â”Š33â”Š\n +â”Š  â”Š34â”Š        expect(this.polygon.getLineIntersection(line)).toEqual([\n +â”Š  â”Š35â”Š          { x: 5, y: 4 },\n-+â”Š  â”Š36â”Š          { x: -0, y: 1 }\n++â”Š  â”Š36â”Š          { x: 0, y: 1 }\n +â”Š  â”Š37â”Š        ]);\n +â”Š  â”Š38â”Š      });\n +â”Š  â”Š39â”Š    });\ndiff --git a/manuals/views/step6.md b/manuals/views/step6.md\nindex f3a8a39..fc0f724 100644\n--- a/manuals/views/step6.md\n+++ b/manuals/views/step6.md\n@@ -269,7 +269,7 @@ Now if you'll launch the game and start a new match, you should see a white `Rea\n +â”Š  â”Š60â”Š        // Don't scan for intersection with self, obviously this will always be true\n +â”Š  â”Š61â”Š        if (opponent === snake) return;\n +â”Š  â”Š62â”Š        // Disqualify if intersected with opponent\n-+â”Š  â”Š63â”Š        if (snake.getSnakeIntersection(opponent)) return this.snakes.splice(index, 1);\n++â”Š  â”Š63â”Š        if (snake.getSnakeIntersection(opponent)) this.snakes.splice(index, 1);\n +â”Š  â”Š64â”Š      });\n +â”Š  â”Š65â”Š    });\n +â”Š  â”Š66â”Š\ndiff --git a/manuals/views/step7.md b/manuals/views/step7.md\nindex a941859..3d3d3e3 100644\n--- a/manuals/views/step7.md\n+++ b/manuals/views/step7.md\n@@ -2,9 +2,2244 @@\n # Step 7: Bonus! Re-implementing geometry in C++\n [}]: #\n [{]: <region> (body)\n-### TBA ###\n+> This step is part of a bigger tutorial series where we learn how to create a game engine and implement a Tron-style game in JavaScript. The base project for the following step is available [here](https://github.com/DAB0mB/radial-snake/tree/step6).\n+\n+So far I covered up pretty much everything I planned. I showed you how to create a game engine, including a font generator, an animation player and a screening system. On top of that, we've learned how to structure and organize our code well, so if in the future we'd like to extend our game by adding more screens or capabilities, we can do that with ease. Indeed, we've went through lots of great stuff, and if you've reached this point I give you my thumbs up. If so far this wasn't enough, in this step we will be focusing on optimization, and making our game engine run faster (a lot, faster). Obviously, when talking about optimizations, the first thing you would probably think of is how we can make our algorithms efficient by using minimum number of operations. While this is true, we will be actually focusing on optimizing our code using C++.\n+\n+Unlike JavaScript, which is a dynamic scripting file executed by an interpreter, C++ is a general purpose language which compiles into executables. Naturally, executables are much faster than scripts, since they don't have to be interpreted, and they can approach the hardware and memory much faster. In C++, we have to explicitly define our data-types, meaning that variables don't have to be parsed during run-time. While explicit variables definition is C++'s biggest drawback, it's also one of its biggest advantages. The mere fact that variables can be handled much faster, makes code much more efficient.\n+\n+Accordingly, we can conclude that the programming language we're using plays a very important role when it comes to efficiency. So how exactly are we going to integrate C++ into the browser? We're going to do that by using a compiler called - [Emscripten](http://kripken.github.io/emscripten-site/).\n+\n+![emscripten](https://cloud.githubusercontent.com/assets/7648874/22675449/ee6d7e9c-eccc-11e6-9570-1dd5d982ee66.png)\n+\n+Emscripten is an Open Source [LLVM](https://en.wikipedia.org/wiki/LLVM) to JavaScript compiler. Using Emscripten you can:\n+\n+- Compile C and C++ code into JavaScript\n+- Compile any other code that can be translated into LLVM bitcode into JavaScript.\n+- Compile the C/C++ runtimes of other languages into JavaScript, and then run code in those other languages in an indirect way (this has been done for Python and Lua)!\n+\n+LLVM is a library that is used to construct, optimize and produce intermediate and/or binary machine code. LLVM can be used as a compiler framework, where you provide the \"front end\" (parser and lexer) and the \"back end\" (code that converts LLVM's representation to actual machine code). LLVM can also act as a JIT compiler - it has support for x86/x86_64 and PPC/PPC64 assembly generation with fast code optimizations aimed for compilation speed.\n+\n+Emscripten operates by taking LLVM code and converting it into a subset of JavaScript called asm.js that can run anywhere that JavaScript can run (usually the browser, but also Node.js, etc.) and is easy for browsers to optimize. This means that you can basically write web applications in any language that has an LLVM compiler.\n+\n+![emscripten-flow](https://cloud.githubusercontent.com/assets/7648874/22675751/b244b76c-ecce-11e6-917e-f7039ed4b340.png)\n+\n+In order to use Emscripten you will first have to install it. I recommend you to follow Emscripten's official installation instructions at their website over [here](https://kripken.github.io/emscripten-site/docs/getting_started/downloads.html). Installing Emscripten might be a bit tiring for some, I know for me it was, but if you're hyped about writing native code in the browser as much as I do, take as much time as needed to install it, and bare with me.\n+\n+Assuming that you have Emscripten installed, we can get right to business. The goal for this step is to re-implement our geometry namespace in C++, and to be more specific, the circle class and line class. We will start by creating an entry file for our C++ code under the path `resources/cpp/src/index.cpp`:\n+\n+    $ mkdir resources/cpp\n+    $ mkdir resources/cpp/src\n+    $ touch resources/cpp/src/index.cpp\n+\n+From now on, every C++ file that we would like to run in the browser should be included in the `index.cpp` file we've just created, otherwise it's not going to appear anywhere. The first stage for re-implementing our geometry would be re-writing the utility module, since our geometry is heavily based on it; Therefore the firs inclusion in our `index.cpp` file would be the following:\n+\n+[{]: <helper> (diff_step 7.1)\n+#### Step 7.1: Add CPP entry script\n+\n+##### Added resources/cpp/src/index.cpp\n+```diff\n+@@ -0,0 +1 @@\n++â”Š â”Š1â”Š#include \"utils.cpp\"ðŸš«â†µ\n+```\n+[}]: #\n+\n+Following that, we will create the `utils.cpp` module included above, which is a direct translation from C++ to JavaScript for the `utils.js` we've created earlier in this tutorial.\n+\n+[{]: <helper> (diff_step 7.2)\n+#### Step 7.2: Add base utility CPP module\n+\n+##### Added resources/cpp/src/utils.cpp\n+```diff\n+@@ -0,0 +1,73 @@\n++â”Š  â”Š 1â”Š#include <cfloat>\n++â”Š  â”Š 2â”Š#include <cmath>\n++â”Š  â”Š 3â”Š#include <string>\n++â”Š  â”Š 4â”Š#include \"utils.h\"\n++â”Š  â”Š 5â”Š\n++â”Š  â”Š 6â”Šnamespace utils {\n++â”Š  â”Š 7â”Š  // Fixed modulo method which can calculate modulo of negative numbers properly\n++â”Š  â”Š 8â”Š  // e.g. (-803).mod(800) returns 797\n++â”Š  â”Š 9â”Š  double mod(double context, double num) {\n++â”Š  â”Š10â”Š    return std::fmod((std::fmod(context, num) + num), num);\n++â”Š  â”Š11â”Š  }\n++â”Š  â”Š12â”Š\n++â”Š  â”Š13â”Š  // Trims number and leaves the number of decimals specified.\n++â”Š  â”Š14â”Š  // The \"mode\" argument specifies which math function should be invoked\n++â”Š  â”Š15â”Š  // right after the number has been trimmed.\n++â”Š  â”Š16â”Š  // e.g. 12.12345.trim(3, \"ceil\") returns 12.124\n++â”Š  â”Š17â”Š  double trim(double context, int decimals, const std::string mode) {\n++â”Š  â”Š18â”Š    double accumulator = context * std::pow(10, decimals);\n++â”Š  â”Š19â”Š\n++â”Š  â”Š20â”Š    if (mode.compare(\"ceil\") == 0)\n++â”Š  â”Š21â”Š      accumulator = std::ceil(accumulator);\n++â”Š  â”Š22â”Š    else if (mode.compare(\"floor\") == 0)\n++â”Š  â”Š23â”Š      accumulator = std::floor(accumulator);\n++â”Š  â”Š24â”Š    else\n++â”Š  â”Š25â”Š      accumulator = std::round(accumulator);\n++â”Š  â”Š26â”Š\n++â”Š  â”Š27â”Š    return accumulator / std::pow(10, decimals);\n++â”Š  â”Š28â”Š  }\n++â”Š  â”Š29â”Š\n++â”Š  â”Š30â”Š  // Tells if number is in specified range based on given precision.\n++â”Š  â”Š31â”Š  // See the \"compare\" method for more information about precision\n++â”Š  â”Š32â”Š  bool isBetween(double context, double num1, double num2, const std::string precision) {\n++â”Š  â”Š33â”Š    return compare(context, std::min(num1, num2), \">=\", precision) &&\n++â”Š  â”Š34â”Š           compare(context, std::max(num1, num2), \"<=\", precision);\n++â”Š  â”Š35â”Š  }\n++â”Š  â”Š36â”Š\n++â”Š  â”Š37â”Š  bool compare(double context, double num, const std::string precision) {\n++â”Š  â”Š38â”Š    return compare(context, num, \"==\", precision);\n++â”Š  â”Š39â”Š  }\n++â”Š  â”Š40â”Š\n++â”Š  â”Š41â”Š  // Initiates comparison operator between context number and a given number, only here\n++â”Š  â”Š42â”Š  // a precision can be specified\n++â”Š  â”Š43â”Š  bool compare(double context, double num, const std::string method, const std::string precision) {\n++â”Š  â”Š44â”Š    // Fixed precision, \"almost equal\" with a deviation of Îµ\n++â”Š  â”Š45â”Š    if (precision.compare(\"f\") == 0) {\n++â”Š  â”Š46â”Š      if (method.compare(\"<\") == 0 ||\n++â”Š  â”Š47â”Š          method.compare(\"<=\") == 0)\n++â”Š  â”Š48â”Š        return context <= num + DBL_EPSILON;\n++â”Š  â”Š49â”Š      if (method.compare(\">\") == 0 ||\n++â”Š  â”Š50â”Š          method.compare(\">=\") == 0)\n++â”Š  â”Š51â”Š        return context >= num - DBL_EPSILON;\n++â”Š  â”Š52â”Š      return std::abs(context - num) <= DBL_EPSILON;\n++â”Š  â”Š53â”Š    }\n++â”Š  â”Š54â”Š    // Pixel precision, round comparison\n++â”Š  â”Š55â”Š    else if (precision.compare(\"px\") == 0) {\n++â”Š  â”Š56â”Š      if (method.compare(\"<\") == 0 ||\n++â”Š  â”Š57â”Š          method.compare(\"<=\") == 0)\n++â”Š  â”Š58â”Š        return std::round(context) <= std::round(num);\n++â”Š  â”Š59â”Š      if (method.compare(\">\") == 0 ||\n++â”Š  â”Š60â”Š          method.compare(\">=\") == 0)\n++â”Š  â”Š61â”Š        return std::round(context) >= std::round(num);\n++â”Š  â”Š62â”Š      return std::round(context) == std::round(num);\n++â”Š  â”Š63â”Š    }\n++â”Š  â”Š64â”Š    // Exact precision\n++â”Š  â”Š65â”Š    else {\n++â”Š  â”Š66â”Š      if (method.compare(\"<\") == 0) return context < num;\n++â”Š  â”Š67â”Š      if (method.compare(\"<=\") == 0) return context <= num;\n++â”Š  â”Š68â”Š      if (method.compare(\">\") == 0) return context > num;\n++â”Š  â”Š69â”Š      if (method.compare(\">=\") == 0) return context >= num;\n++â”Š  â”Š70â”Š      return context == num;\n++â”Š  â”Š71â”Š    }\n++â”Š  â”Š72â”Š  }\n++â”Š  â”Š73â”Š}ðŸš«â†µ\n+```\n+\n+##### Added resources/cpp/src/utils.h\n+```diff\n+@@ -0,0 +1,15 @@\n++â”Š  â”Š 1â”Š#pragma once\n++â”Š  â”Š 2â”Š\n++â”Š  â”Š 3â”Š#include <string>\n++â”Š  â”Š 4â”Š\n++â”Š  â”Š 5â”Šnamespace utils {\n++â”Š  â”Š 6â”Š  double mod(double context, double num);\n++â”Š  â”Š 7â”Š\n++â”Š  â”Š 8â”Š  double trim(double context, int decimals, const std::string mode = \"round\");\n++â”Š  â”Š 9â”Š\n++â”Š  â”Š10â”Š  bool isBetween(double context, double num1, double num2, const std::string precision = \"exact\");\n++â”Š  â”Š11â”Š\n++â”Š  â”Š12â”Š  bool compare(double context, double num, const std::string precision = \"exact\");\n++â”Š  â”Š13â”Š\n++â”Š  â”Š14â”Š  bool compare(double context, double num, const std::string method, const std::string precision);\n++â”Š  â”Š15â”Š}ðŸš«â†µ\n+```\n+[}]: #\n+\n+The module above should work by itself when interacting with it inside the C++ scope, but that's not what we're striving for. We want this module to be available for use in our JavaScript project. This requires us to wrap our code in such a way the the Emscripten compiler will know how to compile it. Apart from providing a compiler, Emscripten provides us with functions and macros that will help use bind our C++ code to the JavaScript environment. These functionalities are packed in a single library which can be imported in our C++ code, and it is called [Embind](https://kripken.github.io/emscripten-site/docs/porting/connecting_cpp_and_javascript/embind.html) (probably stands for \"Emscripten bind\"). Using EMBind, let's wrap our utils module accordingly:\n+\n+[{]: <helper> (diff_step 7.3)\n+#### Step 7.3: EMBind CPP utils\n+\n+##### Changed resources/cpp/src/utils.cpp\n+```diff\n+@@ -1,6 +1,7 @@\n+ â”Š1â”Š1â”Š#include <cfloat>\n+ â”Š2â”Š2â”Š#include <cmath>\n+ â”Š3â”Š3â”Š#include <string>\n++â”Š â”Š4â”Š#include <emscripten/bind.h>\n+ â”Š4â”Š5â”Š#include \"utils.h\"\n+ â”Š5â”Š6â”Š\n+ â”Š6â”Š7â”Šnamespace utils {\n+```\n+```diff\n+@@ -70,4 +71,15 @@\n+ â”Š70â”Š71â”Š      return context == num;\n+ â”Š71â”Š72â”Š    }\n+ â”Š72â”Š73â”Š  }\n++â”Š  â”Š74â”Š}\n++â”Š  â”Š75â”Š\n++â”Š  â”Š76â”ŠEMSCRIPTEN_BINDINGS(utils_module) {\n++â”Š  â”Š77â”Š  emscripten::function(\"utils_mod\", &utils::mod);\n++â”Š  â”Š78â”Š  emscripten::function(\"utils_trim\", &utils::trim);\n++â”Š  â”Š79â”Š  emscripten::function(\"utils_isBetween\", &utils::isBetween);\n++â”Š  â”Š80â”Š  emscripten::function(\"utils_compare\",\n++â”Š  â”Š81â”Š    emscripten::select_overload<bool(double, double, const std::string, const std::string)>(\n++â”Š  â”Š82â”Š      &utils::compare\n++â”Š  â”Š83â”Š    )\n++â”Š  â”Š84â”Š  );\n+ â”Š73â”Š85â”Š}ðŸš«â†µ\n+```\n+[}]: #\n+\n+After a while you'll get used for Embind's API. If you'll look at it, it's self explanatory and easy to understand. Bound objects will be available the JavaScript environment will be available under an object named `Module`, e.g. the C++ method `mod` will be available for use as `Module.utils_mod`. Bound functions should have supported return types and argument types, meaning that if we're using a custom structure as a return type or an argument type, we first need to wrap it using EMBind, otherwise the compiler won't know how to handle it. A list of natively supported data-types can be found [here](https://kripken.github.io/emscripten-site/docs/porting/connecting_cpp_and_javascript/embind.html#built-in-type-conversions).\n+\n+Even though we've wrapped our C++ code and hypothetically it can already be used in the browser, I'd go for a second wrapper, since the compiled code doesn't have the optimal architecture. Right now we will have to approach C++ utility functions using `Module.utils_foo`. Instead, I'd like it to be `CPP.Utils.foo`, since it's clearer this way. The output of the Emscripten compiler can be wrapped with JavaScript code, using a prefix and a suffix, defined in 2 separate files respectively, called `pre.js` and `post.js`:\n+\n+[{]: <helper> (diff_step 7.4)\n+#### Step 7.4: Create CPP wrappers\n+\n+##### Added resources/cpp/post.js\n+```diff\n+@@ -0,0 +1,10 @@\n++â”Š  â”Š 1â”Šreturn {\n++â”Š  â”Š 2â”Š  Utils: {\n++â”Š  â”Š 3â”Š    mod: Module.utils_mod,\n++â”Š  â”Š 4â”Š    trim: Module.utils_trim,\n++â”Š  â”Š 5â”Š    isBetween: Module.utils_isBetween,\n++â”Š  â”Š 6â”Š    compare: Module.utils_compare\n++â”Š  â”Š 7â”Š  }\n++â”Š  â”Š 8â”Š};\n++â”Š  â”Š 9â”Š\n++â”Š  â”Š10â”Š})();ðŸš«â†µ\n+```\n+\n+##### Added resources/cpp/pre.js\n+```diff\n+@@ -0,0 +1 @@\n++â”Š â”Š1â”ŠCPP = (function() {ðŸš«â†µ\n+```\n+[}]: #\n+\n+What we've done in the code snippet above, we've created an anonymous function which calls itself, and inside we've exported a new namespace called `CPP` (C++). This way we can keep the generated code encapsulated, without worrying about spamming the global object.\n+\n+After creating a wrapper, I'd also recommend you to integrate the generated C++ code into existing namespaces, meaning that if for example we would like to approach the `CPP.Utils.foo` method, it could be done using `Utils.foo`. This way existing code won't have to be changed, and extra wrapping logic can be applied with ease, like the chaining logic implemented in the `Utils` namespace:\n+\n+[{]: <helper> (diff_step 7.5)\n+#### Step 7.5: Bind CPP utils to JS utils\n+\n+##### Changed resources/scripts/utils.js\n+```diff\n+@@ -16,53 +16,9 @@\n+ â”Š16â”Š16â”Š  return chain;\n+ â”Š17â”Š17â”Š};\n+ â”Š18â”Š18â”Š\n+-â”Š19â”Š  â”Š// Fixed modulo method which can calculate modulo of negative numbers properly\n+-â”Š20â”Š  â”Š// e.g. (-803).mod(800) returns 797\n+-â”Š21â”Š  â”ŠUtils.mod = function (context, num) {\n+-â”Š22â”Š  â”Š  return ((context % num) + num) % num;\n+-â”Š23â”Š  â”Š};\n+-â”Š24â”Š  â”Š\n+-â”Š25â”Š  â”Š// Trims number and leaves the number of decimals specified.\n+-â”Š26â”Š  â”Š// The \"mode\" argument specifies which math function should be invoked\n+-â”Š27â”Š  â”Š// right after the number has been trimmed.\n+-â”Š28â”Š  â”Š// e.g. 12.12345.trim(3, \"ceil\") returns 12.124\n+-â”Š29â”Š  â”ŠUtils.trim = function (context, decimals, mode = \"round\") {\n+-â”Š30â”Š  â”Š  return Math[mode](context * Math.pow(10, decimals)) / Math.pow(10, decimals);\n+-â”Š31â”Š  â”Š};\n+-â”Š32â”Š  â”Š\n+-â”Š33â”Š  â”Š// Tells if number is in specified range based on given precision.\n+-â”Š34â”Š  â”Š// See the \"compare\" method for more information about precision\n+-â”Š35â”Š  â”ŠUtils.isBetween = function (context, num1, num2, precision) {\n+-â”Š36â”Š  â”Š  return Utils.compare(context, Math.min(num1, num2), \">=\", precision) &&\n+-â”Š37â”Š  â”Š         Utils.compare(context, Math.max(num1, num2), \"<=\", precision);\n+-â”Š38â”Š  â”Š};\n+-â”Š39â”Š  â”Š\n+-â”Š40â”Š  â”Š// Initiates comparison operator between context number and a given number, only here\n+-â”Š41â”Š  â”Š// a precision can be specified\n+-â”Š42â”Š  â”ŠUtils.compare = function (context, num, method, precision = method) {\n+-â”Š43â”Š  â”Š  switch (precision) {\n+-â”Š44â”Š  â”Š    // Fixed precision, \"almost equal\" with a deviation of Îµ\n+-â”Š45â”Š  â”Š    case \"f\":\n+-â”Š46â”Š  â”Š      switch (method) {\n+-â”Š47â”Š  â”Š        case \"<\": case \"<=\": return context <= num + Number.EPSILON;\n+-â”Š48â”Š  â”Š        case \">\": case \">=\": return context >= num - Number.EPSILON;\n+-â”Š49â”Š  â”Š        default: return Math.abs(context - num) <= Number.EPSILON;\n+-â”Š50â”Š  â”Š      }\n+-â”Š51â”Š  â”Š    // Pixel precision, round comparison\n+-â”Š52â”Š  â”Š    case \"px\":\n+-â”Š53â”Š  â”Š      switch (method) {\n+-â”Š54â”Š  â”Š        case \"<\": case \"<=\": return Math.round(context) <= Math.round(num);\n+-â”Š55â”Š  â”Š        case \">\": case \">=\": return Math.round(context) >= Math.round(num);\n+-â”Š56â”Š  â”Š        default: return Math.round(context) == Math.round(num);\n+-â”Š57â”Š  â”Š      }\n+-â”Š58â”Š  â”Š    // Exact precision\n+-â”Š59â”Š  â”Š    default:\n+-â”Š60â”Š  â”Š      switch (method) {\n+-â”Š61â”Š  â”Š        case \"<\": return context < num;\n+-â”Š62â”Š  â”Š        case \"<=\": return context <= num;\n+-â”Š63â”Š  â”Š        case \">\": return context > num;\n+-â”Š64â”Š  â”Š        case \">=\": return context >= num;\n+-â”Š65â”Š  â”Š        default: return context === num;\n+-â”Š66â”Š  â”Š      }\n++â”Š  â”Š19â”ŠObject.assign(Utils, CPP.Utils, {\n++â”Š  â”Š20â”Š  // Overload handling\n++â”Š  â”Š21â”Š  compare(context, num, method, precision = method) {\n++â”Š  â”Š22â”Š    return CPP.Utils.compare(context, num, method, precision);\n+ â”Š67â”Š23â”Š  }\n+-â”Š68â”Š  â”Š};ðŸš«â†µ\n++â”Š  â”Š24â”Š});ðŸš«â†µ\n+```\n+[}]: #\n+\n+Whenever launching the compiler, the generated code should be outputted somewhere. I've decided to go with the path `resources/scripts/cpp.bundle.js`, but it doesn't matter how the file is gonna be called, as long as it's defined under the `scripts` dir, otherwise we won't be able to load it. Also, we need to make sure that we set a git-ignore rule for the generated file, since there's no reason for us to upload it to the git-host if we're planning on compiling it:\n+\n+[{]: <helper> (diff_step 7.5)\n+#### Step 7.5: Bind CPP utils to JS utils\n+\n+##### Changed resources/scripts/utils.js\n+```diff\n+@@ -16,53 +16,9 @@\n+ â”Š16â”Š16â”Š  return chain;\n+ â”Š17â”Š17â”Š};\n+ â”Š18â”Š18â”Š\n+-â”Š19â”Š  â”Š// Fixed modulo method which can calculate modulo of negative numbers properly\n+-â”Š20â”Š  â”Š// e.g. (-803).mod(800) returns 797\n+-â”Š21â”Š  â”ŠUtils.mod = function (context, num) {\n+-â”Š22â”Š  â”Š  return ((context % num) + num) % num;\n+-â”Š23â”Š  â”Š};\n+-â”Š24â”Š  â”Š\n+-â”Š25â”Š  â”Š// Trims number and leaves the number of decimals specified.\n+-â”Š26â”Š  â”Š// The \"mode\" argument specifies which math function should be invoked\n+-â”Š27â”Š  â”Š// right after the number has been trimmed.\n+-â”Š28â”Š  â”Š// e.g. 12.12345.trim(3, \"ceil\") returns 12.124\n+-â”Š29â”Š  â”ŠUtils.trim = function (context, decimals, mode = \"round\") {\n+-â”Š30â”Š  â”Š  return Math[mode](context * Math.pow(10, decimals)) / Math.pow(10, decimals);\n+-â”Š31â”Š  â”Š};\n+-â”Š32â”Š  â”Š\n+-â”Š33â”Š  â”Š// Tells if number is in specified range based on given precision.\n+-â”Š34â”Š  â”Š// See the \"compare\" method for more information about precision\n+-â”Š35â”Š  â”ŠUtils.isBetween = function (context, num1, num2, precision) {\n+-â”Š36â”Š  â”Š  return Utils.compare(context, Math.min(num1, num2), \">=\", precision) &&\n+-â”Š37â”Š  â”Š         Utils.compare(context, Math.max(num1, num2), \"<=\", precision);\n+-â”Š38â”Š  â”Š};\n+-â”Š39â”Š  â”Š\n+-â”Š40â”Š  â”Š// Initiates comparison operator between context number and a given number, only here\n+-â”Š41â”Š  â”Š// a precision can be specified\n+-â”Š42â”Š  â”ŠUtils.compare = function (context, num, method, precision = method) {\n+-â”Š43â”Š  â”Š  switch (precision) {\n+-â”Š44â”Š  â”Š    // Fixed precision, \"almost equal\" with a deviation of Îµ\n+-â”Š45â”Š  â”Š    case \"f\":\n+-â”Š46â”Š  â”Š      switch (method) {\n+-â”Š47â”Š  â”Š        case \"<\": case \"<=\": return context <= num + Number.EPSILON;\n+-â”Š48â”Š  â”Š        case \">\": case \">=\": return context >= num - Number.EPSILON;\n+-â”Š49â”Š  â”Š        default: return Math.abs(context - num) <= Number.EPSILON;\n+-â”Š50â”Š  â”Š      }\n+-â”Š51â”Š  â”Š    // Pixel precision, round comparison\n+-â”Š52â”Š  â”Š    case \"px\":\n+-â”Š53â”Š  â”Š      switch (method) {\n+-â”Š54â”Š  â”Š        case \"<\": case \"<=\": return Math.round(context) <= Math.round(num);\n+-â”Š55â”Š  â”Š        case \">\": case \">=\": return Math.round(context) >= Math.round(num);\n+-â”Š56â”Š  â”Š        default: return Math.round(context) == Math.round(num);\n+-â”Š57â”Š  â”Š      }\n+-â”Š58â”Š  â”Š    // Exact precision\n+-â”Š59â”Š  â”Š    default:\n+-â”Š60â”Š  â”Š      switch (method) {\n+-â”Š61â”Š  â”Š        case \"<\": return context < num;\n+-â”Š62â”Š  â”Š        case \"<=\": return context <= num;\n+-â”Š63â”Š  â”Š        case \">\": return context > num;\n+-â”Š64â”Š  â”Š        case \">=\": return context >= num;\n+-â”Š65â”Š  â”Š        default: return context === num;\n+-â”Š66â”Š  â”Š      }\n++â”Š  â”Š19â”ŠObject.assign(Utils, CPP.Utils, {\n++â”Š  â”Š20â”Š  // Overload handling\n++â”Š  â”Š21â”Š  compare(context, num, method, precision = method) {\n++â”Š  â”Š22â”Š    return CPP.Utils.compare(context, num, method, precision);\n+ â”Š67â”Š23â”Š  }\n+-â”Š68â”Š  â”Š};ðŸš«â†µ\n++â”Š  â”Š24â”Š});ðŸš«â†µ\n+```\n+[}]: #\n+\n+To compile our C++ code and turn it into JavaScript, we'll need to run the following command:\n+\n+    $ emcc -O1 --pre-js resources/cpp/pre.js --post-js resources/cpp/post.js --bind -o resources/scripts/cpp.bundle.js resources/cpp/src/index.cpp\n+\n+Here's a detailed list with explanations regards the arguments vector we've just passed:\n+\n+- `-01` - Optimization level 1. The higher the index, the more optimized our code is gonna be, but less readable.\n+- `--pre-js` - Specifies a JavaScript prefix for the compiled code.\n+- `--post-js` - Specifies a JavaScript postfix for the compiled code.\n+- `--bind` - Tells the compiler to use Embind\n+- `-o` - The output path.\n+\n+> More informations regards Emscripten's CLI can be found [here](https://kripken.github.io/emscripten-site/docs/tools_reference/emcc.html).\n+\n+You don't have to memorize the compilation command we've just typed, because we're gonna save it as an NPM script called `build:cpp`:\n+\n+[{]: <helper> (diff_step 7.6)\n+#### Step 7.6: Add ignore rule to CPP bundle\n+\n+##### Changed .gitignore\n+```diff\n+@@ -1,3 +1,4 @@\n+ â”Š1â”Š1â”Šnode_modules\n+ â”Š2â”Š2â”Šnpm-debug.log\n+-â”Š3â”Š â”Šresources/assets/fonts/*.jsonðŸš«â†µ\n++â”Š â”Š3â”Šresources/assets/fonts/*.json\n++â”Š â”Š4â”Šresources/scripts/cpp.bundle.jsðŸš«â†µ\n+```\n+[}]: #\n+\n+Now if you'd like to compile the C++ code just run:\n+\n+    $ npm run build:cpp\n+\n+Moreover, the code should be compiled automatically any time you start the serer using the command:\n+\n+    $ npm run serve\n+\n+We always have to be on the alert and run our tests against modules we've just translated from JavaScript to C++. This will guarantee that once we run the game we won't stumble upon any defect whatsoever. Before running the tests, be sure to import the C++ bundle in the HTML file's header:\n+\n+[{]: <helper> (diff_step 7.8)\n+#### Step 7.8: Load CPP bundle in spec runner\n+\n+##### Changed views/spec_runner.html\n+```diff\n+@@ -16,6 +16,7 @@\n+ â”Š16â”Š16â”Š    <script type=\"text/javascript\" src=\"libs/underscore.js\"></script>\n+ â”Š17â”Š17â”Š\n+ â”Š18â”Š18â”Š    <!-- Scripts -->\n++â”Š  â”Š19â”Š    <script type=\"text/javascript\" src=\"scripts/cpp.bundle.js\"></script>\n+ â”Š19â”Š20â”Š    <script type=\"text/javascript\" src=\"scripts/utils.js\"></script>\n+ â”Š20â”Š21â”Š    <script type=\"text/javascript\" src=\"scripts/namespaces.js\"></script>\n+ â”Š21â”Š22â”Š    <script type=\"text/javascript\" src=\"scripts/engine/geometry/line.js\"></script>\n+```\n+[}]: #\n+\n+Now we can run the tests by running the following command:\n+\n+    $ npm run test\n+\n+At this point **all our tests should pass**. If they don't, it means our newly created utility module is not working properly, and you will have to repeat the previous steps until you get it right.\n+\n+Up next, we gonna translate the geometry line class to C++. Since it's gonna be translated almost identically, we will have to make sure that all the necessary assets are gonna be available for our class before proceeding. The first thing we will have to do would be making sure that the utility functions are chainable directly from C++ as well. To do that, we will create a chain class which should return a new instance of it whenever we're about to chain the upcoming utility method. Once calling `result()`, the accumulator should be returned:\n+\n+[{]: <helper> (diff_step 7.9)\n+#### Step 7.9: Add chaining method to CPP utils\n+\n+##### Changed resources/cpp/src/utils.cpp\n+```diff\n+@@ -5,6 +5,61 @@\n+ â”Š 5â”Š 5â”Š#include \"utils.h\"\n+ â”Š 6â”Š 6â”Š\n+ â”Š 7â”Š 7â”Šnamespace utils {\n++â”Š  â”Š 8â”Š  template<typename T>\n++â”Š  â”Š 9â”Š  Chain<T>::Chain(T accumulator): _accumulator(accumulator) {\n++â”Š  â”Š10â”Š  }\n++â”Š  â”Š11â”Š\n++â”Š  â”Š12â”Š  template<>\n++â”Š  â”Š13â”Š  Chain<double>* Chain<double>::mod(double num) {\n++â”Š  â”Š14â”Š    double result = utils::mod(_accumulator, num);\n++â”Š  â”Š15â”Š    Chain<double>* chain = new Chain<double>(result);\n++â”Š  â”Š16â”Š    delete this;\n++â”Š  â”Š17â”Š    return chain;\n++â”Š  â”Š18â”Š  }\n++â”Š  â”Š19â”Š\n++â”Š  â”Š20â”Š  template<>\n++â”Š  â”Š21â”Š  Chain<double>* Chain<double>::trim(int decimals, const std::string mode) {\n++â”Š  â”Š22â”Š    double result = utils::trim(_accumulator, decimals, mode);\n++â”Š  â”Š23â”Š    Chain<double>* chain = new Chain<double>(result);\n++â”Š  â”Š24â”Š    delete this;\n++â”Š  â”Š25â”Š    return chain;\n++â”Š  â”Š26â”Š  }\n++â”Š  â”Š27â”Š\n++â”Š  â”Š28â”Š  template<>\n++â”Š  â”Š29â”Š  Chain<bool>* Chain<double>::isBetween(double num1, double num2, const std::string precision) {\n++â”Š  â”Š30â”Š    bool result = utils::isBetween(_accumulator, num1, num2, precision);\n++â”Š  â”Š31â”Š    Chain<bool>* chain = new Chain<bool>(result);\n++â”Š  â”Š32â”Š    delete this;\n++â”Š  â”Š33â”Š    return chain;\n++â”Š  â”Š34â”Š  }\n++â”Š  â”Š35â”Š\n++â”Š  â”Š36â”Š  template<>\n++â”Š  â”Š37â”Š  Chain<bool>* Chain<double>::compare(double num, const std::string precision) {\n++â”Š  â”Š38â”Š    bool result = utils::compare(_accumulator, num, precision);\n++â”Š  â”Š39â”Š    Chain<bool>* chain = new Chain<bool>(result);\n++â”Š  â”Š40â”Š    delete this;\n++â”Š  â”Š41â”Š    return chain;\n++â”Š  â”Š42â”Š  }\n++â”Š  â”Š43â”Š\n++â”Š  â”Š44â”Š  template<>\n++â”Š  â”Š45â”Š  Chain<bool>* Chain<double>::compare(double num, const std::string method, const std::string precision) {\n++â”Š  â”Š46â”Š    bool result = utils::compare(_accumulator, num, method, precision);\n++â”Š  â”Š47â”Š    Chain<bool>* chain = new Chain<bool>(result);\n++â”Š  â”Š48â”Š    delete this;\n++â”Š  â”Š49â”Š    return chain;\n++â”Š  â”Š50â”Š  }\n++â”Š  â”Š51â”Š\n++â”Š  â”Š52â”Š  template<typename T>\n++â”Š  â”Š53â”Š  T Chain<T>::result() {\n++â”Š  â”Š54â”Š    delete this;\n++â”Š  â”Š55â”Š    return _accumulator;\n++â”Š  â”Š56â”Š  }\n++â”Š  â”Š57â”Š\n++â”Š  â”Š58â”Š  template<typename T>\n++â”Š  â”Š59â”Š  Chain<T>* chain(T accumulator) {\n++â”Š  â”Š60â”Š    return new Chain<T>(accumulator);\n++â”Š  â”Š61â”Š  }\n++â”Š  â”Š62â”Š\n+ â”Š 8â”Š63â”Š  // Fixed modulo method which can calculate modulo of negative numbers properly\n+ â”Š 9â”Š64â”Š  // e.g. (-803).mod(800) returns 797\n+ â”Š10â”Š65â”Š  double mod(double context, double num) {\n+```\n+\n+##### Changed resources/cpp/src/utils.h\n+```diff\n+@@ -3,6 +3,30 @@\n+ â”Š 3â”Š 3â”Š#include <string>\n+ â”Š 4â”Š 4â”Š\n+ â”Š 5â”Š 5â”Šnamespace utils {\n++â”Š  â”Š 6â”Š  template<typename T>\n++â”Š  â”Š 7â”Š  class Chain {\n++â”Š  â”Š 8â”Š  private:\n++â”Š  â”Š 9â”Š    T _accumulator;\n++â”Š  â”Š10â”Š\n++â”Š  â”Š11â”Š  public:\n++â”Š  â”Š12â”Š    Chain(T accumulator);\n++â”Š  â”Š13â”Š\n++â”Š  â”Š14â”Š    Chain<double>* mod(double num);\n++â”Š  â”Š15â”Š\n++â”Š  â”Š16â”Š    Chain<double>* trim(int decimals, const std::string mode = \"round\");\n++â”Š  â”Š17â”Š\n++â”Š  â”Š18â”Š    Chain<bool>* isBetween(double num1, double num2, const std::string precision = \"exact\");\n++â”Š  â”Š19â”Š\n++â”Š  â”Š20â”Š    Chain<bool>* compare(double num, const std::string precision = \"exact\");\n++â”Š  â”Š21â”Š\n++â”Š  â”Š22â”Š    Chain<bool>* compare(double num, const std::string method, const std::string precision);\n++â”Š  â”Š23â”Š\n++â”Š  â”Š24â”Š    T result();\n++â”Š  â”Š25â”Š  };\n++â”Š  â”Š26â”Š\n++â”Š  â”Š27â”Š  template<typename T>\n++â”Š  â”Š28â”Š  Chain<T>* chain(T accumulator);\n++â”Š  â”Š29â”Š\n+ â”Š 6â”Š30â”Š  double mod(double context, double num);\n+ â”Š 7â”Š31â”Š\n+ â”Š 8â”Š32â”Š  double trim(double context, int decimals, const std::string mode = \"round\");\n+```\n+[}]: #\n+\n+> Note that when coding in C++ we have to make sure that the objects are being disposed when not needed anymore, otherwise we will have some unnecessary memory leaks.\n+\n+2D shapes are presented in space using points with 2 values - `x` (axis) and `y` axis, therefore, we will create the appropriate point structure:\n+\n+[{]: <helper> (diff_step 7.10)\n+#### Step 7.10: Add point struct\n+\n+##### Added resources/cpp/src/geometry/point.h\n+```diff\n+@@ -0,0 +1,8 @@\n++â”Š â”Š1â”Š#pragma once\n++â”Š â”Š2â”Š\n++â”Š â”Š3â”Šnamespace geometry {\n++â”Š â”Š4â”Š  struct Point {\n++â”Š â”Š5â”Š    double x;\n++â”Š â”Š6â”Š    double y;\n++â”Š â”Š7â”Š  };\n++â”Š â”Š8â”Š}ðŸš«â†µ\n+```\n+[}]: #\n+\n+Returned values can either be `null` (`undefined`) or not. Since there's no built in nullable-values mechanism in C++ (up until C++17), we're gonna create one of our own:\n+\n+[{]: <helper> (diff_step 7.11)\n+#### Step 7.11: Add nullable class\n+\n+##### Changed resources/cpp/src/index.cpp\n+```diff\n+@@ -1 +1,2 @@\n++â”Š â”Š1â”Š#include \"nullable.cpp\"\n+ â”Š1â”Š2â”Š#include \"utils.cpp\"ðŸš«â†µ\n+```\n+\n+##### Added resources/cpp/src/nullable.cpp\n+```diff\n+@@ -0,0 +1,37 @@\n++â”Š  â”Š 1â”Š#include \"nullable.h\"\n++â”Š  â”Š 2â”Š\n++â”Š  â”Š 3â”Štemplate <typename T>\n++â”Š  â”Š 4â”ŠNullable<T>::Nullable(T value): _value(value), _initialized(true) {\n++â”Š  â”Š 5â”Š\n++â”Š  â”Š 6â”Š}\n++â”Š  â”Š 7â”Š\n++â”Š  â”Š 8â”Štemplate <typename T>\n++â”Š  â”Š 9â”ŠNullable<T>::Nullable(): _initialized(false) {\n++â”Š  â”Š10â”Š\n++â”Š  â”Š11â”Š}\n++â”Š  â”Š12â”Š\n++â”Š  â”Š13â”Štemplate <typename T>\n++â”Š  â”Š14â”ŠT Nullable<T>::getValue() const {\n++â”Š  â”Š15â”Š  return _value;\n++â”Š  â”Š16â”Š}\n++â”Š  â”Š17â”Š\n++â”Š  â”Š18â”Štemplate <typename T>\n++â”Š  â”Š19â”Švoid Nullable<T>::setValue(T value) {\n++â”Š  â”Š20â”Š  _value = value;\n++â”Š  â”Š21â”Š  _initialized = true;\n++â”Š  â”Š22â”Š}\n++â”Š  â”Š23â”Š\n++â”Š  â”Š24â”Štemplate <typename T>\n++â”Š  â”Š25â”Švoid Nullable<T>::resetValue() {\n++â”Š  â”Š26â”Š  _initialized = false;\n++â”Š  â”Š27â”Š}\n++â”Š  â”Š28â”Š\n++â”Š  â”Š29â”Štemplate <typename T>\n++â”Š  â”Š30â”Šbool Nullable<T>::hasValue() const {\n++â”Š  â”Š31â”Š  return _initialized == true;\n++â”Š  â”Š32â”Š}\n++â”Š  â”Š33â”Š\n++â”Š  â”Š34â”Štemplate <typename T>\n++â”Š  â”Š35â”Šbool Nullable<T>::isNull() const {\n++â”Š  â”Š36â”Š  return _initialized == false;\n++â”Š  â”Š37â”Š}ðŸš«â†µ\n+```\n+\n+##### Added resources/cpp/src/nullable.h\n+```diff\n+@@ -0,0 +1,23 @@\n++â”Š  â”Š 1â”Š#pragma once\n++â”Š  â”Š 2â”Š\n++â”Š  â”Š 3â”Štemplate <typename T>\n++â”Š  â”Š 4â”Šclass Nullable {\n++â”Š  â”Š 5â”Šprivate:\n++â”Š  â”Š 6â”Š  T _value;\n++â”Š  â”Š 7â”Š  bool _initialized;\n++â”Š  â”Š 8â”Š\n++â”Š  â”Š 9â”Špublic:\n++â”Š  â”Š10â”Š  Nullable(T value);\n++â”Š  â”Š11â”Š\n++â”Š  â”Š12â”Š  Nullable();\n++â”Š  â”Š13â”Š\n++â”Š  â”Š14â”Š  T getValue() const;\n++â”Š  â”Š15â”Š\n++â”Š  â”Š16â”Š  void setValue(T value);\n++â”Š  â”Š17â”Š\n++â”Š  â”Š18â”Š  void resetValue();\n++â”Š  â”Š19â”Š\n++â”Š  â”Š20â”Š  bool hasValue() const;\n++â”Š  â”Š21â”Š\n++â”Š  â”Š22â”Š  bool isNull() const;\n++â”Š  â”Š23â”Š};ðŸš«â†µ\n+```\n+[}]: #\n+\n+Now that all the necessary assets for the line class are ready, we can go ahead and create it:\n+\n+[{]: <helper> (diff_step 7.12)\n+#### Step 7.12: Add base line CPP module\n+\n+##### Added resources/cpp/src/geometry/line.cpp\n+```diff\n+@@ -0,0 +1,99 @@\n++â”Š  â”Š 1â”Š#include \"../nullable.h\"\n++â”Š  â”Š 2â”Š#include \"../utils.h\"\n++â”Š  â”Š 3â”Š#include \"point.h\"\n++â”Š  â”Š 4â”Š#include \"line.h\"\n++â”Š  â”Š 5â”Š\n++â”Š  â”Š 6â”Šnamespace geometry {\n++â”Š  â”Š 7â”Š  // x1 - The first point's x value\n++â”Š  â”Š 8â”Š  // y1 - The first point's y value\n++â”Š  â”Š 9â”Š  // x1 - The second point's x value\n++â”Š  â”Š10â”Š  // y2 - The second point's y value\n++â”Š  â”Š11â”Š  Line::Line(double x1, double y1, double x2, double y2) {\n++â”Š  â”Š12â”Š    _x1 = utils::trim(x1, 9);\n++â”Š  â”Š13â”Š    _y1 = utils::trim(y1, 9);\n++â”Š  â”Š14â”Š    _x2 = utils::trim(x2, 9);\n++â”Š  â”Š15â”Š    _y2 = utils::trim(y2, 9);\n++â”Š  â”Š16â”Š  }\n++â”Š  â”Š17â”Š\n++â”Š  â”Š18â”Š  // Gets the matching x value for a given y value\n++â”Š  â”Š19â”Š  Nullable<double> Line::getMatchingX(double y) {\n++â”Š  â”Š20â”Š    // If an error was thrown it means we divided a number by zero,\n++â”Š  â”Š21â”Š    // in which case there is not intersection point\n++â”Š  â”Š22â”Š    double x = utils::trim(\n++â”Š  â”Š23â”Š      (((y - _y1) * (_x2 - _x1)) /\n++â”Š  â”Š24â”Š       (_y2 - _y1)) + _x1\n++â”Š  â”Š25â”Š    , 9, \"exact\");\n++â”Š  â”Š26â”Š\n++â”Š  â”Š27â”Š    // Check if result is in values range\n++â”Š  â”Š28â”Š    if (utils::isBetween(x, _x1, _x2, \"round\")) {\n++â”Š  â”Š29â”Š      return Nullable<double>(x);\n++â”Š  â”Š30â”Š    }\n++â”Š  â”Š31â”Š\n++â”Š  â”Š32â”Š    return Nullable<double>();\n++â”Š  â”Š33â”Š  }\n++â”Š  â”Š34â”Š\n++â”Š  â”Š35â”Š  // Gets the matching y value for a given x value\n++â”Š  â”Š36â”Š  Nullable<double> Line::getMatchingY(double x) {\n++â”Š  â”Š37â”Š    // If an error was thrown it means we divided a number by zero,\n++â”Š  â”Š38â”Š    // in which case there is not intersection point\n++â”Š  â”Š39â”Š    double y = utils::trim(\n++â”Š  â”Š40â”Š      (((x - _x1) * (_y2 - _y1)) /\n++â”Š  â”Š41â”Š       (_x2 - _x1)) + _y1\n++â”Š  â”Š42â”Š    , 9, \"exact\");\n++â”Š  â”Š43â”Š\n++â”Š  â”Š44â”Š    // Check if result is in values range\n++â”Š  â”Š45â”Š    if (utils::isBetween(y, _y1, _y2, \"round\")) {\n++â”Š  â”Š46â”Š      return Nullable<double>(y);\n++â”Š  â”Š47â”Š    }\n++â”Š  â”Š48â”Š\n++â”Š  â”Š49â”Š    return Nullable<double>();\n++â”Š  â”Š50â”Š  }\n++â”Š  â”Š51â”Š\n++â”Š  â”Š52â”Š  // Returns if line has given point\n++â”Š  â”Š53â”Š  bool Line::hasPoint(double x, double y) {\n++â”Š  â”Š54â”Š    if (!boundsHavePoint(x, y)) return 0;\n++â”Š  â”Š55â”Š\n++â”Š  â”Š56â”Š    double m = utils::trim(\n++â”Š  â”Š57â”Š      (_y2 - _y1) / (_x2 - _x1),\n++â”Š  â”Š58â”Š    9, \"exact\");\n++â”Š  â”Š59â”Š\n++â”Š  â”Š60â”Š    return (y - _y1) / (x - _x1) == m;\n++â”Š  â”Š61â”Š  }\n++â”Š  â”Š62â”Š\n++â”Š  â”Š63â”Š  // Returns if given point is contained by the bounds aka cage of line\n++â”Š  â”Š64â”Š  bool Line::boundsHavePoint(double x, double y) {\n++â”Š  â”Š65â”Š    return utils::isBetween(x, _x1, _x2, \"round\") &&\n++â”Š  â”Š66â”Š           utils::isBetween(y, _y1, _y2, \"round\");\n++â”Š  â”Š67â”Š  }\n++â”Š  â”Š68â”Š\n++â”Š  â”Š69â”Š  // line - line intersection method\n++â”Š  â”Š70â”Š  Nullable<Point> Line::getIntersection(Line line) {\n++â”Š  â”Š71â”Š    // Escape if lines are parallel\n++â”Š  â”Š72â”Š    if (!(((_x1 - _x2) * (line._y1 - line._y2)) -\n++â”Š  â”Š73â”Š          ((_y1 - _y2) * (line._x1 - line._x2))))\n++â”Š  â”Š74â”Š      return Nullable<Point>();\n++â”Š  â”Š75â”Š\n++â”Š  â”Š76â”Š    // Intersection point formula\n++â”Š  â”Š77â”Š    double x = utils::trim(\n++â”Š  â”Š78â”Š      ((((_x1 * _y2) - (_y1 * _x2)) * (line._x1 - line._x2)) -\n++â”Š  â”Š79â”Š       ((_x1 - _x2) * ((line._x1 * line._y2) - (line._y1 * line._x2)))) /\n++â”Š  â”Š80â”Š      (((_x1 - _x2) * (line._y1 - line._y2)) - ((_y1 - _y2) *\n++â”Š  â”Š81â”Š        (line._x1 - line._x2)))\n++â”Š  â”Š82â”Š    , 9, \"exact\");\n++â”Š  â”Š83â”Š    double y = utils::trim(\n++â”Š  â”Š84â”Š      ((((_x1 * _y2) - (_y1 * _x2)) * (line._y1 - line._y2)) -\n++â”Š  â”Š85â”Š       ((_y1 - _y2) * ((line._x1 * line._y2) - (line._y1 * line._x2)))) /\n++â”Š  â”Š86â”Š      (((_x1 - _x2) * (line._y1 - line._y2)) - ((_y1 - _y2) *\n++â”Š  â”Š87â”Š        (line._x1 - line._x2)))\n++â”Š  â”Š88â”Š    , 9, \"exact\");\n++â”Š  â”Š89â”Š\n++â”Š  â”Š90â”Š    if (utils::isBetween(x, _x1, _x2, \"round\") &&\n++â”Š  â”Š91â”Š        utils::isBetween(x, line._x1, line._x2, \"round\") &&\n++â”Š  â”Š92â”Š        utils::isBetween(y, _y1, _y2, \"round\") &&\n++â”Š  â”Š93â”Š        utils::isBetween(y, line._y1, line._y2, \"round\")) {\n++â”Š  â”Š94â”Š      return Nullable<Point>({ x, y });\n++â”Š  â”Š95â”Š    }\n++â”Š  â”Š96â”Š\n++â”Š  â”Š97â”Š    return Nullable<Point>();\n++â”Š  â”Š98â”Š  }\n++â”Š  â”Š99â”Š}ðŸš«â†µ\n+```\n+\n+##### Added resources/cpp/src/geometry/line.h\n+```diff\n+@@ -0,0 +1,30 @@\n++â”Š  â”Š 1â”Š#pragma once\n++â”Š  â”Š 2â”Š\n++â”Š  â”Š 3â”Š#include <vector>\n++â”Š  â”Š 4â”Š#include \"../nullable.h\"\n++â”Š  â”Š 5â”Š#include \"point.h\"\n++â”Š  â”Š 6â”Š\n++â”Š  â”Š 7â”Šnamespace geometry {\n++â”Š  â”Š 8â”Š  class Circle;\n++â”Š  â”Š 9â”Š  class EMCircle;\n++â”Š  â”Š10â”Š\n++â”Š  â”Š11â”Š  class Line {\n++â”Š  â”Š12â”Š  public:\n++â”Š  â”Š13â”Š    double _x1;\n++â”Š  â”Š14â”Š    double _y1;\n++â”Š  â”Š15â”Š    double _x2;\n++â”Š  â”Š16â”Š    double _y2;\n++â”Š  â”Š17â”Š\n++â”Š  â”Š18â”Š    Line(double x1, double y1, double x2, double y2);\n++â”Š  â”Š19â”Š\n++â”Š  â”Š20â”Š    Nullable<double> getMatchingX(double y);\n++â”Š  â”Š21â”Š\n++â”Š  â”Š22â”Š    Nullable<double> getMatchingY(double x);\n++â”Š  â”Š23â”Š\n++â”Š  â”Š24â”Š    bool hasPoint(double x, double y);\n++â”Š  â”Š25â”Š\n++â”Š  â”Š26â”Š    bool boundsHavePoint(double x, double y);\n++â”Š  â”Š27â”Š\n++â”Š  â”Š28â”Š    Nullable<Point> getIntersection(Line line);\n++â”Š  â”Š29â”Š  };\n++â”Š  â”Š30â”Š}ðŸš«â†µ\n+```\n+\n+##### Changed resources/cpp/src/index.cpp\n+```diff\n+@@ -1,2 +1,3 @@\n+ â”Š1â”Š1â”Š#include \"nullable.cpp\"\n+-â”Š2â”Š â”Š#include \"utils.cpp\"ðŸš«â†µ\n++â”Š â”Š2â”Š#include \"utils.cpp\"\n++â”Š â”Š3â”Š#include \"geometry/line.cpp\"ðŸš«â†µ\n+```\n+[}]: #\n+\n+After creating our C++, we will also need to bind it using EMBind:\n+\n+[{]: <helper> (diff_step 7.13)\n+#### Step 7.13: EMBind CPP line\n+\n+##### Changed resources/cpp/post.js\n+```diff\n+@@ -4,6 +4,10 @@\n+ â”Š 4â”Š 4â”Š    trim: Module.utils_trim,\n+ â”Š 5â”Š 5â”Š    isBetween: Module.utils_isBetween,\n+ â”Š 6â”Š 6â”Š    compare: Module.utils_compare\n++â”Š  â”Š 7â”Š  },\n++â”Š  â”Š 8â”Š\n++â”Š  â”Š 9â”Š  Geometry: {\n++â”Š  â”Š10â”Š    Line: Module.geometry_line\n+ â”Š 7â”Š11â”Š  }\n+ â”Š 8â”Š12â”Š};\n+ â”Š 9â”Š13â”Š\n+```\n+\n+##### Changed resources/cpp/src/geometry/line.cpp\n+```diff\n+@@ -1,3 +1,6 @@\n++â”Š â”Š1â”Š#include <vector>\n++â”Š â”Š2â”Š#include <emscripten/bind.h>\n++â”Š â”Š3â”Š#include <emscripten/val.h>\n+ â”Š1â”Š4â”Š#include \"../nullable.h\"\n+ â”Š2â”Š5â”Š#include \"../utils.h\"\n+ â”Š3â”Š6â”Š#include \"point.h\"\n+```\n+```diff\n+@@ -96,4 +99,52 @@\n+ â”Š 96â”Š 99â”Š\n+ â”Š 97â”Š100â”Š    return Nullable<Point>();\n+ â”Š 98â”Š101â”Š  }\n++â”Š   â”Š102â”Š\n++â”Š   â”Š103â”Š  emscripten::val EMLine::getMatchingX(double y) {\n++â”Š   â”Š104â”Š    Nullable<double> nullableX = Line::getMatchingX(y);\n++â”Š   â”Š105â”Š    return nullableX.hasValue() ?\n++â”Š   â”Š106â”Š      emscripten::val(nullableX.getValue()) :\n++â”Š   â”Š107â”Š      emscripten::val::undefined();\n++â”Š   â”Š108â”Š  }\n++â”Š   â”Š109â”Š\n++â”Š   â”Š110â”Š  emscripten::val EMLine::getMatchingY(double x) {\n++â”Š   â”Š111â”Š    Nullable<double> nullableY = Line::getMatchingY(x);\n++â”Š   â”Š112â”Š    return nullableY.hasValue() ?\n++â”Š   â”Š113â”Š      emscripten::val(nullableY.getValue()) :\n++â”Š   â”Š114â”Š      emscripten::val::undefined();\n++â”Š   â”Š115â”Š  }\n++â”Š   â”Š116â”Š\n++â”Š   â”Š117â”Š  emscripten::val EMLine::getIntersection(EMLine emLine) {\n++â”Š   â”Š118â”Š    Line line = Line(emLine._x1, emLine._y1, emLine._x2, emLine._y2);\n++â”Š   â”Š119â”Š    Nullable<Point> nullablePoint = Line::getIntersection(line);\n++â”Š   â”Š120â”Š\n++â”Š   â”Š121â”Š    if (nullablePoint.isNull()) return emscripten::val::undefined();\n++â”Š   â”Š122â”Š\n++â”Š   â”Š123â”Š    Point point = nullablePoint.getValue();\n++â”Š   â”Š124â”Š    emscripten::val emPoint = emscripten::val::object();\n++â”Š   â”Š125â”Š    emPoint.set(\"x\", emscripten::val(point.x));\n++â”Š   â”Š126â”Š    emPoint.set(\"y\", emscripten::val(point.y));\n++â”Š   â”Š127â”Š    return emPoint;\n++â”Š   â”Š128â”Š  }\n++â”Š   â”Š129â”Š}\n++â”Š   â”Š130â”Š\n++â”Š   â”Š131â”ŠEMSCRIPTEN_BINDINGS(geometry_line_module) {\n++â”Š   â”Š132â”Š  emscripten::class_<geometry::Line>(\"geometry_line_base\")\n++â”Š   â”Š133â”Š    .constructor<double, double, double, double>()\n++â”Š   â”Š134â”Š    .property<double>(\"x1\", &geometry::Line::_x1)\n++â”Š   â”Š135â”Š    .property<double>(\"y1\", &geometry::Line::_y1)\n++â”Š   â”Š136â”Š    .property<double>(\"x2\", &geometry::Line::_x2)\n++â”Š   â”Š137â”Š    .property<double>(\"y2\", &geometry::Line::_y2)\n++â”Š   â”Š138â”Š    .function(\"hasPoint\", &geometry::Line::hasPoint)\n++â”Š   â”Š139â”Š    .function(\"boundsHavePoint\", &geometry::Line::boundsHavePoint);\n++â”Š   â”Š140â”Š\n++â”Š   â”Š141â”Š  emscripten::class_<geometry::EMLine, emscripten::base<geometry::Line>>(\"geometry_line\")\n++â”Š   â”Š142â”Š    .constructor<double, double, double, double>()\n++â”Š   â”Š143â”Š    .function(\"getX\", &geometry::EMLine::getMatchingX)\n++â”Š   â”Š144â”Š    .function(\"getY\", &geometry::EMLine::getMatchingY)\n++â”Š   â”Š145â”Š    .function(\"getLineIntersection\",\n++â”Š   â”Š146â”Š      emscripten::select_overload<emscripten::val(geometry::EMLine)>(\n++â”Š   â”Š147â”Š        &geometry::EMLine::getIntersection\n++â”Š   â”Š148â”Š      )\n++â”Š   â”Š149â”Š    );\n+ â”Š 99â”Š150â”Š}ðŸš«â†µ\n+```\n+\n+##### Changed resources/cpp/src/geometry/line.h\n+```diff\n+@@ -1,6 +1,7 @@\n+ â”Š1â”Š1â”Š#pragma once\n+ â”Š2â”Š2â”Š\n+ â”Š3â”Š3â”Š#include <vector>\n++â”Š â”Š4â”Š#include <emscripten/val.h>\n+ â”Š4â”Š5â”Š#include \"../nullable.h\"\n+ â”Š5â”Š6â”Š#include \"point.h\"\n+ â”Š6â”Š7â”Š\n+```\n+```diff\n+@@ -27,4 +28,15 @@\n+ â”Š27â”Š28â”Š\n+ â”Š28â”Š29â”Š    Nullable<Point> getIntersection(Line line);\n+ â”Š29â”Š30â”Š  };\n++â”Š  â”Š31â”Š\n++â”Š  â”Š32â”Š  class EMLine : public Line {\n++â”Š  â”Š33â”Š  public:\n++â”Š  â”Š34â”Š    using Line::Line;\n++â”Š  â”Š35â”Š\n++â”Š  â”Š36â”Š    emscripten::val getMatchingX(double y);\n++â”Š  â”Š37â”Š\n++â”Š  â”Š38â”Š    emscripten::val getMatchingY(double x);\n++â”Š  â”Š39â”Š\n++â”Š  â”Š40â”Š    emscripten::val getIntersection(EMLine line);\n++â”Š  â”Š41â”Š  };\n+ â”Š30â”Š42â”Š}ðŸš«â†µ\n+```\n+[}]: #\n+\n+In the code snippet above, you can see that we used a special data-type called `val` (`emscripten::val`). `val` means that just like JavaScript, that function can return values that are not necessarily of the same data-type; For instance, the `getMatchingY` function can either return a `number` or `undefined`. If you'll take a look at the `getIntersection(Line)` method you'll notice that instead of returning the raw point structure, I chose to build a JavaScript object using the `object` data type (`emscripten::object`). `object` behaves exactly like a native JavaScript `Object`, and it can save us some precious work of binding which sometimes might be just too much.\n+\n+If you'll compare the C++ version of the line class to the JavaScript line class you'll notice that the `draw` and `getIntersection` methods are missing (when we used EMBind we renamed `getIntersection` to `getLineIntersection` because overloadings are forbidden). In addition, Emscripten's API exposes some additional class methods for generated C++ classes, like the `delete` method, which we will shed light on further in this tutorial. Inheritance would be the natural solution for such an issue, unfortunately, generated C++ constructors don't accept indirect instances. For example, if we have a C++ parent class called `Shape` and we have a JavaScript child class called `Line`, we won't be able to initialize a new instance of the `Line` class. Here's a demonstration:\n+\n+```js\n+class JSLine extends CPPShape {}\n+const line = new JSLine(); // Throws error\n+```\n+\n+There are 3 ways to implement inheritance when interacting with C++ classes:\n+\n+- Define an interface when using EMBind. This is the official way but rather complicated, since it requires us to define an extra layer for our wrapper. More information can be found [here](https://kripken.github.io/emscripten-site/docs/porting/connecting_cpp_and_javascript/embind.html#abstract-methods).\n+- Extending the prototype of exported C++ classes directly, which is not really an inheritance.\n+- Using a proxy class, which is the easiest and cleanest solution of all, but it is not really mentioned anywhere. At the same time, I didn't find any restriction regards that.\n+\n+We're gonna use the 3rd method in the list above, because as I said, it's the easiest and cleanest of all. First I will try to explain what I meant by saying \"proxy class\". If you're an intermediate JavaScript developer, you probably know that constructors can be overridden by returning a value explicitly. By doing that, we can actually bypass Emscripten's prohibitions, we can just return the newly created C++ instance and extend it in specific. Proxy classes actually take it a step further by providing a middle-class which will then inject a new link to the prototype chain of the returned instance.\n+\n+```js\n+class JSLine {\n+  constructor() {\n+    const line = new CPPShape();\n+    return line;\n+  }\n+}\n+\n+const line = new JSLine(); // Legal!\n+```\n+\n+> More information about the code snippet above can be found [here](https://www.bennadel.com/blog/2522-providing-a-return-value-in-a-javascript-constructor.htm).\n+\n+I believe that as we go through this tutorial, the concept will get much clearer. The utility function of the proxy class should look like so:\n+\n+[{]: <helper> (diff_step 7.14)\n+#### Step 7.14: Add proxy utility method\n+\n+##### Changed resources/scripts/utils.js\n+```diff\n+@@ -20,5 +20,18 @@\n+ â”Š20â”Š20â”Š  // Overload handling\n+ â”Š21â”Š21â”Š  compare(context, num, method, precision = method) {\n+ â”Š22â”Š22â”Š    return CPP.Utils.compare(context, num, method, precision);\n++â”Š  â”Š23â”Š  },\n++â”Š  â”Š24â”Š\n++â”Š  â”Š25â”Š  proxy(Class) {\n++â”Š  â”Š26â”Š    return class extends Class {\n++â”Š  â”Š27â”Š      constructor() {\n++â”Š  â”Š28â”Š        // Initialize original class\n++â”Š  â”Š29â”Š        let that = new Class(...arguments);\n++â”Š  â”Š30â”Š        // Inject caller's prototype into the prototype chain\n++â”Š  â”Š31â”Š        Object.setPrototypeOf(that, new.target.prototype);\n++â”Š  â”Š32â”Š        // Will original instance will be the substitute for 'this'\n++â”Š  â”Š33â”Š        return that;\n++â”Š  â”Š34â”Š      }\n++â”Š  â”Š35â”Š    }\n+ â”Š23â”Š36â”Š  }\n+ â”Š24â”Š37â”Š});ðŸš«â†µ\n+```\n+[}]: #\n+\n+If you'll take a look at the following line:\n+\n+```js\n+Object.setPrototypeOf(that, new.target.prototype);\n+```\n+\n+This is where the magic actually happens! It enables inheritance for explicitly returned objects; This way we can safely extend C++ classes. Accordingly, our new JavaScript line class should look like so:\n+\n+[{]: <helper> (diff_step 7.15)\n+#### Step 7.15: Extend CPP line class\n+\n+##### Changed resources/scripts/engine/geometry/line.js\n+```diff\n+@@ -1,46 +1,10 @@\n+-â”Š 1â”Š  â”ŠEngine.Geometry.Line = class Line {\n+-â”Š 2â”Š  â”Š  // x1 - The first point's x value\n+-â”Š 3â”Š  â”Š  // y1 - The first point's y value\n+-â”Š 4â”Š  â”Š  // x1 - The second point's x value\n+-â”Š 5â”Š  â”Š  // y2 - The second point's y value\n+-â”Š 6â”Š  â”Š  constructor(x1, y1, x2, y2) {\n+-â”Š 7â”Š  â”Š    this.x1 = Utils.trim(x1, 9);\n+-â”Š 8â”Š  â”Š    this.y1 = Utils.trim(y1, 9);\n+-â”Š 9â”Š  â”Š    this.x2 = Utils.trim(x2, 9);\n+-â”Š10â”Š  â”Š    this.y2 = Utils.trim(y2, 9);\n+-â”Š11â”Š  â”Š  }\n+-â”Š12â”Š  â”Š\n++â”Š  â”Š 1â”ŠEngine.Geometry.Line = class Line extends Utils.proxy(CPP.Geometry.Line) {\n+ â”Š13â”Š 2â”Š  // Draws the line on the given context\n+ â”Š14â”Š 3â”Š  draw(context) {\n+ â”Š15â”Š 4â”Š    context.moveTo(this.x1, this.y1);\n+ â”Š16â”Š 5â”Š    context.lineTo(this.x2, this.y2);\n+ â”Š17â”Š 6â”Š  }\n+ â”Š18â”Š 7â”Š\n+-â”Š19â”Š  â”Š  // Gets the matching x value for a given y value\n+-â”Š20â”Š  â”Š  getX(y) {\n+-â”Š21â”Š  â”Š    let x = Utils.trim((((y - this.y1) * (this.x2 - this.x1)) / (this.y2 - this.y1)) + this.x1, 9);\n+-â”Š22â”Š  â”Š    if (isNaN(x) || Utils.isBetween(x, this.x1, this.x2)) return x;\n+-â”Š23â”Š  â”Š  }\n+-â”Š24â”Š  â”Š\n+-â”Š25â”Š  â”Š  // Gets the matching y value for a given x value\n+-â”Š26â”Š  â”Š  getY(x) {\n+-â”Š27â”Š  â”Š    let y = Utils.trim((((x - this.x1) * (this.y2 - this.y1)) / (this.x2 - this.x1)) + this.y1, 9);\n+-â”Š28â”Š  â”Š    if (isNaN(y) || Utils.isBetween(y, this.y1, this.y2)) return y;\n+-â”Š29â”Š  â”Š  }\n+-â”Š30â”Š  â”Š\n+-â”Š31â”Š  â”Š  // Returns if line has given point\n+-â”Š32â”Š  â”Š  hasPoint(x, y) {\n+-â”Š33â”Š  â”Š    if (!this.boundsHavePoint(x, y)) return false;\n+-â”Š34â”Š  â”Š    let m = Utils.trim((this.y2 - this.y1) / (this.x2 - this.x1), 9);\n+-â”Š35â”Š  â”Š    return (y - this.y1) / (x - this.x1) == m;\n+-â”Š36â”Š  â”Š  }\n+-â”Š37â”Š  â”Š\n+-â”Š38â”Š  â”Š  // Returns if given point is contained by the bounds aka cage of line\n+-â”Š39â”Š  â”Š  boundsHavePoint(x, y) {\n+-â”Š40â”Š  â”Š    return Utils.isBetween(x, this.x1, this.x2) &&\n+-â”Š41â”Š  â”Š           Utils.isBetween(y, this.y1, this.y2);\n+-â”Š42â”Š  â”Š  }\n+-â”Š43â”Š  â”Š\n+ â”Š44â”Š 8â”Š  getIntersection(shape) {\n+ â”Š45â”Š 9â”Š    if (shape instanceof Engine.Geometry.Line)\n+ â”Š46â”Š10â”Š      return this.getLineIntersection(shape);\n+```\n+```diff\n+@@ -50,23 +14,6 @@\n+ â”Š50â”Š14â”Š      return this.getPolygonIntersection(shape);\n+ â”Š51â”Š15â”Š  }\n+ â”Š52â”Š16â”Š\n+-â”Š53â”Š  â”Š  // line - line intersection method\n+-â”Š54â”Š  â”Š  getLineIntersection(line) {\n+-â”Š55â”Š  â”Š    // Escape if lines are parallel\n+-â”Š56â”Š  â”Š    if (!(((this.x1 - this.x2) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * (line.x1 - line.x2)))) return;\n+-â”Š57â”Š  â”Š\n+-â”Š58â”Š  â”Š    // Intersection point formula\n+-â”Š59â”Š  â”Š    let x = Utils.trim(((((this.x1 * this.y2) - (this.y1 * this.x2)) * (line.x1 - line.x2)) - ((this.x1 - this.x2) * ((line.x1 * line.y2) - (line.y1 * line.x2)))) /\n+-â”Š60â”Š  â”Š        (((this.x1 - this.x2) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * (line.x1 - line.x2))), 9);\n+-â”Š61â”Š  â”Š    let y = Utils.trim(((((this.x1 * this.y2) - (this.y1 * this.x2)) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * ((line.x1 * line.y2) - (line.y1 * line.x2)))) /\n+-â”Š62â”Š  â”Š        (((this.x1 - this.x2) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * (line.x1 - line.x2))), 9);\n+-â”Š63â”Š  â”Š\n+-â”Š64â”Š  â”Š    if (Utils.isBetween(x, this.x1, this.x2) && Utils.isBetween(x, line.x1, line.x2) &&\n+-â”Š65â”Š  â”Š        Utils.isBetween(y, this.y1, this.y2) && Utils.isBetween(y, line.y1, line.y2)) {\n+-â”Š66â”Š  â”Š      return { x, y };\n+-â”Š67â”Š  â”Š    }\n+-â”Š68â”Š  â”Š  }\n+-â”Š69â”Š  â”Š\n+ â”Š70â”Š17â”Š  // line - circle intersection method\n+ â”Š71â”Š18â”Š  getCircleIntersection(circle) {\n+ â”Š72â”Š19â”Š    return circle.getLineIntersection(this);\n+```\n+[}]: #\n+\n+By now, our tests should pass. Accept, there is memory leak we need to handle. But you probably ask yourself - \"What memory leak? It's JavaScript man! Have you ever heard of something called garbage collector?!\". Well, this is not the case when compiling C++ code with Emscripten. You see, Emscripten uses asm.js, which is a subset for JavaScript built exactly for these proposes, enabling C++ modules run on the browser. This is how the [WebGL](https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API) project actually started, an almost complete conversion from the famous C++ [OpenGL](https://www.opengl.org/) to JavaScript. Part of what asm.js does, it disables the garbage collector, and instead, it holds raw pointers, just like in C++. Since returned class instances are pointers with unknown lifespans, they need to be disposed manually, using the `delete` method (identical to how we clear memory from the Heap in C++). Let's dispose unused test data by calling the `delete` method as just mentioned:\n+\n+[{]: <helper> (diff_step 7.16)\n+#### Step 7.16: Delete line instances in tests\n+\n+##### Changed resources/scripts/specs/engine/geometry/circle.js\n+```diff\n+@@ -111,6 +111,8 @@\n+ â”Š111â”Š111â”Š          { x: 6, y: 1 },\n+ â”Š112â”Š112â”Š          { x: -4, y: 1 }\n+ â”Š113â”Š113â”Š        ]);\n++â”Š   â”Š114â”Š\n++â”Š   â”Š115â”Š        line.delete();\n+ â”Š114â”Š116â”Š      });\n+ â”Š115â”Š117â”Š    });\n+ â”Š116â”Š118â”Š\n+```\n+```diff\n+@@ -121,6 +123,8 @@\n+ â”Š121â”Š123â”Š        expect(this.circle.getLineIntersection(line)).toEqual([\n+ â”Š122â”Š124â”Š          { x: -4, y: 1 }\n+ â”Š123â”Š125â”Š        ]);\n++â”Š   â”Š126â”Š\n++â”Š   â”Š127â”Š        line.delete();\n+ â”Š124â”Š128â”Š      });\n+ â”Š125â”Š129â”Š    });\n+ â”Š126â”Š130â”Š\n+```\n+```diff\n+@@ -131,6 +135,8 @@\n+ â”Š131â”Š135â”Š        expect(this.circle.getLineIntersection(line)).toEqual([\n+ â”Š132â”Š136â”Š          { x: 1, y: 6 }\n+ â”Š133â”Š137â”Š        ]);\n++â”Š   â”Š138â”Š\n++â”Š   â”Š139â”Š        line.delete();\n+ â”Š134â”Š140â”Š      });\n+ â”Š135â”Š141â”Š    });\n+ â”Š136â”Š142â”Š\n+```\n+```diff\n+@@ -138,6 +144,7 @@\n+ â”Š138â”Š144â”Š      it(\"returns nothing\", function() {\n+ â”Š139â”Š145â”Š        let line = new Engine.Geometry.Line(-10, 10, 10, 10);\n+ â”Š140â”Š146â”Š        expect(this.circle.getLineIntersection(line)).toBeUndefined();\n++â”Š   â”Š147â”Š        line.delete();\n+ â”Š141â”Š148â”Š      });\n+ â”Š142â”Š149â”Š    });\n+ â”Š143â”Š150â”Š  });\n+```\n+\n+##### Changed resources/scripts/specs/engine/geometry/line.js\n+```diff\n+@@ -3,6 +3,10 @@\n+ â”Š 3â”Š 3â”Š    this.line = new Engine.Geometry.Line(-5, -5, 5, 5);\n+ â”Š 4â”Š 4â”Š  });\n+ â”Š 5â”Š 5â”Š\n++â”Š  â”Š 6â”Š  afterEach(function () {\n++â”Š  â”Š 7â”Š    this.line.delete();\n++â”Š  â”Š 8â”Š  });\n++â”Š  â”Š 9â”Š\n+ â”Š 6â”Š10â”Š  describe(\"getX method\", function() {\n+ â”Š 7â”Š11â”Š    describe(\"given inranged y\", function() {\n+ â”Š 8â”Š12â”Š      it(\"returns x\", function() {\n+```\n+```diff\n+@@ -58,6 +62,8 @@\n+ â”Š58â”Š62â”Š          x: 1,\n+ â”Š59â”Š63â”Š          y: 1\n+ â”Š60â”Š64â”Š        });\n++â”Š  â”Š65â”Š\n++â”Š  â”Š66â”Š        line.delete();\n+ â”Š61â”Š67â”Š      });\n+ â”Š62â”Š68â”Š    });\n+ â”Š63â”Š69â”Š\n+```\n+```diff\n+@@ -65,6 +71,7 @@\n+ â”Š65â”Š71â”Š      it(\"returns nothing\", function() {\n+ â”Š66â”Š72â”Š        let line = new Engine.Geometry.Line(-5, -6, 5, 4);\n+ â”Š67â”Š73â”Š        expect(this.line.getLineIntersection(line)).toBeUndefined();\n++â”Š  â”Š74â”Š        line.delete();\n+ â”Š68â”Š75â”Š      });\n+ â”Š69â”Š76â”Š    });\n+ â”Š70â”Š77â”Š\n+```\n+```diff\n+@@ -72,6 +79,7 @@\n+ â”Š72â”Š79â”Š      it(\"returns nothing\", function() {\n+ â”Š73â”Š80â”Š        let line = new Engine.Geometry.Line(10, 10, 10, 15);\n+ â”Š74â”Š81â”Š        expect(this.line.getLineIntersection(line)).toBeUndefined();\n++â”Š  â”Š82â”Š        line.delete();\n+ â”Š75â”Š83â”Š      });\n+ â”Š76â”Š84â”Š    });\n+ â”Š77â”Š85â”Š  });\n+```\n+\n+##### Changed resources/scripts/specs/engine/geometry/polygon.js\n+```diff\n+@@ -35,6 +35,8 @@\n+ â”Š35â”Š35â”Š          { x: 5, y: 4 },\n+ â”Š36â”Š36â”Š          { x: 0, y: 1 }\n+ â”Š37â”Š37â”Š        ]);\n++â”Š  â”Š38â”Š\n++â”Š  â”Š39â”Š        line.delete();\n+ â”Š38â”Š40â”Š      });\n+ â”Š39â”Š41â”Š    });\n+ â”Š40â”Š42â”Š\n+```\n+```diff\n+@@ -43,6 +45,8 @@\n+ â”Š43â”Š45â”Š        let line = new Engine.Geometry.Line(10, 11, 15, 14);\n+ â”Š44â”Š46â”Š\n+ â”Š45â”Š47â”Š        expect(this.polygon.getLineIntersection(line)).toBeUndefined();\n++â”Š  â”Š48â”Š\n++â”Š  â”Š49â”Š        line.delete();\n+ â”Š46â”Š50â”Š      });\n+ â”Š47â”Š51â”Š    });\n+ â”Š48â”Š52â”Š  });\n+```\n+[}]: #\n+\n+Since our game also uses polygons, which is made of an abstract number of lines, its test-data needs to be disposed as well. First, we will add a `delete` method to the polygon class, which will simply go though all its bounds and delete each of its lines:\n+\n+[{]: <helper> (diff_step 7.17)\n+#### Step 7.17: Add polygon deletion method\n+\n+##### Changed resources/scripts/engine/geometry/polygon.js\n+```diff\n+@@ -5,6 +5,10 @@\n+ â”Š 5â”Š 5â”Š    this.bounds = bounds.map(coords => new Engine.Geometry.Line(...coords));\n+ â”Š 6â”Š 6â”Š  }\n+ â”Š 7â”Š 7â”Š\n++â”Š  â”Š 8â”Š  delete() {\n++â”Š  â”Š 9â”Š    this.bounds.forEach(bound => bound.delete());\n++â”Š  â”Š10â”Š  }\n++â”Š  â”Š11â”Š\n+ â”Š 8â”Š12â”Š  // Returns if polygon has given point\n+ â”Š 9â”Š13â”Š  hasPoint(x, y) {\n+ â”Š10â”Š14â”Š    // Run check for each bound\n+```\n+[}]: #\n+\n+Now we can conveniently delete unused polygons in the tests:\n+\n+[{]: <helper> (diff_step 7.18)\n+#### Step 7.18: Delete polygon instances in tests\n+\n+##### Changed resources/scripts/specs/engine/geometry/polygon.js\n+```diff\n+@@ -8,6 +8,10 @@\n+ â”Š 8â”Š 8â”Š    );\n+ â”Š 9â”Š 9â”Š  });\n+ â”Š10â”Š10â”Š\n++â”Š  â”Š11â”Š  afterEach(function () {\n++â”Š  â”Š12â”Š    this.polygon.delete();\n++â”Š  â”Š13â”Š  });\n++â”Š  â”Š14â”Š\n+ â”Š11â”Š15â”Š  describe(\"hasPoint method\", function() {\n+ â”Š12â”Š16â”Š    describe(\"given contained point\", function() {\n+ â”Š13â”Š17â”Š      it(\"returns true\", function() {\n+```\n+[}]: #\n+\n+Moving on, we have the circle class to transform. The process is almost the identical to how we transformed the line class, so it's gonna be way easier now. We first start by translating our code from JavaScript to C++:\n+\n+[{]: <helper> (diff_step 7.19)\n+#### Step 7.19: Add base circle CPP module\n+\n+##### Added resources/cpp/src/geometry/circle.cpp\n+```diff\n+@@ -0,0 +1,202 @@\n++â”Š   â”Š  1â”Š\n++â”Š   â”Š  2â”Š#include <algorithm>\n++â”Š   â”Š  3â”Š#include <cmath>\n++â”Š   â”Š  4â”Š#include <vector>\n++â”Š   â”Š  5â”Š#include \"../nullable.h\"\n++â”Š   â”Š  6â”Š#include \"../utils.h\"\n++â”Š   â”Š  7â”Š#include \"point.h\"\n++â”Š   â”Š  8â”Š#include \"line.h\"\n++â”Š   â”Š  9â”Š\n++â”Š   â”Š 10â”Šnamespace geometry {\n++â”Š   â”Š 11â”Š  // x - The x value of the circle's center\n++â”Š   â”Š 12â”Š  // y - The y value of the circle's center\n++â”Š   â”Š 13â”Š  // r - The radius of the center\n++â”Š   â”Š 14â”Š  // rad1 - The first radian of the circle, not necessarily its beginning\n++â”Š   â”Š 15â”Š  // rad2 - The second radian of the circle, not necessarily its beginning\n++â”Š   â”Š 16â”Š  Circle::Circle(double x, double y, double r, double rad1, double rad2) {\n++â”Š   â”Š 17â”Š    _x = utils::trim(x, 9);\n++â”Š   â”Š 18â”Š    _y = utils::trim(y, 9);\n++â”Š   â”Š 19â”Š    _r = utils::trim(r, 9);\n++â”Š   â”Š 20â”Š\n++â”Š   â”Š 21â”Š    // Trimming mode is done based on which radian represents the ending and which radian\n++â”Š   â”Š 22â”Š    // represents the ending\n++â”Š   â”Š 23â”Š    if (rad1 > rad2) {\n++â”Š   â”Š 24â”Š      _rad1 = utils::trim(rad1, 9, \"floor\");\n++â”Š   â”Š 25â”Š      _rad2 = utils::trim(rad2, 9, \"ceil\");\n++â”Š   â”Š 26â”Š    }\n++â”Š   â”Š 27â”Š    else {\n++â”Š   â”Š 28â”Š      _rad1 = utils::trim(rad1, 9, \"ceil\");\n++â”Š   â”Š 29â”Š      _rad2 = utils::trim(rad2, 9, \"floor\");\n++â”Š   â”Š 30â”Š    }\n++â”Š   â”Š 31â”Š  }\n++â”Š   â”Š 32â”Š\n++â”Š   â”Š 33â”Š  // Gets the matching x value for the given radian\n++â”Š   â”Š 34â”Š  Nullable<double> Circle::getMatchingX(double rad) {\n++â”Š   â”Š 35â”Š    if (!utils::chain(rad)->trim(9)->isBetween(_rad1, _rad2)->result()) {\n++â”Š   â”Š 36â”Š      return Nullable<double>();\n++â”Š   â”Š 37â”Š    }\n++â”Š   â”Š 38â”Š\n++â”Š   â”Š 39â”Š    return Nullable<double>(utils::trim((_r * std::cos(rad)) + _x, 9));\n++â”Š   â”Š 40â”Š  }\n++â”Š   â”Š 41â”Š\n++â”Š   â”Š 42â”Š  // Gets the matching y value for the given radian\n++â”Š   â”Š 43â”Š  Nullable<double> Circle::getMatchingY(double rad) {\n++â”Š   â”Š 44â”Š    if (!utils::chain(rad)->trim(9)->isBetween(_rad1, _rad2)->result()) {\n++â”Š   â”Š 45â”Š      return Nullable<double>();\n++â”Š   â”Š 46â”Š    }\n++â”Š   â”Š 47â”Š\n++â”Š   â”Š 48â”Š    return Nullable<double>(utils::trim((_r * std::sin(rad)) + _y, 9));\n++â”Š   â”Š 49â”Š  }\n++â”Š   â”Š 50â”Š\n++â”Š   â”Š 51â”Š  // Gets the matching point for the given radian\n++â”Š   â”Š 52â”Š  Nullable<Point> Circle::getMatchingPoint(double rad) {\n++â”Š   â”Š 53â”Š    if (!utils::isBetween(rad, _rad1, _rad2)) {\n++â”Š   â”Š 54â”Š      return Nullable<Point>();\n++â”Š   â”Š 55â”Š    }\n++â”Š   â”Š 56â”Š\n++â”Š   â”Š 57â”Š    return Nullable<Point>({\n++â”Š   â”Š 58â”Š      utils::trim((_r * std::cos(rad)) + _x, 9),\n++â”Š   â”Š 59â”Š      utils::trim((_r * std::sin(rad)) + _y, 9)\n++â”Š   â”Š 60â”Š    });\n++â”Š   â”Š 61â”Š  }\n++â”Š   â”Š 62â”Š\n++â”Š   â”Š 63â”Š  // Gets the matching radian for the given point\n++â”Š   â”Š 64â”Š  Nullable<double> Circle::getMatchingRad(double x, double y) {\n++â”Š   â”Š 65â”Š    double rad = std::atan2(y - _y, x - _x);\n++â”Š   â”Š 66â”Š\n++â”Š   â”Š 67â”Š    // If calculated radian is in circle's radian range, return it\n++â”Š   â”Š 68â”Š    if (!std::isnan(rad) && utils::isBetween(rad, _rad1, _rad2)) {\n++â”Š   â”Š 69â”Š      return Nullable<double>(rad);\n++â”Š   â”Š 70â”Š    }\n++â”Š   â”Š 71â”Š\n++â”Š   â”Š 72â”Š    // The calculated radian can still be in the circle's radian range in case one\n++â”Š   â”Š 73â”Š    // of the radians is greater than 2 PIEs\n++â”Š   â”Š 74â”Š    double greatestRad = std::abs(_rad1) > std::abs(_rad2) ? _rad1 : _rad2;\n++â”Š   â”Š 75â”Š\n++â”Š   â”Š 76â”Š    // Check if the absolute radian is in the circle's radian range\n++â”Š   â”Š 77â”Š    if (utils::chain(rad + (2 * M_PI * std::floor(greatestRad / (2 * M_PI))))\n++â”Š   â”Š 78â”Š        ->trim(9)->isBetween(_rad1, _rad2)->result() ||\n++â”Š   â”Š 79â”Š        utils::chain(rad + (2 * M_PI * std::ceil(greatestRad / (2 * M_PI))))\n++â”Š   â”Š 80â”Š        ->trim(9)->isBetween(_rad1, _rad2)->result()) {\n++â”Š   â”Š 81â”Š      return Nullable<double>(rad);\n++â”Š   â”Š 82â”Š    }\n++â”Š   â”Š 83â”Š\n++â”Š   â”Š 84â”Š    return Nullable<double>();\n++â”Š   â”Š 85â”Š  }\n++â”Š   â”Š 86â”Š\n++â”Š   â”Š 87â”Š  // Returns if circle has given points\n++â”Š   â”Š 88â”Š  bool Circle::hasPoint(double x, double y) {\n++â”Š   â”Š 89â”Š    return getMatchingRad(x, y).hasValue();\n++â”Š   â”Š 90â”Š  }\n++â”Š   â”Š 91â”Š\n++â”Š   â”Š 92â”Š  // circle - circle intersection method\n++â”Š   â”Š 93â”Š  Nullable<std::vector<Point>> Circle::getIntersection(Circle circle) {\n++â”Š   â”Š 94â”Š    double dx = circle._x - _x;\n++â”Š   â”Š 95â”Š    double dy = circle._y - _y;\n++â”Š   â”Š 96â”Š    double d = std::sqrt(std::pow(dx, 2) + std::pow(dy, 2));\n++â”Š   â”Š 97â”Š\n++â”Š   â”Š 98â”Š    if (d > _r + circle._r ||\n++â”Š   â”Š 99â”Š       d < std::abs(_r - circle._r)) {\n++â”Š   â”Š100â”Š      return Nullable<std::vector<Point>>();\n++â”Š   â”Š101â”Š    }\n++â”Š   â”Š102â”Š\n++â”Š   â”Š103â”Š    double a = ((std::pow(_r, 2) - std::pow(circle._r, 2)) + std::pow(d, 2)) / (2 * d);\n++â”Š   â”Š104â”Š    double x = _x + ((dx * a) / d);\n++â”Š   â”Š105â”Š    double y = _y + ((dy * a) / d);\n++â”Š   â”Š106â”Š    double h = std::sqrt(std::pow(_r, 2) - std::pow(a, 2));\n++â”Š   â”Š107â”Š    double rx = (- dy * h) / d;\n++â”Š   â”Š108â”Š    double ry = (dx * h) / d;\n++â”Š   â”Š109â”Š\n++â”Š   â”Š110â”Š    std::vector<Point> interPoints(2);\n++â”Š   â”Š111â”Š    interPoints.at(0).x = x + rx;\n++â”Š   â”Š112â”Š    interPoints.at(0).y = y + ry;\n++â”Š   â”Š113â”Š    interPoints.at(1).x = x - rx;\n++â”Š   â”Š114â”Š    interPoints.at(1).y = y - ry;\n++â”Š   â”Š115â”Š\n++â”Š   â”Š116â”Š    for (unsigned i = 0; i < interPoints.size(); i++) {\n++â”Š   â”Š117â”Š      Point& point = interPoints.at(i);\n++â”Š   â”Š118â”Š      point.x = utils::trim(point.x, 9);\n++â”Š   â”Š119â”Š      point.y = utils::trim(point.y, 9);\n++â”Š   â”Š120â”Š    }\n++â”Š   â”Š121â”Š\n++â”Š   â”Š122â”Š    auto pointsBegin = std::unique(interPoints.begin(), interPoints.end(),\n++â”Š   â”Š123â”Š      [](Point pointA, Point pointB) {\n++â”Š   â”Š124â”Š        return pointA.x == pointB.x && pointA.y == pointB.y;\n++â”Š   â”Š125â”Š      }\n++â”Š   â”Š126â”Š    );\n++â”Š   â”Š127â”Š\n++â”Š   â”Š128â”Š    interPoints.erase(pointsBegin, interPoints.end());\n++â”Š   â”Š129â”Š\n++â”Š   â”Š130â”Š    std::vector<Circle> circles = { *this, circle };\n++â”Š   â”Š131â”Š\n++â”Š   â”Š132â”Š    std::for_each(circles.begin(), circles.end(), [&interPoints](Circle circle) {\n++â”Š   â”Š133â”Š      auto pointsBegin = std::remove_if(interPoints.begin(), interPoints.end(),\n++â”Š   â”Š134â”Š        [&circle](Point point) {\n++â”Š   â”Š135â”Š          return !circle.hasPoint(point.x, point.y);\n++â”Š   â”Š136â”Š        }\n++â”Š   â”Š137â”Š      );\n++â”Š   â”Š138â”Š\n++â”Š   â”Š139â”Š      interPoints.erase(pointsBegin, interPoints.end());\n++â”Š   â”Š140â”Š    });\n++â”Š   â”Š141â”Š\n++â”Š   â”Š142â”Š    if (interPoints.size()) {\n++â”Š   â”Š143â”Š      return Nullable<std::vector<Point>>(interPoints);\n++â”Š   â”Š144â”Š    }\n++â”Š   â”Š145â”Š\n++â”Š   â”Š146â”Š    return Nullable<std::vector<Point>>();\n++â”Š   â”Š147â”Š  }\n++â”Š   â”Š148â”Š\n++â”Š   â”Š149â”Š  // circle - line intersection method\n++â”Š   â”Š150â”Š  Nullable<std::vector<Point>> Circle::getIntersection(Line line) {\n++â”Š   â”Š151â”Š    double x1 = line._x1 - _x;\n++â”Š   â”Š152â”Š    double x2 = line._x2 - _x;\n++â”Š   â”Š153â”Š    double y1 = line._y1 - _y;\n++â”Š   â”Š154â”Š    double y2 = line._y2 - _y;\n++â”Š   â”Š155â”Š    double dx = x2 - x1;\n++â”Š   â”Š156â”Š    double dy = y2 - y1;\n++â”Š   â”Š157â”Š    double d = std::sqrt(std::pow(dx, 2) + std::pow(dy, 2));\n++â”Š   â”Š158â”Š    double h = (x1 * y2) - (x2 * y1);\n++â”Š   â”Š159â”Š    double delta = (std::pow(_r, 2) * std::pow(d, 2)) - std::pow(h, 2);\n++â”Š   â”Š160â”Š\n++â”Š   â”Š161â”Š    if (delta < 0) Nullable<std::vector<Point>>();\n++â”Š   â”Š162â”Š\n++â”Š   â”Š163â”Š    double sign = dy / std::abs(dy); if (std::isnan(sign)) sign = 1;\n++â”Š   â”Š164â”Š    double sqrtx = sign * dx * std::sqrt(delta);\n++â”Š   â”Š165â”Š    double sqrty = std::abs(dy) * std::sqrt(delta);\n++â”Š   â”Š166â”Š\n++â”Š   â”Š167â”Š    std::vector<Point> interPoints(2);\n++â”Š   â”Š168â”Š    interPoints.at(0).x = (((h * dy) + sqrtx) / std::pow(d, 2)) + _x;\n++â”Š   â”Š169â”Š    interPoints.at(0).y = (((-h * dx) + sqrty) / std::pow(d, 2)) + _y;\n++â”Š   â”Š170â”Š    interPoints.at(1).x = (((h * dy) - sqrtx) / std::pow(d, 2)) + _x;\n++â”Š   â”Š171â”Š    interPoints.at(1).y = (((-h * dx) - sqrty) / std::pow(d, 2)) + _y;\n++â”Š   â”Š172â”Š\n++â”Š   â”Š173â”Š    for (unsigned i = 0; i < interPoints.size(); i++) {\n++â”Š   â”Š174â”Š      Point& point = interPoints.at(i);\n++â”Š   â”Š175â”Š      point.x = utils::trim(point.x, 9);\n++â”Š   â”Š176â”Š      point.y = utils::trim(point.y, 9);\n++â”Š   â”Š177â”Š    }\n++â”Š   â”Š178â”Š\n++â”Š   â”Š179â”Š    auto pointsBegin = std::remove_if(interPoints.begin(), interPoints.end(),\n++â”Š   â”Š180â”Š      [this, &line](Point point) {\n++â”Š   â”Š181â”Š        return !hasPoint(point.x, point.y) ||\n++â”Š   â”Š182â”Š          !line.boundsHavePoint(point.x, point.y);\n++â”Š   â”Š183â”Š      }\n++â”Š   â”Š184â”Š    );\n++â”Š   â”Š185â”Š\n++â”Š   â”Š186â”Š    interPoints.erase(pointsBegin, interPoints.end());\n++â”Š   â”Š187â”Š\n++â”Š   â”Š188â”Š    pointsBegin = std::unique(interPoints.begin(), interPoints.end(),\n++â”Š   â”Š189â”Š      [](Point pointA, Point pointB) {\n++â”Š   â”Š190â”Š        return pointA.x == pointB.x && pointA.y == pointB.y;\n++â”Š   â”Š191â”Š      }\n++â”Š   â”Š192â”Š    );\n++â”Š   â”Š193â”Š\n++â”Š   â”Š194â”Š    interPoints.erase(pointsBegin, interPoints.end());\n++â”Š   â”Š195â”Š\n++â”Š   â”Š196â”Š    if (interPoints.size()) {\n++â”Š   â”Š197â”Š      return Nullable<std::vector<Point>>(interPoints);\n++â”Š   â”Š198â”Š    }\n++â”Š   â”Š199â”Š\n++â”Š   â”Š200â”Š    return Nullable<std::vector<Point>>();\n++â”Š   â”Š201â”Š  }\n++â”Š   â”Š202â”Š}ðŸš«â†µ\n+```\n+\n+##### Added resources/cpp/src/geometry/circle.h\n+```diff\n+@@ -0,0 +1,35 @@\n++â”Š  â”Š 1â”Š#pragma once\n++â”Š  â”Š 2â”Š\n++â”Š  â”Š 3â”Š#include <vector>\n++â”Š  â”Š 4â”Š#include \"../nullable.h\"\n++â”Š  â”Š 5â”Š#include \"point.h\"\n++â”Š  â”Š 6â”Š#include \"line.h\"\n++â”Š  â”Š 7â”Š\n++â”Š  â”Š 8â”Šnamespace geometry {\n++â”Š  â”Š 9â”Š  class Line;\n++â”Š  â”Š10â”Š\n++â”Š  â”Š11â”Š  class Circle {\n++â”Š  â”Š12â”Š  public:\n++â”Š  â”Š13â”Š    double _x;\n++â”Š  â”Š14â”Š    double _y;\n++â”Š  â”Š15â”Š    double _r;\n++â”Š  â”Š16â”Š    double _rad1;\n++â”Š  â”Š17â”Š    double _rad2;\n++â”Š  â”Š18â”Š\n++â”Š  â”Š19â”Š    Circle(double x, double y, double r, double rad1, double rad2);\n++â”Š  â”Š20â”Š\n++â”Š  â”Š21â”Š    Nullable<double> getMatchingX(double rad);\n++â”Š  â”Š22â”Š\n++â”Š  â”Š23â”Š    Nullable<double> getMatchingY(double rad);\n++â”Š  â”Š24â”Š\n++â”Š  â”Š25â”Š    Nullable<Point> getMatchingPoint(double rad);\n++â”Š  â”Š26â”Š\n++â”Š  â”Š27â”Š    Nullable<double> getMatchingRad(double x, double y);\n++â”Š  â”Š28â”Š\n++â”Š  â”Š29â”Š    bool hasPoint(double x, double y);\n++â”Š  â”Š30â”Š\n++â”Š  â”Š31â”Š    Nullable<std::vector<Point>> getIntersection(Circle circle);\n++â”Š  â”Š32â”Š\n++â”Š  â”Š33â”Š    Nullable<std::vector<Point>> getIntersection(Line line);\n++â”Š  â”Š34â”Š  };\n++â”Š  â”Š35â”Š}ðŸš«â†µ\n+```\n+\n+##### Changed resources/cpp/src/index.cpp\n+```diff\n+@@ -1,3 +1,4 @@\n+ â”Š1â”Š1â”Š#include \"nullable.cpp\"\n+ â”Š2â”Š2â”Š#include \"utils.cpp\"\n+-â”Š3â”Š â”Š#include \"geometry/line.cpp\"ðŸš«â†µ\n++â”Š â”Š3â”Š#include \"geometry/line.cpp\"\n++â”Š â”Š4â”Š#include \"geometry/circle.cpp\"ðŸš«â†µ\n+```\n+[}]: #\n+\n+Second, we need to wrap our code using EMBind:\n+\n+[{]: <helper> (diff_step 7.20)\n+#### Step 7.20: EMBind CPP circle\n+\n+##### Changed resources/cpp/post.js\n+```diff\n+@@ -7,7 +7,8 @@\n+ â”Š 7â”Š 7â”Š  },\n+ â”Š 8â”Š 8â”Š\n+ â”Š 9â”Š 9â”Š  Geometry: {\n+-â”Š10â”Š  â”Š    Line: Module.geometry_line\n++â”Š  â”Š10â”Š    Line: Module.geometry_line,\n++â”Š  â”Š11â”Š    Circle: Module.geometry_circle\n+ â”Š11â”Š12â”Š  }\n+ â”Š12â”Š13â”Š};\n+ â”Š13â”Š14â”Š\n+```\n+\n+##### Changed resources/cpp/src/geometry/circle.cpp\n+```diff\n+@@ -1,7 +1,8 @@\n+-â”Š1â”Š â”Š\n+ â”Š2â”Š1â”Š#include <algorithm>\n+ â”Š3â”Š2â”Š#include <cmath>\n+ â”Š4â”Š3â”Š#include <vector>\n++â”Š â”Š4â”Š#include <emscripten/bind.h>\n++â”Š â”Š5â”Š#include <emscripten/val.h>\n+ â”Š5â”Š6â”Š#include \"../nullable.h\"\n+ â”Š6â”Š7â”Š#include \"../utils.h\"\n+ â”Š7â”Š8â”Š#include \"point.h\"\n+```\n+```diff\n+@@ -199,4 +200,107 @@\n+ â”Š199â”Š200â”Š\n+ â”Š200â”Š201â”Š    return Nullable<std::vector<Point>>();\n+ â”Š201â”Š202â”Š  }\n++â”Š   â”Š203â”Š\n++â”Š   â”Š204â”Š  emscripten::val EMCircle::getMatchingX(double y) {\n++â”Š   â”Š205â”Š    Nullable<double> nullableX = Circle::getMatchingX(y);\n++â”Š   â”Š206â”Š    return nullableX.hasValue() ?\n++â”Š   â”Š207â”Š      emscripten::val(nullableX.getValue()) :\n++â”Š   â”Š208â”Š      emscripten::val::undefined();\n++â”Š   â”Š209â”Š  }\n++â”Š   â”Š210â”Š\n++â”Š   â”Š211â”Š  emscripten::val EMCircle::getMatchingY(double x) {\n++â”Š   â”Š212â”Š    Nullable<double> nullableY = Circle::getMatchingY(x);\n++â”Š   â”Š213â”Š    return nullableY.hasValue() ?\n++â”Š   â”Š214â”Š      emscripten::val(nullableY.getValue()) :\n++â”Š   â”Š215â”Š      emscripten::val::undefined();\n++â”Š   â”Š216â”Š  }\n++â”Š   â”Š217â”Š\n++â”Š   â”Š218â”Š  emscripten::val EMCircle::getMatchingPoint(double rad) {\n++â”Š   â”Š219â”Š    Nullable<Point> nullablePoint = Circle::getMatchingPoint(rad);\n++â”Š   â”Š220â”Š\n++â”Š   â”Š221â”Š    if (nullablePoint.isNull()) return emscripten::val::undefined();\n++â”Š   â”Š222â”Š\n++â”Š   â”Š223â”Š    Point point = nullablePoint.getValue();\n++â”Š   â”Š224â”Š    emscripten::val emPoint = emscripten::val::object();\n++â”Š   â”Š225â”Š    emPoint.set(\"x\", emscripten::val(point.x));\n++â”Š   â”Š226â”Š    emPoint.set(\"y\", emscripten::val(point.y));\n++â”Š   â”Š227â”Š    return emPoint;\n++â”Š   â”Š228â”Š  }\n++â”Š   â”Š229â”Š\n++â”Š   â”Š230â”Š  emscripten::val EMCircle::getMatchingRad(double x, double y) {\n++â”Š   â”Š231â”Š    Nullable<double> nullableRad = Circle::getMatchingRad(x, y);\n++â”Š   â”Š232â”Š    return nullableRad.hasValue() ?\n++â”Š   â”Š233â”Š      emscripten::val(nullableRad.getValue()) :\n++â”Š   â”Š234â”Š      emscripten::val::undefined();\n++â”Š   â”Š235â”Š  }\n++â”Š   â”Š236â”Š\n++â”Š   â”Š237â”Š  emscripten::val EMCircle::getIntersection(EMLine emLine) {\n++â”Š   â”Š238â”Š    Line line = Line(emLine._x1, emLine._y1, emLine._x2, emLine._y2);\n++â”Š   â”Š239â”Š    Nullable<std::vector<Point>> nullablePoints = Circle::getIntersection(line);\n++â”Š   â”Š240â”Š\n++â”Š   â”Š241â”Š    if (nullablePoints.isNull()) return emscripten::val::undefined();\n++â”Š   â”Š242â”Š\n++â”Š   â”Š243â”Š    std::vector<Point> points = nullablePoints.getValue();\n++â”Š   â”Š244â”Š    emscripten::val emPoints = emscripten::val::array();\n++â”Š   â”Š245â”Š\n++â”Š   â”Š246â”Š    for (unsigned i = 0; i < points.size(); i++) {\n++â”Š   â”Š247â”Š      Point point = points.at(i);\n++â”Š   â”Š248â”Š      emscripten::val emPoint = emscripten::val::object();\n++â”Š   â”Š249â”Š      emPoint.set(\"x\", emscripten::val(point.x));\n++â”Š   â”Š250â”Š      emPoint.set(\"y\", emscripten::val(point.y));\n++â”Š   â”Š251â”Š      emPoints.set(i, emPoint);\n++â”Š   â”Š252â”Š    }\n++â”Š   â”Š253â”Š\n++â”Š   â”Š254â”Š    return emPoints;\n++â”Š   â”Š255â”Š  }\n++â”Š   â”Š256â”Š\n++â”Š   â”Š257â”Š  emscripten::val EMCircle::getIntersection(EMCircle emCircle) {\n++â”Š   â”Š258â”Š    Circle circle = Circle(\n++â”Š   â”Š259â”Š      emCircle._x, emCircle._y, emCircle._r, emCircle._rad1, emCircle._rad2\n++â”Š   â”Š260â”Š    );\n++â”Š   â”Š261â”Š    Nullable<std::vector<Point>> nullablePoints = Circle::getIntersection(circle);\n++â”Š   â”Š262â”Š\n++â”Š   â”Š263â”Š    if (nullablePoints.isNull()) return emscripten::val::undefined();\n++â”Š   â”Š264â”Š\n++â”Š   â”Š265â”Š    std::vector<Point> points = nullablePoints.getValue();\n++â”Š   â”Š266â”Š    emscripten::val emPoints = emscripten::val::array();\n++â”Š   â”Š267â”Š\n++â”Š   â”Š268â”Š    for (unsigned i = 0; i < points.size(); i++) {\n++â”Š   â”Š269â”Š      Point point = points.at(i);\n++â”Š   â”Š270â”Š      emscripten::val emPoint = emscripten::val::object();\n++â”Š   â”Š271â”Š      emPoint.set(\"x\", emscripten::val(point.x));\n++â”Š   â”Š272â”Š      emPoint.set(\"y\", emscripten::val(point.y));\n++â”Š   â”Š273â”Š      emPoints.set(i, emPoint);\n++â”Š   â”Š274â”Š    }\n++â”Š   â”Š275â”Š\n++â”Š   â”Š276â”Š    return emPoints;\n++â”Š   â”Š277â”Š  }\n++â”Š   â”Š278â”Š}\n++â”Š   â”Š279â”Š\n++â”Š   â”Š280â”ŠEMSCRIPTEN_BINDINGS(geometry_circle_module) {\n++â”Š   â”Š281â”Š  emscripten::class_<geometry::Circle>(\"geometry_circle_base\")\n++â”Š   â”Š282â”Š    .constructor<double, double, double, double, double>()\n++â”Š   â”Š283â”Š    .property<double>(\"x\", &geometry::Circle::_x)\n++â”Š   â”Š284â”Š    .property<double>(\"y\", &geometry::Circle::_y)\n++â”Š   â”Š285â”Š    .property<double>(\"r\", &geometry::Circle::_r)\n++â”Š   â”Š286â”Š    .property<double>(\"rad1\", &geometry::Circle::_rad1)\n++â”Š   â”Š287â”Š    .property<double>(\"rad2\", &geometry::Circle::_rad2)\n++â”Š   â”Š288â”Š    .function(\"hasPoint\", &geometry::Circle::hasPoint);\n++â”Š   â”Š289â”Š\n++â”Š   â”Š290â”Š  emscripten::class_<geometry::EMCircle, emscripten::base<geometry::Circle>>(\"geometry_circle\")\n++â”Š   â”Š291â”Š    .constructor<double, double, double, double, double>()\n++â”Š   â”Š292â”Š    .function(\"getX\", &geometry::EMCircle::getMatchingX)\n++â”Š   â”Š293â”Š    .function(\"getY\", &geometry::EMCircle::getMatchingY)\n++â”Š   â”Š294â”Š    .function(\"getPoint\", &geometry::EMCircle::getMatchingPoint)\n++â”Š   â”Š295â”Š    .function(\"getRad\", &geometry::EMCircle::getMatchingRad)\n++â”Š   â”Š296â”Š    .function(\"getLineIntersection\",\n++â”Š   â”Š297â”Š      emscripten::select_overload<emscripten::val(geometry::EMLine)>(\n++â”Š   â”Š298â”Š        &geometry::EMCircle::getIntersection\n++â”Š   â”Š299â”Š      )\n++â”Š   â”Š300â”Š    )\n++â”Š   â”Š301â”Š    .function(\"getCircleIntersection\",\n++â”Š   â”Š302â”Š      emscripten::select_overload<emscripten::val(geometry::EMCircle)>(\n++â”Š   â”Š303â”Š        &geometry::EMCircle::getIntersection\n++â”Š   â”Š304â”Š      )\n++â”Š   â”Š305â”Š    );\n+ â”Š202â”Š306â”Š}ðŸš«â†µ\n+```\n+\n+##### Changed resources/cpp/src/geometry/circle.h\n+```diff\n+@@ -1,12 +1,14 @@\n+ â”Š 1â”Š 1â”Š#pragma once\n+ â”Š 2â”Š 2â”Š\n+ â”Š 3â”Š 3â”Š#include <vector>\n++â”Š  â”Š 4â”Š#include <emscripten/val.h>\n+ â”Š 4â”Š 5â”Š#include \"../nullable.h\"\n+ â”Š 5â”Š 6â”Š#include \"point.h\"\n+ â”Š 6â”Š 7â”Š#include \"line.h\"\n+ â”Š 7â”Š 8â”Š\n+ â”Š 8â”Š 9â”Šnamespace geometry {\n+ â”Š 9â”Š10â”Š  class Line;\n++â”Š  â”Š11â”Š  class EMLine;\n+ â”Š10â”Š12â”Š\n+ â”Š11â”Š13â”Š  class Circle {\n+ â”Š12â”Š14â”Š  public:\n+```\n+```diff\n+@@ -32,4 +34,21 @@\n+ â”Š32â”Š34â”Š\n+ â”Š33â”Š35â”Š    Nullable<std::vector<Point>> getIntersection(Line line);\n+ â”Š34â”Š36â”Š  };\n++â”Š  â”Š37â”Š\n++â”Š  â”Š38â”Š  class EMCircle : public Circle {\n++â”Š  â”Š39â”Š  public:\n++â”Š  â”Š40â”Š    using Circle::Circle;\n++â”Š  â”Š41â”Š\n++â”Š  â”Š42â”Š    emscripten::val getMatchingX(double y);\n++â”Š  â”Š43â”Š\n++â”Š  â”Š44â”Š    emscripten::val getMatchingY(double x);\n++â”Š  â”Š45â”Š\n++â”Š  â”Š46â”Š    emscripten::val getMatchingPoint(double rad);\n++â”Š  â”Š47â”Š\n++â”Š  â”Š48â”Š    emscripten::val getMatchingRad(double x, double y);\n++â”Š  â”Š49â”Š\n++â”Š  â”Š50â”Š    emscripten::val getIntersection(EMLine line);\n++â”Š  â”Š51â”Š\n++â”Š  â”Š52â”Š    emscripten::val getIntersection(EMCircle circle);\n++â”Š  â”Š53â”Š  };\n+ â”Š35â”Š54â”Š}ðŸš«â†µ\n+```\n+[}]: #\n+\n+And finally, we will extend the C++ in our JavaScript circle:\n+\n+[{]: <helper> (diff_step 7.21)\n+#### Step 7.21: Extend CPP circle class\n+\n+##### Changed resources/scripts/engine/geometry/circle.js\n+```diff\n+@@ -1,83 +1,9 @@\n+-â”Š 1â”Š  â”ŠEngine.Geometry.Circle = class Circle {\n+-â”Š 2â”Š  â”Š  // x - The x value of the circle's center\n+-â”Š 3â”Š  â”Š  // y - The y value of the circle's center\n+-â”Š 4â”Š  â”Š  // r - The radius of the center\n+-â”Š 5â”Š  â”Š  // rad1 - The first radian of the circle, not necessarily its beginning\n+-â”Š 6â”Š  â”Š  // rad2 - The second radian of the circle, not necessarily its beginning\n+-â”Š 7â”Š  â”Š  constructor(x, y, r, rad1, rad2) {\n+-â”Š 8â”Š  â”Š    this.x = Utils.trim(x, 9);\n+-â”Š 9â”Š  â”Š    this.y = Utils.trim(y, 9);\n+-â”Š10â”Š  â”Š    this.r = Utils.trim(r, 9);\n+-â”Š11â”Š  â”Š\n+-â”Š12â”Š  â”Š    // Trimming mode is done based on which radian represents the ending and which radian\n+-â”Š13â”Š  â”Š    // represents the ending\n+-â”Š14â”Š  â”Š    if (rad1 > rad2) {\n+-â”Š15â”Š  â”Š      this.rad1 = Utils.trim(rad1, 9, \"floor\");\n+-â”Š16â”Š  â”Š      this.rad2 = Utils.trim(rad2, 9, \"ceil\");\n+-â”Š17â”Š  â”Š    }\n+-â”Š18â”Š  â”Š    else {\n+-â”Š19â”Š  â”Š      this.rad1 = Utils.trim(rad1, 9, \"ceil\");\n+-â”Š20â”Š  â”Š      this.rad2 = Utils.trim(rad2, 9, \"floor\");\n+-â”Š21â”Š  â”Š    }\n+-â”Š22â”Š  â”Š  }\n+-â”Š23â”Š  â”Š\n++â”Š  â”Š 1â”ŠEngine.Geometry.Circle = class Circle extends Utils.proxy(CPP.Geometry.Circle) {\n+ â”Š24â”Š 2â”Š  // Draws the circle on the given context\n+ â”Š25â”Š 3â”Š  draw(context) {\n+ â”Š26â”Š 4â”Š    context.arc(this.x, this.y, this.r, this.rad1, this.rad2);\n+ â”Š27â”Š 5â”Š  }\n+ â”Š28â”Š 6â”Š\n+-â”Š29â”Š  â”Š  // Gets the matching x value for the given radian\n+-â”Š30â”Š  â”Š  getX(rad) {\n+-â”Š31â”Š  â”Š    if (!Utils(rad).trim(9).isBetween(this.rad1, this.rad2).value()) return;\n+-â”Š32â”Š  â”Š    return Utils.trim((this.r * Math.cos(rad)) + this.x, 9);\n+-â”Š33â”Š  â”Š  }\n+-â”Š34â”Š  â”Š\n+-â”Š35â”Š  â”Š  // Gets the matching y value for the given radian\n+-â”Š36â”Š  â”Š  getY(rad) {\n+-â”Š37â”Š  â”Š    if (!Utils(rad).trim(9).isBetween(this.rad1, this.rad2).value()) return;\n+-â”Š38â”Š  â”Š    return Utils.trim((this.r * Math.sin(rad)) + this.y, 9);\n+-â”Š39â”Š  â”Š  }\n+-â”Š40â”Š  â”Š\n+-â”Š41â”Š  â”Š  // Gets the matching point for the given radian\n+-â”Š42â”Š  â”Š  getPoint(rad) {\n+-â”Š43â”Š  â”Š    if (!Utils.isBetween(rad, this.rad1, this.rad2)) return;\n+-â”Š44â”Š  â”Š\n+-â”Š45â”Š  â”Š    return {\n+-â”Š46â”Š  â”Š      x: Utils.trim((this.r * Math.cos(rad)) + this.x, 9),\n+-â”Š47â”Š  â”Š      y: Utils.trim((this.r * Math.sin(rad)) + this.y, 9)\n+-â”Š48â”Š  â”Š    };\n+-â”Š49â”Š  â”Š  }\n+-â”Š50â”Š  â”Š\n+-â”Š51â”Š  â”Š  // Gets the matching radian for the given point\n+-â”Š52â”Š  â”Š  getRad(x, y) {\n+-â”Š53â”Š  â”Š    let rad = Math.atan2(y - this.y, x - this.x);\n+-â”Š54â”Š  â”Š\n+-â”Š55â”Š  â”Š    // If calculated radian is in circle's radian range, return it\n+-â”Š56â”Š  â”Š    if (rad != null && Utils.isBetween(rad, this.rad1, this.rad2)) {\n+-â”Š57â”Š  â”Š      return rad;\n+-â”Š58â”Š  â”Š    }\n+-â”Š59â”Š  â”Š\n+-â”Š60â”Š  â”Š    // The calculated radian can still be in the circle's radian range in case one\n+-â”Š61â”Š  â”Š    // of the radians is greater than 2 PIEs\n+-â”Š62â”Š  â”Š    if (Math.abs(this.rad1) > Math.abs(this.rad2)) {\n+-â”Š63â”Š  â”Š      var greatestRad = this.rad1;\n+-â”Š64â”Š  â”Š    }\n+-â”Š65â”Š  â”Š    else {\n+-â”Š66â”Š  â”Š      var greatestRad = this.rad2;\n+-â”Š67â”Š  â”Š    }\n+-â”Š68â”Š  â”Š\n+-â”Š69â”Š  â”Š    // Check if the absolute radian is in the circle's radian range\n+-â”Š70â”Š  â”Š    if (Utils(rad + (2 * Math.PI * Math.floor(greatestRad / (2 * Math.PI)))).trim(9).isBetween(this.rad1, this.rad2).value() ||\n+-â”Š71â”Š  â”Š        Utils(rad + (2 * Math.PI * Math.ceil(greatestRad / (2 * Math.PI)))).trim(9).isBetween(this.rad1, this.rad2).value()) {\n+-â”Š72â”Š  â”Š      return rad;\n+-â”Š73â”Š  â”Š    }\n+-â”Š74â”Š  â”Š  }\n+-â”Š75â”Š  â”Š\n+-â”Š76â”Š  â”Š  // Returns if circle has given points\n+-â”Š77â”Š  â”Š  hasPoint(x, y) {\n+-â”Š78â”Š  â”Š    return this.getRad(x, y) != null;\n+-â”Š79â”Š  â”Š  }\n+-â”Š80â”Š  â”Š\n+ â”Š81â”Š 7â”Š  getIntersection(shape) {\n+ â”Š82â”Š 8â”Š    if (shape instanceof Engine.Geometry.Line)\n+ â”Š83â”Š 9â”Š      return this.getLineIntersection(shape);\n+```\n+```diff\n+@@ -87,86 +13,6 @@\n+ â”Š 87â”Š 13â”Š      return this.getPolygonIntersection(shape);\n+ â”Š 88â”Š 14â”Š  }\n+ â”Š 89â”Š 15â”Š\n+-â”Š 90â”Š   â”Š  // circle - circle intersection method\n+-â”Š 91â”Š   â”Š  getCircleIntersection(circle) {\n+-â”Š 92â”Š   â”Š    let dx = circle.x - this.x;\n+-â”Š 93â”Š   â”Š    let dy = circle.y - this.y;\n+-â”Š 94â”Š   â”Š    let d = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\n+-â”Š 95â”Š   â”Š\n+-â”Š 96â”Š   â”Š    if (d > this.r + circle.r ||\n+-â”Š 97â”Š   â”Š       d < Math.abs(this.r - circle.r)) {\n+-â”Š 98â”Š   â”Š      return;\n+-â”Š 99â”Š   â”Š    }\n+-â”Š100â”Š   â”Š\n+-â”Š101â”Š   â”Š    let a = ((Math.pow(this.r, 2) - Math.pow(circle.r, 2)) + Math.pow(d, 2)) / (2 * d);\n+-â”Š102â”Š   â”Š    let x = this.x + ((dx * a) / d);\n+-â”Š103â”Š   â”Š    let y = this.y + ((dy * a) / d);\n+-â”Š104â”Š   â”Š    let h = Math.sqrt(Math.pow(this.r, 2) - Math.pow(a, 2));\n+-â”Š105â”Š   â”Š    let rx = (- dy * h) / d;\n+-â”Š106â”Š   â”Š    let ry = (dx * h) / d;\n+-â”Š107â”Š   â”Š\n+-â”Š108â”Š   â”Š    let interPoints = [\n+-â”Š109â”Š   â”Š      {\n+-â”Š110â”Š   â”Š        x: x + rx,\n+-â”Š111â”Š   â”Š        y: y + ry\n+-â”Š112â”Š   â”Š      },\n+-â”Š113â”Š   â”Š      {\n+-â”Š114â”Š   â”Š        x: x - rx,\n+-â”Š115â”Š   â”Š        y: y - ry\n+-â”Š116â”Š   â”Š      }\n+-â”Š117â”Š   â”Š    ]\n+-â”Š118â”Š   â”Š    .map(point => ({\n+-â”Š119â”Š   â”Š        x: Utils.trim(point.x, 9),\n+-â”Š120â”Š   â”Š        y: Utils.trim(point.y, 9)\n+-â”Š121â”Š   â”Š     }));\n+-â”Š122â”Š   â”Š\n+-â”Š123â”Š   â”Š    interPoints = _.uniq(interPoints, point => `(${point.x}, ${point.y})`);\n+-â”Š124â”Š   â”Š\n+-â”Š125â”Š   â”Š    [this, circle].forEach(function(circle) {\n+-â”Š126â”Š   â”Š      interPoints = interPoints.filter(point => circle.hasPoint(point.x, point.y));\n+-â”Š127â”Š   â”Š    });\n+-â”Š128â”Š   â”Š\n+-â”Š129â”Š   â”Š    if (interPoints.length > 0) return interPoints;\n+-â”Š130â”Š   â”Š  }\n+-â”Š131â”Š   â”Š\n+-â”Š132â”Š   â”Š  // circle - line intersection method\n+-â”Š133â”Š   â”Š  getLineIntersection(line) {\n+-â”Š134â”Š   â”Š    let x1 = line.x1 - this.x;\n+-â”Š135â”Š   â”Š    let x2 = line.x2 - this.x;\n+-â”Š136â”Š   â”Š    let y1 = line.y1 - this.y;\n+-â”Š137â”Š   â”Š    let y2 = line.y2 - this.y;\n+-â”Š138â”Š   â”Š    let dx = x2 - x1;\n+-â”Š139â”Š   â”Š    let dy = y2 - y1;\n+-â”Š140â”Š   â”Š    let d = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\n+-â”Š141â”Š   â”Š    let h = (x1 * y2) - (x2 * y1);\n+-â”Š142â”Š   â”Š    let delta = (Math.pow(this.r, 2) * Math.pow(d, 2)) - Math.pow(h, 2);\n+-â”Š143â”Š   â”Š\n+-â”Š144â”Š   â”Š    if (delta < 0) return;\n+-â”Š145â”Š   â”Š\n+-â”Š146â”Š   â”Š    let interPoints = [\n+-â”Š147â”Š   â”Š      {\n+-â”Š148â”Š   â”Š        x: (((h * dy) + (((dy / Math.abs(dy)) || 1) * dx * Math.sqrt(delta))) / Math.pow(d, 2)) + this.x,\n+-â”Š149â”Š   â”Š        y: (((-h * dx) + (Math.abs(dy) * Math.sqrt(delta))) / Math.pow(d, 2)) + this.y\n+-â”Š150â”Š   â”Š      },\n+-â”Š151â”Š   â”Š      {\n+-â”Š152â”Š   â”Š        x: (((h * dy) - (((dy / Math.abs(dy)) || 1) * dx * Math.sqrt(delta))) / Math.pow(d, 2)) + this.x,\n+-â”Š153â”Š   â”Š        y: (((-h * dx) - (Math.abs(dy) * Math.sqrt(delta))) / Math.pow(d, 2)) + this.y\n+-â”Š154â”Š   â”Š      }\n+-â”Š155â”Š   â”Š    ]\n+-â”Š156â”Š   â”Š    .map(point => ({\n+-â”Š157â”Š   â”Š        x: Utils.trim(point.x, 9),\n+-â”Š158â”Š   â”Š        y: Utils.trim(point.y, 9)\n+-â”Š159â”Š   â”Š    }))\n+-â”Š160â”Š   â”Š    .filter(point => {\n+-â”Š161â”Š   â”Š      return this.hasPoint(point.x, point.y) &&\n+-â”Š162â”Š   â”Š        line.boundsHavePoint(point.x, point.y);\n+-â”Š163â”Š   â”Š    });\n+-â”Š164â”Š   â”Š\n+-â”Š165â”Š   â”Š    interPoints = _.uniq(interPoints, point => `(${point.x}, ${point.y})`);\n+-â”Š166â”Š   â”Š\n+-â”Š167â”Š   â”Š    if (interPoints.length > 0) return interPoints;\n+-â”Š168â”Š   â”Š  }\n+-â”Š169â”Š   â”Š\n+ â”Š170â”Š 16â”Š  // circle - polygon intersection method\n+ â”Š171â”Š 17â”Š  getPolygonIntersection(polygon) {\n+ â”Š172â”Š 18â”Š    return polygon.getCircleIntersection(this);\n+```\n+[}]: #\n+\n+We also need to update the line class to contain a reference to the newly created line-intersection method, so it can be invoked from both a line or a circle bi-directionally:\n+\n+[{]: <helper> (diff_step 7.22)\n+#### Step 7.22: Add line-circle intersection method\n+\n+##### Changed resources/cpp/src/geometry/line.cpp\n+```diff\n+@@ -4,6 +4,7 @@\n+ â”Š 4â”Š 4â”Š#include \"../nullable.h\"\n+ â”Š 5â”Š 5â”Š#include \"../utils.h\"\n+ â”Š 6â”Š 6â”Š#include \"point.h\"\n++â”Š  â”Š 7â”Š#include \"circle.h\"\n+ â”Š 7â”Š 8â”Š#include \"line.h\"\n+ â”Š 8â”Š 9â”Š\n+ â”Š 9â”Š10â”Šnamespace geometry {\n+```\n+```diff\n+@@ -100,6 +101,11 @@\n+ â”Š100â”Š101â”Š    return Nullable<Point>();\n+ â”Š101â”Š102â”Š  }\n+ â”Š102â”Š103â”Š\n++â”Š   â”Š104â”Š  // circle - circle intersection method\n++â”Š   â”Š105â”Š  Nullable<std::vector<Point>> Line::getIntersection(Circle circle) {\n++â”Š   â”Š106â”Š    return circle.getIntersection(*this);\n++â”Š   â”Š107â”Š  }\n++â”Š   â”Š108â”Š\n+ â”Š103â”Š109â”Š  emscripten::val EMLine::getMatchingX(double y) {\n+ â”Š104â”Š110â”Š    Nullable<double> nullableX = Line::getMatchingX(y);\n+ â”Š105â”Š111â”Š    return nullableX.hasValue() ?\n+```\n+```diff\n+@@ -126,6 +132,10 @@\n+ â”Š126â”Š132â”Š    emPoint.set(\"y\", emscripten::val(point.y));\n+ â”Š127â”Š133â”Š    return emPoint;\n+ â”Š128â”Š134â”Š  }\n++â”Š   â”Š135â”Š\n++â”Š   â”Š136â”Š  emscripten::val EMLine::getIntersection(EMCircle emCircle) {\n++â”Š   â”Š137â”Š    return emCircle.getIntersection(*this);\n++â”Š   â”Š138â”Š  }\n+ â”Š129â”Š139â”Š}\n+ â”Š130â”Š140â”Š\n+ â”Š131â”Š141â”ŠEMSCRIPTEN_BINDINGS(geometry_line_module) {\n+```\n+```diff\n+@@ -146,5 +156,10 @@\n+ â”Š146â”Š156â”Š      emscripten::select_overload<emscripten::val(geometry::EMLine)>(\n+ â”Š147â”Š157â”Š        &geometry::EMLine::getIntersection\n+ â”Š148â”Š158â”Š      )\n++â”Š   â”Š159â”Š    )\n++â”Š   â”Š160â”Š    .function(\"getCircleIntersection\",\n++â”Š   â”Š161â”Š      emscripten::select_overload<emscripten::val(geometry::EMCircle)>(\n++â”Š   â”Š162â”Š        &geometry::EMLine::getIntersection\n++â”Š   â”Š163â”Š      )\n+ â”Š149â”Š164â”Š    );\n+ â”Š150â”Š165â”Š}ðŸš«â†µ\n+```\n+\n+##### Changed resources/cpp/src/geometry/line.h\n+```diff\n+@@ -4,6 +4,7 @@\n+ â”Š 4â”Š 4â”Š#include <emscripten/val.h>\n+ â”Š 5â”Š 5â”Š#include \"../nullable.h\"\n+ â”Š 6â”Š 6â”Š#include \"point.h\"\n++â”Š  â”Š 7â”Š#include \"circle.h\"\n+ â”Š 7â”Š 8â”Š\n+ â”Š 8â”Š 9â”Šnamespace geometry {\n+ â”Š 9â”Š10â”Š  class Circle;\n+```\n+```diff\n+@@ -27,6 +28,8 @@\n+ â”Š27â”Š28â”Š    bool boundsHavePoint(double x, double y);\n+ â”Š28â”Š29â”Š\n+ â”Š29â”Š30â”Š    Nullable<Point> getIntersection(Line line);\n++â”Š  â”Š31â”Š\n++â”Š  â”Š32â”Š    Nullable<std::vector<Point>> getIntersection(Circle circle);\n+ â”Š30â”Š33â”Š  };\n+ â”Š31â”Š34â”Š\n+ â”Š32â”Š35â”Š  class EMLine : public Line {\n+```\n+```diff\n+@@ -38,5 +41,7 @@\n+ â”Š38â”Š41â”Š    emscripten::val getMatchingY(double x);\n+ â”Š39â”Š42â”Š\n+ â”Š40â”Š43â”Š    emscripten::val getIntersection(EMLine line);\n++â”Š  â”Š44â”Š\n++â”Š  â”Š45â”Š    emscripten::val getIntersection(EMCircle circle);\n+ â”Š41â”Š46â”Š  };\n+ â”Š42â”Š47â”Š}ðŸš«â†µ\n+```\n+\n+##### Changed resources/scripts/engine/geometry/line.js\n+```diff\n+@@ -14,11 +14,6 @@\n+ â”Š14â”Š14â”Š      return this.getPolygonIntersection(shape);\n+ â”Š15â”Š15â”Š  }\n+ â”Š16â”Š16â”Š\n+-â”Š17â”Š  â”Š  // line - circle intersection method\n+-â”Š18â”Š  â”Š  getCircleIntersection(circle) {\n+-â”Š19â”Š  â”Š    return circle.getLineIntersection(this);\n+-â”Š20â”Š  â”Š  }\n+-â”Š21â”Š  â”Š\n+ â”Š22â”Š17â”Š  // line - polygon intersection method\n+ â”Š23â”Š18â”Š  getPolygonIntersection(polygon) {\n+ â”Š24â”Š19â”Š    return polygon.getLineIntersection(this);\n+```\n+[}]: #\n+\n+Now, before running the tests, be sure to disposed unused circle test-data:\n+\n+[{]: <helper> (diff_step 7.23)\n+#### Step 7.23: Delete circle instances in tests\n+\n+##### Changed resources/scripts/specs/engine/geometry/circle.js\n+```diff\n+@@ -3,6 +3,10 @@\n+ â”Š 3â”Š 3â”Š    this.circle = new Engine.Geometry.Circle(1, 1, 5, 0, 1.5 * Math.PI);\n+ â”Š 4â”Š 4â”Š  });\n+ â”Š 5â”Š 5â”Š\n++â”Š  â”Š 6â”Š  afterEach(function () {\n++â”Š  â”Š 7â”Š    this.circle.delete();\n++â”Š  â”Š 8â”Š  });\n++â”Š  â”Š 9â”Š\n+ â”Š 6â”Š10â”Š  describe(\"getX method\", function() {\n+ â”Š 7â”Š11â”Š    describe(\"given inranged rad\", function() {\n+ â”Š 8â”Š12â”Š      it(\"returns x\", function() {\n+```\n+```diff\n+@@ -64,6 +68,8 @@\n+ â”Š64â”Š68â”Š          { x: -2, y: -3 },\n+ â”Š65â”Š69â”Š          { x: -2, y: 5 }\n+ â”Š66â”Š70â”Š        ]);\n++â”Š  â”Š71â”Š\n++â”Š  â”Š72â”Š        circle.delete();\n+ â”Š67â”Š73â”Š      });\n+ â”Š68â”Š74â”Š    });\n+ â”Š69â”Š75â”Š\n+```\n+```diff\n+@@ -74,6 +80,8 @@\n+ â”Š74â”Š80â”Š        expect(this.circle.getCircleIntersection(circle)).toEqual([\n+ â”Š75â”Š81â”Š          { x: -2, y: 5 }\n+ â”Š76â”Š82â”Š        ]);\n++â”Š  â”Š83â”Š\n++â”Š  â”Š84â”Š        circle.delete();\n+ â”Š77â”Š85â”Š      });\n+ â”Š78â”Š86â”Š    });\n+ â”Š79â”Š87â”Š\n+```\n+```diff\n+@@ -84,6 +92,8 @@\n+ â”Š84â”Š92â”Š        expect(this.circle.getCircleIntersection(circle)).toEqual([\n+ â”Š85â”Š93â”Š          { x: -4, y: 1 }\n+ â”Š86â”Š94â”Š        ]);\n++â”Š  â”Š95â”Š\n++â”Š  â”Š96â”Š        circle.delete();\n+ â”Š87â”Š97â”Š      });\n+ â”Š88â”Š98â”Š    });\n+ â”Š89â”Š99â”Š\n+```\n+```diff\n+@@ -91,6 +101,7 @@\n+ â”Š 91â”Š101â”Š      it(\"returns nothing\", function() {\n+ â”Š 92â”Š102â”Š        let circle = new Engine.Geometry.Circle(10, 10, 2, 0, 2 * Math.PI);\n+ â”Š 93â”Š103â”Š        expect(this.circle.getCircleIntersection(circle)).toBeUndefined();\n++â”Š   â”Š104â”Š        circle.delete();\n+ â”Š 94â”Š105â”Š      });\n+ â”Š 95â”Š106â”Š    });\n+ â”Š 96â”Š107â”Š\n+```\n+```diff\n+@@ -98,6 +109,7 @@\n+ â”Š 98â”Š109â”Š      it(\"nothing\", function() {\n+ â”Š 99â”Š110â”Š        let circle = new Engine.Geometry.Circle(1, 1, 2, 0, 2 * Math.PI);\n+ â”Š100â”Š111â”Š        expect(this.circle.getCircleIntersection(circle)).toBeUndefined();\n++â”Š   â”Š112â”Š        circle.delete();\n+ â”Š101â”Š113â”Š      });\n+ â”Š102â”Š114â”Š    });\n+ â”Š103â”Š115â”Š  });\n+```\n+\n+##### Changed resources/scripts/specs/engine/geometry/polygon.js\n+```diff\n+@@ -64,6 +64,8 @@\n+ â”Š64â”Š64â”Š          { x: 2, y: 0 },\n+ â”Š65â”Š65â”Š          { x: 0, y: 2 }\n+ â”Š66â”Š66â”Š        ]);\n++â”Š  â”Š67â”Š\n++â”Š  â”Š68â”Š        circle.delete();\n+ â”Š67â”Š69â”Š      });\n+ â”Š68â”Š70â”Š    });\n+ â”Š69â”Š71â”Š\n+```\n+```diff\n+@@ -74,6 +76,8 @@\n+ â”Š74â”Š76â”Š        expect(this.polygon.getCircleIntersection(circle)).toEqual([\n+ â”Š75â”Š77â”Š          { x: 2, y: 0 }\n+ â”Š76â”Š78â”Š        ]);\n++â”Š  â”Š79â”Š\n++â”Š  â”Š80â”Š        circle.delete();\n+ â”Š77â”Š81â”Š      });\n+ â”Š78â”Š82â”Š    });\n+ â”Š79â”Š83â”Š\n+```\n+```diff\n+@@ -84,6 +88,8 @@\n+ â”Š84â”Š88â”Š        expect(this.polygon.getCircleIntersection(circle)).toEqual([\n+ â”Š85â”Š89â”Š          { x: 0, y: 3 }\n+ â”Š86â”Š90â”Š        ]);\n++â”Š  â”Š91â”Š\n++â”Š  â”Š92â”Š        circle.delete();\n+ â”Š87â”Š93â”Š      });\n+ â”Š88â”Š94â”Š    });\n+ â”Š89â”Š95â”Š\n+```\n+```diff\n+@@ -91,6 +97,7 @@\n+ â”Š 91â”Š 97â”Š      it(\"returns nothing\", function() {\n+ â”Š 92â”Š 98â”Š        let circle = new Engine.Geometry.Circle(10, 10, 2, 0, 2 * Math.PI);\n+ â”Š 93â”Š 99â”Š        expect(this.polygon.getCircleIntersection(circle)).toBeUndefined();\n++â”Š   â”Š100â”Š        circle.delete();\n+ â”Š 94â”Š101â”Š      });\n+ â”Š 95â”Š102â”Š    });\n+ â”Š 96â”Š103â”Š\n+```\n+```diff\n+@@ -98,6 +105,7 @@\n+ â”Š 98â”Š105â”Š      it(\"nothing\", function() {\n+ â”Š 99â”Š106â”Š        let circle = new Engine.Geometry.Circle(2.5, 2.5, 2, 0, 2 * Math.PI);\n+ â”Š100â”Š107â”Š        expect(this.polygon.getCircleIntersection(circle)).toBeUndefined();\n++â”Š   â”Š108â”Š        circle.delete();\n+ â”Š101â”Š109â”Š      });\n+ â”Š102â”Š110â”Š    });\n+ â”Š103â”Š111â”Š  });\n+```\n+[}]: #\n+\n+Our C++ code should be finished now, and all the tests should be passing. The only thing left to do would be applying it to our game. Like any other application, we first need to reference the script file so it can be loaded, in this case, the C++ bundle script:\n+\n+[{]: <helper> (diff_step 7.24)\n+#### Step 7.24: Load CPP bundle in game\n+\n+##### Changed views/game.html\n+```diff\n+@@ -8,6 +8,7 @@\n+ â”Š 8â”Š 8â”Š    <script type=\"text/javascript\" src=\"/libs/underscore.js\"></script>\n+ â”Š 9â”Š 9â”Š\n+ â”Š10â”Š10â”Š    <!-- Scripts -->\n++â”Š  â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/cpp.bundle.js\"></script>\n+ â”Š11â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/utils.js\"></script>\n+ â”Š12â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n+ â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/geometry/line.js\"></script>\n+```\n+[}]: #\n+\n+And now we need to make sure to dispose the geometry shapes correctly so we won't experience any unnecessary memory leaks. Most of our disposals should go to the snake entity, since it's made out of shapes; So we will add a `delete` method to the snake entity and we will dispose it whenever a match is finished:\n+\n+[{]: <helper> (diff_step 7.25)\n+#### Step 7.25: Delete shape instances in game\n+\n+##### Changed resources/scripts/engine/game.js\n+```diff\n+@@ -95,6 +95,7 @@\n+ â”Š 95â”Š 95â”Š  changeScreen(Screen, ...screenArgs) {\n+ â”Š 96â”Š 96â”Š    // If there is a screen defined, dispose it first\n+ â”Š 97â”Š 97â”Š    if (this.screen) {\n++â”Š   â”Š 98â”Š      this.screen.delete();\n+ â”Š 98â”Š 99â”Š      this.unloadScreen();\n+ â”Š 99â”Š100â”Š      this.screen.disposeEventListeners();\n+ â”Š100â”Š101â”Š    }\n+```\n+\n+##### Changed resources/scripts/engine/layer.js\n+```diff\n+@@ -23,6 +23,9 @@\n+ â”Š23â”Š23â”Š    this.canvas = screen.game.canvas;\n+ â”Š24â”Š24â”Š  }\n+ â”Š25â”Š25â”Š\n++â”Š  â”Š26â”Š  delete() {\n++â”Š  â”Š27â”Š  }\n++â”Š  â”Š28â”Š\n+ â”Š26â”Š29â”Š  update(span) {\n+ â”Š27â”Š30â”Š  }\n+ â”Š28â”Š31â”Š\n+```\n+\n+##### Changed resources/scripts/engine/screen.js\n+```diff\n+@@ -28,6 +28,13 @@\n+ â”Š28â”Š28â”Š    return this;\n+ â”Š29â”Š29â”Š  }\n+ â”Š30â”Š30â”Š\n++â”Š  â”Š31â”Š   // Delete all layers. Same as 'unload', only it disposes memory rather than assets\n++â”Š  â”Š32â”Š  delete() {\n++â”Š  â”Š33â”Š    this.layers.forEach(layer => {\n++â”Š  â”Š34â”Š      layer.delete();\n++â”Š  â”Š35â”Š    });\n++â”Š  â”Š36â”Š  }\n++â”Š  â”Š37â”Š\n+ â”Š31â”Š38â”Š  // Updates each layer\n+ â”Š32â”Š39â”Š  update(span) {\n+ â”Š33â”Š40â”Š    this.layers.forEach(layer => {\n+```\n+```diff\n+@@ -61,6 +68,7 @@\n+ â”Š61â”Š68â”Š  removeLayer(layer) {\n+ â”Š62â”Š69â”Š    this.layers = _.without(this.layers, layer);\n+ â”Š63â”Š70â”Š    layer.disposeEventListeners();\n++â”Š  â”Š71â”Š    layer.delete();\n+ â”Š64â”Š72â”Š  }\n+ â”Š65â”Š73â”Š\n+ â”Š66â”Š74â”Š  initEventListeners() {\n+```\n+\n+##### Changed resources/scripts/game/entities/snake.js\n+```diff\n+@@ -31,6 +31,10 @@\n+ â”Š31â”Š31â”Š    }\n+ â”Š32â”Š32â”Š  }\n+ â”Š33â”Š33â”Š\n++â”Š  â”Š34â”Š  delete() {\n++â”Š  â”Š35â”Š    this.shapes.forEach(shape => shape.delete());\n++â”Š  â”Š36â”Š  }\n++â”Š  â”Š37â”Š\n+ â”Š34â”Š38â”Š  draw(context) {\n+ â”Š35â”Š39â”Š    // Draw all shapes in the shapes array\n+ â”Š36â”Š40â”Š    this.shapes.forEach(shape => {\n+```\n+```diff\n+@@ -229,6 +233,8 @@\n+ â”Š229â”Š233â”Š      [0, height, 0, 0]\n+ â”Š230â”Š234â”Š    );\n+ â”Š231â”Š235â”Š\n+-â”Š232â”Š   â”Š    return canvasPolygon.getIntersection(this.lastBit);\n++â”Š   â”Š236â”Š    let result = canvasPolygon.getIntersection(this.lastBit);\n++â”Š   â”Š237â”Š    canvasPolygon.delete();\n++â”Š   â”Š238â”Š    return result;\n+ â”Š233â”Š239â”Š  }\n+ â”Š234â”Š240â”Š};ðŸš«â†µ\n+```\n+\n+##### Changed resources/scripts/game/screens/play/snake.js\n+```diff\n+@@ -43,6 +43,10 @@\n+ â”Š43â”Š43â”Š    screen.appendLayer(Game.Screens.Play.Score, this.snakes);\n+ â”Š44â”Š44â”Š  }\n+ â”Š45â”Š45â”Š\n++â”Š  â”Š46â”Š  unload() {\n++â”Š  â”Š47â”Š    this.snakes.forEach(snake => snake.delete());\n++â”Š  â”Š48â”Š  }\n++â”Š  â”Š49â”Š\n+ â”Š46â”Š50â”Š  draw(context) {\n+ â”Š47â”Š51â”Š    // Draw each snake in the snakes array\n+ â”Š48â”Š52â”Š    this.snakes.forEach(snake => snake.draw(context));\n+```\n+[}]: #\n+\n+Congratulations! You've created a C++ cross JavaScript game. There shouldn't be any significant difference between the C++ version of the game and the JavaScript version on most machines, since the game is very small and barely requires any processing power. You'll probably notice the difference when starting to extend the game by adding terrains or more snakes.\n+\n+One might ask - \"How much faster does my game actually run?\". The short answer is - around 50%. Why did I run into this conclusion? Well, take a look at the following JavaScript code snippet, for calculating Fibonacci of 42:\n+\n+```js\n+function fib(x) {\n+  if (x < 2) {\n+    return 1;\n+  }\n+  else {\n+    return fib(x - 1) + fib(x - 2);\n+  }\n+}\n+```\n+\n+The same code snippet should look almost identical written in C++:\n+\n+```cpp\n+int fib(int x) {\n+  if (x < 2) {\n+    return 1;\n+  }\n+  else {\n+    return fib(x - 1) + fib(x - 2);\n+  }\n+}\n+```\n+\n+However, the run-times are completely different! I compared the average of 10 runs in 3 different environments, and I received the following results:\n+\n+![chart](https://cloud.githubusercontent.com/assets/7648874/22802494/2591025e-eef8-11e6-9679-10b5bca0ef30.png)\n+\n+As you can see, the generated C++ is much faster, and to be precise, 57% faster! Surprisingly, I didn't have any significant difference between Emscripten generated C++ and natively compiled executable.\n+\n+C++ is more complex to write, but it certainly has its advantages over JavaScript. Remember, now that you know that you have the possibility to run C++ in the browser, make sure to use it, but never overdo it, always find the right balance between readability and performance.\n+\n+> *Sources:*\n+> - *https://kripken.github.io/emscripten-site/docs/introducing_emscripten/index.html*\n+> - *http://www.crunchy.com/?q=content/emscripten-perfectly-cromulent-compiler*\n+> - *http://stackoverflow.com/questions/2354725/what-exactly-is-llvm*\n \n-Oops! It looks that this step is not yet implemented. Stay tuned for upcoming updates.\n [}]: #\n [{]: <region> (footer)\n [{]: <helper> (nav_step)\ndiff --git a/package.json b/package.json\nindex 49b6e54..8b27d5a 100644\n--- a/package.json\n+++ b/package.json\n@@ -3,8 +3,10 @@\n   \"description\": \"A tutorial for creating a Tron-style game\",\n   \"private\": true,\n   \"scripts\": {\n-    \"serve\": \"npm run parse:fonts && nodemon server.js\",\n-    \"parse:fonts\": \"node helpers/font_parser.js\"\n+    \"serve\": \"npm run build && nodemon server.js\",\n+    \"build\": \"npm run build:fonts && npm run build:cpp\",\n+    \"build:fonts\": \"node helpers/font_parser.js\",\n+    \"build:cpp\": \"emcc -O1 --pre-js resources/cpp/pre.js --post-js resources/cpp/post.js --bind -o resources/scripts/cpp.bundle.js resources/cpp/src/index.cpp\"\n   },\n   \"dependencies\": {\n     \"async\": \"^2.1.4\",\ndiff --git a/resources/cpp/post.js b/resources/cpp/post.js\nnew file mode 100644\nindex 0000000..e13254b\n--- /dev/null\n+++ b/resources/cpp/post.js\n@@ -0,0 +1,15 @@\n+return {\n+  Utils: {\n+    mod: Module.utils_mod,\n+    trim: Module.utils_trim,\n+    isBetween: Module.utils_isBetween,\n+    compare: Module.utils_compare\n+  },\n+\n+  Geometry: {\n+    Line: Module.geometry_line,\n+    Circle: Module.geometry_circle\n+  }\n+};\n+\n+})();\n\\ No newline at end of file\ndiff --git a/resources/cpp/pre.js b/resources/cpp/pre.js\nnew file mode 100644\nindex 0000000..cfc57f4\n--- /dev/null\n+++ b/resources/cpp/pre.js\n@@ -0,0 +1 @@\n+CPP = (function() {\n\\ No newline at end of file\ndiff --git a/resources/cpp/src/geometry/circle.cpp b/resources/cpp/src/geometry/circle.cpp\nnew file mode 100644\nindex 0000000..4026f6a\n--- /dev/null\n+++ b/resources/cpp/src/geometry/circle.cpp\n@@ -0,0 +1,306 @@\n+#include <algorithm>\n+#include <cmath>\n+#include <vector>\n+#include <emscripten/bind.h>\n+#include <emscripten/val.h>\n+#include \"../nullable.h\"\n+#include \"../utils.h\"\n+#include \"point.h\"\n+#include \"line.h\"\n+\n+namespace geometry {\n+  // x - The x value of the circle's center\n+  // y - The y value of the circle's center\n+  // r - The radius of the center\n+  // rad1 - The first radian of the circle, not necessarily its beginning\n+  // rad2 - The second radian of the circle, not necessarily its beginning\n+  Circle::Circle(double x, double y, double r, double rad1, double rad2) {\n+    _x = utils::trim(x, 9);\n+    _y = utils::trim(y, 9);\n+    _r = utils::trim(r, 9);\n+\n+    // Trimming mode is done based on which radian represents the ending and which radian\n+    // represents the ending\n+    if (rad1 > rad2) {\n+      _rad1 = utils::trim(rad1, 9, \"floor\");\n+      _rad2 = utils::trim(rad2, 9, \"ceil\");\n+    }\n+    else {\n+      _rad1 = utils::trim(rad1, 9, \"ceil\");\n+      _rad2 = utils::trim(rad2, 9, \"floor\");\n+    }\n+  }\n+\n+  // Gets the matching x value for the given radian\n+  Nullable<double> Circle::getMatchingX(double rad) {\n+    if (!utils::chain(rad)->trim(9)->isBetween(_rad1, _rad2)->result()) {\n+      return Nullable<double>();\n+    }\n+\n+    return Nullable<double>(utils::trim((_r * std::cos(rad)) + _x, 9));\n+  }\n+\n+  // Gets the matching y value for the given radian\n+  Nullable<double> Circle::getMatchingY(double rad) {\n+    if (!utils::chain(rad)->trim(9)->isBetween(_rad1, _rad2)->result()) {\n+      return Nullable<double>();\n+    }\n+\n+    return Nullable<double>(utils::trim((_r * std::sin(rad)) + _y, 9));\n+  }\n+\n+  // Gets the matching point for the given radian\n+  Nullable<Point> Circle::getMatchingPoint(double rad) {\n+    if (!utils::isBetween(rad, _rad1, _rad2)) {\n+      return Nullable<Point>();\n+    }\n+\n+    return Nullable<Point>({\n+      utils::trim((_r * std::cos(rad)) + _x, 9),\n+      utils::trim((_r * std::sin(rad)) + _y, 9)\n+    });\n+  }\n+\n+  // Gets the matching radian for the given point\n+  Nullable<double> Circle::getMatchingRad(double x, double y) {\n+    double rad = std::atan2(y - _y, x - _x);\n+\n+    // If calculated radian is in circle's radian range, return it\n+    if (!std::isnan(rad) && utils::isBetween(rad, _rad1, _rad2)) {\n+      return Nullable<double>(rad);\n+    }\n+\n+    // The calculated radian can still be in the circle's radian range in case one\n+    // of the radians is greater than 2 PIEs\n+    double greatestRad = std::abs(_rad1) > std::abs(_rad2) ? _rad1 : _rad2;\n+\n+    // Check if the absolute radian is in the circle's radian range\n+    if (utils::chain(rad + (2 * M_PI * std::floor(greatestRad / (2 * M_PI))))\n+        ->trim(9)->isBetween(_rad1, _rad2)->result() ||\n+        utils::chain(rad + (2 * M_PI * std::ceil(greatestRad / (2 * M_PI))))\n+        ->trim(9)->isBetween(_rad1, _rad2)->result()) {\n+      return Nullable<double>(rad);\n+    }\n+\n+    return Nullable<double>();\n+  }\n+\n+  // Returns if circle has given points\n+  bool Circle::hasPoint(double x, double y) {\n+    return getMatchingRad(x, y).hasValue();\n+  }\n+\n+  // circle - circle intersection method\n+  Nullable<std::vector<Point>> Circle::getIntersection(Circle circle) {\n+    double dx = circle._x - _x;\n+    double dy = circle._y - _y;\n+    double d = std::sqrt(std::pow(dx, 2) + std::pow(dy, 2));\n+\n+    if (d > _r + circle._r ||\n+       d < std::abs(_r - circle._r)) {\n+      return Nullable<std::vector<Point>>();\n+    }\n+\n+    double a = ((std::pow(_r, 2) - std::pow(circle._r, 2)) + std::pow(d, 2)) / (2 * d);\n+    double x = _x + ((dx * a) / d);\n+    double y = _y + ((dy * a) / d);\n+    double h = std::sqrt(std::pow(_r, 2) - std::pow(a, 2));\n+    double rx = (- dy * h) / d;\n+    double ry = (dx * h) / d;\n+\n+    std::vector<Point> interPoints(2);\n+    interPoints.at(0).x = x + rx;\n+    interPoints.at(0).y = y + ry;\n+    interPoints.at(1).x = x - rx;\n+    interPoints.at(1).y = y - ry;\n+\n+    for (unsigned i = 0; i < interPoints.size(); i++) {\n+      Point& point = interPoints.at(i);\n+      point.x = utils::trim(point.x, 9);\n+      point.y = utils::trim(point.y, 9);\n+    }\n+\n+    auto pointsBegin = std::unique(interPoints.begin(), interPoints.end(),\n+      [](Point pointA, Point pointB) {\n+        return pointA.x == pointB.x && pointA.y == pointB.y;\n+      }\n+    );\n+\n+    interPoints.erase(pointsBegin, interPoints.end());\n+\n+    std::vector<Circle> circles = { *this, circle };\n+\n+    std::for_each(circles.begin(), circles.end(), [&interPoints](Circle circle) {\n+      auto pointsBegin = std::remove_if(interPoints.begin(), interPoints.end(),\n+        [&circle](Point point) {\n+          return !circle.hasPoint(point.x, point.y);\n+        }\n+      );\n+\n+      interPoints.erase(pointsBegin, interPoints.end());\n+    });\n+\n+    if (interPoints.size()) {\n+      return Nullable<std::vector<Point>>(interPoints);\n+    }\n+\n+    return Nullable<std::vector<Point>>();\n+  }\n+\n+  // circle - line intersection method\n+  Nullable<std::vector<Point>> Circle::getIntersection(Line line) {\n+    double x1 = line._x1 - _x;\n+    double x2 = line._x2 - _x;\n+    double y1 = line._y1 - _y;\n+    double y2 = line._y2 - _y;\n+    double dx = x2 - x1;\n+    double dy = y2 - y1;\n+    double d = std::sqrt(std::pow(dx, 2) + std::pow(dy, 2));\n+    double h = (x1 * y2) - (x2 * y1);\n+    double delta = (std::pow(_r, 2) * std::pow(d, 2)) - std::pow(h, 2);\n+\n+    if (delta < 0) Nullable<std::vector<Point>>();\n+\n+    double sign = dy / std::abs(dy); if (std::isnan(sign)) sign = 1;\n+    double sqrtx = sign * dx * std::sqrt(delta);\n+    double sqrty = std::abs(dy) * std::sqrt(delta);\n+\n+    std::vector<Point> interPoints(2);\n+    interPoints.at(0).x = (((h * dy) + sqrtx) / std::pow(d, 2)) + _x;\n+    interPoints.at(0).y = (((-h * dx) + sqrty) / std::pow(d, 2)) + _y;\n+    interPoints.at(1).x = (((h * dy) - sqrtx) / std::pow(d, 2)) + _x;\n+    interPoints.at(1).y = (((-h * dx) - sqrty) / std::pow(d, 2)) + _y;\n+\n+    for (unsigned i = 0; i < interPoints.size(); i++) {\n+      Point& point = interPoints.at(i);\n+      point.x = utils::trim(point.x, 9);\n+      point.y = utils::trim(point.y, 9);\n+    }\n+\n+    auto pointsBegin = std::remove_if(interPoints.begin(), interPoints.end(),\n+      [this, &line](Point point) {\n+        return !hasPoint(point.x, point.y) ||\n+          !line.boundsHavePoint(point.x, point.y);\n+      }\n+    );\n+\n+    interPoints.erase(pointsBegin, interPoints.end());\n+\n+    pointsBegin = std::unique(interPoints.begin(), interPoints.end(),\n+      [](Point pointA, Point pointB) {\n+        return pointA.x == pointB.x && pointA.y == pointB.y;\n+      }\n+    );\n+\n+    interPoints.erase(pointsBegin, interPoints.end());\n+\n+    if (interPoints.size()) {\n+      return Nullable<std::vector<Point>>(interPoints);\n+    }\n+\n+    return Nullable<std::vector<Point>>();\n+  }\n+\n+  emscripten::val EMCircle::getMatchingX(double y) {\n+    Nullable<double> nullableX = Circle::getMatchingX(y);\n+    return nullableX.hasValue() ?\n+      emscripten::val(nullableX.getValue()) :\n+      emscripten::val::undefined();\n+  }\n+\n+  emscripten::val EMCircle::getMatchingY(double x) {\n+    Nullable<double> nullableY = Circle::getMatchingY(x);\n+    return nullableY.hasValue() ?\n+      emscripten::val(nullableY.getValue()) :\n+      emscripten::val::undefined();\n+  }\n+\n+  emscripten::val EMCircle::getMatchingPoint(double rad) {\n+    Nullable<Point> nullablePoint = Circle::getMatchingPoint(rad);\n+\n+    if (nullablePoint.isNull()) return emscripten::val::undefined();\n+\n+    Point point = nullablePoint.getValue();\n+    emscripten::val emPoint = emscripten::val::object();\n+    emPoint.set(\"x\", emscripten::val(point.x));\n+    emPoint.set(\"y\", emscripten::val(point.y));\n+    return emPoint;\n+  }\n+\n+  emscripten::val EMCircle::getMatchingRad(double x, double y) {\n+    Nullable<double> nullableRad = Circle::getMatchingRad(x, y);\n+    return nullableRad.hasValue() ?\n+      emscripten::val(nullableRad.getValue()) :\n+      emscripten::val::undefined();\n+  }\n+\n+  emscripten::val EMCircle::getIntersection(EMLine emLine) {\n+    Line line = Line(emLine._x1, emLine._y1, emLine._x2, emLine._y2);\n+    Nullable<std::vector<Point>> nullablePoints = Circle::getIntersection(line);\n+\n+    if (nullablePoints.isNull()) return emscripten::val::undefined();\n+\n+    std::vector<Point> points = nullablePoints.getValue();\n+    emscripten::val emPoints = emscripten::val::array();\n+\n+    for (unsigned i = 0; i < points.size(); i++) {\n+      Point point = points.at(i);\n+      emscripten::val emPoint = emscripten::val::object();\n+      emPoint.set(\"x\", emscripten::val(point.x));\n+      emPoint.set(\"y\", emscripten::val(point.y));\n+      emPoints.set(i, emPoint);\n+    }\n+\n+    return emPoints;\n+  }\n+\n+  emscripten::val EMCircle::getIntersection(EMCircle emCircle) {\n+    Circle circle = Circle(\n+      emCircle._x, emCircle._y, emCircle._r, emCircle._rad1, emCircle._rad2\n+    );\n+    Nullable<std::vector<Point>> nullablePoints = Circle::getIntersection(circle);\n+\n+    if (nullablePoints.isNull()) return emscripten::val::undefined();\n+\n+    std::vector<Point> points = nullablePoints.getValue();\n+    emscripten::val emPoints = emscripten::val::array();\n+\n+    for (unsigned i = 0; i < points.size(); i++) {\n+      Point point = points.at(i);\n+      emscripten::val emPoint = emscripten::val::object();\n+      emPoint.set(\"x\", emscripten::val(point.x));\n+      emPoint.set(\"y\", emscripten::val(point.y));\n+      emPoints.set(i, emPoint);\n+    }\n+\n+    return emPoints;\n+  }\n+}\n+\n+EMSCRIPTEN_BINDINGS(geometry_circle_module) {\n+  emscripten::class_<geometry::Circle>(\"geometry_circle_base\")\n+    .constructor<double, double, double, double, double>()\n+    .property<double>(\"x\", &geometry::Circle::_x)\n+    .property<double>(\"y\", &geometry::Circle::_y)\n+    .property<double>(\"r\", &geometry::Circle::_r)\n+    .property<double>(\"rad1\", &geometry::Circle::_rad1)\n+    .property<double>(\"rad2\", &geometry::Circle::_rad2)\n+    .function(\"hasPoint\", &geometry::Circle::hasPoint);\n+\n+  emscripten::class_<geometry::EMCircle, emscripten::base<geometry::Circle>>(\"geometry_circle\")\n+    .constructor<double, double, double, double, double>()\n+    .function(\"getX\", &geometry::EMCircle::getMatchingX)\n+    .function(\"getY\", &geometry::EMCircle::getMatchingY)\n+    .function(\"getPoint\", &geometry::EMCircle::getMatchingPoint)\n+    .function(\"getRad\", &geometry::EMCircle::getMatchingRad)\n+    .function(\"getLineIntersection\",\n+      emscripten::select_overload<emscripten::val(geometry::EMLine)>(\n+        &geometry::EMCircle::getIntersection\n+      )\n+    )\n+    .function(\"getCircleIntersection\",\n+      emscripten::select_overload<emscripten::val(geometry::EMCircle)>(\n+        &geometry::EMCircle::getIntersection\n+      )\n+    );\n+}\n\\ No newline at end of file\ndiff --git a/resources/cpp/src/geometry/circle.h b/resources/cpp/src/geometry/circle.h\nnew file mode 100644\nindex 0000000..54cd0f4\n--- /dev/null\n+++ b/resources/cpp/src/geometry/circle.h\n@@ -0,0 +1,54 @@\n+#pragma once\n+\n+#include <vector>\n+#include <emscripten/val.h>\n+#include \"../nullable.h\"\n+#include \"point.h\"\n+#include \"line.h\"\n+\n+namespace geometry {\n+  class Line;\n+  class EMLine;\n+\n+  class Circle {\n+  public:\n+    double _x;\n+    double _y;\n+    double _r;\n+    double _rad1;\n+    double _rad2;\n+\n+    Circle(double x, double y, double r, double rad1, double rad2);\n+\n+    Nullable<double> getMatchingX(double rad);\n+\n+    Nullable<double> getMatchingY(double rad);\n+\n+    Nullable<Point> getMatchingPoint(double rad);\n+\n+    Nullable<double> getMatchingRad(double x, double y);\n+\n+    bool hasPoint(double x, double y);\n+\n+    Nullable<std::vector<Point>> getIntersection(Circle circle);\n+\n+    Nullable<std::vector<Point>> getIntersection(Line line);\n+  };\n+\n+  class EMCircle : public Circle {\n+  public:\n+    using Circle::Circle;\n+\n+    emscripten::val getMatchingX(double y);\n+\n+    emscripten::val getMatchingY(double x);\n+\n+    emscripten::val getMatchingPoint(double rad);\n+\n+    emscripten::val getMatchingRad(double x, double y);\n+\n+    emscripten::val getIntersection(EMLine line);\n+\n+    emscripten::val getIntersection(EMCircle circle);\n+  };\n+}\n\\ No newline at end of file\ndiff --git a/resources/cpp/src/geometry/line.cpp b/resources/cpp/src/geometry/line.cpp\nnew file mode 100644\nindex 0000000..0bf328f\n--- /dev/null\n+++ b/resources/cpp/src/geometry/line.cpp\n@@ -0,0 +1,165 @@\n+#include <vector>\n+#include <emscripten/bind.h>\n+#include <emscripten/val.h>\n+#include \"../nullable.h\"\n+#include \"../utils.h\"\n+#include \"point.h\"\n+#include \"circle.h\"\n+#include \"line.h\"\n+\n+namespace geometry {\n+  // x1 - The first point's x value\n+  // y1 - The first point's y value\n+  // x1 - The second point's x value\n+  // y2 - The second point's y value\n+  Line::Line(double x1, double y1, double x2, double y2) {\n+    _x1 = utils::trim(x1, 9);\n+    _y1 = utils::trim(y1, 9);\n+    _x2 = utils::trim(x2, 9);\n+    _y2 = utils::trim(y2, 9);\n+  }\n+\n+  // Gets the matching x value for a given y value\n+  Nullable<double> Line::getMatchingX(double y) {\n+    // If an error was thrown it means we divided a number by zero,\n+    // in which case there is not intersection point\n+    double x = utils::trim(\n+      (((y - _y1) * (_x2 - _x1)) /\n+       (_y2 - _y1)) + _x1\n+    , 9, \"exact\");\n+\n+    // Check if result is in values range\n+    if (utils::isBetween(x, _x1, _x2, \"round\")) {\n+      return Nullable<double>(x);\n+    }\n+\n+    return Nullable<double>();\n+  }\n+\n+  // Gets the matching y value for a given x value\n+  Nullable<double> Line::getMatchingY(double x) {\n+    // If an error was thrown it means we divided a number by zero,\n+    // in which case there is not intersection point\n+    double y = utils::trim(\n+      (((x - _x1) * (_y2 - _y1)) /\n+       (_x2 - _x1)) + _y1\n+    , 9, \"exact\");\n+\n+    // Check if result is in values range\n+    if (utils::isBetween(y, _y1, _y2, \"round\")) {\n+      return Nullable<double>(y);\n+    }\n+\n+    return Nullable<double>();\n+  }\n+\n+  // Returns if line has given point\n+  bool Line::hasPoint(double x, double y) {\n+    if (!boundsHavePoint(x, y)) return 0;\n+\n+    double m = utils::trim(\n+      (_y2 - _y1) / (_x2 - _x1),\n+    9, \"exact\");\n+\n+    return (y - _y1) / (x - _x1) == m;\n+  }\n+\n+  // Returns if given point is contained by the bounds aka cage of line\n+  bool Line::boundsHavePoint(double x, double y) {\n+    return utils::isBetween(x, _x1, _x2, \"round\") &&\n+           utils::isBetween(y, _y1, _y2, \"round\");\n+  }\n+\n+  // line - line intersection method\n+  Nullable<Point> Line::getIntersection(Line line) {\n+    // Escape if lines are parallel\n+    if (!(((_x1 - _x2) * (line._y1 - line._y2)) -\n+          ((_y1 - _y2) * (line._x1 - line._x2))))\n+      return Nullable<Point>();\n+\n+    // Intersection point formula\n+    double x = utils::trim(\n+      ((((_x1 * _y2) - (_y1 * _x2)) * (line._x1 - line._x2)) -\n+       ((_x1 - _x2) * ((line._x1 * line._y2) - (line._y1 * line._x2)))) /\n+      (((_x1 - _x2) * (line._y1 - line._y2)) - ((_y1 - _y2) *\n+        (line._x1 - line._x2)))\n+    , 9, \"exact\");\n+    double y = utils::trim(\n+      ((((_x1 * _y2) - (_y1 * _x2)) * (line._y1 - line._y2)) -\n+       ((_y1 - _y2) * ((line._x1 * line._y2) - (line._y1 * line._x2)))) /\n+      (((_x1 - _x2) * (line._y1 - line._y2)) - ((_y1 - _y2) *\n+        (line._x1 - line._x2)))\n+    , 9, \"exact\");\n+\n+    if (utils::isBetween(x, _x1, _x2, \"round\") &&\n+        utils::isBetween(x, line._x1, line._x2, \"round\") &&\n+        utils::isBetween(y, _y1, _y2, \"round\") &&\n+        utils::isBetween(y, line._y1, line._y2, \"round\")) {\n+      return Nullable<Point>({ x, y });\n+    }\n+\n+    return Nullable<Point>();\n+  }\n+\n+  // circle - circle intersection method\n+  Nullable<std::vector<Point>> Line::getIntersection(Circle circle) {\n+    return circle.getIntersection(*this);\n+  }\n+\n+  emscripten::val EMLine::getMatchingX(double y) {\n+    Nullable<double> nullableX = Line::getMatchingX(y);\n+    return nullableX.hasValue() ?\n+      emscripten::val(nullableX.getValue()) :\n+      emscripten::val::undefined();\n+  }\n+\n+  emscripten::val EMLine::getMatchingY(double x) {\n+    Nullable<double> nullableY = Line::getMatchingY(x);\n+    return nullableY.hasValue() ?\n+      emscripten::val(nullableY.getValue()) :\n+      emscripten::val::undefined();\n+  }\n+\n+  emscripten::val EMLine::getIntersection(EMLine emLine) {\n+    Line line = Line(emLine._x1, emLine._y1, emLine._x2, emLine._y2);\n+    Nullable<Point> nullablePoint = Line::getIntersection(line);\n+\n+    if (nullablePoint.isNull()) return emscripten::val::undefined();\n+\n+    Point point = nullablePoint.getValue();\n+    emscripten::val emPoint = emscripten::val::object();\n+    emPoint.set(\"x\", emscripten::val(point.x));\n+    emPoint.set(\"y\", emscripten::val(point.y));\n+    return emPoint;\n+  }\n+\n+  emscripten::val EMLine::getIntersection(EMCircle emCircle) {\n+    return emCircle.getIntersection(*this);\n+  }\n+}\n+\n+EMSCRIPTEN_BINDINGS(geometry_line_module) {\n+  emscripten::class_<geometry::Line>(\"geometry_line_base\")\n+    .constructor<double, double, double, double>()\n+    .property<double>(\"x1\", &geometry::Line::_x1)\n+    .property<double>(\"y1\", &geometry::Line::_y1)\n+    .property<double>(\"x2\", &geometry::Line::_x2)\n+    .property<double>(\"y2\", &geometry::Line::_y2)\n+    .function(\"hasPoint\", &geometry::Line::hasPoint)\n+    .function(\"boundsHavePoint\", &geometry::Line::boundsHavePoint);\n+\n+  emscripten::class_<geometry::EMLine, emscripten::base<geometry::Line>>(\"geometry_line\")\n+    .constructor<double, double, double, double>()\n+    .function(\"getX\", &geometry::EMLine::getMatchingX)\n+    .function(\"getY\", &geometry::EMLine::getMatchingY)\n+    .function(\"getLineIntersection\",\n+      emscripten::select_overload<emscripten::val(geometry::EMLine)>(\n+        &geometry::EMLine::getIntersection\n+      )\n+    )\n+    .function(\"getCircleIntersection\",\n+      emscripten::select_overload<emscripten::val(geometry::EMCircle)>(\n+        &geometry::EMLine::getIntersection\n+      )\n+    );\n+}\n\\ No newline at end of file\ndiff --git a/resources/cpp/src/geometry/line.h b/resources/cpp/src/geometry/line.h\nnew file mode 100644\nindex 0000000..605f070\n--- /dev/null\n+++ b/resources/cpp/src/geometry/line.h\n@@ -0,0 +1,47 @@\n+#pragma once\n+\n+#include <vector>\n+#include <emscripten/val.h>\n+#include \"../nullable.h\"\n+#include \"point.h\"\n+#include \"circle.h\"\n+\n+namespace geometry {\n+  class Circle;\n+  class EMCircle;\n+\n+  class Line {\n+  public:\n+    double _x1;\n+    double _y1;\n+    double _x2;\n+    double _y2;\n+\n+    Line(double x1, double y1, double x2, double y2);\n+\n+    Nullable<double> getMatchingX(double y);\n+\n+    Nullable<double> getMatchingY(double x);\n+\n+    bool hasPoint(double x, double y);\n+\n+    bool boundsHavePoint(double x, double y);\n+\n+    Nullable<Point> getIntersection(Line line);\n+\n+    Nullable<std::vector<Point>> getIntersection(Circle circle);\n+  };\n+\n+  class EMLine : public Line {\n+  public:\n+    using Line::Line;\n+\n+    emscripten::val getMatchingX(double y);\n+\n+    emscripten::val getMatchingY(double x);\n+\n+    emscripten::val getIntersection(EMLine line);\n+\n+    emscripten::val getIntersection(EMCircle circle);\n+  };\n+}\n\\ No newline at end of file\ndiff --git a/resources/cpp/src/geometry/point.h b/resources/cpp/src/geometry/point.h\nnew file mode 100644\nindex 0000000..3b9ae08\n--- /dev/null\n+++ b/resources/cpp/src/geometry/point.h\n@@ -0,0 +1,8 @@\n+#pragma once\n+\n+namespace geometry {\n+  struct Point {\n+    double x;\n+    double y;\n+  };\n+}\n\\ No newline at end of file\ndiff --git a/resources/cpp/src/index.cpp b/resources/cpp/src/index.cpp\nnew file mode 100644\nindex 0000000..1d0cdb8\n--- /dev/null\n+++ b/resources/cpp/src/index.cpp\n@@ -0,0 +1,4 @@\n+#include \"nullable.cpp\"\n+#include \"utils.cpp\"\n+#include \"geometry/line.cpp\"\n+#include \"geometry/circle.cpp\"\n\\ No newline at end of file\ndiff --git a/resources/cpp/src/nullable.cpp b/resources/cpp/src/nullable.cpp\nnew file mode 100644\nindex 0000000..63db015\n--- /dev/null\n+++ b/resources/cpp/src/nullable.cpp\n@@ -0,0 +1,37 @@\n+#include \"nullable.h\"\n+\n+template <typename T>\n+Nullable<T>::Nullable(T value): _value(value), _initialized(true) {\n+\n+}\n+\n+template <typename T>\n+Nullable<T>::Nullable(): _initialized(false) {\n+\n+}\n+\n+template <typename T>\n+T Nullable<T>::getValue() const {\n+  return _value;\n+}\n+\n+template <typename T>\n+void Nullable<T>::setValue(T value) {\n+  _value = value;\n+  _initialized = true;\n+}\n+\n+template <typename T>\n+void Nullable<T>::resetValue() {\n+  _initialized = false;\n+}\n+\n+template <typename T>\n+bool Nullable<T>::hasValue() const {\n+  return _initialized == true;\n+}\n+\n+template <typename T>\n+bool Nullable<T>::isNull() const {\n+  return _initialized == false;\n+}\n\\ No newline at end of file\ndiff --git a/resources/cpp/src/nullable.h b/resources/cpp/src/nullable.h\nnew file mode 100644\nindex 0000000..329fa3c\n--- /dev/null\n+++ b/resources/cpp/src/nullable.h\n@@ -0,0 +1,23 @@\n+#pragma once\n+\n+template <typename T>\n+class Nullable {\n+private:\n+  T _value;\n+  bool _initialized;\n+\n+public:\n+  Nullable(T value);\n+\n+  Nullable();\n+\n+  T getValue() const;\n+\n+  void setValue(T value);\n+\n+  void resetValue();\n+\n+  bool hasValue() const;\n+\n+  bool isNull() const;\n+};\n\\ No newline at end of file\ndiff --git a/resources/cpp/src/utils.cpp b/resources/cpp/src/utils.cpp\nnew file mode 100644\nindex 0000000..9c30cc7\n--- /dev/null\n+++ b/resources/cpp/src/utils.cpp\n@@ -0,0 +1,140 @@\n+#include <cfloat>\n+#include <cmath>\n+#include <string>\n+#include <emscripten/bind.h>\n+#include \"utils.h\"\n+\n+namespace utils {\n+  template<typename T>\n+  Chain<T>::Chain(T accumulator): _accumulator(accumulator) {\n+  }\n+\n+  template<>\n+  Chain<double>* Chain<double>::mod(double num) {\n+    double result = utils::mod(_accumulator, num);\n+    Chain<double>* chain = new Chain<double>(result);\n+    delete this;\n+    return chain;\n+  }\n+\n+  template<>\n+  Chain<double>* Chain<double>::trim(int decimals, const std::string mode) {\n+    double result = utils::trim(_accumulator, decimals, mode);\n+    Chain<double>* chain = new Chain<double>(result);\n+    delete this;\n+    return chain;\n+  }\n+\n+  template<>\n+  Chain<bool>* Chain<double>::isBetween(double num1, double num2, const std::string precision) {\n+    bool result = utils::isBetween(_accumulator, num1, num2, precision);\n+    Chain<bool>* chain = new Chain<bool>(result);\n+    delete this;\n+    return chain;\n+  }\n+\n+  template<>\n+  Chain<bool>* Chain<double>::compare(double num, const std::string precision) {\n+    bool result = utils::compare(_accumulator, num, precision);\n+    Chain<bool>* chain = new Chain<bool>(result);\n+    delete this;\n+    return chain;\n+  }\n+\n+  template<>\n+  Chain<bool>* Chain<double>::compare(double num, const std::string method, const std::string precision) {\n+    bool result = utils::compare(_accumulator, num, method, precision);\n+    Chain<bool>* chain = new Chain<bool>(result);\n+    delete this;\n+    return chain;\n+  }\n+\n+  template<typename T>\n+  T Chain<T>::result() {\n+    delete this;\n+    return _accumulator;\n+  }\n+\n+  template<typename T>\n+  Chain<T>* chain(T accumulator) {\n+    return new Chain<T>(accumulator);\n+  }\n+\n+  // Fixed modulo method which can calculate modulo of negative numbers properly\n+  // e.g. (-803).mod(800) returns 797\n+  double mod(double context, double num) {\n+    return std::fmod((std::fmod(context, num) + num), num);\n+  }\n+\n+  // Trims number and leaves the number of decimals specified.\n+  // The \"mode\" argument specifies which math function should be invoked\n+  // right after the number has been trimmed.\n+  // e.g. 12.12345.trim(3, \"ceil\") returns 12.124\n+  double trim(double context, int decimals, const std::string mode) {\n+    double accumulator = context * std::pow(10, decimals);\n+\n+    if (mode.compare(\"ceil\") == 0)\n+      accumulator = std::ceil(accumulator);\n+    else if (mode.compare(\"floor\") == 0)\n+      accumulator = std::floor(accumulator);\n+    else\n+      accumulator = std::round(accumulator);\n+\n+    return accumulator / std::pow(10, decimals);\n+  }\n+\n+  // Tells if number is in specified range based on given precision.\n+  // See the \"compare\" method for more information about precision\n+  bool isBetween(double context, double num1, double num2, const std::string precision) {\n+    return compare(context, std::min(num1, num2), \">=\", precision) &&\n+           compare(context, std::max(num1, num2), \"<=\", precision);\n+  }\n+\n+  bool compare(double context, double num, const std::string precision) {\n+    return compare(context, num, \"==\", precision);\n+  }\n+\n+  // Initiates comparison operator between context number and a given number, only here\n+  // a precision can be specified\n+  bool compare(double context, double num, const std::string method, const std::string precision) {\n+    // Fixed precision, \"almost equal\" with a deviation of Îµ\n+    if (precision.compare(\"f\") == 0) {\n+      if (method.compare(\"<\") == 0 ||\n+          method.compare(\"<=\") == 0)\n+        return context <= num + DBL_EPSILON;\n+      if (method.compare(\">\") == 0 ||\n+          method.compare(\">=\") == 0)\n+        return context >= num - DBL_EPSILON;\n+      return std::abs(context - num) <= DBL_EPSILON;\n+    }\n+    // Pixel precision, round comparison\n+    else if (precision.compare(\"px\") == 0) {\n+      if (method.compare(\"<\") == 0 ||\n+          method.compare(\"<=\") == 0)\n+        return std::round(context) <= std::round(num);\n+      if (method.compare(\">\") == 0 ||\n+          method.compare(\">=\") == 0)\n+        return std::round(context) >= std::round(num);\n+      return std::round(context) == std::round(num);\n+    }\n+    // Exact precision\n+    else {\n+      if (method.compare(\"<\") == 0) return context < num;\n+      if (method.compare(\"<=\") == 0) return context <= num;\n+      if (method.compare(\">\") == 0) return context > num;\n+      if (method.compare(\">=\") == 0) return context >= num;\n+      return context == num;\n+    }\n+  }\n+}\n+\n+EMSCRIPTEN_BINDINGS(utils_module) {\n+  emscripten::function(\"utils_mod\", &utils::mod);\n+  emscripten::function(\"utils_trim\", &utils::trim);\n+  emscripten::function(\"utils_isBetween\", &utils::isBetween);\n+  emscripten::function(\"utils_compare\",\n+    emscripten::select_overload<bool(double, double, const std::string, const std::string)>(\n+      &utils::compare\n+    )\n+  );\n+}\n\\ No newline at end of file\ndiff --git a/resources/cpp/src/utils.h b/resources/cpp/src/utils.h\nnew file mode 100644\nindex 0000000..abd31c2\n--- /dev/null\n+++ b/resources/cpp/src/utils.h\n@@ -0,0 +1,39 @@\n+#pragma once\n+\n+#include <string>\n+\n+namespace utils {\n+  template<typename T>\n+  class Chain {\n+  private:\n+    T _accumulator;\n+\n+  public:\n+    Chain(T accumulator);\n+\n+    Chain<double>* mod(double num);\n+\n+    Chain<double>* trim(int decimals, const std::string mode = \"round\");\n+\n+    Chain<bool>* isBetween(double num1, double num2, const std::string precision = \"exact\");\n+\n+    Chain<bool>* compare(double num, const std::string precision = \"exact\");\n+\n+    Chain<bool>* compare(double num, const std::string method, const std::string precision);\n+\n+    T result();\n+  };\n+\n+  template<typename T>\n+  Chain<T>* chain(T accumulator);\n+\n+  double mod(double context, double num);\n+\n+  double trim(double context, int decimals, const std::string mode = \"round\");\n+\n+  bool isBetween(double context, double num1, double num2, const std::string precision = \"exact\");\n+\n+  bool compare(double context, double num, const std::string precision = \"exact\");\n+\n+  bool compare(double context, double num, const std::string method, const std::string precision);\n+}\n\\ No newline at end of file\ndiff --git a/resources/scripts/engine/game.js b/resources/scripts/engine/game.js\nindex 6f5f67a..4a848a3 100644\n--- a/resources/scripts/engine/game.js\n+++ b/resources/scripts/engine/game.js\n@@ -40,6 +40,7 @@ Engine.Game = class Game {\n   }\n \n   draw() {\n+    // Draw a black screen by default\n     this.context.restore();\n     this.context.fillStyle = \"black\";\n     this.context.save();\n@@ -94,6 +95,7 @@ Engine.Game = class Game {\n   changeScreen(Screen, ...screenArgs) {\n     // If there is a screen defined, dispose it first\n     if (this.screen) {\n+      this.screen.delete();\n       this.unloadScreen();\n       this.screen.disposeEventListeners();\n     }\n@@ -117,13 +119,7 @@ Engine.Game = class Game {\n     this.screen.loading = true;\n     // The number of assets to load\n     let loadsize = 0;\n-\n-    // We use the \"after\" method because we want the following callback to be invoked\n-    // only once all assets are loaded\n-    let onload = _.after(loadsize, () => {\n-      delete this.screen.loading;\n-      callback();\n-    });\n+    let onload;\n \n     // This object can load assets\n     let assetsLoader = new Engine.AssetsLoader(() => {\n@@ -133,13 +129,22 @@ Engine.Game = class Game {\n \n     // The \"load\" method returns the assets loaded by the screen\n     let screenAssets = this.screen.load(assetsLoader);\n+\n+    // We use the \"after\" method because we want the following callback to be invoked\n+    // only once all assets are loaded\n+    onload = _.after(loadsize, () => {\n+      delete this.screen.loading;\n+      callback();\n+    });\n+\n     // The returned assets will be available on screen's assets object\n     _.extend(this.screen.assets, screenAssets);\n   }\n \n   // Disposes screen assets\n   unloadScreen() {\n-    let assetsNames = this.screen.unload && this.screen.unload();\n+    if (!this.screen.unload) return;\n+    let assetsNames = this.screen.unload();\n     _.omit(this.assets, assetsNames);\n   }\n \ndiff --git a/resources/scripts/engine/geometry/circle.js b/resources/scripts/engine/geometry/circle.js\nindex 3a6320c..3b96122 100644\n--- a/resources/scripts/engine/geometry/circle.js\n+++ b/resources/scripts/engine/geometry/circle.js\n@@ -1,83 +1,9 @@\n-Engine.Geometry.Circle = class Circle {\n-  // x - The x value of the circle's center\n-  // y - The y value of the circle's center\n-  // r - The radius of the center\n-  // rad1 - The first radian of the circle, not necessarily its beginning\n-  // rad2 - The second radian of the circle, not necessarily its beginning\n-  constructor(x, y, r, rad1, rad2) {\n-    this.x = Utils.trim(x, 9);\n-    this.y = Utils.trim(y, 9);\n-    this.r = Utils.trim(r, 9);\n-\n-    // Trimming mode is done based on which radian represents the ending and which radian\n-    // represents the ending\n-    if (rad1 > rad2) {\n-      this.rad1 = Utils.trim(rad1, 9, \"floor\");\n-      this.rad2 = Utils.trim(rad2, 9, \"ceil\");\n-    }\n-    else {\n-      this.rad1 = Utils.trim(rad1, 9, \"ceil\");\n-      this.rad2 = Utils.trim(rad2, 9, \"floor\");\n-    }\n-  }\n-\n+Engine.Geometry.Circle = class Circle extends Utils.proxy(CPP.Geometry.Circle) {\n   // Draws the circle on the given context\n   draw(context) {\n     context.arc(this.x, this.y, this.r, this.rad1, this.rad2);\n   }\n \n-  // Gets the matching x value for the given radian\n-  getX(rad) {\n-    if (!Utils(rad).trim(9).isBetween(this.rad1, this.rad2).value()) return;\n-    return Utils.trim((this.r * Math.cos(rad)) + this.x, 9);\n-  }\n-\n-  // Gets the matching y value for the given radian\n-  getY(rad) {\n-    if (!Utils(rad).trim(9).isBetween(this.rad1, this.rad2).value()) return;\n-    return Utils.trim((this.r * Math.sin(rad)) + this.y, 9);\n-  }\n-\n-  // Gets the matching point for the given radian\n-  getPoint(rad) {\n-    if (!Utils.isBetween(rad, this.rad1, this.rad2)) return;\n-\n-    return {\n-      x: Utils.trim((this.r * Math.cos(rad)) + this.x, 9),\n-      y: Utils.trim((this.r * Math.sin(rad)) + this.y, 9)\n-    };\n-  }\n-\n-  // Gets the matching radian for the given point\n-  getRad(x, y) {\n-    let rad = Math.atan2(y - this.y, x - this.x);\n-\n-    // If calculated radian is in circle's radian range, return it\n-    if (rad != null && Utils.isBetween(rad, this.rad1, this.rad2)) {\n-      return rad;\n-    }\n-\n-    // The calculated radian can still be in the circle's radian range in case one\n-    // of the radians is greater than 2 PIEs\n-    if (Math.abs(this.rad1) > Math.abs(this.rad2)) {\n-      var greatestRad = this.rad1;\n-    }\n-    else {\n-      var greatestRad = this.rad2;\n-    }\n-\n-    // Check if the absolute radian is in the circle's radian range\n-    if (Utils(rad + (2 * Math.PI * Math.floor(greatestRad / (2 * Math.PI)))).trim(9).isBetween(this.rad1, this.rad2).value() ||\n-        Utils(rad + (2 * Math.PI * Math.ceil(greatestRad / (2 * Math.PI)))).trim(9).isBetween(this.rad1, this.rad2).value()) {\n-      return rad;\n-    }\n-  }\n-\n-  // Returns if circle has given points\n-  hasPoint(x, y) {\n-    return this.getRad(x, y) != null;\n-  }\n-\n   getIntersection(shape) {\n     if (shape instanceof Engine.Geometry.Line)\n       return this.getLineIntersection(shape);\n@@ -87,86 +13,6 @@ Engine.Geometry.Circle = class Circle {\n       return this.getPolygonIntersection(shape);\n   }\n \n-  // circle - circle intersection method\n-  getCircleIntersection(circle) {\n-    let dx = circle.x - this.x;\n-    let dy = circle.y - this.y;\n-    let d = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\n-\n-    if (d > this.r + circle.r ||\n-       d < Math.abs(this.r - circle.r)) {\n-      return;\n-    }\n-\n-    let a = ((Math.pow(this.r, 2) - Math.pow(circle.r, 2)) + Math.pow(d, 2)) / (2 * d);\n-    let x = this.x + ((dx * a) / d);\n-    let y = this.y + ((dy * a) / d);\n-    let h = Math.sqrt(Math.pow(this.r, 2) - Math.pow(a, 2));\n-    let rx = (- dy * h) / d;\n-    let ry = (dx * h) / d;\n-\n-    let interPoints = [\n-      {\n-        x: x + rx,\n-        y: y + ry\n-      },\n-      {\n-        x: x - rx,\n-        y: y - ry\n-      }\n-    ]\n-    .map(point => ({\n-        x: Utils.trim(point.x, 9),\n-        y: Utils.trim(point.y, 9)\n-     }));\n-\n-    interPoints = _.uniq(interPoints, point => `(${point.x}, ${point.y})`);\n-\n-    [this, circle].forEach(function(circle) {\n-      interPoints = interPoints.filter(point => circle.hasPoint(point.x, point.y));\n-    });\n-\n-    if (interPoints.length > 0) return interPoints;\n-  }\n-\n-  // circle - line intersection method\n-  getLineIntersection(line) {\n-    let x1 = line.x1 - this.x;\n-    let x2 = line.x2 - this.x;\n-    let y1 = line.y1 - this.y;\n-    let y2 = line.y2 - this.y;\n-    let dx = x2 - x1;\n-    let dy = y2 - y1;\n-    let d = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\n-    let h = (x1 * y2) - (x2 * y1);\n-    let delta = (Math.pow(this.r, 2) * Math.pow(d, 2)) - Math.pow(h, 2);\n-\n-    if (delta < 0) return;\n-\n-    let interPoints = [\n-      {\n-        x: (((h * dy) + (((dy / Math.abs(dy)) || 1) * dx * Math.sqrt(delta))) / Math.pow(d, 2)) + this.x,\n-        y: (((-h * dx) + (Math.abs(dy) * Math.sqrt(delta))) / Math.pow(d, 2)) + this.y\n-      },\n-      {\n-        x: (((h * dy) - (((dy / Math.abs(dy)) || 1) * dx * Math.sqrt(delta))) / Math.pow(d, 2)) + this.x,\n-        y: (((-h * dx) - (Math.abs(dy) * Math.sqrt(delta))) / Math.pow(d, 2)) + this.y\n-      }\n-    ]\n-    .map(point => ({\n-        x: Utils.trim(point.x, 9),\n-        y: Utils.trim(point.y, 9)\n-    }))\n-    .filter(point => {\n-      return this.hasPoint(point.x, point.y) &&\n-        line.boundsHavePoint(point.x, point.y);\n-    });\n-\n-    interPoints = _.uniq(interPoints, point => `(${point.x}, ${point.y})`);\n-\n-    if (interPoints.length > 0) return interPoints;\n-  }\n-\n   // circle - polygon intersection method\n   getPolygonIntersection(polygon) {\n     return polygon.getCircleIntersection(this);\ndiff --git a/resources/scripts/engine/geometry/line.js b/resources/scripts/engine/geometry/line.js\nindex ac8bbdc..1a6d825 100644\n--- a/resources/scripts/engine/geometry/line.js\n+++ b/resources/scripts/engine/geometry/line.js\n@@ -1,46 +1,10 @@\n-Engine.Geometry.Line = class Line {\n-  // x1 - The first point's x value\n-  // y1 - The first point's y value\n-  // x1 - The second point's x value\n-  // y2 - The second point's y value\n-  constructor(x1, y1, x2, y2) {\n-    this.x1 = Utils.trim(x1, 9);\n-    this.y1 = Utils.trim(y1, 9);\n-    this.x2 = Utils.trim(x2, 9);\n-    this.y2 = Utils.trim(y2, 9);\n-  }\n-\n+Engine.Geometry.Line = class Line extends Utils.proxy(CPP.Geometry.Line) {\n   // Draws the line on the given context\n   draw(context) {\n     context.moveTo(this.x1, this.y1);\n     context.lineTo(this.x2, this.y2);\n   }\n \n-  // Gets the matching x value for a given y value\n-  getX(y) {\n-    let x = Utils.trim((((y - this.y1) * (this.x2 - this.x1)) / (this.y2 - this.y1)) + this.x1, 9);\n-    if (isNaN(x) || Utils.isBetween(x, this.x1, this.x2)) return x;\n-  }\n-\n-  // Gets the matching y value for a given x value\n-  getY(x) {\n-    let y = Utils.trim((((x - this.x1) * (this.y2 - this.y1)) / (this.x2 - this.x1)) + this.y1, 9);\n-    if (isNaN(y) || Utils.isBetween(y, this.y1, this.y2)) return y;\n-  }\n-\n-  // Returns if line has given point\n-  hasPoint(x, y) {\n-    if (!this.boundsHavePoint(x, y)) return false;\n-    let m = Utils.trim((this.y2 - this.y1) / (this.x2 - this.x1), 9);\n-    return (y - this.y1) / (x - this.x1) == m;\n-  }\n-\n-  // Returns if given point is contained by the bounds aka cage of line\n-  boundsHavePoint(x, y) {\n-    return Utils.isBetween(x, this.x1, this.x2) &&\n-           Utils.isBetween(y, this.y1, this.y2);\n-  }\n-\n   getIntersection(shape) {\n     if (shape instanceof Engine.Geometry.Line)\n       return this.getLineIntersection(shape);\n@@ -50,28 +14,6 @@ Engine.Geometry.Line = class Line {\n       return this.getPolygonIntersection(shape);\n   }\n \n-  // line - line intersection method\n-  getLineIntersection(line) {\n-    // Escape if lines are parallel\n-    if (!(((this.x1 - this.x2) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * (line.x1 - line.x2)))) return;\n-\n-    // Intersection point formula\n-    let x = Utils.trim(((((this.x1 * this.y2) - (this.y1 * this.x2)) * (line.x1 - line.x2)) - ((this.x1 - this.x2) * ((line.x1 * line.y2) - (line.y1 * line.x2)))) /\n-        (((this.x1 - this.x2) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * (line.x1 - line.x2))), 9);\n-    let y = Utils.trim(((((this.x1 * this.y2) - (this.y1 * this.x2)) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * ((line.x1 * line.y2) - (line.y1 * line.x2)))) /\n-        (((this.x1 - this.x2) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * (line.x1 - line.x2))), 9);\n-\n-    if (Utils.isBetween(x, this.x1, this.x2) && Utils.isBetween(x, line.x1, line.x2) &&\n-        Utils.isBetween(y, this.y1, this.y2) && Utils.isBetween(y, line.y1, line.y2)) {\n-      return { x, y };\n-    }\n-  }\n-\n-  // line - circle intersection method\n-  getCircleIntersection(circle) {\n-    return circle.getLineIntersection(this);\n-  }\n-\n   // line - polygon intersection method\n   getPolygonIntersection(polygon) {\n     return polygon.getLineIntersection(this);\ndiff --git a/resources/scripts/engine/geometry/polygon.js b/resources/scripts/engine/geometry/polygon.js\nindex 6e4d828..60cbd44 100644\n--- a/resources/scripts/engine/geometry/polygon.js\n+++ b/resources/scripts/engine/geometry/polygon.js\n@@ -5,6 +5,10 @@ Engine.Geometry.Polygon = class Polygon {\n     this.bounds = bounds.map(coords => new Engine.Geometry.Line(...coords));\n   }\n \n+  delete() {\n+    this.bounds.forEach(bound => bound.delete());\n+  }\n+\n   // Returns if polygon has given point\n   hasPoint(x, y) {\n     // Run check for each bound\ndiff --git a/resources/scripts/engine/layer.js b/resources/scripts/engine/layer.js\nindex bbef4ea..5ef041f 100644\n--- a/resources/scripts/engine/layer.js\n+++ b/resources/scripts/engine/layer.js\n@@ -23,6 +23,9 @@ Engine.Layer = class Layer {\n     this.canvas = screen.game.canvas;\n   }\n \n+  delete() {\n+  }\n+\n   update(span) {\n   }\n \ndiff --git a/resources/scripts/engine/screen.js b/resources/scripts/engine/screen.js\nindex ee52870..a4f9018 100644\n--- a/resources/scripts/engine/screen.js\n+++ b/resources/scripts/engine/screen.js\n@@ -28,6 +28,13 @@ Engine.Screen = class Screen {\n     return this;\n   }\n \n+   // Delete all layers. Same as 'unload', only it disposes memory rather than assets\n+  delete() {\n+    this.layers.forEach(layer => {\n+      layer.delete();\n+    });\n+  }\n+\n   // Updates each layer\n   update(span) {\n     this.layers.forEach(layer => {\n@@ -61,6 +68,7 @@ Engine.Screen = class Screen {\n   removeLayer(layer) {\n     this.layers = _.without(this.layers, layer);\n     layer.disposeEventListeners();\n+    layer.delete();\n   }\n \n   initEventListeners() {\ndiff --git a/resources/scripts/game/entities/snake.js b/resources/scripts/game/entities/snake.js\nindex 9c32961..ecc5003 100644\n--- a/resources/scripts/game/entities/snake.js\n+++ b/resources/scripts/game/entities/snake.js\n@@ -31,6 +31,10 @@ Game.Entities.Snake = class Snake {\n     }\n   }\n \n+  delete() {\n+    this.shapes.forEach(shape => shape.delete());\n+  }\n+\n   draw(context) {\n     // Draw all shapes in the shapes array\n     this.shapes.forEach(shape => {\n@@ -229,6 +233,8 @@ Game.Entities.Snake = class Snake {\n       [0, height, 0, 0]\n     );\n \n-    return canvasPolygon.getIntersection(this.lastBit);\n+    let result = canvasPolygon.getIntersection(this.lastBit);\n+    canvasPolygon.delete();\n+    return result;\n   }\n };\n\\ No newline at end of file\ndiff --git a/resources/scripts/game/screens/play/snake.js b/resources/scripts/game/screens/play/snake.js\nindex 66a0b92..a3f5eb6 100644\n--- a/resources/scripts/game/screens/play/snake.js\n+++ b/resources/scripts/game/screens/play/snake.js\n@@ -43,6 +43,10 @@ Game.Screens.Play.Snake = class Snake extends Engine.Layer {\n     screen.appendLayer(Game.Screens.Play.Score, this.snakes);\n   }\n \n+  unload() {\n+    this.snakes.forEach(snake => snake.delete());\n+  }\n+\n   draw(context) {\n     // Draw each snake in the snakes array\n     this.snakes.forEach(snake => snake.draw(context));\n@@ -63,7 +67,7 @@ Game.Screens.Play.Snake = class Snake extends Engine.Layer {\n         // Don't scan for intersection with self, obviously this will always be true\n         if (opponent === snake) return;\n         // Disqualify if intersected with opponent\n-        if (snake.getSnakeIntersection(opponent)) return this.snakes.splice(index, 1);\n+        if (snake.getSnakeIntersection(opponent)) this.snakes.splice(index, 1);\n       });\n     });\n \ndiff --git a/resources/scripts/specs/engine/geometry/circle.js b/resources/scripts/specs/engine/geometry/circle.js\nindex 669bcd5..dd47603 100644\n--- a/resources/scripts/specs/engine/geometry/circle.js\n+++ b/resources/scripts/specs/engine/geometry/circle.js\n@@ -3,6 +3,10 @@ describe(\"Engine.Geometry.Circle class\", function() {\n     this.circle = new Engine.Geometry.Circle(1, 1, 5, 0, 1.5 * Math.PI);\n   });\n \n+  afterEach(function () {\n+    this.circle.delete();\n+  });\n+\n   describe(\"getX method\", function() {\n     describe(\"given inranged rad\", function() {\n       it(\"returns x\", function() {\n@@ -64,6 +68,8 @@ describe(\"Engine.Geometry.Circle class\", function() {\n           { x: -2, y: -3 },\n           { x: -2, y: 5 }\n         ]);\n+\n+        circle.delete();\n       });\n     });\n \n@@ -74,6 +80,8 @@ describe(\"Engine.Geometry.Circle class\", function() {\n         expect(this.circle.getCircleIntersection(circle)).toEqual([\n           { x: -2, y: 5 }\n         ]);\n+\n+        circle.delete();\n       });\n     });\n \n@@ -84,6 +92,8 @@ describe(\"Engine.Geometry.Circle class\", function() {\n         expect(this.circle.getCircleIntersection(circle)).toEqual([\n           { x: -4, y: 1 }\n         ]);\n+\n+        circle.delete();\n       });\n     });\n \n@@ -91,6 +101,7 @@ describe(\"Engine.Geometry.Circle class\", function() {\n       it(\"returns nothing\", function() {\n         let circle = new Engine.Geometry.Circle(10, 10, 2, 0, 2 * Math.PI);\n         expect(this.circle.getCircleIntersection(circle)).toBeUndefined();\n+        circle.delete();\n       });\n     });\n \n@@ -98,6 +109,7 @@ describe(\"Engine.Geometry.Circle class\", function() {\n       it(\"nothing\", function() {\n         let circle = new Engine.Geometry.Circle(1, 1, 2, 0, 2 * Math.PI);\n         expect(this.circle.getCircleIntersection(circle)).toBeUndefined();\n+        circle.delete();\n       });\n     });\n   });\n@@ -111,6 +123,8 @@ describe(\"Engine.Geometry.Circle class\", function() {\n           { x: 6, y: 1 },\n           { x: -4, y: 1 }\n         ]);\n+\n+        line.delete();\n       });\n     });\n \n@@ -121,6 +135,8 @@ describe(\"Engine.Geometry.Circle class\", function() {\n         expect(this.circle.getLineIntersection(line)).toEqual([\n           { x: -4, y: 1 }\n         ]);\n+\n+        line.delete();\n       });\n     });\n \n@@ -131,6 +147,8 @@ describe(\"Engine.Geometry.Circle class\", function() {\n         expect(this.circle.getLineIntersection(line)).toEqual([\n           { x: 1, y: 6 }\n         ]);\n+\n+        line.delete();\n       });\n     });\n \n@@ -138,6 +156,7 @@ describe(\"Engine.Geometry.Circle class\", function() {\n       it(\"returns nothing\", function() {\n         let line = new Engine.Geometry.Line(-10, 10, 10, 10);\n         expect(this.circle.getLineIntersection(line)).toBeUndefined();\n+        line.delete();\n       });\n     });\n   });\ndiff --git a/resources/scripts/specs/engine/geometry/line.js b/resources/scripts/specs/engine/geometry/line.js\nindex c65ca88..27d0a93 100644\n--- a/resources/scripts/specs/engine/geometry/line.js\n+++ b/resources/scripts/specs/engine/geometry/line.js\n@@ -3,6 +3,10 @@ describe(\"Engine.Geometry.Line class\", function() {\n     this.line = new Engine.Geometry.Line(-5, -5, 5, 5);\n   });\n \n+  afterEach(function () {\n+    this.line.delete();\n+  });\n+\n   describe(\"getX method\", function() {\n     describe(\"given inranged y\", function() {\n       it(\"returns x\", function() {\n@@ -58,6 +62,8 @@ describe(\"Engine.Geometry.Line class\", function() {\n           x: 1,\n           y: 1\n         });\n+\n+        line.delete();\n       });\n     });\n \n@@ -65,6 +71,7 @@ describe(\"Engine.Geometry.Line class\", function() {\n       it(\"returns nothing\", function() {\n         let line = new Engine.Geometry.Line(-5, -6, 5, 4);\n         expect(this.line.getLineIntersection(line)).toBeUndefined();\n+        line.delete();\n       });\n     });\n \n@@ -72,6 +79,7 @@ describe(\"Engine.Geometry.Line class\", function() {\n       it(\"returns nothing\", function() {\n         let line = new Engine.Geometry.Line(10, 10, 10, 15);\n         expect(this.line.getLineIntersection(line)).toBeUndefined();\n+        line.delete();\n       });\n     });\n   });\ndiff --git a/resources/scripts/specs/engine/geometry/polygon.js b/resources/scripts/specs/engine/geometry/polygon.js\nindex 6c142d8..4da2977 100644\n--- a/resources/scripts/specs/engine/geometry/polygon.js\n+++ b/resources/scripts/specs/engine/geometry/polygon.js\n@@ -8,6 +8,10 @@ describe(\"Engine.Geometry.Polygon class\", function() {\n     );\n   });\n \n+  afterEach(function () {\n+    this.polygon.delete();\n+  });\n+\n   describe(\"hasPoint method\", function() {\n     describe(\"given contained point\", function() {\n       it(\"returns true\", function() {\n@@ -33,8 +37,10 @@ describe(\"Engine.Geometry.Polygon class\", function() {\n \n         expect(this.polygon.getLineIntersection(line)).toEqual([\n           { x: 5, y: 4 },\n-          { x: -0, y: 1 }\n+          { x: 0, y: 1 }\n         ]);\n+\n+        line.delete();\n       });\n     });\n \n@@ -43,6 +49,8 @@ describe(\"Engine.Geometry.Polygon class\", function() {\n         let line = new Engine.Geometry.Line(10, 11, 15, 14);\n \n         expect(this.polygon.getLineIntersection(line)).toBeUndefined();\n+\n+        line.delete();\n       });\n     });\n   });\n@@ -56,6 +64,8 @@ describe(\"Engine.Geometry.Polygon class\", function() {\n           { x: 2, y: 0 },\n           { x: 0, y: 2 }\n         ]);\n+\n+        circle.delete();\n       });\n     });\n \n@@ -66,6 +76,8 @@ describe(\"Engine.Geometry.Polygon class\", function() {\n         expect(this.polygon.getCircleIntersection(circle)).toEqual([\n           { x: 2, y: 0 }\n         ]);\n+\n+        circle.delete();\n       });\n     });\n \n@@ -76,6 +88,8 @@ describe(\"Engine.Geometry.Polygon class\", function() {\n         expect(this.polygon.getCircleIntersection(circle)).toEqual([\n           { x: 0, y: 3 }\n         ]);\n+\n+        circle.delete();\n       });\n     });\n \n@@ -83,6 +97,7 @@ describe(\"Engine.Geometry.Polygon class\", function() {\n       it(\"returns nothing\", function() {\n         let circle = new Engine.Geometry.Circle(10, 10, 2, 0, 2 * Math.PI);\n         expect(this.polygon.getCircleIntersection(circle)).toBeUndefined();\n+        circle.delete();\n       });\n     });\n \n@@ -90,6 +105,7 @@ describe(\"Engine.Geometry.Polygon class\", function() {\n       it(\"nothing\", function() {\n         let circle = new Engine.Geometry.Circle(2.5, 2.5, 2, 0, 2 * Math.PI);\n         expect(this.polygon.getCircleIntersection(circle)).toBeUndefined();\n+        circle.delete();\n       });\n     });\n   });\ndiff --git a/resources/scripts/utils.js b/resources/scripts/utils.js\nindex 27a4cb7..207754e 100644\n--- a/resources/scripts/utils.js\n+++ b/resources/scripts/utils.js\n@@ -16,63 +16,22 @@ Utils = function Utils(context) {\n   return chain;\n };\n \n-// Fixed modulo method which can calculate modulo of negative numbers properly\n-// e.g. (-803).mod(800) returns 797\n-Utils.mod = function (context, num) {\n-  return ((context % num) + num) % num;\n-};\n-\n-// Trims number and leaves the number of decimals specified.\n-// The \"mode\" argument specifies which math function should be invoked\n-// right after the number has been trimmed.\n-// e.g. 12.12345.trim(3, \"ceil\") returns 12.124\n-Utils.trim = function (context, decimals, mode = \"round\") {\n-  return Math[mode](context * Math.pow(10, decimals)) / Math.pow(10, decimals);\n-};\n-\n-// Tells if number is in specified range based on given precision.\n-// See the \"compare\" method for more information about precision\n-Utils.isBetween = function (context, num1, num2, precision) {\n-  return Utils.compare(context, Math.min(num1, num2), \">=\", precision) &&\n-         Utils.compare(context, Math.max(num1, num2), \"<=\", precision);\n-};\n-\n-// Initiates comparison operator between context number and a given number, only here\n-// a precision can be specified\n-Utils.compare = function (context, num, method, precision) {\n-  switch (arguments.length) {\n-    case 2:\n-      var precision = arguments[1];\n-      break;\n-    case 3:\n-      var method = arguments[1];\n-      precision = arguments[2];\n-      break;\n-  }\n-\n-  switch (precision) {\n-    // Fixed precision, \"almost equal\" with a deviation of Îµ\n-    case \"f\":\n-      switch (method) {\n-        case \"<\": case \"<=\": return context <= num + Number.EPSILON;\n-        case \">\": case \">=\": return context >= num - Number.EPSILON;\n-        default: return Math.abs(context - num) <= Number.EPSILON;\n-      }\n-    // Pixel precision, round comparison\n-    case \"px\":\n-      switch (method) {\n-        case \"<\": case \"<=\": return Math.round(context) <= Math.round(num);\n-        case \">\": case \">=\": return Math.round(context) >= Math.round(num);\n-        default: return Math.round(context) == Math.round(num);\n-      }\n-    // Exact precision\n-    default:\n-      switch (method) {\n-        case \"<\": return context < num;\n-        case \"<=\": return context <= num;\n-        case \">\": return context > num;\n-        case \">=\": return context >= num;\n-        default: return context === num;\n+Object.assign(Utils, CPP.Utils, {\n+  // Overload handling\n+  compare(context, num, method, precision = method) {\n+    return CPP.Utils.compare(context, num, method, precision);\n+  },\n+\n+  proxy(Class) {\n+    return class extends Class {\n+      constructor() {\n+        // Initialize original class\n+        let that = new Class(...arguments);\n+        // Inject caller's prototype into the prototype chain\n+        Object.setPrototypeOf(that, new.target.prototype);\n+        // Will original instance will be the substitute for 'this'\n+        return that;\n       }\n+    }\n   }\n-};\n\\ No newline at end of file\n+});\n\\ No newline at end of file\ndiff --git a/views/game.html b/views/game.html\nindex 5c300ad..c18ee54 100644\n--- a/views/game.html\n+++ b/views/game.html\n@@ -8,6 +8,7 @@\n     <script type=\"text/javascript\" src=\"/libs/underscore.js\"></script>\n \n     <!-- Scripts -->\n+    <script type=\"text/javascript\" src=\"/scripts/cpp.bundle.js\"></script>\n     <script type=\"text/javascript\" src=\"/scripts/utils.js\"></script>\n     <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n     <script type=\"text/javascript\" src=\"/scripts/engine/geometry/line.js\"></script>\ndiff --git a/views/spec_runner.html b/views/spec_runner.html\nindex 1b191ee..5d4ef63 100644\n--- a/views/spec_runner.html\n+++ b/views/spec_runner.html\n@@ -16,6 +16,7 @@\n     <script type=\"text/javascript\" src=\"libs/underscore.js\"></script>\n \n     <!-- Scripts -->\n+    <script type=\"text/javascript\" src=\"scripts/cpp.bundle.js\"></script>\n     <script type=\"text/javascript\" src=\"scripts/utils.js\"></script>\n     <script type=\"text/javascript\" src=\"scripts/namespaces.js\"></script>\n     <script type=\"text/javascript\" src=\"scripts/engine/geometry/line.js\"></script>\n",
        "manuals": [
          {
            "manualTitle": "How to implement a game engine in JavaScript and build a Tron-style game",
            "stepRevision": "08b88f5a9d7b2d3ba4c8a67a1433218ef6a6a3a5",
            "manualView": "![snake-demo-full-small](https://cloud.githubusercontent.com/assets/7648874/21073892/ae331a8a-bed2-11e6-9141-9554f9bb808b.gif)\n\nThis tutorial will guide you through the following steps:\n\n- [**Step 1**](https://github.com/DAB0mB/radial-snake/blob/master/.tortilla/manuals/views/step1.md) - Creating a server\n- [**Step 2**](https://github.com/DAB0mB/radial-snake/blob/master/.tortilla/manuals/views/step2.md) - Creating a game engine basis\n- [**Step 3**](https://github.com/DAB0mB/radial-snake/blob/master/.tortilla/manuals/views/step3.md) - Creating a splash screen using a keyframe animation engine\n- [**Step 4**](https://github.com/DAB0mB/radial-snake/blob/master/.tortilla/manuals/views/step4.md) - Creating a main menu screen using a font engine\n- [**Step 5**](https://github.com/DAB0mB/radial-snake/blob/master/.tortilla/manuals/views/step5.md) - Creating a snake and related geometry shapes\n- [**Step 6**](https://github.com/DAB0mB/radial-snake/blob/master/.tortilla/manuals/views/step6.md) - Creating a complex game screen with multiple layers\n- [**Step 7**](https://github.com/DAB0mB/radial-snake/blob/master/.tortilla/manuals/views/step7.md) - Bonus! Re-implementing geometry in C++\n\nMake sure you have the following software installed:\n\n- NodeJS with an ECMAScript 2015 support (v6.0.0 and above).\n- Any web-browser which supports ECMAScript 2015, with a preference for Google Chrome.\n\n> The final project is a hybrid of C++ and JavaScript. A JavaScript **only** version of this tutorial is available [here](https://github.com/DAB0mB/radial-snake/tree/master%40step6%400.1.3).\n\nThis tutorial is mostly based on pure JavaScript, so people can have a deeper understanding of the language and its dynamics. In addition, this tutorial makes a great practice on how to build a nice architecture for complex systems, which can then be expanded and maintained with ease. Yes, it is specifically designed for games, but I truly believe that video games can easily get messed up if not planned and designed properly in terms of object oriented relationships. They are naturally more complicated then any web-app you gonna see out there, so if you can create a game engine and understand its flow, creating a web-app would be a piece of cake for you. By the end of this tutorial, your general sense for programming should be enhanced greatly.\n\nSo hopefully that I got you pumped up by now, let's get started!"
          },
          {
            "manualTitle": "Step 1: Creating a server",
            "stepRevision": "1aed2194c509617dbe79447e2615aa34728262bc",
            "manualView": "The first thing we will learn to do would be creating a server so we can serve our assets. We will be using [HapiJS](https://hapijs.com/) to build a REST API, although this step can be implemented with any library you'd want, like [ExpressJS](http://expressjs.com/) or [Connect](https://www.senchalabs.github.com/connect) etc. Let's install it then:\n\n    $ npm install hapi --save\n\nWe will start by setting up a basis for our server, and we will expand it as we go further in this step. A general boiler plate should look like so:\n\n[{]: <helper> (diffStep 1.2)\n\n#### [Step 1.2: Add server basis](https://github.com/DAB0mB/radial-snake/commit/8ff8805)\n\n##### Added server.js\n```diff\n@@ -0,0 +1,36 @@\n+â”Š  â”Š 1â”Šconst Hapi = require(\"hapi\");\n+â”Š  â”Š 2â”Š\n+â”Š  â”Š 3â”Šlet port = 8000;\n+â”Š  â”Š 4â”Š\n+â”Š  â”Š 5â”Š// Initialize a new server\n+â”Š  â”Š 6â”Šlet server = new Hapi.Server();\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Šserver.connection({ port: process.env.PORT || port });\n+â”Š  â”Š 9â”Š\n+â”Š  â”Š10â”Š// Report each response made\n+â”Š  â”Š11â”Šserver.ext(\"onPreResponse\", (req, rep) => {\n+â”Š  â”Š12â”Š  let res = req.response;\n+â”Š  â”Š13â”Š\n+â”Š  â”Š14â”Š  console.log(\"Outcoming response:\");\n+â”Š  â”Š15â”Š  console.log(`in: ${new Date}`);\n+â”Š  â”Š16â”Š  console.log(`to: ${req.info.remoteAddress}`);\n+â”Š  â”Š17â”Š  console.log(`method: ${req.method}`);\n+â”Š  â”Š18â”Š  console.log(`url: ${req.url.path}`);\n+â”Š  â”Š19â”Š  console.log(`status: ${res.statusCode || res.output.statusCode}`);\n+â”Š  â”Š20â”Š  console.log();\n+â”Š  â”Š21â”Š\n+â”Š  â”Š22â”Š  rep.continue();\n+â”Š  â”Š23â”Š});\n+â”Š  â”Š24â”Š\n+â”Š  â”Š25â”Š// Print message once started\n+â”Š  â”Š26â”Šserver.start((err) => {\n+â”Š  â”Š27â”Š  if (err) throw err;\n+â”Š  â”Š28â”Š\n+â”Š  â”Š29â”Š  console.log();\n+â”Š  â”Š30â”Š  console.log(\"---------- -------- ------ ---- --\");\n+â”Š  â”Š31â”Š  console.log(\"----- ---- --- -- -\");\n+â”Š  â”Š32â”Š  console.log(`Server running at ${port}`);\n+â”Š  â”Š33â”Š  console.log(\"----- ---- --- -- -\");\n+â”Š  â”Š34â”Š  console.log(\"---------- -------- ------ ---- --\");\n+â”Š  â”Š35â”Š  console.log();\n+â”Š  â”Š36â”Š});ðŸš«â†µ\n```\n\n[}]: #\n\nWe simply initialize a new server which will connect to port `8000` by default, unless we defined an environment variable called `PORT`. Once the server is started, and whenever there is an outcoming response, a message will be printed to the console.\n\n> More information and configuration options regards HapiJS's API can be found in this [here](https://hapijs.com/).\n\nNow that the basis is ready, we want a convenient way to launch it. Repetitive scripts are usually defined in the `package.json` file under the `scripts` field. To start the server, we gonna create a simple script called `serve`:\n\n[{]: <helper> (diffStep 1.3)\n\n#### [Step 1.3: Add serve npm script](https://github.com/DAB0mB/radial-snake/commit/6e7d691)\n\n##### Changed package.json\n```diff\n@@ -6,6 +6,9 @@\n â”Š 6â”Š 6â”Š    \"url\": \"https://DAB0mB@github.com/DAB0mB/radial-snake.git\"\n â”Š 7â”Š 7â”Š  },\n â”Š 8â”Š 8â”Š  \"private\": true,\n+â”Š  â”Š 9â”Š  \"scripts\": {\n+â”Š  â”Š10â”Š    \"serve\": \"node server.js\"\n+â”Š  â”Š11â”Š  },\n â”Š 9â”Š12â”Š  \"dependencies\": {\n â”Š10â”Š13â”Š    \"hapi\": \"^16.0.1\"\n â”Š11â”Š14â”Š  }\n```\n\n[}]: #\n\nTo run this script, we will simply need to type the following:\n\n    $ npm run serve\n\nThis will run our server, and you should see the following message printed to the console:\n\n```\n---------- -------- ------ ---- --\n----- ---- --- -- -\nServer running at 8000\n----- ---- --- -- -\n---------- -------- ------ ---- --\n```\n\n> As for now, nothing happens, because we didn't define any handlers for HTTP requests. I will get to it in a bit, stay with me.\n\nThe main disadvantage of starting a server directly with node is that we have no listeners for changes in our files, so if we want the served files to be updated, we will have to restart our server anytime we make a change. To avoid that, we gonna use [nodemon](https://nodemon.io/), which is a simple utility that can monitor changes is source files and automatically restart our server. To install it, type the following:\n\n    $ sudo npm install nodemon -g\n\nNow that we have it, we will need to update our `serve` npm script to use `nodemon` instead of `node`:\n\n[{]: <helper> (diffStep 1.4)\n\n#### [Step 1.4: Change serve npm script to use nodemon](https://github.com/DAB0mB/radial-snake/commit/a238294)\n\n##### Changed package.json\n```diff\n@@ -7,7 +7,7 @@\n â”Š 7â”Š 7â”Š  },\n â”Š 8â”Š 8â”Š  \"private\": true,\n â”Š 9â”Š 9â”Š  \"scripts\": {\n-â”Š10â”Š  â”Š    \"serve\": \"node server.js\"\n+â”Š  â”Š10â”Š    \"serve\": \"nodemon server.js\"\n â”Š11â”Š11â”Š  },\n â”Š12â”Š12â”Š  \"dependencies\": {\n â”Š13â”Š13â”Š    \"hapi\": \"^16.0.1\"\n```\n\n[}]: #\n\nThe basis for our server is pretty much complete. From now on we gonna build stuff on top of it and extend our server. I'd like to add a small attachment to our server. I want that the IP address of the current computer will be printed to the console once the server is started. For this, we first gonna create a helper which we gonna call `ip_grabber`:\n\n[{]: <helper> (diffStep 1.5)\n\n#### [Step 1.5: Add ip_grabber helper](https://github.com/DAB0mB/radial-snake/commit/8ff1d1c)\n\n##### Added helpers&#x2F;ip_grabber.js\n```diff\n@@ -0,0 +1,23 @@\n+â”Š  â”Š 1â”Šconst Os = require(\"os\");\n+â”Š  â”Š 2â”Š\n+â”Š  â”Š 3â”Š// Grab local IP address of which the NodeJS process runs on\n+â”Š  â”Š 4â”Šfunction local() {\n+â”Š  â”Š 5â”Š  let interfaces = Os.networkInterfaces();\n+â”Š  â”Š 6â”Š  let addresses = [];\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Š  for (let k in interfaces) {\n+â”Š  â”Š 9â”Š    for (let k2 in interfaces[k]) {\n+â”Š  â”Š10â”Š      let address = interfaces[k][k2];\n+â”Š  â”Š11â”Š\n+â”Š  â”Š12â”Š      if (address.family == \"IPv4\" && !address.internal) {\n+â”Š  â”Š13â”Š        addresses.push(address.address);\n+â”Š  â”Š14â”Š      }\n+â”Š  â”Š15â”Š    }\n+â”Š  â”Š16â”Š  }\n+â”Š  â”Š17â”Š\n+â”Š  â”Š18â”Š  return addresses[0];\n+â”Š  â”Š19â”Š}\n+â”Š  â”Š20â”Š\n+â”Š  â”Š21â”Šmodule.exports = {\n+â”Š  â”Š22â”Š  local\n+â”Š  â”Š23â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nThis module simply goes through the available network interfaces and grabs the IP address of the default gateway using the `os` module. Now that we have it, let's import it in the server's entry file and use the `local` method to grab the IP address and report it once the server is started:\n\n[{]: <helper> (diffStep 1.6)\n\n#### [Step 1.6: Print IP address once server is started](https://github.com/DAB0mB/radial-snake/commit/18ed984)\n\n##### Changed server.js\n```diff\n@@ -1,5 +1,7 @@\n â”Š1â”Š1â”Šconst Hapi = require(\"hapi\");\n+â”Š â”Š2â”Šconst IpGrabber = require(\"./helpers/ip_grabber\");\n â”Š2â”Š3â”Š\n+â”Š â”Š4â”Šlet localIp = IpGrabber.local();\n â”Š3â”Š5â”Šlet port = 8000;\n â”Š4â”Š6â”Š\n â”Š5â”Š7â”Š// Initialize a new server\n```\n```diff\n@@ -29,7 +31,7 @@\n â”Š29â”Š31â”Š  console.log();\n â”Š30â”Š32â”Š  console.log(\"---------- -------- ------ ---- --\");\n â”Š31â”Š33â”Š  console.log(\"----- ---- --- -- -\");\n-â”Š32â”Š  â”Š  console.log(`Server running at ${port}`);\n+â”Š  â”Š34â”Š  console.log(`Server running at ${localIp}:${port}`);\n â”Š33â”Š35â”Š  console.log(\"----- ---- --- -- -\");\n â”Š34â”Š36â”Š  console.log(\"---------- -------- ------ ---- --\");\n â”Š35â”Š37â”Š  console.log();\n```\n\n[}]: #\n\nBy now you should have the following message printed to the console once you start the server:\n\n```\n---------- -------- ------ ---- --\n----- ---- --- -- -\nServer running at 95.221.122.30:8000\n----- ---- --- -- -\n---------- -------- ------ ---- --\n```\n\n> Instead of `95.221.122.30` you should have the IP address which is right for you.\n\nNow comes the most important part - handling HTTP requests! Because what does a server worth if it doesn't know how to handle anything? When using `HapiJS`, we can separate extensions to our server in different modules, and eventually register them as plug-ins. So the first plug-in is gonna be the routes batch for the endpoints - it will take care of serving file requests as is, and basically turning local directories into public ones. This is useful because our game is going to be dependent on many assets like textures, images, fonts, and so on... But before I go into the implementation part we first need to install a couple of libraries which will help us with the task. The first one is going to be `async`, which will take care of managing the control flow of asynchronous code:\n\n    $ npm install async --save\n\nAnd the second library is going to be `inert`, which is a `HapiJS` plug-in which will give us the ability to serve files from local directories:\n\n    $ npm install inert --save\n\nNow that we're set, let's implement the `endpoints` routes batch:\n\n[{]: <helper> (diffStep 1.8)\n\n#### [Step 1.8: Add endpoints routes](https://github.com/DAB0mB/radial-snake/commit/9c22408)\n\n##### Added routes&#x2F;endpoints.js\n```diff\n@@ -0,0 +1,80 @@\n+â”Š  â”Š 1â”Šconst Pack = require(\"../package.json\");\n+â”Š  â”Š 2â”Š\n+â”Š  â”Š 3â”Šregister.attributes = {\n+â”Š  â”Š 4â”Š  name: \"endpoints\",\n+â”Š  â”Š 5â”Š  version: Pack.version\n+â”Š  â”Š 6â”Š};\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Šfunction register(server, options, next) {\n+â”Š  â”Š 9â”Š  // Scripts endpoint\n+â”Š  â”Š10â”Š  server.route({\n+â”Š  â”Š11â”Š    method: \"GET\",\n+â”Š  â”Š12â”Š    path: \"/scripts/{path*}\",\n+â”Š  â”Š13â”Š    handler: {\n+â”Š  â”Š14â”Š      directory: {\n+â”Š  â”Š15â”Š        path: \"./resources/scripts/\"\n+â”Š  â”Š16â”Š      }\n+â”Š  â”Š17â”Š    }\n+â”Š  â”Š18â”Š  });\n+â”Š  â”Š19â”Š\n+â”Š  â”Š20â”Š  // Style-sheets endpoint\n+â”Š  â”Š21â”Š  server.route({\n+â”Š  â”Š22â”Š    method: \"GET\",\n+â”Š  â”Š23â”Š    path: \"/styles/{path*}\",\n+â”Š  â”Š24â”Š    handler: {\n+â”Š  â”Š25â”Š      directory: {\n+â”Š  â”Š26â”Š        path: \"./resources/styles/\"\n+â”Š  â”Š27â”Š      }\n+â”Š  â”Š28â”Š    }\n+â”Š  â”Š29â”Š  });\n+â”Š  â”Š30â”Š\n+â”Š  â”Š31â”Š  // Libraries endpoint\n+â”Š  â”Š32â”Š  server.route({\n+â”Š  â”Š33â”Š    method: \"GET\",\n+â”Š  â”Š34â”Š    path: \"/libs/{path*}\",\n+â”Š  â”Š35â”Š    handler: {\n+â”Š  â”Š36â”Š      directory: {\n+â”Š  â”Š37â”Š        path: \"./resources/libs/\"\n+â”Š  â”Š38â”Š      }\n+â”Š  â”Š39â”Š    }\n+â”Š  â”Š40â”Š  });\n+â”Š  â”Š41â”Š\n+â”Š  â”Š42â”Š  // Images endpoint\n+â”Š  â”Š43â”Š  server.route({\n+â”Š  â”Š44â”Š    method: \"GET\",\n+â”Š  â”Š45â”Š    path: \"/images/{path*}\",\n+â”Š  â”Š46â”Š    handler: {\n+â”Š  â”Š47â”Š      directory: {\n+â”Š  â”Š48â”Š        path: \"./resources/images/\"\n+â”Š  â”Š49â”Š      }\n+â”Š  â”Š50â”Š    }\n+â”Š  â”Š51â”Š  });\n+â”Š  â”Š52â”Š\n+â”Š  â”Š53â”Š  // Textures endpoint\n+â”Š  â”Š54â”Š  server.route({\n+â”Š  â”Š55â”Š    method: \"GET\",\n+â”Š  â”Š56â”Š    path: \"/textures/{path*}\",\n+â”Š  â”Š57â”Š    handler: {\n+â”Š  â”Š58â”Š      directory: {\n+â”Š  â”Š59â”Š        path: \"./resources/assets/textures/\"\n+â”Š  â”Š60â”Š      }\n+â”Š  â”Š61â”Š    }\n+â”Š  â”Š62â”Š  });\n+â”Š  â”Š63â”Š\n+â”Š  â”Š64â”Š  // Fonts endpoint\n+â”Š  â”Š65â”Š  server.route({\n+â”Š  â”Š66â”Š    method: \"GET\",\n+â”Š  â”Š67â”Š    path: \"/fonts/{path*}\",\n+â”Š  â”Š68â”Š    handler: {\n+â”Š  â”Š69â”Š      directory: {\n+â”Š  â”Š70â”Š        path: \"./resources/assets/fonts/\"\n+â”Š  â”Š71â”Š      }\n+â”Š  â”Š72â”Š    }\n+â”Š  â”Š73â”Š  });\n+â”Š  â”Š74â”Š\n+â”Š  â”Š75â”Š  next();\n+â”Š  â”Š76â”Š}\n+â”Š  â”Š77â”Š\n+â”Š  â”Š78â”Šmodule.exports = {\n+â”Š  â”Š79â”Š  register\n+â”Š  â”Š80â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nThis module actually represents a classic structure of a `HapiJS` plug-in. It should export a `name` for debugging proposes, a `version`, and a `register` function, which will take care of registering extensions to our server; in this case, these are the endpoints routes. To make this plug-in (Or any other plug-in) work, we need to register it. The registration is an asynchronous operation, thus we gonna handle it using `async`:\n\n[{]: <helper> (diffStep 1.9)\n\n#### [Step 1.9: Register ednpoints routes](https://github.com/DAB0mB/radial-snake/commit/bba460f)\n\n##### Changed server.js\n```diff\n@@ -1,11 +1,23 @@\n+â”Š  â”Š 1â”Šconst Async = require(\"async\");\n â”Š 1â”Š 2â”Šconst Hapi = require(\"hapi\");\n+â”Š  â”Š 3â”Šconst Inert = require(\"inert\");\n+â”Š  â”Š 4â”Šconst Endpoints = require(\"./routes/endpoints\");\n â”Š 2â”Š 5â”Šconst IpGrabber = require(\"./helpers/ip_grabber\");\n â”Š 3â”Š 6â”Š\n â”Š 4â”Š 7â”Šlet localIp = IpGrabber.local();\n â”Š 5â”Š 8â”Šlet port = 8000;\n â”Š 6â”Š 9â”Š\n â”Š 7â”Š10â”Š// Initialize a new server\n-â”Š 8â”Š  â”Šlet server = new Hapi.Server();\n+â”Š  â”Š11â”Šlet server = new Hapi.Server({\n+â”Š  â”Š12â”Š  connections: {\n+â”Š  â”Š13â”Š    routes: {\n+â”Š  â”Š14â”Š      files: {\n+â”Š  â”Š15â”Š        // Served files will be relative to current directory\n+â”Š  â”Š16â”Š        relativeTo: __dirname\n+â”Š  â”Š17â”Š      }\n+â”Š  â”Š18â”Š    }\n+â”Š  â”Š19â”Š  }\n+â”Š  â”Š20â”Š});\n â”Š 9â”Š21â”Š\n â”Š10â”Š22â”Šserver.connection({ port: process.env.PORT || port });\n â”Š11â”Š23â”Š\n```\n```diff\n@@ -24,8 +36,14 @@\n â”Š24â”Š36â”Š  rep.continue();\n â”Š25â”Š37â”Š});\n â”Š26â”Š38â”Š\n+â”Š  â”Š39â”Š// Register all routes and plug-ins\n+â”Š  â”Š40â”ŠAsync.series([\n+â”Š  â”Š41â”Š  next => server.register(Inert, next),\n+â”Š  â”Š42â”Š  next => server.register(Endpoints, next),\n+â”Š  â”Š43â”Š  // Once registrations are finished, start the server\n+â”Š  â”Š44â”Š  next => server.start(next)\n â”Š27â”Š45â”Š// Print message once started\n-â”Š28â”Š  â”Šserver.start((err) => {\n+â”Š  â”Š46â”Š], (err) => {\n â”Š29â”Š47â”Š  if (err) throw err;\n â”Š30â”Š48â”Š\n â”Š31â”Š49â”Š  console.log();\n```\n\n[}]: #\n\nOnce all the plug-ins have been registered, we gonna start our server as we previously did. Note that we also registered the `inert` plug-in, because as I said earlier, that's what gives us the ability to handle files requests.\n\nLastly, I want to create the `pages` routes batch, which will be responsible for serving pages in our application as listed above:\n\n- The `/` route will serve us the `game.html` file.\n- The `/test` route will serve us the `spec_runner.html` file.\n\nBy the name of each route and file you can probably what each one should do. The thing is, we don't want everyone to be able to access the `spec_runner.html` file, or the `game.html` file if in the middle of development. For this, we're going to create a new helper which will be responsible for handling permissions. So first we gonna install an npm package called `boom` which has the ability to format `permission denied` HTTP errors:\n\n    $ npm install boom --save\n\nAnd now we gonna implement the module itself:\n\n[{]: <helper> (diffStep 1.11)\n\n#### [Step 1.11: Add permitter helper](https://github.com/DAB0mB/radial-snake/commit/d26a5d7)\n\n##### Added helpers&#x2F;permitter.js\n```diff\n@@ -0,0 +1,29 @@\n+â”Š  â”Š 1â”Šconst Boom = require(\"boom\");\n+â”Š  â”Š 2â”Šconst Hapi = require(\"hapi\");\n+â”Š  â”Š 3â”Šconst IpGrabber = require(\"./ip_grabber\");\n+â”Š  â”Š 4â”Š\n+â”Š  â”Š 5â”Š// These addresses will be permitted by default\n+â”Š  â”Š 6â”Šconst defaultPermissions = [\n+â”Š  â”Š 7â”Š  IpGrabber.local(), \"127.0.0.1\", \"localhost\"\n+â”Š  â”Š 8â”Š];\n+â”Š  â”Š 9â”Š\n+â”Š  â”Š10â”Š// Manage file permissions\n+â”Š  â”Š11â”Šfunction file(path, permissions, req, rep) {\n+â”Š  â”Š12â”Š  // Apply default permissions\n+â”Š  â”Š13â”Š  permissions = permissions.concat(defaultPermissions);\n+â”Š  â”Š14â”Š  // Request address\n+â”Š  â”Š15â”Š  let remoteAddress = req.info.remoteAddress;\n+â”Š  â”Š16â”Š\n+â”Š  â”Š17â”Š  // If not permitted, reply error\n+â”Š  â”Š18â”Š  if (permissions.indexOf(remoteAddress) == -1) {\n+â”Š  â”Š19â”Š    let err = new Boom.forbidden(\"Missing permissions\");\n+â”Š  â”Š20â”Š    return rep(err);\n+â”Š  â”Š21â”Š  }\n+â”Š  â”Š22â”Š\n+â”Š  â”Š23â”Š  // If permitted, reply file\n+â”Š  â”Š24â”Š  rep.file(path);\n+â”Š  â”Š25â”Š}\n+â”Š  â”Š26â”Š\n+â”Š  â”Š27â”Šmodule.exports = {\n+â”Š  â”Š28â”Š  file\n+â”Š  â”Š29â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nThe default permitted IP address would be the current computer's IP address. Extra IP permissions can be provided with the invocation of the `file` method. If the requesting IP is not listed in the permissions list, an error is gonna be replied instead of the requested file. Now that we have our \"permitter\" ready, let's implement the `pages` routes batch, only we're gonna pass the requests through the black-list, for the reason mentioned above:\n\n[{]: <helper> (diffStep 1.12)\n\n#### [Step 1.12: Add pages routes](https://github.com/DAB0mB/radial-snake/commit/11860e9)\n\n##### Added routes&#x2F;pages.js\n```diff\n@@ -0,0 +1,35 @@\n+â”Š  â”Š 1â”Šconst Hapi = require(\"hapi\");\n+â”Š  â”Š 2â”Šconst Pack = require(\"../package.json\");\n+â”Š  â”Š 3â”Šconst Permitter = require(\"../helpers/permitter\");\n+â”Š  â”Š 4â”Š\n+â”Š  â”Š 5â”Šregister.attributes = {\n+â”Š  â”Š 6â”Š  name: \"pages\",\n+â”Š  â”Š 7â”Š  version: Pack.version\n+â”Š  â”Š 8â”Š};\n+â”Š  â”Š 9â”Š\n+â”Š  â”Š10â”Šfunction register(server, options, next) {\n+â”Š  â”Š11â”Š  server.route({ method: \"GET\", path: \"/\", handler: getGame });\n+â”Š  â”Š12â”Š  server.route({ method: \"GET\", path: \"/test\", handler: getSpecRunner });\n+â”Š  â”Š13â”Š\n+â”Š  â”Š14â”Š  next();\n+â”Š  â”Š15â”Š}\n+â”Š  â”Š16â”Š\n+â”Š  â”Š17â”Š// Serve game page\n+â”Š  â”Š18â”Šfunction getGame(req, rep) {\n+â”Š  â”Š19â”Š  let path = \"./views/game.html\";\n+â”Š  â”Š20â”Š  let permissions = [];\n+â”Š  â”Š21â”Š\n+â”Š  â”Š22â”Š  Permitter.file(path, permissions, req, rep);\n+â”Š  â”Š23â”Š}\n+â”Š  â”Š24â”Š\n+â”Š  â”Š25â”Š// Serve test page\n+â”Š  â”Š26â”Šfunction getSpecRunner(req, rep) {\n+â”Š  â”Š27â”Š  let path = \"./views/spec_runner.html\";\n+â”Š  â”Š28â”Š  let permissions = [];\n+â”Š  â”Š29â”Š\n+â”Š  â”Š30â”Š  Permitter.file(path, permissions, req, rep);\n+â”Š  â”Š31â”Š}\n+â”Š  â”Š32â”Š\n+â”Š  â”Š33â”Šmodule.exports = {\n+â”Š  â”Š34â”Š  register\n+â”Š  â”Š35â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nNow the only thing left to do would be registering the plug-in we've just created:\n\n[{]: <helper> (diffStep 1.13)\n\n#### [Step 1.13: Register pages routes](https://github.com/DAB0mB/radial-snake/commit/ed50bef)\n\n##### Changed server.js\n```diff\n@@ -2,6 +2,7 @@\n â”Š2â”Š2â”Šconst Hapi = require(\"hapi\");\n â”Š3â”Š3â”Šconst Inert = require(\"inert\");\n â”Š4â”Š4â”Šconst Endpoints = require(\"./routes/endpoints\");\n+â”Š â”Š5â”Šconst Pages = require(\"./routes/pages\");\n â”Š5â”Š6â”Šconst IpGrabber = require(\"./helpers/ip_grabber\");\n â”Š6â”Š7â”Š\n â”Š7â”Š8â”Šlet localIp = IpGrabber.local();\n```\n```diff\n@@ -40,6 +41,7 @@\n â”Š40â”Š41â”ŠAsync.series([\n â”Š41â”Š42â”Š  next => server.register(Inert, next),\n â”Š42â”Š43â”Š  next => server.register(Endpoints, next),\n+â”Š  â”Š44â”Š  next => server.register(Pages, next),\n â”Š43â”Š45â”Š  // Once registrations are finished, start the server\n â”Š44â”Š46â”Š  next => server.start(next)\n â”Š45â”Š47â”Š// Print message once started\n```\n\n[}]: #\n\nAnd that's it for the current step! In the next steps we will start storing files and assets in our public directories and implement all the necessary scripts, so our server is not running in vain."
          },
          {
            "manualTitle": "Step 2: Creating a game engine basis",
            "stepRevision": "a3e901039dc5db535111da14305175182f9f346c",
            "manualView": "Like any other JavaScript-based application, we should have an entry view written in HTML. However, in our application, the only visible element is going to be an [HTMLCanvas](https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API). The canvas is exactly what it sounds like - a blank white surface which we can draw things on top of it. As we go further with this tutorial, we will learn more about the canvas and dive into its API and how to use it. Now that you got the general idea, let's create the HTML file:\n\n[{]: <helper> (diffStep 2.1)\n\n#### [Step 2.1: Create basic game view](https://github.com/DAB0mB/radial-snake/commit/254f06f)\n\n##### Added views&#x2F;game.html\n```diff\n@@ -0,0 +1,10 @@\n+â”Š  â”Š 1â”Š<!DOCTYPE html>\n+â”Š  â”Š 2â”Š<html>\n+â”Š  â”Š 3â”Š  <head>\n+â”Š  â”Š 4â”Š    <title>radial snake</title>\n+â”Š  â”Š 5â”Š  </head>\n+â”Š  â”Š 6â”Š\n+â”Š  â”Š 7â”Š  <body>\n+â”Š  â”Š 8â”Š    <canvas id=\"gameCanvas\" tabindex=\"0\"></canvas>\n+â”Š  â”Š 9â”Š  </body>\n+â”Š  â”Š10â”Š</html>ðŸš«â†µ\n```\n\n[}]: #\n\nIn the previous step we've already set the route for this file, so if you'd like to run the game, simply start the server by typing `npm run serve`, and navigate to the address presented on the screen (Should be `localhost:8000` by default).\n\n> From now on I'm going to assume the server is running in the background, so I won't repeat the instruction above\n\nJust to make sure that the canvas is visible and not blended into the background, we will draw a black border around using a simple style-sheet:\n\n[{]: <helper> (diffStep 2.2)\n\n#### [Step 2.2: Create basic game stylesheet](https://github.com/DAB0mB/radial-snake/commit/44fe5aa)\n\n##### Added resources&#x2F;styles&#x2F;game.css\n```diff\n@@ -0,0 +1,6 @@\n+â”Š â”Š1â”Š#gameCanvas {\n+â”Š â”Š2â”Š  display: block;\n+â”Š â”Š3â”Š  margin: auto;\n+â”Š â”Š4â”Š  border-style: solid;\n+â”Š â”Š5â”Š  border-width: 1px;\n+â”Š â”Š6â”Š}ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -2,6 +2,9 @@\n â”Š 2â”Š 2â”Š<html>\n â”Š 3â”Š 3â”Š  <head>\n â”Š 4â”Š 4â”Š    <title>radial snake</title>\n+â”Š  â”Š 5â”Š\n+â”Š  â”Š 6â”Š    <!-- Styles -->\n+â”Š  â”Š 7â”Š    <link rel=\"stylesheet\" type=\"text/css\" href=\"/styles/game.css\">\n â”Š 5â”Š 8â”Š  </head>\n â”Š 6â”Š 9â”Š\n â”Š 7â”Š10â”Š  <body>\n```\n\n[}]: #\n\n> Note that every asset we create should be declared in the HTML file in order for it to take effect\n\nTo build this project we're also gonna use two very famous utility libraries called [JQuery](http://jquery.com/) and [Underscore](http://underscorejs.org/) which will make our lives a bit easier. Third-party libraries should be located in a directory called `libs`, according to the routes-map we created in the previous step. To set these libraries up, type the following commands in series:\n\n    resources$ mkdir libs\n    resources$ cd libs\n    resources/libs$ wget raw.githubusercontent.com/dab0mb/radial-snake/master/resources/libs/underscore.js\n    resources/libs$ wget raw.githubusercontent.com/dab0mb/radial-snake/master/resources/libs/jquery-2.1.1.js\n\nAnd load them in the game's HTML file's header:\n\n[{]: <helper> (diffStep 2.3 files=\"views/game.html\")\n\n#### [Step 2.3: Add jquery and underscore libs](https://github.com/DAB0mB/radial-snake/commit/085ca6b)\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -3,6 +3,10 @@\n â”Š 3â”Š 3â”Š  <head>\n â”Š 4â”Š 4â”Š    <title>radial snake</title>\n â”Š 5â”Š 5â”Š\n+â”Š  â”Š 6â”Š    <!-- Libs -->\n+â”Š  â”Š 7â”Š    <script type=\"text/javascript\" src=\"/libs/jquery-2.1.1.js\"></script>\n+â”Š  â”Š 8â”Š    <script type=\"text/javascript\" src=\"/libs/underscore.js\"></script>\n+â”Š  â”Š 9â”Š\n â”Š 6â”Š10â”Š    <!-- Styles -->\n â”Š 7â”Š11â”Š    <link rel=\"stylesheet\" type=\"text/css\" href=\"/styles/game.css\">\n â”Š 8â”Š12â”Š  </head>\n```\n\n[}]: #\n\nNow, we're finally going to build the game engine. At first, it's gonna be very basic simple, but further in this tutorial we're going to extend it and add some pretty neat features. When creating an application, of any kind, you don't want to garbage the global scope, so it can stay clean without any conflicts. Therefore, we're going to create an initial namespace for our game engine called `Engine`, which is going to contain all our game engine's classes and entities:\n\n[{]: <helper> (diffStep 2.4)\n\n#### [Step 2.4: Add engine namespace](https://github.com/DAB0mB/radial-snake/commit/3d52525)\n\n##### Added resources&#x2F;scripts&#x2F;namespaces.js\n```diff\n@@ -0,0 +1 @@\n+â”Š â”Š1â”ŠEngine = {};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -7,6 +7,9 @@\n â”Š 7â”Š 7â”Š    <script type=\"text/javascript\" src=\"/libs/jquery-2.1.1.js\"></script>\n â”Š 8â”Š 8â”Š    <script type=\"text/javascript\" src=\"/libs/underscore.js\"></script>\n â”Š 9â”Š 9â”Š\n+â”Š  â”Š10â”Š    <!-- Scripts -->\n+â”Š  â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n+â”Š  â”Š12â”Š\n â”Š10â”Š13â”Š    <!-- Styles -->\n â”Š11â”Š14â”Š    <link rel=\"stylesheet\" type=\"text/css\" href=\"/styles/game.css\">\n â”Š12â”Š15â”Š  </head>\n```\n\n[}]: #\n\nThe first thing we're going to define in the namespace we've just created would be the game loop. The game loop is the central code of your game, split into different parts. Generally, these are: update and draw.\n\nThe main purpose of the update phase is to prepare all objects to be drawn, so this is where all the geometry code, coordinate updates, score changes, animation refreshments and other similar operations belong. This is also where the input will be captured and processed.\n\nWhen everything is properly updated and ready, we enter the draw phase where all this information is put on the screen. This function should contain all the code to manage and draw the levels, shapes, score board and so on.\n\n![game-loop](https://cloud.githubusercontent.com/assets/7648874/21332964/4b80ef4e-c633-11e6-946a-0c5870d2f9c9.png)\n\n> You can find plenty of details and information about what \"game loop\" means simply by typing in on Google.\n\nA game loop can wear many forms, but the concept is gonna be the same, plus-minus. This is how our game loop is going to loop like:\n\n[{]: <helper> (diffStep 2.5)\n\n#### [Step 2.5: Create a game basis](https://github.com/DAB0mB/radial-snake/commit/1b7fcf9)\n\n##### Added resources&#x2F;scripts&#x2F;engine&#x2F;game.js\n```diff\n@@ -0,0 +1,99 @@\n+â”Š  â”Š 1â”ŠEngine.Game = class Game {\n+â”Š  â”Š 2â”Š  // The frequency of which each frame will be drawn in milliseconds\n+â”Š  â”Š 3â”Š  get fps() {\n+â”Š  â”Š 4â”Š    return 1000 / 60;\n+â”Š  â”Š 5â”Š  }\n+â”Š  â”Š 6â”Š\n+â”Š  â”Š 7â”Š  // Game's run speed.\n+â”Š  â”Š 8â”Š  // A lower value will make it run slower and a higher value will make it run faster\n+â”Š  â”Š 9â”Š  get speed() {\n+â”Š  â”Š10â”Š    return 1;\n+â”Š  â”Š11â”Š  }\n+â”Š  â”Š12â”Š\n+â”Š  â”Š13â”Š  constructor(canvas) {\n+â”Š  â”Š14â”Š    this.canvas = canvas;\n+â”Š  â”Š15â”Š    this.lastUpdate = this.creation = new Date().getTime();\n+â”Š  â”Š16â”Š\n+â”Š  â”Š17â”Š    // Canvas dimensions must be set programmatically otherwise you might encounter some\n+â”Š  â”Š18â”Š    // unexpected behaviors\n+â”Š  â”Š19â”Š    canvas.width = 1280;\n+â”Š  â”Š20â”Š    canvas.height = 720;\n+â”Š  â”Š21â”Š    // Canvas will be focused once game page is loaded so all events will automatically\n+â”Š  â”Š22â”Š    // be captured by it\n+â”Š  â”Š23â”Š    canvas.focus();\n+â”Š  â”Š24â”Š\n+â”Š  â”Š25â”Š    // We want to focus on the canvas once we press on it\n+â”Š  â”Š26â”Š    canvas.addEventListener(\"mousedown\", canvas.focus.bind(canvas), false);\n+â”Š  â”Š27â”Š\n+â”Š  â”Š28â”Š    this.assets = {};\n+â”Š  â”Š29â”Š    this.events = new Map();\n+â”Š  â”Š30â”Š    this.context = canvas.getContext(\"2d\");\n+â”Š  â”Š31â”Š    this.bufferedCanvas = document.createElement(\"canvas\");\n+â”Š  â”Š32â”Š    this.bufferedContext = this.bufferedCanvas.getContext(\"2d\");\n+â”Š  â”Š33â”Š    this.bufferedCanvas.width = canvas.width;\n+â”Š  â”Š34â”Š    this.bufferedCanvas.height = canvas.height;\n+â”Š  â”Š35â”Š  }\n+â”Š  â”Š36â”Š\n+â”Š  â”Š37â”Š  draw() {\n+â”Š  â”Š38â”Š    // Draw a black screen by default\n+â”Š  â”Š39â”Š    this.context.restore();\n+â”Š  â”Š40â”Š    this.context.fillStyle = \"black\";\n+â”Š  â”Š41â”Š    this.context.save();\n+â”Š  â”Š42â”Š    this.context.beginPath();\n+â”Š  â”Š43â”Š    this.context.rect(0, 0, this.canvas.width, this.canvas.height);\n+â”Š  â”Š44â”Š    this.context.fill();\n+â”Š  â”Š45â”Š  }\n+â”Š  â”Š46â”Š\n+â”Š  â”Š47â”Š  update() {\n+â”Š  â”Š48â”Š    // Calculate the time elapsed\n+â”Š  â”Š49â”Š    let lastUpdate = this.lastUpdate;\n+â”Š  â”Š50â”Š    let currUpdate = this.lastUpdate = new Date().getTime();\n+â”Š  â”Š51â”Š    let span = currUpdate - lastUpdate;\n+â”Š  â”Š52â”Š    this.updateScreen(span / this.speed);\n+â”Š  â”Š53â”Š  }\n+â”Š  â”Š54â”Š\n+â”Š  â”Š55â”Š  // The main loop of the game\n+â”Š  â”Š56â”Š  loop() {\n+â”Š  â”Š57â”Š    // If paused, don't run loop. The canvas will remain as is\n+â”Š  â”Š58â”Š    if (!this.playing) return;\n+â”Š  â”Š59â”Š\n+â”Š  â”Š60â”Š    setTimeout(() => {\n+â”Š  â”Š61â”Š      this.draw();\n+â”Š  â”Š62â”Š      this.update();\n+â”Š  â”Š63â”Š      this.loop();\n+â”Š  â”Š64â”Š    }, this.fps);\n+â”Š  â”Š65â”Š  }\n+â”Š  â”Š66â”Š\n+â”Š  â”Š67â”Š  play() {\n+â”Š  â”Š68â”Š    this.playing = true;\n+â”Š  â”Š69â”Š    this.loop();\n+â”Š  â”Š70â”Š  }\n+â”Š  â”Š71â”Š\n+â”Š  â”Š72â”Š  pause() {\n+â”Š  â”Š73â”Š    this.playing = false;\n+â”Š  â”Š74â”Š  }\n+â”Š  â”Š75â”Š\n+â”Š  â”Š76â”Š  // Defines global assets\n+â”Š  â”Š77â”Š  extendAssets(assets) {\n+â”Š  â”Š78â”Š    _.extend(this.assets, assets);\n+â”Š  â”Š79â”Š  }\n+â”Š  â”Š80â”Š\n+â”Š  â”Š81â”Š  // Disposes global assets\n+â”Š  â”Š82â”Š  clearAssets() {\n+â”Š  â”Š83â”Š    this.assets = {};\n+â”Š  â”Š84â”Š  }\n+â”Š  â”Š85â”Š\n+â”Š  â”Š86â”Š  // Adds event listener for game canvas\n+â”Š  â”Š87â”Š  addEventListener(type, listener, target) {\n+â”Š  â”Š88â”Š    let boundListener = listener.bind(target);\n+â”Š  â”Š89â”Š    this.events.set(listener, boundListener);\n+â”Š  â”Š90â”Š    this.canvas.addEventListener(type, boundListener, false);\n+â”Š  â”Š91â”Š  }\n+â”Š  â”Š92â”Š\n+â”Š  â”Š93â”Š  // Removes event listener from game canvas\n+â”Š  â”Š94â”Š  removeEventListener(type, listener) {\n+â”Š  â”Š95â”Š    let boundListener = this.events.get(listener);\n+â”Š  â”Š96â”Š    this.events.delete(listener);\n+â”Š  â”Š97â”Š    this.canvas.removeEventListener(type, boundListener, false);\n+â”Š  â”Š98â”Š  }\n+â”Š  â”Š99â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -9,6 +9,7 @@\n â”Š 9â”Š 9â”Š\n â”Š10â”Š10â”Š    <!-- Scripts -->\n â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n+â”Š  â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š12â”Š13â”Š\n â”Š13â”Š14â”Š    <!-- Styles -->\n â”Š14â”Š15â”Š    <link rel=\"stylesheet\" type=\"text/css\" href=\"/styles/game.css\">\n```\n\n[}]: #\n\nThe only thing it's doing right now is drawing a black background, but we're soon going to learn how to take advantage of this game-loop to draw stuff of our own. I'd like to point out that there is no need to implement a [double-buffer](https://en.wikipedia.org/wiki/Multiple_buffering) (A method similar to React's [virtual DOM](https://www.npmjs.com/package/react-dom)) when it comes to `HTMLCanvas` elements, since `HTML5` already does that for us. To start running the game, we first need to wait for the DOM content to initialize, and once it's ready we gonna create a new game instance and call the `play` method:\n\n[{]: <helper> (diffStep 2.6)\n\n#### [Step 2.6: Create game entry point](https://github.com/DAB0mB/radial-snake/commit/30e75df)\n\n##### Added resources&#x2F;scripts&#x2F;main.js\n```diff\n@@ -0,0 +1,4 @@\n+â”Š â”Š1â”Šdocument.addEventListener(\"DOMContentLoaded\", function(event) {\n+â”Š â”Š2â”Š  let game = new Engine.Game(document.getElementById(\"gameCanvas\"), false);\n+â”Š â”Š3â”Š  game.play();\n+â”Š â”Š4â”Š});ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -10,6 +10,7 @@\n â”Š10â”Š10â”Š    <!-- Scripts -->\n â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n â”Š12â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n+â”Š  â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n â”Š13â”Š14â”Š\n â”Š14â”Š15â”Š    <!-- Styles -->\n â”Š15â”Š16â”Š    <link rel=\"stylesheet\" type=\"text/css\" href=\"/styles/game.css\">\n```\n\n[}]: #\n\nThis will take control over the canvas and will draw a new picture every 17ms, which is 60fps (Frames per second). As for now you're only going to see a black canvas, but I promise the final result is not going to disappoint you.\n\nThe next thing we're gonna do would be adding a 'key state' manager, which will store a flag for each key pressed on the keyboard. Once we press the key, the flag's value would be `true`, and once we release it, its value would turn into `false`. This way we have an easy way to track all the key presses without registering a specific event listener for each key press we wanna track:\n\n[{]: <helper> (diffStep 2.7)\n\n#### [Step 2.7: Add key states manager](https://github.com/DAB0mB/radial-snake/commit/831b058)\n\n##### Added resources&#x2F;scripts&#x2F;engine&#x2F;key_states.js\n```diff\n@@ -0,0 +1,20 @@\n+â”Š  â”Š 1â”ŠEngine.KeyStates = class KeyStates {\n+â”Š  â”Š 2â”Š  constructor() {\n+â”Š  â”Š 3â”Š    // We will have 255 states, each one represents an ascii code matching its index\n+â”Š  â”Š 4â”Š    this.states = new Array(255);\n+â”Š  â”Š 5â”Š  }\n+â”Š  â”Š 6â”Š\n+â”Š  â”Š 7â”Š  get(k) {\n+â”Š  â”Š 8â”Š    return this.states[k];\n+â”Š  â”Š 9â”Š  }\n+â”Š  â”Š10â”Š\n+â”Š  â”Š11â”Š  // This should be called once we press a key\n+â”Š  â”Š12â”Š  add(k) {\n+â”Š  â”Š13â”Š    this.states[k] = true;\n+â”Š  â”Š14â”Š  }\n+â”Š  â”Š15â”Š\n+â”Š  â”Š16â”Š  // This should be called once we release a key\n+â”Š  â”Š17â”Š  remove(k) {\n+â”Š  â”Š18â”Š    this.states[k] = false;\n+â”Š  â”Š19â”Š  }\n+â”Š  â”Š20â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -9,6 +9,7 @@\n â”Š 9â”Š 9â”Š\n â”Š10â”Š10â”Š    <!-- Scripts -->\n â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n+â”Š  â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/key_states.js\"></script>\n â”Š12â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n```\n\n[}]: #\n\nNow that we have the key state manager, we will initialize a new instance as part of our game's essentials, and we will create a global event listener for key presses; Each time a key is pressed, the key state manager will update itself:\n\n[{]: <helper> (diffStep 2.8)\n\n#### [Step 2.8: Register key presses](https://github.com/DAB0mB/radial-snake/commit/9f55501)\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;game.js\n```diff\n@@ -14,7 +14,7 @@\n â”Š14â”Š14â”Š    this.canvas = canvas;\n â”Š15â”Š15â”Š    this.lastUpdate = this.creation = new Date().getTime();\n â”Š16â”Š16â”Š\n-â”Š17â”Š  â”Š    // Canvas dimensions must be set programmatically otherwise you might encounter some\n+â”Š  â”Š17â”Š    // Canvas dimensions must be set programmatically, otherwise you might encounter some\n â”Š18â”Š18â”Š    // unexpected behaviors\n â”Š19â”Š19â”Š    canvas.width = 1280;\n â”Š20â”Š20â”Š    canvas.height = 720;\n```\n```diff\n@@ -24,9 +24,13 @@\n â”Š24â”Š24â”Š\n â”Š25â”Š25â”Š    // We want to focus on the canvas once we press on it\n â”Š26â”Š26â”Š    canvas.addEventListener(\"mousedown\", canvas.focus.bind(canvas), false);\n+â”Š  â”Š27â”Š    // Key flags will be registered by the \"KeyStates\" instance\n+â”Š  â”Š28â”Š    canvas.addEventListener(\"keydown\", onKeyDown.bind(this), false);\n+â”Š  â”Š29â”Š    canvas.addEventListener(\"keyup\", onKeyUp.bind(this), false);\n â”Š27â”Š30â”Š\n â”Š28â”Š31â”Š    this.assets = {};\n â”Š29â”Š32â”Š    this.events = new Map();\n+â”Š  â”Š33â”Š    this.keyStates = new Engine.KeyStates();\n â”Š30â”Š34â”Š    this.context = canvas.getContext(\"2d\");\n â”Š31â”Š35â”Š    this.bufferedCanvas = document.createElement(\"canvas\");\n â”Š32â”Š36â”Š    this.bufferedContext = this.bufferedCanvas.getContext(\"2d\");\n```\n```diff\n@@ -96,4 +100,19 @@\n â”Š 96â”Š100â”Š    this.events.delete(listener);\n â”Š 97â”Š101â”Š    this.canvas.removeEventListener(type, boundListener, false);\n â”Š 98â”Š102â”Š  }\n-â”Š 99â”Š   â”Š};ðŸš«â†µ\n+â”Š   â”Š103â”Š};\n+â”Š   â”Š104â”Š\n+â”Š   â”Š105â”Šfunction onKeyDown(e) {\n+â”Š   â”Š106â”Š  // Once we're focused on the canvas, we want nothing else to happen\n+â”Š   â”Š107â”Š  // besides events the game is listening to. For example, when we press\n+â”Š   â”Š108â”Š  // the arrow keys, this will prevent the screen from scrolling\n+â”Š   â”Š109â”Š  e.preventDefault();\n+â”Š   â”Š110â”Š  // Register key press\n+â”Š   â”Š111â”Š  this.keyStates.add(e.keyCode);\n+â”Š   â”Š112â”Š}\n+â”Š   â”Š113â”Š\n+â”Š   â”Š114â”Šfunction onKeyUp(e) {\n+â”Š   â”Š115â”Š  e.preventDefault();\n+â”Š   â”Š116â”Š  // Register key release\n+â”Š   â”Š117â”Š  this.keyStates.remove(e.keyCode);\n+â”Š   â”Š118â”Š}\n```\n\n[}]: #\n\nA 2D game's view might get complex as we go through with its development and add more logic and entities into it. Having only one `draw` method and only one `update` method is not enough, and if you think of it, it might easily get buffed up into ridiculous dimensions, which is not the way to go. I'd like to introduce you into a new methodology which involves `screens` and `layers`:\n\n- **screen** - Will literally be used whenever we want to show a new screen in our game e.g. 'splash' screen and 'main menu' screen. A screen consists of multiple layers, and will be used as their communicator; All the relevant assets and logic will be initialized inside it.\n- **layer** - similar to Photoshop's layer system, any time we want to add something to the view we add new layers on top or beneath of each other.\n\n![screen-layer](https://cloud.githubusercontent.com/assets/7648874/21487708/9b366efe-cbb7-11e6-8669-3212e440871a.png)\n\nAs I said earlier, the purpose of the screens and the layers is just to split the task of updating and drawing and updating, so we can have logical segments; So the `layer` class should mainly consist of a `draw` and an `update` method:\n\n[{]: <helper> (diffStep 2.9)\n\n#### [Step 2.9: Add screen layer](https://github.com/DAB0mB/radial-snake/commit/736ab08)\n\n##### Added resources&#x2F;scripts&#x2F;engine&#x2F;layer.js\n```diff\n@@ -0,0 +1,43 @@\n+â”Š  â”Š 1â”ŠEngine.Layer = class Layer {\n+â”Š  â”Š 2â”Š  // The dimensions of the layer are correlated to dimensions of the canvas\n+â”Š  â”Š 3â”Š  get width() {\n+â”Š  â”Š 4â”Š    return this.canvas.width;\n+â”Š  â”Š 5â”Š  }\n+â”Š  â”Š 6â”Š\n+â”Š  â”Š 7â”Š  get height() {\n+â”Š  â”Š 8â”Š    return this.canvas.height;\n+â”Š  â”Š 9â”Š  }\n+â”Š  â”Š10â”Š\n+â”Š  â”Š11â”Š  // A hash of \"eventName\" : \"handlerName\" which should be overrided by user\n+â”Š  â”Š12â”Š  get events() {\n+â”Š  â”Š13â”Š    return {};\n+â”Š  â”Š14â”Š  }\n+â”Š  â”Š15â”Š\n+â”Š  â”Š16â”Š  constructor(screen) {\n+â”Š  â”Š17â”Š    this.age = 0;\n+â”Š  â”Š18â”Š    this.creation = new Date().getTime();\n+â”Š  â”Š19â”Š    this.screen = screen;\n+â”Š  â”Š20â”Š    this.game = screen.game;\n+â”Š  â”Š21â”Š    this.assets = screen.assets;\n+â”Š  â”Š22â”Š    this.keyStates = screen.keyStates;\n+â”Š  â”Š23â”Š    this.canvas = screen.game.canvas;\n+â”Š  â”Š24â”Š  }\n+â”Š  â”Š25â”Š\n+â”Š  â”Š26â”Š  update(span) {\n+â”Š  â”Š27â”Š  }\n+â”Š  â”Š28â”Š\n+â”Š  â”Š29â”Š  draw(context) {\n+â”Š  â”Š30â”Š  }\n+â”Š  â”Š31â”Š\n+â”Š  â”Š32â”Š  initEventListeners() {\n+â”Š  â”Š33â”Š    _.each(this.events, (listener, event) => {\n+â”Š  â”Š34â”Š      this.game.addEventListener(event, this[listener], this);\n+â”Š  â”Š35â”Š    });\n+â”Š  â”Š36â”Š  }\n+â”Š  â”Š37â”Š\n+â”Š  â”Š38â”Š  disposeEventListeners() {\n+â”Š  â”Š39â”Š    _.each(this.events, (listener, event) => {\n+â”Š  â”Š40â”Š      this.game.removeEventListener(event, this[listener]);\n+â”Š  â”Š41â”Š    });\n+â”Š  â”Š42â”Š  }\n+â”Š  â”Š43â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -10,6 +10,7 @@\n â”Š10â”Š10â”Š    <!-- Scripts -->\n â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n â”Š12â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/key_states.js\"></script>\n+â”Š  â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/layer.js\"></script>\n â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š14â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n```\n\n[}]: #\n\nSame thing for the screen, it only has a `draw` and `update` methods, only it has a stack of layers, which can either be added or removed:\n\n[{]: <helper> (diffStep 2.1)\n\n#### [Step 2.1: Create basic game view](https://github.com/DAB0mB/radial-snake/commit/254f06f)\n\n##### Added views&#x2F;game.html\n```diff\n@@ -0,0 +1,10 @@\n+â”Š  â”Š 1â”Š<!DOCTYPE html>\n+â”Š  â”Š 2â”Š<html>\n+â”Š  â”Š 3â”Š  <head>\n+â”Š  â”Š 4â”Š    <title>radial snake</title>\n+â”Š  â”Š 5â”Š  </head>\n+â”Š  â”Š 6â”Š\n+â”Š  â”Š 7â”Š  <body>\n+â”Š  â”Š 8â”Š    <canvas id=\"gameCanvas\" tabindex=\"0\"></canvas>\n+â”Š  â”Š 9â”Š  </body>\n+â”Š  â”Š10â”Š</html>ðŸš«â†µ\n```\n\n[}]: #\n\nNow that we have the `screen` class available for us, let's apply it to the main game loop:\n\n[{]: <helper> (diffStep 2.11)\n\n#### [Step 2.11: Draw and update screen in game loop](https://github.com/DAB0mB/radial-snake/commit/9f34754)\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;game.js\n```diff\n@@ -30,6 +30,7 @@\n â”Š30â”Š30â”Š\n â”Š31â”Š31â”Š    this.assets = {};\n â”Š32â”Š32â”Š    this.events = new Map();\n+â”Š  â”Š33â”Š    this.screen = new Engine.Screen(this);\n â”Š33â”Š34â”Š    this.keyStates = new Engine.KeyStates();\n â”Š34â”Š35â”Š    this.context = canvas.getContext(\"2d\");\n â”Š35â”Š36â”Š    this.bufferedCanvas = document.createElement(\"canvas\");\n```\n```diff\n@@ -46,6 +47,13 @@\n â”Š46â”Š47â”Š    this.context.beginPath();\n â”Š47â”Š48â”Š    this.context.rect(0, 0, this.canvas.width, this.canvas.height);\n â”Š48â”Š49â”Š    this.context.fill();\n+â”Š  â”Š50â”Š    this.drawScreen(this.context);\n+â”Š  â”Š51â”Š  }\n+â”Š  â”Š52â”Š\n+â”Š  â”Š53â”Š  drawScreen(context) {\n+â”Š  â”Š54â”Š    // If screen's assets are not yet loaded, don't draw it\n+â”Š  â”Š55â”Š    if (this.screen.loading) return;\n+â”Š  â”Š56â”Š    if (this.screen.draw) this.screen.draw(context);\n â”Š49â”Š57â”Š  }\n â”Š50â”Š58â”Š\n â”Š51â”Š59â”Š  update() {\n```\n```diff\n@@ -56,6 +64,13 @@\n â”Š56â”Š64â”Š    this.updateScreen(span / this.speed);\n â”Š57â”Š65â”Š  }\n â”Š58â”Š66â”Š\n+â”Š  â”Š67â”Š  updateScreen(span) {\n+â”Š  â”Š68â”Š    this.screen.age += span;\n+â”Š  â”Š69â”Š    // If screen's assets are not yet loaded, don't update it\n+â”Š  â”Š70â”Š    if (this.screen.loading) return;\n+â”Š  â”Š71â”Š    if (this.screen.update) this.screen.update(span);\n+â”Š  â”Š72â”Š  }\n+â”Š  â”Š73â”Š\n â”Š59â”Š74â”Š  // The main loop of the game\n â”Š60â”Š75â”Š  loop() {\n â”Š61â”Š76â”Š    // If paused, don't run loop. The canvas will remain as is\n```\n\n[}]: #\n\nThis step looks kind of useless for now, unless we will have the ability to change screens as we please. Any time a screen is changed, it should be loaded with its necessary assets e.g textures, sounds, fonts, etc. The assets loading is an asynchronous operation whose logic might get a bit messy if not managed properly. To make it easier, we're going to define an assets loader, which will help us load assets asynchronously:\n\n[{]: <helper> (diffStep 2.12)\n\n#### [Step 2.12: Add assets loader](https://github.com/DAB0mB/radial-snake/commit/d8895f8)\n\n##### Added resources&#x2F;scripts&#x2F;engine&#x2F;assets_loader.js\n```diff\n@@ -0,0 +1,13 @@\n+â”Š  â”Š 1â”ŠEngine.AssetsLoader = class AssetsLoader {\n+â”Š  â”Š 2â”Š  constructor(next) {\n+â”Š  â”Š 3â”Š    this.next = next;\n+â”Š  â”Š 4â”Š  }\n+â”Š  â”Š 5â”Š\n+â”Š  â”Š 6â”Š  // Load texture\n+â”Š  â”Š 7â”Š  texture(path) {\n+â”Š  â”Š 8â”Š    let image = new Image();\n+â”Š  â”Š 9â”Š    image.onload = this.next();\n+â”Š  â”Š10â”Š    image.src = `${path}.png`;\n+â”Š  â”Š11â”Š    return image;\n+â”Š  â”Š12â”Š  }\n+â”Š  â”Š13â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -12,6 +12,7 @@\n â”Š12â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/key_states.js\"></script>\n â”Š13â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/layer.js\"></script>\n â”Š14â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/screen.js\"></script>\n+â”Š  â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/assets_loader.js\"></script>\n â”Š15â”Š16â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š16â”Š17â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n```\n\n[}]: #\n\n> As for now the `assets loader` only has the ability to load textures, but we will extend it as we go further in this tutorial, no need to overdo it.\n\nNow that we have the `assets loader` we can add the ability to change a screen. Whenever we change a screen, the old screen's assets should be unloaded, and the new screen's assets should be loaded using the `assets loader`:\n\n[{]: <helper> (diffStep 2.13)\n\n#### [Step 2.13: Add the ability to change and load screen](https://github.com/DAB0mB/radial-snake/commit/90aab03)\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;game.js\n```diff\n@@ -92,6 +92,61 @@\n â”Š 92â”Š 92â”Š    this.playing = false;\n â”Š 93â”Š 93â”Š  }\n â”Š 94â”Š 94â”Š\n+â”Š   â”Š 95â”Š  changeScreen(Screen, ...screenArgs) {\n+â”Š   â”Š 96â”Š    // If there is a screen defined, dispose it first\n+â”Š   â”Š 97â”Š    if (this.screen) {\n+â”Š   â”Š 98â”Š      this.unloadScreen();\n+â”Š   â”Š 99â”Š      this.screen.disposeEventListeners();\n+â”Š   â”Š100â”Š    }\n+â”Š   â”Š101â”Š\n+â”Š   â”Š102â”Š    this.screen = new Screen(this, ...screenArgs);\n+â”Š   â”Š103â”Š\n+â”Š   â”Š104â”Š    // Load screen assets\n+â”Š   â”Š105â”Š    this.loadScreen(() => {\n+â”Š   â”Š106â”Š      // Once assets are loaded, initialize event listeners\n+â”Š   â”Š107â”Š      this.screen.initEventListeners();\n+â”Š   â”Š108â”Š      // The \"initialize\" method is exactly the same as the constructor, only it runs\n+â”Š   â”Š109â”Š      // once assets are available and event listeners are registered\n+â”Š   â”Š110â”Š      this.screen.initialize(this, ...screenArgs);\n+â”Š   â”Š111â”Š    });\n+â”Š   â”Š112â”Š  }\n+â”Š   â”Š113â”Š\n+â”Š   â”Š114â”Š  // Loads screen assets and invokes callback once loading is finished\n+â”Š   â”Š115â”Š  loadScreen(callback = _.noop) {\n+â”Š   â”Š116â”Š    if (!this.screen.load) return callback();\n+â”Š   â”Š117â”Š\n+â”Š   â”Š118â”Š    this.screen.loading = true;\n+â”Š   â”Š119â”Š    // The number of assets to load\n+â”Š   â”Š120â”Š    let loadsize = 0;\n+â”Š   â”Š121â”Š    let onload;\n+â”Š   â”Š122â”Š\n+â”Š   â”Š123â”Š    // This object can load assets\n+â”Š   â”Š124â”Š    let assetsLoader = new Engine.AssetsLoader(() => {\n+â”Š   â”Š125â”Š      loadsize++;\n+â”Š   â”Š126â”Š      return () => onload();\n+â”Š   â”Š127â”Š    });\n+â”Š   â”Š128â”Š\n+â”Š   â”Š129â”Š    // The \"load\" method returns the assets loaded by the screen\n+â”Š   â”Š130â”Š    let screenAssets = this.screen.load(assetsLoader);\n+â”Š   â”Š131â”Š\n+â”Š   â”Š132â”Š    // We use the \"after\" method because we want the following callback to be invoked\n+â”Š   â”Š133â”Š    // only once all assets are loaded\n+â”Š   â”Š134â”Š    onload = _.after(loadsize, () => {\n+â”Š   â”Š135â”Š      delete this.screen.loading;\n+â”Š   â”Š136â”Š      callback();\n+â”Š   â”Š137â”Š    });\n+â”Š   â”Š138â”Š\n+â”Š   â”Š139â”Š    // The returned assets will be available on screen's assets object\n+â”Š   â”Š140â”Š    _.extend(this.screen.assets, screenAssets);\n+â”Š   â”Š141â”Š  }\n+â”Š   â”Š142â”Š\n+â”Š   â”Š143â”Š  // Disposes screen assets\n+â”Š   â”Š144â”Š  unloadScreen() {\n+â”Š   â”Š145â”Š    if (!this.screen.unload) return;\n+â”Š   â”Š146â”Š    let assetsNames = this.screen.unload();\n+â”Š   â”Š147â”Š    _.omit(this.assets, assetsNames);\n+â”Š   â”Š148â”Š  }\n+â”Š   â”Š149â”Š\n â”Š 95â”Š150â”Š  // Defines global assets\n â”Š 96â”Š151â”Š  extendAssets(assets) {\n â”Š 97â”Š152â”Š    _.extend(this.assets, assets);\n```\n\n[}]: #\n\nLet's add a test screen just so we can get the hang of it. The test screen will only print a message to the canvas:\n\n[{]: <helper> (diffStep 2.14)\n\n#### [Step 2.14: Add test screen](https://github.com/DAB0mB/radial-snake/commit/85776e8)\n\n##### Added resources&#x2F;scripts&#x2F;test_screen.js\n```diff\n@@ -0,0 +1,10 @@\n+â”Š  â”Š 1â”Šclass TestScreen extends Engine.Screen {\n+â”Š  â”Š 2â”Š  draw(context) {\n+â”Š  â”Š 3â”Š    // A 20px sized \"Georgia\" font (Available natively)\n+â”Š  â”Š 4â”Š    context.font = \"20px Georgia\";\n+â”Š  â”Š 5â”Š    // The text should be colored white\n+â”Š  â”Š 6â”Š    context.fillStyle = \"white\";\n+â”Š  â”Š 7â”Š    // Draw the following message 50px from the left and 50px from the top\n+â”Š  â”Š 8â”Š    context.fillText(\"This is a Test Screen\", 50, 50);\n+â”Š  â”Š 9â”Š  }\n+â”Š  â”Š10â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -14,6 +14,7 @@\n â”Š14â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/screen.js\"></script>\n â”Š15â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/assets_loader.js\"></script>\n â”Š16â”Š16â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n+â”Š  â”Š17â”Š    <script type=\"text/javascript\" src=\"/scripts/test_screen.js\"></script>\n â”Š17â”Š18â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n â”Š18â”Š19â”Š\n â”Š19â”Š20â”Š    <!-- Styles -->\n```\n\n[}]: #\n\nNow we will use the test screen by changing to it as we create an instance of the game:\n\n[{]: <helper> (diffStep 2.15)\n\n#### [Step 2.15: Set test screen as the initial screen](https://github.com/DAB0mB/radial-snake/commit/203d084)\n\n##### Changed resources&#x2F;scripts&#x2F;main.js\n```diff\n@@ -1,4 +1,5 @@\n â”Š1â”Š1â”Šdocument.addEventListener(\"DOMContentLoaded\", function(event) {\n â”Š2â”Š2â”Š  let game = new Engine.Game(document.getElementById(\"gameCanvas\"), false);\n+â”Š â”Š3â”Š  game.changeScreen(TestScreen);\n â”Š3â”Š4â”Š  game.play();\n â”Š4â”Š5â”Š});ðŸš«â†µ\n```\n\n[}]: #\n\nOnce you will load the application you should see a black canvas with a white text saying:\n\n    This is a test screen\n\nIt means our screen system works and you may proceed to the next step, where we're gonna create our first screen :-)"
          },
          {
            "manualTitle": "Step 3: Creating a splash screen using a keyframe animation engine",
            "stepRevision": "4b2431bbc910f8945e5fd86aa964fec3ede8761c",
            "manualView": "![snake-demo-splash-small](https://cloud.githubusercontent.com/assets/7648874/21074086/a19fa9ce-bed6-11e6-9060-2ce94c215712.gif)\n\nIn this step we will be creating the `splash` screen - the initial screen that should be shown once we launch the game. Our splash is consisted of a random logo animation as presented in the `gif` file above. The \"splash\" effect can be achieved using 2 concepts:\n\n- A sprite class - Which will present the logo texture in different dimensions, angles and rotations.\n- A key-frame animation - Which will draw an animation automatically along the time axis using key-frames - each is a sprite representation of the texture in a specific time point.\n\nSo first thing first, we will start by implementing the sprite class:\n\n[{]: <helper> (diffStep 3.1)\n\n#### [Step 3.1: Create &#x27;Sprite&#x27; class](https://github.com/DAB0mB/radial-snake/commit/a32a711)\n\n##### Added resources&#x2F;scripts&#x2F;engine&#x2F;sprite.js\n```diff\n@@ -0,0 +1,58 @@\n+â”Š  â”Š 1â”ŠEngine.Sprite = class Sprite {\n+â”Š  â”Š 2â”Š  // An easy representation of a sprite on a canvas, with a set of convenient tools\n+â”Š  â”Š 3â”Š  // for alignment and coloring\n+â”Š  â”Š 4â”Š  constructor(texture) {\n+â”Š  â”Š 5â”Š    this.texture = texture;\n+â”Š  â”Š 6â”Š    this.x = 0;\n+â”Š  â”Š 7â”Š    this.y = 0;\n+â”Š  â”Š 8â”Š    this.width = texture.width;\n+â”Š  â”Š 9â”Š    this.height = texture.height;\n+â”Š  â”Š10â”Š    this.pivot = { x: 0, y: 0 };\n+â”Š  â”Š11â”Š    this.opacity = 1;\n+â”Š  â”Š12â”Š  }\n+â”Š  â”Š13â”Š\n+â”Š  â”Š14â”Š  draw(context, offsetX = 0, offsetY = 0) {\n+â”Š  â”Š15â”Š    context.save();\n+â”Š  â”Š16â”Š    context.globalAlpha = this.opacity;\n+â”Š  â”Š17â”Š\n+â”Š  â”Š18â”Š    // The following switch-case can also be seen as a list of all possible\n+â”Š  â”Š19â”Š    // alignment modes\n+â”Š  â”Š20â”Š    switch (this.align) {\n+â”Š  â”Š21â”Š      case \"top-left\": case \"left-top\": this.pivot = { x: 0, y: 0 }; break;\n+â”Š  â”Š22â”Š      case \"top-right\": case \"right-top\": this.pivot = { x: this.width, y: 0 }; break;\n+â”Š  â”Š23â”Š      case \"bottom-left\": case \"left-bottom\": this.pivot = { x: 0, y: this.height }; break;\n+â”Š  â”Š24â”Š      case \"bottom-right\": case \"right-bottom\": this.pivot = { x: this.width, y: this.height }; break;\n+â”Š  â”Š25â”Š      case \"middle\": case \"center\": this.pivot = { x: this.width / 2, y: this.height / 2 }; break;\n+â”Š  â”Š26â”Š      case \"left\": this.pivot = { x: 0, y: this.height / 2 }; break;\n+â”Š  â”Š27â”Š      case \"top\": this.pivot = { x: this.width / 2, y: 0 }; break;\n+â”Š  â”Š28â”Š      case \"right\": this.pivot = { x: this.width, y: this.height / 2 }; break;\n+â”Š  â”Š29â”Š      case \"bottom\": this.pivot = { x: this.width / 2, y: this.height }; break;\n+â”Š  â”Š30â”Š    }\n+â”Š  â”Š31â”Š\n+â”Š  â”Š32â”Š    context.drawImage(\n+â”Š  â”Š33â”Š      this.texture,\n+â”Š  â”Š34â”Š      (this.x - this.pivot.x) + offsetX,\n+â”Š  â”Š35â”Š      (this.y - this.pivot.y) + offsetY,\n+â”Š  â”Š36â”Š      this.width,\n+â”Š  â”Š37â”Š      this.height\n+â”Š  â”Š38â”Š    );\n+â”Š  â”Š39â”Š\n+â”Š  â”Š40â”Š    context.restore();\n+â”Š  â”Š41â”Š  }\n+â”Š  â”Š42â”Š\n+â”Š  â”Š43â”Š  // A sprite property (key) can also be resized based on a given percentage.\n+â”Š  â”Š44â”Š  // The 'relative' argument represents the whole of which the percents are gonna be\n+â”Š  â”Š45â”Š  // calculated from, and the 'adapters' argument is an array of property names which\n+â”Š  â”Š46â”Š  // gonna adapt themselves based on the changes made in the given key.\n+â”Š  â”Š47â”Š  // Usually 'width' goes along with ['height'] adapters, if we\n+â”Š  â”Š48â”Š  // want to keep their original ratio\n+â”Š  â”Š49â”Š  setPercentage(key, relative, percents, ...adapters) {\n+â”Š  â”Š50â”Š    let oldVal = this[key];\n+â”Š  â”Š51â”Š    let newVal = this[key] = (percents * relative) / 100;\n+â”Š  â”Š52â”Š    let ratio = newVal / oldVal;\n+â”Š  â”Š53â”Š\n+â”Š  â”Š54â”Š    adapters.forEach(adapter => {\n+â”Š  â”Š55â”Š      this[adapter] *= ratio;\n+â”Š  â”Š56â”Š    });\n+â”Š  â”Š57â”Š  }\n+â”Š  â”Š58â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -9,6 +9,7 @@\n â”Š 9â”Š 9â”Š\n â”Š10â”Š10â”Š    <!-- Scripts -->\n â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n+â”Š  â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/sprite.js\"></script>\n â”Š12â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/key_states.js\"></script>\n â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/layer.js\"></script>\n â”Š14â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/screen.js\"></script>\n```\n\n[}]: #\n\nAnd we will download the logo which will be presented in the splash screen using the sprite class:\n\n    resources$ mkdir assets\n    resources$ cd assets\n    resources/assets$ mkdir textures\n    resources/assets$ cd textures\n    resources/assets/textures$ wget raw.githubusercontent.com/dab0mb/radial-snake/master/resources/assets/textures/splash.png\n\n> Any logo can that you desired can be used instead! But to ease things up I already provided you with one as a sample\n\nNow we will create the initial splash screen, where we only gonna show a sprite of the logo in the middle of the screen, with no animation applied yet. We will first define a dedicated `Screens` module under the `Game` namespace:\n\n[{]: <helper> (diffStep 3.3)\n\n#### [Step 3.3: Create a &#x27;Game&#x27; namespace with a &#x27;Screens&#x27; module](https://github.com/DAB0mB/radial-snake/commit/ae85a96)\n\n##### Changed resources&#x2F;scripts&#x2F;namespaces.js\n```diff\n@@ -1 +1,5 @@\n+â”Š â”Š1â”ŠGame = {\n+â”Š â”Š2â”Š  Screens: {}\n+â”Š â”Š3â”Š};\n+â”Š â”Š4â”Š\n â”Š1â”Š5â”ŠEngine = {};ðŸš«â†µ\n```\n\n[}]: #\n\nAnd we can go ahead and implement the screen itself:\n\n[{]: <helper> (diffStep 3.4)\n\n#### [Step 3.4: Create initial splash screen](https://github.com/DAB0mB/radial-snake/commit/4dd73f3)\n\n##### Added resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;splash&#x2F;index.js\n```diff\n@@ -0,0 +1,19 @@\n+â”Š  â”Š 1â”ŠGame.Screens.Splash = class Splash extends Engine.Screen {\n+â”Š  â”Š 2â”Š  initialize() {\n+â”Š  â”Š 3â”Š    // Create splash sprite and set its properties\n+â”Š  â”Š 4â”Š    this.splashSprite = new Engine.Sprite(this.assets.splashTexture);\n+â”Š  â”Š 5â”Š    this.splashSprite.align = \"center\";\n+â”Š  â”Š 6â”Š    this.splashSprite.x = this.width / 2;\n+â”Š  â”Š 7â”Š  }\n+â”Š  â”Š 8â”Š\n+â”Š  â”Š 9â”Š  load(assetsLoader) {\n+â”Š  â”Š10â”Š    // These are local assets which will be disposed along with the screen\n+â”Š  â”Š11â”Š    return {\n+â”Š  â”Š12â”Š      splashTexture: assetsLoader.texture(\"/textures/splash\")\n+â”Š  â”Š13â”Š    };\n+â”Š  â”Š14â”Š  }\n+â”Š  â”Š15â”Š\n+â”Š  â”Š16â”Š  draw(context) {\n+â”Š  â”Š17â”Š    this.splashSprite.draw(context);\n+â”Š  â”Š18â”Š  }\n+â”Š  â”Š19â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -16,6 +16,7 @@\n â”Š16â”Š16â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/assets_loader.js\"></script>\n â”Š17â”Š17â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š18â”Š18â”Š    <script type=\"text/javascript\" src=\"/scripts/test_screen.js\"></script>\n+â”Š  â”Š19â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/splash/index.js\"></script>\n â”Š19â”Š20â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n â”Š20â”Š21â”Š\n â”Š21â”Š22â”Š    <!-- Styles -->\n```\n\n[}]: #\n\nNow we can set the splash screen as the initial screen in the entry script file:\n\n[{]: <helper> (diffStep 3.5)\n\n#### [Step 3.5: Set splash screen as the initial game screen](https://github.com/DAB0mB/radial-snake/commit/3576ff8)\n\n##### Changed resources&#x2F;scripts&#x2F;main.js\n```diff\n@@ -1,5 +1,5 @@\n â”Š1â”Š1â”Šdocument.addEventListener(\"DOMContentLoaded\", function(event) {\n â”Š2â”Š2â”Š  let game = new Engine.Game(document.getElementById(\"gameCanvas\"), false);\n-â”Š3â”Š â”Š  game.changeScreen(TestScreen);\n+â”Š â”Š3â”Š  game.changeScreen(Game.Screens.Splash);\n â”Š4â”Š4â”Š  game.play();\n â”Š5â”Š5â”Š});ðŸš«â†µ\n```\n\n[}]: #\n\nAnd we will get rid of the unnecessary test screen since we make no use of it any longer:\n\n    $ rm resources/scripts/test_screen.js\n\nWe will now proceed into the next stage where we will be implementing the key-frame animation engine as said at the beginning of the step. We first need to define an `Animations` module, since we can have multiple types of animation strategy like [sprite-atlas animation](http://www.joshmorony.com/how-to-create-animations-in-phaser-with-a-texture-atlas/), not necessarily a key-frame animation:\n\n[{]: <helper> (diffStep 3.7)\n\n#### [Step 3.7: Add &#x27;Animations&#x27; module to &#x27;Engine&#x27; namespace](https://github.com/DAB0mB/radial-snake/commit/ffe800c)\n\n##### Changed resources&#x2F;scripts&#x2F;namespaces.js\n```diff\n@@ -2,4 +2,6 @@\n â”Š2â”Š2â”Š  Screens: {}\n â”Š3â”Š3â”Š};\n â”Š4â”Š4â”Š\n-â”Š5â”Š â”ŠEngine = {};ðŸš«â†µ\n+â”Š â”Š5â”ŠEngine = {\n+â”Š â”Š6â”Š  Animations: {}\n+â”Š â”Š7â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nInside the newly created module we will create the key-frame animation engine. The key-frame animation consists of the following methods:\n\n- update - Updates the animation.\n- draw - Draws the current animation frame on the provided canvas context.\n- play - Enables update operations.\n- pause - Disables update operations.\n\n[{]: <helper> (diffStep 3.8)\n\n#### [Step 3.8: Create a key-frame animation engine](https://github.com/DAB0mB/radial-snake/commit/64c58fb)\n\n##### Added resources&#x2F;scripts&#x2F;engine&#x2F;animations&#x2F;keyframe.js\n```diff\n@@ -0,0 +1,142 @@\n+â”Š   â”Š  1â”ŠEngine.Animations.Keyframe = class Keyframe {\n+â”Š   â”Š  2â”Š  constructor(sprite, keyframes) {\n+â”Š   â”Š  3â”Š    this.sprite = sprite;\n+â”Š   â”Š  4â”Š    // The key-frames array contains objects with the properties of the\n+â”Š   â”Š  5â”Š    // sprite at the current time-point, e.g. width of 100 and height of 200\n+â”Š   â”Š  6â”Š    this.keyframes = keyframes;\n+â”Š   â”Š  7â”Š    this.age = 0;\n+â”Š   â”Š  8â”Š    this.frame = 0;\n+â”Š   â”Š  9â”Š    // This flag determines what's gonna happen to the animation once\n+â”Š   â”Š 10â”Š    // it's finished playing\n+â”Š   â”Š 11â”Š    this.repetitionMode = \"none\";\n+â”Š   â”Š 12â”Š    this.lastKeyframe = _.last(keyframes);\n+â”Š   â”Š 13â”Š    this.lastFrame = this.lastKeyframe.frame;\n+â”Š   â”Š 14â”Š\n+â”Š   â”Š 15â”Š    // These are the properties which we can animate\n+â”Š   â”Š 16â”Š    this.animables = [\n+â”Š   â”Š 17â”Š      \"x\", \"y\", \"width\", \"height\", \"opacity\"\n+â”Š   â”Š 18â”Š    ];\n+â”Š   â”Š 19â”Š\n+â”Š   â”Š 20â”Š    // Set a map whose keys represent animatable properties and values represent an array\n+â”Š   â”Š 21â”Š    // with relevant key-frames to its belonging property\n+â”Š   â”Š 22â”Š    this.trimmedKeyframes = this.animables.reduce((trimmedKeyframes, key) => {\n+â”Š   â”Š 23â”Š      trimmedKeyframes[key] = keyframes.filter(keyframe => keyframe[key] != null);\n+â”Š   â”Š 24â”Š      return trimmedKeyframes;\n+â”Š   â”Š 25â”Š    }, {});\n+â”Š   â”Š 26â”Š\n+â”Š   â”Š 27â”Š    // Set initial properties on sprite based on initial key-frame\n+â”Š   â”Š 28â”Š    _.each(keyframes[0], (value, key) => {\n+â”Š   â”Š 29â”Š      if (this.animables.includes(key)) sprite[key] = value;\n+â”Š   â”Š 30â”Š    });\n+â”Š   â”Š 31â”Š  }\n+â”Š   â”Š 32â”Š\n+â”Š   â”Š 33â”Š  draw(context, offsetX, offsetY) {\n+â”Š   â”Š 34â”Š    this.sprite.draw(context, offsetX, offsetY);\n+â”Š   â”Š 35â”Š  }\n+â”Š   â”Š 36â”Š\n+â”Š   â”Š 37â”Š  update(span) {\n+â”Š   â”Š 38â”Š    if (!this.playing) return;\n+â”Š   â”Š 39â”Š\n+â”Š   â”Š 40â”Š    this.age += span;\n+â”Š   â”Š 41â”Š\n+â”Š   â”Š 42â”Š    switch (this.repetitionMode) {\n+â”Š   â”Š 43â”Š      // After one cycle animation would stop\n+â”Š   â”Š 44â”Š      case \"none\":\n+â”Š   â”Š 45â”Š        this.frame += span;\n+â”Š   â”Š 46â”Š\n+â”Š   â”Š 47â”Š        if (this.frame > this.lastFrame) {\n+â”Š   â”Š 48â”Š          this.frame = this.lastFrame;\n+â”Š   â”Š 49â”Š          this.playing = false;\n+â”Š   â”Š 50â”Š        }\n+â”Š   â”Š 51â”Š\n+â”Š   â”Š 52â”Š        break;\n+â”Š   â”Š 53â”Š\n+â”Š   â”Š 54â”Š      // Once finished, replay from the beginning\n+â”Š   â”Š 55â”Š      case \"cyclic\":\n+â”Š   â”Š 56â”Š        this.frame = this.age % this.lastFrame;\n+â”Š   â”Š 57â”Š        break;\n+â”Š   â”Š 58â”Š\n+â”Š   â”Š 59â”Š      // Once finished, play backwards, and so on\n+â”Š   â”Š 60â”Š      case \"full\":\n+â”Š   â”Š 61â”Š        this.frame = this.age % this.lastFrame;\n+â”Š   â”Š 62â”Š        let animationComplete = (this.age / this.lastFrame) % 2 >= 1;\n+â”Š   â”Š 63â”Š        if (animationComplete) this.frame = this.lastFrame - this.frame;\n+â”Š   â”Š 64â”Š        break;\n+â”Š   â”Š 65â”Š    }\n+â”Š   â”Š 66â”Š\n+â”Š   â”Š 67â”Š    // Update sprite properties based on given key-frame's easing mode\n+â”Š   â”Š 68â”Š    this.animables.forEach(key => {\n+â”Š   â”Š 69â”Š      let motion = this.getKeyframeMotion(key);\n+â”Š   â”Š 70â”Š\n+â”Š   â”Š 71â”Š      if (motion)\n+â”Š   â”Š 72â”Š        this.sprite[key] = this.calculateRelativeValue(motion, key);\n+â”Š   â”Š 73â”Š    });\n+â”Š   â”Š 74â”Š  }\n+â”Š   â”Š 75â”Š\n+â”Š   â”Š 76â”Š  play() {\n+â”Š   â”Š 77â”Š    this.playing = true;\n+â”Š   â”Š 78â”Š  }\n+â”Š   â”Š 79â”Š\n+â”Š   â”Š 80â”Š  pause() {\n+â”Š   â”Š 81â”Š    this.playing = false;\n+â”Š   â”Š 82â”Š  }\n+â”Š   â”Š 83â”Š\n+â”Š   â”Š 84â”Š  // Gets motion for current refresh\n+â”Š   â”Š 85â”Š  getKeyframeMotion(key) {\n+â”Š   â”Š 86â”Š    let keyframes = this.trimmedKeyframes[key];\n+â”Š   â”Š 87â”Š\n+â”Š   â”Š 88â”Š    // If no key-frames defined, motion is idle\n+â”Š   â”Š 89â”Š    if (keyframes == null) return;\n+â”Š   â”Š 90â”Š    // If there is only one key frame, motion is idle\n+â”Š   â”Š 91â”Š    if (keyframes.length < 2) return;\n+â”Š   â”Š 92â”Š    // If last frame reached, motion is idle\n+â”Š   â”Š 93â”Š    if (this.frame > _.last(keyframes).frame) return;\n+â”Š   â”Š 94â”Š\n+â”Š   â”Š 95â”Š    let start = this.findStartKeyframe(keyframes);\n+â”Š   â”Š 96â”Š    let end = this.findEndKeyframe(keyframes);\n+â”Š   â”Š 97â”Š    let ratio = this.getKeyframesRatio(start, end);\n+â”Š   â”Š 98â”Š\n+â”Š   â”Š 99â”Š    return { start, end, ratio };\n+â”Š   â”Š100â”Š  }\n+â”Š   â”Š101â”Š\n+â”Š   â”Š102â”Š  // Gets the movement ratio\n+â”Š   â”Š103â”Š  getKeyframesRatio(start, end) {\n+â”Š   â”Š104â”Š    return (this.frame - start.frame) / (end.frame - start.frame);\n+â”Š   â”Š105â”Š  }\n+â”Š   â”Š106â”Š\n+â”Š   â”Š107â”Š  // Get property end value based on current frame\n+â”Š   â”Š108â”Š  findEndKeyframe(keyframes) {\n+â”Š   â”Š109â”Š    return _.find(keyframes, keyframe =>\n+â”Š   â”Š110â”Š      keyframe.frame >= (this.frame || 1)\n+â”Š   â”Š111â”Š    );\n+â”Š   â”Š112â”Š  }\n+â”Š   â”Š113â”Š\n+â”Š   â”Š114â”Š  // Get property start value based on current frame\n+â”Š   â”Š115â”Š  findStartKeyframe(keyframes) {\n+â”Š   â”Š116â”Š    let resultIndex;\n+â”Š   â”Š117â”Š\n+â”Š   â”Š118â”Š    keyframes.some((keyframe, currIndex) => {\n+â”Š   â”Š119â”Š      if (keyframe.frame >= (this.frame || 1)) {\n+â”Š   â”Š120â”Š        resultIndex = currIndex;\n+â”Š   â”Š121â”Š        return true;\n+â”Š   â”Š122â”Š      }\n+â”Š   â”Š123â”Š    });\n+â”Š   â”Š124â”Š\n+â”Š   â”Š125â”Š    return keyframes[resultIndex - 1];\n+â”Š   â”Š126â”Š  }\n+â”Š   â”Š127â”Š\n+â”Š   â”Š128â”Š  // Get a recalculated property value relative to provided easing mode\n+â”Š   â”Š129â”Š  calculateRelativeValue(motion, key) {\n+â”Š   â”Š130â”Š    let a = motion.start[key];\n+â”Š   â”Š131â”Š    let b = motion.end[key];\n+â”Š   â”Š132â”Š    let r = motion.ratio;\n+â”Š   â”Š133â”Š    let easing = r > 0 ? motion.start.easing : motion.end.easing;\n+â”Š   â”Š134â”Š\n+â”Š   â”Š135â”Š    switch (easing) {\n+â”Š   â”Š136â”Š      case \"in\": r = Math.sin((r * Math.PI) / 2); break;\n+â”Š   â”Š137â”Š      case \"out\": r = Math.cos((r * Math.PI) / 2); break;\n+â”Š   â”Š138â”Š    }\n+â”Š   â”Š139â”Š\n+â”Š   â”Š140â”Š    return ((b - a) * r) + a;\n+â”Š   â”Š141â”Š  }\n+â”Š   â”Š142â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -10,6 +10,7 @@\n â”Š10â”Š10â”Š    <!-- Scripts -->\n â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n â”Š12â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/sprite.js\"></script>\n+â”Š  â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/animations/keyframe.js\"></script>\n â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/key_states.js\"></script>\n â”Š14â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/layer.js\"></script>\n â”Š15â”Š16â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/screen.js\"></script>\n```\n\n[}]: #\n\nWhen initializing a new instance of the key-frame animation, we should invoke it with the desired sprite, and an array of key-frames. What exactly does a single key-frame represents? The properties of the sprite at that specific time point. In addition, a key-frame can be set with an [easing mode](https://css-tricks.com/ease-out-in-ease-in-out/) of `in` and `out`. By default, the animation would be linear.\n\nBased on the `repitationMode` property, three things can happen to the animation once finished:\n\n- `none` - The animation will play once, and then stop. It will appear as a static sprite.\n- `cyclic` - The animation will repeat itself from the beginning, over and over again until stopped manually.\n- `full` - The animation will play itself backwards, and then forwards, backwards, forwards, and so on.\n\nThanks to the key-frame animation engine, we can apply it to the splash screen to show a beautifully animated logo rather than showing a static image. So in addition to the logo sprite, we will initialize a key-frame animation as well:\n\n[{]: <helper> (diffStep 3.9)\n\n#### [Step 3.9: Apply key-frame animation to splash screen](https://github.com/DAB0mB/radial-snake/commit/8ca47e5)\n\n##### Changed resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;splash&#x2F;index.js\n```diff\n@@ -1,9 +1,34 @@\n â”Š 1â”Š 1â”ŠGame.Screens.Splash = class Splash extends Engine.Screen {\n â”Š 2â”Š 2â”Š  initialize() {\n â”Š 3â”Š 3â”Š    // Create splash sprite and set its properties\n-â”Š 4â”Š  â”Š    this.splashSprite = new Engine.Sprite(this.assets.splashTexture);\n-â”Š 5â”Š  â”Š    this.splashSprite.align = \"center\";\n-â”Š 6â”Š  â”Š    this.splashSprite.x = this.width / 2;\n+â”Š  â”Š 4â”Š    let splashSprite = new Engine.Sprite(this.assets.splashTexture);\n+â”Š  â”Š 5â”Š    splashSprite.align = \"center\";\n+â”Š  â”Š 6â”Š    splashSprite.x = this.width / 2;\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Š    // Create splash sprite animation\n+â”Š  â”Š 9â”Š    this.splashAnim = new Engine.Animations.Keyframe(splashSprite, [\n+â”Š  â”Š10â”Š      {\n+â”Š  â”Š11â”Š        y: (this.height / 2) - 30,\n+â”Š  â”Š12â”Š        width: splashSprite.width / 4,\n+â”Š  â”Š13â”Š        height: splashSprite.height / 4,\n+â”Š  â”Š14â”Š        opacity: 0,\n+â”Š  â”Š15â”Š        easing: \"in\",\n+â”Š  â”Š16â”Š        frame: 0\n+â”Š  â”Š17â”Š      },\n+â”Š  â”Š18â”Š      {\n+â”Š  â”Š19â”Š        y: this.height / 2,\n+â”Š  â”Š20â”Š        width: (splashSprite.width / 3) + (splashSprite.width * 0.05),\n+â”Š  â”Š21â”Š        height: (splashSprite.height / 3) + (splashSprite.height * 0.05),\n+â”Š  â”Š22â”Š        opacity: 1,\n+â”Š  â”Š23â”Š        frame: 3000\n+â”Š  â”Š24â”Š      },\n+â”Š  â”Š25â”Š      {\n+â”Š  â”Š26â”Š        frame: 3500\n+â”Š  â”Š27â”Š      }\n+â”Š  â”Š28â”Š    ]);\n+â”Š  â”Š29â”Š\n+â”Š  â”Š30â”Š    // Start playing animation\n+â”Š  â”Š31â”Š    this.splashAnim.play();\n â”Š 7â”Š32â”Š  }\n â”Š 8â”Š33â”Š\n â”Š 9â”Š34â”Š  load(assetsLoader) {\n```\n```diff\n@@ -14,6 +39,10 @@\n â”Š14â”Š39â”Š  }\n â”Š15â”Š40â”Š\n â”Š16â”Š41â”Š  draw(context) {\n-â”Š17â”Š  â”Š    this.splashSprite.draw(context);\n+â”Š  â”Š42â”Š    this.splashAnim.draw(context);\n+â”Š  â”Š43â”Š  }\n+â”Š  â”Š44â”Š\n+â”Š  â”Š45â”Š  update(span) {\n+â”Š  â”Š46â”Š    this.splashAnim.update(span);\n â”Š18â”Š47â”Š  }\n â”Š19â”Š48â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nThe following key-frames illustrate the nodes of the animation we've just created:\n\n    width: 0\n    height: 0\n    opacity: 0\n\n![logo-empty](https://cloud.githubusercontent.com/assets/7648874/21583394/ee7a1dec-d065-11e6-80ce-fdd37c4b5dbb.png)\n\n    width: 225\n    height: 175\n    opacity: 1\n\n![logo-half](https://cloud.githubusercontent.com/assets/7648874/21583396/ee9bdf68-d065-11e6-95fb-4cf5ed58a9de.png)\n\n    width: 342\n    height: 266\n    opacity: 1\n\n![logo-full](https://cloud.githubusercontent.com/assets/7648874/21583395/ee7b3754-d065-11e6-9646-476d196a6412.png)"
          },
          {
            "manualTitle": "Step 4: Creating a main menu screen using a font engine",
            "stepRevision": "f88428bffcdf2bcf269b9cc15837cc40e0ed9caf",
            "manualView": "![snake-demo-menu-small](https://cloud.githubusercontent.com/assets/7648874/21074099/e72a81bc-bed6-11e6-98cb-329dc12a4b06.gif)\n\nIn this step we will be creating the main menu screen as shown above. The main menu screen is a simple screen which will show the logo of the game and an instruction text saying `Press a key to start`. We will be using a simple texture to show the game-logo and we will use the key-frame animation engine to show a flickering animation of the instruction text. The instruction text is the main part of this step, since it is made out of a font file (`.ttf`) and the text is auto-generated, a general solution which can serve us in many situations. We will start by implementing the main menu using static assets, which means that we will use a texture to show the instructions text, and later on we will implement the generic solution I've just mentioned. First, we will download the necessary assets:\n\n    resources/assets/textures$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/assets/textures/instructions.png\n    resources/assets/textures$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/assets/textures/logo.png\n\nAnd then we will implement the initial main menu screen:\n\n[{]: <helper> (diffStep 4.2)\n\n#### [Step 4.2: Create initial main menu screen](https://github.com/DAB0mB/radial-snake/commit/ed79de7)\n\n##### Added resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;menu&#x2F;index.js\n```diff\n@@ -0,0 +1,44 @@\n+â”Š  â”Š 1â”ŠGame.Screens.Menu = class Menu extends Engine.Screen {\n+â”Š  â”Š 2â”Š  initialize() {\n+â”Š  â”Š 3â”Š    // Initialize snake logo sprite\n+â”Š  â”Š 4â”Š    this.logoSprite = new Engine.Sprite(this.assets.logoTexture);\n+â”Š  â”Š 5â”Š    this.logoSprite.setPercentage(\"width\", this.width, 30, \"height\");\n+â”Š  â”Š 6â”Š\n+â”Š  â”Š 7â”Š    // Initialize instructions sprite\n+â”Š  â”Š 8â”Š    let instructionsSprite = new Engine.Sprite(this.assets.instructionsTexture);\n+â”Š  â”Š 9â”Š    instructionsSprite.align = \"center\";\n+â”Š  â”Š10â”Š    instructionsSprite.setPercentage(\"width\", this.width, 35, \"height\");\n+â”Š  â”Š11â”Š    instructionsSprite.x = this.width / 2;\n+â”Š  â”Š12â”Š    instructionsSprite.y = this.height / 2;\n+â”Š  â”Š13â”Š\n+â”Š  â”Š14â”Š    // Create flickering animation for instructions sprite\n+â”Š  â”Š15â”Š    this.instructionsAnim = new Engine.Animations.Keyframe(instructionsSprite, [\n+â”Š  â”Š16â”Š      {\n+â”Š  â”Š17â”Š        opacity: 1,\n+â”Š  â”Š18â”Š        frame: 0\n+â”Š  â”Š19â”Š      },\n+â”Š  â”Š20â”Š      {\n+â”Š  â”Š21â”Š        opacity: 0,\n+â”Š  â”Š22â”Š        frame: 2000\n+â”Š  â”Š23â”Š      }\n+â”Š  â”Š24â”Š    ]);\n+â”Š  â”Š25â”Š\n+â”Š  â”Š26â”Š    // Play it repeatedly, back and forth\n+â”Š  â”Š27â”Š    this.instructionsAnim.repetitionMode = \"full\";\n+â”Š  â”Š28â”Š    this.instructionsAnim.play();\n+â”Š  â”Š29â”Š  }\n+â”Š  â”Š30â”Š\n+â”Š  â”Š31â”Š  unload() {\n+â”Š  â”Š32â”Š    // Dispose the following assets to prevent memory leaks\n+â”Š  â”Š33â”Š    return [\"logoTexture\", \"instructionsTexture\"];\n+â”Š  â”Š34â”Š  }\n+â”Š  â”Š35â”Š\n+â”Š  â”Š36â”Š  draw(context) {\n+â”Š  â”Š37â”Š    this.logoSprite.draw(context);\n+â”Š  â”Š38â”Š    this.instructionsAnim.draw(context);\n+â”Š  â”Š39â”Š  }\n+â”Š  â”Š40â”Š\n+â”Š  â”Š41â”Š  update(span) {\n+â”Š  â”Š42â”Š    this.instructionsAnim.update(span);\n+â”Š  â”Š43â”Š  }\n+â”Š  â”Š44â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -16,6 +16,7 @@\n â”Š16â”Š16â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/screen.js\"></script>\n â”Š17â”Š17â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/assets_loader.js\"></script>\n â”Š18â”Š18â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n+â”Š  â”Š19â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/menu/index.js\"></script>\n â”Š19â”Š20â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/splash/index.js\"></script>\n â”Š20â”Š21â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n```\n\n[}]: #\n\nThis screen is dependent on several assets which we will load during \"splash screen time\", to save some loading time and for a smooth experience. The main menu screen will be shown automatically once the splash animation has been finished:\n\n[{]: <helper> (diffStep 4.3)\n\n#### [Step 4.3: Queue main menu screen](https://github.com/DAB0mB/radial-snake/commit/cd83a30)\n\n##### Changed resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;splash&#x2F;index.js\n```diff\n@@ -32,10 +32,21 @@\n â”Š32â”Š32â”Š  }\n â”Š33â”Š33â”Š\n â”Š34â”Š34â”Š  load(assetsLoader) {\n+â”Š  â”Š35â”Š    // Load assets\n+â”Š  â”Š36â”Š    let instructionsTexture = assetsLoader.texture(\"/textures/instrucitons\");\n+â”Š  â”Š37â”Š    let logoTexture = assetsLoader.texture(\"/textures/logo\");\n+â”Š  â”Š38â”Š    let splashTexture = assetsLoader.texture(\"/textures/splash\");\n+â”Š  â”Š39â”Š\n+â”Š  â”Š40â”Š    // These are global assets which will be shared among all screens until manually\n+â”Š  â”Š41â”Š    // disposed. We use the time gap created by the splash animation to load necessary\n+â”Š  â”Š42â”Š    // assets without wasting any time\n+â”Š  â”Š43â”Š    this.game.extendAssets({\n+â”Š  â”Š44â”Š      instructionsTexture,\n+â”Š  â”Š45â”Š      logoTexture\n+â”Š  â”Š46â”Š    });\n+â”Š  â”Š47â”Š\n â”Š35â”Š48â”Š    // These are local assets which will be disposed along with the screen\n-â”Š36â”Š  â”Š    return {\n-â”Š37â”Š  â”Š      splashTexture: assetsLoader.texture(\"/textures/splash\")\n-â”Š38â”Š  â”Š    };\n+â”Š  â”Š49â”Š    return { splashTexture };\n â”Š39â”Š50â”Š  }\n â”Š40â”Š51â”Š\n â”Š41â”Š52â”Š  draw(context) {\n```\n```diff\n@@ -43,6 +54,12 @@\n â”Š43â”Š54â”Š  }\n â”Š44â”Š55â”Š\n â”Š45â”Š56â”Š  update(span) {\n-â”Š46â”Š  â”Š    this.splashAnim.update(span);\n+â”Š  â”Š57â”Š    if (this.splashAnim.playing) {\n+â”Š  â”Š58â”Š      this.splashAnim.update(span);\n+â”Š  â”Š59â”Š    }\n+â”Š  â”Š60â”Š    // Once animation has stopped play switch to main menu\n+â”Š  â”Š61â”Š    else {\n+â”Š  â”Š62â”Š      this.game.changeScreen(Game.Screens.Menu);\n+â”Š  â”Š63â”Š    }\n â”Š47â”Š64â”Š  }\n â”Š48â”Š65â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nBy now if you launch the application you should see the main menu screen as described in the beginning. But event though it works, we're not yet finished. We still need to convert the instruction texture into an auto-generated font texture. Obviously, this requires us to download the desired `ttf` file:\n\n    resources/assets/fonts$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/assets/fonts/minecraftia.ttf\n\n> Any font file can be used here, but to save time and effort I already provided you with one\n\n`ttf` is the most common format, but since we're using JavaScript, it would make sense to convert it into a `json` file, and that's exactly what we're going to do. There's a very convenient software called [font-builder](https://github.com/andryblack/fontbuilder), and it can cut fonts, store them in `png` files, along with some user-specified meta-data stored in an `xml` file.\n\n![font-builder](https://camo.githubusercontent.com/b2c95cda825c783f5399d9197599848c33cdfcc8/687474703a2f2f7777772e67616d656465762e72752f66696c65732f696d616765732f73637265656e312e6a706567)\n\nGo over to this website: https://github.com/andryblack/fontbuilder.\nFetch a copy of the `font-builder` repo, and try to convert the `minecraftia.ttf` file into a `png` file. If you want to skip this step, although I wouldn't recommend it, you can download the following files which I already generated myself:\n\n    resources/assets/fonts$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/assets/fonts/minecraftia.png\n    resources/assets/fonts$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/assets/fonts/minecraftia.xml\n\nAs promised, we will be working with a `json` file, not a `ttf` file and not an `xml` file. For this task we will be implementing a font-parser module, which will simply take all the meta-data in the `xml` file and put it into a nice `json` schema:\n\n[{]: <helper> (diffStep 4.6)\n\n#### [Step 4.6: Create font parser so we can convert &#x27;xml&#x27; font format to &#x27;json&#x27;](https://github.com/DAB0mB/radial-snake/commit/66044e9)\n\n##### Added helpers&#x2F;font_parser.js\n```diff\n@@ -0,0 +1,102 @@\n+â”Š   â”Š  1â”Šconst _ = require(\"underscore\");\n+â”Š   â”Š  2â”Šconst Async = require(\"async\");\n+â”Š   â”Š  3â”Šconst Fs = require(\"fs\");\n+â”Š   â”Š  4â”Šconst Path = require(\"path\");\n+â”Š   â”Š  5â”Šconst { DOMParser } = require(\"xmldom\");\n+â”Š   â”Š  6â”Š\n+â”Š   â”Š  7â”Šif (module === require.main) {\n+â”Š   â”Š  8â”Š  let fonstDir = Path.resolve(__dirname, \"../resources/assets/fonts\");\n+â”Š   â”Š  9â”Š  xmlsToJsons(fonstDir, err => { if (err) throw err });\n+â”Š   â”Š 10â”Š}\n+â”Š   â”Š 11â”Š\n+â”Š   â”Š 12â”Š// Gets a dir path containing font xmls and converts them all to jsons\n+â”Š   â”Š 13â”Šfunction xmlsToJsons(path, callback = _.noop) {\n+â”Š   â”Š 14â”Š  Fs.readdir(path, (err, files) => {\n+â”Š   â”Š 15â”Š    if (err) return callback(err);\n+â”Š   â”Š 16â”Š\n+â”Š   â”Š 17â”Š    // Remove all extensions\n+â”Š   â”Š 18â”Š    fileNames = _.uniq(files.map(file => file.split(\".\")[0]));\n+â”Š   â”Š 19â”Š\n+â”Š   â”Š 20â”Š    // Convert each xml individually\n+â”Š   â”Š 21â”Š    Async.each(fileNames, (fileName, next) => {\n+â”Š   â”Š 22â”Š      xmlToJson(`${path}/${fileName}`, next);\n+â”Š   â”Š 23â”Š    },\n+â”Š   â”Š 24â”Š    (err) => {\n+â”Š   â”Š 25â”Š      if (!err) console.log(\n+â”Š   â”Š 26â”Š        'All fonts have been successfully parsed!'\n+â”Š   â”Š 27â”Š      );\n+â”Š   â”Š 28â”Š\n+â”Š   â”Š 29â”Š      callback(err);\n+â”Š   â”Š 30â”Š    });\n+â”Š   â”Š 31â”Š  });\n+â”Š   â”Š 32â”Š}\n+â”Š   â”Š 33â”Š\n+â”Š   â”Š 34â”Š// Gets a font xml and converts it to json\n+â”Š   â”Š 35â”Šfunction xmlToJson(path, callback = _.noop) {\n+â”Š   â”Š 36â”Š  Async.waterfall([\n+â”Š   â”Š 37â”Š    (next) => {\n+â”Š   â”Š 38â”Š      Fs.readFile(`${path}.xml`, function(err, xmlBuffer) {\n+â”Š   â”Š 39â”Š        if (err) return next(err);\n+â”Š   â”Š 40â”Š\n+â”Š   â”Š 41â”Š        let json = {\n+â”Š   â”Š 42â”Š          chars: {}\n+â”Š   â”Š 43â”Š        };\n+â”Š   â”Š 44â”Š\n+â”Š   â”Š 45â”Š        let xml = xmlBuffer.toString();\n+â”Š   â”Š 46â”Š        let doc = new DOMParser().parseFromString(xml);\n+â”Š   â”Š 47â”Š        let fontDoc = doc.getElementsByTagName(\"Font\")[0];\n+â”Š   â”Š 48â”Š        let charsDoc = fontDoc.getElementsByTagName(\"Char\");\n+â”Š   â”Š 49â”Š\n+â”Š   â”Š 50â”Š        // Compose meta-data about font like size and family\n+â”Š   â”Š 51â”Š        _.each(fontDoc.attributes, (attr) => {\n+â”Š   â”Š 52â”Š          json[attr.name] = parseInt(attr.value) || attr.value;\n+â”Š   â”Š 53â”Š        });\n+â”Š   â”Š 54â”Š\n+â”Š   â”Š 55â”Š        // Compose data about each character in font\n+â”Š   â”Š 56â”Š        _.each(charsDoc, (charDoc) => {\n+â”Š   â”Š 57â”Š          let charCode = charDoc.getAttribute(\"code\");\n+â”Š   â”Š 58â”Š\n+â”Š   â”Š 59â”Š          let char = json.chars[charCode] = {\n+â”Š   â”Š 60â”Š            rect: rect = {},\n+â”Š   â”Š 61â”Š            offset: offset = {},\n+â”Š   â”Š 62â”Š            width: parseInt(charDoc.getAttribute(\"width\"))\n+â”Š   â”Š 63â”Š          };\n+â”Š   â”Š 64â”Š\n+â”Š   â”Š 65â”Š          [\n+â”Š   â”Š 66â”Š            rect.x,\n+â”Š   â”Š 67â”Š            rect.y,\n+â”Š   â”Š 68â”Š            rect.width,\n+â”Š   â”Š 69â”Š            rect.height\n+â”Š   â”Š 70â”Š          ] = extractIntegers(charDoc.getAttribute(\"rect\"));\n+â”Š   â”Š 71â”Š\n+â”Š   â”Š 72â”Š          [offset.x, offset.y] = extractIntegers(charDoc.getAttribute(\"offset\"));\n+â”Š   â”Š 73â”Š        });\n+â”Š   â”Š 74â”Š\n+â”Š   â”Š 75â”Š        next(null, JSON.stringify(json, null, 2));\n+â”Š   â”Š 76â”Š      });\n+â”Š   â”Š 77â”Š    },\n+â”Š   â”Š 78â”Š    (json, next) => {\n+â”Š   â”Š 79â”Š      // Once finished, write json into file\n+â”Š   â”Š 80â”Š      Fs.writeFile(path + \".json\", json, (err) => {\n+â”Š   â”Š 81â”Š        next(err);\n+â”Š   â”Š 82â”Š      });\n+â”Š   â”Š 83â”Š    }\n+â”Š   â”Š 84â”Š  ], (err) => {\n+â”Š   â”Š 85â”Š    if (!err) console.log(\n+â”Š   â”Š 86â”Š      `Font ${path} has been successfully parsed...`\n+â”Š   â”Š 87â”Š    );\n+â”Š   â”Š 88â”Š\n+â”Š   â”Š 89â”Š    callback(err);\n+â”Š   â”Š 90â”Š  });\n+â”Š   â”Š 91â”Š};\n+â”Š   â”Š 92â”Š\n+â”Š   â”Š 93â”Š// Converts an string of numbers to array of numbers\n+â”Š   â”Š 94â”Š// e.g. extractIntegers(\"1 2 3\") -> [1, 2, 3]\n+â”Š   â”Š 95â”Šfunction extractIntegers(srcstr) {\n+â”Š   â”Š 96â”Š  return srcstr.split(\" \").map((substr) => parseInt(substr));\n+â”Š   â”Š 97â”Š}\n+â”Š   â”Š 98â”Š\n+â”Š   â”Š 99â”Šmodule.exports = {\n+â”Š   â”Š100â”Š  xmlToJson,\n+â”Š   â”Š101â”Š  xmlsToJsons\n+â”Š   â”Š102â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nThis script will take everything that's in the `fonts` dir and parser it as mentioned above. Before we can user this script we will need to install some NPM dependencies like so:\n\n    $ npm install --save underscore\n    $ npm install --save xmldom\n\nAnd instead of running the parser manually over and over again whenever we wanna use it, we will use the following `NPM` script instead:\n\n[{]: <helper> (diffStep 4.8)\n\n#### [Step 4.8: Add font parsing npm scripts](https://github.com/DAB0mB/radial-snake/commit/7a1cf81)\n\n##### Changed package.json\n```diff\n@@ -7,7 +7,8 @@\n â”Š 7â”Š 7â”Š  },\n â”Š 8â”Š 8â”Š  \"private\": true,\n â”Š 9â”Š 9â”Š  \"scripts\": {\n-â”Š10â”Š  â”Š    \"serve\": \"nodemon server.js\"\n+â”Š  â”Š10â”Š    \"serve\": \"npm run parse:fonts && nodemon server.js\",\n+â”Š  â”Š11â”Š    \"build:fonts\": \"node helpers/font_parser.js\"\n â”Š11â”Š12â”Š  },\n â”Š12â”Š13â”Š  \"dependencies\": {\n â”Š13â”Š14â”Š    \"async\": \"^2.1.4\",\n```\n\n[}]: #\n\nWe don't want the generated fonts to be included by `git` since they are going to automatically regenerate themselves, therefore we gonna add the following ignore rule:\n\n[{]: <helper> (diffStep 4.9)\n\n#### [Step 4.9: Add rule to to git-ignore parsed fonts](https://github.com/DAB0mB/radial-snake/commit/bbf7647)\n\n##### Changed .gitignore\n```diff\n@@ -1,2 +1,3 @@\n â”Š1â”Š1â”Šnode_modules\n-â”Š2â”Š â”Šnpm-debug.logðŸš«â†µ\n+â”Š â”Š2â”Šnpm-debug.log\n+â”Š â”Š3â”Šresources/assets/fonts/*.jsonðŸš«â†µ\n```\n\n[}]: #\n\nNow we will build our `minecraftia` font by simply running:\n\n    $ npm run build:fonts\n\nAnd voila! We have a freshly created `json` file which we can work with. You can also get it from here:\n\n    resources/assets/fonts$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/assets/fonts/minecraftia.json\n\nNow that we have our assets finally ready we can go ahead and focus on extending the engine which powers up our game. We need some sort of a generic font-engine which will know how to load a font file and create a text-sprite out of it. First we will implement a class called `Restorable`, which shares the same restore API as the CanvasRenderingContext2D and will give us the ability to save and restore the font's state (More information can be found [here](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/restore)):\n\n[{]: <helper> (diffStep 4.11)\n\n#### [Step 4.11: Add &#x27;Restorable&#x27; class](https://github.com/DAB0mB/radial-snake/commit/8239c01)\n\n##### Added resources&#x2F;scripts&#x2F;engine&#x2F;restorable.js\n```diff\n@@ -0,0 +1,21 @@\n+â”Š  â”Š 1â”ŠEngine.Restorable = class Restorable {\n+â”Š  â”Š 2â”Š  // Acts the same as canvas's save() and restore() API.\n+â”Š  â”Š 3â”Š  // 'restorable' props are defined in the constructor\n+â”Š  â”Š 4â”Š  constructor(...restorableProps) {\n+â”Š  â”Š 5â”Š    this._restorableProps = restorableProps;\n+â”Š  â”Š 6â”Š    this._restorableStates = [];\n+â”Š  â”Š 7â”Š  }\n+â”Š  â”Š 8â”Š\n+â”Š  â”Š 9â”Š  // Save current state in the stack\n+â”Š  â”Š10â”Š  save() {\n+â”Š  â”Š11â”Š    this._restorableStates.push(this._restorableProps.reduce((state, prop) => {\n+â”Š  â”Š12â”Š      state[prop] = this[prop];\n+â”Š  â”Š13â”Š      return state;\n+â”Š  â”Š14â”Š    }, {}));\n+â”Š  â”Š15â”Š  }\n+â”Š  â”Š16â”Š\n+â”Š  â”Š17â”Š  // Pop most recent state and apply it\n+â”Š  â”Š18â”Š  restore() {\n+â”Š  â”Š19â”Š    _.extend(this, this._restorableStates.pop());\n+â”Š  â”Š20â”Š  }\n+â”Š  â”Š21â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -9,6 +9,7 @@\n â”Š 9â”Š 9â”Š\n â”Š10â”Š10â”Š    <!-- Scripts -->\n â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n+â”Š  â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/restorable.js\"></script>\n â”Š12â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/sprite.js\"></script>\n â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/animations/keyframe.js\"></script>\n â”Š14â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/key_states.js\"></script>\n```\n\n[}]: #\n\nAnd now we can go ahead and implement the font class itself:\n\n[{]: <helper> (diffStep 4.12)\n\n#### [Step 4.12: Create font engine](https://github.com/DAB0mB/radial-snake/commit/7a1f2c7)\n\n##### Added resources&#x2F;scripts&#x2F;engine&#x2F;font.js\n```diff\n@@ -0,0 +1,133 @@\n+â”Š   â”Š  1â”ŠEngine.Font = class Font extends Engine.Restorable {\n+â”Š   â”Š  2â”Š  // The src property acts just line native image's src property.\n+â”Š   â”Š  3â”Š  // Once finished loading, the onload() callback will be invoked\n+â”Š   â”Š  4â”Š  get src() {\n+â”Š   â”Š  5â”Š    return this._src;\n+â”Š   â”Š  6â”Š  }\n+â”Š   â”Š  7â”Š\n+â”Š   â”Š  8â”Š  set src(src) {\n+â”Š   â”Š  9â”Š    this._src = src;\n+â”Š   â”Š 10â”Š\n+â”Š   â”Š 11â”Š    // The font is actually an image, therefore we have 2 onload callbacks.\n+â”Š   â”Š 12â”Š    // The first one is the native one which will always be run,\n+â”Š   â”Š 13â”Š    // and the second one is a user defined one\n+â”Š   â”Š 14â”Š    if (this.onload) var done = _.after(2, this.onload);\n+â”Š   â”Š 15â”Š\n+â”Š   â”Š 16â”Š    this.atlas = new Image();\n+â”Š   â”Š 17â”Š    this.atlas.onload = done;\n+â”Š   â”Š 18â”Š    this.atlas.src = `${src}.png`;\n+â”Š   â”Š 19â”Š\n+â”Š   â”Š 20â”Š    // Get json based on the given src property\n+â”Š   â”Š 21â”Š    $.getJSON(`${src}.json`, data => {\n+â”Š   â”Š 22â”Š      this.data = data;\n+â”Š   â”Š 23â”Š      if (done) done();\n+â”Š   â”Š 24â”Š    });\n+â”Š   â”Š 25â”Š\n+â”Š   â”Š 26â”Š    return this._src;\n+â”Š   â”Š 27â”Š  }\n+â”Š   â”Š 28â”Š\n+â”Š   â”Š 29â”Š  constructor() {\n+â”Š   â”Š 30â”Š    // The color property is the only restorable property\n+â”Š   â”Š 31â”Š    super(\"color\");\n+â”Š   â”Š 32â”Š    this.charSpritesCache = {};\n+â”Š   â”Š 33â”Š  }\n+â”Š   â”Š 34â”Š\n+â”Š   â”Š 35â”Š  // Creates a texture out of the font with the given text\n+â”Š   â”Š 36â”Š  createTexture(text, options = {}) {\n+â”Š   â”Š 37â”Š    let { noOffsets, noSpaces } = options;\n+â”Š   â”Š 38â”Š    let canvas = document.createElement(\"canvas\");\n+â”Š   â”Š 39â”Š    let context = canvas.getContext(\"2d\");\n+â”Š   â”Š 40â”Š    let height = canvas.height = this.data.height;\n+â”Š   â”Š 41â”Š\n+â”Š   â”Š 42â”Š    // Calculates the width of the canvas based on the text and the font\n+â”Š   â”Š 43â”Š    let width = canvas.width = _.reduce(text, (width, c) => {\n+â”Š   â”Š 44â”Š      // No-space option means that the characters will be\n+â”Š   â”Š 45â”Š      // drawn with no any space between them\n+â”Š   â”Š 46â”Š      if (noSpaces) {\n+â”Š   â”Š 47â”Š        return width + this.getCharSprite(c).width;\n+â”Š   â”Š 48â”Š      }\n+â”Š   â”Š 49â”Š\n+â”Š   â”Š 50â”Š      return width + this.data.chars[c].width;\n+â”Š   â”Š 51â”Š    }, 0);\n+â”Š   â”Š 52â”Š\n+â”Š   â”Š 53â”Š    // A custom size can be specified for a font as well\n+â”Š   â”Š 54â”Š    if (this.size) {\n+â”Š   â”Š 55â”Š      let ratio = this.size / this.data.size;\n+â”Š   â”Š 56â”Š      canvas.height *= ratio;\n+â”Š   â”Š 57â”Š      canvas.width *= ratio;\n+â”Š   â”Š 58â”Š      context.scale(ratio, ratio);\n+â”Š   â”Š 59â”Š    }\n+â”Š   â”Š 60â”Š\n+â”Š   â”Š 61â”Š    // No we are going to draw each char on the canvas individually,\n+â”Š   â”Š 62â”Š    // naturally, there should be an offset after we draw each character.\n+â”Š   â”Š 63â”Š    // This variable will be used to calculate the offset\n+â”Š   â”Š 64â”Š    let offset = 0;\n+â”Š   â”Š 65â”Š\n+â”Š   â”Š 66â”Š    // Get for each char\n+â”Š   â”Š 67â”Š    _.map(text, (char) => {\n+â”Š   â”Š 68â”Š      return this.getCharSprite(char);\n+â”Š   â”Š 69â”Š    })\n+â”Š   â”Š 70â”Š    // Start drawing each char on the canvas\n+â”Š   â”Š 71â”Š    .forEach((charSprite, index) => {\n+â”Š   â”Š 72â”Š      let charData = this.data.chars[text.charAt(index)];\n+â”Š   â”Š 73â”Š\n+â”Š   â”Š 74â”Š      // Each char in the font xml has a native offset in addition to its rectangle.\n+â”Š   â”Š 75â”Š      // This option will disable the calculation of the native offset\n+â”Š   â”Š 76â”Š      if (noOffsets) {\n+â”Š   â”Š 77â”Š        charSprite.draw(context, offset);\n+â”Š   â”Š 78â”Š      }\n+â”Š   â”Š 79â”Š      else {\n+â”Š   â”Š 80â”Š        charSprite.draw(context, offset + charData.offset.x, charData.offset.y);\n+â”Š   â”Š 81â”Š      }\n+â”Š   â”Š 82â”Š\n+â”Š   â”Š 83â”Š      if (noSpaces) {\n+â”Š   â”Š 84â”Š        offset += charSprite.width;\n+â”Š   â”Š 85â”Š      }\n+â”Š   â”Š 86â”Š      else {\n+â”Š   â”Š 87â”Š        offset += charData.width;\n+â”Š   â”Š 88â”Š      }\n+â”Š   â”Š 89â”Š\n+â”Š   â”Š 90â”Š      // A color for the font can be specified as well\n+â”Š   â”Š 91â”Š      if (this.color) {\n+â”Š   â”Š 92â”Š        let overlayCanvas = document.createElement(\"canvas\");\n+â”Š   â”Š 93â”Š        let overlayContext = overlayCanvas.getContext(\"2d\");\n+â”Š   â”Š 94â”Š        overlayCanvas.width = width;\n+â”Š   â”Š 95â”Š        overlayCanvas.height = height;\n+â”Š   â”Š 96â”Š        overlayContext.beginPath();\n+â”Š   â”Š 97â”Š        overlayContext.rect(0, 0, width, height);\n+â”Š   â”Š 98â”Š        overlayContext.fillStyle = this.color;\n+â”Š   â”Š 99â”Š        overlayContext.fill();\n+â”Š   â”Š100â”Š\n+â”Š   â”Š101â”Š        context.save();\n+â”Š   â”Š102â”Š        context.globalCompositeOperation = \"source-in\";\n+â”Š   â”Š103â”Š        context.drawImage(overlayCanvas, 0, 0);\n+â”Š   â”Š104â”Š        context.restore();\n+â”Š   â”Š105â”Š      }\n+â”Š   â”Š106â”Š    });\n+â”Š   â”Š107â”Š\n+â”Š   â”Š108â”Š    // The canvas will be treated like an image\n+â”Š   â”Š109â”Š    return canvas;\n+â”Š   â”Š110â”Š  }\n+â”Š   â”Š111â”Š\n+â”Š   â”Š112â”Š  // Gets a sprite of the given char, using the current font\n+â”Š   â”Š113â”Š  getCharSprite(char) {\n+â”Š   â”Š114â”Š    // If char is already stored in cache, abort calculation and return it\n+â”Š   â”Š115â”Š    if (this.charSpritesCache[char]) return this.charSpritesCache[char];\n+â”Š   â”Š116â”Š\n+â”Š   â”Š117â”Š    // This data is fetched by the given json\n+â”Š   â”Š118â”Š    let { x, y, width, height } = this.data.chars[char].rect;\n+â”Š   â”Š119â”Š    // Creating a canvas which we will use to draw on,\n+â”Š   â”Š120â”Š    // but it is used exactly like an image afterwards\n+â”Š   â”Š121â”Š    let canvas = document.createElement(\"canvas\");\n+â”Š   â”Š122â”Š    let context = canvas.getContext(\"2d\");\n+â”Š   â”Š123â”Š\n+â”Š   â”Š124â”Š    // The canvas will have the same dimensions as the font\n+â”Š   â”Š125â”Š    canvas.width = width;\n+â”Š   â”Š126â”Š    canvas.height = height;\n+â”Š   â”Š127â”Š    // Draw a cropped image from the atlas, this image contains the char font\n+â”Š   â”Š128â”Š    context.drawImage(this.atlas, x, y, width, height, 0, 0, width, height);\n+â”Š   â”Š129â”Š\n+â”Š   â”Š130â”Š    // Store in cache and return it\n+â”Š   â”Š131â”Š    return this.charSpritesCache[char] = new Engine.Sprite(canvas);\n+â”Š   â”Š132â”Š  }\n+â”Š   â”Š133â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -10,6 +10,7 @@\n â”Š10â”Š10â”Š    <!-- Scripts -->\n â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n â”Š12â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/restorable.js\"></script>\n+â”Š  â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/font.js\"></script>\n â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/sprite.js\"></script>\n â”Š14â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/animations/keyframe.js\"></script>\n â”Š15â”Š16â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/key_states.js\"></script>\n```\n\n[}]: #\n\nThe font API shares a similar API as [HTMLImageElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/Image), once we set the `src` property the font will start loading itself, and the `onload` user-defined callback should be called once finished. Another neat feature would be the `createTexture` method, which takes a string as its first argument, representing the text that we would like to generate, and returns an instance of the `Sprite` class.\n\nWe will also be adding the option to load some font assets in our asset-loader:\n\n[{]: <helper> (diffStep 4.13)\n\n#### [Step 4.13: Add a font loading option to &#x27;AssetLoader&#x27;](https://github.com/DAB0mB/radial-snake/commit/a9d73cc)\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;assets_loader.js\n```diff\n@@ -10,4 +10,12 @@\n â”Š10â”Š10â”Š    image.src = `${path}.png`;\n â”Š11â”Š11â”Š    return image;\n â”Š12â”Š12â”Š  }\n+â”Š  â”Š13â”Š\n+â”Š  â”Š14â”Š  // Load font\n+â”Š  â”Š15â”Š  font(path) {\n+â”Š  â”Š16â”Š    let font = new Engine.Font();\n+â”Š  â”Š17â”Š    font.onload = this.next();\n+â”Š  â”Š18â”Š    font.src = path;\n+â”Š  â”Š19â”Š    return font;\n+â”Š  â”Š20â”Š  }\n â”Š13â”Š21â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nAnd replace the instructions texture loading with a `minecraftia` font loading in the initial splash screen:\n\n[{]: <helper> (diffStep 4.14)\n\n#### [Step 4.14: Load &#x27;minecraftia&#x27; font in splash screen](https://github.com/DAB0mB/radial-snake/commit/231a68f)\n\n##### Changed resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;splash&#x2F;index.js\n```diff\n@@ -33,7 +33,7 @@\n â”Š33â”Š33â”Š\n â”Š34â”Š34â”Š  load(assetsLoader) {\n â”Š35â”Š35â”Š    // Load assets\n-â”Š36â”Š  â”Š    let instructionsTexture = assetsLoader.texture(\"/textures/instrucitons\");\n+â”Š  â”Š36â”Š    let minecraftiaFont = assetsLoader.font(\"/fonts/minecraftia\");\n â”Š37â”Š37â”Š    let logoTexture = assetsLoader.texture(\"/textures/logo\");\n â”Š38â”Š38â”Š    let splashTexture = assetsLoader.texture(\"/textures/splash\");\n â”Š39â”Š39â”Š\n```\n```diff\n@@ -41,7 +41,7 @@\n â”Š41â”Š41â”Š    // disposed. We use the time gap created by the splash animation to load necessary\n â”Š42â”Š42â”Š    // assets without wasting any time\n â”Š43â”Š43â”Š    this.game.extendAssets({\n-â”Š44â”Š  â”Š      instructionsTexture,\n+â”Š  â”Š44â”Š      minecraftiaFont,\n â”Š45â”Š45â”Š      logoTexture\n â”Š46â”Š46â”Š    });\n```\n\n[}]: #\n\nNow it can use us in the main menu screen where we will create a text-sprite saying `Press a key to start`, just like the instruction sprite we're about to replace:\n\n[{]: <helper> (diffStep 4.15)\n\n#### [Step 4.15: Replace texture usage with font usage in main menu screen](https://github.com/DAB0mB/radial-snake/commit/a769b81)\n\n##### Changed resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;menu&#x2F;index.js\n```diff\n@@ -5,7 +5,8 @@\n â”Š 5â”Š 5â”Š    this.logoSprite.setPercentage(\"width\", this.width, 30, \"height\");\n â”Š 6â”Š 6â”Š\n â”Š 7â”Š 7â”Š    // Initialize instructions sprite\n-â”Š 8â”Š  â”Š    let instructionsSprite = new Engine.Sprite(this.assets.instructionsTexture);\n+â”Š  â”Š 8â”Š    let instructionsTexture = this.assets.minecraftiaFont.createTexture(\"Press a key to start\");\n+â”Š  â”Š 9â”Š    let instructionsSprite = new Engine.Sprite(instructionsTexture);\n â”Š 9â”Š10â”Š    instructionsSprite.align = \"center\";\n â”Š10â”Š11â”Š    instructionsSprite.setPercentage(\"width\", this.width, 35, \"height\");\n â”Š11â”Š12â”Š    instructionsSprite.x = this.width / 2;\n```\n```diff\n@@ -30,7 +31,7 @@\n â”Š30â”Š31â”Š\n â”Š31â”Š32â”Š  unload() {\n â”Š32â”Š33â”Š    // Dispose the following assets to prevent memory leaks\n-â”Š33â”Š  â”Š    return [\"logoTexture\", \"instructionsTexture\"];\n+â”Š  â”Š34â”Š    return \"logoTexture\";\n â”Š34â”Š35â”Š  }\n â”Š35â”Š36â”Š\n â”Š36â”Š37â”Š  draw(context) {\n```\n```diff\n@@ -41,4 +42,8 @@\n â”Š41â”Š42â”Š  update(span) {\n â”Š42â”Š43â”Š    this.instructionsAnim.update(span);\n â”Š43â”Š44â”Š  }\n+â”Š  â”Š45â”Š\n+â”Š  â”Š46â”Š  update(span) {\n+â”Š  â”Š47â”Š    this.instructionsAnim.update(span);\n+â”Š  â”Š48â”Š  }\n â”Š44â”Š49â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nIt shouldn't look any different from the beginning of the step where we manually drew the instruction texture, but in the next steps we will be using the font-engine a lot, and you will be thankful for what we've just did."
          },
          {
            "manualTitle": "Step 5: Creating a snake and related geometry shapes",
            "stepRevision": "ad178e03e276b088c96d6f67889db379ad201e3e",
            "manualView": "![snake-illustrate](https://cloud.githubusercontent.com/assets/7648874/21074115/46ef4466-bed7-11e6-9d5d-12fa6d43147b.gif)\n\nIn this step we will be creating all the necessary geometry shapes to form a snake; we're basically implementing the right infrastructure so in the next step we will be able to implement the game screen with ease. What exactly do I mean by \"geometry shapes\"? Well, our snake will be made out of circles, and lines. If we don't press any buttons at all, the snake should move forward at a straight line, and once we press on one of the arrow keys, the snake should move in a circular motion. Not only we want to draw the screen on the canvas, we also want to be able to detect collision with other snakes, since this is a \"Tron\" style game where we gonna fight against an opponent.\n\nKeep in mind that a computer's precision is limited due its [binary representation in memory](https://en.wikipedia.org/wiki/Memory_cell_(binary)). We need to take into consideration that there might be a significant deviation when detecting collisions and intersections between geometry shapes, especially when elapsed time is not always guaranteed to stay precise. To handle these deviation issues, we're gonna create some utility functions and place then in a new module called `Utils`:\n\n[{]: <helper> (diffStep 5.1)\n\n#### [Step 5.1: Create utilities module](https://github.com/DAB0mB/radial-snake/commit/58ae99a)\n\n##### Added resources&#x2F;scripts&#x2F;utils.js\n```diff\n@@ -0,0 +1,68 @@\n+â”Š  â”Š 1â”Š// A wrapper function for our utilities which will enable chaining\n+â”Š  â”Š 2â”Š// e.g. Utils().mod().trim().isBetween()...\n+â”Š  â”Š 3â”ŠUtils = function Utils(context) {\n+â”Š  â”Š 4â”Š  const chain = {};\n+â”Š  â”Š 5â”Š\n+â”Š  â”Š 6â”Š  Object.keys(Utils).forEach((utilName) => {\n+â”Š  â”Š 7â”Š    chain[utilName] = (...args) => {\n+â”Š  â”Š 8â”Š      const result = Utils[utilName](context, ...args);\n+â”Š  â”Š 9â”Š      return Utils(result);\n+â”Š  â”Š10â”Š    };\n+â”Š  â”Š11â”Š  });\n+â”Š  â”Š12â”Š\n+â”Š  â”Š13â”Š  // Returns the result of the chaining\n+â”Š  â”Š14â”Š  chain.value = () => context;\n+â”Š  â”Š15â”Š\n+â”Š  â”Š16â”Š  return chain;\n+â”Š  â”Š17â”Š};\n+â”Š  â”Š18â”Š\n+â”Š  â”Š19â”Š// Fixed modulo method which can calculate modulo of negative numbers properly\n+â”Š  â”Š20â”Š// e.g. (-803).mod(800) returns 797\n+â”Š  â”Š21â”ŠUtils.mod = function (context, num) {\n+â”Š  â”Š22â”Š  return ((context % num) + num) % num;\n+â”Š  â”Š23â”Š};\n+â”Š  â”Š24â”Š\n+â”Š  â”Š25â”Š// Trims number and leaves the number of decimals specified.\n+â”Š  â”Š26â”Š// The \"mode\" argument specifies which math function should be invoked\n+â”Š  â”Š27â”Š// right after the number has been trimmed.\n+â”Š  â”Š28â”Š// e.g. 12.12345.trim(3, \"ceil\") returns 12.124\n+â”Š  â”Š29â”ŠUtils.trim = function (context, decimals, mode = \"round\") {\n+â”Š  â”Š30â”Š  return Math[mode](context * Math.pow(10, decimals)) / Math.pow(10, decimals);\n+â”Š  â”Š31â”Š};\n+â”Š  â”Š32â”Š\n+â”Š  â”Š33â”Š// Tells if number is in specified range based on given precision.\n+â”Š  â”Š34â”Š// See the \"compare\" method for more information about precision\n+â”Š  â”Š35â”ŠUtils.isBetween = function (context, num1, num2, precision) {\n+â”Š  â”Š36â”Š  return Utils.compare(context, Math.min(num1, num2), \">=\", precision) &&\n+â”Š  â”Š37â”Š         Utils.compare(context, Math.max(num1, num2), \"<=\", precision);\n+â”Š  â”Š38â”Š};\n+â”Š  â”Š39â”Š\n+â”Š  â”Š40â”Š// Initiates comparison operator between context number and a given number, only here\n+â”Š  â”Š41â”Š// a precision can be specified\n+â”Š  â”Š42â”ŠUtils.compare = function (context, num, method, precision = method) {\n+â”Š  â”Š43â”Š  switch (precision) {\n+â”Š  â”Š44â”Š    // Fixed precision, \"almost equal\" with a deviation of Îµ\n+â”Š  â”Š45â”Š    case \"f\":\n+â”Š  â”Š46â”Š      switch (method) {\n+â”Š  â”Š47â”Š        case \"<\": case \"<=\": return context <= num + Number.EPSILON;\n+â”Š  â”Š48â”Š        case \">\": case \">=\": return context >= num - Number.EPSILON;\n+â”Š  â”Š49â”Š        default: return Math.abs(context - num) <= Number.EPSILON;\n+â”Š  â”Š50â”Š      }\n+â”Š  â”Š51â”Š    // Pixel precision, round comparison\n+â”Š  â”Š52â”Š    case \"px\":\n+â”Š  â”Š53â”Š      switch (method) {\n+â”Š  â”Š54â”Š        case \"<\": case \"<=\": return Math.round(context) <= Math.round(num);\n+â”Š  â”Š55â”Š        case \">\": case \">=\": return Math.round(context) >= Math.round(num);\n+â”Š  â”Š56â”Š        default: return Math.round(context) == Math.round(num);\n+â”Š  â”Š57â”Š      }\n+â”Š  â”Š58â”Š    // Exact precision\n+â”Š  â”Š59â”Š    default:\n+â”Š  â”Š60â”Š      switch (method) {\n+â”Š  â”Š61â”Š        case \"<\": return context < num;\n+â”Š  â”Š62â”Š        case \"<=\": return context <= num;\n+â”Š  â”Š63â”Š        case \">\": return context > num;\n+â”Š  â”Š64â”Š        case \">=\": return context >= num;\n+â”Š  â”Š65â”Š        default: return context === num;\n+â”Š  â”Š66â”Š      }\n+â”Š  â”Š67â”Š  }\n+â”Š  â”Š68â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -8,6 +8,7 @@\n â”Š 8â”Š 8â”Š    <script type=\"text/javascript\" src=\"/libs/underscore.js\"></script>\n â”Š 9â”Š 9â”Š\n â”Š10â”Š10â”Š    <!-- Scripts -->\n+â”Š  â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/utils.js\"></script>\n â”Š11â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n â”Š12â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/restorable.js\"></script>\n â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/font.js\"></script>\n```\n\n[}]: #\n\nNow we would like to start implementing the first class representation for a line, and for that we're requires to add a new module called `Geometry` to the `Engine` namespace:\n\n[{]: <helper> (diffStep 5.2)\n\n#### [Step 5.2: Add &#x27;Shapes&#x27; module to &#x27;Engine&#x27; namespace](https://github.com/DAB0mB/radial-snake/commit/4ed2788)\n\n##### Changed resources&#x2F;scripts&#x2F;namespaces.js\n```diff\n@@ -3,5 +3,6 @@\n â”Š3â”Š3â”Š};\n â”Š4â”Š4â”Š\n â”Š5â”Š5â”ŠEngine = {\n-â”Š6â”Š â”Š  Animations: {}\n+â”Š â”Š6â”Š  Animations: {},\n+â”Š â”Š7â”Š  Geometry: {}\n â”Š7â”Š8â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nAnd now that we have this module available to use, we can go ahead and implement our first geometry shape class - `Line`:\n\n[{]: <helper> (diffStep 5.3)\n\n#### [Step 5.3: Create &#x27;Line&#x27; class](https://github.com/DAB0mB/radial-snake/commit/fb38ab5)\n\n##### Added resources&#x2F;scripts&#x2F;engine&#x2F;geometry&#x2F;line.js\n```diff\n@@ -0,0 +1,65 @@\n+â”Š  â”Š 1â”ŠEngine.Geometry.Line = class Line {\n+â”Š  â”Š 2â”Š  // x1 - The first point's x value\n+â”Š  â”Š 3â”Š  // y1 - The first point's y value\n+â”Š  â”Š 4â”Š  // x1 - The second point's x value\n+â”Š  â”Š 5â”Š  // y2 - The second point's y value\n+â”Š  â”Š 6â”Š  constructor(x1, y1, x2, y2) {\n+â”Š  â”Š 7â”Š    this.x1 = Utils.trim(x1, 9);\n+â”Š  â”Š 8â”Š    this.y1 = Utils.trim(y1, 9);\n+â”Š  â”Š 9â”Š    this.x2 = Utils.trim(x2, 9);\n+â”Š  â”Š10â”Š    this.y2 = Utils.trim(y2, 9);\n+â”Š  â”Š11â”Š  }\n+â”Š  â”Š12â”Š\n+â”Š  â”Š13â”Š  // Draws the line on the given context\n+â”Š  â”Š14â”Š  draw(context) {\n+â”Š  â”Š15â”Š    context.moveTo(this.x1, this.y1);\n+â”Š  â”Š16â”Š    context.lineTo(this.x2, this.y2);\n+â”Š  â”Š17â”Š  }\n+â”Š  â”Š18â”Š\n+â”Š  â”Š19â”Š  // Gets the matching x value for a given y value\n+â”Š  â”Š20â”Š  getX(y) {\n+â”Š  â”Š21â”Š    let x = Utils.trim((((y - this.y1) * (this.x2 - this.x1)) / (this.y2 - this.y1)) + this.x1, 9);\n+â”Š  â”Š22â”Š    if (isNaN(x) || Utils.isBetween(x, this.x1, this.x2)) return x;\n+â”Š  â”Š23â”Š  }\n+â”Š  â”Š24â”Š\n+â”Š  â”Š25â”Š  // Gets the matching y value for a given x value\n+â”Š  â”Š26â”Š  getY(x) {\n+â”Š  â”Š27â”Š    let y = Utils.trim((((x - this.x1) * (this.y2 - this.y1)) / (this.x2 - this.x1)) + this.y1, 9);\n+â”Š  â”Š28â”Š    if (isNaN(y) || Utils.isBetween(y, this.y1, this.y2)) return y;\n+â”Š  â”Š29â”Š  }\n+â”Š  â”Š30â”Š\n+â”Š  â”Š31â”Š  // Returns if line has given point\n+â”Š  â”Š32â”Š  hasPoint(x, y) {\n+â”Š  â”Š33â”Š    if (!this.boundsHavePoint(x, y)) return false;\n+â”Š  â”Š34â”Š    let m = Utils.trim((this.y2 - this.y1) / (this.x2 - this.x1), 9);\n+â”Š  â”Š35â”Š    return (y - this.y1) / (x - this.x1) == m;\n+â”Š  â”Š36â”Š  }\n+â”Š  â”Š37â”Š\n+â”Š  â”Š38â”Š  // Returns if given point is contained by the bounds aka cage of line\n+â”Š  â”Š39â”Š  boundsHavePoint(x, y) {\n+â”Š  â”Š40â”Š    return Utils.isBetween(x, this.x1, this.x2) &&\n+â”Š  â”Š41â”Š           Utils.isBetween(y, this.y1, this.y2);\n+â”Š  â”Š42â”Š  }\n+â”Š  â”Š43â”Š\n+â”Š  â”Š44â”Š  getIntersection(shape) {\n+â”Š  â”Š45â”Š    if (shape instanceof Engine.Geometry.Line)\n+â”Š  â”Š46â”Š      return this.getLineIntersection(shape);\n+â”Š  â”Š47â”Š  }\n+â”Š  â”Š48â”Š\n+â”Š  â”Š49â”Š  // line - line intersection method\n+â”Š  â”Š50â”Š  getLineIntersection(line) {\n+â”Š  â”Š51â”Š    // Escape if lines are parallel\n+â”Š  â”Š52â”Š    if (!(((this.x1 - this.x2) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * (line.x1 - line.x2)))) return;\n+â”Š  â”Š53â”Š\n+â”Š  â”Š54â”Š    // Intersection point formula\n+â”Š  â”Š55â”Š    let x = Utils.trim(((((this.x1 * this.y2) - (this.y1 * this.x2)) * (line.x1 - line.x2)) - ((this.x1 - this.x2) * ((line.x1 * line.y2) - (line.y1 * line.x2)))) /\n+â”Š  â”Š56â”Š        (((this.x1 - this.x2) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * (line.x1 - line.x2))), 9);\n+â”Š  â”Š57â”Š    let y = Utils.trim(((((this.x1 * this.y2) - (this.y1 * this.x2)) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * ((line.x1 * line.y2) - (line.y1 * line.x2)))) /\n+â”Š  â”Š58â”Š        (((this.x1 - this.x2) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * (line.x1 - line.x2))), 9);\n+â”Š  â”Š59â”Š\n+â”Š  â”Š60â”Š    if (Utils.isBetween(x, this.x1, this.x2) && Utils.isBetween(x, line.x1, line.x2) &&\n+â”Š  â”Š61â”Š        Utils.isBetween(y, this.y1, this.y2) && Utils.isBetween(y, line.y1, line.y2)) {\n+â”Š  â”Š62â”Š      return { x, y };\n+â”Š  â”Š63â”Š    }\n+â”Š  â”Š64â”Š  }\n+â”Š  â”Š65â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -10,6 +10,7 @@\n â”Š10â”Š10â”Š    <!-- Scripts -->\n â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/utils.js\"></script>\n â”Š12â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n+â”Š  â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/geometry/line.js\"></script>\n â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/restorable.js\"></script>\n â”Š14â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/font.js\"></script>\n â”Š15â”Š16â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/sprite.js\"></script>\n```\n\n[}]: #\n\nYou can go through the comments of the step above which will guide you through the programmatic aspect of it, but I think it's more important to understand the concept of a line in 2D space. A line is made out of two points, usually represented as `(x1, y1)` and `(x2, y2)`. The slope of the line, usually represented as `m`, can be determined using these two points based on the following formula:\n\n![slope](https://cloud.githubusercontent.com/assets/7648874/21788249/b4c7e41c-d6b4-11e6-9c17-baff66ec6bc8.png)\n\nOnce we have two lines whose `m` is different (Unparalleled) and there is no intersection between the points of which they are represented with (In which case they are united), there must be an intersection point. The intersection point can be found using the following formula:\n\n![line-line](https://cloud.githubusercontent.com/assets/7648874/21787164/c9d83bf0-d6ae-11e6-9846-4fc013eebab3.png)\n\n![line-line-illustration](https://cloud.githubusercontent.com/assets/7648874/21790864/56725cf0-d6c6-11e6-916b-50b1fc0b87af.png)\n\n> See reference: http://mathworld.wolfram.com/Line-LineIntersection.html.\n\nObviously we have some logic here which needs to be tested. To test our `Line` class, we will be using a testing framework called [Jasmine](https://jasmine.github.io/). We first need to download `Jasmine`'s essentials in order for it to work:\n\n    resources/libs$ mkdir jasmine\n    resources/libs$ cd jasmine\n    resources/libs/jasmine$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/libs/jasmine/boot.js\n    resources/libs/jasmine$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/libs/jasmine/console.js\n    resources/libs/jasmine$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/libs/jasmine/jasmine-html.js\n    resources/libs/jasmine$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/libs/jasmine/jasmine.css\n    resources/libs/jasmine$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/libs/jasmine/jasmine.js\n    resources/libs/jasmine$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/libs/jasmine/jasmine_favicon.png\n\nThese essentials should be loaded in a newly created view where we're gonna see our specs running:\n\n[{]: <helper> (diffStep 5.5)\n\n#### [Step 5.5: Create specs runner view](https://github.com/DAB0mB/radial-snake/commit/150be1a)\n\n##### Added views&#x2F;spec_runner.html\n```diff\n@@ -0,0 +1,27 @@\n+â”Š  â”Š 1â”Š\n+â”Š  â”Š 2â”Š<!DOCTYPE html>\n+â”Š  â”Š 3â”Š<html>\n+â”Š  â”Š 4â”Š  <head>\n+â”Š  â”Š 5â”Š    <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n+â”Š  â”Š 6â”Š    <title>Jasmine Spec Runner v2.0.1</title>\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Š    <!-- Jasmine -->\n+â”Š  â”Š 9â”Š    <script type=\"text/javascript\" src=\"libs/jasmine/jasmine.js\"></script>\n+â”Š  â”Š10â”Š    <script type=\"text/javascript\" src=\"libs/jasmine/jasmine-html.js\"></script>\n+â”Š  â”Š11â”Š    <script type=\"text/javascript\" src=\"libs/jasmine/boot.js\"></script>\n+â”Š  â”Š12â”Š    <link rel=\"shortcut icon\" type=\"image/png\" href=\"libs/jasmine/jasmine_favicon.png\">\n+â”Š  â”Š13â”Š    <link rel=\"stylesheet\" type=\"text/css\" href=\"libs/jasmine/jasmine.css\">\n+â”Š  â”Š14â”Š\n+â”Š  â”Š15â”Š    <!-- Libs -->\n+â”Š  â”Š16â”Š    <script type=\"text/javascript\" src=\"libs/underscore.js\"></script>\n+â”Š  â”Š17â”Š\n+â”Š  â”Š18â”Š    <!-- Scripts -->\n+â”Š  â”Š19â”Š    <script type=\"text/javascript\" src=\"scripts/utils.js\"></script>\n+â”Š  â”Š20â”Š    <script type=\"text/javascript\" src=\"scripts/namespaces.js\"></script>\n+â”Š  â”Š21â”Š\n+â”Š  â”Š22â”Š    <!-- Specs -->\n+â”Š  â”Š23â”Š  </head>\n+â”Š  â”Š24â”Š\n+â”Š  â”Š25â”Š  <body>\n+â”Š  â”Š26â”Š  </body>\n+â”Š  â”Š27â”Š</html>ðŸš«â†µ\n```\n\n[}]: #\n\nNow once we'll navigate to the `/test` sub-route (`localhost:8000/test` by default) we should be provided with the spec runner. As for now there are no specs implemented at all, which brings us to the next stage - Implementing tests for `Line` class:\n\n[{]: <helper> (diffStep 5.6)\n\n#### [Step 5.6: Create &#x27;Line&#x27; class tests](https://github.com/DAB0mB/radial-snake/commit/c052752)\n\n##### Added resources&#x2F;scripts&#x2F;specs&#x2F;engine&#x2F;geometry&#x2F;line.js\n```diff\n@@ -0,0 +1,78 @@\n+â”Š  â”Š 1â”Šdescribe(\"Engine.Geometry.Line class\", function() {\n+â”Š  â”Š 2â”Š  beforeEach(function() {\n+â”Š  â”Š 3â”Š    this.line = new Engine.Geometry.Line(-5, -5, 5, 5);\n+â”Š  â”Š 4â”Š  });\n+â”Š  â”Š 5â”Š\n+â”Š  â”Š 6â”Š  describe(\"getX method\", function() {\n+â”Š  â”Š 7â”Š    describe(\"given inranged y\", function() {\n+â”Š  â”Š 8â”Š      it(\"returns x\", function() {\n+â”Š  â”Š 9â”Š        expect(this.line.getX(1)).toBeCloseTo(1);\n+â”Š  â”Š10â”Š      });\n+â”Š  â”Š11â”Š    });\n+â”Š  â”Š12â”Š\n+â”Š  â”Š13â”Š    describe(\"given outranged y\", function() {\n+â”Š  â”Š14â”Š      it(\"returns nothing\", function() {\n+â”Š  â”Š15â”Š        expect(this.line.getX(10)).toBeUndefined();\n+â”Š  â”Š16â”Š      });\n+â”Š  â”Š17â”Š    });\n+â”Š  â”Š18â”Š  });\n+â”Š  â”Š19â”Š\n+â”Š  â”Š20â”Š  describe(\"getY method\", function() {\n+â”Š  â”Š21â”Š    describe(\"given inranged x\", function() {\n+â”Š  â”Š22â”Š      it(\"returns y\", function() {\n+â”Š  â”Š23â”Š        expect(this.line.getY(1)).toBeCloseTo(1);\n+â”Š  â”Š24â”Š      });\n+â”Š  â”Š25â”Š    });\n+â”Š  â”Š26â”Š\n+â”Š  â”Š27â”Š    describe(\"given outranged x\", function() {\n+â”Š  â”Š28â”Š      it(\"returns nothing\", function() {\n+â”Š  â”Š29â”Š        expect(this.line.getY(10)).toBeUndefined();\n+â”Š  â”Š30â”Š      });\n+â”Š  â”Š31â”Š    });\n+â”Š  â”Š32â”Š  });\n+â”Š  â”Š33â”Š\n+â”Š  â”Š34â”Š  describe(\"hasPoint method\", function() {\n+â”Š  â”Š35â”Š    describe(\"given contained point\", function() {\n+â”Š  â”Š36â”Š      it(\"returns true\", function() {\n+â”Š  â”Š37â”Š        let x = 1;\n+â”Š  â”Š38â”Š        let y = 1;\n+â”Š  â”Š39â”Š        expect(this.line.hasPoint(x, y)).toBeTruthy();\n+â”Š  â”Š40â”Š      });\n+â”Š  â”Š41â”Š    });\n+â”Š  â”Š42â”Š\n+â”Š  â”Š43â”Š    describe(\"given uncontained point\", function() {\n+â”Š  â”Š44â”Š      it(\"returns false\", function() {\n+â”Š  â”Š45â”Š        let x = 10;\n+â”Š  â”Š46â”Š        let y = 10;\n+â”Š  â”Š47â”Š        expect(this.line.hasPoint(x, y)).toBeFalsy();\n+â”Š  â”Š48â”Š      });\n+â”Š  â”Š49â”Š    });\n+â”Š  â”Š50â”Š  });\n+â”Š  â”Š51â”Š\n+â”Š  â”Š52â”Š  describe(\"getLineIntersection method\", function() {\n+â”Š  â”Š53â”Š    describe(\"given intersecting line\", function() {\n+â”Š  â”Š54â”Š      it(\"returns intersection point\", function() {\n+â”Š  â”Š55â”Š        let line = new Engine.Geometry.Line(1, -5, 1, 5);\n+â”Š  â”Š56â”Š\n+â”Š  â”Š57â”Š        expect(this.line.getLineIntersection(line)).toEqual({\n+â”Š  â”Š58â”Š          x: 1,\n+â”Š  â”Š59â”Š          y: 1\n+â”Š  â”Š60â”Š        });\n+â”Š  â”Š61â”Š      });\n+â”Š  â”Š62â”Š    });\n+â”Š  â”Š63â”Š\n+â”Š  â”Š64â”Š    describe(\"given parallel line\", function() {\n+â”Š  â”Š65â”Š      it(\"returns nothing\", function() {\n+â”Š  â”Š66â”Š        let line = new Engine.Geometry.Line(-5, -6, 5, 4);\n+â”Š  â”Š67â”Š        expect(this.line.getLineIntersection(line)).toBeUndefined();\n+â”Š  â”Š68â”Š      });\n+â”Š  â”Š69â”Š    });\n+â”Š  â”Š70â”Š\n+â”Š  â”Š71â”Š    describe(\"given outranged line\", function() {\n+â”Š  â”Š72â”Š      it(\"returns nothing\", function() {\n+â”Š  â”Š73â”Š        let line = new Engine.Geometry.Line(10, 10, 10, 15);\n+â”Š  â”Š74â”Š        expect(this.line.getLineIntersection(line)).toBeUndefined();\n+â”Š  â”Š75â”Š      });\n+â”Š  â”Š76â”Š    });\n+â”Š  â”Š77â”Š  });\n+â”Š  â”Š78â”Š});ðŸš«â†µ\n```\n\n##### Changed views&#x2F;spec_runner.html\n```diff\n@@ -18,8 +18,10 @@\n â”Š18â”Š18â”Š    <!-- Scripts -->\n â”Š19â”Š19â”Š    <script type=\"text/javascript\" src=\"scripts/utils.js\"></script>\n â”Š20â”Š20â”Š    <script type=\"text/javascript\" src=\"scripts/namespaces.js\"></script>\n+â”Š  â”Š21â”Š    <script type=\"text/javascript\" src=\"scripts/engine/geometry/line.js\"></script>\n â”Š21â”Š22â”Š\n â”Š22â”Š23â”Š    <!-- Specs -->\n+â”Š  â”Š24â”Š    <script type=\"text/javascript\" src=\"scripts/specs/engine/geometry/line.js\"></script>\n â”Š23â”Š25â”Š  </head>\n â”Š24â”Š26â”Š\n â”Š25â”Š27â”Š  <body>\n```\n\n[}]: #\n\nNow if you'll refresh the spec runner page you should be able to a green screen indicating all tests have passed (Assuming the tutorial is updated and you followed it correctly). As introduced at the beginning of the step, the snake is also dependent on circles, whose representing class should look like so:\n\n[{]: <helper> (diffStep 5.7)\n\n#### [Step 5.7: Create &#x27;Circle&#x27; class](https://github.com/DAB0mB/radial-snake/commit/f9c5723)\n\n##### Added resources&#x2F;scripts&#x2F;engine&#x2F;geometry&#x2F;circle.js\n```diff\n@@ -0,0 +1,167 @@\n+â”Š   â”Š  1â”ŠEngine.Geometry.Circle = class Circle {\n+â”Š   â”Š  2â”Š  // x - The x value of the circle's center\n+â”Š   â”Š  3â”Š  // y - The y value of the circle's center\n+â”Š   â”Š  4â”Š  // r - The radius of the center\n+â”Š   â”Š  5â”Š  // rad1 - The first radian of the circle, not necessarily its beginning\n+â”Š   â”Š  6â”Š  // rad2 - The second radian of the circle, not necessarily its beginning\n+â”Š   â”Š  7â”Š  constructor(x, y, r, rad1, rad2) {\n+â”Š   â”Š  8â”Š    this.x = Utils.trim(x, 9);\n+â”Š   â”Š  9â”Š    this.y = Utils.trim(y, 9);\n+â”Š   â”Š 10â”Š    this.r = Utils.trim(r, 9);\n+â”Š   â”Š 11â”Š\n+â”Š   â”Š 12â”Š    // Trimming mode is done based on which radian represents the ending and which radian\n+â”Š   â”Š 13â”Š    // represents the ending\n+â”Š   â”Š 14â”Š    if (rad1 > rad2) {\n+â”Š   â”Š 15â”Š      this.rad1 = Utils.trim(rad1, 9, \"floor\");\n+â”Š   â”Š 16â”Š      this.rad2 = Utils.trim(rad2, 9, \"ceil\");\n+â”Š   â”Š 17â”Š    }\n+â”Š   â”Š 18â”Š    else {\n+â”Š   â”Š 19â”Š      this.rad1 = Utils.trim(rad1, 9, \"ceil\");\n+â”Š   â”Š 20â”Š      this.rad2 = Utils.trim(rad2, 9, \"floor\");\n+â”Š   â”Š 21â”Š    }\n+â”Š   â”Š 22â”Š  }\n+â”Š   â”Š 23â”Š\n+â”Š   â”Š 24â”Š  // Draws the circle on the given context\n+â”Š   â”Š 25â”Š  draw(context) {\n+â”Š   â”Š 26â”Š    context.arc(this.x, this.y, this.r, this.rad1, this.rad2);\n+â”Š   â”Š 27â”Š  }\n+â”Š   â”Š 28â”Š\n+â”Š   â”Š 29â”Š  // Gets the matching x value for the given radian\n+â”Š   â”Š 30â”Š  getX(rad) {\n+â”Š   â”Š 31â”Š    if (!Utils(rad).trim(9).isBetween(this.rad1, this.rad2).value()) return;\n+â”Š   â”Š 32â”Š    return Utils.trim((this.r * Math.cos(rad)) + this.x, 9);\n+â”Š   â”Š 33â”Š  }\n+â”Š   â”Š 34â”Š\n+â”Š   â”Š 35â”Š  // Gets the matching y value for the given radian\n+â”Š   â”Š 36â”Š  getY(rad) {\n+â”Š   â”Š 37â”Š    if (!Utils(rad).trim(9).isBetween(this.rad1, this.rad2).value()) return;\n+â”Š   â”Š 38â”Š    return Utils.trim((this.r * Math.sin(rad)) + this.y, 9);\n+â”Š   â”Š 39â”Š  }\n+â”Š   â”Š 40â”Š\n+â”Š   â”Š 41â”Š  // Gets the matching point for the given radian\n+â”Š   â”Š 42â”Š  getPoint(rad) {\n+â”Š   â”Š 43â”Š    if (!Utils.isBetween(rad, this.rad1, this.rad2)) return;\n+â”Š   â”Š 44â”Š\n+â”Š   â”Š 45â”Š    return {\n+â”Š   â”Š 46â”Š      x: Utils.trim((this.r * Math.cos(rad)) + this.x, 9),\n+â”Š   â”Š 47â”Š      y: Utils.trim((this.r * Math.sin(rad)) + this.y, 9)\n+â”Š   â”Š 48â”Š    };\n+â”Š   â”Š 49â”Š  }\n+â”Š   â”Š 50â”Š\n+â”Š   â”Š 51â”Š  // Gets the matching radian for the given point\n+â”Š   â”Š 52â”Š  getRad(x, y) {\n+â”Š   â”Š 53â”Š    let rad = Math.atan2(y - this.y, x - this.x);\n+â”Š   â”Š 54â”Š\n+â”Š   â”Š 55â”Š    // If calculated radian is in circle's radian range, return it\n+â”Š   â”Š 56â”Š    if (rad != null && Utils.isBetween(rad, this.rad1, this.rad2)) {\n+â”Š   â”Š 57â”Š      return rad;\n+â”Š   â”Š 58â”Š    }\n+â”Š   â”Š 59â”Š\n+â”Š   â”Š 60â”Š    // The calculated radian can still be in the circle's radian range in case one\n+â”Š   â”Š 61â”Š    // of the radians is greater than 2 PIEs\n+â”Š   â”Š 62â”Š    if (Math.abs(this.rad1) > Math.abs(this.rad2)) {\n+â”Š   â”Š 63â”Š      var greatestRad = this.rad1;\n+â”Š   â”Š 64â”Š    }\n+â”Š   â”Š 65â”Š    else {\n+â”Š   â”Š 66â”Š      var greatestRad = this.rad2;\n+â”Š   â”Š 67â”Š    }\n+â”Š   â”Š 68â”Š\n+â”Š   â”Š 69â”Š    // Check if the absolute radian is in the circle's radian range\n+â”Š   â”Š 70â”Š    if (Utils(rad + (2 * Math.PI * Math.floor(greatestRad / (2 * Math.PI)))).trim(9).isBetween(this.rad1, this.rad2).value() ||\n+â”Š   â”Š 71â”Š        Utils(rad + (2 * Math.PI * Math.ceil(greatestRad / (2 * Math.PI)))).trim(9).isBetween(this.rad1, this.rad2).value()) {\n+â”Š   â”Š 72â”Š      return rad;\n+â”Š   â”Š 73â”Š    }\n+â”Š   â”Š 74â”Š  }\n+â”Š   â”Š 75â”Š\n+â”Š   â”Š 76â”Š  // Returns if circle has given points\n+â”Š   â”Š 77â”Š  hasPoint(x, y) {\n+â”Š   â”Š 78â”Š    return this.getRad(x, y) != null;\n+â”Š   â”Š 79â”Š  }\n+â”Š   â”Š 80â”Š\n+â”Š   â”Š 81â”Š  getIntersection(shape) {\n+â”Š   â”Š 82â”Š    if (shape instanceof Engine.Geometry.Line)\n+â”Š   â”Š 83â”Š      return this.getLineIntersection(shape);\n+â”Š   â”Š 84â”Š    if (shape instanceof Engine.Geometry.Circle)\n+â”Š   â”Š 85â”Š      return this.getCircleIntersection(shape);\n+â”Š   â”Š 86â”Š  }\n+â”Š   â”Š 87â”Š\n+â”Š   â”Š 88â”Š  // circle - circle intersection method\n+â”Š   â”Š 89â”Š  getCircleIntersection(circle) {\n+â”Š   â”Š 90â”Š    let dx = circle.x - this.x;\n+â”Š   â”Š 91â”Š    let dy = circle.y - this.y;\n+â”Š   â”Š 92â”Š    let d = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\n+â”Š   â”Š 93â”Š\n+â”Š   â”Š 94â”Š    if (d > this.r + circle.r ||\n+â”Š   â”Š 95â”Š       d < Math.abs(this.r - circle.r)) {\n+â”Š   â”Š 96â”Š      return;\n+â”Š   â”Š 97â”Š    }\n+â”Š   â”Š 98â”Š\n+â”Š   â”Š 99â”Š    let a = ((Math.pow(this.r, 2) - Math.pow(circle.r, 2)) + Math.pow(d, 2)) / (2 * d);\n+â”Š   â”Š100â”Š    let x = this.x + ((dx * a) / d);\n+â”Š   â”Š101â”Š    let y = this.y + ((dy * a) / d);\n+â”Š   â”Š102â”Š    let h = Math.sqrt(Math.pow(this.r, 2) - Math.pow(a, 2));\n+â”Š   â”Š103â”Š    let rx = (- dy * h) / d;\n+â”Š   â”Š104â”Š    let ry = (dx * h) / d;\n+â”Š   â”Š105â”Š\n+â”Š   â”Š106â”Š    let interPoints = [\n+â”Š   â”Š107â”Š      {\n+â”Š   â”Š108â”Š        x: x + rx,\n+â”Š   â”Š109â”Š        y: y + ry\n+â”Š   â”Š110â”Š      },\n+â”Š   â”Š111â”Š      {\n+â”Š   â”Š112â”Š        x: x - rx,\n+â”Š   â”Š113â”Š        y: y - ry\n+â”Š   â”Š114â”Š      }\n+â”Š   â”Š115â”Š    ]\n+â”Š   â”Š116â”Š    .map(point => ({\n+â”Š   â”Š117â”Š        x: Utils.trim(point.x, 9),\n+â”Š   â”Š118â”Š        y: Utils.trim(point.y, 9)\n+â”Š   â”Š119â”Š     }));\n+â”Š   â”Š120â”Š\n+â”Š   â”Š121â”Š    interPoints = _.uniq(interPoints, point => `(${point.x}, ${point.y})`);\n+â”Š   â”Š122â”Š\n+â”Š   â”Š123â”Š    [this, circle].forEach(function(circle) {\n+â”Š   â”Š124â”Š      interPoints = interPoints.filter(point => circle.hasPoint(point.x, point.y));\n+â”Š   â”Š125â”Š    });\n+â”Š   â”Š126â”Š\n+â”Š   â”Š127â”Š    if (interPoints.length > 0) return interPoints;\n+â”Š   â”Š128â”Š  }\n+â”Š   â”Š129â”Š\n+â”Š   â”Š130â”Š  // circle - line intersection method\n+â”Š   â”Š131â”Š  getLineIntersection(line) {\n+â”Š   â”Š132â”Š    let x1 = line.x1 - this.x;\n+â”Š   â”Š133â”Š    let x2 = line.x2 - this.x;\n+â”Š   â”Š134â”Š    let y1 = line.y1 - this.y;\n+â”Š   â”Š135â”Š    let y2 = line.y2 - this.y;\n+â”Š   â”Š136â”Š    let dx = x2 - x1;\n+â”Š   â”Š137â”Š    let dy = y2 - y1;\n+â”Š   â”Š138â”Š    let d = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\n+â”Š   â”Š139â”Š    let h = (x1 * y2) - (x2 * y1);\n+â”Š   â”Š140â”Š    let delta = (Math.pow(this.r, 2) * Math.pow(d, 2)) - Math.pow(h, 2);\n+â”Š   â”Š141â”Š\n+â”Š   â”Š142â”Š    if (delta < 0) return;\n+â”Š   â”Š143â”Š\n+â”Š   â”Š144â”Š    let interPoints = [\n+â”Š   â”Š145â”Š      {\n+â”Š   â”Š146â”Š        x: (((h * dy) + (((dy / Math.abs(dy)) || 1) * dx * Math.sqrt(delta))) / Math.pow(d, 2)) + this.x,\n+â”Š   â”Š147â”Š        y: (((-h * dx) + (Math.abs(dy) * Math.sqrt(delta))) / Math.pow(d, 2)) + this.y\n+â”Š   â”Š148â”Š      },\n+â”Š   â”Š149â”Š      {\n+â”Š   â”Š150â”Š        x: (((h * dy) - (((dy / Math.abs(dy)) || 1) * dx * Math.sqrt(delta))) / Math.pow(d, 2)) + this.x,\n+â”Š   â”Š151â”Š        y: (((-h * dx) - (Math.abs(dy) * Math.sqrt(delta))) / Math.pow(d, 2)) + this.y\n+â”Š   â”Š152â”Š      }\n+â”Š   â”Š153â”Š    ]\n+â”Š   â”Š154â”Š    .map(point => ({\n+â”Š   â”Š155â”Š        x: Utils.trim(point.x, 9),\n+â”Š   â”Š156â”Š        y: Utils.trim(point.y, 9)\n+â”Š   â”Š157â”Š    }))\n+â”Š   â”Š158â”Š    .filter(point => {\n+â”Š   â”Š159â”Š      return this.hasPoint(point.x, point.y) &&\n+â”Š   â”Š160â”Š        line.boundsHavePoint(point.x, point.y);\n+â”Š   â”Š161â”Š    });\n+â”Š   â”Š162â”Š\n+â”Š   â”Š163â”Š    interPoints = _.uniq(interPoints, point => `(${point.x}, ${point.y})`);\n+â”Š   â”Š164â”Š\n+â”Š   â”Š165â”Š    if (interPoints.length > 0) return interPoints;\n+â”Š   â”Š166â”Š  }\n+â”Š   â”Š167â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -11,6 +11,7 @@\n â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/utils.js\"></script>\n â”Š12â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n â”Š13â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/geometry/line.js\"></script>\n+â”Š  â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/geometry/circle.js\"></script>\n â”Š14â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/restorable.js\"></script>\n â”Š15â”Š16â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/font.js\"></script>\n â”Š16â”Š17â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/sprite.js\"></script>\n```\n\n[}]: #\n\nJust like a line, a circle can be presented using variables as well. The center of the circle is represented as `(x, y)` and its radius is represented as `r`. Remember that our circle doesn't necessarily have to be a full one, therefore we limit its range using two radians - `rad1` and `rad2`. The formula for representing a circle in a 2D space looks like this:\n\n![circle-formula](https://cloud.githubusercontent.com/assets/7648874/21829783/84a54574-d77f-11e6-9b87-3fb0f073bb8d.png)\n\n![circle-circle-illustration](https://cloud.githubusercontent.com/assets/7648874/21790842/3a73408c-d6c6-11e6-8bdd-9c73355e6ebb.png)\n\n> `a` and `b` represent the offsets from the `x` and the `y` axes respectively.\n> See reference: http://mathworld.wolfram.com/Circle-CircleIntersection.html.\n\nTo find intersection between two circles, we simply calculate the solution for two equations with two variables. Given that a line can be represented in a 2D space using the following formula:\n\n![line-formula](https://cloud.githubusercontent.com/assets/7648874/21790671/1609c050-d6c5-11e6-8bd7-16cc306f5eea.png)\n\n![circle-line-illustration](https://cloud.githubusercontent.com/assets/7648874/21790810/1a052086-d6c6-11e6-9c5c-24298fedb043.png)\n\n> `n` represents the intersection value with the `y` axis.\n> See reference: http://mathworld.wolfram.com/Circle-LineIntersection.html.\n\nwe can find the intersection between a circle and line by solving the systems formed by the equations of both. We also want the line-circle algorithm to be available for any `Line` instance, therefore we gonna add the following delegate on the `Line` prototype:\n\n[{]: <helper> (diffStep 5.8)\n\n#### [Step 5.8: Delegate circle intersection methods](https://github.com/DAB0mB/radial-snake/commit/19828bf)\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;geometry&#x2F;line.js\n```diff\n@@ -44,6 +44,8 @@\n â”Š44â”Š44â”Š  getIntersection(shape) {\n â”Š45â”Š45â”Š    if (shape instanceof Engine.Geometry.Line)\n â”Š46â”Š46â”Š      return this.getLineIntersection(shape);\n+â”Š  â”Š47â”Š    if (shape instanceof Engine.Geometry.Circle)\n+â”Š  â”Š48â”Š      return this.getCircleIntersection(shape);\n â”Š47â”Š49â”Š  }\n â”Š48â”Š50â”Š\n â”Š49â”Š51â”Š  // line - line intersection method\n```\n```diff\n@@ -62,4 +64,9 @@\n â”Š62â”Š64â”Š      return { x, y };\n â”Š63â”Š65â”Š    }\n â”Š64â”Š66â”Š  }\n+â”Š  â”Š67â”Š\n+â”Š  â”Š68â”Š  // line - circle intersection method\n+â”Š  â”Š69â”Š  getCircleIntersection(circle) {\n+â”Š  â”Š70â”Š    return circle.getLineIntersection(this);\n+â”Š  â”Š71â”Š  }\n â”Š65â”Š72â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nThen again a newly created geometry shape class should be tested against different scenarios:\n\n[{]: <helper> (diffStep 5.9)\n\n#### [Step 5.9: Create &#x27;Circle&#x27; class tests](https://github.com/DAB0mB/radial-snake/commit/1d98a6e)\n\n##### Added resources&#x2F;scripts&#x2F;specs&#x2F;engine&#x2F;geometry&#x2F;circle.js\n```diff\n@@ -0,0 +1,144 @@\n+â”Š   â”Š  1â”Šdescribe(\"Engine.Geometry.Circle class\", function() {\n+â”Š   â”Š  2â”Š  beforeEach(function() {\n+â”Š   â”Š  3â”Š    this.circle = new Engine.Geometry.Circle(1, 1, 5, 0, 1.5 * Math.PI);\n+â”Š   â”Š  4â”Š  });\n+â”Š   â”Š  5â”Š\n+â”Š   â”Š  6â”Š  describe(\"getX method\", function() {\n+â”Š   â”Š  7â”Š    describe(\"given inranged rad\", function() {\n+â”Š   â”Š  8â”Š      it(\"returns x\", function() {\n+â”Š   â”Š  9â”Š        expect(this.circle.getX(0 * Math.PI)).toBeCloseTo(6);\n+â”Š   â”Š 10â”Š        expect(this.circle.getX(0.5 * Math.PI)).toBeCloseTo(1);\n+â”Š   â”Š 11â”Š        expect(this.circle.getX(1 * Math.PI)).toBeCloseTo(-4);\n+â”Š   â”Š 12â”Š        expect(this.circle.getX(1.5 * Math.PI)).toBeCloseTo(1);\n+â”Š   â”Š 13â”Š      });\n+â”Š   â”Š 14â”Š    });\n+â”Š   â”Š 15â”Š\n+â”Š   â”Š 16â”Š    describe(\"given outranged rad\", function() {\n+â”Š   â”Š 17â”Š      it(\"returns nothing\", function() {\n+â”Š   â”Š 18â”Š        expect(this.circle.getX(2 * Math.PI)).toBeUndefined();\n+â”Š   â”Š 19â”Š      });\n+â”Š   â”Š 20â”Š    });\n+â”Š   â”Š 21â”Š  });\n+â”Š   â”Š 22â”Š\n+â”Š   â”Š 23â”Š  describe(\"getY method\", function() {\n+â”Š   â”Š 24â”Š    describe(\"given inranged rad\", function() {\n+â”Š   â”Š 25â”Š      it(\"returns y\", function() {\n+â”Š   â”Š 26â”Š        expect(this.circle.getY(0 * Math.PI)).toBeCloseTo(1);\n+â”Š   â”Š 27â”Š        expect(this.circle.getY(0.5 * Math.PI)).toBeCloseTo(6);\n+â”Š   â”Š 28â”Š        expect(this.circle.getY(1 * Math.PI)).toBeCloseTo(1);\n+â”Š   â”Š 29â”Š        expect(this.circle.getY(1.5 * Math.PI)).toBeCloseTo(-4);\n+â”Š   â”Š 30â”Š      });\n+â”Š   â”Š 31â”Š    });\n+â”Š   â”Š 32â”Š\n+â”Š   â”Š 33â”Š    describe(\"given outranged rad\", function() {\n+â”Š   â”Š 34â”Š      it(\"returns nothing\", function() {\n+â”Š   â”Š 35â”Š        expect(this.circle.getY(2 * Math.PI)).toBeUndefined();\n+â”Š   â”Š 36â”Š      });\n+â”Š   â”Š 37â”Š    });\n+â”Š   â”Š 38â”Š  });\n+â”Š   â”Š 39â”Š\n+â”Š   â”Š 40â”Š  describe(\"getRad method\", function() {\n+â”Š   â”Š 41â”Š    describe(\"given inranged point\", function() {\n+â”Š   â”Š 42â”Š      it(\"returns rad\", function() {\n+â”Š   â”Š 43â”Š        let x = -3.0450849718747346;\n+â”Š   â”Š 44â”Š        let y = 3.9389262614623686;\n+â”Š   â”Š 45â”Š        expect(this.circle.getRad(x, y)).toBeCloseTo(0.8 * Math.PI);\n+â”Š   â”Š 46â”Š      });\n+â”Š   â”Š 47â”Š    });\n+â”Š   â”Š 48â”Š\n+â”Š   â”Š 49â”Š    describe(\"given outranged point\", function() {\n+â”Š   â”Š 50â”Š      it(\"returns nothing\", function() {\n+â”Š   â”Š 51â”Š        let x = 5.045084971874736;\n+â”Š   â”Š 52â”Š        let y = -1.9389262614623664;\n+â”Š   â”Š 53â”Š        expect(this.circle.getRad(x, y)).toBeUndefined();\n+â”Š   â”Š 54â”Š      });\n+â”Š   â”Š 55â”Š    });\n+â”Š   â”Š 56â”Š  });\n+â”Š   â”Š 57â”Š\n+â”Š   â”Š 58â”Š  describe(\"getCircleIntersection method\", function() {\n+â”Š   â”Š 59â”Š    describe(\"given circle with 2 intersection points\", function() {\n+â”Š   â”Š 60â”Š      it(\"returns array with intersection points\", function() {\n+â”Š   â”Š 61â”Š        let circle = new Engine.Geometry.Circle(-5, 1, 5, 0, 2 * Math.PI);\n+â”Š   â”Š 62â”Š\n+â”Š   â”Š 63â”Š        expect(this.circle.getCircleIntersection(circle)).toEqual([\n+â”Š   â”Š 64â”Š          { x: -2, y: -3 },\n+â”Š   â”Š 65â”Š          { x: -2, y: 5 }\n+â”Š   â”Š 66â”Š        ]);\n+â”Š   â”Š 67â”Š      });\n+â”Š   â”Š 68â”Š    });\n+â”Š   â”Š 69â”Š\n+â”Š   â”Š 70â”Š    describe(\"given circle with 1 intersection points\", function() {\n+â”Š   â”Š 71â”Š      it(\"returns array with intersection point\", function() {\n+â”Š   â”Š 72â”Š        let circle = new Engine.Geometry.Circle(-5, 1, 5, 0, 1 * Math.PI);\n+â”Š   â”Š 73â”Š\n+â”Š   â”Š 74â”Š        expect(this.circle.getCircleIntersection(circle)).toEqual([\n+â”Š   â”Š 75â”Š          { x: -2, y: 5 }\n+â”Š   â”Š 76â”Š        ]);\n+â”Š   â”Š 77â”Š      });\n+â”Š   â”Š 78â”Š    });\n+â”Š   â”Š 79â”Š\n+â”Š   â”Š 80â”Š    describe(\"given kissing circle\", function() {\n+â”Š   â”Š 81â”Š      it(\"returns array with intersection point\", function() {\n+â”Š   â”Š 82â”Š        let circle = new Engine.Geometry.Circle(-9, 1, 5, 0, 2 * Math.PI);\n+â”Š   â”Š 83â”Š\n+â”Š   â”Š 84â”Š        expect(this.circle.getCircleIntersection(circle)).toEqual([\n+â”Š   â”Š 85â”Š          { x: -4, y: 1 }\n+â”Š   â”Š 86â”Š        ]);\n+â”Š   â”Š 87â”Š      });\n+â”Š   â”Š 88â”Š    });\n+â”Š   â”Š 89â”Š\n+â”Š   â”Š 90â”Š    describe(\"given outer circle\", function() {\n+â”Š   â”Š 91â”Š      it(\"returns nothing\", function() {\n+â”Š   â”Š 92â”Š        let circle = new Engine.Geometry.Circle(10, 10, 2, 0, 2 * Math.PI);\n+â”Š   â”Š 93â”Š        expect(this.circle.getCircleIntersection(circle)).toBeUndefined();\n+â”Š   â”Š 94â”Š      });\n+â”Š   â”Š 95â”Š    });\n+â”Š   â”Š 96â”Š\n+â”Š   â”Š 97â”Š    describe(\"given inner circle\", function() {\n+â”Š   â”Š 98â”Š      it(\"nothing\", function() {\n+â”Š   â”Š 99â”Š        let circle = new Engine.Geometry.Circle(1, 1, 2, 0, 2 * Math.PI);\n+â”Š   â”Š100â”Š        expect(this.circle.getCircleIntersection(circle)).toBeUndefined();\n+â”Š   â”Š101â”Š      });\n+â”Š   â”Š102â”Š    });\n+â”Š   â”Š103â”Š  });\n+â”Š   â”Š104â”Š\n+â”Š   â”Š105â”Š  describe(\"getLineIntersection method\", function() {\n+â”Š   â”Š106â”Š    describe(\"given line with 2 intersection points\", function() {\n+â”Š   â”Š107â”Š      it(\"returns array with intersection points\", function() {\n+â”Š   â”Š108â”Š        let line = new Engine.Geometry.Line(-10, 1, 10, 1);\n+â”Š   â”Š109â”Š\n+â”Š   â”Š110â”Š        expect(this.circle.getLineIntersection(line)).toEqual([\n+â”Š   â”Š111â”Š          { x: 6, y: 1 },\n+â”Š   â”Š112â”Š          { x: -4, y: 1 }\n+â”Š   â”Š113â”Š        ]);\n+â”Š   â”Š114â”Š      });\n+â”Š   â”Š115â”Š    });\n+â”Š   â”Š116â”Š\n+â”Š   â”Š117â”Š    describe(\"given line with 1 intersection point\", function() {\n+â”Š   â”Š118â”Š      it(\"returns array with intersection point\", function() {\n+â”Š   â”Š119â”Š        let line = new Engine.Geometry.Line(-10, 1, 1, 1);\n+â”Š   â”Š120â”Š\n+â”Š   â”Š121â”Š        expect(this.circle.getLineIntersection(line)).toEqual([\n+â”Š   â”Š122â”Š          { x: -4, y: 1 }\n+â”Š   â”Š123â”Š        ]);\n+â”Š   â”Š124â”Š      });\n+â”Š   â”Š125â”Š    });\n+â”Š   â”Š126â”Š\n+â”Š   â”Š127â”Š    describe(\"given kissing line\", function() {\n+â”Š   â”Š128â”Š      it(\"returns array with intersection point\", function() {\n+â”Š   â”Š129â”Š        let line = new Engine.Geometry.Line(-10, 6, 10, 6);\n+â”Š   â”Š130â”Š\n+â”Š   â”Š131â”Š        expect(this.circle.getLineIntersection(line)).toEqual([\n+â”Š   â”Š132â”Š          { x: 1, y: 6 }\n+â”Š   â”Š133â”Š        ]);\n+â”Š   â”Š134â”Š      });\n+â”Š   â”Š135â”Š    });\n+â”Š   â”Š136â”Š\n+â”Š   â”Š137â”Š    describe(\"given outranged line\", function() {\n+â”Š   â”Š138â”Š      it(\"returns nothing\", function() {\n+â”Š   â”Š139â”Š        let line = new Engine.Geometry.Line(-10, 10, 10, 10);\n+â”Š   â”Š140â”Š        expect(this.circle.getLineIntersection(line)).toBeUndefined();\n+â”Š   â”Š141â”Š      });\n+â”Š   â”Š142â”Š    });\n+â”Š   â”Š143â”Š  });\n+â”Š   â”Š144â”Š});ðŸš«â†µ\n```\n\n##### Changed views&#x2F;spec_runner.html\n```diff\n@@ -19,9 +19,11 @@\n â”Š19â”Š19â”Š    <script type=\"text/javascript\" src=\"scripts/utils.js\"></script>\n â”Š20â”Š20â”Š    <script type=\"text/javascript\" src=\"scripts/namespaces.js\"></script>\n â”Š21â”Š21â”Š    <script type=\"text/javascript\" src=\"scripts/engine/geometry/line.js\"></script>\n+â”Š  â”Š22â”Š    <script type=\"text/javascript\" src=\"scripts/engine/geometry/circle.js\"></script>\n â”Š22â”Š23â”Š\n â”Š23â”Š24â”Š    <!-- Specs -->\n â”Š24â”Š25â”Š    <script type=\"text/javascript\" src=\"scripts/specs/engine/geometry/line.js\"></script>\n+â”Š  â”Š26â”Š    <script type=\"text/javascript\" src=\"scripts/specs/engine/geometry/circle.js\"></script>\n â”Š25â”Š27â”Š  </head>\n â”Š26â”Š28â”Š\n â”Š27â”Š29â”Š  <body>\n```\n\n[}]: #\n\nOur final shape in the geometry module would be a polygon. Why a polygon? Since I'm planning to make the snake's movement circular, which means that once the snake hits a random boundary, he will reappear from the other side of the canvas. The collision detection between the snake and the canvas would be done using a polygon - which is simply made out of 4 lines:\n\n[{]: <helper> (diffStep 5.1)\n\n#### [Step 5.1: Create utilities module](https://github.com/DAB0mB/radial-snake/commit/58ae99a)\n\n##### Added resources&#x2F;scripts&#x2F;utils.js\n```diff\n@@ -0,0 +1,68 @@\n+â”Š  â”Š 1â”Š// A wrapper function for our utilities which will enable chaining\n+â”Š  â”Š 2â”Š// e.g. Utils().mod().trim().isBetween()...\n+â”Š  â”Š 3â”ŠUtils = function Utils(context) {\n+â”Š  â”Š 4â”Š  const chain = {};\n+â”Š  â”Š 5â”Š\n+â”Š  â”Š 6â”Š  Object.keys(Utils).forEach((utilName) => {\n+â”Š  â”Š 7â”Š    chain[utilName] = (...args) => {\n+â”Š  â”Š 8â”Š      const result = Utils[utilName](context, ...args);\n+â”Š  â”Š 9â”Š      return Utils(result);\n+â”Š  â”Š10â”Š    };\n+â”Š  â”Š11â”Š  });\n+â”Š  â”Š12â”Š\n+â”Š  â”Š13â”Š  // Returns the result of the chaining\n+â”Š  â”Š14â”Š  chain.value = () => context;\n+â”Š  â”Š15â”Š\n+â”Š  â”Š16â”Š  return chain;\n+â”Š  â”Š17â”Š};\n+â”Š  â”Š18â”Š\n+â”Š  â”Š19â”Š// Fixed modulo method which can calculate modulo of negative numbers properly\n+â”Š  â”Š20â”Š// e.g. (-803).mod(800) returns 797\n+â”Š  â”Š21â”ŠUtils.mod = function (context, num) {\n+â”Š  â”Š22â”Š  return ((context % num) + num) % num;\n+â”Š  â”Š23â”Š};\n+â”Š  â”Š24â”Š\n+â”Š  â”Š25â”Š// Trims number and leaves the number of decimals specified.\n+â”Š  â”Š26â”Š// The \"mode\" argument specifies which math function should be invoked\n+â”Š  â”Š27â”Š// right after the number has been trimmed.\n+â”Š  â”Š28â”Š// e.g. 12.12345.trim(3, \"ceil\") returns 12.124\n+â”Š  â”Š29â”ŠUtils.trim = function (context, decimals, mode = \"round\") {\n+â”Š  â”Š30â”Š  return Math[mode](context * Math.pow(10, decimals)) / Math.pow(10, decimals);\n+â”Š  â”Š31â”Š};\n+â”Š  â”Š32â”Š\n+â”Š  â”Š33â”Š// Tells if number is in specified range based on given precision.\n+â”Š  â”Š34â”Š// See the \"compare\" method for more information about precision\n+â”Š  â”Š35â”ŠUtils.isBetween = function (context, num1, num2, precision) {\n+â”Š  â”Š36â”Š  return Utils.compare(context, Math.min(num1, num2), \">=\", precision) &&\n+â”Š  â”Š37â”Š         Utils.compare(context, Math.max(num1, num2), \"<=\", precision);\n+â”Š  â”Š38â”Š};\n+â”Š  â”Š39â”Š\n+â”Š  â”Š40â”Š// Initiates comparison operator between context number and a given number, only here\n+â”Š  â”Š41â”Š// a precision can be specified\n+â”Š  â”Š42â”ŠUtils.compare = function (context, num, method, precision = method) {\n+â”Š  â”Š43â”Š  switch (precision) {\n+â”Š  â”Š44â”Š    // Fixed precision, \"almost equal\" with a deviation of Îµ\n+â”Š  â”Š45â”Š    case \"f\":\n+â”Š  â”Š46â”Š      switch (method) {\n+â”Š  â”Š47â”Š        case \"<\": case \"<=\": return context <= num + Number.EPSILON;\n+â”Š  â”Š48â”Š        case \">\": case \">=\": return context >= num - Number.EPSILON;\n+â”Š  â”Š49â”Š        default: return Math.abs(context - num) <= Number.EPSILON;\n+â”Š  â”Š50â”Š      }\n+â”Š  â”Š51â”Š    // Pixel precision, round comparison\n+â”Š  â”Š52â”Š    case \"px\":\n+â”Š  â”Š53â”Š      switch (method) {\n+â”Š  â”Š54â”Š        case \"<\": case \"<=\": return Math.round(context) <= Math.round(num);\n+â”Š  â”Š55â”Š        case \">\": case \">=\": return Math.round(context) >= Math.round(num);\n+â”Š  â”Š56â”Š        default: return Math.round(context) == Math.round(num);\n+â”Š  â”Š57â”Š      }\n+â”Š  â”Š58â”Š    // Exact precision\n+â”Š  â”Š59â”Š    default:\n+â”Š  â”Š60â”Š      switch (method) {\n+â”Š  â”Š61â”Š        case \"<\": return context < num;\n+â”Š  â”Š62â”Š        case \"<=\": return context <= num;\n+â”Š  â”Š63â”Š        case \">\": return context > num;\n+â”Š  â”Š64â”Š        case \">=\": return context >= num;\n+â”Š  â”Š65â”Š        default: return context === num;\n+â”Š  â”Š66â”Š      }\n+â”Š  â”Š67â”Š  }\n+â”Š  â”Š68â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -8,6 +8,7 @@\n â”Š 8â”Š 8â”Š    <script type=\"text/javascript\" src=\"/libs/underscore.js\"></script>\n â”Š 9â”Š 9â”Š\n â”Š10â”Š10â”Š    <!-- Scripts -->\n+â”Š  â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/utils.js\"></script>\n â”Š11â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n â”Š12â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/restorable.js\"></script>\n â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/font.js\"></script>\n```\n\n[}]: #\n\nAgain we will delegate the newly created intersection methods in the `Line` class and `Circle` class:\n\n[{]: <helper> (diffStep 5.11)\n\n#### [Step 5.11: Delegate polygon intersection methods](https://github.com/DAB0mB/radial-snake/commit/d42a5d9)\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;geometry&#x2F;circle.js\n```diff\n@@ -83,6 +83,8 @@\n â”Š83â”Š83â”Š      return this.getLineIntersection(shape);\n â”Š84â”Š84â”Š    if (shape instanceof Engine.Geometry.Circle)\n â”Š85â”Š85â”Š      return this.getCircleIntersection(shape);\n+â”Š  â”Š86â”Š    if (shape instanceof Engine.Geometry.Polygon)\n+â”Š  â”Š87â”Š      return this.getPolygonIntersection(shape);\n â”Š86â”Š88â”Š  }\n â”Š87â”Š89â”Š\n â”Š88â”Š90â”Š  // circle - circle intersection method\n```\n```diff\n@@ -164,4 +166,9 @@\n â”Š164â”Š166â”Š\n â”Š165â”Š167â”Š    if (interPoints.length > 0) return interPoints;\n â”Š166â”Š168â”Š  }\n+â”Š   â”Š169â”Š\n+â”Š   â”Š170â”Š  // circle - polygon intersection method\n+â”Š   â”Š171â”Š  getPolygonIntersection(polygon) {\n+â”Š   â”Š172â”Š    return polygon.getCircleIntersection(this);\n+â”Š   â”Š173â”Š  }\n â”Š167â”Š174â”Š};ðŸš«â†µ\n```\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;geometry&#x2F;line.js\n```diff\n@@ -46,6 +46,8 @@\n â”Š46â”Š46â”Š      return this.getLineIntersection(shape);\n â”Š47â”Š47â”Š    if (shape instanceof Engine.Geometry.Circle)\n â”Š48â”Š48â”Š      return this.getCircleIntersection(shape);\n+â”Š  â”Š49â”Š    if (shape instanceof Engine.Geometry.Polygon)\n+â”Š  â”Š50â”Š      return this.getPolygonIntersection(shape);\n â”Š49â”Š51â”Š  }\n â”Š50â”Š52â”Š\n â”Š51â”Š53â”Š  // line - line intersection method\n```\n```diff\n@@ -69,4 +71,9 @@\n â”Š69â”Š71â”Š  getCircleIntersection(circle) {\n â”Š70â”Š72â”Š    return circle.getLineIntersection(this);\n â”Š71â”Š73â”Š  }\n+â”Š  â”Š74â”Š\n+â”Š  â”Š75â”Š  // line - polygon intersection method\n+â”Š  â”Š76â”Š  getPolygonIntersection(polygon) {\n+â”Š  â”Š77â”Š    return polygon.getLineIntersection(this);\n+â”Š  â”Š78â”Š  }\n â”Š72â”Š79â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nNow we will create a some tests to make sure our newly created polygon works properly:\n\n[{]: <helper> (diffStep 5.12)\n\n#### [Step 5.12: Create &#x27;Polygon&#x27; class tests](https://github.com/DAB0mB/radial-snake/commit/f3f890b)\n\n##### Added resources&#x2F;scripts&#x2F;specs&#x2F;engine&#x2F;geometry&#x2F;polygon.js\n```diff\n@@ -0,0 +1,96 @@\n+â”Š  â”Š 1â”Šdescribe(\"Engine.Geometry.Polygon class\", function() {\n+â”Š  â”Š 2â”Š  beforeEach(function() {\n+â”Š  â”Š 3â”Š    this.polygon = new Engine.Geometry.Polygon(\n+â”Š  â”Š 4â”Š      [0, 0, 5, 0],\n+â”Š  â”Š 5â”Š      [5, 0, 5, 5],\n+â”Š  â”Š 6â”Š      [5, 5, 0, 5],\n+â”Š  â”Š 7â”Š      [0, 5, 0, 0]\n+â”Š  â”Š 8â”Š    );\n+â”Š  â”Š 9â”Š  });\n+â”Š  â”Š10â”Š\n+â”Š  â”Š11â”Š  describe(\"hasPoint method\", function() {\n+â”Š  â”Š12â”Š    describe(\"given contained point\", function() {\n+â”Š  â”Š13â”Š      it(\"returns true\", function() {\n+â”Š  â”Š14â”Š        let x = 5;\n+â”Š  â”Š15â”Š        let y = 3;\n+â”Š  â”Š16â”Š        expect(this.polygon.hasPoint(x, y)).toBeTruthy();\n+â”Š  â”Š17â”Š      });\n+â”Š  â”Š18â”Š    });\n+â”Š  â”Š19â”Š\n+â”Š  â”Š20â”Š    describe(\"given outranged point\", function() {\n+â”Š  â”Š21â”Š      it(\"returns false\", function() {\n+â”Š  â”Š22â”Š        let x = 10;\n+â”Š  â”Š23â”Š        let y = 10;\n+â”Š  â”Š24â”Š        expect(this.polygon.hasPoint(x, y)).toBeFalsy();\n+â”Š  â”Š25â”Š      });\n+â”Š  â”Š26â”Š    });\n+â”Š  â”Š27â”Š  });\n+â”Š  â”Š28â”Š\n+â”Š  â”Š29â”Š  describe(\"getLineIntersection method\", function() {\n+â”Š  â”Š30â”Š    describe(\"given intersecting line\", function() {\n+â”Š  â”Š31â”Š      it(\"returns intersection point\", function() {\n+â”Š  â”Š32â”Š        let line = new Engine.Geometry.Line(0, 1, 5, 4);\n+â”Š  â”Š33â”Š\n+â”Š  â”Š34â”Š        expect(this.polygon.getLineIntersection(line)).toEqual([\n+â”Š  â”Š35â”Š          { x: 5, y: 4 },\n+â”Š  â”Š36â”Š          { x: 0, y: 1 }\n+â”Š  â”Š37â”Š        ]);\n+â”Š  â”Š38â”Š      });\n+â”Š  â”Š39â”Š    });\n+â”Š  â”Š40â”Š\n+â”Š  â”Š41â”Š    describe(\"given outranged line\", function() {\n+â”Š  â”Š42â”Š      it(\"returns nothing\", function() {\n+â”Š  â”Š43â”Š        let line = new Engine.Geometry.Line(10, 11, 15, 14);\n+â”Š  â”Š44â”Š\n+â”Š  â”Š45â”Š        expect(this.polygon.getLineIntersection(line)).toBeUndefined();\n+â”Š  â”Š46â”Š      });\n+â”Š  â”Š47â”Š    });\n+â”Š  â”Š48â”Š  });\n+â”Š  â”Š49â”Š\n+â”Š  â”Š50â”Š  describe(\"getCircleIntersection method\", function() {\n+â”Š  â”Š51â”Š    describe(\"given circle with 2 intersection points\", function() {\n+â”Š  â”Š52â”Š      it(\"returns array with intersection points\", function() {\n+â”Š  â”Š53â”Š        let circle = new Engine.Geometry.Circle(0, 0, 2, 0, 2 * Math.PI);\n+â”Š  â”Š54â”Š\n+â”Š  â”Š55â”Š        expect(this.polygon.getCircleIntersection(circle)).toEqual([\n+â”Š  â”Š56â”Š          { x: 2, y: 0 },\n+â”Š  â”Š57â”Š          { x: 0, y: 2 }\n+â”Š  â”Š58â”Š        ]);\n+â”Š  â”Š59â”Š      });\n+â”Š  â”Š60â”Š    });\n+â”Š  â”Š61â”Š\n+â”Š  â”Š62â”Š    describe(\"given circle with 1 intersection points\", function() {\n+â”Š  â”Š63â”Š      it(\"returns array with intersection point\", function() {\n+â”Š  â”Š64â”Š        let circle = new Engine.Geometry.Circle(0, 0, 2, 0, 0.25 * Math.PI);\n+â”Š  â”Š65â”Š\n+â”Š  â”Š66â”Š        expect(this.polygon.getCircleIntersection(circle)).toEqual([\n+â”Š  â”Š67â”Š          { x: 2, y: 0 }\n+â”Š  â”Š68â”Š        ]);\n+â”Š  â”Š69â”Š      });\n+â”Š  â”Š70â”Š    });\n+â”Š  â”Š71â”Š\n+â”Š  â”Š72â”Š    describe(\"given kissing circle\", function() {\n+â”Š  â”Š73â”Š      it(\"returns array with intersection point\", function() {\n+â”Š  â”Š74â”Š        let circle = new Engine.Geometry.Circle(-3, 3, 3, 0, 2 * Math.PI);\n+â”Š  â”Š75â”Š\n+â”Š  â”Š76â”Š        expect(this.polygon.getCircleIntersection(circle)).toEqual([\n+â”Š  â”Š77â”Š          { x: 0, y: 3 }\n+â”Š  â”Š78â”Š        ]);\n+â”Š  â”Š79â”Š      });\n+â”Š  â”Š80â”Š    });\n+â”Š  â”Š81â”Š\n+â”Š  â”Š82â”Š    describe(\"given outer circle\", function() {\n+â”Š  â”Š83â”Š      it(\"returns nothing\", function() {\n+â”Š  â”Š84â”Š        let circle = new Engine.Geometry.Circle(10, 10, 2, 0, 2 * Math.PI);\n+â”Š  â”Š85â”Š        expect(this.polygon.getCircleIntersection(circle)).toBeUndefined();\n+â”Š  â”Š86â”Š      });\n+â”Š  â”Š87â”Š    });\n+â”Š  â”Š88â”Š\n+â”Š  â”Š89â”Š    describe(\"given inner circle\", function() {\n+â”Š  â”Š90â”Š      it(\"nothing\", function() {\n+â”Š  â”Š91â”Š        let circle = new Engine.Geometry.Circle(2.5, 2.5, 2, 0, 2 * Math.PI);\n+â”Š  â”Š92â”Š        expect(this.polygon.getCircleIntersection(circle)).toBeUndefined();\n+â”Š  â”Š93â”Š      });\n+â”Š  â”Š94â”Š    });\n+â”Š  â”Š95â”Š  });\n+â”Š  â”Š96â”Š});ðŸš«â†µ\n```\n\n##### Changed views&#x2F;spec_runner.html\n```diff\n@@ -20,10 +20,12 @@\n â”Š20â”Š20â”Š    <script type=\"text/javascript\" src=\"scripts/namespaces.js\"></script>\n â”Š21â”Š21â”Š    <script type=\"text/javascript\" src=\"scripts/engine/geometry/line.js\"></script>\n â”Š22â”Š22â”Š    <script type=\"text/javascript\" src=\"scripts/engine/geometry/circle.js\"></script>\n+â”Š  â”Š23â”Š    <script type=\"text/javascript\" src=\"scripts/engine/geometry/polygon.js\"></script>\n â”Š23â”Š24â”Š\n â”Š24â”Š25â”Š    <!-- Specs -->\n â”Š25â”Š26â”Š    <script type=\"text/javascript\" src=\"scripts/specs/engine/geometry/line.js\"></script>\n â”Š26â”Š27â”Š    <script type=\"text/javascript\" src=\"scripts/specs/engine/geometry/circle.js\"></script>\n+â”Š  â”Š28â”Š    <script type=\"text/javascript\" src=\"scripts/specs/engine/geometry/polygon.js\"></script>\n â”Š27â”Š29â”Š  </head>\n â”Š28â”Š30â”Š\n â”Š29â”Š31â”Š  <body>\n```\n\n[}]: #\n\nAt last, all the necessary geometry shapes are implemented and ready to use. We will now focus on the snake itself. Since our game can potentially have infinite number of entities, not necessarily just a snake, we will add the a new module under the `Game` namespace called `Entities`:\n\n[{]: <helper> (diffStep 5.13)\n\n#### [Step 5.13: Add &#x27;Entities&#x27; module to &#x27;Game&#x27; namespace](https://github.com/DAB0mB/radial-snake/commit/a0bed8c)\n\n##### Changed resources&#x2F;scripts&#x2F;namespaces.js\n```diff\n@@ -1,4 +1,5 @@\n â”Š1â”Š1â”ŠGame = {\n+â”Š â”Š2â”Š  Entities: {},\n â”Š2â”Š3â”Š  Screens: {}\n â”Š3â”Š4â”Š};\n```\n\n[}]: #\n\nAnd now we can add the `Snake` class:\n\n[{]: <helper> (diffStep 5.14)\n\n#### [Step 5.14: Create &#x27;Snake&#x27; class](https://github.com/DAB0mB/radial-snake/commit/b938ba7)\n\n##### Added resources&#x2F;scripts&#x2F;game&#x2F;entities&#x2F;snake.js\n```diff\n@@ -0,0 +1,234 @@\n+â”Š   â”Š  1â”ŠGame.Entities.Snake = class Snake {\n+â”Š   â”Š  2â”Š  // Represents a snake data-structure which will eventually appear on screen.\n+â”Š   â”Š  3â”Š  // All the properties provided to the constructor are the initial values of\n+â”Š   â”Š  4â”Š  // the snake\n+â”Š   â”Š  5â”Š  constructor(x, y, r, rad, v, color, keyStates, options) {\n+â”Š   â”Š  6â”Š    this.x = x;\n+â”Š   â”Š  7â”Š    this.y = y;\n+â”Š   â”Š  8â”Š    this.r = r;\n+â”Š   â”Š  9â”Š    this.rad = rad;\n+â”Š   â”Š 10â”Š    this.v = v;\n+â”Š   â”Š 11â”Š    this.color = color;\n+â”Š   â”Š 12â”Š    this.keyStates = keyStates;\n+â”Š   â”Š 13â”Š    // A snake is made out of many geometry shapes\n+â”Š   â”Š 14â”Š    this.shapes = [];\n+â”Š   â”Š 15â”Š    // A snake starts with a line\n+â”Š   â”Š 16â”Š    this.currentShape = new Engine.Geometry.Line(x, y, x, y);\n+â”Š   â”Š 17â”Š    this.shapes.push(this.currentShape);\n+â”Š   â”Š 18â”Š    // A score can be provided in case we want to reserve previous scores from\n+â”Š   â”Š 19â”Š    // recent matches\n+â”Š   â”Š 20â”Š    this.score = options.score || 0;\n+â”Š   â”Š 21â”Š\n+â”Š   â”Š 22â”Š    // Custom keys can be specified\n+â”Š   â”Š 23â”Š    if (options.keys && options.keys) {\n+â”Š   â”Š 24â”Š      this.leftKey = options.keys.left;\n+â”Š   â”Š 25â”Š      this.rightKey = options.keys.right;\n+â”Š   â”Š 26â”Š    }\n+â”Š   â”Š 27â”Š    // Left and right arrow keys will be used by default\n+â”Š   â”Š 28â”Š    else {\n+â”Š   â”Š 29â”Š      this.leftKey = 37; // Left arrow\n+â”Š   â”Š 30â”Š      this.rightKey = 39; // Right arrow\n+â”Š   â”Š 31â”Š    }\n+â”Š   â”Š 32â”Š  }\n+â”Š   â”Š 33â”Š\n+â”Š   â”Š 34â”Š  draw(context) {\n+â”Š   â”Š 35â”Š    // Draw all shapes in the shapes array\n+â”Š   â”Š 36â”Š    this.shapes.forEach(shape => {\n+â”Š   â”Š 37â”Š      context.save();\n+â”Š   â”Š 38â”Š      context.strokeStyle = this.color;\n+â”Š   â”Š 39â”Š      context.lineWidth = 3;\n+â”Š   â”Š 40â”Š      context.beginPath();\n+â”Š   â”Š 41â”Š\n+â”Š   â”Š 42â”Š      // Each shape has its own unique drawing method\n+â”Š   â”Š 43â”Š      shape.draw(context);\n+â”Š   â”Š 44â”Š\n+â”Š   â”Š 45â”Š      context.stroke();\n+â”Š   â”Š 46â”Š      context.restore();\n+â”Š   â”Š 47â”Š    });\n+â”Š   â”Š 48â”Š  }\n+â”Š   â”Š 49â”Š\n+â”Š   â”Š 50â”Š  update(span, width, height) {\n+â”Š   â”Š 51â”Š    // Progress made based on elapsed time and velocity\n+â”Š   â”Š 52â”Š    let step = (this.v * span) / 1000;\n+â”Š   â”Š 53â”Š\n+â”Š   â”Š 54â”Š    this.updateShapes(step, width, height);\n+â”Š   â”Š 55â”Š    this.cycleThrough(step, width, height);\n+â”Š   â”Š 56â”Š  }\n+â”Š   â”Š 57â”Š\n+â”Š   â”Š 58â”Š  // Updates shapes array based on progress made\n+â”Š   â”Š 59â”Š  updateShapes(step, width, height, options = {}) {\n+â”Š   â”Š 60â”Š    this.updateCurrentShape(step, options);\n+â”Š   â”Š 61â”Š    this.updateDirection(step, options);\n+â”Š   â”Š 62â”Š  }\n+â”Š   â”Š 63â”Š\n+â”Š   â”Š 64â”Š  // Updates current shape\n+â”Š   â”Š 65â”Š  updateCurrentShape(step, options) {\n+â”Š   â”Š 66â”Š    if (this.currentShape instanceof Engine.Geometry.Line)\n+â”Š   â”Š 67â”Š      return this.updateCurrentLine(options);\n+â”Š   â”Š 68â”Š    if (this.currentShape instanceof Engine.Geometry.Circle)\n+â”Š   â”Š 69â”Š      return this.updateCurrentCircle(options);\n+â”Š   â”Š 70â”Š  }\n+â”Š   â”Š 71â”Š\n+â”Š   â”Š 72â”Š  // Updates current shape in case it is a line\n+â”Š   â”Š 73â”Š  updateCurrentLine(options) {\n+â”Š   â”Š 74â”Š    let lastX = options.lastX || this.x;\n+â”Š   â”Š 75â”Š    let lastY = options.lastY || this.y;\n+â”Š   â”Š 76â”Š    this.x = options.x || this.currentShape.x2;\n+â”Š   â”Š 77â”Š    this.y = options.y || this.currentShape.y2;\n+â”Š   â”Š 78â”Š    this.lastBit = new Engine.Geometry.Line(lastX, lastY, this.x, this.y);\n+â”Š   â”Š 79â”Š  }\n+â”Š   â”Š 80â”Š\n+â”Š   â”Š 81â”Š  // Updates current shape in case it is a circle\n+â”Š   â”Š 82â”Š  updateCurrentCircle(options) {\n+â”Š   â”Š 83â”Š    let lastX = options.lastX || this.currentShape.x;\n+â”Š   â”Š 84â”Š    let lastY = options.lastY || this.currentShape.y;\n+â”Š   â”Š 85â”Š    let lastR = options.lastR || this.currentShape.r;\n+â”Š   â”Š 86â”Š\n+â”Š   â”Š 87â”Š    // Update logic for left rotation\n+â”Š   â”Š 88â”Š    if (this.direction == \"left\") {\n+â”Š   â”Š 89â”Š      let lastRad = this.rad + (0.5 * Math.PI);\n+â”Š   â”Š 90â”Š      let currentShapePoint = this.currentShape.getPoint(this.currentShape.rad1);\n+â”Š   â”Š 91â”Š      this.x = options.x || currentShapePoint.x;\n+â”Š   â”Š 92â”Š      this.y = options.y || currentShapePoint.y;\n+â”Š   â”Š 93â”Š      this.rad = this.currentShape.rad1 - (0.5 * Math.PI);\n+â”Š   â”Š 94â”Š      this.lastBit = new Engine.Geometry.Circle(lastX, lastY, lastR, this.currentShape.rad1, lastRad);\n+â”Š   â”Š 95â”Š    }\n+â”Š   â”Š 96â”Š    // Update logic for right rotation\n+â”Š   â”Š 97â”Š    else {\n+â”Š   â”Š 98â”Š      let lastRad = this.rad - (0.5 * Math.PI);\n+â”Š   â”Š 99â”Š      let currentShapePoint = this.currentShape.getPoint(this.currentShape.rad2);\n+â”Š   â”Š100â”Š      this.x = options.x || currentShapePoint.x;\n+â”Š   â”Š101â”Š      this.y = options.y || currentShapePoint.y;\n+â”Š   â”Š102â”Š      this.rad = this.currentShape.rad2 + (0.5 * Math.PI);\n+â”Š   â”Š103â”Š      this.lastBit = new Engine.Geometry.Circle(lastX, lastY, lastR, lastRad, this.currentShape.rad2);\n+â”Š   â”Š104â”Š    }\n+â”Š   â”Š105â”Š  }\n+â”Š   â”Š106â”Š\n+â”Š   â”Š107â”Š  updateDirection(step, options) {\n+â”Š   â”Š108â”Š    // Update the direction based on pressed key\n+â”Š   â”Š109â”Š    if (this.keyStates.get(this.leftKey))\n+â”Š   â”Š110â”Š      var direction = \"left\";\n+â”Š   â”Š111â”Š    else if (this.keyStates.get(this.rightKey))\n+â”Š   â”Š112â”Š      var direction = \"right\";\n+â”Š   â”Š113â”Š\n+â”Š   â”Š114â”Š    this.changeDirection(step, direction, options);\n+â”Š   â”Š115â”Š    this.continueDirection(step, direction, options);\n+â”Š   â”Š116â”Š  }\n+â”Š   â”Š117â”Š\n+â”Š   â”Š118â”Š  // Change the recent shape type according to the given direction\n+â”Š   â”Š119â”Š  changeDirection(step, direction, options) {\n+â”Š   â”Š120â”Š    // If there is no change in direction, abort, unless we force it\n+â”Š   â”Š121â”Š    if (direction == this.direction && !options.force) return;\n+â”Š   â”Š122â”Š\n+â”Š   â”Š123â”Š    this.direction = direction;\n+â”Š   â”Š124â”Š\n+â”Š   â”Š125â”Š    // This will push a new shape with new properties, based on the direction\n+â”Š   â”Š126â”Š    switch (direction) {\n+â”Š   â”Š127â”Š      case \"left\":\n+â”Š   â”Š128â”Š        var angle = this.rad - (0.5 * Math.PI);\n+â”Š   â”Š129â”Š        var rad = this.rad + (0.5 * Math.PI);\n+â”Š   â”Š130â”Š        var x = this.x + (this.r * Math.cos(angle));\n+â”Š   â”Š131â”Š        var y = this.y + (this.r * Math.sin(angle));\n+â”Š   â”Š132â”Š        this.currentShape = new Engine.Geometry.Circle(x, y, this.r, rad, rad);\n+â”Š   â”Š133â”Š        break;\n+â”Š   â”Š134â”Š      case \"right\":\n+â”Š   â”Š135â”Š        angle = this.rad + (0.5 * Math.PI);\n+â”Š   â”Š136â”Š        rad = this.rad - (0.5 * Math.PI);\n+â”Š   â”Š137â”Š        x = this.x + (this.r * Math.cos(angle));\n+â”Š   â”Š138â”Š        y = this.y + (this.r * Math.sin(angle));\n+â”Š   â”Š139â”Š        this.currentShape = new Engine.Geometry.Circle(x, y, this.r, rad, rad);\n+â”Š   â”Š140â”Š        break;\n+â”Š   â”Š141â”Š      default:\n+â”Š   â”Š142â”Š        this.currentShape = new Engine.Geometry.Line(this.x, this.y, this.x, this.y);\n+â”Š   â”Š143â”Š    }\n+â”Š   â”Š144â”Š\n+â”Š   â”Š145â”Š    this.shapes.push(this.currentShape);\n+â”Š   â”Š146â”Š  }\n+â”Š   â”Š147â”Š\n+â”Š   â”Š148â”Š  // Extend the recent shape based on progress made\n+â”Š   â”Š149â”Š  continueDirection(step, direction) {\n+â”Š   â”Š150â”Š    switch (direction) {\n+â”Š   â”Š151â”Š      case \"left\":\n+â”Š   â”Š152â”Š        this.currentShape.rad1 -= step / this.r;\n+â”Š   â”Š153â”Š        break;\n+â”Š   â”Š154â”Š      case \"right\":\n+â”Š   â”Š155â”Š        this.currentShape.rad2 += step / this.r;\n+â”Š   â”Š156â”Š        break;\n+â”Š   â”Š157â”Š      default:\n+â”Š   â”Š158â”Š        this.currentShape.x2 += step * Math.cos(this.rad);\n+â”Š   â”Š159â”Š        this.currentShape.y2 += step * Math.sin(this.rad);\n+â”Š   â”Š160â”Š    }\n+â”Š   â”Š161â”Š  }\n+â”Š   â”Š162â”Š\n+â”Š   â”Š163â”Š  // Handles case where snake is out limits and we need to render it from\n+â”Š   â”Š164â”Š  // the other side of the canvas\n+â”Š   â”Š165â”Š  cycleThrough(step, width, height) {\n+â”Š   â”Š166â”Š    let intersectionPoint = this.getCanvasIntersection(width, height);\n+â”Š   â”Š167â”Š\n+â”Š   â”Š168â”Š    if (!intersectionPoint) return;\n+â”Š   â”Š169â”Š\n+â”Š   â”Š170â”Š    intersectionPoint = intersectionPoint[0];\n+â”Š   â”Š171â”Š\n+â”Š   â”Š172â”Š    // Re-calculate position based on canvas bounds\n+â”Š   â”Š173â”Š    if (intersectionPoint.x % width == 0)\n+â”Š   â”Š174â”Š      this.x = Utils.mod(this.x - width, width);\n+â”Š   â”Š175â”Š    if (intersectionPoint.y % height == 0)\n+â”Š   â”Š176â”Š      this.y = Utils.mod(this.y - height, height);\n+â”Š   â”Š177â”Š\n+â”Š   â”Š178â”Š    // Update shapes again based on custom properties\n+â”Š   â”Š179â”Š    this.updateShapes(step, width, height, {\n+â”Š   â”Š180â”Š      force: true,\n+â”Š   â”Š181â”Š      lastX: this.x,\n+â”Š   â”Š182â”Š      lastY: this.y,\n+â”Š   â”Š183â”Š      x: this.x,\n+â”Š   â”Š184â”Š      y: this.y\n+â”Š   â”Š185â”Š    });\n+â”Š   â”Š186â”Š  }\n+â”Š   â”Š187â”Š\n+â”Š   â”Š188â”Š  // Gets intersection points between last bit and own shapes\n+â”Š   â”Š189â”Š  getSelfIntersection() {\n+â”Š   â”Š190â”Š    if (this.currentShape instanceof Engine.Geometry.Circle &&\n+â”Š   â”Š191â”Š       Math.abs(this.currentShape.rad1 - this.currentShape.rad2) >= 2 * Math.PI) {\n+â”Š   â”Š192â”Š      if (this.direction == \"left\")\n+â”Š   â”Š193â”Š        var rad = this.currentShape.rad1;\n+â”Š   â”Š194â”Š      else\n+â”Š   â”Š195â”Š        var rad = this.currentShape.rad2;\n+â”Š   â”Š196â”Š\n+â”Š   â”Š197â”Š      return this.currentShape.getPoint(rad);\n+â”Š   â”Š198â”Š    }\n+â”Š   â”Š199â”Š\n+â”Š   â”Š200â”Š    let result;\n+â”Š   â”Š201â”Š\n+â”Š   â”Š202â”Š    this.shapes.slice(0, -2).some(shape =>\n+â”Š   â”Š203â”Š      result = this.lastBit.getIntersection(shape)\n+â”Š   â”Š204â”Š    );\n+â”Š   â”Š205â”Š\n+â”Š   â”Š206â”Š    return result;\n+â”Š   â”Š207â”Š  }\n+â”Š   â”Š208â”Š\n+â”Š   â”Š209â”Š  // Returns intersection points between snakes\n+â”Š   â”Š210â”Š  getSnakeIntersection(snake) {\n+â”Š   â”Š211â”Š    let result;\n+â”Š   â”Š212â”Š\n+â”Š   â”Š213â”Š    snake.shapes.some(shape =>\n+â”Š   â”Š214â”Š      // Only last bit is relevant, if we reached this point it means that\n+â”Š   â”Š215â”Š      // previous intersection will definitely fail\n+â”Š   â”Š216â”Š      result = this.lastBit.getIntersection(shape)\n+â”Š   â”Š217â”Š    );\n+â”Š   â”Š218â”Š\n+â”Š   â”Š219â”Š    return result;\n+â”Š   â”Š220â”Š  }\n+â”Š   â”Š221â”Š\n+â”Š   â”Š222â”Š  // Returns intersection points between snake and canvas\n+â”Š   â”Š223â”Š  getCanvasIntersection(width, height) {\n+â”Š   â”Š224â”Š    // Canvas polygon\n+â”Š   â”Š225â”Š    let canvasPolygon = new Engine.Geometry.Polygon(\n+â”Š   â”Š226â”Š      [0, 0, width, 0],\n+â”Š   â”Š227â”Š      [width, 0, width, height],\n+â”Š   â”Š228â”Š      [width, height, 0, height],\n+â”Š   â”Š229â”Š      [0, height, 0, 0]\n+â”Š   â”Š230â”Š    );\n+â”Š   â”Š231â”Š\n+â”Š   â”Š232â”Š    return canvasPolygon.getIntersection(this.lastBit);\n+â”Š   â”Š233â”Š  }\n+â”Š   â”Š234â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -22,6 +22,7 @@\n â”Š22â”Š22â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/screen.js\"></script>\n â”Š23â”Š23â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/assets_loader.js\"></script>\n â”Š24â”Š24â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n+â”Š  â”Š25â”Š    <script type=\"text/javascript\" src=\"/scripts/game/entities/snake.js\"></script>\n â”Š25â”Š26â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/menu/index.js\"></script>\n â”Š26â”Š27â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/splash/index.js\"></script>\n â”Š27â”Š28â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n```\n\n[}]: #\n\nThis class is titled with most complexity out of everything we did so far in this step. You can follow the code accompanied by comments regard it, but I'd also like to explain the key concepts. As said earlier, the `Snake` is simply made out of shapes; In this case - lines and circles.\n\nThe `draw` method just goes through this array and draws whatever shape it's currently looping through. Regardless of its type, every shape is provided with a `draw` method of its own, all shapes share the same interface, therefore we can just draw them regularly and the snake should be drawn automatically.\n\nThe `update` method updates the last bit only according to its type, the time elapsed and the speed of the snake. For example, the last bit of the snake is a line, and 5 seconds have passed at a speed of 5 meters per second, our line should be extended by 5 meters long. Same principle applies to circle extension only based on radians. The last bit's type might be changed according to the current input; e.g. if the `right` key is held the last bit would turn into a circle, and once released it would turn into a straight line.\n\nNote that besides shapes extension, collision detection should also be made. The embedded is the collision detection between the snake and the canvas, which means that any time the snake collides with the canvas's boundaries the last bit should be redrawn from the opposite side of the canvas. In addition, we've implemented intersection methods for self collision detection and collision detection between rivals, which should be used externally by the hosting screen.\n\nIn the next step we will be implementing the game screen where we will make use of the `Snake` class we've just created, and see how it works in action."
          },
          {
            "manualTitle": "Step 6: Creating a complex game screen with multiple layers",
            "stepRevision": "c27bb0d7806aab70ec489ccd9bbff182d1053dda",
            "manualView": "![snake-demo-game-small](https://cloud.githubusercontent.com/assets/7648874/21074124/8b7cd724-bed7-11e6-9f91-2a211630ac78.gif)\n\nIn this step we will be using the `Snake` class we've just created in the previous step to form the actual game screen - called the `Play` screen. The play screen is a complex screen made out multiple layers as following:\n\n- **`Ready` layer** - Displays a message at the beginning of each match.\n- **`Snake` layer** - Displays the the competitors' snakes.\n- **`Score` layer** - Displays the score board.\n- **`Win` layer** - Displays the winner at the end of each match.\n\nAs we go further with this step, we will give a deeper explanation about each layer and how they interact with each other; As for let's start with the `Play` screen's basis. Regardless of what the `Play` screen should contain at the final result, we want to have the ability to abort the match whenever we press the `Escape` key, therefore, the initial implementation should look like this:\n\n[{]: <helper> (diffStep 6.1)\n\n#### [Step 6.1: Create &#x27;Play&#x27; screen](https://github.com/DAB0mB/radial-snake/commit/e17a45f)\n\n##### Added resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;play&#x2F;index.js\n```diff\n@@ -0,0 +1,14 @@\n+â”Š  â”Š 1â”ŠGame.Screens.Play = class Play extends Engine.Screen {\n+â”Š  â”Š 2â”Š  get events() {\n+â”Š  â”Š 3â”Š    return {\n+â”Š  â”Š 4â”Š      \"keydown\": \"onKeyDown\"\n+â”Š  â”Š 5â”Š    }\n+â”Š  â”Š 6â”Š  }\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Š  onKeyDown() {\n+â”Š  â”Š 9â”Š    // Once escape is pressed, return to main menu screen\n+â”Š  â”Š10â”Š    if (this.keyStates.get(27)) {\n+â”Š  â”Š11â”Š      this.game.changeScreen(Game.Screens.Menu);\n+â”Š  â”Š12â”Š    }\n+â”Š  â”Š13â”Š  }\n+â”Š  â”Š14â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -23,6 +23,7 @@\n â”Š23â”Š23â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/assets_loader.js\"></script>\n â”Š24â”Š24â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š25â”Š25â”Š    <script type=\"text/javascript\" src=\"/scripts/game/entities/snake.js\"></script>\n+â”Š  â”Š26â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/index.js\"></script>\n â”Š26â”Š27â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/menu/index.js\"></script>\n â”Š27â”Š28â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/splash/index.js\"></script>\n â”Š28â”Š29â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n```\n\n[}]: #\n\nNow that we have the `Play` screen, we need to hook it to the `Menu` screen, so whenever we press a key, we will be proceeded to it:\n\n[{]: <helper> (diffStep 6.2)\n\n#### [Step 6.2: Hook &#x27;Play&#x27; screen to &#x27;menu&#x27; screen](https://github.com/DAB0mB/radial-snake/commit/495b9ee)\n\n##### Changed resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;menu&#x2F;index.js\n```diff\n@@ -1,4 +1,10 @@\n â”Š 1â”Š 1â”ŠGame.Screens.Menu = class Menu extends Engine.Screen {\n+â”Š  â”Š 2â”Š  get events() {\n+â”Š  â”Š 3â”Š    return {\n+â”Š  â”Š 4â”Š      \"keydown\": \"onKeyDown\"\n+â”Š  â”Š 5â”Š    }\n+â”Š  â”Š 6â”Š  }\n+â”Š  â”Š 7â”Š\n â”Š 2â”Š 8â”Š  initialize() {\n â”Š 3â”Š 9â”Š    // Initialize snake logo sprite\n â”Š 4â”Š10â”Š    this.logoSprite = new Engine.Sprite(this.assets.logoTexture);\n```\n```diff\n@@ -40,10 +46,18 @@\n â”Š40â”Š46â”Š  }\n â”Š41â”Š47â”Š\n â”Š42â”Š48â”Š  update(span) {\n-â”Š43â”Š  â”Š    this.instructionsAnim.update(span);\n+â”Š  â”Š49â”Š    // On key press, proceed to play screen\n+â”Š  â”Š50â”Š    if (this.keyPressed) {\n+â”Š  â”Š51â”Š      this.game.changeScreen(Game.Screens.Play);\n+â”Š  â”Š52â”Š    }\n+â”Š  â”Š53â”Š    // Else, just update animation\n+â”Š  â”Š54â”Š    else {\n+â”Š  â”Š55â”Š      this.instructionsAnim.update(span);\n+â”Š  â”Š56â”Š    }\n â”Š44â”Š57â”Š  }\n â”Š45â”Š58â”Š\n-â”Š46â”Š  â”Š  update(span) {\n-â”Š47â”Š  â”Š    this.instructionsAnim.update(span);\n+â”Š  â”Š59â”Š  // Register key press\n+â”Š  â”Š60â”Š  onKeyDown(e) {\n+â”Š  â”Š61â”Š    this.keyPressed = true;\n â”Š48â”Š62â”Š  }\n â”Š49â”Š63â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nBy now there shouldn't be anything special. Once you're at the main menu, just press a key as instructed, and you shall see a black screen, which is actually the `Play` screen we've just created; And once you'll press the `Escape` key, you should be receded to the main menu.\n\nThe next stage would be displaying a `Ready` message on the screen, and whenever a key is pressed, the message should fade away using a key-frame animation, and the match should start in the background:\n\n[{]: <helper> (diffStep 6.3)\n\n#### [Step 6.3: Create &#x27;Ready&#x27; layer](https://github.com/DAB0mB/radial-snake/commit/551962d)\n\n##### Added resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;play&#x2F;ready.js\n```diff\n@@ -0,0 +1,59 @@\n+â”Š  â”Š 1â”ŠGame.Screens.Play.Ready = class Ready extends Engine.Layer {\n+â”Š  â”Š 2â”Š  get events() {\n+â”Š  â”Š 3â”Š    return {\n+â”Š  â”Š 4â”Š      \"keydown\": \"onKeyDown\"\n+â”Š  â”Š 5â”Š    };\n+â”Š  â”Š 6â”Š  }\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Š  constructor(screen, snakes) {\n+â”Š  â”Š 9â”Š    super(screen);\n+â”Š  â”Š10â”Š\n+â”Š  â”Š11â”Š    this.snakes = snakes;\n+â”Š  â”Š12â”Š\n+â”Š  â”Š13â”Š    // Create \"ready\" sprite and set its properties\n+â”Š  â”Š14â”Š    let readyTexture = this.assets.minecraftiaFont.createTexture(\"Ready\");\n+â”Š  â”Š15â”Š    let readySprite = new Engine.Sprite(readyTexture);\n+â”Š  â”Š16â”Š    readySprite.align = \"center\";\n+â”Š  â”Š17â”Š    readySprite.setPercentage(\"width\", this.width, 15, \"height\");\n+â”Š  â”Š18â”Š\n+â”Š  â”Š19â”Š    // Create fade out animation for \"ready\" sprite\n+â”Š  â”Š20â”Š    this.readyAnim = new Engine.Animations.Keyframe(readySprite, [\n+â”Š  â”Š21â”Š      {\n+â”Š  â”Š22â”Š        x: this.width / 2,\n+â”Š  â”Š23â”Š        y: this.height / 2,\n+â”Š  â”Š24â”Š        opacity: 1,\n+â”Š  â”Š25â”Š        frame: 0\n+â”Š  â”Š26â”Š      },\n+â”Š  â”Š27â”Š      {\n+â”Š  â”Š28â”Š        y: this.height / 3,\n+â”Š  â”Š29â”Š        opacity: 0,\n+â”Š  â”Š30â”Š        frame: 700\n+â”Š  â”Š31â”Š      }\n+â”Š  â”Š32â”Š    ]);\n+â”Š  â”Š33â”Š  }\n+â”Š  â”Š34â”Š\n+â”Š  â”Š35â”Š  draw(context) {\n+â”Š  â”Š36â”Š    this.readyAnim.draw(context);\n+â”Š  â”Š37â”Š  }\n+â”Š  â”Š38â”Š\n+â”Š  â”Š39â”Š  update(span) {\n+â”Š  â”Š40â”Š    if (!this.ready) return;\n+â”Š  â”Š41â”Š\n+â”Š  â”Š42â”Š    if (this.readyAnim.playing) {\n+â”Š  â”Š43â”Š      this.readyAnim.update(span);\n+â”Š  â”Š44â”Š    }\n+â”Š  â”Š45â”Š    // Once animation is finished, dispose layer\n+â”Š  â”Š46â”Š    else {\n+â”Š  â”Š47â”Š      this.screen.removeLayer(this);\n+â”Š  â”Š48â”Š    }\n+â”Š  â”Š49â”Š  }\n+â”Š  â”Š50â”Š\n+â”Š  â”Š51â”Š  onKeyDown() {\n+â”Š  â”Š52â”Š    // One time event\n+â”Š  â”Š53â”Š    this.disposeEventListeners()\n+â”Š  â”Š54â”Š\n+â”Š  â”Š55â”Š    // This will start playing the animation\n+â”Š  â”Š56â”Š    this.ready = true;\n+â”Š  â”Š57â”Š    this.readyAnim.play();\n+â”Š  â”Š58â”Š  }\n+â”Š  â”Š59â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -24,6 +24,7 @@\n â”Š24â”Š24â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š25â”Š25â”Š    <script type=\"text/javascript\" src=\"/scripts/game/entities/snake.js\"></script>\n â”Š26â”Š26â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/index.js\"></script>\n+â”Š  â”Š27â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/ready.js\"></script>\n â”Š27â”Š28â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/menu/index.js\"></script>\n â”Š28â”Š29â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/splash/index.js\"></script>\n â”Š29â”Š30â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n```\n\n[}]: #\n\nIn order to hook the `Ready` layer to the `Play` screen, we will just push a new instance of it to the layers stack, using the screen's `appendLayer` method. Note that the order of the layer is super critic! Since if we push a new layer it means it will be drawn on top of any previous layer. To \"shift\" a layer to the layers stack, we can simply use the `prependLayer` method instead. Without further due, this is how our hook should look like:\n\n[{]: <helper> (diffStep 6.4)\n\n#### [Step 6.4: Hook &#x27;Ready&#x27; layer to &#x27;Play&#x27; screen](https://github.com/DAB0mB/radial-snake/commit/b461464)\n\n##### Changed resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;play&#x2F;index.js\n```diff\n@@ -5,6 +5,11 @@\n â”Š 5â”Š 5â”Š    }\n â”Š 6â”Š 6â”Š  }\n â”Š 7â”Š 7â”Š\n+â”Š  â”Š 8â”Š  // The ready screen will be the initial screen\n+â”Š  â”Š 9â”Š  initialize(game, snakes) {\n+â”Š  â”Š10â”Š    this.appendLayer(Game.Screens.Play.Ready, snakes);\n+â”Š  â”Š11â”Š  }\n+â”Š  â”Š12â”Š\n â”Š 8â”Š13â”Š  onKeyDown() {\n â”Š 9â”Š14â”Š    // Once escape is pressed, return to main menu screen\n â”Š10â”Š15â”Š    if (this.keyStates.get(27)) {\n```\n\n[}]: #\n\nNow if you'll launch the game and start a new match, you should see a white `Ready` message in the middle of the screen. Up next, would be the `Snake` layer, which will simply initialize 2 new `Snake` instances, and take care of drawing and updating them:\n\n[{]: <helper> (diffStep 6.5)\n\n#### [Step 6.5: Create &#x27;snake&#x27; layer](https://github.com/DAB0mB/radial-snake/commit/a36d7f2)\n\n##### Added resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;play&#x2F;snake.js\n```diff\n@@ -0,0 +1,79 @@\n+â”Š  â”Š 1â”ŠGame.Screens.Play.Snake = class Snake extends Engine.Layer {\n+â”Š  â”Š 2â”Š  constructor(screen, snakes = []) {\n+â”Š  â”Š 3â”Š    super(screen);\n+â”Š  â”Š 4â”Š\n+â”Š  â”Š 5â”Š    // Red snake\n+â”Š  â”Š 6â”Š    this.snakes = [\n+â”Š  â”Š 7â”Š      new Game.Entities.Snake(\n+â”Š  â”Š 8â”Š        this.width / 4,\n+â”Š  â”Š 9â”Š        this.height / 4,\n+â”Š  â”Š10â”Š        50,\n+â”Š  â”Š11â”Š        Math.PI / 4,\n+â”Š  â”Š12â”Š        100,\n+â”Š  â”Š13â”Š        \"FireBrick\",\n+â”Š  â”Š14â”Š        this.keyStates,\n+â”Š  â”Š15â”Š        {\n+â”Š  â”Š16â”Š          // Use score from previous matches\n+â”Š  â”Š17â”Š          score: snakes[0] && snakes[0].score,\n+â”Š  â”Š18â”Š          keys: {\n+â”Š  â”Š19â”Š            left: 37, // Left key\n+â”Š  â”Š20â”Š            right: 39 // RIght key\n+â”Š  â”Š21â”Š        }\n+â”Š  â”Š22â”Š      }),\n+â”Š  â”Š23â”Š\n+â”Š  â”Š24â”Š      // Blue snake\n+â”Š  â”Š25â”Š      new Game.Entities.Snake(\n+â”Š  â”Š26â”Š        (this.width / 4) * 3,\n+â”Š  â”Š27â”Š        (this.height / 4) * 3,\n+â”Š  â”Š28â”Š        50,\n+â”Š  â”Š29â”Š        (-Math.PI / 4) * 3,\n+â”Š  â”Š30â”Š        100,\n+â”Š  â”Š31â”Š        \"DodgerBlue\",\n+â”Š  â”Š32â”Š        this.keyStates,\n+â”Š  â”Š33â”Š        {\n+â”Š  â”Š34â”Š          score: snakes[1] && snakes[1].score,\n+â”Š  â”Š35â”Š          keys: {\n+â”Š  â”Š36â”Š            left: 65, // 'a' key\n+â”Š  â”Š37â”Š            right: 68 // 'b' key\n+â”Š  â”Š38â”Š        }\n+â”Š  â”Š39â”Š      })\n+â”Š  â”Š40â”Š    ];\n+â”Š  â”Š41â”Š  }\n+â”Š  â”Š42â”Š\n+â”Š  â”Š43â”Š  draw(context) {\n+â”Š  â”Š44â”Š    // Draw each snake in the snakes array\n+â”Š  â”Š45â”Š    this.snakes.forEach(snake => snake.draw(context));\n+â”Š  â”Š46â”Š  }\n+â”Š  â”Š47â”Š\n+â”Š  â”Š48â”Š  update(span) {\n+â”Š  â”Š49â”Š    if (!this.snakes.length) return;\n+â”Š  â”Š50â”Š\n+â”Š  â”Š51â”Š    // Storing original snakes array for future use, since it might get changed\n+â”Š  â”Š52â”Š    let snakes = this.snakes.slice();\n+â”Š  â”Š53â”Š\n+â”Š  â”Š54â”Š    snakes.forEach((snake, index) => {\n+â”Š  â”Š55â”Š      snake.update(span, this.width, this.height);\n+â”Š  â”Š56â”Š      // Disqualify if intersected with self\n+â”Š  â”Š57â”Š      if (snake.getSelfIntersection()) return this.snakes.splice(index, 1);\n+â”Š  â”Š58â”Š\n+â”Š  â”Š59â”Š      snakes.forEach((opponent) => {\n+â”Š  â”Š60â”Š        // Don't scan for intersection with self, obviously this will always be true\n+â”Š  â”Š61â”Š        if (opponent === snake) return;\n+â”Š  â”Š62â”Š        // Disqualify if intersected with opponent\n+â”Š  â”Š63â”Š        if (snake.getSnakeIntersection(opponent)) this.snakes.splice(index, 1);\n+â”Š  â”Š64â”Š      });\n+â”Š  â”Š65â”Š    });\n+â”Š  â”Š66â”Š\n+â”Š  â”Š67â”Š    // There can be only one winner, or a tie (very rare, most likely not to happen)\n+â”Š  â”Š68â”Š    // If the match is already finished, skip the next steps since they are not relevant\n+â”Š  â”Š69â”Š    if (this.snakes.length > 1 || this.matchFinished) return;\n+â”Š  â”Š70â”Š\n+â”Š  â”Š71â”Š    // The winner is the \"last snake standing\"\n+â”Š  â”Š72â”Š    let winner = this.snakes[0];\n+â”Š  â”Š73â”Š    // If this is not a tie, which is a very rare case, increase the winner's score\n+â”Š  â”Š74â”Š    if (winner) winner.score++;\n+â”Š  â”Š75â”Š\n+â”Š  â”Š76â”Š    // Indicates whether we should update the score counter or not\n+â”Š  â”Š77â”Š    this.matchFinished = true;\n+â”Š  â”Š78â”Š  }\n+â”Š  â”Š79â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -24,6 +24,7 @@\n â”Š24â”Š24â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š25â”Š25â”Š    <script type=\"text/javascript\" src=\"/scripts/game/entities/snake.js\"></script>\n â”Š26â”Š26â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/index.js\"></script>\n+â”Š  â”Š27â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/snake.js\"></script>\n â”Š27â”Š28â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/ready.js\"></script>\n â”Š28â”Š29â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/menu/index.js\"></script>\n â”Š29â”Š30â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/splash/index.js\"></script>\n```\n\n[}]: #\n\nOnce pressing a key in the `Ready` layer, not only we want to display an animation, but we also want the match to start in the background, thus, we gonna push a new instance of the `Snake` layer we've just created like so:\n\n[{]: <helper> (diffStep 6.6)\n\n#### [Step 6.6: Hook &#x27;snake&#x27; layer to &#x27;ready&#x27; layer](https://github.com/DAB0mB/radial-snake/commit/982db7b)\n\n##### Changed resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;play&#x2F;ready.js\n```diff\n@@ -55,5 +55,8 @@\n â”Š55â”Š55â”Š    // This will start playing the animation\n â”Š56â”Š56â”Š    this.ready = true;\n â”Š57â”Š57â”Š    this.readyAnim.play();\n+â”Š  â”Š58â”Š\n+â”Š  â”Š59â”Š    // Start the game in the background\n+â”Š  â”Š60â”Š    this.screen.prependLayer(Game.Screens.Play.Snake, this.snakes);\n â”Š58â”Š61â”Š  }\n â”Š59â”Š62â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nNote that the layer is pushed when the animation starts and not once finished; This would give a nice smooth feeling to our game-flow. If you'll test out the game, you would discover that the match is actually playable! The first snake (Red) snake should be controlled by the arrow keys, and the second snake (Blue) should be controlled by the letter keys `a`, `s`, `d` and `w`. So far, the snakes function great, but you can probably tell that whenever a match is finished, it feels a bit dull. There's no indication of winning, and there's no score board to present the score of each competitor, which brings us to the next stage - Implementing the `Score` layer.\n\nThe `Score` layer is a simple layer which takes the 2 snakes as a parameter and displays their scores at the top of the screen:\n\n[{]: <helper> (diffStep 6.7)\n\n#### [Step 6.7: Create &#x27;Score&#x27; layer](https://github.com/DAB0mB/radial-snake/commit/6ec4cac)\n\n##### Added resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;play&#x2F;score.js\n```diff\n@@ -0,0 +1,66 @@\n+â”Š  â”Š 1â”ŠGame.Screens.Play.Score = class Score extends Engine.Layer {\n+â”Š  â”Š 2â”Š  constructor(screen, snakes) {\n+â”Š  â”Š 3â”Š    super(screen);\n+â”Š  â”Š 4â”Š\n+â”Š  â”Š 5â”Š    this.snakes = snakes;\n+â”Š  â”Š 6â”Š    this.scoreSprites = [];\n+â”Š  â”Š 7â”Š    this.scores = [];\n+â”Š  â”Š 8â”Š\n+â”Š  â”Š 9â”Š    // It's important to match indexes to each snake since the number of snakes\n+â”Š  â”Š10â”Š    // can be reduced along the way as we play\n+â”Š  â”Š11â”Š    snakes.forEach((snake, index) => {\n+â”Š  â”Š12â”Š      snake.index = index;\n+â”Š  â”Š13â”Š    });\n+â”Š  â”Š14â”Š  }\n+â”Š  â”Š15â”Š\n+â”Š  â”Š16â”Š  draw(context) {\n+â”Š  â”Š17â”Š    this.scoreSprites.forEach((scoreSprite) => {\n+â”Š  â”Š18â”Š      scoreSprite.draw(context);\n+â”Š  â”Š19â”Š    });\n+â”Š  â”Š20â”Š  }\n+â”Š  â”Š21â”Š\n+â”Š  â”Š22â”Š  update(span) {\n+â”Š  â”Š23â”Š    this.snakes.forEach(snake => {\n+â”Š  â”Š24â”Š      let index = snake.index;\n+â”Š  â”Š25â”Š      if (this.scores[index] == snake.score) return;\n+â”Š  â”Š26â”Š\n+â”Š  â”Š27â”Š      // The sprite might be changed along the way so it's important to recreate it\n+â”Š  â”Š28â”Š      // over and over again. If no change was made the cache will be used by the engine\n+â”Š  â”Š29â”Š      this.scoreSprites[index] = this.createScoreSprite(snake);\n+â”Š  â”Š30â”Š      this.scores[index] = snake.score;\n+â”Š  â”Š31â”Š    });\n+â”Š  â”Š32â”Š  }\n+â”Š  â”Š33â”Š\n+â”Š  â”Š34â”Š  createScoreSprite(snake) {\n+â”Š  â”Š35â”Š    let minecraftiaFont = this.assets.minecraftiaFont;\n+â”Š  â”Š36â”Š    minecraftiaFont.save();\n+â”Š  â”Š37â”Š    minecraftiaFont.color = snake.color;\n+â”Š  â”Š38â”Š\n+â”Š  â”Š39â”Š    // Create a score sprite for the snake\n+â”Š  â”Š40â”Š    let scoreTexture = minecraftiaFont.createTexture(`${snake.score}`, {\n+â”Š  â”Š41â”Š      noOffsets: true,\n+â”Š  â”Š42â”Š      noSpaces: true\n+â”Š  â”Š43â”Š    });\n+â”Š  â”Š44â”Š\n+â”Š  â”Š45â”Š    let scoreSprite = new Engine.Sprite(scoreTexture);\n+â”Š  â”Š46â”Š\n+â”Š  â”Š47â”Š    // Size of score board is dynamic to screen size\n+â”Š  â”Š48â”Š    scoreSprite.setPercentage(\"width\", this.width, 4, \"height\");\n+â”Š  â”Š49â”Š\n+â”Š  â”Š50â”Š    // Set alignment modes.\n+â”Š  â”Š51â”Š    // Once we add more snakes we should add more cases here\n+â”Š  â”Š52â”Š    switch (snake.index) {\n+â”Š  â”Š53â”Š      case 0:\n+â”Š  â”Š54â”Š        scoreSprite.align = \"top-left\";\n+â”Š  â”Š55â”Š        break;\n+â”Š  â”Š56â”Š      case 1:\n+â”Š  â”Š57â”Š        scoreSprite.align = \"top-right\";\n+â”Š  â”Š58â”Š        scoreSprite.x = this.width;\n+â”Š  â”Š59â”Š        break;\n+â”Š  â”Š60â”Š    }\n+â”Š  â”Š61â”Š\n+â”Š  â”Š62â”Š    // Restore the font to its original color\n+â”Š  â”Š63â”Š    minecraftiaFont.restore();\n+â”Š  â”Š64â”Š    return scoreSprite;\n+â”Š  â”Š65â”Š  }\n+â”Š  â”Š66â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -24,6 +24,7 @@\n â”Š24â”Š24â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š25â”Š25â”Š    <script type=\"text/javascript\" src=\"/scripts/game/entities/snake.js\"></script>\n â”Š26â”Š26â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/index.js\"></script>\n+â”Š  â”Š27â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/score.js\"></script>\n â”Š27â”Š28â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/snake.js\"></script>\n â”Š28â”Š29â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/ready.js\"></script>\n â”Š29â”Š30â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/menu/index.js\"></script>\n```\n\n[}]: #\n\n> Note that the current score board is suitable for two players, but can easily be modified to support as much players as you want if done correctly.\n\nThe `Score` board should be appended to the layers stack as soon as the `Snake` layers is initialized, so it would be available to us once the match is started:\n\n[{]: <helper> (diffStep 6.8)\n\n#### [Step 6.8: Hook &#x27;Score&#x27; layer to &#x27;Snake&#x27; layer](https://github.com/DAB0mB/radial-snake/commit/feb4a0b)\n\n##### Changed resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;play&#x2F;snake.js\n```diff\n@@ -38,6 +38,9 @@\n â”Š38â”Š38â”Š        }\n â”Š39â”Š39â”Š      })\n â”Š40â”Š40â”Š    ];\n+â”Š  â”Š41â”Š\n+â”Š  â”Š42â”Š    // Show score board for newly created snakes\n+â”Š  â”Š43â”Š    screen.appendLayer(Game.Screens.Play.Score, this.snakes);\n â”Š41â”Š44â”Š  }\n â”Š42â”Š45â”Š\n â”Š43â”Š46â”Š  draw(context) {\n```\n\n[}]: #\n\nNow we're one layer further from completing the `Play` screen, the only thing missing is the `Win` layer, which should present the winner once the match is finished:\n\n[{]: <helper> (diffStep 6.9)\n\n#### [Step 6.9: Create &#x27;Win&#x27; layer](https://github.com/DAB0mB/radial-snake/commit/3476384)\n\n##### Added resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;play&#x2F;win.js\n```diff\n@@ -0,0 +1,43 @@\n+â”Š  â”Š 1â”ŠGame.Screens.Play.Win = class Win extends Engine.Layer {\n+â”Š  â”Š 2â”Š  constructor(screen, snakes, winner) {\n+â”Š  â”Š 3â”Š    super(screen);\n+â”Š  â”Š 4â”Š\n+â”Š  â”Š 5â”Š    this.snakes = snakes;\n+â”Š  â”Š 6â”Š    this.winner = winner;\n+â”Š  â”Š 7â”Š    // ttl stands for \"time to live\", which means, this layer is going to be\n+â”Š  â”Š 8â”Š    // disposed after 3 seconds\n+â”Š  â”Š 9â”Š    this.ttl = 3000;\n+â”Š  â”Š10â”Š\n+â”Š  â”Š11â”Š    // If there is a winner\n+â”Š  â”Š12â”Š    if (this.winner) {\n+â”Š  â”Š13â”Š      // Message could be something like \"RED SNAKE WINS\"\n+â”Š  â”Š14â”Š      var text = `${this.winner.color.toUpperCase()} SNAKE WINS`;\n+â”Š  â”Š15â”Š      var percent = 40;\n+â”Š  â”Š16â”Š    }\n+â”Š  â”Š17â”Š    // If there is a tie\n+â”Š  â”Š18â”Š    else {\n+â”Š  â”Š19â”Š      var text = 'TIE';\n+â”Š  â”Š20â”Š      var percent = 15;\n+â”Š  â”Š21â”Š    }\n+â”Š  â”Š22â”Š\n+â”Š  â”Š23â”Š    // Create winner sprite and set its properties\n+â”Š  â”Š24â”Š    let winnerTexture = this.assets.minecraftiaFont.createTexture(text);\n+â”Š  â”Š25â”Š    this.winnerSprite = new Engine.Sprite(winnerTexture);\n+â”Š  â”Š26â”Š    this.winnerSprite.align = \"center\";\n+â”Š  â”Š27â”Š    this.winnerSprite.setPercentage(\"width\", this.width, percent, \"height\");\n+â”Š  â”Š28â”Š    this.winnerSprite.x = this.width / 2;\n+â”Š  â”Š29â”Š    this.winnerSprite.y = this.height / 2;\n+â”Š  â”Š30â”Š  }\n+â”Š  â”Š31â”Š\n+â”Š  â”Š32â”Š  draw(context) {\n+â”Š  â”Š33â”Š    this.winnerSprite.draw(context);\n+â”Š  â”Š34â”Š  }\n+â”Š  â”Š35â”Š\n+â”Š  â”Š36â”Š  update(span) {\n+â”Š  â”Š37â”Š    // If limit not yet reached, abort\n+â”Š  â”Š38â”Š    if (this.age < this.ttl) return;\n+â”Š  â”Š39â”Š\n+â”Š  â”Š40â”Š    // Show \"ready\" message all over again, only this time use the updated score board\n+â”Š  â”Š41â”Š    this.screen.game.changeScreen(Game.Screens.Play, this.snakes);\n+â”Š  â”Š42â”Š  }\n+â”Š  â”Š43â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -24,6 +24,7 @@\n â”Š24â”Š24â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š25â”Š25â”Š    <script type=\"text/javascript\" src=\"/scripts/game/entities/snake.js\"></script>\n â”Š26â”Š26â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/index.js\"></script>\n+â”Š  â”Š27â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/win.js\"></script>\n â”Š27â”Š28â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/score.js\"></script>\n â”Š28â”Š29â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/snake.js\"></script>\n â”Š29â”Š30â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/ready.js\"></script>\n```\n\n[}]: #\n\nNote how we use the `changeScreen` method once the `Win` layer has reached its age limit (Time to live, aka `ttl`); This would clear the layers stack and restart the `Play` screen, so we can start a new match all-over, only this time we will pass the `Snake` instances to reserve the original scores. The `Win` layer should be presented whenever a collision has been detected between the snakes:\n\n[{]: <helper> (diffStep 6.1)\n\n#### [Step 6.1: Create &#x27;Play&#x27; screen](https://github.com/DAB0mB/radial-snake/commit/e17a45f)\n\n##### Added resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;play&#x2F;index.js\n```diff\n@@ -0,0 +1,14 @@\n+â”Š  â”Š 1â”ŠGame.Screens.Play = class Play extends Engine.Screen {\n+â”Š  â”Š 2â”Š  get events() {\n+â”Š  â”Š 3â”Š    return {\n+â”Š  â”Š 4â”Š      \"keydown\": \"onKeyDown\"\n+â”Š  â”Š 5â”Š    }\n+â”Š  â”Š 6â”Š  }\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Š  onKeyDown() {\n+â”Š  â”Š 9â”Š    // Once escape is pressed, return to main menu screen\n+â”Š  â”Š10â”Š    if (this.keyStates.get(27)) {\n+â”Š  â”Š11â”Š      this.game.changeScreen(Game.Screens.Menu);\n+â”Š  â”Š12â”Š    }\n+â”Š  â”Š13â”Š  }\n+â”Š  â”Š14â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -23,6 +23,7 @@\n â”Š23â”Š23â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/assets_loader.js\"></script>\n â”Š24â”Š24â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š25â”Š25â”Š    <script type=\"text/javascript\" src=\"/scripts/game/entities/snake.js\"></script>\n+â”Š  â”Š26â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/index.js\"></script>\n â”Š26â”Š27â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/menu/index.js\"></script>\n â”Š27â”Š28â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/splash/index.js\"></script>\n â”Š28â”Š29â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n```\n\n[}]: #\n\nThat's it folks, the `Play` screen is finished, and you can play as much matches as you'd feel like.\n\nAlthough the game is finished, it can still be optimized using `C++`. To discover more on hooking efficiency and how we can hook `C++` to the browser, see the next step."
          },
          {
            "manualTitle": "Step 7: Bonus! Re-implementing geometry in C++",
            "stepRevision": "cea4cffcc2f5e801020ed13ef8f1edde608c85f3",
            "manualView": "> This step is part of a bigger tutorial series where we learn how to create a game engine and implement a Tron-style game in JavaScript. The base project for the following step is available [here](https://github.com/DAB0mB/radial-snake/tree/step6).\n\nSo far I covered up pretty much everything I planned. I showed you how to create a game engine, including a font generator, an animation player and a screening system. On top of that, we've learned how to structure and organize our code well, so if in the future we'd like to extend our game by adding more screens or capabilities, we can do that with ease. Indeed, we've went through lots of great stuff, and if you've reached this point I give you my thumbs up. If so far this wasn't enough, in this step we will be focusing on optimization, and making our game engine run faster (a lot, faster). Obviously, when talking about optimizations, the first thing you would probably think of is how we can make our algorithms efficient by using minimum number of operations. While this is true, we will be actually focusing on optimizing our code using C++.\n\nUnlike JavaScript, which is a dynamic scripting file executed by an interpreter, C++ is a general purpose language which compiles into executables. Naturally, executables are much faster than scripts, since they don't have to be interpreted, and they can approach the hardware and memory much faster. In C++, we have to explicitly define our data-types, meaning that variables don't have to be parsed during run-time. While explicit variables definition is C++'s biggest drawback, it's also one of its biggest advantages. The mere fact that variables can be handled much faster, makes code much more efficient.\n\nAccordingly, we can conclude that the programming language we're using plays a very important role when it comes to efficiency. So how exactly are we going to integrate C++ into the browser? We're going to do that by using a compiler called - [Emscripten](http://kripken.github.io/emscripten-site/).\n\n![emscripten](https://cloud.githubusercontent.com/assets/7648874/22675449/ee6d7e9c-eccc-11e6-9570-1dd5d982ee66.png)\n\nEmscripten is an Open Source [LLVM](https://en.wikipedia.org/wiki/LLVM) to JavaScript compiler. Using Emscripten you can:\n\n- Compile C and C++ code into JavaScript\n- Compile any other code that can be translated into LLVM bitcode into JavaScript.\n- Compile the C/C++ runtimes of other languages into JavaScript, and then run code in those other languages in an indirect way (this has been done for Python and Lua)!\n\nLLVM is a library that is used to construct, optimize and produce intermediate and/or binary machine code. LLVM can be used as a compiler framework, where you provide the \"front end\" (parser and lexer) and the \"back end\" (code that converts LLVM's representation to actual machine code). LLVM can also act as a JIT compiler - it has support for x86/x86_64 and PPC/PPC64 assembly generation with fast code optimizations aimed for compilation speed.\n\nEmscripten operates by taking LLVM code and converting it into a subset of JavaScript called asm.js that can run anywhere that JavaScript can run (usually the browser, but also Node.js, etc.) and is easy for browsers to optimize. This means that you can basically write web applications in any language that has an LLVM compiler.\n\n![emscripten-flow](https://cloud.githubusercontent.com/assets/7648874/22675751/b244b76c-ecce-11e6-917e-f7039ed4b340.png)\n\nIn order to use Emscripten you will first have to install it. I recommend you to follow Emscripten's official installation instructions at their website over [here](https://kripken.github.io/emscripten-site/docs/getting_started/downloads.html). Installing Emscripten might be a bit tiring for some, I know for me it was, but if you're hyped about writing native code in the browser as much as I do, take as much time as needed to install it, and bare with me.\n\nAssuming that you have Emscripten installed, we can get right to business. The goal for this step is to re-implement our geometry namespace in C++, and to be more specific, the circle class and line class. We will start by creating an entry file for our C++ code under the path `resources/cpp/src/index.cpp`:\n\n    $ mkdir resources/cpp\n    $ mkdir resources/cpp/src\n    $ touch resources/cpp/src/index.cpp\n\nFrom now on, every C++ file that we would like to run in the browser should be included in the `index.cpp` file we've just created, otherwise it's not going to appear anywhere. The first stage for re-implementing our geometry would be re-writing the utility module, since our geometry is heavily based on it; Therefore the firs inclusion in our `index.cpp` file would be the following:\n\n[{]: <helper> (diffStep 7.1)\n\n#### [Step 7.1: Add CPP entry script](https://github.com/DAB0mB/radial-snake/commit/2f35323)\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;index.cpp\n```diff\n@@ -0,0 +1 @@\n+â”Š â”Š1â”Š#include \"utils.cpp\"ðŸš«â†µ\n```\n\n[}]: #\n\nFollowing that, we will create the `utils.cpp` module included above, which is a direct translation from C++ to JavaScript for the `utils.js` we've created earlier in this tutorial.\n\n[{]: <helper> (diffStep 7.2)\n\n#### [Step 7.2: Add base utility CPP module](https://github.com/DAB0mB/radial-snake/commit/6dba512)\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;utils.cpp\n```diff\n@@ -0,0 +1,73 @@\n+â”Š  â”Š 1â”Š#include <cfloat>\n+â”Š  â”Š 2â”Š#include <cmath>\n+â”Š  â”Š 3â”Š#include <string>\n+â”Š  â”Š 4â”Š#include \"utils.h\"\n+â”Š  â”Š 5â”Š\n+â”Š  â”Š 6â”Šnamespace utils {\n+â”Š  â”Š 7â”Š  // Fixed modulo method which can calculate modulo of negative numbers properly\n+â”Š  â”Š 8â”Š  // e.g. (-803).mod(800) returns 797\n+â”Š  â”Š 9â”Š  double mod(double context, double num) {\n+â”Š  â”Š10â”Š    return std::fmod((std::fmod(context, num) + num), num);\n+â”Š  â”Š11â”Š  }\n+â”Š  â”Š12â”Š\n+â”Š  â”Š13â”Š  // Trims number and leaves the number of decimals specified.\n+â”Š  â”Š14â”Š  // The \"mode\" argument specifies which math function should be invoked\n+â”Š  â”Š15â”Š  // right after the number has been trimmed.\n+â”Š  â”Š16â”Š  // e.g. 12.12345.trim(3, \"ceil\") returns 12.124\n+â”Š  â”Š17â”Š  double trim(double context, int decimals, const std::string mode) {\n+â”Š  â”Š18â”Š    double accumulator = context * std::pow(10, decimals);\n+â”Š  â”Š19â”Š\n+â”Š  â”Š20â”Š    if (mode.compare(\"ceil\") == 0)\n+â”Š  â”Š21â”Š      accumulator = std::ceil(accumulator);\n+â”Š  â”Š22â”Š    else if (mode.compare(\"floor\") == 0)\n+â”Š  â”Š23â”Š      accumulator = std::floor(accumulator);\n+â”Š  â”Š24â”Š    else\n+â”Š  â”Š25â”Š      accumulator = std::round(accumulator);\n+â”Š  â”Š26â”Š\n+â”Š  â”Š27â”Š    return accumulator / std::pow(10, decimals);\n+â”Š  â”Š28â”Š  }\n+â”Š  â”Š29â”Š\n+â”Š  â”Š30â”Š  // Tells if number is in specified range based on given precision.\n+â”Š  â”Š31â”Š  // See the \"compare\" method for more information about precision\n+â”Š  â”Š32â”Š  bool isBetween(double context, double num1, double num2, const std::string precision) {\n+â”Š  â”Š33â”Š    return compare(context, std::min(num1, num2), \">=\", precision) &&\n+â”Š  â”Š34â”Š           compare(context, std::max(num1, num2), \"<=\", precision);\n+â”Š  â”Š35â”Š  }\n+â”Š  â”Š36â”Š\n+â”Š  â”Š37â”Š  bool compare(double context, double num, const std::string precision) {\n+â”Š  â”Š38â”Š    return compare(context, num, \"==\", precision);\n+â”Š  â”Š39â”Š  }\n+â”Š  â”Š40â”Š\n+â”Š  â”Š41â”Š  // Initiates comparison operator between context number and a given number, only here\n+â”Š  â”Š42â”Š  // a precision can be specified\n+â”Š  â”Š43â”Š  bool compare(double context, double num, const std::string method, const std::string precision) {\n+â”Š  â”Š44â”Š    // Fixed precision, \"almost equal\" with a deviation of Îµ\n+â”Š  â”Š45â”Š    if (precision.compare(\"f\") == 0) {\n+â”Š  â”Š46â”Š      if (method.compare(\"<\") == 0 ||\n+â”Š  â”Š47â”Š          method.compare(\"<=\") == 0)\n+â”Š  â”Š48â”Š        return context <= num + DBL_EPSILON;\n+â”Š  â”Š49â”Š      if (method.compare(\">\") == 0 ||\n+â”Š  â”Š50â”Š          method.compare(\">=\") == 0)\n+â”Š  â”Š51â”Š        return context >= num - DBL_EPSILON;\n+â”Š  â”Š52â”Š      return std::abs(context - num) <= DBL_EPSILON;\n+â”Š  â”Š53â”Š    }\n+â”Š  â”Š54â”Š    // Pixel precision, round comparison\n+â”Š  â”Š55â”Š    else if (precision.compare(\"px\") == 0) {\n+â”Š  â”Š56â”Š      if (method.compare(\"<\") == 0 ||\n+â”Š  â”Š57â”Š          method.compare(\"<=\") == 0)\n+â”Š  â”Š58â”Š        return std::round(context) <= std::round(num);\n+â”Š  â”Š59â”Š      if (method.compare(\">\") == 0 ||\n+â”Š  â”Š60â”Š          method.compare(\">=\") == 0)\n+â”Š  â”Š61â”Š        return std::round(context) >= std::round(num);\n+â”Š  â”Š62â”Š      return std::round(context) == std::round(num);\n+â”Š  â”Š63â”Š    }\n+â”Š  â”Š64â”Š    // Exact precision\n+â”Š  â”Š65â”Š    else {\n+â”Š  â”Š66â”Š      if (method.compare(\"<\") == 0) return context < num;\n+â”Š  â”Š67â”Š      if (method.compare(\"<=\") == 0) return context <= num;\n+â”Š  â”Š68â”Š      if (method.compare(\">\") == 0) return context > num;\n+â”Š  â”Š69â”Š      if (method.compare(\">=\") == 0) return context >= num;\n+â”Š  â”Š70â”Š      return context == num;\n+â”Š  â”Š71â”Š    }\n+â”Š  â”Š72â”Š  }\n+â”Š  â”Š73â”Š}ðŸš«â†µ\n```\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;utils.h\n```diff\n@@ -0,0 +1,15 @@\n+â”Š  â”Š 1â”Š#pragma once\n+â”Š  â”Š 2â”Š\n+â”Š  â”Š 3â”Š#include <string>\n+â”Š  â”Š 4â”Š\n+â”Š  â”Š 5â”Šnamespace utils {\n+â”Š  â”Š 6â”Š  double mod(double context, double num);\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Š  double trim(double context, int decimals, const std::string mode = \"round\");\n+â”Š  â”Š 9â”Š\n+â”Š  â”Š10â”Š  bool isBetween(double context, double num1, double num2, const std::string precision = \"exact\");\n+â”Š  â”Š11â”Š\n+â”Š  â”Š12â”Š  bool compare(double context, double num, const std::string precision = \"exact\");\n+â”Š  â”Š13â”Š\n+â”Š  â”Š14â”Š  bool compare(double context, double num, const std::string method, const std::string precision);\n+â”Š  â”Š15â”Š}ðŸš«â†µ\n```\n\n[}]: #\n\nThe module above should work by itself when interacting with it inside the C++ scope, but that's not what we're striving for. We want this module to be available for use in our JavaScript project. This requires us to wrap our code in such a way the the Emscripten compiler will know how to compile it. Apart from providing a compiler, Emscripten provides us with functions and macros that will help use bind our C++ code to the JavaScript environment. These functionalities are packed in a single library which can be imported in our C++ code, and it is called [Embind](https://kripken.github.io/emscripten-site/docs/porting/connecting_cpp_and_javascript/embind.html) (probably stands for \"Emscripten bind\"). Using EMBind, let's wrap our utils module accordingly:\n\n[{]: <helper> (diffStep 7.3)\n\n#### [Step 7.3: EMBind CPP utils](https://github.com/DAB0mB/radial-snake/commit/0f34332)\n\n##### Changed resources&#x2F;cpp&#x2F;src&#x2F;utils.cpp\n```diff\n@@ -1,6 +1,7 @@\n â”Š1â”Š1â”Š#include <cfloat>\n â”Š2â”Š2â”Š#include <cmath>\n â”Š3â”Š3â”Š#include <string>\n+â”Š â”Š4â”Š#include <emscripten/bind.h>\n â”Š4â”Š5â”Š#include \"utils.h\"\n â”Š5â”Š6â”Š\n â”Š6â”Š7â”Šnamespace utils {\n```\n```diff\n@@ -70,4 +71,15 @@\n â”Š70â”Š71â”Š      return context == num;\n â”Š71â”Š72â”Š    }\n â”Š72â”Š73â”Š  }\n+â”Š  â”Š74â”Š}\n+â”Š  â”Š75â”Š\n+â”Š  â”Š76â”ŠEMSCRIPTEN_BINDINGS(utils_module) {\n+â”Š  â”Š77â”Š  emscripten::function(\"utils_mod\", &utils::mod);\n+â”Š  â”Š78â”Š  emscripten::function(\"utils_trim\", &utils::trim);\n+â”Š  â”Š79â”Š  emscripten::function(\"utils_isBetween\", &utils::isBetween);\n+â”Š  â”Š80â”Š  emscripten::function(\"utils_compare\",\n+â”Š  â”Š81â”Š    emscripten::select_overload<bool(double, double, const std::string, const std::string)>(\n+â”Š  â”Š82â”Š      &utils::compare\n+â”Š  â”Š83â”Š    )\n+â”Š  â”Š84â”Š  );\n â”Š73â”Š85â”Š}ðŸš«â†µ\n```\n\n[}]: #\n\nAfter a while you'll get used for Embind's API. If you'll look at it, it's self explanatory and easy to understand. Bound objects will be available the JavaScript environment will be available under an object named `Module`, e.g. the C++ method `mod` will be available for use as `Module.utils_mod`. Bound functions should have supported return types and argument types, meaning that if we're using a custom structure as a return type or an argument type, we first need to wrap it using EMBind, otherwise the compiler won't know how to handle it. A list of natively supported data-types can be found [here](https://kripken.github.io/emscripten-site/docs/porting/connecting_cpp_and_javascript/embind.html#built-in-type-conversions).\n\nEven though we've wrapped our C++ code and hypothetically it can already be used in the browser, I'd go for a second wrapper, since the compiled code doesn't have the optimal architecture. Right now we will have to approach C++ utility functions using `Module.utils_foo`. Instead, I'd like it to be `CPP.Utils.foo`, since it's clearer this way. The output of the Emscripten compiler can be wrapped with JavaScript code, using a prefix and a suffix, defined in 2 separate files respectively, called `pre.js` and `post.js`:\n\n[{]: <helper> (diffStep 7.4)\n\n#### [Step 7.4: Create CPP wrappers](https://github.com/DAB0mB/radial-snake/commit/cc28a34)\n\n##### Added resources&#x2F;cpp&#x2F;post.js\n```diff\n@@ -0,0 +1,10 @@\n+â”Š  â”Š 1â”Šreturn {\n+â”Š  â”Š 2â”Š  Utils: {\n+â”Š  â”Š 3â”Š    mod: Module.utils_mod,\n+â”Š  â”Š 4â”Š    trim: Module.utils_trim,\n+â”Š  â”Š 5â”Š    isBetween: Module.utils_isBetween,\n+â”Š  â”Š 6â”Š    compare: Module.utils_compare\n+â”Š  â”Š 7â”Š  }\n+â”Š  â”Š 8â”Š};\n+â”Š  â”Š 9â”Š\n+â”Š  â”Š10â”Š})();ðŸš«â†µ\n```\n\n##### Added resources&#x2F;cpp&#x2F;pre.js\n```diff\n@@ -0,0 +1 @@\n+â”Š â”Š1â”ŠCPP = (function() {ðŸš«â†µ\n```\n\n[}]: #\n\nWhat we've done in the code snippet above, we've created an anonymous function which calls itself, and inside we've exported a new namespace called `CPP` (C++). This way we can keep the generated code encapsulated, without worrying about spamming the global object.\n\nAfter creating a wrapper, I'd also recommend you to integrate the generated C++ code into existing namespaces, meaning that if for example we would like to approach the `CPP.Utils.foo` method, it could be done using `Utils.foo`. This way existing code won't have to be changed, and extra wrapping logic can be applied with ease, like the chaining logic implemented in the `Utils` namespace:\n\n[{]: <helper> (diffStep 7.5)\n\n#### [Step 7.5: Bind CPP utils to JS utils](https://github.com/DAB0mB/radial-snake/commit/0a67d50)\n\n##### Changed resources&#x2F;scripts&#x2F;utils.js\n```diff\n@@ -16,53 +16,9 @@\n â”Š16â”Š16â”Š  return chain;\n â”Š17â”Š17â”Š};\n â”Š18â”Š18â”Š\n-â”Š19â”Š  â”Š// Fixed modulo method which can calculate modulo of negative numbers properly\n-â”Š20â”Š  â”Š// e.g. (-803).mod(800) returns 797\n-â”Š21â”Š  â”ŠUtils.mod = function (context, num) {\n-â”Š22â”Š  â”Š  return ((context % num) + num) % num;\n-â”Š23â”Š  â”Š};\n-â”Š24â”Š  â”Š\n-â”Š25â”Š  â”Š// Trims number and leaves the number of decimals specified.\n-â”Š26â”Š  â”Š// The \"mode\" argument specifies which math function should be invoked\n-â”Š27â”Š  â”Š// right after the number has been trimmed.\n-â”Š28â”Š  â”Š// e.g. 12.12345.trim(3, \"ceil\") returns 12.124\n-â”Š29â”Š  â”ŠUtils.trim = function (context, decimals, mode = \"round\") {\n-â”Š30â”Š  â”Š  return Math[mode](context * Math.pow(10, decimals)) / Math.pow(10, decimals);\n-â”Š31â”Š  â”Š};\n-â”Š32â”Š  â”Š\n-â”Š33â”Š  â”Š// Tells if number is in specified range based on given precision.\n-â”Š34â”Š  â”Š// See the \"compare\" method for more information about precision\n-â”Š35â”Š  â”ŠUtils.isBetween = function (context, num1, num2, precision) {\n-â”Š36â”Š  â”Š  return Utils.compare(context, Math.min(num1, num2), \">=\", precision) &&\n-â”Š37â”Š  â”Š         Utils.compare(context, Math.max(num1, num2), \"<=\", precision);\n-â”Š38â”Š  â”Š};\n-â”Š39â”Š  â”Š\n-â”Š40â”Š  â”Š// Initiates comparison operator between context number and a given number, only here\n-â”Š41â”Š  â”Š// a precision can be specified\n-â”Š42â”Š  â”ŠUtils.compare = function (context, num, method, precision = method) {\n-â”Š43â”Š  â”Š  switch (precision) {\n-â”Š44â”Š  â”Š    // Fixed precision, \"almost equal\" with a deviation of Îµ\n-â”Š45â”Š  â”Š    case \"f\":\n-â”Š46â”Š  â”Š      switch (method) {\n-â”Š47â”Š  â”Š        case \"<\": case \"<=\": return context <= num + Number.EPSILON;\n-â”Š48â”Š  â”Š        case \">\": case \">=\": return context >= num - Number.EPSILON;\n-â”Š49â”Š  â”Š        default: return Math.abs(context - num) <= Number.EPSILON;\n-â”Š50â”Š  â”Š      }\n-â”Š51â”Š  â”Š    // Pixel precision, round comparison\n-â”Š52â”Š  â”Š    case \"px\":\n-â”Š53â”Š  â”Š      switch (method) {\n-â”Š54â”Š  â”Š        case \"<\": case \"<=\": return Math.round(context) <= Math.round(num);\n-â”Š55â”Š  â”Š        case \">\": case \">=\": return Math.round(context) >= Math.round(num);\n-â”Š56â”Š  â”Š        default: return Math.round(context) == Math.round(num);\n-â”Š57â”Š  â”Š      }\n-â”Š58â”Š  â”Š    // Exact precision\n-â”Š59â”Š  â”Š    default:\n-â”Š60â”Š  â”Š      switch (method) {\n-â”Š61â”Š  â”Š        case \"<\": return context < num;\n-â”Š62â”Š  â”Š        case \"<=\": return context <= num;\n-â”Š63â”Š  â”Š        case \">\": return context > num;\n-â”Š64â”Š  â”Š        case \">=\": return context >= num;\n-â”Š65â”Š  â”Š        default: return context === num;\n-â”Š66â”Š  â”Š      }\n+â”Š  â”Š19â”ŠObject.assign(Utils, CPP.Utils, {\n+â”Š  â”Š20â”Š  // Overload handling\n+â”Š  â”Š21â”Š  compare(context, num, method, precision = method) {\n+â”Š  â”Š22â”Š    return CPP.Utils.compare(context, num, method, precision);\n â”Š67â”Š23â”Š  }\n-â”Š68â”Š  â”Š};ðŸš«â†µ\n+â”Š  â”Š24â”Š});ðŸš«â†µ\n```\n\n[}]: #\n\nWhenever launching the compiler, the generated code should be outputted somewhere. I've decided to go with the path `resources/scripts/cpp.bundle.js`, but it doesn't matter how the file is gonna be called, as long as it's defined under the `scripts` dir, otherwise we won't be able to load it. Also, we need to make sure that we set a git-ignore rule for the generated file, since there's no reason for us to upload it to the git-host if we're planning on compiling it:\n\n[{]: <helper> (diffStep 7.5)\n\n#### [Step 7.5: Bind CPP utils to JS utils](https://github.com/DAB0mB/radial-snake/commit/0a67d50)\n\n##### Changed resources&#x2F;scripts&#x2F;utils.js\n```diff\n@@ -16,53 +16,9 @@\n â”Š16â”Š16â”Š  return chain;\n â”Š17â”Š17â”Š};\n â”Š18â”Š18â”Š\n-â”Š19â”Š  â”Š// Fixed modulo method which can calculate modulo of negative numbers properly\n-â”Š20â”Š  â”Š// e.g. (-803).mod(800) returns 797\n-â”Š21â”Š  â”ŠUtils.mod = function (context, num) {\n-â”Š22â”Š  â”Š  return ((context % num) + num) % num;\n-â”Š23â”Š  â”Š};\n-â”Š24â”Š  â”Š\n-â”Š25â”Š  â”Š// Trims number and leaves the number of decimals specified.\n-â”Š26â”Š  â”Š// The \"mode\" argument specifies which math function should be invoked\n-â”Š27â”Š  â”Š// right after the number has been trimmed.\n-â”Š28â”Š  â”Š// e.g. 12.12345.trim(3, \"ceil\") returns 12.124\n-â”Š29â”Š  â”ŠUtils.trim = function (context, decimals, mode = \"round\") {\n-â”Š30â”Š  â”Š  return Math[mode](context * Math.pow(10, decimals)) / Math.pow(10, decimals);\n-â”Š31â”Š  â”Š};\n-â”Š32â”Š  â”Š\n-â”Š33â”Š  â”Š// Tells if number is in specified range based on given precision.\n-â”Š34â”Š  â”Š// See the \"compare\" method for more information about precision\n-â”Š35â”Š  â”ŠUtils.isBetween = function (context, num1, num2, precision) {\n-â”Š36â”Š  â”Š  return Utils.compare(context, Math.min(num1, num2), \">=\", precision) &&\n-â”Š37â”Š  â”Š         Utils.compare(context, Math.max(num1, num2), \"<=\", precision);\n-â”Š38â”Š  â”Š};\n-â”Š39â”Š  â”Š\n-â”Š40â”Š  â”Š// Initiates comparison operator between context number and a given number, only here\n-â”Š41â”Š  â”Š// a precision can be specified\n-â”Š42â”Š  â”ŠUtils.compare = function (context, num, method, precision = method) {\n-â”Š43â”Š  â”Š  switch (precision) {\n-â”Š44â”Š  â”Š    // Fixed precision, \"almost equal\" with a deviation of Îµ\n-â”Š45â”Š  â”Š    case \"f\":\n-â”Š46â”Š  â”Š      switch (method) {\n-â”Š47â”Š  â”Š        case \"<\": case \"<=\": return context <= num + Number.EPSILON;\n-â”Š48â”Š  â”Š        case \">\": case \">=\": return context >= num - Number.EPSILON;\n-â”Š49â”Š  â”Š        default: return Math.abs(context - num) <= Number.EPSILON;\n-â”Š50â”Š  â”Š      }\n-â”Š51â”Š  â”Š    // Pixel precision, round comparison\n-â”Š52â”Š  â”Š    case \"px\":\n-â”Š53â”Š  â”Š      switch (method) {\n-â”Š54â”Š  â”Š        case \"<\": case \"<=\": return Math.round(context) <= Math.round(num);\n-â”Š55â”Š  â”Š        case \">\": case \">=\": return Math.round(context) >= Math.round(num);\n-â”Š56â”Š  â”Š        default: return Math.round(context) == Math.round(num);\n-â”Š57â”Š  â”Š      }\n-â”Š58â”Š  â”Š    // Exact precision\n-â”Š59â”Š  â”Š    default:\n-â”Š60â”Š  â”Š      switch (method) {\n-â”Š61â”Š  â”Š        case \"<\": return context < num;\n-â”Š62â”Š  â”Š        case \"<=\": return context <= num;\n-â”Š63â”Š  â”Š        case \">\": return context > num;\n-â”Š64â”Š  â”Š        case \">=\": return context >= num;\n-â”Š65â”Š  â”Š        default: return context === num;\n-â”Š66â”Š  â”Š      }\n+â”Š  â”Š19â”ŠObject.assign(Utils, CPP.Utils, {\n+â”Š  â”Š20â”Š  // Overload handling\n+â”Š  â”Š21â”Š  compare(context, num, method, precision = method) {\n+â”Š  â”Š22â”Š    return CPP.Utils.compare(context, num, method, precision);\n â”Š67â”Š23â”Š  }\n-â”Š68â”Š  â”Š};ðŸš«â†µ\n+â”Š  â”Š24â”Š});ðŸš«â†µ\n```\n\n[}]: #\n\nTo compile our C++ code and turn it into JavaScript, we'll need to run the following command:\n\n    $ emcc -O1 --pre-js resources/cpp/pre.js --post-js resources/cpp/post.js --bind -o resources/scripts/cpp.bundle.js resources/cpp/src/index.cpp\n\nHere's a detailed list with explanations regards the arguments vector we've just passed:\n\n- `-01` - Optimization level 1. The higher the index, the more optimized our code is gonna be, but less readable.\n- `--pre-js` - Specifies a JavaScript prefix for the compiled code.\n- `--post-js` - Specifies a JavaScript postfix for the compiled code.\n- `--bind` - Tells the compiler to use Embind\n- `-o` - The output path.\n\n> More informations regards Emscripten's CLI can be found [here](https://kripken.github.io/emscripten-site/docs/tools_reference/emcc.html).\n\nYou don't have to memorize the compilation command we've just typed, because we're gonna save it as an NPM script called `build:cpp`:\n\n[{]: <helper> (diffStep 7.6)\n\n#### [Step 7.6: Add ignore rule to CPP bundle](https://github.com/DAB0mB/radial-snake/commit/f4a75cf)\n\n##### Changed .gitignore\n```diff\n@@ -1,3 +1,4 @@\n â”Š1â”Š1â”Šnode_modules\n â”Š2â”Š2â”Šnpm-debug.log\n-â”Š3â”Š â”Šresources/assets/fonts/*.jsonðŸš«â†µ\n+â”Š â”Š3â”Šresources/assets/fonts/*.json\n+â”Š â”Š4â”Šresources/scripts/cpp.bundle.jsðŸš«â†µ\n```\n\n[}]: #\n\nNow if you'd like to compile the C++ code just run:\n\n    $ npm run build:cpp\n\nMoreover, the code should be compiled automatically any time you start the serer using the command:\n\n    $ npm run serve\n\nWe always have to be on the alert and run our tests against modules we've just translated from JavaScript to C++. This will guarantee that once we run the game we won't stumble upon any defect whatsoever. Before running the tests, be sure to import the C++ bundle in the HTML file's header:\n\n[{]: <helper> (diffStep 7.8)\n\n#### [Step 7.8: Load CPP bundle in spec runner](https://github.com/DAB0mB/radial-snake/commit/0d1bd08)\n\n##### Changed views&#x2F;spec_runner.html\n```diff\n@@ -16,6 +16,7 @@\n â”Š16â”Š16â”Š    <script type=\"text/javascript\" src=\"libs/underscore.js\"></script>\n â”Š17â”Š17â”Š\n â”Š18â”Š18â”Š    <!-- Scripts -->\n+â”Š  â”Š19â”Š    <script type=\"text/javascript\" src=\"scripts/cpp.bundle.js\"></script>\n â”Š19â”Š20â”Š    <script type=\"text/javascript\" src=\"scripts/utils.js\"></script>\n â”Š20â”Š21â”Š    <script type=\"text/javascript\" src=\"scripts/namespaces.js\"></script>\n â”Š21â”Š22â”Š    <script type=\"text/javascript\" src=\"scripts/engine/geometry/line.js\"></script>\n```\n\n[}]: #\n\nNow we can run the tests by running the following command:\n\n    $ npm run test\n\nAt this point **all our tests should pass**. If they don't, it means our newly created utility module is not working properly, and you will have to repeat the previous steps until you get it right.\n\nUp next, we gonna translate the geometry line class to C++. Since it's gonna be translated almost identically, we will have to make sure that all the necessary assets are gonna be available for our class before proceeding. The first thing we will have to do would be making sure that the utility functions are chainable directly from C++ as well. To do that, we will create a chain class which should return a new instance of it whenever we're about to chain the upcoming utility method. Once calling `result()`, the accumulator should be returned:\n\n[{]: <helper> (diffStep 7.9)\n\n#### [Step 7.9: Add chaining method to CPP utils](https://github.com/DAB0mB/radial-snake/commit/0927eea)\n\n##### Changed resources&#x2F;cpp&#x2F;src&#x2F;utils.cpp\n```diff\n@@ -5,6 +5,61 @@\n â”Š 5â”Š 5â”Š#include \"utils.h\"\n â”Š 6â”Š 6â”Š\n â”Š 7â”Š 7â”Šnamespace utils {\n+â”Š  â”Š 8â”Š  template<typename T>\n+â”Š  â”Š 9â”Š  Chain<T>::Chain(T accumulator): _accumulator(accumulator) {\n+â”Š  â”Š10â”Š  }\n+â”Š  â”Š11â”Š\n+â”Š  â”Š12â”Š  template<>\n+â”Š  â”Š13â”Š  Chain<double>* Chain<double>::mod(double num) {\n+â”Š  â”Š14â”Š    double result = utils::mod(_accumulator, num);\n+â”Š  â”Š15â”Š    Chain<double>* chain = new Chain<double>(result);\n+â”Š  â”Š16â”Š    delete this;\n+â”Š  â”Š17â”Š    return chain;\n+â”Š  â”Š18â”Š  }\n+â”Š  â”Š19â”Š\n+â”Š  â”Š20â”Š  template<>\n+â”Š  â”Š21â”Š  Chain<double>* Chain<double>::trim(int decimals, const std::string mode) {\n+â”Š  â”Š22â”Š    double result = utils::trim(_accumulator, decimals, mode);\n+â”Š  â”Š23â”Š    Chain<double>* chain = new Chain<double>(result);\n+â”Š  â”Š24â”Š    delete this;\n+â”Š  â”Š25â”Š    return chain;\n+â”Š  â”Š26â”Š  }\n+â”Š  â”Š27â”Š\n+â”Š  â”Š28â”Š  template<>\n+â”Š  â”Š29â”Š  Chain<bool>* Chain<double>::isBetween(double num1, double num2, const std::string precision) {\n+â”Š  â”Š30â”Š    bool result = utils::isBetween(_accumulator, num1, num2, precision);\n+â”Š  â”Š31â”Š    Chain<bool>* chain = new Chain<bool>(result);\n+â”Š  â”Š32â”Š    delete this;\n+â”Š  â”Š33â”Š    return chain;\n+â”Š  â”Š34â”Š  }\n+â”Š  â”Š35â”Š\n+â”Š  â”Š36â”Š  template<>\n+â”Š  â”Š37â”Š  Chain<bool>* Chain<double>::compare(double num, const std::string precision) {\n+â”Š  â”Š38â”Š    bool result = utils::compare(_accumulator, num, precision);\n+â”Š  â”Š39â”Š    Chain<bool>* chain = new Chain<bool>(result);\n+â”Š  â”Š40â”Š    delete this;\n+â”Š  â”Š41â”Š    return chain;\n+â”Š  â”Š42â”Š  }\n+â”Š  â”Š43â”Š\n+â”Š  â”Š44â”Š  template<>\n+â”Š  â”Š45â”Š  Chain<bool>* Chain<double>::compare(double num, const std::string method, const std::string precision) {\n+â”Š  â”Š46â”Š    bool result = utils::compare(_accumulator, num, method, precision);\n+â”Š  â”Š47â”Š    Chain<bool>* chain = new Chain<bool>(result);\n+â”Š  â”Š48â”Š    delete this;\n+â”Š  â”Š49â”Š    return chain;\n+â”Š  â”Š50â”Š  }\n+â”Š  â”Š51â”Š\n+â”Š  â”Š52â”Š  template<typename T>\n+â”Š  â”Š53â”Š  T Chain<T>::result() {\n+â”Š  â”Š54â”Š    delete this;\n+â”Š  â”Š55â”Š    return _accumulator;\n+â”Š  â”Š56â”Š  }\n+â”Š  â”Š57â”Š\n+â”Š  â”Š58â”Š  template<typename T>\n+â”Š  â”Š59â”Š  Chain<T>* chain(T accumulator) {\n+â”Š  â”Š60â”Š    return new Chain<T>(accumulator);\n+â”Š  â”Š61â”Š  }\n+â”Š  â”Š62â”Š\n â”Š 8â”Š63â”Š  // Fixed modulo method which can calculate modulo of negative numbers properly\n â”Š 9â”Š64â”Š  // e.g. (-803).mod(800) returns 797\n â”Š10â”Š65â”Š  double mod(double context, double num) {\n```\n\n##### Changed resources&#x2F;cpp&#x2F;src&#x2F;utils.h\n```diff\n@@ -3,6 +3,30 @@\n â”Š 3â”Š 3â”Š#include <string>\n â”Š 4â”Š 4â”Š\n â”Š 5â”Š 5â”Šnamespace utils {\n+â”Š  â”Š 6â”Š  template<typename T>\n+â”Š  â”Š 7â”Š  class Chain {\n+â”Š  â”Š 8â”Š  private:\n+â”Š  â”Š 9â”Š    T _accumulator;\n+â”Š  â”Š10â”Š\n+â”Š  â”Š11â”Š  public:\n+â”Š  â”Š12â”Š    Chain(T accumulator);\n+â”Š  â”Š13â”Š\n+â”Š  â”Š14â”Š    Chain<double>* mod(double num);\n+â”Š  â”Š15â”Š\n+â”Š  â”Š16â”Š    Chain<double>* trim(int decimals, const std::string mode = \"round\");\n+â”Š  â”Š17â”Š\n+â”Š  â”Š18â”Š    Chain<bool>* isBetween(double num1, double num2, const std::string precision = \"exact\");\n+â”Š  â”Š19â”Š\n+â”Š  â”Š20â”Š    Chain<bool>* compare(double num, const std::string precision = \"exact\");\n+â”Š  â”Š21â”Š\n+â”Š  â”Š22â”Š    Chain<bool>* compare(double num, const std::string method, const std::string precision);\n+â”Š  â”Š23â”Š\n+â”Š  â”Š24â”Š    T result();\n+â”Š  â”Š25â”Š  };\n+â”Š  â”Š26â”Š\n+â”Š  â”Š27â”Š  template<typename T>\n+â”Š  â”Š28â”Š  Chain<T>* chain(T accumulator);\n+â”Š  â”Š29â”Š\n â”Š 6â”Š30â”Š  double mod(double context, double num);\n â”Š 7â”Š31â”Š\n â”Š 8â”Š32â”Š  double trim(double context, int decimals, const std::string mode = \"round\");\n```\n\n[}]: #\n\n> Note that when coding in C++ we have to make sure that the objects are being disposed when not needed anymore, otherwise we will have some unnecessary memory leaks.\n\n2D shapes are presented in space using points with 2 values - `x` (axis) and `y` axis, therefore, we will create the appropriate point structure:\n\n[{]: <helper> (diffStep 7.1)\n\n#### [Step 7.1: Add CPP entry script](https://github.com/DAB0mB/radial-snake/commit/2f35323)\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;index.cpp\n```diff\n@@ -0,0 +1 @@\n+â”Š â”Š1â”Š#include \"utils.cpp\"ðŸš«â†µ\n```\n\n[}]: #\n\nReturned values can either be `null` (`undefined`) or not. Since there's no built in nullable-values mechanism in C++ (up until C++17), we're gonna create one of our own:\n\n[{]: <helper> (diffStep 7.11)\n\n#### [Step 7.11: Add nullable class](https://github.com/DAB0mB/radial-snake/commit/41b2f7c)\n\n##### Changed resources&#x2F;cpp&#x2F;src&#x2F;index.cpp\n```diff\n@@ -1 +1,2 @@\n+â”Š â”Š1â”Š#include \"nullable.cpp\"\n â”Š1â”Š2â”Š#include \"utils.cpp\"ðŸš«â†µ\n```\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;nullable.cpp\n```diff\n@@ -0,0 +1,37 @@\n+â”Š  â”Š 1â”Š#include \"nullable.h\"\n+â”Š  â”Š 2â”Š\n+â”Š  â”Š 3â”Štemplate <typename T>\n+â”Š  â”Š 4â”ŠNullable<T>::Nullable(T value): _value(value), _initialized(true) {\n+â”Š  â”Š 5â”Š\n+â”Š  â”Š 6â”Š}\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Štemplate <typename T>\n+â”Š  â”Š 9â”ŠNullable<T>::Nullable(): _initialized(false) {\n+â”Š  â”Š10â”Š\n+â”Š  â”Š11â”Š}\n+â”Š  â”Š12â”Š\n+â”Š  â”Š13â”Štemplate <typename T>\n+â”Š  â”Š14â”ŠT Nullable<T>::getValue() const {\n+â”Š  â”Š15â”Š  return _value;\n+â”Š  â”Š16â”Š}\n+â”Š  â”Š17â”Š\n+â”Š  â”Š18â”Štemplate <typename T>\n+â”Š  â”Š19â”Švoid Nullable<T>::setValue(T value) {\n+â”Š  â”Š20â”Š  _value = value;\n+â”Š  â”Š21â”Š  _initialized = true;\n+â”Š  â”Š22â”Š}\n+â”Š  â”Š23â”Š\n+â”Š  â”Š24â”Štemplate <typename T>\n+â”Š  â”Š25â”Švoid Nullable<T>::resetValue() {\n+â”Š  â”Š26â”Š  _initialized = false;\n+â”Š  â”Š27â”Š}\n+â”Š  â”Š28â”Š\n+â”Š  â”Š29â”Štemplate <typename T>\n+â”Š  â”Š30â”Šbool Nullable<T>::hasValue() const {\n+â”Š  â”Š31â”Š  return _initialized == true;\n+â”Š  â”Š32â”Š}\n+â”Š  â”Š33â”Š\n+â”Š  â”Š34â”Štemplate <typename T>\n+â”Š  â”Š35â”Šbool Nullable<T>::isNull() const {\n+â”Š  â”Š36â”Š  return _initialized == false;\n+â”Š  â”Š37â”Š}ðŸš«â†µ\n```\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;nullable.h\n```diff\n@@ -0,0 +1,23 @@\n+â”Š  â”Š 1â”Š#pragma once\n+â”Š  â”Š 2â”Š\n+â”Š  â”Š 3â”Štemplate <typename T>\n+â”Š  â”Š 4â”Šclass Nullable {\n+â”Š  â”Š 5â”Šprivate:\n+â”Š  â”Š 6â”Š  T _value;\n+â”Š  â”Š 7â”Š  bool _initialized;\n+â”Š  â”Š 8â”Š\n+â”Š  â”Š 9â”Špublic:\n+â”Š  â”Š10â”Š  Nullable(T value);\n+â”Š  â”Š11â”Š\n+â”Š  â”Š12â”Š  Nullable();\n+â”Š  â”Š13â”Š\n+â”Š  â”Š14â”Š  T getValue() const;\n+â”Š  â”Š15â”Š\n+â”Š  â”Š16â”Š  void setValue(T value);\n+â”Š  â”Š17â”Š\n+â”Š  â”Š18â”Š  void resetValue();\n+â”Š  â”Š19â”Š\n+â”Š  â”Š20â”Š  bool hasValue() const;\n+â”Š  â”Š21â”Š\n+â”Š  â”Š22â”Š  bool isNull() const;\n+â”Š  â”Š23â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nNow that all the necessary assets for the line class are ready, we can go ahead and create it:\n\n[{]: <helper> (diffStep 7.12)\n\n#### [Step 7.12: Add base line CPP module](https://github.com/DAB0mB/radial-snake/commit/9d17554)\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;geometry&#x2F;line.cpp\n```diff\n@@ -0,0 +1,99 @@\n+â”Š  â”Š 1â”Š#include \"../nullable.h\"\n+â”Š  â”Š 2â”Š#include \"../utils.h\"\n+â”Š  â”Š 3â”Š#include \"point.h\"\n+â”Š  â”Š 4â”Š#include \"line.h\"\n+â”Š  â”Š 5â”Š\n+â”Š  â”Š 6â”Šnamespace geometry {\n+â”Š  â”Š 7â”Š  // x1 - The first point's x value\n+â”Š  â”Š 8â”Š  // y1 - The first point's y value\n+â”Š  â”Š 9â”Š  // x1 - The second point's x value\n+â”Š  â”Š10â”Š  // y2 - The second point's y value\n+â”Š  â”Š11â”Š  Line::Line(double x1, double y1, double x2, double y2) {\n+â”Š  â”Š12â”Š    _x1 = utils::trim(x1, 9);\n+â”Š  â”Š13â”Š    _y1 = utils::trim(y1, 9);\n+â”Š  â”Š14â”Š    _x2 = utils::trim(x2, 9);\n+â”Š  â”Š15â”Š    _y2 = utils::trim(y2, 9);\n+â”Š  â”Š16â”Š  }\n+â”Š  â”Š17â”Š\n+â”Š  â”Š18â”Š  // Gets the matching x value for a given y value\n+â”Š  â”Š19â”Š  Nullable<double> Line::getMatchingX(double y) {\n+â”Š  â”Š20â”Š    // If an error was thrown it means we divided a number by zero,\n+â”Š  â”Š21â”Š    // in which case there is not intersection point\n+â”Š  â”Š22â”Š    double x = utils::trim(\n+â”Š  â”Š23â”Š      (((y - _y1) * (_x2 - _x1)) /\n+â”Š  â”Š24â”Š       (_y2 - _y1)) + _x1\n+â”Š  â”Š25â”Š    , 9, \"exact\");\n+â”Š  â”Š26â”Š\n+â”Š  â”Š27â”Š    // Check if result is in values range\n+â”Š  â”Š28â”Š    if (utils::isBetween(x, _x1, _x2, \"round\")) {\n+â”Š  â”Š29â”Š      return Nullable<double>(x);\n+â”Š  â”Š30â”Š    }\n+â”Š  â”Š31â”Š\n+â”Š  â”Š32â”Š    return Nullable<double>();\n+â”Š  â”Š33â”Š  }\n+â”Š  â”Š34â”Š\n+â”Š  â”Š35â”Š  // Gets the matching y value for a given x value\n+â”Š  â”Š36â”Š  Nullable<double> Line::getMatchingY(double x) {\n+â”Š  â”Š37â”Š    // If an error was thrown it means we divided a number by zero,\n+â”Š  â”Š38â”Š    // in which case there is not intersection point\n+â”Š  â”Š39â”Š    double y = utils::trim(\n+â”Š  â”Š40â”Š      (((x - _x1) * (_y2 - _y1)) /\n+â”Š  â”Š41â”Š       (_x2 - _x1)) + _y1\n+â”Š  â”Š42â”Š    , 9, \"exact\");\n+â”Š  â”Š43â”Š\n+â”Š  â”Š44â”Š    // Check if result is in values range\n+â”Š  â”Š45â”Š    if (utils::isBetween(y, _y1, _y2, \"round\")) {\n+â”Š  â”Š46â”Š      return Nullable<double>(y);\n+â”Š  â”Š47â”Š    }\n+â”Š  â”Š48â”Š\n+â”Š  â”Š49â”Š    return Nullable<double>();\n+â”Š  â”Š50â”Š  }\n+â”Š  â”Š51â”Š\n+â”Š  â”Š52â”Š  // Returns if line has given point\n+â”Š  â”Š53â”Š  bool Line::hasPoint(double x, double y) {\n+â”Š  â”Š54â”Š    if (!boundsHavePoint(x, y)) return 0;\n+â”Š  â”Š55â”Š\n+â”Š  â”Š56â”Š    double m = utils::trim(\n+â”Š  â”Š57â”Š      (_y2 - _y1) / (_x2 - _x1),\n+â”Š  â”Š58â”Š    9, \"exact\");\n+â”Š  â”Š59â”Š\n+â”Š  â”Š60â”Š    return (y - _y1) / (x - _x1) == m;\n+â”Š  â”Š61â”Š  }\n+â”Š  â”Š62â”Š\n+â”Š  â”Š63â”Š  // Returns if given point is contained by the bounds aka cage of line\n+â”Š  â”Š64â”Š  bool Line::boundsHavePoint(double x, double y) {\n+â”Š  â”Š65â”Š    return utils::isBetween(x, _x1, _x2, \"round\") &&\n+â”Š  â”Š66â”Š           utils::isBetween(y, _y1, _y2, \"round\");\n+â”Š  â”Š67â”Š  }\n+â”Š  â”Š68â”Š\n+â”Š  â”Š69â”Š  // line - line intersection method\n+â”Š  â”Š70â”Š  Nullable<Point> Line::getIntersection(Line line) {\n+â”Š  â”Š71â”Š    // Escape if lines are parallel\n+â”Š  â”Š72â”Š    if (!(((_x1 - _x2) * (line._y1 - line._y2)) -\n+â”Š  â”Š73â”Š          ((_y1 - _y2) * (line._x1 - line._x2))))\n+â”Š  â”Š74â”Š      return Nullable<Point>();\n+â”Š  â”Š75â”Š\n+â”Š  â”Š76â”Š    // Intersection point formula\n+â”Š  â”Š77â”Š    double x = utils::trim(\n+â”Š  â”Š78â”Š      ((((_x1 * _y2) - (_y1 * _x2)) * (line._x1 - line._x2)) -\n+â”Š  â”Š79â”Š       ((_x1 - _x2) * ((line._x1 * line._y2) - (line._y1 * line._x2)))) /\n+â”Š  â”Š80â”Š      (((_x1 - _x2) * (line._y1 - line._y2)) - ((_y1 - _y2) *\n+â”Š  â”Š81â”Š        (line._x1 - line._x2)))\n+â”Š  â”Š82â”Š    , 9, \"exact\");\n+â”Š  â”Š83â”Š    double y = utils::trim(\n+â”Š  â”Š84â”Š      ((((_x1 * _y2) - (_y1 * _x2)) * (line._y1 - line._y2)) -\n+â”Š  â”Š85â”Š       ((_y1 - _y2) * ((line._x1 * line._y2) - (line._y1 * line._x2)))) /\n+â”Š  â”Š86â”Š      (((_x1 - _x2) * (line._y1 - line._y2)) - ((_y1 - _y2) *\n+â”Š  â”Š87â”Š        (line._x1 - line._x2)))\n+â”Š  â”Š88â”Š    , 9, \"exact\");\n+â”Š  â”Š89â”Š\n+â”Š  â”Š90â”Š    if (utils::isBetween(x, _x1, _x2, \"round\") &&\n+â”Š  â”Š91â”Š        utils::isBetween(x, line._x1, line._x2, \"round\") &&\n+â”Š  â”Š92â”Š        utils::isBetween(y, _y1, _y2, \"round\") &&\n+â”Š  â”Š93â”Š        utils::isBetween(y, line._y1, line._y2, \"round\")) {\n+â”Š  â”Š94â”Š      return Nullable<Point>({ x, y });\n+â”Š  â”Š95â”Š    }\n+â”Š  â”Š96â”Š\n+â”Š  â”Š97â”Š    return Nullable<Point>();\n+â”Š  â”Š98â”Š  }\n+â”Š  â”Š99â”Š}ðŸš«â†µ\n```\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;geometry&#x2F;line.h\n```diff\n@@ -0,0 +1,30 @@\n+â”Š  â”Š 1â”Š#pragma once\n+â”Š  â”Š 2â”Š\n+â”Š  â”Š 3â”Š#include <vector>\n+â”Š  â”Š 4â”Š#include \"../nullable.h\"\n+â”Š  â”Š 5â”Š#include \"point.h\"\n+â”Š  â”Š 6â”Š\n+â”Š  â”Š 7â”Šnamespace geometry {\n+â”Š  â”Š 8â”Š  class Circle;\n+â”Š  â”Š 9â”Š  class EMCircle;\n+â”Š  â”Š10â”Š\n+â”Š  â”Š11â”Š  class Line {\n+â”Š  â”Š12â”Š  public:\n+â”Š  â”Š13â”Š    double _x1;\n+â”Š  â”Š14â”Š    double _y1;\n+â”Š  â”Š15â”Š    double _x2;\n+â”Š  â”Š16â”Š    double _y2;\n+â”Š  â”Š17â”Š\n+â”Š  â”Š18â”Š    Line(double x1, double y1, double x2, double y2);\n+â”Š  â”Š19â”Š\n+â”Š  â”Š20â”Š    Nullable<double> getMatchingX(double y);\n+â”Š  â”Š21â”Š\n+â”Š  â”Š22â”Š    Nullable<double> getMatchingY(double x);\n+â”Š  â”Š23â”Š\n+â”Š  â”Š24â”Š    bool hasPoint(double x, double y);\n+â”Š  â”Š25â”Š\n+â”Š  â”Š26â”Š    bool boundsHavePoint(double x, double y);\n+â”Š  â”Š27â”Š\n+â”Š  â”Š28â”Š    Nullable<Point> getIntersection(Line line);\n+â”Š  â”Š29â”Š  };\n+â”Š  â”Š30â”Š}ðŸš«â†µ\n```\n\n##### Changed resources&#x2F;cpp&#x2F;src&#x2F;index.cpp\n```diff\n@@ -1,2 +1,3 @@\n â”Š1â”Š1â”Š#include \"nullable.cpp\"\n-â”Š2â”Š â”Š#include \"utils.cpp\"ðŸš«â†µ\n+â”Š â”Š2â”Š#include \"utils.cpp\"\n+â”Š â”Š3â”Š#include \"geometry/line.cpp\"ðŸš«â†µ\n```\n\n[}]: #\n\nAfter creating our C++, we will also need to bind it using EMBind:\n\n[{]: <helper> (diffStep 7.13)\n\n#### [Step 7.13: EMBind CPP line](https://github.com/DAB0mB/radial-snake/commit/8920ddf)\n\n##### Changed resources&#x2F;cpp&#x2F;post.js\n```diff\n@@ -4,6 +4,10 @@\n â”Š 4â”Š 4â”Š    trim: Module.utils_trim,\n â”Š 5â”Š 5â”Š    isBetween: Module.utils_isBetween,\n â”Š 6â”Š 6â”Š    compare: Module.utils_compare\n+â”Š  â”Š 7â”Š  },\n+â”Š  â”Š 8â”Š\n+â”Š  â”Š 9â”Š  Geometry: {\n+â”Š  â”Š10â”Š    Line: Module.geometry_line\n â”Š 7â”Š11â”Š  }\n â”Š 8â”Š12â”Š};\n â”Š 9â”Š13â”Š\n```\n\n##### Changed resources&#x2F;cpp&#x2F;src&#x2F;geometry&#x2F;line.cpp\n```diff\n@@ -1,3 +1,6 @@\n+â”Š â”Š1â”Š#include <vector>\n+â”Š â”Š2â”Š#include <emscripten/bind.h>\n+â”Š â”Š3â”Š#include <emscripten/val.h>\n â”Š1â”Š4â”Š#include \"../nullable.h\"\n â”Š2â”Š5â”Š#include \"../utils.h\"\n â”Š3â”Š6â”Š#include \"point.h\"\n```\n```diff\n@@ -96,4 +99,52 @@\n â”Š 96â”Š 99â”Š\n â”Š 97â”Š100â”Š    return Nullable<Point>();\n â”Š 98â”Š101â”Š  }\n+â”Š   â”Š102â”Š\n+â”Š   â”Š103â”Š  emscripten::val EMLine::getMatchingX(double y) {\n+â”Š   â”Š104â”Š    Nullable<double> nullableX = Line::getMatchingX(y);\n+â”Š   â”Š105â”Š    return nullableX.hasValue() ?\n+â”Š   â”Š106â”Š      emscripten::val(nullableX.getValue()) :\n+â”Š   â”Š107â”Š      emscripten::val::undefined();\n+â”Š   â”Š108â”Š  }\n+â”Š   â”Š109â”Š\n+â”Š   â”Š110â”Š  emscripten::val EMLine::getMatchingY(double x) {\n+â”Š   â”Š111â”Š    Nullable<double> nullableY = Line::getMatchingY(x);\n+â”Š   â”Š112â”Š    return nullableY.hasValue() ?\n+â”Š   â”Š113â”Š      emscripten::val(nullableY.getValue()) :\n+â”Š   â”Š114â”Š      emscripten::val::undefined();\n+â”Š   â”Š115â”Š  }\n+â”Š   â”Š116â”Š\n+â”Š   â”Š117â”Š  emscripten::val EMLine::getIntersection(EMLine emLine) {\n+â”Š   â”Š118â”Š    Line line = Line(emLine._x1, emLine._y1, emLine._x2, emLine._y2);\n+â”Š   â”Š119â”Š    Nullable<Point> nullablePoint = Line::getIntersection(line);\n+â”Š   â”Š120â”Š\n+â”Š   â”Š121â”Š    if (nullablePoint.isNull()) return emscripten::val::undefined();\n+â”Š   â”Š122â”Š\n+â”Š   â”Š123â”Š    Point point = nullablePoint.getValue();\n+â”Š   â”Š124â”Š    emscripten::val emPoint = emscripten::val::object();\n+â”Š   â”Š125â”Š    emPoint.set(\"x\", emscripten::val(point.x));\n+â”Š   â”Š126â”Š    emPoint.set(\"y\", emscripten::val(point.y));\n+â”Š   â”Š127â”Š    return emPoint;\n+â”Š   â”Š128â”Š  }\n+â”Š   â”Š129â”Š}\n+â”Š   â”Š130â”Š\n+â”Š   â”Š131â”ŠEMSCRIPTEN_BINDINGS(geometry_line_module) {\n+â”Š   â”Š132â”Š  emscripten::class_<geometry::Line>(\"geometry_line_base\")\n+â”Š   â”Š133â”Š    .constructor<double, double, double, double>()\n+â”Š   â”Š134â”Š    .property<double>(\"x1\", &geometry::Line::_x1)\n+â”Š   â”Š135â”Š    .property<double>(\"y1\", &geometry::Line::_y1)\n+â”Š   â”Š136â”Š    .property<double>(\"x2\", &geometry::Line::_x2)\n+â”Š   â”Š137â”Š    .property<double>(\"y2\", &geometry::Line::_y2)\n+â”Š   â”Š138â”Š    .function(\"hasPoint\", &geometry::Line::hasPoint)\n+â”Š   â”Š139â”Š    .function(\"boundsHavePoint\", &geometry::Line::boundsHavePoint);\n+â”Š   â”Š140â”Š\n+â”Š   â”Š141â”Š  emscripten::class_<geometry::EMLine, emscripten::base<geometry::Line>>(\"geometry_line\")\n+â”Š   â”Š142â”Š    .constructor<double, double, double, double>()\n+â”Š   â”Š143â”Š    .function(\"getX\", &geometry::EMLine::getMatchingX)\n+â”Š   â”Š144â”Š    .function(\"getY\", &geometry::EMLine::getMatchingY)\n+â”Š   â”Š145â”Š    .function(\"getLineIntersection\",\n+â”Š   â”Š146â”Š      emscripten::select_overload<emscripten::val(geometry::EMLine)>(\n+â”Š   â”Š147â”Š        &geometry::EMLine::getIntersection\n+â”Š   â”Š148â”Š      )\n+â”Š   â”Š149â”Š    );\n â”Š 99â”Š150â”Š}ðŸš«â†µ\n```\n\n##### Changed resources&#x2F;cpp&#x2F;src&#x2F;geometry&#x2F;line.h\n```diff\n@@ -1,6 +1,7 @@\n â”Š1â”Š1â”Š#pragma once\n â”Š2â”Š2â”Š\n â”Š3â”Š3â”Š#include <vector>\n+â”Š â”Š4â”Š#include <emscripten/val.h>\n â”Š4â”Š5â”Š#include \"../nullable.h\"\n â”Š5â”Š6â”Š#include \"point.h\"\n â”Š6â”Š7â”Š\n```\n```diff\n@@ -27,4 +28,15 @@\n â”Š27â”Š28â”Š\n â”Š28â”Š29â”Š    Nullable<Point> getIntersection(Line line);\n â”Š29â”Š30â”Š  };\n+â”Š  â”Š31â”Š\n+â”Š  â”Š32â”Š  class EMLine : public Line {\n+â”Š  â”Š33â”Š  public:\n+â”Š  â”Š34â”Š    using Line::Line;\n+â”Š  â”Š35â”Š\n+â”Š  â”Š36â”Š    emscripten::val getMatchingX(double y);\n+â”Š  â”Š37â”Š\n+â”Š  â”Š38â”Š    emscripten::val getMatchingY(double x);\n+â”Š  â”Š39â”Š\n+â”Š  â”Š40â”Š    emscripten::val getIntersection(EMLine line);\n+â”Š  â”Š41â”Š  };\n â”Š30â”Š42â”Š}ðŸš«â†µ\n```\n\n[}]: #\n\nIn the code snippet above, you can see that we used a special data-type called `val` (`emscripten::val`). `val` means that just like JavaScript, that function can return values that are not necessarily of the same data-type; For instance, the `getMatchingY` function can either return a `number` or `undefined`. If you'll take a look at the `getIntersection(Line)` method you'll notice that instead of returning the raw point structure, I chose to build a JavaScript object using the `object` data type (`emscripten::object`). `object` behaves exactly like a native JavaScript `Object`, and it can save us some precious work of binding which sometimes might be just too much.\n\nIf you'll compare the C++ version of the line class to the JavaScript line class you'll notice that the `draw` and `getIntersection` methods are missing (when we used EMBind we renamed `getIntersection` to `getLineIntersection` because overloadings are forbidden). In addition, Emscripten's API exposes some additional class methods for generated C++ classes, like the `delete` method, which we will shed light on further in this tutorial. Inheritance would be the natural solution for such an issue, unfortunately, generated C++ constructors don't accept indirect instances. For example, if we have a C++ parent class called `Shape` and we have a JavaScript child class called `Line`, we won't be able to initialize a new instance of the `Line` class. Here's a demonstration:\n\n```js\nclass JSLine extends CPPShape {}\nconst line = new JSLine(); // Throws error\n```\n\nThere are 3 ways to implement inheritance when interacting with C++ classes:\n\n- Define an interface when using EMBind. This is the official way but rather complicated, since it requires us to define an extra layer for our wrapper. More information can be found [here](https://kripken.github.io/emscripten-site/docs/porting/connecting_cpp_and_javascript/embind.html#abstract-methods).\n- Extending the prototype of exported C++ classes directly, which is not really an inheritance.\n- Using a proxy class, which is the easiest and cleanest solution of all, but it is not really mentioned anywhere. At the same time, I didn't find any restriction regards that.\n\nWe're gonna use the 3rd method in the list above, because as I said, it's the easiest and cleanest of all. First I will try to explain what I meant by saying \"proxy class\". If you're an intermediate JavaScript developer, you probably know that constructors can be overridden by returning a value explicitly. By doing that, we can actually bypass Emscripten's prohibitions, we can just return the newly created C++ instance and extend it in specific. Proxy classes actually take it a step further by providing a middle-class which will then inject a new link to the prototype chain of the returned instance.\n\n```js\nclass JSLine {\n  constructor() {\n    const line = new CPPShape();\n    return line;\n  }\n}\n\nconst line = new JSLine(); // Legal!\n```\n\n> More information about the code snippet above can be found [here](https://www.bennadel.com/blog/2522-providing-a-return-value-in-a-javascript-constructor.htm).\n\nI believe that as we go through this tutorial, the concept will get much clearer. The utility function of the proxy class should look like so:\n\n[{]: <helper> (diffStep 7.14)\n\n#### [Step 7.14: Add proxy utility method](https://github.com/DAB0mB/radial-snake/commit/06e615e)\n\n##### Changed resources&#x2F;scripts&#x2F;utils.js\n```diff\n@@ -20,5 +20,18 @@\n â”Š20â”Š20â”Š  // Overload handling\n â”Š21â”Š21â”Š  compare(context, num, method, precision = method) {\n â”Š22â”Š22â”Š    return CPP.Utils.compare(context, num, method, precision);\n+â”Š  â”Š23â”Š  },\n+â”Š  â”Š24â”Š\n+â”Š  â”Š25â”Š  proxy(Class) {\n+â”Š  â”Š26â”Š    return class extends Class {\n+â”Š  â”Š27â”Š      constructor() {\n+â”Š  â”Š28â”Š        // Initialize original class\n+â”Š  â”Š29â”Š        let that = new Class(...arguments);\n+â”Š  â”Š30â”Š        // Inject caller's prototype into the prototype chain\n+â”Š  â”Š31â”Š        Object.setPrototypeOf(that, new.target.prototype);\n+â”Š  â”Š32â”Š        // Will original instance will be the substitute for 'this'\n+â”Š  â”Š33â”Š        return that;\n+â”Š  â”Š34â”Š      }\n+â”Š  â”Š35â”Š    }\n â”Š23â”Š36â”Š  }\n â”Š24â”Š37â”Š});ðŸš«â†µ\n```\n\n[}]: #\n\nIf you'll take a look at the following line:\n\n```js\nObject.setPrototypeOf(that, new.target.prototype);\n```\n\nThis is where the magic actually happens! It enables inheritance for explicitly returned objects; This way we can safely extend C++ classes. Accordingly, our new JavaScript line class should look like so:\n\n[{]: <helper> (diffStep 7.15)\n\n#### [Step 7.15: Extend CPP line class](https://github.com/DAB0mB/radial-snake/commit/66acf9d)\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;geometry&#x2F;line.js\n```diff\n@@ -1,46 +1,10 @@\n-â”Š 1â”Š  â”ŠEngine.Geometry.Line = class Line {\n-â”Š 2â”Š  â”Š  // x1 - The first point's x value\n-â”Š 3â”Š  â”Š  // y1 - The first point's y value\n-â”Š 4â”Š  â”Š  // x1 - The second point's x value\n-â”Š 5â”Š  â”Š  // y2 - The second point's y value\n-â”Š 6â”Š  â”Š  constructor(x1, y1, x2, y2) {\n-â”Š 7â”Š  â”Š    this.x1 = Utils.trim(x1, 9);\n-â”Š 8â”Š  â”Š    this.y1 = Utils.trim(y1, 9);\n-â”Š 9â”Š  â”Š    this.x2 = Utils.trim(x2, 9);\n-â”Š10â”Š  â”Š    this.y2 = Utils.trim(y2, 9);\n-â”Š11â”Š  â”Š  }\n-â”Š12â”Š  â”Š\n+â”Š  â”Š 1â”ŠEngine.Geometry.Line = class Line extends Utils.proxy(CPP.Geometry.Line) {\n â”Š13â”Š 2â”Š  // Draws the line on the given context\n â”Š14â”Š 3â”Š  draw(context) {\n â”Š15â”Š 4â”Š    context.moveTo(this.x1, this.y1);\n â”Š16â”Š 5â”Š    context.lineTo(this.x2, this.y2);\n â”Š17â”Š 6â”Š  }\n â”Š18â”Š 7â”Š\n-â”Š19â”Š  â”Š  // Gets the matching x value for a given y value\n-â”Š20â”Š  â”Š  getX(y) {\n-â”Š21â”Š  â”Š    let x = Utils.trim((((y - this.y1) * (this.x2 - this.x1)) / (this.y2 - this.y1)) + this.x1, 9);\n-â”Š22â”Š  â”Š    if (isNaN(x) || Utils.isBetween(x, this.x1, this.x2)) return x;\n-â”Š23â”Š  â”Š  }\n-â”Š24â”Š  â”Š\n-â”Š25â”Š  â”Š  // Gets the matching y value for a given x value\n-â”Š26â”Š  â”Š  getY(x) {\n-â”Š27â”Š  â”Š    let y = Utils.trim((((x - this.x1) * (this.y2 - this.y1)) / (this.x2 - this.x1)) + this.y1, 9);\n-â”Š28â”Š  â”Š    if (isNaN(y) || Utils.isBetween(y, this.y1, this.y2)) return y;\n-â”Š29â”Š  â”Š  }\n-â”Š30â”Š  â”Š\n-â”Š31â”Š  â”Š  // Returns if line has given point\n-â”Š32â”Š  â”Š  hasPoint(x, y) {\n-â”Š33â”Š  â”Š    if (!this.boundsHavePoint(x, y)) return false;\n-â”Š34â”Š  â”Š    let m = Utils.trim((this.y2 - this.y1) / (this.x2 - this.x1), 9);\n-â”Š35â”Š  â”Š    return (y - this.y1) / (x - this.x1) == m;\n-â”Š36â”Š  â”Š  }\n-â”Š37â”Š  â”Š\n-â”Š38â”Š  â”Š  // Returns if given point is contained by the bounds aka cage of line\n-â”Š39â”Š  â”Š  boundsHavePoint(x, y) {\n-â”Š40â”Š  â”Š    return Utils.isBetween(x, this.x1, this.x2) &&\n-â”Š41â”Š  â”Š           Utils.isBetween(y, this.y1, this.y2);\n-â”Š42â”Š  â”Š  }\n-â”Š43â”Š  â”Š\n â”Š44â”Š 8â”Š  getIntersection(shape) {\n â”Š45â”Š 9â”Š    if (shape instanceof Engine.Geometry.Line)\n â”Š46â”Š10â”Š      return this.getLineIntersection(shape);\n```\n```diff\n@@ -50,23 +14,6 @@\n â”Š50â”Š14â”Š      return this.getPolygonIntersection(shape);\n â”Š51â”Š15â”Š  }\n â”Š52â”Š16â”Š\n-â”Š53â”Š  â”Š  // line - line intersection method\n-â”Š54â”Š  â”Š  getLineIntersection(line) {\n-â”Š55â”Š  â”Š    // Escape if lines are parallel\n-â”Š56â”Š  â”Š    if (!(((this.x1 - this.x2) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * (line.x1 - line.x2)))) return;\n-â”Š57â”Š  â”Š\n-â”Š58â”Š  â”Š    // Intersection point formula\n-â”Š59â”Š  â”Š    let x = Utils.trim(((((this.x1 * this.y2) - (this.y1 * this.x2)) * (line.x1 - line.x2)) - ((this.x1 - this.x2) * ((line.x1 * line.y2) - (line.y1 * line.x2)))) /\n-â”Š60â”Š  â”Š        (((this.x1 - this.x2) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * (line.x1 - line.x2))), 9);\n-â”Š61â”Š  â”Š    let y = Utils.trim(((((this.x1 * this.y2) - (this.y1 * this.x2)) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * ((line.x1 * line.y2) - (line.y1 * line.x2)))) /\n-â”Š62â”Š  â”Š        (((this.x1 - this.x2) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * (line.x1 - line.x2))), 9);\n-â”Š63â”Š  â”Š\n-â”Š64â”Š  â”Š    if (Utils.isBetween(x, this.x1, this.x2) && Utils.isBetween(x, line.x1, line.x2) &&\n-â”Š65â”Š  â”Š        Utils.isBetween(y, this.y1, this.y2) && Utils.isBetween(y, line.y1, line.y2)) {\n-â”Š66â”Š  â”Š      return { x, y };\n-â”Š67â”Š  â”Š    }\n-â”Š68â”Š  â”Š  }\n-â”Š69â”Š  â”Š\n â”Š70â”Š17â”Š  // line - circle intersection method\n â”Š71â”Š18â”Š  getCircleIntersection(circle) {\n â”Š72â”Š19â”Š    return circle.getLineIntersection(this);\n```\n\n[}]: #\n\nBy now, our tests should pass. Accept, there is memory leak we need to handle. But you probably ask yourself - \"What memory leak? It's JavaScript man! Have you ever heard of something called garbage collector?!\". Well, this is not the case when compiling C++ code with Emscripten. You see, Emscripten uses asm.js, which is a subset for JavaScript built exactly for these proposes, enabling C++ modules run on the browser. This is how the [WebGL](https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API) project actually started, an almost complete conversion from the famous C++ [OpenGL](https://www.opengl.org/) to JavaScript. Part of what asm.js does, it disables the garbage collector, and instead, it holds raw pointers, just like in C++. Since returned class instances are pointers with unknown lifespans, they need to be disposed manually, using the `delete` method (identical to how we clear memory from the Heap in C++). Let's dispose unused test data by calling the `delete` method as just mentioned:\n\n[{]: <helper> (diffStep 7.16)\n\n#### [Step 7.16: Delete line instances in tests](https://github.com/DAB0mB/radial-snake/commit/f181da4)\n\n##### Changed resources&#x2F;scripts&#x2F;specs&#x2F;engine&#x2F;geometry&#x2F;circle.js\n```diff\n@@ -111,6 +111,8 @@\n â”Š111â”Š111â”Š          { x: 6, y: 1 },\n â”Š112â”Š112â”Š          { x: -4, y: 1 }\n â”Š113â”Š113â”Š        ]);\n+â”Š   â”Š114â”Š\n+â”Š   â”Š115â”Š        line.delete();\n â”Š114â”Š116â”Š      });\n â”Š115â”Š117â”Š    });\n â”Š116â”Š118â”Š\n```\n```diff\n@@ -121,6 +123,8 @@\n â”Š121â”Š123â”Š        expect(this.circle.getLineIntersection(line)).toEqual([\n â”Š122â”Š124â”Š          { x: -4, y: 1 }\n â”Š123â”Š125â”Š        ]);\n+â”Š   â”Š126â”Š\n+â”Š   â”Š127â”Š        line.delete();\n â”Š124â”Š128â”Š      });\n â”Š125â”Š129â”Š    });\n â”Š126â”Š130â”Š\n```\n```diff\n@@ -131,6 +135,8 @@\n â”Š131â”Š135â”Š        expect(this.circle.getLineIntersection(line)).toEqual([\n â”Š132â”Š136â”Š          { x: 1, y: 6 }\n â”Š133â”Š137â”Š        ]);\n+â”Š   â”Š138â”Š\n+â”Š   â”Š139â”Š        line.delete();\n â”Š134â”Š140â”Š      });\n â”Š135â”Š141â”Š    });\n â”Š136â”Š142â”Š\n```\n```diff\n@@ -138,6 +144,7 @@\n â”Š138â”Š144â”Š      it(\"returns nothing\", function() {\n â”Š139â”Š145â”Š        let line = new Engine.Geometry.Line(-10, 10, 10, 10);\n â”Š140â”Š146â”Š        expect(this.circle.getLineIntersection(line)).toBeUndefined();\n+â”Š   â”Š147â”Š        line.delete();\n â”Š141â”Š148â”Š      });\n â”Š142â”Š149â”Š    });\n â”Š143â”Š150â”Š  });\n```\n\n##### Changed resources&#x2F;scripts&#x2F;specs&#x2F;engine&#x2F;geometry&#x2F;line.js\n```diff\n@@ -3,6 +3,10 @@\n â”Š 3â”Š 3â”Š    this.line = new Engine.Geometry.Line(-5, -5, 5, 5);\n â”Š 4â”Š 4â”Š  });\n â”Š 5â”Š 5â”Š\n+â”Š  â”Š 6â”Š  afterEach(function () {\n+â”Š  â”Š 7â”Š    this.line.delete();\n+â”Š  â”Š 8â”Š  });\n+â”Š  â”Š 9â”Š\n â”Š 6â”Š10â”Š  describe(\"getX method\", function() {\n â”Š 7â”Š11â”Š    describe(\"given inranged y\", function() {\n â”Š 8â”Š12â”Š      it(\"returns x\", function() {\n```\n```diff\n@@ -58,6 +62,8 @@\n â”Š58â”Š62â”Š          x: 1,\n â”Š59â”Š63â”Š          y: 1\n â”Š60â”Š64â”Š        });\n+â”Š  â”Š65â”Š\n+â”Š  â”Š66â”Š        line.delete();\n â”Š61â”Š67â”Š      });\n â”Š62â”Š68â”Š    });\n â”Š63â”Š69â”Š\n```\n```diff\n@@ -65,6 +71,7 @@\n â”Š65â”Š71â”Š      it(\"returns nothing\", function() {\n â”Š66â”Š72â”Š        let line = new Engine.Geometry.Line(-5, -6, 5, 4);\n â”Š67â”Š73â”Š        expect(this.line.getLineIntersection(line)).toBeUndefined();\n+â”Š  â”Š74â”Š        line.delete();\n â”Š68â”Š75â”Š      });\n â”Š69â”Š76â”Š    });\n â”Š70â”Š77â”Š\n```\n```diff\n@@ -72,6 +79,7 @@\n â”Š72â”Š79â”Š      it(\"returns nothing\", function() {\n â”Š73â”Š80â”Š        let line = new Engine.Geometry.Line(10, 10, 10, 15);\n â”Š74â”Š81â”Š        expect(this.line.getLineIntersection(line)).toBeUndefined();\n+â”Š  â”Š82â”Š        line.delete();\n â”Š75â”Š83â”Š      });\n â”Š76â”Š84â”Š    });\n â”Š77â”Š85â”Š  });\n```\n\n##### Changed resources&#x2F;scripts&#x2F;specs&#x2F;engine&#x2F;geometry&#x2F;polygon.js\n```diff\n@@ -35,6 +35,8 @@\n â”Š35â”Š35â”Š          { x: 5, y: 4 },\n â”Š36â”Š36â”Š          { x: 0, y: 1 }\n â”Š37â”Š37â”Š        ]);\n+â”Š  â”Š38â”Š\n+â”Š  â”Š39â”Š        line.delete();\n â”Š38â”Š40â”Š      });\n â”Š39â”Š41â”Š    });\n â”Š40â”Š42â”Š\n```\n```diff\n@@ -43,6 +45,8 @@\n â”Š43â”Š45â”Š        let line = new Engine.Geometry.Line(10, 11, 15, 14);\n â”Š44â”Š46â”Š\n â”Š45â”Š47â”Š        expect(this.polygon.getLineIntersection(line)).toBeUndefined();\n+â”Š  â”Š48â”Š\n+â”Š  â”Š49â”Š        line.delete();\n â”Š46â”Š50â”Š      });\n â”Š47â”Š51â”Š    });\n â”Š48â”Š52â”Š  });\n```\n\n[}]: #\n\nSince our game also uses polygons, which is made of an abstract number of lines, its test-data needs to be disposed as well. First, we will add a `delete` method to the polygon class, which will simply go though all its bounds and delete each of its lines:\n\n[{]: <helper> (diffStep 7.17)\n\n#### [Step 7.17: Add polygon deletion method](https://github.com/DAB0mB/radial-snake/commit/1c9447f)\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;geometry&#x2F;polygon.js\n```diff\n@@ -5,6 +5,10 @@\n â”Š 5â”Š 5â”Š    this.bounds = bounds.map(coords => new Engine.Geometry.Line(...coords));\n â”Š 6â”Š 6â”Š  }\n â”Š 7â”Š 7â”Š\n+â”Š  â”Š 8â”Š  delete() {\n+â”Š  â”Š 9â”Š    this.bounds.forEach(bound => bound.delete());\n+â”Š  â”Š10â”Š  }\n+â”Š  â”Š11â”Š\n â”Š 8â”Š12â”Š  // Returns if polygon has given point\n â”Š 9â”Š13â”Š  hasPoint(x, y) {\n â”Š10â”Š14â”Š    // Run check for each bound\n```\n\n[}]: #\n\nNow we can conveniently delete unused polygons in the tests:\n\n[{]: <helper> (diffStep 7.18)\n\n#### [Step 7.18: Delete polygon instances in tests](https://github.com/DAB0mB/radial-snake/commit/48024bc)\n\n##### Changed resources&#x2F;scripts&#x2F;specs&#x2F;engine&#x2F;geometry&#x2F;polygon.js\n```diff\n@@ -8,6 +8,10 @@\n â”Š 8â”Š 8â”Š    );\n â”Š 9â”Š 9â”Š  });\n â”Š10â”Š10â”Š\n+â”Š  â”Š11â”Š  afterEach(function () {\n+â”Š  â”Š12â”Š    this.polygon.delete();\n+â”Š  â”Š13â”Š  });\n+â”Š  â”Š14â”Š\n â”Š11â”Š15â”Š  describe(\"hasPoint method\", function() {\n â”Š12â”Š16â”Š    describe(\"given contained point\", function() {\n â”Š13â”Š17â”Š      it(\"returns true\", function() {\n```\n\n[}]: #\n\nMoving on, we have the circle class to transform. The process is almost the identical to how we transformed the line class, so it's gonna be way easier now. We first start by translating our code from JavaScript to C++:\n\n[{]: <helper> (diffStep 7.19)\n\n#### [Step 7.19: Add base circle CPP module](https://github.com/DAB0mB/radial-snake/commit/1a3fa58)\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;geometry&#x2F;circle.cpp\n```diff\n@@ -0,0 +1,202 @@\n+â”Š   â”Š  1â”Š\n+â”Š   â”Š  2â”Š#include <algorithm>\n+â”Š   â”Š  3â”Š#include <cmath>\n+â”Š   â”Š  4â”Š#include <vector>\n+â”Š   â”Š  5â”Š#include \"../nullable.h\"\n+â”Š   â”Š  6â”Š#include \"../utils.h\"\n+â”Š   â”Š  7â”Š#include \"point.h\"\n+â”Š   â”Š  8â”Š#include \"line.h\"\n+â”Š   â”Š  9â”Š\n+â”Š   â”Š 10â”Šnamespace geometry {\n+â”Š   â”Š 11â”Š  // x - The x value of the circle's center\n+â”Š   â”Š 12â”Š  // y - The y value of the circle's center\n+â”Š   â”Š 13â”Š  // r - The radius of the center\n+â”Š   â”Š 14â”Š  // rad1 - The first radian of the circle, not necessarily its beginning\n+â”Š   â”Š 15â”Š  // rad2 - The second radian of the circle, not necessarily its beginning\n+â”Š   â”Š 16â”Š  Circle::Circle(double x, double y, double r, double rad1, double rad2) {\n+â”Š   â”Š 17â”Š    _x = utils::trim(x, 9);\n+â”Š   â”Š 18â”Š    _y = utils::trim(y, 9);\n+â”Š   â”Š 19â”Š    _r = utils::trim(r, 9);\n+â”Š   â”Š 20â”Š\n+â”Š   â”Š 21â”Š    // Trimming mode is done based on which radian represents the ending and which radian\n+â”Š   â”Š 22â”Š    // represents the ending\n+â”Š   â”Š 23â”Š    if (rad1 > rad2) {\n+â”Š   â”Š 24â”Š      _rad1 = utils::trim(rad1, 9, \"floor\");\n+â”Š   â”Š 25â”Š      _rad2 = utils::trim(rad2, 9, \"ceil\");\n+â”Š   â”Š 26â”Š    }\n+â”Š   â”Š 27â”Š    else {\n+â”Š   â”Š 28â”Š      _rad1 = utils::trim(rad1, 9, \"ceil\");\n+â”Š   â”Š 29â”Š      _rad2 = utils::trim(rad2, 9, \"floor\");\n+â”Š   â”Š 30â”Š    }\n+â”Š   â”Š 31â”Š  }\n+â”Š   â”Š 32â”Š\n+â”Š   â”Š 33â”Š  // Gets the matching x value for the given radian\n+â”Š   â”Š 34â”Š  Nullable<double> Circle::getMatchingX(double rad) {\n+â”Š   â”Š 35â”Š    if (!utils::chain(rad)->trim(9)->isBetween(_rad1, _rad2)->result()) {\n+â”Š   â”Š 36â”Š      return Nullable<double>();\n+â”Š   â”Š 37â”Š    }\n+â”Š   â”Š 38â”Š\n+â”Š   â”Š 39â”Š    return Nullable<double>(utils::trim((_r * std::cos(rad)) + _x, 9));\n+â”Š   â”Š 40â”Š  }\n+â”Š   â”Š 41â”Š\n+â”Š   â”Š 42â”Š  // Gets the matching y value for the given radian\n+â”Š   â”Š 43â”Š  Nullable<double> Circle::getMatchingY(double rad) {\n+â”Š   â”Š 44â”Š    if (!utils::chain(rad)->trim(9)->isBetween(_rad1, _rad2)->result()) {\n+â”Š   â”Š 45â”Š      return Nullable<double>();\n+â”Š   â”Š 46â”Š    }\n+â”Š   â”Š 47â”Š\n+â”Š   â”Š 48â”Š    return Nullable<double>(utils::trim((_r * std::sin(rad)) + _y, 9));\n+â”Š   â”Š 49â”Š  }\n+â”Š   â”Š 50â”Š\n+â”Š   â”Š 51â”Š  // Gets the matching point for the given radian\n+â”Š   â”Š 52â”Š  Nullable<Point> Circle::getMatchingPoint(double rad) {\n+â”Š   â”Š 53â”Š    if (!utils::isBetween(rad, _rad1, _rad2)) {\n+â”Š   â”Š 54â”Š      return Nullable<Point>();\n+â”Š   â”Š 55â”Š    }\n+â”Š   â”Š 56â”Š\n+â”Š   â”Š 57â”Š    return Nullable<Point>({\n+â”Š   â”Š 58â”Š      utils::trim((_r * std::cos(rad)) + _x, 9),\n+â”Š   â”Š 59â”Š      utils::trim((_r * std::sin(rad)) + _y, 9)\n+â”Š   â”Š 60â”Š    });\n+â”Š   â”Š 61â”Š  }\n+â”Š   â”Š 62â”Š\n+â”Š   â”Š 63â”Š  // Gets the matching radian for the given point\n+â”Š   â”Š 64â”Š  Nullable<double> Circle::getMatchingRad(double x, double y) {\n+â”Š   â”Š 65â”Š    double rad = std::atan2(y - _y, x - _x);\n+â”Š   â”Š 66â”Š\n+â”Š   â”Š 67â”Š    // If calculated radian is in circle's radian range, return it\n+â”Š   â”Š 68â”Š    if (!std::isnan(rad) && utils::isBetween(rad, _rad1, _rad2)) {\n+â”Š   â”Š 69â”Š      return Nullable<double>(rad);\n+â”Š   â”Š 70â”Š    }\n+â”Š   â”Š 71â”Š\n+â”Š   â”Š 72â”Š    // The calculated radian can still be in the circle's radian range in case one\n+â”Š   â”Š 73â”Š    // of the radians is greater than 2 PIEs\n+â”Š   â”Š 74â”Š    double greatestRad = std::abs(_rad1) > std::abs(_rad2) ? _rad1 : _rad2;\n+â”Š   â”Š 75â”Š\n+â”Š   â”Š 76â”Š    // Check if the absolute radian is in the circle's radian range\n+â”Š   â”Š 77â”Š    if (utils::chain(rad + (2 * M_PI * std::floor(greatestRad / (2 * M_PI))))\n+â”Š   â”Š 78â”Š        ->trim(9)->isBetween(_rad1, _rad2)->result() ||\n+â”Š   â”Š 79â”Š        utils::chain(rad + (2 * M_PI * std::ceil(greatestRad / (2 * M_PI))))\n+â”Š   â”Š 80â”Š        ->trim(9)->isBetween(_rad1, _rad2)->result()) {\n+â”Š   â”Š 81â”Š      return Nullable<double>(rad);\n+â”Š   â”Š 82â”Š    }\n+â”Š   â”Š 83â”Š\n+â”Š   â”Š 84â”Š    return Nullable<double>();\n+â”Š   â”Š 85â”Š  }\n+â”Š   â”Š 86â”Š\n+â”Š   â”Š 87â”Š  // Returns if circle has given points\n+â”Š   â”Š 88â”Š  bool Circle::hasPoint(double x, double y) {\n+â”Š   â”Š 89â”Š    return getMatchingRad(x, y).hasValue();\n+â”Š   â”Š 90â”Š  }\n+â”Š   â”Š 91â”Š\n+â”Š   â”Š 92â”Š  // circle - circle intersection method\n+â”Š   â”Š 93â”Š  Nullable<std::vector<Point>> Circle::getIntersection(Circle circle) {\n+â”Š   â”Š 94â”Š    double dx = circle._x - _x;\n+â”Š   â”Š 95â”Š    double dy = circle._y - _y;\n+â”Š   â”Š 96â”Š    double d = std::sqrt(std::pow(dx, 2) + std::pow(dy, 2));\n+â”Š   â”Š 97â”Š\n+â”Š   â”Š 98â”Š    if (d > _r + circle._r ||\n+â”Š   â”Š 99â”Š       d < std::abs(_r - circle._r)) {\n+â”Š   â”Š100â”Š      return Nullable<std::vector<Point>>();\n+â”Š   â”Š101â”Š    }\n+â”Š   â”Š102â”Š\n+â”Š   â”Š103â”Š    double a = ((std::pow(_r, 2) - std::pow(circle._r, 2)) + std::pow(d, 2)) / (2 * d);\n+â”Š   â”Š104â”Š    double x = _x + ((dx * a) / d);\n+â”Š   â”Š105â”Š    double y = _y + ((dy * a) / d);\n+â”Š   â”Š106â”Š    double h = std::sqrt(std::pow(_r, 2) - std::pow(a, 2));\n+â”Š   â”Š107â”Š    double rx = (- dy * h) / d;\n+â”Š   â”Š108â”Š    double ry = (dx * h) / d;\n+â”Š   â”Š109â”Š\n+â”Š   â”Š110â”Š    std::vector<Point> interPoints(2);\n+â”Š   â”Š111â”Š    interPoints.at(0).x = x + rx;\n+â”Š   â”Š112â”Š    interPoints.at(0).y = y + ry;\n+â”Š   â”Š113â”Š    interPoints.at(1).x = x - rx;\n+â”Š   â”Š114â”Š    interPoints.at(1).y = y - ry;\n+â”Š   â”Š115â”Š\n+â”Š   â”Š116â”Š    for (unsigned i = 0; i < interPoints.size(); i++) {\n+â”Š   â”Š117â”Š      Point& point = interPoints.at(i);\n+â”Š   â”Š118â”Š      point.x = utils::trim(point.x, 9);\n+â”Š   â”Š119â”Š      point.y = utils::trim(point.y, 9);\n+â”Š   â”Š120â”Š    }\n+â”Š   â”Š121â”Š\n+â”Š   â”Š122â”Š    auto pointsBegin = std::unique(interPoints.begin(), interPoints.end(),\n+â”Š   â”Š123â”Š      [](Point pointA, Point pointB) {\n+â”Š   â”Š124â”Š        return pointA.x == pointB.x && pointA.y == pointB.y;\n+â”Š   â”Š125â”Š      }\n+â”Š   â”Š126â”Š    );\n+â”Š   â”Š127â”Š\n+â”Š   â”Š128â”Š    interPoints.erase(pointsBegin, interPoints.end());\n+â”Š   â”Š129â”Š\n+â”Š   â”Š130â”Š    std::vector<Circle> circles = { *this, circle };\n+â”Š   â”Š131â”Š\n+â”Š   â”Š132â”Š    std::for_each(circles.begin(), circles.end(), [&interPoints](Circle circle) {\n+â”Š   â”Š133â”Š      auto pointsBegin = std::remove_if(interPoints.begin(), interPoints.end(),\n+â”Š   â”Š134â”Š        [&circle](Point point) {\n+â”Š   â”Š135â”Š          return !circle.hasPoint(point.x, point.y);\n+â”Š   â”Š136â”Š        }\n+â”Š   â”Š137â”Š      );\n+â”Š   â”Š138â”Š\n+â”Š   â”Š139â”Š      interPoints.erase(pointsBegin, interPoints.end());\n+â”Š   â”Š140â”Š    });\n+â”Š   â”Š141â”Š\n+â”Š   â”Š142â”Š    if (interPoints.size()) {\n+â”Š   â”Š143â”Š      return Nullable<std::vector<Point>>(interPoints);\n+â”Š   â”Š144â”Š    }\n+â”Š   â”Š145â”Š\n+â”Š   â”Š146â”Š    return Nullable<std::vector<Point>>();\n+â”Š   â”Š147â”Š  }\n+â”Š   â”Š148â”Š\n+â”Š   â”Š149â”Š  // circle - line intersection method\n+â”Š   â”Š150â”Š  Nullable<std::vector<Point>> Circle::getIntersection(Line line) {\n+â”Š   â”Š151â”Š    double x1 = line._x1 - _x;\n+â”Š   â”Š152â”Š    double x2 = line._x2 - _x;\n+â”Š   â”Š153â”Š    double y1 = line._y1 - _y;\n+â”Š   â”Š154â”Š    double y2 = line._y2 - _y;\n+â”Š   â”Š155â”Š    double dx = x2 - x1;\n+â”Š   â”Š156â”Š    double dy = y2 - y1;\n+â”Š   â”Š157â”Š    double d = std::sqrt(std::pow(dx, 2) + std::pow(dy, 2));\n+â”Š   â”Š158â”Š    double h = (x1 * y2) - (x2 * y1);\n+â”Š   â”Š159â”Š    double delta = (std::pow(_r, 2) * std::pow(d, 2)) - std::pow(h, 2);\n+â”Š   â”Š160â”Š\n+â”Š   â”Š161â”Š    if (delta < 0) Nullable<std::vector<Point>>();\n+â”Š   â”Š162â”Š\n+â”Š   â”Š163â”Š    double sign = dy / std::abs(dy); if (std::isnan(sign)) sign = 1;\n+â”Š   â”Š164â”Š    double sqrtx = sign * dx * std::sqrt(delta);\n+â”Š   â”Š165â”Š    double sqrty = std::abs(dy) * std::sqrt(delta);\n+â”Š   â”Š166â”Š\n+â”Š   â”Š167â”Š    std::vector<Point> interPoints(2);\n+â”Š   â”Š168â”Š    interPoints.at(0).x = (((h * dy) + sqrtx) / std::pow(d, 2)) + _x;\n+â”Š   â”Š169â”Š    interPoints.at(0).y = (((-h * dx) + sqrty) / std::pow(d, 2)) + _y;\n+â”Š   â”Š170â”Š    interPoints.at(1).x = (((h * dy) - sqrtx) / std::pow(d, 2)) + _x;\n+â”Š   â”Š171â”Š    interPoints.at(1).y = (((-h * dx) - sqrty) / std::pow(d, 2)) + _y;\n+â”Š   â”Š172â”Š\n+â”Š   â”Š173â”Š    for (unsigned i = 0; i < interPoints.size(); i++) {\n+â”Š   â”Š174â”Š      Point& point = interPoints.at(i);\n+â”Š   â”Š175â”Š      point.x = utils::trim(point.x, 9);\n+â”Š   â”Š176â”Š      point.y = utils::trim(point.y, 9);\n+â”Š   â”Š177â”Š    }\n+â”Š   â”Š178â”Š\n+â”Š   â”Š179â”Š    auto pointsBegin = std::remove_if(interPoints.begin(), interPoints.end(),\n+â”Š   â”Š180â”Š      [this, &line](Point point) {\n+â”Š   â”Š181â”Š        return !hasPoint(point.x, point.y) ||\n+â”Š   â”Š182â”Š          !line.boundsHavePoint(point.x, point.y);\n+â”Š   â”Š183â”Š      }\n+â”Š   â”Š184â”Š    );\n+â”Š   â”Š185â”Š\n+â”Š   â”Š186â”Š    interPoints.erase(pointsBegin, interPoints.end());\n+â”Š   â”Š187â”Š\n+â”Š   â”Š188â”Š    pointsBegin = std::unique(interPoints.begin(), interPoints.end(),\n+â”Š   â”Š189â”Š      [](Point pointA, Point pointB) {\n+â”Š   â”Š190â”Š        return pointA.x == pointB.x && pointA.y == pointB.y;\n+â”Š   â”Š191â”Š      }\n+â”Š   â”Š192â”Š    );\n+â”Š   â”Š193â”Š\n+â”Š   â”Š194â”Š    interPoints.erase(pointsBegin, interPoints.end());\n+â”Š   â”Š195â”Š\n+â”Š   â”Š196â”Š    if (interPoints.size()) {\n+â”Š   â”Š197â”Š      return Nullable<std::vector<Point>>(interPoints);\n+â”Š   â”Š198â”Š    }\n+â”Š   â”Š199â”Š\n+â”Š   â”Š200â”Š    return Nullable<std::vector<Point>>();\n+â”Š   â”Š201â”Š  }\n+â”Š   â”Š202â”Š}ðŸš«â†µ\n```\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;geometry&#x2F;circle.h\n```diff\n@@ -0,0 +1,35 @@\n+â”Š  â”Š 1â”Š#pragma once\n+â”Š  â”Š 2â”Š\n+â”Š  â”Š 3â”Š#include <vector>\n+â”Š  â”Š 4â”Š#include \"../nullable.h\"\n+â”Š  â”Š 5â”Š#include \"point.h\"\n+â”Š  â”Š 6â”Š#include \"line.h\"\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Šnamespace geometry {\n+â”Š  â”Š 9â”Š  class Line;\n+â”Š  â”Š10â”Š\n+â”Š  â”Š11â”Š  class Circle {\n+â”Š  â”Š12â”Š  public:\n+â”Š  â”Š13â”Š    double _x;\n+â”Š  â”Š14â”Š    double _y;\n+â”Š  â”Š15â”Š    double _r;\n+â”Š  â”Š16â”Š    double _rad1;\n+â”Š  â”Š17â”Š    double _rad2;\n+â”Š  â”Š18â”Š\n+â”Š  â”Š19â”Š    Circle(double x, double y, double r, double rad1, double rad2);\n+â”Š  â”Š20â”Š\n+â”Š  â”Š21â”Š    Nullable<double> getMatchingX(double rad);\n+â”Š  â”Š22â”Š\n+â”Š  â”Š23â”Š    Nullable<double> getMatchingY(double rad);\n+â”Š  â”Š24â”Š\n+â”Š  â”Š25â”Š    Nullable<Point> getMatchingPoint(double rad);\n+â”Š  â”Š26â”Š\n+â”Š  â”Š27â”Š    Nullable<double> getMatchingRad(double x, double y);\n+â”Š  â”Š28â”Š\n+â”Š  â”Š29â”Š    bool hasPoint(double x, double y);\n+â”Š  â”Š30â”Š\n+â”Š  â”Š31â”Š    Nullable<std::vector<Point>> getIntersection(Circle circle);\n+â”Š  â”Š32â”Š\n+â”Š  â”Š33â”Š    Nullable<std::vector<Point>> getIntersection(Line line);\n+â”Š  â”Š34â”Š  };\n+â”Š  â”Š35â”Š}ðŸš«â†µ\n```\n\n##### Changed resources&#x2F;cpp&#x2F;src&#x2F;index.cpp\n```diff\n@@ -1,3 +1,4 @@\n â”Š1â”Š1â”Š#include \"nullable.cpp\"\n â”Š2â”Š2â”Š#include \"utils.cpp\"\n-â”Š3â”Š â”Š#include \"geometry/line.cpp\"ðŸš«â†µ\n+â”Š â”Š3â”Š#include \"geometry/line.cpp\"\n+â”Š â”Š4â”Š#include \"geometry/circle.cpp\"ðŸš«â†µ\n```\n\n[}]: #\n\nSecond, we need to wrap our code using EMBind:\n\n[{]: <helper> (diffStep 7.2)\n\n#### [Step 7.2: Add base utility CPP module](https://github.com/DAB0mB/radial-snake/commit/6dba512)\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;utils.cpp\n```diff\n@@ -0,0 +1,73 @@\n+â”Š  â”Š 1â”Š#include <cfloat>\n+â”Š  â”Š 2â”Š#include <cmath>\n+â”Š  â”Š 3â”Š#include <string>\n+â”Š  â”Š 4â”Š#include \"utils.h\"\n+â”Š  â”Š 5â”Š\n+â”Š  â”Š 6â”Šnamespace utils {\n+â”Š  â”Š 7â”Š  // Fixed modulo method which can calculate modulo of negative numbers properly\n+â”Š  â”Š 8â”Š  // e.g. (-803).mod(800) returns 797\n+â”Š  â”Š 9â”Š  double mod(double context, double num) {\n+â”Š  â”Š10â”Š    return std::fmod((std::fmod(context, num) + num), num);\n+â”Š  â”Š11â”Š  }\n+â”Š  â”Š12â”Š\n+â”Š  â”Š13â”Š  // Trims number and leaves the number of decimals specified.\n+â”Š  â”Š14â”Š  // The \"mode\" argument specifies which math function should be invoked\n+â”Š  â”Š15â”Š  // right after the number has been trimmed.\n+â”Š  â”Š16â”Š  // e.g. 12.12345.trim(3, \"ceil\") returns 12.124\n+â”Š  â”Š17â”Š  double trim(double context, int decimals, const std::string mode) {\n+â”Š  â”Š18â”Š    double accumulator = context * std::pow(10, decimals);\n+â”Š  â”Š19â”Š\n+â”Š  â”Š20â”Š    if (mode.compare(\"ceil\") == 0)\n+â”Š  â”Š21â”Š      accumulator = std::ceil(accumulator);\n+â”Š  â”Š22â”Š    else if (mode.compare(\"floor\") == 0)\n+â”Š  â”Š23â”Š      accumulator = std::floor(accumulator);\n+â”Š  â”Š24â”Š    else\n+â”Š  â”Š25â”Š      accumulator = std::round(accumulator);\n+â”Š  â”Š26â”Š\n+â”Š  â”Š27â”Š    return accumulator / std::pow(10, decimals);\n+â”Š  â”Š28â”Š  }\n+â”Š  â”Š29â”Š\n+â”Š  â”Š30â”Š  // Tells if number is in specified range based on given precision.\n+â”Š  â”Š31â”Š  // See the \"compare\" method for more information about precision\n+â”Š  â”Š32â”Š  bool isBetween(double context, double num1, double num2, const std::string precision) {\n+â”Š  â”Š33â”Š    return compare(context, std::min(num1, num2), \">=\", precision) &&\n+â”Š  â”Š34â”Š           compare(context, std::max(num1, num2), \"<=\", precision);\n+â”Š  â”Š35â”Š  }\n+â”Š  â”Š36â”Š\n+â”Š  â”Š37â”Š  bool compare(double context, double num, const std::string precision) {\n+â”Š  â”Š38â”Š    return compare(context, num, \"==\", precision);\n+â”Š  â”Š39â”Š  }\n+â”Š  â”Š40â”Š\n+â”Š  â”Š41â”Š  // Initiates comparison operator between context number and a given number, only here\n+â”Š  â”Š42â”Š  // a precision can be specified\n+â”Š  â”Š43â”Š  bool compare(double context, double num, const std::string method, const std::string precision) {\n+â”Š  â”Š44â”Š    // Fixed precision, \"almost equal\" with a deviation of Îµ\n+â”Š  â”Š45â”Š    if (precision.compare(\"f\") == 0) {\n+â”Š  â”Š46â”Š      if (method.compare(\"<\") == 0 ||\n+â”Š  â”Š47â”Š          method.compare(\"<=\") == 0)\n+â”Š  â”Š48â”Š        return context <= num + DBL_EPSILON;\n+â”Š  â”Š49â”Š      if (method.compare(\">\") == 0 ||\n+â”Š  â”Š50â”Š          method.compare(\">=\") == 0)\n+â”Š  â”Š51â”Š        return context >= num - DBL_EPSILON;\n+â”Š  â”Š52â”Š      return std::abs(context - num) <= DBL_EPSILON;\n+â”Š  â”Š53â”Š    }\n+â”Š  â”Š54â”Š    // Pixel precision, round comparison\n+â”Š  â”Š55â”Š    else if (precision.compare(\"px\") == 0) {\n+â”Š  â”Š56â”Š      if (method.compare(\"<\") == 0 ||\n+â”Š  â”Š57â”Š          method.compare(\"<=\") == 0)\n+â”Š  â”Š58â”Š        return std::round(context) <= std::round(num);\n+â”Š  â”Š59â”Š      if (method.compare(\">\") == 0 ||\n+â”Š  â”Š60â”Š          method.compare(\">=\") == 0)\n+â”Š  â”Š61â”Š        return std::round(context) >= std::round(num);\n+â”Š  â”Š62â”Š      return std::round(context) == std::round(num);\n+â”Š  â”Š63â”Š    }\n+â”Š  â”Š64â”Š    // Exact precision\n+â”Š  â”Š65â”Š    else {\n+â”Š  â”Š66â”Š      if (method.compare(\"<\") == 0) return context < num;\n+â”Š  â”Š67â”Š      if (method.compare(\"<=\") == 0) return context <= num;\n+â”Š  â”Š68â”Š      if (method.compare(\">\") == 0) return context > num;\n+â”Š  â”Š69â”Š      if (method.compare(\">=\") == 0) return context >= num;\n+â”Š  â”Š70â”Š      return context == num;\n+â”Š  â”Š71â”Š    }\n+â”Š  â”Š72â”Š  }\n+â”Š  â”Š73â”Š}ðŸš«â†µ\n```\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;utils.h\n```diff\n@@ -0,0 +1,15 @@\n+â”Š  â”Š 1â”Š#pragma once\n+â”Š  â”Š 2â”Š\n+â”Š  â”Š 3â”Š#include <string>\n+â”Š  â”Š 4â”Š\n+â”Š  â”Š 5â”Šnamespace utils {\n+â”Š  â”Š 6â”Š  double mod(double context, double num);\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Š  double trim(double context, int decimals, const std::string mode = \"round\");\n+â”Š  â”Š 9â”Š\n+â”Š  â”Š10â”Š  bool isBetween(double context, double num1, double num2, const std::string precision = \"exact\");\n+â”Š  â”Š11â”Š\n+â”Š  â”Š12â”Š  bool compare(double context, double num, const std::string precision = \"exact\");\n+â”Š  â”Š13â”Š\n+â”Š  â”Š14â”Š  bool compare(double context, double num, const std::string method, const std::string precision);\n+â”Š  â”Š15â”Š}ðŸš«â†µ\n```\n\n[}]: #\n\nAnd finally, we will extend the C++ in our JavaScript circle:\n\n[{]: <helper> (diffStep 7.21)\n\n#### [Step 7.21: Extend CPP circle class](https://github.com/DAB0mB/radial-snake/commit/d05cf32)\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;geometry&#x2F;circle.js\n```diff\n@@ -1,83 +1,9 @@\n-â”Š 1â”Š  â”ŠEngine.Geometry.Circle = class Circle {\n-â”Š 2â”Š  â”Š  // x - The x value of the circle's center\n-â”Š 3â”Š  â”Š  // y - The y value of the circle's center\n-â”Š 4â”Š  â”Š  // r - The radius of the center\n-â”Š 5â”Š  â”Š  // rad1 - The first radian of the circle, not necessarily its beginning\n-â”Š 6â”Š  â”Š  // rad2 - The second radian of the circle, not necessarily its beginning\n-â”Š 7â”Š  â”Š  constructor(x, y, r, rad1, rad2) {\n-â”Š 8â”Š  â”Š    this.x = Utils.trim(x, 9);\n-â”Š 9â”Š  â”Š    this.y = Utils.trim(y, 9);\n-â”Š10â”Š  â”Š    this.r = Utils.trim(r, 9);\n-â”Š11â”Š  â”Š\n-â”Š12â”Š  â”Š    // Trimming mode is done based on which radian represents the ending and which radian\n-â”Š13â”Š  â”Š    // represents the ending\n-â”Š14â”Š  â”Š    if (rad1 > rad2) {\n-â”Š15â”Š  â”Š      this.rad1 = Utils.trim(rad1, 9, \"floor\");\n-â”Š16â”Š  â”Š      this.rad2 = Utils.trim(rad2, 9, \"ceil\");\n-â”Š17â”Š  â”Š    }\n-â”Š18â”Š  â”Š    else {\n-â”Š19â”Š  â”Š      this.rad1 = Utils.trim(rad1, 9, \"ceil\");\n-â”Š20â”Š  â”Š      this.rad2 = Utils.trim(rad2, 9, \"floor\");\n-â”Š21â”Š  â”Š    }\n-â”Š22â”Š  â”Š  }\n-â”Š23â”Š  â”Š\n+â”Š  â”Š 1â”ŠEngine.Geometry.Circle = class Circle extends Utils.proxy(CPP.Geometry.Circle) {\n â”Š24â”Š 2â”Š  // Draws the circle on the given context\n â”Š25â”Š 3â”Š  draw(context) {\n â”Š26â”Š 4â”Š    context.arc(this.x, this.y, this.r, this.rad1, this.rad2);\n â”Š27â”Š 5â”Š  }\n â”Š28â”Š 6â”Š\n-â”Š29â”Š  â”Š  // Gets the matching x value for the given radian\n-â”Š30â”Š  â”Š  getX(rad) {\n-â”Š31â”Š  â”Š    if (!Utils(rad).trim(9).isBetween(this.rad1, this.rad2).value()) return;\n-â”Š32â”Š  â”Š    return Utils.trim((this.r * Math.cos(rad)) + this.x, 9);\n-â”Š33â”Š  â”Š  }\n-â”Š34â”Š  â”Š\n-â”Š35â”Š  â”Š  // Gets the matching y value for the given radian\n-â”Š36â”Š  â”Š  getY(rad) {\n-â”Š37â”Š  â”Š    if (!Utils(rad).trim(9).isBetween(this.rad1, this.rad2).value()) return;\n-â”Š38â”Š  â”Š    return Utils.trim((this.r * Math.sin(rad)) + this.y, 9);\n-â”Š39â”Š  â”Š  }\n-â”Š40â”Š  â”Š\n-â”Š41â”Š  â”Š  // Gets the matching point for the given radian\n-â”Š42â”Š  â”Š  getPoint(rad) {\n-â”Š43â”Š  â”Š    if (!Utils.isBetween(rad, this.rad1, this.rad2)) return;\n-â”Š44â”Š  â”Š\n-â”Š45â”Š  â”Š    return {\n-â”Š46â”Š  â”Š      x: Utils.trim((this.r * Math.cos(rad)) + this.x, 9),\n-â”Š47â”Š  â”Š      y: Utils.trim((this.r * Math.sin(rad)) + this.y, 9)\n-â”Š48â”Š  â”Š    };\n-â”Š49â”Š  â”Š  }\n-â”Š50â”Š  â”Š\n-â”Š51â”Š  â”Š  // Gets the matching radian for the given point\n-â”Š52â”Š  â”Š  getRad(x, y) {\n-â”Š53â”Š  â”Š    let rad = Math.atan2(y - this.y, x - this.x);\n-â”Š54â”Š  â”Š\n-â”Š55â”Š  â”Š    // If calculated radian is in circle's radian range, return it\n-â”Š56â”Š  â”Š    if (rad != null && Utils.isBetween(rad, this.rad1, this.rad2)) {\n-â”Š57â”Š  â”Š      return rad;\n-â”Š58â”Š  â”Š    }\n-â”Š59â”Š  â”Š\n-â”Š60â”Š  â”Š    // The calculated radian can still be in the circle's radian range in case one\n-â”Š61â”Š  â”Š    // of the radians is greater than 2 PIEs\n-â”Š62â”Š  â”Š    if (Math.abs(this.rad1) > Math.abs(this.rad2)) {\n-â”Š63â”Š  â”Š      var greatestRad = this.rad1;\n-â”Š64â”Š  â”Š    }\n-â”Š65â”Š  â”Š    else {\n-â”Š66â”Š  â”Š      var greatestRad = this.rad2;\n-â”Š67â”Š  â”Š    }\n-â”Š68â”Š  â”Š\n-â”Š69â”Š  â”Š    // Check if the absolute radian is in the circle's radian range\n-â”Š70â”Š  â”Š    if (Utils(rad + (2 * Math.PI * Math.floor(greatestRad / (2 * Math.PI)))).trim(9).isBetween(this.rad1, this.rad2).value() ||\n-â”Š71â”Š  â”Š        Utils(rad + (2 * Math.PI * Math.ceil(greatestRad / (2 * Math.PI)))).trim(9).isBetween(this.rad1, this.rad2).value()) {\n-â”Š72â”Š  â”Š      return rad;\n-â”Š73â”Š  â”Š    }\n-â”Š74â”Š  â”Š  }\n-â”Š75â”Š  â”Š\n-â”Š76â”Š  â”Š  // Returns if circle has given points\n-â”Š77â”Š  â”Š  hasPoint(x, y) {\n-â”Š78â”Š  â”Š    return this.getRad(x, y) != null;\n-â”Š79â”Š  â”Š  }\n-â”Š80â”Š  â”Š\n â”Š81â”Š 7â”Š  getIntersection(shape) {\n â”Š82â”Š 8â”Š    if (shape instanceof Engine.Geometry.Line)\n â”Š83â”Š 9â”Š      return this.getLineIntersection(shape);\n```\n```diff\n@@ -87,86 +13,6 @@\n â”Š 87â”Š 13â”Š      return this.getPolygonIntersection(shape);\n â”Š 88â”Š 14â”Š  }\n â”Š 89â”Š 15â”Š\n-â”Š 90â”Š   â”Š  // circle - circle intersection method\n-â”Š 91â”Š   â”Š  getCircleIntersection(circle) {\n-â”Š 92â”Š   â”Š    let dx = circle.x - this.x;\n-â”Š 93â”Š   â”Š    let dy = circle.y - this.y;\n-â”Š 94â”Š   â”Š    let d = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\n-â”Š 95â”Š   â”Š\n-â”Š 96â”Š   â”Š    if (d > this.r + circle.r ||\n-â”Š 97â”Š   â”Š       d < Math.abs(this.r - circle.r)) {\n-â”Š 98â”Š   â”Š      return;\n-â”Š 99â”Š   â”Š    }\n-â”Š100â”Š   â”Š\n-â”Š101â”Š   â”Š    let a = ((Math.pow(this.r, 2) - Math.pow(circle.r, 2)) + Math.pow(d, 2)) / (2 * d);\n-â”Š102â”Š   â”Š    let x = this.x + ((dx * a) / d);\n-â”Š103â”Š   â”Š    let y = this.y + ((dy * a) / d);\n-â”Š104â”Š   â”Š    let h = Math.sqrt(Math.pow(this.r, 2) - Math.pow(a, 2));\n-â”Š105â”Š   â”Š    let rx = (- dy * h) / d;\n-â”Š106â”Š   â”Š    let ry = (dx * h) / d;\n-â”Š107â”Š   â”Š\n-â”Š108â”Š   â”Š    let interPoints = [\n-â”Š109â”Š   â”Š      {\n-â”Š110â”Š   â”Š        x: x + rx,\n-â”Š111â”Š   â”Š        y: y + ry\n-â”Š112â”Š   â”Š      },\n-â”Š113â”Š   â”Š      {\n-â”Š114â”Š   â”Š        x: x - rx,\n-â”Š115â”Š   â”Š        y: y - ry\n-â”Š116â”Š   â”Š      }\n-â”Š117â”Š   â”Š    ]\n-â”Š118â”Š   â”Š    .map(point => ({\n-â”Š119â”Š   â”Š        x: Utils.trim(point.x, 9),\n-â”Š120â”Š   â”Š        y: Utils.trim(point.y, 9)\n-â”Š121â”Š   â”Š     }));\n-â”Š122â”Š   â”Š\n-â”Š123â”Š   â”Š    interPoints = _.uniq(interPoints, point => `(${point.x}, ${point.y})`);\n-â”Š124â”Š   â”Š\n-â”Š125â”Š   â”Š    [this, circle].forEach(function(circle) {\n-â”Š126â”Š   â”Š      interPoints = interPoints.filter(point => circle.hasPoint(point.x, point.y));\n-â”Š127â”Š   â”Š    });\n-â”Š128â”Š   â”Š\n-â”Š129â”Š   â”Š    if (interPoints.length > 0) return interPoints;\n-â”Š130â”Š   â”Š  }\n-â”Š131â”Š   â”Š\n-â”Š132â”Š   â”Š  // circle - line intersection method\n-â”Š133â”Š   â”Š  getLineIntersection(line) {\n-â”Š134â”Š   â”Š    let x1 = line.x1 - this.x;\n-â”Š135â”Š   â”Š    let x2 = line.x2 - this.x;\n-â”Š136â”Š   â”Š    let y1 = line.y1 - this.y;\n-â”Š137â”Š   â”Š    let y2 = line.y2 - this.y;\n-â”Š138â”Š   â”Š    let dx = x2 - x1;\n-â”Š139â”Š   â”Š    let dy = y2 - y1;\n-â”Š140â”Š   â”Š    let d = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\n-â”Š141â”Š   â”Š    let h = (x1 * y2) - (x2 * y1);\n-â”Š142â”Š   â”Š    let delta = (Math.pow(this.r, 2) * Math.pow(d, 2)) - Math.pow(h, 2);\n-â”Š143â”Š   â”Š\n-â”Š144â”Š   â”Š    if (delta < 0) return;\n-â”Š145â”Š   â”Š\n-â”Š146â”Š   â”Š    let interPoints = [\n-â”Š147â”Š   â”Š      {\n-â”Š148â”Š   â”Š        x: (((h * dy) + (((dy / Math.abs(dy)) || 1) * dx * Math.sqrt(delta))) / Math.pow(d, 2)) + this.x,\n-â”Š149â”Š   â”Š        y: (((-h * dx) + (Math.abs(dy) * Math.sqrt(delta))) / Math.pow(d, 2)) + this.y\n-â”Š150â”Š   â”Š      },\n-â”Š151â”Š   â”Š      {\n-â”Š152â”Š   â”Š        x: (((h * dy) - (((dy / Math.abs(dy)) || 1) * dx * Math.sqrt(delta))) / Math.pow(d, 2)) + this.x,\n-â”Š153â”Š   â”Š        y: (((-h * dx) - (Math.abs(dy) * Math.sqrt(delta))) / Math.pow(d, 2)) + this.y\n-â”Š154â”Š   â”Š      }\n-â”Š155â”Š   â”Š    ]\n-â”Š156â”Š   â”Š    .map(point => ({\n-â”Š157â”Š   â”Š        x: Utils.trim(point.x, 9),\n-â”Š158â”Š   â”Š        y: Utils.trim(point.y, 9)\n-â”Š159â”Š   â”Š    }))\n-â”Š160â”Š   â”Š    .filter(point => {\n-â”Š161â”Š   â”Š      return this.hasPoint(point.x, point.y) &&\n-â”Š162â”Š   â”Š        line.boundsHavePoint(point.x, point.y);\n-â”Š163â”Š   â”Š    });\n-â”Š164â”Š   â”Š\n-â”Š165â”Š   â”Š    interPoints = _.uniq(interPoints, point => `(${point.x}, ${point.y})`);\n-â”Š166â”Š   â”Š\n-â”Š167â”Š   â”Š    if (interPoints.length > 0) return interPoints;\n-â”Š168â”Š   â”Š  }\n-â”Š169â”Š   â”Š\n â”Š170â”Š 16â”Š  // circle - polygon intersection method\n â”Š171â”Š 17â”Š  getPolygonIntersection(polygon) {\n â”Š172â”Š 18â”Š    return polygon.getCircleIntersection(this);\n```\n\n[}]: #\n\nWe also need to update the line class to contain a reference to the newly created line-intersection method, so it can be invoked from both a line or a circle bi-directionally:\n\n[{]: <helper> (diffStep 7.22)\n\n#### [Step 7.22: Add line-circle intersection method](https://github.com/DAB0mB/radial-snake/commit/84f5f4d)\n\n##### Changed resources&#x2F;cpp&#x2F;src&#x2F;geometry&#x2F;line.cpp\n```diff\n@@ -4,6 +4,7 @@\n â”Š 4â”Š 4â”Š#include \"../nullable.h\"\n â”Š 5â”Š 5â”Š#include \"../utils.h\"\n â”Š 6â”Š 6â”Š#include \"point.h\"\n+â”Š  â”Š 7â”Š#include \"circle.h\"\n â”Š 7â”Š 8â”Š#include \"line.h\"\n â”Š 8â”Š 9â”Š\n â”Š 9â”Š10â”Šnamespace geometry {\n```\n```diff\n@@ -100,6 +101,11 @@\n â”Š100â”Š101â”Š    return Nullable<Point>();\n â”Š101â”Š102â”Š  }\n â”Š102â”Š103â”Š\n+â”Š   â”Š104â”Š  // circle - circle intersection method\n+â”Š   â”Š105â”Š  Nullable<std::vector<Point>> Line::getIntersection(Circle circle) {\n+â”Š   â”Š106â”Š    return circle.getIntersection(*this);\n+â”Š   â”Š107â”Š  }\n+â”Š   â”Š108â”Š\n â”Š103â”Š109â”Š  emscripten::val EMLine::getMatchingX(double y) {\n â”Š104â”Š110â”Š    Nullable<double> nullableX = Line::getMatchingX(y);\n â”Š105â”Š111â”Š    return nullableX.hasValue() ?\n```\n```diff\n@@ -126,6 +132,10 @@\n â”Š126â”Š132â”Š    emPoint.set(\"y\", emscripten::val(point.y));\n â”Š127â”Š133â”Š    return emPoint;\n â”Š128â”Š134â”Š  }\n+â”Š   â”Š135â”Š\n+â”Š   â”Š136â”Š  emscripten::val EMLine::getIntersection(EMCircle emCircle) {\n+â”Š   â”Š137â”Š    return emCircle.getIntersection(*this);\n+â”Š   â”Š138â”Š  }\n â”Š129â”Š139â”Š}\n â”Š130â”Š140â”Š\n â”Š131â”Š141â”ŠEMSCRIPTEN_BINDINGS(geometry_line_module) {\n```\n```diff\n@@ -146,5 +156,10 @@\n â”Š146â”Š156â”Š      emscripten::select_overload<emscripten::val(geometry::EMLine)>(\n â”Š147â”Š157â”Š        &geometry::EMLine::getIntersection\n â”Š148â”Š158â”Š      )\n+â”Š   â”Š159â”Š    )\n+â”Š   â”Š160â”Š    .function(\"getCircleIntersection\",\n+â”Š   â”Š161â”Š      emscripten::select_overload<emscripten::val(geometry::EMCircle)>(\n+â”Š   â”Š162â”Š        &geometry::EMLine::getIntersection\n+â”Š   â”Š163â”Š      )\n â”Š149â”Š164â”Š    );\n â”Š150â”Š165â”Š}ðŸš«â†µ\n```\n\n##### Changed resources&#x2F;cpp&#x2F;src&#x2F;geometry&#x2F;line.h\n```diff\n@@ -4,6 +4,7 @@\n â”Š 4â”Š 4â”Š#include <emscripten/val.h>\n â”Š 5â”Š 5â”Š#include \"../nullable.h\"\n â”Š 6â”Š 6â”Š#include \"point.h\"\n+â”Š  â”Š 7â”Š#include \"circle.h\"\n â”Š 7â”Š 8â”Š\n â”Š 8â”Š 9â”Šnamespace geometry {\n â”Š 9â”Š10â”Š  class Circle;\n```\n```diff\n@@ -27,6 +28,8 @@\n â”Š27â”Š28â”Š    bool boundsHavePoint(double x, double y);\n â”Š28â”Š29â”Š\n â”Š29â”Š30â”Š    Nullable<Point> getIntersection(Line line);\n+â”Š  â”Š31â”Š\n+â”Š  â”Š32â”Š    Nullable<std::vector<Point>> getIntersection(Circle circle);\n â”Š30â”Š33â”Š  };\n â”Š31â”Š34â”Š\n â”Š32â”Š35â”Š  class EMLine : public Line {\n```\n```diff\n@@ -38,5 +41,7 @@\n â”Š38â”Š41â”Š    emscripten::val getMatchingY(double x);\n â”Š39â”Š42â”Š\n â”Š40â”Š43â”Š    emscripten::val getIntersection(EMLine line);\n+â”Š  â”Š44â”Š\n+â”Š  â”Š45â”Š    emscripten::val getIntersection(EMCircle circle);\n â”Š41â”Š46â”Š  };\n â”Š42â”Š47â”Š}ðŸš«â†µ\n```\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;geometry&#x2F;line.js\n```diff\n@@ -14,11 +14,6 @@\n â”Š14â”Š14â”Š      return this.getPolygonIntersection(shape);\n â”Š15â”Š15â”Š  }\n â”Š16â”Š16â”Š\n-â”Š17â”Š  â”Š  // line - circle intersection method\n-â”Š18â”Š  â”Š  getCircleIntersection(circle) {\n-â”Š19â”Š  â”Š    return circle.getLineIntersection(this);\n-â”Š20â”Š  â”Š  }\n-â”Š21â”Š  â”Š\n â”Š22â”Š17â”Š  // line - polygon intersection method\n â”Š23â”Š18â”Š  getPolygonIntersection(polygon) {\n â”Š24â”Š19â”Š    return polygon.getLineIntersection(this);\n```\n\n[}]: #\n\nNow, before running the tests, be sure to disposed unused circle test-data:\n\n[{]: <helper> (diffStep 7.23)\n\n#### [Step 7.23: Delete circle instances in tests](https://github.com/DAB0mB/radial-snake/commit/e953fae)\n\n##### Changed resources&#x2F;scripts&#x2F;specs&#x2F;engine&#x2F;geometry&#x2F;circle.js\n```diff\n@@ -3,6 +3,10 @@\n â”Š 3â”Š 3â”Š    this.circle = new Engine.Geometry.Circle(1, 1, 5, 0, 1.5 * Math.PI);\n â”Š 4â”Š 4â”Š  });\n â”Š 5â”Š 5â”Š\n+â”Š  â”Š 6â”Š  afterEach(function () {\n+â”Š  â”Š 7â”Š    this.circle.delete();\n+â”Š  â”Š 8â”Š  });\n+â”Š  â”Š 9â”Š\n â”Š 6â”Š10â”Š  describe(\"getX method\", function() {\n â”Š 7â”Š11â”Š    describe(\"given inranged rad\", function() {\n â”Š 8â”Š12â”Š      it(\"returns x\", function() {\n```\n```diff\n@@ -64,6 +68,8 @@\n â”Š64â”Š68â”Š          { x: -2, y: -3 },\n â”Š65â”Š69â”Š          { x: -2, y: 5 }\n â”Š66â”Š70â”Š        ]);\n+â”Š  â”Š71â”Š\n+â”Š  â”Š72â”Š        circle.delete();\n â”Š67â”Š73â”Š      });\n â”Š68â”Š74â”Š    });\n â”Š69â”Š75â”Š\n```\n```diff\n@@ -74,6 +80,8 @@\n â”Š74â”Š80â”Š        expect(this.circle.getCircleIntersection(circle)).toEqual([\n â”Š75â”Š81â”Š          { x: -2, y: 5 }\n â”Š76â”Š82â”Š        ]);\n+â”Š  â”Š83â”Š\n+â”Š  â”Š84â”Š        circle.delete();\n â”Š77â”Š85â”Š      });\n â”Š78â”Š86â”Š    });\n â”Š79â”Š87â”Š\n```\n```diff\n@@ -84,6 +92,8 @@\n â”Š84â”Š92â”Š        expect(this.circle.getCircleIntersection(circle)).toEqual([\n â”Š85â”Š93â”Š          { x: -4, y: 1 }\n â”Š86â”Š94â”Š        ]);\n+â”Š  â”Š95â”Š\n+â”Š  â”Š96â”Š        circle.delete();\n â”Š87â”Š97â”Š      });\n â”Š88â”Š98â”Š    });\n â”Š89â”Š99â”Š\n```\n```diff\n@@ -91,6 +101,7 @@\n â”Š 91â”Š101â”Š      it(\"returns nothing\", function() {\n â”Š 92â”Š102â”Š        let circle = new Engine.Geometry.Circle(10, 10, 2, 0, 2 * Math.PI);\n â”Š 93â”Š103â”Š        expect(this.circle.getCircleIntersection(circle)).toBeUndefined();\n+â”Š   â”Š104â”Š        circle.delete();\n â”Š 94â”Š105â”Š      });\n â”Š 95â”Š106â”Š    });\n â”Š 96â”Š107â”Š\n```\n```diff\n@@ -98,6 +109,7 @@\n â”Š 98â”Š109â”Š      it(\"nothing\", function() {\n â”Š 99â”Š110â”Š        let circle = new Engine.Geometry.Circle(1, 1, 2, 0, 2 * Math.PI);\n â”Š100â”Š111â”Š        expect(this.circle.getCircleIntersection(circle)).toBeUndefined();\n+â”Š   â”Š112â”Š        circle.delete();\n â”Š101â”Š113â”Š      });\n â”Š102â”Š114â”Š    });\n â”Š103â”Š115â”Š  });\n```\n\n##### Changed resources&#x2F;scripts&#x2F;specs&#x2F;engine&#x2F;geometry&#x2F;polygon.js\n```diff\n@@ -64,6 +64,8 @@\n â”Š64â”Š64â”Š          { x: 2, y: 0 },\n â”Š65â”Š65â”Š          { x: 0, y: 2 }\n â”Š66â”Š66â”Š        ]);\n+â”Š  â”Š67â”Š\n+â”Š  â”Š68â”Š        circle.delete();\n â”Š67â”Š69â”Š      });\n â”Š68â”Š70â”Š    });\n â”Š69â”Š71â”Š\n```\n```diff\n@@ -74,6 +76,8 @@\n â”Š74â”Š76â”Š        expect(this.polygon.getCircleIntersection(circle)).toEqual([\n â”Š75â”Š77â”Š          { x: 2, y: 0 }\n â”Š76â”Š78â”Š        ]);\n+â”Š  â”Š79â”Š\n+â”Š  â”Š80â”Š        circle.delete();\n â”Š77â”Š81â”Š      });\n â”Š78â”Š82â”Š    });\n â”Š79â”Š83â”Š\n```\n```diff\n@@ -84,6 +88,8 @@\n â”Š84â”Š88â”Š        expect(this.polygon.getCircleIntersection(circle)).toEqual([\n â”Š85â”Š89â”Š          { x: 0, y: 3 }\n â”Š86â”Š90â”Š        ]);\n+â”Š  â”Š91â”Š\n+â”Š  â”Š92â”Š        circle.delete();\n â”Š87â”Š93â”Š      });\n â”Š88â”Š94â”Š    });\n â”Š89â”Š95â”Š\n```\n```diff\n@@ -91,6 +97,7 @@\n â”Š 91â”Š 97â”Š      it(\"returns nothing\", function() {\n â”Š 92â”Š 98â”Š        let circle = new Engine.Geometry.Circle(10, 10, 2, 0, 2 * Math.PI);\n â”Š 93â”Š 99â”Š        expect(this.polygon.getCircleIntersection(circle)).toBeUndefined();\n+â”Š   â”Š100â”Š        circle.delete();\n â”Š 94â”Š101â”Š      });\n â”Š 95â”Š102â”Š    });\n â”Š 96â”Š103â”Š\n```\n```diff\n@@ -98,6 +105,7 @@\n â”Š 98â”Š105â”Š      it(\"nothing\", function() {\n â”Š 99â”Š106â”Š        let circle = new Engine.Geometry.Circle(2.5, 2.5, 2, 0, 2 * Math.PI);\n â”Š100â”Š107â”Š        expect(this.polygon.getCircleIntersection(circle)).toBeUndefined();\n+â”Š   â”Š108â”Š        circle.delete();\n â”Š101â”Š109â”Š      });\n â”Š102â”Š110â”Š    });\n â”Š103â”Š111â”Š  });\n```\n\n[}]: #\n\nOur C++ code should be finished now, and all the tests should be passing. The only thing left to do would be applying it to our game. Like any other application, we first need to reference the script file so it can be loaded, in this case, the C++ bundle script:\n\n[{]: <helper> (diffStep 7.24)\n\n#### [Step 7.24: Load CPP bundle in game](https://github.com/DAB0mB/radial-snake/commit/a2c0d46)\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -8,6 +8,7 @@\n â”Š 8â”Š 8â”Š    <script type=\"text/javascript\" src=\"/libs/underscore.js\"></script>\n â”Š 9â”Š 9â”Š\n â”Š10â”Š10â”Š    <!-- Scripts -->\n+â”Š  â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/cpp.bundle.js\"></script>\n â”Š11â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/utils.js\"></script>\n â”Š12â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/geometry/line.js\"></script>\n```\n\n[}]: #\n\nAnd now we need to make sure to dispose the geometry shapes correctly so we won't experience any unnecessary memory leaks. Most of our disposals should go to the snake entity, since it's made out of shapes; So we will add a `delete` method to the snake entity and we will dispose it whenever a match is finished:\n\n[{]: <helper> (diffStep 7.25)\n\n#### [Step 7.25: Delete shape instances in game](https://github.com/DAB0mB/radial-snake/commit/ae58323)\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;game.js\n```diff\n@@ -95,6 +95,7 @@\n â”Š 95â”Š 95â”Š  changeScreen(Screen, ...screenArgs) {\n â”Š 96â”Š 96â”Š    // If there is a screen defined, dispose it first\n â”Š 97â”Š 97â”Š    if (this.screen) {\n+â”Š   â”Š 98â”Š      this.screen.delete();\n â”Š 98â”Š 99â”Š      this.unloadScreen();\n â”Š 99â”Š100â”Š      this.screen.disposeEventListeners();\n â”Š100â”Š101â”Š    }\n```\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;layer.js\n```diff\n@@ -23,6 +23,9 @@\n â”Š23â”Š23â”Š    this.canvas = screen.game.canvas;\n â”Š24â”Š24â”Š  }\n â”Š25â”Š25â”Š\n+â”Š  â”Š26â”Š  delete() {\n+â”Š  â”Š27â”Š  }\n+â”Š  â”Š28â”Š\n â”Š26â”Š29â”Š  update(span) {\n â”Š27â”Š30â”Š  }\n â”Š28â”Š31â”Š\n```\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;screen.js\n```diff\n@@ -28,6 +28,13 @@\n â”Š28â”Š28â”Š    return this;\n â”Š29â”Š29â”Š  }\n â”Š30â”Š30â”Š\n+â”Š  â”Š31â”Š   // Delete all layers. Same as 'unload', only it disposes memory rather than assets\n+â”Š  â”Š32â”Š  delete() {\n+â”Š  â”Š33â”Š    this.layers.forEach(layer => {\n+â”Š  â”Š34â”Š      layer.delete();\n+â”Š  â”Š35â”Š    });\n+â”Š  â”Š36â”Š  }\n+â”Š  â”Š37â”Š\n â”Š31â”Š38â”Š  // Updates each layer\n â”Š32â”Š39â”Š  update(span) {\n â”Š33â”Š40â”Š    this.layers.forEach(layer => {\n```\n```diff\n@@ -61,6 +68,7 @@\n â”Š61â”Š68â”Š  removeLayer(layer) {\n â”Š62â”Š69â”Š    this.layers = _.without(this.layers, layer);\n â”Š63â”Š70â”Š    layer.disposeEventListeners();\n+â”Š  â”Š71â”Š    layer.delete();\n â”Š64â”Š72â”Š  }\n â”Š65â”Š73â”Š\n â”Š66â”Š74â”Š  initEventListeners() {\n```\n\n##### Changed resources&#x2F;scripts&#x2F;game&#x2F;entities&#x2F;snake.js\n```diff\n@@ -31,6 +31,10 @@\n â”Š31â”Š31â”Š    }\n â”Š32â”Š32â”Š  }\n â”Š33â”Š33â”Š\n+â”Š  â”Š34â”Š  delete() {\n+â”Š  â”Š35â”Š    this.shapes.forEach(shape => shape.delete());\n+â”Š  â”Š36â”Š  }\n+â”Š  â”Š37â”Š\n â”Š34â”Š38â”Š  draw(context) {\n â”Š35â”Š39â”Š    // Draw all shapes in the shapes array\n â”Š36â”Š40â”Š    this.shapes.forEach(shape => {\n```\n```diff\n@@ -229,6 +233,8 @@\n â”Š229â”Š233â”Š      [0, height, 0, 0]\n â”Š230â”Š234â”Š    );\n â”Š231â”Š235â”Š\n-â”Š232â”Š   â”Š    return canvasPolygon.getIntersection(this.lastBit);\n+â”Š   â”Š236â”Š    let result = canvasPolygon.getIntersection(this.lastBit);\n+â”Š   â”Š237â”Š    canvasPolygon.delete();\n+â”Š   â”Š238â”Š    return result;\n â”Š233â”Š239â”Š  }\n â”Š234â”Š240â”Š};ðŸš«â†µ\n```\n\n##### Changed resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;play&#x2F;snake.js\n```diff\n@@ -43,6 +43,10 @@\n â”Š43â”Š43â”Š    screen.appendLayer(Game.Screens.Play.Score, this.snakes);\n â”Š44â”Š44â”Š  }\n â”Š45â”Š45â”Š\n+â”Š  â”Š46â”Š  unload() {\n+â”Š  â”Š47â”Š    this.snakes.forEach(snake => snake.delete());\n+â”Š  â”Š48â”Š  }\n+â”Š  â”Š49â”Š\n â”Š46â”Š50â”Š  draw(context) {\n â”Š47â”Š51â”Š    // Draw each snake in the snakes array\n â”Š48â”Š52â”Š    this.snakes.forEach(snake => snake.draw(context));\n```\n\n[}]: #\n\nCongratulations! You've created a C++ cross JavaScript game. There shouldn't be any significant difference between the C++ version of the game and the JavaScript version on most machines, since the game is very small and barely requires any processing power. You'll probably notice the difference when starting to extend the game by adding terrains or more snakes.\n\nOne might ask - \"How much faster does my game actually run?\". The short answer is - around 50%. Why did I run into this conclusion? Well, take a look at the following JavaScript code snippet, for calculating Fibonacci of 42:\n\n```js\nfunction fib(x) {\n  if (x < 2) {\n    return 1;\n  }\n  else {\n    return fib(x - 1) + fib(x - 2);\n  }\n}\n```\n\nThe same code snippet should look almost identical written in C++:\n\n```cpp\nint fib(int x) {\n  if (x < 2) {\n    return 1;\n  }\n  else {\n    return fib(x - 1) + fib(x - 2);\n  }\n}\n```\n\nHowever, the run-times are completely different! I compared the average of 10 runs in 3 different environments, and I received the following results:\n\n![chart](https://cloud.githubusercontent.com/assets/7648874/22802494/2591025e-eef8-11e6-9679-10b5bca0ef30.png)\n\nAs you can see, the generated C++ is much faster, and to be precise, 57% faster! Surprisingly, I didn't have any significant difference between Emscripten generated C++ and natively compiled executable.\n\nC++ is more complex to write, but it certainly has its advantages over JavaScript. Remember, now that you know that you have the possibility to run C++ in the browser, make sure to use it, but never overdo it, always find the right balance between readability and performance.\n\n> *Sources:*\n> - *https://kripken.github.io/emscripten-site/docs/introducing_emscripten/index.html*\n> - *http://www.crunchy.com/?q=content/emscripten-perfectly-cromulent-compiler*\n> - *http://stackoverflow.com/questions/2354725/what-exactly-is-llvm*"
          }
        ]
      },
      {
        "releaseVersion": "0.0.2",
        "releaseDate": "2017-01-20 03:02:52 -0200",
        "tagName": "master@0.0.2",
        "tagRevision": "f8c0e5318f1f94bae85aa1b078a9592df34847c2",
        "historyRevision": "6e3117812c01aa5e13779e8b0f44c3c8e3f0115d",
        "changesDiff": "diff --git a/manuals/templates/step2.md b/manuals/templates/step2.md\nindex 0164be3..cfcbb81 100644\n--- a/manuals/templates/step2.md\n+++ b/manuals/templates/step2.md\n@@ -41,7 +41,7 @@ A game loop can wear many forms, but the concept is gonna be the same, plus-minu\n \n {{{diff_step 2.5}}}\n \n-The only thing it's doing right now is only drawing a black background, but we're soon going to learn how to take advantage of this game-loop to draw some custom stuff. I just want to point out that in the `draw` method I used a very handy technique called [double-buffer](https://en.wikipedia.org/wiki/Multiple_buffering), where I first draw everything on a virtual canvas which is not visible to us, and once it's finished, I the result on the main canvas. It behaves the same way React's [virtual DOM](https://www.npmjs.com/package/react-dom) behaves like, and it will prevent our game from stuttering. To start running the game, we first need to wait for the DOM content to initialize, and once its ready we gonna create a new game instance and call the `play` method:\n+The only thing it's doing right now is only drawing a black background, but we're soon going to learn how to take advantage of this game-loop to draw stuff of our own. I want to point out that there is no need to implement a [double-buffer](https://en.wikipedia.org/wiki/Multiple_buffering) (A method similar to React's [virtual DOM](https://www.npmjs.com/package/react-dom)) when it comes to `HTMLCanvas` elements, since `HTML5` already does that for us. To start running the game, we first need to wait for the DOM content to initialize, and once it's ready we gonna create a new game instance and call the `play` method:\n \n {{{diff_step 2.6}}}\n \ndiff --git a/manuals/templates/step5.md b/manuals/templates/step5.md\nindex 8627312..2c11ac8 100644\n--- a/manuals/templates/step5.md\n+++ b/manuals/templates/step5.md\n@@ -2,7 +2,7 @@\n \n In this step we will be creating all the necessary geometry shapes to form a snake; we're basically implementing the right infrastructure so in the next step we will be able to implement the game screen with ease. What exactly do I mean by \"geometry shapes\"? Well, our snake will be made out of circles, and lines. If we don't press any buttons at all, the snake should move forward at a straight line, and once we press on one of the arrow keys, the snake should move in a circular motion. Not only we want to draw the screen on the canvas, we also want to be able to detect collision with other snakes, since this is a \"Tron\" style game where we gonna fight against an opponent.\n \n-Keep in mind that a computer's precision is limited due its [binary representation in memory](https://en.wikipedia.org/wiki/Memory_cell_(binary)). We need to take into consideration that there might be a significant deviation when detecting collisions and intersections between geometry shapes, especially when elapsed time is not always guaranteed to stay precise. To handle these deviation issues, we're gonna create some utility functions and place then as an extension for the `Number` prototype:\n+Keep in mind that a computer's precision is limited due its [binary representation in memory](https://en.wikipedia.org/wiki/Memory_cell_(binary)). We need to take into consideration that there might be a significant deviation when detecting collisions and intersections between geometry shapes, especially when elapsed time is not always guaranteed to stay precise. To handle these deviation issues, we're gonna create some utility functions and place then in a new module called `Utils`:\n \n {{{diff_step 5.1}}}\n \ndiff --git a/manuals/views/step2.md b/manuals/views/step2.md\nindex 855f82a..3b947ce 100644\n--- a/manuals/views/step2.md\n+++ b/manuals/views/step2.md\n@@ -131,119 +131,106 @@ A game loop can wear many forms, but the concept is gonna be the same, plus-minu\n \n ##### Added resources/scripts/engine/game.js\n ```diff\n-@@ -0,0 +1,112 @@\n-+â”Š   â”Š  1â”ŠEngine.Game = class Game {\n-+â”Š   â”Š  2â”Š  // Frames rendered per second\n-+â”Š   â”Š  3â”Š  get fps() {\n-+â”Š   â”Š  4â”Š    return 60;\n-+â”Š   â”Š  5â”Š  }\n-+â”Š   â”Š  6â”Š\n-+â”Š   â”Š  7â”Š  // Game's run speed.\n-+â”Š   â”Š  8â”Š  // A lower value will make it run slower and a higher value will make it run faster\n-+â”Š   â”Š  9â”Š  get speed() {\n-+â”Š   â”Š 10â”Š    return 1;\n-+â”Š   â”Š 11â”Š  }\n-+â”Š   â”Š 12â”Š\n-+â”Š   â”Š 13â”Š  constructor(canvas, debugging) {\n-+â”Š   â”Š 14â”Š    this.canvas = canvas;\n-+â”Š   â”Š 15â”Š    this.debugging = debugging;\n-+â”Š   â”Š 16â”Š    this.lastUpdate = this.creation = new Date().getTime();\n-+â”Š   â”Š 17â”Š\n-+â”Š   â”Š 18â”Š    // Canvas dimensions must be set programmatically otherwise you might encounter some\n-+â”Š   â”Š 19â”Š    // unexpected behaviors\n-+â”Š   â”Š 20â”Š    canvas.width = 1280;\n-+â”Š   â”Š 21â”Š    canvas.height = 720;\n-+â”Š   â”Š 22â”Š    // Canvas will be focused once game page is loaded so all events will automatically\n-+â”Š   â”Š 23â”Š    // be captured by it\n-+â”Š   â”Š 24â”Š    canvas.focus();\n-+â”Š   â”Š 25â”Š\n-+â”Š   â”Š 26â”Š    // We want to focus on the canvas once we press on it\n-+â”Š   â”Š 27â”Š    canvas.addEventListener(\"mousedown\", canvas.focus.bind(canvas), false);\n-+â”Š   â”Š 28â”Š\n-+â”Š   â”Š 29â”Š    this.assets = {};\n-+â”Š   â”Š 30â”Š    this.events = new Map();\n-+â”Š   â”Š 31â”Š    this.context = canvas.getContext(\"2d\");\n-+â”Š   â”Š 32â”Š    this.bufferedCanvas = document.createElement(\"canvas\");\n-+â”Š   â”Š 33â”Š    this.bufferedContext = this.bufferedCanvas.getContext(\"2d\");\n-+â”Š   â”Š 34â”Š    this.bufferedCanvas.width = canvas.width;\n-+â”Š   â”Š 35â”Š    this.bufferedCanvas.height = canvas.height;\n-+â”Š   â”Š 36â”Š  }\n-+â”Š   â”Š 37â”Š\n-+â”Š   â”Š 38â”Š  draw() {\n-+â”Š   â”Š 39â”Š    // If debugging, don't use double buffer so we can see rendering in real time\n-+â”Š   â”Š 40â”Š    if (this.debugging) {\n-+â”Š   â”Š 41â”Š      this.context.restore();\n-+â”Š   â”Š 42â”Š      this.context.fillStyle = \"black\";\n-+â”Š   â”Š 43â”Š      this.context.save();\n-+â”Š   â”Š 44â”Š      this.context.beginPath();\n-+â”Š   â”Š 45â”Š      this.context.rect(0, 0, this.canvas.width, this.canvas.height);\n-+â”Š   â”Š 46â”Š      this.context.fill();\n-+â”Š   â”Š 47â”Š    }\n-+â”Š   â”Š 48â”Š    // If not debugging, use double buffer to prevent flickering\n-+â”Š   â”Š 49â”Š    else {\n-+â”Š   â”Š 50â”Š      this.bufferedContext.restore();\n-+â”Š   â”Š 51â”Š      this.bufferedContext.fillStyle = \"black\";\n-+â”Š   â”Š 52â”Š      this.bufferedContext.save();\n-+â”Š   â”Š 53â”Š      this.bufferedContext.beginPath();\n-+â”Š   â”Š 54â”Š      this.bufferedContext.rect(0, 0, this.canvas.width, this.canvas.height);\n-+â”Š   â”Š 55â”Š      this.bufferedContext.fill();\n-+â”Š   â”Š 56â”Š      this.context.drawImage(this.bufferedCanvas, 0, 0);\n-+â”Š   â”Š 57â”Š    }\n-+â”Š   â”Š 58â”Š  }\n-+â”Š   â”Š 59â”Š\n-+â”Š   â”Š 60â”Š  update() {\n-+â”Š   â”Š 61â”Š    // Calculate the time elapsed\n-+â”Š   â”Š 62â”Š    let lastUpdate = this.lastUpdate;\n-+â”Š   â”Š 63â”Š    let currUpdate = this.lastUpdate = new Date().getTime();\n-+â”Š   â”Š 64â”Š    let span = currUpdate - lastUpdate;\n-+â”Š   â”Š 65â”Š    this.updateScreen(span / this.speed);\n-+â”Š   â”Š 66â”Š  }\n-+â”Š   â”Š 67â”Š\n-+â”Š   â”Š 68â”Š  // The main loop of the game\n-+â”Š   â”Š 69â”Š  loop() {\n-+â”Š   â”Š 70â”Š    // If paused, don't run loop. The canvas will remain as is\n-+â”Š   â”Š 71â”Š    if (!this.playing) return;\n-+â”Š   â”Š 72â”Š\n-+â”Š   â”Š 73â”Š    setTimeout(() => {\n-+â”Š   â”Š 74â”Š      this.draw();\n-+â”Š   â”Š 75â”Š      this.update();\n-+â”Š   â”Š 76â”Š      this.loop();\n-+â”Š   â”Š 77â”Š    }, this.fps);\n-+â”Š   â”Š 78â”Š  }\n-+â”Š   â”Š 79â”Š\n-+â”Š   â”Š 80â”Š  play() {\n-+â”Š   â”Š 81â”Š    this.playing = true;\n-+â”Š   â”Š 82â”Š    this.loop();\n-+â”Š   â”Š 83â”Š  }\n-+â”Š   â”Š 84â”Š\n-+â”Š   â”Š 85â”Š  pause() {\n-+â”Š   â”Š 86â”Š    this.playing = false;\n-+â”Š   â”Š 87â”Š  }\n-+â”Š   â”Š 88â”Š\n-+â”Š   â”Š 89â”Š  // Defines global assets\n-+â”Š   â”Š 90â”Š  extendAssets(assets) {\n-+â”Š   â”Š 91â”Š    _.extend(this.assets, assets);\n-+â”Š   â”Š 92â”Š  }\n-+â”Š   â”Š 93â”Š\n-+â”Š   â”Š 94â”Š  // Disposes global assets\n-+â”Š   â”Š 95â”Š  clearAssets() {\n-+â”Š   â”Š 96â”Š    this.assets = {};\n-+â”Š   â”Š 97â”Š  }\n-+â”Š   â”Š 98â”Š\n-+â”Š   â”Š 99â”Š  // Adds event listener for game canvas\n-+â”Š   â”Š100â”Š  addEventListener(type, listener, target) {\n-+â”Š   â”Š101â”Š    let boundListener = listener.bind(target);\n-+â”Š   â”Š102â”Š    this.events.set(listener, boundListener);\n-+â”Š   â”Š103â”Š    this.canvas.addEventListener(type, boundListener, false);\n-+â”Š   â”Š104â”Š  }\n-+â”Š   â”Š105â”Š\n-+â”Š   â”Š106â”Š  // Removes event listener from game canvas\n-+â”Š   â”Š107â”Š  removeEventListener(type, listener) {\n-+â”Š   â”Š108â”Š    let boundListener = this.events.get(listener);\n-+â”Š   â”Š109â”Š    this.events.delete(listener);\n-+â”Š   â”Š110â”Š    this.canvas.removeEventListener(type, boundListener, false);\n-+â”Š   â”Š111â”Š  }\n-+â”Š   â”Š112â”Š};ðŸš«â†µ\n+@@ -0,0 +1,99 @@\n++â”Š  â”Š 1â”ŠEngine.Game = class Game {\n++â”Š  â”Š 2â”Š  // The frequency of which each frame will be drawn in milliseconds\n++â”Š  â”Š 3â”Š  get fps() {\n++â”Š  â”Š 4â”Š    return 1000 / 60;\n++â”Š  â”Š 5â”Š  }\n++â”Š  â”Š 6â”Š\n++â”Š  â”Š 7â”Š  // Game's run speed.\n++â”Š  â”Š 8â”Š  // A lower value will make it run slower and a higher value will make it run faster\n++â”Š  â”Š 9â”Š  get speed() {\n++â”Š  â”Š10â”Š    return 1;\n++â”Š  â”Š11â”Š  }\n++â”Š  â”Š12â”Š\n++â”Š  â”Š13â”Š  constructor(canvas) {\n++â”Š  â”Š14â”Š    this.canvas = canvas;\n++â”Š  â”Š15â”Š    this.lastUpdate = this.creation = new Date().getTime();\n++â”Š  â”Š16â”Š\n++â”Š  â”Š17â”Š    // Canvas dimensions must be set programmatically otherwise you might encounter some\n++â”Š  â”Š18â”Š    // unexpected behaviors\n++â”Š  â”Š19â”Š    canvas.width = 1280;\n++â”Š  â”Š20â”Š    canvas.height = 720;\n++â”Š  â”Š21â”Š    // Canvas will be focused once game page is loaded so all events will automatically\n++â”Š  â”Š22â”Š    // be captured by it\n++â”Š  â”Š23â”Š    canvas.focus();\n++â”Š  â”Š24â”Š\n++â”Š  â”Š25â”Š    // We want to focus on the canvas once we press on it\n++â”Š  â”Š26â”Š    canvas.addEventListener(\"mousedown\", canvas.focus.bind(canvas), false);\n++â”Š  â”Š27â”Š\n++â”Š  â”Š28â”Š    this.assets = {};\n++â”Š  â”Š29â”Š    this.events = new Map();\n++â”Š  â”Š30â”Š    this.context = canvas.getContext(\"2d\");\n++â”Š  â”Š31â”Š    this.bufferedCanvas = document.createElement(\"canvas\");\n++â”Š  â”Š32â”Š    this.bufferedContext = this.bufferedCanvas.getContext(\"2d\");\n++â”Š  â”Š33â”Š    this.bufferedCanvas.width = canvas.width;\n++â”Š  â”Š34â”Š    this.bufferedCanvas.height = canvas.height;\n++â”Š  â”Š35â”Š  }\n++â”Š  â”Š36â”Š\n++â”Š  â”Š37â”Š  draw() {\n++â”Š  â”Š38â”Š    // Draw a black screen by default\n++â”Š  â”Š39â”Š    this.context.restore();\n++â”Š  â”Š40â”Š    this.context.fillStyle = \"black\";\n++â”Š  â”Š41â”Š    this.context.save();\n++â”Š  â”Š42â”Š    this.context.beginPath();\n++â”Š  â”Š43â”Š    this.context.rect(0, 0, this.canvas.width, this.canvas.height);\n++â”Š  â”Š44â”Š    this.context.fill();\n++â”Š  â”Š45â”Š  }\n++â”Š  â”Š46â”Š\n++â”Š  â”Š47â”Š  update() {\n++â”Š  â”Š48â”Š    // Calculate the time elapsed\n++â”Š  â”Š49â”Š    let lastUpdate = this.lastUpdate;\n++â”Š  â”Š50â”Š    let currUpdate = this.lastUpdate = new Date().getTime();\n++â”Š  â”Š51â”Š    let span = currUpdate - lastUpdate;\n++â”Š  â”Š52â”Š    this.updateScreen(span / this.speed);\n++â”Š  â”Š53â”Š  }\n++â”Š  â”Š54â”Š\n++â”Š  â”Š55â”Š  // The main loop of the game\n++â”Š  â”Š56â”Š  loop() {\n++â”Š  â”Š57â”Š    // If paused, don't run loop. The canvas will remain as is\n++â”Š  â”Š58â”Š    if (!this.playing) return;\n++â”Š  â”Š59â”Š\n++â”Š  â”Š60â”Š    setTimeout(() => {\n++â”Š  â”Š61â”Š      this.draw();\n++â”Š  â”Š62â”Š      this.update();\n++â”Š  â”Š63â”Š      this.loop();\n++â”Š  â”Š64â”Š    }, this.fps);\n++â”Š  â”Š65â”Š  }\n++â”Š  â”Š66â”Š\n++â”Š  â”Š67â”Š  play() {\n++â”Š  â”Š68â”Š    this.playing = true;\n++â”Š  â”Š69â”Š    this.loop();\n++â”Š  â”Š70â”Š  }\n++â”Š  â”Š71â”Š\n++â”Š  â”Š72â”Š  pause() {\n++â”Š  â”Š73â”Š    this.playing = false;\n++â”Š  â”Š74â”Š  }\n++â”Š  â”Š75â”Š\n++â”Š  â”Š76â”Š  // Defines global assets\n++â”Š  â”Š77â”Š  extendAssets(assets) {\n++â”Š  â”Š78â”Š    _.extend(this.assets, assets);\n++â”Š  â”Š79â”Š  }\n++â”Š  â”Š80â”Š\n++â”Š  â”Š81â”Š  // Disposes global assets\n++â”Š  â”Š82â”Š  clearAssets() {\n++â”Š  â”Š83â”Š    this.assets = {};\n++â”Š  â”Š84â”Š  }\n++â”Š  â”Š85â”Š\n++â”Š  â”Š86â”Š  // Adds event listener for game canvas\n++â”Š  â”Š87â”Š  addEventListener(type, listener, target) {\n++â”Š  â”Š88â”Š    let boundListener = listener.bind(target);\n++â”Š  â”Š89â”Š    this.events.set(listener, boundListener);\n++â”Š  â”Š90â”Š    this.canvas.addEventListener(type, boundListener, false);\n++â”Š  â”Š91â”Š  }\n++â”Š  â”Š92â”Š\n++â”Š  â”Š93â”Š  // Removes event listener from game canvas\n++â”Š  â”Š94â”Š  removeEventListener(type, listener) {\n++â”Š  â”Š95â”Š    let boundListener = this.events.get(listener);\n++â”Š  â”Š96â”Š    this.events.delete(listener);\n++â”Š  â”Š97â”Š    this.canvas.removeEventListener(type, boundListener, false);\n++â”Š  â”Š98â”Š  }\n++â”Š  â”Š99â”Š};ðŸš«â†µ\n ```\n \n ##### Changed views/game.html\n@@ -259,7 +246,7 @@ A game loop can wear many forms, but the concept is gonna be the same, plus-minu\n ```\n [}]: #\n \n-The only thing it's doing right now is only drawing a black background, but we're soon going to learn how to take advantage of this game-loop to draw some custom stuff. I just want to point out that in the `draw` method I used a very handy technique called [double-buffer](https://en.wikipedia.org/wiki/Multiple_buffering), where I first draw everything on a virtual canvas which is not visible to us, and once it's finished, I the result on the main canvas. It behaves the same way React's [virtual DOM](https://www.npmjs.com/package/react-dom) behaves like, and it will prevent our game from stuttering. To start running the game, we first need to wait for the DOM content to initialize, and once its ready we gonna create a new game instance and call the `play` method:\n+The only thing it's doing right now is only drawing a black background, but we're soon going to learn how to take advantage of this game-loop to draw stuff of our own. I want to point out that there is no need to implement a [double-buffer](https://en.wikipedia.org/wiki/Multiple_buffering) (A method similar to React's [virtual DOM](https://www.npmjs.com/package/react-dom)) when it comes to `HTMLCanvas` elements, since `HTML5` already does that for us. To start running the game, we first need to wait for the DOM content to initialize, and once it's ready we gonna create a new game instance and call the `play` method:\n \n [{]: <helper> (diff_step 2.6)\n #### Step 2.6: Create game entry point\n@@ -337,54 +324,54 @@ Now that we have the key state manager, we will initialize a new instance as par\n \n ##### Changed resources/scripts/engine/game.js\n ```diff\n-@@ -15,7 +15,7 @@\n- â”Š15â”Š15â”Š    this.debugging = debugging;\n- â”Š16â”Š16â”Š    this.lastUpdate = this.creation = new Date().getTime();\n- â”Š17â”Š17â”Š\n--â”Š18â”Š  â”Š    // Canvas dimensions must be set programmatically otherwise you might encounter some\n-+â”Š  â”Š18â”Š    // Canvas dimensions must be set programmatically, otherwise you might encounter some\n- â”Š19â”Š19â”Š    // unexpected behaviors\n- â”Š20â”Š20â”Š    canvas.width = 1280;\n- â”Š21â”Š21â”Š    canvas.height = 720;\n+@@ -14,7 +14,7 @@\n+ â”Š14â”Š14â”Š    this.canvas = canvas;\n+ â”Š15â”Š15â”Š    this.lastUpdate = this.creation = new Date().getTime();\n+ â”Š16â”Š16â”Š\n+-â”Š17â”Š  â”Š    // Canvas dimensions must be set programmatically otherwise you might encounter some\n++â”Š  â”Š17â”Š    // Canvas dimensions must be set programmatically, otherwise you might encounter some\n+ â”Š18â”Š18â”Š    // unexpected behaviors\n+ â”Š19â”Š19â”Š    canvas.width = 1280;\n+ â”Š20â”Š20â”Š    canvas.height = 720;\n ```\n ```diff\n-@@ -25,9 +25,13 @@\n- â”Š25â”Š25â”Š\n- â”Š26â”Š26â”Š    // We want to focus on the canvas once we press on it\n- â”Š27â”Š27â”Š    canvas.addEventListener(\"mousedown\", canvas.focus.bind(canvas), false);\n-+â”Š  â”Š28â”Š    // Key flags will be registered by the \"KeyStates\" instance\n-+â”Š  â”Š29â”Š    canvas.addEventListener(\"keydown\", onKeyDown.bind(this), false);\n-+â”Š  â”Š30â”Š    canvas.addEventListener(\"keyup\", onKeyUp.bind(this), false);\n- â”Š28â”Š31â”Š\n- â”Š29â”Š32â”Š    this.assets = {};\n- â”Š30â”Š33â”Š    this.events = new Map();\n-+â”Š  â”Š34â”Š    this.keyStates = new Engine.KeyStates();\n- â”Š31â”Š35â”Š    this.context = canvas.getContext(\"2d\");\n- â”Š32â”Š36â”Š    this.bufferedCanvas = document.createElement(\"canvas\");\n- â”Š33â”Š37â”Š    this.bufferedContext = this.bufferedCanvas.getContext(\"2d\");\n+@@ -24,9 +24,13 @@\n+ â”Š24â”Š24â”Š\n+ â”Š25â”Š25â”Š    // We want to focus on the canvas once we press on it\n+ â”Š26â”Š26â”Š    canvas.addEventListener(\"mousedown\", canvas.focus.bind(canvas), false);\n++â”Š  â”Š27â”Š    // Key flags will be registered by the \"KeyStates\" instance\n++â”Š  â”Š28â”Š    canvas.addEventListener(\"keydown\", onKeyDown.bind(this), false);\n++â”Š  â”Š29â”Š    canvas.addEventListener(\"keyup\", onKeyUp.bind(this), false);\n+ â”Š27â”Š30â”Š\n+ â”Š28â”Š31â”Š    this.assets = {};\n+ â”Š29â”Š32â”Š    this.events = new Map();\n++â”Š  â”Š33â”Š    this.keyStates = new Engine.KeyStates();\n+ â”Š30â”Š34â”Š    this.context = canvas.getContext(\"2d\");\n+ â”Š31â”Š35â”Š    this.bufferedCanvas = document.createElement(\"canvas\");\n+ â”Š32â”Š36â”Š    this.bufferedContext = this.bufferedCanvas.getContext(\"2d\");\n ```\n ```diff\n-@@ -109,4 +113,19 @@\n- â”Š109â”Š113â”Š    this.events.delete(listener);\n- â”Š110â”Š114â”Š    this.canvas.removeEventListener(type, boundListener, false);\n- â”Š111â”Š115â”Š  }\n--â”Š112â”Š   â”Š};ðŸš«â†µ\n-+â”Š   â”Š116â”Š};\n-+â”Š   â”Š117â”Š\n-+â”Š   â”Š118â”Šfunction onKeyDown(e) {\n-+â”Š   â”Š119â”Š  // Once we're focused on the canvas, we want nothing else to happen\n-+â”Š   â”Š120â”Š  // besides events the game is listening to. For example, when we press\n-+â”Š   â”Š121â”Š  // the arrow keys, this will prevent the screen from scrolling\n-+â”Š   â”Š122â”Š  e.preventDefault();\n-+â”Š   â”Š123â”Š  // Register key press\n-+â”Š   â”Š124â”Š  this.keyStates.add(e.keyCode);\n-+â”Š   â”Š125â”Š}\n-+â”Š   â”Š126â”Š\n-+â”Š   â”Š127â”Šfunction onKeyUp(e) {\n-+â”Š   â”Š128â”Š  e.preventDefault();\n-+â”Š   â”Š129â”Š  // Register key release\n-+â”Š   â”Š130â”Š  this.keyStates.remove(e.keyCode);\n-+â”Š   â”Š131â”Š}\n+@@ -96,4 +100,19 @@\n+ â”Š 96â”Š100â”Š    this.events.delete(listener);\n+ â”Š 97â”Š101â”Š    this.canvas.removeEventListener(type, boundListener, false);\n+ â”Š 98â”Š102â”Š  }\n+-â”Š 99â”Š   â”Š};ðŸš«â†µ\n++â”Š   â”Š103â”Š};\n++â”Š   â”Š104â”Š\n++â”Š   â”Š105â”Šfunction onKeyDown(e) {\n++â”Š   â”Š106â”Š  // Once we're focused on the canvas, we want nothing else to happen\n++â”Š   â”Š107â”Š  // besides events the game is listening to. For example, when we press\n++â”Š   â”Š108â”Š  // the arrow keys, this will prevent the screen from scrolling\n++â”Š   â”Š109â”Š  e.preventDefault();\n++â”Š   â”Š110â”Š  // Register key press\n++â”Š   â”Š111â”Š  this.keyStates.add(e.keyCode);\n++â”Š   â”Š112â”Š}\n++â”Š   â”Š113â”Š\n++â”Š   â”Š114â”Šfunction onKeyUp(e) {\n++â”Š   â”Š115â”Š  e.preventDefault();\n++â”Š   â”Š116â”Š  // Register key release\n++â”Š   â”Š117â”Š  this.keyStates.remove(e.keyCode);\n++â”Š   â”Š118â”Š}\n ```\n [}]: #\n \n@@ -574,60 +561,53 @@ Now that we have the `screen` class available for us, let's apply it to the main\n \n ##### Changed resources/scripts/engine/game.js\n ```diff\n-@@ -31,6 +31,7 @@\n- â”Š31â”Š31â”Š\n- â”Š32â”Š32â”Š    this.assets = {};\n- â”Š33â”Š33â”Š    this.events = new Map();\n-+â”Š  â”Š34â”Š    this.screen = new Engine.Screen(this);\n- â”Š34â”Š35â”Š    this.keyStates = new Engine.KeyStates();\n- â”Š35â”Š36â”Š    this.context = canvas.getContext(\"2d\");\n- â”Š36â”Š37â”Š    this.bufferedCanvas = document.createElement(\"canvas\");\n+@@ -30,6 +30,7 @@\n+ â”Š30â”Š30â”Š\n+ â”Š31â”Š31â”Š    this.assets = {};\n+ â”Š32â”Š32â”Š    this.events = new Map();\n++â”Š  â”Š33â”Š    this.screen = new Engine.Screen(this);\n+ â”Š33â”Š34â”Š    this.keyStates = new Engine.KeyStates();\n+ â”Š34â”Š35â”Š    this.context = canvas.getContext(\"2d\");\n+ â”Š35â”Š36â”Š    this.bufferedCanvas = document.createElement(\"canvas\");\n ```\n ```diff\n-@@ -48,6 +49,7 @@\n- â”Š48â”Š49â”Š      this.context.beginPath();\n- â”Š49â”Š50â”Š      this.context.rect(0, 0, this.canvas.width, this.canvas.height);\n- â”Š50â”Š51â”Š      this.context.fill();\n-+â”Š  â”Š52â”Š      this.drawScreen(this.context);\n- â”Š51â”Š53â”Š    }\n- â”Š52â”Š54â”Š    // If not debugging, use double buffer to prevent flickering\n- â”Š53â”Š55â”Š    else {\n+@@ -39,13 +40,19 @@\n+ â”Š39â”Š40â”Š  }\n+ â”Š40â”Š41â”Š\n+ â”Š41â”Š42â”Š  draw() {\n+-â”Š42â”Š  â”Š    // Draw a black screen by default\n+ â”Š43â”Š43â”Š    this.context.restore();\n+ â”Š44â”Š44â”Š    this.context.fillStyle = \"black\";\n+ â”Š45â”Š45â”Š    this.context.save();\n+ â”Š46â”Š46â”Š    this.context.beginPath();\n+ â”Š47â”Š47â”Š    this.context.rect(0, 0, this.canvas.width, this.canvas.height);\n+ â”Š48â”Š48â”Š    this.context.fill();\n++â”Š  â”Š49â”Š    this.drawScreen(this.context);\n++â”Š  â”Š50â”Š  }\n++â”Š  â”Š51â”Š\n++â”Š  â”Š52â”Š  drawScreen(context) {\n++â”Š  â”Š53â”Š    // If screen's assets are not yet loaded, don't draw it\n++â”Š  â”Š54â”Š    if (this.screen.loading) return;\n++â”Š  â”Š55â”Š    if (this.screen.draw) this.screen.draw(context);\n+ â”Š49â”Š56â”Š  }\n+ â”Š50â”Š57â”Š\n+ â”Š51â”Š58â”Š  update() {\n ```\n ```diff\n-@@ -57,10 +59,17 @@\n- â”Š57â”Š59â”Š      this.bufferedContext.beginPath();\n- â”Š58â”Š60â”Š      this.bufferedContext.rect(0, 0, this.canvas.width, this.canvas.height);\n- â”Š59â”Š61â”Š      this.bufferedContext.fill();\n-+â”Š  â”Š62â”Š      this.drawScreen(this.bufferedContext);\n- â”Š60â”Š63â”Š      this.context.drawImage(this.bufferedCanvas, 0, 0);\n- â”Š61â”Š64â”Š    }\n- â”Š62â”Š65â”Š  }\n- â”Š63â”Š66â”Š\n-+â”Š  â”Š67â”Š  drawScreen(context) {\n-+â”Š  â”Š68â”Š    // If screen's assets are not yet loaded, don't draw it\n+@@ -56,6 +63,13 @@\n+ â”Š56â”Š63â”Š    this.updateScreen(span / this.speed);\n+ â”Š57â”Š64â”Š  }\n+ â”Š58â”Š65â”Š\n++â”Š  â”Š66â”Š  updateScreen(span) {\n++â”Š  â”Š67â”Š    this.screen.age += span;\n++â”Š  â”Š68â”Š    // If screen's assets are not yet loaded, don't update it\n +â”Š  â”Š69â”Š    if (this.screen.loading) return;\n-+â”Š  â”Š70â”Š    if (this.screen.draw) this.screen.draw(context);\n++â”Š  â”Š70â”Š    if (this.screen.update) this.screen.update(span);\n +â”Š  â”Š71â”Š  }\n +â”Š  â”Š72â”Š\n- â”Š64â”Š73â”Š  update() {\n- â”Š65â”Š74â”Š    // Calculate the time elapsed\n- â”Š66â”Š75â”Š    let lastUpdate = this.lastUpdate;\n-```\n-```diff\n-@@ -69,6 +78,13 @@\n- â”Š69â”Š78â”Š    this.updateScreen(span / this.speed);\n- â”Š70â”Š79â”Š  }\n- â”Š71â”Š80â”Š\n-+â”Š  â”Š81â”Š  updateScreen(span) {\n-+â”Š  â”Š82â”Š    this.screen.age += span;\n-+â”Š  â”Š83â”Š    // If screen's assets are not yet loaded, don't update it\n-+â”Š  â”Š84â”Š    if (this.screen.loading) return;\n-+â”Š  â”Š85â”Š    if (this.screen.update) this.screen.update(span);\n-+â”Š  â”Š86â”Š  }\n-+â”Š  â”Š87â”Š\n- â”Š72â”Š88â”Š  // The main loop of the game\n- â”Š73â”Š89â”Š  loop() {\n- â”Š74â”Š90â”Š    // If paused, don't run loop. The canvas will remain as is\n+ â”Š59â”Š73â”Š  // The main loop of the game\n+ â”Š60â”Š74â”Š  loop() {\n+ â”Š61â”Š75â”Š    // If paused, don't run loop. The canvas will remain as is\n ```\n [}]: #\n \n@@ -675,65 +655,65 @@ Now that we have the `assets loader` we can add the ability to change a screen.\n \n ##### Changed resources/scripts/engine/game.js\n ```diff\n-@@ -106,6 +106,58 @@\n- â”Š106â”Š106â”Š    this.playing = false;\n- â”Š107â”Š107â”Š  }\n- â”Š108â”Š108â”Š\n-+â”Š   â”Š109â”Š  changeScreen(Screen, ...screenArgs) {\n-+â”Š   â”Š110â”Š    // If there is a screen defined, dispose it first\n-+â”Š   â”Š111â”Š    if (this.screen) {\n-+â”Š   â”Š112â”Š      this.unloadScreen();\n-+â”Š   â”Š113â”Š      this.screen.disposeEventListeners();\n-+â”Š   â”Š114â”Š    }\n-+â”Š   â”Š115â”Š\n-+â”Š   â”Š116â”Š    this.screen = new Screen(this, ...screenArgs);\n-+â”Š   â”Š117â”Š\n-+â”Š   â”Š118â”Š    // Load screen assets\n-+â”Š   â”Š119â”Š    this.loadScreen(() => {\n-+â”Š   â”Š120â”Š      // Once assets are loaded, initialize event listeners\n-+â”Š   â”Š121â”Š      this.screen.initEventListeners();\n-+â”Š   â”Š122â”Š      // The \"initialize\" method is exactly the same as the constructor, only it runs\n-+â”Š   â”Š123â”Š      // once assets are available and event listeners are registered\n-+â”Š   â”Š124â”Š      this.screen.initialize(this, ...screenArgs);\n-+â”Š   â”Š125â”Š    });\n-+â”Š   â”Š126â”Š  }\n+@@ -91,6 +91,58 @@\n+ â”Š 91â”Š 91â”Š    this.playing = false;\n+ â”Š 92â”Š 92â”Š  }\n+ â”Š 93â”Š 93â”Š\n++â”Š   â”Š 94â”Š  changeScreen(Screen, ...screenArgs) {\n++â”Š   â”Š 95â”Š    // If there is a screen defined, dispose it first\n++â”Š   â”Š 96â”Š    if (this.screen) {\n++â”Š   â”Š 97â”Š      this.unloadScreen();\n++â”Š   â”Š 98â”Š      this.screen.disposeEventListeners();\n++â”Š   â”Š 99â”Š    }\n++â”Š   â”Š100â”Š\n++â”Š   â”Š101â”Š    this.screen = new Screen(this, ...screenArgs);\n++â”Š   â”Š102â”Š\n++â”Š   â”Š103â”Š    // Load screen assets\n++â”Š   â”Š104â”Š    this.loadScreen(() => {\n++â”Š   â”Š105â”Š      // Once assets are loaded, initialize event listeners\n++â”Š   â”Š106â”Š      this.screen.initEventListeners();\n++â”Š   â”Š107â”Š      // The \"initialize\" method is exactly the same as the constructor, only it runs\n++â”Š   â”Š108â”Š      // once assets are available and event listeners are registered\n++â”Š   â”Š109â”Š      this.screen.initialize(this, ...screenArgs);\n++â”Š   â”Š110â”Š    });\n++â”Š   â”Š111â”Š  }\n++â”Š   â”Š112â”Š\n++â”Š   â”Š113â”Š  // Loads screen assets and invokes callback once loading is finished\n++â”Š   â”Š114â”Š  loadScreen(callback = _.noop) {\n++â”Š   â”Š115â”Š    if (!this.screen.load) return callback();\n++â”Š   â”Š116â”Š\n++â”Š   â”Š117â”Š    this.screen.loading = true;\n++â”Š   â”Š118â”Š    // The number of assets to load\n++â”Š   â”Š119â”Š    let loadsize = 0;\n++â”Š   â”Š120â”Š\n++â”Š   â”Š121â”Š    // We use the \"after\" method because we want the following callback to be invoked\n++â”Š   â”Š122â”Š    // only once all assets are loaded\n++â”Š   â”Š123â”Š    let onload = _.after(loadsize, () => {\n++â”Š   â”Š124â”Š      delete this.screen.loading;\n++â”Š   â”Š125â”Š      callback();\n++â”Š   â”Š126â”Š    });\n +â”Š   â”Š127â”Š\n-+â”Š   â”Š128â”Š  // Loads screen assets and invokes callback once loading is finished\n-+â”Š   â”Š129â”Š  loadScreen(callback = _.noop) {\n-+â”Š   â”Š130â”Š    if (!this.screen.load) return callback();\n-+â”Š   â”Š131â”Š\n-+â”Š   â”Š132â”Š    this.screen.loading = true;\n-+â”Š   â”Š133â”Š    // The number of assets to load\n-+â”Š   â”Š134â”Š    let loadsize = 0;\n-+â”Š   â”Š135â”Š\n-+â”Š   â”Š136â”Š    // We use the \"after\" method because we want the following callback to be invoked\n-+â”Š   â”Š137â”Š    // only once all assets are loaded\n-+â”Š   â”Š138â”Š    let onload = _.after(loadsize, () => {\n-+â”Š   â”Š139â”Š      delete this.screen.loading;\n-+â”Š   â”Š140â”Š      callback();\n-+â”Š   â”Š141â”Š    });\n-+â”Š   â”Š142â”Š\n-+â”Š   â”Š143â”Š    // This object can load assets\n-+â”Š   â”Š144â”Š    let assetsLoader = new Engine.AssetsLoader(() => {\n-+â”Š   â”Š145â”Š      loadsize++;\n-+â”Š   â”Š146â”Š      return () => onload();\n-+â”Š   â”Š147â”Š    });\n-+â”Š   â”Š148â”Š\n-+â”Š   â”Š149â”Š    // The \"load\" method returns the assets loaded by the screen\n-+â”Š   â”Š150â”Š    let screenAssets = this.screen.load(assetsLoader);\n-+â”Š   â”Š151â”Š    // The returned assets will be available on screen's assets object\n-+â”Š   â”Š152â”Š    _.extend(this.screen.assets, screenAssets);\n-+â”Š   â”Š153â”Š  }\n-+â”Š   â”Š154â”Š\n-+â”Š   â”Š155â”Š  // Disposes screen assets\n-+â”Š   â”Š156â”Š  unloadScreen() {\n-+â”Š   â”Š157â”Š    let assetsNames = this.screen.unload && this.screen.unload();\n-+â”Š   â”Š158â”Š    _.omit(this.assets, assetsNames);\n-+â”Š   â”Š159â”Š  }\n-+â”Š   â”Š160â”Š\n- â”Š109â”Š161â”Š  // Defines global assets\n- â”Š110â”Š162â”Š  extendAssets(assets) {\n- â”Š111â”Š163â”Š    _.extend(this.assets, assets);\n++â”Š   â”Š128â”Š    // This object can load assets\n++â”Š   â”Š129â”Š    let assetsLoader = new Engine.AssetsLoader(() => {\n++â”Š   â”Š130â”Š      loadsize++;\n++â”Š   â”Š131â”Š      return () => onload();\n++â”Š   â”Š132â”Š    });\n++â”Š   â”Š133â”Š\n++â”Š   â”Š134â”Š    // The \"load\" method returns the assets loaded by the screen\n++â”Š   â”Š135â”Š    let screenAssets = this.screen.load(assetsLoader);\n++â”Š   â”Š136â”Š    // The returned assets will be available on screen's assets object\n++â”Š   â”Š137â”Š    _.extend(this.screen.assets, screenAssets);\n++â”Š   â”Š138â”Š  }\n++â”Š   â”Š139â”Š\n++â”Š   â”Š140â”Š  // Disposes screen assets\n++â”Š   â”Š141â”Š  unloadScreen() {\n++â”Š   â”Š142â”Š    let assetsNames = this.screen.unload && this.screen.unload();\n++â”Š   â”Š143â”Š    _.omit(this.assets, assetsNames);\n++â”Š   â”Š144â”Š  }\n++â”Š   â”Š145â”Š\n+ â”Š 94â”Š146â”Š  // Defines global assets\n+ â”Š 95â”Š147â”Š  extendAssets(assets) {\n+ â”Š 96â”Š148â”Š    _.extend(this.assets, assets);\n ```\n [}]: #\n \ndiff --git a/manuals/views/step4.md b/manuals/views/step4.md\nindex 90831fe..5e20563 100644\n--- a/manuals/views/step4.md\n+++ b/manuals/views/step4.md\n@@ -43,7 +43,7 @@ And then we will implement the initial main menu screen:\n +â”Š  â”Š24â”Š    ]);\n +â”Š  â”Š25â”Š\n +â”Š  â”Š26â”Š    // Play it repeatedly, back and forth\n-+â”Š  â”Š27â”Š    this.instructionsAnim.repMode = \"full\";\n++â”Š  â”Š27â”Š    this.instructionsAnim.repetitionMode = \"full\";\n +â”Š  â”Š28â”Š    this.instructionsAnim.play();\n +â”Š  â”Š29â”Š  }\n +â”Š  â”Š30â”Š\ndiff --git a/manuals/views/step5.md b/manuals/views/step5.md\nindex a9f10e2..4c80cd5 100644\n--- a/manuals/views/step5.md\n+++ b/manuals/views/step5.md\n@@ -6,84 +6,92 @@\n \n In this step we will be creating all the necessary geometry shapes to form a snake; we're basically implementing the right infrastructure so in the next step we will be able to implement the game screen with ease. What exactly do I mean by \"geometry shapes\"? Well, our snake will be made out of circles, and lines. If we don't press any buttons at all, the snake should move forward at a straight line, and once we press on one of the arrow keys, the snake should move in a circular motion. Not only we want to draw the screen on the canvas, we also want to be able to detect collision with other snakes, since this is a \"Tron\" style game where we gonna fight against an opponent.\n \n-Keep in mind that a computer's precision is limited due its [binary representation in memory](https://en.wikipedia.org/wiki/Memory_cell_(binary)). We need to take into consideration that there might be a significant deviation when detecting collisions and intersections between geometry shapes, especially when elapsed time is not always guaranteed to stay precise. To handle these deviation issues, we're gonna create some utility functions and place then as an extension for the `Number` prototype:\n+Keep in mind that a computer's precision is limited due its [binary representation in memory](https://en.wikipedia.org/wiki/Memory_cell_(binary)). We need to take into consideration that there might be a significant deviation when detecting collisions and intersections between geometry shapes, especially when elapsed time is not always guaranteed to stay precise. To handle these deviation issues, we're gonna create some utility functions and place then in a new module called `Utils`:\n \n [{]: <helper> (diff_step 5.1)\n-#### Step 5.1: Extend 'Number' prototype\n+#### Step 5.1: Create utilities module\n \n-##### Added resources/scripts/extensions.js\n+##### Added resources/scripts/utils.js\n ```diff\n-@@ -0,0 +1,70 @@\n-+â”Š  â”Š 1â”ŠObject.defineProperties(Number.prototype, {\n-+â”Š  â”Š 2â”Š  // Fixed modulo method which can calculate modulo of negative numbers properly\n-+â”Š  â”Š 3â”Š  // e.g., (-803).mod(800) returns 797\n-+â”Š  â”Š 4â”Š  \"mod\": {\n-+â”Š  â”Š 5â”Š    value(num) {\n-+â”Š  â”Š 6â”Š      return ((this % num) + num) % num;\n-+â”Š  â”Š 7â”Š    }\n-+â”Š  â”Š 8â”Š  },\n-+â”Š  â”Š 9â”Š\n-+â”Š  â”Š10â”Š  // Trims number and leaves the number of decimals specified.\n-+â”Š  â”Š11â”Š  // The \"mode\" argument specifies which math function should be invoked\n-+â”Š  â”Š12â”Š  // right after the number has been trimmed.\n-+â”Š  â”Š13â”Š  // e.g. 12.12345.trim(3, \"ceil\") returns 12.124\n-+â”Š  â”Š14â”Š  \"trim\": {\n-+â”Š  â”Š15â”Š    value(decimals, mode = \"round\") {\n-+â”Š  â”Š16â”Š      return Math[mode](this * Math.pow(10, decimals)) / Math.pow(10, decimals);\n-+â”Š  â”Š17â”Š    }\n-+â”Š  â”Š18â”Š  },\n-+â”Š  â”Š19â”Š\n-+â”Š  â”Š20â”Š  // Tells if number is in specified range based on given precision.\n-+â”Š  â”Š21â”Š  // See the \"compare\" method for more information about precision\n-+â”Š  â”Š22â”Š  \"isBetween\": {\n-+â”Š  â”Š23â”Š    value(num1, num2, precision) {\n-+â”Š  â”Š24â”Š      return this.compare(Math.min(num1, num2), \">=\", precision) &&\n-+â”Š  â”Š25â”Š      this.compare(Math.max(num1, num2), \"<=\", precision);\n-+â”Š  â”Š26â”Š    }\n-+â”Š  â”Š27â”Š  },\n-+â”Š  â”Š28â”Š\n-+â”Š  â”Š29â”Š  // Initiates comparison operator between this number and a given number, only here\n-+â”Š  â”Š30â”Š  // a precision can be specified\n-+â”Š  â”Š31â”Š  \"compare\": {\n-+â”Š  â”Š32â”Š    value(num) {\n-+â”Š  â”Š33â”Š      switch (arguments.length) {\n-+â”Š  â”Š34â”Š        case 2:\n-+â”Š  â”Š35â”Š          var precision = arguments[1];\n-+â”Š  â”Š36â”Š          break;\n-+â”Š  â”Š37â”Š        case 3:\n-+â”Š  â”Š38â”Š          var method = arguments[1];\n-+â”Š  â”Š39â”Š          precision = arguments[2];\n-+â”Š  â”Š40â”Š          break;\n-+â”Š  â”Š41â”Š      }\n-+â”Š  â”Š42â”Š\n-+â”Š  â”Š43â”Š      switch (precision) {\n-+â”Š  â”Š44â”Š        // Fixed precision, \"almost equal\" with a deviation of Îµ\n-+â”Š  â”Š45â”Š        case \"f\":\n-+â”Š  â”Š46â”Š          switch (method) {\n-+â”Š  â”Š47â”Š            case \"<\": case \"<=\": return this <= num + Number.EPSILON;\n-+â”Š  â”Š48â”Š            case \">\": case \">=\": return this >= num - Number.EPSILON;\n-+â”Š  â”Š49â”Š            default: return Math.abs(this - num) <= Number.EPSILON;\n-+â”Š  â”Š50â”Š          }\n-+â”Š  â”Š51â”Š        // Pixel precision, round comparison\n-+â”Š  â”Š52â”Š        case \"px\":\n-+â”Š  â”Š53â”Š          switch (method) {\n-+â”Š  â”Š54â”Š            case \"<\": case \"<=\": return Math.round(this) <= Math.round(num);\n-+â”Š  â”Š55â”Š            case \">\": case \">=\": return Math.round(this) >= Math.round(num);\n-+â”Š  â”Š56â”Š            default: return Math.round(this) == Math.round(num);\n-+â”Š  â”Š57â”Š          }\n-+â”Š  â”Š58â”Š        // Exact precision\n-+â”Š  â”Š59â”Š        default:\n-+â”Š  â”Š60â”Š          switch (method) {\n-+â”Š  â”Š61â”Š            case \"<\": return this < num;\n-+â”Š  â”Š62â”Š            case \"<=\": return this <= num;\n-+â”Š  â”Š63â”Š            case \">\": return this > num;\n-+â”Š  â”Š64â”Š            case \">=\": return this >= num;\n-+â”Š  â”Š65â”Š            default: return this === num;\n-+â”Š  â”Š66â”Š          }\n+@@ -0,0 +1,78 @@\n++â”Š  â”Š 1â”Š// A wrapper function for our utilities which will enable chaining\n++â”Š  â”Š 2â”Š// e.g. Utils().mod().trim().isBetween()...\n++â”Š  â”Š 3â”ŠUtils = function Utils(context) {\n++â”Š  â”Š 4â”Š  const chain = {};\n++â”Š  â”Š 5â”Š\n++â”Š  â”Š 6â”Š  Object.keys(Utils).forEach((utilName) => {\n++â”Š  â”Š 7â”Š    chain[utilName] = (...args) => {\n++â”Š  â”Š 8â”Š      const result = Utils[utilName](context, ...args);\n++â”Š  â”Š 9â”Š      return Utils(result);\n++â”Š  â”Š10â”Š    };\n++â”Š  â”Š11â”Š  });\n++â”Š  â”Š12â”Š\n++â”Š  â”Š13â”Š  // Returns the result of the chaining\n++â”Š  â”Š14â”Š  chain.value = () => context;\n++â”Š  â”Š15â”Š\n++â”Š  â”Š16â”Š  return chain;\n++â”Š  â”Š17â”Š};\n++â”Š  â”Š18â”Š\n++â”Š  â”Š19â”Š// Fixed modulo method which can calculate modulo of negative numbers properly\n++â”Š  â”Š20â”Š// e.g. (-803).mod(800) returns 797\n++â”Š  â”Š21â”ŠUtils.mod = function (context, num) {\n++â”Š  â”Š22â”Š  return ((context % num) + num) % num;\n++â”Š  â”Š23â”Š};\n++â”Š  â”Š24â”Š\n++â”Š  â”Š25â”Š// Trims number and leaves the number of decimals specified.\n++â”Š  â”Š26â”Š// The \"mode\" argument specifies which math function should be invoked\n++â”Š  â”Š27â”Š// right after the number has been trimmed.\n++â”Š  â”Š28â”Š// e.g. 12.12345.trim(3, \"ceil\") returns 12.124\n++â”Š  â”Š29â”ŠUtils.trim = function (context, decimals, mode = \"round\") {\n++â”Š  â”Š30â”Š  return Math[mode](context * Math.pow(10, decimals)) / Math.pow(10, decimals);\n++â”Š  â”Š31â”Š};\n++â”Š  â”Š32â”Š\n++â”Š  â”Š33â”Š// Tells if number is in specified range based on given precision.\n++â”Š  â”Š34â”Š// See the \"compare\" method for more information about precision\n++â”Š  â”Š35â”ŠUtils.isBetween = function (context, num1, num2, precision) {\n++â”Š  â”Š36â”Š  return Utils.compare(context, Math.min(num1, num2), \">=\", precision) &&\n++â”Š  â”Š37â”Š         Utils.compare(context, Math.max(num1, num2), \"<=\", precision);\n++â”Š  â”Š38â”Š};\n++â”Š  â”Š39â”Š\n++â”Š  â”Š40â”Š// Initiates comparison operator between context number and a given number, only here\n++â”Š  â”Š41â”Š// a precision can be specified\n++â”Š  â”Š42â”ŠUtils.compare = function (context, num, method, precision) {\n++â”Š  â”Š43â”Š  switch (arguments.length) {\n++â”Š  â”Š44â”Š    case 2:\n++â”Š  â”Š45â”Š      var precision = arguments[1];\n++â”Š  â”Š46â”Š      break;\n++â”Š  â”Š47â”Š    case 3:\n++â”Š  â”Š48â”Š      var method = arguments[1];\n++â”Š  â”Š49â”Š      precision = arguments[2];\n++â”Š  â”Š50â”Š      break;\n++â”Š  â”Š51â”Š  }\n++â”Š  â”Š52â”Š\n++â”Š  â”Š53â”Š  switch (precision) {\n++â”Š  â”Š54â”Š    // Fixed precision, \"almost equal\" with a deviation of Îµ\n++â”Š  â”Š55â”Š    case \"f\":\n++â”Š  â”Š56â”Š      switch (method) {\n++â”Š  â”Š57â”Š        case \"<\": case \"<=\": return context <= num + Number.EPSILON;\n++â”Š  â”Š58â”Š        case \">\": case \">=\": return context >= num - Number.EPSILON;\n++â”Š  â”Š59â”Š        default: return Math.abs(context - num) <= Number.EPSILON;\n++â”Š  â”Š60â”Š      }\n++â”Š  â”Š61â”Š    // Pixel precision, round comparison\n++â”Š  â”Š62â”Š    case \"px\":\n++â”Š  â”Š63â”Š      switch (method) {\n++â”Š  â”Š64â”Š        case \"<\": case \"<=\": return Math.round(context) <= Math.round(num);\n++â”Š  â”Š65â”Š        case \">\": case \">=\": return Math.round(context) >= Math.round(num);\n++â”Š  â”Š66â”Š        default: return Math.round(context) == Math.round(num);\n +â”Š  â”Š67â”Š      }\n-+â”Š  â”Š68â”Š    }\n-+â”Š  â”Š69â”Š  }\n-+â”Š  â”Š70â”Š});ðŸš«â†µ\n++â”Š  â”Š68â”Š    // Exact precision\n++â”Š  â”Š69â”Š    default:\n++â”Š  â”Š70â”Š      switch (method) {\n++â”Š  â”Š71â”Š        case \"<\": return context < num;\n++â”Š  â”Š72â”Š        case \"<=\": return context <= num;\n++â”Š  â”Š73â”Š        case \">\": return context > num;\n++â”Š  â”Š74â”Š        case \">=\": return context >= num;\n++â”Š  â”Š75â”Š        default: return context === num;\n++â”Š  â”Š76â”Š      }\n++â”Š  â”Š77â”Š  }\n++â”Š  â”Š78â”Š};ðŸš«â†µ\n ```\n \n ##### Changed views/game.html\n@@ -92,7 +100,7 @@ Keep in mind that a computer's precision is limited due its [binary representati\n  â”Š 8â”Š 8â”Š    <script type=\"text/javascript\" src=\"/libs/underscore.js\"></script>\n  â”Š 9â”Š 9â”Š\n  â”Š10â”Š10â”Š    <!-- Scripts -->\n-+â”Š  â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/extensions.js\"></script>\n++â”Š  â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/utils.js\"></script>\n  â”Š11â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n  â”Š12â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/restorable.js\"></script>\n  â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/font.js\"></script>\n@@ -124,71 +132,79 @@ And now that we have this module available to use, we can go ahead and implement\n \n ##### Added resources/scripts/engine/geometry/line.js\n ```diff\n-@@ -0,0 +1,57 @@\n+@@ -0,0 +1,65 @@\n +â”Š  â”Š 1â”ŠEngine.Geometry.Line = class Line {\n +â”Š  â”Š 2â”Š  // x1 - The first point's x value\n +â”Š  â”Š 3â”Š  // y1 - The first point's y value\n +â”Š  â”Š 4â”Š  // x1 - The second point's x value\n +â”Š  â”Š 5â”Š  // y2 - The second point's y value\n +â”Š  â”Š 6â”Š  constructor(x1, y1, x2, y2) {\n-+â”Š  â”Š 7â”Š    this.x1 = x1.trim(9);\n-+â”Š  â”Š 8â”Š    this.y1 = y1.trim(9);\n-+â”Š  â”Š 9â”Š    this.x2 = x2.trim(9);\n-+â”Š  â”Š10â”Š    this.y2 = y2.trim(9);\n++â”Š  â”Š 7â”Š    this.x1 = Utils.trim(x1, 9);\n++â”Š  â”Š 8â”Š    this.y1 = Utils.trim(y1, 9);\n++â”Š  â”Š 9â”Š    this.x2 = Utils.trim(x2, 9);\n++â”Š  â”Š10â”Š    this.y2 = Utils.trim(y2, 9);\n +â”Š  â”Š11â”Š  }\n +â”Š  â”Š12â”Š\n-+â”Š  â”Š13â”Š  // Gets the matching x value for a given y value\n-+â”Š  â”Š14â”Š  getX(y) {\n-+â”Š  â”Š15â”Š    let x = ((((y - this.y1) * (this.x2 - this.x1)) / (this.y2 - this.y1)) + this.x1).trim(9);\n-+â”Š  â”Š16â”Š    if (isNaN(x) || x.isBetween(this.x1, this.x2)) return x;\n++â”Š  â”Š13â”Š  // Draws the line on the given context\n++â”Š  â”Š14â”Š  draw(context) {\n++â”Š  â”Š15â”Š    context.moveTo(this.x1, this.y1);\n++â”Š  â”Š16â”Š    context.lineTo(this.x2, this.y2);\n +â”Š  â”Š17â”Š  }\n +â”Š  â”Š18â”Š\n-+â”Š  â”Š19â”Š  // Gets the matching y value for a given x value\n-+â”Š  â”Š20â”Š  getY(x) {\n-+â”Š  â”Š21â”Š    let y = ((((x - this.x1) * (this.y2 - this.y1)) / (this.x2 - this.x1)) + this.y1).trim(9);\n-+â”Š  â”Š22â”Š    if (isNaN(y) || y.isBetween(this.y1, this.y2)) return y;\n++â”Š  â”Š19â”Š  // Gets the matching x value for a given y value\n++â”Š  â”Š20â”Š  getX(y) {\n++â”Š  â”Š21â”Š    let x = Utils.trim((((y - this.y1) * (this.x2 - this.x1)) / (this.y2 - this.y1)) + this.x1, 9);\n++â”Š  â”Š22â”Š    if (isNaN(x) || Utils.isBetween(x, this.x1, this.x2)) return x;\n +â”Š  â”Š23â”Š  }\n +â”Š  â”Š24â”Š\n-+â”Š  â”Š25â”Š  // Returns if line has given point\n-+â”Š  â”Š26â”Š  hasPoint(x, y) {\n-+â”Š  â”Š27â”Š    if (!this.boundsHavePoint(x, y)) return false;\n-+â”Š  â”Š28â”Š    let m = ((this.y2 - this.y1) / (this.x2 - this.x1)).trim(9);\n-+â”Š  â”Š29â”Š    return (y - this.y1) / (x - this.x1) == m;\n-+â”Š  â”Š30â”Š  }\n-+â”Š  â”Š31â”Š\n-+â”Š  â”Š32â”Š  // Returns if given point is contained by the bounds aka cage of line\n-+â”Š  â”Š33â”Š  boundsHavePoint(x, y) {\n-+â”Š  â”Š34â”Š    return x.isBetween(this.x1, this.x2) &&\n-+â”Š  â”Š35â”Š    y.isBetween(this.y1, this.y2);\n++â”Š  â”Š25â”Š  // Gets the matching y value for a given x value\n++â”Š  â”Š26â”Š  getY(x) {\n++â”Š  â”Š27â”Š    let y = Utils.trim((((x - this.x1) * (this.y2 - this.y1)) / (this.x2 - this.x1)) + this.y1, 9);\n++â”Š  â”Š28â”Š    if (isNaN(y) || Utils.isBetween(y, this.y1, this.y2)) return y;\n++â”Š  â”Š29â”Š  }\n++â”Š  â”Š30â”Š\n++â”Š  â”Š31â”Š  // Returns if line has given point\n++â”Š  â”Š32â”Š  hasPoint(x, y) {\n++â”Š  â”Š33â”Š    if (!this.boundsHavePoint(x, y)) return false;\n++â”Š  â”Š34â”Š    let m = Utils.trim((this.y2 - this.y1) / (this.x2 - this.x1), 9);\n++â”Š  â”Š35â”Š    return (y - this.y1) / (x - this.x1) == m;\n +â”Š  â”Š36â”Š  }\n +â”Š  â”Š37â”Š\n-+â”Š  â”Š38â”Š  getIntersection(shape) {\n-+â”Š  â”Š39â”Š    if (shape instanceof Engine.Geometry.Line)\n-+â”Š  â”Š40â”Š      return this.getLineIntersection(shape);\n-+â”Š  â”Š41â”Š  }\n-+â”Š  â”Š42â”Š\n-+â”Š  â”Š43â”Š  // line - line intersection method\n-+â”Š  â”Š44â”Š  getLineIntersection(line) {\n-+â”Š  â”Š45â”Š    if (!(((this.x1 - this.x2) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * (line.x1 - line.x2)))) return;\n-+â”Š  â”Š46â”Š\n-+â”Š  â”Š47â”Š    let x = (((((this.x1 * this.y2) - (this.y1 * this.x2)) * (line.x1 - line.x2)) - ((this.x1 - this.x2) * ((line.x1 * line.y2) - (line.y1 * line.x2)))) /\n-+â”Š  â”Š48â”Š        (((this.x1 - this.x2) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * (line.x1 - line.x2)))).trim(9);\n-+â”Š  â”Š49â”Š    let y = (((((this.x1 * this.y2) - (this.y1 * this.x2)) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * ((line.x1 * line.y2) - (line.y1 * line.x2)))) /\n-+â”Š  â”Š50â”Š        (((this.x1 - this.x2) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * (line.x1 - line.x2)))).trim(9);\n-+â”Š  â”Š51â”Š\n-+â”Š  â”Š52â”Š    if (x.isBetween(this.x1, this.x2) && x.isBetween(line.x1, line.x2) &&\n-+â”Š  â”Š53â”Š       y.isBetween(this.y1, this.y2) && y.isBetween(line.y1, line.y2)) {\n-+â”Š  â”Š54â”Š      return { x, y };\n-+â”Š  â”Š55â”Š    }\n-+â”Š  â”Š56â”Š  }\n-+â”Š  â”Š57â”Š};ðŸš«â†µ\n++â”Š  â”Š38â”Š  // Returns if given point is contained by the bounds aka cage of line\n++â”Š  â”Š39â”Š  boundsHavePoint(x, y) {\n++â”Š  â”Š40â”Š    return Utils.isBetween(x, this.x1, this.x2) &&\n++â”Š  â”Š41â”Š           Utils.isBetween(y, this.y1, this.y2);\n++â”Š  â”Š42â”Š  }\n++â”Š  â”Š43â”Š\n++â”Š  â”Š44â”Š  getIntersection(shape) {\n++â”Š  â”Š45â”Š    if (shape instanceof Engine.Geometry.Line)\n++â”Š  â”Š46â”Š      return this.getLineIntersection(shape);\n++â”Š  â”Š47â”Š  }\n++â”Š  â”Š48â”Š\n++â”Š  â”Š49â”Š  // line - line intersection method\n++â”Š  â”Š50â”Š  getLineIntersection(line) {\n++â”Š  â”Š51â”Š    // Escape if lines are parallel\n++â”Š  â”Š52â”Š    if (!(((this.x1 - this.x2) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * (line.x1 - line.x2)))) return;\n++â”Š  â”Š53â”Š\n++â”Š  â”Š54â”Š    // Intersection point formula\n++â”Š  â”Š55â”Š    let x = Utils.trim(((((this.x1 * this.y2) - (this.y1 * this.x2)) * (line.x1 - line.x2)) - ((this.x1 - this.x2) * ((line.x1 * line.y2) - (line.y1 * line.x2)))) /\n++â”Š  â”Š56â”Š        (((this.x1 - this.x2) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * (line.x1 - line.x2))), 9);\n++â”Š  â”Š57â”Š    let y = Utils.trim(((((this.x1 * this.y2) - (this.y1 * this.x2)) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * ((line.x1 * line.y2) - (line.y1 * line.x2)))) /\n++â”Š  â”Š58â”Š        (((this.x1 - this.x2) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * (line.x1 - line.x2))), 9);\n++â”Š  â”Š59â”Š\n++â”Š  â”Š60â”Š    if (Utils.isBetween(x, this.x1, this.x2) && Utils.isBetween(x, line.x1, line.x2) &&\n++â”Š  â”Š61â”Š        Utils.isBetween(y, this.y1, this.y2) && Utils.isBetween(y, line.y1, line.y2)) {\n++â”Š  â”Š62â”Š      return { x, y };\n++â”Š  â”Š63â”Š    }\n++â”Š  â”Š64â”Š  }\n++â”Š  â”Š65â”Š};ðŸš«â†µ\n ```\n \n ##### Changed views/game.html\n ```diff\n @@ -10,6 +10,7 @@\n  â”Š10â”Š10â”Š    <!-- Scripts -->\n- â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/extensions.js\"></script>\n+ â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/utils.js\"></script>\n  â”Š12â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n +â”Š  â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/geometry/line.js\"></script>\n  â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/restorable.js\"></script>\n@@ -246,7 +262,7 @@ These essentials should be loaded in a newly created view where we're gonna see\n +â”Š  â”Š16â”Š    <script type=\"text/javascript\" src=\"libs/underscore.js\"></script>\n +â”Š  â”Š17â”Š\n +â”Š  â”Š18â”Š    <!-- Scripts -->\n-+â”Š  â”Š19â”Š    <script type=\"text/javascript\" src=\"scripts/extensions.js\"></script>\n++â”Š  â”Š19â”Š    <script type=\"text/javascript\" src=\"scripts/utils.js\"></script>\n +â”Š  â”Š20â”Š    <script type=\"text/javascript\" src=\"scripts/namespaces.js\"></script>\n +â”Š  â”Š21â”Š\n +â”Š  â”Š22â”Š    <!-- Specs -->\n@@ -350,7 +366,7 @@ Now once we'll navigate to the `/test` sub-route (`localhost:8000/test` by defau\n ```diff\n @@ -18,8 +18,10 @@\n  â”Š18â”Š18â”Š    <!-- Scripts -->\n- â”Š19â”Š19â”Š    <script type=\"text/javascript\" src=\"scripts/extensions.js\"></script>\n+ â”Š19â”Š19â”Š    <script type=\"text/javascript\" src=\"scripts/utils.js\"></script>\n  â”Š20â”Š20â”Š    <script type=\"text/javascript\" src=\"scripts/namespaces.js\"></script>\n +â”Š  â”Š21â”Š    <script type=\"text/javascript\" src=\"scripts/engine/geometry/line.js\"></script>\n  â”Š21â”Š22â”Š\n@@ -369,7 +385,7 @@ Now if you'll refresh the spec runner page you should be able to a green screen\n \n ##### Added resources/scripts/engine/geometry/circle.js\n ```diff\n-@@ -0,0 +1,161 @@\n+@@ -0,0 +1,167 @@\n +â”Š   â”Š  1â”ŠEngine.Geometry.Circle = class Circle {\n +â”Š   â”Š  2â”Š  // x - The x value of the circle's center\n +â”Š   â”Š  3â”Š  // y - The y value of the circle's center\n@@ -377,166 +393,172 @@ Now if you'll refresh the spec runner page you should be able to a green screen\n +â”Š   â”Š  5â”Š  // rad1 - The first radian of the circle, not necessarily its beginning\n +â”Š   â”Š  6â”Š  // rad2 - The second radian of the circle, not necessarily its beginning\n +â”Š   â”Š  7â”Š  constructor(x, y, r, rad1, rad2) {\n-+â”Š   â”Š  8â”Š    this.x = x.trim(9);\n-+â”Š   â”Š  9â”Š    this.y = y.trim(9);\n-+â”Š   â”Š 10â”Š    this.r = r.trim(9);\n++â”Š   â”Š  8â”Š    this.x = Utils.trim(x, 9);\n++â”Š   â”Š  9â”Š    this.y = Utils.trim(y, 9);\n++â”Š   â”Š 10â”Š    this.r = Utils.trim(r, 9);\n +â”Š   â”Š 11â”Š\n +â”Š   â”Š 12â”Š    // Trimming mode is done based on which radian represents the ending and which radian\n +â”Š   â”Š 13â”Š    // represents the ending\n +â”Š   â”Š 14â”Š    if (rad1 > rad2) {\n-+â”Š   â”Š 15â”Š      this.rad1 = rad1.trim(9, \"floor\");\n-+â”Š   â”Š 16â”Š      this.rad2 = rad2.trim(9, \"ceil\");\n++â”Š   â”Š 15â”Š      this.rad1 = Utils.trim(rad1, 9, \"floor\");\n++â”Š   â”Š 16â”Š      this.rad2 = Utils.trim(rad2, 9, \"ceil\");\n +â”Š   â”Š 17â”Š    }\n +â”Š   â”Š 18â”Š    else {\n-+â”Š   â”Š 19â”Š      this.rad1 = rad1.trim(9, \"ceil\");\n-+â”Š   â”Š 20â”Š      this.rad2 = rad2.trim(9, \"floor\");\n++â”Š   â”Š 19â”Š      this.rad1 = Utils.trim(rad1, 9, \"ceil\");\n++â”Š   â”Š 20â”Š      this.rad2 = Utils.trim(rad2, 9, \"floor\");\n +â”Š   â”Š 21â”Š    }\n +â”Š   â”Š 22â”Š  }\n +â”Š   â”Š 23â”Š\n-+â”Š   â”Š 24â”Š  // Gets the matching x value for the given radian\n-+â”Š   â”Š 25â”Š  getX(rad) {\n-+â”Š   â”Š 26â”Š    if (!rad.trim(9).isBetween(this.rad1, this.rad2)) return;\n-+â”Š   â”Š 27â”Š    return ((this.r * Math.cos(rad)) + this.x).trim(9);\n-+â”Š   â”Š 28â”Š  }\n-+â”Š   â”Š 29â”Š\n-+â”Š   â”Š 30â”Š  // Gets the matching y value for the given radian\n-+â”Š   â”Š 31â”Š  getY(rad) {\n-+â”Š   â”Š 32â”Š    if (!rad.trim(9).isBetween(this.rad1, this.rad2)) return;\n-+â”Š   â”Š 33â”Š    return ((this.r * Math.sin(rad)) + this.y).trim(9);\n-+â”Š   â”Š 34â”Š  }\n-+â”Š   â”Š 35â”Š\n-+â”Š   â”Š 36â”Š  // Gets the matching point for the given radian\n-+â”Š   â”Š 37â”Š  getPoint(rad) {\n-+â”Š   â”Š 38â”Š    if (!rad.isBetween(this.rad1, this.rad2)) return;\n-+â”Š   â”Š 39â”Š\n-+â”Š   â”Š 40â”Š    return {\n-+â”Š   â”Š 41â”Š      x: ((this.r * Math.cos(rad)) + this.x).trim(9),\n-+â”Š   â”Š 42â”Š      y: ((this.r * Math.sin(rad)) + this.y).trim(9)\n-+â”Š   â”Š 43â”Š    };\n-+â”Š   â”Š 44â”Š  }\n-+â”Š   â”Š 45â”Š\n-+â”Š   â”Š 46â”Š  // Gets the matching radian for the given point\n-+â”Š   â”Š 47â”Š  getRad(x, y) {\n-+â”Š   â”Š 48â”Š    let rad = Math.atan2(y - this.y, x - this.x);\n-+â”Š   â”Š 49â”Š\n-+â”Š   â”Š 50â”Š    // If calculated radian is in circle's radian range, return it\n-+â”Š   â”Š 51â”Š    if (rad != null && rad.isBetween(this.rad1, this.rad2)) {\n-+â”Š   â”Š 52â”Š      return rad;\n-+â”Š   â”Š 53â”Š    }\n++â”Š   â”Š 24â”Š  // Draws the circle on the given context\n++â”Š   â”Š 25â”Š  draw(context) {\n++â”Š   â”Š 26â”Š    context.arc(this.x, this.y, this.r, this.rad1, this.rad2);\n++â”Š   â”Š 27â”Š  }\n++â”Š   â”Š 28â”Š\n++â”Š   â”Š 29â”Š  // Gets the matching x value for the given radian\n++â”Š   â”Š 30â”Š  getX(rad) {\n++â”Š   â”Š 31â”Š    if (!Utils(rad).trim(9).isBetween(this.rad1, this.rad2).value()) return;\n++â”Š   â”Š 32â”Š    return Utils.trim((this.r * Math.cos(rad)) + this.x, 9);\n++â”Š   â”Š 33â”Š  }\n++â”Š   â”Š 34â”Š\n++â”Š   â”Š 35â”Š  // Gets the matching y value for the given radian\n++â”Š   â”Š 36â”Š  getY(rad) {\n++â”Š   â”Š 37â”Š    if (!Utils(rad).trim(9).isBetween(this.rad1, this.rad2).value()) return;\n++â”Š   â”Š 38â”Š    return Utils.trim((this.r * Math.sin(rad)) + this.y, 9);\n++â”Š   â”Š 39â”Š  }\n++â”Š   â”Š 40â”Š\n++â”Š   â”Š 41â”Š  // Gets the matching point for the given radian\n++â”Š   â”Š 42â”Š  getPoint(rad) {\n++â”Š   â”Š 43â”Š    if (!Utils.isBetween(rad, this.rad1, this.rad2)) return;\n++â”Š   â”Š 44â”Š\n++â”Š   â”Š 45â”Š    return {\n++â”Š   â”Š 46â”Š      x: Utils.trim((this.r * Math.cos(rad)) + this.x, 9),\n++â”Š   â”Š 47â”Š      y: Utils.trim((this.r * Math.sin(rad)) + this.y, 9)\n++â”Š   â”Š 48â”Š    };\n++â”Š   â”Š 49â”Š  }\n++â”Š   â”Š 50â”Š\n++â”Š   â”Š 51â”Š  // Gets the matching radian for the given point\n++â”Š   â”Š 52â”Š  getRad(x, y) {\n++â”Š   â”Š 53â”Š    let rad = Math.atan2(y - this.y, x - this.x);\n +â”Š   â”Š 54â”Š\n-+â”Š   â”Š 55â”Š    // The calculated radian can still be in the circle's radian range in case\n-+â”Š   â”Š 56â”Š    // they completed several whole circles\n-+â”Š   â”Š 57â”Š    if (Math.abs(this.rad1) > Math.abs(this.rad2)) {\n-+â”Š   â”Š 58â”Š      var cycRad = this.rad1;\n-+â”Š   â”Š 59â”Š    }\n-+â”Š   â”Š 60â”Š    else {\n-+â”Š   â”Š 61â”Š      var cycRad = this.rad2;\n-+â”Š   â”Š 62â”Š    }\n-+â”Š   â”Š 63â”Š\n-+â”Š   â”Š 64â”Š    if ((rad + (2 * Math.PI * Math.floor(cycRad / (2 * Math.PI)))).trim(9).isBetween(this.rad1, this.rad2) ||\n-+â”Š   â”Š 65â”Š       (rad + (2 * Math.PI * Math.ceil(cycRad / (2 * Math.PI)))).trim(9).isBetween(this.rad1, this.rad2)) {\n-+â”Š   â”Š 66â”Š      return rad;\n++â”Š   â”Š 55â”Š    // If calculated radian is in circle's radian range, return it\n++â”Š   â”Š 56â”Š    if (rad != null && Utils.isBetween(rad, this.rad1, this.rad2)) {\n++â”Š   â”Š 57â”Š      return rad;\n++â”Š   â”Š 58â”Š    }\n++â”Š   â”Š 59â”Š\n++â”Š   â”Š 60â”Š    // The calculated radian can still be in the circle's radian range in case one\n++â”Š   â”Š 61â”Š    // of the radians is greater than 2 PIEs\n++â”Š   â”Š 62â”Š    if (Math.abs(this.rad1) > Math.abs(this.rad2)) {\n++â”Š   â”Š 63â”Š      var greatestRad = this.rad1;\n++â”Š   â”Š 64â”Š    }\n++â”Š   â”Š 65â”Š    else {\n++â”Š   â”Š 66â”Š      var greatestRad = this.rad2;\n +â”Š   â”Š 67â”Š    }\n-+â”Š   â”Š 68â”Š  }\n-+â”Š   â”Š 69â”Š\n-+â”Š   â”Š 70â”Š  // Returns if circle has given points\n-+â”Š   â”Š 71â”Š  hasPoint(x, y) {\n-+â”Š   â”Š 72â”Š    return this.getRad(x, y) != null;\n-+â”Š   â”Š 73â”Š  }\n-+â”Š   â”Š 74â”Š\n-+â”Š   â”Š 75â”Š  getIntersection(shape) {\n-+â”Š   â”Š 76â”Š    if (shape instanceof Engine.Geometry.Line)\n-+â”Š   â”Š 77â”Š      return this.getLineIntersection(shape);\n-+â”Š   â”Š 78â”Š    if (shape instanceof Engine.Geometry.Circle)\n-+â”Š   â”Š 79â”Š      return this.getCircleIntersection(shape);\n-+â”Š   â”Š 80â”Š  }\n-+â”Š   â”Š 81â”Š\n-+â”Š   â”Š 82â”Š  // circle - circle intersection method\n-+â”Š   â”Š 83â”Š  getCircleIntersection(circle) {\n-+â”Š   â”Š 84â”Š    let dx = circle.x - this.x;\n-+â”Š   â”Š 85â”Š    let dy = circle.y - this.y;\n-+â”Š   â”Š 86â”Š    let d = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\n++â”Š   â”Š 68â”Š\n++â”Š   â”Š 69â”Š    // Check if the absolute radian is in the circle's radian range\n++â”Š   â”Š 70â”Š    if (Utils(rad + (2 * Math.PI * Math.floor(greatestRad / (2 * Math.PI)))).trim(9).isBetween(this.rad1, this.rad2).value() ||\n++â”Š   â”Š 71â”Š        Utils(rad + (2 * Math.PI * Math.ceil(greatestRad / (2 * Math.PI)))).trim(9).isBetween(this.rad1, this.rad2).value()) {\n++â”Š   â”Š 72â”Š      return rad;\n++â”Š   â”Š 73â”Š    }\n++â”Š   â”Š 74â”Š  }\n++â”Š   â”Š 75â”Š\n++â”Š   â”Š 76â”Š  // Returns if circle has given points\n++â”Š   â”Š 77â”Š  hasPoint(x, y) {\n++â”Š   â”Š 78â”Š    return this.getRad(x, y) != null;\n++â”Š   â”Š 79â”Š  }\n++â”Š   â”Š 80â”Š\n++â”Š   â”Š 81â”Š  getIntersection(shape) {\n++â”Š   â”Š 82â”Š    if (shape instanceof Engine.Geometry.Line)\n++â”Š   â”Š 83â”Š      return this.getLineIntersection(shape);\n++â”Š   â”Š 84â”Š    if (shape instanceof Engine.Geometry.Circle)\n++â”Š   â”Š 85â”Š      return this.getCircleIntersection(shape);\n++â”Š   â”Š 86â”Š  }\n +â”Š   â”Š 87â”Š\n-+â”Š   â”Š 88â”Š    if (d > this.r + circle.r ||\n-+â”Š   â”Š 89â”Š       d < Math.abs(this.r - circle.r)) {\n-+â”Š   â”Š 90â”Š      return;\n-+â”Š   â”Š 91â”Š    }\n-+â”Š   â”Š 92â”Š\n-+â”Š   â”Š 93â”Š    let a = ((Math.pow(this.r, 2) - Math.pow(circle.r, 2)) + Math.pow(d, 2)) / (2 * d);\n-+â”Š   â”Š 94â”Š    let x = this.x + ((dx * a) / d);\n-+â”Š   â”Š 95â”Š    let y = this.y + ((dy * a) / d);\n-+â”Š   â”Š 96â”Š    let h = Math.sqrt(Math.pow(this.r, 2) - Math.pow(a, 2));\n-+â”Š   â”Š 97â”Š    let rx = (- dy * h) / d;\n-+â”Š   â”Š 98â”Š    let ry = (dx * h) / d;\n-+â”Š   â”Š 99â”Š\n-+â”Š   â”Š100â”Š    let interPoints = [\n-+â”Š   â”Š101â”Š      {\n-+â”Š   â”Š102â”Š        x: x + rx,\n-+â”Š   â”Š103â”Š        y: y + ry\n-+â”Š   â”Š104â”Š      },\n-+â”Š   â”Š105â”Š      {\n-+â”Š   â”Š106â”Š        x: x - rx,\n-+â”Š   â”Š107â”Š        y: y - ry\n-+â”Š   â”Š108â”Š      }\n-+â”Š   â”Š109â”Š    ]\n-+â”Š   â”Š110â”Š    .map(point => ({\n-+â”Š   â”Š111â”Š        x: point.x.trim(9),\n-+â”Š   â”Š112â”Š        y: point.y.trim(9)\n-+â”Š   â”Š113â”Š     }));\n-+â”Š   â”Š114â”Š\n-+â”Š   â”Š115â”Š    interPoints = _.uniq(interPoints, point => `(${point.x}, ${point.y})`);\n-+â”Š   â”Š116â”Š\n-+â”Š   â”Š117â”Š    [this, circle].forEach(function(circle) {\n-+â”Š   â”Š118â”Š      interPoints = interPoints.filter(point => circle.hasPoint(point.x, point.y));\n-+â”Š   â”Š119â”Š    });\n++â”Š   â”Š 88â”Š  // circle - circle intersection method\n++â”Š   â”Š 89â”Š  getCircleIntersection(circle) {\n++â”Š   â”Š 90â”Š    let dx = circle.x - this.x;\n++â”Š   â”Š 91â”Š    let dy = circle.y - this.y;\n++â”Š   â”Š 92â”Š    let d = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\n++â”Š   â”Š 93â”Š\n++â”Š   â”Š 94â”Š    if (d > this.r + circle.r ||\n++â”Š   â”Š 95â”Š       d < Math.abs(this.r - circle.r)) {\n++â”Š   â”Š 96â”Š      return;\n++â”Š   â”Š 97â”Š    }\n++â”Š   â”Š 98â”Š\n++â”Š   â”Š 99â”Š    let a = ((Math.pow(this.r, 2) - Math.pow(circle.r, 2)) + Math.pow(d, 2)) / (2 * d);\n++â”Š   â”Š100â”Š    let x = this.x + ((dx * a) / d);\n++â”Š   â”Š101â”Š    let y = this.y + ((dy * a) / d);\n++â”Š   â”Š102â”Š    let h = Math.sqrt(Math.pow(this.r, 2) - Math.pow(a, 2));\n++â”Š   â”Š103â”Š    let rx = (- dy * h) / d;\n++â”Š   â”Š104â”Š    let ry = (dx * h) / d;\n++â”Š   â”Š105â”Š\n++â”Š   â”Š106â”Š    let interPoints = [\n++â”Š   â”Š107â”Š      {\n++â”Š   â”Š108â”Š        x: x + rx,\n++â”Š   â”Š109â”Š        y: y + ry\n++â”Š   â”Š110â”Š      },\n++â”Š   â”Š111â”Š      {\n++â”Š   â”Š112â”Š        x: x - rx,\n++â”Š   â”Š113â”Š        y: y - ry\n++â”Š   â”Š114â”Š      }\n++â”Š   â”Š115â”Š    ]\n++â”Š   â”Š116â”Š    .map(point => ({\n++â”Š   â”Š117â”Š        x: Utils.trim(point.x, 9),\n++â”Š   â”Š118â”Š        y: Utils.trim(point.y, 9)\n++â”Š   â”Š119â”Š     }));\n +â”Š   â”Š120â”Š\n-+â”Š   â”Š121â”Š    if (interPoints.length > 0) return interPoints;\n-+â”Š   â”Š122â”Š  }\n-+â”Š   â”Š123â”Š\n-+â”Š   â”Š124â”Š  // circle - line intersection method\n-+â”Š   â”Š125â”Š  getLineIntersection(line) {\n-+â”Š   â”Š126â”Š    let x1 = line.x1 - this.x;\n-+â”Š   â”Š127â”Š    let x2 = line.x2 - this.x;\n-+â”Š   â”Š128â”Š    let y1 = line.y1 - this.y;\n-+â”Š   â”Š129â”Š    let y2 = line.y2 - this.y;\n-+â”Š   â”Š130â”Š    let dx = x2 - x1;\n-+â”Š   â”Š131â”Š    let dy = y2 - y1;\n-+â”Š   â”Š132â”Š    let d = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\n-+â”Š   â”Š133â”Š    let h = (x1 * y2) - (x2 * y1);\n-+â”Š   â”Š134â”Š    let delta = (Math.pow(this.r, 2) * Math.pow(d, 2)) - Math.pow(h, 2);\n-+â”Š   â”Š135â”Š\n-+â”Š   â”Š136â”Š    if (delta < 0) return;\n-+â”Š   â”Š137â”Š\n-+â”Š   â”Š138â”Š    let interPoints = [\n-+â”Š   â”Š139â”Š      {\n-+â”Š   â”Š140â”Š        x: (((h * dy) + (((dy / Math.abs(dy)) || 1) * dx * Math.sqrt(delta))) / Math.pow(d, 2)) + this.x,\n-+â”Š   â”Š141â”Š        y: (((-h * dx) + (Math.abs(dy) * Math.sqrt(delta))) / Math.pow(d, 2)) + this.y\n-+â”Š   â”Š142â”Š      },\n-+â”Š   â”Š143â”Š      {\n-+â”Š   â”Š144â”Š        x: (((h * dy) - (((dy / Math.abs(dy)) || 1) * dx * Math.sqrt(delta))) / Math.pow(d, 2)) + this.x,\n-+â”Š   â”Š145â”Š        y: (((-h * dx) - (Math.abs(dy) * Math.sqrt(delta))) / Math.pow(d, 2)) + this.y\n-+â”Š   â”Š146â”Š      }\n-+â”Š   â”Š147â”Š    ]\n-+â”Š   â”Š148â”Š    .map(point => ({\n-+â”Š   â”Š149â”Š        x: point.x.trim(9),\n-+â”Š   â”Š150â”Š        y: point.y.trim(9)\n-+â”Š   â”Š151â”Š    }))\n-+â”Š   â”Š152â”Š    .filter(point => {\n-+â”Š   â”Š153â”Š      return this.hasPoint(point.x, point.y) &&\n-+â”Š   â”Š154â”Š        line.boundsHavePoint(point.x, point.y);\n-+â”Š   â”Š155â”Š    });\n-+â”Š   â”Š156â”Š\n-+â”Š   â”Š157â”Š    interPoints = _.uniq(interPoints, point => `(${point.x}, ${point.y})`);\n-+â”Š   â”Š158â”Š\n-+â”Š   â”Š159â”Š    if (interPoints.length > 0) return interPoints;\n-+â”Š   â”Š160â”Š  }\n-+â”Š   â”Š161â”Š};ðŸš«â†µ\n++â”Š   â”Š121â”Š    interPoints = _.uniq(interPoints, point => `(${point.x}, ${point.y})`);\n++â”Š   â”Š122â”Š\n++â”Š   â”Š123â”Š    [this, circle].forEach(function(circle) {\n++â”Š   â”Š124â”Š      interPoints = interPoints.filter(point => circle.hasPoint(point.x, point.y));\n++â”Š   â”Š125â”Š    });\n++â”Š   â”Š126â”Š\n++â”Š   â”Š127â”Š    if (interPoints.length > 0) return interPoints;\n++â”Š   â”Š128â”Š  }\n++â”Š   â”Š129â”Š\n++â”Š   â”Š130â”Š  // circle - line intersection method\n++â”Š   â”Š131â”Š  getLineIntersection(line) {\n++â”Š   â”Š132â”Š    let x1 = line.x1 - this.x;\n++â”Š   â”Š133â”Š    let x2 = line.x2 - this.x;\n++â”Š   â”Š134â”Š    let y1 = line.y1 - this.y;\n++â”Š   â”Š135â”Š    let y2 = line.y2 - this.y;\n++â”Š   â”Š136â”Š    let dx = x2 - x1;\n++â”Š   â”Š137â”Š    let dy = y2 - y1;\n++â”Š   â”Š138â”Š    let d = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\n++â”Š   â”Š139â”Š    let h = (x1 * y2) - (x2 * y1);\n++â”Š   â”Š140â”Š    let delta = (Math.pow(this.r, 2) * Math.pow(d, 2)) - Math.pow(h, 2);\n++â”Š   â”Š141â”Š\n++â”Š   â”Š142â”Š    if (delta < 0) return;\n++â”Š   â”Š143â”Š\n++â”Š   â”Š144â”Š    let interPoints = [\n++â”Š   â”Š145â”Š      {\n++â”Š   â”Š146â”Š        x: (((h * dy) + (((dy / Math.abs(dy)) || 1) * dx * Math.sqrt(delta))) / Math.pow(d, 2)) + this.x,\n++â”Š   â”Š147â”Š        y: (((-h * dx) + (Math.abs(dy) * Math.sqrt(delta))) / Math.pow(d, 2)) + this.y\n++â”Š   â”Š148â”Š      },\n++â”Š   â”Š149â”Š      {\n++â”Š   â”Š150â”Š        x: (((h * dy) - (((dy / Math.abs(dy)) || 1) * dx * Math.sqrt(delta))) / Math.pow(d, 2)) + this.x,\n++â”Š   â”Š151â”Š        y: (((-h * dx) - (Math.abs(dy) * Math.sqrt(delta))) / Math.pow(d, 2)) + this.y\n++â”Š   â”Š152â”Š      }\n++â”Š   â”Š153â”Š    ]\n++â”Š   â”Š154â”Š    .map(point => ({\n++â”Š   â”Š155â”Š        x: Utils.trim(point.x, 9),\n++â”Š   â”Š156â”Š        y: Utils.trim(point.y, 9)\n++â”Š   â”Š157â”Š    }))\n++â”Š   â”Š158â”Š    .filter(point => {\n++â”Š   â”Š159â”Š      return this.hasPoint(point.x, point.y) &&\n++â”Š   â”Š160â”Š        line.boundsHavePoint(point.x, point.y);\n++â”Š   â”Š161â”Š    });\n++â”Š   â”Š162â”Š\n++â”Š   â”Š163â”Š    interPoints = _.uniq(interPoints, point => `(${point.x}, ${point.y})`);\n++â”Š   â”Š164â”Š\n++â”Š   â”Š165â”Š    if (interPoints.length > 0) return interPoints;\n++â”Š   â”Š166â”Š  }\n++â”Š   â”Š167â”Š};ðŸš«â†µ\n ```\n \n ##### Changed views/game.html\n ```diff\n @@ -11,6 +11,7 @@\n- â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/extensions.js\"></script>\n+ â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/utils.js\"></script>\n  â”Š12â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n  â”Š13â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/geometry/line.js\"></script>\n +â”Š  â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/geometry/circle.js\"></script>\n@@ -571,27 +593,27 @@ we can find the intersection between a circle and line by solving the systems fo\n \n ##### Changed resources/scripts/engine/geometry/line.js\n ```diff\n-@@ -38,6 +38,8 @@\n- â”Š38â”Š38â”Š  getIntersection(shape) {\n- â”Š39â”Š39â”Š    if (shape instanceof Engine.Geometry.Line)\n- â”Š40â”Š40â”Š      return this.getLineIntersection(shape);\n-+â”Š  â”Š41â”Š    if (shape instanceof Engine.Geometry.Circle)\n-+â”Š  â”Š42â”Š      return this.getCircleIntersection(shape);\n- â”Š41â”Š43â”Š  }\n- â”Š42â”Š44â”Š\n- â”Š43â”Š45â”Š  // line - line intersection method\n+@@ -44,6 +44,8 @@\n+ â”Š44â”Š44â”Š  getIntersection(shape) {\n+ â”Š45â”Š45â”Š    if (shape instanceof Engine.Geometry.Line)\n+ â”Š46â”Š46â”Š      return this.getLineIntersection(shape);\n++â”Š  â”Š47â”Š    if (shape instanceof Engine.Geometry.Circle)\n++â”Š  â”Š48â”Š      return this.getCircleIntersection(shape);\n+ â”Š47â”Š49â”Š  }\n+ â”Š48â”Š50â”Š\n+ â”Š49â”Š51â”Š  // line - line intersection method\n ```\n ```diff\n-@@ -54,4 +56,9 @@\n- â”Š54â”Š56â”Š      return { x, y };\n- â”Š55â”Š57â”Š    }\n- â”Š56â”Š58â”Š  }\n-+â”Š  â”Š59â”Š\n-+â”Š  â”Š60â”Š  // line - circle intersection method\n-+â”Š  â”Š61â”Š  getCircleIntersection(circle) {\n-+â”Š  â”Š62â”Š    return circle.getLineIntersection(this);\n-+â”Š  â”Š63â”Š  }\n- â”Š57â”Š64â”Š};ðŸš«â†µ\n+@@ -62,4 +64,9 @@\n+ â”Š62â”Š64â”Š      return { x, y };\n+ â”Š63â”Š65â”Š    }\n+ â”Š64â”Š66â”Š  }\n++â”Š  â”Š67â”Š\n++â”Š  â”Š68â”Š  // line - circle intersection method\n++â”Š  â”Š69â”Š  getCircleIntersection(circle) {\n++â”Š  â”Š70â”Š    return circle.getLineIntersection(this);\n++â”Š  â”Š71â”Š  }\n+ â”Š65â”Š72â”Š};ðŸš«â†µ\n ```\n [}]: #\n \n@@ -752,7 +774,7 @@ Then again a newly created geometry shape class should be tested against differe\n ##### Changed views/spec_runner.html\n ```diff\n @@ -19,9 +19,11 @@\n- â”Š19â”Š19â”Š    <script type=\"text/javascript\" src=\"scripts/extensions.js\"></script>\n+ â”Š19â”Š19â”Š    <script type=\"text/javascript\" src=\"scripts/utils.js\"></script>\n  â”Š20â”Š20â”Š    <script type=\"text/javascript\" src=\"scripts/namespaces.js\"></script>\n  â”Š21â”Š21â”Š    <script type=\"text/javascript\" src=\"scripts/engine/geometry/line.js\"></script>\n +â”Š  â”Š22â”Š    <script type=\"text/javascript\" src=\"scripts/engine/geometry/circle.js\"></script>\n@@ -776,7 +798,7 @@ Our final shape in the geometry module would be a polygon. Why a polygon? Since\n @@ -0,0 +1,58 @@\n +â”Š  â”Š 1â”ŠEngine.Geometry.Polygon = class Polygon {\n +â”Š  â”Š 2â”Š  // bounds - an array of arrays. Each sub-array represents the arguments vector which\n-+â”Š  â”Š 3â”Š  //   will be invoked by the line's construction method\n++â”Š  â”Š 3â”Š  // will be invoked by the line's construction method\n +â”Š  â”Š 4â”Š  constructor(...bounds) {\n +â”Š  â”Š 5â”Š    this.bounds = bounds.map(coords => new Engine.Geometry.Line(...coords));\n +â”Š  â”Š 6â”Š  }\n@@ -854,52 +876,52 @@ Again we will delegate the newly created intersection methods in the `Line` clas\n \n ##### Changed resources/scripts/engine/geometry/circle.js\n ```diff\n-@@ -77,6 +77,8 @@\n- â”Š77â”Š77â”Š      return this.getLineIntersection(shape);\n- â”Š78â”Š78â”Š    if (shape instanceof Engine.Geometry.Circle)\n- â”Š79â”Š79â”Š      return this.getCircleIntersection(shape);\n-+â”Š  â”Š80â”Š    if (shape instanceof Engine.Geometry.Polygon)\n-+â”Š  â”Š81â”Š      return this.getPolygonIntersection(shape);\n- â”Š80â”Š82â”Š  }\n- â”Š81â”Š83â”Š\n- â”Š82â”Š84â”Š  // circle - circle intersection method\n+@@ -83,6 +83,8 @@\n+ â”Š83â”Š83â”Š      return this.getLineIntersection(shape);\n+ â”Š84â”Š84â”Š    if (shape instanceof Engine.Geometry.Circle)\n+ â”Š85â”Š85â”Š      return this.getCircleIntersection(shape);\n++â”Š  â”Š86â”Š    if (shape instanceof Engine.Geometry.Polygon)\n++â”Š  â”Š87â”Š      return this.getPolygonIntersection(shape);\n+ â”Š86â”Š88â”Š  }\n+ â”Š87â”Š89â”Š\n+ â”Š88â”Š90â”Š  // circle - circle intersection method\n ```\n ```diff\n-@@ -158,4 +160,9 @@\n- â”Š158â”Š160â”Š\n- â”Š159â”Š161â”Š    if (interPoints.length > 0) return interPoints;\n- â”Š160â”Š162â”Š  }\n-+â”Š   â”Š163â”Š\n-+â”Š   â”Š164â”Š  // circle - polygon intersection method\n-+â”Š   â”Š165â”Š  getPolygonIntersection(polygon) {\n-+â”Š   â”Š166â”Š    return polygon.getCircleIntersection(this);\n-+â”Š   â”Š167â”Š  }\n- â”Š161â”Š168â”Š};ðŸš«â†µ\n+@@ -164,4 +166,9 @@\n+ â”Š164â”Š166â”Š\n+ â”Š165â”Š167â”Š    if (interPoints.length > 0) return interPoints;\n+ â”Š166â”Š168â”Š  }\n++â”Š   â”Š169â”Š\n++â”Š   â”Š170â”Š  // circle - polygon intersection method\n++â”Š   â”Š171â”Š  getPolygonIntersection(polygon) {\n++â”Š   â”Š172â”Š    return polygon.getCircleIntersection(this);\n++â”Š   â”Š173â”Š  }\n+ â”Š167â”Š174â”Š};ðŸš«â†µ\n ```\n \n ##### Changed resources/scripts/engine/geometry/line.js\n ```diff\n-@@ -40,6 +40,8 @@\n- â”Š40â”Š40â”Š      return this.getLineIntersection(shape);\n- â”Š41â”Š41â”Š    if (shape instanceof Engine.Geometry.Circle)\n- â”Š42â”Š42â”Š      return this.getCircleIntersection(shape);\n-+â”Š  â”Š43â”Š    if (shape instanceof Engine.Geometry.Polygon)\n-+â”Š  â”Š44â”Š      return this.getPolygonIntersection(shape);\n- â”Š43â”Š45â”Š  }\n- â”Š44â”Š46â”Š\n- â”Š45â”Š47â”Š  // line - line intersection method\n+@@ -46,6 +46,8 @@\n+ â”Š46â”Š46â”Š      return this.getLineIntersection(shape);\n+ â”Š47â”Š47â”Š    if (shape instanceof Engine.Geometry.Circle)\n+ â”Š48â”Š48â”Š      return this.getCircleIntersection(shape);\n++â”Š  â”Š49â”Š    if (shape instanceof Engine.Geometry.Polygon)\n++â”Š  â”Š50â”Š      return this.getPolygonIntersection(shape);\n+ â”Š49â”Š51â”Š  }\n+ â”Š50â”Š52â”Š\n+ â”Š51â”Š53â”Š  // line - line intersection method\n ```\n ```diff\n-@@ -61,4 +63,9 @@\n- â”Š61â”Š63â”Š  getCircleIntersection(circle) {\n- â”Š62â”Š64â”Š    return circle.getLineIntersection(this);\n- â”Š63â”Š65â”Š  }\n-+â”Š  â”Š66â”Š\n-+â”Š  â”Š67â”Š  // line - polygon intersection method\n-+â”Š  â”Š68â”Š  getPolygonIntersection(polygon) {\n-+â”Š  â”Š69â”Š    return polygon.getLineIntersection(this);\n-+â”Š  â”Š70â”Š  }\n- â”Š64â”Š71â”Š};ðŸš«â†µ\n+@@ -69,4 +71,9 @@\n+ â”Š69â”Š71â”Š  getCircleIntersection(circle) {\n+ â”Š70â”Š72â”Š    return circle.getLineIntersection(this);\n+ â”Š71â”Š73â”Š  }\n++â”Š  â”Š74â”Š\n++â”Š  â”Š75â”Š  // line - polygon intersection method\n++â”Š  â”Š76â”Š  getPolygonIntersection(polygon) {\n++â”Š  â”Š77â”Š    return polygon.getLineIntersection(this);\n++â”Š  â”Š78â”Š  }\n+ â”Š72â”Š79â”Š};ðŸš«â†µ\n ```\n [}]: #\n \n@@ -1049,7 +1071,7 @@ And now we can add the `Snake` class:\n \n ##### Added resources/scripts/game/entities/snake.js\n ```diff\n-@@ -0,0 +1,218 @@\n+@@ -0,0 +1,234 @@\n +â”Š   â”Š  1â”ŠGame.Entities.Snake = class Snake {\n +â”Š   â”Š  2â”Š  // Represents a snake data-structure which will eventually appear on screen.\n +â”Š   â”Š  3â”Š  // All the properties provided to the constructor are the initial values of\n@@ -1065,8 +1087,8 @@ And now we can add the `Snake` class:\n +â”Š   â”Š 13â”Š    // A snake is made out of many geometry shapes\n +â”Š   â”Š 14â”Š    this.shapes = [];\n +â”Š   â”Š 15â”Š    // A snake starts with a line\n-+â”Š   â”Š 16â”Š    this.currShape = new Engine.Geometry.Line(x, y, x, y);\n-+â”Š   â”Š 17â”Š    this.shapes.push(this.currShape);\n++â”Š   â”Š 16â”Š    this.currentShape = new Engine.Geometry.Line(x, y, x, y);\n++â”Š   â”Š 17â”Š    this.shapes.push(this.currentShape);\n +â”Š   â”Š 18â”Š    // A score can be provided in case we want to reserve previous scores from\n +â”Š   â”Š 19â”Š    // recent matches\n +â”Š   â”Š 20â”Š    this.score = options.score || 0;\n@@ -1091,183 +1113,199 @@ And now we can add the `Snake` class:\n +â”Š   â”Š 39â”Š      context.lineWidth = 3;\n +â”Š   â”Š 40â”Š      context.beginPath();\n +â”Š   â”Š 41â”Š\n-+â”Š   â”Š 42â”Š      // Use a different drawing method for line and circle\n-+â”Š   â”Š 43â”Š      if (shape instanceof Engine.Geometry.Line) {\n-+â”Š   â”Š 44â”Š        context.moveTo(shape.x1, shape.y1);\n-+â”Š   â”Š 45â”Š        context.lineTo(shape.x2, shape.y2);\n-+â”Š   â”Š 46â”Š      }\n-+â”Š   â”Š 47â”Š      else {\n-+â”Š   â”Š 48â”Š        context.arc(shape.x, shape.y, shape.r, shape.rad1, shape.rad2);\n-+â”Š   â”Š 49â”Š      }\n-+â”Š   â”Š 50â”Š\n-+â”Š   â”Š 51â”Š      context.stroke();\n-+â”Š   â”Š 52â”Š      context.restore();\n-+â”Š   â”Š 53â”Š    });\n-+â”Š   â”Š 54â”Š  }\n-+â”Š   â”Š 55â”Š\n-+â”Š   â”Š 56â”Š  update(span, width, height) {\n-+â”Š   â”Š 57â”Š    // Progress made based on elapsed time and velocity\n-+â”Š   â”Š 58â”Š    let step = (this.v * span) / 1000;\n-+â”Š   â”Š 59â”Š\n-+â”Š   â”Š 60â”Š    this.updateShapes(step, width, height);\n-+â”Š   â”Š 61â”Š    this.cycleThrough(step, width, height);\n++â”Š   â”Š 42â”Š      // Each shape has its own unique drawing method\n++â”Š   â”Š 43â”Š      shape.draw(context);\n++â”Š   â”Š 44â”Š\n++â”Š   â”Š 45â”Š      context.stroke();\n++â”Š   â”Š 46â”Š      context.restore();\n++â”Š   â”Š 47â”Š    });\n++â”Š   â”Š 48â”Š  }\n++â”Š   â”Š 49â”Š\n++â”Š   â”Š 50â”Š  update(span, width, height) {\n++â”Š   â”Š 51â”Š    // Progress made based on elapsed time and velocity\n++â”Š   â”Š 52â”Š    let step = (this.v * span) / 1000;\n++â”Š   â”Š 53â”Š\n++â”Š   â”Š 54â”Š    this.updateShapes(step, width, height);\n++â”Š   â”Š 55â”Š    this.cycleThrough(step, width, height);\n++â”Š   â”Š 56â”Š  }\n++â”Š   â”Š 57â”Š\n++â”Š   â”Š 58â”Š  // Updates shapes array based on progress made\n++â”Š   â”Š 59â”Š  updateShapes(step, width, height, options = {}) {\n++â”Š   â”Š 60â”Š    this.updateCurrentShape(step, options);\n++â”Š   â”Š 61â”Š    this.updateDirection(step, options);\n +â”Š   â”Š 62â”Š  }\n +â”Š   â”Š 63â”Š\n-+â”Š   â”Š 64â”Š  // Updates shapes array based on progress made\n-+â”Š   â”Š 65â”Š  updateShapes(step, width, height, options = {}) {\n-+â”Š   â”Š 66â”Š    // Line update logic\n-+â”Š   â”Š 67â”Š    if (this.currShape instanceof Engine.Geometry.Line) {\n-+â”Š   â”Š 68â”Š      let lastX = options.lastX || this.x;\n-+â”Š   â”Š 69â”Š      let lastY = options.lastY || this.y;\n-+â”Š   â”Š 70â”Š      this.x = options.x || this.currShape.x2;\n-+â”Š   â”Š 71â”Š      this.y = options.y || this.currShape.y2;\n-+â”Š   â”Š 72â”Š      this.lastBit = new Engine.Geometry.Line(lastX, lastY, this.x, this.y);\n-+â”Š   â”Š 73â”Š    }\n-+â”Š   â”Š 74â”Š    // Circle update logic\n-+â”Š   â”Š 75â”Š    else {\n-+â”Š   â”Š 76â”Š      let lastX = options.lastX || this.currShape.x;\n-+â”Š   â”Š 77â”Š      let lastY = options.lastY || this.currShape.y;\n-+â”Š   â”Š 78â”Š      let lastR = options.lastR || this.currShape.r;\n-+â”Š   â”Š 79â”Š\n-+â”Š   â”Š 80â”Š      // Update logic for left rotation\n-+â”Š   â”Š 81â”Š      if (this.direction == \"left\") {\n-+â”Š   â”Š 82â”Š        let lastRad = this.rad + (0.5 * Math.PI);\n-+â”Š   â”Š 83â”Š        let currShapePoint = this.currShape.getPoint(this.currShape.rad1);\n-+â”Š   â”Š 84â”Š        this.x = options.x || currShapePoint.x;\n-+â”Š   â”Š 85â”Š        this.y = options.y || currShapePoint.y;\n-+â”Š   â”Š 86â”Š        this.rad = this.currShape.rad1 - (0.5 * Math.PI);\n-+â”Š   â”Š 87â”Š        this.lastBit = new Engine.Geometry.Circle(lastX, lastY, lastR, this.currShape.rad1, lastRad);\n-+â”Š   â”Š 88â”Š      }\n-+â”Š   â”Š 89â”Š      // Update logic for right rotation\n-+â”Š   â”Š 90â”Š      else {\n-+â”Š   â”Š 91â”Š        let lastRad = this.rad - (0.5 * Math.PI);\n-+â”Š   â”Š 92â”Š        let currShapePoint = this.currShape.getPoint(this.currShape.rad2);\n-+â”Š   â”Š 93â”Š        this.x = options.x || currShapePoint.x;\n-+â”Š   â”Š 94â”Š        this.y = options.y || currShapePoint.y;\n-+â”Š   â”Š 95â”Š        this.rad = this.currShape.rad2 + (0.5 * Math.PI);\n-+â”Š   â”Š 96â”Š        this.lastBit = new Engine.Geometry.Circle(lastX, lastY, lastR, lastRad, this.currShape.rad2);\n-+â”Š   â”Š 97â”Š      }\n-+â”Š   â”Š 98â”Š    }\n-+â”Š   â”Š 99â”Š\n-+â”Š   â”Š100â”Š    // Update the direction based on pressed key\n-+â”Š   â”Š101â”Š    if (this.keyStates.get(this.leftKey))\n-+â”Š   â”Š102â”Š      var direction = \"left\";\n-+â”Š   â”Š103â”Š    else if (this.keyStates.get(this.rightKey))\n-+â”Š   â”Š104â”Š      var direction = \"right\";\n-+â”Š   â”Š105â”Š\n-+â”Š   â”Š106â”Š    // If there is no change direction, abort, unless we force it\n-+â”Š   â”Š107â”Š    if (direction != this.direction || options.force) {\n-+â”Š   â”Š108â”Š      this.direction = direction;\n-+â”Š   â”Š109â”Š\n-+â”Š   â”Š110â”Š      // This will push a new shape with new properties, based on the direction\n-+â”Š   â”Š111â”Š      switch (direction) {\n-+â”Š   â”Š112â”Š        case \"left\":\n-+â”Š   â”Š113â”Š          var angle = this.rad - (0.5 * Math.PI);\n-+â”Š   â”Š114â”Š          var rad = this.rad + (0.5 * Math.PI);\n-+â”Š   â”Š115â”Š          var x = this.x + (this.r * Math.cos(angle));\n-+â”Š   â”Š116â”Š          var y = this.y + (this.r * Math.sin(angle));\n-+â”Š   â”Š117â”Š          this.currShape = new Engine.Geometry.Circle(x, y, this.r, rad, rad);\n-+â”Š   â”Š118â”Š          break;\n-+â”Š   â”Š119â”Š        case \"right\":\n-+â”Š   â”Š120â”Š          angle = this.rad + (0.5 * Math.PI);\n-+â”Š   â”Š121â”Š          rad = this.rad - (0.5 * Math.PI);\n-+â”Š   â”Š122â”Š          x = this.x + (this.r * Math.cos(angle));\n-+â”Š   â”Š123â”Š          y = this.y + (this.r * Math.sin(angle));\n-+â”Š   â”Š124â”Š          this.currShape = new Engine.Geometry.Circle(x, y, this.r, rad, rad);\n-+â”Š   â”Š125â”Š          break;\n-+â”Š   â”Š126â”Š        default:\n-+â”Š   â”Š127â”Š          this.currShape = new Engine.Geometry.Line(this.x, this.y, this.x, this.y);\n-+â”Š   â”Š128â”Š      }\n-+â”Š   â”Š129â”Š\n-+â”Š   â”Š130â”Š      this.shapes.push(this.currShape);\n-+â”Š   â”Š131â”Š    }\n-+â”Š   â”Š132â”Š\n-+â”Š   â”Š133â”Š    // Extend the recent shape based on progress made\n-+â”Š   â”Š134â”Š    switch (direction) {\n-+â”Š   â”Š135â”Š      case \"left\":\n-+â”Š   â”Š136â”Š        this.currShape.rad1 -= step / this.r;\n-+â”Š   â”Š137â”Š        break;\n-+â”Š   â”Š138â”Š      case \"right\":\n-+â”Š   â”Š139â”Š        this.currShape.rad2 += step / this.r;\n++â”Š   â”Š 64â”Š  // Updates current shape\n++â”Š   â”Š 65â”Š  updateCurrentShape(step, options) {\n++â”Š   â”Š 66â”Š    if (this.currentShape instanceof Engine.Geometry.Line)\n++â”Š   â”Š 67â”Š      return this.updateCurrentLine(options);\n++â”Š   â”Š 68â”Š    if (this.currentShape instanceof Engine.Geometry.Circle)\n++â”Š   â”Š 69â”Š      return this.updateCurrentCircle(options);\n++â”Š   â”Š 70â”Š  }\n++â”Š   â”Š 71â”Š\n++â”Š   â”Š 72â”Š  // Updates current shape in case it is a line\n++â”Š   â”Š 73â”Š  updateCurrentLine(options) {\n++â”Š   â”Š 74â”Š    let lastX = options.lastX || this.x;\n++â”Š   â”Š 75â”Š    let lastY = options.lastY || this.y;\n++â”Š   â”Š 76â”Š    this.x = options.x || this.currentShape.x2;\n++â”Š   â”Š 77â”Š    this.y = options.y || this.currentShape.y2;\n++â”Š   â”Š 78â”Š    this.lastBit = new Engine.Geometry.Line(lastX, lastY, this.x, this.y);\n++â”Š   â”Š 79â”Š  }\n++â”Š   â”Š 80â”Š\n++â”Š   â”Š 81â”Š  // Updates current shape in case it is a circle\n++â”Š   â”Š 82â”Š  updateCurrentCircle(options) {\n++â”Š   â”Š 83â”Š    let lastX = options.lastX || this.currentShape.x;\n++â”Š   â”Š 84â”Š    let lastY = options.lastY || this.currentShape.y;\n++â”Š   â”Š 85â”Š    let lastR = options.lastR || this.currentShape.r;\n++â”Š   â”Š 86â”Š\n++â”Š   â”Š 87â”Š    // Update logic for left rotation\n++â”Š   â”Š 88â”Š    if (this.direction == \"left\") {\n++â”Š   â”Š 89â”Š      let lastRad = this.rad + (0.5 * Math.PI);\n++â”Š   â”Š 90â”Š      let currentShapePoint = this.currentShape.getPoint(this.currentShape.rad1);\n++â”Š   â”Š 91â”Š      this.x = options.x || currentShapePoint.x;\n++â”Š   â”Š 92â”Š      this.y = options.y || currentShapePoint.y;\n++â”Š   â”Š 93â”Š      this.rad = this.currentShape.rad1 - (0.5 * Math.PI);\n++â”Š   â”Š 94â”Š      this.lastBit = new Engine.Geometry.Circle(lastX, lastY, lastR, this.currentShape.rad1, lastRad);\n++â”Š   â”Š 95â”Š    }\n++â”Š   â”Š 96â”Š    // Update logic for right rotation\n++â”Š   â”Š 97â”Š    else {\n++â”Š   â”Š 98â”Š      let lastRad = this.rad - (0.5 * Math.PI);\n++â”Š   â”Š 99â”Š      let currentShapePoint = this.currentShape.getPoint(this.currentShape.rad2);\n++â”Š   â”Š100â”Š      this.x = options.x || currentShapePoint.x;\n++â”Š   â”Š101â”Š      this.y = options.y || currentShapePoint.y;\n++â”Š   â”Š102â”Š      this.rad = this.currentShape.rad2 + (0.5 * Math.PI);\n++â”Š   â”Š103â”Š      this.lastBit = new Engine.Geometry.Circle(lastX, lastY, lastR, lastRad, this.currentShape.rad2);\n++â”Š   â”Š104â”Š    }\n++â”Š   â”Š105â”Š  }\n++â”Š   â”Š106â”Š\n++â”Š   â”Š107â”Š  updateDirection(step, options) {\n++â”Š   â”Š108â”Š    // Update the direction based on pressed key\n++â”Š   â”Š109â”Š    if (this.keyStates.get(this.leftKey))\n++â”Š   â”Š110â”Š      var direction = \"left\";\n++â”Š   â”Š111â”Š    else if (this.keyStates.get(this.rightKey))\n++â”Š   â”Š112â”Š      var direction = \"right\";\n++â”Š   â”Š113â”Š\n++â”Š   â”Š114â”Š    this.changeDirection(step, direction, options);\n++â”Š   â”Š115â”Š    this.continueDirection(step, direction, options);\n++â”Š   â”Š116â”Š  }\n++â”Š   â”Š117â”Š\n++â”Š   â”Š118â”Š  // Change the recent shape type according to the given direction\n++â”Š   â”Š119â”Š  changeDirection(step, direction, options) {\n++â”Š   â”Š120â”Š    // If there is no change in direction, abort, unless we force it\n++â”Š   â”Š121â”Š    if (direction == this.direction && !options.force) return;\n++â”Š   â”Š122â”Š\n++â”Š   â”Š123â”Š    this.direction = direction;\n++â”Š   â”Š124â”Š\n++â”Š   â”Š125â”Š    // This will push a new shape with new properties, based on the direction\n++â”Š   â”Š126â”Š    switch (direction) {\n++â”Š   â”Š127â”Š      case \"left\":\n++â”Š   â”Š128â”Š        var angle = this.rad - (0.5 * Math.PI);\n++â”Š   â”Š129â”Š        var rad = this.rad + (0.5 * Math.PI);\n++â”Š   â”Š130â”Š        var x = this.x + (this.r * Math.cos(angle));\n++â”Š   â”Š131â”Š        var y = this.y + (this.r * Math.sin(angle));\n++â”Š   â”Š132â”Š        this.currentShape = new Engine.Geometry.Circle(x, y, this.r, rad, rad);\n++â”Š   â”Š133â”Š        break;\n++â”Š   â”Š134â”Š      case \"right\":\n++â”Š   â”Š135â”Š        angle = this.rad + (0.5 * Math.PI);\n++â”Š   â”Š136â”Š        rad = this.rad - (0.5 * Math.PI);\n++â”Š   â”Š137â”Š        x = this.x + (this.r * Math.cos(angle));\n++â”Š   â”Š138â”Š        y = this.y + (this.r * Math.sin(angle));\n++â”Š   â”Š139â”Š        this.currentShape = new Engine.Geometry.Circle(x, y, this.r, rad, rad);\n +â”Š   â”Š140â”Š        break;\n +â”Š   â”Š141â”Š      default:\n-+â”Š   â”Š142â”Š        this.currShape.x2 += step * Math.cos(this.rad);\n-+â”Š   â”Š143â”Š        this.currShape.y2 += step * Math.sin(this.rad);\n-+â”Š   â”Š144â”Š    }\n-+â”Š   â”Š145â”Š  }\n-+â”Š   â”Š146â”Š\n-+â”Š   â”Š147â”Š  // Handles case where snake is out limits and we need to render it from\n-+â”Š   â”Š148â”Š  // the other side of the canvas\n-+â”Š   â”Š149â”Š  cycleThrough(step, width, height) {\n-+â”Š   â”Š150â”Š    let intersectionPoint = this.getCanvasIntersection(width, height);\n-+â”Š   â”Š151â”Š\n-+â”Š   â”Š152â”Š    if (!intersectionPoint) return;\n-+â”Š   â”Š153â”Š\n-+â”Š   â”Š154â”Š    intersectionPoint = intersectionPoint[0];\n-+â”Š   â”Š155â”Š\n-+â”Š   â”Š156â”Š    // Re-calculate position based on canvas bounds\n-+â”Š   â”Š157â”Š    if (intersectionPoint.x % width == 0)\n-+â”Š   â”Š158â”Š      this.x = (this.x - width).mod(width);\n-+â”Š   â”Š159â”Š    if (intersectionPoint.y % height == 0)\n-+â”Š   â”Š160â”Š      this.y = (this.y - height).mod(height);\n-+â”Š   â”Š161â”Š\n-+â”Š   â”Š162â”Š    // Update shapes again based on custom properties\n-+â”Š   â”Š163â”Š    this.updateShapes(step, width, height, {\n-+â”Š   â”Š164â”Š      force: true,\n-+â”Š   â”Š165â”Š      lastX: this.x,\n-+â”Š   â”Š166â”Š      lastY: this.y,\n-+â”Š   â”Š167â”Š      x: this.x,\n-+â”Š   â”Š168â”Š      y: this.y\n-+â”Š   â”Š169â”Š    });\n-+â”Š   â”Š170â”Š  }\n++â”Š   â”Š142â”Š        this.currentShape = new Engine.Geometry.Line(this.x, this.y, this.x, this.y);\n++â”Š   â”Š143â”Š    }\n++â”Š   â”Š144â”Š\n++â”Š   â”Š145â”Š    this.shapes.push(this.currentShape);\n++â”Š   â”Š146â”Š  }\n++â”Š   â”Š147â”Š\n++â”Š   â”Š148â”Š  // Extend the recent shape based on progress made\n++â”Š   â”Š149â”Š  continueDirection(step, direction) {\n++â”Š   â”Š150â”Š    switch (direction) {\n++â”Š   â”Š151â”Š      case \"left\":\n++â”Š   â”Š152â”Š        this.currentShape.rad1 -= step / this.r;\n++â”Š   â”Š153â”Š        break;\n++â”Š   â”Š154â”Š      case \"right\":\n++â”Š   â”Š155â”Š        this.currentShape.rad2 += step / this.r;\n++â”Š   â”Š156â”Š        break;\n++â”Š   â”Š157â”Š      default:\n++â”Š   â”Š158â”Š        this.currentShape.x2 += step * Math.cos(this.rad);\n++â”Š   â”Š159â”Š        this.currentShape.y2 += step * Math.sin(this.rad);\n++â”Š   â”Š160â”Š    }\n++â”Š   â”Š161â”Š  }\n++â”Š   â”Š162â”Š\n++â”Š   â”Š163â”Š  // Handles case where snake is out limits and we need to render it from\n++â”Š   â”Š164â”Š  // the other side of the canvas\n++â”Š   â”Š165â”Š  cycleThrough(step, width, height) {\n++â”Š   â”Š166â”Š    let intersectionPoint = this.getCanvasIntersection(width, height);\n++â”Š   â”Š167â”Š\n++â”Š   â”Š168â”Š    if (!intersectionPoint) return;\n++â”Š   â”Š169â”Š\n++â”Š   â”Š170â”Š    intersectionPoint = intersectionPoint[0];\n +â”Š   â”Š171â”Š\n-+â”Š   â”Š172â”Š  // Gets intersection points between last bit and own shapes\n-+â”Š   â”Š173â”Š  getSelfIntersection() {\n-+â”Š   â”Š174â”Š    if (this.currShape instanceof Engine.Geometry.Circle &&\n-+â”Š   â”Š175â”Š       Math.abs(this.currShape.rad1 - this.currShape.rad2) >= 2 * Math.PI) {\n-+â”Š   â”Š176â”Š      if (this.direction == \"left\")\n-+â”Š   â”Š177â”Š        var rad = this.currShape.rad1;\n-+â”Š   â”Š178â”Š      else\n-+â”Š   â”Š179â”Š        var rad = this.currShape.rad2;\n-+â”Š   â”Š180â”Š\n-+â”Š   â”Š181â”Š      return this.currShape.getPoint(rad);\n-+â”Š   â”Š182â”Š    }\n-+â”Š   â”Š183â”Š\n-+â”Š   â”Š184â”Š    let result;\n-+â”Š   â”Š185â”Š\n-+â”Š   â”Š186â”Š    this.shapes.slice(0, -2).some(shape =>\n-+â”Š   â”Š187â”Š      result = this.lastBit.getIntersection(shape)\n-+â”Š   â”Š188â”Š    );\n-+â”Š   â”Š189â”Š\n-+â”Š   â”Š190â”Š    return result;\n-+â”Š   â”Š191â”Š  }\n-+â”Š   â”Š192â”Š\n-+â”Š   â”Š193â”Š  // Returns intersection points between snakes\n-+â”Š   â”Š194â”Š  getSnakeIntersection(snake) {\n-+â”Š   â”Š195â”Š    let result;\n++â”Š   â”Š172â”Š    // Re-calculate position based on canvas bounds\n++â”Š   â”Š173â”Š    if (intersectionPoint.x % width == 0)\n++â”Š   â”Š174â”Š      this.x = Utils.mod(this.x - width, width);\n++â”Š   â”Š175â”Š    if (intersectionPoint.y % height == 0)\n++â”Š   â”Š176â”Š      this.y = Utils.mod(this.y - height, height);\n++â”Š   â”Š177â”Š\n++â”Š   â”Š178â”Š    // Update shapes again based on custom properties\n++â”Š   â”Š179â”Š    this.updateShapes(step, width, height, {\n++â”Š   â”Š180â”Š      force: true,\n++â”Š   â”Š181â”Š      lastX: this.x,\n++â”Š   â”Š182â”Š      lastY: this.y,\n++â”Š   â”Š183â”Š      x: this.x,\n++â”Š   â”Š184â”Š      y: this.y\n++â”Š   â”Š185â”Š    });\n++â”Š   â”Š186â”Š  }\n++â”Š   â”Š187â”Š\n++â”Š   â”Š188â”Š  // Gets intersection points between last bit and own shapes\n++â”Š   â”Š189â”Š  getSelfIntersection() {\n++â”Š   â”Š190â”Š    if (this.currentShape instanceof Engine.Geometry.Circle &&\n++â”Š   â”Š191â”Š       Math.abs(this.currentShape.rad1 - this.currentShape.rad2) >= 2 * Math.PI) {\n++â”Š   â”Š192â”Š      if (this.direction == \"left\")\n++â”Š   â”Š193â”Š        var rad = this.currentShape.rad1;\n++â”Š   â”Š194â”Š      else\n++â”Š   â”Š195â”Š        var rad = this.currentShape.rad2;\n +â”Š   â”Š196â”Š\n-+â”Š   â”Š197â”Š    snake.shapes.some(shape =>\n-+â”Š   â”Š198â”Š      // Only last bit is relevant, if we reached this point it means that\n-+â”Š   â”Š199â”Š      // previous intersection will definitely fail\n-+â”Š   â”Š200â”Š      result = this.lastBit.getIntersection(shape)\n-+â”Š   â”Š201â”Š    );\n-+â”Š   â”Š202â”Š\n-+â”Š   â”Š203â”Š    return result;\n-+â”Š   â”Š204â”Š  }\n++â”Š   â”Š197â”Š      return this.currentShape.getPoint(rad);\n++â”Š   â”Š198â”Š    }\n++â”Š   â”Š199â”Š\n++â”Š   â”Š200â”Š    let result;\n++â”Š   â”Š201â”Š\n++â”Š   â”Š202â”Š    this.shapes.slice(0, -2).some(shape =>\n++â”Š   â”Š203â”Š      result = this.lastBit.getIntersection(shape)\n++â”Š   â”Š204â”Š    );\n +â”Š   â”Š205â”Š\n-+â”Š   â”Š206â”Š  // Returns intersection points between snake and canvas\n-+â”Š   â”Š207â”Š  getCanvasIntersection(width, height) {\n-+â”Š   â”Š208â”Š    // Canvas polygon\n-+â”Š   â”Š209â”Š    let canvasPolygon = new Engine.Geometry.Polygon(\n-+â”Š   â”Š210â”Š      [0, 0, width, 0],\n-+â”Š   â”Š211â”Š      [width, 0, width, height],\n-+â”Š   â”Š212â”Š      [width, height, 0, height],\n-+â”Š   â”Š213â”Š      [0, height, 0, 0]\n-+â”Š   â”Š214â”Š    );\n-+â”Š   â”Š215â”Š\n-+â”Š   â”Š216â”Š    return canvasPolygon.getIntersection(this.lastBit);\n-+â”Š   â”Š217â”Š  }\n-+â”Š   â”Š218â”Š};ðŸš«â†µ\n++â”Š   â”Š206â”Š    return result;\n++â”Š   â”Š207â”Š  }\n++â”Š   â”Š208â”Š\n++â”Š   â”Š209â”Š  // Returns intersection points between snakes\n++â”Š   â”Š210â”Š  getSnakeIntersection(snake) {\n++â”Š   â”Š211â”Š    let result;\n++â”Š   â”Š212â”Š\n++â”Š   â”Š213â”Š    snake.shapes.some(shape =>\n++â”Š   â”Š214â”Š      // Only last bit is relevant, if we reached this point it means that\n++â”Š   â”Š215â”Š      // previous intersection will definitely fail\n++â”Š   â”Š216â”Š      result = this.lastBit.getIntersection(shape)\n++â”Š   â”Š217â”Š    );\n++â”Š   â”Š218â”Š\n++â”Š   â”Š219â”Š    return result;\n++â”Š   â”Š220â”Š  }\n++â”Š   â”Š221â”Š\n++â”Š   â”Š222â”Š  // Returns intersection points between snake and canvas\n++â”Š   â”Š223â”Š  getCanvasIntersection(width, height) {\n++â”Š   â”Š224â”Š    // Canvas polygon\n++â”Š   â”Š225â”Š    let canvasPolygon = new Engine.Geometry.Polygon(\n++â”Š   â”Š226â”Š      [0, 0, width, 0],\n++â”Š   â”Š227â”Š      [width, 0, width, height],\n++â”Š   â”Š228â”Š      [width, height, 0, height],\n++â”Š   â”Š229â”Š      [0, height, 0, 0]\n++â”Š   â”Š230â”Š    );\n++â”Š   â”Š231â”Š\n++â”Š   â”Š232â”Š    return canvasPolygon.getIntersection(this.lastBit);\n++â”Š   â”Š233â”Š  }\n++â”Š   â”Š234â”Š};ðŸš«â†µ\n ```\n \n ##### Changed views/game.html\ndiff --git a/resources/scripts/engine/game.js b/resources/scripts/engine/game.js\nindex fae839e..6f5f67a 100644\n--- a/resources/scripts/engine/game.js\n+++ b/resources/scripts/engine/game.js\n@@ -1,7 +1,7 @@\n Engine.Game = class Game {\n-  // Frames rendered per second\n+  // The frequency of which each frame will be drawn in milliseconds\n   get fps() {\n-    return 60;\n+    return 1000 / 60;\n   }\n \n   // Game's run speed.\n@@ -10,9 +10,8 @@ Engine.Game = class Game {\n     return 1;\n   }\n \n-  constructor(canvas, debugging) {\n+  constructor(canvas) {\n     this.canvas = canvas;\n-    this.debugging = debugging;\n     this.lastUpdate = this.creation = new Date().getTime();\n \n     // Canvas dimensions must be set programmatically, otherwise you might encounter some\n@@ -41,27 +40,13 @@ Engine.Game = class Game {\n   }\n \n   draw() {\n-    // If debugging, don't use double buffer so we can see rendering in real time\n-    if (this.debugging) {\n-      this.context.restore();\n-      this.context.fillStyle = \"black\";\n-      this.context.save();\n-      this.context.beginPath();\n-      this.context.rect(0, 0, this.canvas.width, this.canvas.height);\n-      this.context.fill();\n-      this.drawScreen(this.context);\n-    }\n-    // If not debugging, use double buffer to prevent flickering\n-    else {\n-      this.bufferedContext.restore();\n-      this.bufferedContext.fillStyle = \"black\";\n-      this.bufferedContext.save();\n-      this.bufferedContext.beginPath();\n-      this.bufferedContext.rect(0, 0, this.canvas.width, this.canvas.height);\n-      this.bufferedContext.fill();\n-      this.drawScreen(this.bufferedContext);\n-      this.context.drawImage(this.bufferedCanvas, 0, 0);\n-    }\n+    this.context.restore();\n+    this.context.fillStyle = \"black\";\n+    this.context.save();\n+    this.context.beginPath();\n+    this.context.rect(0, 0, this.canvas.width, this.canvas.height);\n+    this.context.fill();\n+    this.drawScreen(this.context);\n   }\n \n   drawScreen(context) {\ndiff --git a/resources/scripts/engine/geometry/circle.js b/resources/scripts/engine/geometry/circle.js\nindex 8961cda..3a6320c 100644\n--- a/resources/scripts/engine/geometry/circle.js\n+++ b/resources/scripts/engine/geometry/circle.js\n@@ -5,41 +5,46 @@ Engine.Geometry.Circle = class Circle {\n   // rad1 - The first radian of the circle, not necessarily its beginning\n   // rad2 - The second radian of the circle, not necessarily its beginning\n   constructor(x, y, r, rad1, rad2) {\n-    this.x = x.trim(9);\n-    this.y = y.trim(9);\n-    this.r = r.trim(9);\n+    this.x = Utils.trim(x, 9);\n+    this.y = Utils.trim(y, 9);\n+    this.r = Utils.trim(r, 9);\n \n     // Trimming mode is done based on which radian represents the ending and which radian\n     // represents the ending\n     if (rad1 > rad2) {\n-      this.rad1 = rad1.trim(9, \"floor\");\n-      this.rad2 = rad2.trim(9, \"ceil\");\n+      this.rad1 = Utils.trim(rad1, 9, \"floor\");\n+      this.rad2 = Utils.trim(rad2, 9, \"ceil\");\n     }\n     else {\n-      this.rad1 = rad1.trim(9, \"ceil\");\n-      this.rad2 = rad2.trim(9, \"floor\");\n+      this.rad1 = Utils.trim(rad1, 9, \"ceil\");\n+      this.rad2 = Utils.trim(rad2, 9, \"floor\");\n     }\n   }\n \n+  // Draws the circle on the given context\n+  draw(context) {\n+    context.arc(this.x, this.y, this.r, this.rad1, this.rad2);\n+  }\n+\n   // Gets the matching x value for the given radian\n   getX(rad) {\n-    if (!rad.trim(9).isBetween(this.rad1, this.rad2)) return;\n-    return ((this.r * Math.cos(rad)) + this.x).trim(9);\n+    if (!Utils(rad).trim(9).isBetween(this.rad1, this.rad2).value()) return;\n+    return Utils.trim((this.r * Math.cos(rad)) + this.x, 9);\n   }\n \n   // Gets the matching y value for the given radian\n   getY(rad) {\n-    if (!rad.trim(9).isBetween(this.rad1, this.rad2)) return;\n-    return ((this.r * Math.sin(rad)) + this.y).trim(9);\n+    if (!Utils(rad).trim(9).isBetween(this.rad1, this.rad2).value()) return;\n+    return Utils.trim((this.r * Math.sin(rad)) + this.y, 9);\n   }\n \n   // Gets the matching point for the given radian\n   getPoint(rad) {\n-    if (!rad.isBetween(this.rad1, this.rad2)) return;\n+    if (!Utils.isBetween(rad, this.rad1, this.rad2)) return;\n \n     return {\n-      x: ((this.r * Math.cos(rad)) + this.x).trim(9),\n-      y: ((this.r * Math.sin(rad)) + this.y).trim(9)\n+      x: Utils.trim((this.r * Math.cos(rad)) + this.x, 9),\n+      y: Utils.trim((this.r * Math.sin(rad)) + this.y, 9)\n     };\n   }\n \n@@ -48,21 +53,22 @@ Engine.Geometry.Circle = class Circle {\n     let rad = Math.atan2(y - this.y, x - this.x);\n \n     // If calculated radian is in circle's radian range, return it\n-    if (rad != null && rad.isBetween(this.rad1, this.rad2)) {\n+    if (rad != null && Utils.isBetween(rad, this.rad1, this.rad2)) {\n       return rad;\n     }\n \n-    // The calculated radian can still be in the circle's radian range in case\n-    // they completed several whole circles\n+    // The calculated radian can still be in the circle's radian range in case one\n+    // of the radians is greater than 2 PIEs\n     if (Math.abs(this.rad1) > Math.abs(this.rad2)) {\n-      var cycRad = this.rad1;\n+      var greatestRad = this.rad1;\n     }\n     else {\n-      var cycRad = this.rad2;\n+      var greatestRad = this.rad2;\n     }\n \n-    if ((rad + (2 * Math.PI * Math.floor(cycRad / (2 * Math.PI)))).trim(9).isBetween(this.rad1, this.rad2) ||\n-       (rad + (2 * Math.PI * Math.ceil(cycRad / (2 * Math.PI)))).trim(9).isBetween(this.rad1, this.rad2)) {\n+    // Check if the absolute radian is in the circle's radian range\n+    if (Utils(rad + (2 * Math.PI * Math.floor(greatestRad / (2 * Math.PI)))).trim(9).isBetween(this.rad1, this.rad2).value() ||\n+        Utils(rad + (2 * Math.PI * Math.ceil(greatestRad / (2 * Math.PI)))).trim(9).isBetween(this.rad1, this.rad2).value()) {\n       return rad;\n     }\n   }\n@@ -110,8 +116,8 @@ Engine.Geometry.Circle = class Circle {\n       }\n     ]\n     .map(point => ({\n-        x: point.x.trim(9),\n-        y: point.y.trim(9)\n+        x: Utils.trim(point.x, 9),\n+        y: Utils.trim(point.y, 9)\n      }));\n \n     interPoints = _.uniq(interPoints, point => `(${point.x}, ${point.y})`);\n@@ -148,8 +154,8 @@ Engine.Geometry.Circle = class Circle {\n       }\n     ]\n     .map(point => ({\n-        x: point.x.trim(9),\n-        y: point.y.trim(9)\n+        x: Utils.trim(point.x, 9),\n+        y: Utils.trim(point.y, 9)\n     }))\n     .filter(point => {\n       return this.hasPoint(point.x, point.y) &&\ndiff --git a/resources/scripts/engine/geometry/line.js b/resources/scripts/engine/geometry/line.js\nindex 19177aa..ac8bbdc 100644\n--- a/resources/scripts/engine/geometry/line.js\n+++ b/resources/scripts/engine/geometry/line.js\n@@ -4,35 +4,41 @@ Engine.Geometry.Line = class Line {\n   // x1 - The second point's x value\n   // y2 - The second point's y value\n   constructor(x1, y1, x2, y2) {\n-    this.x1 = x1.trim(9);\n-    this.y1 = y1.trim(9);\n-    this.x2 = x2.trim(9);\n-    this.y2 = y2.trim(9);\n+    this.x1 = Utils.trim(x1, 9);\n+    this.y1 = Utils.trim(y1, 9);\n+    this.x2 = Utils.trim(x2, 9);\n+    this.y2 = Utils.trim(y2, 9);\n+  }\n+\n+  // Draws the line on the given context\n+  draw(context) {\n+    context.moveTo(this.x1, this.y1);\n+    context.lineTo(this.x2, this.y2);\n   }\n \n   // Gets the matching x value for a given y value\n   getX(y) {\n-    let x = ((((y - this.y1) * (this.x2 - this.x1)) / (this.y2 - this.y1)) + this.x1).trim(9);\n-    if (isNaN(x) || x.isBetween(this.x1, this.x2)) return x;\n+    let x = Utils.trim((((y - this.y1) * (this.x2 - this.x1)) / (this.y2 - this.y1)) + this.x1, 9);\n+    if (isNaN(x) || Utils.isBetween(x, this.x1, this.x2)) return x;\n   }\n \n   // Gets the matching y value for a given x value\n   getY(x) {\n-    let y = ((((x - this.x1) * (this.y2 - this.y1)) / (this.x2 - this.x1)) + this.y1).trim(9);\n-    if (isNaN(y) || y.isBetween(this.y1, this.y2)) return y;\n+    let y = Utils.trim((((x - this.x1) * (this.y2 - this.y1)) / (this.x2 - this.x1)) + this.y1, 9);\n+    if (isNaN(y) || Utils.isBetween(y, this.y1, this.y2)) return y;\n   }\n \n   // Returns if line has given point\n   hasPoint(x, y) {\n     if (!this.boundsHavePoint(x, y)) return false;\n-    let m = ((this.y2 - this.y1) / (this.x2 - this.x1)).trim(9);\n+    let m = Utils.trim((this.y2 - this.y1) / (this.x2 - this.x1), 9);\n     return (y - this.y1) / (x - this.x1) == m;\n   }\n \n   // Returns if given point is contained by the bounds aka cage of line\n   boundsHavePoint(x, y) {\n-    return x.isBetween(this.x1, this.x2) &&\n-    y.isBetween(this.y1, this.y2);\n+    return Utils.isBetween(x, this.x1, this.x2) &&\n+           Utils.isBetween(y, this.y1, this.y2);\n   }\n \n   getIntersection(shape) {\n@@ -46,15 +52,17 @@ Engine.Geometry.Line = class Line {\n \n   // line - line intersection method\n   getLineIntersection(line) {\n+    // Escape if lines are parallel\n     if (!(((this.x1 - this.x2) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * (line.x1 - line.x2)))) return;\n \n-    let x = (((((this.x1 * this.y2) - (this.y1 * this.x2)) * (line.x1 - line.x2)) - ((this.x1 - this.x2) * ((line.x1 * line.y2) - (line.y1 * line.x2)))) /\n-        (((this.x1 - this.x2) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * (line.x1 - line.x2)))).trim(9);\n-    let y = (((((this.x1 * this.y2) - (this.y1 * this.x2)) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * ((line.x1 * line.y2) - (line.y1 * line.x2)))) /\n-        (((this.x1 - this.x2) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * (line.x1 - line.x2)))).trim(9);\n+    // Intersection point formula\n+    let x = Utils.trim(((((this.x1 * this.y2) - (this.y1 * this.x2)) * (line.x1 - line.x2)) - ((this.x1 - this.x2) * ((line.x1 * line.y2) - (line.y1 * line.x2)))) /\n+        (((this.x1 - this.x2) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * (line.x1 - line.x2))), 9);\n+    let y = Utils.trim(((((this.x1 * this.y2) - (this.y1 * this.x2)) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * ((line.x1 * line.y2) - (line.y1 * line.x2)))) /\n+        (((this.x1 - this.x2) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * (line.x1 - line.x2))), 9);\n \n-    if (x.isBetween(this.x1, this.x2) && x.isBetween(line.x1, line.x2) &&\n-       y.isBetween(this.y1, this.y2) && y.isBetween(line.y1, line.y2)) {\n+    if (Utils.isBetween(x, this.x1, this.x2) && Utils.isBetween(x, line.x1, line.x2) &&\n+        Utils.isBetween(y, this.y1, this.y2) && Utils.isBetween(y, line.y1, line.y2)) {\n       return { x, y };\n     }\n   }\ndiff --git a/resources/scripts/engine/geometry/polygon.js b/resources/scripts/engine/geometry/polygon.js\nindex d8507b9..6e4d828 100644\n--- a/resources/scripts/engine/geometry/polygon.js\n+++ b/resources/scripts/engine/geometry/polygon.js\n@@ -1,6 +1,6 @@\n Engine.Geometry.Polygon = class Polygon {\n   // bounds - an array of arrays. Each sub-array represents the arguments vector which\n-  //   will be invoked by the line's construction method\n+  // will be invoked by the line's construction method\n   constructor(...bounds) {\n     this.bounds = bounds.map(coords => new Engine.Geometry.Line(...coords));\n   }\ndiff --git a/resources/scripts/extensions.js b/resources/scripts/extensions.js\ndeleted file mode 100644\nindex c6f7d9f..0000000\n--- a/resources/scripts/extensions.js\n+++ /dev/null\n@@ -1,70 +0,0 @@\n-Object.defineProperties(Number.prototype, {\n-  // Fixed modulo method which can calculate modulo of negative numbers properly\n-  // e.g., (-803).mod(800) returns 797\n-  \"mod\": {\n-    value(num) {\n-      return ((this % num) + num) % num;\n-    }\n-  },\n-\n-  // Trims number and leaves the number of decimals specified.\n-  // The \"mode\" argument specifies which math function should be invoked\n-  // right after the number has been trimmed.\n-  // e.g. 12.12345.trim(3, \"ceil\") returns 12.124\n-  \"trim\": {\n-    value(decimals, mode = \"round\") {\n-      return Math[mode](this * Math.pow(10, decimals)) / Math.pow(10, decimals);\n-    }\n-  },\n-\n-  // Tells if number is in specified range based on given precision.\n-  // See the \"compare\" method for more information about precision\n-  \"isBetween\": {\n-    value(num1, num2, precision) {\n-      return this.compare(Math.min(num1, num2), \">=\", precision) &&\n-      this.compare(Math.max(num1, num2), \"<=\", precision);\n-    }\n-  },\n-\n-  // Initiates comparison operator between this number and a given number, only here\n-  // a precision can be specified\n-  \"compare\": {\n-    value(num) {\n-      switch (arguments.length) {\n-        case 2:\n-          var precision = arguments[1];\n-          break;\n-        case 3:\n-          var method = arguments[1];\n-          precision = arguments[2];\n-          break;\n-      }\n-\n-      switch (precision) {\n-        // Fixed precision, \"almost equal\" with a deviation of Îµ\n-        case \"f\":\n-          switch (method) {\n-            case \"<\": case \"<=\": return this <= num + Number.EPSILON;\n-            case \">\": case \">=\": return this >= num - Number.EPSILON;\n-            default: return Math.abs(this - num) <= Number.EPSILON;\n-          }\n-        // Pixel precision, round comparison\n-        case \"px\":\n-          switch (method) {\n-            case \"<\": case \"<=\": return Math.round(this) <= Math.round(num);\n-            case \">\": case \">=\": return Math.round(this) >= Math.round(num);\n-            default: return Math.round(this) == Math.round(num);\n-          }\n-        // Exact precision\n-        default:\n-          switch (method) {\n-            case \"<\": return this < num;\n-            case \"<=\": return this <= num;\n-            case \">\": return this > num;\n-            case \">=\": return this >= num;\n-            default: return this === num;\n-          }\n-      }\n-    }\n-  }\n-});\n\\ No newline at end of file\ndiff --git a/resources/scripts/game/entities/snake.js b/resources/scripts/game/entities/snake.js\nindex 19f6d97..9c32961 100644\n--- a/resources/scripts/game/entities/snake.js\n+++ b/resources/scripts/game/entities/snake.js\n@@ -13,8 +13,8 @@ Game.Entities.Snake = class Snake {\n     // A snake is made out of many geometry shapes\n     this.shapes = [];\n     // A snake starts with a line\n-    this.currShape = new Engine.Geometry.Line(x, y, x, y);\n-    this.shapes.push(this.currShape);\n+    this.currentShape = new Engine.Geometry.Line(x, y, x, y);\n+    this.shapes.push(this.currentShape);\n     // A score can be provided in case we want to reserve previous scores from\n     // recent matches\n     this.score = options.score || 0;\n@@ -39,14 +39,8 @@ Game.Entities.Snake = class Snake {\n       context.lineWidth = 3;\n       context.beginPath();\n \n-      // Use a different drawing method for line and circle\n-      if (shape instanceof Engine.Geometry.Line) {\n-        context.moveTo(shape.x1, shape.y1);\n-        context.lineTo(shape.x2, shape.y2);\n-      }\n-      else {\n-        context.arc(shape.x, shape.y, shape.r, shape.rad1, shape.rad2);\n-      }\n+      // Each shape has its own unique drawing method\n+      shape.draw(context);\n \n       context.stroke();\n       context.restore();\n@@ -63,84 +57,106 @@ Game.Entities.Snake = class Snake {\n \n   // Updates shapes array based on progress made\n   updateShapes(step, width, height, options = {}) {\n-    // Line update logic\n-    if (this.currShape instanceof Engine.Geometry.Line) {\n-      let lastX = options.lastX || this.x;\n-      let lastY = options.lastY || this.y;\n-      this.x = options.x || this.currShape.x2;\n-      this.y = options.y || this.currShape.y2;\n-      this.lastBit = new Engine.Geometry.Line(lastX, lastY, this.x, this.y);\n+    this.updateCurrentShape(step, options);\n+    this.updateDirection(step, options);\n+  }\n+\n+  // Updates current shape\n+  updateCurrentShape(step, options) {\n+    if (this.currentShape instanceof Engine.Geometry.Line)\n+      return this.updateCurrentLine(options);\n+    if (this.currentShape instanceof Engine.Geometry.Circle)\n+      return this.updateCurrentCircle(options);\n+  }\n+\n+  // Updates current shape in case it is a line\n+  updateCurrentLine(options) {\n+    let lastX = options.lastX || this.x;\n+    let lastY = options.lastY || this.y;\n+    this.x = options.x || this.currentShape.x2;\n+    this.y = options.y || this.currentShape.y2;\n+    this.lastBit = new Engine.Geometry.Line(lastX, lastY, this.x, this.y);\n+  }\n+\n+  // Updates current shape in case it is a circle\n+  updateCurrentCircle(options) {\n+    let lastX = options.lastX || this.currentShape.x;\n+    let lastY = options.lastY || this.currentShape.y;\n+    let lastR = options.lastR || this.currentShape.r;\n+\n+    // Update logic for left rotation\n+    if (this.direction == \"left\") {\n+      let lastRad = this.rad + (0.5 * Math.PI);\n+      let currentShapePoint = this.currentShape.getPoint(this.currentShape.rad1);\n+      this.x = options.x || currentShapePoint.x;\n+      this.y = options.y || currentShapePoint.y;\n+      this.rad = this.currentShape.rad1 - (0.5 * Math.PI);\n+      this.lastBit = new Engine.Geometry.Circle(lastX, lastY, lastR, this.currentShape.rad1, lastRad);\n     }\n-    // Circle update logic\n+    // Update logic for right rotation\n     else {\n-      let lastX = options.lastX || this.currShape.x;\n-      let lastY = options.lastY || this.currShape.y;\n-      let lastR = options.lastR || this.currShape.r;\n-\n-      // Update logic for left rotation\n-      if (this.direction == \"left\") {\n-        let lastRad = this.rad + (0.5 * Math.PI);\n-        let currShapePoint = this.currShape.getPoint(this.currShape.rad1);\n-        this.x = options.x || currShapePoint.x;\n-        this.y = options.y || currShapePoint.y;\n-        this.rad = this.currShape.rad1 - (0.5 * Math.PI);\n-        this.lastBit = new Engine.Geometry.Circle(lastX, lastY, lastR, this.currShape.rad1, lastRad);\n-      }\n-      // Update logic for right rotation\n-      else {\n-        let lastRad = this.rad - (0.5 * Math.PI);\n-        let currShapePoint = this.currShape.getPoint(this.currShape.rad2);\n-        this.x = options.x || currShapePoint.x;\n-        this.y = options.y || currShapePoint.y;\n-        this.rad = this.currShape.rad2 + (0.5 * Math.PI);\n-        this.lastBit = new Engine.Geometry.Circle(lastX, lastY, lastR, lastRad, this.currShape.rad2);\n-      }\n+      let lastRad = this.rad - (0.5 * Math.PI);\n+      let currentShapePoint = this.currentShape.getPoint(this.currentShape.rad2);\n+      this.x = options.x || currentShapePoint.x;\n+      this.y = options.y || currentShapePoint.y;\n+      this.rad = this.currentShape.rad2 + (0.5 * Math.PI);\n+      this.lastBit = new Engine.Geometry.Circle(lastX, lastY, lastR, lastRad, this.currentShape.rad2);\n     }\n+  }\n \n+  updateDirection(step, options) {\n     // Update the direction based on pressed key\n     if (this.keyStates.get(this.leftKey))\n       var direction = \"left\";\n     else if (this.keyStates.get(this.rightKey))\n       var direction = \"right\";\n \n-    // If there is no change direction, abort, unless we force it\n-    if (direction != this.direction || options.force) {\n-      this.direction = direction;\n-\n-      // This will push a new shape with new properties, based on the direction\n-      switch (direction) {\n-        case \"left\":\n-          var angle = this.rad - (0.5 * Math.PI);\n-          var rad = this.rad + (0.5 * Math.PI);\n-          var x = this.x + (this.r * Math.cos(angle));\n-          var y = this.y + (this.r * Math.sin(angle));\n-          this.currShape = new Engine.Geometry.Circle(x, y, this.r, rad, rad);\n-          break;\n-        case \"right\":\n-          angle = this.rad + (0.5 * Math.PI);\n-          rad = this.rad - (0.5 * Math.PI);\n-          x = this.x + (this.r * Math.cos(angle));\n-          y = this.y + (this.r * Math.sin(angle));\n-          this.currShape = new Engine.Geometry.Circle(x, y, this.r, rad, rad);\n-          break;\n-        default:\n-          this.currShape = new Engine.Geometry.Line(this.x, this.y, this.x, this.y);\n-      }\n-\n-      this.shapes.push(this.currShape);\n+    this.changeDirection(step, direction, options);\n+    this.continueDirection(step, direction, options);\n+  }\n+\n+  // Change the recent shape type according to the given direction\n+  changeDirection(step, direction, options) {\n+    // If there is no change in direction, abort, unless we force it\n+    if (direction == this.direction && !options.force) return;\n+\n+    this.direction = direction;\n+\n+    // This will push a new shape with new properties, based on the direction\n+    switch (direction) {\n+      case \"left\":\n+        var angle = this.rad - (0.5 * Math.PI);\n+        var rad = this.rad + (0.5 * Math.PI);\n+        var x = this.x + (this.r * Math.cos(angle));\n+        var y = this.y + (this.r * Math.sin(angle));\n+        this.currentShape = new Engine.Geometry.Circle(x, y, this.r, rad, rad);\n+        break;\n+      case \"right\":\n+        angle = this.rad + (0.5 * Math.PI);\n+        rad = this.rad - (0.5 * Math.PI);\n+        x = this.x + (this.r * Math.cos(angle));\n+        y = this.y + (this.r * Math.sin(angle));\n+        this.currentShape = new Engine.Geometry.Circle(x, y, this.r, rad, rad);\n+        break;\n+      default:\n+        this.currentShape = new Engine.Geometry.Line(this.x, this.y, this.x, this.y);\n     }\n \n-    // Extend the recent shape based on progress made\n+    this.shapes.push(this.currentShape);\n+  }\n+\n+  // Extend the recent shape based on progress made\n+  continueDirection(step, direction) {\n     switch (direction) {\n       case \"left\":\n-        this.currShape.rad1 -= step / this.r;\n+        this.currentShape.rad1 -= step / this.r;\n         break;\n       case \"right\":\n-        this.currShape.rad2 += step / this.r;\n+        this.currentShape.rad2 += step / this.r;\n         break;\n       default:\n-        this.currShape.x2 += step * Math.cos(this.rad);\n-        this.currShape.y2 += step * Math.sin(this.rad);\n+        this.currentShape.x2 += step * Math.cos(this.rad);\n+        this.currentShape.y2 += step * Math.sin(this.rad);\n     }\n   }\n \n@@ -155,9 +171,9 @@ Game.Entities.Snake = class Snake {\n \n     // Re-calculate position based on canvas bounds\n     if (intersectionPoint.x % width == 0)\n-      this.x = (this.x - width).mod(width);\n+      this.x = Utils.mod(this.x - width, width);\n     if (intersectionPoint.y % height == 0)\n-      this.y = (this.y - height).mod(height);\n+      this.y = Utils.mod(this.y - height, height);\n \n     // Update shapes again based on custom properties\n     this.updateShapes(step, width, height, {\n@@ -171,14 +187,14 @@ Game.Entities.Snake = class Snake {\n \n   // Gets intersection points between last bit and own shapes\n   getSelfIntersection() {\n-    if (this.currShape instanceof Engine.Geometry.Circle &&\n-       Math.abs(this.currShape.rad1 - this.currShape.rad2) >= 2 * Math.PI) {\n+    if (this.currentShape instanceof Engine.Geometry.Circle &&\n+       Math.abs(this.currentShape.rad1 - this.currentShape.rad2) >= 2 * Math.PI) {\n       if (this.direction == \"left\")\n-        var rad = this.currShape.rad1;\n+        var rad = this.currentShape.rad1;\n       else\n-        var rad = this.currShape.rad2;\n+        var rad = this.currentShape.rad2;\n \n-      return this.currShape.getPoint(rad);\n+      return this.currentShape.getPoint(rad);\n     }\n \n     let result;\ndiff --git a/resources/scripts/game/screens/menu/index.js b/resources/scripts/game/screens/menu/index.js\nindex 1242041..8afc68a 100644\n--- a/resources/scripts/game/screens/menu/index.js\n+++ b/resources/scripts/game/screens/menu/index.js\n@@ -31,7 +31,7 @@ Game.Screens.Menu = class Menu extends Engine.Screen {\n     ]);\n \n     // Play it repeatedly, back and forth\n-    this.instructionsAnim.repMode = \"full\";\n+    this.instructionsAnim.repetitionMode = \"full\";\n     this.instructionsAnim.play();\n   }\n \ndiff --git a/resources/scripts/utils.js b/resources/scripts/utils.js\nnew file mode 100644\nindex 0000000..27a4cb7\n--- /dev/null\n+++ b/resources/scripts/utils.js\n@@ -0,0 +1,78 @@\n+// A wrapper function for our utilities which will enable chaining\n+// e.g. Utils().mod().trim().isBetween()...\n+Utils = function Utils(context) {\n+  const chain = {};\n+\n+  Object.keys(Utils).forEach((utilName) => {\n+    chain[utilName] = (...args) => {\n+      const result = Utils[utilName](context, ...args);\n+      return Utils(result);\n+    };\n+  });\n+\n+  // Returns the result of the chaining\n+  chain.value = () => context;\n+\n+  return chain;\n+};\n+\n+// Fixed modulo method which can calculate modulo of negative numbers properly\n+// e.g. (-803).mod(800) returns 797\n+Utils.mod = function (context, num) {\n+  return ((context % num) + num) % num;\n+};\n+\n+// Trims number and leaves the number of decimals specified.\n+// The \"mode\" argument specifies which math function should be invoked\n+// right after the number has been trimmed.\n+// e.g. 12.12345.trim(3, \"ceil\") returns 12.124\n+Utils.trim = function (context, decimals, mode = \"round\") {\n+  return Math[mode](context * Math.pow(10, decimals)) / Math.pow(10, decimals);\n+};\n+\n+// Tells if number is in specified range based on given precision.\n+// See the \"compare\" method for more information about precision\n+Utils.isBetween = function (context, num1, num2, precision) {\n+  return Utils.compare(context, Math.min(num1, num2), \">=\", precision) &&\n+         Utils.compare(context, Math.max(num1, num2), \"<=\", precision);\n+};\n+\n+// Initiates comparison operator between context number and a given number, only here\n+// a precision can be specified\n+Utils.compare = function (context, num, method, precision) {\n+  switch (arguments.length) {\n+    case 2:\n+      var precision = arguments[1];\n+      break;\n+    case 3:\n+      var method = arguments[1];\n+      precision = arguments[2];\n+      break;\n+  }\n+\n+  switch (precision) {\n+    // Fixed precision, \"almost equal\" with a deviation of Îµ\n+    case \"f\":\n+      switch (method) {\n+        case \"<\": case \"<=\": return context <= num + Number.EPSILON;\n+        case \">\": case \">=\": return context >= num - Number.EPSILON;\n+        default: return Math.abs(context - num) <= Number.EPSILON;\n+      }\n+    // Pixel precision, round comparison\n+    case \"px\":\n+      switch (method) {\n+        case \"<\": case \"<=\": return Math.round(context) <= Math.round(num);\n+        case \">\": case \">=\": return Math.round(context) >= Math.round(num);\n+        default: return Math.round(context) == Math.round(num);\n+      }\n+    // Exact precision\n+    default:\n+      switch (method) {\n+        case \"<\": return context < num;\n+        case \"<=\": return context <= num;\n+        case \">\": return context > num;\n+        case \">=\": return context >= num;\n+        default: return context === num;\n+      }\n+  }\n+};\n\\ No newline at end of file\ndiff --git a/views/game.html b/views/game.html\nindex f4d45bc..5c300ad 100644\n--- a/views/game.html\n+++ b/views/game.html\n@@ -8,7 +8,7 @@\n     <script type=\"text/javascript\" src=\"/libs/underscore.js\"></script>\n \n     <!-- Scripts -->\n-    <script type=\"text/javascript\" src=\"/scripts/extensions.js\"></script>\n+    <script type=\"text/javascript\" src=\"/scripts/utils.js\"></script>\n     <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n     <script type=\"text/javascript\" src=\"/scripts/engine/geometry/line.js\"></script>\n     <script type=\"text/javascript\" src=\"/scripts/engine/geometry/circle.js\"></script>\ndiff --git a/views/spec_runner.html b/views/spec_runner.html\nindex ce839dc..1b191ee 100644\n--- a/views/spec_runner.html\n+++ b/views/spec_runner.html\n@@ -16,7 +16,7 @@\n     <script type=\"text/javascript\" src=\"libs/underscore.js\"></script>\n \n     <!-- Scripts -->\n-    <script type=\"text/javascript\" src=\"scripts/extensions.js\"></script>\n+    <script type=\"text/javascript\" src=\"scripts/utils.js\"></script>\n     <script type=\"text/javascript\" src=\"scripts/namespaces.js\"></script>\n     <script type=\"text/javascript\" src=\"scripts/engine/geometry/line.js\"></script>\n     <script type=\"text/javascript\" src=\"scripts/engine/geometry/circle.js\"></script>\n",
        "manuals": [
          {
            "manualTitle": "How to implement a game engine in JavaScript and build a Tron-style game",
            "stepRevision": "08b88f5a9d7b2d3ba4c8a67a1433218ef6a6a3a5",
            "manualView": "![snake-demo-full-small](https://cloud.githubusercontent.com/assets/7648874/21073892/ae331a8a-bed2-11e6-9141-9554f9bb808b.gif)\n\nThis tutorial will guide you through the following steps:\n\n- [**Step 1**](https://github.com/DAB0mB/radial-snake/blob/master/.tortilla/manuals/views/step1.md) - Creating a server\n- [**Step 2**](https://github.com/DAB0mB/radial-snake/blob/master/.tortilla/manuals/views/step2.md) - Creating a game engine basis\n- [**Step 3**](https://github.com/DAB0mB/radial-snake/blob/master/.tortilla/manuals/views/step3.md) - Creating a splash screen using a keyframe animation engine\n- [**Step 4**](https://github.com/DAB0mB/radial-snake/blob/master/.tortilla/manuals/views/step4.md) - Creating a main menu screen using a font engine\n- [**Step 5**](https://github.com/DAB0mB/radial-snake/blob/master/.tortilla/manuals/views/step5.md) - Creating a snake and related geometry shapes\n- [**Step 6**](https://github.com/DAB0mB/radial-snake/blob/master/.tortilla/manuals/views/step6.md) - Creating a complex game screen with multiple layers\n- [**Step 7**](https://github.com/DAB0mB/radial-snake/blob/master/.tortilla/manuals/views/step7.md) - Bonus! Re-implementing geometry in C++\n\nMake sure you have the following software installed:\n\n- NodeJS with an ECMAScript 2015 support (v6.0.0 and above).\n- Any web-browser which supports ECMAScript 2015, with a preference for Google Chrome.\n\n> The final project is a hybrid of C++ and JavaScript. A JavaScript **only** version of this tutorial is available [here](https://github.com/DAB0mB/radial-snake/tree/master%40step6%400.1.3).\n\nThis tutorial is mostly based on pure JavaScript, so people can have a deeper understanding of the language and its dynamics. In addition, this tutorial makes a great practice on how to build a nice architecture for complex systems, which can then be expanded and maintained with ease. Yes, it is specifically designed for games, but I truly believe that video games can easily get messed up if not planned and designed properly in terms of object oriented relationships. They are naturally more complicated then any web-app you gonna see out there, so if you can create a game engine and understand its flow, creating a web-app would be a piece of cake for you. By the end of this tutorial, your general sense for programming should be enhanced greatly.\n\nSo hopefully that I got you pumped up by now, let's get started!"
          },
          {
            "manualTitle": "Step 1: Creating a server",
            "stepRevision": "1aed2194c509617dbe79447e2615aa34728262bc",
            "manualView": "The first thing we will learn to do would be creating a server so we can serve our assets. We will be using [HapiJS](https://hapijs.com/) to build a REST API, although this step can be implemented with any library you'd want, like [ExpressJS](http://expressjs.com/) or [Connect](https://www.senchalabs.github.com/connect) etc. Let's install it then:\n\n    $ npm install hapi --save\n\nWe will start by setting up a basis for our server, and we will expand it as we go further in this step. A general boiler plate should look like so:\n\n[{]: <helper> (diffStep 1.2)\n\n#### [Step 1.2: Add server basis](https://github.com/DAB0mB/radial-snake/commit/8ff8805)\n\n##### Added server.js\n```diff\n@@ -0,0 +1,36 @@\n+â”Š  â”Š 1â”Šconst Hapi = require(\"hapi\");\n+â”Š  â”Š 2â”Š\n+â”Š  â”Š 3â”Šlet port = 8000;\n+â”Š  â”Š 4â”Š\n+â”Š  â”Š 5â”Š// Initialize a new server\n+â”Š  â”Š 6â”Šlet server = new Hapi.Server();\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Šserver.connection({ port: process.env.PORT || port });\n+â”Š  â”Š 9â”Š\n+â”Š  â”Š10â”Š// Report each response made\n+â”Š  â”Š11â”Šserver.ext(\"onPreResponse\", (req, rep) => {\n+â”Š  â”Š12â”Š  let res = req.response;\n+â”Š  â”Š13â”Š\n+â”Š  â”Š14â”Š  console.log(\"Outcoming response:\");\n+â”Š  â”Š15â”Š  console.log(`in: ${new Date}`);\n+â”Š  â”Š16â”Š  console.log(`to: ${req.info.remoteAddress}`);\n+â”Š  â”Š17â”Š  console.log(`method: ${req.method}`);\n+â”Š  â”Š18â”Š  console.log(`url: ${req.url.path}`);\n+â”Š  â”Š19â”Š  console.log(`status: ${res.statusCode || res.output.statusCode}`);\n+â”Š  â”Š20â”Š  console.log();\n+â”Š  â”Š21â”Š\n+â”Š  â”Š22â”Š  rep.continue();\n+â”Š  â”Š23â”Š});\n+â”Š  â”Š24â”Š\n+â”Š  â”Š25â”Š// Print message once started\n+â”Š  â”Š26â”Šserver.start((err) => {\n+â”Š  â”Š27â”Š  if (err) throw err;\n+â”Š  â”Š28â”Š\n+â”Š  â”Š29â”Š  console.log();\n+â”Š  â”Š30â”Š  console.log(\"---------- -------- ------ ---- --\");\n+â”Š  â”Š31â”Š  console.log(\"----- ---- --- -- -\");\n+â”Š  â”Š32â”Š  console.log(`Server running at ${port}`);\n+â”Š  â”Š33â”Š  console.log(\"----- ---- --- -- -\");\n+â”Š  â”Š34â”Š  console.log(\"---------- -------- ------ ---- --\");\n+â”Š  â”Š35â”Š  console.log();\n+â”Š  â”Š36â”Š});ðŸš«â†µ\n```\n\n[}]: #\n\nWe simply initialize a new server which will connect to port `8000` by default, unless we defined an environment variable called `PORT`. Once the server is started, and whenever there is an outcoming response, a message will be printed to the console.\n\n> More information and configuration options regards HapiJS's API can be found in this [here](https://hapijs.com/).\n\nNow that the basis is ready, we want a convenient way to launch it. Repetitive scripts are usually defined in the `package.json` file under the `scripts` field. To start the server, we gonna create a simple script called `serve`:\n\n[{]: <helper> (diffStep 1.3)\n\n#### [Step 1.3: Add serve npm script](https://github.com/DAB0mB/radial-snake/commit/6e7d691)\n\n##### Changed package.json\n```diff\n@@ -6,6 +6,9 @@\n â”Š 6â”Š 6â”Š    \"url\": \"https://DAB0mB@github.com/DAB0mB/radial-snake.git\"\n â”Š 7â”Š 7â”Š  },\n â”Š 8â”Š 8â”Š  \"private\": true,\n+â”Š  â”Š 9â”Š  \"scripts\": {\n+â”Š  â”Š10â”Š    \"serve\": \"node server.js\"\n+â”Š  â”Š11â”Š  },\n â”Š 9â”Š12â”Š  \"dependencies\": {\n â”Š10â”Š13â”Š    \"hapi\": \"^16.0.1\"\n â”Š11â”Š14â”Š  }\n```\n\n[}]: #\n\nTo run this script, we will simply need to type the following:\n\n    $ npm run serve\n\nThis will run our server, and you should see the following message printed to the console:\n\n```\n---------- -------- ------ ---- --\n----- ---- --- -- -\nServer running at 8000\n----- ---- --- -- -\n---------- -------- ------ ---- --\n```\n\n> As for now, nothing happens, because we didn't define any handlers for HTTP requests. I will get to it in a bit, stay with me.\n\nThe main disadvantage of starting a server directly with node is that we have no listeners for changes in our files, so if we want the served files to be updated, we will have to restart our server anytime we make a change. To avoid that, we gonna use [nodemon](https://nodemon.io/), which is a simple utility that can monitor changes is source files and automatically restart our server. To install it, type the following:\n\n    $ sudo npm install nodemon -g\n\nNow that we have it, we will need to update our `serve` npm script to use `nodemon` instead of `node`:\n\n[{]: <helper> (diffStep 1.4)\n\n#### [Step 1.4: Change serve npm script to use nodemon](https://github.com/DAB0mB/radial-snake/commit/a238294)\n\n##### Changed package.json\n```diff\n@@ -7,7 +7,7 @@\n â”Š 7â”Š 7â”Š  },\n â”Š 8â”Š 8â”Š  \"private\": true,\n â”Š 9â”Š 9â”Š  \"scripts\": {\n-â”Š10â”Š  â”Š    \"serve\": \"node server.js\"\n+â”Š  â”Š10â”Š    \"serve\": \"nodemon server.js\"\n â”Š11â”Š11â”Š  },\n â”Š12â”Š12â”Š  \"dependencies\": {\n â”Š13â”Š13â”Š    \"hapi\": \"^16.0.1\"\n```\n\n[}]: #\n\nThe basis for our server is pretty much complete. From now on we gonna build stuff on top of it and extend our server. I'd like to add a small attachment to our server. I want that the IP address of the current computer will be printed to the console once the server is started. For this, we first gonna create a helper which we gonna call `ip_grabber`:\n\n[{]: <helper> (diffStep 1.5)\n\n#### [Step 1.5: Add ip_grabber helper](https://github.com/DAB0mB/radial-snake/commit/8ff1d1c)\n\n##### Added helpers&#x2F;ip_grabber.js\n```diff\n@@ -0,0 +1,23 @@\n+â”Š  â”Š 1â”Šconst Os = require(\"os\");\n+â”Š  â”Š 2â”Š\n+â”Š  â”Š 3â”Š// Grab local IP address of which the NodeJS process runs on\n+â”Š  â”Š 4â”Šfunction local() {\n+â”Š  â”Š 5â”Š  let interfaces = Os.networkInterfaces();\n+â”Š  â”Š 6â”Š  let addresses = [];\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Š  for (let k in interfaces) {\n+â”Š  â”Š 9â”Š    for (let k2 in interfaces[k]) {\n+â”Š  â”Š10â”Š      let address = interfaces[k][k2];\n+â”Š  â”Š11â”Š\n+â”Š  â”Š12â”Š      if (address.family == \"IPv4\" && !address.internal) {\n+â”Š  â”Š13â”Š        addresses.push(address.address);\n+â”Š  â”Š14â”Š      }\n+â”Š  â”Š15â”Š    }\n+â”Š  â”Š16â”Š  }\n+â”Š  â”Š17â”Š\n+â”Š  â”Š18â”Š  return addresses[0];\n+â”Š  â”Š19â”Š}\n+â”Š  â”Š20â”Š\n+â”Š  â”Š21â”Šmodule.exports = {\n+â”Š  â”Š22â”Š  local\n+â”Š  â”Š23â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nThis module simply goes through the available network interfaces and grabs the IP address of the default gateway using the `os` module. Now that we have it, let's import it in the server's entry file and use the `local` method to grab the IP address and report it once the server is started:\n\n[{]: <helper> (diffStep 1.6)\n\n#### [Step 1.6: Print IP address once server is started](https://github.com/DAB0mB/radial-snake/commit/18ed984)\n\n##### Changed server.js\n```diff\n@@ -1,5 +1,7 @@\n â”Š1â”Š1â”Šconst Hapi = require(\"hapi\");\n+â”Š â”Š2â”Šconst IpGrabber = require(\"./helpers/ip_grabber\");\n â”Š2â”Š3â”Š\n+â”Š â”Š4â”Šlet localIp = IpGrabber.local();\n â”Š3â”Š5â”Šlet port = 8000;\n â”Š4â”Š6â”Š\n â”Š5â”Š7â”Š// Initialize a new server\n```\n```diff\n@@ -29,7 +31,7 @@\n â”Š29â”Š31â”Š  console.log();\n â”Š30â”Š32â”Š  console.log(\"---------- -------- ------ ---- --\");\n â”Š31â”Š33â”Š  console.log(\"----- ---- --- -- -\");\n-â”Š32â”Š  â”Š  console.log(`Server running at ${port}`);\n+â”Š  â”Š34â”Š  console.log(`Server running at ${localIp}:${port}`);\n â”Š33â”Š35â”Š  console.log(\"----- ---- --- -- -\");\n â”Š34â”Š36â”Š  console.log(\"---------- -------- ------ ---- --\");\n â”Š35â”Š37â”Š  console.log();\n```\n\n[}]: #\n\nBy now you should have the following message printed to the console once you start the server:\n\n```\n---------- -------- ------ ---- --\n----- ---- --- -- -\nServer running at 95.221.122.30:8000\n----- ---- --- -- -\n---------- -------- ------ ---- --\n```\n\n> Instead of `95.221.122.30` you should have the IP address which is right for you.\n\nNow comes the most important part - handling HTTP requests! Because what does a server worth if it doesn't know how to handle anything? When using `HapiJS`, we can separate extensions to our server in different modules, and eventually register them as plug-ins. So the first plug-in is gonna be the routes batch for the endpoints - it will take care of serving file requests as is, and basically turning local directories into public ones. This is useful because our game is going to be dependent on many assets like textures, images, fonts, and so on... But before I go into the implementation part we first need to install a couple of libraries which will help us with the task. The first one is going to be `async`, which will take care of managing the control flow of asynchronous code:\n\n    $ npm install async --save\n\nAnd the second library is going to be `inert`, which is a `HapiJS` plug-in which will give us the ability to serve files from local directories:\n\n    $ npm install inert --save\n\nNow that we're set, let's implement the `endpoints` routes batch:\n\n[{]: <helper> (diffStep 1.8)\n\n#### [Step 1.8: Add endpoints routes](https://github.com/DAB0mB/radial-snake/commit/9c22408)\n\n##### Added routes&#x2F;endpoints.js\n```diff\n@@ -0,0 +1,80 @@\n+â”Š  â”Š 1â”Šconst Pack = require(\"../package.json\");\n+â”Š  â”Š 2â”Š\n+â”Š  â”Š 3â”Šregister.attributes = {\n+â”Š  â”Š 4â”Š  name: \"endpoints\",\n+â”Š  â”Š 5â”Š  version: Pack.version\n+â”Š  â”Š 6â”Š};\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Šfunction register(server, options, next) {\n+â”Š  â”Š 9â”Š  // Scripts endpoint\n+â”Š  â”Š10â”Š  server.route({\n+â”Š  â”Š11â”Š    method: \"GET\",\n+â”Š  â”Š12â”Š    path: \"/scripts/{path*}\",\n+â”Š  â”Š13â”Š    handler: {\n+â”Š  â”Š14â”Š      directory: {\n+â”Š  â”Š15â”Š        path: \"./resources/scripts/\"\n+â”Š  â”Š16â”Š      }\n+â”Š  â”Š17â”Š    }\n+â”Š  â”Š18â”Š  });\n+â”Š  â”Š19â”Š\n+â”Š  â”Š20â”Š  // Style-sheets endpoint\n+â”Š  â”Š21â”Š  server.route({\n+â”Š  â”Š22â”Š    method: \"GET\",\n+â”Š  â”Š23â”Š    path: \"/styles/{path*}\",\n+â”Š  â”Š24â”Š    handler: {\n+â”Š  â”Š25â”Š      directory: {\n+â”Š  â”Š26â”Š        path: \"./resources/styles/\"\n+â”Š  â”Š27â”Š      }\n+â”Š  â”Š28â”Š    }\n+â”Š  â”Š29â”Š  });\n+â”Š  â”Š30â”Š\n+â”Š  â”Š31â”Š  // Libraries endpoint\n+â”Š  â”Š32â”Š  server.route({\n+â”Š  â”Š33â”Š    method: \"GET\",\n+â”Š  â”Š34â”Š    path: \"/libs/{path*}\",\n+â”Š  â”Š35â”Š    handler: {\n+â”Š  â”Š36â”Š      directory: {\n+â”Š  â”Š37â”Š        path: \"./resources/libs/\"\n+â”Š  â”Š38â”Š      }\n+â”Š  â”Š39â”Š    }\n+â”Š  â”Š40â”Š  });\n+â”Š  â”Š41â”Š\n+â”Š  â”Š42â”Š  // Images endpoint\n+â”Š  â”Š43â”Š  server.route({\n+â”Š  â”Š44â”Š    method: \"GET\",\n+â”Š  â”Š45â”Š    path: \"/images/{path*}\",\n+â”Š  â”Š46â”Š    handler: {\n+â”Š  â”Š47â”Š      directory: {\n+â”Š  â”Š48â”Š        path: \"./resources/images/\"\n+â”Š  â”Š49â”Š      }\n+â”Š  â”Š50â”Š    }\n+â”Š  â”Š51â”Š  });\n+â”Š  â”Š52â”Š\n+â”Š  â”Š53â”Š  // Textures endpoint\n+â”Š  â”Š54â”Š  server.route({\n+â”Š  â”Š55â”Š    method: \"GET\",\n+â”Š  â”Š56â”Š    path: \"/textures/{path*}\",\n+â”Š  â”Š57â”Š    handler: {\n+â”Š  â”Š58â”Š      directory: {\n+â”Š  â”Š59â”Š        path: \"./resources/assets/textures/\"\n+â”Š  â”Š60â”Š      }\n+â”Š  â”Š61â”Š    }\n+â”Š  â”Š62â”Š  });\n+â”Š  â”Š63â”Š\n+â”Š  â”Š64â”Š  // Fonts endpoint\n+â”Š  â”Š65â”Š  server.route({\n+â”Š  â”Š66â”Š    method: \"GET\",\n+â”Š  â”Š67â”Š    path: \"/fonts/{path*}\",\n+â”Š  â”Š68â”Š    handler: {\n+â”Š  â”Š69â”Š      directory: {\n+â”Š  â”Š70â”Š        path: \"./resources/assets/fonts/\"\n+â”Š  â”Š71â”Š      }\n+â”Š  â”Š72â”Š    }\n+â”Š  â”Š73â”Š  });\n+â”Š  â”Š74â”Š\n+â”Š  â”Š75â”Š  next();\n+â”Š  â”Š76â”Š}\n+â”Š  â”Š77â”Š\n+â”Š  â”Š78â”Šmodule.exports = {\n+â”Š  â”Š79â”Š  register\n+â”Š  â”Š80â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nThis module actually represents a classic structure of a `HapiJS` plug-in. It should export a `name` for debugging proposes, a `version`, and a `register` function, which will take care of registering extensions to our server; in this case, these are the endpoints routes. To make this plug-in (Or any other plug-in) work, we need to register it. The registration is an asynchronous operation, thus we gonna handle it using `async`:\n\n[{]: <helper> (diffStep 1.9)\n\n#### [Step 1.9: Register ednpoints routes](https://github.com/DAB0mB/radial-snake/commit/bba460f)\n\n##### Changed server.js\n```diff\n@@ -1,11 +1,23 @@\n+â”Š  â”Š 1â”Šconst Async = require(\"async\");\n â”Š 1â”Š 2â”Šconst Hapi = require(\"hapi\");\n+â”Š  â”Š 3â”Šconst Inert = require(\"inert\");\n+â”Š  â”Š 4â”Šconst Endpoints = require(\"./routes/endpoints\");\n â”Š 2â”Š 5â”Šconst IpGrabber = require(\"./helpers/ip_grabber\");\n â”Š 3â”Š 6â”Š\n â”Š 4â”Š 7â”Šlet localIp = IpGrabber.local();\n â”Š 5â”Š 8â”Šlet port = 8000;\n â”Š 6â”Š 9â”Š\n â”Š 7â”Š10â”Š// Initialize a new server\n-â”Š 8â”Š  â”Šlet server = new Hapi.Server();\n+â”Š  â”Š11â”Šlet server = new Hapi.Server({\n+â”Š  â”Š12â”Š  connections: {\n+â”Š  â”Š13â”Š    routes: {\n+â”Š  â”Š14â”Š      files: {\n+â”Š  â”Š15â”Š        // Served files will be relative to current directory\n+â”Š  â”Š16â”Š        relativeTo: __dirname\n+â”Š  â”Š17â”Š      }\n+â”Š  â”Š18â”Š    }\n+â”Š  â”Š19â”Š  }\n+â”Š  â”Š20â”Š});\n â”Š 9â”Š21â”Š\n â”Š10â”Š22â”Šserver.connection({ port: process.env.PORT || port });\n â”Š11â”Š23â”Š\n```\n```diff\n@@ -24,8 +36,14 @@\n â”Š24â”Š36â”Š  rep.continue();\n â”Š25â”Š37â”Š});\n â”Š26â”Š38â”Š\n+â”Š  â”Š39â”Š// Register all routes and plug-ins\n+â”Š  â”Š40â”ŠAsync.series([\n+â”Š  â”Š41â”Š  next => server.register(Inert, next),\n+â”Š  â”Š42â”Š  next => server.register(Endpoints, next),\n+â”Š  â”Š43â”Š  // Once registrations are finished, start the server\n+â”Š  â”Š44â”Š  next => server.start(next)\n â”Š27â”Š45â”Š// Print message once started\n-â”Š28â”Š  â”Šserver.start((err) => {\n+â”Š  â”Š46â”Š], (err) => {\n â”Š29â”Š47â”Š  if (err) throw err;\n â”Š30â”Š48â”Š\n â”Š31â”Š49â”Š  console.log();\n```\n\n[}]: #\n\nOnce all the plug-ins have been registered, we gonna start our server as we previously did. Note that we also registered the `inert` plug-in, because as I said earlier, that's what gives us the ability to handle files requests.\n\nLastly, I want to create the `pages` routes batch, which will be responsible for serving pages in our application as listed above:\n\n- The `/` route will serve us the `game.html` file.\n- The `/test` route will serve us the `spec_runner.html` file.\n\nBy the name of each route and file you can probably what each one should do. The thing is, we don't want everyone to be able to access the `spec_runner.html` file, or the `game.html` file if in the middle of development. For this, we're going to create a new helper which will be responsible for handling permissions. So first we gonna install an npm package called `boom` which has the ability to format `permission denied` HTTP errors:\n\n    $ npm install boom --save\n\nAnd now we gonna implement the module itself:\n\n[{]: <helper> (diffStep 1.11)\n\n#### [Step 1.11: Add permitter helper](https://github.com/DAB0mB/radial-snake/commit/d26a5d7)\n\n##### Added helpers&#x2F;permitter.js\n```diff\n@@ -0,0 +1,29 @@\n+â”Š  â”Š 1â”Šconst Boom = require(\"boom\");\n+â”Š  â”Š 2â”Šconst Hapi = require(\"hapi\");\n+â”Š  â”Š 3â”Šconst IpGrabber = require(\"./ip_grabber\");\n+â”Š  â”Š 4â”Š\n+â”Š  â”Š 5â”Š// These addresses will be permitted by default\n+â”Š  â”Š 6â”Šconst defaultPermissions = [\n+â”Š  â”Š 7â”Š  IpGrabber.local(), \"127.0.0.1\", \"localhost\"\n+â”Š  â”Š 8â”Š];\n+â”Š  â”Š 9â”Š\n+â”Š  â”Š10â”Š// Manage file permissions\n+â”Š  â”Š11â”Šfunction file(path, permissions, req, rep) {\n+â”Š  â”Š12â”Š  // Apply default permissions\n+â”Š  â”Š13â”Š  permissions = permissions.concat(defaultPermissions);\n+â”Š  â”Š14â”Š  // Request address\n+â”Š  â”Š15â”Š  let remoteAddress = req.info.remoteAddress;\n+â”Š  â”Š16â”Š\n+â”Š  â”Š17â”Š  // If not permitted, reply error\n+â”Š  â”Š18â”Š  if (permissions.indexOf(remoteAddress) == -1) {\n+â”Š  â”Š19â”Š    let err = new Boom.forbidden(\"Missing permissions\");\n+â”Š  â”Š20â”Š    return rep(err);\n+â”Š  â”Š21â”Š  }\n+â”Š  â”Š22â”Š\n+â”Š  â”Š23â”Š  // If permitted, reply file\n+â”Š  â”Š24â”Š  rep.file(path);\n+â”Š  â”Š25â”Š}\n+â”Š  â”Š26â”Š\n+â”Š  â”Š27â”Šmodule.exports = {\n+â”Š  â”Š28â”Š  file\n+â”Š  â”Š29â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nThe default permitted IP address would be the current computer's IP address. Extra IP permissions can be provided with the invocation of the `file` method. If the requesting IP is not listed in the permissions list, an error is gonna be replied instead of the requested file. Now that we have our \"permitter\" ready, let's implement the `pages` routes batch, only we're gonna pass the requests through the black-list, for the reason mentioned above:\n\n[{]: <helper> (diffStep 1.12)\n\n#### [Step 1.12: Add pages routes](https://github.com/DAB0mB/radial-snake/commit/11860e9)\n\n##### Added routes&#x2F;pages.js\n```diff\n@@ -0,0 +1,35 @@\n+â”Š  â”Š 1â”Šconst Hapi = require(\"hapi\");\n+â”Š  â”Š 2â”Šconst Pack = require(\"../package.json\");\n+â”Š  â”Š 3â”Šconst Permitter = require(\"../helpers/permitter\");\n+â”Š  â”Š 4â”Š\n+â”Š  â”Š 5â”Šregister.attributes = {\n+â”Š  â”Š 6â”Š  name: \"pages\",\n+â”Š  â”Š 7â”Š  version: Pack.version\n+â”Š  â”Š 8â”Š};\n+â”Š  â”Š 9â”Š\n+â”Š  â”Š10â”Šfunction register(server, options, next) {\n+â”Š  â”Š11â”Š  server.route({ method: \"GET\", path: \"/\", handler: getGame });\n+â”Š  â”Š12â”Š  server.route({ method: \"GET\", path: \"/test\", handler: getSpecRunner });\n+â”Š  â”Š13â”Š\n+â”Š  â”Š14â”Š  next();\n+â”Š  â”Š15â”Š}\n+â”Š  â”Š16â”Š\n+â”Š  â”Š17â”Š// Serve game page\n+â”Š  â”Š18â”Šfunction getGame(req, rep) {\n+â”Š  â”Š19â”Š  let path = \"./views/game.html\";\n+â”Š  â”Š20â”Š  let permissions = [];\n+â”Š  â”Š21â”Š\n+â”Š  â”Š22â”Š  Permitter.file(path, permissions, req, rep);\n+â”Š  â”Š23â”Š}\n+â”Š  â”Š24â”Š\n+â”Š  â”Š25â”Š// Serve test page\n+â”Š  â”Š26â”Šfunction getSpecRunner(req, rep) {\n+â”Š  â”Š27â”Š  let path = \"./views/spec_runner.html\";\n+â”Š  â”Š28â”Š  let permissions = [];\n+â”Š  â”Š29â”Š\n+â”Š  â”Š30â”Š  Permitter.file(path, permissions, req, rep);\n+â”Š  â”Š31â”Š}\n+â”Š  â”Š32â”Š\n+â”Š  â”Š33â”Šmodule.exports = {\n+â”Š  â”Š34â”Š  register\n+â”Š  â”Š35â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nNow the only thing left to do would be registering the plug-in we've just created:\n\n[{]: <helper> (diffStep 1.13)\n\n#### [Step 1.13: Register pages routes](https://github.com/DAB0mB/radial-snake/commit/ed50bef)\n\n##### Changed server.js\n```diff\n@@ -2,6 +2,7 @@\n â”Š2â”Š2â”Šconst Hapi = require(\"hapi\");\n â”Š3â”Š3â”Šconst Inert = require(\"inert\");\n â”Š4â”Š4â”Šconst Endpoints = require(\"./routes/endpoints\");\n+â”Š â”Š5â”Šconst Pages = require(\"./routes/pages\");\n â”Š5â”Š6â”Šconst IpGrabber = require(\"./helpers/ip_grabber\");\n â”Š6â”Š7â”Š\n â”Š7â”Š8â”Šlet localIp = IpGrabber.local();\n```\n```diff\n@@ -40,6 +41,7 @@\n â”Š40â”Š41â”ŠAsync.series([\n â”Š41â”Š42â”Š  next => server.register(Inert, next),\n â”Š42â”Š43â”Š  next => server.register(Endpoints, next),\n+â”Š  â”Š44â”Š  next => server.register(Pages, next),\n â”Š43â”Š45â”Š  // Once registrations are finished, start the server\n â”Š44â”Š46â”Š  next => server.start(next)\n â”Š45â”Š47â”Š// Print message once started\n```\n\n[}]: #\n\nAnd that's it for the current step! In the next steps we will start storing files and assets in our public directories and implement all the necessary scripts, so our server is not running in vain."
          },
          {
            "manualTitle": "Step 2: Creating a game engine basis",
            "stepRevision": "a3e901039dc5db535111da14305175182f9f346c",
            "manualView": "Like any other JavaScript-based application, we should have an entry view written in HTML. However, in our application, the only visible element is going to be an [HTMLCanvas](https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API). The canvas is exactly what it sounds like - a blank white surface which we can draw things on top of it. As we go further with this tutorial, we will learn more about the canvas and dive into its API and how to use it. Now that you got the general idea, let's create the HTML file:\n\n[{]: <helper> (diffStep 2.1)\n\n#### [Step 2.1: Create basic game view](https://github.com/DAB0mB/radial-snake/commit/254f06f)\n\n##### Added views&#x2F;game.html\n```diff\n@@ -0,0 +1,10 @@\n+â”Š  â”Š 1â”Š<!DOCTYPE html>\n+â”Š  â”Š 2â”Š<html>\n+â”Š  â”Š 3â”Š  <head>\n+â”Š  â”Š 4â”Š    <title>radial snake</title>\n+â”Š  â”Š 5â”Š  </head>\n+â”Š  â”Š 6â”Š\n+â”Š  â”Š 7â”Š  <body>\n+â”Š  â”Š 8â”Š    <canvas id=\"gameCanvas\" tabindex=\"0\"></canvas>\n+â”Š  â”Š 9â”Š  </body>\n+â”Š  â”Š10â”Š</html>ðŸš«â†µ\n```\n\n[}]: #\n\nIn the previous step we've already set the route for this file, so if you'd like to run the game, simply start the server by typing `npm run serve`, and navigate to the address presented on the screen (Should be `localhost:8000` by default).\n\n> From now on I'm going to assume the server is running in the background, so I won't repeat the instruction above\n\nJust to make sure that the canvas is visible and not blended into the background, we will draw a black border around using a simple style-sheet:\n\n[{]: <helper> (diffStep 2.2)\n\n#### [Step 2.2: Create basic game stylesheet](https://github.com/DAB0mB/radial-snake/commit/44fe5aa)\n\n##### Added resources&#x2F;styles&#x2F;game.css\n```diff\n@@ -0,0 +1,6 @@\n+â”Š â”Š1â”Š#gameCanvas {\n+â”Š â”Š2â”Š  display: block;\n+â”Š â”Š3â”Š  margin: auto;\n+â”Š â”Š4â”Š  border-style: solid;\n+â”Š â”Š5â”Š  border-width: 1px;\n+â”Š â”Š6â”Š}ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -2,6 +2,9 @@\n â”Š 2â”Š 2â”Š<html>\n â”Š 3â”Š 3â”Š  <head>\n â”Š 4â”Š 4â”Š    <title>radial snake</title>\n+â”Š  â”Š 5â”Š\n+â”Š  â”Š 6â”Š    <!-- Styles -->\n+â”Š  â”Š 7â”Š    <link rel=\"stylesheet\" type=\"text/css\" href=\"/styles/game.css\">\n â”Š 5â”Š 8â”Š  </head>\n â”Š 6â”Š 9â”Š\n â”Š 7â”Š10â”Š  <body>\n```\n\n[}]: #\n\n> Note that every asset we create should be declared in the HTML file in order for it to take effect\n\nTo build this project we're also gonna use two very famous utility libraries called [JQuery](http://jquery.com/) and [Underscore](http://underscorejs.org/) which will make our lives a bit easier. Third-party libraries should be located in a directory called `libs`, according to the routes-map we created in the previous step. To set these libraries up, type the following commands in series:\n\n    resources$ mkdir libs\n    resources$ cd libs\n    resources/libs$ wget raw.githubusercontent.com/dab0mb/radial-snake/master/resources/libs/underscore.js\n    resources/libs$ wget raw.githubusercontent.com/dab0mb/radial-snake/master/resources/libs/jquery-2.1.1.js\n\nAnd load them in the game's HTML file's header:\n\n[{]: <helper> (diffStep 2.3 files=\"views/game.html\")\n\n#### [Step 2.3: Add jquery and underscore libs](https://github.com/DAB0mB/radial-snake/commit/085ca6b)\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -3,6 +3,10 @@\n â”Š 3â”Š 3â”Š  <head>\n â”Š 4â”Š 4â”Š    <title>radial snake</title>\n â”Š 5â”Š 5â”Š\n+â”Š  â”Š 6â”Š    <!-- Libs -->\n+â”Š  â”Š 7â”Š    <script type=\"text/javascript\" src=\"/libs/jquery-2.1.1.js\"></script>\n+â”Š  â”Š 8â”Š    <script type=\"text/javascript\" src=\"/libs/underscore.js\"></script>\n+â”Š  â”Š 9â”Š\n â”Š 6â”Š10â”Š    <!-- Styles -->\n â”Š 7â”Š11â”Š    <link rel=\"stylesheet\" type=\"text/css\" href=\"/styles/game.css\">\n â”Š 8â”Š12â”Š  </head>\n```\n\n[}]: #\n\nNow, we're finally going to build the game engine. At first, it's gonna be very basic simple, but further in this tutorial we're going to extend it and add some pretty neat features. When creating an application, of any kind, you don't want to garbage the global scope, so it can stay clean without any conflicts. Therefore, we're going to create an initial namespace for our game engine called `Engine`, which is going to contain all our game engine's classes and entities:\n\n[{]: <helper> (diffStep 2.4)\n\n#### [Step 2.4: Add engine namespace](https://github.com/DAB0mB/radial-snake/commit/3d52525)\n\n##### Added resources&#x2F;scripts&#x2F;namespaces.js\n```diff\n@@ -0,0 +1 @@\n+â”Š â”Š1â”ŠEngine = {};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -7,6 +7,9 @@\n â”Š 7â”Š 7â”Š    <script type=\"text/javascript\" src=\"/libs/jquery-2.1.1.js\"></script>\n â”Š 8â”Š 8â”Š    <script type=\"text/javascript\" src=\"/libs/underscore.js\"></script>\n â”Š 9â”Š 9â”Š\n+â”Š  â”Š10â”Š    <!-- Scripts -->\n+â”Š  â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n+â”Š  â”Š12â”Š\n â”Š10â”Š13â”Š    <!-- Styles -->\n â”Š11â”Š14â”Š    <link rel=\"stylesheet\" type=\"text/css\" href=\"/styles/game.css\">\n â”Š12â”Š15â”Š  </head>\n```\n\n[}]: #\n\nThe first thing we're going to define in the namespace we've just created would be the game loop. The game loop is the central code of your game, split into different parts. Generally, these are: update and draw.\n\nThe main purpose of the update phase is to prepare all objects to be drawn, so this is where all the geometry code, coordinate updates, score changes, animation refreshments and other similar operations belong. This is also where the input will be captured and processed.\n\nWhen everything is properly updated and ready, we enter the draw phase where all this information is put on the screen. This function should contain all the code to manage and draw the levels, shapes, score board and so on.\n\n![game-loop](https://cloud.githubusercontent.com/assets/7648874/21332964/4b80ef4e-c633-11e6-946a-0c5870d2f9c9.png)\n\n> You can find plenty of details and information about what \"game loop\" means simply by typing in on Google.\n\nA game loop can wear many forms, but the concept is gonna be the same, plus-minus. This is how our game loop is going to loop like:\n\n[{]: <helper> (diffStep 2.5)\n\n#### [Step 2.5: Create a game basis](https://github.com/DAB0mB/radial-snake/commit/1b7fcf9)\n\n##### Added resources&#x2F;scripts&#x2F;engine&#x2F;game.js\n```diff\n@@ -0,0 +1,99 @@\n+â”Š  â”Š 1â”ŠEngine.Game = class Game {\n+â”Š  â”Š 2â”Š  // The frequency of which each frame will be drawn in milliseconds\n+â”Š  â”Š 3â”Š  get fps() {\n+â”Š  â”Š 4â”Š    return 1000 / 60;\n+â”Š  â”Š 5â”Š  }\n+â”Š  â”Š 6â”Š\n+â”Š  â”Š 7â”Š  // Game's run speed.\n+â”Š  â”Š 8â”Š  // A lower value will make it run slower and a higher value will make it run faster\n+â”Š  â”Š 9â”Š  get speed() {\n+â”Š  â”Š10â”Š    return 1;\n+â”Š  â”Š11â”Š  }\n+â”Š  â”Š12â”Š\n+â”Š  â”Š13â”Š  constructor(canvas) {\n+â”Š  â”Š14â”Š    this.canvas = canvas;\n+â”Š  â”Š15â”Š    this.lastUpdate = this.creation = new Date().getTime();\n+â”Š  â”Š16â”Š\n+â”Š  â”Š17â”Š    // Canvas dimensions must be set programmatically otherwise you might encounter some\n+â”Š  â”Š18â”Š    // unexpected behaviors\n+â”Š  â”Š19â”Š    canvas.width = 1280;\n+â”Š  â”Š20â”Š    canvas.height = 720;\n+â”Š  â”Š21â”Š    // Canvas will be focused once game page is loaded so all events will automatically\n+â”Š  â”Š22â”Š    // be captured by it\n+â”Š  â”Š23â”Š    canvas.focus();\n+â”Š  â”Š24â”Š\n+â”Š  â”Š25â”Š    // We want to focus on the canvas once we press on it\n+â”Š  â”Š26â”Š    canvas.addEventListener(\"mousedown\", canvas.focus.bind(canvas), false);\n+â”Š  â”Š27â”Š\n+â”Š  â”Š28â”Š    this.assets = {};\n+â”Š  â”Š29â”Š    this.events = new Map();\n+â”Š  â”Š30â”Š    this.context = canvas.getContext(\"2d\");\n+â”Š  â”Š31â”Š    this.bufferedCanvas = document.createElement(\"canvas\");\n+â”Š  â”Š32â”Š    this.bufferedContext = this.bufferedCanvas.getContext(\"2d\");\n+â”Š  â”Š33â”Š    this.bufferedCanvas.width = canvas.width;\n+â”Š  â”Š34â”Š    this.bufferedCanvas.height = canvas.height;\n+â”Š  â”Š35â”Š  }\n+â”Š  â”Š36â”Š\n+â”Š  â”Š37â”Š  draw() {\n+â”Š  â”Š38â”Š    // Draw a black screen by default\n+â”Š  â”Š39â”Š    this.context.restore();\n+â”Š  â”Š40â”Š    this.context.fillStyle = \"black\";\n+â”Š  â”Š41â”Š    this.context.save();\n+â”Š  â”Š42â”Š    this.context.beginPath();\n+â”Š  â”Š43â”Š    this.context.rect(0, 0, this.canvas.width, this.canvas.height);\n+â”Š  â”Š44â”Š    this.context.fill();\n+â”Š  â”Š45â”Š  }\n+â”Š  â”Š46â”Š\n+â”Š  â”Š47â”Š  update() {\n+â”Š  â”Š48â”Š    // Calculate the time elapsed\n+â”Š  â”Š49â”Š    let lastUpdate = this.lastUpdate;\n+â”Š  â”Š50â”Š    let currUpdate = this.lastUpdate = new Date().getTime();\n+â”Š  â”Š51â”Š    let span = currUpdate - lastUpdate;\n+â”Š  â”Š52â”Š    this.updateScreen(span / this.speed);\n+â”Š  â”Š53â”Š  }\n+â”Š  â”Š54â”Š\n+â”Š  â”Š55â”Š  // The main loop of the game\n+â”Š  â”Š56â”Š  loop() {\n+â”Š  â”Š57â”Š    // If paused, don't run loop. The canvas will remain as is\n+â”Š  â”Š58â”Š    if (!this.playing) return;\n+â”Š  â”Š59â”Š\n+â”Š  â”Š60â”Š    setTimeout(() => {\n+â”Š  â”Š61â”Š      this.draw();\n+â”Š  â”Š62â”Š      this.update();\n+â”Š  â”Š63â”Š      this.loop();\n+â”Š  â”Š64â”Š    }, this.fps);\n+â”Š  â”Š65â”Š  }\n+â”Š  â”Š66â”Š\n+â”Š  â”Š67â”Š  play() {\n+â”Š  â”Š68â”Š    this.playing = true;\n+â”Š  â”Š69â”Š    this.loop();\n+â”Š  â”Š70â”Š  }\n+â”Š  â”Š71â”Š\n+â”Š  â”Š72â”Š  pause() {\n+â”Š  â”Š73â”Š    this.playing = false;\n+â”Š  â”Š74â”Š  }\n+â”Š  â”Š75â”Š\n+â”Š  â”Š76â”Š  // Defines global assets\n+â”Š  â”Š77â”Š  extendAssets(assets) {\n+â”Š  â”Š78â”Š    _.extend(this.assets, assets);\n+â”Š  â”Š79â”Š  }\n+â”Š  â”Š80â”Š\n+â”Š  â”Š81â”Š  // Disposes global assets\n+â”Š  â”Š82â”Š  clearAssets() {\n+â”Š  â”Š83â”Š    this.assets = {};\n+â”Š  â”Š84â”Š  }\n+â”Š  â”Š85â”Š\n+â”Š  â”Š86â”Š  // Adds event listener for game canvas\n+â”Š  â”Š87â”Š  addEventListener(type, listener, target) {\n+â”Š  â”Š88â”Š    let boundListener = listener.bind(target);\n+â”Š  â”Š89â”Š    this.events.set(listener, boundListener);\n+â”Š  â”Š90â”Š    this.canvas.addEventListener(type, boundListener, false);\n+â”Š  â”Š91â”Š  }\n+â”Š  â”Š92â”Š\n+â”Š  â”Š93â”Š  // Removes event listener from game canvas\n+â”Š  â”Š94â”Š  removeEventListener(type, listener) {\n+â”Š  â”Š95â”Š    let boundListener = this.events.get(listener);\n+â”Š  â”Š96â”Š    this.events.delete(listener);\n+â”Š  â”Š97â”Š    this.canvas.removeEventListener(type, boundListener, false);\n+â”Š  â”Š98â”Š  }\n+â”Š  â”Š99â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -9,6 +9,7 @@\n â”Š 9â”Š 9â”Š\n â”Š10â”Š10â”Š    <!-- Scripts -->\n â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n+â”Š  â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š12â”Š13â”Š\n â”Š13â”Š14â”Š    <!-- Styles -->\n â”Š14â”Š15â”Š    <link rel=\"stylesheet\" type=\"text/css\" href=\"/styles/game.css\">\n```\n\n[}]: #\n\nThe only thing it's doing right now is drawing a black background, but we're soon going to learn how to take advantage of this game-loop to draw stuff of our own. I'd like to point out that there is no need to implement a [double-buffer](https://en.wikipedia.org/wiki/Multiple_buffering) (A method similar to React's [virtual DOM](https://www.npmjs.com/package/react-dom)) when it comes to `HTMLCanvas` elements, since `HTML5` already does that for us. To start running the game, we first need to wait for the DOM content to initialize, and once it's ready we gonna create a new game instance and call the `play` method:\n\n[{]: <helper> (diffStep 2.6)\n\n#### [Step 2.6: Create game entry point](https://github.com/DAB0mB/radial-snake/commit/30e75df)\n\n##### Added resources&#x2F;scripts&#x2F;main.js\n```diff\n@@ -0,0 +1,4 @@\n+â”Š â”Š1â”Šdocument.addEventListener(\"DOMContentLoaded\", function(event) {\n+â”Š â”Š2â”Š  let game = new Engine.Game(document.getElementById(\"gameCanvas\"), false);\n+â”Š â”Š3â”Š  game.play();\n+â”Š â”Š4â”Š});ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -10,6 +10,7 @@\n â”Š10â”Š10â”Š    <!-- Scripts -->\n â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n â”Š12â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n+â”Š  â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n â”Š13â”Š14â”Š\n â”Š14â”Š15â”Š    <!-- Styles -->\n â”Š15â”Š16â”Š    <link rel=\"stylesheet\" type=\"text/css\" href=\"/styles/game.css\">\n```\n\n[}]: #\n\nThis will take control over the canvas and will draw a new picture every 17ms, which is 60fps (Frames per second). As for now you're only going to see a black canvas, but I promise the final result is not going to disappoint you.\n\nThe next thing we're gonna do would be adding a 'key state' manager, which will store a flag for each key pressed on the keyboard. Once we press the key, the flag's value would be `true`, and once we release it, its value would turn into `false`. This way we have an easy way to track all the key presses without registering a specific event listener for each key press we wanna track:\n\n[{]: <helper> (diffStep 2.7)\n\n#### [Step 2.7: Add key states manager](https://github.com/DAB0mB/radial-snake/commit/831b058)\n\n##### Added resources&#x2F;scripts&#x2F;engine&#x2F;key_states.js\n```diff\n@@ -0,0 +1,20 @@\n+â”Š  â”Š 1â”ŠEngine.KeyStates = class KeyStates {\n+â”Š  â”Š 2â”Š  constructor() {\n+â”Š  â”Š 3â”Š    // We will have 255 states, each one represents an ascii code matching its index\n+â”Š  â”Š 4â”Š    this.states = new Array(255);\n+â”Š  â”Š 5â”Š  }\n+â”Š  â”Š 6â”Š\n+â”Š  â”Š 7â”Š  get(k) {\n+â”Š  â”Š 8â”Š    return this.states[k];\n+â”Š  â”Š 9â”Š  }\n+â”Š  â”Š10â”Š\n+â”Š  â”Š11â”Š  // This should be called once we press a key\n+â”Š  â”Š12â”Š  add(k) {\n+â”Š  â”Š13â”Š    this.states[k] = true;\n+â”Š  â”Š14â”Š  }\n+â”Š  â”Š15â”Š\n+â”Š  â”Š16â”Š  // This should be called once we release a key\n+â”Š  â”Š17â”Š  remove(k) {\n+â”Š  â”Š18â”Š    this.states[k] = false;\n+â”Š  â”Š19â”Š  }\n+â”Š  â”Š20â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -9,6 +9,7 @@\n â”Š 9â”Š 9â”Š\n â”Š10â”Š10â”Š    <!-- Scripts -->\n â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n+â”Š  â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/key_states.js\"></script>\n â”Š12â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n```\n\n[}]: #\n\nNow that we have the key state manager, we will initialize a new instance as part of our game's essentials, and we will create a global event listener for key presses; Each time a key is pressed, the key state manager will update itself:\n\n[{]: <helper> (diffStep 2.8)\n\n#### [Step 2.8: Register key presses](https://github.com/DAB0mB/radial-snake/commit/9f55501)\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;game.js\n```diff\n@@ -14,7 +14,7 @@\n â”Š14â”Š14â”Š    this.canvas = canvas;\n â”Š15â”Š15â”Š    this.lastUpdate = this.creation = new Date().getTime();\n â”Š16â”Š16â”Š\n-â”Š17â”Š  â”Š    // Canvas dimensions must be set programmatically otherwise you might encounter some\n+â”Š  â”Š17â”Š    // Canvas dimensions must be set programmatically, otherwise you might encounter some\n â”Š18â”Š18â”Š    // unexpected behaviors\n â”Š19â”Š19â”Š    canvas.width = 1280;\n â”Š20â”Š20â”Š    canvas.height = 720;\n```\n```diff\n@@ -24,9 +24,13 @@\n â”Š24â”Š24â”Š\n â”Š25â”Š25â”Š    // We want to focus on the canvas once we press on it\n â”Š26â”Š26â”Š    canvas.addEventListener(\"mousedown\", canvas.focus.bind(canvas), false);\n+â”Š  â”Š27â”Š    // Key flags will be registered by the \"KeyStates\" instance\n+â”Š  â”Š28â”Š    canvas.addEventListener(\"keydown\", onKeyDown.bind(this), false);\n+â”Š  â”Š29â”Š    canvas.addEventListener(\"keyup\", onKeyUp.bind(this), false);\n â”Š27â”Š30â”Š\n â”Š28â”Š31â”Š    this.assets = {};\n â”Š29â”Š32â”Š    this.events = new Map();\n+â”Š  â”Š33â”Š    this.keyStates = new Engine.KeyStates();\n â”Š30â”Š34â”Š    this.context = canvas.getContext(\"2d\");\n â”Š31â”Š35â”Š    this.bufferedCanvas = document.createElement(\"canvas\");\n â”Š32â”Š36â”Š    this.bufferedContext = this.bufferedCanvas.getContext(\"2d\");\n```\n```diff\n@@ -96,4 +100,19 @@\n â”Š 96â”Š100â”Š    this.events.delete(listener);\n â”Š 97â”Š101â”Š    this.canvas.removeEventListener(type, boundListener, false);\n â”Š 98â”Š102â”Š  }\n-â”Š 99â”Š   â”Š};ðŸš«â†µ\n+â”Š   â”Š103â”Š};\n+â”Š   â”Š104â”Š\n+â”Š   â”Š105â”Šfunction onKeyDown(e) {\n+â”Š   â”Š106â”Š  // Once we're focused on the canvas, we want nothing else to happen\n+â”Š   â”Š107â”Š  // besides events the game is listening to. For example, when we press\n+â”Š   â”Š108â”Š  // the arrow keys, this will prevent the screen from scrolling\n+â”Š   â”Š109â”Š  e.preventDefault();\n+â”Š   â”Š110â”Š  // Register key press\n+â”Š   â”Š111â”Š  this.keyStates.add(e.keyCode);\n+â”Š   â”Š112â”Š}\n+â”Š   â”Š113â”Š\n+â”Š   â”Š114â”Šfunction onKeyUp(e) {\n+â”Š   â”Š115â”Š  e.preventDefault();\n+â”Š   â”Š116â”Š  // Register key release\n+â”Š   â”Š117â”Š  this.keyStates.remove(e.keyCode);\n+â”Š   â”Š118â”Š}\n```\n\n[}]: #\n\nA 2D game's view might get complex as we go through with its development and add more logic and entities into it. Having only one `draw` method and only one `update` method is not enough, and if you think of it, it might easily get buffed up into ridiculous dimensions, which is not the way to go. I'd like to introduce you into a new methodology which involves `screens` and `layers`:\n\n- **screen** - Will literally be used whenever we want to show a new screen in our game e.g. 'splash' screen and 'main menu' screen. A screen consists of multiple layers, and will be used as their communicator; All the relevant assets and logic will be initialized inside it.\n- **layer** - similar to Photoshop's layer system, any time we want to add something to the view we add new layers on top or beneath of each other.\n\n![screen-layer](https://cloud.githubusercontent.com/assets/7648874/21487708/9b366efe-cbb7-11e6-8669-3212e440871a.png)\n\nAs I said earlier, the purpose of the screens and the layers is just to split the task of updating and drawing and updating, so we can have logical segments; So the `layer` class should mainly consist of a `draw` and an `update` method:\n\n[{]: <helper> (diffStep 2.9)\n\n#### [Step 2.9: Add screen layer](https://github.com/DAB0mB/radial-snake/commit/736ab08)\n\n##### Added resources&#x2F;scripts&#x2F;engine&#x2F;layer.js\n```diff\n@@ -0,0 +1,43 @@\n+â”Š  â”Š 1â”ŠEngine.Layer = class Layer {\n+â”Š  â”Š 2â”Š  // The dimensions of the layer are correlated to dimensions of the canvas\n+â”Š  â”Š 3â”Š  get width() {\n+â”Š  â”Š 4â”Š    return this.canvas.width;\n+â”Š  â”Š 5â”Š  }\n+â”Š  â”Š 6â”Š\n+â”Š  â”Š 7â”Š  get height() {\n+â”Š  â”Š 8â”Š    return this.canvas.height;\n+â”Š  â”Š 9â”Š  }\n+â”Š  â”Š10â”Š\n+â”Š  â”Š11â”Š  // A hash of \"eventName\" : \"handlerName\" which should be overrided by user\n+â”Š  â”Š12â”Š  get events() {\n+â”Š  â”Š13â”Š    return {};\n+â”Š  â”Š14â”Š  }\n+â”Š  â”Š15â”Š\n+â”Š  â”Š16â”Š  constructor(screen) {\n+â”Š  â”Š17â”Š    this.age = 0;\n+â”Š  â”Š18â”Š    this.creation = new Date().getTime();\n+â”Š  â”Š19â”Š    this.screen = screen;\n+â”Š  â”Š20â”Š    this.game = screen.game;\n+â”Š  â”Š21â”Š    this.assets = screen.assets;\n+â”Š  â”Š22â”Š    this.keyStates = screen.keyStates;\n+â”Š  â”Š23â”Š    this.canvas = screen.game.canvas;\n+â”Š  â”Š24â”Š  }\n+â”Š  â”Š25â”Š\n+â”Š  â”Š26â”Š  update(span) {\n+â”Š  â”Š27â”Š  }\n+â”Š  â”Š28â”Š\n+â”Š  â”Š29â”Š  draw(context) {\n+â”Š  â”Š30â”Š  }\n+â”Š  â”Š31â”Š\n+â”Š  â”Š32â”Š  initEventListeners() {\n+â”Š  â”Š33â”Š    _.each(this.events, (listener, event) => {\n+â”Š  â”Š34â”Š      this.game.addEventListener(event, this[listener], this);\n+â”Š  â”Š35â”Š    });\n+â”Š  â”Š36â”Š  }\n+â”Š  â”Š37â”Š\n+â”Š  â”Š38â”Š  disposeEventListeners() {\n+â”Š  â”Š39â”Š    _.each(this.events, (listener, event) => {\n+â”Š  â”Š40â”Š      this.game.removeEventListener(event, this[listener]);\n+â”Š  â”Š41â”Š    });\n+â”Š  â”Š42â”Š  }\n+â”Š  â”Š43â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -10,6 +10,7 @@\n â”Š10â”Š10â”Š    <!-- Scripts -->\n â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n â”Š12â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/key_states.js\"></script>\n+â”Š  â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/layer.js\"></script>\n â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š14â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n```\n\n[}]: #\n\nSame thing for the screen, it only has a `draw` and `update` methods, only it has a stack of layers, which can either be added or removed:\n\n[{]: <helper> (diffStep 2.1)\n\n#### [Step 2.1: Create basic game view](https://github.com/DAB0mB/radial-snake/commit/254f06f)\n\n##### Added views&#x2F;game.html\n```diff\n@@ -0,0 +1,10 @@\n+â”Š  â”Š 1â”Š<!DOCTYPE html>\n+â”Š  â”Š 2â”Š<html>\n+â”Š  â”Š 3â”Š  <head>\n+â”Š  â”Š 4â”Š    <title>radial snake</title>\n+â”Š  â”Š 5â”Š  </head>\n+â”Š  â”Š 6â”Š\n+â”Š  â”Š 7â”Š  <body>\n+â”Š  â”Š 8â”Š    <canvas id=\"gameCanvas\" tabindex=\"0\"></canvas>\n+â”Š  â”Š 9â”Š  </body>\n+â”Š  â”Š10â”Š</html>ðŸš«â†µ\n```\n\n[}]: #\n\nNow that we have the `screen` class available for us, let's apply it to the main game loop:\n\n[{]: <helper> (diffStep 2.11)\n\n#### [Step 2.11: Draw and update screen in game loop](https://github.com/DAB0mB/radial-snake/commit/9f34754)\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;game.js\n```diff\n@@ -30,6 +30,7 @@\n â”Š30â”Š30â”Š\n â”Š31â”Š31â”Š    this.assets = {};\n â”Š32â”Š32â”Š    this.events = new Map();\n+â”Š  â”Š33â”Š    this.screen = new Engine.Screen(this);\n â”Š33â”Š34â”Š    this.keyStates = new Engine.KeyStates();\n â”Š34â”Š35â”Š    this.context = canvas.getContext(\"2d\");\n â”Š35â”Š36â”Š    this.bufferedCanvas = document.createElement(\"canvas\");\n```\n```diff\n@@ -46,6 +47,13 @@\n â”Š46â”Š47â”Š    this.context.beginPath();\n â”Š47â”Š48â”Š    this.context.rect(0, 0, this.canvas.width, this.canvas.height);\n â”Š48â”Š49â”Š    this.context.fill();\n+â”Š  â”Š50â”Š    this.drawScreen(this.context);\n+â”Š  â”Š51â”Š  }\n+â”Š  â”Š52â”Š\n+â”Š  â”Š53â”Š  drawScreen(context) {\n+â”Š  â”Š54â”Š    // If screen's assets are not yet loaded, don't draw it\n+â”Š  â”Š55â”Š    if (this.screen.loading) return;\n+â”Š  â”Š56â”Š    if (this.screen.draw) this.screen.draw(context);\n â”Š49â”Š57â”Š  }\n â”Š50â”Š58â”Š\n â”Š51â”Š59â”Š  update() {\n```\n```diff\n@@ -56,6 +64,13 @@\n â”Š56â”Š64â”Š    this.updateScreen(span / this.speed);\n â”Š57â”Š65â”Š  }\n â”Š58â”Š66â”Š\n+â”Š  â”Š67â”Š  updateScreen(span) {\n+â”Š  â”Š68â”Š    this.screen.age += span;\n+â”Š  â”Š69â”Š    // If screen's assets are not yet loaded, don't update it\n+â”Š  â”Š70â”Š    if (this.screen.loading) return;\n+â”Š  â”Š71â”Š    if (this.screen.update) this.screen.update(span);\n+â”Š  â”Š72â”Š  }\n+â”Š  â”Š73â”Š\n â”Š59â”Š74â”Š  // The main loop of the game\n â”Š60â”Š75â”Š  loop() {\n â”Š61â”Š76â”Š    // If paused, don't run loop. The canvas will remain as is\n```\n\n[}]: #\n\nThis step looks kind of useless for now, unless we will have the ability to change screens as we please. Any time a screen is changed, it should be loaded with its necessary assets e.g textures, sounds, fonts, etc. The assets loading is an asynchronous operation whose logic might get a bit messy if not managed properly. To make it easier, we're going to define an assets loader, which will help us load assets asynchronously:\n\n[{]: <helper> (diffStep 2.12)\n\n#### [Step 2.12: Add assets loader](https://github.com/DAB0mB/radial-snake/commit/d8895f8)\n\n##### Added resources&#x2F;scripts&#x2F;engine&#x2F;assets_loader.js\n```diff\n@@ -0,0 +1,13 @@\n+â”Š  â”Š 1â”ŠEngine.AssetsLoader = class AssetsLoader {\n+â”Š  â”Š 2â”Š  constructor(next) {\n+â”Š  â”Š 3â”Š    this.next = next;\n+â”Š  â”Š 4â”Š  }\n+â”Š  â”Š 5â”Š\n+â”Š  â”Š 6â”Š  // Load texture\n+â”Š  â”Š 7â”Š  texture(path) {\n+â”Š  â”Š 8â”Š    let image = new Image();\n+â”Š  â”Š 9â”Š    image.onload = this.next();\n+â”Š  â”Š10â”Š    image.src = `${path}.png`;\n+â”Š  â”Š11â”Š    return image;\n+â”Š  â”Š12â”Š  }\n+â”Š  â”Š13â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -12,6 +12,7 @@\n â”Š12â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/key_states.js\"></script>\n â”Š13â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/layer.js\"></script>\n â”Š14â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/screen.js\"></script>\n+â”Š  â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/assets_loader.js\"></script>\n â”Š15â”Š16â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š16â”Š17â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n```\n\n[}]: #\n\n> As for now the `assets loader` only has the ability to load textures, but we will extend it as we go further in this tutorial, no need to overdo it.\n\nNow that we have the `assets loader` we can add the ability to change a screen. Whenever we change a screen, the old screen's assets should be unloaded, and the new screen's assets should be loaded using the `assets loader`:\n\n[{]: <helper> (diffStep 2.13)\n\n#### [Step 2.13: Add the ability to change and load screen](https://github.com/DAB0mB/radial-snake/commit/90aab03)\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;game.js\n```diff\n@@ -92,6 +92,61 @@\n â”Š 92â”Š 92â”Š    this.playing = false;\n â”Š 93â”Š 93â”Š  }\n â”Š 94â”Š 94â”Š\n+â”Š   â”Š 95â”Š  changeScreen(Screen, ...screenArgs) {\n+â”Š   â”Š 96â”Š    // If there is a screen defined, dispose it first\n+â”Š   â”Š 97â”Š    if (this.screen) {\n+â”Š   â”Š 98â”Š      this.unloadScreen();\n+â”Š   â”Š 99â”Š      this.screen.disposeEventListeners();\n+â”Š   â”Š100â”Š    }\n+â”Š   â”Š101â”Š\n+â”Š   â”Š102â”Š    this.screen = new Screen(this, ...screenArgs);\n+â”Š   â”Š103â”Š\n+â”Š   â”Š104â”Š    // Load screen assets\n+â”Š   â”Š105â”Š    this.loadScreen(() => {\n+â”Š   â”Š106â”Š      // Once assets are loaded, initialize event listeners\n+â”Š   â”Š107â”Š      this.screen.initEventListeners();\n+â”Š   â”Š108â”Š      // The \"initialize\" method is exactly the same as the constructor, only it runs\n+â”Š   â”Š109â”Š      // once assets are available and event listeners are registered\n+â”Š   â”Š110â”Š      this.screen.initialize(this, ...screenArgs);\n+â”Š   â”Š111â”Š    });\n+â”Š   â”Š112â”Š  }\n+â”Š   â”Š113â”Š\n+â”Š   â”Š114â”Š  // Loads screen assets and invokes callback once loading is finished\n+â”Š   â”Š115â”Š  loadScreen(callback = _.noop) {\n+â”Š   â”Š116â”Š    if (!this.screen.load) return callback();\n+â”Š   â”Š117â”Š\n+â”Š   â”Š118â”Š    this.screen.loading = true;\n+â”Š   â”Š119â”Š    // The number of assets to load\n+â”Š   â”Š120â”Š    let loadsize = 0;\n+â”Š   â”Š121â”Š    let onload;\n+â”Š   â”Š122â”Š\n+â”Š   â”Š123â”Š    // This object can load assets\n+â”Š   â”Š124â”Š    let assetsLoader = new Engine.AssetsLoader(() => {\n+â”Š   â”Š125â”Š      loadsize++;\n+â”Š   â”Š126â”Š      return () => onload();\n+â”Š   â”Š127â”Š    });\n+â”Š   â”Š128â”Š\n+â”Š   â”Š129â”Š    // The \"load\" method returns the assets loaded by the screen\n+â”Š   â”Š130â”Š    let screenAssets = this.screen.load(assetsLoader);\n+â”Š   â”Š131â”Š\n+â”Š   â”Š132â”Š    // We use the \"after\" method because we want the following callback to be invoked\n+â”Š   â”Š133â”Š    // only once all assets are loaded\n+â”Š   â”Š134â”Š    onload = _.after(loadsize, () => {\n+â”Š   â”Š135â”Š      delete this.screen.loading;\n+â”Š   â”Š136â”Š      callback();\n+â”Š   â”Š137â”Š    });\n+â”Š   â”Š138â”Š\n+â”Š   â”Š139â”Š    // The returned assets will be available on screen's assets object\n+â”Š   â”Š140â”Š    _.extend(this.screen.assets, screenAssets);\n+â”Š   â”Š141â”Š  }\n+â”Š   â”Š142â”Š\n+â”Š   â”Š143â”Š  // Disposes screen assets\n+â”Š   â”Š144â”Š  unloadScreen() {\n+â”Š   â”Š145â”Š    if (!this.screen.unload) return;\n+â”Š   â”Š146â”Š    let assetsNames = this.screen.unload();\n+â”Š   â”Š147â”Š    _.omit(this.assets, assetsNames);\n+â”Š   â”Š148â”Š  }\n+â”Š   â”Š149â”Š\n â”Š 95â”Š150â”Š  // Defines global assets\n â”Š 96â”Š151â”Š  extendAssets(assets) {\n â”Š 97â”Š152â”Š    _.extend(this.assets, assets);\n```\n\n[}]: #\n\nLet's add a test screen just so we can get the hang of it. The test screen will only print a message to the canvas:\n\n[{]: <helper> (diffStep 2.14)\n\n#### [Step 2.14: Add test screen](https://github.com/DAB0mB/radial-snake/commit/85776e8)\n\n##### Added resources&#x2F;scripts&#x2F;test_screen.js\n```diff\n@@ -0,0 +1,10 @@\n+â”Š  â”Š 1â”Šclass TestScreen extends Engine.Screen {\n+â”Š  â”Š 2â”Š  draw(context) {\n+â”Š  â”Š 3â”Š    // A 20px sized \"Georgia\" font (Available natively)\n+â”Š  â”Š 4â”Š    context.font = \"20px Georgia\";\n+â”Š  â”Š 5â”Š    // The text should be colored white\n+â”Š  â”Š 6â”Š    context.fillStyle = \"white\";\n+â”Š  â”Š 7â”Š    // Draw the following message 50px from the left and 50px from the top\n+â”Š  â”Š 8â”Š    context.fillText(\"This is a Test Screen\", 50, 50);\n+â”Š  â”Š 9â”Š  }\n+â”Š  â”Š10â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -14,6 +14,7 @@\n â”Š14â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/screen.js\"></script>\n â”Š15â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/assets_loader.js\"></script>\n â”Š16â”Š16â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n+â”Š  â”Š17â”Š    <script type=\"text/javascript\" src=\"/scripts/test_screen.js\"></script>\n â”Š17â”Š18â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n â”Š18â”Š19â”Š\n â”Š19â”Š20â”Š    <!-- Styles -->\n```\n\n[}]: #\n\nNow we will use the test screen by changing to it as we create an instance of the game:\n\n[{]: <helper> (diffStep 2.15)\n\n#### [Step 2.15: Set test screen as the initial screen](https://github.com/DAB0mB/radial-snake/commit/203d084)\n\n##### Changed resources&#x2F;scripts&#x2F;main.js\n```diff\n@@ -1,4 +1,5 @@\n â”Š1â”Š1â”Šdocument.addEventListener(\"DOMContentLoaded\", function(event) {\n â”Š2â”Š2â”Š  let game = new Engine.Game(document.getElementById(\"gameCanvas\"), false);\n+â”Š â”Š3â”Š  game.changeScreen(TestScreen);\n â”Š3â”Š4â”Š  game.play();\n â”Š4â”Š5â”Š});ðŸš«â†µ\n```\n\n[}]: #\n\nOnce you will load the application you should see a black canvas with a white text saying:\n\n    This is a test screen\n\nIt means our screen system works and you may proceed to the next step, where we're gonna create our first screen :-)"
          },
          {
            "manualTitle": "Step 3: Creating a splash screen using a keyframe animation engine",
            "stepRevision": "4b2431bbc910f8945e5fd86aa964fec3ede8761c",
            "manualView": "![snake-demo-splash-small](https://cloud.githubusercontent.com/assets/7648874/21074086/a19fa9ce-bed6-11e6-9060-2ce94c215712.gif)\n\nIn this step we will be creating the `splash` screen - the initial screen that should be shown once we launch the game. Our splash is consisted of a random logo animation as presented in the `gif` file above. The \"splash\" effect can be achieved using 2 concepts:\n\n- A sprite class - Which will present the logo texture in different dimensions, angles and rotations.\n- A key-frame animation - Which will draw an animation automatically along the time axis using key-frames - each is a sprite representation of the texture in a specific time point.\n\nSo first thing first, we will start by implementing the sprite class:\n\n[{]: <helper> (diffStep 3.1)\n\n#### [Step 3.1: Create &#x27;Sprite&#x27; class](https://github.com/DAB0mB/radial-snake/commit/a32a711)\n\n##### Added resources&#x2F;scripts&#x2F;engine&#x2F;sprite.js\n```diff\n@@ -0,0 +1,58 @@\n+â”Š  â”Š 1â”ŠEngine.Sprite = class Sprite {\n+â”Š  â”Š 2â”Š  // An easy representation of a sprite on a canvas, with a set of convenient tools\n+â”Š  â”Š 3â”Š  // for alignment and coloring\n+â”Š  â”Š 4â”Š  constructor(texture) {\n+â”Š  â”Š 5â”Š    this.texture = texture;\n+â”Š  â”Š 6â”Š    this.x = 0;\n+â”Š  â”Š 7â”Š    this.y = 0;\n+â”Š  â”Š 8â”Š    this.width = texture.width;\n+â”Š  â”Š 9â”Š    this.height = texture.height;\n+â”Š  â”Š10â”Š    this.pivot = { x: 0, y: 0 };\n+â”Š  â”Š11â”Š    this.opacity = 1;\n+â”Š  â”Š12â”Š  }\n+â”Š  â”Š13â”Š\n+â”Š  â”Š14â”Š  draw(context, offsetX = 0, offsetY = 0) {\n+â”Š  â”Š15â”Š    context.save();\n+â”Š  â”Š16â”Š    context.globalAlpha = this.opacity;\n+â”Š  â”Š17â”Š\n+â”Š  â”Š18â”Š    // The following switch-case can also be seen as a list of all possible\n+â”Š  â”Š19â”Š    // alignment modes\n+â”Š  â”Š20â”Š    switch (this.align) {\n+â”Š  â”Š21â”Š      case \"top-left\": case \"left-top\": this.pivot = { x: 0, y: 0 }; break;\n+â”Š  â”Š22â”Š      case \"top-right\": case \"right-top\": this.pivot = { x: this.width, y: 0 }; break;\n+â”Š  â”Š23â”Š      case \"bottom-left\": case \"left-bottom\": this.pivot = { x: 0, y: this.height }; break;\n+â”Š  â”Š24â”Š      case \"bottom-right\": case \"right-bottom\": this.pivot = { x: this.width, y: this.height }; break;\n+â”Š  â”Š25â”Š      case \"middle\": case \"center\": this.pivot = { x: this.width / 2, y: this.height / 2 }; break;\n+â”Š  â”Š26â”Š      case \"left\": this.pivot = { x: 0, y: this.height / 2 }; break;\n+â”Š  â”Š27â”Š      case \"top\": this.pivot = { x: this.width / 2, y: 0 }; break;\n+â”Š  â”Š28â”Š      case \"right\": this.pivot = { x: this.width, y: this.height / 2 }; break;\n+â”Š  â”Š29â”Š      case \"bottom\": this.pivot = { x: this.width / 2, y: this.height }; break;\n+â”Š  â”Š30â”Š    }\n+â”Š  â”Š31â”Š\n+â”Š  â”Š32â”Š    context.drawImage(\n+â”Š  â”Š33â”Š      this.texture,\n+â”Š  â”Š34â”Š      (this.x - this.pivot.x) + offsetX,\n+â”Š  â”Š35â”Š      (this.y - this.pivot.y) + offsetY,\n+â”Š  â”Š36â”Š      this.width,\n+â”Š  â”Š37â”Š      this.height\n+â”Š  â”Š38â”Š    );\n+â”Š  â”Š39â”Š\n+â”Š  â”Š40â”Š    context.restore();\n+â”Š  â”Š41â”Š  }\n+â”Š  â”Š42â”Š\n+â”Š  â”Š43â”Š  // A sprite property (key) can also be resized based on a given percentage.\n+â”Š  â”Š44â”Š  // The 'relative' argument represents the whole of which the percents are gonna be\n+â”Š  â”Š45â”Š  // calculated from, and the 'adapters' argument is an array of property names which\n+â”Š  â”Š46â”Š  // gonna adapt themselves based on the changes made in the given key.\n+â”Š  â”Š47â”Š  // Usually 'width' goes along with ['height'] adapters, if we\n+â”Š  â”Š48â”Š  // want to keep their original ratio\n+â”Š  â”Š49â”Š  setPercentage(key, relative, percents, ...adapters) {\n+â”Š  â”Š50â”Š    let oldVal = this[key];\n+â”Š  â”Š51â”Š    let newVal = this[key] = (percents * relative) / 100;\n+â”Š  â”Š52â”Š    let ratio = newVal / oldVal;\n+â”Š  â”Š53â”Š\n+â”Š  â”Š54â”Š    adapters.forEach(adapter => {\n+â”Š  â”Š55â”Š      this[adapter] *= ratio;\n+â”Š  â”Š56â”Š    });\n+â”Š  â”Š57â”Š  }\n+â”Š  â”Š58â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -9,6 +9,7 @@\n â”Š 9â”Š 9â”Š\n â”Š10â”Š10â”Š    <!-- Scripts -->\n â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n+â”Š  â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/sprite.js\"></script>\n â”Š12â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/key_states.js\"></script>\n â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/layer.js\"></script>\n â”Š14â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/screen.js\"></script>\n```\n\n[}]: #\n\nAnd we will download the logo which will be presented in the splash screen using the sprite class:\n\n    resources$ mkdir assets\n    resources$ cd assets\n    resources/assets$ mkdir textures\n    resources/assets$ cd textures\n    resources/assets/textures$ wget raw.githubusercontent.com/dab0mb/radial-snake/master/resources/assets/textures/splash.png\n\n> Any logo can that you desired can be used instead! But to ease things up I already provided you with one as a sample\n\nNow we will create the initial splash screen, where we only gonna show a sprite of the logo in the middle of the screen, with no animation applied yet. We will first define a dedicated `Screens` module under the `Game` namespace:\n\n[{]: <helper> (diffStep 3.3)\n\n#### [Step 3.3: Create a &#x27;Game&#x27; namespace with a &#x27;Screens&#x27; module](https://github.com/DAB0mB/radial-snake/commit/ae85a96)\n\n##### Changed resources&#x2F;scripts&#x2F;namespaces.js\n```diff\n@@ -1 +1,5 @@\n+â”Š â”Š1â”ŠGame = {\n+â”Š â”Š2â”Š  Screens: {}\n+â”Š â”Š3â”Š};\n+â”Š â”Š4â”Š\n â”Š1â”Š5â”ŠEngine = {};ðŸš«â†µ\n```\n\n[}]: #\n\nAnd we can go ahead and implement the screen itself:\n\n[{]: <helper> (diffStep 3.4)\n\n#### [Step 3.4: Create initial splash screen](https://github.com/DAB0mB/radial-snake/commit/4dd73f3)\n\n##### Added resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;splash&#x2F;index.js\n```diff\n@@ -0,0 +1,19 @@\n+â”Š  â”Š 1â”ŠGame.Screens.Splash = class Splash extends Engine.Screen {\n+â”Š  â”Š 2â”Š  initialize() {\n+â”Š  â”Š 3â”Š    // Create splash sprite and set its properties\n+â”Š  â”Š 4â”Š    this.splashSprite = new Engine.Sprite(this.assets.splashTexture);\n+â”Š  â”Š 5â”Š    this.splashSprite.align = \"center\";\n+â”Š  â”Š 6â”Š    this.splashSprite.x = this.width / 2;\n+â”Š  â”Š 7â”Š  }\n+â”Š  â”Š 8â”Š\n+â”Š  â”Š 9â”Š  load(assetsLoader) {\n+â”Š  â”Š10â”Š    // These are local assets which will be disposed along with the screen\n+â”Š  â”Š11â”Š    return {\n+â”Š  â”Š12â”Š      splashTexture: assetsLoader.texture(\"/textures/splash\")\n+â”Š  â”Š13â”Š    };\n+â”Š  â”Š14â”Š  }\n+â”Š  â”Š15â”Š\n+â”Š  â”Š16â”Š  draw(context) {\n+â”Š  â”Š17â”Š    this.splashSprite.draw(context);\n+â”Š  â”Š18â”Š  }\n+â”Š  â”Š19â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -16,6 +16,7 @@\n â”Š16â”Š16â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/assets_loader.js\"></script>\n â”Š17â”Š17â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š18â”Š18â”Š    <script type=\"text/javascript\" src=\"/scripts/test_screen.js\"></script>\n+â”Š  â”Š19â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/splash/index.js\"></script>\n â”Š19â”Š20â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n â”Š20â”Š21â”Š\n â”Š21â”Š22â”Š    <!-- Styles -->\n```\n\n[}]: #\n\nNow we can set the splash screen as the initial screen in the entry script file:\n\n[{]: <helper> (diffStep 3.5)\n\n#### [Step 3.5: Set splash screen as the initial game screen](https://github.com/DAB0mB/radial-snake/commit/3576ff8)\n\n##### Changed resources&#x2F;scripts&#x2F;main.js\n```diff\n@@ -1,5 +1,5 @@\n â”Š1â”Š1â”Šdocument.addEventListener(\"DOMContentLoaded\", function(event) {\n â”Š2â”Š2â”Š  let game = new Engine.Game(document.getElementById(\"gameCanvas\"), false);\n-â”Š3â”Š â”Š  game.changeScreen(TestScreen);\n+â”Š â”Š3â”Š  game.changeScreen(Game.Screens.Splash);\n â”Š4â”Š4â”Š  game.play();\n â”Š5â”Š5â”Š});ðŸš«â†µ\n```\n\n[}]: #\n\nAnd we will get rid of the unnecessary test screen since we make no use of it any longer:\n\n    $ rm resources/scripts/test_screen.js\n\nWe will now proceed into the next stage where we will be implementing the key-frame animation engine as said at the beginning of the step. We first need to define an `Animations` module, since we can have multiple types of animation strategy like [sprite-atlas animation](http://www.joshmorony.com/how-to-create-animations-in-phaser-with-a-texture-atlas/), not necessarily a key-frame animation:\n\n[{]: <helper> (diffStep 3.7)\n\n#### [Step 3.7: Add &#x27;Animations&#x27; module to &#x27;Engine&#x27; namespace](https://github.com/DAB0mB/radial-snake/commit/ffe800c)\n\n##### Changed resources&#x2F;scripts&#x2F;namespaces.js\n```diff\n@@ -2,4 +2,6 @@\n â”Š2â”Š2â”Š  Screens: {}\n â”Š3â”Š3â”Š};\n â”Š4â”Š4â”Š\n-â”Š5â”Š â”ŠEngine = {};ðŸš«â†µ\n+â”Š â”Š5â”ŠEngine = {\n+â”Š â”Š6â”Š  Animations: {}\n+â”Š â”Š7â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nInside the newly created module we will create the key-frame animation engine. The key-frame animation consists of the following methods:\n\n- update - Updates the animation.\n- draw - Draws the current animation frame on the provided canvas context.\n- play - Enables update operations.\n- pause - Disables update operations.\n\n[{]: <helper> (diffStep 3.8)\n\n#### [Step 3.8: Create a key-frame animation engine](https://github.com/DAB0mB/radial-snake/commit/64c58fb)\n\n##### Added resources&#x2F;scripts&#x2F;engine&#x2F;animations&#x2F;keyframe.js\n```diff\n@@ -0,0 +1,142 @@\n+â”Š   â”Š  1â”ŠEngine.Animations.Keyframe = class Keyframe {\n+â”Š   â”Š  2â”Š  constructor(sprite, keyframes) {\n+â”Š   â”Š  3â”Š    this.sprite = sprite;\n+â”Š   â”Š  4â”Š    // The key-frames array contains objects with the properties of the\n+â”Š   â”Š  5â”Š    // sprite at the current time-point, e.g. width of 100 and height of 200\n+â”Š   â”Š  6â”Š    this.keyframes = keyframes;\n+â”Š   â”Š  7â”Š    this.age = 0;\n+â”Š   â”Š  8â”Š    this.frame = 0;\n+â”Š   â”Š  9â”Š    // This flag determines what's gonna happen to the animation once\n+â”Š   â”Š 10â”Š    // it's finished playing\n+â”Š   â”Š 11â”Š    this.repetitionMode = \"none\";\n+â”Š   â”Š 12â”Š    this.lastKeyframe = _.last(keyframes);\n+â”Š   â”Š 13â”Š    this.lastFrame = this.lastKeyframe.frame;\n+â”Š   â”Š 14â”Š\n+â”Š   â”Š 15â”Š    // These are the properties which we can animate\n+â”Š   â”Š 16â”Š    this.animables = [\n+â”Š   â”Š 17â”Š      \"x\", \"y\", \"width\", \"height\", \"opacity\"\n+â”Š   â”Š 18â”Š    ];\n+â”Š   â”Š 19â”Š\n+â”Š   â”Š 20â”Š    // Set a map whose keys represent animatable properties and values represent an array\n+â”Š   â”Š 21â”Š    // with relevant key-frames to its belonging property\n+â”Š   â”Š 22â”Š    this.trimmedKeyframes = this.animables.reduce((trimmedKeyframes, key) => {\n+â”Š   â”Š 23â”Š      trimmedKeyframes[key] = keyframes.filter(keyframe => keyframe[key] != null);\n+â”Š   â”Š 24â”Š      return trimmedKeyframes;\n+â”Š   â”Š 25â”Š    }, {});\n+â”Š   â”Š 26â”Š\n+â”Š   â”Š 27â”Š    // Set initial properties on sprite based on initial key-frame\n+â”Š   â”Š 28â”Š    _.each(keyframes[0], (value, key) => {\n+â”Š   â”Š 29â”Š      if (this.animables.includes(key)) sprite[key] = value;\n+â”Š   â”Š 30â”Š    });\n+â”Š   â”Š 31â”Š  }\n+â”Š   â”Š 32â”Š\n+â”Š   â”Š 33â”Š  draw(context, offsetX, offsetY) {\n+â”Š   â”Š 34â”Š    this.sprite.draw(context, offsetX, offsetY);\n+â”Š   â”Š 35â”Š  }\n+â”Š   â”Š 36â”Š\n+â”Š   â”Š 37â”Š  update(span) {\n+â”Š   â”Š 38â”Š    if (!this.playing) return;\n+â”Š   â”Š 39â”Š\n+â”Š   â”Š 40â”Š    this.age += span;\n+â”Š   â”Š 41â”Š\n+â”Š   â”Š 42â”Š    switch (this.repetitionMode) {\n+â”Š   â”Š 43â”Š      // After one cycle animation would stop\n+â”Š   â”Š 44â”Š      case \"none\":\n+â”Š   â”Š 45â”Š        this.frame += span;\n+â”Š   â”Š 46â”Š\n+â”Š   â”Š 47â”Š        if (this.frame > this.lastFrame) {\n+â”Š   â”Š 48â”Š          this.frame = this.lastFrame;\n+â”Š   â”Š 49â”Š          this.playing = false;\n+â”Š   â”Š 50â”Š        }\n+â”Š   â”Š 51â”Š\n+â”Š   â”Š 52â”Š        break;\n+â”Š   â”Š 53â”Š\n+â”Š   â”Š 54â”Š      // Once finished, replay from the beginning\n+â”Š   â”Š 55â”Š      case \"cyclic\":\n+â”Š   â”Š 56â”Š        this.frame = this.age % this.lastFrame;\n+â”Š   â”Š 57â”Š        break;\n+â”Š   â”Š 58â”Š\n+â”Š   â”Š 59â”Š      // Once finished, play backwards, and so on\n+â”Š   â”Š 60â”Š      case \"full\":\n+â”Š   â”Š 61â”Š        this.frame = this.age % this.lastFrame;\n+â”Š   â”Š 62â”Š        let animationComplete = (this.age / this.lastFrame) % 2 >= 1;\n+â”Š   â”Š 63â”Š        if (animationComplete) this.frame = this.lastFrame - this.frame;\n+â”Š   â”Š 64â”Š        break;\n+â”Š   â”Š 65â”Š    }\n+â”Š   â”Š 66â”Š\n+â”Š   â”Š 67â”Š    // Update sprite properties based on given key-frame's easing mode\n+â”Š   â”Š 68â”Š    this.animables.forEach(key => {\n+â”Š   â”Š 69â”Š      let motion = this.getKeyframeMotion(key);\n+â”Š   â”Š 70â”Š\n+â”Š   â”Š 71â”Š      if (motion)\n+â”Š   â”Š 72â”Š        this.sprite[key] = this.calculateRelativeValue(motion, key);\n+â”Š   â”Š 73â”Š    });\n+â”Š   â”Š 74â”Š  }\n+â”Š   â”Š 75â”Š\n+â”Š   â”Š 76â”Š  play() {\n+â”Š   â”Š 77â”Š    this.playing = true;\n+â”Š   â”Š 78â”Š  }\n+â”Š   â”Š 79â”Š\n+â”Š   â”Š 80â”Š  pause() {\n+â”Š   â”Š 81â”Š    this.playing = false;\n+â”Š   â”Š 82â”Š  }\n+â”Š   â”Š 83â”Š\n+â”Š   â”Š 84â”Š  // Gets motion for current refresh\n+â”Š   â”Š 85â”Š  getKeyframeMotion(key) {\n+â”Š   â”Š 86â”Š    let keyframes = this.trimmedKeyframes[key];\n+â”Š   â”Š 87â”Š\n+â”Š   â”Š 88â”Š    // If no key-frames defined, motion is idle\n+â”Š   â”Š 89â”Š    if (keyframes == null) return;\n+â”Š   â”Š 90â”Š    // If there is only one key frame, motion is idle\n+â”Š   â”Š 91â”Š    if (keyframes.length < 2) return;\n+â”Š   â”Š 92â”Š    // If last frame reached, motion is idle\n+â”Š   â”Š 93â”Š    if (this.frame > _.last(keyframes).frame) return;\n+â”Š   â”Š 94â”Š\n+â”Š   â”Š 95â”Š    let start = this.findStartKeyframe(keyframes);\n+â”Š   â”Š 96â”Š    let end = this.findEndKeyframe(keyframes);\n+â”Š   â”Š 97â”Š    let ratio = this.getKeyframesRatio(start, end);\n+â”Š   â”Š 98â”Š\n+â”Š   â”Š 99â”Š    return { start, end, ratio };\n+â”Š   â”Š100â”Š  }\n+â”Š   â”Š101â”Š\n+â”Š   â”Š102â”Š  // Gets the movement ratio\n+â”Š   â”Š103â”Š  getKeyframesRatio(start, end) {\n+â”Š   â”Š104â”Š    return (this.frame - start.frame) / (end.frame - start.frame);\n+â”Š   â”Š105â”Š  }\n+â”Š   â”Š106â”Š\n+â”Š   â”Š107â”Š  // Get property end value based on current frame\n+â”Š   â”Š108â”Š  findEndKeyframe(keyframes) {\n+â”Š   â”Š109â”Š    return _.find(keyframes, keyframe =>\n+â”Š   â”Š110â”Š      keyframe.frame >= (this.frame || 1)\n+â”Š   â”Š111â”Š    );\n+â”Š   â”Š112â”Š  }\n+â”Š   â”Š113â”Š\n+â”Š   â”Š114â”Š  // Get property start value based on current frame\n+â”Š   â”Š115â”Š  findStartKeyframe(keyframes) {\n+â”Š   â”Š116â”Š    let resultIndex;\n+â”Š   â”Š117â”Š\n+â”Š   â”Š118â”Š    keyframes.some((keyframe, currIndex) => {\n+â”Š   â”Š119â”Š      if (keyframe.frame >= (this.frame || 1)) {\n+â”Š   â”Š120â”Š        resultIndex = currIndex;\n+â”Š   â”Š121â”Š        return true;\n+â”Š   â”Š122â”Š      }\n+â”Š   â”Š123â”Š    });\n+â”Š   â”Š124â”Š\n+â”Š   â”Š125â”Š    return keyframes[resultIndex - 1];\n+â”Š   â”Š126â”Š  }\n+â”Š   â”Š127â”Š\n+â”Š   â”Š128â”Š  // Get a recalculated property value relative to provided easing mode\n+â”Š   â”Š129â”Š  calculateRelativeValue(motion, key) {\n+â”Š   â”Š130â”Š    let a = motion.start[key];\n+â”Š   â”Š131â”Š    let b = motion.end[key];\n+â”Š   â”Š132â”Š    let r = motion.ratio;\n+â”Š   â”Š133â”Š    let easing = r > 0 ? motion.start.easing : motion.end.easing;\n+â”Š   â”Š134â”Š\n+â”Š   â”Š135â”Š    switch (easing) {\n+â”Š   â”Š136â”Š      case \"in\": r = Math.sin((r * Math.PI) / 2); break;\n+â”Š   â”Š137â”Š      case \"out\": r = Math.cos((r * Math.PI) / 2); break;\n+â”Š   â”Š138â”Š    }\n+â”Š   â”Š139â”Š\n+â”Š   â”Š140â”Š    return ((b - a) * r) + a;\n+â”Š   â”Š141â”Š  }\n+â”Š   â”Š142â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -10,6 +10,7 @@\n â”Š10â”Š10â”Š    <!-- Scripts -->\n â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n â”Š12â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/sprite.js\"></script>\n+â”Š  â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/animations/keyframe.js\"></script>\n â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/key_states.js\"></script>\n â”Š14â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/layer.js\"></script>\n â”Š15â”Š16â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/screen.js\"></script>\n```\n\n[}]: #\n\nWhen initializing a new instance of the key-frame animation, we should invoke it with the desired sprite, and an array of key-frames. What exactly does a single key-frame represents? The properties of the sprite at that specific time point. In addition, a key-frame can be set with an [easing mode](https://css-tricks.com/ease-out-in-ease-in-out/) of `in` and `out`. By default, the animation would be linear.\n\nBased on the `repitationMode` property, three things can happen to the animation once finished:\n\n- `none` - The animation will play once, and then stop. It will appear as a static sprite.\n- `cyclic` - The animation will repeat itself from the beginning, over and over again until stopped manually.\n- `full` - The animation will play itself backwards, and then forwards, backwards, forwards, and so on.\n\nThanks to the key-frame animation engine, we can apply it to the splash screen to show a beautifully animated logo rather than showing a static image. So in addition to the logo sprite, we will initialize a key-frame animation as well:\n\n[{]: <helper> (diffStep 3.9)\n\n#### [Step 3.9: Apply key-frame animation to splash screen](https://github.com/DAB0mB/radial-snake/commit/8ca47e5)\n\n##### Changed resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;splash&#x2F;index.js\n```diff\n@@ -1,9 +1,34 @@\n â”Š 1â”Š 1â”ŠGame.Screens.Splash = class Splash extends Engine.Screen {\n â”Š 2â”Š 2â”Š  initialize() {\n â”Š 3â”Š 3â”Š    // Create splash sprite and set its properties\n-â”Š 4â”Š  â”Š    this.splashSprite = new Engine.Sprite(this.assets.splashTexture);\n-â”Š 5â”Š  â”Š    this.splashSprite.align = \"center\";\n-â”Š 6â”Š  â”Š    this.splashSprite.x = this.width / 2;\n+â”Š  â”Š 4â”Š    let splashSprite = new Engine.Sprite(this.assets.splashTexture);\n+â”Š  â”Š 5â”Š    splashSprite.align = \"center\";\n+â”Š  â”Š 6â”Š    splashSprite.x = this.width / 2;\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Š    // Create splash sprite animation\n+â”Š  â”Š 9â”Š    this.splashAnim = new Engine.Animations.Keyframe(splashSprite, [\n+â”Š  â”Š10â”Š      {\n+â”Š  â”Š11â”Š        y: (this.height / 2) - 30,\n+â”Š  â”Š12â”Š        width: splashSprite.width / 4,\n+â”Š  â”Š13â”Š        height: splashSprite.height / 4,\n+â”Š  â”Š14â”Š        opacity: 0,\n+â”Š  â”Š15â”Š        easing: \"in\",\n+â”Š  â”Š16â”Š        frame: 0\n+â”Š  â”Š17â”Š      },\n+â”Š  â”Š18â”Š      {\n+â”Š  â”Š19â”Š        y: this.height / 2,\n+â”Š  â”Š20â”Š        width: (splashSprite.width / 3) + (splashSprite.width * 0.05),\n+â”Š  â”Š21â”Š        height: (splashSprite.height / 3) + (splashSprite.height * 0.05),\n+â”Š  â”Š22â”Š        opacity: 1,\n+â”Š  â”Š23â”Š        frame: 3000\n+â”Š  â”Š24â”Š      },\n+â”Š  â”Š25â”Š      {\n+â”Š  â”Š26â”Š        frame: 3500\n+â”Š  â”Š27â”Š      }\n+â”Š  â”Š28â”Š    ]);\n+â”Š  â”Š29â”Š\n+â”Š  â”Š30â”Š    // Start playing animation\n+â”Š  â”Š31â”Š    this.splashAnim.play();\n â”Š 7â”Š32â”Š  }\n â”Š 8â”Š33â”Š\n â”Š 9â”Š34â”Š  load(assetsLoader) {\n```\n```diff\n@@ -14,6 +39,10 @@\n â”Š14â”Š39â”Š  }\n â”Š15â”Š40â”Š\n â”Š16â”Š41â”Š  draw(context) {\n-â”Š17â”Š  â”Š    this.splashSprite.draw(context);\n+â”Š  â”Š42â”Š    this.splashAnim.draw(context);\n+â”Š  â”Š43â”Š  }\n+â”Š  â”Š44â”Š\n+â”Š  â”Š45â”Š  update(span) {\n+â”Š  â”Š46â”Š    this.splashAnim.update(span);\n â”Š18â”Š47â”Š  }\n â”Š19â”Š48â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nThe following key-frames illustrate the nodes of the animation we've just created:\n\n    width: 0\n    height: 0\n    opacity: 0\n\n![logo-empty](https://cloud.githubusercontent.com/assets/7648874/21583394/ee7a1dec-d065-11e6-80ce-fdd37c4b5dbb.png)\n\n    width: 225\n    height: 175\n    opacity: 1\n\n![logo-half](https://cloud.githubusercontent.com/assets/7648874/21583396/ee9bdf68-d065-11e6-95fb-4cf5ed58a9de.png)\n\n    width: 342\n    height: 266\n    opacity: 1\n\n![logo-full](https://cloud.githubusercontent.com/assets/7648874/21583395/ee7b3754-d065-11e6-9646-476d196a6412.png)"
          },
          {
            "manualTitle": "Step 4: Creating a main menu screen using a font engine",
            "stepRevision": "f88428bffcdf2bcf269b9cc15837cc40e0ed9caf",
            "manualView": "![snake-demo-menu-small](https://cloud.githubusercontent.com/assets/7648874/21074099/e72a81bc-bed6-11e6-98cb-329dc12a4b06.gif)\n\nIn this step we will be creating the main menu screen as shown above. The main menu screen is a simple screen which will show the logo of the game and an instruction text saying `Press a key to start`. We will be using a simple texture to show the game-logo and we will use the key-frame animation engine to show a flickering animation of the instruction text. The instruction text is the main part of this step, since it is made out of a font file (`.ttf`) and the text is auto-generated, a general solution which can serve us in many situations. We will start by implementing the main menu using static assets, which means that we will use a texture to show the instructions text, and later on we will implement the generic solution I've just mentioned. First, we will download the necessary assets:\n\n    resources/assets/textures$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/assets/textures/instructions.png\n    resources/assets/textures$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/assets/textures/logo.png\n\nAnd then we will implement the initial main menu screen:\n\n[{]: <helper> (diffStep 4.2)\n\n#### [Step 4.2: Create initial main menu screen](https://github.com/DAB0mB/radial-snake/commit/ed79de7)\n\n##### Added resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;menu&#x2F;index.js\n```diff\n@@ -0,0 +1,44 @@\n+â”Š  â”Š 1â”ŠGame.Screens.Menu = class Menu extends Engine.Screen {\n+â”Š  â”Š 2â”Š  initialize() {\n+â”Š  â”Š 3â”Š    // Initialize snake logo sprite\n+â”Š  â”Š 4â”Š    this.logoSprite = new Engine.Sprite(this.assets.logoTexture);\n+â”Š  â”Š 5â”Š    this.logoSprite.setPercentage(\"width\", this.width, 30, \"height\");\n+â”Š  â”Š 6â”Š\n+â”Š  â”Š 7â”Š    // Initialize instructions sprite\n+â”Š  â”Š 8â”Š    let instructionsSprite = new Engine.Sprite(this.assets.instructionsTexture);\n+â”Š  â”Š 9â”Š    instructionsSprite.align = \"center\";\n+â”Š  â”Š10â”Š    instructionsSprite.setPercentage(\"width\", this.width, 35, \"height\");\n+â”Š  â”Š11â”Š    instructionsSprite.x = this.width / 2;\n+â”Š  â”Š12â”Š    instructionsSprite.y = this.height / 2;\n+â”Š  â”Š13â”Š\n+â”Š  â”Š14â”Š    // Create flickering animation for instructions sprite\n+â”Š  â”Š15â”Š    this.instructionsAnim = new Engine.Animations.Keyframe(instructionsSprite, [\n+â”Š  â”Š16â”Š      {\n+â”Š  â”Š17â”Š        opacity: 1,\n+â”Š  â”Š18â”Š        frame: 0\n+â”Š  â”Š19â”Š      },\n+â”Š  â”Š20â”Š      {\n+â”Š  â”Š21â”Š        opacity: 0,\n+â”Š  â”Š22â”Š        frame: 2000\n+â”Š  â”Š23â”Š      }\n+â”Š  â”Š24â”Š    ]);\n+â”Š  â”Š25â”Š\n+â”Š  â”Š26â”Š    // Play it repeatedly, back and forth\n+â”Š  â”Š27â”Š    this.instructionsAnim.repetitionMode = \"full\";\n+â”Š  â”Š28â”Š    this.instructionsAnim.play();\n+â”Š  â”Š29â”Š  }\n+â”Š  â”Š30â”Š\n+â”Š  â”Š31â”Š  unload() {\n+â”Š  â”Š32â”Š    // Dispose the following assets to prevent memory leaks\n+â”Š  â”Š33â”Š    return [\"logoTexture\", \"instructionsTexture\"];\n+â”Š  â”Š34â”Š  }\n+â”Š  â”Š35â”Š\n+â”Š  â”Š36â”Š  draw(context) {\n+â”Š  â”Š37â”Š    this.logoSprite.draw(context);\n+â”Š  â”Š38â”Š    this.instructionsAnim.draw(context);\n+â”Š  â”Š39â”Š  }\n+â”Š  â”Š40â”Š\n+â”Š  â”Š41â”Š  update(span) {\n+â”Š  â”Š42â”Š    this.instructionsAnim.update(span);\n+â”Š  â”Š43â”Š  }\n+â”Š  â”Š44â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -16,6 +16,7 @@\n â”Š16â”Š16â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/screen.js\"></script>\n â”Š17â”Š17â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/assets_loader.js\"></script>\n â”Š18â”Š18â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n+â”Š  â”Š19â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/menu/index.js\"></script>\n â”Š19â”Š20â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/splash/index.js\"></script>\n â”Š20â”Š21â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n```\n\n[}]: #\n\nThis screen is dependent on several assets which we will load during \"splash screen time\", to save some loading time and for a smooth experience. The main menu screen will be shown automatically once the splash animation has been finished:\n\n[{]: <helper> (diffStep 4.3)\n\n#### [Step 4.3: Queue main menu screen](https://github.com/DAB0mB/radial-snake/commit/cd83a30)\n\n##### Changed resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;splash&#x2F;index.js\n```diff\n@@ -32,10 +32,21 @@\n â”Š32â”Š32â”Š  }\n â”Š33â”Š33â”Š\n â”Š34â”Š34â”Š  load(assetsLoader) {\n+â”Š  â”Š35â”Š    // Load assets\n+â”Š  â”Š36â”Š    let instructionsTexture = assetsLoader.texture(\"/textures/instrucitons\");\n+â”Š  â”Š37â”Š    let logoTexture = assetsLoader.texture(\"/textures/logo\");\n+â”Š  â”Š38â”Š    let splashTexture = assetsLoader.texture(\"/textures/splash\");\n+â”Š  â”Š39â”Š\n+â”Š  â”Š40â”Š    // These are global assets which will be shared among all screens until manually\n+â”Š  â”Š41â”Š    // disposed. We use the time gap created by the splash animation to load necessary\n+â”Š  â”Š42â”Š    // assets without wasting any time\n+â”Š  â”Š43â”Š    this.game.extendAssets({\n+â”Š  â”Š44â”Š      instructionsTexture,\n+â”Š  â”Š45â”Š      logoTexture\n+â”Š  â”Š46â”Š    });\n+â”Š  â”Š47â”Š\n â”Š35â”Š48â”Š    // These are local assets which will be disposed along with the screen\n-â”Š36â”Š  â”Š    return {\n-â”Š37â”Š  â”Š      splashTexture: assetsLoader.texture(\"/textures/splash\")\n-â”Š38â”Š  â”Š    };\n+â”Š  â”Š49â”Š    return { splashTexture };\n â”Š39â”Š50â”Š  }\n â”Š40â”Š51â”Š\n â”Š41â”Š52â”Š  draw(context) {\n```\n```diff\n@@ -43,6 +54,12 @@\n â”Š43â”Š54â”Š  }\n â”Š44â”Š55â”Š\n â”Š45â”Š56â”Š  update(span) {\n-â”Š46â”Š  â”Š    this.splashAnim.update(span);\n+â”Š  â”Š57â”Š    if (this.splashAnim.playing) {\n+â”Š  â”Š58â”Š      this.splashAnim.update(span);\n+â”Š  â”Š59â”Š    }\n+â”Š  â”Š60â”Š    // Once animation has stopped play switch to main menu\n+â”Š  â”Š61â”Š    else {\n+â”Š  â”Š62â”Š      this.game.changeScreen(Game.Screens.Menu);\n+â”Š  â”Š63â”Š    }\n â”Š47â”Š64â”Š  }\n â”Š48â”Š65â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nBy now if you launch the application you should see the main menu screen as described in the beginning. But event though it works, we're not yet finished. We still need to convert the instruction texture into an auto-generated font texture. Obviously, this requires us to download the desired `ttf` file:\n\n    resources/assets/fonts$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/assets/fonts/minecraftia.ttf\n\n> Any font file can be used here, but to save time and effort I already provided you with one\n\n`ttf` is the most common format, but since we're using JavaScript, it would make sense to convert it into a `json` file, and that's exactly what we're going to do. There's a very convenient software called [font-builder](https://github.com/andryblack/fontbuilder), and it can cut fonts, store them in `png` files, along with some user-specified meta-data stored in an `xml` file.\n\n![font-builder](https://camo.githubusercontent.com/b2c95cda825c783f5399d9197599848c33cdfcc8/687474703a2f2f7777772e67616d656465762e72752f66696c65732f696d616765732f73637265656e312e6a706567)\n\nGo over to this website: https://github.com/andryblack/fontbuilder.\nFetch a copy of the `font-builder` repo, and try to convert the `minecraftia.ttf` file into a `png` file. If you want to skip this step, although I wouldn't recommend it, you can download the following files which I already generated myself:\n\n    resources/assets/fonts$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/assets/fonts/minecraftia.png\n    resources/assets/fonts$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/assets/fonts/minecraftia.xml\n\nAs promised, we will be working with a `json` file, not a `ttf` file and not an `xml` file. For this task we will be implementing a font-parser module, which will simply take all the meta-data in the `xml` file and put it into a nice `json` schema:\n\n[{]: <helper> (diffStep 4.6)\n\n#### [Step 4.6: Create font parser so we can convert &#x27;xml&#x27; font format to &#x27;json&#x27;](https://github.com/DAB0mB/radial-snake/commit/66044e9)\n\n##### Added helpers&#x2F;font_parser.js\n```diff\n@@ -0,0 +1,102 @@\n+â”Š   â”Š  1â”Šconst _ = require(\"underscore\");\n+â”Š   â”Š  2â”Šconst Async = require(\"async\");\n+â”Š   â”Š  3â”Šconst Fs = require(\"fs\");\n+â”Š   â”Š  4â”Šconst Path = require(\"path\");\n+â”Š   â”Š  5â”Šconst { DOMParser } = require(\"xmldom\");\n+â”Š   â”Š  6â”Š\n+â”Š   â”Š  7â”Šif (module === require.main) {\n+â”Š   â”Š  8â”Š  let fonstDir = Path.resolve(__dirname, \"../resources/assets/fonts\");\n+â”Š   â”Š  9â”Š  xmlsToJsons(fonstDir, err => { if (err) throw err });\n+â”Š   â”Š 10â”Š}\n+â”Š   â”Š 11â”Š\n+â”Š   â”Š 12â”Š// Gets a dir path containing font xmls and converts them all to jsons\n+â”Š   â”Š 13â”Šfunction xmlsToJsons(path, callback = _.noop) {\n+â”Š   â”Š 14â”Š  Fs.readdir(path, (err, files) => {\n+â”Š   â”Š 15â”Š    if (err) return callback(err);\n+â”Š   â”Š 16â”Š\n+â”Š   â”Š 17â”Š    // Remove all extensions\n+â”Š   â”Š 18â”Š    fileNames = _.uniq(files.map(file => file.split(\".\")[0]));\n+â”Š   â”Š 19â”Š\n+â”Š   â”Š 20â”Š    // Convert each xml individually\n+â”Š   â”Š 21â”Š    Async.each(fileNames, (fileName, next) => {\n+â”Š   â”Š 22â”Š      xmlToJson(`${path}/${fileName}`, next);\n+â”Š   â”Š 23â”Š    },\n+â”Š   â”Š 24â”Š    (err) => {\n+â”Š   â”Š 25â”Š      if (!err) console.log(\n+â”Š   â”Š 26â”Š        'All fonts have been successfully parsed!'\n+â”Š   â”Š 27â”Š      );\n+â”Š   â”Š 28â”Š\n+â”Š   â”Š 29â”Š      callback(err);\n+â”Š   â”Š 30â”Š    });\n+â”Š   â”Š 31â”Š  });\n+â”Š   â”Š 32â”Š}\n+â”Š   â”Š 33â”Š\n+â”Š   â”Š 34â”Š// Gets a font xml and converts it to json\n+â”Š   â”Š 35â”Šfunction xmlToJson(path, callback = _.noop) {\n+â”Š   â”Š 36â”Š  Async.waterfall([\n+â”Š   â”Š 37â”Š    (next) => {\n+â”Š   â”Š 38â”Š      Fs.readFile(`${path}.xml`, function(err, xmlBuffer) {\n+â”Š   â”Š 39â”Š        if (err) return next(err);\n+â”Š   â”Š 40â”Š\n+â”Š   â”Š 41â”Š        let json = {\n+â”Š   â”Š 42â”Š          chars: {}\n+â”Š   â”Š 43â”Š        };\n+â”Š   â”Š 44â”Š\n+â”Š   â”Š 45â”Š        let xml = xmlBuffer.toString();\n+â”Š   â”Š 46â”Š        let doc = new DOMParser().parseFromString(xml);\n+â”Š   â”Š 47â”Š        let fontDoc = doc.getElementsByTagName(\"Font\")[0];\n+â”Š   â”Š 48â”Š        let charsDoc = fontDoc.getElementsByTagName(\"Char\");\n+â”Š   â”Š 49â”Š\n+â”Š   â”Š 50â”Š        // Compose meta-data about font like size and family\n+â”Š   â”Š 51â”Š        _.each(fontDoc.attributes, (attr) => {\n+â”Š   â”Š 52â”Š          json[attr.name] = parseInt(attr.value) || attr.value;\n+â”Š   â”Š 53â”Š        });\n+â”Š   â”Š 54â”Š\n+â”Š   â”Š 55â”Š        // Compose data about each character in font\n+â”Š   â”Š 56â”Š        _.each(charsDoc, (charDoc) => {\n+â”Š   â”Š 57â”Š          let charCode = charDoc.getAttribute(\"code\");\n+â”Š   â”Š 58â”Š\n+â”Š   â”Š 59â”Š          let char = json.chars[charCode] = {\n+â”Š   â”Š 60â”Š            rect: rect = {},\n+â”Š   â”Š 61â”Š            offset: offset = {},\n+â”Š   â”Š 62â”Š            width: parseInt(charDoc.getAttribute(\"width\"))\n+â”Š   â”Š 63â”Š          };\n+â”Š   â”Š 64â”Š\n+â”Š   â”Š 65â”Š          [\n+â”Š   â”Š 66â”Š            rect.x,\n+â”Š   â”Š 67â”Š            rect.y,\n+â”Š   â”Š 68â”Š            rect.width,\n+â”Š   â”Š 69â”Š            rect.height\n+â”Š   â”Š 70â”Š          ] = extractIntegers(charDoc.getAttribute(\"rect\"));\n+â”Š   â”Š 71â”Š\n+â”Š   â”Š 72â”Š          [offset.x, offset.y] = extractIntegers(charDoc.getAttribute(\"offset\"));\n+â”Š   â”Š 73â”Š        });\n+â”Š   â”Š 74â”Š\n+â”Š   â”Š 75â”Š        next(null, JSON.stringify(json, null, 2));\n+â”Š   â”Š 76â”Š      });\n+â”Š   â”Š 77â”Š    },\n+â”Š   â”Š 78â”Š    (json, next) => {\n+â”Š   â”Š 79â”Š      // Once finished, write json into file\n+â”Š   â”Š 80â”Š      Fs.writeFile(path + \".json\", json, (err) => {\n+â”Š   â”Š 81â”Š        next(err);\n+â”Š   â”Š 82â”Š      });\n+â”Š   â”Š 83â”Š    }\n+â”Š   â”Š 84â”Š  ], (err) => {\n+â”Š   â”Š 85â”Š    if (!err) console.log(\n+â”Š   â”Š 86â”Š      `Font ${path} has been successfully parsed...`\n+â”Š   â”Š 87â”Š    );\n+â”Š   â”Š 88â”Š\n+â”Š   â”Š 89â”Š    callback(err);\n+â”Š   â”Š 90â”Š  });\n+â”Š   â”Š 91â”Š};\n+â”Š   â”Š 92â”Š\n+â”Š   â”Š 93â”Š// Converts an string of numbers to array of numbers\n+â”Š   â”Š 94â”Š// e.g. extractIntegers(\"1 2 3\") -> [1, 2, 3]\n+â”Š   â”Š 95â”Šfunction extractIntegers(srcstr) {\n+â”Š   â”Š 96â”Š  return srcstr.split(\" \").map((substr) => parseInt(substr));\n+â”Š   â”Š 97â”Š}\n+â”Š   â”Š 98â”Š\n+â”Š   â”Š 99â”Šmodule.exports = {\n+â”Š   â”Š100â”Š  xmlToJson,\n+â”Š   â”Š101â”Š  xmlsToJsons\n+â”Š   â”Š102â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nThis script will take everything that's in the `fonts` dir and parser it as mentioned above. Before we can user this script we will need to install some NPM dependencies like so:\n\n    $ npm install --save underscore\n    $ npm install --save xmldom\n\nAnd instead of running the parser manually over and over again whenever we wanna use it, we will use the following `NPM` script instead:\n\n[{]: <helper> (diffStep 4.8)\n\n#### [Step 4.8: Add font parsing npm scripts](https://github.com/DAB0mB/radial-snake/commit/7a1cf81)\n\n##### Changed package.json\n```diff\n@@ -7,7 +7,8 @@\n â”Š 7â”Š 7â”Š  },\n â”Š 8â”Š 8â”Š  \"private\": true,\n â”Š 9â”Š 9â”Š  \"scripts\": {\n-â”Š10â”Š  â”Š    \"serve\": \"nodemon server.js\"\n+â”Š  â”Š10â”Š    \"serve\": \"npm run parse:fonts && nodemon server.js\",\n+â”Š  â”Š11â”Š    \"build:fonts\": \"node helpers/font_parser.js\"\n â”Š11â”Š12â”Š  },\n â”Š12â”Š13â”Š  \"dependencies\": {\n â”Š13â”Š14â”Š    \"async\": \"^2.1.4\",\n```\n\n[}]: #\n\nWe don't want the generated fonts to be included by `git` since they are going to automatically regenerate themselves, therefore we gonna add the following ignore rule:\n\n[{]: <helper> (diffStep 4.9)\n\n#### [Step 4.9: Add rule to to git-ignore parsed fonts](https://github.com/DAB0mB/radial-snake/commit/bbf7647)\n\n##### Changed .gitignore\n```diff\n@@ -1,2 +1,3 @@\n â”Š1â”Š1â”Šnode_modules\n-â”Š2â”Š â”Šnpm-debug.logðŸš«â†µ\n+â”Š â”Š2â”Šnpm-debug.log\n+â”Š â”Š3â”Šresources/assets/fonts/*.jsonðŸš«â†µ\n```\n\n[}]: #\n\nNow we will build our `minecraftia` font by simply running:\n\n    $ npm run build:fonts\n\nAnd voila! We have a freshly created `json` file which we can work with. You can also get it from here:\n\n    resources/assets/fonts$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/assets/fonts/minecraftia.json\n\nNow that we have our assets finally ready we can go ahead and focus on extending the engine which powers up our game. We need some sort of a generic font-engine which will know how to load a font file and create a text-sprite out of it. First we will implement a class called `Restorable`, which shares the same restore API as the CanvasRenderingContext2D and will give us the ability to save and restore the font's state (More information can be found [here](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/restore)):\n\n[{]: <helper> (diffStep 4.11)\n\n#### [Step 4.11: Add &#x27;Restorable&#x27; class](https://github.com/DAB0mB/radial-snake/commit/8239c01)\n\n##### Added resources&#x2F;scripts&#x2F;engine&#x2F;restorable.js\n```diff\n@@ -0,0 +1,21 @@\n+â”Š  â”Š 1â”ŠEngine.Restorable = class Restorable {\n+â”Š  â”Š 2â”Š  // Acts the same as canvas's save() and restore() API.\n+â”Š  â”Š 3â”Š  // 'restorable' props are defined in the constructor\n+â”Š  â”Š 4â”Š  constructor(...restorableProps) {\n+â”Š  â”Š 5â”Š    this._restorableProps = restorableProps;\n+â”Š  â”Š 6â”Š    this._restorableStates = [];\n+â”Š  â”Š 7â”Š  }\n+â”Š  â”Š 8â”Š\n+â”Š  â”Š 9â”Š  // Save current state in the stack\n+â”Š  â”Š10â”Š  save() {\n+â”Š  â”Š11â”Š    this._restorableStates.push(this._restorableProps.reduce((state, prop) => {\n+â”Š  â”Š12â”Š      state[prop] = this[prop];\n+â”Š  â”Š13â”Š      return state;\n+â”Š  â”Š14â”Š    }, {}));\n+â”Š  â”Š15â”Š  }\n+â”Š  â”Š16â”Š\n+â”Š  â”Š17â”Š  // Pop most recent state and apply it\n+â”Š  â”Š18â”Š  restore() {\n+â”Š  â”Š19â”Š    _.extend(this, this._restorableStates.pop());\n+â”Š  â”Š20â”Š  }\n+â”Š  â”Š21â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -9,6 +9,7 @@\n â”Š 9â”Š 9â”Š\n â”Š10â”Š10â”Š    <!-- Scripts -->\n â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n+â”Š  â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/restorable.js\"></script>\n â”Š12â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/sprite.js\"></script>\n â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/animations/keyframe.js\"></script>\n â”Š14â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/key_states.js\"></script>\n```\n\n[}]: #\n\nAnd now we can go ahead and implement the font class itself:\n\n[{]: <helper> (diffStep 4.12)\n\n#### [Step 4.12: Create font engine](https://github.com/DAB0mB/radial-snake/commit/7a1f2c7)\n\n##### Added resources&#x2F;scripts&#x2F;engine&#x2F;font.js\n```diff\n@@ -0,0 +1,133 @@\n+â”Š   â”Š  1â”ŠEngine.Font = class Font extends Engine.Restorable {\n+â”Š   â”Š  2â”Š  // The src property acts just line native image's src property.\n+â”Š   â”Š  3â”Š  // Once finished loading, the onload() callback will be invoked\n+â”Š   â”Š  4â”Š  get src() {\n+â”Š   â”Š  5â”Š    return this._src;\n+â”Š   â”Š  6â”Š  }\n+â”Š   â”Š  7â”Š\n+â”Š   â”Š  8â”Š  set src(src) {\n+â”Š   â”Š  9â”Š    this._src = src;\n+â”Š   â”Š 10â”Š\n+â”Š   â”Š 11â”Š    // The font is actually an image, therefore we have 2 onload callbacks.\n+â”Š   â”Š 12â”Š    // The first one is the native one which will always be run,\n+â”Š   â”Š 13â”Š    // and the second one is a user defined one\n+â”Š   â”Š 14â”Š    if (this.onload) var done = _.after(2, this.onload);\n+â”Š   â”Š 15â”Š\n+â”Š   â”Š 16â”Š    this.atlas = new Image();\n+â”Š   â”Š 17â”Š    this.atlas.onload = done;\n+â”Š   â”Š 18â”Š    this.atlas.src = `${src}.png`;\n+â”Š   â”Š 19â”Š\n+â”Š   â”Š 20â”Š    // Get json based on the given src property\n+â”Š   â”Š 21â”Š    $.getJSON(`${src}.json`, data => {\n+â”Š   â”Š 22â”Š      this.data = data;\n+â”Š   â”Š 23â”Š      if (done) done();\n+â”Š   â”Š 24â”Š    });\n+â”Š   â”Š 25â”Š\n+â”Š   â”Š 26â”Š    return this._src;\n+â”Š   â”Š 27â”Š  }\n+â”Š   â”Š 28â”Š\n+â”Š   â”Š 29â”Š  constructor() {\n+â”Š   â”Š 30â”Š    // The color property is the only restorable property\n+â”Š   â”Š 31â”Š    super(\"color\");\n+â”Š   â”Š 32â”Š    this.charSpritesCache = {};\n+â”Š   â”Š 33â”Š  }\n+â”Š   â”Š 34â”Š\n+â”Š   â”Š 35â”Š  // Creates a texture out of the font with the given text\n+â”Š   â”Š 36â”Š  createTexture(text, options = {}) {\n+â”Š   â”Š 37â”Š    let { noOffsets, noSpaces } = options;\n+â”Š   â”Š 38â”Š    let canvas = document.createElement(\"canvas\");\n+â”Š   â”Š 39â”Š    let context = canvas.getContext(\"2d\");\n+â”Š   â”Š 40â”Š    let height = canvas.height = this.data.height;\n+â”Š   â”Š 41â”Š\n+â”Š   â”Š 42â”Š    // Calculates the width of the canvas based on the text and the font\n+â”Š   â”Š 43â”Š    let width = canvas.width = _.reduce(text, (width, c) => {\n+â”Š   â”Š 44â”Š      // No-space option means that the characters will be\n+â”Š   â”Š 45â”Š      // drawn with no any space between them\n+â”Š   â”Š 46â”Š      if (noSpaces) {\n+â”Š   â”Š 47â”Š        return width + this.getCharSprite(c).width;\n+â”Š   â”Š 48â”Š      }\n+â”Š   â”Š 49â”Š\n+â”Š   â”Š 50â”Š      return width + this.data.chars[c].width;\n+â”Š   â”Š 51â”Š    }, 0);\n+â”Š   â”Š 52â”Š\n+â”Š   â”Š 53â”Š    // A custom size can be specified for a font as well\n+â”Š   â”Š 54â”Š    if (this.size) {\n+â”Š   â”Š 55â”Š      let ratio = this.size / this.data.size;\n+â”Š   â”Š 56â”Š      canvas.height *= ratio;\n+â”Š   â”Š 57â”Š      canvas.width *= ratio;\n+â”Š   â”Š 58â”Š      context.scale(ratio, ratio);\n+â”Š   â”Š 59â”Š    }\n+â”Š   â”Š 60â”Š\n+â”Š   â”Š 61â”Š    // No we are going to draw each char on the canvas individually,\n+â”Š   â”Š 62â”Š    // naturally, there should be an offset after we draw each character.\n+â”Š   â”Š 63â”Š    // This variable will be used to calculate the offset\n+â”Š   â”Š 64â”Š    let offset = 0;\n+â”Š   â”Š 65â”Š\n+â”Š   â”Š 66â”Š    // Get for each char\n+â”Š   â”Š 67â”Š    _.map(text, (char) => {\n+â”Š   â”Š 68â”Š      return this.getCharSprite(char);\n+â”Š   â”Š 69â”Š    })\n+â”Š   â”Š 70â”Š    // Start drawing each char on the canvas\n+â”Š   â”Š 71â”Š    .forEach((charSprite, index) => {\n+â”Š   â”Š 72â”Š      let charData = this.data.chars[text.charAt(index)];\n+â”Š   â”Š 73â”Š\n+â”Š   â”Š 74â”Š      // Each char in the font xml has a native offset in addition to its rectangle.\n+â”Š   â”Š 75â”Š      // This option will disable the calculation of the native offset\n+â”Š   â”Š 76â”Š      if (noOffsets) {\n+â”Š   â”Š 77â”Š        charSprite.draw(context, offset);\n+â”Š   â”Š 78â”Š      }\n+â”Š   â”Š 79â”Š      else {\n+â”Š   â”Š 80â”Š        charSprite.draw(context, offset + charData.offset.x, charData.offset.y);\n+â”Š   â”Š 81â”Š      }\n+â”Š   â”Š 82â”Š\n+â”Š   â”Š 83â”Š      if (noSpaces) {\n+â”Š   â”Š 84â”Š        offset += charSprite.width;\n+â”Š   â”Š 85â”Š      }\n+â”Š   â”Š 86â”Š      else {\n+â”Š   â”Š 87â”Š        offset += charData.width;\n+â”Š   â”Š 88â”Š      }\n+â”Š   â”Š 89â”Š\n+â”Š   â”Š 90â”Š      // A color for the font can be specified as well\n+â”Š   â”Š 91â”Š      if (this.color) {\n+â”Š   â”Š 92â”Š        let overlayCanvas = document.createElement(\"canvas\");\n+â”Š   â”Š 93â”Š        let overlayContext = overlayCanvas.getContext(\"2d\");\n+â”Š   â”Š 94â”Š        overlayCanvas.width = width;\n+â”Š   â”Š 95â”Š        overlayCanvas.height = height;\n+â”Š   â”Š 96â”Š        overlayContext.beginPath();\n+â”Š   â”Š 97â”Š        overlayContext.rect(0, 0, width, height);\n+â”Š   â”Š 98â”Š        overlayContext.fillStyle = this.color;\n+â”Š   â”Š 99â”Š        overlayContext.fill();\n+â”Š   â”Š100â”Š\n+â”Š   â”Š101â”Š        context.save();\n+â”Š   â”Š102â”Š        context.globalCompositeOperation = \"source-in\";\n+â”Š   â”Š103â”Š        context.drawImage(overlayCanvas, 0, 0);\n+â”Š   â”Š104â”Š        context.restore();\n+â”Š   â”Š105â”Š      }\n+â”Š   â”Š106â”Š    });\n+â”Š   â”Š107â”Š\n+â”Š   â”Š108â”Š    // The canvas will be treated like an image\n+â”Š   â”Š109â”Š    return canvas;\n+â”Š   â”Š110â”Š  }\n+â”Š   â”Š111â”Š\n+â”Š   â”Š112â”Š  // Gets a sprite of the given char, using the current font\n+â”Š   â”Š113â”Š  getCharSprite(char) {\n+â”Š   â”Š114â”Š    // If char is already stored in cache, abort calculation and return it\n+â”Š   â”Š115â”Š    if (this.charSpritesCache[char]) return this.charSpritesCache[char];\n+â”Š   â”Š116â”Š\n+â”Š   â”Š117â”Š    // This data is fetched by the given json\n+â”Š   â”Š118â”Š    let { x, y, width, height } = this.data.chars[char].rect;\n+â”Š   â”Š119â”Š    // Creating a canvas which we will use to draw on,\n+â”Š   â”Š120â”Š    // but it is used exactly like an image afterwards\n+â”Š   â”Š121â”Š    let canvas = document.createElement(\"canvas\");\n+â”Š   â”Š122â”Š    let context = canvas.getContext(\"2d\");\n+â”Š   â”Š123â”Š\n+â”Š   â”Š124â”Š    // The canvas will have the same dimensions as the font\n+â”Š   â”Š125â”Š    canvas.width = width;\n+â”Š   â”Š126â”Š    canvas.height = height;\n+â”Š   â”Š127â”Š    // Draw a cropped image from the atlas, this image contains the char font\n+â”Š   â”Š128â”Š    context.drawImage(this.atlas, x, y, width, height, 0, 0, width, height);\n+â”Š   â”Š129â”Š\n+â”Š   â”Š130â”Š    // Store in cache and return it\n+â”Š   â”Š131â”Š    return this.charSpritesCache[char] = new Engine.Sprite(canvas);\n+â”Š   â”Š132â”Š  }\n+â”Š   â”Š133â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -10,6 +10,7 @@\n â”Š10â”Š10â”Š    <!-- Scripts -->\n â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n â”Š12â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/restorable.js\"></script>\n+â”Š  â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/font.js\"></script>\n â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/sprite.js\"></script>\n â”Š14â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/animations/keyframe.js\"></script>\n â”Š15â”Š16â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/key_states.js\"></script>\n```\n\n[}]: #\n\nThe font API shares a similar API as [HTMLImageElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/Image), once we set the `src` property the font will start loading itself, and the `onload` user-defined callback should be called once finished. Another neat feature would be the `createTexture` method, which takes a string as its first argument, representing the text that we would like to generate, and returns an instance of the `Sprite` class.\n\nWe will also be adding the option to load some font assets in our asset-loader:\n\n[{]: <helper> (diffStep 4.13)\n\n#### [Step 4.13: Add a font loading option to &#x27;AssetLoader&#x27;](https://github.com/DAB0mB/radial-snake/commit/a9d73cc)\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;assets_loader.js\n```diff\n@@ -10,4 +10,12 @@\n â”Š10â”Š10â”Š    image.src = `${path}.png`;\n â”Š11â”Š11â”Š    return image;\n â”Š12â”Š12â”Š  }\n+â”Š  â”Š13â”Š\n+â”Š  â”Š14â”Š  // Load font\n+â”Š  â”Š15â”Š  font(path) {\n+â”Š  â”Š16â”Š    let font = new Engine.Font();\n+â”Š  â”Š17â”Š    font.onload = this.next();\n+â”Š  â”Š18â”Š    font.src = path;\n+â”Š  â”Š19â”Š    return font;\n+â”Š  â”Š20â”Š  }\n â”Š13â”Š21â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nAnd replace the instructions texture loading with a `minecraftia` font loading in the initial splash screen:\n\n[{]: <helper> (diffStep 4.14)\n\n#### [Step 4.14: Load &#x27;minecraftia&#x27; font in splash screen](https://github.com/DAB0mB/radial-snake/commit/231a68f)\n\n##### Changed resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;splash&#x2F;index.js\n```diff\n@@ -33,7 +33,7 @@\n â”Š33â”Š33â”Š\n â”Š34â”Š34â”Š  load(assetsLoader) {\n â”Š35â”Š35â”Š    // Load assets\n-â”Š36â”Š  â”Š    let instructionsTexture = assetsLoader.texture(\"/textures/instrucitons\");\n+â”Š  â”Š36â”Š    let minecraftiaFont = assetsLoader.font(\"/fonts/minecraftia\");\n â”Š37â”Š37â”Š    let logoTexture = assetsLoader.texture(\"/textures/logo\");\n â”Š38â”Š38â”Š    let splashTexture = assetsLoader.texture(\"/textures/splash\");\n â”Š39â”Š39â”Š\n```\n```diff\n@@ -41,7 +41,7 @@\n â”Š41â”Š41â”Š    // disposed. We use the time gap created by the splash animation to load necessary\n â”Š42â”Š42â”Š    // assets without wasting any time\n â”Š43â”Š43â”Š    this.game.extendAssets({\n-â”Š44â”Š  â”Š      instructionsTexture,\n+â”Š  â”Š44â”Š      minecraftiaFont,\n â”Š45â”Š45â”Š      logoTexture\n â”Š46â”Š46â”Š    });\n```\n\n[}]: #\n\nNow it can use us in the main menu screen where we will create a text-sprite saying `Press a key to start`, just like the instruction sprite we're about to replace:\n\n[{]: <helper> (diffStep 4.15)\n\n#### [Step 4.15: Replace texture usage with font usage in main menu screen](https://github.com/DAB0mB/radial-snake/commit/a769b81)\n\n##### Changed resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;menu&#x2F;index.js\n```diff\n@@ -5,7 +5,8 @@\n â”Š 5â”Š 5â”Š    this.logoSprite.setPercentage(\"width\", this.width, 30, \"height\");\n â”Š 6â”Š 6â”Š\n â”Š 7â”Š 7â”Š    // Initialize instructions sprite\n-â”Š 8â”Š  â”Š    let instructionsSprite = new Engine.Sprite(this.assets.instructionsTexture);\n+â”Š  â”Š 8â”Š    let instructionsTexture = this.assets.minecraftiaFont.createTexture(\"Press a key to start\");\n+â”Š  â”Š 9â”Š    let instructionsSprite = new Engine.Sprite(instructionsTexture);\n â”Š 9â”Š10â”Š    instructionsSprite.align = \"center\";\n â”Š10â”Š11â”Š    instructionsSprite.setPercentage(\"width\", this.width, 35, \"height\");\n â”Š11â”Š12â”Š    instructionsSprite.x = this.width / 2;\n```\n```diff\n@@ -30,7 +31,7 @@\n â”Š30â”Š31â”Š\n â”Š31â”Š32â”Š  unload() {\n â”Š32â”Š33â”Š    // Dispose the following assets to prevent memory leaks\n-â”Š33â”Š  â”Š    return [\"logoTexture\", \"instructionsTexture\"];\n+â”Š  â”Š34â”Š    return \"logoTexture\";\n â”Š34â”Š35â”Š  }\n â”Š35â”Š36â”Š\n â”Š36â”Š37â”Š  draw(context) {\n```\n```diff\n@@ -41,4 +42,8 @@\n â”Š41â”Š42â”Š  update(span) {\n â”Š42â”Š43â”Š    this.instructionsAnim.update(span);\n â”Š43â”Š44â”Š  }\n+â”Š  â”Š45â”Š\n+â”Š  â”Š46â”Š  update(span) {\n+â”Š  â”Š47â”Š    this.instructionsAnim.update(span);\n+â”Š  â”Š48â”Š  }\n â”Š44â”Š49â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nIt shouldn't look any different from the beginning of the step where we manually drew the instruction texture, but in the next steps we will be using the font-engine a lot, and you will be thankful for what we've just did."
          },
          {
            "manualTitle": "Step 5: Creating a snake and related geometry shapes",
            "stepRevision": "ad178e03e276b088c96d6f67889db379ad201e3e",
            "manualView": "![snake-illustrate](https://cloud.githubusercontent.com/assets/7648874/21074115/46ef4466-bed7-11e6-9d5d-12fa6d43147b.gif)\n\nIn this step we will be creating all the necessary geometry shapes to form a snake; we're basically implementing the right infrastructure so in the next step we will be able to implement the game screen with ease. What exactly do I mean by \"geometry shapes\"? Well, our snake will be made out of circles, and lines. If we don't press any buttons at all, the snake should move forward at a straight line, and once we press on one of the arrow keys, the snake should move in a circular motion. Not only we want to draw the screen on the canvas, we also want to be able to detect collision with other snakes, since this is a \"Tron\" style game where we gonna fight against an opponent.\n\nKeep in mind that a computer's precision is limited due its [binary representation in memory](https://en.wikipedia.org/wiki/Memory_cell_(binary)). We need to take into consideration that there might be a significant deviation when detecting collisions and intersections between geometry shapes, especially when elapsed time is not always guaranteed to stay precise. To handle these deviation issues, we're gonna create some utility functions and place then in a new module called `Utils`:\n\n[{]: <helper> (diffStep 5.1)\n\n#### [Step 5.1: Create utilities module](https://github.com/DAB0mB/radial-snake/commit/58ae99a)\n\n##### Added resources&#x2F;scripts&#x2F;utils.js\n```diff\n@@ -0,0 +1,68 @@\n+â”Š  â”Š 1â”Š// A wrapper function for our utilities which will enable chaining\n+â”Š  â”Š 2â”Š// e.g. Utils().mod().trim().isBetween()...\n+â”Š  â”Š 3â”ŠUtils = function Utils(context) {\n+â”Š  â”Š 4â”Š  const chain = {};\n+â”Š  â”Š 5â”Š\n+â”Š  â”Š 6â”Š  Object.keys(Utils).forEach((utilName) => {\n+â”Š  â”Š 7â”Š    chain[utilName] = (...args) => {\n+â”Š  â”Š 8â”Š      const result = Utils[utilName](context, ...args);\n+â”Š  â”Š 9â”Š      return Utils(result);\n+â”Š  â”Š10â”Š    };\n+â”Š  â”Š11â”Š  });\n+â”Š  â”Š12â”Š\n+â”Š  â”Š13â”Š  // Returns the result of the chaining\n+â”Š  â”Š14â”Š  chain.value = () => context;\n+â”Š  â”Š15â”Š\n+â”Š  â”Š16â”Š  return chain;\n+â”Š  â”Š17â”Š};\n+â”Š  â”Š18â”Š\n+â”Š  â”Š19â”Š// Fixed modulo method which can calculate modulo of negative numbers properly\n+â”Š  â”Š20â”Š// e.g. (-803).mod(800) returns 797\n+â”Š  â”Š21â”ŠUtils.mod = function (context, num) {\n+â”Š  â”Š22â”Š  return ((context % num) + num) % num;\n+â”Š  â”Š23â”Š};\n+â”Š  â”Š24â”Š\n+â”Š  â”Š25â”Š// Trims number and leaves the number of decimals specified.\n+â”Š  â”Š26â”Š// The \"mode\" argument specifies which math function should be invoked\n+â”Š  â”Š27â”Š// right after the number has been trimmed.\n+â”Š  â”Š28â”Š// e.g. 12.12345.trim(3, \"ceil\") returns 12.124\n+â”Š  â”Š29â”ŠUtils.trim = function (context, decimals, mode = \"round\") {\n+â”Š  â”Š30â”Š  return Math[mode](context * Math.pow(10, decimals)) / Math.pow(10, decimals);\n+â”Š  â”Š31â”Š};\n+â”Š  â”Š32â”Š\n+â”Š  â”Š33â”Š// Tells if number is in specified range based on given precision.\n+â”Š  â”Š34â”Š// See the \"compare\" method for more information about precision\n+â”Š  â”Š35â”ŠUtils.isBetween = function (context, num1, num2, precision) {\n+â”Š  â”Š36â”Š  return Utils.compare(context, Math.min(num1, num2), \">=\", precision) &&\n+â”Š  â”Š37â”Š         Utils.compare(context, Math.max(num1, num2), \"<=\", precision);\n+â”Š  â”Š38â”Š};\n+â”Š  â”Š39â”Š\n+â”Š  â”Š40â”Š// Initiates comparison operator between context number and a given number, only here\n+â”Š  â”Š41â”Š// a precision can be specified\n+â”Š  â”Š42â”ŠUtils.compare = function (context, num, method, precision = method) {\n+â”Š  â”Š43â”Š  switch (precision) {\n+â”Š  â”Š44â”Š    // Fixed precision, \"almost equal\" with a deviation of Îµ\n+â”Š  â”Š45â”Š    case \"f\":\n+â”Š  â”Š46â”Š      switch (method) {\n+â”Š  â”Š47â”Š        case \"<\": case \"<=\": return context <= num + Number.EPSILON;\n+â”Š  â”Š48â”Š        case \">\": case \">=\": return context >= num - Number.EPSILON;\n+â”Š  â”Š49â”Š        default: return Math.abs(context - num) <= Number.EPSILON;\n+â”Š  â”Š50â”Š      }\n+â”Š  â”Š51â”Š    // Pixel precision, round comparison\n+â”Š  â”Š52â”Š    case \"px\":\n+â”Š  â”Š53â”Š      switch (method) {\n+â”Š  â”Š54â”Š        case \"<\": case \"<=\": return Math.round(context) <= Math.round(num);\n+â”Š  â”Š55â”Š        case \">\": case \">=\": return Math.round(context) >= Math.round(num);\n+â”Š  â”Š56â”Š        default: return Math.round(context) == Math.round(num);\n+â”Š  â”Š57â”Š      }\n+â”Š  â”Š58â”Š    // Exact precision\n+â”Š  â”Š59â”Š    default:\n+â”Š  â”Š60â”Š      switch (method) {\n+â”Š  â”Š61â”Š        case \"<\": return context < num;\n+â”Š  â”Š62â”Š        case \"<=\": return context <= num;\n+â”Š  â”Š63â”Š        case \">\": return context > num;\n+â”Š  â”Š64â”Š        case \">=\": return context >= num;\n+â”Š  â”Š65â”Š        default: return context === num;\n+â”Š  â”Š66â”Š      }\n+â”Š  â”Š67â”Š  }\n+â”Š  â”Š68â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -8,6 +8,7 @@\n â”Š 8â”Š 8â”Š    <script type=\"text/javascript\" src=\"/libs/underscore.js\"></script>\n â”Š 9â”Š 9â”Š\n â”Š10â”Š10â”Š    <!-- Scripts -->\n+â”Š  â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/utils.js\"></script>\n â”Š11â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n â”Š12â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/restorable.js\"></script>\n â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/font.js\"></script>\n```\n\n[}]: #\n\nNow we would like to start implementing the first class representation for a line, and for that we're requires to add a new module called `Geometry` to the `Engine` namespace:\n\n[{]: <helper> (diffStep 5.2)\n\n#### [Step 5.2: Add &#x27;Shapes&#x27; module to &#x27;Engine&#x27; namespace](https://github.com/DAB0mB/radial-snake/commit/4ed2788)\n\n##### Changed resources&#x2F;scripts&#x2F;namespaces.js\n```diff\n@@ -3,5 +3,6 @@\n â”Š3â”Š3â”Š};\n â”Š4â”Š4â”Š\n â”Š5â”Š5â”ŠEngine = {\n-â”Š6â”Š â”Š  Animations: {}\n+â”Š â”Š6â”Š  Animations: {},\n+â”Š â”Š7â”Š  Geometry: {}\n â”Š7â”Š8â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nAnd now that we have this module available to use, we can go ahead and implement our first geometry shape class - `Line`:\n\n[{]: <helper> (diffStep 5.3)\n\n#### [Step 5.3: Create &#x27;Line&#x27; class](https://github.com/DAB0mB/radial-snake/commit/fb38ab5)\n\n##### Added resources&#x2F;scripts&#x2F;engine&#x2F;geometry&#x2F;line.js\n```diff\n@@ -0,0 +1,65 @@\n+â”Š  â”Š 1â”ŠEngine.Geometry.Line = class Line {\n+â”Š  â”Š 2â”Š  // x1 - The first point's x value\n+â”Š  â”Š 3â”Š  // y1 - The first point's y value\n+â”Š  â”Š 4â”Š  // x1 - The second point's x value\n+â”Š  â”Š 5â”Š  // y2 - The second point's y value\n+â”Š  â”Š 6â”Š  constructor(x1, y1, x2, y2) {\n+â”Š  â”Š 7â”Š    this.x1 = Utils.trim(x1, 9);\n+â”Š  â”Š 8â”Š    this.y1 = Utils.trim(y1, 9);\n+â”Š  â”Š 9â”Š    this.x2 = Utils.trim(x2, 9);\n+â”Š  â”Š10â”Š    this.y2 = Utils.trim(y2, 9);\n+â”Š  â”Š11â”Š  }\n+â”Š  â”Š12â”Š\n+â”Š  â”Š13â”Š  // Draws the line on the given context\n+â”Š  â”Š14â”Š  draw(context) {\n+â”Š  â”Š15â”Š    context.moveTo(this.x1, this.y1);\n+â”Š  â”Š16â”Š    context.lineTo(this.x2, this.y2);\n+â”Š  â”Š17â”Š  }\n+â”Š  â”Š18â”Š\n+â”Š  â”Š19â”Š  // Gets the matching x value for a given y value\n+â”Š  â”Š20â”Š  getX(y) {\n+â”Š  â”Š21â”Š    let x = Utils.trim((((y - this.y1) * (this.x2 - this.x1)) / (this.y2 - this.y1)) + this.x1, 9);\n+â”Š  â”Š22â”Š    if (isNaN(x) || Utils.isBetween(x, this.x1, this.x2)) return x;\n+â”Š  â”Š23â”Š  }\n+â”Š  â”Š24â”Š\n+â”Š  â”Š25â”Š  // Gets the matching y value for a given x value\n+â”Š  â”Š26â”Š  getY(x) {\n+â”Š  â”Š27â”Š    let y = Utils.trim((((x - this.x1) * (this.y2 - this.y1)) / (this.x2 - this.x1)) + this.y1, 9);\n+â”Š  â”Š28â”Š    if (isNaN(y) || Utils.isBetween(y, this.y1, this.y2)) return y;\n+â”Š  â”Š29â”Š  }\n+â”Š  â”Š30â”Š\n+â”Š  â”Š31â”Š  // Returns if line has given point\n+â”Š  â”Š32â”Š  hasPoint(x, y) {\n+â”Š  â”Š33â”Š    if (!this.boundsHavePoint(x, y)) return false;\n+â”Š  â”Š34â”Š    let m = Utils.trim((this.y2 - this.y1) / (this.x2 - this.x1), 9);\n+â”Š  â”Š35â”Š    return (y - this.y1) / (x - this.x1) == m;\n+â”Š  â”Š36â”Š  }\n+â”Š  â”Š37â”Š\n+â”Š  â”Š38â”Š  // Returns if given point is contained by the bounds aka cage of line\n+â”Š  â”Š39â”Š  boundsHavePoint(x, y) {\n+â”Š  â”Š40â”Š    return Utils.isBetween(x, this.x1, this.x2) &&\n+â”Š  â”Š41â”Š           Utils.isBetween(y, this.y1, this.y2);\n+â”Š  â”Š42â”Š  }\n+â”Š  â”Š43â”Š\n+â”Š  â”Š44â”Š  getIntersection(shape) {\n+â”Š  â”Š45â”Š    if (shape instanceof Engine.Geometry.Line)\n+â”Š  â”Š46â”Š      return this.getLineIntersection(shape);\n+â”Š  â”Š47â”Š  }\n+â”Š  â”Š48â”Š\n+â”Š  â”Š49â”Š  // line - line intersection method\n+â”Š  â”Š50â”Š  getLineIntersection(line) {\n+â”Š  â”Š51â”Š    // Escape if lines are parallel\n+â”Š  â”Š52â”Š    if (!(((this.x1 - this.x2) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * (line.x1 - line.x2)))) return;\n+â”Š  â”Š53â”Š\n+â”Š  â”Š54â”Š    // Intersection point formula\n+â”Š  â”Š55â”Š    let x = Utils.trim(((((this.x1 * this.y2) - (this.y1 * this.x2)) * (line.x1 - line.x2)) - ((this.x1 - this.x2) * ((line.x1 * line.y2) - (line.y1 * line.x2)))) /\n+â”Š  â”Š56â”Š        (((this.x1 - this.x2) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * (line.x1 - line.x2))), 9);\n+â”Š  â”Š57â”Š    let y = Utils.trim(((((this.x1 * this.y2) - (this.y1 * this.x2)) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * ((line.x1 * line.y2) - (line.y1 * line.x2)))) /\n+â”Š  â”Š58â”Š        (((this.x1 - this.x2) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * (line.x1 - line.x2))), 9);\n+â”Š  â”Š59â”Š\n+â”Š  â”Š60â”Š    if (Utils.isBetween(x, this.x1, this.x2) && Utils.isBetween(x, line.x1, line.x2) &&\n+â”Š  â”Š61â”Š        Utils.isBetween(y, this.y1, this.y2) && Utils.isBetween(y, line.y1, line.y2)) {\n+â”Š  â”Š62â”Š      return { x, y };\n+â”Š  â”Š63â”Š    }\n+â”Š  â”Š64â”Š  }\n+â”Š  â”Š65â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -10,6 +10,7 @@\n â”Š10â”Š10â”Š    <!-- Scripts -->\n â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/utils.js\"></script>\n â”Š12â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n+â”Š  â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/geometry/line.js\"></script>\n â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/restorable.js\"></script>\n â”Š14â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/font.js\"></script>\n â”Š15â”Š16â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/sprite.js\"></script>\n```\n\n[}]: #\n\nYou can go through the comments of the step above which will guide you through the programmatic aspect of it, but I think it's more important to understand the concept of a line in 2D space. A line is made out of two points, usually represented as `(x1, y1)` and `(x2, y2)`. The slope of the line, usually represented as `m`, can be determined using these two points based on the following formula:\n\n![slope](https://cloud.githubusercontent.com/assets/7648874/21788249/b4c7e41c-d6b4-11e6-9c17-baff66ec6bc8.png)\n\nOnce we have two lines whose `m` is different (Unparalleled) and there is no intersection between the points of which they are represented with (In which case they are united), there must be an intersection point. The intersection point can be found using the following formula:\n\n![line-line](https://cloud.githubusercontent.com/assets/7648874/21787164/c9d83bf0-d6ae-11e6-9846-4fc013eebab3.png)\n\n![line-line-illustration](https://cloud.githubusercontent.com/assets/7648874/21790864/56725cf0-d6c6-11e6-916b-50b1fc0b87af.png)\n\n> See reference: http://mathworld.wolfram.com/Line-LineIntersection.html.\n\nObviously we have some logic here which needs to be tested. To test our `Line` class, we will be using a testing framework called [Jasmine](https://jasmine.github.io/). We first need to download `Jasmine`'s essentials in order for it to work:\n\n    resources/libs$ mkdir jasmine\n    resources/libs$ cd jasmine\n    resources/libs/jasmine$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/libs/jasmine/boot.js\n    resources/libs/jasmine$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/libs/jasmine/console.js\n    resources/libs/jasmine$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/libs/jasmine/jasmine-html.js\n    resources/libs/jasmine$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/libs/jasmine/jasmine.css\n    resources/libs/jasmine$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/libs/jasmine/jasmine.js\n    resources/libs/jasmine$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/libs/jasmine/jasmine_favicon.png\n\nThese essentials should be loaded in a newly created view where we're gonna see our specs running:\n\n[{]: <helper> (diffStep 5.5)\n\n#### [Step 5.5: Create specs runner view](https://github.com/DAB0mB/radial-snake/commit/150be1a)\n\n##### Added views&#x2F;spec_runner.html\n```diff\n@@ -0,0 +1,27 @@\n+â”Š  â”Š 1â”Š\n+â”Š  â”Š 2â”Š<!DOCTYPE html>\n+â”Š  â”Š 3â”Š<html>\n+â”Š  â”Š 4â”Š  <head>\n+â”Š  â”Š 5â”Š    <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n+â”Š  â”Š 6â”Š    <title>Jasmine Spec Runner v2.0.1</title>\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Š    <!-- Jasmine -->\n+â”Š  â”Š 9â”Š    <script type=\"text/javascript\" src=\"libs/jasmine/jasmine.js\"></script>\n+â”Š  â”Š10â”Š    <script type=\"text/javascript\" src=\"libs/jasmine/jasmine-html.js\"></script>\n+â”Š  â”Š11â”Š    <script type=\"text/javascript\" src=\"libs/jasmine/boot.js\"></script>\n+â”Š  â”Š12â”Š    <link rel=\"shortcut icon\" type=\"image/png\" href=\"libs/jasmine/jasmine_favicon.png\">\n+â”Š  â”Š13â”Š    <link rel=\"stylesheet\" type=\"text/css\" href=\"libs/jasmine/jasmine.css\">\n+â”Š  â”Š14â”Š\n+â”Š  â”Š15â”Š    <!-- Libs -->\n+â”Š  â”Š16â”Š    <script type=\"text/javascript\" src=\"libs/underscore.js\"></script>\n+â”Š  â”Š17â”Š\n+â”Š  â”Š18â”Š    <!-- Scripts -->\n+â”Š  â”Š19â”Š    <script type=\"text/javascript\" src=\"scripts/utils.js\"></script>\n+â”Š  â”Š20â”Š    <script type=\"text/javascript\" src=\"scripts/namespaces.js\"></script>\n+â”Š  â”Š21â”Š\n+â”Š  â”Š22â”Š    <!-- Specs -->\n+â”Š  â”Š23â”Š  </head>\n+â”Š  â”Š24â”Š\n+â”Š  â”Š25â”Š  <body>\n+â”Š  â”Š26â”Š  </body>\n+â”Š  â”Š27â”Š</html>ðŸš«â†µ\n```\n\n[}]: #\n\nNow once we'll navigate to the `/test` sub-route (`localhost:8000/test` by default) we should be provided with the spec runner. As for now there are no specs implemented at all, which brings us to the next stage - Implementing tests for `Line` class:\n\n[{]: <helper> (diffStep 5.6)\n\n#### [Step 5.6: Create &#x27;Line&#x27; class tests](https://github.com/DAB0mB/radial-snake/commit/c052752)\n\n##### Added resources&#x2F;scripts&#x2F;specs&#x2F;engine&#x2F;geometry&#x2F;line.js\n```diff\n@@ -0,0 +1,78 @@\n+â”Š  â”Š 1â”Šdescribe(\"Engine.Geometry.Line class\", function() {\n+â”Š  â”Š 2â”Š  beforeEach(function() {\n+â”Š  â”Š 3â”Š    this.line = new Engine.Geometry.Line(-5, -5, 5, 5);\n+â”Š  â”Š 4â”Š  });\n+â”Š  â”Š 5â”Š\n+â”Š  â”Š 6â”Š  describe(\"getX method\", function() {\n+â”Š  â”Š 7â”Š    describe(\"given inranged y\", function() {\n+â”Š  â”Š 8â”Š      it(\"returns x\", function() {\n+â”Š  â”Š 9â”Š        expect(this.line.getX(1)).toBeCloseTo(1);\n+â”Š  â”Š10â”Š      });\n+â”Š  â”Š11â”Š    });\n+â”Š  â”Š12â”Š\n+â”Š  â”Š13â”Š    describe(\"given outranged y\", function() {\n+â”Š  â”Š14â”Š      it(\"returns nothing\", function() {\n+â”Š  â”Š15â”Š        expect(this.line.getX(10)).toBeUndefined();\n+â”Š  â”Š16â”Š      });\n+â”Š  â”Š17â”Š    });\n+â”Š  â”Š18â”Š  });\n+â”Š  â”Š19â”Š\n+â”Š  â”Š20â”Š  describe(\"getY method\", function() {\n+â”Š  â”Š21â”Š    describe(\"given inranged x\", function() {\n+â”Š  â”Š22â”Š      it(\"returns y\", function() {\n+â”Š  â”Š23â”Š        expect(this.line.getY(1)).toBeCloseTo(1);\n+â”Š  â”Š24â”Š      });\n+â”Š  â”Š25â”Š    });\n+â”Š  â”Š26â”Š\n+â”Š  â”Š27â”Š    describe(\"given outranged x\", function() {\n+â”Š  â”Š28â”Š      it(\"returns nothing\", function() {\n+â”Š  â”Š29â”Š        expect(this.line.getY(10)).toBeUndefined();\n+â”Š  â”Š30â”Š      });\n+â”Š  â”Š31â”Š    });\n+â”Š  â”Š32â”Š  });\n+â”Š  â”Š33â”Š\n+â”Š  â”Š34â”Š  describe(\"hasPoint method\", function() {\n+â”Š  â”Š35â”Š    describe(\"given contained point\", function() {\n+â”Š  â”Š36â”Š      it(\"returns true\", function() {\n+â”Š  â”Š37â”Š        let x = 1;\n+â”Š  â”Š38â”Š        let y = 1;\n+â”Š  â”Š39â”Š        expect(this.line.hasPoint(x, y)).toBeTruthy();\n+â”Š  â”Š40â”Š      });\n+â”Š  â”Š41â”Š    });\n+â”Š  â”Š42â”Š\n+â”Š  â”Š43â”Š    describe(\"given uncontained point\", function() {\n+â”Š  â”Š44â”Š      it(\"returns false\", function() {\n+â”Š  â”Š45â”Š        let x = 10;\n+â”Š  â”Š46â”Š        let y = 10;\n+â”Š  â”Š47â”Š        expect(this.line.hasPoint(x, y)).toBeFalsy();\n+â”Š  â”Š48â”Š      });\n+â”Š  â”Š49â”Š    });\n+â”Š  â”Š50â”Š  });\n+â”Š  â”Š51â”Š\n+â”Š  â”Š52â”Š  describe(\"getLineIntersection method\", function() {\n+â”Š  â”Š53â”Š    describe(\"given intersecting line\", function() {\n+â”Š  â”Š54â”Š      it(\"returns intersection point\", function() {\n+â”Š  â”Š55â”Š        let line = new Engine.Geometry.Line(1, -5, 1, 5);\n+â”Š  â”Š56â”Š\n+â”Š  â”Š57â”Š        expect(this.line.getLineIntersection(line)).toEqual({\n+â”Š  â”Š58â”Š          x: 1,\n+â”Š  â”Š59â”Š          y: 1\n+â”Š  â”Š60â”Š        });\n+â”Š  â”Š61â”Š      });\n+â”Š  â”Š62â”Š    });\n+â”Š  â”Š63â”Š\n+â”Š  â”Š64â”Š    describe(\"given parallel line\", function() {\n+â”Š  â”Š65â”Š      it(\"returns nothing\", function() {\n+â”Š  â”Š66â”Š        let line = new Engine.Geometry.Line(-5, -6, 5, 4);\n+â”Š  â”Š67â”Š        expect(this.line.getLineIntersection(line)).toBeUndefined();\n+â”Š  â”Š68â”Š      });\n+â”Š  â”Š69â”Š    });\n+â”Š  â”Š70â”Š\n+â”Š  â”Š71â”Š    describe(\"given outranged line\", function() {\n+â”Š  â”Š72â”Š      it(\"returns nothing\", function() {\n+â”Š  â”Š73â”Š        let line = new Engine.Geometry.Line(10, 10, 10, 15);\n+â”Š  â”Š74â”Š        expect(this.line.getLineIntersection(line)).toBeUndefined();\n+â”Š  â”Š75â”Š      });\n+â”Š  â”Š76â”Š    });\n+â”Š  â”Š77â”Š  });\n+â”Š  â”Š78â”Š});ðŸš«â†µ\n```\n\n##### Changed views&#x2F;spec_runner.html\n```diff\n@@ -18,8 +18,10 @@\n â”Š18â”Š18â”Š    <!-- Scripts -->\n â”Š19â”Š19â”Š    <script type=\"text/javascript\" src=\"scripts/utils.js\"></script>\n â”Š20â”Š20â”Š    <script type=\"text/javascript\" src=\"scripts/namespaces.js\"></script>\n+â”Š  â”Š21â”Š    <script type=\"text/javascript\" src=\"scripts/engine/geometry/line.js\"></script>\n â”Š21â”Š22â”Š\n â”Š22â”Š23â”Š    <!-- Specs -->\n+â”Š  â”Š24â”Š    <script type=\"text/javascript\" src=\"scripts/specs/engine/geometry/line.js\"></script>\n â”Š23â”Š25â”Š  </head>\n â”Š24â”Š26â”Š\n â”Š25â”Š27â”Š  <body>\n```\n\n[}]: #\n\nNow if you'll refresh the spec runner page you should be able to a green screen indicating all tests have passed (Assuming the tutorial is updated and you followed it correctly). As introduced at the beginning of the step, the snake is also dependent on circles, whose representing class should look like so:\n\n[{]: <helper> (diffStep 5.7)\n\n#### [Step 5.7: Create &#x27;Circle&#x27; class](https://github.com/DAB0mB/radial-snake/commit/f9c5723)\n\n##### Added resources&#x2F;scripts&#x2F;engine&#x2F;geometry&#x2F;circle.js\n```diff\n@@ -0,0 +1,167 @@\n+â”Š   â”Š  1â”ŠEngine.Geometry.Circle = class Circle {\n+â”Š   â”Š  2â”Š  // x - The x value of the circle's center\n+â”Š   â”Š  3â”Š  // y - The y value of the circle's center\n+â”Š   â”Š  4â”Š  // r - The radius of the center\n+â”Š   â”Š  5â”Š  // rad1 - The first radian of the circle, not necessarily its beginning\n+â”Š   â”Š  6â”Š  // rad2 - The second radian of the circle, not necessarily its beginning\n+â”Š   â”Š  7â”Š  constructor(x, y, r, rad1, rad2) {\n+â”Š   â”Š  8â”Š    this.x = Utils.trim(x, 9);\n+â”Š   â”Š  9â”Š    this.y = Utils.trim(y, 9);\n+â”Š   â”Š 10â”Š    this.r = Utils.trim(r, 9);\n+â”Š   â”Š 11â”Š\n+â”Š   â”Š 12â”Š    // Trimming mode is done based on which radian represents the ending and which radian\n+â”Š   â”Š 13â”Š    // represents the ending\n+â”Š   â”Š 14â”Š    if (rad1 > rad2) {\n+â”Š   â”Š 15â”Š      this.rad1 = Utils.trim(rad1, 9, \"floor\");\n+â”Š   â”Š 16â”Š      this.rad2 = Utils.trim(rad2, 9, \"ceil\");\n+â”Š   â”Š 17â”Š    }\n+â”Š   â”Š 18â”Š    else {\n+â”Š   â”Š 19â”Š      this.rad1 = Utils.trim(rad1, 9, \"ceil\");\n+â”Š   â”Š 20â”Š      this.rad2 = Utils.trim(rad2, 9, \"floor\");\n+â”Š   â”Š 21â”Š    }\n+â”Š   â”Š 22â”Š  }\n+â”Š   â”Š 23â”Š\n+â”Š   â”Š 24â”Š  // Draws the circle on the given context\n+â”Š   â”Š 25â”Š  draw(context) {\n+â”Š   â”Š 26â”Š    context.arc(this.x, this.y, this.r, this.rad1, this.rad2);\n+â”Š   â”Š 27â”Š  }\n+â”Š   â”Š 28â”Š\n+â”Š   â”Š 29â”Š  // Gets the matching x value for the given radian\n+â”Š   â”Š 30â”Š  getX(rad) {\n+â”Š   â”Š 31â”Š    if (!Utils(rad).trim(9).isBetween(this.rad1, this.rad2).value()) return;\n+â”Š   â”Š 32â”Š    return Utils.trim((this.r * Math.cos(rad)) + this.x, 9);\n+â”Š   â”Š 33â”Š  }\n+â”Š   â”Š 34â”Š\n+â”Š   â”Š 35â”Š  // Gets the matching y value for the given radian\n+â”Š   â”Š 36â”Š  getY(rad) {\n+â”Š   â”Š 37â”Š    if (!Utils(rad).trim(9).isBetween(this.rad1, this.rad2).value()) return;\n+â”Š   â”Š 38â”Š    return Utils.trim((this.r * Math.sin(rad)) + this.y, 9);\n+â”Š   â”Š 39â”Š  }\n+â”Š   â”Š 40â”Š\n+â”Š   â”Š 41â”Š  // Gets the matching point for the given radian\n+â”Š   â”Š 42â”Š  getPoint(rad) {\n+â”Š   â”Š 43â”Š    if (!Utils.isBetween(rad, this.rad1, this.rad2)) return;\n+â”Š   â”Š 44â”Š\n+â”Š   â”Š 45â”Š    return {\n+â”Š   â”Š 46â”Š      x: Utils.trim((this.r * Math.cos(rad)) + this.x, 9),\n+â”Š   â”Š 47â”Š      y: Utils.trim((this.r * Math.sin(rad)) + this.y, 9)\n+â”Š   â”Š 48â”Š    };\n+â”Š   â”Š 49â”Š  }\n+â”Š   â”Š 50â”Š\n+â”Š   â”Š 51â”Š  // Gets the matching radian for the given point\n+â”Š   â”Š 52â”Š  getRad(x, y) {\n+â”Š   â”Š 53â”Š    let rad = Math.atan2(y - this.y, x - this.x);\n+â”Š   â”Š 54â”Š\n+â”Š   â”Š 55â”Š    // If calculated radian is in circle's radian range, return it\n+â”Š   â”Š 56â”Š    if (rad != null && Utils.isBetween(rad, this.rad1, this.rad2)) {\n+â”Š   â”Š 57â”Š      return rad;\n+â”Š   â”Š 58â”Š    }\n+â”Š   â”Š 59â”Š\n+â”Š   â”Š 60â”Š    // The calculated radian can still be in the circle's radian range in case one\n+â”Š   â”Š 61â”Š    // of the radians is greater than 2 PIEs\n+â”Š   â”Š 62â”Š    if (Math.abs(this.rad1) > Math.abs(this.rad2)) {\n+â”Š   â”Š 63â”Š      var greatestRad = this.rad1;\n+â”Š   â”Š 64â”Š    }\n+â”Š   â”Š 65â”Š    else {\n+â”Š   â”Š 66â”Š      var greatestRad = this.rad2;\n+â”Š   â”Š 67â”Š    }\n+â”Š   â”Š 68â”Š\n+â”Š   â”Š 69â”Š    // Check if the absolute radian is in the circle's radian range\n+â”Š   â”Š 70â”Š    if (Utils(rad + (2 * Math.PI * Math.floor(greatestRad / (2 * Math.PI)))).trim(9).isBetween(this.rad1, this.rad2).value() ||\n+â”Š   â”Š 71â”Š        Utils(rad + (2 * Math.PI * Math.ceil(greatestRad / (2 * Math.PI)))).trim(9).isBetween(this.rad1, this.rad2).value()) {\n+â”Š   â”Š 72â”Š      return rad;\n+â”Š   â”Š 73â”Š    }\n+â”Š   â”Š 74â”Š  }\n+â”Š   â”Š 75â”Š\n+â”Š   â”Š 76â”Š  // Returns if circle has given points\n+â”Š   â”Š 77â”Š  hasPoint(x, y) {\n+â”Š   â”Š 78â”Š    return this.getRad(x, y) != null;\n+â”Š   â”Š 79â”Š  }\n+â”Š   â”Š 80â”Š\n+â”Š   â”Š 81â”Š  getIntersection(shape) {\n+â”Š   â”Š 82â”Š    if (shape instanceof Engine.Geometry.Line)\n+â”Š   â”Š 83â”Š      return this.getLineIntersection(shape);\n+â”Š   â”Š 84â”Š    if (shape instanceof Engine.Geometry.Circle)\n+â”Š   â”Š 85â”Š      return this.getCircleIntersection(shape);\n+â”Š   â”Š 86â”Š  }\n+â”Š   â”Š 87â”Š\n+â”Š   â”Š 88â”Š  // circle - circle intersection method\n+â”Š   â”Š 89â”Š  getCircleIntersection(circle) {\n+â”Š   â”Š 90â”Š    let dx = circle.x - this.x;\n+â”Š   â”Š 91â”Š    let dy = circle.y - this.y;\n+â”Š   â”Š 92â”Š    let d = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\n+â”Š   â”Š 93â”Š\n+â”Š   â”Š 94â”Š    if (d > this.r + circle.r ||\n+â”Š   â”Š 95â”Š       d < Math.abs(this.r - circle.r)) {\n+â”Š   â”Š 96â”Š      return;\n+â”Š   â”Š 97â”Š    }\n+â”Š   â”Š 98â”Š\n+â”Š   â”Š 99â”Š    let a = ((Math.pow(this.r, 2) - Math.pow(circle.r, 2)) + Math.pow(d, 2)) / (2 * d);\n+â”Š   â”Š100â”Š    let x = this.x + ((dx * a) / d);\n+â”Š   â”Š101â”Š    let y = this.y + ((dy * a) / d);\n+â”Š   â”Š102â”Š    let h = Math.sqrt(Math.pow(this.r, 2) - Math.pow(a, 2));\n+â”Š   â”Š103â”Š    let rx = (- dy * h) / d;\n+â”Š   â”Š104â”Š    let ry = (dx * h) / d;\n+â”Š   â”Š105â”Š\n+â”Š   â”Š106â”Š    let interPoints = [\n+â”Š   â”Š107â”Š      {\n+â”Š   â”Š108â”Š        x: x + rx,\n+â”Š   â”Š109â”Š        y: y + ry\n+â”Š   â”Š110â”Š      },\n+â”Š   â”Š111â”Š      {\n+â”Š   â”Š112â”Š        x: x - rx,\n+â”Š   â”Š113â”Š        y: y - ry\n+â”Š   â”Š114â”Š      }\n+â”Š   â”Š115â”Š    ]\n+â”Š   â”Š116â”Š    .map(point => ({\n+â”Š   â”Š117â”Š        x: Utils.trim(point.x, 9),\n+â”Š   â”Š118â”Š        y: Utils.trim(point.y, 9)\n+â”Š   â”Š119â”Š     }));\n+â”Š   â”Š120â”Š\n+â”Š   â”Š121â”Š    interPoints = _.uniq(interPoints, point => `(${point.x}, ${point.y})`);\n+â”Š   â”Š122â”Š\n+â”Š   â”Š123â”Š    [this, circle].forEach(function(circle) {\n+â”Š   â”Š124â”Š      interPoints = interPoints.filter(point => circle.hasPoint(point.x, point.y));\n+â”Š   â”Š125â”Š    });\n+â”Š   â”Š126â”Š\n+â”Š   â”Š127â”Š    if (interPoints.length > 0) return interPoints;\n+â”Š   â”Š128â”Š  }\n+â”Š   â”Š129â”Š\n+â”Š   â”Š130â”Š  // circle - line intersection method\n+â”Š   â”Š131â”Š  getLineIntersection(line) {\n+â”Š   â”Š132â”Š    let x1 = line.x1 - this.x;\n+â”Š   â”Š133â”Š    let x2 = line.x2 - this.x;\n+â”Š   â”Š134â”Š    let y1 = line.y1 - this.y;\n+â”Š   â”Š135â”Š    let y2 = line.y2 - this.y;\n+â”Š   â”Š136â”Š    let dx = x2 - x1;\n+â”Š   â”Š137â”Š    let dy = y2 - y1;\n+â”Š   â”Š138â”Š    let d = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\n+â”Š   â”Š139â”Š    let h = (x1 * y2) - (x2 * y1);\n+â”Š   â”Š140â”Š    let delta = (Math.pow(this.r, 2) * Math.pow(d, 2)) - Math.pow(h, 2);\n+â”Š   â”Š141â”Š\n+â”Š   â”Š142â”Š    if (delta < 0) return;\n+â”Š   â”Š143â”Š\n+â”Š   â”Š144â”Š    let interPoints = [\n+â”Š   â”Š145â”Š      {\n+â”Š   â”Š146â”Š        x: (((h * dy) + (((dy / Math.abs(dy)) || 1) * dx * Math.sqrt(delta))) / Math.pow(d, 2)) + this.x,\n+â”Š   â”Š147â”Š        y: (((-h * dx) + (Math.abs(dy) * Math.sqrt(delta))) / Math.pow(d, 2)) + this.y\n+â”Š   â”Š148â”Š      },\n+â”Š   â”Š149â”Š      {\n+â”Š   â”Š150â”Š        x: (((h * dy) - (((dy / Math.abs(dy)) || 1) * dx * Math.sqrt(delta))) / Math.pow(d, 2)) + this.x,\n+â”Š   â”Š151â”Š        y: (((-h * dx) - (Math.abs(dy) * Math.sqrt(delta))) / Math.pow(d, 2)) + this.y\n+â”Š   â”Š152â”Š      }\n+â”Š   â”Š153â”Š    ]\n+â”Š   â”Š154â”Š    .map(point => ({\n+â”Š   â”Š155â”Š        x: Utils.trim(point.x, 9),\n+â”Š   â”Š156â”Š        y: Utils.trim(point.y, 9)\n+â”Š   â”Š157â”Š    }))\n+â”Š   â”Š158â”Š    .filter(point => {\n+â”Š   â”Š159â”Š      return this.hasPoint(point.x, point.y) &&\n+â”Š   â”Š160â”Š        line.boundsHavePoint(point.x, point.y);\n+â”Š   â”Š161â”Š    });\n+â”Š   â”Š162â”Š\n+â”Š   â”Š163â”Š    interPoints = _.uniq(interPoints, point => `(${point.x}, ${point.y})`);\n+â”Š   â”Š164â”Š\n+â”Š   â”Š165â”Š    if (interPoints.length > 0) return interPoints;\n+â”Š   â”Š166â”Š  }\n+â”Š   â”Š167â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -11,6 +11,7 @@\n â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/utils.js\"></script>\n â”Š12â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n â”Š13â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/geometry/line.js\"></script>\n+â”Š  â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/geometry/circle.js\"></script>\n â”Š14â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/restorable.js\"></script>\n â”Š15â”Š16â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/font.js\"></script>\n â”Š16â”Š17â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/sprite.js\"></script>\n```\n\n[}]: #\n\nJust like a line, a circle can be presented using variables as well. The center of the circle is represented as `(x, y)` and its radius is represented as `r`. Remember that our circle doesn't necessarily have to be a full one, therefore we limit its range using two radians - `rad1` and `rad2`. The formula for representing a circle in a 2D space looks like this:\n\n![circle-formula](https://cloud.githubusercontent.com/assets/7648874/21829783/84a54574-d77f-11e6-9b87-3fb0f073bb8d.png)\n\n![circle-circle-illustration](https://cloud.githubusercontent.com/assets/7648874/21790842/3a73408c-d6c6-11e6-8bdd-9c73355e6ebb.png)\n\n> `a` and `b` represent the offsets from the `x` and the `y` axes respectively.\n> See reference: http://mathworld.wolfram.com/Circle-CircleIntersection.html.\n\nTo find intersection between two circles, we simply calculate the solution for two equations with two variables. Given that a line can be represented in a 2D space using the following formula:\n\n![line-formula](https://cloud.githubusercontent.com/assets/7648874/21790671/1609c050-d6c5-11e6-8bd7-16cc306f5eea.png)\n\n![circle-line-illustration](https://cloud.githubusercontent.com/assets/7648874/21790810/1a052086-d6c6-11e6-9c5c-24298fedb043.png)\n\n> `n` represents the intersection value with the `y` axis.\n> See reference: http://mathworld.wolfram.com/Circle-LineIntersection.html.\n\nwe can find the intersection between a circle and line by solving the systems formed by the equations of both. We also want the line-circle algorithm to be available for any `Line` instance, therefore we gonna add the following delegate on the `Line` prototype:\n\n[{]: <helper> (diffStep 5.8)\n\n#### [Step 5.8: Delegate circle intersection methods](https://github.com/DAB0mB/radial-snake/commit/19828bf)\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;geometry&#x2F;line.js\n```diff\n@@ -44,6 +44,8 @@\n â”Š44â”Š44â”Š  getIntersection(shape) {\n â”Š45â”Š45â”Š    if (shape instanceof Engine.Geometry.Line)\n â”Š46â”Š46â”Š      return this.getLineIntersection(shape);\n+â”Š  â”Š47â”Š    if (shape instanceof Engine.Geometry.Circle)\n+â”Š  â”Š48â”Š      return this.getCircleIntersection(shape);\n â”Š47â”Š49â”Š  }\n â”Š48â”Š50â”Š\n â”Š49â”Š51â”Š  // line - line intersection method\n```\n```diff\n@@ -62,4 +64,9 @@\n â”Š62â”Š64â”Š      return { x, y };\n â”Š63â”Š65â”Š    }\n â”Š64â”Š66â”Š  }\n+â”Š  â”Š67â”Š\n+â”Š  â”Š68â”Š  // line - circle intersection method\n+â”Š  â”Š69â”Š  getCircleIntersection(circle) {\n+â”Š  â”Š70â”Š    return circle.getLineIntersection(this);\n+â”Š  â”Š71â”Š  }\n â”Š65â”Š72â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nThen again a newly created geometry shape class should be tested against different scenarios:\n\n[{]: <helper> (diffStep 5.9)\n\n#### [Step 5.9: Create &#x27;Circle&#x27; class tests](https://github.com/DAB0mB/radial-snake/commit/1d98a6e)\n\n##### Added resources&#x2F;scripts&#x2F;specs&#x2F;engine&#x2F;geometry&#x2F;circle.js\n```diff\n@@ -0,0 +1,144 @@\n+â”Š   â”Š  1â”Šdescribe(\"Engine.Geometry.Circle class\", function() {\n+â”Š   â”Š  2â”Š  beforeEach(function() {\n+â”Š   â”Š  3â”Š    this.circle = new Engine.Geometry.Circle(1, 1, 5, 0, 1.5 * Math.PI);\n+â”Š   â”Š  4â”Š  });\n+â”Š   â”Š  5â”Š\n+â”Š   â”Š  6â”Š  describe(\"getX method\", function() {\n+â”Š   â”Š  7â”Š    describe(\"given inranged rad\", function() {\n+â”Š   â”Š  8â”Š      it(\"returns x\", function() {\n+â”Š   â”Š  9â”Š        expect(this.circle.getX(0 * Math.PI)).toBeCloseTo(6);\n+â”Š   â”Š 10â”Š        expect(this.circle.getX(0.5 * Math.PI)).toBeCloseTo(1);\n+â”Š   â”Š 11â”Š        expect(this.circle.getX(1 * Math.PI)).toBeCloseTo(-4);\n+â”Š   â”Š 12â”Š        expect(this.circle.getX(1.5 * Math.PI)).toBeCloseTo(1);\n+â”Š   â”Š 13â”Š      });\n+â”Š   â”Š 14â”Š    });\n+â”Š   â”Š 15â”Š\n+â”Š   â”Š 16â”Š    describe(\"given outranged rad\", function() {\n+â”Š   â”Š 17â”Š      it(\"returns nothing\", function() {\n+â”Š   â”Š 18â”Š        expect(this.circle.getX(2 * Math.PI)).toBeUndefined();\n+â”Š   â”Š 19â”Š      });\n+â”Š   â”Š 20â”Š    });\n+â”Š   â”Š 21â”Š  });\n+â”Š   â”Š 22â”Š\n+â”Š   â”Š 23â”Š  describe(\"getY method\", function() {\n+â”Š   â”Š 24â”Š    describe(\"given inranged rad\", function() {\n+â”Š   â”Š 25â”Š      it(\"returns y\", function() {\n+â”Š   â”Š 26â”Š        expect(this.circle.getY(0 * Math.PI)).toBeCloseTo(1);\n+â”Š   â”Š 27â”Š        expect(this.circle.getY(0.5 * Math.PI)).toBeCloseTo(6);\n+â”Š   â”Š 28â”Š        expect(this.circle.getY(1 * Math.PI)).toBeCloseTo(1);\n+â”Š   â”Š 29â”Š        expect(this.circle.getY(1.5 * Math.PI)).toBeCloseTo(-4);\n+â”Š   â”Š 30â”Š      });\n+â”Š   â”Š 31â”Š    });\n+â”Š   â”Š 32â”Š\n+â”Š   â”Š 33â”Š    describe(\"given outranged rad\", function() {\n+â”Š   â”Š 34â”Š      it(\"returns nothing\", function() {\n+â”Š   â”Š 35â”Š        expect(this.circle.getY(2 * Math.PI)).toBeUndefined();\n+â”Š   â”Š 36â”Š      });\n+â”Š   â”Š 37â”Š    });\n+â”Š   â”Š 38â”Š  });\n+â”Š   â”Š 39â”Š\n+â”Š   â”Š 40â”Š  describe(\"getRad method\", function() {\n+â”Š   â”Š 41â”Š    describe(\"given inranged point\", function() {\n+â”Š   â”Š 42â”Š      it(\"returns rad\", function() {\n+â”Š   â”Š 43â”Š        let x = -3.0450849718747346;\n+â”Š   â”Š 44â”Š        let y = 3.9389262614623686;\n+â”Š   â”Š 45â”Š        expect(this.circle.getRad(x, y)).toBeCloseTo(0.8 * Math.PI);\n+â”Š   â”Š 46â”Š      });\n+â”Š   â”Š 47â”Š    });\n+â”Š   â”Š 48â”Š\n+â”Š   â”Š 49â”Š    describe(\"given outranged point\", function() {\n+â”Š   â”Š 50â”Š      it(\"returns nothing\", function() {\n+â”Š   â”Š 51â”Š        let x = 5.045084971874736;\n+â”Š   â”Š 52â”Š        let y = -1.9389262614623664;\n+â”Š   â”Š 53â”Š        expect(this.circle.getRad(x, y)).toBeUndefined();\n+â”Š   â”Š 54â”Š      });\n+â”Š   â”Š 55â”Š    });\n+â”Š   â”Š 56â”Š  });\n+â”Š   â”Š 57â”Š\n+â”Š   â”Š 58â”Š  describe(\"getCircleIntersection method\", function() {\n+â”Š   â”Š 59â”Š    describe(\"given circle with 2 intersection points\", function() {\n+â”Š   â”Š 60â”Š      it(\"returns array with intersection points\", function() {\n+â”Š   â”Š 61â”Š        let circle = new Engine.Geometry.Circle(-5, 1, 5, 0, 2 * Math.PI);\n+â”Š   â”Š 62â”Š\n+â”Š   â”Š 63â”Š        expect(this.circle.getCircleIntersection(circle)).toEqual([\n+â”Š   â”Š 64â”Š          { x: -2, y: -3 },\n+â”Š   â”Š 65â”Š          { x: -2, y: 5 }\n+â”Š   â”Š 66â”Š        ]);\n+â”Š   â”Š 67â”Š      });\n+â”Š   â”Š 68â”Š    });\n+â”Š   â”Š 69â”Š\n+â”Š   â”Š 70â”Š    describe(\"given circle with 1 intersection points\", function() {\n+â”Š   â”Š 71â”Š      it(\"returns array with intersection point\", function() {\n+â”Š   â”Š 72â”Š        let circle = new Engine.Geometry.Circle(-5, 1, 5, 0, 1 * Math.PI);\n+â”Š   â”Š 73â”Š\n+â”Š   â”Š 74â”Š        expect(this.circle.getCircleIntersection(circle)).toEqual([\n+â”Š   â”Š 75â”Š          { x: -2, y: 5 }\n+â”Š   â”Š 76â”Š        ]);\n+â”Š   â”Š 77â”Š      });\n+â”Š   â”Š 78â”Š    });\n+â”Š   â”Š 79â”Š\n+â”Š   â”Š 80â”Š    describe(\"given kissing circle\", function() {\n+â”Š   â”Š 81â”Š      it(\"returns array with intersection point\", function() {\n+â”Š   â”Š 82â”Š        let circle = new Engine.Geometry.Circle(-9, 1, 5, 0, 2 * Math.PI);\n+â”Š   â”Š 83â”Š\n+â”Š   â”Š 84â”Š        expect(this.circle.getCircleIntersection(circle)).toEqual([\n+â”Š   â”Š 85â”Š          { x: -4, y: 1 }\n+â”Š   â”Š 86â”Š        ]);\n+â”Š   â”Š 87â”Š      });\n+â”Š   â”Š 88â”Š    });\n+â”Š   â”Š 89â”Š\n+â”Š   â”Š 90â”Š    describe(\"given outer circle\", function() {\n+â”Š   â”Š 91â”Š      it(\"returns nothing\", function() {\n+â”Š   â”Š 92â”Š        let circle = new Engine.Geometry.Circle(10, 10, 2, 0, 2 * Math.PI);\n+â”Š   â”Š 93â”Š        expect(this.circle.getCircleIntersection(circle)).toBeUndefined();\n+â”Š   â”Š 94â”Š      });\n+â”Š   â”Š 95â”Š    });\n+â”Š   â”Š 96â”Š\n+â”Š   â”Š 97â”Š    describe(\"given inner circle\", function() {\n+â”Š   â”Š 98â”Š      it(\"nothing\", function() {\n+â”Š   â”Š 99â”Š        let circle = new Engine.Geometry.Circle(1, 1, 2, 0, 2 * Math.PI);\n+â”Š   â”Š100â”Š        expect(this.circle.getCircleIntersection(circle)).toBeUndefined();\n+â”Š   â”Š101â”Š      });\n+â”Š   â”Š102â”Š    });\n+â”Š   â”Š103â”Š  });\n+â”Š   â”Š104â”Š\n+â”Š   â”Š105â”Š  describe(\"getLineIntersection method\", function() {\n+â”Š   â”Š106â”Š    describe(\"given line with 2 intersection points\", function() {\n+â”Š   â”Š107â”Š      it(\"returns array with intersection points\", function() {\n+â”Š   â”Š108â”Š        let line = new Engine.Geometry.Line(-10, 1, 10, 1);\n+â”Š   â”Š109â”Š\n+â”Š   â”Š110â”Š        expect(this.circle.getLineIntersection(line)).toEqual([\n+â”Š   â”Š111â”Š          { x: 6, y: 1 },\n+â”Š   â”Š112â”Š          { x: -4, y: 1 }\n+â”Š   â”Š113â”Š        ]);\n+â”Š   â”Š114â”Š      });\n+â”Š   â”Š115â”Š    });\n+â”Š   â”Š116â”Š\n+â”Š   â”Š117â”Š    describe(\"given line with 1 intersection point\", function() {\n+â”Š   â”Š118â”Š      it(\"returns array with intersection point\", function() {\n+â”Š   â”Š119â”Š        let line = new Engine.Geometry.Line(-10, 1, 1, 1);\n+â”Š   â”Š120â”Š\n+â”Š   â”Š121â”Š        expect(this.circle.getLineIntersection(line)).toEqual([\n+â”Š   â”Š122â”Š          { x: -4, y: 1 }\n+â”Š   â”Š123â”Š        ]);\n+â”Š   â”Š124â”Š      });\n+â”Š   â”Š125â”Š    });\n+â”Š   â”Š126â”Š\n+â”Š   â”Š127â”Š    describe(\"given kissing line\", function() {\n+â”Š   â”Š128â”Š      it(\"returns array with intersection point\", function() {\n+â”Š   â”Š129â”Š        let line = new Engine.Geometry.Line(-10, 6, 10, 6);\n+â”Š   â”Š130â”Š\n+â”Š   â”Š131â”Š        expect(this.circle.getLineIntersection(line)).toEqual([\n+â”Š   â”Š132â”Š          { x: 1, y: 6 }\n+â”Š   â”Š133â”Š        ]);\n+â”Š   â”Š134â”Š      });\n+â”Š   â”Š135â”Š    });\n+â”Š   â”Š136â”Š\n+â”Š   â”Š137â”Š    describe(\"given outranged line\", function() {\n+â”Š   â”Š138â”Š      it(\"returns nothing\", function() {\n+â”Š   â”Š139â”Š        let line = new Engine.Geometry.Line(-10, 10, 10, 10);\n+â”Š   â”Š140â”Š        expect(this.circle.getLineIntersection(line)).toBeUndefined();\n+â”Š   â”Š141â”Š      });\n+â”Š   â”Š142â”Š    });\n+â”Š   â”Š143â”Š  });\n+â”Š   â”Š144â”Š});ðŸš«â†µ\n```\n\n##### Changed views&#x2F;spec_runner.html\n```diff\n@@ -19,9 +19,11 @@\n â”Š19â”Š19â”Š    <script type=\"text/javascript\" src=\"scripts/utils.js\"></script>\n â”Š20â”Š20â”Š    <script type=\"text/javascript\" src=\"scripts/namespaces.js\"></script>\n â”Š21â”Š21â”Š    <script type=\"text/javascript\" src=\"scripts/engine/geometry/line.js\"></script>\n+â”Š  â”Š22â”Š    <script type=\"text/javascript\" src=\"scripts/engine/geometry/circle.js\"></script>\n â”Š22â”Š23â”Š\n â”Š23â”Š24â”Š    <!-- Specs -->\n â”Š24â”Š25â”Š    <script type=\"text/javascript\" src=\"scripts/specs/engine/geometry/line.js\"></script>\n+â”Š  â”Š26â”Š    <script type=\"text/javascript\" src=\"scripts/specs/engine/geometry/circle.js\"></script>\n â”Š25â”Š27â”Š  </head>\n â”Š26â”Š28â”Š\n â”Š27â”Š29â”Š  <body>\n```\n\n[}]: #\n\nOur final shape in the geometry module would be a polygon. Why a polygon? Since I'm planning to make the snake's movement circular, which means that once the snake hits a random boundary, he will reappear from the other side of the canvas. The collision detection between the snake and the canvas would be done using a polygon - which is simply made out of 4 lines:\n\n[{]: <helper> (diffStep 5.1)\n\n#### [Step 5.1: Create utilities module](https://github.com/DAB0mB/radial-snake/commit/58ae99a)\n\n##### Added resources&#x2F;scripts&#x2F;utils.js\n```diff\n@@ -0,0 +1,68 @@\n+â”Š  â”Š 1â”Š// A wrapper function for our utilities which will enable chaining\n+â”Š  â”Š 2â”Š// e.g. Utils().mod().trim().isBetween()...\n+â”Š  â”Š 3â”ŠUtils = function Utils(context) {\n+â”Š  â”Š 4â”Š  const chain = {};\n+â”Š  â”Š 5â”Š\n+â”Š  â”Š 6â”Š  Object.keys(Utils).forEach((utilName) => {\n+â”Š  â”Š 7â”Š    chain[utilName] = (...args) => {\n+â”Š  â”Š 8â”Š      const result = Utils[utilName](context, ...args);\n+â”Š  â”Š 9â”Š      return Utils(result);\n+â”Š  â”Š10â”Š    };\n+â”Š  â”Š11â”Š  });\n+â”Š  â”Š12â”Š\n+â”Š  â”Š13â”Š  // Returns the result of the chaining\n+â”Š  â”Š14â”Š  chain.value = () => context;\n+â”Š  â”Š15â”Š\n+â”Š  â”Š16â”Š  return chain;\n+â”Š  â”Š17â”Š};\n+â”Š  â”Š18â”Š\n+â”Š  â”Š19â”Š// Fixed modulo method which can calculate modulo of negative numbers properly\n+â”Š  â”Š20â”Š// e.g. (-803).mod(800) returns 797\n+â”Š  â”Š21â”ŠUtils.mod = function (context, num) {\n+â”Š  â”Š22â”Š  return ((context % num) + num) % num;\n+â”Š  â”Š23â”Š};\n+â”Š  â”Š24â”Š\n+â”Š  â”Š25â”Š// Trims number and leaves the number of decimals specified.\n+â”Š  â”Š26â”Š// The \"mode\" argument specifies which math function should be invoked\n+â”Š  â”Š27â”Š// right after the number has been trimmed.\n+â”Š  â”Š28â”Š// e.g. 12.12345.trim(3, \"ceil\") returns 12.124\n+â”Š  â”Š29â”ŠUtils.trim = function (context, decimals, mode = \"round\") {\n+â”Š  â”Š30â”Š  return Math[mode](context * Math.pow(10, decimals)) / Math.pow(10, decimals);\n+â”Š  â”Š31â”Š};\n+â”Š  â”Š32â”Š\n+â”Š  â”Š33â”Š// Tells if number is in specified range based on given precision.\n+â”Š  â”Š34â”Š// See the \"compare\" method for more information about precision\n+â”Š  â”Š35â”ŠUtils.isBetween = function (context, num1, num2, precision) {\n+â”Š  â”Š36â”Š  return Utils.compare(context, Math.min(num1, num2), \">=\", precision) &&\n+â”Š  â”Š37â”Š         Utils.compare(context, Math.max(num1, num2), \"<=\", precision);\n+â”Š  â”Š38â”Š};\n+â”Š  â”Š39â”Š\n+â”Š  â”Š40â”Š// Initiates comparison operator between context number and a given number, only here\n+â”Š  â”Š41â”Š// a precision can be specified\n+â”Š  â”Š42â”ŠUtils.compare = function (context, num, method, precision = method) {\n+â”Š  â”Š43â”Š  switch (precision) {\n+â”Š  â”Š44â”Š    // Fixed precision, \"almost equal\" with a deviation of Îµ\n+â”Š  â”Š45â”Š    case \"f\":\n+â”Š  â”Š46â”Š      switch (method) {\n+â”Š  â”Š47â”Š        case \"<\": case \"<=\": return context <= num + Number.EPSILON;\n+â”Š  â”Š48â”Š        case \">\": case \">=\": return context >= num - Number.EPSILON;\n+â”Š  â”Š49â”Š        default: return Math.abs(context - num) <= Number.EPSILON;\n+â”Š  â”Š50â”Š      }\n+â”Š  â”Š51â”Š    // Pixel precision, round comparison\n+â”Š  â”Š52â”Š    case \"px\":\n+â”Š  â”Š53â”Š      switch (method) {\n+â”Š  â”Š54â”Š        case \"<\": case \"<=\": return Math.round(context) <= Math.round(num);\n+â”Š  â”Š55â”Š        case \">\": case \">=\": return Math.round(context) >= Math.round(num);\n+â”Š  â”Š56â”Š        default: return Math.round(context) == Math.round(num);\n+â”Š  â”Š57â”Š      }\n+â”Š  â”Š58â”Š    // Exact precision\n+â”Š  â”Š59â”Š    default:\n+â”Š  â”Š60â”Š      switch (method) {\n+â”Š  â”Š61â”Š        case \"<\": return context < num;\n+â”Š  â”Š62â”Š        case \"<=\": return context <= num;\n+â”Š  â”Š63â”Š        case \">\": return context > num;\n+â”Š  â”Š64â”Š        case \">=\": return context >= num;\n+â”Š  â”Š65â”Š        default: return context === num;\n+â”Š  â”Š66â”Š      }\n+â”Š  â”Š67â”Š  }\n+â”Š  â”Š68â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -8,6 +8,7 @@\n â”Š 8â”Š 8â”Š    <script type=\"text/javascript\" src=\"/libs/underscore.js\"></script>\n â”Š 9â”Š 9â”Š\n â”Š10â”Š10â”Š    <!-- Scripts -->\n+â”Š  â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/utils.js\"></script>\n â”Š11â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n â”Š12â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/restorable.js\"></script>\n â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/font.js\"></script>\n```\n\n[}]: #\n\nAgain we will delegate the newly created intersection methods in the `Line` class and `Circle` class:\n\n[{]: <helper> (diffStep 5.11)\n\n#### [Step 5.11: Delegate polygon intersection methods](https://github.com/DAB0mB/radial-snake/commit/d42a5d9)\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;geometry&#x2F;circle.js\n```diff\n@@ -83,6 +83,8 @@\n â”Š83â”Š83â”Š      return this.getLineIntersection(shape);\n â”Š84â”Š84â”Š    if (shape instanceof Engine.Geometry.Circle)\n â”Š85â”Š85â”Š      return this.getCircleIntersection(shape);\n+â”Š  â”Š86â”Š    if (shape instanceof Engine.Geometry.Polygon)\n+â”Š  â”Š87â”Š      return this.getPolygonIntersection(shape);\n â”Š86â”Š88â”Š  }\n â”Š87â”Š89â”Š\n â”Š88â”Š90â”Š  // circle - circle intersection method\n```\n```diff\n@@ -164,4 +166,9 @@\n â”Š164â”Š166â”Š\n â”Š165â”Š167â”Š    if (interPoints.length > 0) return interPoints;\n â”Š166â”Š168â”Š  }\n+â”Š   â”Š169â”Š\n+â”Š   â”Š170â”Š  // circle - polygon intersection method\n+â”Š   â”Š171â”Š  getPolygonIntersection(polygon) {\n+â”Š   â”Š172â”Š    return polygon.getCircleIntersection(this);\n+â”Š   â”Š173â”Š  }\n â”Š167â”Š174â”Š};ðŸš«â†µ\n```\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;geometry&#x2F;line.js\n```diff\n@@ -46,6 +46,8 @@\n â”Š46â”Š46â”Š      return this.getLineIntersection(shape);\n â”Š47â”Š47â”Š    if (shape instanceof Engine.Geometry.Circle)\n â”Š48â”Š48â”Š      return this.getCircleIntersection(shape);\n+â”Š  â”Š49â”Š    if (shape instanceof Engine.Geometry.Polygon)\n+â”Š  â”Š50â”Š      return this.getPolygonIntersection(shape);\n â”Š49â”Š51â”Š  }\n â”Š50â”Š52â”Š\n â”Š51â”Š53â”Š  // line - line intersection method\n```\n```diff\n@@ -69,4 +71,9 @@\n â”Š69â”Š71â”Š  getCircleIntersection(circle) {\n â”Š70â”Š72â”Š    return circle.getLineIntersection(this);\n â”Š71â”Š73â”Š  }\n+â”Š  â”Š74â”Š\n+â”Š  â”Š75â”Š  // line - polygon intersection method\n+â”Š  â”Š76â”Š  getPolygonIntersection(polygon) {\n+â”Š  â”Š77â”Š    return polygon.getLineIntersection(this);\n+â”Š  â”Š78â”Š  }\n â”Š72â”Š79â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nNow we will create a some tests to make sure our newly created polygon works properly:\n\n[{]: <helper> (diffStep 5.12)\n\n#### [Step 5.12: Create &#x27;Polygon&#x27; class tests](https://github.com/DAB0mB/radial-snake/commit/f3f890b)\n\n##### Added resources&#x2F;scripts&#x2F;specs&#x2F;engine&#x2F;geometry&#x2F;polygon.js\n```diff\n@@ -0,0 +1,96 @@\n+â”Š  â”Š 1â”Šdescribe(\"Engine.Geometry.Polygon class\", function() {\n+â”Š  â”Š 2â”Š  beforeEach(function() {\n+â”Š  â”Š 3â”Š    this.polygon = new Engine.Geometry.Polygon(\n+â”Š  â”Š 4â”Š      [0, 0, 5, 0],\n+â”Š  â”Š 5â”Š      [5, 0, 5, 5],\n+â”Š  â”Š 6â”Š      [5, 5, 0, 5],\n+â”Š  â”Š 7â”Š      [0, 5, 0, 0]\n+â”Š  â”Š 8â”Š    );\n+â”Š  â”Š 9â”Š  });\n+â”Š  â”Š10â”Š\n+â”Š  â”Š11â”Š  describe(\"hasPoint method\", function() {\n+â”Š  â”Š12â”Š    describe(\"given contained point\", function() {\n+â”Š  â”Š13â”Š      it(\"returns true\", function() {\n+â”Š  â”Š14â”Š        let x = 5;\n+â”Š  â”Š15â”Š        let y = 3;\n+â”Š  â”Š16â”Š        expect(this.polygon.hasPoint(x, y)).toBeTruthy();\n+â”Š  â”Š17â”Š      });\n+â”Š  â”Š18â”Š    });\n+â”Š  â”Š19â”Š\n+â”Š  â”Š20â”Š    describe(\"given outranged point\", function() {\n+â”Š  â”Š21â”Š      it(\"returns false\", function() {\n+â”Š  â”Š22â”Š        let x = 10;\n+â”Š  â”Š23â”Š        let y = 10;\n+â”Š  â”Š24â”Š        expect(this.polygon.hasPoint(x, y)).toBeFalsy();\n+â”Š  â”Š25â”Š      });\n+â”Š  â”Š26â”Š    });\n+â”Š  â”Š27â”Š  });\n+â”Š  â”Š28â”Š\n+â”Š  â”Š29â”Š  describe(\"getLineIntersection method\", function() {\n+â”Š  â”Š30â”Š    describe(\"given intersecting line\", function() {\n+â”Š  â”Š31â”Š      it(\"returns intersection point\", function() {\n+â”Š  â”Š32â”Š        let line = new Engine.Geometry.Line(0, 1, 5, 4);\n+â”Š  â”Š33â”Š\n+â”Š  â”Š34â”Š        expect(this.polygon.getLineIntersection(line)).toEqual([\n+â”Š  â”Š35â”Š          { x: 5, y: 4 },\n+â”Š  â”Š36â”Š          { x: 0, y: 1 }\n+â”Š  â”Š37â”Š        ]);\n+â”Š  â”Š38â”Š      });\n+â”Š  â”Š39â”Š    });\n+â”Š  â”Š40â”Š\n+â”Š  â”Š41â”Š    describe(\"given outranged line\", function() {\n+â”Š  â”Š42â”Š      it(\"returns nothing\", function() {\n+â”Š  â”Š43â”Š        let line = new Engine.Geometry.Line(10, 11, 15, 14);\n+â”Š  â”Š44â”Š\n+â”Š  â”Š45â”Š        expect(this.polygon.getLineIntersection(line)).toBeUndefined();\n+â”Š  â”Š46â”Š      });\n+â”Š  â”Š47â”Š    });\n+â”Š  â”Š48â”Š  });\n+â”Š  â”Š49â”Š\n+â”Š  â”Š50â”Š  describe(\"getCircleIntersection method\", function() {\n+â”Š  â”Š51â”Š    describe(\"given circle with 2 intersection points\", function() {\n+â”Š  â”Š52â”Š      it(\"returns array with intersection points\", function() {\n+â”Š  â”Š53â”Š        let circle = new Engine.Geometry.Circle(0, 0, 2, 0, 2 * Math.PI);\n+â”Š  â”Š54â”Š\n+â”Š  â”Š55â”Š        expect(this.polygon.getCircleIntersection(circle)).toEqual([\n+â”Š  â”Š56â”Š          { x: 2, y: 0 },\n+â”Š  â”Š57â”Š          { x: 0, y: 2 }\n+â”Š  â”Š58â”Š        ]);\n+â”Š  â”Š59â”Š      });\n+â”Š  â”Š60â”Š    });\n+â”Š  â”Š61â”Š\n+â”Š  â”Š62â”Š    describe(\"given circle with 1 intersection points\", function() {\n+â”Š  â”Š63â”Š      it(\"returns array with intersection point\", function() {\n+â”Š  â”Š64â”Š        let circle = new Engine.Geometry.Circle(0, 0, 2, 0, 0.25 * Math.PI);\n+â”Š  â”Š65â”Š\n+â”Š  â”Š66â”Š        expect(this.polygon.getCircleIntersection(circle)).toEqual([\n+â”Š  â”Š67â”Š          { x: 2, y: 0 }\n+â”Š  â”Š68â”Š        ]);\n+â”Š  â”Š69â”Š      });\n+â”Š  â”Š70â”Š    });\n+â”Š  â”Š71â”Š\n+â”Š  â”Š72â”Š    describe(\"given kissing circle\", function() {\n+â”Š  â”Š73â”Š      it(\"returns array with intersection point\", function() {\n+â”Š  â”Š74â”Š        let circle = new Engine.Geometry.Circle(-3, 3, 3, 0, 2 * Math.PI);\n+â”Š  â”Š75â”Š\n+â”Š  â”Š76â”Š        expect(this.polygon.getCircleIntersection(circle)).toEqual([\n+â”Š  â”Š77â”Š          { x: 0, y: 3 }\n+â”Š  â”Š78â”Š        ]);\n+â”Š  â”Š79â”Š      });\n+â”Š  â”Š80â”Š    });\n+â”Š  â”Š81â”Š\n+â”Š  â”Š82â”Š    describe(\"given outer circle\", function() {\n+â”Š  â”Š83â”Š      it(\"returns nothing\", function() {\n+â”Š  â”Š84â”Š        let circle = new Engine.Geometry.Circle(10, 10, 2, 0, 2 * Math.PI);\n+â”Š  â”Š85â”Š        expect(this.polygon.getCircleIntersection(circle)).toBeUndefined();\n+â”Š  â”Š86â”Š      });\n+â”Š  â”Š87â”Š    });\n+â”Š  â”Š88â”Š\n+â”Š  â”Š89â”Š    describe(\"given inner circle\", function() {\n+â”Š  â”Š90â”Š      it(\"nothing\", function() {\n+â”Š  â”Š91â”Š        let circle = new Engine.Geometry.Circle(2.5, 2.5, 2, 0, 2 * Math.PI);\n+â”Š  â”Š92â”Š        expect(this.polygon.getCircleIntersection(circle)).toBeUndefined();\n+â”Š  â”Š93â”Š      });\n+â”Š  â”Š94â”Š    });\n+â”Š  â”Š95â”Š  });\n+â”Š  â”Š96â”Š});ðŸš«â†µ\n```\n\n##### Changed views&#x2F;spec_runner.html\n```diff\n@@ -20,10 +20,12 @@\n â”Š20â”Š20â”Š    <script type=\"text/javascript\" src=\"scripts/namespaces.js\"></script>\n â”Š21â”Š21â”Š    <script type=\"text/javascript\" src=\"scripts/engine/geometry/line.js\"></script>\n â”Š22â”Š22â”Š    <script type=\"text/javascript\" src=\"scripts/engine/geometry/circle.js\"></script>\n+â”Š  â”Š23â”Š    <script type=\"text/javascript\" src=\"scripts/engine/geometry/polygon.js\"></script>\n â”Š23â”Š24â”Š\n â”Š24â”Š25â”Š    <!-- Specs -->\n â”Š25â”Š26â”Š    <script type=\"text/javascript\" src=\"scripts/specs/engine/geometry/line.js\"></script>\n â”Š26â”Š27â”Š    <script type=\"text/javascript\" src=\"scripts/specs/engine/geometry/circle.js\"></script>\n+â”Š  â”Š28â”Š    <script type=\"text/javascript\" src=\"scripts/specs/engine/geometry/polygon.js\"></script>\n â”Š27â”Š29â”Š  </head>\n â”Š28â”Š30â”Š\n â”Š29â”Š31â”Š  <body>\n```\n\n[}]: #\n\nAt last, all the necessary geometry shapes are implemented and ready to use. We will now focus on the snake itself. Since our game can potentially have infinite number of entities, not necessarily just a snake, we will add the a new module under the `Game` namespace called `Entities`:\n\n[{]: <helper> (diffStep 5.13)\n\n#### [Step 5.13: Add &#x27;Entities&#x27; module to &#x27;Game&#x27; namespace](https://github.com/DAB0mB/radial-snake/commit/a0bed8c)\n\n##### Changed resources&#x2F;scripts&#x2F;namespaces.js\n```diff\n@@ -1,4 +1,5 @@\n â”Š1â”Š1â”ŠGame = {\n+â”Š â”Š2â”Š  Entities: {},\n â”Š2â”Š3â”Š  Screens: {}\n â”Š3â”Š4â”Š};\n```\n\n[}]: #\n\nAnd now we can add the `Snake` class:\n\n[{]: <helper> (diffStep 5.14)\n\n#### [Step 5.14: Create &#x27;Snake&#x27; class](https://github.com/DAB0mB/radial-snake/commit/b938ba7)\n\n##### Added resources&#x2F;scripts&#x2F;game&#x2F;entities&#x2F;snake.js\n```diff\n@@ -0,0 +1,234 @@\n+â”Š   â”Š  1â”ŠGame.Entities.Snake = class Snake {\n+â”Š   â”Š  2â”Š  // Represents a snake data-structure which will eventually appear on screen.\n+â”Š   â”Š  3â”Š  // All the properties provided to the constructor are the initial values of\n+â”Š   â”Š  4â”Š  // the snake\n+â”Š   â”Š  5â”Š  constructor(x, y, r, rad, v, color, keyStates, options) {\n+â”Š   â”Š  6â”Š    this.x = x;\n+â”Š   â”Š  7â”Š    this.y = y;\n+â”Š   â”Š  8â”Š    this.r = r;\n+â”Š   â”Š  9â”Š    this.rad = rad;\n+â”Š   â”Š 10â”Š    this.v = v;\n+â”Š   â”Š 11â”Š    this.color = color;\n+â”Š   â”Š 12â”Š    this.keyStates = keyStates;\n+â”Š   â”Š 13â”Š    // A snake is made out of many geometry shapes\n+â”Š   â”Š 14â”Š    this.shapes = [];\n+â”Š   â”Š 15â”Š    // A snake starts with a line\n+â”Š   â”Š 16â”Š    this.currentShape = new Engine.Geometry.Line(x, y, x, y);\n+â”Š   â”Š 17â”Š    this.shapes.push(this.currentShape);\n+â”Š   â”Š 18â”Š    // A score can be provided in case we want to reserve previous scores from\n+â”Š   â”Š 19â”Š    // recent matches\n+â”Š   â”Š 20â”Š    this.score = options.score || 0;\n+â”Š   â”Š 21â”Š\n+â”Š   â”Š 22â”Š    // Custom keys can be specified\n+â”Š   â”Š 23â”Š    if (options.keys && options.keys) {\n+â”Š   â”Š 24â”Š      this.leftKey = options.keys.left;\n+â”Š   â”Š 25â”Š      this.rightKey = options.keys.right;\n+â”Š   â”Š 26â”Š    }\n+â”Š   â”Š 27â”Š    // Left and right arrow keys will be used by default\n+â”Š   â”Š 28â”Š    else {\n+â”Š   â”Š 29â”Š      this.leftKey = 37; // Left arrow\n+â”Š   â”Š 30â”Š      this.rightKey = 39; // Right arrow\n+â”Š   â”Š 31â”Š    }\n+â”Š   â”Š 32â”Š  }\n+â”Š   â”Š 33â”Š\n+â”Š   â”Š 34â”Š  draw(context) {\n+â”Š   â”Š 35â”Š    // Draw all shapes in the shapes array\n+â”Š   â”Š 36â”Š    this.shapes.forEach(shape => {\n+â”Š   â”Š 37â”Š      context.save();\n+â”Š   â”Š 38â”Š      context.strokeStyle = this.color;\n+â”Š   â”Š 39â”Š      context.lineWidth = 3;\n+â”Š   â”Š 40â”Š      context.beginPath();\n+â”Š   â”Š 41â”Š\n+â”Š   â”Š 42â”Š      // Each shape has its own unique drawing method\n+â”Š   â”Š 43â”Š      shape.draw(context);\n+â”Š   â”Š 44â”Š\n+â”Š   â”Š 45â”Š      context.stroke();\n+â”Š   â”Š 46â”Š      context.restore();\n+â”Š   â”Š 47â”Š    });\n+â”Š   â”Š 48â”Š  }\n+â”Š   â”Š 49â”Š\n+â”Š   â”Š 50â”Š  update(span, width, height) {\n+â”Š   â”Š 51â”Š    // Progress made based on elapsed time and velocity\n+â”Š   â”Š 52â”Š    let step = (this.v * span) / 1000;\n+â”Š   â”Š 53â”Š\n+â”Š   â”Š 54â”Š    this.updateShapes(step, width, height);\n+â”Š   â”Š 55â”Š    this.cycleThrough(step, width, height);\n+â”Š   â”Š 56â”Š  }\n+â”Š   â”Š 57â”Š\n+â”Š   â”Š 58â”Š  // Updates shapes array based on progress made\n+â”Š   â”Š 59â”Š  updateShapes(step, width, height, options = {}) {\n+â”Š   â”Š 60â”Š    this.updateCurrentShape(step, options);\n+â”Š   â”Š 61â”Š    this.updateDirection(step, options);\n+â”Š   â”Š 62â”Š  }\n+â”Š   â”Š 63â”Š\n+â”Š   â”Š 64â”Š  // Updates current shape\n+â”Š   â”Š 65â”Š  updateCurrentShape(step, options) {\n+â”Š   â”Š 66â”Š    if (this.currentShape instanceof Engine.Geometry.Line)\n+â”Š   â”Š 67â”Š      return this.updateCurrentLine(options);\n+â”Š   â”Š 68â”Š    if (this.currentShape instanceof Engine.Geometry.Circle)\n+â”Š   â”Š 69â”Š      return this.updateCurrentCircle(options);\n+â”Š   â”Š 70â”Š  }\n+â”Š   â”Š 71â”Š\n+â”Š   â”Š 72â”Š  // Updates current shape in case it is a line\n+â”Š   â”Š 73â”Š  updateCurrentLine(options) {\n+â”Š   â”Š 74â”Š    let lastX = options.lastX || this.x;\n+â”Š   â”Š 75â”Š    let lastY = options.lastY || this.y;\n+â”Š   â”Š 76â”Š    this.x = options.x || this.currentShape.x2;\n+â”Š   â”Š 77â”Š    this.y = options.y || this.currentShape.y2;\n+â”Š   â”Š 78â”Š    this.lastBit = new Engine.Geometry.Line(lastX, lastY, this.x, this.y);\n+â”Š   â”Š 79â”Š  }\n+â”Š   â”Š 80â”Š\n+â”Š   â”Š 81â”Š  // Updates current shape in case it is a circle\n+â”Š   â”Š 82â”Š  updateCurrentCircle(options) {\n+â”Š   â”Š 83â”Š    let lastX = options.lastX || this.currentShape.x;\n+â”Š   â”Š 84â”Š    let lastY = options.lastY || this.currentShape.y;\n+â”Š   â”Š 85â”Š    let lastR = options.lastR || this.currentShape.r;\n+â”Š   â”Š 86â”Š\n+â”Š   â”Š 87â”Š    // Update logic for left rotation\n+â”Š   â”Š 88â”Š    if (this.direction == \"left\") {\n+â”Š   â”Š 89â”Š      let lastRad = this.rad + (0.5 * Math.PI);\n+â”Š   â”Š 90â”Š      let currentShapePoint = this.currentShape.getPoint(this.currentShape.rad1);\n+â”Š   â”Š 91â”Š      this.x = options.x || currentShapePoint.x;\n+â”Š   â”Š 92â”Š      this.y = options.y || currentShapePoint.y;\n+â”Š   â”Š 93â”Š      this.rad = this.currentShape.rad1 - (0.5 * Math.PI);\n+â”Š   â”Š 94â”Š      this.lastBit = new Engine.Geometry.Circle(lastX, lastY, lastR, this.currentShape.rad1, lastRad);\n+â”Š   â”Š 95â”Š    }\n+â”Š   â”Š 96â”Š    // Update logic for right rotation\n+â”Š   â”Š 97â”Š    else {\n+â”Š   â”Š 98â”Š      let lastRad = this.rad - (0.5 * Math.PI);\n+â”Š   â”Š 99â”Š      let currentShapePoint = this.currentShape.getPoint(this.currentShape.rad2);\n+â”Š   â”Š100â”Š      this.x = options.x || currentShapePoint.x;\n+â”Š   â”Š101â”Š      this.y = options.y || currentShapePoint.y;\n+â”Š   â”Š102â”Š      this.rad = this.currentShape.rad2 + (0.5 * Math.PI);\n+â”Š   â”Š103â”Š      this.lastBit = new Engine.Geometry.Circle(lastX, lastY, lastR, lastRad, this.currentShape.rad2);\n+â”Š   â”Š104â”Š    }\n+â”Š   â”Š105â”Š  }\n+â”Š   â”Š106â”Š\n+â”Š   â”Š107â”Š  updateDirection(step, options) {\n+â”Š   â”Š108â”Š    // Update the direction based on pressed key\n+â”Š   â”Š109â”Š    if (this.keyStates.get(this.leftKey))\n+â”Š   â”Š110â”Š      var direction = \"left\";\n+â”Š   â”Š111â”Š    else if (this.keyStates.get(this.rightKey))\n+â”Š   â”Š112â”Š      var direction = \"right\";\n+â”Š   â”Š113â”Š\n+â”Š   â”Š114â”Š    this.changeDirection(step, direction, options);\n+â”Š   â”Š115â”Š    this.continueDirection(step, direction, options);\n+â”Š   â”Š116â”Š  }\n+â”Š   â”Š117â”Š\n+â”Š   â”Š118â”Š  // Change the recent shape type according to the given direction\n+â”Š   â”Š119â”Š  changeDirection(step, direction, options) {\n+â”Š   â”Š120â”Š    // If there is no change in direction, abort, unless we force it\n+â”Š   â”Š121â”Š    if (direction == this.direction && !options.force) return;\n+â”Š   â”Š122â”Š\n+â”Š   â”Š123â”Š    this.direction = direction;\n+â”Š   â”Š124â”Š\n+â”Š   â”Š125â”Š    // This will push a new shape with new properties, based on the direction\n+â”Š   â”Š126â”Š    switch (direction) {\n+â”Š   â”Š127â”Š      case \"left\":\n+â”Š   â”Š128â”Š        var angle = this.rad - (0.5 * Math.PI);\n+â”Š   â”Š129â”Š        var rad = this.rad + (0.5 * Math.PI);\n+â”Š   â”Š130â”Š        var x = this.x + (this.r * Math.cos(angle));\n+â”Š   â”Š131â”Š        var y = this.y + (this.r * Math.sin(angle));\n+â”Š   â”Š132â”Š        this.currentShape = new Engine.Geometry.Circle(x, y, this.r, rad, rad);\n+â”Š   â”Š133â”Š        break;\n+â”Š   â”Š134â”Š      case \"right\":\n+â”Š   â”Š135â”Š        angle = this.rad + (0.5 * Math.PI);\n+â”Š   â”Š136â”Š        rad = this.rad - (0.5 * Math.PI);\n+â”Š   â”Š137â”Š        x = this.x + (this.r * Math.cos(angle));\n+â”Š   â”Š138â”Š        y = this.y + (this.r * Math.sin(angle));\n+â”Š   â”Š139â”Š        this.currentShape = new Engine.Geometry.Circle(x, y, this.r, rad, rad);\n+â”Š   â”Š140â”Š        break;\n+â”Š   â”Š141â”Š      default:\n+â”Š   â”Š142â”Š        this.currentShape = new Engine.Geometry.Line(this.x, this.y, this.x, this.y);\n+â”Š   â”Š143â”Š    }\n+â”Š   â”Š144â”Š\n+â”Š   â”Š145â”Š    this.shapes.push(this.currentShape);\n+â”Š   â”Š146â”Š  }\n+â”Š   â”Š147â”Š\n+â”Š   â”Š148â”Š  // Extend the recent shape based on progress made\n+â”Š   â”Š149â”Š  continueDirection(step, direction) {\n+â”Š   â”Š150â”Š    switch (direction) {\n+â”Š   â”Š151â”Š      case \"left\":\n+â”Š   â”Š152â”Š        this.currentShape.rad1 -= step / this.r;\n+â”Š   â”Š153â”Š        break;\n+â”Š   â”Š154â”Š      case \"right\":\n+â”Š   â”Š155â”Š        this.currentShape.rad2 += step / this.r;\n+â”Š   â”Š156â”Š        break;\n+â”Š   â”Š157â”Š      default:\n+â”Š   â”Š158â”Š        this.currentShape.x2 += step * Math.cos(this.rad);\n+â”Š   â”Š159â”Š        this.currentShape.y2 += step * Math.sin(this.rad);\n+â”Š   â”Š160â”Š    }\n+â”Š   â”Š161â”Š  }\n+â”Š   â”Š162â”Š\n+â”Š   â”Š163â”Š  // Handles case where snake is out limits and we need to render it from\n+â”Š   â”Š164â”Š  // the other side of the canvas\n+â”Š   â”Š165â”Š  cycleThrough(step, width, height) {\n+â”Š   â”Š166â”Š    let intersectionPoint = this.getCanvasIntersection(width, height);\n+â”Š   â”Š167â”Š\n+â”Š   â”Š168â”Š    if (!intersectionPoint) return;\n+â”Š   â”Š169â”Š\n+â”Š   â”Š170â”Š    intersectionPoint = intersectionPoint[0];\n+â”Š   â”Š171â”Š\n+â”Š   â”Š172â”Š    // Re-calculate position based on canvas bounds\n+â”Š   â”Š173â”Š    if (intersectionPoint.x % width == 0)\n+â”Š   â”Š174â”Š      this.x = Utils.mod(this.x - width, width);\n+â”Š   â”Š175â”Š    if (intersectionPoint.y % height == 0)\n+â”Š   â”Š176â”Š      this.y = Utils.mod(this.y - height, height);\n+â”Š   â”Š177â”Š\n+â”Š   â”Š178â”Š    // Update shapes again based on custom properties\n+â”Š   â”Š179â”Š    this.updateShapes(step, width, height, {\n+â”Š   â”Š180â”Š      force: true,\n+â”Š   â”Š181â”Š      lastX: this.x,\n+â”Š   â”Š182â”Š      lastY: this.y,\n+â”Š   â”Š183â”Š      x: this.x,\n+â”Š   â”Š184â”Š      y: this.y\n+â”Š   â”Š185â”Š    });\n+â”Š   â”Š186â”Š  }\n+â”Š   â”Š187â”Š\n+â”Š   â”Š188â”Š  // Gets intersection points between last bit and own shapes\n+â”Š   â”Š189â”Š  getSelfIntersection() {\n+â”Š   â”Š190â”Š    if (this.currentShape instanceof Engine.Geometry.Circle &&\n+â”Š   â”Š191â”Š       Math.abs(this.currentShape.rad1 - this.currentShape.rad2) >= 2 * Math.PI) {\n+â”Š   â”Š192â”Š      if (this.direction == \"left\")\n+â”Š   â”Š193â”Š        var rad = this.currentShape.rad1;\n+â”Š   â”Š194â”Š      else\n+â”Š   â”Š195â”Š        var rad = this.currentShape.rad2;\n+â”Š   â”Š196â”Š\n+â”Š   â”Š197â”Š      return this.currentShape.getPoint(rad);\n+â”Š   â”Š198â”Š    }\n+â”Š   â”Š199â”Š\n+â”Š   â”Š200â”Š    let result;\n+â”Š   â”Š201â”Š\n+â”Š   â”Š202â”Š    this.shapes.slice(0, -2).some(shape =>\n+â”Š   â”Š203â”Š      result = this.lastBit.getIntersection(shape)\n+â”Š   â”Š204â”Š    );\n+â”Š   â”Š205â”Š\n+â”Š   â”Š206â”Š    return result;\n+â”Š   â”Š207â”Š  }\n+â”Š   â”Š208â”Š\n+â”Š   â”Š209â”Š  // Returns intersection points between snakes\n+â”Š   â”Š210â”Š  getSnakeIntersection(snake) {\n+â”Š   â”Š211â”Š    let result;\n+â”Š   â”Š212â”Š\n+â”Š   â”Š213â”Š    snake.shapes.some(shape =>\n+â”Š   â”Š214â”Š      // Only last bit is relevant, if we reached this point it means that\n+â”Š   â”Š215â”Š      // previous intersection will definitely fail\n+â”Š   â”Š216â”Š      result = this.lastBit.getIntersection(shape)\n+â”Š   â”Š217â”Š    );\n+â”Š   â”Š218â”Š\n+â”Š   â”Š219â”Š    return result;\n+â”Š   â”Š220â”Š  }\n+â”Š   â”Š221â”Š\n+â”Š   â”Š222â”Š  // Returns intersection points between snake and canvas\n+â”Š   â”Š223â”Š  getCanvasIntersection(width, height) {\n+â”Š   â”Š224â”Š    // Canvas polygon\n+â”Š   â”Š225â”Š    let canvasPolygon = new Engine.Geometry.Polygon(\n+â”Š   â”Š226â”Š      [0, 0, width, 0],\n+â”Š   â”Š227â”Š      [width, 0, width, height],\n+â”Š   â”Š228â”Š      [width, height, 0, height],\n+â”Š   â”Š229â”Š      [0, height, 0, 0]\n+â”Š   â”Š230â”Š    );\n+â”Š   â”Š231â”Š\n+â”Š   â”Š232â”Š    return canvasPolygon.getIntersection(this.lastBit);\n+â”Š   â”Š233â”Š  }\n+â”Š   â”Š234â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -22,6 +22,7 @@\n â”Š22â”Š22â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/screen.js\"></script>\n â”Š23â”Š23â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/assets_loader.js\"></script>\n â”Š24â”Š24â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n+â”Š  â”Š25â”Š    <script type=\"text/javascript\" src=\"/scripts/game/entities/snake.js\"></script>\n â”Š25â”Š26â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/menu/index.js\"></script>\n â”Š26â”Š27â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/splash/index.js\"></script>\n â”Š27â”Š28â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n```\n\n[}]: #\n\nThis class is titled with most complexity out of everything we did so far in this step. You can follow the code accompanied by comments regard it, but I'd also like to explain the key concepts. As said earlier, the `Snake` is simply made out of shapes; In this case - lines and circles.\n\nThe `draw` method just goes through this array and draws whatever shape it's currently looping through. Regardless of its type, every shape is provided with a `draw` method of its own, all shapes share the same interface, therefore we can just draw them regularly and the snake should be drawn automatically.\n\nThe `update` method updates the last bit only according to its type, the time elapsed and the speed of the snake. For example, the last bit of the snake is a line, and 5 seconds have passed at a speed of 5 meters per second, our line should be extended by 5 meters long. Same principle applies to circle extension only based on radians. The last bit's type might be changed according to the current input; e.g. if the `right` key is held the last bit would turn into a circle, and once released it would turn into a straight line.\n\nNote that besides shapes extension, collision detection should also be made. The embedded is the collision detection between the snake and the canvas, which means that any time the snake collides with the canvas's boundaries the last bit should be redrawn from the opposite side of the canvas. In addition, we've implemented intersection methods for self collision detection and collision detection between rivals, which should be used externally by the hosting screen.\n\nIn the next step we will be implementing the game screen where we will make use of the `Snake` class we've just created, and see how it works in action."
          },
          {
            "manualTitle": "Step 6: Creating a complex game screen with multiple layers",
            "stepRevision": "c27bb0d7806aab70ec489ccd9bbff182d1053dda",
            "manualView": "![snake-demo-game-small](https://cloud.githubusercontent.com/assets/7648874/21074124/8b7cd724-bed7-11e6-9f91-2a211630ac78.gif)\n\nIn this step we will be using the `Snake` class we've just created in the previous step to form the actual game screen - called the `Play` screen. The play screen is a complex screen made out multiple layers as following:\n\n- **`Ready` layer** - Displays a message at the beginning of each match.\n- **`Snake` layer** - Displays the the competitors' snakes.\n- **`Score` layer** - Displays the score board.\n- **`Win` layer** - Displays the winner at the end of each match.\n\nAs we go further with this step, we will give a deeper explanation about each layer and how they interact with each other; As for let's start with the `Play` screen's basis. Regardless of what the `Play` screen should contain at the final result, we want to have the ability to abort the match whenever we press the `Escape` key, therefore, the initial implementation should look like this:\n\n[{]: <helper> (diffStep 6.1)\n\n#### [Step 6.1: Create &#x27;Play&#x27; screen](https://github.com/DAB0mB/radial-snake/commit/e17a45f)\n\n##### Added resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;play&#x2F;index.js\n```diff\n@@ -0,0 +1,14 @@\n+â”Š  â”Š 1â”ŠGame.Screens.Play = class Play extends Engine.Screen {\n+â”Š  â”Š 2â”Š  get events() {\n+â”Š  â”Š 3â”Š    return {\n+â”Š  â”Š 4â”Š      \"keydown\": \"onKeyDown\"\n+â”Š  â”Š 5â”Š    }\n+â”Š  â”Š 6â”Š  }\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Š  onKeyDown() {\n+â”Š  â”Š 9â”Š    // Once escape is pressed, return to main menu screen\n+â”Š  â”Š10â”Š    if (this.keyStates.get(27)) {\n+â”Š  â”Š11â”Š      this.game.changeScreen(Game.Screens.Menu);\n+â”Š  â”Š12â”Š    }\n+â”Š  â”Š13â”Š  }\n+â”Š  â”Š14â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -23,6 +23,7 @@\n â”Š23â”Š23â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/assets_loader.js\"></script>\n â”Š24â”Š24â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š25â”Š25â”Š    <script type=\"text/javascript\" src=\"/scripts/game/entities/snake.js\"></script>\n+â”Š  â”Š26â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/index.js\"></script>\n â”Š26â”Š27â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/menu/index.js\"></script>\n â”Š27â”Š28â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/splash/index.js\"></script>\n â”Š28â”Š29â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n```\n\n[}]: #\n\nNow that we have the `Play` screen, we need to hook it to the `Menu` screen, so whenever we press a key, we will be proceeded to it:\n\n[{]: <helper> (diffStep 6.2)\n\n#### [Step 6.2: Hook &#x27;Play&#x27; screen to &#x27;menu&#x27; screen](https://github.com/DAB0mB/radial-snake/commit/495b9ee)\n\n##### Changed resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;menu&#x2F;index.js\n```diff\n@@ -1,4 +1,10 @@\n â”Š 1â”Š 1â”ŠGame.Screens.Menu = class Menu extends Engine.Screen {\n+â”Š  â”Š 2â”Š  get events() {\n+â”Š  â”Š 3â”Š    return {\n+â”Š  â”Š 4â”Š      \"keydown\": \"onKeyDown\"\n+â”Š  â”Š 5â”Š    }\n+â”Š  â”Š 6â”Š  }\n+â”Š  â”Š 7â”Š\n â”Š 2â”Š 8â”Š  initialize() {\n â”Š 3â”Š 9â”Š    // Initialize snake logo sprite\n â”Š 4â”Š10â”Š    this.logoSprite = new Engine.Sprite(this.assets.logoTexture);\n```\n```diff\n@@ -40,10 +46,18 @@\n â”Š40â”Š46â”Š  }\n â”Š41â”Š47â”Š\n â”Š42â”Š48â”Š  update(span) {\n-â”Š43â”Š  â”Š    this.instructionsAnim.update(span);\n+â”Š  â”Š49â”Š    // On key press, proceed to play screen\n+â”Š  â”Š50â”Š    if (this.keyPressed) {\n+â”Š  â”Š51â”Š      this.game.changeScreen(Game.Screens.Play);\n+â”Š  â”Š52â”Š    }\n+â”Š  â”Š53â”Š    // Else, just update animation\n+â”Š  â”Š54â”Š    else {\n+â”Š  â”Š55â”Š      this.instructionsAnim.update(span);\n+â”Š  â”Š56â”Š    }\n â”Š44â”Š57â”Š  }\n â”Š45â”Š58â”Š\n-â”Š46â”Š  â”Š  update(span) {\n-â”Š47â”Š  â”Š    this.instructionsAnim.update(span);\n+â”Š  â”Š59â”Š  // Register key press\n+â”Š  â”Š60â”Š  onKeyDown(e) {\n+â”Š  â”Š61â”Š    this.keyPressed = true;\n â”Š48â”Š62â”Š  }\n â”Š49â”Š63â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nBy now there shouldn't be anything special. Once you're at the main menu, just press a key as instructed, and you shall see a black screen, which is actually the `Play` screen we've just created; And once you'll press the `Escape` key, you should be receded to the main menu.\n\nThe next stage would be displaying a `Ready` message on the screen, and whenever a key is pressed, the message should fade away using a key-frame animation, and the match should start in the background:\n\n[{]: <helper> (diffStep 6.3)\n\n#### [Step 6.3: Create &#x27;Ready&#x27; layer](https://github.com/DAB0mB/radial-snake/commit/551962d)\n\n##### Added resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;play&#x2F;ready.js\n```diff\n@@ -0,0 +1,59 @@\n+â”Š  â”Š 1â”ŠGame.Screens.Play.Ready = class Ready extends Engine.Layer {\n+â”Š  â”Š 2â”Š  get events() {\n+â”Š  â”Š 3â”Š    return {\n+â”Š  â”Š 4â”Š      \"keydown\": \"onKeyDown\"\n+â”Š  â”Š 5â”Š    };\n+â”Š  â”Š 6â”Š  }\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Š  constructor(screen, snakes) {\n+â”Š  â”Š 9â”Š    super(screen);\n+â”Š  â”Š10â”Š\n+â”Š  â”Š11â”Š    this.snakes = snakes;\n+â”Š  â”Š12â”Š\n+â”Š  â”Š13â”Š    // Create \"ready\" sprite and set its properties\n+â”Š  â”Š14â”Š    let readyTexture = this.assets.minecraftiaFont.createTexture(\"Ready\");\n+â”Š  â”Š15â”Š    let readySprite = new Engine.Sprite(readyTexture);\n+â”Š  â”Š16â”Š    readySprite.align = \"center\";\n+â”Š  â”Š17â”Š    readySprite.setPercentage(\"width\", this.width, 15, \"height\");\n+â”Š  â”Š18â”Š\n+â”Š  â”Š19â”Š    // Create fade out animation for \"ready\" sprite\n+â”Š  â”Š20â”Š    this.readyAnim = new Engine.Animations.Keyframe(readySprite, [\n+â”Š  â”Š21â”Š      {\n+â”Š  â”Š22â”Š        x: this.width / 2,\n+â”Š  â”Š23â”Š        y: this.height / 2,\n+â”Š  â”Š24â”Š        opacity: 1,\n+â”Š  â”Š25â”Š        frame: 0\n+â”Š  â”Š26â”Š      },\n+â”Š  â”Š27â”Š      {\n+â”Š  â”Š28â”Š        y: this.height / 3,\n+â”Š  â”Š29â”Š        opacity: 0,\n+â”Š  â”Š30â”Š        frame: 700\n+â”Š  â”Š31â”Š      }\n+â”Š  â”Š32â”Š    ]);\n+â”Š  â”Š33â”Š  }\n+â”Š  â”Š34â”Š\n+â”Š  â”Š35â”Š  draw(context) {\n+â”Š  â”Š36â”Š    this.readyAnim.draw(context);\n+â”Š  â”Š37â”Š  }\n+â”Š  â”Š38â”Š\n+â”Š  â”Š39â”Š  update(span) {\n+â”Š  â”Š40â”Š    if (!this.ready) return;\n+â”Š  â”Š41â”Š\n+â”Š  â”Š42â”Š    if (this.readyAnim.playing) {\n+â”Š  â”Š43â”Š      this.readyAnim.update(span);\n+â”Š  â”Š44â”Š    }\n+â”Š  â”Š45â”Š    // Once animation is finished, dispose layer\n+â”Š  â”Š46â”Š    else {\n+â”Š  â”Š47â”Š      this.screen.removeLayer(this);\n+â”Š  â”Š48â”Š    }\n+â”Š  â”Š49â”Š  }\n+â”Š  â”Š50â”Š\n+â”Š  â”Š51â”Š  onKeyDown() {\n+â”Š  â”Š52â”Š    // One time event\n+â”Š  â”Š53â”Š    this.disposeEventListeners()\n+â”Š  â”Š54â”Š\n+â”Š  â”Š55â”Š    // This will start playing the animation\n+â”Š  â”Š56â”Š    this.ready = true;\n+â”Š  â”Š57â”Š    this.readyAnim.play();\n+â”Š  â”Š58â”Š  }\n+â”Š  â”Š59â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -24,6 +24,7 @@\n â”Š24â”Š24â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š25â”Š25â”Š    <script type=\"text/javascript\" src=\"/scripts/game/entities/snake.js\"></script>\n â”Š26â”Š26â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/index.js\"></script>\n+â”Š  â”Š27â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/ready.js\"></script>\n â”Š27â”Š28â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/menu/index.js\"></script>\n â”Š28â”Š29â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/splash/index.js\"></script>\n â”Š29â”Š30â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n```\n\n[}]: #\n\nIn order to hook the `Ready` layer to the `Play` screen, we will just push a new instance of it to the layers stack, using the screen's `appendLayer` method. Note that the order of the layer is super critic! Since if we push a new layer it means it will be drawn on top of any previous layer. To \"shift\" a layer to the layers stack, we can simply use the `prependLayer` method instead. Without further due, this is how our hook should look like:\n\n[{]: <helper> (diffStep 6.4)\n\n#### [Step 6.4: Hook &#x27;Ready&#x27; layer to &#x27;Play&#x27; screen](https://github.com/DAB0mB/radial-snake/commit/b461464)\n\n##### Changed resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;play&#x2F;index.js\n```diff\n@@ -5,6 +5,11 @@\n â”Š 5â”Š 5â”Š    }\n â”Š 6â”Š 6â”Š  }\n â”Š 7â”Š 7â”Š\n+â”Š  â”Š 8â”Š  // The ready screen will be the initial screen\n+â”Š  â”Š 9â”Š  initialize(game, snakes) {\n+â”Š  â”Š10â”Š    this.appendLayer(Game.Screens.Play.Ready, snakes);\n+â”Š  â”Š11â”Š  }\n+â”Š  â”Š12â”Š\n â”Š 8â”Š13â”Š  onKeyDown() {\n â”Š 9â”Š14â”Š    // Once escape is pressed, return to main menu screen\n â”Š10â”Š15â”Š    if (this.keyStates.get(27)) {\n```\n\n[}]: #\n\nNow if you'll launch the game and start a new match, you should see a white `Ready` message in the middle of the screen. Up next, would be the `Snake` layer, which will simply initialize 2 new `Snake` instances, and take care of drawing and updating them:\n\n[{]: <helper> (diffStep 6.5)\n\n#### [Step 6.5: Create &#x27;snake&#x27; layer](https://github.com/DAB0mB/radial-snake/commit/a36d7f2)\n\n##### Added resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;play&#x2F;snake.js\n```diff\n@@ -0,0 +1,79 @@\n+â”Š  â”Š 1â”ŠGame.Screens.Play.Snake = class Snake extends Engine.Layer {\n+â”Š  â”Š 2â”Š  constructor(screen, snakes = []) {\n+â”Š  â”Š 3â”Š    super(screen);\n+â”Š  â”Š 4â”Š\n+â”Š  â”Š 5â”Š    // Red snake\n+â”Š  â”Š 6â”Š    this.snakes = [\n+â”Š  â”Š 7â”Š      new Game.Entities.Snake(\n+â”Š  â”Š 8â”Š        this.width / 4,\n+â”Š  â”Š 9â”Š        this.height / 4,\n+â”Š  â”Š10â”Š        50,\n+â”Š  â”Š11â”Š        Math.PI / 4,\n+â”Š  â”Š12â”Š        100,\n+â”Š  â”Š13â”Š        \"FireBrick\",\n+â”Š  â”Š14â”Š        this.keyStates,\n+â”Š  â”Š15â”Š        {\n+â”Š  â”Š16â”Š          // Use score from previous matches\n+â”Š  â”Š17â”Š          score: snakes[0] && snakes[0].score,\n+â”Š  â”Š18â”Š          keys: {\n+â”Š  â”Š19â”Š            left: 37, // Left key\n+â”Š  â”Š20â”Š            right: 39 // RIght key\n+â”Š  â”Š21â”Š        }\n+â”Š  â”Š22â”Š      }),\n+â”Š  â”Š23â”Š\n+â”Š  â”Š24â”Š      // Blue snake\n+â”Š  â”Š25â”Š      new Game.Entities.Snake(\n+â”Š  â”Š26â”Š        (this.width / 4) * 3,\n+â”Š  â”Š27â”Š        (this.height / 4) * 3,\n+â”Š  â”Š28â”Š        50,\n+â”Š  â”Š29â”Š        (-Math.PI / 4) * 3,\n+â”Š  â”Š30â”Š        100,\n+â”Š  â”Š31â”Š        \"DodgerBlue\",\n+â”Š  â”Š32â”Š        this.keyStates,\n+â”Š  â”Š33â”Š        {\n+â”Š  â”Š34â”Š          score: snakes[1] && snakes[1].score,\n+â”Š  â”Š35â”Š          keys: {\n+â”Š  â”Š36â”Š            left: 65, // 'a' key\n+â”Š  â”Š37â”Š            right: 68 // 'b' key\n+â”Š  â”Š38â”Š        }\n+â”Š  â”Š39â”Š      })\n+â”Š  â”Š40â”Š    ];\n+â”Š  â”Š41â”Š  }\n+â”Š  â”Š42â”Š\n+â”Š  â”Š43â”Š  draw(context) {\n+â”Š  â”Š44â”Š    // Draw each snake in the snakes array\n+â”Š  â”Š45â”Š    this.snakes.forEach(snake => snake.draw(context));\n+â”Š  â”Š46â”Š  }\n+â”Š  â”Š47â”Š\n+â”Š  â”Š48â”Š  update(span) {\n+â”Š  â”Š49â”Š    if (!this.snakes.length) return;\n+â”Š  â”Š50â”Š\n+â”Š  â”Š51â”Š    // Storing original snakes array for future use, since it might get changed\n+â”Š  â”Š52â”Š    let snakes = this.snakes.slice();\n+â”Š  â”Š53â”Š\n+â”Š  â”Š54â”Š    snakes.forEach((snake, index) => {\n+â”Š  â”Š55â”Š      snake.update(span, this.width, this.height);\n+â”Š  â”Š56â”Š      // Disqualify if intersected with self\n+â”Š  â”Š57â”Š      if (snake.getSelfIntersection()) return this.snakes.splice(index, 1);\n+â”Š  â”Š58â”Š\n+â”Š  â”Š59â”Š      snakes.forEach((opponent) => {\n+â”Š  â”Š60â”Š        // Don't scan for intersection with self, obviously this will always be true\n+â”Š  â”Š61â”Š        if (opponent === snake) return;\n+â”Š  â”Š62â”Š        // Disqualify if intersected with opponent\n+â”Š  â”Š63â”Š        if (snake.getSnakeIntersection(opponent)) this.snakes.splice(index, 1);\n+â”Š  â”Š64â”Š      });\n+â”Š  â”Š65â”Š    });\n+â”Š  â”Š66â”Š\n+â”Š  â”Š67â”Š    // There can be only one winner, or a tie (very rare, most likely not to happen)\n+â”Š  â”Š68â”Š    // If the match is already finished, skip the next steps since they are not relevant\n+â”Š  â”Š69â”Š    if (this.snakes.length > 1 || this.matchFinished) return;\n+â”Š  â”Š70â”Š\n+â”Š  â”Š71â”Š    // The winner is the \"last snake standing\"\n+â”Š  â”Š72â”Š    let winner = this.snakes[0];\n+â”Š  â”Š73â”Š    // If this is not a tie, which is a very rare case, increase the winner's score\n+â”Š  â”Š74â”Š    if (winner) winner.score++;\n+â”Š  â”Š75â”Š\n+â”Š  â”Š76â”Š    // Indicates whether we should update the score counter or not\n+â”Š  â”Š77â”Š    this.matchFinished = true;\n+â”Š  â”Š78â”Š  }\n+â”Š  â”Š79â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -24,6 +24,7 @@\n â”Š24â”Š24â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š25â”Š25â”Š    <script type=\"text/javascript\" src=\"/scripts/game/entities/snake.js\"></script>\n â”Š26â”Š26â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/index.js\"></script>\n+â”Š  â”Š27â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/snake.js\"></script>\n â”Š27â”Š28â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/ready.js\"></script>\n â”Š28â”Š29â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/menu/index.js\"></script>\n â”Š29â”Š30â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/splash/index.js\"></script>\n```\n\n[}]: #\n\nOnce pressing a key in the `Ready` layer, not only we want to display an animation, but we also want the match to start in the background, thus, we gonna push a new instance of the `Snake` layer we've just created like so:\n\n[{]: <helper> (diffStep 6.6)\n\n#### [Step 6.6: Hook &#x27;snake&#x27; layer to &#x27;ready&#x27; layer](https://github.com/DAB0mB/radial-snake/commit/982db7b)\n\n##### Changed resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;play&#x2F;ready.js\n```diff\n@@ -55,5 +55,8 @@\n â”Š55â”Š55â”Š    // This will start playing the animation\n â”Š56â”Š56â”Š    this.ready = true;\n â”Š57â”Š57â”Š    this.readyAnim.play();\n+â”Š  â”Š58â”Š\n+â”Š  â”Š59â”Š    // Start the game in the background\n+â”Š  â”Š60â”Š    this.screen.prependLayer(Game.Screens.Play.Snake, this.snakes);\n â”Š58â”Š61â”Š  }\n â”Š59â”Š62â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nNote that the layer is pushed when the animation starts and not once finished; This would give a nice smooth feeling to our game-flow. If you'll test out the game, you would discover that the match is actually playable! The first snake (Red) snake should be controlled by the arrow keys, and the second snake (Blue) should be controlled by the letter keys `a`, `s`, `d` and `w`. So far, the snakes function great, but you can probably tell that whenever a match is finished, it feels a bit dull. There's no indication of winning, and there's no score board to present the score of each competitor, which brings us to the next stage - Implementing the `Score` layer.\n\nThe `Score` layer is a simple layer which takes the 2 snakes as a parameter and displays their scores at the top of the screen:\n\n[{]: <helper> (diffStep 6.7)\n\n#### [Step 6.7: Create &#x27;Score&#x27; layer](https://github.com/DAB0mB/radial-snake/commit/6ec4cac)\n\n##### Added resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;play&#x2F;score.js\n```diff\n@@ -0,0 +1,66 @@\n+â”Š  â”Š 1â”ŠGame.Screens.Play.Score = class Score extends Engine.Layer {\n+â”Š  â”Š 2â”Š  constructor(screen, snakes) {\n+â”Š  â”Š 3â”Š    super(screen);\n+â”Š  â”Š 4â”Š\n+â”Š  â”Š 5â”Š    this.snakes = snakes;\n+â”Š  â”Š 6â”Š    this.scoreSprites = [];\n+â”Š  â”Š 7â”Š    this.scores = [];\n+â”Š  â”Š 8â”Š\n+â”Š  â”Š 9â”Š    // It's important to match indexes to each snake since the number of snakes\n+â”Š  â”Š10â”Š    // can be reduced along the way as we play\n+â”Š  â”Š11â”Š    snakes.forEach((snake, index) => {\n+â”Š  â”Š12â”Š      snake.index = index;\n+â”Š  â”Š13â”Š    });\n+â”Š  â”Š14â”Š  }\n+â”Š  â”Š15â”Š\n+â”Š  â”Š16â”Š  draw(context) {\n+â”Š  â”Š17â”Š    this.scoreSprites.forEach((scoreSprite) => {\n+â”Š  â”Š18â”Š      scoreSprite.draw(context);\n+â”Š  â”Š19â”Š    });\n+â”Š  â”Š20â”Š  }\n+â”Š  â”Š21â”Š\n+â”Š  â”Š22â”Š  update(span) {\n+â”Š  â”Š23â”Š    this.snakes.forEach(snake => {\n+â”Š  â”Š24â”Š      let index = snake.index;\n+â”Š  â”Š25â”Š      if (this.scores[index] == snake.score) return;\n+â”Š  â”Š26â”Š\n+â”Š  â”Š27â”Š      // The sprite might be changed along the way so it's important to recreate it\n+â”Š  â”Š28â”Š      // over and over again. If no change was made the cache will be used by the engine\n+â”Š  â”Š29â”Š      this.scoreSprites[index] = this.createScoreSprite(snake);\n+â”Š  â”Š30â”Š      this.scores[index] = snake.score;\n+â”Š  â”Š31â”Š    });\n+â”Š  â”Š32â”Š  }\n+â”Š  â”Š33â”Š\n+â”Š  â”Š34â”Š  createScoreSprite(snake) {\n+â”Š  â”Š35â”Š    let minecraftiaFont = this.assets.minecraftiaFont;\n+â”Š  â”Š36â”Š    minecraftiaFont.save();\n+â”Š  â”Š37â”Š    minecraftiaFont.color = snake.color;\n+â”Š  â”Š38â”Š\n+â”Š  â”Š39â”Š    // Create a score sprite for the snake\n+â”Š  â”Š40â”Š    let scoreTexture = minecraftiaFont.createTexture(`${snake.score}`, {\n+â”Š  â”Š41â”Š      noOffsets: true,\n+â”Š  â”Š42â”Š      noSpaces: true\n+â”Š  â”Š43â”Š    });\n+â”Š  â”Š44â”Š\n+â”Š  â”Š45â”Š    let scoreSprite = new Engine.Sprite(scoreTexture);\n+â”Š  â”Š46â”Š\n+â”Š  â”Š47â”Š    // Size of score board is dynamic to screen size\n+â”Š  â”Š48â”Š    scoreSprite.setPercentage(\"width\", this.width, 4, \"height\");\n+â”Š  â”Š49â”Š\n+â”Š  â”Š50â”Š    // Set alignment modes.\n+â”Š  â”Š51â”Š    // Once we add more snakes we should add more cases here\n+â”Š  â”Š52â”Š    switch (snake.index) {\n+â”Š  â”Š53â”Š      case 0:\n+â”Š  â”Š54â”Š        scoreSprite.align = \"top-left\";\n+â”Š  â”Š55â”Š        break;\n+â”Š  â”Š56â”Š      case 1:\n+â”Š  â”Š57â”Š        scoreSprite.align = \"top-right\";\n+â”Š  â”Š58â”Š        scoreSprite.x = this.width;\n+â”Š  â”Š59â”Š        break;\n+â”Š  â”Š60â”Š    }\n+â”Š  â”Š61â”Š\n+â”Š  â”Š62â”Š    // Restore the font to its original color\n+â”Š  â”Š63â”Š    minecraftiaFont.restore();\n+â”Š  â”Š64â”Š    return scoreSprite;\n+â”Š  â”Š65â”Š  }\n+â”Š  â”Š66â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -24,6 +24,7 @@\n â”Š24â”Š24â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š25â”Š25â”Š    <script type=\"text/javascript\" src=\"/scripts/game/entities/snake.js\"></script>\n â”Š26â”Š26â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/index.js\"></script>\n+â”Š  â”Š27â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/score.js\"></script>\n â”Š27â”Š28â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/snake.js\"></script>\n â”Š28â”Š29â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/ready.js\"></script>\n â”Š29â”Š30â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/menu/index.js\"></script>\n```\n\n[}]: #\n\n> Note that the current score board is suitable for two players, but can easily be modified to support as much players as you want if done correctly.\n\nThe `Score` board should be appended to the layers stack as soon as the `Snake` layers is initialized, so it would be available to us once the match is started:\n\n[{]: <helper> (diffStep 6.8)\n\n#### [Step 6.8: Hook &#x27;Score&#x27; layer to &#x27;Snake&#x27; layer](https://github.com/DAB0mB/radial-snake/commit/feb4a0b)\n\n##### Changed resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;play&#x2F;snake.js\n```diff\n@@ -38,6 +38,9 @@\n â”Š38â”Š38â”Š        }\n â”Š39â”Š39â”Š      })\n â”Š40â”Š40â”Š    ];\n+â”Š  â”Š41â”Š\n+â”Š  â”Š42â”Š    // Show score board for newly created snakes\n+â”Š  â”Š43â”Š    screen.appendLayer(Game.Screens.Play.Score, this.snakes);\n â”Š41â”Š44â”Š  }\n â”Š42â”Š45â”Š\n â”Š43â”Š46â”Š  draw(context) {\n```\n\n[}]: #\n\nNow we're one layer further from completing the `Play` screen, the only thing missing is the `Win` layer, which should present the winner once the match is finished:\n\n[{]: <helper> (diffStep 6.9)\n\n#### [Step 6.9: Create &#x27;Win&#x27; layer](https://github.com/DAB0mB/radial-snake/commit/3476384)\n\n##### Added resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;play&#x2F;win.js\n```diff\n@@ -0,0 +1,43 @@\n+â”Š  â”Š 1â”ŠGame.Screens.Play.Win = class Win extends Engine.Layer {\n+â”Š  â”Š 2â”Š  constructor(screen, snakes, winner) {\n+â”Š  â”Š 3â”Š    super(screen);\n+â”Š  â”Š 4â”Š\n+â”Š  â”Š 5â”Š    this.snakes = snakes;\n+â”Š  â”Š 6â”Š    this.winner = winner;\n+â”Š  â”Š 7â”Š    // ttl stands for \"time to live\", which means, this layer is going to be\n+â”Š  â”Š 8â”Š    // disposed after 3 seconds\n+â”Š  â”Š 9â”Š    this.ttl = 3000;\n+â”Š  â”Š10â”Š\n+â”Š  â”Š11â”Š    // If there is a winner\n+â”Š  â”Š12â”Š    if (this.winner) {\n+â”Š  â”Š13â”Š      // Message could be something like \"RED SNAKE WINS\"\n+â”Š  â”Š14â”Š      var text = `${this.winner.color.toUpperCase()} SNAKE WINS`;\n+â”Š  â”Š15â”Š      var percent = 40;\n+â”Š  â”Š16â”Š    }\n+â”Š  â”Š17â”Š    // If there is a tie\n+â”Š  â”Š18â”Š    else {\n+â”Š  â”Š19â”Š      var text = 'TIE';\n+â”Š  â”Š20â”Š      var percent = 15;\n+â”Š  â”Š21â”Š    }\n+â”Š  â”Š22â”Š\n+â”Š  â”Š23â”Š    // Create winner sprite and set its properties\n+â”Š  â”Š24â”Š    let winnerTexture = this.assets.minecraftiaFont.createTexture(text);\n+â”Š  â”Š25â”Š    this.winnerSprite = new Engine.Sprite(winnerTexture);\n+â”Š  â”Š26â”Š    this.winnerSprite.align = \"center\";\n+â”Š  â”Š27â”Š    this.winnerSprite.setPercentage(\"width\", this.width, percent, \"height\");\n+â”Š  â”Š28â”Š    this.winnerSprite.x = this.width / 2;\n+â”Š  â”Š29â”Š    this.winnerSprite.y = this.height / 2;\n+â”Š  â”Š30â”Š  }\n+â”Š  â”Š31â”Š\n+â”Š  â”Š32â”Š  draw(context) {\n+â”Š  â”Š33â”Š    this.winnerSprite.draw(context);\n+â”Š  â”Š34â”Š  }\n+â”Š  â”Š35â”Š\n+â”Š  â”Š36â”Š  update(span) {\n+â”Š  â”Š37â”Š    // If limit not yet reached, abort\n+â”Š  â”Š38â”Š    if (this.age < this.ttl) return;\n+â”Š  â”Š39â”Š\n+â”Š  â”Š40â”Š    // Show \"ready\" message all over again, only this time use the updated score board\n+â”Š  â”Š41â”Š    this.screen.game.changeScreen(Game.Screens.Play, this.snakes);\n+â”Š  â”Š42â”Š  }\n+â”Š  â”Š43â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -24,6 +24,7 @@\n â”Š24â”Š24â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š25â”Š25â”Š    <script type=\"text/javascript\" src=\"/scripts/game/entities/snake.js\"></script>\n â”Š26â”Š26â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/index.js\"></script>\n+â”Š  â”Š27â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/win.js\"></script>\n â”Š27â”Š28â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/score.js\"></script>\n â”Š28â”Š29â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/snake.js\"></script>\n â”Š29â”Š30â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/ready.js\"></script>\n```\n\n[}]: #\n\nNote how we use the `changeScreen` method once the `Win` layer has reached its age limit (Time to live, aka `ttl`); This would clear the layers stack and restart the `Play` screen, so we can start a new match all-over, only this time we will pass the `Snake` instances to reserve the original scores. The `Win` layer should be presented whenever a collision has been detected between the snakes:\n\n[{]: <helper> (diffStep 6.1)\n\n#### [Step 6.1: Create &#x27;Play&#x27; screen](https://github.com/DAB0mB/radial-snake/commit/e17a45f)\n\n##### Added resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;play&#x2F;index.js\n```diff\n@@ -0,0 +1,14 @@\n+â”Š  â”Š 1â”ŠGame.Screens.Play = class Play extends Engine.Screen {\n+â”Š  â”Š 2â”Š  get events() {\n+â”Š  â”Š 3â”Š    return {\n+â”Š  â”Š 4â”Š      \"keydown\": \"onKeyDown\"\n+â”Š  â”Š 5â”Š    }\n+â”Š  â”Š 6â”Š  }\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Š  onKeyDown() {\n+â”Š  â”Š 9â”Š    // Once escape is pressed, return to main menu screen\n+â”Š  â”Š10â”Š    if (this.keyStates.get(27)) {\n+â”Š  â”Š11â”Š      this.game.changeScreen(Game.Screens.Menu);\n+â”Š  â”Š12â”Š    }\n+â”Š  â”Š13â”Š  }\n+â”Š  â”Š14â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -23,6 +23,7 @@\n â”Š23â”Š23â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/assets_loader.js\"></script>\n â”Š24â”Š24â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š25â”Š25â”Š    <script type=\"text/javascript\" src=\"/scripts/game/entities/snake.js\"></script>\n+â”Š  â”Š26â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/index.js\"></script>\n â”Š26â”Š27â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/menu/index.js\"></script>\n â”Š27â”Š28â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/splash/index.js\"></script>\n â”Š28â”Š29â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n```\n\n[}]: #\n\nThat's it folks, the `Play` screen is finished, and you can play as much matches as you'd feel like.\n\nAlthough the game is finished, it can still be optimized using `C++`. To discover more on hooking efficiency and how we can hook `C++` to the browser, see the next step."
          },
          {
            "manualTitle": "Step 7: Bonus! Re-implementing geometry in C++",
            "stepRevision": "cea4cffcc2f5e801020ed13ef8f1edde608c85f3",
            "manualView": "> This step is part of a bigger tutorial series where we learn how to create a game engine and implement a Tron-style game in JavaScript. The base project for the following step is available [here](https://github.com/DAB0mB/radial-snake/tree/step6).\n\nSo far I covered up pretty much everything I planned. I showed you how to create a game engine, including a font generator, an animation player and a screening system. On top of that, we've learned how to structure and organize our code well, so if in the future we'd like to extend our game by adding more screens or capabilities, we can do that with ease. Indeed, we've went through lots of great stuff, and if you've reached this point I give you my thumbs up. If so far this wasn't enough, in this step we will be focusing on optimization, and making our game engine run faster (a lot, faster). Obviously, when talking about optimizations, the first thing you would probably think of is how we can make our algorithms efficient by using minimum number of operations. While this is true, we will be actually focusing on optimizing our code using C++.\n\nUnlike JavaScript, which is a dynamic scripting file executed by an interpreter, C++ is a general purpose language which compiles into executables. Naturally, executables are much faster than scripts, since they don't have to be interpreted, and they can approach the hardware and memory much faster. In C++, we have to explicitly define our data-types, meaning that variables don't have to be parsed during run-time. While explicit variables definition is C++'s biggest drawback, it's also one of its biggest advantages. The mere fact that variables can be handled much faster, makes code much more efficient.\n\nAccordingly, we can conclude that the programming language we're using plays a very important role when it comes to efficiency. So how exactly are we going to integrate C++ into the browser? We're going to do that by using a compiler called - [Emscripten](http://kripken.github.io/emscripten-site/).\n\n![emscripten](https://cloud.githubusercontent.com/assets/7648874/22675449/ee6d7e9c-eccc-11e6-9570-1dd5d982ee66.png)\n\nEmscripten is an Open Source [LLVM](https://en.wikipedia.org/wiki/LLVM) to JavaScript compiler. Using Emscripten you can:\n\n- Compile C and C++ code into JavaScript\n- Compile any other code that can be translated into LLVM bitcode into JavaScript.\n- Compile the C/C++ runtimes of other languages into JavaScript, and then run code in those other languages in an indirect way (this has been done for Python and Lua)!\n\nLLVM is a library that is used to construct, optimize and produce intermediate and/or binary machine code. LLVM can be used as a compiler framework, where you provide the \"front end\" (parser and lexer) and the \"back end\" (code that converts LLVM's representation to actual machine code). LLVM can also act as a JIT compiler - it has support for x86/x86_64 and PPC/PPC64 assembly generation with fast code optimizations aimed for compilation speed.\n\nEmscripten operates by taking LLVM code and converting it into a subset of JavaScript called asm.js that can run anywhere that JavaScript can run (usually the browser, but also Node.js, etc.) and is easy for browsers to optimize. This means that you can basically write web applications in any language that has an LLVM compiler.\n\n![emscripten-flow](https://cloud.githubusercontent.com/assets/7648874/22675751/b244b76c-ecce-11e6-917e-f7039ed4b340.png)\n\nIn order to use Emscripten you will first have to install it. I recommend you to follow Emscripten's official installation instructions at their website over [here](https://kripken.github.io/emscripten-site/docs/getting_started/downloads.html). Installing Emscripten might be a bit tiring for some, I know for me it was, but if you're hyped about writing native code in the browser as much as I do, take as much time as needed to install it, and bare with me.\n\nAssuming that you have Emscripten installed, we can get right to business. The goal for this step is to re-implement our geometry namespace in C++, and to be more specific, the circle class and line class. We will start by creating an entry file for our C++ code under the path `resources/cpp/src/index.cpp`:\n\n    $ mkdir resources/cpp\n    $ mkdir resources/cpp/src\n    $ touch resources/cpp/src/index.cpp\n\nFrom now on, every C++ file that we would like to run in the browser should be included in the `index.cpp` file we've just created, otherwise it's not going to appear anywhere. The first stage for re-implementing our geometry would be re-writing the utility module, since our geometry is heavily based on it; Therefore the firs inclusion in our `index.cpp` file would be the following:\n\n[{]: <helper> (diffStep 7.1)\n\n#### [Step 7.1: Add CPP entry script](https://github.com/DAB0mB/radial-snake/commit/2f35323)\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;index.cpp\n```diff\n@@ -0,0 +1 @@\n+â”Š â”Š1â”Š#include \"utils.cpp\"ðŸš«â†µ\n```\n\n[}]: #\n\nFollowing that, we will create the `utils.cpp` module included above, which is a direct translation from C++ to JavaScript for the `utils.js` we've created earlier in this tutorial.\n\n[{]: <helper> (diffStep 7.2)\n\n#### [Step 7.2: Add base utility CPP module](https://github.com/DAB0mB/radial-snake/commit/6dba512)\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;utils.cpp\n```diff\n@@ -0,0 +1,73 @@\n+â”Š  â”Š 1â”Š#include <cfloat>\n+â”Š  â”Š 2â”Š#include <cmath>\n+â”Š  â”Š 3â”Š#include <string>\n+â”Š  â”Š 4â”Š#include \"utils.h\"\n+â”Š  â”Š 5â”Š\n+â”Š  â”Š 6â”Šnamespace utils {\n+â”Š  â”Š 7â”Š  // Fixed modulo method which can calculate modulo of negative numbers properly\n+â”Š  â”Š 8â”Š  // e.g. (-803).mod(800) returns 797\n+â”Š  â”Š 9â”Š  double mod(double context, double num) {\n+â”Š  â”Š10â”Š    return std::fmod((std::fmod(context, num) + num), num);\n+â”Š  â”Š11â”Š  }\n+â”Š  â”Š12â”Š\n+â”Š  â”Š13â”Š  // Trims number and leaves the number of decimals specified.\n+â”Š  â”Š14â”Š  // The \"mode\" argument specifies which math function should be invoked\n+â”Š  â”Š15â”Š  // right after the number has been trimmed.\n+â”Š  â”Š16â”Š  // e.g. 12.12345.trim(3, \"ceil\") returns 12.124\n+â”Š  â”Š17â”Š  double trim(double context, int decimals, const std::string mode) {\n+â”Š  â”Š18â”Š    double accumulator = context * std::pow(10, decimals);\n+â”Š  â”Š19â”Š\n+â”Š  â”Š20â”Š    if (mode.compare(\"ceil\") == 0)\n+â”Š  â”Š21â”Š      accumulator = std::ceil(accumulator);\n+â”Š  â”Š22â”Š    else if (mode.compare(\"floor\") == 0)\n+â”Š  â”Š23â”Š      accumulator = std::floor(accumulator);\n+â”Š  â”Š24â”Š    else\n+â”Š  â”Š25â”Š      accumulator = std::round(accumulator);\n+â”Š  â”Š26â”Š\n+â”Š  â”Š27â”Š    return accumulator / std::pow(10, decimals);\n+â”Š  â”Š28â”Š  }\n+â”Š  â”Š29â”Š\n+â”Š  â”Š30â”Š  // Tells if number is in specified range based on given precision.\n+â”Š  â”Š31â”Š  // See the \"compare\" method for more information about precision\n+â”Š  â”Š32â”Š  bool isBetween(double context, double num1, double num2, const std::string precision) {\n+â”Š  â”Š33â”Š    return compare(context, std::min(num1, num2), \">=\", precision) &&\n+â”Š  â”Š34â”Š           compare(context, std::max(num1, num2), \"<=\", precision);\n+â”Š  â”Š35â”Š  }\n+â”Š  â”Š36â”Š\n+â”Š  â”Š37â”Š  bool compare(double context, double num, const std::string precision) {\n+â”Š  â”Š38â”Š    return compare(context, num, \"==\", precision);\n+â”Š  â”Š39â”Š  }\n+â”Š  â”Š40â”Š\n+â”Š  â”Š41â”Š  // Initiates comparison operator between context number and a given number, only here\n+â”Š  â”Š42â”Š  // a precision can be specified\n+â”Š  â”Š43â”Š  bool compare(double context, double num, const std::string method, const std::string precision) {\n+â”Š  â”Š44â”Š    // Fixed precision, \"almost equal\" with a deviation of Îµ\n+â”Š  â”Š45â”Š    if (precision.compare(\"f\") == 0) {\n+â”Š  â”Š46â”Š      if (method.compare(\"<\") == 0 ||\n+â”Š  â”Š47â”Š          method.compare(\"<=\") == 0)\n+â”Š  â”Š48â”Š        return context <= num + DBL_EPSILON;\n+â”Š  â”Š49â”Š      if (method.compare(\">\") == 0 ||\n+â”Š  â”Š50â”Š          method.compare(\">=\") == 0)\n+â”Š  â”Š51â”Š        return context >= num - DBL_EPSILON;\n+â”Š  â”Š52â”Š      return std::abs(context - num) <= DBL_EPSILON;\n+â”Š  â”Š53â”Š    }\n+â”Š  â”Š54â”Š    // Pixel precision, round comparison\n+â”Š  â”Š55â”Š    else if (precision.compare(\"px\") == 0) {\n+â”Š  â”Š56â”Š      if (method.compare(\"<\") == 0 ||\n+â”Š  â”Š57â”Š          method.compare(\"<=\") == 0)\n+â”Š  â”Š58â”Š        return std::round(context) <= std::round(num);\n+â”Š  â”Š59â”Š      if (method.compare(\">\") == 0 ||\n+â”Š  â”Š60â”Š          method.compare(\">=\") == 0)\n+â”Š  â”Š61â”Š        return std::round(context) >= std::round(num);\n+â”Š  â”Š62â”Š      return std::round(context) == std::round(num);\n+â”Š  â”Š63â”Š    }\n+â”Š  â”Š64â”Š    // Exact precision\n+â”Š  â”Š65â”Š    else {\n+â”Š  â”Š66â”Š      if (method.compare(\"<\") == 0) return context < num;\n+â”Š  â”Š67â”Š      if (method.compare(\"<=\") == 0) return context <= num;\n+â”Š  â”Š68â”Š      if (method.compare(\">\") == 0) return context > num;\n+â”Š  â”Š69â”Š      if (method.compare(\">=\") == 0) return context >= num;\n+â”Š  â”Š70â”Š      return context == num;\n+â”Š  â”Š71â”Š    }\n+â”Š  â”Š72â”Š  }\n+â”Š  â”Š73â”Š}ðŸš«â†µ\n```\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;utils.h\n```diff\n@@ -0,0 +1,15 @@\n+â”Š  â”Š 1â”Š#pragma once\n+â”Š  â”Š 2â”Š\n+â”Š  â”Š 3â”Š#include <string>\n+â”Š  â”Š 4â”Š\n+â”Š  â”Š 5â”Šnamespace utils {\n+â”Š  â”Š 6â”Š  double mod(double context, double num);\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Š  double trim(double context, int decimals, const std::string mode = \"round\");\n+â”Š  â”Š 9â”Š\n+â”Š  â”Š10â”Š  bool isBetween(double context, double num1, double num2, const std::string precision = \"exact\");\n+â”Š  â”Š11â”Š\n+â”Š  â”Š12â”Š  bool compare(double context, double num, const std::string precision = \"exact\");\n+â”Š  â”Š13â”Š\n+â”Š  â”Š14â”Š  bool compare(double context, double num, const std::string method, const std::string precision);\n+â”Š  â”Š15â”Š}ðŸš«â†µ\n```\n\n[}]: #\n\nThe module above should work by itself when interacting with it inside the C++ scope, but that's not what we're striving for. We want this module to be available for use in our JavaScript project. This requires us to wrap our code in such a way the the Emscripten compiler will know how to compile it. Apart from providing a compiler, Emscripten provides us with functions and macros that will help use bind our C++ code to the JavaScript environment. These functionalities are packed in a single library which can be imported in our C++ code, and it is called [Embind](https://kripken.github.io/emscripten-site/docs/porting/connecting_cpp_and_javascript/embind.html) (probably stands for \"Emscripten bind\"). Using EMBind, let's wrap our utils module accordingly:\n\n[{]: <helper> (diffStep 7.3)\n\n#### [Step 7.3: EMBind CPP utils](https://github.com/DAB0mB/radial-snake/commit/0f34332)\n\n##### Changed resources&#x2F;cpp&#x2F;src&#x2F;utils.cpp\n```diff\n@@ -1,6 +1,7 @@\n â”Š1â”Š1â”Š#include <cfloat>\n â”Š2â”Š2â”Š#include <cmath>\n â”Š3â”Š3â”Š#include <string>\n+â”Š â”Š4â”Š#include <emscripten/bind.h>\n â”Š4â”Š5â”Š#include \"utils.h\"\n â”Š5â”Š6â”Š\n â”Š6â”Š7â”Šnamespace utils {\n```\n```diff\n@@ -70,4 +71,15 @@\n â”Š70â”Š71â”Š      return context == num;\n â”Š71â”Š72â”Š    }\n â”Š72â”Š73â”Š  }\n+â”Š  â”Š74â”Š}\n+â”Š  â”Š75â”Š\n+â”Š  â”Š76â”ŠEMSCRIPTEN_BINDINGS(utils_module) {\n+â”Š  â”Š77â”Š  emscripten::function(\"utils_mod\", &utils::mod);\n+â”Š  â”Š78â”Š  emscripten::function(\"utils_trim\", &utils::trim);\n+â”Š  â”Š79â”Š  emscripten::function(\"utils_isBetween\", &utils::isBetween);\n+â”Š  â”Š80â”Š  emscripten::function(\"utils_compare\",\n+â”Š  â”Š81â”Š    emscripten::select_overload<bool(double, double, const std::string, const std::string)>(\n+â”Š  â”Š82â”Š      &utils::compare\n+â”Š  â”Š83â”Š    )\n+â”Š  â”Š84â”Š  );\n â”Š73â”Š85â”Š}ðŸš«â†µ\n```\n\n[}]: #\n\nAfter a while you'll get used for Embind's API. If you'll look at it, it's self explanatory and easy to understand. Bound objects will be available the JavaScript environment will be available under an object named `Module`, e.g. the C++ method `mod` will be available for use as `Module.utils_mod`. Bound functions should have supported return types and argument types, meaning that if we're using a custom structure as a return type or an argument type, we first need to wrap it using EMBind, otherwise the compiler won't know how to handle it. A list of natively supported data-types can be found [here](https://kripken.github.io/emscripten-site/docs/porting/connecting_cpp_and_javascript/embind.html#built-in-type-conversions).\n\nEven though we've wrapped our C++ code and hypothetically it can already be used in the browser, I'd go for a second wrapper, since the compiled code doesn't have the optimal architecture. Right now we will have to approach C++ utility functions using `Module.utils_foo`. Instead, I'd like it to be `CPP.Utils.foo`, since it's clearer this way. The output of the Emscripten compiler can be wrapped with JavaScript code, using a prefix and a suffix, defined in 2 separate files respectively, called `pre.js` and `post.js`:\n\n[{]: <helper> (diffStep 7.4)\n\n#### [Step 7.4: Create CPP wrappers](https://github.com/DAB0mB/radial-snake/commit/cc28a34)\n\n##### Added resources&#x2F;cpp&#x2F;post.js\n```diff\n@@ -0,0 +1,10 @@\n+â”Š  â”Š 1â”Šreturn {\n+â”Š  â”Š 2â”Š  Utils: {\n+â”Š  â”Š 3â”Š    mod: Module.utils_mod,\n+â”Š  â”Š 4â”Š    trim: Module.utils_trim,\n+â”Š  â”Š 5â”Š    isBetween: Module.utils_isBetween,\n+â”Š  â”Š 6â”Š    compare: Module.utils_compare\n+â”Š  â”Š 7â”Š  }\n+â”Š  â”Š 8â”Š};\n+â”Š  â”Š 9â”Š\n+â”Š  â”Š10â”Š})();ðŸš«â†µ\n```\n\n##### Added resources&#x2F;cpp&#x2F;pre.js\n```diff\n@@ -0,0 +1 @@\n+â”Š â”Š1â”ŠCPP = (function() {ðŸš«â†µ\n```\n\n[}]: #\n\nWhat we've done in the code snippet above, we've created an anonymous function which calls itself, and inside we've exported a new namespace called `CPP` (C++). This way we can keep the generated code encapsulated, without worrying about spamming the global object.\n\nAfter creating a wrapper, I'd also recommend you to integrate the generated C++ code into existing namespaces, meaning that if for example we would like to approach the `CPP.Utils.foo` method, it could be done using `Utils.foo`. This way existing code won't have to be changed, and extra wrapping logic can be applied with ease, like the chaining logic implemented in the `Utils` namespace:\n\n[{]: <helper> (diffStep 7.5)\n\n#### [Step 7.5: Bind CPP utils to JS utils](https://github.com/DAB0mB/radial-snake/commit/0a67d50)\n\n##### Changed resources&#x2F;scripts&#x2F;utils.js\n```diff\n@@ -16,53 +16,9 @@\n â”Š16â”Š16â”Š  return chain;\n â”Š17â”Š17â”Š};\n â”Š18â”Š18â”Š\n-â”Š19â”Š  â”Š// Fixed modulo method which can calculate modulo of negative numbers properly\n-â”Š20â”Š  â”Š// e.g. (-803).mod(800) returns 797\n-â”Š21â”Š  â”ŠUtils.mod = function (context, num) {\n-â”Š22â”Š  â”Š  return ((context % num) + num) % num;\n-â”Š23â”Š  â”Š};\n-â”Š24â”Š  â”Š\n-â”Š25â”Š  â”Š// Trims number and leaves the number of decimals specified.\n-â”Š26â”Š  â”Š// The \"mode\" argument specifies which math function should be invoked\n-â”Š27â”Š  â”Š// right after the number has been trimmed.\n-â”Š28â”Š  â”Š// e.g. 12.12345.trim(3, \"ceil\") returns 12.124\n-â”Š29â”Š  â”ŠUtils.trim = function (context, decimals, mode = \"round\") {\n-â”Š30â”Š  â”Š  return Math[mode](context * Math.pow(10, decimals)) / Math.pow(10, decimals);\n-â”Š31â”Š  â”Š};\n-â”Š32â”Š  â”Š\n-â”Š33â”Š  â”Š// Tells if number is in specified range based on given precision.\n-â”Š34â”Š  â”Š// See the \"compare\" method for more information about precision\n-â”Š35â”Š  â”ŠUtils.isBetween = function (context, num1, num2, precision) {\n-â”Š36â”Š  â”Š  return Utils.compare(context, Math.min(num1, num2), \">=\", precision) &&\n-â”Š37â”Š  â”Š         Utils.compare(context, Math.max(num1, num2), \"<=\", precision);\n-â”Š38â”Š  â”Š};\n-â”Š39â”Š  â”Š\n-â”Š40â”Š  â”Š// Initiates comparison operator between context number and a given number, only here\n-â”Š41â”Š  â”Š// a precision can be specified\n-â”Š42â”Š  â”ŠUtils.compare = function (context, num, method, precision = method) {\n-â”Š43â”Š  â”Š  switch (precision) {\n-â”Š44â”Š  â”Š    // Fixed precision, \"almost equal\" with a deviation of Îµ\n-â”Š45â”Š  â”Š    case \"f\":\n-â”Š46â”Š  â”Š      switch (method) {\n-â”Š47â”Š  â”Š        case \"<\": case \"<=\": return context <= num + Number.EPSILON;\n-â”Š48â”Š  â”Š        case \">\": case \">=\": return context >= num - Number.EPSILON;\n-â”Š49â”Š  â”Š        default: return Math.abs(context - num) <= Number.EPSILON;\n-â”Š50â”Š  â”Š      }\n-â”Š51â”Š  â”Š    // Pixel precision, round comparison\n-â”Š52â”Š  â”Š    case \"px\":\n-â”Š53â”Š  â”Š      switch (method) {\n-â”Š54â”Š  â”Š        case \"<\": case \"<=\": return Math.round(context) <= Math.round(num);\n-â”Š55â”Š  â”Š        case \">\": case \">=\": return Math.round(context) >= Math.round(num);\n-â”Š56â”Š  â”Š        default: return Math.round(context) == Math.round(num);\n-â”Š57â”Š  â”Š      }\n-â”Š58â”Š  â”Š    // Exact precision\n-â”Š59â”Š  â”Š    default:\n-â”Š60â”Š  â”Š      switch (method) {\n-â”Š61â”Š  â”Š        case \"<\": return context < num;\n-â”Š62â”Š  â”Š        case \"<=\": return context <= num;\n-â”Š63â”Š  â”Š        case \">\": return context > num;\n-â”Š64â”Š  â”Š        case \">=\": return context >= num;\n-â”Š65â”Š  â”Š        default: return context === num;\n-â”Š66â”Š  â”Š      }\n+â”Š  â”Š19â”ŠObject.assign(Utils, CPP.Utils, {\n+â”Š  â”Š20â”Š  // Overload handling\n+â”Š  â”Š21â”Š  compare(context, num, method, precision = method) {\n+â”Š  â”Š22â”Š    return CPP.Utils.compare(context, num, method, precision);\n â”Š67â”Š23â”Š  }\n-â”Š68â”Š  â”Š};ðŸš«â†µ\n+â”Š  â”Š24â”Š});ðŸš«â†µ\n```\n\n[}]: #\n\nWhenever launching the compiler, the generated code should be outputted somewhere. I've decided to go with the path `resources/scripts/cpp.bundle.js`, but it doesn't matter how the file is gonna be called, as long as it's defined under the `scripts` dir, otherwise we won't be able to load it. Also, we need to make sure that we set a git-ignore rule for the generated file, since there's no reason for us to upload it to the git-host if we're planning on compiling it:\n\n[{]: <helper> (diffStep 7.5)\n\n#### [Step 7.5: Bind CPP utils to JS utils](https://github.com/DAB0mB/radial-snake/commit/0a67d50)\n\n##### Changed resources&#x2F;scripts&#x2F;utils.js\n```diff\n@@ -16,53 +16,9 @@\n â”Š16â”Š16â”Š  return chain;\n â”Š17â”Š17â”Š};\n â”Š18â”Š18â”Š\n-â”Š19â”Š  â”Š// Fixed modulo method which can calculate modulo of negative numbers properly\n-â”Š20â”Š  â”Š// e.g. (-803).mod(800) returns 797\n-â”Š21â”Š  â”ŠUtils.mod = function (context, num) {\n-â”Š22â”Š  â”Š  return ((context % num) + num) % num;\n-â”Š23â”Š  â”Š};\n-â”Š24â”Š  â”Š\n-â”Š25â”Š  â”Š// Trims number and leaves the number of decimals specified.\n-â”Š26â”Š  â”Š// The \"mode\" argument specifies which math function should be invoked\n-â”Š27â”Š  â”Š// right after the number has been trimmed.\n-â”Š28â”Š  â”Š// e.g. 12.12345.trim(3, \"ceil\") returns 12.124\n-â”Š29â”Š  â”ŠUtils.trim = function (context, decimals, mode = \"round\") {\n-â”Š30â”Š  â”Š  return Math[mode](context * Math.pow(10, decimals)) / Math.pow(10, decimals);\n-â”Š31â”Š  â”Š};\n-â”Š32â”Š  â”Š\n-â”Š33â”Š  â”Š// Tells if number is in specified range based on given precision.\n-â”Š34â”Š  â”Š// See the \"compare\" method for more information about precision\n-â”Š35â”Š  â”ŠUtils.isBetween = function (context, num1, num2, precision) {\n-â”Š36â”Š  â”Š  return Utils.compare(context, Math.min(num1, num2), \">=\", precision) &&\n-â”Š37â”Š  â”Š         Utils.compare(context, Math.max(num1, num2), \"<=\", precision);\n-â”Š38â”Š  â”Š};\n-â”Š39â”Š  â”Š\n-â”Š40â”Š  â”Š// Initiates comparison operator between context number and a given number, only here\n-â”Š41â”Š  â”Š// a precision can be specified\n-â”Š42â”Š  â”ŠUtils.compare = function (context, num, method, precision = method) {\n-â”Š43â”Š  â”Š  switch (precision) {\n-â”Š44â”Š  â”Š    // Fixed precision, \"almost equal\" with a deviation of Îµ\n-â”Š45â”Š  â”Š    case \"f\":\n-â”Š46â”Š  â”Š      switch (method) {\n-â”Š47â”Š  â”Š        case \"<\": case \"<=\": return context <= num + Number.EPSILON;\n-â”Š48â”Š  â”Š        case \">\": case \">=\": return context >= num - Number.EPSILON;\n-â”Š49â”Š  â”Š        default: return Math.abs(context - num) <= Number.EPSILON;\n-â”Š50â”Š  â”Š      }\n-â”Š51â”Š  â”Š    // Pixel precision, round comparison\n-â”Š52â”Š  â”Š    case \"px\":\n-â”Š53â”Š  â”Š      switch (method) {\n-â”Š54â”Š  â”Š        case \"<\": case \"<=\": return Math.round(context) <= Math.round(num);\n-â”Š55â”Š  â”Š        case \">\": case \">=\": return Math.round(context) >= Math.round(num);\n-â”Š56â”Š  â”Š        default: return Math.round(context) == Math.round(num);\n-â”Š57â”Š  â”Š      }\n-â”Š58â”Š  â”Š    // Exact precision\n-â”Š59â”Š  â”Š    default:\n-â”Š60â”Š  â”Š      switch (method) {\n-â”Š61â”Š  â”Š        case \"<\": return context < num;\n-â”Š62â”Š  â”Š        case \"<=\": return context <= num;\n-â”Š63â”Š  â”Š        case \">\": return context > num;\n-â”Š64â”Š  â”Š        case \">=\": return context >= num;\n-â”Š65â”Š  â”Š        default: return context === num;\n-â”Š66â”Š  â”Š      }\n+â”Š  â”Š19â”ŠObject.assign(Utils, CPP.Utils, {\n+â”Š  â”Š20â”Š  // Overload handling\n+â”Š  â”Š21â”Š  compare(context, num, method, precision = method) {\n+â”Š  â”Š22â”Š    return CPP.Utils.compare(context, num, method, precision);\n â”Š67â”Š23â”Š  }\n-â”Š68â”Š  â”Š};ðŸš«â†µ\n+â”Š  â”Š24â”Š});ðŸš«â†µ\n```\n\n[}]: #\n\nTo compile our C++ code and turn it into JavaScript, we'll need to run the following command:\n\n    $ emcc -O1 --pre-js resources/cpp/pre.js --post-js resources/cpp/post.js --bind -o resources/scripts/cpp.bundle.js resources/cpp/src/index.cpp\n\nHere's a detailed list with explanations regards the arguments vector we've just passed:\n\n- `-01` - Optimization level 1. The higher the index, the more optimized our code is gonna be, but less readable.\n- `--pre-js` - Specifies a JavaScript prefix for the compiled code.\n- `--post-js` - Specifies a JavaScript postfix for the compiled code.\n- `--bind` - Tells the compiler to use Embind\n- `-o` - The output path.\n\n> More informations regards Emscripten's CLI can be found [here](https://kripken.github.io/emscripten-site/docs/tools_reference/emcc.html).\n\nYou don't have to memorize the compilation command we've just typed, because we're gonna save it as an NPM script called `build:cpp`:\n\n[{]: <helper> (diffStep 7.6)\n\n#### [Step 7.6: Add ignore rule to CPP bundle](https://github.com/DAB0mB/radial-snake/commit/f4a75cf)\n\n##### Changed .gitignore\n```diff\n@@ -1,3 +1,4 @@\n â”Š1â”Š1â”Šnode_modules\n â”Š2â”Š2â”Šnpm-debug.log\n-â”Š3â”Š â”Šresources/assets/fonts/*.jsonðŸš«â†µ\n+â”Š â”Š3â”Šresources/assets/fonts/*.json\n+â”Š â”Š4â”Šresources/scripts/cpp.bundle.jsðŸš«â†µ\n```\n\n[}]: #\n\nNow if you'd like to compile the C++ code just run:\n\n    $ npm run build:cpp\n\nMoreover, the code should be compiled automatically any time you start the serer using the command:\n\n    $ npm run serve\n\nWe always have to be on the alert and run our tests against modules we've just translated from JavaScript to C++. This will guarantee that once we run the game we won't stumble upon any defect whatsoever. Before running the tests, be sure to import the C++ bundle in the HTML file's header:\n\n[{]: <helper> (diffStep 7.8)\n\n#### [Step 7.8: Load CPP bundle in spec runner](https://github.com/DAB0mB/radial-snake/commit/0d1bd08)\n\n##### Changed views&#x2F;spec_runner.html\n```diff\n@@ -16,6 +16,7 @@\n â”Š16â”Š16â”Š    <script type=\"text/javascript\" src=\"libs/underscore.js\"></script>\n â”Š17â”Š17â”Š\n â”Š18â”Š18â”Š    <!-- Scripts -->\n+â”Š  â”Š19â”Š    <script type=\"text/javascript\" src=\"scripts/cpp.bundle.js\"></script>\n â”Š19â”Š20â”Š    <script type=\"text/javascript\" src=\"scripts/utils.js\"></script>\n â”Š20â”Š21â”Š    <script type=\"text/javascript\" src=\"scripts/namespaces.js\"></script>\n â”Š21â”Š22â”Š    <script type=\"text/javascript\" src=\"scripts/engine/geometry/line.js\"></script>\n```\n\n[}]: #\n\nNow we can run the tests by running the following command:\n\n    $ npm run test\n\nAt this point **all our tests should pass**. If they don't, it means our newly created utility module is not working properly, and you will have to repeat the previous steps until you get it right.\n\nUp next, we gonna translate the geometry line class to C++. Since it's gonna be translated almost identically, we will have to make sure that all the necessary assets are gonna be available for our class before proceeding. The first thing we will have to do would be making sure that the utility functions are chainable directly from C++ as well. To do that, we will create a chain class which should return a new instance of it whenever we're about to chain the upcoming utility method. Once calling `result()`, the accumulator should be returned:\n\n[{]: <helper> (diffStep 7.9)\n\n#### [Step 7.9: Add chaining method to CPP utils](https://github.com/DAB0mB/radial-snake/commit/0927eea)\n\n##### Changed resources&#x2F;cpp&#x2F;src&#x2F;utils.cpp\n```diff\n@@ -5,6 +5,61 @@\n â”Š 5â”Š 5â”Š#include \"utils.h\"\n â”Š 6â”Š 6â”Š\n â”Š 7â”Š 7â”Šnamespace utils {\n+â”Š  â”Š 8â”Š  template<typename T>\n+â”Š  â”Š 9â”Š  Chain<T>::Chain(T accumulator): _accumulator(accumulator) {\n+â”Š  â”Š10â”Š  }\n+â”Š  â”Š11â”Š\n+â”Š  â”Š12â”Š  template<>\n+â”Š  â”Š13â”Š  Chain<double>* Chain<double>::mod(double num) {\n+â”Š  â”Š14â”Š    double result = utils::mod(_accumulator, num);\n+â”Š  â”Š15â”Š    Chain<double>* chain = new Chain<double>(result);\n+â”Š  â”Š16â”Š    delete this;\n+â”Š  â”Š17â”Š    return chain;\n+â”Š  â”Š18â”Š  }\n+â”Š  â”Š19â”Š\n+â”Š  â”Š20â”Š  template<>\n+â”Š  â”Š21â”Š  Chain<double>* Chain<double>::trim(int decimals, const std::string mode) {\n+â”Š  â”Š22â”Š    double result = utils::trim(_accumulator, decimals, mode);\n+â”Š  â”Š23â”Š    Chain<double>* chain = new Chain<double>(result);\n+â”Š  â”Š24â”Š    delete this;\n+â”Š  â”Š25â”Š    return chain;\n+â”Š  â”Š26â”Š  }\n+â”Š  â”Š27â”Š\n+â”Š  â”Š28â”Š  template<>\n+â”Š  â”Š29â”Š  Chain<bool>* Chain<double>::isBetween(double num1, double num2, const std::string precision) {\n+â”Š  â”Š30â”Š    bool result = utils::isBetween(_accumulator, num1, num2, precision);\n+â”Š  â”Š31â”Š    Chain<bool>* chain = new Chain<bool>(result);\n+â”Š  â”Š32â”Š    delete this;\n+â”Š  â”Š33â”Š    return chain;\n+â”Š  â”Š34â”Š  }\n+â”Š  â”Š35â”Š\n+â”Š  â”Š36â”Š  template<>\n+â”Š  â”Š37â”Š  Chain<bool>* Chain<double>::compare(double num, const std::string precision) {\n+â”Š  â”Š38â”Š    bool result = utils::compare(_accumulator, num, precision);\n+â”Š  â”Š39â”Š    Chain<bool>* chain = new Chain<bool>(result);\n+â”Š  â”Š40â”Š    delete this;\n+â”Š  â”Š41â”Š    return chain;\n+â”Š  â”Š42â”Š  }\n+â”Š  â”Š43â”Š\n+â”Š  â”Š44â”Š  template<>\n+â”Š  â”Š45â”Š  Chain<bool>* Chain<double>::compare(double num, const std::string method, const std::string precision) {\n+â”Š  â”Š46â”Š    bool result = utils::compare(_accumulator, num, method, precision);\n+â”Š  â”Š47â”Š    Chain<bool>* chain = new Chain<bool>(result);\n+â”Š  â”Š48â”Š    delete this;\n+â”Š  â”Š49â”Š    return chain;\n+â”Š  â”Š50â”Š  }\n+â”Š  â”Š51â”Š\n+â”Š  â”Š52â”Š  template<typename T>\n+â”Š  â”Š53â”Š  T Chain<T>::result() {\n+â”Š  â”Š54â”Š    delete this;\n+â”Š  â”Š55â”Š    return _accumulator;\n+â”Š  â”Š56â”Š  }\n+â”Š  â”Š57â”Š\n+â”Š  â”Š58â”Š  template<typename T>\n+â”Š  â”Š59â”Š  Chain<T>* chain(T accumulator) {\n+â”Š  â”Š60â”Š    return new Chain<T>(accumulator);\n+â”Š  â”Š61â”Š  }\n+â”Š  â”Š62â”Š\n â”Š 8â”Š63â”Š  // Fixed modulo method which can calculate modulo of negative numbers properly\n â”Š 9â”Š64â”Š  // e.g. (-803).mod(800) returns 797\n â”Š10â”Š65â”Š  double mod(double context, double num) {\n```\n\n##### Changed resources&#x2F;cpp&#x2F;src&#x2F;utils.h\n```diff\n@@ -3,6 +3,30 @@\n â”Š 3â”Š 3â”Š#include <string>\n â”Š 4â”Š 4â”Š\n â”Š 5â”Š 5â”Šnamespace utils {\n+â”Š  â”Š 6â”Š  template<typename T>\n+â”Š  â”Š 7â”Š  class Chain {\n+â”Š  â”Š 8â”Š  private:\n+â”Š  â”Š 9â”Š    T _accumulator;\n+â”Š  â”Š10â”Š\n+â”Š  â”Š11â”Š  public:\n+â”Š  â”Š12â”Š    Chain(T accumulator);\n+â”Š  â”Š13â”Š\n+â”Š  â”Š14â”Š    Chain<double>* mod(double num);\n+â”Š  â”Š15â”Š\n+â”Š  â”Š16â”Š    Chain<double>* trim(int decimals, const std::string mode = \"round\");\n+â”Š  â”Š17â”Š\n+â”Š  â”Š18â”Š    Chain<bool>* isBetween(double num1, double num2, const std::string precision = \"exact\");\n+â”Š  â”Š19â”Š\n+â”Š  â”Š20â”Š    Chain<bool>* compare(double num, const std::string precision = \"exact\");\n+â”Š  â”Š21â”Š\n+â”Š  â”Š22â”Š    Chain<bool>* compare(double num, const std::string method, const std::string precision);\n+â”Š  â”Š23â”Š\n+â”Š  â”Š24â”Š    T result();\n+â”Š  â”Š25â”Š  };\n+â”Š  â”Š26â”Š\n+â”Š  â”Š27â”Š  template<typename T>\n+â”Š  â”Š28â”Š  Chain<T>* chain(T accumulator);\n+â”Š  â”Š29â”Š\n â”Š 6â”Š30â”Š  double mod(double context, double num);\n â”Š 7â”Š31â”Š\n â”Š 8â”Š32â”Š  double trim(double context, int decimals, const std::string mode = \"round\");\n```\n\n[}]: #\n\n> Note that when coding in C++ we have to make sure that the objects are being disposed when not needed anymore, otherwise we will have some unnecessary memory leaks.\n\n2D shapes are presented in space using points with 2 values - `x` (axis) and `y` axis, therefore, we will create the appropriate point structure:\n\n[{]: <helper> (diffStep 7.1)\n\n#### [Step 7.1: Add CPP entry script](https://github.com/DAB0mB/radial-snake/commit/2f35323)\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;index.cpp\n```diff\n@@ -0,0 +1 @@\n+â”Š â”Š1â”Š#include \"utils.cpp\"ðŸš«â†µ\n```\n\n[}]: #\n\nReturned values can either be `null` (`undefined`) or not. Since there's no built in nullable-values mechanism in C++ (up until C++17), we're gonna create one of our own:\n\n[{]: <helper> (diffStep 7.11)\n\n#### [Step 7.11: Add nullable class](https://github.com/DAB0mB/radial-snake/commit/41b2f7c)\n\n##### Changed resources&#x2F;cpp&#x2F;src&#x2F;index.cpp\n```diff\n@@ -1 +1,2 @@\n+â”Š â”Š1â”Š#include \"nullable.cpp\"\n â”Š1â”Š2â”Š#include \"utils.cpp\"ðŸš«â†µ\n```\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;nullable.cpp\n```diff\n@@ -0,0 +1,37 @@\n+â”Š  â”Š 1â”Š#include \"nullable.h\"\n+â”Š  â”Š 2â”Š\n+â”Š  â”Š 3â”Štemplate <typename T>\n+â”Š  â”Š 4â”ŠNullable<T>::Nullable(T value): _value(value), _initialized(true) {\n+â”Š  â”Š 5â”Š\n+â”Š  â”Š 6â”Š}\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Štemplate <typename T>\n+â”Š  â”Š 9â”ŠNullable<T>::Nullable(): _initialized(false) {\n+â”Š  â”Š10â”Š\n+â”Š  â”Š11â”Š}\n+â”Š  â”Š12â”Š\n+â”Š  â”Š13â”Štemplate <typename T>\n+â”Š  â”Š14â”ŠT Nullable<T>::getValue() const {\n+â”Š  â”Š15â”Š  return _value;\n+â”Š  â”Š16â”Š}\n+â”Š  â”Š17â”Š\n+â”Š  â”Š18â”Štemplate <typename T>\n+â”Š  â”Š19â”Švoid Nullable<T>::setValue(T value) {\n+â”Š  â”Š20â”Š  _value = value;\n+â”Š  â”Š21â”Š  _initialized = true;\n+â”Š  â”Š22â”Š}\n+â”Š  â”Š23â”Š\n+â”Š  â”Š24â”Štemplate <typename T>\n+â”Š  â”Š25â”Švoid Nullable<T>::resetValue() {\n+â”Š  â”Š26â”Š  _initialized = false;\n+â”Š  â”Š27â”Š}\n+â”Š  â”Š28â”Š\n+â”Š  â”Š29â”Štemplate <typename T>\n+â”Š  â”Š30â”Šbool Nullable<T>::hasValue() const {\n+â”Š  â”Š31â”Š  return _initialized == true;\n+â”Š  â”Š32â”Š}\n+â”Š  â”Š33â”Š\n+â”Š  â”Š34â”Štemplate <typename T>\n+â”Š  â”Š35â”Šbool Nullable<T>::isNull() const {\n+â”Š  â”Š36â”Š  return _initialized == false;\n+â”Š  â”Š37â”Š}ðŸš«â†µ\n```\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;nullable.h\n```diff\n@@ -0,0 +1,23 @@\n+â”Š  â”Š 1â”Š#pragma once\n+â”Š  â”Š 2â”Š\n+â”Š  â”Š 3â”Štemplate <typename T>\n+â”Š  â”Š 4â”Šclass Nullable {\n+â”Š  â”Š 5â”Šprivate:\n+â”Š  â”Š 6â”Š  T _value;\n+â”Š  â”Š 7â”Š  bool _initialized;\n+â”Š  â”Š 8â”Š\n+â”Š  â”Š 9â”Špublic:\n+â”Š  â”Š10â”Š  Nullable(T value);\n+â”Š  â”Š11â”Š\n+â”Š  â”Š12â”Š  Nullable();\n+â”Š  â”Š13â”Š\n+â”Š  â”Š14â”Š  T getValue() const;\n+â”Š  â”Š15â”Š\n+â”Š  â”Š16â”Š  void setValue(T value);\n+â”Š  â”Š17â”Š\n+â”Š  â”Š18â”Š  void resetValue();\n+â”Š  â”Š19â”Š\n+â”Š  â”Š20â”Š  bool hasValue() const;\n+â”Š  â”Š21â”Š\n+â”Š  â”Š22â”Š  bool isNull() const;\n+â”Š  â”Š23â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nNow that all the necessary assets for the line class are ready, we can go ahead and create it:\n\n[{]: <helper> (diffStep 7.12)\n\n#### [Step 7.12: Add base line CPP module](https://github.com/DAB0mB/radial-snake/commit/9d17554)\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;geometry&#x2F;line.cpp\n```diff\n@@ -0,0 +1,99 @@\n+â”Š  â”Š 1â”Š#include \"../nullable.h\"\n+â”Š  â”Š 2â”Š#include \"../utils.h\"\n+â”Š  â”Š 3â”Š#include \"point.h\"\n+â”Š  â”Š 4â”Š#include \"line.h\"\n+â”Š  â”Š 5â”Š\n+â”Š  â”Š 6â”Šnamespace geometry {\n+â”Š  â”Š 7â”Š  // x1 - The first point's x value\n+â”Š  â”Š 8â”Š  // y1 - The first point's y value\n+â”Š  â”Š 9â”Š  // x1 - The second point's x value\n+â”Š  â”Š10â”Š  // y2 - The second point's y value\n+â”Š  â”Š11â”Š  Line::Line(double x1, double y1, double x2, double y2) {\n+â”Š  â”Š12â”Š    _x1 = utils::trim(x1, 9);\n+â”Š  â”Š13â”Š    _y1 = utils::trim(y1, 9);\n+â”Š  â”Š14â”Š    _x2 = utils::trim(x2, 9);\n+â”Š  â”Š15â”Š    _y2 = utils::trim(y2, 9);\n+â”Š  â”Š16â”Š  }\n+â”Š  â”Š17â”Š\n+â”Š  â”Š18â”Š  // Gets the matching x value for a given y value\n+â”Š  â”Š19â”Š  Nullable<double> Line::getMatchingX(double y) {\n+â”Š  â”Š20â”Š    // If an error was thrown it means we divided a number by zero,\n+â”Š  â”Š21â”Š    // in which case there is not intersection point\n+â”Š  â”Š22â”Š    double x = utils::trim(\n+â”Š  â”Š23â”Š      (((y - _y1) * (_x2 - _x1)) /\n+â”Š  â”Š24â”Š       (_y2 - _y1)) + _x1\n+â”Š  â”Š25â”Š    , 9, \"exact\");\n+â”Š  â”Š26â”Š\n+â”Š  â”Š27â”Š    // Check if result is in values range\n+â”Š  â”Š28â”Š    if (utils::isBetween(x, _x1, _x2, \"round\")) {\n+â”Š  â”Š29â”Š      return Nullable<double>(x);\n+â”Š  â”Š30â”Š    }\n+â”Š  â”Š31â”Š\n+â”Š  â”Š32â”Š    return Nullable<double>();\n+â”Š  â”Š33â”Š  }\n+â”Š  â”Š34â”Š\n+â”Š  â”Š35â”Š  // Gets the matching y value for a given x value\n+â”Š  â”Š36â”Š  Nullable<double> Line::getMatchingY(double x) {\n+â”Š  â”Š37â”Š    // If an error was thrown it means we divided a number by zero,\n+â”Š  â”Š38â”Š    // in which case there is not intersection point\n+â”Š  â”Š39â”Š    double y = utils::trim(\n+â”Š  â”Š40â”Š      (((x - _x1) * (_y2 - _y1)) /\n+â”Š  â”Š41â”Š       (_x2 - _x1)) + _y1\n+â”Š  â”Š42â”Š    , 9, \"exact\");\n+â”Š  â”Š43â”Š\n+â”Š  â”Š44â”Š    // Check if result is in values range\n+â”Š  â”Š45â”Š    if (utils::isBetween(y, _y1, _y2, \"round\")) {\n+â”Š  â”Š46â”Š      return Nullable<double>(y);\n+â”Š  â”Š47â”Š    }\n+â”Š  â”Š48â”Š\n+â”Š  â”Š49â”Š    return Nullable<double>();\n+â”Š  â”Š50â”Š  }\n+â”Š  â”Š51â”Š\n+â”Š  â”Š52â”Š  // Returns if line has given point\n+â”Š  â”Š53â”Š  bool Line::hasPoint(double x, double y) {\n+â”Š  â”Š54â”Š    if (!boundsHavePoint(x, y)) return 0;\n+â”Š  â”Š55â”Š\n+â”Š  â”Š56â”Š    double m = utils::trim(\n+â”Š  â”Š57â”Š      (_y2 - _y1) / (_x2 - _x1),\n+â”Š  â”Š58â”Š    9, \"exact\");\n+â”Š  â”Š59â”Š\n+â”Š  â”Š60â”Š    return (y - _y1) / (x - _x1) == m;\n+â”Š  â”Š61â”Š  }\n+â”Š  â”Š62â”Š\n+â”Š  â”Š63â”Š  // Returns if given point is contained by the bounds aka cage of line\n+â”Š  â”Š64â”Š  bool Line::boundsHavePoint(double x, double y) {\n+â”Š  â”Š65â”Š    return utils::isBetween(x, _x1, _x2, \"round\") &&\n+â”Š  â”Š66â”Š           utils::isBetween(y, _y1, _y2, \"round\");\n+â”Š  â”Š67â”Š  }\n+â”Š  â”Š68â”Š\n+â”Š  â”Š69â”Š  // line - line intersection method\n+â”Š  â”Š70â”Š  Nullable<Point> Line::getIntersection(Line line) {\n+â”Š  â”Š71â”Š    // Escape if lines are parallel\n+â”Š  â”Š72â”Š    if (!(((_x1 - _x2) * (line._y1 - line._y2)) -\n+â”Š  â”Š73â”Š          ((_y1 - _y2) * (line._x1 - line._x2))))\n+â”Š  â”Š74â”Š      return Nullable<Point>();\n+â”Š  â”Š75â”Š\n+â”Š  â”Š76â”Š    // Intersection point formula\n+â”Š  â”Š77â”Š    double x = utils::trim(\n+â”Š  â”Š78â”Š      ((((_x1 * _y2) - (_y1 * _x2)) * (line._x1 - line._x2)) -\n+â”Š  â”Š79â”Š       ((_x1 - _x2) * ((line._x1 * line._y2) - (line._y1 * line._x2)))) /\n+â”Š  â”Š80â”Š      (((_x1 - _x2) * (line._y1 - line._y2)) - ((_y1 - _y2) *\n+â”Š  â”Š81â”Š        (line._x1 - line._x2)))\n+â”Š  â”Š82â”Š    , 9, \"exact\");\n+â”Š  â”Š83â”Š    double y = utils::trim(\n+â”Š  â”Š84â”Š      ((((_x1 * _y2) - (_y1 * _x2)) * (line._y1 - line._y2)) -\n+â”Š  â”Š85â”Š       ((_y1 - _y2) * ((line._x1 * line._y2) - (line._y1 * line._x2)))) /\n+â”Š  â”Š86â”Š      (((_x1 - _x2) * (line._y1 - line._y2)) - ((_y1 - _y2) *\n+â”Š  â”Š87â”Š        (line._x1 - line._x2)))\n+â”Š  â”Š88â”Š    , 9, \"exact\");\n+â”Š  â”Š89â”Š\n+â”Š  â”Š90â”Š    if (utils::isBetween(x, _x1, _x2, \"round\") &&\n+â”Š  â”Š91â”Š        utils::isBetween(x, line._x1, line._x2, \"round\") &&\n+â”Š  â”Š92â”Š        utils::isBetween(y, _y1, _y2, \"round\") &&\n+â”Š  â”Š93â”Š        utils::isBetween(y, line._y1, line._y2, \"round\")) {\n+â”Š  â”Š94â”Š      return Nullable<Point>({ x, y });\n+â”Š  â”Š95â”Š    }\n+â”Š  â”Š96â”Š\n+â”Š  â”Š97â”Š    return Nullable<Point>();\n+â”Š  â”Š98â”Š  }\n+â”Š  â”Š99â”Š}ðŸš«â†µ\n```\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;geometry&#x2F;line.h\n```diff\n@@ -0,0 +1,30 @@\n+â”Š  â”Š 1â”Š#pragma once\n+â”Š  â”Š 2â”Š\n+â”Š  â”Š 3â”Š#include <vector>\n+â”Š  â”Š 4â”Š#include \"../nullable.h\"\n+â”Š  â”Š 5â”Š#include \"point.h\"\n+â”Š  â”Š 6â”Š\n+â”Š  â”Š 7â”Šnamespace geometry {\n+â”Š  â”Š 8â”Š  class Circle;\n+â”Š  â”Š 9â”Š  class EMCircle;\n+â”Š  â”Š10â”Š\n+â”Š  â”Š11â”Š  class Line {\n+â”Š  â”Š12â”Š  public:\n+â”Š  â”Š13â”Š    double _x1;\n+â”Š  â”Š14â”Š    double _y1;\n+â”Š  â”Š15â”Š    double _x2;\n+â”Š  â”Š16â”Š    double _y2;\n+â”Š  â”Š17â”Š\n+â”Š  â”Š18â”Š    Line(double x1, double y1, double x2, double y2);\n+â”Š  â”Š19â”Š\n+â”Š  â”Š20â”Š    Nullable<double> getMatchingX(double y);\n+â”Š  â”Š21â”Š\n+â”Š  â”Š22â”Š    Nullable<double> getMatchingY(double x);\n+â”Š  â”Š23â”Š\n+â”Š  â”Š24â”Š    bool hasPoint(double x, double y);\n+â”Š  â”Š25â”Š\n+â”Š  â”Š26â”Š    bool boundsHavePoint(double x, double y);\n+â”Š  â”Š27â”Š\n+â”Š  â”Š28â”Š    Nullable<Point> getIntersection(Line line);\n+â”Š  â”Š29â”Š  };\n+â”Š  â”Š30â”Š}ðŸš«â†µ\n```\n\n##### Changed resources&#x2F;cpp&#x2F;src&#x2F;index.cpp\n```diff\n@@ -1,2 +1,3 @@\n â”Š1â”Š1â”Š#include \"nullable.cpp\"\n-â”Š2â”Š â”Š#include \"utils.cpp\"ðŸš«â†µ\n+â”Š â”Š2â”Š#include \"utils.cpp\"\n+â”Š â”Š3â”Š#include \"geometry/line.cpp\"ðŸš«â†µ\n```\n\n[}]: #\n\nAfter creating our C++, we will also need to bind it using EMBind:\n\n[{]: <helper> (diffStep 7.13)\n\n#### [Step 7.13: EMBind CPP line](https://github.com/DAB0mB/radial-snake/commit/8920ddf)\n\n##### Changed resources&#x2F;cpp&#x2F;post.js\n```diff\n@@ -4,6 +4,10 @@\n â”Š 4â”Š 4â”Š    trim: Module.utils_trim,\n â”Š 5â”Š 5â”Š    isBetween: Module.utils_isBetween,\n â”Š 6â”Š 6â”Š    compare: Module.utils_compare\n+â”Š  â”Š 7â”Š  },\n+â”Š  â”Š 8â”Š\n+â”Š  â”Š 9â”Š  Geometry: {\n+â”Š  â”Š10â”Š    Line: Module.geometry_line\n â”Š 7â”Š11â”Š  }\n â”Š 8â”Š12â”Š};\n â”Š 9â”Š13â”Š\n```\n\n##### Changed resources&#x2F;cpp&#x2F;src&#x2F;geometry&#x2F;line.cpp\n```diff\n@@ -1,3 +1,6 @@\n+â”Š â”Š1â”Š#include <vector>\n+â”Š â”Š2â”Š#include <emscripten/bind.h>\n+â”Š â”Š3â”Š#include <emscripten/val.h>\n â”Š1â”Š4â”Š#include \"../nullable.h\"\n â”Š2â”Š5â”Š#include \"../utils.h\"\n â”Š3â”Š6â”Š#include \"point.h\"\n```\n```diff\n@@ -96,4 +99,52 @@\n â”Š 96â”Š 99â”Š\n â”Š 97â”Š100â”Š    return Nullable<Point>();\n â”Š 98â”Š101â”Š  }\n+â”Š   â”Š102â”Š\n+â”Š   â”Š103â”Š  emscripten::val EMLine::getMatchingX(double y) {\n+â”Š   â”Š104â”Š    Nullable<double> nullableX = Line::getMatchingX(y);\n+â”Š   â”Š105â”Š    return nullableX.hasValue() ?\n+â”Š   â”Š106â”Š      emscripten::val(nullableX.getValue()) :\n+â”Š   â”Š107â”Š      emscripten::val::undefined();\n+â”Š   â”Š108â”Š  }\n+â”Š   â”Š109â”Š\n+â”Š   â”Š110â”Š  emscripten::val EMLine::getMatchingY(double x) {\n+â”Š   â”Š111â”Š    Nullable<double> nullableY = Line::getMatchingY(x);\n+â”Š   â”Š112â”Š    return nullableY.hasValue() ?\n+â”Š   â”Š113â”Š      emscripten::val(nullableY.getValue()) :\n+â”Š   â”Š114â”Š      emscripten::val::undefined();\n+â”Š   â”Š115â”Š  }\n+â”Š   â”Š116â”Š\n+â”Š   â”Š117â”Š  emscripten::val EMLine::getIntersection(EMLine emLine) {\n+â”Š   â”Š118â”Š    Line line = Line(emLine._x1, emLine._y1, emLine._x2, emLine._y2);\n+â”Š   â”Š119â”Š    Nullable<Point> nullablePoint = Line::getIntersection(line);\n+â”Š   â”Š120â”Š\n+â”Š   â”Š121â”Š    if (nullablePoint.isNull()) return emscripten::val::undefined();\n+â”Š   â”Š122â”Š\n+â”Š   â”Š123â”Š    Point point = nullablePoint.getValue();\n+â”Š   â”Š124â”Š    emscripten::val emPoint = emscripten::val::object();\n+â”Š   â”Š125â”Š    emPoint.set(\"x\", emscripten::val(point.x));\n+â”Š   â”Š126â”Š    emPoint.set(\"y\", emscripten::val(point.y));\n+â”Š   â”Š127â”Š    return emPoint;\n+â”Š   â”Š128â”Š  }\n+â”Š   â”Š129â”Š}\n+â”Š   â”Š130â”Š\n+â”Š   â”Š131â”ŠEMSCRIPTEN_BINDINGS(geometry_line_module) {\n+â”Š   â”Š132â”Š  emscripten::class_<geometry::Line>(\"geometry_line_base\")\n+â”Š   â”Š133â”Š    .constructor<double, double, double, double>()\n+â”Š   â”Š134â”Š    .property<double>(\"x1\", &geometry::Line::_x1)\n+â”Š   â”Š135â”Š    .property<double>(\"y1\", &geometry::Line::_y1)\n+â”Š   â”Š136â”Š    .property<double>(\"x2\", &geometry::Line::_x2)\n+â”Š   â”Š137â”Š    .property<double>(\"y2\", &geometry::Line::_y2)\n+â”Š   â”Š138â”Š    .function(\"hasPoint\", &geometry::Line::hasPoint)\n+â”Š   â”Š139â”Š    .function(\"boundsHavePoint\", &geometry::Line::boundsHavePoint);\n+â”Š   â”Š140â”Š\n+â”Š   â”Š141â”Š  emscripten::class_<geometry::EMLine, emscripten::base<geometry::Line>>(\"geometry_line\")\n+â”Š   â”Š142â”Š    .constructor<double, double, double, double>()\n+â”Š   â”Š143â”Š    .function(\"getX\", &geometry::EMLine::getMatchingX)\n+â”Š   â”Š144â”Š    .function(\"getY\", &geometry::EMLine::getMatchingY)\n+â”Š   â”Š145â”Š    .function(\"getLineIntersection\",\n+â”Š   â”Š146â”Š      emscripten::select_overload<emscripten::val(geometry::EMLine)>(\n+â”Š   â”Š147â”Š        &geometry::EMLine::getIntersection\n+â”Š   â”Š148â”Š      )\n+â”Š   â”Š149â”Š    );\n â”Š 99â”Š150â”Š}ðŸš«â†µ\n```\n\n##### Changed resources&#x2F;cpp&#x2F;src&#x2F;geometry&#x2F;line.h\n```diff\n@@ -1,6 +1,7 @@\n â”Š1â”Š1â”Š#pragma once\n â”Š2â”Š2â”Š\n â”Š3â”Š3â”Š#include <vector>\n+â”Š â”Š4â”Š#include <emscripten/val.h>\n â”Š4â”Š5â”Š#include \"../nullable.h\"\n â”Š5â”Š6â”Š#include \"point.h\"\n â”Š6â”Š7â”Š\n```\n```diff\n@@ -27,4 +28,15 @@\n â”Š27â”Š28â”Š\n â”Š28â”Š29â”Š    Nullable<Point> getIntersection(Line line);\n â”Š29â”Š30â”Š  };\n+â”Š  â”Š31â”Š\n+â”Š  â”Š32â”Š  class EMLine : public Line {\n+â”Š  â”Š33â”Š  public:\n+â”Š  â”Š34â”Š    using Line::Line;\n+â”Š  â”Š35â”Š\n+â”Š  â”Š36â”Š    emscripten::val getMatchingX(double y);\n+â”Š  â”Š37â”Š\n+â”Š  â”Š38â”Š    emscripten::val getMatchingY(double x);\n+â”Š  â”Š39â”Š\n+â”Š  â”Š40â”Š    emscripten::val getIntersection(EMLine line);\n+â”Š  â”Š41â”Š  };\n â”Š30â”Š42â”Š}ðŸš«â†µ\n```\n\n[}]: #\n\nIn the code snippet above, you can see that we used a special data-type called `val` (`emscripten::val`). `val` means that just like JavaScript, that function can return values that are not necessarily of the same data-type; For instance, the `getMatchingY` function can either return a `number` or `undefined`. If you'll take a look at the `getIntersection(Line)` method you'll notice that instead of returning the raw point structure, I chose to build a JavaScript object using the `object` data type (`emscripten::object`). `object` behaves exactly like a native JavaScript `Object`, and it can save us some precious work of binding which sometimes might be just too much.\n\nIf you'll compare the C++ version of the line class to the JavaScript line class you'll notice that the `draw` and `getIntersection` methods are missing (when we used EMBind we renamed `getIntersection` to `getLineIntersection` because overloadings are forbidden). In addition, Emscripten's API exposes some additional class methods for generated C++ classes, like the `delete` method, which we will shed light on further in this tutorial. Inheritance would be the natural solution for such an issue, unfortunately, generated C++ constructors don't accept indirect instances. For example, if we have a C++ parent class called `Shape` and we have a JavaScript child class called `Line`, we won't be able to initialize a new instance of the `Line` class. Here's a demonstration:\n\n```js\nclass JSLine extends CPPShape {}\nconst line = new JSLine(); // Throws error\n```\n\nThere are 3 ways to implement inheritance when interacting with C++ classes:\n\n- Define an interface when using EMBind. This is the official way but rather complicated, since it requires us to define an extra layer for our wrapper. More information can be found [here](https://kripken.github.io/emscripten-site/docs/porting/connecting_cpp_and_javascript/embind.html#abstract-methods).\n- Extending the prototype of exported C++ classes directly, which is not really an inheritance.\n- Using a proxy class, which is the easiest and cleanest solution of all, but it is not really mentioned anywhere. At the same time, I didn't find any restriction regards that.\n\nWe're gonna use the 3rd method in the list above, because as I said, it's the easiest and cleanest of all. First I will try to explain what I meant by saying \"proxy class\". If you're an intermediate JavaScript developer, you probably know that constructors can be overridden by returning a value explicitly. By doing that, we can actually bypass Emscripten's prohibitions, we can just return the newly created C++ instance and extend it in specific. Proxy classes actually take it a step further by providing a middle-class which will then inject a new link to the prototype chain of the returned instance.\n\n```js\nclass JSLine {\n  constructor() {\n    const line = new CPPShape();\n    return line;\n  }\n}\n\nconst line = new JSLine(); // Legal!\n```\n\n> More information about the code snippet above can be found [here](https://www.bennadel.com/blog/2522-providing-a-return-value-in-a-javascript-constructor.htm).\n\nI believe that as we go through this tutorial, the concept will get much clearer. The utility function of the proxy class should look like so:\n\n[{]: <helper> (diffStep 7.14)\n\n#### [Step 7.14: Add proxy utility method](https://github.com/DAB0mB/radial-snake/commit/06e615e)\n\n##### Changed resources&#x2F;scripts&#x2F;utils.js\n```diff\n@@ -20,5 +20,18 @@\n â”Š20â”Š20â”Š  // Overload handling\n â”Š21â”Š21â”Š  compare(context, num, method, precision = method) {\n â”Š22â”Š22â”Š    return CPP.Utils.compare(context, num, method, precision);\n+â”Š  â”Š23â”Š  },\n+â”Š  â”Š24â”Š\n+â”Š  â”Š25â”Š  proxy(Class) {\n+â”Š  â”Š26â”Š    return class extends Class {\n+â”Š  â”Š27â”Š      constructor() {\n+â”Š  â”Š28â”Š        // Initialize original class\n+â”Š  â”Š29â”Š        let that = new Class(...arguments);\n+â”Š  â”Š30â”Š        // Inject caller's prototype into the prototype chain\n+â”Š  â”Š31â”Š        Object.setPrototypeOf(that, new.target.prototype);\n+â”Š  â”Š32â”Š        // Will original instance will be the substitute for 'this'\n+â”Š  â”Š33â”Š        return that;\n+â”Š  â”Š34â”Š      }\n+â”Š  â”Š35â”Š    }\n â”Š23â”Š36â”Š  }\n â”Š24â”Š37â”Š});ðŸš«â†µ\n```\n\n[}]: #\n\nIf you'll take a look at the following line:\n\n```js\nObject.setPrototypeOf(that, new.target.prototype);\n```\n\nThis is where the magic actually happens! It enables inheritance for explicitly returned objects; This way we can safely extend C++ classes. Accordingly, our new JavaScript line class should look like so:\n\n[{]: <helper> (diffStep 7.15)\n\n#### [Step 7.15: Extend CPP line class](https://github.com/DAB0mB/radial-snake/commit/66acf9d)\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;geometry&#x2F;line.js\n```diff\n@@ -1,46 +1,10 @@\n-â”Š 1â”Š  â”ŠEngine.Geometry.Line = class Line {\n-â”Š 2â”Š  â”Š  // x1 - The first point's x value\n-â”Š 3â”Š  â”Š  // y1 - The first point's y value\n-â”Š 4â”Š  â”Š  // x1 - The second point's x value\n-â”Š 5â”Š  â”Š  // y2 - The second point's y value\n-â”Š 6â”Š  â”Š  constructor(x1, y1, x2, y2) {\n-â”Š 7â”Š  â”Š    this.x1 = Utils.trim(x1, 9);\n-â”Š 8â”Š  â”Š    this.y1 = Utils.trim(y1, 9);\n-â”Š 9â”Š  â”Š    this.x2 = Utils.trim(x2, 9);\n-â”Š10â”Š  â”Š    this.y2 = Utils.trim(y2, 9);\n-â”Š11â”Š  â”Š  }\n-â”Š12â”Š  â”Š\n+â”Š  â”Š 1â”ŠEngine.Geometry.Line = class Line extends Utils.proxy(CPP.Geometry.Line) {\n â”Š13â”Š 2â”Š  // Draws the line on the given context\n â”Š14â”Š 3â”Š  draw(context) {\n â”Š15â”Š 4â”Š    context.moveTo(this.x1, this.y1);\n â”Š16â”Š 5â”Š    context.lineTo(this.x2, this.y2);\n â”Š17â”Š 6â”Š  }\n â”Š18â”Š 7â”Š\n-â”Š19â”Š  â”Š  // Gets the matching x value for a given y value\n-â”Š20â”Š  â”Š  getX(y) {\n-â”Š21â”Š  â”Š    let x = Utils.trim((((y - this.y1) * (this.x2 - this.x1)) / (this.y2 - this.y1)) + this.x1, 9);\n-â”Š22â”Š  â”Š    if (isNaN(x) || Utils.isBetween(x, this.x1, this.x2)) return x;\n-â”Š23â”Š  â”Š  }\n-â”Š24â”Š  â”Š\n-â”Š25â”Š  â”Š  // Gets the matching y value for a given x value\n-â”Š26â”Š  â”Š  getY(x) {\n-â”Š27â”Š  â”Š    let y = Utils.trim((((x - this.x1) * (this.y2 - this.y1)) / (this.x2 - this.x1)) + this.y1, 9);\n-â”Š28â”Š  â”Š    if (isNaN(y) || Utils.isBetween(y, this.y1, this.y2)) return y;\n-â”Š29â”Š  â”Š  }\n-â”Š30â”Š  â”Š\n-â”Š31â”Š  â”Š  // Returns if line has given point\n-â”Š32â”Š  â”Š  hasPoint(x, y) {\n-â”Š33â”Š  â”Š    if (!this.boundsHavePoint(x, y)) return false;\n-â”Š34â”Š  â”Š    let m = Utils.trim((this.y2 - this.y1) / (this.x2 - this.x1), 9);\n-â”Š35â”Š  â”Š    return (y - this.y1) / (x - this.x1) == m;\n-â”Š36â”Š  â”Š  }\n-â”Š37â”Š  â”Š\n-â”Š38â”Š  â”Š  // Returns if given point is contained by the bounds aka cage of line\n-â”Š39â”Š  â”Š  boundsHavePoint(x, y) {\n-â”Š40â”Š  â”Š    return Utils.isBetween(x, this.x1, this.x2) &&\n-â”Š41â”Š  â”Š           Utils.isBetween(y, this.y1, this.y2);\n-â”Š42â”Š  â”Š  }\n-â”Š43â”Š  â”Š\n â”Š44â”Š 8â”Š  getIntersection(shape) {\n â”Š45â”Š 9â”Š    if (shape instanceof Engine.Geometry.Line)\n â”Š46â”Š10â”Š      return this.getLineIntersection(shape);\n```\n```diff\n@@ -50,23 +14,6 @@\n â”Š50â”Š14â”Š      return this.getPolygonIntersection(shape);\n â”Š51â”Š15â”Š  }\n â”Š52â”Š16â”Š\n-â”Š53â”Š  â”Š  // line - line intersection method\n-â”Š54â”Š  â”Š  getLineIntersection(line) {\n-â”Š55â”Š  â”Š    // Escape if lines are parallel\n-â”Š56â”Š  â”Š    if (!(((this.x1 - this.x2) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * (line.x1 - line.x2)))) return;\n-â”Š57â”Š  â”Š\n-â”Š58â”Š  â”Š    // Intersection point formula\n-â”Š59â”Š  â”Š    let x = Utils.trim(((((this.x1 * this.y2) - (this.y1 * this.x2)) * (line.x1 - line.x2)) - ((this.x1 - this.x2) * ((line.x1 * line.y2) - (line.y1 * line.x2)))) /\n-â”Š60â”Š  â”Š        (((this.x1 - this.x2) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * (line.x1 - line.x2))), 9);\n-â”Š61â”Š  â”Š    let y = Utils.trim(((((this.x1 * this.y2) - (this.y1 * this.x2)) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * ((line.x1 * line.y2) - (line.y1 * line.x2)))) /\n-â”Š62â”Š  â”Š        (((this.x1 - this.x2) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * (line.x1 - line.x2))), 9);\n-â”Š63â”Š  â”Š\n-â”Š64â”Š  â”Š    if (Utils.isBetween(x, this.x1, this.x2) && Utils.isBetween(x, line.x1, line.x2) &&\n-â”Š65â”Š  â”Š        Utils.isBetween(y, this.y1, this.y2) && Utils.isBetween(y, line.y1, line.y2)) {\n-â”Š66â”Š  â”Š      return { x, y };\n-â”Š67â”Š  â”Š    }\n-â”Š68â”Š  â”Š  }\n-â”Š69â”Š  â”Š\n â”Š70â”Š17â”Š  // line - circle intersection method\n â”Š71â”Š18â”Š  getCircleIntersection(circle) {\n â”Š72â”Š19â”Š    return circle.getLineIntersection(this);\n```\n\n[}]: #\n\nBy now, our tests should pass. Accept, there is memory leak we need to handle. But you probably ask yourself - \"What memory leak? It's JavaScript man! Have you ever heard of something called garbage collector?!\". Well, this is not the case when compiling C++ code with Emscripten. You see, Emscripten uses asm.js, which is a subset for JavaScript built exactly for these proposes, enabling C++ modules run on the browser. This is how the [WebGL](https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API) project actually started, an almost complete conversion from the famous C++ [OpenGL](https://www.opengl.org/) to JavaScript. Part of what asm.js does, it disables the garbage collector, and instead, it holds raw pointers, just like in C++. Since returned class instances are pointers with unknown lifespans, they need to be disposed manually, using the `delete` method (identical to how we clear memory from the Heap in C++). Let's dispose unused test data by calling the `delete` method as just mentioned:\n\n[{]: <helper> (diffStep 7.16)\n\n#### [Step 7.16: Delete line instances in tests](https://github.com/DAB0mB/radial-snake/commit/f181da4)\n\n##### Changed resources&#x2F;scripts&#x2F;specs&#x2F;engine&#x2F;geometry&#x2F;circle.js\n```diff\n@@ -111,6 +111,8 @@\n â”Š111â”Š111â”Š          { x: 6, y: 1 },\n â”Š112â”Š112â”Š          { x: -4, y: 1 }\n â”Š113â”Š113â”Š        ]);\n+â”Š   â”Š114â”Š\n+â”Š   â”Š115â”Š        line.delete();\n â”Š114â”Š116â”Š      });\n â”Š115â”Š117â”Š    });\n â”Š116â”Š118â”Š\n```\n```diff\n@@ -121,6 +123,8 @@\n â”Š121â”Š123â”Š        expect(this.circle.getLineIntersection(line)).toEqual([\n â”Š122â”Š124â”Š          { x: -4, y: 1 }\n â”Š123â”Š125â”Š        ]);\n+â”Š   â”Š126â”Š\n+â”Š   â”Š127â”Š        line.delete();\n â”Š124â”Š128â”Š      });\n â”Š125â”Š129â”Š    });\n â”Š126â”Š130â”Š\n```\n```diff\n@@ -131,6 +135,8 @@\n â”Š131â”Š135â”Š        expect(this.circle.getLineIntersection(line)).toEqual([\n â”Š132â”Š136â”Š          { x: 1, y: 6 }\n â”Š133â”Š137â”Š        ]);\n+â”Š   â”Š138â”Š\n+â”Š   â”Š139â”Š        line.delete();\n â”Š134â”Š140â”Š      });\n â”Š135â”Š141â”Š    });\n â”Š136â”Š142â”Š\n```\n```diff\n@@ -138,6 +144,7 @@\n â”Š138â”Š144â”Š      it(\"returns nothing\", function() {\n â”Š139â”Š145â”Š        let line = new Engine.Geometry.Line(-10, 10, 10, 10);\n â”Š140â”Š146â”Š        expect(this.circle.getLineIntersection(line)).toBeUndefined();\n+â”Š   â”Š147â”Š        line.delete();\n â”Š141â”Š148â”Š      });\n â”Š142â”Š149â”Š    });\n â”Š143â”Š150â”Š  });\n```\n\n##### Changed resources&#x2F;scripts&#x2F;specs&#x2F;engine&#x2F;geometry&#x2F;line.js\n```diff\n@@ -3,6 +3,10 @@\n â”Š 3â”Š 3â”Š    this.line = new Engine.Geometry.Line(-5, -5, 5, 5);\n â”Š 4â”Š 4â”Š  });\n â”Š 5â”Š 5â”Š\n+â”Š  â”Š 6â”Š  afterEach(function () {\n+â”Š  â”Š 7â”Š    this.line.delete();\n+â”Š  â”Š 8â”Š  });\n+â”Š  â”Š 9â”Š\n â”Š 6â”Š10â”Š  describe(\"getX method\", function() {\n â”Š 7â”Š11â”Š    describe(\"given inranged y\", function() {\n â”Š 8â”Š12â”Š      it(\"returns x\", function() {\n```\n```diff\n@@ -58,6 +62,8 @@\n â”Š58â”Š62â”Š          x: 1,\n â”Š59â”Š63â”Š          y: 1\n â”Š60â”Š64â”Š        });\n+â”Š  â”Š65â”Š\n+â”Š  â”Š66â”Š        line.delete();\n â”Š61â”Š67â”Š      });\n â”Š62â”Š68â”Š    });\n â”Š63â”Š69â”Š\n```\n```diff\n@@ -65,6 +71,7 @@\n â”Š65â”Š71â”Š      it(\"returns nothing\", function() {\n â”Š66â”Š72â”Š        let line = new Engine.Geometry.Line(-5, -6, 5, 4);\n â”Š67â”Š73â”Š        expect(this.line.getLineIntersection(line)).toBeUndefined();\n+â”Š  â”Š74â”Š        line.delete();\n â”Š68â”Š75â”Š      });\n â”Š69â”Š76â”Š    });\n â”Š70â”Š77â”Š\n```\n```diff\n@@ -72,6 +79,7 @@\n â”Š72â”Š79â”Š      it(\"returns nothing\", function() {\n â”Š73â”Š80â”Š        let line = new Engine.Geometry.Line(10, 10, 10, 15);\n â”Š74â”Š81â”Š        expect(this.line.getLineIntersection(line)).toBeUndefined();\n+â”Š  â”Š82â”Š        line.delete();\n â”Š75â”Š83â”Š      });\n â”Š76â”Š84â”Š    });\n â”Š77â”Š85â”Š  });\n```\n\n##### Changed resources&#x2F;scripts&#x2F;specs&#x2F;engine&#x2F;geometry&#x2F;polygon.js\n```diff\n@@ -35,6 +35,8 @@\n â”Š35â”Š35â”Š          { x: 5, y: 4 },\n â”Š36â”Š36â”Š          { x: 0, y: 1 }\n â”Š37â”Š37â”Š        ]);\n+â”Š  â”Š38â”Š\n+â”Š  â”Š39â”Š        line.delete();\n â”Š38â”Š40â”Š      });\n â”Š39â”Š41â”Š    });\n â”Š40â”Š42â”Š\n```\n```diff\n@@ -43,6 +45,8 @@\n â”Š43â”Š45â”Š        let line = new Engine.Geometry.Line(10, 11, 15, 14);\n â”Š44â”Š46â”Š\n â”Š45â”Š47â”Š        expect(this.polygon.getLineIntersection(line)).toBeUndefined();\n+â”Š  â”Š48â”Š\n+â”Š  â”Š49â”Š        line.delete();\n â”Š46â”Š50â”Š      });\n â”Š47â”Š51â”Š    });\n â”Š48â”Š52â”Š  });\n```\n\n[}]: #\n\nSince our game also uses polygons, which is made of an abstract number of lines, its test-data needs to be disposed as well. First, we will add a `delete` method to the polygon class, which will simply go though all its bounds and delete each of its lines:\n\n[{]: <helper> (diffStep 7.17)\n\n#### [Step 7.17: Add polygon deletion method](https://github.com/DAB0mB/radial-snake/commit/1c9447f)\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;geometry&#x2F;polygon.js\n```diff\n@@ -5,6 +5,10 @@\n â”Š 5â”Š 5â”Š    this.bounds = bounds.map(coords => new Engine.Geometry.Line(...coords));\n â”Š 6â”Š 6â”Š  }\n â”Š 7â”Š 7â”Š\n+â”Š  â”Š 8â”Š  delete() {\n+â”Š  â”Š 9â”Š    this.bounds.forEach(bound => bound.delete());\n+â”Š  â”Š10â”Š  }\n+â”Š  â”Š11â”Š\n â”Š 8â”Š12â”Š  // Returns if polygon has given point\n â”Š 9â”Š13â”Š  hasPoint(x, y) {\n â”Š10â”Š14â”Š    // Run check for each bound\n```\n\n[}]: #\n\nNow we can conveniently delete unused polygons in the tests:\n\n[{]: <helper> (diffStep 7.18)\n\n#### [Step 7.18: Delete polygon instances in tests](https://github.com/DAB0mB/radial-snake/commit/48024bc)\n\n##### Changed resources&#x2F;scripts&#x2F;specs&#x2F;engine&#x2F;geometry&#x2F;polygon.js\n```diff\n@@ -8,6 +8,10 @@\n â”Š 8â”Š 8â”Š    );\n â”Š 9â”Š 9â”Š  });\n â”Š10â”Š10â”Š\n+â”Š  â”Š11â”Š  afterEach(function () {\n+â”Š  â”Š12â”Š    this.polygon.delete();\n+â”Š  â”Š13â”Š  });\n+â”Š  â”Š14â”Š\n â”Š11â”Š15â”Š  describe(\"hasPoint method\", function() {\n â”Š12â”Š16â”Š    describe(\"given contained point\", function() {\n â”Š13â”Š17â”Š      it(\"returns true\", function() {\n```\n\n[}]: #\n\nMoving on, we have the circle class to transform. The process is almost the identical to how we transformed the line class, so it's gonna be way easier now. We first start by translating our code from JavaScript to C++:\n\n[{]: <helper> (diffStep 7.19)\n\n#### [Step 7.19: Add base circle CPP module](https://github.com/DAB0mB/radial-snake/commit/1a3fa58)\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;geometry&#x2F;circle.cpp\n```diff\n@@ -0,0 +1,202 @@\n+â”Š   â”Š  1â”Š\n+â”Š   â”Š  2â”Š#include <algorithm>\n+â”Š   â”Š  3â”Š#include <cmath>\n+â”Š   â”Š  4â”Š#include <vector>\n+â”Š   â”Š  5â”Š#include \"../nullable.h\"\n+â”Š   â”Š  6â”Š#include \"../utils.h\"\n+â”Š   â”Š  7â”Š#include \"point.h\"\n+â”Š   â”Š  8â”Š#include \"line.h\"\n+â”Š   â”Š  9â”Š\n+â”Š   â”Š 10â”Šnamespace geometry {\n+â”Š   â”Š 11â”Š  // x - The x value of the circle's center\n+â”Š   â”Š 12â”Š  // y - The y value of the circle's center\n+â”Š   â”Š 13â”Š  // r - The radius of the center\n+â”Š   â”Š 14â”Š  // rad1 - The first radian of the circle, not necessarily its beginning\n+â”Š   â”Š 15â”Š  // rad2 - The second radian of the circle, not necessarily its beginning\n+â”Š   â”Š 16â”Š  Circle::Circle(double x, double y, double r, double rad1, double rad2) {\n+â”Š   â”Š 17â”Š    _x = utils::trim(x, 9);\n+â”Š   â”Š 18â”Š    _y = utils::trim(y, 9);\n+â”Š   â”Š 19â”Š    _r = utils::trim(r, 9);\n+â”Š   â”Š 20â”Š\n+â”Š   â”Š 21â”Š    // Trimming mode is done based on which radian represents the ending and which radian\n+â”Š   â”Š 22â”Š    // represents the ending\n+â”Š   â”Š 23â”Š    if (rad1 > rad2) {\n+â”Š   â”Š 24â”Š      _rad1 = utils::trim(rad1, 9, \"floor\");\n+â”Š   â”Š 25â”Š      _rad2 = utils::trim(rad2, 9, \"ceil\");\n+â”Š   â”Š 26â”Š    }\n+â”Š   â”Š 27â”Š    else {\n+â”Š   â”Š 28â”Š      _rad1 = utils::trim(rad1, 9, \"ceil\");\n+â”Š   â”Š 29â”Š      _rad2 = utils::trim(rad2, 9, \"floor\");\n+â”Š   â”Š 30â”Š    }\n+â”Š   â”Š 31â”Š  }\n+â”Š   â”Š 32â”Š\n+â”Š   â”Š 33â”Š  // Gets the matching x value for the given radian\n+â”Š   â”Š 34â”Š  Nullable<double> Circle::getMatchingX(double rad) {\n+â”Š   â”Š 35â”Š    if (!utils::chain(rad)->trim(9)->isBetween(_rad1, _rad2)->result()) {\n+â”Š   â”Š 36â”Š      return Nullable<double>();\n+â”Š   â”Š 37â”Š    }\n+â”Š   â”Š 38â”Š\n+â”Š   â”Š 39â”Š    return Nullable<double>(utils::trim((_r * std::cos(rad)) + _x, 9));\n+â”Š   â”Š 40â”Š  }\n+â”Š   â”Š 41â”Š\n+â”Š   â”Š 42â”Š  // Gets the matching y value for the given radian\n+â”Š   â”Š 43â”Š  Nullable<double> Circle::getMatchingY(double rad) {\n+â”Š   â”Š 44â”Š    if (!utils::chain(rad)->trim(9)->isBetween(_rad1, _rad2)->result()) {\n+â”Š   â”Š 45â”Š      return Nullable<double>();\n+â”Š   â”Š 46â”Š    }\n+â”Š   â”Š 47â”Š\n+â”Š   â”Š 48â”Š    return Nullable<double>(utils::trim((_r * std::sin(rad)) + _y, 9));\n+â”Š   â”Š 49â”Š  }\n+â”Š   â”Š 50â”Š\n+â”Š   â”Š 51â”Š  // Gets the matching point for the given radian\n+â”Š   â”Š 52â”Š  Nullable<Point> Circle::getMatchingPoint(double rad) {\n+â”Š   â”Š 53â”Š    if (!utils::isBetween(rad, _rad1, _rad2)) {\n+â”Š   â”Š 54â”Š      return Nullable<Point>();\n+â”Š   â”Š 55â”Š    }\n+â”Š   â”Š 56â”Š\n+â”Š   â”Š 57â”Š    return Nullable<Point>({\n+â”Š   â”Š 58â”Š      utils::trim((_r * std::cos(rad)) + _x, 9),\n+â”Š   â”Š 59â”Š      utils::trim((_r * std::sin(rad)) + _y, 9)\n+â”Š   â”Š 60â”Š    });\n+â”Š   â”Š 61â”Š  }\n+â”Š   â”Š 62â”Š\n+â”Š   â”Š 63â”Š  // Gets the matching radian for the given point\n+â”Š   â”Š 64â”Š  Nullable<double> Circle::getMatchingRad(double x, double y) {\n+â”Š   â”Š 65â”Š    double rad = std::atan2(y - _y, x - _x);\n+â”Š   â”Š 66â”Š\n+â”Š   â”Š 67â”Š    // If calculated radian is in circle's radian range, return it\n+â”Š   â”Š 68â”Š    if (!std::isnan(rad) && utils::isBetween(rad, _rad1, _rad2)) {\n+â”Š   â”Š 69â”Š      return Nullable<double>(rad);\n+â”Š   â”Š 70â”Š    }\n+â”Š   â”Š 71â”Š\n+â”Š   â”Š 72â”Š    // The calculated radian can still be in the circle's radian range in case one\n+â”Š   â”Š 73â”Š    // of the radians is greater than 2 PIEs\n+â”Š   â”Š 74â”Š    double greatestRad = std::abs(_rad1) > std::abs(_rad2) ? _rad1 : _rad2;\n+â”Š   â”Š 75â”Š\n+â”Š   â”Š 76â”Š    // Check if the absolute radian is in the circle's radian range\n+â”Š   â”Š 77â”Š    if (utils::chain(rad + (2 * M_PI * std::floor(greatestRad / (2 * M_PI))))\n+â”Š   â”Š 78â”Š        ->trim(9)->isBetween(_rad1, _rad2)->result() ||\n+â”Š   â”Š 79â”Š        utils::chain(rad + (2 * M_PI * std::ceil(greatestRad / (2 * M_PI))))\n+â”Š   â”Š 80â”Š        ->trim(9)->isBetween(_rad1, _rad2)->result()) {\n+â”Š   â”Š 81â”Š      return Nullable<double>(rad);\n+â”Š   â”Š 82â”Š    }\n+â”Š   â”Š 83â”Š\n+â”Š   â”Š 84â”Š    return Nullable<double>();\n+â”Š   â”Š 85â”Š  }\n+â”Š   â”Š 86â”Š\n+â”Š   â”Š 87â”Š  // Returns if circle has given points\n+â”Š   â”Š 88â”Š  bool Circle::hasPoint(double x, double y) {\n+â”Š   â”Š 89â”Š    return getMatchingRad(x, y).hasValue();\n+â”Š   â”Š 90â”Š  }\n+â”Š   â”Š 91â”Š\n+â”Š   â”Š 92â”Š  // circle - circle intersection method\n+â”Š   â”Š 93â”Š  Nullable<std::vector<Point>> Circle::getIntersection(Circle circle) {\n+â”Š   â”Š 94â”Š    double dx = circle._x - _x;\n+â”Š   â”Š 95â”Š    double dy = circle._y - _y;\n+â”Š   â”Š 96â”Š    double d = std::sqrt(std::pow(dx, 2) + std::pow(dy, 2));\n+â”Š   â”Š 97â”Š\n+â”Š   â”Š 98â”Š    if (d > _r + circle._r ||\n+â”Š   â”Š 99â”Š       d < std::abs(_r - circle._r)) {\n+â”Š   â”Š100â”Š      return Nullable<std::vector<Point>>();\n+â”Š   â”Š101â”Š    }\n+â”Š   â”Š102â”Š\n+â”Š   â”Š103â”Š    double a = ((std::pow(_r, 2) - std::pow(circle._r, 2)) + std::pow(d, 2)) / (2 * d);\n+â”Š   â”Š104â”Š    double x = _x + ((dx * a) / d);\n+â”Š   â”Š105â”Š    double y = _y + ((dy * a) / d);\n+â”Š   â”Š106â”Š    double h = std::sqrt(std::pow(_r, 2) - std::pow(a, 2));\n+â”Š   â”Š107â”Š    double rx = (- dy * h) / d;\n+â”Š   â”Š108â”Š    double ry = (dx * h) / d;\n+â”Š   â”Š109â”Š\n+â”Š   â”Š110â”Š    std::vector<Point> interPoints(2);\n+â”Š   â”Š111â”Š    interPoints.at(0).x = x + rx;\n+â”Š   â”Š112â”Š    interPoints.at(0).y = y + ry;\n+â”Š   â”Š113â”Š    interPoints.at(1).x = x - rx;\n+â”Š   â”Š114â”Š    interPoints.at(1).y = y - ry;\n+â”Š   â”Š115â”Š\n+â”Š   â”Š116â”Š    for (unsigned i = 0; i < interPoints.size(); i++) {\n+â”Š   â”Š117â”Š      Point& point = interPoints.at(i);\n+â”Š   â”Š118â”Š      point.x = utils::trim(point.x, 9);\n+â”Š   â”Š119â”Š      point.y = utils::trim(point.y, 9);\n+â”Š   â”Š120â”Š    }\n+â”Š   â”Š121â”Š\n+â”Š   â”Š122â”Š    auto pointsBegin = std::unique(interPoints.begin(), interPoints.end(),\n+â”Š   â”Š123â”Š      [](Point pointA, Point pointB) {\n+â”Š   â”Š124â”Š        return pointA.x == pointB.x && pointA.y == pointB.y;\n+â”Š   â”Š125â”Š      }\n+â”Š   â”Š126â”Š    );\n+â”Š   â”Š127â”Š\n+â”Š   â”Š128â”Š    interPoints.erase(pointsBegin, interPoints.end());\n+â”Š   â”Š129â”Š\n+â”Š   â”Š130â”Š    std::vector<Circle> circles = { *this, circle };\n+â”Š   â”Š131â”Š\n+â”Š   â”Š132â”Š    std::for_each(circles.begin(), circles.end(), [&interPoints](Circle circle) {\n+â”Š   â”Š133â”Š      auto pointsBegin = std::remove_if(interPoints.begin(), interPoints.end(),\n+â”Š   â”Š134â”Š        [&circle](Point point) {\n+â”Š   â”Š135â”Š          return !circle.hasPoint(point.x, point.y);\n+â”Š   â”Š136â”Š        }\n+â”Š   â”Š137â”Š      );\n+â”Š   â”Š138â”Š\n+â”Š   â”Š139â”Š      interPoints.erase(pointsBegin, interPoints.end());\n+â”Š   â”Š140â”Š    });\n+â”Š   â”Š141â”Š\n+â”Š   â”Š142â”Š    if (interPoints.size()) {\n+â”Š   â”Š143â”Š      return Nullable<std::vector<Point>>(interPoints);\n+â”Š   â”Š144â”Š    }\n+â”Š   â”Š145â”Š\n+â”Š   â”Š146â”Š    return Nullable<std::vector<Point>>();\n+â”Š   â”Š147â”Š  }\n+â”Š   â”Š148â”Š\n+â”Š   â”Š149â”Š  // circle - line intersection method\n+â”Š   â”Š150â”Š  Nullable<std::vector<Point>> Circle::getIntersection(Line line) {\n+â”Š   â”Š151â”Š    double x1 = line._x1 - _x;\n+â”Š   â”Š152â”Š    double x2 = line._x2 - _x;\n+â”Š   â”Š153â”Š    double y1 = line._y1 - _y;\n+â”Š   â”Š154â”Š    double y2 = line._y2 - _y;\n+â”Š   â”Š155â”Š    double dx = x2 - x1;\n+â”Š   â”Š156â”Š    double dy = y2 - y1;\n+â”Š   â”Š157â”Š    double d = std::sqrt(std::pow(dx, 2) + std::pow(dy, 2));\n+â”Š   â”Š158â”Š    double h = (x1 * y2) - (x2 * y1);\n+â”Š   â”Š159â”Š    double delta = (std::pow(_r, 2) * std::pow(d, 2)) - std::pow(h, 2);\n+â”Š   â”Š160â”Š\n+â”Š   â”Š161â”Š    if (delta < 0) Nullable<std::vector<Point>>();\n+â”Š   â”Š162â”Š\n+â”Š   â”Š163â”Š    double sign = dy / std::abs(dy); if (std::isnan(sign)) sign = 1;\n+â”Š   â”Š164â”Š    double sqrtx = sign * dx * std::sqrt(delta);\n+â”Š   â”Š165â”Š    double sqrty = std::abs(dy) * std::sqrt(delta);\n+â”Š   â”Š166â”Š\n+â”Š   â”Š167â”Š    std::vector<Point> interPoints(2);\n+â”Š   â”Š168â”Š    interPoints.at(0).x = (((h * dy) + sqrtx) / std::pow(d, 2)) + _x;\n+â”Š   â”Š169â”Š    interPoints.at(0).y = (((-h * dx) + sqrty) / std::pow(d, 2)) + _y;\n+â”Š   â”Š170â”Š    interPoints.at(1).x = (((h * dy) - sqrtx) / std::pow(d, 2)) + _x;\n+â”Š   â”Š171â”Š    interPoints.at(1).y = (((-h * dx) - sqrty) / std::pow(d, 2)) + _y;\n+â”Š   â”Š172â”Š\n+â”Š   â”Š173â”Š    for (unsigned i = 0; i < interPoints.size(); i++) {\n+â”Š   â”Š174â”Š      Point& point = interPoints.at(i);\n+â”Š   â”Š175â”Š      point.x = utils::trim(point.x, 9);\n+â”Š   â”Š176â”Š      point.y = utils::trim(point.y, 9);\n+â”Š   â”Š177â”Š    }\n+â”Š   â”Š178â”Š\n+â”Š   â”Š179â”Š    auto pointsBegin = std::remove_if(interPoints.begin(), interPoints.end(),\n+â”Š   â”Š180â”Š      [this, &line](Point point) {\n+â”Š   â”Š181â”Š        return !hasPoint(point.x, point.y) ||\n+â”Š   â”Š182â”Š          !line.boundsHavePoint(point.x, point.y);\n+â”Š   â”Š183â”Š      }\n+â”Š   â”Š184â”Š    );\n+â”Š   â”Š185â”Š\n+â”Š   â”Š186â”Š    interPoints.erase(pointsBegin, interPoints.end());\n+â”Š   â”Š187â”Š\n+â”Š   â”Š188â”Š    pointsBegin = std::unique(interPoints.begin(), interPoints.end(),\n+â”Š   â”Š189â”Š      [](Point pointA, Point pointB) {\n+â”Š   â”Š190â”Š        return pointA.x == pointB.x && pointA.y == pointB.y;\n+â”Š   â”Š191â”Š      }\n+â”Š   â”Š192â”Š    );\n+â”Š   â”Š193â”Š\n+â”Š   â”Š194â”Š    interPoints.erase(pointsBegin, interPoints.end());\n+â”Š   â”Š195â”Š\n+â”Š   â”Š196â”Š    if (interPoints.size()) {\n+â”Š   â”Š197â”Š      return Nullable<std::vector<Point>>(interPoints);\n+â”Š   â”Š198â”Š    }\n+â”Š   â”Š199â”Š\n+â”Š   â”Š200â”Š    return Nullable<std::vector<Point>>();\n+â”Š   â”Š201â”Š  }\n+â”Š   â”Š202â”Š}ðŸš«â†µ\n```\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;geometry&#x2F;circle.h\n```diff\n@@ -0,0 +1,35 @@\n+â”Š  â”Š 1â”Š#pragma once\n+â”Š  â”Š 2â”Š\n+â”Š  â”Š 3â”Š#include <vector>\n+â”Š  â”Š 4â”Š#include \"../nullable.h\"\n+â”Š  â”Š 5â”Š#include \"point.h\"\n+â”Š  â”Š 6â”Š#include \"line.h\"\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Šnamespace geometry {\n+â”Š  â”Š 9â”Š  class Line;\n+â”Š  â”Š10â”Š\n+â”Š  â”Š11â”Š  class Circle {\n+â”Š  â”Š12â”Š  public:\n+â”Š  â”Š13â”Š    double _x;\n+â”Š  â”Š14â”Š    double _y;\n+â”Š  â”Š15â”Š    double _r;\n+â”Š  â”Š16â”Š    double _rad1;\n+â”Š  â”Š17â”Š    double _rad2;\n+â”Š  â”Š18â”Š\n+â”Š  â”Š19â”Š    Circle(double x, double y, double r, double rad1, double rad2);\n+â”Š  â”Š20â”Š\n+â”Š  â”Š21â”Š    Nullable<double> getMatchingX(double rad);\n+â”Š  â”Š22â”Š\n+â”Š  â”Š23â”Š    Nullable<double> getMatchingY(double rad);\n+â”Š  â”Š24â”Š\n+â”Š  â”Š25â”Š    Nullable<Point> getMatchingPoint(double rad);\n+â”Š  â”Š26â”Š\n+â”Š  â”Š27â”Š    Nullable<double> getMatchingRad(double x, double y);\n+â”Š  â”Š28â”Š\n+â”Š  â”Š29â”Š    bool hasPoint(double x, double y);\n+â”Š  â”Š30â”Š\n+â”Š  â”Š31â”Š    Nullable<std::vector<Point>> getIntersection(Circle circle);\n+â”Š  â”Š32â”Š\n+â”Š  â”Š33â”Š    Nullable<std::vector<Point>> getIntersection(Line line);\n+â”Š  â”Š34â”Š  };\n+â”Š  â”Š35â”Š}ðŸš«â†µ\n```\n\n##### Changed resources&#x2F;cpp&#x2F;src&#x2F;index.cpp\n```diff\n@@ -1,3 +1,4 @@\n â”Š1â”Š1â”Š#include \"nullable.cpp\"\n â”Š2â”Š2â”Š#include \"utils.cpp\"\n-â”Š3â”Š â”Š#include \"geometry/line.cpp\"ðŸš«â†µ\n+â”Š â”Š3â”Š#include \"geometry/line.cpp\"\n+â”Š â”Š4â”Š#include \"geometry/circle.cpp\"ðŸš«â†µ\n```\n\n[}]: #\n\nSecond, we need to wrap our code using EMBind:\n\n[{]: <helper> (diffStep 7.2)\n\n#### [Step 7.2: Add base utility CPP module](https://github.com/DAB0mB/radial-snake/commit/6dba512)\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;utils.cpp\n```diff\n@@ -0,0 +1,73 @@\n+â”Š  â”Š 1â”Š#include <cfloat>\n+â”Š  â”Š 2â”Š#include <cmath>\n+â”Š  â”Š 3â”Š#include <string>\n+â”Š  â”Š 4â”Š#include \"utils.h\"\n+â”Š  â”Š 5â”Š\n+â”Š  â”Š 6â”Šnamespace utils {\n+â”Š  â”Š 7â”Š  // Fixed modulo method which can calculate modulo of negative numbers properly\n+â”Š  â”Š 8â”Š  // e.g. (-803).mod(800) returns 797\n+â”Š  â”Š 9â”Š  double mod(double context, double num) {\n+â”Š  â”Š10â”Š    return std::fmod((std::fmod(context, num) + num), num);\n+â”Š  â”Š11â”Š  }\n+â”Š  â”Š12â”Š\n+â”Š  â”Š13â”Š  // Trims number and leaves the number of decimals specified.\n+â”Š  â”Š14â”Š  // The \"mode\" argument specifies which math function should be invoked\n+â”Š  â”Š15â”Š  // right after the number has been trimmed.\n+â”Š  â”Š16â”Š  // e.g. 12.12345.trim(3, \"ceil\") returns 12.124\n+â”Š  â”Š17â”Š  double trim(double context, int decimals, const std::string mode) {\n+â”Š  â”Š18â”Š    double accumulator = context * std::pow(10, decimals);\n+â”Š  â”Š19â”Š\n+â”Š  â”Š20â”Š    if (mode.compare(\"ceil\") == 0)\n+â”Š  â”Š21â”Š      accumulator = std::ceil(accumulator);\n+â”Š  â”Š22â”Š    else if (mode.compare(\"floor\") == 0)\n+â”Š  â”Š23â”Š      accumulator = std::floor(accumulator);\n+â”Š  â”Š24â”Š    else\n+â”Š  â”Š25â”Š      accumulator = std::round(accumulator);\n+â”Š  â”Š26â”Š\n+â”Š  â”Š27â”Š    return accumulator / std::pow(10, decimals);\n+â”Š  â”Š28â”Š  }\n+â”Š  â”Š29â”Š\n+â”Š  â”Š30â”Š  // Tells if number is in specified range based on given precision.\n+â”Š  â”Š31â”Š  // See the \"compare\" method for more information about precision\n+â”Š  â”Š32â”Š  bool isBetween(double context, double num1, double num2, const std::string precision) {\n+â”Š  â”Š33â”Š    return compare(context, std::min(num1, num2), \">=\", precision) &&\n+â”Š  â”Š34â”Š           compare(context, std::max(num1, num2), \"<=\", precision);\n+â”Š  â”Š35â”Š  }\n+â”Š  â”Š36â”Š\n+â”Š  â”Š37â”Š  bool compare(double context, double num, const std::string precision) {\n+â”Š  â”Š38â”Š    return compare(context, num, \"==\", precision);\n+â”Š  â”Š39â”Š  }\n+â”Š  â”Š40â”Š\n+â”Š  â”Š41â”Š  // Initiates comparison operator between context number and a given number, only here\n+â”Š  â”Š42â”Š  // a precision can be specified\n+â”Š  â”Š43â”Š  bool compare(double context, double num, const std::string method, const std::string precision) {\n+â”Š  â”Š44â”Š    // Fixed precision, \"almost equal\" with a deviation of Îµ\n+â”Š  â”Š45â”Š    if (precision.compare(\"f\") == 0) {\n+â”Š  â”Š46â”Š      if (method.compare(\"<\") == 0 ||\n+â”Š  â”Š47â”Š          method.compare(\"<=\") == 0)\n+â”Š  â”Š48â”Š        return context <= num + DBL_EPSILON;\n+â”Š  â”Š49â”Š      if (method.compare(\">\") == 0 ||\n+â”Š  â”Š50â”Š          method.compare(\">=\") == 0)\n+â”Š  â”Š51â”Š        return context >= num - DBL_EPSILON;\n+â”Š  â”Š52â”Š      return std::abs(context - num) <= DBL_EPSILON;\n+â”Š  â”Š53â”Š    }\n+â”Š  â”Š54â”Š    // Pixel precision, round comparison\n+â”Š  â”Š55â”Š    else if (precision.compare(\"px\") == 0) {\n+â”Š  â”Š56â”Š      if (method.compare(\"<\") == 0 ||\n+â”Š  â”Š57â”Š          method.compare(\"<=\") == 0)\n+â”Š  â”Š58â”Š        return std::round(context) <= std::round(num);\n+â”Š  â”Š59â”Š      if (method.compare(\">\") == 0 ||\n+â”Š  â”Š60â”Š          method.compare(\">=\") == 0)\n+â”Š  â”Š61â”Š        return std::round(context) >= std::round(num);\n+â”Š  â”Š62â”Š      return std::round(context) == std::round(num);\n+â”Š  â”Š63â”Š    }\n+â”Š  â”Š64â”Š    // Exact precision\n+â”Š  â”Š65â”Š    else {\n+â”Š  â”Š66â”Š      if (method.compare(\"<\") == 0) return context < num;\n+â”Š  â”Š67â”Š      if (method.compare(\"<=\") == 0) return context <= num;\n+â”Š  â”Š68â”Š      if (method.compare(\">\") == 0) return context > num;\n+â”Š  â”Š69â”Š      if (method.compare(\">=\") == 0) return context >= num;\n+â”Š  â”Š70â”Š      return context == num;\n+â”Š  â”Š71â”Š    }\n+â”Š  â”Š72â”Š  }\n+â”Š  â”Š73â”Š}ðŸš«â†µ\n```\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;utils.h\n```diff\n@@ -0,0 +1,15 @@\n+â”Š  â”Š 1â”Š#pragma once\n+â”Š  â”Š 2â”Š\n+â”Š  â”Š 3â”Š#include <string>\n+â”Š  â”Š 4â”Š\n+â”Š  â”Š 5â”Šnamespace utils {\n+â”Š  â”Š 6â”Š  double mod(double context, double num);\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Š  double trim(double context, int decimals, const std::string mode = \"round\");\n+â”Š  â”Š 9â”Š\n+â”Š  â”Š10â”Š  bool isBetween(double context, double num1, double num2, const std::string precision = \"exact\");\n+â”Š  â”Š11â”Š\n+â”Š  â”Š12â”Š  bool compare(double context, double num, const std::string precision = \"exact\");\n+â”Š  â”Š13â”Š\n+â”Š  â”Š14â”Š  bool compare(double context, double num, const std::string method, const std::string precision);\n+â”Š  â”Š15â”Š}ðŸš«â†µ\n```\n\n[}]: #\n\nAnd finally, we will extend the C++ in our JavaScript circle:\n\n[{]: <helper> (diffStep 7.21)\n\n#### [Step 7.21: Extend CPP circle class](https://github.com/DAB0mB/radial-snake/commit/d05cf32)\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;geometry&#x2F;circle.js\n```diff\n@@ -1,83 +1,9 @@\n-â”Š 1â”Š  â”ŠEngine.Geometry.Circle = class Circle {\n-â”Š 2â”Š  â”Š  // x - The x value of the circle's center\n-â”Š 3â”Š  â”Š  // y - The y value of the circle's center\n-â”Š 4â”Š  â”Š  // r - The radius of the center\n-â”Š 5â”Š  â”Š  // rad1 - The first radian of the circle, not necessarily its beginning\n-â”Š 6â”Š  â”Š  // rad2 - The second radian of the circle, not necessarily its beginning\n-â”Š 7â”Š  â”Š  constructor(x, y, r, rad1, rad2) {\n-â”Š 8â”Š  â”Š    this.x = Utils.trim(x, 9);\n-â”Š 9â”Š  â”Š    this.y = Utils.trim(y, 9);\n-â”Š10â”Š  â”Š    this.r = Utils.trim(r, 9);\n-â”Š11â”Š  â”Š\n-â”Š12â”Š  â”Š    // Trimming mode is done based on which radian represents the ending and which radian\n-â”Š13â”Š  â”Š    // represents the ending\n-â”Š14â”Š  â”Š    if (rad1 > rad2) {\n-â”Š15â”Š  â”Š      this.rad1 = Utils.trim(rad1, 9, \"floor\");\n-â”Š16â”Š  â”Š      this.rad2 = Utils.trim(rad2, 9, \"ceil\");\n-â”Š17â”Š  â”Š    }\n-â”Š18â”Š  â”Š    else {\n-â”Š19â”Š  â”Š      this.rad1 = Utils.trim(rad1, 9, \"ceil\");\n-â”Š20â”Š  â”Š      this.rad2 = Utils.trim(rad2, 9, \"floor\");\n-â”Š21â”Š  â”Š    }\n-â”Š22â”Š  â”Š  }\n-â”Š23â”Š  â”Š\n+â”Š  â”Š 1â”ŠEngine.Geometry.Circle = class Circle extends Utils.proxy(CPP.Geometry.Circle) {\n â”Š24â”Š 2â”Š  // Draws the circle on the given context\n â”Š25â”Š 3â”Š  draw(context) {\n â”Š26â”Š 4â”Š    context.arc(this.x, this.y, this.r, this.rad1, this.rad2);\n â”Š27â”Š 5â”Š  }\n â”Š28â”Š 6â”Š\n-â”Š29â”Š  â”Š  // Gets the matching x value for the given radian\n-â”Š30â”Š  â”Š  getX(rad) {\n-â”Š31â”Š  â”Š    if (!Utils(rad).trim(9).isBetween(this.rad1, this.rad2).value()) return;\n-â”Š32â”Š  â”Š    return Utils.trim((this.r * Math.cos(rad)) + this.x, 9);\n-â”Š33â”Š  â”Š  }\n-â”Š34â”Š  â”Š\n-â”Š35â”Š  â”Š  // Gets the matching y value for the given radian\n-â”Š36â”Š  â”Š  getY(rad) {\n-â”Š37â”Š  â”Š    if (!Utils(rad).trim(9).isBetween(this.rad1, this.rad2).value()) return;\n-â”Š38â”Š  â”Š    return Utils.trim((this.r * Math.sin(rad)) + this.y, 9);\n-â”Š39â”Š  â”Š  }\n-â”Š40â”Š  â”Š\n-â”Š41â”Š  â”Š  // Gets the matching point for the given radian\n-â”Š42â”Š  â”Š  getPoint(rad) {\n-â”Š43â”Š  â”Š    if (!Utils.isBetween(rad, this.rad1, this.rad2)) return;\n-â”Š44â”Š  â”Š\n-â”Š45â”Š  â”Š    return {\n-â”Š46â”Š  â”Š      x: Utils.trim((this.r * Math.cos(rad)) + this.x, 9),\n-â”Š47â”Š  â”Š      y: Utils.trim((this.r * Math.sin(rad)) + this.y, 9)\n-â”Š48â”Š  â”Š    };\n-â”Š49â”Š  â”Š  }\n-â”Š50â”Š  â”Š\n-â”Š51â”Š  â”Š  // Gets the matching radian for the given point\n-â”Š52â”Š  â”Š  getRad(x, y) {\n-â”Š53â”Š  â”Š    let rad = Math.atan2(y - this.y, x - this.x);\n-â”Š54â”Š  â”Š\n-â”Š55â”Š  â”Š    // If calculated radian is in circle's radian range, return it\n-â”Š56â”Š  â”Š    if (rad != null && Utils.isBetween(rad, this.rad1, this.rad2)) {\n-â”Š57â”Š  â”Š      return rad;\n-â”Š58â”Š  â”Š    }\n-â”Š59â”Š  â”Š\n-â”Š60â”Š  â”Š    // The calculated radian can still be in the circle's radian range in case one\n-â”Š61â”Š  â”Š    // of the radians is greater than 2 PIEs\n-â”Š62â”Š  â”Š    if (Math.abs(this.rad1) > Math.abs(this.rad2)) {\n-â”Š63â”Š  â”Š      var greatestRad = this.rad1;\n-â”Š64â”Š  â”Š    }\n-â”Š65â”Š  â”Š    else {\n-â”Š66â”Š  â”Š      var greatestRad = this.rad2;\n-â”Š67â”Š  â”Š    }\n-â”Š68â”Š  â”Š\n-â”Š69â”Š  â”Š    // Check if the absolute radian is in the circle's radian range\n-â”Š70â”Š  â”Š    if (Utils(rad + (2 * Math.PI * Math.floor(greatestRad / (2 * Math.PI)))).trim(9).isBetween(this.rad1, this.rad2).value() ||\n-â”Š71â”Š  â”Š        Utils(rad + (2 * Math.PI * Math.ceil(greatestRad / (2 * Math.PI)))).trim(9).isBetween(this.rad1, this.rad2).value()) {\n-â”Š72â”Š  â”Š      return rad;\n-â”Š73â”Š  â”Š    }\n-â”Š74â”Š  â”Š  }\n-â”Š75â”Š  â”Š\n-â”Š76â”Š  â”Š  // Returns if circle has given points\n-â”Š77â”Š  â”Š  hasPoint(x, y) {\n-â”Š78â”Š  â”Š    return this.getRad(x, y) != null;\n-â”Š79â”Š  â”Š  }\n-â”Š80â”Š  â”Š\n â”Š81â”Š 7â”Š  getIntersection(shape) {\n â”Š82â”Š 8â”Š    if (shape instanceof Engine.Geometry.Line)\n â”Š83â”Š 9â”Š      return this.getLineIntersection(shape);\n```\n```diff\n@@ -87,86 +13,6 @@\n â”Š 87â”Š 13â”Š      return this.getPolygonIntersection(shape);\n â”Š 88â”Š 14â”Š  }\n â”Š 89â”Š 15â”Š\n-â”Š 90â”Š   â”Š  // circle - circle intersection method\n-â”Š 91â”Š   â”Š  getCircleIntersection(circle) {\n-â”Š 92â”Š   â”Š    let dx = circle.x - this.x;\n-â”Š 93â”Š   â”Š    let dy = circle.y - this.y;\n-â”Š 94â”Š   â”Š    let d = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\n-â”Š 95â”Š   â”Š\n-â”Š 96â”Š   â”Š    if (d > this.r + circle.r ||\n-â”Š 97â”Š   â”Š       d < Math.abs(this.r - circle.r)) {\n-â”Š 98â”Š   â”Š      return;\n-â”Š 99â”Š   â”Š    }\n-â”Š100â”Š   â”Š\n-â”Š101â”Š   â”Š    let a = ((Math.pow(this.r, 2) - Math.pow(circle.r, 2)) + Math.pow(d, 2)) / (2 * d);\n-â”Š102â”Š   â”Š    let x = this.x + ((dx * a) / d);\n-â”Š103â”Š   â”Š    let y = this.y + ((dy * a) / d);\n-â”Š104â”Š   â”Š    let h = Math.sqrt(Math.pow(this.r, 2) - Math.pow(a, 2));\n-â”Š105â”Š   â”Š    let rx = (- dy * h) / d;\n-â”Š106â”Š   â”Š    let ry = (dx * h) / d;\n-â”Š107â”Š   â”Š\n-â”Š108â”Š   â”Š    let interPoints = [\n-â”Š109â”Š   â”Š      {\n-â”Š110â”Š   â”Š        x: x + rx,\n-â”Š111â”Š   â”Š        y: y + ry\n-â”Š112â”Š   â”Š      },\n-â”Š113â”Š   â”Š      {\n-â”Š114â”Š   â”Š        x: x - rx,\n-â”Š115â”Š   â”Š        y: y - ry\n-â”Š116â”Š   â”Š      }\n-â”Š117â”Š   â”Š    ]\n-â”Š118â”Š   â”Š    .map(point => ({\n-â”Š119â”Š   â”Š        x: Utils.trim(point.x, 9),\n-â”Š120â”Š   â”Š        y: Utils.trim(point.y, 9)\n-â”Š121â”Š   â”Š     }));\n-â”Š122â”Š   â”Š\n-â”Š123â”Š   â”Š    interPoints = _.uniq(interPoints, point => `(${point.x}, ${point.y})`);\n-â”Š124â”Š   â”Š\n-â”Š125â”Š   â”Š    [this, circle].forEach(function(circle) {\n-â”Š126â”Š   â”Š      interPoints = interPoints.filter(point => circle.hasPoint(point.x, point.y));\n-â”Š127â”Š   â”Š    });\n-â”Š128â”Š   â”Š\n-â”Š129â”Š   â”Š    if (interPoints.length > 0) return interPoints;\n-â”Š130â”Š   â”Š  }\n-â”Š131â”Š   â”Š\n-â”Š132â”Š   â”Š  // circle - line intersection method\n-â”Š133â”Š   â”Š  getLineIntersection(line) {\n-â”Š134â”Š   â”Š    let x1 = line.x1 - this.x;\n-â”Š135â”Š   â”Š    let x2 = line.x2 - this.x;\n-â”Š136â”Š   â”Š    let y1 = line.y1 - this.y;\n-â”Š137â”Š   â”Š    let y2 = line.y2 - this.y;\n-â”Š138â”Š   â”Š    let dx = x2 - x1;\n-â”Š139â”Š   â”Š    let dy = y2 - y1;\n-â”Š140â”Š   â”Š    let d = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\n-â”Š141â”Š   â”Š    let h = (x1 * y2) - (x2 * y1);\n-â”Š142â”Š   â”Š    let delta = (Math.pow(this.r, 2) * Math.pow(d, 2)) - Math.pow(h, 2);\n-â”Š143â”Š   â”Š\n-â”Š144â”Š   â”Š    if (delta < 0) return;\n-â”Š145â”Š   â”Š\n-â”Š146â”Š   â”Š    let interPoints = [\n-â”Š147â”Š   â”Š      {\n-â”Š148â”Š   â”Š        x: (((h * dy) + (((dy / Math.abs(dy)) || 1) * dx * Math.sqrt(delta))) / Math.pow(d, 2)) + this.x,\n-â”Š149â”Š   â”Š        y: (((-h * dx) + (Math.abs(dy) * Math.sqrt(delta))) / Math.pow(d, 2)) + this.y\n-â”Š150â”Š   â”Š      },\n-â”Š151â”Š   â”Š      {\n-â”Š152â”Š   â”Š        x: (((h * dy) - (((dy / Math.abs(dy)) || 1) * dx * Math.sqrt(delta))) / Math.pow(d, 2)) + this.x,\n-â”Š153â”Š   â”Š        y: (((-h * dx) - (Math.abs(dy) * Math.sqrt(delta))) / Math.pow(d, 2)) + this.y\n-â”Š154â”Š   â”Š      }\n-â”Š155â”Š   â”Š    ]\n-â”Š156â”Š   â”Š    .map(point => ({\n-â”Š157â”Š   â”Š        x: Utils.trim(point.x, 9),\n-â”Š158â”Š   â”Š        y: Utils.trim(point.y, 9)\n-â”Š159â”Š   â”Š    }))\n-â”Š160â”Š   â”Š    .filter(point => {\n-â”Š161â”Š   â”Š      return this.hasPoint(point.x, point.y) &&\n-â”Š162â”Š   â”Š        line.boundsHavePoint(point.x, point.y);\n-â”Š163â”Š   â”Š    });\n-â”Š164â”Š   â”Š\n-â”Š165â”Š   â”Š    interPoints = _.uniq(interPoints, point => `(${point.x}, ${point.y})`);\n-â”Š166â”Š   â”Š\n-â”Š167â”Š   â”Š    if (interPoints.length > 0) return interPoints;\n-â”Š168â”Š   â”Š  }\n-â”Š169â”Š   â”Š\n â”Š170â”Š 16â”Š  // circle - polygon intersection method\n â”Š171â”Š 17â”Š  getPolygonIntersection(polygon) {\n â”Š172â”Š 18â”Š    return polygon.getCircleIntersection(this);\n```\n\n[}]: #\n\nWe also need to update the line class to contain a reference to the newly created line-intersection method, so it can be invoked from both a line or a circle bi-directionally:\n\n[{]: <helper> (diffStep 7.22)\n\n#### [Step 7.22: Add line-circle intersection method](https://github.com/DAB0mB/radial-snake/commit/84f5f4d)\n\n##### Changed resources&#x2F;cpp&#x2F;src&#x2F;geometry&#x2F;line.cpp\n```diff\n@@ -4,6 +4,7 @@\n â”Š 4â”Š 4â”Š#include \"../nullable.h\"\n â”Š 5â”Š 5â”Š#include \"../utils.h\"\n â”Š 6â”Š 6â”Š#include \"point.h\"\n+â”Š  â”Š 7â”Š#include \"circle.h\"\n â”Š 7â”Š 8â”Š#include \"line.h\"\n â”Š 8â”Š 9â”Š\n â”Š 9â”Š10â”Šnamespace geometry {\n```\n```diff\n@@ -100,6 +101,11 @@\n â”Š100â”Š101â”Š    return Nullable<Point>();\n â”Š101â”Š102â”Š  }\n â”Š102â”Š103â”Š\n+â”Š   â”Š104â”Š  // circle - circle intersection method\n+â”Š   â”Š105â”Š  Nullable<std::vector<Point>> Line::getIntersection(Circle circle) {\n+â”Š   â”Š106â”Š    return circle.getIntersection(*this);\n+â”Š   â”Š107â”Š  }\n+â”Š   â”Š108â”Š\n â”Š103â”Š109â”Š  emscripten::val EMLine::getMatchingX(double y) {\n â”Š104â”Š110â”Š    Nullable<double> nullableX = Line::getMatchingX(y);\n â”Š105â”Š111â”Š    return nullableX.hasValue() ?\n```\n```diff\n@@ -126,6 +132,10 @@\n â”Š126â”Š132â”Š    emPoint.set(\"y\", emscripten::val(point.y));\n â”Š127â”Š133â”Š    return emPoint;\n â”Š128â”Š134â”Š  }\n+â”Š   â”Š135â”Š\n+â”Š   â”Š136â”Š  emscripten::val EMLine::getIntersection(EMCircle emCircle) {\n+â”Š   â”Š137â”Š    return emCircle.getIntersection(*this);\n+â”Š   â”Š138â”Š  }\n â”Š129â”Š139â”Š}\n â”Š130â”Š140â”Š\n â”Š131â”Š141â”ŠEMSCRIPTEN_BINDINGS(geometry_line_module) {\n```\n```diff\n@@ -146,5 +156,10 @@\n â”Š146â”Š156â”Š      emscripten::select_overload<emscripten::val(geometry::EMLine)>(\n â”Š147â”Š157â”Š        &geometry::EMLine::getIntersection\n â”Š148â”Š158â”Š      )\n+â”Š   â”Š159â”Š    )\n+â”Š   â”Š160â”Š    .function(\"getCircleIntersection\",\n+â”Š   â”Š161â”Š      emscripten::select_overload<emscripten::val(geometry::EMCircle)>(\n+â”Š   â”Š162â”Š        &geometry::EMLine::getIntersection\n+â”Š   â”Š163â”Š      )\n â”Š149â”Š164â”Š    );\n â”Š150â”Š165â”Š}ðŸš«â†µ\n```\n\n##### Changed resources&#x2F;cpp&#x2F;src&#x2F;geometry&#x2F;line.h\n```diff\n@@ -4,6 +4,7 @@\n â”Š 4â”Š 4â”Š#include <emscripten/val.h>\n â”Š 5â”Š 5â”Š#include \"../nullable.h\"\n â”Š 6â”Š 6â”Š#include \"point.h\"\n+â”Š  â”Š 7â”Š#include \"circle.h\"\n â”Š 7â”Š 8â”Š\n â”Š 8â”Š 9â”Šnamespace geometry {\n â”Š 9â”Š10â”Š  class Circle;\n```\n```diff\n@@ -27,6 +28,8 @@\n â”Š27â”Š28â”Š    bool boundsHavePoint(double x, double y);\n â”Š28â”Š29â”Š\n â”Š29â”Š30â”Š    Nullable<Point> getIntersection(Line line);\n+â”Š  â”Š31â”Š\n+â”Š  â”Š32â”Š    Nullable<std::vector<Point>> getIntersection(Circle circle);\n â”Š30â”Š33â”Š  };\n â”Š31â”Š34â”Š\n â”Š32â”Š35â”Š  class EMLine : public Line {\n```\n```diff\n@@ -38,5 +41,7 @@\n â”Š38â”Š41â”Š    emscripten::val getMatchingY(double x);\n â”Š39â”Š42â”Š\n â”Š40â”Š43â”Š    emscripten::val getIntersection(EMLine line);\n+â”Š  â”Š44â”Š\n+â”Š  â”Š45â”Š    emscripten::val getIntersection(EMCircle circle);\n â”Š41â”Š46â”Š  };\n â”Š42â”Š47â”Š}ðŸš«â†µ\n```\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;geometry&#x2F;line.js\n```diff\n@@ -14,11 +14,6 @@\n â”Š14â”Š14â”Š      return this.getPolygonIntersection(shape);\n â”Š15â”Š15â”Š  }\n â”Š16â”Š16â”Š\n-â”Š17â”Š  â”Š  // line - circle intersection method\n-â”Š18â”Š  â”Š  getCircleIntersection(circle) {\n-â”Š19â”Š  â”Š    return circle.getLineIntersection(this);\n-â”Š20â”Š  â”Š  }\n-â”Š21â”Š  â”Š\n â”Š22â”Š17â”Š  // line - polygon intersection method\n â”Š23â”Š18â”Š  getPolygonIntersection(polygon) {\n â”Š24â”Š19â”Š    return polygon.getLineIntersection(this);\n```\n\n[}]: #\n\nNow, before running the tests, be sure to disposed unused circle test-data:\n\n[{]: <helper> (diffStep 7.23)\n\n#### [Step 7.23: Delete circle instances in tests](https://github.com/DAB0mB/radial-snake/commit/e953fae)\n\n##### Changed resources&#x2F;scripts&#x2F;specs&#x2F;engine&#x2F;geometry&#x2F;circle.js\n```diff\n@@ -3,6 +3,10 @@\n â”Š 3â”Š 3â”Š    this.circle = new Engine.Geometry.Circle(1, 1, 5, 0, 1.5 * Math.PI);\n â”Š 4â”Š 4â”Š  });\n â”Š 5â”Š 5â”Š\n+â”Š  â”Š 6â”Š  afterEach(function () {\n+â”Š  â”Š 7â”Š    this.circle.delete();\n+â”Š  â”Š 8â”Š  });\n+â”Š  â”Š 9â”Š\n â”Š 6â”Š10â”Š  describe(\"getX method\", function() {\n â”Š 7â”Š11â”Š    describe(\"given inranged rad\", function() {\n â”Š 8â”Š12â”Š      it(\"returns x\", function() {\n```\n```diff\n@@ -64,6 +68,8 @@\n â”Š64â”Š68â”Š          { x: -2, y: -3 },\n â”Š65â”Š69â”Š          { x: -2, y: 5 }\n â”Š66â”Š70â”Š        ]);\n+â”Š  â”Š71â”Š\n+â”Š  â”Š72â”Š        circle.delete();\n â”Š67â”Š73â”Š      });\n â”Š68â”Š74â”Š    });\n â”Š69â”Š75â”Š\n```\n```diff\n@@ -74,6 +80,8 @@\n â”Š74â”Š80â”Š        expect(this.circle.getCircleIntersection(circle)).toEqual([\n â”Š75â”Š81â”Š          { x: -2, y: 5 }\n â”Š76â”Š82â”Š        ]);\n+â”Š  â”Š83â”Š\n+â”Š  â”Š84â”Š        circle.delete();\n â”Š77â”Š85â”Š      });\n â”Š78â”Š86â”Š    });\n â”Š79â”Š87â”Š\n```\n```diff\n@@ -84,6 +92,8 @@\n â”Š84â”Š92â”Š        expect(this.circle.getCircleIntersection(circle)).toEqual([\n â”Š85â”Š93â”Š          { x: -4, y: 1 }\n â”Š86â”Š94â”Š        ]);\n+â”Š  â”Š95â”Š\n+â”Š  â”Š96â”Š        circle.delete();\n â”Š87â”Š97â”Š      });\n â”Š88â”Š98â”Š    });\n â”Š89â”Š99â”Š\n```\n```diff\n@@ -91,6 +101,7 @@\n â”Š 91â”Š101â”Š      it(\"returns nothing\", function() {\n â”Š 92â”Š102â”Š        let circle = new Engine.Geometry.Circle(10, 10, 2, 0, 2 * Math.PI);\n â”Š 93â”Š103â”Š        expect(this.circle.getCircleIntersection(circle)).toBeUndefined();\n+â”Š   â”Š104â”Š        circle.delete();\n â”Š 94â”Š105â”Š      });\n â”Š 95â”Š106â”Š    });\n â”Š 96â”Š107â”Š\n```\n```diff\n@@ -98,6 +109,7 @@\n â”Š 98â”Š109â”Š      it(\"nothing\", function() {\n â”Š 99â”Š110â”Š        let circle = new Engine.Geometry.Circle(1, 1, 2, 0, 2 * Math.PI);\n â”Š100â”Š111â”Š        expect(this.circle.getCircleIntersection(circle)).toBeUndefined();\n+â”Š   â”Š112â”Š        circle.delete();\n â”Š101â”Š113â”Š      });\n â”Š102â”Š114â”Š    });\n â”Š103â”Š115â”Š  });\n```\n\n##### Changed resources&#x2F;scripts&#x2F;specs&#x2F;engine&#x2F;geometry&#x2F;polygon.js\n```diff\n@@ -64,6 +64,8 @@\n â”Š64â”Š64â”Š          { x: 2, y: 0 },\n â”Š65â”Š65â”Š          { x: 0, y: 2 }\n â”Š66â”Š66â”Š        ]);\n+â”Š  â”Š67â”Š\n+â”Š  â”Š68â”Š        circle.delete();\n â”Š67â”Š69â”Š      });\n â”Š68â”Š70â”Š    });\n â”Š69â”Š71â”Š\n```\n```diff\n@@ -74,6 +76,8 @@\n â”Š74â”Š76â”Š        expect(this.polygon.getCircleIntersection(circle)).toEqual([\n â”Š75â”Š77â”Š          { x: 2, y: 0 }\n â”Š76â”Š78â”Š        ]);\n+â”Š  â”Š79â”Š\n+â”Š  â”Š80â”Š        circle.delete();\n â”Š77â”Š81â”Š      });\n â”Š78â”Š82â”Š    });\n â”Š79â”Š83â”Š\n```\n```diff\n@@ -84,6 +88,8 @@\n â”Š84â”Š88â”Š        expect(this.polygon.getCircleIntersection(circle)).toEqual([\n â”Š85â”Š89â”Š          { x: 0, y: 3 }\n â”Š86â”Š90â”Š        ]);\n+â”Š  â”Š91â”Š\n+â”Š  â”Š92â”Š        circle.delete();\n â”Š87â”Š93â”Š      });\n â”Š88â”Š94â”Š    });\n â”Š89â”Š95â”Š\n```\n```diff\n@@ -91,6 +97,7 @@\n â”Š 91â”Š 97â”Š      it(\"returns nothing\", function() {\n â”Š 92â”Š 98â”Š        let circle = new Engine.Geometry.Circle(10, 10, 2, 0, 2 * Math.PI);\n â”Š 93â”Š 99â”Š        expect(this.polygon.getCircleIntersection(circle)).toBeUndefined();\n+â”Š   â”Š100â”Š        circle.delete();\n â”Š 94â”Š101â”Š      });\n â”Š 95â”Š102â”Š    });\n â”Š 96â”Š103â”Š\n```\n```diff\n@@ -98,6 +105,7 @@\n â”Š 98â”Š105â”Š      it(\"nothing\", function() {\n â”Š 99â”Š106â”Š        let circle = new Engine.Geometry.Circle(2.5, 2.5, 2, 0, 2 * Math.PI);\n â”Š100â”Š107â”Š        expect(this.polygon.getCircleIntersection(circle)).toBeUndefined();\n+â”Š   â”Š108â”Š        circle.delete();\n â”Š101â”Š109â”Š      });\n â”Š102â”Š110â”Š    });\n â”Š103â”Š111â”Š  });\n```\n\n[}]: #\n\nOur C++ code should be finished now, and all the tests should be passing. The only thing left to do would be applying it to our game. Like any other application, we first need to reference the script file so it can be loaded, in this case, the C++ bundle script:\n\n[{]: <helper> (diffStep 7.24)\n\n#### [Step 7.24: Load CPP bundle in game](https://github.com/DAB0mB/radial-snake/commit/a2c0d46)\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -8,6 +8,7 @@\n â”Š 8â”Š 8â”Š    <script type=\"text/javascript\" src=\"/libs/underscore.js\"></script>\n â”Š 9â”Š 9â”Š\n â”Š10â”Š10â”Š    <!-- Scripts -->\n+â”Š  â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/cpp.bundle.js\"></script>\n â”Š11â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/utils.js\"></script>\n â”Š12â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/geometry/line.js\"></script>\n```\n\n[}]: #\n\nAnd now we need to make sure to dispose the geometry shapes correctly so we won't experience any unnecessary memory leaks. Most of our disposals should go to the snake entity, since it's made out of shapes; So we will add a `delete` method to the snake entity and we will dispose it whenever a match is finished:\n\n[{]: <helper> (diffStep 7.25)\n\n#### [Step 7.25: Delete shape instances in game](https://github.com/DAB0mB/radial-snake/commit/ae58323)\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;game.js\n```diff\n@@ -95,6 +95,7 @@\n â”Š 95â”Š 95â”Š  changeScreen(Screen, ...screenArgs) {\n â”Š 96â”Š 96â”Š    // If there is a screen defined, dispose it first\n â”Š 97â”Š 97â”Š    if (this.screen) {\n+â”Š   â”Š 98â”Š      this.screen.delete();\n â”Š 98â”Š 99â”Š      this.unloadScreen();\n â”Š 99â”Š100â”Š      this.screen.disposeEventListeners();\n â”Š100â”Š101â”Š    }\n```\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;layer.js\n```diff\n@@ -23,6 +23,9 @@\n â”Š23â”Š23â”Š    this.canvas = screen.game.canvas;\n â”Š24â”Š24â”Š  }\n â”Š25â”Š25â”Š\n+â”Š  â”Š26â”Š  delete() {\n+â”Š  â”Š27â”Š  }\n+â”Š  â”Š28â”Š\n â”Š26â”Š29â”Š  update(span) {\n â”Š27â”Š30â”Š  }\n â”Š28â”Š31â”Š\n```\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;screen.js\n```diff\n@@ -28,6 +28,13 @@\n â”Š28â”Š28â”Š    return this;\n â”Š29â”Š29â”Š  }\n â”Š30â”Š30â”Š\n+â”Š  â”Š31â”Š   // Delete all layers. Same as 'unload', only it disposes memory rather than assets\n+â”Š  â”Š32â”Š  delete() {\n+â”Š  â”Š33â”Š    this.layers.forEach(layer => {\n+â”Š  â”Š34â”Š      layer.delete();\n+â”Š  â”Š35â”Š    });\n+â”Š  â”Š36â”Š  }\n+â”Š  â”Š37â”Š\n â”Š31â”Š38â”Š  // Updates each layer\n â”Š32â”Š39â”Š  update(span) {\n â”Š33â”Š40â”Š    this.layers.forEach(layer => {\n```\n```diff\n@@ -61,6 +68,7 @@\n â”Š61â”Š68â”Š  removeLayer(layer) {\n â”Š62â”Š69â”Š    this.layers = _.without(this.layers, layer);\n â”Š63â”Š70â”Š    layer.disposeEventListeners();\n+â”Š  â”Š71â”Š    layer.delete();\n â”Š64â”Š72â”Š  }\n â”Š65â”Š73â”Š\n â”Š66â”Š74â”Š  initEventListeners() {\n```\n\n##### Changed resources&#x2F;scripts&#x2F;game&#x2F;entities&#x2F;snake.js\n```diff\n@@ -31,6 +31,10 @@\n â”Š31â”Š31â”Š    }\n â”Š32â”Š32â”Š  }\n â”Š33â”Š33â”Š\n+â”Š  â”Š34â”Š  delete() {\n+â”Š  â”Š35â”Š    this.shapes.forEach(shape => shape.delete());\n+â”Š  â”Š36â”Š  }\n+â”Š  â”Š37â”Š\n â”Š34â”Š38â”Š  draw(context) {\n â”Š35â”Š39â”Š    // Draw all shapes in the shapes array\n â”Š36â”Š40â”Š    this.shapes.forEach(shape => {\n```\n```diff\n@@ -229,6 +233,8 @@\n â”Š229â”Š233â”Š      [0, height, 0, 0]\n â”Š230â”Š234â”Š    );\n â”Š231â”Š235â”Š\n-â”Š232â”Š   â”Š    return canvasPolygon.getIntersection(this.lastBit);\n+â”Š   â”Š236â”Š    let result = canvasPolygon.getIntersection(this.lastBit);\n+â”Š   â”Š237â”Š    canvasPolygon.delete();\n+â”Š   â”Š238â”Š    return result;\n â”Š233â”Š239â”Š  }\n â”Š234â”Š240â”Š};ðŸš«â†µ\n```\n\n##### Changed resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;play&#x2F;snake.js\n```diff\n@@ -43,6 +43,10 @@\n â”Š43â”Š43â”Š    screen.appendLayer(Game.Screens.Play.Score, this.snakes);\n â”Š44â”Š44â”Š  }\n â”Š45â”Š45â”Š\n+â”Š  â”Š46â”Š  unload() {\n+â”Š  â”Š47â”Š    this.snakes.forEach(snake => snake.delete());\n+â”Š  â”Š48â”Š  }\n+â”Š  â”Š49â”Š\n â”Š46â”Š50â”Š  draw(context) {\n â”Š47â”Š51â”Š    // Draw each snake in the snakes array\n â”Š48â”Š52â”Š    this.snakes.forEach(snake => snake.draw(context));\n```\n\n[}]: #\n\nCongratulations! You've created a C++ cross JavaScript game. There shouldn't be any significant difference between the C++ version of the game and the JavaScript version on most machines, since the game is very small and barely requires any processing power. You'll probably notice the difference when starting to extend the game by adding terrains or more snakes.\n\nOne might ask - \"How much faster does my game actually run?\". The short answer is - around 50%. Why did I run into this conclusion? Well, take a look at the following JavaScript code snippet, for calculating Fibonacci of 42:\n\n```js\nfunction fib(x) {\n  if (x < 2) {\n    return 1;\n  }\n  else {\n    return fib(x - 1) + fib(x - 2);\n  }\n}\n```\n\nThe same code snippet should look almost identical written in C++:\n\n```cpp\nint fib(int x) {\n  if (x < 2) {\n    return 1;\n  }\n  else {\n    return fib(x - 1) + fib(x - 2);\n  }\n}\n```\n\nHowever, the run-times are completely different! I compared the average of 10 runs in 3 different environments, and I received the following results:\n\n![chart](https://cloud.githubusercontent.com/assets/7648874/22802494/2591025e-eef8-11e6-9679-10b5bca0ef30.png)\n\nAs you can see, the generated C++ is much faster, and to be precise, 57% faster! Surprisingly, I didn't have any significant difference between Emscripten generated C++ and natively compiled executable.\n\nC++ is more complex to write, but it certainly has its advantages over JavaScript. Remember, now that you know that you have the possibility to run C++ in the browser, make sure to use it, but never overdo it, always find the right balance between readability and performance.\n\n> *Sources:*\n> - *https://kripken.github.io/emscripten-site/docs/introducing_emscripten/index.html*\n> - *http://www.crunchy.com/?q=content/emscripten-perfectly-cromulent-compiler*\n> - *http://stackoverflow.com/questions/2354725/what-exactly-is-llvm*"
          }
        ]
      },
      {
        "releaseVersion": "0.0.1",
        "releaseDate": "2017-01-16 16:17:28 -0200",
        "tagName": "master@0.0.1",
        "tagRevision": "94c76797c3a03e9c37c63114159549f9c707d4ad",
        "historyRevision": "07bb0fb5711ee4dd189f2afcca1184db8b2cd5f4",
        "changesDiff": "diff --git a/.gitignore b/.gitignore\nnew file mode 100644\nindex 0000000..5171c54\n--- /dev/null\n+++ b/.gitignore\n@@ -0,0 +1,2 @@\n+node_modules\n+npm-debug.log\n\\ No newline at end of file\ndiff --git a/helpers/font_parser.js b/helpers/font_parser.js\nnew file mode 100644\nindex 0000000..f63665b\n--- /dev/null\n+++ b/helpers/font_parser.js\n@@ -0,0 +1,102 @@\n+const _ = require(\"underscore\");\n+const Async = require(\"async\");\n+const Fs = require(\"fs\");\n+const Path = require(\"path\");\n+const { DOMParser } = require(\"xmldom\");\n+\n+if (module === require.main) {\n+  let fonstDir = Path.resolve(__dirname, \"../resources/assets/fonts\");\n+  xmlsToJsons(fonstDir, err => { if (err) throw err });\n+}\n+\n+// Gets a dir path containing font xmls and converts them all to jsons\n+function xmlsToJsons(path, callback = _.noop) {\n+  Fs.readdir(path, (err, files) => {\n+    if (err) return callback(err);\n+\n+    // Remove all extensions\n+    fileNames = _.uniq(files.map(file => file.split(\".\")[0]));\n+\n+    // Convert each xml individually\n+    Async.each(fileNames, (fileName, next) => {\n+      xmlToJson(`${path}/${fileName}`, next);\n+    },\n+    (err) => {\n+      if (!err) console.log(\n+        'All fonts have been successfully parsed!'\n+      );\n+\n+      callback(err);\n+    });\n+  });\n+}\n+\n+// Gets a font xml and converts it to json\n+function xmlToJson(path, callback = _.noop) {\n+  Async.waterfall([\n+    (next) => {\n+      Fs.readFile(`${path}.xml`, function(err, xmlBuffer) {\n+        if (err) return next(err);\n+\n+        let json = {\n+          chars: {}\n+        };\n+\n+        let xml = xmlBuffer.toString();\n+        let doc = new DOMParser().parseFromString(xml);\n+        let fontDoc = doc.getElementsByTagName(\"Font\")[0];\n+        let charsDoc = fontDoc.getElementsByTagName(\"Char\");\n+\n+        // Compose meta-data about font like size and family\n+        _.each(fontDoc.attributes, (attr) => {\n+          json[attr.name] = parseInt(attr.value) || attr.value;\n+        });\n+\n+        // Compose data about each character in font\n+        _.each(charsDoc, (charDoc) => {\n+          let charCode = charDoc.getAttribute(\"code\");\n+\n+          let char = json.chars[charCode] = {\n+            rect: rect = {},\n+            offset: offset = {},\n+            width: parseInt(charDoc.getAttribute(\"width\"))\n+          };\n+\n+          [\n+            rect.x,\n+            rect.y,\n+            rect.width,\n+            rect.height\n+          ] = extractIntegers(charDoc.getAttribute(\"rect\"));\n+\n+          [offset.x, offset.y] = extractIntegers(charDoc.getAttribute(\"offset\"));\n+        });\n+\n+        next(null, JSON.stringify(json, null, 2));\n+      });\n+    },\n+    (json, next) => {\n+      // Once finished, write json into file\n+      Fs.writeFile(path + \".json\", json, (err) => {\n+        next(err);\n+      });\n+    }\n+  ], (err) => {\n+    if (!err) console.log(\n+      `Font ${path} has been successfully parsed...`\n+    );\n+\n+    callback(err);\n+  });\n+};\n+\n+// Converts an string of numbers to array of numbers\n+// e.g. extractIntegers(\"1 2 3\") -> [1, 2, 3]\n+function extractIntegers(srcstr) {\n+  return srcstr.split(\" \").map((substr) => parseInt(substr));\n+}\n+\n+module.exports = {\n+  xmlToJson,\n+  xmlsToJsons\n+};\n\\ No newline at end of file\ndiff --git a/helpers/ip_grabber.js b/helpers/ip_grabber.js\nnew file mode 100644\nindex 0000000..0a7a68c\n--- /dev/null\n+++ b/helpers/ip_grabber.js\n@@ -0,0 +1,23 @@\n+const Os = require(\"os\");\n+\n+// Grab local IP address of which the NodeJS process runs on\n+function local() {\n+  let interfaces = Os.networkInterfaces();\n+  let addresses = [];\n+\n+  for (let k in interfaces) {\n+    for (let k2 in interfaces[k]) {\n+      let address = interfaces[k][k2];\n+\n+      if (address.family == \"IPv4\" && !address.internal) {\n+        addresses.push(address.address);\n+      }\n+    }\n+  }\n+\n+  return addresses[0];\n+}\n+\n+module.exports = {\n+  local\n+};\n\\ No newline at end of file\ndiff --git a/helpers/permitter.js b/helpers/permitter.js\nnew file mode 100644\nindex 0000000..7894616\n--- /dev/null\n+++ b/helpers/permitter.js\n@@ -0,0 +1,29 @@\n+const Boom = require(\"boom\");\n+const Hapi = require(\"hapi\");\n+const IpGrabber = require(\"./ip_grabber\");\n+\n+// These addresses will be permitted by default\n+const defaultPermissions = [\n+  IpGrabber.local(), \"127.0.0.1\", \"localhost\"\n+];\n+\n+// Manage file permissions\n+function file(path, permissions, req, rep) {\n+  // Apply default permissions\n+  permissions = permissions.concat(defaultPermissions);\n+  // Request address\n+  let remoteAddress = req.info.remoteAddress;\n+\n+  // If not permitted, reply error\n+  if (permissions.indexOf(remoteAddress) == -1) {\n+    let err = new Boom.forbidden(\"Missing permissions\");\n+    return rep(err);\n+  }\n+\n+  // If permitted, reply file\n+  rep.file(path);\n+}\n+\n+module.exports = {\n+  file\n+};\n\\ No newline at end of file\ndiff --git a/manuals/templates/root.md b/manuals/templates/root.md\nnew file mode 100644\nindex 0000000..8588e1f\n--- /dev/null\n+++ b/manuals/templates/root.md\n@@ -0,0 +1,23 @@\n+![snake-demo-full-small](https://cloud.githubusercontent.com/assets/7648874/21073892/ae331a8a-bed2-11e6-9141-9554f9bb808b.gif)\n+\n+This tutorial will guide you through the following steps:\n+\n+- [**Step 1**](https://github.com/DAB0mB/radial-snake/blob/master/manuals/views/step1.md) - Creating a server\n+- [**Step 2**](https://github.com/DAB0mB/radial-snake/blob/master/manuals/views/step2.md) - Creating a game engine basis\n+- [**Step 3**](https://github.com/DAB0mB/radial-snake/blob/master/manuals/views/step3.md) - Creating a splash screen using a keyframe animation engine\n+- [**Step 4**](https://github.com/DAB0mB/radial-snake/blob/master/manuals/views/step4.md) - Creating a main menu screen using a font engine\n+- [**Step 5**](https://github.com/DAB0mB/radial-snake/blob/master/manuals/views/step5.md) - Creating a snake and related geometry shapes\n+- [**Step 6**](https://github.com/DAB0mB/radial-snake/blob/master/manuals/views/step6.md) - Creating a complex game screen with multiple layers\n+- [**Step 7**](https://github.com/DAB0mB/radial-snake/blob/master/manuals/views/step7.md) - Bonus! Re-implementing geometry in C++\n+- [**Step 8**](https://github.com/DAB0mB/radial-snake/blob/master/manuals/views/step8.md) - Step 8: What's next?\n+\n+Make sure you have the following software installed:\n+\n+- NodeJS with an ECMAScript 2015 support (v6.0.0 and above).\n+- Any web-browser which supports ECMAScript 2015, with a preference for Google Chrome.\n+\n+> The final result is presented in the GIF file above.\n+\n+This tutorial is mostly based on pure JavaScript, so people can have a deeper understanding of the language and its dynamics. In addition, this tutorial makes a great practice on how to build a nice architecture for complex systems, which can then be expanded and maintained with ease. Yes, it is specifically designed for games, but I truly believe that video games can easily get messed up if not planned and designed properly in terms of object oriented relationships. They are naturally more complicated then any web-app you gonna see out there, so if you can create a game engine and understand its flow, creating a web-app would be a piece of cake for you. By the end of this tutorial, your general sense for programming should be enhanced greatly.\n+\n+So hopefully that I got you pumped up by now, let's get started!\n\\ No newline at end of file\ndiff --git a/manuals/templates/step1.md b/manuals/templates/step1.md\nnew file mode 100644\nindex 0000000..a1ebbb7\n--- /dev/null\n+++ b/manuals/templates/step1.md\n@@ -0,0 +1,100 @@\n+The first thing we will learn to do would be creating a server so we can serve our assets. We will be using [HapiJS](https://hapijs.com/) to build a REST API, although this step can be implemented with any library you'd want, like [ExpressJS](http://expressjs.com/) or [Connect](https://www.senchalabs.github.com/connect) etc. Let's install it then:\n+\n+    $ npm install hapi --save\n+\n+We will start by setting up a basis for our server, and we will expand it as we go further in this step. A general boiler plate should look like so:\n+\n+{{{diff_step 1.2}}}\n+\n+We simply initialize a new server which will connect to port `8000` by default, unless we defined an environment variable called `PORT`. Once the server is started, and whenever there is an outcoming response, a message will be printed to the console.\n+\n+> More information and configuration options regards HapiJS's API can be found in this [here](https://hapijs.com/).\n+\n+Now that the basis is ready, we want a convenient way to launch it. Repetitive scripts are usually defined in the `package.json` file under the `scripts` field. To start the server, we gonna create a simple script called `serve`:\n+\n+{{{diff_step 1.3}}}\n+\n+To run this script, we will simply need to type the following:\n+\n+    $ npm run serve\n+\n+This will run our server, and you should see the following message printed to the console:\n+\n+```\n+---------- -------- ------ ---- --\n+----- ---- --- -- -\n+Server running at 8000\n+----- ---- --- -- -\n+---------- -------- ------ ---- --\n+```\n+\n+> As for now, nothing happens, because we didn't define any handlers for HTTP requests. I will get to it in a bit, stay with me.\n+\n+The main disadvantage of starting a server directly with node is that we have no listeners for changes in our files, so if we want the served files to be updated, we will have to restart our server anytime we make a change. To avoid that, we gonna use [nodemon](https://nodemon.io/), which is a simple utility that can monitor changes is source files and automatically restart our server. To install it, type the following:\n+\n+    $ sudo npm install nodemon -g\n+\n+Now that we have it, we will need to update our `serve` npm script to use `nodemon` instead of `node`:\n+\n+{{{diff_step 1.4}}}\n+\n+The basis for our server is pretty much complete. From now on we gonna build stuff on top of it and extend our server. I'd like to add a small attachment to our server. I want that the IP address of the current computer will be printed to the console once the server is started. For this, we first gonna create a helper which we gonna call `ip_grabber`:\n+\n+{{{diff_step 1.5}}}\n+\n+This module simply goes through the available network interfaces and grabs the IP address of the default gateway using the `os` module. Now that we have it, let's import it in the server's entry file and use the `local` method to grab the IP address and report it once the server is started:\n+\n+{{{diff_step 1.6}}}\n+\n+By now you should have the following message printed to the console once you start the server:\n+\n+```\n+---------- -------- ------ ---- --\n+----- ---- --- -- -\n+Server running at 95.221.122.30:8000\n+----- ---- --- -- -\n+---------- -------- ------ ---- --\n+```\n+\n+> Instead of `95.221.122.30` you should have the IP address which is right for you.\n+\n+Now comes the most important part - handling HTTP requests! Because what does a server worth if it doesn't know how to handle anything? When using `HapiJS`, we can separate extensions to our server in different modules, and eventually register them as plug-ins. So the first plug-in is gonna be the routes batch for the endpoints - it will take care of serving file requests as is, and basically turning local directories into public ones. This is useful because our game is going to be dependent on many assets like textures, images, fonts, and so on... But before I go into the implementation part we first need to install a couple of libraries which will help us with the task. The first one is going to be `async`, which will take care of managing the control flow of asynchronous code:\n+\n+    $ npm install async --save\n+\n+And the second library is going to be `inert`, which is a `HapiJS` plug-in which will give us the ability to serve files from local directories:\n+\n+    $ npm install inert --save\n+\n+Now that we're set, let's implement the `endpoints` routes batch:\n+\n+{{{diff_step 1.8}}}\n+\n+This module actually represents a classic structure of a `HapiJS` plug-in. It should export a `name` for debugging proposes, a `version`, and a `register` function, which will take care of registering extensions to our server; in this case, these are the endpoints routes. To make this plug-in (Or any other plug-in) work, we need to register it. The registration is an asynchronous operation, thus we gonna handle it using `async`:\n+\n+{{{diff_step 1.9}}}\n+\n+Once all the plug-ins have been registered, we gonna start our server as we previously did. Note that we also registered the `inert` plug-in, because as I said earlier, that's what gives us the ability to handle files requests.\n+\n+Lastly, I want to create the `pages` routes batch, which will be responsible for serving pages in our application as listed above:\n+\n+- The `/` route will serve us the `game.html` file.\n+- The `/test` route will serve us the `spec_runner.html` file.\n+\n+By the name of each route and file you can probably what each one should do. The thing is, we don't want everyone to be able to access the `spec_runner.html` file, or the `game.html` file if in the middle of development. For this, we're going to create a new helper which will be responsible for handling permissions. So first we gonna install an npm package called `boom` which has the ability to format `permission denied` HTTP errors:\n+\n+    $ npm install boom --save\n+\n+And now we gonna implement the module itself:\n+\n+{{{diff_step 1.11}}}\n+\n+The default permitted IP address would be the current computer's IP address. Extra IP permissions can be provided with the invocation of the `file` method. If the requesting IP is not listed in the permissions list, an error is gonna be replied instead of the requested file. Now that we have our \"permitter\" ready, let's implement the `pages` routes batch, only we're gonna pass the requests through the black-list, for the reason mentioned above:\n+\n+{{{diff_step 1.12}}}\n+\n+Now the only thing left to do would be registering the plug-in we've just created:\n+\n+{{{diff_step 1.13}}}\n+\n+And that's it for the current step! In the next steps we will start storing files and assets in our public directories and implement all the necessary scripts, so our server is not running in vain.\n\\ No newline at end of file\ndiff --git a/manuals/templates/step2.md b/manuals/templates/step2.md\nnew file mode 100644\nindex 0000000..0164be3\n--- /dev/null\n+++ b/manuals/templates/step2.md\n@@ -0,0 +1,99 @@\n+Like any other JavaScript-based application, we should have an entry view written in HTML. However, in our application, the only visible element is going to be an [HTMLCanvas](https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API). The canvas is exactly what it sounds like - a blank white surface which we can draw things on top of it. As we go further with this tutorial, we will learn more about the canvas and dive into its API and how to use it. Now that you got the general idea, let's create the HTML file:\n+\n+{{{diff_step 2.1}}}\n+\n+In the previous step we've already set the route for this file, so if you'd like to run the game, simply start the server by typing `npm run serve`, and navigate to the address presented on the screen (Should be `localhost:8000` by default).\n+\n+> From now on I'm going to assume the server is running in the background, so I won't repeat the instruction above\n+\n+Just to make sure that the canvas is visible and not blended into the background, we will draw a black border around using a simple style-sheet:\n+\n+{{{diff_step 2.2}}}\n+\n+> Note that every asset we create should be declared in the HTML file in order for it to take effect\n+\n+To build this project we're also gonna use two very famous utility libraries called [JQuery](http://jquery.com/) and [Underscore](http://underscorejs.org/) which will make our lives a bit easier. Third-party libraries should be located in a directory called `libs`, according to the routes-map we created in the previous step. To set these libraries up, type the following commands in series:\n+\n+    resources$ mkdir libs\n+    resources$ cd libs\n+    resources/libs$ wget raw.githubusercontent.com/dab0mb/radial-snake/master/resources/libs/underscore.js\n+    resources/libs$ wget raw.githubusercontent.com/dab0mb/radial-snake/master/resources/libs/jquery-2.1.1.js\n+\n+And load them in the game's HTML file's header:\n+\n+{{{diff_step 2.3 views/game.html}}}\n+\n+Now, we're finally going to build the game engine. At first, it's gonna be very basic simple, but further in this tutorial we're going to extend it and add some pretty neat features. When creating an application, of any kind, you don't want to garbage the global scope, so it can stay clean without any conflicts. Therefore, we're going to create an initial namespace for our game engine called `Engine`, which is going to contain all our game engine's classes and entities:\n+\n+{{{diff_step 2.4}}}\n+\n+The first thing we're going to define in the namespace we've just created would be the game loop. The game loop is the central code of your game, split into different parts. Generally, these are: update and draw.\n+\n+The main purpose of the update phase is to prepare all objects to be drawn, so this is where all the geometry code, coordinate updates, score changes, animation refreshments and other similar operations belong. This is also where the input will be captured and processed.\n+\n+When everything is properly updated and ready, we enter the draw phase where all this information is put on the screen. This function should contain all the code to manage and draw the levels, shapes, score board and so on.\n+\n+![game-loop](https://cloud.githubusercontent.com/assets/7648874/21332964/4b80ef4e-c633-11e6-946a-0c5870d2f9c9.png)\n+\n+> You can find plenty of details and information about what \"game loop\" means simply by typing in on Google.\n+\n+A game loop can wear many forms, but the concept is gonna be the same, plus-minus. This is how our game loop is going to loop like:\n+\n+{{{diff_step 2.5}}}\n+\n+The only thing it's doing right now is only drawing a black background, but we're soon going to learn how to take advantage of this game-loop to draw some custom stuff. I just want to point out that in the `draw` method I used a very handy technique called [double-buffer](https://en.wikipedia.org/wiki/Multiple_buffering), where I first draw everything on a virtual canvas which is not visible to us, and once it's finished, I the result on the main canvas. It behaves the same way React's [virtual DOM](https://www.npmjs.com/package/react-dom) behaves like, and it will prevent our game from stuttering. To start running the game, we first need to wait for the DOM content to initialize, and once its ready we gonna create a new game instance and call the `play` method:\n+\n+{{{diff_step 2.6}}}\n+\n+This will take control over the canvas and will draw a new picture every 17ms, which is 60fps (Frames per second). As for now you're only going to see a black canvas, but I promise the final result is not going to disappoint you.\n+\n+The next thing we're gonna do would be adding a 'key state' manager, which will store a flag for each key pressed on the keyboard. Once we press the key, the flag's value would be `true`, and once we release it, its value would turn into `false`. This way we have an easy way to track all the key presses without registering a specific event listener for each key press we wanna track:\n+\n+{{{diff_step 2.7}}}\n+\n+Now that we have the key state manager, we will initialize a new instance as part of our game's essentials, and we will create a global event listener for key presses; Each time a key is pressed, the key state manager will update itself:\n+\n+{{{diff_step 2.8}}}\n+\n+A 2D game's view might get complex as we go through with its development and add more logic and entities into it. Having only one `draw` method and only one `update` method is not enough, and if you think of it, it might easily get buffed up into ridiculous dimensions, which is not the way to go. I'd like to introduce you into a new methodology which involves `screens` and `layers`:\n+\n+- **screen** - Will literally be used whenever we want to show a new screen in our game e.g. 'splash' screen and 'main menu' screen. A screen consists of multiple layers, and will be used as their communicator; All the relevant assets and logic will be initialized inside it.\n+- **layer** - similar to Photoshop's layer system, any time we want to add something to the view we add new layers on top or beneath of each other.\n+\n+![screen-layer](https://cloud.githubusercontent.com/assets/7648874/21487708/9b366efe-cbb7-11e6-8669-3212e440871a.png)\n+\n+As I said earlier, the purpose of the screens and the layers is just to split the task of updating and drawing and updating, so we can have logical segments; So the `layer` class should mainly consist of a `draw` and an `update` method:\n+\n+{{{diff_step 2.9}}}\n+\n+Same thing for the screen, it only has a `draw` and `update` methods, only it has a stack of layers, which can either be added or removed:\n+\n+{{{diff_step 2.10}}}\n+\n+Now that we have the `screen` class available for us, let's apply it to the main game loop:\n+\n+{{{diff_step 2.11}}}\n+\n+This step looks kind of useless for now, unless we will have the ability to change screens as we please. Any time a screen is changed, it should be loaded with its necessary assets e.g textures, sounds, fonts, etc. The assets loading is an asynchronous operation whose logic might get a bit messy if not managed properly. To make it easier, we're going to define an assets loader, which will help us load assets asynchronously:\n+\n+{{{diff_step 2.12}}}\n+\n+> As for now the `assets loader` only has the ability to load textures, but we will extend it as we go further in this tutorial, no need to overdo it.\n+\n+Now that we have the `assets loader` we can add the ability to change a screen. Whenever we change a screen, the old screen's assets should be unloaded, and the new screen's assets should be loaded using the `assets loader`:\n+\n+{{{diff_step 2.13}}}\n+\n+Let's add a test screen just so we can get the hang of it. The test screen will only print a message to the canvas:\n+\n+{{{diff_step 2.14}}}\n+\n+Now we will use the test screen by changing to it as we create an instance of the game:\n+\n+{{{diff_step 2.15}}}\n+\n+Once you will load the application you should see a black canvas with a white text saying:\n+\n+    This is a test screen\n+\n+It means our screen system works and you may proceed to the next step, where we're gonna create our first screen :-)\n\\ No newline at end of file\ndiff --git a/manuals/templates/step3.md b/manuals/templates/step3.md\nnew file mode 100644\nindex 0000000..7b5cff5\n--- /dev/null\n+++ b/manuals/templates/step3.md\n@@ -0,0 +1,81 @@\n+![snake-demo-splash-small](https://cloud.githubusercontent.com/assets/7648874/21074086/a19fa9ce-bed6-11e6-9060-2ce94c215712.gif)\n+\n+In this step we will be creating the `splash` screen - the initial screen that should be shown once we launch the game. Our splash is consisted of a random logo animation as presented in the `gif` file above. The \"splash\" effect can be achieved using 2 concepts:\n+\n+- A sprite class - Which will present the logo texture in different dimensions, angles and rotations.\n+- A key-frame animation - Which will draw an animation automatically along the time axis using key-frames - each is a sprite representation of the texture in a specific time point.\n+\n+So first thing first, we will start by implementing the sprite class:\n+\n+{{{diff_step 3.1}}}\n+\n+And we will download the logo which will be presented in the splash screen using the sprite class:\n+\n+    resources$ mkdir assets\n+    resources$ cd assets\n+    resources/assets$ mkdir textures\n+    resources/assets$ cd textures\n+    resources/assets/textures$ wget raw.githubusercontent.com/dab0mb/radial-snake/master/resources/assets/textures/splash.png\n+\n+> Any logo can that you desired can be used instead! But to ease things up I already provided you with one as a sample\n+\n+Now we will create the initial splash screen, where we only gonna show a sprite of the logo in the middle of the screen, with no animation applied yet. We will first define a dedicated `Screens` module under the `Game` namespace:\n+\n+{{{diff_step 3.3}}}\n+\n+And we can go ahead and implement the screen itself:\n+\n+{{{diff_step 3.4}}}\n+\n+Now we can set the splash screen as the initial screen in the entry script file:\n+\n+{{{diff_step 3.5}}}\n+\n+And we will get rid of the unnecessary test screen since we make no use of it any longer:\n+\n+    $ rm resources/scripts/test_screen.js\n+\n+We will now proceed into the next stage where we will be implementing the key-frame animation engine as said at the beginning of the step. We first need to define an `Animations` module, since we can have multiple types of animation strategy like [sprite-atlas animation](http://www.joshmorony.com/how-to-create-animations-in-phaser-with-a-texture-atlas/), not necessarily a key-frame animation:\n+\n+{{{diff_step 3.7}}}\n+\n+Inside the newly created module we will create the key-frame animation engine. The key-frame animation consists of the following methods:\n+\n+- update - Updates the animation.\n+- draw - Draws the current animation frame on the provided canvas context.\n+- play - Enables update operations.\n+- pause - Disables update operations.\n+\n+{{{diff_step 3.8}}}\n+\n+When initializing a new instance of the key-frame animation, we should invoke it with the desired sprite, and an array of key-frames. What exactly does a single key-frame represents? The properties of the sprite at that specific time point. In addition, a key-frame can be set with an [easing mode](https://css-tricks.com/ease-out-in-ease-in-out/) of `in` and `out`. By default, the animation would be linear.\n+\n+Based on the `repitationMode` property, three things can happen to the animation once finished:\n+\n+- `none` - The animation will play once, and then stop. It will appear as a static sprite.\n+- `cyclic` - The animation will repeat itself from the beginning, over and over again until stopped manually.\n+- `full` - The animation will play itself backwards, and then forwards, backwards, forwards, and so on.\n+\n+Thanks to the key-frame animation engine, we can apply it to the splash screen to show a beautifully animated logo rather than showing a static image. So in addition to the logo sprite, we will initialize a key-frame animation as well:\n+\n+{{{diff_step 3.9}}}\n+\n+The following key-frames illustrate the nodes of the animation we've just created:\n+\n+    width: 0\n+    height: 0\n+    opacity: 0\n+\n+![logo-empty](https://cloud.githubusercontent.com/assets/7648874/21583394/ee7a1dec-d065-11e6-80ce-fdd37c4b5dbb.png)\n+\n+    width: 225\n+    height: 175\n+    opacity: 1\n+\n+![logo-half](https://cloud.githubusercontent.com/assets/7648874/21583396/ee9bdf68-d065-11e6-95fb-4cf5ed58a9de.png)\n+\n+    width: 342\n+    height: 266\n+    opacity: 1\n+\n+![logo-full](https://cloud.githubusercontent.com/assets/7648874/21583395/ee7b3754-d065-11e6-9646-476d196a6412.png)\n\\ No newline at end of file\ndiff --git a/manuals/templates/step4.md b/manuals/templates/step4.md\nnew file mode 100644\nindex 0000000..f25f04b\n--- /dev/null\n+++ b/manuals/templates/step4.md\n@@ -0,0 +1,75 @@\n+![snake-demo-menu-small](https://cloud.githubusercontent.com/assets/7648874/21074099/e72a81bc-bed6-11e6-98cb-329dc12a4b06.gif)\n+\n+In this step we will be creating the main menu screen as shown above. The main menu screen is a simple screen which will show the logo of the game and an instruction text saying `Press a key to start`. We will be using a simple texture to show the game-logo and we will use the key-frame animation engine to show a flickering animation of the instruction text. The instruction text is the main part of this step, since it is made out of a font file (`.ttf`) and the text is auto-generated, a general solution which can serve us in many situations. We will start by implementing the main menu using static assets, which means that we will use a texture to show the instructions text, and later on we will implement the generic solution I've just mentioned. First, we will download the necessary assets:\n+\n+    resources/assets/textures$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/assets/textures/instructions.png\n+    resources/assets/textures$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/assets/textures/logo.png\n+\n+And then we will implement the initial main menu screen:\n+\n+{{{diff_step 4.2}}}\n+\n+This screen is dependent on several assets which we will load during \"splash screen time\", to save some loading time and for a smooth experience. The main menu screen will be shown automatically once the splash animation has been finished:\n+\n+{{{diff_step 4.3}}}\n+\n+By now if you launch the application you should see the main menu screen as described in the beginning. But event though it works, we're not yet finished. We still need to convert the instruction texture into an auto-generated font texture. Obviously, this requires us to download the desired `ttf` file:\n+\n+    resources/assets/fonts$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/assets/fonts/minecraftia.ttf\n+\n+> Any font file can be used here, but to save time and effort I already provided you with one\n+\n+`ttf` is the most common format, but since we're using JavaScript, it would make sense to convert it into a `json` file, and that's exactly what we're going to do. There's a very convenient software called [font-builder](https://github.com/andryblack/fontbuilder), and it can cut fonts, store them in `png` files, along with some user-specified meta-data stored in an `xml` file.\n+\n+![font-builder](https://camo.githubusercontent.com/b2c95cda825c783f5399d9197599848c33cdfcc8/687474703a2f2f7777772e67616d656465762e72752f66696c65732f696d616765732f73637265656e312e6a706567)\n+\n+Go over to this website: https://github.com/andryblack/fontbuilder.\n+Fetch a copy of the `font-builder` repo, and try to convert the `minecraftia.ttf` file into a `png` file. If you want to skip this step, although I wouldn't recommend it, you can download the following files which I already generated myself:\n+\n+    resources/assets/fonts$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/assets/fonts/minecraftia.png\n+    resources/assets/fonts$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/assets/fonts/minecraftia.xml\n+\n+As promised, we will be working with a `json` file, not a `ttf` file and not an `xml` file. For this task we will be implementing a font-parser module, which will simply take all the meta-data in the `xml` file and put it into a nice `json` schema:\n+\n+{{{diff_step 4.6}}}\n+\n+This script will take everything that's in the `fonts` dir and parser it as mentioned above. Before we can user this script we will need to install some NPM dependencies like so:\n+\n+    $ npm install --save underscore\n+    $ npm install --save xmldom\n+\n+And instead of running the parser manually over and over again whenever we wanna use it, we will add an NPM script called `parse:fonts`:\n+\n+{{{diff_step 4.8}}}\n+\n+Now we will build our `minecraftia` font by simply running:\n+\n+    $ npm run parse:fonts\n+\n+And voila! We have a freshly created `json` file which we can work with. You can also get it from here:\n+\n+    resources/assets/fonts$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/assets/fonts/minecraftia.json\n+\n+Now that we have our assets finally ready we can go ahead and focus on extending the engine which powers up our game. We need some sort of a generic font-engine which will know how to load a font file and create a text-sprite out of it. First we will implement a class called `Restorable`, which shares the same restore API as the CanvasRenderingContext2D and will give us the ability to save and restore the font's state (More information can be found [here](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/restore)):\n+\n+{{{diff_step 4.10}}}\n+\n+And now we can go ahead and implement the font class itself:\n+\n+{{{diff_step 4.11}}}\n+\n+The font API shares a similar API as [HTMLImageElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/Image), once we set the `src` property the font will start loading itself, and the `onload` user-defined callback should be called once finished. Another neat feature would be the `createTexture` method, which takes a string as its first argument, representing the text that we would like to generate, and returns an instance of the `Sprite` class.\n+\n+We will also be adding the option to load some font assets in our asset-loader:\n+\n+{{{diff_step 4.12}}}\n+\n+And replace the instructions texture loading with a `minecraftia` font loading in the initial splash screen:\n+\n+{{{diff_step 4.13}}}\n+\n+Now it can use us in the main menu screen where we will create a text-sprite saying `Press a key to start`, just like the instruction sprite we're about to replace:\n+\n+{{{diff_step 4.14}}}\n+\n+It shouldn't look any different from the beginning of the step where we manually drew the instruction texture, but in the next steps we will be using the font-engine a lot, and you will be thankful for what we've just did.\n\\ No newline at end of file\ndiff --git a/manuals/templates/step5.md b/manuals/templates/step5.md\nnew file mode 100644\nindex 0000000..8627312\n--- /dev/null\n+++ b/manuals/templates/step5.md\n@@ -0,0 +1,106 @@\n+![snake-illustrate](https://cloud.githubusercontent.com/assets/7648874/21074115/46ef4466-bed7-11e6-9d5d-12fa6d43147b.gif)\n+\n+In this step we will be creating all the necessary geometry shapes to form a snake; we're basically implementing the right infrastructure so in the next step we will be able to implement the game screen with ease. What exactly do I mean by \"geometry shapes\"? Well, our snake will be made out of circles, and lines. If we don't press any buttons at all, the snake should move forward at a straight line, and once we press on one of the arrow keys, the snake should move in a circular motion. Not only we want to draw the screen on the canvas, we also want to be able to detect collision with other snakes, since this is a \"Tron\" style game where we gonna fight against an opponent.\n+\n+Keep in mind that a computer's precision is limited due its [binary representation in memory](https://en.wikipedia.org/wiki/Memory_cell_(binary)). We need to take into consideration that there might be a significant deviation when detecting collisions and intersections between geometry shapes, especially when elapsed time is not always guaranteed to stay precise. To handle these deviation issues, we're gonna create some utility functions and place then as an extension for the `Number` prototype:\n+\n+{{{diff_step 5.1}}}\n+\n+Now we would like to start implementing the first class representation for a line, and for that we're requires to add a new module called `Geometry` to the `Engine` namespace:\n+\n+{{{diff_step 5.2}}}\n+\n+And now that we have this module available to use, we can go ahead and implement our first geometry shape class - `Line`:\n+\n+{{{diff_step 5.3}}}\n+\n+You can go through the comments of the step above which will guide you through the programmatic aspect of it, but I think it's more important to understand the concept of a line in 2D space. A line is made out of two points, usually represented as `(x1, y1)` and `(x2, y2)`. The slope of the line, usually represented as `m`, can be determined using these two points based on the following formula:\n+\n+![slope](https://cloud.githubusercontent.com/assets/7648874/21788249/b4c7e41c-d6b4-11e6-9c17-baff66ec6bc8.png)\n+\n+Once we have two lines whose `m` is different (Unparalleled) and there is no intersection between the points of which they are represented with (In which case they are united), there must be an intersection point. The intersection point can be found using the following formula:\n+\n+![line-line](https://cloud.githubusercontent.com/assets/7648874/21787164/c9d83bf0-d6ae-11e6-9846-4fc013eebab3.png)\n+\n+![line-line-illustration](https://cloud.githubusercontent.com/assets/7648874/21790864/56725cf0-d6c6-11e6-916b-50b1fc0b87af.png)\n+\n+> See reference: http://mathworld.wolfram.com/Line-LineIntersection.html.\n+\n+Obviously we have some logic here which needs to be tested. To test our `Line` class, we will be using a testing framework called [Jasmine](https://jasmine.github.io/). We first need to download `Jasmine`'s essentials in order for it to work:\n+\n+    resources/libs$ mkdir jasmine\n+    resources/libs$ cd jasmine\n+    resources/libs/jasmine$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/libs/jasmine/boot.js\n+    resources/libs/jasmine$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/libs/jasmine/console.js\n+    resources/libs/jasmine$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/libs/jasmine/jasmine-html.js\n+    resources/libs/jasmine$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/libs/jasmine/jasmine.css\n+    resources/libs/jasmine$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/libs/jasmine/jasmine.js\n+    resources/libs/jasmine$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/libs/jasmine/jasmine_favicon.png\n+\n+These essentials should be loaded in a newly created view where we're gonna see our specs running:\n+\n+{{{diff_step 5.5}}}\n+\n+Now once we'll navigate to the `/test` sub-route (`localhost:8000/test` by default) we should be provided with the spec runner. As for now there are no specs implemented at all, which brings us to the next stage - Implementing tests for `Line` class:\n+\n+{{{diff_step 5.6}}}\n+\n+Now if you'll refresh the spec runner page you should be able to a green screen indicating all tests have passed (Assuming the tutorial is updated and you followed it correctly). As introduced at the beginning of the step, the snake is also dependent on circles, whose representing class should look like so:\n+\n+{{{diff_step 5.7}}}\n+\n+Just like a line, a circle can be presented using variables as well. The center of the circle is represented as `(x, y)` and its radius is represented as `r`. Remember that our circle doesn't necessarily have to be a full one, therefore we limit its range using two radians - `rad1` and `rad2`. The formula for representing a circle in a 2D space looks like this:\n+\n+![circle-formula](https://cloud.githubusercontent.com/assets/7648874/21829783/84a54574-d77f-11e6-9b87-3fb0f073bb8d.png)\n+\n+![circle-circle-illustration](https://cloud.githubusercontent.com/assets/7648874/21790842/3a73408c-d6c6-11e6-8bdd-9c73355e6ebb.png)\n+\n+> `a` and `b` represent the offsets from the `x` and the `y` axes respectively.\n+> See reference: http://mathworld.wolfram.com/Circle-CircleIntersection.html.\n+\n+To find intersection between two circles, we simply calculate the solution for two equations with two variables. Given that a line can be represented in a 2D space using the following formula:\n+\n+![line-formula](https://cloud.githubusercontent.com/assets/7648874/21790671/1609c050-d6c5-11e6-8bd7-16cc306f5eea.png)\n+\n+![circle-line-illustration](https://cloud.githubusercontent.com/assets/7648874/21790810/1a052086-d6c6-11e6-9c5c-24298fedb043.png)\n+\n+> `n` represents the intersection value with the `y` axis.\n+> See reference: http://mathworld.wolfram.com/Circle-LineIntersection.html.\n+\n+we can find the intersection between a circle and line by solving the systems formed by the equations of both. We also want the line-circle algorithm to be available for any `Line` instance, therefore we gonna add the following delegate on the `Line` prototype:\n+\n+{{{diff_step 5.8}}}\n+\n+Then again a newly created geometry shape class should be tested against different scenarios:\n+\n+{{{diff_step 5.9}}}\n+\n+Our final shape in the geometry module would be a polygon. Why a polygon? Since I'm planning to make the snake's movement circular, which means that once the snake hits a random boundary, he will reappear from the other side of the canvas. The collision detection between the snake and the canvas would be done using a polygon - which is simply made out of 4 lines:\n+\n+{{{diff_step 5.10}}}\n+\n+Again we will delegate the newly created intersection methods in the `Line` class and `Circle` class:\n+\n+{{{diff_step 5.11}}}\n+\n+Now we will create a some tests to make sure our newly created polygon works properly:\n+\n+{{{diff_step 5.12}}}\n+\n+At last, all the necessary geometry shapes are implemented and ready to use. We will now focus on the snake itself. Since our game can potentially have infinite number of entities, not necessarily just a snake, we will add the a new module under the `Game` namespace called `Entities`:\n+\n+{{{diff_step 5.13}}}\n+\n+And now we can add the `Snake` class:\n+\n+{{{diff_step 5.14}}}\n+\n+This class is titled with most complexity out of everything we did so far in this step. You can follow the code accompanied by comments regard it, but I'd also like to explain the key concepts. As said earlier, the `Snake` is simply made out of shapes; In this case - lines and circles.\n+\n+The `draw` method just goes through this array and draws whatever shape it's currently looping through. Regardless of its type, every shape is provided with a `draw` method of its own, all shapes share the same interface, therefore we can just draw them regularly and the snake should be drawn automatically.\n+\n+The `update` method updates the last bit only according to its type, the time elapsed and the speed of the snake. For example, the last bit of the snake is a line, and 5 seconds have passed at a speed of 5 meters per second, our line should be extended by 5 meters long. Same principle applies to circle extension only based on radians. The last bit's type might be changed according to the current input; e.g. if the `right` key is held the last bit would turn into a circle, and once released it would turn into a straight line.\n+\n+Note that besides shapes extension, collision detection should also be made. The embedded is the collision detection between the snake and the canvas, which means that any time the snake collides with the canvas's boundaries the last bit should be redrawn from the opposite side of the canvas. In addition, we've implemented intersection methods for self collision detection and collision detection between rivals, which should be used externally by the hosting screen.\n+\n+In the next step we will be implementing the game screen where we will make use of the `Snake` class we've just created, and see how it works in action.\n\\ No newline at end of file\ndiff --git a/manuals/templates/step6.md b/manuals/templates/step6.md\nnew file mode 100644\nindex 0000000..646f23b\n--- /dev/null\n+++ b/manuals/templates/step6.md\n@@ -0,0 +1,58 @@\n+![snake-demo-game-small](https://cloud.githubusercontent.com/assets/7648874/21074124/8b7cd724-bed7-11e6-9f91-2a211630ac78.gif)\n+\n+In this step we will be using the `Snake` class we've just created in the previous step to form the actual game screen - called the `Play` screen. The play screen is a complex screen made out multiple layers as following:\n+\n+- **`Ready` layer** - Displays a message at the beginning of each match.\n+- **`Snake` layer** - Displays the the competitors' snakes.\n+- **`Score` layer** - Displays the score board.\n+- **`Win` layer** - Displays the winner at the end of each match.\n+\n+As we go further with this step, we will give a deeper explanation about each layer and how they interact with each other; As for let's start with the `Play` screen's basis. Regardless of what the `Play` screen should contain at the final result, we want to have the ability to abort the match whenever we press the `Escape` key, therefore, the initial implementation should look like this:\n+\n+{{{diff_step 6.1}}}\n+\n+Now that we have the `Play` screen, we need to hook it to the `Menu` screen, so whenever we press a key, we will be proceeded to it:\n+\n+{{{diff_step 6.2}}}\n+\n+By now there shouldn't be anything special. Once you're at the main menu, just press a key as instructed, and you shall see a black screen, which is actually the `Play` screen we've just created; And once you'll press the `Escape` key, you should be receded to the main menu.\n+\n+The next stage would be displaying a `Ready` message on the screen, and whenever a key is pressed, the message should fade away using a key-frame animation, and the match should start in the background:\n+\n+{{{diff_step 6.3}}}\n+\n+In order to hook the `Ready` layer to the `Play` screen, we will just push a new instance of it to the layers stack, using the screen's `appendLayer` method. Note that the order of the layer is super critic! Since if we push a new layer it means it will be drawn on top of any previous layer. To \"shift\" a layer to the layers stack, we can simply use the `prependLayer` method instead. Without further due, this is how our hook should look like:\n+\n+{{{diff_step 6.4}}}\n+\n+Now if you'll launch the game and start a new match, you should see a white `Ready` message in the middle of the screen. Up next, would be the `Snake` layer, which will simply initialize 2 new `Snake` instances, and take care of drawing and updating them:\n+\n+{{{diff_step 6.5}}}\n+\n+Once pressing a key in the `Ready` layer, not only we want to display an animation, but we also want the match to start in the background, thus, we gonna push a new instance of the `Snake` layer we've just created like so:\n+\n+{{{diff_step 6.6}}}\n+\n+Note that the layer is pushed when the animation starts and not once finished; This would give a nice smooth feeling to our game-flow. If you'll test out the game, you would discover that the match is actually playable! The first snake (Red) snake should be controlled by the arrow keys, and the second snake (Blue) should be controlled by the letter keys `a`, `s`, `d` and `w`. So far, the snakes function great, but you can probably tell that whenever a match is finished, it feels a bit dull. There's no indication of winning, and there's no score board to present the score of each competitor, which brings us to the next stage - Implementing the `Score` layer.\n+\n+The `Score` layer is a simple layer which takes the 2 snakes as a parameter and displays their scores at the top of the screen:\n+\n+{{{diff_step 6.7}}}\n+\n+> Note that the current score board is suitable for two players, but can easily be modified to support as much players as you want if done correctly.\n+\n+The `Score` board should be appended to the layers stack as soon as the `Snake` layers is initialized, so it would be available to us once the match is started:\n+\n+{{{diff_step 6.8}}}\n+\n+Now we're one layer further from completing the `Play` screen, the only thing missing is the `Win` layer, which should present the winner once the match is finished:\n+\n+{{{diff_step 6.9}}}\n+\n+Note how we use the `changeScreen` method once the `Win` layer has reached its age limit (Time to live, aka `ttl`); This would clear the layers stack and restart the `Play` screen, so we can start a new match all-over, only this time we will pass the `Snake` instances to reserve the original scores. The `Win` layer should be presented whenever a collision has been detected between the snakes:\n+\n+{{{diff_step 6.10}}}\n+\n+That's it folks, the `Play` screen is finished, and you can play as much matches as you'd feel like.\n+\n+Although the game is finished, it can still be optimized using `C++`. To discover more on hooking efficiency and how we can hook `C++` to the browser, see the next step.\n\\ No newline at end of file\ndiff --git a/manuals/templates/step7.md b/manuals/templates/step7.md\nnew file mode 100644\nindex 0000000..800619a\n--- /dev/null\n+++ b/manuals/templates/step7.md\n@@ -0,0 +1,3 @@\n+### TBA ###\n+\n+Oops! It looks that this step is not yet implemented. Stay tuned for upcoming updates.\n\\ No newline at end of file\ndiff --git a/manuals/templates/step8.md b/manuals/templates/step8.md\nnew file mode 100644\nindex 0000000..607c84b\n--- /dev/null\n+++ b/manuals/templates/step8.md\n@@ -0,0 +1,14 @@\n+That was it y'all, hopefully you like this tutorial. Definitely a refresher when you have all these high-level frameworks out there.\n+\n+Check out my previous tutorial on how to write a native add-on to `NodeJS` using `C++`: https://github.com/DAB0mB/node-distance-addon\n+\n+Be sure to â˜…*â˜…***â˜…STARâ˜…***â˜…*â˜… this repository: https://github.com/DAB0mB/radial-snake.\n+\n+If you have any suggestions, issues, and things you'd like to ask, be sure to open an issue in the issues section: https://github.com/DAB0mB/radial-snake/issues\n+\n+For more awesome tutorials and upcoming projects, please follow me on:\n+\n+- **Github** - https://github.com/DAB0mB\n+- **Twitter** - https://twitter.com/eytan_manor\n+\n+Stay frosty 'til next time. Peace â˜®.\n\\ No newline at end of file\ndiff --git a/manuals/views/root.md b/manuals/views/root.md\nnew file mode 120000\nindex 0000000..fe84005\n--- /dev/null\n+++ b/manuals/views/root.md\n@@ -0,0 +1 @@\n+../../README.md\n\\ No newline at end of file\ndiff --git a/manuals/views/step1.md b/manuals/views/step1.md\nnew file mode 100644\nindex 0000000..fd103b2\n--- /dev/null\n+++ b/manuals/views/step1.md\n@@ -0,0 +1,478 @@\n+[{]: <region> (header)\n+# Step 1: Creating a server\n+[}]: #\n+[{]: <region> (body)\n+The first thing we will learn to do would be creating a server so we can serve our assets. We will be using [HapiJS](https://hapijs.com/) to build a REST API, although this step can be implemented with any library you'd want, like [ExpressJS](http://expressjs.com/) or [Connect](https://www.senchalabs.github.com/connect) etc. Let's install it then:\n+\n+    $ npm install hapi --save\n+\n+We will start by setting up a basis for our server, and we will expand it as we go further in this step. A general boiler plate should look like so:\n+\n+[{]: <helper> (diff_step 1.2)\n+#### Step 1.2: Add server basis\n+\n+##### Added server.js\n+```diff\n+@@ -0,0 +1,36 @@\n++â”Š  â”Š 1â”Šconst Hapi = require(\"hapi\");\n++â”Š  â”Š 2â”Š\n++â”Š  â”Š 3â”Šlet port = 8000;\n++â”Š  â”Š 4â”Š\n++â”Š  â”Š 5â”Š// Initialize a new server\n++â”Š  â”Š 6â”Šlet server = new Hapi.Server();\n++â”Š  â”Š 7â”Š\n++â”Š  â”Š 8â”Šserver.connection({ port: process.env.PORT || port });\n++â”Š  â”Š 9â”Š\n++â”Š  â”Š10â”Š// Report each response made\n++â”Š  â”Š11â”Šserver.ext(\"onPreResponse\", (req, rep) => {\n++â”Š  â”Š12â”Š  let res = req.response;\n++â”Š  â”Š13â”Š\n++â”Š  â”Š14â”Š  console.log(\"Outcoming response:\");\n++â”Š  â”Š15â”Š  console.log(`in: ${new Date}`);\n++â”Š  â”Š16â”Š  console.log(`to: ${req.info.remoteAddress}`);\n++â”Š  â”Š17â”Š  console.log(`method: ${req.method}`);\n++â”Š  â”Š18â”Š  console.log(`url: ${req.url.path}`);\n++â”Š  â”Š19â”Š  console.log(`status: ${res.statusCode || res.output.statusCode}`);\n++â”Š  â”Š20â”Š  console.log();\n++â”Š  â”Š21â”Š\n++â”Š  â”Š22â”Š  rep.continue();\n++â”Š  â”Š23â”Š});\n++â”Š  â”Š24â”Š\n++â”Š  â”Š25â”Š// Print message once started\n++â”Š  â”Š26â”Šserver.start((err) => {\n++â”Š  â”Š27â”Š  if (err) throw err;\n++â”Š  â”Š28â”Š\n++â”Š  â”Š29â”Š  console.log();\n++â”Š  â”Š30â”Š  console.log(\"---------- -------- ------ ---- --\");\n++â”Š  â”Š31â”Š  console.log(\"----- ---- --- -- -\");\n++â”Š  â”Š32â”Š  console.log(`Server running at ${port}`);\n++â”Š  â”Š33â”Š  console.log(\"----- ---- --- -- -\");\n++â”Š  â”Š34â”Š  console.log(\"---------- -------- ------ ---- --\");\n++â”Š  â”Š35â”Š  console.log();\n++â”Š  â”Š36â”Š});ðŸš«â†µ\n+```\n+[}]: #\n+\n+We simply initialize a new server which will connect to port `8000` by default, unless we defined an environment variable called `PORT`. Once the server is started, and whenever there is an outcoming response, a message will be printed to the console.\n+\n+> More information and configuration options regards HapiJS's API can be found in this [here](https://hapijs.com/).\n+\n+Now that the basis is ready, we want a convenient way to launch it. Repetitive scripts are usually defined in the `package.json` file under the `scripts` field. To start the server, we gonna create a simple script called `serve`:\n+\n+[{]: <helper> (diff_step 1.3)\n+#### Step 1.3: Add serve npm script\n+\n+##### Changed package.json\n+```diff\n+@@ -2,6 +2,9 @@\n+ â”Š 2â”Š 2â”Š  \"name\": \"radial-snake\",\n+ â”Š 3â”Š 3â”Š  \"description\": \"A tutorial for creating a Tron-style game\",\n+ â”Š 4â”Š 4â”Š  \"private\": true,\n++â”Š  â”Š 5â”Š  \"scripts\": {\n++â”Š  â”Š 6â”Š    \"serve\": \"node server.js\"\n++â”Š  â”Š 7â”Š  },\n+ â”Š 5â”Š 8â”Š  \"dependencies\": {\n+ â”Š 6â”Š 9â”Š    \"hapi\": \"^16.0.1\"\n+ â”Š 7â”Š10â”Š  }\n+```\n+[}]: #\n+\n+To run this script, we will simply need to type the following:\n+\n+    $ npm run serve\n+\n+This will run our server, and you should see the following message printed to the console:\n+\n+```\n+---------- -------- ------ ---- --\n+----- ---- --- -- -\n+Server running at 8000\n+----- ---- --- -- -\n+---------- -------- ------ ---- --\n+```\n+\n+> As for now, nothing happens, because we didn't define any handlers for HTTP requests. I will get to it in a bit, stay with me.\n+\n+The main disadvantage of starting a server directly with node is that we have no listeners for changes in our files, so if we want the served files to be updated, we will have to restart our server anytime we make a change. To avoid that, we gonna use [nodemon](https://nodemon.io/), which is a simple utility that can monitor changes is source files and automatically restart our server. To install it, type the following:\n+\n+    $ sudo npm install nodemon -g\n+\n+Now that we have it, we will need to update our `serve` npm script to use `nodemon` instead of `node`:\n+\n+[{]: <helper> (diff_step 1.4)\n+#### Step 1.4: Change serve npm script to use nodemon\n+\n+##### Changed package.json\n+```diff\n+@@ -3,7 +3,7 @@\n+ â”Š3â”Š3â”Š  \"description\": \"A tutorial for creating a Tron-style game\",\n+ â”Š4â”Š4â”Š  \"private\": true,\n+ â”Š5â”Š5â”Š  \"scripts\": {\n+-â”Š6â”Š â”Š    \"serve\": \"node server.js\"\n++â”Š â”Š6â”Š    \"serve\": \"nodemon server.js\"\n+ â”Š7â”Š7â”Š  },\n+ â”Š8â”Š8â”Š  \"dependencies\": {\n+ â”Š9â”Š9â”Š    \"hapi\": \"^16.0.1\"\n+```\n+[}]: #\n+\n+The basis for our server is pretty much complete. From now on we gonna build stuff on top of it and extend our server. I'd like to add a small attachment to our server. I want that the IP address of the current computer will be printed to the console once the server is started. For this, we first gonna create a helper which we gonna call `ip_grabber`:\n+\n+[{]: <helper> (diff_step 1.5)\n+#### Step 1.5: Add ip_grabber helper\n+\n+##### Added helpers/ip_grabber.js\n+```diff\n+@@ -0,0 +1,23 @@\n++â”Š  â”Š 1â”Šconst Os = require(\"os\");\n++â”Š  â”Š 2â”Š\n++â”Š  â”Š 3â”Š// Grab local IP address of which the NodeJS process runs on\n++â”Š  â”Š 4â”Šfunction local() {\n++â”Š  â”Š 5â”Š  let interfaces = Os.networkInterfaces();\n++â”Š  â”Š 6â”Š  let addresses = [];\n++â”Š  â”Š 7â”Š\n++â”Š  â”Š 8â”Š  for (let k in interfaces) {\n++â”Š  â”Š 9â”Š    for (let k2 in interfaces[k]) {\n++â”Š  â”Š10â”Š      let address = interfaces[k][k2];\n++â”Š  â”Š11â”Š\n++â”Š  â”Š12â”Š      if (address.family == \"IPv4\" && !address.internal) {\n++â”Š  â”Š13â”Š        addresses.push(address.address);\n++â”Š  â”Š14â”Š      }\n++â”Š  â”Š15â”Š    }\n++â”Š  â”Š16â”Š  }\n++â”Š  â”Š17â”Š\n++â”Š  â”Š18â”Š  return addresses[0];\n++â”Š  â”Š19â”Š}\n++â”Š  â”Š20â”Š\n++â”Š  â”Š21â”Šmodule.exports = {\n++â”Š  â”Š22â”Š  local\n++â”Š  â”Š23â”Š};ðŸš«â†µ\n+```\n+[}]: #\n+\n+This module simply goes through the available network interfaces and grabs the IP address of the default gateway using the `os` module. Now that we have it, let's import it in the server's entry file and use the `local` method to grab the IP address and report it once the server is started:\n+\n+[{]: <helper> (diff_step 1.6)\n+#### Step 1.6: Print IP address once server is started\n+\n+##### Changed server.js\n+```diff\n+@@ -1,5 +1,7 @@\n+ â”Š1â”Š1â”Šconst Hapi = require(\"hapi\");\n++â”Š â”Š2â”Šconst IpGrabber = require(\"./helpers/ip_grabber\");\n+ â”Š2â”Š3â”Š\n++â”Š â”Š4â”Šlet localIp = IpGrabber.local();\n+ â”Š3â”Š5â”Šlet port = 8000;\n+ â”Š4â”Š6â”Š\n+ â”Š5â”Š7â”Š// Initialize a new server\n+```\n+```diff\n+@@ -29,7 +31,7 @@\n+ â”Š29â”Š31â”Š  console.log();\n+ â”Š30â”Š32â”Š  console.log(\"---------- -------- ------ ---- --\");\n+ â”Š31â”Š33â”Š  console.log(\"----- ---- --- -- -\");\n+-â”Š32â”Š  â”Š  console.log(`Server running at ${port}`);\n++â”Š  â”Š34â”Š  console.log(`Server running at ${localIp}:${port}`);\n+ â”Š33â”Š35â”Š  console.log(\"----- ---- --- -- -\");\n+ â”Š34â”Š36â”Š  console.log(\"---------- -------- ------ ---- --\");\n+ â”Š35â”Š37â”Š  console.log();\n+```\n+[}]: #\n+\n+By now you should have the following message printed to the console once you start the server:\n+\n+```\n+---------- -------- ------ ---- --\n+----- ---- --- -- -\n+Server running at 95.221.122.30:8000\n+----- ---- --- -- -\n+---------- -------- ------ ---- --\n+```\n+\n+> Instead of `95.221.122.30` you should have the IP address which is right for you.\n+\n+Now comes the most important part - handling HTTP requests! Because what does a server worth if it doesn't know how to handle anything? When using `HapiJS`, we can separate extensions to our server in different modules, and eventually register them as plug-ins. So the first plug-in is gonna be the routes batch for the endpoints - it will take care of serving file requests as is, and basically turning local directories into public ones. This is useful because our game is going to be dependent on many assets like textures, images, fonts, and so on... But before I go into the implementation part we first need to install a couple of libraries which will help us with the task. The first one is going to be `async`, which will take care of managing the control flow of asynchronous code:\n+\n+    $ npm install async --save\n+\n+And the second library is going to be `inert`, which is a `HapiJS` plug-in which will give us the ability to serve files from local directories:\n+\n+    $ npm install inert --save\n+\n+Now that we're set, let's implement the `endpoints` routes batch:\n+\n+[{]: <helper> (diff_step 1.8)\n+#### Step 1.8: Add endpoints routes\n+\n+##### Added routes/endpoints.js\n+```diff\n+@@ -0,0 +1,80 @@\n++â”Š  â”Š 1â”Šconst Pack = require(\"../package.json\");\n++â”Š  â”Š 2â”Š\n++â”Š  â”Š 3â”Šregister.attributes = {\n++â”Š  â”Š 4â”Š  name: \"endpoints\",\n++â”Š  â”Š 5â”Š  version: Pack.version\n++â”Š  â”Š 6â”Š};\n++â”Š  â”Š 7â”Š\n++â”Š  â”Š 8â”Šfunction register(server, options, next) {\n++â”Š  â”Š 9â”Š  // Scripts endpoint\n++â”Š  â”Š10â”Š  server.route({\n++â”Š  â”Š11â”Š    method: \"GET\",\n++â”Š  â”Š12â”Š    path: \"/scripts/{path*}\",\n++â”Š  â”Š13â”Š    handler: {\n++â”Š  â”Š14â”Š      directory: {\n++â”Š  â”Š15â”Š        path: \"./resources/scripts/\"\n++â”Š  â”Š16â”Š      }\n++â”Š  â”Š17â”Š    }\n++â”Š  â”Š18â”Š  });\n++â”Š  â”Š19â”Š\n++â”Š  â”Š20â”Š  // Style-sheets endpoint\n++â”Š  â”Š21â”Š  server.route({\n++â”Š  â”Š22â”Š    method: \"GET\",\n++â”Š  â”Š23â”Š    path: \"/styles/{path*}\",\n++â”Š  â”Š24â”Š    handler: {\n++â”Š  â”Š25â”Š      directory: {\n++â”Š  â”Š26â”Š        path: \"./resources/styles/\"\n++â”Š  â”Š27â”Š      }\n++â”Š  â”Š28â”Š    }\n++â”Š  â”Š29â”Š  });\n++â”Š  â”Š30â”Š\n++â”Š  â”Š31â”Š  // Libraries endpoint\n++â”Š  â”Š32â”Š  server.route({\n++â”Š  â”Š33â”Š    method: \"GET\",\n++â”Š  â”Š34â”Š    path: \"/libs/{path*}\",\n++â”Š  â”Š35â”Š    handler: {\n++â”Š  â”Š36â”Š      directory: {\n++â”Š  â”Š37â”Š        path: \"./resources/libs/\"\n++â”Š  â”Š38â”Š      }\n++â”Š  â”Š39â”Š    }\n++â”Š  â”Š40â”Š  });\n++â”Š  â”Š41â”Š\n++â”Š  â”Š42â”Š  // Images endpoint\n++â”Š  â”Š43â”Š  server.route({\n++â”Š  â”Š44â”Š    method: \"GET\",\n++â”Š  â”Š45â”Š    path: \"/images/{path*}\",\n++â”Š  â”Š46â”Š    handler: {\n++â”Š  â”Š47â”Š      directory: {\n++â”Š  â”Š48â”Š        path: \"./resources/images/\"\n++â”Š  â”Š49â”Š      }\n++â”Š  â”Š50â”Š    }\n++â”Š  â”Š51â”Š  });\n++â”Š  â”Š52â”Š\n++â”Š  â”Š53â”Š  // Textures endpoint\n++â”Š  â”Š54â”Š  server.route({\n++â”Š  â”Š55â”Š    method: \"GET\",\n++â”Š  â”Š56â”Š    path: \"/textures/{path*}\",\n++â”Š  â”Š57â”Š    handler: {\n++â”Š  â”Š58â”Š      directory: {\n++â”Š  â”Š59â”Š        path: \"./resources/assets/textures/\"\n++â”Š  â”Š60â”Š      }\n++â”Š  â”Š61â”Š    }\n++â”Š  â”Š62â”Š  });\n++â”Š  â”Š63â”Š\n++â”Š  â”Š64â”Š  // Fonts endpoint\n++â”Š  â”Š65â”Š  server.route({\n++â”Š  â”Š66â”Š    method: \"GET\",\n++â”Š  â”Š67â”Š    path: \"/fonts/{path*}\",\n++â”Š  â”Š68â”Š    handler: {\n++â”Š  â”Š69â”Š      directory: {\n++â”Š  â”Š70â”Š        path: \"./resources/assets/fonts/\"\n++â”Š  â”Š71â”Š      }\n++â”Š  â”Š72â”Š    }\n++â”Š  â”Š73â”Š  });\n++â”Š  â”Š74â”Š\n++â”Š  â”Š75â”Š  next();\n++â”Š  â”Š76â”Š}\n++â”Š  â”Š77â”Š\n++â”Š  â”Š78â”Šmodule.exports = {\n++â”Š  â”Š79â”Š  register\n++â”Š  â”Š80â”Š};ðŸš«â†µ\n+```\n+[}]: #\n+\n+This module actually represents a classic structure of a `HapiJS` plug-in. It should export a `name` for debugging proposes, a `version`, and a `register` function, which will take care of registering extensions to our server; in this case, these are the endpoints routes. To make this plug-in (Or any other plug-in) work, we need to register it. The registration is an asynchronous operation, thus we gonna handle it using `async`:\n+\n+[{]: <helper> (diff_step 1.9)\n+#### Step 1.9: Register ednpoints routes\n+\n+##### Changed server.js\n+```diff\n+@@ -1,11 +1,23 @@\n++â”Š  â”Š 1â”Šconst Async = require(\"async\");\n+ â”Š 1â”Š 2â”Šconst Hapi = require(\"hapi\");\n++â”Š  â”Š 3â”Šconst Inert = require(\"inert\");\n++â”Š  â”Š 4â”Šconst Endpoints = require(\"./routes/endpoints\");\n+ â”Š 2â”Š 5â”Šconst IpGrabber = require(\"./helpers/ip_grabber\");\n+ â”Š 3â”Š 6â”Š\n+ â”Š 4â”Š 7â”Šlet localIp = IpGrabber.local();\n+ â”Š 5â”Š 8â”Šlet port = 8000;\n+ â”Š 6â”Š 9â”Š\n+ â”Š 7â”Š10â”Š// Initialize a new server\n+-â”Š 8â”Š  â”Šlet server = new Hapi.Server();\n++â”Š  â”Š11â”Šlet server = new Hapi.Server({\n++â”Š  â”Š12â”Š  connections: {\n++â”Š  â”Š13â”Š    routes: {\n++â”Š  â”Š14â”Š      files: {\n++â”Š  â”Š15â”Š        // Served files will be relative to current directory\n++â”Š  â”Š16â”Š        relativeTo: __dirname\n++â”Š  â”Š17â”Š      }\n++â”Š  â”Š18â”Š    }\n++â”Š  â”Š19â”Š  }\n++â”Š  â”Š20â”Š});\n+ â”Š 9â”Š21â”Š\n+ â”Š10â”Š22â”Šserver.connection({ port: process.env.PORT || port });\n+ â”Š11â”Š23â”Š\n+```\n+```diff\n+@@ -24,8 +36,14 @@\n+ â”Š24â”Š36â”Š  rep.continue();\n+ â”Š25â”Š37â”Š});\n+ â”Š26â”Š38â”Š\n++â”Š  â”Š39â”Š// Register all routes and plug-ins\n++â”Š  â”Š40â”ŠAsync.series([\n++â”Š  â”Š41â”Š  next => server.register(Inert, next),\n++â”Š  â”Š42â”Š  next => server.register(Endpoints, next),\n++â”Š  â”Š43â”Š  // Once registrations are finished, start the server\n++â”Š  â”Š44â”Š  next => server.start(next)\n+ â”Š27â”Š45â”Š// Print message once started\n+-â”Š28â”Š  â”Šserver.start((err) => {\n++â”Š  â”Š46â”Š], (err) => {\n+ â”Š29â”Š47â”Š  if (err) throw err;\n+ â”Š30â”Š48â”Š\n+ â”Š31â”Š49â”Š  console.log();\n+```\n+[}]: #\n+\n+Once all the plug-ins have been registered, we gonna start our server as we previously did. Note that we also registered the `inert` plug-in, because as I said earlier, that's what gives us the ability to handle files requests.\n+\n+Lastly, I want to create the `pages` routes batch, which will be responsible for serving pages in our application as listed above:\n+\n+- The `/` route will serve us the `game.html` file.\n+- The `/test` route will serve us the `spec_runner.html` file.\n+\n+By the name of each route and file you can probably what each one should do. The thing is, we don't want everyone to be able to access the `spec_runner.html` file, or the `game.html` file if in the middle of development. For this, we're going to create a new helper which will be responsible for handling permissions. So first we gonna install an npm package called `boom` which has the ability to format `permission denied` HTTP errors:\n+\n+    $ npm install boom --save\n+\n+And now we gonna implement the module itself:\n+\n+[{]: <helper> (diff_step 1.11)\n+#### Step 1.11: Add permitter helper\n+\n+##### Added helpers/permitter.js\n+```diff\n+@@ -0,0 +1,29 @@\n++â”Š  â”Š 1â”Šconst Boom = require(\"boom\");\n++â”Š  â”Š 2â”Šconst Hapi = require(\"hapi\");\n++â”Š  â”Š 3â”Šconst IpGrabber = require(\"./ip_grabber\");\n++â”Š  â”Š 4â”Š\n++â”Š  â”Š 5â”Š// These addresses will be permitted by default\n++â”Š  â”Š 6â”Šconst defaultPermissions = [\n++â”Š  â”Š 7â”Š  IpGrabber.local(), \"127.0.0.1\", \"localhost\"\n++â”Š  â”Š 8â”Š];\n++â”Š  â”Š 9â”Š\n++â”Š  â”Š10â”Š// Manage file permissions\n++â”Š  â”Š11â”Šfunction file(path, permissions, req, rep) {\n++â”Š  â”Š12â”Š  // Apply default permissions\n++â”Š  â”Š13â”Š  permissions = permissions.concat(defaultPermissions);\n++â”Š  â”Š14â”Š  // Request address\n++â”Š  â”Š15â”Š  let remoteAddress = req.info.remoteAddress;\n++â”Š  â”Š16â”Š\n++â”Š  â”Š17â”Š  // If not permitted, reply error\n++â”Š  â”Š18â”Š  if (permissions.indexOf(remoteAddress) == -1) {\n++â”Š  â”Š19â”Š    let err = new Boom.forbidden(\"Missing permissions\");\n++â”Š  â”Š20â”Š    return rep(err);\n++â”Š  â”Š21â”Š  }\n++â”Š  â”Š22â”Š\n++â”Š  â”Š23â”Š  // If permitted, reply file\n++â”Š  â”Š24â”Š  rep.file(path);\n++â”Š  â”Š25â”Š}\n++â”Š  â”Š26â”Š\n++â”Š  â”Š27â”Šmodule.exports = {\n++â”Š  â”Š28â”Š  file\n++â”Š  â”Š29â”Š};ðŸš«â†µ\n+```\n+[}]: #\n+\n+The default permitted IP address would be the current computer's IP address. Extra IP permissions can be provided with the invocation of the `file` method. If the requesting IP is not listed in the permissions list, an error is gonna be replied instead of the requested file. Now that we have our \"permitter\" ready, let's implement the `pages` routes batch, only we're gonna pass the requests through the black-list, for the reason mentioned above:\n+\n+[{]: <helper> (diff_step 1.12)\n+#### Step 1.12: Add pages routes\n+\n+##### Added routes/pages.js\n+```diff\n+@@ -0,0 +1,35 @@\n++â”Š  â”Š 1â”Šconst Hapi = require(\"hapi\");\n++â”Š  â”Š 2â”Šconst Pack = require(\"../package.json\");\n++â”Š  â”Š 3â”Šconst Permitter = require(\"../helpers/permitter\");\n++â”Š  â”Š 4â”Š\n++â”Š  â”Š 5â”Šregister.attributes = {\n++â”Š  â”Š 6â”Š  name: \"pages\",\n++â”Š  â”Š 7â”Š  version: Pack.version\n++â”Š  â”Š 8â”Š};\n++â”Š  â”Š 9â”Š\n++â”Š  â”Š10â”Šfunction register(server, options, next) {\n++â”Š  â”Š11â”Š  server.route({ method: \"GET\", path: \"/\", handler: getGame });\n++â”Š  â”Š12â”Š  server.route({ method: \"GET\", path: \"/test\", handler: getSpecRunner });\n++â”Š  â”Š13â”Š\n++â”Š  â”Š14â”Š  next();\n++â”Š  â”Š15â”Š}\n++â”Š  â”Š16â”Š\n++â”Š  â”Š17â”Š// Serve game page\n++â”Š  â”Š18â”Šfunction getGame(req, rep) {\n++â”Š  â”Š19â”Š  let path = \"./views/game.html\";\n++â”Š  â”Š20â”Š  let permissions = [];\n++â”Š  â”Š21â”Š\n++â”Š  â”Š22â”Š  Permitter.file(path, permissions, req, rep);\n++â”Š  â”Š23â”Š}\n++â”Š  â”Š24â”Š\n++â”Š  â”Š25â”Š// Serve test page\n++â”Š  â”Š26â”Šfunction getSpecRunner(req, rep) {\n++â”Š  â”Š27â”Š  let path = \"./views/spec_runner.html\";\n++â”Š  â”Š28â”Š  let permissions = [];\n++â”Š  â”Š29â”Š\n++â”Š  â”Š30â”Š  Permitter.file(path, permissions, req, rep);\n++â”Š  â”Š31â”Š}\n++â”Š  â”Š32â”Š\n++â”Š  â”Š33â”Šmodule.exports = {\n++â”Š  â”Š34â”Š  register\n++â”Š  â”Š35â”Š};ðŸš«â†µ\n+```\n+[}]: #\n+\n+Now the only thing left to do would be registering the plug-in we've just created:\n+\n+[{]: <helper> (diff_step 1.13)\n+#### Step 1.13: Register pages routes\n+\n+##### Changed server.js\n+```diff\n+@@ -2,6 +2,7 @@\n+ â”Š2â”Š2â”Šconst Hapi = require(\"hapi\");\n+ â”Š3â”Š3â”Šconst Inert = require(\"inert\");\n+ â”Š4â”Š4â”Šconst Endpoints = require(\"./routes/endpoints\");\n++â”Š â”Š5â”Šconst Pages = require(\"./routes/pages\");\n+ â”Š5â”Š6â”Šconst IpGrabber = require(\"./helpers/ip_grabber\");\n+ â”Š6â”Š7â”Š\n+ â”Š7â”Š8â”Šlet localIp = IpGrabber.local();\n+```\n+```diff\n+@@ -40,6 +41,7 @@\n+ â”Š40â”Š41â”ŠAsync.series([\n+ â”Š41â”Š42â”Š  next => server.register(Inert, next),\n+ â”Š42â”Š43â”Š  next => server.register(Endpoints, next),\n++â”Š  â”Š44â”Š  next => server.register(Pages, next),\n+ â”Š43â”Š45â”Š  // Once registrations are finished, start the server\n+ â”Š44â”Š46â”Š  next => server.start(next)\n+ â”Š45â”Š47â”Š// Print message once started\n+```\n+[}]: #\n+\n+And that's it for the current step! In the next steps we will start storing files and assets in our public directories and implement all the necessary scripts, so our server is not running in vain.\n+[}]: #\n+[{]: <region> (footer)\n+[{]: <helper> (nav_step)\n+| [< Intro](../../README.md) | [Next Step >](step2.md) |\n+|:--------------------------------|--------------------------------:|\n+[}]: #\n+[}]: #\n\\ No newline at end of file\ndiff --git a/manuals/views/step2.md b/manuals/views/step2.md\nnew file mode 100644\nindex 0000000..855f82a\n--- /dev/null\n+++ b/manuals/views/step2.md\n@@ -0,0 +1,800 @@\n+[{]: <region> (header)\n+# Step 2: Creating a game engine basis\n+[}]: #\n+[{]: <region> (body)\n+Like any other JavaScript-based application, we should have an entry view written in HTML. However, in our application, the only visible element is going to be an [HTMLCanvas](https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API). The canvas is exactly what it sounds like - a blank white surface which we can draw things on top of it. As we go further with this tutorial, we will learn more about the canvas and dive into its API and how to use it. Now that you got the general idea, let's create the HTML file:\n+\n+[{]: <helper> (diff_step 2.1)\n+#### Step 2.1: Create basic game view\n+\n+##### Added views/game.html\n+```diff\n+@@ -0,0 +1,10 @@\n++â”Š  â”Š 1â”Š<!DOCTYPE html>\n++â”Š  â”Š 2â”Š<html>\n++â”Š  â”Š 3â”Š  <head>\n++â”Š  â”Š 4â”Š    <title>radial snake</title>\n++â”Š  â”Š 5â”Š  </head>\n++â”Š  â”Š 6â”Š\n++â”Š  â”Š 7â”Š  <body>\n++â”Š  â”Š 8â”Š    <canvas id=\"gameCanvas\" tabindex=\"0\"></canvas>\n++â”Š  â”Š 9â”Š  </body>\n++â”Š  â”Š10â”Š</html>ðŸš«â†µ\n+```\n+[}]: #\n+\n+In the previous step we've already set the route for this file, so if you'd like to run the game, simply start the server by typing `npm run serve`, and navigate to the address presented on the screen (Should be `localhost:8000` by default).\n+\n+> From now on I'm going to assume the server is running in the background, so I won't repeat the instruction above\n+\n+Just to make sure that the canvas is visible and not blended into the background, we will draw a black border around using a simple style-sheet:\n+\n+[{]: <helper> (diff_step 2.2)\n+#### Step 2.2: Create basic game stylesheet\n+\n+##### Added resources/styles/game.css\n+```diff\n+@@ -0,0 +1,6 @@\n++â”Š â”Š1â”Š#gameCanvas {\n++â”Š â”Š2â”Š  display: block;\n++â”Š â”Š3â”Š  margin: auto;\n++â”Š â”Š4â”Š  border-style: solid;\n++â”Š â”Š5â”Š  border-width: 1px;\n++â”Š â”Š6â”Š}ðŸš«â†µ\n+```\n+\n+##### Changed views/game.html\n+```diff\n+@@ -2,6 +2,9 @@\n+ â”Š 2â”Š 2â”Š<html>\n+ â”Š 3â”Š 3â”Š  <head>\n+ â”Š 4â”Š 4â”Š    <title>radial snake</title>\n++â”Š  â”Š 5â”Š\n++â”Š  â”Š 6â”Š    <!-- Styles -->\n++â”Š  â”Š 7â”Š    <link rel=\"stylesheet\" type=\"text/css\" href=\"/styles/game.css\">\n+ â”Š 5â”Š 8â”Š  </head>\n+ â”Š 6â”Š 9â”Š\n+ â”Š 7â”Š10â”Š  <body>\n+```\n+[}]: #\n+\n+> Note that every asset we create should be declared in the HTML file in order for it to take effect\n+\n+To build this project we're also gonna use two very famous utility libraries called [JQuery](http://jquery.com/) and [Underscore](http://underscorejs.org/) which will make our lives a bit easier. Third-party libraries should be located in a directory called `libs`, according to the routes-map we created in the previous step. To set these libraries up, type the following commands in series:\n+\n+    resources$ mkdir libs\n+    resources$ cd libs\n+    resources/libs$ wget raw.githubusercontent.com/dab0mb/radial-snake/master/resources/libs/underscore.js\n+    resources/libs$ wget raw.githubusercontent.com/dab0mb/radial-snake/master/resources/libs/jquery-2.1.1.js\n+\n+And load them in the game's HTML file's header:\n+\n+[{]: <helper> (diff_step 2.3 views/game.html)\n+#### Step 2.3: Add jquery and underscore libs\n+\n+##### Changed views/game.html\n+```diff\n+@@ -3,6 +3,10 @@\n+ â”Š 3â”Š 3â”Š  <head>\n+ â”Š 4â”Š 4â”Š    <title>radial snake</title>\n+ â”Š 5â”Š 5â”Š\n++â”Š  â”Š 6â”Š    <!-- Libs -->\n++â”Š  â”Š 7â”Š    <script type=\"text/javascript\" src=\"/libs/jquery-2.1.1.js\"></script>\n++â”Š  â”Š 8â”Š    <script type=\"text/javascript\" src=\"/libs/underscore.js\"></script>\n++â”Š  â”Š 9â”Š\n+ â”Š 6â”Š10â”Š    <!-- Styles -->\n+ â”Š 7â”Š11â”Š    <link rel=\"stylesheet\" type=\"text/css\" href=\"/styles/game.css\">\n+ â”Š 8â”Š12â”Š  </head>\n+```\n+[}]: #\n+\n+Now, we're finally going to build the game engine. At first, it's gonna be very basic simple, but further in this tutorial we're going to extend it and add some pretty neat features. When creating an application, of any kind, you don't want to garbage the global scope, so it can stay clean without any conflicts. Therefore, we're going to create an initial namespace for our game engine called `Engine`, which is going to contain all our game engine's classes and entities:\n+\n+[{]: <helper> (diff_step 2.4)\n+#### Step 2.4: Add engine namespace\n+\n+##### Added resources/scripts/namespaces.js\n+```diff\n+@@ -0,0 +1 @@\n++â”Š â”Š1â”ŠEngine = {};ðŸš«â†µ\n+```\n+\n+##### Changed views/game.html\n+```diff\n+@@ -7,6 +7,9 @@\n+ â”Š 7â”Š 7â”Š    <script type=\"text/javascript\" src=\"/libs/jquery-2.1.1.js\"></script>\n+ â”Š 8â”Š 8â”Š    <script type=\"text/javascript\" src=\"/libs/underscore.js\"></script>\n+ â”Š 9â”Š 9â”Š\n++â”Š  â”Š10â”Š    <!-- Scripts -->\n++â”Š  â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n++â”Š  â”Š12â”Š\n+ â”Š10â”Š13â”Š    <!-- Styles -->\n+ â”Š11â”Š14â”Š    <link rel=\"stylesheet\" type=\"text/css\" href=\"/styles/game.css\">\n+ â”Š12â”Š15â”Š  </head>\n+```\n+[}]: #\n+\n+The first thing we're going to define in the namespace we've just created would be the game loop. The game loop is the central code of your game, split into different parts. Generally, these are: update and draw.\n+\n+The main purpose of the update phase is to prepare all objects to be drawn, so this is where all the geometry code, coordinate updates, score changes, animation refreshments and other similar operations belong. This is also where the input will be captured and processed.\n+\n+When everything is properly updated and ready, we enter the draw phase where all this information is put on the screen. This function should contain all the code to manage and draw the levels, shapes, score board and so on.\n+\n+![game-loop](https://cloud.githubusercontent.com/assets/7648874/21332964/4b80ef4e-c633-11e6-946a-0c5870d2f9c9.png)\n+\n+> You can find plenty of details and information about what \"game loop\" means simply by typing in on Google.\n+\n+A game loop can wear many forms, but the concept is gonna be the same, plus-minus. This is how our game loop is going to loop like:\n+\n+[{]: <helper> (diff_step 2.5)\n+#### Step 2.5: Create a game basis\n+\n+##### Added resources/scripts/engine/game.js\n+```diff\n+@@ -0,0 +1,112 @@\n++â”Š   â”Š  1â”ŠEngine.Game = class Game {\n++â”Š   â”Š  2â”Š  // Frames rendered per second\n++â”Š   â”Š  3â”Š  get fps() {\n++â”Š   â”Š  4â”Š    return 60;\n++â”Š   â”Š  5â”Š  }\n++â”Š   â”Š  6â”Š\n++â”Š   â”Š  7â”Š  // Game's run speed.\n++â”Š   â”Š  8â”Š  // A lower value will make it run slower and a higher value will make it run faster\n++â”Š   â”Š  9â”Š  get speed() {\n++â”Š   â”Š 10â”Š    return 1;\n++â”Š   â”Š 11â”Š  }\n++â”Š   â”Š 12â”Š\n++â”Š   â”Š 13â”Š  constructor(canvas, debugging) {\n++â”Š   â”Š 14â”Š    this.canvas = canvas;\n++â”Š   â”Š 15â”Š    this.debugging = debugging;\n++â”Š   â”Š 16â”Š    this.lastUpdate = this.creation = new Date().getTime();\n++â”Š   â”Š 17â”Š\n++â”Š   â”Š 18â”Š    // Canvas dimensions must be set programmatically otherwise you might encounter some\n++â”Š   â”Š 19â”Š    // unexpected behaviors\n++â”Š   â”Š 20â”Š    canvas.width = 1280;\n++â”Š   â”Š 21â”Š    canvas.height = 720;\n++â”Š   â”Š 22â”Š    // Canvas will be focused once game page is loaded so all events will automatically\n++â”Š   â”Š 23â”Š    // be captured by it\n++â”Š   â”Š 24â”Š    canvas.focus();\n++â”Š   â”Š 25â”Š\n++â”Š   â”Š 26â”Š    // We want to focus on the canvas once we press on it\n++â”Š   â”Š 27â”Š    canvas.addEventListener(\"mousedown\", canvas.focus.bind(canvas), false);\n++â”Š   â”Š 28â”Š\n++â”Š   â”Š 29â”Š    this.assets = {};\n++â”Š   â”Š 30â”Š    this.events = new Map();\n++â”Š   â”Š 31â”Š    this.context = canvas.getContext(\"2d\");\n++â”Š   â”Š 32â”Š    this.bufferedCanvas = document.createElement(\"canvas\");\n++â”Š   â”Š 33â”Š    this.bufferedContext = this.bufferedCanvas.getContext(\"2d\");\n++â”Š   â”Š 34â”Š    this.bufferedCanvas.width = canvas.width;\n++â”Š   â”Š 35â”Š    this.bufferedCanvas.height = canvas.height;\n++â”Š   â”Š 36â”Š  }\n++â”Š   â”Š 37â”Š\n++â”Š   â”Š 38â”Š  draw() {\n++â”Š   â”Š 39â”Š    // If debugging, don't use double buffer so we can see rendering in real time\n++â”Š   â”Š 40â”Š    if (this.debugging) {\n++â”Š   â”Š 41â”Š      this.context.restore();\n++â”Š   â”Š 42â”Š      this.context.fillStyle = \"black\";\n++â”Š   â”Š 43â”Š      this.context.save();\n++â”Š   â”Š 44â”Š      this.context.beginPath();\n++â”Š   â”Š 45â”Š      this.context.rect(0, 0, this.canvas.width, this.canvas.height);\n++â”Š   â”Š 46â”Š      this.context.fill();\n++â”Š   â”Š 47â”Š    }\n++â”Š   â”Š 48â”Š    // If not debugging, use double buffer to prevent flickering\n++â”Š   â”Š 49â”Š    else {\n++â”Š   â”Š 50â”Š      this.bufferedContext.restore();\n++â”Š   â”Š 51â”Š      this.bufferedContext.fillStyle = \"black\";\n++â”Š   â”Š 52â”Š      this.bufferedContext.save();\n++â”Š   â”Š 53â”Š      this.bufferedContext.beginPath();\n++â”Š   â”Š 54â”Š      this.bufferedContext.rect(0, 0, this.canvas.width, this.canvas.height);\n++â”Š   â”Š 55â”Š      this.bufferedContext.fill();\n++â”Š   â”Š 56â”Š      this.context.drawImage(this.bufferedCanvas, 0, 0);\n++â”Š   â”Š 57â”Š    }\n++â”Š   â”Š 58â”Š  }\n++â”Š   â”Š 59â”Š\n++â”Š   â”Š 60â”Š  update() {\n++â”Š   â”Š 61â”Š    // Calculate the time elapsed\n++â”Š   â”Š 62â”Š    let lastUpdate = this.lastUpdate;\n++â”Š   â”Š 63â”Š    let currUpdate = this.lastUpdate = new Date().getTime();\n++â”Š   â”Š 64â”Š    let span = currUpdate - lastUpdate;\n++â”Š   â”Š 65â”Š    this.updateScreen(span / this.speed);\n++â”Š   â”Š 66â”Š  }\n++â”Š   â”Š 67â”Š\n++â”Š   â”Š 68â”Š  // The main loop of the game\n++â”Š   â”Š 69â”Š  loop() {\n++â”Š   â”Š 70â”Š    // If paused, don't run loop. The canvas will remain as is\n++â”Š   â”Š 71â”Š    if (!this.playing) return;\n++â”Š   â”Š 72â”Š\n++â”Š   â”Š 73â”Š    setTimeout(() => {\n++â”Š   â”Š 74â”Š      this.draw();\n++â”Š   â”Š 75â”Š      this.update();\n++â”Š   â”Š 76â”Š      this.loop();\n++â”Š   â”Š 77â”Š    }, this.fps);\n++â”Š   â”Š 78â”Š  }\n++â”Š   â”Š 79â”Š\n++â”Š   â”Š 80â”Š  play() {\n++â”Š   â”Š 81â”Š    this.playing = true;\n++â”Š   â”Š 82â”Š    this.loop();\n++â”Š   â”Š 83â”Š  }\n++â”Š   â”Š 84â”Š\n++â”Š   â”Š 85â”Š  pause() {\n++â”Š   â”Š 86â”Š    this.playing = false;\n++â”Š   â”Š 87â”Š  }\n++â”Š   â”Š 88â”Š\n++â”Š   â”Š 89â”Š  // Defines global assets\n++â”Š   â”Š 90â”Š  extendAssets(assets) {\n++â”Š   â”Š 91â”Š    _.extend(this.assets, assets);\n++â”Š   â”Š 92â”Š  }\n++â”Š   â”Š 93â”Š\n++â”Š   â”Š 94â”Š  // Disposes global assets\n++â”Š   â”Š 95â”Š  clearAssets() {\n++â”Š   â”Š 96â”Š    this.assets = {};\n++â”Š   â”Š 97â”Š  }\n++â”Š   â”Š 98â”Š\n++â”Š   â”Š 99â”Š  // Adds event listener for game canvas\n++â”Š   â”Š100â”Š  addEventListener(type, listener, target) {\n++â”Š   â”Š101â”Š    let boundListener = listener.bind(target);\n++â”Š   â”Š102â”Š    this.events.set(listener, boundListener);\n++â”Š   â”Š103â”Š    this.canvas.addEventListener(type, boundListener, false);\n++â”Š   â”Š104â”Š  }\n++â”Š   â”Š105â”Š\n++â”Š   â”Š106â”Š  // Removes event listener from game canvas\n++â”Š   â”Š107â”Š  removeEventListener(type, listener) {\n++â”Š   â”Š108â”Š    let boundListener = this.events.get(listener);\n++â”Š   â”Š109â”Š    this.events.delete(listener);\n++â”Š   â”Š110â”Š    this.canvas.removeEventListener(type, boundListener, false);\n++â”Š   â”Š111â”Š  }\n++â”Š   â”Š112â”Š};ðŸš«â†µ\n+```\n+\n+##### Changed views/game.html\n+```diff\n+@@ -9,6 +9,7 @@\n+ â”Š 9â”Š 9â”Š\n+ â”Š10â”Š10â”Š    <!-- Scripts -->\n+ â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n++â”Š  â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n+ â”Š12â”Š13â”Š\n+ â”Š13â”Š14â”Š    <!-- Styles -->\n+ â”Š14â”Š15â”Š    <link rel=\"stylesheet\" type=\"text/css\" href=\"/styles/game.css\">\n+```\n+[}]: #\n+\n+The only thing it's doing right now is only drawing a black background, but we're soon going to learn how to take advantage of this game-loop to draw some custom stuff. I just want to point out that in the `draw` method I used a very handy technique called [double-buffer](https://en.wikipedia.org/wiki/Multiple_buffering), where I first draw everything on a virtual canvas which is not visible to us, and once it's finished, I the result on the main canvas. It behaves the same way React's [virtual DOM](https://www.npmjs.com/package/react-dom) behaves like, and it will prevent our game from stuttering. To start running the game, we first need to wait for the DOM content to initialize, and once its ready we gonna create a new game instance and call the `play` method:\n+\n+[{]: <helper> (diff_step 2.6)\n+#### Step 2.6: Create game entry point\n+\n+##### Added resources/scripts/main.js\n+```diff\n+@@ -0,0 +1,4 @@\n++â”Š â”Š1â”Šdocument.addEventListener(\"DOMContentLoaded\", function(event) {\n++â”Š â”Š2â”Š  let game = new Engine.Game(document.getElementById(\"gameCanvas\"), false);\n++â”Š â”Š3â”Š  game.play();\n++â”Š â”Š4â”Š});ðŸš«â†µ\n+```\n+\n+##### Changed views/game.html\n+```diff\n+@@ -10,6 +10,7 @@\n+ â”Š10â”Š10â”Š    <!-- Scripts -->\n+ â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n+ â”Š12â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n++â”Š  â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n+ â”Š13â”Š14â”Š\n+ â”Š14â”Š15â”Š    <!-- Styles -->\n+ â”Š15â”Š16â”Š    <link rel=\"stylesheet\" type=\"text/css\" href=\"/styles/game.css\">\n+```\n+[}]: #\n+\n+This will take control over the canvas and will draw a new picture every 17ms, which is 60fps (Frames per second). As for now you're only going to see a black canvas, but I promise the final result is not going to disappoint you.\n+\n+The next thing we're gonna do would be adding a 'key state' manager, which will store a flag for each key pressed on the keyboard. Once we press the key, the flag's value would be `true`, and once we release it, its value would turn into `false`. This way we have an easy way to track all the key presses without registering a specific event listener for each key press we wanna track:\n+\n+[{]: <helper> (diff_step 2.7)\n+#### Step 2.7: Add key states manager\n+\n+##### Added resources/scripts/engine/key_states.js\n+```diff\n+@@ -0,0 +1,20 @@\n++â”Š  â”Š 1â”ŠEngine.KeyStates = class KeyStates {\n++â”Š  â”Š 2â”Š  constructor() {\n++â”Š  â”Š 3â”Š    // We will have 255 states, each one represents an ascii code matching its index\n++â”Š  â”Š 4â”Š    this.states = new Array(255);\n++â”Š  â”Š 5â”Š  }\n++â”Š  â”Š 6â”Š\n++â”Š  â”Š 7â”Š  get(k) {\n++â”Š  â”Š 8â”Š    return this.states[k];\n++â”Š  â”Š 9â”Š  }\n++â”Š  â”Š10â”Š\n++â”Š  â”Š11â”Š  // This should be called once we press a key\n++â”Š  â”Š12â”Š  add(k) {\n++â”Š  â”Š13â”Š    this.states[k] = true;\n++â”Š  â”Š14â”Š  }\n++â”Š  â”Š15â”Š\n++â”Š  â”Š16â”Š  // This should be called once we release a key\n++â”Š  â”Š17â”Š  remove(k) {\n++â”Š  â”Š18â”Š    this.states[k] = false;\n++â”Š  â”Š19â”Š  }\n++â”Š  â”Š20â”Š};ðŸš«â†µ\n+```\n+\n+##### Changed views/game.html\n+```diff\n+@@ -9,6 +9,7 @@\n+ â”Š 9â”Š 9â”Š\n+ â”Š10â”Š10â”Š    <!-- Scripts -->\n+ â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n++â”Š  â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/key_states.js\"></script>\n+ â”Š12â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n+ â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n+```\n+[}]: #\n+\n+Now that we have the key state manager, we will initialize a new instance as part of our game's essentials, and we will create a global event listener for key presses; Each time a key is pressed, the key state manager will update itself:\n+\n+[{]: <helper> (diff_step 2.8)\n+#### Step 2.8: Register key presses\n+\n+##### Changed resources/scripts/engine/game.js\n+```diff\n+@@ -15,7 +15,7 @@\n+ â”Š15â”Š15â”Š    this.debugging = debugging;\n+ â”Š16â”Š16â”Š    this.lastUpdate = this.creation = new Date().getTime();\n+ â”Š17â”Š17â”Š\n+-â”Š18â”Š  â”Š    // Canvas dimensions must be set programmatically otherwise you might encounter some\n++â”Š  â”Š18â”Š    // Canvas dimensions must be set programmatically, otherwise you might encounter some\n+ â”Š19â”Š19â”Š    // unexpected behaviors\n+ â”Š20â”Š20â”Š    canvas.width = 1280;\n+ â”Š21â”Š21â”Š    canvas.height = 720;\n+```\n+```diff\n+@@ -25,9 +25,13 @@\n+ â”Š25â”Š25â”Š\n+ â”Š26â”Š26â”Š    // We want to focus on the canvas once we press on it\n+ â”Š27â”Š27â”Š    canvas.addEventListener(\"mousedown\", canvas.focus.bind(canvas), false);\n++â”Š  â”Š28â”Š    // Key flags will be registered by the \"KeyStates\" instance\n++â”Š  â”Š29â”Š    canvas.addEventListener(\"keydown\", onKeyDown.bind(this), false);\n++â”Š  â”Š30â”Š    canvas.addEventListener(\"keyup\", onKeyUp.bind(this), false);\n+ â”Š28â”Š31â”Š\n+ â”Š29â”Š32â”Š    this.assets = {};\n+ â”Š30â”Š33â”Š    this.events = new Map();\n++â”Š  â”Š34â”Š    this.keyStates = new Engine.KeyStates();\n+ â”Š31â”Š35â”Š    this.context = canvas.getContext(\"2d\");\n+ â”Š32â”Š36â”Š    this.bufferedCanvas = document.createElement(\"canvas\");\n+ â”Š33â”Š37â”Š    this.bufferedContext = this.bufferedCanvas.getContext(\"2d\");\n+```\n+```diff\n+@@ -109,4 +113,19 @@\n+ â”Š109â”Š113â”Š    this.events.delete(listener);\n+ â”Š110â”Š114â”Š    this.canvas.removeEventListener(type, boundListener, false);\n+ â”Š111â”Š115â”Š  }\n+-â”Š112â”Š   â”Š};ðŸš«â†µ\n++â”Š   â”Š116â”Š};\n++â”Š   â”Š117â”Š\n++â”Š   â”Š118â”Šfunction onKeyDown(e) {\n++â”Š   â”Š119â”Š  // Once we're focused on the canvas, we want nothing else to happen\n++â”Š   â”Š120â”Š  // besides events the game is listening to. For example, when we press\n++â”Š   â”Š121â”Š  // the arrow keys, this will prevent the screen from scrolling\n++â”Š   â”Š122â”Š  e.preventDefault();\n++â”Š   â”Š123â”Š  // Register key press\n++â”Š   â”Š124â”Š  this.keyStates.add(e.keyCode);\n++â”Š   â”Š125â”Š}\n++â”Š   â”Š126â”Š\n++â”Š   â”Š127â”Šfunction onKeyUp(e) {\n++â”Š   â”Š128â”Š  e.preventDefault();\n++â”Š   â”Š129â”Š  // Register key release\n++â”Š   â”Š130â”Š  this.keyStates.remove(e.keyCode);\n++â”Š   â”Š131â”Š}\n+```\n+[}]: #\n+\n+A 2D game's view might get complex as we go through with its development and add more logic and entities into it. Having only one `draw` method and only one `update` method is not enough, and if you think of it, it might easily get buffed up into ridiculous dimensions, which is not the way to go. I'd like to introduce you into a new methodology which involves `screens` and `layers`:\n+\n+- **screen** - Will literally be used whenever we want to show a new screen in our game e.g. 'splash' screen and 'main menu' screen. A screen consists of multiple layers, and will be used as their communicator; All the relevant assets and logic will be initialized inside it.\n+- **layer** - similar to Photoshop's layer system, any time we want to add something to the view we add new layers on top or beneath of each other.\n+\n+![screen-layer](https://cloud.githubusercontent.com/assets/7648874/21487708/9b366efe-cbb7-11e6-8669-3212e440871a.png)\n+\n+As I said earlier, the purpose of the screens and the layers is just to split the task of updating and drawing and updating, so we can have logical segments; So the `layer` class should mainly consist of a `draw` and an `update` method:\n+\n+[{]: <helper> (diff_step 2.9)\n+#### Step 2.9: Add screen layer\n+\n+##### Added resources/scripts/engine/layer.js\n+```diff\n+@@ -0,0 +1,43 @@\n++â”Š  â”Š 1â”ŠEngine.Layer = class Layer {\n++â”Š  â”Š 2â”Š  // The dimensions of the layer are correlated to dimensions of the canvas\n++â”Š  â”Š 3â”Š  get width() {\n++â”Š  â”Š 4â”Š    return this.canvas.width;\n++â”Š  â”Š 5â”Š  }\n++â”Š  â”Š 6â”Š\n++â”Š  â”Š 7â”Š  get height() {\n++â”Š  â”Š 8â”Š    return this.canvas.height;\n++â”Š  â”Š 9â”Š  }\n++â”Š  â”Š10â”Š\n++â”Š  â”Š11â”Š  // A hash of \"eventName\" : \"handlerName\" which should be overrided by user\n++â”Š  â”Š12â”Š  get events() {\n++â”Š  â”Š13â”Š    return {};\n++â”Š  â”Š14â”Š  }\n++â”Š  â”Š15â”Š\n++â”Š  â”Š16â”Š  constructor(screen) {\n++â”Š  â”Š17â”Š    this.age = 0;\n++â”Š  â”Š18â”Š    this.creation = new Date().getTime();\n++â”Š  â”Š19â”Š    this.screen = screen;\n++â”Š  â”Š20â”Š    this.game = screen.game;\n++â”Š  â”Š21â”Š    this.assets = screen.assets;\n++â”Š  â”Š22â”Š    this.keyStates = screen.keyStates;\n++â”Š  â”Š23â”Š    this.canvas = screen.game.canvas;\n++â”Š  â”Š24â”Š  }\n++â”Š  â”Š25â”Š\n++â”Š  â”Š26â”Š  update(span) {\n++â”Š  â”Š27â”Š  }\n++â”Š  â”Š28â”Š\n++â”Š  â”Š29â”Š  draw(context) {\n++â”Š  â”Š30â”Š  }\n++â”Š  â”Š31â”Š\n++â”Š  â”Š32â”Š  initEventListeners() {\n++â”Š  â”Š33â”Š    _.each(this.events, (listener, event) => {\n++â”Š  â”Š34â”Š      this.game.addEventListener(event, this[listener], this);\n++â”Š  â”Š35â”Š    });\n++â”Š  â”Š36â”Š  }\n++â”Š  â”Š37â”Š\n++â”Š  â”Š38â”Š  disposeEventListeners() {\n++â”Š  â”Š39â”Š    _.each(this.events, (listener, event) => {\n++â”Š  â”Š40â”Š      this.game.removeEventListener(event, this[listener]);\n++â”Š  â”Š41â”Š    });\n++â”Š  â”Š42â”Š  }\n++â”Š  â”Š43â”Š};ðŸš«â†µ\n+```\n+\n+##### Changed views/game.html\n+```diff\n+@@ -10,6 +10,7 @@\n+ â”Š10â”Š10â”Š    <!-- Scripts -->\n+ â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n+ â”Š12â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/key_states.js\"></script>\n++â”Š  â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/layer.js\"></script>\n+ â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n+ â”Š14â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n+```\n+[}]: #\n+\n+Same thing for the screen, it only has a `draw` and `update` methods, only it has a stack of layers, which can either be added or removed:\n+\n+[{]: <helper> (diff_step 2.10)\n+#### Step 2.10: Add game screen\n+\n+##### Added resources/scripts/engine/screen.js\n+```diff\n+@@ -0,0 +1,85 @@\n++â”Š  â”Š 1â”ŠEngine.Screen = class Screen {\n++â”Š  â”Š 2â”Š  // The dimensions of the screen are correlated to dimensions of the canvas\n++â”Š  â”Š 3â”Š  get width() {\n++â”Š  â”Š 4â”Š    return this.canvas.width;\n++â”Š  â”Š 5â”Š  }\n++â”Š  â”Š 6â”Š\n++â”Š  â”Š 7â”Š  get height() {\n++â”Š  â”Š 8â”Š    return this.canvas.height;\n++â”Š  â”Š 9â”Š  }\n++â”Š  â”Š10â”Š\n++â”Š  â”Š11â”Š  // A hash of \"eventName\" : \"handlerName\" which should be overrided by user\n++â”Š  â”Š12â”Š  get events() {\n++â”Š  â”Š13â”Š    return {};\n++â”Š  â”Š14â”Š  }\n++â”Š  â”Š15â”Š\n++â”Š  â”Š16â”Š  constructor(game) {\n++â”Š  â”Š17â”Š    this.age = 0;\n++â”Š  â”Š18â”Š    this.creation = new Date().getTime();\n++â”Š  â”Š19â”Š    this.game = game;\n++â”Š  â”Š20â”Š    this.canvas = game.canvas;\n++â”Š  â”Š21â”Š    this.keyStates = game.keyStates;\n++â”Š  â”Š22â”Š    this.assets = _.clone(game.assets);\n++â”Š  â”Š23â”Š    this.layers = [];\n++â”Š  â”Š24â”Š  }\n++â”Š  â”Š25â”Š\n++â”Š  â”Š26â”Š  // A custom initialization function should be implemented by child-class\n++â”Š  â”Š27â”Š  initialize() {\n++â”Š  â”Š28â”Š    return this;\n++â”Š  â”Š29â”Š  }\n++â”Š  â”Š30â”Š\n++â”Š  â”Š31â”Š  // Updates each layer\n++â”Š  â”Š32â”Š  update(span) {\n++â”Š  â”Š33â”Š    this.layers.forEach(layer => {\n++â”Š  â”Š34â”Š      layer.age += span;\n++â”Š  â”Š35â”Š      layer.update(span);\n++â”Š  â”Š36â”Š    });\n++â”Š  â”Š37â”Š  }\n++â”Š  â”Š38â”Š\n++â”Š  â”Š39â”Š  // Draws each layer\n++â”Š  â”Š40â”Š  draw(context) {\n++â”Š  â”Š41â”Š    this.layers.forEach(layer => {\n++â”Š  â”Š42â”Š      layer.draw(context);\n++â”Š  â”Š43â”Š    });\n++â”Š  â”Š44â”Š  }\n++â”Š  â”Š45â”Š\n++â”Š  â”Š46â”Š  // Push a new layer to the top of the layers stack\n++â”Š  â”Š47â”Š  appendLayer(Layer, ...layerArgs) {\n++â”Š  â”Š48â”Š    let layer = new Layer(this, ...layerArgs);\n++â”Š  â”Š49â”Š    this.layers.push(layer);\n++â”Š  â”Š50â”Š    layer.initEventListeners();\n++â”Š  â”Š51â”Š  }\n++â”Š  â”Š52â”Š\n++â”Š  â”Š53â”Š  // Push a new layer to the bottom of the layers stack\n++â”Š  â”Š54â”Š  prependLayer(Layer, ...layerArgs) {\n++â”Š  â”Š55â”Š    let layer = new Layer(this, ...layerArgs);\n++â”Š  â”Š56â”Š    this.layers.unshift(layer);\n++â”Š  â”Š57â”Š    layer.initEventListeners();\n++â”Š  â”Š58â”Š  }\n++â”Š  â”Š59â”Š\n++â”Š  â”Š60â”Š  // Removes the given layer from the layers stack\n++â”Š  â”Š61â”Š  removeLayer(layer) {\n++â”Š  â”Š62â”Š    this.layers = _.without(this.layers, layer);\n++â”Š  â”Š63â”Š    layer.disposeEventListeners();\n++â”Š  â”Š64â”Š  }\n++â”Š  â”Š65â”Š\n++â”Š  â”Š66â”Š  initEventListeners() {\n++â”Š  â”Š67â”Š    _.each(this.events, (listener, event) => {\n++â”Š  â”Š68â”Š      this.game.addEventListener(event, this[listener], this);\n++â”Š  â”Š69â”Š    });\n++â”Š  â”Š70â”Š\n++â”Š  â”Š71â”Š    this.layers.forEach(layer => {\n++â”Š  â”Š72â”Š      layer.initEventListeners();\n++â”Š  â”Š73â”Š    });\n++â”Š  â”Š74â”Š  }\n++â”Š  â”Š75â”Š\n++â”Š  â”Š76â”Š  disposeEventListeners() {\n++â”Š  â”Š77â”Š    _.each(this.events, (listener, event) => {\n++â”Š  â”Š78â”Š      this.game.removeEventListener(event, this[listener], this);\n++â”Š  â”Š79â”Š    });\n++â”Š  â”Š80â”Š\n++â”Š  â”Š81â”Š    this.layers.forEach(layer => {\n++â”Š  â”Š82â”Š      layer.disposeEventListeners();\n++â”Š  â”Š83â”Š    });\n++â”Š  â”Š84â”Š  }\n++â”Š  â”Š85â”Š};ðŸš«â†µ\n+```\n+\n+##### Changed views/game.html\n+```diff\n+@@ -11,6 +11,7 @@\n+ â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n+ â”Š12â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/key_states.js\"></script>\n+ â”Š13â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/layer.js\"></script>\n++â”Š  â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/screen.js\"></script>\n+ â”Š14â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n+ â”Š15â”Š16â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n+```\n+[}]: #\n+\n+Now that we have the `screen` class available for us, let's apply it to the main game loop:\n+\n+[{]: <helper> (diff_step 2.11)\n+#### Step 2.11: Draw and update screen in game loop\n+\n+##### Changed resources/scripts/engine/game.js\n+```diff\n+@@ -31,6 +31,7 @@\n+ â”Š31â”Š31â”Š\n+ â”Š32â”Š32â”Š    this.assets = {};\n+ â”Š33â”Š33â”Š    this.events = new Map();\n++â”Š  â”Š34â”Š    this.screen = new Engine.Screen(this);\n+ â”Š34â”Š35â”Š    this.keyStates = new Engine.KeyStates();\n+ â”Š35â”Š36â”Š    this.context = canvas.getContext(\"2d\");\n+ â”Š36â”Š37â”Š    this.bufferedCanvas = document.createElement(\"canvas\");\n+```\n+```diff\n+@@ -48,6 +49,7 @@\n+ â”Š48â”Š49â”Š      this.context.beginPath();\n+ â”Š49â”Š50â”Š      this.context.rect(0, 0, this.canvas.width, this.canvas.height);\n+ â”Š50â”Š51â”Š      this.context.fill();\n++â”Š  â”Š52â”Š      this.drawScreen(this.context);\n+ â”Š51â”Š53â”Š    }\n+ â”Š52â”Š54â”Š    // If not debugging, use double buffer to prevent flickering\n+ â”Š53â”Š55â”Š    else {\n+```\n+```diff\n+@@ -57,10 +59,17 @@\n+ â”Š57â”Š59â”Š      this.bufferedContext.beginPath();\n+ â”Š58â”Š60â”Š      this.bufferedContext.rect(0, 0, this.canvas.width, this.canvas.height);\n+ â”Š59â”Š61â”Š      this.bufferedContext.fill();\n++â”Š  â”Š62â”Š      this.drawScreen(this.bufferedContext);\n+ â”Š60â”Š63â”Š      this.context.drawImage(this.bufferedCanvas, 0, 0);\n+ â”Š61â”Š64â”Š    }\n+ â”Š62â”Š65â”Š  }\n+ â”Š63â”Š66â”Š\n++â”Š  â”Š67â”Š  drawScreen(context) {\n++â”Š  â”Š68â”Š    // If screen's assets are not yet loaded, don't draw it\n++â”Š  â”Š69â”Š    if (this.screen.loading) return;\n++â”Š  â”Š70â”Š    if (this.screen.draw) this.screen.draw(context);\n++â”Š  â”Š71â”Š  }\n++â”Š  â”Š72â”Š\n+ â”Š64â”Š73â”Š  update() {\n+ â”Š65â”Š74â”Š    // Calculate the time elapsed\n+ â”Š66â”Š75â”Š    let lastUpdate = this.lastUpdate;\n+```\n+```diff\n+@@ -69,6 +78,13 @@\n+ â”Š69â”Š78â”Š    this.updateScreen(span / this.speed);\n+ â”Š70â”Š79â”Š  }\n+ â”Š71â”Š80â”Š\n++â”Š  â”Š81â”Š  updateScreen(span) {\n++â”Š  â”Š82â”Š    this.screen.age += span;\n++â”Š  â”Š83â”Š    // If screen's assets are not yet loaded, don't update it\n++â”Š  â”Š84â”Š    if (this.screen.loading) return;\n++â”Š  â”Š85â”Š    if (this.screen.update) this.screen.update(span);\n++â”Š  â”Š86â”Š  }\n++â”Š  â”Š87â”Š\n+ â”Š72â”Š88â”Š  // The main loop of the game\n+ â”Š73â”Š89â”Š  loop() {\n+ â”Š74â”Š90â”Š    // If paused, don't run loop. The canvas will remain as is\n+```\n+[}]: #\n+\n+This step looks kind of useless for now, unless we will have the ability to change screens as we please. Any time a screen is changed, it should be loaded with its necessary assets e.g textures, sounds, fonts, etc. The assets loading is an asynchronous operation whose logic might get a bit messy if not managed properly. To make it easier, we're going to define an assets loader, which will help us load assets asynchronously:\n+\n+[{]: <helper> (diff_step 2.12)\n+#### Step 2.12: Add assets loader\n+\n+##### Added resources/scripts/engine/assets_loader.js\n+```diff\n+@@ -0,0 +1,13 @@\n++â”Š  â”Š 1â”ŠEngine.AssetsLoader = class AssetsLoader {\n++â”Š  â”Š 2â”Š  constructor(next) {\n++â”Š  â”Š 3â”Š    this.next = next;\n++â”Š  â”Š 4â”Š  }\n++â”Š  â”Š 5â”Š\n++â”Š  â”Š 6â”Š  // Load texture\n++â”Š  â”Š 7â”Š  texture(path) {\n++â”Š  â”Š 8â”Š    let image = new Image();\n++â”Š  â”Š 9â”Š    image.onload = this.next();\n++â”Š  â”Š10â”Š    image.src = `${path}.png`;\n++â”Š  â”Š11â”Š    return image;\n++â”Š  â”Š12â”Š  }\n++â”Š  â”Š13â”Š};ðŸš«â†µ\n+```\n+\n+##### Changed views/game.html\n+```diff\n+@@ -12,6 +12,7 @@\n+ â”Š12â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/key_states.js\"></script>\n+ â”Š13â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/layer.js\"></script>\n+ â”Š14â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/screen.js\"></script>\n++â”Š  â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/assets_loader.js\"></script>\n+ â”Š15â”Š16â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n+ â”Š16â”Š17â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n+```\n+[}]: #\n+\n+> As for now the `assets loader` only has the ability to load textures, but we will extend it as we go further in this tutorial, no need to overdo it.\n+\n+Now that we have the `assets loader` we can add the ability to change a screen. Whenever we change a screen, the old screen's assets should be unloaded, and the new screen's assets should be loaded using the `assets loader`:\n+\n+[{]: <helper> (diff_step 2.13)\n+#### Step 2.13: Add the ability to change and load screen\n+\n+##### Changed resources/scripts/engine/game.js\n+```diff\n+@@ -106,6 +106,58 @@\n+ â”Š106â”Š106â”Š    this.playing = false;\n+ â”Š107â”Š107â”Š  }\n+ â”Š108â”Š108â”Š\n++â”Š   â”Š109â”Š  changeScreen(Screen, ...screenArgs) {\n++â”Š   â”Š110â”Š    // If there is a screen defined, dispose it first\n++â”Š   â”Š111â”Š    if (this.screen) {\n++â”Š   â”Š112â”Š      this.unloadScreen();\n++â”Š   â”Š113â”Š      this.screen.disposeEventListeners();\n++â”Š   â”Š114â”Š    }\n++â”Š   â”Š115â”Š\n++â”Š   â”Š116â”Š    this.screen = new Screen(this, ...screenArgs);\n++â”Š   â”Š117â”Š\n++â”Š   â”Š118â”Š    // Load screen assets\n++â”Š   â”Š119â”Š    this.loadScreen(() => {\n++â”Š   â”Š120â”Š      // Once assets are loaded, initialize event listeners\n++â”Š   â”Š121â”Š      this.screen.initEventListeners();\n++â”Š   â”Š122â”Š      // The \"initialize\" method is exactly the same as the constructor, only it runs\n++â”Š   â”Š123â”Š      // once assets are available and event listeners are registered\n++â”Š   â”Š124â”Š      this.screen.initialize(this, ...screenArgs);\n++â”Š   â”Š125â”Š    });\n++â”Š   â”Š126â”Š  }\n++â”Š   â”Š127â”Š\n++â”Š   â”Š128â”Š  // Loads screen assets and invokes callback once loading is finished\n++â”Š   â”Š129â”Š  loadScreen(callback = _.noop) {\n++â”Š   â”Š130â”Š    if (!this.screen.load) return callback();\n++â”Š   â”Š131â”Š\n++â”Š   â”Š132â”Š    this.screen.loading = true;\n++â”Š   â”Š133â”Š    // The number of assets to load\n++â”Š   â”Š134â”Š    let loadsize = 0;\n++â”Š   â”Š135â”Š\n++â”Š   â”Š136â”Š    // We use the \"after\" method because we want the following callback to be invoked\n++â”Š   â”Š137â”Š    // only once all assets are loaded\n++â”Š   â”Š138â”Š    let onload = _.after(loadsize, () => {\n++â”Š   â”Š139â”Š      delete this.screen.loading;\n++â”Š   â”Š140â”Š      callback();\n++â”Š   â”Š141â”Š    });\n++â”Š   â”Š142â”Š\n++â”Š   â”Š143â”Š    // This object can load assets\n++â”Š   â”Š144â”Š    let assetsLoader = new Engine.AssetsLoader(() => {\n++â”Š   â”Š145â”Š      loadsize++;\n++â”Š   â”Š146â”Š      return () => onload();\n++â”Š   â”Š147â”Š    });\n++â”Š   â”Š148â”Š\n++â”Š   â”Š149â”Š    // The \"load\" method returns the assets loaded by the screen\n++â”Š   â”Š150â”Š    let screenAssets = this.screen.load(assetsLoader);\n++â”Š   â”Š151â”Š    // The returned assets will be available on screen's assets object\n++â”Š   â”Š152â”Š    _.extend(this.screen.assets, screenAssets);\n++â”Š   â”Š153â”Š  }\n++â”Š   â”Š154â”Š\n++â”Š   â”Š155â”Š  // Disposes screen assets\n++â”Š   â”Š156â”Š  unloadScreen() {\n++â”Š   â”Š157â”Š    let assetsNames = this.screen.unload && this.screen.unload();\n++â”Š   â”Š158â”Š    _.omit(this.assets, assetsNames);\n++â”Š   â”Š159â”Š  }\n++â”Š   â”Š160â”Š\n+ â”Š109â”Š161â”Š  // Defines global assets\n+ â”Š110â”Š162â”Š  extendAssets(assets) {\n+ â”Š111â”Š163â”Š    _.extend(this.assets, assets);\n+```\n+[}]: #\n+\n+Let's add a test screen just so we can get the hang of it. The test screen will only print a message to the canvas:\n+\n+[{]: <helper> (diff_step 2.14)\n+#### Step 2.14: Add test screen\n+\n+##### Added resources/scripts/test_screen.js\n+```diff\n+@@ -0,0 +1,10 @@\n++â”Š  â”Š 1â”Šclass TestScreen extends Engine.Screen {\n++â”Š  â”Š 2â”Š  draw(context) {\n++â”Š  â”Š 3â”Š    // A 20px sized \"Georgia\" font (Available natively)\n++â”Š  â”Š 4â”Š    context.font = \"20px Georgia\";\n++â”Š  â”Š 5â”Š    // The text should be colored white\n++â”Š  â”Š 6â”Š    context.fillStyle = \"white\";\n++â”Š  â”Š 7â”Š    // Draw the following message 50px from the left and 50px from the top\n++â”Š  â”Š 8â”Š    context.fillText(\"This is a Test Screen\", 50, 50);\n++â”Š  â”Š 9â”Š  }\n++â”Š  â”Š10â”Š};ðŸš«â†µ\n+```\n+\n+##### Changed views/game.html\n+```diff\n+@@ -14,6 +14,7 @@\n+ â”Š14â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/screen.js\"></script>\n+ â”Š15â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/assets_loader.js\"></script>\n+ â”Š16â”Š16â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n++â”Š  â”Š17â”Š    <script type=\"text/javascript\" src=\"/scripts/test_screen.js\"></script>\n+ â”Š17â”Š18â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n+ â”Š18â”Š19â”Š\n+ â”Š19â”Š20â”Š    <!-- Styles -->\n+```\n+[}]: #\n+\n+Now we will use the test screen by changing to it as we create an instance of the game:\n+\n+[{]: <helper> (diff_step 2.15)\n+#### Step 2.15: Set test screen as the initial screen\n+\n+##### Changed resources/scripts/main.js\n+```diff\n+@@ -1,4 +1,5 @@\n+ â”Š1â”Š1â”Šdocument.addEventListener(\"DOMContentLoaded\", function(event) {\n+ â”Š2â”Š2â”Š  let game = new Engine.Game(document.getElementById(\"gameCanvas\"), false);\n++â”Š â”Š3â”Š  game.changeScreen(TestScreen);\n+ â”Š3â”Š4â”Š  game.play();\n+ â”Š4â”Š5â”Š});ðŸš«â†µ\n+```\n+[}]: #\n+\n+Once you will load the application you should see a black canvas with a white text saying:\n+\n+    This is a test screen\n+\n+It means our screen system works and you may proceed to the next step, where we're gonna create our first screen :-)\n+[}]: #\n+[{]: <region> (footer)\n+[{]: <helper> (nav_step)\n+| [< Previous Step](step1.md) | [Next Step >](step3.md) |\n+|:--------------------------------|--------------------------------:|\n+[}]: #\n+[}]: #\n\\ No newline at end of file\ndiff --git a/manuals/views/step3.md b/manuals/views/step3.md\nnew file mode 100644\nindex 0000000..2ad11a0\n--- /dev/null\n+++ b/manuals/views/step3.md\n@@ -0,0 +1,465 @@\n+[{]: <region> (header)\n+# Step 3: Creating a splash screen using a keyframe animation engine\n+[}]: #\n+[{]: <region> (body)\n+![snake-demo-splash-small](https://cloud.githubusercontent.com/assets/7648874/21074086/a19fa9ce-bed6-11e6-9060-2ce94c215712.gif)\n+\n+In this step we will be creating the `splash` screen - the initial screen that should be shown once we launch the game. Our splash is consisted of a random logo animation as presented in the `gif` file above. The \"splash\" effect can be achieved using 2 concepts:\n+\n+- A sprite class - Which will present the logo texture in different dimensions, angles and rotations.\n+- A key-frame animation - Which will draw an animation automatically along the time axis using key-frames - each is a sprite representation of the texture in a specific time point.\n+\n+So first thing first, we will start by implementing the sprite class:\n+\n+[{]: <helper> (diff_step 3.1)\n+#### Step 3.1: Create 'Sprite' class\n+\n+##### Added resources/scripts/engine/sprite.js\n+```diff\n+@@ -0,0 +1,58 @@\n++â”Š  â”Š 1â”ŠEngine.Sprite = class Sprite {\n++â”Š  â”Š 2â”Š  // An easy representation of a sprite on a canvas, with a set of convenient tools\n++â”Š  â”Š 3â”Š  // for alignment and coloring\n++â”Š  â”Š 4â”Š  constructor(texture) {\n++â”Š  â”Š 5â”Š    this.texture = texture;\n++â”Š  â”Š 6â”Š    this.x = 0;\n++â”Š  â”Š 7â”Š    this.y = 0;\n++â”Š  â”Š 8â”Š    this.width = texture.width;\n++â”Š  â”Š 9â”Š    this.height = texture.height;\n++â”Š  â”Š10â”Š    this.pivot = { x: 0, y: 0 };\n++â”Š  â”Š11â”Š    this.opacity = 1;\n++â”Š  â”Š12â”Š  }\n++â”Š  â”Š13â”Š\n++â”Š  â”Š14â”Š  draw(context, offsetX = 0, offsetY = 0) {\n++â”Š  â”Š15â”Š    context.save();\n++â”Š  â”Š16â”Š    context.globalAlpha = this.opacity;\n++â”Š  â”Š17â”Š\n++â”Š  â”Š18â”Š    // The following switch-case can also be seen as a list of all possible\n++â”Š  â”Š19â”Š    // alignment modes\n++â”Š  â”Š20â”Š    switch (this.align) {\n++â”Š  â”Š21â”Š      case \"top-left\": case \"left-top\": this.pivot = { x: 0, y: 0 }; break;\n++â”Š  â”Š22â”Š      case \"top-right\": case \"right-top\": this.pivot = { x: this.width, y: 0 }; break;\n++â”Š  â”Š23â”Š      case \"bottom-left\": case \"left-bottom\": this.pivot = { x: 0, y: this.height }; break;\n++â”Š  â”Š24â”Š      case \"bottom-right\": case \"right-bottom\": this.pivot = { x: this.width, y: this.height }; break;\n++â”Š  â”Š25â”Š      case \"middle\": case \"center\": this.pivot = { x: this.width / 2, y: this.height / 2 }; break;\n++â”Š  â”Š26â”Š      case \"left\": this.pivot = { x: 0, y: this.height / 2 }; break;\n++â”Š  â”Š27â”Š      case \"top\": this.pivot = { x: this.width / 2, y: 0 }; break;\n++â”Š  â”Š28â”Š      case \"right\": this.pivot = { x: this.width, y: this.height / 2 }; break;\n++â”Š  â”Š29â”Š      case \"bottom\": this.pivot = { x: this.width / 2, y: this.height }; break;\n++â”Š  â”Š30â”Š    }\n++â”Š  â”Š31â”Š\n++â”Š  â”Š32â”Š    context.drawImage(\n++â”Š  â”Š33â”Š      this.texture,\n++â”Š  â”Š34â”Š      (this.x - this.pivot.x) + offsetX,\n++â”Š  â”Š35â”Š      (this.y - this.pivot.y) + offsetY,\n++â”Š  â”Š36â”Š      this.width,\n++â”Š  â”Š37â”Š      this.height\n++â”Š  â”Š38â”Š    );\n++â”Š  â”Š39â”Š\n++â”Š  â”Š40â”Š    context.restore();\n++â”Š  â”Š41â”Š  }\n++â”Š  â”Š42â”Š\n++â”Š  â”Š43â”Š  // A sprite property (key) can also be resized based on a given percentage.\n++â”Š  â”Š44â”Š  // The 'relative' argument represents the whole of which the percents are gonna be\n++â”Š  â”Š45â”Š  // calculated from, and the 'adapters' argument is an array of property names which\n++â”Š  â”Š46â”Š  // gonna adapt themselves based on the changes made in the given key.\n++â”Š  â”Š47â”Š  // Usually 'width' goes along with ['height'] adapters, if we\n++â”Š  â”Š48â”Š  // want to keep their original ratio\n++â”Š  â”Š49â”Š  setPercentage(key, relative, percents, ...adapters) {\n++â”Š  â”Š50â”Š    let oldVal = this[key];\n++â”Š  â”Š51â”Š    let newVal = this[key] = (percents * relative) / 100;\n++â”Š  â”Š52â”Š    let ratio = newVal / oldVal;\n++â”Š  â”Š53â”Š\n++â”Š  â”Š54â”Š    adapters.forEach(adapter => {\n++â”Š  â”Š55â”Š      this[adapter] *= ratio;\n++â”Š  â”Š56â”Š    });\n++â”Š  â”Š57â”Š  }\n++â”Š  â”Š58â”Š};ðŸš«â†µ\n+```\n+\n+##### Changed views/game.html\n+```diff\n+@@ -9,6 +9,7 @@\n+ â”Š 9â”Š 9â”Š\n+ â”Š10â”Š10â”Š    <!-- Scripts -->\n+ â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n++â”Š  â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/sprite.js\"></script>\n+ â”Š12â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/key_states.js\"></script>\n+ â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/layer.js\"></script>\n+ â”Š14â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/screen.js\"></script>\n+```\n+[}]: #\n+\n+And we will download the logo which will be presented in the splash screen using the sprite class:\n+\n+    resources$ mkdir assets\n+    resources$ cd assets\n+    resources/assets$ mkdir textures\n+    resources/assets$ cd textures\n+    resources/assets/textures$ wget raw.githubusercontent.com/dab0mb/radial-snake/master/resources/assets/textures/splash.png\n+\n+> Any logo can that you desired can be used instead! But to ease things up I already provided you with one as a sample\n+\n+Now we will create the initial splash screen, where we only gonna show a sprite of the logo in the middle of the screen, with no animation applied yet. We will first define a dedicated `Screens` module under the `Game` namespace:\n+\n+[{]: <helper> (diff_step 3.3)\n+#### Step 3.3: Create a 'Game' namespace with a 'Screens' module\n+\n+##### Changed resources/scripts/namespaces.js\n+```diff\n+@@ -1 +1,5 @@\n++â”Š â”Š1â”ŠGame = {\n++â”Š â”Š2â”Š  Screens: {}\n++â”Š â”Š3â”Š};\n++â”Š â”Š4â”Š\n+ â”Š1â”Š5â”ŠEngine = {};ðŸš«â†µ\n+```\n+[}]: #\n+\n+And we can go ahead and implement the screen itself:\n+\n+[{]: <helper> (diff_step 3.4)\n+#### Step 3.4: Create initial splash screen\n+\n+##### Added resources/scripts/game/screens/splash/index.js\n+```diff\n+@@ -0,0 +1,19 @@\n++â”Š  â”Š 1â”ŠGame.Screens.Splash = class Splash extends Engine.Screen {\n++â”Š  â”Š 2â”Š  initialize() {\n++â”Š  â”Š 3â”Š    // Create splash sprite and set its properties\n++â”Š  â”Š 4â”Š    this.splashSprite = new Engine.Sprite(this.assets.splashTexture);\n++â”Š  â”Š 5â”Š    this.splashSprite.align = \"center\";\n++â”Š  â”Š 6â”Š    this.splashSprite.x = this.width / 2;\n++â”Š  â”Š 7â”Š  }\n++â”Š  â”Š 8â”Š\n++â”Š  â”Š 9â”Š  load(assetsLoader) {\n++â”Š  â”Š10â”Š    // These are local assets which will be disposed along with the screen\n++â”Š  â”Š11â”Š    return {\n++â”Š  â”Š12â”Š      splashTexture: assetsLoader.texture(\"/textures/splash\")\n++â”Š  â”Š13â”Š    };\n++â”Š  â”Š14â”Š  }\n++â”Š  â”Š15â”Š\n++â”Š  â”Š16â”Š  draw(context) {\n++â”Š  â”Š17â”Š    this.splashSprite.draw(context);\n++â”Š  â”Š18â”Š  }\n++â”Š  â”Š19â”Š};ðŸš«â†µ\n+```\n+\n+##### Changed views/game.html\n+```diff\n+@@ -16,6 +16,7 @@\n+ â”Š16â”Š16â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/assets_loader.js\"></script>\n+ â”Š17â”Š17â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n+ â”Š18â”Š18â”Š    <script type=\"text/javascript\" src=\"/scripts/test_screen.js\"></script>\n++â”Š  â”Š19â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/splash/index.js\"></script>\n+ â”Š19â”Š20â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n+ â”Š20â”Š21â”Š\n+ â”Š21â”Š22â”Š    <!-- Styles -->\n+```\n+[}]: #\n+\n+Now we can set the splash screen as the initial screen in the entry script file:\n+\n+[{]: <helper> (diff_step 3.5)\n+#### Step 3.5: Set splash screen as the initial game screen\n+\n+##### Changed resources/scripts/main.js\n+```diff\n+@@ -1,5 +1,5 @@\n+ â”Š1â”Š1â”Šdocument.addEventListener(\"DOMContentLoaded\", function(event) {\n+ â”Š2â”Š2â”Š  let game = new Engine.Game(document.getElementById(\"gameCanvas\"), false);\n+-â”Š3â”Š â”Š  game.changeScreen(TestScreen);\n++â”Š â”Š3â”Š  game.changeScreen(Game.Screens.Splash);\n+ â”Š4â”Š4â”Š  game.play();\n+ â”Š5â”Š5â”Š});ðŸš«â†µ\n+```\n+[}]: #\n+\n+And we will get rid of the unnecessary test screen since we make no use of it any longer:\n+\n+    $ rm resources/scripts/test_screen.js\n+\n+We will now proceed into the next stage where we will be implementing the key-frame animation engine as said at the beginning of the step. We first need to define an `Animations` module, since we can have multiple types of animation strategy like [sprite-atlas animation](http://www.joshmorony.com/how-to-create-animations-in-phaser-with-a-texture-atlas/), not necessarily a key-frame animation:\n+\n+[{]: <helper> (diff_step 3.7)\n+#### Step 3.7: Add 'Animations' module to 'Engine' namespace\n+\n+##### Changed resources/scripts/namespaces.js\n+```diff\n+@@ -2,4 +2,6 @@\n+ â”Š2â”Š2â”Š  Screens: {}\n+ â”Š3â”Š3â”Š};\n+ â”Š4â”Š4â”Š\n+-â”Š5â”Š â”ŠEngine = {};ðŸš«â†µ\n++â”Š â”Š5â”ŠEngine = {\n++â”Š â”Š6â”Š  Animations: {}\n++â”Š â”Š7â”Š};ðŸš«â†µ\n+```\n+[}]: #\n+\n+Inside the newly created module we will create the key-frame animation engine. The key-frame animation consists of the following methods:\n+\n+- update - Updates the animation.\n+- draw - Draws the current animation frame on the provided canvas context.\n+- play - Enables update operations.\n+- pause - Disables update operations.\n+\n+[{]: <helper> (diff_step 3.8)\n+#### Step 3.8: Create a key-frame animation engine\n+\n+##### Added resources/scripts/engine/animations/keyframe.js\n+```diff\n+@@ -0,0 +1,142 @@\n++â”Š   â”Š  1â”ŠEngine.Animations.Keyframe = class Keyframe {\n++â”Š   â”Š  2â”Š  constructor(sprite, keyframes) {\n++â”Š   â”Š  3â”Š    this.sprite = sprite;\n++â”Š   â”Š  4â”Š    // The key-frames array contains objects with the properties of the\n++â”Š   â”Š  5â”Š    // sprite at the current time-point, e.g. width of 100 and height of 200\n++â”Š   â”Š  6â”Š    this.keyframes = keyframes;\n++â”Š   â”Š  7â”Š    this.age = 0;\n++â”Š   â”Š  8â”Š    this.frame = 0;\n++â”Š   â”Š  9â”Š    // This flag determines what's gonna happen to the animation once\n++â”Š   â”Š 10â”Š    // it's finished playing\n++â”Š   â”Š 11â”Š    this.repetitionMode = \"none\";\n++â”Š   â”Š 12â”Š    this.lastKeyframe = _.last(keyframes);\n++â”Š   â”Š 13â”Š    this.lastFrame = this.lastKeyframe.frame;\n++â”Š   â”Š 14â”Š\n++â”Š   â”Š 15â”Š    // These are the properties which we can animate\n++â”Š   â”Š 16â”Š    this.animables = [\n++â”Š   â”Š 17â”Š      \"x\", \"y\", \"width\", \"height\", \"opacity\"\n++â”Š   â”Š 18â”Š    ];\n++â”Š   â”Š 19â”Š\n++â”Š   â”Š 20â”Š    // Set a map whose keys represent animatable properties and values represent an array\n++â”Š   â”Š 21â”Š    // with relevant key-frames to its belonging property\n++â”Š   â”Š 22â”Š    this.trimmedKeyframes = this.animables.reduce((trimmedKeyframes, key) => {\n++â”Š   â”Š 23â”Š      trimmedKeyframes[key] = keyframes.filter(keyframe => keyframe[key] != null);\n++â”Š   â”Š 24â”Š      return trimmedKeyframes;\n++â”Š   â”Š 25â”Š    }, {});\n++â”Š   â”Š 26â”Š\n++â”Š   â”Š 27â”Š    // Set initial properties on sprite based on initial key-frame\n++â”Š   â”Š 28â”Š    _.each(keyframes[0], (value, key) => {\n++â”Š   â”Š 29â”Š      if (this.animables.includes(key)) sprite[key] = value;\n++â”Š   â”Š 30â”Š    });\n++â”Š   â”Š 31â”Š  }\n++â”Š   â”Š 32â”Š\n++â”Š   â”Š 33â”Š  draw(context, offsetX, offsetY) {\n++â”Š   â”Š 34â”Š    this.sprite.draw(context, offsetX, offsetY);\n++â”Š   â”Š 35â”Š  }\n++â”Š   â”Š 36â”Š\n++â”Š   â”Š 37â”Š  update(span) {\n++â”Š   â”Š 38â”Š    if (!this.playing) return;\n++â”Š   â”Š 39â”Š\n++â”Š   â”Š 40â”Š    this.age += span;\n++â”Š   â”Š 41â”Š\n++â”Š   â”Š 42â”Š    switch (this.repetitionMode) {\n++â”Š   â”Š 43â”Š      // After one cycle animation would stop\n++â”Š   â”Š 44â”Š      case \"none\":\n++â”Š   â”Š 45â”Š        this.frame += span;\n++â”Š   â”Š 46â”Š\n++â”Š   â”Š 47â”Š        if (this.frame > this.lastFrame) {\n++â”Š   â”Š 48â”Š          this.frame = this.lastFrame;\n++â”Š   â”Š 49â”Š          this.playing = false;\n++â”Š   â”Š 50â”Š        }\n++â”Š   â”Š 51â”Š\n++â”Š   â”Š 52â”Š        break;\n++â”Š   â”Š 53â”Š\n++â”Š   â”Š 54â”Š      // Once finished, replay from the beginning\n++â”Š   â”Š 55â”Š      case \"cyclic\":\n++â”Š   â”Š 56â”Š        this.frame = this.age % this.lastFrame;\n++â”Š   â”Š 57â”Š        break;\n++â”Š   â”Š 58â”Š\n++â”Š   â”Š 59â”Š      // Once finished, play backwards, and so on\n++â”Š   â”Š 60â”Š      case \"full\":\n++â”Š   â”Š 61â”Š        this.frame = this.age % this.lastFrame;\n++â”Š   â”Š 62â”Š        let animationComplete = (this.age / this.lastFrame) % 2 >= 1;\n++â”Š   â”Š 63â”Š        if (animationComplete) this.frame = this.lastFrame - this.frame;\n++â”Š   â”Š 64â”Š        break;\n++â”Š   â”Š 65â”Š    }\n++â”Š   â”Š 66â”Š\n++â”Š   â”Š 67â”Š    // Update sprite properties based on given key-frame's easing mode\n++â”Š   â”Š 68â”Š    this.animables.forEach(key => {\n++â”Š   â”Š 69â”Š      let motion = this.getKeyframeMotion(key);\n++â”Š   â”Š 70â”Š\n++â”Š   â”Š 71â”Š      if (motion)\n++â”Š   â”Š 72â”Š        this.sprite[key] = this.calculateRelativeValue(motion, key);\n++â”Š   â”Š 73â”Š    });\n++â”Š   â”Š 74â”Š  }\n++â”Š   â”Š 75â”Š\n++â”Š   â”Š 76â”Š  play() {\n++â”Š   â”Š 77â”Š    this.playing = true;\n++â”Š   â”Š 78â”Š  }\n++â”Š   â”Š 79â”Š\n++â”Š   â”Š 80â”Š  pause() {\n++â”Š   â”Š 81â”Š    this.playing = false;\n++â”Š   â”Š 82â”Š  }\n++â”Š   â”Š 83â”Š\n++â”Š   â”Š 84â”Š  // Gets motion for current refresh\n++â”Š   â”Š 85â”Š  getKeyframeMotion(key) {\n++â”Š   â”Š 86â”Š    let keyframes = this.trimmedKeyframes[key];\n++â”Š   â”Š 87â”Š\n++â”Š   â”Š 88â”Š    // If no key-frames defined, motion is idle\n++â”Š   â”Š 89â”Š    if (keyframes == null) return;\n++â”Š   â”Š 90â”Š    // If there is only one key frame, motion is idle\n++â”Š   â”Š 91â”Š    if (keyframes.length < 2) return;\n++â”Š   â”Š 92â”Š    // If last frame reached, motion is idle\n++â”Š   â”Š 93â”Š    if (this.frame > _.last(keyframes).frame) return;\n++â”Š   â”Š 94â”Š\n++â”Š   â”Š 95â”Š    let start = this.findStartKeyframe(keyframes);\n++â”Š   â”Š 96â”Š    let end = this.findEndKeyframe(keyframes);\n++â”Š   â”Š 97â”Š    let ratio = this.getKeyframesRatio(start, end);\n++â”Š   â”Š 98â”Š\n++â”Š   â”Š 99â”Š    return { start, end, ratio };\n++â”Š   â”Š100â”Š  }\n++â”Š   â”Š101â”Š\n++â”Š   â”Š102â”Š  // Gets the movement ratio\n++â”Š   â”Š103â”Š  getKeyframesRatio(start, end) {\n++â”Š   â”Š104â”Š    return (this.frame - start.frame) / (end.frame - start.frame);\n++â”Š   â”Š105â”Š  }\n++â”Š   â”Š106â”Š\n++â”Š   â”Š107â”Š  // Get property end value based on current frame\n++â”Š   â”Š108â”Š  findEndKeyframe(keyframes) {\n++â”Š   â”Š109â”Š    return _.find(keyframes, keyframe =>\n++â”Š   â”Š110â”Š      keyframe.frame >= (this.frame || 1)\n++â”Š   â”Š111â”Š    );\n++â”Š   â”Š112â”Š  }\n++â”Š   â”Š113â”Š\n++â”Š   â”Š114â”Š  // Get property start value based on current frame\n++â”Š   â”Š115â”Š  findStartKeyframe(keyframes) {\n++â”Š   â”Š116â”Š    let resultIndex;\n++â”Š   â”Š117â”Š\n++â”Š   â”Š118â”Š    keyframes.some((keyframe, currIndex) => {\n++â”Š   â”Š119â”Š      if (keyframe.frame >= (this.frame || 1)) {\n++â”Š   â”Š120â”Š        resultIndex = currIndex;\n++â”Š   â”Š121â”Š        return true;\n++â”Š   â”Š122â”Š      }\n++â”Š   â”Š123â”Š    });\n++â”Š   â”Š124â”Š\n++â”Š   â”Š125â”Š    return keyframes[resultIndex - 1];\n++â”Š   â”Š126â”Š  }\n++â”Š   â”Š127â”Š\n++â”Š   â”Š128â”Š  // Get a recalculated property value relative to provided easing mode\n++â”Š   â”Š129â”Š  calculateRelativeValue(motion, key) {\n++â”Š   â”Š130â”Š    let a = motion.start[key];\n++â”Š   â”Š131â”Š    let b = motion.end[key];\n++â”Š   â”Š132â”Š    let r = motion.ratio;\n++â”Š   â”Š133â”Š    let easing = r > 0 ? motion.start.easing : motion.end.easing;\n++â”Š   â”Š134â”Š\n++â”Š   â”Š135â”Š    switch (easing) {\n++â”Š   â”Š136â”Š      case \"in\": r = Math.sin((r * Math.PI) / 2); break;\n++â”Š   â”Š137â”Š      case \"out\": r = Math.cos((r * Math.PI) / 2); break;\n++â”Š   â”Š138â”Š    }\n++â”Š   â”Š139â”Š\n++â”Š   â”Š140â”Š    return ((b - a) * r) + a;\n++â”Š   â”Š141â”Š  }\n++â”Š   â”Š142â”Š};ðŸš«â†µ\n+```\n+\n+##### Changed views/game.html\n+```diff\n+@@ -10,6 +10,7 @@\n+ â”Š10â”Š10â”Š    <!-- Scripts -->\n+ â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n+ â”Š12â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/sprite.js\"></script>\n++â”Š  â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/animations/keyframe.js\"></script>\n+ â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/key_states.js\"></script>\n+ â”Š14â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/layer.js\"></script>\n+ â”Š15â”Š16â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/screen.js\"></script>\n+```\n+[}]: #\n+\n+When initializing a new instance of the key-frame animation, we should invoke it with the desired sprite, and an array of key-frames. What exactly does a single key-frame represents? The properties of the sprite at that specific time point. In addition, a key-frame can be set with an [easing mode](https://css-tricks.com/ease-out-in-ease-in-out/) of `in` and `out`. By default, the animation would be linear.\n+\n+Based on the `repitationMode` property, three things can happen to the animation once finished:\n+\n+- `none` - The animation will play once, and then stop. It will appear as a static sprite.\n+- `cyclic` - The animation will repeat itself from the beginning, over and over again until stopped manually.\n+- `full` - The animation will play itself backwards, and then forwards, backwards, forwards, and so on.\n+\n+Thanks to the key-frame animation engine, we can apply it to the splash screen to show a beautifully animated logo rather than showing a static image. So in addition to the logo sprite, we will initialize a key-frame animation as well:\n+\n+[{]: <helper> (diff_step 3.9)\n+#### Step 3.9: Apply key-frame animation to splash screen\n+\n+##### Changed resources/scripts/game/screens/splash/index.js\n+```diff\n+@@ -1,9 +1,34 @@\n+ â”Š 1â”Š 1â”ŠGame.Screens.Splash = class Splash extends Engine.Screen {\n+ â”Š 2â”Š 2â”Š  initialize() {\n+ â”Š 3â”Š 3â”Š    // Create splash sprite and set its properties\n+-â”Š 4â”Š  â”Š    this.splashSprite = new Engine.Sprite(this.assets.splashTexture);\n+-â”Š 5â”Š  â”Š    this.splashSprite.align = \"center\";\n+-â”Š 6â”Š  â”Š    this.splashSprite.x = this.width / 2;\n++â”Š  â”Š 4â”Š    let splashSprite = new Engine.Sprite(this.assets.splashTexture);\n++â”Š  â”Š 5â”Š    splashSprite.align = \"center\";\n++â”Š  â”Š 6â”Š    splashSprite.x = this.width / 2;\n++â”Š  â”Š 7â”Š\n++â”Š  â”Š 8â”Š    // Create splash sprite animation\n++â”Š  â”Š 9â”Š    this.splashAnim = new Engine.Animations.Keyframe(splashSprite, [\n++â”Š  â”Š10â”Š      {\n++â”Š  â”Š11â”Š        y: (this.height / 2) - 30,\n++â”Š  â”Š12â”Š        width: splashSprite.width / 4,\n++â”Š  â”Š13â”Š        height: splashSprite.height / 4,\n++â”Š  â”Š14â”Š        opacity: 0,\n++â”Š  â”Š15â”Š        easing: \"in\",\n++â”Š  â”Š16â”Š        frame: 0\n++â”Š  â”Š17â”Š      },\n++â”Š  â”Š18â”Š      {\n++â”Š  â”Š19â”Š        y: this.height / 2,\n++â”Š  â”Š20â”Š        width: (splashSprite.width / 3) + (splashSprite.width * 0.05),\n++â”Š  â”Š21â”Š        height: (splashSprite.height / 3) + (splashSprite.height * 0.05),\n++â”Š  â”Š22â”Š        opacity: 1,\n++â”Š  â”Š23â”Š        frame: 3000\n++â”Š  â”Š24â”Š      },\n++â”Š  â”Š25â”Š      {\n++â”Š  â”Š26â”Š        frame: 3500\n++â”Š  â”Š27â”Š      }\n++â”Š  â”Š28â”Š    ]);\n++â”Š  â”Š29â”Š\n++â”Š  â”Š30â”Š    // Start playing animation\n++â”Š  â”Š31â”Š    this.splashAnim.play();\n+ â”Š 7â”Š32â”Š  }\n+ â”Š 8â”Š33â”Š\n+ â”Š 9â”Š34â”Š  load(assetsLoader) {\n+```\n+```diff\n+@@ -14,6 +39,10 @@\n+ â”Š14â”Š39â”Š  }\n+ â”Š15â”Š40â”Š\n+ â”Š16â”Š41â”Š  draw(context) {\n+-â”Š17â”Š  â”Š    this.splashSprite.draw(context);\n++â”Š  â”Š42â”Š    this.splashAnim.draw(context);\n++â”Š  â”Š43â”Š  }\n++â”Š  â”Š44â”Š\n++â”Š  â”Š45â”Š  update(span) {\n++â”Š  â”Š46â”Š    this.splashAnim.update(span);\n+ â”Š18â”Š47â”Š  }\n+ â”Š19â”Š48â”Š};ðŸš«â†µ\n+```\n+[}]: #\n+\n+The following key-frames illustrate the nodes of the animation we've just created:\n+\n+    width: 0\n+    height: 0\n+    opacity: 0\n+\n+![logo-empty](https://cloud.githubusercontent.com/assets/7648874/21583394/ee7a1dec-d065-11e6-80ce-fdd37c4b5dbb.png)\n+\n+    width: 225\n+    height: 175\n+    opacity: 1\n+\n+![logo-half](https://cloud.githubusercontent.com/assets/7648874/21583396/ee9bdf68-d065-11e6-95fb-4cf5ed58a9de.png)\n+\n+    width: 342\n+    height: 266\n+    opacity: 1\n+\n+![logo-full](https://cloud.githubusercontent.com/assets/7648874/21583395/ee7b3754-d065-11e6-9646-476d196a6412.png)\n+[}]: #\n+[{]: <region> (footer)\n+[{]: <helper> (nav_step)\n+| [< Previous Step](step2.md) | [Next Step >](step4.md) |\n+|:--------------------------------|--------------------------------:|\n+[}]: #\n+[}]: #\n\\ No newline at end of file\ndiff --git a/manuals/views/step4.md b/manuals/views/step4.md\nnew file mode 100644\nindex 0000000..90831fe\n--- /dev/null\n+++ b/manuals/views/step4.md\n@@ -0,0 +1,594 @@\n+[{]: <region> (header)\n+# Step 4: Creating a main menu screen using a font engine\n+[}]: #\n+[{]: <region> (body)\n+![snake-demo-menu-small](https://cloud.githubusercontent.com/assets/7648874/21074099/e72a81bc-bed6-11e6-98cb-329dc12a4b06.gif)\n+\n+In this step we will be creating the main menu screen as shown above. The main menu screen is a simple screen which will show the logo of the game and an instruction text saying `Press a key to start`. We will be using a simple texture to show the game-logo and we will use the key-frame animation engine to show a flickering animation of the instruction text. The instruction text is the main part of this step, since it is made out of a font file (`.ttf`) and the text is auto-generated, a general solution which can serve us in many situations. We will start by implementing the main menu using static assets, which means that we will use a texture to show the instructions text, and later on we will implement the generic solution I've just mentioned. First, we will download the necessary assets:\n+\n+    resources/assets/textures$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/assets/textures/instructions.png\n+    resources/assets/textures$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/assets/textures/logo.png\n+\n+And then we will implement the initial main menu screen:\n+\n+[{]: <helper> (diff_step 4.2)\n+#### Step 4.2: Create initial main menu screen\n+\n+##### Added resources/scripts/game/screens/menu/index.js\n+```diff\n+@@ -0,0 +1,44 @@\n++â”Š  â”Š 1â”ŠGame.Screens.Menu = class Menu extends Engine.Screen {\n++â”Š  â”Š 2â”Š  initialize() {\n++â”Š  â”Š 3â”Š    // Initialize snake logo sprite\n++â”Š  â”Š 4â”Š    this.logoSprite = new Engine.Sprite(this.assets.logoTexture);\n++â”Š  â”Š 5â”Š    this.logoSprite.setPercentage(\"width\", this.width, 30, \"height\");\n++â”Š  â”Š 6â”Š\n++â”Š  â”Š 7â”Š    // Initialize instructions sprite\n++â”Š  â”Š 8â”Š    let instructionsSprite = new Engine.Sprite(this.assets.instructionsTexture);\n++â”Š  â”Š 9â”Š    instructionsSprite.align = \"center\";\n++â”Š  â”Š10â”Š    instructionsSprite.setPercentage(\"width\", this.width, 35, \"height\");\n++â”Š  â”Š11â”Š    instructionsSprite.x = this.width / 2;\n++â”Š  â”Š12â”Š    instructionsSprite.y = this.height / 2;\n++â”Š  â”Š13â”Š\n++â”Š  â”Š14â”Š    // Create flickering animation for instructions sprite\n++â”Š  â”Š15â”Š    this.instructionsAnim = new Engine.Animations.Keyframe(instructionsSprite, [\n++â”Š  â”Š16â”Š      {\n++â”Š  â”Š17â”Š        opacity: 1,\n++â”Š  â”Š18â”Š        frame: 0\n++â”Š  â”Š19â”Š      },\n++â”Š  â”Š20â”Š      {\n++â”Š  â”Š21â”Š        opacity: 0,\n++â”Š  â”Š22â”Š        frame: 2000\n++â”Š  â”Š23â”Š      }\n++â”Š  â”Š24â”Š    ]);\n++â”Š  â”Š25â”Š\n++â”Š  â”Š26â”Š    // Play it repeatedly, back and forth\n++â”Š  â”Š27â”Š    this.instructionsAnim.repMode = \"full\";\n++â”Š  â”Š28â”Š    this.instructionsAnim.play();\n++â”Š  â”Š29â”Š  }\n++â”Š  â”Š30â”Š\n++â”Š  â”Š31â”Š  unload() {\n++â”Š  â”Š32â”Š    // Dispose the following assets to prevent memory leaks\n++â”Š  â”Š33â”Š    return [\"logoTexture\", \"instructionsTexture\"];\n++â”Š  â”Š34â”Š  }\n++â”Š  â”Š35â”Š\n++â”Š  â”Š36â”Š  draw(context) {\n++â”Š  â”Š37â”Š    this.logoSprite.draw(context);\n++â”Š  â”Š38â”Š    this.instructionsAnim.draw(context);\n++â”Š  â”Š39â”Š  }\n++â”Š  â”Š40â”Š\n++â”Š  â”Š41â”Š  update(span) {\n++â”Š  â”Š42â”Š    this.instructionsAnim.update(span);\n++â”Š  â”Š43â”Š  }\n++â”Š  â”Š44â”Š};ðŸš«â†µ\n+```\n+\n+##### Changed views/game.html\n+```diff\n+@@ -16,6 +16,7 @@\n+ â”Š16â”Š16â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/screen.js\"></script>\n+ â”Š17â”Š17â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/assets_loader.js\"></script>\n+ â”Š18â”Š18â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n++â”Š  â”Š19â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/menu/index.js\"></script>\n+ â”Š19â”Š20â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/splash/index.js\"></script>\n+ â”Š20â”Š21â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n+```\n+[}]: #\n+\n+This screen is dependent on several assets which we will load during \"splash screen time\", to save some loading time and for a smooth experience. The main menu screen will be shown automatically once the splash animation has been finished:\n+\n+[{]: <helper> (diff_step 4.3)\n+#### Step 4.3: Queue main menu screen\n+\n+##### Changed resources/scripts/game/screens/splash/index.js\n+```diff\n+@@ -32,10 +32,21 @@\n+ â”Š32â”Š32â”Š  }\n+ â”Š33â”Š33â”Š\n+ â”Š34â”Š34â”Š  load(assetsLoader) {\n++â”Š  â”Š35â”Š    // Load assets\n++â”Š  â”Š36â”Š    let instructionsTexture = assetsLoader.texture(\"/textures/instrucitons\");\n++â”Š  â”Š37â”Š    let logoTexture = assetsLoader.texture(\"/textures/logo\");\n++â”Š  â”Š38â”Š    let splashTexture = assetsLoader.texture(\"/textures/splash\");\n++â”Š  â”Š39â”Š\n++â”Š  â”Š40â”Š    // These are global assets which will be shared among all screens until manually\n++â”Š  â”Š41â”Š    // disposed. We use the time gap created by the splash animation to load necessary\n++â”Š  â”Š42â”Š    // assets without wasting any time\n++â”Š  â”Š43â”Š    this.game.extendAssets({\n++â”Š  â”Š44â”Š      instructionsTexture,\n++â”Š  â”Š45â”Š      logoTexture\n++â”Š  â”Š46â”Š    });\n++â”Š  â”Š47â”Š\n+ â”Š35â”Š48â”Š    // These are local assets which will be disposed along with the screen\n+-â”Š36â”Š  â”Š    return {\n+-â”Š37â”Š  â”Š      splashTexture: assetsLoader.texture(\"/textures/splash\")\n+-â”Š38â”Š  â”Š    };\n++â”Š  â”Š49â”Š    return { splashTexture };\n+ â”Š39â”Š50â”Š  }\n+ â”Š40â”Š51â”Š\n+ â”Š41â”Š52â”Š  draw(context) {\n+```\n+```diff\n+@@ -43,6 +54,12 @@\n+ â”Š43â”Š54â”Š  }\n+ â”Š44â”Š55â”Š\n+ â”Š45â”Š56â”Š  update(span) {\n+-â”Š46â”Š  â”Š    this.splashAnim.update(span);\n++â”Š  â”Š57â”Š    if (this.splashAnim.playing) {\n++â”Š  â”Š58â”Š      this.splashAnim.update(span);\n++â”Š  â”Š59â”Š    }\n++â”Š  â”Š60â”Š    // Once animation has stopped play switch to main menu\n++â”Š  â”Š61â”Š    else {\n++â”Š  â”Š62â”Š      this.game.changeScreen(Game.Screens.Menu);\n++â”Š  â”Š63â”Š    }\n+ â”Š47â”Š64â”Š  }\n+ â”Š48â”Š65â”Š};ðŸš«â†µ\n+```\n+[}]: #\n+\n+By now if you launch the application you should see the main menu screen as described in the beginning. But event though it works, we're not yet finished. We still need to convert the instruction texture into an auto-generated font texture. Obviously, this requires us to download the desired `ttf` file:\n+\n+    resources/assets/fonts$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/assets/fonts/minecraftia.ttf\n+\n+> Any font file can be used here, but to save time and effort I already provided you with one\n+\n+`ttf` is the most common format, but since we're using JavaScript, it would make sense to convert it into a `json` file, and that's exactly what we're going to do. There's a very convenient software called [font-builder](https://github.com/andryblack/fontbuilder), and it can cut fonts, store them in `png` files, along with some user-specified meta-data stored in an `xml` file.\n+\n+![font-builder](https://camo.githubusercontent.com/b2c95cda825c783f5399d9197599848c33cdfcc8/687474703a2f2f7777772e67616d656465762e72752f66696c65732f696d616765732f73637265656e312e6a706567)\n+\n+Go over to this website: https://github.com/andryblack/fontbuilder.\n+Fetch a copy of the `font-builder` repo, and try to convert the `minecraftia.ttf` file into a `png` file. If you want to skip this step, although I wouldn't recommend it, you can download the following files which I already generated myself:\n+\n+    resources/assets/fonts$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/assets/fonts/minecraftia.png\n+    resources/assets/fonts$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/assets/fonts/minecraftia.xml\n+\n+As promised, we will be working with a `json` file, not a `ttf` file and not an `xml` file. For this task we will be implementing a font-parser module, which will simply take all the meta-data in the `xml` file and put it into a nice `json` schema:\n+\n+[{]: <helper> (diff_step 4.6)\n+#### Step 4.6: Create font parser so we can convert 'xml' font format to 'json'\n+\n+##### Added helpers/font_parser.js\n+```diff\n+@@ -0,0 +1,102 @@\n++â”Š   â”Š  1â”Šconst _ = require(\"underscore\");\n++â”Š   â”Š  2â”Šconst Async = require(\"async\");\n++â”Š   â”Š  3â”Šconst Fs = require(\"fs\");\n++â”Š   â”Š  4â”Šconst Path = require(\"path\");\n++â”Š   â”Š  5â”Šconst { DOMParser } = require(\"xmldom\");\n++â”Š   â”Š  6â”Š\n++â”Š   â”Š  7â”Šif (module === require.main) {\n++â”Š   â”Š  8â”Š  let fonstDir = Path.resolve(__dirname, \"../resources/assets/fonts\");\n++â”Š   â”Š  9â”Š  xmlsToJsons(fonstDir, err => { if (err) throw err });\n++â”Š   â”Š 10â”Š}\n++â”Š   â”Š 11â”Š\n++â”Š   â”Š 12â”Š// Gets a dir path containing font xmls and converts them all to jsons\n++â”Š   â”Š 13â”Šfunction xmlsToJsons(path, callback = _.noop) {\n++â”Š   â”Š 14â”Š  Fs.readdir(path, (err, files) => {\n++â”Š   â”Š 15â”Š    if (err) return callback(err);\n++â”Š   â”Š 16â”Š\n++â”Š   â”Š 17â”Š    // Remove all extensions\n++â”Š   â”Š 18â”Š    fileNames = _.uniq(files.map(file => file.split(\".\")[0]));\n++â”Š   â”Š 19â”Š\n++â”Š   â”Š 20â”Š    // Convert each xml individually\n++â”Š   â”Š 21â”Š    Async.each(fileNames, (fileName, next) => {\n++â”Š   â”Š 22â”Š      xmlToJson(`${path}/${fileName}`, next);\n++â”Š   â”Š 23â”Š    },\n++â”Š   â”Š 24â”Š    (err) => {\n++â”Š   â”Š 25â”Š      if (!err) console.log(\n++â”Š   â”Š 26â”Š        'All fonts have been successfully parsed!'\n++â”Š   â”Š 27â”Š      );\n++â”Š   â”Š 28â”Š\n++â”Š   â”Š 29â”Š      callback(err);\n++â”Š   â”Š 30â”Š    });\n++â”Š   â”Š 31â”Š  });\n++â”Š   â”Š 32â”Š}\n++â”Š   â”Š 33â”Š\n++â”Š   â”Š 34â”Š// Gets a font xml and converts it to json\n++â”Š   â”Š 35â”Šfunction xmlToJson(path, callback = _.noop) {\n++â”Š   â”Š 36â”Š  Async.waterfall([\n++â”Š   â”Š 37â”Š    (next) => {\n++â”Š   â”Š 38â”Š      Fs.readFile(`${path}.xml`, function(err, xmlBuffer) {\n++â”Š   â”Š 39â”Š        if (err) return next(err);\n++â”Š   â”Š 40â”Š\n++â”Š   â”Š 41â”Š        let json = {\n++â”Š   â”Š 42â”Š          chars: {}\n++â”Š   â”Š 43â”Š        };\n++â”Š   â”Š 44â”Š\n++â”Š   â”Š 45â”Š        let xml = xmlBuffer.toString();\n++â”Š   â”Š 46â”Š        let doc = new DOMParser().parseFromString(xml);\n++â”Š   â”Š 47â”Š        let fontDoc = doc.getElementsByTagName(\"Font\")[0];\n++â”Š   â”Š 48â”Š        let charsDoc = fontDoc.getElementsByTagName(\"Char\");\n++â”Š   â”Š 49â”Š\n++â”Š   â”Š 50â”Š        // Compose meta-data about font like size and family\n++â”Š   â”Š 51â”Š        _.each(fontDoc.attributes, (attr) => {\n++â”Š   â”Š 52â”Š          json[attr.name] = parseInt(attr.value) || attr.value;\n++â”Š   â”Š 53â”Š        });\n++â”Š   â”Š 54â”Š\n++â”Š   â”Š 55â”Š        // Compose data about each character in font\n++â”Š   â”Š 56â”Š        _.each(charsDoc, (charDoc) => {\n++â”Š   â”Š 57â”Š          let charCode = charDoc.getAttribute(\"code\");\n++â”Š   â”Š 58â”Š\n++â”Š   â”Š 59â”Š          let char = json.chars[charCode] = {\n++â”Š   â”Š 60â”Š            rect: rect = {},\n++â”Š   â”Š 61â”Š            offset: offset = {},\n++â”Š   â”Š 62â”Š            width: parseInt(charDoc.getAttribute(\"width\"))\n++â”Š   â”Š 63â”Š          };\n++â”Š   â”Š 64â”Š\n++â”Š   â”Š 65â”Š          [\n++â”Š   â”Š 66â”Š            rect.x,\n++â”Š   â”Š 67â”Š            rect.y,\n++â”Š   â”Š 68â”Š            rect.width,\n++â”Š   â”Š 69â”Š            rect.height\n++â”Š   â”Š 70â”Š          ] = extractIntegers(charDoc.getAttribute(\"rect\"));\n++â”Š   â”Š 71â”Š\n++â”Š   â”Š 72â”Š          [offset.x, offset.y] = extractIntegers(charDoc.getAttribute(\"offset\"));\n++â”Š   â”Š 73â”Š        });\n++â”Š   â”Š 74â”Š\n++â”Š   â”Š 75â”Š        next(null, JSON.stringify(json, null, 2));\n++â”Š   â”Š 76â”Š      });\n++â”Š   â”Š 77â”Š    },\n++â”Š   â”Š 78â”Š    (json, next) => {\n++â”Š   â”Š 79â”Š      // Once finished, write json into file\n++â”Š   â”Š 80â”Š      Fs.writeFile(path + \".json\", json, (err) => {\n++â”Š   â”Š 81â”Š        next(err);\n++â”Š   â”Š 82â”Š      });\n++â”Š   â”Š 83â”Š    }\n++â”Š   â”Š 84â”Š  ], (err) => {\n++â”Š   â”Š 85â”Š    if (!err) console.log(\n++â”Š   â”Š 86â”Š      `Font ${path} has been successfully parsed...`\n++â”Š   â”Š 87â”Š    );\n++â”Š   â”Š 88â”Š\n++â”Š   â”Š 89â”Š    callback(err);\n++â”Š   â”Š 90â”Š  });\n++â”Š   â”Š 91â”Š};\n++â”Š   â”Š 92â”Š\n++â”Š   â”Š 93â”Š// Converts an string of numbers to array of numbers\n++â”Š   â”Š 94â”Š// e.g. extractIntegers(\"1 2 3\") -> [1, 2, 3]\n++â”Š   â”Š 95â”Šfunction extractIntegers(srcstr) {\n++â”Š   â”Š 96â”Š  return srcstr.split(\" \").map((substr) => parseInt(substr));\n++â”Š   â”Š 97â”Š}\n++â”Š   â”Š 98â”Š\n++â”Š   â”Š 99â”Šmodule.exports = {\n++â”Š   â”Š100â”Š  xmlToJson,\n++â”Š   â”Š101â”Š  xmlsToJsons\n++â”Š   â”Š102â”Š};ðŸš«â†µ\n+```\n+[}]: #\n+\n+This script will take everything that's in the `fonts` dir and parser it as mentioned above. Before we can user this script we will need to install some NPM dependencies like so:\n+\n+    $ npm install --save underscore\n+    $ npm install --save xmldom\n+\n+And instead of running the parser manually over and over again whenever we wanna use it, we will add an NPM script called `parse:fonts`:\n+\n+[{]: <helper> (diff_step 4.8)\n+#### Step 4.8: Add font parsing npm scripts\n+\n+##### Changed package.json\n+```diff\n+@@ -3,7 +3,8 @@\n+ â”Š 3â”Š 3â”Š  \"description\": \"A tutorial for creating a Tron-style game\",\n+ â”Š 4â”Š 4â”Š  \"private\": true,\n+ â”Š 5â”Š 5â”Š  \"scripts\": {\n+-â”Š 6â”Š  â”Š    \"serve\": \"nodemon server.js\"\n++â”Š  â”Š 6â”Š    \"serve\": \"npm run parse:fonts && nodemon server.js\",\n++â”Š  â”Š 7â”Š    \"parse:fonts\": \"node helpers/font_parser.js\"\n+ â”Š 7â”Š 8â”Š  },\n+ â”Š 8â”Š 9â”Š  \"dependencies\": {\n+ â”Š 9â”Š10â”Š    \"async\": \"^2.1.4\",\n+```\n+[}]: #\n+\n+Now we will build our `minecraftia` font by simply running:\n+\n+    $ npm run parse:fonts\n+\n+And voila! We have a freshly created `json` file which we can work with. You can also get it from here:\n+\n+    resources/assets/fonts$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/assets/fonts/minecraftia.json\n+\n+Now that we have our assets finally ready we can go ahead and focus on extending the engine which powers up our game. We need some sort of a generic font-engine which will know how to load a font file and create a text-sprite out of it. First we will implement a class called `Restorable`, which shares the same restore API as the CanvasRenderingContext2D and will give us the ability to save and restore the font's state (More information can be found [here](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/restore)):\n+\n+[{]: <helper> (diff_step 4.10)\n+#### Step 4.10: Add 'Restorable' class\n+\n+##### Added resources/scripts/engine/restorable.js\n+```diff\n+@@ -0,0 +1,21 @@\n++â”Š  â”Š 1â”ŠEngine.Restorable = class Restorable {\n++â”Š  â”Š 2â”Š  // Acts the same as canvas's save() and restore() API.\n++â”Š  â”Š 3â”Š  // 'restorable' props are defined in the constructor\n++â”Š  â”Š 4â”Š  constructor(...restorableProps) {\n++â”Š  â”Š 5â”Š    this._restorableProps = restorableProps;\n++â”Š  â”Š 6â”Š    this._restorableStates = [];\n++â”Š  â”Š 7â”Š  }\n++â”Š  â”Š 8â”Š\n++â”Š  â”Š 9â”Š  // Save current state in the stack\n++â”Š  â”Š10â”Š  save() {\n++â”Š  â”Š11â”Š    this._restorableStates.push(this._restorableProps.reduce((state, prop) => {\n++â”Š  â”Š12â”Š      state[prop] = this[prop];\n++â”Š  â”Š13â”Š      return state;\n++â”Š  â”Š14â”Š    }, {}));\n++â”Š  â”Š15â”Š  }\n++â”Š  â”Š16â”Š\n++â”Š  â”Š17â”Š  // Pop most recent state and apply it\n++â”Š  â”Š18â”Š  restore() {\n++â”Š  â”Š19â”Š    _.extend(this, this._restorableStates.pop());\n++â”Š  â”Š20â”Š  }\n++â”Š  â”Š21â”Š};ðŸš«â†µ\n+```\n+\n+##### Changed views/game.html\n+```diff\n+@@ -9,6 +9,7 @@\n+ â”Š 9â”Š 9â”Š\n+ â”Š10â”Š10â”Š    <!-- Scripts -->\n+ â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n++â”Š  â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/restorable.js\"></script>\n+ â”Š12â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/sprite.js\"></script>\n+ â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/animations/keyframe.js\"></script>\n+ â”Š14â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/key_states.js\"></script>\n+```\n+[}]: #\n+\n+And now we can go ahead and implement the font class itself:\n+\n+[{]: <helper> (diff_step 4.11)\n+#### Step 4.11: Create font engine\n+\n+##### Added resources/scripts/engine/font.js\n+```diff\n+@@ -0,0 +1,133 @@\n++â”Š   â”Š  1â”ŠEngine.Font = class Font extends Engine.Restorable {\n++â”Š   â”Š  2â”Š  // The src property acts just line native image's src property.\n++â”Š   â”Š  3â”Š  // Once finished loading, the onload() callback will be invoked\n++â”Š   â”Š  4â”Š  get src() {\n++â”Š   â”Š  5â”Š    return this._src;\n++â”Š   â”Š  6â”Š  }\n++â”Š   â”Š  7â”Š\n++â”Š   â”Š  8â”Š  set src(src) {\n++â”Š   â”Š  9â”Š    this._src = src;\n++â”Š   â”Š 10â”Š\n++â”Š   â”Š 11â”Š    // The font is actually an image, therefore we have 2 onload callbacks.\n++â”Š   â”Š 12â”Š    // The first one is the native one which will always be run,\n++â”Š   â”Š 13â”Š    // and the second one is a user defined one\n++â”Š   â”Š 14â”Š    if (this.onload) var done = _.after(2, this.onload);\n++â”Š   â”Š 15â”Š\n++â”Š   â”Š 16â”Š    this.atlas = new Image();\n++â”Š   â”Š 17â”Š    this.atlas.onload = done;\n++â”Š   â”Š 18â”Š    this.atlas.src = `${src}.png`;\n++â”Š   â”Š 19â”Š\n++â”Š   â”Š 20â”Š    // Get json based on the given src property\n++â”Š   â”Š 21â”Š    $.getJSON(`${src}.json`, data => {\n++â”Š   â”Š 22â”Š      this.data = data;\n++â”Š   â”Š 23â”Š      if (done) done();\n++â”Š   â”Š 24â”Š    });\n++â”Š   â”Š 25â”Š\n++â”Š   â”Š 26â”Š    return this._src;\n++â”Š   â”Š 27â”Š  }\n++â”Š   â”Š 28â”Š\n++â”Š   â”Š 29â”Š  constructor() {\n++â”Š   â”Š 30â”Š    // The color property is the only restorable property\n++â”Š   â”Š 31â”Š    super(\"color\");\n++â”Š   â”Š 32â”Š    this.charSpritesCache = {};\n++â”Š   â”Š 33â”Š  }\n++â”Š   â”Š 34â”Š\n++â”Š   â”Š 35â”Š  // Creates a texture out of the font with the given text\n++â”Š   â”Š 36â”Š  createTexture(text, options = {}) {\n++â”Š   â”Š 37â”Š    let { noOffsets, noSpaces } = options;\n++â”Š   â”Š 38â”Š    let canvas = document.createElement(\"canvas\");\n++â”Š   â”Š 39â”Š    let context = canvas.getContext(\"2d\");\n++â”Š   â”Š 40â”Š    let height = canvas.height = this.data.height;\n++â”Š   â”Š 41â”Š\n++â”Š   â”Š 42â”Š    // Calculates the width of the canvas based on the text and the font\n++â”Š   â”Š 43â”Š    let width = canvas.width = _.reduce(text, (width, c) => {\n++â”Š   â”Š 44â”Š      // No-space option means that the characters will be\n++â”Š   â”Š 45â”Š      // drawn with no any space between them\n++â”Š   â”Š 46â”Š      if (noSpaces) {\n++â”Š   â”Š 47â”Š        return width + this.getCharSprite(c).width;\n++â”Š   â”Š 48â”Š      }\n++â”Š   â”Š 49â”Š\n++â”Š   â”Š 50â”Š      return width + this.data.chars[c].width;\n++â”Š   â”Š 51â”Š    }, 0);\n++â”Š   â”Š 52â”Š\n++â”Š   â”Š 53â”Š    // A custom size can be specified for a font as well\n++â”Š   â”Š 54â”Š    if (this.size) {\n++â”Š   â”Š 55â”Š      let ratio = this.size / this.data.size;\n++â”Š   â”Š 56â”Š      canvas.height *= ratio;\n++â”Š   â”Š 57â”Š      canvas.width *= ratio;\n++â”Š   â”Š 58â”Š      context.scale(ratio, ratio);\n++â”Š   â”Š 59â”Š    }\n++â”Š   â”Š 60â”Š\n++â”Š   â”Š 61â”Š    // No we are going to draw each char on the canvas individually,\n++â”Š   â”Š 62â”Š    // naturally, there should be an offset after we draw each character.\n++â”Š   â”Š 63â”Š    // This variable will be used to calculate the offset\n++â”Š   â”Š 64â”Š    let offset = 0;\n++â”Š   â”Š 65â”Š\n++â”Š   â”Š 66â”Š    // Get for each char\n++â”Š   â”Š 67â”Š    _.map(text, (char) => {\n++â”Š   â”Š 68â”Š      return this.getCharSprite(char);\n++â”Š   â”Š 69â”Š    })\n++â”Š   â”Š 70â”Š    // Start drawing each char on the canvas\n++â”Š   â”Š 71â”Š    .forEach((charSprite, index) => {\n++â”Š   â”Š 72â”Š      let charData = this.data.chars[text.charAt(index)];\n++â”Š   â”Š 73â”Š\n++â”Š   â”Š 74â”Š      // Each char in the font xml has a native offset in addition to its rectangle.\n++â”Š   â”Š 75â”Š      // This option will disable the calculation of the native offset\n++â”Š   â”Š 76â”Š      if (noOffsets) {\n++â”Š   â”Š 77â”Š        charSprite.draw(context, offset);\n++â”Š   â”Š 78â”Š      }\n++â”Š   â”Š 79â”Š      else {\n++â”Š   â”Š 80â”Š        charSprite.draw(context, offset + charData.offset.x, charData.offset.y);\n++â”Š   â”Š 81â”Š      }\n++â”Š   â”Š 82â”Š\n++â”Š   â”Š 83â”Š      if (noSpaces) {\n++â”Š   â”Š 84â”Š        offset += charSprite.width;\n++â”Š   â”Š 85â”Š      }\n++â”Š   â”Š 86â”Š      else {\n++â”Š   â”Š 87â”Š        offset += charData.width;\n++â”Š   â”Š 88â”Š      }\n++â”Š   â”Š 89â”Š\n++â”Š   â”Š 90â”Š      // A color for the font can be specified as well\n++â”Š   â”Š 91â”Š      if (this.color) {\n++â”Š   â”Š 92â”Š        let overlayCanvas = document.createElement(\"canvas\");\n++â”Š   â”Š 93â”Š        let overlayContext = overlayCanvas.getContext(\"2d\");\n++â”Š   â”Š 94â”Š        overlayCanvas.width = width;\n++â”Š   â”Š 95â”Š        overlayCanvas.height = height;\n++â”Š   â”Š 96â”Š        overlayContext.beginPath();\n++â”Š   â”Š 97â”Š        overlayContext.rect(0, 0, width, height);\n++â”Š   â”Š 98â”Š        overlayContext.fillStyle = this.color;\n++â”Š   â”Š 99â”Š        overlayContext.fill();\n++â”Š   â”Š100â”Š\n++â”Š   â”Š101â”Š        context.save();\n++â”Š   â”Š102â”Š        context.globalCompositeOperation = \"source-in\";\n++â”Š   â”Š103â”Š        context.drawImage(overlayCanvas, 0, 0);\n++â”Š   â”Š104â”Š        context.restore();\n++â”Š   â”Š105â”Š      }\n++â”Š   â”Š106â”Š    });\n++â”Š   â”Š107â”Š\n++â”Š   â”Š108â”Š    // The canvas will be treated like an image\n++â”Š   â”Š109â”Š    return canvas;\n++â”Š   â”Š110â”Š  }\n++â”Š   â”Š111â”Š\n++â”Š   â”Š112â”Š  // Gets a sprite of the given char, using the current font\n++â”Š   â”Š113â”Š  getCharSprite(char) {\n++â”Š   â”Š114â”Š    // If char is already stored in cache, abort calculation and return it\n++â”Š   â”Š115â”Š    if (this.charSpritesCache[char]) return this.charSpritesCache[char];\n++â”Š   â”Š116â”Š\n++â”Š   â”Š117â”Š    // This data is fetched by the given json\n++â”Š   â”Š118â”Š    let { x, y, width, height } = this.data.chars[char].rect;\n++â”Š   â”Š119â”Š    // Creating a canvas which we will use to draw on,\n++â”Š   â”Š120â”Š    // but it is used exactly like an image afterwards\n++â”Š   â”Š121â”Š    let canvas = document.createElement(\"canvas\");\n++â”Š   â”Š122â”Š    let context = canvas.getContext(\"2d\");\n++â”Š   â”Š123â”Š\n++â”Š   â”Š124â”Š    // The canvas will have the same dimensions as the font\n++â”Š   â”Š125â”Š    canvas.width = width;\n++â”Š   â”Š126â”Š    canvas.height = height;\n++â”Š   â”Š127â”Š    // Draw a cropped image from the atlas, this image contains the char font\n++â”Š   â”Š128â”Š    context.drawImage(this.atlas, x, y, width, height, 0, 0, width, height);\n++â”Š   â”Š129â”Š\n++â”Š   â”Š130â”Š    // Store in cache and return it\n++â”Š   â”Š131â”Š    return this.charSpritesCache[char] = new Engine.Sprite(canvas);\n++â”Š   â”Š132â”Š  }\n++â”Š   â”Š133â”Š};ðŸš«â†µ\n+```\n+\n+##### Changed views/game.html\n+```diff\n+@@ -10,6 +10,7 @@\n+ â”Š10â”Š10â”Š    <!-- Scripts -->\n+ â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n+ â”Š12â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/restorable.js\"></script>\n++â”Š  â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/font.js\"></script>\n+ â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/sprite.js\"></script>\n+ â”Š14â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/animations/keyframe.js\"></script>\n+ â”Š15â”Š16â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/key_states.js\"></script>\n+```\n+[}]: #\n+\n+The font API shares a similar API as [HTMLImageElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/Image), once we set the `src` property the font will start loading itself, and the `onload` user-defined callback should be called once finished. Another neat feature would be the `createTexture` method, which takes a string as its first argument, representing the text that we would like to generate, and returns an instance of the `Sprite` class.\n+\n+We will also be adding the option to load some font assets in our asset-loader:\n+\n+[{]: <helper> (diff_step 4.12)\n+#### Step 4.12: Add a font loading option to 'AssetLoader'\n+\n+##### Changed resources/scripts/engine/assets_loader.js\n+```diff\n+@@ -10,4 +10,12 @@\n+ â”Š10â”Š10â”Š    image.src = `${path}.png`;\n+ â”Š11â”Š11â”Š    return image;\n+ â”Š12â”Š12â”Š  }\n++â”Š  â”Š13â”Š\n++â”Š  â”Š14â”Š  // Load font\n++â”Š  â”Š15â”Š  font(path) {\n++â”Š  â”Š16â”Š    let font = new Engine.Font();\n++â”Š  â”Š17â”Š    font.onload = this.next();\n++â”Š  â”Š18â”Š    font.src = path;\n++â”Š  â”Š19â”Š    return font;\n++â”Š  â”Š20â”Š  }\n+ â”Š13â”Š21â”Š};ðŸš«â†µ\n+```\n+[}]: #\n+\n+And replace the instructions texture loading with a `minecraftia` font loading in the initial splash screen:\n+\n+[{]: <helper> (diff_step 4.13)\n+#### Step 4.13: Load 'minecraftia' font in splash screen\n+\n+##### Changed resources/scripts/game/screens/splash/index.js\n+```diff\n+@@ -33,7 +33,7 @@\n+ â”Š33â”Š33â”Š\n+ â”Š34â”Š34â”Š  load(assetsLoader) {\n+ â”Š35â”Š35â”Š    // Load assets\n+-â”Š36â”Š  â”Š    let instructionsTexture = assetsLoader.texture(\"/textures/instrucitons\");\n++â”Š  â”Š36â”Š    let minecraftiaFont = assetsLoader.font(\"/fonts/minecraftia\");\n+ â”Š37â”Š37â”Š    let logoTexture = assetsLoader.texture(\"/textures/logo\");\n+ â”Š38â”Š38â”Š    let splashTexture = assetsLoader.texture(\"/textures/splash\");\n+ â”Š39â”Š39â”Š\n+```\n+```diff\n+@@ -41,7 +41,7 @@\n+ â”Š41â”Š41â”Š    // disposed. We use the time gap created by the splash animation to load necessary\n+ â”Š42â”Š42â”Š    // assets without wasting any time\n+ â”Š43â”Š43â”Š    this.game.extendAssets({\n+-â”Š44â”Š  â”Š      instructionsTexture,\n++â”Š  â”Š44â”Š      minecraftiaFont,\n+ â”Š45â”Š45â”Š      logoTexture\n+ â”Š46â”Š46â”Š    });\n+```\n+[}]: #\n+\n+Now it can use us in the main menu screen where we will create a text-sprite saying `Press a key to start`, just like the instruction sprite we're about to replace:\n+\n+[{]: <helper> (diff_step 4.14)\n+#### Step 4.14: Replace texture usage with font usage in main menu screen\n+\n+##### Changed resources/scripts/game/screens/menu/index.js\n+```diff\n+@@ -5,7 +5,8 @@\n+ â”Š 5â”Š 5â”Š    this.logoSprite.setPercentage(\"width\", this.width, 30, \"height\");\n+ â”Š 6â”Š 6â”Š\n+ â”Š 7â”Š 7â”Š    // Initialize instructions sprite\n+-â”Š 8â”Š  â”Š    let instructionsSprite = new Engine.Sprite(this.assets.instructionsTexture);\n++â”Š  â”Š 8â”Š    let instructionsTexture = this.assets.minecraftiaFont.createTexture(\"Press a key to start\");\n++â”Š  â”Š 9â”Š    let instructionsSprite = new Engine.Sprite(instructionsTexture);\n+ â”Š 9â”Š10â”Š    instructionsSprite.align = \"center\";\n+ â”Š10â”Š11â”Š    instructionsSprite.setPercentage(\"width\", this.width, 35, \"height\");\n+ â”Š11â”Š12â”Š    instructionsSprite.x = this.width / 2;\n+```\n+```diff\n+@@ -30,7 +31,7 @@\n+ â”Š30â”Š31â”Š\n+ â”Š31â”Š32â”Š  unload() {\n+ â”Š32â”Š33â”Š    // Dispose the following assets to prevent memory leaks\n+-â”Š33â”Š  â”Š    return [\"logoTexture\", \"instructionsTexture\"];\n++â”Š  â”Š34â”Š    return \"logoTexture\";\n+ â”Š34â”Š35â”Š  }\n+ â”Š35â”Š36â”Š\n+ â”Š36â”Š37â”Š  draw(context) {\n+```\n+```diff\n+@@ -41,4 +42,8 @@\n+ â”Š41â”Š42â”Š  update(span) {\n+ â”Š42â”Š43â”Š    this.instructionsAnim.update(span);\n+ â”Š43â”Š44â”Š  }\n++â”Š  â”Š45â”Š\n++â”Š  â”Š46â”Š  update(span) {\n++â”Š  â”Š47â”Š    this.instructionsAnim.update(span);\n++â”Š  â”Š48â”Š  }\n+ â”Š44â”Š49â”Š};ðŸš«â†µ\n+```\n+[}]: #\n+\n+It shouldn't look any different from the beginning of the step where we manually drew the instruction texture, but in the next steps we will be using the font-engine a lot, and you will be thankful for what we've just did.\n+[}]: #\n+[{]: <region> (footer)\n+[{]: <helper> (nav_step)\n+| [< Previous Step](step3.md) | [Next Step >](step5.md) |\n+|:--------------------------------|--------------------------------:|\n+[}]: #\n+[}]: #\n\\ No newline at end of file\ndiff --git a/manuals/views/step5.md b/manuals/views/step5.md\nnew file mode 100644\nindex 0000000..a9f10e2\n--- /dev/null\n+++ b/manuals/views/step5.md\n@@ -0,0 +1,1301 @@\n+[{]: <region> (header)\n+# Step 5: Creating a snake and related geometry shapes\n+[}]: #\n+[{]: <region> (body)\n+![snake-illustrate](https://cloud.githubusercontent.com/assets/7648874/21074115/46ef4466-bed7-11e6-9d5d-12fa6d43147b.gif)\n+\n+In this step we will be creating all the necessary geometry shapes to form a snake; we're basically implementing the right infrastructure so in the next step we will be able to implement the game screen with ease. What exactly do I mean by \"geometry shapes\"? Well, our snake will be made out of circles, and lines. If we don't press any buttons at all, the snake should move forward at a straight line, and once we press on one of the arrow keys, the snake should move in a circular motion. Not only we want to draw the screen on the canvas, we also want to be able to detect collision with other snakes, since this is a \"Tron\" style game where we gonna fight against an opponent.\n+\n+Keep in mind that a computer's precision is limited due its [binary representation in memory](https://en.wikipedia.org/wiki/Memory_cell_(binary)). We need to take into consideration that there might be a significant deviation when detecting collisions and intersections between geometry shapes, especially when elapsed time is not always guaranteed to stay precise. To handle these deviation issues, we're gonna create some utility functions and place then as an extension for the `Number` prototype:\n+\n+[{]: <helper> (diff_step 5.1)\n+#### Step 5.1: Extend 'Number' prototype\n+\n+##### Added resources/scripts/extensions.js\n+```diff\n+@@ -0,0 +1,70 @@\n++â”Š  â”Š 1â”ŠObject.defineProperties(Number.prototype, {\n++â”Š  â”Š 2â”Š  // Fixed modulo method which can calculate modulo of negative numbers properly\n++â”Š  â”Š 3â”Š  // e.g., (-803).mod(800) returns 797\n++â”Š  â”Š 4â”Š  \"mod\": {\n++â”Š  â”Š 5â”Š    value(num) {\n++â”Š  â”Š 6â”Š      return ((this % num) + num) % num;\n++â”Š  â”Š 7â”Š    }\n++â”Š  â”Š 8â”Š  },\n++â”Š  â”Š 9â”Š\n++â”Š  â”Š10â”Š  // Trims number and leaves the number of decimals specified.\n++â”Š  â”Š11â”Š  // The \"mode\" argument specifies which math function should be invoked\n++â”Š  â”Š12â”Š  // right after the number has been trimmed.\n++â”Š  â”Š13â”Š  // e.g. 12.12345.trim(3, \"ceil\") returns 12.124\n++â”Š  â”Š14â”Š  \"trim\": {\n++â”Š  â”Š15â”Š    value(decimals, mode = \"round\") {\n++â”Š  â”Š16â”Š      return Math[mode](this * Math.pow(10, decimals)) / Math.pow(10, decimals);\n++â”Š  â”Š17â”Š    }\n++â”Š  â”Š18â”Š  },\n++â”Š  â”Š19â”Š\n++â”Š  â”Š20â”Š  // Tells if number is in specified range based on given precision.\n++â”Š  â”Š21â”Š  // See the \"compare\" method for more information about precision\n++â”Š  â”Š22â”Š  \"isBetween\": {\n++â”Š  â”Š23â”Š    value(num1, num2, precision) {\n++â”Š  â”Š24â”Š      return this.compare(Math.min(num1, num2), \">=\", precision) &&\n++â”Š  â”Š25â”Š      this.compare(Math.max(num1, num2), \"<=\", precision);\n++â”Š  â”Š26â”Š    }\n++â”Š  â”Š27â”Š  },\n++â”Š  â”Š28â”Š\n++â”Š  â”Š29â”Š  // Initiates comparison operator between this number and a given number, only here\n++â”Š  â”Š30â”Š  // a precision can be specified\n++â”Š  â”Š31â”Š  \"compare\": {\n++â”Š  â”Š32â”Š    value(num) {\n++â”Š  â”Š33â”Š      switch (arguments.length) {\n++â”Š  â”Š34â”Š        case 2:\n++â”Š  â”Š35â”Š          var precision = arguments[1];\n++â”Š  â”Š36â”Š          break;\n++â”Š  â”Š37â”Š        case 3:\n++â”Š  â”Š38â”Š          var method = arguments[1];\n++â”Š  â”Š39â”Š          precision = arguments[2];\n++â”Š  â”Š40â”Š          break;\n++â”Š  â”Š41â”Š      }\n++â”Š  â”Š42â”Š\n++â”Š  â”Š43â”Š      switch (precision) {\n++â”Š  â”Š44â”Š        // Fixed precision, \"almost equal\" with a deviation of Îµ\n++â”Š  â”Š45â”Š        case \"f\":\n++â”Š  â”Š46â”Š          switch (method) {\n++â”Š  â”Š47â”Š            case \"<\": case \"<=\": return this <= num + Number.EPSILON;\n++â”Š  â”Š48â”Š            case \">\": case \">=\": return this >= num - Number.EPSILON;\n++â”Š  â”Š49â”Š            default: return Math.abs(this - num) <= Number.EPSILON;\n++â”Š  â”Š50â”Š          }\n++â”Š  â”Š51â”Š        // Pixel precision, round comparison\n++â”Š  â”Š52â”Š        case \"px\":\n++â”Š  â”Š53â”Š          switch (method) {\n++â”Š  â”Š54â”Š            case \"<\": case \"<=\": return Math.round(this) <= Math.round(num);\n++â”Š  â”Š55â”Š            case \">\": case \">=\": return Math.round(this) >= Math.round(num);\n++â”Š  â”Š56â”Š            default: return Math.round(this) == Math.round(num);\n++â”Š  â”Š57â”Š          }\n++â”Š  â”Š58â”Š        // Exact precision\n++â”Š  â”Š59â”Š        default:\n++â”Š  â”Š60â”Š          switch (method) {\n++â”Š  â”Š61â”Š            case \"<\": return this < num;\n++â”Š  â”Š62â”Š            case \"<=\": return this <= num;\n++â”Š  â”Š63â”Š            case \">\": return this > num;\n++â”Š  â”Š64â”Š            case \">=\": return this >= num;\n++â”Š  â”Š65â”Š            default: return this === num;\n++â”Š  â”Š66â”Š          }\n++â”Š  â”Š67â”Š      }\n++â”Š  â”Š68â”Š    }\n++â”Š  â”Š69â”Š  }\n++â”Š  â”Š70â”Š});ðŸš«â†µ\n+```\n+\n+##### Changed views/game.html\n+```diff\n+@@ -8,6 +8,7 @@\n+ â”Š 8â”Š 8â”Š    <script type=\"text/javascript\" src=\"/libs/underscore.js\"></script>\n+ â”Š 9â”Š 9â”Š\n+ â”Š10â”Š10â”Š    <!-- Scripts -->\n++â”Š  â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/extensions.js\"></script>\n+ â”Š11â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n+ â”Š12â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/restorable.js\"></script>\n+ â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/font.js\"></script>\n+```\n+[}]: #\n+\n+Now we would like to start implementing the first class representation for a line, and for that we're requires to add a new module called `Geometry` to the `Engine` namespace:\n+\n+[{]: <helper> (diff_step 5.2)\n+#### Step 5.2: Add 'Shapes' module to 'Engine' namespace\n+\n+##### Changed resources/scripts/namespaces.js\n+```diff\n+@@ -3,5 +3,6 @@\n+ â”Š3â”Š3â”Š};\n+ â”Š4â”Š4â”Š\n+ â”Š5â”Š5â”ŠEngine = {\n+-â”Š6â”Š â”Š  Animations: {}\n++â”Š â”Š6â”Š  Animations: {},\n++â”Š â”Š7â”Š  Geometry: {}\n+ â”Š7â”Š8â”Š};ðŸš«â†µ\n+```\n+[}]: #\n+\n+And now that we have this module available to use, we can go ahead and implement our first geometry shape class - `Line`:\n+\n+[{]: <helper> (diff_step 5.3)\n+#### Step 5.3: Create 'Line' class\n+\n+##### Added resources/scripts/engine/geometry/line.js\n+```diff\n+@@ -0,0 +1,57 @@\n++â”Š  â”Š 1â”ŠEngine.Geometry.Line = class Line {\n++â”Š  â”Š 2â”Š  // x1 - The first point's x value\n++â”Š  â”Š 3â”Š  // y1 - The first point's y value\n++â”Š  â”Š 4â”Š  // x1 - The second point's x value\n++â”Š  â”Š 5â”Š  // y2 - The second point's y value\n++â”Š  â”Š 6â”Š  constructor(x1, y1, x2, y2) {\n++â”Š  â”Š 7â”Š    this.x1 = x1.trim(9);\n++â”Š  â”Š 8â”Š    this.y1 = y1.trim(9);\n++â”Š  â”Š 9â”Š    this.x2 = x2.trim(9);\n++â”Š  â”Š10â”Š    this.y2 = y2.trim(9);\n++â”Š  â”Š11â”Š  }\n++â”Š  â”Š12â”Š\n++â”Š  â”Š13â”Š  // Gets the matching x value for a given y value\n++â”Š  â”Š14â”Š  getX(y) {\n++â”Š  â”Š15â”Š    let x = ((((y - this.y1) * (this.x2 - this.x1)) / (this.y2 - this.y1)) + this.x1).trim(9);\n++â”Š  â”Š16â”Š    if (isNaN(x) || x.isBetween(this.x1, this.x2)) return x;\n++â”Š  â”Š17â”Š  }\n++â”Š  â”Š18â”Š\n++â”Š  â”Š19â”Š  // Gets the matching y value for a given x value\n++â”Š  â”Š20â”Š  getY(x) {\n++â”Š  â”Š21â”Š    let y = ((((x - this.x1) * (this.y2 - this.y1)) / (this.x2 - this.x1)) + this.y1).trim(9);\n++â”Š  â”Š22â”Š    if (isNaN(y) || y.isBetween(this.y1, this.y2)) return y;\n++â”Š  â”Š23â”Š  }\n++â”Š  â”Š24â”Š\n++â”Š  â”Š25â”Š  // Returns if line has given point\n++â”Š  â”Š26â”Š  hasPoint(x, y) {\n++â”Š  â”Š27â”Š    if (!this.boundsHavePoint(x, y)) return false;\n++â”Š  â”Š28â”Š    let m = ((this.y2 - this.y1) / (this.x2 - this.x1)).trim(9);\n++â”Š  â”Š29â”Š    return (y - this.y1) / (x - this.x1) == m;\n++â”Š  â”Š30â”Š  }\n++â”Š  â”Š31â”Š\n++â”Š  â”Š32â”Š  // Returns if given point is contained by the bounds aka cage of line\n++â”Š  â”Š33â”Š  boundsHavePoint(x, y) {\n++â”Š  â”Š34â”Š    return x.isBetween(this.x1, this.x2) &&\n++â”Š  â”Š35â”Š    y.isBetween(this.y1, this.y2);\n++â”Š  â”Š36â”Š  }\n++â”Š  â”Š37â”Š\n++â”Š  â”Š38â”Š  getIntersection(shape) {\n++â”Š  â”Š39â”Š    if (shape instanceof Engine.Geometry.Line)\n++â”Š  â”Š40â”Š      return this.getLineIntersection(shape);\n++â”Š  â”Š41â”Š  }\n++â”Š  â”Š42â”Š\n++â”Š  â”Š43â”Š  // line - line intersection method\n++â”Š  â”Š44â”Š  getLineIntersection(line) {\n++â”Š  â”Š45â”Š    if (!(((this.x1 - this.x2) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * (line.x1 - line.x2)))) return;\n++â”Š  â”Š46â”Š\n++â”Š  â”Š47â”Š    let x = (((((this.x1 * this.y2) - (this.y1 * this.x2)) * (line.x1 - line.x2)) - ((this.x1 - this.x2) * ((line.x1 * line.y2) - (line.y1 * line.x2)))) /\n++â”Š  â”Š48â”Š        (((this.x1 - this.x2) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * (line.x1 - line.x2)))).trim(9);\n++â”Š  â”Š49â”Š    let y = (((((this.x1 * this.y2) - (this.y1 * this.x2)) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * ((line.x1 * line.y2) - (line.y1 * line.x2)))) /\n++â”Š  â”Š50â”Š        (((this.x1 - this.x2) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * (line.x1 - line.x2)))).trim(9);\n++â”Š  â”Š51â”Š\n++â”Š  â”Š52â”Š    if (x.isBetween(this.x1, this.x2) && x.isBetween(line.x1, line.x2) &&\n++â”Š  â”Š53â”Š       y.isBetween(this.y1, this.y2) && y.isBetween(line.y1, line.y2)) {\n++â”Š  â”Š54â”Š      return { x, y };\n++â”Š  â”Š55â”Š    }\n++â”Š  â”Š56â”Š  }\n++â”Š  â”Š57â”Š};ðŸš«â†µ\n+```\n+\n+##### Changed views/game.html\n+```diff\n+@@ -10,6 +10,7 @@\n+ â”Š10â”Š10â”Š    <!-- Scripts -->\n+ â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/extensions.js\"></script>\n+ â”Š12â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n++â”Š  â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/geometry/line.js\"></script>\n+ â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/restorable.js\"></script>\n+ â”Š14â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/font.js\"></script>\n+ â”Š15â”Š16â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/sprite.js\"></script>\n+```\n+[}]: #\n+\n+You can go through the comments of the step above which will guide you through the programmatic aspect of it, but I think it's more important to understand the concept of a line in 2D space. A line is made out of two points, usually represented as `(x1, y1)` and `(x2, y2)`. The slope of the line, usually represented as `m`, can be determined using these two points based on the following formula:\n+\n+![slope](https://cloud.githubusercontent.com/assets/7648874/21788249/b4c7e41c-d6b4-11e6-9c17-baff66ec6bc8.png)\n+\n+Once we have two lines whose `m` is different (Unparalleled) and there is no intersection between the points of which they are represented with (In which case they are united), there must be an intersection point. The intersection point can be found using the following formula:\n+\n+![line-line](https://cloud.githubusercontent.com/assets/7648874/21787164/c9d83bf0-d6ae-11e6-9846-4fc013eebab3.png)\n+\n+![line-line-illustration](https://cloud.githubusercontent.com/assets/7648874/21790864/56725cf0-d6c6-11e6-916b-50b1fc0b87af.png)\n+\n+> See reference: http://mathworld.wolfram.com/Line-LineIntersection.html.\n+\n+Obviously we have some logic here which needs to be tested. To test our `Line` class, we will be using a testing framework called [Jasmine](https://jasmine.github.io/). We first need to download `Jasmine`'s essentials in order for it to work:\n+\n+    resources/libs$ mkdir jasmine\n+    resources/libs$ cd jasmine\n+    resources/libs/jasmine$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/libs/jasmine/boot.js\n+    resources/libs/jasmine$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/libs/jasmine/console.js\n+    resources/libs/jasmine$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/libs/jasmine/jasmine-html.js\n+    resources/libs/jasmine$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/libs/jasmine/jasmine.css\n+    resources/libs/jasmine$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/libs/jasmine/jasmine.js\n+    resources/libs/jasmine$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/libs/jasmine/jasmine_favicon.png\n+\n+These essentials should be loaded in a newly created view where we're gonna see our specs running:\n+\n+[{]: <helper> (diff_step 5.5)\n+#### Step 5.5: Create specs runner view\n+\n+##### Added views/spec_runner.html\n+```diff\n+@@ -0,0 +1,27 @@\n++â”Š  â”Š 1â”Š\n++â”Š  â”Š 2â”Š<!DOCTYPE html>\n++â”Š  â”Š 3â”Š<html>\n++â”Š  â”Š 4â”Š  <head>\n++â”Š  â”Š 5â”Š    <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n++â”Š  â”Š 6â”Š    <title>Jasmine Spec Runner v2.0.1</title>\n++â”Š  â”Š 7â”Š\n++â”Š  â”Š 8â”Š    <!-- Jasmine -->\n++â”Š  â”Š 9â”Š    <script type=\"text/javascript\" src=\"libs/jasmine/jasmine.js\"></script>\n++â”Š  â”Š10â”Š    <script type=\"text/javascript\" src=\"libs/jasmine/jasmine-html.js\"></script>\n++â”Š  â”Š11â”Š    <script type=\"text/javascript\" src=\"libs/jasmine/boot.js\"></script>\n++â”Š  â”Š12â”Š    <link rel=\"shortcut icon\" type=\"image/png\" href=\"libs/jasmine/jasmine_favicon.png\">\n++â”Š  â”Š13â”Š    <link rel=\"stylesheet\" type=\"text/css\" href=\"libs/jasmine/jasmine.css\">\n++â”Š  â”Š14â”Š\n++â”Š  â”Š15â”Š    <!-- Libs -->\n++â”Š  â”Š16â”Š    <script type=\"text/javascript\" src=\"libs/underscore.js\"></script>\n++â”Š  â”Š17â”Š\n++â”Š  â”Š18â”Š    <!-- Scripts -->\n++â”Š  â”Š19â”Š    <script type=\"text/javascript\" src=\"scripts/extensions.js\"></script>\n++â”Š  â”Š20â”Š    <script type=\"text/javascript\" src=\"scripts/namespaces.js\"></script>\n++â”Š  â”Š21â”Š\n++â”Š  â”Š22â”Š    <!-- Specs -->\n++â”Š  â”Š23â”Š  </head>\n++â”Š  â”Š24â”Š\n++â”Š  â”Š25â”Š  <body>\n++â”Š  â”Š26â”Š  </body>\n++â”Š  â”Š27â”Š</html>ðŸš«â†µ\n+```\n+[}]: #\n+\n+Now once we'll navigate to the `/test` sub-route (`localhost:8000/test` by default) we should be provided with the spec runner. As for now there are no specs implemented at all, which brings us to the next stage - Implementing tests for `Line` class:\n+\n+[{]: <helper> (diff_step 5.6)\n+#### Step 5.6: Create 'Line' class tests\n+\n+##### Added resources/scripts/specs/engine/geometry/line.js\n+```diff\n+@@ -0,0 +1,78 @@\n++â”Š  â”Š 1â”Šdescribe(\"Engine.Geometry.Line class\", function() {\n++â”Š  â”Š 2â”Š  beforeEach(function() {\n++â”Š  â”Š 3â”Š    this.line = new Engine.Geometry.Line(-5, -5, 5, 5);\n++â”Š  â”Š 4â”Š  });\n++â”Š  â”Š 5â”Š\n++â”Š  â”Š 6â”Š  describe(\"getX method\", function() {\n++â”Š  â”Š 7â”Š    describe(\"given inranged y\", function() {\n++â”Š  â”Š 8â”Š      it(\"returns x\", function() {\n++â”Š  â”Š 9â”Š        expect(this.line.getX(1)).toBeCloseTo(1);\n++â”Š  â”Š10â”Š      });\n++â”Š  â”Š11â”Š    });\n++â”Š  â”Š12â”Š\n++â”Š  â”Š13â”Š    describe(\"given outranged y\", function() {\n++â”Š  â”Š14â”Š      it(\"returns nothing\", function() {\n++â”Š  â”Š15â”Š        expect(this.line.getX(10)).toBeUndefined();\n++â”Š  â”Š16â”Š      });\n++â”Š  â”Š17â”Š    });\n++â”Š  â”Š18â”Š  });\n++â”Š  â”Š19â”Š\n++â”Š  â”Š20â”Š  describe(\"getY method\", function() {\n++â”Š  â”Š21â”Š    describe(\"given inranged x\", function() {\n++â”Š  â”Š22â”Š      it(\"returns y\", function() {\n++â”Š  â”Š23â”Š        expect(this.line.getY(1)).toBeCloseTo(1);\n++â”Š  â”Š24â”Š      });\n++â”Š  â”Š25â”Š    });\n++â”Š  â”Š26â”Š\n++â”Š  â”Š27â”Š    describe(\"given outranged x\", function() {\n++â”Š  â”Š28â”Š      it(\"returns nothing\", function() {\n++â”Š  â”Š29â”Š        expect(this.line.getY(10)).toBeUndefined();\n++â”Š  â”Š30â”Š      });\n++â”Š  â”Š31â”Š    });\n++â”Š  â”Š32â”Š  });\n++â”Š  â”Š33â”Š\n++â”Š  â”Š34â”Š  describe(\"hasPoint method\", function() {\n++â”Š  â”Š35â”Š    describe(\"given contained point\", function() {\n++â”Š  â”Š36â”Š      it(\"returns true\", function() {\n++â”Š  â”Š37â”Š        let x = 1;\n++â”Š  â”Š38â”Š        let y = 1;\n++â”Š  â”Š39â”Š        expect(this.line.hasPoint(x, y)).toBeTruthy();\n++â”Š  â”Š40â”Š      });\n++â”Š  â”Š41â”Š    });\n++â”Š  â”Š42â”Š\n++â”Š  â”Š43â”Š    describe(\"given uncontained point\", function() {\n++â”Š  â”Š44â”Š      it(\"returns false\", function() {\n++â”Š  â”Š45â”Š        let x = 10;\n++â”Š  â”Š46â”Š        let y = 10;\n++â”Š  â”Š47â”Š        expect(this.line.hasPoint(x, y)).toBeFalsy();\n++â”Š  â”Š48â”Š      });\n++â”Š  â”Š49â”Š    });\n++â”Š  â”Š50â”Š  });\n++â”Š  â”Š51â”Š\n++â”Š  â”Š52â”Š  describe(\"getLineIntersection method\", function() {\n++â”Š  â”Š53â”Š    describe(\"given intersecting line\", function() {\n++â”Š  â”Š54â”Š      it(\"returns intersection point\", function() {\n++â”Š  â”Š55â”Š        let line = new Engine.Geometry.Line(1, -5, 1, 5);\n++â”Š  â”Š56â”Š\n++â”Š  â”Š57â”Š        expect(this.line.getLineIntersection(line)).toEqual({\n++â”Š  â”Š58â”Š          x: 1,\n++â”Š  â”Š59â”Š          y: 1\n++â”Š  â”Š60â”Š        });\n++â”Š  â”Š61â”Š      });\n++â”Š  â”Š62â”Š    });\n++â”Š  â”Š63â”Š\n++â”Š  â”Š64â”Š    describe(\"given parallel line\", function() {\n++â”Š  â”Š65â”Š      it(\"returns nothing\", function() {\n++â”Š  â”Š66â”Š        let line = new Engine.Geometry.Line(-5, -6, 5, 4);\n++â”Š  â”Š67â”Š        expect(this.line.getLineIntersection(line)).toBeUndefined();\n++â”Š  â”Š68â”Š      });\n++â”Š  â”Š69â”Š    });\n++â”Š  â”Š70â”Š\n++â”Š  â”Š71â”Š    describe(\"given outranged line\", function() {\n++â”Š  â”Š72â”Š      it(\"returns nothing\", function() {\n++â”Š  â”Š73â”Š        let line = new Engine.Geometry.Line(10, 10, 10, 15);\n++â”Š  â”Š74â”Š        expect(this.line.getLineIntersection(line)).toBeUndefined();\n++â”Š  â”Š75â”Š      });\n++â”Š  â”Š76â”Š    });\n++â”Š  â”Š77â”Š  });\n++â”Š  â”Š78â”Š});ðŸš«â†µ\n+```\n+\n+##### Changed views/spec_runner.html\n+```diff\n+@@ -18,8 +18,10 @@\n+ â”Š18â”Š18â”Š    <!-- Scripts -->\n+ â”Š19â”Š19â”Š    <script type=\"text/javascript\" src=\"scripts/extensions.js\"></script>\n+ â”Š20â”Š20â”Š    <script type=\"text/javascript\" src=\"scripts/namespaces.js\"></script>\n++â”Š  â”Š21â”Š    <script type=\"text/javascript\" src=\"scripts/engine/geometry/line.js\"></script>\n+ â”Š21â”Š22â”Š\n+ â”Š22â”Š23â”Š    <!-- Specs -->\n++â”Š  â”Š24â”Š    <script type=\"text/javascript\" src=\"scripts/specs/engine/geometry/line.js\"></script>\n+ â”Š23â”Š25â”Š  </head>\n+ â”Š24â”Š26â”Š\n+ â”Š25â”Š27â”Š  <body>\n+```\n+[}]: #\n+\n+Now if you'll refresh the spec runner page you should be able to a green screen indicating all tests have passed (Assuming the tutorial is updated and you followed it correctly). As introduced at the beginning of the step, the snake is also dependent on circles, whose representing class should look like so:\n+\n+[{]: <helper> (diff_step 5.7)\n+#### Step 5.7: Create 'Circle' class\n+\n+##### Added resources/scripts/engine/geometry/circle.js\n+```diff\n+@@ -0,0 +1,161 @@\n++â”Š   â”Š  1â”ŠEngine.Geometry.Circle = class Circle {\n++â”Š   â”Š  2â”Š  // x - The x value of the circle's center\n++â”Š   â”Š  3â”Š  // y - The y value of the circle's center\n++â”Š   â”Š  4â”Š  // r - The radius of the center\n++â”Š   â”Š  5â”Š  // rad1 - The first radian of the circle, not necessarily its beginning\n++â”Š   â”Š  6â”Š  // rad2 - The second radian of the circle, not necessarily its beginning\n++â”Š   â”Š  7â”Š  constructor(x, y, r, rad1, rad2) {\n++â”Š   â”Š  8â”Š    this.x = x.trim(9);\n++â”Š   â”Š  9â”Š    this.y = y.trim(9);\n++â”Š   â”Š 10â”Š    this.r = r.trim(9);\n++â”Š   â”Š 11â”Š\n++â”Š   â”Š 12â”Š    // Trimming mode is done based on which radian represents the ending and which radian\n++â”Š   â”Š 13â”Š    // represents the ending\n++â”Š   â”Š 14â”Š    if (rad1 > rad2) {\n++â”Š   â”Š 15â”Š      this.rad1 = rad1.trim(9, \"floor\");\n++â”Š   â”Š 16â”Š      this.rad2 = rad2.trim(9, \"ceil\");\n++â”Š   â”Š 17â”Š    }\n++â”Š   â”Š 18â”Š    else {\n++â”Š   â”Š 19â”Š      this.rad1 = rad1.trim(9, \"ceil\");\n++â”Š   â”Š 20â”Š      this.rad2 = rad2.trim(9, \"floor\");\n++â”Š   â”Š 21â”Š    }\n++â”Š   â”Š 22â”Š  }\n++â”Š   â”Š 23â”Š\n++â”Š   â”Š 24â”Š  // Gets the matching x value for the given radian\n++â”Š   â”Š 25â”Š  getX(rad) {\n++â”Š   â”Š 26â”Š    if (!rad.trim(9).isBetween(this.rad1, this.rad2)) return;\n++â”Š   â”Š 27â”Š    return ((this.r * Math.cos(rad)) + this.x).trim(9);\n++â”Š   â”Š 28â”Š  }\n++â”Š   â”Š 29â”Š\n++â”Š   â”Š 30â”Š  // Gets the matching y value for the given radian\n++â”Š   â”Š 31â”Š  getY(rad) {\n++â”Š   â”Š 32â”Š    if (!rad.trim(9).isBetween(this.rad1, this.rad2)) return;\n++â”Š   â”Š 33â”Š    return ((this.r * Math.sin(rad)) + this.y).trim(9);\n++â”Š   â”Š 34â”Š  }\n++â”Š   â”Š 35â”Š\n++â”Š   â”Š 36â”Š  // Gets the matching point for the given radian\n++â”Š   â”Š 37â”Š  getPoint(rad) {\n++â”Š   â”Š 38â”Š    if (!rad.isBetween(this.rad1, this.rad2)) return;\n++â”Š   â”Š 39â”Š\n++â”Š   â”Š 40â”Š    return {\n++â”Š   â”Š 41â”Š      x: ((this.r * Math.cos(rad)) + this.x).trim(9),\n++â”Š   â”Š 42â”Š      y: ((this.r * Math.sin(rad)) + this.y).trim(9)\n++â”Š   â”Š 43â”Š    };\n++â”Š   â”Š 44â”Š  }\n++â”Š   â”Š 45â”Š\n++â”Š   â”Š 46â”Š  // Gets the matching radian for the given point\n++â”Š   â”Š 47â”Š  getRad(x, y) {\n++â”Š   â”Š 48â”Š    let rad = Math.atan2(y - this.y, x - this.x);\n++â”Š   â”Š 49â”Š\n++â”Š   â”Š 50â”Š    // If calculated radian is in circle's radian range, return it\n++â”Š   â”Š 51â”Š    if (rad != null && rad.isBetween(this.rad1, this.rad2)) {\n++â”Š   â”Š 52â”Š      return rad;\n++â”Š   â”Š 53â”Š    }\n++â”Š   â”Š 54â”Š\n++â”Š   â”Š 55â”Š    // The calculated radian can still be in the circle's radian range in case\n++â”Š   â”Š 56â”Š    // they completed several whole circles\n++â”Š   â”Š 57â”Š    if (Math.abs(this.rad1) > Math.abs(this.rad2)) {\n++â”Š   â”Š 58â”Š      var cycRad = this.rad1;\n++â”Š   â”Š 59â”Š    }\n++â”Š   â”Š 60â”Š    else {\n++â”Š   â”Š 61â”Š      var cycRad = this.rad2;\n++â”Š   â”Š 62â”Š    }\n++â”Š   â”Š 63â”Š\n++â”Š   â”Š 64â”Š    if ((rad + (2 * Math.PI * Math.floor(cycRad / (2 * Math.PI)))).trim(9).isBetween(this.rad1, this.rad2) ||\n++â”Š   â”Š 65â”Š       (rad + (2 * Math.PI * Math.ceil(cycRad / (2 * Math.PI)))).trim(9).isBetween(this.rad1, this.rad2)) {\n++â”Š   â”Š 66â”Š      return rad;\n++â”Š   â”Š 67â”Š    }\n++â”Š   â”Š 68â”Š  }\n++â”Š   â”Š 69â”Š\n++â”Š   â”Š 70â”Š  // Returns if circle has given points\n++â”Š   â”Š 71â”Š  hasPoint(x, y) {\n++â”Š   â”Š 72â”Š    return this.getRad(x, y) != null;\n++â”Š   â”Š 73â”Š  }\n++â”Š   â”Š 74â”Š\n++â”Š   â”Š 75â”Š  getIntersection(shape) {\n++â”Š   â”Š 76â”Š    if (shape instanceof Engine.Geometry.Line)\n++â”Š   â”Š 77â”Š      return this.getLineIntersection(shape);\n++â”Š   â”Š 78â”Š    if (shape instanceof Engine.Geometry.Circle)\n++â”Š   â”Š 79â”Š      return this.getCircleIntersection(shape);\n++â”Š   â”Š 80â”Š  }\n++â”Š   â”Š 81â”Š\n++â”Š   â”Š 82â”Š  // circle - circle intersection method\n++â”Š   â”Š 83â”Š  getCircleIntersection(circle) {\n++â”Š   â”Š 84â”Š    let dx = circle.x - this.x;\n++â”Š   â”Š 85â”Š    let dy = circle.y - this.y;\n++â”Š   â”Š 86â”Š    let d = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\n++â”Š   â”Š 87â”Š\n++â”Š   â”Š 88â”Š    if (d > this.r + circle.r ||\n++â”Š   â”Š 89â”Š       d < Math.abs(this.r - circle.r)) {\n++â”Š   â”Š 90â”Š      return;\n++â”Š   â”Š 91â”Š    }\n++â”Š   â”Š 92â”Š\n++â”Š   â”Š 93â”Š    let a = ((Math.pow(this.r, 2) - Math.pow(circle.r, 2)) + Math.pow(d, 2)) / (2 * d);\n++â”Š   â”Š 94â”Š    let x = this.x + ((dx * a) / d);\n++â”Š   â”Š 95â”Š    let y = this.y + ((dy * a) / d);\n++â”Š   â”Š 96â”Š    let h = Math.sqrt(Math.pow(this.r, 2) - Math.pow(a, 2));\n++â”Š   â”Š 97â”Š    let rx = (- dy * h) / d;\n++â”Š   â”Š 98â”Š    let ry = (dx * h) / d;\n++â”Š   â”Š 99â”Š\n++â”Š   â”Š100â”Š    let interPoints = [\n++â”Š   â”Š101â”Š      {\n++â”Š   â”Š102â”Š        x: x + rx,\n++â”Š   â”Š103â”Š        y: y + ry\n++â”Š   â”Š104â”Š      },\n++â”Š   â”Š105â”Š      {\n++â”Š   â”Š106â”Š        x: x - rx,\n++â”Š   â”Š107â”Š        y: y - ry\n++â”Š   â”Š108â”Š      }\n++â”Š   â”Š109â”Š    ]\n++â”Š   â”Š110â”Š    .map(point => ({\n++â”Š   â”Š111â”Š        x: point.x.trim(9),\n++â”Š   â”Š112â”Š        y: point.y.trim(9)\n++â”Š   â”Š113â”Š     }));\n++â”Š   â”Š114â”Š\n++â”Š   â”Š115â”Š    interPoints = _.uniq(interPoints, point => `(${point.x}, ${point.y})`);\n++â”Š   â”Š116â”Š\n++â”Š   â”Š117â”Š    [this, circle].forEach(function(circle) {\n++â”Š   â”Š118â”Š      interPoints = interPoints.filter(point => circle.hasPoint(point.x, point.y));\n++â”Š   â”Š119â”Š    });\n++â”Š   â”Š120â”Š\n++â”Š   â”Š121â”Š    if (interPoints.length > 0) return interPoints;\n++â”Š   â”Š122â”Š  }\n++â”Š   â”Š123â”Š\n++â”Š   â”Š124â”Š  // circle - line intersection method\n++â”Š   â”Š125â”Š  getLineIntersection(line) {\n++â”Š   â”Š126â”Š    let x1 = line.x1 - this.x;\n++â”Š   â”Š127â”Š    let x2 = line.x2 - this.x;\n++â”Š   â”Š128â”Š    let y1 = line.y1 - this.y;\n++â”Š   â”Š129â”Š    let y2 = line.y2 - this.y;\n++â”Š   â”Š130â”Š    let dx = x2 - x1;\n++â”Š   â”Š131â”Š    let dy = y2 - y1;\n++â”Š   â”Š132â”Š    let d = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\n++â”Š   â”Š133â”Š    let h = (x1 * y2) - (x2 * y1);\n++â”Š   â”Š134â”Š    let delta = (Math.pow(this.r, 2) * Math.pow(d, 2)) - Math.pow(h, 2);\n++â”Š   â”Š135â”Š\n++â”Š   â”Š136â”Š    if (delta < 0) return;\n++â”Š   â”Š137â”Š\n++â”Š   â”Š138â”Š    let interPoints = [\n++â”Š   â”Š139â”Š      {\n++â”Š   â”Š140â”Š        x: (((h * dy) + (((dy / Math.abs(dy)) || 1) * dx * Math.sqrt(delta))) / Math.pow(d, 2)) + this.x,\n++â”Š   â”Š141â”Š        y: (((-h * dx) + (Math.abs(dy) * Math.sqrt(delta))) / Math.pow(d, 2)) + this.y\n++â”Š   â”Š142â”Š      },\n++â”Š   â”Š143â”Š      {\n++â”Š   â”Š144â”Š        x: (((h * dy) - (((dy / Math.abs(dy)) || 1) * dx * Math.sqrt(delta))) / Math.pow(d, 2)) + this.x,\n++â”Š   â”Š145â”Š        y: (((-h * dx) - (Math.abs(dy) * Math.sqrt(delta))) / Math.pow(d, 2)) + this.y\n++â”Š   â”Š146â”Š      }\n++â”Š   â”Š147â”Š    ]\n++â”Š   â”Š148â”Š    .map(point => ({\n++â”Š   â”Š149â”Š        x: point.x.trim(9),\n++â”Š   â”Š150â”Š        y: point.y.trim(9)\n++â”Š   â”Š151â”Š    }))\n++â”Š   â”Š152â”Š    .filter(point => {\n++â”Š   â”Š153â”Š      return this.hasPoint(point.x, point.y) &&\n++â”Š   â”Š154â”Š        line.boundsHavePoint(point.x, point.y);\n++â”Š   â”Š155â”Š    });\n++â”Š   â”Š156â”Š\n++â”Š   â”Š157â”Š    interPoints = _.uniq(interPoints, point => `(${point.x}, ${point.y})`);\n++â”Š   â”Š158â”Š\n++â”Š   â”Š159â”Š    if (interPoints.length > 0) return interPoints;\n++â”Š   â”Š160â”Š  }\n++â”Š   â”Š161â”Š};ðŸš«â†µ\n+```\n+\n+##### Changed views/game.html\n+```diff\n+@@ -11,6 +11,7 @@\n+ â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/extensions.js\"></script>\n+ â”Š12â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n+ â”Š13â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/geometry/line.js\"></script>\n++â”Š  â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/geometry/circle.js\"></script>\n+ â”Š14â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/restorable.js\"></script>\n+ â”Š15â”Š16â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/font.js\"></script>\n+ â”Š16â”Š17â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/sprite.js\"></script>\n+```\n+[}]: #\n+\n+Just like a line, a circle can be presented using variables as well. The center of the circle is represented as `(x, y)` and its radius is represented as `r`. Remember that our circle doesn't necessarily have to be a full one, therefore we limit its range using two radians - `rad1` and `rad2`. The formula for representing a circle in a 2D space looks like this:\n+\n+![circle-formula](https://cloud.githubusercontent.com/assets/7648874/21829783/84a54574-d77f-11e6-9b87-3fb0f073bb8d.png)\n+\n+![circle-circle-illustration](https://cloud.githubusercontent.com/assets/7648874/21790842/3a73408c-d6c6-11e6-8bdd-9c73355e6ebb.png)\n+\n+> `a` and `b` represent the offsets from the `x` and the `y` axes respectively.\n+> See reference: http://mathworld.wolfram.com/Circle-CircleIntersection.html.\n+\n+To find intersection between two circles, we simply calculate the solution for two equations with two variables. Given that a line can be represented in a 2D space using the following formula:\n+\n+![line-formula](https://cloud.githubusercontent.com/assets/7648874/21790671/1609c050-d6c5-11e6-8bd7-16cc306f5eea.png)\n+\n+![circle-line-illustration](https://cloud.githubusercontent.com/assets/7648874/21790810/1a052086-d6c6-11e6-9c5c-24298fedb043.png)\n+\n+> `n` represents the intersection value with the `y` axis.\n+> See reference: http://mathworld.wolfram.com/Circle-LineIntersection.html.\n+\n+we can find the intersection between a circle and line by solving the systems formed by the equations of both. We also want the line-circle algorithm to be available for any `Line` instance, therefore we gonna add the following delegate on the `Line` prototype:\n+\n+[{]: <helper> (diff_step 5.8)\n+#### Step 5.8: Delegate circle intersection methods\n+\n+##### Changed resources/scripts/engine/geometry/line.js\n+```diff\n+@@ -38,6 +38,8 @@\n+ â”Š38â”Š38â”Š  getIntersection(shape) {\n+ â”Š39â”Š39â”Š    if (shape instanceof Engine.Geometry.Line)\n+ â”Š40â”Š40â”Š      return this.getLineIntersection(shape);\n++â”Š  â”Š41â”Š    if (shape instanceof Engine.Geometry.Circle)\n++â”Š  â”Š42â”Š      return this.getCircleIntersection(shape);\n+ â”Š41â”Š43â”Š  }\n+ â”Š42â”Š44â”Š\n+ â”Š43â”Š45â”Š  // line - line intersection method\n+```\n+```diff\n+@@ -54,4 +56,9 @@\n+ â”Š54â”Š56â”Š      return { x, y };\n+ â”Š55â”Š57â”Š    }\n+ â”Š56â”Š58â”Š  }\n++â”Š  â”Š59â”Š\n++â”Š  â”Š60â”Š  // line - circle intersection method\n++â”Š  â”Š61â”Š  getCircleIntersection(circle) {\n++â”Š  â”Š62â”Š    return circle.getLineIntersection(this);\n++â”Š  â”Š63â”Š  }\n+ â”Š57â”Š64â”Š};ðŸš«â†µ\n+```\n+[}]: #\n+\n+Then again a newly created geometry shape class should be tested against different scenarios:\n+\n+[{]: <helper> (diff_step 5.9)\n+#### Step 5.9: Create 'Circle' class tests\n+\n+##### Added resources/scripts/specs/engine/geometry/circle.js\n+```diff\n+@@ -0,0 +1,144 @@\n++â”Š   â”Š  1â”Šdescribe(\"Engine.Geometry.Circle class\", function() {\n++â”Š   â”Š  2â”Š  beforeEach(function() {\n++â”Š   â”Š  3â”Š    this.circle = new Engine.Geometry.Circle(1, 1, 5, 0, 1.5 * Math.PI);\n++â”Š   â”Š  4â”Š  });\n++â”Š   â”Š  5â”Š\n++â”Š   â”Š  6â”Š  describe(\"getX method\", function() {\n++â”Š   â”Š  7â”Š    describe(\"given inranged rad\", function() {\n++â”Š   â”Š  8â”Š      it(\"returns x\", function() {\n++â”Š   â”Š  9â”Š        expect(this.circle.getX(0 * Math.PI)).toBeCloseTo(6);\n++â”Š   â”Š 10â”Š        expect(this.circle.getX(0.5 * Math.PI)).toBeCloseTo(1);\n++â”Š   â”Š 11â”Š        expect(this.circle.getX(1 * Math.PI)).toBeCloseTo(-4);\n++â”Š   â”Š 12â”Š        expect(this.circle.getX(1.5 * Math.PI)).toBeCloseTo(1);\n++â”Š   â”Š 13â”Š      });\n++â”Š   â”Š 14â”Š    });\n++â”Š   â”Š 15â”Š\n++â”Š   â”Š 16â”Š    describe(\"given outranged rad\", function() {\n++â”Š   â”Š 17â”Š      it(\"returns nothing\", function() {\n++â”Š   â”Š 18â”Š        expect(this.circle.getX(2 * Math.PI)).toBeUndefined();\n++â”Š   â”Š 19â”Š      });\n++â”Š   â”Š 20â”Š    });\n++â”Š   â”Š 21â”Š  });\n++â”Š   â”Š 22â”Š\n++â”Š   â”Š 23â”Š  describe(\"getY method\", function() {\n++â”Š   â”Š 24â”Š    describe(\"given inranged rad\", function() {\n++â”Š   â”Š 25â”Š      it(\"returns y\", function() {\n++â”Š   â”Š 26â”Š        expect(this.circle.getY(0 * Math.PI)).toBeCloseTo(1);\n++â”Š   â”Š 27â”Š        expect(this.circle.getY(0.5 * Math.PI)).toBeCloseTo(6);\n++â”Š   â”Š 28â”Š        expect(this.circle.getY(1 * Math.PI)).toBeCloseTo(1);\n++â”Š   â”Š 29â”Š        expect(this.circle.getY(1.5 * Math.PI)).toBeCloseTo(-4);\n++â”Š   â”Š 30â”Š      });\n++â”Š   â”Š 31â”Š    });\n++â”Š   â”Š 32â”Š\n++â”Š   â”Š 33â”Š    describe(\"given outranged rad\", function() {\n++â”Š   â”Š 34â”Š      it(\"returns nothing\", function() {\n++â”Š   â”Š 35â”Š        expect(this.circle.getY(2 * Math.PI)).toBeUndefined();\n++â”Š   â”Š 36â”Š      });\n++â”Š   â”Š 37â”Š    });\n++â”Š   â”Š 38â”Š  });\n++â”Š   â”Š 39â”Š\n++â”Š   â”Š 40â”Š  describe(\"getRad method\", function() {\n++â”Š   â”Š 41â”Š    describe(\"given inranged point\", function() {\n++â”Š   â”Š 42â”Š      it(\"returns rad\", function() {\n++â”Š   â”Š 43â”Š        let x = -3.0450849718747346;\n++â”Š   â”Š 44â”Š        let y = 3.9389262614623686;\n++â”Š   â”Š 45â”Š        expect(this.circle.getRad(x, y)).toBeCloseTo(0.8 * Math.PI);\n++â”Š   â”Š 46â”Š      });\n++â”Š   â”Š 47â”Š    });\n++â”Š   â”Š 48â”Š\n++â”Š   â”Š 49â”Š    describe(\"given outranged point\", function() {\n++â”Š   â”Š 50â”Š      it(\"returns nothing\", function() {\n++â”Š   â”Š 51â”Š        let x = 5.045084971874736;\n++â”Š   â”Š 52â”Š        let y = -1.9389262614623664;\n++â”Š   â”Š 53â”Š        expect(this.circle.getRad(x, y)).toBeUndefined();\n++â”Š   â”Š 54â”Š      });\n++â”Š   â”Š 55â”Š    });\n++â”Š   â”Š 56â”Š  });\n++â”Š   â”Š 57â”Š\n++â”Š   â”Š 58â”Š  describe(\"getCircleIntersection method\", function() {\n++â”Š   â”Š 59â”Š    describe(\"given circle with 2 intersection points\", function() {\n++â”Š   â”Š 60â”Š      it(\"returns array with intersection points\", function() {\n++â”Š   â”Š 61â”Š        let circle = new Engine.Geometry.Circle(-5, 1, 5, 0, 2 * Math.PI);\n++â”Š   â”Š 62â”Š\n++â”Š   â”Š 63â”Š        expect(this.circle.getCircleIntersection(circle)).toEqual([\n++â”Š   â”Š 64â”Š          { x: -2, y: -3 },\n++â”Š   â”Š 65â”Š          { x: -2, y: 5 }\n++â”Š   â”Š 66â”Š        ]);\n++â”Š   â”Š 67â”Š      });\n++â”Š   â”Š 68â”Š    });\n++â”Š   â”Š 69â”Š\n++â”Š   â”Š 70â”Š    describe(\"given circle with 1 intersection points\", function() {\n++â”Š   â”Š 71â”Š      it(\"returns array with intersection point\", function() {\n++â”Š   â”Š 72â”Š        let circle = new Engine.Geometry.Circle(-5, 1, 5, 0, 1 * Math.PI);\n++â”Š   â”Š 73â”Š\n++â”Š   â”Š 74â”Š        expect(this.circle.getCircleIntersection(circle)).toEqual([\n++â”Š   â”Š 75â”Š          { x: -2, y: 5 }\n++â”Š   â”Š 76â”Š        ]);\n++â”Š   â”Š 77â”Š      });\n++â”Š   â”Š 78â”Š    });\n++â”Š   â”Š 79â”Š\n++â”Š   â”Š 80â”Š    describe(\"given kissing circle\", function() {\n++â”Š   â”Š 81â”Š      it(\"returns array with intersection point\", function() {\n++â”Š   â”Š 82â”Š        let circle = new Engine.Geometry.Circle(-9, 1, 5, 0, 2 * Math.PI);\n++â”Š   â”Š 83â”Š\n++â”Š   â”Š 84â”Š        expect(this.circle.getCircleIntersection(circle)).toEqual([\n++â”Š   â”Š 85â”Š          { x: -4, y: 1 }\n++â”Š   â”Š 86â”Š        ]);\n++â”Š   â”Š 87â”Š      });\n++â”Š   â”Š 88â”Š    });\n++â”Š   â”Š 89â”Š\n++â”Š   â”Š 90â”Š    describe(\"given outer circle\", function() {\n++â”Š   â”Š 91â”Š      it(\"returns nothing\", function() {\n++â”Š   â”Š 92â”Š        let circle = new Engine.Geometry.Circle(10, 10, 2, 0, 2 * Math.PI);\n++â”Š   â”Š 93â”Š        expect(this.circle.getCircleIntersection(circle)).toBeUndefined();\n++â”Š   â”Š 94â”Š      });\n++â”Š   â”Š 95â”Š    });\n++â”Š   â”Š 96â”Š\n++â”Š   â”Š 97â”Š    describe(\"given inner circle\", function() {\n++â”Š   â”Š 98â”Š      it(\"nothing\", function() {\n++â”Š   â”Š 99â”Š        let circle = new Engine.Geometry.Circle(1, 1, 2, 0, 2 * Math.PI);\n++â”Š   â”Š100â”Š        expect(this.circle.getCircleIntersection(circle)).toBeUndefined();\n++â”Š   â”Š101â”Š      });\n++â”Š   â”Š102â”Š    });\n++â”Š   â”Š103â”Š  });\n++â”Š   â”Š104â”Š\n++â”Š   â”Š105â”Š  describe(\"getLineIntersection method\", function() {\n++â”Š   â”Š106â”Š    describe(\"given line with 2 intersection points\", function() {\n++â”Š   â”Š107â”Š      it(\"returns array with intersection points\", function() {\n++â”Š   â”Š108â”Š        let line = new Engine.Geometry.Line(-10, 1, 10, 1);\n++â”Š   â”Š109â”Š\n++â”Š   â”Š110â”Š        expect(this.circle.getLineIntersection(line)).toEqual([\n++â”Š   â”Š111â”Š          { x: 6, y: 1 },\n++â”Š   â”Š112â”Š          { x: -4, y: 1 }\n++â”Š   â”Š113â”Š        ]);\n++â”Š   â”Š114â”Š      });\n++â”Š   â”Š115â”Š    });\n++â”Š   â”Š116â”Š\n++â”Š   â”Š117â”Š    describe(\"given line with 1 intersection point\", function() {\n++â”Š   â”Š118â”Š      it(\"returns array with intersection point\", function() {\n++â”Š   â”Š119â”Š        let line = new Engine.Geometry.Line(-10, 1, 1, 1);\n++â”Š   â”Š120â”Š\n++â”Š   â”Š121â”Š        expect(this.circle.getLineIntersection(line)).toEqual([\n++â”Š   â”Š122â”Š          { x: -4, y: 1 }\n++â”Š   â”Š123â”Š        ]);\n++â”Š   â”Š124â”Š      });\n++â”Š   â”Š125â”Š    });\n++â”Š   â”Š126â”Š\n++â”Š   â”Š127â”Š    describe(\"given kissing line\", function() {\n++â”Š   â”Š128â”Š      it(\"returns array with intersection point\", function() {\n++â”Š   â”Š129â”Š        let line = new Engine.Geometry.Line(-10, 6, 10, 6);\n++â”Š   â”Š130â”Š\n++â”Š   â”Š131â”Š        expect(this.circle.getLineIntersection(line)).toEqual([\n++â”Š   â”Š132â”Š          { x: 1, y: 6 }\n++â”Š   â”Š133â”Š        ]);\n++â”Š   â”Š134â”Š      });\n++â”Š   â”Š135â”Š    });\n++â”Š   â”Š136â”Š\n++â”Š   â”Š137â”Š    describe(\"given outranged line\", function() {\n++â”Š   â”Š138â”Š      it(\"returns nothing\", function() {\n++â”Š   â”Š139â”Š        let line = new Engine.Geometry.Line(-10, 10, 10, 10);\n++â”Š   â”Š140â”Š        expect(this.circle.getLineIntersection(line)).toBeUndefined();\n++â”Š   â”Š141â”Š      });\n++â”Š   â”Š142â”Š    });\n++â”Š   â”Š143â”Š  });\n++â”Š   â”Š144â”Š});ðŸš«â†µ\n+```\n+\n+##### Changed views/spec_runner.html\n+```diff\n+@@ -19,9 +19,11 @@\n+ â”Š19â”Š19â”Š    <script type=\"text/javascript\" src=\"scripts/extensions.js\"></script>\n+ â”Š20â”Š20â”Š    <script type=\"text/javascript\" src=\"scripts/namespaces.js\"></script>\n+ â”Š21â”Š21â”Š    <script type=\"text/javascript\" src=\"scripts/engine/geometry/line.js\"></script>\n++â”Š  â”Š22â”Š    <script type=\"text/javascript\" src=\"scripts/engine/geometry/circle.js\"></script>\n+ â”Š22â”Š23â”Š\n+ â”Š23â”Š24â”Š    <!-- Specs -->\n+ â”Š24â”Š25â”Š    <script type=\"text/javascript\" src=\"scripts/specs/engine/geometry/line.js\"></script>\n++â”Š  â”Š26â”Š    <script type=\"text/javascript\" src=\"scripts/specs/engine/geometry/circle.js\"></script>\n+ â”Š25â”Š27â”Š  </head>\n+ â”Š26â”Š28â”Š\n+ â”Š27â”Š29â”Š  <body>\n+```\n+[}]: #\n+\n+Our final shape in the geometry module would be a polygon. Why a polygon? Since I'm planning to make the snake's movement circular, which means that once the snake hits a random boundary, he will reappear from the other side of the canvas. The collision detection between the snake and the canvas would be done using a polygon - which is simply made out of 4 lines:\n+\n+[{]: <helper> (diff_step 5.10)\n+#### Step 5.10: Create 'Polygon' class\n+\n+##### Added resources/scripts/engine/geometry/polygon.js\n+```diff\n+@@ -0,0 +1,58 @@\n++â”Š  â”Š 1â”ŠEngine.Geometry.Polygon = class Polygon {\n++â”Š  â”Š 2â”Š  // bounds - an array of arrays. Each sub-array represents the arguments vector which\n++â”Š  â”Š 3â”Š  //   will be invoked by the line's construction method\n++â”Š  â”Š 4â”Š  constructor(...bounds) {\n++â”Š  â”Š 5â”Š    this.bounds = bounds.map(coords => new Engine.Geometry.Line(...coords));\n++â”Š  â”Š 6â”Š  }\n++â”Š  â”Š 7â”Š\n++â”Š  â”Š 8â”Š  // Returns if polygon has given point\n++â”Š  â”Š 9â”Š  hasPoint(x, y) {\n++â”Š  â”Š10â”Š    // Run check for each bound\n++â”Š  â”Š11â”Š    return this.bounds.some(bound => bound.hasPoint(x, y));\n++â”Š  â”Š12â”Š  }\n++â”Š  â”Š13â”Š\n++â”Š  â”Š14â”Š  getIntersection(shape) {\n++â”Š  â”Š15â”Š    if (shape instanceof Engine.Geometry.Line)\n++â”Š  â”Š16â”Š      return this.getLineIntersection(shape);\n++â”Š  â”Š17â”Š    if (shape instanceof Engine.Geometry.Circle)\n++â”Š  â”Š18â”Š      return this.getCircleIntersection(shape);\n++â”Š  â”Š19â”Š    if (shape instanceof Engine.Geometry.Polygon)\n++â”Š  â”Š20â”Š      return this.getPolygonIntersection(shape);\n++â”Š  â”Š21â”Š  }\n++â”Š  â”Š22â”Š\n++â”Š  â”Š23â”Š  // polygon - line intersection method\n++â”Š  â”Š24â”Š  getLineIntersection(line) {\n++â”Š  â”Š25â”Š    // line - line intersection for each bound\n++â”Š  â”Š26â”Š    let result = this.bounds.reduce((result, bound) => {\n++â”Š  â”Š27â”Š      let intersection = line.getLineIntersection(bound);\n++â”Š  â”Š28â”Š      if (intersection) result = result.concat(intersection);\n++â”Š  â”Š29â”Š      return result;\n++â”Š  â”Š30â”Š    }, []);\n++â”Š  â”Š31â”Š\n++â”Š  â”Š32â”Š    if (result.length) return result;\n++â”Š  â”Š33â”Š  }\n++â”Š  â”Š34â”Š\n++â”Š  â”Š35â”Š  // polygon - circle intersection method\n++â”Š  â”Š36â”Š  getCircleIntersection(circle) {\n++â”Š  â”Š37â”Š    // line - circle intersection for each bound\n++â”Š  â”Š38â”Š    let result = this.bounds.reduce((result, bound) => {\n++â”Š  â”Š39â”Š      let intersection = circle.getLineIntersection(bound);\n++â”Š  â”Š40â”Š      if (intersection) result = result.concat(intersection);\n++â”Š  â”Š41â”Š      return result;\n++â”Š  â”Š42â”Š    }, []);\n++â”Š  â”Š43â”Š\n++â”Š  â”Š44â”Š    if (result.length) return result;\n++â”Š  â”Š45â”Š  }\n++â”Š  â”Š46â”Š\n++â”Š  â”Š47â”Š  // polygon - polygon intersection method\n++â”Š  â”Š48â”Š  getPolygonIntersection(polygon) {\n++â”Š  â”Š49â”Š    // line - polygon intersection for each bound\n++â”Š  â”Š50â”Š    let result = this.bounds.reduce((result, bound) => {\n++â”Š  â”Š51â”Š      let intersection = polygon.getLineIntersection(bound);\n++â”Š  â”Š52â”Š      if (intersection) result = result.concat(intersection);\n++â”Š  â”Š53â”Š      return result;\n++â”Š  â”Š54â”Š    }, []);\n++â”Š  â”Š55â”Š\n++â”Š  â”Š56â”Š    if (result.length) return result;\n++â”Š  â”Š57â”Š  }\n++â”Š  â”Š58â”Š};ðŸš«â†µ\n+```\n+\n+##### Changed views/game.html\n+```diff\n+@@ -12,6 +12,7 @@\n+ â”Š12â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n+ â”Š13â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/geometry/line.js\"></script>\n+ â”Š14â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/geometry/circle.js\"></script>\n++â”Š  â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/geometry/polygon.js\"></script>\n+ â”Š15â”Š16â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/restorable.js\"></script>\n+ â”Š16â”Š17â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/font.js\"></script>\n+ â”Š17â”Š18â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/sprite.js\"></script>\n+```\n+[}]: #\n+\n+Again we will delegate the newly created intersection methods in the `Line` class and `Circle` class:\n+\n+[{]: <helper> (diff_step 5.11)\n+#### Step 5.11: Delegate polygon intersection methods\n+\n+##### Changed resources/scripts/engine/geometry/circle.js\n+```diff\n+@@ -77,6 +77,8 @@\n+ â”Š77â”Š77â”Š      return this.getLineIntersection(shape);\n+ â”Š78â”Š78â”Š    if (shape instanceof Engine.Geometry.Circle)\n+ â”Š79â”Š79â”Š      return this.getCircleIntersection(shape);\n++â”Š  â”Š80â”Š    if (shape instanceof Engine.Geometry.Polygon)\n++â”Š  â”Š81â”Š      return this.getPolygonIntersection(shape);\n+ â”Š80â”Š82â”Š  }\n+ â”Š81â”Š83â”Š\n+ â”Š82â”Š84â”Š  // circle - circle intersection method\n+```\n+```diff\n+@@ -158,4 +160,9 @@\n+ â”Š158â”Š160â”Š\n+ â”Š159â”Š161â”Š    if (interPoints.length > 0) return interPoints;\n+ â”Š160â”Š162â”Š  }\n++â”Š   â”Š163â”Š\n++â”Š   â”Š164â”Š  // circle - polygon intersection method\n++â”Š   â”Š165â”Š  getPolygonIntersection(polygon) {\n++â”Š   â”Š166â”Š    return polygon.getCircleIntersection(this);\n++â”Š   â”Š167â”Š  }\n+ â”Š161â”Š168â”Š};ðŸš«â†µ\n+```\n+\n+##### Changed resources/scripts/engine/geometry/line.js\n+```diff\n+@@ -40,6 +40,8 @@\n+ â”Š40â”Š40â”Š      return this.getLineIntersection(shape);\n+ â”Š41â”Š41â”Š    if (shape instanceof Engine.Geometry.Circle)\n+ â”Š42â”Š42â”Š      return this.getCircleIntersection(shape);\n++â”Š  â”Š43â”Š    if (shape instanceof Engine.Geometry.Polygon)\n++â”Š  â”Š44â”Š      return this.getPolygonIntersection(shape);\n+ â”Š43â”Š45â”Š  }\n+ â”Š44â”Š46â”Š\n+ â”Š45â”Š47â”Š  // line - line intersection method\n+```\n+```diff\n+@@ -61,4 +63,9 @@\n+ â”Š61â”Š63â”Š  getCircleIntersection(circle) {\n+ â”Š62â”Š64â”Š    return circle.getLineIntersection(this);\n+ â”Š63â”Š65â”Š  }\n++â”Š  â”Š66â”Š\n++â”Š  â”Š67â”Š  // line - polygon intersection method\n++â”Š  â”Š68â”Š  getPolygonIntersection(polygon) {\n++â”Š  â”Š69â”Š    return polygon.getLineIntersection(this);\n++â”Š  â”Š70â”Š  }\n+ â”Š64â”Š71â”Š};ðŸš«â†µ\n+```\n+[}]: #\n+\n+Now we will create a some tests to make sure our newly created polygon works properly:\n+\n+[{]: <helper> (diff_step 5.12)\n+#### Step 5.12: Create 'Polygon' class tests\n+\n+##### Added resources/scripts/specs/engine/geometry/polygon.js\n+```diff\n+@@ -0,0 +1,96 @@\n++â”Š  â”Š 1â”Šdescribe(\"Engine.Geometry.Polygon class\", function() {\n++â”Š  â”Š 2â”Š  beforeEach(function() {\n++â”Š  â”Š 3â”Š    this.polygon = new Engine.Geometry.Polygon(\n++â”Š  â”Š 4â”Š      [0, 0, 5, 0],\n++â”Š  â”Š 5â”Š      [5, 0, 5, 5],\n++â”Š  â”Š 6â”Š      [5, 5, 0, 5],\n++â”Š  â”Š 7â”Š      [0, 5, 0, 0]\n++â”Š  â”Š 8â”Š    );\n++â”Š  â”Š 9â”Š  });\n++â”Š  â”Š10â”Š\n++â”Š  â”Š11â”Š  describe(\"hasPoint method\", function() {\n++â”Š  â”Š12â”Š    describe(\"given contained point\", function() {\n++â”Š  â”Š13â”Š      it(\"returns true\", function() {\n++â”Š  â”Š14â”Š        let x = 5;\n++â”Š  â”Š15â”Š        let y = 3;\n++â”Š  â”Š16â”Š        expect(this.polygon.hasPoint(x, y)).toBeTruthy();\n++â”Š  â”Š17â”Š      });\n++â”Š  â”Š18â”Š    });\n++â”Š  â”Š19â”Š\n++â”Š  â”Š20â”Š    describe(\"given outranged point\", function() {\n++â”Š  â”Š21â”Š      it(\"returns false\", function() {\n++â”Š  â”Š22â”Š        let x = 10;\n++â”Š  â”Š23â”Š        let y = 10;\n++â”Š  â”Š24â”Š        expect(this.polygon.hasPoint(x, y)).toBeFalsy();\n++â”Š  â”Š25â”Š      });\n++â”Š  â”Š26â”Š    });\n++â”Š  â”Š27â”Š  });\n++â”Š  â”Š28â”Š\n++â”Š  â”Š29â”Š  describe(\"getLineIntersection method\", function() {\n++â”Š  â”Š30â”Š    describe(\"given intersecting line\", function() {\n++â”Š  â”Š31â”Š      it(\"returns intersection point\", function() {\n++â”Š  â”Š32â”Š        let line = new Engine.Geometry.Line(0, 1, 5, 4);\n++â”Š  â”Š33â”Š\n++â”Š  â”Š34â”Š        expect(this.polygon.getLineIntersection(line)).toEqual([\n++â”Š  â”Š35â”Š          { x: 5, y: 4 },\n++â”Š  â”Š36â”Š          { x: -0, y: 1 }\n++â”Š  â”Š37â”Š        ]);\n++â”Š  â”Š38â”Š      });\n++â”Š  â”Š39â”Š    });\n++â”Š  â”Š40â”Š\n++â”Š  â”Š41â”Š    describe(\"given outranged line\", function() {\n++â”Š  â”Š42â”Š      it(\"returns nothing\", function() {\n++â”Š  â”Š43â”Š        let line = new Engine.Geometry.Line(10, 11, 15, 14);\n++â”Š  â”Š44â”Š\n++â”Š  â”Š45â”Š        expect(this.polygon.getLineIntersection(line)).toBeUndefined();\n++â”Š  â”Š46â”Š      });\n++â”Š  â”Š47â”Š    });\n++â”Š  â”Š48â”Š  });\n++â”Š  â”Š49â”Š\n++â”Š  â”Š50â”Š  describe(\"getCircleIntersection method\", function() {\n++â”Š  â”Š51â”Š    describe(\"given circle with 2 intersection points\", function() {\n++â”Š  â”Š52â”Š      it(\"returns array with intersection points\", function() {\n++â”Š  â”Š53â”Š        let circle = new Engine.Geometry.Circle(0, 0, 2, 0, 2 * Math.PI);\n++â”Š  â”Š54â”Š\n++â”Š  â”Š55â”Š        expect(this.polygon.getCircleIntersection(circle)).toEqual([\n++â”Š  â”Š56â”Š          { x: 2, y: 0 },\n++â”Š  â”Š57â”Š          { x: 0, y: 2 }\n++â”Š  â”Š58â”Š        ]);\n++â”Š  â”Š59â”Š      });\n++â”Š  â”Š60â”Š    });\n++â”Š  â”Š61â”Š\n++â”Š  â”Š62â”Š    describe(\"given circle with 1 intersection points\", function() {\n++â”Š  â”Š63â”Š      it(\"returns array with intersection point\", function() {\n++â”Š  â”Š64â”Š        let circle = new Engine.Geometry.Circle(0, 0, 2, 0, 0.25 * Math.PI);\n++â”Š  â”Š65â”Š\n++â”Š  â”Š66â”Š        expect(this.polygon.getCircleIntersection(circle)).toEqual([\n++â”Š  â”Š67â”Š          { x: 2, y: 0 }\n++â”Š  â”Š68â”Š        ]);\n++â”Š  â”Š69â”Š      });\n++â”Š  â”Š70â”Š    });\n++â”Š  â”Š71â”Š\n++â”Š  â”Š72â”Š    describe(\"given kissing circle\", function() {\n++â”Š  â”Š73â”Š      it(\"returns array with intersection point\", function() {\n++â”Š  â”Š74â”Š        let circle = new Engine.Geometry.Circle(-3, 3, 3, 0, 2 * Math.PI);\n++â”Š  â”Š75â”Š\n++â”Š  â”Š76â”Š        expect(this.polygon.getCircleIntersection(circle)).toEqual([\n++â”Š  â”Š77â”Š          { x: 0, y: 3 }\n++â”Š  â”Š78â”Š        ]);\n++â”Š  â”Š79â”Š      });\n++â”Š  â”Š80â”Š    });\n++â”Š  â”Š81â”Š\n++â”Š  â”Š82â”Š    describe(\"given outer circle\", function() {\n++â”Š  â”Š83â”Š      it(\"returns nothing\", function() {\n++â”Š  â”Š84â”Š        let circle = new Engine.Geometry.Circle(10, 10, 2, 0, 2 * Math.PI);\n++â”Š  â”Š85â”Š        expect(this.polygon.getCircleIntersection(circle)).toBeUndefined();\n++â”Š  â”Š86â”Š      });\n++â”Š  â”Š87â”Š    });\n++â”Š  â”Š88â”Š\n++â”Š  â”Š89â”Š    describe(\"given inner circle\", function() {\n++â”Š  â”Š90â”Š      it(\"nothing\", function() {\n++â”Š  â”Š91â”Š        let circle = new Engine.Geometry.Circle(2.5, 2.5, 2, 0, 2 * Math.PI);\n++â”Š  â”Š92â”Š        expect(this.polygon.getCircleIntersection(circle)).toBeUndefined();\n++â”Š  â”Š93â”Š      });\n++â”Š  â”Š94â”Š    });\n++â”Š  â”Š95â”Š  });\n++â”Š  â”Š96â”Š});ðŸš«â†µ\n+```\n+\n+##### Changed views/spec_runner.html\n+```diff\n+@@ -20,10 +20,12 @@\n+ â”Š20â”Š20â”Š    <script type=\"text/javascript\" src=\"scripts/namespaces.js\"></script>\n+ â”Š21â”Š21â”Š    <script type=\"text/javascript\" src=\"scripts/engine/geometry/line.js\"></script>\n+ â”Š22â”Š22â”Š    <script type=\"text/javascript\" src=\"scripts/engine/geometry/circle.js\"></script>\n++â”Š  â”Š23â”Š    <script type=\"text/javascript\" src=\"scripts/engine/geometry/polygon.js\"></script>\n+ â”Š23â”Š24â”Š\n+ â”Š24â”Š25â”Š    <!-- Specs -->\n+ â”Š25â”Š26â”Š    <script type=\"text/javascript\" src=\"scripts/specs/engine/geometry/line.js\"></script>\n+ â”Š26â”Š27â”Š    <script type=\"text/javascript\" src=\"scripts/specs/engine/geometry/circle.js\"></script>\n++â”Š  â”Š28â”Š    <script type=\"text/javascript\" src=\"scripts/specs/engine/geometry/polygon.js\"></script>\n+ â”Š27â”Š29â”Š  </head>\n+ â”Š28â”Š30â”Š\n+ â”Š29â”Š31â”Š  <body>\n+```\n+[}]: #\n+\n+At last, all the necessary geometry shapes are implemented and ready to use. We will now focus on the snake itself. Since our game can potentially have infinite number of entities, not necessarily just a snake, we will add the a new module under the `Game` namespace called `Entities`:\n+\n+[{]: <helper> (diff_step 5.13)\n+#### Step 5.13: Add 'Entities' module to 'Game' namespace\n+\n+##### Changed resources/scripts/namespaces.js\n+```diff\n+@@ -1,4 +1,5 @@\n+ â”Š1â”Š1â”ŠGame = {\n++â”Š â”Š2â”Š  Entities: {},\n+ â”Š2â”Š3â”Š  Screens: {}\n+ â”Š3â”Š4â”Š};\n+```\n+[}]: #\n+\n+And now we can add the `Snake` class:\n+\n+[{]: <helper> (diff_step 5.14)\n+#### Step 5.14: Create 'Snake' class\n+\n+##### Added resources/scripts/game/entities/snake.js\n+```diff\n+@@ -0,0 +1,218 @@\n++â”Š   â”Š  1â”ŠGame.Entities.Snake = class Snake {\n++â”Š   â”Š  2â”Š  // Represents a snake data-structure which will eventually appear on screen.\n++â”Š   â”Š  3â”Š  // All the properties provided to the constructor are the initial values of\n++â”Š   â”Š  4â”Š  // the snake\n++â”Š   â”Š  5â”Š  constructor(x, y, r, rad, v, color, keyStates, options) {\n++â”Š   â”Š  6â”Š    this.x = x;\n++â”Š   â”Š  7â”Š    this.y = y;\n++â”Š   â”Š  8â”Š    this.r = r;\n++â”Š   â”Š  9â”Š    this.rad = rad;\n++â”Š   â”Š 10â”Š    this.v = v;\n++â”Š   â”Š 11â”Š    this.color = color;\n++â”Š   â”Š 12â”Š    this.keyStates = keyStates;\n++â”Š   â”Š 13â”Š    // A snake is made out of many geometry shapes\n++â”Š   â”Š 14â”Š    this.shapes = [];\n++â”Š   â”Š 15â”Š    // A snake starts with a line\n++â”Š   â”Š 16â”Š    this.currShape = new Engine.Geometry.Line(x, y, x, y);\n++â”Š   â”Š 17â”Š    this.shapes.push(this.currShape);\n++â”Š   â”Š 18â”Š    // A score can be provided in case we want to reserve previous scores from\n++â”Š   â”Š 19â”Š    // recent matches\n++â”Š   â”Š 20â”Š    this.score = options.score || 0;\n++â”Š   â”Š 21â”Š\n++â”Š   â”Š 22â”Š    // Custom keys can be specified\n++â”Š   â”Š 23â”Š    if (options.keys && options.keys) {\n++â”Š   â”Š 24â”Š      this.leftKey = options.keys.left;\n++â”Š   â”Š 25â”Š      this.rightKey = options.keys.right;\n++â”Š   â”Š 26â”Š    }\n++â”Š   â”Š 27â”Š    // Left and right arrow keys will be used by default\n++â”Š   â”Š 28â”Š    else {\n++â”Š   â”Š 29â”Š      this.leftKey = 37; // Left arrow\n++â”Š   â”Š 30â”Š      this.rightKey = 39; // Right arrow\n++â”Š   â”Š 31â”Š    }\n++â”Š   â”Š 32â”Š  }\n++â”Š   â”Š 33â”Š\n++â”Š   â”Š 34â”Š  draw(context) {\n++â”Š   â”Š 35â”Š    // Draw all shapes in the shapes array\n++â”Š   â”Š 36â”Š    this.shapes.forEach(shape => {\n++â”Š   â”Š 37â”Š      context.save();\n++â”Š   â”Š 38â”Š      context.strokeStyle = this.color;\n++â”Š   â”Š 39â”Š      context.lineWidth = 3;\n++â”Š   â”Š 40â”Š      context.beginPath();\n++â”Š   â”Š 41â”Š\n++â”Š   â”Š 42â”Š      // Use a different drawing method for line and circle\n++â”Š   â”Š 43â”Š      if (shape instanceof Engine.Geometry.Line) {\n++â”Š   â”Š 44â”Š        context.moveTo(shape.x1, shape.y1);\n++â”Š   â”Š 45â”Š        context.lineTo(shape.x2, shape.y2);\n++â”Š   â”Š 46â”Š      }\n++â”Š   â”Š 47â”Š      else {\n++â”Š   â”Š 48â”Š        context.arc(shape.x, shape.y, shape.r, shape.rad1, shape.rad2);\n++â”Š   â”Š 49â”Š      }\n++â”Š   â”Š 50â”Š\n++â”Š   â”Š 51â”Š      context.stroke();\n++â”Š   â”Š 52â”Š      context.restore();\n++â”Š   â”Š 53â”Š    });\n++â”Š   â”Š 54â”Š  }\n++â”Š   â”Š 55â”Š\n++â”Š   â”Š 56â”Š  update(span, width, height) {\n++â”Š   â”Š 57â”Š    // Progress made based on elapsed time and velocity\n++â”Š   â”Š 58â”Š    let step = (this.v * span) / 1000;\n++â”Š   â”Š 59â”Š\n++â”Š   â”Š 60â”Š    this.updateShapes(step, width, height);\n++â”Š   â”Š 61â”Š    this.cycleThrough(step, width, height);\n++â”Š   â”Š 62â”Š  }\n++â”Š   â”Š 63â”Š\n++â”Š   â”Š 64â”Š  // Updates shapes array based on progress made\n++â”Š   â”Š 65â”Š  updateShapes(step, width, height, options = {}) {\n++â”Š   â”Š 66â”Š    // Line update logic\n++â”Š   â”Š 67â”Š    if (this.currShape instanceof Engine.Geometry.Line) {\n++â”Š   â”Š 68â”Š      let lastX = options.lastX || this.x;\n++â”Š   â”Š 69â”Š      let lastY = options.lastY || this.y;\n++â”Š   â”Š 70â”Š      this.x = options.x || this.currShape.x2;\n++â”Š   â”Š 71â”Š      this.y = options.y || this.currShape.y2;\n++â”Š   â”Š 72â”Š      this.lastBit = new Engine.Geometry.Line(lastX, lastY, this.x, this.y);\n++â”Š   â”Š 73â”Š    }\n++â”Š   â”Š 74â”Š    // Circle update logic\n++â”Š   â”Š 75â”Š    else {\n++â”Š   â”Š 76â”Š      let lastX = options.lastX || this.currShape.x;\n++â”Š   â”Š 77â”Š      let lastY = options.lastY || this.currShape.y;\n++â”Š   â”Š 78â”Š      let lastR = options.lastR || this.currShape.r;\n++â”Š   â”Š 79â”Š\n++â”Š   â”Š 80â”Š      // Update logic for left rotation\n++â”Š   â”Š 81â”Š      if (this.direction == \"left\") {\n++â”Š   â”Š 82â”Š        let lastRad = this.rad + (0.5 * Math.PI);\n++â”Š   â”Š 83â”Š        let currShapePoint = this.currShape.getPoint(this.currShape.rad1);\n++â”Š   â”Š 84â”Š        this.x = options.x || currShapePoint.x;\n++â”Š   â”Š 85â”Š        this.y = options.y || currShapePoint.y;\n++â”Š   â”Š 86â”Š        this.rad = this.currShape.rad1 - (0.5 * Math.PI);\n++â”Š   â”Š 87â”Š        this.lastBit = new Engine.Geometry.Circle(lastX, lastY, lastR, this.currShape.rad1, lastRad);\n++â”Š   â”Š 88â”Š      }\n++â”Š   â”Š 89â”Š      // Update logic for right rotation\n++â”Š   â”Š 90â”Š      else {\n++â”Š   â”Š 91â”Š        let lastRad = this.rad - (0.5 * Math.PI);\n++â”Š   â”Š 92â”Š        let currShapePoint = this.currShape.getPoint(this.currShape.rad2);\n++â”Š   â”Š 93â”Š        this.x = options.x || currShapePoint.x;\n++â”Š   â”Š 94â”Š        this.y = options.y || currShapePoint.y;\n++â”Š   â”Š 95â”Š        this.rad = this.currShape.rad2 + (0.5 * Math.PI);\n++â”Š   â”Š 96â”Š        this.lastBit = new Engine.Geometry.Circle(lastX, lastY, lastR, lastRad, this.currShape.rad2);\n++â”Š   â”Š 97â”Š      }\n++â”Š   â”Š 98â”Š    }\n++â”Š   â”Š 99â”Š\n++â”Š   â”Š100â”Š    // Update the direction based on pressed key\n++â”Š   â”Š101â”Š    if (this.keyStates.get(this.leftKey))\n++â”Š   â”Š102â”Š      var direction = \"left\";\n++â”Š   â”Š103â”Š    else if (this.keyStates.get(this.rightKey))\n++â”Š   â”Š104â”Š      var direction = \"right\";\n++â”Š   â”Š105â”Š\n++â”Š   â”Š106â”Š    // If there is no change direction, abort, unless we force it\n++â”Š   â”Š107â”Š    if (direction != this.direction || options.force) {\n++â”Š   â”Š108â”Š      this.direction = direction;\n++â”Š   â”Š109â”Š\n++â”Š   â”Š110â”Š      // This will push a new shape with new properties, based on the direction\n++â”Š   â”Š111â”Š      switch (direction) {\n++â”Š   â”Š112â”Š        case \"left\":\n++â”Š   â”Š113â”Š          var angle = this.rad - (0.5 * Math.PI);\n++â”Š   â”Š114â”Š          var rad = this.rad + (0.5 * Math.PI);\n++â”Š   â”Š115â”Š          var x = this.x + (this.r * Math.cos(angle));\n++â”Š   â”Š116â”Š          var y = this.y + (this.r * Math.sin(angle));\n++â”Š   â”Š117â”Š          this.currShape = new Engine.Geometry.Circle(x, y, this.r, rad, rad);\n++â”Š   â”Š118â”Š          break;\n++â”Š   â”Š119â”Š        case \"right\":\n++â”Š   â”Š120â”Š          angle = this.rad + (0.5 * Math.PI);\n++â”Š   â”Š121â”Š          rad = this.rad - (0.5 * Math.PI);\n++â”Š   â”Š122â”Š          x = this.x + (this.r * Math.cos(angle));\n++â”Š   â”Š123â”Š          y = this.y + (this.r * Math.sin(angle));\n++â”Š   â”Š124â”Š          this.currShape = new Engine.Geometry.Circle(x, y, this.r, rad, rad);\n++â”Š   â”Š125â”Š          break;\n++â”Š   â”Š126â”Š        default:\n++â”Š   â”Š127â”Š          this.currShape = new Engine.Geometry.Line(this.x, this.y, this.x, this.y);\n++â”Š   â”Š128â”Š      }\n++â”Š   â”Š129â”Š\n++â”Š   â”Š130â”Š      this.shapes.push(this.currShape);\n++â”Š   â”Š131â”Š    }\n++â”Š   â”Š132â”Š\n++â”Š   â”Š133â”Š    // Extend the recent shape based on progress made\n++â”Š   â”Š134â”Š    switch (direction) {\n++â”Š   â”Š135â”Š      case \"left\":\n++â”Š   â”Š136â”Š        this.currShape.rad1 -= step / this.r;\n++â”Š   â”Š137â”Š        break;\n++â”Š   â”Š138â”Š      case \"right\":\n++â”Š   â”Š139â”Š        this.currShape.rad2 += step / this.r;\n++â”Š   â”Š140â”Š        break;\n++â”Š   â”Š141â”Š      default:\n++â”Š   â”Š142â”Š        this.currShape.x2 += step * Math.cos(this.rad);\n++â”Š   â”Š143â”Š        this.currShape.y2 += step * Math.sin(this.rad);\n++â”Š   â”Š144â”Š    }\n++â”Š   â”Š145â”Š  }\n++â”Š   â”Š146â”Š\n++â”Š   â”Š147â”Š  // Handles case where snake is out limits and we need to render it from\n++â”Š   â”Š148â”Š  // the other side of the canvas\n++â”Š   â”Š149â”Š  cycleThrough(step, width, height) {\n++â”Š   â”Š150â”Š    let intersectionPoint = this.getCanvasIntersection(width, height);\n++â”Š   â”Š151â”Š\n++â”Š   â”Š152â”Š    if (!intersectionPoint) return;\n++â”Š   â”Š153â”Š\n++â”Š   â”Š154â”Š    intersectionPoint = intersectionPoint[0];\n++â”Š   â”Š155â”Š\n++â”Š   â”Š156â”Š    // Re-calculate position based on canvas bounds\n++â”Š   â”Š157â”Š    if (intersectionPoint.x % width == 0)\n++â”Š   â”Š158â”Š      this.x = (this.x - width).mod(width);\n++â”Š   â”Š159â”Š    if (intersectionPoint.y % height == 0)\n++â”Š   â”Š160â”Š      this.y = (this.y - height).mod(height);\n++â”Š   â”Š161â”Š\n++â”Š   â”Š162â”Š    // Update shapes again based on custom properties\n++â”Š   â”Š163â”Š    this.updateShapes(step, width, height, {\n++â”Š   â”Š164â”Š      force: true,\n++â”Š   â”Š165â”Š      lastX: this.x,\n++â”Š   â”Š166â”Š      lastY: this.y,\n++â”Š   â”Š167â”Š      x: this.x,\n++â”Š   â”Š168â”Š      y: this.y\n++â”Š   â”Š169â”Š    });\n++â”Š   â”Š170â”Š  }\n++â”Š   â”Š171â”Š\n++â”Š   â”Š172â”Š  // Gets intersection points between last bit and own shapes\n++â”Š   â”Š173â”Š  getSelfIntersection() {\n++â”Š   â”Š174â”Š    if (this.currShape instanceof Engine.Geometry.Circle &&\n++â”Š   â”Š175â”Š       Math.abs(this.currShape.rad1 - this.currShape.rad2) >= 2 * Math.PI) {\n++â”Š   â”Š176â”Š      if (this.direction == \"left\")\n++â”Š   â”Š177â”Š        var rad = this.currShape.rad1;\n++â”Š   â”Š178â”Š      else\n++â”Š   â”Š179â”Š        var rad = this.currShape.rad2;\n++â”Š   â”Š180â”Š\n++â”Š   â”Š181â”Š      return this.currShape.getPoint(rad);\n++â”Š   â”Š182â”Š    }\n++â”Š   â”Š183â”Š\n++â”Š   â”Š184â”Š    let result;\n++â”Š   â”Š185â”Š\n++â”Š   â”Š186â”Š    this.shapes.slice(0, -2).some(shape =>\n++â”Š   â”Š187â”Š      result = this.lastBit.getIntersection(shape)\n++â”Š   â”Š188â”Š    );\n++â”Š   â”Š189â”Š\n++â”Š   â”Š190â”Š    return result;\n++â”Š   â”Š191â”Š  }\n++â”Š   â”Š192â”Š\n++â”Š   â”Š193â”Š  // Returns intersection points between snakes\n++â”Š   â”Š194â”Š  getSnakeIntersection(snake) {\n++â”Š   â”Š195â”Š    let result;\n++â”Š   â”Š196â”Š\n++â”Š   â”Š197â”Š    snake.shapes.some(shape =>\n++â”Š   â”Š198â”Š      // Only last bit is relevant, if we reached this point it means that\n++â”Š   â”Š199â”Š      // previous intersection will definitely fail\n++â”Š   â”Š200â”Š      result = this.lastBit.getIntersection(shape)\n++â”Š   â”Š201â”Š    );\n++â”Š   â”Š202â”Š\n++â”Š   â”Š203â”Š    return result;\n++â”Š   â”Š204â”Š  }\n++â”Š   â”Š205â”Š\n++â”Š   â”Š206â”Š  // Returns intersection points between snake and canvas\n++â”Š   â”Š207â”Š  getCanvasIntersection(width, height) {\n++â”Š   â”Š208â”Š    // Canvas polygon\n++â”Š   â”Š209â”Š    let canvasPolygon = new Engine.Geometry.Polygon(\n++â”Š   â”Š210â”Š      [0, 0, width, 0],\n++â”Š   â”Š211â”Š      [width, 0, width, height],\n++â”Š   â”Š212â”Š      [width, height, 0, height],\n++â”Š   â”Š213â”Š      [0, height, 0, 0]\n++â”Š   â”Š214â”Š    );\n++â”Š   â”Š215â”Š\n++â”Š   â”Š216â”Š    return canvasPolygon.getIntersection(this.lastBit);\n++â”Š   â”Š217â”Š  }\n++â”Š   â”Š218â”Š};ðŸš«â†µ\n+```\n+\n+##### Changed views/game.html\n+```diff\n+@@ -22,6 +22,7 @@\n+ â”Š22â”Š22â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/screen.js\"></script>\n+ â”Š23â”Š23â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/assets_loader.js\"></script>\n+ â”Š24â”Š24â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n++â”Š  â”Š25â”Š    <script type=\"text/javascript\" src=\"/scripts/game/entities/snake.js\"></script>\n+ â”Š25â”Š26â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/menu/index.js\"></script>\n+ â”Š26â”Š27â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/splash/index.js\"></script>\n+ â”Š27â”Š28â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n+```\n+[}]: #\n+\n+This class is titled with most complexity out of everything we did so far in this step. You can follow the code accompanied by comments regard it, but I'd also like to explain the key concepts. As said earlier, the `Snake` is simply made out of shapes; In this case - lines and circles.\n+\n+The `draw` method just goes through this array and draws whatever shape it's currently looping through. Regardless of its type, every shape is provided with a `draw` method of its own, all shapes share the same interface, therefore we can just draw them regularly and the snake should be drawn automatically.\n+\n+The `update` method updates the last bit only according to its type, the time elapsed and the speed of the snake. For example, the last bit of the snake is a line, and 5 seconds have passed at a speed of 5 meters per second, our line should be extended by 5 meters long. Same principle applies to circle extension only based on radians. The last bit's type might be changed according to the current input; e.g. if the `right` key is held the last bit would turn into a circle, and once released it would turn into a straight line.\n+\n+Note that besides shapes extension, collision detection should also be made. The embedded is the collision detection between the snake and the canvas, which means that any time the snake collides with the canvas's boundaries the last bit should be redrawn from the opposite side of the canvas. In addition, we've implemented intersection methods for self collision detection and collision detection between rivals, which should be used externally by the hosting screen.\n+\n+In the next step we will be implementing the game screen where we will make use of the `Snake` class we've just created, and see how it works in action.\n+[}]: #\n+[{]: <region> (footer)\n+[{]: <helper> (nav_step)\n+| [< Previous Step](step4.md) | [Next Step >](step6.md) |\n+|:--------------------------------|--------------------------------:|\n+[}]: #\n+[}]: #\n\\ No newline at end of file\ndiff --git a/manuals/views/step6.md b/manuals/views/step6.md\nnew file mode 100644\nindex 0000000..f3a8a39\n--- /dev/null\n+++ b/manuals/views/step6.md\n@@ -0,0 +1,536 @@\n+[{]: <region> (header)\n+# Step 6: Creating a complex game screen with multiple layers\n+[}]: #\n+[{]: <region> (body)\n+![snake-demo-game-small](https://cloud.githubusercontent.com/assets/7648874/21074124/8b7cd724-bed7-11e6-9f91-2a211630ac78.gif)\n+\n+In this step we will be using the `Snake` class we've just created in the previous step to form the actual game screen - called the `Play` screen. The play screen is a complex screen made out multiple layers as following:\n+\n+- **`Ready` layer** - Displays a message at the beginning of each match.\n+- **`Snake` layer** - Displays the the competitors' snakes.\n+- **`Score` layer** - Displays the score board.\n+- **`Win` layer** - Displays the winner at the end of each match.\n+\n+As we go further with this step, we will give a deeper explanation about each layer and how they interact with each other; As for let's start with the `Play` screen's basis. Regardless of what the `Play` screen should contain at the final result, we want to have the ability to abort the match whenever we press the `Escape` key, therefore, the initial implementation should look like this:\n+\n+[{]: <helper> (diff_step 6.1)\n+#### Step 6.1: Create 'Play' screen\n+\n+##### Added resources/scripts/game/screens/play/index.js\n+```diff\n+@@ -0,0 +1,14 @@\n++â”Š  â”Š 1â”ŠGame.Screens.Play = class Play extends Engine.Screen {\n++â”Š  â”Š 2â”Š  get events() {\n++â”Š  â”Š 3â”Š    return {\n++â”Š  â”Š 4â”Š      \"keydown\": \"onKeyDown\"\n++â”Š  â”Š 5â”Š    }\n++â”Š  â”Š 6â”Š  }\n++â”Š  â”Š 7â”Š\n++â”Š  â”Š 8â”Š  onKeyDown() {\n++â”Š  â”Š 9â”Š    // Once escape is pressed, return to main menu screen\n++â”Š  â”Š10â”Š    if (this.keyStates.get(27)) {\n++â”Š  â”Š11â”Š      this.game.changeScreen(Game.Screens.Menu);\n++â”Š  â”Š12â”Š    }\n++â”Š  â”Š13â”Š  }\n++â”Š  â”Š14â”Š};ðŸš«â†µ\n+```\n+\n+##### Changed views/game.html\n+```diff\n+@@ -23,6 +23,7 @@\n+ â”Š23â”Š23â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/assets_loader.js\"></script>\n+ â”Š24â”Š24â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n+ â”Š25â”Š25â”Š    <script type=\"text/javascript\" src=\"/scripts/game/entities/snake.js\"></script>\n++â”Š  â”Š26â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/index.js\"></script>\n+ â”Š26â”Š27â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/menu/index.js\"></script>\n+ â”Š27â”Š28â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/splash/index.js\"></script>\n+ â”Š28â”Š29â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n+```\n+[}]: #\n+\n+Now that we have the `Play` screen, we need to hook it to the `Menu` screen, so whenever we press a key, we will be proceeded to it:\n+\n+[{]: <helper> (diff_step 6.2)\n+#### Step 6.2: Hook 'Play' screen to 'menu' screen\n+\n+##### Changed resources/scripts/game/screens/menu/index.js\n+```diff\n+@@ -1,4 +1,10 @@\n+ â”Š 1â”Š 1â”ŠGame.Screens.Menu = class Menu extends Engine.Screen {\n++â”Š  â”Š 2â”Š  get events() {\n++â”Š  â”Š 3â”Š    return {\n++â”Š  â”Š 4â”Š      \"keydown\": \"onKeyDown\"\n++â”Š  â”Š 5â”Š    }\n++â”Š  â”Š 6â”Š  }\n++â”Š  â”Š 7â”Š\n+ â”Š 2â”Š 8â”Š  initialize() {\n+ â”Š 3â”Š 9â”Š    // Initialize snake logo sprite\n+ â”Š 4â”Š10â”Š    this.logoSprite = new Engine.Sprite(this.assets.logoTexture);\n+```\n+```diff\n+@@ -40,10 +46,18 @@\n+ â”Š40â”Š46â”Š  }\n+ â”Š41â”Š47â”Š\n+ â”Š42â”Š48â”Š  update(span) {\n+-â”Š43â”Š  â”Š    this.instructionsAnim.update(span);\n++â”Š  â”Š49â”Š    // On key press, proceed to play screen\n++â”Š  â”Š50â”Š    if (this.keyPressed) {\n++â”Š  â”Š51â”Š      this.game.changeScreen(Game.Screens.Play);\n++â”Š  â”Š52â”Š    }\n++â”Š  â”Š53â”Š    // Else, just update animation\n++â”Š  â”Š54â”Š    else {\n++â”Š  â”Š55â”Š      this.instructionsAnim.update(span);\n++â”Š  â”Š56â”Š    }\n+ â”Š44â”Š57â”Š  }\n+ â”Š45â”Š58â”Š\n+-â”Š46â”Š  â”Š  update(span) {\n+-â”Š47â”Š  â”Š    this.instructionsAnim.update(span);\n++â”Š  â”Š59â”Š  // Register key press\n++â”Š  â”Š60â”Š  onKeyDown(e) {\n++â”Š  â”Š61â”Š    this.keyPressed = true;\n+ â”Š48â”Š62â”Š  }\n+ â”Š49â”Š63â”Š};ðŸš«â†µ\n+```\n+[}]: #\n+\n+By now there shouldn't be anything special. Once you're at the main menu, just press a key as instructed, and you shall see a black screen, which is actually the `Play` screen we've just created; And once you'll press the `Escape` key, you should be receded to the main menu.\n+\n+The next stage would be displaying a `Ready` message on the screen, and whenever a key is pressed, the message should fade away using a key-frame animation, and the match should start in the background:\n+\n+[{]: <helper> (diff_step 6.3)\n+#### Step 6.3: Create 'Ready' layer\n+\n+##### Added resources/scripts/game/screens/play/ready.js\n+```diff\n+@@ -0,0 +1,59 @@\n++â”Š  â”Š 1â”ŠGame.Screens.Play.Ready = class Ready extends Engine.Layer {\n++â”Š  â”Š 2â”Š  get events() {\n++â”Š  â”Š 3â”Š    return {\n++â”Š  â”Š 4â”Š      \"keydown\": \"onKeyDown\"\n++â”Š  â”Š 5â”Š    };\n++â”Š  â”Š 6â”Š  }\n++â”Š  â”Š 7â”Š\n++â”Š  â”Š 8â”Š  constructor(screen, snakes) {\n++â”Š  â”Š 9â”Š    super(screen);\n++â”Š  â”Š10â”Š\n++â”Š  â”Š11â”Š    this.snakes = snakes;\n++â”Š  â”Š12â”Š\n++â”Š  â”Š13â”Š    // Create \"ready\" sprite and set its properties\n++â”Š  â”Š14â”Š    let readyTexture = this.assets.minecraftiaFont.createTexture(\"Ready\");\n++â”Š  â”Š15â”Š    let readySprite = new Engine.Sprite(readyTexture);\n++â”Š  â”Š16â”Š    readySprite.align = \"center\";\n++â”Š  â”Š17â”Š    readySprite.setPercentage(\"width\", this.width, 15, \"height\");\n++â”Š  â”Š18â”Š\n++â”Š  â”Š19â”Š    // Create fade out animation for \"ready\" sprite\n++â”Š  â”Š20â”Š    this.readyAnim = new Engine.Animations.Keyframe(readySprite, [\n++â”Š  â”Š21â”Š      {\n++â”Š  â”Š22â”Š        x: this.width / 2,\n++â”Š  â”Š23â”Š        y: this.height / 2,\n++â”Š  â”Š24â”Š        opacity: 1,\n++â”Š  â”Š25â”Š        frame: 0\n++â”Š  â”Š26â”Š      },\n++â”Š  â”Š27â”Š      {\n++â”Š  â”Š28â”Š        y: this.height / 3,\n++â”Š  â”Š29â”Š        opacity: 0,\n++â”Š  â”Š30â”Š        frame: 700\n++â”Š  â”Š31â”Š      }\n++â”Š  â”Š32â”Š    ]);\n++â”Š  â”Š33â”Š  }\n++â”Š  â”Š34â”Š\n++â”Š  â”Š35â”Š  draw(context) {\n++â”Š  â”Š36â”Š    this.readyAnim.draw(context);\n++â”Š  â”Š37â”Š  }\n++â”Š  â”Š38â”Š\n++â”Š  â”Š39â”Š  update(span) {\n++â”Š  â”Š40â”Š    if (!this.ready) return;\n++â”Š  â”Š41â”Š\n++â”Š  â”Š42â”Š    if (this.readyAnim.playing) {\n++â”Š  â”Š43â”Š      this.readyAnim.update(span);\n++â”Š  â”Š44â”Š    }\n++â”Š  â”Š45â”Š    // Once animation is finished, dispose layer\n++â”Š  â”Š46â”Š    else {\n++â”Š  â”Š47â”Š      this.screen.removeLayer(this);\n++â”Š  â”Š48â”Š    }\n++â”Š  â”Š49â”Š  }\n++â”Š  â”Š50â”Š\n++â”Š  â”Š51â”Š  onKeyDown() {\n++â”Š  â”Š52â”Š    // One time event\n++â”Š  â”Š53â”Š    this.disposeEventListeners()\n++â”Š  â”Š54â”Š\n++â”Š  â”Š55â”Š    // This will start playing the animation\n++â”Š  â”Š56â”Š    this.ready = true;\n++â”Š  â”Š57â”Š    this.readyAnim.play();\n++â”Š  â”Š58â”Š  }\n++â”Š  â”Š59â”Š};ðŸš«â†µ\n+```\n+\n+##### Changed views/game.html\n+```diff\n+@@ -24,6 +24,7 @@\n+ â”Š24â”Š24â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n+ â”Š25â”Š25â”Š    <script type=\"text/javascript\" src=\"/scripts/game/entities/snake.js\"></script>\n+ â”Š26â”Š26â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/index.js\"></script>\n++â”Š  â”Š27â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/ready.js\"></script>\n+ â”Š27â”Š28â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/menu/index.js\"></script>\n+ â”Š28â”Š29â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/splash/index.js\"></script>\n+ â”Š29â”Š30â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n+```\n+[}]: #\n+\n+In order to hook the `Ready` layer to the `Play` screen, we will just push a new instance of it to the layers stack, using the screen's `appendLayer` method. Note that the order of the layer is super critic! Since if we push a new layer it means it will be drawn on top of any previous layer. To \"shift\" a layer to the layers stack, we can simply use the `prependLayer` method instead. Without further due, this is how our hook should look like:\n+\n+[{]: <helper> (diff_step 6.4)\n+#### Step 6.4: Hook 'Ready' layer to 'Play' screen\n+\n+##### Changed resources/scripts/game/screens/play/index.js\n+```diff\n+@@ -5,6 +5,11 @@\n+ â”Š 5â”Š 5â”Š    }\n+ â”Š 6â”Š 6â”Š  }\n+ â”Š 7â”Š 7â”Š\n++â”Š  â”Š 8â”Š  // The ready screen will be the initial screen\n++â”Š  â”Š 9â”Š  initialize(game, snakes) {\n++â”Š  â”Š10â”Š    this.appendLayer(Game.Screens.Play.Ready, snakes);\n++â”Š  â”Š11â”Š  }\n++â”Š  â”Š12â”Š\n+ â”Š 8â”Š13â”Š  onKeyDown() {\n+ â”Š 9â”Š14â”Š    // Once escape is pressed, return to main menu screen\n+ â”Š10â”Š15â”Š    if (this.keyStates.get(27)) {\n+```\n+[}]: #\n+\n+Now if you'll launch the game and start a new match, you should see a white `Ready` message in the middle of the screen. Up next, would be the `Snake` layer, which will simply initialize 2 new `Snake` instances, and take care of drawing and updating them:\n+\n+[{]: <helper> (diff_step 6.5)\n+#### Step 6.5: Create 'snake' layer\n+\n+##### Added resources/scripts/game/screens/play/snake.js\n+```diff\n+@@ -0,0 +1,79 @@\n++â”Š  â”Š 1â”ŠGame.Screens.Play.Snake = class Snake extends Engine.Layer {\n++â”Š  â”Š 2â”Š  constructor(screen, snakes = []) {\n++â”Š  â”Š 3â”Š    super(screen);\n++â”Š  â”Š 4â”Š\n++â”Š  â”Š 5â”Š    // Red snake\n++â”Š  â”Š 6â”Š    this.snakes = [\n++â”Š  â”Š 7â”Š      new Game.Entities.Snake(\n++â”Š  â”Š 8â”Š        this.width / 4,\n++â”Š  â”Š 9â”Š        this.height / 4,\n++â”Š  â”Š10â”Š        50,\n++â”Š  â”Š11â”Š        Math.PI / 4,\n++â”Š  â”Š12â”Š        100,\n++â”Š  â”Š13â”Š        \"FireBrick\",\n++â”Š  â”Š14â”Š        this.keyStates,\n++â”Š  â”Š15â”Š        {\n++â”Š  â”Š16â”Š          // Use score from previous matches\n++â”Š  â”Š17â”Š          score: snakes[0] && snakes[0].score,\n++â”Š  â”Š18â”Š          keys: {\n++â”Š  â”Š19â”Š            left: 37, // Left key\n++â”Š  â”Š20â”Š            right: 39 // RIght key\n++â”Š  â”Š21â”Š        }\n++â”Š  â”Š22â”Š      }),\n++â”Š  â”Š23â”Š\n++â”Š  â”Š24â”Š      // Blue snake\n++â”Š  â”Š25â”Š      new Game.Entities.Snake(\n++â”Š  â”Š26â”Š        (this.width / 4) * 3,\n++â”Š  â”Š27â”Š        (this.height / 4) * 3,\n++â”Š  â”Š28â”Š        50,\n++â”Š  â”Š29â”Š        (-Math.PI / 4) * 3,\n++â”Š  â”Š30â”Š        100,\n++â”Š  â”Š31â”Š        \"DodgerBlue\",\n++â”Š  â”Š32â”Š        this.keyStates,\n++â”Š  â”Š33â”Š        {\n++â”Š  â”Š34â”Š          score: snakes[1] && snakes[1].score,\n++â”Š  â”Š35â”Š          keys: {\n++â”Š  â”Š36â”Š            left: 65, // 'a' key\n++â”Š  â”Š37â”Š            right: 68 // 'b' key\n++â”Š  â”Š38â”Š        }\n++â”Š  â”Š39â”Š      })\n++â”Š  â”Š40â”Š    ];\n++â”Š  â”Š41â”Š  }\n++â”Š  â”Š42â”Š\n++â”Š  â”Š43â”Š  draw(context) {\n++â”Š  â”Š44â”Š    // Draw each snake in the snakes array\n++â”Š  â”Š45â”Š    this.snakes.forEach(snake => snake.draw(context));\n++â”Š  â”Š46â”Š  }\n++â”Š  â”Š47â”Š\n++â”Š  â”Š48â”Š  update(span) {\n++â”Š  â”Š49â”Š    if (!this.snakes.length) return;\n++â”Š  â”Š50â”Š\n++â”Š  â”Š51â”Š    // Storing original snakes array for future use, since it might get changed\n++â”Š  â”Š52â”Š    let snakes = this.snakes.slice();\n++â”Š  â”Š53â”Š\n++â”Š  â”Š54â”Š    snakes.forEach((snake, index) => {\n++â”Š  â”Š55â”Š      snake.update(span, this.width, this.height);\n++â”Š  â”Š56â”Š      // Disqualify if intersected with self\n++â”Š  â”Š57â”Š      if (snake.getSelfIntersection()) return this.snakes.splice(index, 1);\n++â”Š  â”Š58â”Š\n++â”Š  â”Š59â”Š      snakes.forEach((opponent) => {\n++â”Š  â”Š60â”Š        // Don't scan for intersection with self, obviously this will always be true\n++â”Š  â”Š61â”Š        if (opponent === snake) return;\n++â”Š  â”Š62â”Š        // Disqualify if intersected with opponent\n++â”Š  â”Š63â”Š        if (snake.getSnakeIntersection(opponent)) return this.snakes.splice(index, 1);\n++â”Š  â”Š64â”Š      });\n++â”Š  â”Š65â”Š    });\n++â”Š  â”Š66â”Š\n++â”Š  â”Š67â”Š    // There can be only one winner, or a tie (very rare, most likely not to happen)\n++â”Š  â”Š68â”Š    // If the match is already finished, skip the next steps since they are not relevant\n++â”Š  â”Š69â”Š    if (this.snakes.length > 1 || this.matchFinished) return;\n++â”Š  â”Š70â”Š\n++â”Š  â”Š71â”Š    // The winner is the \"last snake standing\"\n++â”Š  â”Š72â”Š    let winner = this.snakes[0];\n++â”Š  â”Š73â”Š    // If this is not a tie, which is a very rare case, increase the winner's score\n++â”Š  â”Š74â”Š    if (winner) winner.score++;\n++â”Š  â”Š75â”Š\n++â”Š  â”Š76â”Š    // Indicates whether we should update the score counter or not\n++â”Š  â”Š77â”Š    this.matchFinished = true;\n++â”Š  â”Š78â”Š  }\n++â”Š  â”Š79â”Š};ðŸš«â†µ\n+```\n+\n+##### Changed views/game.html\n+```diff\n+@@ -24,6 +24,7 @@\n+ â”Š24â”Š24â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n+ â”Š25â”Š25â”Š    <script type=\"text/javascript\" src=\"/scripts/game/entities/snake.js\"></script>\n+ â”Š26â”Š26â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/index.js\"></script>\n++â”Š  â”Š27â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/snake.js\"></script>\n+ â”Š27â”Š28â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/ready.js\"></script>\n+ â”Š28â”Š29â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/menu/index.js\"></script>\n+ â”Š29â”Š30â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/splash/index.js\"></script>\n+```\n+[}]: #\n+\n+Once pressing a key in the `Ready` layer, not only we want to display an animation, but we also want the match to start in the background, thus, we gonna push a new instance of the `Snake` layer we've just created like so:\n+\n+[{]: <helper> (diff_step 6.6)\n+#### Step 6.6: Hook 'snake' layer to 'ready' layer\n+\n+##### Changed resources/scripts/game/screens/play/ready.js\n+```diff\n+@@ -55,5 +55,8 @@\n+ â”Š55â”Š55â”Š    // This will start playing the animation\n+ â”Š56â”Š56â”Š    this.ready = true;\n+ â”Š57â”Š57â”Š    this.readyAnim.play();\n++â”Š  â”Š58â”Š\n++â”Š  â”Š59â”Š    // Start the game in the background\n++â”Š  â”Š60â”Š    this.screen.prependLayer(Game.Screens.Play.Snake, this.snakes);\n+ â”Š58â”Š61â”Š  }\n+ â”Š59â”Š62â”Š};ðŸš«â†µ\n+```\n+[}]: #\n+\n+Note that the layer is pushed when the animation starts and not once finished; This would give a nice smooth feeling to our game-flow. If you'll test out the game, you would discover that the match is actually playable! The first snake (Red) snake should be controlled by the arrow keys, and the second snake (Blue) should be controlled by the letter keys `a`, `s`, `d` and `w`. So far, the snakes function great, but you can probably tell that whenever a match is finished, it feels a bit dull. There's no indication of winning, and there's no score board to present the score of each competitor, which brings us to the next stage - Implementing the `Score` layer.\n+\n+The `Score` layer is a simple layer which takes the 2 snakes as a parameter and displays their scores at the top of the screen:\n+\n+[{]: <helper> (diff_step 6.7)\n+#### Step 6.7: Create 'Score' layer\n+\n+##### Added resources/scripts/game/screens/play/score.js\n+```diff\n+@@ -0,0 +1,66 @@\n++â”Š  â”Š 1â”ŠGame.Screens.Play.Score = class Score extends Engine.Layer {\n++â”Š  â”Š 2â”Š  constructor(screen, snakes) {\n++â”Š  â”Š 3â”Š    super(screen);\n++â”Š  â”Š 4â”Š\n++â”Š  â”Š 5â”Š    this.snakes = snakes;\n++â”Š  â”Š 6â”Š    this.scoreSprites = [];\n++â”Š  â”Š 7â”Š    this.scores = [];\n++â”Š  â”Š 8â”Š\n++â”Š  â”Š 9â”Š    // It's important to match indexes to each snake since the number of snakes\n++â”Š  â”Š10â”Š    // can be reduced along the way as we play\n++â”Š  â”Š11â”Š    snakes.forEach((snake, index) => {\n++â”Š  â”Š12â”Š      snake.index = index;\n++â”Š  â”Š13â”Š    });\n++â”Š  â”Š14â”Š  }\n++â”Š  â”Š15â”Š\n++â”Š  â”Š16â”Š  draw(context) {\n++â”Š  â”Š17â”Š    this.scoreSprites.forEach((scoreSprite) => {\n++â”Š  â”Š18â”Š      scoreSprite.draw(context);\n++â”Š  â”Š19â”Š    });\n++â”Š  â”Š20â”Š  }\n++â”Š  â”Š21â”Š\n++â”Š  â”Š22â”Š  update(span) {\n++â”Š  â”Š23â”Š    this.snakes.forEach(snake => {\n++â”Š  â”Š24â”Š      let index = snake.index;\n++â”Š  â”Š25â”Š      if (this.scores[index] == snake.score) return;\n++â”Š  â”Š26â”Š\n++â”Š  â”Š27â”Š      // The sprite might be changed along the way so it's important to recreate it\n++â”Š  â”Š28â”Š      // over and over again. If no change was made the cache will be used by the engine\n++â”Š  â”Š29â”Š      this.scoreSprites[index] = this.createScoreSprite(snake);\n++â”Š  â”Š30â”Š      this.scores[index] = snake.score;\n++â”Š  â”Š31â”Š    });\n++â”Š  â”Š32â”Š  }\n++â”Š  â”Š33â”Š\n++â”Š  â”Š34â”Š  createScoreSprite(snake) {\n++â”Š  â”Š35â”Š    let minecraftiaFont = this.assets.minecraftiaFont;\n++â”Š  â”Š36â”Š    minecraftiaFont.save();\n++â”Š  â”Š37â”Š    minecraftiaFont.color = snake.color;\n++â”Š  â”Š38â”Š\n++â”Š  â”Š39â”Š    // Create a score sprite for the snake\n++â”Š  â”Š40â”Š    let scoreTexture = minecraftiaFont.createTexture(`${snake.score}`, {\n++â”Š  â”Š41â”Š      noOffsets: true,\n++â”Š  â”Š42â”Š      noSpaces: true\n++â”Š  â”Š43â”Š    });\n++â”Š  â”Š44â”Š\n++â”Š  â”Š45â”Š    let scoreSprite = new Engine.Sprite(scoreTexture);\n++â”Š  â”Š46â”Š\n++â”Š  â”Š47â”Š    // Size of score board is dynamic to screen size\n++â”Š  â”Š48â”Š    scoreSprite.setPercentage(\"width\", this.width, 4, \"height\");\n++â”Š  â”Š49â”Š\n++â”Š  â”Š50â”Š    // Set alignment modes.\n++â”Š  â”Š51â”Š    // Once we add more snakes we should add more cases here\n++â”Š  â”Š52â”Š    switch (snake.index) {\n++â”Š  â”Š53â”Š      case 0:\n++â”Š  â”Š54â”Š        scoreSprite.align = \"top-left\";\n++â”Š  â”Š55â”Š        break;\n++â”Š  â”Š56â”Š      case 1:\n++â”Š  â”Š57â”Š        scoreSprite.align = \"top-right\";\n++â”Š  â”Š58â”Š        scoreSprite.x = this.width;\n++â”Š  â”Š59â”Š        break;\n++â”Š  â”Š60â”Š    }\n++â”Š  â”Š61â”Š\n++â”Š  â”Š62â”Š    // Restore the font to its original color\n++â”Š  â”Š63â”Š    minecraftiaFont.restore();\n++â”Š  â”Š64â”Š    return scoreSprite;\n++â”Š  â”Š65â”Š  }\n++â”Š  â”Š66â”Š};ðŸš«â†µ\n+```\n+\n+##### Changed views/game.html\n+```diff\n+@@ -24,6 +24,7 @@\n+ â”Š24â”Š24â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n+ â”Š25â”Š25â”Š    <script type=\"text/javascript\" src=\"/scripts/game/entities/snake.js\"></script>\n+ â”Š26â”Š26â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/index.js\"></script>\n++â”Š  â”Š27â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/score.js\"></script>\n+ â”Š27â”Š28â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/snake.js\"></script>\n+ â”Š28â”Š29â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/ready.js\"></script>\n+ â”Š29â”Š30â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/menu/index.js\"></script>\n+```\n+[}]: #\n+\n+> Note that the current score board is suitable for two players, but can easily be modified to support as much players as you want if done correctly.\n+\n+The `Score` board should be appended to the layers stack as soon as the `Snake` layers is initialized, so it would be available to us once the match is started:\n+\n+[{]: <helper> (diff_step 6.8)\n+#### Step 6.8: Hook 'Score' layer to 'Snake' layer\n+\n+##### Changed resources/scripts/game/screens/play/snake.js\n+```diff\n+@@ -38,6 +38,9 @@\n+ â”Š38â”Š38â”Š        }\n+ â”Š39â”Š39â”Š      })\n+ â”Š40â”Š40â”Š    ];\n++â”Š  â”Š41â”Š\n++â”Š  â”Š42â”Š    // Show score board for newly created snakes\n++â”Š  â”Š43â”Š    screen.appendLayer(Game.Screens.Play.Score, this.snakes);\n+ â”Š41â”Š44â”Š  }\n+ â”Š42â”Š45â”Š\n+ â”Š43â”Š46â”Š  draw(context) {\n+```\n+[}]: #\n+\n+Now we're one layer further from completing the `Play` screen, the only thing missing is the `Win` layer, which should present the winner once the match is finished:\n+\n+[{]: <helper> (diff_step 6.9)\n+#### Step 6.9: Create 'Win' layer\n+\n+##### Added resources/scripts/game/screens/play/win.js\n+```diff\n+@@ -0,0 +1,43 @@\n++â”Š  â”Š 1â”ŠGame.Screens.Play.Win = class Win extends Engine.Layer {\n++â”Š  â”Š 2â”Š  constructor(screen, snakes, winner) {\n++â”Š  â”Š 3â”Š    super(screen);\n++â”Š  â”Š 4â”Š\n++â”Š  â”Š 5â”Š    this.snakes = snakes;\n++â”Š  â”Š 6â”Š    this.winner = winner;\n++â”Š  â”Š 7â”Š    // ttl stands for \"time to live\", which means, this layer is going to be\n++â”Š  â”Š 8â”Š    // disposed after 3 seconds\n++â”Š  â”Š 9â”Š    this.ttl = 3000;\n++â”Š  â”Š10â”Š\n++â”Š  â”Š11â”Š    // If there is a winner\n++â”Š  â”Š12â”Š    if (this.winner) {\n++â”Š  â”Š13â”Š      // Message could be something like \"RED SNAKE WINS\"\n++â”Š  â”Š14â”Š      var text = `${this.winner.color.toUpperCase()} SNAKE WINS`;\n++â”Š  â”Š15â”Š      var percent = 40;\n++â”Š  â”Š16â”Š    }\n++â”Š  â”Š17â”Š    // If there is a tie\n++â”Š  â”Š18â”Š    else {\n++â”Š  â”Š19â”Š      var text = 'TIE';\n++â”Š  â”Š20â”Š      var percent = 15;\n++â”Š  â”Š21â”Š    }\n++â”Š  â”Š22â”Š\n++â”Š  â”Š23â”Š    // Create winner sprite and set its properties\n++â”Š  â”Š24â”Š    let winnerTexture = this.assets.minecraftiaFont.createTexture(text);\n++â”Š  â”Š25â”Š    this.winnerSprite = new Engine.Sprite(winnerTexture);\n++â”Š  â”Š26â”Š    this.winnerSprite.align = \"center\";\n++â”Š  â”Š27â”Š    this.winnerSprite.setPercentage(\"width\", this.width, percent, \"height\");\n++â”Š  â”Š28â”Š    this.winnerSprite.x = this.width / 2;\n++â”Š  â”Š29â”Š    this.winnerSprite.y = this.height / 2;\n++â”Š  â”Š30â”Š  }\n++â”Š  â”Š31â”Š\n++â”Š  â”Š32â”Š  draw(context) {\n++â”Š  â”Š33â”Š    this.winnerSprite.draw(context);\n++â”Š  â”Š34â”Š  }\n++â”Š  â”Š35â”Š\n++â”Š  â”Š36â”Š  update(span) {\n++â”Š  â”Š37â”Š    // If limit not yet reached, abort\n++â”Š  â”Š38â”Š    if (this.age < this.ttl) return;\n++â”Š  â”Š39â”Š\n++â”Š  â”Š40â”Š    // Show \"ready\" message all over again, only this time use the updated score board\n++â”Š  â”Š41â”Š    this.screen.game.changeScreen(Game.Screens.Play, this.snakes);\n++â”Š  â”Š42â”Š  }\n++â”Š  â”Š43â”Š};ðŸš«â†µ\n+```\n+\n+##### Changed views/game.html\n+```diff\n+@@ -24,6 +24,7 @@\n+ â”Š24â”Š24â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n+ â”Š25â”Š25â”Š    <script type=\"text/javascript\" src=\"/scripts/game/entities/snake.js\"></script>\n+ â”Š26â”Š26â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/index.js\"></script>\n++â”Š  â”Š27â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/win.js\"></script>\n+ â”Š27â”Š28â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/score.js\"></script>\n+ â”Š28â”Š29â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/snake.js\"></script>\n+ â”Š29â”Š30â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/ready.js\"></script>\n+```\n+[}]: #\n+\n+Note how we use the `changeScreen` method once the `Win` layer has reached its age limit (Time to live, aka `ttl`); This would clear the layers stack and restart the `Play` screen, so we can start a new match all-over, only this time we will pass the `Snake` instances to reserve the original scores. The `Win` layer should be presented whenever a collision has been detected between the snakes:\n+\n+[{]: <helper> (diff_step 6.10)\n+#### Step 6.10: Hook 'Win' layer to 'Snake' layer\n+\n+##### Changed resources/scripts/game/screens/play/snake.js\n+```diff\n+@@ -76,7 +76,13 @@\n+ â”Š76â”Š76â”Š    // If this is not a tie, which is a very rare case, increase the winner's score\n+ â”Š77â”Š77â”Š    if (winner) winner.score++;\n+ â”Š78â”Š78â”Š\n+-â”Š79â”Š  â”Š    // Indicates whether we should update the score counter or not\n++â”Š  â”Š79â”Š    // Show a message saying the result (e.g., \"red snake wins\")\n++â”Š  â”Š80â”Š    this.screen.appendLayer(Game.Screens.Play.Win, snakes, winner);\n++â”Š  â”Š81â”Š\n++â”Š  â”Š82â”Š    // Indicates whether we should update the score counter or not.\n++â”Š  â”Š83â”Š    // In addition, will prevent from the 'winner' message from appearing multiple times,\n++â”Š  â”Š84â”Š    // otherwise memory is gonna be wasted despite the fact that we're not going to see\n++â”Š  â”Š85â”Š    // any visual difference\n+ â”Š80â”Š86â”Š    this.matchFinished = true;\n+ â”Š81â”Š87â”Š  }\n+ â”Š82â”Š88â”Š};ðŸš«â†µ\n+```\n+[}]: #\n+\n+That's it folks, the `Play` screen is finished, and you can play as much matches as you'd feel like.\n+\n+Although the game is finished, it can still be optimized using `C++`. To discover more on hooking efficiency and how we can hook `C++` to the browser, see the next step.\n+[}]: #\n+[{]: <region> (footer)\n+[{]: <helper> (nav_step)\n+| [< Previous Step](step5.md) | [Next Step >](step7.md) |\n+|:--------------------------------|--------------------------------:|\n+[}]: #\n+[}]: #\n\\ No newline at end of file\ndiff --git a/manuals/views/step7.md b/manuals/views/step7.md\nnew file mode 100644\nindex 0000000..a941859\n--- /dev/null\n+++ b/manuals/views/step7.md\n@@ -0,0 +1,14 @@\n+[{]: <region> (header)\n+# Step 7: Bonus! Re-implementing geometry in C++\n+[}]: #\n+[{]: <region> (body)\n+### TBA ###\n+\n+Oops! It looks that this step is not yet implemented. Stay tuned for upcoming updates.\n+[}]: #\n+[{]: <region> (footer)\n+[{]: <helper> (nav_step)\n+| [< Previous Step](step6.md) | [Next Step >](step8.md) |\n+|:--------------------------------|--------------------------------:|\n+[}]: #\n+[}]: #\n\\ No newline at end of file\ndiff --git a/manuals/views/step8.md b/manuals/views/step8.md\nnew file mode 100644\nindex 0000000..bc8bfaf\n--- /dev/null\n+++ b/manuals/views/step8.md\n@@ -0,0 +1,25 @@\n+[{]: <region> (header)\n+# Step 8: What's next?\n+[}]: #\n+[{]: <region> (body)\n+That was it y'all, hopefully you like this tutorial. Definitely a refresher when you have all these high-level frameworks out there.\n+\n+Check out my previous tutorial on how to write a native add-on to `NodeJS` using `C++`: https://github.com/DAB0mB/node-distance-addon\n+\n+Be sure to â˜…*â˜…***â˜…STARâ˜…***â˜…*â˜… this repository: https://github.com/DAB0mB/radial-snake.\n+\n+If you have any suggestions, issues, and things you'd like to ask, be sure to open an issue in the issues section: https://github.com/DAB0mB/radial-snake/issues\n+\n+For more awesome tutorials and upcoming projects, please follow me on:\n+\n+- **Github** - https://github.com/DAB0mB\n+- **Twitter** - https://twitter.com/eytan_manor\n+\n+Stay frosty 'til next time. Peace â˜®.\n+[}]: #\n+[{]: <region> (footer)\n+[{]: <helper> (nav_step)\n+| [< Previous Step](step7.md) |\n+|:----------------------|\n+[}]: #\n+[}]: #\n\\ No newline at end of file\ndiff --git a/package.json b/package.json\nnew file mode 100644\nindex 0000000..49b6e54\n--- /dev/null\n+++ b/package.json\n@@ -0,0 +1,17 @@\n+{\n+  \"name\": \"radial-snake\",\n+  \"description\": \"A tutorial for creating a Tron-style game\",\n+  \"private\": true,\n+  \"scripts\": {\n+    \"serve\": \"npm run parse:fonts && nodemon server.js\",\n+    \"parse:fonts\": \"node helpers/font_parser.js\"\n+  },\n+  \"dependencies\": {\n+    \"async\": \"^2.1.4\",\n+    \"boom\": \"^4.2.0\",\n+    \"hapi\": \"^16.0.1\",\n+    \"inert\": \"^4.0.3\",\n+    \"underscore\": \"^1.8.3\",\n+    \"xmldom\": \"^0.1.27\"\n+  }\n+}\ndiff --git a/resources/assets/fonts/minecraftia.json b/resources/assets/fonts/minecraftia.json\nnew file mode 100644\nindex 0000000..615f2b5\n--- /dev/null\n+++ b/resources/assets/fonts/minecraftia.json\n@@ -0,0 +1,1243 @@\n+{\n+  \"chars\": {\n+    \"0\": {\n+      \"rect\": {\n+        \"x\": 1,\n+        \"y\": 89,\n+        \"width\": 54,\n+        \"height\": 76\n+      },\n+      \"offset\": {\n+        \"x\": 0,\n+        \"y\": 33\n+      },\n+      \"width\": 65\n+    },\n+    \"1\": {\n+      \"rect\": {\n+        \"x\": 56,\n+        \"y\": 89,\n+        \"width\": 54,\n+        \"height\": 76\n+      },\n+      \"offset\": {\n+        \"x\": 0,\n+        \"y\": 33\n+      },\n+      \"width\": 65\n+    },\n+    \"2\": {\n+      \"rect\": {\n+        \"x\": 111,\n+        \"y\": 89,\n+        \"width\": 54,\n+        \"height\": 76\n+      },\n+      \"offset\": {\n+        \"x\": 0,\n+        \"y\": 33\n+      },\n+      \"width\": 65\n+    },\n+    \"3\": {\n+      \"rect\": {\n+        \"x\": 166,\n+        \"y\": 89,\n+        \"width\": 54,\n+        \"height\": 76\n+      },\n+      \"offset\": {\n+        \"x\": 0,\n+        \"y\": 33\n+      },\n+      \"width\": 65\n+    },\n+    \"4\": {\n+      \"rect\": {\n+        \"x\": 221,\n+        \"y\": 89,\n+        \"width\": 54,\n+        \"height\": 76\n+      },\n+      \"offset\": {\n+        \"x\": 0,\n+        \"y\": 33\n+      },\n+      \"width\": 65\n+    },\n+    \"5\": {\n+      \"rect\": {\n+        \"x\": 276,\n+        \"y\": 89,\n+        \"width\": 54,\n+        \"height\": 76\n+      },\n+      \"offset\": {\n+        \"x\": 0,\n+        \"y\": 33\n+      },\n+      \"width\": 65\n+    },\n+    \"6\": {\n+      \"rect\": {\n+        \"x\": 331,\n+        \"y\": 89,\n+        \"width\": 54,\n+        \"height\": 76\n+      },\n+      \"offset\": {\n+        \"x\": 0,\n+        \"y\": 33\n+      },\n+      \"width\": 65\n+    },\n+    \"7\": {\n+      \"rect\": {\n+        \"x\": 386,\n+        \"y\": 89,\n+        \"width\": 54,\n+        \"height\": 76\n+      },\n+      \"offset\": {\n+        \"x\": 0,\n+        \"y\": 33\n+      },\n+      \"width\": 65\n+    },\n+    \"8\": {\n+      \"rect\": {\n+        \"x\": 441,\n+        \"y\": 89,\n+        \"width\": 54,\n+        \"height\": 76\n+      },\n+      \"offset\": {\n+        \"x\": 0,\n+        \"y\": 33\n+      },\n+      \"width\": 65\n+    },\n+    \"9\": {\n+      \"rect\": {\n+        \"x\": 496,\n+        \"y\": 89,\n+        \"width\": 54,\n+        \"height\": 76\n+      },\n+      \"offset\": {\n+        \"x\": 0,\n+        \"y\": 33\n+      },\n+      \"width\": 65\n+    },\n+    \" \": {\n+      \"rect\": {\n+        \"x\": 1,\n+        \"y\": 77,\n+        \"width\": 0,\n+        \"height\": 0\n+      },\n+      \"offset\": {\n+        \"x\": 0,\n+        \"y\": 109\n+      },\n+      \"width\": 55\n+    },\n+    \"!\": {\n+      \"rect\": {\n+        \"x\": 2,\n+        \"y\": 1,\n+        \"width\": 11,\n+        \"height\": 76\n+      },\n+      \"offset\": {\n+        \"x\": 0,\n+        \"y\": 33\n+      },\n+      \"width\": 22\n+    },\n+    \"\\\"\": {\n+      \"rect\": {\n+        \"x\": 14,\n+        \"y\": 1,\n+        \"width\": 43,\n+        \"height\": 33\n+      },\n+      \"offset\": {\n+        \"x\": 0,\n+        \"y\": 33\n+      },\n+      \"width\": 54\n+    },\n+    \"#\": {\n+      \"rect\": {\n+        \"x\": 58,\n+        \"y\": 1,\n+        \"width\": 54,\n+        \"height\": 76\n+      },\n+      \"offset\": {\n+        \"x\": 0,\n+        \"y\": 33\n+      },\n+      \"width\": 65\n+    },\n+    \"$\": {\n+      \"rect\": {\n+        \"x\": 113,\n+        \"y\": 1,\n+        \"width\": 54,\n+        \"height\": 76\n+      },\n+      \"offset\": {\n+        \"x\": 0,\n+        \"y\": 33\n+      },\n+      \"width\": 65\n+    },\n+    \"%\": {\n+      \"rect\": {\n+        \"x\": 168,\n+        \"y\": 1,\n+        \"width\": 54,\n+        \"height\": 76\n+      },\n+      \"offset\": {\n+        \"x\": 0,\n+        \"y\": 33\n+      },\n+      \"width\": 65\n+    },\n+    \"&\": {\n+      \"rect\": {\n+        \"x\": 223,\n+        \"y\": 1,\n+        \"width\": 54,\n+        \"height\": 76\n+      },\n+      \"offset\": {\n+        \"x\": 0,\n+        \"y\": 33\n+      },\n+      \"width\": 65\n+    },\n+    \"'\": {\n+      \"rect\": {\n+        \"x\": 278,\n+        \"y\": 1,\n+        \"width\": 22,\n+        \"height\": 33\n+      },\n+      \"offset\": {\n+        \"x\": 0,\n+        \"y\": 33\n+      },\n+      \"width\": 33\n+    },\n+    \"(\": {\n+      \"rect\": {\n+        \"x\": 301,\n+        \"y\": 1,\n+        \"width\": 43,\n+        \"height\": 76\n+      },\n+      \"offset\": {\n+        \"x\": 0,\n+        \"y\": 33\n+      },\n+      \"width\": 54\n+    },\n+    \")\": {\n+      \"rect\": {\n+        \"x\": 345,\n+        \"y\": 1,\n+        \"width\": 43,\n+        \"height\": 76\n+      },\n+      \"offset\": {\n+        \"x\": 0,\n+        \"y\": 33\n+      },\n+      \"width\": 54\n+    },\n+    \"*\": {\n+      \"rect\": {\n+        \"x\": 389,\n+        \"y\": 23,\n+        \"width\": 43,\n+        \"height\": 33\n+      },\n+      \"offset\": {\n+        \"x\": 0,\n+        \"y\": 55\n+      },\n+      \"width\": 54\n+    },\n+    \"+\": {\n+      \"rect\": {\n+        \"x\": 433,\n+        \"y\": 12,\n+        \"width\": 54,\n+        \"height\": 54\n+      },\n+      \"offset\": {\n+        \"x\": 0,\n+        \"y\": 44\n+      },\n+      \"width\": 65\n+    },\n+    \",\": {\n+      \"rect\": {\n+        \"x\": 488,\n+        \"y\": 56,\n+        \"width\": 11,\n+        \"height\": 32\n+      },\n+      \"offset\": {\n+        \"x\": 0,\n+        \"y\": 88\n+      },\n+      \"width\": 22\n+    },\n+    \"-\": {\n+      \"rect\": {\n+        \"x\": 500,\n+        \"y\": 34,\n+        \"width\": 54,\n+        \"height\": 11\n+      },\n+      \"offset\": {\n+        \"x\": 0,\n+        \"y\": 66\n+      },\n+      \"width\": 65\n+    },\n+    \".\": {\n+      \"rect\": {\n+        \"x\": 555,\n+        \"y\": 56,\n+        \"width\": 11,\n+        \"height\": 21\n+      },\n+      \"offset\": {\n+        \"x\": 0,\n+        \"y\": 88\n+      },\n+      \"width\": 22\n+    },\n+    \"/\": {\n+      \"rect\": {\n+        \"x\": 567,\n+        \"y\": 1,\n+        \"width\": 54,\n+        \"height\": 76\n+      },\n+      \"offset\": {\n+        \"x\": 0,\n+        \"y\": 33\n+      },\n+      \"width\": 65\n+    },\n+    \":\": {\n+      \"rect\": {\n+        \"x\": 551,\n+        \"y\": 100,\n+        \"width\": 11,\n+        \"height\": 65\n+      },\n+      \"offset\": {\n+        \"x\": 0,\n+        \"y\": 44\n+      },\n+      \"width\": 22\n+    },\n+    \";\": {\n+      \"rect\": {\n+        \"x\": 563,\n+        \"y\": 101,\n+        \"width\": 11,\n+        \"height\": 75\n+      },\n+      \"offset\": {\n+        \"x\": 0,\n+        \"y\": 45\n+      },\n+      \"width\": 22\n+    },\n+    \"<\": {\n+      \"rect\": {\n+        \"x\": 575,\n+        \"y\": 89,\n+        \"width\": 43,\n+        \"height\": 76\n+      },\n+      \"offset\": {\n+        \"x\": 0,\n+        \"y\": 33\n+      },\n+      \"width\": 54\n+    },\n+    \"=\": {\n+      \"rect\": {\n+        \"x\": 1,\n+        \"y\": 199,\n+        \"width\": 54,\n+        \"height\": 44\n+      },\n+      \"offset\": {\n+        \"x\": 0,\n+        \"y\": 55\n+      },\n+      \"width\": 65\n+    },\n+    \">\": {\n+      \"rect\": {\n+        \"x\": 56,\n+        \"y\": 177,\n+        \"width\": 43,\n+        \"height\": 76\n+      },\n+      \"offset\": {\n+        \"x\": 0,\n+        \"y\": 33\n+      },\n+      \"width\": 54\n+    },\n+    \"?\": {\n+      \"rect\": {\n+        \"x\": 100,\n+        \"y\": 177,\n+        \"width\": 54,\n+        \"height\": 76\n+      },\n+      \"offset\": {\n+        \"x\": 0,\n+        \"y\": 33\n+      },\n+      \"width\": 65\n+    },\n+    \"@\": {\n+      \"rect\": {\n+        \"x\": 155,\n+        \"y\": 177,\n+        \"width\": 65,\n+        \"height\": 76\n+      },\n+      \"offset\": {\n+        \"x\": 0,\n+        \"y\": 33\n+      },\n+      \"width\": 76\n+    },\n+    \"A\": {\n+      \"rect\": {\n+        \"x\": 221,\n+        \"y\": 177,\n+        \"width\": 54,\n+        \"height\": 76\n+      },\n+      \"offset\": {\n+        \"x\": 0,\n+        \"y\": 33\n+      },\n+      \"width\": 65\n+    },\n+    \"B\": {\n+      \"rect\": {\n+        \"x\": 276,\n+        \"y\": 177,\n+        \"width\": 54,\n+        \"height\": 76\n+      },\n+      \"offset\": {\n+        \"x\": 0,\n+        \"y\": 33\n+      },\n+      \"width\": 65\n+    },\n+    \"C\": {\n+      \"rect\": {\n+        \"x\": 331,\n+        \"y\": 177,\n+        \"width\": 54,\n+        \"height\": 76\n+      },\n+      \"offset\": {\n+        \"x\": 0,\n+        \"y\": 33\n+      },\n+      \"width\": 65\n+    },\n+    \"D\": {\n+      \"rect\": {\n+        \"x\": 386,\n+        \"y\": 177,\n+        \"width\": 54,\n+        \"height\": 76\n+      },\n+      \"offset\": {\n+        \"x\": 0,\n+        \"y\": 33\n+      },\n+      \"width\": 65\n+    },\n+    \"E\": {\n+      \"rect\": {\n+        \"x\": 441,\n+        \"y\": 177,\n+        \"width\": 54,\n+        \"height\": 76\n+      },\n+      \"offset\": {\n+        \"x\": 0,\n+        \"y\": 33\n+      },\n+      \"width\": 65\n+    },\n+    \"F\": {\n+      \"rect\": {\n+        \"x\": 496,\n+        \"y\": 177,\n+        \"width\": 54,\n+        \"height\": 76\n+      },\n+      \"offset\": {\n+        \"x\": 0,\n+        \"y\": 33\n+      },\n+      \"width\": 65\n+    },\n+    \"G\": {\n+      \"rect\": {\n+        \"x\": 551,\n+        \"y\": 177,\n+        \"width\": 54,\n+        \"height\": 76\n+      },\n+      \"offset\": {\n+        \"x\": 0,\n+        \"y\": 33\n+      },\n+      \"width\": 65\n+    },\n+    \"H\": {\n+      \"rect\": {\n+        \"x\": 606,\n+        \"y\": 177,\n+        \"width\": 54,\n+        \"height\": 76\n+      },\n+      \"offset\": {\n+        \"x\": 0,\n+        \"y\": 33\n+      },\n+      \"width\": 65\n+    },\n+    \"I\": {\n+      \"rect\": {\n+        \"x\": 1,\n+        \"y\": 254,\n+        \"width\": 33,\n+        \"height\": 76\n+      },\n+      \"offset\": {\n+        \"x\": 0,\n+        \"y\": 33\n+      },\n+      \"width\": 44\n+    },\n+    \"J\": {\n+      \"rect\": {\n+        \"x\": 35,\n+        \"y\": 254,\n+        \"width\": 54,\n+        \"height\": 76\n+      },\n+      \"offset\": {\n+        \"x\": 0,\n+        \"y\": 33\n+      },\n+      \"width\": 65\n+    },\n+    \"K\": {\n+      \"rect\": {\n+        \"x\": 90,\n+        \"y\": 254,\n+        \"width\": 54,\n+        \"height\": 76\n+      },\n+      \"offset\": {\n+        \"x\": 0,\n+        \"y\": 33\n+      },\n+      \"width\": 65\n+    },\n+    \"L\": {\n+      \"rect\": {\n+        \"x\": 145,\n+        \"y\": 254,\n+        \"width\": 54,\n+        \"height\": 76\n+      },\n+      \"offset\": {\n+        \"x\": 0,\n+        \"y\": 33\n+      },\n+      \"width\": 65\n+    },\n+    \"M\": {\n+      \"rect\": {\n+        \"x\": 200,\n+        \"y\": 254,\n+        \"width\": 54,\n+        \"height\": 76\n+      },\n+      \"offset\": {\n+        \"x\": 0,\n+        \"y\": 33\n+      },\n+      \"width\": 65\n+    },\n+    \"N\": {\n+      \"rect\": {\n+        \"x\": 255,\n+        \"y\": 254,\n+        \"width\": 54,\n+        \"height\": 76\n+      },\n+      \"offset\": {\n+        \"x\": 0,\n+        \"y\": 33\n+      },\n+      \"width\": 65\n+    },\n+    \"O\": {\n+      \"rect\": {\n+        \"x\": 310,\n+        \"y\": 254,\n+        \"width\": 54,\n+        \"height\": 76\n+      },\n+      \"offset\": {\n+        \"x\": 0,\n+        \"y\": 33\n+      },\n+      \"width\": 65\n+    },\n+    \"P\": {\n+      \"rect\": {\n+        \"x\": 365,\n+        \"y\": 254,\n+        \"width\": 54,\n+        \"height\": 76\n+      },\n+      \"offset\": {\n+        \"x\": 0,\n+        \"y\": 33\n+      },\n+      \"width\": 65\n+    },\n+    \"Q\": {\n+      \"rect\": {\n+        \"x\": 420,\n+        \"y\": 254,\n+        \"width\": 54,\n+        \"height\": 76\n+      },\n+      \"offset\": {\n+        \"x\": 0,\n+        \"y\": 33\n+      },\n+      \"width\": 65\n+    },\n+    \"R\": {\n+      \"rect\": {\n+        \"x\": 475,\n+        \"y\": 254,\n+        \"width\": 54,\n+        \"height\": 76\n+      },\n+      \"offset\": {\n+        \"x\": 0,\n+        \"y\": 33\n+      },\n+      \"width\": 65\n+    },\n+    \"S\": {\n+      \"rect\": {\n+        \"x\": 530,\n+        \"y\": 254,\n+        \"width\": 54,\n+        \"height\": 76\n+      },\n+      \"offset\": {\n+        \"x\": 0,\n+        \"y\": 33\n+      },\n+      \"width\": 65\n+    },\n+    \"T\": {\n+      \"rect\": {\n+        \"x\": 585,\n+        \"y\": 254,\n+        \"width\": 54,\n+        \"height\": 76\n+      },\n+      \"offset\": {\n+        \"x\": 0,\n+        \"y\": 33\n+      },\n+      \"width\": 65\n+    },\n+    \"U\": {\n+      \"rect\": {\n+        \"x\": 1,\n+        \"y\": 331,\n+        \"width\": 54,\n+        \"height\": 76\n+      },\n+      \"offset\": {\n+        \"x\": 0,\n+        \"y\": 33\n+      },\n+      \"width\": 65\n+    },\n+    \"V\": {\n+      \"rect\": {\n+        \"x\": 56,\n+        \"y\": 331,\n+        \"width\": 54,\n+        \"height\": 76\n+      },\n+      \"offset\": {\n+        \"x\": 0,\n+        \"y\": 33\n+      },\n+      \"width\": 65\n+    },\n+    \"W\": {\n+      \"rect\": {\n+        \"x\": 111,\n+        \"y\": 331,\n+        \"width\": 54,\n+        \"height\": 76\n+      },\n+      \"offset\": {\n+        \"x\": 0,\n+        \"y\": 33\n+      },\n+      \"width\": 65\n+    },\n+    \"X\": {\n+      \"rect\": {\n+        \"x\": 166,\n+        \"y\": 331,\n+        \"width\": 54,\n+        \"height\": 76\n+      },\n+      \"offset\": {\n+        \"x\": 0,\n+        \"y\": 33\n+      },\n+      \"width\": 65\n+    },\n+    \"Y\": {\n+      \"rect\": {\n+        \"x\": 221,\n+        \"y\": 331,\n+        \"width\": 54,\n+        \"height\": 76\n+      },\n+      \"offset\": {\n+        \"x\": 0,\n+        \"y\": 33\n+      },\n+      \"width\": 65\n+    },\n+    \"Z\": {\n+      \"rect\": {\n+        \"x\": 276,\n+        \"y\": 331,\n+        \"width\": 54,\n+        \"height\": 76\n+      },\n+      \"offset\": {\n+        \"x\": 0,\n+        \"y\": 33\n+      },\n+      \"width\": 65\n+    },\n+    \"[\": {\n+      \"rect\": {\n+        \"x\": 331,\n+        \"y\": 331,\n+        \"width\": 33,\n+        \"height\": 76\n+      },\n+      \"offset\": {\n+        \"x\": 0,\n+        \"y\": 33\n+      },\n+      \"width\": 43\n+    },\n+    \"\\\\\": {\n+      \"rect\": {\n+        \"x\": 365,\n+        \"y\": 331,\n+        \"width\": 54,\n+        \"height\": 76\n+      },\n+      \"offset\": {\n+        \"x\": 0,\n+        \"y\": 33\n+      },\n+      \"width\": 65\n+    },\n+    \"]\": {\n+      \"rect\": {\n+        \"x\": 420,\n+        \"y\": 331,\n+        \"width\": 33,\n+        \"height\": 76\n+      },\n+      \"offset\": {\n+        \"x\": 0,\n+        \"y\": 33\n+      },\n+      \"width\": 44\n+    },\n+    \"^\": {\n+      \"rect\": {\n+        \"x\": 454,\n+        \"y\": 331,\n+        \"width\": 54,\n+        \"height\": 33\n+      },\n+      \"offset\": {\n+        \"x\": 0,\n+        \"y\": 33\n+      },\n+      \"width\": 65\n+    },\n+    \"_\": {\n+      \"rect\": {\n+        \"x\": 509,\n+        \"y\": 396,\n+        \"width\": 54,\n+        \"height\": 11\n+      },\n+      \"offset\": {\n+        \"x\": 0,\n+        \"y\": 98\n+      },\n+      \"width\": 65\n+    },\n+    \"`\": {\n+      \"rect\": {\n+        \"x\": 564,\n+        \"y\": 331,\n+        \"width\": 22,\n+        \"height\": 33\n+      },\n+      \"offset\": {\n+        \"x\": 0,\n+        \"y\": 33\n+      },\n+      \"width\": 33\n+    },\n+    \"a\": {\n+      \"rect\": {\n+        \"x\": 587,\n+        \"y\": 353,\n+        \"width\": 54,\n+        \"height\": 54\n+      },\n+      \"offset\": {\n+        \"x\": 0,\n+        \"y\": 55\n+      },\n+      \"width\": 65\n+    },\n+    \"b\": {\n+      \"rect\": {\n+        \"x\": 1,\n+        \"y\": 408,\n+        \"width\": 54,\n+        \"height\": 76\n+      },\n+      \"offset\": {\n+        \"x\": 0,\n+        \"y\": 33\n+      },\n+      \"width\": 65\n+    },\n+    \"c\": {\n+      \"rect\": {\n+        \"x\": 56,\n+        \"y\": 430,\n+        \"width\": 54,\n+        \"height\": 54\n+      },\n+      \"offset\": {\n+        \"x\": 0,\n+        \"y\": 55\n+      },\n+      \"width\": 65\n+    },\n+    \"d\": {\n+      \"rect\": {\n+        \"x\": 111,\n+        \"y\": 408,\n+        \"width\": 54,\n+        \"height\": 76\n+      },\n+      \"offset\": {\n+        \"x\": 0,\n+        \"y\": 33\n+      },\n+      \"width\": 65\n+    },\n+    \"e\": {\n+      \"rect\": {\n+        \"x\": 166,\n+        \"y\": 430,\n+        \"width\": 54,\n+        \"height\": 54\n+      },\n+      \"offset\": {\n+        \"x\": 0,\n+        \"y\": 55\n+      },\n+      \"width\": 65\n+    },\n+    \"f\": {\n+      \"rect\": {\n+        \"x\": 221,\n+        \"y\": 408,\n+        \"width\": 43,\n+        \"height\": 76\n+      },\n+      \"offset\": {\n+        \"x\": 0,\n+        \"y\": 33\n+      },\n+      \"width\": 54\n+    },\n+    \"g\": {\n+      \"rect\": {\n+        \"x\": 265,\n+        \"y\": 430,\n+        \"width\": 54,\n+        \"height\": 65\n+      },\n+      \"offset\": {\n+        \"x\": 0,\n+        \"y\": 55\n+      },\n+      \"width\": 65\n+    },\n+    \"h\": {\n+      \"rect\": {\n+        \"x\": 320,\n+        \"y\": 408,\n+        \"width\": 54,\n+        \"height\": 76\n+      },\n+      \"offset\": {\n+        \"x\": 0,\n+        \"y\": 33\n+      },\n+      \"width\": 65\n+    },\n+    \"i\": {\n+      \"rect\": {\n+        \"x\": 375,\n+        \"y\": 408,\n+        \"width\": 11,\n+        \"height\": 76\n+      },\n+      \"offset\": {\n+        \"x\": 0,\n+        \"y\": 33\n+      },\n+      \"width\": 22\n+    },\n+    \"j\": {\n+      \"rect\": {\n+        \"x\": 387,\n+        \"y\": 408,\n+        \"width\": 54,\n+        \"height\": 87\n+      },\n+      \"offset\": {\n+        \"x\": 0,\n+        \"y\": 33\n+      },\n+      \"width\": 65\n+    },\n+    \"k\": {\n+      \"rect\": {\n+        \"x\": 442,\n+        \"y\": 408,\n+        \"width\": 43,\n+        \"height\": 76\n+      },\n+      \"offset\": {\n+        \"x\": 0,\n+        \"y\": 33\n+      },\n+      \"width\": 54\n+    },\n+    \"l\": {\n+      \"rect\": {\n+        \"x\": 486,\n+        \"y\": 408,\n+        \"width\": 22,\n+        \"height\": 76\n+      },\n+      \"offset\": {\n+        \"x\": 0,\n+        \"y\": 33\n+      },\n+      \"width\": 33\n+    },\n+    \"m\": {\n+      \"rect\": {\n+        \"x\": 509,\n+        \"y\": 430,\n+        \"width\": 54,\n+        \"height\": 54\n+      },\n+      \"offset\": {\n+        \"x\": 0,\n+        \"y\": 55\n+      },\n+      \"width\": 65\n+    },\n+    \"n\": {\n+      \"rect\": {\n+        \"x\": 564,\n+        \"y\": 430,\n+        \"width\": 54,\n+        \"height\": 54\n+      },\n+      \"offset\": {\n+        \"x\": 0,\n+        \"y\": 55\n+      },\n+      \"width\": 65\n+    },\n+    \"o\": {\n+      \"rect\": {\n+        \"x\": 1,\n+        \"y\": 518,\n+        \"width\": 54,\n+        \"height\": 54\n+      },\n+      \"offset\": {\n+        \"x\": 0,\n+        \"y\": 55\n+      },\n+      \"width\": 65\n+    },\n+    \"p\": {\n+      \"rect\": {\n+        \"x\": 56,\n+        \"y\": 518,\n+        \"width\": 54,\n+        \"height\": 65\n+      },\n+      \"offset\": {\n+        \"x\": 0,\n+        \"y\": 55\n+      },\n+      \"width\": 65\n+    },\n+    \"q\": {\n+      \"rect\": {\n+        \"x\": 111,\n+        \"y\": 518,\n+        \"width\": 54,\n+        \"height\": 65\n+      },\n+      \"offset\": {\n+        \"x\": 0,\n+        \"y\": 55\n+      },\n+      \"width\": 65\n+    },\n+    \"r\": {\n+      \"rect\": {\n+        \"x\": 166,\n+        \"y\": 518,\n+        \"width\": 54,\n+        \"height\": 54\n+      },\n+      \"offset\": {\n+        \"x\": 0,\n+        \"y\": 55\n+      },\n+      \"width\": 65\n+    },\n+    \"s\": {\n+      \"rect\": {\n+        \"x\": 221,\n+        \"y\": 518,\n+        \"width\": 54,\n+        \"height\": 54\n+      },\n+      \"offset\": {\n+        \"x\": 0,\n+        \"y\": 55\n+      },\n+      \"width\": 65\n+    },\n+    \"t\": {\n+      \"rect\": {\n+        \"x\": 276,\n+        \"y\": 496,\n+        \"width\": 33,\n+        \"height\": 76\n+      },\n+      \"offset\": {\n+        \"x\": 0,\n+        \"y\": 33\n+      },\n+      \"width\": 44\n+    },\n+    \"u\": {\n+      \"rect\": {\n+        \"x\": 310,\n+        \"y\": 518,\n+        \"width\": 54,\n+        \"height\": 54\n+      },\n+      \"offset\": {\n+        \"x\": 0,\n+        \"y\": 55\n+      },\n+      \"width\": 65\n+    },\n+    \"v\": {\n+      \"rect\": {\n+        \"x\": 365,\n+        \"y\": 518,\n+        \"width\": 54,\n+        \"height\": 54\n+      },\n+      \"offset\": {\n+        \"x\": 0,\n+        \"y\": 55\n+      },\n+      \"width\": 65\n+    },\n+    \"w\": {\n+      \"rect\": {\n+        \"x\": 420,\n+        \"y\": 518,\n+        \"width\": 54,\n+        \"height\": 54\n+      },\n+      \"offset\": {\n+        \"x\": 0,\n+        \"y\": 55\n+      },\n+      \"width\": 65\n+    },\n+    \"x\": {\n+      \"rect\": {\n+        \"x\": 475,\n+        \"y\": 518,\n+        \"width\": 54,\n+        \"height\": 54\n+      },\n+      \"offset\": {\n+        \"x\": 0,\n+        \"y\": 55\n+      },\n+      \"width\": 65\n+    },\n+    \"y\": {\n+      \"rect\": {\n+        \"x\": 530,\n+        \"y\": 518,\n+        \"width\": 54,\n+        \"height\": 65\n+      },\n+      \"offset\": {\n+        \"x\": 0,\n+        \"y\": 55\n+      },\n+      \"width\": 65\n+    },\n+    \"z\": {\n+      \"rect\": {\n+        \"x\": 585,\n+        \"y\": 518,\n+        \"width\": 54,\n+        \"height\": 54\n+      },\n+      \"offset\": {\n+        \"x\": 0,\n+        \"y\": 55\n+      },\n+      \"width\": 65\n+    },\n+    \"{\": {\n+      \"rect\": {\n+        \"x\": 1,\n+        \"y\": 584,\n+        \"width\": 43,\n+        \"height\": 76\n+      },\n+      \"offset\": {\n+        \"x\": 0,\n+        \"y\": 33\n+      },\n+      \"width\": 54\n+    },\n+    \"|\": {\n+      \"rect\": {\n+        \"x\": 45,\n+        \"y\": 584,\n+        \"width\": 11,\n+        \"height\": 76\n+      },\n+      \"offset\": {\n+        \"x\": 0,\n+        \"y\": 33\n+      },\n+      \"width\": 22\n+    },\n+    \"}\": {\n+      \"rect\": {\n+        \"x\": 57,\n+        \"y\": 584,\n+        \"width\": 43,\n+        \"height\": 76\n+      },\n+      \"offset\": {\n+        \"x\": 0,\n+        \"y\": 33\n+      },\n+      \"width\": 54\n+    },\n+    \"~\": {\n+      \"rect\": {\n+        \"x\": 101,\n+        \"y\": 584,\n+        \"width\": 65,\n+        \"height\": 22\n+      },\n+      \"offset\": {\n+        \"x\": 0,\n+        \"y\": 33\n+      },\n+      \"width\": 76\n+    }\n+  },\n+  \"size\": 65,\n+  \"family\": \"Minecraftia\",\n+  \"height\": 130,\n+  \"style\": \"Regular\"\n+}\n\\ No newline at end of file\ndiff --git a/resources/assets/fonts/minecraftia.png b/resources/assets/fonts/minecraftia.png\nnew file mode 100644\nindex 0000000..777786b\nBinary files /dev/null and b/resources/assets/fonts/minecraftia.png differ\ndiff --git a/resources/assets/fonts/minecraftia.ttf b/resources/assets/fonts/minecraftia.ttf\nnew file mode 100644\nindex 0000000..2cf2af4\nBinary files /dev/null and b/resources/assets/fonts/minecraftia.ttf differ\ndiff --git a/resources/assets/fonts/minecraftia.xml b/resources/assets/fonts/minecraftia.xml\nnew file mode 100644\nindex 0000000..03754eb\n--- /dev/null\n+++ b/resources/assets/fonts/minecraftia.xml\n@@ -0,0 +1,98 @@\n+<?xml version=\"1.0\" encoding=\"utf-8\"?>\n+<Font size=\"65\" family=\"Minecraftia\" height=\"130\" style=\"Regular\">\n+ <Char width=\"55\" offset=\"0 109\" rect=\"1 77 0 0\" code=\" \"/>\n+ <Char width=\"22\" offset=\"0 33\" rect=\"2 1 11 76\" code=\"!\"/>\n+ <Char width=\"54\" offset=\"0 33\" rect=\"14 1 43 33\" code=\"&quot;\"/>\n+ <Char width=\"65\" offset=\"0 33\" rect=\"58 1 54 76\" code=\"#\"/>\n+ <Char width=\"65\" offset=\"0 33\" rect=\"113 1 54 76\" code=\"$\"/>\n+ <Char width=\"65\" offset=\"0 33\" rect=\"168 1 54 76\" code=\"%\"/>\n+ <Char width=\"65\" offset=\"0 33\" rect=\"223 1 54 76\" code=\"&amp;\"/>\n+ <Char width=\"33\" offset=\"0 33\" rect=\"278 1 22 33\" code=\"'\"/>\n+ <Char width=\"54\" offset=\"0 33\" rect=\"301 1 43 76\" code=\"(\"/>\n+ <Char width=\"54\" offset=\"0 33\" rect=\"345 1 43 76\" code=\")\"/>\n+ <Char width=\"54\" offset=\"0 55\" rect=\"389 23 43 33\" code=\"*\"/>\n+ <Char width=\"65\" offset=\"0 44\" rect=\"433 12 54 54\" code=\"+\"/>\n+ <Char width=\"22\" offset=\"0 88\" rect=\"488 56 11 32\" code=\",\"/>\n+ <Char width=\"65\" offset=\"0 66\" rect=\"500 34 54 11\" code=\"-\"/>\n+ <Char width=\"22\" offset=\"0 88\" rect=\"555 56 11 21\" code=\".\"/>\n+ <Char width=\"65\" offset=\"0 33\" rect=\"567 1 54 76\" code=\"/\"/>\n+ <Char width=\"65\" offset=\"0 33\" rect=\"1 89 54 76\" code=\"0\"/>\n+ <Char width=\"65\" offset=\"0 33\" rect=\"56 89 54 76\" code=\"1\"/>\n+ <Char width=\"65\" offset=\"0 33\" rect=\"111 89 54 76\" code=\"2\"/>\n+ <Char width=\"65\" offset=\"0 33\" rect=\"166 89 54 76\" code=\"3\"/>\n+ <Char width=\"65\" offset=\"0 33\" rect=\"221 89 54 76\" code=\"4\"/>\n+ <Char width=\"65\" offset=\"0 33\" rect=\"276 89 54 76\" code=\"5\"/>\n+ <Char width=\"65\" offset=\"0 33\" rect=\"331 89 54 76\" code=\"6\"/>\n+ <Char width=\"65\" offset=\"0 33\" rect=\"386 89 54 76\" code=\"7\"/>\n+ <Char width=\"65\" offset=\"0 33\" rect=\"441 89 54 76\" code=\"8\"/>\n+ <Char width=\"65\" offset=\"0 33\" rect=\"496 89 54 76\" code=\"9\"/>\n+ <Char width=\"22\" offset=\"0 44\" rect=\"551 100 11 65\" code=\":\"/>\n+ <Char width=\"22\" offset=\"0 45\" rect=\"563 101 11 75\" code=\";\"/>\n+ <Char width=\"54\" offset=\"0 33\" rect=\"575 89 43 76\" code=\"&lt;\"/>\n+ <Char width=\"65\" offset=\"0 55\" rect=\"1 199 54 44\" code=\"=\"/>\n+ <Char width=\"54\" offset=\"0 33\" rect=\"56 177 43 76\" code=\">\"/>\n+ <Char width=\"65\" offset=\"0 33\" rect=\"100 177 54 76\" code=\"?\"/>\n+ <Char width=\"76\" offset=\"0 33\" rect=\"155 177 65 76\" code=\"@\"/>\n+ <Char width=\"65\" offset=\"0 33\" rect=\"221 177 54 76\" code=\"A\"/>\n+ <Char width=\"65\" offset=\"0 33\" rect=\"276 177 54 76\" code=\"B\"/>\n+ <Char width=\"65\" offset=\"0 33\" rect=\"331 177 54 76\" code=\"C\"/>\n+ <Char width=\"65\" offset=\"0 33\" rect=\"386 177 54 76\" code=\"D\"/>\n+ <Char width=\"65\" offset=\"0 33\" rect=\"441 177 54 76\" code=\"E\"/>\n+ <Char width=\"65\" offset=\"0 33\" rect=\"496 177 54 76\" code=\"F\"/>\n+ <Char width=\"65\" offset=\"0 33\" rect=\"551 177 54 76\" code=\"G\"/>\n+ <Char width=\"65\" offset=\"0 33\" rect=\"606 177 54 76\" code=\"H\"/>\n+ <Char width=\"44\" offset=\"0 33\" rect=\"1 254 33 76\" code=\"I\"/>\n+ <Char width=\"65\" offset=\"0 33\" rect=\"35 254 54 76\" code=\"J\"/>\n+ <Char width=\"65\" offset=\"0 33\" rect=\"90 254 54 76\" code=\"K\"/>\n+ <Char width=\"65\" offset=\"0 33\" rect=\"145 254 54 76\" code=\"L\"/>\n+ <Char width=\"65\" offset=\"0 33\" rect=\"200 254 54 76\" code=\"M\"/>\n+ <Char width=\"65\" offset=\"0 33\" rect=\"255 254 54 76\" code=\"N\"/>\n+ <Char width=\"65\" offset=\"0 33\" rect=\"310 254 54 76\" code=\"O\"/>\n+ <Char width=\"65\" offset=\"0 33\" rect=\"365 254 54 76\" code=\"P\"/>\n+ <Char width=\"65\" offset=\"0 33\" rect=\"420 254 54 76\" code=\"Q\"/>\n+ <Char width=\"65\" offset=\"0 33\" rect=\"475 254 54 76\" code=\"R\"/>\n+ <Char width=\"65\" offset=\"0 33\" rect=\"530 254 54 76\" code=\"S\"/>\n+ <Char width=\"65\" offset=\"0 33\" rect=\"585 254 54 76\" code=\"T\"/>\n+ <Char width=\"65\" offset=\"0 33\" rect=\"1 331 54 76\" code=\"U\"/>\n+ <Char width=\"65\" offset=\"0 33\" rect=\"56 331 54 76\" code=\"V\"/>\n+ <Char width=\"65\" offset=\"0 33\" rect=\"111 331 54 76\" code=\"W\"/>\n+ <Char width=\"65\" offset=\"0 33\" rect=\"166 331 54 76\" code=\"X\"/>\n+ <Char width=\"65\" offset=\"0 33\" rect=\"221 331 54 76\" code=\"Y\"/>\n+ <Char width=\"65\" offset=\"0 33\" rect=\"276 331 54 76\" code=\"Z\"/>\n+ <Char width=\"43\" offset=\"0 33\" rect=\"331 331 33 76\" code=\"[\"/>\n+ <Char width=\"65\" offset=\"0 33\" rect=\"365 331 54 76\" code=\"\\\"/>\n+ <Char width=\"44\" offset=\"0 33\" rect=\"420 331 33 76\" code=\"]\"/>\n+ <Char width=\"65\" offset=\"0 33\" rect=\"454 331 54 33\" code=\"^\"/>\n+ <Char width=\"65\" offset=\"0 98\" rect=\"509 396 54 11\" code=\"_\"/>\n+ <Char width=\"33\" offset=\"0 33\" rect=\"564 331 22 33\" code=\"`\"/>\n+ <Char width=\"65\" offset=\"0 55\" rect=\"587 353 54 54\" code=\"a\"/>\n+ <Char width=\"65\" offset=\"0 33\" rect=\"1 408 54 76\" code=\"b\"/>\n+ <Char width=\"65\" offset=\"0 55\" rect=\"56 430 54 54\" code=\"c\"/>\n+ <Char width=\"65\" offset=\"0 33\" rect=\"111 408 54 76\" code=\"d\"/>\n+ <Char width=\"65\" offset=\"0 55\" rect=\"166 430 54 54\" code=\"e\"/>\n+ <Char width=\"54\" offset=\"0 33\" rect=\"221 408 43 76\" code=\"f\"/>\n+ <Char width=\"65\" offset=\"0 55\" rect=\"265 430 54 65\" code=\"g\"/>\n+ <Char width=\"65\" offset=\"0 33\" rect=\"320 408 54 76\" code=\"h\"/>\n+ <Char width=\"22\" offset=\"0 33\" rect=\"375 408 11 76\" code=\"i\"/>\n+ <Char width=\"65\" offset=\"0 33\" rect=\"387 408 54 87\" code=\"j\"/>\n+ <Char width=\"54\" offset=\"0 33\" rect=\"442 408 43 76\" code=\"k\"/>\n+ <Char width=\"33\" offset=\"0 33\" rect=\"486 408 22 76\" code=\"l\"/>\n+ <Char width=\"65\" offset=\"0 55\" rect=\"509 430 54 54\" code=\"m\"/>\n+ <Char width=\"65\" offset=\"0 55\" rect=\"564 430 54 54\" code=\"n\"/>\n+ <Char width=\"65\" offset=\"0 55\" rect=\"1 518 54 54\" code=\"o\"/>\n+ <Char width=\"65\" offset=\"0 55\" rect=\"56 518 54 65\" code=\"p\"/>\n+ <Char width=\"65\" offset=\"0 55\" rect=\"111 518 54 65\" code=\"q\"/>\n+ <Char width=\"65\" offset=\"0 55\" rect=\"166 518 54 54\" code=\"r\"/>\n+ <Char width=\"65\" offset=\"0 55\" rect=\"221 518 54 54\" code=\"s\"/>\n+ <Char width=\"44\" offset=\"0 33\" rect=\"276 496 33 76\" code=\"t\"/>\n+ <Char width=\"65\" offset=\"0 55\" rect=\"310 518 54 54\" code=\"u\"/>\n+ <Char width=\"65\" offset=\"0 55\" rect=\"365 518 54 54\" code=\"v\"/>\n+ <Char width=\"65\" offset=\"0 55\" rect=\"420 518 54 54\" code=\"w\"/>\n+ <Char width=\"65\" offset=\"0 55\" rect=\"475 518 54 54\" code=\"x\"/>\n+ <Char width=\"65\" offset=\"0 55\" rect=\"530 518 54 65\" code=\"y\"/>\n+ <Char width=\"65\" offset=\"0 55\" rect=\"585 518 54 54\" code=\"z\"/>\n+ <Char width=\"54\" offset=\"0 33\" rect=\"1 584 43 76\" code=\"{\"/>\n+ <Char width=\"22\" offset=\"0 33\" rect=\"45 584 11 76\" code=\"|\"/>\n+ <Char width=\"54\" offset=\"0 33\" rect=\"57 584 43 76\" code=\"}\"/>\n+ <Char width=\"76\" offset=\"0 33\" rect=\"101 584 65 22\" code=\"~\"/>\n+</Font>\ndiff --git a/resources/assets/textures/instructions.png b/resources/assets/textures/instructions.png\nnew file mode 100644\nindex 0000000..f8e2245\nBinary files /dev/null and b/resources/assets/textures/instructions.png differ\ndiff --git a/resources/assets/textures/logo.png b/resources/assets/textures/logo.png\nnew file mode 100644\nindex 0000000..2cd4917\nBinary files /dev/null and b/resources/assets/textures/logo.png differ\ndiff --git a/resources/assets/textures/splash.png b/resources/assets/textures/splash.png\nnew file mode 100644\nindex 0000000..563963d\nBinary files /dev/null and b/resources/assets/textures/splash.png differ\ndiff --git a/resources/libs/jasmine/boot.js b/resources/libs/jasmine/boot.js\nnew file mode 100644\nindex 0000000..65298f2\n--- /dev/null\n+++ b/resources/libs/jasmine/boot.js\n@@ -0,0 +1,181 @@\n+/**\n+ Starting with version 2.0, this file \"boots\" Jasmine, performing all of the necessary initialization before executing the loaded environment and all of a project's specs. This file should be loaded after `jasmine.js`, but before any project source files or spec files are loaded. Thus this file can also be used to customize Jasmine for a project.\n+\n+ If a project is using Jasmine via the standalone distribution, this file can be customized directly. If a project is using Jasmine via the [Ruby gem][jasmine-gem], this file can be copied into the support directory via `jasmine copy_boot_js`. Other environments (e.g., Python) will have different mechanisms.\n+\n+ The location of `boot.js` can be specified and/or overridden in `jasmine.yml`.\n+\n+ [jasmine-gem]: http://github.com/pivotal/jasmine-gem\n+ */\n+\n+(function() {\n+\n+  /**\n+   * ## Require &amp; Instantiate\n+   *\n+   * Require Jasmine's core files. Specifically, this requires and attaches all of Jasmine's code to the `jasmine` reference.\n+   */\n+  window.jasmine = jasmineRequire.core(jasmineRequire);\n+\n+  /**\n+   * Since this is being run in a browser and the results should populate to an HTML page, require the HTML-specific Jasmine code, injecting the same reference.\n+   */\n+  jasmineRequire.html(jasmine);\n+\n+  /**\n+   * Create the Jasmine environment. This is used to run all specs in a project.\n+   */\n+  var env = jasmine.getEnv();\n+\n+  /**\n+   * ## The Global Interface\n+   *\n+   * Build up the functions that will be exposed as the Jasmine public interface. A project can customize, rename or alias any of these functions as desired, provided the implementation remains unchanged.\n+   */\n+  var jasmineInterface = {\n+    describe: function(description, specDefinitions) {\n+      return env.describe(description, specDefinitions);\n+    },\n+\n+    xdescribe: function(description, specDefinitions) {\n+      return env.xdescribe(description, specDefinitions);\n+    },\n+\n+    it: function(desc, func) {\n+      return env.it(desc, func);\n+    },\n+\n+    xit: function(desc, func) {\n+      return env.xit(desc, func);\n+    },\n+\n+    beforeEach: function(beforeEachFunction) {\n+      return env.beforeEach(beforeEachFunction);\n+    },\n+\n+    afterEach: function(afterEachFunction) {\n+      return env.afterEach(afterEachFunction);\n+    },\n+\n+    expect: function(actual) {\n+      return env.expect(actual);\n+    },\n+\n+    pending: function() {\n+      return env.pending();\n+    },\n+\n+    spyOn: function(obj, methodName) {\n+      return env.spyOn(obj, methodName);\n+    },\n+\n+    jsApiReporter: new jasmine.JsApiReporter({\n+      timer: new jasmine.Timer()\n+    })\n+  };\n+\n+  /**\n+   * Add all of the Jasmine global/public interface to the proper global, so a project can use the public interface directly. For example, calling `describe` in specs instead of `jasmine.getEnv().describe`.\n+   */\n+  if (typeof window == \"undefined\" && typeof exports == \"object\") {\n+    extend(exports, jasmineInterface);\n+  } else {\n+    extend(window, jasmineInterface);\n+  }\n+\n+  /**\n+   * Expose the interface for adding custom equality testers.\n+   */\n+  jasmine.addCustomEqualityTester = function(tester) {\n+    env.addCustomEqualityTester(tester);\n+  };\n+\n+  /**\n+   * Expose the interface for adding custom expectation matchers\n+   */\n+  jasmine.addMatchers = function(matchers) {\n+    return env.addMatchers(matchers);\n+  };\n+\n+  /**\n+   * Expose the mock interface for the JavaScript timeout functions\n+   */\n+  jasmine.clock = function() {\n+    return env.clock;\n+  };\n+\n+  /**\n+   * ## Runner Parameters\n+   *\n+   * More browser specific code - wrap the query string in an object and to allow for getting/setting parameters from the runner user interface.\n+   */\n+\n+  var queryString = new jasmine.QueryString({\n+    getWindowLocation: function() { return window.location; }\n+  });\n+\n+  var catchingExceptions = queryString.getParam(\"catch\");\n+  env.catchExceptions(typeof catchingExceptions === \"undefined\" ? true : catchingExceptions);\n+\n+  /**\n+   * ## Reporters\n+   * The `HtmlReporter` builds all of the HTML UI for the runner page. This reporter paints the dots, stars, and x's for specs, as well as all spec names and all failures (if any).\n+   */\n+  var htmlReporter = new jasmine.HtmlReporter({\n+    env: env,\n+    onRaiseExceptionsClick: function() { queryString.setParam(\"catch\", !env.catchingExceptions()); },\n+    getContainer: function() { return document.body; },\n+    createElement: function() { return document.createElement.apply(document, arguments); },\n+    createTextNode: function() { return document.createTextNode.apply(document, arguments); },\n+    timer: new jasmine.Timer()\n+  });\n+\n+  /**\n+   * The `jsApiReporter` also receives spec results, and is used by any environment that needs to extract the results  from JavaScript.\n+   */\n+  env.addReporter(jasmineInterface.jsApiReporter);\n+  env.addReporter(htmlReporter);\n+\n+  /**\n+   * Filter which specs will be run by matching the start of the full name against the `spec` query param.\n+   */\n+  var specFilter = new jasmine.HtmlSpecFilter({\n+    filterString: function() { return queryString.getParam(\"spec\"); }\n+  });\n+\n+  env.specFilter = function(spec) {\n+    return specFilter.matches(spec.getFullName());\n+  };\n+\n+  /**\n+   * Setting up timing functions to be able to be overridden. Certain browsers (Safari, IE 8, phantomjs) require this hack.\n+   */\n+  window.setTimeout = window.setTimeout;\n+  window.setInterval = window.setInterval;\n+  window.clearTimeout = window.clearTimeout;\n+  window.clearInterval = window.clearInterval;\n+\n+  /**\n+   * ## Execution\n+   *\n+   * Replace the browser window's `onload`, ensure it's called, and then run all of the loaded specs. This includes initializing the `HtmlReporter` instance and then executing the loaded Jasmine environment. All of this will happen after all of the specs are loaded.\n+   */\n+  var currentWindowOnload = window.onload;\n+\n+  window.onload = function() {\n+    if (currentWindowOnload) {\n+      currentWindowOnload();\n+    }\n+    htmlReporter.initialize();\n+    env.execute();\n+  };\n+\n+  /**\n+   * Helper function for readability above.\n+   */\n+  function extend(destination, source) {\n+    for (var property in source) destination[property] = source[property];\n+    return destination;\n+  }\n+\n+}());\n\\ No newline at end of file\ndiff --git a/resources/libs/jasmine/console.js b/resources/libs/jasmine/console.js\nnew file mode 100644\nindex 0000000..8aa70af\n--- /dev/null\n+++ b/resources/libs/jasmine/console.js\n@@ -0,0 +1,165 @@\n+/*\n+Copyright (c) 2008-2014 Pivotal Labs\n+\n+Permission is hereby granted, free of charge, to any person obtaining\n+a copy of this software and associated documentation files (the\n+\"Software\"), to deal in the Software without restriction, including\n+without limitation the rights to use, copy, modify, merge, publish,\n+distribute, sublicense, and/or sell copies of the Software, and to\n+permit persons to whom the Software is furnished to do so, subject to\n+the following conditions:\n+\n+The above copyright notice and this permission notice shall be\n+included in all copies or substantial portions of the Software.\n+\n+THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n+*/\n+function getJasmineRequireObj() {\n+  if (typeof module !== 'undefined' && module.exports) {\n+    return exports;\n+  } else {\n+    window.jasmineRequire = window.jasmineRequire || {};\n+    return window.jasmineRequire;\n+  }\n+}\n+\n+getJasmineRequireObj().console = function(jRequire, j$) {\n+  j$.ConsoleReporter = jRequire.ConsoleReporter();\n+};\n+\n+getJasmineRequireObj().ConsoleReporter = function() {\n+\n+  var noopTimer = {\n+    start: function(){},\n+    elapsed: function(){ return 0; }\n+  };\n+\n+  function ConsoleReporter(options) {\n+    var print = options.print,\n+      showColors = options.showColors || false,\n+      onComplete = options.onComplete || function() {},\n+      timer = options.timer || noopTimer,\n+      specCount,\n+      failureCount,\n+      failedSpecs = [],\n+      pendingCount,\n+      ansi = {\n+        green: '\\x1B[32m',\n+        red: '\\x1B[31m',\n+        yellow: '\\x1B[33m',\n+        none: '\\x1B[0m'\n+      };\n+\n+    this.jasmineStarted = function() {\n+      specCount = 0;\n+      failureCount = 0;\n+      pendingCount = 0;\n+      print('Started');\n+      printNewline();\n+      timer.start();\n+    };\n+\n+    this.jasmineDone = function() {\n+      printNewline();\n+      for (var i = 0; i < failedSpecs.length; i++) {\n+        specFailureDetails(failedSpecs[i]);\n+      }\n+\n+      if(specCount > 0) {\n+        printNewline();\n+\n+        var specCounts = specCount + ' ' + plural('spec', specCount) + ', ' +\n+          failureCount + ' ' + plural('failure', failureCount);\n+\n+        if (pendingCount) {\n+          specCounts += ', ' + pendingCount + ' pending ' + plural('spec', pendingCount);\n+        }\n+\n+        print(specCounts);\n+      } else {\n+        print('No specs found');\n+      }\n+\n+      printNewline();\n+      var seconds = timer.elapsed() / 1000;\n+      print('Finished in ' + seconds + ' ' + plural('second', seconds));\n+\n+      printNewline();\n+\n+      onComplete(failureCount === 0);\n+    };\n+\n+    this.specDone = function(result) {\n+      specCount++;\n+\n+      if (result.status == 'pending') {\n+        pendingCount++;\n+        print(colored('yellow', '*'));\n+        return;\n+      }\n+\n+      if (result.status == 'passed') {\n+        print(colored('green', '.'));\n+        return;\n+      }\n+\n+      if (result.status == 'failed') {\n+        failureCount++;\n+        failedSpecs.push(result);\n+        print(colored('red', 'F'));\n+      }\n+    };\n+\n+    return this;\n+\n+    function printNewline() {\n+      print('\\n');\n+    }\n+\n+    function colored(color, str) {\n+      return showColors ? (ansi[color] + str + ansi.none) : str;\n+    }\n+\n+    function plural(str, count) {\n+      return count == 1 ? str : str + 's';\n+    }\n+\n+    function repeat(thing, times) {\n+      var arr = [];\n+      for (var i = 0; i < times; i++) {\n+        arr.push(thing);\n+      }\n+      return arr;\n+    }\n+\n+    function indent(str, spaces) {\n+      var lines = (str || '').split('\\n');\n+      var newArr = [];\n+      for (var i = 0; i < lines.length; i++) {\n+        newArr.push(repeat(' ', spaces).join('') + lines[i]);\n+      }\n+      return newArr.join('\\n');\n+    }\n+\n+    function specFailureDetails(result) {\n+      printNewline();\n+      print(result.fullName);\n+\n+      for (var i = 0; i < result.failedExpectations.length; i++) {\n+        var failedExpectation = result.failedExpectations[i];\n+        printNewline();\n+        print(indent(failedExpectation.stack, 2));\n+      }\n+\n+      printNewline();\n+    }\n+  }\n+\n+  return ConsoleReporter;\n+};\n\\ No newline at end of file\ndiff --git a/resources/libs/jasmine/jasmine-html.js b/resources/libs/jasmine/jasmine-html.js\nnew file mode 100644\nindex 0000000..09c268b\n--- /dev/null\n+++ b/resources/libs/jasmine/jasmine-html.js\n@@ -0,0 +1,390 @@\n+/*\n+Copyright (c) 2008-2014 Pivotal Labs\n+\n+Permission is hereby granted, free of charge, to any person obtaining\n+a copy of this software and associated documentation files (the\n+\"Software\"), to deal in the Software without restriction, including\n+without limitation the rights to use, copy, modify, merge, publish,\n+distribute, sublicense, and/or sell copies of the Software, and to\n+permit persons to whom the Software is furnished to do so, subject to\n+the following conditions:\n+\n+The above copyright notice and this permission notice shall be\n+included in all copies or substantial portions of the Software.\n+\n+THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n+*/\n+jasmineRequire.html = function(j$) {\n+  j$.ResultsNode = jasmineRequire.ResultsNode();\n+  j$.HtmlReporter = jasmineRequire.HtmlReporter(j$);\n+  j$.QueryString = jasmineRequire.QueryString();\n+  j$.HtmlSpecFilter = jasmineRequire.HtmlSpecFilter();\n+};\n+\n+jasmineRequire.HtmlReporter = function(j$) {\n+\n+  var noopTimer = {\n+    start: function() {},\n+    elapsed: function() { return 0; }\n+  };\n+\n+  function HtmlReporter(options) {\n+    var env = options.env || {},\n+      getContainer = options.getContainer,\n+      createElement = options.createElement,\n+      createTextNode = options.createTextNode,\n+      onRaiseExceptionsClick = options.onRaiseExceptionsClick || function() {},\n+      timer = options.timer || noopTimer,\n+      results = [],\n+      specsExecuted = 0,\n+      failureCount = 0,\n+      pendingSpecCount = 0,\n+      htmlReporterMain,\n+      symbols;\n+\n+    this.initialize = function() {\n+      clearPrior();\n+      htmlReporterMain = createDom('div', {className: 'jasmine_html-reporter'},\n+        createDom('div', {className: 'banner'},\n+          createDom('a', {className: 'title', href: 'http://jasmine.github.io/', target: '_blank'}),\n+          createDom('span', {className: 'version'}, j$.version)\n+        ),\n+        createDom('ul', {className: 'symbol-summary'}),\n+        createDom('div', {className: 'alert'}),\n+        createDom('div', {className: 'results'},\n+          createDom('div', {className: 'failures'})\n+        )\n+      );\n+      getContainer().appendChild(htmlReporterMain);\n+\n+      symbols = find('.symbol-summary');\n+    };\n+\n+    var totalSpecsDefined;\n+    this.jasmineStarted = function(options) {\n+      totalSpecsDefined = options.totalSpecsDefined || 0;\n+      timer.start();\n+    };\n+\n+    var summary = createDom('div', {className: 'summary'});\n+\n+    var topResults = new j$.ResultsNode({}, '', null),\n+      currentParent = topResults;\n+\n+    this.suiteStarted = function(result) {\n+      currentParent.addChild(result, 'suite');\n+      currentParent = currentParent.last();\n+    };\n+\n+    this.suiteDone = function(result) {\n+      if (currentParent == topResults) {\n+        return;\n+      }\n+\n+      currentParent = currentParent.parent;\n+    };\n+\n+    this.specStarted = function(result) {\n+      currentParent.addChild(result, 'spec');\n+    };\n+\n+    var failures = [];\n+    this.specDone = function(result) {\n+      if(noExpectations(result) && console && console.error) {\n+        console.error('Spec \\'' + result.fullName + '\\' has no expectations.');\n+      }\n+\n+      if (result.status != 'disabled') {\n+        specsExecuted++;\n+      }\n+\n+      symbols.appendChild(createDom('li', {\n+          className: noExpectations(result) ? 'empty' : result.status,\n+          id: 'spec_' + result.id,\n+          title: result.fullName\n+        }\n+      ));\n+\n+      if (result.status == 'failed') {\n+        failureCount++;\n+\n+        var failure =\n+          createDom('div', {className: 'spec-detail failed'},\n+            createDom('div', {className: 'description'},\n+              createDom('a', {title: result.fullName, href: specHref(result)}, result.fullName)\n+            ),\n+            createDom('div', {className: 'messages'})\n+          );\n+        var messages = failure.childNodes[1];\n+\n+        for (var i = 0; i < result.failedExpectations.length; i++) {\n+          var expectation = result.failedExpectations[i];\n+          messages.appendChild(createDom('div', {className: 'result-message'}, expectation.message));\n+          messages.appendChild(createDom('div', {className: 'stack-trace'}, expectation.stack));\n+        }\n+\n+        failures.push(failure);\n+      }\n+\n+      if (result.status == 'pending') {\n+        pendingSpecCount++;\n+      }\n+    };\n+\n+    this.jasmineDone = function() {\n+      var banner = find('.banner');\n+      banner.appendChild(createDom('span', {className: 'duration'}, 'finished in ' + timer.elapsed() / 1000 + 's'));\n+\n+      var alert = find('.alert');\n+\n+      alert.appendChild(createDom('span', { className: 'exceptions' },\n+        createDom('label', { className: 'label', 'for': 'raise-exceptions' }, 'raise exceptions'),\n+        createDom('input', {\n+          className: 'raise',\n+          id: 'raise-exceptions',\n+          type: 'checkbox'\n+        })\n+      ));\n+      var checkbox = find('#raise-exceptions');\n+\n+      checkbox.checked = !env.catchingExceptions();\n+      checkbox.onclick = onRaiseExceptionsClick;\n+\n+      if (specsExecuted < totalSpecsDefined) {\n+        var skippedMessage = 'Ran ' + specsExecuted + ' of ' + totalSpecsDefined + ' specs - run all';\n+        alert.appendChild(\n+          createDom('span', {className: 'bar skipped'},\n+            createDom('a', {href: '?', title: 'Run all specs'}, skippedMessage)\n+          )\n+        );\n+      }\n+      var statusBarMessage = '';\n+      var statusBarClassName = 'bar ';\n+\n+      if (totalSpecsDefined > 0) {\n+        statusBarMessage += pluralize('spec', specsExecuted) + ', ' + pluralize('failure', failureCount);\n+        if (pendingSpecCount) { statusBarMessage += ', ' + pluralize('pending spec', pendingSpecCount); }\n+        statusBarClassName += (failureCount > 0) ? 'failed' : 'passed';\n+      } else {\n+        statusBarClassName += 'skipped';\n+        statusBarMessage += 'No specs found';\n+      }\n+\n+      alert.appendChild(createDom('span', {className: statusBarClassName}, statusBarMessage));\n+\n+      var results = find('.results');\n+      results.appendChild(summary);\n+\n+      summaryList(topResults, summary);\n+\n+      function summaryList(resultsTree, domParent) {\n+        var specListNode;\n+        for (var i = 0; i < resultsTree.children.length; i++) {\n+          var resultNode = resultsTree.children[i];\n+          if (resultNode.type == 'suite') {\n+            var suiteListNode = createDom('ul', {className: 'suite', id: 'suite-' + resultNode.result.id},\n+              createDom('li', {className: 'suite-detail'},\n+                createDom('a', {href: specHref(resultNode.result)}, resultNode.result.description)\n+              )\n+            );\n+\n+            summaryList(resultNode, suiteListNode);\n+            domParent.appendChild(suiteListNode);\n+          }\n+          if (resultNode.type == 'spec') {\n+            if (domParent.getAttribute('class') != 'specs') {\n+              specListNode = createDom('ul', {className: 'specs'});\n+              domParent.appendChild(specListNode);\n+            }\n+            var specDescription = resultNode.result.description;\n+            if(noExpectations(resultNode.result)) {\n+              specDescription = 'SPEC HAS NO EXPECTATIONS ' + specDescription;\n+            }\n+            specListNode.appendChild(\n+              createDom('li', {\n+                  className: resultNode.result.status,\n+                  id: 'spec-' + resultNode.result.id\n+                },\n+                createDom('a', {href: specHref(resultNode.result)}, specDescription)\n+              )\n+            );\n+          }\n+        }\n+      }\n+\n+      if (failures.length) {\n+        alert.appendChild(\n+          createDom('span', {className: 'menu bar spec-list'},\n+            createDom('span', {}, 'Spec List | '),\n+            createDom('a', {className: 'failures-menu', href: '#'}, 'Failures')));\n+        alert.appendChild(\n+          createDom('span', {className: 'menu bar failure-list'},\n+            createDom('a', {className: 'spec-list-menu', href: '#'}, 'Spec List'),\n+            createDom('span', {}, ' | Failures ')));\n+\n+        find('.failures-menu').onclick = function() {\n+          setMenuModeTo('failure-list');\n+        };\n+        find('.spec-list-menu').onclick = function() {\n+          setMenuModeTo('spec-list');\n+        };\n+\n+        setMenuModeTo('failure-list');\n+\n+        var failureNode = find('.failures');\n+        for (var i = 0; i < failures.length; i++) {\n+          failureNode.appendChild(failures[i]);\n+        }\n+      }\n+    };\n+\n+    return this;\n+\n+    function find(selector) {\n+      return getContainer().querySelector('.jasmine_html-reporter ' + selector);\n+    }\n+\n+    function clearPrior() {\n+      // return the reporter\n+      var oldReporter = find('');\n+      \n+      if(oldReporter) {\n+        getContainer().removeChild(oldReporter);\n+      }\n+    }\n+\n+    function createDom(type, attrs, childrenVarArgs) {\n+      var el = createElement(type);\n+\n+      for (var i = 2; i < arguments.length; i++) {\n+        var child = arguments[i];\n+\n+        if (typeof child === 'string') {\n+          el.appendChild(createTextNode(child));\n+        } else {\n+          if (child) {\n+            el.appendChild(child);\n+          }\n+        }\n+      }\n+\n+      for (var attr in attrs) {\n+        if (attr == 'className') {\n+          el[attr] = attrs[attr];\n+        } else {\n+          el.setAttribute(attr, attrs[attr]);\n+        }\n+      }\n+\n+      return el;\n+    }\n+\n+    function pluralize(singular, count) {\n+      var word = (count == 1 ? singular : singular + 's');\n+\n+      return '' + count + ' ' + word;\n+    }\n+\n+    function specHref(result) {\n+      return '?spec=' + encodeURIComponent(result.fullName);\n+    }\n+\n+    function setMenuModeTo(mode) {\n+      htmlReporterMain.setAttribute('class', 'jasmine_html-reporter ' + mode);\n+    }\n+\n+    function noExpectations(result) {\n+      return (result.failedExpectations.length + result.passedExpectations.length) === 0 &&\n+        result.status === 'passed';\n+    }\n+  }\n+\n+  return HtmlReporter;\n+};\n+\n+jasmineRequire.HtmlSpecFilter = function() {\n+  function HtmlSpecFilter(options) {\n+    var filterString = options && options.filterString() && options.filterString().replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n+    var filterPattern = new RegExp(filterString);\n+\n+    this.matches = function(specName) {\n+      return filterPattern.test(specName);\n+    };\n+  }\n+\n+  return HtmlSpecFilter;\n+};\n+\n+jasmineRequire.ResultsNode = function() {\n+  function ResultsNode(result, type, parent) {\n+    this.result = result;\n+    this.type = type;\n+    this.parent = parent;\n+\n+    this.children = [];\n+\n+    this.addChild = function(result, type) {\n+      this.children.push(new ResultsNode(result, type, this));\n+    };\n+\n+    this.last = function() {\n+      return this.children[this.children.length - 1];\n+    };\n+  }\n+\n+  return ResultsNode;\n+};\n+\n+jasmineRequire.QueryString = function() {\n+  function QueryString(options) {\n+\n+    this.setParam = function(key, value) {\n+      var paramMap = queryStringToParamMap();\n+      paramMap[key] = value;\n+      options.getWindowLocation().search = toQueryString(paramMap);\n+    };\n+\n+    this.getParam = function(key) {\n+      return queryStringToParamMap()[key];\n+    };\n+\n+    return this;\n+\n+    function toQueryString(paramMap) {\n+      var qStrPairs = [];\n+      for (var prop in paramMap) {\n+        qStrPairs.push(encodeURIComponent(prop) + '=' + encodeURIComponent(paramMap[prop]));\n+      }\n+      return '?' + qStrPairs.join('&');\n+    }\n+\n+    function queryStringToParamMap() {\n+      var paramStr = options.getWindowLocation().search.substring(1),\n+        params = [],\n+        paramMap = {};\n+\n+      if (paramStr.length > 0) {\n+        params = paramStr.split('&');\n+        for (var i = 0; i < params.length; i++) {\n+          var p = params[i].split('=');\n+          var value = decodeURIComponent(p[1]);\n+          if (value === 'true' || value === 'false') {\n+            value = JSON.parse(value);\n+          }\n+          paramMap[decodeURIComponent(p[0])] = value;\n+        }\n+      }\n+\n+      return paramMap;\n+    }\n+\n+  }\n+\n+  return QueryString;\n+};\n\\ No newline at end of file\ndiff --git a/resources/libs/jasmine/jasmine.css b/resources/libs/jasmine/jasmine.css\nnew file mode 100644\nindex 0000000..6d0c106\n--- /dev/null\n+++ b/resources/libs/jasmine/jasmine.css\n@@ -0,0 +1,59 @@\n+body { overflow-y: scroll; }\n+\n+.jasmine_html-reporter { background-color: #eeeeee; padding: 5px; margin: -8px; font-size: 11px; font-family: Monaco, \"Lucida Console\", monospace; line-height: 14px; color: #333333; }\n+.jasmine_html-reporter a { text-decoration: none; }\n+.jasmine_html-reporter a:hover { text-decoration: underline; }\n+.jasmine_html-reporter p, .jasmine_html-reporter h1, .jasmine_html-reporter h2, .jasmine_html-reporter h3, .jasmine_html-reporter h4, .jasmine_html-reporter h5, .jasmine_html-reporter h6 { margin: 0; line-height: 14px; }\n+.jasmine_html-reporter .banner, .jasmine_html-reporter .symbol-summary, .jasmine_html-reporter .summary, .jasmine_html-reporter .result-message, .jasmine_html-reporter .spec .description, .jasmine_html-reporter .spec-detail .description, .jasmine_html-reporter .alert .bar, .jasmine_html-reporter .stack-trace { padding-left: 9px; padding-right: 9px; }\n+.jasmine_html-reporter .banner { position: relative; }\n+.jasmine_html-reporter .banner .title { background: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAAAZCAMAAACGusnyAAACdlBMVEX/////AP+AgICqVaqAQICZM5mAVYCSSZKAQICOOY6ATYCLRouAQICJO4mSSYCIRIiPQICHPIeOR4CGQ4aMQICGPYaLRoCFQ4WKQICPPYWJRYCOQoSJQICNPoSIRICMQoSHQICHRICKQoOHQICKPoOJO4OJQYOMQICMQ4CIQYKLQICIPoKLQ4CKQICNPoKJQISMQ4KJQoSLQYKJQISLQ4KIQoSKQYKIQICIQISMQoSKQYKLQIOLQoOJQYGLQIOKQIOMQoGKQYOLQYGKQIOLQoGJQYOJQIOKQYGJQIOKQoGKQIGLQIKLQ4KKQoGLQYKJQIGKQYKJQIGKQIKJQoGKQYKLQIGKQYKLQIOJQoKKQoOJQYKKQIOJQoKKQoOKQIOLQoKKQYOLQYKJQIOKQoKKQYKKQoKJQYOKQYKLQIOKQoKLQYOKQYKLQIOJQoGKQYKJQYGJQoGKQYKLQoGLQYGKQoGJQYKKQYGJQIKKQoGJQYKLQIKKQYGLQYKKQYGKQYGKQYKJQYOKQoKJQYOKQYKLQYOLQYOKQYKLQYOKQoKKQYKKQYOKQYOJQYKKQYKLQYKKQIKKQoKKQYKKQYKKQoKJQIKKQYKLQYKKQYKKQIKKQYKKQYKKQYKKQIKKQYKJQYGLQYGKQYKKQYKKQYGKQIKKQYGKQYOJQoKKQYOLQYKKQYOKQoKKQYKKQoKKQYKKQYKJQYKLQYKKQYKKQYKKQYKKQYKKQYKKQYKKQYKKQYKJQYKKQYKKQYKKQYKKQYKKQYKKQYKKQYKKQYKKQYKKQYKKQYKLQYKKQYKKQYKKQYKKQYKKQYKKQYKKQYKKQYKKQYKKQYKKQYKKQYKmIDpEAAAA0XRSTlMAAQIDBAUGBwgJCgsMDQ4PEBESExQVFhcYGRobHB0eHyAiIyQlJycoKissLS4wMTQ1Njc4OTo7PDw+P0BCQ0RISUpLTE1OUFNUVVdYWFlaW15fYGFiY2ZnaGlqa2xtb3BxcnN0dnh5ent8fX5/gIGChIWIioyNjo+QkZOUlZaYmZqbnJ2eoKGio6WmqKmsra6vsLGztre4ubq7vL2+wMHDxMjJysvNzs/Q0dLU1tfY2dvc3t/g4eLj5ebn6Onq6+zt7u/w8vP09fb3+Pn6+/z9/vkVQXAAAAMaSURBVHhe5dXxV1N1GMfxz2ABbDgIAm5VDJOyVDIJLUMaVpBWUZUaGbmqoGpZRSiGiRWp6KoZ5AB0ZY50RImZQIlahKkMYXv/R90dBvET/rJfOr3Ouc8v99zPec59zvf56j+vYKlViSf7250X4Mr3O29Tgq08BdGB4DhcekEJ5YkQKFsgWZdtj9JpV+I8xPjLFqkrsEIqO8PHSpis36jWazcqjEsfJjkvRssVU37SdIOu4XCf5vEJPsnwJpnRNU9JmxhMk8l1gehIrq7hTFjzOD+Vf88629qKMJVNltInFeRexRQyJlNeqd1iGDlSzrIUIyXbyFfm3RYprcQRe7lqtWyGYbfc6dT0R2vmdOOkX3u55C1rP37ftiH+tDby4r/RBT0w8TyEkr+epB9XgPDmSYYWbrhCuFYaIyw3fDQAXTnSkh+ANofiHmWf9l+FY1I90FdQTetstO00o23novzVsJ7uB3/C5TkbjRwZ5JerwV4iRWq9HFbFMaK/d0TYqayRiQPuIxxS3Bu8JWU90/60tKi7vkhaznez0a/TbVOKj5CaOZh6fWG6/Lyv9B/ZLR1gw/S/fpbeVD3MCW1li6SvWDOn65tr99/uvWtBS0XDm4s1t+sOHpG0kpBKx/l77wOSnxLpcx6TXmXLTPQOKYOf9Q1dfr8/SJ2mFdCvl1Yl93DiHUZvXeLJbGSzYu5gVJ2slbSakOR8dxCq5adQ2oFLqsE9Ex3L4qQO0eOPeU5x56bypXp4onSEb5OkICX6lDat55TeoztNKQcJaakrz9KCb95oD69IKq+yKW4XPjknaS52V0TZqE2cTtXjcHSCRmUO88e+85hj3EP74i9p8pylw7lxgMDyyl6OV7ZejnjNMfatu87LxRbH0IS35gt2a4ZjmGpVBdKK3Wr6INk8jWWSGqbA55CKgjBRC6E9w78ydTg3ABS3AFV1QN0Y4Aa2pgEjWnQURj9L0ayK6R2ysEqxHUKzYnLvvyU+i9KM2JHJzE4vyZOyDcOwOsySajeLPc8sNvPJkFlyJd20wpqAzZeAfZ3oWybxd+P/3j+SG3uSBdf2VQAAAABJRU5ErkJggg==') no-repeat; background: url('data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgoKPHN2ZwogICB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iCiAgIHhtbG5zOmNjPSJodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9ucyMiCiAgIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyIKICAgeG1sbnM6c3ZnPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIKICAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxuczppbmtzY2FwZT0iaHR0cDovL3d3dy5pbmtzY2FwZS5vcmcvbmFtZXNwYWNlcy9pbmtzY2FwZSIKICAgdmVyc2lvbj0iMS4xIgogICB3aWR0aD0iNjgxLjk2MjUyIgogICBoZWlnaHQ9IjE4Ny41IgogICBpZD0ic3ZnMiIKICAgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+PG1ldGFkYXRhCiAgICAgaWQ9Im1ldGFkYXRhOCI+PHJkZjpSREY+PGNjOldvcmsKICAgICAgICAgcmRmOmFib3V0PSIiPjxkYzpmb3JtYXQ+aW1hZ2Uvc3ZnK3htbDwvZGM6Zm9ybWF0PjxkYzp0eXBlCiAgICAgICAgICAgcmRmOnJlc291cmNlPSJodHRwOi8vcHVybC5vcmcvZGMvZGNtaXR5cGUvU3RpbGxJbWFnZSIgLz48L2NjOldvcms+PC9yZGY6UkRGPjwvbWV0YWRhdGE+PGRlZnMKICAgICBpZD0iZGVmczYiPjxjbGlwUGF0aAogICAgICAgaWQ9ImNsaXBQYXRoMTgiPjxwYXRoCiAgICAgICAgIGQ9Ik0gMCwxNTAwIDAsMCBsIDU0NTUuNzQsMCAwLDE1MDAgTCAwLDE1MDAgeiIKICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgaWQ9InBhdGgyMCIgLz48L2NsaXBQYXRoPjwvZGVmcz48ZwogICAgIHRyYW5zZm9ybT0ibWF0cml4KDEuMjUsMCwwLC0xLjI1LDAsMTg3LjUpIgogICAgIGlkPSJnMTAiPjxnCiAgICAgICB0cmFuc2Zvcm09InNjYWxlKDAuMSwwLjEpIgogICAgICAgaWQ9ImcxMiI+PGcKICAgICAgICAgaWQ9ImcxNCI+PGcKICAgICAgICAgICBjbGlwLXBhdGg9InVybCgjY2xpcFBhdGgxOCkiCiAgICAgICAgICAgaWQ9ImcxNiI+PHBhdGgKICAgICAgICAgICAgIGQ9Im0gMTU0NCw1OTkuNDM0IGMgMC45MiwtNDAuMzUyIDI1LjY4LC04MS42MDIgNzEuNTMsLTgxLjYwMiAyNy41MSwwIDQ3LjY4LDEyLjgzMiA2MS40NCwzNS43NTQgMTIuODMsMjIuOTMgMTIuODMsNTYuODUyIDEyLjgzLDgyLjUyNyBsIDAsMzI5LjE4NCAtNzEuNTIsMCAwLDEwNC41NDMgMjY2LjgzLDAgMCwtMTA0LjU0MyAtNzAuNiwwIDAsLTM0NC43NyBjIDAsLTU4LjY5MSAtMy42OCwtMTA0LjUzMSAtNDQuOTMsLTE1Mi4yMTggLTM2LjY4LC00Mi4xOCAtOTYuMjgsLTY2LjAyIC0xNTMuMTQsLTY2LjAyIC0xMTcuMzcsMCAtMjA3LjI0LDc3Ljk0MSAtMjAyLjY0LDE5Ny4xNDUgbCAxMzAuMiwwIgogICAgICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgICAgIGlkPSJwYXRoMjIiCiAgICAgICAgICAgICBzdHlsZT0iZmlsbDojOGE0MTgyO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIiAvPjxwYXRoCiAgICAgICAgICAgICBkPSJtIDIzMDEuNCw2NjIuNjk1IGMgMCw4MC43MDMgLTY2Ljk0LDE0NS44MTMgLTE0Ny42MywxNDUuODEzIC04My40NCwwIC0xNDcuNjMsLTY4Ljc4MSAtMTQ3LjYzLC0xNTEuMzAxIDAsLTc5Ljc4NSA2Ni45NCwtMTQ1LjgwMSAxNDUuOCwtMTQ1LjgwMSA4NC4zNSwwIDE0OS40Niw2Ny44NTIgMTQ5LjQ2LDE1MS4yODkgeiBtIC0xLjgzLC0xODEuNTQ3IGMgLTM1Ljc3LC01NC4wOTcgLTkzLjUzLC03OC44NTkgLTE1Ny43MiwtNzguODU5IC0xNDAuMywwIC0yNTEuMjQsMTE2LjQ0OSAtMjUxLjI0LDI1NC45MTggMCwxNDIuMTI5IDExMy43LDI2MC40MSAyNTYuNzQsMjYwLjQxIDYzLjI3LDAgMTE4LjI5LC0yOS4zMzYgMTUyLjIyLC04Mi41MjMgbCAwLDY5LjY4NyAxNzUuMTQsMCAwLC0xMDQuNTI3IC02MS40NCwwIDAsLTI4MC41OTggNjEuNDQsMCAwLC0xMDQuNTI3IC0xNzUuMTQsMCAwLDY2LjAxOSIKICAgICAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgICAgICBpZD0icGF0aDI0IgogICAgICAgICAgICAgc3R5bGU9ImZpbGw6IzhhNDE4MjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIgLz48cGF0aAogICAgICAgICAgICAgZD0ibSAyNjIyLjMzLDU1Ny4yNTggYyAzLjY3LC00NC4wMTYgMzMuMDEsLTczLjM0OCA3OC44NiwtNzMuMzQ4IDMzLjkzLDAgNjYuOTMsMjMuODI0IDY2LjkzLDYwLjUwNCAwLDQ4LjYwNiAtNDUuODQsNTYuODU2IC04My40NCw2Ni45NDEgLTg1LjI4LDIyLjAwNCAtMTc4LjgxLDQ4LjYwNiAtMTc4LjgxLDE1NS44NzkgMCw5My41MzYgNzguODYsMTQ3LjYzMyAxNjUuOTgsMTQ3LjYzMyA0NCwwIDgzLjQzLC05LjE3NiAxMTAuOTQsLTQ0LjAwOCBsIDAsMzMuOTIyIDgyLjUzLDAgMCwtMTMyLjk2NSAtMTA4LjIxLDAgYyAtMS44MywzNC44NTYgLTI4LjQyLDU3Ljc3NCAtNjMuMjYsNTcuNzc0IC0zMC4yNiwwIC02Mi4zNSwtMTcuNDIyIC02Mi4zNSwtNTEuMzQ4IDAsLTQ1Ljg0NyA0NC45MywtNTUuOTMgODAuNjksLTY0LjE4IDg4LjAyLC0yMC4xNzUgMTgyLjQ3LC00Ny42OTUgMTgyLjQ3LC0xNTcuNzM0IDAsLTk5LjAyNyAtODMuNDQsLTE1NC4wMzkgLTE3NS4xMywtMTU0LjAzOSAtNDkuNTMsMCAtOTQuNDYsMTUuNTgyIC0xMjYuNTUsNTMuMTggbCAwLC00MC4zNCAtODUuMjcsMCAwLDE0Mi4xMjkgMTE0LjYyLDAiCiAgICAgICAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIgogICAgICAgICAgICAgaWQ9InBhdGgyNiIKICAgICAgICAgICAgIHN0eWxlPSJmaWxsOiM4YTQxODI7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiIC8+PHBhdGgKICAgICAgICAgICAgIGQ9Im0gMjk4OC4xOCw4MDAuMjU0IC02My4yNiwwIDAsMTA0LjUyNyAxNjUuMDUsMCAwLC03My4zNTUgYyAzMS4xOCw1MS4zNDcgNzguODYsODUuMjc3IDE0MS4yMSw4NS4yNzcgNjcuODUsMCAxMjQuNzEsLTQxLjI1OCAxNTIuMjEsLTEwMi42OTkgMjYuNiw2Mi4zNTEgOTIuNjIsMTAyLjY5OSAxNjAuNDcsMTAyLjY5OSA1My4xOSwwIDEwNS40NiwtMjIgMTQxLjIxLC02Mi4zNTEgMzguNTIsLTQ0LjkzOCAzOC41MiwtOTMuNTMyIDM4LjUyLC0xNDkuNDU3IGwgMCwtMTg1LjIzOSA2My4yNywwIDAsLTEwNC41MjcgLTIzOC40MiwwIDAsMTA0LjUyNyA2My4yOCwwIDAsMTU3LjcxNSBjIDAsMzIuMTAyIDAsNjAuNTI3IC0xNC42Nyw4OC45NTcgLTE4LjM0LDI2LjU4MiAtNDguNjEsNDAuMzQ0IC03OS43Nyw0MC4zNDQgLTMwLjI2LDAgLTYzLjI4LC0xMi44NDQgLTgyLjUzLC0zNi42NzIgLTIyLjkzLC0yOS4zNTUgLTIyLjkzLC01Ni44NjMgLTIyLjkzLC05Mi42MjkgbCAwLC0xNTcuNzE1IDYzLjI3LDAgMCwtMTA0LjUyNyAtMjM4LjQxLDAgMCwxMDQuNTI3IDYzLjI4LDAgMCwxNTAuMzgzIGMgMCwyOS4zNDggMCw2Ni4wMjMgLTE0LjY3LDkxLjY5OSAtMTUuNTksMjkuMzM2IC00Ny42OSw0NC45MzQgLTgwLjcsNDQuOTM0IC0zMS4xOCwwIC01Ny43NywtMTEuMDA4IC03Ny45NCwtMzUuNzc0IC0yNC43NywtMzAuMjUzIC0yNi42LC02Mi4zNDMgLTI2LjYsLTk5Ljk0MSBsIDAsLTE1MS4zMDEgNjMuMjcsMCAwLC0xMDQuNTI3IC0yMzguNCwwIDAsMTA0LjUyNyA2My4yNiwwIDAsMjgwLjU5OCIKICAgICAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgICAgICBpZD0icGF0aDI4IgogICAgICAgICAgICAgc3R5bGU9ImZpbGw6IzhhNDE4MjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIgLz48cGF0aAogICAgICAgICAgICAgZD0ibSAzOTk4LjY2LDk1MS41NDcgLTExMS44NywwIDAsMTE4LjI5MyAxMTEuODcsMCAwLC0xMTguMjkzIHogbSAwLC00MzEuODkxIDYzLjI3LDAgMCwtMTA0LjUyNyAtMjM5LjMzLDAgMCwxMDQuNTI3IDY0LjE5LDAgMCwyODAuNTk4IC02My4yNywwIDAsMTA0LjUyNyAxNzUuMTQsMCAwLC0zODUuMTI1IgogICAgICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgICAgIGlkPSJwYXRoMzAiCiAgICAgICAgICAgICBzdHlsZT0iZmlsbDojOGE0MTgyO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIiAvPjxwYXRoCiAgICAgICAgICAgICBkPSJtIDQxNTkuMTIsODAwLjI1NCAtNjMuMjcsMCAwLDEwNC41MjcgMTc1LjE0LDAgMCwtNjkuNjg3IGMgMjkuMzUsNTQuMTAxIDg0LjM2LDgwLjY5OSAxNDQuODcsODAuNjk5IDUzLjE5LDAgMTA1LjQ1LC0yMi4wMTYgMTQxLjIyLC02MC41MjcgNDAuMzQsLTQ0LjkzNCA0MS4yNiwtODguMDMyIDQxLjI2LC0xNDMuOTU3IGwgMCwtMTkxLjY1MyA2My4yNywwIDAsLTEwNC41MjcgLTIzOC40LDAgMCwxMDQuNTI3IDYzLjI2LDAgMCwxNTguNjM3IGMgMCwzMC4yNjIgMCw2MS40MzQgLTE5LjI2LDg4LjAzNSAtMjAuMTcsMjYuNTgyIC01My4xOCwzOS40MTQgLTg2LjE5LDM5LjQxNCAtMzMuOTMsMCAtNjguNzcsLTEzLjc1IC04OC45NCwtNDEuMjUgLTIxLjA5LC0yNy41IC0yMS4wOSwtNjkuNjg3IC0yMS4wOSwtMTAyLjcwNyBsIDAsLTE0Mi4xMjkgNjMuMjYsMCAwLC0xMDQuNTI3IC0yMzguNCwwIDAsMTA0LjUyNyA2My4yNywwIDAsMjgwLjU5OCIKICAgICAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgICAgICBpZD0icGF0aDMyIgogICAgICAgICAgICAgc3R5bGU9ImZpbGw6IzhhNDE4MjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIgLz48cGF0aAogICAgICAgICAgICAgZD0ibSA1MDgyLjQ4LDcwMy45NjUgYyAtMTkuMjQsNzAuNjA1IC04MS42LDExNS41NDcgLTE1NC4wNCwxMTUuNTQ3IC02Ni4wNCwwIC0xMjkuMywtNTEuMzQ4IC0xNDMuMDUsLTExNS41NDcgbCAyOTcuMDksMCB6IG0gODUuMjcsLTE0NC44ODMgYyAtMzguNTEsLTkzLjUyMyAtMTI5LjI3LC0xNTYuNzkzIC0yMzEuMDUsLTE1Ni43OTMgLTE0My4wNywwIC0yNTcuNjgsMTExLjg3MSAtMjU3LjY4LDI1NS44MzYgMCwxNDQuODgzIDEwOS4xMiwyNjEuMzI4IDI1NC45MSwyNjEuMzI4IDY3Ljg3LDAgMTM1LjcyLC0zMC4yNTggMTgzLjM5LC03OC44NjMgNDguNjIsLTUxLjM0NCA2OC43OSwtMTEzLjY5NSA2OC43OSwtMTgzLjM4MyBsIC0zLjY3LC0zOS40MzQgLTM5Ni4xMywwIGMgMTQuNjcsLTY3Ljg2MyA3Ny4wMywtMTE3LjM2MyAxNDYuNzIsLTExNy4zNjMgNDguNTksMCA5MC43NiwxOC4zMjggMTE4LjI4LDU4LjY3MiBsIDExNi40NCwwIgogICAgICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgICAgIGlkPSJwYXRoMzQiCiAgICAgICAgICAgICBzdHlsZT0iZmlsbDojOGE0MTgyO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIiAvPjxwYXRoCiAgICAgICAgICAgICBkPSJtIDY5MC44OTUsODUwLjcwMyA5MC43NSwwIDIyLjU0MywzMS4wMzUgMCwyNDMuMTIyIC0xMzUuODI5LDAgMCwtMjQzLjE0MSAyMi41MzYsLTMxLjAxNiIKICAgICAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgICAgICBpZD0icGF0aDM2IgogICAgICAgICAgICAgc3R5bGU9ImZpbGw6IzhhNDE4MjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIgLz48cGF0aAogICAgICAgICAgICAgZD0ibSA2MzIuMzk1LDc0Mi4yNTggMjguMDM5LDg2LjMwNCAtMjIuNTUxLDMxLjA0IC0yMzEuMjIzLDc1LjEyOCAtNDEuOTc2LC0xMjkuMTgzIDIzMS4yNTcsLTc1LjEzNyAzNi40NTQsMTEuODQ4IgogICAgICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgICAgIGlkPSJwYXRoMzgiCiAgICAgICAgICAgICBzdHlsZT0iZmlsbDojOGE0MTgyO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIiAvPjxwYXRoCiAgICAgICAgICAgICBkPSJtIDcxNy40NDksNjUzLjEwNSAtNzMuNDEsNTMuMzYgLTM2LjQ4OCwtMTEuODc1IC0xNDIuOTAzLC0xOTYuNjkyIDEwOS44ODMsLTc5LjgyOCAxNDIuOTE4LDE5Ni43MDMgMCwzOC4zMzIiCiAgICAgICAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIgogICAgICAgICAgICAgaWQ9InBhdGg0MCIKICAgICAgICAgICAgIHN0eWxlPSJmaWxsOiM4YTQxODI7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiIC8+PHBhdGgKICAgICAgICAgICAgIGQ9Im0gODI4LjUyLDcwNi40NjUgLTczLjQyNiwtNTMuMzQgMC4wMTEsLTM4LjM1OSBMIDg5OC4wMDQsNDE4LjA3IDEwMDcuOSw0OTcuODk4IDg2NC45NzMsNjk0LjYwOSA4MjguNTIsNzA2LjQ2NSIKICAgICAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgICAgICBpZD0icGF0aDQyIgogICAgICAgICAgICAgc3R5bGU9ImZpbGw6IzhhNDE4MjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIgLz48cGF0aAogICAgICAgICAgICAgZD0ibSA4MTIuMDg2LDgyOC41ODYgMjguMDU1LC04Ni4zMiAzNi40ODQsLTExLjgzNiAyMzEuMjI1LDc1LjExNyAtNDEuOTcsMTI5LjE4MyAtMjMxLjIzOSwtNzUuMTQgLTIyLjU1NSwtMzEuMDA0IgogICAgICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgICAgIGlkPSJwYXRoNDQiCiAgICAgICAgICAgICBzdHlsZT0iZmlsbDojOGE0MTgyO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIiAvPjxwYXRoCiAgICAgICAgICAgICBkPSJtIDczNi4zMDEsMTMzNS44OCBjIC0zMjMuMDQ3LDAgLTU4NS44NzUsLTI2Mi43OCAtNTg1Ljg3NSwtNTg1Ljc4MiAwLC0zMjMuMTE4IDI2Mi44MjgsLTU4NS45NzcgNTg1Ljg3NSwtNTg1Ljk3NyAzMjMuMDE5LDAgNTg1LjgwOSwyNjIuODU5IDU4NS44MDksNTg1Ljk3NyAwLDMyMy4wMDIgLTI2Mi43OSw1ODUuNzgyIC01ODUuODA5LDU4NS43ODIgbCAwLDAgeiBtIDAsLTExOC42MSBjIDI1Ny45NzIsMCA0NjcuMTg5LC0yMDkuMTMgNDY3LjE4OSwtNDY3LjE3MiAwLC0yNTguMTI5IC0yMDkuMjE3LC00NjcuMzQ4IC00NjcuMTg5LC00NjcuMzQ4IC0yNTguMDc0LDAgLTQ2Ny4yNTQsMjA5LjIxOSAtNDY3LjI1NCw0NjcuMzQ4IDAsMjU4LjA0MiAyMDkuMTgsNDY3LjE3MiA0NjcuMjU0LDQ2Ny4xNzIiCiAgICAgICAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIgogICAgICAgICAgICAgaWQ9InBhdGg0NiIKICAgICAgICAgICAgIHN0eWxlPSJmaWxsOiM4YTQxODI7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiIC8+PHBhdGgKICAgICAgICAgICAgIGQ9Im0gMTA5MS4xMyw2MTkuODgzIC0xNzUuNzcxLDU3LjEyMSAxMS42MjksMzUuODA4IDE3NS43NjIsLTU3LjEyMSAtMTEuNjIsLTM1LjgwOCIKICAgICAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgICAgICBpZD0icGF0aDQ4IgogICAgICAgICAgICAgc3R5bGU9ImZpbGw6IzhhNDE4MjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIgLz48cGF0aAogICAgICAgICAgICAgZD0iTSA4NjYuOTU3LDkwMi4wNzQgODM2LjUsOTI0LjE5OSA5NDUuMTIxLDEwNzMuNzMgOTc1LjU4NiwxMDUxLjYxIDg2Ni45NTcsOTAyLjA3NCIKICAgICAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgICAgICBpZD0icGF0aDUwIgogICAgICAgICAgICAgc3R5bGU9ImZpbGw6IzhhNDE4MjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIgLz48cGF0aAogICAgICAgICAgICAgZD0iTSA2MDcuNDY1LDkwMy40NDUgNDk4Ljg1NSwxMDUyLjk3IDUyOS4zMiwxMDc1LjEgNjM3LjkzLDkyNS41NjYgNjA3LjQ2NSw5MDMuNDQ1IgogICAgICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgICAgIGlkPSJwYXRoNTIiCiAgICAgICAgICAgICBzdHlsZT0iZmlsbDojOGE0MTgyO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIiAvPjxwYXRoCiAgICAgICAgICAgICBkPSJtIDM4MC42ODgsNjIyLjEyOSAtMTEuNjI2LDM1LjgwMSAxNzUuNzU4LDU3LjA5IDExLjYyMSwtMzUuODAxIC0xNzUuNzUzLC01Ny4wOSIKICAgICAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgICAgICBpZD0icGF0aDU0IgogICAgICAgICAgICAgc3R5bGU9ImZpbGw6IzhhNDE4MjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIgLz48cGF0aAogICAgICAgICAgICAgZD0ibSA3MTYuMjg5LDM3Ni41OSAzNy42NDA2LDAgMCwxODQuODE2IC0zNy42NDA2LDAgMCwtMTg0LjgxNiB6IgogICAgICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgICAgIGlkPSJwYXRoNTYiCiAgICAgICAgICAgICBzdHlsZT0iZmlsbDojOGE0MTgyO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIiAvPjwvZz48L2c+PC9nPjwvZz48L3N2Zz4=') no-repeat, none; -webkit-background-size: 100%; -moz-background-size: 100%; -o-background-size: 100%; background-size: 100%; display: block; float: left; width: 90px; height: 25px; }\n+.jasmine_html-reporter .banner .version { margin-left: 14px; position: relative; top: 6px; }\n+.jasmine_html-reporter .banner .duration { position: absolute; right: 14px; top: 6px; }\n+.jasmine_html-reporter #jasmine_content { position: fixed; right: 100%; }\n+.jasmine_html-reporter .version { color: #aaaaaa; }\n+.jasmine_html-reporter .banner { margin-top: 14px; }\n+.jasmine_html-reporter .duration { color: #aaaaaa; float: right; }\n+.jasmine_html-reporter .symbol-summary { overflow: hidden; *zoom: 1; margin: 14px 0; }\n+.jasmine_html-reporter .symbol-summary li { display: inline-block; height: 8px; width: 14px; font-size: 16px; }\n+.jasmine_html-reporter .symbol-summary li.passed { font-size: 14px; }\n+.jasmine_html-reporter .symbol-summary li.passed:before { color: #007069; content: \"\\02022\"; }\n+.jasmine_html-reporter .symbol-summary li.failed { line-height: 9px; }\n+.jasmine_html-reporter .symbol-summary li.failed:before { color: #ca3a11; content: \"\\d7\"; font-weight: bold; margin-left: -1px; }\n+.jasmine_html-reporter .symbol-summary li.disabled { font-size: 14px; }\n+.jasmine_html-reporter .symbol-summary li.disabled:before { color: #bababa; content: \"\\02022\"; }\n+.jasmine_html-reporter .symbol-summary li.pending { line-height: 17px; }\n+.jasmine_html-reporter .symbol-summary li.pending:before { color: #ba9d37; content: \"*\"; }\n+.jasmine_html-reporter .exceptions { color: #fff; float: right; margin-top: 5px; margin-right: 5px; }\n+.jasmine_html-reporter .bar { line-height: 28px; font-size: 14px; display: block; color: #eee; }\n+.jasmine_html-reporter .bar.failed { background-color: #ca3a11; }\n+.jasmine_html-reporter .bar.passed { background-color: #007069; }\n+.jasmine_html-reporter .bar.skipped { background-color: #bababa; }\n+.jasmine_html-reporter .bar.menu { background-color: #fff; color: #aaaaaa; }\n+.jasmine_html-reporter .bar.menu a { color: #333333; }\n+.jasmine_html-reporter .bar a { color: white; }\n+.jasmine_html-reporter.spec-list .bar.menu.failure-list, .jasmine_html-reporter.spec-list .results .failures { display: none; }\n+.jasmine_html-reporter.failure-list .bar.menu.spec-list, .jasmine_html-reporter.failure-list .summary { display: none; }\n+.jasmine_html-reporter .running-alert { background-color: #666666; }\n+.jasmine_html-reporter .results { margin-top: 14px; }\n+.jasmine_html-reporter.showDetails .summaryMenuItem { font-weight: normal; text-decoration: inherit; }\n+.jasmine_html-reporter.showDetails .summaryMenuItem:hover { text-decoration: underline; }\n+.jasmine_html-reporter.showDetails .detailsMenuItem { font-weight: bold; text-decoration: underline; }\n+.jasmine_html-reporter.showDetails .summary { display: none; }\n+.jasmine_html-reporter.showDetails #details { display: block; }\n+.jasmine_html-reporter .summaryMenuItem { font-weight: bold; text-decoration: underline; }\n+.jasmine_html-reporter .summary { margin-top: 14px; }\n+.jasmine_html-reporter .summary ul { list-style-type: none; margin-left: 14px; padding-top: 0; padding-left: 0; }\n+.jasmine_html-reporter .summary ul.suite { margin-top: 7px; margin-bottom: 7px; }\n+.jasmine_html-reporter .summary li.passed a { color: #007069; }\n+.jasmine_html-reporter .summary li.failed a { color: #ca3a11; }\n+.jasmine_html-reporter .summary li.empty a { color: #ba9d37; }\n+.jasmine_html-reporter .summary li.pending a { color: #ba9d37; }\n+.jasmine_html-reporter .description + .suite { margin-top: 0; }\n+.jasmine_html-reporter .suite { margin-top: 14px; }\n+.jasmine_html-reporter .suite a { color: #333333; }\n+.jasmine_html-reporter .failures .spec-detail { margin-bottom: 28px; }\n+.jasmine_html-reporter .failures .spec-detail .description { background-color: #ca3a11; }\n+.jasmine_html-reporter .failures .spec-detail .description a { color: white; }\n+.jasmine_html-reporter .result-message { padding-top: 14px; color: #333333; white-space: pre; }\n+.jasmine_html-reporter .result-message span.result { display: block; }\n+.jasmine_html-reporter .stack-trace { margin: 5px 0 0 0; max-height: 224px; overflow: auto; line-height: 18px; color: #666666; border: 1px solid #ddd; background: white; white-space: pre; }\n\\ No newline at end of file\ndiff --git a/resources/libs/jasmine/jasmine.js b/resources/libs/jasmine/jasmine.js\nnew file mode 100644\nindex 0000000..b582720\n--- /dev/null\n+++ b/resources/libs/jasmine/jasmine.js\n@@ -0,0 +1,2516 @@\n+/*\n+Copyright (c) 2008-2014 Pivotal Labs\n+\n+Permission is hereby granted, free of charge, to any person obtaining\n+a copy of this software and associated documentation files (the\n+\"Software\"), to deal in the Software without restriction, including\n+without limitation the rights to use, copy, modify, merge, publish,\n+distribute, sublicense, and/or sell copies of the Software, and to\n+permit persons to whom the Software is furnished to do so, subject to\n+the following conditions:\n+\n+The above copyright notice and this permission notice shall be\n+included in all copies or substantial portions of the Software.\n+\n+THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n+*/\n+function getJasmineRequireObj() {\n+  if (typeof module !== 'undefined' && module.exports) {\n+    return exports;\n+  } else {\n+    window.jasmineRequire = window.jasmineRequire || {};\n+    return window.jasmineRequire;\n+  }\n+}\n+\n+getJasmineRequireObj().core = function(jRequire) {\n+  var j$ = {};\n+\n+  jRequire.base(j$);\n+  j$.util = jRequire.util();\n+  j$.Any = jRequire.Any();\n+  j$.CallTracker = jRequire.CallTracker();\n+  j$.MockDate = jRequire.MockDate();\n+  j$.Clock = jRequire.Clock();\n+  j$.DelayedFunctionScheduler = jRequire.DelayedFunctionScheduler();\n+  j$.Env = jRequire.Env(j$);\n+  j$.ExceptionFormatter = jRequire.ExceptionFormatter();\n+  j$.Expectation = jRequire.Expectation();\n+  j$.buildExpectationResult = jRequire.buildExpectationResult();\n+  j$.JsApiReporter = jRequire.JsApiReporter();\n+  j$.matchersUtil = jRequire.matchersUtil(j$);\n+  j$.ObjectContaining = jRequire.ObjectContaining(j$);\n+  j$.pp = jRequire.pp(j$);\n+  j$.QueueRunner = jRequire.QueueRunner(j$);\n+  j$.ReportDispatcher = jRequire.ReportDispatcher();\n+  j$.Spec = jRequire.Spec(j$);\n+  j$.SpyStrategy = jRequire.SpyStrategy();\n+  j$.Suite = jRequire.Suite();\n+  j$.Timer = jRequire.Timer();\n+  j$.version = jRequire.version();\n+\n+  j$.matchers = jRequire.requireMatchers(jRequire, j$);\n+\n+  return j$;\n+};\n+\n+getJasmineRequireObj().requireMatchers = function(jRequire, j$) {\n+  var availableMatchers = [\n+      'toBe',\n+      'toBeCloseTo',\n+      'toBeDefined',\n+      'toBeFalsy',\n+      'toBeGreaterThan',\n+      'toBeLessThan',\n+      'toBeNaN',\n+      'toBeNull',\n+      'toBeTruthy',\n+      'toBeUndefined',\n+      'toContain',\n+      'toEqual',\n+      'toHaveBeenCalled',\n+      'toHaveBeenCalledWith',\n+      'toMatch',\n+      'toThrow',\n+      'toThrowError'\n+    ],\n+    matchers = {};\n+\n+  for (var i = 0; i < availableMatchers.length; i++) {\n+    var name = availableMatchers[i];\n+    matchers[name] = jRequire[name](j$);\n+  }\n+\n+  return matchers;\n+};\n+\n+getJasmineRequireObj().base = (function (jasmineGlobal) {\n+  if (typeof module !== 'undefined' && module.exports) {\n+    jasmineGlobal = global;\n+  }\n+\n+  return function(j$) {\n+    j$.unimplementedMethod_ = function() {\n+      throw new Error('unimplemented method');\n+    };\n+\n+    j$.MAX_PRETTY_PRINT_DEPTH = 40;\n+    j$.MAX_PRETTY_PRINT_ARRAY_LENGTH = 100;\n+    j$.DEFAULT_TIMEOUT_INTERVAL = 5000;\n+\n+    j$.getGlobal = function() {\n+      return jasmineGlobal;\n+    };\n+\n+    j$.getEnv = function(options) {\n+      var env = j$.currentEnv_ = j$.currentEnv_ || new j$.Env(options);\n+      //jasmine. singletons in here (setTimeout blah blah).\n+      return env;\n+    };\n+\n+    j$.isArray_ = function(value) {\n+      return j$.isA_('Array', value);\n+    };\n+\n+    j$.isString_ = function(value) {\n+      return j$.isA_('String', value);\n+    };\n+\n+    j$.isNumber_ = function(value) {\n+      return j$.isA_('Number', value);\n+    };\n+\n+    j$.isA_ = function(typeName, value) {\n+      return Object.prototype.toString.apply(value) === '[object ' + typeName + ']';\n+    };\n+\n+    j$.isDomNode = function(obj) {\n+      return obj.nodeType > 0;\n+    };\n+\n+    j$.any = function(clazz) {\n+      return new j$.Any(clazz);\n+    };\n+\n+    j$.objectContaining = function(sample) {\n+      return new j$.ObjectContaining(sample);\n+    };\n+\n+    j$.createSpy = function(name, originalFn) {\n+\n+      var spyStrategy = new j$.SpyStrategy({\n+          name: name,\n+          fn: originalFn,\n+          getSpy: function() { return spy; }\n+        }),\n+        callTracker = new j$.CallTracker(),\n+        spy = function() {\n+          callTracker.track({\n+            object: this,\n+            args: Array.prototype.slice.apply(arguments)\n+          });\n+          return spyStrategy.exec.apply(this, arguments);\n+        };\n+\n+      for (var prop in originalFn) {\n+        if (prop === 'and' || prop === 'calls') {\n+          throw new Error('Jasmine spies would overwrite the \\'and\\' and \\'calls\\' properties on the object being spied upon');\n+        }\n+\n+        spy[prop] = originalFn[prop];\n+      }\n+\n+      spy.and = spyStrategy;\n+      spy.calls = callTracker;\n+\n+      return spy;\n+    };\n+\n+    j$.isSpy = function(putativeSpy) {\n+      if (!putativeSpy) {\n+        return false;\n+      }\n+      return putativeSpy.and instanceof j$.SpyStrategy &&\n+        putativeSpy.calls instanceof j$.CallTracker;\n+    };\n+\n+    j$.createSpyObj = function(baseName, methodNames) {\n+      if (!j$.isArray_(methodNames) || methodNames.length === 0) {\n+        throw 'createSpyObj requires a non-empty array of method names to create spies for';\n+      }\n+      var obj = {};\n+      for (var i = 0; i < methodNames.length; i++) {\n+        obj[methodNames[i]] = j$.createSpy(baseName + '.' + methodNames[i]);\n+      }\n+      return obj;\n+    };\n+  };\n+})(this);\n+\n+getJasmineRequireObj().util = function() {\n+\n+  var util = {};\n+\n+  util.inherit = function(childClass, parentClass) {\n+    var Subclass = function() {\n+    };\n+    Subclass.prototype = parentClass.prototype;\n+    childClass.prototype = new Subclass();\n+  };\n+\n+  util.htmlEscape = function(str) {\n+    if (!str) {\n+      return str;\n+    }\n+    return str.replace(/&/g, '&amp;')\n+      .replace(/</g, '&lt;')\n+      .replace(/>/g, '&gt;');\n+  };\n+\n+  util.argsToArray = function(args) {\n+    var arrayOfArgs = [];\n+    for (var i = 0; i < args.length; i++) {\n+      arrayOfArgs.push(args[i]);\n+    }\n+    return arrayOfArgs;\n+  };\n+\n+  util.isUndefined = function(obj) {\n+    return obj === void 0;\n+  };\n+\n+  util.arrayContains = function(array, search) {\n+    var i = array.length;\n+    while (i--) {\n+      if (array[i] == search) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  };\n+\n+  return util;\n+};\n+\n+getJasmineRequireObj().Spec = function(j$) {\n+  function Spec(attrs) {\n+    this.expectationFactory = attrs.expectationFactory;\n+    this.resultCallback = attrs.resultCallback || function() {};\n+    this.id = attrs.id;\n+    this.description = attrs.description || '';\n+    this.fn = attrs.fn;\n+    this.beforeFns = attrs.beforeFns || function() { return []; };\n+    this.afterFns = attrs.afterFns || function() { return []; };\n+    this.onStart = attrs.onStart || function() {};\n+    this.exceptionFormatter = attrs.exceptionFormatter || function() {};\n+    this.getSpecName = attrs.getSpecName || function() { return ''; };\n+    this.expectationResultFactory = attrs.expectationResultFactory || function() { };\n+    this.queueRunnerFactory = attrs.queueRunnerFactory || function() {};\n+    this.catchingExceptions = attrs.catchingExceptions || function() { return true; };\n+\n+    if (!this.fn) {\n+      this.pend();\n+    }\n+\n+    this.result = {\n+      id: this.id,\n+      description: this.description,\n+      fullName: this.getFullName(),\n+      failedExpectations: [],\n+      passedExpectations: []\n+    };\n+  }\n+\n+  Spec.prototype.addExpectationResult = function(passed, data) {\n+    var expectationResult = this.expectationResultFactory(data);\n+    if (passed) {\n+      this.result.passedExpectations.push(expectationResult);\n+    } else {\n+      this.result.failedExpectations.push(expectationResult);\n+    }\n+  };\n+\n+  Spec.prototype.expect = function(actual) {\n+    return this.expectationFactory(actual, this);\n+  };\n+\n+  Spec.prototype.execute = function(onComplete) {\n+    var self = this;\n+\n+    this.onStart(this);\n+\n+    if (this.markedPending || this.disabled) {\n+      complete();\n+      return;\n+    }\n+\n+    var allFns = this.beforeFns().concat(this.fn).concat(this.afterFns());\n+\n+    this.queueRunnerFactory({\n+      fns: allFns,\n+      onException: onException,\n+      onComplete: complete,\n+      enforceTimeout: function() { return true; }\n+    });\n+\n+    function onException(e) {\n+      if (Spec.isPendingSpecException(e)) {\n+        self.pend();\n+        return;\n+      }\n+\n+      self.addExpectationResult(false, {\n+        matcherName: '',\n+        passed: false,\n+        expected: '',\n+        actual: '',\n+        error: e\n+      });\n+    }\n+\n+    function complete() {\n+      self.result.status = self.status();\n+      self.resultCallback(self.result);\n+\n+      if (onComplete) {\n+        onComplete();\n+      }\n+    }\n+  };\n+\n+  Spec.prototype.disable = function() {\n+    this.disabled = true;\n+  };\n+\n+  Spec.prototype.pend = function() {\n+    this.markedPending = true;\n+  };\n+\n+  Spec.prototype.status = function() {\n+    if (this.disabled) {\n+      return 'disabled';\n+    }\n+\n+    if (this.markedPending) {\n+      return 'pending';\n+    }\n+\n+    if (this.result.failedExpectations.length > 0) {\n+      return 'failed';\n+    } else {\n+      return 'passed';\n+    }\n+  };\n+\n+  Spec.prototype.getFullName = function() {\n+    return this.getSpecName(this);\n+  };\n+\n+  Spec.pendingSpecExceptionMessage = '=> marked Pending';\n+\n+  Spec.isPendingSpecException = function(e) {\n+    return !!(e && e.toString && e.toString().indexOf(Spec.pendingSpecExceptionMessage) !== -1);\n+  };\n+\n+  return Spec;\n+};\n+\n+if (typeof window == void 0 && typeof exports == 'object') {\n+  exports.Spec = jasmineRequire.Spec;\n+}\n+\n+getJasmineRequireObj().Env = function(j$) {\n+  function Env(options) {\n+    options = options || {};\n+\n+    var self = this;\n+    var global = options.global || j$.getGlobal();\n+\n+    var totalSpecsDefined = 0;\n+\n+    var catchExceptions = true;\n+\n+    var realSetTimeout = j$.getGlobal().setTimeout;\n+    var realClearTimeout = j$.getGlobal().clearTimeout;\n+    this.clock = new j$.Clock(global, new j$.DelayedFunctionScheduler(), new j$.MockDate(global));\n+\n+    var runnableLookupTable = {};\n+\n+    var spies = [];\n+\n+    var currentSpec = null;\n+    var currentSuite = null;\n+\n+    var reporter = new j$.ReportDispatcher([\n+      'jasmineStarted',\n+      'jasmineDone',\n+      'suiteStarted',\n+      'suiteDone',\n+      'specStarted',\n+      'specDone'\n+    ]);\n+\n+    this.specFilter = function() {\n+      return true;\n+    };\n+\n+    var equalityTesters = [];\n+\n+    var customEqualityTesters = [];\n+    this.addCustomEqualityTester = function(tester) {\n+      customEqualityTesters.push(tester);\n+    };\n+\n+    j$.Expectation.addCoreMatchers(j$.matchers);\n+\n+    var nextSpecId = 0;\n+    var getNextSpecId = function() {\n+      return 'spec' + nextSpecId++;\n+    };\n+\n+    var nextSuiteId = 0;\n+    var getNextSuiteId = function() {\n+      return 'suite' + nextSuiteId++;\n+    };\n+\n+    var expectationFactory = function(actual, spec) {\n+      return j$.Expectation.Factory({\n+        util: j$.matchersUtil,\n+        customEqualityTesters: customEqualityTesters,\n+        actual: actual,\n+        addExpectationResult: addExpectationResult\n+      });\n+\n+      function addExpectationResult(passed, result) {\n+        return spec.addExpectationResult(passed, result);\n+      }\n+    };\n+\n+    var specStarted = function(spec) {\n+      currentSpec = spec;\n+      reporter.specStarted(spec.result);\n+    };\n+\n+    var beforeFns = function(suite) {\n+      return function() {\n+        var befores = [];\n+        while(suite) {\n+          befores = befores.concat(suite.beforeFns);\n+          suite = suite.parentSuite;\n+        }\n+        return befores.reverse();\n+      };\n+    };\n+\n+    var afterFns = function(suite) {\n+      return function() {\n+        var afters = [];\n+        while(suite) {\n+          afters = afters.concat(suite.afterFns);\n+          suite = suite.parentSuite;\n+        }\n+        return afters;\n+      };\n+    };\n+\n+    var getSpecName = function(spec, suite) {\n+      return suite.getFullName() + ' ' + spec.description;\n+    };\n+\n+    // TODO: we may just be able to pass in the fn instead of wrapping here\n+    var buildExpectationResult = j$.buildExpectationResult,\n+        exceptionFormatter = new j$.ExceptionFormatter(),\n+        expectationResultFactory = function(attrs) {\n+          attrs.messageFormatter = exceptionFormatter.message;\n+          attrs.stackFormatter = exceptionFormatter.stack;\n+\n+          return buildExpectationResult(attrs);\n+        };\n+\n+    // TODO: fix this naming, and here's where the value comes in\n+    this.catchExceptions = function(value) {\n+      catchExceptions = !!value;\n+      return catchExceptions;\n+    };\n+\n+    this.catchingExceptions = function() {\n+      return catchExceptions;\n+    };\n+\n+    var maximumSpecCallbackDepth = 20;\n+    var currentSpecCallbackDepth = 0;\n+\n+    function clearStack(fn) {\n+      currentSpecCallbackDepth++;\n+      if (currentSpecCallbackDepth >= maximumSpecCallbackDepth) {\n+        currentSpecCallbackDepth = 0;\n+        realSetTimeout(fn, 0);\n+      } else {\n+        fn();\n+      }\n+    }\n+\n+    var catchException = function(e) {\n+      return j$.Spec.isPendingSpecException(e) || catchExceptions;\n+    };\n+\n+    var queueRunnerFactory = function(options) {\n+      options.catchException = catchException;\n+      options.clearStack = options.clearStack || clearStack;\n+      options.timer = {setTimeout: realSetTimeout, clearTimeout: realClearTimeout};\n+\n+      new j$.QueueRunner(options).execute();\n+    };\n+\n+    var topSuite = new j$.Suite({\n+      env: this,\n+      id: getNextSuiteId(),\n+      description: 'Jasmine__TopLevel__Suite',\n+      queueRunner: queueRunnerFactory,\n+      resultCallback: function() {} // TODO - hook this up\n+    });\n+    runnableLookupTable[topSuite.id] = topSuite;\n+    currentSuite = topSuite;\n+\n+    this.topSuite = function() {\n+      return topSuite;\n+    };\n+\n+    this.execute = function(runnablesToRun) {\n+      runnablesToRun = runnablesToRun || [topSuite.id];\n+\n+      var allFns = [];\n+      for(var i = 0; i < runnablesToRun.length; i++) {\n+        var runnable = runnableLookupTable[runnablesToRun[i]];\n+        allFns.push((function(runnable) { return function(done) { runnable.execute(done); }; })(runnable));\n+      }\n+\n+      reporter.jasmineStarted({\n+        totalSpecsDefined: totalSpecsDefined\n+      });\n+\n+      queueRunnerFactory({fns: allFns, onComplete: reporter.jasmineDone});\n+    };\n+\n+    this.addReporter = function(reporterToAdd) {\n+      reporter.addReporter(reporterToAdd);\n+    };\n+\n+    this.addMatchers = function(matchersToAdd) {\n+      j$.Expectation.addMatchers(matchersToAdd);\n+    };\n+\n+    this.spyOn = function(obj, methodName) {\n+      if (j$.util.isUndefined(obj)) {\n+        throw new Error('spyOn could not find an object to spy upon for ' + methodName + '()');\n+      }\n+\n+      if (j$.util.isUndefined(obj[methodName])) {\n+        throw new Error(methodName + '() method does not exist');\n+      }\n+\n+      if (obj[methodName] && j$.isSpy(obj[methodName])) {\n+        //TODO?: should this return the current spy? Downside: may cause user confusion about spy state\n+        throw new Error(methodName + ' has already been spied upon');\n+      }\n+\n+      var spy = j$.createSpy(methodName, obj[methodName]);\n+\n+      spies.push({\n+        spy: spy,\n+        baseObj: obj,\n+        methodName: methodName,\n+        originalValue: obj[methodName]\n+      });\n+\n+      obj[methodName] = spy;\n+\n+      return spy;\n+    };\n+\n+    var suiteFactory = function(description) {\n+      var suite = new j$.Suite({\n+        env: self,\n+        id: getNextSuiteId(),\n+        description: description,\n+        parentSuite: currentSuite,\n+        queueRunner: queueRunnerFactory,\n+        onStart: suiteStarted,\n+        resultCallback: function(attrs) {\n+          reporter.suiteDone(attrs);\n+        }\n+      });\n+\n+      runnableLookupTable[suite.id] = suite;\n+      return suite;\n+    };\n+\n+    this.describe = function(description, specDefinitions) {\n+      var suite = suiteFactory(description);\n+\n+      var parentSuite = currentSuite;\n+      parentSuite.addChild(suite);\n+      currentSuite = suite;\n+\n+      var declarationError = null;\n+      try {\n+        specDefinitions.call(suite);\n+      } catch (e) {\n+        declarationError = e;\n+      }\n+\n+      if (declarationError) {\n+        this.it('encountered a declaration exception', function() {\n+          throw declarationError;\n+        });\n+      }\n+\n+      currentSuite = parentSuite;\n+\n+      return suite;\n+    };\n+\n+    this.xdescribe = function(description, specDefinitions) {\n+      var suite = this.describe(description, specDefinitions);\n+      suite.disable();\n+      return suite;\n+    };\n+\n+    var specFactory = function(description, fn, suite) {\n+      totalSpecsDefined++;\n+\n+      var spec = new j$.Spec({\n+        id: getNextSpecId(),\n+        beforeFns: beforeFns(suite),\n+        afterFns: afterFns(suite),\n+        expectationFactory: expectationFactory,\n+        exceptionFormatter: exceptionFormatter,\n+        resultCallback: specResultCallback,\n+        getSpecName: function(spec) {\n+          return getSpecName(spec, suite);\n+        },\n+        onStart: specStarted,\n+        description: description,\n+        expectationResultFactory: expectationResultFactory,\n+        queueRunnerFactory: queueRunnerFactory,\n+        fn: fn\n+      });\n+\n+      runnableLookupTable[spec.id] = spec;\n+\n+      if (!self.specFilter(spec)) {\n+        spec.disable();\n+      }\n+\n+      return spec;\n+\n+      function removeAllSpies() {\n+        for (var i = 0; i < spies.length; i++) {\n+          var spyEntry = spies[i];\n+          spyEntry.baseObj[spyEntry.methodName] = spyEntry.originalValue;\n+        }\n+        spies = [];\n+      }\n+\n+      function specResultCallback(result) {\n+        removeAllSpies();\n+        j$.Expectation.resetMatchers();\n+        customEqualityTesters = [];\n+        currentSpec = null;\n+        reporter.specDone(result);\n+      }\n+    };\n+\n+    var suiteStarted = function(suite) {\n+      reporter.suiteStarted(suite.result);\n+    };\n+\n+    this.it = function(description, fn) {\n+      var spec = specFactory(description, fn, currentSuite);\n+      currentSuite.addChild(spec);\n+      return spec;\n+    };\n+\n+    this.xit = function(description, fn) {\n+      var spec = this.it(description, fn);\n+      spec.pend();\n+      return spec;\n+    };\n+\n+    this.expect = function(actual) {\n+      if (!currentSpec) {\n+        throw new Error('\\'expect\\' was used when there was no current spec, this could be because an asynchronous test timed out');\n+      }\n+\n+      return currentSpec.expect(actual);\n+    };\n+\n+    this.beforeEach = function(beforeEachFunction) {\n+      currentSuite.beforeEach(beforeEachFunction);\n+    };\n+\n+    this.afterEach = function(afterEachFunction) {\n+      currentSuite.afterEach(afterEachFunction);\n+    };\n+\n+    this.pending = function() {\n+      throw j$.Spec.pendingSpecExceptionMessage;\n+    };\n+  }\n+\n+  return Env;\n+};\n+\n+getJasmineRequireObj().JsApiReporter = function() {\n+\n+  var noopTimer = {\n+    start: function(){},\n+    elapsed: function(){ return 0; }\n+  };\n+\n+  function JsApiReporter(options) {\n+    var timer = options.timer || noopTimer,\n+        status = 'loaded';\n+\n+    this.started = false;\n+    this.finished = false;\n+\n+    this.jasmineStarted = function() {\n+      this.started = true;\n+      status = 'started';\n+      timer.start();\n+    };\n+\n+    var executionTime;\n+\n+    this.jasmineDone = function() {\n+      this.finished = true;\n+      executionTime = timer.elapsed();\n+      status = 'done';\n+    };\n+\n+    this.status = function() {\n+      return status;\n+    };\n+\n+    var suites = {};\n+\n+    this.suiteStarted = function(result) {\n+      storeSuite(result);\n+    };\n+\n+    this.suiteDone = function(result) {\n+      storeSuite(result);\n+    };\n+\n+    function storeSuite(result) {\n+      suites[result.id] = result;\n+    }\n+\n+    this.suites = function() {\n+      return suites;\n+    };\n+\n+    var specs = [];\n+    this.specStarted = function(result) { };\n+\n+    this.specDone = function(result) {\n+      specs.push(result);\n+    };\n+\n+    this.specResults = function(index, length) {\n+      return specs.slice(index, index + length);\n+    };\n+\n+    this.specs = function() {\n+      return specs;\n+    };\n+\n+    this.executionTime = function() {\n+      return executionTime;\n+    };\n+\n+  }\n+\n+  return JsApiReporter;\n+};\n+\n+getJasmineRequireObj().Any = function() {\n+\n+  function Any(expectedObject) {\n+    this.expectedObject = expectedObject;\n+  }\n+\n+  Any.prototype.jasmineMatches = function(other) {\n+    if (this.expectedObject == String) {\n+      return typeof other == 'string' || other instanceof String;\n+    }\n+\n+    if (this.expectedObject == Number) {\n+      return typeof other == 'number' || other instanceof Number;\n+    }\n+\n+    if (this.expectedObject == Function) {\n+      return typeof other == 'function' || other instanceof Function;\n+    }\n+\n+    if (this.expectedObject == Object) {\n+      return typeof other == 'object';\n+    }\n+    \n+    if (this.expectedObject == Boolean) {\n+      return typeof other == 'boolean';\n+    }\n+\n+    return other instanceof this.expectedObject;\n+  };\n+\n+  Any.prototype.jasmineToString = function() {\n+    return '<jasmine.any(' + this.expectedObject + ')>';\n+  };\n+\n+  return Any;\n+};\n+\n+getJasmineRequireObj().CallTracker = function() {\n+\n+  function CallTracker() {\n+    var calls = [];\n+\n+    this.track = function(context) {\n+      calls.push(context);\n+    };\n+\n+    this.any = function() {\n+      return !!calls.length;\n+    };\n+\n+    this.count = function() {\n+      return calls.length;\n+    };\n+\n+    this.argsFor = function(index) {\n+      var call = calls[index];\n+      return call ? call.args : [];\n+    };\n+\n+    this.all = function() {\n+      return calls;\n+    };\n+\n+    this.allArgs = function() {\n+      var callArgs = [];\n+      for(var i = 0; i < calls.length; i++){\n+        callArgs.push(calls[i].args);\n+      }\n+\n+      return callArgs;\n+    };\n+\n+    this.first = function() {\n+      return calls[0];\n+    };\n+\n+    this.mostRecent = function() {\n+      return calls[calls.length - 1];\n+    };\n+\n+    this.reset = function() {\n+      calls = [];\n+    };\n+  }\n+\n+  return CallTracker;\n+};\n+\n+getJasmineRequireObj().Clock = function() {\n+  function Clock(global, delayedFunctionScheduler, mockDate) {\n+    var self = this,\n+      realTimingFunctions = {\n+        setTimeout: global.setTimeout,\n+        clearTimeout: global.clearTimeout,\n+        setInterval: global.setInterval,\n+        clearInterval: global.clearInterval\n+      },\n+      fakeTimingFunctions = {\n+        setTimeout: setTimeout,\n+        clearTimeout: clearTimeout,\n+        setInterval: setInterval,\n+        clearInterval: clearInterval\n+      },\n+      installed = false,\n+      timer;\n+\n+\n+    self.install = function() {\n+      replace(global, fakeTimingFunctions);\n+      timer = fakeTimingFunctions;\n+      installed = true;\n+\n+      return self;\n+    };\n+\n+    self.uninstall = function() {\n+      delayedFunctionScheduler.reset();\n+      mockDate.uninstall();\n+      replace(global, realTimingFunctions);\n+\n+      timer = realTimingFunctions;\n+      installed = false;\n+    };\n+\n+    self.mockDate = function(initialDate) {\n+      mockDate.install(initialDate);\n+    };\n+\n+    self.setTimeout = function(fn, delay, params) {\n+      if (legacyIE()) {\n+        if (arguments.length > 2) {\n+          throw new Error('IE < 9 cannot support extra params to setTimeout without a polyfill');\n+        }\n+        return timer.setTimeout(fn, delay);\n+      }\n+      return Function.prototype.apply.apply(timer.setTimeout, [global, arguments]);\n+    };\n+\n+    self.setInterval = function(fn, delay, params) {\n+      if (legacyIE()) {\n+        if (arguments.length > 2) {\n+          throw new Error('IE < 9 cannot support extra params to setInterval without a polyfill');\n+        }\n+        return timer.setInterval(fn, delay);\n+      }\n+      return Function.prototype.apply.apply(timer.setInterval, [global, arguments]);\n+    };\n+\n+    self.clearTimeout = function(id) {\n+      return Function.prototype.call.apply(timer.clearTimeout, [global, id]);\n+    };\n+\n+    self.clearInterval = function(id) {\n+      return Function.prototype.call.apply(timer.clearInterval, [global, id]);\n+    };\n+\n+    self.tick = function(millis) {\n+      if (installed) {\n+        mockDate.tick(millis);\n+        delayedFunctionScheduler.tick(millis);\n+      } else {\n+        throw new Error('Mock clock is not installed, use jasmine.clock().install()');\n+      }\n+    };\n+\n+    return self;\n+\n+    function legacyIE() {\n+      //if these methods are polyfilled, apply will be present\n+      return !(realTimingFunctions.setTimeout || realTimingFunctions.setInterval).apply;\n+    }\n+\n+    function replace(dest, source) {\n+      for (var prop in source) {\n+        dest[prop] = source[prop];\n+      }\n+    }\n+\n+    function setTimeout(fn, delay) {\n+      return delayedFunctionScheduler.scheduleFunction(fn, delay, argSlice(arguments, 2));\n+    }\n+\n+    function clearTimeout(id) {\n+      return delayedFunctionScheduler.removeFunctionWithId(id);\n+    }\n+\n+    function setInterval(fn, interval) {\n+      return delayedFunctionScheduler.scheduleFunction(fn, interval, argSlice(arguments, 2), true);\n+    }\n+\n+    function clearInterval(id) {\n+      return delayedFunctionScheduler.removeFunctionWithId(id);\n+    }\n+\n+    function argSlice(argsObj, n) {\n+      return Array.prototype.slice.call(argsObj, n);\n+    }\n+  }\n+\n+  return Clock;\n+};\n+\n+getJasmineRequireObj().DelayedFunctionScheduler = function() {\n+  function DelayedFunctionScheduler() {\n+    var self = this;\n+    var scheduledLookup = [];\n+    var scheduledFunctions = {};\n+    var currentTime = 0;\n+    var delayedFnCount = 0;\n+\n+    self.tick = function(millis) {\n+      millis = millis || 0;\n+      var endTime = currentTime + millis;\n+\n+      runScheduledFunctions(endTime);\n+      currentTime = endTime;\n+    };\n+\n+    self.scheduleFunction = function(funcToCall, millis, params, recurring, timeoutKey, runAtMillis) {\n+      var f;\n+      if (typeof(funcToCall) === 'string') {\n+        /* jshint evil: true */\n+        f = function() { return eval(funcToCall); };\n+        /* jshint evil: false */\n+      } else {\n+        f = funcToCall;\n+      }\n+\n+      millis = millis || 0;\n+      timeoutKey = timeoutKey || ++delayedFnCount;\n+      runAtMillis = runAtMillis || (currentTime + millis);\n+\n+      var funcToSchedule = {\n+        runAtMillis: runAtMillis,\n+        funcToCall: f,\n+        recurring: recurring,\n+        params: params,\n+        timeoutKey: timeoutKey,\n+        millis: millis\n+      };\n+\n+      if (runAtMillis in scheduledFunctions) {\n+        scheduledFunctions[runAtMillis].push(funcToSchedule);\n+      } else {\n+        scheduledFunctions[runAtMillis] = [funcToSchedule];\n+        scheduledLookup.push(runAtMillis);\n+        scheduledLookup.sort(function (a, b) {\n+          return a - b;\n+        });\n+      }\n+\n+      return timeoutKey;\n+    };\n+\n+    self.removeFunctionWithId = function(timeoutKey) {\n+      for (var runAtMillis in scheduledFunctions) {\n+        var funcs = scheduledFunctions[runAtMillis];\n+        var i = indexOfFirstToPass(funcs, function (func) {\n+          return func.timeoutKey === timeoutKey;\n+        });\n+\n+        if (i > -1) {\n+          if (funcs.length === 1) {\n+            delete scheduledFunctions[runAtMillis];\n+            deleteFromLookup(runAtMillis);\n+          } else {\n+            funcs.splice(i, 1);\n+          }\n+\n+          // intervals get rescheduled when executed, so there's never more\n+          // than a single scheduled function with a given timeoutKey\n+          break;\n+        }\n+      }\n+    };\n+\n+    self.reset = function() {\n+      currentTime = 0;\n+      scheduledLookup = [];\n+      scheduledFunctions = {};\n+      delayedFnCount = 0;\n+    };\n+\n+    return self;\n+\n+    function indexOfFirstToPass(array, testFn) {\n+      var index = -1;\n+\n+      for (var i = 0; i < array.length; ++i) {\n+        if (testFn(array[i])) {\n+          index = i;\n+          break;\n+        }\n+      }\n+\n+      return index;\n+    }\n+\n+    function deleteFromLookup(key) {\n+      var value = Number(key);\n+      var i = indexOfFirstToPass(scheduledLookup, function (millis) {\n+        return millis === value;\n+      });\n+\n+      if (i > -1) {\n+        scheduledLookup.splice(i, 1);\n+      }\n+    }\n+\n+    function reschedule(scheduledFn) {\n+      self.scheduleFunction(scheduledFn.funcToCall,\n+        scheduledFn.millis,\n+        scheduledFn.params,\n+        true,\n+        scheduledFn.timeoutKey,\n+        scheduledFn.runAtMillis + scheduledFn.millis);\n+    }\n+\n+    function runScheduledFunctions(endTime) {\n+      if (scheduledLookup.length === 0 || scheduledLookup[0] > endTime) {\n+        return;\n+      }\n+\n+      do {\n+        currentTime = scheduledLookup.shift();\n+\n+        var funcsToRun = scheduledFunctions[currentTime];\n+        delete scheduledFunctions[currentTime];\n+\n+        for (var i = 0; i < funcsToRun.length; ++i) {\n+          var funcToRun = funcsToRun[i];\n+          funcToRun.funcToCall.apply(null, funcToRun.params || []);\n+\n+          if (funcToRun.recurring) {\n+            reschedule(funcToRun);\n+          }\n+        }\n+      } while (scheduledLookup.length > 0 &&\n+              // checking first if we're out of time prevents setTimeout(0)\n+              // scheduled in a funcToRun from forcing an extra iteration\n+                 currentTime !== endTime  &&\n+                 scheduledLookup[0] <= endTime);\n+    }\n+  }\n+\n+  return DelayedFunctionScheduler;\n+};\n+\n+getJasmineRequireObj().ExceptionFormatter = function() {\n+  function ExceptionFormatter() {\n+    this.message = function(error) {\n+      var message = '';\n+\n+      if (error.name && error.message) {\n+        message += error.name + ': ' + error.message;\n+      } else {\n+        message += error.toString() + ' thrown';\n+      }\n+\n+      if (error.fileName || error.sourceURL) {\n+        message += ' in ' + (error.fileName || error.sourceURL);\n+      }\n+\n+      if (error.line || error.lineNumber) {\n+        message += ' (line ' + (error.line || error.lineNumber) + ')';\n+      }\n+\n+      return message;\n+    };\n+\n+    this.stack = function(error) {\n+      return error ? error.stack : null;\n+    };\n+  }\n+\n+  return ExceptionFormatter;\n+};\n+\n+getJasmineRequireObj().Expectation = function() {\n+\n+  var matchers = {};\n+\n+  function Expectation(options) {\n+    this.util = options.util || { buildFailureMessage: function() {} };\n+    this.customEqualityTesters = options.customEqualityTesters || [];\n+    this.actual = options.actual;\n+    this.addExpectationResult = options.addExpectationResult || function(){};\n+    this.isNot = options.isNot;\n+\n+    for (var matcherName in matchers) {\n+      this[matcherName] = matchers[matcherName];\n+    }\n+  }\n+\n+  Expectation.prototype.wrapCompare = function(name, matcherFactory) {\n+    return function() {\n+      var args = Array.prototype.slice.call(arguments, 0),\n+        expected = args.slice(0),\n+        message = '';\n+\n+      args.unshift(this.actual);\n+\n+      var matcher = matcherFactory(this.util, this.customEqualityTesters),\n+          matcherCompare = matcher.compare;\n+\n+      function defaultNegativeCompare() {\n+        var result = matcher.compare.apply(null, args);\n+        result.pass = !result.pass;\n+        return result;\n+      }\n+\n+      if (this.isNot) {\n+        matcherCompare = matcher.negativeCompare || defaultNegativeCompare;\n+      }\n+\n+      var result = matcherCompare.apply(null, args);\n+\n+      if (!result.pass) {\n+        if (!result.message) {\n+          args.unshift(this.isNot);\n+          args.unshift(name);\n+          message = this.util.buildFailureMessage.apply(null, args);\n+        } else {\n+          if (Object.prototype.toString.apply(result.message) === '[object Function]') {\n+            message = result.message();\n+          } else {\n+            message = result.message;\n+          }\n+        }\n+      }\n+\n+      if (expected.length == 1) {\n+        expected = expected[0];\n+      }\n+\n+      // TODO: how many of these params are needed?\n+      this.addExpectationResult(\n+        result.pass,\n+        {\n+          matcherName: name,\n+          passed: result.pass,\n+          message: message,\n+          actual: this.actual,\n+          expected: expected // TODO: this may need to be arrayified/sliced\n+        }\n+      );\n+    };\n+  };\n+\n+  Expectation.addCoreMatchers = function(matchers) {\n+    var prototype = Expectation.prototype;\n+    for (var matcherName in matchers) {\n+      var matcher = matchers[matcherName];\n+      prototype[matcherName] = prototype.wrapCompare(matcherName, matcher);\n+    }\n+  };\n+\n+  Expectation.addMatchers = function(matchersToAdd) {\n+    for (var name in matchersToAdd) {\n+      var matcher = matchersToAdd[name];\n+      matchers[name] = Expectation.prototype.wrapCompare(name, matcher);\n+    }\n+  };\n+\n+  Expectation.resetMatchers = function() {\n+    for (var name in matchers) {\n+      delete matchers[name];\n+    }\n+  };\n+\n+  Expectation.Factory = function(options) {\n+    options = options || {};\n+\n+    var expect = new Expectation(options);\n+\n+    // TODO: this would be nice as its own Object - NegativeExpectation\n+    // TODO: copy instead of mutate options\n+    options.isNot = true;\n+    expect.not = new Expectation(options);\n+\n+    return expect;\n+  };\n+\n+  return Expectation;\n+};\n+\n+//TODO: expectation result may make more sense as a presentation of an expectation.\n+getJasmineRequireObj().buildExpectationResult = function() {\n+  function buildExpectationResult(options) {\n+    var messageFormatter = options.messageFormatter || function() {},\n+      stackFormatter = options.stackFormatter || function() {};\n+\n+    return {\n+      matcherName: options.matcherName,\n+      expected: options.expected,\n+      actual: options.actual,\n+      message: message(),\n+      stack: stack(),\n+      passed: options.passed\n+    };\n+\n+    function message() {\n+      if (options.passed) {\n+        return 'Passed.';\n+      } else if (options.message) {\n+        return options.message;\n+      } else if (options.error) {\n+        return messageFormatter(options.error);\n+      }\n+      return '';\n+    }\n+\n+    function stack() {\n+      if (options.passed) {\n+        return '';\n+      }\n+\n+      var error = options.error;\n+      if (!error) {\n+        try {\n+          throw new Error(message());\n+        } catch (e) {\n+          error = e;\n+        }\n+      }\n+      return stackFormatter(error);\n+    }\n+  }\n+\n+  return buildExpectationResult;\n+};\n+\n+getJasmineRequireObj().MockDate = function() {\n+  function MockDate(global) {\n+    var self = this;\n+    var currentTime = 0;\n+\n+    if (!global || !global.Date) {\n+      self.install = function() {};\n+      self.tick = function() {};\n+      self.uninstall = function() {};\n+      return self;\n+    }\n+\n+    var GlobalDate = global.Date;\n+\n+    self.install = function(mockDate) {\n+      if (mockDate instanceof GlobalDate) {\n+        currentTime = mockDate.getTime();\n+      } else {\n+        currentTime = new GlobalDate().getTime();\n+      }\n+\n+      global.Date = FakeDate;\n+    };\n+\n+    self.tick = function(millis) {\n+      millis = millis || 0;\n+      currentTime = currentTime + millis;\n+    };\n+\n+    self.uninstall = function() {\n+      currentTime = 0;\n+      global.Date = GlobalDate;\n+    };\n+\n+    createDateProperties();\n+\n+    return self;\n+\n+    function FakeDate() {\n+      if (arguments.length === 0) {\n+        return new GlobalDate(currentTime);\n+      } else {\n+        return new GlobalDate(arguments[0], arguments[1], arguments[2],\n+          arguments[3], arguments[4], arguments[5], arguments[6]);\n+      }\n+    }\n+\n+    function createDateProperties() {\n+\n+      FakeDate.now = function() {\n+        if (GlobalDate.now) {\n+          return currentTime;\n+        } else {\n+          throw new Error('Browser does not support Date.now()');\n+        }\n+      };\n+\n+      FakeDate.toSource = GlobalDate.toSource;\n+      FakeDate.toString = GlobalDate.toString;\n+      FakeDate.parse = GlobalDate.parse;\n+      FakeDate.UTC = GlobalDate.UTC;\n+    }\n+  }\n+\n+  return MockDate;\n+};\n+\n+getJasmineRequireObj().ObjectContaining = function(j$) {\n+\n+  function ObjectContaining(sample) {\n+    this.sample = sample;\n+  }\n+\n+  ObjectContaining.prototype.jasmineMatches = function(other, mismatchKeys, mismatchValues) {\n+    if (typeof(this.sample) !== 'object') { throw new Error('You must provide an object to objectContaining, not \\''+this.sample+'\\'.'); }\n+\n+    mismatchKeys = mismatchKeys || [];\n+    mismatchValues = mismatchValues || [];\n+\n+    var hasKey = function(obj, keyName) {\n+      return obj !== null && !j$.util.isUndefined(obj[keyName]);\n+    };\n+\n+    for (var property in this.sample) {\n+      if (!hasKey(other, property) && hasKey(this.sample, property)) {\n+        mismatchKeys.push('expected has key \\'' + property + '\\', but missing from actual.');\n+      }\n+      else if (!j$.matchersUtil.equals(other[property], this.sample[property])) {\n+        mismatchValues.push('\\'' + property + '\\' was \\'' + (other[property] ? j$.util.htmlEscape(other[property].toString()) : other[property]) + '\\' in actual, but was \\'' + (this.sample[property] ? j$.util.htmlEscape(this.sample[property].toString()) : this.sample[property]) + '\\' in expected.');\n+      }\n+    }\n+\n+    return (mismatchKeys.length === 0 && mismatchValues.length === 0);\n+  };\n+\n+  ObjectContaining.prototype.jasmineToString = function() {\n+    return '<jasmine.objectContaining(' + j$.pp(this.sample) + ')>';\n+  };\n+\n+  return ObjectContaining;\n+};\n+\n+getJasmineRequireObj().pp = function(j$) {\n+\n+  function PrettyPrinter() {\n+    this.ppNestLevel_ = 0;\n+    this.seen = [];\n+  }\n+\n+  PrettyPrinter.prototype.format = function(value) {\n+    this.ppNestLevel_++;\n+    try {\n+      if (j$.util.isUndefined(value)) {\n+        this.emitScalar('undefined');\n+      } else if (value === null) {\n+        this.emitScalar('null');\n+      } else if (value === 0 && 1/value === -Infinity) {\n+        this.emitScalar('-0');\n+      } else if (value === j$.getGlobal()) {\n+        this.emitScalar('<global>');\n+      } else if (value.jasmineToString) {\n+        this.emitScalar(value.jasmineToString());\n+      } else if (typeof value === 'string') {\n+        this.emitString(value);\n+      } else if (j$.isSpy(value)) {\n+        this.emitScalar('spy on ' + value.and.identity());\n+      } else if (value instanceof RegExp) {\n+        this.emitScalar(value.toString());\n+      } else if (typeof value === 'function') {\n+        this.emitScalar('Function');\n+      } else if (typeof value.nodeType === 'number') {\n+        this.emitScalar('HTMLNode');\n+      } else if (value instanceof Date) {\n+        this.emitScalar('Date(' + value + ')');\n+      } else if (j$.util.arrayContains(this.seen, value)) {\n+        this.emitScalar('<circular reference: ' + (j$.isArray_(value) ? 'Array' : 'Object') + '>');\n+      } else if (j$.isArray_(value) || j$.isA_('Object', value)) {\n+        this.seen.push(value);\n+        if (j$.isArray_(value)) {\n+          this.emitArray(value);\n+        } else {\n+          this.emitObject(value);\n+        }\n+        this.seen.pop();\n+      } else {\n+        this.emitScalar(value.toString());\n+      }\n+    } finally {\n+      this.ppNestLevel_--;\n+    }\n+  };\n+\n+  PrettyPrinter.prototype.iterateObject = function(obj, fn) {\n+    for (var property in obj) {\n+      if (!Object.prototype.hasOwnProperty.call(obj, property)) { continue; }\n+      fn(property, obj.__lookupGetter__ ? (!j$.util.isUndefined(obj.__lookupGetter__(property)) &&\n+          obj.__lookupGetter__(property) !== null) : false);\n+    }\n+  };\n+\n+  PrettyPrinter.prototype.emitArray = j$.unimplementedMethod_;\n+  PrettyPrinter.prototype.emitObject = j$.unimplementedMethod_;\n+  PrettyPrinter.prototype.emitScalar = j$.unimplementedMethod_;\n+  PrettyPrinter.prototype.emitString = j$.unimplementedMethod_;\n+\n+  function StringPrettyPrinter() {\n+    PrettyPrinter.call(this);\n+\n+    this.string = '';\n+  }\n+\n+  j$.util.inherit(StringPrettyPrinter, PrettyPrinter);\n+\n+  StringPrettyPrinter.prototype.emitScalar = function(value) {\n+    this.append(value);\n+  };\n+\n+  StringPrettyPrinter.prototype.emitString = function(value) {\n+    this.append('\\'' + value + '\\'');\n+  };\n+\n+  StringPrettyPrinter.prototype.emitArray = function(array) {\n+    if (this.ppNestLevel_ > j$.MAX_PRETTY_PRINT_DEPTH) {\n+      this.append('Array');\n+      return;\n+    }\n+    var length = Math.min(array.length, j$.MAX_PRETTY_PRINT_ARRAY_LENGTH);\n+    this.append('[ ');\n+    for (var i = 0; i < length; i++) {\n+      if (i > 0) {\n+        this.append(', ');\n+      }\n+      this.format(array[i]);\n+    }\n+    if(array.length > length){\n+      this.append(', ...');\n+    }\n+    this.append(' ]');\n+  };\n+\n+  StringPrettyPrinter.prototype.emitObject = function(obj) {\n+    if (this.ppNestLevel_ > j$.MAX_PRETTY_PRINT_DEPTH) {\n+      this.append('Object');\n+      return;\n+    }\n+\n+    var self = this;\n+    this.append('{ ');\n+    var first = true;\n+\n+    this.iterateObject(obj, function(property, isGetter) {\n+      if (first) {\n+        first = false;\n+      } else {\n+        self.append(', ');\n+      }\n+\n+      self.append(property);\n+      self.append(': ');\n+      if (isGetter) {\n+        self.append('<getter>');\n+      } else {\n+        self.format(obj[property]);\n+      }\n+    });\n+\n+    this.append(' }');\n+  };\n+\n+  StringPrettyPrinter.prototype.append = function(value) {\n+    this.string += value;\n+  };\n+\n+  return function(value) {\n+    var stringPrettyPrinter = new StringPrettyPrinter();\n+    stringPrettyPrinter.format(value);\n+    return stringPrettyPrinter.string;\n+  };\n+};\n+\n+getJasmineRequireObj().QueueRunner = function(j$) {\n+\n+  function once(fn) {\n+    var called = false;\n+    return function() {\n+      if (!called) {\n+        called = true;\n+        fn();\n+      }\n+    };\n+  }\n+\n+  function QueueRunner(attrs) {\n+    this.fns = attrs.fns || [];\n+    this.onComplete = attrs.onComplete || function() {};\n+    this.clearStack = attrs.clearStack || function(fn) {fn();};\n+    this.onException = attrs.onException || function() {};\n+    this.catchException = attrs.catchException || function() { return true; };\n+    this.enforceTimeout = attrs.enforceTimeout || function() { return false; };\n+    this.userContext = {};\n+    this.timer = attrs.timeout || {setTimeout: setTimeout, clearTimeout: clearTimeout};\n+  }\n+\n+  QueueRunner.prototype.execute = function() {\n+    this.run(this.fns, 0);\n+  };\n+\n+  QueueRunner.prototype.run = function(fns, recursiveIndex) {\n+    var length = fns.length,\n+        self = this,\n+        iterativeIndex;\n+\n+    for(iterativeIndex = recursiveIndex; iterativeIndex < length; iterativeIndex++) {\n+      var fn = fns[iterativeIndex];\n+      if (fn.length > 0) {\n+        return attemptAsync(fn);\n+      } else {\n+        attemptSync(fn);\n+      }\n+    }\n+\n+    var runnerDone = iterativeIndex >= length;\n+\n+    if (runnerDone) {\n+      this.clearStack(this.onComplete);\n+    }\n+\n+    function attemptSync(fn) {\n+      try {\n+        fn.call(self.userContext);\n+      } catch (e) {\n+        handleException(e);\n+      }\n+    }\n+\n+    function attemptAsync(fn) {\n+      var clearTimeout = function () {\n+          Function.prototype.apply.apply(self.timer.clearTimeout, [j$.getGlobal(), [timeoutId]]);\n+        },\n+        next = once(function () {\n+          clearTimeout(timeoutId);\n+          self.run(fns, iterativeIndex + 1);\n+        }),\n+        timeoutId;\n+\n+      if (self.enforceTimeout()) {\n+        timeoutId = Function.prototype.apply.apply(self.timer.setTimeout, [j$.getGlobal(), [function() {\n+          self.onException(new Error('Timeout - Async callback was not invoked within timeout specified by jasmine.DEFAULT_TIMEOUT_INTERVAL.'));\n+          next();\n+        }, j$.DEFAULT_TIMEOUT_INTERVAL]]);\n+      }\n+\n+      try {\n+        fn.call(self.userContext, next);\n+      } catch (e) {\n+        handleException(e);\n+        next();\n+      }\n+    }\n+\n+    function handleException(e) {\n+      self.onException(e);\n+      if (!self.catchException(e)) {\n+        //TODO: set a var when we catch an exception and\n+        //use a finally block to close the loop in a nice way..\n+        throw e;\n+      }\n+    }\n+  };\n+\n+  return QueueRunner;\n+};\n+\n+getJasmineRequireObj().ReportDispatcher = function() {\n+  function ReportDispatcher(methods) {\n+\n+    var dispatchedMethods = methods || [];\n+\n+    for (var i = 0; i < dispatchedMethods.length; i++) {\n+      var method = dispatchedMethods[i];\n+      this[method] = (function(m) {\n+        return function() {\n+          dispatch(m, arguments);\n+        };\n+      }(method));\n+    }\n+\n+    var reporters = [];\n+\n+    this.addReporter = function(reporter) {\n+      reporters.push(reporter);\n+    };\n+\n+    return this;\n+\n+    function dispatch(method, args) {\n+      for (var i = 0; i < reporters.length; i++) {\n+        var reporter = reporters[i];\n+        if (reporter[method]) {\n+          reporter[method].apply(reporter, args);\n+        }\n+      }\n+    }\n+  }\n+\n+  return ReportDispatcher;\n+};\n+\n+\n+getJasmineRequireObj().SpyStrategy = function() {\n+\n+  function SpyStrategy(options) {\n+    options = options || {};\n+\n+    var identity = options.name || 'unknown',\n+        originalFn = options.fn || function() {},\n+        getSpy = options.getSpy || function() {},\n+        plan = function() {};\n+\n+    this.identity = function() {\n+      return identity;\n+    };\n+\n+    this.exec = function() {\n+      return plan.apply(this, arguments);\n+    };\n+\n+    this.callThrough = function() {\n+      plan = originalFn;\n+      return getSpy();\n+    };\n+\n+    this.returnValue = function(value) {\n+      plan = function() {\n+        return value;\n+      };\n+      return getSpy();\n+    };\n+\n+    this.throwError = function(something) {\n+      var error = (something instanceof Error) ? something : new Error(something);\n+      plan = function() {\n+        throw error;\n+      };\n+      return getSpy();\n+    };\n+\n+    this.callFake = function(fn) {\n+      plan = fn;\n+      return getSpy();\n+    };\n+\n+    this.stub = function(fn) {\n+      plan = function() {};\n+      return getSpy();\n+    };\n+  }\n+\n+  return SpyStrategy;\n+};\n+\n+getJasmineRequireObj().Suite = function() {\n+  function Suite(attrs) {\n+    this.env = attrs.env;\n+    this.id = attrs.id;\n+    this.parentSuite = attrs.parentSuite;\n+    this.description = attrs.description;\n+    this.onStart = attrs.onStart || function() {};\n+    this.resultCallback = attrs.resultCallback || function() {};\n+    this.clearStack = attrs.clearStack || function(fn) {fn();};\n+\n+    this.beforeFns = [];\n+    this.afterFns = [];\n+    this.queueRunner = attrs.queueRunner || function() {};\n+    this.disabled = false;\n+\n+    this.children = [];\n+\n+    this.result = {\n+      id: this.id,\n+      status: this.disabled ? 'disabled' : '',\n+      description: this.description,\n+      fullName: this.getFullName()\n+    };\n+  }\n+\n+  Suite.prototype.getFullName = function() {\n+    var fullName = this.description;\n+    for (var parentSuite = this.parentSuite; parentSuite; parentSuite = parentSuite.parentSuite) {\n+      if (parentSuite.parentSuite) {\n+        fullName = parentSuite.description + ' ' + fullName;\n+      }\n+    }\n+    return fullName;\n+  };\n+\n+  Suite.prototype.disable = function() {\n+    this.disabled = true;\n+  };\n+\n+  Suite.prototype.beforeEach = function(fn) {\n+    this.beforeFns.unshift(fn);\n+  };\n+\n+  Suite.prototype.afterEach = function(fn) {\n+    this.afterFns.unshift(fn);\n+  };\n+\n+  Suite.prototype.addChild = function(child) {\n+    this.children.push(child);\n+  };\n+\n+  Suite.prototype.execute = function(onComplete) {\n+    var self = this;\n+    if (this.disabled) {\n+      complete();\n+      return;\n+    }\n+\n+    var allFns = [];\n+\n+    for (var i = 0; i < this.children.length; i++) {\n+      allFns.push(wrapChildAsAsync(this.children[i]));\n+    }\n+\n+    this.onStart(this);\n+\n+    this.queueRunner({\n+      fns: allFns,\n+      onComplete: complete\n+    });\n+\n+    function complete() {\n+      self.resultCallback(self.result);\n+\n+      if (onComplete) {\n+        onComplete();\n+      }\n+    }\n+\n+    function wrapChildAsAsync(child) {\n+      return function(done) { child.execute(done); };\n+    }\n+  };\n+\n+  return Suite;\n+};\n+\n+if (typeof window == void 0 && typeof exports == 'object') {\n+  exports.Suite = jasmineRequire.Suite;\n+}\n+\n+getJasmineRequireObj().Timer = function() {\n+  var defaultNow = (function(Date) {\n+    return function() { return new Date().getTime(); };\n+  })(Date);\n+\n+  function Timer(options) {\n+    options = options || {};\n+\n+    var now = options.now || defaultNow,\n+      startTime;\n+\n+    this.start = function() {\n+      startTime = now();\n+    };\n+\n+    this.elapsed = function() {\n+      return now() - startTime;\n+    };\n+  }\n+\n+  return Timer;\n+};\n+\n+getJasmineRequireObj().matchersUtil = function(j$) {\n+  // TODO: what to do about jasmine.pp not being inject? move to JSON.stringify? gut PrettyPrinter?\n+\n+  return {\n+    equals: function(a, b, customTesters) {\n+      customTesters = customTesters || [];\n+\n+      return eq(a, b, [], [], customTesters);\n+    },\n+\n+    contains: function(haystack, needle, customTesters) {\n+      customTesters = customTesters || [];\n+\n+      if (Object.prototype.toString.apply(haystack) === '[object Array]') {\n+        for (var i = 0; i < haystack.length; i++) {\n+          if (eq(haystack[i], needle, [], [], customTesters)) {\n+            return true;\n+          }\n+        }\n+        return false;\n+      }\n+      return !!haystack && haystack.indexOf(needle) >= 0;\n+    },\n+\n+    buildFailureMessage: function() {\n+      var args = Array.prototype.slice.call(arguments, 0),\n+        matcherName = args[0],\n+        isNot = args[1],\n+        actual = args[2],\n+        expected = args.slice(3),\n+        englishyPredicate = matcherName.replace(/[A-Z]/g, function(s) { return ' ' + s.toLowerCase(); });\n+\n+      var message = 'Expected ' +\n+        j$.pp(actual) +\n+        (isNot ? ' not ' : ' ') +\n+        englishyPredicate;\n+\n+      if (expected.length > 0) {\n+        for (var i = 0; i < expected.length; i++) {\n+          if (i > 0) {\n+            message += ',';\n+          }\n+          message += ' ' + j$.pp(expected[i]);\n+        }\n+      }\n+\n+      return message + '.';\n+    }\n+  };\n+\n+  // Equality function lovingly adapted from isEqual in\n+  //   [Underscore](http://underscorejs.org)\n+  function eq(a, b, aStack, bStack, customTesters) {\n+    var result = true;\n+\n+    for (var i = 0; i < customTesters.length; i++) {\n+      var customTesterResult = customTesters[i](a, b);\n+      if (!j$.util.isUndefined(customTesterResult)) {\n+        return customTesterResult;\n+      }\n+    }\n+\n+    if (a instanceof j$.Any) {\n+      result = a.jasmineMatches(b);\n+      if (result) {\n+        return true;\n+      }\n+    }\n+\n+    if (b instanceof j$.Any) {\n+      result = b.jasmineMatches(a);\n+      if (result) {\n+        return true;\n+      }\n+    }\n+\n+    if (b instanceof j$.ObjectContaining) {\n+      result = b.jasmineMatches(a);\n+      if (result) {\n+        return true;\n+      }\n+    }\n+\n+    if (a instanceof Error && b instanceof Error) {\n+      return a.message == b.message;\n+    }\n+\n+    // Identical objects are equal. `0 === -0`, but they aren't identical.\n+    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).\n+    if (a === b) { return a !== 0 || 1 / a == 1 / b; }\n+    // A strict comparison is necessary because `null == undefined`.\n+    if (a === null || b === null) { return a === b; }\n+    var className = Object.prototype.toString.call(a);\n+    if (className != Object.prototype.toString.call(b)) { return false; }\n+    switch (className) {\n+      // Strings, numbers, dates, and booleans are compared by value.\n+      case '[object String]':\n+        // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n+        // equivalent to `new String(\"5\")`.\n+        return a == String(b);\n+      case '[object Number]':\n+        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for\n+        // other numeric values.\n+        return a != +a ? b != +b : (a === 0 ? 1 / a == 1 / b : a == +b);\n+      case '[object Date]':\n+      case '[object Boolean]':\n+        // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n+        // millisecond representations. Note that invalid dates with millisecond representations\n+        // of `NaN` are not equivalent.\n+        return +a == +b;\n+      // RegExps are compared by their source patterns and flags.\n+      case '[object RegExp]':\n+        return a.source == b.source &&\n+          a.global == b.global &&\n+          a.multiline == b.multiline &&\n+          a.ignoreCase == b.ignoreCase;\n+    }\n+    if (typeof a != 'object' || typeof b != 'object') { return false; }\n+    // Assume equality for cyclic structures. The algorithm for detecting cyclic\n+    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n+    var length = aStack.length;\n+    while (length--) {\n+      // Linear search. Performance is inversely proportional to the number of\n+      // unique nested structures.\n+      if (aStack[length] == a) { return bStack[length] == b; }\n+    }\n+    // Add the first object to the stack of traversed objects.\n+    aStack.push(a);\n+    bStack.push(b);\n+    var size = 0;\n+    // Recursively compare objects and arrays.\n+    if (className == '[object Array]') {\n+      // Compare array lengths to determine if a deep comparison is necessary.\n+      size = a.length;\n+      result = size == b.length;\n+      if (result) {\n+        // Deep compare the contents, ignoring non-numeric properties.\n+        while (size--) {\n+          if (!(result = eq(a[size], b[size], aStack, bStack, customTesters))) { break; }\n+        }\n+      }\n+    } else {\n+      // Objects with different constructors are not equivalent, but `Object`s\n+      // from different frames are.\n+      var aCtor = a.constructor, bCtor = b.constructor;\n+      if (aCtor !== bCtor && !(isFunction(aCtor) && (aCtor instanceof aCtor) &&\n+        isFunction(bCtor) && (bCtor instanceof bCtor))) {\n+        return false;\n+      }\n+      // Deep compare objects.\n+      for (var key in a) {\n+        if (has(a, key)) {\n+          // Count the expected number of properties.\n+          size++;\n+          // Deep compare each member.\n+          if (!(result = has(b, key) && eq(a[key], b[key], aStack, bStack, customTesters))) { break; }\n+        }\n+      }\n+      // Ensure that both objects contain the same number of properties.\n+      if (result) {\n+        for (key in b) {\n+          if (has(b, key) && !(size--)) { break; }\n+        }\n+        result = !size;\n+      }\n+    }\n+    // Remove the first object from the stack of traversed objects.\n+    aStack.pop();\n+    bStack.pop();\n+\n+    return result;\n+\n+    function has(obj, key) {\n+      return obj.hasOwnProperty(key);\n+    }\n+\n+    function isFunction(obj) {\n+      return typeof obj === 'function';\n+    }\n+  }\n+};\n+\n+getJasmineRequireObj().toBe = function() {\n+  function toBe() {\n+    return {\n+      compare: function(actual, expected) {\n+        return {\n+          pass: actual === expected\n+        };\n+      }\n+    };\n+  }\n+\n+  return toBe;\n+};\n+\n+getJasmineRequireObj().toBeCloseTo = function() {\n+\n+  function toBeCloseTo() {\n+    return {\n+      compare: function(actual, expected, precision) {\n+        if (precision !== 0) {\n+          precision = precision || 2;\n+        }\n+\n+        return {\n+          pass: Math.abs(expected - actual) < (Math.pow(10, -precision) / 2)\n+        };\n+      }\n+    };\n+  }\n+\n+  return toBeCloseTo;\n+};\n+\n+getJasmineRequireObj().toBeDefined = function() {\n+  function toBeDefined() {\n+    return {\n+      compare: function(actual) {\n+        return {\n+          pass: (void 0 !== actual)\n+        };\n+      }\n+    };\n+  }\n+\n+  return toBeDefined;\n+};\n+\n+getJasmineRequireObj().toBeFalsy = function() {\n+  function toBeFalsy() {\n+    return {\n+      compare: function(actual) {\n+        return {\n+          pass: !!!actual\n+        };\n+      }\n+    };\n+  }\n+\n+  return toBeFalsy;\n+};\n+\n+getJasmineRequireObj().toBeGreaterThan = function() {\n+\n+  function toBeGreaterThan() {\n+    return {\n+      compare: function(actual, expected) {\n+        return {\n+          pass: actual > expected\n+        };\n+      }\n+    };\n+  }\n+\n+  return toBeGreaterThan;\n+};\n+\n+\n+getJasmineRequireObj().toBeLessThan = function() {\n+  function toBeLessThan() {\n+    return {\n+\n+      compare: function(actual, expected) {\n+        return {\n+          pass: actual < expected\n+        };\n+      }\n+    };\n+  }\n+\n+  return toBeLessThan;\n+};\n+getJasmineRequireObj().toBeNaN = function(j$) {\n+\n+  function toBeNaN() {\n+    return {\n+      compare: function(actual) {\n+        var result = {\n+          pass: (actual !== actual)\n+        };\n+\n+        if (result.pass) {\n+          result.message = 'Expected actual not to be NaN.';\n+        } else {\n+          result.message = function() { return 'Expected ' + j$.pp(actual) + ' to be NaN.'; };\n+        }\n+\n+        return result;\n+      }\n+    };\n+  }\n+\n+  return toBeNaN;\n+};\n+\n+getJasmineRequireObj().toBeNull = function() {\n+\n+  function toBeNull() {\n+    return {\n+      compare: function(actual) {\n+        return {\n+          pass: actual === null\n+        };\n+      }\n+    };\n+  }\n+\n+  return toBeNull;\n+};\n+\n+getJasmineRequireObj().toBeTruthy = function() {\n+\n+  function toBeTruthy() {\n+    return {\n+      compare: function(actual) {\n+        return {\n+          pass: !!actual\n+        };\n+      }\n+    };\n+  }\n+\n+  return toBeTruthy;\n+};\n+\n+getJasmineRequireObj().toBeUndefined = function() {\n+\n+  function toBeUndefined() {\n+    return {\n+      compare: function(actual) {\n+        return {\n+          pass: void 0 === actual\n+        };\n+      }\n+    };\n+  }\n+\n+  return toBeUndefined;\n+};\n+\n+getJasmineRequireObj().toContain = function() {\n+  function toContain(util, customEqualityTesters) {\n+    customEqualityTesters = customEqualityTesters || [];\n+\n+    return {\n+      compare: function(actual, expected) {\n+\n+        return {\n+          pass: util.contains(actual, expected, customEqualityTesters)\n+        };\n+      }\n+    };\n+  }\n+\n+  return toContain;\n+};\n+\n+getJasmineRequireObj().toEqual = function() {\n+\n+  function toEqual(util, customEqualityTesters) {\n+    customEqualityTesters = customEqualityTesters || [];\n+\n+    return {\n+      compare: function(actual, expected) {\n+        var result = {\n+          pass: false\n+        };\n+\n+        result.pass = util.equals(actual, expected, customEqualityTesters);\n+\n+        return result;\n+      }\n+    };\n+  }\n+\n+  return toEqual;\n+};\n+\n+getJasmineRequireObj().toHaveBeenCalled = function(j$) {\n+\n+  function toHaveBeenCalled() {\n+    return {\n+      compare: function(actual) {\n+        var result = {};\n+\n+        if (!j$.isSpy(actual)) {\n+          throw new Error('Expected a spy, but got ' + j$.pp(actual) + '.');\n+        }\n+\n+        if (arguments.length > 1) {\n+          throw new Error('toHaveBeenCalled does not take arguments, use toHaveBeenCalledWith');\n+        }\n+\n+        result.pass = actual.calls.any();\n+\n+        result.message = result.pass ?\n+          'Expected spy ' + actual.and.identity() + ' not to have been called.' :\n+          'Expected spy ' + actual.and.identity() + ' to have been called.';\n+\n+        return result;\n+      }\n+    };\n+  }\n+\n+  return toHaveBeenCalled;\n+};\n+\n+getJasmineRequireObj().toHaveBeenCalledWith = function(j$) {\n+\n+  function toHaveBeenCalledWith(util, customEqualityTesters) {\n+    return {\n+      compare: function() {\n+        var args = Array.prototype.slice.call(arguments, 0),\n+          actual = args[0],\n+          expectedArgs = args.slice(1),\n+          result = { pass: false };\n+\n+        if (!j$.isSpy(actual)) {\n+          throw new Error('Expected a spy, but got ' + j$.pp(actual) + '.');\n+        }\n+\n+        if (!actual.calls.any()) {\n+          result.message = function() { return 'Expected spy ' + actual.and.identity() + ' to have been called with ' + j$.pp(expectedArgs) + ' but it was never called.'; };\n+          return result;\n+        }\n+\n+        if (util.contains(actual.calls.allArgs(), expectedArgs, customEqualityTesters)) {\n+          result.pass = true;\n+          result.message = function() { return 'Expected spy ' + actual.and.identity() + ' not to have been called with ' + j$.pp(expectedArgs) + ' but it was.'; };\n+        } else {\n+          result.message = function() { return 'Expected spy ' + actual.and.identity() + ' to have been called with ' + j$.pp(expectedArgs) + ' but actual calls were ' + j$.pp(actual.calls.allArgs()).replace(/^\\[ | \\]$/g, '') + '.'; };\n+        }\n+\n+        return result;\n+      }\n+    };\n+  }\n+\n+  return toHaveBeenCalledWith;\n+};\n+\n+getJasmineRequireObj().toMatch = function() {\n+\n+  function toMatch() {\n+    return {\n+      compare: function(actual, expected) {\n+        var regexp = new RegExp(expected);\n+\n+        return {\n+          pass: regexp.test(actual)\n+        };\n+      }\n+    };\n+  }\n+\n+  return toMatch;\n+};\n+\n+getJasmineRequireObj().toThrow = function(j$) {\n+\n+  function toThrow(util) {\n+    return {\n+      compare: function(actual, expected) {\n+        var result = { pass: false },\n+          threw = false,\n+          thrown;\n+\n+        if (typeof actual != 'function') {\n+          throw new Error('Actual is not a Function');\n+        }\n+\n+        try {\n+          actual();\n+        } catch (e) {\n+          threw = true;\n+          thrown = e;\n+        }\n+\n+        if (!threw) {\n+          result.message = 'Expected function to throw an exception.';\n+          return result;\n+        }\n+\n+        if (arguments.length == 1) {\n+          result.pass = true;\n+          result.message = function() { return 'Expected function not to throw, but it threw ' + j$.pp(thrown) + '.'; };\n+\n+          return result;\n+        }\n+\n+        if (util.equals(thrown, expected)) {\n+          result.pass = true;\n+          result.message = function() { return 'Expected function not to throw ' + j$.pp(expected) + '.'; };\n+        } else {\n+          result.message = function() { return 'Expected function to throw ' + j$.pp(expected) + ', but it threw ' +  j$.pp(thrown) + '.'; };\n+        }\n+\n+        return result;\n+      }\n+    };\n+  }\n+\n+  return toThrow;\n+};\n+\n+getJasmineRequireObj().toThrowError = function(j$) {\n+  function toThrowError (util) {\n+    return {\n+      compare: function(actual) {\n+        var threw = false,\n+          pass = {pass: true},\n+          fail = {pass: false},\n+          thrown,\n+          errorType,\n+          message,\n+          regexp,\n+          name,\n+          constructorName;\n+\n+        if (typeof actual != 'function') {\n+          throw new Error('Actual is not a Function');\n+        }\n+\n+        extractExpectedParams.apply(null, arguments);\n+\n+        try {\n+          actual();\n+        } catch (e) {\n+          threw = true;\n+          thrown = e;\n+        }\n+\n+        if (!threw) {\n+          fail.message = 'Expected function to throw an Error.';\n+          return fail;\n+        }\n+\n+        if (!(thrown instanceof Error)) {\n+          fail.message = function() { return 'Expected function to throw an Error, but it threw ' + j$.pp(thrown) + '.'; };\n+          return fail;\n+        }\n+\n+        if (arguments.length == 1) {\n+          pass.message = 'Expected function not to throw an Error, but it threw ' + fnNameFor(thrown) + '.';\n+          return pass;\n+        }\n+\n+        if (errorType) {\n+          name = fnNameFor(errorType);\n+          constructorName = fnNameFor(thrown.constructor);\n+        }\n+\n+        if (errorType && message) {\n+          if (thrown.constructor == errorType && util.equals(thrown.message, message)) {\n+            pass.message = function() { return 'Expected function not to throw ' + name + ' with message ' + j$.pp(message) + '.'; };\n+            return pass;\n+          } else {\n+            fail.message = function() { return 'Expected function to throw ' + name + ' with message ' + j$.pp(message) +\n+              ', but it threw ' + constructorName + ' with message ' + j$.pp(thrown.message) + '.'; };\n+            return fail;\n+          }\n+        }\n+\n+        if (errorType && regexp) {\n+          if (thrown.constructor == errorType && regexp.test(thrown.message)) {\n+            pass.message = function() { return 'Expected function not to throw ' + name + ' with message matching ' + j$.pp(regexp) + '.'; };\n+            return pass;\n+          } else {\n+            fail.message = function() { return 'Expected function to throw ' + name + ' with message matching ' + j$.pp(regexp) +\n+              ', but it threw ' + constructorName + ' with message ' + j$.pp(thrown.message) + '.'; };\n+            return fail;\n+          }\n+        }\n+\n+        if (errorType) {\n+          if (thrown.constructor == errorType) {\n+            pass.message = 'Expected function not to throw ' + name + '.';\n+            return pass;\n+          } else {\n+            fail.message = 'Expected function to throw ' + name + ', but it threw ' + constructorName + '.';\n+            return fail;\n+          }\n+        }\n+\n+        if (message) {\n+          if (thrown.message == message) {\n+            pass.message = function() { return 'Expected function not to throw an exception with message ' + j$.pp(message) + '.'; };\n+            return pass;\n+          } else {\n+            fail.message = function() { return 'Expected function to throw an exception with message ' + j$.pp(message) +\n+              ', but it threw an exception with message ' + j$.pp(thrown.message) + '.'; };\n+            return fail;\n+          }\n+        }\n+\n+        if (regexp) {\n+          if (regexp.test(thrown.message)) {\n+            pass.message = function() { return 'Expected function not to throw an exception with a message matching ' + j$.pp(regexp) + '.'; };\n+            return pass;\n+          } else {\n+            fail.message = function() { return 'Expected function to throw an exception with a message matching ' + j$.pp(regexp) +\n+              ', but it threw an exception with message ' + j$.pp(thrown.message) + '.'; };\n+            return fail;\n+          }\n+        }\n+\n+        function fnNameFor(func) {\n+            return func.name || func.toString().match(/^\\s*function\\s*(\\w*)\\s*\\(/)[1];\n+        }\n+\n+        function extractExpectedParams() {\n+          if (arguments.length == 1) {\n+            return;\n+          }\n+\n+          if (arguments.length == 2) {\n+            var expected = arguments[1];\n+\n+            if (expected instanceof RegExp) {\n+              regexp = expected;\n+            } else if (typeof expected == 'string') {\n+              message = expected;\n+            } else if (checkForAnErrorType(expected)) {\n+              errorType = expected;\n+            }\n+\n+            if (!(errorType || message || regexp)) {\n+              throw new Error('Expected is not an Error, string, or RegExp.');\n+            }\n+          } else {\n+            if (checkForAnErrorType(arguments[1])) {\n+              errorType = arguments[1];\n+            } else {\n+              throw new Error('Expected error type is not an Error.');\n+            }\n+\n+            if (arguments[2] instanceof RegExp) {\n+              regexp = arguments[2];\n+            } else if (typeof arguments[2] == 'string') {\n+              message = arguments[2];\n+            } else {\n+              throw new Error('Expected error message is not a string or RegExp.');\n+            }\n+          }\n+        }\n+\n+        function checkForAnErrorType(type) {\n+          if (typeof type !== 'function') {\n+            return false;\n+          }\n+\n+          var Surrogate = function() {};\n+          Surrogate.prototype = type.prototype;\n+          return (new Surrogate()) instanceof Error;\n+        }\n+      }\n+    };\n+  }\n+\n+  return toThrowError;\n+};\n+\n+getJasmineRequireObj().version = function() {\n+  return '2.0.1';\n+};\n\\ No newline at end of file\ndiff --git a/resources/libs/jasmine/jasmine_favicon.png b/resources/libs/jasmine/jasmine_favicon.png\nnew file mode 100644\nindex 0000000..3b84583\nBinary files /dev/null and b/resources/libs/jasmine/jasmine_favicon.png differ\ndiff --git a/resources/libs/jquery-2.1.1.js b/resources/libs/jquery-2.1.1.js\nnew file mode 100644\nindex 0000000..3a06706\n--- /dev/null\n+++ b/resources/libs/jquery-2.1.1.js\n@@ -0,0 +1,9190 @@\n+/*!\n+ * jQuery JavaScript Library v2.1.1\n+ * http://jquery.com/\n+ *\n+ * Includes Sizzle.js\n+ * http://sizzlejs.com/\n+ *\n+ * Copyright 2005, 2014 jQuery Foundation, Inc. and other contributors\n+ * Released under the MIT license\n+ * http://jquery.org/license\n+ *\n+ * Date: 2014-05-01T17:11Z\n+ */\n+\n+(function( global, factory ) {\n+\n+  if ( typeof module === \"object\" && typeof module.exports === \"object\" ) {\n+    // For CommonJS and CommonJS-like environments where a proper window is present,\n+    // execute the factory and get jQuery\n+    // For environments that do not inherently posses a window with a document\n+    // (such as Node.js), expose a jQuery-making factory as module.exports\n+    // This accentuates the need for the creation of a real window\n+    // e.g. var jQuery = require(\"jquery\")(window);\n+    // See ticket #14549 for more info\n+    module.exports = global.document ?\n+      factory( global, true ) :\n+      function( w ) {\n+        if ( !w.document ) {\n+          throw new Error( \"jQuery requires a window with a document\" );\n+        }\n+        return factory( w );\n+      };\n+  } else {\n+    factory( global );\n+  }\n+\n+// Pass this if window is not defined yet\n+}(typeof window !== \"undefined\" ? window : this, function( window, noGlobal ) {\n+\n+// Can't do this because several apps including ASP.NET trace\n+// the stack via arguments.caller.callee and Firefox dies if\n+// you try to trace through \"use strict\" call chains. (#13335)\n+// Support: Firefox 18+\n+//\n+\n+var arr = [];\n+\n+var slice = arr.slice;\n+\n+var concat = arr.concat;\n+\n+var push = arr.push;\n+\n+var indexOf = arr.indexOf;\n+\n+var class2type = {};\n+\n+var toString = class2type.toString;\n+\n+var hasOwn = class2type.hasOwnProperty;\n+\n+var support = {};\n+\n+\n+\n+var\n+  // Use the correct document accordingly with window argument (sandbox)\n+  document = window.document,\n+\n+  version = \"2.1.1\",\n+\n+  // Define a local copy of jQuery\n+  jQuery = function( selector, context ) {\n+    // The jQuery object is actually just the init constructor 'enhanced'\n+    // Need init if jQuery is called (just allow error to be thrown if not included)\n+    return new jQuery.fn.init( selector, context );\n+  },\n+\n+  // Support: Android<4.1\n+  // Make sure we trim BOM and NBSP\n+  rtrim = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g,\n+\n+  // Matches dashed string for camelizing\n+  rmsPrefix = /^-ms-/,\n+  rdashAlpha = /-([\\da-z])/gi,\n+\n+  // Used by jQuery.camelCase as callback to replace()\n+  fcamelCase = function( all, letter ) {\n+    return letter.toUpperCase();\n+  };\n+\n+jQuery.fn = jQuery.prototype = {\n+  // The current version of jQuery being used\n+  jquery: version,\n+\n+  constructor: jQuery,\n+\n+  // Start with an empty selector\n+  selector: \"\",\n+\n+  // The default length of a jQuery object is 0\n+  length: 0,\n+\n+  toArray: function() {\n+    return slice.call( this );\n+  },\n+\n+  // Get the Nth element in the matched element set OR\n+  // Get the whole matched element set as a clean array\n+  get: function( num ) {\n+    return num != null ?\n+\n+      // Return just the one element from the set\n+      ( num < 0 ? this[ num + this.length ] : this[ num ] ) :\n+\n+      // Return all the elements in a clean array\n+      slice.call( this );\n+  },\n+\n+  // Take an array of elements and push it onto the stack\n+  // (returning the new matched element set)\n+  pushStack: function( elems ) {\n+\n+    // Build a new jQuery matched element set\n+    var ret = jQuery.merge( this.constructor(), elems );\n+\n+    // Add the old object onto the stack (as a reference)\n+    ret.prevObject = this;\n+    ret.context = this.context;\n+\n+    // Return the newly-formed element set\n+    return ret;\n+  },\n+\n+  // Execute a callback for every element in the matched set.\n+  // (You can seed the arguments with an array of args, but this is\n+  // only used internally.)\n+  each: function( callback, args ) {\n+    return jQuery.each( this, callback, args );\n+  },\n+\n+  map: function( callback ) {\n+    return this.pushStack( jQuery.map(this, function( elem, i ) {\n+      return callback.call( elem, i, elem );\n+    }));\n+  },\n+\n+  slice: function() {\n+    return this.pushStack( slice.apply( this, arguments ) );\n+  },\n+\n+  first: function() {\n+    return this.eq( 0 );\n+  },\n+\n+  last: function() {\n+    return this.eq( -1 );\n+  },\n+\n+  eq: function( i ) {\n+    var len = this.length,\n+      j = +i + ( i < 0 ? len : 0 );\n+    return this.pushStack( j >= 0 && j < len ? [ this[j] ] : [] );\n+  },\n+\n+  end: function() {\n+    return this.prevObject || this.constructor(null);\n+  },\n+\n+  // For internal use only.\n+  // Behaves like an Array's method, not like a jQuery method.\n+  push: push,\n+  sort: arr.sort,\n+  splice: arr.splice\n+};\n+\n+jQuery.extend = jQuery.fn.extend = function() {\n+  var options, name, src, copy, copyIsArray, clone,\n+    target = arguments[0] || {},\n+    i = 1,\n+    length = arguments.length,\n+    deep = false;\n+\n+  // Handle a deep copy situation\n+  if ( typeof target === \"boolean\" ) {\n+    deep = target;\n+\n+    // skip the boolean and the target\n+    target = arguments[ i ] || {};\n+    i++;\n+  }\n+\n+  // Handle case when target is a string or something (possible in deep copy)\n+  if ( typeof target !== \"object\" && !jQuery.isFunction(target) ) {\n+    target = {};\n+  }\n+\n+  // extend jQuery itself if only one argument is passed\n+  if ( i === length ) {\n+    target = this;\n+    i--;\n+  }\n+\n+  for ( ; i < length; i++ ) {\n+    // Only deal with non-null/undefined values\n+    if ( (options = arguments[ i ]) != null ) {\n+      // Extend the base object\n+      for ( name in options ) {\n+        src = target[ name ];\n+        copy = options[ name ];\n+\n+        // Prevent never-ending loop\n+        if ( target === copy ) {\n+          continue;\n+        }\n+\n+        // Recurse if we're merging plain objects or arrays\n+        if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {\n+          if ( copyIsArray ) {\n+            copyIsArray = false;\n+            clone = src && jQuery.isArray(src) ? src : [];\n+\n+          } else {\n+            clone = src && jQuery.isPlainObject(src) ? src : {};\n+          }\n+\n+          // Never move original objects, clone them\n+          target[ name ] = jQuery.extend( deep, clone, copy );\n+\n+        // Don't bring in undefined values\n+        } else if ( copy !== undefined ) {\n+          target[ name ] = copy;\n+        }\n+      }\n+    }\n+  }\n+\n+  // Return the modified object\n+  return target;\n+};\n+\n+jQuery.extend({\n+  // Unique for each copy of jQuery on the page\n+  expando: \"jQuery\" + ( version + Math.random() ).replace( /\\D/g, \"\" ),\n+\n+  // Assume jQuery is ready without the ready module\n+  isReady: true,\n+\n+  error: function( msg ) {\n+    throw new Error( msg );\n+  },\n+\n+  noop: function() {},\n+\n+  // See test/unit/core.js for details concerning isFunction.\n+  // Since version 1.3, DOM methods and functions like alert\n+  // aren't supported. They return false on IE (#2968).\n+  isFunction: function( obj ) {\n+    return jQuery.type(obj) === \"function\";\n+  },\n+\n+  isArray: Array.isArray,\n+\n+  isWindow: function( obj ) {\n+    return obj != null && obj === obj.window;\n+  },\n+\n+  isNumeric: function( obj ) {\n+    // parseFloat NaNs numeric-cast false positives (null|true|false|\"\")\n+    // ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n+    // subtraction forces infinities to NaN\n+    return !jQuery.isArray( obj ) && obj - parseFloat( obj ) >= 0;\n+  },\n+\n+  isPlainObject: function( obj ) {\n+    // Not plain objects:\n+    // - Any object or value whose internal [[Class]] property is not \"[object Object]\"\n+    // - DOM nodes\n+    // - window\n+    if ( jQuery.type( obj ) !== \"object\" || obj.nodeType || jQuery.isWindow( obj ) ) {\n+      return false;\n+    }\n+\n+    if ( obj.constructor &&\n+        !hasOwn.call( obj.constructor.prototype, \"isPrototypeOf\" ) ) {\n+      return false;\n+    }\n+\n+    // If the function hasn't returned already, we're confident that\n+    // |obj| is a plain object, created by {} or constructed with new Object\n+    return true;\n+  },\n+\n+  isEmptyObject: function( obj ) {\n+    var name;\n+    for ( name in obj ) {\n+      return false;\n+    }\n+    return true;\n+  },\n+\n+  type: function( obj ) {\n+    if ( obj == null ) {\n+      return obj + \"\";\n+    }\n+    // Support: Android < 4.0, iOS < 6 (functionish RegExp)\n+    return typeof obj === \"object\" || typeof obj === \"function\" ?\n+      class2type[ toString.call(obj) ] || \"object\" :\n+      typeof obj;\n+  },\n+\n+  // Evaluates a script in a global context\n+  globalEval: function( code ) {\n+    var script,\n+      indirect = eval;\n+\n+    code = jQuery.trim( code );\n+\n+    if ( code ) {\n+      // If the code includes a valid, prologue position\n+      // strict mode pragma, execute code by injecting a\n+      // script tag into the document.\n+      if ( code.indexOf(\"use strict\") === 1 ) {\n+        script = document.createElement(\"script\");\n+        script.text = code;\n+        document.head.appendChild( script ).parentNode.removeChild( script );\n+      } else {\n+      // Otherwise, avoid the DOM node creation, insertion\n+      // and removal by using an indirect global eval\n+        indirect( code );\n+      }\n+    }\n+  },\n+\n+  // Convert dashed to camelCase; used by the css and data modules\n+  // Microsoft forgot to hump their vendor prefix (#9572)\n+  camelCase: function( string ) {\n+    return string.replace( rmsPrefix, \"ms-\" ).replace( rdashAlpha, fcamelCase );\n+  },\n+\n+  nodeName: function( elem, name ) {\n+    return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();\n+  },\n+\n+  // args is for internal usage only\n+  each: function( obj, callback, args ) {\n+    var value,\n+      i = 0,\n+      length = obj.length,\n+      isArray = isArraylike( obj );\n+\n+    if ( args ) {\n+      if ( isArray ) {\n+        for ( ; i < length; i++ ) {\n+          value = callback.apply( obj[ i ], args );\n+\n+          if ( value === false ) {\n+            break;\n+          }\n+        }\n+      } else {\n+        for ( i in obj ) {\n+          value = callback.apply( obj[ i ], args );\n+\n+          if ( value === false ) {\n+            break;\n+          }\n+        }\n+      }\n+\n+    // A special, fast, case for the most common use of each\n+    } else {\n+      if ( isArray ) {\n+        for ( ; i < length; i++ ) {\n+          value = callback.call( obj[ i ], i, obj[ i ] );\n+\n+          if ( value === false ) {\n+            break;\n+          }\n+        }\n+      } else {\n+        for ( i in obj ) {\n+          value = callback.call( obj[ i ], i, obj[ i ] );\n+\n+          if ( value === false ) {\n+            break;\n+          }\n+        }\n+      }\n+    }\n+\n+    return obj;\n+  },\n+\n+  // Support: Android<4.1\n+  trim: function( text ) {\n+    return text == null ?\n+      \"\" :\n+      ( text + \"\" ).replace( rtrim, \"\" );\n+  },\n+\n+  // results is for internal usage only\n+  makeArray: function( arr, results ) {\n+    var ret = results || [];\n+\n+    if ( arr != null ) {\n+      if ( isArraylike( Object(arr) ) ) {\n+        jQuery.merge( ret,\n+          typeof arr === \"string\" ?\n+          [ arr ] : arr\n+        );\n+      } else {\n+        push.call( ret, arr );\n+      }\n+    }\n+\n+    return ret;\n+  },\n+\n+  inArray: function( elem, arr, i ) {\n+    return arr == null ? -1 : indexOf.call( arr, elem, i );\n+  },\n+\n+  merge: function( first, second ) {\n+    var len = +second.length,\n+      j = 0,\n+      i = first.length;\n+\n+    for ( ; j < len; j++ ) {\n+      first[ i++ ] = second[ j ];\n+    }\n+\n+    first.length = i;\n+\n+    return first;\n+  },\n+\n+  grep: function( elems, callback, invert ) {\n+    var callbackInverse,\n+      matches = [],\n+      i = 0,\n+      length = elems.length,\n+      callbackExpect = !invert;\n+\n+    // Go through the array, only saving the items\n+    // that pass the validator function\n+    for ( ; i < length; i++ ) {\n+      callbackInverse = !callback( elems[ i ], i );\n+      if ( callbackInverse !== callbackExpect ) {\n+        matches.push( elems[ i ] );\n+      }\n+    }\n+\n+    return matches;\n+  },\n+\n+  // arg is for internal usage only\n+  map: function( elems, callback, arg ) {\n+    var value,\n+      i = 0,\n+      length = elems.length,\n+      isArray = isArraylike( elems ),\n+      ret = [];\n+\n+    // Go through the array, translating each of the items to their new values\n+    if ( isArray ) {\n+      for ( ; i < length; i++ ) {\n+        value = callback( elems[ i ], i, arg );\n+\n+        if ( value != null ) {\n+          ret.push( value );\n+        }\n+      }\n+\n+    // Go through every key on the object,\n+    } else {\n+      for ( i in elems ) {\n+        value = callback( elems[ i ], i, arg );\n+\n+        if ( value != null ) {\n+          ret.push( value );\n+        }\n+      }\n+    }\n+\n+    // Flatten any nested arrays\n+    return concat.apply( [], ret );\n+  },\n+\n+  // A global GUID counter for objects\n+  guid: 1,\n+\n+  // Bind a function to a context, optionally partially applying any\n+  // arguments.\n+  proxy: function( fn, context ) {\n+    var tmp, args, proxy;\n+\n+    if ( typeof context === \"string\" ) {\n+      tmp = fn[ context ];\n+      context = fn;\n+      fn = tmp;\n+    }\n+\n+    // Quick check to determine if target is callable, in the spec\n+    // this throws a TypeError, but we will just return undefined.\n+    if ( !jQuery.isFunction( fn ) ) {\n+      return undefined;\n+    }\n+\n+    // Simulated bind\n+    args = slice.call( arguments, 2 );\n+    proxy = function() {\n+      return fn.apply( context || this, args.concat( slice.call( arguments ) ) );\n+    };\n+\n+    // Set the guid of unique handler to the same of original handler, so it can be removed\n+    proxy.guid = fn.guid = fn.guid || jQuery.guid++;\n+\n+    return proxy;\n+  },\n+\n+  now: Date.now,\n+\n+  // jQuery.support is not used in Core but other projects attach their\n+  // properties to it so it needs to exist.\n+  support: support\n+});\n+\n+// Populate the class2type map\n+jQuery.each(\"Boolean Number String Function Array Date RegExp Object Error\".split(\" \"), function(i, name) {\n+  class2type[ \"[object \" + name + \"]\" ] = name.toLowerCase();\n+});\n+\n+function isArraylike( obj ) {\n+  var length = obj.length,\n+    type = jQuery.type( obj );\n+\n+  if ( type === \"function\" || jQuery.isWindow( obj ) ) {\n+    return false;\n+  }\n+\n+  if ( obj.nodeType === 1 && length ) {\n+    return true;\n+  }\n+\n+  return type === \"array\" || length === 0 ||\n+    typeof length === \"number\" && length > 0 && ( length - 1 ) in obj;\n+}\n+var Sizzle =\n+/*!\n+ * Sizzle CSS Selector Engine v1.10.19\n+ * http://sizzlejs.com/\n+ *\n+ * Copyright 2013 jQuery Foundation, Inc. and other contributors\n+ * Released under the MIT license\n+ * http://jquery.org/license\n+ *\n+ * Date: 2014-04-18\n+ */\n+(function( window ) {\n+\n+var i,\n+  support,\n+  Expr,\n+  getText,\n+  isXML,\n+  tokenize,\n+  compile,\n+  select,\n+  outermostContext,\n+  sortInput,\n+  hasDuplicate,\n+\n+  // Local document vars\n+  setDocument,\n+  document,\n+  docElem,\n+  documentIsHTML,\n+  rbuggyQSA,\n+  rbuggyMatches,\n+  matches,\n+  contains,\n+\n+  // Instance-specific data\n+  expando = \"sizzle\" + -(new Date()),\n+  preferredDoc = window.document,\n+  dirruns = 0,\n+  done = 0,\n+  classCache = createCache(),\n+  tokenCache = createCache(),\n+  compilerCache = createCache(),\n+  sortOrder = function( a, b ) {\n+    if ( a === b ) {\n+      hasDuplicate = true;\n+    }\n+    return 0;\n+  },\n+\n+  // General-purpose constants\n+  strundefined = typeof undefined,\n+  MAX_NEGATIVE = 1 << 31,\n+\n+  // Instance methods\n+  hasOwn = ({}).hasOwnProperty,\n+  arr = [],\n+  pop = arr.pop,\n+  push_native = arr.push,\n+  push = arr.push,\n+  slice = arr.slice,\n+  // Use a stripped-down indexOf if we can't use a native one\n+  indexOf = arr.indexOf || function( elem ) {\n+    var i = 0,\n+      len = this.length;\n+    for ( ; i < len; i++ ) {\n+      if ( this[i] === elem ) {\n+        return i;\n+      }\n+    }\n+    return -1;\n+  },\n+\n+  booleans = \"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\",\n+\n+  // Regular expressions\n+\n+  // Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace\n+  whitespace = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",\n+  // http://www.w3.org/TR/css3-syntax/#characters\n+  characterEncoding = \"(?:\\\\\\\\.|[\\\\w-]|[^\\\\x00-\\\\xa0])+\",\n+\n+  // Loosely modeled on CSS identifier characters\n+  // An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors\n+  // Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier\n+  identifier = characterEncoding.replace( \"w\", \"w#\" ),\n+\n+  // Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors\n+  attributes = \"\\\\[\" + whitespace + \"*(\" + characterEncoding + \")(?:\" + whitespace +\n+    // Operator (capture 2)\n+    \"*([*^$|!~]?=)\" + whitespace +\n+    // \"Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]\"\n+    \"*(?:'((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\"|(\" + identifier + \"))|)\" + whitespace +\n+    \"*\\\\]\",\n+\n+  pseudos = \":(\" + characterEncoding + \")(?:\\\\((\" +\n+    // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:\n+    // 1. quoted (capture 3; capture 4 or capture 5)\n+    \"('((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\")|\" +\n+    // 2. simple (capture 6)\n+    \"((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\" + attributes + \")*)|\" +\n+    // 3. anything else (capture 2)\n+    \".*\" +\n+    \")\\\\)|)\",\n+\n+  // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\n+  rtrim = new RegExp( \"^\" + whitespace + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" + whitespace + \"+$\", \"g\" ),\n+\n+  rcomma = new RegExp( \"^\" + whitespace + \"*,\" + whitespace + \"*\" ),\n+  rcombinators = new RegExp( \"^\" + whitespace + \"*([>+~]|\" + whitespace + \")\" + whitespace + \"*\" ),\n+\n+  rattributeQuotes = new RegExp( \"=\" + whitespace + \"*([^\\\\]'\\\"]*?)\" + whitespace + \"*\\\\]\", \"g\" ),\n+\n+  rpseudo = new RegExp( pseudos ),\n+  ridentifier = new RegExp( \"^\" + identifier + \"$\" ),\n+\n+  matchExpr = {\n+    \"ID\": new RegExp( \"^#(\" + characterEncoding + \")\" ),\n+    \"CLASS\": new RegExp( \"^\\\\.(\" + characterEncoding + \")\" ),\n+    \"TAG\": new RegExp( \"^(\" + characterEncoding.replace( \"w\", \"w*\" ) + \")\" ),\n+    \"ATTR\": new RegExp( \"^\" + attributes ),\n+    \"PSEUDO\": new RegExp( \"^\" + pseudos ),\n+    \"CHILD\": new RegExp( \"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\" + whitespace +\n+      \"*(even|odd|(([+-]|)(\\\\d*)n|)\" + whitespace + \"*(?:([+-]|)\" + whitespace +\n+      \"*(\\\\d+)|))\" + whitespace + \"*\\\\)|)\", \"i\" ),\n+    \"bool\": new RegExp( \"^(?:\" + booleans + \")$\", \"i\" ),\n+    // For use in libraries implementing .is()\n+    // We use this for POS matching in `select`\n+    \"needsContext\": new RegExp( \"^\" + whitespace + \"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\" +\n+      whitespace + \"*((?:-\\\\d)?\\\\d*)\" + whitespace + \"*\\\\)|)(?=[^-]|$)\", \"i\" )\n+  },\n+\n+  rinputs = /^(?:input|select|textarea|button)$/i,\n+  rheader = /^h\\d$/i,\n+\n+  rnative = /^[^{]+\\{\\s*\\[native \\w/,\n+\n+  // Easily-parseable/retrievable ID or TAG or CLASS selectors\n+  rquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n+\n+  rsibling = /[+~]/,\n+  rescape = /'|\\\\/g,\n+\n+  // CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\n+  runescape = new RegExp( \"\\\\\\\\([\\\\da-f]{1,6}\" + whitespace + \"?|(\" + whitespace + \")|.)\", \"ig\" ),\n+  funescape = function( _, escaped, escapedWhitespace ) {\n+    var high = \"0x\" + escaped - 0x10000;\n+    // NaN means non-codepoint\n+    // Support: Firefox<24\n+    // Workaround erroneous numeric interpretation of +\"0x\"\n+    return high !== high || escapedWhitespace ?\n+      escaped :\n+      high < 0 ?\n+        // BMP codepoint\n+        String.fromCharCode( high + 0x10000 ) :\n+        // Supplemental Plane codepoint (surrogate pair)\n+        String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );\n+  };\n+\n+// Optimize for push.apply( _, NodeList )\n+try {\n+  push.apply(\n+    (arr = slice.call( preferredDoc.childNodes )),\n+    preferredDoc.childNodes\n+  );\n+  // Support: Android<4.0\n+  // Detect silently failing push.apply\n+  arr[ preferredDoc.childNodes.length ].nodeType;\n+} catch ( e ) {\n+  push = { apply: arr.length ?\n+\n+    // Leverage slice if possible\n+    function( target, els ) {\n+      push_native.apply( target, slice.call(els) );\n+    } :\n+\n+    // Support: IE<9\n+    // Otherwise append directly\n+    function( target, els ) {\n+      var j = target.length,\n+        i = 0;\n+      // Can't trust NodeList.length\n+      while ( (target[j++] = els[i++]) ) {}\n+      target.length = j - 1;\n+    }\n+  };\n+}\n+\n+function Sizzle( selector, context, results, seed ) {\n+  var match, elem, m, nodeType,\n+    // QSA vars\n+    i, groups, old, nid, newContext, newSelector;\n+\n+  if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {\n+    setDocument( context );\n+  }\n+\n+  context = context || document;\n+  results = results || [];\n+\n+  if ( !selector || typeof selector !== \"string\" ) {\n+    return results;\n+  }\n+\n+  if ( (nodeType = context.nodeType) !== 1 && nodeType !== 9 ) {\n+    return [];\n+  }\n+\n+  if ( documentIsHTML && !seed ) {\n+\n+    // Shortcuts\n+    if ( (match = rquickExpr.exec( selector )) ) {\n+      // Speed-up: Sizzle(\"#ID\")\n+      if ( (m = match[1]) ) {\n+        if ( nodeType === 9 ) {\n+          elem = context.getElementById( m );\n+          // Check parentNode to catch when Blackberry 4.6 returns\n+          // nodes that are no longer in the document (jQuery #6963)\n+          if ( elem && elem.parentNode ) {\n+            // Handle the case where IE, Opera, and Webkit return items\n+            // by name instead of ID\n+            if ( elem.id === m ) {\n+              results.push( elem );\n+              return results;\n+            }\n+          } else {\n+            return results;\n+          }\n+        } else {\n+          // Context is not a document\n+          if ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&\n+            contains( context, elem ) && elem.id === m ) {\n+            results.push( elem );\n+            return results;\n+          }\n+        }\n+\n+      // Speed-up: Sizzle(\"TAG\")\n+      } else if ( match[2] ) {\n+        push.apply( results, context.getElementsByTagName( selector ) );\n+        return results;\n+\n+      // Speed-up: Sizzle(\".CLASS\")\n+      } else if ( (m = match[3]) && support.getElementsByClassName && context.getElementsByClassName ) {\n+        push.apply( results, context.getElementsByClassName( m ) );\n+        return results;\n+      }\n+    }\n+\n+    // QSA path\n+    if ( support.qsa && (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {\n+      nid = old = expando;\n+      newContext = context;\n+      newSelector = nodeType === 9 && selector;\n+\n+      // qSA works strangely on Element-rooted queries\n+      // We can work around this by specifying an extra ID on the root\n+      // and working up from there (Thanks to Andrew Dupont for the technique)\n+      // IE 8 doesn't work on object elements\n+      if ( nodeType === 1 && context.nodeName.toLowerCase() !== \"object\" ) {\n+        groups = tokenize( selector );\n+\n+        if ( (old = context.getAttribute(\"id\")) ) {\n+          nid = old.replace( rescape, \"\\\\$&\" );\n+        } else {\n+          context.setAttribute( \"id\", nid );\n+        }\n+        nid = \"[id='\" + nid + \"'] \";\n+\n+        i = groups.length;\n+        while ( i-- ) {\n+          groups[i] = nid + toSelector( groups[i] );\n+        }\n+        newContext = rsibling.test( selector ) && testContext( context.parentNode ) || context;\n+        newSelector = groups.join(\",\");\n+      }\n+\n+      if ( newSelector ) {\n+        try {\n+          push.apply( results,\n+            newContext.querySelectorAll( newSelector )\n+          );\n+          return results;\n+        } catch(qsaError) {\n+        } finally {\n+          if ( !old ) {\n+            context.removeAttribute(\"id\");\n+          }\n+        }\n+      }\n+    }\n+  }\n+\n+  // All others\n+  return select( selector.replace( rtrim, \"$1\" ), context, results, seed );\n+}\n+\n+/**\n+ * Create key-value caches of limited size\n+ * @returns {Function(string, Object)} Returns the Object data after storing it on itself with\n+ *  property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\n+ *  deleting the oldest entry\n+ */\n+function createCache() {\n+  var keys = [];\n+\n+  function cache( key, value ) {\n+    // Use (key + \" \") to avoid collision with native prototype properties (see Issue #157)\n+    if ( keys.push( key + \" \" ) > Expr.cacheLength ) {\n+      // Only keep the most recent entries\n+      delete cache[ keys.shift() ];\n+    }\n+    return (cache[ key + \" \" ] = value);\n+  }\n+  return cache;\n+}\n+\n+/**\n+ * Mark a function for special use by Sizzle\n+ * @param {Function} fn The function to mark\n+ */\n+function markFunction( fn ) {\n+  fn[ expando ] = true;\n+  return fn;\n+}\n+\n+/**\n+ * Support testing using an element\n+ * @param {Function} fn Passed the created div and expects a boolean result\n+ */\n+function assert( fn ) {\n+  var div = document.createElement(\"div\");\n+\n+  try {\n+    return !!fn( div );\n+  } catch (e) {\n+    return false;\n+  } finally {\n+    // Remove from its parent by default\n+    if ( div.parentNode ) {\n+      div.parentNode.removeChild( div );\n+    }\n+    // release memory in IE\n+    div = null;\n+  }\n+}\n+\n+/**\n+ * Adds the same handler for all of the specified attrs\n+ * @param {String} attrs Pipe-separated list of attributes\n+ * @param {Function} handler The method that will be applied\n+ */\n+function addHandle( attrs, handler ) {\n+  var arr = attrs.split(\"|\"),\n+    i = attrs.length;\n+\n+  while ( i-- ) {\n+    Expr.attrHandle[ arr[i] ] = handler;\n+  }\n+}\n+\n+/**\n+ * Checks document order of two siblings\n+ * @param {Element} a\n+ * @param {Element} b\n+ * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\n+ */\n+function siblingCheck( a, b ) {\n+  var cur = b && a,\n+    diff = cur && a.nodeType === 1 && b.nodeType === 1 &&\n+      ( ~b.sourceIndex || MAX_NEGATIVE ) -\n+      ( ~a.sourceIndex || MAX_NEGATIVE );\n+\n+  // Use IE sourceIndex if available on both nodes\n+  if ( diff ) {\n+    return diff;\n+  }\n+\n+  // Check if b follows a\n+  if ( cur ) {\n+    while ( (cur = cur.nextSibling) ) {\n+      if ( cur === b ) {\n+        return -1;\n+      }\n+    }\n+  }\n+\n+  return a ? 1 : -1;\n+}\n+\n+/**\n+ * Returns a function to use in pseudos for input types\n+ * @param {String} type\n+ */\n+function createInputPseudo( type ) {\n+  return function( elem ) {\n+    var name = elem.nodeName.toLowerCase();\n+    return name === \"input\" && elem.type === type;\n+  };\n+}\n+\n+/**\n+ * Returns a function to use in pseudos for buttons\n+ * @param {String} type\n+ */\n+function createButtonPseudo( type ) {\n+  return function( elem ) {\n+    var name = elem.nodeName.toLowerCase();\n+    return (name === \"input\" || name === \"button\") && elem.type === type;\n+  };\n+}\n+\n+/**\n+ * Returns a function to use in pseudos for positionals\n+ * @param {Function} fn\n+ */\n+function createPositionalPseudo( fn ) {\n+  return markFunction(function( argument ) {\n+    argument = +argument;\n+    return markFunction(function( seed, matches ) {\n+      var j,\n+        matchIndexes = fn( [], seed.length, argument ),\n+        i = matchIndexes.length;\n+\n+      // Match elements found at the specified indexes\n+      while ( i-- ) {\n+        if ( seed[ (j = matchIndexes[i]) ] ) {\n+          seed[j] = !(matches[j] = seed[j]);\n+        }\n+      }\n+    });\n+  });\n+}\n+\n+/**\n+ * Checks a node for validity as a Sizzle context\n+ * @param {Element|Object=} context\n+ * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\n+ */\n+function testContext( context ) {\n+  return context && typeof context.getElementsByTagName !== strundefined && context;\n+}\n+\n+// Expose support vars for convenience\n+support = Sizzle.support = {};\n+\n+/**\n+ * Detects XML nodes\n+ * @param {Element|Object} elem An element or a document\n+ * @returns {Boolean} True iff elem is a non-HTML XML node\n+ */\n+isXML = Sizzle.isXML = function( elem ) {\n+  // documentElement is verified for cases where it doesn't yet exist\n+  // (such as loading iframes in IE - #4833)\n+  var documentElement = elem && (elem.ownerDocument || elem).documentElement;\n+  return documentElement ? documentElement.nodeName !== \"HTML\" : false;\n+};\n+\n+/**\n+ * Sets document-related variables once based on the current document\n+ * @param {Element|Object} [doc] An element or document object to use to set the document\n+ * @returns {Object} Returns the current document\n+ */\n+setDocument = Sizzle.setDocument = function( node ) {\n+  var hasCompare,\n+    doc = node ? node.ownerDocument || node : preferredDoc,\n+    parent = doc.defaultView;\n+\n+  // If no document and documentElement is available, return\n+  if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {\n+    return document;\n+  }\n+\n+  // Set our document\n+  document = doc;\n+  docElem = doc.documentElement;\n+\n+  // Support tests\n+  documentIsHTML = !isXML( doc );\n+\n+  // Support: IE>8\n+  // If iframe document is assigned to \"document\" variable and if iframe has been reloaded,\n+  // IE will throw \"permission denied\" error when accessing \"document\" variable, see jQuery #13936\n+  // IE6-8 do not support the defaultView property so parent will be undefined\n+  if ( parent && parent !== parent.top ) {\n+    // IE11 does not have attachEvent, so all must suffer\n+    if ( parent.addEventListener ) {\n+      parent.addEventListener( \"unload\", function() {\n+        setDocument();\n+      }, false );\n+    } else if ( parent.attachEvent ) {\n+      parent.attachEvent( \"onunload\", function() {\n+        setDocument();\n+      });\n+    }\n+  }\n+\n+  /* Attributes\n+  ---------------------------------------------------------------------- */\n+\n+  // Support: IE<8\n+  // Verify that getAttribute really returns attributes and not properties (excepting IE8 booleans)\n+  support.attributes = assert(function( div ) {\n+    div.className = \"i\";\n+    return !div.getAttribute(\"className\");\n+  });\n+\n+  /* getElement(s)By*\n+  ---------------------------------------------------------------------- */\n+\n+  // Check if getElementsByTagName(\"*\") returns only elements\n+  support.getElementsByTagName = assert(function( div ) {\n+    div.appendChild( doc.createComment(\"\") );\n+    return !div.getElementsByTagName(\"*\").length;\n+  });\n+\n+  // Check if getElementsByClassName can be trusted\n+  support.getElementsByClassName = rnative.test( doc.getElementsByClassName ) && assert(function( div ) {\n+    div.innerHTML = \"<div class='a'></div><div class='a i'></div>\";\n+\n+    // Support: Safari<4\n+    // Catch class over-caching\n+    div.firstChild.className = \"i\";\n+    // Support: Opera<10\n+    // Catch gEBCN failure to find non-leading classes\n+    return div.getElementsByClassName(\"i\").length === 2;\n+  });\n+\n+  // Support: IE<10\n+  // Check if getElementById returns elements by name\n+  // The broken getElementById methods don't pick up programatically-set names,\n+  // so use a roundabout getElementsByName test\n+  support.getById = assert(function( div ) {\n+    docElem.appendChild( div ).id = expando;\n+    return !doc.getElementsByName || !doc.getElementsByName( expando ).length;\n+  });\n+\n+  // ID find and filter\n+  if ( support.getById ) {\n+    Expr.find[\"ID\"] = function( id, context ) {\n+      if ( typeof context.getElementById !== strundefined && documentIsHTML ) {\n+        var m = context.getElementById( id );\n+        // Check parentNode to catch when Blackberry 4.6 returns\n+        // nodes that are no longer in the document #6963\n+        return m && m.parentNode ? [ m ] : [];\n+      }\n+    };\n+    Expr.filter[\"ID\"] = function( id ) {\n+      var attrId = id.replace( runescape, funescape );\n+      return function( elem ) {\n+        return elem.getAttribute(\"id\") === attrId;\n+      };\n+    };\n+  } else {\n+    // Support: IE6/7\n+    // getElementById is not reliable as a find shortcut\n+    delete Expr.find[\"ID\"];\n+\n+    Expr.filter[\"ID\"] =  function( id ) {\n+      var attrId = id.replace( runescape, funescape );\n+      return function( elem ) {\n+        var node = typeof elem.getAttributeNode !== strundefined && elem.getAttributeNode(\"id\");\n+        return node && node.value === attrId;\n+      };\n+    };\n+  }\n+\n+  // Tag\n+  Expr.find[\"TAG\"] = support.getElementsByTagName ?\n+    function( tag, context ) {\n+      if ( typeof context.getElementsByTagName !== strundefined ) {\n+        return context.getElementsByTagName( tag );\n+      }\n+    } :\n+    function( tag, context ) {\n+      var elem,\n+        tmp = [],\n+        i = 0,\n+        results = context.getElementsByTagName( tag );\n+\n+      // Filter out possible comments\n+      if ( tag === \"*\" ) {\n+        while ( (elem = results[i++]) ) {\n+          if ( elem.nodeType === 1 ) {\n+            tmp.push( elem );\n+          }\n+        }\n+\n+        return tmp;\n+      }\n+      return results;\n+    };\n+\n+  // Class\n+  Expr.find[\"CLASS\"] = support.getElementsByClassName && function( className, context ) {\n+    if ( typeof context.getElementsByClassName !== strundefined && documentIsHTML ) {\n+      return context.getElementsByClassName( className );\n+    }\n+  };\n+\n+  /* QSA/matchesSelector\n+  ---------------------------------------------------------------------- */\n+\n+  // QSA and matchesSelector support\n+\n+  // matchesSelector(:active) reports false when true (IE9/Opera 11.5)\n+  rbuggyMatches = [];\n+\n+  // qSa(:focus) reports false when true (Chrome 21)\n+  // We allow this because of a bug in IE8/9 that throws an error\n+  // whenever `document.activeElement` is accessed on an iframe\n+  // So, we allow :focus to pass through QSA all the time to avoid the IE error\n+  // See http://bugs.jquery.com/ticket/13378\n+  rbuggyQSA = [];\n+\n+  if ( (support.qsa = rnative.test( doc.querySelectorAll )) ) {\n+    // Build QSA regex\n+    // Regex strategy adopted from Diego Perini\n+    assert(function( div ) {\n+      // Select is set to empty string on purpose\n+      // This is to test IE's treatment of not explicitly\n+      // setting a boolean content attribute,\n+      // since its presence should be enough\n+      // http://bugs.jquery.com/ticket/12359\n+      div.innerHTML = \"<select msallowclip=''><option selected=''></option></select>\";\n+\n+      // Support: IE8, Opera 11-12.16\n+      // Nothing should be selected when empty strings follow ^= or $= or *=\n+      // The test attribute must be unknown in Opera but \"safe\" for WinRT\n+      // http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section\n+      if ( div.querySelectorAll(\"[msallowclip^='']\").length ) {\n+        rbuggyQSA.push( \"[*^$]=\" + whitespace + \"*(?:''|\\\"\\\")\" );\n+      }\n+\n+      // Support: IE8\n+      // Boolean attributes and \"value\" are not treated correctly\n+      if ( !div.querySelectorAll(\"[selected]\").length ) {\n+        rbuggyQSA.push( \"\\\\[\" + whitespace + \"*(?:value|\" + booleans + \")\" );\n+      }\n+\n+      // Webkit/Opera - :checked should return selected option elements\n+      // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n+      // IE8 throws error here and will not see later tests\n+      if ( !div.querySelectorAll(\":checked\").length ) {\n+        rbuggyQSA.push(\":checked\");\n+      }\n+    });\n+\n+    assert(function( div ) {\n+      // Support: Windows 8 Native Apps\n+      // The type and name attributes are restricted during .innerHTML assignment\n+      var input = doc.createElement(\"input\");\n+      input.setAttribute( \"type\", \"hidden\" );\n+      div.appendChild( input ).setAttribute( \"name\", \"D\" );\n+\n+      // Support: IE8\n+      // Enforce case-sensitivity of name attribute\n+      if ( div.querySelectorAll(\"[name=d]\").length ) {\n+        rbuggyQSA.push( \"name\" + whitespace + \"*[*^$|!~]?=\" );\n+      }\n+\n+      // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\n+      // IE8 throws error here and will not see later tests\n+      if ( !div.querySelectorAll(\":enabled\").length ) {\n+        rbuggyQSA.push( \":enabled\", \":disabled\" );\n+      }\n+\n+      // Opera 10-11 does not throw on post-comma invalid pseudos\n+      div.querySelectorAll(\"*,:x\");\n+      rbuggyQSA.push(\",.*:\");\n+    });\n+  }\n+\n+  if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||\n+    docElem.webkitMatchesSelector ||\n+    docElem.mozMatchesSelector ||\n+    docElem.oMatchesSelector ||\n+    docElem.msMatchesSelector) )) ) {\n+\n+    assert(function( div ) {\n+      // Check to see if it's possible to do matchesSelector\n+      // on a disconnected node (IE 9)\n+      support.disconnectedMatch = matches.call( div, \"div\" );\n+\n+      // This should fail with an exception\n+      // Gecko does not error, returns false instead\n+      matches.call( div, \"[s!='']:x\" );\n+      rbuggyMatches.push( \"!=\", pseudos );\n+    });\n+  }\n+\n+  rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join(\"|\") );\n+  rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join(\"|\") );\n+\n+  /* Contains\n+  ---------------------------------------------------------------------- */\n+  hasCompare = rnative.test( docElem.compareDocumentPosition );\n+\n+  // Element contains another\n+  // Purposefully does not implement inclusive descendent\n+  // As in, an element does not contain itself\n+  contains = hasCompare || rnative.test( docElem.contains ) ?\n+    function( a, b ) {\n+      var adown = a.nodeType === 9 ? a.documentElement : a,\n+        bup = b && b.parentNode;\n+      return a === bup || !!( bup && bup.nodeType === 1 && (\n+        adown.contains ?\n+          adown.contains( bup ) :\n+          a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16\n+      ));\n+    } :\n+    function( a, b ) {\n+      if ( b ) {\n+        while ( (b = b.parentNode) ) {\n+          if ( b === a ) {\n+            return true;\n+          }\n+        }\n+      }\n+      return false;\n+    };\n+\n+  /* Sorting\n+  ---------------------------------------------------------------------- */\n+\n+  // Document order sorting\n+  sortOrder = hasCompare ?\n+  function( a, b ) {\n+\n+    // Flag for duplicate removal\n+    if ( a === b ) {\n+      hasDuplicate = true;\n+      return 0;\n+    }\n+\n+    // Sort on method existence if only one input has compareDocumentPosition\n+    var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\n+    if ( compare ) {\n+      return compare;\n+    }\n+\n+    // Calculate position if both inputs belong to the same document\n+    compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?\n+      a.compareDocumentPosition( b ) :\n+\n+      // Otherwise we know they are disconnected\n+      1;\n+\n+    // Disconnected nodes\n+    if ( compare & 1 ||\n+      (!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {\n+\n+      // Choose the first element that is related to our preferred document\n+      if ( a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {\n+        return -1;\n+      }\n+      if ( b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {\n+        return 1;\n+      }\n+\n+      // Maintain original order\n+      return sortInput ?\n+        ( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :\n+        0;\n+    }\n+\n+    return compare & 4 ? -1 : 1;\n+  } :\n+  function( a, b ) {\n+    // Exit early if the nodes are identical\n+    if ( a === b ) {\n+      hasDuplicate = true;\n+      return 0;\n+    }\n+\n+    var cur,\n+      i = 0,\n+      aup = a.parentNode,\n+      bup = b.parentNode,\n+      ap = [ a ],\n+      bp = [ b ];\n+\n+    // Parentless nodes are either documents or disconnected\n+    if ( !aup || !bup ) {\n+      return a === doc ? -1 :\n+        b === doc ? 1 :\n+        aup ? -1 :\n+        bup ? 1 :\n+        sortInput ?\n+        ( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :\n+        0;\n+\n+    // If the nodes are siblings, we can do a quick check\n+    } else if ( aup === bup ) {\n+      return siblingCheck( a, b );\n+    }\n+\n+    // Otherwise we need full lists of their ancestors for comparison\n+    cur = a;\n+    while ( (cur = cur.parentNode) ) {\n+      ap.unshift( cur );\n+    }\n+    cur = b;\n+    while ( (cur = cur.parentNode) ) {\n+      bp.unshift( cur );\n+    }\n+\n+    // Walk down the tree looking for a discrepancy\n+    while ( ap[i] === bp[i] ) {\n+      i++;\n+    }\n+\n+    return i ?\n+      // Do a sibling check if the nodes have a common ancestor\n+      siblingCheck( ap[i], bp[i] ) :\n+\n+      // Otherwise nodes in our document sort first\n+      ap[i] === preferredDoc ? -1 :\n+      bp[i] === preferredDoc ? 1 :\n+      0;\n+  };\n+\n+  return doc;\n+};\n+\n+Sizzle.matches = function( expr, elements ) {\n+  return Sizzle( expr, null, null, elements );\n+};\n+\n+Sizzle.matchesSelector = function( elem, expr ) {\n+  // Set document vars if needed\n+  if ( ( elem.ownerDocument || elem ) !== document ) {\n+    setDocument( elem );\n+  }\n+\n+  // Make sure that attribute selectors are quoted\n+  expr = expr.replace( rattributeQuotes, \"='$1']\" );\n+\n+  if ( support.matchesSelector && documentIsHTML &&\n+    ( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&\n+    ( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {\n+\n+    try {\n+      var ret = matches.call( elem, expr );\n+\n+      // IE 9's matchesSelector returns false on disconnected nodes\n+      if ( ret || support.disconnectedMatch ||\n+          // As well, disconnected nodes are said to be in a document\n+          // fragment in IE 9\n+          elem.document && elem.document.nodeType !== 11 ) {\n+        return ret;\n+      }\n+    } catch(e) {}\n+  }\n+\n+  return Sizzle( expr, document, null, [ elem ] ).length > 0;\n+};\n+\n+Sizzle.contains = function( context, elem ) {\n+  // Set document vars if needed\n+  if ( ( context.ownerDocument || context ) !== document ) {\n+    setDocument( context );\n+  }\n+  return contains( context, elem );\n+};\n+\n+Sizzle.attr = function( elem, name ) {\n+  // Set document vars if needed\n+  if ( ( elem.ownerDocument || elem ) !== document ) {\n+    setDocument( elem );\n+  }\n+\n+  var fn = Expr.attrHandle[ name.toLowerCase() ],\n+    // Don't get fooled by Object.prototype properties (jQuery #13807)\n+    val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?\n+      fn( elem, name, !documentIsHTML ) :\n+      undefined;\n+\n+  return val !== undefined ?\n+    val :\n+    support.attributes || !documentIsHTML ?\n+      elem.getAttribute( name ) :\n+      (val = elem.getAttributeNode(name)) && val.specified ?\n+        val.value :\n+        null;\n+};\n+\n+Sizzle.error = function( msg ) {\n+  throw new Error( \"Syntax error, unrecognized expression: \" + msg );\n+};\n+\n+/**\n+ * Document sorting and removing duplicates\n+ * @param {ArrayLike} results\n+ */\n+Sizzle.uniqueSort = function( results ) {\n+  var elem,\n+    duplicates = [],\n+    j = 0,\n+    i = 0;\n+\n+  // Unless we *know* we can detect duplicates, assume their presence\n+  hasDuplicate = !support.detectDuplicates;\n+  sortInput = !support.sortStable && results.slice( 0 );\n+  results.sort( sortOrder );\n+\n+  if ( hasDuplicate ) {\n+    while ( (elem = results[i++]) ) {\n+      if ( elem === results[ i ] ) {\n+        j = duplicates.push( i );\n+      }\n+    }\n+    while ( j-- ) {\n+      results.splice( duplicates[ j ], 1 );\n+    }\n+  }\n+\n+  // Clear input after sorting to release objects\n+  // See https://github.com/jquery/sizzle/pull/225\n+  sortInput = null;\n+\n+  return results;\n+};\n+\n+/**\n+ * Utility function for retrieving the text value of an array of DOM nodes\n+ * @param {Array|Element} elem\n+ */\n+getText = Sizzle.getText = function( elem ) {\n+  var node,\n+    ret = \"\",\n+    i = 0,\n+    nodeType = elem.nodeType;\n+\n+  if ( !nodeType ) {\n+    // If no nodeType, this is expected to be an array\n+    while ( (node = elem[i++]) ) {\n+      // Do not traverse comment nodes\n+      ret += getText( node );\n+    }\n+  } else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {\n+    // Use textContent for elements\n+    // innerText usage removed for consistency of new lines (jQuery #11153)\n+    if ( typeof elem.textContent === \"string\" ) {\n+      return elem.textContent;\n+    } else {\n+      // Traverse its children\n+      for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n+        ret += getText( elem );\n+      }\n+    }\n+  } else if ( nodeType === 3 || nodeType === 4 ) {\n+    return elem.nodeValue;\n+  }\n+  // Do not include comment or processing instruction nodes\n+\n+  return ret;\n+};\n+\n+Expr = Sizzle.selectors = {\n+\n+  // Can be adjusted by the user\n+  cacheLength: 50,\n+\n+  createPseudo: markFunction,\n+\n+  match: matchExpr,\n+\n+  attrHandle: {},\n+\n+  find: {},\n+\n+  relative: {\n+    \">\": { dir: \"parentNode\", first: true },\n+    \" \": { dir: \"parentNode\" },\n+    \"+\": { dir: \"previousSibling\", first: true },\n+    \"~\": { dir: \"previousSibling\" }\n+  },\n+\n+  preFilter: {\n+    \"ATTR\": function( match ) {\n+      match[1] = match[1].replace( runescape, funescape );\n+\n+      // Move the given value to match[3] whether quoted or unquoted\n+      match[3] = ( match[3] || match[4] || match[5] || \"\" ).replace( runescape, funescape );\n+\n+      if ( match[2] === \"~=\" ) {\n+        match[3] = \" \" + match[3] + \" \";\n+      }\n+\n+      return match.slice( 0, 4 );\n+    },\n+\n+    \"CHILD\": function( match ) {\n+      /* matches from matchExpr[\"CHILD\"]\n+        1 type (only|nth|...)\n+        2 what (child|of-type)\n+        3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\n+        4 xn-component of xn+y argument ([+-]?\\d*n|)\n+        5 sign of xn-component\n+        6 x of xn-component\n+        7 sign of y-component\n+        8 y of y-component\n+      */\n+      match[1] = match[1].toLowerCase();\n+\n+      if ( match[1].slice( 0, 3 ) === \"nth\" ) {\n+        // nth-* requires argument\n+        if ( !match[3] ) {\n+          Sizzle.error( match[0] );\n+        }\n+\n+        // numeric x and y parameters for Expr.filter.CHILD\n+        // remember that false/true cast respectively to 0/1\n+        match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === \"even\" || match[3] === \"odd\" ) );\n+        match[5] = +( ( match[7] + match[8] ) || match[3] === \"odd\" );\n+\n+      // other types prohibit arguments\n+      } else if ( match[3] ) {\n+        Sizzle.error( match[0] );\n+      }\n+\n+      return match;\n+    },\n+\n+    \"PSEUDO\": function( match ) {\n+      var excess,\n+        unquoted = !match[6] && match[2];\n+\n+      if ( matchExpr[\"CHILD\"].test( match[0] ) ) {\n+        return null;\n+      }\n+\n+      // Accept quoted arguments as-is\n+      if ( match[3] ) {\n+        match[2] = match[4] || match[5] || \"\";\n+\n+      // Strip excess characters from unquoted arguments\n+      } else if ( unquoted && rpseudo.test( unquoted ) &&\n+        // Get excess from tokenize (recursively)\n+        (excess = tokenize( unquoted, true )) &&\n+        // advance to the next closing parenthesis\n+        (excess = unquoted.indexOf( \")\", unquoted.length - excess ) - unquoted.length) ) {\n+\n+        // excess is a negative index\n+        match[0] = match[0].slice( 0, excess );\n+        match[2] = unquoted.slice( 0, excess );\n+      }\n+\n+      // Return only captures needed by the pseudo filter method (type and argument)\n+      return match.slice( 0, 3 );\n+    }\n+  },\n+\n+  filter: {\n+\n+    \"TAG\": function( nodeNameSelector ) {\n+      var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();\n+      return nodeNameSelector === \"*\" ?\n+        function() { return true; } :\n+        function( elem ) {\n+          return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\n+        };\n+    },\n+\n+    \"CLASS\": function( className ) {\n+      var pattern = classCache[ className + \" \" ];\n+\n+      return pattern ||\n+        (pattern = new RegExp( \"(^|\" + whitespace + \")\" + className + \"(\" + whitespace + \"|$)\" )) &&\n+        classCache( className, function( elem ) {\n+          return pattern.test( typeof elem.className === \"string\" && elem.className || typeof elem.getAttribute !== strundefined && elem.getAttribute(\"class\") || \"\" );\n+        });\n+    },\n+\n+    \"ATTR\": function( name, operator, check ) {\n+      return function( elem ) {\n+        var result = Sizzle.attr( elem, name );\n+\n+        if ( result == null ) {\n+          return operator === \"!=\";\n+        }\n+        if ( !operator ) {\n+          return true;\n+        }\n+\n+        result += \"\";\n+\n+        return operator === \"=\" ? result === check :\n+          operator === \"!=\" ? result !== check :\n+          operator === \"^=\" ? check && result.indexOf( check ) === 0 :\n+          operator === \"*=\" ? check && result.indexOf( check ) > -1 :\n+          operator === \"$=\" ? check && result.slice( -check.length ) === check :\n+          operator === \"~=\" ? ( \" \" + result + \" \" ).indexOf( check ) > -1 :\n+          operator === \"|=\" ? result === check || result.slice( 0, check.length + 1 ) === check + \"-\" :\n+          false;\n+      };\n+    },\n+\n+    \"CHILD\": function( type, what, argument, first, last ) {\n+      var simple = type.slice( 0, 3 ) !== \"nth\",\n+        forward = type.slice( -4 ) !== \"last\",\n+        ofType = what === \"of-type\";\n+\n+      return first === 1 && last === 0 ?\n+\n+        // Shortcut for :nth-*(n)\n+        function( elem ) {\n+          return !!elem.parentNode;\n+        } :\n+\n+        function( elem, context, xml ) {\n+          var cache, outerCache, node, diff, nodeIndex, start,\n+            dir = simple !== forward ? \"nextSibling\" : \"previousSibling\",\n+            parent = elem.parentNode,\n+            name = ofType && elem.nodeName.toLowerCase(),\n+            useCache = !xml && !ofType;\n+\n+          if ( parent ) {\n+\n+            // :(first|last|only)-(child|of-type)\n+            if ( simple ) {\n+              while ( dir ) {\n+                node = elem;\n+                while ( (node = node[ dir ]) ) {\n+                  if ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) {\n+                    return false;\n+                  }\n+                }\n+                // Reverse direction for :only-* (if we haven't yet done so)\n+                start = dir = type === \"only\" && !start && \"nextSibling\";\n+              }\n+              return true;\n+            }\n+\n+            start = [ forward ? parent.firstChild : parent.lastChild ];\n+\n+            // non-xml :nth-child(...) stores cache data on `parent`\n+            if ( forward && useCache ) {\n+              // Seek `elem` from a previously-cached index\n+              outerCache = parent[ expando ] || (parent[ expando ] = {});\n+              cache = outerCache[ type ] || [];\n+              nodeIndex = cache[0] === dirruns && cache[1];\n+              diff = cache[0] === dirruns && cache[2];\n+              node = nodeIndex && parent.childNodes[ nodeIndex ];\n+\n+              while ( (node = ++nodeIndex && node && node[ dir ] ||\n+\n+                // Fallback to seeking `elem` from the start\n+                (diff = nodeIndex = 0) || start.pop()) ) {\n+\n+                // When found, cache indexes on `parent` and break\n+                if ( node.nodeType === 1 && ++diff && node === elem ) {\n+                  outerCache[ type ] = [ dirruns, nodeIndex, diff ];\n+                  break;\n+                }\n+              }\n+\n+            // Use previously-cached element index if available\n+            } else if ( useCache && (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) && cache[0] === dirruns ) {\n+              diff = cache[1];\n+\n+            // xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)\n+            } else {\n+              // Use the same loop as above to seek `elem` from the start\n+              while ( (node = ++nodeIndex && node && node[ dir ] ||\n+                (diff = nodeIndex = 0) || start.pop()) ) {\n+\n+                if ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) && ++diff ) {\n+                  // Cache the index of each encountered element\n+                  if ( useCache ) {\n+                    (node[ expando ] || (node[ expando ] = {}))[ type ] = [ dirruns, diff ];\n+                  }\n+\n+                  if ( node === elem ) {\n+                    break;\n+                  }\n+                }\n+              }\n+            }\n+\n+            // Incorporate the offset, then check against cycle size\n+            diff -= last;\n+            return diff === first || ( diff % first === 0 && diff / first >= 0 );\n+          }\n+        };\n+    },\n+\n+    \"PSEUDO\": function( pseudo, argument ) {\n+      // pseudo-class names are case-insensitive\n+      // http://www.w3.org/TR/selectors/#pseudo-classes\n+      // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\n+      // Remember that setFilters inherits from pseudos\n+      var args,\n+        fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||\n+          Sizzle.error( \"unsupported pseudo: \" + pseudo );\n+\n+      // The user may use createPseudo to indicate that\n+      // arguments are needed to create the filter function\n+      // just as Sizzle does\n+      if ( fn[ expando ] ) {\n+        return fn( argument );\n+      }\n+\n+      // But maintain support for old signatures\n+      if ( fn.length > 1 ) {\n+        args = [ pseudo, pseudo, \"\", argument ];\n+        return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?\n+          markFunction(function( seed, matches ) {\n+            var idx,\n+              matched = fn( seed, argument ),\n+              i = matched.length;\n+            while ( i-- ) {\n+              idx = indexOf.call( seed, matched[i] );\n+              seed[ idx ] = !( matches[ idx ] = matched[i] );\n+            }\n+          }) :\n+          function( elem ) {\n+            return fn( elem, 0, args );\n+          };\n+      }\n+\n+      return fn;\n+    }\n+  },\n+\n+  pseudos: {\n+    // Potentially complex pseudos\n+    \"not\": markFunction(function( selector ) {\n+      // Trim the selector passed to compile\n+      // to avoid treating leading and trailing\n+      // spaces as combinators\n+      var input = [],\n+        results = [],\n+        matcher = compile( selector.replace( rtrim, \"$1\" ) );\n+\n+      return matcher[ expando ] ?\n+        markFunction(function( seed, matches, context, xml ) {\n+          var elem,\n+            unmatched = matcher( seed, null, xml, [] ),\n+            i = seed.length;\n+\n+          // Match elements unmatched by `matcher`\n+          while ( i-- ) {\n+            if ( (elem = unmatched[i]) ) {\n+              seed[i] = !(matches[i] = elem);\n+            }\n+          }\n+        }) :\n+        function( elem, context, xml ) {\n+          input[0] = elem;\n+          matcher( input, null, xml, results );\n+          return !results.pop();\n+        };\n+    }),\n+\n+    \"has\": markFunction(function( selector ) {\n+      return function( elem ) {\n+        return Sizzle( selector, elem ).length > 0;\n+      };\n+    }),\n+\n+    \"contains\": markFunction(function( text ) {\n+      return function( elem ) {\n+        return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;\n+      };\n+    }),\n+\n+    // \"Whether an element is represented by a :lang() selector\n+    // is based solely on the element's language value\n+    // being equal to the identifier C,\n+    // or beginning with the identifier C immediately followed by \"-\".\n+    // The matching of C against the element's language value is performed case-insensitively.\n+    // The identifier C does not have to be a valid language name.\"\n+    // http://www.w3.org/TR/selectors/#lang-pseudo\n+    \"lang\": markFunction( function( lang ) {\n+      // lang value must be a valid identifier\n+      if ( !ridentifier.test(lang || \"\") ) {\n+        Sizzle.error( \"unsupported lang: \" + lang );\n+      }\n+      lang = lang.replace( runescape, funescape ).toLowerCase();\n+      return function( elem ) {\n+        var elemLang;\n+        do {\n+          if ( (elemLang = documentIsHTML ?\n+            elem.lang :\n+            elem.getAttribute(\"xml:lang\") || elem.getAttribute(\"lang\")) ) {\n+\n+            elemLang = elemLang.toLowerCase();\n+            return elemLang === lang || elemLang.indexOf( lang + \"-\" ) === 0;\n+          }\n+        } while ( (elem = elem.parentNode) && elem.nodeType === 1 );\n+        return false;\n+      };\n+    }),\n+\n+    // Miscellaneous\n+    \"target\": function( elem ) {\n+      var hash = window.location && window.location.hash;\n+      return hash && hash.slice( 1 ) === elem.id;\n+    },\n+\n+    \"root\": function( elem ) {\n+      return elem === docElem;\n+    },\n+\n+    \"focus\": function( elem ) {\n+      return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);\n+    },\n+\n+    // Boolean properties\n+    \"enabled\": function( elem ) {\n+      return elem.disabled === false;\n+    },\n+\n+    \"disabled\": function( elem ) {\n+      return elem.disabled === true;\n+    },\n+\n+    \"checked\": function( elem ) {\n+      // In CSS3, :checked should return both checked and selected elements\n+      // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n+      var nodeName = elem.nodeName.toLowerCase();\n+      return (nodeName === \"input\" && !!elem.checked) || (nodeName === \"option\" && !!elem.selected);\n+    },\n+\n+    \"selected\": function( elem ) {\n+      // Accessing this property makes selected-by-default\n+      // options in Safari work properly\n+      if ( elem.parentNode ) {\n+        elem.parentNode.selectedIndex;\n+      }\n+\n+      return elem.selected === true;\n+    },\n+\n+    // Contents\n+    \"empty\": function( elem ) {\n+      // http://www.w3.org/TR/selectors/#empty-pseudo\n+      // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\n+      //   but not by others (comment: 8; processing instruction: 7; etc.)\n+      // nodeType < 6 works because attributes (2) do not appear as children\n+      for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n+        if ( elem.nodeType < 6 ) {\n+          return false;\n+        }\n+      }\n+      return true;\n+    },\n+\n+    \"parent\": function( elem ) {\n+      return !Expr.pseudos[\"empty\"]( elem );\n+    },\n+\n+    // Element/input types\n+    \"header\": function( elem ) {\n+      return rheader.test( elem.nodeName );\n+    },\n+\n+    \"input\": function( elem ) {\n+      return rinputs.test( elem.nodeName );\n+    },\n+\n+    \"button\": function( elem ) {\n+      var name = elem.nodeName.toLowerCase();\n+      return name === \"input\" && elem.type === \"button\" || name === \"button\";\n+    },\n+\n+    \"text\": function( elem ) {\n+      var attr;\n+      return elem.nodeName.toLowerCase() === \"input\" &&\n+        elem.type === \"text\" &&\n+\n+        // Support: IE<8\n+        // New HTML5 attribute values (e.g., \"search\") appear with elem.type === \"text\"\n+        ( (attr = elem.getAttribute(\"type\")) == null || attr.toLowerCase() === \"text\" );\n+    },\n+\n+    // Position-in-collection\n+    \"first\": createPositionalPseudo(function() {\n+      return [ 0 ];\n+    }),\n+\n+    \"last\": createPositionalPseudo(function( matchIndexes, length ) {\n+      return [ length - 1 ];\n+    }),\n+\n+    \"eq\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n+      return [ argument < 0 ? argument + length : argument ];\n+    }),\n+\n+    \"even\": createPositionalPseudo(function( matchIndexes, length ) {\n+      var i = 0;\n+      for ( ; i < length; i += 2 ) {\n+        matchIndexes.push( i );\n+      }\n+      return matchIndexes;\n+    }),\n+\n+    \"odd\": createPositionalPseudo(function( matchIndexes, length ) {\n+      var i = 1;\n+      for ( ; i < length; i += 2 ) {\n+        matchIndexes.push( i );\n+      }\n+      return matchIndexes;\n+    }),\n+\n+    \"lt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n+      var i = argument < 0 ? argument + length : argument;\n+      for ( ; --i >= 0; ) {\n+        matchIndexes.push( i );\n+      }\n+      return matchIndexes;\n+    }),\n+\n+    \"gt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n+      var i = argument < 0 ? argument + length : argument;\n+      for ( ; ++i < length; ) {\n+        matchIndexes.push( i );\n+      }\n+      return matchIndexes;\n+    })\n+  }\n+};\n+\n+Expr.pseudos[\"nth\"] = Expr.pseudos[\"eq\"];\n+\n+// Add button/input type pseudos\n+for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {\n+  Expr.pseudos[ i ] = createInputPseudo( i );\n+}\n+for ( i in { submit: true, reset: true } ) {\n+  Expr.pseudos[ i ] = createButtonPseudo( i );\n+}\n+\n+// Easy API for creating new setFilters\n+function setFilters() {}\n+setFilters.prototype = Expr.filters = Expr.pseudos;\n+Expr.setFilters = new setFilters();\n+\n+tokenize = Sizzle.tokenize = function( selector, parseOnly ) {\n+  var matched, match, tokens, type,\n+    soFar, groups, preFilters,\n+    cached = tokenCache[ selector + \" \" ];\n+\n+  if ( cached ) {\n+    return parseOnly ? 0 : cached.slice( 0 );\n+  }\n+\n+  soFar = selector;\n+  groups = [];\n+  preFilters = Expr.preFilter;\n+\n+  while ( soFar ) {\n+\n+    // Comma and first run\n+    if ( !matched || (match = rcomma.exec( soFar )) ) {\n+      if ( match ) {\n+        // Don't consume trailing commas as valid\n+        soFar = soFar.slice( match[0].length ) || soFar;\n+      }\n+      groups.push( (tokens = []) );\n+    }\n+\n+    matched = false;\n+\n+    // Combinators\n+    if ( (match = rcombinators.exec( soFar )) ) {\n+      matched = match.shift();\n+      tokens.push({\n+        value: matched,\n+        // Cast descendant combinators to space\n+        type: match[0].replace( rtrim, \" \" )\n+      });\n+      soFar = soFar.slice( matched.length );\n+    }\n+\n+    // Filters\n+    for ( type in Expr.filter ) {\n+      if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||\n+        (match = preFilters[ type ]( match ))) ) {\n+        matched = match.shift();\n+        tokens.push({\n+          value: matched,\n+          type: type,\n+          matches: match\n+        });\n+        soFar = soFar.slice( matched.length );\n+      }\n+    }\n+\n+    if ( !matched ) {\n+      break;\n+    }\n+  }\n+\n+  // Return the length of the invalid excess\n+  // if we're just parsing\n+  // Otherwise, throw an error or return tokens\n+  return parseOnly ?\n+    soFar.length :\n+    soFar ?\n+      Sizzle.error( selector ) :\n+      // Cache the tokens\n+      tokenCache( selector, groups ).slice( 0 );\n+};\n+\n+function toSelector( tokens ) {\n+  var i = 0,\n+    len = tokens.length,\n+    selector = \"\";\n+  for ( ; i < len; i++ ) {\n+    selector += tokens[i].value;\n+  }\n+  return selector;\n+}\n+\n+function addCombinator( matcher, combinator, base ) {\n+  var dir = combinator.dir,\n+    checkNonElements = base && dir === \"parentNode\",\n+    doneName = done++;\n+\n+  return combinator.first ?\n+    // Check against closest ancestor/preceding element\n+    function( elem, context, xml ) {\n+      while ( (elem = elem[ dir ]) ) {\n+        if ( elem.nodeType === 1 || checkNonElements ) {\n+          return matcher( elem, context, xml );\n+        }\n+      }\n+    } :\n+\n+    // Check against all ancestor/preceding elements\n+    function( elem, context, xml ) {\n+      var oldCache, outerCache,\n+        newCache = [ dirruns, doneName ];\n+\n+      // We can't set arbitrary data on XML nodes, so they don't benefit from dir caching\n+      if ( xml ) {\n+        while ( (elem = elem[ dir ]) ) {\n+          if ( elem.nodeType === 1 || checkNonElements ) {\n+            if ( matcher( elem, context, xml ) ) {\n+              return true;\n+            }\n+          }\n+        }\n+      } else {\n+        while ( (elem = elem[ dir ]) ) {\n+          if ( elem.nodeType === 1 || checkNonElements ) {\n+            outerCache = elem[ expando ] || (elem[ expando ] = {});\n+            if ( (oldCache = outerCache[ dir ]) &&\n+              oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {\n+\n+              // Assign to newCache so results back-propagate to previous elements\n+              return (newCache[ 2 ] = oldCache[ 2 ]);\n+            } else {\n+              // Reuse newcache so results back-propagate to previous elements\n+              outerCache[ dir ] = newCache;\n+\n+              // A match means we're done; a fail means we have to keep checking\n+              if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {\n+                return true;\n+              }\n+            }\n+          }\n+        }\n+      }\n+    };\n+}\n+\n+function elementMatcher( matchers ) {\n+  return matchers.length > 1 ?\n+    function( elem, context, xml ) {\n+      var i = matchers.length;\n+      while ( i-- ) {\n+        if ( !matchers[i]( elem, context, xml ) ) {\n+          return false;\n+        }\n+      }\n+      return true;\n+    } :\n+    matchers[0];\n+}\n+\n+function multipleContexts( selector, contexts, results ) {\n+  var i = 0,\n+    len = contexts.length;\n+  for ( ; i < len; i++ ) {\n+    Sizzle( selector, contexts[i], results );\n+  }\n+  return results;\n+}\n+\n+function condense( unmatched, map, filter, context, xml ) {\n+  var elem,\n+    newUnmatched = [],\n+    i = 0,\n+    len = unmatched.length,\n+    mapped = map != null;\n+\n+  for ( ; i < len; i++ ) {\n+    if ( (elem = unmatched[i]) ) {\n+      if ( !filter || filter( elem, context, xml ) ) {\n+        newUnmatched.push( elem );\n+        if ( mapped ) {\n+          map.push( i );\n+        }\n+      }\n+    }\n+  }\n+\n+  return newUnmatched;\n+}\n+\n+function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {\n+  if ( postFilter && !postFilter[ expando ] ) {\n+    postFilter = setMatcher( postFilter );\n+  }\n+  if ( postFinder && !postFinder[ expando ] ) {\n+    postFinder = setMatcher( postFinder, postSelector );\n+  }\n+  return markFunction(function( seed, results, context, xml ) {\n+    var temp, i, elem,\n+      preMap = [],\n+      postMap = [],\n+      preexisting = results.length,\n+\n+      // Get initial elements from seed or context\n+      elems = seed || multipleContexts( selector || \"*\", context.nodeType ? [ context ] : context, [] ),\n+\n+      // Prefilter to get matcher input, preserving a map for seed-results synchronization\n+      matcherIn = preFilter && ( seed || !selector ) ?\n+        condense( elems, preMap, preFilter, context, xml ) :\n+        elems,\n+\n+      matcherOut = matcher ?\n+        // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\n+        postFinder || ( seed ? preFilter : preexisting || postFilter ) ?\n+\n+          // ...intermediate processing is necessary\n+          [] :\n+\n+          // ...otherwise use results directly\n+          results :\n+        matcherIn;\n+\n+    // Find primary matches\n+    if ( matcher ) {\n+      matcher( matcherIn, matcherOut, context, xml );\n+    }\n+\n+    // Apply postFilter\n+    if ( postFilter ) {\n+      temp = condense( matcherOut, postMap );\n+      postFilter( temp, [], context, xml );\n+\n+      // Un-match failing elements by moving them back to matcherIn\n+      i = temp.length;\n+      while ( i-- ) {\n+        if ( (elem = temp[i]) ) {\n+          matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);\n+        }\n+      }\n+    }\n+\n+    if ( seed ) {\n+      if ( postFinder || preFilter ) {\n+        if ( postFinder ) {\n+          // Get the final matcherOut by condensing this intermediate into postFinder contexts\n+          temp = [];\n+          i = matcherOut.length;\n+          while ( i-- ) {\n+            if ( (elem = matcherOut[i]) ) {\n+              // Restore matcherIn since elem is not yet a final match\n+              temp.push( (matcherIn[i] = elem) );\n+            }\n+          }\n+          postFinder( null, (matcherOut = []), temp, xml );\n+        }\n+\n+        // Move matched elements from seed to results to keep them synchronized\n+        i = matcherOut.length;\n+        while ( i-- ) {\n+          if ( (elem = matcherOut[i]) &&\n+            (temp = postFinder ? indexOf.call( seed, elem ) : preMap[i]) > -1 ) {\n+\n+            seed[temp] = !(results[temp] = elem);\n+          }\n+        }\n+      }\n+\n+    // Add elements to results, through postFinder if defined\n+    } else {\n+      matcherOut = condense(\n+        matcherOut === results ?\n+          matcherOut.splice( preexisting, matcherOut.length ) :\n+          matcherOut\n+      );\n+      if ( postFinder ) {\n+        postFinder( null, results, matcherOut, xml );\n+      } else {\n+        push.apply( results, matcherOut );\n+      }\n+    }\n+  });\n+}\n+\n+function matcherFromTokens( tokens ) {\n+  var checkContext, matcher, j,\n+    len = tokens.length,\n+    leadingRelative = Expr.relative[ tokens[0].type ],\n+    implicitRelative = leadingRelative || Expr.relative[\" \"],\n+    i = leadingRelative ? 1 : 0,\n+\n+    // The foundational matcher ensures that elements are reachable from top-level context(s)\n+    matchContext = addCombinator( function( elem ) {\n+      return elem === checkContext;\n+    }, implicitRelative, true ),\n+    matchAnyContext = addCombinator( function( elem ) {\n+      return indexOf.call( checkContext, elem ) > -1;\n+    }, implicitRelative, true ),\n+    matchers = [ function( elem, context, xml ) {\n+      return ( !leadingRelative && ( xml || context !== outermostContext ) ) || (\n+        (checkContext = context).nodeType ?\n+          matchContext( elem, context, xml ) :\n+          matchAnyContext( elem, context, xml ) );\n+    } ];\n+\n+  for ( ; i < len; i++ ) {\n+    if ( (matcher = Expr.relative[ tokens[i].type ]) ) {\n+      matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];\n+    } else {\n+      matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );\n+\n+      // Return special upon seeing a positional matcher\n+      if ( matcher[ expando ] ) {\n+        // Find the next relative operator (if any) for proper handling\n+        j = ++i;\n+        for ( ; j < len; j++ ) {\n+          if ( Expr.relative[ tokens[j].type ] ) {\n+            break;\n+          }\n+        }\n+        return setMatcher(\n+          i > 1 && elementMatcher( matchers ),\n+          i > 1 && toSelector(\n+            // If the preceding token was a descendant combinator, insert an implicit any-element `*`\n+            tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === \" \" ? \"*\" : \"\" })\n+          ).replace( rtrim, \"$1\" ),\n+          matcher,\n+          i < j && matcherFromTokens( tokens.slice( i, j ) ),\n+          j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),\n+          j < len && toSelector( tokens )\n+        );\n+      }\n+      matchers.push( matcher );\n+    }\n+  }\n+\n+  return elementMatcher( matchers );\n+}\n+\n+function matcherFromGroupMatchers( elementMatchers, setMatchers ) {\n+  var bySet = setMatchers.length > 0,\n+    byElement = elementMatchers.length > 0,\n+    superMatcher = function( seed, context, xml, results, outermost ) {\n+      var elem, j, matcher,\n+        matchedCount = 0,\n+        i = \"0\",\n+        unmatched = seed && [],\n+        setMatched = [],\n+        contextBackup = outermostContext,\n+        // We must always have either seed elements or outermost context\n+        elems = seed || byElement && Expr.find[\"TAG\"]( \"*\", outermost ),\n+        // Use integer dirruns iff this is the outermost matcher\n+        dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),\n+        len = elems.length;\n+\n+      if ( outermost ) {\n+        outermostContext = context !== document && context;\n+      }\n+\n+      // Add elements passing elementMatchers directly to results\n+      // Keep `i` a string if there are no elements so `matchedCount` will be \"00\" below\n+      // Support: IE<9, Safari\n+      // Tolerate NodeList properties (IE: \"length\"; Safari: <number>) matching elements by id\n+      for ( ; i !== len && (elem = elems[i]) != null; i++ ) {\n+        if ( byElement && elem ) {\n+          j = 0;\n+          while ( (matcher = elementMatchers[j++]) ) {\n+            if ( matcher( elem, context, xml ) ) {\n+              results.push( elem );\n+              break;\n+            }\n+          }\n+          if ( outermost ) {\n+            dirruns = dirrunsUnique;\n+          }\n+        }\n+\n+        // Track unmatched elements for set filters\n+        if ( bySet ) {\n+          // They will have gone through all possible matchers\n+          if ( (elem = !matcher && elem) ) {\n+            matchedCount--;\n+          }\n+\n+          // Lengthen the array for every element, matched or not\n+          if ( seed ) {\n+            unmatched.push( elem );\n+          }\n+        }\n+      }\n+\n+      // Apply set filters to unmatched elements\n+      matchedCount += i;\n+      if ( bySet && i !== matchedCount ) {\n+        j = 0;\n+        while ( (matcher = setMatchers[j++]) ) {\n+          matcher( unmatched, setMatched, context, xml );\n+        }\n+\n+        if ( seed ) {\n+          // Reintegrate element matches to eliminate the need for sorting\n+          if ( matchedCount > 0 ) {\n+            while ( i-- ) {\n+              if ( !(unmatched[i] || setMatched[i]) ) {\n+                setMatched[i] = pop.call( results );\n+              }\n+            }\n+          }\n+\n+          // Discard index placeholder values to get only actual matches\n+          setMatched = condense( setMatched );\n+        }\n+\n+        // Add matches to results\n+        push.apply( results, setMatched );\n+\n+        // Seedless set matches succeeding multiple successful matchers stipulate sorting\n+        if ( outermost && !seed && setMatched.length > 0 &&\n+          ( matchedCount + setMatchers.length ) > 1 ) {\n+\n+          Sizzle.uniqueSort( results );\n+        }\n+      }\n+\n+      // Override manipulation of globals by nested matchers\n+      if ( outermost ) {\n+        dirruns = dirrunsUnique;\n+        outermostContext = contextBackup;\n+      }\n+\n+      return unmatched;\n+    };\n+\n+  return bySet ?\n+    markFunction( superMatcher ) :\n+    superMatcher;\n+}\n+\n+compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {\n+  var i,\n+    setMatchers = [],\n+    elementMatchers = [],\n+    cached = compilerCache[ selector + \" \" ];\n+\n+  if ( !cached ) {\n+    // Generate a function of recursive functions that can be used to check each element\n+    if ( !match ) {\n+      match = tokenize( selector );\n+    }\n+    i = match.length;\n+    while ( i-- ) {\n+      cached = matcherFromTokens( match[i] );\n+      if ( cached[ expando ] ) {\n+        setMatchers.push( cached );\n+      } else {\n+        elementMatchers.push( cached );\n+      }\n+    }\n+\n+    // Cache the compiled function\n+    cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );\n+\n+    // Save selector and tokenization\n+    cached.selector = selector;\n+  }\n+  return cached;\n+};\n+\n+/**\n+ * A low-level selection function that works with Sizzle's compiled\n+ *  selector functions\n+ * @param {String|Function} selector A selector or a pre-compiled\n+ *  selector function built with Sizzle.compile\n+ * @param {Element} context\n+ * @param {Array} [results]\n+ * @param {Array} [seed] A set of elements to match against\n+ */\n+select = Sizzle.select = function( selector, context, results, seed ) {\n+  var i, tokens, token, type, find,\n+    compiled = typeof selector === \"function\" && selector,\n+    match = !seed && tokenize( (selector = compiled.selector || selector) );\n+\n+  results = results || [];\n+\n+  // Try to minimize operations if there is no seed and only one group\n+  if ( match.length === 1 ) {\n+\n+    // Take a shortcut and set the context if the root selector is an ID\n+    tokens = match[0] = match[0].slice( 0 );\n+    if ( tokens.length > 2 && (token = tokens[0]).type === \"ID\" &&\n+        support.getById && context.nodeType === 9 && documentIsHTML &&\n+        Expr.relative[ tokens[1].type ] ) {\n+\n+      context = ( Expr.find[\"ID\"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];\n+      if ( !context ) {\n+        return results;\n+\n+      // Precompiled matchers will still verify ancestry, so step up a level\n+      } else if ( compiled ) {\n+        context = context.parentNode;\n+      }\n+\n+      selector = selector.slice( tokens.shift().value.length );\n+    }\n+\n+    // Fetch a seed set for right-to-left matching\n+    i = matchExpr[\"needsContext\"].test( selector ) ? 0 : tokens.length;\n+    while ( i-- ) {\n+      token = tokens[i];\n+\n+      // Abort if we hit a combinator\n+      if ( Expr.relative[ (type = token.type) ] ) {\n+        break;\n+      }\n+      if ( (find = Expr.find[ type ]) ) {\n+        // Search, expanding context for leading sibling combinators\n+        if ( (seed = find(\n+          token.matches[0].replace( runescape, funescape ),\n+          rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context\n+        )) ) {\n+\n+          // If seed is empty or no tokens remain, we can return early\n+          tokens.splice( i, 1 );\n+          selector = seed.length && toSelector( tokens );\n+          if ( !selector ) {\n+            push.apply( results, seed );\n+            return results;\n+          }\n+\n+          break;\n+        }\n+      }\n+    }\n+  }\n+\n+  // Compile and execute a filtering function if one is not provided\n+  // Provide `match` to avoid retokenization if we modified the selector above\n+  ( compiled || compile( selector, match ) )(\n+    seed,\n+    context,\n+    !documentIsHTML,\n+    results,\n+    rsibling.test( selector ) && testContext( context.parentNode ) || context\n+  );\n+  return results;\n+};\n+\n+// One-time assignments\n+\n+// Sort stability\n+support.sortStable = expando.split(\"\").sort( sortOrder ).join(\"\") === expando;\n+\n+// Support: Chrome<14\n+// Always assume duplicates if they aren't passed to the comparison function\n+support.detectDuplicates = !!hasDuplicate;\n+\n+// Initialize against the default document\n+setDocument();\n+\n+// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\n+// Detached nodes confoundingly follow *each other*\n+support.sortDetached = assert(function( div1 ) {\n+  // Should return 1, but returns 4 (following)\n+  return div1.compareDocumentPosition( document.createElement(\"div\") ) & 1;\n+});\n+\n+// Support: IE<8\n+// Prevent attribute/property \"interpolation\"\n+// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\n+if ( !assert(function( div ) {\n+  div.innerHTML = \"<a href='#'></a>\";\n+  return div.firstChild.getAttribute(\"href\") === \"#\" ;\n+}) ) {\n+  addHandle( \"type|href|height|width\", function( elem, name, isXML ) {\n+    if ( !isXML ) {\n+      return elem.getAttribute( name, name.toLowerCase() === \"type\" ? 1 : 2 );\n+    }\n+  });\n+}\n+\n+// Support: IE<9\n+// Use defaultValue in place of getAttribute(\"value\")\n+if ( !support.attributes || !assert(function( div ) {\n+  div.innerHTML = \"<input/>\";\n+  div.firstChild.setAttribute( \"value\", \"\" );\n+  return div.firstChild.getAttribute( \"value\" ) === \"\";\n+}) ) {\n+  addHandle( \"value\", function( elem, name, isXML ) {\n+    if ( !isXML && elem.nodeName.toLowerCase() === \"input\" ) {\n+      return elem.defaultValue;\n+    }\n+  });\n+}\n+\n+// Support: IE<9\n+// Use getAttributeNode to fetch booleans when getAttribute lies\n+if ( !assert(function( div ) {\n+  return div.getAttribute(\"disabled\") == null;\n+}) ) {\n+  addHandle( booleans, function( elem, name, isXML ) {\n+    var val;\n+    if ( !isXML ) {\n+      return elem[ name ] === true ? name.toLowerCase() :\n+          (val = elem.getAttributeNode( name )) && val.specified ?\n+          val.value :\n+        null;\n+    }\n+  });\n+}\n+\n+return Sizzle;\n+\n+})( window );\n+\n+\n+\n+jQuery.find = Sizzle;\n+jQuery.expr = Sizzle.selectors;\n+jQuery.expr[\":\"] = jQuery.expr.pseudos;\n+jQuery.unique = Sizzle.uniqueSort;\n+jQuery.text = Sizzle.getText;\n+jQuery.isXMLDoc = Sizzle.isXML;\n+jQuery.contains = Sizzle.contains;\n+\n+\n+\n+var rneedsContext = jQuery.expr.match.needsContext;\n+\n+var rsingleTag = (/^<(\\w+)\\s*\\/?>(?:<\\/\\1>|)$/);\n+\n+\n+\n+var risSimple = /^.[^:#\\[\\.,]*$/;\n+\n+// Implement the identical functionality for filter and not\n+function winnow( elements, qualifier, not ) {\n+  if ( jQuery.isFunction( qualifier ) ) {\n+    return jQuery.grep( elements, function( elem, i ) {\n+      /* jshint -W018 */\n+      return !!qualifier.call( elem, i, elem ) !== not;\n+    });\n+\n+  }\n+\n+  if ( qualifier.nodeType ) {\n+    return jQuery.grep( elements, function( elem ) {\n+      return ( elem === qualifier ) !== not;\n+    });\n+\n+  }\n+\n+  if ( typeof qualifier === \"string\" ) {\n+    if ( risSimple.test( qualifier ) ) {\n+      return jQuery.filter( qualifier, elements, not );\n+    }\n+\n+    qualifier = jQuery.filter( qualifier, elements );\n+  }\n+\n+  return jQuery.grep( elements, function( elem ) {\n+    return ( indexOf.call( qualifier, elem ) >= 0 ) !== not;\n+  });\n+}\n+\n+jQuery.filter = function( expr, elems, not ) {\n+  var elem = elems[ 0 ];\n+\n+  if ( not ) {\n+    expr = \":not(\" + expr + \")\";\n+  }\n+\n+  return elems.length === 1 && elem.nodeType === 1 ?\n+    jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :\n+    jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {\n+      return elem.nodeType === 1;\n+    }));\n+};\n+\n+jQuery.fn.extend({\n+  find: function( selector ) {\n+    var i,\n+      len = this.length,\n+      ret = [],\n+      self = this;\n+\n+    if ( typeof selector !== \"string\" ) {\n+      return this.pushStack( jQuery( selector ).filter(function() {\n+        for ( i = 0; i < len; i++ ) {\n+          if ( jQuery.contains( self[ i ], this ) ) {\n+            return true;\n+          }\n+        }\n+      }) );\n+    }\n+\n+    for ( i = 0; i < len; i++ ) {\n+      jQuery.find( selector, self[ i ], ret );\n+    }\n+\n+    // Needed because $( selector, context ) becomes $( context ).find( selector )\n+    ret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );\n+    ret.selector = this.selector ? this.selector + \" \" + selector : selector;\n+    return ret;\n+  },\n+  filter: function( selector ) {\n+    return this.pushStack( winnow(this, selector || [], false) );\n+  },\n+  not: function( selector ) {\n+    return this.pushStack( winnow(this, selector || [], true) );\n+  },\n+  is: function( selector ) {\n+    return !!winnow(\n+      this,\n+\n+      // If this is a positional/relative selector, check membership in the returned set\n+      // so $(\"p:first\").is(\"p:last\") won't return true for a doc with two \"p\".\n+      typeof selector === \"string\" && rneedsContext.test( selector ) ?\n+        jQuery( selector ) :\n+        selector || [],\n+      false\n+    ).length;\n+  }\n+});\n+\n+\n+// Initialize a jQuery object\n+\n+\n+// A central reference to the root jQuery(document)\n+var rootjQuery,\n+\n+  // A simple way to check for HTML strings\n+  // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\n+  // Strict HTML recognition (#11290: must start with <)\n+  rquickExpr = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]*))$/,\n+\n+  init = jQuery.fn.init = function( selector, context ) {\n+    var match, elem;\n+\n+    // HANDLE: $(\"\"), $(null), $(undefined), $(false)\n+    if ( !selector ) {\n+      return this;\n+    }\n+\n+    // Handle HTML strings\n+    if ( typeof selector === \"string\" ) {\n+      if ( selector[0] === \"<\" && selector[ selector.length - 1 ] === \">\" && selector.length >= 3 ) {\n+        // Assume that strings that start and end with <> are HTML and skip the regex check\n+        match = [ null, selector, null ];\n+\n+      } else {\n+        match = rquickExpr.exec( selector );\n+      }\n+\n+      // Match html or make sure no context is specified for #id\n+      if ( match && (match[1] || !context) ) {\n+\n+        // HANDLE: $(html) -> $(array)\n+        if ( match[1] ) {\n+          context = context instanceof jQuery ? context[0] : context;\n+\n+          // scripts is true for back-compat\n+          // Intentionally let the error be thrown if parseHTML is not present\n+          jQuery.merge( this, jQuery.parseHTML(\n+            match[1],\n+            context && context.nodeType ? context.ownerDocument || context : document,\n+            true\n+          ) );\n+\n+          // HANDLE: $(html, props)\n+          if ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) ) {\n+            for ( match in context ) {\n+              // Properties of context are called as methods if possible\n+              if ( jQuery.isFunction( this[ match ] ) ) {\n+                this[ match ]( context[ match ] );\n+\n+              // ...and otherwise set as attributes\n+              } else {\n+                this.attr( match, context[ match ] );\n+              }\n+            }\n+          }\n+\n+          return this;\n+\n+        // HANDLE: $(#id)\n+        } else {\n+          elem = document.getElementById( match[2] );\n+\n+          // Check parentNode to catch when Blackberry 4.6 returns\n+          // nodes that are no longer in the document #6963\n+          if ( elem && elem.parentNode ) {\n+            // Inject the element directly into the jQuery object\n+            this.length = 1;\n+            this[0] = elem;\n+          }\n+\n+          this.context = document;\n+          this.selector = selector;\n+          return this;\n+        }\n+\n+      // HANDLE: $(expr, $(...))\n+      } else if ( !context || context.jquery ) {\n+        return ( context || rootjQuery ).find( selector );\n+\n+      // HANDLE: $(expr, context)\n+      // (which is just equivalent to: $(context).find(expr)\n+      } else {\n+        return this.constructor( context ).find( selector );\n+      }\n+\n+    // HANDLE: $(DOMElement)\n+    } else if ( selector.nodeType ) {\n+      this.context = this[0] = selector;\n+      this.length = 1;\n+      return this;\n+\n+    // HANDLE: $(function)\n+    // Shortcut for document ready\n+    } else if ( jQuery.isFunction( selector ) ) {\n+      return typeof rootjQuery.ready !== \"undefined\" ?\n+        rootjQuery.ready( selector ) :\n+        // Execute immediately if ready is not present\n+        selector( jQuery );\n+    }\n+\n+    if ( selector.selector !== undefined ) {\n+      this.selector = selector.selector;\n+      this.context = selector.context;\n+    }\n+\n+    return jQuery.makeArray( selector, this );\n+  };\n+\n+// Give the init function the jQuery prototype for later instantiation\n+init.prototype = jQuery.fn;\n+\n+// Initialize central reference\n+rootjQuery = jQuery( document );\n+\n+\n+var rparentsprev = /^(?:parents|prev(?:Until|All))/,\n+  // methods guaranteed to produce a unique set when starting from a unique set\n+  guaranteedUnique = {\n+    children: true,\n+    contents: true,\n+    next: true,\n+    prev: true\n+  };\n+\n+jQuery.extend({\n+  dir: function( elem, dir, until ) {\n+    var matched = [],\n+      truncate = until !== undefined;\n+\n+    while ( (elem = elem[ dir ]) && elem.nodeType !== 9 ) {\n+      if ( elem.nodeType === 1 ) {\n+        if ( truncate && jQuery( elem ).is( until ) ) {\n+          break;\n+        }\n+        matched.push( elem );\n+      }\n+    }\n+    return matched;\n+  },\n+\n+  sibling: function( n, elem ) {\n+    var matched = [];\n+\n+    for ( ; n; n = n.nextSibling ) {\n+      if ( n.nodeType === 1 && n !== elem ) {\n+        matched.push( n );\n+      }\n+    }\n+\n+    return matched;\n+  }\n+});\n+\n+jQuery.fn.extend({\n+  has: function( target ) {\n+    var targets = jQuery( target, this ),\n+      l = targets.length;\n+\n+    return this.filter(function() {\n+      var i = 0;\n+      for ( ; i < l; i++ ) {\n+        if ( jQuery.contains( this, targets[i] ) ) {\n+          return true;\n+        }\n+      }\n+    });\n+  },\n+\n+  closest: function( selectors, context ) {\n+    var cur,\n+      i = 0,\n+      l = this.length,\n+      matched = [],\n+      pos = rneedsContext.test( selectors ) || typeof selectors !== \"string\" ?\n+        jQuery( selectors, context || this.context ) :\n+        0;\n+\n+    for ( ; i < l; i++ ) {\n+      for ( cur = this[i]; cur && cur !== context; cur = cur.parentNode ) {\n+        // Always skip document fragments\n+        if ( cur.nodeType < 11 && (pos ?\n+          pos.index(cur) > -1 :\n+\n+          // Don't pass non-elements to Sizzle\n+          cur.nodeType === 1 &&\n+            jQuery.find.matchesSelector(cur, selectors)) ) {\n+\n+          matched.push( cur );\n+          break;\n+        }\n+      }\n+    }\n+\n+    return this.pushStack( matched.length > 1 ? jQuery.unique( matched ) : matched );\n+  },\n+\n+  // Determine the position of an element within\n+  // the matched set of elements\n+  index: function( elem ) {\n+\n+    // No argument, return index in parent\n+    if ( !elem ) {\n+      return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;\n+    }\n+\n+    // index in selector\n+    if ( typeof elem === \"string\" ) {\n+      return indexOf.call( jQuery( elem ), this[ 0 ] );\n+    }\n+\n+    // Locate the position of the desired element\n+    return indexOf.call( this,\n+\n+      // If it receives a jQuery object, the first element is used\n+      elem.jquery ? elem[ 0 ] : elem\n+    );\n+  },\n+\n+  add: function( selector, context ) {\n+    return this.pushStack(\n+      jQuery.unique(\n+        jQuery.merge( this.get(), jQuery( selector, context ) )\n+      )\n+    );\n+  },\n+\n+  addBack: function( selector ) {\n+    return this.add( selector == null ?\n+      this.prevObject : this.prevObject.filter(selector)\n+    );\n+  }\n+});\n+\n+function sibling( cur, dir ) {\n+  while ( (cur = cur[dir]) && cur.nodeType !== 1 ) {}\n+  return cur;\n+}\n+\n+jQuery.each({\n+  parent: function( elem ) {\n+    var parent = elem.parentNode;\n+    return parent && parent.nodeType !== 11 ? parent : null;\n+  },\n+  parents: function( elem ) {\n+    return jQuery.dir( elem, \"parentNode\" );\n+  },\n+  parentsUntil: function( elem, i, until ) {\n+    return jQuery.dir( elem, \"parentNode\", until );\n+  },\n+  next: function( elem ) {\n+    return sibling( elem, \"nextSibling\" );\n+  },\n+  prev: function( elem ) {\n+    return sibling( elem, \"previousSibling\" );\n+  },\n+  nextAll: function( elem ) {\n+    return jQuery.dir( elem, \"nextSibling\" );\n+  },\n+  prevAll: function( elem ) {\n+    return jQuery.dir( elem, \"previousSibling\" );\n+  },\n+  nextUntil: function( elem, i, until ) {\n+    return jQuery.dir( elem, \"nextSibling\", until );\n+  },\n+  prevUntil: function( elem, i, until ) {\n+    return jQuery.dir( elem, \"previousSibling\", until );\n+  },\n+  siblings: function( elem ) {\n+    return jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );\n+  },\n+  children: function( elem ) {\n+    return jQuery.sibling( elem.firstChild );\n+  },\n+  contents: function( elem ) {\n+    return elem.contentDocument || jQuery.merge( [], elem.childNodes );\n+  }\n+}, function( name, fn ) {\n+  jQuery.fn[ name ] = function( until, selector ) {\n+    var matched = jQuery.map( this, fn, until );\n+\n+    if ( name.slice( -5 ) !== \"Until\" ) {\n+      selector = until;\n+    }\n+\n+    if ( selector && typeof selector === \"string\" ) {\n+      matched = jQuery.filter( selector, matched );\n+    }\n+\n+    if ( this.length > 1 ) {\n+      // Remove duplicates\n+      if ( !guaranteedUnique[ name ] ) {\n+        jQuery.unique( matched );\n+      }\n+\n+      // Reverse order for parents* and prev-derivatives\n+      if ( rparentsprev.test( name ) ) {\n+        matched.reverse();\n+      }\n+    }\n+\n+    return this.pushStack( matched );\n+  };\n+});\n+var rnotwhite = (/\\S+/g);\n+\n+\n+\n+// String to Object options format cache\n+var optionsCache = {};\n+\n+// Convert String-formatted options into Object-formatted ones and store in cache\n+function createOptions( options ) {\n+  var object = optionsCache[ options ] = {};\n+  jQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {\n+    object[ flag ] = true;\n+  });\n+  return object;\n+}\n+\n+/*\n+ * Create a callback list using the following parameters:\n+ *\n+ *  options: an optional list of space-separated options that will change how\n+ *      the callback list behaves or a more traditional option object\n+ *\n+ * By default a callback list will act like an event callback list and can be\n+ * \"fired\" multiple times.\n+ *\n+ * Possible options:\n+ *\n+ *  once:     will ensure the callback list can only be fired once (like a Deferred)\n+ *\n+ *  memory:     will keep track of previous values and will call any callback added\n+ *          after the list has been fired right away with the latest \"memorized\"\n+ *          values (like a Deferred)\n+ *\n+ *  unique:     will ensure a callback can only be added once (no duplicate in the list)\n+ *\n+ *  stopOnFalse:  interrupt callings when a callback returns false\n+ *\n+ */\n+jQuery.Callbacks = function( options ) {\n+\n+  // Convert options from String-formatted to Object-formatted if needed\n+  // (we check in cache first)\n+  options = typeof options === \"string\" ?\n+    ( optionsCache[ options ] || createOptions( options ) ) :\n+    jQuery.extend( {}, options );\n+\n+  var // Last fire value (for non-forgettable lists)\n+    memory,\n+    // Flag to know if list was already fired\n+    fired,\n+    // Flag to know if list is currently firing\n+    firing,\n+    // First callback to fire (used internally by add and fireWith)\n+    firingStart,\n+    // End of the loop when firing\n+    firingLength,\n+    // Index of currently firing callback (modified by remove if needed)\n+    firingIndex,\n+    // Actual callback list\n+    list = [],\n+    // Stack of fire calls for repeatable lists\n+    stack = !options.once && [],\n+    // Fire callbacks\n+    fire = function( data ) {\n+      memory = options.memory && data;\n+      fired = true;\n+      firingIndex = firingStart || 0;\n+      firingStart = 0;\n+      firingLength = list.length;\n+      firing = true;\n+      for ( ; list && firingIndex < firingLength; firingIndex++ ) {\n+        if ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {\n+          memory = false; // To prevent further calls using add\n+          break;\n+        }\n+      }\n+      firing = false;\n+      if ( list ) {\n+        if ( stack ) {\n+          if ( stack.length ) {\n+            fire( stack.shift() );\n+          }\n+        } else if ( memory ) {\n+          list = [];\n+        } else {\n+          self.disable();\n+        }\n+      }\n+    },\n+    // Actual Callbacks object\n+    self = {\n+      // Add a callback or a collection of callbacks to the list\n+      add: function() {\n+        if ( list ) {\n+          // First, we save the current length\n+          var start = list.length;\n+          (function add( args ) {\n+            jQuery.each( args, function( _, arg ) {\n+              var type = jQuery.type( arg );\n+              if ( type === \"function\" ) {\n+                if ( !options.unique || !self.has( arg ) ) {\n+                  list.push( arg );\n+                }\n+              } else if ( arg && arg.length && type !== \"string\" ) {\n+                // Inspect recursively\n+                add( arg );\n+              }\n+            });\n+          })( arguments );\n+          // Do we need to add the callbacks to the\n+          // current firing batch?\n+          if ( firing ) {\n+            firingLength = list.length;\n+          // With memory, if we're not firing then\n+          // we should call right away\n+          } else if ( memory ) {\n+            firingStart = start;\n+            fire( memory );\n+          }\n+        }\n+        return this;\n+      },\n+      // Remove a callback from the list\n+      remove: function() {\n+        if ( list ) {\n+          jQuery.each( arguments, function( _, arg ) {\n+            var index;\n+            while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {\n+              list.splice( index, 1 );\n+              // Handle firing indexes\n+              if ( firing ) {\n+                if ( index <= firingLength ) {\n+                  firingLength--;\n+                }\n+                if ( index <= firingIndex ) {\n+                  firingIndex--;\n+                }\n+              }\n+            }\n+          });\n+        }\n+        return this;\n+      },\n+      // Check if a given callback is in the list.\n+      // If no argument is given, return whether or not list has callbacks attached.\n+      has: function( fn ) {\n+        return fn ? jQuery.inArray( fn, list ) > -1 : !!( list && list.length );\n+      },\n+      // Remove all callbacks from the list\n+      empty: function() {\n+        list = [];\n+        firingLength = 0;\n+        return this;\n+      },\n+      // Have the list do nothing anymore\n+      disable: function() {\n+        list = stack = memory = undefined;\n+        return this;\n+      },\n+      // Is it disabled?\n+      disabled: function() {\n+        return !list;\n+      },\n+      // Lock the list in its current state\n+      lock: function() {\n+        stack = undefined;\n+        if ( !memory ) {\n+          self.disable();\n+        }\n+        return this;\n+      },\n+      // Is it locked?\n+      locked: function() {\n+        return !stack;\n+      },\n+      // Call all callbacks with the given context and arguments\n+      fireWith: function( context, args ) {\n+        if ( list && ( !fired || stack ) ) {\n+          args = args || [];\n+          args = [ context, args.slice ? args.slice() : args ];\n+          if ( firing ) {\n+            stack.push( args );\n+          } else {\n+            fire( args );\n+          }\n+        }\n+        return this;\n+      },\n+      // Call all the callbacks with the given arguments\n+      fire: function() {\n+        self.fireWith( this, arguments );\n+        return this;\n+      },\n+      // To know if the callbacks have already been called at least once\n+      fired: function() {\n+        return !!fired;\n+      }\n+    };\n+\n+  return self;\n+};\n+\n+\n+jQuery.extend({\n+\n+  Deferred: function( func ) {\n+    var tuples = [\n+        // action, add listener, listener list, final state\n+        [ \"resolve\", \"done\", jQuery.Callbacks(\"once memory\"), \"resolved\" ],\n+        [ \"reject\", \"fail\", jQuery.Callbacks(\"once memory\"), \"rejected\" ],\n+        [ \"notify\", \"progress\", jQuery.Callbacks(\"memory\") ]\n+      ],\n+      state = \"pending\",\n+      promise = {\n+        state: function() {\n+          return state;\n+        },\n+        always: function() {\n+          deferred.done( arguments ).fail( arguments );\n+          return this;\n+        },\n+        then: function( /* fnDone, fnFail, fnProgress */ ) {\n+          var fns = arguments;\n+          return jQuery.Deferred(function( newDefer ) {\n+            jQuery.each( tuples, function( i, tuple ) {\n+              var fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];\n+              // deferred[ done | fail | progress ] for forwarding actions to newDefer\n+              deferred[ tuple[1] ](function() {\n+                var returned = fn && fn.apply( this, arguments );\n+                if ( returned && jQuery.isFunction( returned.promise ) ) {\n+                  returned.promise()\n+                    .done( newDefer.resolve )\n+                    .fail( newDefer.reject )\n+                    .progress( newDefer.notify );\n+                } else {\n+                  newDefer[ tuple[ 0 ] + \"With\" ]( this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments );\n+                }\n+              });\n+            });\n+            fns = null;\n+          }).promise();\n+        },\n+        // Get a promise for this deferred\n+        // If obj is provided, the promise aspect is added to the object\n+        promise: function( obj ) {\n+          return obj != null ? jQuery.extend( obj, promise ) : promise;\n+        }\n+      },\n+      deferred = {};\n+\n+    // Keep pipe for back-compat\n+    promise.pipe = promise.then;\n+\n+    // Add list-specific methods\n+    jQuery.each( tuples, function( i, tuple ) {\n+      var list = tuple[ 2 ],\n+        stateString = tuple[ 3 ];\n+\n+      // promise[ done | fail | progress ] = list.add\n+      promise[ tuple[1] ] = list.add;\n+\n+      // Handle state\n+      if ( stateString ) {\n+        list.add(function() {\n+          // state = [ resolved | rejected ]\n+          state = stateString;\n+\n+        // [ reject_list | resolve_list ].disable; progress_list.lock\n+        }, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );\n+      }\n+\n+      // deferred[ resolve | reject | notify ]\n+      deferred[ tuple[0] ] = function() {\n+        deferred[ tuple[0] + \"With\" ]( this === deferred ? promise : this, arguments );\n+        return this;\n+      };\n+      deferred[ tuple[0] + \"With\" ] = list.fireWith;\n+    });\n+\n+    // Make the deferred a promise\n+    promise.promise( deferred );\n+\n+    // Call given func if any\n+    if ( func ) {\n+      func.call( deferred, deferred );\n+    }\n+\n+    // All done!\n+    return deferred;\n+  },\n+\n+  // Deferred helper\n+  when: function( subordinate /* , ..., subordinateN */ ) {\n+    var i = 0,\n+      resolveValues = slice.call( arguments ),\n+      length = resolveValues.length,\n+\n+      // the count of uncompleted subordinates\n+      remaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,\n+\n+      // the master Deferred. If resolveValues consist of only a single Deferred, just use that.\n+      deferred = remaining === 1 ? subordinate : jQuery.Deferred(),\n+\n+      // Update function for both resolve and progress values\n+      updateFunc = function( i, contexts, values ) {\n+        return function( value ) {\n+          contexts[ i ] = this;\n+          values[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;\n+          if ( values === progressValues ) {\n+            deferred.notifyWith( contexts, values );\n+          } else if ( !( --remaining ) ) {\n+            deferred.resolveWith( contexts, values );\n+          }\n+        };\n+      },\n+\n+      progressValues, progressContexts, resolveContexts;\n+\n+    // add listeners to Deferred subordinates; treat others as resolved\n+    if ( length > 1 ) {\n+      progressValues = new Array( length );\n+      progressContexts = new Array( length );\n+      resolveContexts = new Array( length );\n+      for ( ; i < length; i++ ) {\n+        if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {\n+          resolveValues[ i ].promise()\n+            .done( updateFunc( i, resolveContexts, resolveValues ) )\n+            .fail( deferred.reject )\n+            .progress( updateFunc( i, progressContexts, progressValues ) );\n+        } else {\n+          --remaining;\n+        }\n+      }\n+    }\n+\n+    // if we're not waiting on anything, resolve the master\n+    if ( !remaining ) {\n+      deferred.resolveWith( resolveContexts, resolveValues );\n+    }\n+\n+    return deferred.promise();\n+  }\n+});\n+\n+\n+// The deferred used on DOM ready\n+var readyList;\n+\n+jQuery.fn.ready = function( fn ) {\n+  // Add the callback\n+  jQuery.ready.promise().done( fn );\n+\n+  return this;\n+};\n+\n+jQuery.extend({\n+  // Is the DOM ready to be used? Set to true once it occurs.\n+  isReady: false,\n+\n+  // A counter to track how many items to wait for before\n+  // the ready event fires. See #6781\n+  readyWait: 1,\n+\n+  // Hold (or release) the ready event\n+  holdReady: function( hold ) {\n+    if ( hold ) {\n+      jQuery.readyWait++;\n+    } else {\n+      jQuery.ready( true );\n+    }\n+  },\n+\n+  // Handle when the DOM is ready\n+  ready: function( wait ) {\n+\n+    // Abort if there are pending holds or we're already ready\n+    if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {\n+      return;\n+    }\n+\n+    // Remember that the DOM is ready\n+    jQuery.isReady = true;\n+\n+    // If a normal DOM Ready event fired, decrement, and wait if need be\n+    if ( wait !== true && --jQuery.readyWait > 0 ) {\n+      return;\n+    }\n+\n+    // If there are functions bound, to execute\n+    readyList.resolveWith( document, [ jQuery ] );\n+\n+    // Trigger any bound ready events\n+    if ( jQuery.fn.triggerHandler ) {\n+      jQuery( document ).triggerHandler( \"ready\" );\n+      jQuery( document ).off( \"ready\" );\n+    }\n+  }\n+});\n+\n+/**\n+ * The ready event handler and self cleanup method\n+ */\n+function completed() {\n+  document.removeEventListener( \"DOMContentLoaded\", completed, false );\n+  window.removeEventListener( \"load\", completed, false );\n+  jQuery.ready();\n+}\n+\n+jQuery.ready.promise = function( obj ) {\n+  if ( !readyList ) {\n+\n+    readyList = jQuery.Deferred();\n+\n+    // Catch cases where $(document).ready() is called after the browser event has already occurred.\n+    // we once tried to use readyState \"interactive\" here, but it caused issues like the one\n+    // discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15\n+    if ( document.readyState === \"complete\" ) {\n+      // Handle it asynchronously to allow scripts the opportunity to delay ready\n+      setTimeout( jQuery.ready );\n+\n+    } else {\n+\n+      // Use the handy event callback\n+      document.addEventListener( \"DOMContentLoaded\", completed, false );\n+\n+      // A fallback to window.onload, that will always work\n+      window.addEventListener( \"load\", completed, false );\n+    }\n+  }\n+  return readyList.promise( obj );\n+};\n+\n+// Kick off the DOM ready check even if the user does not\n+jQuery.ready.promise();\n+\n+\n+\n+\n+// Multifunctional method to get and set values of a collection\n+// The value/s can optionally be executed if it's a function\n+var access = jQuery.access = function( elems, fn, key, value, chainable, emptyGet, raw ) {\n+  var i = 0,\n+    len = elems.length,\n+    bulk = key == null;\n+\n+  // Sets many values\n+  if ( jQuery.type( key ) === \"object\" ) {\n+    chainable = true;\n+    for ( i in key ) {\n+      jQuery.access( elems, fn, i, key[i], true, emptyGet, raw );\n+    }\n+\n+  // Sets one value\n+  } else if ( value !== undefined ) {\n+    chainable = true;\n+\n+    if ( !jQuery.isFunction( value ) ) {\n+      raw = true;\n+    }\n+\n+    if ( bulk ) {\n+      // Bulk operations run against the entire set\n+      if ( raw ) {\n+        fn.call( elems, value );\n+        fn = null;\n+\n+      // ...except when executing function values\n+      } else {\n+        bulk = fn;\n+        fn = function( elem, key, value ) {\n+          return bulk.call( jQuery( elem ), value );\n+        };\n+      }\n+    }\n+\n+    if ( fn ) {\n+      for ( ; i < len; i++ ) {\n+        fn( elems[i], key, raw ? value : value.call( elems[i], i, fn( elems[i], key ) ) );\n+      }\n+    }\n+  }\n+\n+  return chainable ?\n+    elems :\n+\n+    // Gets\n+    bulk ?\n+      fn.call( elems ) :\n+      len ? fn( elems[0], key ) : emptyGet;\n+};\n+\n+\n+/**\n+ * Determines whether an object can have data\n+ */\n+jQuery.acceptData = function( owner ) {\n+  // Accepts only:\n+  //  - Node\n+  //    - Node.ELEMENT_NODE\n+  //    - Node.DOCUMENT_NODE\n+  //  - Object\n+  //    - Any\n+  /* jshint -W018 */\n+  return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );\n+};\n+\n+\n+function Data() {\n+  // Support: Android < 4,\n+  // Old WebKit does not have Object.preventExtensions/freeze method,\n+  // return new empty object instead with no [[set]] accessor\n+  Object.defineProperty( this.cache = {}, 0, {\n+    get: function() {\n+      return {};\n+    }\n+  });\n+\n+  this.expando = jQuery.expando + Math.random();\n+}\n+\n+Data.uid = 1;\n+Data.accepts = jQuery.acceptData;\n+\n+Data.prototype = {\n+  key: function( owner ) {\n+    // We can accept data for non-element nodes in modern browsers,\n+    // but we should not, see #8335.\n+    // Always return the key for a frozen object.\n+    if ( !Data.accepts( owner ) ) {\n+      return 0;\n+    }\n+\n+    var descriptor = {},\n+      // Check if the owner object already has a cache key\n+      unlock = owner[ this.expando ];\n+\n+    // If not, create one\n+    if ( !unlock ) {\n+      unlock = Data.uid++;\n+\n+      // Secure it in a non-enumerable, non-writable property\n+      try {\n+        descriptor[ this.expando ] = { value: unlock };\n+        Object.defineProperties( owner, descriptor );\n+\n+      // Support: Android < 4\n+      // Fallback to a less secure definition\n+      } catch ( e ) {\n+        descriptor[ this.expando ] = unlock;\n+        jQuery.extend( owner, descriptor );\n+      }\n+    }\n+\n+    // Ensure the cache object\n+    if ( !this.cache[ unlock ] ) {\n+      this.cache[ unlock ] = {};\n+    }\n+\n+    return unlock;\n+  },\n+  set: function( owner, data, value ) {\n+    var prop,\n+      // There may be an unlock assigned to this node,\n+      // if there is no entry for this \"owner\", create one inline\n+      // and set the unlock as though an owner entry had always existed\n+      unlock = this.key( owner ),\n+      cache = this.cache[ unlock ];\n+\n+    // Handle: [ owner, key, value ] args\n+    if ( typeof data === \"string\" ) {\n+      cache[ data ] = value;\n+\n+    // Handle: [ owner, { properties } ] args\n+    } else {\n+      // Fresh assignments by object are shallow copied\n+      if ( jQuery.isEmptyObject( cache ) ) {\n+        jQuery.extend( this.cache[ unlock ], data );\n+      // Otherwise, copy the properties one-by-one to the cache object\n+      } else {\n+        for ( prop in data ) {\n+          cache[ prop ] = data[ prop ];\n+        }\n+      }\n+    }\n+    return cache;\n+  },\n+  get: function( owner, key ) {\n+    // Either a valid cache is found, or will be created.\n+    // New caches will be created and the unlock returned,\n+    // allowing direct access to the newly created\n+    // empty data object. A valid owner object must be provided.\n+    var cache = this.cache[ this.key( owner ) ];\n+\n+    return key === undefined ?\n+      cache : cache[ key ];\n+  },\n+  access: function( owner, key, value ) {\n+    var stored;\n+    // In cases where either:\n+    //\n+    //   1. No key was specified\n+    //   2. A string key was specified, but no value provided\n+    //\n+    // Take the \"read\" path and allow the get method to determine\n+    // which value to return, respectively either:\n+    //\n+    //   1. The entire cache object\n+    //   2. The data stored at the key\n+    //\n+    if ( key === undefined ||\n+        ((key && typeof key === \"string\") && value === undefined) ) {\n+\n+      stored = this.get( owner, key );\n+\n+      return stored !== undefined ?\n+        stored : this.get( owner, jQuery.camelCase(key) );\n+    }\n+\n+    // [*]When the key is not a string, or both a key and value\n+    // are specified, set or extend (existing objects) with either:\n+    //\n+    //   1. An object of properties\n+    //   2. A key and value\n+    //\n+    this.set( owner, key, value );\n+\n+    // Since the \"set\" path can have two possible entry points\n+    // return the expected data based on which path was taken[*]\n+    return value !== undefined ? value : key;\n+  },\n+  remove: function( owner, key ) {\n+    var i, name, camel,\n+      unlock = this.key( owner ),\n+      cache = this.cache[ unlock ];\n+\n+    if ( key === undefined ) {\n+      this.cache[ unlock ] = {};\n+\n+    } else {\n+      // Support array or space separated string of keys\n+      if ( jQuery.isArray( key ) ) {\n+        // If \"name\" is an array of keys...\n+        // When data is initially created, via (\"key\", \"val\") signature,\n+        // keys will be converted to camelCase.\n+        // Since there is no way to tell _how_ a key was added, remove\n+        // both plain key and camelCase key. #12786\n+        // This will only penalize the array argument path.\n+        name = key.concat( key.map( jQuery.camelCase ) );\n+      } else {\n+        camel = jQuery.camelCase( key );\n+        // Try the string as a key before any manipulation\n+        if ( key in cache ) {\n+          name = [ key, camel ];\n+        } else {\n+          // If a key with the spaces exists, use it.\n+          // Otherwise, create an array by matching non-whitespace\n+          name = camel;\n+          name = name in cache ?\n+            [ name ] : ( name.match( rnotwhite ) || [] );\n+        }\n+      }\n+\n+      i = name.length;\n+      while ( i-- ) {\n+        delete cache[ name[ i ] ];\n+      }\n+    }\n+  },\n+  hasData: function( owner ) {\n+    return !jQuery.isEmptyObject(\n+      this.cache[ owner[ this.expando ] ] || {}\n+    );\n+  },\n+  discard: function( owner ) {\n+    if ( owner[ this.expando ] ) {\n+      delete this.cache[ owner[ this.expando ] ];\n+    }\n+  }\n+};\n+var data_priv = new Data();\n+\n+var data_user = new Data();\n+\n+\n+\n+/*\n+  Implementation Summary\n+\n+  1. Enforce API surface and semantic compatibility with 1.9.x branch\n+  2. Improve the module's maintainability by reducing the storage\n+    paths to a single mechanism.\n+  3. Use the same single mechanism to support \"private\" and \"user\" data.\n+  4. _Never_ expose \"private\" data to user code (TODO: Drop _data, _removeData)\n+  5. Avoid exposing implementation details on user objects (eg. expando properties)\n+  6. Provide a clear path for implementation upgrade to WeakMap in 2014\n+*/\n+var rbrace = /^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$/,\n+  rmultiDash = /([A-Z])/g;\n+\n+function dataAttr( elem, key, data ) {\n+  var name;\n+\n+  // If nothing was found internally, try to fetch any\n+  // data from the HTML5 data-* attribute\n+  if ( data === undefined && elem.nodeType === 1 ) {\n+    name = \"data-\" + key.replace( rmultiDash, \"-$1\" ).toLowerCase();\n+    data = elem.getAttribute( name );\n+\n+    if ( typeof data === \"string\" ) {\n+      try {\n+        data = data === \"true\" ? true :\n+          data === \"false\" ? false :\n+          data === \"null\" ? null :\n+          // Only convert to a number if it doesn't change the string\n+          +data + \"\" === data ? +data :\n+          rbrace.test( data ) ? jQuery.parseJSON( data ) :\n+          data;\n+      } catch( e ) {}\n+\n+      // Make sure we set the data so it isn't changed later\n+      data_user.set( elem, key, data );\n+    } else {\n+      data = undefined;\n+    }\n+  }\n+  return data;\n+}\n+\n+jQuery.extend({\n+  hasData: function( elem ) {\n+    return data_user.hasData( elem ) || data_priv.hasData( elem );\n+  },\n+\n+  data: function( elem, name, data ) {\n+    return data_user.access( elem, name, data );\n+  },\n+\n+  removeData: function( elem, name ) {\n+    data_user.remove( elem, name );\n+  },\n+\n+  // TODO: Now that all calls to _data and _removeData have been replaced\n+  // with direct calls to data_priv methods, these can be deprecated.\n+  _data: function( elem, name, data ) {\n+    return data_priv.access( elem, name, data );\n+  },\n+\n+  _removeData: function( elem, name ) {\n+    data_priv.remove( elem, name );\n+  }\n+});\n+\n+jQuery.fn.extend({\n+  data: function( key, value ) {\n+    var i, name, data,\n+      elem = this[ 0 ],\n+      attrs = elem && elem.attributes;\n+\n+    // Gets all values\n+    if ( key === undefined ) {\n+      if ( this.length ) {\n+        data = data_user.get( elem );\n+\n+        if ( elem.nodeType === 1 && !data_priv.get( elem, \"hasDataAttrs\" ) ) {\n+          i = attrs.length;\n+          while ( i-- ) {\n+\n+            // Support: IE11+\n+            // The attrs elements can be null (#14894)\n+            if ( attrs[ i ] ) {\n+              name = attrs[ i ].name;\n+              if ( name.indexOf( \"data-\" ) === 0 ) {\n+                name = jQuery.camelCase( name.slice(5) );\n+                dataAttr( elem, name, data[ name ] );\n+              }\n+            }\n+          }\n+          data_priv.set( elem, \"hasDataAttrs\", true );\n+        }\n+      }\n+\n+      return data;\n+    }\n+\n+    // Sets multiple values\n+    if ( typeof key === \"object\" ) {\n+      return this.each(function() {\n+        data_user.set( this, key );\n+      });\n+    }\n+\n+    return access( this, function( value ) {\n+      var data,\n+        camelKey = jQuery.camelCase( key );\n+\n+      // The calling jQuery object (element matches) is not empty\n+      // (and therefore has an element appears at this[ 0 ]) and the\n+      // `value` parameter was not undefined. An empty jQuery object\n+      // will result in `undefined` for elem = this[ 0 ] which will\n+      // throw an exception if an attempt to read a data cache is made.\n+      if ( elem && value === undefined ) {\n+        // Attempt to get data from the cache\n+        // with the key as-is\n+        data = data_user.get( elem, key );\n+        if ( data !== undefined ) {\n+          return data;\n+        }\n+\n+        // Attempt to get data from the cache\n+        // with the key camelized\n+        data = data_user.get( elem, camelKey );\n+        if ( data !== undefined ) {\n+          return data;\n+        }\n+\n+        // Attempt to \"discover\" the data in\n+        // HTML5 custom data-* attrs\n+        data = dataAttr( elem, camelKey, undefined );\n+        if ( data !== undefined ) {\n+          return data;\n+        }\n+\n+        // We tried really hard, but the data doesn't exist.\n+        return;\n+      }\n+\n+      // Set the data...\n+      this.each(function() {\n+        // First, attempt to store a copy or reference of any\n+        // data that might've been store with a camelCased key.\n+        var data = data_user.get( this, camelKey );\n+\n+        // For HTML5 data-* attribute interop, we have to\n+        // store property names with dashes in a camelCase form.\n+        // This might not apply to all properties...*\n+        data_user.set( this, camelKey, value );\n+\n+        // *... In the case of properties that might _actually_\n+        // have dashes, we need to also store a copy of that\n+        // unchanged property.\n+        if ( key.indexOf(\"-\") !== -1 && data !== undefined ) {\n+          data_user.set( this, key, value );\n+        }\n+      });\n+    }, null, value, arguments.length > 1, null, true );\n+  },\n+\n+  removeData: function( key ) {\n+    return this.each(function() {\n+      data_user.remove( this, key );\n+    });\n+  }\n+});\n+\n+\n+jQuery.extend({\n+  queue: function( elem, type, data ) {\n+    var queue;\n+\n+    if ( elem ) {\n+      type = ( type || \"fx\" ) + \"queue\";\n+      queue = data_priv.get( elem, type );\n+\n+      // Speed up dequeue by getting out quickly if this is just a lookup\n+      if ( data ) {\n+        if ( !queue || jQuery.isArray( data ) ) {\n+          queue = data_priv.access( elem, type, jQuery.makeArray(data) );\n+        } else {\n+          queue.push( data );\n+        }\n+      }\n+      return queue || [];\n+    }\n+  },\n+\n+  dequeue: function( elem, type ) {\n+    type = type || \"fx\";\n+\n+    var queue = jQuery.queue( elem, type ),\n+      startLength = queue.length,\n+      fn = queue.shift(),\n+      hooks = jQuery._queueHooks( elem, type ),\n+      next = function() {\n+        jQuery.dequeue( elem, type );\n+      };\n+\n+    // If the fx queue is dequeued, always remove the progress sentinel\n+    if ( fn === \"inprogress\" ) {\n+      fn = queue.shift();\n+      startLength--;\n+    }\n+\n+    if ( fn ) {\n+\n+      // Add a progress sentinel to prevent the fx queue from being\n+      // automatically dequeued\n+      if ( type === \"fx\" ) {\n+        queue.unshift( \"inprogress\" );\n+      }\n+\n+      // clear up the last queue stop function\n+      delete hooks.stop;\n+      fn.call( elem, next, hooks );\n+    }\n+\n+    if ( !startLength && hooks ) {\n+      hooks.empty.fire();\n+    }\n+  },\n+\n+  // not intended for public consumption - generates a queueHooks object, or returns the current one\n+  _queueHooks: function( elem, type ) {\n+    var key = type + \"queueHooks\";\n+    return data_priv.get( elem, key ) || data_priv.access( elem, key, {\n+      empty: jQuery.Callbacks(\"once memory\").add(function() {\n+        data_priv.remove( elem, [ type + \"queue\", key ] );\n+      })\n+    });\n+  }\n+});\n+\n+jQuery.fn.extend({\n+  queue: function( type, data ) {\n+    var setter = 2;\n+\n+    if ( typeof type !== \"string\" ) {\n+      data = type;\n+      type = \"fx\";\n+      setter--;\n+    }\n+\n+    if ( arguments.length < setter ) {\n+      return jQuery.queue( this[0], type );\n+    }\n+\n+    return data === undefined ?\n+      this :\n+      this.each(function() {\n+        var queue = jQuery.queue( this, type, data );\n+\n+        // ensure a hooks for this queue\n+        jQuery._queueHooks( this, type );\n+\n+        if ( type === \"fx\" && queue[0] !== \"inprogress\" ) {\n+          jQuery.dequeue( this, type );\n+        }\n+      });\n+  },\n+  dequeue: function( type ) {\n+    return this.each(function() {\n+      jQuery.dequeue( this, type );\n+    });\n+  },\n+  clearQueue: function( type ) {\n+    return this.queue( type || \"fx\", [] );\n+  },\n+  // Get a promise resolved when queues of a certain type\n+  // are emptied (fx is the type by default)\n+  promise: function( type, obj ) {\n+    var tmp,\n+      count = 1,\n+      defer = jQuery.Deferred(),\n+      elements = this,\n+      i = this.length,\n+      resolve = function() {\n+        if ( !( --count ) ) {\n+          defer.resolveWith( elements, [ elements ] );\n+        }\n+      };\n+\n+    if ( typeof type !== \"string\" ) {\n+      obj = type;\n+      type = undefined;\n+    }\n+    type = type || \"fx\";\n+\n+    while ( i-- ) {\n+      tmp = data_priv.get( elements[ i ], type + \"queueHooks\" );\n+      if ( tmp && tmp.empty ) {\n+        count++;\n+        tmp.empty.add( resolve );\n+      }\n+    }\n+    resolve();\n+    return defer.promise( obj );\n+  }\n+});\n+var pnum = (/[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/).source;\n+\n+var cssExpand = [ \"Top\", \"Right\", \"Bottom\", \"Left\" ];\n+\n+var isHidden = function( elem, el ) {\n+    // isHidden might be called from jQuery#filter function;\n+    // in that case, element will be second argument\n+    elem = el || elem;\n+    return jQuery.css( elem, \"display\" ) === \"none\" || !jQuery.contains( elem.ownerDocument, elem );\n+  };\n+\n+var rcheckableType = (/^(?:checkbox|radio)$/i);\n+\n+\n+\n+(function() {\n+  var fragment = document.createDocumentFragment(),\n+    div = fragment.appendChild( document.createElement( \"div\" ) ),\n+    input = document.createElement( \"input\" );\n+\n+  // #11217 - WebKit loses check when the name is after the checked attribute\n+  // Support: Windows Web Apps (WWA)\n+  // `name` and `type` need .setAttribute for WWA\n+  input.setAttribute( \"type\", \"radio\" );\n+  input.setAttribute( \"checked\", \"checked\" );\n+  input.setAttribute( \"name\", \"t\" );\n+\n+  div.appendChild( input );\n+\n+  // Support: Safari 5.1, iOS 5.1, Android 4.x, Android 2.3\n+  // old WebKit doesn't clone checked state correctly in fragments\n+  support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;\n+\n+  // Make sure textarea (and checkbox) defaultValue is properly cloned\n+  // Support: IE9-IE11+\n+  div.innerHTML = \"<textarea>x</textarea>\";\n+  support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;\n+})();\n+var strundefined = typeof undefined;\n+\n+\n+\n+support.focusinBubbles = \"onfocusin\" in window;\n+\n+\n+var\n+  rkeyEvent = /^key/,\n+  rmouseEvent = /^(?:mouse|pointer|contextmenu)|click/,\n+  rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,\n+  rtypenamespace = /^([^.]*)(?:\\.(.+)|)$/;\n+\n+function returnTrue() {\n+  return true;\n+}\n+\n+function returnFalse() {\n+  return false;\n+}\n+\n+function safeActiveElement() {\n+  try {\n+    return document.activeElement;\n+  } catch ( err ) { }\n+}\n+\n+/*\n+ * Helper functions for managing events -- not part of the public interface.\n+ * Props to Dean Edwards' addEvent library for many of the ideas.\n+ */\n+jQuery.event = {\n+\n+  global: {},\n+\n+  add: function( elem, types, handler, data, selector ) {\n+\n+    var handleObjIn, eventHandle, tmp,\n+      events, t, handleObj,\n+      special, handlers, type, namespaces, origType,\n+      elemData = data_priv.get( elem );\n+\n+    // Don't attach events to noData or text/comment nodes (but allow plain objects)\n+    if ( !elemData ) {\n+      return;\n+    }\n+\n+    // Caller can pass in an object of custom data in lieu of the handler\n+    if ( handler.handler ) {\n+      handleObjIn = handler;\n+      handler = handleObjIn.handler;\n+      selector = handleObjIn.selector;\n+    }\n+\n+    // Make sure that the handler has a unique ID, used to find/remove it later\n+    if ( !handler.guid ) {\n+      handler.guid = jQuery.guid++;\n+    }\n+\n+    // Init the element's event structure and main handler, if this is the first\n+    if ( !(events = elemData.events) ) {\n+      events = elemData.events = {};\n+    }\n+    if ( !(eventHandle = elemData.handle) ) {\n+      eventHandle = elemData.handle = function( e ) {\n+        // Discard the second event of a jQuery.event.trigger() and\n+        // when an event is called after a page has unloaded\n+        return typeof jQuery !== strundefined && jQuery.event.triggered !== e.type ?\n+          jQuery.event.dispatch.apply( elem, arguments ) : undefined;\n+      };\n+    }\n+\n+    // Handle multiple events separated by a space\n+    types = ( types || \"\" ).match( rnotwhite ) || [ \"\" ];\n+    t = types.length;\n+    while ( t-- ) {\n+      tmp = rtypenamespace.exec( types[t] ) || [];\n+      type = origType = tmp[1];\n+      namespaces = ( tmp[2] || \"\" ).split( \".\" ).sort();\n+\n+      // There *must* be a type, no attaching namespace-only handlers\n+      if ( !type ) {\n+        continue;\n+      }\n+\n+      // If event changes its type, use the special event handlers for the changed type\n+      special = jQuery.event.special[ type ] || {};\n+\n+      // If selector defined, determine special event api type, otherwise given type\n+      type = ( selector ? special.delegateType : special.bindType ) || type;\n+\n+      // Update special based on newly reset type\n+      special = jQuery.event.special[ type ] || {};\n+\n+      // handleObj is passed to all event handlers\n+      handleObj = jQuery.extend({\n+        type: type,\n+        origType: origType,\n+        data: data,\n+        handler: handler,\n+        guid: handler.guid,\n+        selector: selector,\n+        needsContext: selector && jQuery.expr.match.needsContext.test( selector ),\n+        namespace: namespaces.join(\".\")\n+      }, handleObjIn );\n+\n+      // Init the event handler queue if we're the first\n+      if ( !(handlers = events[ type ]) ) {\n+        handlers = events[ type ] = [];\n+        handlers.delegateCount = 0;\n+\n+        // Only use addEventListener if the special events handler returns false\n+        if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {\n+          if ( elem.addEventListener ) {\n+            elem.addEventListener( type, eventHandle, false );\n+          }\n+        }\n+      }\n+\n+      if ( special.add ) {\n+        special.add.call( elem, handleObj );\n+\n+        if ( !handleObj.handler.guid ) {\n+          handleObj.handler.guid = handler.guid;\n+        }\n+      }\n+\n+      // Add to the element's handler list, delegates in front\n+      if ( selector ) {\n+        handlers.splice( handlers.delegateCount++, 0, handleObj );\n+      } else {\n+        handlers.push( handleObj );\n+      }\n+\n+      // Keep track of which events have ever been used, for event optimization\n+      jQuery.event.global[ type ] = true;\n+    }\n+\n+  },\n+\n+  // Detach an event or set of events from an element\n+  remove: function( elem, types, handler, selector, mappedTypes ) {\n+\n+    var j, origCount, tmp,\n+      events, t, handleObj,\n+      special, handlers, type, namespaces, origType,\n+      elemData = data_priv.hasData( elem ) && data_priv.get( elem );\n+\n+    if ( !elemData || !(events = elemData.events) ) {\n+      return;\n+    }\n+\n+    // Once for each type.namespace in types; type may be omitted\n+    types = ( types || \"\" ).match( rnotwhite ) || [ \"\" ];\n+    t = types.length;\n+    while ( t-- ) {\n+      tmp = rtypenamespace.exec( types[t] ) || [];\n+      type = origType = tmp[1];\n+      namespaces = ( tmp[2] || \"\" ).split( \".\" ).sort();\n+\n+      // Unbind all events (on this namespace, if provided) for the element\n+      if ( !type ) {\n+        for ( type in events ) {\n+          jQuery.event.remove( elem, type + types[ t ], handler, selector, true );\n+        }\n+        continue;\n+      }\n+\n+      special = jQuery.event.special[ type ] || {};\n+      type = ( selector ? special.delegateType : special.bindType ) || type;\n+      handlers = events[ type ] || [];\n+      tmp = tmp[2] && new RegExp( \"(^|\\\\.)\" + namespaces.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\" );\n+\n+      // Remove matching events\n+      origCount = j = handlers.length;\n+      while ( j-- ) {\n+        handleObj = handlers[ j ];\n+\n+        if ( ( mappedTypes || origType === handleObj.origType ) &&\n+          ( !handler || handler.guid === handleObj.guid ) &&\n+          ( !tmp || tmp.test( handleObj.namespace ) ) &&\n+          ( !selector || selector === handleObj.selector || selector === \"**\" && handleObj.selector ) ) {\n+          handlers.splice( j, 1 );\n+\n+          if ( handleObj.selector ) {\n+            handlers.delegateCount--;\n+          }\n+          if ( special.remove ) {\n+            special.remove.call( elem, handleObj );\n+          }\n+        }\n+      }\n+\n+      // Remove generic event handler if we removed something and no more handlers exist\n+      // (avoids potential for endless recursion during removal of special event handlers)\n+      if ( origCount && !handlers.length ) {\n+        if ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {\n+          jQuery.removeEvent( elem, type, elemData.handle );\n+        }\n+\n+        delete events[ type ];\n+      }\n+    }\n+\n+    // Remove the expando if it's no longer used\n+    if ( jQuery.isEmptyObject( events ) ) {\n+      delete elemData.handle;\n+      data_priv.remove( elem, \"events\" );\n+    }\n+  },\n+\n+  trigger: function( event, data, elem, onlyHandlers ) {\n+\n+    var i, cur, tmp, bubbleType, ontype, handle, special,\n+      eventPath = [ elem || document ],\n+      type = hasOwn.call( event, \"type\" ) ? event.type : event,\n+      namespaces = hasOwn.call( event, \"namespace\" ) ? event.namespace.split(\".\") : [];\n+\n+    cur = tmp = elem = elem || document;\n+\n+    // Don't do events on text and comment nodes\n+    if ( elem.nodeType === 3 || elem.nodeType === 8 ) {\n+      return;\n+    }\n+\n+    // focus/blur morphs to focusin/out; ensure we're not firing them right now\n+    if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {\n+      return;\n+    }\n+\n+    if ( type.indexOf(\".\") >= 0 ) {\n+      // Namespaced trigger; create a regexp to match event type in handle()\n+      namespaces = type.split(\".\");\n+      type = namespaces.shift();\n+      namespaces.sort();\n+    }\n+    ontype = type.indexOf(\":\") < 0 && \"on\" + type;\n+\n+    // Caller can pass in a jQuery.Event object, Object, or just an event type string\n+    event = event[ jQuery.expando ] ?\n+      event :\n+      new jQuery.Event( type, typeof event === \"object\" && event );\n+\n+    // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)\n+    event.isTrigger = onlyHandlers ? 2 : 3;\n+    event.namespace = namespaces.join(\".\");\n+    event.namespace_re = event.namespace ?\n+      new RegExp( \"(^|\\\\.)\" + namespaces.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\" ) :\n+      null;\n+\n+    // Clean up the event in case it is being reused\n+    event.result = undefined;\n+    if ( !event.target ) {\n+      event.target = elem;\n+    }\n+\n+    // Clone any incoming data and prepend the event, creating the handler arg list\n+    data = data == null ?\n+      [ event ] :\n+      jQuery.makeArray( data, [ event ] );\n+\n+    // Allow special events to draw outside the lines\n+    special = jQuery.event.special[ type ] || {};\n+    if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {\n+      return;\n+    }\n+\n+    // Determine event propagation path in advance, per W3C events spec (#9951)\n+    // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)\n+    if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {\n+\n+      bubbleType = special.delegateType || type;\n+      if ( !rfocusMorph.test( bubbleType + type ) ) {\n+        cur = cur.parentNode;\n+      }\n+      for ( ; cur; cur = cur.parentNode ) {\n+        eventPath.push( cur );\n+        tmp = cur;\n+      }\n+\n+      // Only add window if we got to document (e.g., not plain obj or detached DOM)\n+      if ( tmp === (elem.ownerDocument || document) ) {\n+        eventPath.push( tmp.defaultView || tmp.parentWindow || window );\n+      }\n+    }\n+\n+    // Fire handlers on the event path\n+    i = 0;\n+    while ( (cur = eventPath[i++]) && !event.isPropagationStopped() ) {\n+\n+      event.type = i > 1 ?\n+        bubbleType :\n+        special.bindType || type;\n+\n+      // jQuery handler\n+      handle = ( data_priv.get( cur, \"events\" ) || {} )[ event.type ] && data_priv.get( cur, \"handle\" );\n+      if ( handle ) {\n+        handle.apply( cur, data );\n+      }\n+\n+      // Native handler\n+      handle = ontype && cur[ ontype ];\n+      if ( handle && handle.apply && jQuery.acceptData( cur ) ) {\n+        event.result = handle.apply( cur, data );\n+        if ( event.result === false ) {\n+          event.preventDefault();\n+        }\n+      }\n+    }\n+    event.type = type;\n+\n+    // If nobody prevented the default action, do it now\n+    if ( !onlyHandlers && !event.isDefaultPrevented() ) {\n+\n+      if ( (!special._default || special._default.apply( eventPath.pop(), data ) === false) &&\n+        jQuery.acceptData( elem ) ) {\n+\n+        // Call a native DOM method on the target with the same name name as the event.\n+        // Don't do default actions on window, that's where global variables be (#6170)\n+        if ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {\n+\n+          // Don't re-trigger an onFOO event when we call its FOO() method\n+          tmp = elem[ ontype ];\n+\n+          if ( tmp ) {\n+            elem[ ontype ] = null;\n+          }\n+\n+          // Prevent re-triggering of the same event, since we already bubbled it above\n+          jQuery.event.triggered = type;\n+          elem[ type ]();\n+          jQuery.event.triggered = undefined;\n+\n+          if ( tmp ) {\n+            elem[ ontype ] = tmp;\n+          }\n+        }\n+      }\n+    }\n+\n+    return event.result;\n+  },\n+\n+  dispatch: function( event ) {\n+\n+    // Make a writable jQuery.Event from the native event object\n+    event = jQuery.event.fix( event );\n+\n+    var i, j, ret, matched, handleObj,\n+      handlerQueue = [],\n+      args = slice.call( arguments ),\n+      handlers = ( data_priv.get( this, \"events\" ) || {} )[ event.type ] || [],\n+      special = jQuery.event.special[ event.type ] || {};\n+\n+    // Use the fix-ed jQuery.Event rather than the (read-only) native event\n+    args[0] = event;\n+    event.delegateTarget = this;\n+\n+    // Call the preDispatch hook for the mapped type, and let it bail if desired\n+    if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {\n+      return;\n+    }\n+\n+    // Determine handlers\n+    handlerQueue = jQuery.event.handlers.call( this, event, handlers );\n+\n+    // Run delegates first; they may want to stop propagation beneath us\n+    i = 0;\n+    while ( (matched = handlerQueue[ i++ ]) && !event.isPropagationStopped() ) {\n+      event.currentTarget = matched.elem;\n+\n+      j = 0;\n+      while ( (handleObj = matched.handlers[ j++ ]) && !event.isImmediatePropagationStopped() ) {\n+\n+        // Triggered event must either 1) have no namespace, or\n+        // 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).\n+        if ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {\n+\n+          event.handleObj = handleObj;\n+          event.data = handleObj.data;\n+\n+          ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )\n+              .apply( matched.elem, args );\n+\n+          if ( ret !== undefined ) {\n+            if ( (event.result = ret) === false ) {\n+              event.preventDefault();\n+              event.stopPropagation();\n+            }\n+          }\n+        }\n+      }\n+    }\n+\n+    // Call the postDispatch hook for the mapped type\n+    if ( special.postDispatch ) {\n+      special.postDispatch.call( this, event );\n+    }\n+\n+    return event.result;\n+  },\n+\n+  handlers: function( event, handlers ) {\n+    var i, matches, sel, handleObj,\n+      handlerQueue = [],\n+      delegateCount = handlers.delegateCount,\n+      cur = event.target;\n+\n+    // Find delegate handlers\n+    // Black-hole SVG <use> instance trees (#13180)\n+    // Avoid non-left-click bubbling in Firefox (#3861)\n+    if ( delegateCount && cur.nodeType && (!event.button || event.type !== \"click\") ) {\n+\n+      for ( ; cur !== this; cur = cur.parentNode || this ) {\n+\n+        // Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)\n+        if ( cur.disabled !== true || event.type !== \"click\" ) {\n+          matches = [];\n+          for ( i = 0; i < delegateCount; i++ ) {\n+            handleObj = handlers[ i ];\n+\n+            // Don't conflict with Object.prototype properties (#13203)\n+            sel = handleObj.selector + \" \";\n+\n+            if ( matches[ sel ] === undefined ) {\n+              matches[ sel ] = handleObj.needsContext ?\n+                jQuery( sel, this ).index( cur ) >= 0 :\n+                jQuery.find( sel, this, null, [ cur ] ).length;\n+            }\n+            if ( matches[ sel ] ) {\n+              matches.push( handleObj );\n+            }\n+          }\n+          if ( matches.length ) {\n+            handlerQueue.push({ elem: cur, handlers: matches });\n+          }\n+        }\n+      }\n+    }\n+\n+    // Add the remaining (directly-bound) handlers\n+    if ( delegateCount < handlers.length ) {\n+      handlerQueue.push({ elem: this, handlers: handlers.slice( delegateCount ) });\n+    }\n+\n+    return handlerQueue;\n+  },\n+\n+  // Includes some event props shared by KeyEvent and MouseEvent\n+  props: \"altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which\".split(\" \"),\n+\n+  fixHooks: {},\n+\n+  keyHooks: {\n+    props: \"char charCode key keyCode\".split(\" \"),\n+    filter: function( event, original ) {\n+\n+      // Add which for key events\n+      if ( event.which == null ) {\n+        event.which = original.charCode != null ? original.charCode : original.keyCode;\n+      }\n+\n+      return event;\n+    }\n+  },\n+\n+  mouseHooks: {\n+    props: \"button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement\".split(\" \"),\n+    filter: function( event, original ) {\n+      var eventDoc, doc, body,\n+        button = original.button;\n+\n+      // Calculate pageX/Y if missing and clientX/Y available\n+      if ( event.pageX == null && original.clientX != null ) {\n+        eventDoc = event.target.ownerDocument || document;\n+        doc = eventDoc.documentElement;\n+        body = eventDoc.body;\n+\n+        event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );\n+        event.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );\n+      }\n+\n+      // Add which for click: 1 === left; 2 === middle; 3 === right\n+      // Note: button is not normalized, so don't use it\n+      if ( !event.which && button !== undefined ) {\n+        event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );\n+      }\n+\n+      return event;\n+    }\n+  },\n+\n+  fix: function( event ) {\n+    if ( event[ jQuery.expando ] ) {\n+      return event;\n+    }\n+\n+    // Create a writable copy of the event object and normalize some properties\n+    var i, prop, copy,\n+      type = event.type,\n+      originalEvent = event,\n+      fixHook = this.fixHooks[ type ];\n+\n+    if ( !fixHook ) {\n+      this.fixHooks[ type ] = fixHook =\n+        rmouseEvent.test( type ) ? this.mouseHooks :\n+        rkeyEvent.test( type ) ? this.keyHooks :\n+        {};\n+    }\n+    copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;\n+\n+    event = new jQuery.Event( originalEvent );\n+\n+    i = copy.length;\n+    while ( i-- ) {\n+      prop = copy[ i ];\n+      event[ prop ] = originalEvent[ prop ];\n+    }\n+\n+    // Support: Cordova 2.5 (WebKit) (#13255)\n+    // All events should have a target; Cordova deviceready doesn't\n+    if ( !event.target ) {\n+      event.target = document;\n+    }\n+\n+    // Support: Safari 6.0+, Chrome < 28\n+    // Target should not be a text node (#504, #13143)\n+    if ( event.target.nodeType === 3 ) {\n+      event.target = event.target.parentNode;\n+    }\n+\n+    return fixHook.filter ? fixHook.filter( event, originalEvent ) : event;\n+  },\n+\n+  special: {\n+    load: {\n+      // Prevent triggered image.load events from bubbling to window.load\n+      noBubble: true\n+    },\n+    focus: {\n+      // Fire native event if possible so blur/focus sequence is correct\n+      trigger: function() {\n+        if ( this !== safeActiveElement() && this.focus ) {\n+          this.focus();\n+          return false;\n+        }\n+      },\n+      delegateType: \"focusin\"\n+    },\n+    blur: {\n+      trigger: function() {\n+        if ( this === safeActiveElement() && this.blur ) {\n+          this.blur();\n+          return false;\n+        }\n+      },\n+      delegateType: \"focusout\"\n+    },\n+    click: {\n+      // For checkbox, fire native event so checked state will be right\n+      trigger: function() {\n+        if ( this.type === \"checkbox\" && this.click && jQuery.nodeName( this, \"input\" ) ) {\n+          this.click();\n+          return false;\n+        }\n+      },\n+\n+      // For cross-browser consistency, don't fire native .click() on links\n+      _default: function( event ) {\n+        return jQuery.nodeName( event.target, \"a\" );\n+      }\n+    },\n+\n+    beforeunload: {\n+      postDispatch: function( event ) {\n+\n+        // Support: Firefox 20+\n+        // Firefox doesn't alert if the returnValue field is not set.\n+        if ( event.result !== undefined && event.originalEvent ) {\n+          event.originalEvent.returnValue = event.result;\n+        }\n+      }\n+    }\n+  },\n+\n+  simulate: function( type, elem, event, bubble ) {\n+    // Piggyback on a donor event to simulate a different one.\n+    // Fake originalEvent to avoid donor's stopPropagation, but if the\n+    // simulated event prevents default then we do the same on the donor.\n+    var e = jQuery.extend(\n+      new jQuery.Event(),\n+      event,\n+      {\n+        type: type,\n+        isSimulated: true,\n+        originalEvent: {}\n+      }\n+    );\n+    if ( bubble ) {\n+      jQuery.event.trigger( e, null, elem );\n+    } else {\n+      jQuery.event.dispatch.call( elem, e );\n+    }\n+    if ( e.isDefaultPrevented() ) {\n+      event.preventDefault();\n+    }\n+  }\n+};\n+\n+jQuery.removeEvent = function( elem, type, handle ) {\n+  if ( elem.removeEventListener ) {\n+    elem.removeEventListener( type, handle, false );\n+  }\n+};\n+\n+jQuery.Event = function( src, props ) {\n+  // Allow instantiation without the 'new' keyword\n+  if ( !(this instanceof jQuery.Event) ) {\n+    return new jQuery.Event( src, props );\n+  }\n+\n+  // Event object\n+  if ( src && src.type ) {\n+    this.originalEvent = src;\n+    this.type = src.type;\n+\n+    // Events bubbling up the document may have been marked as prevented\n+    // by a handler lower down the tree; reflect the correct value.\n+    this.isDefaultPrevented = src.defaultPrevented ||\n+        src.defaultPrevented === undefined &&\n+        // Support: Android < 4.0\n+        src.returnValue === false ?\n+      returnTrue :\n+      returnFalse;\n+\n+  // Event type\n+  } else {\n+    this.type = src;\n+  }\n+\n+  // Put explicitly provided properties onto the event object\n+  if ( props ) {\n+    jQuery.extend( this, props );\n+  }\n+\n+  // Create a timestamp if incoming event doesn't have one\n+  this.timeStamp = src && src.timeStamp || jQuery.now();\n+\n+  // Mark it as fixed\n+  this[ jQuery.expando ] = true;\n+};\n+\n+// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\n+// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\n+jQuery.Event.prototype = {\n+  isDefaultPrevented: returnFalse,\n+  isPropagationStopped: returnFalse,\n+  isImmediatePropagationStopped: returnFalse,\n+\n+  preventDefault: function() {\n+    var e = this.originalEvent;\n+\n+    this.isDefaultPrevented = returnTrue;\n+\n+    if ( e && e.preventDefault ) {\n+      e.preventDefault();\n+    }\n+  },\n+  stopPropagation: function() {\n+    var e = this.originalEvent;\n+\n+    this.isPropagationStopped = returnTrue;\n+\n+    if ( e && e.stopPropagation ) {\n+      e.stopPropagation();\n+    }\n+  },\n+  stopImmediatePropagation: function() {\n+    var e = this.originalEvent;\n+\n+    this.isImmediatePropagationStopped = returnTrue;\n+\n+    if ( e && e.stopImmediatePropagation ) {\n+      e.stopImmediatePropagation();\n+    }\n+\n+    this.stopPropagation();\n+  }\n+};\n+\n+// Create mouseenter/leave events using mouseover/out and event-time checks\n+// Support: Chrome 15+\n+jQuery.each({\n+  mouseenter: \"mouseover\",\n+  mouseleave: \"mouseout\",\n+  pointerenter: \"pointerover\",\n+  pointerleave: \"pointerout\"\n+}, function( orig, fix ) {\n+  jQuery.event.special[ orig ] = {\n+    delegateType: fix,\n+    bindType: fix,\n+\n+    handle: function( event ) {\n+      var ret,\n+        target = this,\n+        related = event.relatedTarget,\n+        handleObj = event.handleObj;\n+\n+      // For mousenter/leave call the handler if related is outside the target.\n+      // NB: No relatedTarget if the mouse left/entered the browser window\n+      if ( !related || (related !== target && !jQuery.contains( target, related )) ) {\n+        event.type = handleObj.origType;\n+        ret = handleObj.handler.apply( this, arguments );\n+        event.type = fix;\n+      }\n+      return ret;\n+    }\n+  };\n+});\n+\n+// Create \"bubbling\" focus and blur events\n+// Support: Firefox, Chrome, Safari\n+if ( !support.focusinBubbles ) {\n+  jQuery.each({ focus: \"focusin\", blur: \"focusout\" }, function( orig, fix ) {\n+\n+    // Attach a single capturing handler on the document while someone wants focusin/focusout\n+    var handler = function( event ) {\n+        jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );\n+      };\n+\n+    jQuery.event.special[ fix ] = {\n+      setup: function() {\n+        var doc = this.ownerDocument || this,\n+          attaches = data_priv.access( doc, fix );\n+\n+        if ( !attaches ) {\n+          doc.addEventListener( orig, handler, true );\n+        }\n+        data_priv.access( doc, fix, ( attaches || 0 ) + 1 );\n+      },\n+      teardown: function() {\n+        var doc = this.ownerDocument || this,\n+          attaches = data_priv.access( doc, fix ) - 1;\n+\n+        if ( !attaches ) {\n+          doc.removeEventListener( orig, handler, true );\n+          data_priv.remove( doc, fix );\n+\n+        } else {\n+          data_priv.access( doc, fix, attaches );\n+        }\n+      }\n+    };\n+  });\n+}\n+\n+jQuery.fn.extend({\n+\n+  on: function( types, selector, data, fn, /*INTERNAL*/ one ) {\n+    var origFn, type;\n+\n+    // Types can be a map of types/handlers\n+    if ( typeof types === \"object\" ) {\n+      // ( types-Object, selector, data )\n+      if ( typeof selector !== \"string\" ) {\n+        // ( types-Object, data )\n+        data = data || selector;\n+        selector = undefined;\n+      }\n+      for ( type in types ) {\n+        this.on( type, selector, data, types[ type ], one );\n+      }\n+      return this;\n+    }\n+\n+    if ( data == null && fn == null ) {\n+      // ( types, fn )\n+      fn = selector;\n+      data = selector = undefined;\n+    } else if ( fn == null ) {\n+      if ( typeof selector === \"string\" ) {\n+        // ( types, selector, fn )\n+        fn = data;\n+        data = undefined;\n+      } else {\n+        // ( types, data, fn )\n+        fn = data;\n+        data = selector;\n+        selector = undefined;\n+      }\n+    }\n+    if ( fn === false ) {\n+      fn = returnFalse;\n+    } else if ( !fn ) {\n+      return this;\n+    }\n+\n+    if ( one === 1 ) {\n+      origFn = fn;\n+      fn = function( event ) {\n+        // Can use an empty set, since event contains the info\n+        jQuery().off( event );\n+        return origFn.apply( this, arguments );\n+      };\n+      // Use same guid so caller can remove using origFn\n+      fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );\n+    }\n+    return this.each( function() {\n+      jQuery.event.add( this, types, fn, data, selector );\n+    });\n+  },\n+  one: function( types, selector, data, fn ) {\n+    return this.on( types, selector, data, fn, 1 );\n+  },\n+  off: function( types, selector, fn ) {\n+    var handleObj, type;\n+    if ( types && types.preventDefault && types.handleObj ) {\n+      // ( event )  dispatched jQuery.Event\n+      handleObj = types.handleObj;\n+      jQuery( types.delegateTarget ).off(\n+        handleObj.namespace ? handleObj.origType + \".\" + handleObj.namespace : handleObj.origType,\n+        handleObj.selector,\n+        handleObj.handler\n+      );\n+      return this;\n+    }\n+    if ( typeof types === \"object\" ) {\n+      // ( types-object [, selector] )\n+      for ( type in types ) {\n+        this.off( type, selector, types[ type ] );\n+      }\n+      return this;\n+    }\n+    if ( selector === false || typeof selector === \"function\" ) {\n+      // ( types [, fn] )\n+      fn = selector;\n+      selector = undefined;\n+    }\n+    if ( fn === false ) {\n+      fn = returnFalse;\n+    }\n+    return this.each(function() {\n+      jQuery.event.remove( this, types, fn, selector );\n+    });\n+  },\n+\n+  trigger: function( type, data ) {\n+    return this.each(function() {\n+      jQuery.event.trigger( type, data, this );\n+    });\n+  },\n+  triggerHandler: function( type, data ) {\n+    var elem = this[0];\n+    if ( elem ) {\n+      return jQuery.event.trigger( type, data, elem, true );\n+    }\n+  }\n+});\n+\n+\n+var\n+  rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:]+)[^>]*)\\/>/gi,\n+  rtagName = /<([\\w:]+)/,\n+  rhtml = /<|&#?\\w+;/,\n+  rnoInnerhtml = /<(?:script|style|link)/i,\n+  // checked=\"checked\" or checked\n+  rchecked = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\n+  rscriptType = /^$|\\/(?:java|ecma)script/i,\n+  rscriptTypeMasked = /^true\\/(.*)/,\n+  rcleanScript = /^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g,\n+\n+  // We have to close these tags to support XHTML (#13200)\n+  wrapMap = {\n+\n+    // Support: IE 9\n+    option: [ 1, \"<select multiple='multiple'>\", \"</select>\" ],\n+\n+    thead: [ 1, \"<table>\", \"</table>\" ],\n+    col: [ 2, \"<table><colgroup>\", \"</colgroup></table>\" ],\n+    tr: [ 2, \"<table><tbody>\", \"</tbody></table>\" ],\n+    td: [ 3, \"<table><tbody><tr>\", \"</tr></tbody></table>\" ],\n+\n+    _default: [ 0, \"\", \"\" ]\n+  };\n+\n+// Support: IE 9\n+wrapMap.optgroup = wrapMap.option;\n+\n+wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\n+wrapMap.th = wrapMap.td;\n+\n+// Support: 1.x compatibility\n+// Manipulating tables requires a tbody\n+function manipulationTarget( elem, content ) {\n+  return jQuery.nodeName( elem, \"table\" ) &&\n+    jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, \"tr\" ) ?\n+\n+    elem.getElementsByTagName(\"tbody\")[0] ||\n+      elem.appendChild( elem.ownerDocument.createElement(\"tbody\") ) :\n+    elem;\n+}\n+\n+// Replace/restore the type attribute of script elements for safe DOM manipulation\n+function disableScript( elem ) {\n+  elem.type = (elem.getAttribute(\"type\") !== null) + \"/\" + elem.type;\n+  return elem;\n+}\n+function restoreScript( elem ) {\n+  var match = rscriptTypeMasked.exec( elem.type );\n+\n+  if ( match ) {\n+    elem.type = match[ 1 ];\n+  } else {\n+    elem.removeAttribute(\"type\");\n+  }\n+\n+  return elem;\n+}\n+\n+// Mark scripts as having already been evaluated\n+function setGlobalEval( elems, refElements ) {\n+  var i = 0,\n+    l = elems.length;\n+\n+  for ( ; i < l; i++ ) {\n+    data_priv.set(\n+      elems[ i ], \"globalEval\", !refElements || data_priv.get( refElements[ i ], \"globalEval\" )\n+    );\n+  }\n+}\n+\n+function cloneCopyEvent( src, dest ) {\n+  var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;\n+\n+  if ( dest.nodeType !== 1 ) {\n+    return;\n+  }\n+\n+  // 1. Copy private data: events, handlers, etc.\n+  if ( data_priv.hasData( src ) ) {\n+    pdataOld = data_priv.access( src );\n+    pdataCur = data_priv.set( dest, pdataOld );\n+    events = pdataOld.events;\n+\n+    if ( events ) {\n+      delete pdataCur.handle;\n+      pdataCur.events = {};\n+\n+      for ( type in events ) {\n+        for ( i = 0, l = events[ type ].length; i < l; i++ ) {\n+          jQuery.event.add( dest, type, events[ type ][ i ] );\n+        }\n+      }\n+    }\n+  }\n+\n+  // 2. Copy user data\n+  if ( data_user.hasData( src ) ) {\n+    udataOld = data_user.access( src );\n+    udataCur = jQuery.extend( {}, udataOld );\n+\n+    data_user.set( dest, udataCur );\n+  }\n+}\n+\n+function getAll( context, tag ) {\n+  var ret = context.getElementsByTagName ? context.getElementsByTagName( tag || \"*\" ) :\n+      context.querySelectorAll ? context.querySelectorAll( tag || \"*\" ) :\n+      [];\n+\n+  return tag === undefined || tag && jQuery.nodeName( context, tag ) ?\n+    jQuery.merge( [ context ], ret ) :\n+    ret;\n+}\n+\n+// Support: IE >= 9\n+function fixInput( src, dest ) {\n+  var nodeName = dest.nodeName.toLowerCase();\n+\n+  // Fails to persist the checked state of a cloned checkbox or radio button.\n+  if ( nodeName === \"input\" && rcheckableType.test( src.type ) ) {\n+    dest.checked = src.checked;\n+\n+  // Fails to return the selected option to the default selected state when cloning options\n+  } else if ( nodeName === \"input\" || nodeName === \"textarea\" ) {\n+    dest.defaultValue = src.defaultValue;\n+  }\n+}\n+\n+jQuery.extend({\n+  clone: function( elem, dataAndEvents, deepDataAndEvents ) {\n+    var i, l, srcElements, destElements,\n+      clone = elem.cloneNode( true ),\n+      inPage = jQuery.contains( elem.ownerDocument, elem );\n+\n+    // Support: IE >= 9\n+    // Fix Cloning issues\n+    if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&\n+        !jQuery.isXMLDoc( elem ) ) {\n+\n+      // We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2\n+      destElements = getAll( clone );\n+      srcElements = getAll( elem );\n+\n+      for ( i = 0, l = srcElements.length; i < l; i++ ) {\n+        fixInput( srcElements[ i ], destElements[ i ] );\n+      }\n+    }\n+\n+    // Copy the events from the original to the clone\n+    if ( dataAndEvents ) {\n+      if ( deepDataAndEvents ) {\n+        srcElements = srcElements || getAll( elem );\n+        destElements = destElements || getAll( clone );\n+\n+        for ( i = 0, l = srcElements.length; i < l; i++ ) {\n+          cloneCopyEvent( srcElements[ i ], destElements[ i ] );\n+        }\n+      } else {\n+        cloneCopyEvent( elem, clone );\n+      }\n+    }\n+\n+    // Preserve script evaluation history\n+    destElements = getAll( clone, \"script\" );\n+    if ( destElements.length > 0 ) {\n+      setGlobalEval( destElements, !inPage && getAll( elem, \"script\" ) );\n+    }\n+\n+    // Return the cloned set\n+    return clone;\n+  },\n+\n+  buildFragment: function( elems, context, scripts, selection ) {\n+    var elem, tmp, tag, wrap, contains, j,\n+      fragment = context.createDocumentFragment(),\n+      nodes = [],\n+      i = 0,\n+      l = elems.length;\n+\n+    for ( ; i < l; i++ ) {\n+      elem = elems[ i ];\n+\n+      if ( elem || elem === 0 ) {\n+\n+        // Add nodes directly\n+        if ( jQuery.type( elem ) === \"object\" ) {\n+          // Support: QtWebKit\n+          // jQuery.merge because push.apply(_, arraylike) throws\n+          jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );\n+\n+        // Convert non-html into a text node\n+        } else if ( !rhtml.test( elem ) ) {\n+          nodes.push( context.createTextNode( elem ) );\n+\n+        // Convert html into DOM nodes\n+        } else {\n+          tmp = tmp || fragment.appendChild( context.createElement(\"div\") );\n+\n+          // Deserialize a standard representation\n+          tag = ( rtagName.exec( elem ) || [ \"\", \"\" ] )[ 1 ].toLowerCase();\n+          wrap = wrapMap[ tag ] || wrapMap._default;\n+          tmp.innerHTML = wrap[ 1 ] + elem.replace( rxhtmlTag, \"<$1></$2>\" ) + wrap[ 2 ];\n+\n+          // Descend through wrappers to the right content\n+          j = wrap[ 0 ];\n+          while ( j-- ) {\n+            tmp = tmp.lastChild;\n+          }\n+\n+          // Support: QtWebKit\n+          // jQuery.merge because push.apply(_, arraylike) throws\n+          jQuery.merge( nodes, tmp.childNodes );\n+\n+          // Remember the top-level container\n+          tmp = fragment.firstChild;\n+\n+          // Fixes #12346\n+          // Support: Webkit, IE\n+          tmp.textContent = \"\";\n+        }\n+      }\n+    }\n+\n+    // Remove wrapper from fragment\n+    fragment.textContent = \"\";\n+\n+    i = 0;\n+    while ( (elem = nodes[ i++ ]) ) {\n+\n+      // #4087 - If origin and destination elements are the same, and this is\n+      // that element, do not do anything\n+      if ( selection && jQuery.inArray( elem, selection ) !== -1 ) {\n+        continue;\n+      }\n+\n+      contains = jQuery.contains( elem.ownerDocument, elem );\n+\n+      // Append to fragment\n+      tmp = getAll( fragment.appendChild( elem ), \"script\" );\n+\n+      // Preserve script evaluation history\n+      if ( contains ) {\n+        setGlobalEval( tmp );\n+      }\n+\n+      // Capture executables\n+      if ( scripts ) {\n+        j = 0;\n+        while ( (elem = tmp[ j++ ]) ) {\n+          if ( rscriptType.test( elem.type || \"\" ) ) {\n+            scripts.push( elem );\n+          }\n+        }\n+      }\n+    }\n+\n+    return fragment;\n+  },\n+\n+  cleanData: function( elems ) {\n+    var data, elem, type, key,\n+      special = jQuery.event.special,\n+      i = 0;\n+\n+    for ( ; (elem = elems[ i ]) !== undefined; i++ ) {\n+      if ( jQuery.acceptData( elem ) ) {\n+        key = elem[ data_priv.expando ];\n+\n+        if ( key && (data = data_priv.cache[ key ]) ) {\n+          if ( data.events ) {\n+            for ( type in data.events ) {\n+              if ( special[ type ] ) {\n+                jQuery.event.remove( elem, type );\n+\n+              // This is a shortcut to avoid jQuery.event.remove's overhead\n+              } else {\n+                jQuery.removeEvent( elem, type, data.handle );\n+              }\n+            }\n+          }\n+          if ( data_priv.cache[ key ] ) {\n+            // Discard any remaining `private` data\n+            delete data_priv.cache[ key ];\n+          }\n+        }\n+      }\n+      // Discard any remaining `user` data\n+      delete data_user.cache[ elem[ data_user.expando ] ];\n+    }\n+  }\n+});\n+\n+jQuery.fn.extend({\n+  text: function( value ) {\n+    return access( this, function( value ) {\n+      return value === undefined ?\n+        jQuery.text( this ) :\n+        this.empty().each(function() {\n+          if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n+            this.textContent = value;\n+          }\n+        });\n+    }, null, value, arguments.length );\n+  },\n+\n+  append: function() {\n+    return this.domManip( arguments, function( elem ) {\n+      if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n+        var target = manipulationTarget( this, elem );\n+        target.appendChild( elem );\n+      }\n+    });\n+  },\n+\n+  prepend: function() {\n+    return this.domManip( arguments, function( elem ) {\n+      if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n+        var target = manipulationTarget( this, elem );\n+        target.insertBefore( elem, target.firstChild );\n+      }\n+    });\n+  },\n+\n+  before: function() {\n+    return this.domManip( arguments, function( elem ) {\n+      if ( this.parentNode ) {\n+        this.parentNode.insertBefore( elem, this );\n+      }\n+    });\n+  },\n+\n+  after: function() {\n+    return this.domManip( arguments, function( elem ) {\n+      if ( this.parentNode ) {\n+        this.parentNode.insertBefore( elem, this.nextSibling );\n+      }\n+    });\n+  },\n+\n+  remove: function( selector, keepData /* Internal Use Only */ ) {\n+    var elem,\n+      elems = selector ? jQuery.filter( selector, this ) : this,\n+      i = 0;\n+\n+    for ( ; (elem = elems[i]) != null; i++ ) {\n+      if ( !keepData && elem.nodeType === 1 ) {\n+        jQuery.cleanData( getAll( elem ) );\n+      }\n+\n+      if ( elem.parentNode ) {\n+        if ( keepData && jQuery.contains( elem.ownerDocument, elem ) ) {\n+          setGlobalEval( getAll( elem, \"script\" ) );\n+        }\n+        elem.parentNode.removeChild( elem );\n+      }\n+    }\n+\n+    return this;\n+  },\n+\n+  empty: function() {\n+    var elem,\n+      i = 0;\n+\n+    for ( ; (elem = this[i]) != null; i++ ) {\n+      if ( elem.nodeType === 1 ) {\n+\n+        // Prevent memory leaks\n+        jQuery.cleanData( getAll( elem, false ) );\n+\n+        // Remove any remaining nodes\n+        elem.textContent = \"\";\n+      }\n+    }\n+\n+    return this;\n+  },\n+\n+  clone: function( dataAndEvents, deepDataAndEvents ) {\n+    dataAndEvents = dataAndEvents == null ? false : dataAndEvents;\n+    deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;\n+\n+    return this.map(function() {\n+      return jQuery.clone( this, dataAndEvents, deepDataAndEvents );\n+    });\n+  },\n+\n+  html: function( value ) {\n+    return access( this, function( value ) {\n+      var elem = this[ 0 ] || {},\n+        i = 0,\n+        l = this.length;\n+\n+      if ( value === undefined && elem.nodeType === 1 ) {\n+        return elem.innerHTML;\n+      }\n+\n+      // See if we can take a shortcut and just use innerHTML\n+      if ( typeof value === \"string\" && !rnoInnerhtml.test( value ) &&\n+        !wrapMap[ ( rtagName.exec( value ) || [ \"\", \"\" ] )[ 1 ].toLowerCase() ] ) {\n+\n+        value = value.replace( rxhtmlTag, \"<$1></$2>\" );\n+\n+        try {\n+          for ( ; i < l; i++ ) {\n+            elem = this[ i ] || {};\n+\n+            // Remove element nodes and prevent memory leaks\n+            if ( elem.nodeType === 1 ) {\n+              jQuery.cleanData( getAll( elem, false ) );\n+              elem.innerHTML = value;\n+            }\n+          }\n+\n+          elem = 0;\n+\n+        // If using innerHTML throws an exception, use the fallback method\n+        } catch( e ) {}\n+      }\n+\n+      if ( elem ) {\n+        this.empty().append( value );\n+      }\n+    }, null, value, arguments.length );\n+  },\n+\n+  replaceWith: function() {\n+    var arg = arguments[ 0 ];\n+\n+    // Make the changes, replacing each context element with the new content\n+    this.domManip( arguments, function( elem ) {\n+      arg = this.parentNode;\n+\n+      jQuery.cleanData( getAll( this ) );\n+\n+      if ( arg ) {\n+        arg.replaceChild( elem, this );\n+      }\n+    });\n+\n+    // Force removal if there was no new content (e.g., from empty arguments)\n+    return arg && (arg.length || arg.nodeType) ? this : this.remove();\n+  },\n+\n+  detach: function( selector ) {\n+    return this.remove( selector, true );\n+  },\n+\n+  domManip: function( args, callback ) {\n+\n+    // Flatten any nested arrays\n+    args = concat.apply( [], args );\n+\n+    var fragment, first, scripts, hasScripts, node, doc,\n+      i = 0,\n+      l = this.length,\n+      set = this,\n+      iNoClone = l - 1,\n+      value = args[ 0 ],\n+      isFunction = jQuery.isFunction( value );\n+\n+    // We can't cloneNode fragments that contain checked, in WebKit\n+    if ( isFunction ||\n+        ( l > 1 && typeof value === \"string\" &&\n+          !support.checkClone && rchecked.test( value ) ) ) {\n+      return this.each(function( index ) {\n+        var self = set.eq( index );\n+        if ( isFunction ) {\n+          args[ 0 ] = value.call( this, index, self.html() );\n+        }\n+        self.domManip( args, callback );\n+      });\n+    }\n+\n+    if ( l ) {\n+      fragment = jQuery.buildFragment( args, this[ 0 ].ownerDocument, false, this );\n+      first = fragment.firstChild;\n+\n+      if ( fragment.childNodes.length === 1 ) {\n+        fragment = first;\n+      }\n+\n+      if ( first ) {\n+        scripts = jQuery.map( getAll( fragment, \"script\" ), disableScript );\n+        hasScripts = scripts.length;\n+\n+        // Use the original fragment for the last item instead of the first because it can end up\n+        // being emptied incorrectly in certain situations (#8070).\n+        for ( ; i < l; i++ ) {\n+          node = fragment;\n+\n+          if ( i !== iNoClone ) {\n+            node = jQuery.clone( node, true, true );\n+\n+            // Keep references to cloned scripts for later restoration\n+            if ( hasScripts ) {\n+              // Support: QtWebKit\n+              // jQuery.merge because push.apply(_, arraylike) throws\n+              jQuery.merge( scripts, getAll( node, \"script\" ) );\n+            }\n+          }\n+\n+          callback.call( this[ i ], node, i );\n+        }\n+\n+        if ( hasScripts ) {\n+          doc = scripts[ scripts.length - 1 ].ownerDocument;\n+\n+          // Reenable scripts\n+          jQuery.map( scripts, restoreScript );\n+\n+          // Evaluate executable scripts on first document insertion\n+          for ( i = 0; i < hasScripts; i++ ) {\n+            node = scripts[ i ];\n+            if ( rscriptType.test( node.type || \"\" ) &&\n+              !data_priv.access( node, \"globalEval\" ) && jQuery.contains( doc, node ) ) {\n+\n+              if ( node.src ) {\n+                // Optional AJAX dependency, but won't run scripts if not present\n+                if ( jQuery._evalUrl ) {\n+                  jQuery._evalUrl( node.src );\n+                }\n+              } else {\n+                jQuery.globalEval( node.textContent.replace( rcleanScript, \"\" ) );\n+              }\n+            }\n+          }\n+        }\n+      }\n+    }\n+\n+    return this;\n+  }\n+});\n+\n+jQuery.each({\n+  appendTo: \"append\",\n+  prependTo: \"prepend\",\n+  insertBefore: \"before\",\n+  insertAfter: \"after\",\n+  replaceAll: \"replaceWith\"\n+}, function( name, original ) {\n+  jQuery.fn[ name ] = function( selector ) {\n+    var elems,\n+      ret = [],\n+      insert = jQuery( selector ),\n+      last = insert.length - 1,\n+      i = 0;\n+\n+    for ( ; i <= last; i++ ) {\n+      elems = i === last ? this : this.clone( true );\n+      jQuery( insert[ i ] )[ original ]( elems );\n+\n+      // Support: QtWebKit\n+      // .get() because push.apply(_, arraylike) throws\n+      push.apply( ret, elems.get() );\n+    }\n+\n+    return this.pushStack( ret );\n+  };\n+});\n+\n+\n+var iframe,\n+  elemdisplay = {};\n+\n+/**\n+ * Retrieve the actual display of a element\n+ * @param {String} name nodeName of the element\n+ * @param {Object} doc Document object\n+ */\n+// Called only from within defaultDisplay\n+function actualDisplay( name, doc ) {\n+  var style,\n+    elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),\n+\n+    // getDefaultComputedStyle might be reliably used only on attached element\n+    display = window.getDefaultComputedStyle && ( style = window.getDefaultComputedStyle( elem[ 0 ] ) ) ?\n+\n+      // Use of this method is a temporary fix (more like optmization) until something better comes along,\n+      // since it was removed from specification and supported only in FF\n+      style.display : jQuery.css( elem[ 0 ], \"display\" );\n+\n+  // We don't have any data stored on the element,\n+  // so use \"detach\" method as fast way to get rid of the element\n+  elem.detach();\n+\n+  return display;\n+}\n+\n+/**\n+ * Try to determine the default display value of an element\n+ * @param {String} nodeName\n+ */\n+function defaultDisplay( nodeName ) {\n+  var doc = document,\n+    display = elemdisplay[ nodeName ];\n+\n+  if ( !display ) {\n+    display = actualDisplay( nodeName, doc );\n+\n+    // If the simple way fails, read from inside an iframe\n+    if ( display === \"none\" || !display ) {\n+\n+      // Use the already-created iframe if possible\n+      iframe = (iframe || jQuery( \"<iframe frameborder='0' width='0' height='0'/>\" )).appendTo( doc.documentElement );\n+\n+      // Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse\n+      doc = iframe[ 0 ].contentDocument;\n+\n+      // Support: IE\n+      doc.write();\n+      doc.close();\n+\n+      display = actualDisplay( nodeName, doc );\n+      iframe.detach();\n+    }\n+\n+    // Store the correct default display\n+    elemdisplay[ nodeName ] = display;\n+  }\n+\n+  return display;\n+}\n+var rmargin = (/^margin/);\n+\n+var rnumnonpx = new RegExp( \"^(\" + pnum + \")(?!px)[a-z%]+$\", \"i\" );\n+\n+var getStyles = function( elem ) {\n+    return elem.ownerDocument.defaultView.getComputedStyle( elem, null );\n+  };\n+\n+\n+\n+function curCSS( elem, name, computed ) {\n+  var width, minWidth, maxWidth, ret,\n+    style = elem.style;\n+\n+  computed = computed || getStyles( elem );\n+\n+  // Support: IE9\n+  // getPropertyValue is only needed for .css('filter') in IE9, see #12537\n+  if ( computed ) {\n+    ret = computed.getPropertyValue( name ) || computed[ name ];\n+  }\n+\n+  if ( computed ) {\n+\n+    if ( ret === \"\" && !jQuery.contains( elem.ownerDocument, elem ) ) {\n+      ret = jQuery.style( elem, name );\n+    }\n+\n+    // Support: iOS < 6\n+    // A tribute to the \"awesome hack by Dean Edwards\"\n+    // iOS < 6 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels\n+    // this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values\n+    if ( rnumnonpx.test( ret ) && rmargin.test( name ) ) {\n+\n+      // Remember the original values\n+      width = style.width;\n+      minWidth = style.minWidth;\n+      maxWidth = style.maxWidth;\n+\n+      // Put in the new values to get a computed value out\n+      style.minWidth = style.maxWidth = style.width = ret;\n+      ret = computed.width;\n+\n+      // Revert the changed values\n+      style.width = width;\n+      style.minWidth = minWidth;\n+      style.maxWidth = maxWidth;\n+    }\n+  }\n+\n+  return ret !== undefined ?\n+    // Support: IE\n+    // IE returns zIndex value as an integer.\n+    ret + \"\" :\n+    ret;\n+}\n+\n+\n+function addGetHookIf( conditionFn, hookFn ) {\n+  // Define the hook, we'll check on the first run if it's really needed.\n+  return {\n+    get: function() {\n+      if ( conditionFn() ) {\n+        // Hook not needed (or it's not possible to use it due to missing dependency),\n+        // remove it.\n+        // Since there are no other hooks for marginRight, remove the whole object.\n+        delete this.get;\n+        return;\n+      }\n+\n+      // Hook needed; redefine it so that the support test is not executed again.\n+\n+      return (this.get = hookFn).apply( this, arguments );\n+    }\n+  };\n+}\n+\n+\n+(function() {\n+  var pixelPositionVal, boxSizingReliableVal,\n+    docElem = document.documentElement,\n+    container = document.createElement( \"div\" ),\n+    div = document.createElement( \"div\" );\n+\n+  if ( !div.style ) {\n+    return;\n+  }\n+\n+  div.style.backgroundClip = \"content-box\";\n+  div.cloneNode( true ).style.backgroundClip = \"\";\n+  support.clearCloneStyle = div.style.backgroundClip === \"content-box\";\n+\n+  container.style.cssText = \"border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;\" +\n+    \"position:absolute\";\n+  container.appendChild( div );\n+\n+  // Executing both pixelPosition & boxSizingReliable tests require only one layout\n+  // so they're executed at the same time to save the second computation.\n+  function computePixelPositionAndBoxSizingReliable() {\n+    div.style.cssText =\n+      // Support: Firefox<29, Android 2.3\n+      // Vendor-prefix box-sizing\n+      \"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;\" +\n+      \"box-sizing:border-box;display:block;margin-top:1%;top:1%;\" +\n+      \"border:1px;padding:1px;width:4px;position:absolute\";\n+    div.innerHTML = \"\";\n+    docElem.appendChild( container );\n+\n+    var divStyle = window.getComputedStyle( div, null );\n+    pixelPositionVal = divStyle.top !== \"1%\";\n+    boxSizingReliableVal = divStyle.width === \"4px\";\n+\n+    docElem.removeChild( container );\n+  }\n+\n+  // Support: node.js jsdom\n+  // Don't assume that getComputedStyle is a property of the global object\n+  if ( window.getComputedStyle ) {\n+    jQuery.extend( support, {\n+      pixelPosition: function() {\n+        // This test is executed only once but we still do memoizing\n+        // since we can use the boxSizingReliable pre-computing.\n+        // No need to check if the test was already performed, though.\n+        computePixelPositionAndBoxSizingReliable();\n+        return pixelPositionVal;\n+      },\n+      boxSizingReliable: function() {\n+        if ( boxSizingReliableVal == null ) {\n+          computePixelPositionAndBoxSizingReliable();\n+        }\n+        return boxSizingReliableVal;\n+      },\n+      reliableMarginRight: function() {\n+        // Support: Android 2.3\n+        // Check if div with explicit width and no margin-right incorrectly\n+        // gets computed margin-right based on width of container. (#3333)\n+        // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right\n+        // This support function is only executed once so no memoizing is needed.\n+        var ret,\n+          marginDiv = div.appendChild( document.createElement( \"div\" ) );\n+\n+        // Reset CSS: box-sizing; display; margin; border; padding\n+        marginDiv.style.cssText = div.style.cssText =\n+          // Support: Firefox<29, Android 2.3\n+          // Vendor-prefix box-sizing\n+          \"-webkit-box-sizing:content-box;-moz-box-sizing:content-box;\" +\n+          \"box-sizing:content-box;display:block;margin:0;border:0;padding:0\";\n+        marginDiv.style.marginRight = marginDiv.style.width = \"0\";\n+        div.style.width = \"1px\";\n+        docElem.appendChild( container );\n+\n+        ret = !parseFloat( window.getComputedStyle( marginDiv, null ).marginRight );\n+\n+        docElem.removeChild( container );\n+\n+        return ret;\n+      }\n+    });\n+  }\n+})();\n+\n+\n+// A method for quickly swapping in/out CSS properties to get correct calculations.\n+jQuery.swap = function( elem, options, callback, args ) {\n+  var ret, name,\n+    old = {};\n+\n+  // Remember the old values, and insert the new ones\n+  for ( name in options ) {\n+    old[ name ] = elem.style[ name ];\n+    elem.style[ name ] = options[ name ];\n+  }\n+\n+  ret = callback.apply( elem, args || [] );\n+\n+  // Revert the old values\n+  for ( name in options ) {\n+    elem.style[ name ] = old[ name ];\n+  }\n+\n+  return ret;\n+};\n+\n+\n+var\n+  // swappable if display is none or starts with table except \"table\", \"table-cell\", or \"table-caption\"\n+  // see here for display values: https://developer.mozilla.org/en-US/docs/CSS/display\n+  rdisplayswap = /^(none|table(?!-c[ea]).+)/,\n+  rnumsplit = new RegExp( \"^(\" + pnum + \")(.*)$\", \"i\" ),\n+  rrelNum = new RegExp( \"^([+-])=(\" + pnum + \")\", \"i\" ),\n+\n+  cssShow = { position: \"absolute\", visibility: \"hidden\", display: \"block\" },\n+  cssNormalTransform = {\n+    letterSpacing: \"0\",\n+    fontWeight: \"400\"\n+  },\n+\n+  cssPrefixes = [ \"Webkit\", \"O\", \"Moz\", \"ms\" ];\n+\n+// return a css property mapped to a potentially vendor prefixed property\n+function vendorPropName( style, name ) {\n+\n+  // shortcut for names that are not vendor prefixed\n+  if ( name in style ) {\n+    return name;\n+  }\n+\n+  // check for vendor prefixed names\n+  var capName = name[0].toUpperCase() + name.slice(1),\n+    origName = name,\n+    i = cssPrefixes.length;\n+\n+  while ( i-- ) {\n+    name = cssPrefixes[ i ] + capName;\n+    if ( name in style ) {\n+      return name;\n+    }\n+  }\n+\n+  return origName;\n+}\n+\n+function setPositiveNumber( elem, value, subtract ) {\n+  var matches = rnumsplit.exec( value );\n+  return matches ?\n+    // Guard against undefined \"subtract\", e.g., when used as in cssHooks\n+    Math.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || \"px\" ) :\n+    value;\n+}\n+\n+function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {\n+  var i = extra === ( isBorderBox ? \"border\" : \"content\" ) ?\n+    // If we already have the right measurement, avoid augmentation\n+    4 :\n+    // Otherwise initialize for horizontal or vertical properties\n+    name === \"width\" ? 1 : 0,\n+\n+    val = 0;\n+\n+  for ( ; i < 4; i += 2 ) {\n+    // both box models exclude margin, so add it if we want it\n+    if ( extra === \"margin\" ) {\n+      val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );\n+    }\n+\n+    if ( isBorderBox ) {\n+      // border-box includes padding, so remove it if we want content\n+      if ( extra === \"content\" ) {\n+        val -= jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n+      }\n+\n+      // at this point, extra isn't border nor margin, so remove border\n+      if ( extra !== \"margin\" ) {\n+        val -= jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n+      }\n+    } else {\n+      // at this point, extra isn't content, so add padding\n+      val += jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n+\n+      // at this point, extra isn't content nor padding, so add border\n+      if ( extra !== \"padding\" ) {\n+        val += jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n+      }\n+    }\n+  }\n+\n+  return val;\n+}\n+\n+function getWidthOrHeight( elem, name, extra ) {\n+\n+  // Start with offset property, which is equivalent to the border-box value\n+  var valueIsBorderBox = true,\n+    val = name === \"width\" ? elem.offsetWidth : elem.offsetHeight,\n+    styles = getStyles( elem ),\n+    isBorderBox = jQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\";\n+\n+  // some non-html elements return undefined for offsetWidth, so check for null/undefined\n+  // svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285\n+  // MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668\n+  if ( val <= 0 || val == null ) {\n+    // Fall back to computed then uncomputed css if necessary\n+    val = curCSS( elem, name, styles );\n+    if ( val < 0 || val == null ) {\n+      val = elem.style[ name ];\n+    }\n+\n+    // Computed unit is not pixels. Stop here and return.\n+    if ( rnumnonpx.test(val) ) {\n+      return val;\n+    }\n+\n+    // we need the check for style in case a browser which returns unreliable values\n+    // for getComputedStyle silently falls back to the reliable elem.style\n+    valueIsBorderBox = isBorderBox &&\n+      ( support.boxSizingReliable() || val === elem.style[ name ] );\n+\n+    // Normalize \"\", auto, and prepare for extra\n+    val = parseFloat( val ) || 0;\n+  }\n+\n+  // use the active box-sizing model to add/subtract irrelevant styles\n+  return ( val +\n+    augmentWidthOrHeight(\n+      elem,\n+      name,\n+      extra || ( isBorderBox ? \"border\" : \"content\" ),\n+      valueIsBorderBox,\n+      styles\n+    )\n+  ) + \"px\";\n+}\n+\n+function showHide( elements, show ) {\n+  var display, elem, hidden,\n+    values = [],\n+    index = 0,\n+    length = elements.length;\n+\n+  for ( ; index < length; index++ ) {\n+    elem = elements[ index ];\n+    if ( !elem.style ) {\n+      continue;\n+    }\n+\n+    values[ index ] = data_priv.get( elem, \"olddisplay\" );\n+    display = elem.style.display;\n+    if ( show ) {\n+      // Reset the inline display of this element to learn if it is\n+      // being hidden by cascaded rules or not\n+      if ( !values[ index ] && display === \"none\" ) {\n+        elem.style.display = \"\";\n+      }\n+\n+      // Set elements which have been overridden with display: none\n+      // in a stylesheet to whatever the default browser style is\n+      // for such an element\n+      if ( elem.style.display === \"\" && isHidden( elem ) ) {\n+        values[ index ] = data_priv.access( elem, \"olddisplay\", defaultDisplay(elem.nodeName) );\n+      }\n+    } else {\n+      hidden = isHidden( elem );\n+\n+      if ( display !== \"none\" || !hidden ) {\n+        data_priv.set( elem, \"olddisplay\", hidden ? display : jQuery.css( elem, \"display\" ) );\n+      }\n+    }\n+  }\n+\n+  // Set the display of most of the elements in a second loop\n+  // to avoid the constant reflow\n+  for ( index = 0; index < length; index++ ) {\n+    elem = elements[ index ];\n+    if ( !elem.style ) {\n+      continue;\n+    }\n+    if ( !show || elem.style.display === \"none\" || elem.style.display === \"\" ) {\n+      elem.style.display = show ? values[ index ] || \"\" : \"none\";\n+    }\n+  }\n+\n+  return elements;\n+}\n+\n+jQuery.extend({\n+  // Add in style property hooks for overriding the default\n+  // behavior of getting and setting a style property\n+  cssHooks: {\n+    opacity: {\n+      get: function( elem, computed ) {\n+        if ( computed ) {\n+          // We should always get a number back from opacity\n+          var ret = curCSS( elem, \"opacity\" );\n+          return ret === \"\" ? \"1\" : ret;\n+        }\n+      }\n+    }\n+  },\n+\n+  // Don't automatically add \"px\" to these possibly-unitless properties\n+  cssNumber: {\n+    \"columnCount\": true,\n+    \"fillOpacity\": true,\n+    \"flexGrow\": true,\n+    \"flexShrink\": true,\n+    \"fontWeight\": true,\n+    \"lineHeight\": true,\n+    \"opacity\": true,\n+    \"order\": true,\n+    \"orphans\": true,\n+    \"widows\": true,\n+    \"zIndex\": true,\n+    \"zoom\": true\n+  },\n+\n+  // Add in properties whose names you wish to fix before\n+  // setting or getting the value\n+  cssProps: {\n+    // normalize float css property\n+    \"float\": \"cssFloat\"\n+  },\n+\n+  // Get and set the style property on a DOM Node\n+  style: function( elem, name, value, extra ) {\n+    // Don't set styles on text and comment nodes\n+    if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {\n+      return;\n+    }\n+\n+    // Make sure that we're working with the right name\n+    var ret, type, hooks,\n+      origName = jQuery.camelCase( name ),\n+      style = elem.style;\n+\n+    name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );\n+\n+    // gets hook for the prefixed version\n+    // followed by the unprefixed version\n+    hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n+\n+    // Check if we're setting a value\n+    if ( value !== undefined ) {\n+      type = typeof value;\n+\n+      // convert relative number strings (+= or -=) to relative numbers. #7345\n+      if ( type === \"string\" && (ret = rrelNum.exec( value )) ) {\n+        value = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );\n+        // Fixes bug #9237\n+        type = \"number\";\n+      }\n+\n+      // Make sure that null and NaN values aren't set. See: #7116\n+      if ( value == null || value !== value ) {\n+        return;\n+      }\n+\n+      // If a number was passed in, add 'px' to the (except for certain CSS properties)\n+      if ( type === \"number\" && !jQuery.cssNumber[ origName ] ) {\n+        value += \"px\";\n+      }\n+\n+      // Fixes #8908, it can be done more correctly by specifying setters in cssHooks,\n+      // but it would mean to define eight (for every problematic property) identical functions\n+      if ( !support.clearCloneStyle && value === \"\" && name.indexOf( \"background\" ) === 0 ) {\n+        style[ name ] = \"inherit\";\n+      }\n+\n+      // If a hook was provided, use that value, otherwise just set the specified value\n+      if ( !hooks || !(\"set\" in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {\n+        style[ name ] = value;\n+      }\n+\n+    } else {\n+      // If a hook was provided get the non-computed value from there\n+      if ( hooks && \"get\" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {\n+        return ret;\n+      }\n+\n+      // Otherwise just get the value from the style object\n+      return style[ name ];\n+    }\n+  },\n+\n+  css: function( elem, name, extra, styles ) {\n+    var val, num, hooks,\n+      origName = jQuery.camelCase( name );\n+\n+    // Make sure that we're working with the right name\n+    name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );\n+\n+    // gets hook for the prefixed version\n+    // followed by the unprefixed version\n+    hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n+\n+    // If a hook was provided get the computed value from there\n+    if ( hooks && \"get\" in hooks ) {\n+      val = hooks.get( elem, true, extra );\n+    }\n+\n+    // Otherwise, if a way to get the computed value exists, use that\n+    if ( val === undefined ) {\n+      val = curCSS( elem, name, styles );\n+    }\n+\n+    //convert \"normal\" to computed value\n+    if ( val === \"normal\" && name in cssNormalTransform ) {\n+      val = cssNormalTransform[ name ];\n+    }\n+\n+    // Return, converting to number if forced or a qualifier was provided and val looks numeric\n+    if ( extra === \"\" || extra ) {\n+      num = parseFloat( val );\n+      return extra === true || jQuery.isNumeric( num ) ? num || 0 : val;\n+    }\n+    return val;\n+  }\n+});\n+\n+jQuery.each([ \"height\", \"width\" ], function( i, name ) {\n+  jQuery.cssHooks[ name ] = {\n+    get: function( elem, computed, extra ) {\n+      if ( computed ) {\n+        // certain elements can have dimension info if we invisibly show them\n+        // however, it must have a current display style that would benefit from this\n+        return rdisplayswap.test( jQuery.css( elem, \"display\" ) ) && elem.offsetWidth === 0 ?\n+          jQuery.swap( elem, cssShow, function() {\n+            return getWidthOrHeight( elem, name, extra );\n+          }) :\n+          getWidthOrHeight( elem, name, extra );\n+      }\n+    },\n+\n+    set: function( elem, value, extra ) {\n+      var styles = extra && getStyles( elem );\n+      return setPositiveNumber( elem, value, extra ?\n+        augmentWidthOrHeight(\n+          elem,\n+          name,\n+          extra,\n+          jQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\",\n+          styles\n+        ) : 0\n+      );\n+    }\n+  };\n+});\n+\n+// Support: Android 2.3\n+jQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight,\n+  function( elem, computed ) {\n+    if ( computed ) {\n+      // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right\n+      // Work around by temporarily setting element display to inline-block\n+      return jQuery.swap( elem, { \"display\": \"inline-block\" },\n+        curCSS, [ elem, \"marginRight\" ] );\n+    }\n+  }\n+);\n+\n+// These hooks are used by animate to expand properties\n+jQuery.each({\n+  margin: \"\",\n+  padding: \"\",\n+  border: \"Width\"\n+}, function( prefix, suffix ) {\n+  jQuery.cssHooks[ prefix + suffix ] = {\n+    expand: function( value ) {\n+      var i = 0,\n+        expanded = {},\n+\n+        // assumes a single number if not a string\n+        parts = typeof value === \"string\" ? value.split(\" \") : [ value ];\n+\n+      for ( ; i < 4; i++ ) {\n+        expanded[ prefix + cssExpand[ i ] + suffix ] =\n+          parts[ i ] || parts[ i - 2 ] || parts[ 0 ];\n+      }\n+\n+      return expanded;\n+    }\n+  };\n+\n+  if ( !rmargin.test( prefix ) ) {\n+    jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;\n+  }\n+});\n+\n+jQuery.fn.extend({\n+  css: function( name, value ) {\n+    return access( this, function( elem, name, value ) {\n+      var styles, len,\n+        map = {},\n+        i = 0;\n+\n+      if ( jQuery.isArray( name ) ) {\n+        styles = getStyles( elem );\n+        len = name.length;\n+\n+        for ( ; i < len; i++ ) {\n+          map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );\n+        }\n+\n+        return map;\n+      }\n+\n+      return value !== undefined ?\n+        jQuery.style( elem, name, value ) :\n+        jQuery.css( elem, name );\n+    }, name, value, arguments.length > 1 );\n+  },\n+  show: function() {\n+    return showHide( this, true );\n+  },\n+  hide: function() {\n+    return showHide( this );\n+  },\n+  toggle: function( state ) {\n+    if ( typeof state === \"boolean\" ) {\n+      return state ? this.show() : this.hide();\n+    }\n+\n+    return this.each(function() {\n+      if ( isHidden( this ) ) {\n+        jQuery( this ).show();\n+      } else {\n+        jQuery( this ).hide();\n+      }\n+    });\n+  }\n+});\n+\n+\n+function Tween( elem, options, prop, end, easing ) {\n+  return new Tween.prototype.init( elem, options, prop, end, easing );\n+}\n+jQuery.Tween = Tween;\n+\n+Tween.prototype = {\n+  constructor: Tween,\n+  init: function( elem, options, prop, end, easing, unit ) {\n+    this.elem = elem;\n+    this.prop = prop;\n+    this.easing = easing || \"swing\";\n+    this.options = options;\n+    this.start = this.now = this.cur();\n+    this.end = end;\n+    this.unit = unit || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" );\n+  },\n+  cur: function() {\n+    var hooks = Tween.propHooks[ this.prop ];\n+\n+    return hooks && hooks.get ?\n+      hooks.get( this ) :\n+      Tween.propHooks._default.get( this );\n+  },\n+  run: function( percent ) {\n+    var eased,\n+      hooks = Tween.propHooks[ this.prop ];\n+\n+    if ( this.options.duration ) {\n+      this.pos = eased = jQuery.easing[ this.easing ](\n+        percent, this.options.duration * percent, 0, 1, this.options.duration\n+      );\n+    } else {\n+      this.pos = eased = percent;\n+    }\n+    this.now = ( this.end - this.start ) * eased + this.start;\n+\n+    if ( this.options.step ) {\n+      this.options.step.call( this.elem, this.now, this );\n+    }\n+\n+    if ( hooks && hooks.set ) {\n+      hooks.set( this );\n+    } else {\n+      Tween.propHooks._default.set( this );\n+    }\n+    return this;\n+  }\n+};\n+\n+Tween.prototype.init.prototype = Tween.prototype;\n+\n+Tween.propHooks = {\n+  _default: {\n+    get: function( tween ) {\n+      var result;\n+\n+      if ( tween.elem[ tween.prop ] != null &&\n+        (!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) {\n+        return tween.elem[ tween.prop ];\n+      }\n+\n+      // passing an empty string as a 3rd parameter to .css will automatically\n+      // attempt a parseFloat and fallback to a string if the parse fails\n+      // so, simple values such as \"10px\" are parsed to Float.\n+      // complex values such as \"rotate(1rad)\" are returned as is.\n+      result = jQuery.css( tween.elem, tween.prop, \"\" );\n+      // Empty strings, null, undefined and \"auto\" are converted to 0.\n+      return !result || result === \"auto\" ? 0 : result;\n+    },\n+    set: function( tween ) {\n+      // use step hook for back compat - use cssHook if its there - use .style if its\n+      // available and use plain properties where available\n+      if ( jQuery.fx.step[ tween.prop ] ) {\n+        jQuery.fx.step[ tween.prop ]( tween );\n+      } else if ( tween.elem.style && ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {\n+        jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );\n+      } else {\n+        tween.elem[ tween.prop ] = tween.now;\n+      }\n+    }\n+  }\n+};\n+\n+// Support: IE9\n+// Panic based approach to setting things on disconnected nodes\n+\n+Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {\n+  set: function( tween ) {\n+    if ( tween.elem.nodeType && tween.elem.parentNode ) {\n+      tween.elem[ tween.prop ] = tween.now;\n+    }\n+  }\n+};\n+\n+jQuery.easing = {\n+  linear: function( p ) {\n+    return p;\n+  },\n+  swing: function( p ) {\n+    return 0.5 - Math.cos( p * Math.PI ) / 2;\n+  }\n+};\n+\n+jQuery.fx = Tween.prototype.init;\n+\n+// Back Compat <1.8 extension point\n+jQuery.fx.step = {};\n+\n+\n+\n+\n+var\n+  fxNow, timerId,\n+  rfxtypes = /^(?:toggle|show|hide)$/,\n+  rfxnum = new RegExp( \"^(?:([+-])=|)(\" + pnum + \")([a-z%]*)$\", \"i\" ),\n+  rrun = /queueHooks$/,\n+  animationPrefilters = [ defaultPrefilter ],\n+  tweeners = {\n+    \"*\": [ function( prop, value ) {\n+      var tween = this.createTween( prop, value ),\n+        target = tween.cur(),\n+        parts = rfxnum.exec( value ),\n+        unit = parts && parts[ 3 ] || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" ),\n+\n+        // Starting value computation is required for potential unit mismatches\n+        start = ( jQuery.cssNumber[ prop ] || unit !== \"px\" && +target ) &&\n+          rfxnum.exec( jQuery.css( tween.elem, prop ) ),\n+        scale = 1,\n+        maxIterations = 20;\n+\n+      if ( start && start[ 3 ] !== unit ) {\n+        // Trust units reported by jQuery.css\n+        unit = unit || start[ 3 ];\n+\n+        // Make sure we update the tween properties later on\n+        parts = parts || [];\n+\n+        // Iteratively approximate from a nonzero starting point\n+        start = +target || 1;\n+\n+        do {\n+          // If previous iteration zeroed out, double until we get *something*\n+          // Use a string for doubling factor so we don't accidentally see scale as unchanged below\n+          scale = scale || \".5\";\n+\n+          // Adjust and apply\n+          start = start / scale;\n+          jQuery.style( tween.elem, prop, start + unit );\n+\n+        // Update scale, tolerating zero or NaN from tween.cur()\n+        // And breaking the loop if scale is unchanged or perfect, or if we've just had enough\n+        } while ( scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations );\n+      }\n+\n+      // Update tween properties\n+      if ( parts ) {\n+        start = tween.start = +start || +target || 0;\n+        tween.unit = unit;\n+        // If a +=/-= token was provided, we're doing a relative animation\n+        tween.end = parts[ 1 ] ?\n+          start + ( parts[ 1 ] + 1 ) * parts[ 2 ] :\n+          +parts[ 2 ];\n+      }\n+\n+      return tween;\n+    } ]\n+  };\n+\n+// Animations created synchronously will run synchronously\n+function createFxNow() {\n+  setTimeout(function() {\n+    fxNow = undefined;\n+  });\n+  return ( fxNow = jQuery.now() );\n+}\n+\n+// Generate parameters to create a standard animation\n+function genFx( type, includeWidth ) {\n+  var which,\n+    i = 0,\n+    attrs = { height: type };\n+\n+  // if we include width, step value is 1 to do all cssExpand values,\n+  // if we don't include width, step value is 2 to skip over Left and Right\n+  includeWidth = includeWidth ? 1 : 0;\n+  for ( ; i < 4 ; i += 2 - includeWidth ) {\n+    which = cssExpand[ i ];\n+    attrs[ \"margin\" + which ] = attrs[ \"padding\" + which ] = type;\n+  }\n+\n+  if ( includeWidth ) {\n+    attrs.opacity = attrs.width = type;\n+  }\n+\n+  return attrs;\n+}\n+\n+function createTween( value, prop, animation ) {\n+  var tween,\n+    collection = ( tweeners[ prop ] || [] ).concat( tweeners[ \"*\" ] ),\n+    index = 0,\n+    length = collection.length;\n+  for ( ; index < length; index++ ) {\n+    if ( (tween = collection[ index ].call( animation, prop, value )) ) {\n+\n+      // we're done with this property\n+      return tween;\n+    }\n+  }\n+}\n+\n+function defaultPrefilter( elem, props, opts ) {\n+  /* jshint validthis: true */\n+  var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,\n+    anim = this,\n+    orig = {},\n+    style = elem.style,\n+    hidden = elem.nodeType && isHidden( elem ),\n+    dataShow = data_priv.get( elem, \"fxshow\" );\n+\n+  // handle queue: false promises\n+  if ( !opts.queue ) {\n+    hooks = jQuery._queueHooks( elem, \"fx\" );\n+    if ( hooks.unqueued == null ) {\n+      hooks.unqueued = 0;\n+      oldfire = hooks.empty.fire;\n+      hooks.empty.fire = function() {\n+        if ( !hooks.unqueued ) {\n+          oldfire();\n+        }\n+      };\n+    }\n+    hooks.unqueued++;\n+\n+    anim.always(function() {\n+      // doing this makes sure that the complete handler will be called\n+      // before this completes\n+      anim.always(function() {\n+        hooks.unqueued--;\n+        if ( !jQuery.queue( elem, \"fx\" ).length ) {\n+          hooks.empty.fire();\n+        }\n+      });\n+    });\n+  }\n+\n+  // height/width overflow pass\n+  if ( elem.nodeType === 1 && ( \"height\" in props || \"width\" in props ) ) {\n+    // Make sure that nothing sneaks out\n+    // Record all 3 overflow attributes because IE9-10 do not\n+    // change the overflow attribute when overflowX and\n+    // overflowY are set to the same value\n+    opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];\n+\n+    // Set display property to inline-block for height/width\n+    // animations on inline elements that are having width/height animated\n+    display = jQuery.css( elem, \"display\" );\n+\n+    // Test default display if display is currently \"none\"\n+    checkDisplay = display === \"none\" ?\n+      data_priv.get( elem, \"olddisplay\" ) || defaultDisplay( elem.nodeName ) : display;\n+\n+    if ( checkDisplay === \"inline\" && jQuery.css( elem, \"float\" ) === \"none\" ) {\n+      style.display = \"inline-block\";\n+    }\n+  }\n+\n+  if ( opts.overflow ) {\n+    style.overflow = \"hidden\";\n+    anim.always(function() {\n+      style.overflow = opts.overflow[ 0 ];\n+      style.overflowX = opts.overflow[ 1 ];\n+      style.overflowY = opts.overflow[ 2 ];\n+    });\n+  }\n+\n+  // show/hide pass\n+  for ( prop in props ) {\n+    value = props[ prop ];\n+    if ( rfxtypes.exec( value ) ) {\n+      delete props[ prop ];\n+      toggle = toggle || value === \"toggle\";\n+      if ( value === ( hidden ? \"hide\" : \"show\" ) ) {\n+\n+        // If there is dataShow left over from a stopped hide or show and we are going to proceed with show, we should pretend to be hidden\n+        if ( value === \"show\" && dataShow && dataShow[ prop ] !== undefined ) {\n+          hidden = true;\n+        } else {\n+          continue;\n+        }\n+      }\n+      orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );\n+\n+    // Any non-fx value stops us from restoring the original display value\n+    } else {\n+      display = undefined;\n+    }\n+  }\n+\n+  if ( !jQuery.isEmptyObject( orig ) ) {\n+    if ( dataShow ) {\n+      if ( \"hidden\" in dataShow ) {\n+        hidden = dataShow.hidden;\n+      }\n+    } else {\n+      dataShow = data_priv.access( elem, \"fxshow\", {} );\n+    }\n+\n+    // store state if its toggle - enables .stop().toggle() to \"reverse\"\n+    if ( toggle ) {\n+      dataShow.hidden = !hidden;\n+    }\n+    if ( hidden ) {\n+      jQuery( elem ).show();\n+    } else {\n+      anim.done(function() {\n+        jQuery( elem ).hide();\n+      });\n+    }\n+    anim.done(function() {\n+      var prop;\n+\n+      data_priv.remove( elem, \"fxshow\" );\n+      for ( prop in orig ) {\n+        jQuery.style( elem, prop, orig[ prop ] );\n+      }\n+    });\n+    for ( prop in orig ) {\n+      tween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );\n+\n+      if ( !( prop in dataShow ) ) {\n+        dataShow[ prop ] = tween.start;\n+        if ( hidden ) {\n+          tween.end = tween.start;\n+          tween.start = prop === \"width\" || prop === \"height\" ? 1 : 0;\n+        }\n+      }\n+    }\n+\n+  // If this is a noop like .hide().hide(), restore an overwritten display value\n+  } else if ( (display === \"none\" ? defaultDisplay( elem.nodeName ) : display) === \"inline\" ) {\n+    style.display = display;\n+  }\n+}\n+\n+function propFilter( props, specialEasing ) {\n+  var index, name, easing, value, hooks;\n+\n+  // camelCase, specialEasing and expand cssHook pass\n+  for ( index in props ) {\n+    name = jQuery.camelCase( index );\n+    easing = specialEasing[ name ];\n+    value = props[ index ];\n+    if ( jQuery.isArray( value ) ) {\n+      easing = value[ 1 ];\n+      value = props[ index ] = value[ 0 ];\n+    }\n+\n+    if ( index !== name ) {\n+      props[ name ] = value;\n+      delete props[ index ];\n+    }\n+\n+    hooks = jQuery.cssHooks[ name ];\n+    if ( hooks && \"expand\" in hooks ) {\n+      value = hooks.expand( value );\n+      delete props[ name ];\n+\n+      // not quite $.extend, this wont overwrite keys already present.\n+      // also - reusing 'index' from above because we have the correct \"name\"\n+      for ( index in value ) {\n+        if ( !( index in props ) ) {\n+          props[ index ] = value[ index ];\n+          specialEasing[ index ] = easing;\n+        }\n+      }\n+    } else {\n+      specialEasing[ name ] = easing;\n+    }\n+  }\n+}\n+\n+function Animation( elem, properties, options ) {\n+  var result,\n+    stopped,\n+    index = 0,\n+    length = animationPrefilters.length,\n+    deferred = jQuery.Deferred().always( function() {\n+      // don't match elem in the :animated selector\n+      delete tick.elem;\n+    }),\n+    tick = function() {\n+      if ( stopped ) {\n+        return false;\n+      }\n+      var currentTime = fxNow || createFxNow(),\n+        remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),\n+        // archaic crash bug won't allow us to use 1 - ( 0.5 || 0 ) (#12497)\n+        temp = remaining / animation.duration || 0,\n+        percent = 1 - temp,\n+        index = 0,\n+        length = animation.tweens.length;\n+\n+      for ( ; index < length ; index++ ) {\n+        animation.tweens[ index ].run( percent );\n+      }\n+\n+      deferred.notifyWith( elem, [ animation, percent, remaining ]);\n+\n+      if ( percent < 1 && length ) {\n+        return remaining;\n+      } else {\n+        deferred.resolveWith( elem, [ animation ] );\n+        return false;\n+      }\n+    },\n+    animation = deferred.promise({\n+      elem: elem,\n+      props: jQuery.extend( {}, properties ),\n+      opts: jQuery.extend( true, { specialEasing: {} }, options ),\n+      originalProperties: properties,\n+      originalOptions: options,\n+      startTime: fxNow || createFxNow(),\n+      duration: options.duration,\n+      tweens: [],\n+      createTween: function( prop, end ) {\n+        var tween = jQuery.Tween( elem, animation.opts, prop, end,\n+            animation.opts.specialEasing[ prop ] || animation.opts.easing );\n+        animation.tweens.push( tween );\n+        return tween;\n+      },\n+      stop: function( gotoEnd ) {\n+        var index = 0,\n+          // if we are going to the end, we want to run all the tweens\n+          // otherwise we skip this part\n+          length = gotoEnd ? animation.tweens.length : 0;\n+        if ( stopped ) {\n+          return this;\n+        }\n+        stopped = true;\n+        for ( ; index < length ; index++ ) {\n+          animation.tweens[ index ].run( 1 );\n+        }\n+\n+        // resolve when we played the last frame\n+        // otherwise, reject\n+        if ( gotoEnd ) {\n+          deferred.resolveWith( elem, [ animation, gotoEnd ] );\n+        } else {\n+          deferred.rejectWith( elem, [ animation, gotoEnd ] );\n+        }\n+        return this;\n+      }\n+    }),\n+    props = animation.props;\n+\n+  propFilter( props, animation.opts.specialEasing );\n+\n+  for ( ; index < length ; index++ ) {\n+    result = animationPrefilters[ index ].call( animation, elem, props, animation.opts );\n+    if ( result ) {\n+      return result;\n+    }\n+  }\n+\n+  jQuery.map( props, createTween, animation );\n+\n+  if ( jQuery.isFunction( animation.opts.start ) ) {\n+    animation.opts.start.call( elem, animation );\n+  }\n+\n+  jQuery.fx.timer(\n+    jQuery.extend( tick, {\n+      elem: elem,\n+      anim: animation,\n+      queue: animation.opts.queue\n+    })\n+  );\n+\n+  // attach callbacks from options\n+  return animation.progress( animation.opts.progress )\n+    .done( animation.opts.done, animation.opts.complete )\n+    .fail( animation.opts.fail )\n+    .always( animation.opts.always );\n+}\n+\n+jQuery.Animation = jQuery.extend( Animation, {\n+\n+  tweener: function( props, callback ) {\n+    if ( jQuery.isFunction( props ) ) {\n+      callback = props;\n+      props = [ \"*\" ];\n+    } else {\n+      props = props.split(\" \");\n+    }\n+\n+    var prop,\n+      index = 0,\n+      length = props.length;\n+\n+    for ( ; index < length ; index++ ) {\n+      prop = props[ index ];\n+      tweeners[ prop ] = tweeners[ prop ] || [];\n+      tweeners[ prop ].unshift( callback );\n+    }\n+  },\n+\n+  prefilter: function( callback, prepend ) {\n+    if ( prepend ) {\n+      animationPrefilters.unshift( callback );\n+    } else {\n+      animationPrefilters.push( callback );\n+    }\n+  }\n+});\n+\n+jQuery.speed = function( speed, easing, fn ) {\n+  var opt = speed && typeof speed === \"object\" ? jQuery.extend( {}, speed ) : {\n+    complete: fn || !fn && easing ||\n+      jQuery.isFunction( speed ) && speed,\n+    duration: speed,\n+    easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing\n+  };\n+\n+  opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === \"number\" ? opt.duration :\n+    opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;\n+\n+  // normalize opt.queue - true/undefined/null -> \"fx\"\n+  if ( opt.queue == null || opt.queue === true ) {\n+    opt.queue = \"fx\";\n+  }\n+\n+  // Queueing\n+  opt.old = opt.complete;\n+\n+  opt.complete = function() {\n+    if ( jQuery.isFunction( opt.old ) ) {\n+      opt.old.call( this );\n+    }\n+\n+    if ( opt.queue ) {\n+      jQuery.dequeue( this, opt.queue );\n+    }\n+  };\n+\n+  return opt;\n+};\n+\n+jQuery.fn.extend({\n+  fadeTo: function( speed, to, easing, callback ) {\n+\n+    // show any hidden elements after setting opacity to 0\n+    return this.filter( isHidden ).css( \"opacity\", 0 ).show()\n+\n+      // animate to the value specified\n+      .end().animate({ opacity: to }, speed, easing, callback );\n+  },\n+  animate: function( prop, speed, easing, callback ) {\n+    var empty = jQuery.isEmptyObject( prop ),\n+      optall = jQuery.speed( speed, easing, callback ),\n+      doAnimation = function() {\n+        // Operate on a copy of prop so per-property easing won't be lost\n+        var anim = Animation( this, jQuery.extend( {}, prop ), optall );\n+\n+        // Empty animations, or finishing resolves immediately\n+        if ( empty || data_priv.get( this, \"finish\" ) ) {\n+          anim.stop( true );\n+        }\n+      };\n+      doAnimation.finish = doAnimation;\n+\n+    return empty || optall.queue === false ?\n+      this.each( doAnimation ) :\n+      this.queue( optall.queue, doAnimation );\n+  },\n+  stop: function( type, clearQueue, gotoEnd ) {\n+    var stopQueue = function( hooks ) {\n+      var stop = hooks.stop;\n+      delete hooks.stop;\n+      stop( gotoEnd );\n+    };\n+\n+    if ( typeof type !== \"string\" ) {\n+      gotoEnd = clearQueue;\n+      clearQueue = type;\n+      type = undefined;\n+    }\n+    if ( clearQueue && type !== false ) {\n+      this.queue( type || \"fx\", [] );\n+    }\n+\n+    return this.each(function() {\n+      var dequeue = true,\n+        index = type != null && type + \"queueHooks\",\n+        timers = jQuery.timers,\n+        data = data_priv.get( this );\n+\n+      if ( index ) {\n+        if ( data[ index ] && data[ index ].stop ) {\n+          stopQueue( data[ index ] );\n+        }\n+      } else {\n+        for ( index in data ) {\n+          if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {\n+            stopQueue( data[ index ] );\n+          }\n+        }\n+      }\n+\n+      for ( index = timers.length; index--; ) {\n+        if ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {\n+          timers[ index ].anim.stop( gotoEnd );\n+          dequeue = false;\n+          timers.splice( index, 1 );\n+        }\n+      }\n+\n+      // start the next in the queue if the last step wasn't forced\n+      // timers currently will call their complete callbacks, which will dequeue\n+      // but only if they were gotoEnd\n+      if ( dequeue || !gotoEnd ) {\n+        jQuery.dequeue( this, type );\n+      }\n+    });\n+  },\n+  finish: function( type ) {\n+    if ( type !== false ) {\n+      type = type || \"fx\";\n+    }\n+    return this.each(function() {\n+      var index,\n+        data = data_priv.get( this ),\n+        queue = data[ type + \"queue\" ],\n+        hooks = data[ type + \"queueHooks\" ],\n+        timers = jQuery.timers,\n+        length = queue ? queue.length : 0;\n+\n+      // enable finishing flag on private data\n+      data.finish = true;\n+\n+      // empty the queue first\n+      jQuery.queue( this, type, [] );\n+\n+      if ( hooks && hooks.stop ) {\n+        hooks.stop.call( this, true );\n+      }\n+\n+      // look for any active animations, and finish them\n+      for ( index = timers.length; index--; ) {\n+        if ( timers[ index ].elem === this && timers[ index ].queue === type ) {\n+          timers[ index ].anim.stop( true );\n+          timers.splice( index, 1 );\n+        }\n+      }\n+\n+      // look for any animations in the old queue and finish them\n+      for ( index = 0; index < length; index++ ) {\n+        if ( queue[ index ] && queue[ index ].finish ) {\n+          queue[ index ].finish.call( this );\n+        }\n+      }\n+\n+      // turn off finishing flag\n+      delete data.finish;\n+    });\n+  }\n+});\n+\n+jQuery.each([ \"toggle\", \"show\", \"hide\" ], function( i, name ) {\n+  var cssFn = jQuery.fn[ name ];\n+  jQuery.fn[ name ] = function( speed, easing, callback ) {\n+    return speed == null || typeof speed === \"boolean\" ?\n+      cssFn.apply( this, arguments ) :\n+      this.animate( genFx( name, true ), speed, easing, callback );\n+  };\n+});\n+\n+// Generate shortcuts for custom animations\n+jQuery.each({\n+  slideDown: genFx(\"show\"),\n+  slideUp: genFx(\"hide\"),\n+  slideToggle: genFx(\"toggle\"),\n+  fadeIn: { opacity: \"show\" },\n+  fadeOut: { opacity: \"hide\" },\n+  fadeToggle: { opacity: \"toggle\" }\n+}, function( name, props ) {\n+  jQuery.fn[ name ] = function( speed, easing, callback ) {\n+    return this.animate( props, speed, easing, callback );\n+  };\n+});\n+\n+jQuery.timers = [];\n+jQuery.fx.tick = function() {\n+  var timer,\n+    i = 0,\n+    timers = jQuery.timers;\n+\n+  fxNow = jQuery.now();\n+\n+  for ( ; i < timers.length; i++ ) {\n+    timer = timers[ i ];\n+    // Checks the timer has not already been removed\n+    if ( !timer() && timers[ i ] === timer ) {\n+      timers.splice( i--, 1 );\n+    }\n+  }\n+\n+  if ( !timers.length ) {\n+    jQuery.fx.stop();\n+  }\n+  fxNow = undefined;\n+};\n+\n+jQuery.fx.timer = function( timer ) {\n+  jQuery.timers.push( timer );\n+  if ( timer() ) {\n+    jQuery.fx.start();\n+  } else {\n+    jQuery.timers.pop();\n+  }\n+};\n+\n+jQuery.fx.interval = 13;\n+\n+jQuery.fx.start = function() {\n+  if ( !timerId ) {\n+    timerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );\n+  }\n+};\n+\n+jQuery.fx.stop = function() {\n+  clearInterval( timerId );\n+  timerId = null;\n+};\n+\n+jQuery.fx.speeds = {\n+  slow: 600,\n+  fast: 200,\n+  // Default speed\n+  _default: 400\n+};\n+\n+\n+// Based off of the plugin by Clint Helfers, with permission.\n+// http://blindsignals.com/index.php/2009/07/jquery-delay/\n+jQuery.fn.delay = function( time, type ) {\n+  time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;\n+  type = type || \"fx\";\n+\n+  return this.queue( type, function( next, hooks ) {\n+    var timeout = setTimeout( next, time );\n+    hooks.stop = function() {\n+      clearTimeout( timeout );\n+    };\n+  });\n+};\n+\n+\n+(function() {\n+  var input = document.createElement( \"input\" ),\n+    select = document.createElement( \"select\" ),\n+    opt = select.appendChild( document.createElement( \"option\" ) );\n+\n+  input.type = \"checkbox\";\n+\n+  // Support: iOS 5.1, Android 4.x, Android 2.3\n+  // Check the default checkbox/radio value (\"\" on old WebKit; \"on\" elsewhere)\n+  support.checkOn = input.value !== \"\";\n+\n+  // Must access the parent to make an option select properly\n+  // Support: IE9, IE10\n+  support.optSelected = opt.selected;\n+\n+  // Make sure that the options inside disabled selects aren't marked as disabled\n+  // (WebKit marks them as disabled)\n+  select.disabled = true;\n+  support.optDisabled = !opt.disabled;\n+\n+  // Check if an input maintains its value after becoming a radio\n+  // Support: IE9, IE10\n+  input = document.createElement( \"input\" );\n+  input.value = \"t\";\n+  input.type = \"radio\";\n+  support.radioValue = input.value === \"t\";\n+})();\n+\n+\n+var nodeHook, boolHook,\n+  attrHandle = jQuery.expr.attrHandle;\n+\n+jQuery.fn.extend({\n+  attr: function( name, value ) {\n+    return access( this, jQuery.attr, name, value, arguments.length > 1 );\n+  },\n+\n+  removeAttr: function( name ) {\n+    return this.each(function() {\n+      jQuery.removeAttr( this, name );\n+    });\n+  }\n+});\n+\n+jQuery.extend({\n+  attr: function( elem, name, value ) {\n+    var hooks, ret,\n+      nType = elem.nodeType;\n+\n+    // don't get/set attributes on text, comment and attribute nodes\n+    if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {\n+      return;\n+    }\n+\n+    // Fallback to prop when attributes are not supported\n+    if ( typeof elem.getAttribute === strundefined ) {\n+      return jQuery.prop( elem, name, value );\n+    }\n+\n+    // All attributes are lowercase\n+    // Grab necessary hook if one is defined\n+    if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\n+      name = name.toLowerCase();\n+      hooks = jQuery.attrHooks[ name ] ||\n+        ( jQuery.expr.match.bool.test( name ) ? boolHook : nodeHook );\n+    }\n+\n+    if ( value !== undefined ) {\n+\n+      if ( value === null ) {\n+        jQuery.removeAttr( elem, name );\n+\n+      } else if ( hooks && \"set\" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {\n+        return ret;\n+\n+      } else {\n+        elem.setAttribute( name, value + \"\" );\n+        return value;\n+      }\n+\n+    } else if ( hooks && \"get\" in hooks && (ret = hooks.get( elem, name )) !== null ) {\n+      return ret;\n+\n+    } else {\n+      ret = jQuery.find.attr( elem, name );\n+\n+      // Non-existent attributes return null, we normalize to undefined\n+      return ret == null ?\n+        undefined :\n+        ret;\n+    }\n+  },\n+\n+  removeAttr: function( elem, value ) {\n+    var name, propName,\n+      i = 0,\n+      attrNames = value && value.match( rnotwhite );\n+\n+    if ( attrNames && elem.nodeType === 1 ) {\n+      while ( (name = attrNames[i++]) ) {\n+        propName = jQuery.propFix[ name ] || name;\n+\n+        // Boolean attributes get special treatment (#10870)\n+        if ( jQuery.expr.match.bool.test( name ) ) {\n+          // Set corresponding property to false\n+          elem[ propName ] = false;\n+        }\n+\n+        elem.removeAttribute( name );\n+      }\n+    }\n+  },\n+\n+  attrHooks: {\n+    type: {\n+      set: function( elem, value ) {\n+        if ( !support.radioValue && value === \"radio\" &&\n+          jQuery.nodeName( elem, \"input\" ) ) {\n+          // Setting the type on a radio button after the value resets the value in IE6-9\n+          // Reset value to default in case type is set after value during creation\n+          var val = elem.value;\n+          elem.setAttribute( \"type\", value );\n+          if ( val ) {\n+            elem.value = val;\n+          }\n+          return value;\n+        }\n+      }\n+    }\n+  }\n+});\n+\n+// Hooks for boolean attributes\n+boolHook = {\n+  set: function( elem, value, name ) {\n+    if ( value === false ) {\n+      // Remove boolean attributes when set to false\n+      jQuery.removeAttr( elem, name );\n+    } else {\n+      elem.setAttribute( name, name );\n+    }\n+    return name;\n+  }\n+};\n+jQuery.each( jQuery.expr.match.bool.source.match( /\\w+/g ), function( i, name ) {\n+  var getter = attrHandle[ name ] || jQuery.find.attr;\n+\n+  attrHandle[ name ] = function( elem, name, isXML ) {\n+    var ret, handle;\n+    if ( !isXML ) {\n+      // Avoid an infinite loop by temporarily removing this function from the getter\n+      handle = attrHandle[ name ];\n+      attrHandle[ name ] = ret;\n+      ret = getter( elem, name, isXML ) != null ?\n+        name.toLowerCase() :\n+        null;\n+      attrHandle[ name ] = handle;\n+    }\n+    return ret;\n+  };\n+});\n+\n+\n+\n+\n+var rfocusable = /^(?:input|select|textarea|button)$/i;\n+\n+jQuery.fn.extend({\n+  prop: function( name, value ) {\n+    return access( this, jQuery.prop, name, value, arguments.length > 1 );\n+  },\n+\n+  removeProp: function( name ) {\n+    return this.each(function() {\n+      delete this[ jQuery.propFix[ name ] || name ];\n+    });\n+  }\n+});\n+\n+jQuery.extend({\n+  propFix: {\n+    \"for\": \"htmlFor\",\n+    \"class\": \"className\"\n+  },\n+\n+  prop: function( elem, name, value ) {\n+    var ret, hooks, notxml,\n+      nType = elem.nodeType;\n+\n+    // don't get/set properties on text, comment and attribute nodes\n+    if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {\n+      return;\n+    }\n+\n+    notxml = nType !== 1 || !jQuery.isXMLDoc( elem );\n+\n+    if ( notxml ) {\n+      // Fix name and attach hooks\n+      name = jQuery.propFix[ name ] || name;\n+      hooks = jQuery.propHooks[ name ];\n+    }\n+\n+    if ( value !== undefined ) {\n+      return hooks && \"set\" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ?\n+        ret :\n+        ( elem[ name ] = value );\n+\n+    } else {\n+      return hooks && \"get\" in hooks && (ret = hooks.get( elem, name )) !== null ?\n+        ret :\n+        elem[ name ];\n+    }\n+  },\n+\n+  propHooks: {\n+    tabIndex: {\n+      get: function( elem ) {\n+        return elem.hasAttribute( \"tabindex\" ) || rfocusable.test( elem.nodeName ) || elem.href ?\n+          elem.tabIndex :\n+          -1;\n+      }\n+    }\n+  }\n+});\n+\n+// Support: IE9+\n+// Selectedness for an option in an optgroup can be inaccurate\n+if ( !support.optSelected ) {\n+  jQuery.propHooks.selected = {\n+    get: function( elem ) {\n+      var parent = elem.parentNode;\n+      if ( parent && parent.parentNode ) {\n+        parent.parentNode.selectedIndex;\n+      }\n+      return null;\n+    }\n+  };\n+}\n+\n+jQuery.each([\n+  \"tabIndex\",\n+  \"readOnly\",\n+  \"maxLength\",\n+  \"cellSpacing\",\n+  \"cellPadding\",\n+  \"rowSpan\",\n+  \"colSpan\",\n+  \"useMap\",\n+  \"frameBorder\",\n+  \"contentEditable\"\n+], function() {\n+  jQuery.propFix[ this.toLowerCase() ] = this;\n+});\n+\n+\n+\n+\n+var rclass = /[\\t\\r\\n\\f]/g;\n+\n+jQuery.fn.extend({\n+  addClass: function( value ) {\n+    var classes, elem, cur, clazz, j, finalValue,\n+      proceed = typeof value === \"string\" && value,\n+      i = 0,\n+      len = this.length;\n+\n+    if ( jQuery.isFunction( value ) ) {\n+      return this.each(function( j ) {\n+        jQuery( this ).addClass( value.call( this, j, this.className ) );\n+      });\n+    }\n+\n+    if ( proceed ) {\n+      // The disjunction here is for better compressibility (see removeClass)\n+      classes = ( value || \"\" ).match( rnotwhite ) || [];\n+\n+      for ( ; i < len; i++ ) {\n+        elem = this[ i ];\n+        cur = elem.nodeType === 1 && ( elem.className ?\n+          ( \" \" + elem.className + \" \" ).replace( rclass, \" \" ) :\n+          \" \"\n+        );\n+\n+        if ( cur ) {\n+          j = 0;\n+          while ( (clazz = classes[j++]) ) {\n+            if ( cur.indexOf( \" \" + clazz + \" \" ) < 0 ) {\n+              cur += clazz + \" \";\n+            }\n+          }\n+\n+          // only assign if different to avoid unneeded rendering.\n+          finalValue = jQuery.trim( cur );\n+          if ( elem.className !== finalValue ) {\n+            elem.className = finalValue;\n+          }\n+        }\n+      }\n+    }\n+\n+    return this;\n+  },\n+\n+  removeClass: function( value ) {\n+    var classes, elem, cur, clazz, j, finalValue,\n+      proceed = arguments.length === 0 || typeof value === \"string\" && value,\n+      i = 0,\n+      len = this.length;\n+\n+    if ( jQuery.isFunction( value ) ) {\n+      return this.each(function( j ) {\n+        jQuery( this ).removeClass( value.call( this, j, this.className ) );\n+      });\n+    }\n+    if ( proceed ) {\n+      classes = ( value || \"\" ).match( rnotwhite ) || [];\n+\n+      for ( ; i < len; i++ ) {\n+        elem = this[ i ];\n+        // This expression is here for better compressibility (see addClass)\n+        cur = elem.nodeType === 1 && ( elem.className ?\n+          ( \" \" + elem.className + \" \" ).replace( rclass, \" \" ) :\n+          \"\"\n+        );\n+\n+        if ( cur ) {\n+          j = 0;\n+          while ( (clazz = classes[j++]) ) {\n+            // Remove *all* instances\n+            while ( cur.indexOf( \" \" + clazz + \" \" ) >= 0 ) {\n+              cur = cur.replace( \" \" + clazz + \" \", \" \" );\n+            }\n+          }\n+\n+          // only assign if different to avoid unneeded rendering.\n+          finalValue = value ? jQuery.trim( cur ) : \"\";\n+          if ( elem.className !== finalValue ) {\n+            elem.className = finalValue;\n+          }\n+        }\n+      }\n+    }\n+\n+    return this;\n+  },\n+\n+  toggleClass: function( value, stateVal ) {\n+    var type = typeof value;\n+\n+    if ( typeof stateVal === \"boolean\" && type === \"string\" ) {\n+      return stateVal ? this.addClass( value ) : this.removeClass( value );\n+    }\n+\n+    if ( jQuery.isFunction( value ) ) {\n+      return this.each(function( i ) {\n+        jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );\n+      });\n+    }\n+\n+    return this.each(function() {\n+      if ( type === \"string\" ) {\n+        // toggle individual class names\n+        var className,\n+          i = 0,\n+          self = jQuery( this ),\n+          classNames = value.match( rnotwhite ) || [];\n+\n+        while ( (className = classNames[ i++ ]) ) {\n+          // check each className given, space separated list\n+          if ( self.hasClass( className ) ) {\n+            self.removeClass( className );\n+          } else {\n+            self.addClass( className );\n+          }\n+        }\n+\n+      // Toggle whole class name\n+      } else if ( type === strundefined || type === \"boolean\" ) {\n+        if ( this.className ) {\n+          // store className if set\n+          data_priv.set( this, \"__className__\", this.className );\n+        }\n+\n+        // If the element has a class name or if we're passed \"false\",\n+        // then remove the whole classname (if there was one, the above saved it).\n+        // Otherwise bring back whatever was previously saved (if anything),\n+        // falling back to the empty string if nothing was stored.\n+        this.className = this.className || value === false ? \"\" : data_priv.get( this, \"__className__\" ) || \"\";\n+      }\n+    });\n+  },\n+\n+  hasClass: function( selector ) {\n+    var className = \" \" + selector + \" \",\n+      i = 0,\n+      l = this.length;\n+    for ( ; i < l; i++ ) {\n+      if ( this[i].nodeType === 1 && (\" \" + this[i].className + \" \").replace(rclass, \" \").indexOf( className ) >= 0 ) {\n+        return true;\n+      }\n+    }\n+\n+    return false;\n+  }\n+});\n+\n+\n+\n+\n+var rreturn = /\\r/g;\n+\n+jQuery.fn.extend({\n+  val: function( value ) {\n+    var hooks, ret, isFunction,\n+      elem = this[0];\n+\n+    if ( !arguments.length ) {\n+      if ( elem ) {\n+        hooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];\n+\n+        if ( hooks && \"get\" in hooks && (ret = hooks.get( elem, \"value\" )) !== undefined ) {\n+          return ret;\n+        }\n+\n+        ret = elem.value;\n+\n+        return typeof ret === \"string\" ?\n+          // handle most common string cases\n+          ret.replace(rreturn, \"\") :\n+          // handle cases where value is null/undef or number\n+          ret == null ? \"\" : ret;\n+      }\n+\n+      return;\n+    }\n+\n+    isFunction = jQuery.isFunction( value );\n+\n+    return this.each(function( i ) {\n+      var val;\n+\n+      if ( this.nodeType !== 1 ) {\n+        return;\n+      }\n+\n+      if ( isFunction ) {\n+        val = value.call( this, i, jQuery( this ).val() );\n+      } else {\n+        val = value;\n+      }\n+\n+      // Treat null/undefined as \"\"; convert numbers to string\n+      if ( val == null ) {\n+        val = \"\";\n+\n+      } else if ( typeof val === \"number\" ) {\n+        val += \"\";\n+\n+      } else if ( jQuery.isArray( val ) ) {\n+        val = jQuery.map( val, function( value ) {\n+          return value == null ? \"\" : value + \"\";\n+        });\n+      }\n+\n+      hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];\n+\n+      // If set returns undefined, fall back to normal setting\n+      if ( !hooks || !(\"set\" in hooks) || hooks.set( this, val, \"value\" ) === undefined ) {\n+        this.value = val;\n+      }\n+    });\n+  }\n+});\n+\n+jQuery.extend({\n+  valHooks: {\n+    option: {\n+      get: function( elem ) {\n+        var val = jQuery.find.attr( elem, \"value\" );\n+        return val != null ?\n+          val :\n+          // Support: IE10-11+\n+          // option.text throws exceptions (#14686, #14858)\n+          jQuery.trim( jQuery.text( elem ) );\n+      }\n+    },\n+    select: {\n+      get: function( elem ) {\n+        var value, option,\n+          options = elem.options,\n+          index = elem.selectedIndex,\n+          one = elem.type === \"select-one\" || index < 0,\n+          values = one ? null : [],\n+          max = one ? index + 1 : options.length,\n+          i = index < 0 ?\n+            max :\n+            one ? index : 0;\n+\n+        // Loop through all the selected options\n+        for ( ; i < max; i++ ) {\n+          option = options[ i ];\n+\n+          // IE6-9 doesn't update selected after form reset (#2551)\n+          if ( ( option.selected || i === index ) &&\n+              // Don't return options that are disabled or in a disabled optgroup\n+              ( support.optDisabled ? !option.disabled : option.getAttribute( \"disabled\" ) === null ) &&\n+              ( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode, \"optgroup\" ) ) ) {\n+\n+            // Get the specific value for the option\n+            value = jQuery( option ).val();\n+\n+            // We don't need an array for one selects\n+            if ( one ) {\n+              return value;\n+            }\n+\n+            // Multi-Selects return an array\n+            values.push( value );\n+          }\n+        }\n+\n+        return values;\n+      },\n+\n+      set: function( elem, value ) {\n+        var optionSet, option,\n+          options = elem.options,\n+          values = jQuery.makeArray( value ),\n+          i = options.length;\n+\n+        while ( i-- ) {\n+          option = options[ i ];\n+          if ( (option.selected = jQuery.inArray( option.value, values ) >= 0) ) {\n+            optionSet = true;\n+          }\n+        }\n+\n+        // force browsers to behave consistently when non-matching value is set\n+        if ( !optionSet ) {\n+          elem.selectedIndex = -1;\n+        }\n+        return values;\n+      }\n+    }\n+  }\n+});\n+\n+// Radios and checkboxes getter/setter\n+jQuery.each([ \"radio\", \"checkbox\" ], function() {\n+  jQuery.valHooks[ this ] = {\n+    set: function( elem, value ) {\n+      if ( jQuery.isArray( value ) ) {\n+        return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );\n+      }\n+    }\n+  };\n+  if ( !support.checkOn ) {\n+    jQuery.valHooks[ this ].get = function( elem ) {\n+      // Support: Webkit\n+      // \"\" is returned instead of \"on\" if a value isn't specified\n+      return elem.getAttribute(\"value\") === null ? \"on\" : elem.value;\n+    };\n+  }\n+});\n+\n+\n+\n+\n+// Return jQuery for attributes-only inclusion\n+\n+\n+jQuery.each( (\"blur focus focusin focusout load resize scroll unload click dblclick \" +\n+  \"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave \" +\n+  \"change select submit keydown keypress keyup error contextmenu\").split(\" \"), function( i, name ) {\n+\n+  // Handle event binding\n+  jQuery.fn[ name ] = function( data, fn ) {\n+    return arguments.length > 0 ?\n+      this.on( name, null, data, fn ) :\n+      this.trigger( name );\n+  };\n+});\n+\n+jQuery.fn.extend({\n+  hover: function( fnOver, fnOut ) {\n+    return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );\n+  },\n+\n+  bind: function( types, data, fn ) {\n+    return this.on( types, null, data, fn );\n+  },\n+  unbind: function( types, fn ) {\n+    return this.off( types, null, fn );\n+  },\n+\n+  delegate: function( selector, types, data, fn ) {\n+    return this.on( types, selector, data, fn );\n+  },\n+  undelegate: function( selector, types, fn ) {\n+    // ( namespace ) or ( selector, types [, fn] )\n+    return arguments.length === 1 ? this.off( selector, \"**\" ) : this.off( types, selector || \"**\", fn );\n+  }\n+});\n+\n+\n+var nonce = jQuery.now();\n+\n+var rquery = (/\\?/);\n+\n+\n+\n+// Support: Android 2.3\n+// Workaround failure to string-cast null input\n+jQuery.parseJSON = function( data ) {\n+  return JSON.parse( data + \"\" );\n+};\n+\n+\n+// Cross-browser xml parsing\n+jQuery.parseXML = function( data ) {\n+  var xml, tmp;\n+  if ( !data || typeof data !== \"string\" ) {\n+    return null;\n+  }\n+\n+  // Support: IE9\n+  try {\n+    tmp = new DOMParser();\n+    xml = tmp.parseFromString( data, \"text/xml\" );\n+  } catch ( e ) {\n+    xml = undefined;\n+  }\n+\n+  if ( !xml || xml.getElementsByTagName( \"parsererror\" ).length ) {\n+    jQuery.error( \"Invalid XML: \" + data );\n+  }\n+  return xml;\n+};\n+\n+\n+var\n+  // Document location\n+  ajaxLocParts,\n+  ajaxLocation,\n+\n+  rhash = /#.*$/,\n+  rts = /([?&])_=[^&]*/,\n+  rheaders = /^(.*?):[ \\t]*([^\\r\\n]*)$/mg,\n+  // #7653, #8125, #8152: local protocol detection\n+  rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\n+  rnoContent = /^(?:GET|HEAD)$/,\n+  rprotocol = /^\\/\\//,\n+  rurl = /^([\\w.+-]+:)(?:\\/\\/(?:[^\\/?#]*@|)([^\\/?#:]*)(?::(\\d+)|)|)/,\n+\n+  /* Prefilters\n+   * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\n+   * 2) These are called:\n+   *    - BEFORE asking for a transport\n+   *    - AFTER param serialization (s.data is a string if s.processData is true)\n+   * 3) key is the dataType\n+   * 4) the catchall symbol \"*\" can be used\n+   * 5) execution will start with transport dataType and THEN continue down to \"*\" if needed\n+   */\n+  prefilters = {},\n+\n+  /* Transports bindings\n+   * 1) key is the dataType\n+   * 2) the catchall symbol \"*\" can be used\n+   * 3) selection will start with transport dataType and THEN go to \"*\" if needed\n+   */\n+  transports = {},\n+\n+  // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression\n+  allTypes = \"*/\".concat(\"*\");\n+\n+// #8138, IE may throw an exception when accessing\n+// a field from window.location if document.domain has been set\n+try {\n+  ajaxLocation = location.href;\n+} catch( e ) {\n+  // Use the href attribute of an A element\n+  // since IE will modify it given document.location\n+  ajaxLocation = document.createElement( \"a\" );\n+  ajaxLocation.href = \"\";\n+  ajaxLocation = ajaxLocation.href;\n+}\n+\n+// Segment location into parts\n+ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];\n+\n+// Base \"constructor\" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\n+function addToPrefiltersOrTransports( structure ) {\n+\n+  // dataTypeExpression is optional and defaults to \"*\"\n+  return function( dataTypeExpression, func ) {\n+\n+    if ( typeof dataTypeExpression !== \"string\" ) {\n+      func = dataTypeExpression;\n+      dataTypeExpression = \"*\";\n+    }\n+\n+    var dataType,\n+      i = 0,\n+      dataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];\n+\n+    if ( jQuery.isFunction( func ) ) {\n+      // For each dataType in the dataTypeExpression\n+      while ( (dataType = dataTypes[i++]) ) {\n+        // Prepend if requested\n+        if ( dataType[0] === \"+\" ) {\n+          dataType = dataType.slice( 1 ) || \"*\";\n+          (structure[ dataType ] = structure[ dataType ] || []).unshift( func );\n+\n+        // Otherwise append\n+        } else {\n+          (structure[ dataType ] = structure[ dataType ] || []).push( func );\n+        }\n+      }\n+    }\n+  };\n+}\n+\n+// Base inspection function for prefilters and transports\n+function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {\n+\n+  var inspected = {},\n+    seekingTransport = ( structure === transports );\n+\n+  function inspect( dataType ) {\n+    var selected;\n+    inspected[ dataType ] = true;\n+    jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {\n+      var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );\n+      if ( typeof dataTypeOrTransport === \"string\" && !seekingTransport && !inspected[ dataTypeOrTransport ] ) {\n+        options.dataTypes.unshift( dataTypeOrTransport );\n+        inspect( dataTypeOrTransport );\n+        return false;\n+      } else if ( seekingTransport ) {\n+        return !( selected = dataTypeOrTransport );\n+      }\n+    });\n+    return selected;\n+  }\n+\n+  return inspect( options.dataTypes[ 0 ] ) || !inspected[ \"*\" ] && inspect( \"*\" );\n+}\n+\n+// A special extend for ajax options\n+// that takes \"flat\" options (not to be deep extended)\n+// Fixes #9887\n+function ajaxExtend( target, src ) {\n+  var key, deep,\n+    flatOptions = jQuery.ajaxSettings.flatOptions || {};\n+\n+  for ( key in src ) {\n+    if ( src[ key ] !== undefined ) {\n+      ( flatOptions[ key ] ? target : ( deep || (deep = {}) ) )[ key ] = src[ key ];\n+    }\n+  }\n+  if ( deep ) {\n+    jQuery.extend( true, target, deep );\n+  }\n+\n+  return target;\n+}\n+\n+/* Handles responses to an ajax request:\n+ * - finds the right dataType (mediates between content-type and expected dataType)\n+ * - returns the corresponding response\n+ */\n+function ajaxHandleResponses( s, jqXHR, responses ) {\n+\n+  var ct, type, finalDataType, firstDataType,\n+    contents = s.contents,\n+    dataTypes = s.dataTypes;\n+\n+  // Remove auto dataType and get content-type in the process\n+  while ( dataTypes[ 0 ] === \"*\" ) {\n+    dataTypes.shift();\n+    if ( ct === undefined ) {\n+      ct = s.mimeType || jqXHR.getResponseHeader(\"Content-Type\");\n+    }\n+  }\n+\n+  // Check if we're dealing with a known content-type\n+  if ( ct ) {\n+    for ( type in contents ) {\n+      if ( contents[ type ] && contents[ type ].test( ct ) ) {\n+        dataTypes.unshift( type );\n+        break;\n+      }\n+    }\n+  }\n+\n+  // Check to see if we have a response for the expected dataType\n+  if ( dataTypes[ 0 ] in responses ) {\n+    finalDataType = dataTypes[ 0 ];\n+  } else {\n+    // Try convertible dataTypes\n+    for ( type in responses ) {\n+      if ( !dataTypes[ 0 ] || s.converters[ type + \" \" + dataTypes[0] ] ) {\n+        finalDataType = type;\n+        break;\n+      }\n+      if ( !firstDataType ) {\n+        firstDataType = type;\n+      }\n+    }\n+    // Or just use first one\n+    finalDataType = finalDataType || firstDataType;\n+  }\n+\n+  // If we found a dataType\n+  // We add the dataType to the list if needed\n+  // and return the corresponding response\n+  if ( finalDataType ) {\n+    if ( finalDataType !== dataTypes[ 0 ] ) {\n+      dataTypes.unshift( finalDataType );\n+    }\n+    return responses[ finalDataType ];\n+  }\n+}\n+\n+/* Chain conversions given the request and the original response\n+ * Also sets the responseXXX fields on the jqXHR instance\n+ */\n+function ajaxConvert( s, response, jqXHR, isSuccess ) {\n+  var conv2, current, conv, tmp, prev,\n+    converters = {},\n+    // Work with a copy of dataTypes in case we need to modify it for conversion\n+    dataTypes = s.dataTypes.slice();\n+\n+  // Create converters map with lowercased keys\n+  if ( dataTypes[ 1 ] ) {\n+    for ( conv in s.converters ) {\n+      converters[ conv.toLowerCase() ] = s.converters[ conv ];\n+    }\n+  }\n+\n+  current = dataTypes.shift();\n+\n+  // Convert to each sequential dataType\n+  while ( current ) {\n+\n+    if ( s.responseFields[ current ] ) {\n+      jqXHR[ s.responseFields[ current ] ] = response;\n+    }\n+\n+    // Apply the dataFilter if provided\n+    if ( !prev && isSuccess && s.dataFilter ) {\n+      response = s.dataFilter( response, s.dataType );\n+    }\n+\n+    prev = current;\n+    current = dataTypes.shift();\n+\n+    if ( current ) {\n+\n+    // There's only work to do if current dataType is non-auto\n+      if ( current === \"*\" ) {\n+\n+        current = prev;\n+\n+      // Convert response if prev dataType is non-auto and differs from current\n+      } else if ( prev !== \"*\" && prev !== current ) {\n+\n+        // Seek a direct converter\n+        conv = converters[ prev + \" \" + current ] || converters[ \"* \" + current ];\n+\n+        // If none found, seek a pair\n+        if ( !conv ) {\n+          for ( conv2 in converters ) {\n+\n+            // If conv2 outputs current\n+            tmp = conv2.split( \" \" );\n+            if ( tmp[ 1 ] === current ) {\n+\n+              // If prev can be converted to accepted input\n+              conv = converters[ prev + \" \" + tmp[ 0 ] ] ||\n+                converters[ \"* \" + tmp[ 0 ] ];\n+              if ( conv ) {\n+                // Condense equivalence converters\n+                if ( conv === true ) {\n+                  conv = converters[ conv2 ];\n+\n+                // Otherwise, insert the intermediate dataType\n+                } else if ( converters[ conv2 ] !== true ) {\n+                  current = tmp[ 0 ];\n+                  dataTypes.unshift( tmp[ 1 ] );\n+                }\n+                break;\n+              }\n+            }\n+          }\n+        }\n+\n+        // Apply converter (if not an equivalence)\n+        if ( conv !== true ) {\n+\n+          // Unless errors are allowed to bubble, catch and return them\n+          if ( conv && s[ \"throws\" ] ) {\n+            response = conv( response );\n+          } else {\n+            try {\n+              response = conv( response );\n+            } catch ( e ) {\n+              return { state: \"parsererror\", error: conv ? e : \"No conversion from \" + prev + \" to \" + current };\n+            }\n+          }\n+        }\n+      }\n+    }\n+  }\n+\n+  return { state: \"success\", data: response };\n+}\n+\n+jQuery.extend({\n+\n+  // Counter for holding the number of active queries\n+  active: 0,\n+\n+  // Last-Modified header cache for next request\n+  lastModified: {},\n+  etag: {},\n+\n+  ajaxSettings: {\n+    url: ajaxLocation,\n+    type: \"GET\",\n+    isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),\n+    global: true,\n+    processData: true,\n+    async: true,\n+    contentType: \"application/x-www-form-urlencoded; charset=UTF-8\",\n+    /*\n+    timeout: 0,\n+    data: null,\n+    dataType: null,\n+    username: null,\n+    password: null,\n+    cache: null,\n+    throws: false,\n+    traditional: false,\n+    headers: {},\n+    */\n+\n+    accepts: {\n+      \"*\": allTypes,\n+      text: \"text/plain\",\n+      html: \"text/html\",\n+      xml: \"application/xml, text/xml\",\n+      json: \"application/json, text/javascript\"\n+    },\n+\n+    contents: {\n+      xml: /xml/,\n+      html: /html/,\n+      json: /json/\n+    },\n+\n+    responseFields: {\n+      xml: \"responseXML\",\n+      text: \"responseText\",\n+      json: \"responseJSON\"\n+    },\n+\n+    // Data converters\n+    // Keys separate source (or catchall \"*\") and destination types with a single space\n+    converters: {\n+\n+      // Convert anything to text\n+      \"* text\": String,\n+\n+      // Text to html (true = no transformation)\n+      \"text html\": true,\n+\n+      // Evaluate text as a json expression\n+      \"text json\": jQuery.parseJSON,\n+\n+      // Parse text as xml\n+      \"text xml\": jQuery.parseXML\n+    },\n+\n+    // For options that shouldn't be deep extended:\n+    // you can add your own custom options here if\n+    // and when you create one that shouldn't be\n+    // deep extended (see ajaxExtend)\n+    flatOptions: {\n+      url: true,\n+      context: true\n+    }\n+  },\n+\n+  // Creates a full fledged settings object into target\n+  // with both ajaxSettings and settings fields.\n+  // If target is omitted, writes into ajaxSettings.\n+  ajaxSetup: function( target, settings ) {\n+    return settings ?\n+\n+      // Building a settings object\n+      ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :\n+\n+      // Extending ajaxSettings\n+      ajaxExtend( jQuery.ajaxSettings, target );\n+  },\n+\n+  ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),\n+  ajaxTransport: addToPrefiltersOrTransports( transports ),\n+\n+  // Main method\n+  ajax: function( url, options ) {\n+\n+    // If url is an object, simulate pre-1.5 signature\n+    if ( typeof url === \"object\" ) {\n+      options = url;\n+      url = undefined;\n+    }\n+\n+    // Force options to be an object\n+    options = options || {};\n+\n+    var transport,\n+      // URL without anti-cache param\n+      cacheURL,\n+      // Response headers\n+      responseHeadersString,\n+      responseHeaders,\n+      // timeout handle\n+      timeoutTimer,\n+      // Cross-domain detection vars\n+      parts,\n+      // To know if global events are to be dispatched\n+      fireGlobals,\n+      // Loop variable\n+      i,\n+      // Create the final options object\n+      s = jQuery.ajaxSetup( {}, options ),\n+      // Callbacks context\n+      callbackContext = s.context || s,\n+      // Context for global events is callbackContext if it is a DOM node or jQuery collection\n+      globalEventContext = s.context && ( callbackContext.nodeType || callbackContext.jquery ) ?\n+        jQuery( callbackContext ) :\n+        jQuery.event,\n+      // Deferreds\n+      deferred = jQuery.Deferred(),\n+      completeDeferred = jQuery.Callbacks(\"once memory\"),\n+      // Status-dependent callbacks\n+      statusCode = s.statusCode || {},\n+      // Headers (they are sent all at once)\n+      requestHeaders = {},\n+      requestHeadersNames = {},\n+      // The jqXHR state\n+      state = 0,\n+      // Default abort message\n+      strAbort = \"canceled\",\n+      // Fake xhr\n+      jqXHR = {\n+        readyState: 0,\n+\n+        // Builds headers hashtable if needed\n+        getResponseHeader: function( key ) {\n+          var match;\n+          if ( state === 2 ) {\n+            if ( !responseHeaders ) {\n+              responseHeaders = {};\n+              while ( (match = rheaders.exec( responseHeadersString )) ) {\n+                responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];\n+              }\n+            }\n+            match = responseHeaders[ key.toLowerCase() ];\n+          }\n+          return match == null ? null : match;\n+        },\n+\n+        // Raw string\n+        getAllResponseHeaders: function() {\n+          return state === 2 ? responseHeadersString : null;\n+        },\n+\n+        // Caches the header\n+        setRequestHeader: function( name, value ) {\n+          var lname = name.toLowerCase();\n+          if ( !state ) {\n+            name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;\n+            requestHeaders[ name ] = value;\n+          }\n+          return this;\n+        },\n+\n+        // Overrides response content-type header\n+        overrideMimeType: function( type ) {\n+          if ( !state ) {\n+            s.mimeType = type;\n+          }\n+          return this;\n+        },\n+\n+        // Status-dependent callbacks\n+        statusCode: function( map ) {\n+          var code;\n+          if ( map ) {\n+            if ( state < 2 ) {\n+              for ( code in map ) {\n+                // Lazy-add the new callback in a way that preserves old ones\n+                statusCode[ code ] = [ statusCode[ code ], map[ code ] ];\n+              }\n+            } else {\n+              // Execute the appropriate callbacks\n+              jqXHR.always( map[ jqXHR.status ] );\n+            }\n+          }\n+          return this;\n+        },\n+\n+        // Cancel the request\n+        abort: function( statusText ) {\n+          var finalText = statusText || strAbort;\n+          if ( transport ) {\n+            transport.abort( finalText );\n+          }\n+          done( 0, finalText );\n+          return this;\n+        }\n+      };\n+\n+    // Attach deferreds\n+    deferred.promise( jqXHR ).complete = completeDeferred.add;\n+    jqXHR.success = jqXHR.done;\n+    jqXHR.error = jqXHR.fail;\n+\n+    // Remove hash character (#7531: and string promotion)\n+    // Add protocol if not provided (prefilters might expect it)\n+    // Handle falsy url in the settings object (#10093: consistency with old signature)\n+    // We also use the url parameter if available\n+    s.url = ( ( url || s.url || ajaxLocation ) + \"\" ).replace( rhash, \"\" )\n+      .replace( rprotocol, ajaxLocParts[ 1 ] + \"//\" );\n+\n+    // Alias method option to type as per ticket #12004\n+    s.type = options.method || options.type || s.method || s.type;\n+\n+    // Extract dataTypes list\n+    s.dataTypes = jQuery.trim( s.dataType || \"*\" ).toLowerCase().match( rnotwhite ) || [ \"\" ];\n+\n+    // A cross-domain request is in order when we have a protocol:host:port mismatch\n+    if ( s.crossDomain == null ) {\n+      parts = rurl.exec( s.url.toLowerCase() );\n+      s.crossDomain = !!( parts &&\n+        ( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||\n+          ( parts[ 3 ] || ( parts[ 1 ] === \"http:\" ? \"80\" : \"443\" ) ) !==\n+            ( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === \"http:\" ? \"80\" : \"443\" ) ) )\n+      );\n+    }\n+\n+    // Convert data if not already a string\n+    if ( s.data && s.processData && typeof s.data !== \"string\" ) {\n+      s.data = jQuery.param( s.data, s.traditional );\n+    }\n+\n+    // Apply prefilters\n+    inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );\n+\n+    // If request was aborted inside a prefilter, stop there\n+    if ( state === 2 ) {\n+      return jqXHR;\n+    }\n+\n+    // We can fire global events as of now if asked to\n+    fireGlobals = s.global;\n+\n+    // Watch for a new set of requests\n+    if ( fireGlobals && jQuery.active++ === 0 ) {\n+      jQuery.event.trigger(\"ajaxStart\");\n+    }\n+\n+    // Uppercase the type\n+    s.type = s.type.toUpperCase();\n+\n+    // Determine if request has content\n+    s.hasContent = !rnoContent.test( s.type );\n+\n+    // Save the URL in case we're toying with the If-Modified-Since\n+    // and/or If-None-Match header later on\n+    cacheURL = s.url;\n+\n+    // More options handling for requests with no content\n+    if ( !s.hasContent ) {\n+\n+      // If data is available, append data to url\n+      if ( s.data ) {\n+        cacheURL = ( s.url += ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + s.data );\n+        // #9682: remove data so that it's not used in an eventual retry\n+        delete s.data;\n+      }\n+\n+      // Add anti-cache in url if needed\n+      if ( s.cache === false ) {\n+        s.url = rts.test( cacheURL ) ?\n+\n+          // If there is already a '_' parameter, set its value\n+          cacheURL.replace( rts, \"$1_=\" + nonce++ ) :\n+\n+          // Otherwise add one to the end\n+          cacheURL + ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + \"_=\" + nonce++;\n+      }\n+    }\n+\n+    // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n+    if ( s.ifModified ) {\n+      if ( jQuery.lastModified[ cacheURL ] ) {\n+        jqXHR.setRequestHeader( \"If-Modified-Since\", jQuery.lastModified[ cacheURL ] );\n+      }\n+      if ( jQuery.etag[ cacheURL ] ) {\n+        jqXHR.setRequestHeader( \"If-None-Match\", jQuery.etag[ cacheURL ] );\n+      }\n+    }\n+\n+    // Set the correct header, if data is being sent\n+    if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {\n+      jqXHR.setRequestHeader( \"Content-Type\", s.contentType );\n+    }\n+\n+    // Set the Accepts header for the server, depending on the dataType\n+    jqXHR.setRequestHeader(\n+      \"Accept\",\n+      s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?\n+        s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== \"*\" ? \", \" + allTypes + \"; q=0.01\" : \"\" ) :\n+        s.accepts[ \"*\" ]\n+    );\n+\n+    // Check for headers option\n+    for ( i in s.headers ) {\n+      jqXHR.setRequestHeader( i, s.headers[ i ] );\n+    }\n+\n+    // Allow custom headers/mimetypes and early abort\n+    if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {\n+      // Abort if not done already and return\n+      return jqXHR.abort();\n+    }\n+\n+    // aborting is no longer a cancellation\n+    strAbort = \"abort\";\n+\n+    // Install callbacks on deferreds\n+    for ( i in { success: 1, error: 1, complete: 1 } ) {\n+      jqXHR[ i ]( s[ i ] );\n+    }\n+\n+    // Get transport\n+    transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );\n+\n+    // If no transport, we auto-abort\n+    if ( !transport ) {\n+      done( -1, \"No Transport\" );\n+    } else {\n+      jqXHR.readyState = 1;\n+\n+      // Send global event\n+      if ( fireGlobals ) {\n+        globalEventContext.trigger( \"ajaxSend\", [ jqXHR, s ] );\n+      }\n+      // Timeout\n+      if ( s.async && s.timeout > 0 ) {\n+        timeoutTimer = setTimeout(function() {\n+          jqXHR.abort(\"timeout\");\n+        }, s.timeout );\n+      }\n+\n+      try {\n+        state = 1;\n+        transport.send( requestHeaders, done );\n+      } catch ( e ) {\n+        // Propagate exception as error if not done\n+        if ( state < 2 ) {\n+          done( -1, e );\n+        // Simply rethrow otherwise\n+        } else {\n+          throw e;\n+        }\n+      }\n+    }\n+\n+    // Callback for when everything is done\n+    function done( status, nativeStatusText, responses, headers ) {\n+      var isSuccess, success, error, response, modified,\n+        statusText = nativeStatusText;\n+\n+      // Called once\n+      if ( state === 2 ) {\n+        return;\n+      }\n+\n+      // State is \"done\" now\n+      state = 2;\n+\n+      // Clear timeout if it exists\n+      if ( timeoutTimer ) {\n+        clearTimeout( timeoutTimer );\n+      }\n+\n+      // Dereference transport for early garbage collection\n+      // (no matter how long the jqXHR object will be used)\n+      transport = undefined;\n+\n+      // Cache response headers\n+      responseHeadersString = headers || \"\";\n+\n+      // Set readyState\n+      jqXHR.readyState = status > 0 ? 4 : 0;\n+\n+      // Determine if successful\n+      isSuccess = status >= 200 && status < 300 || status === 304;\n+\n+      // Get response data\n+      if ( responses ) {\n+        response = ajaxHandleResponses( s, jqXHR, responses );\n+      }\n+\n+      // Convert no matter what (that way responseXXX fields are always set)\n+      response = ajaxConvert( s, response, jqXHR, isSuccess );\n+\n+      // If successful, handle type chaining\n+      if ( isSuccess ) {\n+\n+        // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n+        if ( s.ifModified ) {\n+          modified = jqXHR.getResponseHeader(\"Last-Modified\");\n+          if ( modified ) {\n+            jQuery.lastModified[ cacheURL ] = modified;\n+          }\n+          modified = jqXHR.getResponseHeader(\"etag\");\n+          if ( modified ) {\n+            jQuery.etag[ cacheURL ] = modified;\n+          }\n+        }\n+\n+        // if no content\n+        if ( status === 204 || s.type === \"HEAD\" ) {\n+          statusText = \"nocontent\";\n+\n+        // if not modified\n+        } else if ( status === 304 ) {\n+          statusText = \"notmodified\";\n+\n+        // If we have data, let's convert it\n+        } else {\n+          statusText = response.state;\n+          success = response.data;\n+          error = response.error;\n+          isSuccess = !error;\n+        }\n+      } else {\n+        // We extract error from statusText\n+        // then normalize statusText and status for non-aborts\n+        error = statusText;\n+        if ( status || !statusText ) {\n+          statusText = \"error\";\n+          if ( status < 0 ) {\n+            status = 0;\n+          }\n+        }\n+      }\n+\n+      // Set data for the fake xhr object\n+      jqXHR.status = status;\n+      jqXHR.statusText = ( nativeStatusText || statusText ) + \"\";\n+\n+      // Success/Error\n+      if ( isSuccess ) {\n+        deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );\n+      } else {\n+        deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );\n+      }\n+\n+      // Status-dependent callbacks\n+      jqXHR.statusCode( statusCode );\n+      statusCode = undefined;\n+\n+      if ( fireGlobals ) {\n+        globalEventContext.trigger( isSuccess ? \"ajaxSuccess\" : \"ajaxError\",\n+          [ jqXHR, s, isSuccess ? success : error ] );\n+      }\n+\n+      // Complete\n+      completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );\n+\n+      if ( fireGlobals ) {\n+        globalEventContext.trigger( \"ajaxComplete\", [ jqXHR, s ] );\n+        // Handle the global AJAX counter\n+        if ( !( --jQuery.active ) ) {\n+          jQuery.event.trigger(\"ajaxStop\");\n+        }\n+      }\n+    }\n+\n+    return jqXHR;\n+  },\n+\n+  getJSON: function( url, data, callback ) {\n+    return jQuery.get( url, data, callback, \"json\" );\n+  },\n+\n+  getScript: function( url, callback ) {\n+    return jQuery.get( url, undefined, callback, \"script\" );\n+  }\n+});\n+\n+jQuery.each( [ \"get\", \"post\" ], function( i, method ) {\n+  jQuery[ method ] = function( url, data, callback, type ) {\n+    // shift arguments if data argument was omitted\n+    if ( jQuery.isFunction( data ) ) {\n+      type = type || callback;\n+      callback = data;\n+      data = undefined;\n+    }\n+\n+    return jQuery.ajax({\n+      url: url,\n+      type: method,\n+      dataType: type,\n+      data: data,\n+      success: callback\n+    });\n+  };\n+});\n+\n+// Attach a bunch of functions for handling common AJAX events\n+jQuery.each( [ \"ajaxStart\", \"ajaxStop\", \"ajaxComplete\", \"ajaxError\", \"ajaxSuccess\", \"ajaxSend\" ], function( i, type ) {\n+  jQuery.fn[ type ] = function( fn ) {\n+    return this.on( type, fn );\n+  };\n+});\n+\n+\n+jQuery._evalUrl = function( url ) {\n+  return jQuery.ajax({\n+    url: url,\n+    type: \"GET\",\n+    dataType: \"script\",\n+    async: false,\n+    global: false,\n+    \"throws\": true\n+  });\n+};\n+\n+\n+jQuery.fn.extend({\n+  wrapAll: function( html ) {\n+    var wrap;\n+\n+    if ( jQuery.isFunction( html ) ) {\n+      return this.each(function( i ) {\n+        jQuery( this ).wrapAll( html.call(this, i) );\n+      });\n+    }\n+\n+    if ( this[ 0 ] ) {\n+\n+      // The elements to wrap the target around\n+      wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );\n+\n+      if ( this[ 0 ].parentNode ) {\n+        wrap.insertBefore( this[ 0 ] );\n+      }\n+\n+      wrap.map(function() {\n+        var elem = this;\n+\n+        while ( elem.firstElementChild ) {\n+          elem = elem.firstElementChild;\n+        }\n+\n+        return elem;\n+      }).append( this );\n+    }\n+\n+    return this;\n+  },\n+\n+  wrapInner: function( html ) {\n+    if ( jQuery.isFunction( html ) ) {\n+      return this.each(function( i ) {\n+        jQuery( this ).wrapInner( html.call(this, i) );\n+      });\n+    }\n+\n+    return this.each(function() {\n+      var self = jQuery( this ),\n+        contents = self.contents();\n+\n+      if ( contents.length ) {\n+        contents.wrapAll( html );\n+\n+      } else {\n+        self.append( html );\n+      }\n+    });\n+  },\n+\n+  wrap: function( html ) {\n+    var isFunction = jQuery.isFunction( html );\n+\n+    return this.each(function( i ) {\n+      jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );\n+    });\n+  },\n+\n+  unwrap: function() {\n+    return this.parent().each(function() {\n+      if ( !jQuery.nodeName( this, \"body\" ) ) {\n+        jQuery( this ).replaceWith( this.childNodes );\n+      }\n+    }).end();\n+  }\n+});\n+\n+\n+jQuery.expr.filters.hidden = function( elem ) {\n+  // Support: Opera <= 12.12\n+  // Opera reports offsetWidths and offsetHeights less than zero on some elements\n+  return elem.offsetWidth <= 0 && elem.offsetHeight <= 0;\n+};\n+jQuery.expr.filters.visible = function( elem ) {\n+  return !jQuery.expr.filters.hidden( elem );\n+};\n+\n+\n+\n+\n+var r20 = /%20/g,\n+  rbracket = /\\[\\]$/,\n+  rCRLF = /\\r?\\n/g,\n+  rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,\n+  rsubmittable = /^(?:input|select|textarea|keygen)/i;\n+\n+function buildParams( prefix, obj, traditional, add ) {\n+  var name;\n+\n+  if ( jQuery.isArray( obj ) ) {\n+    // Serialize array item.\n+    jQuery.each( obj, function( i, v ) {\n+      if ( traditional || rbracket.test( prefix ) ) {\n+        // Treat each array item as a scalar.\n+        add( prefix, v );\n+\n+      } else {\n+        // Item is non-scalar (array or object), encode its numeric index.\n+        buildParams( prefix + \"[\" + ( typeof v === \"object\" ? i : \"\" ) + \"]\", v, traditional, add );\n+      }\n+    });\n+\n+  } else if ( !traditional && jQuery.type( obj ) === \"object\" ) {\n+    // Serialize object item.\n+    for ( name in obj ) {\n+      buildParams( prefix + \"[\" + name + \"]\", obj[ name ], traditional, add );\n+    }\n+\n+  } else {\n+    // Serialize scalar item.\n+    add( prefix, obj );\n+  }\n+}\n+\n+// Serialize an array of form elements or a set of\n+// key/values into a query string\n+jQuery.param = function( a, traditional ) {\n+  var prefix,\n+    s = [],\n+    add = function( key, value ) {\n+      // If value is a function, invoke it and return its value\n+      value = jQuery.isFunction( value ) ? value() : ( value == null ? \"\" : value );\n+      s[ s.length ] = encodeURIComponent( key ) + \"=\" + encodeURIComponent( value );\n+    };\n+\n+  // Set traditional to true for jQuery <= 1.3.2 behavior.\n+  if ( traditional === undefined ) {\n+    traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;\n+  }\n+\n+  // If an array was passed in, assume that it is an array of form elements.\n+  if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {\n+    // Serialize the form elements\n+    jQuery.each( a, function() {\n+      add( this.name, this.value );\n+    });\n+\n+  } else {\n+    // If traditional, encode the \"old\" way (the way 1.3.2 or older\n+    // did it), otherwise encode params recursively.\n+    for ( prefix in a ) {\n+      buildParams( prefix, a[ prefix ], traditional, add );\n+    }\n+  }\n+\n+  // Return the resulting serialization\n+  return s.join( \"&\" ).replace( r20, \"+\" );\n+};\n+\n+jQuery.fn.extend({\n+  serialize: function() {\n+    return jQuery.param( this.serializeArray() );\n+  },\n+  serializeArray: function() {\n+    return this.map(function() {\n+      // Can add propHook for \"elements\" to filter or add form elements\n+      var elements = jQuery.prop( this, \"elements\" );\n+      return elements ? jQuery.makeArray( elements ) : this;\n+    })\n+    .filter(function() {\n+      var type = this.type;\n+\n+      // Use .is( \":disabled\" ) so that fieldset[disabled] works\n+      return this.name && !jQuery( this ).is( \":disabled\" ) &&\n+        rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&\n+        ( this.checked || !rcheckableType.test( type ) );\n+    })\n+    .map(function( i, elem ) {\n+      var val = jQuery( this ).val();\n+\n+      return val == null ?\n+        null :\n+        jQuery.isArray( val ) ?\n+          jQuery.map( val, function( val ) {\n+            return { name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n+          }) :\n+          { name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n+    }).get();\n+  }\n+});\n+\n+\n+jQuery.ajaxSettings.xhr = function() {\n+  try {\n+    return new XMLHttpRequest();\n+  } catch( e ) {}\n+};\n+\n+var xhrId = 0,\n+  xhrCallbacks = {},\n+  xhrSuccessStatus = {\n+    // file protocol always yields status code 0, assume 200\n+    0: 200,\n+    // Support: IE9\n+    // #1450: sometimes IE returns 1223 when it should be 204\n+    1223: 204\n+  },\n+  xhrSupported = jQuery.ajaxSettings.xhr();\n+\n+// Support: IE9\n+// Open requests must be manually aborted on unload (#5280)\n+if ( window.ActiveXObject ) {\n+  jQuery( window ).on( \"unload\", function() {\n+    for ( var key in xhrCallbacks ) {\n+      xhrCallbacks[ key ]();\n+    }\n+  });\n+}\n+\n+support.cors = !!xhrSupported && ( \"withCredentials\" in xhrSupported );\n+support.ajax = xhrSupported = !!xhrSupported;\n+\n+jQuery.ajaxTransport(function( options ) {\n+  var callback;\n+\n+  // Cross domain only allowed if supported through XMLHttpRequest\n+  if ( support.cors || xhrSupported && !options.crossDomain ) {\n+    return {\n+      send: function( headers, complete ) {\n+        var i,\n+          xhr = options.xhr(),\n+          id = ++xhrId;\n+\n+        xhr.open( options.type, options.url, options.async, options.username, options.password );\n+\n+        // Apply custom fields if provided\n+        if ( options.xhrFields ) {\n+          for ( i in options.xhrFields ) {\n+            xhr[ i ] = options.xhrFields[ i ];\n+          }\n+        }\n+\n+        // Override mime type if needed\n+        if ( options.mimeType && xhr.overrideMimeType ) {\n+          xhr.overrideMimeType( options.mimeType );\n+        }\n+\n+        // X-Requested-With header\n+        // For cross-domain requests, seeing as conditions for a preflight are\n+        // akin to a jigsaw puzzle, we simply never set it to be sure.\n+        // (it can always be set on a per-request basis or even using ajaxSetup)\n+        // For same-domain requests, won't change header if already provided.\n+        if ( !options.crossDomain && !headers[\"X-Requested-With\"] ) {\n+          headers[\"X-Requested-With\"] = \"XMLHttpRequest\";\n+        }\n+\n+        // Set headers\n+        for ( i in headers ) {\n+          xhr.setRequestHeader( i, headers[ i ] );\n+        }\n+\n+        // Callback\n+        callback = function( type ) {\n+          return function() {\n+            if ( callback ) {\n+              delete xhrCallbacks[ id ];\n+              callback = xhr.onload = xhr.onerror = null;\n+\n+              if ( type === \"abort\" ) {\n+                xhr.abort();\n+              } else if ( type === \"error\" ) {\n+                complete(\n+                  // file: protocol always yields status 0; see #8605, #14207\n+                  xhr.status,\n+                  xhr.statusText\n+                );\n+              } else {\n+                complete(\n+                  xhrSuccessStatus[ xhr.status ] || xhr.status,\n+                  xhr.statusText,\n+                  // Support: IE9\n+                  // Accessing binary-data responseText throws an exception\n+                  // (#11426)\n+                  typeof xhr.responseText === \"string\" ? {\n+                    text: xhr.responseText\n+                  } : undefined,\n+                  xhr.getAllResponseHeaders()\n+                );\n+              }\n+            }\n+          };\n+        };\n+\n+        // Listen to events\n+        xhr.onload = callback();\n+        xhr.onerror = callback(\"error\");\n+\n+        // Create the abort callback\n+        callback = xhrCallbacks[ id ] = callback(\"abort\");\n+\n+        try {\n+          // Do send the request (this may raise an exception)\n+          xhr.send( options.hasContent && options.data || null );\n+        } catch ( e ) {\n+          // #14683: Only rethrow if this hasn't been notified as an error yet\n+          if ( callback ) {\n+            throw e;\n+          }\n+        }\n+      },\n+\n+      abort: function() {\n+        if ( callback ) {\n+          callback();\n+        }\n+      }\n+    };\n+  }\n+});\n+\n+\n+\n+\n+// Install script dataType\n+jQuery.ajaxSetup({\n+  accepts: {\n+    script: \"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript\"\n+  },\n+  contents: {\n+    script: /(?:java|ecma)script/\n+  },\n+  converters: {\n+    \"text script\": function( text ) {\n+      jQuery.globalEval( text );\n+      return text;\n+    }\n+  }\n+});\n+\n+// Handle cache's special case and crossDomain\n+jQuery.ajaxPrefilter( \"script\", function( s ) {\n+  if ( s.cache === undefined ) {\n+    s.cache = false;\n+  }\n+  if ( s.crossDomain ) {\n+    s.type = \"GET\";\n+  }\n+});\n+\n+// Bind script tag hack transport\n+jQuery.ajaxTransport( \"script\", function( s ) {\n+  // This transport only deals with cross domain requests\n+  if ( s.crossDomain ) {\n+    var script, callback;\n+    return {\n+      send: function( _, complete ) {\n+        script = jQuery(\"<script>\").prop({\n+          async: true,\n+          charset: s.scriptCharset,\n+          src: s.url\n+        }).on(\n+          \"load error\",\n+          callback = function( evt ) {\n+            script.remove();\n+            callback = null;\n+            if ( evt ) {\n+              complete( evt.type === \"error\" ? 404 : 200, evt.type );\n+            }\n+          }\n+        );\n+        document.head.appendChild( script[ 0 ] );\n+      },\n+      abort: function() {\n+        if ( callback ) {\n+          callback();\n+        }\n+      }\n+    };\n+  }\n+});\n+\n+\n+\n+\n+var oldCallbacks = [],\n+  rjsonp = /(=)\\?(?=&|$)|\\?\\?/;\n+\n+// Default jsonp settings\n+jQuery.ajaxSetup({\n+  jsonp: \"callback\",\n+  jsonpCallback: function() {\n+    var callback = oldCallbacks.pop() || ( jQuery.expando + \"_\" + ( nonce++ ) );\n+    this[ callback ] = true;\n+    return callback;\n+  }\n+});\n+\n+// Detect, normalize options and install callbacks for jsonp requests\n+jQuery.ajaxPrefilter( \"json jsonp\", function( s, originalSettings, jqXHR ) {\n+\n+  var callbackName, overwritten, responseContainer,\n+    jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?\n+      \"url\" :\n+      typeof s.data === \"string\" && !( s.contentType || \"\" ).indexOf(\"application/x-www-form-urlencoded\") && rjsonp.test( s.data ) && \"data\"\n+    );\n+\n+  // Handle iff the expected data type is \"jsonp\" or we have a parameter to set\n+  if ( jsonProp || s.dataTypes[ 0 ] === \"jsonp\" ) {\n+\n+    // Get callback name, remembering preexisting value associated with it\n+    callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?\n+      s.jsonpCallback() :\n+      s.jsonpCallback;\n+\n+    // Insert callback into url or form data\n+    if ( jsonProp ) {\n+      s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, \"$1\" + callbackName );\n+    } else if ( s.jsonp !== false ) {\n+      s.url += ( rquery.test( s.url ) ? \"&\" : \"?\" ) + s.jsonp + \"=\" + callbackName;\n+    }\n+\n+    // Use data converter to retrieve json after script execution\n+    s.converters[\"script json\"] = function() {\n+      if ( !responseContainer ) {\n+        jQuery.error( callbackName + \" was not called\" );\n+      }\n+      return responseContainer[ 0 ];\n+    };\n+\n+    // force json dataType\n+    s.dataTypes[ 0 ] = \"json\";\n+\n+    // Install callback\n+    overwritten = window[ callbackName ];\n+    window[ callbackName ] = function() {\n+      responseContainer = arguments;\n+    };\n+\n+    // Clean-up function (fires after converters)\n+    jqXHR.always(function() {\n+      // Restore preexisting value\n+      window[ callbackName ] = overwritten;\n+\n+      // Save back as free\n+      if ( s[ callbackName ] ) {\n+        // make sure that re-using the options doesn't screw things around\n+        s.jsonpCallback = originalSettings.jsonpCallback;\n+\n+        // save the callback name for future use\n+        oldCallbacks.push( callbackName );\n+      }\n+\n+      // Call if it was a function and we have a response\n+      if ( responseContainer && jQuery.isFunction( overwritten ) ) {\n+        overwritten( responseContainer[ 0 ] );\n+      }\n+\n+      responseContainer = overwritten = undefined;\n+    });\n+\n+    // Delegate to script\n+    return \"script\";\n+  }\n+});\n+\n+\n+\n+\n+// data: string of html\n+// context (optional): If specified, the fragment will be created in this context, defaults to document\n+// keepScripts (optional): If true, will include scripts passed in the html string\n+jQuery.parseHTML = function( data, context, keepScripts ) {\n+  if ( !data || typeof data !== \"string\" ) {\n+    return null;\n+  }\n+  if ( typeof context === \"boolean\" ) {\n+    keepScripts = context;\n+    context = false;\n+  }\n+  context = context || document;\n+\n+  var parsed = rsingleTag.exec( data ),\n+    scripts = !keepScripts && [];\n+\n+  // Single tag\n+  if ( parsed ) {\n+    return [ context.createElement( parsed[1] ) ];\n+  }\n+\n+  parsed = jQuery.buildFragment( [ data ], context, scripts );\n+\n+  if ( scripts && scripts.length ) {\n+    jQuery( scripts ).remove();\n+  }\n+\n+  return jQuery.merge( [], parsed.childNodes );\n+};\n+\n+\n+// Keep a copy of the old load method\n+var _load = jQuery.fn.load;\n+\n+/**\n+ * Load a url into a page\n+ */\n+jQuery.fn.load = function( url, params, callback ) {\n+  if ( typeof url !== \"string\" && _load ) {\n+    return _load.apply( this, arguments );\n+  }\n+\n+  var selector, type, response,\n+    self = this,\n+    off = url.indexOf(\" \");\n+\n+  if ( off >= 0 ) {\n+    selector = jQuery.trim( url.slice( off ) );\n+    url = url.slice( 0, off );\n+  }\n+\n+  // If it's a function\n+  if ( jQuery.isFunction( params ) ) {\n+\n+    // We assume that it's the callback\n+    callback = params;\n+    params = undefined;\n+\n+  // Otherwise, build a param string\n+  } else if ( params && typeof params === \"object\" ) {\n+    type = \"POST\";\n+  }\n+\n+  // If we have elements to modify, make the request\n+  if ( self.length > 0 ) {\n+    jQuery.ajax({\n+      url: url,\n+\n+      // if \"type\" variable is undefined, then \"GET\" method will be used\n+      type: type,\n+      dataType: \"html\",\n+      data: params\n+    }).done(function( responseText ) {\n+\n+      // Save response for use in complete callback\n+      response = arguments;\n+\n+      self.html( selector ?\n+\n+        // If a selector was specified, locate the right elements in a dummy div\n+        // Exclude scripts to avoid IE 'Permission Denied' errors\n+        jQuery(\"<div>\").append( jQuery.parseHTML( responseText ) ).find( selector ) :\n+\n+        // Otherwise use the full result\n+        responseText );\n+\n+    }).complete( callback && function( jqXHR, status ) {\n+      self.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );\n+    });\n+  }\n+\n+  return this;\n+};\n+\n+\n+\n+\n+jQuery.expr.filters.animated = function( elem ) {\n+  return jQuery.grep(jQuery.timers, function( fn ) {\n+    return elem === fn.elem;\n+  }).length;\n+};\n+\n+\n+\n+\n+var docElem = window.document.documentElement;\n+\n+/**\n+ * Gets a window from an element\n+ */\n+function getWindow( elem ) {\n+  return jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;\n+}\n+\n+jQuery.offset = {\n+  setOffset: function( elem, options, i ) {\n+    var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,\n+      position = jQuery.css( elem, \"position\" ),\n+      curElem = jQuery( elem ),\n+      props = {};\n+\n+    // Set position first, in-case top/left are set even on static elem\n+    if ( position === \"static\" ) {\n+      elem.style.position = \"relative\";\n+    }\n+\n+    curOffset = curElem.offset();\n+    curCSSTop = jQuery.css( elem, \"top\" );\n+    curCSSLeft = jQuery.css( elem, \"left\" );\n+    calculatePosition = ( position === \"absolute\" || position === \"fixed\" ) &&\n+      ( curCSSTop + curCSSLeft ).indexOf(\"auto\") > -1;\n+\n+    // Need to be able to calculate position if either top or left is auto and position is either absolute or fixed\n+    if ( calculatePosition ) {\n+      curPosition = curElem.position();\n+      curTop = curPosition.top;\n+      curLeft = curPosition.left;\n+\n+    } else {\n+      curTop = parseFloat( curCSSTop ) || 0;\n+      curLeft = parseFloat( curCSSLeft ) || 0;\n+    }\n+\n+    if ( jQuery.isFunction( options ) ) {\n+      options = options.call( elem, i, curOffset );\n+    }\n+\n+    if ( options.top != null ) {\n+      props.top = ( options.top - curOffset.top ) + curTop;\n+    }\n+    if ( options.left != null ) {\n+      props.left = ( options.left - curOffset.left ) + curLeft;\n+    }\n+\n+    if ( \"using\" in options ) {\n+      options.using.call( elem, props );\n+\n+    } else {\n+      curElem.css( props );\n+    }\n+  }\n+};\n+\n+jQuery.fn.extend({\n+  offset: function( options ) {\n+    if ( arguments.length ) {\n+      return options === undefined ?\n+        this :\n+        this.each(function( i ) {\n+          jQuery.offset.setOffset( this, options, i );\n+        });\n+    }\n+\n+    var docElem, win,\n+      elem = this[ 0 ],\n+      box = { top: 0, left: 0 },\n+      doc = elem && elem.ownerDocument;\n+\n+    if ( !doc ) {\n+      return;\n+    }\n+\n+    docElem = doc.documentElement;\n+\n+    // Make sure it's not a disconnected DOM node\n+    if ( !jQuery.contains( docElem, elem ) ) {\n+      return box;\n+    }\n+\n+    // If we don't have gBCR, just use 0,0 rather than error\n+    // BlackBerry 5, iOS 3 (original iPhone)\n+    if ( typeof elem.getBoundingClientRect !== strundefined ) {\n+      box = elem.getBoundingClientRect();\n+    }\n+    win = getWindow( doc );\n+    return {\n+      top: box.top + win.pageYOffset - docElem.clientTop,\n+      left: box.left + win.pageXOffset - docElem.clientLeft\n+    };\n+  },\n+\n+  position: function() {\n+    if ( !this[ 0 ] ) {\n+      return;\n+    }\n+\n+    var offsetParent, offset,\n+      elem = this[ 0 ],\n+      parentOffset = { top: 0, left: 0 };\n+\n+    // Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is its only offset parent\n+    if ( jQuery.css( elem, \"position\" ) === \"fixed\" ) {\n+      // We assume that getBoundingClientRect is available when computed position is fixed\n+      offset = elem.getBoundingClientRect();\n+\n+    } else {\n+      // Get *real* offsetParent\n+      offsetParent = this.offsetParent();\n+\n+      // Get correct offsets\n+      offset = this.offset();\n+      if ( !jQuery.nodeName( offsetParent[ 0 ], \"html\" ) ) {\n+        parentOffset = offsetParent.offset();\n+      }\n+\n+      // Add offsetParent borders\n+      parentOffset.top += jQuery.css( offsetParent[ 0 ], \"borderTopWidth\", true );\n+      parentOffset.left += jQuery.css( offsetParent[ 0 ], \"borderLeftWidth\", true );\n+    }\n+\n+    // Subtract parent offsets and element margins\n+    return {\n+      top: offset.top - parentOffset.top - jQuery.css( elem, \"marginTop\", true ),\n+      left: offset.left - parentOffset.left - jQuery.css( elem, \"marginLeft\", true )\n+    };\n+  },\n+\n+  offsetParent: function() {\n+    return this.map(function() {\n+      var offsetParent = this.offsetParent || docElem;\n+\n+      while ( offsetParent && ( !jQuery.nodeName( offsetParent, \"html\" ) && jQuery.css( offsetParent, \"position\" ) === \"static\" ) ) {\n+        offsetParent = offsetParent.offsetParent;\n+      }\n+\n+      return offsetParent || docElem;\n+    });\n+  }\n+});\n+\n+// Create scrollLeft and scrollTop methods\n+jQuery.each( { scrollLeft: \"pageXOffset\", scrollTop: \"pageYOffset\" }, function( method, prop ) {\n+  var top = \"pageYOffset\" === prop;\n+\n+  jQuery.fn[ method ] = function( val ) {\n+    return access( this, function( elem, method, val ) {\n+      var win = getWindow( elem );\n+\n+      if ( val === undefined ) {\n+        return win ? win[ prop ] : elem[ method ];\n+      }\n+\n+      if ( win ) {\n+        win.scrollTo(\n+          !top ? val : window.pageXOffset,\n+          top ? val : window.pageYOffset\n+        );\n+\n+      } else {\n+        elem[ method ] = val;\n+      }\n+    }, method, val, arguments.length, null );\n+  };\n+});\n+\n+// Add the top/left cssHooks using jQuery.fn.position\n+// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084\n+// getComputedStyle returns percent when specified for top/left/bottom/right\n+// rather than make the css module depend on the offset module, we just check for it here\n+jQuery.each( [ \"top\", \"left\" ], function( i, prop ) {\n+  jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,\n+    function( elem, computed ) {\n+      if ( computed ) {\n+        computed = curCSS( elem, prop );\n+        // if curCSS returns percentage, fallback to offset\n+        return rnumnonpx.test( computed ) ?\n+          jQuery( elem ).position()[ prop ] + \"px\" :\n+          computed;\n+      }\n+    }\n+  );\n+});\n+\n+\n+// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods\n+jQuery.each( { Height: \"height\", Width: \"width\" }, function( name, type ) {\n+  jQuery.each( { padding: \"inner\" + name, content: type, \"\": \"outer\" + name }, function( defaultExtra, funcName ) {\n+    // margin is only for outerHeight, outerWidth\n+    jQuery.fn[ funcName ] = function( margin, value ) {\n+      var chainable = arguments.length && ( defaultExtra || typeof margin !== \"boolean\" ),\n+        extra = defaultExtra || ( margin === true || value === true ? \"margin\" : \"border\" );\n+\n+      return access( this, function( elem, type, value ) {\n+        var doc;\n+\n+        if ( jQuery.isWindow( elem ) ) {\n+          // As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there\n+          // isn't a whole lot we can do. See pull request at this URL for discussion:\n+          // https://github.com/jquery/jquery/pull/764\n+          return elem.document.documentElement[ \"client\" + name ];\n+        }\n+\n+        // Get document width or height\n+        if ( elem.nodeType === 9 ) {\n+          doc = elem.documentElement;\n+\n+          // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],\n+          // whichever is greatest\n+          return Math.max(\n+            elem.body[ \"scroll\" + name ], doc[ \"scroll\" + name ],\n+            elem.body[ \"offset\" + name ], doc[ \"offset\" + name ],\n+            doc[ \"client\" + name ]\n+          );\n+        }\n+\n+        return value === undefined ?\n+          // Get width or height on the element, requesting but not forcing parseFloat\n+          jQuery.css( elem, type, extra ) :\n+\n+          // Set width or height on the element\n+          jQuery.style( elem, type, value, extra );\n+      }, type, chainable ? margin : undefined, chainable, null );\n+    };\n+  });\n+});\n+\n+\n+// The number of elements contained in the matched element set\n+jQuery.fn.size = function() {\n+  return this.length;\n+};\n+\n+jQuery.fn.andSelf = jQuery.fn.addBack;\n+\n+\n+\n+\n+// Register as a named AMD module, since jQuery can be concatenated with other\n+// files that may use define, but not via a proper concatenation script that\n+// understands anonymous AMD modules. A named AMD is safest and most robust\n+// way to register. Lowercase jquery is used because AMD module names are\n+// derived from file names, and jQuery is normally delivered in a lowercase\n+// file name. Do this after creating the global so that if an AMD module wants\n+// to call noConflict to hide this version of jQuery, it will work.\n+\n+// Note that for maximum portability, libraries that are not jQuery should\n+// declare themselves as anonymous modules, and avoid setting a global if an\n+// AMD loader is present. jQuery is a special case. For more information, see\n+// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon\n+\n+if ( typeof define === \"function\" && define.amd ) {\n+  define( \"jquery\", [], function() {\n+    return jQuery;\n+  });\n+}\n+\n+\n+\n+\n+var\n+  // Map over jQuery in case of overwrite\n+  _jQuery = window.jQuery,\n+\n+  // Map over the $ in case of overwrite\n+  _$ = window.$;\n+\n+jQuery.noConflict = function( deep ) {\n+  if ( window.$ === jQuery ) {\n+    window.$ = _$;\n+  }\n+\n+  if ( deep && window.jQuery === jQuery ) {\n+    window.jQuery = _jQuery;\n+  }\n+\n+  return jQuery;\n+};\n+\n+// Expose jQuery and $ identifiers, even in\n+// AMD (#7102#comment:10, https://github.com/jquery/jquery/pull/557)\n+// and CommonJS for browser emulators (#13566)\n+if ( typeof noGlobal === strundefined ) {\n+  window.jQuery = window.$ = jQuery;\n+}\n+\n+\n+\n+\n+return jQuery;\n+\n+}));\ndiff --git a/resources/libs/underscore.js b/resources/libs/underscore.js\nnew file mode 100644\nindex 0000000..9a4cabe\n--- /dev/null\n+++ b/resources/libs/underscore.js\n@@ -0,0 +1,1343 @@\n+//     Underscore.js 1.6.0\n+//     http://underscorejs.org\n+//     (c) 2009-2014 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n+//     Underscore may be freely distributed under the MIT license.\n+\n+(function() {\n+\n+  // Baseline setup\n+  // --------------\n+\n+  // Establish the root object, `window` in the browser, or `exports` on the server.\n+  var root = this;\n+\n+  // Save the previous value of the `_` variable.\n+  var previousUnderscore = root._;\n+\n+  // Establish the object that gets returned to break out of a loop iteration.\n+  var breaker = {};\n+\n+  // Save bytes in the minified (but not gzipped) version:\n+  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;\n+\n+  // Create quick reference variables for speed access to core prototypes.\n+  var\n+    push             = ArrayProto.push,\n+    slice            = ArrayProto.slice,\n+    concat           = ArrayProto.concat,\n+    toString         = ObjProto.toString,\n+    hasOwnProperty   = ObjProto.hasOwnProperty;\n+\n+  // All **ECMAScript 5** native function implementations that we hope to use\n+  // are declared here.\n+  var\n+    nativeForEach      = ArrayProto.forEach,\n+    nativeMap          = ArrayProto.map,\n+    nativeReduce       = ArrayProto.reduce,\n+    nativeReduceRight  = ArrayProto.reduceRight,\n+    nativeFilter       = ArrayProto.filter,\n+    nativeEvery        = ArrayProto.every,\n+    nativeSome         = ArrayProto.some,\n+    nativeIndexOf      = ArrayProto.indexOf,\n+    nativeLastIndexOf  = ArrayProto.lastIndexOf,\n+    nativeIsArray      = Array.isArray,\n+    nativeKeys         = Object.keys,\n+    nativeBind         = FuncProto.bind;\n+\n+  // Create a safe reference to the Underscore object for use below.\n+  var _ = function(obj) {\n+    if (obj instanceof _) return obj;\n+    if (!(this instanceof _)) return new _(obj);\n+    this._wrapped = obj;\n+  };\n+\n+  // Export the Underscore object for **Node.js**, with\n+  // backwards-compatibility for the old `require()` API. If we're in\n+  // the browser, add `_` as a global object via a string identifier,\n+  // for Closure Compiler \"advanced\" mode.\n+  if (typeof exports !== 'undefined') {\n+    if (typeof module !== 'undefined' && module.exports) {\n+      exports = module.exports = _;\n+    }\n+    exports._ = _;\n+  } else {\n+    root._ = _;\n+  }\n+\n+  // Current version.\n+  _.VERSION = '1.6.0';\n+\n+  // Collection Functions\n+  // --------------------\n+\n+  // The cornerstone, an `each` implementation, aka `forEach`.\n+  // Handles objects with the built-in `forEach`, arrays, and raw objects.\n+  // Delegates to **ECMAScript 5**'s native `forEach` if available.\n+  var each = _.each = _.forEach = function(obj, iterator, context) {\n+    if (obj == null) return obj;\n+    if (nativeForEach && obj.forEach === nativeForEach) {\n+      obj.forEach(iterator, context);\n+    } else if (obj.length === +obj.length) {\n+      for (var i = 0, length = obj.length; i < length; i++) {\n+        if (iterator.call(context, obj[i], i, obj) === breaker) return;\n+      }\n+    } else {\n+      var keys = _.keys(obj);\n+      for (var i = 0, length = keys.length; i < length; i++) {\n+        if (iterator.call(context, obj[keys[i]], keys[i], obj) === breaker) return;\n+      }\n+    }\n+    return obj;\n+  };\n+\n+  // Return the results of applying the iterator to each element.\n+  // Delegates to **ECMAScript 5**'s native `map` if available.\n+  _.map = _.collect = function(obj, iterator, context) {\n+    var results = [];\n+    if (obj == null) return results;\n+    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);\n+    each(obj, function(value, index, list) {\n+      results.push(iterator.call(context, value, index, list));\n+    });\n+    return results;\n+  };\n+\n+  var reduceError = 'Reduce of empty array with no initial value';\n+\n+  // **Reduce** builds up a single result from a list of values, aka `inject`,\n+  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.\n+  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {\n+    var initial = arguments.length > 2;\n+    if (obj == null) obj = [];\n+    if (nativeReduce && obj.reduce === nativeReduce) {\n+      if (context) iterator = _.bind(iterator, context);\n+      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);\n+    }\n+    each(obj, function(value, index, list) {\n+      if (!initial) {\n+        memo = value;\n+        initial = true;\n+      } else {\n+        memo = iterator.call(context, memo, value, index, list);\n+      }\n+    });\n+    if (!initial) throw new TypeError(reduceError);\n+    return memo;\n+  };\n+\n+  // The right-associative version of reduce, also known as `foldr`.\n+  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.\n+  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {\n+    var initial = arguments.length > 2;\n+    if (obj == null) obj = [];\n+    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {\n+      if (context) iterator = _.bind(iterator, context);\n+      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);\n+    }\n+    var length = obj.length;\n+    if (length !== +length) {\n+      var keys = _.keys(obj);\n+      length = keys.length;\n+    }\n+    each(obj, function(value, index, list) {\n+      index = keys ? keys[--length] : --length;\n+      if (!initial) {\n+        memo = obj[index];\n+        initial = true;\n+      } else {\n+        memo = iterator.call(context, memo, obj[index], index, list);\n+      }\n+    });\n+    if (!initial) throw new TypeError(reduceError);\n+    return memo;\n+  };\n+\n+  // Return the first value which passes a truth test. Aliased as `detect`.\n+  _.find = _.detect = function(obj, predicate, context) {\n+    var result;\n+    any(obj, function(value, index, list) {\n+      if (predicate.call(context, value, index, list)) {\n+        result = value;\n+        return true;\n+      }\n+    });\n+    return result;\n+  };\n+\n+  // Return all the elements that pass a truth test.\n+  // Delegates to **ECMAScript 5**'s native `filter` if available.\n+  // Aliased as `select`.\n+  _.filter = _.select = function(obj, predicate, context) {\n+    var results = [];\n+    if (obj == null) return results;\n+    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(predicate, context);\n+    each(obj, function(value, index, list) {\n+      if (predicate.call(context, value, index, list)) results.push(value);\n+    });\n+    return results;\n+  };\n+\n+  // Return all the elements for which a truth test fails.\n+  _.reject = function(obj, predicate, context) {\n+    return _.filter(obj, function(value, index, list) {\n+      return !predicate.call(context, value, index, list);\n+    }, context);\n+  };\n+\n+  // Determine whether all of the elements match a truth test.\n+  // Delegates to **ECMAScript 5**'s native `every` if available.\n+  // Aliased as `all`.\n+  _.every = _.all = function(obj, predicate, context) {\n+    predicate || (predicate = _.identity);\n+    var result = true;\n+    if (obj == null) return result;\n+    if (nativeEvery && obj.every === nativeEvery) return obj.every(predicate, context);\n+    each(obj, function(value, index, list) {\n+      if (!(result = result && predicate.call(context, value, index, list))) return breaker;\n+    });\n+    return !!result;\n+  };\n+\n+  // Determine if at least one element in the object matches a truth test.\n+  // Delegates to **ECMAScript 5**'s native `some` if available.\n+  // Aliased as `any`.\n+  var any = _.some = _.any = function(obj, predicate, context) {\n+    predicate || (predicate = _.identity);\n+    var result = false;\n+    if (obj == null) return result;\n+    if (nativeSome && obj.some === nativeSome) return obj.some(predicate, context);\n+    each(obj, function(value, index, list) {\n+      if (result || (result = predicate.call(context, value, index, list))) return breaker;\n+    });\n+    return !!result;\n+  };\n+\n+  // Determine if the array or object contains a given value (using `===`).\n+  // Aliased as `include`.\n+  _.contains = _.include = function(obj, target) {\n+    if (obj == null) return false;\n+    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;\n+    return any(obj, function(value) {\n+      return value === target;\n+    });\n+  };\n+\n+  // Invoke a method (with arguments) on every item in a collection.\n+  _.invoke = function(obj, method) {\n+    var args = slice.call(arguments, 2);\n+    var isFunc = _.isFunction(method);\n+    return _.map(obj, function(value) {\n+      return (isFunc ? method : value[method]).apply(value, args);\n+    });\n+  };\n+\n+  // Convenience version of a common use case of `map`: fetching a property.\n+  _.pluck = function(obj, key) {\n+    return _.map(obj, _.property(key));\n+  };\n+\n+  // Convenience version of a common use case of `filter`: selecting only objects\n+  // containing specific `key:value` pairs.\n+  _.where = function(obj, attrs) {\n+    return _.filter(obj, _.matches(attrs));\n+  };\n+\n+  // Convenience version of a common use case of `find`: getting the first object\n+  // containing specific `key:value` pairs.\n+  _.findWhere = function(obj, attrs) {\n+    return _.find(obj, _.matches(attrs));\n+  };\n+\n+  // Return the maximum element or (element-based computation).\n+  // Can't optimize arrays of integers longer than 65,535 elements.\n+  // See [WebKit Bug 80797](https://bugs.webkit.org/show_bug.cgi?id=80797)\n+  _.max = function(obj, iterator, context) {\n+    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {\n+      return Math.max.apply(Math, obj);\n+    }\n+    var result = -Infinity, lastComputed = -Infinity;\n+    each(obj, function(value, index, list) {\n+      var computed = iterator ? iterator.call(context, value, index, list) : value;\n+      if (computed > lastComputed) {\n+        result = value;\n+        lastComputed = computed;\n+      }\n+    });\n+    return result;\n+  };\n+\n+  // Return the minimum element (or element-based computation).\n+  _.min = function(obj, iterator, context) {\n+    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {\n+      return Math.min.apply(Math, obj);\n+    }\n+    var result = Infinity, lastComputed = Infinity;\n+    each(obj, function(value, index, list) {\n+      var computed = iterator ? iterator.call(context, value, index, list) : value;\n+      if (computed < lastComputed) {\n+        result = value;\n+        lastComputed = computed;\n+      }\n+    });\n+    return result;\n+  };\n+\n+  // Shuffle an array, using the modern version of the\n+  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisherâ€“Yates_shuffle).\n+  _.shuffle = function(obj) {\n+    var rand;\n+    var index = 0;\n+    var shuffled = [];\n+    each(obj, function(value) {\n+      rand = _.random(index++);\n+      shuffled[index - 1] = shuffled[rand];\n+      shuffled[rand] = value;\n+    });\n+    return shuffled;\n+  };\n+\n+  // Sample **n** random values from a collection.\n+  // If **n** is not specified, returns a single random element.\n+  // The internal `guard` argument allows it to work with `map`.\n+  _.sample = function(obj, n, guard) {\n+    if (n == null || guard) {\n+      if (obj.length !== +obj.length) obj = _.values(obj);\n+      return obj[_.random(obj.length - 1)];\n+    }\n+    return _.shuffle(obj).slice(0, Math.max(0, n));\n+  };\n+\n+  // An internal function to generate lookup iterators.\n+  var lookupIterator = function(value) {\n+    if (value == null) return _.identity;\n+    if (_.isFunction(value)) return value;\n+    return _.property(value);\n+  };\n+\n+  // Sort the object's values by a criterion produced by an iterator.\n+  _.sortBy = function(obj, iterator, context) {\n+    iterator = lookupIterator(iterator);\n+    return _.pluck(_.map(obj, function(value, index, list) {\n+      return {\n+        value: value,\n+        index: index,\n+        criteria: iterator.call(context, value, index, list)\n+      };\n+    }).sort(function(left, right) {\n+      var a = left.criteria;\n+      var b = right.criteria;\n+      if (a !== b) {\n+        if (a > b || a === void 0) return 1;\n+        if (a < b || b === void 0) return -1;\n+      }\n+      return left.index - right.index;\n+    }), 'value');\n+  };\n+\n+  // An internal function used for aggregate \"group by\" operations.\n+  var group = function(behavior) {\n+    return function(obj, iterator, context) {\n+      var result = {};\n+      iterator = lookupIterator(iterator);\n+      each(obj, function(value, index) {\n+        var key = iterator.call(context, value, index, obj);\n+        behavior(result, key, value);\n+      });\n+      return result;\n+    };\n+  };\n+\n+  // Groups the object's values by a criterion. Pass either a string attribute\n+  // to group by, or a function that returns the criterion.\n+  _.groupBy = group(function(result, key, value) {\n+    _.has(result, key) ? result[key].push(value) : result[key] = [value];\n+  });\n+\n+  // Indexes the object's values by a criterion, similar to `groupBy`, but for\n+  // when you know that your index values will be unique.\n+  _.indexBy = group(function(result, key, value) {\n+    result[key] = value;\n+  });\n+\n+  // Counts instances of an object that group by a certain criterion. Pass\n+  // either a string attribute to count by, or a function that returns the\n+  // criterion.\n+  _.countBy = group(function(result, key) {\n+    _.has(result, key) ? result[key]++ : result[key] = 1;\n+  });\n+\n+  // Use a comparator function to figure out the smallest index at which\n+  // an object should be inserted so as to maintain order. Uses binary search.\n+  _.sortedIndex = function(array, obj, iterator, context) {\n+    iterator = lookupIterator(iterator);\n+    var value = iterator.call(context, obj);\n+    var low = 0, high = array.length;\n+    while (low < high) {\n+      var mid = (low + high) >>> 1;\n+      iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;\n+    }\n+    return low;\n+  };\n+\n+  // Safely create a real, live array from anything iterable.\n+  _.toArray = function(obj) {\n+    if (!obj) return [];\n+    if (_.isArray(obj)) return slice.call(obj);\n+    if (obj.length === +obj.length) return _.map(obj, _.identity);\n+    return _.values(obj);\n+  };\n+\n+  // Return the number of elements in an object.\n+  _.size = function(obj) {\n+    if (obj == null) return 0;\n+    return (obj.length === +obj.length) ? obj.length : _.keys(obj).length;\n+  };\n+\n+  // Array Functions\n+  // ---------------\n+\n+  // Get the first element of an array. Passing **n** will return the first N\n+  // values in the array. Aliased as `head` and `take`. The **guard** check\n+  // allows it to work with `_.map`.\n+  _.first = _.head = _.take = function(array, n, guard) {\n+    if (array == null) return void 0;\n+    if ((n == null) || guard) return array[0];\n+    if (n < 0) return [];\n+    return slice.call(array, 0, n);\n+  };\n+\n+  // Returns everything but the last entry of the array. Especially useful on\n+  // the arguments object. Passing **n** will return all the values in\n+  // the array, excluding the last N. The **guard** check allows it to work with\n+  // `_.map`.\n+  _.initial = function(array, n, guard) {\n+    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));\n+  };\n+\n+  // Get the last element of an array. Passing **n** will return the last N\n+  // values in the array. The **guard** check allows it to work with `_.map`.\n+  _.last = function(array, n, guard) {\n+    if (array == null) return void 0;\n+    if ((n == null) || guard) return array[array.length - 1];\n+    return slice.call(array, Math.max(array.length - n, 0));\n+  };\n+\n+  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.\n+  // Especially useful on the arguments object. Passing an **n** will return\n+  // the rest N values in the array. The **guard**\n+  // check allows it to work with `_.map`.\n+  _.rest = _.tail = _.drop = function(array, n, guard) {\n+    return slice.call(array, (n == null) || guard ? 1 : n);\n+  };\n+\n+  // Trim out all falsy values from an array.\n+  _.compact = function(array) {\n+    return _.filter(array, _.identity);\n+  };\n+\n+  // Internal implementation of a recursive `flatten` function.\n+  var flatten = function(input, shallow, output) {\n+    if (shallow && _.every(input, _.isArray)) {\n+      return concat.apply(output, input);\n+    }\n+    each(input, function(value) {\n+      if (_.isArray(value) || _.isArguments(value)) {\n+        shallow ? push.apply(output, value) : flatten(value, shallow, output);\n+      } else {\n+        output.push(value);\n+      }\n+    });\n+    return output;\n+  };\n+\n+  // Flatten out an array, either recursively (by default), or just one level.\n+  _.flatten = function(array, shallow) {\n+    return flatten(array, shallow, []);\n+  };\n+\n+  // Return a version of the array that does not contain the specified value(s).\n+  _.without = function(array) {\n+    return _.difference(array, slice.call(arguments, 1));\n+  };\n+\n+  // Split an array into two arrays: one whose elements all satisfy the given\n+  // predicate, and one whose elements all do not satisfy the predicate.\n+  _.partition = function(array, predicate) {\n+    var pass = [], fail = [];\n+    each(array, function(elem) {\n+      (predicate(elem) ? pass : fail).push(elem);\n+    });\n+    return [pass, fail];\n+  };\n+\n+  // Produce a duplicate-free version of the array. If the array has already\n+  // been sorted, you have the option of using a faster algorithm.\n+  // Aliased as `unique`.\n+  _.uniq = _.unique = function(array, isSorted, iterator, context) {\n+    if (_.isFunction(isSorted)) {\n+      context = iterator;\n+      iterator = isSorted;\n+      isSorted = false;\n+    }\n+    var initial = iterator ? _.map(array, iterator, context) : array;\n+    var results = [];\n+    var seen = [];\n+    each(initial, function(value, index) {\n+      if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {\n+        seen.push(value);\n+        results.push(array[index]);\n+      }\n+    });\n+    return results;\n+  };\n+\n+  // Produce an array that contains the union: each distinct element from all of\n+  // the passed-in arrays.\n+  _.union = function() {\n+    return _.uniq(_.flatten(arguments, true));\n+  };\n+\n+  // Produce an array that contains every item shared between all the\n+  // passed-in arrays.\n+  _.intersection = function(array) {\n+    var rest = slice.call(arguments, 1);\n+    return _.filter(_.uniq(array), function(item) {\n+      return _.every(rest, function(other) {\n+        return _.contains(other, item);\n+      });\n+    });\n+  };\n+\n+  // Take the difference between one array and a number of other arrays.\n+  // Only the elements present in just the first array will remain.\n+  _.difference = function(array) {\n+    var rest = concat.apply(ArrayProto, slice.call(arguments, 1));\n+    return _.filter(array, function(value){ return !_.contains(rest, value); });\n+  };\n+\n+  // Zip together multiple lists into a single array -- elements that share\n+  // an index go together.\n+  _.zip = function() {\n+    var length = _.max(_.pluck(arguments, 'length').concat(0));\n+    var results = new Array(length);\n+    for (var i = 0; i < length; i++) {\n+      results[i] = _.pluck(arguments, '' + i);\n+    }\n+    return results;\n+  };\n+\n+  // Converts lists into objects. Pass either a single array of `[key, value]`\n+  // pairs, or two parallel arrays of the same length -- one of keys, and one of\n+  // the corresponding values.\n+  _.object = function(list, values) {\n+    if (list == null) return {};\n+    var result = {};\n+    for (var i = 0, length = list.length; i < length; i++) {\n+      if (values) {\n+        result[list[i]] = values[i];\n+      } else {\n+        result[list[i][0]] = list[i][1];\n+      }\n+    }\n+    return result;\n+  };\n+\n+  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),\n+  // we need this function. Return the position of the first occurrence of an\n+  // item in an array, or -1 if the item is not included in the array.\n+  // Delegates to **ECMAScript 5**'s native `indexOf` if available.\n+  // If the array is large and already in sort order, pass `true`\n+  // for **isSorted** to use binary search.\n+  _.indexOf = function(array, item, isSorted) {\n+    if (array == null) return -1;\n+    var i = 0, length = array.length;\n+    if (isSorted) {\n+      if (typeof isSorted == 'number') {\n+        i = (isSorted < 0 ? Math.max(0, length + isSorted) : isSorted);\n+      } else {\n+        i = _.sortedIndex(array, item);\n+        return array[i] === item ? i : -1;\n+      }\n+    }\n+    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);\n+    for (; i < length; i++) if (array[i] === item) return i;\n+    return -1;\n+  };\n+\n+  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.\n+  _.lastIndexOf = function(array, item, from) {\n+    if (array == null) return -1;\n+    var hasIndex = from != null;\n+    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {\n+      return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);\n+    }\n+    var i = (hasIndex ? from : array.length);\n+    while (i--) if (array[i] === item) return i;\n+    return -1;\n+  };\n+\n+  // Generate an integer Array containing an arithmetic progression. A port of\n+  // the native Python `range()` function. See\n+  // [the Python documentation](http://docs.python.org/library/functions.html#range).\n+  _.range = function(start, stop, step) {\n+    if (arguments.length <= 1) {\n+      stop = start || 0;\n+      start = 0;\n+    }\n+    step = arguments[2] || 1;\n+\n+    var length = Math.max(Math.ceil((stop - start) / step), 0);\n+    var idx = 0;\n+    var range = new Array(length);\n+\n+    while(idx < length) {\n+      range[idx++] = start;\n+      start += step;\n+    }\n+\n+    return range;\n+  };\n+\n+  // Function (ahem) Functions\n+  // ------------------\n+\n+  // Reusable constructor function for prototype setting.\n+  var ctor = function(){};\n+\n+  // Create a function bound to a given object (assigning `this`, and arguments,\n+  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if\n+  // available.\n+  _.bind = function(func, context) {\n+    var args, bound;\n+    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));\n+    if (!_.isFunction(func)) throw new TypeError;\n+    args = slice.call(arguments, 2);\n+    return bound = function() {\n+      if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));\n+      ctor.prototype = func.prototype;\n+      var self = new ctor;\n+      ctor.prototype = null;\n+      var result = func.apply(self, args.concat(slice.call(arguments)));\n+      if (Object(result) === result) return result;\n+      return self;\n+    };\n+  };\n+\n+  // Partially apply a function by creating a version that has had some of its\n+  // arguments pre-filled, without changing its dynamic `this` context. _ acts\n+  // as a placeholder, allowing any combination of arguments to be pre-filled.\n+  _.partial = function(func) {\n+    var boundArgs = slice.call(arguments, 1);\n+    return function() {\n+      var position = 0;\n+      var args = boundArgs.slice();\n+      for (var i = 0, length = args.length; i < length; i++) {\n+        if (args[i] === _) args[i] = arguments[position++];\n+      }\n+      while (position < arguments.length) args.push(arguments[position++]);\n+      return func.apply(this, args);\n+    };\n+  };\n+\n+  // Bind a number of an object's methods to that object. Remaining arguments\n+  // are the method names to be bound. Useful for ensuring that all callbacks\n+  // defined on an object belong to it.\n+  _.bindAll = function(obj) {\n+    var funcs = slice.call(arguments, 1);\n+    if (funcs.length === 0) throw new Error('bindAll must be passed function names');\n+    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });\n+    return obj;\n+  };\n+\n+  // Memoize an expensive function by storing its results.\n+  _.memoize = function(func, hasher) {\n+    var memo = {};\n+    hasher || (hasher = _.identity);\n+    return function() {\n+      var key = hasher.apply(this, arguments);\n+      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));\n+    };\n+  };\n+\n+  // Delays a function for the given number of milliseconds, and then calls\n+  // it with the arguments supplied.\n+  _.delay = function(func, wait) {\n+    var args = slice.call(arguments, 2);\n+    return setTimeout(function(){ return func.apply(null, args); }, wait);\n+  };\n+\n+  // Defers a function, scheduling it to run after the current call stack has\n+  // cleared.\n+  _.defer = function(func) {\n+    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));\n+  };\n+\n+  // Returns a function, that, when invoked, will only be triggered at most once\n+  // during a given window of time. Normally, the throttled function will run\n+  // as much as it can, without ever going more than once per `wait` duration;\n+  // but if you'd like to disable the execution on the leading edge, pass\n+  // `{leading: false}`. To disable execution on the trailing edge, ditto.\n+  _.throttle = function(func, wait, options) {\n+    var context, args, result;\n+    var timeout = null;\n+    var previous = 0;\n+    options || (options = {});\n+    var later = function() {\n+      previous = options.leading === false ? 0 : _.now();\n+      timeout = null;\n+      result = func.apply(context, args);\n+      context = args = null;\n+    };\n+    return function() {\n+      var now = _.now();\n+      if (!previous && options.leading === false) previous = now;\n+      var remaining = wait - (now - previous);\n+      context = this;\n+      args = arguments;\n+      if (remaining <= 0) {\n+        clearTimeout(timeout);\n+        timeout = null;\n+        previous = now;\n+        result = func.apply(context, args);\n+        context = args = null;\n+      } else if (!timeout && options.trailing !== false) {\n+        timeout = setTimeout(later, remaining);\n+      }\n+      return result;\n+    };\n+  };\n+\n+  // Returns a function, that, as long as it continues to be invoked, will not\n+  // be triggered. The function will be called after it stops being called for\n+  // N milliseconds. If `immediate` is passed, trigger the function on the\n+  // leading edge, instead of the trailing.\n+  _.debounce = function(func, wait, immediate) {\n+    var timeout, args, context, timestamp, result;\n+\n+    var later = function() {\n+      var last = _.now() - timestamp;\n+      if (last < wait) {\n+        timeout = setTimeout(later, wait - last);\n+      } else {\n+        timeout = null;\n+        if (!immediate) {\n+          result = func.apply(context, args);\n+          context = args = null;\n+        }\n+      }\n+    };\n+\n+    return function() {\n+      context = this;\n+      args = arguments;\n+      timestamp = _.now();\n+      var callNow = immediate && !timeout;\n+      if (!timeout) {\n+        timeout = setTimeout(later, wait);\n+      }\n+      if (callNow) {\n+        result = func.apply(context, args);\n+        context = args = null;\n+      }\n+\n+      return result;\n+    };\n+  };\n+\n+  // Returns a function that will be executed at most one time, no matter how\n+  // often you call it. Useful for lazy initialization.\n+  _.once = function(func) {\n+    var ran = false, memo;\n+    return function() {\n+      if (ran) return memo;\n+      ran = true;\n+      memo = func.apply(this, arguments);\n+      func = null;\n+      return memo;\n+    };\n+  };\n+\n+  // Returns the first function passed as an argument to the second,\n+  // allowing you to adjust arguments, run code before and after, and\n+  // conditionally execute the original function.\n+  _.wrap = function(func, wrapper) {\n+    return _.partial(wrapper, func);\n+  };\n+\n+  // Returns a function that is the composition of a list of functions, each\n+  // consuming the return value of the function that follows.\n+  _.compose = function() {\n+    var funcs = arguments;\n+    return function() {\n+      var args = arguments;\n+      for (var i = funcs.length - 1; i >= 0; i--) {\n+        args = [funcs[i].apply(this, args)];\n+      }\n+      return args[0];\n+    };\n+  };\n+\n+  // Returns a function that will only be executed after being called N times.\n+  _.after = function(times, func) {\n+    return function() {\n+      if (--times < 1) {\n+        return func.apply(this, arguments);\n+      }\n+    };\n+  };\n+\n+  // Object Functions\n+  // ----------------\n+\n+  // Retrieve the names of an object's properties.\n+  // Delegates to **ECMAScript 5**'s native `Object.keys`\n+  _.keys = function(obj) {\n+    if (!_.isObject(obj)) return [];\n+    if (nativeKeys) return nativeKeys(obj);\n+    var keys = [];\n+    for (var key in obj) if (_.has(obj, key)) keys.push(key);\n+    return keys;\n+  };\n+\n+  // Retrieve the values of an object's properties.\n+  _.values = function(obj) {\n+    var keys = _.keys(obj);\n+    var length = keys.length;\n+    var values = new Array(length);\n+    for (var i = 0; i < length; i++) {\n+      values[i] = obj[keys[i]];\n+    }\n+    return values;\n+  };\n+\n+  // Convert an object into a list of `[key, value]` pairs.\n+  _.pairs = function(obj) {\n+    var keys = _.keys(obj);\n+    var length = keys.length;\n+    var pairs = new Array(length);\n+    for (var i = 0; i < length; i++) {\n+      pairs[i] = [keys[i], obj[keys[i]]];\n+    }\n+    return pairs;\n+  };\n+\n+  // Invert the keys and values of an object. The values must be serializable.\n+  _.invert = function(obj) {\n+    var result = {};\n+    var keys = _.keys(obj);\n+    for (var i = 0, length = keys.length; i < length; i++) {\n+      result[obj[keys[i]]] = keys[i];\n+    }\n+    return result;\n+  };\n+\n+  // Return a sorted list of the function names available on the object.\n+  // Aliased as `methods`\n+  _.functions = _.methods = function(obj) {\n+    var names = [];\n+    for (var key in obj) {\n+      if (_.isFunction(obj[key])) names.push(key);\n+    }\n+    return names.sort();\n+  };\n+\n+  // Extend a given object with all the properties in passed-in object(s).\n+  _.extend = function(obj) {\n+    each(slice.call(arguments, 1), function(source) {\n+      if (source) {\n+        for (var prop in source) {\n+          obj[prop] = source[prop];\n+        }\n+      }\n+    });\n+    return obj;\n+  };\n+\n+  // Return a copy of the object only containing the whitelisted properties.\n+  _.pick = function(obj) {\n+    var copy = {};\n+    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));\n+    each(keys, function(key) {\n+      if (key in obj) copy[key] = obj[key];\n+    });\n+    return copy;\n+  };\n+\n+   // Return a copy of the object without the blacklisted properties.\n+  _.omit = function(obj) {\n+    var copy = {};\n+    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));\n+    for (var key in obj) {\n+      if (!_.contains(keys, key)) copy[key] = obj[key];\n+    }\n+    return copy;\n+  };\n+\n+  // Fill in a given object with default properties.\n+  _.defaults = function(obj) {\n+    each(slice.call(arguments, 1), function(source) {\n+      if (source) {\n+        for (var prop in source) {\n+          if (obj[prop] === void 0) obj[prop] = source[prop];\n+        }\n+      }\n+    });\n+    return obj;\n+  };\n+\n+  // Create a (shallow-cloned) duplicate of an object.\n+  _.clone = function(obj) {\n+    if (!_.isObject(obj)) return obj;\n+    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);\n+  };\n+\n+  // Invokes interceptor with the obj, and then returns obj.\n+  // The primary purpose of this method is to \"tap into\" a method chain, in\n+  // order to perform operations on intermediate results within the chain.\n+  _.tap = function(obj, interceptor) {\n+    interceptor(obj);\n+    return obj;\n+  };\n+\n+  // Internal recursive comparison function for `isEqual`.\n+  var eq = function(a, b, aStack, bStack) {\n+    // Identical objects are equal. `0 === -0`, but they aren't identical.\n+    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).\n+    if (a === b) return a !== 0 || 1 / a == 1 / b;\n+    // A strict comparison is necessary because `null == undefined`.\n+    if (a == null || b == null) return a === b;\n+    // Unwrap any wrapped objects.\n+    if (a instanceof _) a = a._wrapped;\n+    if (b instanceof _) b = b._wrapped;\n+    // Compare `[[Class]]` names.\n+    var className = toString.call(a);\n+    if (className != toString.call(b)) return false;\n+    switch (className) {\n+      // Strings, numbers, dates, and booleans are compared by value.\n+      case '[object String]':\n+        // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n+        // equivalent to `new String(\"5\")`.\n+        return a == String(b);\n+      case '[object Number]':\n+        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for\n+        // other numeric values.\n+        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);\n+      case '[object Date]':\n+      case '[object Boolean]':\n+        // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n+        // millisecond representations. Note that invalid dates with millisecond representations\n+        // of `NaN` are not equivalent.\n+        return +a == +b;\n+      // RegExps are compared by their source patterns and flags.\n+      case '[object RegExp]':\n+        return a.source == b.source &&\n+               a.global == b.global &&\n+               a.multiline == b.multiline &&\n+               a.ignoreCase == b.ignoreCase;\n+    }\n+    if (typeof a != 'object' || typeof b != 'object') return false;\n+    // Assume equality for cyclic structures. The algorithm for detecting cyclic\n+    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n+    var length = aStack.length;\n+    while (length--) {\n+      // Linear search. Performance is inversely proportional to the number of\n+      // unique nested structures.\n+      if (aStack[length] == a) return bStack[length] == b;\n+    }\n+    // Objects with different constructors are not equivalent, but `Object`s\n+    // from different frames are.\n+    var aCtor = a.constructor, bCtor = b.constructor;\n+    if (aCtor !== bCtor && !(_.isFunction(aCtor) && (aCtor instanceof aCtor) &&\n+                             _.isFunction(bCtor) && (bCtor instanceof bCtor))\n+                        && ('constructor' in a && 'constructor' in b)) {\n+      return false;\n+    }\n+    // Add the first object to the stack of traversed objects.\n+    aStack.push(a);\n+    bStack.push(b);\n+    var size = 0, result = true;\n+    // Recursively compare objects and arrays.\n+    if (className == '[object Array]') {\n+      // Compare array lengths to determine if a deep comparison is necessary.\n+      size = a.length;\n+      result = size == b.length;\n+      if (result) {\n+        // Deep compare the contents, ignoring non-numeric properties.\n+        while (size--) {\n+          if (!(result = eq(a[size], b[size], aStack, bStack))) break;\n+        }\n+      }\n+    } else {\n+      // Deep compare objects.\n+      for (var key in a) {\n+        if (_.has(a, key)) {\n+          // Count the expected number of properties.\n+          size++;\n+          // Deep compare each member.\n+          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;\n+        }\n+      }\n+      // Ensure that both objects contain the same number of properties.\n+      if (result) {\n+        for (key in b) {\n+          if (_.has(b, key) && !(size--)) break;\n+        }\n+        result = !size;\n+      }\n+    }\n+    // Remove the first object from the stack of traversed objects.\n+    aStack.pop();\n+    bStack.pop();\n+    return result;\n+  };\n+\n+  // Perform a deep comparison to check if two objects are equal.\n+  _.isEqual = function(a, b) {\n+    return eq(a, b, [], []);\n+  };\n+\n+  // Is a given array, string, or object empty?\n+  // An \"empty\" object has no enumerable own-properties.\n+  _.isEmpty = function(obj) {\n+    if (obj == null) return true;\n+    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;\n+    for (var key in obj) if (_.has(obj, key)) return false;\n+    return true;\n+  };\n+\n+  // Is a given value a DOM element?\n+  _.isElement = function(obj) {\n+    return !!(obj && obj.nodeType === 1);\n+  };\n+\n+  // Is a given value an array?\n+  // Delegates to ECMA5's native Array.isArray\n+  _.isArray = nativeIsArray || function(obj) {\n+    return toString.call(obj) == '[object Array]';\n+  };\n+\n+  // Is a given variable an object?\n+  _.isObject = function(obj) {\n+    return obj === Object(obj);\n+  };\n+\n+  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.\n+  each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {\n+    _['is' + name] = function(obj) {\n+      return toString.call(obj) == '[object ' + name + ']';\n+    };\n+  });\n+\n+  // Define a fallback version of the method in browsers (ahem, IE), where\n+  // there isn't any inspectable \"Arguments\" type.\n+  if (!_.isArguments(arguments)) {\n+    _.isArguments = function(obj) {\n+      return !!(obj && _.has(obj, 'callee'));\n+    };\n+  }\n+\n+  // Optimize `isFunction` if appropriate.\n+  if (typeof (/./) !== 'function') {\n+    _.isFunction = function(obj) {\n+      return typeof obj === 'function';\n+    };\n+  }\n+\n+  // Is a given object a finite number?\n+  _.isFinite = function(obj) {\n+    return isFinite(obj) && !isNaN(parseFloat(obj));\n+  };\n+\n+  // Is the given value `NaN`? (NaN is the only number which does not equal itself).\n+  _.isNaN = function(obj) {\n+    return _.isNumber(obj) && obj != +obj;\n+  };\n+\n+  // Is a given value a boolean?\n+  _.isBoolean = function(obj) {\n+    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';\n+  };\n+\n+  // Is a given value equal to null?\n+  _.isNull = function(obj) {\n+    return obj === null;\n+  };\n+\n+  // Is a given variable undefined?\n+  _.isUndefined = function(obj) {\n+    return obj === void 0;\n+  };\n+\n+  // Shortcut function for checking if an object has a given property directly\n+  // on itself (in other words, not on a prototype).\n+  _.has = function(obj, key) {\n+    return hasOwnProperty.call(obj, key);\n+  };\n+\n+  // Utility Functions\n+  // -----------------\n+\n+  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its\n+  // previous owner. Returns a reference to the Underscore object.\n+  _.noConflict = function() {\n+    root._ = previousUnderscore;\n+    return this;\n+  };\n+\n+  // Keep the identity function around for default iterators.\n+  _.identity = function(value) {\n+    return value;\n+  };\n+\n+  _.constant = function(value) {\n+    return function () {\n+      return value;\n+    };\n+  };\n+\n+  _.property = function(key) {\n+    return function(obj) {\n+      return obj[key];\n+    };\n+  };\n+\n+  // Returns a predicate for checking whether an object has a given set of `key:value` pairs.\n+  _.matches = function(attrs) {\n+    return function(obj) {\n+      if (obj === attrs) return true; //avoid comparing an object to itself.\n+      for (var key in attrs) {\n+        if (attrs[key] !== obj[key])\n+          return false;\n+      }\n+      return true;\n+    }\n+  };\n+\n+  // Run a function **n** times.\n+  _.times = function(n, iterator, context) {\n+    var accum = Array(Math.max(0, n));\n+    for (var i = 0; i < n; i++) accum[i] = iterator.call(context, i);\n+    return accum;\n+  };\n+\n+  // Return a random integer between min and max (inclusive).\n+  _.random = function(min, max) {\n+    if (max == null) {\n+      max = min;\n+      min = 0;\n+    }\n+    return min + Math.floor(Math.random() * (max - min + 1));\n+  };\n+\n+  // A (possibly faster) way to get the current timestamp as an integer.\n+  _.now = Date.now || function() { return new Date().getTime(); };\n+\n+  // List of HTML entities for escaping.\n+  var entityMap = {\n+    escape: {\n+      '&': '&amp;',\n+      '<': '&lt;',\n+      '>': '&gt;',\n+      '\"': '&quot;',\n+      \"'\": '&#x27;'\n+    }\n+  };\n+  entityMap.unescape = _.invert(entityMap.escape);\n+\n+  // Regexes containing the keys and values listed immediately above.\n+  var entityRegexes = {\n+    escape:   new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),\n+    unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')\n+  };\n+\n+  // Functions for escaping and unescaping strings to/from HTML interpolation.\n+  _.each(['escape', 'unescape'], function(method) {\n+    _[method] = function(string) {\n+      if (string == null) return '';\n+      return ('' + string).replace(entityRegexes[method], function(match) {\n+        return entityMap[method][match];\n+      });\n+    };\n+  });\n+\n+  // If the value of the named `property` is a function then invoke it with the\n+  // `object` as context; otherwise, return it.\n+  _.result = function(object, property) {\n+    if (object == null) return void 0;\n+    var value = object[property];\n+    return _.isFunction(value) ? value.call(object) : value;\n+  };\n+\n+  // Add your own custom functions to the Underscore object.\n+  _.mixin = function(obj) {\n+    each(_.functions(obj), function(name) {\n+      var func = _[name] = obj[name];\n+      _.prototype[name] = function() {\n+        var args = [this._wrapped];\n+        push.apply(args, arguments);\n+        return result.call(this, func.apply(_, args));\n+      };\n+    });\n+  };\n+\n+  // Generate a unique integer id (unique within the entire client session).\n+  // Useful for temporary DOM ids.\n+  var idCounter = 0;\n+  _.uniqueId = function(prefix) {\n+    var id = ++idCounter + '';\n+    return prefix ? prefix + id : id;\n+  };\n+\n+  // By default, Underscore uses ERB-style template delimiters, change the\n+  // following template settings to use alternative delimiters.\n+  _.templateSettings = {\n+    evaluate    : /<%([\\s\\S]+?)%>/g,\n+    interpolate : /<%=([\\s\\S]+?)%>/g,\n+    escape      : /<%-([\\s\\S]+?)%>/g\n+  };\n+\n+  // When customizing `templateSettings`, if you don't want to define an\n+  // interpolation, evaluation or escaping regex, we need one that is\n+  // guaranteed not to match.\n+  var noMatch = /(.)^/;\n+\n+  // Certain characters need to be escaped so that they can be put into a\n+  // string literal.\n+  var escapes = {\n+    \"'\":      \"'\",\n+    '\\\\':     '\\\\',\n+    '\\r':     'r',\n+    '\\n':     'n',\n+    '\\t':     't',\n+    '\\u2028': 'u2028',\n+    '\\u2029': 'u2029'\n+  };\n+\n+  var escaper = /\\\\|'|\\r|\\n|\\t|\\u2028|\\u2029/g;\n+\n+  // JavaScript micro-templating, similar to John Resig's implementation.\n+  // Underscore templating handles arbitrary delimiters, preserves whitespace,\n+  // and correctly escapes quotes within interpolated code.\n+  _.template = function(text, data, settings) {\n+    var render;\n+    settings = _.defaults({}, settings, _.templateSettings);\n+\n+    // Combine delimiters into one regular expression via alternation.\n+    var matcher = new RegExp([\n+      (settings.escape || noMatch).source,\n+      (settings.interpolate || noMatch).source,\n+      (settings.evaluate || noMatch).source\n+    ].join('|') + '|$', 'g');\n+\n+    // Compile the template source, escaping string literals appropriately.\n+    var index = 0;\n+    var source = \"__p+='\";\n+    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {\n+      source += text.slice(index, offset)\n+        .replace(escaper, function(match) { return '\\\\' + escapes[match]; });\n+\n+      if (escape) {\n+        source += \"'+\\n((__t=(\" + escape + \"))==null?'':_.escape(__t))+\\n'\";\n+      }\n+      if (interpolate) {\n+        source += \"'+\\n((__t=(\" + interpolate + \"))==null?'':__t)+\\n'\";\n+      }\n+      if (evaluate) {\n+        source += \"';\\n\" + evaluate + \"\\n__p+='\";\n+      }\n+      index = offset + match.length;\n+      return match;\n+    });\n+    source += \"';\\n\";\n+\n+    // If a variable is not specified, place data values in local scope.\n+    if (!settings.variable) source = 'with(obj||{}){\\n' + source + '}\\n';\n+\n+    source = \"var __t,__p='',__j=Array.prototype.join,\" +\n+      \"print=function(){__p+=__j.call(arguments,'');};\\n\" +\n+      source + \"return __p;\\n\";\n+\n+    try {\n+      render = new Function(settings.variable || 'obj', '_', source);\n+    } catch (e) {\n+      e.source = source;\n+      throw e;\n+    }\n+\n+    if (data) return render(data, _);\n+    var template = function(data) {\n+      return render.call(this, data, _);\n+    };\n+\n+    // Provide the compiled function source as a convenience for precompilation.\n+    template.source = 'function(' + (settings.variable || 'obj') + '){\\n' + source + '}';\n+\n+    return template;\n+  };\n+\n+  // Add a \"chain\" function, which will delegate to the wrapper.\n+  _.chain = function(obj) {\n+    return _(obj).chain();\n+  };\n+\n+  // OOP\n+  // ---------------\n+  // If Underscore is called as a function, it returns a wrapped object that\n+  // can be used OO-style. This wrapper holds altered versions of all the\n+  // underscore functions. Wrapped objects may be chained.\n+\n+  // Helper function to continue chaining intermediate results.\n+  var result = function(obj) {\n+    return this._chain ? _(obj).chain() : obj;\n+  };\n+\n+  // Add all of the Underscore functions to the wrapper object.\n+  _.mixin(_);\n+\n+  // Add all mutator Array functions to the wrapper.\n+  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {\n+    var method = ArrayProto[name];\n+    _.prototype[name] = function() {\n+      var obj = this._wrapped;\n+      method.apply(obj, arguments);\n+      if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];\n+      return result.call(this, obj);\n+    };\n+  });\n+\n+  // Add all accessor Array functions to the wrapper.\n+  each(['concat', 'join', 'slice'], function(name) {\n+    var method = ArrayProto[name];\n+    _.prototype[name] = function() {\n+      return result.call(this, method.apply(this._wrapped, arguments));\n+    };\n+  });\n+\n+  _.extend(_.prototype, {\n+\n+    // Start chaining a wrapped Underscore object.\n+    chain: function() {\n+      this._chain = true;\n+      return this;\n+    },\n+\n+    // Extracts the result from a wrapped and chained object.\n+    value: function() {\n+      return this._wrapped;\n+    }\n+\n+  });\n+\n+  // AMD registration happens at the end for compatibility with AMD loaders\n+  // that may not enforce next-turn semantics on modules. Even though general\n+  // practice for AMD registration is to be anonymous, underscore registers\n+  // as a named module because, like jQuery, it is a base library that is\n+  // popular enough to be bundled in a third party lib, but not be part of\n+  // an AMD load request. Those cases could generate an error when an\n+  // anonymous define() is called outside of a loader request.\n+  if (typeof define === 'function' && define.amd) {\n+    define('underscore', [], function() {\n+      return _;\n+    });\n+  }\n+}).call(this);\ndiff --git a/resources/scripts/engine/animations/keyframe.js b/resources/scripts/engine/animations/keyframe.js\nnew file mode 100644\nindex 0000000..b28071a\n--- /dev/null\n+++ b/resources/scripts/engine/animations/keyframe.js\n@@ -0,0 +1,142 @@\n+Engine.Animations.Keyframe = class Keyframe {\n+  constructor(sprite, keyframes) {\n+    this.sprite = sprite;\n+    // The key-frames array contains objects with the properties of the\n+    // sprite at the current time-point, e.g. width of 100 and height of 200\n+    this.keyframes = keyframes;\n+    this.age = 0;\n+    this.frame = 0;\n+    // This flag determines what's gonna happen to the animation once\n+    // it's finished playing\n+    this.repetitionMode = \"none\";\n+    this.lastKeyframe = _.last(keyframes);\n+    this.lastFrame = this.lastKeyframe.frame;\n+\n+    // These are the properties which we can animate\n+    this.animables = [\n+      \"x\", \"y\", \"width\", \"height\", \"opacity\"\n+    ];\n+\n+    // Set a map whose keys represent animatable properties and values represent an array\n+    // with relevant key-frames to its belonging property\n+    this.trimmedKeyframes = this.animables.reduce((trimmedKeyframes, key) => {\n+      trimmedKeyframes[key] = keyframes.filter(keyframe => keyframe[key] != null);\n+      return trimmedKeyframes;\n+    }, {});\n+\n+    // Set initial properties on sprite based on initial key-frame\n+    _.each(keyframes[0], (value, key) => {\n+      if (this.animables.includes(key)) sprite[key] = value;\n+    });\n+  }\n+\n+  draw(context, offsetX, offsetY) {\n+    this.sprite.draw(context, offsetX, offsetY);\n+  }\n+\n+  update(span) {\n+    if (!this.playing) return;\n+\n+    this.age += span;\n+\n+    switch (this.repetitionMode) {\n+      // After one cycle animation would stop\n+      case \"none\":\n+        this.frame += span;\n+\n+        if (this.frame > this.lastFrame) {\n+          this.frame = this.lastFrame;\n+          this.playing = false;\n+        }\n+\n+        break;\n+\n+      // Once finished, replay from the beginning\n+      case \"cyclic\":\n+        this.frame = this.age % this.lastFrame;\n+        break;\n+\n+      // Once finished, play backwards, and so on\n+      case \"full\":\n+        this.frame = this.age % this.lastFrame;\n+        let animationComplete = (this.age / this.lastFrame) % 2 >= 1;\n+        if (animationComplete) this.frame = this.lastFrame - this.frame;\n+        break;\n+    }\n+\n+    // Update sprite properties based on given key-frame's easing mode\n+    this.animables.forEach(key => {\n+      let motion = this.getKeyframeMotion(key);\n+\n+      if (motion)\n+        this.sprite[key] = this.calculateRelativeValue(motion, key);\n+    });\n+  }\n+\n+  play() {\n+    this.playing = true;\n+  }\n+\n+  pause() {\n+    this.playing = false;\n+  }\n+\n+  // Gets motion for current refresh\n+  getKeyframeMotion(key) {\n+    let keyframes = this.trimmedKeyframes[key];\n+\n+    // If no key-frames defined, motion is idle\n+    if (keyframes == null) return;\n+    // If there is only one key frame, motion is idle\n+    if (keyframes.length < 2) return;\n+    // If last frame reached, motion is idle\n+    if (this.frame > _.last(keyframes).frame) return;\n+\n+    let start = this.findStartKeyframe(keyframes);\n+    let end = this.findEndKeyframe(keyframes);\n+    let ratio = this.getKeyframesRatio(start, end);\n+\n+    return { start, end, ratio };\n+  }\n+\n+  // Gets the movement ratio\n+  getKeyframesRatio(start, end) {\n+    return (this.frame - start.frame) / (end.frame - start.frame);\n+  }\n+\n+  // Get property end value based on current frame\n+  findEndKeyframe(keyframes) {\n+    return _.find(keyframes, keyframe =>\n+      keyframe.frame >= (this.frame || 1)\n+    );\n+  }\n+\n+  // Get property start value based on current frame\n+  findStartKeyframe(keyframes) {\n+    let resultIndex;\n+\n+    keyframes.some((keyframe, currIndex) => {\n+      if (keyframe.frame >= (this.frame || 1)) {\n+        resultIndex = currIndex;\n+        return true;\n+      }\n+    });\n+\n+    return keyframes[resultIndex - 1];\n+  }\n+\n+  // Get a recalculated property value relative to provided easing mode\n+  calculateRelativeValue(motion, key) {\n+    let a = motion.start[key];\n+    let b = motion.end[key];\n+    let r = motion.ratio;\n+    let easing = r > 0 ? motion.start.easing : motion.end.easing;\n+\n+    switch (easing) {\n+      case \"in\": r = Math.sin((r * Math.PI) / 2); break;\n+      case \"out\": r = Math.cos((r * Math.PI) / 2); break;\n+    }\n+\n+    return ((b - a) * r) + a;\n+  }\n+};\n\\ No newline at end of file\ndiff --git a/resources/scripts/engine/assets_loader.js b/resources/scripts/engine/assets_loader.js\nnew file mode 100644\nindex 0000000..e43f1e0\n--- /dev/null\n+++ b/resources/scripts/engine/assets_loader.js\n@@ -0,0 +1,21 @@\n+Engine.AssetsLoader = class AssetsLoader {\n+  constructor(next) {\n+    this.next = next;\n+  }\n+\n+  // Load texture\n+  texture(path) {\n+    let image = new Image();\n+    image.onload = this.next();\n+    image.src = `${path}.png`;\n+    return image;\n+  }\n+\n+  // Load font\n+  font(path) {\n+    let font = new Engine.Font();\n+    font.onload = this.next();\n+    font.src = path;\n+    return font;\n+  }\n+};\n\\ No newline at end of file\ndiff --git a/resources/scripts/engine/font.js b/resources/scripts/engine/font.js\nnew file mode 100644\nindex 0000000..e39986e\n--- /dev/null\n+++ b/resources/scripts/engine/font.js\n@@ -0,0 +1,133 @@\n+Engine.Font = class Font extends Engine.Restorable {\n+  // The src property acts just line native image's src property.\n+  // Once finished loading, the onload() callback will be invoked\n+  get src() {\n+    return this._src;\n+  }\n+\n+  set src(src) {\n+    this._src = src;\n+\n+    // The font is actually an image, therefore we have 2 onload callbacks.\n+    // The first one is the native one which will always be run,\n+    // and the second one is a user defined one\n+    if (this.onload) var done = _.after(2, this.onload);\n+\n+    this.atlas = new Image();\n+    this.atlas.onload = done;\n+    this.atlas.src = `${src}.png`;\n+\n+    // Get json based on the given src property\n+    $.getJSON(`${src}.json`, data => {\n+      this.data = data;\n+      if (done) done();\n+    });\n+\n+    return this._src;\n+  }\n+\n+  constructor() {\n+    // The color property is the only restorable property\n+    super(\"color\");\n+    this.charSpritesCache = {};\n+  }\n+\n+  // Creates a texture out of the font with the given text\n+  createTexture(text, options = {}) {\n+    let { noOffsets, noSpaces } = options;\n+    let canvas = document.createElement(\"canvas\");\n+    let context = canvas.getContext(\"2d\");\n+    let height = canvas.height = this.data.height;\n+\n+    // Calculates the width of the canvas based on the text and the font\n+    let width = canvas.width = _.reduce(text, (width, c) => {\n+      // No-space option means that the characters will be\n+      // drawn with no any space between them\n+      if (noSpaces) {\n+        return width + this.getCharSprite(c).width;\n+      }\n+\n+      return width + this.data.chars[c].width;\n+    }, 0);\n+\n+    // A custom size can be specified for a font as well\n+    if (this.size) {\n+      let ratio = this.size / this.data.size;\n+      canvas.height *= ratio;\n+      canvas.width *= ratio;\n+      context.scale(ratio, ratio);\n+    }\n+\n+    // No we are going to draw each char on the canvas individually,\n+    // naturally, there should be an offset after we draw each character.\n+    // This variable will be used to calculate the offset\n+    let offset = 0;\n+\n+    // Get for each char\n+    _.map(text, (char) => {\n+      return this.getCharSprite(char);\n+    })\n+    // Start drawing each char on the canvas\n+    .forEach((charSprite, index) => {\n+      let charData = this.data.chars[text.charAt(index)];\n+\n+      // Each char in the font xml has a native offset in addition to its rectangle.\n+      // This option will disable the calculation of the native offset\n+      if (noOffsets) {\n+        charSprite.draw(context, offset);\n+      }\n+      else {\n+        charSprite.draw(context, offset + charData.offset.x, charData.offset.y);\n+      }\n+\n+      if (noSpaces) {\n+        offset += charSprite.width;\n+      }\n+      else {\n+        offset += charData.width;\n+      }\n+\n+      // A color for the font can be specified as well\n+      if (this.color) {\n+        let overlayCanvas = document.createElement(\"canvas\");\n+        let overlayContext = overlayCanvas.getContext(\"2d\");\n+        overlayCanvas.width = width;\n+        overlayCanvas.height = height;\n+        overlayContext.beginPath();\n+        overlayContext.rect(0, 0, width, height);\n+        overlayContext.fillStyle = this.color;\n+        overlayContext.fill();\n+\n+        context.save();\n+        context.globalCompositeOperation = \"source-in\";\n+        context.drawImage(overlayCanvas, 0, 0);\n+        context.restore();\n+      }\n+    });\n+\n+    // The canvas will be treated like an image\n+    return canvas;\n+  }\n+\n+  // Gets a sprite of the given char, using the current font\n+  getCharSprite(char) {\n+    // If char is already stored in cache, abort calculation and return it\n+    if (this.charSpritesCache[char]) return this.charSpritesCache[char];\n+\n+    // This data is fetched by the given json\n+    let { x, y, width, height } = this.data.chars[char].rect;\n+    // Creating a canvas which we will use to draw on,\n+    // but it is used exactly like an image afterwards\n+    let canvas = document.createElement(\"canvas\");\n+    let context = canvas.getContext(\"2d\");\n+\n+    // The canvas will have the same dimensions as the font\n+    canvas.width = width;\n+    canvas.height = height;\n+    // Draw a cropped image from the atlas, this image contains the char font\n+    context.drawImage(this.atlas, x, y, width, height, 0, 0, width, height);\n+\n+    // Store in cache and return it\n+    return this.charSpritesCache[char] = new Engine.Sprite(canvas);\n+  }\n+};\n\\ No newline at end of file\ndiff --git a/resources/scripts/engine/game.js b/resources/scripts/engine/game.js\nnew file mode 100644\nindex 0000000..fae839e\n--- /dev/null\n+++ b/resources/scripts/engine/game.js\n@@ -0,0 +1,199 @@\n+Engine.Game = class Game {\n+  // Frames rendered per second\n+  get fps() {\n+    return 60;\n+  }\n+\n+  // Game's run speed.\n+  // A lower value will make it run slower and a higher value will make it run faster\n+  get speed() {\n+    return 1;\n+  }\n+\n+  constructor(canvas, debugging) {\n+    this.canvas = canvas;\n+    this.debugging = debugging;\n+    this.lastUpdate = this.creation = new Date().getTime();\n+\n+    // Canvas dimensions must be set programmatically, otherwise you might encounter some\n+    // unexpected behaviors\n+    canvas.width = 1280;\n+    canvas.height = 720;\n+    // Canvas will be focused once game page is loaded so all events will automatically\n+    // be captured by it\n+    canvas.focus();\n+\n+    // We want to focus on the canvas once we press on it\n+    canvas.addEventListener(\"mousedown\", canvas.focus.bind(canvas), false);\n+    // Key flags will be registered by the \"KeyStates\" instance\n+    canvas.addEventListener(\"keydown\", onKeyDown.bind(this), false);\n+    canvas.addEventListener(\"keyup\", onKeyUp.bind(this), false);\n+\n+    this.assets = {};\n+    this.events = new Map();\n+    this.screen = new Engine.Screen(this);\n+    this.keyStates = new Engine.KeyStates();\n+    this.context = canvas.getContext(\"2d\");\n+    this.bufferedCanvas = document.createElement(\"canvas\");\n+    this.bufferedContext = this.bufferedCanvas.getContext(\"2d\");\n+    this.bufferedCanvas.width = canvas.width;\n+    this.bufferedCanvas.height = canvas.height;\n+  }\n+\n+  draw() {\n+    // If debugging, don't use double buffer so we can see rendering in real time\n+    if (this.debugging) {\n+      this.context.restore();\n+      this.context.fillStyle = \"black\";\n+      this.context.save();\n+      this.context.beginPath();\n+      this.context.rect(0, 0, this.canvas.width, this.canvas.height);\n+      this.context.fill();\n+      this.drawScreen(this.context);\n+    }\n+    // If not debugging, use double buffer to prevent flickering\n+    else {\n+      this.bufferedContext.restore();\n+      this.bufferedContext.fillStyle = \"black\";\n+      this.bufferedContext.save();\n+      this.bufferedContext.beginPath();\n+      this.bufferedContext.rect(0, 0, this.canvas.width, this.canvas.height);\n+      this.bufferedContext.fill();\n+      this.drawScreen(this.bufferedContext);\n+      this.context.drawImage(this.bufferedCanvas, 0, 0);\n+    }\n+  }\n+\n+  drawScreen(context) {\n+    // If screen's assets are not yet loaded, don't draw it\n+    if (this.screen.loading) return;\n+    if (this.screen.draw) this.screen.draw(context);\n+  }\n+\n+  update() {\n+    // Calculate the time elapsed\n+    let lastUpdate = this.lastUpdate;\n+    let currUpdate = this.lastUpdate = new Date().getTime();\n+    let span = currUpdate - lastUpdate;\n+    this.updateScreen(span / this.speed);\n+  }\n+\n+  updateScreen(span) {\n+    this.screen.age += span;\n+    // If screen's assets are not yet loaded, don't update it\n+    if (this.screen.loading) return;\n+    if (this.screen.update) this.screen.update(span);\n+  }\n+\n+  // The main loop of the game\n+  loop() {\n+    // If paused, don't run loop. The canvas will remain as is\n+    if (!this.playing) return;\n+\n+    setTimeout(() => {\n+      this.draw();\n+      this.update();\n+      this.loop();\n+    }, this.fps);\n+  }\n+\n+  play() {\n+    this.playing = true;\n+    this.loop();\n+  }\n+\n+  pause() {\n+    this.playing = false;\n+  }\n+\n+  changeScreen(Screen, ...screenArgs) {\n+    // If there is a screen defined, dispose it first\n+    if (this.screen) {\n+      this.unloadScreen();\n+      this.screen.disposeEventListeners();\n+    }\n+\n+    this.screen = new Screen(this, ...screenArgs);\n+\n+    // Load screen assets\n+    this.loadScreen(() => {\n+      // Once assets are loaded, initialize event listeners\n+      this.screen.initEventListeners();\n+      // The \"initialize\" method is exactly the same as the constructor, only it runs\n+      // once assets are available and event listeners are registered\n+      this.screen.initialize(this, ...screenArgs);\n+    });\n+  }\n+\n+  // Loads screen assets and invokes callback once loading is finished\n+  loadScreen(callback = _.noop) {\n+    if (!this.screen.load) return callback();\n+\n+    this.screen.loading = true;\n+    // The number of assets to load\n+    let loadsize = 0;\n+\n+    // We use the \"after\" method because we want the following callback to be invoked\n+    // only once all assets are loaded\n+    let onload = _.after(loadsize, () => {\n+      delete this.screen.loading;\n+      callback();\n+    });\n+\n+    // This object can load assets\n+    let assetsLoader = new Engine.AssetsLoader(() => {\n+      loadsize++;\n+      return () => onload();\n+    });\n+\n+    // The \"load\" method returns the assets loaded by the screen\n+    let screenAssets = this.screen.load(assetsLoader);\n+    // The returned assets will be available on screen's assets object\n+    _.extend(this.screen.assets, screenAssets);\n+  }\n+\n+  // Disposes screen assets\n+  unloadScreen() {\n+    let assetsNames = this.screen.unload && this.screen.unload();\n+    _.omit(this.assets, assetsNames);\n+  }\n+\n+  // Defines global assets\n+  extendAssets(assets) {\n+    _.extend(this.assets, assets);\n+  }\n+\n+  // Disposes global assets\n+  clearAssets() {\n+    this.assets = {};\n+  }\n+\n+  // Adds event listener for game canvas\n+  addEventListener(type, listener, target) {\n+    let boundListener = listener.bind(target);\n+    this.events.set(listener, boundListener);\n+    this.canvas.addEventListener(type, boundListener, false);\n+  }\n+\n+  // Removes event listener from game canvas\n+  removeEventListener(type, listener) {\n+    let boundListener = this.events.get(listener);\n+    this.events.delete(listener);\n+    this.canvas.removeEventListener(type, boundListener, false);\n+  }\n+};\n+\n+function onKeyDown(e) {\n+  // Once we're focused on the canvas, we want nothing else to happen\n+  // besides events the game is listening to. For example, when we press\n+  // the arrow keys, this will prevent the screen from scrolling\n+  e.preventDefault();\n+  // Register key press\n+  this.keyStates.add(e.keyCode);\n+}\n+\n+function onKeyUp(e) {\n+  e.preventDefault();\n+  // Register key release\n+  this.keyStates.remove(e.keyCode);\n+}\ndiff --git a/resources/scripts/engine/geometry/circle.js b/resources/scripts/engine/geometry/circle.js\nnew file mode 100644\nindex 0000000..8961cda\n--- /dev/null\n+++ b/resources/scripts/engine/geometry/circle.js\n@@ -0,0 +1,168 @@\n+Engine.Geometry.Circle = class Circle {\n+  // x - The x value of the circle's center\n+  // y - The y value of the circle's center\n+  // r - The radius of the center\n+  // rad1 - The first radian of the circle, not necessarily its beginning\n+  // rad2 - The second radian of the circle, not necessarily its beginning\n+  constructor(x, y, r, rad1, rad2) {\n+    this.x = x.trim(9);\n+    this.y = y.trim(9);\n+    this.r = r.trim(9);\n+\n+    // Trimming mode is done based on which radian represents the ending and which radian\n+    // represents the ending\n+    if (rad1 > rad2) {\n+      this.rad1 = rad1.trim(9, \"floor\");\n+      this.rad2 = rad2.trim(9, \"ceil\");\n+    }\n+    else {\n+      this.rad1 = rad1.trim(9, \"ceil\");\n+      this.rad2 = rad2.trim(9, \"floor\");\n+    }\n+  }\n+\n+  // Gets the matching x value for the given radian\n+  getX(rad) {\n+    if (!rad.trim(9).isBetween(this.rad1, this.rad2)) return;\n+    return ((this.r * Math.cos(rad)) + this.x).trim(9);\n+  }\n+\n+  // Gets the matching y value for the given radian\n+  getY(rad) {\n+    if (!rad.trim(9).isBetween(this.rad1, this.rad2)) return;\n+    return ((this.r * Math.sin(rad)) + this.y).trim(9);\n+  }\n+\n+  // Gets the matching point for the given radian\n+  getPoint(rad) {\n+    if (!rad.isBetween(this.rad1, this.rad2)) return;\n+\n+    return {\n+      x: ((this.r * Math.cos(rad)) + this.x).trim(9),\n+      y: ((this.r * Math.sin(rad)) + this.y).trim(9)\n+    };\n+  }\n+\n+  // Gets the matching radian for the given point\n+  getRad(x, y) {\n+    let rad = Math.atan2(y - this.y, x - this.x);\n+\n+    // If calculated radian is in circle's radian range, return it\n+    if (rad != null && rad.isBetween(this.rad1, this.rad2)) {\n+      return rad;\n+    }\n+\n+    // The calculated radian can still be in the circle's radian range in case\n+    // they completed several whole circles\n+    if (Math.abs(this.rad1) > Math.abs(this.rad2)) {\n+      var cycRad = this.rad1;\n+    }\n+    else {\n+      var cycRad = this.rad2;\n+    }\n+\n+    if ((rad + (2 * Math.PI * Math.floor(cycRad / (2 * Math.PI)))).trim(9).isBetween(this.rad1, this.rad2) ||\n+       (rad + (2 * Math.PI * Math.ceil(cycRad / (2 * Math.PI)))).trim(9).isBetween(this.rad1, this.rad2)) {\n+      return rad;\n+    }\n+  }\n+\n+  // Returns if circle has given points\n+  hasPoint(x, y) {\n+    return this.getRad(x, y) != null;\n+  }\n+\n+  getIntersection(shape) {\n+    if (shape instanceof Engine.Geometry.Line)\n+      return this.getLineIntersection(shape);\n+    if (shape instanceof Engine.Geometry.Circle)\n+      return this.getCircleIntersection(shape);\n+    if (shape instanceof Engine.Geometry.Polygon)\n+      return this.getPolygonIntersection(shape);\n+  }\n+\n+  // circle - circle intersection method\n+  getCircleIntersection(circle) {\n+    let dx = circle.x - this.x;\n+    let dy = circle.y - this.y;\n+    let d = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\n+\n+    if (d > this.r + circle.r ||\n+       d < Math.abs(this.r - circle.r)) {\n+      return;\n+    }\n+\n+    let a = ((Math.pow(this.r, 2) - Math.pow(circle.r, 2)) + Math.pow(d, 2)) / (2 * d);\n+    let x = this.x + ((dx * a) / d);\n+    let y = this.y + ((dy * a) / d);\n+    let h = Math.sqrt(Math.pow(this.r, 2) - Math.pow(a, 2));\n+    let rx = (- dy * h) / d;\n+    let ry = (dx * h) / d;\n+\n+    let interPoints = [\n+      {\n+        x: x + rx,\n+        y: y + ry\n+      },\n+      {\n+        x: x - rx,\n+        y: y - ry\n+      }\n+    ]\n+    .map(point => ({\n+        x: point.x.trim(9),\n+        y: point.y.trim(9)\n+     }));\n+\n+    interPoints = _.uniq(interPoints, point => `(${point.x}, ${point.y})`);\n+\n+    [this, circle].forEach(function(circle) {\n+      interPoints = interPoints.filter(point => circle.hasPoint(point.x, point.y));\n+    });\n+\n+    if (interPoints.length > 0) return interPoints;\n+  }\n+\n+  // circle - line intersection method\n+  getLineIntersection(line) {\n+    let x1 = line.x1 - this.x;\n+    let x2 = line.x2 - this.x;\n+    let y1 = line.y1 - this.y;\n+    let y2 = line.y2 - this.y;\n+    let dx = x2 - x1;\n+    let dy = y2 - y1;\n+    let d = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\n+    let h = (x1 * y2) - (x2 * y1);\n+    let delta = (Math.pow(this.r, 2) * Math.pow(d, 2)) - Math.pow(h, 2);\n+\n+    if (delta < 0) return;\n+\n+    let interPoints = [\n+      {\n+        x: (((h * dy) + (((dy / Math.abs(dy)) || 1) * dx * Math.sqrt(delta))) / Math.pow(d, 2)) + this.x,\n+        y: (((-h * dx) + (Math.abs(dy) * Math.sqrt(delta))) / Math.pow(d, 2)) + this.y\n+      },\n+      {\n+        x: (((h * dy) - (((dy / Math.abs(dy)) || 1) * dx * Math.sqrt(delta))) / Math.pow(d, 2)) + this.x,\n+        y: (((-h * dx) - (Math.abs(dy) * Math.sqrt(delta))) / Math.pow(d, 2)) + this.y\n+      }\n+    ]\n+    .map(point => ({\n+        x: point.x.trim(9),\n+        y: point.y.trim(9)\n+    }))\n+    .filter(point => {\n+      return this.hasPoint(point.x, point.y) &&\n+        line.boundsHavePoint(point.x, point.y);\n+    });\n+\n+    interPoints = _.uniq(interPoints, point => `(${point.x}, ${point.y})`);\n+\n+    if (interPoints.length > 0) return interPoints;\n+  }\n+\n+  // circle - polygon intersection method\n+  getPolygonIntersection(polygon) {\n+    return polygon.getCircleIntersection(this);\n+  }\n+};\n\\ No newline at end of file\ndiff --git a/resources/scripts/engine/geometry/line.js b/resources/scripts/engine/geometry/line.js\nnew file mode 100644\nindex 0000000..19177aa\n--- /dev/null\n+++ b/resources/scripts/engine/geometry/line.js\n@@ -0,0 +1,71 @@\n+Engine.Geometry.Line = class Line {\n+  // x1 - The first point's x value\n+  // y1 - The first point's y value\n+  // x1 - The second point's x value\n+  // y2 - The second point's y value\n+  constructor(x1, y1, x2, y2) {\n+    this.x1 = x1.trim(9);\n+    this.y1 = y1.trim(9);\n+    this.x2 = x2.trim(9);\n+    this.y2 = y2.trim(9);\n+  }\n+\n+  // Gets the matching x value for a given y value\n+  getX(y) {\n+    let x = ((((y - this.y1) * (this.x2 - this.x1)) / (this.y2 - this.y1)) + this.x1).trim(9);\n+    if (isNaN(x) || x.isBetween(this.x1, this.x2)) return x;\n+  }\n+\n+  // Gets the matching y value for a given x value\n+  getY(x) {\n+    let y = ((((x - this.x1) * (this.y2 - this.y1)) / (this.x2 - this.x1)) + this.y1).trim(9);\n+    if (isNaN(y) || y.isBetween(this.y1, this.y2)) return y;\n+  }\n+\n+  // Returns if line has given point\n+  hasPoint(x, y) {\n+    if (!this.boundsHavePoint(x, y)) return false;\n+    let m = ((this.y2 - this.y1) / (this.x2 - this.x1)).trim(9);\n+    return (y - this.y1) / (x - this.x1) == m;\n+  }\n+\n+  // Returns if given point is contained by the bounds aka cage of line\n+  boundsHavePoint(x, y) {\n+    return x.isBetween(this.x1, this.x2) &&\n+    y.isBetween(this.y1, this.y2);\n+  }\n+\n+  getIntersection(shape) {\n+    if (shape instanceof Engine.Geometry.Line)\n+      return this.getLineIntersection(shape);\n+    if (shape instanceof Engine.Geometry.Circle)\n+      return this.getCircleIntersection(shape);\n+    if (shape instanceof Engine.Geometry.Polygon)\n+      return this.getPolygonIntersection(shape);\n+  }\n+\n+  // line - line intersection method\n+  getLineIntersection(line) {\n+    if (!(((this.x1 - this.x2) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * (line.x1 - line.x2)))) return;\n+\n+    let x = (((((this.x1 * this.y2) - (this.y1 * this.x2)) * (line.x1 - line.x2)) - ((this.x1 - this.x2) * ((line.x1 * line.y2) - (line.y1 * line.x2)))) /\n+        (((this.x1 - this.x2) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * (line.x1 - line.x2)))).trim(9);\n+    let y = (((((this.x1 * this.y2) - (this.y1 * this.x2)) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * ((line.x1 * line.y2) - (line.y1 * line.x2)))) /\n+        (((this.x1 - this.x2) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * (line.x1 - line.x2)))).trim(9);\n+\n+    if (x.isBetween(this.x1, this.x2) && x.isBetween(line.x1, line.x2) &&\n+       y.isBetween(this.y1, this.y2) && y.isBetween(line.y1, line.y2)) {\n+      return { x, y };\n+    }\n+  }\n+\n+  // line - circle intersection method\n+  getCircleIntersection(circle) {\n+    return circle.getLineIntersection(this);\n+  }\n+\n+  // line - polygon intersection method\n+  getPolygonIntersection(polygon) {\n+    return polygon.getLineIntersection(this);\n+  }\n+};\n\\ No newline at end of file\ndiff --git a/resources/scripts/engine/geometry/polygon.js b/resources/scripts/engine/geometry/polygon.js\nnew file mode 100644\nindex 0000000..d8507b9\n--- /dev/null\n+++ b/resources/scripts/engine/geometry/polygon.js\n@@ -0,0 +1,58 @@\n+Engine.Geometry.Polygon = class Polygon {\n+  // bounds - an array of arrays. Each sub-array represents the arguments vector which\n+  //   will be invoked by the line's construction method\n+  constructor(...bounds) {\n+    this.bounds = bounds.map(coords => new Engine.Geometry.Line(...coords));\n+  }\n+\n+  // Returns if polygon has given point\n+  hasPoint(x, y) {\n+    // Run check for each bound\n+    return this.bounds.some(bound => bound.hasPoint(x, y));\n+  }\n+\n+  getIntersection(shape) {\n+    if (shape instanceof Engine.Geometry.Line)\n+      return this.getLineIntersection(shape);\n+    if (shape instanceof Engine.Geometry.Circle)\n+      return this.getCircleIntersection(shape);\n+    if (shape instanceof Engine.Geometry.Polygon)\n+      return this.getPolygonIntersection(shape);\n+  }\n+\n+  // polygon - line intersection method\n+  getLineIntersection(line) {\n+    // line - line intersection for each bound\n+    let result = this.bounds.reduce((result, bound) => {\n+      let intersection = line.getLineIntersection(bound);\n+      if (intersection) result = result.concat(intersection);\n+      return result;\n+    }, []);\n+\n+    if (result.length) return result;\n+  }\n+\n+  // polygon - circle intersection method\n+  getCircleIntersection(circle) {\n+    // line - circle intersection for each bound\n+    let result = this.bounds.reduce((result, bound) => {\n+      let intersection = circle.getLineIntersection(bound);\n+      if (intersection) result = result.concat(intersection);\n+      return result;\n+    }, []);\n+\n+    if (result.length) return result;\n+  }\n+\n+  // polygon - polygon intersection method\n+  getPolygonIntersection(polygon) {\n+    // line - polygon intersection for each bound\n+    let result = this.bounds.reduce((result, bound) => {\n+      let intersection = polygon.getLineIntersection(bound);\n+      if (intersection) result = result.concat(intersection);\n+      return result;\n+    }, []);\n+\n+    if (result.length) return result;\n+  }\n+};\n\\ No newline at end of file\ndiff --git a/resources/scripts/engine/key_states.js b/resources/scripts/engine/key_states.js\nnew file mode 100644\nindex 0000000..c63bb23\n--- /dev/null\n+++ b/resources/scripts/engine/key_states.js\n@@ -0,0 +1,20 @@\n+Engine.KeyStates = class KeyStates {\n+  constructor() {\n+    // We will have 255 states, each one represents an ascii code matching its index\n+    this.states = new Array(255);\n+  }\n+\n+  get(k) {\n+    return this.states[k];\n+  }\n+\n+  // This should be called once we press a key\n+  add(k) {\n+    this.states[k] = true;\n+  }\n+\n+  // This should be called once we release a key\n+  remove(k) {\n+    this.states[k] = false;\n+  }\n+};\n\\ No newline at end of file\ndiff --git a/resources/scripts/engine/layer.js b/resources/scripts/engine/layer.js\nnew file mode 100644\nindex 0000000..bbef4ea\n--- /dev/null\n+++ b/resources/scripts/engine/layer.js\n@@ -0,0 +1,43 @@\n+Engine.Layer = class Layer {\n+  // The dimensions of the layer are correlated to dimensions of the canvas\n+  get width() {\n+    return this.canvas.width;\n+  }\n+\n+  get height() {\n+    return this.canvas.height;\n+  }\n+\n+  // A hash of \"eventName\" : \"handlerName\" which should be overrided by user\n+  get events() {\n+    return {};\n+  }\n+\n+  constructor(screen) {\n+    this.age = 0;\n+    this.creation = new Date().getTime();\n+    this.screen = screen;\n+    this.game = screen.game;\n+    this.assets = screen.assets;\n+    this.keyStates = screen.keyStates;\n+    this.canvas = screen.game.canvas;\n+  }\n+\n+  update(span) {\n+  }\n+\n+  draw(context) {\n+  }\n+\n+  initEventListeners() {\n+    _.each(this.events, (listener, event) => {\n+      this.game.addEventListener(event, this[listener], this);\n+    });\n+  }\n+\n+  disposeEventListeners() {\n+    _.each(this.events, (listener, event) => {\n+      this.game.removeEventListener(event, this[listener]);\n+    });\n+  }\n+};\n\\ No newline at end of file\ndiff --git a/resources/scripts/engine/restorable.js b/resources/scripts/engine/restorable.js\nnew file mode 100644\nindex 0000000..9d00eba\n--- /dev/null\n+++ b/resources/scripts/engine/restorable.js\n@@ -0,0 +1,21 @@\n+Engine.Restorable = class Restorable {\n+  // Acts the same as canvas's save() and restore() API.\n+  // 'restorable' props are defined in the constructor\n+  constructor(...restorableProps) {\n+    this._restorableProps = restorableProps;\n+    this._restorableStates = [];\n+  }\n+\n+  // Save current state in the stack\n+  save() {\n+    this._restorableStates.push(this._restorableProps.reduce((state, prop) => {\n+      state[prop] = this[prop];\n+      return state;\n+    }, {}));\n+  }\n+\n+  // Pop most recent state and apply it\n+  restore() {\n+    _.extend(this, this._restorableStates.pop());\n+  }\n+};\n\\ No newline at end of file\ndiff --git a/resources/scripts/engine/screen.js b/resources/scripts/engine/screen.js\nnew file mode 100644\nindex 0000000..ee52870\n--- /dev/null\n+++ b/resources/scripts/engine/screen.js\n@@ -0,0 +1,85 @@\n+Engine.Screen = class Screen {\n+  // The dimensions of the screen are correlated to dimensions of the canvas\n+  get width() {\n+    return this.canvas.width;\n+  }\n+\n+  get height() {\n+    return this.canvas.height;\n+  }\n+\n+  // A hash of \"eventName\" : \"handlerName\" which should be overrided by user\n+  get events() {\n+    return {};\n+  }\n+\n+  constructor(game) {\n+    this.age = 0;\n+    this.creation = new Date().getTime();\n+    this.game = game;\n+    this.canvas = game.canvas;\n+    this.keyStates = game.keyStates;\n+    this.assets = _.clone(game.assets);\n+    this.layers = [];\n+  }\n+\n+  // A custom initialization function should be implemented by child-class\n+  initialize() {\n+    return this;\n+  }\n+\n+  // Updates each layer\n+  update(span) {\n+    this.layers.forEach(layer => {\n+      layer.age += span;\n+      layer.update(span);\n+    });\n+  }\n+\n+  // Draws each layer\n+  draw(context) {\n+    this.layers.forEach(layer => {\n+      layer.draw(context);\n+    });\n+  }\n+\n+  // Push a new layer to the top of the layers stack\n+  appendLayer(Layer, ...layerArgs) {\n+    let layer = new Layer(this, ...layerArgs);\n+    this.layers.push(layer);\n+    layer.initEventListeners();\n+  }\n+\n+  // Push a new layer to the bottom of the layers stack\n+  prependLayer(Layer, ...layerArgs) {\n+    let layer = new Layer(this, ...layerArgs);\n+    this.layers.unshift(layer);\n+    layer.initEventListeners();\n+  }\n+\n+  // Removes the given layer from the layers stack\n+  removeLayer(layer) {\n+    this.layers = _.without(this.layers, layer);\n+    layer.disposeEventListeners();\n+  }\n+\n+  initEventListeners() {\n+    _.each(this.events, (listener, event) => {\n+      this.game.addEventListener(event, this[listener], this);\n+    });\n+\n+    this.layers.forEach(layer => {\n+      layer.initEventListeners();\n+    });\n+  }\n+\n+  disposeEventListeners() {\n+    _.each(this.events, (listener, event) => {\n+      this.game.removeEventListener(event, this[listener], this);\n+    });\n+\n+    this.layers.forEach(layer => {\n+      layer.disposeEventListeners();\n+    });\n+  }\n+};\n\\ No newline at end of file\ndiff --git a/resources/scripts/engine/sprite.js b/resources/scripts/engine/sprite.js\nnew file mode 100644\nindex 0000000..9813fcc\n--- /dev/null\n+++ b/resources/scripts/engine/sprite.js\n@@ -0,0 +1,58 @@\n+Engine.Sprite = class Sprite {\n+  // An easy representation of a sprite on a canvas, with a set of convenient tools\n+  // for alignment and coloring\n+  constructor(texture) {\n+    this.texture = texture;\n+    this.x = 0;\n+    this.y = 0;\n+    this.width = texture.width;\n+    this.height = texture.height;\n+    this.pivot = { x: 0, y: 0 };\n+    this.opacity = 1;\n+  }\n+\n+  draw(context, offsetX = 0, offsetY = 0) {\n+    context.save();\n+    context.globalAlpha = this.opacity;\n+\n+    // The following switch-case can also be seen as a list of all possible\n+    // alignment modes\n+    switch (this.align) {\n+      case \"top-left\": case \"left-top\": this.pivot = { x: 0, y: 0 }; break;\n+      case \"top-right\": case \"right-top\": this.pivot = { x: this.width, y: 0 }; break;\n+      case \"bottom-left\": case \"left-bottom\": this.pivot = { x: 0, y: this.height }; break;\n+      case \"bottom-right\": case \"right-bottom\": this.pivot = { x: this.width, y: this.height }; break;\n+      case \"middle\": case \"center\": this.pivot = { x: this.width / 2, y: this.height / 2 }; break;\n+      case \"left\": this.pivot = { x: 0, y: this.height / 2 }; break;\n+      case \"top\": this.pivot = { x: this.width / 2, y: 0 }; break;\n+      case \"right\": this.pivot = { x: this.width, y: this.height / 2 }; break;\n+      case \"bottom\": this.pivot = { x: this.width / 2, y: this.height }; break;\n+    }\n+\n+    context.drawImage(\n+      this.texture,\n+      (this.x - this.pivot.x) + offsetX,\n+      (this.y - this.pivot.y) + offsetY,\n+      this.width,\n+      this.height\n+    );\n+\n+    context.restore();\n+  }\n+\n+  // A sprite property (key) can also be resized based on a given percentage.\n+  // The 'relative' argument represents the whole of which the percents are gonna be\n+  // calculated from, and the 'adapters' argument is an array of property names which\n+  // gonna adapt themselves based on the changes made in the given key.\n+  // Usually 'width' goes along with ['height'] adapters, if we\n+  // want to keep their original ratio\n+  setPercentage(key, relative, percents, ...adapters) {\n+    let oldVal = this[key];\n+    let newVal = this[key] = (percents * relative) / 100;\n+    let ratio = newVal / oldVal;\n+\n+    adapters.forEach(adapter => {\n+      this[adapter] *= ratio;\n+    });\n+  }\n+};\n\\ No newline at end of file\ndiff --git a/resources/scripts/extensions.js b/resources/scripts/extensions.js\nnew file mode 100644\nindex 0000000..c6f7d9f\n--- /dev/null\n+++ b/resources/scripts/extensions.js\n@@ -0,0 +1,70 @@\n+Object.defineProperties(Number.prototype, {\n+  // Fixed modulo method which can calculate modulo of negative numbers properly\n+  // e.g., (-803).mod(800) returns 797\n+  \"mod\": {\n+    value(num) {\n+      return ((this % num) + num) % num;\n+    }\n+  },\n+\n+  // Trims number and leaves the number of decimals specified.\n+  // The \"mode\" argument specifies which math function should be invoked\n+  // right after the number has been trimmed.\n+  // e.g. 12.12345.trim(3, \"ceil\") returns 12.124\n+  \"trim\": {\n+    value(decimals, mode = \"round\") {\n+      return Math[mode](this * Math.pow(10, decimals)) / Math.pow(10, decimals);\n+    }\n+  },\n+\n+  // Tells if number is in specified range based on given precision.\n+  // See the \"compare\" method for more information about precision\n+  \"isBetween\": {\n+    value(num1, num2, precision) {\n+      return this.compare(Math.min(num1, num2), \">=\", precision) &&\n+      this.compare(Math.max(num1, num2), \"<=\", precision);\n+    }\n+  },\n+\n+  // Initiates comparison operator between this number and a given number, only here\n+  // a precision can be specified\n+  \"compare\": {\n+    value(num) {\n+      switch (arguments.length) {\n+        case 2:\n+          var precision = arguments[1];\n+          break;\n+        case 3:\n+          var method = arguments[1];\n+          precision = arguments[2];\n+          break;\n+      }\n+\n+      switch (precision) {\n+        // Fixed precision, \"almost equal\" with a deviation of Îµ\n+        case \"f\":\n+          switch (method) {\n+            case \"<\": case \"<=\": return this <= num + Number.EPSILON;\n+            case \">\": case \">=\": return this >= num - Number.EPSILON;\n+            default: return Math.abs(this - num) <= Number.EPSILON;\n+          }\n+        // Pixel precision, round comparison\n+        case \"px\":\n+          switch (method) {\n+            case \"<\": case \"<=\": return Math.round(this) <= Math.round(num);\n+            case \">\": case \">=\": return Math.round(this) >= Math.round(num);\n+            default: return Math.round(this) == Math.round(num);\n+          }\n+        // Exact precision\n+        default:\n+          switch (method) {\n+            case \"<\": return this < num;\n+            case \"<=\": return this <= num;\n+            case \">\": return this > num;\n+            case \">=\": return this >= num;\n+            default: return this === num;\n+          }\n+      }\n+    }\n+  }\n+});\n\\ No newline at end of file\ndiff --git a/resources/scripts/game/entities/snake.js b/resources/scripts/game/entities/snake.js\nnew file mode 100644\nindex 0000000..19f6d97\n--- /dev/null\n+++ b/resources/scripts/game/entities/snake.js\n@@ -0,0 +1,218 @@\n+Game.Entities.Snake = class Snake {\n+  // Represents a snake data-structure which will eventually appear on screen.\n+  // All the properties provided to the constructor are the initial values of\n+  // the snake\n+  constructor(x, y, r, rad, v, color, keyStates, options) {\n+    this.x = x;\n+    this.y = y;\n+    this.r = r;\n+    this.rad = rad;\n+    this.v = v;\n+    this.color = color;\n+    this.keyStates = keyStates;\n+    // A snake is made out of many geometry shapes\n+    this.shapes = [];\n+    // A snake starts with a line\n+    this.currShape = new Engine.Geometry.Line(x, y, x, y);\n+    this.shapes.push(this.currShape);\n+    // A score can be provided in case we want to reserve previous scores from\n+    // recent matches\n+    this.score = options.score || 0;\n+\n+    // Custom keys can be specified\n+    if (options.keys && options.keys) {\n+      this.leftKey = options.keys.left;\n+      this.rightKey = options.keys.right;\n+    }\n+    // Left and right arrow keys will be used by default\n+    else {\n+      this.leftKey = 37; // Left arrow\n+      this.rightKey = 39; // Right arrow\n+    }\n+  }\n+\n+  draw(context) {\n+    // Draw all shapes in the shapes array\n+    this.shapes.forEach(shape => {\n+      context.save();\n+      context.strokeStyle = this.color;\n+      context.lineWidth = 3;\n+      context.beginPath();\n+\n+      // Use a different drawing method for line and circle\n+      if (shape instanceof Engine.Geometry.Line) {\n+        context.moveTo(shape.x1, shape.y1);\n+        context.lineTo(shape.x2, shape.y2);\n+      }\n+      else {\n+        context.arc(shape.x, shape.y, shape.r, shape.rad1, shape.rad2);\n+      }\n+\n+      context.stroke();\n+      context.restore();\n+    });\n+  }\n+\n+  update(span, width, height) {\n+    // Progress made based on elapsed time and velocity\n+    let step = (this.v * span) / 1000;\n+\n+    this.updateShapes(step, width, height);\n+    this.cycleThrough(step, width, height);\n+  }\n+\n+  // Updates shapes array based on progress made\n+  updateShapes(step, width, height, options = {}) {\n+    // Line update logic\n+    if (this.currShape instanceof Engine.Geometry.Line) {\n+      let lastX = options.lastX || this.x;\n+      let lastY = options.lastY || this.y;\n+      this.x = options.x || this.currShape.x2;\n+      this.y = options.y || this.currShape.y2;\n+      this.lastBit = new Engine.Geometry.Line(lastX, lastY, this.x, this.y);\n+    }\n+    // Circle update logic\n+    else {\n+      let lastX = options.lastX || this.currShape.x;\n+      let lastY = options.lastY || this.currShape.y;\n+      let lastR = options.lastR || this.currShape.r;\n+\n+      // Update logic for left rotation\n+      if (this.direction == \"left\") {\n+        let lastRad = this.rad + (0.5 * Math.PI);\n+        let currShapePoint = this.currShape.getPoint(this.currShape.rad1);\n+        this.x = options.x || currShapePoint.x;\n+        this.y = options.y || currShapePoint.y;\n+        this.rad = this.currShape.rad1 - (0.5 * Math.PI);\n+        this.lastBit = new Engine.Geometry.Circle(lastX, lastY, lastR, this.currShape.rad1, lastRad);\n+      }\n+      // Update logic for right rotation\n+      else {\n+        let lastRad = this.rad - (0.5 * Math.PI);\n+        let currShapePoint = this.currShape.getPoint(this.currShape.rad2);\n+        this.x = options.x || currShapePoint.x;\n+        this.y = options.y || currShapePoint.y;\n+        this.rad = this.currShape.rad2 + (0.5 * Math.PI);\n+        this.lastBit = new Engine.Geometry.Circle(lastX, lastY, lastR, lastRad, this.currShape.rad2);\n+      }\n+    }\n+\n+    // Update the direction based on pressed key\n+    if (this.keyStates.get(this.leftKey))\n+      var direction = \"left\";\n+    else if (this.keyStates.get(this.rightKey))\n+      var direction = \"right\";\n+\n+    // If there is no change direction, abort, unless we force it\n+    if (direction != this.direction || options.force) {\n+      this.direction = direction;\n+\n+      // This will push a new shape with new properties, based on the direction\n+      switch (direction) {\n+        case \"left\":\n+          var angle = this.rad - (0.5 * Math.PI);\n+          var rad = this.rad + (0.5 * Math.PI);\n+          var x = this.x + (this.r * Math.cos(angle));\n+          var y = this.y + (this.r * Math.sin(angle));\n+          this.currShape = new Engine.Geometry.Circle(x, y, this.r, rad, rad);\n+          break;\n+        case \"right\":\n+          angle = this.rad + (0.5 * Math.PI);\n+          rad = this.rad - (0.5 * Math.PI);\n+          x = this.x + (this.r * Math.cos(angle));\n+          y = this.y + (this.r * Math.sin(angle));\n+          this.currShape = new Engine.Geometry.Circle(x, y, this.r, rad, rad);\n+          break;\n+        default:\n+          this.currShape = new Engine.Geometry.Line(this.x, this.y, this.x, this.y);\n+      }\n+\n+      this.shapes.push(this.currShape);\n+    }\n+\n+    // Extend the recent shape based on progress made\n+    switch (direction) {\n+      case \"left\":\n+        this.currShape.rad1 -= step / this.r;\n+        break;\n+      case \"right\":\n+        this.currShape.rad2 += step / this.r;\n+        break;\n+      default:\n+        this.currShape.x2 += step * Math.cos(this.rad);\n+        this.currShape.y2 += step * Math.sin(this.rad);\n+    }\n+  }\n+\n+  // Handles case where snake is out limits and we need to render it from\n+  // the other side of the canvas\n+  cycleThrough(step, width, height) {\n+    let intersectionPoint = this.getCanvasIntersection(width, height);\n+\n+    if (!intersectionPoint) return;\n+\n+    intersectionPoint = intersectionPoint[0];\n+\n+    // Re-calculate position based on canvas bounds\n+    if (intersectionPoint.x % width == 0)\n+      this.x = (this.x - width).mod(width);\n+    if (intersectionPoint.y % height == 0)\n+      this.y = (this.y - height).mod(height);\n+\n+    // Update shapes again based on custom properties\n+    this.updateShapes(step, width, height, {\n+      force: true,\n+      lastX: this.x,\n+      lastY: this.y,\n+      x: this.x,\n+      y: this.y\n+    });\n+  }\n+\n+  // Gets intersection points between last bit and own shapes\n+  getSelfIntersection() {\n+    if (this.currShape instanceof Engine.Geometry.Circle &&\n+       Math.abs(this.currShape.rad1 - this.currShape.rad2) >= 2 * Math.PI) {\n+      if (this.direction == \"left\")\n+        var rad = this.currShape.rad1;\n+      else\n+        var rad = this.currShape.rad2;\n+\n+      return this.currShape.getPoint(rad);\n+    }\n+\n+    let result;\n+\n+    this.shapes.slice(0, -2).some(shape =>\n+      result = this.lastBit.getIntersection(shape)\n+    );\n+\n+    return result;\n+  }\n+\n+  // Returns intersection points between snakes\n+  getSnakeIntersection(snake) {\n+    let result;\n+\n+    snake.shapes.some(shape =>\n+      // Only last bit is relevant, if we reached this point it means that\n+      // previous intersection will definitely fail\n+      result = this.lastBit.getIntersection(shape)\n+    );\n+\n+    return result;\n+  }\n+\n+  // Returns intersection points between snake and canvas\n+  getCanvasIntersection(width, height) {\n+    // Canvas polygon\n+    let canvasPolygon = new Engine.Geometry.Polygon(\n+      [0, 0, width, 0],\n+      [width, 0, width, height],\n+      [width, height, 0, height],\n+      [0, height, 0, 0]\n+    );\n+\n+    return canvasPolygon.getIntersection(this.lastBit);\n+  }\n+};\n\\ No newline at end of file\ndiff --git a/resources/scripts/game/screens/menu/index.js b/resources/scripts/game/screens/menu/index.js\nnew file mode 100644\nindex 0000000..1242041\n--- /dev/null\n+++ b/resources/scripts/game/screens/menu/index.js\n@@ -0,0 +1,63 @@\n+Game.Screens.Menu = class Menu extends Engine.Screen {\n+  get events() {\n+    return {\n+      \"keydown\": \"onKeyDown\"\n+    }\n+  }\n+\n+  initialize() {\n+    // Initialize snake logo sprite\n+    this.logoSprite = new Engine.Sprite(this.assets.logoTexture);\n+    this.logoSprite.setPercentage(\"width\", this.width, 30, \"height\");\n+\n+    // Initialize instructions sprite\n+    let instructionsTexture = this.assets.minecraftiaFont.createTexture(\"Press a key to start\");\n+    let instructionsSprite = new Engine.Sprite(instructionsTexture);\n+    instructionsSprite.align = \"center\";\n+    instructionsSprite.setPercentage(\"width\", this.width, 35, \"height\");\n+    instructionsSprite.x = this.width / 2;\n+    instructionsSprite.y = this.height / 2;\n+\n+    // Create flickering animation for instructions sprite\n+    this.instructionsAnim = new Engine.Animations.Keyframe(instructionsSprite, [\n+      {\n+        opacity: 1,\n+        frame: 0\n+      },\n+      {\n+        opacity: 0,\n+        frame: 2000\n+      }\n+    ]);\n+\n+    // Play it repeatedly, back and forth\n+    this.instructionsAnim.repMode = \"full\";\n+    this.instructionsAnim.play();\n+  }\n+\n+  unload() {\n+    // Dispose the following assets to prevent memory leaks\n+    return \"logoTexture\";\n+  }\n+\n+  draw(context) {\n+    this.logoSprite.draw(context);\n+    this.instructionsAnim.draw(context);\n+  }\n+\n+  update(span) {\n+    // On key press, proceed to play screen\n+    if (this.keyPressed) {\n+      this.game.changeScreen(Game.Screens.Play);\n+    }\n+    // Else, just update animation\n+    else {\n+      this.instructionsAnim.update(span);\n+    }\n+  }\n+\n+  // Register key press\n+  onKeyDown(e) {\n+    this.keyPressed = true;\n+  }\n+};\n\\ No newline at end of file\ndiff --git a/resources/scripts/game/screens/play/index.js b/resources/scripts/game/screens/play/index.js\nnew file mode 100644\nindex 0000000..02f5e6c\n--- /dev/null\n+++ b/resources/scripts/game/screens/play/index.js\n@@ -0,0 +1,19 @@\n+Game.Screens.Play = class Play extends Engine.Screen {\n+  get events() {\n+    return {\n+      \"keydown\": \"onKeyDown\"\n+    }\n+  }\n+\n+  // The ready screen will be the initial screen\n+  initialize(game, snakes) {\n+    this.appendLayer(Game.Screens.Play.Ready, snakes);\n+  }\n+\n+  onKeyDown() {\n+    // Once escape is pressed, return to main menu screen\n+    if (this.keyStates.get(27)) {\n+      this.game.changeScreen(Game.Screens.Menu);\n+    }\n+  }\n+};\n\\ No newline at end of file\ndiff --git a/resources/scripts/game/screens/play/ready.js b/resources/scripts/game/screens/play/ready.js\nnew file mode 100644\nindex 0000000..fee8652\n--- /dev/null\n+++ b/resources/scripts/game/screens/play/ready.js\n@@ -0,0 +1,62 @@\n+Game.Screens.Play.Ready = class Ready extends Engine.Layer {\n+  get events() {\n+    return {\n+      \"keydown\": \"onKeyDown\"\n+    };\n+  }\n+\n+  constructor(screen, snakes) {\n+    super(screen);\n+\n+    this.snakes = snakes;\n+\n+    // Create \"ready\" sprite and set its properties\n+    let readyTexture = this.assets.minecraftiaFont.createTexture(\"Ready\");\n+    let readySprite = new Engine.Sprite(readyTexture);\n+    readySprite.align = \"center\";\n+    readySprite.setPercentage(\"width\", this.width, 15, \"height\");\n+\n+    // Create fade out animation for \"ready\" sprite\n+    this.readyAnim = new Engine.Animations.Keyframe(readySprite, [\n+      {\n+        x: this.width / 2,\n+        y: this.height / 2,\n+        opacity: 1,\n+        frame: 0\n+      },\n+      {\n+        y: this.height / 3,\n+        opacity: 0,\n+        frame: 700\n+      }\n+    ]);\n+  }\n+\n+  draw(context) {\n+    this.readyAnim.draw(context);\n+  }\n+\n+  update(span) {\n+    if (!this.ready) return;\n+\n+    if (this.readyAnim.playing) {\n+      this.readyAnim.update(span);\n+    }\n+    // Once animation is finished, dispose layer\n+    else {\n+      this.screen.removeLayer(this);\n+    }\n+  }\n+\n+  onKeyDown() {\n+    // One time event\n+    this.disposeEventListeners()\n+\n+    // This will start playing the animation\n+    this.ready = true;\n+    this.readyAnim.play();\n+\n+    // Start the game in the background\n+    this.screen.prependLayer(Game.Screens.Play.Snake, this.snakes);\n+  }\n+};\n\\ No newline at end of file\ndiff --git a/resources/scripts/game/screens/play/score.js b/resources/scripts/game/screens/play/score.js\nnew file mode 100644\nindex 0000000..7da223e\n--- /dev/null\n+++ b/resources/scripts/game/screens/play/score.js\n@@ -0,0 +1,66 @@\n+Game.Screens.Play.Score = class Score extends Engine.Layer {\n+  constructor(screen, snakes) {\n+    super(screen);\n+\n+    this.snakes = snakes;\n+    this.scoreSprites = [];\n+    this.scores = [];\n+\n+    // It's important to match indexes to each snake since the number of snakes\n+    // can be reduced along the way as we play\n+    snakes.forEach((snake, index) => {\n+      snake.index = index;\n+    });\n+  }\n+\n+  draw(context) {\n+    this.scoreSprites.forEach((scoreSprite) => {\n+      scoreSprite.draw(context);\n+    });\n+  }\n+\n+  update(span) {\n+    this.snakes.forEach(snake => {\n+      let index = snake.index;\n+      if (this.scores[index] == snake.score) return;\n+\n+      // The sprite might be changed along the way so it's important to recreate it\n+      // over and over again. If no change was made the cache will be used by the engine\n+      this.scoreSprites[index] = this.createScoreSprite(snake);\n+      this.scores[index] = snake.score;\n+    });\n+  }\n+\n+  createScoreSprite(snake) {\n+    let minecraftiaFont = this.assets.minecraftiaFont;\n+    minecraftiaFont.save();\n+    minecraftiaFont.color = snake.color;\n+\n+    // Create a score sprite for the snake\n+    let scoreTexture = minecraftiaFont.createTexture(`${snake.score}`, {\n+      noOffsets: true,\n+      noSpaces: true\n+    });\n+\n+    let scoreSprite = new Engine.Sprite(scoreTexture);\n+\n+    // Size of score board is dynamic to screen size\n+    scoreSprite.setPercentage(\"width\", this.width, 4, \"height\");\n+\n+    // Set alignment modes.\n+    // Once we add more snakes we should add more cases here\n+    switch (snake.index) {\n+      case 0:\n+        scoreSprite.align = \"top-left\";\n+        break;\n+      case 1:\n+        scoreSprite.align = \"top-right\";\n+        scoreSprite.x = this.width;\n+        break;\n+    }\n+\n+    // Restore the font to its original color\n+    minecraftiaFont.restore();\n+    return scoreSprite;\n+  }\n+};\n\\ No newline at end of file\ndiff --git a/resources/scripts/game/screens/play/snake.js b/resources/scripts/game/screens/play/snake.js\nnew file mode 100644\nindex 0000000..66a0b92\n--- /dev/null\n+++ b/resources/scripts/game/screens/play/snake.js\n@@ -0,0 +1,88 @@\n+Game.Screens.Play.Snake = class Snake extends Engine.Layer {\n+  constructor(screen, snakes = []) {\n+    super(screen);\n+\n+    // Red snake\n+    this.snakes = [\n+      new Game.Entities.Snake(\n+        this.width / 4,\n+        this.height / 4,\n+        50,\n+        Math.PI / 4,\n+        100,\n+        \"FireBrick\",\n+        this.keyStates,\n+        {\n+          // Use score from previous matches\n+          score: snakes[0] && snakes[0].score,\n+          keys: {\n+            left: 37, // Left key\n+            right: 39 // RIght key\n+        }\n+      }),\n+\n+      // Blue snake\n+      new Game.Entities.Snake(\n+        (this.width / 4) * 3,\n+        (this.height / 4) * 3,\n+        50,\n+        (-Math.PI / 4) * 3,\n+        100,\n+        \"DodgerBlue\",\n+        this.keyStates,\n+        {\n+          score: snakes[1] && snakes[1].score,\n+          keys: {\n+            left: 65, // 'a' key\n+            right: 68 // 'b' key\n+        }\n+      })\n+    ];\n+\n+    // Show score board for newly created snakes\n+    screen.appendLayer(Game.Screens.Play.Score, this.snakes);\n+  }\n+\n+  draw(context) {\n+    // Draw each snake in the snakes array\n+    this.snakes.forEach(snake => snake.draw(context));\n+  }\n+\n+  update(span) {\n+    if (!this.snakes.length) return;\n+\n+    // Storing original snakes array for future use, since it might get changed\n+    let snakes = this.snakes.slice();\n+\n+    snakes.forEach((snake, index) => {\n+      snake.update(span, this.width, this.height);\n+      // Disqualify if intersected with self\n+      if (snake.getSelfIntersection()) return this.snakes.splice(index, 1);\n+\n+      snakes.forEach((opponent) => {\n+        // Don't scan for intersection with self, obviously this will always be true\n+        if (opponent === snake) return;\n+        // Disqualify if intersected with opponent\n+        if (snake.getSnakeIntersection(opponent)) return this.snakes.splice(index, 1);\n+      });\n+    });\n+\n+    // There can be only one winner, or a tie (very rare, most likely not to happen)\n+    // If the match is already finished, skip the next steps since they are not relevant\n+    if (this.snakes.length > 1 || this.matchFinished) return;\n+\n+    // The winner is the \"last snake standing\"\n+    let winner = this.snakes[0];\n+    // If this is not a tie, which is a very rare case, increase the winner's score\n+    if (winner) winner.score++;\n+\n+    // Show a message saying the result (e.g., \"red snake wins\")\n+    this.screen.appendLayer(Game.Screens.Play.Win, snakes, winner);\n+\n+    // Indicates whether we should update the score counter or not.\n+    // In addition, will prevent from the 'winner' message from appearing multiple times,\n+    // otherwise memory is gonna be wasted despite the fact that we're not going to see\n+    // any visual difference\n+    this.matchFinished = true;\n+  }\n+};\n\\ No newline at end of file\ndiff --git a/resources/scripts/game/screens/play/win.js b/resources/scripts/game/screens/play/win.js\nnew file mode 100644\nindex 0000000..220745f\n--- /dev/null\n+++ b/resources/scripts/game/screens/play/win.js\n@@ -0,0 +1,43 @@\n+Game.Screens.Play.Win = class Win extends Engine.Layer {\n+  constructor(screen, snakes, winner) {\n+    super(screen);\n+\n+    this.snakes = snakes;\n+    this.winner = winner;\n+    // ttl stands for \"time to live\", which means, this layer is going to be\n+    // disposed after 3 seconds\n+    this.ttl = 3000;\n+\n+    // If there is a winner\n+    if (this.winner) {\n+      // Message could be something like \"RED SNAKE WINS\"\n+      var text = `${this.winner.color.toUpperCase()} SNAKE WINS`;\n+      var percent = 40;\n+    }\n+    // If there is a tie\n+    else {\n+      var text = 'TIE';\n+      var percent = 15;\n+    }\n+\n+    // Create winner sprite and set its properties\n+    let winnerTexture = this.assets.minecraftiaFont.createTexture(text);\n+    this.winnerSprite = new Engine.Sprite(winnerTexture);\n+    this.winnerSprite.align = \"center\";\n+    this.winnerSprite.setPercentage(\"width\", this.width, percent, \"height\");\n+    this.winnerSprite.x = this.width / 2;\n+    this.winnerSprite.y = this.height / 2;\n+  }\n+\n+  draw(context) {\n+    this.winnerSprite.draw(context);\n+  }\n+\n+  update(span) {\n+    // If limit not yet reached, abort\n+    if (this.age < this.ttl) return;\n+\n+    // Show \"ready\" message all over again, only this time use the updated score board\n+    this.screen.game.changeScreen(Game.Screens.Play, this.snakes);\n+  }\n+};\n\\ No newline at end of file\ndiff --git a/resources/scripts/game/screens/splash/index.js b/resources/scripts/game/screens/splash/index.js\nnew file mode 100644\nindex 0000000..9b3d226\n--- /dev/null\n+++ b/resources/scripts/game/screens/splash/index.js\n@@ -0,0 +1,65 @@\n+Game.Screens.Splash = class Splash extends Engine.Screen {\n+  initialize() {\n+    // Create splash sprite and set its properties\n+    let splashSprite = new Engine.Sprite(this.assets.splashTexture);\n+    splashSprite.align = \"center\";\n+    splashSprite.x = this.width / 2;\n+\n+    // Create splash sprite animation\n+    this.splashAnim = new Engine.Animations.Keyframe(splashSprite, [\n+      {\n+        y: (this.height / 2) - 30,\n+        width: splashSprite.width / 4,\n+        height: splashSprite.height / 4,\n+        opacity: 0,\n+        easing: \"in\",\n+        frame: 0\n+      },\n+      {\n+        y: this.height / 2,\n+        width: (splashSprite.width / 3) + (splashSprite.width * 0.05),\n+        height: (splashSprite.height / 3) + (splashSprite.height * 0.05),\n+        opacity: 1,\n+        frame: 3000\n+      },\n+      {\n+        frame: 3500\n+      }\n+    ]);\n+\n+    // Start playing animation\n+    this.splashAnim.play();\n+  }\n+\n+  load(assetsLoader) {\n+    // Load assets\n+    let minecraftiaFont = assetsLoader.font(\"/fonts/minecraftia\");\n+    let logoTexture = assetsLoader.texture(\"/textures/logo\");\n+    let splashTexture = assetsLoader.texture(\"/textures/splash\");\n+\n+    // These are global assets which will be shared among all screens until manually\n+    // disposed. We use the time gap created by the splash animation to load necessary\n+    // assets without wasting any time\n+    this.game.extendAssets({\n+      minecraftiaFont,\n+      logoTexture\n+    });\n+\n+    // These are local assets which will be disposed along with the screen\n+    return { splashTexture };\n+  }\n+\n+  draw(context) {\n+    this.splashAnim.draw(context);\n+  }\n+\n+  update(span) {\n+    if (this.splashAnim.playing) {\n+      this.splashAnim.update(span);\n+    }\n+    // Once animation has stopped play switch to main menu\n+    else {\n+      this.game.changeScreen(Game.Screens.Menu);\n+    }\n+  }\n+};\n\\ No newline at end of file\ndiff --git a/resources/scripts/main.js b/resources/scripts/main.js\nnew file mode 100644\nindex 0000000..accd7c6\n--- /dev/null\n+++ b/resources/scripts/main.js\n@@ -0,0 +1,5 @@\n+document.addEventListener(\"DOMContentLoaded\", function(event) {\n+  let game = new Engine.Game(document.getElementById(\"gameCanvas\"), false);\n+  game.changeScreen(Game.Screens.Splash);\n+  game.play();\n+});\n\\ No newline at end of file\ndiff --git a/resources/scripts/namespaces.js b/resources/scripts/namespaces.js\nnew file mode 100644\nindex 0000000..dfba85c\n--- /dev/null\n+++ b/resources/scripts/namespaces.js\n@@ -0,0 +1,9 @@\n+Game = {\n+  Entities: {},\n+  Screens: {}\n+};\n+\n+Engine = {\n+  Animations: {},\n+  Geometry: {}\n+};\n\\ No newline at end of file\ndiff --git a/resources/scripts/specs/engine/geometry/circle.js b/resources/scripts/specs/engine/geometry/circle.js\nnew file mode 100644\nindex 0000000..669bcd5\n--- /dev/null\n+++ b/resources/scripts/specs/engine/geometry/circle.js\n@@ -0,0 +1,144 @@\n+describe(\"Engine.Geometry.Circle class\", function() {\n+  beforeEach(function() {\n+    this.circle = new Engine.Geometry.Circle(1, 1, 5, 0, 1.5 * Math.PI);\n+  });\n+\n+  describe(\"getX method\", function() {\n+    describe(\"given inranged rad\", function() {\n+      it(\"returns x\", function() {\n+        expect(this.circle.getX(0 * Math.PI)).toBeCloseTo(6);\n+        expect(this.circle.getX(0.5 * Math.PI)).toBeCloseTo(1);\n+        expect(this.circle.getX(1 * Math.PI)).toBeCloseTo(-4);\n+        expect(this.circle.getX(1.5 * Math.PI)).toBeCloseTo(1);\n+      });\n+    });\n+\n+    describe(\"given outranged rad\", function() {\n+      it(\"returns nothing\", function() {\n+        expect(this.circle.getX(2 * Math.PI)).toBeUndefined();\n+      });\n+    });\n+  });\n+\n+  describe(\"getY method\", function() {\n+    describe(\"given inranged rad\", function() {\n+      it(\"returns y\", function() {\n+        expect(this.circle.getY(0 * Math.PI)).toBeCloseTo(1);\n+        expect(this.circle.getY(0.5 * Math.PI)).toBeCloseTo(6);\n+        expect(this.circle.getY(1 * Math.PI)).toBeCloseTo(1);\n+        expect(this.circle.getY(1.5 * Math.PI)).toBeCloseTo(-4);\n+      });\n+    });\n+\n+    describe(\"given outranged rad\", function() {\n+      it(\"returns nothing\", function() {\n+        expect(this.circle.getY(2 * Math.PI)).toBeUndefined();\n+      });\n+    });\n+  });\n+\n+  describe(\"getRad method\", function() {\n+    describe(\"given inranged point\", function() {\n+      it(\"returns rad\", function() {\n+        let x = -3.0450849718747346;\n+        let y = 3.9389262614623686;\n+        expect(this.circle.getRad(x, y)).toBeCloseTo(0.8 * Math.PI);\n+      });\n+    });\n+\n+    describe(\"given outranged point\", function() {\n+      it(\"returns nothing\", function() {\n+        let x = 5.045084971874736;\n+        let y = -1.9389262614623664;\n+        expect(this.circle.getRad(x, y)).toBeUndefined();\n+      });\n+    });\n+  });\n+\n+  describe(\"getCircleIntersection method\", function() {\n+    describe(\"given circle with 2 intersection points\", function() {\n+      it(\"returns array with intersection points\", function() {\n+        let circle = new Engine.Geometry.Circle(-5, 1, 5, 0, 2 * Math.PI);\n+\n+        expect(this.circle.getCircleIntersection(circle)).toEqual([\n+          { x: -2, y: -3 },\n+          { x: -2, y: 5 }\n+        ]);\n+      });\n+    });\n+\n+    describe(\"given circle with 1 intersection points\", function() {\n+      it(\"returns array with intersection point\", function() {\n+        let circle = new Engine.Geometry.Circle(-5, 1, 5, 0, 1 * Math.PI);\n+\n+        expect(this.circle.getCircleIntersection(circle)).toEqual([\n+          { x: -2, y: 5 }\n+        ]);\n+      });\n+    });\n+\n+    describe(\"given kissing circle\", function() {\n+      it(\"returns array with intersection point\", function() {\n+        let circle = new Engine.Geometry.Circle(-9, 1, 5, 0, 2 * Math.PI);\n+\n+        expect(this.circle.getCircleIntersection(circle)).toEqual([\n+          { x: -4, y: 1 }\n+        ]);\n+      });\n+    });\n+\n+    describe(\"given outer circle\", function() {\n+      it(\"returns nothing\", function() {\n+        let circle = new Engine.Geometry.Circle(10, 10, 2, 0, 2 * Math.PI);\n+        expect(this.circle.getCircleIntersection(circle)).toBeUndefined();\n+      });\n+    });\n+\n+    describe(\"given inner circle\", function() {\n+      it(\"nothing\", function() {\n+        let circle = new Engine.Geometry.Circle(1, 1, 2, 0, 2 * Math.PI);\n+        expect(this.circle.getCircleIntersection(circle)).toBeUndefined();\n+      });\n+    });\n+  });\n+\n+  describe(\"getLineIntersection method\", function() {\n+    describe(\"given line with 2 intersection points\", function() {\n+      it(\"returns array with intersection points\", function() {\n+        let line = new Engine.Geometry.Line(-10, 1, 10, 1);\n+\n+        expect(this.circle.getLineIntersection(line)).toEqual([\n+          { x: 6, y: 1 },\n+          { x: -4, y: 1 }\n+        ]);\n+      });\n+    });\n+\n+    describe(\"given line with 1 intersection point\", function() {\n+      it(\"returns array with intersection point\", function() {\n+        let line = new Engine.Geometry.Line(-10, 1, 1, 1);\n+\n+        expect(this.circle.getLineIntersection(line)).toEqual([\n+          { x: -4, y: 1 }\n+        ]);\n+      });\n+    });\n+\n+    describe(\"given kissing line\", function() {\n+      it(\"returns array with intersection point\", function() {\n+        let line = new Engine.Geometry.Line(-10, 6, 10, 6);\n+\n+        expect(this.circle.getLineIntersection(line)).toEqual([\n+          { x: 1, y: 6 }\n+        ]);\n+      });\n+    });\n+\n+    describe(\"given outranged line\", function() {\n+      it(\"returns nothing\", function() {\n+        let line = new Engine.Geometry.Line(-10, 10, 10, 10);\n+        expect(this.circle.getLineIntersection(line)).toBeUndefined();\n+      });\n+    });\n+  });\n+});\n\\ No newline at end of file\ndiff --git a/resources/scripts/specs/engine/geometry/line.js b/resources/scripts/specs/engine/geometry/line.js\nnew file mode 100644\nindex 0000000..c65ca88\n--- /dev/null\n+++ b/resources/scripts/specs/engine/geometry/line.js\n@@ -0,0 +1,78 @@\n+describe(\"Engine.Geometry.Line class\", function() {\n+  beforeEach(function() {\n+    this.line = new Engine.Geometry.Line(-5, -5, 5, 5);\n+  });\n+\n+  describe(\"getX method\", function() {\n+    describe(\"given inranged y\", function() {\n+      it(\"returns x\", function() {\n+        expect(this.line.getX(1)).toBeCloseTo(1);\n+      });\n+    });\n+\n+    describe(\"given outranged y\", function() {\n+      it(\"returns nothing\", function() {\n+        expect(this.line.getX(10)).toBeUndefined();\n+      });\n+    });\n+  });\n+\n+  describe(\"getY method\", function() {\n+    describe(\"given inranged x\", function() {\n+      it(\"returns y\", function() {\n+        expect(this.line.getY(1)).toBeCloseTo(1);\n+      });\n+    });\n+\n+    describe(\"given outranged x\", function() {\n+      it(\"returns nothing\", function() {\n+        expect(this.line.getY(10)).toBeUndefined();\n+      });\n+    });\n+  });\n+\n+  describe(\"hasPoint method\", function() {\n+    describe(\"given contained point\", function() {\n+      it(\"returns true\", function() {\n+        let x = 1;\n+        let y = 1;\n+        expect(this.line.hasPoint(x, y)).toBeTruthy();\n+      });\n+    });\n+\n+    describe(\"given uncontained point\", function() {\n+      it(\"returns false\", function() {\n+        let x = 10;\n+        let y = 10;\n+        expect(this.line.hasPoint(x, y)).toBeFalsy();\n+      });\n+    });\n+  });\n+\n+  describe(\"getLineIntersection method\", function() {\n+    describe(\"given intersecting line\", function() {\n+      it(\"returns intersection point\", function() {\n+        let line = new Engine.Geometry.Line(1, -5, 1, 5);\n+\n+        expect(this.line.getLineIntersection(line)).toEqual({\n+          x: 1,\n+          y: 1\n+        });\n+      });\n+    });\n+\n+    describe(\"given parallel line\", function() {\n+      it(\"returns nothing\", function() {\n+        let line = new Engine.Geometry.Line(-5, -6, 5, 4);\n+        expect(this.line.getLineIntersection(line)).toBeUndefined();\n+      });\n+    });\n+\n+    describe(\"given outranged line\", function() {\n+      it(\"returns nothing\", function() {\n+        let line = new Engine.Geometry.Line(10, 10, 10, 15);\n+        expect(this.line.getLineIntersection(line)).toBeUndefined();\n+      });\n+    });\n+  });\n+});\n\\ No newline at end of file\ndiff --git a/resources/scripts/specs/engine/geometry/polygon.js b/resources/scripts/specs/engine/geometry/polygon.js\nnew file mode 100644\nindex 0000000..6c142d8\n--- /dev/null\n+++ b/resources/scripts/specs/engine/geometry/polygon.js\n@@ -0,0 +1,96 @@\n+describe(\"Engine.Geometry.Polygon class\", function() {\n+  beforeEach(function() {\n+    this.polygon = new Engine.Geometry.Polygon(\n+      [0, 0, 5, 0],\n+      [5, 0, 5, 5],\n+      [5, 5, 0, 5],\n+      [0, 5, 0, 0]\n+    );\n+  });\n+\n+  describe(\"hasPoint method\", function() {\n+    describe(\"given contained point\", function() {\n+      it(\"returns true\", function() {\n+        let x = 5;\n+        let y = 3;\n+        expect(this.polygon.hasPoint(x, y)).toBeTruthy();\n+      });\n+    });\n+\n+    describe(\"given outranged point\", function() {\n+      it(\"returns false\", function() {\n+        let x = 10;\n+        let y = 10;\n+        expect(this.polygon.hasPoint(x, y)).toBeFalsy();\n+      });\n+    });\n+  });\n+\n+  describe(\"getLineIntersection method\", function() {\n+    describe(\"given intersecting line\", function() {\n+      it(\"returns intersection point\", function() {\n+        let line = new Engine.Geometry.Line(0, 1, 5, 4);\n+\n+        expect(this.polygon.getLineIntersection(line)).toEqual([\n+          { x: 5, y: 4 },\n+          { x: -0, y: 1 }\n+        ]);\n+      });\n+    });\n+\n+    describe(\"given outranged line\", function() {\n+      it(\"returns nothing\", function() {\n+        let line = new Engine.Geometry.Line(10, 11, 15, 14);\n+\n+        expect(this.polygon.getLineIntersection(line)).toBeUndefined();\n+      });\n+    });\n+  });\n+\n+  describe(\"getCircleIntersection method\", function() {\n+    describe(\"given circle with 2 intersection points\", function() {\n+      it(\"returns array with intersection points\", function() {\n+        let circle = new Engine.Geometry.Circle(0, 0, 2, 0, 2 * Math.PI);\n+\n+        expect(this.polygon.getCircleIntersection(circle)).toEqual([\n+          { x: 2, y: 0 },\n+          { x: 0, y: 2 }\n+        ]);\n+      });\n+    });\n+\n+    describe(\"given circle with 1 intersection points\", function() {\n+      it(\"returns array with intersection point\", function() {\n+        let circle = new Engine.Geometry.Circle(0, 0, 2, 0, 0.25 * Math.PI);\n+\n+        expect(this.polygon.getCircleIntersection(circle)).toEqual([\n+          { x: 2, y: 0 }\n+        ]);\n+      });\n+    });\n+\n+    describe(\"given kissing circle\", function() {\n+      it(\"returns array with intersection point\", function() {\n+        let circle = new Engine.Geometry.Circle(-3, 3, 3, 0, 2 * Math.PI);\n+\n+        expect(this.polygon.getCircleIntersection(circle)).toEqual([\n+          { x: 0, y: 3 }\n+        ]);\n+      });\n+    });\n+\n+    describe(\"given outer circle\", function() {\n+      it(\"returns nothing\", function() {\n+        let circle = new Engine.Geometry.Circle(10, 10, 2, 0, 2 * Math.PI);\n+        expect(this.polygon.getCircleIntersection(circle)).toBeUndefined();\n+      });\n+    });\n+\n+    describe(\"given inner circle\", function() {\n+      it(\"nothing\", function() {\n+        let circle = new Engine.Geometry.Circle(2.5, 2.5, 2, 0, 2 * Math.PI);\n+        expect(this.polygon.getCircleIntersection(circle)).toBeUndefined();\n+      });\n+    });\n+  });\n+});\n\\ No newline at end of file\ndiff --git a/resources/styles/game.css b/resources/styles/game.css\nnew file mode 100644\nindex 0000000..35f8e86\n--- /dev/null\n+++ b/resources/styles/game.css\n@@ -0,0 +1,6 @@\n+#gameCanvas {\n+  display: block;\n+  margin: auto;\n+  border-style: solid;\n+  border-width: 1px;\n+}\n\\ No newline at end of file\ndiff --git a/routes/endpoints.js b/routes/endpoints.js\nnew file mode 100644\nindex 0000000..8e71902\n--- /dev/null\n+++ b/routes/endpoints.js\n@@ -0,0 +1,80 @@\n+const Pack = require(\"../package.json\");\n+\n+register.attributes = {\n+  name: \"endpoints\",\n+  version: Pack.version\n+};\n+\n+function register(server, options, next) {\n+  // Scripts endpoint\n+  server.route({\n+    method: \"GET\",\n+    path: \"/scripts/{path*}\",\n+    handler: {\n+      directory: {\n+        path: \"./resources/scripts/\"\n+      }\n+    }\n+  });\n+\n+  // Style-sheets endpoint\n+  server.route({\n+    method: \"GET\",\n+    path: \"/styles/{path*}\",\n+    handler: {\n+      directory: {\n+        path: \"./resources/styles/\"\n+      }\n+    }\n+  });\n+\n+  // Libraries endpoint\n+  server.route({\n+    method: \"GET\",\n+    path: \"/libs/{path*}\",\n+    handler: {\n+      directory: {\n+        path: \"./resources/libs/\"\n+      }\n+    }\n+  });\n+\n+  // Images endpoint\n+  server.route({\n+    method: \"GET\",\n+    path: \"/images/{path*}\",\n+    handler: {\n+      directory: {\n+        path: \"./resources/images/\"\n+      }\n+    }\n+  });\n+\n+  // Textures endpoint\n+  server.route({\n+    method: \"GET\",\n+    path: \"/textures/{path*}\",\n+    handler: {\n+      directory: {\n+        path: \"./resources/assets/textures/\"\n+      }\n+    }\n+  });\n+\n+  // Fonts endpoint\n+  server.route({\n+    method: \"GET\",\n+    path: \"/fonts/{path*}\",\n+    handler: {\n+      directory: {\n+        path: \"./resources/assets/fonts/\"\n+      }\n+    }\n+  });\n+\n+  next();\n+}\n+\n+module.exports = {\n+  register\n+};\n\\ No newline at end of file\ndiff --git a/routes/pages.js b/routes/pages.js\nnew file mode 100644\nindex 0000000..a5c6afe\n--- /dev/null\n+++ b/routes/pages.js\n@@ -0,0 +1,35 @@\n+const Hapi = require(\"hapi\");\n+const Pack = require(\"../package.json\");\n+const Permitter = require(\"../helpers/permitter\");\n+\n+register.attributes = {\n+  name: \"pages\",\n+  version: Pack.version\n+};\n+\n+function register(server, options, next) {\n+  server.route({ method: \"GET\", path: \"/\", handler: getGame });\n+  server.route({ method: \"GET\", path: \"/test\", handler: getSpecRunner });\n+\n+  next();\n+}\n+\n+// Serve game page\n+function getGame(req, rep) {\n+  let path = \"./views/game.html\";\n+  let permissions = [];\n+\n+  Permitter.file(path, permissions, req, rep);\n+}\n+\n+// Serve test page\n+function getSpecRunner(req, rep) {\n+  let path = \"./views/spec_runner.html\";\n+  let permissions = [];\n+\n+  Permitter.file(path, permissions, req, rep);\n+}\n+\n+module.exports = {\n+  register\n+};\n\\ No newline at end of file\ndiff --git a/server.js b/server.js\nnew file mode 100644\nindex 0000000..f5d8027\n--- /dev/null\n+++ b/server.js\n@@ -0,0 +1,58 @@\n+const Async = require(\"async\");\n+const Hapi = require(\"hapi\");\n+const Inert = require(\"inert\");\n+const Endpoints = require(\"./routes/endpoints\");\n+const Pages = require(\"./routes/pages\");\n+const IpGrabber = require(\"./helpers/ip_grabber\");\n+\n+let localIp = IpGrabber.local();\n+let port = 8000;\n+\n+// Initialize a new server\n+let server = new Hapi.Server({\n+  connections: {\n+    routes: {\n+      files: {\n+        // Served files will be relative to current directory\n+        relativeTo: __dirname\n+      }\n+    }\n+  }\n+});\n+\n+server.connection({ port: process.env.PORT || port });\n+\n+// Report each response made\n+server.ext(\"onPreResponse\", (req, rep) => {\n+  let res = req.response;\n+\n+  console.log(\"Outcoming response:\");\n+  console.log(`in: ${new Date}`);\n+  console.log(`to: ${req.info.remoteAddress}`);\n+  console.log(`method: ${req.method}`);\n+  console.log(`url: ${req.url.path}`);\n+  console.log(`status: ${res.statusCode || res.output.statusCode}`);\n+  console.log();\n+\n+  rep.continue();\n+});\n+\n+// Register all routes and plug-ins\n+Async.series([\n+  next => server.register(Inert, next),\n+  next => server.register(Endpoints, next),\n+  next => server.register(Pages, next),\n+  // Once registrations are finished, start the server\n+  next => server.start(next)\n+// Print message once started\n+], (err) => {\n+  if (err) throw err;\n+\n+  console.log();\n+  console.log(\"---------- -------- ------ ---- --\");\n+  console.log(\"----- ---- --- -- -\");\n+  console.log(`Server running at ${localIp}:${port}`);\n+  console.log(\"----- ---- --- -- -\");\n+  console.log(\"---------- -------- ------ ---- --\");\n+  console.log();\n+});\n\\ No newline at end of file\ndiff --git a/views/game.html b/views/game.html\nnew file mode 100644\nindex 0000000..f4d45bc\n--- /dev/null\n+++ b/views/game.html\n@@ -0,0 +1,42 @@\n+<!DOCTYPE html>\n+<html>\n+  <head>\n+    <title>radial snake</title>\n+\n+    <!-- Libs -->\n+    <script type=\"text/javascript\" src=\"/libs/jquery-2.1.1.js\"></script>\n+    <script type=\"text/javascript\" src=\"/libs/underscore.js\"></script>\n+\n+    <!-- Scripts -->\n+    <script type=\"text/javascript\" src=\"/scripts/extensions.js\"></script>\n+    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n+    <script type=\"text/javascript\" src=\"/scripts/engine/geometry/line.js\"></script>\n+    <script type=\"text/javascript\" src=\"/scripts/engine/geometry/circle.js\"></script>\n+    <script type=\"text/javascript\" src=\"/scripts/engine/geometry/polygon.js\"></script>\n+    <script type=\"text/javascript\" src=\"/scripts/engine/restorable.js\"></script>\n+    <script type=\"text/javascript\" src=\"/scripts/engine/font.js\"></script>\n+    <script type=\"text/javascript\" src=\"/scripts/engine/sprite.js\"></script>\n+    <script type=\"text/javascript\" src=\"/scripts/engine/animations/keyframe.js\"></script>\n+    <script type=\"text/javascript\" src=\"/scripts/engine/key_states.js\"></script>\n+    <script type=\"text/javascript\" src=\"/scripts/engine/layer.js\"></script>\n+    <script type=\"text/javascript\" src=\"/scripts/engine/screen.js\"></script>\n+    <script type=\"text/javascript\" src=\"/scripts/engine/assets_loader.js\"></script>\n+    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n+    <script type=\"text/javascript\" src=\"/scripts/game/entities/snake.js\"></script>\n+    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/index.js\"></script>\n+    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/win.js\"></script>\n+    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/score.js\"></script>\n+    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/snake.js\"></script>\n+    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/ready.js\"></script>\n+    <script type=\"text/javascript\" src=\"/scripts/game/screens/menu/index.js\"></script>\n+    <script type=\"text/javascript\" src=\"/scripts/game/screens/splash/index.js\"></script>\n+    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n+\n+    <!-- Styles -->\n+    <link rel=\"stylesheet\" type=\"text/css\" href=\"/styles/game.css\">\n+  </head>\n+\n+  <body>\n+    <canvas id=\"gameCanvas\" tabindex=\"0\"></canvas>\n+  </body>\n+</html>\n\\ No newline at end of file\ndiff --git a/views/spec_runner.html b/views/spec_runner.html\nnew file mode 100644\nindex 0000000..ce839dc\n--- /dev/null\n+++ b/views/spec_runner.html\n@@ -0,0 +1,33 @@\n+\n+<!DOCTYPE html>\n+<html>\n+  <head>\n+    <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n+    <title>Jasmine Spec Runner v2.0.1</title>\n+\n+    <!-- Jasmine -->\n+    <script type=\"text/javascript\" src=\"libs/jasmine/jasmine.js\"></script>\n+    <script type=\"text/javascript\" src=\"libs/jasmine/jasmine-html.js\"></script>\n+    <script type=\"text/javascript\" src=\"libs/jasmine/boot.js\"></script>\n+    <link rel=\"shortcut icon\" type=\"image/png\" href=\"libs/jasmine/jasmine_favicon.png\">\n+    <link rel=\"stylesheet\" type=\"text/css\" href=\"libs/jasmine/jasmine.css\">\n+\n+    <!-- Libs -->\n+    <script type=\"text/javascript\" src=\"libs/underscore.js\"></script>\n+\n+    <!-- Scripts -->\n+    <script type=\"text/javascript\" src=\"scripts/extensions.js\"></script>\n+    <script type=\"text/javascript\" src=\"scripts/namespaces.js\"></script>\n+    <script type=\"text/javascript\" src=\"scripts/engine/geometry/line.js\"></script>\n+    <script type=\"text/javascript\" src=\"scripts/engine/geometry/circle.js\"></script>\n+    <script type=\"text/javascript\" src=\"scripts/engine/geometry/polygon.js\"></script>\n+\n+    <!-- Specs -->\n+    <script type=\"text/javascript\" src=\"scripts/specs/engine/geometry/line.js\"></script>\n+    <script type=\"text/javascript\" src=\"scripts/specs/engine/geometry/circle.js\"></script>\n+    <script type=\"text/javascript\" src=\"scripts/specs/engine/geometry/polygon.js\"></script>\n+  </head>\n+\n+  <body>\n+  </body>\n+</html>\n\\ No newline at end of file\n",
        "manuals": [
          {
            "manualTitle": "How to implement a game engine in JavaScript and build a Tron-style game",
            "stepRevision": "08b88f5a9d7b2d3ba4c8a67a1433218ef6a6a3a5",
            "manualView": "![snake-demo-full-small](https://cloud.githubusercontent.com/assets/7648874/21073892/ae331a8a-bed2-11e6-9141-9554f9bb808b.gif)\n\nThis tutorial will guide you through the following steps:\n\n- [**Step 1**](https://github.com/DAB0mB/radial-snake/blob/master/.tortilla/manuals/views/step1.md) - Creating a server\n- [**Step 2**](https://github.com/DAB0mB/radial-snake/blob/master/.tortilla/manuals/views/step2.md) - Creating a game engine basis\n- [**Step 3**](https://github.com/DAB0mB/radial-snake/blob/master/.tortilla/manuals/views/step3.md) - Creating a splash screen using a keyframe animation engine\n- [**Step 4**](https://github.com/DAB0mB/radial-snake/blob/master/.tortilla/manuals/views/step4.md) - Creating a main menu screen using a font engine\n- [**Step 5**](https://github.com/DAB0mB/radial-snake/blob/master/.tortilla/manuals/views/step5.md) - Creating a snake and related geometry shapes\n- [**Step 6**](https://github.com/DAB0mB/radial-snake/blob/master/.tortilla/manuals/views/step6.md) - Creating a complex game screen with multiple layers\n- [**Step 7**](https://github.com/DAB0mB/radial-snake/blob/master/.tortilla/manuals/views/step7.md) - Bonus! Re-implementing geometry in C++\n\nMake sure you have the following software installed:\n\n- NodeJS with an ECMAScript 2015 support (v6.0.0 and above).\n- Any web-browser which supports ECMAScript 2015, with a preference for Google Chrome.\n\n> The final project is a hybrid of C++ and JavaScript. A JavaScript **only** version of this tutorial is available [here](https://github.com/DAB0mB/radial-snake/tree/master%40step6%400.1.3).\n\nThis tutorial is mostly based on pure JavaScript, so people can have a deeper understanding of the language and its dynamics. In addition, this tutorial makes a great practice on how to build a nice architecture for complex systems, which can then be expanded and maintained with ease. Yes, it is specifically designed for games, but I truly believe that video games can easily get messed up if not planned and designed properly in terms of object oriented relationships. They are naturally more complicated then any web-app you gonna see out there, so if you can create a game engine and understand its flow, creating a web-app would be a piece of cake for you. By the end of this tutorial, your general sense for programming should be enhanced greatly.\n\nSo hopefully that I got you pumped up by now, let's get started!"
          },
          {
            "manualTitle": "Step 1: Creating a server",
            "stepRevision": "1aed2194c509617dbe79447e2615aa34728262bc",
            "manualView": "The first thing we will learn to do would be creating a server so we can serve our assets. We will be using [HapiJS](https://hapijs.com/) to build a REST API, although this step can be implemented with any library you'd want, like [ExpressJS](http://expressjs.com/) or [Connect](https://www.senchalabs.github.com/connect) etc. Let's install it then:\n\n    $ npm install hapi --save\n\nWe will start by setting up a basis for our server, and we will expand it as we go further in this step. A general boiler plate should look like so:\n\n[{]: <helper> (diffStep 1.2)\n\n#### [Step 1.2: Add server basis](https://github.com/DAB0mB/radial-snake/commit/8ff8805)\n\n##### Added server.js\n```diff\n@@ -0,0 +1,36 @@\n+â”Š  â”Š 1â”Šconst Hapi = require(\"hapi\");\n+â”Š  â”Š 2â”Š\n+â”Š  â”Š 3â”Šlet port = 8000;\n+â”Š  â”Š 4â”Š\n+â”Š  â”Š 5â”Š// Initialize a new server\n+â”Š  â”Š 6â”Šlet server = new Hapi.Server();\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Šserver.connection({ port: process.env.PORT || port });\n+â”Š  â”Š 9â”Š\n+â”Š  â”Š10â”Š// Report each response made\n+â”Š  â”Š11â”Šserver.ext(\"onPreResponse\", (req, rep) => {\n+â”Š  â”Š12â”Š  let res = req.response;\n+â”Š  â”Š13â”Š\n+â”Š  â”Š14â”Š  console.log(\"Outcoming response:\");\n+â”Š  â”Š15â”Š  console.log(`in: ${new Date}`);\n+â”Š  â”Š16â”Š  console.log(`to: ${req.info.remoteAddress}`);\n+â”Š  â”Š17â”Š  console.log(`method: ${req.method}`);\n+â”Š  â”Š18â”Š  console.log(`url: ${req.url.path}`);\n+â”Š  â”Š19â”Š  console.log(`status: ${res.statusCode || res.output.statusCode}`);\n+â”Š  â”Š20â”Š  console.log();\n+â”Š  â”Š21â”Š\n+â”Š  â”Š22â”Š  rep.continue();\n+â”Š  â”Š23â”Š});\n+â”Š  â”Š24â”Š\n+â”Š  â”Š25â”Š// Print message once started\n+â”Š  â”Š26â”Šserver.start((err) => {\n+â”Š  â”Š27â”Š  if (err) throw err;\n+â”Š  â”Š28â”Š\n+â”Š  â”Š29â”Š  console.log();\n+â”Š  â”Š30â”Š  console.log(\"---------- -------- ------ ---- --\");\n+â”Š  â”Š31â”Š  console.log(\"----- ---- --- -- -\");\n+â”Š  â”Š32â”Š  console.log(`Server running at ${port}`);\n+â”Š  â”Š33â”Š  console.log(\"----- ---- --- -- -\");\n+â”Š  â”Š34â”Š  console.log(\"---------- -------- ------ ---- --\");\n+â”Š  â”Š35â”Š  console.log();\n+â”Š  â”Š36â”Š});ðŸš«â†µ\n```\n\n[}]: #\n\nWe simply initialize a new server which will connect to port `8000` by default, unless we defined an environment variable called `PORT`. Once the server is started, and whenever there is an outcoming response, a message will be printed to the console.\n\n> More information and configuration options regards HapiJS's API can be found in this [here](https://hapijs.com/).\n\nNow that the basis is ready, we want a convenient way to launch it. Repetitive scripts are usually defined in the `package.json` file under the `scripts` field. To start the server, we gonna create a simple script called `serve`:\n\n[{]: <helper> (diffStep 1.3)\n\n#### [Step 1.3: Add serve npm script](https://github.com/DAB0mB/radial-snake/commit/6e7d691)\n\n##### Changed package.json\n```diff\n@@ -6,6 +6,9 @@\n â”Š 6â”Š 6â”Š    \"url\": \"https://DAB0mB@github.com/DAB0mB/radial-snake.git\"\n â”Š 7â”Š 7â”Š  },\n â”Š 8â”Š 8â”Š  \"private\": true,\n+â”Š  â”Š 9â”Š  \"scripts\": {\n+â”Š  â”Š10â”Š    \"serve\": \"node server.js\"\n+â”Š  â”Š11â”Š  },\n â”Š 9â”Š12â”Š  \"dependencies\": {\n â”Š10â”Š13â”Š    \"hapi\": \"^16.0.1\"\n â”Š11â”Š14â”Š  }\n```\n\n[}]: #\n\nTo run this script, we will simply need to type the following:\n\n    $ npm run serve\n\nThis will run our server, and you should see the following message printed to the console:\n\n```\n---------- -------- ------ ---- --\n----- ---- --- -- -\nServer running at 8000\n----- ---- --- -- -\n---------- -------- ------ ---- --\n```\n\n> As for now, nothing happens, because we didn't define any handlers for HTTP requests. I will get to it in a bit, stay with me.\n\nThe main disadvantage of starting a server directly with node is that we have no listeners for changes in our files, so if we want the served files to be updated, we will have to restart our server anytime we make a change. To avoid that, we gonna use [nodemon](https://nodemon.io/), which is a simple utility that can monitor changes is source files and automatically restart our server. To install it, type the following:\n\n    $ sudo npm install nodemon -g\n\nNow that we have it, we will need to update our `serve` npm script to use `nodemon` instead of `node`:\n\n[{]: <helper> (diffStep 1.4)\n\n#### [Step 1.4: Change serve npm script to use nodemon](https://github.com/DAB0mB/radial-snake/commit/a238294)\n\n##### Changed package.json\n```diff\n@@ -7,7 +7,7 @@\n â”Š 7â”Š 7â”Š  },\n â”Š 8â”Š 8â”Š  \"private\": true,\n â”Š 9â”Š 9â”Š  \"scripts\": {\n-â”Š10â”Š  â”Š    \"serve\": \"node server.js\"\n+â”Š  â”Š10â”Š    \"serve\": \"nodemon server.js\"\n â”Š11â”Š11â”Š  },\n â”Š12â”Š12â”Š  \"dependencies\": {\n â”Š13â”Š13â”Š    \"hapi\": \"^16.0.1\"\n```\n\n[}]: #\n\nThe basis for our server is pretty much complete. From now on we gonna build stuff on top of it and extend our server. I'd like to add a small attachment to our server. I want that the IP address of the current computer will be printed to the console once the server is started. For this, we first gonna create a helper which we gonna call `ip_grabber`:\n\n[{]: <helper> (diffStep 1.5)\n\n#### [Step 1.5: Add ip_grabber helper](https://github.com/DAB0mB/radial-snake/commit/8ff1d1c)\n\n##### Added helpers&#x2F;ip_grabber.js\n```diff\n@@ -0,0 +1,23 @@\n+â”Š  â”Š 1â”Šconst Os = require(\"os\");\n+â”Š  â”Š 2â”Š\n+â”Š  â”Š 3â”Š// Grab local IP address of which the NodeJS process runs on\n+â”Š  â”Š 4â”Šfunction local() {\n+â”Š  â”Š 5â”Š  let interfaces = Os.networkInterfaces();\n+â”Š  â”Š 6â”Š  let addresses = [];\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Š  for (let k in interfaces) {\n+â”Š  â”Š 9â”Š    for (let k2 in interfaces[k]) {\n+â”Š  â”Š10â”Š      let address = interfaces[k][k2];\n+â”Š  â”Š11â”Š\n+â”Š  â”Š12â”Š      if (address.family == \"IPv4\" && !address.internal) {\n+â”Š  â”Š13â”Š        addresses.push(address.address);\n+â”Š  â”Š14â”Š      }\n+â”Š  â”Š15â”Š    }\n+â”Š  â”Š16â”Š  }\n+â”Š  â”Š17â”Š\n+â”Š  â”Š18â”Š  return addresses[0];\n+â”Š  â”Š19â”Š}\n+â”Š  â”Š20â”Š\n+â”Š  â”Š21â”Šmodule.exports = {\n+â”Š  â”Š22â”Š  local\n+â”Š  â”Š23â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nThis module simply goes through the available network interfaces and grabs the IP address of the default gateway using the `os` module. Now that we have it, let's import it in the server's entry file and use the `local` method to grab the IP address and report it once the server is started:\n\n[{]: <helper> (diffStep 1.6)\n\n#### [Step 1.6: Print IP address once server is started](https://github.com/DAB0mB/radial-snake/commit/18ed984)\n\n##### Changed server.js\n```diff\n@@ -1,5 +1,7 @@\n â”Š1â”Š1â”Šconst Hapi = require(\"hapi\");\n+â”Š â”Š2â”Šconst IpGrabber = require(\"./helpers/ip_grabber\");\n â”Š2â”Š3â”Š\n+â”Š â”Š4â”Šlet localIp = IpGrabber.local();\n â”Š3â”Š5â”Šlet port = 8000;\n â”Š4â”Š6â”Š\n â”Š5â”Š7â”Š// Initialize a new server\n```\n```diff\n@@ -29,7 +31,7 @@\n â”Š29â”Š31â”Š  console.log();\n â”Š30â”Š32â”Š  console.log(\"---------- -------- ------ ---- --\");\n â”Š31â”Š33â”Š  console.log(\"----- ---- --- -- -\");\n-â”Š32â”Š  â”Š  console.log(`Server running at ${port}`);\n+â”Š  â”Š34â”Š  console.log(`Server running at ${localIp}:${port}`);\n â”Š33â”Š35â”Š  console.log(\"----- ---- --- -- -\");\n â”Š34â”Š36â”Š  console.log(\"---------- -------- ------ ---- --\");\n â”Š35â”Š37â”Š  console.log();\n```\n\n[}]: #\n\nBy now you should have the following message printed to the console once you start the server:\n\n```\n---------- -------- ------ ---- --\n----- ---- --- -- -\nServer running at 95.221.122.30:8000\n----- ---- --- -- -\n---------- -------- ------ ---- --\n```\n\n> Instead of `95.221.122.30` you should have the IP address which is right for you.\n\nNow comes the most important part - handling HTTP requests! Because what does a server worth if it doesn't know how to handle anything? When using `HapiJS`, we can separate extensions to our server in different modules, and eventually register them as plug-ins. So the first plug-in is gonna be the routes batch for the endpoints - it will take care of serving file requests as is, and basically turning local directories into public ones. This is useful because our game is going to be dependent on many assets like textures, images, fonts, and so on... But before I go into the implementation part we first need to install a couple of libraries which will help us with the task. The first one is going to be `async`, which will take care of managing the control flow of asynchronous code:\n\n    $ npm install async --save\n\nAnd the second library is going to be `inert`, which is a `HapiJS` plug-in which will give us the ability to serve files from local directories:\n\n    $ npm install inert --save\n\nNow that we're set, let's implement the `endpoints` routes batch:\n\n[{]: <helper> (diffStep 1.8)\n\n#### [Step 1.8: Add endpoints routes](https://github.com/DAB0mB/radial-snake/commit/9c22408)\n\n##### Added routes&#x2F;endpoints.js\n```diff\n@@ -0,0 +1,80 @@\n+â”Š  â”Š 1â”Šconst Pack = require(\"../package.json\");\n+â”Š  â”Š 2â”Š\n+â”Š  â”Š 3â”Šregister.attributes = {\n+â”Š  â”Š 4â”Š  name: \"endpoints\",\n+â”Š  â”Š 5â”Š  version: Pack.version\n+â”Š  â”Š 6â”Š};\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Šfunction register(server, options, next) {\n+â”Š  â”Š 9â”Š  // Scripts endpoint\n+â”Š  â”Š10â”Š  server.route({\n+â”Š  â”Š11â”Š    method: \"GET\",\n+â”Š  â”Š12â”Š    path: \"/scripts/{path*}\",\n+â”Š  â”Š13â”Š    handler: {\n+â”Š  â”Š14â”Š      directory: {\n+â”Š  â”Š15â”Š        path: \"./resources/scripts/\"\n+â”Š  â”Š16â”Š      }\n+â”Š  â”Š17â”Š    }\n+â”Š  â”Š18â”Š  });\n+â”Š  â”Š19â”Š\n+â”Š  â”Š20â”Š  // Style-sheets endpoint\n+â”Š  â”Š21â”Š  server.route({\n+â”Š  â”Š22â”Š    method: \"GET\",\n+â”Š  â”Š23â”Š    path: \"/styles/{path*}\",\n+â”Š  â”Š24â”Š    handler: {\n+â”Š  â”Š25â”Š      directory: {\n+â”Š  â”Š26â”Š        path: \"./resources/styles/\"\n+â”Š  â”Š27â”Š      }\n+â”Š  â”Š28â”Š    }\n+â”Š  â”Š29â”Š  });\n+â”Š  â”Š30â”Š\n+â”Š  â”Š31â”Š  // Libraries endpoint\n+â”Š  â”Š32â”Š  server.route({\n+â”Š  â”Š33â”Š    method: \"GET\",\n+â”Š  â”Š34â”Š    path: \"/libs/{path*}\",\n+â”Š  â”Š35â”Š    handler: {\n+â”Š  â”Š36â”Š      directory: {\n+â”Š  â”Š37â”Š        path: \"./resources/libs/\"\n+â”Š  â”Š38â”Š      }\n+â”Š  â”Š39â”Š    }\n+â”Š  â”Š40â”Š  });\n+â”Š  â”Š41â”Š\n+â”Š  â”Š42â”Š  // Images endpoint\n+â”Š  â”Š43â”Š  server.route({\n+â”Š  â”Š44â”Š    method: \"GET\",\n+â”Š  â”Š45â”Š    path: \"/images/{path*}\",\n+â”Š  â”Š46â”Š    handler: {\n+â”Š  â”Š47â”Š      directory: {\n+â”Š  â”Š48â”Š        path: \"./resources/images/\"\n+â”Š  â”Š49â”Š      }\n+â”Š  â”Š50â”Š    }\n+â”Š  â”Š51â”Š  });\n+â”Š  â”Š52â”Š\n+â”Š  â”Š53â”Š  // Textures endpoint\n+â”Š  â”Š54â”Š  server.route({\n+â”Š  â”Š55â”Š    method: \"GET\",\n+â”Š  â”Š56â”Š    path: \"/textures/{path*}\",\n+â”Š  â”Š57â”Š    handler: {\n+â”Š  â”Š58â”Š      directory: {\n+â”Š  â”Š59â”Š        path: \"./resources/assets/textures/\"\n+â”Š  â”Š60â”Š      }\n+â”Š  â”Š61â”Š    }\n+â”Š  â”Š62â”Š  });\n+â”Š  â”Š63â”Š\n+â”Š  â”Š64â”Š  // Fonts endpoint\n+â”Š  â”Š65â”Š  server.route({\n+â”Š  â”Š66â”Š    method: \"GET\",\n+â”Š  â”Š67â”Š    path: \"/fonts/{path*}\",\n+â”Š  â”Š68â”Š    handler: {\n+â”Š  â”Š69â”Š      directory: {\n+â”Š  â”Š70â”Š        path: \"./resources/assets/fonts/\"\n+â”Š  â”Š71â”Š      }\n+â”Š  â”Š72â”Š    }\n+â”Š  â”Š73â”Š  });\n+â”Š  â”Š74â”Š\n+â”Š  â”Š75â”Š  next();\n+â”Š  â”Š76â”Š}\n+â”Š  â”Š77â”Š\n+â”Š  â”Š78â”Šmodule.exports = {\n+â”Š  â”Š79â”Š  register\n+â”Š  â”Š80â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nThis module actually represents a classic structure of a `HapiJS` plug-in. It should export a `name` for debugging proposes, a `version`, and a `register` function, which will take care of registering extensions to our server; in this case, these are the endpoints routes. To make this plug-in (Or any other plug-in) work, we need to register it. The registration is an asynchronous operation, thus we gonna handle it using `async`:\n\n[{]: <helper> (diffStep 1.9)\n\n#### [Step 1.9: Register ednpoints routes](https://github.com/DAB0mB/radial-snake/commit/bba460f)\n\n##### Changed server.js\n```diff\n@@ -1,11 +1,23 @@\n+â”Š  â”Š 1â”Šconst Async = require(\"async\");\n â”Š 1â”Š 2â”Šconst Hapi = require(\"hapi\");\n+â”Š  â”Š 3â”Šconst Inert = require(\"inert\");\n+â”Š  â”Š 4â”Šconst Endpoints = require(\"./routes/endpoints\");\n â”Š 2â”Š 5â”Šconst IpGrabber = require(\"./helpers/ip_grabber\");\n â”Š 3â”Š 6â”Š\n â”Š 4â”Š 7â”Šlet localIp = IpGrabber.local();\n â”Š 5â”Š 8â”Šlet port = 8000;\n â”Š 6â”Š 9â”Š\n â”Š 7â”Š10â”Š// Initialize a new server\n-â”Š 8â”Š  â”Šlet server = new Hapi.Server();\n+â”Š  â”Š11â”Šlet server = new Hapi.Server({\n+â”Š  â”Š12â”Š  connections: {\n+â”Š  â”Š13â”Š    routes: {\n+â”Š  â”Š14â”Š      files: {\n+â”Š  â”Š15â”Š        // Served files will be relative to current directory\n+â”Š  â”Š16â”Š        relativeTo: __dirname\n+â”Š  â”Š17â”Š      }\n+â”Š  â”Š18â”Š    }\n+â”Š  â”Š19â”Š  }\n+â”Š  â”Š20â”Š});\n â”Š 9â”Š21â”Š\n â”Š10â”Š22â”Šserver.connection({ port: process.env.PORT || port });\n â”Š11â”Š23â”Š\n```\n```diff\n@@ -24,8 +36,14 @@\n â”Š24â”Š36â”Š  rep.continue();\n â”Š25â”Š37â”Š});\n â”Š26â”Š38â”Š\n+â”Š  â”Š39â”Š// Register all routes and plug-ins\n+â”Š  â”Š40â”ŠAsync.series([\n+â”Š  â”Š41â”Š  next => server.register(Inert, next),\n+â”Š  â”Š42â”Š  next => server.register(Endpoints, next),\n+â”Š  â”Š43â”Š  // Once registrations are finished, start the server\n+â”Š  â”Š44â”Š  next => server.start(next)\n â”Š27â”Š45â”Š// Print message once started\n-â”Š28â”Š  â”Šserver.start((err) => {\n+â”Š  â”Š46â”Š], (err) => {\n â”Š29â”Š47â”Š  if (err) throw err;\n â”Š30â”Š48â”Š\n â”Š31â”Š49â”Š  console.log();\n```\n\n[}]: #\n\nOnce all the plug-ins have been registered, we gonna start our server as we previously did. Note that we also registered the `inert` plug-in, because as I said earlier, that's what gives us the ability to handle files requests.\n\nLastly, I want to create the `pages` routes batch, which will be responsible for serving pages in our application as listed above:\n\n- The `/` route will serve us the `game.html` file.\n- The `/test` route will serve us the `spec_runner.html` file.\n\nBy the name of each route and file you can probably what each one should do. The thing is, we don't want everyone to be able to access the `spec_runner.html` file, or the `game.html` file if in the middle of development. For this, we're going to create a new helper which will be responsible for handling permissions. So first we gonna install an npm package called `boom` which has the ability to format `permission denied` HTTP errors:\n\n    $ npm install boom --save\n\nAnd now we gonna implement the module itself:\n\n[{]: <helper> (diffStep 1.11)\n\n#### [Step 1.11: Add permitter helper](https://github.com/DAB0mB/radial-snake/commit/d26a5d7)\n\n##### Added helpers&#x2F;permitter.js\n```diff\n@@ -0,0 +1,29 @@\n+â”Š  â”Š 1â”Šconst Boom = require(\"boom\");\n+â”Š  â”Š 2â”Šconst Hapi = require(\"hapi\");\n+â”Š  â”Š 3â”Šconst IpGrabber = require(\"./ip_grabber\");\n+â”Š  â”Š 4â”Š\n+â”Š  â”Š 5â”Š// These addresses will be permitted by default\n+â”Š  â”Š 6â”Šconst defaultPermissions = [\n+â”Š  â”Š 7â”Š  IpGrabber.local(), \"127.0.0.1\", \"localhost\"\n+â”Š  â”Š 8â”Š];\n+â”Š  â”Š 9â”Š\n+â”Š  â”Š10â”Š// Manage file permissions\n+â”Š  â”Š11â”Šfunction file(path, permissions, req, rep) {\n+â”Š  â”Š12â”Š  // Apply default permissions\n+â”Š  â”Š13â”Š  permissions = permissions.concat(defaultPermissions);\n+â”Š  â”Š14â”Š  // Request address\n+â”Š  â”Š15â”Š  let remoteAddress = req.info.remoteAddress;\n+â”Š  â”Š16â”Š\n+â”Š  â”Š17â”Š  // If not permitted, reply error\n+â”Š  â”Š18â”Š  if (permissions.indexOf(remoteAddress) == -1) {\n+â”Š  â”Š19â”Š    let err = new Boom.forbidden(\"Missing permissions\");\n+â”Š  â”Š20â”Š    return rep(err);\n+â”Š  â”Š21â”Š  }\n+â”Š  â”Š22â”Š\n+â”Š  â”Š23â”Š  // If permitted, reply file\n+â”Š  â”Š24â”Š  rep.file(path);\n+â”Š  â”Š25â”Š}\n+â”Š  â”Š26â”Š\n+â”Š  â”Š27â”Šmodule.exports = {\n+â”Š  â”Š28â”Š  file\n+â”Š  â”Š29â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nThe default permitted IP address would be the current computer's IP address. Extra IP permissions can be provided with the invocation of the `file` method. If the requesting IP is not listed in the permissions list, an error is gonna be replied instead of the requested file. Now that we have our \"permitter\" ready, let's implement the `pages` routes batch, only we're gonna pass the requests through the black-list, for the reason mentioned above:\n\n[{]: <helper> (diffStep 1.12)\n\n#### [Step 1.12: Add pages routes](https://github.com/DAB0mB/radial-snake/commit/11860e9)\n\n##### Added routes&#x2F;pages.js\n```diff\n@@ -0,0 +1,35 @@\n+â”Š  â”Š 1â”Šconst Hapi = require(\"hapi\");\n+â”Š  â”Š 2â”Šconst Pack = require(\"../package.json\");\n+â”Š  â”Š 3â”Šconst Permitter = require(\"../helpers/permitter\");\n+â”Š  â”Š 4â”Š\n+â”Š  â”Š 5â”Šregister.attributes = {\n+â”Š  â”Š 6â”Š  name: \"pages\",\n+â”Š  â”Š 7â”Š  version: Pack.version\n+â”Š  â”Š 8â”Š};\n+â”Š  â”Š 9â”Š\n+â”Š  â”Š10â”Šfunction register(server, options, next) {\n+â”Š  â”Š11â”Š  server.route({ method: \"GET\", path: \"/\", handler: getGame });\n+â”Š  â”Š12â”Š  server.route({ method: \"GET\", path: \"/test\", handler: getSpecRunner });\n+â”Š  â”Š13â”Š\n+â”Š  â”Š14â”Š  next();\n+â”Š  â”Š15â”Š}\n+â”Š  â”Š16â”Š\n+â”Š  â”Š17â”Š// Serve game page\n+â”Š  â”Š18â”Šfunction getGame(req, rep) {\n+â”Š  â”Š19â”Š  let path = \"./views/game.html\";\n+â”Š  â”Š20â”Š  let permissions = [];\n+â”Š  â”Š21â”Š\n+â”Š  â”Š22â”Š  Permitter.file(path, permissions, req, rep);\n+â”Š  â”Š23â”Š}\n+â”Š  â”Š24â”Š\n+â”Š  â”Š25â”Š// Serve test page\n+â”Š  â”Š26â”Šfunction getSpecRunner(req, rep) {\n+â”Š  â”Š27â”Š  let path = \"./views/spec_runner.html\";\n+â”Š  â”Š28â”Š  let permissions = [];\n+â”Š  â”Š29â”Š\n+â”Š  â”Š30â”Š  Permitter.file(path, permissions, req, rep);\n+â”Š  â”Š31â”Š}\n+â”Š  â”Š32â”Š\n+â”Š  â”Š33â”Šmodule.exports = {\n+â”Š  â”Š34â”Š  register\n+â”Š  â”Š35â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nNow the only thing left to do would be registering the plug-in we've just created:\n\n[{]: <helper> (diffStep 1.13)\n\n#### [Step 1.13: Register pages routes](https://github.com/DAB0mB/radial-snake/commit/ed50bef)\n\n##### Changed server.js\n```diff\n@@ -2,6 +2,7 @@\n â”Š2â”Š2â”Šconst Hapi = require(\"hapi\");\n â”Š3â”Š3â”Šconst Inert = require(\"inert\");\n â”Š4â”Š4â”Šconst Endpoints = require(\"./routes/endpoints\");\n+â”Š â”Š5â”Šconst Pages = require(\"./routes/pages\");\n â”Š5â”Š6â”Šconst IpGrabber = require(\"./helpers/ip_grabber\");\n â”Š6â”Š7â”Š\n â”Š7â”Š8â”Šlet localIp = IpGrabber.local();\n```\n```diff\n@@ -40,6 +41,7 @@\n â”Š40â”Š41â”ŠAsync.series([\n â”Š41â”Š42â”Š  next => server.register(Inert, next),\n â”Š42â”Š43â”Š  next => server.register(Endpoints, next),\n+â”Š  â”Š44â”Š  next => server.register(Pages, next),\n â”Š43â”Š45â”Š  // Once registrations are finished, start the server\n â”Š44â”Š46â”Š  next => server.start(next)\n â”Š45â”Š47â”Š// Print message once started\n```\n\n[}]: #\n\nAnd that's it for the current step! In the next steps we will start storing files and assets in our public directories and implement all the necessary scripts, so our server is not running in vain."
          },
          {
            "manualTitle": "Step 2: Creating a game engine basis",
            "stepRevision": "a3e901039dc5db535111da14305175182f9f346c",
            "manualView": "Like any other JavaScript-based application, we should have an entry view written in HTML. However, in our application, the only visible element is going to be an [HTMLCanvas](https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API). The canvas is exactly what it sounds like - a blank white surface which we can draw things on top of it. As we go further with this tutorial, we will learn more about the canvas and dive into its API and how to use it. Now that you got the general idea, let's create the HTML file:\n\n[{]: <helper> (diffStep 2.1)\n\n#### [Step 2.1: Create basic game view](https://github.com/DAB0mB/radial-snake/commit/254f06f)\n\n##### Added views&#x2F;game.html\n```diff\n@@ -0,0 +1,10 @@\n+â”Š  â”Š 1â”Š<!DOCTYPE html>\n+â”Š  â”Š 2â”Š<html>\n+â”Š  â”Š 3â”Š  <head>\n+â”Š  â”Š 4â”Š    <title>radial snake</title>\n+â”Š  â”Š 5â”Š  </head>\n+â”Š  â”Š 6â”Š\n+â”Š  â”Š 7â”Š  <body>\n+â”Š  â”Š 8â”Š    <canvas id=\"gameCanvas\" tabindex=\"0\"></canvas>\n+â”Š  â”Š 9â”Š  </body>\n+â”Š  â”Š10â”Š</html>ðŸš«â†µ\n```\n\n[}]: #\n\nIn the previous step we've already set the route for this file, so if you'd like to run the game, simply start the server by typing `npm run serve`, and navigate to the address presented on the screen (Should be `localhost:8000` by default).\n\n> From now on I'm going to assume the server is running in the background, so I won't repeat the instruction above\n\nJust to make sure that the canvas is visible and not blended into the background, we will draw a black border around using a simple style-sheet:\n\n[{]: <helper> (diffStep 2.2)\n\n#### [Step 2.2: Create basic game stylesheet](https://github.com/DAB0mB/radial-snake/commit/44fe5aa)\n\n##### Added resources&#x2F;styles&#x2F;game.css\n```diff\n@@ -0,0 +1,6 @@\n+â”Š â”Š1â”Š#gameCanvas {\n+â”Š â”Š2â”Š  display: block;\n+â”Š â”Š3â”Š  margin: auto;\n+â”Š â”Š4â”Š  border-style: solid;\n+â”Š â”Š5â”Š  border-width: 1px;\n+â”Š â”Š6â”Š}ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -2,6 +2,9 @@\n â”Š 2â”Š 2â”Š<html>\n â”Š 3â”Š 3â”Š  <head>\n â”Š 4â”Š 4â”Š    <title>radial snake</title>\n+â”Š  â”Š 5â”Š\n+â”Š  â”Š 6â”Š    <!-- Styles -->\n+â”Š  â”Š 7â”Š    <link rel=\"stylesheet\" type=\"text/css\" href=\"/styles/game.css\">\n â”Š 5â”Š 8â”Š  </head>\n â”Š 6â”Š 9â”Š\n â”Š 7â”Š10â”Š  <body>\n```\n\n[}]: #\n\n> Note that every asset we create should be declared in the HTML file in order for it to take effect\n\nTo build this project we're also gonna use two very famous utility libraries called [JQuery](http://jquery.com/) and [Underscore](http://underscorejs.org/) which will make our lives a bit easier. Third-party libraries should be located in a directory called `libs`, according to the routes-map we created in the previous step. To set these libraries up, type the following commands in series:\n\n    resources$ mkdir libs\n    resources$ cd libs\n    resources/libs$ wget raw.githubusercontent.com/dab0mb/radial-snake/master/resources/libs/underscore.js\n    resources/libs$ wget raw.githubusercontent.com/dab0mb/radial-snake/master/resources/libs/jquery-2.1.1.js\n\nAnd load them in the game's HTML file's header:\n\n[{]: <helper> (diffStep 2.3 files=\"views/game.html\")\n\n#### [Step 2.3: Add jquery and underscore libs](https://github.com/DAB0mB/radial-snake/commit/085ca6b)\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -3,6 +3,10 @@\n â”Š 3â”Š 3â”Š  <head>\n â”Š 4â”Š 4â”Š    <title>radial snake</title>\n â”Š 5â”Š 5â”Š\n+â”Š  â”Š 6â”Š    <!-- Libs -->\n+â”Š  â”Š 7â”Š    <script type=\"text/javascript\" src=\"/libs/jquery-2.1.1.js\"></script>\n+â”Š  â”Š 8â”Š    <script type=\"text/javascript\" src=\"/libs/underscore.js\"></script>\n+â”Š  â”Š 9â”Š\n â”Š 6â”Š10â”Š    <!-- Styles -->\n â”Š 7â”Š11â”Š    <link rel=\"stylesheet\" type=\"text/css\" href=\"/styles/game.css\">\n â”Š 8â”Š12â”Š  </head>\n```\n\n[}]: #\n\nNow, we're finally going to build the game engine. At first, it's gonna be very basic simple, but further in this tutorial we're going to extend it and add some pretty neat features. When creating an application, of any kind, you don't want to garbage the global scope, so it can stay clean without any conflicts. Therefore, we're going to create an initial namespace for our game engine called `Engine`, which is going to contain all our game engine's classes and entities:\n\n[{]: <helper> (diffStep 2.4)\n\n#### [Step 2.4: Add engine namespace](https://github.com/DAB0mB/radial-snake/commit/3d52525)\n\n##### Added resources&#x2F;scripts&#x2F;namespaces.js\n```diff\n@@ -0,0 +1 @@\n+â”Š â”Š1â”ŠEngine = {};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -7,6 +7,9 @@\n â”Š 7â”Š 7â”Š    <script type=\"text/javascript\" src=\"/libs/jquery-2.1.1.js\"></script>\n â”Š 8â”Š 8â”Š    <script type=\"text/javascript\" src=\"/libs/underscore.js\"></script>\n â”Š 9â”Š 9â”Š\n+â”Š  â”Š10â”Š    <!-- Scripts -->\n+â”Š  â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n+â”Š  â”Š12â”Š\n â”Š10â”Š13â”Š    <!-- Styles -->\n â”Š11â”Š14â”Š    <link rel=\"stylesheet\" type=\"text/css\" href=\"/styles/game.css\">\n â”Š12â”Š15â”Š  </head>\n```\n\n[}]: #\n\nThe first thing we're going to define in the namespace we've just created would be the game loop. The game loop is the central code of your game, split into different parts. Generally, these are: update and draw.\n\nThe main purpose of the update phase is to prepare all objects to be drawn, so this is where all the geometry code, coordinate updates, score changes, animation refreshments and other similar operations belong. This is also where the input will be captured and processed.\n\nWhen everything is properly updated and ready, we enter the draw phase where all this information is put on the screen. This function should contain all the code to manage and draw the levels, shapes, score board and so on.\n\n![game-loop](https://cloud.githubusercontent.com/assets/7648874/21332964/4b80ef4e-c633-11e6-946a-0c5870d2f9c9.png)\n\n> You can find plenty of details and information about what \"game loop\" means simply by typing in on Google.\n\nA game loop can wear many forms, but the concept is gonna be the same, plus-minus. This is how our game loop is going to loop like:\n\n[{]: <helper> (diffStep 2.5)\n\n#### [Step 2.5: Create a game basis](https://github.com/DAB0mB/radial-snake/commit/1b7fcf9)\n\n##### Added resources&#x2F;scripts&#x2F;engine&#x2F;game.js\n```diff\n@@ -0,0 +1,99 @@\n+â”Š  â”Š 1â”ŠEngine.Game = class Game {\n+â”Š  â”Š 2â”Š  // The frequency of which each frame will be drawn in milliseconds\n+â”Š  â”Š 3â”Š  get fps() {\n+â”Š  â”Š 4â”Š    return 1000 / 60;\n+â”Š  â”Š 5â”Š  }\n+â”Š  â”Š 6â”Š\n+â”Š  â”Š 7â”Š  // Game's run speed.\n+â”Š  â”Š 8â”Š  // A lower value will make it run slower and a higher value will make it run faster\n+â”Š  â”Š 9â”Š  get speed() {\n+â”Š  â”Š10â”Š    return 1;\n+â”Š  â”Š11â”Š  }\n+â”Š  â”Š12â”Š\n+â”Š  â”Š13â”Š  constructor(canvas) {\n+â”Š  â”Š14â”Š    this.canvas = canvas;\n+â”Š  â”Š15â”Š    this.lastUpdate = this.creation = new Date().getTime();\n+â”Š  â”Š16â”Š\n+â”Š  â”Š17â”Š    // Canvas dimensions must be set programmatically otherwise you might encounter some\n+â”Š  â”Š18â”Š    // unexpected behaviors\n+â”Š  â”Š19â”Š    canvas.width = 1280;\n+â”Š  â”Š20â”Š    canvas.height = 720;\n+â”Š  â”Š21â”Š    // Canvas will be focused once game page is loaded so all events will automatically\n+â”Š  â”Š22â”Š    // be captured by it\n+â”Š  â”Š23â”Š    canvas.focus();\n+â”Š  â”Š24â”Š\n+â”Š  â”Š25â”Š    // We want to focus on the canvas once we press on it\n+â”Š  â”Š26â”Š    canvas.addEventListener(\"mousedown\", canvas.focus.bind(canvas), false);\n+â”Š  â”Š27â”Š\n+â”Š  â”Š28â”Š    this.assets = {};\n+â”Š  â”Š29â”Š    this.events = new Map();\n+â”Š  â”Š30â”Š    this.context = canvas.getContext(\"2d\");\n+â”Š  â”Š31â”Š    this.bufferedCanvas = document.createElement(\"canvas\");\n+â”Š  â”Š32â”Š    this.bufferedContext = this.bufferedCanvas.getContext(\"2d\");\n+â”Š  â”Š33â”Š    this.bufferedCanvas.width = canvas.width;\n+â”Š  â”Š34â”Š    this.bufferedCanvas.height = canvas.height;\n+â”Š  â”Š35â”Š  }\n+â”Š  â”Š36â”Š\n+â”Š  â”Š37â”Š  draw() {\n+â”Š  â”Š38â”Š    // Draw a black screen by default\n+â”Š  â”Š39â”Š    this.context.restore();\n+â”Š  â”Š40â”Š    this.context.fillStyle = \"black\";\n+â”Š  â”Š41â”Š    this.context.save();\n+â”Š  â”Š42â”Š    this.context.beginPath();\n+â”Š  â”Š43â”Š    this.context.rect(0, 0, this.canvas.width, this.canvas.height);\n+â”Š  â”Š44â”Š    this.context.fill();\n+â”Š  â”Š45â”Š  }\n+â”Š  â”Š46â”Š\n+â”Š  â”Š47â”Š  update() {\n+â”Š  â”Š48â”Š    // Calculate the time elapsed\n+â”Š  â”Š49â”Š    let lastUpdate = this.lastUpdate;\n+â”Š  â”Š50â”Š    let currUpdate = this.lastUpdate = new Date().getTime();\n+â”Š  â”Š51â”Š    let span = currUpdate - lastUpdate;\n+â”Š  â”Š52â”Š    this.updateScreen(span / this.speed);\n+â”Š  â”Š53â”Š  }\n+â”Š  â”Š54â”Š\n+â”Š  â”Š55â”Š  // The main loop of the game\n+â”Š  â”Š56â”Š  loop() {\n+â”Š  â”Š57â”Š    // If paused, don't run loop. The canvas will remain as is\n+â”Š  â”Š58â”Š    if (!this.playing) return;\n+â”Š  â”Š59â”Š\n+â”Š  â”Š60â”Š    setTimeout(() => {\n+â”Š  â”Š61â”Š      this.draw();\n+â”Š  â”Š62â”Š      this.update();\n+â”Š  â”Š63â”Š      this.loop();\n+â”Š  â”Š64â”Š    }, this.fps);\n+â”Š  â”Š65â”Š  }\n+â”Š  â”Š66â”Š\n+â”Š  â”Š67â”Š  play() {\n+â”Š  â”Š68â”Š    this.playing = true;\n+â”Š  â”Š69â”Š    this.loop();\n+â”Š  â”Š70â”Š  }\n+â”Š  â”Š71â”Š\n+â”Š  â”Š72â”Š  pause() {\n+â”Š  â”Š73â”Š    this.playing = false;\n+â”Š  â”Š74â”Š  }\n+â”Š  â”Š75â”Š\n+â”Š  â”Š76â”Š  // Defines global assets\n+â”Š  â”Š77â”Š  extendAssets(assets) {\n+â”Š  â”Š78â”Š    _.extend(this.assets, assets);\n+â”Š  â”Š79â”Š  }\n+â”Š  â”Š80â”Š\n+â”Š  â”Š81â”Š  // Disposes global assets\n+â”Š  â”Š82â”Š  clearAssets() {\n+â”Š  â”Š83â”Š    this.assets = {};\n+â”Š  â”Š84â”Š  }\n+â”Š  â”Š85â”Š\n+â”Š  â”Š86â”Š  // Adds event listener for game canvas\n+â”Š  â”Š87â”Š  addEventListener(type, listener, target) {\n+â”Š  â”Š88â”Š    let boundListener = listener.bind(target);\n+â”Š  â”Š89â”Š    this.events.set(listener, boundListener);\n+â”Š  â”Š90â”Š    this.canvas.addEventListener(type, boundListener, false);\n+â”Š  â”Š91â”Š  }\n+â”Š  â”Š92â”Š\n+â”Š  â”Š93â”Š  // Removes event listener from game canvas\n+â”Š  â”Š94â”Š  removeEventListener(type, listener) {\n+â”Š  â”Š95â”Š    let boundListener = this.events.get(listener);\n+â”Š  â”Š96â”Š    this.events.delete(listener);\n+â”Š  â”Š97â”Š    this.canvas.removeEventListener(type, boundListener, false);\n+â”Š  â”Š98â”Š  }\n+â”Š  â”Š99â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -9,6 +9,7 @@\n â”Š 9â”Š 9â”Š\n â”Š10â”Š10â”Š    <!-- Scripts -->\n â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n+â”Š  â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š12â”Š13â”Š\n â”Š13â”Š14â”Š    <!-- Styles -->\n â”Š14â”Š15â”Š    <link rel=\"stylesheet\" type=\"text/css\" href=\"/styles/game.css\">\n```\n\n[}]: #\n\nThe only thing it's doing right now is drawing a black background, but we're soon going to learn how to take advantage of this game-loop to draw stuff of our own. I'd like to point out that there is no need to implement a [double-buffer](https://en.wikipedia.org/wiki/Multiple_buffering) (A method similar to React's [virtual DOM](https://www.npmjs.com/package/react-dom)) when it comes to `HTMLCanvas` elements, since `HTML5` already does that for us. To start running the game, we first need to wait for the DOM content to initialize, and once it's ready we gonna create a new game instance and call the `play` method:\n\n[{]: <helper> (diffStep 2.6)\n\n#### [Step 2.6: Create game entry point](https://github.com/DAB0mB/radial-snake/commit/30e75df)\n\n##### Added resources&#x2F;scripts&#x2F;main.js\n```diff\n@@ -0,0 +1,4 @@\n+â”Š â”Š1â”Šdocument.addEventListener(\"DOMContentLoaded\", function(event) {\n+â”Š â”Š2â”Š  let game = new Engine.Game(document.getElementById(\"gameCanvas\"), false);\n+â”Š â”Š3â”Š  game.play();\n+â”Š â”Š4â”Š});ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -10,6 +10,7 @@\n â”Š10â”Š10â”Š    <!-- Scripts -->\n â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n â”Š12â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n+â”Š  â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n â”Š13â”Š14â”Š\n â”Š14â”Š15â”Š    <!-- Styles -->\n â”Š15â”Š16â”Š    <link rel=\"stylesheet\" type=\"text/css\" href=\"/styles/game.css\">\n```\n\n[}]: #\n\nThis will take control over the canvas and will draw a new picture every 17ms, which is 60fps (Frames per second). As for now you're only going to see a black canvas, but I promise the final result is not going to disappoint you.\n\nThe next thing we're gonna do would be adding a 'key state' manager, which will store a flag for each key pressed on the keyboard. Once we press the key, the flag's value would be `true`, and once we release it, its value would turn into `false`. This way we have an easy way to track all the key presses without registering a specific event listener for each key press we wanna track:\n\n[{]: <helper> (diffStep 2.7)\n\n#### [Step 2.7: Add key states manager](https://github.com/DAB0mB/radial-snake/commit/831b058)\n\n##### Added resources&#x2F;scripts&#x2F;engine&#x2F;key_states.js\n```diff\n@@ -0,0 +1,20 @@\n+â”Š  â”Š 1â”ŠEngine.KeyStates = class KeyStates {\n+â”Š  â”Š 2â”Š  constructor() {\n+â”Š  â”Š 3â”Š    // We will have 255 states, each one represents an ascii code matching its index\n+â”Š  â”Š 4â”Š    this.states = new Array(255);\n+â”Š  â”Š 5â”Š  }\n+â”Š  â”Š 6â”Š\n+â”Š  â”Š 7â”Š  get(k) {\n+â”Š  â”Š 8â”Š    return this.states[k];\n+â”Š  â”Š 9â”Š  }\n+â”Š  â”Š10â”Š\n+â”Š  â”Š11â”Š  // This should be called once we press a key\n+â”Š  â”Š12â”Š  add(k) {\n+â”Š  â”Š13â”Š    this.states[k] = true;\n+â”Š  â”Š14â”Š  }\n+â”Š  â”Š15â”Š\n+â”Š  â”Š16â”Š  // This should be called once we release a key\n+â”Š  â”Š17â”Š  remove(k) {\n+â”Š  â”Š18â”Š    this.states[k] = false;\n+â”Š  â”Š19â”Š  }\n+â”Š  â”Š20â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -9,6 +9,7 @@\n â”Š 9â”Š 9â”Š\n â”Š10â”Š10â”Š    <!-- Scripts -->\n â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n+â”Š  â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/key_states.js\"></script>\n â”Š12â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n```\n\n[}]: #\n\nNow that we have the key state manager, we will initialize a new instance as part of our game's essentials, and we will create a global event listener for key presses; Each time a key is pressed, the key state manager will update itself:\n\n[{]: <helper> (diffStep 2.8)\n\n#### [Step 2.8: Register key presses](https://github.com/DAB0mB/radial-snake/commit/9f55501)\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;game.js\n```diff\n@@ -14,7 +14,7 @@\n â”Š14â”Š14â”Š    this.canvas = canvas;\n â”Š15â”Š15â”Š    this.lastUpdate = this.creation = new Date().getTime();\n â”Š16â”Š16â”Š\n-â”Š17â”Š  â”Š    // Canvas dimensions must be set programmatically otherwise you might encounter some\n+â”Š  â”Š17â”Š    // Canvas dimensions must be set programmatically, otherwise you might encounter some\n â”Š18â”Š18â”Š    // unexpected behaviors\n â”Š19â”Š19â”Š    canvas.width = 1280;\n â”Š20â”Š20â”Š    canvas.height = 720;\n```\n```diff\n@@ -24,9 +24,13 @@\n â”Š24â”Š24â”Š\n â”Š25â”Š25â”Š    // We want to focus on the canvas once we press on it\n â”Š26â”Š26â”Š    canvas.addEventListener(\"mousedown\", canvas.focus.bind(canvas), false);\n+â”Š  â”Š27â”Š    // Key flags will be registered by the \"KeyStates\" instance\n+â”Š  â”Š28â”Š    canvas.addEventListener(\"keydown\", onKeyDown.bind(this), false);\n+â”Š  â”Š29â”Š    canvas.addEventListener(\"keyup\", onKeyUp.bind(this), false);\n â”Š27â”Š30â”Š\n â”Š28â”Š31â”Š    this.assets = {};\n â”Š29â”Š32â”Š    this.events = new Map();\n+â”Š  â”Š33â”Š    this.keyStates = new Engine.KeyStates();\n â”Š30â”Š34â”Š    this.context = canvas.getContext(\"2d\");\n â”Š31â”Š35â”Š    this.bufferedCanvas = document.createElement(\"canvas\");\n â”Š32â”Š36â”Š    this.bufferedContext = this.bufferedCanvas.getContext(\"2d\");\n```\n```diff\n@@ -96,4 +100,19 @@\n â”Š 96â”Š100â”Š    this.events.delete(listener);\n â”Š 97â”Š101â”Š    this.canvas.removeEventListener(type, boundListener, false);\n â”Š 98â”Š102â”Š  }\n-â”Š 99â”Š   â”Š};ðŸš«â†µ\n+â”Š   â”Š103â”Š};\n+â”Š   â”Š104â”Š\n+â”Š   â”Š105â”Šfunction onKeyDown(e) {\n+â”Š   â”Š106â”Š  // Once we're focused on the canvas, we want nothing else to happen\n+â”Š   â”Š107â”Š  // besides events the game is listening to. For example, when we press\n+â”Š   â”Š108â”Š  // the arrow keys, this will prevent the screen from scrolling\n+â”Š   â”Š109â”Š  e.preventDefault();\n+â”Š   â”Š110â”Š  // Register key press\n+â”Š   â”Š111â”Š  this.keyStates.add(e.keyCode);\n+â”Š   â”Š112â”Š}\n+â”Š   â”Š113â”Š\n+â”Š   â”Š114â”Šfunction onKeyUp(e) {\n+â”Š   â”Š115â”Š  e.preventDefault();\n+â”Š   â”Š116â”Š  // Register key release\n+â”Š   â”Š117â”Š  this.keyStates.remove(e.keyCode);\n+â”Š   â”Š118â”Š}\n```\n\n[}]: #\n\nA 2D game's view might get complex as we go through with its development and add more logic and entities into it. Having only one `draw` method and only one `update` method is not enough, and if you think of it, it might easily get buffed up into ridiculous dimensions, which is not the way to go. I'd like to introduce you into a new methodology which involves `screens` and `layers`:\n\n- **screen** - Will literally be used whenever we want to show a new screen in our game e.g. 'splash' screen and 'main menu' screen. A screen consists of multiple layers, and will be used as their communicator; All the relevant assets and logic will be initialized inside it.\n- **layer** - similar to Photoshop's layer system, any time we want to add something to the view we add new layers on top or beneath of each other.\n\n![screen-layer](https://cloud.githubusercontent.com/assets/7648874/21487708/9b366efe-cbb7-11e6-8669-3212e440871a.png)\n\nAs I said earlier, the purpose of the screens and the layers is just to split the task of updating and drawing and updating, so we can have logical segments; So the `layer` class should mainly consist of a `draw` and an `update` method:\n\n[{]: <helper> (diffStep 2.9)\n\n#### [Step 2.9: Add screen layer](https://github.com/DAB0mB/radial-snake/commit/736ab08)\n\n##### Added resources&#x2F;scripts&#x2F;engine&#x2F;layer.js\n```diff\n@@ -0,0 +1,43 @@\n+â”Š  â”Š 1â”ŠEngine.Layer = class Layer {\n+â”Š  â”Š 2â”Š  // The dimensions of the layer are correlated to dimensions of the canvas\n+â”Š  â”Š 3â”Š  get width() {\n+â”Š  â”Š 4â”Š    return this.canvas.width;\n+â”Š  â”Š 5â”Š  }\n+â”Š  â”Š 6â”Š\n+â”Š  â”Š 7â”Š  get height() {\n+â”Š  â”Š 8â”Š    return this.canvas.height;\n+â”Š  â”Š 9â”Š  }\n+â”Š  â”Š10â”Š\n+â”Š  â”Š11â”Š  // A hash of \"eventName\" : \"handlerName\" which should be overrided by user\n+â”Š  â”Š12â”Š  get events() {\n+â”Š  â”Š13â”Š    return {};\n+â”Š  â”Š14â”Š  }\n+â”Š  â”Š15â”Š\n+â”Š  â”Š16â”Š  constructor(screen) {\n+â”Š  â”Š17â”Š    this.age = 0;\n+â”Š  â”Š18â”Š    this.creation = new Date().getTime();\n+â”Š  â”Š19â”Š    this.screen = screen;\n+â”Š  â”Š20â”Š    this.game = screen.game;\n+â”Š  â”Š21â”Š    this.assets = screen.assets;\n+â”Š  â”Š22â”Š    this.keyStates = screen.keyStates;\n+â”Š  â”Š23â”Š    this.canvas = screen.game.canvas;\n+â”Š  â”Š24â”Š  }\n+â”Š  â”Š25â”Š\n+â”Š  â”Š26â”Š  update(span) {\n+â”Š  â”Š27â”Š  }\n+â”Š  â”Š28â”Š\n+â”Š  â”Š29â”Š  draw(context) {\n+â”Š  â”Š30â”Š  }\n+â”Š  â”Š31â”Š\n+â”Š  â”Š32â”Š  initEventListeners() {\n+â”Š  â”Š33â”Š    _.each(this.events, (listener, event) => {\n+â”Š  â”Š34â”Š      this.game.addEventListener(event, this[listener], this);\n+â”Š  â”Š35â”Š    });\n+â”Š  â”Š36â”Š  }\n+â”Š  â”Š37â”Š\n+â”Š  â”Š38â”Š  disposeEventListeners() {\n+â”Š  â”Š39â”Š    _.each(this.events, (listener, event) => {\n+â”Š  â”Š40â”Š      this.game.removeEventListener(event, this[listener]);\n+â”Š  â”Š41â”Š    });\n+â”Š  â”Š42â”Š  }\n+â”Š  â”Š43â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -10,6 +10,7 @@\n â”Š10â”Š10â”Š    <!-- Scripts -->\n â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n â”Š12â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/key_states.js\"></script>\n+â”Š  â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/layer.js\"></script>\n â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š14â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n```\n\n[}]: #\n\nSame thing for the screen, it only has a `draw` and `update` methods, only it has a stack of layers, which can either be added or removed:\n\n[{]: <helper> (diffStep 2.1)\n\n#### [Step 2.1: Create basic game view](https://github.com/DAB0mB/radial-snake/commit/254f06f)\n\n##### Added views&#x2F;game.html\n```diff\n@@ -0,0 +1,10 @@\n+â”Š  â”Š 1â”Š<!DOCTYPE html>\n+â”Š  â”Š 2â”Š<html>\n+â”Š  â”Š 3â”Š  <head>\n+â”Š  â”Š 4â”Š    <title>radial snake</title>\n+â”Š  â”Š 5â”Š  </head>\n+â”Š  â”Š 6â”Š\n+â”Š  â”Š 7â”Š  <body>\n+â”Š  â”Š 8â”Š    <canvas id=\"gameCanvas\" tabindex=\"0\"></canvas>\n+â”Š  â”Š 9â”Š  </body>\n+â”Š  â”Š10â”Š</html>ðŸš«â†µ\n```\n\n[}]: #\n\nNow that we have the `screen` class available for us, let's apply it to the main game loop:\n\n[{]: <helper> (diffStep 2.11)\n\n#### [Step 2.11: Draw and update screen in game loop](https://github.com/DAB0mB/radial-snake/commit/9f34754)\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;game.js\n```diff\n@@ -30,6 +30,7 @@\n â”Š30â”Š30â”Š\n â”Š31â”Š31â”Š    this.assets = {};\n â”Š32â”Š32â”Š    this.events = new Map();\n+â”Š  â”Š33â”Š    this.screen = new Engine.Screen(this);\n â”Š33â”Š34â”Š    this.keyStates = new Engine.KeyStates();\n â”Š34â”Š35â”Š    this.context = canvas.getContext(\"2d\");\n â”Š35â”Š36â”Š    this.bufferedCanvas = document.createElement(\"canvas\");\n```\n```diff\n@@ -46,6 +47,13 @@\n â”Š46â”Š47â”Š    this.context.beginPath();\n â”Š47â”Š48â”Š    this.context.rect(0, 0, this.canvas.width, this.canvas.height);\n â”Š48â”Š49â”Š    this.context.fill();\n+â”Š  â”Š50â”Š    this.drawScreen(this.context);\n+â”Š  â”Š51â”Š  }\n+â”Š  â”Š52â”Š\n+â”Š  â”Š53â”Š  drawScreen(context) {\n+â”Š  â”Š54â”Š    // If screen's assets are not yet loaded, don't draw it\n+â”Š  â”Š55â”Š    if (this.screen.loading) return;\n+â”Š  â”Š56â”Š    if (this.screen.draw) this.screen.draw(context);\n â”Š49â”Š57â”Š  }\n â”Š50â”Š58â”Š\n â”Š51â”Š59â”Š  update() {\n```\n```diff\n@@ -56,6 +64,13 @@\n â”Š56â”Š64â”Š    this.updateScreen(span / this.speed);\n â”Š57â”Š65â”Š  }\n â”Š58â”Š66â”Š\n+â”Š  â”Š67â”Š  updateScreen(span) {\n+â”Š  â”Š68â”Š    this.screen.age += span;\n+â”Š  â”Š69â”Š    // If screen's assets are not yet loaded, don't update it\n+â”Š  â”Š70â”Š    if (this.screen.loading) return;\n+â”Š  â”Š71â”Š    if (this.screen.update) this.screen.update(span);\n+â”Š  â”Š72â”Š  }\n+â”Š  â”Š73â”Š\n â”Š59â”Š74â”Š  // The main loop of the game\n â”Š60â”Š75â”Š  loop() {\n â”Š61â”Š76â”Š    // If paused, don't run loop. The canvas will remain as is\n```\n\n[}]: #\n\nThis step looks kind of useless for now, unless we will have the ability to change screens as we please. Any time a screen is changed, it should be loaded with its necessary assets e.g textures, sounds, fonts, etc. The assets loading is an asynchronous operation whose logic might get a bit messy if not managed properly. To make it easier, we're going to define an assets loader, which will help us load assets asynchronously:\n\n[{]: <helper> (diffStep 2.12)\n\n#### [Step 2.12: Add assets loader](https://github.com/DAB0mB/radial-snake/commit/d8895f8)\n\n##### Added resources&#x2F;scripts&#x2F;engine&#x2F;assets_loader.js\n```diff\n@@ -0,0 +1,13 @@\n+â”Š  â”Š 1â”ŠEngine.AssetsLoader = class AssetsLoader {\n+â”Š  â”Š 2â”Š  constructor(next) {\n+â”Š  â”Š 3â”Š    this.next = next;\n+â”Š  â”Š 4â”Š  }\n+â”Š  â”Š 5â”Š\n+â”Š  â”Š 6â”Š  // Load texture\n+â”Š  â”Š 7â”Š  texture(path) {\n+â”Š  â”Š 8â”Š    let image = new Image();\n+â”Š  â”Š 9â”Š    image.onload = this.next();\n+â”Š  â”Š10â”Š    image.src = `${path}.png`;\n+â”Š  â”Š11â”Š    return image;\n+â”Š  â”Š12â”Š  }\n+â”Š  â”Š13â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -12,6 +12,7 @@\n â”Š12â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/key_states.js\"></script>\n â”Š13â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/layer.js\"></script>\n â”Š14â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/screen.js\"></script>\n+â”Š  â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/assets_loader.js\"></script>\n â”Š15â”Š16â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š16â”Š17â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n```\n\n[}]: #\n\n> As for now the `assets loader` only has the ability to load textures, but we will extend it as we go further in this tutorial, no need to overdo it.\n\nNow that we have the `assets loader` we can add the ability to change a screen. Whenever we change a screen, the old screen's assets should be unloaded, and the new screen's assets should be loaded using the `assets loader`:\n\n[{]: <helper> (diffStep 2.13)\n\n#### [Step 2.13: Add the ability to change and load screen](https://github.com/DAB0mB/radial-snake/commit/90aab03)\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;game.js\n```diff\n@@ -92,6 +92,61 @@\n â”Š 92â”Š 92â”Š    this.playing = false;\n â”Š 93â”Š 93â”Š  }\n â”Š 94â”Š 94â”Š\n+â”Š   â”Š 95â”Š  changeScreen(Screen, ...screenArgs) {\n+â”Š   â”Š 96â”Š    // If there is a screen defined, dispose it first\n+â”Š   â”Š 97â”Š    if (this.screen) {\n+â”Š   â”Š 98â”Š      this.unloadScreen();\n+â”Š   â”Š 99â”Š      this.screen.disposeEventListeners();\n+â”Š   â”Š100â”Š    }\n+â”Š   â”Š101â”Š\n+â”Š   â”Š102â”Š    this.screen = new Screen(this, ...screenArgs);\n+â”Š   â”Š103â”Š\n+â”Š   â”Š104â”Š    // Load screen assets\n+â”Š   â”Š105â”Š    this.loadScreen(() => {\n+â”Š   â”Š106â”Š      // Once assets are loaded, initialize event listeners\n+â”Š   â”Š107â”Š      this.screen.initEventListeners();\n+â”Š   â”Š108â”Š      // The \"initialize\" method is exactly the same as the constructor, only it runs\n+â”Š   â”Š109â”Š      // once assets are available and event listeners are registered\n+â”Š   â”Š110â”Š      this.screen.initialize(this, ...screenArgs);\n+â”Š   â”Š111â”Š    });\n+â”Š   â”Š112â”Š  }\n+â”Š   â”Š113â”Š\n+â”Š   â”Š114â”Š  // Loads screen assets and invokes callback once loading is finished\n+â”Š   â”Š115â”Š  loadScreen(callback = _.noop) {\n+â”Š   â”Š116â”Š    if (!this.screen.load) return callback();\n+â”Š   â”Š117â”Š\n+â”Š   â”Š118â”Š    this.screen.loading = true;\n+â”Š   â”Š119â”Š    // The number of assets to load\n+â”Š   â”Š120â”Š    let loadsize = 0;\n+â”Š   â”Š121â”Š    let onload;\n+â”Š   â”Š122â”Š\n+â”Š   â”Š123â”Š    // This object can load assets\n+â”Š   â”Š124â”Š    let assetsLoader = new Engine.AssetsLoader(() => {\n+â”Š   â”Š125â”Š      loadsize++;\n+â”Š   â”Š126â”Š      return () => onload();\n+â”Š   â”Š127â”Š    });\n+â”Š   â”Š128â”Š\n+â”Š   â”Š129â”Š    // The \"load\" method returns the assets loaded by the screen\n+â”Š   â”Š130â”Š    let screenAssets = this.screen.load(assetsLoader);\n+â”Š   â”Š131â”Š\n+â”Š   â”Š132â”Š    // We use the \"after\" method because we want the following callback to be invoked\n+â”Š   â”Š133â”Š    // only once all assets are loaded\n+â”Š   â”Š134â”Š    onload = _.after(loadsize, () => {\n+â”Š   â”Š135â”Š      delete this.screen.loading;\n+â”Š   â”Š136â”Š      callback();\n+â”Š   â”Š137â”Š    });\n+â”Š   â”Š138â”Š\n+â”Š   â”Š139â”Š    // The returned assets will be available on screen's assets object\n+â”Š   â”Š140â”Š    _.extend(this.screen.assets, screenAssets);\n+â”Š   â”Š141â”Š  }\n+â”Š   â”Š142â”Š\n+â”Š   â”Š143â”Š  // Disposes screen assets\n+â”Š   â”Š144â”Š  unloadScreen() {\n+â”Š   â”Š145â”Š    if (!this.screen.unload) return;\n+â”Š   â”Š146â”Š    let assetsNames = this.screen.unload();\n+â”Š   â”Š147â”Š    _.omit(this.assets, assetsNames);\n+â”Š   â”Š148â”Š  }\n+â”Š   â”Š149â”Š\n â”Š 95â”Š150â”Š  // Defines global assets\n â”Š 96â”Š151â”Š  extendAssets(assets) {\n â”Š 97â”Š152â”Š    _.extend(this.assets, assets);\n```\n\n[}]: #\n\nLet's add a test screen just so we can get the hang of it. The test screen will only print a message to the canvas:\n\n[{]: <helper> (diffStep 2.14)\n\n#### [Step 2.14: Add test screen](https://github.com/DAB0mB/radial-snake/commit/85776e8)\n\n##### Added resources&#x2F;scripts&#x2F;test_screen.js\n```diff\n@@ -0,0 +1,10 @@\n+â”Š  â”Š 1â”Šclass TestScreen extends Engine.Screen {\n+â”Š  â”Š 2â”Š  draw(context) {\n+â”Š  â”Š 3â”Š    // A 20px sized \"Georgia\" font (Available natively)\n+â”Š  â”Š 4â”Š    context.font = \"20px Georgia\";\n+â”Š  â”Š 5â”Š    // The text should be colored white\n+â”Š  â”Š 6â”Š    context.fillStyle = \"white\";\n+â”Š  â”Š 7â”Š    // Draw the following message 50px from the left and 50px from the top\n+â”Š  â”Š 8â”Š    context.fillText(\"This is a Test Screen\", 50, 50);\n+â”Š  â”Š 9â”Š  }\n+â”Š  â”Š10â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -14,6 +14,7 @@\n â”Š14â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/screen.js\"></script>\n â”Š15â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/assets_loader.js\"></script>\n â”Š16â”Š16â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n+â”Š  â”Š17â”Š    <script type=\"text/javascript\" src=\"/scripts/test_screen.js\"></script>\n â”Š17â”Š18â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n â”Š18â”Š19â”Š\n â”Š19â”Š20â”Š    <!-- Styles -->\n```\n\n[}]: #\n\nNow we will use the test screen by changing to it as we create an instance of the game:\n\n[{]: <helper> (diffStep 2.15)\n\n#### [Step 2.15: Set test screen as the initial screen](https://github.com/DAB0mB/radial-snake/commit/203d084)\n\n##### Changed resources&#x2F;scripts&#x2F;main.js\n```diff\n@@ -1,4 +1,5 @@\n â”Š1â”Š1â”Šdocument.addEventListener(\"DOMContentLoaded\", function(event) {\n â”Š2â”Š2â”Š  let game = new Engine.Game(document.getElementById(\"gameCanvas\"), false);\n+â”Š â”Š3â”Š  game.changeScreen(TestScreen);\n â”Š3â”Š4â”Š  game.play();\n â”Š4â”Š5â”Š});ðŸš«â†µ\n```\n\n[}]: #\n\nOnce you will load the application you should see a black canvas with a white text saying:\n\n    This is a test screen\n\nIt means our screen system works and you may proceed to the next step, where we're gonna create our first screen :-)"
          },
          {
            "manualTitle": "Step 3: Creating a splash screen using a keyframe animation engine",
            "stepRevision": "4b2431bbc910f8945e5fd86aa964fec3ede8761c",
            "manualView": "![snake-demo-splash-small](https://cloud.githubusercontent.com/assets/7648874/21074086/a19fa9ce-bed6-11e6-9060-2ce94c215712.gif)\n\nIn this step we will be creating the `splash` screen - the initial screen that should be shown once we launch the game. Our splash is consisted of a random logo animation as presented in the `gif` file above. The \"splash\" effect can be achieved using 2 concepts:\n\n- A sprite class - Which will present the logo texture in different dimensions, angles and rotations.\n- A key-frame animation - Which will draw an animation automatically along the time axis using key-frames - each is a sprite representation of the texture in a specific time point.\n\nSo first thing first, we will start by implementing the sprite class:\n\n[{]: <helper> (diffStep 3.1)\n\n#### [Step 3.1: Create &#x27;Sprite&#x27; class](https://github.com/DAB0mB/radial-snake/commit/a32a711)\n\n##### Added resources&#x2F;scripts&#x2F;engine&#x2F;sprite.js\n```diff\n@@ -0,0 +1,58 @@\n+â”Š  â”Š 1â”ŠEngine.Sprite = class Sprite {\n+â”Š  â”Š 2â”Š  // An easy representation of a sprite on a canvas, with a set of convenient tools\n+â”Š  â”Š 3â”Š  // for alignment and coloring\n+â”Š  â”Š 4â”Š  constructor(texture) {\n+â”Š  â”Š 5â”Š    this.texture = texture;\n+â”Š  â”Š 6â”Š    this.x = 0;\n+â”Š  â”Š 7â”Š    this.y = 0;\n+â”Š  â”Š 8â”Š    this.width = texture.width;\n+â”Š  â”Š 9â”Š    this.height = texture.height;\n+â”Š  â”Š10â”Š    this.pivot = { x: 0, y: 0 };\n+â”Š  â”Š11â”Š    this.opacity = 1;\n+â”Š  â”Š12â”Š  }\n+â”Š  â”Š13â”Š\n+â”Š  â”Š14â”Š  draw(context, offsetX = 0, offsetY = 0) {\n+â”Š  â”Š15â”Š    context.save();\n+â”Š  â”Š16â”Š    context.globalAlpha = this.opacity;\n+â”Š  â”Š17â”Š\n+â”Š  â”Š18â”Š    // The following switch-case can also be seen as a list of all possible\n+â”Š  â”Š19â”Š    // alignment modes\n+â”Š  â”Š20â”Š    switch (this.align) {\n+â”Š  â”Š21â”Š      case \"top-left\": case \"left-top\": this.pivot = { x: 0, y: 0 }; break;\n+â”Š  â”Š22â”Š      case \"top-right\": case \"right-top\": this.pivot = { x: this.width, y: 0 }; break;\n+â”Š  â”Š23â”Š      case \"bottom-left\": case \"left-bottom\": this.pivot = { x: 0, y: this.height }; break;\n+â”Š  â”Š24â”Š      case \"bottom-right\": case \"right-bottom\": this.pivot = { x: this.width, y: this.height }; break;\n+â”Š  â”Š25â”Š      case \"middle\": case \"center\": this.pivot = { x: this.width / 2, y: this.height / 2 }; break;\n+â”Š  â”Š26â”Š      case \"left\": this.pivot = { x: 0, y: this.height / 2 }; break;\n+â”Š  â”Š27â”Š      case \"top\": this.pivot = { x: this.width / 2, y: 0 }; break;\n+â”Š  â”Š28â”Š      case \"right\": this.pivot = { x: this.width, y: this.height / 2 }; break;\n+â”Š  â”Š29â”Š      case \"bottom\": this.pivot = { x: this.width / 2, y: this.height }; break;\n+â”Š  â”Š30â”Š    }\n+â”Š  â”Š31â”Š\n+â”Š  â”Š32â”Š    context.drawImage(\n+â”Š  â”Š33â”Š      this.texture,\n+â”Š  â”Š34â”Š      (this.x - this.pivot.x) + offsetX,\n+â”Š  â”Š35â”Š      (this.y - this.pivot.y) + offsetY,\n+â”Š  â”Š36â”Š      this.width,\n+â”Š  â”Š37â”Š      this.height\n+â”Š  â”Š38â”Š    );\n+â”Š  â”Š39â”Š\n+â”Š  â”Š40â”Š    context.restore();\n+â”Š  â”Š41â”Š  }\n+â”Š  â”Š42â”Š\n+â”Š  â”Š43â”Š  // A sprite property (key) can also be resized based on a given percentage.\n+â”Š  â”Š44â”Š  // The 'relative' argument represents the whole of which the percents are gonna be\n+â”Š  â”Š45â”Š  // calculated from, and the 'adapters' argument is an array of property names which\n+â”Š  â”Š46â”Š  // gonna adapt themselves based on the changes made in the given key.\n+â”Š  â”Š47â”Š  // Usually 'width' goes along with ['height'] adapters, if we\n+â”Š  â”Š48â”Š  // want to keep their original ratio\n+â”Š  â”Š49â”Š  setPercentage(key, relative, percents, ...adapters) {\n+â”Š  â”Š50â”Š    let oldVal = this[key];\n+â”Š  â”Š51â”Š    let newVal = this[key] = (percents * relative) / 100;\n+â”Š  â”Š52â”Š    let ratio = newVal / oldVal;\n+â”Š  â”Š53â”Š\n+â”Š  â”Š54â”Š    adapters.forEach(adapter => {\n+â”Š  â”Š55â”Š      this[adapter] *= ratio;\n+â”Š  â”Š56â”Š    });\n+â”Š  â”Š57â”Š  }\n+â”Š  â”Š58â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -9,6 +9,7 @@\n â”Š 9â”Š 9â”Š\n â”Š10â”Š10â”Š    <!-- Scripts -->\n â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n+â”Š  â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/sprite.js\"></script>\n â”Š12â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/key_states.js\"></script>\n â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/layer.js\"></script>\n â”Š14â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/screen.js\"></script>\n```\n\n[}]: #\n\nAnd we will download the logo which will be presented in the splash screen using the sprite class:\n\n    resources$ mkdir assets\n    resources$ cd assets\n    resources/assets$ mkdir textures\n    resources/assets$ cd textures\n    resources/assets/textures$ wget raw.githubusercontent.com/dab0mb/radial-snake/master/resources/assets/textures/splash.png\n\n> Any logo can that you desired can be used instead! But to ease things up I already provided you with one as a sample\n\nNow we will create the initial splash screen, where we only gonna show a sprite of the logo in the middle of the screen, with no animation applied yet. We will first define a dedicated `Screens` module under the `Game` namespace:\n\n[{]: <helper> (diffStep 3.3)\n\n#### [Step 3.3: Create a &#x27;Game&#x27; namespace with a &#x27;Screens&#x27; module](https://github.com/DAB0mB/radial-snake/commit/ae85a96)\n\n##### Changed resources&#x2F;scripts&#x2F;namespaces.js\n```diff\n@@ -1 +1,5 @@\n+â”Š â”Š1â”ŠGame = {\n+â”Š â”Š2â”Š  Screens: {}\n+â”Š â”Š3â”Š};\n+â”Š â”Š4â”Š\n â”Š1â”Š5â”ŠEngine = {};ðŸš«â†µ\n```\n\n[}]: #\n\nAnd we can go ahead and implement the screen itself:\n\n[{]: <helper> (diffStep 3.4)\n\n#### [Step 3.4: Create initial splash screen](https://github.com/DAB0mB/radial-snake/commit/4dd73f3)\n\n##### Added resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;splash&#x2F;index.js\n```diff\n@@ -0,0 +1,19 @@\n+â”Š  â”Š 1â”ŠGame.Screens.Splash = class Splash extends Engine.Screen {\n+â”Š  â”Š 2â”Š  initialize() {\n+â”Š  â”Š 3â”Š    // Create splash sprite and set its properties\n+â”Š  â”Š 4â”Š    this.splashSprite = new Engine.Sprite(this.assets.splashTexture);\n+â”Š  â”Š 5â”Š    this.splashSprite.align = \"center\";\n+â”Š  â”Š 6â”Š    this.splashSprite.x = this.width / 2;\n+â”Š  â”Š 7â”Š  }\n+â”Š  â”Š 8â”Š\n+â”Š  â”Š 9â”Š  load(assetsLoader) {\n+â”Š  â”Š10â”Š    // These are local assets which will be disposed along with the screen\n+â”Š  â”Š11â”Š    return {\n+â”Š  â”Š12â”Š      splashTexture: assetsLoader.texture(\"/textures/splash\")\n+â”Š  â”Š13â”Š    };\n+â”Š  â”Š14â”Š  }\n+â”Š  â”Š15â”Š\n+â”Š  â”Š16â”Š  draw(context) {\n+â”Š  â”Š17â”Š    this.splashSprite.draw(context);\n+â”Š  â”Š18â”Š  }\n+â”Š  â”Š19â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -16,6 +16,7 @@\n â”Š16â”Š16â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/assets_loader.js\"></script>\n â”Š17â”Š17â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š18â”Š18â”Š    <script type=\"text/javascript\" src=\"/scripts/test_screen.js\"></script>\n+â”Š  â”Š19â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/splash/index.js\"></script>\n â”Š19â”Š20â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n â”Š20â”Š21â”Š\n â”Š21â”Š22â”Š    <!-- Styles -->\n```\n\n[}]: #\n\nNow we can set the splash screen as the initial screen in the entry script file:\n\n[{]: <helper> (diffStep 3.5)\n\n#### [Step 3.5: Set splash screen as the initial game screen](https://github.com/DAB0mB/radial-snake/commit/3576ff8)\n\n##### Changed resources&#x2F;scripts&#x2F;main.js\n```diff\n@@ -1,5 +1,5 @@\n â”Š1â”Š1â”Šdocument.addEventListener(\"DOMContentLoaded\", function(event) {\n â”Š2â”Š2â”Š  let game = new Engine.Game(document.getElementById(\"gameCanvas\"), false);\n-â”Š3â”Š â”Š  game.changeScreen(TestScreen);\n+â”Š â”Š3â”Š  game.changeScreen(Game.Screens.Splash);\n â”Š4â”Š4â”Š  game.play();\n â”Š5â”Š5â”Š});ðŸš«â†µ\n```\n\n[}]: #\n\nAnd we will get rid of the unnecessary test screen since we make no use of it any longer:\n\n    $ rm resources/scripts/test_screen.js\n\nWe will now proceed into the next stage where we will be implementing the key-frame animation engine as said at the beginning of the step. We first need to define an `Animations` module, since we can have multiple types of animation strategy like [sprite-atlas animation](http://www.joshmorony.com/how-to-create-animations-in-phaser-with-a-texture-atlas/), not necessarily a key-frame animation:\n\n[{]: <helper> (diffStep 3.7)\n\n#### [Step 3.7: Add &#x27;Animations&#x27; module to &#x27;Engine&#x27; namespace](https://github.com/DAB0mB/radial-snake/commit/ffe800c)\n\n##### Changed resources&#x2F;scripts&#x2F;namespaces.js\n```diff\n@@ -2,4 +2,6 @@\n â”Š2â”Š2â”Š  Screens: {}\n â”Š3â”Š3â”Š};\n â”Š4â”Š4â”Š\n-â”Š5â”Š â”ŠEngine = {};ðŸš«â†µ\n+â”Š â”Š5â”ŠEngine = {\n+â”Š â”Š6â”Š  Animations: {}\n+â”Š â”Š7â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nInside the newly created module we will create the key-frame animation engine. The key-frame animation consists of the following methods:\n\n- update - Updates the animation.\n- draw - Draws the current animation frame on the provided canvas context.\n- play - Enables update operations.\n- pause - Disables update operations.\n\n[{]: <helper> (diffStep 3.8)\n\n#### [Step 3.8: Create a key-frame animation engine](https://github.com/DAB0mB/radial-snake/commit/64c58fb)\n\n##### Added resources&#x2F;scripts&#x2F;engine&#x2F;animations&#x2F;keyframe.js\n```diff\n@@ -0,0 +1,142 @@\n+â”Š   â”Š  1â”ŠEngine.Animations.Keyframe = class Keyframe {\n+â”Š   â”Š  2â”Š  constructor(sprite, keyframes) {\n+â”Š   â”Š  3â”Š    this.sprite = sprite;\n+â”Š   â”Š  4â”Š    // The key-frames array contains objects with the properties of the\n+â”Š   â”Š  5â”Š    // sprite at the current time-point, e.g. width of 100 and height of 200\n+â”Š   â”Š  6â”Š    this.keyframes = keyframes;\n+â”Š   â”Š  7â”Š    this.age = 0;\n+â”Š   â”Š  8â”Š    this.frame = 0;\n+â”Š   â”Š  9â”Š    // This flag determines what's gonna happen to the animation once\n+â”Š   â”Š 10â”Š    // it's finished playing\n+â”Š   â”Š 11â”Š    this.repetitionMode = \"none\";\n+â”Š   â”Š 12â”Š    this.lastKeyframe = _.last(keyframes);\n+â”Š   â”Š 13â”Š    this.lastFrame = this.lastKeyframe.frame;\n+â”Š   â”Š 14â”Š\n+â”Š   â”Š 15â”Š    // These are the properties which we can animate\n+â”Š   â”Š 16â”Š    this.animables = [\n+â”Š   â”Š 17â”Š      \"x\", \"y\", \"width\", \"height\", \"opacity\"\n+â”Š   â”Š 18â”Š    ];\n+â”Š   â”Š 19â”Š\n+â”Š   â”Š 20â”Š    // Set a map whose keys represent animatable properties and values represent an array\n+â”Š   â”Š 21â”Š    // with relevant key-frames to its belonging property\n+â”Š   â”Š 22â”Š    this.trimmedKeyframes = this.animables.reduce((trimmedKeyframes, key) => {\n+â”Š   â”Š 23â”Š      trimmedKeyframes[key] = keyframes.filter(keyframe => keyframe[key] != null);\n+â”Š   â”Š 24â”Š      return trimmedKeyframes;\n+â”Š   â”Š 25â”Š    }, {});\n+â”Š   â”Š 26â”Š\n+â”Š   â”Š 27â”Š    // Set initial properties on sprite based on initial key-frame\n+â”Š   â”Š 28â”Š    _.each(keyframes[0], (value, key) => {\n+â”Š   â”Š 29â”Š      if (this.animables.includes(key)) sprite[key] = value;\n+â”Š   â”Š 30â”Š    });\n+â”Š   â”Š 31â”Š  }\n+â”Š   â”Š 32â”Š\n+â”Š   â”Š 33â”Š  draw(context, offsetX, offsetY) {\n+â”Š   â”Š 34â”Š    this.sprite.draw(context, offsetX, offsetY);\n+â”Š   â”Š 35â”Š  }\n+â”Š   â”Š 36â”Š\n+â”Š   â”Š 37â”Š  update(span) {\n+â”Š   â”Š 38â”Š    if (!this.playing) return;\n+â”Š   â”Š 39â”Š\n+â”Š   â”Š 40â”Š    this.age += span;\n+â”Š   â”Š 41â”Š\n+â”Š   â”Š 42â”Š    switch (this.repetitionMode) {\n+â”Š   â”Š 43â”Š      // After one cycle animation would stop\n+â”Š   â”Š 44â”Š      case \"none\":\n+â”Š   â”Š 45â”Š        this.frame += span;\n+â”Š   â”Š 46â”Š\n+â”Š   â”Š 47â”Š        if (this.frame > this.lastFrame) {\n+â”Š   â”Š 48â”Š          this.frame = this.lastFrame;\n+â”Š   â”Š 49â”Š          this.playing = false;\n+â”Š   â”Š 50â”Š        }\n+â”Š   â”Š 51â”Š\n+â”Š   â”Š 52â”Š        break;\n+â”Š   â”Š 53â”Š\n+â”Š   â”Š 54â”Š      // Once finished, replay from the beginning\n+â”Š   â”Š 55â”Š      case \"cyclic\":\n+â”Š   â”Š 56â”Š        this.frame = this.age % this.lastFrame;\n+â”Š   â”Š 57â”Š        break;\n+â”Š   â”Š 58â”Š\n+â”Š   â”Š 59â”Š      // Once finished, play backwards, and so on\n+â”Š   â”Š 60â”Š      case \"full\":\n+â”Š   â”Š 61â”Š        this.frame = this.age % this.lastFrame;\n+â”Š   â”Š 62â”Š        let animationComplete = (this.age / this.lastFrame) % 2 >= 1;\n+â”Š   â”Š 63â”Š        if (animationComplete) this.frame = this.lastFrame - this.frame;\n+â”Š   â”Š 64â”Š        break;\n+â”Š   â”Š 65â”Š    }\n+â”Š   â”Š 66â”Š\n+â”Š   â”Š 67â”Š    // Update sprite properties based on given key-frame's easing mode\n+â”Š   â”Š 68â”Š    this.animables.forEach(key => {\n+â”Š   â”Š 69â”Š      let motion = this.getKeyframeMotion(key);\n+â”Š   â”Š 70â”Š\n+â”Š   â”Š 71â”Š      if (motion)\n+â”Š   â”Š 72â”Š        this.sprite[key] = this.calculateRelativeValue(motion, key);\n+â”Š   â”Š 73â”Š    });\n+â”Š   â”Š 74â”Š  }\n+â”Š   â”Š 75â”Š\n+â”Š   â”Š 76â”Š  play() {\n+â”Š   â”Š 77â”Š    this.playing = true;\n+â”Š   â”Š 78â”Š  }\n+â”Š   â”Š 79â”Š\n+â”Š   â”Š 80â”Š  pause() {\n+â”Š   â”Š 81â”Š    this.playing = false;\n+â”Š   â”Š 82â”Š  }\n+â”Š   â”Š 83â”Š\n+â”Š   â”Š 84â”Š  // Gets motion for current refresh\n+â”Š   â”Š 85â”Š  getKeyframeMotion(key) {\n+â”Š   â”Š 86â”Š    let keyframes = this.trimmedKeyframes[key];\n+â”Š   â”Š 87â”Š\n+â”Š   â”Š 88â”Š    // If no key-frames defined, motion is idle\n+â”Š   â”Š 89â”Š    if (keyframes == null) return;\n+â”Š   â”Š 90â”Š    // If there is only one key frame, motion is idle\n+â”Š   â”Š 91â”Š    if (keyframes.length < 2) return;\n+â”Š   â”Š 92â”Š    // If last frame reached, motion is idle\n+â”Š   â”Š 93â”Š    if (this.frame > _.last(keyframes).frame) return;\n+â”Š   â”Š 94â”Š\n+â”Š   â”Š 95â”Š    let start = this.findStartKeyframe(keyframes);\n+â”Š   â”Š 96â”Š    let end = this.findEndKeyframe(keyframes);\n+â”Š   â”Š 97â”Š    let ratio = this.getKeyframesRatio(start, end);\n+â”Š   â”Š 98â”Š\n+â”Š   â”Š 99â”Š    return { start, end, ratio };\n+â”Š   â”Š100â”Š  }\n+â”Š   â”Š101â”Š\n+â”Š   â”Š102â”Š  // Gets the movement ratio\n+â”Š   â”Š103â”Š  getKeyframesRatio(start, end) {\n+â”Š   â”Š104â”Š    return (this.frame - start.frame) / (end.frame - start.frame);\n+â”Š   â”Š105â”Š  }\n+â”Š   â”Š106â”Š\n+â”Š   â”Š107â”Š  // Get property end value based on current frame\n+â”Š   â”Š108â”Š  findEndKeyframe(keyframes) {\n+â”Š   â”Š109â”Š    return _.find(keyframes, keyframe =>\n+â”Š   â”Š110â”Š      keyframe.frame >= (this.frame || 1)\n+â”Š   â”Š111â”Š    );\n+â”Š   â”Š112â”Š  }\n+â”Š   â”Š113â”Š\n+â”Š   â”Š114â”Š  // Get property start value based on current frame\n+â”Š   â”Š115â”Š  findStartKeyframe(keyframes) {\n+â”Š   â”Š116â”Š    let resultIndex;\n+â”Š   â”Š117â”Š\n+â”Š   â”Š118â”Š    keyframes.some((keyframe, currIndex) => {\n+â”Š   â”Š119â”Š      if (keyframe.frame >= (this.frame || 1)) {\n+â”Š   â”Š120â”Š        resultIndex = currIndex;\n+â”Š   â”Š121â”Š        return true;\n+â”Š   â”Š122â”Š      }\n+â”Š   â”Š123â”Š    });\n+â”Š   â”Š124â”Š\n+â”Š   â”Š125â”Š    return keyframes[resultIndex - 1];\n+â”Š   â”Š126â”Š  }\n+â”Š   â”Š127â”Š\n+â”Š   â”Š128â”Š  // Get a recalculated property value relative to provided easing mode\n+â”Š   â”Š129â”Š  calculateRelativeValue(motion, key) {\n+â”Š   â”Š130â”Š    let a = motion.start[key];\n+â”Š   â”Š131â”Š    let b = motion.end[key];\n+â”Š   â”Š132â”Š    let r = motion.ratio;\n+â”Š   â”Š133â”Š    let easing = r > 0 ? motion.start.easing : motion.end.easing;\n+â”Š   â”Š134â”Š\n+â”Š   â”Š135â”Š    switch (easing) {\n+â”Š   â”Š136â”Š      case \"in\": r = Math.sin((r * Math.PI) / 2); break;\n+â”Š   â”Š137â”Š      case \"out\": r = Math.cos((r * Math.PI) / 2); break;\n+â”Š   â”Š138â”Š    }\n+â”Š   â”Š139â”Š\n+â”Š   â”Š140â”Š    return ((b - a) * r) + a;\n+â”Š   â”Š141â”Š  }\n+â”Š   â”Š142â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -10,6 +10,7 @@\n â”Š10â”Š10â”Š    <!-- Scripts -->\n â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n â”Š12â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/sprite.js\"></script>\n+â”Š  â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/animations/keyframe.js\"></script>\n â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/key_states.js\"></script>\n â”Š14â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/layer.js\"></script>\n â”Š15â”Š16â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/screen.js\"></script>\n```\n\n[}]: #\n\nWhen initializing a new instance of the key-frame animation, we should invoke it with the desired sprite, and an array of key-frames. What exactly does a single key-frame represents? The properties of the sprite at that specific time point. In addition, a key-frame can be set with an [easing mode](https://css-tricks.com/ease-out-in-ease-in-out/) of `in` and `out`. By default, the animation would be linear.\n\nBased on the `repitationMode` property, three things can happen to the animation once finished:\n\n- `none` - The animation will play once, and then stop. It will appear as a static sprite.\n- `cyclic` - The animation will repeat itself from the beginning, over and over again until stopped manually.\n- `full` - The animation will play itself backwards, and then forwards, backwards, forwards, and so on.\n\nThanks to the key-frame animation engine, we can apply it to the splash screen to show a beautifully animated logo rather than showing a static image. So in addition to the logo sprite, we will initialize a key-frame animation as well:\n\n[{]: <helper> (diffStep 3.9)\n\n#### [Step 3.9: Apply key-frame animation to splash screen](https://github.com/DAB0mB/radial-snake/commit/8ca47e5)\n\n##### Changed resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;splash&#x2F;index.js\n```diff\n@@ -1,9 +1,34 @@\n â”Š 1â”Š 1â”ŠGame.Screens.Splash = class Splash extends Engine.Screen {\n â”Š 2â”Š 2â”Š  initialize() {\n â”Š 3â”Š 3â”Š    // Create splash sprite and set its properties\n-â”Š 4â”Š  â”Š    this.splashSprite = new Engine.Sprite(this.assets.splashTexture);\n-â”Š 5â”Š  â”Š    this.splashSprite.align = \"center\";\n-â”Š 6â”Š  â”Š    this.splashSprite.x = this.width / 2;\n+â”Š  â”Š 4â”Š    let splashSprite = new Engine.Sprite(this.assets.splashTexture);\n+â”Š  â”Š 5â”Š    splashSprite.align = \"center\";\n+â”Š  â”Š 6â”Š    splashSprite.x = this.width / 2;\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Š    // Create splash sprite animation\n+â”Š  â”Š 9â”Š    this.splashAnim = new Engine.Animations.Keyframe(splashSprite, [\n+â”Š  â”Š10â”Š      {\n+â”Š  â”Š11â”Š        y: (this.height / 2) - 30,\n+â”Š  â”Š12â”Š        width: splashSprite.width / 4,\n+â”Š  â”Š13â”Š        height: splashSprite.height / 4,\n+â”Š  â”Š14â”Š        opacity: 0,\n+â”Š  â”Š15â”Š        easing: \"in\",\n+â”Š  â”Š16â”Š        frame: 0\n+â”Š  â”Š17â”Š      },\n+â”Š  â”Š18â”Š      {\n+â”Š  â”Š19â”Š        y: this.height / 2,\n+â”Š  â”Š20â”Š        width: (splashSprite.width / 3) + (splashSprite.width * 0.05),\n+â”Š  â”Š21â”Š        height: (splashSprite.height / 3) + (splashSprite.height * 0.05),\n+â”Š  â”Š22â”Š        opacity: 1,\n+â”Š  â”Š23â”Š        frame: 3000\n+â”Š  â”Š24â”Š      },\n+â”Š  â”Š25â”Š      {\n+â”Š  â”Š26â”Š        frame: 3500\n+â”Š  â”Š27â”Š      }\n+â”Š  â”Š28â”Š    ]);\n+â”Š  â”Š29â”Š\n+â”Š  â”Š30â”Š    // Start playing animation\n+â”Š  â”Š31â”Š    this.splashAnim.play();\n â”Š 7â”Š32â”Š  }\n â”Š 8â”Š33â”Š\n â”Š 9â”Š34â”Š  load(assetsLoader) {\n```\n```diff\n@@ -14,6 +39,10 @@\n â”Š14â”Š39â”Š  }\n â”Š15â”Š40â”Š\n â”Š16â”Š41â”Š  draw(context) {\n-â”Š17â”Š  â”Š    this.splashSprite.draw(context);\n+â”Š  â”Š42â”Š    this.splashAnim.draw(context);\n+â”Š  â”Š43â”Š  }\n+â”Š  â”Š44â”Š\n+â”Š  â”Š45â”Š  update(span) {\n+â”Š  â”Š46â”Š    this.splashAnim.update(span);\n â”Š18â”Š47â”Š  }\n â”Š19â”Š48â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nThe following key-frames illustrate the nodes of the animation we've just created:\n\n    width: 0\n    height: 0\n    opacity: 0\n\n![logo-empty](https://cloud.githubusercontent.com/assets/7648874/21583394/ee7a1dec-d065-11e6-80ce-fdd37c4b5dbb.png)\n\n    width: 225\n    height: 175\n    opacity: 1\n\n![logo-half](https://cloud.githubusercontent.com/assets/7648874/21583396/ee9bdf68-d065-11e6-95fb-4cf5ed58a9de.png)\n\n    width: 342\n    height: 266\n    opacity: 1\n\n![logo-full](https://cloud.githubusercontent.com/assets/7648874/21583395/ee7b3754-d065-11e6-9646-476d196a6412.png)"
          },
          {
            "manualTitle": "Step 4: Creating a main menu screen using a font engine",
            "stepRevision": "f88428bffcdf2bcf269b9cc15837cc40e0ed9caf",
            "manualView": "![snake-demo-menu-small](https://cloud.githubusercontent.com/assets/7648874/21074099/e72a81bc-bed6-11e6-98cb-329dc12a4b06.gif)\n\nIn this step we will be creating the main menu screen as shown above. The main menu screen is a simple screen which will show the logo of the game and an instruction text saying `Press a key to start`. We will be using a simple texture to show the game-logo and we will use the key-frame animation engine to show a flickering animation of the instruction text. The instruction text is the main part of this step, since it is made out of a font file (`.ttf`) and the text is auto-generated, a general solution which can serve us in many situations. We will start by implementing the main menu using static assets, which means that we will use a texture to show the instructions text, and later on we will implement the generic solution I've just mentioned. First, we will download the necessary assets:\n\n    resources/assets/textures$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/assets/textures/instructions.png\n    resources/assets/textures$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/assets/textures/logo.png\n\nAnd then we will implement the initial main menu screen:\n\n[{]: <helper> (diffStep 4.2)\n\n#### [Step 4.2: Create initial main menu screen](https://github.com/DAB0mB/radial-snake/commit/ed79de7)\n\n##### Added resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;menu&#x2F;index.js\n```diff\n@@ -0,0 +1,44 @@\n+â”Š  â”Š 1â”ŠGame.Screens.Menu = class Menu extends Engine.Screen {\n+â”Š  â”Š 2â”Š  initialize() {\n+â”Š  â”Š 3â”Š    // Initialize snake logo sprite\n+â”Š  â”Š 4â”Š    this.logoSprite = new Engine.Sprite(this.assets.logoTexture);\n+â”Š  â”Š 5â”Š    this.logoSprite.setPercentage(\"width\", this.width, 30, \"height\");\n+â”Š  â”Š 6â”Š\n+â”Š  â”Š 7â”Š    // Initialize instructions sprite\n+â”Š  â”Š 8â”Š    let instructionsSprite = new Engine.Sprite(this.assets.instructionsTexture);\n+â”Š  â”Š 9â”Š    instructionsSprite.align = \"center\";\n+â”Š  â”Š10â”Š    instructionsSprite.setPercentage(\"width\", this.width, 35, \"height\");\n+â”Š  â”Š11â”Š    instructionsSprite.x = this.width / 2;\n+â”Š  â”Š12â”Š    instructionsSprite.y = this.height / 2;\n+â”Š  â”Š13â”Š\n+â”Š  â”Š14â”Š    // Create flickering animation for instructions sprite\n+â”Š  â”Š15â”Š    this.instructionsAnim = new Engine.Animations.Keyframe(instructionsSprite, [\n+â”Š  â”Š16â”Š      {\n+â”Š  â”Š17â”Š        opacity: 1,\n+â”Š  â”Š18â”Š        frame: 0\n+â”Š  â”Š19â”Š      },\n+â”Š  â”Š20â”Š      {\n+â”Š  â”Š21â”Š        opacity: 0,\n+â”Š  â”Š22â”Š        frame: 2000\n+â”Š  â”Š23â”Š      }\n+â”Š  â”Š24â”Š    ]);\n+â”Š  â”Š25â”Š\n+â”Š  â”Š26â”Š    // Play it repeatedly, back and forth\n+â”Š  â”Š27â”Š    this.instructionsAnim.repetitionMode = \"full\";\n+â”Š  â”Š28â”Š    this.instructionsAnim.play();\n+â”Š  â”Š29â”Š  }\n+â”Š  â”Š30â”Š\n+â”Š  â”Š31â”Š  unload() {\n+â”Š  â”Š32â”Š    // Dispose the following assets to prevent memory leaks\n+â”Š  â”Š33â”Š    return [\"logoTexture\", \"instructionsTexture\"];\n+â”Š  â”Š34â”Š  }\n+â”Š  â”Š35â”Š\n+â”Š  â”Š36â”Š  draw(context) {\n+â”Š  â”Š37â”Š    this.logoSprite.draw(context);\n+â”Š  â”Š38â”Š    this.instructionsAnim.draw(context);\n+â”Š  â”Š39â”Š  }\n+â”Š  â”Š40â”Š\n+â”Š  â”Š41â”Š  update(span) {\n+â”Š  â”Š42â”Š    this.instructionsAnim.update(span);\n+â”Š  â”Š43â”Š  }\n+â”Š  â”Š44â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -16,6 +16,7 @@\n â”Š16â”Š16â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/screen.js\"></script>\n â”Š17â”Š17â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/assets_loader.js\"></script>\n â”Š18â”Š18â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n+â”Š  â”Š19â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/menu/index.js\"></script>\n â”Š19â”Š20â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/splash/index.js\"></script>\n â”Š20â”Š21â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n```\n\n[}]: #\n\nThis screen is dependent on several assets which we will load during \"splash screen time\", to save some loading time and for a smooth experience. The main menu screen will be shown automatically once the splash animation has been finished:\n\n[{]: <helper> (diffStep 4.3)\n\n#### [Step 4.3: Queue main menu screen](https://github.com/DAB0mB/radial-snake/commit/cd83a30)\n\n##### Changed resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;splash&#x2F;index.js\n```diff\n@@ -32,10 +32,21 @@\n â”Š32â”Š32â”Š  }\n â”Š33â”Š33â”Š\n â”Š34â”Š34â”Š  load(assetsLoader) {\n+â”Š  â”Š35â”Š    // Load assets\n+â”Š  â”Š36â”Š    let instructionsTexture = assetsLoader.texture(\"/textures/instrucitons\");\n+â”Š  â”Š37â”Š    let logoTexture = assetsLoader.texture(\"/textures/logo\");\n+â”Š  â”Š38â”Š    let splashTexture = assetsLoader.texture(\"/textures/splash\");\n+â”Š  â”Š39â”Š\n+â”Š  â”Š40â”Š    // These are global assets which will be shared among all screens until manually\n+â”Š  â”Š41â”Š    // disposed. We use the time gap created by the splash animation to load necessary\n+â”Š  â”Š42â”Š    // assets without wasting any time\n+â”Š  â”Š43â”Š    this.game.extendAssets({\n+â”Š  â”Š44â”Š      instructionsTexture,\n+â”Š  â”Š45â”Š      logoTexture\n+â”Š  â”Š46â”Š    });\n+â”Š  â”Š47â”Š\n â”Š35â”Š48â”Š    // These are local assets which will be disposed along with the screen\n-â”Š36â”Š  â”Š    return {\n-â”Š37â”Š  â”Š      splashTexture: assetsLoader.texture(\"/textures/splash\")\n-â”Š38â”Š  â”Š    };\n+â”Š  â”Š49â”Š    return { splashTexture };\n â”Š39â”Š50â”Š  }\n â”Š40â”Š51â”Š\n â”Š41â”Š52â”Š  draw(context) {\n```\n```diff\n@@ -43,6 +54,12 @@\n â”Š43â”Š54â”Š  }\n â”Š44â”Š55â”Š\n â”Š45â”Š56â”Š  update(span) {\n-â”Š46â”Š  â”Š    this.splashAnim.update(span);\n+â”Š  â”Š57â”Š    if (this.splashAnim.playing) {\n+â”Š  â”Š58â”Š      this.splashAnim.update(span);\n+â”Š  â”Š59â”Š    }\n+â”Š  â”Š60â”Š    // Once animation has stopped play switch to main menu\n+â”Š  â”Š61â”Š    else {\n+â”Š  â”Š62â”Š      this.game.changeScreen(Game.Screens.Menu);\n+â”Š  â”Š63â”Š    }\n â”Š47â”Š64â”Š  }\n â”Š48â”Š65â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nBy now if you launch the application you should see the main menu screen as described in the beginning. But event though it works, we're not yet finished. We still need to convert the instruction texture into an auto-generated font texture. Obviously, this requires us to download the desired `ttf` file:\n\n    resources/assets/fonts$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/assets/fonts/minecraftia.ttf\n\n> Any font file can be used here, but to save time and effort I already provided you with one\n\n`ttf` is the most common format, but since we're using JavaScript, it would make sense to convert it into a `json` file, and that's exactly what we're going to do. There's a very convenient software called [font-builder](https://github.com/andryblack/fontbuilder), and it can cut fonts, store them in `png` files, along with some user-specified meta-data stored in an `xml` file.\n\n![font-builder](https://camo.githubusercontent.com/b2c95cda825c783f5399d9197599848c33cdfcc8/687474703a2f2f7777772e67616d656465762e72752f66696c65732f696d616765732f73637265656e312e6a706567)\n\nGo over to this website: https://github.com/andryblack/fontbuilder.\nFetch a copy of the `font-builder` repo, and try to convert the `minecraftia.ttf` file into a `png` file. If you want to skip this step, although I wouldn't recommend it, you can download the following files which I already generated myself:\n\n    resources/assets/fonts$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/assets/fonts/minecraftia.png\n    resources/assets/fonts$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/assets/fonts/minecraftia.xml\n\nAs promised, we will be working with a `json` file, not a `ttf` file and not an `xml` file. For this task we will be implementing a font-parser module, which will simply take all the meta-data in the `xml` file and put it into a nice `json` schema:\n\n[{]: <helper> (diffStep 4.6)\n\n#### [Step 4.6: Create font parser so we can convert &#x27;xml&#x27; font format to &#x27;json&#x27;](https://github.com/DAB0mB/radial-snake/commit/66044e9)\n\n##### Added helpers&#x2F;font_parser.js\n```diff\n@@ -0,0 +1,102 @@\n+â”Š   â”Š  1â”Šconst _ = require(\"underscore\");\n+â”Š   â”Š  2â”Šconst Async = require(\"async\");\n+â”Š   â”Š  3â”Šconst Fs = require(\"fs\");\n+â”Š   â”Š  4â”Šconst Path = require(\"path\");\n+â”Š   â”Š  5â”Šconst { DOMParser } = require(\"xmldom\");\n+â”Š   â”Š  6â”Š\n+â”Š   â”Š  7â”Šif (module === require.main) {\n+â”Š   â”Š  8â”Š  let fonstDir = Path.resolve(__dirname, \"../resources/assets/fonts\");\n+â”Š   â”Š  9â”Š  xmlsToJsons(fonstDir, err => { if (err) throw err });\n+â”Š   â”Š 10â”Š}\n+â”Š   â”Š 11â”Š\n+â”Š   â”Š 12â”Š// Gets a dir path containing font xmls and converts them all to jsons\n+â”Š   â”Š 13â”Šfunction xmlsToJsons(path, callback = _.noop) {\n+â”Š   â”Š 14â”Š  Fs.readdir(path, (err, files) => {\n+â”Š   â”Š 15â”Š    if (err) return callback(err);\n+â”Š   â”Š 16â”Š\n+â”Š   â”Š 17â”Š    // Remove all extensions\n+â”Š   â”Š 18â”Š    fileNames = _.uniq(files.map(file => file.split(\".\")[0]));\n+â”Š   â”Š 19â”Š\n+â”Š   â”Š 20â”Š    // Convert each xml individually\n+â”Š   â”Š 21â”Š    Async.each(fileNames, (fileName, next) => {\n+â”Š   â”Š 22â”Š      xmlToJson(`${path}/${fileName}`, next);\n+â”Š   â”Š 23â”Š    },\n+â”Š   â”Š 24â”Š    (err) => {\n+â”Š   â”Š 25â”Š      if (!err) console.log(\n+â”Š   â”Š 26â”Š        'All fonts have been successfully parsed!'\n+â”Š   â”Š 27â”Š      );\n+â”Š   â”Š 28â”Š\n+â”Š   â”Š 29â”Š      callback(err);\n+â”Š   â”Š 30â”Š    });\n+â”Š   â”Š 31â”Š  });\n+â”Š   â”Š 32â”Š}\n+â”Š   â”Š 33â”Š\n+â”Š   â”Š 34â”Š// Gets a font xml and converts it to json\n+â”Š   â”Š 35â”Šfunction xmlToJson(path, callback = _.noop) {\n+â”Š   â”Š 36â”Š  Async.waterfall([\n+â”Š   â”Š 37â”Š    (next) => {\n+â”Š   â”Š 38â”Š      Fs.readFile(`${path}.xml`, function(err, xmlBuffer) {\n+â”Š   â”Š 39â”Š        if (err) return next(err);\n+â”Š   â”Š 40â”Š\n+â”Š   â”Š 41â”Š        let json = {\n+â”Š   â”Š 42â”Š          chars: {}\n+â”Š   â”Š 43â”Š        };\n+â”Š   â”Š 44â”Š\n+â”Š   â”Š 45â”Š        let xml = xmlBuffer.toString();\n+â”Š   â”Š 46â”Š        let doc = new DOMParser().parseFromString(xml);\n+â”Š   â”Š 47â”Š        let fontDoc = doc.getElementsByTagName(\"Font\")[0];\n+â”Š   â”Š 48â”Š        let charsDoc = fontDoc.getElementsByTagName(\"Char\");\n+â”Š   â”Š 49â”Š\n+â”Š   â”Š 50â”Š        // Compose meta-data about font like size and family\n+â”Š   â”Š 51â”Š        _.each(fontDoc.attributes, (attr) => {\n+â”Š   â”Š 52â”Š          json[attr.name] = parseInt(attr.value) || attr.value;\n+â”Š   â”Š 53â”Š        });\n+â”Š   â”Š 54â”Š\n+â”Š   â”Š 55â”Š        // Compose data about each character in font\n+â”Š   â”Š 56â”Š        _.each(charsDoc, (charDoc) => {\n+â”Š   â”Š 57â”Š          let charCode = charDoc.getAttribute(\"code\");\n+â”Š   â”Š 58â”Š\n+â”Š   â”Š 59â”Š          let char = json.chars[charCode] = {\n+â”Š   â”Š 60â”Š            rect: rect = {},\n+â”Š   â”Š 61â”Š            offset: offset = {},\n+â”Š   â”Š 62â”Š            width: parseInt(charDoc.getAttribute(\"width\"))\n+â”Š   â”Š 63â”Š          };\n+â”Š   â”Š 64â”Š\n+â”Š   â”Š 65â”Š          [\n+â”Š   â”Š 66â”Š            rect.x,\n+â”Š   â”Š 67â”Š            rect.y,\n+â”Š   â”Š 68â”Š            rect.width,\n+â”Š   â”Š 69â”Š            rect.height\n+â”Š   â”Š 70â”Š          ] = extractIntegers(charDoc.getAttribute(\"rect\"));\n+â”Š   â”Š 71â”Š\n+â”Š   â”Š 72â”Š          [offset.x, offset.y] = extractIntegers(charDoc.getAttribute(\"offset\"));\n+â”Š   â”Š 73â”Š        });\n+â”Š   â”Š 74â”Š\n+â”Š   â”Š 75â”Š        next(null, JSON.stringify(json, null, 2));\n+â”Š   â”Š 76â”Š      });\n+â”Š   â”Š 77â”Š    },\n+â”Š   â”Š 78â”Š    (json, next) => {\n+â”Š   â”Š 79â”Š      // Once finished, write json into file\n+â”Š   â”Š 80â”Š      Fs.writeFile(path + \".json\", json, (err) => {\n+â”Š   â”Š 81â”Š        next(err);\n+â”Š   â”Š 82â”Š      });\n+â”Š   â”Š 83â”Š    }\n+â”Š   â”Š 84â”Š  ], (err) => {\n+â”Š   â”Š 85â”Š    if (!err) console.log(\n+â”Š   â”Š 86â”Š      `Font ${path} has been successfully parsed...`\n+â”Š   â”Š 87â”Š    );\n+â”Š   â”Š 88â”Š\n+â”Š   â”Š 89â”Š    callback(err);\n+â”Š   â”Š 90â”Š  });\n+â”Š   â”Š 91â”Š};\n+â”Š   â”Š 92â”Š\n+â”Š   â”Š 93â”Š// Converts an string of numbers to array of numbers\n+â”Š   â”Š 94â”Š// e.g. extractIntegers(\"1 2 3\") -> [1, 2, 3]\n+â”Š   â”Š 95â”Šfunction extractIntegers(srcstr) {\n+â”Š   â”Š 96â”Š  return srcstr.split(\" \").map((substr) => parseInt(substr));\n+â”Š   â”Š 97â”Š}\n+â”Š   â”Š 98â”Š\n+â”Š   â”Š 99â”Šmodule.exports = {\n+â”Š   â”Š100â”Š  xmlToJson,\n+â”Š   â”Š101â”Š  xmlsToJsons\n+â”Š   â”Š102â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nThis script will take everything that's in the `fonts` dir and parser it as mentioned above. Before we can user this script we will need to install some NPM dependencies like so:\n\n    $ npm install --save underscore\n    $ npm install --save xmldom\n\nAnd instead of running the parser manually over and over again whenever we wanna use it, we will use the following `NPM` script instead:\n\n[{]: <helper> (diffStep 4.8)\n\n#### [Step 4.8: Add font parsing npm scripts](https://github.com/DAB0mB/radial-snake/commit/7a1cf81)\n\n##### Changed package.json\n```diff\n@@ -7,7 +7,8 @@\n â”Š 7â”Š 7â”Š  },\n â”Š 8â”Š 8â”Š  \"private\": true,\n â”Š 9â”Š 9â”Š  \"scripts\": {\n-â”Š10â”Š  â”Š    \"serve\": \"nodemon server.js\"\n+â”Š  â”Š10â”Š    \"serve\": \"npm run parse:fonts && nodemon server.js\",\n+â”Š  â”Š11â”Š    \"build:fonts\": \"node helpers/font_parser.js\"\n â”Š11â”Š12â”Š  },\n â”Š12â”Š13â”Š  \"dependencies\": {\n â”Š13â”Š14â”Š    \"async\": \"^2.1.4\",\n```\n\n[}]: #\n\nWe don't want the generated fonts to be included by `git` since they are going to automatically regenerate themselves, therefore we gonna add the following ignore rule:\n\n[{]: <helper> (diffStep 4.9)\n\n#### [Step 4.9: Add rule to to git-ignore parsed fonts](https://github.com/DAB0mB/radial-snake/commit/bbf7647)\n\n##### Changed .gitignore\n```diff\n@@ -1,2 +1,3 @@\n â”Š1â”Š1â”Šnode_modules\n-â”Š2â”Š â”Šnpm-debug.logðŸš«â†µ\n+â”Š â”Š2â”Šnpm-debug.log\n+â”Š â”Š3â”Šresources/assets/fonts/*.jsonðŸš«â†µ\n```\n\n[}]: #\n\nNow we will build our `minecraftia` font by simply running:\n\n    $ npm run build:fonts\n\nAnd voila! We have a freshly created `json` file which we can work with. You can also get it from here:\n\n    resources/assets/fonts$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/assets/fonts/minecraftia.json\n\nNow that we have our assets finally ready we can go ahead and focus on extending the engine which powers up our game. We need some sort of a generic font-engine which will know how to load a font file and create a text-sprite out of it. First we will implement a class called `Restorable`, which shares the same restore API as the CanvasRenderingContext2D and will give us the ability to save and restore the font's state (More information can be found [here](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/restore)):\n\n[{]: <helper> (diffStep 4.11)\n\n#### [Step 4.11: Add &#x27;Restorable&#x27; class](https://github.com/DAB0mB/radial-snake/commit/8239c01)\n\n##### Added resources&#x2F;scripts&#x2F;engine&#x2F;restorable.js\n```diff\n@@ -0,0 +1,21 @@\n+â”Š  â”Š 1â”ŠEngine.Restorable = class Restorable {\n+â”Š  â”Š 2â”Š  // Acts the same as canvas's save() and restore() API.\n+â”Š  â”Š 3â”Š  // 'restorable' props are defined in the constructor\n+â”Š  â”Š 4â”Š  constructor(...restorableProps) {\n+â”Š  â”Š 5â”Š    this._restorableProps = restorableProps;\n+â”Š  â”Š 6â”Š    this._restorableStates = [];\n+â”Š  â”Š 7â”Š  }\n+â”Š  â”Š 8â”Š\n+â”Š  â”Š 9â”Š  // Save current state in the stack\n+â”Š  â”Š10â”Š  save() {\n+â”Š  â”Š11â”Š    this._restorableStates.push(this._restorableProps.reduce((state, prop) => {\n+â”Š  â”Š12â”Š      state[prop] = this[prop];\n+â”Š  â”Š13â”Š      return state;\n+â”Š  â”Š14â”Š    }, {}));\n+â”Š  â”Š15â”Š  }\n+â”Š  â”Š16â”Š\n+â”Š  â”Š17â”Š  // Pop most recent state and apply it\n+â”Š  â”Š18â”Š  restore() {\n+â”Š  â”Š19â”Š    _.extend(this, this._restorableStates.pop());\n+â”Š  â”Š20â”Š  }\n+â”Š  â”Š21â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -9,6 +9,7 @@\n â”Š 9â”Š 9â”Š\n â”Š10â”Š10â”Š    <!-- Scripts -->\n â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n+â”Š  â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/restorable.js\"></script>\n â”Š12â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/sprite.js\"></script>\n â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/animations/keyframe.js\"></script>\n â”Š14â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/key_states.js\"></script>\n```\n\n[}]: #\n\nAnd now we can go ahead and implement the font class itself:\n\n[{]: <helper> (diffStep 4.12)\n\n#### [Step 4.12: Create font engine](https://github.com/DAB0mB/radial-snake/commit/7a1f2c7)\n\n##### Added resources&#x2F;scripts&#x2F;engine&#x2F;font.js\n```diff\n@@ -0,0 +1,133 @@\n+â”Š   â”Š  1â”ŠEngine.Font = class Font extends Engine.Restorable {\n+â”Š   â”Š  2â”Š  // The src property acts just line native image's src property.\n+â”Š   â”Š  3â”Š  // Once finished loading, the onload() callback will be invoked\n+â”Š   â”Š  4â”Š  get src() {\n+â”Š   â”Š  5â”Š    return this._src;\n+â”Š   â”Š  6â”Š  }\n+â”Š   â”Š  7â”Š\n+â”Š   â”Š  8â”Š  set src(src) {\n+â”Š   â”Š  9â”Š    this._src = src;\n+â”Š   â”Š 10â”Š\n+â”Š   â”Š 11â”Š    // The font is actually an image, therefore we have 2 onload callbacks.\n+â”Š   â”Š 12â”Š    // The first one is the native one which will always be run,\n+â”Š   â”Š 13â”Š    // and the second one is a user defined one\n+â”Š   â”Š 14â”Š    if (this.onload) var done = _.after(2, this.onload);\n+â”Š   â”Š 15â”Š\n+â”Š   â”Š 16â”Š    this.atlas = new Image();\n+â”Š   â”Š 17â”Š    this.atlas.onload = done;\n+â”Š   â”Š 18â”Š    this.atlas.src = `${src}.png`;\n+â”Š   â”Š 19â”Š\n+â”Š   â”Š 20â”Š    // Get json based on the given src property\n+â”Š   â”Š 21â”Š    $.getJSON(`${src}.json`, data => {\n+â”Š   â”Š 22â”Š      this.data = data;\n+â”Š   â”Š 23â”Š      if (done) done();\n+â”Š   â”Š 24â”Š    });\n+â”Š   â”Š 25â”Š\n+â”Š   â”Š 26â”Š    return this._src;\n+â”Š   â”Š 27â”Š  }\n+â”Š   â”Š 28â”Š\n+â”Š   â”Š 29â”Š  constructor() {\n+â”Š   â”Š 30â”Š    // The color property is the only restorable property\n+â”Š   â”Š 31â”Š    super(\"color\");\n+â”Š   â”Š 32â”Š    this.charSpritesCache = {};\n+â”Š   â”Š 33â”Š  }\n+â”Š   â”Š 34â”Š\n+â”Š   â”Š 35â”Š  // Creates a texture out of the font with the given text\n+â”Š   â”Š 36â”Š  createTexture(text, options = {}) {\n+â”Š   â”Š 37â”Š    let { noOffsets, noSpaces } = options;\n+â”Š   â”Š 38â”Š    let canvas = document.createElement(\"canvas\");\n+â”Š   â”Š 39â”Š    let context = canvas.getContext(\"2d\");\n+â”Š   â”Š 40â”Š    let height = canvas.height = this.data.height;\n+â”Š   â”Š 41â”Š\n+â”Š   â”Š 42â”Š    // Calculates the width of the canvas based on the text and the font\n+â”Š   â”Š 43â”Š    let width = canvas.width = _.reduce(text, (width, c) => {\n+â”Š   â”Š 44â”Š      // No-space option means that the characters will be\n+â”Š   â”Š 45â”Š      // drawn with no any space between them\n+â”Š   â”Š 46â”Š      if (noSpaces) {\n+â”Š   â”Š 47â”Š        return width + this.getCharSprite(c).width;\n+â”Š   â”Š 48â”Š      }\n+â”Š   â”Š 49â”Š\n+â”Š   â”Š 50â”Š      return width + this.data.chars[c].width;\n+â”Š   â”Š 51â”Š    }, 0);\n+â”Š   â”Š 52â”Š\n+â”Š   â”Š 53â”Š    // A custom size can be specified for a font as well\n+â”Š   â”Š 54â”Š    if (this.size) {\n+â”Š   â”Š 55â”Š      let ratio = this.size / this.data.size;\n+â”Š   â”Š 56â”Š      canvas.height *= ratio;\n+â”Š   â”Š 57â”Š      canvas.width *= ratio;\n+â”Š   â”Š 58â”Š      context.scale(ratio, ratio);\n+â”Š   â”Š 59â”Š    }\n+â”Š   â”Š 60â”Š\n+â”Š   â”Š 61â”Š    // No we are going to draw each char on the canvas individually,\n+â”Š   â”Š 62â”Š    // naturally, there should be an offset after we draw each character.\n+â”Š   â”Š 63â”Š    // This variable will be used to calculate the offset\n+â”Š   â”Š 64â”Š    let offset = 0;\n+â”Š   â”Š 65â”Š\n+â”Š   â”Š 66â”Š    // Get for each char\n+â”Š   â”Š 67â”Š    _.map(text, (char) => {\n+â”Š   â”Š 68â”Š      return this.getCharSprite(char);\n+â”Š   â”Š 69â”Š    })\n+â”Š   â”Š 70â”Š    // Start drawing each char on the canvas\n+â”Š   â”Š 71â”Š    .forEach((charSprite, index) => {\n+â”Š   â”Š 72â”Š      let charData = this.data.chars[text.charAt(index)];\n+â”Š   â”Š 73â”Š\n+â”Š   â”Š 74â”Š      // Each char in the font xml has a native offset in addition to its rectangle.\n+â”Š   â”Š 75â”Š      // This option will disable the calculation of the native offset\n+â”Š   â”Š 76â”Š      if (noOffsets) {\n+â”Š   â”Š 77â”Š        charSprite.draw(context, offset);\n+â”Š   â”Š 78â”Š      }\n+â”Š   â”Š 79â”Š      else {\n+â”Š   â”Š 80â”Š        charSprite.draw(context, offset + charData.offset.x, charData.offset.y);\n+â”Š   â”Š 81â”Š      }\n+â”Š   â”Š 82â”Š\n+â”Š   â”Š 83â”Š      if (noSpaces) {\n+â”Š   â”Š 84â”Š        offset += charSprite.width;\n+â”Š   â”Š 85â”Š      }\n+â”Š   â”Š 86â”Š      else {\n+â”Š   â”Š 87â”Š        offset += charData.width;\n+â”Š   â”Š 88â”Š      }\n+â”Š   â”Š 89â”Š\n+â”Š   â”Š 90â”Š      // A color for the font can be specified as well\n+â”Š   â”Š 91â”Š      if (this.color) {\n+â”Š   â”Š 92â”Š        let overlayCanvas = document.createElement(\"canvas\");\n+â”Š   â”Š 93â”Š        let overlayContext = overlayCanvas.getContext(\"2d\");\n+â”Š   â”Š 94â”Š        overlayCanvas.width = width;\n+â”Š   â”Š 95â”Š        overlayCanvas.height = height;\n+â”Š   â”Š 96â”Š        overlayContext.beginPath();\n+â”Š   â”Š 97â”Š        overlayContext.rect(0, 0, width, height);\n+â”Š   â”Š 98â”Š        overlayContext.fillStyle = this.color;\n+â”Š   â”Š 99â”Š        overlayContext.fill();\n+â”Š   â”Š100â”Š\n+â”Š   â”Š101â”Š        context.save();\n+â”Š   â”Š102â”Š        context.globalCompositeOperation = \"source-in\";\n+â”Š   â”Š103â”Š        context.drawImage(overlayCanvas, 0, 0);\n+â”Š   â”Š104â”Š        context.restore();\n+â”Š   â”Š105â”Š      }\n+â”Š   â”Š106â”Š    });\n+â”Š   â”Š107â”Š\n+â”Š   â”Š108â”Š    // The canvas will be treated like an image\n+â”Š   â”Š109â”Š    return canvas;\n+â”Š   â”Š110â”Š  }\n+â”Š   â”Š111â”Š\n+â”Š   â”Š112â”Š  // Gets a sprite of the given char, using the current font\n+â”Š   â”Š113â”Š  getCharSprite(char) {\n+â”Š   â”Š114â”Š    // If char is already stored in cache, abort calculation and return it\n+â”Š   â”Š115â”Š    if (this.charSpritesCache[char]) return this.charSpritesCache[char];\n+â”Š   â”Š116â”Š\n+â”Š   â”Š117â”Š    // This data is fetched by the given json\n+â”Š   â”Š118â”Š    let { x, y, width, height } = this.data.chars[char].rect;\n+â”Š   â”Š119â”Š    // Creating a canvas which we will use to draw on,\n+â”Š   â”Š120â”Š    // but it is used exactly like an image afterwards\n+â”Š   â”Š121â”Š    let canvas = document.createElement(\"canvas\");\n+â”Š   â”Š122â”Š    let context = canvas.getContext(\"2d\");\n+â”Š   â”Š123â”Š\n+â”Š   â”Š124â”Š    // The canvas will have the same dimensions as the font\n+â”Š   â”Š125â”Š    canvas.width = width;\n+â”Š   â”Š126â”Š    canvas.height = height;\n+â”Š   â”Š127â”Š    // Draw a cropped image from the atlas, this image contains the char font\n+â”Š   â”Š128â”Š    context.drawImage(this.atlas, x, y, width, height, 0, 0, width, height);\n+â”Š   â”Š129â”Š\n+â”Š   â”Š130â”Š    // Store in cache and return it\n+â”Š   â”Š131â”Š    return this.charSpritesCache[char] = new Engine.Sprite(canvas);\n+â”Š   â”Š132â”Š  }\n+â”Š   â”Š133â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -10,6 +10,7 @@\n â”Š10â”Š10â”Š    <!-- Scripts -->\n â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n â”Š12â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/restorable.js\"></script>\n+â”Š  â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/font.js\"></script>\n â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/sprite.js\"></script>\n â”Š14â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/animations/keyframe.js\"></script>\n â”Š15â”Š16â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/key_states.js\"></script>\n```\n\n[}]: #\n\nThe font API shares a similar API as [HTMLImageElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/Image), once we set the `src` property the font will start loading itself, and the `onload` user-defined callback should be called once finished. Another neat feature would be the `createTexture` method, which takes a string as its first argument, representing the text that we would like to generate, and returns an instance of the `Sprite` class.\n\nWe will also be adding the option to load some font assets in our asset-loader:\n\n[{]: <helper> (diffStep 4.13)\n\n#### [Step 4.13: Add a font loading option to &#x27;AssetLoader&#x27;](https://github.com/DAB0mB/radial-snake/commit/a9d73cc)\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;assets_loader.js\n```diff\n@@ -10,4 +10,12 @@\n â”Š10â”Š10â”Š    image.src = `${path}.png`;\n â”Š11â”Š11â”Š    return image;\n â”Š12â”Š12â”Š  }\n+â”Š  â”Š13â”Š\n+â”Š  â”Š14â”Š  // Load font\n+â”Š  â”Š15â”Š  font(path) {\n+â”Š  â”Š16â”Š    let font = new Engine.Font();\n+â”Š  â”Š17â”Š    font.onload = this.next();\n+â”Š  â”Š18â”Š    font.src = path;\n+â”Š  â”Š19â”Š    return font;\n+â”Š  â”Š20â”Š  }\n â”Š13â”Š21â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nAnd replace the instructions texture loading with a `minecraftia` font loading in the initial splash screen:\n\n[{]: <helper> (diffStep 4.14)\n\n#### [Step 4.14: Load &#x27;minecraftia&#x27; font in splash screen](https://github.com/DAB0mB/radial-snake/commit/231a68f)\n\n##### Changed resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;splash&#x2F;index.js\n```diff\n@@ -33,7 +33,7 @@\n â”Š33â”Š33â”Š\n â”Š34â”Š34â”Š  load(assetsLoader) {\n â”Š35â”Š35â”Š    // Load assets\n-â”Š36â”Š  â”Š    let instructionsTexture = assetsLoader.texture(\"/textures/instrucitons\");\n+â”Š  â”Š36â”Š    let minecraftiaFont = assetsLoader.font(\"/fonts/minecraftia\");\n â”Š37â”Š37â”Š    let logoTexture = assetsLoader.texture(\"/textures/logo\");\n â”Š38â”Š38â”Š    let splashTexture = assetsLoader.texture(\"/textures/splash\");\n â”Š39â”Š39â”Š\n```\n```diff\n@@ -41,7 +41,7 @@\n â”Š41â”Š41â”Š    // disposed. We use the time gap created by the splash animation to load necessary\n â”Š42â”Š42â”Š    // assets without wasting any time\n â”Š43â”Š43â”Š    this.game.extendAssets({\n-â”Š44â”Š  â”Š      instructionsTexture,\n+â”Š  â”Š44â”Š      minecraftiaFont,\n â”Š45â”Š45â”Š      logoTexture\n â”Š46â”Š46â”Š    });\n```\n\n[}]: #\n\nNow it can use us in the main menu screen where we will create a text-sprite saying `Press a key to start`, just like the instruction sprite we're about to replace:\n\n[{]: <helper> (diffStep 4.15)\n\n#### [Step 4.15: Replace texture usage with font usage in main menu screen](https://github.com/DAB0mB/radial-snake/commit/a769b81)\n\n##### Changed resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;menu&#x2F;index.js\n```diff\n@@ -5,7 +5,8 @@\n â”Š 5â”Š 5â”Š    this.logoSprite.setPercentage(\"width\", this.width, 30, \"height\");\n â”Š 6â”Š 6â”Š\n â”Š 7â”Š 7â”Š    // Initialize instructions sprite\n-â”Š 8â”Š  â”Š    let instructionsSprite = new Engine.Sprite(this.assets.instructionsTexture);\n+â”Š  â”Š 8â”Š    let instructionsTexture = this.assets.minecraftiaFont.createTexture(\"Press a key to start\");\n+â”Š  â”Š 9â”Š    let instructionsSprite = new Engine.Sprite(instructionsTexture);\n â”Š 9â”Š10â”Š    instructionsSprite.align = \"center\";\n â”Š10â”Š11â”Š    instructionsSprite.setPercentage(\"width\", this.width, 35, \"height\");\n â”Š11â”Š12â”Š    instructionsSprite.x = this.width / 2;\n```\n```diff\n@@ -30,7 +31,7 @@\n â”Š30â”Š31â”Š\n â”Š31â”Š32â”Š  unload() {\n â”Š32â”Š33â”Š    // Dispose the following assets to prevent memory leaks\n-â”Š33â”Š  â”Š    return [\"logoTexture\", \"instructionsTexture\"];\n+â”Š  â”Š34â”Š    return \"logoTexture\";\n â”Š34â”Š35â”Š  }\n â”Š35â”Š36â”Š\n â”Š36â”Š37â”Š  draw(context) {\n```\n```diff\n@@ -41,4 +42,8 @@\n â”Š41â”Š42â”Š  update(span) {\n â”Š42â”Š43â”Š    this.instructionsAnim.update(span);\n â”Š43â”Š44â”Š  }\n+â”Š  â”Š45â”Š\n+â”Š  â”Š46â”Š  update(span) {\n+â”Š  â”Š47â”Š    this.instructionsAnim.update(span);\n+â”Š  â”Š48â”Š  }\n â”Š44â”Š49â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nIt shouldn't look any different from the beginning of the step where we manually drew the instruction texture, but in the next steps we will be using the font-engine a lot, and you will be thankful for what we've just did."
          },
          {
            "manualTitle": "Step 5: Creating a snake and related geometry shapes",
            "stepRevision": "ad178e03e276b088c96d6f67889db379ad201e3e",
            "manualView": "![snake-illustrate](https://cloud.githubusercontent.com/assets/7648874/21074115/46ef4466-bed7-11e6-9d5d-12fa6d43147b.gif)\n\nIn this step we will be creating all the necessary geometry shapes to form a snake; we're basically implementing the right infrastructure so in the next step we will be able to implement the game screen with ease. What exactly do I mean by \"geometry shapes\"? Well, our snake will be made out of circles, and lines. If we don't press any buttons at all, the snake should move forward at a straight line, and once we press on one of the arrow keys, the snake should move in a circular motion. Not only we want to draw the screen on the canvas, we also want to be able to detect collision with other snakes, since this is a \"Tron\" style game where we gonna fight against an opponent.\n\nKeep in mind that a computer's precision is limited due its [binary representation in memory](https://en.wikipedia.org/wiki/Memory_cell_(binary)). We need to take into consideration that there might be a significant deviation when detecting collisions and intersections between geometry shapes, especially when elapsed time is not always guaranteed to stay precise. To handle these deviation issues, we're gonna create some utility functions and place then in a new module called `Utils`:\n\n[{]: <helper> (diffStep 5.1)\n\n#### [Step 5.1: Create utilities module](https://github.com/DAB0mB/radial-snake/commit/58ae99a)\n\n##### Added resources&#x2F;scripts&#x2F;utils.js\n```diff\n@@ -0,0 +1,68 @@\n+â”Š  â”Š 1â”Š// A wrapper function for our utilities which will enable chaining\n+â”Š  â”Š 2â”Š// e.g. Utils().mod().trim().isBetween()...\n+â”Š  â”Š 3â”ŠUtils = function Utils(context) {\n+â”Š  â”Š 4â”Š  const chain = {};\n+â”Š  â”Š 5â”Š\n+â”Š  â”Š 6â”Š  Object.keys(Utils).forEach((utilName) => {\n+â”Š  â”Š 7â”Š    chain[utilName] = (...args) => {\n+â”Š  â”Š 8â”Š      const result = Utils[utilName](context, ...args);\n+â”Š  â”Š 9â”Š      return Utils(result);\n+â”Š  â”Š10â”Š    };\n+â”Š  â”Š11â”Š  });\n+â”Š  â”Š12â”Š\n+â”Š  â”Š13â”Š  // Returns the result of the chaining\n+â”Š  â”Š14â”Š  chain.value = () => context;\n+â”Š  â”Š15â”Š\n+â”Š  â”Š16â”Š  return chain;\n+â”Š  â”Š17â”Š};\n+â”Š  â”Š18â”Š\n+â”Š  â”Š19â”Š// Fixed modulo method which can calculate modulo of negative numbers properly\n+â”Š  â”Š20â”Š// e.g. (-803).mod(800) returns 797\n+â”Š  â”Š21â”ŠUtils.mod = function (context, num) {\n+â”Š  â”Š22â”Š  return ((context % num) + num) % num;\n+â”Š  â”Š23â”Š};\n+â”Š  â”Š24â”Š\n+â”Š  â”Š25â”Š// Trims number and leaves the number of decimals specified.\n+â”Š  â”Š26â”Š// The \"mode\" argument specifies which math function should be invoked\n+â”Š  â”Š27â”Š// right after the number has been trimmed.\n+â”Š  â”Š28â”Š// e.g. 12.12345.trim(3, \"ceil\") returns 12.124\n+â”Š  â”Š29â”ŠUtils.trim = function (context, decimals, mode = \"round\") {\n+â”Š  â”Š30â”Š  return Math[mode](context * Math.pow(10, decimals)) / Math.pow(10, decimals);\n+â”Š  â”Š31â”Š};\n+â”Š  â”Š32â”Š\n+â”Š  â”Š33â”Š// Tells if number is in specified range based on given precision.\n+â”Š  â”Š34â”Š// See the \"compare\" method for more information about precision\n+â”Š  â”Š35â”ŠUtils.isBetween = function (context, num1, num2, precision) {\n+â”Š  â”Š36â”Š  return Utils.compare(context, Math.min(num1, num2), \">=\", precision) &&\n+â”Š  â”Š37â”Š         Utils.compare(context, Math.max(num1, num2), \"<=\", precision);\n+â”Š  â”Š38â”Š};\n+â”Š  â”Š39â”Š\n+â”Š  â”Š40â”Š// Initiates comparison operator between context number and a given number, only here\n+â”Š  â”Š41â”Š// a precision can be specified\n+â”Š  â”Š42â”ŠUtils.compare = function (context, num, method, precision = method) {\n+â”Š  â”Š43â”Š  switch (precision) {\n+â”Š  â”Š44â”Š    // Fixed precision, \"almost equal\" with a deviation of Îµ\n+â”Š  â”Š45â”Š    case \"f\":\n+â”Š  â”Š46â”Š      switch (method) {\n+â”Š  â”Š47â”Š        case \"<\": case \"<=\": return context <= num + Number.EPSILON;\n+â”Š  â”Š48â”Š        case \">\": case \">=\": return context >= num - Number.EPSILON;\n+â”Š  â”Š49â”Š        default: return Math.abs(context - num) <= Number.EPSILON;\n+â”Š  â”Š50â”Š      }\n+â”Š  â”Š51â”Š    // Pixel precision, round comparison\n+â”Š  â”Š52â”Š    case \"px\":\n+â”Š  â”Š53â”Š      switch (method) {\n+â”Š  â”Š54â”Š        case \"<\": case \"<=\": return Math.round(context) <= Math.round(num);\n+â”Š  â”Š55â”Š        case \">\": case \">=\": return Math.round(context) >= Math.round(num);\n+â”Š  â”Š56â”Š        default: return Math.round(context) == Math.round(num);\n+â”Š  â”Š57â”Š      }\n+â”Š  â”Š58â”Š    // Exact precision\n+â”Š  â”Š59â”Š    default:\n+â”Š  â”Š60â”Š      switch (method) {\n+â”Š  â”Š61â”Š        case \"<\": return context < num;\n+â”Š  â”Š62â”Š        case \"<=\": return context <= num;\n+â”Š  â”Š63â”Š        case \">\": return context > num;\n+â”Š  â”Š64â”Š        case \">=\": return context >= num;\n+â”Š  â”Š65â”Š        default: return context === num;\n+â”Š  â”Š66â”Š      }\n+â”Š  â”Š67â”Š  }\n+â”Š  â”Š68â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -8,6 +8,7 @@\n â”Š 8â”Š 8â”Š    <script type=\"text/javascript\" src=\"/libs/underscore.js\"></script>\n â”Š 9â”Š 9â”Š\n â”Š10â”Š10â”Š    <!-- Scripts -->\n+â”Š  â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/utils.js\"></script>\n â”Š11â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n â”Š12â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/restorable.js\"></script>\n â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/font.js\"></script>\n```\n\n[}]: #\n\nNow we would like to start implementing the first class representation for a line, and for that we're requires to add a new module called `Geometry` to the `Engine` namespace:\n\n[{]: <helper> (diffStep 5.2)\n\n#### [Step 5.2: Add &#x27;Shapes&#x27; module to &#x27;Engine&#x27; namespace](https://github.com/DAB0mB/radial-snake/commit/4ed2788)\n\n##### Changed resources&#x2F;scripts&#x2F;namespaces.js\n```diff\n@@ -3,5 +3,6 @@\n â”Š3â”Š3â”Š};\n â”Š4â”Š4â”Š\n â”Š5â”Š5â”ŠEngine = {\n-â”Š6â”Š â”Š  Animations: {}\n+â”Š â”Š6â”Š  Animations: {},\n+â”Š â”Š7â”Š  Geometry: {}\n â”Š7â”Š8â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nAnd now that we have this module available to use, we can go ahead and implement our first geometry shape class - `Line`:\n\n[{]: <helper> (diffStep 5.3)\n\n#### [Step 5.3: Create &#x27;Line&#x27; class](https://github.com/DAB0mB/radial-snake/commit/fb38ab5)\n\n##### Added resources&#x2F;scripts&#x2F;engine&#x2F;geometry&#x2F;line.js\n```diff\n@@ -0,0 +1,65 @@\n+â”Š  â”Š 1â”ŠEngine.Geometry.Line = class Line {\n+â”Š  â”Š 2â”Š  // x1 - The first point's x value\n+â”Š  â”Š 3â”Š  // y1 - The first point's y value\n+â”Š  â”Š 4â”Š  // x1 - The second point's x value\n+â”Š  â”Š 5â”Š  // y2 - The second point's y value\n+â”Š  â”Š 6â”Š  constructor(x1, y1, x2, y2) {\n+â”Š  â”Š 7â”Š    this.x1 = Utils.trim(x1, 9);\n+â”Š  â”Š 8â”Š    this.y1 = Utils.trim(y1, 9);\n+â”Š  â”Š 9â”Š    this.x2 = Utils.trim(x2, 9);\n+â”Š  â”Š10â”Š    this.y2 = Utils.trim(y2, 9);\n+â”Š  â”Š11â”Š  }\n+â”Š  â”Š12â”Š\n+â”Š  â”Š13â”Š  // Draws the line on the given context\n+â”Š  â”Š14â”Š  draw(context) {\n+â”Š  â”Š15â”Š    context.moveTo(this.x1, this.y1);\n+â”Š  â”Š16â”Š    context.lineTo(this.x2, this.y2);\n+â”Š  â”Š17â”Š  }\n+â”Š  â”Š18â”Š\n+â”Š  â”Š19â”Š  // Gets the matching x value for a given y value\n+â”Š  â”Š20â”Š  getX(y) {\n+â”Š  â”Š21â”Š    let x = Utils.trim((((y - this.y1) * (this.x2 - this.x1)) / (this.y2 - this.y1)) + this.x1, 9);\n+â”Š  â”Š22â”Š    if (isNaN(x) || Utils.isBetween(x, this.x1, this.x2)) return x;\n+â”Š  â”Š23â”Š  }\n+â”Š  â”Š24â”Š\n+â”Š  â”Š25â”Š  // Gets the matching y value for a given x value\n+â”Š  â”Š26â”Š  getY(x) {\n+â”Š  â”Š27â”Š    let y = Utils.trim((((x - this.x1) * (this.y2 - this.y1)) / (this.x2 - this.x1)) + this.y1, 9);\n+â”Š  â”Š28â”Š    if (isNaN(y) || Utils.isBetween(y, this.y1, this.y2)) return y;\n+â”Š  â”Š29â”Š  }\n+â”Š  â”Š30â”Š\n+â”Š  â”Š31â”Š  // Returns if line has given point\n+â”Š  â”Š32â”Š  hasPoint(x, y) {\n+â”Š  â”Š33â”Š    if (!this.boundsHavePoint(x, y)) return false;\n+â”Š  â”Š34â”Š    let m = Utils.trim((this.y2 - this.y1) / (this.x2 - this.x1), 9);\n+â”Š  â”Š35â”Š    return (y - this.y1) / (x - this.x1) == m;\n+â”Š  â”Š36â”Š  }\n+â”Š  â”Š37â”Š\n+â”Š  â”Š38â”Š  // Returns if given point is contained by the bounds aka cage of line\n+â”Š  â”Š39â”Š  boundsHavePoint(x, y) {\n+â”Š  â”Š40â”Š    return Utils.isBetween(x, this.x1, this.x2) &&\n+â”Š  â”Š41â”Š           Utils.isBetween(y, this.y1, this.y2);\n+â”Š  â”Š42â”Š  }\n+â”Š  â”Š43â”Š\n+â”Š  â”Š44â”Š  getIntersection(shape) {\n+â”Š  â”Š45â”Š    if (shape instanceof Engine.Geometry.Line)\n+â”Š  â”Š46â”Š      return this.getLineIntersection(shape);\n+â”Š  â”Š47â”Š  }\n+â”Š  â”Š48â”Š\n+â”Š  â”Š49â”Š  // line - line intersection method\n+â”Š  â”Š50â”Š  getLineIntersection(line) {\n+â”Š  â”Š51â”Š    // Escape if lines are parallel\n+â”Š  â”Š52â”Š    if (!(((this.x1 - this.x2) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * (line.x1 - line.x2)))) return;\n+â”Š  â”Š53â”Š\n+â”Š  â”Š54â”Š    // Intersection point formula\n+â”Š  â”Š55â”Š    let x = Utils.trim(((((this.x1 * this.y2) - (this.y1 * this.x2)) * (line.x1 - line.x2)) - ((this.x1 - this.x2) * ((line.x1 * line.y2) - (line.y1 * line.x2)))) /\n+â”Š  â”Š56â”Š        (((this.x1 - this.x2) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * (line.x1 - line.x2))), 9);\n+â”Š  â”Š57â”Š    let y = Utils.trim(((((this.x1 * this.y2) - (this.y1 * this.x2)) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * ((line.x1 * line.y2) - (line.y1 * line.x2)))) /\n+â”Š  â”Š58â”Š        (((this.x1 - this.x2) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * (line.x1 - line.x2))), 9);\n+â”Š  â”Š59â”Š\n+â”Š  â”Š60â”Š    if (Utils.isBetween(x, this.x1, this.x2) && Utils.isBetween(x, line.x1, line.x2) &&\n+â”Š  â”Š61â”Š        Utils.isBetween(y, this.y1, this.y2) && Utils.isBetween(y, line.y1, line.y2)) {\n+â”Š  â”Š62â”Š      return { x, y };\n+â”Š  â”Š63â”Š    }\n+â”Š  â”Š64â”Š  }\n+â”Š  â”Š65â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -10,6 +10,7 @@\n â”Š10â”Š10â”Š    <!-- Scripts -->\n â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/utils.js\"></script>\n â”Š12â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n+â”Š  â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/geometry/line.js\"></script>\n â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/restorable.js\"></script>\n â”Š14â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/font.js\"></script>\n â”Š15â”Š16â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/sprite.js\"></script>\n```\n\n[}]: #\n\nYou can go through the comments of the step above which will guide you through the programmatic aspect of it, but I think it's more important to understand the concept of a line in 2D space. A line is made out of two points, usually represented as `(x1, y1)` and `(x2, y2)`. The slope of the line, usually represented as `m`, can be determined using these two points based on the following formula:\n\n![slope](https://cloud.githubusercontent.com/assets/7648874/21788249/b4c7e41c-d6b4-11e6-9c17-baff66ec6bc8.png)\n\nOnce we have two lines whose `m` is different (Unparalleled) and there is no intersection between the points of which they are represented with (In which case they are united), there must be an intersection point. The intersection point can be found using the following formula:\n\n![line-line](https://cloud.githubusercontent.com/assets/7648874/21787164/c9d83bf0-d6ae-11e6-9846-4fc013eebab3.png)\n\n![line-line-illustration](https://cloud.githubusercontent.com/assets/7648874/21790864/56725cf0-d6c6-11e6-916b-50b1fc0b87af.png)\n\n> See reference: http://mathworld.wolfram.com/Line-LineIntersection.html.\n\nObviously we have some logic here which needs to be tested. To test our `Line` class, we will be using a testing framework called [Jasmine](https://jasmine.github.io/). We first need to download `Jasmine`'s essentials in order for it to work:\n\n    resources/libs$ mkdir jasmine\n    resources/libs$ cd jasmine\n    resources/libs/jasmine$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/libs/jasmine/boot.js\n    resources/libs/jasmine$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/libs/jasmine/console.js\n    resources/libs/jasmine$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/libs/jasmine/jasmine-html.js\n    resources/libs/jasmine$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/libs/jasmine/jasmine.css\n    resources/libs/jasmine$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/libs/jasmine/jasmine.js\n    resources/libs/jasmine$ wget https://raw.githubusercontent.com/DAB0mB/radial-snake/master/resources/libs/jasmine/jasmine_favicon.png\n\nThese essentials should be loaded in a newly created view where we're gonna see our specs running:\n\n[{]: <helper> (diffStep 5.5)\n\n#### [Step 5.5: Create specs runner view](https://github.com/DAB0mB/radial-snake/commit/150be1a)\n\n##### Added views&#x2F;spec_runner.html\n```diff\n@@ -0,0 +1,27 @@\n+â”Š  â”Š 1â”Š\n+â”Š  â”Š 2â”Š<!DOCTYPE html>\n+â”Š  â”Š 3â”Š<html>\n+â”Š  â”Š 4â”Š  <head>\n+â”Š  â”Š 5â”Š    <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n+â”Š  â”Š 6â”Š    <title>Jasmine Spec Runner v2.0.1</title>\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Š    <!-- Jasmine -->\n+â”Š  â”Š 9â”Š    <script type=\"text/javascript\" src=\"libs/jasmine/jasmine.js\"></script>\n+â”Š  â”Š10â”Š    <script type=\"text/javascript\" src=\"libs/jasmine/jasmine-html.js\"></script>\n+â”Š  â”Š11â”Š    <script type=\"text/javascript\" src=\"libs/jasmine/boot.js\"></script>\n+â”Š  â”Š12â”Š    <link rel=\"shortcut icon\" type=\"image/png\" href=\"libs/jasmine/jasmine_favicon.png\">\n+â”Š  â”Š13â”Š    <link rel=\"stylesheet\" type=\"text/css\" href=\"libs/jasmine/jasmine.css\">\n+â”Š  â”Š14â”Š\n+â”Š  â”Š15â”Š    <!-- Libs -->\n+â”Š  â”Š16â”Š    <script type=\"text/javascript\" src=\"libs/underscore.js\"></script>\n+â”Š  â”Š17â”Š\n+â”Š  â”Š18â”Š    <!-- Scripts -->\n+â”Š  â”Š19â”Š    <script type=\"text/javascript\" src=\"scripts/utils.js\"></script>\n+â”Š  â”Š20â”Š    <script type=\"text/javascript\" src=\"scripts/namespaces.js\"></script>\n+â”Š  â”Š21â”Š\n+â”Š  â”Š22â”Š    <!-- Specs -->\n+â”Š  â”Š23â”Š  </head>\n+â”Š  â”Š24â”Š\n+â”Š  â”Š25â”Š  <body>\n+â”Š  â”Š26â”Š  </body>\n+â”Š  â”Š27â”Š</html>ðŸš«â†µ\n```\n\n[}]: #\n\nNow once we'll navigate to the `/test` sub-route (`localhost:8000/test` by default) we should be provided with the spec runner. As for now there are no specs implemented at all, which brings us to the next stage - Implementing tests for `Line` class:\n\n[{]: <helper> (diffStep 5.6)\n\n#### [Step 5.6: Create &#x27;Line&#x27; class tests](https://github.com/DAB0mB/radial-snake/commit/c052752)\n\n##### Added resources&#x2F;scripts&#x2F;specs&#x2F;engine&#x2F;geometry&#x2F;line.js\n```diff\n@@ -0,0 +1,78 @@\n+â”Š  â”Š 1â”Šdescribe(\"Engine.Geometry.Line class\", function() {\n+â”Š  â”Š 2â”Š  beforeEach(function() {\n+â”Š  â”Š 3â”Š    this.line = new Engine.Geometry.Line(-5, -5, 5, 5);\n+â”Š  â”Š 4â”Š  });\n+â”Š  â”Š 5â”Š\n+â”Š  â”Š 6â”Š  describe(\"getX method\", function() {\n+â”Š  â”Š 7â”Š    describe(\"given inranged y\", function() {\n+â”Š  â”Š 8â”Š      it(\"returns x\", function() {\n+â”Š  â”Š 9â”Š        expect(this.line.getX(1)).toBeCloseTo(1);\n+â”Š  â”Š10â”Š      });\n+â”Š  â”Š11â”Š    });\n+â”Š  â”Š12â”Š\n+â”Š  â”Š13â”Š    describe(\"given outranged y\", function() {\n+â”Š  â”Š14â”Š      it(\"returns nothing\", function() {\n+â”Š  â”Š15â”Š        expect(this.line.getX(10)).toBeUndefined();\n+â”Š  â”Š16â”Š      });\n+â”Š  â”Š17â”Š    });\n+â”Š  â”Š18â”Š  });\n+â”Š  â”Š19â”Š\n+â”Š  â”Š20â”Š  describe(\"getY method\", function() {\n+â”Š  â”Š21â”Š    describe(\"given inranged x\", function() {\n+â”Š  â”Š22â”Š      it(\"returns y\", function() {\n+â”Š  â”Š23â”Š        expect(this.line.getY(1)).toBeCloseTo(1);\n+â”Š  â”Š24â”Š      });\n+â”Š  â”Š25â”Š    });\n+â”Š  â”Š26â”Š\n+â”Š  â”Š27â”Š    describe(\"given outranged x\", function() {\n+â”Š  â”Š28â”Š      it(\"returns nothing\", function() {\n+â”Š  â”Š29â”Š        expect(this.line.getY(10)).toBeUndefined();\n+â”Š  â”Š30â”Š      });\n+â”Š  â”Š31â”Š    });\n+â”Š  â”Š32â”Š  });\n+â”Š  â”Š33â”Š\n+â”Š  â”Š34â”Š  describe(\"hasPoint method\", function() {\n+â”Š  â”Š35â”Š    describe(\"given contained point\", function() {\n+â”Š  â”Š36â”Š      it(\"returns true\", function() {\n+â”Š  â”Š37â”Š        let x = 1;\n+â”Š  â”Š38â”Š        let y = 1;\n+â”Š  â”Š39â”Š        expect(this.line.hasPoint(x, y)).toBeTruthy();\n+â”Š  â”Š40â”Š      });\n+â”Š  â”Š41â”Š    });\n+â”Š  â”Š42â”Š\n+â”Š  â”Š43â”Š    describe(\"given uncontained point\", function() {\n+â”Š  â”Š44â”Š      it(\"returns false\", function() {\n+â”Š  â”Š45â”Š        let x = 10;\n+â”Š  â”Š46â”Š        let y = 10;\n+â”Š  â”Š47â”Š        expect(this.line.hasPoint(x, y)).toBeFalsy();\n+â”Š  â”Š48â”Š      });\n+â”Š  â”Š49â”Š    });\n+â”Š  â”Š50â”Š  });\n+â”Š  â”Š51â”Š\n+â”Š  â”Š52â”Š  describe(\"getLineIntersection method\", function() {\n+â”Š  â”Š53â”Š    describe(\"given intersecting line\", function() {\n+â”Š  â”Š54â”Š      it(\"returns intersection point\", function() {\n+â”Š  â”Š55â”Š        let line = new Engine.Geometry.Line(1, -5, 1, 5);\n+â”Š  â”Š56â”Š\n+â”Š  â”Š57â”Š        expect(this.line.getLineIntersection(line)).toEqual({\n+â”Š  â”Š58â”Š          x: 1,\n+â”Š  â”Š59â”Š          y: 1\n+â”Š  â”Š60â”Š        });\n+â”Š  â”Š61â”Š      });\n+â”Š  â”Š62â”Š    });\n+â”Š  â”Š63â”Š\n+â”Š  â”Š64â”Š    describe(\"given parallel line\", function() {\n+â”Š  â”Š65â”Š      it(\"returns nothing\", function() {\n+â”Š  â”Š66â”Š        let line = new Engine.Geometry.Line(-5, -6, 5, 4);\n+â”Š  â”Š67â”Š        expect(this.line.getLineIntersection(line)).toBeUndefined();\n+â”Š  â”Š68â”Š      });\n+â”Š  â”Š69â”Š    });\n+â”Š  â”Š70â”Š\n+â”Š  â”Š71â”Š    describe(\"given outranged line\", function() {\n+â”Š  â”Š72â”Š      it(\"returns nothing\", function() {\n+â”Š  â”Š73â”Š        let line = new Engine.Geometry.Line(10, 10, 10, 15);\n+â”Š  â”Š74â”Š        expect(this.line.getLineIntersection(line)).toBeUndefined();\n+â”Š  â”Š75â”Š      });\n+â”Š  â”Š76â”Š    });\n+â”Š  â”Š77â”Š  });\n+â”Š  â”Š78â”Š});ðŸš«â†µ\n```\n\n##### Changed views&#x2F;spec_runner.html\n```diff\n@@ -18,8 +18,10 @@\n â”Š18â”Š18â”Š    <!-- Scripts -->\n â”Š19â”Š19â”Š    <script type=\"text/javascript\" src=\"scripts/utils.js\"></script>\n â”Š20â”Š20â”Š    <script type=\"text/javascript\" src=\"scripts/namespaces.js\"></script>\n+â”Š  â”Š21â”Š    <script type=\"text/javascript\" src=\"scripts/engine/geometry/line.js\"></script>\n â”Š21â”Š22â”Š\n â”Š22â”Š23â”Š    <!-- Specs -->\n+â”Š  â”Š24â”Š    <script type=\"text/javascript\" src=\"scripts/specs/engine/geometry/line.js\"></script>\n â”Š23â”Š25â”Š  </head>\n â”Š24â”Š26â”Š\n â”Š25â”Š27â”Š  <body>\n```\n\n[}]: #\n\nNow if you'll refresh the spec runner page you should be able to a green screen indicating all tests have passed (Assuming the tutorial is updated and you followed it correctly). As introduced at the beginning of the step, the snake is also dependent on circles, whose representing class should look like so:\n\n[{]: <helper> (diffStep 5.7)\n\n#### [Step 5.7: Create &#x27;Circle&#x27; class](https://github.com/DAB0mB/radial-snake/commit/f9c5723)\n\n##### Added resources&#x2F;scripts&#x2F;engine&#x2F;geometry&#x2F;circle.js\n```diff\n@@ -0,0 +1,167 @@\n+â”Š   â”Š  1â”ŠEngine.Geometry.Circle = class Circle {\n+â”Š   â”Š  2â”Š  // x - The x value of the circle's center\n+â”Š   â”Š  3â”Š  // y - The y value of the circle's center\n+â”Š   â”Š  4â”Š  // r - The radius of the center\n+â”Š   â”Š  5â”Š  // rad1 - The first radian of the circle, not necessarily its beginning\n+â”Š   â”Š  6â”Š  // rad2 - The second radian of the circle, not necessarily its beginning\n+â”Š   â”Š  7â”Š  constructor(x, y, r, rad1, rad2) {\n+â”Š   â”Š  8â”Š    this.x = Utils.trim(x, 9);\n+â”Š   â”Š  9â”Š    this.y = Utils.trim(y, 9);\n+â”Š   â”Š 10â”Š    this.r = Utils.trim(r, 9);\n+â”Š   â”Š 11â”Š\n+â”Š   â”Š 12â”Š    // Trimming mode is done based on which radian represents the ending and which radian\n+â”Š   â”Š 13â”Š    // represents the ending\n+â”Š   â”Š 14â”Š    if (rad1 > rad2) {\n+â”Š   â”Š 15â”Š      this.rad1 = Utils.trim(rad1, 9, \"floor\");\n+â”Š   â”Š 16â”Š      this.rad2 = Utils.trim(rad2, 9, \"ceil\");\n+â”Š   â”Š 17â”Š    }\n+â”Š   â”Š 18â”Š    else {\n+â”Š   â”Š 19â”Š      this.rad1 = Utils.trim(rad1, 9, \"ceil\");\n+â”Š   â”Š 20â”Š      this.rad2 = Utils.trim(rad2, 9, \"floor\");\n+â”Š   â”Š 21â”Š    }\n+â”Š   â”Š 22â”Š  }\n+â”Š   â”Š 23â”Š\n+â”Š   â”Š 24â”Š  // Draws the circle on the given context\n+â”Š   â”Š 25â”Š  draw(context) {\n+â”Š   â”Š 26â”Š    context.arc(this.x, this.y, this.r, this.rad1, this.rad2);\n+â”Š   â”Š 27â”Š  }\n+â”Š   â”Š 28â”Š\n+â”Š   â”Š 29â”Š  // Gets the matching x value for the given radian\n+â”Š   â”Š 30â”Š  getX(rad) {\n+â”Š   â”Š 31â”Š    if (!Utils(rad).trim(9).isBetween(this.rad1, this.rad2).value()) return;\n+â”Š   â”Š 32â”Š    return Utils.trim((this.r * Math.cos(rad)) + this.x, 9);\n+â”Š   â”Š 33â”Š  }\n+â”Š   â”Š 34â”Š\n+â”Š   â”Š 35â”Š  // Gets the matching y value for the given radian\n+â”Š   â”Š 36â”Š  getY(rad) {\n+â”Š   â”Š 37â”Š    if (!Utils(rad).trim(9).isBetween(this.rad1, this.rad2).value()) return;\n+â”Š   â”Š 38â”Š    return Utils.trim((this.r * Math.sin(rad)) + this.y, 9);\n+â”Š   â”Š 39â”Š  }\n+â”Š   â”Š 40â”Š\n+â”Š   â”Š 41â”Š  // Gets the matching point for the given radian\n+â”Š   â”Š 42â”Š  getPoint(rad) {\n+â”Š   â”Š 43â”Š    if (!Utils.isBetween(rad, this.rad1, this.rad2)) return;\n+â”Š   â”Š 44â”Š\n+â”Š   â”Š 45â”Š    return {\n+â”Š   â”Š 46â”Š      x: Utils.trim((this.r * Math.cos(rad)) + this.x, 9),\n+â”Š   â”Š 47â”Š      y: Utils.trim((this.r * Math.sin(rad)) + this.y, 9)\n+â”Š   â”Š 48â”Š    };\n+â”Š   â”Š 49â”Š  }\n+â”Š   â”Š 50â”Š\n+â”Š   â”Š 51â”Š  // Gets the matching radian for the given point\n+â”Š   â”Š 52â”Š  getRad(x, y) {\n+â”Š   â”Š 53â”Š    let rad = Math.atan2(y - this.y, x - this.x);\n+â”Š   â”Š 54â”Š\n+â”Š   â”Š 55â”Š    // If calculated radian is in circle's radian range, return it\n+â”Š   â”Š 56â”Š    if (rad != null && Utils.isBetween(rad, this.rad1, this.rad2)) {\n+â”Š   â”Š 57â”Š      return rad;\n+â”Š   â”Š 58â”Š    }\n+â”Š   â”Š 59â”Š\n+â”Š   â”Š 60â”Š    // The calculated radian can still be in the circle's radian range in case one\n+â”Š   â”Š 61â”Š    // of the radians is greater than 2 PIEs\n+â”Š   â”Š 62â”Š    if (Math.abs(this.rad1) > Math.abs(this.rad2)) {\n+â”Š   â”Š 63â”Š      var greatestRad = this.rad1;\n+â”Š   â”Š 64â”Š    }\n+â”Š   â”Š 65â”Š    else {\n+â”Š   â”Š 66â”Š      var greatestRad = this.rad2;\n+â”Š   â”Š 67â”Š    }\n+â”Š   â”Š 68â”Š\n+â”Š   â”Š 69â”Š    // Check if the absolute radian is in the circle's radian range\n+â”Š   â”Š 70â”Š    if (Utils(rad + (2 * Math.PI * Math.floor(greatestRad / (2 * Math.PI)))).trim(9).isBetween(this.rad1, this.rad2).value() ||\n+â”Š   â”Š 71â”Š        Utils(rad + (2 * Math.PI * Math.ceil(greatestRad / (2 * Math.PI)))).trim(9).isBetween(this.rad1, this.rad2).value()) {\n+â”Š   â”Š 72â”Š      return rad;\n+â”Š   â”Š 73â”Š    }\n+â”Š   â”Š 74â”Š  }\n+â”Š   â”Š 75â”Š\n+â”Š   â”Š 76â”Š  // Returns if circle has given points\n+â”Š   â”Š 77â”Š  hasPoint(x, y) {\n+â”Š   â”Š 78â”Š    return this.getRad(x, y) != null;\n+â”Š   â”Š 79â”Š  }\n+â”Š   â”Š 80â”Š\n+â”Š   â”Š 81â”Š  getIntersection(shape) {\n+â”Š   â”Š 82â”Š    if (shape instanceof Engine.Geometry.Line)\n+â”Š   â”Š 83â”Š      return this.getLineIntersection(shape);\n+â”Š   â”Š 84â”Š    if (shape instanceof Engine.Geometry.Circle)\n+â”Š   â”Š 85â”Š      return this.getCircleIntersection(shape);\n+â”Š   â”Š 86â”Š  }\n+â”Š   â”Š 87â”Š\n+â”Š   â”Š 88â”Š  // circle - circle intersection method\n+â”Š   â”Š 89â”Š  getCircleIntersection(circle) {\n+â”Š   â”Š 90â”Š    let dx = circle.x - this.x;\n+â”Š   â”Š 91â”Š    let dy = circle.y - this.y;\n+â”Š   â”Š 92â”Š    let d = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\n+â”Š   â”Š 93â”Š\n+â”Š   â”Š 94â”Š    if (d > this.r + circle.r ||\n+â”Š   â”Š 95â”Š       d < Math.abs(this.r - circle.r)) {\n+â”Š   â”Š 96â”Š      return;\n+â”Š   â”Š 97â”Š    }\n+â”Š   â”Š 98â”Š\n+â”Š   â”Š 99â”Š    let a = ((Math.pow(this.r, 2) - Math.pow(circle.r, 2)) + Math.pow(d, 2)) / (2 * d);\n+â”Š   â”Š100â”Š    let x = this.x + ((dx * a) / d);\n+â”Š   â”Š101â”Š    let y = this.y + ((dy * a) / d);\n+â”Š   â”Š102â”Š    let h = Math.sqrt(Math.pow(this.r, 2) - Math.pow(a, 2));\n+â”Š   â”Š103â”Š    let rx = (- dy * h) / d;\n+â”Š   â”Š104â”Š    let ry = (dx * h) / d;\n+â”Š   â”Š105â”Š\n+â”Š   â”Š106â”Š    let interPoints = [\n+â”Š   â”Š107â”Š      {\n+â”Š   â”Š108â”Š        x: x + rx,\n+â”Š   â”Š109â”Š        y: y + ry\n+â”Š   â”Š110â”Š      },\n+â”Š   â”Š111â”Š      {\n+â”Š   â”Š112â”Š        x: x - rx,\n+â”Š   â”Š113â”Š        y: y - ry\n+â”Š   â”Š114â”Š      }\n+â”Š   â”Š115â”Š    ]\n+â”Š   â”Š116â”Š    .map(point => ({\n+â”Š   â”Š117â”Š        x: Utils.trim(point.x, 9),\n+â”Š   â”Š118â”Š        y: Utils.trim(point.y, 9)\n+â”Š   â”Š119â”Š     }));\n+â”Š   â”Š120â”Š\n+â”Š   â”Š121â”Š    interPoints = _.uniq(interPoints, point => `(${point.x}, ${point.y})`);\n+â”Š   â”Š122â”Š\n+â”Š   â”Š123â”Š    [this, circle].forEach(function(circle) {\n+â”Š   â”Š124â”Š      interPoints = interPoints.filter(point => circle.hasPoint(point.x, point.y));\n+â”Š   â”Š125â”Š    });\n+â”Š   â”Š126â”Š\n+â”Š   â”Š127â”Š    if (interPoints.length > 0) return interPoints;\n+â”Š   â”Š128â”Š  }\n+â”Š   â”Š129â”Š\n+â”Š   â”Š130â”Š  // circle - line intersection method\n+â”Š   â”Š131â”Š  getLineIntersection(line) {\n+â”Š   â”Š132â”Š    let x1 = line.x1 - this.x;\n+â”Š   â”Š133â”Š    let x2 = line.x2 - this.x;\n+â”Š   â”Š134â”Š    let y1 = line.y1 - this.y;\n+â”Š   â”Š135â”Š    let y2 = line.y2 - this.y;\n+â”Š   â”Š136â”Š    let dx = x2 - x1;\n+â”Š   â”Š137â”Š    let dy = y2 - y1;\n+â”Š   â”Š138â”Š    let d = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\n+â”Š   â”Š139â”Š    let h = (x1 * y2) - (x2 * y1);\n+â”Š   â”Š140â”Š    let delta = (Math.pow(this.r, 2) * Math.pow(d, 2)) - Math.pow(h, 2);\n+â”Š   â”Š141â”Š\n+â”Š   â”Š142â”Š    if (delta < 0) return;\n+â”Š   â”Š143â”Š\n+â”Š   â”Š144â”Š    let interPoints = [\n+â”Š   â”Š145â”Š      {\n+â”Š   â”Š146â”Š        x: (((h * dy) + (((dy / Math.abs(dy)) || 1) * dx * Math.sqrt(delta))) / Math.pow(d, 2)) + this.x,\n+â”Š   â”Š147â”Š        y: (((-h * dx) + (Math.abs(dy) * Math.sqrt(delta))) / Math.pow(d, 2)) + this.y\n+â”Š   â”Š148â”Š      },\n+â”Š   â”Š149â”Š      {\n+â”Š   â”Š150â”Š        x: (((h * dy) - (((dy / Math.abs(dy)) || 1) * dx * Math.sqrt(delta))) / Math.pow(d, 2)) + this.x,\n+â”Š   â”Š151â”Š        y: (((-h * dx) - (Math.abs(dy) * Math.sqrt(delta))) / Math.pow(d, 2)) + this.y\n+â”Š   â”Š152â”Š      }\n+â”Š   â”Š153â”Š    ]\n+â”Š   â”Š154â”Š    .map(point => ({\n+â”Š   â”Š155â”Š        x: Utils.trim(point.x, 9),\n+â”Š   â”Š156â”Š        y: Utils.trim(point.y, 9)\n+â”Š   â”Š157â”Š    }))\n+â”Š   â”Š158â”Š    .filter(point => {\n+â”Š   â”Š159â”Š      return this.hasPoint(point.x, point.y) &&\n+â”Š   â”Š160â”Š        line.boundsHavePoint(point.x, point.y);\n+â”Š   â”Š161â”Š    });\n+â”Š   â”Š162â”Š\n+â”Š   â”Š163â”Š    interPoints = _.uniq(interPoints, point => `(${point.x}, ${point.y})`);\n+â”Š   â”Š164â”Š\n+â”Š   â”Š165â”Š    if (interPoints.length > 0) return interPoints;\n+â”Š   â”Š166â”Š  }\n+â”Š   â”Š167â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -11,6 +11,7 @@\n â”Š11â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/utils.js\"></script>\n â”Š12â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n â”Š13â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/geometry/line.js\"></script>\n+â”Š  â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/geometry/circle.js\"></script>\n â”Š14â”Š15â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/restorable.js\"></script>\n â”Š15â”Š16â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/font.js\"></script>\n â”Š16â”Š17â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/sprite.js\"></script>\n```\n\n[}]: #\n\nJust like a line, a circle can be presented using variables as well. The center of the circle is represented as `(x, y)` and its radius is represented as `r`. Remember that our circle doesn't necessarily have to be a full one, therefore we limit its range using two radians - `rad1` and `rad2`. The formula for representing a circle in a 2D space looks like this:\n\n![circle-formula](https://cloud.githubusercontent.com/assets/7648874/21829783/84a54574-d77f-11e6-9b87-3fb0f073bb8d.png)\n\n![circle-circle-illustration](https://cloud.githubusercontent.com/assets/7648874/21790842/3a73408c-d6c6-11e6-8bdd-9c73355e6ebb.png)\n\n> `a` and `b` represent the offsets from the `x` and the `y` axes respectively.\n> See reference: http://mathworld.wolfram.com/Circle-CircleIntersection.html.\n\nTo find intersection between two circles, we simply calculate the solution for two equations with two variables. Given that a line can be represented in a 2D space using the following formula:\n\n![line-formula](https://cloud.githubusercontent.com/assets/7648874/21790671/1609c050-d6c5-11e6-8bd7-16cc306f5eea.png)\n\n![circle-line-illustration](https://cloud.githubusercontent.com/assets/7648874/21790810/1a052086-d6c6-11e6-9c5c-24298fedb043.png)\n\n> `n` represents the intersection value with the `y` axis.\n> See reference: http://mathworld.wolfram.com/Circle-LineIntersection.html.\n\nwe can find the intersection between a circle and line by solving the systems formed by the equations of both. We also want the line-circle algorithm to be available for any `Line` instance, therefore we gonna add the following delegate on the `Line` prototype:\n\n[{]: <helper> (diffStep 5.8)\n\n#### [Step 5.8: Delegate circle intersection methods](https://github.com/DAB0mB/radial-snake/commit/19828bf)\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;geometry&#x2F;line.js\n```diff\n@@ -44,6 +44,8 @@\n â”Š44â”Š44â”Š  getIntersection(shape) {\n â”Š45â”Š45â”Š    if (shape instanceof Engine.Geometry.Line)\n â”Š46â”Š46â”Š      return this.getLineIntersection(shape);\n+â”Š  â”Š47â”Š    if (shape instanceof Engine.Geometry.Circle)\n+â”Š  â”Š48â”Š      return this.getCircleIntersection(shape);\n â”Š47â”Š49â”Š  }\n â”Š48â”Š50â”Š\n â”Š49â”Š51â”Š  // line - line intersection method\n```\n```diff\n@@ -62,4 +64,9 @@\n â”Š62â”Š64â”Š      return { x, y };\n â”Š63â”Š65â”Š    }\n â”Š64â”Š66â”Š  }\n+â”Š  â”Š67â”Š\n+â”Š  â”Š68â”Š  // line - circle intersection method\n+â”Š  â”Š69â”Š  getCircleIntersection(circle) {\n+â”Š  â”Š70â”Š    return circle.getLineIntersection(this);\n+â”Š  â”Š71â”Š  }\n â”Š65â”Š72â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nThen again a newly created geometry shape class should be tested against different scenarios:\n\n[{]: <helper> (diffStep 5.9)\n\n#### [Step 5.9: Create &#x27;Circle&#x27; class tests](https://github.com/DAB0mB/radial-snake/commit/1d98a6e)\n\n##### Added resources&#x2F;scripts&#x2F;specs&#x2F;engine&#x2F;geometry&#x2F;circle.js\n```diff\n@@ -0,0 +1,144 @@\n+â”Š   â”Š  1â”Šdescribe(\"Engine.Geometry.Circle class\", function() {\n+â”Š   â”Š  2â”Š  beforeEach(function() {\n+â”Š   â”Š  3â”Š    this.circle = new Engine.Geometry.Circle(1, 1, 5, 0, 1.5 * Math.PI);\n+â”Š   â”Š  4â”Š  });\n+â”Š   â”Š  5â”Š\n+â”Š   â”Š  6â”Š  describe(\"getX method\", function() {\n+â”Š   â”Š  7â”Š    describe(\"given inranged rad\", function() {\n+â”Š   â”Š  8â”Š      it(\"returns x\", function() {\n+â”Š   â”Š  9â”Š        expect(this.circle.getX(0 * Math.PI)).toBeCloseTo(6);\n+â”Š   â”Š 10â”Š        expect(this.circle.getX(0.5 * Math.PI)).toBeCloseTo(1);\n+â”Š   â”Š 11â”Š        expect(this.circle.getX(1 * Math.PI)).toBeCloseTo(-4);\n+â”Š   â”Š 12â”Š        expect(this.circle.getX(1.5 * Math.PI)).toBeCloseTo(1);\n+â”Š   â”Š 13â”Š      });\n+â”Š   â”Š 14â”Š    });\n+â”Š   â”Š 15â”Š\n+â”Š   â”Š 16â”Š    describe(\"given outranged rad\", function() {\n+â”Š   â”Š 17â”Š      it(\"returns nothing\", function() {\n+â”Š   â”Š 18â”Š        expect(this.circle.getX(2 * Math.PI)).toBeUndefined();\n+â”Š   â”Š 19â”Š      });\n+â”Š   â”Š 20â”Š    });\n+â”Š   â”Š 21â”Š  });\n+â”Š   â”Š 22â”Š\n+â”Š   â”Š 23â”Š  describe(\"getY method\", function() {\n+â”Š   â”Š 24â”Š    describe(\"given inranged rad\", function() {\n+â”Š   â”Š 25â”Š      it(\"returns y\", function() {\n+â”Š   â”Š 26â”Š        expect(this.circle.getY(0 * Math.PI)).toBeCloseTo(1);\n+â”Š   â”Š 27â”Š        expect(this.circle.getY(0.5 * Math.PI)).toBeCloseTo(6);\n+â”Š   â”Š 28â”Š        expect(this.circle.getY(1 * Math.PI)).toBeCloseTo(1);\n+â”Š   â”Š 29â”Š        expect(this.circle.getY(1.5 * Math.PI)).toBeCloseTo(-4);\n+â”Š   â”Š 30â”Š      });\n+â”Š   â”Š 31â”Š    });\n+â”Š   â”Š 32â”Š\n+â”Š   â”Š 33â”Š    describe(\"given outranged rad\", function() {\n+â”Š   â”Š 34â”Š      it(\"returns nothing\", function() {\n+â”Š   â”Š 35â”Š        expect(this.circle.getY(2 * Math.PI)).toBeUndefined();\n+â”Š   â”Š 36â”Š      });\n+â”Š   â”Š 37â”Š    });\n+â”Š   â”Š 38â”Š  });\n+â”Š   â”Š 39â”Š\n+â”Š   â”Š 40â”Š  describe(\"getRad method\", function() {\n+â”Š   â”Š 41â”Š    describe(\"given inranged point\", function() {\n+â”Š   â”Š 42â”Š      it(\"returns rad\", function() {\n+â”Š   â”Š 43â”Š        let x = -3.0450849718747346;\n+â”Š   â”Š 44â”Š        let y = 3.9389262614623686;\n+â”Š   â”Š 45â”Š        expect(this.circle.getRad(x, y)).toBeCloseTo(0.8 * Math.PI);\n+â”Š   â”Š 46â”Š      });\n+â”Š   â”Š 47â”Š    });\n+â”Š   â”Š 48â”Š\n+â”Š   â”Š 49â”Š    describe(\"given outranged point\", function() {\n+â”Š   â”Š 50â”Š      it(\"returns nothing\", function() {\n+â”Š   â”Š 51â”Š        let x = 5.045084971874736;\n+â”Š   â”Š 52â”Š        let y = -1.9389262614623664;\n+â”Š   â”Š 53â”Š        expect(this.circle.getRad(x, y)).toBeUndefined();\n+â”Š   â”Š 54â”Š      });\n+â”Š   â”Š 55â”Š    });\n+â”Š   â”Š 56â”Š  });\n+â”Š   â”Š 57â”Š\n+â”Š   â”Š 58â”Š  describe(\"getCircleIntersection method\", function() {\n+â”Š   â”Š 59â”Š    describe(\"given circle with 2 intersection points\", function() {\n+â”Š   â”Š 60â”Š      it(\"returns array with intersection points\", function() {\n+â”Š   â”Š 61â”Š        let circle = new Engine.Geometry.Circle(-5, 1, 5, 0, 2 * Math.PI);\n+â”Š   â”Š 62â”Š\n+â”Š   â”Š 63â”Š        expect(this.circle.getCircleIntersection(circle)).toEqual([\n+â”Š   â”Š 64â”Š          { x: -2, y: -3 },\n+â”Š   â”Š 65â”Š          { x: -2, y: 5 }\n+â”Š   â”Š 66â”Š        ]);\n+â”Š   â”Š 67â”Š      });\n+â”Š   â”Š 68â”Š    });\n+â”Š   â”Š 69â”Š\n+â”Š   â”Š 70â”Š    describe(\"given circle with 1 intersection points\", function() {\n+â”Š   â”Š 71â”Š      it(\"returns array with intersection point\", function() {\n+â”Š   â”Š 72â”Š        let circle = new Engine.Geometry.Circle(-5, 1, 5, 0, 1 * Math.PI);\n+â”Š   â”Š 73â”Š\n+â”Š   â”Š 74â”Š        expect(this.circle.getCircleIntersection(circle)).toEqual([\n+â”Š   â”Š 75â”Š          { x: -2, y: 5 }\n+â”Š   â”Š 76â”Š        ]);\n+â”Š   â”Š 77â”Š      });\n+â”Š   â”Š 78â”Š    });\n+â”Š   â”Š 79â”Š\n+â”Š   â”Š 80â”Š    describe(\"given kissing circle\", function() {\n+â”Š   â”Š 81â”Š      it(\"returns array with intersection point\", function() {\n+â”Š   â”Š 82â”Š        let circle = new Engine.Geometry.Circle(-9, 1, 5, 0, 2 * Math.PI);\n+â”Š   â”Š 83â”Š\n+â”Š   â”Š 84â”Š        expect(this.circle.getCircleIntersection(circle)).toEqual([\n+â”Š   â”Š 85â”Š          { x: -4, y: 1 }\n+â”Š   â”Š 86â”Š        ]);\n+â”Š   â”Š 87â”Š      });\n+â”Š   â”Š 88â”Š    });\n+â”Š   â”Š 89â”Š\n+â”Š   â”Š 90â”Š    describe(\"given outer circle\", function() {\n+â”Š   â”Š 91â”Š      it(\"returns nothing\", function() {\n+â”Š   â”Š 92â”Š        let circle = new Engine.Geometry.Circle(10, 10, 2, 0, 2 * Math.PI);\n+â”Š   â”Š 93â”Š        expect(this.circle.getCircleIntersection(circle)).toBeUndefined();\n+â”Š   â”Š 94â”Š      });\n+â”Š   â”Š 95â”Š    });\n+â”Š   â”Š 96â”Š\n+â”Š   â”Š 97â”Š    describe(\"given inner circle\", function() {\n+â”Š   â”Š 98â”Š      it(\"nothing\", function() {\n+â”Š   â”Š 99â”Š        let circle = new Engine.Geometry.Circle(1, 1, 2, 0, 2 * Math.PI);\n+â”Š   â”Š100â”Š        expect(this.circle.getCircleIntersection(circle)).toBeUndefined();\n+â”Š   â”Š101â”Š      });\n+â”Š   â”Š102â”Š    });\n+â”Š   â”Š103â”Š  });\n+â”Š   â”Š104â”Š\n+â”Š   â”Š105â”Š  describe(\"getLineIntersection method\", function() {\n+â”Š   â”Š106â”Š    describe(\"given line with 2 intersection points\", function() {\n+â”Š   â”Š107â”Š      it(\"returns array with intersection points\", function() {\n+â”Š   â”Š108â”Š        let line = new Engine.Geometry.Line(-10, 1, 10, 1);\n+â”Š   â”Š109â”Š\n+â”Š   â”Š110â”Š        expect(this.circle.getLineIntersection(line)).toEqual([\n+â”Š   â”Š111â”Š          { x: 6, y: 1 },\n+â”Š   â”Š112â”Š          { x: -4, y: 1 }\n+â”Š   â”Š113â”Š        ]);\n+â”Š   â”Š114â”Š      });\n+â”Š   â”Š115â”Š    });\n+â”Š   â”Š116â”Š\n+â”Š   â”Š117â”Š    describe(\"given line with 1 intersection point\", function() {\n+â”Š   â”Š118â”Š      it(\"returns array with intersection point\", function() {\n+â”Š   â”Š119â”Š        let line = new Engine.Geometry.Line(-10, 1, 1, 1);\n+â”Š   â”Š120â”Š\n+â”Š   â”Š121â”Š        expect(this.circle.getLineIntersection(line)).toEqual([\n+â”Š   â”Š122â”Š          { x: -4, y: 1 }\n+â”Š   â”Š123â”Š        ]);\n+â”Š   â”Š124â”Š      });\n+â”Š   â”Š125â”Š    });\n+â”Š   â”Š126â”Š\n+â”Š   â”Š127â”Š    describe(\"given kissing line\", function() {\n+â”Š   â”Š128â”Š      it(\"returns array with intersection point\", function() {\n+â”Š   â”Š129â”Š        let line = new Engine.Geometry.Line(-10, 6, 10, 6);\n+â”Š   â”Š130â”Š\n+â”Š   â”Š131â”Š        expect(this.circle.getLineIntersection(line)).toEqual([\n+â”Š   â”Š132â”Š          { x: 1, y: 6 }\n+â”Š   â”Š133â”Š        ]);\n+â”Š   â”Š134â”Š      });\n+â”Š   â”Š135â”Š    });\n+â”Š   â”Š136â”Š\n+â”Š   â”Š137â”Š    describe(\"given outranged line\", function() {\n+â”Š   â”Š138â”Š      it(\"returns nothing\", function() {\n+â”Š   â”Š139â”Š        let line = new Engine.Geometry.Line(-10, 10, 10, 10);\n+â”Š   â”Š140â”Š        expect(this.circle.getLineIntersection(line)).toBeUndefined();\n+â”Š   â”Š141â”Š      });\n+â”Š   â”Š142â”Š    });\n+â”Š   â”Š143â”Š  });\n+â”Š   â”Š144â”Š});ðŸš«â†µ\n```\n\n##### Changed views&#x2F;spec_runner.html\n```diff\n@@ -19,9 +19,11 @@\n â”Š19â”Š19â”Š    <script type=\"text/javascript\" src=\"scripts/utils.js\"></script>\n â”Š20â”Š20â”Š    <script type=\"text/javascript\" src=\"scripts/namespaces.js\"></script>\n â”Š21â”Š21â”Š    <script type=\"text/javascript\" src=\"scripts/engine/geometry/line.js\"></script>\n+â”Š  â”Š22â”Š    <script type=\"text/javascript\" src=\"scripts/engine/geometry/circle.js\"></script>\n â”Š22â”Š23â”Š\n â”Š23â”Š24â”Š    <!-- Specs -->\n â”Š24â”Š25â”Š    <script type=\"text/javascript\" src=\"scripts/specs/engine/geometry/line.js\"></script>\n+â”Š  â”Š26â”Š    <script type=\"text/javascript\" src=\"scripts/specs/engine/geometry/circle.js\"></script>\n â”Š25â”Š27â”Š  </head>\n â”Š26â”Š28â”Š\n â”Š27â”Š29â”Š  <body>\n```\n\n[}]: #\n\nOur final shape in the geometry module would be a polygon. Why a polygon? Since I'm planning to make the snake's movement circular, which means that once the snake hits a random boundary, he will reappear from the other side of the canvas. The collision detection between the snake and the canvas would be done using a polygon - which is simply made out of 4 lines:\n\n[{]: <helper> (diffStep 5.1)\n\n#### [Step 5.1: Create utilities module](https://github.com/DAB0mB/radial-snake/commit/58ae99a)\n\n##### Added resources&#x2F;scripts&#x2F;utils.js\n```diff\n@@ -0,0 +1,68 @@\n+â”Š  â”Š 1â”Š// A wrapper function for our utilities which will enable chaining\n+â”Š  â”Š 2â”Š// e.g. Utils().mod().trim().isBetween()...\n+â”Š  â”Š 3â”ŠUtils = function Utils(context) {\n+â”Š  â”Š 4â”Š  const chain = {};\n+â”Š  â”Š 5â”Š\n+â”Š  â”Š 6â”Š  Object.keys(Utils).forEach((utilName) => {\n+â”Š  â”Š 7â”Š    chain[utilName] = (...args) => {\n+â”Š  â”Š 8â”Š      const result = Utils[utilName](context, ...args);\n+â”Š  â”Š 9â”Š      return Utils(result);\n+â”Š  â”Š10â”Š    };\n+â”Š  â”Š11â”Š  });\n+â”Š  â”Š12â”Š\n+â”Š  â”Š13â”Š  // Returns the result of the chaining\n+â”Š  â”Š14â”Š  chain.value = () => context;\n+â”Š  â”Š15â”Š\n+â”Š  â”Š16â”Š  return chain;\n+â”Š  â”Š17â”Š};\n+â”Š  â”Š18â”Š\n+â”Š  â”Š19â”Š// Fixed modulo method which can calculate modulo of negative numbers properly\n+â”Š  â”Š20â”Š// e.g. (-803).mod(800) returns 797\n+â”Š  â”Š21â”ŠUtils.mod = function (context, num) {\n+â”Š  â”Š22â”Š  return ((context % num) + num) % num;\n+â”Š  â”Š23â”Š};\n+â”Š  â”Š24â”Š\n+â”Š  â”Š25â”Š// Trims number and leaves the number of decimals specified.\n+â”Š  â”Š26â”Š// The \"mode\" argument specifies which math function should be invoked\n+â”Š  â”Š27â”Š// right after the number has been trimmed.\n+â”Š  â”Š28â”Š// e.g. 12.12345.trim(3, \"ceil\") returns 12.124\n+â”Š  â”Š29â”ŠUtils.trim = function (context, decimals, mode = \"round\") {\n+â”Š  â”Š30â”Š  return Math[mode](context * Math.pow(10, decimals)) / Math.pow(10, decimals);\n+â”Š  â”Š31â”Š};\n+â”Š  â”Š32â”Š\n+â”Š  â”Š33â”Š// Tells if number is in specified range based on given precision.\n+â”Š  â”Š34â”Š// See the \"compare\" method for more information about precision\n+â”Š  â”Š35â”ŠUtils.isBetween = function (context, num1, num2, precision) {\n+â”Š  â”Š36â”Š  return Utils.compare(context, Math.min(num1, num2), \">=\", precision) &&\n+â”Š  â”Š37â”Š         Utils.compare(context, Math.max(num1, num2), \"<=\", precision);\n+â”Š  â”Š38â”Š};\n+â”Š  â”Š39â”Š\n+â”Š  â”Š40â”Š// Initiates comparison operator between context number and a given number, only here\n+â”Š  â”Š41â”Š// a precision can be specified\n+â”Š  â”Š42â”ŠUtils.compare = function (context, num, method, precision = method) {\n+â”Š  â”Š43â”Š  switch (precision) {\n+â”Š  â”Š44â”Š    // Fixed precision, \"almost equal\" with a deviation of Îµ\n+â”Š  â”Š45â”Š    case \"f\":\n+â”Š  â”Š46â”Š      switch (method) {\n+â”Š  â”Š47â”Š        case \"<\": case \"<=\": return context <= num + Number.EPSILON;\n+â”Š  â”Š48â”Š        case \">\": case \">=\": return context >= num - Number.EPSILON;\n+â”Š  â”Š49â”Š        default: return Math.abs(context - num) <= Number.EPSILON;\n+â”Š  â”Š50â”Š      }\n+â”Š  â”Š51â”Š    // Pixel precision, round comparison\n+â”Š  â”Š52â”Š    case \"px\":\n+â”Š  â”Š53â”Š      switch (method) {\n+â”Š  â”Š54â”Š        case \"<\": case \"<=\": return Math.round(context) <= Math.round(num);\n+â”Š  â”Š55â”Š        case \">\": case \">=\": return Math.round(context) >= Math.round(num);\n+â”Š  â”Š56â”Š        default: return Math.round(context) == Math.round(num);\n+â”Š  â”Š57â”Š      }\n+â”Š  â”Š58â”Š    // Exact precision\n+â”Š  â”Š59â”Š    default:\n+â”Š  â”Š60â”Š      switch (method) {\n+â”Š  â”Š61â”Š        case \"<\": return context < num;\n+â”Š  â”Š62â”Š        case \"<=\": return context <= num;\n+â”Š  â”Š63â”Š        case \">\": return context > num;\n+â”Š  â”Š64â”Š        case \">=\": return context >= num;\n+â”Š  â”Š65â”Š        default: return context === num;\n+â”Š  â”Š66â”Š      }\n+â”Š  â”Š67â”Š  }\n+â”Š  â”Š68â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -8,6 +8,7 @@\n â”Š 8â”Š 8â”Š    <script type=\"text/javascript\" src=\"/libs/underscore.js\"></script>\n â”Š 9â”Š 9â”Š\n â”Š10â”Š10â”Š    <!-- Scripts -->\n+â”Š  â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/utils.js\"></script>\n â”Š11â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n â”Š12â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/restorable.js\"></script>\n â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/font.js\"></script>\n```\n\n[}]: #\n\nAgain we will delegate the newly created intersection methods in the `Line` class and `Circle` class:\n\n[{]: <helper> (diffStep 5.11)\n\n#### [Step 5.11: Delegate polygon intersection methods](https://github.com/DAB0mB/radial-snake/commit/d42a5d9)\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;geometry&#x2F;circle.js\n```diff\n@@ -83,6 +83,8 @@\n â”Š83â”Š83â”Š      return this.getLineIntersection(shape);\n â”Š84â”Š84â”Š    if (shape instanceof Engine.Geometry.Circle)\n â”Š85â”Š85â”Š      return this.getCircleIntersection(shape);\n+â”Š  â”Š86â”Š    if (shape instanceof Engine.Geometry.Polygon)\n+â”Š  â”Š87â”Š      return this.getPolygonIntersection(shape);\n â”Š86â”Š88â”Š  }\n â”Š87â”Š89â”Š\n â”Š88â”Š90â”Š  // circle - circle intersection method\n```\n```diff\n@@ -164,4 +166,9 @@\n â”Š164â”Š166â”Š\n â”Š165â”Š167â”Š    if (interPoints.length > 0) return interPoints;\n â”Š166â”Š168â”Š  }\n+â”Š   â”Š169â”Š\n+â”Š   â”Š170â”Š  // circle - polygon intersection method\n+â”Š   â”Š171â”Š  getPolygonIntersection(polygon) {\n+â”Š   â”Š172â”Š    return polygon.getCircleIntersection(this);\n+â”Š   â”Š173â”Š  }\n â”Š167â”Š174â”Š};ðŸš«â†µ\n```\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;geometry&#x2F;line.js\n```diff\n@@ -46,6 +46,8 @@\n â”Š46â”Š46â”Š      return this.getLineIntersection(shape);\n â”Š47â”Š47â”Š    if (shape instanceof Engine.Geometry.Circle)\n â”Š48â”Š48â”Š      return this.getCircleIntersection(shape);\n+â”Š  â”Š49â”Š    if (shape instanceof Engine.Geometry.Polygon)\n+â”Š  â”Š50â”Š      return this.getPolygonIntersection(shape);\n â”Š49â”Š51â”Š  }\n â”Š50â”Š52â”Š\n â”Š51â”Š53â”Š  // line - line intersection method\n```\n```diff\n@@ -69,4 +71,9 @@\n â”Š69â”Š71â”Š  getCircleIntersection(circle) {\n â”Š70â”Š72â”Š    return circle.getLineIntersection(this);\n â”Š71â”Š73â”Š  }\n+â”Š  â”Š74â”Š\n+â”Š  â”Š75â”Š  // line - polygon intersection method\n+â”Š  â”Š76â”Š  getPolygonIntersection(polygon) {\n+â”Š  â”Š77â”Š    return polygon.getLineIntersection(this);\n+â”Š  â”Š78â”Š  }\n â”Š72â”Š79â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nNow we will create a some tests to make sure our newly created polygon works properly:\n\n[{]: <helper> (diffStep 5.12)\n\n#### [Step 5.12: Create &#x27;Polygon&#x27; class tests](https://github.com/DAB0mB/radial-snake/commit/f3f890b)\n\n##### Added resources&#x2F;scripts&#x2F;specs&#x2F;engine&#x2F;geometry&#x2F;polygon.js\n```diff\n@@ -0,0 +1,96 @@\n+â”Š  â”Š 1â”Šdescribe(\"Engine.Geometry.Polygon class\", function() {\n+â”Š  â”Š 2â”Š  beforeEach(function() {\n+â”Š  â”Š 3â”Š    this.polygon = new Engine.Geometry.Polygon(\n+â”Š  â”Š 4â”Š      [0, 0, 5, 0],\n+â”Š  â”Š 5â”Š      [5, 0, 5, 5],\n+â”Š  â”Š 6â”Š      [5, 5, 0, 5],\n+â”Š  â”Š 7â”Š      [0, 5, 0, 0]\n+â”Š  â”Š 8â”Š    );\n+â”Š  â”Š 9â”Š  });\n+â”Š  â”Š10â”Š\n+â”Š  â”Š11â”Š  describe(\"hasPoint method\", function() {\n+â”Š  â”Š12â”Š    describe(\"given contained point\", function() {\n+â”Š  â”Š13â”Š      it(\"returns true\", function() {\n+â”Š  â”Š14â”Š        let x = 5;\n+â”Š  â”Š15â”Š        let y = 3;\n+â”Š  â”Š16â”Š        expect(this.polygon.hasPoint(x, y)).toBeTruthy();\n+â”Š  â”Š17â”Š      });\n+â”Š  â”Š18â”Š    });\n+â”Š  â”Š19â”Š\n+â”Š  â”Š20â”Š    describe(\"given outranged point\", function() {\n+â”Š  â”Š21â”Š      it(\"returns false\", function() {\n+â”Š  â”Š22â”Š        let x = 10;\n+â”Š  â”Š23â”Š        let y = 10;\n+â”Š  â”Š24â”Š        expect(this.polygon.hasPoint(x, y)).toBeFalsy();\n+â”Š  â”Š25â”Š      });\n+â”Š  â”Š26â”Š    });\n+â”Š  â”Š27â”Š  });\n+â”Š  â”Š28â”Š\n+â”Š  â”Š29â”Š  describe(\"getLineIntersection method\", function() {\n+â”Š  â”Š30â”Š    describe(\"given intersecting line\", function() {\n+â”Š  â”Š31â”Š      it(\"returns intersection point\", function() {\n+â”Š  â”Š32â”Š        let line = new Engine.Geometry.Line(0, 1, 5, 4);\n+â”Š  â”Š33â”Š\n+â”Š  â”Š34â”Š        expect(this.polygon.getLineIntersection(line)).toEqual([\n+â”Š  â”Š35â”Š          { x: 5, y: 4 },\n+â”Š  â”Š36â”Š          { x: 0, y: 1 }\n+â”Š  â”Š37â”Š        ]);\n+â”Š  â”Š38â”Š      });\n+â”Š  â”Š39â”Š    });\n+â”Š  â”Š40â”Š\n+â”Š  â”Š41â”Š    describe(\"given outranged line\", function() {\n+â”Š  â”Š42â”Š      it(\"returns nothing\", function() {\n+â”Š  â”Š43â”Š        let line = new Engine.Geometry.Line(10, 11, 15, 14);\n+â”Š  â”Š44â”Š\n+â”Š  â”Š45â”Š        expect(this.polygon.getLineIntersection(line)).toBeUndefined();\n+â”Š  â”Š46â”Š      });\n+â”Š  â”Š47â”Š    });\n+â”Š  â”Š48â”Š  });\n+â”Š  â”Š49â”Š\n+â”Š  â”Š50â”Š  describe(\"getCircleIntersection method\", function() {\n+â”Š  â”Š51â”Š    describe(\"given circle with 2 intersection points\", function() {\n+â”Š  â”Š52â”Š      it(\"returns array with intersection points\", function() {\n+â”Š  â”Š53â”Š        let circle = new Engine.Geometry.Circle(0, 0, 2, 0, 2 * Math.PI);\n+â”Š  â”Š54â”Š\n+â”Š  â”Š55â”Š        expect(this.polygon.getCircleIntersection(circle)).toEqual([\n+â”Š  â”Š56â”Š          { x: 2, y: 0 },\n+â”Š  â”Š57â”Š          { x: 0, y: 2 }\n+â”Š  â”Š58â”Š        ]);\n+â”Š  â”Š59â”Š      });\n+â”Š  â”Š60â”Š    });\n+â”Š  â”Š61â”Š\n+â”Š  â”Š62â”Š    describe(\"given circle with 1 intersection points\", function() {\n+â”Š  â”Š63â”Š      it(\"returns array with intersection point\", function() {\n+â”Š  â”Š64â”Š        let circle = new Engine.Geometry.Circle(0, 0, 2, 0, 0.25 * Math.PI);\n+â”Š  â”Š65â”Š\n+â”Š  â”Š66â”Š        expect(this.polygon.getCircleIntersection(circle)).toEqual([\n+â”Š  â”Š67â”Š          { x: 2, y: 0 }\n+â”Š  â”Š68â”Š        ]);\n+â”Š  â”Š69â”Š      });\n+â”Š  â”Š70â”Š    });\n+â”Š  â”Š71â”Š\n+â”Š  â”Š72â”Š    describe(\"given kissing circle\", function() {\n+â”Š  â”Š73â”Š      it(\"returns array with intersection point\", function() {\n+â”Š  â”Š74â”Š        let circle = new Engine.Geometry.Circle(-3, 3, 3, 0, 2 * Math.PI);\n+â”Š  â”Š75â”Š\n+â”Š  â”Š76â”Š        expect(this.polygon.getCircleIntersection(circle)).toEqual([\n+â”Š  â”Š77â”Š          { x: 0, y: 3 }\n+â”Š  â”Š78â”Š        ]);\n+â”Š  â”Š79â”Š      });\n+â”Š  â”Š80â”Š    });\n+â”Š  â”Š81â”Š\n+â”Š  â”Š82â”Š    describe(\"given outer circle\", function() {\n+â”Š  â”Š83â”Š      it(\"returns nothing\", function() {\n+â”Š  â”Š84â”Š        let circle = new Engine.Geometry.Circle(10, 10, 2, 0, 2 * Math.PI);\n+â”Š  â”Š85â”Š        expect(this.polygon.getCircleIntersection(circle)).toBeUndefined();\n+â”Š  â”Š86â”Š      });\n+â”Š  â”Š87â”Š    });\n+â”Š  â”Š88â”Š\n+â”Š  â”Š89â”Š    describe(\"given inner circle\", function() {\n+â”Š  â”Š90â”Š      it(\"nothing\", function() {\n+â”Š  â”Š91â”Š        let circle = new Engine.Geometry.Circle(2.5, 2.5, 2, 0, 2 * Math.PI);\n+â”Š  â”Š92â”Š        expect(this.polygon.getCircleIntersection(circle)).toBeUndefined();\n+â”Š  â”Š93â”Š      });\n+â”Š  â”Š94â”Š    });\n+â”Š  â”Š95â”Š  });\n+â”Š  â”Š96â”Š});ðŸš«â†µ\n```\n\n##### Changed views&#x2F;spec_runner.html\n```diff\n@@ -20,10 +20,12 @@\n â”Š20â”Š20â”Š    <script type=\"text/javascript\" src=\"scripts/namespaces.js\"></script>\n â”Š21â”Š21â”Š    <script type=\"text/javascript\" src=\"scripts/engine/geometry/line.js\"></script>\n â”Š22â”Š22â”Š    <script type=\"text/javascript\" src=\"scripts/engine/geometry/circle.js\"></script>\n+â”Š  â”Š23â”Š    <script type=\"text/javascript\" src=\"scripts/engine/geometry/polygon.js\"></script>\n â”Š23â”Š24â”Š\n â”Š24â”Š25â”Š    <!-- Specs -->\n â”Š25â”Š26â”Š    <script type=\"text/javascript\" src=\"scripts/specs/engine/geometry/line.js\"></script>\n â”Š26â”Š27â”Š    <script type=\"text/javascript\" src=\"scripts/specs/engine/geometry/circle.js\"></script>\n+â”Š  â”Š28â”Š    <script type=\"text/javascript\" src=\"scripts/specs/engine/geometry/polygon.js\"></script>\n â”Š27â”Š29â”Š  </head>\n â”Š28â”Š30â”Š\n â”Š29â”Š31â”Š  <body>\n```\n\n[}]: #\n\nAt last, all the necessary geometry shapes are implemented and ready to use. We will now focus on the snake itself. Since our game can potentially have infinite number of entities, not necessarily just a snake, we will add the a new module under the `Game` namespace called `Entities`:\n\n[{]: <helper> (diffStep 5.13)\n\n#### [Step 5.13: Add &#x27;Entities&#x27; module to &#x27;Game&#x27; namespace](https://github.com/DAB0mB/radial-snake/commit/a0bed8c)\n\n##### Changed resources&#x2F;scripts&#x2F;namespaces.js\n```diff\n@@ -1,4 +1,5 @@\n â”Š1â”Š1â”ŠGame = {\n+â”Š â”Š2â”Š  Entities: {},\n â”Š2â”Š3â”Š  Screens: {}\n â”Š3â”Š4â”Š};\n```\n\n[}]: #\n\nAnd now we can add the `Snake` class:\n\n[{]: <helper> (diffStep 5.14)\n\n#### [Step 5.14: Create &#x27;Snake&#x27; class](https://github.com/DAB0mB/radial-snake/commit/b938ba7)\n\n##### Added resources&#x2F;scripts&#x2F;game&#x2F;entities&#x2F;snake.js\n```diff\n@@ -0,0 +1,234 @@\n+â”Š   â”Š  1â”ŠGame.Entities.Snake = class Snake {\n+â”Š   â”Š  2â”Š  // Represents a snake data-structure which will eventually appear on screen.\n+â”Š   â”Š  3â”Š  // All the properties provided to the constructor are the initial values of\n+â”Š   â”Š  4â”Š  // the snake\n+â”Š   â”Š  5â”Š  constructor(x, y, r, rad, v, color, keyStates, options) {\n+â”Š   â”Š  6â”Š    this.x = x;\n+â”Š   â”Š  7â”Š    this.y = y;\n+â”Š   â”Š  8â”Š    this.r = r;\n+â”Š   â”Š  9â”Š    this.rad = rad;\n+â”Š   â”Š 10â”Š    this.v = v;\n+â”Š   â”Š 11â”Š    this.color = color;\n+â”Š   â”Š 12â”Š    this.keyStates = keyStates;\n+â”Š   â”Š 13â”Š    // A snake is made out of many geometry shapes\n+â”Š   â”Š 14â”Š    this.shapes = [];\n+â”Š   â”Š 15â”Š    // A snake starts with a line\n+â”Š   â”Š 16â”Š    this.currentShape = new Engine.Geometry.Line(x, y, x, y);\n+â”Š   â”Š 17â”Š    this.shapes.push(this.currentShape);\n+â”Š   â”Š 18â”Š    // A score can be provided in case we want to reserve previous scores from\n+â”Š   â”Š 19â”Š    // recent matches\n+â”Š   â”Š 20â”Š    this.score = options.score || 0;\n+â”Š   â”Š 21â”Š\n+â”Š   â”Š 22â”Š    // Custom keys can be specified\n+â”Š   â”Š 23â”Š    if (options.keys && options.keys) {\n+â”Š   â”Š 24â”Š      this.leftKey = options.keys.left;\n+â”Š   â”Š 25â”Š      this.rightKey = options.keys.right;\n+â”Š   â”Š 26â”Š    }\n+â”Š   â”Š 27â”Š    // Left and right arrow keys will be used by default\n+â”Š   â”Š 28â”Š    else {\n+â”Š   â”Š 29â”Š      this.leftKey = 37; // Left arrow\n+â”Š   â”Š 30â”Š      this.rightKey = 39; // Right arrow\n+â”Š   â”Š 31â”Š    }\n+â”Š   â”Š 32â”Š  }\n+â”Š   â”Š 33â”Š\n+â”Š   â”Š 34â”Š  draw(context) {\n+â”Š   â”Š 35â”Š    // Draw all shapes in the shapes array\n+â”Š   â”Š 36â”Š    this.shapes.forEach(shape => {\n+â”Š   â”Š 37â”Š      context.save();\n+â”Š   â”Š 38â”Š      context.strokeStyle = this.color;\n+â”Š   â”Š 39â”Š      context.lineWidth = 3;\n+â”Š   â”Š 40â”Š      context.beginPath();\n+â”Š   â”Š 41â”Š\n+â”Š   â”Š 42â”Š      // Each shape has its own unique drawing method\n+â”Š   â”Š 43â”Š      shape.draw(context);\n+â”Š   â”Š 44â”Š\n+â”Š   â”Š 45â”Š      context.stroke();\n+â”Š   â”Š 46â”Š      context.restore();\n+â”Š   â”Š 47â”Š    });\n+â”Š   â”Š 48â”Š  }\n+â”Š   â”Š 49â”Š\n+â”Š   â”Š 50â”Š  update(span, width, height) {\n+â”Š   â”Š 51â”Š    // Progress made based on elapsed time and velocity\n+â”Š   â”Š 52â”Š    let step = (this.v * span) / 1000;\n+â”Š   â”Š 53â”Š\n+â”Š   â”Š 54â”Š    this.updateShapes(step, width, height);\n+â”Š   â”Š 55â”Š    this.cycleThrough(step, width, height);\n+â”Š   â”Š 56â”Š  }\n+â”Š   â”Š 57â”Š\n+â”Š   â”Š 58â”Š  // Updates shapes array based on progress made\n+â”Š   â”Š 59â”Š  updateShapes(step, width, height, options = {}) {\n+â”Š   â”Š 60â”Š    this.updateCurrentShape(step, options);\n+â”Š   â”Š 61â”Š    this.updateDirection(step, options);\n+â”Š   â”Š 62â”Š  }\n+â”Š   â”Š 63â”Š\n+â”Š   â”Š 64â”Š  // Updates current shape\n+â”Š   â”Š 65â”Š  updateCurrentShape(step, options) {\n+â”Š   â”Š 66â”Š    if (this.currentShape instanceof Engine.Geometry.Line)\n+â”Š   â”Š 67â”Š      return this.updateCurrentLine(options);\n+â”Š   â”Š 68â”Š    if (this.currentShape instanceof Engine.Geometry.Circle)\n+â”Š   â”Š 69â”Š      return this.updateCurrentCircle(options);\n+â”Š   â”Š 70â”Š  }\n+â”Š   â”Š 71â”Š\n+â”Š   â”Š 72â”Š  // Updates current shape in case it is a line\n+â”Š   â”Š 73â”Š  updateCurrentLine(options) {\n+â”Š   â”Š 74â”Š    let lastX = options.lastX || this.x;\n+â”Š   â”Š 75â”Š    let lastY = options.lastY || this.y;\n+â”Š   â”Š 76â”Š    this.x = options.x || this.currentShape.x2;\n+â”Š   â”Š 77â”Š    this.y = options.y || this.currentShape.y2;\n+â”Š   â”Š 78â”Š    this.lastBit = new Engine.Geometry.Line(lastX, lastY, this.x, this.y);\n+â”Š   â”Š 79â”Š  }\n+â”Š   â”Š 80â”Š\n+â”Š   â”Š 81â”Š  // Updates current shape in case it is a circle\n+â”Š   â”Š 82â”Š  updateCurrentCircle(options) {\n+â”Š   â”Š 83â”Š    let lastX = options.lastX || this.currentShape.x;\n+â”Š   â”Š 84â”Š    let lastY = options.lastY || this.currentShape.y;\n+â”Š   â”Š 85â”Š    let lastR = options.lastR || this.currentShape.r;\n+â”Š   â”Š 86â”Š\n+â”Š   â”Š 87â”Š    // Update logic for left rotation\n+â”Š   â”Š 88â”Š    if (this.direction == \"left\") {\n+â”Š   â”Š 89â”Š      let lastRad = this.rad + (0.5 * Math.PI);\n+â”Š   â”Š 90â”Š      let currentShapePoint = this.currentShape.getPoint(this.currentShape.rad1);\n+â”Š   â”Š 91â”Š      this.x = options.x || currentShapePoint.x;\n+â”Š   â”Š 92â”Š      this.y = options.y || currentShapePoint.y;\n+â”Š   â”Š 93â”Š      this.rad = this.currentShape.rad1 - (0.5 * Math.PI);\n+â”Š   â”Š 94â”Š      this.lastBit = new Engine.Geometry.Circle(lastX, lastY, lastR, this.currentShape.rad1, lastRad);\n+â”Š   â”Š 95â”Š    }\n+â”Š   â”Š 96â”Š    // Update logic for right rotation\n+â”Š   â”Š 97â”Š    else {\n+â”Š   â”Š 98â”Š      let lastRad = this.rad - (0.5 * Math.PI);\n+â”Š   â”Š 99â”Š      let currentShapePoint = this.currentShape.getPoint(this.currentShape.rad2);\n+â”Š   â”Š100â”Š      this.x = options.x || currentShapePoint.x;\n+â”Š   â”Š101â”Š      this.y = options.y || currentShapePoint.y;\n+â”Š   â”Š102â”Š      this.rad = this.currentShape.rad2 + (0.5 * Math.PI);\n+â”Š   â”Š103â”Š      this.lastBit = new Engine.Geometry.Circle(lastX, lastY, lastR, lastRad, this.currentShape.rad2);\n+â”Š   â”Š104â”Š    }\n+â”Š   â”Š105â”Š  }\n+â”Š   â”Š106â”Š\n+â”Š   â”Š107â”Š  updateDirection(step, options) {\n+â”Š   â”Š108â”Š    // Update the direction based on pressed key\n+â”Š   â”Š109â”Š    if (this.keyStates.get(this.leftKey))\n+â”Š   â”Š110â”Š      var direction = \"left\";\n+â”Š   â”Š111â”Š    else if (this.keyStates.get(this.rightKey))\n+â”Š   â”Š112â”Š      var direction = \"right\";\n+â”Š   â”Š113â”Š\n+â”Š   â”Š114â”Š    this.changeDirection(step, direction, options);\n+â”Š   â”Š115â”Š    this.continueDirection(step, direction, options);\n+â”Š   â”Š116â”Š  }\n+â”Š   â”Š117â”Š\n+â”Š   â”Š118â”Š  // Change the recent shape type according to the given direction\n+â”Š   â”Š119â”Š  changeDirection(step, direction, options) {\n+â”Š   â”Š120â”Š    // If there is no change in direction, abort, unless we force it\n+â”Š   â”Š121â”Š    if (direction == this.direction && !options.force) return;\n+â”Š   â”Š122â”Š\n+â”Š   â”Š123â”Š    this.direction = direction;\n+â”Š   â”Š124â”Š\n+â”Š   â”Š125â”Š    // This will push a new shape with new properties, based on the direction\n+â”Š   â”Š126â”Š    switch (direction) {\n+â”Š   â”Š127â”Š      case \"left\":\n+â”Š   â”Š128â”Š        var angle = this.rad - (0.5 * Math.PI);\n+â”Š   â”Š129â”Š        var rad = this.rad + (0.5 * Math.PI);\n+â”Š   â”Š130â”Š        var x = this.x + (this.r * Math.cos(angle));\n+â”Š   â”Š131â”Š        var y = this.y + (this.r * Math.sin(angle));\n+â”Š   â”Š132â”Š        this.currentShape = new Engine.Geometry.Circle(x, y, this.r, rad, rad);\n+â”Š   â”Š133â”Š        break;\n+â”Š   â”Š134â”Š      case \"right\":\n+â”Š   â”Š135â”Š        angle = this.rad + (0.5 * Math.PI);\n+â”Š   â”Š136â”Š        rad = this.rad - (0.5 * Math.PI);\n+â”Š   â”Š137â”Š        x = this.x + (this.r * Math.cos(angle));\n+â”Š   â”Š138â”Š        y = this.y + (this.r * Math.sin(angle));\n+â”Š   â”Š139â”Š        this.currentShape = new Engine.Geometry.Circle(x, y, this.r, rad, rad);\n+â”Š   â”Š140â”Š        break;\n+â”Š   â”Š141â”Š      default:\n+â”Š   â”Š142â”Š        this.currentShape = new Engine.Geometry.Line(this.x, this.y, this.x, this.y);\n+â”Š   â”Š143â”Š    }\n+â”Š   â”Š144â”Š\n+â”Š   â”Š145â”Š    this.shapes.push(this.currentShape);\n+â”Š   â”Š146â”Š  }\n+â”Š   â”Š147â”Š\n+â”Š   â”Š148â”Š  // Extend the recent shape based on progress made\n+â”Š   â”Š149â”Š  continueDirection(step, direction) {\n+â”Š   â”Š150â”Š    switch (direction) {\n+â”Š   â”Š151â”Š      case \"left\":\n+â”Š   â”Š152â”Š        this.currentShape.rad1 -= step / this.r;\n+â”Š   â”Š153â”Š        break;\n+â”Š   â”Š154â”Š      case \"right\":\n+â”Š   â”Š155â”Š        this.currentShape.rad2 += step / this.r;\n+â”Š   â”Š156â”Š        break;\n+â”Š   â”Š157â”Š      default:\n+â”Š   â”Š158â”Š        this.currentShape.x2 += step * Math.cos(this.rad);\n+â”Š   â”Š159â”Š        this.currentShape.y2 += step * Math.sin(this.rad);\n+â”Š   â”Š160â”Š    }\n+â”Š   â”Š161â”Š  }\n+â”Š   â”Š162â”Š\n+â”Š   â”Š163â”Š  // Handles case where snake is out limits and we need to render it from\n+â”Š   â”Š164â”Š  // the other side of the canvas\n+â”Š   â”Š165â”Š  cycleThrough(step, width, height) {\n+â”Š   â”Š166â”Š    let intersectionPoint = this.getCanvasIntersection(width, height);\n+â”Š   â”Š167â”Š\n+â”Š   â”Š168â”Š    if (!intersectionPoint) return;\n+â”Š   â”Š169â”Š\n+â”Š   â”Š170â”Š    intersectionPoint = intersectionPoint[0];\n+â”Š   â”Š171â”Š\n+â”Š   â”Š172â”Š    // Re-calculate position based on canvas bounds\n+â”Š   â”Š173â”Š    if (intersectionPoint.x % width == 0)\n+â”Š   â”Š174â”Š      this.x = Utils.mod(this.x - width, width);\n+â”Š   â”Š175â”Š    if (intersectionPoint.y % height == 0)\n+â”Š   â”Š176â”Š      this.y = Utils.mod(this.y - height, height);\n+â”Š   â”Š177â”Š\n+â”Š   â”Š178â”Š    // Update shapes again based on custom properties\n+â”Š   â”Š179â”Š    this.updateShapes(step, width, height, {\n+â”Š   â”Š180â”Š      force: true,\n+â”Š   â”Š181â”Š      lastX: this.x,\n+â”Š   â”Š182â”Š      lastY: this.y,\n+â”Š   â”Š183â”Š      x: this.x,\n+â”Š   â”Š184â”Š      y: this.y\n+â”Š   â”Š185â”Š    });\n+â”Š   â”Š186â”Š  }\n+â”Š   â”Š187â”Š\n+â”Š   â”Š188â”Š  // Gets intersection points between last bit and own shapes\n+â”Š   â”Š189â”Š  getSelfIntersection() {\n+â”Š   â”Š190â”Š    if (this.currentShape instanceof Engine.Geometry.Circle &&\n+â”Š   â”Š191â”Š       Math.abs(this.currentShape.rad1 - this.currentShape.rad2) >= 2 * Math.PI) {\n+â”Š   â”Š192â”Š      if (this.direction == \"left\")\n+â”Š   â”Š193â”Š        var rad = this.currentShape.rad1;\n+â”Š   â”Š194â”Š      else\n+â”Š   â”Š195â”Š        var rad = this.currentShape.rad2;\n+â”Š   â”Š196â”Š\n+â”Š   â”Š197â”Š      return this.currentShape.getPoint(rad);\n+â”Š   â”Š198â”Š    }\n+â”Š   â”Š199â”Š\n+â”Š   â”Š200â”Š    let result;\n+â”Š   â”Š201â”Š\n+â”Š   â”Š202â”Š    this.shapes.slice(0, -2).some(shape =>\n+â”Š   â”Š203â”Š      result = this.lastBit.getIntersection(shape)\n+â”Š   â”Š204â”Š    );\n+â”Š   â”Š205â”Š\n+â”Š   â”Š206â”Š    return result;\n+â”Š   â”Š207â”Š  }\n+â”Š   â”Š208â”Š\n+â”Š   â”Š209â”Š  // Returns intersection points between snakes\n+â”Š   â”Š210â”Š  getSnakeIntersection(snake) {\n+â”Š   â”Š211â”Š    let result;\n+â”Š   â”Š212â”Š\n+â”Š   â”Š213â”Š    snake.shapes.some(shape =>\n+â”Š   â”Š214â”Š      // Only last bit is relevant, if we reached this point it means that\n+â”Š   â”Š215â”Š      // previous intersection will definitely fail\n+â”Š   â”Š216â”Š      result = this.lastBit.getIntersection(shape)\n+â”Š   â”Š217â”Š    );\n+â”Š   â”Š218â”Š\n+â”Š   â”Š219â”Š    return result;\n+â”Š   â”Š220â”Š  }\n+â”Š   â”Š221â”Š\n+â”Š   â”Š222â”Š  // Returns intersection points between snake and canvas\n+â”Š   â”Š223â”Š  getCanvasIntersection(width, height) {\n+â”Š   â”Š224â”Š    // Canvas polygon\n+â”Š   â”Š225â”Š    let canvasPolygon = new Engine.Geometry.Polygon(\n+â”Š   â”Š226â”Š      [0, 0, width, 0],\n+â”Š   â”Š227â”Š      [width, 0, width, height],\n+â”Š   â”Š228â”Š      [width, height, 0, height],\n+â”Š   â”Š229â”Š      [0, height, 0, 0]\n+â”Š   â”Š230â”Š    );\n+â”Š   â”Š231â”Š\n+â”Š   â”Š232â”Š    return canvasPolygon.getIntersection(this.lastBit);\n+â”Š   â”Š233â”Š  }\n+â”Š   â”Š234â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -22,6 +22,7 @@\n â”Š22â”Š22â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/screen.js\"></script>\n â”Š23â”Š23â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/assets_loader.js\"></script>\n â”Š24â”Š24â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n+â”Š  â”Š25â”Š    <script type=\"text/javascript\" src=\"/scripts/game/entities/snake.js\"></script>\n â”Š25â”Š26â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/menu/index.js\"></script>\n â”Š26â”Š27â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/splash/index.js\"></script>\n â”Š27â”Š28â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n```\n\n[}]: #\n\nThis class is titled with most complexity out of everything we did so far in this step. You can follow the code accompanied by comments regard it, but I'd also like to explain the key concepts. As said earlier, the `Snake` is simply made out of shapes; In this case - lines and circles.\n\nThe `draw` method just goes through this array and draws whatever shape it's currently looping through. Regardless of its type, every shape is provided with a `draw` method of its own, all shapes share the same interface, therefore we can just draw them regularly and the snake should be drawn automatically.\n\nThe `update` method updates the last bit only according to its type, the time elapsed and the speed of the snake. For example, the last bit of the snake is a line, and 5 seconds have passed at a speed of 5 meters per second, our line should be extended by 5 meters long. Same principle applies to circle extension only based on radians. The last bit's type might be changed according to the current input; e.g. if the `right` key is held the last bit would turn into a circle, and once released it would turn into a straight line.\n\nNote that besides shapes extension, collision detection should also be made. The embedded is the collision detection between the snake and the canvas, which means that any time the snake collides with the canvas's boundaries the last bit should be redrawn from the opposite side of the canvas. In addition, we've implemented intersection methods for self collision detection and collision detection between rivals, which should be used externally by the hosting screen.\n\nIn the next step we will be implementing the game screen where we will make use of the `Snake` class we've just created, and see how it works in action."
          },
          {
            "manualTitle": "Step 6: Creating a complex game screen with multiple layers",
            "stepRevision": "c27bb0d7806aab70ec489ccd9bbff182d1053dda",
            "manualView": "![snake-demo-game-small](https://cloud.githubusercontent.com/assets/7648874/21074124/8b7cd724-bed7-11e6-9f91-2a211630ac78.gif)\n\nIn this step we will be using the `Snake` class we've just created in the previous step to form the actual game screen - called the `Play` screen. The play screen is a complex screen made out multiple layers as following:\n\n- **`Ready` layer** - Displays a message at the beginning of each match.\n- **`Snake` layer** - Displays the the competitors' snakes.\n- **`Score` layer** - Displays the score board.\n- **`Win` layer** - Displays the winner at the end of each match.\n\nAs we go further with this step, we will give a deeper explanation about each layer and how they interact with each other; As for let's start with the `Play` screen's basis. Regardless of what the `Play` screen should contain at the final result, we want to have the ability to abort the match whenever we press the `Escape` key, therefore, the initial implementation should look like this:\n\n[{]: <helper> (diffStep 6.1)\n\n#### [Step 6.1: Create &#x27;Play&#x27; screen](https://github.com/DAB0mB/radial-snake/commit/e17a45f)\n\n##### Added resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;play&#x2F;index.js\n```diff\n@@ -0,0 +1,14 @@\n+â”Š  â”Š 1â”ŠGame.Screens.Play = class Play extends Engine.Screen {\n+â”Š  â”Š 2â”Š  get events() {\n+â”Š  â”Š 3â”Š    return {\n+â”Š  â”Š 4â”Š      \"keydown\": \"onKeyDown\"\n+â”Š  â”Š 5â”Š    }\n+â”Š  â”Š 6â”Š  }\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Š  onKeyDown() {\n+â”Š  â”Š 9â”Š    // Once escape is pressed, return to main menu screen\n+â”Š  â”Š10â”Š    if (this.keyStates.get(27)) {\n+â”Š  â”Š11â”Š      this.game.changeScreen(Game.Screens.Menu);\n+â”Š  â”Š12â”Š    }\n+â”Š  â”Š13â”Š  }\n+â”Š  â”Š14â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -23,6 +23,7 @@\n â”Š23â”Š23â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/assets_loader.js\"></script>\n â”Š24â”Š24â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š25â”Š25â”Š    <script type=\"text/javascript\" src=\"/scripts/game/entities/snake.js\"></script>\n+â”Š  â”Š26â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/index.js\"></script>\n â”Š26â”Š27â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/menu/index.js\"></script>\n â”Š27â”Š28â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/splash/index.js\"></script>\n â”Š28â”Š29â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n```\n\n[}]: #\n\nNow that we have the `Play` screen, we need to hook it to the `Menu` screen, so whenever we press a key, we will be proceeded to it:\n\n[{]: <helper> (diffStep 6.2)\n\n#### [Step 6.2: Hook &#x27;Play&#x27; screen to &#x27;menu&#x27; screen](https://github.com/DAB0mB/radial-snake/commit/495b9ee)\n\n##### Changed resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;menu&#x2F;index.js\n```diff\n@@ -1,4 +1,10 @@\n â”Š 1â”Š 1â”ŠGame.Screens.Menu = class Menu extends Engine.Screen {\n+â”Š  â”Š 2â”Š  get events() {\n+â”Š  â”Š 3â”Š    return {\n+â”Š  â”Š 4â”Š      \"keydown\": \"onKeyDown\"\n+â”Š  â”Š 5â”Š    }\n+â”Š  â”Š 6â”Š  }\n+â”Š  â”Š 7â”Š\n â”Š 2â”Š 8â”Š  initialize() {\n â”Š 3â”Š 9â”Š    // Initialize snake logo sprite\n â”Š 4â”Š10â”Š    this.logoSprite = new Engine.Sprite(this.assets.logoTexture);\n```\n```diff\n@@ -40,10 +46,18 @@\n â”Š40â”Š46â”Š  }\n â”Š41â”Š47â”Š\n â”Š42â”Š48â”Š  update(span) {\n-â”Š43â”Š  â”Š    this.instructionsAnim.update(span);\n+â”Š  â”Š49â”Š    // On key press, proceed to play screen\n+â”Š  â”Š50â”Š    if (this.keyPressed) {\n+â”Š  â”Š51â”Š      this.game.changeScreen(Game.Screens.Play);\n+â”Š  â”Š52â”Š    }\n+â”Š  â”Š53â”Š    // Else, just update animation\n+â”Š  â”Š54â”Š    else {\n+â”Š  â”Š55â”Š      this.instructionsAnim.update(span);\n+â”Š  â”Š56â”Š    }\n â”Š44â”Š57â”Š  }\n â”Š45â”Š58â”Š\n-â”Š46â”Š  â”Š  update(span) {\n-â”Š47â”Š  â”Š    this.instructionsAnim.update(span);\n+â”Š  â”Š59â”Š  // Register key press\n+â”Š  â”Š60â”Š  onKeyDown(e) {\n+â”Š  â”Š61â”Š    this.keyPressed = true;\n â”Š48â”Š62â”Š  }\n â”Š49â”Š63â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nBy now there shouldn't be anything special. Once you're at the main menu, just press a key as instructed, and you shall see a black screen, which is actually the `Play` screen we've just created; And once you'll press the `Escape` key, you should be receded to the main menu.\n\nThe next stage would be displaying a `Ready` message on the screen, and whenever a key is pressed, the message should fade away using a key-frame animation, and the match should start in the background:\n\n[{]: <helper> (diffStep 6.3)\n\n#### [Step 6.3: Create &#x27;Ready&#x27; layer](https://github.com/DAB0mB/radial-snake/commit/551962d)\n\n##### Added resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;play&#x2F;ready.js\n```diff\n@@ -0,0 +1,59 @@\n+â”Š  â”Š 1â”ŠGame.Screens.Play.Ready = class Ready extends Engine.Layer {\n+â”Š  â”Š 2â”Š  get events() {\n+â”Š  â”Š 3â”Š    return {\n+â”Š  â”Š 4â”Š      \"keydown\": \"onKeyDown\"\n+â”Š  â”Š 5â”Š    };\n+â”Š  â”Š 6â”Š  }\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Š  constructor(screen, snakes) {\n+â”Š  â”Š 9â”Š    super(screen);\n+â”Š  â”Š10â”Š\n+â”Š  â”Š11â”Š    this.snakes = snakes;\n+â”Š  â”Š12â”Š\n+â”Š  â”Š13â”Š    // Create \"ready\" sprite and set its properties\n+â”Š  â”Š14â”Š    let readyTexture = this.assets.minecraftiaFont.createTexture(\"Ready\");\n+â”Š  â”Š15â”Š    let readySprite = new Engine.Sprite(readyTexture);\n+â”Š  â”Š16â”Š    readySprite.align = \"center\";\n+â”Š  â”Š17â”Š    readySprite.setPercentage(\"width\", this.width, 15, \"height\");\n+â”Š  â”Š18â”Š\n+â”Š  â”Š19â”Š    // Create fade out animation for \"ready\" sprite\n+â”Š  â”Š20â”Š    this.readyAnim = new Engine.Animations.Keyframe(readySprite, [\n+â”Š  â”Š21â”Š      {\n+â”Š  â”Š22â”Š        x: this.width / 2,\n+â”Š  â”Š23â”Š        y: this.height / 2,\n+â”Š  â”Š24â”Š        opacity: 1,\n+â”Š  â”Š25â”Š        frame: 0\n+â”Š  â”Š26â”Š      },\n+â”Š  â”Š27â”Š      {\n+â”Š  â”Š28â”Š        y: this.height / 3,\n+â”Š  â”Š29â”Š        opacity: 0,\n+â”Š  â”Š30â”Š        frame: 700\n+â”Š  â”Š31â”Š      }\n+â”Š  â”Š32â”Š    ]);\n+â”Š  â”Š33â”Š  }\n+â”Š  â”Š34â”Š\n+â”Š  â”Š35â”Š  draw(context) {\n+â”Š  â”Š36â”Š    this.readyAnim.draw(context);\n+â”Š  â”Š37â”Š  }\n+â”Š  â”Š38â”Š\n+â”Š  â”Š39â”Š  update(span) {\n+â”Š  â”Š40â”Š    if (!this.ready) return;\n+â”Š  â”Š41â”Š\n+â”Š  â”Š42â”Š    if (this.readyAnim.playing) {\n+â”Š  â”Š43â”Š      this.readyAnim.update(span);\n+â”Š  â”Š44â”Š    }\n+â”Š  â”Š45â”Š    // Once animation is finished, dispose layer\n+â”Š  â”Š46â”Š    else {\n+â”Š  â”Š47â”Š      this.screen.removeLayer(this);\n+â”Š  â”Š48â”Š    }\n+â”Š  â”Š49â”Š  }\n+â”Š  â”Š50â”Š\n+â”Š  â”Š51â”Š  onKeyDown() {\n+â”Š  â”Š52â”Š    // One time event\n+â”Š  â”Š53â”Š    this.disposeEventListeners()\n+â”Š  â”Š54â”Š\n+â”Š  â”Š55â”Š    // This will start playing the animation\n+â”Š  â”Š56â”Š    this.ready = true;\n+â”Š  â”Š57â”Š    this.readyAnim.play();\n+â”Š  â”Š58â”Š  }\n+â”Š  â”Š59â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -24,6 +24,7 @@\n â”Š24â”Š24â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š25â”Š25â”Š    <script type=\"text/javascript\" src=\"/scripts/game/entities/snake.js\"></script>\n â”Š26â”Š26â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/index.js\"></script>\n+â”Š  â”Š27â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/ready.js\"></script>\n â”Š27â”Š28â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/menu/index.js\"></script>\n â”Š28â”Š29â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/splash/index.js\"></script>\n â”Š29â”Š30â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n```\n\n[}]: #\n\nIn order to hook the `Ready` layer to the `Play` screen, we will just push a new instance of it to the layers stack, using the screen's `appendLayer` method. Note that the order of the layer is super critic! Since if we push a new layer it means it will be drawn on top of any previous layer. To \"shift\" a layer to the layers stack, we can simply use the `prependLayer` method instead. Without further due, this is how our hook should look like:\n\n[{]: <helper> (diffStep 6.4)\n\n#### [Step 6.4: Hook &#x27;Ready&#x27; layer to &#x27;Play&#x27; screen](https://github.com/DAB0mB/radial-snake/commit/b461464)\n\n##### Changed resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;play&#x2F;index.js\n```diff\n@@ -5,6 +5,11 @@\n â”Š 5â”Š 5â”Š    }\n â”Š 6â”Š 6â”Š  }\n â”Š 7â”Š 7â”Š\n+â”Š  â”Š 8â”Š  // The ready screen will be the initial screen\n+â”Š  â”Š 9â”Š  initialize(game, snakes) {\n+â”Š  â”Š10â”Š    this.appendLayer(Game.Screens.Play.Ready, snakes);\n+â”Š  â”Š11â”Š  }\n+â”Š  â”Š12â”Š\n â”Š 8â”Š13â”Š  onKeyDown() {\n â”Š 9â”Š14â”Š    // Once escape is pressed, return to main menu screen\n â”Š10â”Š15â”Š    if (this.keyStates.get(27)) {\n```\n\n[}]: #\n\nNow if you'll launch the game and start a new match, you should see a white `Ready` message in the middle of the screen. Up next, would be the `Snake` layer, which will simply initialize 2 new `Snake` instances, and take care of drawing and updating them:\n\n[{]: <helper> (diffStep 6.5)\n\n#### [Step 6.5: Create &#x27;snake&#x27; layer](https://github.com/DAB0mB/radial-snake/commit/a36d7f2)\n\n##### Added resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;play&#x2F;snake.js\n```diff\n@@ -0,0 +1,79 @@\n+â”Š  â”Š 1â”ŠGame.Screens.Play.Snake = class Snake extends Engine.Layer {\n+â”Š  â”Š 2â”Š  constructor(screen, snakes = []) {\n+â”Š  â”Š 3â”Š    super(screen);\n+â”Š  â”Š 4â”Š\n+â”Š  â”Š 5â”Š    // Red snake\n+â”Š  â”Š 6â”Š    this.snakes = [\n+â”Š  â”Š 7â”Š      new Game.Entities.Snake(\n+â”Š  â”Š 8â”Š        this.width / 4,\n+â”Š  â”Š 9â”Š        this.height / 4,\n+â”Š  â”Š10â”Š        50,\n+â”Š  â”Š11â”Š        Math.PI / 4,\n+â”Š  â”Š12â”Š        100,\n+â”Š  â”Š13â”Š        \"FireBrick\",\n+â”Š  â”Š14â”Š        this.keyStates,\n+â”Š  â”Š15â”Š        {\n+â”Š  â”Š16â”Š          // Use score from previous matches\n+â”Š  â”Š17â”Š          score: snakes[0] && snakes[0].score,\n+â”Š  â”Š18â”Š          keys: {\n+â”Š  â”Š19â”Š            left: 37, // Left key\n+â”Š  â”Š20â”Š            right: 39 // RIght key\n+â”Š  â”Š21â”Š        }\n+â”Š  â”Š22â”Š      }),\n+â”Š  â”Š23â”Š\n+â”Š  â”Š24â”Š      // Blue snake\n+â”Š  â”Š25â”Š      new Game.Entities.Snake(\n+â”Š  â”Š26â”Š        (this.width / 4) * 3,\n+â”Š  â”Š27â”Š        (this.height / 4) * 3,\n+â”Š  â”Š28â”Š        50,\n+â”Š  â”Š29â”Š        (-Math.PI / 4) * 3,\n+â”Š  â”Š30â”Š        100,\n+â”Š  â”Š31â”Š        \"DodgerBlue\",\n+â”Š  â”Š32â”Š        this.keyStates,\n+â”Š  â”Š33â”Š        {\n+â”Š  â”Š34â”Š          score: snakes[1] && snakes[1].score,\n+â”Š  â”Š35â”Š          keys: {\n+â”Š  â”Š36â”Š            left: 65, // 'a' key\n+â”Š  â”Š37â”Š            right: 68 // 'b' key\n+â”Š  â”Š38â”Š        }\n+â”Š  â”Š39â”Š      })\n+â”Š  â”Š40â”Š    ];\n+â”Š  â”Š41â”Š  }\n+â”Š  â”Š42â”Š\n+â”Š  â”Š43â”Š  draw(context) {\n+â”Š  â”Š44â”Š    // Draw each snake in the snakes array\n+â”Š  â”Š45â”Š    this.snakes.forEach(snake => snake.draw(context));\n+â”Š  â”Š46â”Š  }\n+â”Š  â”Š47â”Š\n+â”Š  â”Š48â”Š  update(span) {\n+â”Š  â”Š49â”Š    if (!this.snakes.length) return;\n+â”Š  â”Š50â”Š\n+â”Š  â”Š51â”Š    // Storing original snakes array for future use, since it might get changed\n+â”Š  â”Š52â”Š    let snakes = this.snakes.slice();\n+â”Š  â”Š53â”Š\n+â”Š  â”Š54â”Š    snakes.forEach((snake, index) => {\n+â”Š  â”Š55â”Š      snake.update(span, this.width, this.height);\n+â”Š  â”Š56â”Š      // Disqualify if intersected with self\n+â”Š  â”Š57â”Š      if (snake.getSelfIntersection()) return this.snakes.splice(index, 1);\n+â”Š  â”Š58â”Š\n+â”Š  â”Š59â”Š      snakes.forEach((opponent) => {\n+â”Š  â”Š60â”Š        // Don't scan for intersection with self, obviously this will always be true\n+â”Š  â”Š61â”Š        if (opponent === snake) return;\n+â”Š  â”Š62â”Š        // Disqualify if intersected with opponent\n+â”Š  â”Š63â”Š        if (snake.getSnakeIntersection(opponent)) this.snakes.splice(index, 1);\n+â”Š  â”Š64â”Š      });\n+â”Š  â”Š65â”Š    });\n+â”Š  â”Š66â”Š\n+â”Š  â”Š67â”Š    // There can be only one winner, or a tie (very rare, most likely not to happen)\n+â”Š  â”Š68â”Š    // If the match is already finished, skip the next steps since they are not relevant\n+â”Š  â”Š69â”Š    if (this.snakes.length > 1 || this.matchFinished) return;\n+â”Š  â”Š70â”Š\n+â”Š  â”Š71â”Š    // The winner is the \"last snake standing\"\n+â”Š  â”Š72â”Š    let winner = this.snakes[0];\n+â”Š  â”Š73â”Š    // If this is not a tie, which is a very rare case, increase the winner's score\n+â”Š  â”Š74â”Š    if (winner) winner.score++;\n+â”Š  â”Š75â”Š\n+â”Š  â”Š76â”Š    // Indicates whether we should update the score counter or not\n+â”Š  â”Š77â”Š    this.matchFinished = true;\n+â”Š  â”Š78â”Š  }\n+â”Š  â”Š79â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -24,6 +24,7 @@\n â”Š24â”Š24â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š25â”Š25â”Š    <script type=\"text/javascript\" src=\"/scripts/game/entities/snake.js\"></script>\n â”Š26â”Š26â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/index.js\"></script>\n+â”Š  â”Š27â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/snake.js\"></script>\n â”Š27â”Š28â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/ready.js\"></script>\n â”Š28â”Š29â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/menu/index.js\"></script>\n â”Š29â”Š30â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/splash/index.js\"></script>\n```\n\n[}]: #\n\nOnce pressing a key in the `Ready` layer, not only we want to display an animation, but we also want the match to start in the background, thus, we gonna push a new instance of the `Snake` layer we've just created like so:\n\n[{]: <helper> (diffStep 6.6)\n\n#### [Step 6.6: Hook &#x27;snake&#x27; layer to &#x27;ready&#x27; layer](https://github.com/DAB0mB/radial-snake/commit/982db7b)\n\n##### Changed resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;play&#x2F;ready.js\n```diff\n@@ -55,5 +55,8 @@\n â”Š55â”Š55â”Š    // This will start playing the animation\n â”Š56â”Š56â”Š    this.ready = true;\n â”Š57â”Š57â”Š    this.readyAnim.play();\n+â”Š  â”Š58â”Š\n+â”Š  â”Š59â”Š    // Start the game in the background\n+â”Š  â”Š60â”Š    this.screen.prependLayer(Game.Screens.Play.Snake, this.snakes);\n â”Š58â”Š61â”Š  }\n â”Š59â”Š62â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nNote that the layer is pushed when the animation starts and not once finished; This would give a nice smooth feeling to our game-flow. If you'll test out the game, you would discover that the match is actually playable! The first snake (Red) snake should be controlled by the arrow keys, and the second snake (Blue) should be controlled by the letter keys `a`, `s`, `d` and `w`. So far, the snakes function great, but you can probably tell that whenever a match is finished, it feels a bit dull. There's no indication of winning, and there's no score board to present the score of each competitor, which brings us to the next stage - Implementing the `Score` layer.\n\nThe `Score` layer is a simple layer which takes the 2 snakes as a parameter and displays their scores at the top of the screen:\n\n[{]: <helper> (diffStep 6.7)\n\n#### [Step 6.7: Create &#x27;Score&#x27; layer](https://github.com/DAB0mB/radial-snake/commit/6ec4cac)\n\n##### Added resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;play&#x2F;score.js\n```diff\n@@ -0,0 +1,66 @@\n+â”Š  â”Š 1â”ŠGame.Screens.Play.Score = class Score extends Engine.Layer {\n+â”Š  â”Š 2â”Š  constructor(screen, snakes) {\n+â”Š  â”Š 3â”Š    super(screen);\n+â”Š  â”Š 4â”Š\n+â”Š  â”Š 5â”Š    this.snakes = snakes;\n+â”Š  â”Š 6â”Š    this.scoreSprites = [];\n+â”Š  â”Š 7â”Š    this.scores = [];\n+â”Š  â”Š 8â”Š\n+â”Š  â”Š 9â”Š    // It's important to match indexes to each snake since the number of snakes\n+â”Š  â”Š10â”Š    // can be reduced along the way as we play\n+â”Š  â”Š11â”Š    snakes.forEach((snake, index) => {\n+â”Š  â”Š12â”Š      snake.index = index;\n+â”Š  â”Š13â”Š    });\n+â”Š  â”Š14â”Š  }\n+â”Š  â”Š15â”Š\n+â”Š  â”Š16â”Š  draw(context) {\n+â”Š  â”Š17â”Š    this.scoreSprites.forEach((scoreSprite) => {\n+â”Š  â”Š18â”Š      scoreSprite.draw(context);\n+â”Š  â”Š19â”Š    });\n+â”Š  â”Š20â”Š  }\n+â”Š  â”Š21â”Š\n+â”Š  â”Š22â”Š  update(span) {\n+â”Š  â”Š23â”Š    this.snakes.forEach(snake => {\n+â”Š  â”Š24â”Š      let index = snake.index;\n+â”Š  â”Š25â”Š      if (this.scores[index] == snake.score) return;\n+â”Š  â”Š26â”Š\n+â”Š  â”Š27â”Š      // The sprite might be changed along the way so it's important to recreate it\n+â”Š  â”Š28â”Š      // over and over again. If no change was made the cache will be used by the engine\n+â”Š  â”Š29â”Š      this.scoreSprites[index] = this.createScoreSprite(snake);\n+â”Š  â”Š30â”Š      this.scores[index] = snake.score;\n+â”Š  â”Š31â”Š    });\n+â”Š  â”Š32â”Š  }\n+â”Š  â”Š33â”Š\n+â”Š  â”Š34â”Š  createScoreSprite(snake) {\n+â”Š  â”Š35â”Š    let minecraftiaFont = this.assets.minecraftiaFont;\n+â”Š  â”Š36â”Š    minecraftiaFont.save();\n+â”Š  â”Š37â”Š    minecraftiaFont.color = snake.color;\n+â”Š  â”Š38â”Š\n+â”Š  â”Š39â”Š    // Create a score sprite for the snake\n+â”Š  â”Š40â”Š    let scoreTexture = minecraftiaFont.createTexture(`${snake.score}`, {\n+â”Š  â”Š41â”Š      noOffsets: true,\n+â”Š  â”Š42â”Š      noSpaces: true\n+â”Š  â”Š43â”Š    });\n+â”Š  â”Š44â”Š\n+â”Š  â”Š45â”Š    let scoreSprite = new Engine.Sprite(scoreTexture);\n+â”Š  â”Š46â”Š\n+â”Š  â”Š47â”Š    // Size of score board is dynamic to screen size\n+â”Š  â”Š48â”Š    scoreSprite.setPercentage(\"width\", this.width, 4, \"height\");\n+â”Š  â”Š49â”Š\n+â”Š  â”Š50â”Š    // Set alignment modes.\n+â”Š  â”Š51â”Š    // Once we add more snakes we should add more cases here\n+â”Š  â”Š52â”Š    switch (snake.index) {\n+â”Š  â”Š53â”Š      case 0:\n+â”Š  â”Š54â”Š        scoreSprite.align = \"top-left\";\n+â”Š  â”Š55â”Š        break;\n+â”Š  â”Š56â”Š      case 1:\n+â”Š  â”Š57â”Š        scoreSprite.align = \"top-right\";\n+â”Š  â”Š58â”Š        scoreSprite.x = this.width;\n+â”Š  â”Š59â”Š        break;\n+â”Š  â”Š60â”Š    }\n+â”Š  â”Š61â”Š\n+â”Š  â”Š62â”Š    // Restore the font to its original color\n+â”Š  â”Š63â”Š    minecraftiaFont.restore();\n+â”Š  â”Š64â”Š    return scoreSprite;\n+â”Š  â”Š65â”Š  }\n+â”Š  â”Š66â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -24,6 +24,7 @@\n â”Š24â”Š24â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š25â”Š25â”Š    <script type=\"text/javascript\" src=\"/scripts/game/entities/snake.js\"></script>\n â”Š26â”Š26â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/index.js\"></script>\n+â”Š  â”Š27â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/score.js\"></script>\n â”Š27â”Š28â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/snake.js\"></script>\n â”Š28â”Š29â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/ready.js\"></script>\n â”Š29â”Š30â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/menu/index.js\"></script>\n```\n\n[}]: #\n\n> Note that the current score board is suitable for two players, but can easily be modified to support as much players as you want if done correctly.\n\nThe `Score` board should be appended to the layers stack as soon as the `Snake` layers is initialized, so it would be available to us once the match is started:\n\n[{]: <helper> (diffStep 6.8)\n\n#### [Step 6.8: Hook &#x27;Score&#x27; layer to &#x27;Snake&#x27; layer](https://github.com/DAB0mB/radial-snake/commit/feb4a0b)\n\n##### Changed resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;play&#x2F;snake.js\n```diff\n@@ -38,6 +38,9 @@\n â”Š38â”Š38â”Š        }\n â”Š39â”Š39â”Š      })\n â”Š40â”Š40â”Š    ];\n+â”Š  â”Š41â”Š\n+â”Š  â”Š42â”Š    // Show score board for newly created snakes\n+â”Š  â”Š43â”Š    screen.appendLayer(Game.Screens.Play.Score, this.snakes);\n â”Š41â”Š44â”Š  }\n â”Š42â”Š45â”Š\n â”Š43â”Š46â”Š  draw(context) {\n```\n\n[}]: #\n\nNow we're one layer further from completing the `Play` screen, the only thing missing is the `Win` layer, which should present the winner once the match is finished:\n\n[{]: <helper> (diffStep 6.9)\n\n#### [Step 6.9: Create &#x27;Win&#x27; layer](https://github.com/DAB0mB/radial-snake/commit/3476384)\n\n##### Added resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;play&#x2F;win.js\n```diff\n@@ -0,0 +1,43 @@\n+â”Š  â”Š 1â”ŠGame.Screens.Play.Win = class Win extends Engine.Layer {\n+â”Š  â”Š 2â”Š  constructor(screen, snakes, winner) {\n+â”Š  â”Š 3â”Š    super(screen);\n+â”Š  â”Š 4â”Š\n+â”Š  â”Š 5â”Š    this.snakes = snakes;\n+â”Š  â”Š 6â”Š    this.winner = winner;\n+â”Š  â”Š 7â”Š    // ttl stands for \"time to live\", which means, this layer is going to be\n+â”Š  â”Š 8â”Š    // disposed after 3 seconds\n+â”Š  â”Š 9â”Š    this.ttl = 3000;\n+â”Š  â”Š10â”Š\n+â”Š  â”Š11â”Š    // If there is a winner\n+â”Š  â”Š12â”Š    if (this.winner) {\n+â”Š  â”Š13â”Š      // Message could be something like \"RED SNAKE WINS\"\n+â”Š  â”Š14â”Š      var text = `${this.winner.color.toUpperCase()} SNAKE WINS`;\n+â”Š  â”Š15â”Š      var percent = 40;\n+â”Š  â”Š16â”Š    }\n+â”Š  â”Š17â”Š    // If there is a tie\n+â”Š  â”Š18â”Š    else {\n+â”Š  â”Š19â”Š      var text = 'TIE';\n+â”Š  â”Š20â”Š      var percent = 15;\n+â”Š  â”Š21â”Š    }\n+â”Š  â”Š22â”Š\n+â”Š  â”Š23â”Š    // Create winner sprite and set its properties\n+â”Š  â”Š24â”Š    let winnerTexture = this.assets.minecraftiaFont.createTexture(text);\n+â”Š  â”Š25â”Š    this.winnerSprite = new Engine.Sprite(winnerTexture);\n+â”Š  â”Š26â”Š    this.winnerSprite.align = \"center\";\n+â”Š  â”Š27â”Š    this.winnerSprite.setPercentage(\"width\", this.width, percent, \"height\");\n+â”Š  â”Š28â”Š    this.winnerSprite.x = this.width / 2;\n+â”Š  â”Š29â”Š    this.winnerSprite.y = this.height / 2;\n+â”Š  â”Š30â”Š  }\n+â”Š  â”Š31â”Š\n+â”Š  â”Š32â”Š  draw(context) {\n+â”Š  â”Š33â”Š    this.winnerSprite.draw(context);\n+â”Š  â”Š34â”Š  }\n+â”Š  â”Š35â”Š\n+â”Š  â”Š36â”Š  update(span) {\n+â”Š  â”Š37â”Š    // If limit not yet reached, abort\n+â”Š  â”Š38â”Š    if (this.age < this.ttl) return;\n+â”Š  â”Š39â”Š\n+â”Š  â”Š40â”Š    // Show \"ready\" message all over again, only this time use the updated score board\n+â”Š  â”Š41â”Š    this.screen.game.changeScreen(Game.Screens.Play, this.snakes);\n+â”Š  â”Š42â”Š  }\n+â”Š  â”Š43â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -24,6 +24,7 @@\n â”Š24â”Š24â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š25â”Š25â”Š    <script type=\"text/javascript\" src=\"/scripts/game/entities/snake.js\"></script>\n â”Š26â”Š26â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/index.js\"></script>\n+â”Š  â”Š27â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/win.js\"></script>\n â”Š27â”Š28â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/score.js\"></script>\n â”Š28â”Š29â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/snake.js\"></script>\n â”Š29â”Š30â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/ready.js\"></script>\n```\n\n[}]: #\n\nNote how we use the `changeScreen` method once the `Win` layer has reached its age limit (Time to live, aka `ttl`); This would clear the layers stack and restart the `Play` screen, so we can start a new match all-over, only this time we will pass the `Snake` instances to reserve the original scores. The `Win` layer should be presented whenever a collision has been detected between the snakes:\n\n[{]: <helper> (diffStep 6.1)\n\n#### [Step 6.1: Create &#x27;Play&#x27; screen](https://github.com/DAB0mB/radial-snake/commit/e17a45f)\n\n##### Added resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;play&#x2F;index.js\n```diff\n@@ -0,0 +1,14 @@\n+â”Š  â”Š 1â”ŠGame.Screens.Play = class Play extends Engine.Screen {\n+â”Š  â”Š 2â”Š  get events() {\n+â”Š  â”Š 3â”Š    return {\n+â”Š  â”Š 4â”Š      \"keydown\": \"onKeyDown\"\n+â”Š  â”Š 5â”Š    }\n+â”Š  â”Š 6â”Š  }\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Š  onKeyDown() {\n+â”Š  â”Š 9â”Š    // Once escape is pressed, return to main menu screen\n+â”Š  â”Š10â”Š    if (this.keyStates.get(27)) {\n+â”Š  â”Š11â”Š      this.game.changeScreen(Game.Screens.Menu);\n+â”Š  â”Š12â”Š    }\n+â”Š  â”Š13â”Š  }\n+â”Š  â”Š14â”Š};ðŸš«â†µ\n```\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -23,6 +23,7 @@\n â”Š23â”Š23â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/assets_loader.js\"></script>\n â”Š24â”Š24â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/game.js\"></script>\n â”Š25â”Š25â”Š    <script type=\"text/javascript\" src=\"/scripts/game/entities/snake.js\"></script>\n+â”Š  â”Š26â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/play/index.js\"></script>\n â”Š26â”Š27â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/menu/index.js\"></script>\n â”Š27â”Š28â”Š    <script type=\"text/javascript\" src=\"/scripts/game/screens/splash/index.js\"></script>\n â”Š28â”Š29â”Š    <script type=\"text/javascript\" src=\"/scripts/main.js\"></script>\n```\n\n[}]: #\n\nThat's it folks, the `Play` screen is finished, and you can play as much matches as you'd feel like.\n\nAlthough the game is finished, it can still be optimized using `C++`. To discover more on hooking efficiency and how we can hook `C++` to the browser, see the next step."
          },
          {
            "manualTitle": "Step 7: Bonus! Re-implementing geometry in C++",
            "stepRevision": "cea4cffcc2f5e801020ed13ef8f1edde608c85f3",
            "manualView": "> This step is part of a bigger tutorial series where we learn how to create a game engine and implement a Tron-style game in JavaScript. The base project for the following step is available [here](https://github.com/DAB0mB/radial-snake/tree/step6).\n\nSo far I covered up pretty much everything I planned. I showed you how to create a game engine, including a font generator, an animation player and a screening system. On top of that, we've learned how to structure and organize our code well, so if in the future we'd like to extend our game by adding more screens or capabilities, we can do that with ease. Indeed, we've went through lots of great stuff, and if you've reached this point I give you my thumbs up. If so far this wasn't enough, in this step we will be focusing on optimization, and making our game engine run faster (a lot, faster). Obviously, when talking about optimizations, the first thing you would probably think of is how we can make our algorithms efficient by using minimum number of operations. While this is true, we will be actually focusing on optimizing our code using C++.\n\nUnlike JavaScript, which is a dynamic scripting file executed by an interpreter, C++ is a general purpose language which compiles into executables. Naturally, executables are much faster than scripts, since they don't have to be interpreted, and they can approach the hardware and memory much faster. In C++, we have to explicitly define our data-types, meaning that variables don't have to be parsed during run-time. While explicit variables definition is C++'s biggest drawback, it's also one of its biggest advantages. The mere fact that variables can be handled much faster, makes code much more efficient.\n\nAccordingly, we can conclude that the programming language we're using plays a very important role when it comes to efficiency. So how exactly are we going to integrate C++ into the browser? We're going to do that by using a compiler called - [Emscripten](http://kripken.github.io/emscripten-site/).\n\n![emscripten](https://cloud.githubusercontent.com/assets/7648874/22675449/ee6d7e9c-eccc-11e6-9570-1dd5d982ee66.png)\n\nEmscripten is an Open Source [LLVM](https://en.wikipedia.org/wiki/LLVM) to JavaScript compiler. Using Emscripten you can:\n\n- Compile C and C++ code into JavaScript\n- Compile any other code that can be translated into LLVM bitcode into JavaScript.\n- Compile the C/C++ runtimes of other languages into JavaScript, and then run code in those other languages in an indirect way (this has been done for Python and Lua)!\n\nLLVM is a library that is used to construct, optimize and produce intermediate and/or binary machine code. LLVM can be used as a compiler framework, where you provide the \"front end\" (parser and lexer) and the \"back end\" (code that converts LLVM's representation to actual machine code). LLVM can also act as a JIT compiler - it has support for x86/x86_64 and PPC/PPC64 assembly generation with fast code optimizations aimed for compilation speed.\n\nEmscripten operates by taking LLVM code and converting it into a subset of JavaScript called asm.js that can run anywhere that JavaScript can run (usually the browser, but also Node.js, etc.) and is easy for browsers to optimize. This means that you can basically write web applications in any language that has an LLVM compiler.\n\n![emscripten-flow](https://cloud.githubusercontent.com/assets/7648874/22675751/b244b76c-ecce-11e6-917e-f7039ed4b340.png)\n\nIn order to use Emscripten you will first have to install it. I recommend you to follow Emscripten's official installation instructions at their website over [here](https://kripken.github.io/emscripten-site/docs/getting_started/downloads.html). Installing Emscripten might be a bit tiring for some, I know for me it was, but if you're hyped about writing native code in the browser as much as I do, take as much time as needed to install it, and bare with me.\n\nAssuming that you have Emscripten installed, we can get right to business. The goal for this step is to re-implement our geometry namespace in C++, and to be more specific, the circle class and line class. We will start by creating an entry file for our C++ code under the path `resources/cpp/src/index.cpp`:\n\n    $ mkdir resources/cpp\n    $ mkdir resources/cpp/src\n    $ touch resources/cpp/src/index.cpp\n\nFrom now on, every C++ file that we would like to run in the browser should be included in the `index.cpp` file we've just created, otherwise it's not going to appear anywhere. The first stage for re-implementing our geometry would be re-writing the utility module, since our geometry is heavily based on it; Therefore the firs inclusion in our `index.cpp` file would be the following:\n\n[{]: <helper> (diffStep 7.1)\n\n#### [Step 7.1: Add CPP entry script](https://github.com/DAB0mB/radial-snake/commit/2f35323)\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;index.cpp\n```diff\n@@ -0,0 +1 @@\n+â”Š â”Š1â”Š#include \"utils.cpp\"ðŸš«â†µ\n```\n\n[}]: #\n\nFollowing that, we will create the `utils.cpp` module included above, which is a direct translation from C++ to JavaScript for the `utils.js` we've created earlier in this tutorial.\n\n[{]: <helper> (diffStep 7.2)\n\n#### [Step 7.2: Add base utility CPP module](https://github.com/DAB0mB/radial-snake/commit/6dba512)\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;utils.cpp\n```diff\n@@ -0,0 +1,73 @@\n+â”Š  â”Š 1â”Š#include <cfloat>\n+â”Š  â”Š 2â”Š#include <cmath>\n+â”Š  â”Š 3â”Š#include <string>\n+â”Š  â”Š 4â”Š#include \"utils.h\"\n+â”Š  â”Š 5â”Š\n+â”Š  â”Š 6â”Šnamespace utils {\n+â”Š  â”Š 7â”Š  // Fixed modulo method which can calculate modulo of negative numbers properly\n+â”Š  â”Š 8â”Š  // e.g. (-803).mod(800) returns 797\n+â”Š  â”Š 9â”Š  double mod(double context, double num) {\n+â”Š  â”Š10â”Š    return std::fmod((std::fmod(context, num) + num), num);\n+â”Š  â”Š11â”Š  }\n+â”Š  â”Š12â”Š\n+â”Š  â”Š13â”Š  // Trims number and leaves the number of decimals specified.\n+â”Š  â”Š14â”Š  // The \"mode\" argument specifies which math function should be invoked\n+â”Š  â”Š15â”Š  // right after the number has been trimmed.\n+â”Š  â”Š16â”Š  // e.g. 12.12345.trim(3, \"ceil\") returns 12.124\n+â”Š  â”Š17â”Š  double trim(double context, int decimals, const std::string mode) {\n+â”Š  â”Š18â”Š    double accumulator = context * std::pow(10, decimals);\n+â”Š  â”Š19â”Š\n+â”Š  â”Š20â”Š    if (mode.compare(\"ceil\") == 0)\n+â”Š  â”Š21â”Š      accumulator = std::ceil(accumulator);\n+â”Š  â”Š22â”Š    else if (mode.compare(\"floor\") == 0)\n+â”Š  â”Š23â”Š      accumulator = std::floor(accumulator);\n+â”Š  â”Š24â”Š    else\n+â”Š  â”Š25â”Š      accumulator = std::round(accumulator);\n+â”Š  â”Š26â”Š\n+â”Š  â”Š27â”Š    return accumulator / std::pow(10, decimals);\n+â”Š  â”Š28â”Š  }\n+â”Š  â”Š29â”Š\n+â”Š  â”Š30â”Š  // Tells if number is in specified range based on given precision.\n+â”Š  â”Š31â”Š  // See the \"compare\" method for more information about precision\n+â”Š  â”Š32â”Š  bool isBetween(double context, double num1, double num2, const std::string precision) {\n+â”Š  â”Š33â”Š    return compare(context, std::min(num1, num2), \">=\", precision) &&\n+â”Š  â”Š34â”Š           compare(context, std::max(num1, num2), \"<=\", precision);\n+â”Š  â”Š35â”Š  }\n+â”Š  â”Š36â”Š\n+â”Š  â”Š37â”Š  bool compare(double context, double num, const std::string precision) {\n+â”Š  â”Š38â”Š    return compare(context, num, \"==\", precision);\n+â”Š  â”Š39â”Š  }\n+â”Š  â”Š40â”Š\n+â”Š  â”Š41â”Š  // Initiates comparison operator between context number and a given number, only here\n+â”Š  â”Š42â”Š  // a precision can be specified\n+â”Š  â”Š43â”Š  bool compare(double context, double num, const std::string method, const std::string precision) {\n+â”Š  â”Š44â”Š    // Fixed precision, \"almost equal\" with a deviation of Îµ\n+â”Š  â”Š45â”Š    if (precision.compare(\"f\") == 0) {\n+â”Š  â”Š46â”Š      if (method.compare(\"<\") == 0 ||\n+â”Š  â”Š47â”Š          method.compare(\"<=\") == 0)\n+â”Š  â”Š48â”Š        return context <= num + DBL_EPSILON;\n+â”Š  â”Š49â”Š      if (method.compare(\">\") == 0 ||\n+â”Š  â”Š50â”Š          method.compare(\">=\") == 0)\n+â”Š  â”Š51â”Š        return context >= num - DBL_EPSILON;\n+â”Š  â”Š52â”Š      return std::abs(context - num) <= DBL_EPSILON;\n+â”Š  â”Š53â”Š    }\n+â”Š  â”Š54â”Š    // Pixel precision, round comparison\n+â”Š  â”Š55â”Š    else if (precision.compare(\"px\") == 0) {\n+â”Š  â”Š56â”Š      if (method.compare(\"<\") == 0 ||\n+â”Š  â”Š57â”Š          method.compare(\"<=\") == 0)\n+â”Š  â”Š58â”Š        return std::round(context) <= std::round(num);\n+â”Š  â”Š59â”Š      if (method.compare(\">\") == 0 ||\n+â”Š  â”Š60â”Š          method.compare(\">=\") == 0)\n+â”Š  â”Š61â”Š        return std::round(context) >= std::round(num);\n+â”Š  â”Š62â”Š      return std::round(context) == std::round(num);\n+â”Š  â”Š63â”Š    }\n+â”Š  â”Š64â”Š    // Exact precision\n+â”Š  â”Š65â”Š    else {\n+â”Š  â”Š66â”Š      if (method.compare(\"<\") == 0) return context < num;\n+â”Š  â”Š67â”Š      if (method.compare(\"<=\") == 0) return context <= num;\n+â”Š  â”Š68â”Š      if (method.compare(\">\") == 0) return context > num;\n+â”Š  â”Š69â”Š      if (method.compare(\">=\") == 0) return context >= num;\n+â”Š  â”Š70â”Š      return context == num;\n+â”Š  â”Š71â”Š    }\n+â”Š  â”Š72â”Š  }\n+â”Š  â”Š73â”Š}ðŸš«â†µ\n```\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;utils.h\n```diff\n@@ -0,0 +1,15 @@\n+â”Š  â”Š 1â”Š#pragma once\n+â”Š  â”Š 2â”Š\n+â”Š  â”Š 3â”Š#include <string>\n+â”Š  â”Š 4â”Š\n+â”Š  â”Š 5â”Šnamespace utils {\n+â”Š  â”Š 6â”Š  double mod(double context, double num);\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Š  double trim(double context, int decimals, const std::string mode = \"round\");\n+â”Š  â”Š 9â”Š\n+â”Š  â”Š10â”Š  bool isBetween(double context, double num1, double num2, const std::string precision = \"exact\");\n+â”Š  â”Š11â”Š\n+â”Š  â”Š12â”Š  bool compare(double context, double num, const std::string precision = \"exact\");\n+â”Š  â”Š13â”Š\n+â”Š  â”Š14â”Š  bool compare(double context, double num, const std::string method, const std::string precision);\n+â”Š  â”Š15â”Š}ðŸš«â†µ\n```\n\n[}]: #\n\nThe module above should work by itself when interacting with it inside the C++ scope, but that's not what we're striving for. We want this module to be available for use in our JavaScript project. This requires us to wrap our code in such a way the the Emscripten compiler will know how to compile it. Apart from providing a compiler, Emscripten provides us with functions and macros that will help use bind our C++ code to the JavaScript environment. These functionalities are packed in a single library which can be imported in our C++ code, and it is called [Embind](https://kripken.github.io/emscripten-site/docs/porting/connecting_cpp_and_javascript/embind.html) (probably stands for \"Emscripten bind\"). Using EMBind, let's wrap our utils module accordingly:\n\n[{]: <helper> (diffStep 7.3)\n\n#### [Step 7.3: EMBind CPP utils](https://github.com/DAB0mB/radial-snake/commit/0f34332)\n\n##### Changed resources&#x2F;cpp&#x2F;src&#x2F;utils.cpp\n```diff\n@@ -1,6 +1,7 @@\n â”Š1â”Š1â”Š#include <cfloat>\n â”Š2â”Š2â”Š#include <cmath>\n â”Š3â”Š3â”Š#include <string>\n+â”Š â”Š4â”Š#include <emscripten/bind.h>\n â”Š4â”Š5â”Š#include \"utils.h\"\n â”Š5â”Š6â”Š\n â”Š6â”Š7â”Šnamespace utils {\n```\n```diff\n@@ -70,4 +71,15 @@\n â”Š70â”Š71â”Š      return context == num;\n â”Š71â”Š72â”Š    }\n â”Š72â”Š73â”Š  }\n+â”Š  â”Š74â”Š}\n+â”Š  â”Š75â”Š\n+â”Š  â”Š76â”ŠEMSCRIPTEN_BINDINGS(utils_module) {\n+â”Š  â”Š77â”Š  emscripten::function(\"utils_mod\", &utils::mod);\n+â”Š  â”Š78â”Š  emscripten::function(\"utils_trim\", &utils::trim);\n+â”Š  â”Š79â”Š  emscripten::function(\"utils_isBetween\", &utils::isBetween);\n+â”Š  â”Š80â”Š  emscripten::function(\"utils_compare\",\n+â”Š  â”Š81â”Š    emscripten::select_overload<bool(double, double, const std::string, const std::string)>(\n+â”Š  â”Š82â”Š      &utils::compare\n+â”Š  â”Š83â”Š    )\n+â”Š  â”Š84â”Š  );\n â”Š73â”Š85â”Š}ðŸš«â†µ\n```\n\n[}]: #\n\nAfter a while you'll get used for Embind's API. If you'll look at it, it's self explanatory and easy to understand. Bound objects will be available the JavaScript environment will be available under an object named `Module`, e.g. the C++ method `mod` will be available for use as `Module.utils_mod`. Bound functions should have supported return types and argument types, meaning that if we're using a custom structure as a return type or an argument type, we first need to wrap it using EMBind, otherwise the compiler won't know how to handle it. A list of natively supported data-types can be found [here](https://kripken.github.io/emscripten-site/docs/porting/connecting_cpp_and_javascript/embind.html#built-in-type-conversions).\n\nEven though we've wrapped our C++ code and hypothetically it can already be used in the browser, I'd go for a second wrapper, since the compiled code doesn't have the optimal architecture. Right now we will have to approach C++ utility functions using `Module.utils_foo`. Instead, I'd like it to be `CPP.Utils.foo`, since it's clearer this way. The output of the Emscripten compiler can be wrapped with JavaScript code, using a prefix and a suffix, defined in 2 separate files respectively, called `pre.js` and `post.js`:\n\n[{]: <helper> (diffStep 7.4)\n\n#### [Step 7.4: Create CPP wrappers](https://github.com/DAB0mB/radial-snake/commit/cc28a34)\n\n##### Added resources&#x2F;cpp&#x2F;post.js\n```diff\n@@ -0,0 +1,10 @@\n+â”Š  â”Š 1â”Šreturn {\n+â”Š  â”Š 2â”Š  Utils: {\n+â”Š  â”Š 3â”Š    mod: Module.utils_mod,\n+â”Š  â”Š 4â”Š    trim: Module.utils_trim,\n+â”Š  â”Š 5â”Š    isBetween: Module.utils_isBetween,\n+â”Š  â”Š 6â”Š    compare: Module.utils_compare\n+â”Š  â”Š 7â”Š  }\n+â”Š  â”Š 8â”Š};\n+â”Š  â”Š 9â”Š\n+â”Š  â”Š10â”Š})();ðŸš«â†µ\n```\n\n##### Added resources&#x2F;cpp&#x2F;pre.js\n```diff\n@@ -0,0 +1 @@\n+â”Š â”Š1â”ŠCPP = (function() {ðŸš«â†µ\n```\n\n[}]: #\n\nWhat we've done in the code snippet above, we've created an anonymous function which calls itself, and inside we've exported a new namespace called `CPP` (C++). This way we can keep the generated code encapsulated, without worrying about spamming the global object.\n\nAfter creating a wrapper, I'd also recommend you to integrate the generated C++ code into existing namespaces, meaning that if for example we would like to approach the `CPP.Utils.foo` method, it could be done using `Utils.foo`. This way existing code won't have to be changed, and extra wrapping logic can be applied with ease, like the chaining logic implemented in the `Utils` namespace:\n\n[{]: <helper> (diffStep 7.5)\n\n#### [Step 7.5: Bind CPP utils to JS utils](https://github.com/DAB0mB/radial-snake/commit/0a67d50)\n\n##### Changed resources&#x2F;scripts&#x2F;utils.js\n```diff\n@@ -16,53 +16,9 @@\n â”Š16â”Š16â”Š  return chain;\n â”Š17â”Š17â”Š};\n â”Š18â”Š18â”Š\n-â”Š19â”Š  â”Š// Fixed modulo method which can calculate modulo of negative numbers properly\n-â”Š20â”Š  â”Š// e.g. (-803).mod(800) returns 797\n-â”Š21â”Š  â”ŠUtils.mod = function (context, num) {\n-â”Š22â”Š  â”Š  return ((context % num) + num) % num;\n-â”Š23â”Š  â”Š};\n-â”Š24â”Š  â”Š\n-â”Š25â”Š  â”Š// Trims number and leaves the number of decimals specified.\n-â”Š26â”Š  â”Š// The \"mode\" argument specifies which math function should be invoked\n-â”Š27â”Š  â”Š// right after the number has been trimmed.\n-â”Š28â”Š  â”Š// e.g. 12.12345.trim(3, \"ceil\") returns 12.124\n-â”Š29â”Š  â”ŠUtils.trim = function (context, decimals, mode = \"round\") {\n-â”Š30â”Š  â”Š  return Math[mode](context * Math.pow(10, decimals)) / Math.pow(10, decimals);\n-â”Š31â”Š  â”Š};\n-â”Š32â”Š  â”Š\n-â”Š33â”Š  â”Š// Tells if number is in specified range based on given precision.\n-â”Š34â”Š  â”Š// See the \"compare\" method for more information about precision\n-â”Š35â”Š  â”ŠUtils.isBetween = function (context, num1, num2, precision) {\n-â”Š36â”Š  â”Š  return Utils.compare(context, Math.min(num1, num2), \">=\", precision) &&\n-â”Š37â”Š  â”Š         Utils.compare(context, Math.max(num1, num2), \"<=\", precision);\n-â”Š38â”Š  â”Š};\n-â”Š39â”Š  â”Š\n-â”Š40â”Š  â”Š// Initiates comparison operator between context number and a given number, only here\n-â”Š41â”Š  â”Š// a precision can be specified\n-â”Š42â”Š  â”ŠUtils.compare = function (context, num, method, precision = method) {\n-â”Š43â”Š  â”Š  switch (precision) {\n-â”Š44â”Š  â”Š    // Fixed precision, \"almost equal\" with a deviation of Îµ\n-â”Š45â”Š  â”Š    case \"f\":\n-â”Š46â”Š  â”Š      switch (method) {\n-â”Š47â”Š  â”Š        case \"<\": case \"<=\": return context <= num + Number.EPSILON;\n-â”Š48â”Š  â”Š        case \">\": case \">=\": return context >= num - Number.EPSILON;\n-â”Š49â”Š  â”Š        default: return Math.abs(context - num) <= Number.EPSILON;\n-â”Š50â”Š  â”Š      }\n-â”Š51â”Š  â”Š    // Pixel precision, round comparison\n-â”Š52â”Š  â”Š    case \"px\":\n-â”Š53â”Š  â”Š      switch (method) {\n-â”Š54â”Š  â”Š        case \"<\": case \"<=\": return Math.round(context) <= Math.round(num);\n-â”Š55â”Š  â”Š        case \">\": case \">=\": return Math.round(context) >= Math.round(num);\n-â”Š56â”Š  â”Š        default: return Math.round(context) == Math.round(num);\n-â”Š57â”Š  â”Š      }\n-â”Š58â”Š  â”Š    // Exact precision\n-â”Š59â”Š  â”Š    default:\n-â”Š60â”Š  â”Š      switch (method) {\n-â”Š61â”Š  â”Š        case \"<\": return context < num;\n-â”Š62â”Š  â”Š        case \"<=\": return context <= num;\n-â”Š63â”Š  â”Š        case \">\": return context > num;\n-â”Š64â”Š  â”Š        case \">=\": return context >= num;\n-â”Š65â”Š  â”Š        default: return context === num;\n-â”Š66â”Š  â”Š      }\n+â”Š  â”Š19â”ŠObject.assign(Utils, CPP.Utils, {\n+â”Š  â”Š20â”Š  // Overload handling\n+â”Š  â”Š21â”Š  compare(context, num, method, precision = method) {\n+â”Š  â”Š22â”Š    return CPP.Utils.compare(context, num, method, precision);\n â”Š67â”Š23â”Š  }\n-â”Š68â”Š  â”Š};ðŸš«â†µ\n+â”Š  â”Š24â”Š});ðŸš«â†µ\n```\n\n[}]: #\n\nWhenever launching the compiler, the generated code should be outputted somewhere. I've decided to go with the path `resources/scripts/cpp.bundle.js`, but it doesn't matter how the file is gonna be called, as long as it's defined under the `scripts` dir, otherwise we won't be able to load it. Also, we need to make sure that we set a git-ignore rule for the generated file, since there's no reason for us to upload it to the git-host if we're planning on compiling it:\n\n[{]: <helper> (diffStep 7.5)\n\n#### [Step 7.5: Bind CPP utils to JS utils](https://github.com/DAB0mB/radial-snake/commit/0a67d50)\n\n##### Changed resources&#x2F;scripts&#x2F;utils.js\n```diff\n@@ -16,53 +16,9 @@\n â”Š16â”Š16â”Š  return chain;\n â”Š17â”Š17â”Š};\n â”Š18â”Š18â”Š\n-â”Š19â”Š  â”Š// Fixed modulo method which can calculate modulo of negative numbers properly\n-â”Š20â”Š  â”Š// e.g. (-803).mod(800) returns 797\n-â”Š21â”Š  â”ŠUtils.mod = function (context, num) {\n-â”Š22â”Š  â”Š  return ((context % num) + num) % num;\n-â”Š23â”Š  â”Š};\n-â”Š24â”Š  â”Š\n-â”Š25â”Š  â”Š// Trims number and leaves the number of decimals specified.\n-â”Š26â”Š  â”Š// The \"mode\" argument specifies which math function should be invoked\n-â”Š27â”Š  â”Š// right after the number has been trimmed.\n-â”Š28â”Š  â”Š// e.g. 12.12345.trim(3, \"ceil\") returns 12.124\n-â”Š29â”Š  â”ŠUtils.trim = function (context, decimals, mode = \"round\") {\n-â”Š30â”Š  â”Š  return Math[mode](context * Math.pow(10, decimals)) / Math.pow(10, decimals);\n-â”Š31â”Š  â”Š};\n-â”Š32â”Š  â”Š\n-â”Š33â”Š  â”Š// Tells if number is in specified range based on given precision.\n-â”Š34â”Š  â”Š// See the \"compare\" method for more information about precision\n-â”Š35â”Š  â”ŠUtils.isBetween = function (context, num1, num2, precision) {\n-â”Š36â”Š  â”Š  return Utils.compare(context, Math.min(num1, num2), \">=\", precision) &&\n-â”Š37â”Š  â”Š         Utils.compare(context, Math.max(num1, num2), \"<=\", precision);\n-â”Š38â”Š  â”Š};\n-â”Š39â”Š  â”Š\n-â”Š40â”Š  â”Š// Initiates comparison operator between context number and a given number, only here\n-â”Š41â”Š  â”Š// a precision can be specified\n-â”Š42â”Š  â”ŠUtils.compare = function (context, num, method, precision = method) {\n-â”Š43â”Š  â”Š  switch (precision) {\n-â”Š44â”Š  â”Š    // Fixed precision, \"almost equal\" with a deviation of Îµ\n-â”Š45â”Š  â”Š    case \"f\":\n-â”Š46â”Š  â”Š      switch (method) {\n-â”Š47â”Š  â”Š        case \"<\": case \"<=\": return context <= num + Number.EPSILON;\n-â”Š48â”Š  â”Š        case \">\": case \">=\": return context >= num - Number.EPSILON;\n-â”Š49â”Š  â”Š        default: return Math.abs(context - num) <= Number.EPSILON;\n-â”Š50â”Š  â”Š      }\n-â”Š51â”Š  â”Š    // Pixel precision, round comparison\n-â”Š52â”Š  â”Š    case \"px\":\n-â”Š53â”Š  â”Š      switch (method) {\n-â”Š54â”Š  â”Š        case \"<\": case \"<=\": return Math.round(context) <= Math.round(num);\n-â”Š55â”Š  â”Š        case \">\": case \">=\": return Math.round(context) >= Math.round(num);\n-â”Š56â”Š  â”Š        default: return Math.round(context) == Math.round(num);\n-â”Š57â”Š  â”Š      }\n-â”Š58â”Š  â”Š    // Exact precision\n-â”Š59â”Š  â”Š    default:\n-â”Š60â”Š  â”Š      switch (method) {\n-â”Š61â”Š  â”Š        case \"<\": return context < num;\n-â”Š62â”Š  â”Š        case \"<=\": return context <= num;\n-â”Š63â”Š  â”Š        case \">\": return context > num;\n-â”Š64â”Š  â”Š        case \">=\": return context >= num;\n-â”Š65â”Š  â”Š        default: return context === num;\n-â”Š66â”Š  â”Š      }\n+â”Š  â”Š19â”ŠObject.assign(Utils, CPP.Utils, {\n+â”Š  â”Š20â”Š  // Overload handling\n+â”Š  â”Š21â”Š  compare(context, num, method, precision = method) {\n+â”Š  â”Š22â”Š    return CPP.Utils.compare(context, num, method, precision);\n â”Š67â”Š23â”Š  }\n-â”Š68â”Š  â”Š};ðŸš«â†µ\n+â”Š  â”Š24â”Š});ðŸš«â†µ\n```\n\n[}]: #\n\nTo compile our C++ code and turn it into JavaScript, we'll need to run the following command:\n\n    $ emcc -O1 --pre-js resources/cpp/pre.js --post-js resources/cpp/post.js --bind -o resources/scripts/cpp.bundle.js resources/cpp/src/index.cpp\n\nHere's a detailed list with explanations regards the arguments vector we've just passed:\n\n- `-01` - Optimization level 1. The higher the index, the more optimized our code is gonna be, but less readable.\n- `--pre-js` - Specifies a JavaScript prefix for the compiled code.\n- `--post-js` - Specifies a JavaScript postfix for the compiled code.\n- `--bind` - Tells the compiler to use Embind\n- `-o` - The output path.\n\n> More informations regards Emscripten's CLI can be found [here](https://kripken.github.io/emscripten-site/docs/tools_reference/emcc.html).\n\nYou don't have to memorize the compilation command we've just typed, because we're gonna save it as an NPM script called `build:cpp`:\n\n[{]: <helper> (diffStep 7.6)\n\n#### [Step 7.6: Add ignore rule to CPP bundle](https://github.com/DAB0mB/radial-snake/commit/f4a75cf)\n\n##### Changed .gitignore\n```diff\n@@ -1,3 +1,4 @@\n â”Š1â”Š1â”Šnode_modules\n â”Š2â”Š2â”Šnpm-debug.log\n-â”Š3â”Š â”Šresources/assets/fonts/*.jsonðŸš«â†µ\n+â”Š â”Š3â”Šresources/assets/fonts/*.json\n+â”Š â”Š4â”Šresources/scripts/cpp.bundle.jsðŸš«â†µ\n```\n\n[}]: #\n\nNow if you'd like to compile the C++ code just run:\n\n    $ npm run build:cpp\n\nMoreover, the code should be compiled automatically any time you start the serer using the command:\n\n    $ npm run serve\n\nWe always have to be on the alert and run our tests against modules we've just translated from JavaScript to C++. This will guarantee that once we run the game we won't stumble upon any defect whatsoever. Before running the tests, be sure to import the C++ bundle in the HTML file's header:\n\n[{]: <helper> (diffStep 7.8)\n\n#### [Step 7.8: Load CPP bundle in spec runner](https://github.com/DAB0mB/radial-snake/commit/0d1bd08)\n\n##### Changed views&#x2F;spec_runner.html\n```diff\n@@ -16,6 +16,7 @@\n â”Š16â”Š16â”Š    <script type=\"text/javascript\" src=\"libs/underscore.js\"></script>\n â”Š17â”Š17â”Š\n â”Š18â”Š18â”Š    <!-- Scripts -->\n+â”Š  â”Š19â”Š    <script type=\"text/javascript\" src=\"scripts/cpp.bundle.js\"></script>\n â”Š19â”Š20â”Š    <script type=\"text/javascript\" src=\"scripts/utils.js\"></script>\n â”Š20â”Š21â”Š    <script type=\"text/javascript\" src=\"scripts/namespaces.js\"></script>\n â”Š21â”Š22â”Š    <script type=\"text/javascript\" src=\"scripts/engine/geometry/line.js\"></script>\n```\n\n[}]: #\n\nNow we can run the tests by running the following command:\n\n    $ npm run test\n\nAt this point **all our tests should pass**. If they don't, it means our newly created utility module is not working properly, and you will have to repeat the previous steps until you get it right.\n\nUp next, we gonna translate the geometry line class to C++. Since it's gonna be translated almost identically, we will have to make sure that all the necessary assets are gonna be available for our class before proceeding. The first thing we will have to do would be making sure that the utility functions are chainable directly from C++ as well. To do that, we will create a chain class which should return a new instance of it whenever we're about to chain the upcoming utility method. Once calling `result()`, the accumulator should be returned:\n\n[{]: <helper> (diffStep 7.9)\n\n#### [Step 7.9: Add chaining method to CPP utils](https://github.com/DAB0mB/radial-snake/commit/0927eea)\n\n##### Changed resources&#x2F;cpp&#x2F;src&#x2F;utils.cpp\n```diff\n@@ -5,6 +5,61 @@\n â”Š 5â”Š 5â”Š#include \"utils.h\"\n â”Š 6â”Š 6â”Š\n â”Š 7â”Š 7â”Šnamespace utils {\n+â”Š  â”Š 8â”Š  template<typename T>\n+â”Š  â”Š 9â”Š  Chain<T>::Chain(T accumulator): _accumulator(accumulator) {\n+â”Š  â”Š10â”Š  }\n+â”Š  â”Š11â”Š\n+â”Š  â”Š12â”Š  template<>\n+â”Š  â”Š13â”Š  Chain<double>* Chain<double>::mod(double num) {\n+â”Š  â”Š14â”Š    double result = utils::mod(_accumulator, num);\n+â”Š  â”Š15â”Š    Chain<double>* chain = new Chain<double>(result);\n+â”Š  â”Š16â”Š    delete this;\n+â”Š  â”Š17â”Š    return chain;\n+â”Š  â”Š18â”Š  }\n+â”Š  â”Š19â”Š\n+â”Š  â”Š20â”Š  template<>\n+â”Š  â”Š21â”Š  Chain<double>* Chain<double>::trim(int decimals, const std::string mode) {\n+â”Š  â”Š22â”Š    double result = utils::trim(_accumulator, decimals, mode);\n+â”Š  â”Š23â”Š    Chain<double>* chain = new Chain<double>(result);\n+â”Š  â”Š24â”Š    delete this;\n+â”Š  â”Š25â”Š    return chain;\n+â”Š  â”Š26â”Š  }\n+â”Š  â”Š27â”Š\n+â”Š  â”Š28â”Š  template<>\n+â”Š  â”Š29â”Š  Chain<bool>* Chain<double>::isBetween(double num1, double num2, const std::string precision) {\n+â”Š  â”Š30â”Š    bool result = utils::isBetween(_accumulator, num1, num2, precision);\n+â”Š  â”Š31â”Š    Chain<bool>* chain = new Chain<bool>(result);\n+â”Š  â”Š32â”Š    delete this;\n+â”Š  â”Š33â”Š    return chain;\n+â”Š  â”Š34â”Š  }\n+â”Š  â”Š35â”Š\n+â”Š  â”Š36â”Š  template<>\n+â”Š  â”Š37â”Š  Chain<bool>* Chain<double>::compare(double num, const std::string precision) {\n+â”Š  â”Š38â”Š    bool result = utils::compare(_accumulator, num, precision);\n+â”Š  â”Š39â”Š    Chain<bool>* chain = new Chain<bool>(result);\n+â”Š  â”Š40â”Š    delete this;\n+â”Š  â”Š41â”Š    return chain;\n+â”Š  â”Š42â”Š  }\n+â”Š  â”Š43â”Š\n+â”Š  â”Š44â”Š  template<>\n+â”Š  â”Š45â”Š  Chain<bool>* Chain<double>::compare(double num, const std::string method, const std::string precision) {\n+â”Š  â”Š46â”Š    bool result = utils::compare(_accumulator, num, method, precision);\n+â”Š  â”Š47â”Š    Chain<bool>* chain = new Chain<bool>(result);\n+â”Š  â”Š48â”Š    delete this;\n+â”Š  â”Š49â”Š    return chain;\n+â”Š  â”Š50â”Š  }\n+â”Š  â”Š51â”Š\n+â”Š  â”Š52â”Š  template<typename T>\n+â”Š  â”Š53â”Š  T Chain<T>::result() {\n+â”Š  â”Š54â”Š    delete this;\n+â”Š  â”Š55â”Š    return _accumulator;\n+â”Š  â”Š56â”Š  }\n+â”Š  â”Š57â”Š\n+â”Š  â”Š58â”Š  template<typename T>\n+â”Š  â”Š59â”Š  Chain<T>* chain(T accumulator) {\n+â”Š  â”Š60â”Š    return new Chain<T>(accumulator);\n+â”Š  â”Š61â”Š  }\n+â”Š  â”Š62â”Š\n â”Š 8â”Š63â”Š  // Fixed modulo method which can calculate modulo of negative numbers properly\n â”Š 9â”Š64â”Š  // e.g. (-803).mod(800) returns 797\n â”Š10â”Š65â”Š  double mod(double context, double num) {\n```\n\n##### Changed resources&#x2F;cpp&#x2F;src&#x2F;utils.h\n```diff\n@@ -3,6 +3,30 @@\n â”Š 3â”Š 3â”Š#include <string>\n â”Š 4â”Š 4â”Š\n â”Š 5â”Š 5â”Šnamespace utils {\n+â”Š  â”Š 6â”Š  template<typename T>\n+â”Š  â”Š 7â”Š  class Chain {\n+â”Š  â”Š 8â”Š  private:\n+â”Š  â”Š 9â”Š    T _accumulator;\n+â”Š  â”Š10â”Š\n+â”Š  â”Š11â”Š  public:\n+â”Š  â”Š12â”Š    Chain(T accumulator);\n+â”Š  â”Š13â”Š\n+â”Š  â”Š14â”Š    Chain<double>* mod(double num);\n+â”Š  â”Š15â”Š\n+â”Š  â”Š16â”Š    Chain<double>* trim(int decimals, const std::string mode = \"round\");\n+â”Š  â”Š17â”Š\n+â”Š  â”Š18â”Š    Chain<bool>* isBetween(double num1, double num2, const std::string precision = \"exact\");\n+â”Š  â”Š19â”Š\n+â”Š  â”Š20â”Š    Chain<bool>* compare(double num, const std::string precision = \"exact\");\n+â”Š  â”Š21â”Š\n+â”Š  â”Š22â”Š    Chain<bool>* compare(double num, const std::string method, const std::string precision);\n+â”Š  â”Š23â”Š\n+â”Š  â”Š24â”Š    T result();\n+â”Š  â”Š25â”Š  };\n+â”Š  â”Š26â”Š\n+â”Š  â”Š27â”Š  template<typename T>\n+â”Š  â”Š28â”Š  Chain<T>* chain(T accumulator);\n+â”Š  â”Š29â”Š\n â”Š 6â”Š30â”Š  double mod(double context, double num);\n â”Š 7â”Š31â”Š\n â”Š 8â”Š32â”Š  double trim(double context, int decimals, const std::string mode = \"round\");\n```\n\n[}]: #\n\n> Note that when coding in C++ we have to make sure that the objects are being disposed when not needed anymore, otherwise we will have some unnecessary memory leaks.\n\n2D shapes are presented in space using points with 2 values - `x` (axis) and `y` axis, therefore, we will create the appropriate point structure:\n\n[{]: <helper> (diffStep 7.1)\n\n#### [Step 7.1: Add CPP entry script](https://github.com/DAB0mB/radial-snake/commit/2f35323)\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;index.cpp\n```diff\n@@ -0,0 +1 @@\n+â”Š â”Š1â”Š#include \"utils.cpp\"ðŸš«â†µ\n```\n\n[}]: #\n\nReturned values can either be `null` (`undefined`) or not. Since there's no built in nullable-values mechanism in C++ (up until C++17), we're gonna create one of our own:\n\n[{]: <helper> (diffStep 7.11)\n\n#### [Step 7.11: Add nullable class](https://github.com/DAB0mB/radial-snake/commit/41b2f7c)\n\n##### Changed resources&#x2F;cpp&#x2F;src&#x2F;index.cpp\n```diff\n@@ -1 +1,2 @@\n+â”Š â”Š1â”Š#include \"nullable.cpp\"\n â”Š1â”Š2â”Š#include \"utils.cpp\"ðŸš«â†µ\n```\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;nullable.cpp\n```diff\n@@ -0,0 +1,37 @@\n+â”Š  â”Š 1â”Š#include \"nullable.h\"\n+â”Š  â”Š 2â”Š\n+â”Š  â”Š 3â”Štemplate <typename T>\n+â”Š  â”Š 4â”ŠNullable<T>::Nullable(T value): _value(value), _initialized(true) {\n+â”Š  â”Š 5â”Š\n+â”Š  â”Š 6â”Š}\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Štemplate <typename T>\n+â”Š  â”Š 9â”ŠNullable<T>::Nullable(): _initialized(false) {\n+â”Š  â”Š10â”Š\n+â”Š  â”Š11â”Š}\n+â”Š  â”Š12â”Š\n+â”Š  â”Š13â”Štemplate <typename T>\n+â”Š  â”Š14â”ŠT Nullable<T>::getValue() const {\n+â”Š  â”Š15â”Š  return _value;\n+â”Š  â”Š16â”Š}\n+â”Š  â”Š17â”Š\n+â”Š  â”Š18â”Štemplate <typename T>\n+â”Š  â”Š19â”Švoid Nullable<T>::setValue(T value) {\n+â”Š  â”Š20â”Š  _value = value;\n+â”Š  â”Š21â”Š  _initialized = true;\n+â”Š  â”Š22â”Š}\n+â”Š  â”Š23â”Š\n+â”Š  â”Š24â”Štemplate <typename T>\n+â”Š  â”Š25â”Švoid Nullable<T>::resetValue() {\n+â”Š  â”Š26â”Š  _initialized = false;\n+â”Š  â”Š27â”Š}\n+â”Š  â”Š28â”Š\n+â”Š  â”Š29â”Štemplate <typename T>\n+â”Š  â”Š30â”Šbool Nullable<T>::hasValue() const {\n+â”Š  â”Š31â”Š  return _initialized == true;\n+â”Š  â”Š32â”Š}\n+â”Š  â”Š33â”Š\n+â”Š  â”Š34â”Štemplate <typename T>\n+â”Š  â”Š35â”Šbool Nullable<T>::isNull() const {\n+â”Š  â”Š36â”Š  return _initialized == false;\n+â”Š  â”Š37â”Š}ðŸš«â†µ\n```\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;nullable.h\n```diff\n@@ -0,0 +1,23 @@\n+â”Š  â”Š 1â”Š#pragma once\n+â”Š  â”Š 2â”Š\n+â”Š  â”Š 3â”Štemplate <typename T>\n+â”Š  â”Š 4â”Šclass Nullable {\n+â”Š  â”Š 5â”Šprivate:\n+â”Š  â”Š 6â”Š  T _value;\n+â”Š  â”Š 7â”Š  bool _initialized;\n+â”Š  â”Š 8â”Š\n+â”Š  â”Š 9â”Špublic:\n+â”Š  â”Š10â”Š  Nullable(T value);\n+â”Š  â”Š11â”Š\n+â”Š  â”Š12â”Š  Nullable();\n+â”Š  â”Š13â”Š\n+â”Š  â”Š14â”Š  T getValue() const;\n+â”Š  â”Š15â”Š\n+â”Š  â”Š16â”Š  void setValue(T value);\n+â”Š  â”Š17â”Š\n+â”Š  â”Š18â”Š  void resetValue();\n+â”Š  â”Š19â”Š\n+â”Š  â”Š20â”Š  bool hasValue() const;\n+â”Š  â”Š21â”Š\n+â”Š  â”Š22â”Š  bool isNull() const;\n+â”Š  â”Š23â”Š};ðŸš«â†µ\n```\n\n[}]: #\n\nNow that all the necessary assets for the line class are ready, we can go ahead and create it:\n\n[{]: <helper> (diffStep 7.12)\n\n#### [Step 7.12: Add base line CPP module](https://github.com/DAB0mB/radial-snake/commit/9d17554)\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;geometry&#x2F;line.cpp\n```diff\n@@ -0,0 +1,99 @@\n+â”Š  â”Š 1â”Š#include \"../nullable.h\"\n+â”Š  â”Š 2â”Š#include \"../utils.h\"\n+â”Š  â”Š 3â”Š#include \"point.h\"\n+â”Š  â”Š 4â”Š#include \"line.h\"\n+â”Š  â”Š 5â”Š\n+â”Š  â”Š 6â”Šnamespace geometry {\n+â”Š  â”Š 7â”Š  // x1 - The first point's x value\n+â”Š  â”Š 8â”Š  // y1 - The first point's y value\n+â”Š  â”Š 9â”Š  // x1 - The second point's x value\n+â”Š  â”Š10â”Š  // y2 - The second point's y value\n+â”Š  â”Š11â”Š  Line::Line(double x1, double y1, double x2, double y2) {\n+â”Š  â”Š12â”Š    _x1 = utils::trim(x1, 9);\n+â”Š  â”Š13â”Š    _y1 = utils::trim(y1, 9);\n+â”Š  â”Š14â”Š    _x2 = utils::trim(x2, 9);\n+â”Š  â”Š15â”Š    _y2 = utils::trim(y2, 9);\n+â”Š  â”Š16â”Š  }\n+â”Š  â”Š17â”Š\n+â”Š  â”Š18â”Š  // Gets the matching x value for a given y value\n+â”Š  â”Š19â”Š  Nullable<double> Line::getMatchingX(double y) {\n+â”Š  â”Š20â”Š    // If an error was thrown it means we divided a number by zero,\n+â”Š  â”Š21â”Š    // in which case there is not intersection point\n+â”Š  â”Š22â”Š    double x = utils::trim(\n+â”Š  â”Š23â”Š      (((y - _y1) * (_x2 - _x1)) /\n+â”Š  â”Š24â”Š       (_y2 - _y1)) + _x1\n+â”Š  â”Š25â”Š    , 9, \"exact\");\n+â”Š  â”Š26â”Š\n+â”Š  â”Š27â”Š    // Check if result is in values range\n+â”Š  â”Š28â”Š    if (utils::isBetween(x, _x1, _x2, \"round\")) {\n+â”Š  â”Š29â”Š      return Nullable<double>(x);\n+â”Š  â”Š30â”Š    }\n+â”Š  â”Š31â”Š\n+â”Š  â”Š32â”Š    return Nullable<double>();\n+â”Š  â”Š33â”Š  }\n+â”Š  â”Š34â”Š\n+â”Š  â”Š35â”Š  // Gets the matching y value for a given x value\n+â”Š  â”Š36â”Š  Nullable<double> Line::getMatchingY(double x) {\n+â”Š  â”Š37â”Š    // If an error was thrown it means we divided a number by zero,\n+â”Š  â”Š38â”Š    // in which case there is not intersection point\n+â”Š  â”Š39â”Š    double y = utils::trim(\n+â”Š  â”Š40â”Š      (((x - _x1) * (_y2 - _y1)) /\n+â”Š  â”Š41â”Š       (_x2 - _x1)) + _y1\n+â”Š  â”Š42â”Š    , 9, \"exact\");\n+â”Š  â”Š43â”Š\n+â”Š  â”Š44â”Š    // Check if result is in values range\n+â”Š  â”Š45â”Š    if (utils::isBetween(y, _y1, _y2, \"round\")) {\n+â”Š  â”Š46â”Š      return Nullable<double>(y);\n+â”Š  â”Š47â”Š    }\n+â”Š  â”Š48â”Š\n+â”Š  â”Š49â”Š    return Nullable<double>();\n+â”Š  â”Š50â”Š  }\n+â”Š  â”Š51â”Š\n+â”Š  â”Š52â”Š  // Returns if line has given point\n+â”Š  â”Š53â”Š  bool Line::hasPoint(double x, double y) {\n+â”Š  â”Š54â”Š    if (!boundsHavePoint(x, y)) return 0;\n+â”Š  â”Š55â”Š\n+â”Š  â”Š56â”Š    double m = utils::trim(\n+â”Š  â”Š57â”Š      (_y2 - _y1) / (_x2 - _x1),\n+â”Š  â”Š58â”Š    9, \"exact\");\n+â”Š  â”Š59â”Š\n+â”Š  â”Š60â”Š    return (y - _y1) / (x - _x1) == m;\n+â”Š  â”Š61â”Š  }\n+â”Š  â”Š62â”Š\n+â”Š  â”Š63â”Š  // Returns if given point is contained by the bounds aka cage of line\n+â”Š  â”Š64â”Š  bool Line::boundsHavePoint(double x, double y) {\n+â”Š  â”Š65â”Š    return utils::isBetween(x, _x1, _x2, \"round\") &&\n+â”Š  â”Š66â”Š           utils::isBetween(y, _y1, _y2, \"round\");\n+â”Š  â”Š67â”Š  }\n+â”Š  â”Š68â”Š\n+â”Š  â”Š69â”Š  // line - line intersection method\n+â”Š  â”Š70â”Š  Nullable<Point> Line::getIntersection(Line line) {\n+â”Š  â”Š71â”Š    // Escape if lines are parallel\n+â”Š  â”Š72â”Š    if (!(((_x1 - _x2) * (line._y1 - line._y2)) -\n+â”Š  â”Š73â”Š          ((_y1 - _y2) * (line._x1 - line._x2))))\n+â”Š  â”Š74â”Š      return Nullable<Point>();\n+â”Š  â”Š75â”Š\n+â”Š  â”Š76â”Š    // Intersection point formula\n+â”Š  â”Š77â”Š    double x = utils::trim(\n+â”Š  â”Š78â”Š      ((((_x1 * _y2) - (_y1 * _x2)) * (line._x1 - line._x2)) -\n+â”Š  â”Š79â”Š       ((_x1 - _x2) * ((line._x1 * line._y2) - (line._y1 * line._x2)))) /\n+â”Š  â”Š80â”Š      (((_x1 - _x2) * (line._y1 - line._y2)) - ((_y1 - _y2) *\n+â”Š  â”Š81â”Š        (line._x1 - line._x2)))\n+â”Š  â”Š82â”Š    , 9, \"exact\");\n+â”Š  â”Š83â”Š    double y = utils::trim(\n+â”Š  â”Š84â”Š      ((((_x1 * _y2) - (_y1 * _x2)) * (line._y1 - line._y2)) -\n+â”Š  â”Š85â”Š       ((_y1 - _y2) * ((line._x1 * line._y2) - (line._y1 * line._x2)))) /\n+â”Š  â”Š86â”Š      (((_x1 - _x2) * (line._y1 - line._y2)) - ((_y1 - _y2) *\n+â”Š  â”Š87â”Š        (line._x1 - line._x2)))\n+â”Š  â”Š88â”Š    , 9, \"exact\");\n+â”Š  â”Š89â”Š\n+â”Š  â”Š90â”Š    if (utils::isBetween(x, _x1, _x2, \"round\") &&\n+â”Š  â”Š91â”Š        utils::isBetween(x, line._x1, line._x2, \"round\") &&\n+â”Š  â”Š92â”Š        utils::isBetween(y, _y1, _y2, \"round\") &&\n+â”Š  â”Š93â”Š        utils::isBetween(y, line._y1, line._y2, \"round\")) {\n+â”Š  â”Š94â”Š      return Nullable<Point>({ x, y });\n+â”Š  â”Š95â”Š    }\n+â”Š  â”Š96â”Š\n+â”Š  â”Š97â”Š    return Nullable<Point>();\n+â”Š  â”Š98â”Š  }\n+â”Š  â”Š99â”Š}ðŸš«â†µ\n```\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;geometry&#x2F;line.h\n```diff\n@@ -0,0 +1,30 @@\n+â”Š  â”Š 1â”Š#pragma once\n+â”Š  â”Š 2â”Š\n+â”Š  â”Š 3â”Š#include <vector>\n+â”Š  â”Š 4â”Š#include \"../nullable.h\"\n+â”Š  â”Š 5â”Š#include \"point.h\"\n+â”Š  â”Š 6â”Š\n+â”Š  â”Š 7â”Šnamespace geometry {\n+â”Š  â”Š 8â”Š  class Circle;\n+â”Š  â”Š 9â”Š  class EMCircle;\n+â”Š  â”Š10â”Š\n+â”Š  â”Š11â”Š  class Line {\n+â”Š  â”Š12â”Š  public:\n+â”Š  â”Š13â”Š    double _x1;\n+â”Š  â”Š14â”Š    double _y1;\n+â”Š  â”Š15â”Š    double _x2;\n+â”Š  â”Š16â”Š    double _y2;\n+â”Š  â”Š17â”Š\n+â”Š  â”Š18â”Š    Line(double x1, double y1, double x2, double y2);\n+â”Š  â”Š19â”Š\n+â”Š  â”Š20â”Š    Nullable<double> getMatchingX(double y);\n+â”Š  â”Š21â”Š\n+â”Š  â”Š22â”Š    Nullable<double> getMatchingY(double x);\n+â”Š  â”Š23â”Š\n+â”Š  â”Š24â”Š    bool hasPoint(double x, double y);\n+â”Š  â”Š25â”Š\n+â”Š  â”Š26â”Š    bool boundsHavePoint(double x, double y);\n+â”Š  â”Š27â”Š\n+â”Š  â”Š28â”Š    Nullable<Point> getIntersection(Line line);\n+â”Š  â”Š29â”Š  };\n+â”Š  â”Š30â”Š}ðŸš«â†µ\n```\n\n##### Changed resources&#x2F;cpp&#x2F;src&#x2F;index.cpp\n```diff\n@@ -1,2 +1,3 @@\n â”Š1â”Š1â”Š#include \"nullable.cpp\"\n-â”Š2â”Š â”Š#include \"utils.cpp\"ðŸš«â†µ\n+â”Š â”Š2â”Š#include \"utils.cpp\"\n+â”Š â”Š3â”Š#include \"geometry/line.cpp\"ðŸš«â†µ\n```\n\n[}]: #\n\nAfter creating our C++, we will also need to bind it using EMBind:\n\n[{]: <helper> (diffStep 7.13)\n\n#### [Step 7.13: EMBind CPP line](https://github.com/DAB0mB/radial-snake/commit/8920ddf)\n\n##### Changed resources&#x2F;cpp&#x2F;post.js\n```diff\n@@ -4,6 +4,10 @@\n â”Š 4â”Š 4â”Š    trim: Module.utils_trim,\n â”Š 5â”Š 5â”Š    isBetween: Module.utils_isBetween,\n â”Š 6â”Š 6â”Š    compare: Module.utils_compare\n+â”Š  â”Š 7â”Š  },\n+â”Š  â”Š 8â”Š\n+â”Š  â”Š 9â”Š  Geometry: {\n+â”Š  â”Š10â”Š    Line: Module.geometry_line\n â”Š 7â”Š11â”Š  }\n â”Š 8â”Š12â”Š};\n â”Š 9â”Š13â”Š\n```\n\n##### Changed resources&#x2F;cpp&#x2F;src&#x2F;geometry&#x2F;line.cpp\n```diff\n@@ -1,3 +1,6 @@\n+â”Š â”Š1â”Š#include <vector>\n+â”Š â”Š2â”Š#include <emscripten/bind.h>\n+â”Š â”Š3â”Š#include <emscripten/val.h>\n â”Š1â”Š4â”Š#include \"../nullable.h\"\n â”Š2â”Š5â”Š#include \"../utils.h\"\n â”Š3â”Š6â”Š#include \"point.h\"\n```\n```diff\n@@ -96,4 +99,52 @@\n â”Š 96â”Š 99â”Š\n â”Š 97â”Š100â”Š    return Nullable<Point>();\n â”Š 98â”Š101â”Š  }\n+â”Š   â”Š102â”Š\n+â”Š   â”Š103â”Š  emscripten::val EMLine::getMatchingX(double y) {\n+â”Š   â”Š104â”Š    Nullable<double> nullableX = Line::getMatchingX(y);\n+â”Š   â”Š105â”Š    return nullableX.hasValue() ?\n+â”Š   â”Š106â”Š      emscripten::val(nullableX.getValue()) :\n+â”Š   â”Š107â”Š      emscripten::val::undefined();\n+â”Š   â”Š108â”Š  }\n+â”Š   â”Š109â”Š\n+â”Š   â”Š110â”Š  emscripten::val EMLine::getMatchingY(double x) {\n+â”Š   â”Š111â”Š    Nullable<double> nullableY = Line::getMatchingY(x);\n+â”Š   â”Š112â”Š    return nullableY.hasValue() ?\n+â”Š   â”Š113â”Š      emscripten::val(nullableY.getValue()) :\n+â”Š   â”Š114â”Š      emscripten::val::undefined();\n+â”Š   â”Š115â”Š  }\n+â”Š   â”Š116â”Š\n+â”Š   â”Š117â”Š  emscripten::val EMLine::getIntersection(EMLine emLine) {\n+â”Š   â”Š118â”Š    Line line = Line(emLine._x1, emLine._y1, emLine._x2, emLine._y2);\n+â”Š   â”Š119â”Š    Nullable<Point> nullablePoint = Line::getIntersection(line);\n+â”Š   â”Š120â”Š\n+â”Š   â”Š121â”Š    if (nullablePoint.isNull()) return emscripten::val::undefined();\n+â”Š   â”Š122â”Š\n+â”Š   â”Š123â”Š    Point point = nullablePoint.getValue();\n+â”Š   â”Š124â”Š    emscripten::val emPoint = emscripten::val::object();\n+â”Š   â”Š125â”Š    emPoint.set(\"x\", emscripten::val(point.x));\n+â”Š   â”Š126â”Š    emPoint.set(\"y\", emscripten::val(point.y));\n+â”Š   â”Š127â”Š    return emPoint;\n+â”Š   â”Š128â”Š  }\n+â”Š   â”Š129â”Š}\n+â”Š   â”Š130â”Š\n+â”Š   â”Š131â”ŠEMSCRIPTEN_BINDINGS(geometry_line_module) {\n+â”Š   â”Š132â”Š  emscripten::class_<geometry::Line>(\"geometry_line_base\")\n+â”Š   â”Š133â”Š    .constructor<double, double, double, double>()\n+â”Š   â”Š134â”Š    .property<double>(\"x1\", &geometry::Line::_x1)\n+â”Š   â”Š135â”Š    .property<double>(\"y1\", &geometry::Line::_y1)\n+â”Š   â”Š136â”Š    .property<double>(\"x2\", &geometry::Line::_x2)\n+â”Š   â”Š137â”Š    .property<double>(\"y2\", &geometry::Line::_y2)\n+â”Š   â”Š138â”Š    .function(\"hasPoint\", &geometry::Line::hasPoint)\n+â”Š   â”Š139â”Š    .function(\"boundsHavePoint\", &geometry::Line::boundsHavePoint);\n+â”Š   â”Š140â”Š\n+â”Š   â”Š141â”Š  emscripten::class_<geometry::EMLine, emscripten::base<geometry::Line>>(\"geometry_line\")\n+â”Š   â”Š142â”Š    .constructor<double, double, double, double>()\n+â”Š   â”Š143â”Š    .function(\"getX\", &geometry::EMLine::getMatchingX)\n+â”Š   â”Š144â”Š    .function(\"getY\", &geometry::EMLine::getMatchingY)\n+â”Š   â”Š145â”Š    .function(\"getLineIntersection\",\n+â”Š   â”Š146â”Š      emscripten::select_overload<emscripten::val(geometry::EMLine)>(\n+â”Š   â”Š147â”Š        &geometry::EMLine::getIntersection\n+â”Š   â”Š148â”Š      )\n+â”Š   â”Š149â”Š    );\n â”Š 99â”Š150â”Š}ðŸš«â†µ\n```\n\n##### Changed resources&#x2F;cpp&#x2F;src&#x2F;geometry&#x2F;line.h\n```diff\n@@ -1,6 +1,7 @@\n â”Š1â”Š1â”Š#pragma once\n â”Š2â”Š2â”Š\n â”Š3â”Š3â”Š#include <vector>\n+â”Š â”Š4â”Š#include <emscripten/val.h>\n â”Š4â”Š5â”Š#include \"../nullable.h\"\n â”Š5â”Š6â”Š#include \"point.h\"\n â”Š6â”Š7â”Š\n```\n```diff\n@@ -27,4 +28,15 @@\n â”Š27â”Š28â”Š\n â”Š28â”Š29â”Š    Nullable<Point> getIntersection(Line line);\n â”Š29â”Š30â”Š  };\n+â”Š  â”Š31â”Š\n+â”Š  â”Š32â”Š  class EMLine : public Line {\n+â”Š  â”Š33â”Š  public:\n+â”Š  â”Š34â”Š    using Line::Line;\n+â”Š  â”Š35â”Š\n+â”Š  â”Š36â”Š    emscripten::val getMatchingX(double y);\n+â”Š  â”Š37â”Š\n+â”Š  â”Š38â”Š    emscripten::val getMatchingY(double x);\n+â”Š  â”Š39â”Š\n+â”Š  â”Š40â”Š    emscripten::val getIntersection(EMLine line);\n+â”Š  â”Š41â”Š  };\n â”Š30â”Š42â”Š}ðŸš«â†µ\n```\n\n[}]: #\n\nIn the code snippet above, you can see that we used a special data-type called `val` (`emscripten::val`). `val` means that just like JavaScript, that function can return values that are not necessarily of the same data-type; For instance, the `getMatchingY` function can either return a `number` or `undefined`. If you'll take a look at the `getIntersection(Line)` method you'll notice that instead of returning the raw point structure, I chose to build a JavaScript object using the `object` data type (`emscripten::object`). `object` behaves exactly like a native JavaScript `Object`, and it can save us some precious work of binding which sometimes might be just too much.\n\nIf you'll compare the C++ version of the line class to the JavaScript line class you'll notice that the `draw` and `getIntersection` methods are missing (when we used EMBind we renamed `getIntersection` to `getLineIntersection` because overloadings are forbidden). In addition, Emscripten's API exposes some additional class methods for generated C++ classes, like the `delete` method, which we will shed light on further in this tutorial. Inheritance would be the natural solution for such an issue, unfortunately, generated C++ constructors don't accept indirect instances. For example, if we have a C++ parent class called `Shape` and we have a JavaScript child class called `Line`, we won't be able to initialize a new instance of the `Line` class. Here's a demonstration:\n\n```js\nclass JSLine extends CPPShape {}\nconst line = new JSLine(); // Throws error\n```\n\nThere are 3 ways to implement inheritance when interacting with C++ classes:\n\n- Define an interface when using EMBind. This is the official way but rather complicated, since it requires us to define an extra layer for our wrapper. More information can be found [here](https://kripken.github.io/emscripten-site/docs/porting/connecting_cpp_and_javascript/embind.html#abstract-methods).\n- Extending the prototype of exported C++ classes directly, which is not really an inheritance.\n- Using a proxy class, which is the easiest and cleanest solution of all, but it is not really mentioned anywhere. At the same time, I didn't find any restriction regards that.\n\nWe're gonna use the 3rd method in the list above, because as I said, it's the easiest and cleanest of all. First I will try to explain what I meant by saying \"proxy class\". If you're an intermediate JavaScript developer, you probably know that constructors can be overridden by returning a value explicitly. By doing that, we can actually bypass Emscripten's prohibitions, we can just return the newly created C++ instance and extend it in specific. Proxy classes actually take it a step further by providing a middle-class which will then inject a new link to the prototype chain of the returned instance.\n\n```js\nclass JSLine {\n  constructor() {\n    const line = new CPPShape();\n    return line;\n  }\n}\n\nconst line = new JSLine(); // Legal!\n```\n\n> More information about the code snippet above can be found [here](https://www.bennadel.com/blog/2522-providing-a-return-value-in-a-javascript-constructor.htm).\n\nI believe that as we go through this tutorial, the concept will get much clearer. The utility function of the proxy class should look like so:\n\n[{]: <helper> (diffStep 7.14)\n\n#### [Step 7.14: Add proxy utility method](https://github.com/DAB0mB/radial-snake/commit/06e615e)\n\n##### Changed resources&#x2F;scripts&#x2F;utils.js\n```diff\n@@ -20,5 +20,18 @@\n â”Š20â”Š20â”Š  // Overload handling\n â”Š21â”Š21â”Š  compare(context, num, method, precision = method) {\n â”Š22â”Š22â”Š    return CPP.Utils.compare(context, num, method, precision);\n+â”Š  â”Š23â”Š  },\n+â”Š  â”Š24â”Š\n+â”Š  â”Š25â”Š  proxy(Class) {\n+â”Š  â”Š26â”Š    return class extends Class {\n+â”Š  â”Š27â”Š      constructor() {\n+â”Š  â”Š28â”Š        // Initialize original class\n+â”Š  â”Š29â”Š        let that = new Class(...arguments);\n+â”Š  â”Š30â”Š        // Inject caller's prototype into the prototype chain\n+â”Š  â”Š31â”Š        Object.setPrototypeOf(that, new.target.prototype);\n+â”Š  â”Š32â”Š        // Will original instance will be the substitute for 'this'\n+â”Š  â”Š33â”Š        return that;\n+â”Š  â”Š34â”Š      }\n+â”Š  â”Š35â”Š    }\n â”Š23â”Š36â”Š  }\n â”Š24â”Š37â”Š});ðŸš«â†µ\n```\n\n[}]: #\n\nIf you'll take a look at the following line:\n\n```js\nObject.setPrototypeOf(that, new.target.prototype);\n```\n\nThis is where the magic actually happens! It enables inheritance for explicitly returned objects; This way we can safely extend C++ classes. Accordingly, our new JavaScript line class should look like so:\n\n[{]: <helper> (diffStep 7.15)\n\n#### [Step 7.15: Extend CPP line class](https://github.com/DAB0mB/radial-snake/commit/66acf9d)\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;geometry&#x2F;line.js\n```diff\n@@ -1,46 +1,10 @@\n-â”Š 1â”Š  â”ŠEngine.Geometry.Line = class Line {\n-â”Š 2â”Š  â”Š  // x1 - The first point's x value\n-â”Š 3â”Š  â”Š  // y1 - The first point's y value\n-â”Š 4â”Š  â”Š  // x1 - The second point's x value\n-â”Š 5â”Š  â”Š  // y2 - The second point's y value\n-â”Š 6â”Š  â”Š  constructor(x1, y1, x2, y2) {\n-â”Š 7â”Š  â”Š    this.x1 = Utils.trim(x1, 9);\n-â”Š 8â”Š  â”Š    this.y1 = Utils.trim(y1, 9);\n-â”Š 9â”Š  â”Š    this.x2 = Utils.trim(x2, 9);\n-â”Š10â”Š  â”Š    this.y2 = Utils.trim(y2, 9);\n-â”Š11â”Š  â”Š  }\n-â”Š12â”Š  â”Š\n+â”Š  â”Š 1â”ŠEngine.Geometry.Line = class Line extends Utils.proxy(CPP.Geometry.Line) {\n â”Š13â”Š 2â”Š  // Draws the line on the given context\n â”Š14â”Š 3â”Š  draw(context) {\n â”Š15â”Š 4â”Š    context.moveTo(this.x1, this.y1);\n â”Š16â”Š 5â”Š    context.lineTo(this.x2, this.y2);\n â”Š17â”Š 6â”Š  }\n â”Š18â”Š 7â”Š\n-â”Š19â”Š  â”Š  // Gets the matching x value for a given y value\n-â”Š20â”Š  â”Š  getX(y) {\n-â”Š21â”Š  â”Š    let x = Utils.trim((((y - this.y1) * (this.x2 - this.x1)) / (this.y2 - this.y1)) + this.x1, 9);\n-â”Š22â”Š  â”Š    if (isNaN(x) || Utils.isBetween(x, this.x1, this.x2)) return x;\n-â”Š23â”Š  â”Š  }\n-â”Š24â”Š  â”Š\n-â”Š25â”Š  â”Š  // Gets the matching y value for a given x value\n-â”Š26â”Š  â”Š  getY(x) {\n-â”Š27â”Š  â”Š    let y = Utils.trim((((x - this.x1) * (this.y2 - this.y1)) / (this.x2 - this.x1)) + this.y1, 9);\n-â”Š28â”Š  â”Š    if (isNaN(y) || Utils.isBetween(y, this.y1, this.y2)) return y;\n-â”Š29â”Š  â”Š  }\n-â”Š30â”Š  â”Š\n-â”Š31â”Š  â”Š  // Returns if line has given point\n-â”Š32â”Š  â”Š  hasPoint(x, y) {\n-â”Š33â”Š  â”Š    if (!this.boundsHavePoint(x, y)) return false;\n-â”Š34â”Š  â”Š    let m = Utils.trim((this.y2 - this.y1) / (this.x2 - this.x1), 9);\n-â”Š35â”Š  â”Š    return (y - this.y1) / (x - this.x1) == m;\n-â”Š36â”Š  â”Š  }\n-â”Š37â”Š  â”Š\n-â”Š38â”Š  â”Š  // Returns if given point is contained by the bounds aka cage of line\n-â”Š39â”Š  â”Š  boundsHavePoint(x, y) {\n-â”Š40â”Š  â”Š    return Utils.isBetween(x, this.x1, this.x2) &&\n-â”Š41â”Š  â”Š           Utils.isBetween(y, this.y1, this.y2);\n-â”Š42â”Š  â”Š  }\n-â”Š43â”Š  â”Š\n â”Š44â”Š 8â”Š  getIntersection(shape) {\n â”Š45â”Š 9â”Š    if (shape instanceof Engine.Geometry.Line)\n â”Š46â”Š10â”Š      return this.getLineIntersection(shape);\n```\n```diff\n@@ -50,23 +14,6 @@\n â”Š50â”Š14â”Š      return this.getPolygonIntersection(shape);\n â”Š51â”Š15â”Š  }\n â”Š52â”Š16â”Š\n-â”Š53â”Š  â”Š  // line - line intersection method\n-â”Š54â”Š  â”Š  getLineIntersection(line) {\n-â”Š55â”Š  â”Š    // Escape if lines are parallel\n-â”Š56â”Š  â”Š    if (!(((this.x1 - this.x2) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * (line.x1 - line.x2)))) return;\n-â”Š57â”Š  â”Š\n-â”Š58â”Š  â”Š    // Intersection point formula\n-â”Š59â”Š  â”Š    let x = Utils.trim(((((this.x1 * this.y2) - (this.y1 * this.x2)) * (line.x1 - line.x2)) - ((this.x1 - this.x2) * ((line.x1 * line.y2) - (line.y1 * line.x2)))) /\n-â”Š60â”Š  â”Š        (((this.x1 - this.x2) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * (line.x1 - line.x2))), 9);\n-â”Š61â”Š  â”Š    let y = Utils.trim(((((this.x1 * this.y2) - (this.y1 * this.x2)) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * ((line.x1 * line.y2) - (line.y1 * line.x2)))) /\n-â”Š62â”Š  â”Š        (((this.x1 - this.x2) * (line.y1 - line.y2)) - ((this.y1 - this.y2) * (line.x1 - line.x2))), 9);\n-â”Š63â”Š  â”Š\n-â”Š64â”Š  â”Š    if (Utils.isBetween(x, this.x1, this.x2) && Utils.isBetween(x, line.x1, line.x2) &&\n-â”Š65â”Š  â”Š        Utils.isBetween(y, this.y1, this.y2) && Utils.isBetween(y, line.y1, line.y2)) {\n-â”Š66â”Š  â”Š      return { x, y };\n-â”Š67â”Š  â”Š    }\n-â”Š68â”Š  â”Š  }\n-â”Š69â”Š  â”Š\n â”Š70â”Š17â”Š  // line - circle intersection method\n â”Š71â”Š18â”Š  getCircleIntersection(circle) {\n â”Š72â”Š19â”Š    return circle.getLineIntersection(this);\n```\n\n[}]: #\n\nBy now, our tests should pass. Accept, there is memory leak we need to handle. But you probably ask yourself - \"What memory leak? It's JavaScript man! Have you ever heard of something called garbage collector?!\". Well, this is not the case when compiling C++ code with Emscripten. You see, Emscripten uses asm.js, which is a subset for JavaScript built exactly for these proposes, enabling C++ modules run on the browser. This is how the [WebGL](https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API) project actually started, an almost complete conversion from the famous C++ [OpenGL](https://www.opengl.org/) to JavaScript. Part of what asm.js does, it disables the garbage collector, and instead, it holds raw pointers, just like in C++. Since returned class instances are pointers with unknown lifespans, they need to be disposed manually, using the `delete` method (identical to how we clear memory from the Heap in C++). Let's dispose unused test data by calling the `delete` method as just mentioned:\n\n[{]: <helper> (diffStep 7.16)\n\n#### [Step 7.16: Delete line instances in tests](https://github.com/DAB0mB/radial-snake/commit/f181da4)\n\n##### Changed resources&#x2F;scripts&#x2F;specs&#x2F;engine&#x2F;geometry&#x2F;circle.js\n```diff\n@@ -111,6 +111,8 @@\n â”Š111â”Š111â”Š          { x: 6, y: 1 },\n â”Š112â”Š112â”Š          { x: -4, y: 1 }\n â”Š113â”Š113â”Š        ]);\n+â”Š   â”Š114â”Š\n+â”Š   â”Š115â”Š        line.delete();\n â”Š114â”Š116â”Š      });\n â”Š115â”Š117â”Š    });\n â”Š116â”Š118â”Š\n```\n```diff\n@@ -121,6 +123,8 @@\n â”Š121â”Š123â”Š        expect(this.circle.getLineIntersection(line)).toEqual([\n â”Š122â”Š124â”Š          { x: -4, y: 1 }\n â”Š123â”Š125â”Š        ]);\n+â”Š   â”Š126â”Š\n+â”Š   â”Š127â”Š        line.delete();\n â”Š124â”Š128â”Š      });\n â”Š125â”Š129â”Š    });\n â”Š126â”Š130â”Š\n```\n```diff\n@@ -131,6 +135,8 @@\n â”Š131â”Š135â”Š        expect(this.circle.getLineIntersection(line)).toEqual([\n â”Š132â”Š136â”Š          { x: 1, y: 6 }\n â”Š133â”Š137â”Š        ]);\n+â”Š   â”Š138â”Š\n+â”Š   â”Š139â”Š        line.delete();\n â”Š134â”Š140â”Š      });\n â”Š135â”Š141â”Š    });\n â”Š136â”Š142â”Š\n```\n```diff\n@@ -138,6 +144,7 @@\n â”Š138â”Š144â”Š      it(\"returns nothing\", function() {\n â”Š139â”Š145â”Š        let line = new Engine.Geometry.Line(-10, 10, 10, 10);\n â”Š140â”Š146â”Š        expect(this.circle.getLineIntersection(line)).toBeUndefined();\n+â”Š   â”Š147â”Š        line.delete();\n â”Š141â”Š148â”Š      });\n â”Š142â”Š149â”Š    });\n â”Š143â”Š150â”Š  });\n```\n\n##### Changed resources&#x2F;scripts&#x2F;specs&#x2F;engine&#x2F;geometry&#x2F;line.js\n```diff\n@@ -3,6 +3,10 @@\n â”Š 3â”Š 3â”Š    this.line = new Engine.Geometry.Line(-5, -5, 5, 5);\n â”Š 4â”Š 4â”Š  });\n â”Š 5â”Š 5â”Š\n+â”Š  â”Š 6â”Š  afterEach(function () {\n+â”Š  â”Š 7â”Š    this.line.delete();\n+â”Š  â”Š 8â”Š  });\n+â”Š  â”Š 9â”Š\n â”Š 6â”Š10â”Š  describe(\"getX method\", function() {\n â”Š 7â”Š11â”Š    describe(\"given inranged y\", function() {\n â”Š 8â”Š12â”Š      it(\"returns x\", function() {\n```\n```diff\n@@ -58,6 +62,8 @@\n â”Š58â”Š62â”Š          x: 1,\n â”Š59â”Š63â”Š          y: 1\n â”Š60â”Š64â”Š        });\n+â”Š  â”Š65â”Š\n+â”Š  â”Š66â”Š        line.delete();\n â”Š61â”Š67â”Š      });\n â”Š62â”Š68â”Š    });\n â”Š63â”Š69â”Š\n```\n```diff\n@@ -65,6 +71,7 @@\n â”Š65â”Š71â”Š      it(\"returns nothing\", function() {\n â”Š66â”Š72â”Š        let line = new Engine.Geometry.Line(-5, -6, 5, 4);\n â”Š67â”Š73â”Š        expect(this.line.getLineIntersection(line)).toBeUndefined();\n+â”Š  â”Š74â”Š        line.delete();\n â”Š68â”Š75â”Š      });\n â”Š69â”Š76â”Š    });\n â”Š70â”Š77â”Š\n```\n```diff\n@@ -72,6 +79,7 @@\n â”Š72â”Š79â”Š      it(\"returns nothing\", function() {\n â”Š73â”Š80â”Š        let line = new Engine.Geometry.Line(10, 10, 10, 15);\n â”Š74â”Š81â”Š        expect(this.line.getLineIntersection(line)).toBeUndefined();\n+â”Š  â”Š82â”Š        line.delete();\n â”Š75â”Š83â”Š      });\n â”Š76â”Š84â”Š    });\n â”Š77â”Š85â”Š  });\n```\n\n##### Changed resources&#x2F;scripts&#x2F;specs&#x2F;engine&#x2F;geometry&#x2F;polygon.js\n```diff\n@@ -35,6 +35,8 @@\n â”Š35â”Š35â”Š          { x: 5, y: 4 },\n â”Š36â”Š36â”Š          { x: 0, y: 1 }\n â”Š37â”Š37â”Š        ]);\n+â”Š  â”Š38â”Š\n+â”Š  â”Š39â”Š        line.delete();\n â”Š38â”Š40â”Š      });\n â”Š39â”Š41â”Š    });\n â”Š40â”Š42â”Š\n```\n```diff\n@@ -43,6 +45,8 @@\n â”Š43â”Š45â”Š        let line = new Engine.Geometry.Line(10, 11, 15, 14);\n â”Š44â”Š46â”Š\n â”Š45â”Š47â”Š        expect(this.polygon.getLineIntersection(line)).toBeUndefined();\n+â”Š  â”Š48â”Š\n+â”Š  â”Š49â”Š        line.delete();\n â”Š46â”Š50â”Š      });\n â”Š47â”Š51â”Š    });\n â”Š48â”Š52â”Š  });\n```\n\n[}]: #\n\nSince our game also uses polygons, which is made of an abstract number of lines, its test-data needs to be disposed as well. First, we will add a `delete` method to the polygon class, which will simply go though all its bounds and delete each of its lines:\n\n[{]: <helper> (diffStep 7.17)\n\n#### [Step 7.17: Add polygon deletion method](https://github.com/DAB0mB/radial-snake/commit/1c9447f)\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;geometry&#x2F;polygon.js\n```diff\n@@ -5,6 +5,10 @@\n â”Š 5â”Š 5â”Š    this.bounds = bounds.map(coords => new Engine.Geometry.Line(...coords));\n â”Š 6â”Š 6â”Š  }\n â”Š 7â”Š 7â”Š\n+â”Š  â”Š 8â”Š  delete() {\n+â”Š  â”Š 9â”Š    this.bounds.forEach(bound => bound.delete());\n+â”Š  â”Š10â”Š  }\n+â”Š  â”Š11â”Š\n â”Š 8â”Š12â”Š  // Returns if polygon has given point\n â”Š 9â”Š13â”Š  hasPoint(x, y) {\n â”Š10â”Š14â”Š    // Run check for each bound\n```\n\n[}]: #\n\nNow we can conveniently delete unused polygons in the tests:\n\n[{]: <helper> (diffStep 7.18)\n\n#### [Step 7.18: Delete polygon instances in tests](https://github.com/DAB0mB/radial-snake/commit/48024bc)\n\n##### Changed resources&#x2F;scripts&#x2F;specs&#x2F;engine&#x2F;geometry&#x2F;polygon.js\n```diff\n@@ -8,6 +8,10 @@\n â”Š 8â”Š 8â”Š    );\n â”Š 9â”Š 9â”Š  });\n â”Š10â”Š10â”Š\n+â”Š  â”Š11â”Š  afterEach(function () {\n+â”Š  â”Š12â”Š    this.polygon.delete();\n+â”Š  â”Š13â”Š  });\n+â”Š  â”Š14â”Š\n â”Š11â”Š15â”Š  describe(\"hasPoint method\", function() {\n â”Š12â”Š16â”Š    describe(\"given contained point\", function() {\n â”Š13â”Š17â”Š      it(\"returns true\", function() {\n```\n\n[}]: #\n\nMoving on, we have the circle class to transform. The process is almost the identical to how we transformed the line class, so it's gonna be way easier now. We first start by translating our code from JavaScript to C++:\n\n[{]: <helper> (diffStep 7.19)\n\n#### [Step 7.19: Add base circle CPP module](https://github.com/DAB0mB/radial-snake/commit/1a3fa58)\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;geometry&#x2F;circle.cpp\n```diff\n@@ -0,0 +1,202 @@\n+â”Š   â”Š  1â”Š\n+â”Š   â”Š  2â”Š#include <algorithm>\n+â”Š   â”Š  3â”Š#include <cmath>\n+â”Š   â”Š  4â”Š#include <vector>\n+â”Š   â”Š  5â”Š#include \"../nullable.h\"\n+â”Š   â”Š  6â”Š#include \"../utils.h\"\n+â”Š   â”Š  7â”Š#include \"point.h\"\n+â”Š   â”Š  8â”Š#include \"line.h\"\n+â”Š   â”Š  9â”Š\n+â”Š   â”Š 10â”Šnamespace geometry {\n+â”Š   â”Š 11â”Š  // x - The x value of the circle's center\n+â”Š   â”Š 12â”Š  // y - The y value of the circle's center\n+â”Š   â”Š 13â”Š  // r - The radius of the center\n+â”Š   â”Š 14â”Š  // rad1 - The first radian of the circle, not necessarily its beginning\n+â”Š   â”Š 15â”Š  // rad2 - The second radian of the circle, not necessarily its beginning\n+â”Š   â”Š 16â”Š  Circle::Circle(double x, double y, double r, double rad1, double rad2) {\n+â”Š   â”Š 17â”Š    _x = utils::trim(x, 9);\n+â”Š   â”Š 18â”Š    _y = utils::trim(y, 9);\n+â”Š   â”Š 19â”Š    _r = utils::trim(r, 9);\n+â”Š   â”Š 20â”Š\n+â”Š   â”Š 21â”Š    // Trimming mode is done based on which radian represents the ending and which radian\n+â”Š   â”Š 22â”Š    // represents the ending\n+â”Š   â”Š 23â”Š    if (rad1 > rad2) {\n+â”Š   â”Š 24â”Š      _rad1 = utils::trim(rad1, 9, \"floor\");\n+â”Š   â”Š 25â”Š      _rad2 = utils::trim(rad2, 9, \"ceil\");\n+â”Š   â”Š 26â”Š    }\n+â”Š   â”Š 27â”Š    else {\n+â”Š   â”Š 28â”Š      _rad1 = utils::trim(rad1, 9, \"ceil\");\n+â”Š   â”Š 29â”Š      _rad2 = utils::trim(rad2, 9, \"floor\");\n+â”Š   â”Š 30â”Š    }\n+â”Š   â”Š 31â”Š  }\n+â”Š   â”Š 32â”Š\n+â”Š   â”Š 33â”Š  // Gets the matching x value for the given radian\n+â”Š   â”Š 34â”Š  Nullable<double> Circle::getMatchingX(double rad) {\n+â”Š   â”Š 35â”Š    if (!utils::chain(rad)->trim(9)->isBetween(_rad1, _rad2)->result()) {\n+â”Š   â”Š 36â”Š      return Nullable<double>();\n+â”Š   â”Š 37â”Š    }\n+â”Š   â”Š 38â”Š\n+â”Š   â”Š 39â”Š    return Nullable<double>(utils::trim((_r * std::cos(rad)) + _x, 9));\n+â”Š   â”Š 40â”Š  }\n+â”Š   â”Š 41â”Š\n+â”Š   â”Š 42â”Š  // Gets the matching y value for the given radian\n+â”Š   â”Š 43â”Š  Nullable<double> Circle::getMatchingY(double rad) {\n+â”Š   â”Š 44â”Š    if (!utils::chain(rad)->trim(9)->isBetween(_rad1, _rad2)->result()) {\n+â”Š   â”Š 45â”Š      return Nullable<double>();\n+â”Š   â”Š 46â”Š    }\n+â”Š   â”Š 47â”Š\n+â”Š   â”Š 48â”Š    return Nullable<double>(utils::trim((_r * std::sin(rad)) + _y, 9));\n+â”Š   â”Š 49â”Š  }\n+â”Š   â”Š 50â”Š\n+â”Š   â”Š 51â”Š  // Gets the matching point for the given radian\n+â”Š   â”Š 52â”Š  Nullable<Point> Circle::getMatchingPoint(double rad) {\n+â”Š   â”Š 53â”Š    if (!utils::isBetween(rad, _rad1, _rad2)) {\n+â”Š   â”Š 54â”Š      return Nullable<Point>();\n+â”Š   â”Š 55â”Š    }\n+â”Š   â”Š 56â”Š\n+â”Š   â”Š 57â”Š    return Nullable<Point>({\n+â”Š   â”Š 58â”Š      utils::trim((_r * std::cos(rad)) + _x, 9),\n+â”Š   â”Š 59â”Š      utils::trim((_r * std::sin(rad)) + _y, 9)\n+â”Š   â”Š 60â”Š    });\n+â”Š   â”Š 61â”Š  }\n+â”Š   â”Š 62â”Š\n+â”Š   â”Š 63â”Š  // Gets the matching radian for the given point\n+â”Š   â”Š 64â”Š  Nullable<double> Circle::getMatchingRad(double x, double y) {\n+â”Š   â”Š 65â”Š    double rad = std::atan2(y - _y, x - _x);\n+â”Š   â”Š 66â”Š\n+â”Š   â”Š 67â”Š    // If calculated radian is in circle's radian range, return it\n+â”Š   â”Š 68â”Š    if (!std::isnan(rad) && utils::isBetween(rad, _rad1, _rad2)) {\n+â”Š   â”Š 69â”Š      return Nullable<double>(rad);\n+â”Š   â”Š 70â”Š    }\n+â”Š   â”Š 71â”Š\n+â”Š   â”Š 72â”Š    // The calculated radian can still be in the circle's radian range in case one\n+â”Š   â”Š 73â”Š    // of the radians is greater than 2 PIEs\n+â”Š   â”Š 74â”Š    double greatestRad = std::abs(_rad1) > std::abs(_rad2) ? _rad1 : _rad2;\n+â”Š   â”Š 75â”Š\n+â”Š   â”Š 76â”Š    // Check if the absolute radian is in the circle's radian range\n+â”Š   â”Š 77â”Š    if (utils::chain(rad + (2 * M_PI * std::floor(greatestRad / (2 * M_PI))))\n+â”Š   â”Š 78â”Š        ->trim(9)->isBetween(_rad1, _rad2)->result() ||\n+â”Š   â”Š 79â”Š        utils::chain(rad + (2 * M_PI * std::ceil(greatestRad / (2 * M_PI))))\n+â”Š   â”Š 80â”Š        ->trim(9)->isBetween(_rad1, _rad2)->result()) {\n+â”Š   â”Š 81â”Š      return Nullable<double>(rad);\n+â”Š   â”Š 82â”Š    }\n+â”Š   â”Š 83â”Š\n+â”Š   â”Š 84â”Š    return Nullable<double>();\n+â”Š   â”Š 85â”Š  }\n+â”Š   â”Š 86â”Š\n+â”Š   â”Š 87â”Š  // Returns if circle has given points\n+â”Š   â”Š 88â”Š  bool Circle::hasPoint(double x, double y) {\n+â”Š   â”Š 89â”Š    return getMatchingRad(x, y).hasValue();\n+â”Š   â”Š 90â”Š  }\n+â”Š   â”Š 91â”Š\n+â”Š   â”Š 92â”Š  // circle - circle intersection method\n+â”Š   â”Š 93â”Š  Nullable<std::vector<Point>> Circle::getIntersection(Circle circle) {\n+â”Š   â”Š 94â”Š    double dx = circle._x - _x;\n+â”Š   â”Š 95â”Š    double dy = circle._y - _y;\n+â”Š   â”Š 96â”Š    double d = std::sqrt(std::pow(dx, 2) + std::pow(dy, 2));\n+â”Š   â”Š 97â”Š\n+â”Š   â”Š 98â”Š    if (d > _r + circle._r ||\n+â”Š   â”Š 99â”Š       d < std::abs(_r - circle._r)) {\n+â”Š   â”Š100â”Š      return Nullable<std::vector<Point>>();\n+â”Š   â”Š101â”Š    }\n+â”Š   â”Š102â”Š\n+â”Š   â”Š103â”Š    double a = ((std::pow(_r, 2) - std::pow(circle._r, 2)) + std::pow(d, 2)) / (2 * d);\n+â”Š   â”Š104â”Š    double x = _x + ((dx * a) / d);\n+â”Š   â”Š105â”Š    double y = _y + ((dy * a) / d);\n+â”Š   â”Š106â”Š    double h = std::sqrt(std::pow(_r, 2) - std::pow(a, 2));\n+â”Š   â”Š107â”Š    double rx = (- dy * h) / d;\n+â”Š   â”Š108â”Š    double ry = (dx * h) / d;\n+â”Š   â”Š109â”Š\n+â”Š   â”Š110â”Š    std::vector<Point> interPoints(2);\n+â”Š   â”Š111â”Š    interPoints.at(0).x = x + rx;\n+â”Š   â”Š112â”Š    interPoints.at(0).y = y + ry;\n+â”Š   â”Š113â”Š    interPoints.at(1).x = x - rx;\n+â”Š   â”Š114â”Š    interPoints.at(1).y = y - ry;\n+â”Š   â”Š115â”Š\n+â”Š   â”Š116â”Š    for (unsigned i = 0; i < interPoints.size(); i++) {\n+â”Š   â”Š117â”Š      Point& point = interPoints.at(i);\n+â”Š   â”Š118â”Š      point.x = utils::trim(point.x, 9);\n+â”Š   â”Š119â”Š      point.y = utils::trim(point.y, 9);\n+â”Š   â”Š120â”Š    }\n+â”Š   â”Š121â”Š\n+â”Š   â”Š122â”Š    auto pointsBegin = std::unique(interPoints.begin(), interPoints.end(),\n+â”Š   â”Š123â”Š      [](Point pointA, Point pointB) {\n+â”Š   â”Š124â”Š        return pointA.x == pointB.x && pointA.y == pointB.y;\n+â”Š   â”Š125â”Š      }\n+â”Š   â”Š126â”Š    );\n+â”Š   â”Š127â”Š\n+â”Š   â”Š128â”Š    interPoints.erase(pointsBegin, interPoints.end());\n+â”Š   â”Š129â”Š\n+â”Š   â”Š130â”Š    std::vector<Circle> circles = { *this, circle };\n+â”Š   â”Š131â”Š\n+â”Š   â”Š132â”Š    std::for_each(circles.begin(), circles.end(), [&interPoints](Circle circle) {\n+â”Š   â”Š133â”Š      auto pointsBegin = std::remove_if(interPoints.begin(), interPoints.end(),\n+â”Š   â”Š134â”Š        [&circle](Point point) {\n+â”Š   â”Š135â”Š          return !circle.hasPoint(point.x, point.y);\n+â”Š   â”Š136â”Š        }\n+â”Š   â”Š137â”Š      );\n+â”Š   â”Š138â”Š\n+â”Š   â”Š139â”Š      interPoints.erase(pointsBegin, interPoints.end());\n+â”Š   â”Š140â”Š    });\n+â”Š   â”Š141â”Š\n+â”Š   â”Š142â”Š    if (interPoints.size()) {\n+â”Š   â”Š143â”Š      return Nullable<std::vector<Point>>(interPoints);\n+â”Š   â”Š144â”Š    }\n+â”Š   â”Š145â”Š\n+â”Š   â”Š146â”Š    return Nullable<std::vector<Point>>();\n+â”Š   â”Š147â”Š  }\n+â”Š   â”Š148â”Š\n+â”Š   â”Š149â”Š  // circle - line intersection method\n+â”Š   â”Š150â”Š  Nullable<std::vector<Point>> Circle::getIntersection(Line line) {\n+â”Š   â”Š151â”Š    double x1 = line._x1 - _x;\n+â”Š   â”Š152â”Š    double x2 = line._x2 - _x;\n+â”Š   â”Š153â”Š    double y1 = line._y1 - _y;\n+â”Š   â”Š154â”Š    double y2 = line._y2 - _y;\n+â”Š   â”Š155â”Š    double dx = x2 - x1;\n+â”Š   â”Š156â”Š    double dy = y2 - y1;\n+â”Š   â”Š157â”Š    double d = std::sqrt(std::pow(dx, 2) + std::pow(dy, 2));\n+â”Š   â”Š158â”Š    double h = (x1 * y2) - (x2 * y1);\n+â”Š   â”Š159â”Š    double delta = (std::pow(_r, 2) * std::pow(d, 2)) - std::pow(h, 2);\n+â”Š   â”Š160â”Š\n+â”Š   â”Š161â”Š    if (delta < 0) Nullable<std::vector<Point>>();\n+â”Š   â”Š162â”Š\n+â”Š   â”Š163â”Š    double sign = dy / std::abs(dy); if (std::isnan(sign)) sign = 1;\n+â”Š   â”Š164â”Š    double sqrtx = sign * dx * std::sqrt(delta);\n+â”Š   â”Š165â”Š    double sqrty = std::abs(dy) * std::sqrt(delta);\n+â”Š   â”Š166â”Š\n+â”Š   â”Š167â”Š    std::vector<Point> interPoints(2);\n+â”Š   â”Š168â”Š    interPoints.at(0).x = (((h * dy) + sqrtx) / std::pow(d, 2)) + _x;\n+â”Š   â”Š169â”Š    interPoints.at(0).y = (((-h * dx) + sqrty) / std::pow(d, 2)) + _y;\n+â”Š   â”Š170â”Š    interPoints.at(1).x = (((h * dy) - sqrtx) / std::pow(d, 2)) + _x;\n+â”Š   â”Š171â”Š    interPoints.at(1).y = (((-h * dx) - sqrty) / std::pow(d, 2)) + _y;\n+â”Š   â”Š172â”Š\n+â”Š   â”Š173â”Š    for (unsigned i = 0; i < interPoints.size(); i++) {\n+â”Š   â”Š174â”Š      Point& point = interPoints.at(i);\n+â”Š   â”Š175â”Š      point.x = utils::trim(point.x, 9);\n+â”Š   â”Š176â”Š      point.y = utils::trim(point.y, 9);\n+â”Š   â”Š177â”Š    }\n+â”Š   â”Š178â”Š\n+â”Š   â”Š179â”Š    auto pointsBegin = std::remove_if(interPoints.begin(), interPoints.end(),\n+â”Š   â”Š180â”Š      [this, &line](Point point) {\n+â”Š   â”Š181â”Š        return !hasPoint(point.x, point.y) ||\n+â”Š   â”Š182â”Š          !line.boundsHavePoint(point.x, point.y);\n+â”Š   â”Š183â”Š      }\n+â”Š   â”Š184â”Š    );\n+â”Š   â”Š185â”Š\n+â”Š   â”Š186â”Š    interPoints.erase(pointsBegin, interPoints.end());\n+â”Š   â”Š187â”Š\n+â”Š   â”Š188â”Š    pointsBegin = std::unique(interPoints.begin(), interPoints.end(),\n+â”Š   â”Š189â”Š      [](Point pointA, Point pointB) {\n+â”Š   â”Š190â”Š        return pointA.x == pointB.x && pointA.y == pointB.y;\n+â”Š   â”Š191â”Š      }\n+â”Š   â”Š192â”Š    );\n+â”Š   â”Š193â”Š\n+â”Š   â”Š194â”Š    interPoints.erase(pointsBegin, interPoints.end());\n+â”Š   â”Š195â”Š\n+â”Š   â”Š196â”Š    if (interPoints.size()) {\n+â”Š   â”Š197â”Š      return Nullable<std::vector<Point>>(interPoints);\n+â”Š   â”Š198â”Š    }\n+â”Š   â”Š199â”Š\n+â”Š   â”Š200â”Š    return Nullable<std::vector<Point>>();\n+â”Š   â”Š201â”Š  }\n+â”Š   â”Š202â”Š}ðŸš«â†µ\n```\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;geometry&#x2F;circle.h\n```diff\n@@ -0,0 +1,35 @@\n+â”Š  â”Š 1â”Š#pragma once\n+â”Š  â”Š 2â”Š\n+â”Š  â”Š 3â”Š#include <vector>\n+â”Š  â”Š 4â”Š#include \"../nullable.h\"\n+â”Š  â”Š 5â”Š#include \"point.h\"\n+â”Š  â”Š 6â”Š#include \"line.h\"\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Šnamespace geometry {\n+â”Š  â”Š 9â”Š  class Line;\n+â”Š  â”Š10â”Š\n+â”Š  â”Š11â”Š  class Circle {\n+â”Š  â”Š12â”Š  public:\n+â”Š  â”Š13â”Š    double _x;\n+â”Š  â”Š14â”Š    double _y;\n+â”Š  â”Š15â”Š    double _r;\n+â”Š  â”Š16â”Š    double _rad1;\n+â”Š  â”Š17â”Š    double _rad2;\n+â”Š  â”Š18â”Š\n+â”Š  â”Š19â”Š    Circle(double x, double y, double r, double rad1, double rad2);\n+â”Š  â”Š20â”Š\n+â”Š  â”Š21â”Š    Nullable<double> getMatchingX(double rad);\n+â”Š  â”Š22â”Š\n+â”Š  â”Š23â”Š    Nullable<double> getMatchingY(double rad);\n+â”Š  â”Š24â”Š\n+â”Š  â”Š25â”Š    Nullable<Point> getMatchingPoint(double rad);\n+â”Š  â”Š26â”Š\n+â”Š  â”Š27â”Š    Nullable<double> getMatchingRad(double x, double y);\n+â”Š  â”Š28â”Š\n+â”Š  â”Š29â”Š    bool hasPoint(double x, double y);\n+â”Š  â”Š30â”Š\n+â”Š  â”Š31â”Š    Nullable<std::vector<Point>> getIntersection(Circle circle);\n+â”Š  â”Š32â”Š\n+â”Š  â”Š33â”Š    Nullable<std::vector<Point>> getIntersection(Line line);\n+â”Š  â”Š34â”Š  };\n+â”Š  â”Š35â”Š}ðŸš«â†µ\n```\n\n##### Changed resources&#x2F;cpp&#x2F;src&#x2F;index.cpp\n```diff\n@@ -1,3 +1,4 @@\n â”Š1â”Š1â”Š#include \"nullable.cpp\"\n â”Š2â”Š2â”Š#include \"utils.cpp\"\n-â”Š3â”Š â”Š#include \"geometry/line.cpp\"ðŸš«â†µ\n+â”Š â”Š3â”Š#include \"geometry/line.cpp\"\n+â”Š â”Š4â”Š#include \"geometry/circle.cpp\"ðŸš«â†µ\n```\n\n[}]: #\n\nSecond, we need to wrap our code using EMBind:\n\n[{]: <helper> (diffStep 7.2)\n\n#### [Step 7.2: Add base utility CPP module](https://github.com/DAB0mB/radial-snake/commit/6dba512)\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;utils.cpp\n```diff\n@@ -0,0 +1,73 @@\n+â”Š  â”Š 1â”Š#include <cfloat>\n+â”Š  â”Š 2â”Š#include <cmath>\n+â”Š  â”Š 3â”Š#include <string>\n+â”Š  â”Š 4â”Š#include \"utils.h\"\n+â”Š  â”Š 5â”Š\n+â”Š  â”Š 6â”Šnamespace utils {\n+â”Š  â”Š 7â”Š  // Fixed modulo method which can calculate modulo of negative numbers properly\n+â”Š  â”Š 8â”Š  // e.g. (-803).mod(800) returns 797\n+â”Š  â”Š 9â”Š  double mod(double context, double num) {\n+â”Š  â”Š10â”Š    return std::fmod((std::fmod(context, num) + num), num);\n+â”Š  â”Š11â”Š  }\n+â”Š  â”Š12â”Š\n+â”Š  â”Š13â”Š  // Trims number and leaves the number of decimals specified.\n+â”Š  â”Š14â”Š  // The \"mode\" argument specifies which math function should be invoked\n+â”Š  â”Š15â”Š  // right after the number has been trimmed.\n+â”Š  â”Š16â”Š  // e.g. 12.12345.trim(3, \"ceil\") returns 12.124\n+â”Š  â”Š17â”Š  double trim(double context, int decimals, const std::string mode) {\n+â”Š  â”Š18â”Š    double accumulator = context * std::pow(10, decimals);\n+â”Š  â”Š19â”Š\n+â”Š  â”Š20â”Š    if (mode.compare(\"ceil\") == 0)\n+â”Š  â”Š21â”Š      accumulator = std::ceil(accumulator);\n+â”Š  â”Š22â”Š    else if (mode.compare(\"floor\") == 0)\n+â”Š  â”Š23â”Š      accumulator = std::floor(accumulator);\n+â”Š  â”Š24â”Š    else\n+â”Š  â”Š25â”Š      accumulator = std::round(accumulator);\n+â”Š  â”Š26â”Š\n+â”Š  â”Š27â”Š    return accumulator / std::pow(10, decimals);\n+â”Š  â”Š28â”Š  }\n+â”Š  â”Š29â”Š\n+â”Š  â”Š30â”Š  // Tells if number is in specified range based on given precision.\n+â”Š  â”Š31â”Š  // See the \"compare\" method for more information about precision\n+â”Š  â”Š32â”Š  bool isBetween(double context, double num1, double num2, const std::string precision) {\n+â”Š  â”Š33â”Š    return compare(context, std::min(num1, num2), \">=\", precision) &&\n+â”Š  â”Š34â”Š           compare(context, std::max(num1, num2), \"<=\", precision);\n+â”Š  â”Š35â”Š  }\n+â”Š  â”Š36â”Š\n+â”Š  â”Š37â”Š  bool compare(double context, double num, const std::string precision) {\n+â”Š  â”Š38â”Š    return compare(context, num, \"==\", precision);\n+â”Š  â”Š39â”Š  }\n+â”Š  â”Š40â”Š\n+â”Š  â”Š41â”Š  // Initiates comparison operator between context number and a given number, only here\n+â”Š  â”Š42â”Š  // a precision can be specified\n+â”Š  â”Š43â”Š  bool compare(double context, double num, const std::string method, const std::string precision) {\n+â”Š  â”Š44â”Š    // Fixed precision, \"almost equal\" with a deviation of Îµ\n+â”Š  â”Š45â”Š    if (precision.compare(\"f\") == 0) {\n+â”Š  â”Š46â”Š      if (method.compare(\"<\") == 0 ||\n+â”Š  â”Š47â”Š          method.compare(\"<=\") == 0)\n+â”Š  â”Š48â”Š        return context <= num + DBL_EPSILON;\n+â”Š  â”Š49â”Š      if (method.compare(\">\") == 0 ||\n+â”Š  â”Š50â”Š          method.compare(\">=\") == 0)\n+â”Š  â”Š51â”Š        return context >= num - DBL_EPSILON;\n+â”Š  â”Š52â”Š      return std::abs(context - num) <= DBL_EPSILON;\n+â”Š  â”Š53â”Š    }\n+â”Š  â”Š54â”Š    // Pixel precision, round comparison\n+â”Š  â”Š55â”Š    else if (precision.compare(\"px\") == 0) {\n+â”Š  â”Š56â”Š      if (method.compare(\"<\") == 0 ||\n+â”Š  â”Š57â”Š          method.compare(\"<=\") == 0)\n+â”Š  â”Š58â”Š        return std::round(context) <= std::round(num);\n+â”Š  â”Š59â”Š      if (method.compare(\">\") == 0 ||\n+â”Š  â”Š60â”Š          method.compare(\">=\") == 0)\n+â”Š  â”Š61â”Š        return std::round(context) >= std::round(num);\n+â”Š  â”Š62â”Š      return std::round(context) == std::round(num);\n+â”Š  â”Š63â”Š    }\n+â”Š  â”Š64â”Š    // Exact precision\n+â”Š  â”Š65â”Š    else {\n+â”Š  â”Š66â”Š      if (method.compare(\"<\") == 0) return context < num;\n+â”Š  â”Š67â”Š      if (method.compare(\"<=\") == 0) return context <= num;\n+â”Š  â”Š68â”Š      if (method.compare(\">\") == 0) return context > num;\n+â”Š  â”Š69â”Š      if (method.compare(\">=\") == 0) return context >= num;\n+â”Š  â”Š70â”Š      return context == num;\n+â”Š  â”Š71â”Š    }\n+â”Š  â”Š72â”Š  }\n+â”Š  â”Š73â”Š}ðŸš«â†µ\n```\n\n##### Added resources&#x2F;cpp&#x2F;src&#x2F;utils.h\n```diff\n@@ -0,0 +1,15 @@\n+â”Š  â”Š 1â”Š#pragma once\n+â”Š  â”Š 2â”Š\n+â”Š  â”Š 3â”Š#include <string>\n+â”Š  â”Š 4â”Š\n+â”Š  â”Š 5â”Šnamespace utils {\n+â”Š  â”Š 6â”Š  double mod(double context, double num);\n+â”Š  â”Š 7â”Š\n+â”Š  â”Š 8â”Š  double trim(double context, int decimals, const std::string mode = \"round\");\n+â”Š  â”Š 9â”Š\n+â”Š  â”Š10â”Š  bool isBetween(double context, double num1, double num2, const std::string precision = \"exact\");\n+â”Š  â”Š11â”Š\n+â”Š  â”Š12â”Š  bool compare(double context, double num, const std::string precision = \"exact\");\n+â”Š  â”Š13â”Š\n+â”Š  â”Š14â”Š  bool compare(double context, double num, const std::string method, const std::string precision);\n+â”Š  â”Š15â”Š}ðŸš«â†µ\n```\n\n[}]: #\n\nAnd finally, we will extend the C++ in our JavaScript circle:\n\n[{]: <helper> (diffStep 7.21)\n\n#### [Step 7.21: Extend CPP circle class](https://github.com/DAB0mB/radial-snake/commit/d05cf32)\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;geometry&#x2F;circle.js\n```diff\n@@ -1,83 +1,9 @@\n-â”Š 1â”Š  â”ŠEngine.Geometry.Circle = class Circle {\n-â”Š 2â”Š  â”Š  // x - The x value of the circle's center\n-â”Š 3â”Š  â”Š  // y - The y value of the circle's center\n-â”Š 4â”Š  â”Š  // r - The radius of the center\n-â”Š 5â”Š  â”Š  // rad1 - The first radian of the circle, not necessarily its beginning\n-â”Š 6â”Š  â”Š  // rad2 - The second radian of the circle, not necessarily its beginning\n-â”Š 7â”Š  â”Š  constructor(x, y, r, rad1, rad2) {\n-â”Š 8â”Š  â”Š    this.x = Utils.trim(x, 9);\n-â”Š 9â”Š  â”Š    this.y = Utils.trim(y, 9);\n-â”Š10â”Š  â”Š    this.r = Utils.trim(r, 9);\n-â”Š11â”Š  â”Š\n-â”Š12â”Š  â”Š    // Trimming mode is done based on which radian represents the ending and which radian\n-â”Š13â”Š  â”Š    // represents the ending\n-â”Š14â”Š  â”Š    if (rad1 > rad2) {\n-â”Š15â”Š  â”Š      this.rad1 = Utils.trim(rad1, 9, \"floor\");\n-â”Š16â”Š  â”Š      this.rad2 = Utils.trim(rad2, 9, \"ceil\");\n-â”Š17â”Š  â”Š    }\n-â”Š18â”Š  â”Š    else {\n-â”Š19â”Š  â”Š      this.rad1 = Utils.trim(rad1, 9, \"ceil\");\n-â”Š20â”Š  â”Š      this.rad2 = Utils.trim(rad2, 9, \"floor\");\n-â”Š21â”Š  â”Š    }\n-â”Š22â”Š  â”Š  }\n-â”Š23â”Š  â”Š\n+â”Š  â”Š 1â”ŠEngine.Geometry.Circle = class Circle extends Utils.proxy(CPP.Geometry.Circle) {\n â”Š24â”Š 2â”Š  // Draws the circle on the given context\n â”Š25â”Š 3â”Š  draw(context) {\n â”Š26â”Š 4â”Š    context.arc(this.x, this.y, this.r, this.rad1, this.rad2);\n â”Š27â”Š 5â”Š  }\n â”Š28â”Š 6â”Š\n-â”Š29â”Š  â”Š  // Gets the matching x value for the given radian\n-â”Š30â”Š  â”Š  getX(rad) {\n-â”Š31â”Š  â”Š    if (!Utils(rad).trim(9).isBetween(this.rad1, this.rad2).value()) return;\n-â”Š32â”Š  â”Š    return Utils.trim((this.r * Math.cos(rad)) + this.x, 9);\n-â”Š33â”Š  â”Š  }\n-â”Š34â”Š  â”Š\n-â”Š35â”Š  â”Š  // Gets the matching y value for the given radian\n-â”Š36â”Š  â”Š  getY(rad) {\n-â”Š37â”Š  â”Š    if (!Utils(rad).trim(9).isBetween(this.rad1, this.rad2).value()) return;\n-â”Š38â”Š  â”Š    return Utils.trim((this.r * Math.sin(rad)) + this.y, 9);\n-â”Š39â”Š  â”Š  }\n-â”Š40â”Š  â”Š\n-â”Š41â”Š  â”Š  // Gets the matching point for the given radian\n-â”Š42â”Š  â”Š  getPoint(rad) {\n-â”Š43â”Š  â”Š    if (!Utils.isBetween(rad, this.rad1, this.rad2)) return;\n-â”Š44â”Š  â”Š\n-â”Š45â”Š  â”Š    return {\n-â”Š46â”Š  â”Š      x: Utils.trim((this.r * Math.cos(rad)) + this.x, 9),\n-â”Š47â”Š  â”Š      y: Utils.trim((this.r * Math.sin(rad)) + this.y, 9)\n-â”Š48â”Š  â”Š    };\n-â”Š49â”Š  â”Š  }\n-â”Š50â”Š  â”Š\n-â”Š51â”Š  â”Š  // Gets the matching radian for the given point\n-â”Š52â”Š  â”Š  getRad(x, y) {\n-â”Š53â”Š  â”Š    let rad = Math.atan2(y - this.y, x - this.x);\n-â”Š54â”Š  â”Š\n-â”Š55â”Š  â”Š    // If calculated radian is in circle's radian range, return it\n-â”Š56â”Š  â”Š    if (rad != null && Utils.isBetween(rad, this.rad1, this.rad2)) {\n-â”Š57â”Š  â”Š      return rad;\n-â”Š58â”Š  â”Š    }\n-â”Š59â”Š  â”Š\n-â”Š60â”Š  â”Š    // The calculated radian can still be in the circle's radian range in case one\n-â”Š61â”Š  â”Š    // of the radians is greater than 2 PIEs\n-â”Š62â”Š  â”Š    if (Math.abs(this.rad1) > Math.abs(this.rad2)) {\n-â”Š63â”Š  â”Š      var greatestRad = this.rad1;\n-â”Š64â”Š  â”Š    }\n-â”Š65â”Š  â”Š    else {\n-â”Š66â”Š  â”Š      var greatestRad = this.rad2;\n-â”Š67â”Š  â”Š    }\n-â”Š68â”Š  â”Š\n-â”Š69â”Š  â”Š    // Check if the absolute radian is in the circle's radian range\n-â”Š70â”Š  â”Š    if (Utils(rad + (2 * Math.PI * Math.floor(greatestRad / (2 * Math.PI)))).trim(9).isBetween(this.rad1, this.rad2).value() ||\n-â”Š71â”Š  â”Š        Utils(rad + (2 * Math.PI * Math.ceil(greatestRad / (2 * Math.PI)))).trim(9).isBetween(this.rad1, this.rad2).value()) {\n-â”Š72â”Š  â”Š      return rad;\n-â”Š73â”Š  â”Š    }\n-â”Š74â”Š  â”Š  }\n-â”Š75â”Š  â”Š\n-â”Š76â”Š  â”Š  // Returns if circle has given points\n-â”Š77â”Š  â”Š  hasPoint(x, y) {\n-â”Š78â”Š  â”Š    return this.getRad(x, y) != null;\n-â”Š79â”Š  â”Š  }\n-â”Š80â”Š  â”Š\n â”Š81â”Š 7â”Š  getIntersection(shape) {\n â”Š82â”Š 8â”Š    if (shape instanceof Engine.Geometry.Line)\n â”Š83â”Š 9â”Š      return this.getLineIntersection(shape);\n```\n```diff\n@@ -87,86 +13,6 @@\n â”Š 87â”Š 13â”Š      return this.getPolygonIntersection(shape);\n â”Š 88â”Š 14â”Š  }\n â”Š 89â”Š 15â”Š\n-â”Š 90â”Š   â”Š  // circle - circle intersection method\n-â”Š 91â”Š   â”Š  getCircleIntersection(circle) {\n-â”Š 92â”Š   â”Š    let dx = circle.x - this.x;\n-â”Š 93â”Š   â”Š    let dy = circle.y - this.y;\n-â”Š 94â”Š   â”Š    let d = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\n-â”Š 95â”Š   â”Š\n-â”Š 96â”Š   â”Š    if (d > this.r + circle.r ||\n-â”Š 97â”Š   â”Š       d < Math.abs(this.r - circle.r)) {\n-â”Š 98â”Š   â”Š      return;\n-â”Š 99â”Š   â”Š    }\n-â”Š100â”Š   â”Š\n-â”Š101â”Š   â”Š    let a = ((Math.pow(this.r, 2) - Math.pow(circle.r, 2)) + Math.pow(d, 2)) / (2 * d);\n-â”Š102â”Š   â”Š    let x = this.x + ((dx * a) / d);\n-â”Š103â”Š   â”Š    let y = this.y + ((dy * a) / d);\n-â”Š104â”Š   â”Š    let h = Math.sqrt(Math.pow(this.r, 2) - Math.pow(a, 2));\n-â”Š105â”Š   â”Š    let rx = (- dy * h) / d;\n-â”Š106â”Š   â”Š    let ry = (dx * h) / d;\n-â”Š107â”Š   â”Š\n-â”Š108â”Š   â”Š    let interPoints = [\n-â”Š109â”Š   â”Š      {\n-â”Š110â”Š   â”Š        x: x + rx,\n-â”Š111â”Š   â”Š        y: y + ry\n-â”Š112â”Š   â”Š      },\n-â”Š113â”Š   â”Š      {\n-â”Š114â”Š   â”Š        x: x - rx,\n-â”Š115â”Š   â”Š        y: y - ry\n-â”Š116â”Š   â”Š      }\n-â”Š117â”Š   â”Š    ]\n-â”Š118â”Š   â”Š    .map(point => ({\n-â”Š119â”Š   â”Š        x: Utils.trim(point.x, 9),\n-â”Š120â”Š   â”Š        y: Utils.trim(point.y, 9)\n-â”Š121â”Š   â”Š     }));\n-â”Š122â”Š   â”Š\n-â”Š123â”Š   â”Š    interPoints = _.uniq(interPoints, point => `(${point.x}, ${point.y})`);\n-â”Š124â”Š   â”Š\n-â”Š125â”Š   â”Š    [this, circle].forEach(function(circle) {\n-â”Š126â”Š   â”Š      interPoints = interPoints.filter(point => circle.hasPoint(point.x, point.y));\n-â”Š127â”Š   â”Š    });\n-â”Š128â”Š   â”Š\n-â”Š129â”Š   â”Š    if (interPoints.length > 0) return interPoints;\n-â”Š130â”Š   â”Š  }\n-â”Š131â”Š   â”Š\n-â”Š132â”Š   â”Š  // circle - line intersection method\n-â”Š133â”Š   â”Š  getLineIntersection(line) {\n-â”Š134â”Š   â”Š    let x1 = line.x1 - this.x;\n-â”Š135â”Š   â”Š    let x2 = line.x2 - this.x;\n-â”Š136â”Š   â”Š    let y1 = line.y1 - this.y;\n-â”Š137â”Š   â”Š    let y2 = line.y2 - this.y;\n-â”Š138â”Š   â”Š    let dx = x2 - x1;\n-â”Š139â”Š   â”Š    let dy = y2 - y1;\n-â”Š140â”Š   â”Š    let d = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\n-â”Š141â”Š   â”Š    let h = (x1 * y2) - (x2 * y1);\n-â”Š142â”Š   â”Š    let delta = (Math.pow(this.r, 2) * Math.pow(d, 2)) - Math.pow(h, 2);\n-â”Š143â”Š   â”Š\n-â”Š144â”Š   â”Š    if (delta < 0) return;\n-â”Š145â”Š   â”Š\n-â”Š146â”Š   â”Š    let interPoints = [\n-â”Š147â”Š   â”Š      {\n-â”Š148â”Š   â”Š        x: (((h * dy) + (((dy / Math.abs(dy)) || 1) * dx * Math.sqrt(delta))) / Math.pow(d, 2)) + this.x,\n-â”Š149â”Š   â”Š        y: (((-h * dx) + (Math.abs(dy) * Math.sqrt(delta))) / Math.pow(d, 2)) + this.y\n-â”Š150â”Š   â”Š      },\n-â”Š151â”Š   â”Š      {\n-â”Š152â”Š   â”Š        x: (((h * dy) - (((dy / Math.abs(dy)) || 1) * dx * Math.sqrt(delta))) / Math.pow(d, 2)) + this.x,\n-â”Š153â”Š   â”Š        y: (((-h * dx) - (Math.abs(dy) * Math.sqrt(delta))) / Math.pow(d, 2)) + this.y\n-â”Š154â”Š   â”Š      }\n-â”Š155â”Š   â”Š    ]\n-â”Š156â”Š   â”Š    .map(point => ({\n-â”Š157â”Š   â”Š        x: Utils.trim(point.x, 9),\n-â”Š158â”Š   â”Š        y: Utils.trim(point.y, 9)\n-â”Š159â”Š   â”Š    }))\n-â”Š160â”Š   â”Š    .filter(point => {\n-â”Š161â”Š   â”Š      return this.hasPoint(point.x, point.y) &&\n-â”Š162â”Š   â”Š        line.boundsHavePoint(point.x, point.y);\n-â”Š163â”Š   â”Š    });\n-â”Š164â”Š   â”Š\n-â”Š165â”Š   â”Š    interPoints = _.uniq(interPoints, point => `(${point.x}, ${point.y})`);\n-â”Š166â”Š   â”Š\n-â”Š167â”Š   â”Š    if (interPoints.length > 0) return interPoints;\n-â”Š168â”Š   â”Š  }\n-â”Š169â”Š   â”Š\n â”Š170â”Š 16â”Š  // circle - polygon intersection method\n â”Š171â”Š 17â”Š  getPolygonIntersection(polygon) {\n â”Š172â”Š 18â”Š    return polygon.getCircleIntersection(this);\n```\n\n[}]: #\n\nWe also need to update the line class to contain a reference to the newly created line-intersection method, so it can be invoked from both a line or a circle bi-directionally:\n\n[{]: <helper> (diffStep 7.22)\n\n#### [Step 7.22: Add line-circle intersection method](https://github.com/DAB0mB/radial-snake/commit/84f5f4d)\n\n##### Changed resources&#x2F;cpp&#x2F;src&#x2F;geometry&#x2F;line.cpp\n```diff\n@@ -4,6 +4,7 @@\n â”Š 4â”Š 4â”Š#include \"../nullable.h\"\n â”Š 5â”Š 5â”Š#include \"../utils.h\"\n â”Š 6â”Š 6â”Š#include \"point.h\"\n+â”Š  â”Š 7â”Š#include \"circle.h\"\n â”Š 7â”Š 8â”Š#include \"line.h\"\n â”Š 8â”Š 9â”Š\n â”Š 9â”Š10â”Šnamespace geometry {\n```\n```diff\n@@ -100,6 +101,11 @@\n â”Š100â”Š101â”Š    return Nullable<Point>();\n â”Š101â”Š102â”Š  }\n â”Š102â”Š103â”Š\n+â”Š   â”Š104â”Š  // circle - circle intersection method\n+â”Š   â”Š105â”Š  Nullable<std::vector<Point>> Line::getIntersection(Circle circle) {\n+â”Š   â”Š106â”Š    return circle.getIntersection(*this);\n+â”Š   â”Š107â”Š  }\n+â”Š   â”Š108â”Š\n â”Š103â”Š109â”Š  emscripten::val EMLine::getMatchingX(double y) {\n â”Š104â”Š110â”Š    Nullable<double> nullableX = Line::getMatchingX(y);\n â”Š105â”Š111â”Š    return nullableX.hasValue() ?\n```\n```diff\n@@ -126,6 +132,10 @@\n â”Š126â”Š132â”Š    emPoint.set(\"y\", emscripten::val(point.y));\n â”Š127â”Š133â”Š    return emPoint;\n â”Š128â”Š134â”Š  }\n+â”Š   â”Š135â”Š\n+â”Š   â”Š136â”Š  emscripten::val EMLine::getIntersection(EMCircle emCircle) {\n+â”Š   â”Š137â”Š    return emCircle.getIntersection(*this);\n+â”Š   â”Š138â”Š  }\n â”Š129â”Š139â”Š}\n â”Š130â”Š140â”Š\n â”Š131â”Š141â”ŠEMSCRIPTEN_BINDINGS(geometry_line_module) {\n```\n```diff\n@@ -146,5 +156,10 @@\n â”Š146â”Š156â”Š      emscripten::select_overload<emscripten::val(geometry::EMLine)>(\n â”Š147â”Š157â”Š        &geometry::EMLine::getIntersection\n â”Š148â”Š158â”Š      )\n+â”Š   â”Š159â”Š    )\n+â”Š   â”Š160â”Š    .function(\"getCircleIntersection\",\n+â”Š   â”Š161â”Š      emscripten::select_overload<emscripten::val(geometry::EMCircle)>(\n+â”Š   â”Š162â”Š        &geometry::EMLine::getIntersection\n+â”Š   â”Š163â”Š      )\n â”Š149â”Š164â”Š    );\n â”Š150â”Š165â”Š}ðŸš«â†µ\n```\n\n##### Changed resources&#x2F;cpp&#x2F;src&#x2F;geometry&#x2F;line.h\n```diff\n@@ -4,6 +4,7 @@\n â”Š 4â”Š 4â”Š#include <emscripten/val.h>\n â”Š 5â”Š 5â”Š#include \"../nullable.h\"\n â”Š 6â”Š 6â”Š#include \"point.h\"\n+â”Š  â”Š 7â”Š#include \"circle.h\"\n â”Š 7â”Š 8â”Š\n â”Š 8â”Š 9â”Šnamespace geometry {\n â”Š 9â”Š10â”Š  class Circle;\n```\n```diff\n@@ -27,6 +28,8 @@\n â”Š27â”Š28â”Š    bool boundsHavePoint(double x, double y);\n â”Š28â”Š29â”Š\n â”Š29â”Š30â”Š    Nullable<Point> getIntersection(Line line);\n+â”Š  â”Š31â”Š\n+â”Š  â”Š32â”Š    Nullable<std::vector<Point>> getIntersection(Circle circle);\n â”Š30â”Š33â”Š  };\n â”Š31â”Š34â”Š\n â”Š32â”Š35â”Š  class EMLine : public Line {\n```\n```diff\n@@ -38,5 +41,7 @@\n â”Š38â”Š41â”Š    emscripten::val getMatchingY(double x);\n â”Š39â”Š42â”Š\n â”Š40â”Š43â”Š    emscripten::val getIntersection(EMLine line);\n+â”Š  â”Š44â”Š\n+â”Š  â”Š45â”Š    emscripten::val getIntersection(EMCircle circle);\n â”Š41â”Š46â”Š  };\n â”Š42â”Š47â”Š}ðŸš«â†µ\n```\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;geometry&#x2F;line.js\n```diff\n@@ -14,11 +14,6 @@\n â”Š14â”Š14â”Š      return this.getPolygonIntersection(shape);\n â”Š15â”Š15â”Š  }\n â”Š16â”Š16â”Š\n-â”Š17â”Š  â”Š  // line - circle intersection method\n-â”Š18â”Š  â”Š  getCircleIntersection(circle) {\n-â”Š19â”Š  â”Š    return circle.getLineIntersection(this);\n-â”Š20â”Š  â”Š  }\n-â”Š21â”Š  â”Š\n â”Š22â”Š17â”Š  // line - polygon intersection method\n â”Š23â”Š18â”Š  getPolygonIntersection(polygon) {\n â”Š24â”Š19â”Š    return polygon.getLineIntersection(this);\n```\n\n[}]: #\n\nNow, before running the tests, be sure to disposed unused circle test-data:\n\n[{]: <helper> (diffStep 7.23)\n\n#### [Step 7.23: Delete circle instances in tests](https://github.com/DAB0mB/radial-snake/commit/e953fae)\n\n##### Changed resources&#x2F;scripts&#x2F;specs&#x2F;engine&#x2F;geometry&#x2F;circle.js\n```diff\n@@ -3,6 +3,10 @@\n â”Š 3â”Š 3â”Š    this.circle = new Engine.Geometry.Circle(1, 1, 5, 0, 1.5 * Math.PI);\n â”Š 4â”Š 4â”Š  });\n â”Š 5â”Š 5â”Š\n+â”Š  â”Š 6â”Š  afterEach(function () {\n+â”Š  â”Š 7â”Š    this.circle.delete();\n+â”Š  â”Š 8â”Š  });\n+â”Š  â”Š 9â”Š\n â”Š 6â”Š10â”Š  describe(\"getX method\", function() {\n â”Š 7â”Š11â”Š    describe(\"given inranged rad\", function() {\n â”Š 8â”Š12â”Š      it(\"returns x\", function() {\n```\n```diff\n@@ -64,6 +68,8 @@\n â”Š64â”Š68â”Š          { x: -2, y: -3 },\n â”Š65â”Š69â”Š          { x: -2, y: 5 }\n â”Š66â”Š70â”Š        ]);\n+â”Š  â”Š71â”Š\n+â”Š  â”Š72â”Š        circle.delete();\n â”Š67â”Š73â”Š      });\n â”Š68â”Š74â”Š    });\n â”Š69â”Š75â”Š\n```\n```diff\n@@ -74,6 +80,8 @@\n â”Š74â”Š80â”Š        expect(this.circle.getCircleIntersection(circle)).toEqual([\n â”Š75â”Š81â”Š          { x: -2, y: 5 }\n â”Š76â”Š82â”Š        ]);\n+â”Š  â”Š83â”Š\n+â”Š  â”Š84â”Š        circle.delete();\n â”Š77â”Š85â”Š      });\n â”Š78â”Š86â”Š    });\n â”Š79â”Š87â”Š\n```\n```diff\n@@ -84,6 +92,8 @@\n â”Š84â”Š92â”Š        expect(this.circle.getCircleIntersection(circle)).toEqual([\n â”Š85â”Š93â”Š          { x: -4, y: 1 }\n â”Š86â”Š94â”Š        ]);\n+â”Š  â”Š95â”Š\n+â”Š  â”Š96â”Š        circle.delete();\n â”Š87â”Š97â”Š      });\n â”Š88â”Š98â”Š    });\n â”Š89â”Š99â”Š\n```\n```diff\n@@ -91,6 +101,7 @@\n â”Š 91â”Š101â”Š      it(\"returns nothing\", function() {\n â”Š 92â”Š102â”Š        let circle = new Engine.Geometry.Circle(10, 10, 2, 0, 2 * Math.PI);\n â”Š 93â”Š103â”Š        expect(this.circle.getCircleIntersection(circle)).toBeUndefined();\n+â”Š   â”Š104â”Š        circle.delete();\n â”Š 94â”Š105â”Š      });\n â”Š 95â”Š106â”Š    });\n â”Š 96â”Š107â”Š\n```\n```diff\n@@ -98,6 +109,7 @@\n â”Š 98â”Š109â”Š      it(\"nothing\", function() {\n â”Š 99â”Š110â”Š        let circle = new Engine.Geometry.Circle(1, 1, 2, 0, 2 * Math.PI);\n â”Š100â”Š111â”Š        expect(this.circle.getCircleIntersection(circle)).toBeUndefined();\n+â”Š   â”Š112â”Š        circle.delete();\n â”Š101â”Š113â”Š      });\n â”Š102â”Š114â”Š    });\n â”Š103â”Š115â”Š  });\n```\n\n##### Changed resources&#x2F;scripts&#x2F;specs&#x2F;engine&#x2F;geometry&#x2F;polygon.js\n```diff\n@@ -64,6 +64,8 @@\n â”Š64â”Š64â”Š          { x: 2, y: 0 },\n â”Š65â”Š65â”Š          { x: 0, y: 2 }\n â”Š66â”Š66â”Š        ]);\n+â”Š  â”Š67â”Š\n+â”Š  â”Š68â”Š        circle.delete();\n â”Š67â”Š69â”Š      });\n â”Š68â”Š70â”Š    });\n â”Š69â”Š71â”Š\n```\n```diff\n@@ -74,6 +76,8 @@\n â”Š74â”Š76â”Š        expect(this.polygon.getCircleIntersection(circle)).toEqual([\n â”Š75â”Š77â”Š          { x: 2, y: 0 }\n â”Š76â”Š78â”Š        ]);\n+â”Š  â”Š79â”Š\n+â”Š  â”Š80â”Š        circle.delete();\n â”Š77â”Š81â”Š      });\n â”Š78â”Š82â”Š    });\n â”Š79â”Š83â”Š\n```\n```diff\n@@ -84,6 +88,8 @@\n â”Š84â”Š88â”Š        expect(this.polygon.getCircleIntersection(circle)).toEqual([\n â”Š85â”Š89â”Š          { x: 0, y: 3 }\n â”Š86â”Š90â”Š        ]);\n+â”Š  â”Š91â”Š\n+â”Š  â”Š92â”Š        circle.delete();\n â”Š87â”Š93â”Š      });\n â”Š88â”Š94â”Š    });\n â”Š89â”Š95â”Š\n```\n```diff\n@@ -91,6 +97,7 @@\n â”Š 91â”Š 97â”Š      it(\"returns nothing\", function() {\n â”Š 92â”Š 98â”Š        let circle = new Engine.Geometry.Circle(10, 10, 2, 0, 2 * Math.PI);\n â”Š 93â”Š 99â”Š        expect(this.polygon.getCircleIntersection(circle)).toBeUndefined();\n+â”Š   â”Š100â”Š        circle.delete();\n â”Š 94â”Š101â”Š      });\n â”Š 95â”Š102â”Š    });\n â”Š 96â”Š103â”Š\n```\n```diff\n@@ -98,6 +105,7 @@\n â”Š 98â”Š105â”Š      it(\"nothing\", function() {\n â”Š 99â”Š106â”Š        let circle = new Engine.Geometry.Circle(2.5, 2.5, 2, 0, 2 * Math.PI);\n â”Š100â”Š107â”Š        expect(this.polygon.getCircleIntersection(circle)).toBeUndefined();\n+â”Š   â”Š108â”Š        circle.delete();\n â”Š101â”Š109â”Š      });\n â”Š102â”Š110â”Š    });\n â”Š103â”Š111â”Š  });\n```\n\n[}]: #\n\nOur C++ code should be finished now, and all the tests should be passing. The only thing left to do would be applying it to our game. Like any other application, we first need to reference the script file so it can be loaded, in this case, the C++ bundle script:\n\n[{]: <helper> (diffStep 7.24)\n\n#### [Step 7.24: Load CPP bundle in game](https://github.com/DAB0mB/radial-snake/commit/a2c0d46)\n\n##### Changed views&#x2F;game.html\n```diff\n@@ -8,6 +8,7 @@\n â”Š 8â”Š 8â”Š    <script type=\"text/javascript\" src=\"/libs/underscore.js\"></script>\n â”Š 9â”Š 9â”Š\n â”Š10â”Š10â”Š    <!-- Scripts -->\n+â”Š  â”Š11â”Š    <script type=\"text/javascript\" src=\"/scripts/cpp.bundle.js\"></script>\n â”Š11â”Š12â”Š    <script type=\"text/javascript\" src=\"/scripts/utils.js\"></script>\n â”Š12â”Š13â”Š    <script type=\"text/javascript\" src=\"/scripts/namespaces.js\"></script>\n â”Š13â”Š14â”Š    <script type=\"text/javascript\" src=\"/scripts/engine/geometry/line.js\"></script>\n```\n\n[}]: #\n\nAnd now we need to make sure to dispose the geometry shapes correctly so we won't experience any unnecessary memory leaks. Most of our disposals should go to the snake entity, since it's made out of shapes; So we will add a `delete` method to the snake entity and we will dispose it whenever a match is finished:\n\n[{]: <helper> (diffStep 7.25)\n\n#### [Step 7.25: Delete shape instances in game](https://github.com/DAB0mB/radial-snake/commit/ae58323)\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;game.js\n```diff\n@@ -95,6 +95,7 @@\n â”Š 95â”Š 95â”Š  changeScreen(Screen, ...screenArgs) {\n â”Š 96â”Š 96â”Š    // If there is a screen defined, dispose it first\n â”Š 97â”Š 97â”Š    if (this.screen) {\n+â”Š   â”Š 98â”Š      this.screen.delete();\n â”Š 98â”Š 99â”Š      this.unloadScreen();\n â”Š 99â”Š100â”Š      this.screen.disposeEventListeners();\n â”Š100â”Š101â”Š    }\n```\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;layer.js\n```diff\n@@ -23,6 +23,9 @@\n â”Š23â”Š23â”Š    this.canvas = screen.game.canvas;\n â”Š24â”Š24â”Š  }\n â”Š25â”Š25â”Š\n+â”Š  â”Š26â”Š  delete() {\n+â”Š  â”Š27â”Š  }\n+â”Š  â”Š28â”Š\n â”Š26â”Š29â”Š  update(span) {\n â”Š27â”Š30â”Š  }\n â”Š28â”Š31â”Š\n```\n\n##### Changed resources&#x2F;scripts&#x2F;engine&#x2F;screen.js\n```diff\n@@ -28,6 +28,13 @@\n â”Š28â”Š28â”Š    return this;\n â”Š29â”Š29â”Š  }\n â”Š30â”Š30â”Š\n+â”Š  â”Š31â”Š   // Delete all layers. Same as 'unload', only it disposes memory rather than assets\n+â”Š  â”Š32â”Š  delete() {\n+â”Š  â”Š33â”Š    this.layers.forEach(layer => {\n+â”Š  â”Š34â”Š      layer.delete();\n+â”Š  â”Š35â”Š    });\n+â”Š  â”Š36â”Š  }\n+â”Š  â”Š37â”Š\n â”Š31â”Š38â”Š  // Updates each layer\n â”Š32â”Š39â”Š  update(span) {\n â”Š33â”Š40â”Š    this.layers.forEach(layer => {\n```\n```diff\n@@ -61,6 +68,7 @@\n â”Š61â”Š68â”Š  removeLayer(layer) {\n â”Š62â”Š69â”Š    this.layers = _.without(this.layers, layer);\n â”Š63â”Š70â”Š    layer.disposeEventListeners();\n+â”Š  â”Š71â”Š    layer.delete();\n â”Š64â”Š72â”Š  }\n â”Š65â”Š73â”Š\n â”Š66â”Š74â”Š  initEventListeners() {\n```\n\n##### Changed resources&#x2F;scripts&#x2F;game&#x2F;entities&#x2F;snake.js\n```diff\n@@ -31,6 +31,10 @@\n â”Š31â”Š31â”Š    }\n â”Š32â”Š32â”Š  }\n â”Š33â”Š33â”Š\n+â”Š  â”Š34â”Š  delete() {\n+â”Š  â”Š35â”Š    this.shapes.forEach(shape => shape.delete());\n+â”Š  â”Š36â”Š  }\n+â”Š  â”Š37â”Š\n â”Š34â”Š38â”Š  draw(context) {\n â”Š35â”Š39â”Š    // Draw all shapes in the shapes array\n â”Š36â”Š40â”Š    this.shapes.forEach(shape => {\n```\n```diff\n@@ -229,6 +233,8 @@\n â”Š229â”Š233â”Š      [0, height, 0, 0]\n â”Š230â”Š234â”Š    );\n â”Š231â”Š235â”Š\n-â”Š232â”Š   â”Š    return canvasPolygon.getIntersection(this.lastBit);\n+â”Š   â”Š236â”Š    let result = canvasPolygon.getIntersection(this.lastBit);\n+â”Š   â”Š237â”Š    canvasPolygon.delete();\n+â”Š   â”Š238â”Š    return result;\n â”Š233â”Š239â”Š  }\n â”Š234â”Š240â”Š};ðŸš«â†µ\n```\n\n##### Changed resources&#x2F;scripts&#x2F;game&#x2F;screens&#x2F;play&#x2F;snake.js\n```diff\n@@ -43,6 +43,10 @@\n â”Š43â”Š43â”Š    screen.appendLayer(Game.Screens.Play.Score, this.snakes);\n â”Š44â”Š44â”Š  }\n â”Š45â”Š45â”Š\n+â”Š  â”Š46â”Š  unload() {\n+â”Š  â”Š47â”Š    this.snakes.forEach(snake => snake.delete());\n+â”Š  â”Š48â”Š  }\n+â”Š  â”Š49â”Š\n â”Š46â”Š50â”Š  draw(context) {\n â”Š47â”Š51â”Š    // Draw each snake in the snakes array\n â”Š48â”Š52â”Š    this.snakes.forEach(snake => snake.draw(context));\n```\n\n[}]: #\n\nCongratulations! You've created a C++ cross JavaScript game. There shouldn't be any significant difference between the C++ version of the game and the JavaScript version on most machines, since the game is very small and barely requires any processing power. You'll probably notice the difference when starting to extend the game by adding terrains or more snakes.\n\nOne might ask - \"How much faster does my game actually run?\". The short answer is - around 50%. Why did I run into this conclusion? Well, take a look at the following JavaScript code snippet, for calculating Fibonacci of 42:\n\n```js\nfunction fib(x) {\n  if (x < 2) {\n    return 1;\n  }\n  else {\n    return fib(x - 1) + fib(x - 2);\n  }\n}\n```\n\nThe same code snippet should look almost identical written in C++:\n\n```cpp\nint fib(int x) {\n  if (x < 2) {\n    return 1;\n  }\n  else {\n    return fib(x - 1) + fib(x - 2);\n  }\n}\n```\n\nHowever, the run-times are completely different! I compared the average of 10 runs in 3 different environments, and I received the following results:\n\n![chart](https://cloud.githubusercontent.com/assets/7648874/22802494/2591025e-eef8-11e6-9679-10b5bca0ef30.png)\n\nAs you can see, the generated C++ is much faster, and to be precise, 57% faster! Surprisingly, I didn't have any significant difference between Emscripten generated C++ and natively compiled executable.\n\nC++ is more complex to write, but it certainly has its advantages over JavaScript. Remember, now that you know that you have the possibility to run C++ in the browser, make sure to use it, but never overdo it, always find the right balance between readability and performance.\n\n> *Sources:*\n> - *https://kripken.github.io/emscripten-site/docs/introducing_emscripten/index.html*\n> - *http://www.crunchy.com/?q=content/emscripten-perfectly-cromulent-compiler*\n> - *http://stackoverflow.com/questions/2354725/what-exactly-is-llvm*"
          }
        ]
      }
    ]
  }
]
