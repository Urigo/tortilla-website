[
  {
    "repoUrl": "https://github.com/Urigo/WhatsApp-Clone-Tutorial",
    "branchName": "final",
    "historyBranchName": "final-history",
    "releases": [
      {
        "releaseVersion": "next",
        "releaseDate": "2019-03-18 00:09:37 +0800",
        "tagName": "final@next",
        "tagRevision": "0155a7756245669fd0c700b399c96d220c677f32",
        "historyRevision": "cd401e4f3c9a3ae42693caaabdcb6c7c7208247e",
        "changesDiff": "diff --git a/.gitignore b/.gitignore\nnew file mode 100644\nindex 0000000..5171c54\n--- /dev/null\n+++ b/.gitignore\n@@ -0,0 +1,2 @@\n+node_modules\n+npm-debug.log\n\\ No newline at end of file\ndiff --git a/.tortilla/manuals/templates/root.tmpl b/.tortilla/manuals/templates/root.tmpl\nnew file mode 100644\nindex 0000000..140693f\n--- /dev/null\n+++ b/.tortilla/manuals/templates/root.tmpl\n@@ -0,0 +1,80 @@\n+![whatsapp-clone](https://user-images.githubusercontent.com/7648874/54141944-9f801a80-4461-11e9-85a1-bcb161d9a6c6.png)\n+\n+Whatsapp Clone is an open-source tutorial that will guide you through step-by-step on how to create a full-stack hybrid web-app.\n+\n+The software world is evolving quickly, and oftentimes people find themselves left behind, even the most experienced ones. The purpose of this tutorial is to completely demystify the confusion, and be the main guide on how to do things properly.\n+\n+This tutorial is for anyone who has ever asked himself or herself one of the following questions or similar:\n+\n+- How do people build an app today?\n+- What are the “hottest”, most leading technologies currently in the ecosystem?\n+- What are the best practices for using technology XXX?\n+- What is the purpose of technology XXX?\n+- How does technology XXX work?\n+- How do I use technology XXX?\n+- How do I migrate to the new version of technology XXX?\n+- Why should I use technology XXX over technology YYY?\n+\n+All of the above and more can be answered in the tutorial. Whether you’re a beginner, intermediate or a professional, we will have the answers you’re looking for.\n+\n+**What technologies does Whatsapp Clone uses?**\n+\n+Currently, Whatsapp Clone uses:\n+\n+- [React (with Hooks and Suspense)](http://react.com)\n+- [Styled-Components](https://styled-components.com)\n+- [Material-UI](https://material-ui.com)\n+- [TypeScript](https://typescriptlang.org)\n+- [Apollo GraphQL](https://www.apollographql.com)\n+- [GraphQL Code Generator](http://graphql-code-generator.com)\n+- [GraphQL Modules](https://graphql-modules.com)\n+- [PostgreSQL](https://www.postgresql.org/)\n+- [TypeORM](https://github.com/typeorm/typeorm)\n+\n+The point of this tutorial is not to be bound to a certain technology, but rather keep itself aligned with the ecosystem. When a new technology comes out, and it’s better and more popular, Whatsapp Clone will use it at some point (and full migration instructions).\n+\n+**P2P tutorial for the community by the community**\n+\n+What better way would it be to keep Whatsapp Clone aligned with the ecosystem than letting the community maintain it? Rather than dictating what technologies will be used in the app or how’s the tutorial gonna be written, you’re gonna decide how things are gonna be. That’s why we made it open source:\n+\n+- [Whatsapp Clone - Client](https://github.com/Urigo/WhatsApp-Clone-Client-React/tree/step-by-step-final)\n+- [Whatsapp Clone - Server](https://github.com/Urigo/WhatsApp-Clone-server/step-by-step-final)\n+\n+We’ve also made sure to publish some important documents so you can get more involved. You can track our progress and comment your suggestions, since everything is based on Google Docs and is updated live:\n+\n+- [Road map](https://docs.google.com/document/d/1p2Zio6Js2eoFfHs9CjIMF6jTuNyD4eQEHlgEAKhAqM8/edit?usp=sharing)\n+- [Chapter manuals] (https://drive.google.com/open?id=1ITxOniS_S3sgZfunLvtJ1L9P6Fj1YOLlFHhoQPjT3S0)\n+\n+**Migration instructions included**\n+\n+The are great tutorials out there, but almost none of them shows you what changes you should make in your app in order to be aligned with a new version of a certain technology. Technologies are being updated by the minute, some changes are minor and insignificant, but often times a breaking change will be made in which case we need to know how we can adapt to that change. Thanks to the [Tortilla platform](https://tortilla.academy), we can provide you with a git-diff that will show you what changes were made between each and every released version of the Whatsapp Clone tutorial since the beginning of history. This way you can easily notice the changes in APIs and migrate your app in no time.\n+\n+![tutorial-versions-diff](https://user-images.githubusercontent.com/7648874/54142148-0f8ea080-4462-11e9-9522-ec9997b76169.png)\n+\n+**Prerequisites**\n+\n+- JavaScript\n+- TypeScript\n+- JSX\n+- HTML\n+- CSS\n+- Node.JS\n+- NPM\n+- React\n+- SQL\n+\n+OS operations such as navigating to a folder, or creating a folder, are all gonna be written in Bash, but the instructions are OS agnostic and can be applied on any machine that is web-compatible.\n+\n+**What’s on the tutorial?**\n+\n+Whatsapp Clone is built chronologically, from the most basic, to more higher level features, so be sure to execute it in the right order. Each step is focused on a different subject, so by the end of it you’ll have a new feature and a new set of knowledge that you can start implementing in your everyday scenario immediately.\n+\n+Currently, Whatsapp Clone includes the following chapters:\n+\n+- [Step 1: Creating a basic React APP with a basic view.](https://github.com/Urigo/WhatsApp-Clone-Tutorial/blob/final/.tortilla/manuals/views/step1.md)\n+- [Step 2: Styling with Material-UI and Styled-Components.](https://github.com/Urigo/WhatsApp-Clone-Tutorial/blob/final/.tortilla/manuals/views/step2.md)\n+- [Step 3: Setting a basic Node.JS server with basic a basic REST endpoint.](https://github.com/Urigo/WhatsApp-Clone-Tutorial/blob/final/.tortilla/manuals/views/step3.md)\n+- [Step 4: Transition to GraphQL.](https://github.com/Urigo/WhatsApp-Clone-Tutorial/blob/final/.tortilla/manuals/views/step4.md)\n+- Step N: TBA\n+\n+Whatsapp Clone is updated on a regular basis, so you should expect more steps and extensions to it not long from now. You can keep track of our [road map](https://docs.google.com/document/d/1p2Zio6Js2eoFfHs9CjIMF6jTuNyD4eQEHlgEAKhAqM8/edit?usp=sharing) to see what’s upcoming.\ndiff --git a/.tortilla/manuals/templates/step1.tmpl b/.tortilla/manuals/templates/step1.tmpl\nnew file mode 100644\nindex 0000000..deed5cb\n--- /dev/null\n+++ b/.tortilla/manuals/templates/step1.tmpl\n@@ -0,0 +1,119 @@\n+In this chapter we will learn how to create a basic React app. The app will contain a basic view that will render a list of conversations within our app. Everything should be done gradually, so for now, instead of using real data, we will use in-memory fake data instead of calling a server.\n+\n+There are many ways to create an application. Indeed, you can create it from scratch, but the point behind development is that you'll make the least amount of work if possible. The point is to create a working product, and time is what matters, thus we're gonna use a boilerplate to kick-start our application. When it comes to React apps, the most popular is [`create-react-app`](https://github.com/facebook/create-react-app), which is pretty generic and easy to use. In addition, it's officially maintained by Facebook, the creators of React.\n+\n+`create-react-app` is a CLI that is installable via NPM:\n+\n+    $ npm install -g create-react-app\n+\n+Once you do so, you will have it available in your terminal. If the installation failed, try to run the command as `sudo`:\n+\n+\t$ sudo npm install -g create-react-app\n+\n+Using the `create` command, we can create the basis for our Whatsapp Clone:\n+\n+    $ create-react-app create whatsapp-clone-client\n+\n+> Note how we used the `client` prefix. That's because we're planning to create a server as well in further chapters.\n+\n+It will create a directory called `whatsapp-clone-client` inside the current folder. Inside that directory, it will generate the initial project structure and install the transitive dependencies:\n+\n+    my-app\n+    ├── README.md\n+    ├── node_modules\n+    ├── package.json\n+    ├── .gitignore\n+    ├── public\n+    │   ├── favicon.ico\n+    │   ├── index.html\n+    │   └── manifest.json\n+    └── src\n+        ├── App.css\n+        ├── App.js\n+        ├── App.test.js\n+        ├── index.css\n+        ├── index.js\n+        ├── logo.svg\n+        └── serviceWorker.js\n+\n+No configuration or complicated folder structures, just the files you need to build your app. Once the installation is done, you can open your project folder:\n+\n+\t$ cd whatsapp-clone-client\n+\n+Inside the newly created project, you can run some built-in commands:\n+\n+\t$ npm start\n+\n+Runs the app in development mode. Open `http://localhost:3000` to view it in the browser:\n+\n+![boilerplate-page](https://user-images.githubusercontent.com/7648874/54026782-025f8080-41da-11e9-9a4e-796fe15e8d03.png)\n+\n+The project that was created for us by `create-react-app` is highly functional and ready to use, but it's implemented in JavaScript. In our project, we're gonna use TypeScript. There's no right or wrong here, it's more of a personal choice. The main advantage of using TypeScript over using plain JavaScript is that we get to tell the compiler what types and data structures we expect in certain places, so that the compiler (which unlike a human never forgets) will remind us when we make a mistake and assume something that is not true.\n+\n+Luckily enough, `create-react-app` comes with a TypeScript support right out of the box, we only need to make a few adjustments in-order to make it work. First we need to install the TypeScript package, which is essential for TypeScript to function:\n+\n+\t$ yarn add typescript\n+\n+Every TypeScript project requires a `tsconfig.json` to be defined. This configuration file will dictate the behavior of TypeScript within that project. More about `tsconfig.json` and its available options can be found in the [official TypeScript handbook](https://www.typescriptlang.org/docs/handbook/tsconfig-json.html). This is the config file we're gonna use in our project:\n+\n+{{{ diffStep \"1.1\" module=\"client\" files=\"tsconfig.json\" }}}\n+\n+We're also gonna add a `tslint.json` file into the project - a file which will determine the linting preferences for our project. All rules are listed and explained in the [official rules doc page](https://palantir.github.io/tslint/rules/). We will use the following rules:\n+\n+{{{ diffStep \"1.1\" module=\"client\" files=\"tslint.json\" }}}\n+\n+Once we will run the app for the first time, `react-scripts` (`create-react-app` utility scripts package) should automatically initialize some additional TypeScript related files:\n+\n+\t$ npm start\n+\n+Since we're gonna use the new React [Hooks](https://reactjs.org/docs/hooks-intro.html) and [Suspense](https://reactjs.org/docs/react-api.html#reactsuspense) mechanisms, **make sure that your app uses React version 16.8 or above, otherwise it won't work.** The React version can be determined simply by looking at the `package.json` file. If by any chance your React version is lower than the required one, be sure to upgrade the version of `create-react-app` by upgrading it to the latest one and repeat the process of the project creation. Just in case, `create-react-app` can be upgrade by re-running the install command:\n+\n+\t$ npm install -g create-react-app\n+\n+Assuming that everything is set, we will now create our first screen - ChatsListScreen. The ChatsListScreen component is responsible for showing the active conversations within our app. Everything should be done gradually, so for now, instead of using real data, we will use in-memory fake data. Further in this tutorial, we will also create a server that will serve that data and connect it to our client.\n+\n+It's best to first schematically plan how our view's gonna look like. This would help us illustrate the intended view and also understand which React.Components / elements take part in it. This is how our screen's gonna look like:\n+\n+![chatslistscreen](https://user-images.githubusercontent.com/7648874/54027873-01305280-41de-11e9-9df0-5ad9c9c2f226.png)\n+\n+Let's break down the image above and see what components are we gonna have in the ChatsListScreen:\n+\n+- Navbar -  Which should contain a simple static title for now.\n+- ChatsList - Where each item's gonna contain some data regards the user we're chatting with and information about the chat.\n+\n+React apps tend to store React.Components under a directory located at `src/components`, and so we're gonna follow this pattern. We will create a directory called ChatsListScreen in the `components` dir where we're simply gonna import and put together the Navbar and ChatsList components. This is how the contents of that directory should look like:\n+\n+    ChatsListScreen\n+    ├── index.tsx\n+    ├── ChatsList\n+    └── ChatsNavbar\n+\n+We will use the `index.tsx` file to define that component, this way we can import it using the directory name:\n+\n+{{{ diffStep \"1.2\" module=\"client\" files=\"components/ChatsListScreen/index.jsx\" }}}\n+\n+Now we can implement the Navbar component, which doesn't have much for now except some text describing the app:\n+\n+{{{ diffStep \"1.2\" module=\"client\" files=\"components/ChatsListScreen/ChatsNavbar.jsx\" }}}\n+\n+And the ChatsList component:\n+\n+{{{ diffStep \"1.2\" module=\"client\" files=\"components/ChatsListScreen/ChatsList.jsx\" }}}\n+\n+You can see in the code-diff above how we used the [`moment`](https://momentjs.com/) library to wrap `lastMessage.createdAt`. Moment has the ability to wrap date objects nicely and rewrite them in a pretty format. This way we can have an elegant time format at which the message was sent e.g. `11:34`. To install:\n+\n+\t$ yarn add moment\n+\n+The ChatsList component has no event handlers and it's completely non-interactive as for now, that means that you can't click or tap anything yet, but as we go further in the tutorial we will add the necessary event handlers. Note how we used the `db.ts` module to get the chats data. `db.ts` is a temporary mock for our data-source and should be removed once we have a server up and running. Here's how our DB looks like:\n+\n+{{{ diffStep \"1.3\" module=\"client\" }}}\n+\n+The ChatsListScreen is now ready to use. We will replace the contents of the App component with the ChatsListScreen and we will make it the default screen in our app:\n+\n+{{{ diffStep \"1.4\" module=\"client\" files=\"App.jsx\" }}}\n+\n+If you'll try to run the app you'll see that everything is there, but it's not hard to notice that it's missing some style:\n+\n+![naked-chats-list](https://user-images.githubusercontent.com/7648874/54028578-73099b80-41e0-11e9-803a-7469300acb06.png)\n+\n+In the next chapter we will take care of styling our application with [Material-UI](https://material-ui.com/) and [styled-components](https://www.styled-components.com/) - we will give it the desired look and make it more user friendly. For now the ChatsListScreen serves no purpose, because you can't really do anything with it, but it can be used as a great basis to build on top of as we make progress.\ndiff --git a/.tortilla/manuals/templates/step2.tmpl b/.tortilla/manuals/templates/step2.tmpl\nnew file mode 100644\nindex 0000000..4c0cfa3\n--- /dev/null\n+++ b/.tortilla/manuals/templates/step2.tmpl\n@@ -0,0 +1,122 @@\n+Styled-components is a relatively new library that will transpile a given string into a CSS string and will encapsulate it under a React.Component. What's good about it is that you can define your style programmatically and it fits very well into React. With JavaScript in-hand you naturally have more control over your style, which makes it a very powerful tool.\n+\n+Here's one way to style a button using styled-components:\n+\n+```js\n+const Button = styled.button`\n+  background: transparent;\n+  border-radius: 3px;\n+  border: 2px solid palevioletred;\n+  color: palevioletred;\n+  margin: 0.5em 1em;\n+  padding: 0.25em 1em;\n+\n+  ${props => props.primary && css`\n+    background: palevioletred;\n+    color: white;\n+  `}\n+`;\n+```\n+\n+The created Button is actually a React.Component, so an instance of it can be created with ease like any other component:\n+\n+```jsx\n+  <Button primary />\n+```\n+\n+More information about styled-components can be found in the official [docs page](https://www.styled-components.com/docs).\n+\n+We would also use [Material-UI](https://material-ui.com/) - a library with a set of React components that implements Google's Material Design. What's good about it is that the design is already implemented right out of the box. Not only that, but it also includes a set of icons which are free to use.\n+\n+There are many many things that Material-UI can offer, and it's not easy to follow it up, especially with the constantly evolving and improving API. The best way to go with it, is to have a component, and then look for it in the [official website](https://material-ui.com/). When it comes to searching for icons, they can be found in the [material.io](https://material-ui.com/) website through the search bar. As we move further in this tutorial you should have a better grasp of Material and how to use it.\n+\n+![material-ui-icons](https://user-images.githubusercontent.com/7648874/54141504-c853e000-4460-11e9-94b5-aae98ec9a1e3.png)\n+\n+We will start off by installing both libraries:\n+\n+  $ npm install @material-ui/core @material-ui/icons styled-components\n+\n+`@material-ui/core` includes core component of Material-UI such as Input, Popover, Modal, etc, and `@material-ui/icons` includes a set of icons. Material is very generic and has a built in theming system which can be controlled by simply setting few variables, which is exactly what we're gonna need in our app.\n+\n+In our app we're mainly gonna use 2 colors:\n+\n+- Primary #306759\n+- Secondary #79e352\n+\n+Theme definition can easily be done in Material using the MuiThemeProvider component:\n+\n+{{{ diffStep \"2.2\" module=\"client\" }}}\n+\n+Once we have it set, the colors should be available to use in our application by simply providing the \"color\" prop to the component instance whose color we would like to change:\n+\n+```jsx\n+<Button color=\"primary\">Primary</Button>\n+<Button color=\"secondary\">Secondary</Button>\n+```\n+\n+In our app, we're also gonna use CSS directly to change its colors, therefore it would be handy to have these theme variables available to us through CSS. To do so, we will have have a second definition of these variables in `index.css`, at the `:root` level of our application.\n+\n+{{{ diffStep \"2.3\" module=\"client\" }}}\n+\n+`:root` is a pseudo element that simply represents the root node, which will make the colors available in all elements. Normally, it works like JavaScript's scoping system and it will make variables available only to the current node and to its children, NOT its parents. CSS vars can be used like so:\n+\n+```css\n+  color: var(--primary-text);\n+  background-color: var(--primary-bg);\n+```\n+\n+More information about CSS variables can be found in the [official MDN docs](https://developer.mozilla.org/en-US/docs/Web/CSS/Using_CSS_variables).\n+\n+So getting back to the ChatsListScreen, we will wrap the ChatsNavbar with Material's <Toolbar /> component:\n+\n+{{{ diffStep \"2.4\" module=\"client\" files=\"ChatsNavbar.tsx\" }}}\n+\n+And we will replace the `<ul />` and `<li />` elements with Material's `<List />` and `<ListItem />` in ChatsList:\n+\n+{{{ diffStep \"2.4\" module=\"client\" files=\"ChatsList.tsx\" }}}\n+\n+Thanks to the `button` attribute we can give our list a more vibrant feeling and that will display a nice ripple effect once an item is clicked, something that could have taken a long time to implement manually.\n+\n+Next, we will use `styled-components` to create new React.Components which are bound into a style-sheet. This way when we create new instances of them, the components will be styled right out of the box. Example:\n+\n+```jsx\n+const Button = styled.button `\n+  border-radius: 999px;\n+`\n+\n+const RedButton = styled(Button) `\n+  color: red;\n+`\n+\n+const GreenButton = styled(Button) `\n+  color: green;\n+`\n+\n+const BlueButton = styled(Button) `\n+  color: blue;\n+`\n+\n+const Dashboard = (\n+  <div>\n+    <RedButton />\n+    <GreenButton />\n+    <BlueButton />\n+  </div>\n+)\n+```\n+\n+The clear advantage of such working strategy is that all the styles are encapsulated, unlike traditional CSS where style rules can easily collide and be merged unintentionally. Remember that **`styled-components` operates per component, not globally**. In terms of syntax and API there isn't much to explain, it's very intuitive and if you would follow the step-diffs in this tutorial carefully you should get the hang of `styled-components` pretty easily.\n+\n+Accordingly, let's use `styled-components` to wrap internal components in the ChatsNavbar component:\n+\n+{{{ diffStep \"2.5\" module=\"client\" files=\"ChatsNavbar.tsx\" }}}\n+\n+And in the ChatsList components:\n+\n+{{{ diffStep \"2.5\" module=\"client\" files=\"ChatsList.tsx\" }}}\n+\n+Notice that we've changed the structure of the HTML of the ChatsList component. We've added the ChatInfo to allow better alignment of the elements. **There isn't right or wrong way to define CSS rules and HTML, as long as the script is clear and easy to understand, that will do**.\n+\n+We're done styling or ChatsList component. We will keep using the same principles to style the rest of the components in our application. The final result should look like so:\n+\n+![screenshot](https://user-images.githubusercontent.com/7648874/54141766-40baa100-4461-11e9-8dd0-59edcfdb3b84.png)\ndiff --git a/.tortilla/manuals/templates/step3.tmpl b/.tortilla/manuals/templates/step3.tmpl\nnew file mode 100644\nindex 0000000..ee1ac2c\n--- /dev/null\n+++ b/.tortilla/manuals/templates/step3.tmpl\n@@ -0,0 +1,131 @@\n+So we have a running app with a single screen which looks stylish and presents some data to the user. There is something missing though. The data that is presented is just a mock for a server response, and it represents the schema of some real data to come.\n+\n+Even if we'll create real data on the client, that means that when the client is down, all the data is lost. But this is a social app, many people want to use it together and even the same person wants to use it on multiple devices. For that, we need a central place to store all data and all the clients would connect to that central place in order to retrieve or change the data.\n+\n+In this step, we will write a Node.JS server and will expose a REST endpoint that will serve the data-mock. We will build the REST application using [Express](https://www.npmjs.com/package/express). Further in this tutorial, we will migrate to using a real data-base with real I/O from the user, so we got you covered.\n+\n+The plan is to have a server up and running at `localhost:4000` that will expose a `GET /chats` route. Unlike our client application, we're not gonna use any boilerplate and we're gonna set everything up manually. Ofcourse, you should feel free to use a boilerplate if it looks right to you. Right outside the client project, we will create a new directory called `whatsapp-clone-server` in which we will start creating our server:\n+\n+    $ mkdir whatsapp-clone-server\n+    $ cd whatsapp-clone-server\n+\n+Then we will use NPM to initialize a new project:\n+\n+    $ npm init --yes\n+\n+> `--yes` will answer yes to all questions and skip the prompt. It's just faster this way.\n+\n+There's nothing special about this command, it only creates a basic package.json which we can add things on top (see [NPM's official docs](https://docs.npmjs.com/cli/init)). Just to make sure that things work, we will add an `index.js` file which will print \"hello world\" to the console.\n+\n+{{{ diffStep \"1.1\" module=\"server\" files=\"index.js\" }}}\n+\n+\n+And we will add a startup script to the `package.json` file called `start`:\n+\n+    start: node index.js\n+\n+NPM-scripts are just a way to defined an alias for commands. Now we only have one simple script, but it can turn out to be something very complex depending on our server, so it can be very useful. More about npm-scripts can be found in the [official NPM docs](https://docs.npmjs.com/misc/scripts).\n+\n+Now we can run our server by running `$ npm start` and we should see the message \"hello world\" printed to the console, as expected.\n+\n+Like in our client's app, we will be using TypeScript. It's comfortable and it enables consistency between both apps. In order to use TypeScript we will install few packages:\n+\n+    $ npm install --dev typescript ts-node @types/node\n+\n+> Note how we used the `--dev` flag. This project is not gonna be required as an external dependency anywhere, but It is still common to separate between production dependencies and development dependencies. More about the `--dev` option can be read in the [NPM-install docs](https://docs.npmjs.com/cli/install).\n+\n+- The [`typescript`](https://www.npmjs.com/package/typescript) package is TypeScript's core transpiler.\n+- [`ts-node`](https://www.npmjs.com/package/ts-node) is an interpreter that will transpile required `.ts` files into JavaScript at runtime.\n+- [`@types/node`](https://www.npmjs.com/package/@types/node) will make the appropriate definitions for a Node.JS environment.\n+\n+> You can read more about the `@types` monorepo in the [official GitHub repository](https://github.com/DefinitelyTyped/DefinitelyTyped).\n+\n+Our server is gonna use the following `tsconfig.json` file, feel free to make the necessary modifications based on your needs:\n+\n+{{{ diffStep \"1.2\" module=\"server\" files=\"tsconfig.json\" }}}\n+\n+We will rename the `index.js` file to `index.ts`:\n+\n+    $ mv index.js index.ts\n+\n+And we will update the npm-script `start` to use `ts-node`, since we wanna use TypeScript, and not JavaScript directly:\n+\n+    start: ts-node index.ts\n+\n+We can test the startup of our server again by running `$ npm start` and we should see the message \"hello world\" printed to the console. The skeleton of the project is set and we can move on to implementing the REST API.\n+\n+Like we said at the beginning, we will be using Express to setup the API. Express is wrap around the native [Node.JS \"http\"](https://nodejs.org/api/http.html) library which is responsible for handling HTTP requests. Yes, it can also be used directly, but Express is much more comfortable and has an amazing ecosystem built around it. Let's install Express and its TypeScript definitions:\n+\n+    $ npm install express\n+    $ npm install --dev @types/express\n+\n+Before we implement the `GET /chats` route we will implement a `GET /_ping` route. This route will be used to determine whether the server is up and running or not, and how fast the connection is based on the response time. For every request sent to this route, we should expect a response saying \"pong\". Some call it \"heartbeat\", because this route is being tested repeatedly by the hosting machine to check if it's alive, just like a heartbeat in a way. This is how the route should look like:\n+\n+{{{ diffStep \"1.3\" module=\"server\" files=\"index.ts\" }}}\n+\n+We can use the `$ curl localhost:4000/_ping` command to send a request to the server and we should get a \"pong\", assuming that the server available on that URL. The `GET /chats` should be implemented similarly, only the response is different. Instead of returning \"pong\" we will return the data-mock for our chats:\n+\n+{{{ diffStep \"1.4\" module=\"server\" files=\"index.ts, db.ts\" }}}\n+\n+Unlike the previous route, we used the `.json()` method this time around to send a response. This will simply stringify the given JSON and set the right headers. Similarly to the client, we've defined the db mock in a dedicated file, as this is easier to maintain and look at.\n+\n+It's also recommended to connect a middleware called [`cors`](https://www.npmjs.com/package/cors) which will enable cross-origin requests. Without it we will only be able to make requests in localhost, something which is likely to limit us in the future because we would probably host our server somewhere separate than the client application. Let's install the `cors` library and load it with the Express `middleware()` function:\n+\n+    $ npm install cors\n+\n+{{{ diffStep \"1.4\" module=\"server\" files=\"index.ts\" }}}\n+\n+The server is now ready to use! So getting back to the client, first we will define our server's URL under the `.env` file:\n+\n+{{{ diffStep \"3.1\" module=\"client\" }}}\n+\n+This will make our server's URL available under the `process.env.REACT_APP_SERVER_URL` member expression and it will be replaced with a fixed value at build time, just like macros. The `.env` file is a file which will automatically be loaded to `process.env` by the [`dotenv`](https://www.npmjs.com/package/dotenv) NPM package. `react-scripts` then filters environment variables which have a `REACT_APP_` prefix and provides the created JSON to a Webpack plugin called [DefinePlugin](https://webpack.js.org/plugins/define-plugin/), which will result in the macro effect.\n+\n+Now let's move back into our React app folder. We will now replace the local data-mock usage with a fetch from the server. For that we can use the native [fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API), however, it needs to be used in the right life-cycle hook of the React.Component.\n+\n+There are 2 naive approaches for that:\n+\n+- Calling `fetch()` outside the component, but this way that chats will be fetched even if we're not even intending to create an instance of the component.\n+\n+```js\n+fetch().then(() => /* ... */)\n+const MyComponent = () => {}\n+```\n+\n+- Calling `fetch()` inside the component, but then it will be invoked whenever the component is re-rendered.\n+\n+```js\n+const MyComponent = () => {\n+  fetch().then(() => /* ... */)\n+}\n+```\n+\n+These 2 approaches indeed work, but they both fail to deliver what's necessary on the right time. In addition, there's no way to properly coordinate async function calls with the render method of the component.\n+\n+**Introducing: React hooks**\n+\n+With React hooks we can invoke the desired logic in the right life-cycle stage of the target component. This way we can avoid potential memory leaks or extra calculations. To implement a proper `fetch()`, we will be using 2 React hooks:\n+\n+- [`React.useState()`](https://reactjs.org/docs/hooks-reference.html#usestate) - which is used to get and set a state of the component - will be used to store the fetch chats.\n+\n+```js\n+const [value, setValue] = useState(initialValue)\n+```\n+\n+- [`React.useMemo()`](https://reactjs.org/docs/hooks-reference.html#usememo) - which is used to run a computation only once certain conditions were met - will be used to run the `fetch()` function only once the component has mounted.\n+\n+```js\n+const memoizedValue = useMemo(calcFn, [cond1, cond2, ...conds])\n+```\n+\n+The result of that approach will look like this, in the context of our ChatsList component:\n+\n+{{{ diffStep \"3.2\" module=\"client\" }}}\n+\n+> It's recommended to read about React hooks and their basic concept at the [official React docs page](https://reactjs.org/docs/hooks-overview.html).\n+\n+At this point we can get rid of `db.ts` file in the client, since we don't use it anymore:\n+\n+    $ rm src/db.ts\n+\n+That's it. Our ChatsListScreen is now connected to a working back-end. In the next step we will upgrade our REST API into a GraphQL API and we will create a basis for a more robust back-end.\ndiff --git a/.tortilla/manuals/templates/step4.tmpl b/.tortilla/manuals/templates/step4.tmpl\nnew file mode 100644\nindex 0000000..54895ff\n--- /dev/null\n+++ b/.tortilla/manuals/templates/step4.tmpl\n@@ -0,0 +1,192 @@\n+**What is GraphQL?**\n+\n+[GraphQL](https://graphql.org/) is a query language invented by Facebook, and it's used to query data within our API. It allows clients to define the structure of the data required, and the exact same structure of data will be returned from the server, therefore preventing excessively large amounts of data from being returned. Unlike REST, GraphQL APIs are organized in terms of types and fields, not endpoints.\n+\n+Currently in our app, if we'd like to get its chats we would send a GET request to `/chats`. With GraphQL it would be done differently with a string that describes the data that we would like to get:\n+\n+```graphql\n+chats {\n+  id\n+  name\n+  picture\n+  lastMessage {\n+    id\n+    content\n+    createdAt\n+  }\n+}\n+```\n+\n+> Above: An illustration of a potential GraphQL query sent to our Whatsapp API\n+\n+**Why GraphQL and not REST?**\n+\n+In terms of experience REST got the upper hand. It has been used for many more years and has proven itself to work well, and it's completely agnostic to the implementation of the back-end. However, when it comes to data projection and aggregation, it fails to deliver.\n+\n+When using REST, often times you'll find yourself performing multiple requests to execute a single query of data. Not only that, you might even end up with additional data that is not necessary. Either way, the process would result in slower and heavier response.\n+\n+With GraphQL we don't have that kind of problem. Queries may take many shapes and forms, and since GraphQL is schema based - it can handle it. You'll get exactly what you asked for with a single request. **GraphQL provides a dynamic API while REST doesn't.**\n+\n+```graphql\n+# request\n+query {\n+  chat(id: 1) {\n+    id\n+    name\n+    lastMessage {\n+      id\n+      content\n+    }\n+  }\n+}\n+```\n+\n+![graphql-request](https://user-images.githubusercontent.com/7648874/54133620-5aec8300-4451-11e9-9bda-a459dc48f57c.png)\n+\n+```js\n+// response\n+{\n+  \"data\": {\n+    \"chat\": {\n+      \"id\": 1,\n+      \"name\": \"Ethan Gonzalez\",\n+      \"lastMessage\": {\n+        \"id\": 1,\n+        \"content\": \"You on your way?\"\n+      }\n+    }\n+  }\n+}\n+```\n+\n+**GraphQL schema, in a nutshell**\n+\n+Like said earlier,  GraphQL APIs are organized in terms of types and fields. That means that our app data should be described with a schema, where each field's gonna have a resolver - the handler that will return the corresponding data. Things will be much clearer as we move further.\n+\n+Let's try to describe our app's data with a GraphQL schema and then dive into it:\n+\n+```graphql\n+scalar Date\n+\n+type Message {\n+  id: ID!\n+  content: String!\n+  createdAt: Date!\n+}\n+\n+type Chat {\n+  id: ID!\n+  name: String!\n+  picture: String\n+  lastMessage: Message\n+}\n+\n+type Query {\n+  chats: [Chat!]!\n+}\n+```\n+\n+The schema is self explanatory in terms of what data it's compatible with. Supported built-in scalar types in GraphQL are:\n+\n+- Int: Signed 32‐bit integer\n+- Float: Signed double-precision floating-point value\n+- String: UTF‐8 character sequence\n+- Boolean: true or false\n+- ID (serialized as String): A unique identifier, often used to refetch an object or as the key for a cache. While serialized as a String, ID signifies that it is not intended to be human‐readable\n+\n+Any custom scalar can be declared with the `scalar` keyword, and custom types can be declared with the `type` keyword. However, you should know that some types are reserved by GraphQL itself; `Query` is one of them. The `Query` type will be used as the root for received queries by the clients, which means that we can send queries which start with the `chats` field. Other reserved types are:\n+\n+- `type Query` - reserved for [GraphQL queries](https://graphql.org/learn/queries/#mutations).\n+- `type Mutation` - reserved for [GraphQL mutations.](https://graphql.github.io/learn/queries/)\n+- `type Subscription` - reserved for [GraphQL subscriptions.](https://www.apollographql.com/docs/react/advanced/subscriptions.html)\n+\n+> As we're not gonna go through the entire GraphQL API, it's recommended to go through the [official learn section of the GraphQL website](https://graphql.org/learn/), but the information so far will definitely help you kick-start, plus the upcoming implementation.\n+\n+**Getting started**\n+\n+We will be implementing a GraphQL mechanism for the client and for the server. We will start with the server as things will make more sense, and we will be able to test it before we proceed into the client. Essentially GraphQL is connected into a HTTP endpoint, usually under `POST /graphql`, and so this is exactly what we're gonna do, connect the endpoint handler. Luckily, we don't have to implement that. A team called [Apollo](https://www.apollographql.com/) already did it for us, so we can use their implementation. We will install the required packages:\n+\n+    $ npm install apollo-server-express body-parser graphql\n+    $ npm install --dev @types/body-parser @types/graphql\n+\n+- [`graphql`](https://www.npmjs.com/package/graphql) - The core package of GraphQL that includes the resolvers for basic data-types.\n+- [`apollo-server-express`](https://www.npmjs.com/package/apollo-server-express) - Apollo's implementation for the GraphQL Express REST endpoint.\n+- [`body-parser`](https://www.npmjs.com/package/body-parser) - Parse incoming request bodies in a middleware before your handlers, available under the req.body property.\n+- `@types/…` - TypeScript definitions\n+\n+We can now connect Apollo's middleware under the `/graphql` route:\n+\n+{{{ diffStep \"2.1\" module=\"server\" files=\"index.ts\" }}}\n+\n+As you can see, the middleware requires a schema. A schema is composed mainly out of 2 fields:\n+\n+- `typeDefs` (type definitions) - the schema types we wrote earlier this chapter for chats.\n+- `resolvers` - The handlers that will provide the data for each field in `typeDefs`.\n+\n+We will start first by defining the types. All we have to do is to copy-paste the contents of the schema that was shown earlier into a new file called `typeDefs.graphql`:\n+\n+{{{ diffStep \"2.2\" module=\"server\" files=\"typeDefs.graphql\" }}}\n+\n+The `.graphql` file extension is just a more convenient way to work with a GraphQL schema. The exported result should be a simple string that we can use to compose our GraphQL schema. The clear advantage of working with a dedicated file is that we get to have syntax highlight.\n+\n+Now we will implement the resolvers. Resolvers are presented in a JSON object where each resolver name should match the field name it represents. You can read more about resolvers in [Apollo's official docs for resolvers](https://www.apollographql.com/docs/tutorial/resolvers.html). This is how our resolvers should look like:\n+\n+{{{ diffStep \"2.2\" module=\"server\" files=\"resolvers.ts\" }}}\n+\n+For now it's extremely simple, we map the chats query directly into the database collection. Each field in the resolvers object should match the GraphQL type it represents in the schema. Since we don't have any logic now, we should not implement any resolvers for the rest of the types, the data will simply be forwarded as is.\n+\n+Note that we've implemented a custom scalar named `Date` and we resolved it with an NPM package. Let's install it:\n+\n+    $ npm install graphql-iso-date\n+    $ npm install --dev @types/graphql-iso-date\n+\n+Final thing that we have to do would be combining the resolvers and the type-defs under a single GraphQL schema.\n+\n+{{{ diffStep \"2.2\" module=\"server\" files=\"index.ts\" }}}\n+\n+[`graphql-import`](https://www.npmjs.com/package/graphql-import) and [`graphql-tools`](https://www.npmjs.com/package/graphql-tools) are utility packages that will help us create a schema that will be compatible with Apollo's API. Let's install them:\n+\n+    $ npm install graphql-import graphql-tools\n+\n+There's one optimization however that we should make in the our DB. Right now, the each chat document has a direct reference to a message via the `lastMessage` field. Practically speaking, this is NOT how the data sits in the DB. The `lastMessage` should only hold the ID for the correlated message, and then in the Node.JS app we should **resolve** it according to our needs. Let's make the appropriate changes in the DB then:\n+\n+{{{ diffStep \"2.3\" module=\"server\" files=\"db.ts\" }}}\n+\n+And a resolver to the `lastMessage` field:\n+\n+{{{ diffStep \"2.3\" module=\"server\" files=\"typeDefs.graphql\" }}}\n+\n+The first argument of the resolver is the raw chat data received by the DB, and the returned result should be the mapped value which we would like to return to the client.\n+\n+As we get further in this tutorial we should get a better grasp regards resolvers and their API, since we will have to deal with more logic and complexity within our Node.JS app.\n+\n+Assuming that the server is running, we can already test our GraphQL endpoint. Because it's exposed to us via a REST endpoint, we can use a `$ curl` command to send a request to `GET localhost:4000/graphql` and get a response with all the data. Again, the query that we're gonna use to fetch the chats is:\n+\n+```graphql\n+chats {\n+  id\n+  name\n+  picture\n+  lastMessage {\n+    id\n+    content\n+    createdAt\n+  }\n+}\n+```\n+\n+The one-liner version of it with a `$ curl` command looks like so:\n+\n+    curl \\\n+      -X POST \\\n+      -H \"Content-Type: application/json\" \\\n+      --data '{ \"query\": \"{ chats { id name picture lastMessage { id content createdAt } } }\" }' \\\n+      localhost:4000/graphql\n+\n+As a response we should get the data-mock for our chats stored in the server. Since we have that in place, we can go ahead and delete our implementation for the `GET /chats` route.\n+\n+So getting back to the client, all we have to do is to change the fetching URL in the ChatsList component to use our newly implemented GraphQL REST endpoint:\n+\n+{{{ diffStep \"4.1\" module=\"client\" }}}\n+\n+The received data should be similar to the previous one. No further changes are required. In the next chapter, we will continue working on the UI of our front-end application and we will add a new screen to the flow - the `ChatRoomScreen`.\ndiff --git a/.tortilla/manuals/templates/step5.tmpl b/.tortilla/manuals/templates/step5.tmpl\nnew file mode 100644\nindex 0000000..c91d9a6\n--- /dev/null\n+++ b/.tortilla/manuals/templates/step5.tmpl\n@@ -0,0 +1,126 @@\n+Testing is a crucial part when writing an application, especially if we're planning to publish it or make it a commercial thing. Before we hand someone a product, of any kind, we wanna make sure that it passes certain quality checks. We're signed on that product and so it's very important to ensure that it functions properly according our expectations, otherwise wouldn't wanna use it and will look for alternatives.\n+\n+In the context of software, we constantly make changes. It's also inevitable to make all features completely independent from one another, so something in the app is likely to break as we upgrade it or maintain it. That's why we need to write a set of tests that can be run on demand, so when we implement a new feature we can simply run the tests and see what feature broke due to most recent changes.\n+\n+There are currently 3 main testing frameworks in the NPM ecosystem: [Jasmine](https://jasmine.github.io/), [Mocha](https://mochajs.org/), and [Jest](https://jestjs.io/). Each testing framework has its pros, and cons, and at the end of the day it's a matter of preference. In our application we're gonna use [Jest](https://jestjs.io/) - a testing framework which was developed by Facebook. What's good about Jest is that it can be used to test both client and server logic, because it runs as a Node.JS application, but it also emulates the browser environment whenever we run it, thanks to [JSDOM](https://github.com/jsdom/jsdom).\n+\n+![jest](https://user-images.githubusercontent.com/7648874/54493900-e2ce0380-490f-11e9-8075-be4a236c7c38.png)\n+\n+In this chapter we will learn how to test the React.Components in the client, and Apollo-GraphQL resolvers in the server. There are 3 kinds of tests:\n+\n+- Unit tests - which are used to test a single component, independently from other components in our system.\n+- Integration tests - which are used to test a component in relation to other components in our systems (how well do they co-work with each other).\n+- e2e tests (end to end) - which are used to test a complete, from the moment I clicked on a button in the user interface until the data gets back from the server and shown on the screen.\n+\n+The efficiency of the tests go from bottom to top (unit -> e2e), but the maintenance and complexity go from bottom to top (e2e -> unit). Accordingly we will need to find a good balance where we don’t spend too much time on writing tests yet have a good indicator for how well our system functions. So we should write a lot of unit tests, a good amount of integration tests and a handful of e2e tests.\n+\n+![tests-types-table](https://user-images.githubusercontent.com/7648874/54494121-fed2a480-4911-11e9-9370-694ec989729b.png)\n+\n+We will start with the client as it’s much easier, because Jest is set and ready to use right out of the box thanks to `create-react-app`.\n+\n+**Client - Testing React.Components**\n+\n+Thanks to `create-react-app`, we have Jest set and ready to use right out of the box, so we can start writing tests right away. I you'll look at the `src` you'll see a file called `App.test.tsx`, which simply ensures that the component can be rendered without crashing.\n+\n+```jsx\n+import React from 'react';\n+import ReactDOM from 'react-dom';\n+import App from './App';\n+\n+it('renders without crashing', () => {\n+  const div = document.createElement('div');\n+  ReactDOM.render(<App />, div);\n+  ReactDOM.unmountComponentAtNode(div);\n+});\n+```\n+\n+This is not a typical test that you're likely to find in a React project, but it demonstrates very well how Jest can be used to test DOM related issues. If you'll run `$ npm run test` (or `$ yarn test`) in the command line and then press `a`, you should see the following output:\n+\n+![report](https://user-images.githubusercontent.com/7648874/54341429-eabe4700-4674-11e9-8e76-3aaaf7fec79a.png)\n+\n+Jest will automatically run for every file that ends with a `.test.xxx` extension. This is very convenient because the tests can live right next to the component, and you don't need to lookup for it across the project. This behavior can be modified by configuring Jest in the `package.json` file under the `\"jest\"` field. More information about configuring Jest can be found in the official[ configuration documentation](https://jestjs.io/docs/en/configuration).\n+\n+> If you get a warning message regards wrapping the component with `act()` - this is a known issue with hooks and should have a proper solution soon. More about this issue and progress regards its fix can be found in this [GitHub thread](https://github.com/facebook/react/issues/14769#issuecomment-470097212).\n+\n+Now we're gonna write a basic test for the `<ChatsList />` component. In the test, we'll mock a fake response from the server, and examine the contents of rendered HTML. Since the HTML of the component is a dynamic thing and is constantly subject to changes, it would be a good idea to annotate it with `data-testid` attributes so it can be tested regardless of its structure:\n+\n+{{{ diffStep \"5.1\" module=\"client\" files=\"ChatsList.tsx\" }}}\n+\n+Now we can select various HTML elements with a query selector when we test the component. We will install a couple of packages that will assist us in implementing the test:\n+\n+  $ npm install jest-fetch-mock jest-dom react-testing-library\n+\n+- The [`jest-fetch-mock`](https://www.npmjs.com/package/jest-fetch-mock) package can mock responses emitted by the Fetch API.\n+- The [`jest-dom`](https://www.npmjs.com/package/jsdom) package will add custom matchers that will help us examine HTML contents of DOM elements.\n+- The [`react-testing-library`](https://www.npmjs.com/package/react-testing-library) package contains utility methods that will help us test React.Components with Jest.\n+\n+Next, we will create a file under the `src` folder called `setupTests.ts`. This file is loaded configured automatically by `create-react-app` and loaded by Jest, and we can use it to set up our testing environment according to our needs (like said earlier, Jest can be configured, so this file path can be changed). We will use that file to define a fake Fetch API using the `jest-fetch-mock` library:\n+\n+{{{ diffStep \"5.2\" module=\"client\" files=\"src/setupTests.ts\" }}}\n+\n+We will create another file called `ChatsList.test.tsx`, right next to the `<ChatsList />` component under the `ChatsListScreen` directory, and inside we will implement our test. The test should follow these steps:\n+\n+- Mock the response to contain a fake chat, so we won't need to make an actual call to our GraphQL API.\n+- We will create a new instance of `<ChatsList />` and render it in a container element.\n+- We will wait for changes in the DOM caused by `setState()`.\n+- We will test the contents of the container.\n+\n+And this is how the implementation should look like:\n+\n+{{{ diffStep \"5.3\" module=\"client\" files=\"src/components/ChatsListScreen/ChatsList.test.tsx\" }}}\n+\n+> Jest API is vast but pretty intuitive for the most part. It mostly consists of test descriptors and matchers. [Here's a full list of all matchers which are built into Jest's API](https://jestjs.io/docs/en/expect). Always make sure to work against it when writing tests, for optimal results.\n+\n+We will now move on to testing the server where we will learn how to setup Jest manually and test it against a GraphQL API.\n+\n+**Server - Testing GraphQL resolvers**\n+\n+To set-up Jest, we will run the following in the command line:\n+\n+    $ npm install jest @types/jest ts-jest --dev\n+\n+This will basically install Jest and make it useable with TypeScript. In addition, we will need to specify the file pattern that we would like to transform with [`ts-jest`](https://www.npmjs.com/package/ts-jest), by adding the following section to `package.json`:\n+\n+```\n+{\n+  \"jest\": {\n+    \"transform\": {\n+      \"^.+\\\\.(js|jsx|ts|tsx)$\": \"<rootDir>/node_modules/ts-jest\"\n+    }\n+  }\n+}\n+```\n+\n+We will also add a `\"test\"` script in the `package.json` file, so we can run the tests with `$ npm run test` (or `$ yarn test`):\n+\n+```\n+{\n+  \"scripts\": {\n+    \"test\": \"jest\"\n+  }\n+}\n+```\n+\n+This is how our `package.json` should look like at this point:\n+\n+{{{ diffStep \"3.1\" module=\"server\" files=\"package.json\" }}}\n+\n+Now we're gonna test the `chats` query in our GraphQL schema. To do so, we will setup an Apollo Client and send a query request to our back-end, and then we will match the received response with a pre-defined snapshot. Luckily, we don't have to set an actual client, since the tests and the implementation of the back-end live right next to each other, thus, we will install a package which will help us achieving so:\n+\n+    $ npm install apollo-server-testing --dev\n+\n+We will define the test suite under the `tests/queries` folder in a file called `getChats.test.ts`:\n+\n+{{{ diffStep \"3.2\" module=\"server\" files=\"tests/queries/getChats.test.ts\" }}}\n+\n+In the test function, we create a new instance of the Apollo-GraphQL server using our schema, and we query some data against it thanks to the fake client created by [`apollo-server-testing`](https://www.npmjs.com/package/apollo-server-testing).\n+\n+The `.toMatchSnapshot()` matcher will call the `toString()` method on the examined object and will test it against a predefined snapshot. The snapshot will automatically be created once we run the test for the first time and will be stored under the `__snapshot__` directory. This means that the first test run will always pass. This is useful because you can later on observe and adjust manually the snapshot manually without having to write it from scratch. The expected result should be a projection of the data stored in the `db.ts` file.\n+\n+{{{ diffStep \"3.2\" module=\"server\" files=\"tests/queries/__snapshots__\" }}}\n+\n+Always be sure to observe the snapshot before moving on! The received result isn't necessarily what you'd expect. Also it's not a good practice to store production data in the snapshot because it's subject to changes. Normally we would set up another instance of the DB for testing purposes, but since our DB is a mock and doesn't represent real data, there's no need to at this stage.\n+\n+Now that we have the required knowledge regards testing and Jest's API, we will implement tests throughout the tutorial as a trivial thing. We will not go through each and every new matcher that we introduce, as it is self explanatory and there's too much of them. Be sure to work against [this full list of matchers](https://jestjs.io/docs/en/expect) when working with Jest.\n+\n+In the next chapter we will continue expanding our application by adding a `<ChatRoomScreen />`.\ndiff --git a/client/.env b/client/.env\nnew file mode 100644\nindex 0000000..f0fc5d5\n--- /dev/null\n+++ b/client/.env\n@@ -0,0 +1 @@\n+REACT_APP_SERVER_URL=http://localhost:4000\n\\ No newline at end of file\ndiff --git a/client/.gitignore b/client/.gitignore\nnew file mode 100644\nindex 0000000..4d29575\n--- /dev/null\n+++ b/client/.gitignore\n@@ -0,0 +1,23 @@\n+# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.\n+\n+# dependencies\n+/node_modules\n+/.pnp\n+.pnp.js\n+\n+# testing\n+/coverage\n+\n+# production\n+/build\n+\n+# misc\n+.DS_Store\n+.env.local\n+.env.development.local\n+.env.test.local\n+.env.production.local\n+\n+npm-debug.log*\n+yarn-debug.log*\n+yarn-error.log*\ndiff --git a/client/package.json b/client/package.json\nnew file mode 100644\nindex 0000000..4dead69\n--- /dev/null\n+++ b/client/package.json\n@@ -0,0 +1,39 @@\n+{\n+  \"name\": \"whatsapp-clone-client\",\n+  \"version\": \"0.1.0\",\n+  \"private\": true,\n+  \"repository\": {\n+    \"type\": \"git\",\n+    \"url\": \"https://github.com/Urigo/WhatsApp-Clone-Client-React.git\"\n+  },\n+  \"dependencies\": {\n+    \"@material-ui/core\": \"3.9.2\",\n+    \"@material-ui/icons\": \"3.0.2\",\n+    \"moment\": \"2.24.0\",\n+    \"react\": \"16.8.4\",\n+    \"react-dom\": \"16.8.4\",\n+    \"react-scripts\": \"2.1.8\",\n+    \"styled-components\": \"4.1.3\",\n+    \"typescript\": \"3.3.3333\"\n+  },\n+  \"scripts\": {\n+    \"start\": \"react-scripts start\",\n+    \"build\": \"react-scripts build\",\n+    \"test\": \"react-scripts test\",\n+    \"eject\": \"react-scripts eject\"\n+  },\n+  \"eslintConfig\": {\n+    \"extends\": \"react-app\"\n+  },\n+  \"browserslist\": [\n+    \">0.2%\",\n+    \"not dead\",\n+    \"not ie <= 11\",\n+    \"not op_mini all\"\n+  ],\n+  \"devDependencies\": {\n+    \"jest-dom\": \"3.1.1\",\n+    \"jest-fetch-mock\": \"2.1.1\",\n+    \"react-testing-library\": \"6.0.0\"\n+  }\n+}\ndiff --git a/client/public/favicon.ico b/client/public/favicon.ico\nnew file mode 100644\nindex 0000000..a11777c\nBinary files /dev/null and b/client/public/favicon.ico differ\ndiff --git a/client/public/index.html b/client/public/index.html\nnew file mode 100644\nindex 0000000..75980d5\n--- /dev/null\n+++ b/client/public/index.html\n@@ -0,0 +1,41 @@\n+<!DOCTYPE html>\n+<html lang=\"en\">\n+  <head>\n+    <meta charset=\"utf-8\" />\n+    <link rel=\"shortcut icon\" href=\"%PUBLIC_URL%/favicon.ico\" />\n+    <meta\n+      name=\"viewport\"\n+      content=\"width=device-width, initial-scale=1, shrink-to-fit=no\"\n+    />\n+    <meta name=\"theme-color\" content=\"#000000\" />\n+    <!--\n+      manifest.json provides metadata used when your web app is installed on a\n+      user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/\n+    -->\n+    <link rel=\"manifest\" href=\"%PUBLIC_URL%/manifest.json\" />\n+    <!--\n+      Notice the use of %PUBLIC_URL% in the tags above.\n+      It will be replaced with the URL of the `public` folder during the build.\n+      Only files inside the `public` folder can be referenced from the HTML.\n+\n+      Unlike \"/favicon.ico\" or \"favicon.ico\", \"%PUBLIC_URL%/favicon.ico\" will\n+      work correctly both with client-side routing and a non-root public URL.\n+      Learn how to configure a non-root public URL by running `npm run build`.\n+    -->\n+    <title>React App</title>\n+  </head>\n+  <body>\n+    <noscript>You need to enable JavaScript to run this app.</noscript>\n+    <div id=\"root\"></div>\n+    <!--\n+      This HTML file is a template.\n+      If you open it directly in the browser, you will see an empty page.\n+\n+      You can add webfonts, meta tags, or analytics to this file.\n+      The build step will place the bundled scripts into the <body> tag.\n+\n+      To begin the development, run `npm start` or `yarn start`.\n+      To create a production bundle, use `npm run build` or `yarn build`.\n+    -->\n+  </body>\n+</html>\ndiff --git a/client/public/manifest.json b/client/public/manifest.json\nnew file mode 100644\nindex 0000000..1f2f141\n--- /dev/null\n+++ b/client/public/manifest.json\n@@ -0,0 +1,15 @@\n+{\n+  \"short_name\": \"React App\",\n+  \"name\": \"Create React App Sample\",\n+  \"icons\": [\n+    {\n+      \"src\": \"favicon.ico\",\n+      \"sizes\": \"64x64 32x32 24x24 16x16\",\n+      \"type\": \"image/x-icon\"\n+    }\n+  ],\n+  \"start_url\": \".\",\n+  \"display\": \"standalone\",\n+  \"theme_color\": \"#000000\",\n+  \"background_color\": \"#ffffff\"\n+}\ndiff --git a/client/src/App.jsx b/client/src/App.jsx\nnew file mode 100644\nindex 0000000..fd25c3f\n--- /dev/null\n+++ b/client/src/App.jsx\n@@ -0,0 +1,10 @@\n+import * as React from 'react'\n+import ChatsListScreen from './components/ChatsListScreen'\n+\n+const App = () => (\n+  <div>\n+    <ChatsListScreen />\n+  </div>\n+)\n+\n+export default App\ndiff --git a/client/src/App.test.js b/client/src/App.test.js\nnew file mode 100644\nindex 0000000..a754b20\n--- /dev/null\n+++ b/client/src/App.test.js\n@@ -0,0 +1,9 @@\n+import React from 'react';\n+import ReactDOM from 'react-dom';\n+import App from './App';\n+\n+it('renders without crashing', () => {\n+  const div = document.createElement('div');\n+  ReactDOM.render(<App />, div);\n+  ReactDOM.unmountComponentAtNode(div);\n+});\ndiff --git a/client/src/components/ChatsListScreen/ChatsList.test.tsx b/client/src/components/ChatsListScreen/ChatsList.test.tsx\nnew file mode 100644\nindex 0000000..16e0c8d\n--- /dev/null\n+++ b/client/src/components/ChatsListScreen/ChatsList.test.tsx\n@@ -0,0 +1,36 @@\n+import React from 'react'\n+import ReactDOM from 'react-dom'\n+import { render, waitForDomChange } from 'react-testing-library'\n+import ChatsList from './ChatsList'\n+\n+describe('ChatsList', () => {\n+  it('renders fetched chats data', async () => {\n+    fetch.mockResponseOnce(JSON.stringify({\n+      data: {\n+        chats: [\n+          {\n+            id: 1,\n+            name: 'Foo Bar',\n+            picture: 'https://localhost:4000/picture.jpg',\n+            lastMessage: {\n+              id: 1,\n+              content: 'Hello',\n+              createdAt: new Date(0),\n+            },\n+          },\n+        ],\n+      },\n+    }))\n+\n+    {\n+      const { container, getByTestId } = render(<ChatsList />)\n+\n+      await waitForDomChange({ container })\n+\n+      expect(getByTestId('name')).toHaveTextContent('Foo Bar')\n+      expect(getByTestId('picture')).toHaveAttribute('src', 'https://localhost:4000/picture.jpg')\n+      expect(getByTestId('content')).toHaveTextContent('Hello')\n+      expect(getByTestId('date')).toHaveTextContent('08:00')\n+    }\n+  })\n+})\ndiff --git a/client/src/components/ChatsListScreen/ChatsList.tsx b/client/src/components/ChatsListScreen/ChatsList.tsx\nnew file mode 100644\nindex 0000000..948f767\n--- /dev/null\n+++ b/client/src/components/ChatsListScreen/ChatsList.tsx\n@@ -0,0 +1,110 @@\n+import { List, ListItem } from '@material-ui/core'\n+import moment from 'moment'\n+import * as React from 'react'\n+import { useState, useMemo } from 'react'\n+import styled from 'styled-components'\n+\n+const Container = styled.div `\n+  height: calc(100% - 56px);\n+  overflow-y: overlay;\n+`\n+\n+const StyledList = styled(List) `\n+  padding: 0 !important;\n+`\n+\n+const StyledListItem = styled(ListItem) `\n+  height: 76px;\n+  padding: 0 15px;\n+  display: flex;\n+`\n+\n+const ChatPicture = styled.img `\n+  height: 50px;\n+  width: 50px;\n+  object-fit: cover;\n+  border-radius: 50%;\n+`\n+\n+const ChatInfo = styled.div `\n+  width: calc(100% - 60px);\n+  padding: 15px 0;\n+  margin-left: 10px;\n+  border-bottom: 0.5px solid silver;\n+  position: relative;\n+`\n+\n+const ChatName = styled.div `\n+  margin-top: 5px;\n+`\n+\n+const MessageContent = styled.div `\n+  color: gray;\n+  font-size: 15px;\n+  margin-top: 5px;\n+  text-overflow: ellipsis;\n+  overflow: hidden;\n+  white-space: nowrap;\n+`\n+\n+const MessageDate = styled.div `\n+  position: absolute;\n+  color: gray;\n+  top: 20px;\n+  right: 0;\n+  font-size: 13px;\n+`\n+\n+const getChatsQuery = `\n+  query GetChats {\n+    chats {\n+      id\n+      name\n+      picture\n+      lastMessage {\n+        id\n+        content\n+        createdAt\n+      }\n+    }\n+  }\n+`\n+\n+const ChatsList = () => {\n+  const [chats, setChats] = useState([])\n+\n+  useMemo(async () => {\n+    const body = await fetch(`${process.env.REACT_APP_SERVER_URL}/graphql`, {\n+      method: 'POST',\n+      headers: {\n+        'Content-Type': 'application/json',\n+      },\n+      body: JSON.stringify({ query: getChatsQuery }),\n+    })\n+    const { data: { chats } } = await body.json()\n+    setChats(chats)\n+  }, [true])\n+\n+  return (\n+    <Container>\n+      <StyledList>\n+        {chats.map((chat) => (\n+          <StyledListItem key={chat.id} button>\n+            <ChatPicture data-testid=\"picture\" src={chat.picture} />\n+            <ChatInfo>\n+              <ChatName data-testid=\"name\">{chat.name}</ChatName>\n+              {chat.lastMessage && (\n+                <React.Fragment>\n+                  <MessageContent data-testid=\"content\">{chat.lastMessage.content}</MessageContent>\n+                  <MessageDate data-testid=\"date\">{moment(chat.lastMessage.createdAt).format('HH:mm')}</MessageDate>\n+                </React.Fragment>\n+              )}\n+            </ChatInfo>\n+          </StyledListItem>\n+        ))}\n+      </StyledList>\n+    </Container>\n+  )\n+}\n+\n+export default ChatsList\ndiff --git a/client/src/components/ChatsListScreen/ChatsNavbar.tsx b/client/src/components/ChatsListScreen/ChatsNavbar.tsx\nnew file mode 100644\nindex 0000000..68628c3\n--- /dev/null\n+++ b/client/src/components/ChatsListScreen/ChatsNavbar.tsx\n@@ -0,0 +1,18 @@\n+import { Toolbar } from '@material-ui/core'\n+import * as React from 'react'\n+import styled from 'styled-components'\n+\n+const Container = styled(Toolbar) `\n+  background-color: var(--primary-bg);\n+  color: var(--primary-text);\n+  font-size: 20px;\n+  line-height: 40px;\n+`\n+\n+const ChatsNavbar = () => (\n+  <Container>\n+    Whatsapp Clone\n+  </Container>\n+)\n+\n+export default ChatsNavbar\ndiff --git a/client/src/components/ChatsListScreen/index.tsx b/client/src/components/ChatsListScreen/index.tsx\nnew file mode 100644\nindex 0000000..41fea74\n--- /dev/null\n+++ b/client/src/components/ChatsListScreen/index.tsx\n@@ -0,0 +1,12 @@\n+import * as React from 'react'\n+import ChatsNavbar from './ChatsNavbar'\n+import ChatsList from './ChatsList'\n+\n+const ChatsListScreen = () => (\n+  <div>\n+    <ChatsNavbar />\n+    <ChatsList />\n+  </div>\n+)\n+\n+export default ChatsListScreen\ndiff --git a/client/src/index.css b/client/src/index.css\nnew file mode 100644\nindex 0000000..ea591eb\n--- /dev/null\n+++ b/client/src/index.css\n@@ -0,0 +1,21 @@\n+:root {\n+  --primary-bg: #2c6157;\n+  --secondary-bg: #6fd056;\n+  --primary-text: white;\n+  --secondary-text: white;\n+}\n+\n+body {\n+  margin: 0;\n+  padding: 0;\n+  font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", \"Roboto\", \"Oxygen\",\n+    \"Ubuntu\", \"Cantarell\", \"Fira Sans\", \"Droid Sans\", \"Helvetica Neue\",\n+    sans-serif;\n+  -webkit-font-smoothing: antialiased;\n+  -moz-osx-font-smoothing: grayscale;\n+}\n+\n+code {\n+  font-family: source-code-pro, Menlo, Monaco, Consolas, \"Courier New\",\n+    monospace;\n+}\ndiff --git a/client/src/index.jsx b/client/src/index.jsx\nnew file mode 100644\nindex 0000000..018edbb\n--- /dev/null\n+++ b/client/src/index.jsx\n@@ -0,0 +1,27 @@\n+import { MuiThemeProvider, createMuiTheme } from '@material-ui/core/styles'\n+import React from 'react';\n+import ReactDOM from 'react-dom';\n+import './index.css';\n+import App from './App';\n+import * as serviceWorker from './serviceWorker';\n+\n+const theme = createMuiTheme({\n+  palette: {\n+    primary: { main: '#2c6157' },\n+    secondary: { main: '#6fd056' },\n+  },\n+  typography: {\n+    useNextVariants: true,\n+  },\n+})\n+\n+ReactDOM.render(\n+  <MuiThemeProvider theme={theme}>\n+    <App />\n+  </MuiThemeProvider>\n+, document.getElementById('root'));\n+\n+// If you want your app to work offline and load faster, you can change\n+// unregister() to register() below. Note this comes with some pitfalls.\n+// Learn more about service workers: https://bit.ly/CRA-PWA\n+serviceWorker.unregister();\ndiff --git a/client/src/react-app-env.d.ts b/client/src/react-app-env.d.ts\nnew file mode 100644\nindex 0000000..6431bc5\n--- /dev/null\n+++ b/client/src/react-app-env.d.ts\n@@ -0,0 +1 @@\n+/// <reference types=\"react-scripts\" />\ndiff --git a/client/src/serviceWorker.js b/client/src/serviceWorker.js\nnew file mode 100644\nindex 0000000..f8c7e50\n--- /dev/null\n+++ b/client/src/serviceWorker.js\n@@ -0,0 +1,135 @@\n+// This optional code is used to register a service worker.\n+// register() is not called by default.\n+\n+// This lets the app load faster on subsequent visits in production, and gives\n+// it offline capabilities. However, it also means that developers (and users)\n+// will only see deployed updates on subsequent visits to a page, after all the\n+// existing tabs open on the page have been closed, since previously cached\n+// resources are updated in the background.\n+\n+// To learn more about the benefits of this model and instructions on how to\n+// opt-in, read https://bit.ly/CRA-PWA\n+\n+const isLocalhost = Boolean(\n+  window.location.hostname === 'localhost' ||\n+    // [::1] is the IPv6 localhost address.\n+    window.location.hostname === '[::1]' ||\n+    // 127.0.0.1/8 is considered localhost for IPv4.\n+    window.location.hostname.match(\n+      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n+    )\n+);\n+\n+export function register(config) {\n+  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n+    // The URL constructor is available in all browsers that support SW.\n+    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n+    if (publicUrl.origin !== window.location.origin) {\n+      // Our service worker won't work if PUBLIC_URL is on a different origin\n+      // from what our page is served on. This might happen if a CDN is used to\n+      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n+      return;\n+    }\n+\n+    window.addEventListener('load', () => {\n+      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n+\n+      if (isLocalhost) {\n+        // This is running on localhost. Let's check if a service worker still exists or not.\n+        checkValidServiceWorker(swUrl, config);\n+\n+        // Add some additional logging to localhost, pointing developers to the\n+        // service worker/PWA documentation.\n+        navigator.serviceWorker.ready.then(() => {\n+          console.log(\n+            'This web app is being served cache-first by a service ' +\n+              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n+          );\n+        });\n+      } else {\n+        // Is not localhost. Just register service worker\n+        registerValidSW(swUrl, config);\n+      }\n+    });\n+  }\n+}\n+\n+function registerValidSW(swUrl, config) {\n+  navigator.serviceWorker\n+    .register(swUrl)\n+    .then(registration => {\n+      registration.onupdatefound = () => {\n+        const installingWorker = registration.installing;\n+        if (installingWorker == null) {\n+          return;\n+        }\n+        installingWorker.onstatechange = () => {\n+          if (installingWorker.state === 'installed') {\n+            if (navigator.serviceWorker.controller) {\n+              // At this point, the updated precached content has been fetched,\n+              // but the previous service worker will still serve the older\n+              // content until all client tabs are closed.\n+              console.log(\n+                'New content is available and will be used when all ' +\n+                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n+              );\n+\n+              // Execute callback\n+              if (config && config.onUpdate) {\n+                config.onUpdate(registration);\n+              }\n+            } else {\n+              // At this point, everything has been precached.\n+              // It's the perfect time to display a\n+              // \"Content is cached for offline use.\" message.\n+              console.log('Content is cached for offline use.');\n+\n+              // Execute callback\n+              if (config && config.onSuccess) {\n+                config.onSuccess(registration);\n+              }\n+            }\n+          }\n+        };\n+      };\n+    })\n+    .catch(error => {\n+      console.error('Error during service worker registration:', error);\n+    });\n+}\n+\n+function checkValidServiceWorker(swUrl, config) {\n+  // Check if the service worker can be found. If it can't reload the page.\n+  fetch(swUrl)\n+    .then(response => {\n+      // Ensure service worker exists, and that we really are getting a JS file.\n+      const contentType = response.headers.get('content-type');\n+      if (\n+        response.status === 404 ||\n+        (contentType != null && contentType.indexOf('javascript') === -1)\n+      ) {\n+        // No service worker found. Probably a different app. Reload the page.\n+        navigator.serviceWorker.ready.then(registration => {\n+          registration.unregister().then(() => {\n+            window.location.reload();\n+          });\n+        });\n+      } else {\n+        // Service worker found. Proceed as normal.\n+        registerValidSW(swUrl, config);\n+      }\n+    })\n+    .catch(() => {\n+      console.log(\n+        'No internet connection found. App is running in offline mode.'\n+      );\n+    });\n+}\n+\n+export function unregister() {\n+  if ('serviceWorker' in navigator) {\n+    navigator.serviceWorker.ready.then(registration => {\n+      registration.unregister();\n+    });\n+  }\n+}\ndiff --git a/client/src/setupTests.ts b/client/src/setupTests.ts\nnew file mode 100644\nindex 0000000..c42be90\n--- /dev/null\n+++ b/client/src/setupTests.ts\n@@ -0,0 +1,7 @@\n+import 'jest-dom/extend-expect'\n+import { GlobalWithFetchMock } from 'jest-fetch-mock'\n+import { act } from 'react-testing-library'\n+\n+const customGlobal: GlobalWithFetchMock = global as GlobalWithFetchMock\n+customGlobal.fetch = require('jest-fetch-mock')\n+customGlobal.fetchMock = customGlobal.fetch\ndiff --git a/client/tsconfig.json b/client/tsconfig.json\nnew file mode 100644\nindex 0000000..ad80f6a\n--- /dev/null\n+++ b/client/tsconfig.json\n@@ -0,0 +1,35 @@\n+{\n+  \"compilerOptions\": {\n+    \"outDir\": \"build/dist\",\n+    \"sourceMap\": true,\n+    \"declaration\": false,\n+    \"moduleResolution\": \"node\",\n+    \"emitDecoratorMetadata\": true,\n+    \"experimentalDecorators\": true,\n+    \"downlevelIteration\": true,\n+    \"resolveJsonModule\": true,\n+    \"target\": \"es5\",\n+    \"jsx\": \"preserve\",\n+    \"typeRoots\": [\n+      \"node_modules/@types\"\n+    ],\n+    \"lib\": [\n+      \"es2017\",\n+      \"dom\",\n+      \"esnext.asynciterable\"\n+    ],\n+    \"allowJs\": true,\n+    \"skipLibCheck\": true,\n+    \"esModuleInterop\": false,\n+    \"allowSyntheticDefaultImports\": true,\n+    \"forceConsistentCasingInFileNames\": true,\n+    \"isolatedModules\": true,\n+    \"noEmit\": true,\n+    \"noImplicitAny\": false,\n+    \"strict\": false,\n+    \"module\": \"esnext\"\n+  },\n+  \"include\": [\n+    \"src\"\n+  ]\n+}\ndiff --git a/client/tslint.json b/client/tslint.json\nnew file mode 100644\nindex 0000000..446ec3d\n--- /dev/null\n+++ b/client/tslint.json\n@@ -0,0 +1,29 @@\n+{\n+  \"extends\": [\"tslint:recommended\", \"tslint-react\", \"tslint-config-prettier\"],\n+  \"rules\": {\n+    \"ordered-imports\": false,\n+    \"object-literal-sort-keys\": false,\n+    \"jsx-boolean-value\": false,\n+    \"interface-name\" : false,\n+    \"variable-name\": false,\n+    \"no-string-literal\": false,\n+    \"no-namespace\": false,\n+    \"interface-over-type-literal\": false,\n+    \"no-shadowed-variable\": false,\n+    \"curly\": false,\n+    \"no-label\": false,\n+    \"no-empty\": false,\n+    \"no-debugger\": false,\n+    \"no-console\": false,\n+    \"array-type\": false\n+  },\n+  \"linterOptions\": {\n+    \"exclude\": [\n+      \"config/**/*.js\",\n+      \"node_modules/**/*.ts\",\n+      \"coverage/lcov-report/*.js\",\n+      \"*.json\",\n+      \"**/*.json\"\n+    ]\n+  }\n+}\ndiff --git a/package.json b/package.json\nnew file mode 100644\nindex 0000000..008b058\n--- /dev/null\n+++ b/package.json\n@@ -0,0 +1,9 @@\n+{\n+  \"name\": \"whatsapp-clone-tutorial\",\n+  \"description\": \"A newly created Tortilla project\",\n+  \"private\": true,\n+  \"repository\": {\n+    \"type\": \"git\",\n+    \"url\": \"https://github.com/Urigo/WhatsApp-Clone-Tutorial.git\"\n+  }\n+}\ndiff --git a/server/.gitignore b/server/.gitignore\nnew file mode 100644\nindex 0000000..5171c54\n--- /dev/null\n+++ b/server/.gitignore\n@@ -0,0 +1,2 @@\n+node_modules\n+npm-debug.log\n\\ No newline at end of file\ndiff --git a/server/db.ts b/server/db.ts\nnew file mode 100644\nindex 0000000..b641f37\n--- /dev/null\n+++ b/server/db.ts\n@@ -0,0 +1,49 @@\n+export const messages = [\n+  {\n+    id: 1,\n+    content: \"You on your way?\",\n+    createdAt: new Date(Date.now() - 60 * 1000 * 1000),\n+  },\n+  {\n+    id: 2,\n+    content: \"Hey, it's me\",\n+    createdAt: new Date(Date.now() - 2 * 60 * 1000 * 1000),\n+  },\n+  {\n+    id: 3,\n+    content: \"I should buy a boat\",\n+    createdAt: new Date(Date.now() - 24 * 60 * 1000 * 1000),\n+  },\n+  {\n+    id: 4,\n+    content: \"This is wicked good ice cream.\",\n+    createdAt: new Date(Date.now() - 14 * 24 * 60 * 1000 * 1000),\n+  },\n+]\n+\n+export const chats = [\n+  {\n+    id: 1,\n+    name: 'Ethan Gonzalez',\n+    picture: 'https://randomuser.me/api/portraits/thumb/men/1.jpg',\n+    lastMessage: 1,\n+  },\n+  {\n+    id: 2,\n+    name: 'Bryan Wallace',\n+    picture: 'https://randomuser.me/api/portraits/thumb/men/2.jpg',\n+    lastMessage: 2,\n+  },\n+  {\n+    id: 3,\n+    name: 'Avery Stewart',\n+    picture: 'https://randomuser.me/api/portraits/thumb/women/1.jpg',\n+    lastMessage: 3,\n+  },\n+  {\n+    id: 4,\n+    name: 'Katie Peterson',\n+    picture: 'https://randomuser.me/api/portraits/thumb/women/2.jpg',\n+    lastMessage: 4,\n+  },\n+]\ndiff --git a/server/index.ts b/server/index.ts\nnew file mode 100644\nindex 0000000..b9b7f0e\n--- /dev/null\n+++ b/server/index.ts\n@@ -0,0 +1,27 @@\n+import { ApolloServer, gql } from 'apollo-server-express'\n+import bodyParser from 'body-parser'\n+import cors from 'cors'\n+import express from 'express'\n+import schema from './schema'\n+\n+const app = express()\n+\n+app.use(cors())\n+app.use(bodyParser.json())\n+\n+app.get('/_ping', (req, res) => {\n+  res.send('pong')\n+})\n+\n+const server = new ApolloServer({ schema })\n+\n+server.applyMiddleware({\n+  app,\n+  path: '/graphql',\n+})\n+\n+const port = process.env.PORT || 4000\n+\n+app.listen(port, () => {\n+  console.log(`Server is listening on port ${port}`)\n+})\ndiff --git a/server/package.json b/server/package.json\nnew file mode 100644\nindex 0000000..ab050f9\n--- /dev/null\n+++ b/server/package.json\n@@ -0,0 +1,38 @@\n+{\n+  \"name\": \"whatsapp-clone-server\",\n+  \"description\": \"A newly created Tortilla project\",\n+  \"private\": true,\n+  \"scripts\": {\n+    \"start\": \"ts-node index.ts\",\n+    \"test\": \"jest\"\n+  },\n+  \"devDependencies\": {\n+    \"@types/body-parser\": \"1.17.0\",\n+    \"@types/cors\": \"2.8.4\",\n+    \"@types/express\": \"4.16.1\",\n+    \"@types/graphql\": \"14.0.7\",\n+    \"@types/graphql-iso-date\": \"3.3.1\",\n+    \"@types/jest\": \"24.0.11\",\n+    \"@types/node\": \"11.11.0\",\n+    \"ts-jest\": \"24.0.0\",\n+    \"jest\": \"24.5.0\",\n+    \"ts-node\": \"8.0.3\",\n+    \"typescript\": \"3.3.3333\"\n+  },\n+  \"dependencies\": {\n+    \"apollo-server-express\": \"2.4.8\",\n+    \"apollo-server-testing\": \"2.4.8\",\n+    \"body-parser\": \"1.18.3\",\n+    \"cors\": \"2.8.5\",\n+    \"express\": \"4.16.4\",\n+    \"graphql\": \"14.1.1\",\n+    \"graphql-import\": \"0.7.1\",\n+    \"graphql-iso-date\": \"3.6.1\",\n+    \"graphql-tools\": \"4.0.4\"\n+  },\n+  \"jest\": {\n+    \"transform\": {\n+      \"^.+\\\\.(js|jsx|ts|tsx)$\": \"<rootDir>/node_modules/ts-jest\"\n+    }\n+  }\n+}\ndiff --git a/server/schema/index.ts b/server/schema/index.ts\nnew file mode 100644\nindex 0000000..b94bc37\n--- /dev/null\n+++ b/server/schema/index.ts\n@@ -0,0 +1,7 @@\n+import { importSchema } from 'graphql-import'\n+import { makeExecutableSchema } from 'graphql-tools'\n+import resolvers from './resolvers'\n+\n+const typeDefs = importSchema('schema/typeDefs.graphql')\n+\n+export default makeExecutableSchema({ resolvers, typeDefs })\ndiff --git a/server/schema/resolvers.ts b/server/schema/resolvers.ts\nnew file mode 100644\nindex 0000000..ede702f\n--- /dev/null\n+++ b/server/schema/resolvers.ts\n@@ -0,0 +1,18 @@\n+import { GraphQLDateTime } from 'graphql-iso-date'\n+import { chats, messages } from '../db'\n+\n+export default {\n+  Date: GraphQLDateTime,\n+\n+  Chat: {\n+    lastMessage(chat: any) {\n+      return messages.find(m => m.id === chat.lastMessage)\n+    },\n+  },\n+\n+  Query: {\n+    chats() {\n+      return chats\n+    },\n+  },\n+}\ndiff --git a/server/schema/typeDefs.graphql b/server/schema/typeDefs.graphql\nnew file mode 100644\nindex 0000000..137124b\n--- /dev/null\n+++ b/server/schema/typeDefs.graphql\n@@ -0,0 +1,18 @@\n+scalar Date\n+\n+type Message {\n+  id: ID!\n+  content: String!\n+  createdAt: Date!\n+}\n+\n+type Chat {\n+  id: ID!\n+  name: String!\n+  picture: String\n+  lastMessage: Message\n+}\n+\n+type Query {\n+  chats: [Chat!]!\n+}\ndiff --git a/server/tests/queries/__snapshots__/getChats.test.ts.snap b/server/tests/queries/__snapshots__/getChats.test.ts.snap\nnew file mode 100644\nindex 0000000..6f81d55\n--- /dev/null\n+++ b/server/tests/queries/__snapshots__/getChats.test.ts.snap\n@@ -0,0 +1,48 @@\n+// Jest Snapshot v1, https://goo.gl/fbAQLP\n+\n+exports[`Query.chats should fetch all chats 1`] = `\n+Object {\n+  \"chats\": Array [\n+    Object {\n+      \"id\": \"1\",\n+      \"lastMessage\": Object {\n+        \"content\": \"You on your way?\",\n+        \"createdAt\": \"2019-03-12T13:24:18.174Z\",\n+        \"id\": \"1\",\n+      },\n+      \"name\": \"Ethan Gonzalez\",\n+      \"picture\": \"https://randomuser.me/api/portraits/thumb/men/1.jpg\",\n+    },\n+    Object {\n+      \"id\": \"2\",\n+      \"lastMessage\": Object {\n+        \"content\": \"Hey, it's me\",\n+        \"createdAt\": \"2019-03-11T20:44:18.174Z\",\n+        \"id\": \"2\",\n+      },\n+      \"name\": \"Bryan Wallace\",\n+      \"picture\": \"https://randomuser.me/api/portraits/thumb/men/2.jpg\",\n+    },\n+    Object {\n+      \"id\": \"3\",\n+      \"lastMessage\": Object {\n+        \"content\": \"I should buy a boat\",\n+        \"createdAt\": \"2019-02-24T14:04:18.174Z\",\n+        \"id\": \"3\",\n+      },\n+      \"name\": \"Avery Stewart\",\n+      \"picture\": \"https://randomuser.me/api/portraits/thumb/women/1.jpg\",\n+    },\n+    Object {\n+      \"id\": \"4\",\n+      \"lastMessage\": Object {\n+        \"content\": \"This is wicked good ice cream.\",\n+        \"createdAt\": \"2018-07-22T22:04:18.174Z\",\n+        \"id\": \"4\",\n+      },\n+      \"name\": \"Katie Peterson\",\n+      \"picture\": \"https://randomuser.me/api/portraits/thumb/women/2.jpg\",\n+    },\n+  ],\n+}\n+`;\ndiff --git a/server/tests/queries/getChats.test.ts b/server/tests/queries/getChats.test.ts\nnew file mode 100644\nindex 0000000..09d876c\n--- /dev/null\n+++ b/server/tests/queries/getChats.test.ts\n@@ -0,0 +1,32 @@\n+import { createTestClient } from 'apollo-server-testing'\n+import { ApolloServer, gql } from 'apollo-server-express'\n+import schema from '../../schema'\n+\n+describe('Query.chats', () => {\n+  it('should fetch all chats', async () => {\n+    const server = new ApolloServer({ schema })\n+\n+    const { query } = createTestClient(server)\n+\n+    const res = await query({\n+      query: gql `\n+        query GetChats {\n+          chats {\n+            id\n+            name\n+            picture\n+            lastMessage {\n+              id\n+              content\n+              createdAt\n+            }\n+          }\n+        }\n+      `,\n+    })\n+\n+    expect(res.data).toBeDefined()\n+    expect(res.errors).toBeUndefined()\n+    expect(res.data).toMatchSnapshot()\n+  })\n+})\ndiff --git a/server/tsconfig.json b/server/tsconfig.json\nnew file mode 100644\nindex 0000000..fe56553\n--- /dev/null\n+++ b/server/tsconfig.json\n@@ -0,0 +1,16 @@\n+{\n+  \"compilerOptions\": {\n+    \"target\": \"es2018\",\n+    \"module\": \"commonjs\",\n+    \"lib\": [\n+      \"es2018\",\n+      \"esnext.asynciterable\"\n+    ],\n+    \"strict\": true,\n+    \"strictFunctionTypes\": false,\n+    \"strictPropertyInitialization\": false,\n+    \"esModuleInterop\": true,\n+    \"experimentalDecorators\": true,\n+    \"emitDecoratorMetadata\": true\n+  }\n+}\n",
        "manuals": [
          {
            "manualTitle": "Whatsapp Clone Tutorial",
            "stepRevision": "2e85335942a9f7625c9b752dc89c0fe9ba9e81ad",
            "manualView": "![whatsapp-clone](https://user-images.githubusercontent.com/7648874/54141944-9f801a80-4461-11e9-85a1-bcb161d9a6c6.png)\n\nWhatsapp Clone is an open-source tutorial that will guide you through step-by-step on how to create a full-stack hybrid web-app.\n\nThe software world is evolving quickly, and oftentimes people find themselves left behind, even the most experienced ones. The purpose of this tutorial is to completely demystify the confusion, and be the main guide on how to do things properly.\n\nThis tutorial is for anyone who has ever asked himself or herself one of the following questions or similar:\n\n- How do people build an app today?\n- What are the “hottest”, most leading technologies currently in the ecosystem?\n- What are the best practices for using technology XXX?\n- What is the purpose of technology XXX?\n- How does technology XXX work?\n- How do I use technology XXX?\n- How do I migrate to the new version of technology XXX?\n- Why should I use technology XXX over technology YYY?\n\nAll of the above and more can be answered in the tutorial. Whether you’re a beginner, intermediate or a professional, we will have the answers you’re looking for.\n\n**What technologies does Whatsapp Clone uses?**\n\nCurrently, Whatsapp Clone uses:\n\n- [React (with Hooks and Suspense)](http://react.com)\n- [Styled-Components](https://styled-components.com)\n- [Material-UI](https://material-ui.com)\n- [TypeScript](https://typescriptlang.org)\n- [Apollo GraphQL](https://www.apollographql.com)\n- [GraphQL Code Generator](http://graphql-code-generator.com)\n- [GraphQL Modules](https://graphql-modules.com)\n- [PostgreSQL](https://www.postgresql.org/)\n- [TypeORM](https://github.com/typeorm/typeorm)\n\nThe point of this tutorial is not to be bound to a certain technology, but rather keep itself aligned with the ecosystem. When a new technology comes out, and it’s better and more popular, Whatsapp Clone will use it at some point (and full migration instructions).\n\n**P2P tutorial for the community by the community**\n\nWhat better way would it be to keep Whatsapp Clone aligned with the ecosystem than letting the community maintain it? Rather than dictating what technologies will be used in the app or how’s the tutorial gonna be written, you’re gonna decide how things are gonna be. That’s why we made it open source:\n\n- [Whatsapp Clone - Client](https://github.com/Urigo/WhatsApp-Clone-Client-React/tree/step-by-step-final)\n- [Whatsapp Clone - Server](https://github.com/Urigo/WhatsApp-Clone-server/step-by-step-final)\n\nWe’ve also made sure to publish some important documents so you can get more involved. You can track our progress and comment your suggestions, since everything is based on Google Docs and is updated live:\n\n- [Road map](https://docs.google.com/document/d/1p2Zio6Js2eoFfHs9CjIMF6jTuNyD4eQEHlgEAKhAqM8/edit?usp=sharing)\n- [Chapter manuals] (https://drive.google.com/open?id=1ITxOniS_S3sgZfunLvtJ1L9P6Fj1YOLlFHhoQPjT3S0)\n\n**Migration instructions included**\n\nThe are great tutorials out there, but almost none of them shows you what changes you should make in your app in order to be aligned with a new version of a certain technology. Technologies are being updated by the minute, some changes are minor and insignificant, but often times a breaking change will be made in which case we need to know how we can adapt to that change. Thanks to the [Tortilla platform](https://tortilla.academy), we can provide you with a git-diff that will show you what changes were made between each and every released version of the Whatsapp Clone tutorial since the beginning of history. This way you can easily notice the changes in APIs and migrate your app in no time.\n\n![tutorial-versions-diff](https://user-images.githubusercontent.com/7648874/54142148-0f8ea080-4462-11e9-9522-ec9997b76169.png)\n\n**Prerequisites**\n\n- JavaScript\n- TypeScript\n- JSX\n- HTML\n- CSS\n- Node.JS\n- NPM\n- React\n- SQL\n\nOS operations such as navigating to a folder, or creating a folder, are all gonna be written in Bash, but the instructions are OS agnostic and can be applied on any machine that is web-compatible.\n\n**What’s on the tutorial?**\n\nWhatsapp Clone is built chronologically, from the most basic, to more higher level features, so be sure to execute it in the right order. Each step is focused on a different subject, so by the end of it you’ll have a new feature and a new set of knowledge that you can start implementing in your everyday scenario immediately.\n\nCurrently, Whatsapp Clone includes the following chapters:\n\n- [Step 1: Creating a basic React APP with a basic view.](https://github.com/Urigo/WhatsApp-Clone-Tutorial/blob/final/.tortilla/manuals/views/step1.md)\n- [Step 2: Styling with Material-UI and Styled-Components.](https://github.com/Urigo/WhatsApp-Clone-Tutorial/blob/final/.tortilla/manuals/views/step2.md)\n- [Step 3: Setting a basic Node.JS server with basic a basic REST endpoint.](https://github.com/Urigo/WhatsApp-Clone-Tutorial/blob/final/.tortilla/manuals/views/step3.md)\n- [Step 4: Transition to GraphQL.](https://github.com/Urigo/WhatsApp-Clone-Tutorial/blob/final/.tortilla/manuals/views/step4.md)\n- Step N: TBA\n\nWhatsapp Clone is updated on a regular basis, so you should expect more steps and extensions to it not long from now. You can keep track of our [road map](https://docs.google.com/document/d/1p2Zio6Js2eoFfHs9CjIMF6jTuNyD4eQEHlgEAKhAqM8/edit?usp=sharing) to see what’s upcoming."
          },
          {
            "manualTitle": "Step 1: Creating a basic React APP with a basic view",
            "stepRevision": "05aad5d293339dd17c6cb1da677ddc2ec843b560",
            "manualView": "In this chapter we will learn how to create a basic React app. The app will contain a basic view that will render a list of conversations within our app. Everything should be done gradually, so for now, instead of using real data, we will use in-memory fake data instead of calling a server.\n\nThere are many ways to create an application. Indeed, you can create it from scratch, but the point behind development is that you'll make the least amount of work if possible. The point is to create a working product, and time is what matters, thus we're gonna use a boilerplate to kick-start our application. When it comes to React apps, the most popular is [`create-react-app`](https://github.com/facebook/create-react-app), which is pretty generic and easy to use. In addition, it's officially maintained by Facebook, the creators of React.\n\n`create-react-app` is a CLI that is installable via NPM:\n\n    $ npm install -g create-react-app\n\nOnce you do so, you will have it available in your terminal. If the installation failed, try to run the command as `sudo`:\n\n\t$ sudo npm install -g create-react-app\n\nUsing the `create` command, we can create the basis for our Whatsapp Clone:\n\n    $ create-react-app create whatsapp-clone-client\n\n> Note how we used the `client` prefix. That's because we're planning to create a server as well in further chapters.\n\nIt will create a directory called `whatsapp-clone-client` inside the current folder. Inside that directory, it will generate the initial project structure and install the transitive dependencies:\n\n    my-app\n    ├── README.md\n    ├── node_modules\n    ├── package.json\n    ├── .gitignore\n    ├── public\n    │   ├── favicon.ico\n    │   ├── index.html\n    │   └── manifest.json\n    └── src\n        ├── App.css\n        ├── App.js\n        ├── App.test.js\n        ├── index.css\n        ├── index.js\n        ├── logo.svg\n        └── serviceWorker.js\n\nNo configuration or complicated folder structures, just the files you need to build your app. Once the installation is done, you can open your project folder:\n\n\t$ cd whatsapp-clone-client\n\nInside the newly created project, you can run some built-in commands:\n\n\t$ npm start\n\nRuns the app in development mode. Open `http://localhost:3000` to view it in the browser:\n\n![boilerplate-page](https://user-images.githubusercontent.com/7648874/54026782-025f8080-41da-11e9-9a4e-796fe15e8d03.png)\n\nThe project that was created for us by `create-react-app` is highly functional and ready to use, but it's implemented in JavaScript. In our project, we're gonna use TypeScript. There's no right or wrong here, it's more of a personal choice. The main advantage of using TypeScript over using plain JavaScript is that we get to tell the compiler what types and data structures we expect in certain places, so that the compiler (which unlike a human never forgets) will remind us when we make a mistake and assume something that is not true.\n\nLuckily enough, `create-react-app` comes with a TypeScript support right out of the box, we only need to make a few adjustments in-order to make it work. First we need to install the TypeScript package, which is essential for TypeScript to function:\n\n\t$ yarn add typescript\n\nEvery TypeScript project requires a `tsconfig.json` to be defined. This configuration file will dictate the behavior of TypeScript within that project. More about `tsconfig.json` and its available options can be found in the [official TypeScript handbook](https://www.typescriptlang.org/docs/handbook/tsconfig-json.html). This is the config file we're gonna use in our project:\n\n[{]: <helper> (diffStep \"1.1\" files=\"tsconfig.json\" module=\"client\")\n\n#### [Step 1.1: Setup TypeScript](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/2145153)\n\n##### Added tsconfig.json\n```diff\n@@ -0,0 +1,35 @@\n+┊  ┊ 1┊{\n+┊  ┊ 2┊  \"compilerOptions\": {\n+┊  ┊ 3┊    \"outDir\": \"build/dist\",\n+┊  ┊ 4┊    \"sourceMap\": true,\n+┊  ┊ 5┊    \"declaration\": false,\n+┊  ┊ 6┊    \"moduleResolution\": \"node\",\n+┊  ┊ 7┊    \"emitDecoratorMetadata\": true,\n+┊  ┊ 8┊    \"experimentalDecorators\": true,\n+┊  ┊ 9┊    \"downlevelIteration\": true,\n+┊  ┊10┊    \"resolveJsonModule\": true,\n+┊  ┊11┊    \"target\": \"es5\",\n+┊  ┊12┊    \"jsx\": \"preserve\",\n+┊  ┊13┊    \"typeRoots\": [\n+┊  ┊14┊      \"node_modules/@types\"\n+┊  ┊15┊    ],\n+┊  ┊16┊    \"lib\": [\n+┊  ┊17┊      \"es2017\",\n+┊  ┊18┊      \"dom\",\n+┊  ┊19┊      \"esnext.asynciterable\"\n+┊  ┊20┊    ],\n+┊  ┊21┊    \"allowJs\": true,\n+┊  ┊22┊    \"skipLibCheck\": true,\n+┊  ┊23┊    \"esModuleInterop\": false,\n+┊  ┊24┊    \"allowSyntheticDefaultImports\": true,\n+┊  ┊25┊    \"forceConsistentCasingInFileNames\": true,\n+┊  ┊26┊    \"isolatedModules\": true,\n+┊  ┊27┊    \"noEmit\": true,\n+┊  ┊28┊    \"noImplicitAny\": false,\n+┊  ┊29┊    \"strict\": false,\n+┊  ┊30┊    \"module\": \"esnext\"\n+┊  ┊31┊  },\n+┊  ┊32┊  \"include\": [\n+┊  ┊33┊    \"src\"\n+┊  ┊34┊  ]\n+┊  ┊35┊}\n```\n\n[}]: #\n\nWe're also gonna add a `tslint.json` file into the project - a file which will determine the linting preferences for our project. All rules are listed and explained in the [official rules doc page](https://palantir.github.io/tslint/rules/). We will use the following rules:\n\n[{]: <helper> (diffStep \"1.1\" files=\"tslint.json\" module=\"client\")\n\n#### [Step 1.1: Setup TypeScript](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/2145153)\n\n##### Added tslint.json\n```diff\n@@ -0,0 +1,29 @@\n+┊  ┊ 1┊{\n+┊  ┊ 2┊  \"extends\": [\"tslint:recommended\", \"tslint-react\", \"tslint-config-prettier\"],\n+┊  ┊ 3┊  \"rules\": {\n+┊  ┊ 4┊    \"ordered-imports\": false,\n+┊  ┊ 5┊    \"object-literal-sort-keys\": false,\n+┊  ┊ 6┊    \"jsx-boolean-value\": false,\n+┊  ┊ 7┊    \"interface-name\" : false,\n+┊  ┊ 8┊    \"variable-name\": false,\n+┊  ┊ 9┊    \"no-string-literal\": false,\n+┊  ┊10┊    \"no-namespace\": false,\n+┊  ┊11┊    \"interface-over-type-literal\": false,\n+┊  ┊12┊    \"no-shadowed-variable\": false,\n+┊  ┊13┊    \"curly\": false,\n+┊  ┊14┊    \"no-label\": false,\n+┊  ┊15┊    \"no-empty\": false,\n+┊  ┊16┊    \"no-debugger\": false,\n+┊  ┊17┊    \"no-console\": false,\n+┊  ┊18┊    \"array-type\": false\n+┊  ┊19┊  },\n+┊  ┊20┊  \"linterOptions\": {\n+┊  ┊21┊    \"exclude\": [\n+┊  ┊22┊      \"config/**/*.js\",\n+┊  ┊23┊      \"node_modules/**/*.ts\",\n+┊  ┊24┊      \"coverage/lcov-report/*.js\",\n+┊  ┊25┊      \"*.json\",\n+┊  ┊26┊      \"**/*.json\"\n+┊  ┊27┊    ]\n+┊  ┊28┊  }\n+┊  ┊29┊}\n```\n\n[}]: #\n\nOnce we will run the app for the first time, `react-scripts` (`create-react-app` utility scripts package) should automatically initialize some additional TypeScript related files:\n\n\t$ npm start\n\nSince we're gonna use the new React [Hooks](https://reactjs.org/docs/hooks-intro.html) and [Suspense](https://reactjs.org/docs/react-api.html#reactsuspense) mechanisms, **make sure that your app uses React version 16.8 or above, otherwise it won't work.** The React version can be determined simply by looking at the `package.json` file. If by any chance your React version is lower than the required one, be sure to upgrade the version of `create-react-app` by upgrading it to the latest one and repeat the process of the project creation. Just in case, `create-react-app` can be upgrade by re-running the install command:\n\n\t$ npm install -g create-react-app\n\nAssuming that everything is set, we will now create our first screen - ChatsListScreen. The ChatsListScreen component is responsible for showing the active conversations within our app. Everything should be done gradually, so for now, instead of using real data, we will use in-memory fake data. Further in this tutorial, we will also create a server that will serve that data and connect it to our client.\n\nIt's best to first schematically plan how our view's gonna look like. This would help us illustrate the intended view and also understand which React.Components / elements take part in it. This is how our screen's gonna look like:\n\n![chatslistscreen](https://user-images.githubusercontent.com/7648874/54027873-01305280-41de-11e9-9df0-5ad9c9c2f226.png)\n\nLet's break down the image above and see what components are we gonna have in the ChatsListScreen:\n\n- Navbar -  Which should contain a simple static title for now.\n- ChatsList - Where each item's gonna contain some data regards the user we're chatting with and information about the chat.\n\nReact apps tend to store React.Components under a directory located at `src/components`, and so we're gonna follow this pattern. We will create a directory called ChatsListScreen in the `components` dir where we're simply gonna import and put together the Navbar and ChatsList components. This is how the contents of that directory should look like:\n\n    ChatsListScreen\n    ├── index.tsx\n    ├── ChatsList\n    └── ChatsNavbar\n\nWe will use the `index.tsx` file to define that component, this way we can import it using the directory name:\n\n[{]: <helper> (diffStep \"1.2\" files=\"components/ChatsListScreen/index.jsx\" module=\"client\")\n\n#### [Step 1.2: Implement ChatsListScreen](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/26d5a7d)\n\n\n\n[}]: #\n\nNow we can implement the Navbar component, which doesn't have much for now except some text describing the app:\n\n[{]: <helper> (diffStep \"1.2\" files=\"components/ChatsListScreen/ChatsNavbar.jsx\" module=\"client\")\n\n#### [Step 1.2: Implement ChatsListScreen](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/26d5a7d)\n\n\n\n[}]: #\n\nAnd the ChatsList component:\n\n[{]: <helper> (diffStep \"1.2\" files=\"components/ChatsListScreen/ChatsList.jsx\" module=\"client\")\n\n#### [Step 1.2: Implement ChatsListScreen](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/26d5a7d)\n\n\n\n[}]: #\n\nYou can see in the code-diff above how we used the [`moment`](https://momentjs.com/) library to wrap `lastMessage.createdAt`. Moment has the ability to wrap date objects nicely and rewrite them in a pretty format. This way we can have an elegant time format at which the message was sent e.g. `11:34`. To install:\n\n\t$ yarn add moment\n\nThe ChatsList component has no event handlers and it's completely non-interactive as for now, that means that you can't click or tap anything yet, but as we go further in the tutorial we will add the necessary event handlers. Note how we used the `db.ts` module to get the chats data. `db.ts` is a temporary mock for our data-source and should be removed once we have a server up and running. Here's how our DB looks like:\n\n[{]: <helper> (diffStep \"1.3\" module=\"client\")\n\n#### [Step 1.3: Add db mock](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/996b12d)\n\n##### Added src&#x2F;db.ts\n```diff\n@@ -0,0 +1,49 @@\n+┊  ┊ 1┊export const messages = [\n+┊  ┊ 2┊  {\n+┊  ┊ 3┊    id: 1,\n+┊  ┊ 4┊    content: \"You on your way?\",\n+┊  ┊ 5┊    createdAt: new Date(Date.now() - 60 * 1000 * 1000),\n+┊  ┊ 6┊  },\n+┊  ┊ 7┊  {\n+┊  ┊ 8┊    id: 2,\n+┊  ┊ 9┊    content: \"Hey, it's me\",\n+┊  ┊10┊    createdAt: new Date(Date.now() - 2 * 60 * 1000 * 1000),\n+┊  ┊11┊  },\n+┊  ┊12┊  {\n+┊  ┊13┊    id: 3,\n+┊  ┊14┊    content: \"I should buy a boat\",\n+┊  ┊15┊    createdAt: new Date(Date.now() - 24 * 60 * 1000 * 1000),\n+┊  ┊16┊  },\n+┊  ┊17┊  {\n+┊  ┊18┊    id: 4,\n+┊  ┊19┊    content: \"This is wicked good ice cream.\",\n+┊  ┊20┊    createdAt: new Date(Date.now() - 14 * 24 * 60 * 1000 * 1000),\n+┊  ┊21┊  },\n+┊  ┊22┊]\n+┊  ┊23┊\n+┊  ┊24┊export const chats = [\n+┊  ┊25┊  {\n+┊  ┊26┊    id: 1,\n+┊  ┊27┊    name: 'Ethan Gonzalez',\n+┊  ┊28┊    picture: 'https://randomuser.me/api/portraits/thumb/men/1.jpg',\n+┊  ┊29┊    lastMessage: messages.find(m => m.id === 1),\n+┊  ┊30┊  },\n+┊  ┊31┊  {\n+┊  ┊32┊    id: 2,\n+┊  ┊33┊    name: 'Bryan Wallace',\n+┊  ┊34┊    picture: 'https://randomuser.me/api/portraits/thumb/men/2.jpg',\n+┊  ┊35┊    lastMessage: messages.find(m => m.id === 2),\n+┊  ┊36┊  },\n+┊  ┊37┊  {\n+┊  ┊38┊    id: 3,\n+┊  ┊39┊    name: 'Avery Stewart',\n+┊  ┊40┊    picture: 'https://randomuser.me/api/portraits/thumb/women/1.jpg',\n+┊  ┊41┊    lastMessage: messages.find(m => m.id === 3),\n+┊  ┊42┊  },\n+┊  ┊43┊  {\n+┊  ┊44┊    id: 4,\n+┊  ┊45┊    name: 'Katie Peterson',\n+┊  ┊46┊    picture: 'https://randomuser.me/api/portraits/thumb/women/2.jpg',\n+┊  ┊47┊    lastMessage: messages.find(m => m.id === 4),\n+┊  ┊48┊  },\n+┊  ┊49┊]\n```\n\n[}]: #\n\nThe ChatsListScreen is now ready to use. We will replace the contents of the App component with the ChatsListScreen and we will make it the default screen in our app:\n\n[{]: <helper> (diffStep \"1.4\" files=\"App.jsx\" module=\"client\")\n\n#### [Step 1.4: Import ChatsListScreen](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/177df27)\n\n##### Changed src&#x2F;App.jsx\n```diff\n@@ -1,28 +1,10 @@\n-┊ 1┊  ┊import React, { Component } from 'react';\n-┊ 2┊  ┊import logo from './logo.svg';\n-┊ 3┊  ┊import './App.css';\n+┊  ┊ 1┊import * as React from 'react'\n+┊  ┊ 2┊import ChatsListScreen from './components/ChatsListScreen'\n ┊ 4┊ 3┊\n-┊ 5┊  ┊class App extends Component {\n-┊ 6┊  ┊  render() {\n-┊ 7┊  ┊    return (\n-┊ 8┊  ┊      <div className=\"App\">\n-┊ 9┊  ┊        <header className=\"App-header\">\n-┊10┊  ┊          <img src={logo} className=\"App-logo\" alt=\"logo\" />\n-┊11┊  ┊          <p>\n-┊12┊  ┊            Edit <code>src/App.js</code> and save to reload.\n-┊13┊  ┊          </p>\n-┊14┊  ┊          <a\n-┊15┊  ┊            className=\"App-link\"\n-┊16┊  ┊            href=\"https://reactjs.org\"\n-┊17┊  ┊            target=\"_blank\"\n-┊18┊  ┊            rel=\"noopener noreferrer\"\n-┊19┊  ┊          >\n-┊20┊  ┊            Learn React\n-┊21┊  ┊          </a>\n-┊22┊  ┊        </header>\n-┊23┊  ┊      </div>\n-┊24┊  ┊    );\n-┊25┊  ┊  }\n-┊26┊  ┊}\n+┊  ┊ 4┊const App = () => (\n+┊  ┊ 5┊  <div>\n+┊  ┊ 6┊    <ChatsListScreen />\n+┊  ┊ 7┊  </div>\n+┊  ┊ 8┊)\n ┊27┊ 9┊\n-┊28┊  ┊export default App;\n+┊  ┊10┊export default App\n```\n\n[}]: #\n\nIf you'll try to run the app you'll see that everything is there, but it's not hard to notice that it's missing some style:\n\n![naked-chats-list](https://user-images.githubusercontent.com/7648874/54028578-73099b80-41e0-11e9-803a-7469300acb06.png)\n\nIn the next chapter we will take care of styling our application with [Material-UI](https://material-ui.com/) and [styled-components](https://www.styled-components.com/) - we will give it the desired look and make it more user friendly. For now the ChatsListScreen serves no purpose, because you can't really do anything with it, but it can be used as a great basis to build on top of as we make progress."
          },
          {
            "manualTitle": "Step 2: Styling with Material UI and styled-components",
            "stepRevision": "dabf21e6039b2541f21f6e7cfb8feba3627842aa",
            "manualView": "Styled-components is a relatively new library that will transpile a given string into a CSS string and will encapsulate it under a React.Component. What's good about it is that you can define your style programmatically and it fits very well into React. With JavaScript in-hand you naturally have more control over your style, which makes it a very powerful tool.\n\nHere's one way to style a button using styled-components:\n\n```js\nconst Button = styled.button`\n  background: transparent;\n  border-radius: 3px;\n  border: 2px solid palevioletred;\n  color: palevioletred;\n  margin: 0.5em 1em;\n  padding: 0.25em 1em;\n\n  ${props => props.primary && css`\n    background: palevioletred;\n    color: white;\n  `}\n`;\n```\n\nThe created Button is actually a React.Component, so an instance of it can be created with ease like any other component:\n\n```jsx\n  <Button primary />\n```\n\nMore information about styled-components can be found in the official [docs page](https://www.styled-components.com/docs).\n\nWe would also use [Material-UI](https://material-ui.com/) - a library with a set of React components that implements Google's Material Design. What's good about it is that the design is already implemented right out of the box. Not only that, but it also includes a set of icons which are free to use.\n\nThere are many many things that Material-UI can offer, and it's not easy to follow it up, especially with the constantly evolving and improving API. The best way to go with it, is to have a component, and then look for it in the [official website](https://material-ui.com/). When it comes to searching for icons, they can be found in the [material.io](https://material-ui.com/) website through the search bar. As we move further in this tutorial you should have a better grasp of Material and how to use it.\n\n![material-ui-icons](https://user-images.githubusercontent.com/7648874/54141504-c853e000-4460-11e9-94b5-aae98ec9a1e3.png)\n\nWe will start off by installing both libraries:\n\n  $ npm install @material-ui/core @material-ui/icons styled-components\n\n`@material-ui/core` includes core component of Material-UI such as Input, Popover, Modal, etc, and `@material-ui/icons` includes a set of icons. Material is very generic and has a built in theming system which can be controlled by simply setting few variables, which is exactly what we're gonna need in our app.\n\nIn our app we're mainly gonna use 2 colors:\n\n- Primary #306759\n- Secondary #79e352\n\nTheme definition can easily be done in Material using the MuiThemeProvider component:\n\n[{]: <helper> (diffStep \"2.2\" module=\"client\")\n\n#### [Step 2.2: Setup Material-UI theme](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/05a0e1a)\n\n##### Changed src&#x2F;index.jsx\n```diff\n@@ -1,10 +1,25 @@\n+┊  ┊ 1┊import { MuiThemeProvider, createMuiTheme } from '@material-ui/core/styles'\n ┊ 1┊ 2┊import React from 'react';\n ┊ 2┊ 3┊import ReactDOM from 'react-dom';\n ┊ 3┊ 4┊import './index.css';\n ┊ 4┊ 5┊import App from './App';\n ┊ 5┊ 6┊import * as serviceWorker from './serviceWorker';\n ┊ 6┊ 7┊\n-┊ 7┊  ┊ReactDOM.render(<App />, document.getElementById('root'));\n+┊  ┊ 8┊const theme = createMuiTheme({\n+┊  ┊ 9┊  palette: {\n+┊  ┊10┊    primary: { main: '#2c6157' },\n+┊  ┊11┊    secondary: { main: '#6fd056' },\n+┊  ┊12┊  },\n+┊  ┊13┊  typography: {\n+┊  ┊14┊    useNextVariants: true,\n+┊  ┊15┊  },\n+┊  ┊16┊})\n+┊  ┊17┊\n+┊  ┊18┊ReactDOM.render(\n+┊  ┊19┊  <MuiThemeProvider theme={theme}>\n+┊  ┊20┊    <App />\n+┊  ┊21┊  </MuiThemeProvider>\n+┊  ┊22┊, document.getElementById('root'));\n ┊ 8┊23┊\n ┊ 9┊24┊// If you want your app to work offline and load faster, you can change\n ┊10┊25┊// unregister() to register() below. Note this comes with some pitfalls.\n```\n\n[}]: #\n\nOnce we have it set, the colors should be available to use in our application by simply providing the \"color\" prop to the component instance whose color we would like to change:\n\n```jsx\n<Button color=\"primary\">Primary</Button>\n<Button color=\"secondary\">Secondary</Button>\n```\n\nIn our app, we're also gonna use CSS directly to change its colors, therefore it would be handy to have these theme variables available to us through CSS. To do so, we will have have a second definition of these variables in `index.css`, at the `:root` level of our application.\n\n[{]: <helper> (diffStep \"2.3\" module=\"client\")\n\n#### [Step 2.3: Setup CSS theme vars](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/6b9967c)\n\n##### Changed src&#x2F;index.css\n```diff\n@@ -1,3 +1,10 @@\n+┊  ┊ 1┊:root {\n+┊  ┊ 2┊  --primary-bg: #2c6157;\n+┊  ┊ 3┊  --secondary-bg: #6fd056;\n+┊  ┊ 4┊  --primary-text: white;\n+┊  ┊ 5┊  --secondary-text: white;\n+┊  ┊ 6┊}\n+┊  ┊ 7┊\n ┊ 1┊ 8┊body {\n ┊ 2┊ 9┊  margin: 0;\n ┊ 3┊10┊  padding: 0;\n```\n\n[}]: #\n\n`:root` is a pseudo element that simply represents the root node, which will make the colors available in all elements. Normally, it works like JavaScript's scoping system and it will make variables available only to the current node and to its children, NOT its parents. CSS vars can be used like so:\n\n```css\n  color: var(--primary-text);\n  background-color: var(--primary-bg);\n```\n\nMore information about CSS variables can be found in the [official MDN docs](https://developer.mozilla.org/en-US/docs/Web/CSS/Using_CSS_variables).\n\nSo getting back to the ChatsListScreen, we will wrap the ChatsNavbar with Material's <Toolbar /> component:\n\n[{]: <helper> (diffStep \"2.4\" files=\"ChatsNavbar.tsx\" module=\"client\")\n\n#### [Step 2.4: Use Material components](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/32e7354)\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;ChatsNavbar.tsx\n```diff\n@@ -1,9 +1,10 @@\n+┊  ┊ 1┊import { Toolbar } from '@material-ui/core'\n ┊ 1┊ 2┊import * as React from 'react'\n ┊ 2┊ 3┊\n ┊ 3┊ 4┊const ChatsNavbar = () => (\n-┊ 4┊  ┊  <div>\n+┊  ┊ 5┊  <Toolbar>\n ┊ 5┊ 6┊    Whatsapp Clone\n-┊ 6┊  ┊  </div>\n+┊  ┊ 7┊  </Toolbar>\n ┊ 7┊ 8┊)\n ┊ 8┊ 9┊\n ┊ 9┊10┊export default ChatsNavbar\n```\n\n[}]: #\n\nAnd we will replace the `<ul />` and `<li />` elements with Material's `<List />` and `<ListItem />` in ChatsList:\n\n[{]: <helper> (diffStep \"2.4\" files=\"ChatsList.tsx\" module=\"client\")\n\n#### [Step 2.4: Use Material components](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/32e7354)\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;ChatsList.tsx\n```diff\n@@ -1,12 +1,13 @@\n+┊  ┊ 1┊import { List, ListItem } from '@material-ui/core'\n ┊ 1┊ 2┊import moment from 'moment'\n ┊ 2┊ 3┊import * as React from 'react'\n ┊ 3┊ 4┊import { chats } from '../../db'\n ┊ 4┊ 5┊\n ┊ 5┊ 6┊const ChatsList = () => (\n ┊ 6┊ 7┊  <div>\n-┊ 7┊  ┊    <ul>\n+┊  ┊ 8┊    <List>\n ┊ 8┊ 9┊      {chats.map((chat) => (\n-┊ 9┊  ┊        <li key={chat.id}>\n+┊  ┊10┊        <ListItem key={chat.id} button>\n ┊10┊11┊          <img src={chat.picture} />\n ┊11┊12┊          <div>{chat.name}</div>\n ┊12┊13┊          {chat.lastMessage && (\n```\n```diff\n@@ -15,9 +16,9 @@\n ┊15┊16┊              <div>{moment(chat.lastMessage.createdAt).format('HH:mm')}</div>\n ┊16┊17┊            </React.Fragment>\n ┊17┊18┊          )}\n-┊18┊  ┊        </li>\n+┊  ┊19┊        </ListItem>\n ┊19┊20┊      ))}\n-┊20┊  ┊    </ul>\n+┊  ┊21┊    </List>\n ┊21┊22┊  </div>\n ┊22┊23┊)\n ┊23┊24┊\n```\n\n[}]: #\n\nThanks to the `button` attribute we can give our list a more vibrant feeling and that will display a nice ripple effect once an item is clicked, something that could have taken a long time to implement manually.\n\nNext, we will use `styled-components` to create new React.Components which are bound into a style-sheet. This way when we create new instances of them, the components will be styled right out of the box. Example:\n\n```jsx\nconst Button = styled.button `\n  border-radius: 999px;\n`\n\nconst RedButton = styled(Button) `\n  color: red;\n`\n\nconst GreenButton = styled(Button) `\n  color: green;\n`\n\nconst BlueButton = styled(Button) `\n  color: blue;\n`\n\nconst Dashboard = (\n  <div>\n    <RedButton />\n    <GreenButton />\n    <BlueButton />\n  </div>\n)\n```\n\nThe clear advantage of such working strategy is that all the styles are encapsulated, unlike traditional CSS where style rules can easily collide and be merged unintentionally. Remember that **`styled-components` operates per component, not globally**. In terms of syntax and API there isn't much to explain, it's very intuitive and if you would follow the step-diffs in this tutorial carefully you should get the hang of `styled-components` pretty easily.\n\nAccordingly, let's use `styled-components` to wrap internal components in the ChatsNavbar component:\n\n[{]: <helper> (diffStep \"2.5\" files=\"ChatsNavbar.tsx\" module=\"client\")\n\n#### [Step 2.5: Add style with styled-components](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/f07d9f0)\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;ChatsNavbar.tsx\n```diff\n@@ -1,10 +1,18 @@\n ┊ 1┊ 1┊import { Toolbar } from '@material-ui/core'\n ┊ 2┊ 2┊import * as React from 'react'\n+┊  ┊ 3┊import styled from 'styled-components'\n+┊  ┊ 4┊\n+┊  ┊ 5┊const Container = styled(Toolbar) `\n+┊  ┊ 6┊  background-color: var(--primary-bg);\n+┊  ┊ 7┊  color: var(--primary-text);\n+┊  ┊ 8┊  font-size: 20px;\n+┊  ┊ 9┊  line-height: 40px;\n+┊  ┊10┊`\n ┊ 3┊11┊\n ┊ 4┊12┊const ChatsNavbar = () => (\n-┊ 5┊  ┊  <Toolbar>\n+┊  ┊13┊  <Container>\n ┊ 6┊14┊    Whatsapp Clone\n-┊ 7┊  ┊  </Toolbar>\n+┊  ┊15┊  </Container>\n ┊ 8┊16┊)\n ┊ 9┊17┊\n ┊10┊18┊export default ChatsNavbar\n```\n\n[}]: #\n\nAnd in the ChatsList components:\n\n[{]: <helper> (diffStep \"2.5\" files=\"ChatsList.tsx\" module=\"client\")\n\n#### [Step 2.5: Add style with styled-components](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/f07d9f0)\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;ChatsList.tsx\n```diff\n@@ -1,25 +1,79 @@\n ┊ 1┊ 1┊import { List, ListItem } from '@material-ui/core'\n ┊ 2┊ 2┊import moment from 'moment'\n ┊ 3┊ 3┊import * as React from 'react'\n+┊  ┊ 4┊import styled from 'styled-components'\n ┊ 4┊ 5┊import { chats } from '../../db'\n ┊ 5┊ 6┊\n+┊  ┊ 7┊const Container = styled.div `\n+┊  ┊ 8┊  height: calc(100% - 56px);\n+┊  ┊ 9┊  overflow-y: overlay;\n+┊  ┊10┊`\n+┊  ┊11┊\n+┊  ┊12┊const StyledList = styled(List) `\n+┊  ┊13┊  padding: 0 !important;\n+┊  ┊14┊`\n+┊  ┊15┊\n+┊  ┊16┊const StyledListItem = styled(ListItem) `\n+┊  ┊17┊  height: 76px;\n+┊  ┊18┊  padding: 0 15px;\n+┊  ┊19┊  display: flex;\n+┊  ┊20┊`\n+┊  ┊21┊\n+┊  ┊22┊const ChatPicture = styled.img `\n+┊  ┊23┊  height: 50px;\n+┊  ┊24┊  width: 50px;\n+┊  ┊25┊  object-fit: cover;\n+┊  ┊26┊  border-radius: 50%;\n+┊  ┊27┊`\n+┊  ┊28┊\n+┊  ┊29┊const ChatInfo = styled.div `\n+┊  ┊30┊  width: calc(100% - 60px);\n+┊  ┊31┊  padding: 15px 0;\n+┊  ┊32┊  margin-left: 10px;\n+┊  ┊33┊  border-bottom: 0.5px solid silver;\n+┊  ┊34┊  position: relative;\n+┊  ┊35┊`\n+┊  ┊36┊\n+┊  ┊37┊const ChatName = styled.div `\n+┊  ┊38┊  margin-top: 5px;\n+┊  ┊39┊`\n+┊  ┊40┊\n+┊  ┊41┊const MessageContent = styled.div `\n+┊  ┊42┊  color: gray;\n+┊  ┊43┊  font-size: 15px;\n+┊  ┊44┊  margin-top: 5px;\n+┊  ┊45┊  text-overflow: ellipsis;\n+┊  ┊46┊  overflow: hidden;\n+┊  ┊47┊  white-space: nowrap;\n+┊  ┊48┊`\n+┊  ┊49┊\n+┊  ┊50┊const MessageDate = styled.div `\n+┊  ┊51┊  position: absolute;\n+┊  ┊52┊  color: gray;\n+┊  ┊53┊  top: 20px;\n+┊  ┊54┊  right: 0;\n+┊  ┊55┊  font-size: 13px;\n+┊  ┊56┊`\n+┊  ┊57┊\n ┊ 6┊58┊const ChatsList = () => (\n-┊ 7┊  ┊  <div>\n-┊ 8┊  ┊    <List>\n+┊  ┊59┊  <Container>\n+┊  ┊60┊    <StyledList>\n ┊ 9┊61┊      {chats.map((chat) => (\n-┊10┊  ┊        <ListItem key={chat.id} button>\n-┊11┊  ┊          <img src={chat.picture} />\n-┊12┊  ┊          <div>{chat.name}</div>\n-┊13┊  ┊          {chat.lastMessage && (\n-┊14┊  ┊            <React.Fragment>\n-┊15┊  ┊              <div>{chat.lastMessage.content}</div>\n-┊16┊  ┊              <div>{moment(chat.lastMessage.createdAt).format('HH:mm')}</div>\n-┊17┊  ┊            </React.Fragment>\n-┊18┊  ┊          )}\n-┊19┊  ┊        </ListItem>\n+┊  ┊62┊        <StyledListItem key={chat.id} button>\n+┊  ┊63┊          <ChatPicture src={chat.picture} />\n+┊  ┊64┊          <ChatInfo>\n+┊  ┊65┊            <ChatName>{chat.name}</ChatName>\n+┊  ┊66┊            {chat.lastMessage && (\n+┊  ┊67┊              <React.Fragment>\n+┊  ┊68┊                <MessageContent>{chat.lastMessage.content}</MessageContent>\n+┊  ┊69┊                <MessageDate>{moment(chat.lastMessage.createdAt).format('HH:mm')}</MessageDate>\n+┊  ┊70┊              </React.Fragment>\n+┊  ┊71┊            )}\n+┊  ┊72┊          </ChatInfo>\n+┊  ┊73┊        </StyledListItem>\n ┊20┊74┊      ))}\n-┊21┊  ┊    </List>\n-┊22┊  ┊  </div>\n+┊  ┊75┊    </StyledList>\n+┊  ┊76┊  </Container>\n ┊23┊77┊)\n ┊24┊78┊\n ┊25┊79┊export default ChatsList\n```\n\n[}]: #\n\nNotice that we've changed the structure of the HTML of the ChatsList component. We've added the ChatInfo to allow better alignment of the elements. **There isn't right or wrong way to define CSS rules and HTML, as long as the script is clear and easy to understand, that will do**.\n\nWe're done styling or ChatsList component. We will keep using the same principles to style the rest of the components in our application. The final result should look like so:\n\n![screenshot](https://user-images.githubusercontent.com/7648874/54141766-40baa100-4461-11e9-8dd0-59edcfdb3b84.png)"
          },
          {
            "manualTitle": "Step 3: Setup a basic Node.JS server with a basic REST endpoint",
            "stepRevision": "053ee62439ec313156559892c1905ba4426f8fa3",
            "manualView": "So we have a running app with a single screen which looks stylish and presents some data to the user. There is something missing though. The data that is presented is just a mock for a server response, and it represents the schema of some real data to come.\n\nEven if we'll create real data on the client, that means that when the client is down, all the data is lost. But this is a social app, many people want to use it together and even the same person wants to use it on multiple devices. For that, we need a central place to store all data and all the clients would connect to that central place in order to retrieve or change the data.\n\nIn this step, we will write a Node.JS server and will expose a REST endpoint that will serve the data-mock. We will build the REST application using [Express](https://www.npmjs.com/package/express). Further in this tutorial, we will migrate to using a real data-base with real I/O from the user, so we got you covered.\n\nThe plan is to have a server up and running at `localhost:4000` that will expose a `GET /chats` route. Unlike our client application, we're not gonna use any boilerplate and we're gonna set everything up manually. Ofcourse, you should feel free to use a boilerplate if it looks right to you. Right outside the client project, we will create a new directory called `whatsapp-clone-server` in which we will start creating our server:\n\n    $ mkdir whatsapp-clone-server\n    $ cd whatsapp-clone-server\n\nThen we will use NPM to initialize a new project:\n\n    $ npm init --yes\n\n> `--yes` will answer yes to all questions and skip the prompt. It's just faster this way.\n\nThere's nothing special about this command, it only creates a basic package.json which we can add things on top (see [NPM's official docs](https://docs.npmjs.com/cli/init)). Just to make sure that things work, we will add an `index.js` file which will print \"hello world\" to the console.\n\n[{]: <helper> (diffStep \"1.1\" files=\"index.js\" module=\"server\")\n\n#### Step 1.1: Create start script\n\n##### Added index.js\n```diff\n@@ -0,0 +1 @@\n+┊ ┊1┊console.log('hello world')\n```\n\n[}]: #\n\n\nAnd we will add a startup script to the `package.json` file called `start`:\n\n    start: node index.js\n\nNPM-scripts are just a way to defined an alias for commands. Now we only have one simple script, but it can turn out to be something very complex depending on our server, so it can be very useful. More about npm-scripts can be found in the [official NPM docs](https://docs.npmjs.com/misc/scripts).\n\nNow we can run our server by running `$ npm start` and we should see the message \"hello world\" printed to the console, as expected.\n\nLike in our client's app, we will be using TypeScript. It's comfortable and it enables consistency between both apps. In order to use TypeScript we will install few packages:\n\n    $ npm install --dev typescript ts-node @types/node\n\n> Note how we used the `--dev` flag. This project is not gonna be required as an external dependency anywhere, but It is still common to separate between production dependencies and development dependencies. More about the `--dev` option can be read in the [NPM-install docs](https://docs.npmjs.com/cli/install).\n\n- The [`typescript`](https://www.npmjs.com/package/typescript) package is TypeScript's core transpiler.\n- [`ts-node`](https://www.npmjs.com/package/ts-node) is an interpreter that will transpile required `.ts` files into JavaScript at runtime.\n- [`@types/node`](https://www.npmjs.com/package/@types/node) will make the appropriate definitions for a Node.JS environment.\n\n> You can read more about the `@types` monorepo in the [official GitHub repository](https://github.com/DefinitelyTyped/DefinitelyTyped).\n\nOur server is gonna use the following `tsconfig.json` file, feel free to make the necessary modifications based on your needs:\n\n[{]: <helper> (diffStep \"1.2\" files=\"tsconfig.json\" module=\"server\")\n\n#### Step 1.2: Setup TypeScript\n\n##### Added tsconfig.json\n```diff\n@@ -0,0 +1,16 @@\n+┊  ┊ 1┊{\n+┊  ┊ 2┊  \"compilerOptions\": {\n+┊  ┊ 3┊    \"target\": \"es2018\",\n+┊  ┊ 4┊    \"module\": \"commonjs\",\n+┊  ┊ 5┊    \"lib\": [\n+┊  ┊ 6┊      \"es2018\",\n+┊  ┊ 7┊      \"esnext.asynciterable\"\n+┊  ┊ 8┊    ],\n+┊  ┊ 9┊    \"strict\": true,\n+┊  ┊10┊    \"strictFunctionTypes\": false,\n+┊  ┊11┊    \"strictPropertyInitialization\": false,\n+┊  ┊12┊    \"esModuleInterop\": true,\n+┊  ┊13┊    \"experimentalDecorators\": true,\n+┊  ┊14┊    \"emitDecoratorMetadata\": true\n+┊  ┊15┊  }\n+┊  ┊16┊}\n```\n\n[}]: #\n\nWe will rename the `index.js` file to `index.ts`:\n\n    $ mv index.js index.ts\n\nAnd we will update the npm-script `start` to use `ts-node`, since we wanna use TypeScript, and not JavaScript directly:\n\n    start: ts-node index.ts\n\nWe can test the startup of our server again by running `$ npm start` and we should see the message \"hello world\" printed to the console. The skeleton of the project is set and we can move on to implementing the REST API.\n\nLike we said at the beginning, we will be using Express to setup the API. Express is wrap around the native [Node.JS \"http\"](https://nodejs.org/api/http.html) library which is responsible for handling HTTP requests. Yes, it can also be used directly, but Express is much more comfortable and has an amazing ecosystem built around it. Let's install Express and its TypeScript definitions:\n\n    $ npm install express\n    $ npm install --dev @types/express\n\nBefore we implement the `GET /chats` route we will implement a `GET /_ping` route. This route will be used to determine whether the server is up and running or not, and how fast the connection is based on the response time. For every request sent to this route, we should expect a response saying \"pong\". Some call it \"heartbeat\", because this route is being tested repeatedly by the hosting machine to check if it's alive, just like a heartbeat in a way. This is how the route should look like:\n\n[{]: <helper> (diffStep \"1.3\" files=\"index.ts\" module=\"server\")\n\n#### Step 1.3: Setup a Express with a basic health check route\n\n##### Changed index.ts\n```diff\n@@ -1 +1,13 @@\n-┊ 1┊  ┊console.log('hello world')\n+┊  ┊ 1┊import express from 'express'\n+┊  ┊ 2┊\n+┊  ┊ 3┊const app = express()\n+┊  ┊ 4┊\n+┊  ┊ 5┊app.get('/_ping', (req, res) => {\n+┊  ┊ 6┊  res.send('pong')\n+┊  ┊ 7┊})\n+┊  ┊ 8┊\n+┊  ┊ 9┊const port = process.env.PORT || 4000\n+┊  ┊10┊\n+┊  ┊11┊app.listen(port, () => {\n+┊  ┊12┊  console.log(`Server is listening on port ${port}`)\n+┊  ┊13┊})\n```\n\n[}]: #\n\nWe can use the `$ curl localhost:4000/_ping` command to send a request to the server and we should get a \"pong\", assuming that the server available on that URL. The `GET /chats` should be implemented similarly, only the response is different. Instead of returning \"pong\" we will return the data-mock for our chats:\n\n[{]: <helper> (diffStep \"1.4\" files=\"index.ts, db.ts\" module=\"server\")\n\n#### Step 1.4: Create GET /chats route\n\n##### Added db.ts\n```diff\n@@ -0,0 +1,49 @@\n+┊  ┊ 1┊export const messages = [\n+┊  ┊ 2┊  {\n+┊  ┊ 3┊    id: 1,\n+┊  ┊ 4┊    content: \"You on your way?\",\n+┊  ┊ 5┊    createdAt: new Date(Date.now() - 60 * 1000 * 1000),\n+┊  ┊ 6┊  },\n+┊  ┊ 7┊  {\n+┊  ┊ 8┊    id: 2,\n+┊  ┊ 9┊    content: \"Hey, it's me\",\n+┊  ┊10┊    createdAt: new Date(Date.now() - 2 * 60 * 1000 * 1000),\n+┊  ┊11┊  },\n+┊  ┊12┊  {\n+┊  ┊13┊    id: 3,\n+┊  ┊14┊    content: \"I should buy a boat\",\n+┊  ┊15┊    createdAt: new Date(Date.now() - 24 * 60 * 1000 * 1000),\n+┊  ┊16┊  },\n+┊  ┊17┊  {\n+┊  ┊18┊    id: 4,\n+┊  ┊19┊    content: \"This is wicked good ice cream.\",\n+┊  ┊20┊    createdAt: new Date(Date.now() - 14 * 24 * 60 * 1000 * 1000),\n+┊  ┊21┊  },\n+┊  ┊22┊]\n+┊  ┊23┊\n+┊  ┊24┊export const chats = [\n+┊  ┊25┊  {\n+┊  ┊26┊    id: 1,\n+┊  ┊27┊    name: 'Ethan Gonzalez',\n+┊  ┊28┊    picture: 'https://randomuser.me/api/portraits/thumb/men/1.jpg',\n+┊  ┊29┊    lastMessage: messages.find(m => m.id === 1),\n+┊  ┊30┊  },\n+┊  ┊31┊  {\n+┊  ┊32┊    id: 2,\n+┊  ┊33┊    name: 'Bryan Wallace',\n+┊  ┊34┊    picture: 'https://randomuser.me/api/portraits/thumb/men/2.jpg',\n+┊  ┊35┊    lastMessage: messages.find(m => m.id === 2),\n+┊  ┊36┊  },\n+┊  ┊37┊  {\n+┊  ┊38┊    id: 3,\n+┊  ┊39┊    name: 'Avery Stewart',\n+┊  ┊40┊    picture: 'https://randomuser.me/api/portraits/thumb/women/1.jpg',\n+┊  ┊41┊    lastMessage: messages.find(m => m.id === 3),\n+┊  ┊42┊  },\n+┊  ┊43┊  {\n+┊  ┊44┊    id: 4,\n+┊  ┊45┊    name: 'Katie Peterson',\n+┊  ┊46┊    picture: 'https://randomuser.me/api/portraits/thumb/women/2.jpg',\n+┊  ┊47┊    lastMessage: messages.find(m => m.id === 4),\n+┊  ┊48┊  },\n+┊  ┊49┊]\n```\n\n##### Changed index.ts\n```diff\n@@ -1,4 +1,5 @@\n ┊1┊1┊import express from 'express'\n+┊ ┊2┊import { chats } from './db'\n ┊2┊3┊\n ┊3┊4┊const app = express()\n ┊4┊5┊\n```\n```diff\n@@ -6,6 +7,10 @@\n ┊ 6┊ 7┊  res.send('pong')\n ┊ 7┊ 8┊})\n ┊ 8┊ 9┊\n+┊  ┊10┊app.get('/chats', (req, res) => {\n+┊  ┊11┊  res.json(chats)\n+┊  ┊12┊})\n+┊  ┊13┊\n ┊ 9┊14┊const port = process.env.PORT || 4000\n ┊10┊15┊\n ┊11┊16┊app.listen(port, () => {\n```\n\n[}]: #\n\nUnlike the previous route, we used the `.json()` method this time around to send a response. This will simply stringify the given JSON and set the right headers. Similarly to the client, we've defined the db mock in a dedicated file, as this is easier to maintain and look at.\n\nIt's also recommended to connect a middleware called [`cors`](https://www.npmjs.com/package/cors) which will enable cross-origin requests. Without it we will only be able to make requests in localhost, something which is likely to limit us in the future because we would probably host our server somewhere separate than the client application. Let's install the `cors` library and load it with the Express `middleware()` function:\n\n    $ npm install cors\n\n[{]: <helper> (diffStep \"1.4\" files=\"index.ts\" module=\"server\")\n\n#### Step 1.4: Create GET /chats route\n\n##### Changed index.ts\n```diff\n@@ -1,4 +1,5 @@\n ┊1┊1┊import express from 'express'\n+┊ ┊2┊import { chats } from './db'\n ┊2┊3┊\n ┊3┊4┊const app = express()\n ┊4┊5┊\n```\n```diff\n@@ -6,6 +7,10 @@\n ┊ 6┊ 7┊  res.send('pong')\n ┊ 7┊ 8┊})\n ┊ 8┊ 9┊\n+┊  ┊10┊app.get('/chats', (req, res) => {\n+┊  ┊11┊  res.json(chats)\n+┊  ┊12┊})\n+┊  ┊13┊\n ┊ 9┊14┊const port = process.env.PORT || 4000\n ┊10┊15┊\n ┊11┊16┊app.listen(port, () => {\n```\n\n[}]: #\n\nThe server is now ready to use! So getting back to the client, first we will define our server's URL under the `.env` file:\n\n[{]: <helper> (diffStep \"3.1\" module=\"client\")\n\n#### [Step 3.1: Define server URL](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/9784428)\n\n##### Added .env\n```diff\n@@ -0,0 +1 @@\n+┊ ┊1┊REACT_APP_SERVER_URL=http://localhost:4000🚫↵\n```\n\n[}]: #\n\nThis will make our server's URL available under the `process.env.REACT_APP_SERVER_URL` member expression and it will be replaced with a fixed value at build time, just like macros. The `.env` file is a file which will automatically be loaded to `process.env` by the [`dotenv`](https://www.npmjs.com/package/dotenv) NPM package. `react-scripts` then filters environment variables which have a `REACT_APP_` prefix and provides the created JSON to a Webpack plugin called [DefinePlugin](https://webpack.js.org/plugins/define-plugin/), which will result in the macro effect.\n\nNow let's move back into our React app folder. We will now replace the local data-mock usage with a fetch from the server. For that we can use the native [fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API), however, it needs to be used in the right life-cycle hook of the React.Component.\n\nThere are 2 naive approaches for that:\n\n- Calling `fetch()` outside the component, but this way that chats will be fetched even if we're not even intending to create an instance of the component.\n\n```js\nfetch().then(() => /* ... */)\nconst MyComponent = () => {}\n```\n\n- Calling `fetch()` inside the component, but then it will be invoked whenever the component is re-rendered.\n\n```js\nconst MyComponent = () => {\n  fetch().then(() => /* ... */)\n}\n```\n\nThese 2 approaches indeed work, but they both fail to deliver what's necessary on the right time. In addition, there's no way to properly coordinate async function calls with the render method of the component.\n\n**Introducing: React hooks**\n\nWith React hooks we can invoke the desired logic in the right life-cycle stage of the target component. This way we can avoid potential memory leaks or extra calculations. To implement a proper `fetch()`, we will be using 2 React hooks:\n\n- [`React.useState()`](https://reactjs.org/docs/hooks-reference.html#usestate) - which is used to get and set a state of the component - will be used to store the fetch chats.\n\n```js\nconst [value, setValue] = useState(initialValue)\n```\n\n- [`React.useMemo()`](https://reactjs.org/docs/hooks-reference.html#usememo) - which is used to run a computation only once certain conditions were met - will be used to run the `fetch()` function only once the component has mounted.\n\n```js\nconst memoizedValue = useMemo(calcFn, [cond1, cond2, ...conds])\n```\n\nThe result of that approach will look like this, in the context of our ChatsList component:\n\n[{]: <helper> (diffStep \"3.2\" module=\"client\")\n\n#### [Step 3.2: Fetch chats using native fetch API](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/2c088ab)\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;ChatsList.tsx\n```diff\n@@ -1,8 +1,8 @@\n ┊1┊1┊import { List, ListItem } from '@material-ui/core'\n ┊2┊2┊import moment from 'moment'\n ┊3┊3┊import * as React from 'react'\n+┊ ┊4┊import { useState, useMemo } from 'react'\n ┊4┊5┊import styled from 'styled-components'\n-┊5┊ ┊import { chats } from '../../db'\n ┊6┊6┊\n ┊7┊7┊const Container = styled.div `\n ┊8┊8┊  height: calc(100% - 56px);\n```\n```diff\n@@ -55,25 +55,35 @@\n ┊55┊55┊  font-size: 13px;\n ┊56┊56┊`\n ┊57┊57┊\n-┊58┊  ┊const ChatsList = () => (\n-┊59┊  ┊  <Container>\n-┊60┊  ┊    <StyledList>\n-┊61┊  ┊      {chats.map((chat) => (\n-┊62┊  ┊        <StyledListItem key={chat.id} button>\n-┊63┊  ┊          <ChatPicture src={chat.picture} />\n-┊64┊  ┊          <ChatInfo>\n-┊65┊  ┊            <ChatName>{chat.name}</ChatName>\n-┊66┊  ┊            {chat.lastMessage && (\n-┊67┊  ┊              <React.Fragment>\n-┊68┊  ┊                <MessageContent>{chat.lastMessage.content}</MessageContent>\n-┊69┊  ┊                <MessageDate>{moment(chat.lastMessage.createdAt).format('HH:mm')}</MessageDate>\n-┊70┊  ┊              </React.Fragment>\n-┊71┊  ┊            )}\n-┊72┊  ┊          </ChatInfo>\n-┊73┊  ┊        </StyledListItem>\n-┊74┊  ┊      ))}\n-┊75┊  ┊    </StyledList>\n-┊76┊  ┊  </Container>\n-┊77┊  ┊)\n+┊  ┊58┊const ChatsList = () => {\n+┊  ┊59┊  const [chats, setChats] = useState([])\n+┊  ┊60┊\n+┊  ┊61┊  useMemo(async () => {\n+┊  ┊62┊    const body = await fetch(`${process.env.REACT_APP_SERVER_URL}/chats`)\n+┊  ┊63┊    const chats = await body.json()\n+┊  ┊64┊    setChats(chats)\n+┊  ┊65┊  }, [true])\n+┊  ┊66┊\n+┊  ┊67┊  return (\n+┊  ┊68┊    <Container>\n+┊  ┊69┊      <StyledList>\n+┊  ┊70┊        {chats.map((chat) => (\n+┊  ┊71┊          <StyledListItem key={chat.id} button>\n+┊  ┊72┊            <ChatPicture src={chat.picture} />\n+┊  ┊73┊            <ChatInfo>\n+┊  ┊74┊              <ChatName>{chat.name}</ChatName>\n+┊  ┊75┊              {chat.lastMessage && (\n+┊  ┊76┊                <React.Fragment>\n+┊  ┊77┊                  <MessageContent>{chat.lastMessage.content}</MessageContent>\n+┊  ┊78┊                  <MessageDate>{moment(chat.lastMessage.createdAt).format('HH:mm')}</MessageDate>\n+┊  ┊79┊                </React.Fragment>\n+┊  ┊80┊              )}\n+┊  ┊81┊            </ChatInfo>\n+┊  ┊82┊          </StyledListItem>\n+┊  ┊83┊        ))}\n+┊  ┊84┊      </StyledList>\n+┊  ┊85┊    </Container>\n+┊  ┊86┊  )\n+┊  ┊87┊}\n ┊78┊88┊\n ┊79┊89┊export default ChatsList\n```\n\n[}]: #\n\n> It's recommended to read about React hooks and their basic concept at the [official React docs page](https://reactjs.org/docs/hooks-overview.html).\n\nAt this point we can get rid of `db.ts` file in the client, since we don't use it anymore:\n\n    $ rm src/db.ts\n\nThat's it. Our ChatsListScreen is now connected to a working back-end. In the next step we will upgrade our REST API into a GraphQL API and we will create a basis for a more robust back-end."
          },
          {
            "manualTitle": "Step 4: Transition to GraphQL",
            "stepRevision": "e3513d5246e1723f717228115213b418ac8ebdd3",
            "manualView": "**What is GraphQL?**\n\n[GraphQL](https://graphql.org/) is a query language invented by Facebook, and it's used to query data within our API. It allows clients to define the structure of the data required, and the exact same structure of data will be returned from the server, therefore preventing excessively large amounts of data from being returned. Unlike REST, GraphQL APIs are organized in terms of types and fields, not endpoints.\n\nCurrently in our app, if we'd like to get its chats we would send a GET request to `/chats`. With GraphQL it would be done differently with a string that describes the data that we would like to get:\n\n```graphql\nchats {\n  id\n  name\n  picture\n  lastMessage {\n    id\n    content\n    createdAt\n  }\n}\n```\n\n> Above: An illustration of a potential GraphQL query sent to our Whatsapp API\n\n**Why GraphQL and not REST?**\n\nIn terms of experience REST got the upper hand. It has been used for many more years and has proven itself to work well, and it's completely agnostic to the implementation of the back-end. However, when it comes to data projection and aggregation, it fails to deliver.\n\nWhen using REST, often times you'll find yourself performing multiple requests to execute a single query of data. Not only that, you might even end up with additional data that is not necessary. Either way, the process would result in slower and heavier response.\n\nWith GraphQL we don't have that kind of problem. Queries may take many shapes and forms, and since GraphQL is schema based - it can handle it. You'll get exactly what you asked for with a single request. **GraphQL provides a dynamic API while REST doesn't.**\n\n```graphql\n# request\nquery {\n  chat(id: 1) {\n    id\n    name\n    lastMessage {\n      id\n      content\n    }\n  }\n}\n```\n\n![graphql-request](https://user-images.githubusercontent.com/7648874/54133620-5aec8300-4451-11e9-9bda-a459dc48f57c.png)\n\n```js\n// response\n{\n  \"data\": {\n    \"chat\": {\n      \"id\": 1,\n      \"name\": \"Ethan Gonzalez\",\n      \"lastMessage\": {\n        \"id\": 1,\n        \"content\": \"You on your way?\"\n      }\n    }\n  }\n}\n```\n\n**GraphQL schema, in a nutshell**\n\nLike said earlier,  GraphQL APIs are organized in terms of types and fields. That means that our app data should be described with a schema, where each field's gonna have a resolver - the handler that will return the corresponding data. Things will be much clearer as we move further.\n\nLet's try to describe our app's data with a GraphQL schema and then dive into it:\n\n```graphql\nscalar Date\n\ntype Message {\n  id: ID!\n  content: String!\n  createdAt: Date!\n}\n\ntype Chat {\n  id: ID!\n  name: String!\n  picture: String\n  lastMessage: Message\n}\n\ntype Query {\n  chats: [Chat!]!\n}\n```\n\nThe schema is self explanatory in terms of what data it's compatible with. Supported built-in scalar types in GraphQL are:\n\n- Int: Signed 32‐bit integer\n- Float: Signed double-precision floating-point value\n- String: UTF‐8 character sequence\n- Boolean: true or false\n- ID (serialized as String): A unique identifier, often used to refetch an object or as the key for a cache. While serialized as a String, ID signifies that it is not intended to be human‐readable\n\nAny custom scalar can be declared with the `scalar` keyword, and custom types can be declared with the `type` keyword. However, you should know that some types are reserved by GraphQL itself; `Query` is one of them. The `Query` type will be used as the root for received queries by the clients, which means that we can send queries which start with the `chats` field. Other reserved types are:\n\n- `type Query` - reserved for [GraphQL queries](https://graphql.org/learn/queries/#mutations).\n- `type Mutation` - reserved for [GraphQL mutations.](https://graphql.github.io/learn/queries/)\n- `type Subscription` - reserved for [GraphQL subscriptions.](https://www.apollographql.com/docs/react/advanced/subscriptions.html)\n\n> As we're not gonna go through the entire GraphQL API, it's recommended to go through the [official learn section of the GraphQL website](https://graphql.org/learn/), but the information so far will definitely help you kick-start, plus the upcoming implementation.\n\n**Getting started**\n\nWe will be implementing a GraphQL mechanism for the client and for the server. We will start with the server as things will make more sense, and we will be able to test it before we proceed into the client. Essentially GraphQL is connected into a HTTP endpoint, usually under `POST /graphql`, and so this is exactly what we're gonna do, connect the endpoint handler. Luckily, we don't have to implement that. A team called [Apollo](https://www.apollographql.com/) already did it for us, so we can use their implementation. We will install the required packages:\n\n    $ npm install apollo-server-express body-parser graphql\n    $ npm install --dev @types/body-parser @types/graphql\n\n- [`graphql`](https://www.npmjs.com/package/graphql) - The core package of GraphQL that includes the resolvers for basic data-types.\n- [`apollo-server-express`](https://www.npmjs.com/package/apollo-server-express) - Apollo's implementation for the GraphQL Express REST endpoint.\n- [`body-parser`](https://www.npmjs.com/package/body-parser) - Parse incoming request bodies in a middleware before your handlers, available under the req.body property.\n- `@types/…` - TypeScript definitions\n\nWe can now connect Apollo's middleware under the `/graphql` route:\n\n[{]: <helper> (diffStep \"2.1\" files=\"index.ts\" module=\"server\")\n\n#### Step 2.1: Setup Apollo GraphQL\n\n##### Changed index.ts\n```diff\n@@ -1,10 +1,14 @@\n+┊  ┊ 1┊import { ApolloServer, gql } from 'apollo-server-express'\n+┊  ┊ 2┊import bodyParser from 'body-parser'\n ┊ 1┊ 3┊import cors from 'cors'\n ┊ 2┊ 4┊import express from 'express'\n ┊ 3┊ 5┊import { chats } from './db'\n+┊  ┊ 6┊import schema from './schema'\n ┊ 4┊ 7┊\n ┊ 5┊ 8┊const app = express()\n ┊ 6┊ 9┊\n ┊ 7┊10┊app.use(cors())\n+┊  ┊11┊app.use(bodyParser.json())\n ┊ 8┊12┊\n ┊ 9┊13┊app.get('/_ping', (req, res) => {\n ┊10┊14┊  res.send('pong')\n```\n```diff\n@@ -14,6 +18,13 @@\n ┊14┊18┊  res.json(chats)\n ┊15┊19┊})\n ┊16┊20┊\n+┊  ┊21┊const server = new ApolloServer({ schema })\n+┊  ┊22┊\n+┊  ┊23┊server.applyMiddleware({\n+┊  ┊24┊  app,\n+┊  ┊25┊  path: '/graphql',\n+┊  ┊26┊})\n+┊  ┊27┊\n ┊17┊28┊const port = process.env.PORT || 4000\n ┊18┊29┊\n ┊19┊30┊app.listen(port, () => {\n```\n\n[}]: #\n\nAs you can see, the middleware requires a schema. A schema is composed mainly out of 2 fields:\n\n- `typeDefs` (type definitions) - the schema types we wrote earlier this chapter for chats.\n- `resolvers` - The handlers that will provide the data for each field in `typeDefs`.\n\nWe will start first by defining the types. All we have to do is to copy-paste the contents of the schema that was shown earlier into a new file called `typeDefs.graphql`:\n\n[{]: <helper> (diffStep \"2.2\" files=\"typeDefs.graphql\" module=\"server\")\n\n#### Step 2.2: Create a basic GraphQL schema\n\n##### Added schema&#x2F;typeDefs.graphql\n```diff\n@@ -0,0 +1,18 @@\n+┊  ┊ 1┊scalar Date\n+┊  ┊ 2┊\n+┊  ┊ 3┊type Message {\n+┊  ┊ 4┊  id: ID!\n+┊  ┊ 5┊  content: String!\n+┊  ┊ 6┊  createdAt: Date!\n+┊  ┊ 7┊}\n+┊  ┊ 8┊\n+┊  ┊ 9┊type Chat {\n+┊  ┊10┊  id: ID!\n+┊  ┊11┊  name: String!\n+┊  ┊12┊  picture: String\n+┊  ┊13┊  lastMessage: Message\n+┊  ┊14┊}\n+┊  ┊15┊\n+┊  ┊16┊type Query {\n+┊  ┊17┊  chats: [Chat!]!\n+┊  ┊18┊}\n```\n\n[}]: #\n\nThe `.graphql` file extension is just a more convenient way to work with a GraphQL schema. The exported result should be a simple string that we can use to compose our GraphQL schema. The clear advantage of working with a dedicated file is that we get to have syntax highlight.\n\nNow we will implement the resolvers. Resolvers are presented in a JSON object where each resolver name should match the field name it represents. You can read more about resolvers in [Apollo's official docs for resolvers](https://www.apollographql.com/docs/tutorial/resolvers.html). This is how our resolvers should look like:\n\n[{]: <helper> (diffStep \"2.2\" files=\"resolvers.ts\" module=\"server\")\n\n#### Step 2.2: Create a basic GraphQL schema\n\n##### Added schema&#x2F;resolvers.ts\n```diff\n@@ -0,0 +1,12 @@\n+┊  ┊ 1┊import { GraphQLDateTime } from 'graphql-iso-date'\n+┊  ┊ 2┊import { chats } from '../db'\n+┊  ┊ 3┊\n+┊  ┊ 4┊export default {\n+┊  ┊ 5┊  Date: GraphQLDateTime,\n+┊  ┊ 6┊\n+┊  ┊ 7┊  Query: {\n+┊  ┊ 8┊    chats() {\n+┊  ┊ 9┊      return chats\n+┊  ┊10┊    },\n+┊  ┊11┊  },\n+┊  ┊12┊}\n```\n\n[}]: #\n\nFor now it's extremely simple, we map the chats query directly into the database collection. Each field in the resolvers object should match the GraphQL type it represents in the schema. Since we don't have any logic now, we should not implement any resolvers for the rest of the types, the data will simply be forwarded as is.\n\nNote that we've implemented a custom scalar named `Date` and we resolved it with an NPM package. Let's install it:\n\n    $ npm install graphql-iso-date\n    $ npm install --dev @types/graphql-iso-date\n\nFinal thing that we have to do would be combining the resolvers and the type-defs under a single GraphQL schema.\n\n[{]: <helper> (diffStep \"2.2\" files=\"index.ts\" module=\"server\")\n\n#### Step 2.2: Create a basic GraphQL schema\n\n##### Added schema&#x2F;index.ts\n```diff\n@@ -0,0 +1,7 @@\n+┊ ┊1┊import { importSchema } from 'graphql-import'\n+┊ ┊2┊import { makeExecutableSchema } from 'graphql-tools'\n+┊ ┊3┊import resolvers from './resolvers'\n+┊ ┊4┊\n+┊ ┊5┊const typeDefs = importSchema('schema/typeDefs.graphql')\n+┊ ┊6┊\n+┊ ┊7┊export default makeExecutableSchema({ resolvers, typeDefs })\n```\n\n[}]: #\n\n[`graphql-import`](https://www.npmjs.com/package/graphql-import) and [`graphql-tools`](https://www.npmjs.com/package/graphql-tools) are utility packages that will help us create a schema that will be compatible with Apollo's API. Let's install them:\n\n    $ npm install graphql-import graphql-tools\n\nThere's one optimization however that we should make in the our DB. Right now, the each chat document has a direct reference to a message via the `lastMessage` field. Practically speaking, this is NOT how the data sits in the DB. The `lastMessage` should only hold the ID for the correlated message, and then in the Node.JS app we should **resolve** it according to our needs. Let's make the appropriate changes in the DB then:\n\n[{]: <helper> (diffStep \"2.3\" files=\"db.ts\" module=\"server\")\n\n#### Step 2.3: Resolve Chat.lastMessage\n\n##### Changed db.ts\n```diff\n@@ -26,24 +26,24 @@\n ┊26┊26┊    id: 1,\n ┊27┊27┊    name: 'Ethan Gonzalez',\n ┊28┊28┊    picture: 'https://randomuser.me/api/portraits/thumb/men/1.jpg',\n-┊29┊  ┊    lastMessage: messages.find(m => m.id === 1),\n+┊  ┊29┊    lastMessage: 1,\n ┊30┊30┊  },\n ┊31┊31┊  {\n ┊32┊32┊    id: 2,\n ┊33┊33┊    name: 'Bryan Wallace',\n ┊34┊34┊    picture: 'https://randomuser.me/api/portraits/thumb/men/2.jpg',\n-┊35┊  ┊    lastMessage: messages.find(m => m.id === 2),\n+┊  ┊35┊    lastMessage: 2,\n ┊36┊36┊  },\n ┊37┊37┊  {\n ┊38┊38┊    id: 3,\n ┊39┊39┊    name: 'Avery Stewart',\n ┊40┊40┊    picture: 'https://randomuser.me/api/portraits/thumb/women/1.jpg',\n-┊41┊  ┊    lastMessage: messages.find(m => m.id === 3),\n+┊  ┊41┊    lastMessage: 3,\n ┊42┊42┊  },\n ┊43┊43┊  {\n ┊44┊44┊    id: 4,\n ┊45┊45┊    name: 'Katie Peterson',\n ┊46┊46┊    picture: 'https://randomuser.me/api/portraits/thumb/women/2.jpg',\n-┊47┊  ┊    lastMessage: messages.find(m => m.id === 4),\n+┊  ┊47┊    lastMessage: 4,\n ┊48┊48┊  },\n ┊49┊49┊]\n```\n\n[}]: #\n\nAnd a resolver to the `lastMessage` field:\n\n[{]: <helper> (diffStep \"2.3\" files=\"typeDefs.graphql\" module=\"server\")\n\n#### Step 2.3: Resolve Chat.lastMessage\n\n\n\n[}]: #\n\nThe first argument of the resolver is the raw chat data received by the DB, and the returned result should be the mapped value which we would like to return to the client.\n\nAs we get further in this tutorial we should get a better grasp regards resolvers and their API, since we will have to deal with more logic and complexity within our Node.JS app.\n\nAssuming that the server is running, we can already test our GraphQL endpoint. Because it's exposed to us via a REST endpoint, we can use a `$ curl` command to send a request to `GET localhost:4000/graphql` and get a response with all the data. Again, the query that we're gonna use to fetch the chats is:\n\n```graphql\nchats {\n  id\n  name\n  picture\n  lastMessage {\n    id\n    content\n    createdAt\n  }\n}\n```\n\nThe one-liner version of it with a `$ curl` command looks like so:\n\n    curl \\\n      -X POST \\\n      -H \"Content-Type: application/json\" \\\n      --data '{ \"query\": \"{ chats { id name picture lastMessage { id content createdAt } } }\" }' \\\n      localhost:4000/graphql\n\nAs a response we should get the data-mock for our chats stored in the server. Since we have that in place, we can go ahead and delete our implementation for the `GET /chats` route.\n\nSo getting back to the client, all we have to do is to change the fetching URL in the ChatsList component to use our newly implemented GraphQL REST endpoint:\n\n[{]: <helper> (diffStep \"4.1\" module=\"client\")\n\n#### [Step 4.1: Replace REST call with GraphQL call](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/b52a7ab)\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;ChatsList.tsx\n```diff\n@@ -55,12 +55,33 @@\n ┊55┊55┊  font-size: 13px;\n ┊56┊56┊`\n ┊57┊57┊\n+┊  ┊58┊const getChatsQuery = `\n+┊  ┊59┊  query GetChats {\n+┊  ┊60┊    chats {\n+┊  ┊61┊      id\n+┊  ┊62┊      name\n+┊  ┊63┊      picture\n+┊  ┊64┊      lastMessage {\n+┊  ┊65┊        id\n+┊  ┊66┊        content\n+┊  ┊67┊        createdAt\n+┊  ┊68┊      }\n+┊  ┊69┊    }\n+┊  ┊70┊  }\n+┊  ┊71┊`\n+┊  ┊72┊\n ┊58┊73┊const ChatsList = () => {\n ┊59┊74┊  const [chats, setChats] = useState([])\n ┊60┊75┊\n ┊61┊76┊  useMemo(async () => {\n-┊62┊  ┊    const body = await fetch(`${process.env.REACT_APP_SERVER_URL}/chats`)\n-┊63┊  ┊    const chats = await body.json()\n+┊  ┊77┊    const body = await fetch(`${process.env.REACT_APP_SERVER_URL}/graphql`, {\n+┊  ┊78┊      method: 'POST',\n+┊  ┊79┊      headers: {\n+┊  ┊80┊        'Content-Type': 'application/json',\n+┊  ┊81┊      },\n+┊  ┊82┊      body: JSON.stringify({ query: getChatsQuery }),\n+┊  ┊83┊    })\n+┊  ┊84┊    const { data: { chats } } = await body.json()\n ┊64┊85┊    setChats(chats)\n ┊65┊86┊  }, [true])\n```\n\n[}]: #\n\nThe received data should be similar to the previous one. No further changes are required. In the next chapter, we will continue working on the UI of our front-end application and we will add a new screen to the flow - the `ChatRoomScreen`."
          },
          {
            "manualTitle": "Step 5: Testing",
            "stepRevision": "41e6918b0fff182f2084107fe52a12245b9081cd",
            "manualView": "Testing is a crucial part when writing an application, especially if we're planning to publish it or make it a commercial thing. Before we hand someone a product, of any kind, we wanna make sure that it passes certain quality checks. We're signed on that product and so it's very important to ensure that it functions properly according our expectations, otherwise wouldn't wanna use it and will look for alternatives.\n\nIn the context of software, we constantly make changes. It's also inevitable to make all features completely independent from one another, so something in the app is likely to break as we upgrade it or maintain it. That's why we need to write a set of tests that can be run on demand, so when we implement a new feature we can simply run the tests and see what feature broke due to most recent changes.\n\nThere are currently 3 main testing frameworks in the NPM ecosystem: [Jasmine](https://jasmine.github.io/), [Mocha](https://mochajs.org/), and [Jest](https://jestjs.io/). Each testing framework has its pros, and cons, and at the end of the day it's a matter of preference. In our application we're gonna use [Jest](https://jestjs.io/) - a testing framework which was developed by Facebook. What's good about Jest is that it can be used to test both client and server logic, because it runs as a Node.JS application, but it also emulates the browser environment whenever we run it, thanks to [JSDOM](https://github.com/jsdom/jsdom).\n\n![jest](https://user-images.githubusercontent.com/7648874/54493900-e2ce0380-490f-11e9-8075-be4a236c7c38.png)\n\nIn this chapter we will learn how to test the React.Components in the client, and Apollo-GraphQL resolvers in the server. There are 3 kinds of tests:\n\n- Unit tests - which are used to test a single component, independently from other components in our system.\n- Integration tests - which are used to test a component in relation to other components in our systems (how well do they co-work with each other).\n- e2e tests (end to end) - which are used to test a complete, from the moment I clicked on a button in the user interface until the data gets back from the server and shown on the screen.\n\nThe efficiency of the tests go from bottom to top (unit -> e2e), but the maintenance and complexity go from bottom to top (e2e -> unit). Accordingly we will need to find a good balance where we don’t spend too much time on writing tests yet have a good indicator for how well our system functions. So we should write a lot of unit tests, a good amount of integration tests and a handful of e2e tests.\n\n![tests-types-table](https://user-images.githubusercontent.com/7648874/54494121-fed2a480-4911-11e9-9370-694ec989729b.png)\n\nWe will start with the client as it’s much easier, because Jest is set and ready to use right out of the box thanks to `create-react-app`.\n\n**Client - Testing React.Components**\n\nThanks to `create-react-app`, we have Jest set and ready to use right out of the box, so we can start writing tests right away. I you'll look at the `src` you'll see a file called `App.test.tsx`, which simply ensures that the component can be rendered without crashing.\n\n```jsx\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nit('renders without crashing', () => {\n  const div = document.createElement('div');\n  ReactDOM.render(<App />, div);\n  ReactDOM.unmountComponentAtNode(div);\n});\n```\n\nThis is not a typical test that you're likely to find in a React project, but it demonstrates very well how Jest can be used to test DOM related issues. If you'll run `$ npm run test` (or `$ yarn test`) in the command line and then press `a`, you should see the following output:\n\n![report](https://user-images.githubusercontent.com/7648874/54341429-eabe4700-4674-11e9-8e76-3aaaf7fec79a.png)\n\nJest will automatically run for every file that ends with a `.test.xxx` extension. This is very convenient because the tests can live right next to the component, and you don't need to lookup for it across the project. This behavior can be modified by configuring Jest in the `package.json` file under the `\"jest\"` field. More information about configuring Jest can be found in the official[ configuration documentation](https://jestjs.io/docs/en/configuration).\n\n> If you get a warning message regards wrapping the component with `act()` - this is a known issue with hooks and should have a proper solution soon. More about this issue and progress regards its fix can be found in this [GitHub thread](https://github.com/facebook/react/issues/14769#issuecomment-470097212).\n\nNow we're gonna write a basic test for the `<ChatsList />` component. In the test, we'll mock a fake response from the server, and examine the contents of rendered HTML. Since the HTML of the component is a dynamic thing and is constantly subject to changes, it would be a good idea to annotate it with `data-testid` attributes so it can be tested regardless of its structure:\n\n[{]: <helper> (diffStep \"5.1\" files=\"ChatsList.tsx\" module=\"client\")\n\n#### [Step 5.1: Add data-testid attributes](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/a893cdd)\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;ChatsList.tsx\n```diff\n@@ -90,13 +90,13 @@\n ┊ 90┊ 90┊      <StyledList>\n ┊ 91┊ 91┊        {chats.map((chat) => (\n ┊ 92┊ 92┊          <StyledListItem key={chat.id} button>\n-┊ 93┊   ┊            <ChatPicture src={chat.picture} />\n+┊   ┊ 93┊            <ChatPicture data-testid=\"picture\" src={chat.picture} />\n ┊ 94┊ 94┊            <ChatInfo>\n-┊ 95┊   ┊              <ChatName>{chat.name}</ChatName>\n+┊   ┊ 95┊              <ChatName data-testid=\"name\">{chat.name}</ChatName>\n ┊ 96┊ 96┊              {chat.lastMessage && (\n ┊ 97┊ 97┊                <React.Fragment>\n-┊ 98┊   ┊                  <MessageContent>{chat.lastMessage.content}</MessageContent>\n-┊ 99┊   ┊                  <MessageDate>{moment(chat.lastMessage.createdAt).format('HH:mm')}</MessageDate>\n+┊   ┊ 98┊                  <MessageContent data-testid=\"content\">{chat.lastMessage.content}</MessageContent>\n+┊   ┊ 99┊                  <MessageDate data-testid=\"date\">{moment(chat.lastMessage.createdAt).format('HH:mm')}</MessageDate>\n ┊100┊100┊                </React.Fragment>\n ┊101┊101┊              )}\n ┊102┊102┊            </ChatInfo>\n```\n\n[}]: #\n\nNow we can select various HTML elements with a query selector when we test the component. We will install a couple of packages that will assist us in implementing the test:\n\n  $ npm install jest-fetch-mock jest-dom react-testing-library\n\n- The [`jest-fetch-mock`](https://www.npmjs.com/package/jest-fetch-mock) package can mock responses emitted by the Fetch API.\n- The [`jest-dom`](https://www.npmjs.com/package/jsdom) package will add custom matchers that will help us examine HTML contents of DOM elements.\n- The [`react-testing-library`](https://www.npmjs.com/package/react-testing-library) package contains utility methods that will help us test React.Components with Jest.\n\nNext, we will create a file under the `src` folder called `setupTests.ts`. This file is loaded configured automatically by `create-react-app` and loaded by Jest, and we can use it to set up our testing environment according to our needs (like said earlier, Jest can be configured, so this file path can be changed). We will use that file to define a fake Fetch API using the `jest-fetch-mock` library:\n\n[{]: <helper> (diffStep \"5.2\" files=\"src/setupTests.ts\" module=\"client\")\n\n#### [Step 5.2: Setup tests](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/0d87b93)\n\n##### Added src&#x2F;setupTests.ts\n```diff\n@@ -0,0 +1,7 @@\n+┊ ┊1┊import 'jest-dom/extend-expect'\n+┊ ┊2┊import { GlobalWithFetchMock } from 'jest-fetch-mock'\n+┊ ┊3┊import { act } from 'react-testing-library'\n+┊ ┊4┊\n+┊ ┊5┊const customGlobal: GlobalWithFetchMock = global as GlobalWithFetchMock\n+┊ ┊6┊customGlobal.fetch = require('jest-fetch-mock')\n+┊ ┊7┊customGlobal.fetchMock = customGlobal.fetch\n```\n\n[}]: #\n\nWe will create another file called `ChatsList.test.tsx`, right next to the `<ChatsList />` component under the `ChatsListScreen` directory, and inside we will implement our test. The test should follow these steps:\n\n- Mock the response to contain a fake chat, so we won't need to make an actual call to our GraphQL API.\n- We will create a new instance of `<ChatsList />` and render it in a container element.\n- We will wait for changes in the DOM caused by `setState()`.\n- We will test the contents of the container.\n\nAnd this is how the implementation should look like:\n\n[{]: <helper> (diffStep \"5.3\" files=\"src/components/ChatsListScreen/ChatsList.test.tsx\" module=\"client\")\n\n#### [Step 5.3: Test ChatsList](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/8bc4a55)\n\n##### Added src&#x2F;components&#x2F;ChatsListScreen&#x2F;ChatsList.test.tsx\n```diff\n@@ -0,0 +1,36 @@\n+┊  ┊ 1┊import React from 'react'\n+┊  ┊ 2┊import ReactDOM from 'react-dom'\n+┊  ┊ 3┊import { render, waitForDomChange } from 'react-testing-library'\n+┊  ┊ 4┊import ChatsList from './ChatsList'\n+┊  ┊ 5┊\n+┊  ┊ 6┊describe('ChatsList', () => {\n+┊  ┊ 7┊  it('renders fetched chats data', async () => {\n+┊  ┊ 8┊    fetch.mockResponseOnce(JSON.stringify({\n+┊  ┊ 9┊      data: {\n+┊  ┊10┊        chats: [\n+┊  ┊11┊          {\n+┊  ┊12┊            id: 1,\n+┊  ┊13┊            name: 'Foo Bar',\n+┊  ┊14┊            picture: 'https://localhost:4000/picture.jpg',\n+┊  ┊15┊            lastMessage: {\n+┊  ┊16┊              id: 1,\n+┊  ┊17┊              content: 'Hello',\n+┊  ┊18┊              createdAt: new Date(0),\n+┊  ┊19┊            },\n+┊  ┊20┊          },\n+┊  ┊21┊        ],\n+┊  ┊22┊      },\n+┊  ┊23┊    }))\n+┊  ┊24┊\n+┊  ┊25┊    {\n+┊  ┊26┊      const { container, getByTestId } = render(<ChatsList />)\n+┊  ┊27┊\n+┊  ┊28┊      await waitForDomChange({ container })\n+┊  ┊29┊\n+┊  ┊30┊      expect(getByTestId('name')).toHaveTextContent('Foo Bar')\n+┊  ┊31┊      expect(getByTestId('picture')).toHaveAttribute('src', 'https://localhost:4000/picture.jpg')\n+┊  ┊32┊      expect(getByTestId('content')).toHaveTextContent('Hello')\n+┊  ┊33┊      expect(getByTestId('date')).toHaveTextContent('08:00')\n+┊  ┊34┊    }\n+┊  ┊35┊  })\n+┊  ┊36┊})\n```\n\n[}]: #\n\n> Jest API is vast but pretty intuitive for the most part. It mostly consists of test descriptors and matchers. [Here's a full list of all matchers which are built into Jest's API](https://jestjs.io/docs/en/expect). Always make sure to work against it when writing tests, for optimal results.\n\nWe will now move on to testing the server where we will learn how to setup Jest manually and test it against a GraphQL API.\n\n**Server - Testing GraphQL resolvers**\n\nTo set-up Jest, we will run the following in the command line:\n\n    $ npm install jest @types/jest ts-jest --dev\n\nThis will basically install Jest and make it useable with TypeScript. In addition, we will need to specify the file pattern that we would like to transform with [`ts-jest`](https://www.npmjs.com/package/ts-jest), by adding the following section to `package.json`:\n\n```\n{\n  \"jest\": {\n    \"transform\": {\n      \"^.+\\\\.(js|jsx|ts|tsx)$\": \"<rootDir>/node_modules/ts-jest\"\n    }\n  }\n}\n```\n\nWe will also add a `\"test\"` script in the `package.json` file, so we can run the tests with `$ npm run test` (or `$ yarn test`):\n\n```\n{\n  \"scripts\": {\n    \"test\": \"jest\"\n  }\n}\n```\n\nThis is how our `package.json` should look like at this point:\n\n[{]: <helper> (diffStep \"3.1\" files=\"package.json\" module=\"server\")\n\n#### Step 3.1: Install and configure Jest\n\n##### Changed package.json\n```diff\n@@ -3,7 +3,8 @@\n ┊ 3┊ 3┊  \"description\": \"A newly created Tortilla project\",\n ┊ 4┊ 4┊  \"private\": true,\n ┊ 5┊ 5┊  \"scripts\": {\n-┊ 6┊  ┊    \"start\": \"ts-node index.ts\"\n+┊  ┊ 6┊    \"start\": \"ts-node index.ts\",\n+┊  ┊ 7┊    \"test\": \"jest\"\n ┊ 7┊ 8┊  },\n ┊ 8┊ 9┊  \"devDependencies\": {\n ┊ 9┊10┊    \"@types/body-parser\": \"1.17.0\",\n```\n```diff\n@@ -11,7 +12,10 @@\n ┊11┊12┊    \"@types/express\": \"4.16.1\",\n ┊12┊13┊    \"@types/graphql\": \"14.0.7\",\n ┊13┊14┊    \"@types/graphql-iso-date\": \"3.3.1\",\n+┊  ┊15┊    \"@types/jest\": \"24.0.11\",\n ┊14┊16┊    \"@types/node\": \"11.11.0\",\n+┊  ┊17┊    \"ts-jest\": \"24.0.0\",\n+┊  ┊18┊    \"jest\": \"24.5.0\",\n ┊15┊19┊    \"ts-node\": \"8.0.3\",\n ┊16┊20┊    \"typescript\": \"3.3.3333\"\n ┊17┊21┊  },\n```\n```diff\n@@ -24,5 +28,10 @@\n ┊24┊28┊    \"graphql-import\": \"0.7.1\",\n ┊25┊29┊    \"graphql-iso-date\": \"3.6.1\",\n ┊26┊30┊    \"graphql-tools\": \"4.0.4\"\n+┊  ┊31┊  },\n+┊  ┊32┊  \"jest\": {\n+┊  ┊33┊    \"transform\": {\n+┊  ┊34┊      \"^.+\\\\.(js|jsx|ts|tsx)$\": \"<rootDir>/node_modules/ts-jest\"\n+┊  ┊35┊    }\n ┊27┊36┊  }\n ┊28┊37┊}\n```\n\n[}]: #\n\nNow we're gonna test the `chats` query in our GraphQL schema. To do so, we will setup an Apollo Client and send a query request to our back-end, and then we will match the received response with a pre-defined snapshot. Luckily, we don't have to set an actual client, since the tests and the implementation of the back-end live right next to each other, thus, we will install a package which will help us achieving so:\n\n    $ npm install apollo-server-testing --dev\n\nWe will define the test suite under the `tests/queries` folder in a file called `getChats.test.ts`:\n\n[{]: <helper> (diffStep \"3.2\" files=\"tests/queries/getChats.test.ts\" module=\"server\")\n\n#### Step 3.2: Test Query.chats\n\n##### Added tests&#x2F;queries&#x2F;getChats.test.ts\n```diff\n@@ -0,0 +1,32 @@\n+┊  ┊ 1┊import { createTestClient } from 'apollo-server-testing'\n+┊  ┊ 2┊import { ApolloServer, gql } from 'apollo-server-express'\n+┊  ┊ 3┊import schema from '../../schema'\n+┊  ┊ 4┊\n+┊  ┊ 5┊describe('Query.chats', () => {\n+┊  ┊ 6┊  it('should fetch all chats', async () => {\n+┊  ┊ 7┊    const server = new ApolloServer({ schema })\n+┊  ┊ 8┊\n+┊  ┊ 9┊    const { query } = createTestClient(server)\n+┊  ┊10┊\n+┊  ┊11┊    const res = await query({\n+┊  ┊12┊      query: gql `\n+┊  ┊13┊        query GetChats {\n+┊  ┊14┊          chats {\n+┊  ┊15┊            id\n+┊  ┊16┊            name\n+┊  ┊17┊            picture\n+┊  ┊18┊            lastMessage {\n+┊  ┊19┊              id\n+┊  ┊20┊              content\n+┊  ┊21┊              createdAt\n+┊  ┊22┊            }\n+┊  ┊23┊          }\n+┊  ┊24┊        }\n+┊  ┊25┊      `,\n+┊  ┊26┊    })\n+┊  ┊27┊\n+┊  ┊28┊    expect(res.data).toBeDefined()\n+┊  ┊29┊    expect(res.errors).toBeUndefined()\n+┊  ┊30┊    expect(res.data).toMatchSnapshot()\n+┊  ┊31┊  })\n+┊  ┊32┊})\n```\n\n[}]: #\n\nIn the test function, we create a new instance of the Apollo-GraphQL server using our schema, and we query some data against it thanks to the fake client created by [`apollo-server-testing`](https://www.npmjs.com/package/apollo-server-testing).\n\nThe `.toMatchSnapshot()` matcher will call the `toString()` method on the examined object and will test it against a predefined snapshot. The snapshot will automatically be created once we run the test for the first time and will be stored under the `__snapshot__` directory. This means that the first test run will always pass. This is useful because you can later on observe and adjust manually the snapshot manually without having to write it from scratch. The expected result should be a projection of the data stored in the `db.ts` file.\n\n[{]: <helper> (diffStep \"3.2\" files=\"tests/queries/__snapshots__\" module=\"server\")\n\n#### Step 3.2: Test Query.chats\n\n##### Added tests&#x2F;queries&#x2F;__snapshots__&#x2F;getChats.test.ts.snap\n```diff\n@@ -0,0 +1,48 @@\n+┊  ┊ 1┊// Jest Snapshot v1, https://goo.gl/fbAQLP\n+┊  ┊ 2┊\n+┊  ┊ 3┊exports[`Query.chats should fetch all chats 1`] = `\n+┊  ┊ 4┊Object {\n+┊  ┊ 5┊  \"chats\": Array [\n+┊  ┊ 6┊    Object {\n+┊  ┊ 7┊      \"id\": \"1\",\n+┊  ┊ 8┊      \"lastMessage\": Object {\n+┊  ┊ 9┊        \"content\": \"You on your way?\",\n+┊  ┊10┊        \"createdAt\": \"2019-03-12T13:24:18.174Z\",\n+┊  ┊11┊        \"id\": \"1\",\n+┊  ┊12┊      },\n+┊  ┊13┊      \"name\": \"Ethan Gonzalez\",\n+┊  ┊14┊      \"picture\": \"https://randomuser.me/api/portraits/thumb/men/1.jpg\",\n+┊  ┊15┊    },\n+┊  ┊16┊    Object {\n+┊  ┊17┊      \"id\": \"2\",\n+┊  ┊18┊      \"lastMessage\": Object {\n+┊  ┊19┊        \"content\": \"Hey, it's me\",\n+┊  ┊20┊        \"createdAt\": \"2019-03-11T20:44:18.174Z\",\n+┊  ┊21┊        \"id\": \"2\",\n+┊  ┊22┊      },\n+┊  ┊23┊      \"name\": \"Bryan Wallace\",\n+┊  ┊24┊      \"picture\": \"https://randomuser.me/api/portraits/thumb/men/2.jpg\",\n+┊  ┊25┊    },\n+┊  ┊26┊    Object {\n+┊  ┊27┊      \"id\": \"3\",\n+┊  ┊28┊      \"lastMessage\": Object {\n+┊  ┊29┊        \"content\": \"I should buy a boat\",\n+┊  ┊30┊        \"createdAt\": \"2019-02-24T14:04:18.174Z\",\n+┊  ┊31┊        \"id\": \"3\",\n+┊  ┊32┊      },\n+┊  ┊33┊      \"name\": \"Avery Stewart\",\n+┊  ┊34┊      \"picture\": \"https://randomuser.me/api/portraits/thumb/women/1.jpg\",\n+┊  ┊35┊    },\n+┊  ┊36┊    Object {\n+┊  ┊37┊      \"id\": \"4\",\n+┊  ┊38┊      \"lastMessage\": Object {\n+┊  ┊39┊        \"content\": \"This is wicked good ice cream.\",\n+┊  ┊40┊        \"createdAt\": \"2018-07-22T22:04:18.174Z\",\n+┊  ┊41┊        \"id\": \"4\",\n+┊  ┊42┊      },\n+┊  ┊43┊      \"name\": \"Katie Peterson\",\n+┊  ┊44┊      \"picture\": \"https://randomuser.me/api/portraits/thumb/women/2.jpg\",\n+┊  ┊45┊    },\n+┊  ┊46┊  ],\n+┊  ┊47┊}\n+┊  ┊48┊`;\n```\n\n[}]: #\n\nAlways be sure to observe the snapshot before moving on! The received result isn't necessarily what you'd expect. Also it's not a good practice to store production data in the snapshot because it's subject to changes. Normally we would set up another instance of the DB for testing purposes, but since our DB is a mock and doesn't represent real data, there's no need to at this stage.\n\nNow that we have the required knowledge regards testing and Jest's API, we will implement tests throughout the tutorial as a trivial thing. We will not go through each and every new matcher that we introduce, as it is self explanatory and there's too much of them. Be sure to work against [this full list of matchers](https://jestjs.io/docs/en/expect) when working with Jest.\n\nIn the next chapter we will continue expanding our application by adding a `<ChatRoomScreen />`."
          }
        ]
      }
    ]
  }
]
