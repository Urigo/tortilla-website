[
  {
    "repoUrl": "https://github.com/Urigo/WhatsApp-Clone-Tutorial",
    "branchName": "final",
    "historyBranchName": "final-history",
    "releases": [
      {
        "releaseVersion": "next",
        "releaseDate": "2019-03-24 04:40:43 +0800",
        "tagName": "final@next",
        "tagRevision": "3e7c0b82b52ec6545fa64610690f59360365e005",
        "historyRevision": "95270a9965750c4e8b5f6b484563b952f0d7663b",
        "changesDiff": "diff --git a/.gitignore b/.gitignore\nnew file mode 100644\nindex 0000000..5171c54\n--- /dev/null\n+++ b/.gitignore\n@@ -0,0 +1,2 @@\n+node_modules\n+npm-debug.log\n\\ No newline at end of file\ndiff --git a/.tortilla/manuals/templates/root.tmpl b/.tortilla/manuals/templates/root.tmpl\nnew file mode 100644\nindex 0000000..140693f\n--- /dev/null\n+++ b/.tortilla/manuals/templates/root.tmpl\n@@ -0,0 +1,80 @@\n+![whatsapp-clone](https://user-images.githubusercontent.com/7648874/54141944-9f801a80-4461-11e9-85a1-bcb161d9a6c6.png)\n+\n+Whatsapp Clone is an open-source tutorial that will guide you through step-by-step on how to create a full-stack hybrid web-app.\n+\n+The software world is evolving quickly, and oftentimes people find themselves left behind, even the most experienced ones. The purpose of this tutorial is to completely demystify the confusion, and be the main guide on how to do things properly.\n+\n+This tutorial is for anyone who has ever asked himself or herself one of the following questions or similar:\n+\n+- How do people build an app today?\n+- What are the “hottest”, most leading technologies currently in the ecosystem?\n+- What are the best practices for using technology XXX?\n+- What is the purpose of technology XXX?\n+- How does technology XXX work?\n+- How do I use technology XXX?\n+- How do I migrate to the new version of technology XXX?\n+- Why should I use technology XXX over technology YYY?\n+\n+All of the above and more can be answered in the tutorial. Whether you’re a beginner, intermediate or a professional, we will have the answers you’re looking for.\n+\n+**What technologies does Whatsapp Clone uses?**\n+\n+Currently, Whatsapp Clone uses:\n+\n+- [React (with Hooks and Suspense)](http://react.com)\n+- [Styled-Components](https://styled-components.com)\n+- [Material-UI](https://material-ui.com)\n+- [TypeScript](https://typescriptlang.org)\n+- [Apollo GraphQL](https://www.apollographql.com)\n+- [GraphQL Code Generator](http://graphql-code-generator.com)\n+- [GraphQL Modules](https://graphql-modules.com)\n+- [PostgreSQL](https://www.postgresql.org/)\n+- [TypeORM](https://github.com/typeorm/typeorm)\n+\n+The point of this tutorial is not to be bound to a certain technology, but rather keep itself aligned with the ecosystem. When a new technology comes out, and it’s better and more popular, Whatsapp Clone will use it at some point (and full migration instructions).\n+\n+**P2P tutorial for the community by the community**\n+\n+What better way would it be to keep Whatsapp Clone aligned with the ecosystem than letting the community maintain it? Rather than dictating what technologies will be used in the app or how’s the tutorial gonna be written, you’re gonna decide how things are gonna be. That’s why we made it open source:\n+\n+- [Whatsapp Clone - Client](https://github.com/Urigo/WhatsApp-Clone-Client-React/tree/step-by-step-final)\n+- [Whatsapp Clone - Server](https://github.com/Urigo/WhatsApp-Clone-server/step-by-step-final)\n+\n+We’ve also made sure to publish some important documents so you can get more involved. You can track our progress and comment your suggestions, since everything is based on Google Docs and is updated live:\n+\n+- [Road map](https://docs.google.com/document/d/1p2Zio6Js2eoFfHs9CjIMF6jTuNyD4eQEHlgEAKhAqM8/edit?usp=sharing)\n+- [Chapter manuals] (https://drive.google.com/open?id=1ITxOniS_S3sgZfunLvtJ1L9P6Fj1YOLlFHhoQPjT3S0)\n+\n+**Migration instructions included**\n+\n+The are great tutorials out there, but almost none of them shows you what changes you should make in your app in order to be aligned with a new version of a certain technology. Technologies are being updated by the minute, some changes are minor and insignificant, but often times a breaking change will be made in which case we need to know how we can adapt to that change. Thanks to the [Tortilla platform](https://tortilla.academy), we can provide you with a git-diff that will show you what changes were made between each and every released version of the Whatsapp Clone tutorial since the beginning of history. This way you can easily notice the changes in APIs and migrate your app in no time.\n+\n+![tutorial-versions-diff](https://user-images.githubusercontent.com/7648874/54142148-0f8ea080-4462-11e9-9522-ec9997b76169.png)\n+\n+**Prerequisites**\n+\n+- JavaScript\n+- TypeScript\n+- JSX\n+- HTML\n+- CSS\n+- Node.JS\n+- NPM\n+- React\n+- SQL\n+\n+OS operations such as navigating to a folder, or creating a folder, are all gonna be written in Bash, but the instructions are OS agnostic and can be applied on any machine that is web-compatible.\n+\n+**What’s on the tutorial?**\n+\n+Whatsapp Clone is built chronologically, from the most basic, to more higher level features, so be sure to execute it in the right order. Each step is focused on a different subject, so by the end of it you’ll have a new feature and a new set of knowledge that you can start implementing in your everyday scenario immediately.\n+\n+Currently, Whatsapp Clone includes the following chapters:\n+\n+- [Step 1: Creating a basic React APP with a basic view.](https://github.com/Urigo/WhatsApp-Clone-Tutorial/blob/final/.tortilla/manuals/views/step1.md)\n+- [Step 2: Styling with Material-UI and Styled-Components.](https://github.com/Urigo/WhatsApp-Clone-Tutorial/blob/final/.tortilla/manuals/views/step2.md)\n+- [Step 3: Setting a basic Node.JS server with basic a basic REST endpoint.](https://github.com/Urigo/WhatsApp-Clone-Tutorial/blob/final/.tortilla/manuals/views/step3.md)\n+- [Step 4: Transition to GraphQL.](https://github.com/Urigo/WhatsApp-Clone-Tutorial/blob/final/.tortilla/manuals/views/step4.md)\n+- Step N: TBA\n+\n+Whatsapp Clone is updated on a regular basis, so you should expect more steps and extensions to it not long from now. You can keep track of our [road map](https://docs.google.com/document/d/1p2Zio6Js2eoFfHs9CjIMF6jTuNyD4eQEHlgEAKhAqM8/edit?usp=sharing) to see what’s upcoming.\ndiff --git a/.tortilla/manuals/templates/step1.tmpl b/.tortilla/manuals/templates/step1.tmpl\nnew file mode 100644\nindex 0000000..deed5cb\n--- /dev/null\n+++ b/.tortilla/manuals/templates/step1.tmpl\n@@ -0,0 +1,119 @@\n+In this chapter we will learn how to create a basic React app. The app will contain a basic view that will render a list of conversations within our app. Everything should be done gradually, so for now, instead of using real data, we will use in-memory fake data instead of calling a server.\n+\n+There are many ways to create an application. Indeed, you can create it from scratch, but the point behind development is that you'll make the least amount of work if possible. The point is to create a working product, and time is what matters, thus we're gonna use a boilerplate to kick-start our application. When it comes to React apps, the most popular is [`create-react-app`](https://github.com/facebook/create-react-app), which is pretty generic and easy to use. In addition, it's officially maintained by Facebook, the creators of React.\n+\n+`create-react-app` is a CLI that is installable via NPM:\n+\n+    $ npm install -g create-react-app\n+\n+Once you do so, you will have it available in your terminal. If the installation failed, try to run the command as `sudo`:\n+\n+\t$ sudo npm install -g create-react-app\n+\n+Using the `create` command, we can create the basis for our Whatsapp Clone:\n+\n+    $ create-react-app create whatsapp-clone-client\n+\n+> Note how we used the `client` prefix. That's because we're planning to create a server as well in further chapters.\n+\n+It will create a directory called `whatsapp-clone-client` inside the current folder. Inside that directory, it will generate the initial project structure and install the transitive dependencies:\n+\n+    my-app\n+    ├── README.md\n+    ├── node_modules\n+    ├── package.json\n+    ├── .gitignore\n+    ├── public\n+    │   ├── favicon.ico\n+    │   ├── index.html\n+    │   └── manifest.json\n+    └── src\n+        ├── App.css\n+        ├── App.js\n+        ├── App.test.js\n+        ├── index.css\n+        ├── index.js\n+        ├── logo.svg\n+        └── serviceWorker.js\n+\n+No configuration or complicated folder structures, just the files you need to build your app. Once the installation is done, you can open your project folder:\n+\n+\t$ cd whatsapp-clone-client\n+\n+Inside the newly created project, you can run some built-in commands:\n+\n+\t$ npm start\n+\n+Runs the app in development mode. Open `http://localhost:3000` to view it in the browser:\n+\n+![boilerplate-page](https://user-images.githubusercontent.com/7648874/54026782-025f8080-41da-11e9-9a4e-796fe15e8d03.png)\n+\n+The project that was created for us by `create-react-app` is highly functional and ready to use, but it's implemented in JavaScript. In our project, we're gonna use TypeScript. There's no right or wrong here, it's more of a personal choice. The main advantage of using TypeScript over using plain JavaScript is that we get to tell the compiler what types and data structures we expect in certain places, so that the compiler (which unlike a human never forgets) will remind us when we make a mistake and assume something that is not true.\n+\n+Luckily enough, `create-react-app` comes with a TypeScript support right out of the box, we only need to make a few adjustments in-order to make it work. First we need to install the TypeScript package, which is essential for TypeScript to function:\n+\n+\t$ yarn add typescript\n+\n+Every TypeScript project requires a `tsconfig.json` to be defined. This configuration file will dictate the behavior of TypeScript within that project. More about `tsconfig.json` and its available options can be found in the [official TypeScript handbook](https://www.typescriptlang.org/docs/handbook/tsconfig-json.html). This is the config file we're gonna use in our project:\n+\n+{{{ diffStep \"1.1\" module=\"client\" files=\"tsconfig.json\" }}}\n+\n+We're also gonna add a `tslint.json` file into the project - a file which will determine the linting preferences for our project. All rules are listed and explained in the [official rules doc page](https://palantir.github.io/tslint/rules/). We will use the following rules:\n+\n+{{{ diffStep \"1.1\" module=\"client\" files=\"tslint.json\" }}}\n+\n+Once we will run the app for the first time, `react-scripts` (`create-react-app` utility scripts package) should automatically initialize some additional TypeScript related files:\n+\n+\t$ npm start\n+\n+Since we're gonna use the new React [Hooks](https://reactjs.org/docs/hooks-intro.html) and [Suspense](https://reactjs.org/docs/react-api.html#reactsuspense) mechanisms, **make sure that your app uses React version 16.8 or above, otherwise it won't work.** The React version can be determined simply by looking at the `package.json` file. If by any chance your React version is lower than the required one, be sure to upgrade the version of `create-react-app` by upgrading it to the latest one and repeat the process of the project creation. Just in case, `create-react-app` can be upgrade by re-running the install command:\n+\n+\t$ npm install -g create-react-app\n+\n+Assuming that everything is set, we will now create our first screen - ChatsListScreen. The ChatsListScreen component is responsible for showing the active conversations within our app. Everything should be done gradually, so for now, instead of using real data, we will use in-memory fake data. Further in this tutorial, we will also create a server that will serve that data and connect it to our client.\n+\n+It's best to first schematically plan how our view's gonna look like. This would help us illustrate the intended view and also understand which React.Components / elements take part in it. This is how our screen's gonna look like:\n+\n+![chatslistscreen](https://user-images.githubusercontent.com/7648874/54027873-01305280-41de-11e9-9df0-5ad9c9c2f226.png)\n+\n+Let's break down the image above and see what components are we gonna have in the ChatsListScreen:\n+\n+- Navbar -  Which should contain a simple static title for now.\n+- ChatsList - Where each item's gonna contain some data regards the user we're chatting with and information about the chat.\n+\n+React apps tend to store React.Components under a directory located at `src/components`, and so we're gonna follow this pattern. We will create a directory called ChatsListScreen in the `components` dir where we're simply gonna import and put together the Navbar and ChatsList components. This is how the contents of that directory should look like:\n+\n+    ChatsListScreen\n+    ├── index.tsx\n+    ├── ChatsList\n+    └── ChatsNavbar\n+\n+We will use the `index.tsx` file to define that component, this way we can import it using the directory name:\n+\n+{{{ diffStep \"1.2\" module=\"client\" files=\"components/ChatsListScreen/index.jsx\" }}}\n+\n+Now we can implement the Navbar component, which doesn't have much for now except some text describing the app:\n+\n+{{{ diffStep \"1.2\" module=\"client\" files=\"components/ChatsListScreen/ChatsNavbar.jsx\" }}}\n+\n+And the ChatsList component:\n+\n+{{{ diffStep \"1.2\" module=\"client\" files=\"components/ChatsListScreen/ChatsList.jsx\" }}}\n+\n+You can see in the code-diff above how we used the [`moment`](https://momentjs.com/) library to wrap `lastMessage.createdAt`. Moment has the ability to wrap date objects nicely and rewrite them in a pretty format. This way we can have an elegant time format at which the message was sent e.g. `11:34`. To install:\n+\n+\t$ yarn add moment\n+\n+The ChatsList component has no event handlers and it's completely non-interactive as for now, that means that you can't click or tap anything yet, but as we go further in the tutorial we will add the necessary event handlers. Note how we used the `db.ts` module to get the chats data. `db.ts` is a temporary mock for our data-source and should be removed once we have a server up and running. Here's how our DB looks like:\n+\n+{{{ diffStep \"1.3\" module=\"client\" }}}\n+\n+The ChatsListScreen is now ready to use. We will replace the contents of the App component with the ChatsListScreen and we will make it the default screen in our app:\n+\n+{{{ diffStep \"1.4\" module=\"client\" files=\"App.jsx\" }}}\n+\n+If you'll try to run the app you'll see that everything is there, but it's not hard to notice that it's missing some style:\n+\n+![naked-chats-list](https://user-images.githubusercontent.com/7648874/54028578-73099b80-41e0-11e9-803a-7469300acb06.png)\n+\n+In the next chapter we will take care of styling our application with [Material-UI](https://material-ui.com/) and [styled-components](https://www.styled-components.com/) - we will give it the desired look and make it more user friendly. For now the ChatsListScreen serves no purpose, because you can't really do anything with it, but it can be used as a great basis to build on top of as we make progress.\ndiff --git a/.tortilla/manuals/templates/step2.tmpl b/.tortilla/manuals/templates/step2.tmpl\nnew file mode 100644\nindex 0000000..755534e\n--- /dev/null\n+++ b/.tortilla/manuals/templates/step2.tmpl\n@@ -0,0 +1,118 @@\n+Styled-components is a relatively new library that will transpile a given string into a CSS string and will encapsulate it under a React.Component. What's good about it is that you can define your style programmatically and it fits very well into React. With JavaScript in-hand you naturally have more control over your style, which makes it a very powerful tool.\n+\n+Here's one way to style a button using styled-components:\n+\n+```js\n+const Button = styled.button`\n+  background: transparent;\n+  border-radius: 3px;\n+  border: 2px solid palevioletred;\n+  color: palevioletred;\n+  margin: 0.5em 1em;\n+  padding: 0.25em 1em;\n+\n+  ${props => props.primary && css`\n+    background: palevioletred;\n+    color: white;\n+  `}\n+`;\n+```\n+\n+The created Button is actually a React.Component, so an instance of it can be created with ease like any other component:\n+\n+```jsx\n+  <Button primary />\n+```\n+\n+More information about styled-components can be found in the official [docs page](https://www.styled-components.com/docs).\n+\n+We would also use [Material-UI](https://material-ui.com/) - a library with a set of React components that implements Google's Material Design. What's good about it is that the design is already implemented right out of the box. Not only that, but it also includes a set of icons which are free to use.\n+\n+There are many many things that Material-UI can offer, and it's not easy to follow it up, especially with the constantly evolving and improving API. The best way to go with it, is to have a component, and then look for it in the [official website](https://material-ui.com/). When it comes to searching for icons, they can be found in the [material.io](https://material-ui.com/) website through the search bar. As we move further in this tutorial you should have a better grasp of Material and how to use it.\n+\n+![material-ui-icons](https://user-images.githubusercontent.com/7648874/54141504-c853e000-4460-11e9-94b5-aae98ec9a1e3.png)\n+\n+We will start off by installing both libraries:\n+\n+  $ npm install @material-ui/core @material-ui/icons styled-components\n+\n+`@material-ui/core` includes core component of Material-UI such as Input, Popover, Modal, etc, and `@material-ui/icons` includes a set of icons. Material is very generic and has a built in theming system which can be controlled by simply setting few variables, which is exactly what we're gonna need in our app.\n+\n+In our app we're mainly gonna use 2 colors:\n+\n+- Primary #306759\n+- Secondary #79e352\n+\n+Theme definition can easily be done in Material using the MuiThemeProvider component:\n+\n+{{{ diffStep \"2.2\" module=\"client\" }}}\n+\n+Once we have it set, the colors should be available to use in our application by simply providing the \"color\" prop to the component instance whose color we would like to change:\n+\n+```jsx\n+<Button color=\"primary\">Primary</Button>\n+<Button color=\"secondary\">Secondary</Button>\n+```\n+\n+In our app, we're also gonna use CSS directly to change its colors, therefore it would be handy to have these theme variables available to us through CSS. To do so, we will have have a second definition of these variables in `index.css`, at the `:root` level of our application.\n+\n+{{{ diffStep \"2.3\" module=\"client\" }}}\n+\n+`:root` is a pseudo element that simply represents the root node, which will make the colors available in all elements. Normally, it works like JavaScript's scoping system and it will make variables available only to the current node and to its children, NOT its parents. CSS vars can be used like so:\n+\n+```css\n+  color: var(--primary-text);\n+  background-color: var(--primary-bg);\n+```\n+\n+More information about CSS variables can be found in the [official MDN docs](https://developer.mozilla.org/en-US/docs/Web/CSS/Using_CSS_variables).\n+\n+So getting back to the ChatsListScreen, we will wrap the ChatsNavbar with Material's <Toolbar /> component:\n+\n+{{{ diffStep \"2.4\" module=\"client\" files=\"ChatsNavbar.tsx\" }}}\n+\n+And we will replace the `<ul />` and `<li />` elements with Material's `<List />` and `<ListItem />` in ChatsList:\n+\n+{{{ diffStep \"2.4\" module=\"client\" files=\"ChatsList.tsx\" }}}\n+\n+Thanks to the `button` attribute we can give our list a more vibrant feeling and that will display a nice ripple effect once an item is clicked, something that could have taken a long time to implement manually.\n+\n+Next, we will use `styled-components` to create new React.Components which are bound into a style-sheet. This way when we create new instances of them, the components will be styled right out of the box. Example:\n+\n+```jsx\n+const Button = styled.button `\n+  border-radius: 999px;\n+`\n+\n+const RedButton = styled(Button) `\n+  color: red;\n+`\n+\n+const GreenButton = styled(Button) `\n+  color: green;\n+`\n+\n+const BlueButton = styled(Button) `\n+  color: blue;\n+`\n+\n+const Dashboard = (\n+  <div>\n+    <RedButton />\n+    <GreenButton />\n+    <BlueButton />\n+  </div>\n+)\n+```\n+\n+The clear advantage of such working strategy is that all the styles are encapsulated, unlike traditional CSS where style rules can easily collide and be merged unintentionally. Remember that **`styled-components` operates per component, not globally**. In terms of syntax and API there isn't much to explain, it's very intuitive and if you would follow the step-diffs in this tutorial carefully you should get the hang of `styled-components` pretty easily.\n+\n+Accordingly, let's use `styled-components` our `ChatsListScreen`:\n+\n+{{{ diffStep \"2.5\" module=\"client\" files=\"ChatsListScreen\" }}}\n+\n+Notice that we've changed the structure of the HTML of the ChatsList component. We've added the ChatInfo to allow better alignment of the elements. **There isn't right or wrong way to define CSS rules and HTML, as long as the script is clear and easy to understand, that will do**.\n+\n+We're done styling `ChatsListScreen`. We will keep using the same principles to style the rest of the components in our application. The final result should look like so:\n+\n+![screenshot](https://user-images.githubusercontent.com/7648874/54141766-40baa100-4461-11e9-8dd0-59edcfdb3b84.png)\ndiff --git a/.tortilla/manuals/templates/step3.tmpl b/.tortilla/manuals/templates/step3.tmpl\nnew file mode 100644\nindex 0000000..ee1ac2c\n--- /dev/null\n+++ b/.tortilla/manuals/templates/step3.tmpl\n@@ -0,0 +1,131 @@\n+So we have a running app with a single screen which looks stylish and presents some data to the user. There is something missing though. The data that is presented is just a mock for a server response, and it represents the schema of some real data to come.\n+\n+Even if we'll create real data on the client, that means that when the client is down, all the data is lost. But this is a social app, many people want to use it together and even the same person wants to use it on multiple devices. For that, we need a central place to store all data and all the clients would connect to that central place in order to retrieve or change the data.\n+\n+In this step, we will write a Node.JS server and will expose a REST endpoint that will serve the data-mock. We will build the REST application using [Express](https://www.npmjs.com/package/express). Further in this tutorial, we will migrate to using a real data-base with real I/O from the user, so we got you covered.\n+\n+The plan is to have a server up and running at `localhost:4000` that will expose a `GET /chats` route. Unlike our client application, we're not gonna use any boilerplate and we're gonna set everything up manually. Ofcourse, you should feel free to use a boilerplate if it looks right to you. Right outside the client project, we will create a new directory called `whatsapp-clone-server` in which we will start creating our server:\n+\n+    $ mkdir whatsapp-clone-server\n+    $ cd whatsapp-clone-server\n+\n+Then we will use NPM to initialize a new project:\n+\n+    $ npm init --yes\n+\n+> `--yes` will answer yes to all questions and skip the prompt. It's just faster this way.\n+\n+There's nothing special about this command, it only creates a basic package.json which we can add things on top (see [NPM's official docs](https://docs.npmjs.com/cli/init)). Just to make sure that things work, we will add an `index.js` file which will print \"hello world\" to the console.\n+\n+{{{ diffStep \"1.1\" module=\"server\" files=\"index.js\" }}}\n+\n+\n+And we will add a startup script to the `package.json` file called `start`:\n+\n+    start: node index.js\n+\n+NPM-scripts are just a way to defined an alias for commands. Now we only have one simple script, but it can turn out to be something very complex depending on our server, so it can be very useful. More about npm-scripts can be found in the [official NPM docs](https://docs.npmjs.com/misc/scripts).\n+\n+Now we can run our server by running `$ npm start` and we should see the message \"hello world\" printed to the console, as expected.\n+\n+Like in our client's app, we will be using TypeScript. It's comfortable and it enables consistency between both apps. In order to use TypeScript we will install few packages:\n+\n+    $ npm install --dev typescript ts-node @types/node\n+\n+> Note how we used the `--dev` flag. This project is not gonna be required as an external dependency anywhere, but It is still common to separate between production dependencies and development dependencies. More about the `--dev` option can be read in the [NPM-install docs](https://docs.npmjs.com/cli/install).\n+\n+- The [`typescript`](https://www.npmjs.com/package/typescript) package is TypeScript's core transpiler.\n+- [`ts-node`](https://www.npmjs.com/package/ts-node) is an interpreter that will transpile required `.ts` files into JavaScript at runtime.\n+- [`@types/node`](https://www.npmjs.com/package/@types/node) will make the appropriate definitions for a Node.JS environment.\n+\n+> You can read more about the `@types` monorepo in the [official GitHub repository](https://github.com/DefinitelyTyped/DefinitelyTyped).\n+\n+Our server is gonna use the following `tsconfig.json` file, feel free to make the necessary modifications based on your needs:\n+\n+{{{ diffStep \"1.2\" module=\"server\" files=\"tsconfig.json\" }}}\n+\n+We will rename the `index.js` file to `index.ts`:\n+\n+    $ mv index.js index.ts\n+\n+And we will update the npm-script `start` to use `ts-node`, since we wanna use TypeScript, and not JavaScript directly:\n+\n+    start: ts-node index.ts\n+\n+We can test the startup of our server again by running `$ npm start` and we should see the message \"hello world\" printed to the console. The skeleton of the project is set and we can move on to implementing the REST API.\n+\n+Like we said at the beginning, we will be using Express to setup the API. Express is wrap around the native [Node.JS \"http\"](https://nodejs.org/api/http.html) library which is responsible for handling HTTP requests. Yes, it can also be used directly, but Express is much more comfortable and has an amazing ecosystem built around it. Let's install Express and its TypeScript definitions:\n+\n+    $ npm install express\n+    $ npm install --dev @types/express\n+\n+Before we implement the `GET /chats` route we will implement a `GET /_ping` route. This route will be used to determine whether the server is up and running or not, and how fast the connection is based on the response time. For every request sent to this route, we should expect a response saying \"pong\". Some call it \"heartbeat\", because this route is being tested repeatedly by the hosting machine to check if it's alive, just like a heartbeat in a way. This is how the route should look like:\n+\n+{{{ diffStep \"1.3\" module=\"server\" files=\"index.ts\" }}}\n+\n+We can use the `$ curl localhost:4000/_ping` command to send a request to the server and we should get a \"pong\", assuming that the server available on that URL. The `GET /chats` should be implemented similarly, only the response is different. Instead of returning \"pong\" we will return the data-mock for our chats:\n+\n+{{{ diffStep \"1.4\" module=\"server\" files=\"index.ts, db.ts\" }}}\n+\n+Unlike the previous route, we used the `.json()` method this time around to send a response. This will simply stringify the given JSON and set the right headers. Similarly to the client, we've defined the db mock in a dedicated file, as this is easier to maintain and look at.\n+\n+It's also recommended to connect a middleware called [`cors`](https://www.npmjs.com/package/cors) which will enable cross-origin requests. Without it we will only be able to make requests in localhost, something which is likely to limit us in the future because we would probably host our server somewhere separate than the client application. Let's install the `cors` library and load it with the Express `middleware()` function:\n+\n+    $ npm install cors\n+\n+{{{ diffStep \"1.4\" module=\"server\" files=\"index.ts\" }}}\n+\n+The server is now ready to use! So getting back to the client, first we will define our server's URL under the `.env` file:\n+\n+{{{ diffStep \"3.1\" module=\"client\" }}}\n+\n+This will make our server's URL available under the `process.env.REACT_APP_SERVER_URL` member expression and it will be replaced with a fixed value at build time, just like macros. The `.env` file is a file which will automatically be loaded to `process.env` by the [`dotenv`](https://www.npmjs.com/package/dotenv) NPM package. `react-scripts` then filters environment variables which have a `REACT_APP_` prefix and provides the created JSON to a Webpack plugin called [DefinePlugin](https://webpack.js.org/plugins/define-plugin/), which will result in the macro effect.\n+\n+Now let's move back into our React app folder. We will now replace the local data-mock usage with a fetch from the server. For that we can use the native [fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API), however, it needs to be used in the right life-cycle hook of the React.Component.\n+\n+There are 2 naive approaches for that:\n+\n+- Calling `fetch()` outside the component, but this way that chats will be fetched even if we're not even intending to create an instance of the component.\n+\n+```js\n+fetch().then(() => /* ... */)\n+const MyComponent = () => {}\n+```\n+\n+- Calling `fetch()` inside the component, but then it will be invoked whenever the component is re-rendered.\n+\n+```js\n+const MyComponent = () => {\n+  fetch().then(() => /* ... */)\n+}\n+```\n+\n+These 2 approaches indeed work, but they both fail to deliver what's necessary on the right time. In addition, there's no way to properly coordinate async function calls with the render method of the component.\n+\n+**Introducing: React hooks**\n+\n+With React hooks we can invoke the desired logic in the right life-cycle stage of the target component. This way we can avoid potential memory leaks or extra calculations. To implement a proper `fetch()`, we will be using 2 React hooks:\n+\n+- [`React.useState()`](https://reactjs.org/docs/hooks-reference.html#usestate) - which is used to get and set a state of the component - will be used to store the fetch chats.\n+\n+```js\n+const [value, setValue] = useState(initialValue)\n+```\n+\n+- [`React.useMemo()`](https://reactjs.org/docs/hooks-reference.html#usememo) - which is used to run a computation only once certain conditions were met - will be used to run the `fetch()` function only once the component has mounted.\n+\n+```js\n+const memoizedValue = useMemo(calcFn, [cond1, cond2, ...conds])\n+```\n+\n+The result of that approach will look like this, in the context of our ChatsList component:\n+\n+{{{ diffStep \"3.2\" module=\"client\" }}}\n+\n+> It's recommended to read about React hooks and their basic concept at the [official React docs page](https://reactjs.org/docs/hooks-overview.html).\n+\n+At this point we can get rid of `db.ts` file in the client, since we don't use it anymore:\n+\n+    $ rm src/db.ts\n+\n+That's it. Our ChatsListScreen is now connected to a working back-end. In the next step we will upgrade our REST API into a GraphQL API and we will create a basis for a more robust back-end.\ndiff --git a/.tortilla/manuals/templates/step4.tmpl b/.tortilla/manuals/templates/step4.tmpl\nnew file mode 100644\nindex 0000000..54895ff\n--- /dev/null\n+++ b/.tortilla/manuals/templates/step4.tmpl\n@@ -0,0 +1,192 @@\n+**What is GraphQL?**\n+\n+[GraphQL](https://graphql.org/) is a query language invented by Facebook, and it's used to query data within our API. It allows clients to define the structure of the data required, and the exact same structure of data will be returned from the server, therefore preventing excessively large amounts of data from being returned. Unlike REST, GraphQL APIs are organized in terms of types and fields, not endpoints.\n+\n+Currently in our app, if we'd like to get its chats we would send a GET request to `/chats`. With GraphQL it would be done differently with a string that describes the data that we would like to get:\n+\n+```graphql\n+chats {\n+  id\n+  name\n+  picture\n+  lastMessage {\n+    id\n+    content\n+    createdAt\n+  }\n+}\n+```\n+\n+> Above: An illustration of a potential GraphQL query sent to our Whatsapp API\n+\n+**Why GraphQL and not REST?**\n+\n+In terms of experience REST got the upper hand. It has been used for many more years and has proven itself to work well, and it's completely agnostic to the implementation of the back-end. However, when it comes to data projection and aggregation, it fails to deliver.\n+\n+When using REST, often times you'll find yourself performing multiple requests to execute a single query of data. Not only that, you might even end up with additional data that is not necessary. Either way, the process would result in slower and heavier response.\n+\n+With GraphQL we don't have that kind of problem. Queries may take many shapes and forms, and since GraphQL is schema based - it can handle it. You'll get exactly what you asked for with a single request. **GraphQL provides a dynamic API while REST doesn't.**\n+\n+```graphql\n+# request\n+query {\n+  chat(id: 1) {\n+    id\n+    name\n+    lastMessage {\n+      id\n+      content\n+    }\n+  }\n+}\n+```\n+\n+![graphql-request](https://user-images.githubusercontent.com/7648874/54133620-5aec8300-4451-11e9-9bda-a459dc48f57c.png)\n+\n+```js\n+// response\n+{\n+  \"data\": {\n+    \"chat\": {\n+      \"id\": 1,\n+      \"name\": \"Ethan Gonzalez\",\n+      \"lastMessage\": {\n+        \"id\": 1,\n+        \"content\": \"You on your way?\"\n+      }\n+    }\n+  }\n+}\n+```\n+\n+**GraphQL schema, in a nutshell**\n+\n+Like said earlier,  GraphQL APIs are organized in terms of types and fields. That means that our app data should be described with a schema, where each field's gonna have a resolver - the handler that will return the corresponding data. Things will be much clearer as we move further.\n+\n+Let's try to describe our app's data with a GraphQL schema and then dive into it:\n+\n+```graphql\n+scalar Date\n+\n+type Message {\n+  id: ID!\n+  content: String!\n+  createdAt: Date!\n+}\n+\n+type Chat {\n+  id: ID!\n+  name: String!\n+  picture: String\n+  lastMessage: Message\n+}\n+\n+type Query {\n+  chats: [Chat!]!\n+}\n+```\n+\n+The schema is self explanatory in terms of what data it's compatible with. Supported built-in scalar types in GraphQL are:\n+\n+- Int: Signed 32‐bit integer\n+- Float: Signed double-precision floating-point value\n+- String: UTF‐8 character sequence\n+- Boolean: true or false\n+- ID (serialized as String): A unique identifier, often used to refetch an object or as the key for a cache. While serialized as a String, ID signifies that it is not intended to be human‐readable\n+\n+Any custom scalar can be declared with the `scalar` keyword, and custom types can be declared with the `type` keyword. However, you should know that some types are reserved by GraphQL itself; `Query` is one of them. The `Query` type will be used as the root for received queries by the clients, which means that we can send queries which start with the `chats` field. Other reserved types are:\n+\n+- `type Query` - reserved for [GraphQL queries](https://graphql.org/learn/queries/#mutations).\n+- `type Mutation` - reserved for [GraphQL mutations.](https://graphql.github.io/learn/queries/)\n+- `type Subscription` - reserved for [GraphQL subscriptions.](https://www.apollographql.com/docs/react/advanced/subscriptions.html)\n+\n+> As we're not gonna go through the entire GraphQL API, it's recommended to go through the [official learn section of the GraphQL website](https://graphql.org/learn/), but the information so far will definitely help you kick-start, plus the upcoming implementation.\n+\n+**Getting started**\n+\n+We will be implementing a GraphQL mechanism for the client and for the server. We will start with the server as things will make more sense, and we will be able to test it before we proceed into the client. Essentially GraphQL is connected into a HTTP endpoint, usually under `POST /graphql`, and so this is exactly what we're gonna do, connect the endpoint handler. Luckily, we don't have to implement that. A team called [Apollo](https://www.apollographql.com/) already did it for us, so we can use their implementation. We will install the required packages:\n+\n+    $ npm install apollo-server-express body-parser graphql\n+    $ npm install --dev @types/body-parser @types/graphql\n+\n+- [`graphql`](https://www.npmjs.com/package/graphql) - The core package of GraphQL that includes the resolvers for basic data-types.\n+- [`apollo-server-express`](https://www.npmjs.com/package/apollo-server-express) - Apollo's implementation for the GraphQL Express REST endpoint.\n+- [`body-parser`](https://www.npmjs.com/package/body-parser) - Parse incoming request bodies in a middleware before your handlers, available under the req.body property.\n+- `@types/…` - TypeScript definitions\n+\n+We can now connect Apollo's middleware under the `/graphql` route:\n+\n+{{{ diffStep \"2.1\" module=\"server\" files=\"index.ts\" }}}\n+\n+As you can see, the middleware requires a schema. A schema is composed mainly out of 2 fields:\n+\n+- `typeDefs` (type definitions) - the schema types we wrote earlier this chapter for chats.\n+- `resolvers` - The handlers that will provide the data for each field in `typeDefs`.\n+\n+We will start first by defining the types. All we have to do is to copy-paste the contents of the schema that was shown earlier into a new file called `typeDefs.graphql`:\n+\n+{{{ diffStep \"2.2\" module=\"server\" files=\"typeDefs.graphql\" }}}\n+\n+The `.graphql` file extension is just a more convenient way to work with a GraphQL schema. The exported result should be a simple string that we can use to compose our GraphQL schema. The clear advantage of working with a dedicated file is that we get to have syntax highlight.\n+\n+Now we will implement the resolvers. Resolvers are presented in a JSON object where each resolver name should match the field name it represents. You can read more about resolvers in [Apollo's official docs for resolvers](https://www.apollographql.com/docs/tutorial/resolvers.html). This is how our resolvers should look like:\n+\n+{{{ diffStep \"2.2\" module=\"server\" files=\"resolvers.ts\" }}}\n+\n+For now it's extremely simple, we map the chats query directly into the database collection. Each field in the resolvers object should match the GraphQL type it represents in the schema. Since we don't have any logic now, we should not implement any resolvers for the rest of the types, the data will simply be forwarded as is.\n+\n+Note that we've implemented a custom scalar named `Date` and we resolved it with an NPM package. Let's install it:\n+\n+    $ npm install graphql-iso-date\n+    $ npm install --dev @types/graphql-iso-date\n+\n+Final thing that we have to do would be combining the resolvers and the type-defs under a single GraphQL schema.\n+\n+{{{ diffStep \"2.2\" module=\"server\" files=\"index.ts\" }}}\n+\n+[`graphql-import`](https://www.npmjs.com/package/graphql-import) and [`graphql-tools`](https://www.npmjs.com/package/graphql-tools) are utility packages that will help us create a schema that will be compatible with Apollo's API. Let's install them:\n+\n+    $ npm install graphql-import graphql-tools\n+\n+There's one optimization however that we should make in the our DB. Right now, the each chat document has a direct reference to a message via the `lastMessage` field. Practically speaking, this is NOT how the data sits in the DB. The `lastMessage` should only hold the ID for the correlated message, and then in the Node.JS app we should **resolve** it according to our needs. Let's make the appropriate changes in the DB then:\n+\n+{{{ diffStep \"2.3\" module=\"server\" files=\"db.ts\" }}}\n+\n+And a resolver to the `lastMessage` field:\n+\n+{{{ diffStep \"2.3\" module=\"server\" files=\"typeDefs.graphql\" }}}\n+\n+The first argument of the resolver is the raw chat data received by the DB, and the returned result should be the mapped value which we would like to return to the client.\n+\n+As we get further in this tutorial we should get a better grasp regards resolvers and their API, since we will have to deal with more logic and complexity within our Node.JS app.\n+\n+Assuming that the server is running, we can already test our GraphQL endpoint. Because it's exposed to us via a REST endpoint, we can use a `$ curl` command to send a request to `GET localhost:4000/graphql` and get a response with all the data. Again, the query that we're gonna use to fetch the chats is:\n+\n+```graphql\n+chats {\n+  id\n+  name\n+  picture\n+  lastMessage {\n+    id\n+    content\n+    createdAt\n+  }\n+}\n+```\n+\n+The one-liner version of it with a `$ curl` command looks like so:\n+\n+    curl \\\n+      -X POST \\\n+      -H \"Content-Type: application/json\" \\\n+      --data '{ \"query\": \"{ chats { id name picture lastMessage { id content createdAt } } }\" }' \\\n+      localhost:4000/graphql\n+\n+As a response we should get the data-mock for our chats stored in the server. Since we have that in place, we can go ahead and delete our implementation for the `GET /chats` route.\n+\n+So getting back to the client, all we have to do is to change the fetching URL in the ChatsList component to use our newly implemented GraphQL REST endpoint:\n+\n+{{{ diffStep \"4.1\" module=\"client\" }}}\n+\n+The received data should be similar to the previous one. No further changes are required. In the next chapter, we will continue working on the UI of our front-end application and we will add a new screen to the flow - the `ChatRoomScreen`.\ndiff --git a/.tortilla/manuals/templates/step5.tmpl b/.tortilla/manuals/templates/step5.tmpl\nnew file mode 100644\nindex 0000000..c91d9a6\n--- /dev/null\n+++ b/.tortilla/manuals/templates/step5.tmpl\n@@ -0,0 +1,126 @@\n+Testing is a crucial part when writing an application, especially if we're planning to publish it or make it a commercial thing. Before we hand someone a product, of any kind, we wanna make sure that it passes certain quality checks. We're signed on that product and so it's very important to ensure that it functions properly according our expectations, otherwise wouldn't wanna use it and will look for alternatives.\n+\n+In the context of software, we constantly make changes. It's also inevitable to make all features completely independent from one another, so something in the app is likely to break as we upgrade it or maintain it. That's why we need to write a set of tests that can be run on demand, so when we implement a new feature we can simply run the tests and see what feature broke due to most recent changes.\n+\n+There are currently 3 main testing frameworks in the NPM ecosystem: [Jasmine](https://jasmine.github.io/), [Mocha](https://mochajs.org/), and [Jest](https://jestjs.io/). Each testing framework has its pros, and cons, and at the end of the day it's a matter of preference. In our application we're gonna use [Jest](https://jestjs.io/) - a testing framework which was developed by Facebook. What's good about Jest is that it can be used to test both client and server logic, because it runs as a Node.JS application, but it also emulates the browser environment whenever we run it, thanks to [JSDOM](https://github.com/jsdom/jsdom).\n+\n+![jest](https://user-images.githubusercontent.com/7648874/54493900-e2ce0380-490f-11e9-8075-be4a236c7c38.png)\n+\n+In this chapter we will learn how to test the React.Components in the client, and Apollo-GraphQL resolvers in the server. There are 3 kinds of tests:\n+\n+- Unit tests - which are used to test a single component, independently from other components in our system.\n+- Integration tests - which are used to test a component in relation to other components in our systems (how well do they co-work with each other).\n+- e2e tests (end to end) - which are used to test a complete, from the moment I clicked on a button in the user interface until the data gets back from the server and shown on the screen.\n+\n+The efficiency of the tests go from bottom to top (unit -> e2e), but the maintenance and complexity go from bottom to top (e2e -> unit). Accordingly we will need to find a good balance where we don’t spend too much time on writing tests yet have a good indicator for how well our system functions. So we should write a lot of unit tests, a good amount of integration tests and a handful of e2e tests.\n+\n+![tests-types-table](https://user-images.githubusercontent.com/7648874/54494121-fed2a480-4911-11e9-9370-694ec989729b.png)\n+\n+We will start with the client as it’s much easier, because Jest is set and ready to use right out of the box thanks to `create-react-app`.\n+\n+**Client - Testing React.Components**\n+\n+Thanks to `create-react-app`, we have Jest set and ready to use right out of the box, so we can start writing tests right away. I you'll look at the `src` you'll see a file called `App.test.tsx`, which simply ensures that the component can be rendered without crashing.\n+\n+```jsx\n+import React from 'react';\n+import ReactDOM from 'react-dom';\n+import App from './App';\n+\n+it('renders without crashing', () => {\n+  const div = document.createElement('div');\n+  ReactDOM.render(<App />, div);\n+  ReactDOM.unmountComponentAtNode(div);\n+});\n+```\n+\n+This is not a typical test that you're likely to find in a React project, but it demonstrates very well how Jest can be used to test DOM related issues. If you'll run `$ npm run test` (or `$ yarn test`) in the command line and then press `a`, you should see the following output:\n+\n+![report](https://user-images.githubusercontent.com/7648874/54341429-eabe4700-4674-11e9-8e76-3aaaf7fec79a.png)\n+\n+Jest will automatically run for every file that ends with a `.test.xxx` extension. This is very convenient because the tests can live right next to the component, and you don't need to lookup for it across the project. This behavior can be modified by configuring Jest in the `package.json` file under the `\"jest\"` field. More information about configuring Jest can be found in the official[ configuration documentation](https://jestjs.io/docs/en/configuration).\n+\n+> If you get a warning message regards wrapping the component with `act()` - this is a known issue with hooks and should have a proper solution soon. More about this issue and progress regards its fix can be found in this [GitHub thread](https://github.com/facebook/react/issues/14769#issuecomment-470097212).\n+\n+Now we're gonna write a basic test for the `<ChatsList />` component. In the test, we'll mock a fake response from the server, and examine the contents of rendered HTML. Since the HTML of the component is a dynamic thing and is constantly subject to changes, it would be a good idea to annotate it with `data-testid` attributes so it can be tested regardless of its structure:\n+\n+{{{ diffStep \"5.1\" module=\"client\" files=\"ChatsList.tsx\" }}}\n+\n+Now we can select various HTML elements with a query selector when we test the component. We will install a couple of packages that will assist us in implementing the test:\n+\n+  $ npm install jest-fetch-mock jest-dom react-testing-library\n+\n+- The [`jest-fetch-mock`](https://www.npmjs.com/package/jest-fetch-mock) package can mock responses emitted by the Fetch API.\n+- The [`jest-dom`](https://www.npmjs.com/package/jsdom) package will add custom matchers that will help us examine HTML contents of DOM elements.\n+- The [`react-testing-library`](https://www.npmjs.com/package/react-testing-library) package contains utility methods that will help us test React.Components with Jest.\n+\n+Next, we will create a file under the `src` folder called `setupTests.ts`. This file is loaded configured automatically by `create-react-app` and loaded by Jest, and we can use it to set up our testing environment according to our needs (like said earlier, Jest can be configured, so this file path can be changed). We will use that file to define a fake Fetch API using the `jest-fetch-mock` library:\n+\n+{{{ diffStep \"5.2\" module=\"client\" files=\"src/setupTests.ts\" }}}\n+\n+We will create another file called `ChatsList.test.tsx`, right next to the `<ChatsList />` component under the `ChatsListScreen` directory, and inside we will implement our test. The test should follow these steps:\n+\n+- Mock the response to contain a fake chat, so we won't need to make an actual call to our GraphQL API.\n+- We will create a new instance of `<ChatsList />` and render it in a container element.\n+- We will wait for changes in the DOM caused by `setState()`.\n+- We will test the contents of the container.\n+\n+And this is how the implementation should look like:\n+\n+{{{ diffStep \"5.3\" module=\"client\" files=\"src/components/ChatsListScreen/ChatsList.test.tsx\" }}}\n+\n+> Jest API is vast but pretty intuitive for the most part. It mostly consists of test descriptors and matchers. [Here's a full list of all matchers which are built into Jest's API](https://jestjs.io/docs/en/expect). Always make sure to work against it when writing tests, for optimal results.\n+\n+We will now move on to testing the server where we will learn how to setup Jest manually and test it against a GraphQL API.\n+\n+**Server - Testing GraphQL resolvers**\n+\n+To set-up Jest, we will run the following in the command line:\n+\n+    $ npm install jest @types/jest ts-jest --dev\n+\n+This will basically install Jest and make it useable with TypeScript. In addition, we will need to specify the file pattern that we would like to transform with [`ts-jest`](https://www.npmjs.com/package/ts-jest), by adding the following section to `package.json`:\n+\n+```\n+{\n+  \"jest\": {\n+    \"transform\": {\n+      \"^.+\\\\.(js|jsx|ts|tsx)$\": \"<rootDir>/node_modules/ts-jest\"\n+    }\n+  }\n+}\n+```\n+\n+We will also add a `\"test\"` script in the `package.json` file, so we can run the tests with `$ npm run test` (or `$ yarn test`):\n+\n+```\n+{\n+  \"scripts\": {\n+    \"test\": \"jest\"\n+  }\n+}\n+```\n+\n+This is how our `package.json` should look like at this point:\n+\n+{{{ diffStep \"3.1\" module=\"server\" files=\"package.json\" }}}\n+\n+Now we're gonna test the `chats` query in our GraphQL schema. To do so, we will setup an Apollo Client and send a query request to our back-end, and then we will match the received response with a pre-defined snapshot. Luckily, we don't have to set an actual client, since the tests and the implementation of the back-end live right next to each other, thus, we will install a package which will help us achieving so:\n+\n+    $ npm install apollo-server-testing --dev\n+\n+We will define the test suite under the `tests/queries` folder in a file called `getChats.test.ts`:\n+\n+{{{ diffStep \"3.2\" module=\"server\" files=\"tests/queries/getChats.test.ts\" }}}\n+\n+In the test function, we create a new instance of the Apollo-GraphQL server using our schema, and we query some data against it thanks to the fake client created by [`apollo-server-testing`](https://www.npmjs.com/package/apollo-server-testing).\n+\n+The `.toMatchSnapshot()` matcher will call the `toString()` method on the examined object and will test it against a predefined snapshot. The snapshot will automatically be created once we run the test for the first time and will be stored under the `__snapshot__` directory. This means that the first test run will always pass. This is useful because you can later on observe and adjust manually the snapshot manually without having to write it from scratch. The expected result should be a projection of the data stored in the `db.ts` file.\n+\n+{{{ diffStep \"3.2\" module=\"server\" files=\"tests/queries/__snapshots__\" }}}\n+\n+Always be sure to observe the snapshot before moving on! The received result isn't necessarily what you'd expect. Also it's not a good practice to store production data in the snapshot because it's subject to changes. Normally we would set up another instance of the DB for testing purposes, but since our DB is a mock and doesn't represent real data, there's no need to at this stage.\n+\n+Now that we have the required knowledge regards testing and Jest's API, we will implement tests throughout the tutorial as a trivial thing. We will not go through each and every new matcher that we introduce, as it is self explanatory and there's too much of them. Be sure to work against [this full list of matchers](https://jestjs.io/docs/en/expect) when working with Jest.\n+\n+In the next chapter we will continue expanding our application by adding a `<ChatRoomScreen />`.\ndiff --git a/.tortilla/manuals/templates/step6.tmpl b/.tortilla/manuals/templates/step6.tmpl\nnew file mode 100644\nindex 0000000..116ffe7\n--- /dev/null\n+++ b/.tortilla/manuals/templates/step6.tmpl\n@@ -0,0 +1,140 @@\n+In this chapter we will learn how to build a chat room screen. We will setup a router, implement the necessary components, and update the state whenever we send a new message. The screen is NOT gonna be connected to the back-end as it will over complicate things for now. Further this tutorial, we will get to make it full-stack.\n+\n+Since we're gonna have to screens in our app now - `ChatsListScreen` and `ChatRoomScreen`, we will need a router that will be able to alternate between them. We will be using the [`react-router-dom`](https://www.npmjs.com/package/react-router-dom) package to manage the routes of the application:\n+\n+  $ npm install react-router-dom\n+\n+And we will implement a router directly in the `<App />` component:\n+\n+{{{ diffStep 6.1 module=\"client\" files=\"App\" }}}\n+\n+The purpose of a router is to make route managing easy and declarative. It will take care of managing the history within our app and parameterizing certain screens according to our need. Essentially it's a wrap around the `window.history` object which is also compatible with React. I recommend you to go through the [official MDN docs](https://developer.mozilla.org/en-US/docs/Web/API/History) if you're not yet familiar with the concept.\n+\n+The `<Route />` component represents a path for a route in our application. Using the colon syntax (`:chatId`) we basically tell the router that the `/chat` route should be followed by a string whose value can later on be addressed via a parameter called `chatId` when navigating to the route. So here's a sum-up of the routes manifest:\n+\n+\n+\n+*   `/chats` - will navigate to the `ChatsListScreen`.\n+*   `/chat/:chatId` - e.g. `/chat/1`, will navigate to the `ChatRoomScreen` and will parameterize it to show data which is related to chat ID 1.\n+*   Any other route will fallback to the `/chats` route which will redirect us to the `ChatsListScreen`.\n+\n+Now we will implement the `ChatRoomScreen` so the router can function properly. For now we will make it a plain screen which simply prints out the information of the chat that was clicked so we can have a complete flow, and then we will take care of the rest.\n+\n+To do so, we will first implement the `chat` query in our backend. This would be a parameterized query that will provide us with a specific chat according to the received ID, and it will be used by the new screen as soon as it is initialized. First we would update the `Chat` type to contain a `messages` field:\n+\n+{{{ diffStep 4.1 module=\"server\" files=\"schema\" }}}\n+\n+And then we will update our DB mock to be aligned with these changes:\n+\n+{{{ diffStep 4.1 module=\"server\" files=\"db\" }}}\n+\n+This means that when we resolve `Chat.lastMessage`, we should get it directly from the `Chat.messages` field:\n+\n+{{{ diffStep 4.2 module=\"server\" }}}\n+\n+Now that we have an updated schema which is relevant to the new screen that we would like to add, we will declare a new query called `chat`:\n+\n+{{{ diffStep 4.3 module=\"server\" files=\"schema/typeDefs\" }}}\n+\n+Note that unlike the `chats` query, this time we have a parameter. The parameters are provided to the resolver function as the second parameter as a JSON. Using the provided parameter - the chat ID, we will find and return the relevant chat from the DB:\n+\n+{{{ diffStep 4.3 module=\"server\" files=\"schema/resolvers\" }}}\n+\n+> More about the resolver signature can be read in [Apollo-GraphQL's official docs page](https://www.apollographql.com/docs/apollo-server/essentials/data.html#type-signature).\n+\n+Now we will add a test suite:\n+\n+{{{ diffStep 4.3 module=\"server\" files=\"tests/queries/getChat.test\" }}}\n+\n+We can observe the snapshot created by Jest to get a better understanding of how the response should look like:\n+\n+{{{ diffStep 4.3 module=\"server\" files=\"__snapshot__\" }}}\n+\n+If you experience any TypeScript related issues with the following error:\n+\n+```\n+Object literal may only specify known properties, and 'variables' does not exist in type 'Query'.\n+```\n+\n+Add the following declaration file to your project:\n+\n+{{{ diffStep 4.3 module=\"server\" files=\"types\" }}}\n+\n+This is a [known issue](https://github.com/apollographql/apollo-server/issues/2172) in the `apollo-server-testing` package and has a pending [fix PR](https://github.com/apollographql/apollo-server/pull/2307). Now getting back to the client, let's implement a basic version of the `ChatRoomScreen` where we will fetch the new query and print it to the screen:\n+\n+{{{ diffStep 6.2 module=\"client\" }}}\n+\n+Note how we used the `match.params.chatId` variable to get the selected chat ID. The `match` prop is defined and provided to us by the `<Route />` component, since it interfaces directly with the `ChatRoomScreen`. More about that can be read in the [official docs page](https://reacttraining.com/react-router/core/api/match). If you'll run the application and type `/chats/1` in the URL bar, this is what you should see on the screen:\n+\n+![naked-chat](https://user-images.githubusercontent.com/7648874/54664314-d4096b80-4b1e-11e9-9e06-1323cf7b0abe.png)\n+\n+The view has no styling at all but it should be fixed in a moment. To make navigation more convenient we will add an `onClick` listener for each chat item in the `ChatsList`. Using the [history](https://reacttraining.com/react-router/core/api/history) object, provided to us by the `<Route />` component, we will navigate to the correlated `ChatRoomScreen`:\n+\n+{{{ diffStep 6.3 module=\"client\" }}}\n+\n+And add test the new logic:\n+\n+{{{ diffStep 6.4 module=\"client\" }}}\n+\n+If you'll click on the chat item you'll see that the screen changes very suddenly. We can smooth the transition by animating it with CSS. Luckily we don't need to implemented such mechanism manually because there's a package that can do that for us - [`react-router-transition`](https://www.npmjs.com/package/react-router-transition):\n+\n+  $ npm install react-router-transition\n+\n+Using this package, we will create a custom `Switch` component that will play an animation for all its subordinate `Route` components. The animation is defined by the user using a component called `AnimatedSwitch` as specified in the [package's docs page](http://maisano.github.io/react-router-transition/animated-switch/props). So first, let's create our switch component that will play a smooth transition switching routes:\n+\n+{{{ diffStep 6.5 module=\"client\" files=\"AnimatedSwitch\" }}}\n+\n+And then replace it with the main `Switch` component in our app:\n+\n+{{{ diffStep 6.5 module=\"client\" files=\"App\" }}}\n+\n+Both components act identically and thus there shall be no special treatment. Behold the new transition effect:\n+\n+![transition-demo](https://user-images.githubusercontent.com/7648874/54739398-ebb22400-4bf2-11e9-8d4c-2aeb65deeb92.gif)\n+\n+The final screen will be composed out of 3 components:\n+\n+\n+\n+*   A navigation bar.\n+*   A messages list.\n+*   A message input.\n+\n+In the main `index.ts` file of the screen we will simply import all 3 in the right order. We will start with the most simple one - the `ChatRoomNavbar`. The navbar should show the picture of the chat we're currently at and its name, along with a back button that will bring us back to the `ChatsListScreen`:\n+\n+{{{ diffStep 6.6 module=\"client\" files=\"ChatNavbar\" }}}\n+\n+Next, would be the `MesagesList` component, where we will see a scrollable list of all the messages of the active chat:\n+\n+{{{ diffStep 6.6 module=\"client\" files=\"MessagesList\" }}}\n+\n+And finally, would be the `MessageInput` component which will trigger an event whenever we type and submit a new message:\n+\n+{{{ diffStep 6.6 module=\"client\" files=\"MessageInput\" }}}\n+\n+Now that we have all 3 components, we will put them all together in the main `index.ts` file:\n+\n+{{{ diffStep 6.6 module=\"client\" files=\"index\" }}}\n+\n+The view is complete! However the `MessageInput` is not bound to our messages list. We will use the triggered callback to update the chat state, whose changes should appear in the `MessagesList` component in the following render phase:\n+\n+{{{ diffStep 6.7 module=\"client\" }}}\n+\n+This is how the entire flow should look like:\n+\n+![flow-demo](https://user-images.githubusercontent.com/7648874/54739741-27012280-4bf4-11e9-97cb-c715482e2e70.gif)\n+\n+Before we wrap things up, we should also test our components. Since the new components have a direct control over the app's history, we should also find a way to simulate it in our tests. The `react-dom-router` uses the [`history`](https://www.npmjs.com/package/history) package under the hood, that means that we can use that package to inject a custom history object directly into the tested components. Let's install this package if so:\n+\n+  $ npm install history --dev\n+\n+And then implement our test suites:\n+\n+{{{ diffStep 6.8 module=\"client\" files=\"components\" }}}\n+\n+There are many things which are incomplete in the current implementation. The functionality exists in the UI, but no messages are really being sent and stored in the database. In the next chapters we will learn how to:\n+\n+\n+\n+*   Cache query results with Apollo-Client.\n+*   Send messages with GraphQL mutations\ndiff --git a/.tortilla/manuals/templates/step7.tmpl b/.tortilla/manuals/templates/step7.tmpl\nnew file mode 100644\nindex 0000000..2a73a5e\n--- /dev/null\n+++ b/.tortilla/manuals/templates/step7.tmpl\n@@ -0,0 +1,105 @@\n+In the previous step we've implemented a `ChatRoomScreen` where we were able to view each chat's messages list by clicking on a chat item from the main screen. It all looks functional, however, there's a significant optimization issue - each time we navigate into a `ChatRoomScreen`, we need to re-fetch the data related to the target chat.\n+\n+The solution for that would be [caching](https://en.wikipedia.org/wiki/Cache_(computing)) the fetch result, so it can be re-used once we re-enter a screen that we've visited before. For now things are fairly simple so the caching mechanism can be implemented manually, but things are gonna get tougher when we add more queries or things like message sending and profile updating to the mix, so it's not gonna be an easy task. Luckily, in the Apollo team they've invented a solution that works right out of the box and integrates perfectly with Apollo-GraphQL server - [Apollo-GraphQL client](https://www.apollographql.com/docs/link/#apollo-client).\n+\n+\n+\n+![caching](https://user-images.githubusercontent.com/7648874/54871150-f505e100-4dea-11e9-9e2d-439fbf3eaebe.png)\n+\n+\n+\n+Apollo-Client is a wrap around our GraphQL REST endpoint which essentially uses HTTP requests (and further on [web-sockets](https://en.wikipedia.org/wiki/WebSocket), but we will get there), something that we've implemented manually so far. Not only it can be used to fetch data, but it will also cache the result of the query so it can be seamlessly re-used when we request the same data. This means that we will need to setup an Apollo-Client and replace all our `fetch()` calls with `client.query()` call. More about Apollo-Client's API further in this tutorial, but let's start configuring it. First we will install few essential NPM packages:\n+\n+  $ npm install apollo-cache-inmemory apollo-client apollo-link apollo-link-http\n+\n+\n+\n+*   [`apollo-client`](https://www.npmjs.com/package/apollo-client) - Apollo-Client's core package, as we explained earlier.\n+*   [`apollo-cache-inmemory`](https://www.npmjs.com/package/apollo-cache-inmemory) - The data store that will be used to cache the results.\n+*   [`apollo-link-http`](https://www.npmjs.com/package/apollo-link-http) - Get GraphQL results over a network using HTTP fetch.\n+\n+We will create a new file in the `src` directory called `client.ts` and inside we will export the client:\n+\n+{{{ diffStep 7.1 module=\"client\" files=\"client\" }}}\n+\n+Although the client can be used directly and integrated into any UI framework, it would be the most comfortable to use a wrap around it which is suitable for React. For that we will use a package called [`react-apollo-hooks`](https://www.npmjs.com/package/react-apollo-hooks) which includes a set of [React hooks](https://reactjs.org/docs/hooks-intro.html) that can connect between our Apollo-Client and target React.Component:\n+\n+  $ npm install react-apollo-hooks graphql-tag\n+\n+With `react-apollo-hooks` we can use the `useQuery()` hook to fetch data from our GraphQL API. The `graphql-tag` package is used to parse the GraphQL string to an [AST](https://en.wikipedia.org/wiki/Abstract_syntax_tree), something which is required when using Apollo Client. Example:\n+\n+\n+```\n+import gql from 'graphql-tag';\n+import { useQuery } from 'react-apollo-hooks';\n+\n+const GET_DOGS = gql`\n+  {\n+    dogs {\n+      id\n+      breed\n+    }\n+  }\n+`;\n+\n+const Dogs = () => {\n+  const { data, error, loading } = useQuery(GET_DOGS);\n+  if (loading) {\n+    return <div>Loading...</div>;\n+  };\n+  if (error) {\n+    return <div>Error! {error.message}</div>;\n+  };\n+\n+  return (\n+    <ul>\n+      {data.dogs.map(dog => (\n+        <li key={dog.id}>{dog.breed}</li>\n+      ))}\n+    </ul>\n+  );\n+};\n+```\n+\n+\n+The package requires a small setup so that imported hooks can use our Apollo-Client:\n+\n+{{{ diffStep 7.2 module=\"client\" files=\"index\" }}}\n+\n+The code above uses the [Context/Provider](https://reactjs.org/docs/context.html) API, thus the client is now known globally. Now that we can use the `useQuery()` hook, there's no need to use the native Fetch API anymore. Let's replace all our Fetch API call instances with a React hook:\n+\n+{{{ diffStep 7.3 module=\"client\" files=\"components\" }}}\n+\n+The replacement is finished. Note that we removed the usage of `useMemo()` - because Apollo has an internal cache mechanism, there's no need to memoize the result anymore. We also used the [`writeQuery()`](https://www.apollographql.com/docs/react/features/caching.html#writequery-and-writefragment) method to edit the stored result in the cache, so in the next render phase we would have an updated chat with the newly added message.\n+\n+We shouldn't feel any change at all in the view and the response time, since we're running it locally, but if we will take a look at the `network` tab in the browser's dev-tools we should notice the differences:\n+\n+**before**\n+\n+![fetch](https://user-images.githubusercontent.com/7648874/54871305-e5879780-4dec-11e9-87bb-3279e9e18342.png)\n+\n+**after**\n+\n+![apollo](https://user-images.githubusercontent.com/7648874/54871319-1bc51700-4ded-11e9-9001-d5518bedf9ad.png)\n+\n+> Above: ChatsListScreen -> ChatRoomScreen -> ChatsListScreen -> ChatRoomScreen\n+\n+This test is obviously very rough, but the deviation is so big that you don't need any accuracy to emphasize the difference. The blue stripes represents the requests made and the time they took. Before we had about 6 request phases, while after we had only 3 of them.\n+\n+Since we don't use the Fetch API anymore, we will also need to update our tests. Right now we mock the response from the fetch API, but a more appropriate way would be creating a fake Apollo Client where we will be able to mock the results. For that we will install a package called [`apollo-link-mock`](https://www.npmjs.com/package/apollo-link-mock):\n+\n+    $ npm install --dev apollo-link-mock\n+\n+And we will create a `test-helpers.ts` file under the `src` directory that will contain the utility function for creating a fake Apollo Client:\n+\n+{{{ diffStep 7.4 module=\"client\" files=\"test-helpers\" }}}\n+\n+The fake client accepts an array of mocks where each mock object will have a `request` key that will contain details about the request and a `result` key which will contain the mocked result. You should get a better understanding of how it works now that we will replace the fake Fetch calls with fake Apollo Clients:\n+\n+{{{ diffStep 7.4 module=\"client\" files=\"src/components\" }}}\n+\n+Note how we used the `ApolloProvider` component to provide the target component with the fake Apollo Client. Like so, any other component which uses Apollo Client should be wrapped with an ApolloProvider when rendering it, otherwise it will not function as intended:\n+\n+{{{ diffStep 7.4 module=\"client\" files=\"src/App\" }}}\n+\n+That's it for this chapter. There's one thing missing to make our `ChatRoomScreen` functional and that would be actually sending a message to the backend and updating the DB. In the next chapter we will learn how to do exactly that with our new Apollo-Client.\ndiff --git a/client/.env b/client/.env\nnew file mode 100644\nindex 0000000..f0fc5d5\n--- /dev/null\n+++ b/client/.env\n@@ -0,0 +1 @@\n+REACT_APP_SERVER_URL=http://localhost:4000\n\\ No newline at end of file\ndiff --git a/client/.gitignore b/client/.gitignore\nnew file mode 100644\nindex 0000000..4d29575\n--- /dev/null\n+++ b/client/.gitignore\n@@ -0,0 +1,23 @@\n+# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.\n+\n+# dependencies\n+/node_modules\n+/.pnp\n+.pnp.js\n+\n+# testing\n+/coverage\n+\n+# production\n+/build\n+\n+# misc\n+.DS_Store\n+.env.local\n+.env.development.local\n+.env.test.local\n+.env.production.local\n+\n+npm-debug.log*\n+yarn-debug.log*\n+yarn-error.log*\ndiff --git a/client/package.json b/client/package.json\nnew file mode 100644\nindex 0000000..29a5674\n--- /dev/null\n+++ b/client/package.json\n@@ -0,0 +1,50 @@\n+{\n+  \"name\": \"whatsapp-clone-client\",\n+  \"version\": \"0.1.0\",\n+  \"private\": true,\n+  \"repository\": {\n+    \"type\": \"git\",\n+    \"url\": \"https://github.com/Urigo/WhatsApp-Clone-Client-React.git\"\n+  },\n+  \"dependencies\": {\n+    \"@material-ui/core\": \"3.9.2\",\n+    \"@material-ui/icons\": \"3.0.2\",\n+    \"apollo-cache-inmemory\": \"1.5.1\",\n+    \"apollo-client\": \"2.5.1\",\n+    \"apollo-link\": \"1.2.11\",\n+    \"apollo-link-http\": \"1.5.14\",\n+    \"graphql-tag\": \"2.10.1\",\n+    \"moment\": \"2.24.0\",\n+    \"react\": \"16.8.4\",\n+    \"react-apollo-hooks\": \"0.4.3\",\n+    \"react-dom\": \"16.8.4\",\n+    \"react-router-dom\": \"5.0.0\",\n+    \"react-router-transition\": \"1.3.0\",\n+    \"react-scripts\": \"2.1.8\",\n+    \"styled-components\": \"4.1.3\",\n+    \"typescript\": \"3.3.3333\"\n+  },\n+  \"scripts\": {\n+    \"start\": \"react-scripts start\",\n+    \"build\": \"react-scripts build\",\n+    \"test\": \"react-scripts test\",\n+    \"eject\": \"react-scripts eject\"\n+  },\n+  \"eslintConfig\": {\n+    \"extends\": \"react-app\"\n+  },\n+  \"browserslist\": [\n+    \">0.2%\",\n+    \"not dead\",\n+    \"not ie <= 11\",\n+    \"not op_mini all\"\n+  ],\n+  \"devDependencies\": {\n+    \"apollo-link-mock\": \"1.0.1\",\n+    \"graphql\": \"14.1.1\",\n+    \"history\": \"4.9.0\",\n+    \"jest-dom\": \"3.1.1\",\n+    \"jest-fetch-mock\": \"2.1.1\",\n+    \"react-testing-library\": \"6.0.0\"\n+  }\n+}\n\\ No newline at end of file\ndiff --git a/client/public/assets/chat-background.jpg b/client/public/assets/chat-background.jpg\nnew file mode 100644\nindex 0000000..12cf45c\nBinary files /dev/null and b/client/public/assets/chat-background.jpg differ\ndiff --git a/client/public/assets/message-mine.png b/client/public/assets/message-mine.png\nnew file mode 100644\nindex 0000000..a5503eb\nBinary files /dev/null and b/client/public/assets/message-mine.png differ\ndiff --git a/client/public/favicon.ico b/client/public/favicon.ico\nnew file mode 100644\nindex 0000000..a11777c\nBinary files /dev/null and b/client/public/favicon.ico differ\ndiff --git a/client/public/index.html b/client/public/index.html\nnew file mode 100644\nindex 0000000..75980d5\n--- /dev/null\n+++ b/client/public/index.html\n@@ -0,0 +1,41 @@\n+<!DOCTYPE html>\n+<html lang=\"en\">\n+  <head>\n+    <meta charset=\"utf-8\" />\n+    <link rel=\"shortcut icon\" href=\"%PUBLIC_URL%/favicon.ico\" />\n+    <meta\n+      name=\"viewport\"\n+      content=\"width=device-width, initial-scale=1, shrink-to-fit=no\"\n+    />\n+    <meta name=\"theme-color\" content=\"#000000\" />\n+    <!--\n+      manifest.json provides metadata used when your web app is installed on a\n+      user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/\n+    -->\n+    <link rel=\"manifest\" href=\"%PUBLIC_URL%/manifest.json\" />\n+    <!--\n+      Notice the use of %PUBLIC_URL% in the tags above.\n+      It will be replaced with the URL of the `public` folder during the build.\n+      Only files inside the `public` folder can be referenced from the HTML.\n+\n+      Unlike \"/favicon.ico\" or \"favicon.ico\", \"%PUBLIC_URL%/favicon.ico\" will\n+      work correctly both with client-side routing and a non-root public URL.\n+      Learn how to configure a non-root public URL by running `npm run build`.\n+    -->\n+    <title>React App</title>\n+  </head>\n+  <body>\n+    <noscript>You need to enable JavaScript to run this app.</noscript>\n+    <div id=\"root\"></div>\n+    <!--\n+      This HTML file is a template.\n+      If you open it directly in the browser, you will see an empty page.\n+\n+      You can add webfonts, meta tags, or analytics to this file.\n+      The build step will place the bundled scripts into the <body> tag.\n+\n+      To begin the development, run `npm start` or `yarn start`.\n+      To create a production bundle, use `npm run build` or `yarn build`.\n+    -->\n+  </body>\n+</html>\ndiff --git a/client/public/manifest.json b/client/public/manifest.json\nnew file mode 100644\nindex 0000000..1f2f141\n--- /dev/null\n+++ b/client/public/manifest.json\n@@ -0,0 +1,15 @@\n+{\n+  \"short_name\": \"React App\",\n+  \"name\": \"Create React App Sample\",\n+  \"icons\": [\n+    {\n+      \"src\": \"favicon.ico\",\n+      \"sizes\": \"64x64 32x32 24x24 16x16\",\n+      \"type\": \"image/x-icon\"\n+    }\n+  ],\n+  \"start_url\": \".\",\n+  \"display\": \"standalone\",\n+  \"theme_color\": \"#000000\",\n+  \"background_color\": \"#ffffff\"\n+}\ndiff --git a/client/src/App.jsx b/client/src/App.jsx\nnew file mode 100644\nindex 0000000..7f6b6a5\n--- /dev/null\n+++ b/client/src/App.jsx\n@@ -0,0 +1,21 @@\n+import * as React from 'react'\n+import { BrowserRouter, Route, Redirect } from 'react-router-dom'\n+import ChatRoomScreen from './components/ChatRoomScreen'\n+import ChatsListScreen from './components/ChatsListScreen'\n+import AnimatedSwitch from './components/AnimatedSwitch'\n+\n+const App = () => (\n+  <BrowserRouter>\n+    <AnimatedSwitch>\n+      <Route exact path=\"/chats\" component={ChatsListScreen} />\n+      <Route exact path=\"/chats/:chatId\" component={ChatRoomScreen} />\n+    </AnimatedSwitch>\n+    <Route exact path=\"/\" render={redirectToChats} />\n+  </BrowserRouter>\n+)\n+\n+const redirectToChats = () => (\n+  <Redirect to=\"/chats\" />\n+)\n+\n+export default App\ndiff --git a/client/src/App.test.js b/client/src/App.test.js\nnew file mode 100644\nindex 0000000..903a2ea\n--- /dev/null\n+++ b/client/src/App.test.js\n@@ -0,0 +1,17 @@\n+import React from 'react';\n+import { ApolloProvider } from 'react-apollo-hooks'\n+import ReactDOM from 'react-dom';\n+import App from './App';\n+import { mockApolloClient } from './test-helpers'\n+\n+it('renders without crashing', () => {\n+  const client = mockApolloClient()\n+  const div = document.createElement('div');\n+\n+  ReactDOM.render(\n+    <ApolloProvider client={client}>\n+      <App />\n+    </ApolloProvider>\n+  , div);\n+  ReactDOM.unmountComponentAtNode(div);\n+});\ndiff --git a/client/src/client.ts b/client/src/client.ts\nnew file mode 100644\nindex 0000000..2e1ac5b\n--- /dev/null\n+++ b/client/src/client.ts\n@@ -0,0 +1,16 @@\n+import { InMemoryCache } from 'apollo-cache-inmemory'\n+import { ApolloClient } from 'apollo-client'\n+import { HttpLink } from 'apollo-link-http'\n+\n+const httpUri = process.env.REACT_APP_SERVER_URL + '/graphql'\n+\n+const httpLink = new HttpLink({\n+  uri: httpUri,\n+})\n+\n+const inMemoryCache = new InMemoryCache()\n+\n+export default new ApolloClient({\n+  link: httpLink,\n+  cache: inMemoryCache,\n+})\ndiff --git a/client/src/components/AnimatedSwitch.tsx b/client/src/components/AnimatedSwitch.tsx\nnew file mode 100644\nindex 0000000..81f4d01\n--- /dev/null\n+++ b/client/src/components/AnimatedSwitch.tsx\n@@ -0,0 +1,37 @@\n+import { Switch } from 'react-router-dom'\n+import { AnimatedSwitch, spring } from 'react-router-transition'\n+import styled from 'styled-components'\n+\n+// A workaround to make test pass\n+const SwitchComponent = process.env.NODE_ENV === 'test' ? Switch : AnimatedSwitch\n+\n+const glide = val =>\n+  spring(val, {\n+    stiffness: 174,\n+    damping: 24,\n+  })\n+\n+const mapStyles = styles => ({\n+  transform: `translateX(${styles.offset}%)`,\n+})\n+\n+const MyAnimatedSwitch =  styled(SwitchComponent).attrs(() => ({\n+  atEnter: { offset: 100 },\n+  atLeave: { offset: glide(-100) },\n+  atActive: { offset: glide(0) },\n+  mapStyles,\n+}))`\n+  position: relative;\n+  overflow: hidden;\n+  height: 100vh;\n+  width: 100vw;\n+\n+  > div {\n+    position: absolute;\n+    overflow: hidden;\n+    height: 100vh;\n+    width: 100vw;\n+  }\n+`\n+\n+export default MyAnimatedSwitch\ndiff --git a/client/src/components/ChatRoomScreen/ChatNavbar.test.tsx b/client/src/components/ChatRoomScreen/ChatNavbar.test.tsx\nnew file mode 100644\nindex 0000000..a404912\n--- /dev/null\n+++ b/client/src/components/ChatRoomScreen/ChatNavbar.test.tsx\n@@ -0,0 +1,49 @@\n+import { createMemoryHistory } from 'history'\n+import React from 'react'\n+import { cleanup, render, fireEvent, wait } from 'react-testing-library'\n+import ChatNavbar from './ChatNavbar'\n+\n+describe('ChatNavbar', () => {\n+  afterEach(cleanup)\n+\n+  it('renders chat data', () => {\n+    const chat = {\n+      id: '1',\n+      name: 'Foo Bar',\n+      picture: 'https://localhost:4000/picture.jpg',\n+    }\n+\n+    {\n+      const { container, getByTestId } = render(<ChatNavbar chat={chat} />)\n+\n+      expect(getByTestId('chat-name')).toHaveTextContent('Foo Bar')\n+      expect(getByTestId('chat-picture')).toHaveAttribute('src', 'https://localhost:4000/picture.jpg')\n+    }\n+  })\n+\n+  it('goes back on arrow click', async () => {\n+    const chat = {\n+      id: '1',\n+      name: 'Foo Bar',\n+      picture: 'https://localhost:4000/picture.jpg',\n+    }\n+\n+    const history = createMemoryHistory()\n+\n+    history.push('/chats/1')\n+\n+    await wait(() =>\n+      expect(history.location.pathname).toEqual('/chats/1')\n+    )\n+\n+    {\n+      const { container, getByTestId } = render(<ChatNavbar chat={chat} history={history} />)\n+\n+      fireEvent.click(getByTestId('back-button'))\n+\n+      await wait(() =>\n+        expect(history.location.pathname).toEqual('/')\n+      )\n+    }\n+  })\n+})\ndiff --git a/client/src/components/ChatRoomScreen/ChatNavbar.tsx b/client/src/components/ChatRoomScreen/ChatNavbar.tsx\nnew file mode 100644\nindex 0000000..87b146d\n--- /dev/null\n+++ b/client/src/components/ChatRoomScreen/ChatNavbar.tsx\n@@ -0,0 +1,51 @@\n+import Button from '@material-ui/core/Button'\n+import ArrowBackIcon from '@material-ui/icons/ArrowBack'\n+import * as React from 'react'\n+import { useCallback, useState } from 'react'\n+import styled from 'styled-components'\n+\n+const Style = styled.div`\n+  padding: 0;\n+  display: flex;\n+  flex-direction: row;\n+  background-color: var(--primary-bg);\n+  color: var(--primary-text);\n+`\n+\n+const BackButton = styled(Button) `\n+  svg {\n+    color: var(--primary-text);\n+  }\n+`\n+\n+const Picture = styled.img `\n+  height: 40px;\n+  width: 40px;\n+  margin-top: 3px;\n+  margin-left: -22px;\n+  object-fit: cover;\n+  padding: 5px;\n+  border-radius: 50%;\n+`\n+\n+const Name = styled.div `\n+  line-height: 56px;\n+`\n+\n+const ChatNavbar = ({ chat, history }) => {\n+  const navBack = useCallback(() => {\n+    history.goBack()\n+  }, [true])\n+\n+  return (\n+    <Style className={name}>\n+      <BackButton data-testid=\"back-button\" onClick={navBack}>\n+        <ArrowBackIcon />\n+      </BackButton>\n+      <Picture data-testid=\"chat-picture\" src={chat.picture} />\n+      <Name data-testid=\"chat-name\">{chat.name}</Name>\n+    </Style>\n+  )\n+}\n+\n+export default ChatNavbar\ndiff --git a/client/src/components/ChatRoomScreen/MessageInput.test.tsx b/client/src/components/ChatRoomScreen/MessageInput.test.tsx\nnew file mode 100644\nindex 0000000..ce5fc86\n--- /dev/null\n+++ b/client/src/components/ChatRoomScreen/MessageInput.test.tsx\n@@ -0,0 +1,47 @@\n+import { createMemoryHistory } from 'history'\n+import React from 'react'\n+import { cleanup, render, fireEvent, wait, waitForElement } from 'react-testing-library'\n+import MessageInput from './MessageInput'\n+\n+describe('MessageInput', () => {\n+  afterEach(cleanup)\n+\n+  it('triggers callback on send button click', async () => {\n+    const onSendMessage = jest.fn(() => {})\n+\n+    {\n+      const { container, getByTestId } = render(<MessageInput onSendMessage={onSendMessage} />)\n+      const messageInput = getByTestId('message-input')\n+      const sendButton = getByTestId('send-button')\n+\n+      fireEvent.change(messageInput, { target: { value: 'foo' } })\n+\n+      await waitForElement(() => messageInput)\n+\n+      fireEvent.click(sendButton)\n+\n+      await wait(() =>\n+        expect(onSendMessage.mock.calls.length).toBe(1)\n+      )\n+    }\n+  })\n+\n+  it('triggers callback on Enter press', async () => {\n+    const onSendMessage = jest.fn(() => {})\n+\n+    {\n+      const { container, getByTestId } = render(<MessageInput onSendMessage={onSendMessage} />)\n+      const messageInput = getByTestId('message-input')\n+\n+      fireEvent.change(messageInput, { target: { value: 'foo' } })\n+\n+      await waitForElement(() => messageInput)\n+\n+      fireEvent.keyPress(messageInput, { key: 'Enter', code: 13, charCode: 13 })\n+\n+      await wait(() =>\n+        expect(onSendMessage.mock.calls.length).toBe(1)\n+      )\n+    }\n+  })\n+})\ndiff --git a/client/src/components/ChatRoomScreen/MessageInput.tsx b/client/src/components/ChatRoomScreen/MessageInput.tsx\nnew file mode 100644\nindex 0000000..c0ebf27\n--- /dev/null\n+++ b/client/src/components/ChatRoomScreen/MessageInput.tsx\n@@ -0,0 +1,88 @@\n+import Button from '@material-ui/core/Button'\n+import SendIcon from '@material-ui/icons/Send'\n+import * as React from 'react'\n+import { useState } from 'react'\n+import styled from 'styled-components'\n+\n+const Container = styled.div`\n+  display: flex;\n+  height: 50px;\n+  padding: 5px;\n+  width: calc(100% - 10px);\n+`\n+\n+const ActualInput = styled.input `\n+  width: calc(100% - 50px);\n+  border: none;\n+  border-radius: 999px;\n+  padding: 10px;\n+  padding-left: 20px;\n+  padding-right: 20px;\n+  font-size: 15px;\n+  outline: none;\n+  box-shadow: 0 1px silver;\n+  font-size: 18px;\n+  line-height: 45px;\n+`\n+\n+const SendButton = styled(Button) `\n+  min-width: 50px !important;\n+  width: 50px !important;\n+  border-radius: 999px !important;\n+  background-color: var(--primary-bg) !important;\n+  margin: 0 5px !important;\n+  margin-right: 0 !important;\n+  color: white !important;\n+  padding-left: 20px !important;\n+\n+  svg {\n+    margin-left: -3px;\n+  }\n+`\n+\n+const MessageInput = ({ onSendMessage }) => {\n+  const [message, setMessage] = useState('')\n+\n+  const onKeyPress = e => {\n+    if (e.charCode === 13) {\n+      submitMessage()\n+    }\n+  }\n+\n+  const onChange = ({ target }) => {\n+    setMessage(target.value)\n+  }\n+\n+  const submitMessage = () => {\n+    if (!message) return\n+\n+    setMessage('')\n+\n+    if (typeof onSendMessage === 'function') {\n+      onSendMessage(message)\n+    }\n+  }\n+\n+  return (\n+    <Container>\n+      <ActualInput\n+        data-testid=\"message-input\"\n+        type=\"text\"\n+        placeholder=\"Type a message\"\n+        value={message}\n+        onKeyPress={onKeyPress}\n+        onChange={onChange}\n+      />\n+      <SendButton\n+        data-testid=\"send-button\"\n+        variant=\"contained\"\n+        color=\"primary\"\n+        onClick={submitMessage}\n+      >\n+        <SendIcon />\n+      </SendButton>\n+    </Container>\n+  )\n+}\n+\n+export default MessageInput\ndiff --git a/client/src/components/ChatRoomScreen/MessagesList.test.tsx b/client/src/components/ChatRoomScreen/MessagesList.test.tsx\nnew file mode 100644\nindex 0000000..26534f6\n--- /dev/null\n+++ b/client/src/components/ChatRoomScreen/MessagesList.test.tsx\n@@ -0,0 +1,37 @@\n+import { createMemoryHistory } from 'history'\n+import React from 'react'\n+import { cleanup, render, fireEvent, wait, getByTestId } from 'react-testing-library'\n+import MessagesList from './MessagesList'\n+\n+describe('MessagesList', () => {\n+  afterEach(cleanup)\n+\n+  it('renders messages data', () => {\n+    const messages = [\n+      {\n+        id: '1',\n+        content: 'foo',\n+        createdAt: new Date(0),\n+      },\n+      {\n+        id: '2',\n+        content: 'bar',\n+        createdAt: new Date(1000 * 60 * 60),\n+      },\n+    ]\n+\n+    let message1, message2\n+    {\n+      const { container, getAllByTestId, getByTestId } = render(<MessagesList messages={messages} />)\n+      const match = getAllByTestId('message-item')\n+      message1 = match[0]\n+      message2 = match[1]\n+    }\n+\n+    expect(getByTestId(message1, 'message-content')).toHaveTextContent('foo')\n+    expect(getByTestId(message1, 'message-date')).toHaveTextContent('08:00')\n+\n+    expect(getByTestId(message2, 'message-content')).toHaveTextContent('bar')\n+    expect(getByTestId(message2, 'message-date')).toHaveTextContent('09:00')\n+  })\n+})\ndiff --git a/client/src/components/ChatRoomScreen/MessagesList.tsx b/client/src/components/ChatRoomScreen/MessagesList.tsx\nnew file mode 100644\nindex 0000000..10cc74f\n--- /dev/null\n+++ b/client/src/components/ChatRoomScreen/MessagesList.tsx\n@@ -0,0 +1,75 @@\n+import moment from 'moment'\n+import * as React from 'react'\n+import styled from 'styled-components'\n+\n+const Container = styled.div`\n+  display: block;\n+  flex: 2;\n+  overflow-y: overlay;\n+  padding: 0 15px;\n+`\n+\n+const MessageItem = styled.div `\n+  float: right;\n+  background-color: #dcf8c6;\n+  display: inline-block;\n+  position: relative;\n+  max-width: 100%;\n+  border-radius: 7px;\n+  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.15);\n+  margin-top: 10px;\n+  margin-bottom: 10px;\n+  clear: both;\n+\n+  &::after {\n+    content: '';\n+    display: table;\n+    clear: both;\n+  }\n+\n+  &::before {\n+    background-image: url(/assets/message-mine.png);\n+    content: '';\n+    position: absolute;\n+    bottom: 3px;\n+    width: 12px;\n+    height: 19px;\n+    right: -11px;\n+    background-position: 50% 50%;\n+    background-repeat: no-repeat;\n+    background-size: contain;\n+  }\n+`\n+\n+const Contents = styled.div `\n+  padding: 5px 7px;\n+  word-wrap: break-word;\n+\n+  &::after {\n+    content: ' \\00a0\\00a0\\00a0\\00a0\\00a0\\00a0\\00a0\\00a0\\00a0\\00a0\\00a0\\00a0\\00a0\\00a0\\00a0\\00a0\\00a0\\00a0\\00a0';\n+    display: inline;\n+  }\n+`\n+\n+const Timestamp = styled.div `\n+  position: absolute;\n+  bottom: 2px;\n+  right: 7px;\n+  color: gray;\n+  font-size: 12px;\n+`\n+\n+const MessagesList = ({ messages }) => {\n+  return (\n+    <Container>\n+      {messages.map((message) => (\n+        <MessageItem data-testid=\"message-item\" key={message.id}>\n+          <Contents data-testid=\"message-content\">{message.content}</Contents>\n+          <Timestamp data-testid=\"message-date\">{moment(message.createdAt).format('HH:mm')}</Timestamp>\n+        </MessageItem>\n+      ))}\n+    </Container>\n+  )\n+}\n+\n+export default MessagesList\ndiff --git a/client/src/components/ChatRoomScreen/index.tsx b/client/src/components/ChatRoomScreen/index.tsx\nnew file mode 100644\nindex 0000000..1f077b0\n--- /dev/null\n+++ b/client/src/components/ChatRoomScreen/index.tsx\n@@ -0,0 +1,67 @@\n+import gql from 'graphql-tag'\n+import * as React from 'react'\n+import { useCallback } from 'react'\n+import { useApolloClient, useQuery } from 'react-apollo-hooks'\n+import styled from 'styled-components'\n+import ChatNavbar from './ChatNavbar'\n+import MessageInput from './MessageInput'\n+import MessagesList from './MessagesList'\n+\n+const Container = styled.div `\n+  background: url(/assets/chat-background.jpg);\n+  display: flex;\n+  flex-flow: column;\n+  height: 100vh;\n+`\n+\n+const getChatQuery = gql `\n+  query GetChat($chatId: ID!) {\n+    chat(chatId: $chatId) {\n+      id\n+      name\n+      picture\n+      messages {\n+        id\n+        content\n+        createdAt\n+      }\n+    }\n+  }\n+`\n+\n+const ChatRoomScreen = ({ history, match }) => {\n+  const { params: { chatId } } = match\n+  const client = useApolloClient()\n+  const { data: { chat } } = useQuery(getChatQuery, {\n+    variables: { chatId }\n+  })\n+\n+  const onSendMessage = useCallback((content) => {\n+    const message = {\n+      id: chat.messages.length + 1,\n+      createdAt: Date.now(),\n+      content,\n+    }\n+\n+    client.writeQuery({\n+      query: getChatQuery,\n+      variables: { chatId },\n+      data: {\n+        ...chat,\n+        messages: chat.messages.concat(message),\n+      },\n+    })\n+  }, [chat])\n+\n+  if (!chat) return null\n+\n+  return (\n+    <Container>\n+      <ChatNavbar chat={chat} history={history} />\n+      <MessagesList messages={chat.messages} />\n+      <MessageInput onSendMessage={onSendMessage} />\n+    </Container>\n+  )\n+}\n+\n+export default ChatRoomScreen\ndiff --git a/client/src/components/ChatsListScreen/ChatsList.test.tsx b/client/src/components/ChatsListScreen/ChatsList.test.tsx\nnew file mode 100644\nindex 0000000..c1b5d11\n--- /dev/null\n+++ b/client/src/components/ChatsListScreen/ChatsList.test.tsx\n@@ -0,0 +1,99 @@\n+import { createBrowserHistory } from 'history'\n+import React from 'react'\n+import { ApolloProvider } from 'react-apollo-hooks'\n+import ReactDOM from 'react-dom'\n+import { cleanup, render, fireEvent, wait, waitForDomChange } from 'react-testing-library'\n+import { mockApolloClient } from '../../test-helpers'\n+import ChatsList, { getChatsQuery } from './ChatsList'\n+\n+describe('ChatsList', () => {\n+  afterEach(() => {\n+    cleanup()\n+    window.location.pathname = '/'\n+  })\n+\n+  it('renders fetched chats data', async () => {\n+    const client = mockApolloClient([\n+      {\n+        request: { query: getChatsQuery },\n+        result: {\n+          data: {\n+            chats: [\n+              {\n+                __typename: 'Chat',\n+                id: 1,\n+                name: 'Foo Bar',\n+                picture: 'https://localhost:4000/picture.jpg',\n+                lastMessage: {\n+                  __typename: 'Message',\n+                  id: 1,\n+                  content: 'Hello',\n+                  createdAt: new Date(0),\n+                },\n+              },\n+            ],\n+          },\n+        },\n+      },\n+    ])\n+\n+    {\n+      const { container, getByTestId } = render(\n+        <ApolloProvider client={client}>\n+          <ChatsList />\n+        </ApolloProvider>\n+      )\n+\n+      await waitForDomChange({ container })\n+\n+      expect(getByTestId('name')).toHaveTextContent('Foo Bar')\n+      expect(getByTestId('picture')).toHaveAttribute('src', 'https://localhost:4000/picture.jpg')\n+      expect(getByTestId('content')).toHaveTextContent('Hello')\n+      expect(getByTestId('date')).toHaveTextContent('08:00')\n+    }\n+  })\n+\n+  it('should navigate to the target chat room on chat item click', async () => {\n+    const client = mockApolloClient([\n+      {\n+        request: { query: getChatsQuery },\n+        result: {\n+          data: {\n+            chats: [\n+              {\n+                __typename: 'Chat',\n+                id: 1,\n+                name: 'Foo Bar',\n+                picture: 'https://localhost:4000/picture.jpg',\n+                lastMessage: {\n+                  __typename: 'Message',\n+                  id: 1,\n+                  content: 'Hello',\n+                  createdAt: new Date(0),\n+                },\n+              },\n+            ],\n+          },\n+        },\n+      },\n+    ])\n+\n+    const history = createBrowserHistory()\n+\n+    {\n+      const { container, getByTestId } = render(\n+        <ApolloProvider client={client}>\n+          <ChatsList history={history} />\n+        </ApolloProvider>\n+      )\n+\n+      await waitForDomChange({ container })\n+\n+      fireEvent.click(getByTestId('chat'))\n+\n+      await wait(() =>\n+        expect(history.location.pathname).toEqual('/chats/1')\n+      )\n+    }\n+  })\n+})\ndiff --git a/client/src/components/ChatsListScreen/ChatsList.tsx b/client/src/components/ChatsListScreen/ChatsList.tsx\nnew file mode 100644\nindex 0000000..fd49ae5\n--- /dev/null\n+++ b/client/src/components/ChatsListScreen/ChatsList.tsx\n@@ -0,0 +1,104 @@\n+import { List, ListItem } from '@material-ui/core'\n+import gql from 'graphql-tag'\n+import moment from 'moment'\n+import * as React from 'react'\n+import { useCallback } from 'react'\n+import { useQuery } from 'react-apollo-hooks'\n+import styled from 'styled-components'\n+\n+const Container = styled.div `\n+  height: calc(100% - 56px);\n+  overflow-y: overlay;\n+`\n+\n+const StyledList = styled(List) `\n+  padding: 0 !important;\n+`\n+\n+const StyledListItem = styled(ListItem) `\n+  height: 76px;\n+  padding: 0 15px;\n+  display: flex;\n+`\n+\n+const ChatPicture = styled.img `\n+  height: 50px;\n+  width: 50px;\n+  object-fit: cover;\n+  border-radius: 50%;\n+`\n+\n+const ChatInfo = styled.div `\n+  width: calc(100% - 60px);\n+  padding: 15px 0;\n+  margin-left: 10px;\n+  border-bottom: 0.5px solid silver;\n+  position: relative;\n+`\n+\n+const ChatName = styled.div `\n+  margin-top: 5px;\n+`\n+\n+const MessageContent = styled.div `\n+  color: gray;\n+  font-size: 15px;\n+  margin-top: 5px;\n+  text-overflow: ellipsis;\n+  overflow: hidden;\n+  white-space: nowrap;\n+`\n+\n+const MessageDate = styled.div `\n+  position: absolute;\n+  color: gray;\n+  top: 20px;\n+  right: 0;\n+  font-size: 13px;\n+`\n+\n+export const getChatsQuery = gql `\n+  query GetChats {\n+    chats {\n+      id\n+      name\n+      picture\n+      lastMessage {\n+        id\n+        content\n+        createdAt\n+      }\n+    }\n+  }\n+`\n+\n+const ChatsList = ({ history }) => {\n+  const { data: { chats = [] } } = useQuery(getChatsQuery)\n+\n+  const navToChat = useCallback((chat) => {\n+    history.push(`chats/${chat.id}`)\n+  }, [true])\n+\n+  return (\n+    <Container>\n+      <StyledList>\n+        {chats.map((chat) => (\n+          <StyledListItem key={chat.id} data-testid=\"chat\" button onClick={navToChat.bind(null, chat)}>\n+            <ChatPicture data-testid=\"picture\" src={chat.picture} />\n+            <ChatInfo>\n+              <ChatName data-testid=\"name\">{chat.name}</ChatName>\n+              {chat.lastMessage && (\n+                <React.Fragment>\n+                  <MessageContent data-testid=\"content\">{chat.lastMessage.content}</MessageContent>\n+                  <MessageDate data-testid=\"date\">{moment(chat.lastMessage.createdAt).format('HH:mm')}</MessageDate>\n+                </React.Fragment>\n+              )}\n+            </ChatInfo>\n+          </StyledListItem>\n+        ))}\n+      </StyledList>\n+    </Container>\n+  )\n+}\n+\n+export default ChatsList\ndiff --git a/client/src/components/ChatsListScreen/ChatsNavbar.tsx b/client/src/components/ChatsListScreen/ChatsNavbar.tsx\nnew file mode 100644\nindex 0000000..68628c3\n--- /dev/null\n+++ b/client/src/components/ChatsListScreen/ChatsNavbar.tsx\n@@ -0,0 +1,18 @@\n+import { Toolbar } from '@material-ui/core'\n+import * as React from 'react'\n+import styled from 'styled-components'\n+\n+const Container = styled(Toolbar) `\n+  background-color: var(--primary-bg);\n+  color: var(--primary-text);\n+  font-size: 20px;\n+  line-height: 40px;\n+`\n+\n+const ChatsNavbar = () => (\n+  <Container>\n+    Whatsapp Clone\n+  </Container>\n+)\n+\n+export default ChatsNavbar\ndiff --git a/client/src/components/ChatsListScreen/index.tsx b/client/src/components/ChatsListScreen/index.tsx\nnew file mode 100644\nindex 0000000..572a5bb\n--- /dev/null\n+++ b/client/src/components/ChatsListScreen/index.tsx\n@@ -0,0 +1,17 @@\n+import * as React from 'react'\n+import styled from 'styled-components'\n+import ChatsNavbar from './ChatsNavbar'\n+import ChatsList from './ChatsList'\n+\n+const Container = styled.div `\n+  height: 100vh;\n+`\n+\n+const ChatsListScreen = ({ history }) => (\n+  <Container>\n+    <ChatsNavbar />\n+    <ChatsList history={history} />\n+  </Container>\n+)\n+\n+export default ChatsListScreen\ndiff --git a/client/src/index.css b/client/src/index.css\nnew file mode 100644\nindex 0000000..ea591eb\n--- /dev/null\n+++ b/client/src/index.css\n@@ -0,0 +1,21 @@\n+:root {\n+  --primary-bg: #2c6157;\n+  --secondary-bg: #6fd056;\n+  --primary-text: white;\n+  --secondary-text: white;\n+}\n+\n+body {\n+  margin: 0;\n+  padding: 0;\n+  font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", \"Roboto\", \"Oxygen\",\n+    \"Ubuntu\", \"Cantarell\", \"Fira Sans\", \"Droid Sans\", \"Helvetica Neue\",\n+    sans-serif;\n+  -webkit-font-smoothing: antialiased;\n+  -moz-osx-font-smoothing: grayscale;\n+}\n+\n+code {\n+  font-family: source-code-pro, Menlo, Monaco, Consolas, \"Courier New\",\n+    monospace;\n+}\ndiff --git a/client/src/index.jsx b/client/src/index.jsx\nnew file mode 100644\nindex 0000000..311a72a\n--- /dev/null\n+++ b/client/src/index.jsx\n@@ -0,0 +1,31 @@\n+import { MuiThemeProvider, createMuiTheme } from '@material-ui/core/styles'\n+import React from 'react';\n+import ReactDOM from 'react-dom';\n+import { ApolloProvider } from 'react-apollo-hooks'\n+import './index.css';\n+import App from './App';\n+import client from './client'\n+import * as serviceWorker from './serviceWorker';\n+\n+const theme = createMuiTheme({\n+  palette: {\n+    primary: { main: '#2c6157' },\n+    secondary: { main: '#6fd056' },\n+  },\n+  typography: {\n+    useNextVariants: true,\n+  },\n+})\n+\n+ReactDOM.render(\n+  <MuiThemeProvider theme={theme}>\n+    <ApolloProvider client={client}>\n+      <App />\n+    </ApolloProvider>\n+  </MuiThemeProvider>\n+, document.getElementById('root'));\n+\n+// If you want your app to work offline and load faster, you can change\n+// unregister() to register() below. Note this comes with some pitfalls.\n+// Learn more about service workers: https://bit.ly/CRA-PWA\n+serviceWorker.unregister();\ndiff --git a/client/src/react-app-env.d.ts b/client/src/react-app-env.d.ts\nnew file mode 100644\nindex 0000000..6431bc5\n--- /dev/null\n+++ b/client/src/react-app-env.d.ts\n@@ -0,0 +1 @@\n+/// <reference types=\"react-scripts\" />\ndiff --git a/client/src/serviceWorker.js b/client/src/serviceWorker.js\nnew file mode 100644\nindex 0000000..f8c7e50\n--- /dev/null\n+++ b/client/src/serviceWorker.js\n@@ -0,0 +1,135 @@\n+// This optional code is used to register a service worker.\n+// register() is not called by default.\n+\n+// This lets the app load faster on subsequent visits in production, and gives\n+// it offline capabilities. However, it also means that developers (and users)\n+// will only see deployed updates on subsequent visits to a page, after all the\n+// existing tabs open on the page have been closed, since previously cached\n+// resources are updated in the background.\n+\n+// To learn more about the benefits of this model and instructions on how to\n+// opt-in, read https://bit.ly/CRA-PWA\n+\n+const isLocalhost = Boolean(\n+  window.location.hostname === 'localhost' ||\n+    // [::1] is the IPv6 localhost address.\n+    window.location.hostname === '[::1]' ||\n+    // 127.0.0.1/8 is considered localhost for IPv4.\n+    window.location.hostname.match(\n+      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n+    )\n+);\n+\n+export function register(config) {\n+  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n+    // The URL constructor is available in all browsers that support SW.\n+    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n+    if (publicUrl.origin !== window.location.origin) {\n+      // Our service worker won't work if PUBLIC_URL is on a different origin\n+      // from what our page is served on. This might happen if a CDN is used to\n+      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n+      return;\n+    }\n+\n+    window.addEventListener('load', () => {\n+      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n+\n+      if (isLocalhost) {\n+        // This is running on localhost. Let's check if a service worker still exists or not.\n+        checkValidServiceWorker(swUrl, config);\n+\n+        // Add some additional logging to localhost, pointing developers to the\n+        // service worker/PWA documentation.\n+        navigator.serviceWorker.ready.then(() => {\n+          console.log(\n+            'This web app is being served cache-first by a service ' +\n+              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n+          );\n+        });\n+      } else {\n+        // Is not localhost. Just register service worker\n+        registerValidSW(swUrl, config);\n+      }\n+    });\n+  }\n+}\n+\n+function registerValidSW(swUrl, config) {\n+  navigator.serviceWorker\n+    .register(swUrl)\n+    .then(registration => {\n+      registration.onupdatefound = () => {\n+        const installingWorker = registration.installing;\n+        if (installingWorker == null) {\n+          return;\n+        }\n+        installingWorker.onstatechange = () => {\n+          if (installingWorker.state === 'installed') {\n+            if (navigator.serviceWorker.controller) {\n+              // At this point, the updated precached content has been fetched,\n+              // but the previous service worker will still serve the older\n+              // content until all client tabs are closed.\n+              console.log(\n+                'New content is available and will be used when all ' +\n+                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n+              );\n+\n+              // Execute callback\n+              if (config && config.onUpdate) {\n+                config.onUpdate(registration);\n+              }\n+            } else {\n+              // At this point, everything has been precached.\n+              // It's the perfect time to display a\n+              // \"Content is cached for offline use.\" message.\n+              console.log('Content is cached for offline use.');\n+\n+              // Execute callback\n+              if (config && config.onSuccess) {\n+                config.onSuccess(registration);\n+              }\n+            }\n+          }\n+        };\n+      };\n+    })\n+    .catch(error => {\n+      console.error('Error during service worker registration:', error);\n+    });\n+}\n+\n+function checkValidServiceWorker(swUrl, config) {\n+  // Check if the service worker can be found. If it can't reload the page.\n+  fetch(swUrl)\n+    .then(response => {\n+      // Ensure service worker exists, and that we really are getting a JS file.\n+      const contentType = response.headers.get('content-type');\n+      if (\n+        response.status === 404 ||\n+        (contentType != null && contentType.indexOf('javascript') === -1)\n+      ) {\n+        // No service worker found. Probably a different app. Reload the page.\n+        navigator.serviceWorker.ready.then(registration => {\n+          registration.unregister().then(() => {\n+            window.location.reload();\n+          });\n+        });\n+      } else {\n+        // Service worker found. Proceed as normal.\n+        registerValidSW(swUrl, config);\n+      }\n+    })\n+    .catch(() => {\n+      console.log(\n+        'No internet connection found. App is running in offline mode.'\n+      );\n+    });\n+}\n+\n+export function unregister() {\n+  if ('serviceWorker' in navigator) {\n+    navigator.serviceWorker.ready.then(registration => {\n+      registration.unregister();\n+    });\n+  }\n+}\ndiff --git a/client/src/setupTests.ts b/client/src/setupTests.ts\nnew file mode 100644\nindex 0000000..c42be90\n--- /dev/null\n+++ b/client/src/setupTests.ts\n@@ -0,0 +1,7 @@\n+import 'jest-dom/extend-expect'\n+import { GlobalWithFetchMock } from 'jest-fetch-mock'\n+import { act } from 'react-testing-library'\n+\n+const customGlobal: GlobalWithFetchMock = global as GlobalWithFetchMock\n+customGlobal.fetch = require('jest-fetch-mock')\n+customGlobal.fetchMock = customGlobal.fetch\ndiff --git a/client/src/test-helpers.ts b/client/src/test-helpers.ts\nnew file mode 100644\nindex 0000000..55c02bb\n--- /dev/null\n+++ b/client/src/test-helpers.ts\n@@ -0,0 +1,10 @@\n+import { InMemoryCache } from 'apollo-cache-inmemory'\n+import { ApolloClient } from 'apollo-client'\n+import { MockLink } from 'apollo-link-mock'\n+\n+export const mockApolloClient = (mocks) => {\n+  return new ApolloClient({\n+    cache: new InMemoryCache(),\n+    link: new MockLink(mocks),\n+  })\n+}\ndiff --git a/client/tsconfig.json b/client/tsconfig.json\nnew file mode 100644\nindex 0000000..ad80f6a\n--- /dev/null\n+++ b/client/tsconfig.json\n@@ -0,0 +1,35 @@\n+{\n+  \"compilerOptions\": {\n+    \"outDir\": \"build/dist\",\n+    \"sourceMap\": true,\n+    \"declaration\": false,\n+    \"moduleResolution\": \"node\",\n+    \"emitDecoratorMetadata\": true,\n+    \"experimentalDecorators\": true,\n+    \"downlevelIteration\": true,\n+    \"resolveJsonModule\": true,\n+    \"target\": \"es5\",\n+    \"jsx\": \"preserve\",\n+    \"typeRoots\": [\n+      \"node_modules/@types\"\n+    ],\n+    \"lib\": [\n+      \"es2017\",\n+      \"dom\",\n+      \"esnext.asynciterable\"\n+    ],\n+    \"allowJs\": true,\n+    \"skipLibCheck\": true,\n+    \"esModuleInterop\": false,\n+    \"allowSyntheticDefaultImports\": true,\n+    \"forceConsistentCasingInFileNames\": true,\n+    \"isolatedModules\": true,\n+    \"noEmit\": true,\n+    \"noImplicitAny\": false,\n+    \"strict\": false,\n+    \"module\": \"esnext\"\n+  },\n+  \"include\": [\n+    \"src\"\n+  ]\n+}\ndiff --git a/client/tslint.json b/client/tslint.json\nnew file mode 100644\nindex 0000000..446ec3d\n--- /dev/null\n+++ b/client/tslint.json\n@@ -0,0 +1,29 @@\n+{\n+  \"extends\": [\"tslint:recommended\", \"tslint-react\", \"tslint-config-prettier\"],\n+  \"rules\": {\n+    \"ordered-imports\": false,\n+    \"object-literal-sort-keys\": false,\n+    \"jsx-boolean-value\": false,\n+    \"interface-name\" : false,\n+    \"variable-name\": false,\n+    \"no-string-literal\": false,\n+    \"no-namespace\": false,\n+    \"interface-over-type-literal\": false,\n+    \"no-shadowed-variable\": false,\n+    \"curly\": false,\n+    \"no-label\": false,\n+    \"no-empty\": false,\n+    \"no-debugger\": false,\n+    \"no-console\": false,\n+    \"array-type\": false\n+  },\n+  \"linterOptions\": {\n+    \"exclude\": [\n+      \"config/**/*.js\",\n+      \"node_modules/**/*.ts\",\n+      \"coverage/lcov-report/*.js\",\n+      \"*.json\",\n+      \"**/*.json\"\n+    ]\n+  }\n+}\ndiff --git a/package.json b/package.json\nnew file mode 100644\nindex 0000000..008b058\n--- /dev/null\n+++ b/package.json\n@@ -0,0 +1,9 @@\n+{\n+  \"name\": \"whatsapp-clone-tutorial\",\n+  \"description\": \"A newly created Tortilla project\",\n+  \"private\": true,\n+  \"repository\": {\n+    \"type\": \"git\",\n+    \"url\": \"https://github.com/Urigo/WhatsApp-Clone-Tutorial.git\"\n+  }\n+}\ndiff --git a/server/.gitignore b/server/.gitignore\nnew file mode 100644\nindex 0000000..5171c54\n--- /dev/null\n+++ b/server/.gitignore\n@@ -0,0 +1,2 @@\n+node_modules\n+npm-debug.log\n\\ No newline at end of file\ndiff --git a/server/db.ts b/server/db.ts\nnew file mode 100644\nindex 0000000..ac0a101\n--- /dev/null\n+++ b/server/db.ts\n@@ -0,0 +1,49 @@\n+export const messages = [\n+  {\n+    id: '1',\n+    content: \"You on your way?\",\n+    createdAt: new Date(new Date('1-1-2019').getTime() - 60 * 1000 * 1000),\n+  },\n+  {\n+    id: '2',\n+    content: \"Hey, it's me\",\n+    createdAt: new Date(new Date('1-1-2019').getTime() - 2 * 60 * 1000 * 1000),\n+  },\n+  {\n+    id: '3',\n+    content: \"I should buy a boat\",\n+    createdAt: new Date(new Date('1-1-2019').getTime() - 24 * 60 * 1000 * 1000),\n+  },\n+  {\n+    id: '4',\n+    content: \"This is wicked good ice cream.\",\n+    createdAt: new Date(new Date('1-1-2019').getTime() - 14 * 24 * 60 * 1000 * 1000),\n+  },\n+]\n+\n+export const chats = [\n+  {\n+    id: '1',\n+    name: 'Ethan Gonzalez',\n+    picture: 'https://randomuser.me/api/portraits/thumb/men/1.jpg',\n+    messages: ['1'],\n+  },\n+  {\n+    id: '2',\n+    name: 'Bryan Wallace',\n+    picture: 'https://randomuser.me/api/portraits/thumb/men/2.jpg',\n+    messages: ['2'],\n+  },\n+  {\n+    id: '3',\n+    name: 'Avery Stewart',\n+    picture: 'https://randomuser.me/api/portraits/thumb/women/1.jpg',\n+    messages: ['3'],\n+  },\n+  {\n+    id: '4',\n+    name: 'Katie Peterson',\n+    picture: 'https://randomuser.me/api/portraits/thumb/women/2.jpg',\n+    messages: ['4'],\n+  },\n+]\ndiff --git a/server/index.ts b/server/index.ts\nnew file mode 100644\nindex 0000000..b9b7f0e\n--- /dev/null\n+++ b/server/index.ts\n@@ -0,0 +1,27 @@\n+import { ApolloServer, gql } from 'apollo-server-express'\n+import bodyParser from 'body-parser'\n+import cors from 'cors'\n+import express from 'express'\n+import schema from './schema'\n+\n+const app = express()\n+\n+app.use(cors())\n+app.use(bodyParser.json())\n+\n+app.get('/_ping', (req, res) => {\n+  res.send('pong')\n+})\n+\n+const server = new ApolloServer({ schema })\n+\n+server.applyMiddleware({\n+  app,\n+  path: '/graphql',\n+})\n+\n+const port = process.env.PORT || 4000\n+\n+app.listen(port, () => {\n+  console.log(`Server is listening on port ${port}`)\n+})\ndiff --git a/server/package.json b/server/package.json\nnew file mode 100644\nindex 0000000..ab050f9\n--- /dev/null\n+++ b/server/package.json\n@@ -0,0 +1,38 @@\n+{\n+  \"name\": \"whatsapp-clone-server\",\n+  \"description\": \"A newly created Tortilla project\",\n+  \"private\": true,\n+  \"scripts\": {\n+    \"start\": \"ts-node index.ts\",\n+    \"test\": \"jest\"\n+  },\n+  \"devDependencies\": {\n+    \"@types/body-parser\": \"1.17.0\",\n+    \"@types/cors\": \"2.8.4\",\n+    \"@types/express\": \"4.16.1\",\n+    \"@types/graphql\": \"14.0.7\",\n+    \"@types/graphql-iso-date\": \"3.3.1\",\n+    \"@types/jest\": \"24.0.11\",\n+    \"@types/node\": \"11.11.0\",\n+    \"ts-jest\": \"24.0.0\",\n+    \"jest\": \"24.5.0\",\n+    \"ts-node\": \"8.0.3\",\n+    \"typescript\": \"3.3.3333\"\n+  },\n+  \"dependencies\": {\n+    \"apollo-server-express\": \"2.4.8\",\n+    \"apollo-server-testing\": \"2.4.8\",\n+    \"body-parser\": \"1.18.3\",\n+    \"cors\": \"2.8.5\",\n+    \"express\": \"4.16.4\",\n+    \"graphql\": \"14.1.1\",\n+    \"graphql-import\": \"0.7.1\",\n+    \"graphql-iso-date\": \"3.6.1\",\n+    \"graphql-tools\": \"4.0.4\"\n+  },\n+  \"jest\": {\n+    \"transform\": {\n+      \"^.+\\\\.(js|jsx|ts|tsx)$\": \"<rootDir>/node_modules/ts-jest\"\n+    }\n+  }\n+}\ndiff --git a/server/schema/index.ts b/server/schema/index.ts\nnew file mode 100644\nindex 0000000..b94bc37\n--- /dev/null\n+++ b/server/schema/index.ts\n@@ -0,0 +1,7 @@\n+import { importSchema } from 'graphql-import'\n+import { makeExecutableSchema } from 'graphql-tools'\n+import resolvers from './resolvers'\n+\n+const typeDefs = importSchema('schema/typeDefs.graphql')\n+\n+export default makeExecutableSchema({ resolvers, typeDefs })\ndiff --git a/server/schema/resolvers.ts b/server/schema/resolvers.ts\nnew file mode 100644\nindex 0000000..1a056ba\n--- /dev/null\n+++ b/server/schema/resolvers.ts\n@@ -0,0 +1,28 @@\n+import { GraphQLDateTime } from 'graphql-iso-date'\n+import { chats, messages } from '../db'\n+\n+export default {\n+  Date: GraphQLDateTime,\n+\n+  Chat: {\n+    messages(chat: any) {\n+      return messages.filter(m => chat.messages.includes(m.id))\n+    },\n+\n+    lastMessage(chat: any) {\n+      const lastMessage = chat.messages[chat.messages.length - 1]\n+\n+      return messages.find(m => m.id === lastMessage)\n+    },\n+  },\n+\n+  Query: {\n+    chats() {\n+      return chats\n+    },\n+\n+    chat(chat: any, { chatId }: any) {\n+      return chats.find(c => c.id === chatId)\n+    },\n+  },\n+}\ndiff --git a/server/schema/typeDefs.graphql b/server/schema/typeDefs.graphql\nnew file mode 100644\nindex 0000000..9e19c52\n--- /dev/null\n+++ b/server/schema/typeDefs.graphql\n@@ -0,0 +1,20 @@\n+scalar Date\n+\n+type Message {\n+  id: ID!\n+  content: String!\n+  createdAt: Date!\n+}\n+\n+type Chat {\n+  id: ID!\n+  name: String!\n+  picture: String\n+  lastMessage: Message\n+  messages: [Message!]!\n+}\n+\n+type Query {\n+  chats: [Chat!]!\n+  chat(chatId: ID!): Chat\n+}\ndiff --git a/server/tests/queries/__snapshots__/getChat.test.ts.snap b/server/tests/queries/__snapshots__/getChat.test.ts.snap\nnew file mode 100644\nindex 0000000..a4b7849\n--- /dev/null\n+++ b/server/tests/queries/__snapshots__/getChat.test.ts.snap\n@@ -0,0 +1,16 @@\n+// Jest Snapshot v1, https://goo.gl/fbAQLP\n+\n+exports[`Query.chat should fetch specified chat 1`] = `\n+Object {\n+  \"chat\": Object {\n+    \"id\": \"1\",\n+    \"lastMessage\": Object {\n+      \"content\": \"You on your way?\",\n+      \"createdAt\": \"2018-12-30T23:20:00.000Z\",\n+      \"id\": \"1\",\n+    },\n+    \"name\": \"Ethan Gonzalez\",\n+    \"picture\": \"https://randomuser.me/api/portraits/thumb/men/1.jpg\",\n+  },\n+}\n+`;\ndiff --git a/server/tests/queries/__snapshots__/getChats.test.ts.snap b/server/tests/queries/__snapshots__/getChats.test.ts.snap\nnew file mode 100644\nindex 0000000..54a167c\n--- /dev/null\n+++ b/server/tests/queries/__snapshots__/getChats.test.ts.snap\n@@ -0,0 +1,48 @@\n+// Jest Snapshot v1, https://goo.gl/fbAQLP\n+\n+exports[`Query.chats should fetch all chats 1`] = `\n+Object {\n+  \"chats\": Array [\n+    Object {\n+      \"id\": \"1\",\n+      \"lastMessage\": Object {\n+        \"content\": \"You on your way?\",\n+        \"createdAt\": \"2018-12-30T23:20:00.000Z\",\n+        \"id\": \"1\",\n+      },\n+      \"name\": \"Ethan Gonzalez\",\n+      \"picture\": \"https://randomuser.me/api/portraits/thumb/men/1.jpg\",\n+    },\n+    Object {\n+      \"id\": \"2\",\n+      \"lastMessage\": Object {\n+        \"content\": \"Hey, it's me\",\n+        \"createdAt\": \"2018-12-30T06:40:00.000Z\",\n+        \"id\": \"2\",\n+      },\n+      \"name\": \"Bryan Wallace\",\n+      \"picture\": \"https://randomuser.me/api/portraits/thumb/men/2.jpg\",\n+    },\n+    Object {\n+      \"id\": \"3\",\n+      \"lastMessage\": Object {\n+        \"content\": \"I should buy a boat\",\n+        \"createdAt\": \"2018-12-15T00:00:00.000Z\",\n+        \"id\": \"3\",\n+      },\n+      \"name\": \"Avery Stewart\",\n+      \"picture\": \"https://randomuser.me/api/portraits/thumb/women/1.jpg\",\n+    },\n+    Object {\n+      \"id\": \"4\",\n+      \"lastMessage\": Object {\n+        \"content\": \"This is wicked good ice cream.\",\n+        \"createdAt\": \"2018-05-12T08:00:00.000Z\",\n+        \"id\": \"4\",\n+      },\n+      \"name\": \"Katie Peterson\",\n+      \"picture\": \"https://randomuser.me/api/portraits/thumb/women/2.jpg\",\n+    },\n+  ],\n+}\n+`;\ndiff --git a/server/tests/queries/getChat.test.ts b/server/tests/queries/getChat.test.ts\nnew file mode 100644\nindex 0000000..0d8bc8e\n--- /dev/null\n+++ b/server/tests/queries/getChat.test.ts\n@@ -0,0 +1,33 @@\n+import { createTestClient } from 'apollo-server-testing'\n+import { ApolloServer, gql } from 'apollo-server-express'\n+import schema from '../../schema'\n+\n+describe('Query.chat', () => {\n+  it('should fetch specified chat', async () => {\n+    const server = new ApolloServer({ schema })\n+\n+    const { query } = createTestClient(server)\n+\n+    const res = await query({\n+      variables: { chatId: '1' },\n+      query: gql `\n+        query GetChat($chatId: ID!) {\n+          chat(chatId: $chatId) {\n+            id\n+            name\n+            picture\n+            lastMessage {\n+              id\n+              content\n+              createdAt\n+            }\n+          }\n+        }\n+      `,\n+    })\n+\n+    expect(res.data).toBeDefined()\n+    expect(res.errors).toBeUndefined()\n+    expect(res.data).toMatchSnapshot()\n+  })\n+})\ndiff --git a/server/tests/queries/getChats.test.ts b/server/tests/queries/getChats.test.ts\nnew file mode 100644\nindex 0000000..09d876c\n--- /dev/null\n+++ b/server/tests/queries/getChats.test.ts\n@@ -0,0 +1,32 @@\n+import { createTestClient } from 'apollo-server-testing'\n+import { ApolloServer, gql } from 'apollo-server-express'\n+import schema from '../../schema'\n+\n+describe('Query.chats', () => {\n+  it('should fetch all chats', async () => {\n+    const server = new ApolloServer({ schema })\n+\n+    const { query } = createTestClient(server)\n+\n+    const res = await query({\n+      query: gql `\n+        query GetChats {\n+          chats {\n+            id\n+            name\n+            picture\n+            lastMessage {\n+              id\n+              content\n+              createdAt\n+            }\n+          }\n+        }\n+      `,\n+    })\n+\n+    expect(res.data).toBeDefined()\n+    expect(res.errors).toBeUndefined()\n+    expect(res.data).toMatchSnapshot()\n+  })\n+})\ndiff --git a/server/tsconfig.json b/server/tsconfig.json\nnew file mode 100644\nindex 0000000..fe56553\n--- /dev/null\n+++ b/server/tsconfig.json\n@@ -0,0 +1,16 @@\n+{\n+  \"compilerOptions\": {\n+    \"target\": \"es2018\",\n+    \"module\": \"commonjs\",\n+    \"lib\": [\n+      \"es2018\",\n+      \"esnext.asynciterable\"\n+    ],\n+    \"strict\": true,\n+    \"strictFunctionTypes\": false,\n+    \"strictPropertyInitialization\": false,\n+    \"esModuleInterop\": true,\n+    \"experimentalDecorators\": true,\n+    \"emitDecoratorMetadata\": true\n+  }\n+}\ndiff --git a/server/types/apollo-server-testing.d.ts b/server/types/apollo-server-testing.d.ts\nnew file mode 100644\nindex 0000000..e9d9b94\n--- /dev/null\n+++ b/server/types/apollo-server-testing.d.ts\n@@ -0,0 +1,27 @@\n+declare module 'apollo-server-testing' {\n+  import { ApolloServerBase } from 'apollo-server-core';\n+  import { print, DocumentNode } from 'graphql';\n+  import { GraphQLResponse } from 'graphql-extensions';\n+\n+  type StringOrAst = string | DocumentNode;\n+\n+  // A query must not come with a mutation (and vice versa).\n+  type Query<TVariables> = {\n+    query: StringOrAst;\n+    mutation?: undefined;\n+    variables?: TVariables;\n+  };\n+\n+  type Mutation<TVariables> = {\n+    mutation: StringOrAst;\n+    query?: undefined;\n+    variables?: TVariables;\n+  };\n+\n+  export const createTestClient: <TVariables>(\n+    server: ApolloServerBase,\n+  ) => {\n+    query: (query: Query<TVariables>) => Promise<GraphQLResponse>;\n+    mutate: (mutation: Mutation<TVariables>) => Promise<GraphQLResponse>;\n+  };\n+}\n",
        "manuals": [
          {
            "manualTitle": "Whatsapp Clone Tutorial",
            "stepRevision": "281a9a5866e2b1d54e2372cc1bede1450a0f8d7c",
            "manualView": "![whatsapp-clone](https://user-images.githubusercontent.com/7648874/54141944-9f801a80-4461-11e9-85a1-bcb161d9a6c6.png)\n\nWhatsapp Clone is an open-source tutorial that will guide you through step-by-step on how to create a full-stack hybrid web-app.\n\nThe software world is evolving quickly, and oftentimes people find themselves left behind, even the most experienced ones. The purpose of this tutorial is to completely demystify the confusion, and be the main guide on how to do things properly.\n\nThis tutorial is for anyone who has ever asked himself or herself one of the following questions or similar:\n\n- How do people build an app today?\n- What are the “hottest”, most leading technologies currently in the ecosystem?\n- What are the best practices for using technology XXX?\n- What is the purpose of technology XXX?\n- How does technology XXX work?\n- How do I use technology XXX?\n- How do I migrate to the new version of technology XXX?\n- Why should I use technology XXX over technology YYY?\n\nAll of the above and more can be answered in the tutorial. Whether you’re a beginner, intermediate or a professional, we will have the answers you’re looking for.\n\n**What technologies does Whatsapp Clone uses?**\n\nCurrently, Whatsapp Clone uses:\n\n- [React (with Hooks and Suspense)](http://react.com)\n- [Styled-Components](https://styled-components.com)\n- [Material-UI](https://material-ui.com)\n- [TypeScript](https://typescriptlang.org)\n- [Apollo GraphQL](https://www.apollographql.com)\n- [GraphQL Code Generator](http://graphql-code-generator.com)\n- [GraphQL Modules](https://graphql-modules.com)\n- [PostgreSQL](https://www.postgresql.org/)\n- [TypeORM](https://github.com/typeorm/typeorm)\n\nThe point of this tutorial is not to be bound to a certain technology, but rather keep itself aligned with the ecosystem. When a new technology comes out, and it’s better and more popular, Whatsapp Clone will use it at some point (and full migration instructions).\n\n**P2P tutorial for the community by the community**\n\nWhat better way would it be to keep Whatsapp Clone aligned with the ecosystem than letting the community maintain it? Rather than dictating what technologies will be used in the app or how’s the tutorial gonna be written, you’re gonna decide how things are gonna be. That’s why we made it open source:\n\n- [Whatsapp Clone - Client](https://github.com/Urigo/WhatsApp-Clone-Client-React/tree/step-by-step-final)\n- [Whatsapp Clone - Server](https://github.com/Urigo/WhatsApp-Clone-server/step-by-step-final)\n\nWe’ve also made sure to publish some important documents so you can get more involved. You can track our progress and comment your suggestions, since everything is based on Google Docs and is updated live:\n\n- [Road map](https://docs.google.com/document/d/1p2Zio6Js2eoFfHs9CjIMF6jTuNyD4eQEHlgEAKhAqM8/edit?usp=sharing)\n- [Chapter manuals] (https://drive.google.com/open?id=1ITxOniS_S3sgZfunLvtJ1L9P6Fj1YOLlFHhoQPjT3S0)\n\n**Migration instructions included**\n\nThe are great tutorials out there, but almost none of them shows you what changes you should make in your app in order to be aligned with a new version of a certain technology. Technologies are being updated by the minute, some changes are minor and insignificant, but often times a breaking change will be made in which case we need to know how we can adapt to that change. Thanks to the [Tortilla platform](https://tortilla.academy), we can provide you with a git-diff that will show you what changes were made between each and every released version of the Whatsapp Clone tutorial since the beginning of history. This way you can easily notice the changes in APIs and migrate your app in no time.\n\n![tutorial-versions-diff](https://user-images.githubusercontent.com/7648874/54142148-0f8ea080-4462-11e9-9522-ec9997b76169.png)\n\n**Prerequisites**\n\n- JavaScript\n- TypeScript\n- JSX\n- HTML\n- CSS\n- Node.JS\n- NPM\n- React\n- SQL\n\nOS operations such as navigating to a folder, or creating a folder, are all gonna be written in Bash, but the instructions are OS agnostic and can be applied on any machine that is web-compatible.\n\n**What’s on the tutorial?**\n\nWhatsapp Clone is built chronologically, from the most basic, to more higher level features, so be sure to execute it in the right order. Each step is focused on a different subject, so by the end of it you’ll have a new feature and a new set of knowledge that you can start implementing in your everyday scenario immediately.\n\nCurrently, Whatsapp Clone includes the following chapters:\n\n- [Step 1: Creating a basic React APP with a basic view.](https://github.com/Urigo/WhatsApp-Clone-Tutorial/blob/final/.tortilla/manuals/views/step1.md)\n- [Step 2: Styling with Material-UI and Styled-Components.](https://github.com/Urigo/WhatsApp-Clone-Tutorial/blob/final/.tortilla/manuals/views/step2.md)\n- [Step 3: Setting a basic Node.JS server with basic a basic REST endpoint.](https://github.com/Urigo/WhatsApp-Clone-Tutorial/blob/final/.tortilla/manuals/views/step3.md)\n- [Step 4: Transition to GraphQL.](https://github.com/Urigo/WhatsApp-Clone-Tutorial/blob/final/.tortilla/manuals/views/step4.md)\n- Step N: TBA\n\nWhatsapp Clone is updated on a regular basis, so you should expect more steps and extensions to it not long from now. You can keep track of our [road map](https://docs.google.com/document/d/1p2Zio6Js2eoFfHs9CjIMF6jTuNyD4eQEHlgEAKhAqM8/edit?usp=sharing) to see what’s upcoming."
          },
          {
            "manualTitle": "Step 1: Creating a basic React APP with a basic view",
            "stepRevision": "d913ca8b6da27f1e83ebc344dad234725a867df5",
            "manualView": "In this chapter we will learn how to create a basic React app. The app will contain a basic view that will render a list of conversations within our app. Everything should be done gradually, so for now, instead of using real data, we will use in-memory fake data instead of calling a server.\n\nThere are many ways to create an application. Indeed, you can create it from scratch, but the point behind development is that you'll make the least amount of work if possible. The point is to create a working product, and time is what matters, thus we're gonna use a boilerplate to kick-start our application. When it comes to React apps, the most popular is [`create-react-app`](https://github.com/facebook/create-react-app), which is pretty generic and easy to use. In addition, it's officially maintained by Facebook, the creators of React.\n\n`create-react-app` is a CLI that is installable via NPM:\n\n    $ npm install -g create-react-app\n\nOnce you do so, you will have it available in your terminal. If the installation failed, try to run the command as `sudo`:\n\n\t$ sudo npm install -g create-react-app\n\nUsing the `create` command, we can create the basis for our Whatsapp Clone:\n\n    $ create-react-app create whatsapp-clone-client\n\n> Note how we used the `client` prefix. That's because we're planning to create a server as well in further chapters.\n\nIt will create a directory called `whatsapp-clone-client` inside the current folder. Inside that directory, it will generate the initial project structure and install the transitive dependencies:\n\n    my-app\n    ├── README.md\n    ├── node_modules\n    ├── package.json\n    ├── .gitignore\n    ├── public\n    │   ├── favicon.ico\n    │   ├── index.html\n    │   └── manifest.json\n    └── src\n        ├── App.css\n        ├── App.js\n        ├── App.test.js\n        ├── index.css\n        ├── index.js\n        ├── logo.svg\n        └── serviceWorker.js\n\nNo configuration or complicated folder structures, just the files you need to build your app. Once the installation is done, you can open your project folder:\n\n\t$ cd whatsapp-clone-client\n\nInside the newly created project, you can run some built-in commands:\n\n\t$ npm start\n\nRuns the app in development mode. Open `http://localhost:3000` to view it in the browser:\n\n![boilerplate-page](https://user-images.githubusercontent.com/7648874/54026782-025f8080-41da-11e9-9a4e-796fe15e8d03.png)\n\nThe project that was created for us by `create-react-app` is highly functional and ready to use, but it's implemented in JavaScript. In our project, we're gonna use TypeScript. There's no right or wrong here, it's more of a personal choice. The main advantage of using TypeScript over using plain JavaScript is that we get to tell the compiler what types and data structures we expect in certain places, so that the compiler (which unlike a human never forgets) will remind us when we make a mistake and assume something that is not true.\n\nLuckily enough, `create-react-app` comes with a TypeScript support right out of the box, we only need to make a few adjustments in-order to make it work. First we need to install the TypeScript package, which is essential for TypeScript to function:\n\n\t$ yarn add typescript\n\nEvery TypeScript project requires a `tsconfig.json` to be defined. This configuration file will dictate the behavior of TypeScript within that project. More about `tsconfig.json` and its available options can be found in the [official TypeScript handbook](https://www.typescriptlang.org/docs/handbook/tsconfig-json.html). This is the config file we're gonna use in our project:\n\n[{]: <helper> (diffStep \"1.1\" files=\"tsconfig.json\" module=\"client\")\n\n#### [Step 1.1: Setup TypeScript](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/c05e16f)\n\n##### Added tsconfig.json\n```diff\n@@ -0,0 +1,35 @@\n+┊  ┊ 1┊{\n+┊  ┊ 2┊  \"compilerOptions\": {\n+┊  ┊ 3┊    \"outDir\": \"build/dist\",\n+┊  ┊ 4┊    \"sourceMap\": true,\n+┊  ┊ 5┊    \"declaration\": false,\n+┊  ┊ 6┊    \"moduleResolution\": \"node\",\n+┊  ┊ 7┊    \"emitDecoratorMetadata\": true,\n+┊  ┊ 8┊    \"experimentalDecorators\": true,\n+┊  ┊ 9┊    \"downlevelIteration\": true,\n+┊  ┊10┊    \"resolveJsonModule\": true,\n+┊  ┊11┊    \"target\": \"es5\",\n+┊  ┊12┊    \"jsx\": \"preserve\",\n+┊  ┊13┊    \"typeRoots\": [\n+┊  ┊14┊      \"node_modules/@types\"\n+┊  ┊15┊    ],\n+┊  ┊16┊    \"lib\": [\n+┊  ┊17┊      \"es2017\",\n+┊  ┊18┊      \"dom\",\n+┊  ┊19┊      \"esnext.asynciterable\"\n+┊  ┊20┊    ],\n+┊  ┊21┊    \"allowJs\": true,\n+┊  ┊22┊    \"skipLibCheck\": true,\n+┊  ┊23┊    \"esModuleInterop\": false,\n+┊  ┊24┊    \"allowSyntheticDefaultImports\": true,\n+┊  ┊25┊    \"forceConsistentCasingInFileNames\": true,\n+┊  ┊26┊    \"isolatedModules\": true,\n+┊  ┊27┊    \"noEmit\": true,\n+┊  ┊28┊    \"noImplicitAny\": false,\n+┊  ┊29┊    \"strict\": false,\n+┊  ┊30┊    \"module\": \"esnext\"\n+┊  ┊31┊  },\n+┊  ┊32┊  \"include\": [\n+┊  ┊33┊    \"src\"\n+┊  ┊34┊  ]\n+┊  ┊35┊}\n```\n\n[}]: #\n\nWe're also gonna add a `tslint.json` file into the project - a file which will determine the linting preferences for our project. All rules are listed and explained in the [official rules doc page](https://palantir.github.io/tslint/rules/). We will use the following rules:\n\n[{]: <helper> (diffStep \"1.1\" files=\"tslint.json\" module=\"client\")\n\n#### [Step 1.1: Setup TypeScript](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/c05e16f)\n\n##### Added tslint.json\n```diff\n@@ -0,0 +1,29 @@\n+┊  ┊ 1┊{\n+┊  ┊ 2┊  \"extends\": [\"tslint:recommended\", \"tslint-react\", \"tslint-config-prettier\"],\n+┊  ┊ 3┊  \"rules\": {\n+┊  ┊ 4┊    \"ordered-imports\": false,\n+┊  ┊ 5┊    \"object-literal-sort-keys\": false,\n+┊  ┊ 6┊    \"jsx-boolean-value\": false,\n+┊  ┊ 7┊    \"interface-name\" : false,\n+┊  ┊ 8┊    \"variable-name\": false,\n+┊  ┊ 9┊    \"no-string-literal\": false,\n+┊  ┊10┊    \"no-namespace\": false,\n+┊  ┊11┊    \"interface-over-type-literal\": false,\n+┊  ┊12┊    \"no-shadowed-variable\": false,\n+┊  ┊13┊    \"curly\": false,\n+┊  ┊14┊    \"no-label\": false,\n+┊  ┊15┊    \"no-empty\": false,\n+┊  ┊16┊    \"no-debugger\": false,\n+┊  ┊17┊    \"no-console\": false,\n+┊  ┊18┊    \"array-type\": false\n+┊  ┊19┊  },\n+┊  ┊20┊  \"linterOptions\": {\n+┊  ┊21┊    \"exclude\": [\n+┊  ┊22┊      \"config/**/*.js\",\n+┊  ┊23┊      \"node_modules/**/*.ts\",\n+┊  ┊24┊      \"coverage/lcov-report/*.js\",\n+┊  ┊25┊      \"*.json\",\n+┊  ┊26┊      \"**/*.json\"\n+┊  ┊27┊    ]\n+┊  ┊28┊  }\n+┊  ┊29┊}\n```\n\n[}]: #\n\nOnce we will run the app for the first time, `react-scripts` (`create-react-app` utility scripts package) should automatically initialize some additional TypeScript related files:\n\n\t$ npm start\n\nSince we're gonna use the new React [Hooks](https://reactjs.org/docs/hooks-intro.html) and [Suspense](https://reactjs.org/docs/react-api.html#reactsuspense) mechanisms, **make sure that your app uses React version 16.8 or above, otherwise it won't work.** The React version can be determined simply by looking at the `package.json` file. If by any chance your React version is lower than the required one, be sure to upgrade the version of `create-react-app` by upgrading it to the latest one and repeat the process of the project creation. Just in case, `create-react-app` can be upgrade by re-running the install command:\n\n\t$ npm install -g create-react-app\n\nAssuming that everything is set, we will now create our first screen - ChatsListScreen. The ChatsListScreen component is responsible for showing the active conversations within our app. Everything should be done gradually, so for now, instead of using real data, we will use in-memory fake data. Further in this tutorial, we will also create a server that will serve that data and connect it to our client.\n\nIt's best to first schematically plan how our view's gonna look like. This would help us illustrate the intended view and also understand which React.Components / elements take part in it. This is how our screen's gonna look like:\n\n![chatslistscreen](https://user-images.githubusercontent.com/7648874/54027873-01305280-41de-11e9-9df0-5ad9c9c2f226.png)\n\nLet's break down the image above and see what components are we gonna have in the ChatsListScreen:\n\n- Navbar -  Which should contain a simple static title for now.\n- ChatsList - Where each item's gonna contain some data regards the user we're chatting with and information about the chat.\n\nReact apps tend to store React.Components under a directory located at `src/components`, and so we're gonna follow this pattern. We will create a directory called ChatsListScreen in the `components` dir where we're simply gonna import and put together the Navbar and ChatsList components. This is how the contents of that directory should look like:\n\n    ChatsListScreen\n    ├── index.tsx\n    ├── ChatsList\n    └── ChatsNavbar\n\nWe will use the `index.tsx` file to define that component, this way we can import it using the directory name:\n\n[{]: <helper> (diffStep \"1.2\" files=\"components/ChatsListScreen/index.jsx\" module=\"client\")\n\n#### [Step 1.2: Implement ChatsListScreen](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/80da8a2)\n\n\n\n[}]: #\n\nNow we can implement the Navbar component, which doesn't have much for now except some text describing the app:\n\n[{]: <helper> (diffStep \"1.2\" files=\"components/ChatsListScreen/ChatsNavbar.jsx\" module=\"client\")\n\n#### [Step 1.2: Implement ChatsListScreen](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/80da8a2)\n\n\n\n[}]: #\n\nAnd the ChatsList component:\n\n[{]: <helper> (diffStep \"1.2\" files=\"components/ChatsListScreen/ChatsList.jsx\" module=\"client\")\n\n#### [Step 1.2: Implement ChatsListScreen](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/80da8a2)\n\n\n\n[}]: #\n\nYou can see in the code-diff above how we used the [`moment`](https://momentjs.com/) library to wrap `lastMessage.createdAt`. Moment has the ability to wrap date objects nicely and rewrite them in a pretty format. This way we can have an elegant time format at which the message was sent e.g. `11:34`. To install:\n\n\t$ yarn add moment\n\nThe ChatsList component has no event handlers and it's completely non-interactive as for now, that means that you can't click or tap anything yet, but as we go further in the tutorial we will add the necessary event handlers. Note how we used the `db.ts` module to get the chats data. `db.ts` is a temporary mock for our data-source and should be removed once we have a server up and running. Here's how our DB looks like:\n\n[{]: <helper> (diffStep \"1.3\" module=\"client\")\n\n#### [Step 1.3: Add db mock](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/254ce3f)\n\n##### Added src&#x2F;db.ts\n```diff\n@@ -0,0 +1,49 @@\n+┊  ┊ 1┊export const messages = [\n+┊  ┊ 2┊  {\n+┊  ┊ 3┊    id: 1,\n+┊  ┊ 4┊    content: \"You on your way?\",\n+┊  ┊ 5┊    createdAt: new Date(Date.now() - 60 * 1000 * 1000),\n+┊  ┊ 6┊  },\n+┊  ┊ 7┊  {\n+┊  ┊ 8┊    id: 2,\n+┊  ┊ 9┊    content: \"Hey, it's me\",\n+┊  ┊10┊    createdAt: new Date(Date.now() - 2 * 60 * 1000 * 1000),\n+┊  ┊11┊  },\n+┊  ┊12┊  {\n+┊  ┊13┊    id: 3,\n+┊  ┊14┊    content: \"I should buy a boat\",\n+┊  ┊15┊    createdAt: new Date(Date.now() - 24 * 60 * 1000 * 1000),\n+┊  ┊16┊  },\n+┊  ┊17┊  {\n+┊  ┊18┊    id: 4,\n+┊  ┊19┊    content: \"This is wicked good ice cream.\",\n+┊  ┊20┊    createdAt: new Date(Date.now() - 14 * 24 * 60 * 1000 * 1000),\n+┊  ┊21┊  },\n+┊  ┊22┊]\n+┊  ┊23┊\n+┊  ┊24┊export const chats = [\n+┊  ┊25┊  {\n+┊  ┊26┊    id: 1,\n+┊  ┊27┊    name: 'Ethan Gonzalez',\n+┊  ┊28┊    picture: 'https://randomuser.me/api/portraits/thumb/men/1.jpg',\n+┊  ┊29┊    lastMessage: messages.find(m => m.id === 1),\n+┊  ┊30┊  },\n+┊  ┊31┊  {\n+┊  ┊32┊    id: 2,\n+┊  ┊33┊    name: 'Bryan Wallace',\n+┊  ┊34┊    picture: 'https://randomuser.me/api/portraits/thumb/men/2.jpg',\n+┊  ┊35┊    lastMessage: messages.find(m => m.id === 2),\n+┊  ┊36┊  },\n+┊  ┊37┊  {\n+┊  ┊38┊    id: 3,\n+┊  ┊39┊    name: 'Avery Stewart',\n+┊  ┊40┊    picture: 'https://randomuser.me/api/portraits/thumb/women/1.jpg',\n+┊  ┊41┊    lastMessage: messages.find(m => m.id === 3),\n+┊  ┊42┊  },\n+┊  ┊43┊  {\n+┊  ┊44┊    id: 4,\n+┊  ┊45┊    name: 'Katie Peterson',\n+┊  ┊46┊    picture: 'https://randomuser.me/api/portraits/thumb/women/2.jpg',\n+┊  ┊47┊    lastMessage: messages.find(m => m.id === 4),\n+┊  ┊48┊  },\n+┊  ┊49┊]\n```\n\n[}]: #\n\nThe ChatsListScreen is now ready to use. We will replace the contents of the App component with the ChatsListScreen and we will make it the default screen in our app:\n\n[{]: <helper> (diffStep \"1.4\" files=\"App.jsx\" module=\"client\")\n\n#### [Step 1.4: Import ChatsListScreen](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/298b0d2)\n\n##### Changed src&#x2F;App.jsx\n```diff\n@@ -1,28 +1,10 @@\n-┊ 1┊  ┊import React, { Component } from 'react';\n-┊ 2┊  ┊import logo from './logo.svg';\n-┊ 3┊  ┊import './App.css';\n+┊  ┊ 1┊import * as React from 'react'\n+┊  ┊ 2┊import ChatsListScreen from './components/ChatsListScreen'\n ┊ 4┊ 3┊\n-┊ 5┊  ┊class App extends Component {\n-┊ 6┊  ┊  render() {\n-┊ 7┊  ┊    return (\n-┊ 8┊  ┊      <div className=\"App\">\n-┊ 9┊  ┊        <header className=\"App-header\">\n-┊10┊  ┊          <img src={logo} className=\"App-logo\" alt=\"logo\" />\n-┊11┊  ┊          <p>\n-┊12┊  ┊            Edit <code>src/App.js</code> and save to reload.\n-┊13┊  ┊          </p>\n-┊14┊  ┊          <a\n-┊15┊  ┊            className=\"App-link\"\n-┊16┊  ┊            href=\"https://reactjs.org\"\n-┊17┊  ┊            target=\"_blank\"\n-┊18┊  ┊            rel=\"noopener noreferrer\"\n-┊19┊  ┊          >\n-┊20┊  ┊            Learn React\n-┊21┊  ┊          </a>\n-┊22┊  ┊        </header>\n-┊23┊  ┊      </div>\n-┊24┊  ┊    );\n-┊25┊  ┊  }\n-┊26┊  ┊}\n+┊  ┊ 4┊const App = () => (\n+┊  ┊ 5┊  <div>\n+┊  ┊ 6┊    <ChatsListScreen />\n+┊  ┊ 7┊  </div>\n+┊  ┊ 8┊)\n ┊27┊ 9┊\n-┊28┊  ┊export default App;\n+┊  ┊10┊export default App\n```\n\n[}]: #\n\nIf you'll try to run the app you'll see that everything is there, but it's not hard to notice that it's missing some style:\n\n![naked-chats-list](https://user-images.githubusercontent.com/7648874/54028578-73099b80-41e0-11e9-803a-7469300acb06.png)\n\nIn the next chapter we will take care of styling our application with [Material-UI](https://material-ui.com/) and [styled-components](https://www.styled-components.com/) - we will give it the desired look and make it more user friendly. For now the ChatsListScreen serves no purpose, because you can't really do anything with it, but it can be used as a great basis to build on top of as we make progress."
          },
          {
            "manualTitle": "Step 2: Styling with Material UI and styled-components",
            "stepRevision": "a831935e614122962d32a2485c06082841e5b09f",
            "manualView": "Styled-components is a relatively new library that will transpile a given string into a CSS string and will encapsulate it under a React.Component. What's good about it is that you can define your style programmatically and it fits very well into React. With JavaScript in-hand you naturally have more control over your style, which makes it a very powerful tool.\n\nHere's one way to style a button using styled-components:\n\n```js\nconst Button = styled.button`\n  background: transparent;\n  border-radius: 3px;\n  border: 2px solid palevioletred;\n  color: palevioletred;\n  margin: 0.5em 1em;\n  padding: 0.25em 1em;\n\n  ${props => props.primary && css`\n    background: palevioletred;\n    color: white;\n  `}\n`;\n```\n\nThe created Button is actually a React.Component, so an instance of it can be created with ease like any other component:\n\n```jsx\n  <Button primary />\n```\n\nMore information about styled-components can be found in the official [docs page](https://www.styled-components.com/docs).\n\nWe would also use [Material-UI](https://material-ui.com/) - a library with a set of React components that implements Google's Material Design. What's good about it is that the design is already implemented right out of the box. Not only that, but it also includes a set of icons which are free to use.\n\nThere are many many things that Material-UI can offer, and it's not easy to follow it up, especially with the constantly evolving and improving API. The best way to go with it, is to have a component, and then look for it in the [official website](https://material-ui.com/). When it comes to searching for icons, they can be found in the [material.io](https://material-ui.com/) website through the search bar. As we move further in this tutorial you should have a better grasp of Material and how to use it.\n\n![material-ui-icons](https://user-images.githubusercontent.com/7648874/54141504-c853e000-4460-11e9-94b5-aae98ec9a1e3.png)\n\nWe will start off by installing both libraries:\n\n  $ npm install @material-ui/core @material-ui/icons styled-components\n\n`@material-ui/core` includes core component of Material-UI such as Input, Popover, Modal, etc, and `@material-ui/icons` includes a set of icons. Material is very generic and has a built in theming system which can be controlled by simply setting few variables, which is exactly what we're gonna need in our app.\n\nIn our app we're mainly gonna use 2 colors:\n\n- Primary #306759\n- Secondary #79e352\n\nTheme definition can easily be done in Material using the MuiThemeProvider component:\n\n[{]: <helper> (diffStep \"2.2\" module=\"client\")\n\n#### [Step 2.2: Setup Material-UI theme](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/e04f746)\n\n##### Changed src&#x2F;index.jsx\n```diff\n@@ -1,10 +1,25 @@\n+┊  ┊ 1┊import { MuiThemeProvider, createMuiTheme } from '@material-ui/core/styles'\n ┊ 1┊ 2┊import React from 'react';\n ┊ 2┊ 3┊import ReactDOM from 'react-dom';\n ┊ 3┊ 4┊import './index.css';\n ┊ 4┊ 5┊import App from './App';\n ┊ 5┊ 6┊import * as serviceWorker from './serviceWorker';\n ┊ 6┊ 7┊\n-┊ 7┊  ┊ReactDOM.render(<App />, document.getElementById('root'));\n+┊  ┊ 8┊const theme = createMuiTheme({\n+┊  ┊ 9┊  palette: {\n+┊  ┊10┊    primary: { main: '#2c6157' },\n+┊  ┊11┊    secondary: { main: '#6fd056' },\n+┊  ┊12┊  },\n+┊  ┊13┊  typography: {\n+┊  ┊14┊    useNextVariants: true,\n+┊  ┊15┊  },\n+┊  ┊16┊})\n+┊  ┊17┊\n+┊  ┊18┊ReactDOM.render(\n+┊  ┊19┊  <MuiThemeProvider theme={theme}>\n+┊  ┊20┊    <App />\n+┊  ┊21┊  </MuiThemeProvider>\n+┊  ┊22┊, document.getElementById('root'));\n ┊ 8┊23┊\n ┊ 9┊24┊// If you want your app to work offline and load faster, you can change\n ┊10┊25┊// unregister() to register() below. Note this comes with some pitfalls.\n```\n\n[}]: #\n\nOnce we have it set, the colors should be available to use in our application by simply providing the \"color\" prop to the component instance whose color we would like to change:\n\n```jsx\n<Button color=\"primary\">Primary</Button>\n<Button color=\"secondary\">Secondary</Button>\n```\n\nIn our app, we're also gonna use CSS directly to change its colors, therefore it would be handy to have these theme variables available to us through CSS. To do so, we will have have a second definition of these variables in `index.css`, at the `:root` level of our application.\n\n[{]: <helper> (diffStep \"2.3\" module=\"client\")\n\n#### [Step 2.3: Setup CSS theme vars](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/a31ace4)\n\n##### Changed src&#x2F;index.css\n```diff\n@@ -1,3 +1,10 @@\n+┊  ┊ 1┊:root {\n+┊  ┊ 2┊  --primary-bg: #2c6157;\n+┊  ┊ 3┊  --secondary-bg: #6fd056;\n+┊  ┊ 4┊  --primary-text: white;\n+┊  ┊ 5┊  --secondary-text: white;\n+┊  ┊ 6┊}\n+┊  ┊ 7┊\n ┊ 1┊ 8┊body {\n ┊ 2┊ 9┊  margin: 0;\n ┊ 3┊10┊  padding: 0;\n```\n\n[}]: #\n\n`:root` is a pseudo element that simply represents the root node, which will make the colors available in all elements. Normally, it works like JavaScript's scoping system and it will make variables available only to the current node and to its children, NOT its parents. CSS vars can be used like so:\n\n```css\n  color: var(--primary-text);\n  background-color: var(--primary-bg);\n```\n\nMore information about CSS variables can be found in the [official MDN docs](https://developer.mozilla.org/en-US/docs/Web/CSS/Using_CSS_variables).\n\nSo getting back to the ChatsListScreen, we will wrap the ChatsNavbar with Material's <Toolbar /> component:\n\n[{]: <helper> (diffStep \"2.4\" files=\"ChatsNavbar.tsx\" module=\"client\")\n\n#### [Step 2.4: Use Material components](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/e2e2104)\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;ChatsNavbar.tsx\n```diff\n@@ -1,9 +1,10 @@\n+┊  ┊ 1┊import { Toolbar } from '@material-ui/core'\n ┊ 1┊ 2┊import * as React from 'react'\n ┊ 2┊ 3┊\n ┊ 3┊ 4┊const ChatsNavbar = () => (\n-┊ 4┊  ┊  <div>\n+┊  ┊ 5┊  <Toolbar>\n ┊ 5┊ 6┊    Whatsapp Clone\n-┊ 6┊  ┊  </div>\n+┊  ┊ 7┊  </Toolbar>\n ┊ 7┊ 8┊)\n ┊ 8┊ 9┊\n ┊ 9┊10┊export default ChatsNavbar\n```\n\n[}]: #\n\nAnd we will replace the `<ul />` and `<li />` elements with Material's `<List />` and `<ListItem />` in ChatsList:\n\n[{]: <helper> (diffStep \"2.4\" files=\"ChatsList.tsx\" module=\"client\")\n\n#### [Step 2.4: Use Material components](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/e2e2104)\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;ChatsList.tsx\n```diff\n@@ -1,12 +1,13 @@\n+┊  ┊ 1┊import { List, ListItem } from '@material-ui/core'\n ┊ 1┊ 2┊import moment from 'moment'\n ┊ 2┊ 3┊import * as React from 'react'\n ┊ 3┊ 4┊import { chats } from '../../db'\n ┊ 4┊ 5┊\n ┊ 5┊ 6┊const ChatsList = () => (\n ┊ 6┊ 7┊  <div>\n-┊ 7┊  ┊    <ul>\n+┊  ┊ 8┊    <List>\n ┊ 8┊ 9┊      {chats.map((chat) => (\n-┊ 9┊  ┊        <li key={chat.id}>\n+┊  ┊10┊        <ListItem key={chat.id} button>\n ┊10┊11┊          <img src={chat.picture} />\n ┊11┊12┊          <div>{chat.name}</div>\n ┊12┊13┊          {chat.lastMessage && (\n```\n```diff\n@@ -15,9 +16,9 @@\n ┊15┊16┊              <div>{moment(chat.lastMessage.createdAt).format('HH:mm')}</div>\n ┊16┊17┊            </React.Fragment>\n ┊17┊18┊          )}\n-┊18┊  ┊        </li>\n+┊  ┊19┊        </ListItem>\n ┊19┊20┊      ))}\n-┊20┊  ┊    </ul>\n+┊  ┊21┊    </List>\n ┊21┊22┊  </div>\n ┊22┊23┊)\n ┊23┊24┊\n```\n\n[}]: #\n\nThanks to the `button` attribute we can give our list a more vibrant feeling and that will display a nice ripple effect once an item is clicked, something that could have taken a long time to implement manually.\n\nNext, we will use `styled-components` to create new React.Components which are bound into a style-sheet. This way when we create new instances of them, the components will be styled right out of the box. Example:\n\n```jsx\nconst Button = styled.button `\n  border-radius: 999px;\n`\n\nconst RedButton = styled(Button) `\n  color: red;\n`\n\nconst GreenButton = styled(Button) `\n  color: green;\n`\n\nconst BlueButton = styled(Button) `\n  color: blue;\n`\n\nconst Dashboard = (\n  <div>\n    <RedButton />\n    <GreenButton />\n    <BlueButton />\n  </div>\n)\n```\n\nThe clear advantage of such working strategy is that all the styles are encapsulated, unlike traditional CSS where style rules can easily collide and be merged unintentionally. Remember that **`styled-components` operates per component, not globally**. In terms of syntax and API there isn't much to explain, it's very intuitive and if you would follow the step-diffs in this tutorial carefully you should get the hang of `styled-components` pretty easily.\n\nAccordingly, let's use `styled-components` our `ChatsListScreen`:\n\n[{]: <helper> (diffStep \"2.5\" files=\"ChatsListScreen\" module=\"client\")\n\n#### [Step 2.5: Add style with styled-components](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/b12b9ff)\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;ChatsList.tsx\n```diff\n@@ -1,25 +1,79 @@\n ┊ 1┊ 1┊import { List, ListItem } from '@material-ui/core'\n ┊ 2┊ 2┊import moment from 'moment'\n ┊ 3┊ 3┊import * as React from 'react'\n+┊  ┊ 4┊import styled from 'styled-components'\n ┊ 4┊ 5┊import { chats } from '../../db'\n ┊ 5┊ 6┊\n+┊  ┊ 7┊const Container = styled.div `\n+┊  ┊ 8┊  height: calc(100% - 56px);\n+┊  ┊ 9┊  overflow-y: overlay;\n+┊  ┊10┊`\n+┊  ┊11┊\n+┊  ┊12┊const StyledList = styled(List) `\n+┊  ┊13┊  padding: 0 !important;\n+┊  ┊14┊`\n+┊  ┊15┊\n+┊  ┊16┊const StyledListItem = styled(ListItem) `\n+┊  ┊17┊  height: 76px;\n+┊  ┊18┊  padding: 0 15px;\n+┊  ┊19┊  display: flex;\n+┊  ┊20┊`\n+┊  ┊21┊\n+┊  ┊22┊const ChatPicture = styled.img `\n+┊  ┊23┊  height: 50px;\n+┊  ┊24┊  width: 50px;\n+┊  ┊25┊  object-fit: cover;\n+┊  ┊26┊  border-radius: 50%;\n+┊  ┊27┊`\n+┊  ┊28┊\n+┊  ┊29┊const ChatInfo = styled.div `\n+┊  ┊30┊  width: calc(100% - 60px);\n+┊  ┊31┊  padding: 15px 0;\n+┊  ┊32┊  margin-left: 10px;\n+┊  ┊33┊  border-bottom: 0.5px solid silver;\n+┊  ┊34┊  position: relative;\n+┊  ┊35┊`\n+┊  ┊36┊\n+┊  ┊37┊const ChatName = styled.div `\n+┊  ┊38┊  margin-top: 5px;\n+┊  ┊39┊`\n+┊  ┊40┊\n+┊  ┊41┊const MessageContent = styled.div `\n+┊  ┊42┊  color: gray;\n+┊  ┊43┊  font-size: 15px;\n+┊  ┊44┊  margin-top: 5px;\n+┊  ┊45┊  text-overflow: ellipsis;\n+┊  ┊46┊  overflow: hidden;\n+┊  ┊47┊  white-space: nowrap;\n+┊  ┊48┊`\n+┊  ┊49┊\n+┊  ┊50┊const MessageDate = styled.div `\n+┊  ┊51┊  position: absolute;\n+┊  ┊52┊  color: gray;\n+┊  ┊53┊  top: 20px;\n+┊  ┊54┊  right: 0;\n+┊  ┊55┊  font-size: 13px;\n+┊  ┊56┊`\n+┊  ┊57┊\n ┊ 6┊58┊const ChatsList = () => (\n-┊ 7┊  ┊  <div>\n-┊ 8┊  ┊    <List>\n+┊  ┊59┊  <Container>\n+┊  ┊60┊    <StyledList>\n ┊ 9┊61┊      {chats.map((chat) => (\n-┊10┊  ┊        <ListItem key={chat.id} button>\n-┊11┊  ┊          <img src={chat.picture} />\n-┊12┊  ┊          <div>{chat.name}</div>\n-┊13┊  ┊          {chat.lastMessage && (\n-┊14┊  ┊            <React.Fragment>\n-┊15┊  ┊              <div>{chat.lastMessage.content}</div>\n-┊16┊  ┊              <div>{moment(chat.lastMessage.createdAt).format('HH:mm')}</div>\n-┊17┊  ┊            </React.Fragment>\n-┊18┊  ┊          )}\n-┊19┊  ┊        </ListItem>\n+┊  ┊62┊        <StyledListItem key={chat.id} button>\n+┊  ┊63┊          <ChatPicture src={chat.picture} />\n+┊  ┊64┊          <ChatInfo>\n+┊  ┊65┊            <ChatName>{chat.name}</ChatName>\n+┊  ┊66┊            {chat.lastMessage && (\n+┊  ┊67┊              <React.Fragment>\n+┊  ┊68┊                <MessageContent>{chat.lastMessage.content}</MessageContent>\n+┊  ┊69┊                <MessageDate>{moment(chat.lastMessage.createdAt).format('HH:mm')}</MessageDate>\n+┊  ┊70┊              </React.Fragment>\n+┊  ┊71┊            )}\n+┊  ┊72┊          </ChatInfo>\n+┊  ┊73┊        </StyledListItem>\n ┊20┊74┊      ))}\n-┊21┊  ┊    </List>\n-┊22┊  ┊  </div>\n+┊  ┊75┊    </StyledList>\n+┊  ┊76┊  </Container>\n ┊23┊77┊)\n ┊24┊78┊\n ┊25┊79┊export default ChatsList\n```\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;ChatsNavbar.tsx\n```diff\n@@ -1,10 +1,18 @@\n ┊ 1┊ 1┊import { Toolbar } from '@material-ui/core'\n ┊ 2┊ 2┊import * as React from 'react'\n+┊  ┊ 3┊import styled from 'styled-components'\n+┊  ┊ 4┊\n+┊  ┊ 5┊const Container = styled(Toolbar) `\n+┊  ┊ 6┊  background-color: var(--primary-bg);\n+┊  ┊ 7┊  color: var(--primary-text);\n+┊  ┊ 8┊  font-size: 20px;\n+┊  ┊ 9┊  line-height: 40px;\n+┊  ┊10┊`\n ┊ 3┊11┊\n ┊ 4┊12┊const ChatsNavbar = () => (\n-┊ 5┊  ┊  <Toolbar>\n+┊  ┊13┊  <Container>\n ┊ 6┊14┊    Whatsapp Clone\n-┊ 7┊  ┊  </Toolbar>\n+┊  ┊15┊  </Container>\n ┊ 8┊16┊)\n ┊ 9┊17┊\n ┊10┊18┊export default ChatsNavbar\n```\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;index.tsx\n```diff\n@@ -1,12 +1,17 @@\n ┊ 1┊ 1┊import * as React from 'react'\n+┊  ┊ 2┊import styled from 'styled-components'\n ┊ 2┊ 3┊import ChatsNavbar from './ChatsNavbar'\n ┊ 3┊ 4┊import ChatsList from './ChatsList'\n ┊ 4┊ 5┊\n+┊  ┊ 6┊const Container = styled.div `\n+┊  ┊ 7┊  height: 100vh;\n+┊  ┊ 8┊`\n+┊  ┊ 9┊\n ┊ 5┊10┊const ChatsListScreen = () => (\n-┊ 6┊  ┊  <div>\n+┊  ┊11┊  <Container>\n ┊ 7┊12┊    <ChatsNavbar />\n ┊ 8┊13┊    <ChatsList />\n-┊ 9┊  ┊  </div>\n+┊  ┊14┊  </Container>\n ┊10┊15┊)\n ┊11┊16┊\n ┊12┊17┊export default ChatsListScreen\n```\n\n[}]: #\n\nNotice that we've changed the structure of the HTML of the ChatsList component. We've added the ChatInfo to allow better alignment of the elements. **There isn't right or wrong way to define CSS rules and HTML, as long as the script is clear and easy to understand, that will do**.\n\nWe're done styling `ChatsListScreen`. We will keep using the same principles to style the rest of the components in our application. The final result should look like so:\n\n![screenshot](https://user-images.githubusercontent.com/7648874/54141766-40baa100-4461-11e9-8dd0-59edcfdb3b84.png)"
          },
          {
            "manualTitle": "Step 3: Setup a basic Node.JS server with a basic REST endpoint",
            "stepRevision": "21ac15f658517699686281ba97757fc69e28ad0c",
            "manualView": "So we have a running app with a single screen which looks stylish and presents some data to the user. There is something missing though. The data that is presented is just a mock for a server response, and it represents the schema of some real data to come.\n\nEven if we'll create real data on the client, that means that when the client is down, all the data is lost. But this is a social app, many people want to use it together and even the same person wants to use it on multiple devices. For that, we need a central place to store all data and all the clients would connect to that central place in order to retrieve or change the data.\n\nIn this step, we will write a Node.JS server and will expose a REST endpoint that will serve the data-mock. We will build the REST application using [Express](https://www.npmjs.com/package/express). Further in this tutorial, we will migrate to using a real data-base with real I/O from the user, so we got you covered.\n\nThe plan is to have a server up and running at `localhost:4000` that will expose a `GET /chats` route. Unlike our client application, we're not gonna use any boilerplate and we're gonna set everything up manually. Ofcourse, you should feel free to use a boilerplate if it looks right to you. Right outside the client project, we will create a new directory called `whatsapp-clone-server` in which we will start creating our server:\n\n    $ mkdir whatsapp-clone-server\n    $ cd whatsapp-clone-server\n\nThen we will use NPM to initialize a new project:\n\n    $ npm init --yes\n\n> `--yes` will answer yes to all questions and skip the prompt. It's just faster this way.\n\nThere's nothing special about this command, it only creates a basic package.json which we can add things on top (see [NPM's official docs](https://docs.npmjs.com/cli/init)). Just to make sure that things work, we will add an `index.js` file which will print \"hello world\" to the console.\n\n[{]: <helper> (diffStep \"1.1\" files=\"index.js\" module=\"server\")\n\n#### Step 1.1: Create start script\n\n##### Added index.js\n```diff\n@@ -0,0 +1 @@\n+┊ ┊1┊console.log('hello world')\n```\n\n[}]: #\n\n\nAnd we will add a startup script to the `package.json` file called `start`:\n\n    start: node index.js\n\nNPM-scripts are just a way to defined an alias for commands. Now we only have one simple script, but it can turn out to be something very complex depending on our server, so it can be very useful. More about npm-scripts can be found in the [official NPM docs](https://docs.npmjs.com/misc/scripts).\n\nNow we can run our server by running `$ npm start` and we should see the message \"hello world\" printed to the console, as expected.\n\nLike in our client's app, we will be using TypeScript. It's comfortable and it enables consistency between both apps. In order to use TypeScript we will install few packages:\n\n    $ npm install --dev typescript ts-node @types/node\n\n> Note how we used the `--dev` flag. This project is not gonna be required as an external dependency anywhere, but It is still common to separate between production dependencies and development dependencies. More about the `--dev` option can be read in the [NPM-install docs](https://docs.npmjs.com/cli/install).\n\n- The [`typescript`](https://www.npmjs.com/package/typescript) package is TypeScript's core transpiler.\n- [`ts-node`](https://www.npmjs.com/package/ts-node) is an interpreter that will transpile required `.ts` files into JavaScript at runtime.\n- [`@types/node`](https://www.npmjs.com/package/@types/node) will make the appropriate definitions for a Node.JS environment.\n\n> You can read more about the `@types` monorepo in the [official GitHub repository](https://github.com/DefinitelyTyped/DefinitelyTyped).\n\nOur server is gonna use the following `tsconfig.json` file, feel free to make the necessary modifications based on your needs:\n\n[{]: <helper> (diffStep \"1.2\" files=\"tsconfig.json\" module=\"server\")\n\n#### Step 1.2: Setup TypeScript\n\n##### Added tsconfig.json\n```diff\n@@ -0,0 +1,16 @@\n+┊  ┊ 1┊{\n+┊  ┊ 2┊  \"compilerOptions\": {\n+┊  ┊ 3┊    \"target\": \"es2018\",\n+┊  ┊ 4┊    \"module\": \"commonjs\",\n+┊  ┊ 5┊    \"lib\": [\n+┊  ┊ 6┊      \"es2018\",\n+┊  ┊ 7┊      \"esnext.asynciterable\"\n+┊  ┊ 8┊    ],\n+┊  ┊ 9┊    \"strict\": true,\n+┊  ┊10┊    \"strictFunctionTypes\": false,\n+┊  ┊11┊    \"strictPropertyInitialization\": false,\n+┊  ┊12┊    \"esModuleInterop\": true,\n+┊  ┊13┊    \"experimentalDecorators\": true,\n+┊  ┊14┊    \"emitDecoratorMetadata\": true\n+┊  ┊15┊  }\n+┊  ┊16┊}\n```\n\n[}]: #\n\nWe will rename the `index.js` file to `index.ts`:\n\n    $ mv index.js index.ts\n\nAnd we will update the npm-script `start` to use `ts-node`, since we wanna use TypeScript, and not JavaScript directly:\n\n    start: ts-node index.ts\n\nWe can test the startup of our server again by running `$ npm start` and we should see the message \"hello world\" printed to the console. The skeleton of the project is set and we can move on to implementing the REST API.\n\nLike we said at the beginning, we will be using Express to setup the API. Express is wrap around the native [Node.JS \"http\"](https://nodejs.org/api/http.html) library which is responsible for handling HTTP requests. Yes, it can also be used directly, but Express is much more comfortable and has an amazing ecosystem built around it. Let's install Express and its TypeScript definitions:\n\n    $ npm install express\n    $ npm install --dev @types/express\n\nBefore we implement the `GET /chats` route we will implement a `GET /_ping` route. This route will be used to determine whether the server is up and running or not, and how fast the connection is based on the response time. For every request sent to this route, we should expect a response saying \"pong\". Some call it \"heartbeat\", because this route is being tested repeatedly by the hosting machine to check if it's alive, just like a heartbeat in a way. This is how the route should look like:\n\n[{]: <helper> (diffStep \"1.3\" files=\"index.ts\" module=\"server\")\n\n#### Step 1.3: Setup a Express with a basic health check route\n\n##### Changed index.ts\n```diff\n@@ -1 +1,13 @@\n-┊ 1┊  ┊console.log('hello world')\n+┊  ┊ 1┊import express from 'express'\n+┊  ┊ 2┊\n+┊  ┊ 3┊const app = express()\n+┊  ┊ 4┊\n+┊  ┊ 5┊app.get('/_ping', (req, res) => {\n+┊  ┊ 6┊  res.send('pong')\n+┊  ┊ 7┊})\n+┊  ┊ 8┊\n+┊  ┊ 9┊const port = process.env.PORT || 4000\n+┊  ┊10┊\n+┊  ┊11┊app.listen(port, () => {\n+┊  ┊12┊  console.log(`Server is listening on port ${port}`)\n+┊  ┊13┊})\n```\n\n[}]: #\n\nWe can use the `$ curl localhost:4000/_ping` command to send a request to the server and we should get a \"pong\", assuming that the server available on that URL. The `GET /chats` should be implemented similarly, only the response is different. Instead of returning \"pong\" we will return the data-mock for our chats:\n\n[{]: <helper> (diffStep \"1.4\" files=\"index.ts, db.ts\" module=\"server\")\n\n#### Step 1.4: Create GET /chats route\n\n##### Added db.ts\n```diff\n@@ -0,0 +1,49 @@\n+┊  ┊ 1┊export const messages = [\n+┊  ┊ 2┊  {\n+┊  ┊ 3┊    id: '1',\n+┊  ┊ 4┊    content: \"You on your way?\",\n+┊  ┊ 5┊    createdAt: new Date(new Date('1-1-2019').getTime() - 60 * 1000 * 1000),\n+┊  ┊ 6┊  },\n+┊  ┊ 7┊  {\n+┊  ┊ 8┊    id: '2',\n+┊  ┊ 9┊    content: \"Hey, it's me\",\n+┊  ┊10┊    createdAt: new Date(new Date('1-1-2019').getTime() - 2 * 60 * 1000 * 1000),\n+┊  ┊11┊  },\n+┊  ┊12┊  {\n+┊  ┊13┊    id: '3',\n+┊  ┊14┊    content: \"I should buy a boat\",\n+┊  ┊15┊    createdAt: new Date(new Date('1-1-2019').getTime() - 24 * 60 * 1000 * 1000),\n+┊  ┊16┊  },\n+┊  ┊17┊  {\n+┊  ┊18┊    id: '4',\n+┊  ┊19┊    content: \"This is wicked good ice cream.\",\n+┊  ┊20┊    createdAt: new Date(new Date('1-1-2019').getTime() - 14 * 24 * 60 * 1000 * 1000),\n+┊  ┊21┊  },\n+┊  ┊22┊]\n+┊  ┊23┊\n+┊  ┊24┊export const chats = [\n+┊  ┊25┊  {\n+┊  ┊26┊    id: '1',\n+┊  ┊27┊    name: 'Ethan Gonzalez',\n+┊  ┊28┊    picture: 'https://randomuser.me/api/portraits/thumb/men/1.jpg',\n+┊  ┊29┊    lastMessage: '1',\n+┊  ┊30┊  },\n+┊  ┊31┊  {\n+┊  ┊32┊    id: '2',\n+┊  ┊33┊    name: 'Bryan Wallace',\n+┊  ┊34┊    picture: 'https://randomuser.me/api/portraits/thumb/men/2.jpg',\n+┊  ┊35┊    lastMessage: '2',\n+┊  ┊36┊  },\n+┊  ┊37┊  {\n+┊  ┊38┊    id: '3',\n+┊  ┊39┊    name: 'Avery Stewart',\n+┊  ┊40┊    picture: 'https://randomuser.me/api/portraits/thumb/women/1.jpg',\n+┊  ┊41┊    lastMessage: '3',\n+┊  ┊42┊  },\n+┊  ┊43┊  {\n+┊  ┊44┊    id: '4',\n+┊  ┊45┊    name: 'Katie Peterson',\n+┊  ┊46┊    picture: 'https://randomuser.me/api/portraits/thumb/women/2.jpg',\n+┊  ┊47┊    lastMessage: '4',\n+┊  ┊48┊  },\n+┊  ┊49┊]\n```\n\n##### Changed index.ts\n```diff\n@@ -1,4 +1,5 @@\n ┊1┊1┊import express from 'express'\n+┊ ┊2┊import { chats } from './db'\n ┊2┊3┊\n ┊3┊4┊const app = express()\n ┊4┊5┊\n```\n```diff\n@@ -6,6 +7,10 @@\n ┊ 6┊ 7┊  res.send('pong')\n ┊ 7┊ 8┊})\n ┊ 8┊ 9┊\n+┊  ┊10┊app.get('/chats', (req, res) => {\n+┊  ┊11┊  res.json(chats)\n+┊  ┊12┊})\n+┊  ┊13┊\n ┊ 9┊14┊const port = process.env.PORT || 4000\n ┊10┊15┊\n ┊11┊16┊app.listen(port, () => {\n```\n\n[}]: #\n\nUnlike the previous route, we used the `.json()` method this time around to send a response. This will simply stringify the given JSON and set the right headers. Similarly to the client, we've defined the db mock in a dedicated file, as this is easier to maintain and look at.\n\nIt's also recommended to connect a middleware called [`cors`](https://www.npmjs.com/package/cors) which will enable cross-origin requests. Without it we will only be able to make requests in localhost, something which is likely to limit us in the future because we would probably host our server somewhere separate than the client application. Let's install the `cors` library and load it with the Express `middleware()` function:\n\n    $ npm install cors\n\n[{]: <helper> (diffStep \"1.4\" files=\"index.ts\" module=\"server\")\n\n#### Step 1.4: Create GET /chats route\n\n##### Changed index.ts\n```diff\n@@ -1,4 +1,5 @@\n ┊1┊1┊import express from 'express'\n+┊ ┊2┊import { chats } from './db'\n ┊2┊3┊\n ┊3┊4┊const app = express()\n ┊4┊5┊\n```\n```diff\n@@ -6,6 +7,10 @@\n ┊ 6┊ 7┊  res.send('pong')\n ┊ 7┊ 8┊})\n ┊ 8┊ 9┊\n+┊  ┊10┊app.get('/chats', (req, res) => {\n+┊  ┊11┊  res.json(chats)\n+┊  ┊12┊})\n+┊  ┊13┊\n ┊ 9┊14┊const port = process.env.PORT || 4000\n ┊10┊15┊\n ┊11┊16┊app.listen(port, () => {\n```\n\n[}]: #\n\nThe server is now ready to use! So getting back to the client, first we will define our server's URL under the `.env` file:\n\n[{]: <helper> (diffStep \"3.1\" module=\"client\")\n\n#### [Step 3.1: Define server URL](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/58ec4cf)\n\n##### Added .env\n```diff\n@@ -0,0 +1 @@\n+┊ ┊1┊REACT_APP_SERVER_URL=http://localhost:4000🚫↵\n```\n\n[}]: #\n\nThis will make our server's URL available under the `process.env.REACT_APP_SERVER_URL` member expression and it will be replaced with a fixed value at build time, just like macros. The `.env` file is a file which will automatically be loaded to `process.env` by the [`dotenv`](https://www.npmjs.com/package/dotenv) NPM package. `react-scripts` then filters environment variables which have a `REACT_APP_` prefix and provides the created JSON to a Webpack plugin called [DefinePlugin](https://webpack.js.org/plugins/define-plugin/), which will result in the macro effect.\n\nNow let's move back into our React app folder. We will now replace the local data-mock usage with a fetch from the server. For that we can use the native [fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API), however, it needs to be used in the right life-cycle hook of the React.Component.\n\nThere are 2 naive approaches for that:\n\n- Calling `fetch()` outside the component, but this way that chats will be fetched even if we're not even intending to create an instance of the component.\n\n```js\nfetch().then(() => /* ... */)\nconst MyComponent = () => {}\n```\n\n- Calling `fetch()` inside the component, but then it will be invoked whenever the component is re-rendered.\n\n```js\nconst MyComponent = () => {\n  fetch().then(() => /* ... */)\n}\n```\n\nThese 2 approaches indeed work, but they both fail to deliver what's necessary on the right time. In addition, there's no way to properly coordinate async function calls with the render method of the component.\n\n**Introducing: React hooks**\n\nWith React hooks we can invoke the desired logic in the right life-cycle stage of the target component. This way we can avoid potential memory leaks or extra calculations. To implement a proper `fetch()`, we will be using 2 React hooks:\n\n- [`React.useState()`](https://reactjs.org/docs/hooks-reference.html#usestate) - which is used to get and set a state of the component - will be used to store the fetch chats.\n\n```js\nconst [value, setValue] = useState(initialValue)\n```\n\n- [`React.useMemo()`](https://reactjs.org/docs/hooks-reference.html#usememo) - which is used to run a computation only once certain conditions were met - will be used to run the `fetch()` function only once the component has mounted.\n\n```js\nconst memoizedValue = useMemo(calcFn, [cond1, cond2, ...conds])\n```\n\nThe result of that approach will look like this, in the context of our ChatsList component:\n\n[{]: <helper> (diffStep \"3.2\" module=\"client\")\n\n#### [Step 3.2: Fetch chats using native fetch API](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/83f0684)\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;ChatsList.tsx\n```diff\n@@ -1,8 +1,8 @@\n ┊1┊1┊import { List, ListItem } from '@material-ui/core'\n ┊2┊2┊import moment from 'moment'\n ┊3┊3┊import * as React from 'react'\n+┊ ┊4┊import { useState, useMemo } from 'react'\n ┊4┊5┊import styled from 'styled-components'\n-┊5┊ ┊import { chats } from '../../db'\n ┊6┊6┊\n ┊7┊7┊const Container = styled.div `\n ┊8┊8┊  height: calc(100% - 56px);\n```\n```diff\n@@ -55,25 +55,35 @@\n ┊55┊55┊  font-size: 13px;\n ┊56┊56┊`\n ┊57┊57┊\n-┊58┊  ┊const ChatsList = () => (\n-┊59┊  ┊  <Container>\n-┊60┊  ┊    <StyledList>\n-┊61┊  ┊      {chats.map((chat) => (\n-┊62┊  ┊        <StyledListItem key={chat.id} button>\n-┊63┊  ┊          <ChatPicture src={chat.picture} />\n-┊64┊  ┊          <ChatInfo>\n-┊65┊  ┊            <ChatName>{chat.name}</ChatName>\n-┊66┊  ┊            {chat.lastMessage && (\n-┊67┊  ┊              <React.Fragment>\n-┊68┊  ┊                <MessageContent>{chat.lastMessage.content}</MessageContent>\n-┊69┊  ┊                <MessageDate>{moment(chat.lastMessage.createdAt).format('HH:mm')}</MessageDate>\n-┊70┊  ┊              </React.Fragment>\n-┊71┊  ┊            )}\n-┊72┊  ┊          </ChatInfo>\n-┊73┊  ┊        </StyledListItem>\n-┊74┊  ┊      ))}\n-┊75┊  ┊    </StyledList>\n-┊76┊  ┊  </Container>\n-┊77┊  ┊)\n+┊  ┊58┊const ChatsList = () => {\n+┊  ┊59┊  const [chats, setChats] = useState([])\n+┊  ┊60┊\n+┊  ┊61┊  useMemo(async () => {\n+┊  ┊62┊    const body = await fetch(`${process.env.REACT_APP_SERVER_URL}/chats`)\n+┊  ┊63┊    const chats = await body.json()\n+┊  ┊64┊    setChats(chats)\n+┊  ┊65┊  }, [true])\n+┊  ┊66┊\n+┊  ┊67┊  return (\n+┊  ┊68┊    <Container>\n+┊  ┊69┊      <StyledList>\n+┊  ┊70┊        {chats.map((chat) => (\n+┊  ┊71┊          <StyledListItem key={chat.id} button>\n+┊  ┊72┊            <ChatPicture src={chat.picture} />\n+┊  ┊73┊            <ChatInfo>\n+┊  ┊74┊              <ChatName>{chat.name}</ChatName>\n+┊  ┊75┊              {chat.lastMessage && (\n+┊  ┊76┊                <React.Fragment>\n+┊  ┊77┊                  <MessageContent>{chat.lastMessage.content}</MessageContent>\n+┊  ┊78┊                  <MessageDate>{moment(chat.lastMessage.createdAt).format('HH:mm')}</MessageDate>\n+┊  ┊79┊                </React.Fragment>\n+┊  ┊80┊              )}\n+┊  ┊81┊            </ChatInfo>\n+┊  ┊82┊          </StyledListItem>\n+┊  ┊83┊        ))}\n+┊  ┊84┊      </StyledList>\n+┊  ┊85┊    </Container>\n+┊  ┊86┊  )\n+┊  ┊87┊}\n ┊78┊88┊\n ┊79┊89┊export default ChatsList\n```\n\n[}]: #\n\n> It's recommended to read about React hooks and their basic concept at the [official React docs page](https://reactjs.org/docs/hooks-overview.html).\n\nAt this point we can get rid of `db.ts` file in the client, since we don't use it anymore:\n\n    $ rm src/db.ts\n\nThat's it. Our ChatsListScreen is now connected to a working back-end. In the next step we will upgrade our REST API into a GraphQL API and we will create a basis for a more robust back-end."
          },
          {
            "manualTitle": "Step 4: Transition to GraphQL",
            "stepRevision": "397dc3b328ff76af781d7fdd866ae1c71b1021cb",
            "manualView": "**What is GraphQL?**\n\n[GraphQL](https://graphql.org/) is a query language invented by Facebook, and it's used to query data within our API. It allows clients to define the structure of the data required, and the exact same structure of data will be returned from the server, therefore preventing excessively large amounts of data from being returned. Unlike REST, GraphQL APIs are organized in terms of types and fields, not endpoints.\n\nCurrently in our app, if we'd like to get its chats we would send a GET request to `/chats`. With GraphQL it would be done differently with a string that describes the data that we would like to get:\n\n```graphql\nchats {\n  id\n  name\n  picture\n  lastMessage {\n    id\n    content\n    createdAt\n  }\n}\n```\n\n> Above: An illustration of a potential GraphQL query sent to our Whatsapp API\n\n**Why GraphQL and not REST?**\n\nIn terms of experience REST got the upper hand. It has been used for many more years and has proven itself to work well, and it's completely agnostic to the implementation of the back-end. However, when it comes to data projection and aggregation, it fails to deliver.\n\nWhen using REST, often times you'll find yourself performing multiple requests to execute a single query of data. Not only that, you might even end up with additional data that is not necessary. Either way, the process would result in slower and heavier response.\n\nWith GraphQL we don't have that kind of problem. Queries may take many shapes and forms, and since GraphQL is schema based - it can handle it. You'll get exactly what you asked for with a single request. **GraphQL provides a dynamic API while REST doesn't.**\n\n```graphql\n# request\nquery {\n  chat(id: 1) {\n    id\n    name\n    lastMessage {\n      id\n      content\n    }\n  }\n}\n```\n\n![graphql-request](https://user-images.githubusercontent.com/7648874/54133620-5aec8300-4451-11e9-9bda-a459dc48f57c.png)\n\n```js\n// response\n{\n  \"data\": {\n    \"chat\": {\n      \"id\": 1,\n      \"name\": \"Ethan Gonzalez\",\n      \"lastMessage\": {\n        \"id\": 1,\n        \"content\": \"You on your way?\"\n      }\n    }\n  }\n}\n```\n\n**GraphQL schema, in a nutshell**\n\nLike said earlier,  GraphQL APIs are organized in terms of types and fields. That means that our app data should be described with a schema, where each field's gonna have a resolver - the handler that will return the corresponding data. Things will be much clearer as we move further.\n\nLet's try to describe our app's data with a GraphQL schema and then dive into it:\n\n```graphql\nscalar Date\n\ntype Message {\n  id: ID!\n  content: String!\n  createdAt: Date!\n}\n\ntype Chat {\n  id: ID!\n  name: String!\n  picture: String\n  lastMessage: Message\n}\n\ntype Query {\n  chats: [Chat!]!\n}\n```\n\nThe schema is self explanatory in terms of what data it's compatible with. Supported built-in scalar types in GraphQL are:\n\n- Int: Signed 32‐bit integer\n- Float: Signed double-precision floating-point value\n- String: UTF‐8 character sequence\n- Boolean: true or false\n- ID (serialized as String): A unique identifier, often used to refetch an object or as the key for a cache. While serialized as a String, ID signifies that it is not intended to be human‐readable\n\nAny custom scalar can be declared with the `scalar` keyword, and custom types can be declared with the `type` keyword. However, you should know that some types are reserved by GraphQL itself; `Query` is one of them. The `Query` type will be used as the root for received queries by the clients, which means that we can send queries which start with the `chats` field. Other reserved types are:\n\n- `type Query` - reserved for [GraphQL queries](https://graphql.org/learn/queries/#mutations).\n- `type Mutation` - reserved for [GraphQL mutations.](https://graphql.github.io/learn/queries/)\n- `type Subscription` - reserved for [GraphQL subscriptions.](https://www.apollographql.com/docs/react/advanced/subscriptions.html)\n\n> As we're not gonna go through the entire GraphQL API, it's recommended to go through the [official learn section of the GraphQL website](https://graphql.org/learn/), but the information so far will definitely help you kick-start, plus the upcoming implementation.\n\n**Getting started**\n\nWe will be implementing a GraphQL mechanism for the client and for the server. We will start with the server as things will make more sense, and we will be able to test it before we proceed into the client. Essentially GraphQL is connected into a HTTP endpoint, usually under `POST /graphql`, and so this is exactly what we're gonna do, connect the endpoint handler. Luckily, we don't have to implement that. A team called [Apollo](https://www.apollographql.com/) already did it for us, so we can use their implementation. We will install the required packages:\n\n    $ npm install apollo-server-express body-parser graphql\n    $ npm install --dev @types/body-parser @types/graphql\n\n- [`graphql`](https://www.npmjs.com/package/graphql) - The core package of GraphQL that includes the resolvers for basic data-types.\n- [`apollo-server-express`](https://www.npmjs.com/package/apollo-server-express) - Apollo's implementation for the GraphQL Express REST endpoint.\n- [`body-parser`](https://www.npmjs.com/package/body-parser) - Parse incoming request bodies in a middleware before your handlers, available under the req.body property.\n- `@types/…` - TypeScript definitions\n\nWe can now connect Apollo's middleware under the `/graphql` route:\n\n[{]: <helper> (diffStep \"2.1\" files=\"index.ts\" module=\"server\")\n\n#### Step 2.1: Setup Apollo GraphQL\n\n##### Changed index.ts\n```diff\n@@ -1,10 +1,14 @@\n+┊  ┊ 1┊import { ApolloServer, gql } from 'apollo-server-express'\n+┊  ┊ 2┊import bodyParser from 'body-parser'\n ┊ 1┊ 3┊import cors from 'cors'\n ┊ 2┊ 4┊import express from 'express'\n ┊ 3┊ 5┊import { chats } from './db'\n+┊  ┊ 6┊import schema from './schema'\n ┊ 4┊ 7┊\n ┊ 5┊ 8┊const app = express()\n ┊ 6┊ 9┊\n ┊ 7┊10┊app.use(cors())\n+┊  ┊11┊app.use(bodyParser.json())\n ┊ 8┊12┊\n ┊ 9┊13┊app.get('/_ping', (req, res) => {\n ┊10┊14┊  res.send('pong')\n```\n```diff\n@@ -14,6 +18,13 @@\n ┊14┊18┊  res.json(chats)\n ┊15┊19┊})\n ┊16┊20┊\n+┊  ┊21┊const server = new ApolloServer({ schema })\n+┊  ┊22┊\n+┊  ┊23┊server.applyMiddleware({\n+┊  ┊24┊  app,\n+┊  ┊25┊  path: '/graphql',\n+┊  ┊26┊})\n+┊  ┊27┊\n ┊17┊28┊const port = process.env.PORT || 4000\n ┊18┊29┊\n ┊19┊30┊app.listen(port, () => {\n```\n\n[}]: #\n\nAs you can see, the middleware requires a schema. A schema is composed mainly out of 2 fields:\n\n- `typeDefs` (type definitions) - the schema types we wrote earlier this chapter for chats.\n- `resolvers` - The handlers that will provide the data for each field in `typeDefs`.\n\nWe will start first by defining the types. All we have to do is to copy-paste the contents of the schema that was shown earlier into a new file called `typeDefs.graphql`:\n\n[{]: <helper> (diffStep \"2.2\" files=\"typeDefs.graphql\" module=\"server\")\n\n#### Step 2.2: Create a basic GraphQL schema\n\n##### Added schema&#x2F;typeDefs.graphql\n```diff\n@@ -0,0 +1,18 @@\n+┊  ┊ 1┊scalar Date\n+┊  ┊ 2┊\n+┊  ┊ 3┊type Message {\n+┊  ┊ 4┊  id: ID!\n+┊  ┊ 5┊  content: String!\n+┊  ┊ 6┊  createdAt: Date!\n+┊  ┊ 7┊}\n+┊  ┊ 8┊\n+┊  ┊ 9┊type Chat {\n+┊  ┊10┊  id: ID!\n+┊  ┊11┊  name: String!\n+┊  ┊12┊  picture: String\n+┊  ┊13┊  lastMessage: Message\n+┊  ┊14┊}\n+┊  ┊15┊\n+┊  ┊16┊type Query {\n+┊  ┊17┊  chats: [Chat!]!\n+┊  ┊18┊}\n```\n\n[}]: #\n\nThe `.graphql` file extension is just a more convenient way to work with a GraphQL schema. The exported result should be a simple string that we can use to compose our GraphQL schema. The clear advantage of working with a dedicated file is that we get to have syntax highlight.\n\nNow we will implement the resolvers. Resolvers are presented in a JSON object where each resolver name should match the field name it represents. You can read more about resolvers in [Apollo's official docs for resolvers](https://www.apollographql.com/docs/tutorial/resolvers.html). This is how our resolvers should look like:\n\n[{]: <helper> (diffStep \"2.2\" files=\"resolvers.ts\" module=\"server\")\n\n#### Step 2.2: Create a basic GraphQL schema\n\n##### Added schema&#x2F;resolvers.ts\n```diff\n@@ -0,0 +1,12 @@\n+┊  ┊ 1┊import { GraphQLDateTime } from 'graphql-iso-date'\n+┊  ┊ 2┊import { chats } from '../db'\n+┊  ┊ 3┊\n+┊  ┊ 4┊export default {\n+┊  ┊ 5┊  Date: GraphQLDateTime,\n+┊  ┊ 6┊\n+┊  ┊ 7┊  Query: {\n+┊  ┊ 8┊    chats() {\n+┊  ┊ 9┊      return chats\n+┊  ┊10┊    },\n+┊  ┊11┊  },\n+┊  ┊12┊}\n```\n\n[}]: #\n\nFor now it's extremely simple, we map the chats query directly into the database collection. Each field in the resolvers object should match the GraphQL type it represents in the schema. Since we don't have any logic now, we should not implement any resolvers for the rest of the types, the data will simply be forwarded as is.\n\nNote that we've implemented a custom scalar named `Date` and we resolved it with an NPM package. Let's install it:\n\n    $ npm install graphql-iso-date\n    $ npm install --dev @types/graphql-iso-date\n\nFinal thing that we have to do would be combining the resolvers and the type-defs under a single GraphQL schema.\n\n[{]: <helper> (diffStep \"2.2\" files=\"index.ts\" module=\"server\")\n\n#### Step 2.2: Create a basic GraphQL schema\n\n##### Added schema&#x2F;index.ts\n```diff\n@@ -0,0 +1,7 @@\n+┊ ┊1┊import { importSchema } from 'graphql-import'\n+┊ ┊2┊import { makeExecutableSchema } from 'graphql-tools'\n+┊ ┊3┊import resolvers from './resolvers'\n+┊ ┊4┊\n+┊ ┊5┊const typeDefs = importSchema('schema/typeDefs.graphql')\n+┊ ┊6┊\n+┊ ┊7┊export default makeExecutableSchema({ resolvers, typeDefs })\n```\n\n[}]: #\n\n[`graphql-import`](https://www.npmjs.com/package/graphql-import) and [`graphql-tools`](https://www.npmjs.com/package/graphql-tools) are utility packages that will help us create a schema that will be compatible with Apollo's API. Let's install them:\n\n    $ npm install graphql-import graphql-tools\n\nThere's one optimization however that we should make in the our DB. Right now, the each chat document has a direct reference to a message via the `lastMessage` field. Practically speaking, this is NOT how the data sits in the DB. The `lastMessage` should only hold the ID for the correlated message, and then in the Node.JS app we should **resolve** it according to our needs. Let's make the appropriate changes in the DB then:\n\n[{]: <helper> (diffStep \"2.3\" files=\"db.ts\" module=\"server\")\n\n#### Step 2.3: Resolve Chat.lastMessage\n\n\n\n[}]: #\n\nAnd a resolver to the `lastMessage` field:\n\n[{]: <helper> (diffStep \"2.3\" files=\"typeDefs.graphql\" module=\"server\")\n\n#### Step 2.3: Resolve Chat.lastMessage\n\n\n\n[}]: #\n\nThe first argument of the resolver is the raw chat data received by the DB, and the returned result should be the mapped value which we would like to return to the client.\n\nAs we get further in this tutorial we should get a better grasp regards resolvers and their API, since we will have to deal with more logic and complexity within our Node.JS app.\n\nAssuming that the server is running, we can already test our GraphQL endpoint. Because it's exposed to us via a REST endpoint, we can use a `$ curl` command to send a request to `GET localhost:4000/graphql` and get a response with all the data. Again, the query that we're gonna use to fetch the chats is:\n\n```graphql\nchats {\n  id\n  name\n  picture\n  lastMessage {\n    id\n    content\n    createdAt\n  }\n}\n```\n\nThe one-liner version of it with a `$ curl` command looks like so:\n\n    curl \\\n      -X POST \\\n      -H \"Content-Type: application/json\" \\\n      --data '{ \"query\": \"{ chats { id name picture lastMessage { id content createdAt } } }\" }' \\\n      localhost:4000/graphql\n\nAs a response we should get the data-mock for our chats stored in the server. Since we have that in place, we can go ahead and delete our implementation for the `GET /chats` route.\n\nSo getting back to the client, all we have to do is to change the fetching URL in the ChatsList component to use our newly implemented GraphQL REST endpoint:\n\n[{]: <helper> (diffStep \"4.1\" module=\"client\")\n\n#### [Step 4.1: Replace REST call with GraphQL call](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/7d359a7)\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;ChatsList.tsx\n```diff\n@@ -55,12 +55,33 @@\n ┊55┊55┊  font-size: 13px;\n ┊56┊56┊`\n ┊57┊57┊\n+┊  ┊58┊const getChatsQuery = `\n+┊  ┊59┊  query GetChats {\n+┊  ┊60┊    chats {\n+┊  ┊61┊      id\n+┊  ┊62┊      name\n+┊  ┊63┊      picture\n+┊  ┊64┊      lastMessage {\n+┊  ┊65┊        id\n+┊  ┊66┊        content\n+┊  ┊67┊        createdAt\n+┊  ┊68┊      }\n+┊  ┊69┊    }\n+┊  ┊70┊  }\n+┊  ┊71┊`\n+┊  ┊72┊\n ┊58┊73┊const ChatsList = () => {\n ┊59┊74┊  const [chats, setChats] = useState([])\n ┊60┊75┊\n ┊61┊76┊  useMemo(async () => {\n-┊62┊  ┊    const body = await fetch(`${process.env.REACT_APP_SERVER_URL}/chats`)\n-┊63┊  ┊    const chats = await body.json()\n+┊  ┊77┊    const body = await fetch(`${process.env.REACT_APP_SERVER_URL}/graphql`, {\n+┊  ┊78┊      method: 'POST',\n+┊  ┊79┊      headers: {\n+┊  ┊80┊        'Content-Type': 'application/json',\n+┊  ┊81┊      },\n+┊  ┊82┊      body: JSON.stringify({ query: getChatsQuery }),\n+┊  ┊83┊    })\n+┊  ┊84┊    const { data: { chats } } = await body.json()\n ┊64┊85┊    setChats(chats)\n ┊65┊86┊  }, [true])\n```\n\n[}]: #\n\nThe received data should be similar to the previous one. No further changes are required. In the next chapter, we will continue working on the UI of our front-end application and we will add a new screen to the flow - the `ChatRoomScreen`."
          },
          {
            "manualTitle": "Step 5: Testing",
            "stepRevision": "6f684adb4d1c1b487e4a1cfba6d9f400f25e2bde",
            "manualView": "Testing is a crucial part when writing an application, especially if we're planning to publish it or make it a commercial thing. Before we hand someone a product, of any kind, we wanna make sure that it passes certain quality checks. We're signed on that product and so it's very important to ensure that it functions properly according our expectations, otherwise wouldn't wanna use it and will look for alternatives.\n\nIn the context of software, we constantly make changes. It's also inevitable to make all features completely independent from one another, so something in the app is likely to break as we upgrade it or maintain it. That's why we need to write a set of tests that can be run on demand, so when we implement a new feature we can simply run the tests and see what feature broke due to most recent changes.\n\nThere are currently 3 main testing frameworks in the NPM ecosystem: [Jasmine](https://jasmine.github.io/), [Mocha](https://mochajs.org/), and [Jest](https://jestjs.io/). Each testing framework has its pros, and cons, and at the end of the day it's a matter of preference. In our application we're gonna use [Jest](https://jestjs.io/) - a testing framework which was developed by Facebook. What's good about Jest is that it can be used to test both client and server logic, because it runs as a Node.JS application, but it also emulates the browser environment whenever we run it, thanks to [JSDOM](https://github.com/jsdom/jsdom).\n\n![jest](https://user-images.githubusercontent.com/7648874/54493900-e2ce0380-490f-11e9-8075-be4a236c7c38.png)\n\nIn this chapter we will learn how to test the React.Components in the client, and Apollo-GraphQL resolvers in the server. There are 3 kinds of tests:\n\n- Unit tests - which are used to test a single component, independently from other components in our system.\n- Integration tests - which are used to test a component in relation to other components in our systems (how well do they co-work with each other).\n- e2e tests (end to end) - which are used to test a complete, from the moment I clicked on a button in the user interface until the data gets back from the server and shown on the screen.\n\nThe efficiency of the tests go from bottom to top (unit -> e2e), but the maintenance and complexity go from bottom to top (e2e -> unit). Accordingly we will need to find a good balance where we don’t spend too much time on writing tests yet have a good indicator for how well our system functions. So we should write a lot of unit tests, a good amount of integration tests and a handful of e2e tests.\n\n![tests-types-table](https://user-images.githubusercontent.com/7648874/54494121-fed2a480-4911-11e9-9370-694ec989729b.png)\n\nWe will start with the client as it’s much easier, because Jest is set and ready to use right out of the box thanks to `create-react-app`.\n\n**Client - Testing React.Components**\n\nThanks to `create-react-app`, we have Jest set and ready to use right out of the box, so we can start writing tests right away. I you'll look at the `src` you'll see a file called `App.test.tsx`, which simply ensures that the component can be rendered without crashing.\n\n```jsx\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nit('renders without crashing', () => {\n  const div = document.createElement('div');\n  ReactDOM.render(<App />, div);\n  ReactDOM.unmountComponentAtNode(div);\n});\n```\n\nThis is not a typical test that you're likely to find in a React project, but it demonstrates very well how Jest can be used to test DOM related issues. If you'll run `$ npm run test` (or `$ yarn test`) in the command line and then press `a`, you should see the following output:\n\n![report](https://user-images.githubusercontent.com/7648874/54341429-eabe4700-4674-11e9-8e76-3aaaf7fec79a.png)\n\nJest will automatically run for every file that ends with a `.test.xxx` extension. This is very convenient because the tests can live right next to the component, and you don't need to lookup for it across the project. This behavior can be modified by configuring Jest in the `package.json` file under the `\"jest\"` field. More information about configuring Jest can be found in the official[ configuration documentation](https://jestjs.io/docs/en/configuration).\n\n> If you get a warning message regards wrapping the component with `act()` - this is a known issue with hooks and should have a proper solution soon. More about this issue and progress regards its fix can be found in this [GitHub thread](https://github.com/facebook/react/issues/14769#issuecomment-470097212).\n\nNow we're gonna write a basic test for the `<ChatsList />` component. In the test, we'll mock a fake response from the server, and examine the contents of rendered HTML. Since the HTML of the component is a dynamic thing and is constantly subject to changes, it would be a good idea to annotate it with `data-testid` attributes so it can be tested regardless of its structure:\n\n[{]: <helper> (diffStep \"5.1\" files=\"ChatsList.tsx\" module=\"client\")\n\n#### [Step 5.1: Add data-testid attributes](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/6c641f2)\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;ChatsList.tsx\n```diff\n@@ -90,13 +90,13 @@\n ┊ 90┊ 90┊      <StyledList>\n ┊ 91┊ 91┊        {chats.map((chat) => (\n ┊ 92┊ 92┊          <StyledListItem key={chat.id} button>\n-┊ 93┊   ┊            <ChatPicture src={chat.picture} />\n+┊   ┊ 93┊            <ChatPicture data-testid=\"picture\" src={chat.picture} />\n ┊ 94┊ 94┊            <ChatInfo>\n-┊ 95┊   ┊              <ChatName>{chat.name}</ChatName>\n+┊   ┊ 95┊              <ChatName data-testid=\"name\">{chat.name}</ChatName>\n ┊ 96┊ 96┊              {chat.lastMessage && (\n ┊ 97┊ 97┊                <React.Fragment>\n-┊ 98┊   ┊                  <MessageContent>{chat.lastMessage.content}</MessageContent>\n-┊ 99┊   ┊                  <MessageDate>{moment(chat.lastMessage.createdAt).format('HH:mm')}</MessageDate>\n+┊   ┊ 98┊                  <MessageContent data-testid=\"content\">{chat.lastMessage.content}</MessageContent>\n+┊   ┊ 99┊                  <MessageDate data-testid=\"date\">{moment(chat.lastMessage.createdAt).format('HH:mm')}</MessageDate>\n ┊100┊100┊                </React.Fragment>\n ┊101┊101┊              )}\n ┊102┊102┊            </ChatInfo>\n```\n\n[}]: #\n\nNow we can select various HTML elements with a query selector when we test the component. We will install a couple of packages that will assist us in implementing the test:\n\n  $ npm install jest-fetch-mock jest-dom react-testing-library\n\n- The [`jest-fetch-mock`](https://www.npmjs.com/package/jest-fetch-mock) package can mock responses emitted by the Fetch API.\n- The [`jest-dom`](https://www.npmjs.com/package/jsdom) package will add custom matchers that will help us examine HTML contents of DOM elements.\n- The [`react-testing-library`](https://www.npmjs.com/package/react-testing-library) package contains utility methods that will help us test React.Components with Jest.\n\nNext, we will create a file under the `src` folder called `setupTests.ts`. This file is loaded configured automatically by `create-react-app` and loaded by Jest, and we can use it to set up our testing environment according to our needs (like said earlier, Jest can be configured, so this file path can be changed). We will use that file to define a fake Fetch API using the `jest-fetch-mock` library:\n\n[{]: <helper> (diffStep \"5.2\" files=\"src/setupTests.ts\" module=\"client\")\n\n#### [Step 5.2: Setup tests](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/820450b)\n\n##### Added src&#x2F;setupTests.ts\n```diff\n@@ -0,0 +1,7 @@\n+┊ ┊1┊import 'jest-dom/extend-expect'\n+┊ ┊2┊import { GlobalWithFetchMock } from 'jest-fetch-mock'\n+┊ ┊3┊import { act } from 'react-testing-library'\n+┊ ┊4┊\n+┊ ┊5┊const customGlobal: GlobalWithFetchMock = global as GlobalWithFetchMock\n+┊ ┊6┊customGlobal.fetch = require('jest-fetch-mock')\n+┊ ┊7┊customGlobal.fetchMock = customGlobal.fetch\n```\n\n[}]: #\n\nWe will create another file called `ChatsList.test.tsx`, right next to the `<ChatsList />` component under the `ChatsListScreen` directory, and inside we will implement our test. The test should follow these steps:\n\n- Mock the response to contain a fake chat, so we won't need to make an actual call to our GraphQL API.\n- We will create a new instance of `<ChatsList />` and render it in a container element.\n- We will wait for changes in the DOM caused by `setState()`.\n- We will test the contents of the container.\n\nAnd this is how the implementation should look like:\n\n[{]: <helper> (diffStep \"5.3\" files=\"src/components/ChatsListScreen/ChatsList.test.tsx\" module=\"client\")\n\n#### [Step 5.3: Test ChatsList](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/3f07a20)\n\n##### Added src&#x2F;components&#x2F;ChatsListScreen&#x2F;ChatsList.test.tsx\n```diff\n@@ -0,0 +1,38 @@\n+┊  ┊ 1┊import React from 'react'\n+┊  ┊ 2┊import ReactDOM from 'react-dom'\n+┊  ┊ 3┊import { cleanup, render, waitForDomChange } from 'react-testing-library'\n+┊  ┊ 4┊import ChatsList from './ChatsList'\n+┊  ┊ 5┊\n+┊  ┊ 6┊describe('ChatsList', () => {\n+┊  ┊ 7┊  afterEach(cleanup)\n+┊  ┊ 8┊\n+┊  ┊ 9┊  it('renders fetched chats data', async () => {\n+┊  ┊10┊    fetch.mockResponseOnce(JSON.stringify({\n+┊  ┊11┊      data: {\n+┊  ┊12┊        chats: [\n+┊  ┊13┊          {\n+┊  ┊14┊            id: 1,\n+┊  ┊15┊            name: 'Foo Bar',\n+┊  ┊16┊            picture: 'https://localhost:4000/picture.jpg',\n+┊  ┊17┊            lastMessage: {\n+┊  ┊18┊              id: 1,\n+┊  ┊19┊              content: 'Hello',\n+┊  ┊20┊              createdAt: new Date(0),\n+┊  ┊21┊            },\n+┊  ┊22┊          },\n+┊  ┊23┊        ],\n+┊  ┊24┊      },\n+┊  ┊25┊    }))\n+┊  ┊26┊\n+┊  ┊27┊    {\n+┊  ┊28┊      const { container, getByTestId } = render(<ChatsList />)\n+┊  ┊29┊\n+┊  ┊30┊      await waitForDomChange({ container })\n+┊  ┊31┊\n+┊  ┊32┊      expect(getByTestId('name')).toHaveTextContent('Foo Bar')\n+┊  ┊33┊      expect(getByTestId('picture')).toHaveAttribute('src', 'https://localhost:4000/picture.jpg')\n+┊  ┊34┊      expect(getByTestId('content')).toHaveTextContent('Hello')\n+┊  ┊35┊      expect(getByTestId('date')).toHaveTextContent('08:00')\n+┊  ┊36┊    }\n+┊  ┊37┊  })\n+┊  ┊38┊})\n```\n\n[}]: #\n\n> Jest API is vast but pretty intuitive for the most part. It mostly consists of test descriptors and matchers. [Here's a full list of all matchers which are built into Jest's API](https://jestjs.io/docs/en/expect). Always make sure to work against it when writing tests, for optimal results.\n\nWe will now move on to testing the server where we will learn how to setup Jest manually and test it against a GraphQL API.\n\n**Server - Testing GraphQL resolvers**\n\nTo set-up Jest, we will run the following in the command line:\n\n    $ npm install jest @types/jest ts-jest --dev\n\nThis will basically install Jest and make it useable with TypeScript. In addition, we will need to specify the file pattern that we would like to transform with [`ts-jest`](https://www.npmjs.com/package/ts-jest), by adding the following section to `package.json`:\n\n```\n{\n  \"jest\": {\n    \"transform\": {\n      \"^.+\\\\.(js|jsx|ts|tsx)$\": \"<rootDir>/node_modules/ts-jest\"\n    }\n  }\n}\n```\n\nWe will also add a `\"test\"` script in the `package.json` file, so we can run the tests with `$ npm run test` (or `$ yarn test`):\n\n```\n{\n  \"scripts\": {\n    \"test\": \"jest\"\n  }\n}\n```\n\nThis is how our `package.json` should look like at this point:\n\n[{]: <helper> (diffStep \"3.1\" files=\"package.json\" module=\"server\")\n\n#### Step 3.1: Install and configure Jest\n\n##### Changed package.json\n```diff\n@@ -3,7 +3,8 @@\n ┊ 3┊ 3┊  \"description\": \"A newly created Tortilla project\",\n ┊ 4┊ 4┊  \"private\": true,\n ┊ 5┊ 5┊  \"scripts\": {\n-┊ 6┊  ┊    \"start\": \"ts-node index.ts\"\n+┊  ┊ 6┊    \"start\": \"ts-node index.ts\",\n+┊  ┊ 7┊    \"test\": \"jest\"\n ┊ 7┊ 8┊  },\n ┊ 8┊ 9┊  \"devDependencies\": {\n ┊ 9┊10┊    \"@types/body-parser\": \"1.17.0\",\n```\n```diff\n@@ -11,7 +12,10 @@\n ┊11┊12┊    \"@types/express\": \"4.16.1\",\n ┊12┊13┊    \"@types/graphql\": \"14.0.7\",\n ┊13┊14┊    \"@types/graphql-iso-date\": \"3.3.1\",\n+┊  ┊15┊    \"@types/jest\": \"24.0.11\",\n ┊14┊16┊    \"@types/node\": \"11.11.0\",\n+┊  ┊17┊    \"ts-jest\": \"24.0.0\",\n+┊  ┊18┊    \"jest\": \"24.5.0\",\n ┊15┊19┊    \"ts-node\": \"8.0.3\",\n ┊16┊20┊    \"typescript\": \"3.3.3333\"\n ┊17┊21┊  },\n```\n```diff\n@@ -24,5 +28,10 @@\n ┊24┊28┊    \"graphql-import\": \"0.7.1\",\n ┊25┊29┊    \"graphql-iso-date\": \"3.6.1\",\n ┊26┊30┊    \"graphql-tools\": \"4.0.4\"\n+┊  ┊31┊  },\n+┊  ┊32┊  \"jest\": {\n+┊  ┊33┊    \"transform\": {\n+┊  ┊34┊      \"^.+\\\\.(js|jsx|ts|tsx)$\": \"<rootDir>/node_modules/ts-jest\"\n+┊  ┊35┊    }\n ┊27┊36┊  }\n ┊28┊37┊}\n```\n\n[}]: #\n\nNow we're gonna test the `chats` query in our GraphQL schema. To do so, we will setup an Apollo Client and send a query request to our back-end, and then we will match the received response with a pre-defined snapshot. Luckily, we don't have to set an actual client, since the tests and the implementation of the back-end live right next to each other, thus, we will install a package which will help us achieving so:\n\n    $ npm install apollo-server-testing --dev\n\nWe will define the test suite under the `tests/queries` folder in a file called `getChats.test.ts`:\n\n[{]: <helper> (diffStep \"3.2\" files=\"tests/queries/getChats.test.ts\" module=\"server\")\n\n#### Step 3.2: Test Query.chats\n\n##### Added tests&#x2F;queries&#x2F;getChats.test.ts\n```diff\n@@ -0,0 +1,32 @@\n+┊  ┊ 1┊import { createTestClient } from 'apollo-server-testing'\n+┊  ┊ 2┊import { ApolloServer, gql } from 'apollo-server-express'\n+┊  ┊ 3┊import schema from '../../schema'\n+┊  ┊ 4┊\n+┊  ┊ 5┊describe('Query.chats', () => {\n+┊  ┊ 6┊  it('should fetch all chats', async () => {\n+┊  ┊ 7┊    const server = new ApolloServer({ schema })\n+┊  ┊ 8┊\n+┊  ┊ 9┊    const { query } = createTestClient(server)\n+┊  ┊10┊\n+┊  ┊11┊    const res = await query({\n+┊  ┊12┊      query: gql `\n+┊  ┊13┊        query GetChats {\n+┊  ┊14┊          chats {\n+┊  ┊15┊            id\n+┊  ┊16┊            name\n+┊  ┊17┊            picture\n+┊  ┊18┊            lastMessage {\n+┊  ┊19┊              id\n+┊  ┊20┊              content\n+┊  ┊21┊              createdAt\n+┊  ┊22┊            }\n+┊  ┊23┊          }\n+┊  ┊24┊        }\n+┊  ┊25┊      `,\n+┊  ┊26┊    })\n+┊  ┊27┊\n+┊  ┊28┊    expect(res.data).toBeDefined()\n+┊  ┊29┊    expect(res.errors).toBeUndefined()\n+┊  ┊30┊    expect(res.data).toMatchSnapshot()\n+┊  ┊31┊  })\n+┊  ┊32┊})\n```\n\n[}]: #\n\nIn the test function, we create a new instance of the Apollo-GraphQL server using our schema, and we query some data against it thanks to the fake client created by [`apollo-server-testing`](https://www.npmjs.com/package/apollo-server-testing).\n\nThe `.toMatchSnapshot()` matcher will call the `toString()` method on the examined object and will test it against a predefined snapshot. The snapshot will automatically be created once we run the test for the first time and will be stored under the `__snapshot__` directory. This means that the first test run will always pass. This is useful because you can later on observe and adjust manually the snapshot manually without having to write it from scratch. The expected result should be a projection of the data stored in the `db.ts` file.\n\n[{]: <helper> (diffStep \"3.2\" files=\"tests/queries/__snapshots__\" module=\"server\")\n\n#### Step 3.2: Test Query.chats\n\n##### Added tests&#x2F;queries&#x2F;__snapshots__&#x2F;getChats.test.ts.snap\n```diff\n@@ -0,0 +1,48 @@\n+┊  ┊ 1┊// Jest Snapshot v1, https://goo.gl/fbAQLP\n+┊  ┊ 2┊\n+┊  ┊ 3┊exports[`Query.chats should fetch all chats 1`] = `\n+┊  ┊ 4┊Object {\n+┊  ┊ 5┊  \"chats\": Array [\n+┊  ┊ 6┊    Object {\n+┊  ┊ 7┊      \"id\": \"1\",\n+┊  ┊ 8┊      \"lastMessage\": Object {\n+┊  ┊ 9┊        \"content\": \"You on your way?\",\n+┊  ┊10┊        \"createdAt\": \"2018-12-30T23:20:00.000Z\",\n+┊  ┊11┊        \"id\": \"1\",\n+┊  ┊12┊      },\n+┊  ┊13┊      \"name\": \"Ethan Gonzalez\",\n+┊  ┊14┊      \"picture\": \"https://randomuser.me/api/portraits/thumb/men/1.jpg\",\n+┊  ┊15┊    },\n+┊  ┊16┊    Object {\n+┊  ┊17┊      \"id\": \"2\",\n+┊  ┊18┊      \"lastMessage\": Object {\n+┊  ┊19┊        \"content\": \"Hey, it's me\",\n+┊  ┊20┊        \"createdAt\": \"2018-12-30T06:40:00.000Z\",\n+┊  ┊21┊        \"id\": \"2\",\n+┊  ┊22┊      },\n+┊  ┊23┊      \"name\": \"Bryan Wallace\",\n+┊  ┊24┊      \"picture\": \"https://randomuser.me/api/portraits/thumb/men/2.jpg\",\n+┊  ┊25┊    },\n+┊  ┊26┊    Object {\n+┊  ┊27┊      \"id\": \"3\",\n+┊  ┊28┊      \"lastMessage\": Object {\n+┊  ┊29┊        \"content\": \"I should buy a boat\",\n+┊  ┊30┊        \"createdAt\": \"2018-12-15T00:00:00.000Z\",\n+┊  ┊31┊        \"id\": \"3\",\n+┊  ┊32┊      },\n+┊  ┊33┊      \"name\": \"Avery Stewart\",\n+┊  ┊34┊      \"picture\": \"https://randomuser.me/api/portraits/thumb/women/1.jpg\",\n+┊  ┊35┊    },\n+┊  ┊36┊    Object {\n+┊  ┊37┊      \"id\": \"4\",\n+┊  ┊38┊      \"lastMessage\": Object {\n+┊  ┊39┊        \"content\": \"This is wicked good ice cream.\",\n+┊  ┊40┊        \"createdAt\": \"2018-05-12T08:00:00.000Z\",\n+┊  ┊41┊        \"id\": \"4\",\n+┊  ┊42┊      },\n+┊  ┊43┊      \"name\": \"Katie Peterson\",\n+┊  ┊44┊      \"picture\": \"https://randomuser.me/api/portraits/thumb/women/2.jpg\",\n+┊  ┊45┊    },\n+┊  ┊46┊  ],\n+┊  ┊47┊}\n+┊  ┊48┊`;\n```\n\n[}]: #\n\nAlways be sure to observe the snapshot before moving on! The received result isn't necessarily what you'd expect. Also it's not a good practice to store production data in the snapshot because it's subject to changes. Normally we would set up another instance of the DB for testing purposes, but since our DB is a mock and doesn't represent real data, there's no need to at this stage.\n\nNow that we have the required knowledge regards testing and Jest's API, we will implement tests throughout the tutorial as a trivial thing. We will not go through each and every new matcher that we introduce, as it is self explanatory and there's too much of them. Be sure to work against [this full list of matchers](https://jestjs.io/docs/en/expect) when working with Jest.\n\nIn the next chapter we will continue expanding our application by adding a `<ChatRoomScreen />`."
          },
          {
            "manualTitle": "Step 6: Creating an app router and implementing a chat room",
            "stepRevision": "8222f75b834bf0bf512175f5ae0bddf4ea72fdab",
            "manualView": "In this chapter we will learn how to build a chat room screen. We will setup a router, implement the necessary components, and update the state whenever we send a new message. The screen is NOT gonna be connected to the back-end as it will over complicate things for now. Further this tutorial, we will get to make it full-stack.\n\nSince we're gonna have to screens in our app now - `ChatsListScreen` and `ChatRoomScreen`, we will need a router that will be able to alternate between them. We will be using the [`react-router-dom`](https://www.npmjs.com/package/react-router-dom) package to manage the routes of the application:\n\n  $ npm install react-router-dom\n\nAnd we will implement a router directly in the `<App />` component:\n\n[{]: <helper> (diffStep 6.1 files=\"App\" module=\"client\")\n\n#### [Step 6.1: Add router](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/9dc0639)\n\n##### Changed src&#x2F;App.jsx\n```diff\n@@ -1,10 +1,20 @@\n ┊ 1┊ 1┊import * as React from 'react'\n+┊  ┊ 2┊import { BrowserRouter, Route, Redirect, Switch } from 'react-router-dom'\n+┊  ┊ 3┊import ChatRoomScreen from './components/ChatRoomScreen'\n ┊ 2┊ 4┊import ChatsListScreen from './components/ChatsListScreen'\n ┊ 3┊ 5┊\n ┊ 4┊ 6┊const App = () => (\n-┊ 5┊  ┊  <div>\n-┊ 6┊  ┊    <ChatsListScreen />\n-┊ 7┊  ┊  </div>\n+┊  ┊ 7┊  <BrowserRouter>\n+┊  ┊ 8┊    <Switch>\n+┊  ┊ 9┊      <Route exact path=\"/chats\" component={ChatsListScreen} />\n+┊  ┊10┊      <Route exact path=\"/chats/:chatId\" component={ChatRoomScreen} />\n+┊  ┊11┊    </Switch>\n+┊  ┊12┊    <Route exact path=\"/\" render={redirectToChats} />\n+┊  ┊13┊  </BrowserRouter>\n+┊  ┊14┊)\n+┊  ┊15┊\n+┊  ┊16┊const redirectToChats = () => (\n+┊  ┊17┊  <Redirect to=\"/chats\" />\n ┊ 8┊18┊)\n ┊ 9┊19┊\n ┊10┊20┊export default App\n```\n\n[}]: #\n\nThe purpose of a router is to make route managing easy and declarative. It will take care of managing the history within our app and parameterizing certain screens according to our need. Essentially it's a wrap around the `window.history` object which is also compatible with React. I recommend you to go through the [official MDN docs](https://developer.mozilla.org/en-US/docs/Web/API/History) if you're not yet familiar with the concept.\n\nThe `<Route />` component represents a path for a route in our application. Using the colon syntax (`:chatId`) we basically tell the router that the `/chat` route should be followed by a string whose value can later on be addressed via a parameter called `chatId` when navigating to the route. So here's a sum-up of the routes manifest:\n\n\n\n*   `/chats` - will navigate to the `ChatsListScreen`.\n*   `/chat/:chatId` - e.g. `/chat/1`, will navigate to the `ChatRoomScreen` and will parameterize it to show data which is related to chat ID 1.\n*   Any other route will fallback to the `/chats` route which will redirect us to the `ChatsListScreen`.\n\nNow we will implement the `ChatRoomScreen` so the router can function properly. For now we will make it a plain screen which simply prints out the information of the chat that was clicked so we can have a complete flow, and then we will take care of the rest.\n\nTo do so, we will first implement the `chat` query in our backend. This would be a parameterized query that will provide us with a specific chat according to the received ID, and it will be used by the new screen as soon as it is initialized. First we would update the `Chat` type to contain a `messages` field:\n\n[{]: <helper> (diffStep 4.1 files=\"schema\" module=\"server\")\n\n#### Step 4.1: Add messages field to Chat type\n\n##### Changed schema&#x2F;resolvers.ts\n```diff\n@@ -5,6 +5,10 @@\n ┊ 5┊ 5┊  Date: GraphQLDateTime,\n ┊ 6┊ 6┊\n ┊ 7┊ 7┊  Chat: {\n+┊  ┊ 8┊    messages(chat: any) {\n+┊  ┊ 9┊      return messages.filter(m => chat.messages.includes(m.id))\n+┊  ┊10┊    },\n+┊  ┊11┊\n ┊ 8┊12┊    lastMessage(chat: any) {\n ┊ 9┊13┊      return messages.find(m => m.id === chat.lastMessage)\n ┊10┊14┊    },\n```\n\n##### Changed schema&#x2F;typeDefs.graphql\n```diff\n@@ -11,6 +11,7 @@\n ┊11┊11┊  name: String!\n ┊12┊12┊  picture: String\n ┊13┊13┊  lastMessage: Message\n+┊  ┊14┊  messages: [Message!]!\n ┊14┊15┊}\n ┊15┊16┊\n ┊16┊17┊type Query {\n```\n\n[}]: #\n\nAnd then we will update our DB mock to be aligned with these changes:\n\n[{]: <helper> (diffStep 4.1 files=\"db\" module=\"server\")\n\n#### Step 4.1: Add messages field to Chat type\n\n##### Changed db.ts\n```diff\n@@ -27,23 +27,27 @@\n ┊27┊27┊    name: 'Ethan Gonzalez',\n ┊28┊28┊    picture: 'https://randomuser.me/api/portraits/thumb/men/1.jpg',\n ┊29┊29┊    lastMessage: '1',\n+┊  ┊30┊    messages: ['1'],\n ┊30┊31┊  },\n ┊31┊32┊  {\n ┊32┊33┊    id: '2',\n ┊33┊34┊    name: 'Bryan Wallace',\n ┊34┊35┊    picture: 'https://randomuser.me/api/portraits/thumb/men/2.jpg',\n ┊35┊36┊    lastMessage: '2',\n+┊  ┊37┊    messages: ['2'],\n ┊36┊38┊  },\n ┊37┊39┊  {\n ┊38┊40┊    id: '3',\n ┊39┊41┊    name: 'Avery Stewart',\n ┊40┊42┊    picture: 'https://randomuser.me/api/portraits/thumb/women/1.jpg',\n ┊41┊43┊    lastMessage: '3',\n+┊  ┊44┊    messages: ['3'],\n ┊42┊45┊  },\n ┊43┊46┊  {\n ┊44┊47┊    id: '4',\n ┊45┊48┊    name: 'Katie Peterson',\n ┊46┊49┊    picture: 'https://randomuser.me/api/portraits/thumb/women/2.jpg',\n ┊47┊50┊    lastMessage: '4',\n+┊  ┊51┊    messages: ['4'],\n ┊48┊52┊  },\n ┊49┊53┊]\n```\n\n[}]: #\n\nThis means that when we resolve `Chat.lastMessage`, we should get it directly from the `Chat.messages` field:\n\n[{]: <helper> (diffStep 4.2 module=\"server\")\n\n#### Step 4.2: Resolve last message based on messages array\n\n##### Changed db.ts\n```diff\n@@ -26,28 +26,24 @@\n ┊26┊26┊    id: '1',\n ┊27┊27┊    name: 'Ethan Gonzalez',\n ┊28┊28┊    picture: 'https://randomuser.me/api/portraits/thumb/men/1.jpg',\n-┊29┊  ┊    lastMessage: '1',\n ┊30┊29┊    messages: ['1'],\n ┊31┊30┊  },\n ┊32┊31┊  {\n ┊33┊32┊    id: '2',\n ┊34┊33┊    name: 'Bryan Wallace',\n ┊35┊34┊    picture: 'https://randomuser.me/api/portraits/thumb/men/2.jpg',\n-┊36┊  ┊    lastMessage: '2',\n ┊37┊35┊    messages: ['2'],\n ┊38┊36┊  },\n ┊39┊37┊  {\n ┊40┊38┊    id: '3',\n ┊41┊39┊    name: 'Avery Stewart',\n ┊42┊40┊    picture: 'https://randomuser.me/api/portraits/thumb/women/1.jpg',\n-┊43┊  ┊    lastMessage: '3',\n ┊44┊41┊    messages: ['3'],\n ┊45┊42┊  },\n ┊46┊43┊  {\n ┊47┊44┊    id: '4',\n ┊48┊45┊    name: 'Katie Peterson',\n ┊49┊46┊    picture: 'https://randomuser.me/api/portraits/thumb/women/2.jpg',\n-┊50┊  ┊    lastMessage: '4',\n ┊51┊47┊    messages: ['4'],\n ┊52┊48┊  },\n ┊53┊49┊]\n```\n\n##### Changed schema&#x2F;resolvers.ts\n```diff\n@@ -10,7 +10,9 @@\n ┊10┊10┊    },\n ┊11┊11┊\n ┊12┊12┊    lastMessage(chat: any) {\n-┊13┊  ┊      return messages.find(m => m.id === chat.lastMessage)\n+┊  ┊13┊      const lastMessage = chat.messages[chat.messages.length - 1]\n+┊  ┊14┊\n+┊  ┊15┊      return messages.find(m => m.id === lastMessage)\n ┊14┊16┊    },\n ┊15┊17┊  },\n```\n\n[}]: #\n\nNow that we have an updated schema which is relevant to the new screen that we would like to add, we will declare a new query called `chat`:\n\n[{]: <helper> (diffStep 4.3 files=\"schema/typeDefs\" module=\"server\")\n\n#### Step 4.3: Add chat field to Query type\n\n##### Changed schema&#x2F;typeDefs.graphql\n```diff\n@@ -16,4 +16,5 @@\n ┊16┊16┊\n ┊17┊17┊type Query {\n ┊18┊18┊  chats: [Chat!]!\n+┊  ┊19┊  chat(chatId: ID!): Chat\n ┊19┊20┊}\n```\n\n[}]: #\n\nNote that unlike the `chats` query, this time we have a parameter. The parameters are provided to the resolver function as the second parameter as a JSON. Using the provided parameter - the chat ID, we will find and return the relevant chat from the DB:\n\n[{]: <helper> (diffStep 4.3 files=\"schema/resolvers\" module=\"server\")\n\n#### Step 4.3: Add chat field to Query type\n\n##### Changed schema&#x2F;resolvers.ts\n```diff\n@@ -20,5 +20,9 @@\n ┊20┊20┊    chats() {\n ┊21┊21┊      return chats\n ┊22┊22┊    },\n+┊  ┊23┊\n+┊  ┊24┊    chat(chat: any, { chatId }: any) {\n+┊  ┊25┊      return chats.find(c => c.id === chatId)\n+┊  ┊26┊    },\n ┊23┊27┊  },\n ┊24┊28┊}\n```\n\n[}]: #\n\n> More about the resolver signature can be read in [Apollo-GraphQL's official docs page](https://www.apollographql.com/docs/apollo-server/essentials/data.html#type-signature).\n\nNow we will add a test suite:\n\n[{]: <helper> (diffStep 4.3 files=\"tests/queries/getChat.test\" module=\"server\")\n\n#### Step 4.3: Add chat field to Query type\n\n##### Added tests&#x2F;queries&#x2F;getChat.test.ts\n```diff\n@@ -0,0 +1,33 @@\n+┊  ┊ 1┊import { createTestClient } from 'apollo-server-testing'\n+┊  ┊ 2┊import { ApolloServer, gql } from 'apollo-server-express'\n+┊  ┊ 3┊import schema from '../../schema'\n+┊  ┊ 4┊\n+┊  ┊ 5┊describe('Query.chat', () => {\n+┊  ┊ 6┊  it('should fetch specified chat', async () => {\n+┊  ┊ 7┊    const server = new ApolloServer({ schema })\n+┊  ┊ 8┊\n+┊  ┊ 9┊    const { query } = createTestClient(server)\n+┊  ┊10┊\n+┊  ┊11┊    const res = await query({\n+┊  ┊12┊      variables: { chatId: '1' },\n+┊  ┊13┊      query: gql `\n+┊  ┊14┊        query GetChat($chatId: ID!) {\n+┊  ┊15┊          chat(chatId: $chatId) {\n+┊  ┊16┊            id\n+┊  ┊17┊            name\n+┊  ┊18┊            picture\n+┊  ┊19┊            lastMessage {\n+┊  ┊20┊              id\n+┊  ┊21┊              content\n+┊  ┊22┊              createdAt\n+┊  ┊23┊            }\n+┊  ┊24┊          }\n+┊  ┊25┊        }\n+┊  ┊26┊      `,\n+┊  ┊27┊    })\n+┊  ┊28┊\n+┊  ┊29┊    expect(res.data).toBeDefined()\n+┊  ┊30┊    expect(res.errors).toBeUndefined()\n+┊  ┊31┊    expect(res.data).toMatchSnapshot()\n+┊  ┊32┊  })\n+┊  ┊33┊})\n```\n\n[}]: #\n\nWe can observe the snapshot created by Jest to get a better understanding of how the response should look like:\n\n[{]: <helper> (diffStep 4.3 files=\"__snapshot__\" module=\"server\")\n\n#### Step 4.3: Add chat field to Query type\n\n\n\n[}]: #\n\nIf you experience any TypeScript related issues with the following error:\n\n```\nObject literal may only specify known properties, and 'variables' does not exist in type 'Query'.\n```\n\nAdd the following declaration file to your project:\n\n[{]: <helper> (diffStep 4.3 files=\"types\" module=\"server\")\n\n#### Step 4.3: Add chat field to Query type\n\n##### Added types&#x2F;apollo-server-testing.d.ts\n```diff\n@@ -0,0 +1,27 @@\n+┊  ┊ 1┊declare module 'apollo-server-testing' {\n+┊  ┊ 2┊  import { ApolloServerBase } from 'apollo-server-core';\n+┊  ┊ 3┊  import { print, DocumentNode } from 'graphql';\n+┊  ┊ 4┊  import { GraphQLResponse } from 'graphql-extensions';\n+┊  ┊ 5┊\n+┊  ┊ 6┊  type StringOrAst = string | DocumentNode;\n+┊  ┊ 7┊\n+┊  ┊ 8┊  // A query must not come with a mutation (and vice versa).\n+┊  ┊ 9┊  type Query<TVariables> = {\n+┊  ┊10┊    query: StringOrAst;\n+┊  ┊11┊    mutation?: undefined;\n+┊  ┊12┊    variables?: TVariables;\n+┊  ┊13┊  };\n+┊  ┊14┊\n+┊  ┊15┊  type Mutation<TVariables> = {\n+┊  ┊16┊    mutation: StringOrAst;\n+┊  ┊17┊    query?: undefined;\n+┊  ┊18┊    variables?: TVariables;\n+┊  ┊19┊  };\n+┊  ┊20┊\n+┊  ┊21┊  export const createTestClient: <TVariables>(\n+┊  ┊22┊    server: ApolloServerBase,\n+┊  ┊23┊  ) => {\n+┊  ┊24┊    query: (query: Query<TVariables>) => Promise<GraphQLResponse>;\n+┊  ┊25┊    mutate: (mutation: Mutation<TVariables>) => Promise<GraphQLResponse>;\n+┊  ┊26┊  };\n+┊  ┊27┊}\n```\n\n[}]: #\n\nThis is a [known issue](https://github.com/apollographql/apollo-server/issues/2172) in the `apollo-server-testing` package and has a pending [fix PR](https://github.com/apollographql/apollo-server/pull/2307). Now getting back to the client, let's implement a basic version of the `ChatRoomScreen` where we will fetch the new query and print it to the screen:\n\n[{]: <helper> (diffStep 6.2 module=\"client\")\n\n#### [Step 6.2: Add basic ChatRoomScreen](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/e1b65e0)\n\n##### Added src&#x2F;components&#x2F;ChatRoomScreen&#x2F;index.tsx\n```diff\n@@ -0,0 +1,55 @@\n+┊  ┊ 1┊import * as React from 'react'\n+┊  ┊ 2┊import { useMemo, useState } from 'react'\n+┊  ┊ 3┊\n+┊  ┊ 4┊const getChatQuery = `\n+┊  ┊ 5┊  query GetChat($chatId: ID!) {\n+┊  ┊ 6┊    chat(chatId: $chatId) {\n+┊  ┊ 7┊      id\n+┊  ┊ 8┊      name\n+┊  ┊ 9┊      picture\n+┊  ┊10┊      messages {\n+┊  ┊11┊        id\n+┊  ┊12┊        content\n+┊  ┊13┊        createdAt\n+┊  ┊14┊      }\n+┊  ┊15┊    }\n+┊  ┊16┊  }\n+┊  ┊17┊`\n+┊  ┊18┊\n+┊  ┊19┊const ChatRoomScreen = ({ match }) => {\n+┊  ┊20┊  const { params: { chatId } } = match\n+┊  ┊21┊  const [chat, setChat] = useState(null)\n+┊  ┊22┊\n+┊  ┊23┊  useMemo(async () => {\n+┊  ┊24┊    const body = await fetch(`${process.env.REACT_APP_SERVER_URL}/graphql`, {\n+┊  ┊25┊      method: 'POST',\n+┊  ┊26┊      headers: {\n+┊  ┊27┊        'Content-Type': 'application/json',\n+┊  ┊28┊      },\n+┊  ┊29┊      body: JSON.stringify({\n+┊  ┊30┊        query: getChatQuery,\n+┊  ┊31┊        variables: { chatId },\n+┊  ┊32┊      }),\n+┊  ┊33┊    })\n+┊  ┊34┊    const { data: { chat } } = await body.json()\n+┊  ┊35┊    setChat(chat)\n+┊  ┊36┊  }, [true])\n+┊  ┊37┊\n+┊  ┊38┊  if (!chat) return null\n+┊  ┊39┊\n+┊  ┊40┊  return (\n+┊  ┊41┊    <div>\n+┊  ┊42┊      <img src={chat.picture} /><div>{chat.name}</div>\n+┊  ┊43┊      <ul>\n+┊  ┊44┊        {chat.messages.map((message) =>\n+┊  ┊45┊          <li key={message.id}>\n+┊  ┊46┊            <div>{message.content}</div>\n+┊  ┊47┊            <div>{message.createdAt}</div>\n+┊  ┊48┊          </li>\n+┊  ┊49┊        )}\n+┊  ┊50┊      </ul>\n+┊  ┊51┊    </div>\n+┊  ┊52┊  )\n+┊  ┊53┊}\n+┊  ┊54┊\n+┊  ┊55┊export default ChatRoomScreen\n```\n\n[}]: #\n\nNote how we used the `match.params.chatId` variable to get the selected chat ID. The `match` prop is defined and provided to us by the `<Route />` component, since it interfaces directly with the `ChatRoomScreen`. More about that can be read in the [official docs page](https://reacttraining.com/react-router/core/api/match). If you'll run the application and type `/chats/1` in the URL bar, this is what you should see on the screen:\n\n![naked-chat](https://user-images.githubusercontent.com/7648874/54664314-d4096b80-4b1e-11e9-9e06-1323cf7b0abe.png)\n\nThe view has no styling at all but it should be fixed in a moment. To make navigation more convenient we will add an `onClick` listener for each chat item in the `ChatsList`. Using the [history](https://reacttraining.com/react-router/core/api/history) object, provided to us by the `<Route />` component, we will navigate to the correlated `ChatRoomScreen`:\n\n[{]: <helper> (diffStep 6.3 module=\"client\")\n\n#### [Step 6.3: Nav to chat on click](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/6028ec2)\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;ChatsList.tsx\n```diff\n@@ -1,7 +1,7 @@\n ┊1┊1┊import { List, ListItem } from '@material-ui/core'\n ┊2┊2┊import moment from 'moment'\n ┊3┊3┊import * as React from 'react'\n-┊4┊ ┊import { useState, useMemo } from 'react'\n+┊ ┊4┊import { useCallback, useState, useMemo } from 'react'\n ┊5┊5┊import styled from 'styled-components'\n ┊6┊6┊\n ┊7┊7┊const Container = styled.div `\n```\n```diff\n@@ -70,7 +70,7 @@\n ┊70┊70┊  }\n ┊71┊71┊`\n ┊72┊72┊\n-┊73┊  ┊const ChatsList = () => {\n+┊  ┊73┊const ChatsList = ({ history }) => {\n ┊74┊74┊  const [chats, setChats] = useState([])\n ┊75┊75┊\n ┊76┊76┊  useMemo(async () => {\n```\n```diff\n@@ -85,11 +85,15 @@\n ┊85┊85┊    setChats(chats)\n ┊86┊86┊  }, [true])\n ┊87┊87┊\n+┊  ┊88┊  const navToChat = useCallback((chat) => {\n+┊  ┊89┊    history.push(`chats/${chat.id}`)\n+┊  ┊90┊  }, [true])\n+┊  ┊91┊\n ┊88┊92┊  return (\n ┊89┊93┊    <Container>\n ┊90┊94┊      <StyledList>\n ┊91┊95┊        {chats.map((chat) => (\n-┊92┊  ┊          <StyledListItem key={chat.id} button>\n+┊  ┊96┊          <StyledListItem key={chat.id} data-testid=\"chat\" button onClick={navToChat.bind(null, chat)}>\n ┊93┊97┊            <ChatPicture data-testid=\"picture\" src={chat.picture} />\n ┊94┊98┊            <ChatInfo>\n ┊95┊99┊              <ChatName data-testid=\"name\">{chat.name}</ChatName>\n```\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;index.tsx\n```diff\n@@ -7,10 +7,10 @@\n ┊ 7┊ 7┊  height: 100vh;\n ┊ 8┊ 8┊`\n ┊ 9┊ 9┊\n-┊10┊  ┊const ChatsListScreen = () => (\n+┊  ┊10┊const ChatsListScreen = ({ history }) => (\n ┊11┊11┊  <Container>\n ┊12┊12┊    <ChatsNavbar />\n-┊13┊  ┊    <ChatsList />\n+┊  ┊13┊    <ChatsList history={history} />\n ┊14┊14┊  </Container>\n ┊15┊15┊)\n```\n\n[}]: #\n\nAnd add test the new logic:\n\n[{]: <helper> (diffStep 6.4 module=\"client\")\n\n#### [Step 6.4: Test new navigation logic](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/cb8c02b)\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;ChatsList.test.tsx\n```diff\n@@ -1,10 +1,14 @@\n+┊  ┊ 1┊import { createBrowserHistory } from 'history'\n ┊ 1┊ 2┊import React from 'react'\n ┊ 2┊ 3┊import ReactDOM from 'react-dom'\n-┊ 3┊  ┊import { cleanup, render, waitForDomChange } from 'react-testing-library'\n+┊  ┊ 4┊import { cleanup, render, fireEvent, wait, waitForDomChange } from 'react-testing-library'\n ┊ 4┊ 5┊import ChatsList from './ChatsList'\n ┊ 5┊ 6┊\n ┊ 6┊ 7┊describe('ChatsList', () => {\n-┊ 7┊  ┊  afterEach(cleanup)\n+┊  ┊ 8┊  afterEach(() => {\n+┊  ┊ 9┊    cleanup()\n+┊  ┊10┊    window.location.pathname = '/'\n+┊  ┊11┊  })\n ┊ 8┊12┊\n ┊ 9┊13┊  it('renders fetched chats data', async () => {\n ┊10┊14┊    fetch.mockResponseOnce(JSON.stringify({\n```\n```diff\n@@ -35,4 +39,37 @@\n ┊35┊39┊      expect(getByTestId('date')).toHaveTextContent('08:00')\n ┊36┊40┊    }\n ┊37┊41┊  })\n+┊  ┊42┊\n+┊  ┊43┊  it('should navigate to the target chat room on chat item click', async () => {\n+┊  ┊44┊    fetch.mockResponseOnce(JSON.stringify({\n+┊  ┊45┊      data: {\n+┊  ┊46┊        chats: [\n+┊  ┊47┊          {\n+┊  ┊48┊            id: 1,\n+┊  ┊49┊            name: 'Foo Bar',\n+┊  ┊50┊            picture: 'https://localhost:4000/picture.jpg',\n+┊  ┊51┊            lastMessage: {\n+┊  ┊52┊              id: 1,\n+┊  ┊53┊              content: 'Hello',\n+┊  ┊54┊              createdAt: new Date(0),\n+┊  ┊55┊            },\n+┊  ┊56┊          },\n+┊  ┊57┊        ],\n+┊  ┊58┊      },\n+┊  ┊59┊    }))\n+┊  ┊60┊\n+┊  ┊61┊    const history = createBrowserHistory()\n+┊  ┊62┊\n+┊  ┊63┊    {\n+┊  ┊64┊      const { container, getByTestId } = render(<ChatsList history={history} />)\n+┊  ┊65┊\n+┊  ┊66┊      await waitForDomChange({ container })\n+┊  ┊67┊\n+┊  ┊68┊      fireEvent.click(getByTestId('chat'))\n+┊  ┊69┊\n+┊  ┊70┊      await wait(() =>\n+┊  ┊71┊        expect(history.location.pathname).toEqual('/chats/1')\n+┊  ┊72┊      )\n+┊  ┊73┊    }\n+┊  ┊74┊  })\n ┊38┊75┊})\n```\n\n[}]: #\n\nIf you'll click on the chat item you'll see that the screen changes very suddenly. We can smooth the transition by animating it with CSS. Luckily we don't need to implemented such mechanism manually because there's a package that can do that for us - [`react-router-transition`](https://www.npmjs.com/package/react-router-transition):\n\n  $ npm install react-router-transition\n\nUsing this package, we will create a custom `Switch` component that will play an animation for all its subordinate `Route` components. The animation is defined by the user using a component called `AnimatedSwitch` as specified in the [package's docs page](http://maisano.github.io/react-router-transition/animated-switch/props). So first, let's create our switch component that will play a smooth transition switching routes:\n\n[{]: <helper> (diffStep 6.5 files=\"AnimatedSwitch\" module=\"client\")\n\n#### [Step 6.5: Animate route switching](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/b85095e)\n\n##### Added src&#x2F;components&#x2F;AnimatedSwitch.tsx\n```diff\n@@ -0,0 +1,37 @@\n+┊  ┊ 1┊import { Switch } from 'react-router-dom'\n+┊  ┊ 2┊import { AnimatedSwitch, spring } from 'react-router-transition'\n+┊  ┊ 3┊import styled from 'styled-components'\n+┊  ┊ 4┊\n+┊  ┊ 5┊// A workaround to make test pass\n+┊  ┊ 6┊const SwitchComponent = process.env.NODE_ENV === 'test' ? Switch : AnimatedSwitch\n+┊  ┊ 7┊\n+┊  ┊ 8┊const glide = val =>\n+┊  ┊ 9┊  spring(val, {\n+┊  ┊10┊    stiffness: 174,\n+┊  ┊11┊    damping: 24,\n+┊  ┊12┊  })\n+┊  ┊13┊\n+┊  ┊14┊const mapStyles = styles => ({\n+┊  ┊15┊  transform: `translateX(${styles.offset}%)`,\n+┊  ┊16┊})\n+┊  ┊17┊\n+┊  ┊18┊const MyAnimatedSwitch =  styled(SwitchComponent).attrs(() => ({\n+┊  ┊19┊  atEnter: { offset: 100 },\n+┊  ┊20┊  atLeave: { offset: glide(-100) },\n+┊  ┊21┊  atActive: { offset: glide(0) },\n+┊  ┊22┊  mapStyles,\n+┊  ┊23┊}))`\n+┊  ┊24┊  position: relative;\n+┊  ┊25┊  overflow: hidden;\n+┊  ┊26┊  height: 100vh;\n+┊  ┊27┊  width: 100vw;\n+┊  ┊28┊\n+┊  ┊29┊  > div {\n+┊  ┊30┊    position: absolute;\n+┊  ┊31┊    overflow: hidden;\n+┊  ┊32┊    height: 100vh;\n+┊  ┊33┊    width: 100vw;\n+┊  ┊34┊  }\n+┊  ┊35┊`\n+┊  ┊36┊\n+┊  ┊37┊export default MyAnimatedSwitch\n```\n\n[}]: #\n\nAnd then replace it with the main `Switch` component in our app:\n\n[{]: <helper> (diffStep 6.5 files=\"App\" module=\"client\")\n\n#### [Step 6.5: Animate route switching](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/b85095e)\n\n##### Changed src&#x2F;App.jsx\n```diff\n@@ -1,14 +1,15 @@\n ┊ 1┊ 1┊import * as React from 'react'\n-┊ 2┊  ┊import { BrowserRouter, Route, Redirect, Switch } from 'react-router-dom'\n+┊  ┊ 2┊import { BrowserRouter, Route, Redirect } from 'react-router-dom'\n ┊ 3┊ 3┊import ChatRoomScreen from './components/ChatRoomScreen'\n ┊ 4┊ 4┊import ChatsListScreen from './components/ChatsListScreen'\n+┊  ┊ 5┊import AnimatedSwitch from './components/AnimatedSwitch'\n ┊ 5┊ 6┊\n ┊ 6┊ 7┊const App = () => (\n ┊ 7┊ 8┊  <BrowserRouter>\n-┊ 8┊  ┊    <Switch>\n+┊  ┊ 9┊    <AnimatedSwitch>\n ┊ 9┊10┊      <Route exact path=\"/chats\" component={ChatsListScreen} />\n ┊10┊11┊      <Route exact path=\"/chats/:chatId\" component={ChatRoomScreen} />\n-┊11┊  ┊    </Switch>\n+┊  ┊12┊    </AnimatedSwitch>\n ┊12┊13┊    <Route exact path=\"/\" render={redirectToChats} />\n ┊13┊14┊  </BrowserRouter>\n ┊14┊15┊)\n```\n\n[}]: #\n\nBoth components act identically and thus there shall be no special treatment. Behold the new transition effect:\n\n![transition-demo](https://user-images.githubusercontent.com/7648874/54739398-ebb22400-4bf2-11e9-8d4c-2aeb65deeb92.gif)\n\nThe final screen will be composed out of 3 components:\n\n\n\n*   A navigation bar.\n*   A messages list.\n*   A message input.\n\nIn the main `index.ts` file of the screen we will simply import all 3 in the right order. We will start with the most simple one - the `ChatRoomNavbar`. The navbar should show the picture of the chat we're currently at and its name, along with a back button that will bring us back to the `ChatsListScreen`:\n\n[{]: <helper> (diffStep 6.6 files=\"ChatNavbar\" module=\"client\")\n\n#### [Step 6.6: Implement ChatRoomScreen components](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/4937611)\n\n##### Added src&#x2F;components&#x2F;ChatRoomScreen&#x2F;ChatNavbar.tsx\n```diff\n@@ -0,0 +1,51 @@\n+┊  ┊ 1┊import Button from '@material-ui/core/Button'\n+┊  ┊ 2┊import ArrowBackIcon from '@material-ui/icons/ArrowBack'\n+┊  ┊ 3┊import * as React from 'react'\n+┊  ┊ 4┊import { useCallback, useState } from 'react'\n+┊  ┊ 5┊import styled from 'styled-components'\n+┊  ┊ 6┊\n+┊  ┊ 7┊const Style = styled.div`\n+┊  ┊ 8┊  padding: 0;\n+┊  ┊ 9┊  display: flex;\n+┊  ┊10┊  flex-direction: row;\n+┊  ┊11┊  background-color: var(--primary-bg);\n+┊  ┊12┊  color: var(--primary-text);\n+┊  ┊13┊`\n+┊  ┊14┊\n+┊  ┊15┊const BackButton = styled(Button) `\n+┊  ┊16┊  svg {\n+┊  ┊17┊    color: var(--primary-text);\n+┊  ┊18┊  }\n+┊  ┊19┊`\n+┊  ┊20┊\n+┊  ┊21┊const Picture = styled.img `\n+┊  ┊22┊  height: 40px;\n+┊  ┊23┊  width: 40px;\n+┊  ┊24┊  margin-top: 3px;\n+┊  ┊25┊  margin-left: -22px;\n+┊  ┊26┊  object-fit: cover;\n+┊  ┊27┊  padding: 5px;\n+┊  ┊28┊  border-radius: 50%;\n+┊  ┊29┊`\n+┊  ┊30┊\n+┊  ┊31┊const Title = styled.div `\n+┊  ┊32┊  line-height: 56px;\n+┊  ┊33┊`\n+┊  ┊34┊\n+┊  ┊35┊const ChatNavbar = ({ chat, history }) => {\n+┊  ┊36┊  const navBack = useCallback(() => {\n+┊  ┊37┊    history.goBack()\n+┊  ┊38┊  }, [true])\n+┊  ┊39┊\n+┊  ┊40┊  return (\n+┊  ┊41┊    <Style className={name}>\n+┊  ┊42┊      <BackButton onClick={navBack}>\n+┊  ┊43┊        <ArrowBackIcon />\n+┊  ┊44┊      </BackButton>\n+┊  ┊45┊      <Picture src={chat.picture} />\n+┊  ┊46┊      <Title>{chat.name}</Title>\n+┊  ┊47┊    </Style>\n+┊  ┊48┊  )\n+┊  ┊49┊}\n+┊  ┊50┊\n+┊  ┊51┊export default ChatNavbar\n```\n\n[}]: #\n\nNext, would be the `MesagesList` component, where we will see a scrollable list of all the messages of the active chat:\n\n[{]: <helper> (diffStep 6.6 files=\"MessagesList\" module=\"client\")\n\n#### [Step 6.6: Implement ChatRoomScreen components](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/4937611)\n\n##### Added src&#x2F;components&#x2F;ChatRoomScreen&#x2F;MessagesList.tsx\n```diff\n@@ -0,0 +1,75 @@\n+┊  ┊ 1┊import moment from 'moment'\n+┊  ┊ 2┊import * as React from 'react'\n+┊  ┊ 3┊import styled from 'styled-components'\n+┊  ┊ 4┊\n+┊  ┊ 5┊const Container = styled.div`\n+┊  ┊ 6┊  display: block;\n+┊  ┊ 7┊  flex: 2;\n+┊  ┊ 8┊  overflow-y: overlay;\n+┊  ┊ 9┊  padding: 0 15px;\n+┊  ┊10┊`\n+┊  ┊11┊\n+┊  ┊12┊const MessageItem = styled.div `\n+┊  ┊13┊  float: right;\n+┊  ┊14┊  background-color: #dcf8c6;\n+┊  ┊15┊  display: inline-block;\n+┊  ┊16┊  position: relative;\n+┊  ┊17┊  max-width: 100%;\n+┊  ┊18┊  border-radius: 7px;\n+┊  ┊19┊  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.15);\n+┊  ┊20┊  margin-top: 10px;\n+┊  ┊21┊  margin-bottom: 10px;\n+┊  ┊22┊  clear: both;\n+┊  ┊23┊\n+┊  ┊24┊  &::after {\n+┊  ┊25┊    content: '';\n+┊  ┊26┊    display: table;\n+┊  ┊27┊    clear: both;\n+┊  ┊28┊  }\n+┊  ┊29┊\n+┊  ┊30┊  &::before {\n+┊  ┊31┊    background-image: url(/assets/message-mine.png);\n+┊  ┊32┊    content: '';\n+┊  ┊33┊    position: absolute;\n+┊  ┊34┊    bottom: 3px;\n+┊  ┊35┊    width: 12px;\n+┊  ┊36┊    height: 19px;\n+┊  ┊37┊    right: -11px;\n+┊  ┊38┊    background-position: 50% 50%;\n+┊  ┊39┊    background-repeat: no-repeat;\n+┊  ┊40┊    background-size: contain;\n+┊  ┊41┊  }\n+┊  ┊42┊`\n+┊  ┊43┊\n+┊  ┊44┊const Contents = styled.div `\n+┊  ┊45┊  padding: 5px 7px;\n+┊  ┊46┊  word-wrap: break-word;\n+┊  ┊47┊\n+┊  ┊48┊  &::after {\n+┊  ┊49┊    content: ' \\00a0\\00a0\\00a0\\00a0\\00a0\\00a0\\00a0\\00a0\\00a0\\00a0\\00a0\\00a0\\00a0\\00a0\\00a0\\00a0\\00a0\\00a0\\00a0';\n+┊  ┊50┊    display: inline;\n+┊  ┊51┊  }\n+┊  ┊52┊`\n+┊  ┊53┊\n+┊  ┊54┊const Timestamp = styled.div `\n+┊  ┊55┊  position: absolute;\n+┊  ┊56┊  bottom: 2px;\n+┊  ┊57┊  right: 7px;\n+┊  ┊58┊  color: gray;\n+┊  ┊59┊  font-size: 12px;\n+┊  ┊60┊`\n+┊  ┊61┊\n+┊  ┊62┊const MessagesList = ({ messages }) => {\n+┊  ┊63┊  return (\n+┊  ┊64┊    <Container>\n+┊  ┊65┊      {messages.map((message) => (\n+┊  ┊66┊        <MessageItem key={message.id}>\n+┊  ┊67┊          <Contents>{message.content}</Contents>\n+┊  ┊68┊          <Timestamp>{moment(message.createdAt).format('HH:mm')}</Timestamp>\n+┊  ┊69┊        </MessageItem>\n+┊  ┊70┊      ))}\n+┊  ┊71┊    </Container>\n+┊  ┊72┊  )\n+┊  ┊73┊}\n+┊  ┊74┊\n+┊  ┊75┊export default MessagesList\n```\n\n[}]: #\n\nAnd finally, would be the `MessageInput` component which will trigger an event whenever we type and submit a new message:\n\n[{]: <helper> (diffStep 6.6 files=\"MessageInput\" module=\"client\")\n\n#### [Step 6.6: Implement ChatRoomScreen components](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/4937611)\n\n##### Added src&#x2F;components&#x2F;ChatRoomScreen&#x2F;MessageInput.tsx\n```diff\n@@ -0,0 +1,86 @@\n+┊  ┊ 1┊import Button from '@material-ui/core/Button'\n+┊  ┊ 2┊import SendIcon from '@material-ui/icons/Send'\n+┊  ┊ 3┊import * as React from 'react'\n+┊  ┊ 4┊import { useState } from 'react'\n+┊  ┊ 5┊import styled from 'styled-components'\n+┊  ┊ 6┊\n+┊  ┊ 7┊const Container = styled.div`\n+┊  ┊ 8┊  display: flex;\n+┊  ┊ 9┊  height: 50px;\n+┊  ┊10┊  padding: 5px;\n+┊  ┊11┊  width: calc(100% - 10px);\n+┊  ┊12┊`\n+┊  ┊13┊\n+┊  ┊14┊const ActualInput = styled.input `\n+┊  ┊15┊  width: calc(100% - 50px);\n+┊  ┊16┊  border: none;\n+┊  ┊17┊  border-radius: 999px;\n+┊  ┊18┊  padding: 10px;\n+┊  ┊19┊  padding-left: 20px;\n+┊  ┊20┊  padding-right: 20px;\n+┊  ┊21┊  font-size: 15px;\n+┊  ┊22┊  outline: none;\n+┊  ┊23┊  box-shadow: 0 1px silver;\n+┊  ┊24┊  font-size: 18px;\n+┊  ┊25┊  line-height: 45px;\n+┊  ┊26┊`\n+┊  ┊27┊\n+┊  ┊28┊const SendButton = styled(Button) `\n+┊  ┊29┊  min-width: 50px !important;\n+┊  ┊30┊  width: 50px !important;\n+┊  ┊31┊  border-radius: 999px !important;\n+┊  ┊32┊  background-color: var(--primary-bg) !important;\n+┊  ┊33┊  margin: 0 5px !important;\n+┊  ┊34┊  margin-right: 0 !important;\n+┊  ┊35┊  color: white !important;\n+┊  ┊36┊  padding-left: 20px !important;\n+┊  ┊37┊\n+┊  ┊38┊  svg {\n+┊  ┊39┊    margin-left: -3px;\n+┊  ┊40┊  }\n+┊  ┊41┊`\n+┊  ┊42┊\n+┊  ┊43┊const MessageInput = ({ onSendMessage }) => {\n+┊  ┊44┊  const [message, setMessage] = useState('')\n+┊  ┊45┊\n+┊  ┊46┊  const onKeyPress = e => {\n+┊  ┊47┊    if (e.charCode === 13) {\n+┊  ┊48┊      submitMessage()\n+┊  ┊49┊    }\n+┊  ┊50┊  }\n+┊  ┊51┊\n+┊  ┊52┊  const onChange = ({ target }) => {\n+┊  ┊53┊    setMessage(target.value)\n+┊  ┊54┊  }\n+┊  ┊55┊\n+┊  ┊56┊  const submitMessage = () => {\n+┊  ┊57┊    if (!message) return\n+┊  ┊58┊\n+┊  ┊59┊    setMessage('')\n+┊  ┊60┊\n+┊  ┊61┊    if (typeof onSendMessage === 'function') {\n+┊  ┊62┊      onSendMessage(message)\n+┊  ┊63┊    }\n+┊  ┊64┊  }\n+┊  ┊65┊\n+┊  ┊66┊  return (\n+┊  ┊67┊    <Container>\n+┊  ┊68┊      <ActualInput\n+┊  ┊69┊        type=\"text\"\n+┊  ┊70┊        placeholder=\"Type a message\"\n+┊  ┊71┊        value={message}\n+┊  ┊72┊        onKeyPress={onKeyPress}\n+┊  ┊73┊        onChange={onChange}\n+┊  ┊74┊      />\n+┊  ┊75┊      <SendButton\n+┊  ┊76┊        variant=\"contained\"\n+┊  ┊77┊        color=\"primary\"\n+┊  ┊78┊        onClick={submitMessage}\n+┊  ┊79┊      >\n+┊  ┊80┊        <SendIcon />\n+┊  ┊81┊      </SendButton>\n+┊  ┊82┊    </Container>\n+┊  ┊83┊  )\n+┊  ┊84┊}\n+┊  ┊85┊\n+┊  ┊86┊export default MessageInput\n```\n\n[}]: #\n\nNow that we have all 3 components, we will put them all together in the main `index.ts` file:\n\n[{]: <helper> (diffStep 6.6 files=\"index\" module=\"client\")\n\n#### [Step 6.6: Implement ChatRoomScreen components](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/4937611)\n\n##### Changed src&#x2F;components&#x2F;ChatRoomScreen&#x2F;index.tsx\n```diff\n@@ -1,5 +1,16 @@\n ┊ 1┊ 1┊import * as React from 'react'\n ┊ 2┊ 2┊import { useMemo, useState } from 'react'\n+┊  ┊ 3┊import styled from 'styled-components'\n+┊  ┊ 4┊import ChatNavbar from './ChatNavbar'\n+┊  ┊ 5┊import MessageInput from './MessageInput'\n+┊  ┊ 6┊import MessagesList from './MessagesList'\n+┊  ┊ 7┊\n+┊  ┊ 8┊const Container = styled.div `\n+┊  ┊ 9┊  background: url(/assets/chat-background.jpg);\n+┊  ┊10┊  display: flex;\n+┊  ┊11┊  flex-flow: column;\n+┊  ┊12┊  height: 100vh;\n+┊  ┊13┊`\n ┊ 3┊14┊\n ┊ 4┊15┊const getChatQuery = `\n ┊ 5┊16┊  query GetChat($chatId: ID!) {\n```\n```diff\n@@ -16,7 +27,7 @@\n ┊16┊27┊  }\n ┊17┊28┊`\n ┊18┊29┊\n-┊19┊  ┊const ChatRoomScreen = ({ match }) => {\n+┊  ┊30┊const ChatRoomScreen = ({ history, match }) => {\n ┊20┊31┊  const { params: { chatId } } = match\n ┊21┊32┊  const [chat, setChat] = useState(null)\n ┊22┊33┊\n```\n```diff\n@@ -38,17 +49,11 @@\n ┊38┊49┊  if (!chat) return null\n ┊39┊50┊\n ┊40┊51┊  return (\n-┊41┊  ┊    <div>\n-┊42┊  ┊      <img src={chat.picture} /><div>{chat.name}</div>\n-┊43┊  ┊      <ul>\n-┊44┊  ┊        {chat.messages.map((message) =>\n-┊45┊  ┊          <li key={message.id}>\n-┊46┊  ┊            <div>{message.content}</div>\n-┊47┊  ┊            <div>{message.createdAt}</div>\n-┊48┊  ┊          </li>\n-┊49┊  ┊        )}\n-┊50┊  ┊      </ul>\n-┊51┊  ┊    </div>\n+┊  ┊52┊    <Container>\n+┊  ┊53┊      <ChatNavbar chat={chat} history={history} />\n+┊  ┊54┊      <MessagesList messages={chat.messages} />\n+┊  ┊55┊      <MessageInput />\n+┊  ┊56┊    </Container>\n ┊52┊57┊  )\n ┊53┊58┊}\n```\n\n[}]: #\n\nThe view is complete! However the `MessageInput` is not bound to our messages list. We will use the triggered callback to update the chat state, whose changes should appear in the `MessagesList` component in the following render phase:\n\n[{]: <helper> (diffStep 6.7 module=\"client\")\n\n#### [Step 6.7: Define onSendMessage callback](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/5997b48)\n\n##### Changed src&#x2F;components&#x2F;ChatRoomScreen&#x2F;index.tsx\n```diff\n@@ -1,5 +1,5 @@\n ┊1┊1┊import * as React from 'react'\n-┊2┊ ┊import { useMemo, useState } from 'react'\n+┊ ┊2┊import { useCallback, useMemo, useState } from 'react'\n ┊3┊3┊import styled from 'styled-components'\n ┊4┊4┊import ChatNavbar from './ChatNavbar'\n ┊5┊5┊import MessageInput from './MessageInput'\n```\n```diff\n@@ -46,13 +46,26 @@\n ┊46┊46┊    setChat(chat)\n ┊47┊47┊  }, [true])\n ┊48┊48┊\n+┊  ┊49┊  const onSendMessage = useCallback((content) => {\n+┊  ┊50┊    const message = {\n+┊  ┊51┊      id: chat.messages.length + 1,\n+┊  ┊52┊      createdAt: Date.now(),\n+┊  ┊53┊      content,\n+┊  ┊54┊    }\n+┊  ┊55┊\n+┊  ┊56┊    setChat({\n+┊  ┊57┊      ...chat,\n+┊  ┊58┊      messages: chat.messages.concat(message),\n+┊  ┊59┊    })\n+┊  ┊60┊  }, [chat])\n+┊  ┊61┊\n ┊49┊62┊  if (!chat) return null\n ┊50┊63┊\n ┊51┊64┊  return (\n ┊52┊65┊    <Container>\n ┊53┊66┊      <ChatNavbar chat={chat} history={history} />\n ┊54┊67┊      <MessagesList messages={chat.messages} />\n-┊55┊  ┊      <MessageInput />\n+┊  ┊68┊      <MessageInput onSendMessage={onSendMessage} />\n ┊56┊69┊    </Container>\n ┊57┊70┊  )\n ┊58┊71┊}\n```\n\n[}]: #\n\nThis is how the entire flow should look like:\n\n![flow-demo](https://user-images.githubusercontent.com/7648874/54739741-27012280-4bf4-11e9-97cb-c715482e2e70.gif)\n\nBefore we wrap things up, we should also test our components. Since the new components have a direct control over the app's history, we should also find a way to simulate it in our tests. The `react-dom-router` uses the [`history`](https://www.npmjs.com/package/history) package under the hood, that means that we can use that package to inject a custom history object directly into the tested components. Let's install this package if so:\n\n  $ npm install history --dev\n\nAnd then implement our test suites:\n\n[{]: <helper> (diffStep 6.8 files=\"components\" module=\"client\")\n\n#### [Step 6.8: Test ChatRoomScreen child components](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/b8a743c)\n\n##### Added src&#x2F;components&#x2F;ChatRoomScreen&#x2F;ChatNavbar.test.tsx\n```diff\n@@ -0,0 +1,49 @@\n+┊  ┊ 1┊import { createMemoryHistory } from 'history'\n+┊  ┊ 2┊import React from 'react'\n+┊  ┊ 3┊import { cleanup, render, fireEvent, wait } from 'react-testing-library'\n+┊  ┊ 4┊import ChatNavbar from './ChatNavbar'\n+┊  ┊ 5┊\n+┊  ┊ 6┊describe('ChatNavbar', () => {\n+┊  ┊ 7┊  afterEach(cleanup)\n+┊  ┊ 8┊\n+┊  ┊ 9┊  it('renders chat data', () => {\n+┊  ┊10┊    const chat = {\n+┊  ┊11┊      id: '1',\n+┊  ┊12┊      name: 'Foo Bar',\n+┊  ┊13┊      picture: 'https://localhost:4000/picture.jpg',\n+┊  ┊14┊    }\n+┊  ┊15┊\n+┊  ┊16┊    {\n+┊  ┊17┊      const { container, getByTestId } = render(<ChatNavbar chat={chat} />)\n+┊  ┊18┊\n+┊  ┊19┊      expect(getByTestId('chat-name')).toHaveTextContent('Foo Bar')\n+┊  ┊20┊      expect(getByTestId('chat-picture')).toHaveAttribute('src', 'https://localhost:4000/picture.jpg')\n+┊  ┊21┊    }\n+┊  ┊22┊  })\n+┊  ┊23┊\n+┊  ┊24┊  it('goes back on arrow click', async () => {\n+┊  ┊25┊    const chat = {\n+┊  ┊26┊      id: '1',\n+┊  ┊27┊      name: 'Foo Bar',\n+┊  ┊28┊      picture: 'https://localhost:4000/picture.jpg',\n+┊  ┊29┊    }\n+┊  ┊30┊\n+┊  ┊31┊    const history = createMemoryHistory()\n+┊  ┊32┊\n+┊  ┊33┊    history.push('/chats/1')\n+┊  ┊34┊\n+┊  ┊35┊    await wait(() =>\n+┊  ┊36┊      expect(history.location.pathname).toEqual('/chats/1')\n+┊  ┊37┊    )\n+┊  ┊38┊\n+┊  ┊39┊    {\n+┊  ┊40┊      const { container, getByTestId } = render(<ChatNavbar chat={chat} history={history} />)\n+┊  ┊41┊\n+┊  ┊42┊      fireEvent.click(getByTestId('back-button'))\n+┊  ┊43┊\n+┊  ┊44┊      await wait(() =>\n+┊  ┊45┊        expect(history.location.pathname).toEqual('/')\n+┊  ┊46┊      )\n+┊  ┊47┊    }\n+┊  ┊48┊  })\n+┊  ┊49┊})\n```\n\n##### Changed src&#x2F;components&#x2F;ChatRoomScreen&#x2F;ChatNavbar.tsx\n```diff\n@@ -28,7 +28,7 @@\n ┊28┊28┊  border-radius: 50%;\n ┊29┊29┊`\n ┊30┊30┊\n-┊31┊  ┊const Title = styled.div `\n+┊  ┊31┊const Name = styled.div `\n ┊32┊32┊  line-height: 56px;\n ┊33┊33┊`\n ┊34┊34┊\n```\n```diff\n@@ -39,11 +39,11 @@\n ┊39┊39┊\n ┊40┊40┊  return (\n ┊41┊41┊    <Style className={name}>\n-┊42┊  ┊      <BackButton onClick={navBack}>\n+┊  ┊42┊      <BackButton data-testid=\"back-button\" onClick={navBack}>\n ┊43┊43┊        <ArrowBackIcon />\n ┊44┊44┊      </BackButton>\n-┊45┊  ┊      <Picture src={chat.picture} />\n-┊46┊  ┊      <Title>{chat.name}</Title>\n+┊  ┊45┊      <Picture data-testid=\"chat-picture\" src={chat.picture} />\n+┊  ┊46┊      <Name data-testid=\"chat-name\">{chat.name}</Name>\n ┊47┊47┊    </Style>\n ┊48┊48┊  )\n ┊49┊49┊}\n```\n\n##### Added src&#x2F;components&#x2F;ChatRoomScreen&#x2F;MessageInput.test.tsx\n```diff\n@@ -0,0 +1,47 @@\n+┊  ┊ 1┊import { createMemoryHistory } from 'history'\n+┊  ┊ 2┊import React from 'react'\n+┊  ┊ 3┊import { cleanup, render, fireEvent, wait, waitForElement } from 'react-testing-library'\n+┊  ┊ 4┊import MessageInput from './MessageInput'\n+┊  ┊ 5┊\n+┊  ┊ 6┊describe('MessageInput', () => {\n+┊  ┊ 7┊  afterEach(cleanup)\n+┊  ┊ 8┊\n+┊  ┊ 9┊  it('triggers callback on send button click', async () => {\n+┊  ┊10┊    const onSendMessage = jest.fn(() => {})\n+┊  ┊11┊\n+┊  ┊12┊    {\n+┊  ┊13┊      const { container, getByTestId } = render(<MessageInput onSendMessage={onSendMessage} />)\n+┊  ┊14┊      const messageInput = getByTestId('message-input')\n+┊  ┊15┊      const sendButton = getByTestId('send-button')\n+┊  ┊16┊\n+┊  ┊17┊      fireEvent.change(messageInput, { target: { value: 'foo' } })\n+┊  ┊18┊\n+┊  ┊19┊      await waitForElement(() => messageInput)\n+┊  ┊20┊\n+┊  ┊21┊      fireEvent.click(sendButton)\n+┊  ┊22┊\n+┊  ┊23┊      await wait(() =>\n+┊  ┊24┊        expect(onSendMessage.mock.calls.length).toBe(1)\n+┊  ┊25┊      )\n+┊  ┊26┊    }\n+┊  ┊27┊  })\n+┊  ┊28┊\n+┊  ┊29┊  it('triggers callback on Enter press', async () => {\n+┊  ┊30┊    const onSendMessage = jest.fn(() => {})\n+┊  ┊31┊\n+┊  ┊32┊    {\n+┊  ┊33┊      const { container, getByTestId } = render(<MessageInput onSendMessage={onSendMessage} />)\n+┊  ┊34┊      const messageInput = getByTestId('message-input')\n+┊  ┊35┊\n+┊  ┊36┊      fireEvent.change(messageInput, { target: { value: 'foo' } })\n+┊  ┊37┊\n+┊  ┊38┊      await waitForElement(() => messageInput)\n+┊  ┊39┊\n+┊  ┊40┊      fireEvent.keyPress(messageInput, { key: 'Enter', code: 13, charCode: 13 })\n+┊  ┊41┊\n+┊  ┊42┊      await wait(() =>\n+┊  ┊43┊        expect(onSendMessage.mock.calls.length).toBe(1)\n+┊  ┊44┊      )\n+┊  ┊45┊    }\n+┊  ┊46┊  })\n+┊  ┊47┊})\n```\n\n##### Changed src&#x2F;components&#x2F;ChatRoomScreen&#x2F;MessageInput.tsx\n```diff\n@@ -66,6 +66,7 @@\n ┊66┊66┊  return (\n ┊67┊67┊    <Container>\n ┊68┊68┊      <ActualInput\n+┊  ┊69┊        data-testid=\"message-input\"\n ┊69┊70┊        type=\"text\"\n ┊70┊71┊        placeholder=\"Type a message\"\n ┊71┊72┊        value={message}\n```\n```diff\n@@ -73,6 +74,7 @@\n ┊73┊74┊        onChange={onChange}\n ┊74┊75┊      />\n ┊75┊76┊      <SendButton\n+┊  ┊77┊        data-testid=\"send-button\"\n ┊76┊78┊        variant=\"contained\"\n ┊77┊79┊        color=\"primary\"\n ┊78┊80┊        onClick={submitMessage}\n```\n\n##### Added src&#x2F;components&#x2F;ChatRoomScreen&#x2F;MessagesList.test.tsx\n```diff\n@@ -0,0 +1,37 @@\n+┊  ┊ 1┊import { createMemoryHistory } from 'history'\n+┊  ┊ 2┊import React from 'react'\n+┊  ┊ 3┊import { cleanup, render, fireEvent, wait, getByTestId } from 'react-testing-library'\n+┊  ┊ 4┊import MessagesList from './MessagesList'\n+┊  ┊ 5┊\n+┊  ┊ 6┊describe('MessagesList', () => {\n+┊  ┊ 7┊  afterEach(cleanup)\n+┊  ┊ 8┊\n+┊  ┊ 9┊  it('renders messages data', () => {\n+┊  ┊10┊    const messages = [\n+┊  ┊11┊      {\n+┊  ┊12┊        id: '1',\n+┊  ┊13┊        content: 'foo',\n+┊  ┊14┊        createdAt: new Date(0),\n+┊  ┊15┊      },\n+┊  ┊16┊      {\n+┊  ┊17┊        id: '2',\n+┊  ┊18┊        content: 'bar',\n+┊  ┊19┊        createdAt: new Date(1000 * 60 * 60),\n+┊  ┊20┊      },\n+┊  ┊21┊    ]\n+┊  ┊22┊\n+┊  ┊23┊    let message1, message2\n+┊  ┊24┊    {\n+┊  ┊25┊      const { container, getAllByTestId, getByTestId } = render(<MessagesList messages={messages} />)\n+┊  ┊26┊      const match = getAllByTestId('message-item')\n+┊  ┊27┊      message1 = match[0]\n+┊  ┊28┊      message2 = match[1]\n+┊  ┊29┊    }\n+┊  ┊30┊\n+┊  ┊31┊    expect(getByTestId(message1, 'message-content')).toHaveTextContent('foo')\n+┊  ┊32┊    expect(getByTestId(message1, 'message-date')).toHaveTextContent('08:00')\n+┊  ┊33┊\n+┊  ┊34┊    expect(getByTestId(message2, 'message-content')).toHaveTextContent('bar')\n+┊  ┊35┊    expect(getByTestId(message2, 'message-date')).toHaveTextContent('09:00')\n+┊  ┊36┊  })\n+┊  ┊37┊})\n```\n\n##### Changed src&#x2F;components&#x2F;ChatRoomScreen&#x2F;MessagesList.tsx\n```diff\n@@ -63,9 +63,9 @@\n ┊63┊63┊  return (\n ┊64┊64┊    <Container>\n ┊65┊65┊      {messages.map((message) => (\n-┊66┊  ┊        <MessageItem key={message.id}>\n-┊67┊  ┊          <Contents>{message.content}</Contents>\n-┊68┊  ┊          <Timestamp>{moment(message.createdAt).format('HH:mm')}</Timestamp>\n+┊  ┊66┊        <MessageItem data-testid=\"message-item\" key={message.id}>\n+┊  ┊67┊          <Contents data-testid=\"message-content\">{message.content}</Contents>\n+┊  ┊68┊          <Timestamp data-testid=\"message-date\">{moment(message.createdAt).format('HH:mm')}</Timestamp>\n ┊69┊69┊        </MessageItem>\n ┊70┊70┊      ))}\n ┊71┊71┊    </Container>\n```\n\n[}]: #\n\nThere are many things which are incomplete in the current implementation. The functionality exists in the UI, but no messages are really being sent and stored in the database. In the next chapters we will learn how to:\n\n\n\n*   Cache query results with Apollo-Client.\n*   Send messages with GraphQL mutations"
          },
          {
            "manualTitle": "Step 7: Caching with Apollo-Client",
            "stepRevision": "4334aacdcee9621e89b244dfd77548101bdd25dd",
            "manualView": "In the previous step we've implemented a `ChatRoomScreen` where we were able to view each chat's messages list by clicking on a chat item from the main screen. It all looks functional, however, there's a significant optimization issue - each time we navigate into a `ChatRoomScreen`, we need to re-fetch the data related to the target chat.\n\nThe solution for that would be [caching](https://en.wikipedia.org/wiki/Cache_(computing)) the fetch result, so it can be re-used once we re-enter a screen that we've visited before. For now things are fairly simple so the caching mechanism can be implemented manually, but things are gonna get tougher when we add more queries or things like message sending and profile updating to the mix, so it's not gonna be an easy task. Luckily, in the Apollo team they've invented a solution that works right out of the box and integrates perfectly with Apollo-GraphQL server - [Apollo-GraphQL client](https://www.apollographql.com/docs/link/#apollo-client).\n\n\n\n![caching](https://user-images.githubusercontent.com/7648874/54871150-f505e100-4dea-11e9-9e2d-439fbf3eaebe.png)\n\n\n\nApollo-Client is a wrap around our GraphQL REST endpoint which essentially uses HTTP requests (and further on [web-sockets](https://en.wikipedia.org/wiki/WebSocket), but we will get there), something that we've implemented manually so far. Not only it can be used to fetch data, but it will also cache the result of the query so it can be seamlessly re-used when we request the same data. This means that we will need to setup an Apollo-Client and replace all our `fetch()` calls with `client.query()` call. More about Apollo-Client's API further in this tutorial, but let's start configuring it. First we will install few essential NPM packages:\n\n  $ npm install apollo-cache-inmemory apollo-client apollo-link apollo-link-http\n\n\n\n*   [`apollo-client`](https://www.npmjs.com/package/apollo-client) - Apollo-Client's core package, as we explained earlier.\n*   [`apollo-cache-inmemory`](https://www.npmjs.com/package/apollo-cache-inmemory) - The data store that will be used to cache the results.\n*   [`apollo-link-http`](https://www.npmjs.com/package/apollo-link-http) - Get GraphQL results over a network using HTTP fetch.\n\nWe will create a new file in the `src` directory called `client.ts` and inside we will export the client:\n\n[{]: <helper> (diffStep 7.1 files=\"client\" module=\"client\")\n\n#### [Step 7.1: Add Apollo client](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/e1d76bc)\n\n##### Added src&#x2F;client.ts\n```diff\n@@ -0,0 +1,16 @@\n+┊  ┊ 1┊import { InMemoryCache } from 'apollo-cache-inmemory'\n+┊  ┊ 2┊import { ApolloClient } from 'apollo-client'\n+┊  ┊ 3┊import { HttpLink } from 'apollo-link-http'\n+┊  ┊ 4┊\n+┊  ┊ 5┊const httpUri = process.env.REACT_APP_SERVER_URL + '/graphql'\n+┊  ┊ 6┊\n+┊  ┊ 7┊const httpLink = new HttpLink({\n+┊  ┊ 8┊  uri: httpUri,\n+┊  ┊ 9┊})\n+┊  ┊10┊\n+┊  ┊11┊const inMemoryCache = new InMemoryCache()\n+┊  ┊12┊\n+┊  ┊13┊export default new ApolloClient({\n+┊  ┊14┊  link: httpLink,\n+┊  ┊15┊  cache: inMemoryCache,\n+┊  ┊16┊})\n```\n\n[}]: #\n\nAlthough the client can be used directly and integrated into any UI framework, it would be the most comfortable to use a wrap around it which is suitable for React. For that we will use a package called [`react-apollo-hooks`](https://www.npmjs.com/package/react-apollo-hooks) which includes a set of [React hooks](https://reactjs.org/docs/hooks-intro.html) that can connect between our Apollo-Client and target React.Component:\n\n  $ npm install react-apollo-hooks graphql-tag\n\nWith `react-apollo-hooks` we can use the `useQuery()` hook to fetch data from our GraphQL API. The `graphql-tag` package is used to parse the GraphQL string to an [AST](https://en.wikipedia.org/wiki/Abstract_syntax_tree), something which is required when using Apollo Client. Example:\n\n\n```\nimport gql from 'graphql-tag';\nimport { useQuery } from 'react-apollo-hooks';\n\nconst GET_DOGS = gql`\n  {\n    dogs {\n      id\n      breed\n    }\n  }\n`;\n\nconst Dogs = () => {\n  const { data, error, loading } = useQuery(GET_DOGS);\n  if (loading) {\n    return <div>Loading...</div>;\n  };\n  if (error) {\n    return <div>Error! {error.message}</div>;\n  };\n\n  return (\n    <ul>\n      {data.dogs.map(dog => (\n        <li key={dog.id}>{dog.breed}</li>\n      ))}\n    </ul>\n  );\n};\n```\n\n\nThe package requires a small setup so that imported hooks can use our Apollo-Client:\n\n[{]: <helper> (diffStep 7.2 files=\"index\" module=\"client\")\n\n#### [Step 7.2: Provide Apollo client](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/016ecb9)\n\n##### Changed src&#x2F;index.jsx\n```diff\n@@ -1,8 +1,10 @@\n ┊ 1┊ 1┊import { MuiThemeProvider, createMuiTheme } from '@material-ui/core/styles'\n ┊ 2┊ 2┊import React from 'react';\n ┊ 3┊ 3┊import ReactDOM from 'react-dom';\n+┊  ┊ 4┊import { ApolloProvider } from 'react-apollo-hooks'\n ┊ 4┊ 5┊import './index.css';\n ┊ 5┊ 6┊import App from './App';\n+┊  ┊ 7┊import client from './client'\n ┊ 6┊ 8┊import * as serviceWorker from './serviceWorker';\n ┊ 7┊ 9┊\n ┊ 8┊10┊const theme = createMuiTheme({\n```\n```diff\n@@ -17,7 +19,9 @@\n ┊17┊19┊\n ┊18┊20┊ReactDOM.render(\n ┊19┊21┊  <MuiThemeProvider theme={theme}>\n-┊20┊  ┊    <App />\n+┊  ┊22┊    <ApolloProvider client={client}>\n+┊  ┊23┊      <App />\n+┊  ┊24┊    </ApolloProvider>\n ┊21┊25┊  </MuiThemeProvider>\n ┊22┊26┊, document.getElementById('root'));\n```\n\n[}]: #\n\nThe code above uses the [Context/Provider](https://reactjs.org/docs/context.html) API, thus the client is now known globally. Now that we can use the `useQuery()` hook, there's no need to use the native Fetch API anymore. Let's replace all our Fetch API call instances with a React hook:\n\n[{]: <helper> (diffStep 7.3 files=\"components\" module=\"client\")\n\n#### [Step 7.3: Replace fetch() calls with useQuery()](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/b497532)\n\n##### Changed src&#x2F;components&#x2F;ChatRoomScreen&#x2F;index.tsx\n```diff\n@@ -1,5 +1,7 @@\n+┊ ┊1┊import gql from 'graphql-tag'\n ┊1┊2┊import * as React from 'react'\n-┊2┊ ┊import { useCallback, useMemo, useState } from 'react'\n+┊ ┊3┊import { useCallback } from 'react'\n+┊ ┊4┊import { useApolloClient, useQuery } from 'react-apollo-hooks'\n ┊3┊5┊import styled from 'styled-components'\n ┊4┊6┊import ChatNavbar from './ChatNavbar'\n ┊5┊7┊import MessageInput from './MessageInput'\n```\n```diff\n@@ -12,7 +14,7 @@\n ┊12┊14┊  height: 100vh;\n ┊13┊15┊`\n ┊14┊16┊\n-┊15┊  ┊const getChatQuery = `\n+┊  ┊17┊const getChatQuery = gql `\n ┊16┊18┊  query GetChat($chatId: ID!) {\n ┊17┊19┊    chat(chatId: $chatId) {\n ┊18┊20┊      id\n```\n```diff\n@@ -29,22 +31,10 @@\n ┊29┊31┊\n ┊30┊32┊const ChatRoomScreen = ({ history, match }) => {\n ┊31┊33┊  const { params: { chatId } } = match\n-┊32┊  ┊  const [chat, setChat] = useState(null)\n-┊33┊  ┊\n-┊34┊  ┊  useMemo(async () => {\n-┊35┊  ┊    const body = await fetch(`${process.env.REACT_APP_SERVER_URL}/graphql`, {\n-┊36┊  ┊      method: 'POST',\n-┊37┊  ┊      headers: {\n-┊38┊  ┊        'Content-Type': 'application/json',\n-┊39┊  ┊      },\n-┊40┊  ┊      body: JSON.stringify({\n-┊41┊  ┊        query: getChatQuery,\n-┊42┊  ┊        variables: { chatId },\n-┊43┊  ┊      }),\n-┊44┊  ┊    })\n-┊45┊  ┊    const { data: { chat } } = await body.json()\n-┊46┊  ┊    setChat(chat)\n-┊47┊  ┊  }, [true])\n+┊  ┊34┊  const client = useApolloClient()\n+┊  ┊35┊  const { data: { chat } } = useQuery(getChatQuery, {\n+┊  ┊36┊    variables: { chatId }\n+┊  ┊37┊  })\n ┊48┊38┊\n ┊49┊39┊  const onSendMessage = useCallback((content) => {\n ┊50┊40┊    const message = {\n```\n```diff\n@@ -53,9 +43,13 @@\n ┊53┊43┊      content,\n ┊54┊44┊    }\n ┊55┊45┊\n-┊56┊  ┊    setChat({\n-┊57┊  ┊      ...chat,\n-┊58┊  ┊      messages: chat.messages.concat(message),\n+┊  ┊46┊    client.writeQuery({\n+┊  ┊47┊      query: getChatQuery,\n+┊  ┊48┊      variables: { chatId },\n+┊  ┊49┊      data: {\n+┊  ┊50┊        ...chat,\n+┊  ┊51┊        messages: chat.messages.concat(message),\n+┊  ┊52┊      },\n ┊59┊53┊    })\n ┊60┊54┊  }, [chat])\n ┊61┊55┊\n```\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;ChatsList.tsx\n```diff\n@@ -1,7 +1,9 @@\n ┊1┊1┊import { List, ListItem } from '@material-ui/core'\n+┊ ┊2┊import gql from 'graphql-tag'\n ┊2┊3┊import moment from 'moment'\n ┊3┊4┊import * as React from 'react'\n-┊4┊ ┊import { useCallback, useState, useMemo } from 'react'\n+┊ ┊5┊import { useCallback } from 'react'\n+┊ ┊6┊import { useQuery } from 'react-apollo-hooks'\n ┊5┊7┊import styled from 'styled-components'\n ┊6┊8┊\n ┊7┊9┊const Container = styled.div `\n```\n```diff\n@@ -55,7 +57,7 @@\n ┊55┊57┊  font-size: 13px;\n ┊56┊58┊`\n ┊57┊59┊\n-┊58┊  ┊const getChatsQuery = `\n+┊  ┊60┊const getChatsQuery = gql `\n ┊59┊61┊  query GetChats {\n ┊60┊62┊    chats {\n ┊61┊63┊      id\n```\n```diff\n@@ -71,19 +73,7 @@\n ┊71┊73┊`\n ┊72┊74┊\n ┊73┊75┊const ChatsList = ({ history }) => {\n-┊74┊  ┊  const [chats, setChats] = useState([])\n-┊75┊  ┊\n-┊76┊  ┊  useMemo(async () => {\n-┊77┊  ┊    const body = await fetch(`${process.env.REACT_APP_SERVER_URL}/graphql`, {\n-┊78┊  ┊      method: 'POST',\n-┊79┊  ┊      headers: {\n-┊80┊  ┊        'Content-Type': 'application/json',\n-┊81┊  ┊      },\n-┊82┊  ┊      body: JSON.stringify({ query: getChatsQuery }),\n-┊83┊  ┊    })\n-┊84┊  ┊    const { data: { chats } } = await body.json()\n-┊85┊  ┊    setChats(chats)\n-┊86┊  ┊  }, [true])\n+┊  ┊76┊  const { data: { chats = [] } } = useQuery(getChatsQuery)\n ┊87┊77┊\n ┊88┊78┊  const navToChat = useCallback((chat) => {\n ┊89┊79┊    history.push(`chats/${chat.id}`)\n```\n\n[}]: #\n\nThe replacement is finished. Note that we removed the usage of `useMemo()` - because Apollo has an internal cache mechanism, there's no need to memoize the result anymore. We also used the [`writeQuery()`](https://www.apollographql.com/docs/react/features/caching.html#writequery-and-writefragment) method to edit the stored result in the cache, so in the next render phase we would have an updated chat with the newly added message.\n\nWe shouldn't feel any change at all in the view and the response time, since we're running it locally, but if we will take a look at the `network` tab in the browser's dev-tools we should notice the differences:\n\n**before**\n\n![fetch](https://user-images.githubusercontent.com/7648874/54871305-e5879780-4dec-11e9-87bb-3279e9e18342.png)\n\n**after**\n\n![apollo](https://user-images.githubusercontent.com/7648874/54871319-1bc51700-4ded-11e9-9001-d5518bedf9ad.png)\n\n> Above: ChatsListScreen -> ChatRoomScreen -> ChatsListScreen -> ChatRoomScreen\n\nThis test is obviously very rough, but the deviation is so big that you don't need any accuracy to emphasize the difference. The blue stripes represents the requests made and the time they took. Before we had about 6 request phases, while after we had only 3 of them.\n\nSince we don't use the Fetch API anymore, we will also need to update our tests. Right now we mock the response from the fetch API, but a more appropriate way would be creating a fake Apollo Client where we will be able to mock the results. For that we will install a package called [`apollo-link-mock`](https://www.npmjs.com/package/apollo-link-mock):\n\n    $ npm install --dev apollo-link-mock\n\nAnd we will create a `test-helpers.ts` file under the `src` directory that will contain the utility function for creating a fake Apollo Client:\n\n[{]: <helper> (diffStep 7.4 files=\"test-helpers\" module=\"client\")\n\n#### [Step 7.4: Mock GraphQL requests in tests](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/929d26f)\n\n##### Added src&#x2F;test-helpers.ts\n```diff\n@@ -0,0 +1,10 @@\n+┊  ┊ 1┊import { InMemoryCache } from 'apollo-cache-inmemory'\n+┊  ┊ 2┊import { ApolloClient } from 'apollo-client'\n+┊  ┊ 3┊import { MockLink } from 'apollo-link-mock'\n+┊  ┊ 4┊\n+┊  ┊ 5┊export const mockApolloClient = (mocks) => {\n+┊  ┊ 6┊  return new ApolloClient({\n+┊  ┊ 7┊    cache: new InMemoryCache(),\n+┊  ┊ 8┊    link: new MockLink(mocks),\n+┊  ┊ 9┊  })\n+┊  ┊10┊}\n```\n\n[}]: #\n\nThe fake client accepts an array of mocks where each mock object will have a `request` key that will contain details about the request and a `result` key which will contain the mocked result. You should get a better understanding of how it works now that we will replace the fake Fetch calls with fake Apollo Clients:\n\n[{]: <helper> (diffStep 7.4 files=\"src/components\" module=\"client\")\n\n#### [Step 7.4: Mock GraphQL requests in tests](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/929d26f)\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;ChatsList.test.tsx\n```diff\n@@ -1,8 +1,10 @@\n ┊ 1┊ 1┊import { createBrowserHistory } from 'history'\n ┊ 2┊ 2┊import React from 'react'\n+┊  ┊ 3┊import { ApolloProvider } from 'react-apollo-hooks'\n ┊ 3┊ 4┊import ReactDOM from 'react-dom'\n ┊ 4┊ 5┊import { cleanup, render, fireEvent, wait, waitForDomChange } from 'react-testing-library'\n-┊ 5┊  ┊import ChatsList from './ChatsList'\n+┊  ┊ 6┊import { mockApolloClient } from '../../test-helpers'\n+┊  ┊ 7┊import ChatsList, { getChatsQuery } from './ChatsList'\n ┊ 6┊ 8┊\n ┊ 7┊ 9┊describe('ChatsList', () => {\n ┊ 8┊10┊  afterEach(() => {\n```\n```diff\n@@ -11,25 +13,36 @@\n ┊11┊13┊  })\n ┊12┊14┊\n ┊13┊15┊  it('renders fetched chats data', async () => {\n-┊14┊  ┊    fetch.mockResponseOnce(JSON.stringify({\n-┊15┊  ┊      data: {\n-┊16┊  ┊        chats: [\n-┊17┊  ┊          {\n-┊18┊  ┊            id: 1,\n-┊19┊  ┊            name: 'Foo Bar',\n-┊20┊  ┊            picture: 'https://localhost:4000/picture.jpg',\n-┊21┊  ┊            lastMessage: {\n-┊22┊  ┊              id: 1,\n-┊23┊  ┊              content: 'Hello',\n-┊24┊  ┊              createdAt: new Date(0),\n-┊25┊  ┊            },\n+┊  ┊16┊    const client = mockApolloClient([\n+┊  ┊17┊      {\n+┊  ┊18┊        request: { query: getChatsQuery },\n+┊  ┊19┊        result: {\n+┊  ┊20┊          data: {\n+┊  ┊21┊            chats: [\n+┊  ┊22┊              {\n+┊  ┊23┊                __typename: 'Chat',\n+┊  ┊24┊                id: 1,\n+┊  ┊25┊                name: 'Foo Bar',\n+┊  ┊26┊                picture: 'https://localhost:4000/picture.jpg',\n+┊  ┊27┊                lastMessage: {\n+┊  ┊28┊                  __typename: 'Message',\n+┊  ┊29┊                  id: 1,\n+┊  ┊30┊                  content: 'Hello',\n+┊  ┊31┊                  createdAt: new Date(0),\n+┊  ┊32┊                },\n+┊  ┊33┊              },\n+┊  ┊34┊            ],\n ┊26┊35┊          },\n-┊27┊  ┊        ],\n+┊  ┊36┊        },\n ┊28┊37┊      },\n-┊29┊  ┊    }))\n+┊  ┊38┊    ])\n ┊30┊39┊\n ┊31┊40┊    {\n-┊32┊  ┊      const { container, getByTestId } = render(<ChatsList />)\n+┊  ┊41┊      const { container, getByTestId } = render(\n+┊  ┊42┊        <ApolloProvider client={client}>\n+┊  ┊43┊          <ChatsList />\n+┊  ┊44┊        </ApolloProvider>\n+┊  ┊45┊      )\n ┊33┊46┊\n ┊34┊47┊      await waitForDomChange({ container })\n ┊35┊48┊\n```\n```diff\n@@ -41,27 +54,38 @@\n ┊41┊54┊  })\n ┊42┊55┊\n ┊43┊56┊  it('should navigate to the target chat room on chat item click', async () => {\n-┊44┊  ┊    fetch.mockResponseOnce(JSON.stringify({\n-┊45┊  ┊      data: {\n-┊46┊  ┊        chats: [\n-┊47┊  ┊          {\n-┊48┊  ┊            id: 1,\n-┊49┊  ┊            name: 'Foo Bar',\n-┊50┊  ┊            picture: 'https://localhost:4000/picture.jpg',\n-┊51┊  ┊            lastMessage: {\n-┊52┊  ┊              id: 1,\n-┊53┊  ┊              content: 'Hello',\n-┊54┊  ┊              createdAt: new Date(0),\n-┊55┊  ┊            },\n+┊  ┊57┊    const client = mockApolloClient([\n+┊  ┊58┊      {\n+┊  ┊59┊        request: { query: getChatsQuery },\n+┊  ┊60┊        result: {\n+┊  ┊61┊          data: {\n+┊  ┊62┊            chats: [\n+┊  ┊63┊              {\n+┊  ┊64┊                __typename: 'Chat',\n+┊  ┊65┊                id: 1,\n+┊  ┊66┊                name: 'Foo Bar',\n+┊  ┊67┊                picture: 'https://localhost:4000/picture.jpg',\n+┊  ┊68┊                lastMessage: {\n+┊  ┊69┊                  __typename: 'Message',\n+┊  ┊70┊                  id: 1,\n+┊  ┊71┊                  content: 'Hello',\n+┊  ┊72┊                  createdAt: new Date(0),\n+┊  ┊73┊                },\n+┊  ┊74┊              },\n+┊  ┊75┊            ],\n ┊56┊76┊          },\n-┊57┊  ┊        ],\n+┊  ┊77┊        },\n ┊58┊78┊      },\n-┊59┊  ┊    }))\n+┊  ┊79┊    ])\n ┊60┊80┊\n ┊61┊81┊    const history = createBrowserHistory()\n ┊62┊82┊\n ┊63┊83┊    {\n-┊64┊  ┊      const { container, getByTestId } = render(<ChatsList history={history} />)\n+┊  ┊84┊      const { container, getByTestId } = render(\n+┊  ┊85┊        <ApolloProvider client={client}>\n+┊  ┊86┊          <ChatsList history={history} />\n+┊  ┊87┊        </ApolloProvider>\n+┊  ┊88┊      )\n ┊65┊89┊\n ┊66┊90┊      await waitForDomChange({ container })\n ┊67┊91┊\n```\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;ChatsList.tsx\n```diff\n@@ -57,7 +57,7 @@\n ┊57┊57┊  font-size: 13px;\n ┊58┊58┊`\n ┊59┊59┊\n-┊60┊  ┊const getChatsQuery = gql `\n+┊  ┊60┊export const getChatsQuery = gql `\n ┊61┊61┊  query GetChats {\n ┊62┊62┊    chats {\n ┊63┊63┊      id\n```\n\n[}]: #\n\nNote how we used the `ApolloProvider` component to provide the target component with the fake Apollo Client. Like so, any other component which uses Apollo Client should be wrapped with an ApolloProvider when rendering it, otherwise it will not function as intended:\n\n[{]: <helper> (diffStep 7.4 files=\"src/App\" module=\"client\")\n\n#### [Step 7.4: Mock GraphQL requests in tests](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/929d26f)\n\n##### Changed src&#x2F;App.test.js\n```diff\n@@ -1,9 +1,17 @@\n ┊ 1┊ 1┊import React from 'react';\n+┊  ┊ 2┊import { ApolloProvider } from 'react-apollo-hooks'\n ┊ 2┊ 3┊import ReactDOM from 'react-dom';\n ┊ 3┊ 4┊import App from './App';\n+┊  ┊ 5┊import { mockApolloClient } from './test-helpers'\n ┊ 4┊ 6┊\n ┊ 5┊ 7┊it('renders without crashing', () => {\n+┊  ┊ 8┊  const client = mockApolloClient()\n ┊ 6┊ 9┊  const div = document.createElement('div');\n-┊ 7┊  ┊  ReactDOM.render(<App />, div);\n+┊  ┊10┊\n+┊  ┊11┊  ReactDOM.render(\n+┊  ┊12┊    <ApolloProvider client={client}>\n+┊  ┊13┊      <App />\n+┊  ┊14┊    </ApolloProvider>\n+┊  ┊15┊  , div);\n ┊ 8┊16┊  ReactDOM.unmountComponentAtNode(div);\n ┊ 9┊17┊});\n```\n\n[}]: #\n\nThat's it for this chapter. There's one thing missing to make our `ChatRoomScreen` functional and that would be actually sending a message to the backend and updating the DB. In the next chapter we will learn how to do exactly that with our new Apollo-Client."
          }
        ]
      }
    ]
  }
]
