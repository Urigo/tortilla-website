[
  {
    "repoUrl": "https://github.com/Urigo/WhatsApp-Clone-Tutorial",
    "branchName": "final",
    "historyBranchName": "final-history",
    "releases": [
      {
        "releaseVersion": "next",
        "releaseDate": "2019-04-12 14:12:54 +0800",
        "tagName": "final@next",
        "tagRevision": "a6c217fae29a6815aebb44433cf242619ba39ddf",
        "historyRevision": "38ed937b9303c3167a9b5e6a28fb3d88bb9e0923",
        "changesDiff": "diff --git a/.gitignore b/.gitignore\nnew file mode 100644\nindex 0000000..5171c54\n--- /dev/null\n+++ b/.gitignore\n@@ -0,0 +1,2 @@\n+node_modules\n+npm-debug.log\n\\ No newline at end of file\ndiff --git a/.tortilla/manuals/templates/root.tmpl b/.tortilla/manuals/templates/root.tmpl\nnew file mode 100644\nindex 0000000..140693f\n--- /dev/null\n+++ b/.tortilla/manuals/templates/root.tmpl\n@@ -0,0 +1,80 @@\n+![whatsapp-clone](https://user-images.githubusercontent.com/7648874/54141944-9f801a80-4461-11e9-85a1-bcb161d9a6c6.png)\n+\n+Whatsapp Clone is an open-source tutorial that will guide you through step-by-step on how to create a full-stack hybrid web-app.\n+\n+The software world is evolving quickly, and oftentimes people find themselves left behind, even the most experienced ones. The purpose of this tutorial is to completely demystify the confusion, and be the main guide on how to do things properly.\n+\n+This tutorial is for anyone who has ever asked himself or herself one of the following questions or similar:\n+\n+- How do people build an app today?\n+- What are the “hottest”, most leading technologies currently in the ecosystem?\n+- What are the best practices for using technology XXX?\n+- What is the purpose of technology XXX?\n+- How does technology XXX work?\n+- How do I use technology XXX?\n+- How do I migrate to the new version of technology XXX?\n+- Why should I use technology XXX over technology YYY?\n+\n+All of the above and more can be answered in the tutorial. Whether you’re a beginner, intermediate or a professional, we will have the answers you’re looking for.\n+\n+**What technologies does Whatsapp Clone uses?**\n+\n+Currently, Whatsapp Clone uses:\n+\n+- [React (with Hooks and Suspense)](http://react.com)\n+- [Styled-Components](https://styled-components.com)\n+- [Material-UI](https://material-ui.com)\n+- [TypeScript](https://typescriptlang.org)\n+- [Apollo GraphQL](https://www.apollographql.com)\n+- [GraphQL Code Generator](http://graphql-code-generator.com)\n+- [GraphQL Modules](https://graphql-modules.com)\n+- [PostgreSQL](https://www.postgresql.org/)\n+- [TypeORM](https://github.com/typeorm/typeorm)\n+\n+The point of this tutorial is not to be bound to a certain technology, but rather keep itself aligned with the ecosystem. When a new technology comes out, and it’s better and more popular, Whatsapp Clone will use it at some point (and full migration instructions).\n+\n+**P2P tutorial for the community by the community**\n+\n+What better way would it be to keep Whatsapp Clone aligned with the ecosystem than letting the community maintain it? Rather than dictating what technologies will be used in the app or how’s the tutorial gonna be written, you’re gonna decide how things are gonna be. That’s why we made it open source:\n+\n+- [Whatsapp Clone - Client](https://github.com/Urigo/WhatsApp-Clone-Client-React/tree/step-by-step-final)\n+- [Whatsapp Clone - Server](https://github.com/Urigo/WhatsApp-Clone-server/step-by-step-final)\n+\n+We’ve also made sure to publish some important documents so you can get more involved. You can track our progress and comment your suggestions, since everything is based on Google Docs and is updated live:\n+\n+- [Road map](https://docs.google.com/document/d/1p2Zio6Js2eoFfHs9CjIMF6jTuNyD4eQEHlgEAKhAqM8/edit?usp=sharing)\n+- [Chapter manuals] (https://drive.google.com/open?id=1ITxOniS_S3sgZfunLvtJ1L9P6Fj1YOLlFHhoQPjT3S0)\n+\n+**Migration instructions included**\n+\n+The are great tutorials out there, but almost none of them shows you what changes you should make in your app in order to be aligned with a new version of a certain technology. Technologies are being updated by the minute, some changes are minor and insignificant, but often times a breaking change will be made in which case we need to know how we can adapt to that change. Thanks to the [Tortilla platform](https://tortilla.academy), we can provide you with a git-diff that will show you what changes were made between each and every released version of the Whatsapp Clone tutorial since the beginning of history. This way you can easily notice the changes in APIs and migrate your app in no time.\n+\n+![tutorial-versions-diff](https://user-images.githubusercontent.com/7648874/54142148-0f8ea080-4462-11e9-9522-ec9997b76169.png)\n+\n+**Prerequisites**\n+\n+- JavaScript\n+- TypeScript\n+- JSX\n+- HTML\n+- CSS\n+- Node.JS\n+- NPM\n+- React\n+- SQL\n+\n+OS operations such as navigating to a folder, or creating a folder, are all gonna be written in Bash, but the instructions are OS agnostic and can be applied on any machine that is web-compatible.\n+\n+**What’s on the tutorial?**\n+\n+Whatsapp Clone is built chronologically, from the most basic, to more higher level features, so be sure to execute it in the right order. Each step is focused on a different subject, so by the end of it you’ll have a new feature and a new set of knowledge that you can start implementing in your everyday scenario immediately.\n+\n+Currently, Whatsapp Clone includes the following chapters:\n+\n+- [Step 1: Creating a basic React APP with a basic view.](https://github.com/Urigo/WhatsApp-Clone-Tutorial/blob/final/.tortilla/manuals/views/step1.md)\n+- [Step 2: Styling with Material-UI and Styled-Components.](https://github.com/Urigo/WhatsApp-Clone-Tutorial/blob/final/.tortilla/manuals/views/step2.md)\n+- [Step 3: Setting a basic Node.JS server with basic a basic REST endpoint.](https://github.com/Urigo/WhatsApp-Clone-Tutorial/blob/final/.tortilla/manuals/views/step3.md)\n+- [Step 4: Transition to GraphQL.](https://github.com/Urigo/WhatsApp-Clone-Tutorial/blob/final/.tortilla/manuals/views/step4.md)\n+- Step N: TBA\n+\n+Whatsapp Clone is updated on a regular basis, so you should expect more steps and extensions to it not long from now. You can keep track of our [road map](https://docs.google.com/document/d/1p2Zio6Js2eoFfHs9CjIMF6jTuNyD4eQEHlgEAKhAqM8/edit?usp=sharing) to see what’s upcoming.\ndiff --git a/.tortilla/manuals/templates/step1.tmpl b/.tortilla/manuals/templates/step1.tmpl\nnew file mode 100644\nindex 0000000..deed5cb\n--- /dev/null\n+++ b/.tortilla/manuals/templates/step1.tmpl\n@@ -0,0 +1,119 @@\n+In this chapter we will learn how to create a basic React app. The app will contain a basic view that will render a list of conversations within our app. Everything should be done gradually, so for now, instead of using real data, we will use in-memory fake data instead of calling a server.\n+\n+There are many ways to create an application. Indeed, you can create it from scratch, but the point behind development is that you'll make the least amount of work if possible. The point is to create a working product, and time is what matters, thus we're gonna use a boilerplate to kick-start our application. When it comes to React apps, the most popular is [`create-react-app`](https://github.com/facebook/create-react-app), which is pretty generic and easy to use. In addition, it's officially maintained by Facebook, the creators of React.\n+\n+`create-react-app` is a CLI that is installable via NPM:\n+\n+    $ npm install -g create-react-app\n+\n+Once you do so, you will have it available in your terminal. If the installation failed, try to run the command as `sudo`:\n+\n+\t$ sudo npm install -g create-react-app\n+\n+Using the `create` command, we can create the basis for our Whatsapp Clone:\n+\n+    $ create-react-app create whatsapp-clone-client\n+\n+> Note how we used the `client` prefix. That's because we're planning to create a server as well in further chapters.\n+\n+It will create a directory called `whatsapp-clone-client` inside the current folder. Inside that directory, it will generate the initial project structure and install the transitive dependencies:\n+\n+    my-app\n+    ├── README.md\n+    ├── node_modules\n+    ├── package.json\n+    ├── .gitignore\n+    ├── public\n+    │   ├── favicon.ico\n+    │   ├── index.html\n+    │   └── manifest.json\n+    └── src\n+        ├── App.css\n+        ├── App.js\n+        ├── App.test.js\n+        ├── index.css\n+        ├── index.js\n+        ├── logo.svg\n+        └── serviceWorker.js\n+\n+No configuration or complicated folder structures, just the files you need to build your app. Once the installation is done, you can open your project folder:\n+\n+\t$ cd whatsapp-clone-client\n+\n+Inside the newly created project, you can run some built-in commands:\n+\n+\t$ npm start\n+\n+Runs the app in development mode. Open `http://localhost:3000` to view it in the browser:\n+\n+![boilerplate-page](https://user-images.githubusercontent.com/7648874/54026782-025f8080-41da-11e9-9a4e-796fe15e8d03.png)\n+\n+The project that was created for us by `create-react-app` is highly functional and ready to use, but it's implemented in JavaScript. In our project, we're gonna use TypeScript. There's no right or wrong here, it's more of a personal choice. The main advantage of using TypeScript over using plain JavaScript is that we get to tell the compiler what types and data structures we expect in certain places, so that the compiler (which unlike a human never forgets) will remind us when we make a mistake and assume something that is not true.\n+\n+Luckily enough, `create-react-app` comes with a TypeScript support right out of the box, we only need to make a few adjustments in-order to make it work. First we need to install the TypeScript package, which is essential for TypeScript to function:\n+\n+\t$ yarn add typescript\n+\n+Every TypeScript project requires a `tsconfig.json` to be defined. This configuration file will dictate the behavior of TypeScript within that project. More about `tsconfig.json` and its available options can be found in the [official TypeScript handbook](https://www.typescriptlang.org/docs/handbook/tsconfig-json.html). This is the config file we're gonna use in our project:\n+\n+{{{ diffStep \"1.1\" module=\"client\" files=\"tsconfig.json\" }}}\n+\n+We're also gonna add a `tslint.json` file into the project - a file which will determine the linting preferences for our project. All rules are listed and explained in the [official rules doc page](https://palantir.github.io/tslint/rules/). We will use the following rules:\n+\n+{{{ diffStep \"1.1\" module=\"client\" files=\"tslint.json\" }}}\n+\n+Once we will run the app for the first time, `react-scripts` (`create-react-app` utility scripts package) should automatically initialize some additional TypeScript related files:\n+\n+\t$ npm start\n+\n+Since we're gonna use the new React [Hooks](https://reactjs.org/docs/hooks-intro.html) and [Suspense](https://reactjs.org/docs/react-api.html#reactsuspense) mechanisms, **make sure that your app uses React version 16.8 or above, otherwise it won't work.** The React version can be determined simply by looking at the `package.json` file. If by any chance your React version is lower than the required one, be sure to upgrade the version of `create-react-app` by upgrading it to the latest one and repeat the process of the project creation. Just in case, `create-react-app` can be upgrade by re-running the install command:\n+\n+\t$ npm install -g create-react-app\n+\n+Assuming that everything is set, we will now create our first screen - ChatsListScreen. The ChatsListScreen component is responsible for showing the active conversations within our app. Everything should be done gradually, so for now, instead of using real data, we will use in-memory fake data. Further in this tutorial, we will also create a server that will serve that data and connect it to our client.\n+\n+It's best to first schematically plan how our view's gonna look like. This would help us illustrate the intended view and also understand which React.Components / elements take part in it. This is how our screen's gonna look like:\n+\n+![chatslistscreen](https://user-images.githubusercontent.com/7648874/54027873-01305280-41de-11e9-9df0-5ad9c9c2f226.png)\n+\n+Let's break down the image above and see what components are we gonna have in the ChatsListScreen:\n+\n+- Navbar -  Which should contain a simple static title for now.\n+- ChatsList - Where each item's gonna contain some data regards the user we're chatting with and information about the chat.\n+\n+React apps tend to store React.Components under a directory located at `src/components`, and so we're gonna follow this pattern. We will create a directory called ChatsListScreen in the `components` dir where we're simply gonna import and put together the Navbar and ChatsList components. This is how the contents of that directory should look like:\n+\n+    ChatsListScreen\n+    ├── index.tsx\n+    ├── ChatsList\n+    └── ChatsNavbar\n+\n+We will use the `index.tsx` file to define that component, this way we can import it using the directory name:\n+\n+{{{ diffStep \"1.2\" module=\"client\" files=\"components/ChatsListScreen/index.jsx\" }}}\n+\n+Now we can implement the Navbar component, which doesn't have much for now except some text describing the app:\n+\n+{{{ diffStep \"1.2\" module=\"client\" files=\"components/ChatsListScreen/ChatsNavbar.jsx\" }}}\n+\n+And the ChatsList component:\n+\n+{{{ diffStep \"1.2\" module=\"client\" files=\"components/ChatsListScreen/ChatsList.jsx\" }}}\n+\n+You can see in the code-diff above how we used the [`moment`](https://momentjs.com/) library to wrap `lastMessage.createdAt`. Moment has the ability to wrap date objects nicely and rewrite them in a pretty format. This way we can have an elegant time format at which the message was sent e.g. `11:34`. To install:\n+\n+\t$ yarn add moment\n+\n+The ChatsList component has no event handlers and it's completely non-interactive as for now, that means that you can't click or tap anything yet, but as we go further in the tutorial we will add the necessary event handlers. Note how we used the `db.ts` module to get the chats data. `db.ts` is a temporary mock for our data-source and should be removed once we have a server up and running. Here's how our DB looks like:\n+\n+{{{ diffStep \"1.3\" module=\"client\" }}}\n+\n+The ChatsListScreen is now ready to use. We will replace the contents of the App component with the ChatsListScreen and we will make it the default screen in our app:\n+\n+{{{ diffStep \"1.4\" module=\"client\" files=\"App.jsx\" }}}\n+\n+If you'll try to run the app you'll see that everything is there, but it's not hard to notice that it's missing some style:\n+\n+![naked-chats-list](https://user-images.githubusercontent.com/7648874/54028578-73099b80-41e0-11e9-803a-7469300acb06.png)\n+\n+In the next chapter we will take care of styling our application with [Material-UI](https://material-ui.com/) and [styled-components](https://www.styled-components.com/) - we will give it the desired look and make it more user friendly. For now the ChatsListScreen serves no purpose, because you can't really do anything with it, but it can be used as a great basis to build on top of as we make progress.\ndiff --git a/.tortilla/manuals/templates/step10.tmpl b/.tortilla/manuals/templates/step10.tmpl\nnew file mode 100644\nindex 0000000..4e481e4\n--- /dev/null\n+++ b/.tortilla/manuals/templates/step10.tmpl\n@@ -0,0 +1,116 @@\n+So far we've been developing the app and we've been treating it as if there's no other users; we're the only one exists. This approach is true when we want to develop a UI and focus on UX, but comes a point where we need to start thinking on a macro level. Our app is social interactive, and if things work properly for me, it doesn't mean that it works properly to the fellow I'm chatting with. It's inevitable to have an authentication system in our app, hence we need to take care of things before we get to that stage.\n+\n+Try to open 2 instances of the app in 2 separate tabs/windows, and navigate into the same chat room. Try to send a message with one instance and notice that the second instance doesn't update unless we refresh the page.\n+\n+\n+\n+![ezgif com-video-to-gif (2)](https://user-images.githubusercontent.com/7648874/55079371-fbd87080-50d6-11e9-8ade-5ffeed6eaf8d.gif)\n+\n+\n+This issue is very important and should be addressed, because a chat is all about sending and receiving messages on a lively basis. This issue was expected, as there's no mechanism that would trigger and listen to changes in the back-end. In this chapter we're gonna address that issue by implementing exactly that mechanism.\n+\n+**Introducing: GraphQL Subscriptions**\n+\n+[GraphQL subscriptions](https://github.com/apollographql/graphql-subscriptions) is a mechanism that works on [web-sockets](https://en.wikipedia.org/wiki/WebSocket) and live communication; clients can subscribe to it and be notified regards specific changes that happen in the back-end. Notifications will be triggered manually by us and can be provided with parameters that provide additional information regards the triggered event. For example, a `messageAdded` will be published with the new message, and will notify all clients who are subscribed to that event. Once the subscribers are notified, they can respond as they would like to, such as updating the UI.\n+\n+\n+\n+![subscription-notifications](https://user-images.githubusercontent.com/7648874/55079462-30e4c300-50d7-11e9-8399-7706da2a9cff.png)\n+\n+\n+A subscription is presented in our GraphQL schema as a separate type called `Subscription`, where each field represents an event name along with its return type. Like any other GraphQL type, each field should be match with a resolver where we handle the request.** **In this chapter we will implement the `messageAdded` subscription, so users can be notified when it happens and update the messages list to contain the new message.\n+\n+**Implementing a subscription**\n+\n+We will start by creating a new `Subscription` type in our GraphQL schema with the field `messageAdded`:\n+\n+{{{ diffStep 7.1 module=\"server\" }}}\n+\n+Changes are triggered using an event-emitter like object called `PubSub`. This can be done using the `PubSub.prototype.publish` method. We will create a new instance of it and will provide it via the [context](https://www.apollographql.com/docs/apollo-server/essentials/data#context) - a common pattern for providing objects which are useful for the execution of the resolvers:\n+\n+{{{ diffStep 7.2 module=\"server\" }}}\n+\n+Inside the `addMessage` resolver we will publish a new event called `messageAdded`. The 3rd argument of the resolver will be the context object that we've just defined in the previous step, where we can use the pubsub instance. The TypeScript type of our context can be directly defined and generated by CodeGen through the `codegen.yml` file. This can be specified under the `ContextType` field with the file path that contains the context followed by the name of the exported object, like so:\n+\n+{{{ diffStep 7.3 module=\"server\" }}}\n+\n+The event will be published right after the message was pushed into the messages collection, because order is a crucial thing. We don't want to notify our users unless the change has been made. The event will have a single parameter which represents the new message.\n+\n+{{{ diffStep 7.4 module=\"server\" }}}\n+\n+A subscription resolver behaves differently and thus should be implemented differently. Using the `pubsub.asyncIterator` instance, we can specify which events are relevant for the subscription, for example, all clients who are subscribers of the `chatUpdated` subscription will be notified when `messageAdded`, `messageRemoved` and `chatInfoChanged` events were triggered. For now, we will have a 1 to 1 relationship between the `messageAdded` event and `messageAdded` subscription. In code, it should look like this:\n+\n+{{{ diffStep 7.5 module=\"server\" }}}\n+\n+The idea behind the `pubsub.asyncIterator` method is that it returns an [`Iterator`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators#Iterators) like object, where each value is a promise that will be resolved when the relevant events are triggered. By default, the parameter that has a similar name to the subscription will be returned as a response, e.g. `messageAdded` parameter will be sent back to the subscribers. This behavior can be modified as explained [here](https://github.com/apollographql/graphql-subscriptions#payload-manipulation), but it's very unlikely and not necessary for our use case.\n+\n+As mentioned at the beginning of this article, there needs to be an open connection between the client and the server so live updates can happen. There are serveral methods for doing so, but the 2 most popular ones are:\n+\n+\n+\n+*   Based on polling with HTTP protocol\n+*   Based on web-sockets (WS protocol)\n+\n+HTTP polling means that each amount of time an HTTP request will be made to the server where potential changes can be sent back to us at any given time. HTTP requests are very reliable, but the problem with them is that they contain a lot of information in their headers, so even if we sent an empty request, it might be still very heavy due to cookies, user-agent, language, request type, etc.\n+\n+With web-sockets, once a connection has been established, it will remain open and it will only send the information which is relevant for the current session, so it's much faster. The communication is between the server and the client is bi-directional when it comes to web-sockets, which means that a user can spontaneously receive information from the server, as long as the communication channel remains open.\n+\n+> More information about the advantages of Web Sockets over HTTP can be found at [websocket.org](http://websocket.org/quantum.html)\n+\n+The subscription mechanism can be installed using the `server.installSubscriptionHandlers`. It will use the WS protocol by default and will fallback to HTTP polling if there were troubles establishing a connection via WS protocol:\n+\n+{{{ diffStep 7.6 module=\"server\" }}}\n+\n+Now we have everything set and we can start listening to subscriptions and react to to triggered changes.\n+\n+**Using subscriptions**\n+\n+To support subscriptions we need to establish a WS connection. For that we will need to update our Apollo client. We will install a couple of packages that will enable such feature:\n+\n+  $ npm install subscriptions-transport-ws apollo-link apollo-link-ws apollo-utilities\n+\n+\n+\n+*   [`subscriptions-transport-ws`](https://www.npmjs.com/package/subscriptions-transport-ws) - The WS client. Essential for subscriptions to work.\n+*   [`apollo-link-ws`](https://www.npmjs.com/package/apollo-link-ws) - Will establish a WS connection.\n+*   [`apollo-link`](https://www.npmjs.com/package/apollo-link) - Will enable WS and HTTP connections co-exist in a single client.\n+*   [`apollo-utilities`](https://www.npmjs.com/package/apollo-utilities) - Includes utility functions that will help us analyze a GraphQL AST.\n+\n+The WS url can be composed by simply running a regular expression over the `REACT_APP_SERVER_URL` environment variable and is unnecessary to be stored separately. Here's how our new client should look like: \\\n+\n+\n+{{{ diffStep 10.1 module=\"client\" files=\"client\" }}}\n+\n+Our subscription listeners should live globally across our application and shouldn't be bound to a specific component, thus we will create an external service which will be responsible of doing so. Using that service, we will update our GraphQL data-store any time a new message has been added. We will define a `messageAdded` subscription in a dedicated file under the `src/graphql/subscriptions` dir where all our subscriptions will be defined and exported:\n+\n+{{{ diffStep 10.2 module=\"client\" }}}\n+\n+Now we will create the service under the path `services/cache.service.ts`. Like any other GraphQL operation, `react-apollo-hooks` provides us with a dedicated React hook for subscriptions called `useSubscription`. Given the subscription document and the `onSubscriptionData` callback we can handle incoming changes. We will be using GraphQL Code Generator to generate typed subscription hooks, as the `typescript-react-apollo` plug-in supports it right out of the box. First let's update the `codegen.yml` file to look for documents in the `graphql/subscriptions` dir:\n+\n+{{{ diffStep 10.3 module=\"client\" }}}\n+\n+And then we will type the code generation command:\n+\n+    $ npm run codegen\n+\n+Now we can import and use the newly generated hook `useMessageAddedSubscription` in the `cache.service`. Like mentioned earlier, we will be using the `onSubscriptionData` callback to retrieve the change that was sent by the server and we will use it to re-write our cache. In this case we will be writing a new fragment for the incoming message, and we will update the correlated chat:\n+\n+{{{ diffStep 10.4 module=\"client\" files=\"cache.service\" }}}\n+\n+We will also use the exported `writeMessage()` function in the `ChatRoomScreen` so we won't have any code duplications:\n+\n+{{{ diffStep 10.4 module=\"client\" files=\"ChatRoom\" }}}\n+\n+One thing missing that you might notice is that we're trying to retrieve the chat from the received message, unfortunately our GraphQL schema doesn't support it and we will need to add it. On the server, we will add a `chat` field to the `Message` type in the GraphQL schema, and we will implement a resolver which will lookup for the chat in the chats collection:\n+\n+{{{ diffStep 7.7 module=\"server\" }}}\n+\n+Now that we have it supported we can update the `Message` fragment in the client to include that information. We don't need the entire chat, only its ID, since the fragment ID composition is done out of an ID and type name:\n+\n+{{{ diffStep 10.5 module=\"client\" }}}\n+\n+Finally, we will import the `useCacheService` React hook that we've just created and we will use it in our main `App` component. This means that the cache service will start listening for changes right as the app component is mounted:\n+\n+{{{ diffStep 10.6 module=\"client\" }}}\n+\n+Subscription handling is complete! If you'll try to repeat the same process again where you check messages updating between 2 instances of the app, you should see them both update.\ndiff --git a/.tortilla/manuals/templates/step11.tmpl b/.tortilla/manuals/templates/step11.tmpl\nnew file mode 100644\nindex 0000000..d5b3060\n--- /dev/null\n+++ b/.tortilla/manuals/templates/step11.tmpl\n@@ -0,0 +1,127 @@\n+Our chat app is pretty functional. We can pick a chat from the chats list and we can send messages. It's not hard to notice that one of the most important mechanisms is missing, which is relating a chat or a message to a specific user. Even though we can send messages, it's basically pointless unless someone else receives it. In this chapter we will create a new users collection with pre-defined documents and we will learn how to simulate authentication programmatically so we can test the new mechanism.\n+\n+**Reshaping the back-end**\n+\n+To implement this feature we need to rethink our back-end and reshape the way our GraphQL schema is structured. Right now we only have 2 entities: Chat and Message, which are connected like so:\n+\n+\n+\n+![chat-message-orm](https://user-images.githubusercontent.com/7648874/55325929-0faa1b00-54b9-11e9-8868-7a8ed3edcda1.png)\n+\n+\n+We want to have a new User entity where each user will have Chats he participates in and Messages he owns. Therefore, our new GraphQL schema should look like something like this:\n+\n+\n+\n+![chat-message-user-orm](https://user-images.githubusercontent.com/7648874/55325935-146ecf00-54b9-11e9-8c0f-bc3b63cbe676.png)\n+\n+This change would require us to update the GraphQL type definitions and handlers, the DB models, and the codegen configuration file:\n+\n+{{{ diffStep 8.1 module=\"server\" }}}\n+\n+Even though we made these changes, the app remained the same. That's because the Query type haven't changed at all, and we still serve the same data as before. What we need to do is to edit the Query resolvers to serve data based on the user that is currently logged-in to the app in the current session. Before we go all in with a robust authentication system, it would be smarter to simulate it, so we can test our app and see that everything works as intended.\n+\n+For now, let's assume that we're logged in with user of ID 1 - Ray Edwards. Codewise, this would mean that we will need to have the current user defined on the resolver context. In the main file, let's add the `currentUser` field to the context using a simple `find()` method from our `users` collection:\n+\n+{{{ diffStep 8.2 module=\"server\" files=\"index.ts\" }}}\n+\n+And we will update the context type:\n+\n+{{{ diffStep 8.2 module=\"server\" files=\"context\" }}}\n+\n+Now we will update the resolvers to fetch data relatively to the current user logged in. If there's no user logged in, the resolvers should return `null`, as the client is not authorized to view the data he requested:\n+\n+{{{ diffStep 8.2 module=\"server\" files=\"schema, tests\" }}}\n+\n+Now if we will get back to the app and refresh the page, we should see a new chats list which is only relevant to Ray Edwards. Earlier in this chapter, we've defined a new `isMine` field on the `Message` type. This field is useful because now we can differentiate between messages that are mine and messages that belong to the recipient. We can use that information to distinct between messages in our UI.\n+\n+Let's first download a new image that will help us achieve the new style and save it under the [`src/public/assets/message-yours.png`](https://github.com/Urigo/WhatsApp-Clone-Client-React/blob/cordova/public/assets/message-other.png?raw=true) path. Then let's implement the new style:\n+\n+{{{ diffStep 11.1 module=\"client\" files=\"src/components\" }}}\n+\n+This is how the updated `ChatRoomScreen` should look like:\n+\n+\n+\n+![chat-room-screen](https://user-images.githubusercontent.com/7648874/55326701-face8700-54ba-11e9-877e-0b7dd71a1b68.png)\n+\n+\n+\n+We can use a temporary solution to log-in and alternate between different users. This would be a good way to test data authorization without implementing an authentication mechanism. One way to know which user is logged in is via [cookies](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies).\n+\n+Cookies are just text files which are stored locally on your computer and they contain key-value data maps. Cookies will be sent automatically by the browser with every HTTP request under the `Cookie` header. The header can be parsed and read by the server and this way inform it about the state of the client. Cookie values can also be set by the server by sending back a response which contain a `Set-Cookie` header. The browser will automatically write these cookies because of its specification and how it works.\n+\n+This is how you can set cookies on the client:\n+\n+```js\n+document.cookie = \"yummy_cookie=choco\"\n+document.cookie = \"tasty_cookie=strawberry\"\n+// logs \"yummy_cookie=choco; tasty_cookie=strawberry\"\n+```\n+\n+And this is how further requests would look like:\n+\n+```\n+GET /sample_page.html HTTP/2.0\n+Host: www.example.org\n+Cookie: yummy_cookie=choco; tasty_cookie=strawberry\n+```\n+\n+Using this method we can set the current user's ID. Open your browser's dev-console, and type the following:\n+\n+```js\n+// Ray Edwards\n+document.cookie = 'currentUserId=1'\n+```\n+\n+To be able to send cookies with Apollo Client, we need to set the [`credentials`](https://www.apollographql.com/docs/react/recipes/authentication#cookie) option to \"include\" when creating the HTTP link:\n+\n+{{{ diffStep 11.2 module=\"client\" }}}\n+\n+This will set the [`Access-Control-Allow-Credentials`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Credentials) header to “include” with each HTTP request which is necessary when using the POST method. In correlation to that, we would need to configure the server to be able to receive and set cookies. This can be done via CORS options like so:\n+\n+{{{ diffStep 8.4 module=\"server\" files=\"index.ts\" }}}\n+\n+So how exactly does one retrieve the values of the cookies? Like mentioned earlier, each and every request will have them set on the `cookie` header, so one way would be by reading the header directly, but a more convenient way would be using an Express middleware called [`cookie-parser`](https://www.npmjs.com/package/cookie-parser):\n+\n+  $ npm install cookie-parser\n+\n+{{{ diffStep 8.5 module=\"server\" files=\"index.ts\" }}}\n+\n+`cookie-parser` will read the `Cookie` header, it will parse it into a JSON and will define it on `req.cookies`. Since we’re using Apollo-Server with Express, the `req` object should be accessible as the first argument in the `context` function. This means that we can use the `currentUserId` from the cookies to fetch the current user from our users collection and define it on the context object:\n+\n+{{{ diffStep 8.6 module=\"server\" }}}\n+\n+Now you can go ahead and change the value of the `currentUserId` cookie and see how it affects the view anytime you refresh the page. Needless to say that this is not the most convenient way to switch between users, so we’re gonna implement a dedicated screen that will set the cookies for us.\n+\n+All the auth related logic should go into a dedicated service since it can serve us vastly across the application, not just for a single component. Thus we will create a new service called `auth.service`, which will contain 3 basic functions for now: `signIn()`, `signOut()` and `isSignedIn():\n+\n+{{{ diffStep 11.3 module=\"client\" }}}\n+\n+Now we will implement the `AuthScreen`. For now this screen should be fairly simple. It should contain a single `TextField` to specify the current user ID, and a `sign-in` button that will call the `signIn()` method with the specified ID. Once it does so, we will be proceeded to the `ChatsListScreen`. First we will download and save the following assets:\n+\n+- [`src/public/assets/whatsapp-icon.ping`](https://github.com/Urigo/WhatsApp-Clone-Client-React/raw/wip/cookie-auth/public/assets/whatsapp-icon.png)\n+\n+{{{ diffStep 11.4 module=\"client\" files=\"components\" }}}\n+\n+Accordingly we will define a new `/sign-in` route that will render the `AuthScreen` we’re under that path name:\n+\n+{{{ diffStep 11.4 module=\"client\" files=\"App\" }}}\n+\n+This is how the new screen should look like:\n+\n+![auth-screen](https://user-images.githubusercontent.com/7648874/55606715-7a56a180-57ac-11e9-8eea-2da5931cccf5.png)\n+\n+Now let’s type the `/sign-in` route in our browser’s navigation bar and assign a user ID, see how it affects what chats we see in the `ChatsListScreen`. You’ve probably noticed that there’s no way to escape from the `/chats` route unless we edit the browser’s navigation bar manually. To fix that, we will add a new sign-out button to the navbar of the `ChatsListScreen` that will call the `signOut()` method anytime we click on it, and will bring us back to the `AuthScreen`:\n+\n+{{{ diffStep 11.5 module=\"client\" }}}\n+\n+At this point we’ve got everything we need, but we will add a small touch to improve the user experience and make it feel more complete. Users who aren’t logged in shouldn’t be able to view any screen besides the `AuthScreen`. First they need to sign-in, and only then they will be able to view the `ChatsListScreen` and `ChatRoomScreen`. To achieve that, we will wrap all the components which require authentication before we provide them into their routes. This wrap will basically check whether a user is logged in or not by reading the cookies, and if not we will be redirected to the `/sign-in` route. Let’s implement that wrap in the `auth.service` and call it `withAuth()`:\n+\n+{{{ diffStep 11.6 module=\"client\" files=\"auth.service\" }}}\n+\n+We will use this function to wrap the right components in our app’s router. Note that since we used the `useCacheService()` directly in the `withAuth()` method, there’s no need to use it in the router itself anymore. This makes a lot more sense since there’s no need to stay subscribed to data that you're not gonna receive from the first place unless you’re logged-in:\n+\n+{{{ diffStep 11.6 module=\"client\" files=\"App\" }}}\n+\n+Assuming that you’re not logged-in, if you’ll try to force navigate to the `/chats` route you should be automatically redirected to the `/sign-in` form. We will finish the chapter here as we wanna keep things simple and gradual. It’s true that we haven’t implemented true authentication, but that would be addressed soon further in this tutorial.\ndiff --git a/.tortilla/manuals/templates/step12.tmpl b/.tortilla/manuals/templates/step12.tmpl\nnew file mode 100644\nindex 0000000..5fc416b\n--- /dev/null\n+++ b/.tortilla/manuals/templates/step12.tmpl\n@@ -0,0 +1,83 @@\n+Now that the users system is ready it would be a lot more comfortable to implement a chat creation feature. In the original Whatsapp, you can create a new chat based on your available contacts - a list of your contacts will appear on the screen and by picking one of the items you’ll basically be able to start chatting with the selected contact. However, since in our app we don’t have any real contacts (yet), we will implement the chats creation feature based on all available users in our DB. By picking a user from the users list we will be able to start chatting with it.\n+\n+![demo](https://user-images.githubusercontent.com/7648874/55896445-e4c67200-5bf0-11e9-9c1c-88318642ef81.gif)\n+\n+To be able to fetch users in our system we will need to add a new query called `users`. The `users` query will retrieve all users except for current user:\n+\n+{{{ diffStep 9.1 module=\"server\" }}}\n+\n+This query will be reflected in a component called `UsersList`. First we will define and export a new fragment called `User`:\n+\n+{{{ diffStep 12.1 module=\"client\" files=\"graphql/fragments\" }}}\n+\n+And then we will implement the `UsersList` component which is going to use the `users` query with the `User` fragment:\n+\n+{{{ diffStep 12.1 module=\"client\" files=\"UsersList\" }}}\n+\n+The list is likely to change when a new user signs-up. We will implement a subscription and live-update the list further this tutorial when we go through authentication. Now we will implement a new screen component called `ChatCreationScreen`. The screen will simply render the `UsersList` along with a navigation bar:\n+\n+{{{ diffStep 12.1 module=\"client\" files=\"ChatCreationScreen\" }}}\n+\n+The screen will be available under the route `/new-chat`. The new route will be restricted, since only authenticated users should be able to access it:\n+\n+{{{ diffStep 12.1 module=\"client\" files=\"App\" }}}\n+\n+the `/new-chat` route will be accessible directly from the main `ChatsListScreen`. We will implement a navigation button which is gonna have a fixed position at the bottom right corner of the screen:\n+\n+{{{ diffStep 12.1 module=\"client\" files=\"AddChatButton\" }}}\n+\n+And then we will render it in the `ChatsListScreen`:\n+\n+{{{ diffStep 12.1 module=\"client\" files=\"ChatsListScreen/index\" }}}\n+\n+For now we can only observe the users list. Our goal now is to be able to start chatting with a user once it has been clicked. First we will need to add a new mutation called `addChat` which will create a new chat document and add it to the chats collection. If the chat already exists we will return the existing instance. This behavior will help us navigate to the desired `ChatRoomScreen`, whether it exists or not:\n+\n+{{{ diffStep 9.2 module=\"server\" }}}\n+\n+To use the new mutation, we will define a new callback called `onUserPick` in the `UsersList` so it can be used from the `ChatCreationScreen`:\n+\n+{{{ diffStep 12.2 module=\"client\" files=\"UsersList\" }}}\n+\n+In the `ChatCreationScreen/index.tsx` module, we will define an `AddChat` document with `graphql-tag`. Using the `$ yarn codegen` command we can generate the correlated React mutation hook and use it as the `onUserPick` callback:\n+\n+{{{ diffStep 12.2 module=\"client\" files=\"ChatCreationScreen/index\" }}}\n+\n+Chats can now be created, you can test out the function by signing in with different users. However, the chats list in the `ChatsListScreen` will not be updated unless we refresh the page manually. In the server project, we will define a new subscription called `chatAdded`. The subscription should be broadcasted to the current user only if he is a participant of the published chat:\n+\n+{{{ diffStep 9.3 module=\"server\" }}}\n+\n+Now we will listen to the new subscription in the client and update the cache. First we will define the subscription document:\n+\n+{{{ diffStep 12.3 module=\"client\" files=\"graphql/subscriptions\" }}}\n+\n+And then we will update the `cache.service` to write the broadcasted chat to the store. We will write the fragment, and we will also update the `chats` query to contain the new chat. We will also check if the chat already exists before we update the query, because remember, the `addChat` mutation will return the chat even if it already exists, not if it was created only:\n+\n+{{{ diffStep 12.3 module=\"client\" }}}\n+\n+Now we can create new chats, and the chats list would be updated, without refreshing the page. You can also test it with 2 separate sessions in the browser and see how each tab/window affects the other. Lastly, we will implement a chat removal function. This is important as we don’t want to garbage our chats collection, sometimes we would like to clean up some of them.\n+\n+In the back-end, let’s implement the `removeChat` mutation. The chat can only be removed only if the current user is one of the chat’s participants. The mutation will also remove all the messages which are related to the target chat, since we’re not gonna use them anymore. The chat will be removed for all participants. This is not exactly the behavior of the original Whatsapp, but to keep things simple we will go with that solution:\n+\n+{{{ diffStep 9.4 module=\"server\" }}}\n+\n+In the client app, a chat could be removed directly from the `ChatRoomScreen`. On the top right corner, right on the navbar, we will add a dispose button that will call the `removeChat` mutation. Just like we did before, we will define the mutation document with `graphql-tag` and generate the correlated hook with CodeGen:\n+\n+{{{ diffStep 12.4 module=\"client\" }}}\n+\n+Normally this is a dangerous behavior because we wipe out the entire history without any warnings, which is not recommended. For tutoring purposes only we will keep it the way it is, because it makes things simple and easier to understand.\n+\n+To be able to update the chats list cache, we will implement a `chatRemoved` subscription. The subscription will be broadcasted only to those who’re participants of the published chat:\n+\n+{{{ diffStep 9.5 module=\"server\" }}}\n+\n+In the client, we will define the right subscription document:\n+\n+{{{ diffStep 12.5 module=\"client\" files=\"graphql/subscriptions\" }}}\n+\n+And we will update the `cache.service` to listen to the new subscription and update the `chats` query accordingly. When we deal with the fragment, we remove the `FullChat` fragment because it consists of the `Chat` fragment. If it was the other way around, we would still have some data leftovers from the `FullChat` on the fragment, because of how Apollo-Cache manages the store:\n+\n+{{{ diffStep 12.5 module=\"client\" files=\"cache.service\" }}}\n+\n+We will also update the `ChatRoomScreen` to redirect us to the `/chats` route if the chat was not found. The render method of the component will be re-triggered automatically by `react-apollo-hooks` if the cached result of `useGetChat()` hook has changed, which means that even if you didn’t actively remove the chat, you will still be redirected as a result:\n+\n+{{{ diffStep 12.5 module=\"client\" files=\"ChatRoom\" }}}\ndiff --git a/.tortilla/manuals/templates/step13.tmpl b/.tortilla/manuals/templates/step13.tmpl\nnew file mode 100644\nindex 0000000..a142354\n--- /dev/null\n+++ b/.tortilla/manuals/templates/step13.tmpl\n@@ -0,0 +1,117 @@\n+In the previous step we’ve set the ground for the authentication system in our app. We have a users collection which can be used to distinguish which data the client is authorized to view, and we have a context handler which can retrieve the current user logged in based on the received value of the `cookie` header. It’s definitely a good starting point, but it misses a lot of things.\n+\n+In this chapter we will implement a cookie-based authentication system. There are many ways to implement an authentication system in an app, but cookie-based authentication is one of the most popular ones, hence we will go with that method. Essentially the authentication flow in our app should look very simple: a user will be able to sign-in with a dedicated screen, and if he doesn’t own an account he can use the sign-up screen to create a new one. The more complicated part in this flow is the back-end, which is the core of this chapter. So before we get into the implementation, we need to understand the authentication process:\n+\n+- A user logs in with a username and a password.\n+The server compares the received username and password to the ones stored in the database.\n+- If the comparison was successful, the server will generate a token and will set it as a cookie.\n+- Each time a request is sent, the server will retrieve the username from the stored token on the cookie header and will send data back accordingly.\n+\n+![auth-flow](https://user-images.githubusercontent.com/7648874/55929679-55e94200-5c50-11e9-9fe7-54ad6194a572.png)\n+\n+The stored token will save us the hassle of re-specifying the username and password over and over again each and every request. It’s important to note that everything in the authentication process is encrypted, **sensitive information will never be stored or sent in its raw form**, otherwise data might be stolen in case of a DB breach or a request hijacking. This is what it means for our app:\n+\n+- Passwords will always be stored in an encrypted form in the DB using an algorithm called [Bcrypt](https://en.wikipedia.org/wiki/Bcrypt). Bcrypt has the ability to compare the password in its raw form to the encrypted one, which can help us authorize the user.\n+\n+- Tokens are self contained. That means that once we decode the encrypted string we can get a hold of the username string. This form of encrypted tokens is called [Json Web Token (JWT)](https://jwt.io/).\n+\n+> We're not going to elaborate about the algorithm behind each encryption method because we want to focus more on practicality, although it's very much recommended to understand how each method works before proceeding.\n+\n+The implementation will follow the principles above. Authentication is a hot topic in the GraphQL world and there are several ways of doing so. In our application we will implement the mechanism using the classic REST framework within our GraphQL back-end. This approach is completely fine and in line with the official GraphQL best practices. We will start with the back-end and set the infrastructure for authentication, and then we will move on to the front-end.\n+\n+We’re gonna expose 2 new routes from our REST API: `/sign-in` and `/sign-up`. `/sign-out` is unnecessary because it can be done locally by deleting the right cookie. Our back-end is gonna grow bigger so first we will separate the Express app from the Apollo Server instance, and extract the env vars to a dedicated module:\n+\n+{{{ diffStep 10.1 module=\"server\" }}}\n+\n+We will first start with the `/sign-in` route, so we can test it against pre-defined user credentials, and then we will proceed to implementing the `/sign-up` route. It would be a lot easier to progress this way. For that we will install a couple of packages:\n+\n+- `bcrypt` - which is responsible for running a one-way encryption against received passwords before they’re stored in the DB.\n+- `jsonwebtoken` - responsible for encrypting the logged-in username before it’s set as a cooky and decrypting it once it’s sent back with a request.\n+\n+    $ npm install bcrypt jsonwebtoken\n+    $ npm install --dev @types/bcrypt @types/jsonwebtoken\n+\n+And we will implement the `/sign-in` route:\n+\n+{{{ diffStep 10.2 module=\"server\" files=\"app\" }}}\n+\n+As you can see we use a special secret before we encrypt the username with JWT. The same secret will be used later on to decrypt the token back into username when getting requests. If someone malicious will get a hold of that password, he can fabricate an authentication token for every user that he wants, **thus it’s important to choose a strong secret**.\n+\n+When building the context for our GraphQL resolvers, we will decode the received cookie with JWT using the same secret to determine the username who made the request. Once we have that username, we can simply retrieve the original user from the DB and define it on the context:\n+\n+{{{ diffStep 10.3 module=\"server\" }}}\n+\n+You might have noticed that the User schema has been updated, because we try to address the `user.username` property. The authentication in our app will be done with a username and a password; accordingly, we will update our User type definitions and the user documents in the users collection mock. The credentials that we’re going to store can actually be used to sign-in to our app:\n+\n+{{{ diffStep 10.4 module=\"server\" }}}\n+\n+To test it out, we will run our front-end application and open the dev-console. Using the Fetch API we will send a request to the `/sign-in` route. We can use the credentials of one of the users stored in the DB. As for now all our restricted routes are observing the `currentUserId` cookie. This is wrong and no longer relevant. Let’s change the `withAuth()` method to observe the `authToken` cookie so we can test our REST endpoint successfully:\n+\n+{{{ diffStep 13.1 module=\"client\" }}}\n+\n+Now we can perform the sign-in. It would be a good idea to sign-in with the first user - `ray`, since all the DB mock is built around him:\n+\n+```js\n+fetch(`http://localhost:4000/sign-in`, {\n+  method: 'POST',\n+  body: JSON.stringify({\n+    username: 'ray',\n+    password: '111',\n+  }),\n+  credentials: 'include',\n+  headers: {\n+    'Accept': 'application/json',\n+    'Content-Type': 'application/json',\n+  },\n+})\n+```\n+\n+Now if we would look at the value of `document.cookie` we should see a key named `authToken` with a JWT token and the `ChatsListScreen` should show the chats which are relevant to `ray`. To complete the sign-in flow we would need to update the `AuthScreen` and the `auth.service` to use username and password and the actual `/sign-in` route we’ve just implemented.\n+\n+To check if we’re authorized to visit a route, not only we would need to check if we have the `authToken` cookie defined, but we would also need to validate it against the server to see that it actually references a real user. For that we will implement `Query.me` which will send us back the current user logged in directly from the context:\n+\n+{{{ diffStep 10.5 module=\"server\" }}}\n+\n+Now back to the `auth.service`, we will replace the `signIn()` method implementation with one that actually calls the `/sign-in` REST endpoint in our API:\n+\n+{{{ diffStep 13.2 module=\"client\" }}}\n+\n+And we will use the GraphQL query we’ve just implemented to check if the user actually exists within the DB before we proceed to the restricted route:\n+\n+{{{ diffStep 13.3 module=\"client\" }}}\n+\n+we will use the new query to try and fetch the user directly from the back-end, and we will only proceed if the user was actually found. In addition, we will replace the `signIn()` method to call our REST API using the native fetch API:\n+\n+{{{ diffStep 13.4 module=\"client\" }}}\n+\n+The behavior of the updated screen should be identical to what we had so far. To complete the flow we’ll need a way to sign-up. When we signing-up we will need the following parameters: `name`, `username`, `password` and `passwordConfirm`. In addition we will need to run certain validations against the parameters:\n+\n+- The name must be at least 3 and at most 50 characters long.\n+- The username must be at least 3 and at most 18 characters long.\n+- A password must be at least 8 and at most 30 characters long. In addition, it should contain English letters, numbers, and special characters.\n+\n+For that we will implement a dedicated validations module:\n+\n+{{{ diffStep 10.6 module=\"server\" files=\"validators\" }}}\n+\n+And we will implement the handler for the `/sign-up` route:\n+\n+{{{ diffStep 10.6 module=\"server\" files=\"app\" }}}\n+\n+Before encrypting the password we append a string called “salt” to it. Even though the passwords are stored encrypted in the DB, a hacker might use a dictionary of common passwords in their encrypted form to decipher the original password. When adding salt to a password which is essentially a random string, the hacker cannot use a dictionary anymore since he would need to know the salt. Hypothetically, the hacker can get a hold of the salt and re-generate the entire dictionary, however that would take too long because of the way Bcrypt is designed to work.\n+\n+Going back to the client, we will implement a new `signUp()` method in the `auth.service` that will call the `/sign-up` route in our REST API:\n+\n+{{{ diffStep 13.5 module=\"client\" }}}\n+\n+Now we will implement a dedicated `SignUpForm` that we can use to perform the sign-up. Instead of implementing a new screen, we will use the `AuthScreen` to alternate between the `SignInForm` and the `SignUpForm` using `AnimatedSwitch`. This way we can have a container component that is common for both forms, and we will be able to switch between the two very smoothly. We will first define a new `/sign-up` route in our router:\n+\n+{{{ diffStep 13.6 module=\"client\" module=\"App\" }}}\n+\n+And then we will make the necessary changes in the `AuthScreen`:\n+\n+{{{ diffStep 13.6 module=\"client\" module=\"AuthScreen\" }}}\n+\n+> Note how we used the `/sign-(in|up)` pattern to define the `/sign-up` route. This is because the request will be further redirected in the `AuthScreen`.\n+\n+The authentication flow is complete! To test it out, you can create a new user, log in with it and start chatting with other users.\ndiff --git a/.tortilla/manuals/templates/step2.tmpl b/.tortilla/manuals/templates/step2.tmpl\nnew file mode 100644\nindex 0000000..755534e\n--- /dev/null\n+++ b/.tortilla/manuals/templates/step2.tmpl\n@@ -0,0 +1,118 @@\n+Styled-components is a relatively new library that will transpile a given string into a CSS string and will encapsulate it under a React.Component. What's good about it is that you can define your style programmatically and it fits very well into React. With JavaScript in-hand you naturally have more control over your style, which makes it a very powerful tool.\n+\n+Here's one way to style a button using styled-components:\n+\n+```js\n+const Button = styled.button`\n+  background: transparent;\n+  border-radius: 3px;\n+  border: 2px solid palevioletred;\n+  color: palevioletred;\n+  margin: 0.5em 1em;\n+  padding: 0.25em 1em;\n+\n+  ${props => props.primary && css`\n+    background: palevioletred;\n+    color: white;\n+  `}\n+`;\n+```\n+\n+The created Button is actually a React.Component, so an instance of it can be created with ease like any other component:\n+\n+```jsx\n+  <Button primary />\n+```\n+\n+More information about styled-components can be found in the official [docs page](https://www.styled-components.com/docs).\n+\n+We would also use [Material-UI](https://material-ui.com/) - a library with a set of React components that implements Google's Material Design. What's good about it is that the design is already implemented right out of the box. Not only that, but it also includes a set of icons which are free to use.\n+\n+There are many many things that Material-UI can offer, and it's not easy to follow it up, especially with the constantly evolving and improving API. The best way to go with it, is to have a component, and then look for it in the [official website](https://material-ui.com/). When it comes to searching for icons, they can be found in the [material.io](https://material-ui.com/) website through the search bar. As we move further in this tutorial you should have a better grasp of Material and how to use it.\n+\n+![material-ui-icons](https://user-images.githubusercontent.com/7648874/54141504-c853e000-4460-11e9-94b5-aae98ec9a1e3.png)\n+\n+We will start off by installing both libraries:\n+\n+  $ npm install @material-ui/core @material-ui/icons styled-components\n+\n+`@material-ui/core` includes core component of Material-UI such as Input, Popover, Modal, etc, and `@material-ui/icons` includes a set of icons. Material is very generic and has a built in theming system which can be controlled by simply setting few variables, which is exactly what we're gonna need in our app.\n+\n+In our app we're mainly gonna use 2 colors:\n+\n+- Primary #306759\n+- Secondary #79e352\n+\n+Theme definition can easily be done in Material using the MuiThemeProvider component:\n+\n+{{{ diffStep \"2.2\" module=\"client\" }}}\n+\n+Once we have it set, the colors should be available to use in our application by simply providing the \"color\" prop to the component instance whose color we would like to change:\n+\n+```jsx\n+<Button color=\"primary\">Primary</Button>\n+<Button color=\"secondary\">Secondary</Button>\n+```\n+\n+In our app, we're also gonna use CSS directly to change its colors, therefore it would be handy to have these theme variables available to us through CSS. To do so, we will have have a second definition of these variables in `index.css`, at the `:root` level of our application.\n+\n+{{{ diffStep \"2.3\" module=\"client\" }}}\n+\n+`:root` is a pseudo element that simply represents the root node, which will make the colors available in all elements. Normally, it works like JavaScript's scoping system and it will make variables available only to the current node and to its children, NOT its parents. CSS vars can be used like so:\n+\n+```css\n+  color: var(--primary-text);\n+  background-color: var(--primary-bg);\n+```\n+\n+More information about CSS variables can be found in the [official MDN docs](https://developer.mozilla.org/en-US/docs/Web/CSS/Using_CSS_variables).\n+\n+So getting back to the ChatsListScreen, we will wrap the ChatsNavbar with Material's <Toolbar /> component:\n+\n+{{{ diffStep \"2.4\" module=\"client\" files=\"ChatsNavbar.tsx\" }}}\n+\n+And we will replace the `<ul />` and `<li />` elements with Material's `<List />` and `<ListItem />` in ChatsList:\n+\n+{{{ diffStep \"2.4\" module=\"client\" files=\"ChatsList.tsx\" }}}\n+\n+Thanks to the `button` attribute we can give our list a more vibrant feeling and that will display a nice ripple effect once an item is clicked, something that could have taken a long time to implement manually.\n+\n+Next, we will use `styled-components` to create new React.Components which are bound into a style-sheet. This way when we create new instances of them, the components will be styled right out of the box. Example:\n+\n+```jsx\n+const Button = styled.button `\n+  border-radius: 999px;\n+`\n+\n+const RedButton = styled(Button) `\n+  color: red;\n+`\n+\n+const GreenButton = styled(Button) `\n+  color: green;\n+`\n+\n+const BlueButton = styled(Button) `\n+  color: blue;\n+`\n+\n+const Dashboard = (\n+  <div>\n+    <RedButton />\n+    <GreenButton />\n+    <BlueButton />\n+  </div>\n+)\n+```\n+\n+The clear advantage of such working strategy is that all the styles are encapsulated, unlike traditional CSS where style rules can easily collide and be merged unintentionally. Remember that **`styled-components` operates per component, not globally**. In terms of syntax and API there isn't much to explain, it's very intuitive and if you would follow the step-diffs in this tutorial carefully you should get the hang of `styled-components` pretty easily.\n+\n+Accordingly, let's use `styled-components` our `ChatsListScreen`:\n+\n+{{{ diffStep \"2.5\" module=\"client\" files=\"ChatsListScreen\" }}}\n+\n+Notice that we've changed the structure of the HTML of the ChatsList component. We've added the ChatInfo to allow better alignment of the elements. **There isn't right or wrong way to define CSS rules and HTML, as long as the script is clear and easy to understand, that will do**.\n+\n+We're done styling `ChatsListScreen`. We will keep using the same principles to style the rest of the components in our application. The final result should look like so:\n+\n+![screenshot](https://user-images.githubusercontent.com/7648874/54141766-40baa100-4461-11e9-8dd0-59edcfdb3b84.png)\ndiff --git a/.tortilla/manuals/templates/step3.tmpl b/.tortilla/manuals/templates/step3.tmpl\nnew file mode 100644\nindex 0000000..ee1ac2c\n--- /dev/null\n+++ b/.tortilla/manuals/templates/step3.tmpl\n@@ -0,0 +1,131 @@\n+So we have a running app with a single screen which looks stylish and presents some data to the user. There is something missing though. The data that is presented is just a mock for a server response, and it represents the schema of some real data to come.\n+\n+Even if we'll create real data on the client, that means that when the client is down, all the data is lost. But this is a social app, many people want to use it together and even the same person wants to use it on multiple devices. For that, we need a central place to store all data and all the clients would connect to that central place in order to retrieve or change the data.\n+\n+In this step, we will write a Node.JS server and will expose a REST endpoint that will serve the data-mock. We will build the REST application using [Express](https://www.npmjs.com/package/express). Further in this tutorial, we will migrate to using a real data-base with real I/O from the user, so we got you covered.\n+\n+The plan is to have a server up and running at `localhost:4000` that will expose a `GET /chats` route. Unlike our client application, we're not gonna use any boilerplate and we're gonna set everything up manually. Ofcourse, you should feel free to use a boilerplate if it looks right to you. Right outside the client project, we will create a new directory called `whatsapp-clone-server` in which we will start creating our server:\n+\n+    $ mkdir whatsapp-clone-server\n+    $ cd whatsapp-clone-server\n+\n+Then we will use NPM to initialize a new project:\n+\n+    $ npm init --yes\n+\n+> `--yes` will answer yes to all questions and skip the prompt. It's just faster this way.\n+\n+There's nothing special about this command, it only creates a basic package.json which we can add things on top (see [NPM's official docs](https://docs.npmjs.com/cli/init)). Just to make sure that things work, we will add an `index.js` file which will print \"hello world\" to the console.\n+\n+{{{ diffStep \"1.1\" module=\"server\" files=\"index.js\" }}}\n+\n+\n+And we will add a startup script to the `package.json` file called `start`:\n+\n+    start: node index.js\n+\n+NPM-scripts are just a way to defined an alias for commands. Now we only have one simple script, but it can turn out to be something very complex depending on our server, so it can be very useful. More about npm-scripts can be found in the [official NPM docs](https://docs.npmjs.com/misc/scripts).\n+\n+Now we can run our server by running `$ npm start` and we should see the message \"hello world\" printed to the console, as expected.\n+\n+Like in our client's app, we will be using TypeScript. It's comfortable and it enables consistency between both apps. In order to use TypeScript we will install few packages:\n+\n+    $ npm install --dev typescript ts-node @types/node\n+\n+> Note how we used the `--dev` flag. This project is not gonna be required as an external dependency anywhere, but It is still common to separate between production dependencies and development dependencies. More about the `--dev` option can be read in the [NPM-install docs](https://docs.npmjs.com/cli/install).\n+\n+- The [`typescript`](https://www.npmjs.com/package/typescript) package is TypeScript's core transpiler.\n+- [`ts-node`](https://www.npmjs.com/package/ts-node) is an interpreter that will transpile required `.ts` files into JavaScript at runtime.\n+- [`@types/node`](https://www.npmjs.com/package/@types/node) will make the appropriate definitions for a Node.JS environment.\n+\n+> You can read more about the `@types` monorepo in the [official GitHub repository](https://github.com/DefinitelyTyped/DefinitelyTyped).\n+\n+Our server is gonna use the following `tsconfig.json` file, feel free to make the necessary modifications based on your needs:\n+\n+{{{ diffStep \"1.2\" module=\"server\" files=\"tsconfig.json\" }}}\n+\n+We will rename the `index.js` file to `index.ts`:\n+\n+    $ mv index.js index.ts\n+\n+And we will update the npm-script `start` to use `ts-node`, since we wanna use TypeScript, and not JavaScript directly:\n+\n+    start: ts-node index.ts\n+\n+We can test the startup of our server again by running `$ npm start` and we should see the message \"hello world\" printed to the console. The skeleton of the project is set and we can move on to implementing the REST API.\n+\n+Like we said at the beginning, we will be using Express to setup the API. Express is wrap around the native [Node.JS \"http\"](https://nodejs.org/api/http.html) library which is responsible for handling HTTP requests. Yes, it can also be used directly, but Express is much more comfortable and has an amazing ecosystem built around it. Let's install Express and its TypeScript definitions:\n+\n+    $ npm install express\n+    $ npm install --dev @types/express\n+\n+Before we implement the `GET /chats` route we will implement a `GET /_ping` route. This route will be used to determine whether the server is up and running or not, and how fast the connection is based on the response time. For every request sent to this route, we should expect a response saying \"pong\". Some call it \"heartbeat\", because this route is being tested repeatedly by the hosting machine to check if it's alive, just like a heartbeat in a way. This is how the route should look like:\n+\n+{{{ diffStep \"1.3\" module=\"server\" files=\"index.ts\" }}}\n+\n+We can use the `$ curl localhost:4000/_ping` command to send a request to the server and we should get a \"pong\", assuming that the server available on that URL. The `GET /chats` should be implemented similarly, only the response is different. Instead of returning \"pong\" we will return the data-mock for our chats:\n+\n+{{{ diffStep \"1.4\" module=\"server\" files=\"index.ts, db.ts\" }}}\n+\n+Unlike the previous route, we used the `.json()` method this time around to send a response. This will simply stringify the given JSON and set the right headers. Similarly to the client, we've defined the db mock in a dedicated file, as this is easier to maintain and look at.\n+\n+It's also recommended to connect a middleware called [`cors`](https://www.npmjs.com/package/cors) which will enable cross-origin requests. Without it we will only be able to make requests in localhost, something which is likely to limit us in the future because we would probably host our server somewhere separate than the client application. Let's install the `cors` library and load it with the Express `middleware()` function:\n+\n+    $ npm install cors\n+\n+{{{ diffStep \"1.4\" module=\"server\" files=\"index.ts\" }}}\n+\n+The server is now ready to use! So getting back to the client, first we will define our server's URL under the `.env` file:\n+\n+{{{ diffStep \"3.1\" module=\"client\" }}}\n+\n+This will make our server's URL available under the `process.env.REACT_APP_SERVER_URL` member expression and it will be replaced with a fixed value at build time, just like macros. The `.env` file is a file which will automatically be loaded to `process.env` by the [`dotenv`](https://www.npmjs.com/package/dotenv) NPM package. `react-scripts` then filters environment variables which have a `REACT_APP_` prefix and provides the created JSON to a Webpack plugin called [DefinePlugin](https://webpack.js.org/plugins/define-plugin/), which will result in the macro effect.\n+\n+Now let's move back into our React app folder. We will now replace the local data-mock usage with a fetch from the server. For that we can use the native [fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API), however, it needs to be used in the right life-cycle hook of the React.Component.\n+\n+There are 2 naive approaches for that:\n+\n+- Calling `fetch()` outside the component, but this way that chats will be fetched even if we're not even intending to create an instance of the component.\n+\n+```js\n+fetch().then(() => /* ... */)\n+const MyComponent = () => {}\n+```\n+\n+- Calling `fetch()` inside the component, but then it will be invoked whenever the component is re-rendered.\n+\n+```js\n+const MyComponent = () => {\n+  fetch().then(() => /* ... */)\n+}\n+```\n+\n+These 2 approaches indeed work, but they both fail to deliver what's necessary on the right time. In addition, there's no way to properly coordinate async function calls with the render method of the component.\n+\n+**Introducing: React hooks**\n+\n+With React hooks we can invoke the desired logic in the right life-cycle stage of the target component. This way we can avoid potential memory leaks or extra calculations. To implement a proper `fetch()`, we will be using 2 React hooks:\n+\n+- [`React.useState()`](https://reactjs.org/docs/hooks-reference.html#usestate) - which is used to get and set a state of the component - will be used to store the fetch chats.\n+\n+```js\n+const [value, setValue] = useState(initialValue)\n+```\n+\n+- [`React.useMemo()`](https://reactjs.org/docs/hooks-reference.html#usememo) - which is used to run a computation only once certain conditions were met - will be used to run the `fetch()` function only once the component has mounted.\n+\n+```js\n+const memoizedValue = useMemo(calcFn, [cond1, cond2, ...conds])\n+```\n+\n+The result of that approach will look like this, in the context of our ChatsList component:\n+\n+{{{ diffStep \"3.2\" module=\"client\" }}}\n+\n+> It's recommended to read about React hooks and their basic concept at the [official React docs page](https://reactjs.org/docs/hooks-overview.html).\n+\n+At this point we can get rid of `db.ts` file in the client, since we don't use it anymore:\n+\n+    $ rm src/db.ts\n+\n+That's it. Our ChatsListScreen is now connected to a working back-end. In the next step we will upgrade our REST API into a GraphQL API and we will create a basis for a more robust back-end.\ndiff --git a/.tortilla/manuals/templates/step4.tmpl b/.tortilla/manuals/templates/step4.tmpl\nnew file mode 100644\nindex 0000000..c85dcf8\n--- /dev/null\n+++ b/.tortilla/manuals/templates/step4.tmpl\n@@ -0,0 +1,196 @@\n+**What is GraphQL?**\n+\n+[GraphQL](https://graphql.org/) is a query language invented by Facebook, and it's used to query data within our API. It allows clients to define the structure of the data required, and the exact same structure of data will be returned from the server, therefore preventing excessively large amounts of data from being returned. Unlike REST, GraphQL APIs are organized in terms of types and fields, not endpoints.\n+\n+Currently in our app, if we'd like to get its chats we would send a GET request to `/chats`. With GraphQL it would be done differently with a string that describes the data that we would like to get:\n+\n+```graphql\n+chats {\n+  id\n+  name\n+  picture\n+  lastMessage {\n+    id\n+    content\n+    createdAt\n+  }\n+}\n+```\n+\n+> Above: An illustration of a potential GraphQL query sent to our Whatsapp API\n+\n+**Why GraphQL and not REST?**\n+\n+In terms of experience REST got the upper hand. It has been used for many more years and has proven itself to work well, and it's completely agnostic to the implementation of the back-end. However, when it comes to data projection and aggregation, it fails to deliver.\n+\n+When using REST, often times you'll find yourself performing multiple requests to execute a single query of data. Not only that, you might even end up with additional data that is not necessary. Either way, the process would result in slower and heavier response.\n+\n+With GraphQL we don't have that kind of problem. Queries may take many shapes and forms, and since GraphQL is schema based - it can handle it. You'll get exactly what you asked for with a single request. **GraphQL provides a dynamic API while REST doesn't.**\n+\n+```graphql\n+# request\n+query {\n+  chat(id: 1) {\n+    id\n+    name\n+    lastMessage {\n+      id\n+      content\n+    }\n+  }\n+}\n+```\n+\n+![graphql-request](https://user-images.githubusercontent.com/7648874/54133620-5aec8300-4451-11e9-9bda-a459dc48f57c.png)\n+\n+```js\n+// response\n+{\n+  \"data\": {\n+    \"chat\": {\n+      \"id\": 1,\n+      \"name\": \"Ethan Gonzalez\",\n+      \"lastMessage\": {\n+        \"id\": 1,\n+        \"content\": \"You on your way?\"\n+      }\n+    }\n+  }\n+}\n+```\n+\n+**GraphQL schema, in a nutshell**\n+\n+Like said earlier,  GraphQL APIs are organized in terms of types and fields. That means that our app data should be described with a schema, where each field's gonna have a resolver - the handler that will return the corresponding data. Things will be much clearer as we move further.\n+\n+Let's try to describe our app's data with a GraphQL schema and then dive into it:\n+\n+```graphql\n+scalar Date\n+\n+type Message {\n+  id: ID!\n+  content: String!\n+  createdAt: Date!\n+}\n+\n+type Chat {\n+  id: ID!\n+  name: String!\n+  picture: String\n+  lastMessage: Message\n+}\n+\n+type Query {\n+  chats: [Chat!]!\n+}\n+```\n+\n+The schema is self explanatory in terms of what data it's compatible with. Supported built-in scalar types in GraphQL are:\n+\n+- Int: Signed 32‐bit integer\n+- Float: Signed double-precision floating-point value\n+- String: UTF‐8 character sequence\n+- Boolean: true or false\n+- ID (serialized as String): A unique identifier, often used to refetch an object or as the key for a cache. While serialized as a String, ID signifies that it is not intended to be human‐readable\n+\n+Any custom scalar can be declared with the `scalar` keyword, and custom types can be declared with the `type` keyword. However, you should know that some types are reserved by GraphQL itself; `Query` is one of them. The `Query` type will be used as the root for received queries by the clients, which means that we can send queries which start with the `chats` field. Other reserved types are:\n+\n+- `type Query` - reserved for [GraphQL queries](https://graphql.org/learn/queries/#mutations).\n+- `type Mutation` - reserved for [GraphQL mutations.](https://graphql.github.io/learn/queries/)\n+- `type Subscription` - reserved for [GraphQL subscriptions.](https://www.apollographql.com/docs/react/advanced/subscriptions.html)\n+\n+> As we're not gonna go through the entire GraphQL API, it's recommended to go through the [official learn section of the GraphQL website](https://graphql.org/learn/), but the information so far will definitely help you kick-start, plus the upcoming implementation.\n+\n+**Getting started**\n+\n+We will be implementing a GraphQL mechanism for the client and for the server. We will start with the server as things will make more sense, and we will be able to test it before we proceed into the client. Essentially GraphQL is connected into a HTTP endpoint, usually under `POST /graphql`, and so this is exactly what we're gonna do, connect the endpoint handler. Luckily, we don't have to implement that. A team called [Apollo](https://www.apollographql.com/) already did it for us, so we can use their implementation. We will install the required packages:\n+\n+    $ npm install apollo-server-express body-parser graphql\n+    $ npm install --dev @types/body-parser @types/graphql\n+\n+- [`graphql`](https://www.npmjs.com/package/graphql) - The core package of GraphQL that includes the resolvers for basic data-types.\n+- [`apollo-server-express`](https://www.npmjs.com/package/apollo-server-express) - Apollo's implementation for the GraphQL Express REST endpoint.\n+- [`body-parser`](https://www.npmjs.com/package/body-parser) - Parse incoming request bodies in a middleware before your handlers, available under the req.body property.\n+- `@types/…` - TypeScript definitions\n+\n+We can now connect Apollo's middleware under the `/graphql` route:\n+\n+{{{ diffStep \"2.1\" module=\"server\" files=\"index.ts\" }}}\n+\n+As you can see, the middleware requires a schema. A schema is composed mainly out of 2 fields:\n+\n+- `typeDefs` (type definitions) - the schema types we wrote earlier this chapter for chats.\n+- `resolvers` - The handlers that will provide the data for each field in `typeDefs`.\n+\n+We will start first by defining the types. All we have to do is to copy-paste the contents of the schema that was shown earlier into a new file called `typeDefs.graphql`:\n+\n+{{{ diffStep \"2.2\" module=\"server\" files=\"schema/typeDefs.graphql\" }}}\n+\n+The `.graphql` file extension is just a more convenient way to work with a GraphQL schema. The exported result should be a simple string that we can use to compose our GraphQL schema. The clear advantage of working with a dedicated file is that we get to have syntax highlight.\n+\n+Now we will implement the resolvers. Resolvers are presented in a JSON object where each resolver name should match the field name it represents. You can read more about resolvers in [Apollo's official docs for resolvers](https://www.apollographql.com/docs/tutorial/resolvers.html). This is how our resolvers should look like:\n+\n+{{{ diffStep \"2.2\" module=\"server\" files=\"schema/resolvers.ts\" }}}\n+\n+For now it's extremely simple, we map the chats query directly into the database collection. Each field in the resolvers object should match the GraphQL type it represents in the schema. Since we don't have any logic now, we should not implement any resolvers for the rest of the types, the data will simply be forwarded as is.\n+\n+Note that we've implemented a custom scalar named `Date` and we resolved it with an NPM package. Let's install it:\n+\n+    $ npm install graphql-iso-date\n+    $ npm install --dev @types/graphql-iso-date\n+\n+Final thing that we have to do would be combining the resolvers and the type-defs under a single GraphQL schema.\n+\n+{{{ diffStep \"2.2\" module=\"server\" files=\"index.ts\" }}}\n+\n+[`graphql-import`](https://www.npmjs.com/package/graphql-import) and [`graphql-tools`](https://www.npmjs.com/package/graphql-tools) are utility packages that will help us create a schema that will be compatible with Apollo's API. Let's install them:\n+\n+    $ npm install graphql-import graphql-tools\n+\n+There's one optimization however that we should make in the our DB. Right now, the each chat document has a direct reference to a message via the `lastMessage` field. Practically speaking, this is NOT how the data sits in the DB. The `lastMessage` should only hold the ID for the correlated message, and then in the Node.JS app we should **resolve** it according to our needs. Let's make the appropriate changes in the DB then:\n+\n+{{{ diffStep \"2.3\" module=\"server\" files=\"db.ts\" }}}\n+\n+And a resolver to the `lastMessage` field:\n+\n+{{{ diffStep \"2.3\" module=\"server\" files=\"schema/typeDefs.graphql\" }}}\n+\n+The first argument of the resolver is the raw chat data received by the DB, and the returned result should be the mapped value which we would like to return to the client.\n+\n+As we get further in this tutorial we should get a better grasp regards resolvers and their API, since we will have to deal with more logic and complexity within our Node.JS app.\n+\n+Assuming that the server is running, we can already test our GraphQL endpoint. Because it's exposed to us via a REST endpoint, we can use a `$ curl` command to send a request to `GET localhost:4000/graphql` and get a response with all the data. Again, the query that we're gonna use to fetch the chats is:\n+\n+```graphql\n+chats {\n+  id\n+  name\n+  picture\n+  lastMessage {\n+    id\n+    content\n+    createdAt\n+  }\n+}\n+```\n+\n+The one-liner version of it with a `$ curl` command looks like so:\n+\n+    curl \\\n+      -X POST \\\n+      -H \"Content-Type: application/json\" \\\n+      --data '{ \"query\": \"{ chats { id name picture lastMessage { id content createdAt } } }\" }' \\\n+      localhost:4000/graphql\n+\n+As a response we should get the data-mock for our chats stored in the server. Since we have that in place, we can go ahead and delete our implementation for the `GET /chats` route.\n+\n+Another way to test and inspect our GraphQL schema would be by using an IDE for the browser called [GraphQL Playground](https://github.com/prisma/graphql-playground). Apollo-Server ships with it right out of the box and can be used right away by navigating to the `localhost:4000/graphql` URL from the browser.\n+\n+[![](https://i.imgur.com/AE5W6OW.png)](https://graphqlbin.com/v2/6RQ6TM)\n+\n+So getting back to the client, all we have to do is to change the fetching URL in the ChatsList component to use our newly implemented GraphQL REST endpoint:\n+\n+{{{ diffStep \"4.1\" module=\"client\" }}}\n+\n+The received data should be similar to the previous one. No further changes are required. In the next chapter, we will continue working on the UI of our front-end application and we will add a new screen to the flow - the `ChatRoomScreen`.\ndiff --git a/.tortilla/manuals/templates/step5.tmpl b/.tortilla/manuals/templates/step5.tmpl\nnew file mode 100644\nindex 0000000..c91d9a6\n--- /dev/null\n+++ b/.tortilla/manuals/templates/step5.tmpl\n@@ -0,0 +1,126 @@\n+Testing is a crucial part when writing an application, especially if we're planning to publish it or make it a commercial thing. Before we hand someone a product, of any kind, we wanna make sure that it passes certain quality checks. We're signed on that product and so it's very important to ensure that it functions properly according our expectations, otherwise wouldn't wanna use it and will look for alternatives.\n+\n+In the context of software, we constantly make changes. It's also inevitable to make all features completely independent from one another, so something in the app is likely to break as we upgrade it or maintain it. That's why we need to write a set of tests that can be run on demand, so when we implement a new feature we can simply run the tests and see what feature broke due to most recent changes.\n+\n+There are currently 3 main testing frameworks in the NPM ecosystem: [Jasmine](https://jasmine.github.io/), [Mocha](https://mochajs.org/), and [Jest](https://jestjs.io/). Each testing framework has its pros, and cons, and at the end of the day it's a matter of preference. In our application we're gonna use [Jest](https://jestjs.io/) - a testing framework which was developed by Facebook. What's good about Jest is that it can be used to test both client and server logic, because it runs as a Node.JS application, but it also emulates the browser environment whenever we run it, thanks to [JSDOM](https://github.com/jsdom/jsdom).\n+\n+![jest](https://user-images.githubusercontent.com/7648874/54493900-e2ce0380-490f-11e9-8075-be4a236c7c38.png)\n+\n+In this chapter we will learn how to test the React.Components in the client, and Apollo-GraphQL resolvers in the server. There are 3 kinds of tests:\n+\n+- Unit tests - which are used to test a single component, independently from other components in our system.\n+- Integration tests - which are used to test a component in relation to other components in our systems (how well do they co-work with each other).\n+- e2e tests (end to end) - which are used to test a complete, from the moment I clicked on a button in the user interface until the data gets back from the server and shown on the screen.\n+\n+The efficiency of the tests go from bottom to top (unit -> e2e), but the maintenance and complexity go from bottom to top (e2e -> unit). Accordingly we will need to find a good balance where we don’t spend too much time on writing tests yet have a good indicator for how well our system functions. So we should write a lot of unit tests, a good amount of integration tests and a handful of e2e tests.\n+\n+![tests-types-table](https://user-images.githubusercontent.com/7648874/54494121-fed2a480-4911-11e9-9370-694ec989729b.png)\n+\n+We will start with the client as it’s much easier, because Jest is set and ready to use right out of the box thanks to `create-react-app`.\n+\n+**Client - Testing React.Components**\n+\n+Thanks to `create-react-app`, we have Jest set and ready to use right out of the box, so we can start writing tests right away. I you'll look at the `src` you'll see a file called `App.test.tsx`, which simply ensures that the component can be rendered without crashing.\n+\n+```jsx\n+import React from 'react';\n+import ReactDOM from 'react-dom';\n+import App from './App';\n+\n+it('renders without crashing', () => {\n+  const div = document.createElement('div');\n+  ReactDOM.render(<App />, div);\n+  ReactDOM.unmountComponentAtNode(div);\n+});\n+```\n+\n+This is not a typical test that you're likely to find in a React project, but it demonstrates very well how Jest can be used to test DOM related issues. If you'll run `$ npm run test` (or `$ yarn test`) in the command line and then press `a`, you should see the following output:\n+\n+![report](https://user-images.githubusercontent.com/7648874/54341429-eabe4700-4674-11e9-8e76-3aaaf7fec79a.png)\n+\n+Jest will automatically run for every file that ends with a `.test.xxx` extension. This is very convenient because the tests can live right next to the component, and you don't need to lookup for it across the project. This behavior can be modified by configuring Jest in the `package.json` file under the `\"jest\"` field. More information about configuring Jest can be found in the official[ configuration documentation](https://jestjs.io/docs/en/configuration).\n+\n+> If you get a warning message regards wrapping the component with `act()` - this is a known issue with hooks and should have a proper solution soon. More about this issue and progress regards its fix can be found in this [GitHub thread](https://github.com/facebook/react/issues/14769#issuecomment-470097212).\n+\n+Now we're gonna write a basic test for the `<ChatsList />` component. In the test, we'll mock a fake response from the server, and examine the contents of rendered HTML. Since the HTML of the component is a dynamic thing and is constantly subject to changes, it would be a good idea to annotate it with `data-testid` attributes so it can be tested regardless of its structure:\n+\n+{{{ diffStep \"5.1\" module=\"client\" files=\"ChatsList.tsx\" }}}\n+\n+Now we can select various HTML elements with a query selector when we test the component. We will install a couple of packages that will assist us in implementing the test:\n+\n+  $ npm install jest-fetch-mock jest-dom react-testing-library\n+\n+- The [`jest-fetch-mock`](https://www.npmjs.com/package/jest-fetch-mock) package can mock responses emitted by the Fetch API.\n+- The [`jest-dom`](https://www.npmjs.com/package/jsdom) package will add custom matchers that will help us examine HTML contents of DOM elements.\n+- The [`react-testing-library`](https://www.npmjs.com/package/react-testing-library) package contains utility methods that will help us test React.Components with Jest.\n+\n+Next, we will create a file under the `src` folder called `setupTests.ts`. This file is loaded configured automatically by `create-react-app` and loaded by Jest, and we can use it to set up our testing environment according to our needs (like said earlier, Jest can be configured, so this file path can be changed). We will use that file to define a fake Fetch API using the `jest-fetch-mock` library:\n+\n+{{{ diffStep \"5.2\" module=\"client\" files=\"src/setupTests.ts\" }}}\n+\n+We will create another file called `ChatsList.test.tsx`, right next to the `<ChatsList />` component under the `ChatsListScreen` directory, and inside we will implement our test. The test should follow these steps:\n+\n+- Mock the response to contain a fake chat, so we won't need to make an actual call to our GraphQL API.\n+- We will create a new instance of `<ChatsList />` and render it in a container element.\n+- We will wait for changes in the DOM caused by `setState()`.\n+- We will test the contents of the container.\n+\n+And this is how the implementation should look like:\n+\n+{{{ diffStep \"5.3\" module=\"client\" files=\"src/components/ChatsListScreen/ChatsList.test.tsx\" }}}\n+\n+> Jest API is vast but pretty intuitive for the most part. It mostly consists of test descriptors and matchers. [Here's a full list of all matchers which are built into Jest's API](https://jestjs.io/docs/en/expect). Always make sure to work against it when writing tests, for optimal results.\n+\n+We will now move on to testing the server where we will learn how to setup Jest manually and test it against a GraphQL API.\n+\n+**Server - Testing GraphQL resolvers**\n+\n+To set-up Jest, we will run the following in the command line:\n+\n+    $ npm install jest @types/jest ts-jest --dev\n+\n+This will basically install Jest and make it useable with TypeScript. In addition, we will need to specify the file pattern that we would like to transform with [`ts-jest`](https://www.npmjs.com/package/ts-jest), by adding the following section to `package.json`:\n+\n+```\n+{\n+  \"jest\": {\n+    \"transform\": {\n+      \"^.+\\\\.(js|jsx|ts|tsx)$\": \"<rootDir>/node_modules/ts-jest\"\n+    }\n+  }\n+}\n+```\n+\n+We will also add a `\"test\"` script in the `package.json` file, so we can run the tests with `$ npm run test` (or `$ yarn test`):\n+\n+```\n+{\n+  \"scripts\": {\n+    \"test\": \"jest\"\n+  }\n+}\n+```\n+\n+This is how our `package.json` should look like at this point:\n+\n+{{{ diffStep \"3.1\" module=\"server\" files=\"package.json\" }}}\n+\n+Now we're gonna test the `chats` query in our GraphQL schema. To do so, we will setup an Apollo Client and send a query request to our back-end, and then we will match the received response with a pre-defined snapshot. Luckily, we don't have to set an actual client, since the tests and the implementation of the back-end live right next to each other, thus, we will install a package which will help us achieving so:\n+\n+    $ npm install apollo-server-testing --dev\n+\n+We will define the test suite under the `tests/queries` folder in a file called `getChats.test.ts`:\n+\n+{{{ diffStep \"3.2\" module=\"server\" files=\"tests/queries/getChats.test.ts\" }}}\n+\n+In the test function, we create a new instance of the Apollo-GraphQL server using our schema, and we query some data against it thanks to the fake client created by [`apollo-server-testing`](https://www.npmjs.com/package/apollo-server-testing).\n+\n+The `.toMatchSnapshot()` matcher will call the `toString()` method on the examined object and will test it against a predefined snapshot. The snapshot will automatically be created once we run the test for the first time and will be stored under the `__snapshot__` directory. This means that the first test run will always pass. This is useful because you can later on observe and adjust manually the snapshot manually without having to write it from scratch. The expected result should be a projection of the data stored in the `db.ts` file.\n+\n+{{{ diffStep \"3.2\" module=\"server\" files=\"tests/queries/__snapshots__\" }}}\n+\n+Always be sure to observe the snapshot before moving on! The received result isn't necessarily what you'd expect. Also it's not a good practice to store production data in the snapshot because it's subject to changes. Normally we would set up another instance of the DB for testing purposes, but since our DB is a mock and doesn't represent real data, there's no need to at this stage.\n+\n+Now that we have the required knowledge regards testing and Jest's API, we will implement tests throughout the tutorial as a trivial thing. We will not go through each and every new matcher that we introduce, as it is self explanatory and there's too much of them. Be sure to work against [this full list of matchers](https://jestjs.io/docs/en/expect) when working with Jest.\n+\n+In the next chapter we will continue expanding our application by adding a `<ChatRoomScreen />`.\ndiff --git a/.tortilla/manuals/templates/step6.tmpl b/.tortilla/manuals/templates/step6.tmpl\nnew file mode 100644\nindex 0000000..2c28669\n--- /dev/null\n+++ b/.tortilla/manuals/templates/step6.tmpl\n@@ -0,0 +1,149 @@\n+In this chapter we will learn how to build a chat room screen. We will setup a router, implement the necessary components, and update the state whenever we send a new message. The screen is NOT gonna be connected to the back-end as it will over complicate things for now. Further this tutorial, we will get to make it full-stack.\n+\n+Since we're gonna have to screens in our app now - `ChatsListScreen` and `ChatRoomScreen`, we will need a router that will be able to alternate between them. We will be using the [`react-router-dom`](https://www.npmjs.com/package/react-router-dom) package to manage the routes of the application:\n+\n+  $ npm install react-router-dom\n+\n+And we will implement a router directly in the `<App />` component:\n+\n+{{{ diffStep 6.1 module=\"client\" files=\"App\" }}}\n+\n+The purpose of a router is to make route managing easy and declarative. It will take care of managing the history within our app and parameterizing certain screens according to our need. Essentially it's a wrap around the `window.history` object which is also compatible with React. I recommend you to go through the [official MDN docs](https://developer.mozilla.org/en-US/docs/Web/API/History) if you're not yet familiar with the concept.\n+\n+The `<Route />` component represents a path for a route in our application. Using the colon syntax (`:chatId`) we basically tell the router that the `/chat` route should be followed by a string whose value can later on be addressed via a parameter called `chatId` when navigating to the route. So here's a sum-up of the routes manifest:\n+\n+\n+\n+*   `/chats` - will navigate to the `ChatsListScreen`.\n+*   `/chat/:chatId` - e.g. `/chat/1`, will navigate to the `ChatRoomScreen` and will parameterize it to show data which is related to chat ID 1.\n+*   Any other route will fallback to the `/chats` route which will redirect us to the `ChatsListScreen`.\n+\n+Now we will implement the `ChatRoomScreen` so the router can function properly. For now we will make it a plain screen which simply prints out the information of the chat that was clicked so we can have a complete flow, and then we will take care of the rest.\n+\n+To do so, we will first implement the `chat` query in our backend. This would be a parameterized query that will provide us with a specific chat according to the received ID, and it will be used by the new screen as soon as it is initialized. First we would update the `Chat` type to contain a `messages` field:\n+\n+{{{ diffStep 4.1 module=\"server\" files=\"schema\" }}}\n+\n+And then we will update our DB mock to be aligned with these changes:\n+\n+{{{ diffStep 4.1 module=\"server\" files=\"db\" }}}\n+\n+This means that when we resolve `Chat.lastMessage`, we should get it directly from the `Chat.messages` field:\n+\n+{{{ diffStep 4.2 module=\"server\" }}}\n+\n+Now that we have an updated schema which is relevant to the new screen that we would like to add, we will declare a new query called `chat`:\n+\n+{{{ diffStep 4.3 module=\"server\" files=\"schema/typeDefs\" }}}\n+\n+Note that unlike the `chats` query, this time we have a parameter. The parameters are provided to the resolver function as the second parameter as a JSON. Using the provided parameter - the chat ID, we will find and return the relevant chat from the DB:\n+\n+{{{ diffStep 4.3 module=\"server\" files=\"schema/resolvers\" }}}\n+\n+> More about the resolver signature can be read in [Apollo-GraphQL's official docs page](https://www.apollographql.com/docs/apollo-server/essentials/data.html#type-signature).\n+\n+Now we will add a test suite:\n+\n+{{{ diffStep 4.3 module=\"server\" files=\"tests/queries/getChat.test\" }}}\n+\n+We can observe the snapshot created by Jest to get a better understanding of how the response should look like:\n+\n+{{{ diffStep 4.3 module=\"server\" files=\"__snapshot__\" }}}\n+\n+If you experience any TypeScript related issues with the following error:\n+\n+```\n+Object literal may only specify known properties, and 'variables' does not exist in type 'Query'.\n+```\n+\n+Add the following declaration file to your project:\n+\n+{{{ diffStep 4.3 module=\"server\" files=\"types\" }}}\n+\n+This is a [known issue](https://github.com/apollographql/apollo-server/issues/2172) in the `apollo-server-testing` package and has a pending [fix PR](https://github.com/apollographql/apollo-server/pull/2307). Now getting back to the client, let's implement a basic version of the `ChatRoomScreen` where we will fetch the new query and print it to the screen:\n+\n+{{{ diffStep 6.2 module=\"client\" }}}\n+\n+Note how we used the `match.params.chatId` variable to get the selected chat ID. The `match` prop is defined and provided to us by the `<Route />` component, since it interfaces directly with the `ChatRoomScreen`. More about that can be read in the [official docs page](https://reacttraining.com/react-router/core/api/match). If you'll run the application and type `/chats/1` in the URL bar, this is what you should see on the screen:\n+\n+![naked-chat](https://user-images.githubusercontent.com/7648874/54664314-d4096b80-4b1e-11e9-9e06-1323cf7b0abe.png)\n+\n+The view has no styling at all but it should be fixed in a moment. To make navigation more convenient we will add an `onClick` listener for each chat item in the `ChatsList`. Using the [history](https://reacttraining.com/react-router/core/api/history) object, provided to us by the `<Route />` component, we will navigate to the correlated `ChatRoomScreen`:\n+\n+{{{ diffStep 6.3 module=\"client\" }}}\n+\n+And add test the new logic:\n+\n+{{{ diffStep 6.4 module=\"client\" }}}\n+\n+If you'll click on the chat item you'll see that the screen changes very suddenly. We can smooth the transition by animating it with CSS. Luckily we don't need to implemented such mechanism manually because there's a package that can do that for us - [`react-router-transition`](https://www.npmjs.com/package/react-router-transition):\n+\n+  $ npm install react-router-transition\n+\n+Using this package, we will create a custom `Switch` component that will play an animation for all its subordinate `Route` components. The animation is defined by the user using a component called `AnimatedSwitch` as specified in the [package's docs page](http://maisano.github.io/react-router-transition/animated-switch/props). So first, let's create our switch component that will play a smooth transition switching routes:\n+\n+{{{ diffStep 6.5 module=\"client\" files=\"AnimatedSwitch\" }}}\n+\n+And then replace it with the main `Switch` component in our app:\n+\n+{{{ diffStep 6.5 module=\"client\" files=\"App\" }}}\n+\n+Both components act identically and thus there shall be no special treatment. Behold the new transition effect:\n+\n+![transition-demo](https://user-images.githubusercontent.com/7648874/54739398-ebb22400-4bf2-11e9-8d4c-2aeb65deeb92.gif)\n+\n+The final screen will be composed out of 3 components:\n+\n+\n+\n+*   A navigation bar.\n+*   A messages list.\n+*   A message input.\n+\n+We will create a new directory under the path `public/assets` and inside we will download and place a couple of assets which are necessary for our view:\n+\n+*   [chat-background.jpg](https://raw.githubusercontent.com/Urigo/WhatsApp-Clone-Client-Angular/master/src/assets/chat-background.jpg)\n+*   [message-mine.png](https://raw.githubusercontent.com/Urigo/WhatsApp-Clone-Client-Angular/master/src/assets/message-mine.png)\n+\n+In the main `index.ts` file of the screen we will simply import all 3 in the right order. We will start with the most simple one - the `ChatRoomNavbar`. The navbar should show the picture of the chat we're currently at and its name, along with a back button that will bring us back to the `ChatsListScreen`:\n+\n+{{{ diffStep 6.6 module=\"client\" files=\"ChatNavbar\" }}}\n+\n+Next, would be the `MesagesList` component, where we will see a scrollable list of all the messages of the active chat:\n+\n+{{{ diffStep 6.6 module=\"client\" files=\"MessagesList\" }}}\n+\n+And finally, would be the `MessageInput` component which will trigger an event whenever we type and submit a new message:\n+\n+{{{ diffStep 6.6 module=\"client\" files=\"MessageInput\" }}}\n+\n+Now that we have all 3 components, we will put them all together in the main `index.ts` file:\n+\n+{{{ diffStep 6.6 module=\"client\" files=\"index\" }}}\n+\n+The view is complete! However the `MessageInput` is not bound to our messages list. We will use the triggered callback to update the chat state, whose changes should appear in the `MessagesList` component in the following render phase:\n+\n+{{{ diffStep 6.7 module=\"client\" }}}\n+\n+This is how the entire flow should look like:\n+\n+![flow-demo](https://user-images.githubusercontent.com/7648874/54739741-27012280-4bf4-11e9-97cb-c715482e2e70.gif)\n+\n+An edge case that should be taken care of is when the messages list length in the view exceeds the length of the container, in which case we will have to scroll down to the bottom of the view. This way we can keep track of the most recent message. We will use `ReactDOM` to retrieve the native HTML element of the container and change the position of the scroller whenever a messages was sent:\n+\n+{{{ diffStep 6.8 module=\"client\" }}}\n+\n+Before we wrap things up, we should also test our components. Since the new components have a direct control over the app's history, we should also find a way to simulate it in our tests. The `react-dom-router` uses the [`history`](https://www.npmjs.com/package/history) package under the hood, that means that we can use that package to inject a custom history object directly into the tested components. Let's install this package if so:\n+\n+  $ npm install history --dev\n+\n+And then implement our test suites:\n+\n+{{{ diffStep 6.9 module=\"client\" files=\"components\" }}}\n+\n+There are many things which are incomplete in the current implementation. The functionality exists in the UI, but no messages are really being sent and stored in the database. In the next chapters we will learn how to:\n+\n+\n+\n+*   Cache query results with Apollo-Client.\n+*   Send messages with GraphQL mutations\ndiff --git a/.tortilla/manuals/templates/step7.tmpl b/.tortilla/manuals/templates/step7.tmpl\nnew file mode 100644\nindex 0000000..4def4f9\n--- /dev/null\n+++ b/.tortilla/manuals/templates/step7.tmpl\n@@ -0,0 +1,105 @@\n+In the previous step we've implemented a `ChatRoomScreen` where we were able to view each chat's messages list by clicking on a chat item from the main screen. It all looks functional, however, there's a significant optimization issue - each time we navigate into a `ChatRoomScreen`, we need to re-fetch the data related to the target chat.\n+\n+The solution for that would be [caching](https://en.wikipedia.org/wiki/Cache_(computing)) the fetch result, so it can be re-used once we re-enter a screen that we've visited before. For now things are fairly simple so the caching mechanism can be implemented manually, but things are gonna get tougher when we add more queries or things like message sending and profile updating to the mix, so it's not gonna be an easy task. Luckily, in the Apollo team they've invented a solution that works right out of the box and integrates perfectly with Apollo-GraphQL server - [Apollo-GraphQL client](https://www.apollographql.com/docs/link/#apollo-client).\n+\n+\n+\n+![caching](https://user-images.githubusercontent.com/7648874/54871150-f505e100-4dea-11e9-9e2d-439fbf3eaebe.png)\n+\n+\n+\n+Apollo-Client is a wrap around our GraphQL REST endpoint which essentially uses HTTP requests (and further on [web-sockets](https://en.wikipedia.org/wiki/WebSocket), but we will get there), something that we've implemented manually so far. Not only it can be used to fetch data, but it will also cache the result of the query so it can be seamlessly re-used when we request the same data. This means that we will need to setup an Apollo-Client and replace all our `fetch()` calls with `client.query()` call. More about Apollo-Client's API further in this tutorial, but let's start configuring it. First we will install few essential NPM packages:\n+\n+  $ npm install apollo-cache-inmemory apollo-client apollo-link apollo-link-http\n+\n+\n+\n+*   [`apollo-client`](https://www.npmjs.com/package/apollo-client) - Apollo-Client's core package, as we explained earlier.\n+*   [`apollo-cache-inmemory`](https://www.npmjs.com/package/apollo-cache-inmemory) - The data store that will be used to cache the results.\n+*   [`apollo-link-http`](https://www.npmjs.com/package/apollo-link-http) - Get GraphQL results over a network using HTTP fetch.\n+\n+We will create a new file in the `src` directory called `client.ts` and inside we will export the client:\n+\n+{{{ diffStep 7.1 module=\"client\" files=\"client\" }}}\n+\n+Although the client can be used directly and integrated into any UI framework, it would be the most comfortable to use a wrap around it which is suitable for React. For that we will use a package called [`react-apollo-hooks`](https://www.npmjs.com/package/react-apollo-hooks) which includes a set of [React hooks](https://reactjs.org/docs/hooks-intro.html) that can connect between our Apollo-Client and target React.Component:\n+\n+    $ npm install react-apollo-hooks graphql-tag\n+\n+With `react-apollo-hooks` we can use the `useQuery()` hook to fetch data from our GraphQL API. The `graphql-tag` package is used to parse the GraphQL string to an [AST](https://en.wikipedia.org/wiki/Abstract_syntax_tree), something which is required when using Apollo Client. Example:\n+\n+\n+```\n+import gql from 'graphql-tag';\n+import { useQuery } from 'react-apollo-hooks';\n+\n+const GET_DOGS = gql`\n+  {\n+    dogs {\n+      id\n+      breed\n+    }\n+  }\n+`;\n+\n+const Dogs = () => {\n+  const { data, error, loading } = useQuery(GET_DOGS);\n+  if (loading) {\n+    return <div>Loading...</div>;\n+  };\n+  if (error) {\n+    return <div>Error! {error.message}</div>;\n+  };\n+\n+  return (\n+    <ul>\n+      {data.dogs.map(dog => (\n+        <li key={dog.id}>{dog.breed}</li>\n+      ))}\n+    </ul>\n+  );\n+};\n+```\n+\n+\n+The package requires a small setup so that imported hooks can use our Apollo-Client:\n+\n+{{{ diffStep 7.2 module=\"client\" files=\"index\" }}}\n+\n+The code above uses the [Context/Provider](https://reactjs.org/docs/context.html) API, thus the client is now known globally. Now that we can use the `useQuery()` hook, there's no need to use the native Fetch API anymore. Let's replace all our Fetch API call instances with a React hook:\n+\n+{{{ diffStep 7.3 module=\"client\" files=\"components\" }}}\n+\n+The replacement is finished. Note that we removed the usage of `useMemo()` - because Apollo has an internal cache mechanism, there's no need to memoize the result anymore. We also used the [`writeQuery()`](https://www.apollographql.com/docs/react/features/caching.html#writequery-and-writefragment) method to edit the stored result in the cache, so in the next render phase we would have an updated chat with the newly added message.\n+\n+We shouldn't feel any change at all in the view and the response time, since we're running it locally, but if we will take a look at the `network` tab in the browser's dev-tools we should notice the differences:\n+\n+**before**\n+\n+![fetch](https://user-images.githubusercontent.com/7648874/54871305-e5879780-4dec-11e9-87bb-3279e9e18342.png)\n+\n+**after**\n+\n+![apollo](https://user-images.githubusercontent.com/7648874/54871319-1bc51700-4ded-11e9-9001-d5518bedf9ad.png)\n+\n+> Above: ChatsListScreen -> ChatRoomScreen -> ChatsListScreen -> ChatRoomScreen\n+\n+This test is obviously very rough, but the deviation is so big that you don't need any accuracy to emphasize the difference. The blue stripes represents the requests made and the time they took. Before we had about 6 request phases, while after we had only 3 of them.\n+\n+Since we don't use the Fetch API anymore, we will also need to update our tests. Right now we mock the response from the fetch API, but a more appropriate way would be creating a fake Apollo Client where we will be able to mock the results. For that we will install a package called [`apollo-link-mock`](https://www.npmjs.com/package/apollo-link-mock):\n+\n+    $ npm install --dev apollo-link-mock\n+\n+And we will create a `test-helpers.ts` file under the `src` directory that will contain the utility function for creating a fake Apollo Client:\n+\n+{{{ diffStep 7.4 module=\"client\" files=\"test-helpers\" }}}\n+\n+The fake client accepts an array of mocks where each mock object will have a `request` key that will contain details about the request and a `result` key which will contain the mocked result. You should get a better understanding of how it works now that we will replace the fake Fetch calls with fake Apollo Clients:\n+\n+{{{ diffStep 7.4 module=\"client\" files=\"src/components\" }}}\n+\n+Note how we used the `ApolloProvider` component to provide the target component with the fake Apollo Client. Like so, any other component which uses Apollo Client should be wrapped with an ApolloProvider when rendering it, otherwise it will not function as intended:\n+\n+{{{ diffStep 7.4 module=\"client\" files=\"src/App\" }}}\n+\n+That's it for this chapter. There's one thing missing to make our `ChatRoomScreen` functional and that would be actually sending a message to the backend and updating the DB. In the next chapter we will learn how to do exactly that with our new Apollo-Client.\ndiff --git a/.tortilla/manuals/templates/step8.tmpl b/.tortilla/manuals/templates/step8.tmpl\nnew file mode 100644\nindex 0000000..b36fbd7\n--- /dev/null\n+++ b/.tortilla/manuals/templates/step8.tmpl\n@@ -0,0 +1,121 @@\n+The view and the functionality for updating the component's state when sending a message already exists. The thing is that messages are not really being sent, we only update the memory in the client. If so, how exactly can we send messages and store them in the DB? For this purpose we're gonna learn about GraphQL mutations - a method for sending and applying mutations in our back-end.\n+\n+**What are GraphQL mutations?**\n+\n+If you have an API endpoint that alters data, like inserting data into a database or altering data already in a database, you should make this endpoint a `Mutation` rather than a `Query`. This is as simple as making the API endpoint part of the top-level `Mutation` type instead of the top-level `Query` type.\n+\n+It's often convenient to have a mutation that maps to a database create or update operation, return the same thing that the server stored. That way, if you modify the data on the server, the client can learn about those modifications. **A GraphQL mutation is like a GraphQL query, only with side effects**. It's equivalent to GET (query) and POST/PUT (mutation) in the context of REST API.\n+\n+Below is a sample GraphQL mutation request:\n+\n+```graphql\n+mutation AddMessage($chatId: ID!) {\n+  addMessage(chatId: $chatId) {\n+    id\n+    contents\n+    createdAt\n+  }\n+}\n+```\n+\n+**How to implement a GraphQL mutation?**\n+\n+Since GraphQL is schema based, we will need to create a new type called `Mutation` in the `typeDefs.graphql` file. In this chapter we want to have the ability to send messages, thus we will have a field named `addMessage` in the new mutation type:\n+\n+{{{ diffStep 5.1 module=\"server\" files=\"typeDefs\" }}}\n+\n+Note that our mutation resolver `addMessage` receives a `chatId`. This is because when adding a message, we should update both the messages collection, and the correlated chat document. Mutations are resolved exactly like any other type in our resolvers manifest. The new resolver should look like this:\n+\n+{{{ diffStep 5.1 module=\"server\" files=\"resolvers\" }}}\n+\n+In terms of testing, we will use a temporary solution for now to reset the DB each time we test a mutation. Since we make a modification in the DB, we need to make sure that each test is completely agnostic and doesn't affect one another, thus, we will export a `resetDB()` method from our `db.ts` module:\n+\n+{{{ diffStep 5.2 module=\"server\" files=\"db.ts\" }}}\n+\n+And we will use the `beforeEach()` test hook to reset the `chats` and `messages` collections:\n+\n+{{{ diffStep 5.2 module=\"server\" files=\"tests\" }}}\n+\n+Now we have the infrastructure set for sending a new message and we can start using it in our client.\n+\n+**How to use a GraphQL mutation?**\n+\n+Like in the previous chapters, we're gonna use a React hook so we can run a mutation more efficiently in a React.Component. For this we're gonna use the [`useMutation()`](https://github.com/trojanowski/react-apollo-hooks#usemutation) react hook. The first argument of the hook is the mutation string, and the second one is the [mutation options](https://www.apollographql.com/docs/react/api/apollo-client.html#ApolloClient.mutate). We're gonna provide our mutation call with a single option called `optimisticResponse`.\n+\n+Optimistic response is a common pattern that will update the state of the component twice so we can have a better UX: First it updates the component's state with the predicted result, and then it will update the state with the actual result.\n+\n+\n+\n+![optimistic_response](https://user-images.githubusercontent.com/7648874/54883302-859df900-4e9f-11e9-9eb7-a98108cd2482.png)\n+\n+\n+This is how the component should look like:\n+\n+{{{ diffStep 8.1 module=\"client\" }}}\n+\n+Note that unlike `useQuery()`, `useMutation()` returns a callback that will run the mutation only once called, NOT immediately. Seemingly, everything works fine, but if you'll try to navigate from `ChatsListScreen` to `ChatRoomScreen`, send a message, and then go back, you'll see that the last message was not updated. So why is that exactly?\n+\n+**Cache updating**\n+\n+As explained in the previous chapter, Apollo-Client will cache all the results in a data-store. Later on, rather than re-fetching the data, it will look up for the result in the store and will serve it to you in case it exists. That means, that even though we ran the mutation and updated the data on the server, our data-store is still left behind and it needs to be updated as well, otherwise Apollo-Client will see nothing wrong with the outcome.\n+\n+Apollo-Client stores the data in a hash, where the key represents the query and the value represents the retrieved result. This means that the cache will need to be updated for:\n+\n+\n+\n+*   `chats` query - which we already did, without really diving into the reason behind it.\n+*   `chat(chatId: $chatId)` where `chatId` is the chat that was just mutated.\n+\n+Indeed, a query will be duplicated for each and every distinct set of parameters. So potentially our data-store can grow infinite amount of times, and we will need to take care of it and manage it correctly, so things won't get out of hand.\n+\n+To update a query, we will first export the `getChats` query to a separate file so it can be imported in the `ChatRoomScreen`. We will define all our GraphQL assets under the `src/graphql` directory:\n+\n+{{{ diffStep 8.2 module=\"client\" files=\"graphql\" }}}\n+\n+And then we will read the memoized result from the store using [`client.readQuery`](https://www.apollographql.com/docs/react/features/caching.html#readquery), update it, and then rewrite it using [`client.writeQuery`](https://www.apollographql.com/docs/react/features/caching.html#writequery-and-writefragment). We can gain access to the client object via the `update` callback which will be triggered right after the mutation has been successfully executed. This is how it should look like:\n+\n+{{{ diffStep 8.2 module=\"client\" files=\"components\" }}}\n+\n+Right now what happens is that we update a single chat document twice: Once for the `chats` query and another time for the `chat($chatId)` query. This work is redundant and become more complex as we add more `chat` related queries. To solve it, we can define and use a [GraphQL fragment](https://www.apollographql.com/docs/react/advanced/fragments.html).\n+\n+**Using Fragments**\n+\n+A GraphQL fragment is a shared piece of query logic.\n+\n+```graphql\n+fragment NameParts on Person {\n+  firstName\n+  lastName\n+}\n+\n+query GetPerson {\n+  people(id: \"7\") {\n+    ...NameParts\n+    avatar(size: LARGE)\n+  }\n+}\n+```\n+\n+It's important to note that the component after the `on` clause is designated for the type we are selecting from. In this case, `people` is of type `Person` and we want to select the `firstName` and `lastName` fields from `people(id: \"7\")`.\n+\n+Apollo maps the fragment ID to its retrieved data in the store. By default, Apollo will compose the fragment ID out of the entity type and the ID of the document. For example, for a `Chat` document with an ID of `7`, the fragment ID would be `Chat:7`. This behavior can be modified, but there's no need to.\n+\n+We will define the following fragments in our app:\n+\n+\n+\n+*   `Message` - represents a message\n+*   `Chat` - represents a chat, **without its messages list**.\n+*   `FullChat` - represents a chat, **including its messages list**.\n+\n+Once we define the fragments we can start embedding them in our queries. We will create a new directory path `src/graphql/fragments`, and inside we will create a dedicated fragment file for each fragment type: `message.fragment.ts`, `chat.fragment.ts` and `fullChat.fragment.ts`:\n+\n+{{{ diffStep 8.3 module=\"client\" files=\"graphql/fragments\" }}}\n+\n+And now that we have the fragments available to us, let's embed them in the relevant queries:\n+\n+{{{ diffStep 8.3 module=\"client\" files=\"components, graphql/queries\" }}}\n+\n+Similarly to query rewriting, we will use the [`readFragment()`](https://www.apollographql.com/docs/react/features/caching.html#readfragment) and [`writeFragment()`](https://www.apollographql.com/docs/react/features/caching.html#writefragment) methods in the same way to rewrite the fragments. When working with a fragment we need to compose its ID, just like explained earlier. The default mapping function called `defaultDataIdFromObject` can be imported from `apollo-cache-inmemory` and be used to specify the fragment that we would like to read/write. Accordingly, we're gonna replace all our query re-writings with fragments re-writings, as we don't need them anymore:\n+\n+{{{ diffStep 8.4 module=\"client\" }}}\ndiff --git a/.tortilla/manuals/templates/step9.tmpl b/.tortilla/manuals/templates/step9.tmpl\nnew file mode 100644\nindex 0000000..b5d4e47\n--- /dev/null\n+++ b/.tortilla/manuals/templates/step9.tmpl\n@@ -0,0 +1,136 @@\n+So far we've been just writing code. If there was an error we would most likely discover it during runtime. As a reminder, we've created a project which is based on TypeScript, but we haven't really took any advantage of TypeScript's type safety mechanism. Currently, the TypeScript compiler is configured to work on loose mode, so any object which is not bound to any type will be converted to `any` - a type which is compatible with any type of casting and will ignore type errors.\n+\n+So far it's been very convenient because we've only started to learn about building an app and the ecosystem around it, but for a long term project it's would be very handy to take a full advantage of TypeScript and not let it go under the radar. So where exactly are we missing type checkings? In the core of our project - when dealing with GraphQL documents.\n+\n+When we run a query, or a mutation, we wanna make sure that we use the received data correctly, based on its intended shape and form. For example, given the following GraphQL query:\n+\n+```graphql\n+query Chats {\n+  chats {\n+    id\n+    name\n+    picture\n+  }\n+}\n+```\n+\n+We want to have the following TypeScript type:\n+\n+```ts\n+export type Chat = {\n+  __typename?: \"Chat\"\n+  id: string\n+  name: string\n+  picture: string\n+}\n+\n+export type ChatQuery = {\n+  __typename?: \"Query\"\n+  chats: Chats[]\n+}\n+\n+```\n+\n+So later on we can use it with `react-apollo-hooks` like so:\n+\n+```ts\n+useQuery<ChatsQuery>(getChatsQuery)\n+```\n+\n+Everything looks nice in theory, but the main issue that arises from having type definitions is that we need to maintain and sync 2 similar code bases: A GraphQL schema and TypeScript type definitions. Both are essentially the same, and if so, why do we even need to maintain 2 code bases? Isn't there a tool which does that for us? A question which brings us straight to the point of the chapter.\n+\n+**Introducing: GraphQL Code Generator**\n+\n+With [GraphQL Code Generator](https://graphql-code-generator.com/) we can generate TypeScript definitions given a GraphQL schema, and a set of GraphQL documents if they are presented to us.\n+\n+\n+\n+![graphql-codegen](https://user-images.githubusercontent.com/7648874/54940897-9f564380-4f66-11e9-9891-3b994a1daef1.png)\n+\n+\n+GraphQL Code Generator is a simple CLI tool that operates based on a configuration file and can generate TypeScript types for both Client and Server. We will start with generating types for the server, as the client types are dependent on them.\n+\n+In the server project, install GraphQL Code Generator via NPM (or Yarn)\n+\n+    $ npm install @graphql-codegen/cli --dev\n+\n+Now GraphQL Code Generator can be used directly from the `scripts` section in the `package.json` file using the `gql-gen` binary. We're gonna call the code generation script \"codegen\":\n+\n+```json\n+{\n+  \"codegen\": \"gql-gen\"\n+}\n+```\n+\n+This command will automatically be referenced to a configuration file in the root of our project called `codegen.yml`. The essence of this file is to provide the code generator with the GraphQL schema, GraphQL documents, the output path of the type definition file/s and a set of plug-ins. More about the configuration file can be found in the [official website](https://graphql-code-generator.com/docs/getting-started/codegen-config).\n+\n+In the server project, we will generate the `types/graphql.d.ts` file and we will use a couple of plug-ins to do that:\n+\n+\n+\n+*   `@graphql-codegen/typescript` - Will generate the core TypeScript types from our GraphQL schema.\n+*   `@graphql-codegen/typescript-resolvers` - Will generate resolvers signatures with the generated TypeScript types.\n+\n+> A full list of available plugins is available [here](https://graphql-code-generator.com/docs/plugins/). In addition, you can write your own [custom plugin](https://graphql-code-generator.com/docs/custom-codegen/write-your-plugin).\n+\n+Let's install these 2 plugins:\n+\n+    $ npm install @graphql-codegen/typescript @graphql-codegen/typescript-resolvers --dev\n+\n+And write the `codegen.yml` file:\n+\n+{{{ diffStep 6.1 module=\"server\" files=\"codegen.yml\" }}}\n+\n+> See inline comments to learn more about our configuration setup.\n+\n+Now if you'll run `$ npm run codegen` you should see that a new file `types/graphql.d.ts` has been generated with all the necessary TypeScript types. Since these types are very likely to change as we extend our schema, there's no need to include them in our project, thus it's recommended to add the appropriate .gitignore rule:\n+\n+{{{ diffStep 6.1 module=\"server\" files=\".gitignore\" }}}\n+\n+Now we can import the `IResolvers` type from the file we've just created and use it in the `resolvers.ts` file to ensure our resolvers handlers have the right signature:\n+\n+{{{ diffStep 6.2 module=\"server\" }}}\n+\n+We will now repeat the same process in the client with few tweaks. Again, we will install GraphQL Code Generator:\n+\n+    $ npm install @graphql-codegen/cli --dev\n+\n+And we will define a script:\n+\n+```json\n+{\n+  \"codegen\": \"gql-gen\"\n+}\n+```\n+\n+This time around, because we're in the client, we will define a set of glob paths that will specify which files contain GraphQL documents. GraphQL Code Generator is smart enough to automatically recognize the documents within these files by looking at the `gql` template literal calls using the `typescript-operations` package. We will be using a plugin called `typescript-react-apollo` to generate React/Apollo-GraphQL hooks that can be used in our function components. Let's install the necessary plugins:\n+\n+    $ npm install @graphql-codegen/typescript @graphql-codegen/typescript-operations @graphql-codegen/typescript-react-apollo --dev\n+\n+And we will write the `codegen.yml` file:\n+\n+{{{ diffStep 9.1 module=\"client\" files=\"codegen.yml\" }}}\n+\n+For the schema path we could have also provided a REST GraphQL endpoint that exposes a GraphQL schema. This way if there's an existing running GraphQL API, we can generate TypeScript types out of it, such as GitHub's GraphQL API. The advantages of providing a local path is that the server doesn't have to be running in order to generate types, which is more comfortable in development, and we can bypass authentication if the REST endpoint is guarded with such mechanism. This will be useful in further chapters when we're introduced to the concept of authentication.\n+\n+Be sure to add a .gitignore rule:\n+\n+{{{ diffStep 9.1 module=\"client\" files=\".gitignore\" }}}\n+\n+Now we have TypeScript types available to us and we can replace `useQuery()` and `useMutation()` calls with the generated React hooks:\n+\n+{{{ diffStep 9.2 module=\"client\" }}}\n+\n+To test if things are working properly, we can address a non existing field in one of the retrieved query results, for example `chat.foo` in `useGetChatQuery()`. We should receive the following typing error when trying to run the project:\n+\n+```\n+TypeScript error: Property 'foo' does not exist on type '{ __typename?: \"Chat\"; } & { __typename?: \"Chat\"; } & { messages: ({ __typename?: \"Message\"; } & { __typename?: \"Message\"; } & Pick<Message, \"id\" | \"createdAt\" | \"content\">)[]; } & { __typename?: \"Chat\"; } & Pick<...> & { ...; }'.  TS2339\n+\n+    44 |   const addMessage = useAddMessageMutation()\n+    45 |\n+  > 46 |   console.log(chat.foo)\n+       |                    ^\n+    47 |\n+    48 |   const onSendMessage = useCallback((content) => {\n+    49 |     addMessage({\n+```\ndiff --git a/client/.env b/client/.env\nnew file mode 100644\nindex 0000000..f0fc5d5\n--- /dev/null\n+++ b/client/.env\n@@ -0,0 +1 @@\n+REACT_APP_SERVER_URL=http://localhost:4000\n\\ No newline at end of file\ndiff --git a/client/.gitignore b/client/.gitignore\nnew file mode 100644\nindex 0000000..31561ca\n--- /dev/null\n+++ b/client/.gitignore\n@@ -0,0 +1,25 @@\n+# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.\n+\n+# dependencies\n+/node_modules\n+/.pnp\n+.pnp.js\n+\n+# testing\n+/coverage\n+\n+# production\n+/build\n+\n+# misc\n+.DS_Store\n+.env.local\n+.env.development.local\n+.env.test.local\n+.env.production.local\n+\n+npm-debug.log*\n+yarn-debug.log*\n+yarn-error.log*\n+\n+src/graphql/types.tsx\ndiff --git a/client/codegen.yml b/client/codegen.yml\nnew file mode 100644\nindex 0000000..63aca59\n--- /dev/null\n+++ b/client/codegen.yml\n@@ -0,0 +1,20 @@\n+schema: ../Whatsapp-Clone-Server/schema/typeDefs.graphql\n+documents:\n+  - ./src/components/**/*.tsx\n+  - ./src/graphql/fragments/**/*.ts\n+  - ./src/graphql/queries/**/*.ts\n+  - ./src/graphql/subscriptions/**/*.ts\n+overwrite: true\n+generates:\n+  ./src/graphql/types.tsx:\n+    plugins:\n+      - typescript\n+      - typescript-operations\n+      - typescript-react-apollo\n+    # The combined options of all provided plug-ins\n+    # More information about the options below:\n+    # graphql-code-generator.com/docs/plugins/typescript-react-apollo#configuration\n+    config:\n+      withHOC: false\n+      withHooks: true\n+      withComponent: false\ndiff --git a/client/package.json b/client/package.json\nnew file mode 100644\nindex 0000000..ee4ddd6\n--- /dev/null\n+++ b/client/package.json\n@@ -0,0 +1,59 @@\n+{\n+  \"name\": \"whatsapp-clone-client\",\n+  \"version\": \"0.1.0\",\n+  \"private\": true,\n+  \"repository\": {\n+    \"type\": \"git\",\n+    \"url\": \"https://github.com/Urigo/WhatsApp-Clone-Client-React.git\"\n+  },\n+  \"dependencies\": {\n+    \"@material-ui/core\": \"3.9.2\",\n+    \"@material-ui/icons\": \"3.0.2\",\n+    \"apollo-cache-inmemory\": \"1.5.1\",\n+    \"apollo-client\": \"2.5.1\",\n+    \"apollo-link\": \"1.2.11\",\n+    \"apollo-link-http\": \"1.5.14\",\n+    \"apollo-link-ws\": \"1.0.17\",\n+    \"apollo-utilities\": \"1.2.1\",\n+    \"graphql-tag\": \"2.10.1\",\n+    \"moment\": \"2.24.0\",\n+    \"react\": \"16.8.4\",\n+    \"react-apollo-hooks\": \"0.4.3\",\n+    \"react-dom\": \"16.8.4\",\n+    \"react-router-dom\": \"5.0.0\",\n+    \"react-router-transition\": \"1.3.0\",\n+    \"react-scripts\": \"2.1.8\",\n+    \"styled-components\": \"4.1.3\",\n+    \"subscriptions-transport-ws\": \"0.9.16\",\n+    \"typescript\": \"3.3.3333\"\n+  },\n+  \"scripts\": {\n+    \"start\": \"react-scripts start\",\n+    \"build\": \"react-scripts build\",\n+    \"test\": \"react-scripts test\",\n+    \"eject\": \"react-scripts eject\",\n+    \"codegen\": \"gql-gen\"\n+  },\n+  \"eslintConfig\": {\n+    \"extends\": \"react-app\"\n+  },\n+  \"browserslist\": [\n+    \">0.2%\",\n+    \"not dead\",\n+    \"not ie <= 11\",\n+    \"not op_mini all\"\n+  ],\n+  \"devDependencies\": {\n+    \"@graphql-codegen/cli\": \"1.0.3\",\n+    \"@graphql-codegen/typescript\": \"1.0.3\",\n+    \"@graphql-codegen/typescript-operations\": \"1.0.3\",\n+    \"@graphql-codegen/typescript-react-apollo\": \"1.0.3\",\n+    \"apollo-link-mock\": \"1.0.1\",\n+    \"graphql\": \"14.1.1\",\n+    \"history\": \"4.9.0\",\n+    \"jest-dom\": \"3.1.1\",\n+    \"jest-fetch-mock\": \"2.1.1\",\n+    \"react-testing-library\": \"6.0.0\",\n+    \"ts-node\": \"8.0.3\"\n+  }\n+}\n\\ No newline at end of file\ndiff --git a/client/public/assets/chat-background.jpg b/client/public/assets/chat-background.jpg\nnew file mode 100644\nindex 0000000..12cf45c\nBinary files /dev/null and b/client/public/assets/chat-background.jpg differ\ndiff --git a/client/public/assets/message-mine.png b/client/public/assets/message-mine.png\nnew file mode 100644\nindex 0000000..a5503eb\nBinary files /dev/null and b/client/public/assets/message-mine.png differ\ndiff --git a/client/public/assets/message-other.png b/client/public/assets/message-other.png\nnew file mode 100644\nindex 0000000..a9477be\nBinary files /dev/null and b/client/public/assets/message-other.png differ\ndiff --git a/client/public/assets/whatsapp-icon.png b/client/public/assets/whatsapp-icon.png\nnew file mode 100644\nindex 0000000..ef4c897\nBinary files /dev/null and b/client/public/assets/whatsapp-icon.png differ\ndiff --git a/client/public/favicon.ico b/client/public/favicon.ico\nnew file mode 100644\nindex 0000000..a11777c\nBinary files /dev/null and b/client/public/favicon.ico differ\ndiff --git a/client/public/index.html b/client/public/index.html\nnew file mode 100644\nindex 0000000..75980d5\n--- /dev/null\n+++ b/client/public/index.html\n@@ -0,0 +1,41 @@\n+<!DOCTYPE html>\n+<html lang=\"en\">\n+  <head>\n+    <meta charset=\"utf-8\" />\n+    <link rel=\"shortcut icon\" href=\"%PUBLIC_URL%/favicon.ico\" />\n+    <meta\n+      name=\"viewport\"\n+      content=\"width=device-width, initial-scale=1, shrink-to-fit=no\"\n+    />\n+    <meta name=\"theme-color\" content=\"#000000\" />\n+    <!--\n+      manifest.json provides metadata used when your web app is installed on a\n+      user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/\n+    -->\n+    <link rel=\"manifest\" href=\"%PUBLIC_URL%/manifest.json\" />\n+    <!--\n+      Notice the use of %PUBLIC_URL% in the tags above.\n+      It will be replaced with the URL of the `public` folder during the build.\n+      Only files inside the `public` folder can be referenced from the HTML.\n+\n+      Unlike \"/favicon.ico\" or \"favicon.ico\", \"%PUBLIC_URL%/favicon.ico\" will\n+      work correctly both with client-side routing and a non-root public URL.\n+      Learn how to configure a non-root public URL by running `npm run build`.\n+    -->\n+    <title>React App</title>\n+  </head>\n+  <body>\n+    <noscript>You need to enable JavaScript to run this app.</noscript>\n+    <div id=\"root\"></div>\n+    <!--\n+      This HTML file is a template.\n+      If you open it directly in the browser, you will see an empty page.\n+\n+      You can add webfonts, meta tags, or analytics to this file.\n+      The build step will place the bundled scripts into the <body> tag.\n+\n+      To begin the development, run `npm start` or `yarn start`.\n+      To create a production bundle, use `npm run build` or `yarn build`.\n+    -->\n+  </body>\n+</html>\ndiff --git a/client/public/manifest.json b/client/public/manifest.json\nnew file mode 100644\nindex 0000000..1f2f141\n--- /dev/null\n+++ b/client/public/manifest.json\n@@ -0,0 +1,15 @@\n+{\n+  \"short_name\": \"React App\",\n+  \"name\": \"Create React App Sample\",\n+  \"icons\": [\n+    {\n+      \"src\": \"favicon.ico\",\n+      \"sizes\": \"64x64 32x32 24x24 16x16\",\n+      \"type\": \"image/x-icon\"\n+    }\n+  ],\n+  \"start_url\": \".\",\n+  \"display\": \"standalone\",\n+  \"theme_color\": \"#000000\",\n+  \"background_color\": \"#ffffff\"\n+}\ndiff --git a/client/src/App.jsx b/client/src/App.jsx\nnew file mode 100644\nindex 0000000..82697ca\n--- /dev/null\n+++ b/client/src/App.jsx\n@@ -0,0 +1,26 @@\n+import * as React from 'react'\n+import { BrowserRouter, Route, Redirect } from 'react-router-dom'\n+import AuthScreen from './components/AuthScreen'\n+import ChatRoomScreen from './components/ChatRoomScreen'\n+import ChatsListScreen from './components/ChatsListScreen'\n+import ChatCreationScreen from './components/ChatCreationScreen'\n+import AnimatedSwitch from './components/AnimatedSwitch'\n+import { withAuth } from './services/auth.service'\n+\n+const App = () => (\n+  <BrowserRouter>\n+    <AnimatedSwitch>\n+      <Route exact path=\"/sign-in\" component={AuthScreen} />\n+      <Route exact path=\"/chats\" component={withAuth(ChatsListScreen)} />\n+      <Route exact path=\"/chats/:chatId\" component={withAuth(ChatRoomScreen)} />\n+      <Route exact path=\"/new-chat\" component={withAuth(ChatCreationScreen)} />\n+    </AnimatedSwitch>\n+    <Route exact path=\"/\" render={redirectToChats} />\n+  </BrowserRouter>\n+)\n+\n+const redirectToChats = () => (\n+  <Redirect to=\"/chats\" />\n+)\n+\n+export default App\ndiff --git a/client/src/App.test.js b/client/src/App.test.js\nnew file mode 100644\nindex 0000000..903a2ea\n--- /dev/null\n+++ b/client/src/App.test.js\n@@ -0,0 +1,17 @@\n+import React from 'react';\n+import { ApolloProvider } from 'react-apollo-hooks'\n+import ReactDOM from 'react-dom';\n+import App from './App';\n+import { mockApolloClient } from './test-helpers'\n+\n+it('renders without crashing', () => {\n+  const client = mockApolloClient()\n+  const div = document.createElement('div');\n+\n+  ReactDOM.render(\n+    <ApolloProvider client={client}>\n+      <App />\n+    </ApolloProvider>\n+  , div);\n+  ReactDOM.unmountComponentAtNode(div);\n+});\ndiff --git a/client/src/client.ts b/client/src/client.ts\nnew file mode 100644\nindex 0000000..e18678a\n--- /dev/null\n+++ b/client/src/client.ts\n@@ -0,0 +1,43 @@\n+import { InMemoryCache } from 'apollo-cache-inmemory'\n+import { ApolloClient } from 'apollo-client'\n+import { getMainDefinition } from 'apollo-utilities'\n+import { HttpLink } from 'apollo-link-http'\n+import { WebSocketLink } from 'apollo-link-ws'\n+import { ApolloLink, split } from 'apollo-link'\n+\n+const httpUri = process.env.REACT_APP_SERVER_URL + '/graphql'\n+const wsUri = httpUri.replace(/^https?/, 'ws')\n+\n+const httpLink = new HttpLink({\n+  uri: httpUri,\n+  credentials: 'include',\n+})\n+\n+const wsLink = new WebSocketLink({\n+  uri: wsUri,\n+  options: {\n+    // Automatic reconnect in case of connection error\n+    reconnect: true,\n+  },\n+})\n+\n+const terminatingLink = split(\n+    ({ query }) => {\n+      const { kind, operation } = getMainDefinition(query)\n+      // If this is a subscription query, use wsLink, otherwise use httpLink\n+      return (\n+        kind === 'OperationDefinition' && operation === 'subscription'\n+      )\n+    },\n+    wsLink,\n+    httpLink,\n+)\n+\n+const link = ApolloLink.from([terminatingLink])\n+\n+const inMemoryCache = new InMemoryCache()\n+\n+export default new ApolloClient({\n+  link,\n+  cache: inMemoryCache,\n+})\ndiff --git a/client/src/components/AnimatedSwitch.tsx b/client/src/components/AnimatedSwitch.tsx\nnew file mode 100644\nindex 0000000..81f4d01\n--- /dev/null\n+++ b/client/src/components/AnimatedSwitch.tsx\n@@ -0,0 +1,37 @@\n+import { Switch } from 'react-router-dom'\n+import { AnimatedSwitch, spring } from 'react-router-transition'\n+import styled from 'styled-components'\n+\n+// A workaround to make test pass\n+const SwitchComponent = process.env.NODE_ENV === 'test' ? Switch : AnimatedSwitch\n+\n+const glide = val =>\n+  spring(val, {\n+    stiffness: 174,\n+    damping: 24,\n+  })\n+\n+const mapStyles = styles => ({\n+  transform: `translateX(${styles.offset}%)`,\n+})\n+\n+const MyAnimatedSwitch =  styled(SwitchComponent).attrs(() => ({\n+  atEnter: { offset: 100 },\n+  atLeave: { offset: glide(-100) },\n+  atActive: { offset: glide(0) },\n+  mapStyles,\n+}))`\n+  position: relative;\n+  overflow: hidden;\n+  height: 100vh;\n+  width: 100vw;\n+\n+  > div {\n+    position: absolute;\n+    overflow: hidden;\n+    height: 100vh;\n+    width: 100vw;\n+  }\n+`\n+\n+export default MyAnimatedSwitch\ndiff --git a/client/src/components/AuthScreen/SignInForm.test.tsx b/client/src/components/AuthScreen/SignInForm.test.tsx\nnew file mode 100644\nindex 0000000..c6901d0\n--- /dev/null\n+++ b/client/src/components/AuthScreen/SignInForm.test.tsx\n@@ -0,0 +1,81 @@\n+import { createMemoryHistory } from 'history'\n+import React from 'react'\n+import { cleanup, render, fireEvent, wait, waitForElement } from 'react-testing-library'\n+import SignInForm from './SignInForm'\n+\n+describe('SignInForm', () => {\n+  afterEach(cleanup)\n+  afterEach(() => fetch.resetMocks())\n+\n+  it('enables sign-in button when filled in', async () => {\n+    const history = createMemoryHistory()\n+\n+    {\n+      const { container, getByTestId } = render(<SignInForm history={history} />)\n+      const usernameInput = getByTestId('username-input').querySelector('input')\n+      const passwordInput = getByTestId('password-input').querySelector('input')\n+      const signInButton = getByTestId('sign-in-button') as HTMLButtonElement\n+\n+      expect(signInButton.disabled).toEqual(true)\n+\n+      fireEvent.change(usernameInput, { target: { value: 'username' } })\n+      fireEvent.change(passwordInput, { target: { value: 'password' } })\n+\n+      await waitForElement(() => usernameInput)\n+      await waitForElement(() => passwordInput)\n+\n+      expect(signInButton.disabled).toEqual(false)\n+    }\n+  })\n+\n+  it('prints server error if input was wrong', async () => {\n+    const history = createMemoryHistory()\n+\n+    fetchMock.mockRejectOnce(new Error('sign-in failed'))\n+\n+    {\n+      const { container, getByTestId } = render(<SignInForm history={history} />)\n+      const usernameInput = getByTestId('username-input').querySelector('input')\n+      const passwordInput = getByTestId('password-input').querySelector('input')\n+      const signInButton = getByTestId('sign-in-button') as HTMLButtonElement\n+      const errorMessage = getByTestId('error-message')\n+\n+      fireEvent.change(usernameInput, { target: { value: 'username' } })\n+      fireEvent.change(passwordInput, { target: { value: 'password' } })\n+\n+      await waitForElement(() => usernameInput)\n+      await waitForElement(() => passwordInput)\n+\n+      fireEvent.click(signInButton)\n+\n+      await waitForElement(() => errorMessage)\n+\n+      expect(errorMessage.innerHTML).toEqual('sign-in failed')\n+    }\n+  })\n+\n+  it('navigates to /chats if everything went right', async () => {\n+    const history = createMemoryHistory()\n+\n+    fetchMock.mockResponseOnce('success')\n+\n+    {\n+      const { container, getByTestId } = render(<SignInForm history={history} />)\n+      const usernameInput = getByTestId('username-input').querySelector('input')\n+      const passwordInput = getByTestId('password-input').querySelector('input')\n+      const signInButton = getByTestId('sign-in-button') as HTMLButtonElement\n+\n+      fireEvent.change(usernameInput, { target: { value: 'username' } })\n+      fireEvent.change(passwordInput, { target: { value: 'password' } })\n+\n+      await waitForElement(() => usernameInput)\n+      await waitForElement(() => passwordInput)\n+\n+      fireEvent.click(signInButton)\n+\n+      await wait(() =>\n+        expect(history.location.pathname).toEqual('/chats')\n+      )\n+    }\n+  })\n+})\ndiff --git a/client/src/components/AuthScreen/SignInForm.tsx b/client/src/components/AuthScreen/SignInForm.tsx\nnew file mode 100644\nindex 0000000..b870443\n--- /dev/null\n+++ b/client/src/components/AuthScreen/SignInForm.tsx\n@@ -0,0 +1,81 @@\n+import { History } from 'history'\n+import * as React from 'react'\n+import { useCallback, useState } from 'react'\n+import { signIn } from '../../services/auth.service'\n+import {\n+  SignForm,\n+  ActualForm,\n+  Legend,\n+  Section,\n+  TextField,\n+  Button,\n+  ErrorMessage,\n+} from './form-components'\n+\n+export default ({ history }) => {\n+  const [username, setUsername] = useState('')\n+  const [password, setPassword] = useState('')\n+  const [error, setError] = useState('')\n+\n+  const onUsernameChange = useCallback(({ target }) => {\n+    setError('')\n+    setUsername(target.value)\n+  }, [true])\n+\n+  const onPasswordChange = useCallback(({ target }) => {\n+    setError('')\n+    setPassword(target.value)\n+  }, [true])\n+\n+  const maySignIn = useCallback(() => {\n+    return !!(username && password)\n+  }, [username, password])\n+\n+  const handleSignIn = useCallback(() => {\n+    signIn({ username, password })\n+      .then(() => {\n+        history.replace('/chats')\n+      })\n+      .catch(error => {\n+        setError(error.message || error)\n+      })\n+  }, [username, password])\n+\n+  return (\n+    <SignForm>\n+      <ActualForm>\n+        <Legend>Sign in</Legend>\n+        <Section style={{ width: '100%' }}>\n+          <TextField\n+            data-testid=\"username-input\"\n+            label=\"Username\"\n+            value={username}\n+            onChange={onUsernameChange}\n+            margin=\"normal\"\n+            placeholder=\"Enter your username\"\n+          />\n+          <TextField\n+            data-testid=\"password-input\"\n+            label=\"Password\"\n+            type=\"password\"\n+            value={password}\n+            onChange={onPasswordChange}\n+            margin=\"normal\"\n+            placeholder=\"Enter your password\"\n+          />\n+        </Section>\n+        <Button\n+          data-testid=\"sign-in-button\"\n+          type=\"button\"\n+          color=\"secondary\"\n+          variant=\"contained\"\n+          disabled={!maySignIn()}\n+          onClick={handleSignIn}\n+        >\n+          Sign in\n+        </Button>\n+        <ErrorMessage data-testid=\"error-message\">{error}</ErrorMessage>\n+      </ActualForm>\n+    </SignForm>\n+  )\n+}\ndiff --git a/client/src/components/AuthScreen/SignUpForm.test.tsx b/client/src/components/AuthScreen/SignUpForm.test.tsx\nnew file mode 100644\nindex 0000000..7b8bae9\n--- /dev/null\n+++ b/client/src/components/AuthScreen/SignUpForm.test.tsx\n@@ -0,0 +1,99 @@\n+import { createMemoryHistory } from 'history'\n+import React from 'react'\n+import { cleanup, render, fireEvent, wait, waitForElement } from 'react-testing-library'\n+import SignUpForm from './SignUpForm'\n+\n+describe('SignUpForm', () => {\n+  afterEach(cleanup)\n+  afterEach(() => fetch.resetMocks())\n+\n+  it('enables sign-up button when filled in', async () => {\n+    const history = createMemoryHistory()\n+\n+    {\n+      const { container, getByTestId } = render(<SignUpForm history={history} />)\n+      const nameInput = getByTestId('name-input').querySelector('input')\n+      const usernameInput = getByTestId('username-input').querySelector('input')\n+      const passwordInput = getByTestId('password-input').querySelector('input')\n+      const passwordConfirmInput = getByTestId('password-confirm-input').querySelector('input')\n+      const signUpButton = getByTestId('sign-up-button') as HTMLButtonElement\n+\n+      expect(signUpButton.disabled).toEqual(true)\n+\n+      fireEvent.change(nameInput, { target: { value: 'User Name' } })\n+      fireEvent.change(usernameInput, { target: { value: 'username' } })\n+      fireEvent.change(passwordInput, { target: { value: 'password' } })\n+      fireEvent.change(passwordConfirmInput, { target: { value: 'password' } })\n+\n+      await waitForElement(() => nameInput)\n+      await waitForElement(() => usernameInput)\n+      await waitForElement(() => passwordInput)\n+      await waitForElement(() => passwordConfirmInput)\n+\n+      expect(signUpButton.disabled).toEqual(false)\n+    }\n+  })\n+\n+  it('prints server error if input was wrong', async () => {\n+    const history = createMemoryHistory()\n+\n+    fetchMock.mockRejectOnce(new Error('sign-up failed'))\n+\n+    {\n+      const { container, getByTestId } = render(<SignUpForm history={history} />)\n+      const nameInput = getByTestId('name-input').querySelector('input')\n+      const usernameInput = getByTestId('username-input').querySelector('input')\n+      const passwordInput = getByTestId('password-input').querySelector('input')\n+      const passwordConfirmInput = getByTestId('password-confirm-input').querySelector('input')\n+      const signUpButton = getByTestId('sign-up-button') as HTMLButtonElement\n+      const errorMessage = getByTestId('error-message')\n+\n+      fireEvent.change(nameInput, { target: { value: 'User Name' } })\n+      fireEvent.change(usernameInput, { target: { value: 'username' } })\n+      fireEvent.change(passwordInput, { target: { value: 'password' } })\n+      fireEvent.change(passwordConfirmInput, { target: { value: 'password' } })\n+\n+      await waitForElement(() => nameInput)\n+      await waitForElement(() => usernameInput)\n+      await waitForElement(() => passwordInput)\n+      await waitForElement(() => passwordConfirmInput)\n+\n+      fireEvent.click(signUpButton)\n+\n+      await waitForElement(() => errorMessage)\n+\n+      expect(errorMessage.innerHTML).toEqual('sign-up failed')\n+    }\n+  })\n+\n+  it('navigates to /sign-in if everything went right', async () => {\n+    const history = createMemoryHistory()\n+\n+    fetchMock.mockResponseOnce('success')\n+\n+    {\n+      const { container, getByTestId } = render(<SignUpForm history={history} />)\n+      const nameInput = getByTestId('name-input').querySelector('input')\n+      const usernameInput = getByTestId('username-input').querySelector('input')\n+      const passwordInput = getByTestId('password-input').querySelector('input')\n+      const passwordConfirmInput = getByTestId('password-confirm-input').querySelector('input')\n+      const signUpButton = getByTestId('sign-up-button') as HTMLButtonElement\n+\n+      fireEvent.change(nameInput, { target: { value: 'User Name' } })\n+      fireEvent.change(usernameInput, { target: { value: 'username' } })\n+      fireEvent.change(passwordInput, { target: { value: 'password' } })\n+      fireEvent.change(passwordConfirmInput, { target: { value: 'password' } })\n+\n+      await waitForElement(() => nameInput)\n+      await waitForElement(() => usernameInput)\n+      await waitForElement(() => passwordInput)\n+      await waitForElement(() => passwordConfirmInput)\n+\n+      fireEvent.click(signUpButton)\n+\n+      await wait(() =>\n+        expect(history.location.pathname).toEqual('/sign-in')\n+      )\n+    }\n+  })\n+})\ndiff --git a/client/src/components/AuthScreen/SignUpForm.tsx b/client/src/components/AuthScreen/SignUpForm.tsx\nnew file mode 100644\nindex 0000000..c062ff3\n--- /dev/null\n+++ b/client/src/components/AuthScreen/SignUpForm.tsx\n@@ -0,0 +1,123 @@\n+import * as React from 'react'\n+import { useCallback, useState } from 'react'\n+import { signUp } from '../../services/auth.service'\n+import {\n+  SignForm,\n+  ActualForm,\n+  Legend,\n+  Section,\n+  TextField,\n+  Button,\n+  ErrorMessage,\n+} from './form-components'\n+\n+export default ({ history }) => {\n+  const [name, setName] = useState('')\n+  const [username, setUsername] = useState('')\n+  const [password, setPassword] = useState('')\n+  const [passwordConfirm, setPasswordConfirm] = useState('')\n+  const [error, setError] = useState('')\n+\n+  const updateName = useCallback(({ target }) => {\n+    setError('')\n+    setName(target.value)\n+  }, [true])\n+\n+  const updateUsername = useCallback(({ target }) => {\n+    setError('')\n+    setUsername(target.value)\n+  }, [true])\n+\n+  const updatePassword = useCallback(({ target }) => {\n+    setError('')\n+    setPassword(target.value)\n+  }, [true])\n+\n+  const updatePasswordConfirm = useCallback(({ target }) => {\n+    setError('')\n+    setPasswordConfirm(target.value)\n+  }, [true])\n+\n+  const maySignUp = useCallback(() => {\n+    return !!(name && username && password && password === passwordConfirm)\n+  }, [name, username, password, passwordConfirm])\n+\n+  const handleSignUp = useCallback(() => {\n+    signUp({ username, password, passwordConfirm, name })\n+      .then(() => {\n+        history.replace('/sign-in')\n+      })\n+      .catch(error => {\n+        setError(error.message || error)\n+      })\n+  }, [name, username, password, passwordConfirm])\n+\n+  return (\n+    <SignForm>\n+      <ActualForm>\n+        <Legend>Sign up</Legend>\n+        <Section\n+          style={{\n+            float: 'left',\n+            width: 'calc(50% - 10px)',\n+            paddingRight: '10px',\n+          }}\n+        >\n+          <TextField\n+            data-testid=\"name-input\"\n+            label=\"Name\"\n+            value={name}\n+            onChange={updateName}\n+            autoComplete=\"off\"\n+            margin=\"normal\"\n+          />\n+          <TextField\n+            data-testid=\"username-input\"\n+            label=\"Username\"\n+            value={username}\n+            onChange={updateUsername}\n+            autoComplete=\"off\"\n+            margin=\"normal\"\n+          />\n+        </Section>\n+        <Section\n+          style={{\n+            float: 'right',\n+            width: 'calc(50% - 10px)',\n+            paddingLeft: '10px',\n+          }}\n+        >\n+          <TextField\n+            data-testid=\"password-input\"\n+            label=\"Password\"\n+            type=\"password\"\n+            value={password}\n+            onChange={updatePassword}\n+            autoComplete=\"off\"\n+            margin=\"normal\"\n+          />\n+          <TextField\n+            data-testid=\"password-confirm-input\"\n+            label=\"Confirm password\"\n+            type=\"password\"\n+            value={passwordConfirm}\n+            onChange={updatePasswordConfirm}\n+            autoComplete=\"off\"\n+            margin=\"normal\"\n+          />\n+        </Section>\n+        <Button\n+          data-testid=\"sign-up-button\"\n+          type=\"button\"\n+          color=\"secondary\"\n+          variant=\"contained\"\n+          disabled={!maySignUp()}\n+          onClick={handleSignUp}\n+        >\n+          Sign up\n+        </Button>\n+        <ErrorMessage data-testid=\"error-message\">{error}</ErrorMessage>\n+      </ActualForm>\n+    </SignForm>\n+  )\n+}\ndiff --git a/client/src/components/AuthScreen/form-components.ts b/client/src/components/AuthScreen/form-components.ts\nnew file mode 100644\nindex 0000000..d3bb362\n--- /dev/null\n+++ b/client/src/components/AuthScreen/form-components.ts\n@@ -0,0 +1,75 @@\n+import MaterialButton from '@material-ui/core/Button'\n+import MaterialTextField from '@material-ui/core/TextField'\n+import styled from 'styled-components'\n+\n+export const SignForm = styled.div `\n+  height: calc(100% - 265px);\n+`\n+\n+export const ActualForm = styled.form `\n+  padding: 20px;\n+`\n+\n+export const Section = styled.div `\n+  padding-bottom: 35px;\n+`\n+\n+export const Legend = styled.legend `\n+  font-weight: bold;\n+  color: white;\n+`\n+\n+export const Label = styled.label `\n+  color: white !important;\n+`\n+\n+export const Input = styled.input `\n+  color: white;\n+\n+  &::placeholder {\n+    color: var(--primary-bg);\n+  }\n+`\n+\n+export const TextField = styled(MaterialTextField) `\n+  width: 100%;\n+  position: relative;\n+\n+  > div::before {\n+    border-color: white !important;\n+  }\n+\n+  input {\n+    color: white !important;\n+\n+    &::placeholder {\n+      color: var(--primary-bg) !important;\n+    }\n+  }\n+\n+  label {\n+    color: white !important;\n+  }\n+`\n+\n+export const Button = styled(MaterialButton) `\n+  width: 100px;\n+  display: block !important;\n+  margin: auto !important;\n+  background-color: var(--secondary-bg) !important;\n+\n+  &[disabled] {\n+    color: #38a81c;\n+  }\n+\n+  &:not([disabled]) {\n+    color: white;\n+  }\n+`\n+\n+export const ErrorMessage = styled.div `\n+  position: fixed;\n+  color: red;\n+  font-size: 15px;\n+  margin-top: 20px;\n+`\ndiff --git a/client/src/components/AuthScreen/index.tsx b/client/src/components/AuthScreen/index.tsx\nnew file mode 100644\nindex 0000000..5cbe2a9\n--- /dev/null\n+++ b/client/src/components/AuthScreen/index.tsx\n@@ -0,0 +1,85 @@\n+import * as React from 'react'\n+import { useMemo } from 'react'\n+import { Route } from 'react-router-dom'\n+import styled from 'styled-components'\n+import AnimatedSwitch from '../AnimatedSwitch'\n+import SignInForm from './SignInForm'\n+import SignUpForm from './SignUpForm'\n+\n+const Container = styled.div `\n+  background: radial-gradient(rgb(34, 65, 67), rgb(17, 48, 50)),\n+    url(/assets/chat-background.jpg) no-repeat;\n+  background-size: cover;\n+  background-blend-mode: multiply;\n+  color: white;\n+`\n+\n+const Intro = styled.div `\n+  height: 265px;\n+`\n+\n+const Icon = styled.img `\n+  width: 125px;\n+  height: auto;\n+  margin-left: auto;\n+  margin-right: auto;\n+  padding-top: 70px;\n+  display: block;\n+`\n+\n+const Title = styled.h2 `\n+  width: 100%;\n+  text-align: center;\n+  color: white;\n+`\n+\n+const Alternative = styled.div `\n+  position: fixed;\n+  bottom: 10px;\n+  left: 10px;\n+\n+  a {\n+    color: var(--secondary-bg);\n+  }\n+`\n+\n+export default ({ history, location }) => {\n+  const alternative = useMemo(() => {\n+    if (location.pathname === '/sign-in') {\n+      const handleSignUp = () => {\n+        history.replace('/sign-up')\n+      }\n+\n+      return (\n+        <Alternative>\n+          Don't have an account yet? <a onClick={handleSignUp}>Sign up!</a>\n+        </Alternative>\n+      )\n+    }\n+    else {\n+      const handleSignIn = () => {\n+        history.replace('/sign-in')\n+      }\n+\n+      return (\n+        <Alternative>\n+          Already have an accout? <a onClick={handleSignIn}>Sign in!</a>\n+        </Alternative>\n+      )\n+    }\n+  }, [location.pathname])\n+\n+  return (\n+    <Container className=\"AuthScreen Screen\">\n+      <Intro className=\"AuthScreen-intro\">\n+        <Icon src=\"assets/whatsapp-icon.png\" className=\"AuthScreen-icon\" />\n+        <Title className=\"AuthScreen-title\">WhatsApp</Title>\n+      </Intro>\n+      <AnimatedSwitch>\n+        <Route exact path=\"/sign-in\" component={SignInForm} />\n+        <Route exact path=\"/sign-up\" component={SignUpForm} />\n+      </AnimatedSwitch>\n+      {alternative}\n+    </Container>\n+  )\n+}\ndiff --git a/client/src/components/ChatCreationScreen/ChatCreationNavbar.test.tsx b/client/src/components/ChatCreationScreen/ChatCreationNavbar.test.tsx\nnew file mode 100644\nindex 0000000..a729600\n--- /dev/null\n+++ b/client/src/components/ChatCreationScreen/ChatCreationNavbar.test.tsx\n@@ -0,0 +1,28 @@\n+import { createMemoryHistory } from 'history'\n+import React from 'react'\n+import { cleanup, render, fireEvent, wait } from 'react-testing-library'\n+import ChatCreationNavbar from './ChatCreationNavbar'\n+\n+describe('ChatCreationNavbar', () => {\n+  afterEach(cleanup)\n+\n+  it('goes back on arrow click', async () => {\n+    const history = createMemoryHistory()\n+\n+    history.push('/new-chat')\n+\n+    await wait(() =>\n+      expect(history.location.pathname).toEqual('/new-chat')\n+    )\n+\n+    {\n+      const { container, getByTestId } = render(<ChatCreationNavbar history={history} />)\n+\n+      fireEvent.click(getByTestId('back-button'))\n+\n+      await wait(() =>\n+        expect(history.location.pathname).toEqual('/chats')\n+      )\n+    }\n+  })\n+})\ndiff --git a/client/src/components/ChatCreationScreen/ChatCreationNavbar.tsx b/client/src/components/ChatCreationScreen/ChatCreationNavbar.tsx\nnew file mode 100644\nindex 0000000..3e3692a\n--- /dev/null\n+++ b/client/src/components/ChatCreationScreen/ChatCreationNavbar.tsx\n@@ -0,0 +1,41 @@\n+import ArrowBackIcon from '@material-ui/icons/ArrowBack'\n+import { Toolbar, Button } from '@material-ui/core'\n+import * as React from 'react'\n+import { useCallback } from 'react'\n+import styled from 'styled-components'\n+\n+const Container = styled(Toolbar) `\n+  display: flex;\n+  background-color: var(--primary-bg);\n+  color: var(--primary-text);\n+  font-size: 20px;\n+  line-height: 40px;\n+`\n+\n+const BackButton = styled(Button) `\n+  svg {\n+    color: var(--primary-text);\n+  }\n+`\n+\n+const Title = styled.div `\n+  flex: 1;\n+`\n+\n+const ChatCreationNavbar = ({ history }) => {\n+  const navBack = useCallback(() => {\n+    history.replace('/chats')\n+  }, [true])\n+\n+  return (\n+    <Container>\n+      <BackButton data-testid=\"back-button\" onClick={navBack}>\n+        <ArrowBackIcon />\n+      </BackButton>\n+      <Title>Create Chat</Title>\n+    </Container>\n+  )\n+}\n+\n+\n+export default ChatCreationNavbar\ndiff --git a/client/src/components/ChatCreationScreen/index.tsx b/client/src/components/ChatCreationScreen/index.tsx\nnew file mode 100644\nindex 0000000..744f673\n--- /dev/null\n+++ b/client/src/components/ChatCreationScreen/index.tsx\n@@ -0,0 +1,62 @@\n+import gql from 'graphql-tag'\n+import * as React from 'react'\n+import { useCallback } from 'react'\n+import styled from 'styled-components'\n+import * as fragments from '../../graphql/fragments'\n+import UsersList from '../UsersList'\n+import ChatCreationNavbar from './ChatCreationNavbar'\n+import { useAddChatMutation } from '../../graphql/types'\n+import { writeChat } from '../../services/cache.service'\n+\n+const Container = styled.div `\n+  height: calc(100% - 56px);\n+  overflow-y: overlay;\n+`\n+\n+const StyledUsersList = styled(UsersList) `\n+  height: calc(100% - 56px);\n+`\n+\n+gql`\n+  mutation AddChat($recipientId: ID!) {\n+    addChat(recipientId: $recipientId) {\n+      ...Chat\n+    }\n+  }\n+  ${fragments.chat}\n+`\n+\n+export default ({ history }) => {\n+  const addChat = useAddChatMutation({\n+    update: (client, { data: { addChat } }) => {\n+      writeChat(client, addChat)\n+    }\n+  })\n+\n+  const onUserPick = useCallback((user) => {\n+    addChat({\n+      optimisticResponse: {\n+        __typename: 'Mutation',\n+        addChat: {\n+          __typename: 'Chat',\n+          id: Math.random().toString(36).substr(2, 9),\n+          name: user.name,\n+          picture: user.picture,\n+          lastMessage: null,\n+        },\n+      },\n+      variables: {\n+        recipientId: user.id,\n+      },\n+    }).then(({ data: { addChat } }) => {\n+      history.push(`/chats/${addChat.id}`)\n+    })\n+  }, [addChat])\n+\n+  return (\n+    <div>\n+      <ChatCreationNavbar history={history} />\n+      <UsersList onUserPick={onUserPick} />\n+    </div>\n+  )\n+}\ndiff --git a/client/src/components/ChatRoomScreen/ChatNavbar.test.tsx b/client/src/components/ChatRoomScreen/ChatNavbar.test.tsx\nnew file mode 100644\nindex 0000000..cbc1b0f\n--- /dev/null\n+++ b/client/src/components/ChatRoomScreen/ChatNavbar.test.tsx\n@@ -0,0 +1,108 @@\n+import { createMemoryHistory } from 'history'\n+import React from 'react'\n+import { ApolloProvider } from 'react-apollo-hooks'\n+import { cleanup, render, fireEvent, wait } from 'react-testing-library'\n+import { mockApolloClient } from '../../test-helpers'\n+import ChatNavbar from './ChatNavbar'\n+import { RemoveChatDocument } from '../../graphql/types'\n+\n+describe('ChatNavbar', () => {\n+  afterEach(cleanup)\n+\n+  it('renders chat data', () => {\n+    const client = mockApolloClient()\n+\n+    const chat = {\n+      id: '1',\n+      name: 'Foo Bar',\n+      picture: 'https://localhost:4000/picture.jpg',\n+    }\n+\n+    {\n+      const { container, getByTestId } = render(\n+        <ApolloProvider client={client}>\n+          <ChatNavbar chat={chat} />\n+        </ApolloProvider>\n+      )\n+\n+      expect(getByTestId('chat-name')).toHaveTextContent('Foo Bar')\n+      expect(getByTestId('chat-picture')).toHaveAttribute('src', 'https://localhost:4000/picture.jpg')\n+    }\n+  })\n+\n+  it('goes back on arrow click', async () => {\n+    const client = mockApolloClient()\n+\n+    const chat = {\n+      id: '1',\n+      name: 'Foo Bar',\n+      picture: 'https://localhost:4000/picture.jpg',\n+    }\n+\n+    const history = createMemoryHistory()\n+\n+    history.push('/chats/1')\n+\n+    await wait(() =>\n+      expect(history.location.pathname).toEqual('/chats/1')\n+    )\n+\n+    {\n+      const { container, getByTestId } = render(\n+        <ApolloProvider client={client}>\n+          <ChatNavbar chat={chat} history={history} />\n+        </ApolloProvider>\n+      )\n+\n+      fireEvent.click(getByTestId('back-button'))\n+\n+      await wait(() =>\n+        expect(history.location.pathname).toEqual('/chats')\n+      )\n+    }\n+  })\n+\n+  it('goes back on chat removal', async () => {\n+    const client = mockApolloClient([\n+      {\n+        request: {\n+          query: RemoveChatDocument,\n+          variables: { chatId: '1' },\n+        },\n+        result: {\n+          data: {\n+            removeChat: '1'\n+          }\n+        }\n+      },\n+    ])\n+\n+    const chat = {\n+      id: '1',\n+      name: 'Foo Bar',\n+      picture: 'https://localhost:4000/picture.jpg',\n+    }\n+\n+    const history = createMemoryHistory()\n+\n+    history.push('/chats/1')\n+\n+    await wait(() =>\n+      expect(history.location.pathname).toEqual('/chats/1')\n+    )\n+\n+    {\n+      const { container, getByTestId } = render(\n+        <ApolloProvider client={client}>\n+          <ChatNavbar chat={chat} history={history} />\n+        </ApolloProvider>\n+      )\n+\n+      fireEvent.click(getByTestId('delete-button'))\n+\n+      await wait(() =>\n+        expect(history.location.pathname).toEqual('/chats')\n+      )\n+    }\n+  })\n+})\ndiff --git a/client/src/components/ChatRoomScreen/ChatNavbar.tsx b/client/src/components/ChatRoomScreen/ChatNavbar.tsx\nnew file mode 100644\nindex 0000000..3e8656a\n--- /dev/null\n+++ b/client/src/components/ChatRoomScreen/ChatNavbar.tsx\n@@ -0,0 +1,92 @@\n+import Button from '@material-ui/core/Button'\n+import Toolbar from '@material-ui/core/Toolbar'\n+import ArrowBackIcon from '@material-ui/icons/ArrowBack'\n+import DeleteIcon from '@material-ui/icons/Delete'\n+import gql from 'graphql-tag'\n+import * as React from 'react'\n+import { useCallback, useState } from 'react'\n+import styled from 'styled-components'\n+import { eraseChat } from '../../services/cache.service'\n+import { useRemoveChatMutation } from '../../graphql/types'\n+\n+const Container = styled(Toolbar) `\n+  padding: 0;\n+  display: flex;\n+  flex-direction: row;\n+  background-color: var(--primary-bg);\n+  color: var(--primary-text);\n+`\n+\n+const BackButton = styled(Button) `\n+  svg {\n+    color: var(--primary-text);\n+  }\n+`\n+\n+const Rest = styled.div `\n+  flex: 1;\n+  display: flex;\n+  justify-content: flex-end;\n+`\n+\n+const Picture = styled.img `\n+  height: 40px;\n+  width: 40px;\n+  margin-top: 3px;\n+  margin-left: -22px;\n+  object-fit: cover;\n+  padding: 5px;\n+  border-radius: 50%;\n+`\n+\n+const Name = styled.div `\n+  line-height: 56px;\n+`\n+\n+const DeleteButton = styled(Button)`\n+  color: var(--primary-text) !important;\n+`\n+\n+export const removeChatMutation = gql`\n+  mutation RemoveChat($chatId: ID!) {\n+    removeChat(chatId: $chatId)\n+  }\n+`\n+\n+const ChatNavbar = ({ chat, history }) => {\n+  const removeChat = useRemoveChatMutation({\n+    variables: {\n+      chatId: chat.id\n+    },\n+    update: (client, { data: { removeChat } }) => {\n+      eraseChat(client, removeChat)\n+    }\n+  })\n+\n+  const handleRemoveChat = useCallback(() => {\n+    removeChat().then(() => {\n+      history.replace('/chats')\n+    })\n+  }, [removeChat])\n+\n+  const navBack = useCallback(() => {\n+    history.replace('/chats')\n+  }, [true])\n+\n+  return (\n+    <Container className={name}>\n+      <BackButton data-testid=\"back-button\" onClick={navBack}>\n+        <ArrowBackIcon />\n+      </BackButton>\n+      <Picture data-testid=\"chat-picture\" src={chat.picture} />\n+      <Name data-testid=\"chat-name\">{chat.name}</Name>\n+      <Rest>\n+        <DeleteButton data-testid=\"delete-button\" onClick={handleRemoveChat}>\n+          <DeleteIcon />\n+        </DeleteButton>\n+      </Rest>\n+    </Container>\n+  )\n+}\n+\n+export default ChatNavbar\ndiff --git a/client/src/components/ChatRoomScreen/MessageInput.test.tsx b/client/src/components/ChatRoomScreen/MessageInput.test.tsx\nnew file mode 100644\nindex 0000000..ce5fc86\n--- /dev/null\n+++ b/client/src/components/ChatRoomScreen/MessageInput.test.tsx\n@@ -0,0 +1,47 @@\n+import { createMemoryHistory } from 'history'\n+import React from 'react'\n+import { cleanup, render, fireEvent, wait, waitForElement } from 'react-testing-library'\n+import MessageInput from './MessageInput'\n+\n+describe('MessageInput', () => {\n+  afterEach(cleanup)\n+\n+  it('triggers callback on send button click', async () => {\n+    const onSendMessage = jest.fn(() => {})\n+\n+    {\n+      const { container, getByTestId } = render(<MessageInput onSendMessage={onSendMessage} />)\n+      const messageInput = getByTestId('message-input')\n+      const sendButton = getByTestId('send-button')\n+\n+      fireEvent.change(messageInput, { target: { value: 'foo' } })\n+\n+      await waitForElement(() => messageInput)\n+\n+      fireEvent.click(sendButton)\n+\n+      await wait(() =>\n+        expect(onSendMessage.mock.calls.length).toBe(1)\n+      )\n+    }\n+  })\n+\n+  it('triggers callback on Enter press', async () => {\n+    const onSendMessage = jest.fn(() => {})\n+\n+    {\n+      const { container, getByTestId } = render(<MessageInput onSendMessage={onSendMessage} />)\n+      const messageInput = getByTestId('message-input')\n+\n+      fireEvent.change(messageInput, { target: { value: 'foo' } })\n+\n+      await waitForElement(() => messageInput)\n+\n+      fireEvent.keyPress(messageInput, { key: 'Enter', code: 13, charCode: 13 })\n+\n+      await wait(() =>\n+        expect(onSendMessage.mock.calls.length).toBe(1)\n+      )\n+    }\n+  })\n+})\ndiff --git a/client/src/components/ChatRoomScreen/MessageInput.tsx b/client/src/components/ChatRoomScreen/MessageInput.tsx\nnew file mode 100644\nindex 0000000..c0ebf27\n--- /dev/null\n+++ b/client/src/components/ChatRoomScreen/MessageInput.tsx\n@@ -0,0 +1,88 @@\n+import Button from '@material-ui/core/Button'\n+import SendIcon from '@material-ui/icons/Send'\n+import * as React from 'react'\n+import { useState } from 'react'\n+import styled from 'styled-components'\n+\n+const Container = styled.div`\n+  display: flex;\n+  height: 50px;\n+  padding: 5px;\n+  width: calc(100% - 10px);\n+`\n+\n+const ActualInput = styled.input `\n+  width: calc(100% - 50px);\n+  border: none;\n+  border-radius: 999px;\n+  padding: 10px;\n+  padding-left: 20px;\n+  padding-right: 20px;\n+  font-size: 15px;\n+  outline: none;\n+  box-shadow: 0 1px silver;\n+  font-size: 18px;\n+  line-height: 45px;\n+`\n+\n+const SendButton = styled(Button) `\n+  min-width: 50px !important;\n+  width: 50px !important;\n+  border-radius: 999px !important;\n+  background-color: var(--primary-bg) !important;\n+  margin: 0 5px !important;\n+  margin-right: 0 !important;\n+  color: white !important;\n+  padding-left: 20px !important;\n+\n+  svg {\n+    margin-left: -3px;\n+  }\n+`\n+\n+const MessageInput = ({ onSendMessage }) => {\n+  const [message, setMessage] = useState('')\n+\n+  const onKeyPress = e => {\n+    if (e.charCode === 13) {\n+      submitMessage()\n+    }\n+  }\n+\n+  const onChange = ({ target }) => {\n+    setMessage(target.value)\n+  }\n+\n+  const submitMessage = () => {\n+    if (!message) return\n+\n+    setMessage('')\n+\n+    if (typeof onSendMessage === 'function') {\n+      onSendMessage(message)\n+    }\n+  }\n+\n+  return (\n+    <Container>\n+      <ActualInput\n+        data-testid=\"message-input\"\n+        type=\"text\"\n+        placeholder=\"Type a message\"\n+        value={message}\n+        onKeyPress={onKeyPress}\n+        onChange={onChange}\n+      />\n+      <SendButton\n+        data-testid=\"send-button\"\n+        variant=\"contained\"\n+        color=\"primary\"\n+        onClick={submitMessage}\n+      >\n+        <SendIcon />\n+      </SendButton>\n+    </Container>\n+  )\n+}\n+\n+export default MessageInput\ndiff --git a/client/src/components/ChatRoomScreen/MessagesList.test.tsx b/client/src/components/ChatRoomScreen/MessagesList.test.tsx\nnew file mode 100644\nindex 0000000..26534f6\n--- /dev/null\n+++ b/client/src/components/ChatRoomScreen/MessagesList.test.tsx\n@@ -0,0 +1,37 @@\n+import { createMemoryHistory } from 'history'\n+import React from 'react'\n+import { cleanup, render, fireEvent, wait, getByTestId } from 'react-testing-library'\n+import MessagesList from './MessagesList'\n+\n+describe('MessagesList', () => {\n+  afterEach(cleanup)\n+\n+  it('renders messages data', () => {\n+    const messages = [\n+      {\n+        id: '1',\n+        content: 'foo',\n+        createdAt: new Date(0),\n+      },\n+      {\n+        id: '2',\n+        content: 'bar',\n+        createdAt: new Date(1000 * 60 * 60),\n+      },\n+    ]\n+\n+    let message1, message2\n+    {\n+      const { container, getAllByTestId, getByTestId } = render(<MessagesList messages={messages} />)\n+      const match = getAllByTestId('message-item')\n+      message1 = match[0]\n+      message2 = match[1]\n+    }\n+\n+    expect(getByTestId(message1, 'message-content')).toHaveTextContent('foo')\n+    expect(getByTestId(message1, 'message-date')).toHaveTextContent('08:00')\n+\n+    expect(getByTestId(message2, 'message-content')).toHaveTextContent('bar')\n+    expect(getByTestId(message2, 'message-date')).toHaveTextContent('09:00')\n+  })\n+})\ndiff --git a/client/src/components/ChatRoomScreen/MessagesList.tsx b/client/src/components/ChatRoomScreen/MessagesList.tsx\nnew file mode 100644\nindex 0000000..713ba8d\n--- /dev/null\n+++ b/client/src/components/ChatRoomScreen/MessagesList.tsx\n@@ -0,0 +1,104 @@\n+import moment from 'moment'\n+import * as React from 'react'\n+import { useEffect, useRef } from 'react'\n+import * as ReactDOM from 'react-dom'\n+import styled, { css } from 'styled-components'\n+\n+const Container = styled.div`\n+  display: block;\n+  flex: 2;\n+  overflow-y: overlay;\n+  padding: 0 15px;\n+`\n+\n+const MessageItem = styled.div `\n+  display: inline-block;\n+  position: relative;\n+  max-width: 100%;\n+  border-radius: 7px;\n+  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.15);\n+  margin-top: 10px;\n+  margin-bottom: 10px;\n+  clear: both;\n+\n+  &::after {\n+    content: '';\n+    display: table;\n+    clear: both;\n+  }\n+\n+  &::before {\n+    content: '';\n+    position: absolute;\n+    bottom: 3px;\n+    width: 12px;\n+    height: 19px;\n+    background-position: 50% 50%;\n+    background-repeat: no-repeat;\n+    background-size: contain;\n+  }\n+\n+  ${props => props.isMine ? css `\n+    float: right;\n+    background-color: #dcf8c6;\n+\n+    &::before {\n+      right: -11px;\n+      background-image: url(/assets/message-mine.png);\n+    }\n+  ` : css `\n+    float: left;\n+    background-color: #fff;\n+\n+    &::before {\n+      left: -11px;\n+      background-image: url(/assets/message-other.png);\n+    }\n+  `}\n+`\n+\n+const Contents = styled.div `\n+  padding: 5px 7px;\n+  word-wrap: break-word;\n+\n+  &::after {\n+    content: ' \\00a0\\00a0\\00a0\\00a0\\00a0\\00a0\\00a0\\00a0\\00a0\\00a0\\00a0\\00a0\\00a0\\00a0\\00a0\\00a0\\00a0\\00a0\\00a0';\n+    display: inline;\n+  }\n+`\n+\n+const Timestamp = styled.div `\n+  position: absolute;\n+  bottom: 2px;\n+  right: 7px;\n+  color: gray;\n+  font-size: 12px;\n+`\n+\n+const MessagesList = ({ messages }) => {\n+  const selfRef = useRef(null)\n+\n+  useEffect(() => {\n+    if (!selfRef.current) return\n+\n+    const selfDOMNode = ReactDOM.findDOMNode(selfRef.current) as HTMLElement\n+    selfDOMNode.scrollTop = Number.MAX_SAFE_INTEGER\n+  }, [messages.length])\n+\n+  return (\n+    <Container ref={selfRef}>\n+      {messages.map((message) => (\n+        <MessageItem\n+          data-testid=\"message-item\"\n+          isMine={message.isMine}\n+          key={message.id}\n+        >\n+          <Contents data-testid=\"message-content\">{message.content}</Contents>\n+          <Timestamp data-testid=\"message-date\">{moment(message.createdAt).format('HH:mm')}</Timestamp>\n+        </MessageItem>\n+      ))}\n+    </Container>\n+  )\n+}\n+\n+export default MessagesList\ndiff --git a/client/src/components/ChatRoomScreen/index.tsx b/client/src/components/ChatRoomScreen/index.tsx\nnew file mode 100644\nindex 0000000..6f3ca29\n--- /dev/null\n+++ b/client/src/components/ChatRoomScreen/index.tsx\n@@ -0,0 +1,90 @@\n+import { defaultDataIdFromObject } from 'apollo-cache-inmemory'\n+import gql from 'graphql-tag'\n+import * as React from 'react'\n+import { useCallback } from 'react'\n+import { Redirect } from 'react-router-dom'\n+import { useApolloClient, useQuery, useMutation } from 'react-apollo-hooks'\n+import styled from 'styled-components'\n+import ChatNavbar from './ChatNavbar'\n+import MessageInput from './MessageInput'\n+import MessagesList from './MessagesList'\n+import { useGetChatQuery, useAddMessageMutation } from '../../graphql/types'\n+import * as queries from '../../graphql/queries'\n+import * as fragments from '../../graphql/fragments'\n+import { writeMessage } from '../../services/cache.service'\n+\n+const Container = styled.div `\n+  background: url(/assets/chat-background.jpg);\n+  display: flex;\n+  flex-flow: column;\n+  height: 100vh;\n+`\n+\n+const getChatQuery = gql `\n+  query GetChat($chatId: ID!) {\n+    chat(chatId: $chatId) {\n+      ...FullChat\n+    }\n+  }\n+  ${fragments.fullChat}\n+`\n+\n+const addMessageMutation = gql `\n+  mutation AddMessage($chatId: ID!, $content: String!) {\n+    addMessage(chatId: $chatId, content: $content) {\n+      ...Message\n+    }\n+  }\n+  ${fragments.message}\n+`\n+\n+const ChatRoomScreen = ({ history, match }) => {\n+  const { params: { chatId } } = match\n+  const client = useApolloClient()\n+  const { data: { chat }, loading: loadingChat } = useGetChatQuery({\n+    variables: { chatId }\n+  })\n+  const addMessage = useAddMessageMutation()\n+\n+  const onSendMessage = useCallback((content) => {\n+    addMessage({\n+      variables: { chatId, content },\n+      optimisticResponse: {\n+        __typename: 'Mutation',\n+        addMessage: {\n+          __typename: 'Message',\n+          id: Math.random().toString(36).substr(2, 9),\n+          createdAt: new Date(),\n+          isMine: true,\n+          chat: {\n+            __typename: 'Chat',\n+            id: chatId,\n+          },\n+          content,\n+        }\n+      },\n+      update: (client, { data: { addMessage } }) => {\n+        writeMessage(client, addMessage)\n+      },\n+    })\n+  }, [chat])\n+\n+  if (loadingChat) return null\n+\n+  // Chat was probably removed from cache by the subscription handler\n+  if (!chat) {\n+    return (\n+      <Redirect to=\"/chats\" />\n+    )\n+  }\n+\n+  return (\n+    <Container>\n+      <ChatNavbar chat={chat} history={history} />\n+      <MessagesList messages={chat.messages} />\n+      <MessageInput onSendMessage={onSendMessage} />\n+    </Container>\n+  )\n+}\n+\n+export default ChatRoomScreen\ndiff --git a/client/src/components/ChatsListScreen/AddChatButton.test.tsx b/client/src/components/ChatsListScreen/AddChatButton.test.tsx\nnew file mode 100644\nindex 0000000..7c82304\n--- /dev/null\n+++ b/client/src/components/ChatsListScreen/AddChatButton.test.tsx\n@@ -0,0 +1,22 @@\n+import { createMemoryHistory } from 'history'\n+import React from 'react'\n+import { cleanup, render, fireEvent, wait } from 'react-testing-library'\n+import AddChatButton from './AddChatButton'\n+\n+describe('AddChatButton', () => {\n+  afterEach(cleanup)\n+\n+  it('goes back on arrow click', async () => {\n+    const history = createMemoryHistory()\n+\n+    {\n+      const { container, getByTestId } = render(<AddChatButton history={history} />)\n+\n+      fireEvent.click(getByTestId('new-chat-button'))\n+\n+      await wait(() =>\n+        expect(history.location.pathname).toEqual('/new-chat')\n+      )\n+    }\n+  })\n+})\ndiff --git a/client/src/components/ChatsListScreen/AddChatButton.tsx b/client/src/components/ChatsListScreen/AddChatButton.tsx\nnew file mode 100644\nindex 0000000..17bcccc\n--- /dev/null\n+++ b/client/src/components/ChatsListScreen/AddChatButton.tsx\n@@ -0,0 +1,38 @@\n+import Button from '@material-ui/core/Button'\n+import ChatIcon from '@material-ui/icons/Chat'\n+import * as React from 'react'\n+import styled from 'styled-components'\n+\n+const Container = styled.div `\n+  position: fixed;\n+  right: 10px;\n+  bottom: 10px;\n+\n+  button {\n+    min-width: 50px;\n+    width: 50px;\n+    height: 50px;\n+    border-radius: 999px;\n+    background-color: var(--secondary-bg);\n+    color: white;\n+  }\n+`\n+\n+export default ({ history }) => {\n+  const onClick = () => {\n+    history.push('/new-chat')\n+  }\n+\n+  return (\n+    <Container>\n+      <Button\n+        data-testid=\"new-chat-button\"\n+        variant=\"contained\"\n+        color=\"secondary\"\n+        onClick={onClick}\n+      >\n+        <ChatIcon />\n+      </Button>\n+    </Container>\n+  )\n+}\n\\ No newline at end of file\ndiff --git a/client/src/components/ChatsListScreen/ChatsList.test.tsx b/client/src/components/ChatsListScreen/ChatsList.test.tsx\nnew file mode 100644\nindex 0000000..a34d01a\n--- /dev/null\n+++ b/client/src/components/ChatsListScreen/ChatsList.test.tsx\n@@ -0,0 +1,110 @@\n+import { createBrowserHistory } from 'history'\n+import React from 'react'\n+import { ApolloProvider } from 'react-apollo-hooks'\n+import ReactDOM from 'react-dom'\n+import { cleanup, render, fireEvent, wait, waitForDomChange } from 'react-testing-library'\n+import { mockApolloClient } from '../../test-helpers'\n+import ChatsList, { getChatsQuery } from './ChatsList'\n+import * as queries from '../../graphql/queries'\n+\n+describe('ChatsList', () => {\n+  afterEach(() => {\n+    cleanup()\n+    window.location.pathname = '/'\n+  })\n+\n+  it('renders fetched chats data', async () => {\n+    const client = mockApolloClient([\n+      {\n+        request: { query: queries.chats },\n+        result: {\n+          data: {\n+            chats: [\n+              {\n+                __typename: 'Chat',\n+                id: 1,\n+                name: 'Foo Bar',\n+                picture: 'https://localhost:4000/picture.jpg',\n+                lastMessage: {\n+                  __typename: 'Message',\n+                  id: 1,\n+                  content: 'Hello',\n+                  createdAt: new Date(0),\n+                  isMine: true,\n+                  chat: {\n+                    __typename: 'Chat',\n+                    id: 1,\n+                  },\n+                },\n+              },\n+            ],\n+          },\n+        },\n+      },\n+    ])\n+\n+    {\n+      const { container, getByTestId } = render(\n+        <ApolloProvider client={client}>\n+          <ChatsList />\n+        </ApolloProvider>\n+      )\n+\n+      await waitForDomChange({ container })\n+\n+      expect(getByTestId('name')).toHaveTextContent('Foo Bar')\n+      expect(getByTestId('picture')).toHaveAttribute('src', 'https://localhost:4000/picture.jpg')\n+      expect(getByTestId('content')).toHaveTextContent('Hello')\n+      expect(getByTestId('date')).toHaveTextContent('08:00')\n+    }\n+  })\n+\n+  it('should navigate to the target chat room on chat item click', async () => {\n+    const client = mockApolloClient([\n+      {\n+        request: { query: queries.chats },\n+        result: {\n+          data: {\n+            chats: [\n+              {\n+                __typename: 'Chat',\n+                id: 1,\n+                name: 'Foo Bar',\n+                picture: 'https://localhost:4000/picture.jpg',\n+                lastMessage: {\n+                  __typename: 'Message',\n+                  id: 1,\n+                  content: 'Hello',\n+                  createdAt: new Date(0),\n+                  isMine: true,\n+                  chat: {\n+                    __typename: 'Chat',\n+                    id: 1,\n+                  },\n+                },\n+              },\n+            ],\n+          },\n+        },\n+      },\n+    ])\n+\n+    const history = createBrowserHistory()\n+\n+    {\n+      const { container, getByTestId } = render(\n+        <ApolloProvider client={client}>\n+          <ChatsList history={history} />\n+        </ApolloProvider>\n+      )\n+\n+      await waitForDomChange({ container })\n+\n+      fireEvent.click(getByTestId('chat'))\n+\n+      await wait(() =>\n+        expect(history.location.pathname).toEqual('/chats/1')\n+      )\n+    }\n+  })\n+})\ndiff --git a/client/src/components/ChatsListScreen/ChatsList.tsx b/client/src/components/ChatsListScreen/ChatsList.tsx\nnew file mode 100644\nindex 0000000..88ccef9\n--- /dev/null\n+++ b/client/src/components/ChatsListScreen/ChatsList.tsx\n@@ -0,0 +1,90 @@\n+import { List, ListItem } from '@material-ui/core'\n+import gql from 'graphql-tag'\n+import moment from 'moment'\n+import * as React from 'react'\n+import { useCallback } from 'react'\n+import styled from 'styled-components'\n+import { useChatsQuery } from '../../graphql/types'\n+\n+const Container = styled.div `\n+  height: calc(100% - 56px);\n+  overflow-y: overlay;\n+`\n+\n+const StyledList = styled(List) `\n+  padding: 0 !important;\n+`\n+\n+const StyledListItem = styled(ListItem) `\n+  height: 76px;\n+  padding: 0 15px;\n+  display: flex;\n+`\n+\n+const ChatPicture = styled.img `\n+  height: 50px;\n+  width: 50px;\n+  object-fit: cover;\n+  border-radius: 50%;\n+`\n+\n+const ChatInfo = styled.div `\n+  width: calc(100% - 60px);\n+  height: 46px;\n+  padding: 15px 0;\n+  margin-left: 10px;\n+  border-bottom: 0.5px solid silver;\n+  position: relative;\n+`\n+\n+const ChatName = styled.div `\n+  margin-top: 5px;\n+`\n+\n+const MessageContent = styled.div `\n+  color: gray;\n+  font-size: 15px;\n+  margin-top: 5px;\n+  text-overflow: ellipsis;\n+  overflow: hidden;\n+  white-space: nowrap;\n+`\n+\n+const MessageDate = styled.div `\n+  position: absolute;\n+  color: gray;\n+  top: 20px;\n+  right: 0;\n+  font-size: 13px;\n+`\n+\n+const ChatsList = ({ history }) => {\n+  const { data: { chats = [] } } = useChatsQuery()\n+\n+  const navToChat = useCallback((chat) => {\n+    history.push(`chats/${chat.id}`)\n+  }, [true])\n+\n+  return (\n+    <Container>\n+      <StyledList>\n+        {chats.map((chat) => (\n+          <StyledListItem key={chat.id} data-testid=\"chat\" button onClick={navToChat.bind(null, chat)}>\n+            <ChatPicture data-testid=\"picture\" src={chat.picture} />\n+            <ChatInfo>\n+              <ChatName data-testid=\"name\">{chat.name}</ChatName>\n+              {chat.lastMessage && (\n+                <React.Fragment>\n+                  <MessageContent data-testid=\"content\">{chat.lastMessage.content}</MessageContent>\n+                  <MessageDate data-testid=\"date\">{moment(chat.lastMessage.createdAt).format('HH:mm')}</MessageDate>\n+                </React.Fragment>\n+              )}\n+            </ChatInfo>\n+          </StyledListItem>\n+        ))}\n+      </StyledList>\n+    </Container>\n+  )\n+}\n+\n+export default ChatsList\ndiff --git a/client/src/components/ChatsListScreen/ChatsNavbar.tsx b/client/src/components/ChatsListScreen/ChatsNavbar.tsx\nnew file mode 100644\nindex 0000000..a575d4d\n--- /dev/null\n+++ b/client/src/components/ChatsListScreen/ChatsNavbar.tsx\n@@ -0,0 +1,41 @@\n+import { Button, Toolbar } from '@material-ui/core'\n+import SignOutIcon from '@material-ui/icons/PowerSettingsNew'\n+import * as React from 'react'\n+import { useCallback } from 'react'\n+import styled from 'styled-components'\n+import { signOut } from '../../services/auth.service'\n+\n+const Container = styled(Toolbar) `\n+  display: flex;\n+  background-color: var(--primary-bg);\n+  color: var(--primary-text);\n+  font-size: 20px;\n+  line-height: 40px;\n+`\n+\n+const Title = styled.div `\n+  flex: 1;\n+`\n+\n+const LogoutButton = styled(Button) `\n+  color: var(--primary-text) !important;\n+`\n+\n+const ChatsNavbar = ({ history }) => {\n+  const handleSignOut = useCallback(() => {\n+    signOut().then(() => {\n+      history.replace('/sign-in')\n+    })\n+  }, [true])\n+\n+  return (\n+    <Container>\n+      <Title>Whatsapp Clone</Title>\n+      <LogoutButton data-testid=\"sign-out-button\" onClick={handleSignOut}>\n+        <SignOutIcon />\n+      </LogoutButton>\n+    </Container>\n+  )\n+}\n+\n+export default ChatsNavbar\n\\ No newline at end of file\ndiff --git a/client/src/components/ChatsListScreen/index.tsx b/client/src/components/ChatsListScreen/index.tsx\nnew file mode 100644\nindex 0000000..bd3ceb6\n--- /dev/null\n+++ b/client/src/components/ChatsListScreen/index.tsx\n@@ -0,0 +1,19 @@\n+import * as React from 'react'\n+import styled from 'styled-components'\n+import AddChatButton from './AddChatButton'\n+import ChatsNavbar from './ChatsNavbar'\n+import ChatsList from './ChatsList'\n+\n+const Container = styled.div `\n+  height: 100vh;\n+`\n+\n+const ChatsListScreen = ({ history }) => (\n+  <Container>\n+    <ChatsNavbar history={history} />\n+    <ChatsList history={history} />\n+    <AddChatButton history={history} />\n+  </Container>\n+)\n+\n+export default ChatsListScreen\ndiff --git a/client/src/components/UsersList.test.tsx b/client/src/components/UsersList.test.tsx\nnew file mode 100644\nindex 0000000..01cc502\n--- /dev/null\n+++ b/client/src/components/UsersList.test.tsx\n@@ -0,0 +1,84 @@\n+import React from 'react'\n+import { ApolloProvider } from 'react-apollo-hooks'\n+import { cleanup, render, fireEvent, wait, waitForDomChange } from 'react-testing-library'\n+import { mockApolloClient } from '../test-helpers'\n+import UsersList, { UsersListQuery } from './UsersList'\n+import * as queries from '../graphql/queries'\n+\n+describe('UsersList', () => {\n+  afterEach(cleanup)\n+\n+  it('renders fetched users data', async () => {\n+    const client = mockApolloClient([\n+      {\n+        request: { query: UsersListQuery },\n+        result: {\n+          data: {\n+            users: [\n+              {\n+                __typename: 'User',\n+                id: 1,\n+                name: 'Charles Dickhead',\n+                picture: 'https://localhost:4000/dick.jpg',\n+              },\n+            ],\n+          },\n+        },\n+      },\n+    ])\n+\n+    {\n+      const { container, getByTestId } = render(\n+        <ApolloProvider client={client}>\n+          <UsersList />\n+        </ApolloProvider>\n+      )\n+\n+      await waitForDomChange({ container })\n+\n+      expect(getByTestId('name')).toHaveTextContent('Charles Dickhead')\n+      expect(getByTestId('picture')).toHaveAttribute('src', 'https://localhost:4000/dick.jpg')\n+    }\n+  })\n+\n+  it('triggers onUserPick() callback on user-item click', async () => {\n+    const client = mockApolloClient([\n+      {\n+        request: { query: UsersListQuery },\n+        result: {\n+          data: {\n+            users: [\n+              {\n+                __typename: 'User',\n+                id: 1,\n+                name: 'Charles Dickhead',\n+                picture: 'https://localhost:4000/dick.jpg',\n+              },\n+            ],\n+          },\n+        },\n+      },\n+    ])\n+\n+    const onUserPick = jest.fn(() => {})\n+\n+    {\n+      const { container, getByTestId } = render(\n+        <ApolloProvider client={client}>\n+          <UsersList onUserPick={onUserPick} />\n+        </ApolloProvider>\n+      )\n+\n+      await waitForDomChange({ container })\n+\n+      fireEvent.click(getByTestId('user'))\n+\n+      await wait(() =>\n+        expect(onUserPick.mock.calls.length).toBe(1)\n+      )\n+\n+      expect(onUserPick.mock.calls[0][0].name).toEqual('Charles Dickhead')\n+      expect(onUserPick.mock.calls[0][0].picture).toEqual('https://localhost:4000/dick.jpg')\n+    }\n+  })\n+})\ndiff --git a/client/src/components/UsersList.tsx b/client/src/components/UsersList.tsx\nnew file mode 100644\nindex 0000000..0f7e612\n--- /dev/null\n+++ b/client/src/components/UsersList.tsx\n@@ -0,0 +1,63 @@\n+import MaterialList from '@material-ui/core/List'\n+import MaterialItem from '@material-ui/core/ListItem'\n+import CheckCircle from '@material-ui/icons/CheckCircle'\n+import gql from 'graphql-tag'\n+import * as React from 'react'\n+import { useCallback, useState } from 'react'\n+import styled from 'styled-components'\n+import * as fragments from '../graphql/fragments'\n+import { useUsersListQuery, User } from '../graphql/types'\n+\n+const ActualList = styled(MaterialList) `\n+  padding: 0;\n+`\n+\n+const UserItem = styled(MaterialItem) `\n+  position: relative;\n+  padding: 7.5px 15px;\n+  display: flex;\n+  cursor: pinter;\n+`\n+\n+const ProfilePicture = styled.img `\n+  height: 50px;\n+  width: 50px;\n+  object-fit: cover;\n+  border-radius: 50%;\n+`\n+\n+const Name = styled.div `\n+  padding-left: 15px;\n+  font-weight: bold;\n+`\n+\n+export const UsersListQuery = gql`\n+  query UsersList {\n+    users {\n+      ...User\n+    }\n+  }\n+  ${fragments.user}\n+`\n+\n+const UsersList = ({ onUserPick = (user: User) => {} }) => {\n+  const { data: { users }, loading: loadingUsers } = useUsersListQuery()\n+\n+  return (\n+    <ActualList>\n+      {!loadingUsers && users.map(user => (\n+        <UserItem\n+          key={user.id}\n+          data-testid=\"user\"\n+          onClick={onUserPick.bind(null, user)}\n+          button\n+        >\n+          <ProfilePicture data-testid=\"picture\" src={user.picture} />\n+          <Name data-testid=\"name\">{user.name}</Name>\n+        </UserItem>\n+      ))}\n+    </ActualList>\n+  )\n+}\n+\n+export default UsersList\ndiff --git a/client/src/graphql/fragments/chat.fragment.ts b/client/src/graphql/fragments/chat.fragment.ts\nnew file mode 100644\nindex 0000000..9a92f3b\n--- /dev/null\n+++ b/client/src/graphql/fragments/chat.fragment.ts\n@@ -0,0 +1,14 @@\n+import gql from 'graphql-tag'\n+import message from './message.fragment'\n+\n+export default gql `\n+  fragment Chat on Chat {\n+    id\n+    name\n+    picture\n+    lastMessage {\n+      ...Message\n+    }\n+  }\n+  ${message}\n+`\ndiff --git a/client/src/graphql/fragments/fullChat.fragment.ts b/client/src/graphql/fragments/fullChat.fragment.ts\nnew file mode 100644\nindex 0000000..631a41d\n--- /dev/null\n+++ b/client/src/graphql/fragments/fullChat.fragment.ts\n@@ -0,0 +1,14 @@\n+import gql from 'graphql-tag'\n+import chat from './chat.fragment'\n+import message from './message.fragment'\n+\n+export default gql `\n+  fragment FullChat on Chat {\n+    ...Chat\n+    messages {\n+      ...Message\n+    }\n+  }\n+  ${chat}\n+  ${message}\n+`\ndiff --git a/client/src/graphql/fragments/index.ts b/client/src/graphql/fragments/index.ts\nnew file mode 100644\nindex 0000000..7b6c3c0\n--- /dev/null\n+++ b/client/src/graphql/fragments/index.ts\n@@ -0,0 +1,4 @@\n+export { default as chat } from './chat.fragment'\n+export { default as fullChat } from './fullChat.fragment'\n+export { default as message } from './message.fragment'\n+export { default as user } from './user.fragment'\ndiff --git a/client/src/graphql/fragments/message.fragment.ts b/client/src/graphql/fragments/message.fragment.ts\nnew file mode 100644\nindex 0000000..268591d\n--- /dev/null\n+++ b/client/src/graphql/fragments/message.fragment.ts\n@@ -0,0 +1,13 @@\n+import gql from 'graphql-tag'\n+\n+export default gql`\n+  fragment Message on Message {\n+    id\n+    createdAt\n+    content\n+    isMine\n+    chat {\n+      id\n+    }\n+  }\n+`\ndiff --git a/client/src/graphql/fragments/user.fragment.ts b/client/src/graphql/fragments/user.fragment.ts\nnew file mode 100644\nindex 0000000..c87010b\n--- /dev/null\n+++ b/client/src/graphql/fragments/user.fragment.ts\n@@ -0,0 +1,9 @@\n+import gql from 'graphql-tag'\n+\n+export default gql`\n+  fragment User on User {\n+    id\n+    name\n+    picture\n+  }\n+`\ndiff --git a/client/src/graphql/queries/chats.query.ts b/client/src/graphql/queries/chats.query.ts\nnew file mode 100644\nindex 0000000..40016ed\n--- /dev/null\n+++ b/client/src/graphql/queries/chats.query.ts\n@@ -0,0 +1,11 @@\n+import gql from 'graphql-tag'\n+import * as fragments from '../fragments'\n+\n+export default gql `\n+  query Chats {\n+    chats {\n+      ...Chat\n+    }\n+  }\n+  ${fragments.chat}\n+`\ndiff --git a/client/src/graphql/queries/index.ts b/client/src/graphql/queries/index.ts\nnew file mode 100644\nindex 0000000..2084224\n--- /dev/null\n+++ b/client/src/graphql/queries/index.ts\n@@ -0,0 +1 @@\n+export { default as chats } from './chats.query'\ndiff --git a/client/src/graphql/queries/me.query.ts b/client/src/graphql/queries/me.query.ts\nnew file mode 100644\nindex 0000000..d48ee66\n--- /dev/null\n+++ b/client/src/graphql/queries/me.query.ts\n@@ -0,0 +1,11 @@\n+import gql from 'graphql-tag'\n+import * as fragments from '../fragments'\n+\n+export default gql `\n+  query Me {\n+    me {\n+      ...User\n+    }\n+  }\n+  ${fragments.user}\n+`\ndiff --git a/client/src/graphql/subscriptions/chatAdded.subscription.ts b/client/src/graphql/subscriptions/chatAdded.subscription.ts\nnew file mode 100644\nindex 0000000..747116c\n--- /dev/null\n+++ b/client/src/graphql/subscriptions/chatAdded.subscription.ts\n@@ -0,0 +1,11 @@\n+import gql from 'graphql-tag'\n+import * as fragments from '../fragments'\n+\n+export default gql `\n+  subscription ChatAdded {\n+    chatAdded {\n+      ...Chat\n+    }\n+  }\n+  ${fragments.chat}\n+`\ndiff --git a/client/src/graphql/subscriptions/chatRemoved.subscription.ts b/client/src/graphql/subscriptions/chatRemoved.subscription.ts\nnew file mode 100644\nindex 0000000..7bc3477\n--- /dev/null\n+++ b/client/src/graphql/subscriptions/chatRemoved.subscription.ts\n@@ -0,0 +1,7 @@\n+import gql from 'graphql-tag'\n+\n+export default gql `\n+  subscription ChatRemoved {\n+    chatRemoved\n+  }\n+`\ndiff --git a/client/src/graphql/subscriptions/index.ts b/client/src/graphql/subscriptions/index.ts\nnew file mode 100644\nindex 0000000..77e7b4e\n--- /dev/null\n+++ b/client/src/graphql/subscriptions/index.ts\n@@ -0,0 +1,3 @@\n+export { default as messageAdded } from './messageAdded.subscription'\n+export { default as chatAdded } from './chatAdded.subscription'\n+export { default as chatRemoved } from './chatRemoved.subscription'\ndiff --git a/client/src/graphql/subscriptions/messageAdded.subscription.ts b/client/src/graphql/subscriptions/messageAdded.subscription.ts\nnew file mode 100644\nindex 0000000..b16392b\n--- /dev/null\n+++ b/client/src/graphql/subscriptions/messageAdded.subscription.ts\n@@ -0,0 +1,11 @@\n+import gql from 'graphql-tag'\n+import * as fragments from '../fragments'\n+\n+export default gql `\n+  subscription MessageAdded {\n+    messageAdded {\n+      ...Message\n+    }\n+  }\n+  ${fragments.message}\n+`\ndiff --git a/client/src/index.css b/client/src/index.css\nnew file mode 100644\nindex 0000000..ea591eb\n--- /dev/null\n+++ b/client/src/index.css\n@@ -0,0 +1,21 @@\n+:root {\n+  --primary-bg: #2c6157;\n+  --secondary-bg: #6fd056;\n+  --primary-text: white;\n+  --secondary-text: white;\n+}\n+\n+body {\n+  margin: 0;\n+  padding: 0;\n+  font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", \"Roboto\", \"Oxygen\",\n+    \"Ubuntu\", \"Cantarell\", \"Fira Sans\", \"Droid Sans\", \"Helvetica Neue\",\n+    sans-serif;\n+  -webkit-font-smoothing: antialiased;\n+  -moz-osx-font-smoothing: grayscale;\n+}\n+\n+code {\n+  font-family: source-code-pro, Menlo, Monaco, Consolas, \"Courier New\",\n+    monospace;\n+}\ndiff --git a/client/src/index.jsx b/client/src/index.jsx\nnew file mode 100644\nindex 0000000..311a72a\n--- /dev/null\n+++ b/client/src/index.jsx\n@@ -0,0 +1,31 @@\n+import { MuiThemeProvider, createMuiTheme } from '@material-ui/core/styles'\n+import React from 'react';\n+import ReactDOM from 'react-dom';\n+import { ApolloProvider } from 'react-apollo-hooks'\n+import './index.css';\n+import App from './App';\n+import client from './client'\n+import * as serviceWorker from './serviceWorker';\n+\n+const theme = createMuiTheme({\n+  palette: {\n+    primary: { main: '#2c6157' },\n+    secondary: { main: '#6fd056' },\n+  },\n+  typography: {\n+    useNextVariants: true,\n+  },\n+})\n+\n+ReactDOM.render(\n+  <MuiThemeProvider theme={theme}>\n+    <ApolloProvider client={client}>\n+      <App />\n+    </ApolloProvider>\n+  </MuiThemeProvider>\n+, document.getElementById('root'));\n+\n+// If you want your app to work offline and load faster, you can change\n+// unregister() to register() below. Note this comes with some pitfalls.\n+// Learn more about service workers: https://bit.ly/CRA-PWA\n+serviceWorker.unregister();\ndiff --git a/client/src/react-app-env.d.ts b/client/src/react-app-env.d.ts\nnew file mode 100644\nindex 0000000..6431bc5\n--- /dev/null\n+++ b/client/src/react-app-env.d.ts\n@@ -0,0 +1 @@\n+/// <reference types=\"react-scripts\" />\ndiff --git a/client/src/serviceWorker.js b/client/src/serviceWorker.js\nnew file mode 100644\nindex 0000000..f8c7e50\n--- /dev/null\n+++ b/client/src/serviceWorker.js\n@@ -0,0 +1,135 @@\n+// This optional code is used to register a service worker.\n+// register() is not called by default.\n+\n+// This lets the app load faster on subsequent visits in production, and gives\n+// it offline capabilities. However, it also means that developers (and users)\n+// will only see deployed updates on subsequent visits to a page, after all the\n+// existing tabs open on the page have been closed, since previously cached\n+// resources are updated in the background.\n+\n+// To learn more about the benefits of this model and instructions on how to\n+// opt-in, read https://bit.ly/CRA-PWA\n+\n+const isLocalhost = Boolean(\n+  window.location.hostname === 'localhost' ||\n+    // [::1] is the IPv6 localhost address.\n+    window.location.hostname === '[::1]' ||\n+    // 127.0.0.1/8 is considered localhost for IPv4.\n+    window.location.hostname.match(\n+      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n+    )\n+);\n+\n+export function register(config) {\n+  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n+    // The URL constructor is available in all browsers that support SW.\n+    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n+    if (publicUrl.origin !== window.location.origin) {\n+      // Our service worker won't work if PUBLIC_URL is on a different origin\n+      // from what our page is served on. This might happen if a CDN is used to\n+      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n+      return;\n+    }\n+\n+    window.addEventListener('load', () => {\n+      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n+\n+      if (isLocalhost) {\n+        // This is running on localhost. Let's check if a service worker still exists or not.\n+        checkValidServiceWorker(swUrl, config);\n+\n+        // Add some additional logging to localhost, pointing developers to the\n+        // service worker/PWA documentation.\n+        navigator.serviceWorker.ready.then(() => {\n+          console.log(\n+            'This web app is being served cache-first by a service ' +\n+              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n+          );\n+        });\n+      } else {\n+        // Is not localhost. Just register service worker\n+        registerValidSW(swUrl, config);\n+      }\n+    });\n+  }\n+}\n+\n+function registerValidSW(swUrl, config) {\n+  navigator.serviceWorker\n+    .register(swUrl)\n+    .then(registration => {\n+      registration.onupdatefound = () => {\n+        const installingWorker = registration.installing;\n+        if (installingWorker == null) {\n+          return;\n+        }\n+        installingWorker.onstatechange = () => {\n+          if (installingWorker.state === 'installed') {\n+            if (navigator.serviceWorker.controller) {\n+              // At this point, the updated precached content has been fetched,\n+              // but the previous service worker will still serve the older\n+              // content until all client tabs are closed.\n+              console.log(\n+                'New content is available and will be used when all ' +\n+                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n+              );\n+\n+              // Execute callback\n+              if (config && config.onUpdate) {\n+                config.onUpdate(registration);\n+              }\n+            } else {\n+              // At this point, everything has been precached.\n+              // It's the perfect time to display a\n+              // \"Content is cached for offline use.\" message.\n+              console.log('Content is cached for offline use.');\n+\n+              // Execute callback\n+              if (config && config.onSuccess) {\n+                config.onSuccess(registration);\n+              }\n+            }\n+          }\n+        };\n+      };\n+    })\n+    .catch(error => {\n+      console.error('Error during service worker registration:', error);\n+    });\n+}\n+\n+function checkValidServiceWorker(swUrl, config) {\n+  // Check if the service worker can be found. If it can't reload the page.\n+  fetch(swUrl)\n+    .then(response => {\n+      // Ensure service worker exists, and that we really are getting a JS file.\n+      const contentType = response.headers.get('content-type');\n+      if (\n+        response.status === 404 ||\n+        (contentType != null && contentType.indexOf('javascript') === -1)\n+      ) {\n+        // No service worker found. Probably a different app. Reload the page.\n+        navigator.serviceWorker.ready.then(registration => {\n+          registration.unregister().then(() => {\n+            window.location.reload();\n+          });\n+        });\n+      } else {\n+        // Service worker found. Proceed as normal.\n+        registerValidSW(swUrl, config);\n+      }\n+    })\n+    .catch(() => {\n+      console.log(\n+        'No internet connection found. App is running in offline mode.'\n+      );\n+    });\n+}\n+\n+export function unregister() {\n+  if ('serviceWorker' in navigator) {\n+    navigator.serviceWorker.ready.then(registration => {\n+      registration.unregister();\n+    });\n+  }\n+}\ndiff --git a/client/src/services/auth.service.tsx b/client/src/services/auth.service.tsx\nnew file mode 100644\nindex 0000000..b03f473\n--- /dev/null\n+++ b/client/src/services/auth.service.tsx\n@@ -0,0 +1,87 @@\n+import { parse as parseCookie } from 'cookie'\n+import * as React from 'react'\n+import { useContext } from 'react'\n+import { Redirect } from 'react-router-dom'\n+import client from '../client'\n+import { useMeQuery, User } from '../graphql/types'\n+import { useCacheService } from './cache.service'\n+\n+const MyContext = React.createContext<User>(null)\n+\n+export const useMe = () => {\n+  return useContext(MyContext)\n+}\n+\n+export const withAuth = (Component: React.ComponentType) => {\n+  return (props) => {\n+    if (!isSignedIn()) {\n+      if (props.history.location.pathname === '/sign-in') {\n+        return null\n+      }\n+\n+      return (\n+        <Redirect to=\"/sign-in\" />\n+      )\n+    }\n+\n+    const { data, error, loading } = useMeQuery()\n+\n+    useCacheService()\n+\n+    if (loading) return null\n+\n+    if (error || !data.me) {\n+      signOut()\n+\n+      return <Redirect to=\"/sign-in\" />\n+    }\n+\n+    return (\n+      <MyContext.Provider value={data.me}>\n+        <Component {...props} />\n+      </MyContext.Provider>\n+    )\n+  }\n+}\n+\n+export const signIn = ({ username, password }) => {\n+  return fetch(`${process.env.REACT_APP_SERVER_URL}/sign-in`, {\n+    method: 'POST',\n+    body: JSON.stringify({ username, password }),\n+    credentials: 'include',\n+    headers: {\n+      'Accept': 'application/json',\n+      'Content-Type': 'application/json',\n+    },\n+  }).then(res => {\n+    if (res.status >= 400) {\n+      return res.text().then(e => Promise.reject(e))\n+    }\n+  })\n+}\n+\n+export const signUp = ({ name, username, password, passwordConfirm }) => {\n+  return fetch(`${process.env.REACT_APP_SERVER_URL}/sign-up`, {\n+    method: 'POST',\n+    body: JSON.stringify({ name, username, password, passwordConfirm }),\n+    credentials: 'include',\n+    headers: {\n+      'Accept': 'application/json',\n+      'Content-Type': 'application/json',\n+    },\n+  }).then(res => {\n+    if (res.status >= 400) {\n+      return res.text().then(e => Promise.reject(e))\n+    }\n+  })\n+}\n+\n+export const signOut = () => {\n+  document.cookie = `authToken=;expires=${new Date(0)}`\n+\n+  return client.clearStore()\n+}\n+\n+export const isSignedIn = () => {\n+  return /authToken=.+(;|$)/.test(document.cookie)\n+}\n\\ No newline at end of file\ndiff --git a/client/src/services/cache.service.ts b/client/src/services/cache.service.ts\nnew file mode 100644\nindex 0000000..2258936\n--- /dev/null\n+++ b/client/src/services/cache.service.ts\n@@ -0,0 +1,171 @@\n+import { DataProxy } from 'apollo-cache'\n+import { defaultDataIdFromObject } from 'apollo-cache-inmemory'\n+import { ApolloClient } from 'apollo-client'\n+import * as fragments from '../graphql/fragments'\n+import * as queries from '../graphql/queries'\n+import {\n+  MessageFragment,\n+  ChatFragment,\n+  useMessageAddedSubscription,\n+  useChatAddedSubscription,\n+  useChatRemovedSubscription,\n+} from '../graphql/types'\n+\n+type Client = ApolloClient<any> | DataProxy\n+\n+export const useCacheService = () => {\n+  useMessageAddedSubscription({\n+    onSubscriptionData: ({ client, subscriptionData: { data: { messageAdded } } }) => {\n+      writeMessage(client, messageAdded)\n+    }\n+  })\n+\n+  useChatAddedSubscription({\n+    onSubscriptionData: ({ client, subscriptionData: { data: { chatAdded } } }) => {\n+      writeChat(client, chatAdded)\n+    }\n+  })\n+\n+  useChatRemovedSubscription({\n+    onSubscriptionData: ({ client, subscriptionData: { data: { chatRemoved } } }) => {\n+      eraseChat(client, chatRemoved)\n+    }\n+  })\n+}\n+\n+export const writeMessage = (client: Client, message: MessageFragment) => {\n+  let fullChat\n+  try {\n+    fullChat = client.readFragment({\n+      id: defaultDataIdFromObject(message.chat),\n+      fragment: fragments.fullChat,\n+      fragmentName: 'FullChat',\n+    })\n+  } catch (e) {\n+    return\n+  }\n+\n+  if (fullChat.messages.some(m => m.id === message.id)) return\n+\n+  fullChat.messages.push(message)\n+  fullChat.lastMessage = message\n+\n+  client.writeFragment({\n+    id: defaultDataIdFromObject(message.chat),\n+    fragment: fragments.fullChat,\n+    fragmentName: 'FullChat',\n+    data: fullChat,\n+  })\n+\n+  rewriteChats:\n+  {\n+    let data\n+    try {\n+      data = client.readQuery({\n+        query: queries.chats,\n+      })\n+    } catch (e) {\n+      break rewriteChats\n+    }\n+\n+    if (!data) break rewriteChats\n+\n+    const chats = data.chats\n+\n+    if (!chats) break rewriteChats\n+\n+    const chatIndex = chats.findIndex(c => c.id === message.chat.id)\n+\n+    if (chatIndex === -1) break rewriteChats\n+\n+    const chat = chats[chatIndex]\n+\n+    // The chat will appear at the top of the ChatsList component\n+    chats.splice(chatIndex, 1)\n+    chats.unshift(chat)\n+\n+    client.writeQuery({\n+      query: queries.chats,\n+      data: { chats: chats },\n+    })\n+  }\n+}\n+\n+export const writeChat = (client: Client, chat: ChatFragment) => {\n+  client.writeFragment({\n+    id: defaultDataIdFromObject(chat),\n+    fragment: fragments.chat,\n+    fragmentName: 'Chat',\n+    data: chat,\n+  })\n+\n+  rewriteChats:\n+  {\n+    let data\n+    try {\n+      data = client.readQuery({\n+        query: queries.chats,\n+      })\n+    } catch (e) {\n+      break rewriteChats\n+    }\n+\n+    if (!data) break rewriteChats\n+\n+    const chats = data.chats\n+\n+    if (!chats) break rewriteChats\n+    if (chats.some(c => c.id === chat.id)) break rewriteChats\n+\n+    chats.unshift(chat)\n+\n+    client.writeQuery({\n+      query: queries.chats,\n+      data: { chats },\n+    })\n+  }\n+}\n+\n+export const eraseChat = (client: Client, chatId: string) => {\n+  const chatType = {\n+    __typename: 'Chat',\n+    id: chatId\n+  }\n+\n+  client.writeFragment({\n+    id: defaultDataIdFromObject(chatType),\n+    fragment: fragments.fullChat,\n+    fragmentName: 'FullChat',\n+    data: null,\n+  })\n+\n+  rewriteChats:\n+  {\n+    let data\n+    try {\n+      data = client.readQuery({\n+        query: queries.chats,\n+      })\n+    } catch (e) {\n+      break rewriteChats\n+    }\n+\n+    if (!data) break rewriteChats\n+\n+    const chats = data.chats\n+\n+    if (!chats) break rewriteChats\n+\n+    const chatIndex = chats.findIndex(c => c.id === chatId)\n+\n+    if (chatIndex === -1) break rewriteChats\n+\n+    // The chat will appear at the top of the ChatsList component\n+    chats.splice(chatIndex, 1)\n+\n+    client.writeQuery({\n+      query: queries.chats,\n+      data: { chats: chats },\n+    })\n+  }\n+}\ndiff --git a/client/src/setupTests.ts b/client/src/setupTests.ts\nnew file mode 100644\nindex 0000000..c42be90\n--- /dev/null\n+++ b/client/src/setupTests.ts\n@@ -0,0 +1,7 @@\n+import 'jest-dom/extend-expect'\n+import { GlobalWithFetchMock } from 'jest-fetch-mock'\n+import { act } from 'react-testing-library'\n+\n+const customGlobal: GlobalWithFetchMock = global as GlobalWithFetchMock\n+customGlobal.fetch = require('jest-fetch-mock')\n+customGlobal.fetchMock = customGlobal.fetch\ndiff --git a/client/src/test-helpers.ts b/client/src/test-helpers.ts\nnew file mode 100644\nindex 0000000..55c02bb\n--- /dev/null\n+++ b/client/src/test-helpers.ts\n@@ -0,0 +1,10 @@\n+import { InMemoryCache } from 'apollo-cache-inmemory'\n+import { ApolloClient } from 'apollo-client'\n+import { MockLink } from 'apollo-link-mock'\n+\n+export const mockApolloClient = (mocks) => {\n+  return new ApolloClient({\n+    cache: new InMemoryCache(),\n+    link: new MockLink(mocks),\n+  })\n+}\ndiff --git a/client/tsconfig.json b/client/tsconfig.json\nnew file mode 100644\nindex 0000000..ad80f6a\n--- /dev/null\n+++ b/client/tsconfig.json\n@@ -0,0 +1,35 @@\n+{\n+  \"compilerOptions\": {\n+    \"outDir\": \"build/dist\",\n+    \"sourceMap\": true,\n+    \"declaration\": false,\n+    \"moduleResolution\": \"node\",\n+    \"emitDecoratorMetadata\": true,\n+    \"experimentalDecorators\": true,\n+    \"downlevelIteration\": true,\n+    \"resolveJsonModule\": true,\n+    \"target\": \"es5\",\n+    \"jsx\": \"preserve\",\n+    \"typeRoots\": [\n+      \"node_modules/@types\"\n+    ],\n+    \"lib\": [\n+      \"es2017\",\n+      \"dom\",\n+      \"esnext.asynciterable\"\n+    ],\n+    \"allowJs\": true,\n+    \"skipLibCheck\": true,\n+    \"esModuleInterop\": false,\n+    \"allowSyntheticDefaultImports\": true,\n+    \"forceConsistentCasingInFileNames\": true,\n+    \"isolatedModules\": true,\n+    \"noEmit\": true,\n+    \"noImplicitAny\": false,\n+    \"strict\": false,\n+    \"module\": \"esnext\"\n+  },\n+  \"include\": [\n+    \"src\"\n+  ]\n+}\ndiff --git a/client/tslint.json b/client/tslint.json\nnew file mode 100644\nindex 0000000..446ec3d\n--- /dev/null\n+++ b/client/tslint.json\n@@ -0,0 +1,29 @@\n+{\n+  \"extends\": [\"tslint:recommended\", \"tslint-react\", \"tslint-config-prettier\"],\n+  \"rules\": {\n+    \"ordered-imports\": false,\n+    \"object-literal-sort-keys\": false,\n+    \"jsx-boolean-value\": false,\n+    \"interface-name\" : false,\n+    \"variable-name\": false,\n+    \"no-string-literal\": false,\n+    \"no-namespace\": false,\n+    \"interface-over-type-literal\": false,\n+    \"no-shadowed-variable\": false,\n+    \"curly\": false,\n+    \"no-label\": false,\n+    \"no-empty\": false,\n+    \"no-debugger\": false,\n+    \"no-console\": false,\n+    \"array-type\": false\n+  },\n+  \"linterOptions\": {\n+    \"exclude\": [\n+      \"config/**/*.js\",\n+      \"node_modules/**/*.ts\",\n+      \"coverage/lcov-report/*.js\",\n+      \"*.json\",\n+      \"**/*.json\"\n+    ]\n+  }\n+}\ndiff --git a/package.json b/package.json\nnew file mode 100644\nindex 0000000..008b058\n--- /dev/null\n+++ b/package.json\n@@ -0,0 +1,9 @@\n+{\n+  \"name\": \"whatsapp-clone-tutorial\",\n+  \"description\": \"A newly created Tortilla project\",\n+  \"private\": true,\n+  \"repository\": {\n+    \"type\": \"git\",\n+    \"url\": \"https://github.com/Urigo/WhatsApp-Clone-Tutorial.git\"\n+  }\n+}\ndiff --git a/server/.gitignore b/server/.gitignore\nnew file mode 100644\nindex 0000000..7c40371\n--- /dev/null\n+++ b/server/.gitignore\n@@ -0,0 +1,3 @@\n+node_modules\n+npm-debug.log\n+types/graphql.d.ts\n\\ No newline at end of file\ndiff --git a/server/app.ts b/server/app.ts\nnew file mode 100644\nindex 0000000..b2d9fca\n--- /dev/null\n+++ b/server/app.ts\n@@ -0,0 +1,74 @@\n+import bodyParser from 'body-parser'\n+import cors from 'cors'\n+import cookieParser from 'cookie-parser'\n+import express from 'express'\n+import bcrypt from 'bcrypt'\n+import jwt from 'jsonwebtoken'\n+import { User, users } from './db'\n+import { expiration, origin, secret } from './env'\n+import { validateLength, validatePassword } from './validators'\n+\n+export const app = express()\n+\n+app.use(cors({ credentials: true, origin }))\n+app.use(bodyParser.json())\n+app.use(cookieParser())\n+\n+app.get('/_ping', (req, res) => {\n+  res.send('pong')\n+})\n+\n+app.post('/sign-up', (req, res) => {\n+  const { name, username, password, passwordConfirm } = req.body\n+\n+  try {\n+    validateLength('req.name', name, 3, 50)\n+    validateLength('req.username', name, 3, 18)\n+    validatePassword('req.password', password)\n+\n+    if (password !== passwordConfirm) {\n+      throw Error(\"req.password and req.passwordConfirm don't match\")\n+    }\n+\n+    if (users.some(u => u.username === username)) {\n+      throw Error(\"username already exists\")\n+    }\n+  } catch (e) {\n+    return res.status(400).send(e.message)\n+  }\n+\n+  const passwordHash = bcrypt.hashSync(password, bcrypt.genSaltSync(8))\n+\n+  const user: User = {\n+    id: String(users.length + 1),\n+    password: passwordHash,\n+    picture: '',\n+    username,\n+    name,\n+  }\n+\n+  users.push(user)\n+\n+  res.status(200).send({ id: user.id })\n+})\n+\n+app.post('/sign-in', (req, res) => {\n+  const { username, password } = req.body\n+\n+  const user = users.find(u => u.username === username)\n+\n+  if (!user) {\n+    return res.status(404).send('user not found')\n+  }\n+\n+  const passwordsMatch = bcrypt.compareSync(password, user.password)\n+\n+  if (!passwordsMatch) {\n+    return res.status(400).send('password is incorrect')\n+  }\n+\n+  const authToken = jwt.sign(username, secret)\n+\n+  res.cookie('authToken', authToken, { maxAge: expiration })\n+  res.status(200).send({ id: user.id })\n+})\ndiff --git a/server/codegen.yml b/server/codegen.yml\nnew file mode 100644\nindex 0000000..ab9b748\n--- /dev/null\n+++ b/server/codegen.yml\n@@ -0,0 +1,18 @@\n+schema: ./schema/typeDefs.graphql\n+overwrite: true\n+generates:\n+  ./types/graphql.d.ts:\n+    plugins:\n+      - typescript\n+      - typescript-resolvers\n+    config:\n+      contextType: ../context#MyContext\n+      mappers:\n+        # import { Message } from '../db'\n+        # The root types of Message resolvers\n+        User: ../db#User\n+        Message: ../db#Message\n+        Chat: ../db#Chat\n+      scalars:\n+        # e.g. Message.createdAt will be of type Date\n+        Date: Date\ndiff --git a/server/context.ts b/server/context.ts\nnew file mode 100644\nindex 0000000..d8a47c1\n--- /dev/null\n+++ b/server/context.ts\n@@ -0,0 +1,7 @@\n+import { PubSub } from 'apollo-server-express'\n+import { User } from './db'\n+\n+export type MyContext = {\n+  pubsub: PubSub,\n+  currentUser: User,\n+}\ndiff --git a/server/db.ts b/server/db.ts\nnew file mode 100644\nindex 0000000..1f72785\n--- /dev/null\n+++ b/server/db.ts\n@@ -0,0 +1,121 @@\n+export type User = {\n+  id: string\n+  name: string\n+  username: string\n+  password: string\n+  picture: string\n+}\n+\n+export type Message = {\n+  id: string\n+  content: string\n+  createdAt: Date\n+  sender: string\n+  recipient: string\n+}\n+\n+export type Chat = {\n+  id: string\n+  messages: string[]\n+  participants: string[]\n+}\n+\n+export const users: User[] = []\n+export const messages: Message[] = []\n+export const chats: Chat[] = []\n+\n+export const resetDb = () => {\n+  users.splice(0, Infinity, ...[\n+    {\n+      id: '1',\n+      name: 'Ray Edwards',\n+      username: 'ray',\n+      password: '$2a$08$NO9tkFLCoSqX1c5wk3s7z.JfxaVMKA.m7zUDdDwEquo4rvzimQeJm', // 111\n+      picture: 'https://randomuser.me/api/portraits/thumb/lego/1.jpg',\n+    },\n+    {\n+      id: '2',\n+      name: 'Ethan Gonzalez',\n+      username: 'ethan',\n+      password: '$2a$08$xE4FuCi/ifxjL2S8CzKAmuKLwv18ktksSN.F3XYEnpmcKtpbpeZgO', // 222\n+      picture: 'https://randomuser.me/api/portraits/thumb/men/1.jpg',\n+    },\n+    {\n+      id: '3',\n+      name: 'Bryan Wallace',\n+      username: 'bryan',\n+      password: '$2a$08$UHgH7J8G6z1mGQn2qx2kdeWv0jvgHItyAsL9hpEUI3KJmhVW5Q1d.', // 333\n+      picture: 'https://randomuser.me/api/portraits/thumb/men/2.jpg',\n+    },\n+    {\n+      id: '4',\n+      name: 'Avery Stewart',\n+      username: 'avery',\n+      password: '$2a$08$wR1k5Q3T9FC7fUgB7Gdb9Os/GV7dGBBf4PLlWT7HERMFhmFDt47xi', // 444\n+      picture: 'https://randomuser.me/api/portraits/thumb/women/1.jpg',\n+    },\n+    {\n+      id: '5',\n+      name: 'Katie Peterson',\n+      username: 'katie',\n+      password: '$2a$08$6.mbXqsDX82ZZ7q5d8Osb..JrGSsNp4R3IKj7mxgF6YGT0OmMw242', // 555\n+      picture: 'https://randomuser.me/api/portraits/thumb/women/2.jpg',\n+    },\n+  ])\n+\n+  messages.splice(0, Infinity, ...[\n+    {\n+      id: '1',\n+      content: \"You on your way?\",\n+      createdAt: new Date(new Date('1-1-2019').getTime() - 60 * 1000 * 1000),\n+      sender: '1',\n+      recipient: '2',\n+    },\n+    {\n+      id: '2',\n+      content: \"Hey, it's me\",\n+      createdAt: new Date(new Date('1-1-2019').getTime() - 2 * 60 * 1000 * 1000),\n+      sender: '1',\n+      recipient: '3',\n+    },\n+    {\n+      id: '3',\n+      content: \"I should buy a boat\",\n+      createdAt: new Date(new Date('1-1-2019').getTime() - 24 * 60 * 1000 * 1000),\n+      sender: '1',\n+      recipient: '4',\n+    },\n+    {\n+      id: '4',\n+      content: \"This is wicked good ice cream.\",\n+      createdAt: new Date(new Date('1-1-2019').getTime() - 14 * 24 * 60 * 1000 * 1000),\n+      sender: '1',\n+      recipient: '5',\n+    },\n+  ])\n+\n+  chats.splice(0, Infinity, ...[\n+    {\n+      id: '1',\n+      participants: ['1', '2'],\n+      messages: ['1'],\n+    },\n+    {\n+      id: '2',\n+      participants: ['1', '3'],\n+      messages: ['2'],\n+    },\n+    {\n+      id: '3',\n+      participants: ['1', '4'],\n+      messages: ['3'],\n+    },\n+    {\n+      id: '4',\n+      participants: ['1', '5'],\n+      messages: ['4'],\n+    },\n+  ])\n+}\n+\n+resetDb()\n\\ No newline at end of file\ndiff --git a/server/env.ts b/server/env.ts\nnew file mode 100644\nindex 0000000..8f844a1\n--- /dev/null\n+++ b/server/env.ts\n@@ -0,0 +1,6 @@\n+export const expiration = process.env.JWT_EXPIRATION_MS\n+  ?  parseInt(process.env.JWT_EXPIRATION_MS)\n+  : 24 * 60 * 60 * 1000\n+export const secret = process.env.JWT_SECRET || '70p53cr37'\n+export const origin = process.env.ORIGIN || 'http://localhost:3000'\n+export const port = process.env.PORT || 4000\ndiff --git a/server/index.ts b/server/index.ts\nnew file mode 100644\nindex 0000000..652aa49\n--- /dev/null\n+++ b/server/index.ts\n@@ -0,0 +1,34 @@\n+import { ApolloServer, gql, PubSub } from 'apollo-server-express'\n+import http from 'http'\n+import jwt from 'jsonwebtoken'\n+import { app } from './app'\n+import { users } from './db'\n+import { origin, port, secret } from './env'\n+import schema from './schema'\n+\n+const pubsub = new PubSub()\n+const server = new ApolloServer({\n+  schema,\n+  context: ({ req }) => {\n+    const username = jwt.verify(req.cookies.authToken, secret) as string\n+    const currentUser = username && users.find(u => u.username === username)\n+\n+    return {\n+      currentUser,\n+      pubsub,\n+    }\n+  },\n+})\n+\n+server.applyMiddleware({\n+  app,\n+  path: '/graphql',\n+  cors: { credentials: true, origin },\n+})\n+\n+const httpServer = http.createServer(app)\n+server.installSubscriptionHandlers(httpServer)\n+\n+httpServer.listen(port, () => {\n+  console.log(`Server is listening on port ${port}`)\n+})\ndiff --git a/server/package.json b/server/package.json\nnew file mode 100644\nindex 0000000..6cd6f08\n--- /dev/null\n+++ b/server/package.json\n@@ -0,0 +1,52 @@\n+{\n+  \"name\": \"whatsapp-clone-server\",\n+  \"description\": \"A newly created Tortilla project\",\n+  \"repository\": {\n+    \"type\": \"git\",\n+    \"url\": \"https://github.com/Urigo/WhatsApp-Clone-Server.git\"\n+  },\n+  \"private\": true,\n+  \"scripts\": {\n+    \"start\": \"ts-node index.ts\",\n+    \"test\": \"jest\",\n+    \"codegen\": \"gql-gen\"\n+  },\n+  \"devDependencies\": {\n+    \"@graphql-codegen/cli\": \"1.0.3\",\n+    \"@graphql-codegen/typescript\": \"1.0.3\",\n+    \"@graphql-codegen/typescript-resolvers\": \"1.0.3\",\n+    \"@types/bcrypt\": \"3.0.0\",\n+    \"@types/body-parser\": \"1.17.0\",\n+    \"@types/cookie-parser\": \"1.4.1\",\n+    \"@types/cors\": \"2.8.4\",\n+    \"@types/express\": \"4.16.1\",\n+    \"@types/graphql\": \"14.0.7\",\n+    \"@types/graphql-iso-date\": \"3.3.1\",\n+    \"@types/jest\": \"24.0.11\",\n+    \"@types/jsonwebtoken\": \"8.3.2\",\n+    \"@types/node\": \"11.11.0\",\n+    \"jest\": \"24.5.0\",\n+    \"ts-jest\": \"24.0.0\",\n+    \"ts-node\": \"8.0.3\",\n+    \"typescript\": \"3.3.3333\"\n+  },\n+  \"dependencies\": {\n+    \"apollo-server-express\": \"2.4.8\",\n+    \"apollo-server-testing\": \"2.4.8\",\n+    \"bcrypt\": \"3.0.5\",\n+    \"body-parser\": \"1.18.3\",\n+    \"cookie-parser\": \"1.4.4\",\n+    \"cors\": \"2.8.5\",\n+    \"express\": \"4.16.4\",\n+    \"graphql\": \"14.1.1\",\n+    \"graphql-import\": \"0.7.1\",\n+    \"graphql-iso-date\": \"3.6.1\",\n+    \"graphql-tools\": \"4.0.4\",\n+    \"jsonwebtoken\": \"8.5.1\"\n+  },\n+  \"jest\": {\n+    \"transform\": {\n+      \"^.+\\\\.(js|jsx|ts|tsx)$\": \"<rootDir>/node_modules/ts-jest\"\n+    }\n+  }\n+}\ndiff --git a/server/schema/index.ts b/server/schema/index.ts\nnew file mode 100644\nindex 0000000..9cc2043\n--- /dev/null\n+++ b/server/schema/index.ts\n@@ -0,0 +1,10 @@\n+import { importSchema } from 'graphql-import'\n+import { makeExecutableSchema, IResolvers } from 'graphql-tools'\n+import resolvers from './resolvers'\n+\n+const typeDefs = importSchema('schema/typeDefs.graphql')\n+\n+export default makeExecutableSchema({\n+  resolvers: resolvers as IResolvers,\n+  typeDefs,\n+})\ndiff --git a/server/schema/resolvers.ts b/server/schema/resolvers.ts\nnew file mode 100644\nindex 0000000..6d25289\n--- /dev/null\n+++ b/server/schema/resolvers.ts\n@@ -0,0 +1,227 @@\n+import { withFilter } from 'apollo-server-express'\n+import { GraphQLDateTime } from 'graphql-iso-date'\n+import { User, Message, Chat, chats, messages, users } from '../db'\n+import { Resolvers } from '../types/graphql'\n+\n+const resolvers: Resolvers = {\n+  Date: GraphQLDateTime,\n+\n+  Message: {\n+    chat(message) {\n+      return chats.find(c => c.messages.some(m => m === message.id)) || null\n+    },\n+\n+    sender(message) {\n+      return users.find(u => u.id === message.sender) || null\n+    },\n+\n+    recipient(message) {\n+      return users.find(u => u.id === message.recipient) || null\n+    },\n+\n+    isMine(message, args, { currentUser }) {\n+      return message.sender === currentUser.id\n+    },\n+  },\n+\n+  Chat: {\n+    name(chat, args, { currentUser }) {\n+      if (!currentUser) return null\n+\n+      const participantId = chat.participants.find(p => p !== currentUser.id)\n+\n+      if (!participantId) return null\n+\n+      const participant = users.find(u => u.id === participantId)\n+\n+      return participant ? participant.name : null\n+    },\n+\n+    picture(chat, args, { currentUser }) {\n+      if (!currentUser) return null\n+\n+      const participantId = chat.participants.find(p => p !== currentUser.id)\n+\n+      if (!participantId) return null\n+\n+      const participant = users.find(u => u.id === participantId)\n+\n+      return participant ? participant.picture : null\n+    },\n+\n+    messages(chat) {\n+      return messages.filter(m => chat.messages.includes(m.id))\n+    },\n+\n+    lastMessage(chat) {\n+      const lastMessage = chat.messages[chat.messages.length - 1]\n+\n+      return messages.find(m => m.id === lastMessage) || null\n+    },\n+\n+    participants(chat) {\n+      return chat.participants.map(p => users.find(u => u.id === p)).filter(Boolean) as User[]\n+    },\n+  },\n+\n+  Query: {\n+    me(root, args, { currentUser }) {\n+      return currentUser || null\n+    },\n+\n+    chats(root, args, { currentUser }) {\n+      if (!currentUser) return []\n+\n+      return chats.filter(c => c.participants.includes(currentUser.id))\n+    },\n+\n+    chat(root, { chatId }, { currentUser }) {\n+      if (!currentUser) return null\n+\n+      const chat = chats.find(c => c.id === chatId)\n+\n+      if (!chat) return null\n+\n+      return chat.participants.includes(currentUser.id) ? chat : null\n+    },\n+\n+    users(root, args, { currentUser }) {\n+      if (!currentUser) return []\n+\n+      return users.filter(u => u.id !== currentUser.id)\n+    },\n+  },\n+\n+  Mutation: {\n+    addMessage(root, { chatId, content }, { currentUser, pubsub }) {\n+      if (!currentUser) return null\n+\n+      const chatIndex = chats.findIndex(c => c.id === chatId)\n+\n+      if (chatIndex === -1) return null\n+\n+      const chat = chats[chatIndex]\n+\n+      if (!chat.participants.includes(currentUser.id)) return null\n+\n+      const recentMessage = messages[messages.length - 1]\n+      const messageId = String(Number(recentMessage.id) + 1)\n+      const message: Message = {\n+        id: messageId,\n+        createdAt: new Date(),\n+        sender: currentUser.id,\n+        recipient: chat.participants.find(p => p !== currentUser.id) as string,\n+        content,\n+      }\n+\n+      messages.push(message)\n+      chat.messages.push(messageId)\n+      // The chat will appear at the top of the ChatsList component\n+      chats.splice(chatIndex, 1)\n+      chats.unshift(chat)\n+\n+      pubsub.publish('messageAdded', {\n+        messageAdded: message,\n+      })\n+\n+      return message\n+    },\n+\n+    addChat(root, { recipientId }, { currentUser, pubsub }) {\n+      if (!currentUser) return null\n+      if (!users.some(u => u.id === recipientId)) return null\n+\n+      let chat = chats.find(c =>\n+        c.participants.includes(currentUser.id) &&\n+        c.participants.includes(recipientId)\n+      )\n+\n+      if (chat) return chat\n+\n+      const chatsIds = chats.map(c => Number(c.id))\n+\n+      chat = {\n+        id: String(Math.max(...chatsIds) + 1),\n+        participants: [currentUser.id, recipientId],\n+        messages: [],\n+      }\n+\n+      chats.push(chat)\n+\n+      pubsub.publish('chatAdded', {\n+        chatAdded: chat\n+      })\n+\n+      return chat\n+    },\n+\n+    removeChat(root, { chatId }, { currentUser, pubsub }) {\n+      if (!currentUser) return null\n+\n+      const chatIndex = chats.findIndex(c => c.id === chatId)\n+\n+      if (chatIndex === -1) return null\n+\n+      const chat = chats[chatIndex]\n+\n+      if (!chat.participants.some(p => p === currentUser.id)) return null\n+\n+      chat.messages.forEach((chatMessage) => {\n+        const chatMessageIndex = messages.findIndex(m => m.id === chatMessage)\n+\n+        if (chatMessageIndex !== -1) {\n+          messages.splice(chatMessageIndex, 1)\n+        }\n+      })\n+\n+      chats.splice(chatIndex, 1)\n+\n+      pubsub.publish('chatRemoved', {\n+        chatRemoved: chat.id,\n+        targetChat: chat,\n+      })\n+\n+      return chatId\n+    }\n+  },\n+\n+  Subscription: {\n+    messageAdded: {\n+      subscribe: withFilter(\n+        (root, args, { pubsub }) => pubsub.asyncIterator('messageAdded'),\n+        ({ messageAdded }, args, { currentUser }) => {\n+          if (!currentUser) return false\n+\n+          return [\n+            messageAdded.sender,\n+            messageAdded.recipient,\n+          ].includes(currentUser.id)\n+        },\n+      )\n+    },\n+\n+    chatAdded: {\n+      subscribe: withFilter(\n+        (root, args, { pubsub }) => pubsub.asyncIterator('chatAdded'),\n+        ({ chatAdded }: { chatAdded: Chat }, args, { currentUser }) => {\n+          if (!currentUser) return false\n+\n+          return chatAdded.participants.some(p => p === currentUser.id)\n+        },\n+      )\n+    },\n+\n+    chatRemoved: {\n+      subscribe: withFilter(\n+        (root, args, { pubsub }) => pubsub.asyncIterator('chatRemoved'),\n+        ({ targetChat }: { targetChat: Chat }, args, { currentUser }) => {\n+          if (!currentUser) return false\n+\n+          return targetChat.participants.some(p => p === currentUser.id)\n+        },\n+      )\n+    }\n+  }\n+}\n+\n+export default resolvers\ndiff --git a/server/schema/typeDefs.graphql b/server/schema/typeDefs.graphql\nnew file mode 100644\nindex 0000000..6bbdca3\n--- /dev/null\n+++ b/server/schema/typeDefs.graphql\n@@ -0,0 +1,45 @@\n+scalar Date\n+\n+type User {\n+  id: ID!\n+  name: String!\n+  picture: String\n+}\n+\n+type Message {\n+  id: ID!\n+  content: String!\n+  createdAt: Date!\n+  chat: Chat\n+  sender: User\n+  recipient: User\n+  isMine: Boolean!\n+}\n+\n+type Chat {\n+  id: ID!\n+  name: String\n+  picture: String\n+  lastMessage: Message\n+  messages: [Message!]!\n+  participants: [User!]!\n+}\n+\n+type Query {\n+  me: User\n+  chats: [Chat!]!\n+  chat(chatId: ID!): Chat\n+  users: [User!]!\n+}\n+\n+type Mutation {\n+  addMessage(chatId: ID!, content: String!): Message\n+  addChat(recipientId: ID!): Chat\n+  removeChat(chatId: ID!): ID\n+}\n+\n+type Subscription {\n+  messageAdded: Message!\n+  chatAdded: Chat!\n+  chatRemoved: ID!\n+}\ndiff --git a/server/tests/mutations/__snapshots__/addChat.test.ts.snap b/server/tests/mutations/__snapshots__/addChat.test.ts.snap\nnew file mode 100644\nindex 0000000..d1d9f44\n--- /dev/null\n+++ b/server/tests/mutations/__snapshots__/addChat.test.ts.snap\n@@ -0,0 +1,52 @@\n+// Jest Snapshot v1, https://goo.gl/fbAQLP\n+\n+exports[`Mutation.addChat creates a new chat between current user and specified recipient 1`] = `\n+Object {\n+  \"addChat\": Object {\n+    \"id\": \"5\",\n+    \"name\": \"Bryan Wallace\",\n+    \"participants\": Array [\n+      Object {\n+        \"id\": \"2\",\n+      },\n+      Object {\n+        \"id\": \"3\",\n+      },\n+    ],\n+  },\n+}\n+`;\n+\n+exports[`Mutation.addChat creates a new chat between current user and specified recipient 2`] = `\n+Object {\n+  \"chat\": Object {\n+    \"id\": \"5\",\n+    \"name\": \"Bryan Wallace\",\n+    \"participants\": Array [\n+      Object {\n+        \"id\": \"2\",\n+      },\n+      Object {\n+        \"id\": \"3\",\n+      },\n+    ],\n+  },\n+}\n+`;\n+\n+exports[`Mutation.addChat returns the existing chat if so 1`] = `\n+Object {\n+  \"addChat\": Object {\n+    \"id\": \"1\",\n+    \"name\": \"Ethan Gonzalez\",\n+    \"participants\": Array [\n+      Object {\n+        \"id\": \"1\",\n+      },\n+      Object {\n+        \"id\": \"2\",\n+      },\n+    ],\n+  },\n+}\n+`;\ndiff --git a/server/tests/mutations/__snapshots__/addMessage.test.ts.snap b/server/tests/mutations/__snapshots__/addMessage.test.ts.snap\nnew file mode 100644\nindex 0000000..0e88349\n--- /dev/null\n+++ b/server/tests/mutations/__snapshots__/addMessage.test.ts.snap\n@@ -0,0 +1,22 @@\n+// Jest Snapshot v1, https://goo.gl/fbAQLP\n+\n+exports[`Mutation.addMessage should add message to specified chat 1`] = `\n+Object {\n+  \"addMessage\": Object {\n+    \"content\": \"Hello World\",\n+    \"id\": \"5\",\n+  },\n+}\n+`;\n+\n+exports[`Mutation.addMessage should add message to specified chat 2`] = `\n+Object {\n+  \"chat\": Object {\n+    \"id\": \"1\",\n+    \"lastMessage\": Object {\n+      \"content\": \"Hello World\",\n+      \"id\": \"5\",\n+    },\n+  },\n+}\n+`;\ndiff --git a/server/tests/mutations/addChat.test.ts b/server/tests/mutations/addChat.test.ts\nnew file mode 100644\nindex 0000000..1440c9f\n--- /dev/null\n+++ b/server/tests/mutations/addChat.test.ts\n@@ -0,0 +1,89 @@\n+import { createTestClient } from 'apollo-server-testing'\n+import { ApolloServer, PubSub, gql } from 'apollo-server-express'\n+import schema from '../../schema'\n+import { resetDb, users } from '../../db'\n+\n+describe('Mutation.addChat', () => {\n+  beforeEach(resetDb)\n+\n+  it('creates a new chat between current user and specified recipient', async () => {\n+    const server = new ApolloServer({\n+      schema,\n+      context: () => ({\n+        pubsub: new PubSub(),\n+        currentUser: users[1],\n+      }),\n+    })\n+\n+    const { query, mutate } = createTestClient(server)\n+\n+    const addChatRes = await mutate({\n+      variables: { recipientId: '3' },\n+      mutation: gql `\n+        mutation AddChat($recipientId: ID!) {\n+          addChat(recipientId: $recipientId) {\n+            id\n+            name\n+            participants {\n+              id\n+            }\n+          }\n+        }\n+      `,\n+    })\n+\n+    expect(addChatRes.data).toBeDefined()\n+    expect(addChatRes.errors).toBeUndefined()\n+    expect(addChatRes.data).toMatchSnapshot()\n+\n+    const getChatRes = await query({\n+      variables: { chatId: '5' },\n+      query: gql `\n+        query GetChat($chatId: ID!) {\n+          chat(chatId: $chatId) {\n+            id\n+            name\n+            participants {\n+              id\n+            }\n+          }\n+        }\n+      `,\n+    })\n+\n+    expect(getChatRes.data).toBeDefined()\n+    expect(getChatRes.errors).toBeUndefined()\n+    expect(getChatRes.data).toMatchSnapshot()\n+  })\n+\n+  it('returns the existing chat if so', async () => {\n+    const server = new ApolloServer({\n+      schema,\n+      context: () => ({\n+        pubsub: new PubSub(),\n+        currentUser: users[0],\n+      }),\n+    })\n+\n+    const { query, mutate } = createTestClient(server)\n+\n+    const addChatRes = await mutate({\n+      variables: { recipientId: '2' },\n+      mutation: gql `\n+        mutation AddChat($recipientId: ID!) {\n+          addChat(recipientId: $recipientId) {\n+            id\n+            name\n+            participants {\n+              id\n+            }\n+          }\n+        }\n+      `,\n+    })\n+\n+    expect(addChatRes.data).toBeDefined()\n+    expect(addChatRes.errors).toBeUndefined()\n+    expect(addChatRes.data).toMatchSnapshot()\n+  })\n+})\ndiff --git a/server/tests/mutations/addMessage.test.ts b/server/tests/mutations/addMessage.test.ts\nnew file mode 100644\nindex 0000000..9987460\n--- /dev/null\n+++ b/server/tests/mutations/addMessage.test.ts\n@@ -0,0 +1,55 @@\n+import { createTestClient } from 'apollo-server-testing'\n+import { ApolloServer, PubSub, gql } from 'apollo-server-express'\n+import schema from '../../schema'\n+import { resetDb, users } from '../../db'\n+\n+describe('Mutation.addMessage', () => {\n+  beforeEach(resetDb)\n+\n+  it('should add message to specified chat', async () => {\n+    const server = new ApolloServer({\n+      schema,\n+      context: () => ({\n+        pubsub: new PubSub(),\n+        currentUser: users[0],\n+      }),\n+    })\n+\n+    const { query, mutate } = createTestClient(server)\n+\n+    const addMessageRes = await mutate({\n+      variables: { chatId: '1', content: 'Hello World' },\n+      mutation: gql `\n+        mutation AddMessage($chatId: ID!, $content: String!) {\n+          addMessage(chatId: $chatId, content: $content) {\n+            id\n+            content\n+          }\n+        }\n+      `,\n+    })\n+\n+    expect(addMessageRes.data).toBeDefined()\n+    expect(addMessageRes.errors).toBeUndefined()\n+    expect(addMessageRes.data).toMatchSnapshot()\n+\n+    const getChatRes = await query({\n+      variables: { chatId: '1' },\n+      query: gql `\n+        query GetChat($chatId: ID!) {\n+          chat(chatId: $chatId) {\n+            id\n+            lastMessage {\n+              id\n+              content\n+            }\n+          }\n+        }\n+      `,\n+    })\n+\n+    expect(getChatRes.data).toBeDefined()\n+    expect(getChatRes.errors).toBeUndefined()\n+    expect(getChatRes.data).toMatchSnapshot()\n+  })\n+})\ndiff --git a/server/tests/mutations/removeChat.test.ts b/server/tests/mutations/removeChat.test.ts\nnew file mode 100644\nindex 0000000..ba2e27d\n--- /dev/null\n+++ b/server/tests/mutations/removeChat.test.ts\n@@ -0,0 +1,52 @@\n+import { createTestClient } from 'apollo-server-testing'\n+import { ApolloServer, PubSub, gql } from 'apollo-server-express'\n+import schema from '../../schema'\n+import { resetDb, users } from '../../db'\n+\n+describe('Mutation.removeChat', () => {\n+  beforeEach(resetDb)\n+\n+  it('removes chat by id', async () => {\n+    const server = new ApolloServer({\n+      schema,\n+      context: () => ({\n+        pubsub: new PubSub(),\n+        currentUser: users[0],\n+      }),\n+    })\n+\n+    const { query, mutate } = createTestClient(server)\n+\n+    const addChatRes = await mutate({\n+      variables: { chatId: '1' },\n+      mutation: gql `\n+        mutation RemoveChat($chatId: ID!) {\n+          removeChat(chatId: $chatId)\n+        }\n+      `,\n+    })\n+\n+    expect(addChatRes.data).toBeDefined()\n+    expect(addChatRes.errors).toBeUndefined()\n+    expect(addChatRes.data!.removeChat).toEqual('1')\n+\n+    const getChatRes = await query({\n+      variables: { chatId: '1' },\n+      query: gql `\n+        query GetChat($chatId: ID!) {\n+          chat(chatId: $chatId) {\n+            id\n+            name\n+            participants {\n+              id\n+            }\n+          }\n+        }\n+      `,\n+    })\n+\n+    expect(addChatRes.data).toBeDefined()\n+    expect(getChatRes.errors).toBeUndefined()\n+    expect(addChatRes.data!.chat).toBeUndefined()\n+  })\n+})\ndiff --git a/server/tests/queries/__snapshots__/getChat.test.ts.snap b/server/tests/queries/__snapshots__/getChat.test.ts.snap\nnew file mode 100644\nindex 0000000..a4b7849\n--- /dev/null\n+++ b/server/tests/queries/__snapshots__/getChat.test.ts.snap\n@@ -0,0 +1,16 @@\n+// Jest Snapshot v1, https://goo.gl/fbAQLP\n+\n+exports[`Query.chat should fetch specified chat 1`] = `\n+Object {\n+  \"chat\": Object {\n+    \"id\": \"1\",\n+    \"lastMessage\": Object {\n+      \"content\": \"You on your way?\",\n+      \"createdAt\": \"2018-12-30T23:20:00.000Z\",\n+      \"id\": \"1\",\n+    },\n+    \"name\": \"Ethan Gonzalez\",\n+    \"picture\": \"https://randomuser.me/api/portraits/thumb/men/1.jpg\",\n+  },\n+}\n+`;\ndiff --git a/server/tests/queries/__snapshots__/getChats.test.ts.snap b/server/tests/queries/__snapshots__/getChats.test.ts.snap\nnew file mode 100644\nindex 0000000..54a167c\n--- /dev/null\n+++ b/server/tests/queries/__snapshots__/getChats.test.ts.snap\n@@ -0,0 +1,48 @@\n+// Jest Snapshot v1, https://goo.gl/fbAQLP\n+\n+exports[`Query.chats should fetch all chats 1`] = `\n+Object {\n+  \"chats\": Array [\n+    Object {\n+      \"id\": \"1\",\n+      \"lastMessage\": Object {\n+        \"content\": \"You on your way?\",\n+        \"createdAt\": \"2018-12-30T23:20:00.000Z\",\n+        \"id\": \"1\",\n+      },\n+      \"name\": \"Ethan Gonzalez\",\n+      \"picture\": \"https://randomuser.me/api/portraits/thumb/men/1.jpg\",\n+    },\n+    Object {\n+      \"id\": \"2\",\n+      \"lastMessage\": Object {\n+        \"content\": \"Hey, it's me\",\n+        \"createdAt\": \"2018-12-30T06:40:00.000Z\",\n+        \"id\": \"2\",\n+      },\n+      \"name\": \"Bryan Wallace\",\n+      \"picture\": \"https://randomuser.me/api/portraits/thumb/men/2.jpg\",\n+    },\n+    Object {\n+      \"id\": \"3\",\n+      \"lastMessage\": Object {\n+        \"content\": \"I should buy a boat\",\n+        \"createdAt\": \"2018-12-15T00:00:00.000Z\",\n+        \"id\": \"3\",\n+      },\n+      \"name\": \"Avery Stewart\",\n+      \"picture\": \"https://randomuser.me/api/portraits/thumb/women/1.jpg\",\n+    },\n+    Object {\n+      \"id\": \"4\",\n+      \"lastMessage\": Object {\n+        \"content\": \"This is wicked good ice cream.\",\n+        \"createdAt\": \"2018-05-12T08:00:00.000Z\",\n+        \"id\": \"4\",\n+      },\n+      \"name\": \"Katie Peterson\",\n+      \"picture\": \"https://randomuser.me/api/portraits/thumb/women/2.jpg\",\n+    },\n+  ],\n+}\n+`;\ndiff --git a/server/tests/queries/__snapshots__/getUsers.test.ts.snap b/server/tests/queries/__snapshots__/getUsers.test.ts.snap\nnew file mode 100644\nindex 0000000..a2fd9bd\n--- /dev/null\n+++ b/server/tests/queries/__snapshots__/getUsers.test.ts.snap\n@@ -0,0 +1,55 @@\n+// Jest Snapshot v1, https://goo.gl/fbAQLP\n+\n+exports[`Query.getUsers should fetch all users except the one signed-in 1`] = `\n+Object {\n+  \"users\": Array [\n+    Object {\n+      \"id\": \"2\",\n+      \"name\": \"Ethan Gonzalez\",\n+      \"picture\": \"https://randomuser.me/api/portraits/thumb/men/1.jpg\",\n+    },\n+    Object {\n+      \"id\": \"3\",\n+      \"name\": \"Bryan Wallace\",\n+      \"picture\": \"https://randomuser.me/api/portraits/thumb/men/2.jpg\",\n+    },\n+    Object {\n+      \"id\": \"4\",\n+      \"name\": \"Avery Stewart\",\n+      \"picture\": \"https://randomuser.me/api/portraits/thumb/women/1.jpg\",\n+    },\n+    Object {\n+      \"id\": \"5\",\n+      \"name\": \"Katie Peterson\",\n+      \"picture\": \"https://randomuser.me/api/portraits/thumb/women/2.jpg\",\n+    },\n+  ],\n+}\n+`;\n+\n+exports[`Query.getUsers should fetch all users except the one signed-in 2`] = `\n+Object {\n+  \"users\": Array [\n+    Object {\n+      \"id\": \"1\",\n+      \"name\": \"Ray Edwards\",\n+      \"picture\": \"https://randomuser.me/api/portraits/thumb/lego/1.jpg\",\n+    },\n+    Object {\n+      \"id\": \"3\",\n+      \"name\": \"Bryan Wallace\",\n+      \"picture\": \"https://randomuser.me/api/portraits/thumb/men/2.jpg\",\n+    },\n+    Object {\n+      \"id\": \"4\",\n+      \"name\": \"Avery Stewart\",\n+      \"picture\": \"https://randomuser.me/api/portraits/thumb/women/1.jpg\",\n+    },\n+    Object {\n+      \"id\": \"5\",\n+      \"name\": \"Katie Peterson\",\n+      \"picture\": \"https://randomuser.me/api/portraits/thumb/women/2.jpg\",\n+    },\n+  ],\n+}\n+`;\ndiff --git a/server/tests/queries/getChat.test.ts b/server/tests/queries/getChat.test.ts\nnew file mode 100644\nindex 0000000..2d2407c\n--- /dev/null\n+++ b/server/tests/queries/getChat.test.ts\n@@ -0,0 +1,39 @@\n+import { createTestClient } from 'apollo-server-testing'\n+import { ApolloServer, gql } from 'apollo-server-express'\n+import schema from '../../schema'\n+import { users } from '../../db'\n+\n+describe('Query.chat', () => {\n+  it('should fetch specified chat', async () => {\n+    const server = new ApolloServer({\n+      schema,\n+      context: () => ({\n+        currentUser: users[0],\n+      }),\n+    })\n+\n+    const { query } = createTestClient(server)\n+\n+    const res = await query({\n+      variables: { chatId: '1' },\n+      query: gql `\n+        query GetChat($chatId: ID!) {\n+          chat(chatId: $chatId) {\n+            id\n+            name\n+            picture\n+            lastMessage {\n+              id\n+              content\n+              createdAt\n+            }\n+          }\n+        }\n+      `,\n+    })\n+\n+    expect(res.data).toBeDefined()\n+    expect(res.errors).toBeUndefined()\n+    expect(res.data).toMatchSnapshot()\n+  })\n+})\ndiff --git a/server/tests/queries/getChats.test.ts b/server/tests/queries/getChats.test.ts\nnew file mode 100644\nindex 0000000..e05d3f8\n--- /dev/null\n+++ b/server/tests/queries/getChats.test.ts\n@@ -0,0 +1,38 @@\n+import { createTestClient } from 'apollo-server-testing'\n+import { ApolloServer, gql } from 'apollo-server-express'\n+import schema from '../../schema'\n+import { users } from '../../db'\n+\n+describe('Query.chats', () => {\n+  it('should fetch all chats', async () => {\n+    const server = new ApolloServer({\n+      schema,\n+      context: () => ({\n+        currentUser: users[0],\n+      }),\n+    })\n+\n+    const { query } = createTestClient(server)\n+\n+    const res = await query({\n+      query: gql `\n+        query GetChats {\n+          chats {\n+            id\n+            name\n+            picture\n+            lastMessage {\n+              id\n+              content\n+              createdAt\n+            }\n+          }\n+        }\n+      `,\n+    })\n+\n+    expect(res.data).toBeDefined()\n+    expect(res.errors).toBeUndefined()\n+    expect(res.data).toMatchSnapshot()\n+  })\n+})\ndiff --git a/server/tests/queries/getMe.test.ts b/server/tests/queries/getMe.test.ts\nnew file mode 100644\nindex 0000000..353a883\n--- /dev/null\n+++ b/server/tests/queries/getMe.test.ts\n@@ -0,0 +1,33 @@\n+import { createTestClient } from 'apollo-server-testing'\n+import { ApolloServer, gql } from 'apollo-server-express'\n+import schema from '../../schema'\n+import { users } from '../../db'\n+\n+describe('Query.me', () => {\n+  it('should fetch current user', async () => {\n+    const server = new ApolloServer({\n+      schema,\n+      context: () => ({\n+        currentUser: users[0],\n+      }),\n+    })\n+\n+    const { query } = createTestClient(server)\n+\n+    const res = await query({\n+      query: gql `\n+        query GetMe {\n+          me {\n+            id\n+            name\n+            picture\n+          }\n+        }\n+      `,\n+    })\n+\n+    expect(res.data).toBeDefined()\n+    expect(res.errors).toBeUndefined()\n+    expect(res.data).toMatchSnapshot()\n+  })\n+})\ndiff --git a/server/tests/queries/getUsers.test.ts b/server/tests/queries/getUsers.test.ts\nnew file mode 100644\nindex 0000000..f09e829\n--- /dev/null\n+++ b/server/tests/queries/getUsers.test.ts\n@@ -0,0 +1,51 @@\n+import { createTestClient } from 'apollo-server-testing'\n+import { ApolloServer, gql } from 'apollo-server-express'\n+import schema from '../../schema'\n+import { users } from '../../db'\n+\n+describe('Query.getUsers', () => {\n+  it('should fetch all users except the one signed-in', async () => {\n+    let currentUser = users[0]\n+\n+    const server = new ApolloServer({\n+      schema,\n+      context: () => ({ currentUser }),\n+    })\n+\n+    const { query } = createTestClient(server)\n+\n+    let res = await query({\n+      query: gql `\n+        query GetUsers {\n+          users {\n+            id\n+            name\n+            picture\n+          }\n+        }\n+      `,\n+    })\n+\n+    expect(res.data).toBeDefined()\n+    expect(res.errors).toBeUndefined()\n+    expect(res.data).toMatchSnapshot()\n+\n+    currentUser = users[1]\n+\n+    res = await query({\n+      query: gql `\n+        query GetUsers {\n+          users {\n+            id\n+            name\n+            picture\n+          }\n+        }\n+      `,\n+    })\n+\n+    expect(res.data).toBeDefined()\n+    expect(res.errors).toBeUndefined()\n+    expect(res.data).toMatchSnapshot()\n+  })\n+})\ndiff --git a/server/tsconfig.json b/server/tsconfig.json\nnew file mode 100644\nindex 0000000..fe56553\n--- /dev/null\n+++ b/server/tsconfig.json\n@@ -0,0 +1,16 @@\n+{\n+  \"compilerOptions\": {\n+    \"target\": \"es2018\",\n+    \"module\": \"commonjs\",\n+    \"lib\": [\n+      \"es2018\",\n+      \"esnext.asynciterable\"\n+    ],\n+    \"strict\": true,\n+    \"strictFunctionTypes\": false,\n+    \"strictPropertyInitialization\": false,\n+    \"esModuleInterop\": true,\n+    \"experimentalDecorators\": true,\n+    \"emitDecoratorMetadata\": true\n+  }\n+}\ndiff --git a/server/types/apollo-server-testing.d.ts b/server/types/apollo-server-testing.d.ts\nnew file mode 100644\nindex 0000000..e9d9b94\n--- /dev/null\n+++ b/server/types/apollo-server-testing.d.ts\n@@ -0,0 +1,27 @@\n+declare module 'apollo-server-testing' {\n+  import { ApolloServerBase } from 'apollo-server-core';\n+  import { print, DocumentNode } from 'graphql';\n+  import { GraphQLResponse } from 'graphql-extensions';\n+\n+  type StringOrAst = string | DocumentNode;\n+\n+  // A query must not come with a mutation (and vice versa).\n+  type Query<TVariables> = {\n+    query: StringOrAst;\n+    mutation?: undefined;\n+    variables?: TVariables;\n+  };\n+\n+  type Mutation<TVariables> = {\n+    mutation: StringOrAst;\n+    query?: undefined;\n+    variables?: TVariables;\n+  };\n+\n+  export const createTestClient: <TVariables>(\n+    server: ApolloServerBase,\n+  ) => {\n+    query: (query: Query<TVariables>) => Promise<GraphQLResponse>;\n+    mutate: (mutation: Mutation<TVariables>) => Promise<GraphQLResponse>;\n+  };\n+}\ndiff --git a/server/validators.ts b/server/validators.ts\nnew file mode 100644\nindex 0000000..341d955\n--- /dev/null\n+++ b/server/validators.ts\n@@ -0,0 +1,43 @@\n+export const validatePassword = (ctx: string, str: string) => {\n+  if (typeof str !== 'string') {\n+    throw TypeError(`${ctx} must be a string`)\n+  }\n+\n+  validateLength(ctx, str, 8, 30)\n+\n+  if (!/[a-zA-Z]+/.test(str)) {\n+    throw TypeError(`${ctx} must contain english letters`)\n+  }\n+\n+  if (!/\\d+/.test(str)) {\n+    throw TypeError(`${ctx} must contain numbers`)\n+  }\n+\n+  if (!/[^\\da-zA-Z]+/.test(str)) {\n+    throw TypeError(`${ctx} must contain special charachters`)\n+  }\n+}\n+\n+export const validateLength = (ctx: string, str: string, ...args: number[]) => {\n+  let min, max\n+\n+  if (args.length === 1) {\n+    min = 0\n+    max = args[0]\n+  } else {\n+    min = args[0]\n+    max = args[1]\n+  }\n+\n+  if (typeof str !== 'string') {\n+    throw TypeError(`${ctx} must be a string`)\n+  }\n+\n+  if (str.length < min) {\n+    throw TypeError(`${ctx} must be at least ${min} chars long`)\n+  }\n+\n+  if (str.length > max) {\n+    throw TypeError(`${ctx} must contain ${max} chars at most`)\n+  }\n+}\n",
        "manuals": [
          {
            "manualTitle": "Whatsapp Clone Tutorial",
            "stepRevision": "35db7831b127708a77b49da926b1cae615b17733",
            "manualView": "![whatsapp-clone](https://user-images.githubusercontent.com/7648874/54141944-9f801a80-4461-11e9-85a1-bcb161d9a6c6.png)\n\nWhatsapp Clone is an open-source tutorial that will guide you through step-by-step on how to create a full-stack hybrid web-app.\n\nThe software world is evolving quickly, and oftentimes people find themselves left behind, even the most experienced ones. The purpose of this tutorial is to completely demystify the confusion, and be the main guide on how to do things properly.\n\nThis tutorial is for anyone who has ever asked himself or herself one of the following questions or similar:\n\n- How do people build an app today?\n- What are the “hottest”, most leading technologies currently in the ecosystem?\n- What are the best practices for using technology XXX?\n- What is the purpose of technology XXX?\n- How does technology XXX work?\n- How do I use technology XXX?\n- How do I migrate to the new version of technology XXX?\n- Why should I use technology XXX over technology YYY?\n\nAll of the above and more can be answered in the tutorial. Whether you’re a beginner, intermediate or a professional, we will have the answers you’re looking for.\n\n**What technologies does Whatsapp Clone uses?**\n\nCurrently, Whatsapp Clone uses:\n\n- [React (with Hooks and Suspense)](http://react.com)\n- [Styled-Components](https://styled-components.com)\n- [Material-UI](https://material-ui.com)\n- [TypeScript](https://typescriptlang.org)\n- [Apollo GraphQL](https://www.apollographql.com)\n- [GraphQL Code Generator](http://graphql-code-generator.com)\n- [GraphQL Modules](https://graphql-modules.com)\n- [PostgreSQL](https://www.postgresql.org/)\n- [TypeORM](https://github.com/typeorm/typeorm)\n\nThe point of this tutorial is not to be bound to a certain technology, but rather keep itself aligned with the ecosystem. When a new technology comes out, and it’s better and more popular, Whatsapp Clone will use it at some point (and full migration instructions).\n\n**P2P tutorial for the community by the community**\n\nWhat better way would it be to keep Whatsapp Clone aligned with the ecosystem than letting the community maintain it? Rather than dictating what technologies will be used in the app or how’s the tutorial gonna be written, you’re gonna decide how things are gonna be. That’s why we made it open source:\n\n- [Whatsapp Clone - Client](https://github.com/Urigo/WhatsApp-Clone-Client-React/tree/step-by-step-final)\n- [Whatsapp Clone - Server](https://github.com/Urigo/WhatsApp-Clone-server/step-by-step-final)\n\nWe’ve also made sure to publish some important documents so you can get more involved. You can track our progress and comment your suggestions, since everything is based on Google Docs and is updated live:\n\n- [Road map](https://docs.google.com/document/d/1p2Zio6Js2eoFfHs9CjIMF6jTuNyD4eQEHlgEAKhAqM8/edit?usp=sharing)\n- [Chapter manuals] (https://drive.google.com/open?id=1ITxOniS_S3sgZfunLvtJ1L9P6Fj1YOLlFHhoQPjT3S0)\n\n**Migration instructions included**\n\nThe are great tutorials out there, but almost none of them shows you what changes you should make in your app in order to be aligned with a new version of a certain technology. Technologies are being updated by the minute, some changes are minor and insignificant, but often times a breaking change will be made in which case we need to know how we can adapt to that change. Thanks to the [Tortilla platform](https://tortilla.academy), we can provide you with a git-diff that will show you what changes were made between each and every released version of the Whatsapp Clone tutorial since the beginning of history. This way you can easily notice the changes in APIs and migrate your app in no time.\n\n![tutorial-versions-diff](https://user-images.githubusercontent.com/7648874/54142148-0f8ea080-4462-11e9-9522-ec9997b76169.png)\n\n**Prerequisites**\n\n- JavaScript\n- TypeScript\n- JSX\n- HTML\n- CSS\n- Node.JS\n- NPM\n- React\n- SQL\n\nOS operations such as navigating to a folder, or creating a folder, are all gonna be written in Bash, but the instructions are OS agnostic and can be applied on any machine that is web-compatible.\n\n**What’s on the tutorial?**\n\nWhatsapp Clone is built chronologically, from the most basic, to more higher level features, so be sure to execute it in the right order. Each step is focused on a different subject, so by the end of it you’ll have a new feature and a new set of knowledge that you can start implementing in your everyday scenario immediately.\n\nCurrently, Whatsapp Clone includes the following chapters:\n\n- [Step 1: Creating a basic React APP with a basic view.](https://github.com/Urigo/WhatsApp-Clone-Tutorial/blob/final/.tortilla/manuals/views/step1.md)\n- [Step 2: Styling with Material-UI and Styled-Components.](https://github.com/Urigo/WhatsApp-Clone-Tutorial/blob/final/.tortilla/manuals/views/step2.md)\n- [Step 3: Setting a basic Node.JS server with basic a basic REST endpoint.](https://github.com/Urigo/WhatsApp-Clone-Tutorial/blob/final/.tortilla/manuals/views/step3.md)\n- [Step 4: Transition to GraphQL.](https://github.com/Urigo/WhatsApp-Clone-Tutorial/blob/final/.tortilla/manuals/views/step4.md)\n- Step N: TBA\n\nWhatsapp Clone is updated on a regular basis, so you should expect more steps and extensions to it not long from now. You can keep track of our [road map](https://docs.google.com/document/d/1p2Zio6Js2eoFfHs9CjIMF6jTuNyD4eQEHlgEAKhAqM8/edit?usp=sharing) to see what’s upcoming."
          },
          {
            "manualTitle": "Step 1: Creating a basic React APP with a basic view",
            "stepRevision": "96aad1c68a1344e34bb994d67a3d5d8a0d1ebe80",
            "manualView": "In this chapter we will learn how to create a basic React app. The app will contain a basic view that will render a list of conversations within our app. Everything should be done gradually, so for now, instead of using real data, we will use in-memory fake data instead of calling a server.\n\nThere are many ways to create an application. Indeed, you can create it from scratch, but the point behind development is that you'll make the least amount of work if possible. The point is to create a working product, and time is what matters, thus we're gonna use a boilerplate to kick-start our application. When it comes to React apps, the most popular is [`create-react-app`](https://github.com/facebook/create-react-app), which is pretty generic and easy to use. In addition, it's officially maintained by Facebook, the creators of React.\n\n`create-react-app` is a CLI that is installable via NPM:\n\n    $ npm install -g create-react-app\n\nOnce you do so, you will have it available in your terminal. If the installation failed, try to run the command as `sudo`:\n\n\t$ sudo npm install -g create-react-app\n\nUsing the `create` command, we can create the basis for our Whatsapp Clone:\n\n    $ create-react-app create whatsapp-clone-client\n\n> Note how we used the `client` prefix. That's because we're planning to create a server as well in further chapters.\n\nIt will create a directory called `whatsapp-clone-client` inside the current folder. Inside that directory, it will generate the initial project structure and install the transitive dependencies:\n\n    my-app\n    ├── README.md\n    ├── node_modules\n    ├── package.json\n    ├── .gitignore\n    ├── public\n    │   ├── favicon.ico\n    │   ├── index.html\n    │   └── manifest.json\n    └── src\n        ├── App.css\n        ├── App.js\n        ├── App.test.js\n        ├── index.css\n        ├── index.js\n        ├── logo.svg\n        └── serviceWorker.js\n\nNo configuration or complicated folder structures, just the files you need to build your app. Once the installation is done, you can open your project folder:\n\n\t$ cd whatsapp-clone-client\n\nInside the newly created project, you can run some built-in commands:\n\n\t$ npm start\n\nRuns the app in development mode. Open `http://localhost:3000` to view it in the browser:\n\n![boilerplate-page](https://user-images.githubusercontent.com/7648874/54026782-025f8080-41da-11e9-9a4e-796fe15e8d03.png)\n\nThe project that was created for us by `create-react-app` is highly functional and ready to use, but it's implemented in JavaScript. In our project, we're gonna use TypeScript. There's no right or wrong here, it's more of a personal choice. The main advantage of using TypeScript over using plain JavaScript is that we get to tell the compiler what types and data structures we expect in certain places, so that the compiler (which unlike a human never forgets) will remind us when we make a mistake and assume something that is not true.\n\nLuckily enough, `create-react-app` comes with a TypeScript support right out of the box, we only need to make a few adjustments in-order to make it work. First we need to install the TypeScript package, which is essential for TypeScript to function:\n\n\t$ yarn add typescript\n\nEvery TypeScript project requires a `tsconfig.json` to be defined. This configuration file will dictate the behavior of TypeScript within that project. More about `tsconfig.json` and its available options can be found in the [official TypeScript handbook](https://www.typescriptlang.org/docs/handbook/tsconfig-json.html). This is the config file we're gonna use in our project:\n\n[{]: <helper> (diffStep \"1.1\" files=\"tsconfig.json\" module=\"client\")\n\n#### [Step 1.1: Setup TypeScript](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/c05e16f)\n\n##### Added tsconfig.json\n```diff\n@@ -0,0 +1,35 @@\n+┊  ┊ 1┊{\n+┊  ┊ 2┊  \"compilerOptions\": {\n+┊  ┊ 3┊    \"outDir\": \"build/dist\",\n+┊  ┊ 4┊    \"sourceMap\": true,\n+┊  ┊ 5┊    \"declaration\": false,\n+┊  ┊ 6┊    \"moduleResolution\": \"node\",\n+┊  ┊ 7┊    \"emitDecoratorMetadata\": true,\n+┊  ┊ 8┊    \"experimentalDecorators\": true,\n+┊  ┊ 9┊    \"downlevelIteration\": true,\n+┊  ┊10┊    \"resolveJsonModule\": true,\n+┊  ┊11┊    \"target\": \"es5\",\n+┊  ┊12┊    \"jsx\": \"preserve\",\n+┊  ┊13┊    \"typeRoots\": [\n+┊  ┊14┊      \"node_modules/@types\"\n+┊  ┊15┊    ],\n+┊  ┊16┊    \"lib\": [\n+┊  ┊17┊      \"es2017\",\n+┊  ┊18┊      \"dom\",\n+┊  ┊19┊      \"esnext.asynciterable\"\n+┊  ┊20┊    ],\n+┊  ┊21┊    \"allowJs\": true,\n+┊  ┊22┊    \"skipLibCheck\": true,\n+┊  ┊23┊    \"esModuleInterop\": false,\n+┊  ┊24┊    \"allowSyntheticDefaultImports\": true,\n+┊  ┊25┊    \"forceConsistentCasingInFileNames\": true,\n+┊  ┊26┊    \"isolatedModules\": true,\n+┊  ┊27┊    \"noEmit\": true,\n+┊  ┊28┊    \"noImplicitAny\": false,\n+┊  ┊29┊    \"strict\": false,\n+┊  ┊30┊    \"module\": \"esnext\"\n+┊  ┊31┊  },\n+┊  ┊32┊  \"include\": [\n+┊  ┊33┊    \"src\"\n+┊  ┊34┊  ]\n+┊  ┊35┊}\n```\n\n[}]: #\n\nWe're also gonna add a `tslint.json` file into the project - a file which will determine the linting preferences for our project. All rules are listed and explained in the [official rules doc page](https://palantir.github.io/tslint/rules/). We will use the following rules:\n\n[{]: <helper> (diffStep \"1.1\" files=\"tslint.json\" module=\"client\")\n\n#### [Step 1.1: Setup TypeScript](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/c05e16f)\n\n##### Added tslint.json\n```diff\n@@ -0,0 +1,29 @@\n+┊  ┊ 1┊{\n+┊  ┊ 2┊  \"extends\": [\"tslint:recommended\", \"tslint-react\", \"tslint-config-prettier\"],\n+┊  ┊ 3┊  \"rules\": {\n+┊  ┊ 4┊    \"ordered-imports\": false,\n+┊  ┊ 5┊    \"object-literal-sort-keys\": false,\n+┊  ┊ 6┊    \"jsx-boolean-value\": false,\n+┊  ┊ 7┊    \"interface-name\" : false,\n+┊  ┊ 8┊    \"variable-name\": false,\n+┊  ┊ 9┊    \"no-string-literal\": false,\n+┊  ┊10┊    \"no-namespace\": false,\n+┊  ┊11┊    \"interface-over-type-literal\": false,\n+┊  ┊12┊    \"no-shadowed-variable\": false,\n+┊  ┊13┊    \"curly\": false,\n+┊  ┊14┊    \"no-label\": false,\n+┊  ┊15┊    \"no-empty\": false,\n+┊  ┊16┊    \"no-debugger\": false,\n+┊  ┊17┊    \"no-console\": false,\n+┊  ┊18┊    \"array-type\": false\n+┊  ┊19┊  },\n+┊  ┊20┊  \"linterOptions\": {\n+┊  ┊21┊    \"exclude\": [\n+┊  ┊22┊      \"config/**/*.js\",\n+┊  ┊23┊      \"node_modules/**/*.ts\",\n+┊  ┊24┊      \"coverage/lcov-report/*.js\",\n+┊  ┊25┊      \"*.json\",\n+┊  ┊26┊      \"**/*.json\"\n+┊  ┊27┊    ]\n+┊  ┊28┊  }\n+┊  ┊29┊}\n```\n\n[}]: #\n\nOnce we will run the app for the first time, `react-scripts` (`create-react-app` utility scripts package) should automatically initialize some additional TypeScript related files:\n\n\t$ npm start\n\nSince we're gonna use the new React [Hooks](https://reactjs.org/docs/hooks-intro.html) and [Suspense](https://reactjs.org/docs/react-api.html#reactsuspense) mechanisms, **make sure that your app uses React version 16.8 or above, otherwise it won't work.** The React version can be determined simply by looking at the `package.json` file. If by any chance your React version is lower than the required one, be sure to upgrade the version of `create-react-app` by upgrading it to the latest one and repeat the process of the project creation. Just in case, `create-react-app` can be upgrade by re-running the install command:\n\n\t$ npm install -g create-react-app\n\nAssuming that everything is set, we will now create our first screen - ChatsListScreen. The ChatsListScreen component is responsible for showing the active conversations within our app. Everything should be done gradually, so for now, instead of using real data, we will use in-memory fake data. Further in this tutorial, we will also create a server that will serve that data and connect it to our client.\n\nIt's best to first schematically plan how our view's gonna look like. This would help us illustrate the intended view and also understand which React.Components / elements take part in it. This is how our screen's gonna look like:\n\n![chatslistscreen](https://user-images.githubusercontent.com/7648874/54027873-01305280-41de-11e9-9df0-5ad9c9c2f226.png)\n\nLet's break down the image above and see what components are we gonna have in the ChatsListScreen:\n\n- Navbar -  Which should contain a simple static title for now.\n- ChatsList - Where each item's gonna contain some data regards the user we're chatting with and information about the chat.\n\nReact apps tend to store React.Components under a directory located at `src/components`, and so we're gonna follow this pattern. We will create a directory called ChatsListScreen in the `components` dir where we're simply gonna import and put together the Navbar and ChatsList components. This is how the contents of that directory should look like:\n\n    ChatsListScreen\n    ├── index.tsx\n    ├── ChatsList\n    └── ChatsNavbar\n\nWe will use the `index.tsx` file to define that component, this way we can import it using the directory name:\n\n[{]: <helper> (diffStep \"1.2\" files=\"components/ChatsListScreen/index.jsx\" module=\"client\")\n\n#### [Step 1.2: Implement ChatsListScreen](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/80da8a2)\n\n\n\n[}]: #\n\nNow we can implement the Navbar component, which doesn't have much for now except some text describing the app:\n\n[{]: <helper> (diffStep \"1.2\" files=\"components/ChatsListScreen/ChatsNavbar.jsx\" module=\"client\")\n\n#### [Step 1.2: Implement ChatsListScreen](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/80da8a2)\n\n\n\n[}]: #\n\nAnd the ChatsList component:\n\n[{]: <helper> (diffStep \"1.2\" files=\"components/ChatsListScreen/ChatsList.jsx\" module=\"client\")\n\n#### [Step 1.2: Implement ChatsListScreen](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/80da8a2)\n\n\n\n[}]: #\n\nYou can see in the code-diff above how we used the [`moment`](https://momentjs.com/) library to wrap `lastMessage.createdAt`. Moment has the ability to wrap date objects nicely and rewrite them in a pretty format. This way we can have an elegant time format at which the message was sent e.g. `11:34`. To install:\n\n\t$ yarn add moment\n\nThe ChatsList component has no event handlers and it's completely non-interactive as for now, that means that you can't click or tap anything yet, but as we go further in the tutorial we will add the necessary event handlers. Note how we used the `db.ts` module to get the chats data. `db.ts` is a temporary mock for our data-source and should be removed once we have a server up and running. Here's how our DB looks like:\n\n[{]: <helper> (diffStep \"1.3\" module=\"client\")\n\n#### [Step 1.3: Add db mock](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/254ce3f)\n\n##### Added src&#x2F;db.ts\n```diff\n@@ -0,0 +1,49 @@\n+┊  ┊ 1┊export const messages = [\n+┊  ┊ 2┊  {\n+┊  ┊ 3┊    id: 1,\n+┊  ┊ 4┊    content: \"You on your way?\",\n+┊  ┊ 5┊    createdAt: new Date(Date.now() - 60 * 1000 * 1000),\n+┊  ┊ 6┊  },\n+┊  ┊ 7┊  {\n+┊  ┊ 8┊    id: 2,\n+┊  ┊ 9┊    content: \"Hey, it's me\",\n+┊  ┊10┊    createdAt: new Date(Date.now() - 2 * 60 * 1000 * 1000),\n+┊  ┊11┊  },\n+┊  ┊12┊  {\n+┊  ┊13┊    id: 3,\n+┊  ┊14┊    content: \"I should buy a boat\",\n+┊  ┊15┊    createdAt: new Date(Date.now() - 24 * 60 * 1000 * 1000),\n+┊  ┊16┊  },\n+┊  ┊17┊  {\n+┊  ┊18┊    id: 4,\n+┊  ┊19┊    content: \"This is wicked good ice cream.\",\n+┊  ┊20┊    createdAt: new Date(Date.now() - 14 * 24 * 60 * 1000 * 1000),\n+┊  ┊21┊  },\n+┊  ┊22┊]\n+┊  ┊23┊\n+┊  ┊24┊export const chats = [\n+┊  ┊25┊  {\n+┊  ┊26┊    id: 1,\n+┊  ┊27┊    name: 'Ethan Gonzalez',\n+┊  ┊28┊    picture: 'https://randomuser.me/api/portraits/thumb/men/1.jpg',\n+┊  ┊29┊    lastMessage: messages.find(m => m.id === 1),\n+┊  ┊30┊  },\n+┊  ┊31┊  {\n+┊  ┊32┊    id: 2,\n+┊  ┊33┊    name: 'Bryan Wallace',\n+┊  ┊34┊    picture: 'https://randomuser.me/api/portraits/thumb/men/2.jpg',\n+┊  ┊35┊    lastMessage: messages.find(m => m.id === 2),\n+┊  ┊36┊  },\n+┊  ┊37┊  {\n+┊  ┊38┊    id: 3,\n+┊  ┊39┊    name: 'Avery Stewart',\n+┊  ┊40┊    picture: 'https://randomuser.me/api/portraits/thumb/women/1.jpg',\n+┊  ┊41┊    lastMessage: messages.find(m => m.id === 3),\n+┊  ┊42┊  },\n+┊  ┊43┊  {\n+┊  ┊44┊    id: 4,\n+┊  ┊45┊    name: 'Katie Peterson',\n+┊  ┊46┊    picture: 'https://randomuser.me/api/portraits/thumb/women/2.jpg',\n+┊  ┊47┊    lastMessage: messages.find(m => m.id === 4),\n+┊  ┊48┊  },\n+┊  ┊49┊]\n```\n\n[}]: #\n\nThe ChatsListScreen is now ready to use. We will replace the contents of the App component with the ChatsListScreen and we will make it the default screen in our app:\n\n[{]: <helper> (diffStep \"1.4\" files=\"App.jsx\" module=\"client\")\n\n#### [Step 1.4: Import ChatsListScreen](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/298b0d2)\n\n##### Changed src&#x2F;App.jsx\n```diff\n@@ -1,28 +1,10 @@\n-┊ 1┊  ┊import React, { Component } from 'react';\n-┊ 2┊  ┊import logo from './logo.svg';\n-┊ 3┊  ┊import './App.css';\n+┊  ┊ 1┊import * as React from 'react'\n+┊  ┊ 2┊import ChatsListScreen from './components/ChatsListScreen'\n ┊ 4┊ 3┊\n-┊ 5┊  ┊class App extends Component {\n-┊ 6┊  ┊  render() {\n-┊ 7┊  ┊    return (\n-┊ 8┊  ┊      <div className=\"App\">\n-┊ 9┊  ┊        <header className=\"App-header\">\n-┊10┊  ┊          <img src={logo} className=\"App-logo\" alt=\"logo\" />\n-┊11┊  ┊          <p>\n-┊12┊  ┊            Edit <code>src/App.js</code> and save to reload.\n-┊13┊  ┊          </p>\n-┊14┊  ┊          <a\n-┊15┊  ┊            className=\"App-link\"\n-┊16┊  ┊            href=\"https://reactjs.org\"\n-┊17┊  ┊            target=\"_blank\"\n-┊18┊  ┊            rel=\"noopener noreferrer\"\n-┊19┊  ┊          >\n-┊20┊  ┊            Learn React\n-┊21┊  ┊          </a>\n-┊22┊  ┊        </header>\n-┊23┊  ┊      </div>\n-┊24┊  ┊    );\n-┊25┊  ┊  }\n-┊26┊  ┊}\n+┊  ┊ 4┊const App = () => (\n+┊  ┊ 5┊  <div>\n+┊  ┊ 6┊    <ChatsListScreen />\n+┊  ┊ 7┊  </div>\n+┊  ┊ 8┊)\n ┊27┊ 9┊\n-┊28┊  ┊export default App;\n+┊  ┊10┊export default App\n```\n\n[}]: #\n\nIf you'll try to run the app you'll see that everything is there, but it's not hard to notice that it's missing some style:\n\n![naked-chats-list](https://user-images.githubusercontent.com/7648874/54028578-73099b80-41e0-11e9-803a-7469300acb06.png)\n\nIn the next chapter we will take care of styling our application with [Material-UI](https://material-ui.com/) and [styled-components](https://www.styled-components.com/) - we will give it the desired look and make it more user friendly. For now the ChatsListScreen serves no purpose, because you can't really do anything with it, but it can be used as a great basis to build on top of as we make progress."
          },
          {
            "manualTitle": "Step 2: Styling with Material UI and styled-components",
            "stepRevision": "6d68028a5ea49c2eafd2a5fe2125b70d27c55a68",
            "manualView": "Styled-components is a relatively new library that will transpile a given string into a CSS string and will encapsulate it under a React.Component. What's good about it is that you can define your style programmatically and it fits very well into React. With JavaScript in-hand you naturally have more control over your style, which makes it a very powerful tool.\n\nHere's one way to style a button using styled-components:\n\n```js\nconst Button = styled.button`\n  background: transparent;\n  border-radius: 3px;\n  border: 2px solid palevioletred;\n  color: palevioletred;\n  margin: 0.5em 1em;\n  padding: 0.25em 1em;\n\n  ${props => props.primary && css`\n    background: palevioletred;\n    color: white;\n  `}\n`;\n```\n\nThe created Button is actually a React.Component, so an instance of it can be created with ease like any other component:\n\n```jsx\n  <Button primary />\n```\n\nMore information about styled-components can be found in the official [docs page](https://www.styled-components.com/docs).\n\nWe would also use [Material-UI](https://material-ui.com/) - a library with a set of React components that implements Google's Material Design. What's good about it is that the design is already implemented right out of the box. Not only that, but it also includes a set of icons which are free to use.\n\nThere are many many things that Material-UI can offer, and it's not easy to follow it up, especially with the constantly evolving and improving API. The best way to go with it, is to have a component, and then look for it in the [official website](https://material-ui.com/). When it comes to searching for icons, they can be found in the [material.io](https://material-ui.com/) website through the search bar. As we move further in this tutorial you should have a better grasp of Material and how to use it.\n\n![material-ui-icons](https://user-images.githubusercontent.com/7648874/54141504-c853e000-4460-11e9-94b5-aae98ec9a1e3.png)\n\nWe will start off by installing both libraries:\n\n  $ npm install @material-ui/core @material-ui/icons styled-components\n\n`@material-ui/core` includes core component of Material-UI such as Input, Popover, Modal, etc, and `@material-ui/icons` includes a set of icons. Material is very generic and has a built in theming system which can be controlled by simply setting few variables, which is exactly what we're gonna need in our app.\n\nIn our app we're mainly gonna use 2 colors:\n\n- Primary #306759\n- Secondary #79e352\n\nTheme definition can easily be done in Material using the MuiThemeProvider component:\n\n[{]: <helper> (diffStep \"2.2\" module=\"client\")\n\n#### [Step 2.2: Setup Material-UI theme](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/e04f746)\n\n##### Changed src&#x2F;index.jsx\n```diff\n@@ -1,10 +1,25 @@\n+┊  ┊ 1┊import { MuiThemeProvider, createMuiTheme } from '@material-ui/core/styles'\n ┊ 1┊ 2┊import React from 'react';\n ┊ 2┊ 3┊import ReactDOM from 'react-dom';\n ┊ 3┊ 4┊import './index.css';\n ┊ 4┊ 5┊import App from './App';\n ┊ 5┊ 6┊import * as serviceWorker from './serviceWorker';\n ┊ 6┊ 7┊\n-┊ 7┊  ┊ReactDOM.render(<App />, document.getElementById('root'));\n+┊  ┊ 8┊const theme = createMuiTheme({\n+┊  ┊ 9┊  palette: {\n+┊  ┊10┊    primary: { main: '#2c6157' },\n+┊  ┊11┊    secondary: { main: '#6fd056' },\n+┊  ┊12┊  },\n+┊  ┊13┊  typography: {\n+┊  ┊14┊    useNextVariants: true,\n+┊  ┊15┊  },\n+┊  ┊16┊})\n+┊  ┊17┊\n+┊  ┊18┊ReactDOM.render(\n+┊  ┊19┊  <MuiThemeProvider theme={theme}>\n+┊  ┊20┊    <App />\n+┊  ┊21┊  </MuiThemeProvider>\n+┊  ┊22┊, document.getElementById('root'));\n ┊ 8┊23┊\n ┊ 9┊24┊// If you want your app to work offline and load faster, you can change\n ┊10┊25┊// unregister() to register() below. Note this comes with some pitfalls.\n```\n\n[}]: #\n\nOnce we have it set, the colors should be available to use in our application by simply providing the \"color\" prop to the component instance whose color we would like to change:\n\n```jsx\n<Button color=\"primary\">Primary</Button>\n<Button color=\"secondary\">Secondary</Button>\n```\n\nIn our app, we're also gonna use CSS directly to change its colors, therefore it would be handy to have these theme variables available to us through CSS. To do so, we will have have a second definition of these variables in `index.css`, at the `:root` level of our application.\n\n[{]: <helper> (diffStep \"2.3\" module=\"client\")\n\n#### [Step 2.3: Setup CSS theme vars](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/a31ace4)\n\n##### Changed src&#x2F;index.css\n```diff\n@@ -1,3 +1,10 @@\n+┊  ┊ 1┊:root {\n+┊  ┊ 2┊  --primary-bg: #2c6157;\n+┊  ┊ 3┊  --secondary-bg: #6fd056;\n+┊  ┊ 4┊  --primary-text: white;\n+┊  ┊ 5┊  --secondary-text: white;\n+┊  ┊ 6┊}\n+┊  ┊ 7┊\n ┊ 1┊ 8┊body {\n ┊ 2┊ 9┊  margin: 0;\n ┊ 3┊10┊  padding: 0;\n```\n\n[}]: #\n\n`:root` is a pseudo element that simply represents the root node, which will make the colors available in all elements. Normally, it works like JavaScript's scoping system and it will make variables available only to the current node and to its children, NOT its parents. CSS vars can be used like so:\n\n```css\n  color: var(--primary-text);\n  background-color: var(--primary-bg);\n```\n\nMore information about CSS variables can be found in the [official MDN docs](https://developer.mozilla.org/en-US/docs/Web/CSS/Using_CSS_variables).\n\nSo getting back to the ChatsListScreen, we will wrap the ChatsNavbar with Material's <Toolbar /> component:\n\n[{]: <helper> (diffStep \"2.4\" files=\"ChatsNavbar.tsx\" module=\"client\")\n\n#### [Step 2.4: Use Material components](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/e2e2104)\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;ChatsNavbar.tsx\n```diff\n@@ -1,9 +1,10 @@\n+┊  ┊ 1┊import { Toolbar } from '@material-ui/core'\n ┊ 1┊ 2┊import * as React from 'react'\n ┊ 2┊ 3┊\n ┊ 3┊ 4┊const ChatsNavbar = () => (\n-┊ 4┊  ┊  <div>\n+┊  ┊ 5┊  <Toolbar>\n ┊ 5┊ 6┊    Whatsapp Clone\n-┊ 6┊  ┊  </div>\n+┊  ┊ 7┊  </Toolbar>\n ┊ 7┊ 8┊)\n ┊ 8┊ 9┊\n ┊ 9┊10┊export default ChatsNavbar\n```\n\n[}]: #\n\nAnd we will replace the `<ul />` and `<li />` elements with Material's `<List />` and `<ListItem />` in ChatsList:\n\n[{]: <helper> (diffStep \"2.4\" files=\"ChatsList.tsx\" module=\"client\")\n\n#### [Step 2.4: Use Material components](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/e2e2104)\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;ChatsList.tsx\n```diff\n@@ -1,12 +1,13 @@\n+┊  ┊ 1┊import { List, ListItem } from '@material-ui/core'\n ┊ 1┊ 2┊import moment from 'moment'\n ┊ 2┊ 3┊import * as React from 'react'\n ┊ 3┊ 4┊import { chats } from '../../db'\n ┊ 4┊ 5┊\n ┊ 5┊ 6┊const ChatsList = () => (\n ┊ 6┊ 7┊  <div>\n-┊ 7┊  ┊    <ul>\n+┊  ┊ 8┊    <List>\n ┊ 8┊ 9┊      {chats.map((chat) => (\n-┊ 9┊  ┊        <li key={chat.id}>\n+┊  ┊10┊        <ListItem key={chat.id} button>\n ┊10┊11┊          <img src={chat.picture} />\n ┊11┊12┊          <div>{chat.name}</div>\n ┊12┊13┊          {chat.lastMessage && (\n```\n```diff\n@@ -15,9 +16,9 @@\n ┊15┊16┊              <div>{moment(chat.lastMessage.createdAt).format('HH:mm')}</div>\n ┊16┊17┊            </React.Fragment>\n ┊17┊18┊          )}\n-┊18┊  ┊        </li>\n+┊  ┊19┊        </ListItem>\n ┊19┊20┊      ))}\n-┊20┊  ┊    </ul>\n+┊  ┊21┊    </List>\n ┊21┊22┊  </div>\n ┊22┊23┊)\n ┊23┊24┊\n```\n\n[}]: #\n\nThanks to the `button` attribute we can give our list a more vibrant feeling and that will display a nice ripple effect once an item is clicked, something that could have taken a long time to implement manually.\n\nNext, we will use `styled-components` to create new React.Components which are bound into a style-sheet. This way when we create new instances of them, the components will be styled right out of the box. Example:\n\n```jsx\nconst Button = styled.button `\n  border-radius: 999px;\n`\n\nconst RedButton = styled(Button) `\n  color: red;\n`\n\nconst GreenButton = styled(Button) `\n  color: green;\n`\n\nconst BlueButton = styled(Button) `\n  color: blue;\n`\n\nconst Dashboard = (\n  <div>\n    <RedButton />\n    <GreenButton />\n    <BlueButton />\n  </div>\n)\n```\n\nThe clear advantage of such working strategy is that all the styles are encapsulated, unlike traditional CSS where style rules can easily collide and be merged unintentionally. Remember that **`styled-components` operates per component, not globally**. In terms of syntax and API there isn't much to explain, it's very intuitive and if you would follow the step-diffs in this tutorial carefully you should get the hang of `styled-components` pretty easily.\n\nAccordingly, let's use `styled-components` our `ChatsListScreen`:\n\n[{]: <helper> (diffStep \"2.5\" files=\"ChatsListScreen\" module=\"client\")\n\n#### [Step 2.5: Add style with styled-components](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/e8004c9)\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;ChatsList.tsx\n```diff\n@@ -1,25 +1,80 @@\n ┊ 1┊ 1┊import { List, ListItem } from '@material-ui/core'\n ┊ 2┊ 2┊import moment from 'moment'\n ┊ 3┊ 3┊import * as React from 'react'\n+┊  ┊ 4┊import styled from 'styled-components'\n ┊ 4┊ 5┊import { chats } from '../../db'\n ┊ 5┊ 6┊\n+┊  ┊ 7┊const Container = styled.div `\n+┊  ┊ 8┊  height: calc(100% - 56px);\n+┊  ┊ 9┊  overflow-y: overlay;\n+┊  ┊10┊`\n+┊  ┊11┊\n+┊  ┊12┊const StyledList = styled(List) `\n+┊  ┊13┊  padding: 0 !important;\n+┊  ┊14┊`\n+┊  ┊15┊\n+┊  ┊16┊const StyledListItem = styled(ListItem) `\n+┊  ┊17┊  height: 76px;\n+┊  ┊18┊  padding: 0 15px;\n+┊  ┊19┊  display: flex;\n+┊  ┊20┊`\n+┊  ┊21┊\n+┊  ┊22┊const ChatPicture = styled.img `\n+┊  ┊23┊  height: 50px;\n+┊  ┊24┊  width: 50px;\n+┊  ┊25┊  object-fit: cover;\n+┊  ┊26┊  border-radius: 50%;\n+┊  ┊27┊`\n+┊  ┊28┊\n+┊  ┊29┊const ChatInfo = styled.div `\n+┊  ┊30┊  width: calc(100% - 60px);\n+┊  ┊31┊  height: 46px;\n+┊  ┊32┊  padding: 15px 0;\n+┊  ┊33┊  margin-left: 10px;\n+┊  ┊34┊  border-bottom: 0.5px solid silver;\n+┊  ┊35┊  position: relative;\n+┊  ┊36┊`\n+┊  ┊37┊\n+┊  ┊38┊const ChatName = styled.div `\n+┊  ┊39┊  margin-top: 5px;\n+┊  ┊40┊`\n+┊  ┊41┊\n+┊  ┊42┊const MessageContent = styled.div `\n+┊  ┊43┊  color: gray;\n+┊  ┊44┊  font-size: 15px;\n+┊  ┊45┊  margin-top: 5px;\n+┊  ┊46┊  text-overflow: ellipsis;\n+┊  ┊47┊  overflow: hidden;\n+┊  ┊48┊  white-space: nowrap;\n+┊  ┊49┊`\n+┊  ┊50┊\n+┊  ┊51┊const MessageDate = styled.div `\n+┊  ┊52┊  position: absolute;\n+┊  ┊53┊  color: gray;\n+┊  ┊54┊  top: 20px;\n+┊  ┊55┊  right: 0;\n+┊  ┊56┊  font-size: 13px;\n+┊  ┊57┊`\n+┊  ┊58┊\n ┊ 6┊59┊const ChatsList = () => (\n-┊ 7┊  ┊  <div>\n-┊ 8┊  ┊    <List>\n+┊  ┊60┊  <Container>\n+┊  ┊61┊    <StyledList>\n ┊ 9┊62┊      {chats.map((chat) => (\n-┊10┊  ┊        <ListItem key={chat.id} button>\n-┊11┊  ┊          <img src={chat.picture} />\n-┊12┊  ┊          <div>{chat.name}</div>\n-┊13┊  ┊          {chat.lastMessage && (\n-┊14┊  ┊            <React.Fragment>\n-┊15┊  ┊              <div>{chat.lastMessage.content}</div>\n-┊16┊  ┊              <div>{moment(chat.lastMessage.createdAt).format('HH:mm')}</div>\n-┊17┊  ┊            </React.Fragment>\n-┊18┊  ┊          )}\n-┊19┊  ┊        </ListItem>\n+┊  ┊63┊        <StyledListItem key={chat.id} button>\n+┊  ┊64┊          <ChatPicture src={chat.picture} />\n+┊  ┊65┊          <ChatInfo>\n+┊  ┊66┊            <ChatName>{chat.name}</ChatName>\n+┊  ┊67┊            {chat.lastMessage && (\n+┊  ┊68┊              <React.Fragment>\n+┊  ┊69┊                <MessageContent>{chat.lastMessage.content}</MessageContent>\n+┊  ┊70┊                <MessageDate>{moment(chat.lastMessage.createdAt).format('HH:mm')}</MessageDate>\n+┊  ┊71┊              </React.Fragment>\n+┊  ┊72┊            )}\n+┊  ┊73┊          </ChatInfo>\n+┊  ┊74┊        </StyledListItem>\n ┊20┊75┊      ))}\n-┊21┊  ┊    </List>\n-┊22┊  ┊  </div>\n+┊  ┊76┊    </StyledList>\n+┊  ┊77┊  </Container>\n ┊23┊78┊)\n ┊24┊79┊\n ┊25┊80┊export default ChatsList\n```\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;ChatsNavbar.tsx\n```diff\n@@ -1,10 +1,18 @@\n ┊ 1┊ 1┊import { Toolbar } from '@material-ui/core'\n ┊ 2┊ 2┊import * as React from 'react'\n+┊  ┊ 3┊import styled from 'styled-components'\n+┊  ┊ 4┊\n+┊  ┊ 5┊const Container = styled(Toolbar) `\n+┊  ┊ 6┊  background-color: var(--primary-bg);\n+┊  ┊ 7┊  color: var(--primary-text);\n+┊  ┊ 8┊  font-size: 20px;\n+┊  ┊ 9┊  line-height: 40px;\n+┊  ┊10┊`\n ┊ 3┊11┊\n ┊ 4┊12┊const ChatsNavbar = () => (\n-┊ 5┊  ┊  <Toolbar>\n+┊  ┊13┊  <Container>\n ┊ 6┊14┊    Whatsapp Clone\n-┊ 7┊  ┊  </Toolbar>\n+┊  ┊15┊  </Container>\n ┊ 8┊16┊)\n ┊ 9┊17┊\n ┊10┊18┊export default ChatsNavbar\n```\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;index.tsx\n```diff\n@@ -1,12 +1,17 @@\n ┊ 1┊ 1┊import * as React from 'react'\n+┊  ┊ 2┊import styled from 'styled-components'\n ┊ 2┊ 3┊import ChatsNavbar from './ChatsNavbar'\n ┊ 3┊ 4┊import ChatsList from './ChatsList'\n ┊ 4┊ 5┊\n+┊  ┊ 6┊const Container = styled.div `\n+┊  ┊ 7┊  height: 100vh;\n+┊  ┊ 8┊`\n+┊  ┊ 9┊\n ┊ 5┊10┊const ChatsListScreen = () => (\n-┊ 6┊  ┊  <div>\n+┊  ┊11┊  <Container>\n ┊ 7┊12┊    <ChatsNavbar />\n ┊ 8┊13┊    <ChatsList />\n-┊ 9┊  ┊  </div>\n+┊  ┊14┊  </Container>\n ┊10┊15┊)\n ┊11┊16┊\n ┊12┊17┊export default ChatsListScreen\n```\n\n[}]: #\n\nNotice that we've changed the structure of the HTML of the ChatsList component. We've added the ChatInfo to allow better alignment of the elements. **There isn't right or wrong way to define CSS rules and HTML, as long as the script is clear and easy to understand, that will do**.\n\nWe're done styling `ChatsListScreen`. We will keep using the same principles to style the rest of the components in our application. The final result should look like so:\n\n![screenshot](https://user-images.githubusercontent.com/7648874/54141766-40baa100-4461-11e9-8dd0-59edcfdb3b84.png)"
          },
          {
            "manualTitle": "Step 3: Setup a basic Node.JS server with a basic REST endpoint",
            "stepRevision": "132bec62e76ad351ee738c7b3cd6dfd74041e380",
            "manualView": "So we have a running app with a single screen which looks stylish and presents some data to the user. There is something missing though. The data that is presented is just a mock for a server response, and it represents the schema of some real data to come.\n\nEven if we'll create real data on the client, that means that when the client is down, all the data is lost. But this is a social app, many people want to use it together and even the same person wants to use it on multiple devices. For that, we need a central place to store all data and all the clients would connect to that central place in order to retrieve or change the data.\n\nIn this step, we will write a Node.JS server and will expose a REST endpoint that will serve the data-mock. We will build the REST application using [Express](https://www.npmjs.com/package/express). Further in this tutorial, we will migrate to using a real data-base with real I/O from the user, so we got you covered.\n\nThe plan is to have a server up and running at `localhost:4000` that will expose a `GET /chats` route. Unlike our client application, we're not gonna use any boilerplate and we're gonna set everything up manually. Ofcourse, you should feel free to use a boilerplate if it looks right to you. Right outside the client project, we will create a new directory called `whatsapp-clone-server` in which we will start creating our server:\n\n    $ mkdir whatsapp-clone-server\n    $ cd whatsapp-clone-server\n\nThen we will use NPM to initialize a new project:\n\n    $ npm init --yes\n\n> `--yes` will answer yes to all questions and skip the prompt. It's just faster this way.\n\nThere's nothing special about this command, it only creates a basic package.json which we can add things on top (see [NPM's official docs](https://docs.npmjs.com/cli/init)). Just to make sure that things work, we will add an `index.js` file which will print \"hello world\" to the console.\n\n[{]: <helper> (diffStep \"1.1\" files=\"index.js\" module=\"server\")\n\n#### [Step 1.1: Create start script](https://github.com/Urigo/WhatsApp-Clone-Server/commit/6db07e1)\n\n##### Added index.js\n```diff\n@@ -0,0 +1 @@\n+┊ ┊1┊console.log('hello world')\n```\n\n[}]: #\n\n\nAnd we will add a startup script to the `package.json` file called `start`:\n\n    start: node index.js\n\nNPM-scripts are just a way to defined an alias for commands. Now we only have one simple script, but it can turn out to be something very complex depending on our server, so it can be very useful. More about npm-scripts can be found in the [official NPM docs](https://docs.npmjs.com/misc/scripts).\n\nNow we can run our server by running `$ npm start` and we should see the message \"hello world\" printed to the console, as expected.\n\nLike in our client's app, we will be using TypeScript. It's comfortable and it enables consistency between both apps. In order to use TypeScript we will install few packages:\n\n    $ npm install --dev typescript ts-node @types/node\n\n> Note how we used the `--dev` flag. This project is not gonna be required as an external dependency anywhere, but It is still common to separate between production dependencies and development dependencies. More about the `--dev` option can be read in the [NPM-install docs](https://docs.npmjs.com/cli/install).\n\n- The [`typescript`](https://www.npmjs.com/package/typescript) package is TypeScript's core transpiler.\n- [`ts-node`](https://www.npmjs.com/package/ts-node) is an interpreter that will transpile required `.ts` files into JavaScript at runtime.\n- [`@types/node`](https://www.npmjs.com/package/@types/node) will make the appropriate definitions for a Node.JS environment.\n\n> You can read more about the `@types` monorepo in the [official GitHub repository](https://github.com/DefinitelyTyped/DefinitelyTyped).\n\nOur server is gonna use the following `tsconfig.json` file, feel free to make the necessary modifications based on your needs:\n\n[{]: <helper> (diffStep \"1.2\" files=\"tsconfig.json\" module=\"server\")\n\n#### [Step 1.2: Setup TypeScript](https://github.com/Urigo/WhatsApp-Clone-Server/commit/eb61b6b)\n\n##### Added tsconfig.json\n```diff\n@@ -0,0 +1,16 @@\n+┊  ┊ 1┊{\n+┊  ┊ 2┊  \"compilerOptions\": {\n+┊  ┊ 3┊    \"target\": \"es2018\",\n+┊  ┊ 4┊    \"module\": \"commonjs\",\n+┊  ┊ 5┊    \"lib\": [\n+┊  ┊ 6┊      \"es2018\",\n+┊  ┊ 7┊      \"esnext.asynciterable\"\n+┊  ┊ 8┊    ],\n+┊  ┊ 9┊    \"strict\": true,\n+┊  ┊10┊    \"strictFunctionTypes\": false,\n+┊  ┊11┊    \"strictPropertyInitialization\": false,\n+┊  ┊12┊    \"esModuleInterop\": true,\n+┊  ┊13┊    \"experimentalDecorators\": true,\n+┊  ┊14┊    \"emitDecoratorMetadata\": true\n+┊  ┊15┊  }\n+┊  ┊16┊}\n```\n\n[}]: #\n\nWe will rename the `index.js` file to `index.ts`:\n\n    $ mv index.js index.ts\n\nAnd we will update the npm-script `start` to use `ts-node`, since we wanna use TypeScript, and not JavaScript directly:\n\n    start: ts-node index.ts\n\nWe can test the startup of our server again by running `$ npm start` and we should see the message \"hello world\" printed to the console. The skeleton of the project is set and we can move on to implementing the REST API.\n\nLike we said at the beginning, we will be using Express to setup the API. Express is wrap around the native [Node.JS \"http\"](https://nodejs.org/api/http.html) library which is responsible for handling HTTP requests. Yes, it can also be used directly, but Express is much more comfortable and has an amazing ecosystem built around it. Let's install Express and its TypeScript definitions:\n\n    $ npm install express\n    $ npm install --dev @types/express\n\nBefore we implement the `GET /chats` route we will implement a `GET /_ping` route. This route will be used to determine whether the server is up and running or not, and how fast the connection is based on the response time. For every request sent to this route, we should expect a response saying \"pong\". Some call it \"heartbeat\", because this route is being tested repeatedly by the hosting machine to check if it's alive, just like a heartbeat in a way. This is how the route should look like:\n\n[{]: <helper> (diffStep \"1.3\" files=\"index.ts\" module=\"server\")\n\n#### [Step 1.3: Setup a Express with a basic health check route](https://github.com/Urigo/WhatsApp-Clone-Server/commit/d04acfb)\n\n##### Changed index.ts\n```diff\n@@ -1 +1,13 @@\n-┊ 1┊  ┊console.log('hello world')\n+┊  ┊ 1┊import express from 'express'\n+┊  ┊ 2┊\n+┊  ┊ 3┊const app = express()\n+┊  ┊ 4┊\n+┊  ┊ 5┊app.get('/_ping', (req, res) => {\n+┊  ┊ 6┊  res.send('pong')\n+┊  ┊ 7┊})\n+┊  ┊ 8┊\n+┊  ┊ 9┊const port = process.env.PORT || 4000\n+┊  ┊10┊\n+┊  ┊11┊app.listen(port, () => {\n+┊  ┊12┊  console.log(`Server is listening on port ${port}`)\n+┊  ┊13┊})\n```\n\n[}]: #\n\nWe can use the `$ curl localhost:4000/_ping` command to send a request to the server and we should get a \"pong\", assuming that the server available on that URL. The `GET /chats` should be implemented similarly, only the response is different. Instead of returning \"pong\" we will return the data-mock for our chats:\n\n[{]: <helper> (diffStep \"1.4\" files=\"index.ts, db.ts\" module=\"server\")\n\n#### [Step 1.4: Create GET /chats route](https://github.com/Urigo/WhatsApp-Clone-Server/commit/db8fcca)\n\n##### Added db.ts\n```diff\n@@ -0,0 +1,49 @@\n+┊  ┊ 1┊export const messages = [\n+┊  ┊ 2┊  {\n+┊  ┊ 3┊    id: '1',\n+┊  ┊ 4┊    content: \"You on your way?\",\n+┊  ┊ 5┊    createdAt: new Date(new Date('1-1-2019').getTime() - 60 * 1000 * 1000),\n+┊  ┊ 6┊  },\n+┊  ┊ 7┊  {\n+┊  ┊ 8┊    id: '2',\n+┊  ┊ 9┊    content: \"Hey, it's me\",\n+┊  ┊10┊    createdAt: new Date(new Date('1-1-2019').getTime() - 2 * 60 * 1000 * 1000),\n+┊  ┊11┊  },\n+┊  ┊12┊  {\n+┊  ┊13┊    id: '3',\n+┊  ┊14┊    content: \"I should buy a boat\",\n+┊  ┊15┊    createdAt: new Date(new Date('1-1-2019').getTime() - 24 * 60 * 1000 * 1000),\n+┊  ┊16┊  },\n+┊  ┊17┊  {\n+┊  ┊18┊    id: '4',\n+┊  ┊19┊    content: \"This is wicked good ice cream.\",\n+┊  ┊20┊    createdAt: new Date(new Date('1-1-2019').getTime() - 14 * 24 * 60 * 1000 * 1000),\n+┊  ┊21┊  },\n+┊  ┊22┊]\n+┊  ┊23┊\n+┊  ┊24┊export const chats = [\n+┊  ┊25┊  {\n+┊  ┊26┊    id: '1',\n+┊  ┊27┊    name: 'Ethan Gonzalez',\n+┊  ┊28┊    picture: 'https://randomuser.me/api/portraits/thumb/men/1.jpg',\n+┊  ┊29┊    lastMessage: '1',\n+┊  ┊30┊  },\n+┊  ┊31┊  {\n+┊  ┊32┊    id: '2',\n+┊  ┊33┊    name: 'Bryan Wallace',\n+┊  ┊34┊    picture: 'https://randomuser.me/api/portraits/thumb/men/2.jpg',\n+┊  ┊35┊    lastMessage: '2',\n+┊  ┊36┊  },\n+┊  ┊37┊  {\n+┊  ┊38┊    id: '3',\n+┊  ┊39┊    name: 'Avery Stewart',\n+┊  ┊40┊    picture: 'https://randomuser.me/api/portraits/thumb/women/1.jpg',\n+┊  ┊41┊    lastMessage: '3',\n+┊  ┊42┊  },\n+┊  ┊43┊  {\n+┊  ┊44┊    id: '4',\n+┊  ┊45┊    name: 'Katie Peterson',\n+┊  ┊46┊    picture: 'https://randomuser.me/api/portraits/thumb/women/2.jpg',\n+┊  ┊47┊    lastMessage: '4',\n+┊  ┊48┊  },\n+┊  ┊49┊]\n```\n\n##### Changed index.ts\n```diff\n@@ -1,4 +1,5 @@\n ┊1┊1┊import express from 'express'\n+┊ ┊2┊import { chats } from './db'\n ┊2┊3┊\n ┊3┊4┊const app = express()\n ┊4┊5┊\n```\n```diff\n@@ -6,6 +7,10 @@\n ┊ 6┊ 7┊  res.send('pong')\n ┊ 7┊ 8┊})\n ┊ 8┊ 9┊\n+┊  ┊10┊app.get('/chats', (req, res) => {\n+┊  ┊11┊  res.json(chats)\n+┊  ┊12┊})\n+┊  ┊13┊\n ┊ 9┊14┊const port = process.env.PORT || 4000\n ┊10┊15┊\n ┊11┊16┊app.listen(port, () => {\n```\n\n[}]: #\n\nUnlike the previous route, we used the `.json()` method this time around to send a response. This will simply stringify the given JSON and set the right headers. Similarly to the client, we've defined the db mock in a dedicated file, as this is easier to maintain and look at.\n\nIt's also recommended to connect a middleware called [`cors`](https://www.npmjs.com/package/cors) which will enable cross-origin requests. Without it we will only be able to make requests in localhost, something which is likely to limit us in the future because we would probably host our server somewhere separate than the client application. Let's install the `cors` library and load it with the Express `middleware()` function:\n\n    $ npm install cors\n\n[{]: <helper> (diffStep \"1.4\" files=\"index.ts\" module=\"server\")\n\n#### [Step 1.4: Create GET /chats route](https://github.com/Urigo/WhatsApp-Clone-Server/commit/db8fcca)\n\n##### Changed index.ts\n```diff\n@@ -1,4 +1,5 @@\n ┊1┊1┊import express from 'express'\n+┊ ┊2┊import { chats } from './db'\n ┊2┊3┊\n ┊3┊4┊const app = express()\n ┊4┊5┊\n```\n```diff\n@@ -6,6 +7,10 @@\n ┊ 6┊ 7┊  res.send('pong')\n ┊ 7┊ 8┊})\n ┊ 8┊ 9┊\n+┊  ┊10┊app.get('/chats', (req, res) => {\n+┊  ┊11┊  res.json(chats)\n+┊  ┊12┊})\n+┊  ┊13┊\n ┊ 9┊14┊const port = process.env.PORT || 4000\n ┊10┊15┊\n ┊11┊16┊app.listen(port, () => {\n```\n\n[}]: #\n\nThe server is now ready to use! So getting back to the client, first we will define our server's URL under the `.env` file:\n\n[{]: <helper> (diffStep \"3.1\" module=\"client\")\n\n#### [Step 3.1: Define server URL](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/30e5400)\n\n##### Added .env\n```diff\n@@ -0,0 +1 @@\n+┊ ┊1┊REACT_APP_SERVER_URL=http://localhost:4000🚫↵\n```\n\n[}]: #\n\nThis will make our server's URL available under the `process.env.REACT_APP_SERVER_URL` member expression and it will be replaced with a fixed value at build time, just like macros. The `.env` file is a file which will automatically be loaded to `process.env` by the [`dotenv`](https://www.npmjs.com/package/dotenv) NPM package. `react-scripts` then filters environment variables which have a `REACT_APP_` prefix and provides the created JSON to a Webpack plugin called [DefinePlugin](https://webpack.js.org/plugins/define-plugin/), which will result in the macro effect.\n\nNow let's move back into our React app folder. We will now replace the local data-mock usage with a fetch from the server. For that we can use the native [fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API), however, it needs to be used in the right life-cycle hook of the React.Component.\n\nThere are 2 naive approaches for that:\n\n- Calling `fetch()` outside the component, but this way that chats will be fetched even if we're not even intending to create an instance of the component.\n\n```js\nfetch().then(() => /* ... */)\nconst MyComponent = () => {}\n```\n\n- Calling `fetch()` inside the component, but then it will be invoked whenever the component is re-rendered.\n\n```js\nconst MyComponent = () => {\n  fetch().then(() => /* ... */)\n}\n```\n\nThese 2 approaches indeed work, but they both fail to deliver what's necessary on the right time. In addition, there's no way to properly coordinate async function calls with the render method of the component.\n\n**Introducing: React hooks**\n\nWith React hooks we can invoke the desired logic in the right life-cycle stage of the target component. This way we can avoid potential memory leaks or extra calculations. To implement a proper `fetch()`, we will be using 2 React hooks:\n\n- [`React.useState()`](https://reactjs.org/docs/hooks-reference.html#usestate) - which is used to get and set a state of the component - will be used to store the fetch chats.\n\n```js\nconst [value, setValue] = useState(initialValue)\n```\n\n- [`React.useMemo()`](https://reactjs.org/docs/hooks-reference.html#usememo) - which is used to run a computation only once certain conditions were met - will be used to run the `fetch()` function only once the component has mounted.\n\n```js\nconst memoizedValue = useMemo(calcFn, [cond1, cond2, ...conds])\n```\n\nThe result of that approach will look like this, in the context of our ChatsList component:\n\n[{]: <helper> (diffStep \"3.2\" module=\"client\")\n\n#### [Step 3.2: Fetch chats using native fetch API](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/0201332)\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;ChatsList.tsx\n```diff\n@@ -1,8 +1,8 @@\n ┊1┊1┊import { List, ListItem } from '@material-ui/core'\n ┊2┊2┊import moment from 'moment'\n ┊3┊3┊import * as React from 'react'\n+┊ ┊4┊import { useState, useMemo } from 'react'\n ┊4┊5┊import styled from 'styled-components'\n-┊5┊ ┊import { chats } from '../../db'\n ┊6┊6┊\n ┊7┊7┊const Container = styled.div `\n ┊8┊8┊  height: calc(100% - 56px);\n```\n```diff\n@@ -56,25 +56,35 @@\n ┊56┊56┊  font-size: 13px;\n ┊57┊57┊`\n ┊58┊58┊\n-┊59┊  ┊const ChatsList = () => (\n-┊60┊  ┊  <Container>\n-┊61┊  ┊    <StyledList>\n-┊62┊  ┊      {chats.map((chat) => (\n-┊63┊  ┊        <StyledListItem key={chat.id} button>\n-┊64┊  ┊          <ChatPicture src={chat.picture} />\n-┊65┊  ┊          <ChatInfo>\n-┊66┊  ┊            <ChatName>{chat.name}</ChatName>\n-┊67┊  ┊            {chat.lastMessage && (\n-┊68┊  ┊              <React.Fragment>\n-┊69┊  ┊                <MessageContent>{chat.lastMessage.content}</MessageContent>\n-┊70┊  ┊                <MessageDate>{moment(chat.lastMessage.createdAt).format('HH:mm')}</MessageDate>\n-┊71┊  ┊              </React.Fragment>\n-┊72┊  ┊            )}\n-┊73┊  ┊          </ChatInfo>\n-┊74┊  ┊        </StyledListItem>\n-┊75┊  ┊      ))}\n-┊76┊  ┊    </StyledList>\n-┊77┊  ┊  </Container>\n-┊78┊  ┊)\n+┊  ┊59┊const ChatsList = () => {\n+┊  ┊60┊  const [chats, setChats] = useState([])\n+┊  ┊61┊\n+┊  ┊62┊  useMemo(async () => {\n+┊  ┊63┊    const body = await fetch(`${process.env.REACT_APP_SERVER_URL}/chats`)\n+┊  ┊64┊    const chats = await body.json()\n+┊  ┊65┊    setChats(chats)\n+┊  ┊66┊  }, [true])\n+┊  ┊67┊\n+┊  ┊68┊  return (\n+┊  ┊69┊    <Container>\n+┊  ┊70┊      <StyledList>\n+┊  ┊71┊        {chats.map((chat) => (\n+┊  ┊72┊          <StyledListItem key={chat.id} button>\n+┊  ┊73┊            <ChatPicture src={chat.picture} />\n+┊  ┊74┊            <ChatInfo>\n+┊  ┊75┊              <ChatName>{chat.name}</ChatName>\n+┊  ┊76┊              {chat.lastMessage && (\n+┊  ┊77┊                <React.Fragment>\n+┊  ┊78┊                  <MessageContent>{chat.lastMessage.content}</MessageContent>\n+┊  ┊79┊                  <MessageDate>{moment(chat.lastMessage.createdAt).format('HH:mm')}</MessageDate>\n+┊  ┊80┊                </React.Fragment>\n+┊  ┊81┊              )}\n+┊  ┊82┊            </ChatInfo>\n+┊  ┊83┊          </StyledListItem>\n+┊  ┊84┊        ))}\n+┊  ┊85┊      </StyledList>\n+┊  ┊86┊    </Container>\n+┊  ┊87┊  )\n+┊  ┊88┊}\n ┊79┊89┊\n ┊80┊90┊export default ChatsList\n```\n\n[}]: #\n\n> It's recommended to read about React hooks and their basic concept at the [official React docs page](https://reactjs.org/docs/hooks-overview.html).\n\nAt this point we can get rid of `db.ts` file in the client, since we don't use it anymore:\n\n    $ rm src/db.ts\n\nThat's it. Our ChatsListScreen is now connected to a working back-end. In the next step we will upgrade our REST API into a GraphQL API and we will create a basis for a more robust back-end."
          },
          {
            "manualTitle": "Step 4: Transition to GraphQL",
            "stepRevision": "e330bc88baacaf4c2197af547fa033d7b4b142ef",
            "manualView": "**What is GraphQL?**\n\n[GraphQL](https://graphql.org/) is a query language invented by Facebook, and it's used to query data within our API. It allows clients to define the structure of the data required, and the exact same structure of data will be returned from the server, therefore preventing excessively large amounts of data from being returned. Unlike REST, GraphQL APIs are organized in terms of types and fields, not endpoints.\n\nCurrently in our app, if we'd like to get its chats we would send a GET request to `/chats`. With GraphQL it would be done differently with a string that describes the data that we would like to get:\n\n```graphql\nchats {\n  id\n  name\n  picture\n  lastMessage {\n    id\n    content\n    createdAt\n  }\n}\n```\n\n> Above: An illustration of a potential GraphQL query sent to our Whatsapp API\n\n**Why GraphQL and not REST?**\n\nIn terms of experience REST got the upper hand. It has been used for many more years and has proven itself to work well, and it's completely agnostic to the implementation of the back-end. However, when it comes to data projection and aggregation, it fails to deliver.\n\nWhen using REST, often times you'll find yourself performing multiple requests to execute a single query of data. Not only that, you might even end up with additional data that is not necessary. Either way, the process would result in slower and heavier response.\n\nWith GraphQL we don't have that kind of problem. Queries may take many shapes and forms, and since GraphQL is schema based - it can handle it. You'll get exactly what you asked for with a single request. **GraphQL provides a dynamic API while REST doesn't.**\n\n```graphql\n# request\nquery {\n  chat(id: 1) {\n    id\n    name\n    lastMessage {\n      id\n      content\n    }\n  }\n}\n```\n\n![graphql-request](https://user-images.githubusercontent.com/7648874/54133620-5aec8300-4451-11e9-9bda-a459dc48f57c.png)\n\n```js\n// response\n{\n  \"data\": {\n    \"chat\": {\n      \"id\": 1,\n      \"name\": \"Ethan Gonzalez\",\n      \"lastMessage\": {\n        \"id\": 1,\n        \"content\": \"You on your way?\"\n      }\n    }\n  }\n}\n```\n\n**GraphQL schema, in a nutshell**\n\nLike said earlier,  GraphQL APIs are organized in terms of types and fields. That means that our app data should be described with a schema, where each field's gonna have a resolver - the handler that will return the corresponding data. Things will be much clearer as we move further.\n\nLet's try to describe our app's data with a GraphQL schema and then dive into it:\n\n```graphql\nscalar Date\n\ntype Message {\n  id: ID!\n  content: String!\n  createdAt: Date!\n}\n\ntype Chat {\n  id: ID!\n  name: String!\n  picture: String\n  lastMessage: Message\n}\n\ntype Query {\n  chats: [Chat!]!\n}\n```\n\nThe schema is self explanatory in terms of what data it's compatible with. Supported built-in scalar types in GraphQL are:\n\n- Int: Signed 32‐bit integer\n- Float: Signed double-precision floating-point value\n- String: UTF‐8 character sequence\n- Boolean: true or false\n- ID (serialized as String): A unique identifier, often used to refetch an object or as the key for a cache. While serialized as a String, ID signifies that it is not intended to be human‐readable\n\nAny custom scalar can be declared with the `scalar` keyword, and custom types can be declared with the `type` keyword. However, you should know that some types are reserved by GraphQL itself; `Query` is one of them. The `Query` type will be used as the root for received queries by the clients, which means that we can send queries which start with the `chats` field. Other reserved types are:\n\n- `type Query` - reserved for [GraphQL queries](https://graphql.org/learn/queries/#mutations).\n- `type Mutation` - reserved for [GraphQL mutations.](https://graphql.github.io/learn/queries/)\n- `type Subscription` - reserved for [GraphQL subscriptions.](https://www.apollographql.com/docs/react/advanced/subscriptions.html)\n\n> As we're not gonna go through the entire GraphQL API, it's recommended to go through the [official learn section of the GraphQL website](https://graphql.org/learn/), but the information so far will definitely help you kick-start, plus the upcoming implementation.\n\n**Getting started**\n\nWe will be implementing a GraphQL mechanism for the client and for the server. We will start with the server as things will make more sense, and we will be able to test it before we proceed into the client. Essentially GraphQL is connected into a HTTP endpoint, usually under `POST /graphql`, and so this is exactly what we're gonna do, connect the endpoint handler. Luckily, we don't have to implement that. A team called [Apollo](https://www.apollographql.com/) already did it for us, so we can use their implementation. We will install the required packages:\n\n    $ npm install apollo-server-express body-parser graphql\n    $ npm install --dev @types/body-parser @types/graphql\n\n- [`graphql`](https://www.npmjs.com/package/graphql) - The core package of GraphQL that includes the resolvers for basic data-types.\n- [`apollo-server-express`](https://www.npmjs.com/package/apollo-server-express) - Apollo's implementation for the GraphQL Express REST endpoint.\n- [`body-parser`](https://www.npmjs.com/package/body-parser) - Parse incoming request bodies in a middleware before your handlers, available under the req.body property.\n- `@types/…` - TypeScript definitions\n\nWe can now connect Apollo's middleware under the `/graphql` route:\n\n[{]: <helper> (diffStep \"2.1\" files=\"index.ts\" module=\"server\")\n\n#### [Step 2.1: Setup Apollo GraphQL](https://github.com/Urigo/WhatsApp-Clone-Server/commit/61346cd)\n\n##### Changed index.ts\n```diff\n@@ -1,10 +1,14 @@\n+┊  ┊ 1┊import { ApolloServer, gql } from 'apollo-server-express'\n+┊  ┊ 2┊import bodyParser from 'body-parser'\n ┊ 1┊ 3┊import cors from 'cors'\n ┊ 2┊ 4┊import express from 'express'\n ┊ 3┊ 5┊import { chats } from './db'\n+┊  ┊ 6┊import schema from './schema'\n ┊ 4┊ 7┊\n ┊ 5┊ 8┊const app = express()\n ┊ 6┊ 9┊\n ┊ 7┊10┊app.use(cors())\n+┊  ┊11┊app.use(bodyParser.json())\n ┊ 8┊12┊\n ┊ 9┊13┊app.get('/_ping', (req, res) => {\n ┊10┊14┊  res.send('pong')\n```\n```diff\n@@ -14,6 +18,13 @@\n ┊14┊18┊  res.json(chats)\n ┊15┊19┊})\n ┊16┊20┊\n+┊  ┊21┊const server = new ApolloServer({ schema })\n+┊  ┊22┊\n+┊  ┊23┊server.applyMiddleware({\n+┊  ┊24┊  app,\n+┊  ┊25┊  path: '/graphql',\n+┊  ┊26┊})\n+┊  ┊27┊\n ┊17┊28┊const port = process.env.PORT || 4000\n ┊18┊29┊\n ┊19┊30┊app.listen(port, () => {\n```\n\n[}]: #\n\nAs you can see, the middleware requires a schema. A schema is composed mainly out of 2 fields:\n\n- `typeDefs` (type definitions) - the schema types we wrote earlier this chapter for chats.\n- `resolvers` - The handlers that will provide the data for each field in `typeDefs`.\n\nWe will start first by defining the types. All we have to do is to copy-paste the contents of the schema that was shown earlier into a new file called `typeDefs.graphql`:\n\n[{]: <helper> (diffStep \"2.2\" files=\"schema/typeDefs.graphql\" module=\"server\")\n\n#### [Step 2.2: Create a basic GraphQL schema](https://github.com/Urigo/WhatsApp-Clone-Server/commit/43886fc)\n\n##### Added schema&#x2F;typeDefs.graphql\n```diff\n@@ -0,0 +1,18 @@\n+┊  ┊ 1┊scalar Date\n+┊  ┊ 2┊\n+┊  ┊ 3┊type Message {\n+┊  ┊ 4┊  id: ID!\n+┊  ┊ 5┊  content: String!\n+┊  ┊ 6┊  createdAt: Date!\n+┊  ┊ 7┊}\n+┊  ┊ 8┊\n+┊  ┊ 9┊type Chat {\n+┊  ┊10┊  id: ID!\n+┊  ┊11┊  name: String!\n+┊  ┊12┊  picture: String\n+┊  ┊13┊  lastMessage: Message\n+┊  ┊14┊}\n+┊  ┊15┊\n+┊  ┊16┊type Query {\n+┊  ┊17┊  chats: [Chat!]!\n+┊  ┊18┊}\n```\n\n[}]: #\n\nThe `.graphql` file extension is just a more convenient way to work with a GraphQL schema. The exported result should be a simple string that we can use to compose our GraphQL schema. The clear advantage of working with a dedicated file is that we get to have syntax highlight.\n\nNow we will implement the resolvers. Resolvers are presented in a JSON object where each resolver name should match the field name it represents. You can read more about resolvers in [Apollo's official docs for resolvers](https://www.apollographql.com/docs/tutorial/resolvers.html). This is how our resolvers should look like:\n\n[{]: <helper> (diffStep \"2.2\" files=\"schema/resolvers.ts\" module=\"server\")\n\n#### [Step 2.2: Create a basic GraphQL schema](https://github.com/Urigo/WhatsApp-Clone-Server/commit/43886fc)\n\n##### Added schema&#x2F;resolvers.ts\n```diff\n@@ -0,0 +1,14 @@\n+┊  ┊ 1┊import { GraphQLDateTime } from 'graphql-iso-date'\n+┊  ┊ 2┊import { chats } from '../db'\n+┊  ┊ 3┊\n+┊  ┊ 4┊const resolvers = {\n+┊  ┊ 5┊  Date: GraphQLDateTime,\n+┊  ┊ 6┊\n+┊  ┊ 7┊  Query: {\n+┊  ┊ 8┊    chats() {\n+┊  ┊ 9┊      return chats\n+┊  ┊10┊    },\n+┊  ┊11┊  },\n+┊  ┊12┊}\n+┊  ┊13┊\n+┊  ┊14┊export default resolvers\n```\n\n[}]: #\n\nFor now it's extremely simple, we map the chats query directly into the database collection. Each field in the resolvers object should match the GraphQL type it represents in the schema. Since we don't have any logic now, we should not implement any resolvers for the rest of the types, the data will simply be forwarded as is.\n\nNote that we've implemented a custom scalar named `Date` and we resolved it with an NPM package. Let's install it:\n\n    $ npm install graphql-iso-date\n    $ npm install --dev @types/graphql-iso-date\n\nFinal thing that we have to do would be combining the resolvers and the type-defs under a single GraphQL schema.\n\n[{]: <helper> (diffStep \"2.2\" files=\"index.ts\" module=\"server\")\n\n#### [Step 2.2: Create a basic GraphQL schema](https://github.com/Urigo/WhatsApp-Clone-Server/commit/43886fc)\n\n##### Added schema&#x2F;index.ts\n```diff\n@@ -0,0 +1,7 @@\n+┊ ┊1┊import { importSchema } from 'graphql-import'\n+┊ ┊2┊import { makeExecutableSchema } from 'graphql-tools'\n+┊ ┊3┊import resolvers from './resolvers'\n+┊ ┊4┊\n+┊ ┊5┊const typeDefs = importSchema('schema/typeDefs.graphql')\n+┊ ┊6┊\n+┊ ┊7┊export default makeExecutableSchema({ resolvers, typeDefs })\n```\n\n[}]: #\n\n[`graphql-import`](https://www.npmjs.com/package/graphql-import) and [`graphql-tools`](https://www.npmjs.com/package/graphql-tools) are utility packages that will help us create a schema that will be compatible with Apollo's API. Let's install them:\n\n    $ npm install graphql-import graphql-tools\n\nThere's one optimization however that we should make in the our DB. Right now, the each chat document has a direct reference to a message via the `lastMessage` field. Practically speaking, this is NOT how the data sits in the DB. The `lastMessage` should only hold the ID for the correlated message, and then in the Node.JS app we should **resolve** it according to our needs. Let's make the appropriate changes in the DB then:\n\n[{]: <helper> (diffStep \"2.3\" files=\"db.ts\" module=\"server\")\n\n#### [Step 2.3: Resolve Chat.lastMessage](https://github.com/Urigo/WhatsApp-Clone-Server/commit/f3aa258)\n\n\n\n[}]: #\n\nAnd a resolver to the `lastMessage` field:\n\n[{]: <helper> (diffStep \"2.3\" files=\"schema/typeDefs.graphql\" module=\"server\")\n\n#### [Step 2.3: Resolve Chat.lastMessage](https://github.com/Urigo/WhatsApp-Clone-Server/commit/f3aa258)\n\n\n\n[}]: #\n\nThe first argument of the resolver is the raw chat data received by the DB, and the returned result should be the mapped value which we would like to return to the client.\n\nAs we get further in this tutorial we should get a better grasp regards resolvers and their API, since we will have to deal with more logic and complexity within our Node.JS app.\n\nAssuming that the server is running, we can already test our GraphQL endpoint. Because it's exposed to us via a REST endpoint, we can use a `$ curl` command to send a request to `GET localhost:4000/graphql` and get a response with all the data. Again, the query that we're gonna use to fetch the chats is:\n\n```graphql\nchats {\n  id\n  name\n  picture\n  lastMessage {\n    id\n    content\n    createdAt\n  }\n}\n```\n\nThe one-liner version of it with a `$ curl` command looks like so:\n\n    curl \\\n      -X POST \\\n      -H \"Content-Type: application/json\" \\\n      --data '{ \"query\": \"{ chats { id name picture lastMessage { id content createdAt } } }\" }' \\\n      localhost:4000/graphql\n\nAs a response we should get the data-mock for our chats stored in the server. Since we have that in place, we can go ahead and delete our implementation for the `GET /chats` route.\n\nAnother way to test and inspect our GraphQL schema would be by using an IDE for the browser called [GraphQL Playground](https://github.com/prisma/graphql-playground). Apollo-Server ships with it right out of the box and can be used right away by navigating to the `localhost:4000/graphql` URL from the browser.\n\n[![](https://i.imgur.com/AE5W6OW.png)](https://graphqlbin.com/v2/6RQ6TM)\n\nSo getting back to the client, all we have to do is to change the fetching URL in the ChatsList component to use our newly implemented GraphQL REST endpoint:\n\n[{]: <helper> (diffStep \"4.1\" module=\"client\")\n\n#### [Step 4.1: Replace REST call with GraphQL call](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/88f7abd)\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;ChatsList.tsx\n```diff\n@@ -56,12 +56,33 @@\n ┊56┊56┊  font-size: 13px;\n ┊57┊57┊`\n ┊58┊58┊\n+┊  ┊59┊const getChatsQuery = `\n+┊  ┊60┊  query GetChats {\n+┊  ┊61┊    chats {\n+┊  ┊62┊      id\n+┊  ┊63┊      name\n+┊  ┊64┊      picture\n+┊  ┊65┊      lastMessage {\n+┊  ┊66┊        id\n+┊  ┊67┊        content\n+┊  ┊68┊        createdAt\n+┊  ┊69┊      }\n+┊  ┊70┊    }\n+┊  ┊71┊  }\n+┊  ┊72┊`\n+┊  ┊73┊\n ┊59┊74┊const ChatsList = () => {\n ┊60┊75┊  const [chats, setChats] = useState([])\n ┊61┊76┊\n ┊62┊77┊  useMemo(async () => {\n-┊63┊  ┊    const body = await fetch(`${process.env.REACT_APP_SERVER_URL}/chats`)\n-┊64┊  ┊    const chats = await body.json()\n+┊  ┊78┊    const body = await fetch(`${process.env.REACT_APP_SERVER_URL}/graphql`, {\n+┊  ┊79┊      method: 'POST',\n+┊  ┊80┊      headers: {\n+┊  ┊81┊        'Content-Type': 'application/json',\n+┊  ┊82┊      },\n+┊  ┊83┊      body: JSON.stringify({ query: getChatsQuery }),\n+┊  ┊84┊    })\n+┊  ┊85┊    const { data: { chats } } = await body.json()\n ┊65┊86┊    setChats(chats)\n ┊66┊87┊  }, [true])\n```\n\n[}]: #\n\nThe received data should be similar to the previous one. No further changes are required. In the next chapter, we will continue working on the UI of our front-end application and we will add a new screen to the flow - the `ChatRoomScreen`."
          },
          {
            "manualTitle": "Step 5: Testing",
            "stepRevision": "f677807a57821fe6d507cee0ec4979687ed35ea3",
            "manualView": "Testing is a crucial part when writing an application, especially if we're planning to publish it or make it a commercial thing. Before we hand someone a product, of any kind, we wanna make sure that it passes certain quality checks. We're signed on that product and so it's very important to ensure that it functions properly according our expectations, otherwise wouldn't wanna use it and will look for alternatives.\n\nIn the context of software, we constantly make changes. It's also inevitable to make all features completely independent from one another, so something in the app is likely to break as we upgrade it or maintain it. That's why we need to write a set of tests that can be run on demand, so when we implement a new feature we can simply run the tests and see what feature broke due to most recent changes.\n\nThere are currently 3 main testing frameworks in the NPM ecosystem: [Jasmine](https://jasmine.github.io/), [Mocha](https://mochajs.org/), and [Jest](https://jestjs.io/). Each testing framework has its pros, and cons, and at the end of the day it's a matter of preference. In our application we're gonna use [Jest](https://jestjs.io/) - a testing framework which was developed by Facebook. What's good about Jest is that it can be used to test both client and server logic, because it runs as a Node.JS application, but it also emulates the browser environment whenever we run it, thanks to [JSDOM](https://github.com/jsdom/jsdom).\n\n![jest](https://user-images.githubusercontent.com/7648874/54493900-e2ce0380-490f-11e9-8075-be4a236c7c38.png)\n\nIn this chapter we will learn how to test the React.Components in the client, and Apollo-GraphQL resolvers in the server. There are 3 kinds of tests:\n\n- Unit tests - which are used to test a single component, independently from other components in our system.\n- Integration tests - which are used to test a component in relation to other components in our systems (how well do they co-work with each other).\n- e2e tests (end to end) - which are used to test a complete, from the moment I clicked on a button in the user interface until the data gets back from the server and shown on the screen.\n\nThe efficiency of the tests go from bottom to top (unit -> e2e), but the maintenance and complexity go from bottom to top (e2e -> unit). Accordingly we will need to find a good balance where we don’t spend too much time on writing tests yet have a good indicator for how well our system functions. So we should write a lot of unit tests, a good amount of integration tests and a handful of e2e tests.\n\n![tests-types-table](https://user-images.githubusercontent.com/7648874/54494121-fed2a480-4911-11e9-9370-694ec989729b.png)\n\nWe will start with the client as it’s much easier, because Jest is set and ready to use right out of the box thanks to `create-react-app`.\n\n**Client - Testing React.Components**\n\nThanks to `create-react-app`, we have Jest set and ready to use right out of the box, so we can start writing tests right away. I you'll look at the `src` you'll see a file called `App.test.tsx`, which simply ensures that the component can be rendered without crashing.\n\n```jsx\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nit('renders without crashing', () => {\n  const div = document.createElement('div');\n  ReactDOM.render(<App />, div);\n  ReactDOM.unmountComponentAtNode(div);\n});\n```\n\nThis is not a typical test that you're likely to find in a React project, but it demonstrates very well how Jest can be used to test DOM related issues. If you'll run `$ npm run test` (or `$ yarn test`) in the command line and then press `a`, you should see the following output:\n\n![report](https://user-images.githubusercontent.com/7648874/54341429-eabe4700-4674-11e9-8e76-3aaaf7fec79a.png)\n\nJest will automatically run for every file that ends with a `.test.xxx` extension. This is very convenient because the tests can live right next to the component, and you don't need to lookup for it across the project. This behavior can be modified by configuring Jest in the `package.json` file under the `\"jest\"` field. More information about configuring Jest can be found in the official[ configuration documentation](https://jestjs.io/docs/en/configuration).\n\n> If you get a warning message regards wrapping the component with `act()` - this is a known issue with hooks and should have a proper solution soon. More about this issue and progress regards its fix can be found in this [GitHub thread](https://github.com/facebook/react/issues/14769#issuecomment-470097212).\n\nNow we're gonna write a basic test for the `<ChatsList />` component. In the test, we'll mock a fake response from the server, and examine the contents of rendered HTML. Since the HTML of the component is a dynamic thing and is constantly subject to changes, it would be a good idea to annotate it with `data-testid` attributes so it can be tested regardless of its structure:\n\n[{]: <helper> (diffStep \"5.1\" files=\"ChatsList.tsx\" module=\"client\")\n\n#### [Step 5.1: Add data-testid attributes](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/be6d6c5)\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;ChatsList.tsx\n```diff\n@@ -91,13 +91,13 @@\n ┊ 91┊ 91┊      <StyledList>\n ┊ 92┊ 92┊        {chats.map((chat) => (\n ┊ 93┊ 93┊          <StyledListItem key={chat.id} button>\n-┊ 94┊   ┊            <ChatPicture src={chat.picture} />\n+┊   ┊ 94┊            <ChatPicture data-testid=\"picture\" src={chat.picture} />\n ┊ 95┊ 95┊            <ChatInfo>\n-┊ 96┊   ┊              <ChatName>{chat.name}</ChatName>\n+┊   ┊ 96┊              <ChatName data-testid=\"name\">{chat.name}</ChatName>\n ┊ 97┊ 97┊              {chat.lastMessage && (\n ┊ 98┊ 98┊                <React.Fragment>\n-┊ 99┊   ┊                  <MessageContent>{chat.lastMessage.content}</MessageContent>\n-┊100┊   ┊                  <MessageDate>{moment(chat.lastMessage.createdAt).format('HH:mm')}</MessageDate>\n+┊   ┊ 99┊                  <MessageContent data-testid=\"content\">{chat.lastMessage.content}</MessageContent>\n+┊   ┊100┊                  <MessageDate data-testid=\"date\">{moment(chat.lastMessage.createdAt).format('HH:mm')}</MessageDate>\n ┊101┊101┊                </React.Fragment>\n ┊102┊102┊              )}\n ┊103┊103┊            </ChatInfo>\n```\n\n[}]: #\n\nNow we can select various HTML elements with a query selector when we test the component. We will install a couple of packages that will assist us in implementing the test:\n\n  $ npm install jest-fetch-mock jest-dom react-testing-library\n\n- The [`jest-fetch-mock`](https://www.npmjs.com/package/jest-fetch-mock) package can mock responses emitted by the Fetch API.\n- The [`jest-dom`](https://www.npmjs.com/package/jsdom) package will add custom matchers that will help us examine HTML contents of DOM elements.\n- The [`react-testing-library`](https://www.npmjs.com/package/react-testing-library) package contains utility methods that will help us test React.Components with Jest.\n\nNext, we will create a file under the `src` folder called `setupTests.ts`. This file is loaded configured automatically by `create-react-app` and loaded by Jest, and we can use it to set up our testing environment according to our needs (like said earlier, Jest can be configured, so this file path can be changed). We will use that file to define a fake Fetch API using the `jest-fetch-mock` library:\n\n[{]: <helper> (diffStep \"5.2\" files=\"src/setupTests.ts\" module=\"client\")\n\n#### [Step 5.2: Setup tests](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/07699a6)\n\n##### Added src&#x2F;setupTests.ts\n```diff\n@@ -0,0 +1,7 @@\n+┊ ┊1┊import 'jest-dom/extend-expect'\n+┊ ┊2┊import { GlobalWithFetchMock } from 'jest-fetch-mock'\n+┊ ┊3┊import { act } from 'react-testing-library'\n+┊ ┊4┊\n+┊ ┊5┊const customGlobal: GlobalWithFetchMock = global as GlobalWithFetchMock\n+┊ ┊6┊customGlobal.fetch = require('jest-fetch-mock')\n+┊ ┊7┊customGlobal.fetchMock = customGlobal.fetch\n```\n\n[}]: #\n\nWe will create another file called `ChatsList.test.tsx`, right next to the `<ChatsList />` component under the `ChatsListScreen` directory, and inside we will implement our test. The test should follow these steps:\n\n- Mock the response to contain a fake chat, so we won't need to make an actual call to our GraphQL API.\n- We will create a new instance of `<ChatsList />` and render it in a container element.\n- We will wait for changes in the DOM caused by `setState()`.\n- We will test the contents of the container.\n\nAnd this is how the implementation should look like:\n\n[{]: <helper> (diffStep \"5.3\" files=\"src/components/ChatsListScreen/ChatsList.test.tsx\" module=\"client\")\n\n#### [Step 5.3: Test ChatsList](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/ce389d9)\n\n##### Added src&#x2F;components&#x2F;ChatsListScreen&#x2F;ChatsList.test.tsx\n```diff\n@@ -0,0 +1,38 @@\n+┊  ┊ 1┊import React from 'react'\n+┊  ┊ 2┊import ReactDOM from 'react-dom'\n+┊  ┊ 3┊import { cleanup, render, waitForDomChange } from 'react-testing-library'\n+┊  ┊ 4┊import ChatsList from './ChatsList'\n+┊  ┊ 5┊\n+┊  ┊ 6┊describe('ChatsList', () => {\n+┊  ┊ 7┊  afterEach(cleanup)\n+┊  ┊ 8┊\n+┊  ┊ 9┊  it('renders fetched chats data', async () => {\n+┊  ┊10┊    fetch.mockResponseOnce(JSON.stringify({\n+┊  ┊11┊      data: {\n+┊  ┊12┊        chats: [\n+┊  ┊13┊          {\n+┊  ┊14┊            id: 1,\n+┊  ┊15┊            name: 'Foo Bar',\n+┊  ┊16┊            picture: 'https://localhost:4000/picture.jpg',\n+┊  ┊17┊            lastMessage: {\n+┊  ┊18┊              id: 1,\n+┊  ┊19┊              content: 'Hello',\n+┊  ┊20┊              createdAt: new Date(0),\n+┊  ┊21┊            },\n+┊  ┊22┊          },\n+┊  ┊23┊        ],\n+┊  ┊24┊      },\n+┊  ┊25┊    }))\n+┊  ┊26┊\n+┊  ┊27┊    {\n+┊  ┊28┊      const { container, getByTestId } = render(<ChatsList />)\n+┊  ┊29┊\n+┊  ┊30┊      await waitForDomChange({ container })\n+┊  ┊31┊\n+┊  ┊32┊      expect(getByTestId('name')).toHaveTextContent('Foo Bar')\n+┊  ┊33┊      expect(getByTestId('picture')).toHaveAttribute('src', 'https://localhost:4000/picture.jpg')\n+┊  ┊34┊      expect(getByTestId('content')).toHaveTextContent('Hello')\n+┊  ┊35┊      expect(getByTestId('date')).toHaveTextContent('08:00')\n+┊  ┊36┊    }\n+┊  ┊37┊  })\n+┊  ┊38┊})\n```\n\n[}]: #\n\n> Jest API is vast but pretty intuitive for the most part. It mostly consists of test descriptors and matchers. [Here's a full list of all matchers which are built into Jest's API](https://jestjs.io/docs/en/expect). Always make sure to work against it when writing tests, for optimal results.\n\nWe will now move on to testing the server where we will learn how to setup Jest manually and test it against a GraphQL API.\n\n**Server - Testing GraphQL resolvers**\n\nTo set-up Jest, we will run the following in the command line:\n\n    $ npm install jest @types/jest ts-jest --dev\n\nThis will basically install Jest and make it useable with TypeScript. In addition, we will need to specify the file pattern that we would like to transform with [`ts-jest`](https://www.npmjs.com/package/ts-jest), by adding the following section to `package.json`:\n\n```\n{\n  \"jest\": {\n    \"transform\": {\n      \"^.+\\\\.(js|jsx|ts|tsx)$\": \"<rootDir>/node_modules/ts-jest\"\n    }\n  }\n}\n```\n\nWe will also add a `\"test\"` script in the `package.json` file, so we can run the tests with `$ npm run test` (or `$ yarn test`):\n\n```\n{\n  \"scripts\": {\n    \"test\": \"jest\"\n  }\n}\n```\n\nThis is how our `package.json` should look like at this point:\n\n[{]: <helper> (diffStep \"3.1\" files=\"package.json\" module=\"server\")\n\n#### [Step 3.1: Install and configure Jest](https://github.com/Urigo/WhatsApp-Clone-Server/commit/3de9ad9)\n\n##### Changed package.json\n```diff\n@@ -7,7 +7,8 @@\n ┊ 7┊ 7┊  },\n ┊ 8┊ 8┊  \"private\": true,\n ┊ 9┊ 9┊  \"scripts\": {\n-┊10┊  ┊    \"start\": \"ts-node index.ts\"\n+┊  ┊10┊    \"start\": \"ts-node index.ts\",\n+┊  ┊11┊    \"test\": \"jest\"\n ┊11┊12┊  },\n ┊12┊13┊  \"devDependencies\": {\n ┊13┊14┊    \"@types/body-parser\": \"1.17.0\",\n```\n```diff\n@@ -15,7 +16,10 @@\n ┊15┊16┊    \"@types/express\": \"4.16.1\",\n ┊16┊17┊    \"@types/graphql\": \"14.0.7\",\n ┊17┊18┊    \"@types/graphql-iso-date\": \"3.3.1\",\n+┊  ┊19┊    \"@types/jest\": \"24.0.11\",\n ┊18┊20┊    \"@types/node\": \"11.11.0\",\n+┊  ┊21┊    \"ts-jest\": \"24.0.0\",\n+┊  ┊22┊    \"jest\": \"24.5.0\",\n ┊19┊23┊    \"ts-node\": \"8.0.3\",\n ┊20┊24┊    \"typescript\": \"3.3.3333\"\n ┊21┊25┊  },\n```\n```diff\n@@ -28,5 +32,10 @@\n ┊28┊32┊    \"graphql-import\": \"0.7.1\",\n ┊29┊33┊    \"graphql-iso-date\": \"3.6.1\",\n ┊30┊34┊    \"graphql-tools\": \"4.0.4\"\n+┊  ┊35┊  },\n+┊  ┊36┊  \"jest\": {\n+┊  ┊37┊    \"transform\": {\n+┊  ┊38┊      \"^.+\\\\.(js|jsx|ts|tsx)$\": \"<rootDir>/node_modules/ts-jest\"\n+┊  ┊39┊    }\n ┊31┊40┊  }\n ┊32┊41┊}\n```\n\n[}]: #\n\nNow we're gonna test the `chats` query in our GraphQL schema. To do so, we will setup an Apollo Client and send a query request to our back-end, and then we will match the received response with a pre-defined snapshot. Luckily, we don't have to set an actual client, since the tests and the implementation of the back-end live right next to each other, thus, we will install a package which will help us achieving so:\n\n    $ npm install apollo-server-testing --dev\n\nWe will define the test suite under the `tests/queries` folder in a file called `getChats.test.ts`:\n\n[{]: <helper> (diffStep \"3.2\" files=\"tests/queries/getChats.test.ts\" module=\"server\")\n\n#### [Step 3.2: Test Query.chats](https://github.com/Urigo/WhatsApp-Clone-Server/commit/818de95)\n\n##### Added tests&#x2F;queries&#x2F;getChats.test.ts\n```diff\n@@ -0,0 +1,32 @@\n+┊  ┊ 1┊import { createTestClient } from 'apollo-server-testing'\n+┊  ┊ 2┊import { ApolloServer, gql } from 'apollo-server-express'\n+┊  ┊ 3┊import schema from '../../schema'\n+┊  ┊ 4┊\n+┊  ┊ 5┊describe('Query.chats', () => {\n+┊  ┊ 6┊  it('should fetch all chats', async () => {\n+┊  ┊ 7┊    const server = new ApolloServer({ schema })\n+┊  ┊ 8┊\n+┊  ┊ 9┊    const { query } = createTestClient(server)\n+┊  ┊10┊\n+┊  ┊11┊    const res = await query({\n+┊  ┊12┊      query: gql `\n+┊  ┊13┊        query GetChats {\n+┊  ┊14┊          chats {\n+┊  ┊15┊            id\n+┊  ┊16┊            name\n+┊  ┊17┊            picture\n+┊  ┊18┊            lastMessage {\n+┊  ┊19┊              id\n+┊  ┊20┊              content\n+┊  ┊21┊              createdAt\n+┊  ┊22┊            }\n+┊  ┊23┊          }\n+┊  ┊24┊        }\n+┊  ┊25┊      `,\n+┊  ┊26┊    })\n+┊  ┊27┊\n+┊  ┊28┊    expect(res.data).toBeDefined()\n+┊  ┊29┊    expect(res.errors).toBeUndefined()\n+┊  ┊30┊    expect(res.data).toMatchSnapshot()\n+┊  ┊31┊  })\n+┊  ┊32┊})\n```\n\n[}]: #\n\nIn the test function, we create a new instance of the Apollo-GraphQL server using our schema, and we query some data against it thanks to the fake client created by [`apollo-server-testing`](https://www.npmjs.com/package/apollo-server-testing).\n\nThe `.toMatchSnapshot()` matcher will call the `toString()` method on the examined object and will test it against a predefined snapshot. The snapshot will automatically be created once we run the test for the first time and will be stored under the `__snapshot__` directory. This means that the first test run will always pass. This is useful because you can later on observe and adjust manually the snapshot manually without having to write it from scratch. The expected result should be a projection of the data stored in the `db.ts` file.\n\n[{]: <helper> (diffStep \"3.2\" files=\"tests/queries/__snapshots__\" module=\"server\")\n\n#### [Step 3.2: Test Query.chats](https://github.com/Urigo/WhatsApp-Clone-Server/commit/818de95)\n\n##### Added tests&#x2F;queries&#x2F;__snapshots__&#x2F;getChats.test.ts.snap\n```diff\n@@ -0,0 +1,48 @@\n+┊  ┊ 1┊// Jest Snapshot v1, https://goo.gl/fbAQLP\n+┊  ┊ 2┊\n+┊  ┊ 3┊exports[`Query.chats should fetch all chats 1`] = `\n+┊  ┊ 4┊Object {\n+┊  ┊ 5┊  \"chats\": Array [\n+┊  ┊ 6┊    Object {\n+┊  ┊ 7┊      \"id\": \"1\",\n+┊  ┊ 8┊      \"lastMessage\": Object {\n+┊  ┊ 9┊        \"content\": \"You on your way?\",\n+┊  ┊10┊        \"createdAt\": \"2018-12-30T23:20:00.000Z\",\n+┊  ┊11┊        \"id\": \"1\",\n+┊  ┊12┊      },\n+┊  ┊13┊      \"name\": \"Ethan Gonzalez\",\n+┊  ┊14┊      \"picture\": \"https://randomuser.me/api/portraits/thumb/men/1.jpg\",\n+┊  ┊15┊    },\n+┊  ┊16┊    Object {\n+┊  ┊17┊      \"id\": \"2\",\n+┊  ┊18┊      \"lastMessage\": Object {\n+┊  ┊19┊        \"content\": \"Hey, it's me\",\n+┊  ┊20┊        \"createdAt\": \"2018-12-30T06:40:00.000Z\",\n+┊  ┊21┊        \"id\": \"2\",\n+┊  ┊22┊      },\n+┊  ┊23┊      \"name\": \"Bryan Wallace\",\n+┊  ┊24┊      \"picture\": \"https://randomuser.me/api/portraits/thumb/men/2.jpg\",\n+┊  ┊25┊    },\n+┊  ┊26┊    Object {\n+┊  ┊27┊      \"id\": \"3\",\n+┊  ┊28┊      \"lastMessage\": Object {\n+┊  ┊29┊        \"content\": \"I should buy a boat\",\n+┊  ┊30┊        \"createdAt\": \"2018-12-15T00:00:00.000Z\",\n+┊  ┊31┊        \"id\": \"3\",\n+┊  ┊32┊      },\n+┊  ┊33┊      \"name\": \"Avery Stewart\",\n+┊  ┊34┊      \"picture\": \"https://randomuser.me/api/portraits/thumb/women/1.jpg\",\n+┊  ┊35┊    },\n+┊  ┊36┊    Object {\n+┊  ┊37┊      \"id\": \"4\",\n+┊  ┊38┊      \"lastMessage\": Object {\n+┊  ┊39┊        \"content\": \"This is wicked good ice cream.\",\n+┊  ┊40┊        \"createdAt\": \"2018-05-12T08:00:00.000Z\",\n+┊  ┊41┊        \"id\": \"4\",\n+┊  ┊42┊      },\n+┊  ┊43┊      \"name\": \"Katie Peterson\",\n+┊  ┊44┊      \"picture\": \"https://randomuser.me/api/portraits/thumb/women/2.jpg\",\n+┊  ┊45┊    },\n+┊  ┊46┊  ],\n+┊  ┊47┊}\n+┊  ┊48┊`;\n```\n\n[}]: #\n\nAlways be sure to observe the snapshot before moving on! The received result isn't necessarily what you'd expect. Also it's not a good practice to store production data in the snapshot because it's subject to changes. Normally we would set up another instance of the DB for testing purposes, but since our DB is a mock and doesn't represent real data, there's no need to at this stage.\n\nNow that we have the required knowledge regards testing and Jest's API, we will implement tests throughout the tutorial as a trivial thing. We will not go through each and every new matcher that we introduce, as it is self explanatory and there's too much of them. Be sure to work against [this full list of matchers](https://jestjs.io/docs/en/expect) when working with Jest.\n\nIn the next chapter we will continue expanding our application by adding a `<ChatRoomScreen />`."
          },
          {
            "manualTitle": "Step 6: Creating an app router and implementing a chat room",
            "stepRevision": "75567403ed0e92cbb6c4810baa5182ee27302432",
            "manualView": "In this chapter we will learn how to build a chat room screen. We will setup a router, implement the necessary components, and update the state whenever we send a new message. The screen is NOT gonna be connected to the back-end as it will over complicate things for now. Further this tutorial, we will get to make it full-stack.\n\nSince we're gonna have to screens in our app now - `ChatsListScreen` and `ChatRoomScreen`, we will need a router that will be able to alternate between them. We will be using the [`react-router-dom`](https://www.npmjs.com/package/react-router-dom) package to manage the routes of the application:\n\n  $ npm install react-router-dom\n\nAnd we will implement a router directly in the `<App />` component:\n\n[{]: <helper> (diffStep 6.1 files=\"App\" module=\"client\")\n\n#### [Step 6.1: Add router](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/7f46257)\n\n##### Changed src&#x2F;App.jsx\n```diff\n@@ -1,10 +1,20 @@\n ┊ 1┊ 1┊import * as React from 'react'\n+┊  ┊ 2┊import { BrowserRouter, Route, Redirect, Switch } from 'react-router-dom'\n+┊  ┊ 3┊import ChatRoomScreen from './components/ChatRoomScreen'\n ┊ 2┊ 4┊import ChatsListScreen from './components/ChatsListScreen'\n ┊ 3┊ 5┊\n ┊ 4┊ 6┊const App = () => (\n-┊ 5┊  ┊  <div>\n-┊ 6┊  ┊    <ChatsListScreen />\n-┊ 7┊  ┊  </div>\n+┊  ┊ 7┊  <BrowserRouter>\n+┊  ┊ 8┊    <Switch>\n+┊  ┊ 9┊      <Route exact path=\"/chats\" component={ChatsListScreen} />\n+┊  ┊10┊      <Route exact path=\"/chats/:chatId\" component={ChatRoomScreen} />\n+┊  ┊11┊    </Switch>\n+┊  ┊12┊    <Route exact path=\"/\" render={redirectToChats} />\n+┊  ┊13┊  </BrowserRouter>\n+┊  ┊14┊)\n+┊  ┊15┊\n+┊  ┊16┊const redirectToChats = () => (\n+┊  ┊17┊  <Redirect to=\"/chats\" />\n ┊ 8┊18┊)\n ┊ 9┊19┊\n ┊10┊20┊export default App\n```\n\n[}]: #\n\nThe purpose of a router is to make route managing easy and declarative. It will take care of managing the history within our app and parameterizing certain screens according to our need. Essentially it's a wrap around the `window.history` object which is also compatible with React. I recommend you to go through the [official MDN docs](https://developer.mozilla.org/en-US/docs/Web/API/History) if you're not yet familiar with the concept.\n\nThe `<Route />` component represents a path for a route in our application. Using the colon syntax (`:chatId`) we basically tell the router that the `/chat` route should be followed by a string whose value can later on be addressed via a parameter called `chatId` when navigating to the route. So here's a sum-up of the routes manifest:\n\n\n\n*   `/chats` - will navigate to the `ChatsListScreen`.\n*   `/chat/:chatId` - e.g. `/chat/1`, will navigate to the `ChatRoomScreen` and will parameterize it to show data which is related to chat ID 1.\n*   Any other route will fallback to the `/chats` route which will redirect us to the `ChatsListScreen`.\n\nNow we will implement the `ChatRoomScreen` so the router can function properly. For now we will make it a plain screen which simply prints out the information of the chat that was clicked so we can have a complete flow, and then we will take care of the rest.\n\nTo do so, we will first implement the `chat` query in our backend. This would be a parameterized query that will provide us with a specific chat according to the received ID, and it will be used by the new screen as soon as it is initialized. First we would update the `Chat` type to contain a `messages` field:\n\n[{]: <helper> (diffStep 4.1 files=\"schema\" module=\"server\")\n\n#### [Step 4.1: Add messages field to Chat type](https://github.com/Urigo/WhatsApp-Clone-Server/commit/a956ba7)\n\n##### Changed schema&#x2F;resolvers.ts\n```diff\n@@ -5,6 +5,10 @@\n ┊ 5┊ 5┊  Date: GraphQLDateTime,\n ┊ 6┊ 6┊\n ┊ 7┊ 7┊  Chat: {\n+┊  ┊ 8┊    messages(chat: any) {\n+┊  ┊ 9┊      return messages.filter(m => chat.messages.includes(m.id))\n+┊  ┊10┊    },\n+┊  ┊11┊\n ┊ 8┊12┊    lastMessage(chat: any) {\n ┊ 9┊13┊      return messages.find(m => m.id === chat.lastMessage)\n ┊10┊14┊    },\n```\n\n##### Changed schema&#x2F;typeDefs.graphql\n```diff\n@@ -11,6 +11,7 @@\n ┊11┊11┊  name: String!\n ┊12┊12┊  picture: String\n ┊13┊13┊  lastMessage: Message\n+┊  ┊14┊  messages: [Message!]!\n ┊14┊15┊}\n ┊15┊16┊\n ┊16┊17┊type Query {\n```\n\n[}]: #\n\nAnd then we will update our DB mock to be aligned with these changes:\n\n[{]: <helper> (diffStep 4.1 files=\"db\" module=\"server\")\n\n#### [Step 4.1: Add messages field to Chat type](https://github.com/Urigo/WhatsApp-Clone-Server/commit/a956ba7)\n\n##### Changed db.ts\n```diff\n@@ -27,23 +27,27 @@\n ┊27┊27┊    name: 'Ethan Gonzalez',\n ┊28┊28┊    picture: 'https://randomuser.me/api/portraits/thumb/men/1.jpg',\n ┊29┊29┊    lastMessage: '1',\n+┊  ┊30┊    messages: ['1'],\n ┊30┊31┊  },\n ┊31┊32┊  {\n ┊32┊33┊    id: '2',\n ┊33┊34┊    name: 'Bryan Wallace',\n ┊34┊35┊    picture: 'https://randomuser.me/api/portraits/thumb/men/2.jpg',\n ┊35┊36┊    lastMessage: '2',\n+┊  ┊37┊    messages: ['2'],\n ┊36┊38┊  },\n ┊37┊39┊  {\n ┊38┊40┊    id: '3',\n ┊39┊41┊    name: 'Avery Stewart',\n ┊40┊42┊    picture: 'https://randomuser.me/api/portraits/thumb/women/1.jpg',\n ┊41┊43┊    lastMessage: '3',\n+┊  ┊44┊    messages: ['3'],\n ┊42┊45┊  },\n ┊43┊46┊  {\n ┊44┊47┊    id: '4',\n ┊45┊48┊    name: 'Katie Peterson',\n ┊46┊49┊    picture: 'https://randomuser.me/api/portraits/thumb/women/2.jpg',\n ┊47┊50┊    lastMessage: '4',\n+┊  ┊51┊    messages: ['4'],\n ┊48┊52┊  },\n ┊49┊53┊]\n```\n\n[}]: #\n\nThis means that when we resolve `Chat.lastMessage`, we should get it directly from the `Chat.messages` field:\n\n[{]: <helper> (diffStep 4.2 module=\"server\")\n\n#### [Step 4.2: Resolve last message based on messages array](https://github.com/Urigo/WhatsApp-Clone-Server/commit/3672e75)\n\n##### Changed db.ts\n```diff\n@@ -26,28 +26,24 @@\n ┊26┊26┊    id: '1',\n ┊27┊27┊    name: 'Ethan Gonzalez',\n ┊28┊28┊    picture: 'https://randomuser.me/api/portraits/thumb/men/1.jpg',\n-┊29┊  ┊    lastMessage: '1',\n ┊30┊29┊    messages: ['1'],\n ┊31┊30┊  },\n ┊32┊31┊  {\n ┊33┊32┊    id: '2',\n ┊34┊33┊    name: 'Bryan Wallace',\n ┊35┊34┊    picture: 'https://randomuser.me/api/portraits/thumb/men/2.jpg',\n-┊36┊  ┊    lastMessage: '2',\n ┊37┊35┊    messages: ['2'],\n ┊38┊36┊  },\n ┊39┊37┊  {\n ┊40┊38┊    id: '3',\n ┊41┊39┊    name: 'Avery Stewart',\n ┊42┊40┊    picture: 'https://randomuser.me/api/portraits/thumb/women/1.jpg',\n-┊43┊  ┊    lastMessage: '3',\n ┊44┊41┊    messages: ['3'],\n ┊45┊42┊  },\n ┊46┊43┊  {\n ┊47┊44┊    id: '4',\n ┊48┊45┊    name: 'Katie Peterson',\n ┊49┊46┊    picture: 'https://randomuser.me/api/portraits/thumb/women/2.jpg',\n-┊50┊  ┊    lastMessage: '4',\n ┊51┊47┊    messages: ['4'],\n ┊52┊48┊  },\n ┊53┊49┊]\n```\n\n##### Changed schema&#x2F;resolvers.ts\n```diff\n@@ -10,7 +10,9 @@\n ┊10┊10┊    },\n ┊11┊11┊\n ┊12┊12┊    lastMessage(chat: any) {\n-┊13┊  ┊      return messages.find(m => m.id === chat.lastMessage)\n+┊  ┊13┊      const lastMessage = chat.messages[chat.messages.length - 1]\n+┊  ┊14┊\n+┊  ┊15┊      return messages.find(m => m.id === lastMessage)\n ┊14┊16┊    },\n ┊15┊17┊  },\n```\n\n[}]: #\n\nNow that we have an updated schema which is relevant to the new screen that we would like to add, we will declare a new query called `chat`:\n\n[{]: <helper> (diffStep 4.3 files=\"schema/typeDefs\" module=\"server\")\n\n#### [Step 4.3: Add chat field to Query type](https://github.com/Urigo/WhatsApp-Clone-Server/commit/f803126)\n\n##### Changed schema&#x2F;typeDefs.graphql\n```diff\n@@ -16,4 +16,5 @@\n ┊16┊16┊\n ┊17┊17┊type Query {\n ┊18┊18┊  chats: [Chat!]!\n+┊  ┊19┊  chat(chatId: ID!): Chat\n ┊19┊20┊}\n```\n\n[}]: #\n\nNote that unlike the `chats` query, this time we have a parameter. The parameters are provided to the resolver function as the second parameter as a JSON. Using the provided parameter - the chat ID, we will find and return the relevant chat from the DB:\n\n[{]: <helper> (diffStep 4.3 files=\"schema/resolvers\" module=\"server\")\n\n#### [Step 4.3: Add chat field to Query type](https://github.com/Urigo/WhatsApp-Clone-Server/commit/f803126)\n\n##### Changed schema&#x2F;resolvers.ts\n```diff\n@@ -20,6 +20,10 @@\n ┊20┊20┊    chats() {\n ┊21┊21┊      return chats\n ┊22┊22┊    },\n+┊  ┊23┊\n+┊  ┊24┊    chat(root: any, { chatId }: any) {\n+┊  ┊25┊      return chats.find(c => c.id === chatId)\n+┊  ┊26┊    },\n ┊23┊27┊  },\n ┊24┊28┊}\n ┊25┊29┊\n```\n\n[}]: #\n\n> More about the resolver signature can be read in [Apollo-GraphQL's official docs page](https://www.apollographql.com/docs/apollo-server/essentials/data.html#type-signature).\n\nNow we will add a test suite:\n\n[{]: <helper> (diffStep 4.3 files=\"tests/queries/getChat.test\" module=\"server\")\n\n#### [Step 4.3: Add chat field to Query type](https://github.com/Urigo/WhatsApp-Clone-Server/commit/f803126)\n\n##### Added tests&#x2F;queries&#x2F;getChat.test.ts\n```diff\n@@ -0,0 +1,33 @@\n+┊  ┊ 1┊import { createTestClient } from 'apollo-server-testing'\n+┊  ┊ 2┊import { ApolloServer, gql } from 'apollo-server-express'\n+┊  ┊ 3┊import schema from '../../schema'\n+┊  ┊ 4┊\n+┊  ┊ 5┊describe('Query.chat', () => {\n+┊  ┊ 6┊  it('should fetch specified chat', async () => {\n+┊  ┊ 7┊    const server = new ApolloServer({ schema })\n+┊  ┊ 8┊\n+┊  ┊ 9┊    const { query } = createTestClient(server)\n+┊  ┊10┊\n+┊  ┊11┊    const res = await query({\n+┊  ┊12┊      variables: { chatId: '1' },\n+┊  ┊13┊      query: gql `\n+┊  ┊14┊        query GetChat($chatId: ID!) {\n+┊  ┊15┊          chat(chatId: $chatId) {\n+┊  ┊16┊            id\n+┊  ┊17┊            name\n+┊  ┊18┊            picture\n+┊  ┊19┊            lastMessage {\n+┊  ┊20┊              id\n+┊  ┊21┊              content\n+┊  ┊22┊              createdAt\n+┊  ┊23┊            }\n+┊  ┊24┊          }\n+┊  ┊25┊        }\n+┊  ┊26┊      `,\n+┊  ┊27┊    })\n+┊  ┊28┊\n+┊  ┊29┊    expect(res.data).toBeDefined()\n+┊  ┊30┊    expect(res.errors).toBeUndefined()\n+┊  ┊31┊    expect(res.data).toMatchSnapshot()\n+┊  ┊32┊  })\n+┊  ┊33┊})\n```\n\n[}]: #\n\nWe can observe the snapshot created by Jest to get a better understanding of how the response should look like:\n\n[{]: <helper> (diffStep 4.3 files=\"__snapshot__\" module=\"server\")\n\n#### [Step 4.3: Add chat field to Query type](https://github.com/Urigo/WhatsApp-Clone-Server/commit/f803126)\n\n\n\n[}]: #\n\nIf you experience any TypeScript related issues with the following error:\n\n```\nObject literal may only specify known properties, and 'variables' does not exist in type 'Query'.\n```\n\nAdd the following declaration file to your project:\n\n[{]: <helper> (diffStep 4.3 files=\"types\" module=\"server\")\n\n#### [Step 4.3: Add chat field to Query type](https://github.com/Urigo/WhatsApp-Clone-Server/commit/f803126)\n\n##### Added types&#x2F;apollo-server-testing.d.ts\n```diff\n@@ -0,0 +1,27 @@\n+┊  ┊ 1┊declare module 'apollo-server-testing' {\n+┊  ┊ 2┊  import { ApolloServerBase } from 'apollo-server-core';\n+┊  ┊ 3┊  import { print, DocumentNode } from 'graphql';\n+┊  ┊ 4┊  import { GraphQLResponse } from 'graphql-extensions';\n+┊  ┊ 5┊\n+┊  ┊ 6┊  type StringOrAst = string | DocumentNode;\n+┊  ┊ 7┊\n+┊  ┊ 8┊  // A query must not come with a mutation (and vice versa).\n+┊  ┊ 9┊  type Query<TVariables> = {\n+┊  ┊10┊    query: StringOrAst;\n+┊  ┊11┊    mutation?: undefined;\n+┊  ┊12┊    variables?: TVariables;\n+┊  ┊13┊  };\n+┊  ┊14┊\n+┊  ┊15┊  type Mutation<TVariables> = {\n+┊  ┊16┊    mutation: StringOrAst;\n+┊  ┊17┊    query?: undefined;\n+┊  ┊18┊    variables?: TVariables;\n+┊  ┊19┊  };\n+┊  ┊20┊\n+┊  ┊21┊  export const createTestClient: <TVariables>(\n+┊  ┊22┊    server: ApolloServerBase,\n+┊  ┊23┊  ) => {\n+┊  ┊24┊    query: (query: Query<TVariables>) => Promise<GraphQLResponse>;\n+┊  ┊25┊    mutate: (mutation: Mutation<TVariables>) => Promise<GraphQLResponse>;\n+┊  ┊26┊  };\n+┊  ┊27┊}\n```\n\n[}]: #\n\nThis is a [known issue](https://github.com/apollographql/apollo-server/issues/2172) in the `apollo-server-testing` package and has a pending [fix PR](https://github.com/apollographql/apollo-server/pull/2307). Now getting back to the client, let's implement a basic version of the `ChatRoomScreen` where we will fetch the new query and print it to the screen:\n\n[{]: <helper> (diffStep 6.2 module=\"client\")\n\n#### [Step 6.2: Add basic ChatRoomScreen](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/1809f98)\n\n##### Added src&#x2F;components&#x2F;ChatRoomScreen&#x2F;index.tsx\n```diff\n@@ -0,0 +1,55 @@\n+┊  ┊ 1┊import * as React from 'react'\n+┊  ┊ 2┊import { useMemo, useState } from 'react'\n+┊  ┊ 3┊\n+┊  ┊ 4┊const getChatQuery = `\n+┊  ┊ 5┊  query GetChat($chatId: ID!) {\n+┊  ┊ 6┊    chat(chatId: $chatId) {\n+┊  ┊ 7┊      id\n+┊  ┊ 8┊      name\n+┊  ┊ 9┊      picture\n+┊  ┊10┊      messages {\n+┊  ┊11┊        id\n+┊  ┊12┊        content\n+┊  ┊13┊        createdAt\n+┊  ┊14┊      }\n+┊  ┊15┊    }\n+┊  ┊16┊  }\n+┊  ┊17┊`\n+┊  ┊18┊\n+┊  ┊19┊const ChatRoomScreen = ({ match }) => {\n+┊  ┊20┊  const { params: { chatId } } = match\n+┊  ┊21┊  const [chat, setChat] = useState(null)\n+┊  ┊22┊\n+┊  ┊23┊  useMemo(async () => {\n+┊  ┊24┊    const body = await fetch(`${process.env.REACT_APP_SERVER_URL}/graphql`, {\n+┊  ┊25┊      method: 'POST',\n+┊  ┊26┊      headers: {\n+┊  ┊27┊        'Content-Type': 'application/json',\n+┊  ┊28┊      },\n+┊  ┊29┊      body: JSON.stringify({\n+┊  ┊30┊        query: getChatQuery,\n+┊  ┊31┊        variables: { chatId },\n+┊  ┊32┊      }),\n+┊  ┊33┊    })\n+┊  ┊34┊    const { data: { chat } } = await body.json()\n+┊  ┊35┊    setChat(chat)\n+┊  ┊36┊  }, [true])\n+┊  ┊37┊\n+┊  ┊38┊  if (!chat) return null\n+┊  ┊39┊\n+┊  ┊40┊  return (\n+┊  ┊41┊    <div>\n+┊  ┊42┊      <img src={chat.picture} /><div>{chat.name}</div>\n+┊  ┊43┊      <ul>\n+┊  ┊44┊        {chat.messages.map((message) =>\n+┊  ┊45┊          <li key={message.id}>\n+┊  ┊46┊            <div>{message.content}</div>\n+┊  ┊47┊            <div>{message.createdAt}</div>\n+┊  ┊48┊          </li>\n+┊  ┊49┊        )}\n+┊  ┊50┊      </ul>\n+┊  ┊51┊    </div>\n+┊  ┊52┊  )\n+┊  ┊53┊}\n+┊  ┊54┊\n+┊  ┊55┊export default ChatRoomScreen\n```\n\n[}]: #\n\nNote how we used the `match.params.chatId` variable to get the selected chat ID. The `match` prop is defined and provided to us by the `<Route />` component, since it interfaces directly with the `ChatRoomScreen`. More about that can be read in the [official docs page](https://reacttraining.com/react-router/core/api/match). If you'll run the application and type `/chats/1` in the URL bar, this is what you should see on the screen:\n\n![naked-chat](https://user-images.githubusercontent.com/7648874/54664314-d4096b80-4b1e-11e9-9e06-1323cf7b0abe.png)\n\nThe view has no styling at all but it should be fixed in a moment. To make navigation more convenient we will add an `onClick` listener for each chat item in the `ChatsList`. Using the [history](https://reacttraining.com/react-router/core/api/history) object, provided to us by the `<Route />` component, we will navigate to the correlated `ChatRoomScreen`:\n\n[{]: <helper> (diffStep 6.3 module=\"client\")\n\n#### [Step 6.3: Nav to chat on click](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/95c0c4b)\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;ChatsList.tsx\n```diff\n@@ -1,7 +1,7 @@\n ┊1┊1┊import { List, ListItem } from '@material-ui/core'\n ┊2┊2┊import moment from 'moment'\n ┊3┊3┊import * as React from 'react'\n-┊4┊ ┊import { useState, useMemo } from 'react'\n+┊ ┊4┊import { useCallback, useState, useMemo } from 'react'\n ┊5┊5┊import styled from 'styled-components'\n ┊6┊6┊\n ┊7┊7┊const Container = styled.div `\n```\n```diff\n@@ -71,7 +71,7 @@\n ┊71┊71┊  }\n ┊72┊72┊`\n ┊73┊73┊\n-┊74┊  ┊const ChatsList = () => {\n+┊  ┊74┊const ChatsList = ({ history }) => {\n ┊75┊75┊  const [chats, setChats] = useState([])\n ┊76┊76┊\n ┊77┊77┊  useMemo(async () => {\n```\n```diff\n@@ -86,11 +86,15 @@\n ┊ 86┊ 86┊    setChats(chats)\n ┊ 87┊ 87┊  }, [true])\n ┊ 88┊ 88┊\n+┊   ┊ 89┊  const navToChat = useCallback((chat) => {\n+┊   ┊ 90┊    history.push(`chats/${chat.id}`)\n+┊   ┊ 91┊  }, [true])\n+┊   ┊ 92┊\n ┊ 89┊ 93┊  return (\n ┊ 90┊ 94┊    <Container>\n ┊ 91┊ 95┊      <StyledList>\n ┊ 92┊ 96┊        {chats.map((chat) => (\n-┊ 93┊   ┊          <StyledListItem key={chat.id} button>\n+┊   ┊ 97┊          <StyledListItem key={chat.id} data-testid=\"chat\" button onClick={navToChat.bind(null, chat)}>\n ┊ 94┊ 98┊            <ChatPicture data-testid=\"picture\" src={chat.picture} />\n ┊ 95┊ 99┊            <ChatInfo>\n ┊ 96┊100┊              <ChatName data-testid=\"name\">{chat.name}</ChatName>\n```\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;index.tsx\n```diff\n@@ -7,10 +7,10 @@\n ┊ 7┊ 7┊  height: 100vh;\n ┊ 8┊ 8┊`\n ┊ 9┊ 9┊\n-┊10┊  ┊const ChatsListScreen = () => (\n+┊  ┊10┊const ChatsListScreen = ({ history }) => (\n ┊11┊11┊  <Container>\n ┊12┊12┊    <ChatsNavbar />\n-┊13┊  ┊    <ChatsList />\n+┊  ┊13┊    <ChatsList history={history} />\n ┊14┊14┊  </Container>\n ┊15┊15┊)\n```\n\n[}]: #\n\nAnd add test the new logic:\n\n[{]: <helper> (diffStep 6.4 module=\"client\")\n\n#### [Step 6.4: Test new navigation logic](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/65a540a)\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;ChatsList.test.tsx\n```diff\n@@ -1,10 +1,14 @@\n+┊  ┊ 1┊import { createBrowserHistory } from 'history'\n ┊ 1┊ 2┊import React from 'react'\n ┊ 2┊ 3┊import ReactDOM from 'react-dom'\n-┊ 3┊  ┊import { cleanup, render, waitForDomChange } from 'react-testing-library'\n+┊  ┊ 4┊import { cleanup, render, fireEvent, wait, waitForDomChange } from 'react-testing-library'\n ┊ 4┊ 5┊import ChatsList from './ChatsList'\n ┊ 5┊ 6┊\n ┊ 6┊ 7┊describe('ChatsList', () => {\n-┊ 7┊  ┊  afterEach(cleanup)\n+┊  ┊ 8┊  afterEach(() => {\n+┊  ┊ 9┊    cleanup()\n+┊  ┊10┊    window.location.pathname = '/'\n+┊  ┊11┊  })\n ┊ 8┊12┊\n ┊ 9┊13┊  it('renders fetched chats data', async () => {\n ┊10┊14┊    fetch.mockResponseOnce(JSON.stringify({\n```\n```diff\n@@ -35,4 +39,37 @@\n ┊35┊39┊      expect(getByTestId('date')).toHaveTextContent('08:00')\n ┊36┊40┊    }\n ┊37┊41┊  })\n+┊  ┊42┊\n+┊  ┊43┊  it('should navigate to the target chat room on chat item click', async () => {\n+┊  ┊44┊    fetch.mockResponseOnce(JSON.stringify({\n+┊  ┊45┊      data: {\n+┊  ┊46┊        chats: [\n+┊  ┊47┊          {\n+┊  ┊48┊            id: 1,\n+┊  ┊49┊            name: 'Foo Bar',\n+┊  ┊50┊            picture: 'https://localhost:4000/picture.jpg',\n+┊  ┊51┊            lastMessage: {\n+┊  ┊52┊              id: 1,\n+┊  ┊53┊              content: 'Hello',\n+┊  ┊54┊              createdAt: new Date(0),\n+┊  ┊55┊            },\n+┊  ┊56┊          },\n+┊  ┊57┊        ],\n+┊  ┊58┊      },\n+┊  ┊59┊    }))\n+┊  ┊60┊\n+┊  ┊61┊    const history = createBrowserHistory()\n+┊  ┊62┊\n+┊  ┊63┊    {\n+┊  ┊64┊      const { container, getByTestId } = render(<ChatsList history={history} />)\n+┊  ┊65┊\n+┊  ┊66┊      await waitForDomChange({ container })\n+┊  ┊67┊\n+┊  ┊68┊      fireEvent.click(getByTestId('chat'))\n+┊  ┊69┊\n+┊  ┊70┊      await wait(() =>\n+┊  ┊71┊        expect(history.location.pathname).toEqual('/chats/1')\n+┊  ┊72┊      )\n+┊  ┊73┊    }\n+┊  ┊74┊  })\n ┊38┊75┊})\n```\n\n[}]: #\n\nIf you'll click on the chat item you'll see that the screen changes very suddenly. We can smooth the transition by animating it with CSS. Luckily we don't need to implemented such mechanism manually because there's a package that can do that for us - [`react-router-transition`](https://www.npmjs.com/package/react-router-transition):\n\n  $ npm install react-router-transition\n\nUsing this package, we will create a custom `Switch` component that will play an animation for all its subordinate `Route` components. The animation is defined by the user using a component called `AnimatedSwitch` as specified in the [package's docs page](http://maisano.github.io/react-router-transition/animated-switch/props). So first, let's create our switch component that will play a smooth transition switching routes:\n\n[{]: <helper> (diffStep 6.5 files=\"AnimatedSwitch\" module=\"client\")\n\n#### [Step 6.5: Animate route switching](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/b2c0294)\n\n##### Added src&#x2F;components&#x2F;AnimatedSwitch.tsx\n```diff\n@@ -0,0 +1,37 @@\n+┊  ┊ 1┊import { Switch } from 'react-router-dom'\n+┊  ┊ 2┊import { AnimatedSwitch, spring } from 'react-router-transition'\n+┊  ┊ 3┊import styled from 'styled-components'\n+┊  ┊ 4┊\n+┊  ┊ 5┊// A workaround to make test pass\n+┊  ┊ 6┊const SwitchComponent = process.env.NODE_ENV === 'test' ? Switch : AnimatedSwitch\n+┊  ┊ 7┊\n+┊  ┊ 8┊const glide = val =>\n+┊  ┊ 9┊  spring(val, {\n+┊  ┊10┊    stiffness: 174,\n+┊  ┊11┊    damping: 24,\n+┊  ┊12┊  })\n+┊  ┊13┊\n+┊  ┊14┊const mapStyles = styles => ({\n+┊  ┊15┊  transform: `translateX(${styles.offset}%)`,\n+┊  ┊16┊})\n+┊  ┊17┊\n+┊  ┊18┊const MyAnimatedSwitch =  styled(SwitchComponent).attrs(() => ({\n+┊  ┊19┊  atEnter: { offset: 100 },\n+┊  ┊20┊  atLeave: { offset: glide(-100) },\n+┊  ┊21┊  atActive: { offset: glide(0) },\n+┊  ┊22┊  mapStyles,\n+┊  ┊23┊}))`\n+┊  ┊24┊  position: relative;\n+┊  ┊25┊  overflow: hidden;\n+┊  ┊26┊  height: 100vh;\n+┊  ┊27┊  width: 100vw;\n+┊  ┊28┊\n+┊  ┊29┊  > div {\n+┊  ┊30┊    position: absolute;\n+┊  ┊31┊    overflow: hidden;\n+┊  ┊32┊    height: 100vh;\n+┊  ┊33┊    width: 100vw;\n+┊  ┊34┊  }\n+┊  ┊35┊`\n+┊  ┊36┊\n+┊  ┊37┊export default MyAnimatedSwitch\n```\n\n[}]: #\n\nAnd then replace it with the main `Switch` component in our app:\n\n[{]: <helper> (diffStep 6.5 files=\"App\" module=\"client\")\n\n#### [Step 6.5: Animate route switching](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/b2c0294)\n\n##### Changed src&#x2F;App.jsx\n```diff\n@@ -1,14 +1,15 @@\n ┊ 1┊ 1┊import * as React from 'react'\n-┊ 2┊  ┊import { BrowserRouter, Route, Redirect, Switch } from 'react-router-dom'\n+┊  ┊ 2┊import { BrowserRouter, Route, Redirect } from 'react-router-dom'\n ┊ 3┊ 3┊import ChatRoomScreen from './components/ChatRoomScreen'\n ┊ 4┊ 4┊import ChatsListScreen from './components/ChatsListScreen'\n+┊  ┊ 5┊import AnimatedSwitch from './components/AnimatedSwitch'\n ┊ 5┊ 6┊\n ┊ 6┊ 7┊const App = () => (\n ┊ 7┊ 8┊  <BrowserRouter>\n-┊ 8┊  ┊    <Switch>\n+┊  ┊ 9┊    <AnimatedSwitch>\n ┊ 9┊10┊      <Route exact path=\"/chats\" component={ChatsListScreen} />\n ┊10┊11┊      <Route exact path=\"/chats/:chatId\" component={ChatRoomScreen} />\n-┊11┊  ┊    </Switch>\n+┊  ┊12┊    </AnimatedSwitch>\n ┊12┊13┊    <Route exact path=\"/\" render={redirectToChats} />\n ┊13┊14┊  </BrowserRouter>\n ┊14┊15┊)\n```\n\n[}]: #\n\nBoth components act identically and thus there shall be no special treatment. Behold the new transition effect:\n\n![transition-demo](https://user-images.githubusercontent.com/7648874/54739398-ebb22400-4bf2-11e9-8d4c-2aeb65deeb92.gif)\n\nThe final screen will be composed out of 3 components:\n\n\n\n*   A navigation bar.\n*   A messages list.\n*   A message input.\n\nWe will create a new directory under the path `public/assets` and inside we will download and place a couple of assets which are necessary for our view:\n\n*   [chat-background.jpg](https://raw.githubusercontent.com/Urigo/WhatsApp-Clone-Client-Angular/master/src/assets/chat-background.jpg)\n*   [message-mine.png](https://raw.githubusercontent.com/Urigo/WhatsApp-Clone-Client-Angular/master/src/assets/message-mine.png)\n\nIn the main `index.ts` file of the screen we will simply import all 3 in the right order. We will start with the most simple one - the `ChatRoomNavbar`. The navbar should show the picture of the chat we're currently at and its name, along with a back button that will bring us back to the `ChatsListScreen`:\n\n[{]: <helper> (diffStep 6.6 files=\"ChatNavbar\" module=\"client\")\n\n#### [Step 6.6: Implement ChatRoomScreen components](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/4c8f2bc)\n\n##### Added src&#x2F;components&#x2F;ChatRoomScreen&#x2F;ChatNavbar.tsx\n```diff\n@@ -0,0 +1,52 @@\n+┊  ┊ 1┊import Button from '@material-ui/core/Button'\n+┊  ┊ 2┊import Toolbar from '@material-ui/core/Toolbar'\n+┊  ┊ 3┊import ArrowBackIcon from '@material-ui/icons/ArrowBack'\n+┊  ┊ 4┊import * as React from 'react'\n+┊  ┊ 5┊import { useCallback, useState } from 'react'\n+┊  ┊ 6┊import styled from 'styled-components'\n+┊  ┊ 7┊\n+┊  ┊ 8┊const Container = styled(Toolbar) `\n+┊  ┊ 9┊  padding: 0;\n+┊  ┊10┊  display: flex;\n+┊  ┊11┊  flex-direction: row;\n+┊  ┊12┊  background-color: var(--primary-bg);\n+┊  ┊13┊  color: var(--primary-text);\n+┊  ┊14┊`\n+┊  ┊15┊\n+┊  ┊16┊const BackButton = styled(Button) `\n+┊  ┊17┊  svg {\n+┊  ┊18┊    color: var(--primary-text);\n+┊  ┊19┊  }\n+┊  ┊20┊`\n+┊  ┊21┊\n+┊  ┊22┊const Picture = styled.img `\n+┊  ┊23┊  height: 40px;\n+┊  ┊24┊  width: 40px;\n+┊  ┊25┊  margin-top: 3px;\n+┊  ┊26┊  margin-left: -22px;\n+┊  ┊27┊  object-fit: cover;\n+┊  ┊28┊  padding: 5px;\n+┊  ┊29┊  border-radius: 50%;\n+┊  ┊30┊`\n+┊  ┊31┊\n+┊  ┊32┊const Title = styled.div `\n+┊  ┊33┊  line-height: 56px;\n+┊  ┊34┊`\n+┊  ┊35┊\n+┊  ┊36┊const ChatNavbar = ({ chat, history }) => {\n+┊  ┊37┊  const navBack = useCallback(() => {\n+┊  ┊38┊    history.replace('/chats')\n+┊  ┊39┊  }, [true])\n+┊  ┊40┊\n+┊  ┊41┊  return (\n+┊  ┊42┊    <Container className={name}>\n+┊  ┊43┊      <BackButton onClick={navBack}>\n+┊  ┊44┊        <ArrowBackIcon />\n+┊  ┊45┊      </BackButton>\n+┊  ┊46┊      <Picture src={chat.picture} />\n+┊  ┊47┊      <Title>{chat.name}</Title>\n+┊  ┊48┊    </Container>\n+┊  ┊49┊  )\n+┊  ┊50┊}\n+┊  ┊51┊\n+┊  ┊52┊export default ChatNavbar\n```\n\n[}]: #\n\nNext, would be the `MesagesList` component, where we will see a scrollable list of all the messages of the active chat:\n\n[{]: <helper> (diffStep 6.6 files=\"MessagesList\" module=\"client\")\n\n#### [Step 6.6: Implement ChatRoomScreen components](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/4c8f2bc)\n\n##### Added src&#x2F;components&#x2F;ChatRoomScreen&#x2F;MessagesList.tsx\n```diff\n@@ -0,0 +1,73 @@\n+┊  ┊ 1┊import moment from 'moment'\n+┊  ┊ 2┊import * as React from 'react'\n+┊  ┊ 3┊import styled from 'styled-components'\n+┊  ┊ 4┊\n+┊  ┊ 5┊const Container = styled.div`\n+┊  ┊ 6┊  display: block;\n+┊  ┊ 7┊  flex: 2;\n+┊  ┊ 8┊  overflow-y: overlay;\n+┊  ┊ 9┊  padding: 0 15px;\n+┊  ┊10┊`\n+┊  ┊11┊\n+┊  ┊12┊const MessageItem = styled.div `\n+┊  ┊13┊  float: right;\n+┊  ┊14┊  background-color: #dcf8c6;\n+┊  ┊15┊  display: inline-block;\n+┊  ┊16┊  position: relative;\n+┊  ┊17┊  max-width: 100%;\n+┊  ┊18┊  border-radius: 7px;\n+┊  ┊19┊  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.15);\n+┊  ┊20┊  margin-top: 10px;\n+┊  ┊21┊  margin-bottom: 10px;\n+┊  ┊22┊  clear: both;\n+┊  ┊23┊\n+┊  ┊24┊  &::after {\n+┊  ┊25┊    content: '';\n+┊  ┊26┊    display: table;\n+┊  ┊27┊    clear: both;\n+┊  ┊28┊  }\n+┊  ┊29┊\n+┊  ┊30┊  &::before {\n+┊  ┊31┊    background-image: url(/assets/message-mine.png);\n+┊  ┊32┊    content: '';\n+┊  ┊33┊    position: absolute;\n+┊  ┊34┊    bottom: 3px;\n+┊  ┊35┊    width: 12px;\n+┊  ┊36┊    height: 19px;\n+┊  ┊37┊    right: -11px;\n+┊  ┊38┊    background-position: 50% 50%;\n+┊  ┊39┊    background-repeat: no-repeat;\n+┊  ┊40┊    background-size: contain;\n+┊  ┊41┊  }\n+┊  ┊42┊`\n+┊  ┊43┊\n+┊  ┊44┊const Contents = styled.div `\n+┊  ┊45┊  padding: 5px 7px;\n+┊  ┊46┊  word-wrap: break-word;\n+┊  ┊47┊\n+┊  ┊48┊  &::after {\n+┊  ┊49┊    content: ' \\00a0\\00a0\\00a0\\00a0\\00a0\\00a0\\00a0\\00a0\\00a0\\00a0\\00a0\\00a0\\00a0\\00a0\\00a0\\00a0\\00a0\\00a0\\00a0';\n+┊  ┊50┊    display: inline;\n+┊  ┊51┊  }\n+┊  ┊52┊`\n+┊  ┊53┊\n+┊  ┊54┊const Timestamp = styled.div `\n+┊  ┊55┊  position: absolute;\n+┊  ┊56┊  bottom: 2px;\n+┊  ┊57┊  right: 7px;\n+┊  ┊58┊  color: gray;\n+┊  ┊59┊  font-size: 12px;\n+┊  ┊60┊`\n+┊  ┊61┊\n+┊  ┊62┊const MessagesList = ({ messages }) => (\n+┊  ┊63┊  <Container>\n+┊  ┊64┊    {messages.map((message) => (\n+┊  ┊65┊      <MessageItem key={message.id}>\n+┊  ┊66┊        <Contents>{message.content}</Contents>\n+┊  ┊67┊        <Timestamp>{moment(message.createdAt).format('HH:mm')}</Timestamp>\n+┊  ┊68┊      </MessageItem>\n+┊  ┊69┊    ))}\n+┊  ┊70┊  </Container>\n+┊  ┊71┊)\n+┊  ┊72┊\n+┊  ┊73┊export default MessagesList\n```\n\n[}]: #\n\nAnd finally, would be the `MessageInput` component which will trigger an event whenever we type and submit a new message:\n\n[{]: <helper> (diffStep 6.6 files=\"MessageInput\" module=\"client\")\n\n#### [Step 6.6: Implement ChatRoomScreen components](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/4c8f2bc)\n\n##### Added src&#x2F;components&#x2F;ChatRoomScreen&#x2F;MessageInput.tsx\n```diff\n@@ -0,0 +1,86 @@\n+┊  ┊ 1┊import Button from '@material-ui/core/Button'\n+┊  ┊ 2┊import SendIcon from '@material-ui/icons/Send'\n+┊  ┊ 3┊import * as React from 'react'\n+┊  ┊ 4┊import { useState } from 'react'\n+┊  ┊ 5┊import styled from 'styled-components'\n+┊  ┊ 6┊\n+┊  ┊ 7┊const Container = styled.div`\n+┊  ┊ 8┊  display: flex;\n+┊  ┊ 9┊  height: 50px;\n+┊  ┊10┊  padding: 5px;\n+┊  ┊11┊  width: calc(100% - 10px);\n+┊  ┊12┊`\n+┊  ┊13┊\n+┊  ┊14┊const ActualInput = styled.input `\n+┊  ┊15┊  width: calc(100% - 50px);\n+┊  ┊16┊  border: none;\n+┊  ┊17┊  border-radius: 999px;\n+┊  ┊18┊  padding: 10px;\n+┊  ┊19┊  padding-left: 20px;\n+┊  ┊20┊  padding-right: 20px;\n+┊  ┊21┊  font-size: 15px;\n+┊  ┊22┊  outline: none;\n+┊  ┊23┊  box-shadow: 0 1px silver;\n+┊  ┊24┊  font-size: 18px;\n+┊  ┊25┊  line-height: 45px;\n+┊  ┊26┊`\n+┊  ┊27┊\n+┊  ┊28┊const SendButton = styled(Button) `\n+┊  ┊29┊  min-width: 50px !important;\n+┊  ┊30┊  width: 50px !important;\n+┊  ┊31┊  border-radius: 999px !important;\n+┊  ┊32┊  background-color: var(--primary-bg) !important;\n+┊  ┊33┊  margin: 0 5px !important;\n+┊  ┊34┊  margin-right: 0 !important;\n+┊  ┊35┊  color: white !important;\n+┊  ┊36┊  padding-left: 20px !important;\n+┊  ┊37┊\n+┊  ┊38┊  svg {\n+┊  ┊39┊    margin-left: -3px;\n+┊  ┊40┊  }\n+┊  ┊41┊`\n+┊  ┊42┊\n+┊  ┊43┊const MessageInput = ({ onSendMessage }) => {\n+┊  ┊44┊  const [message, setMessage] = useState('')\n+┊  ┊45┊\n+┊  ┊46┊  const onKeyPress = e => {\n+┊  ┊47┊    if (e.charCode === 13) {\n+┊  ┊48┊      submitMessage()\n+┊  ┊49┊    }\n+┊  ┊50┊  }\n+┊  ┊51┊\n+┊  ┊52┊  const onChange = ({ target }) => {\n+┊  ┊53┊    setMessage(target.value)\n+┊  ┊54┊  }\n+┊  ┊55┊\n+┊  ┊56┊  const submitMessage = () => {\n+┊  ┊57┊    if (!message) return\n+┊  ┊58┊\n+┊  ┊59┊    setMessage('')\n+┊  ┊60┊\n+┊  ┊61┊    if (typeof onSendMessage === 'function') {\n+┊  ┊62┊      onSendMessage(message)\n+┊  ┊63┊    }\n+┊  ┊64┊  }\n+┊  ┊65┊\n+┊  ┊66┊  return (\n+┊  ┊67┊    <Container>\n+┊  ┊68┊      <ActualInput\n+┊  ┊69┊        type=\"text\"\n+┊  ┊70┊        placeholder=\"Type a message\"\n+┊  ┊71┊        value={message}\n+┊  ┊72┊        onKeyPress={onKeyPress}\n+┊  ┊73┊        onChange={onChange}\n+┊  ┊74┊      />\n+┊  ┊75┊      <SendButton\n+┊  ┊76┊        variant=\"contained\"\n+┊  ┊77┊        color=\"primary\"\n+┊  ┊78┊        onClick={submitMessage}\n+┊  ┊79┊      >\n+┊  ┊80┊        <SendIcon />\n+┊  ┊81┊      </SendButton>\n+┊  ┊82┊    </Container>\n+┊  ┊83┊  )\n+┊  ┊84┊}\n+┊  ┊85┊\n+┊  ┊86┊export default MessageInput\n```\n\n[}]: #\n\nNow that we have all 3 components, we will put them all together in the main `index.ts` file:\n\n[{]: <helper> (diffStep 6.6 files=\"index\" module=\"client\")\n\n#### [Step 6.6: Implement ChatRoomScreen components](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/4c8f2bc)\n\n##### Changed src&#x2F;components&#x2F;ChatRoomScreen&#x2F;index.tsx\n```diff\n@@ -1,5 +1,16 @@\n ┊ 1┊ 1┊import * as React from 'react'\n ┊ 2┊ 2┊import { useMemo, useState } from 'react'\n+┊  ┊ 3┊import styled from 'styled-components'\n+┊  ┊ 4┊import ChatNavbar from './ChatNavbar'\n+┊  ┊ 5┊import MessageInput from './MessageInput'\n+┊  ┊ 6┊import MessagesList from './MessagesList'\n+┊  ┊ 7┊\n+┊  ┊ 8┊const Container = styled.div `\n+┊  ┊ 9┊  background: url(/assets/chat-background.jpg);\n+┊  ┊10┊  display: flex;\n+┊  ┊11┊  flex-flow: column;\n+┊  ┊12┊  height: 100vh;\n+┊  ┊13┊`\n ┊ 3┊14┊\n ┊ 4┊15┊const getChatQuery = `\n ┊ 5┊16┊  query GetChat($chatId: ID!) {\n```\n```diff\n@@ -16,7 +27,7 @@\n ┊16┊27┊  }\n ┊17┊28┊`\n ┊18┊29┊\n-┊19┊  ┊const ChatRoomScreen = ({ match }) => {\n+┊  ┊30┊const ChatRoomScreen = ({ history, match }) => {\n ┊20┊31┊  const { params: { chatId } } = match\n ┊21┊32┊  const [chat, setChat] = useState(null)\n ┊22┊33┊\n```\n```diff\n@@ -38,17 +49,11 @@\n ┊38┊49┊  if (!chat) return null\n ┊39┊50┊\n ┊40┊51┊  return (\n-┊41┊  ┊    <div>\n-┊42┊  ┊      <img src={chat.picture} /><div>{chat.name}</div>\n-┊43┊  ┊      <ul>\n-┊44┊  ┊        {chat.messages.map((message) =>\n-┊45┊  ┊          <li key={message.id}>\n-┊46┊  ┊            <div>{message.content}</div>\n-┊47┊  ┊            <div>{message.createdAt}</div>\n-┊48┊  ┊          </li>\n-┊49┊  ┊        )}\n-┊50┊  ┊      </ul>\n-┊51┊  ┊    </div>\n+┊  ┊52┊    <Container>\n+┊  ┊53┊      <ChatNavbar chat={chat} history={history} />\n+┊  ┊54┊      <MessagesList messages={chat.messages} />\n+┊  ┊55┊      <MessageInput />\n+┊  ┊56┊    </Container>\n ┊52┊57┊  )\n ┊53┊58┊}\n```\n\n[}]: #\n\nThe view is complete! However the `MessageInput` is not bound to our messages list. We will use the triggered callback to update the chat state, whose changes should appear in the `MessagesList` component in the following render phase:\n\n[{]: <helper> (diffStep 6.7 module=\"client\")\n\n#### [Step 6.7: Define onSendMessage callback](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/c72f705)\n\n##### Changed src&#x2F;components&#x2F;ChatRoomScreen&#x2F;index.tsx\n```diff\n@@ -1,5 +1,5 @@\n ┊1┊1┊import * as React from 'react'\n-┊2┊ ┊import { useMemo, useState } from 'react'\n+┊ ┊2┊import { useCallback, useMemo, useState } from 'react'\n ┊3┊3┊import styled from 'styled-components'\n ┊4┊4┊import ChatNavbar from './ChatNavbar'\n ┊5┊5┊import MessageInput from './MessageInput'\n```\n```diff\n@@ -46,13 +46,26 @@\n ┊46┊46┊    setChat(chat)\n ┊47┊47┊  }, [true])\n ┊48┊48┊\n+┊  ┊49┊  const onSendMessage = useCallback((content) => {\n+┊  ┊50┊    const message = {\n+┊  ┊51┊      id: chat.messages.length + 1,\n+┊  ┊52┊      createdAt: Date.now(),\n+┊  ┊53┊      content,\n+┊  ┊54┊    }\n+┊  ┊55┊\n+┊  ┊56┊    setChat({\n+┊  ┊57┊      ...chat,\n+┊  ┊58┊      messages: chat.messages.concat(message),\n+┊  ┊59┊    })\n+┊  ┊60┊  }, [chat])\n+┊  ┊61┊\n ┊49┊62┊  if (!chat) return null\n ┊50┊63┊\n ┊51┊64┊  return (\n ┊52┊65┊    <Container>\n ┊53┊66┊      <ChatNavbar chat={chat} history={history} />\n ┊54┊67┊      <MessagesList messages={chat.messages} />\n-┊55┊  ┊      <MessageInput />\n+┊  ┊68┊      <MessageInput onSendMessage={onSendMessage} />\n ┊56┊69┊    </Container>\n ┊57┊70┊  )\n ┊58┊71┊}\n```\n\n[}]: #\n\nThis is how the entire flow should look like:\n\n![flow-demo](https://user-images.githubusercontent.com/7648874/54739741-27012280-4bf4-11e9-97cb-c715482e2e70.gif)\n\nAn edge case that should be taken care of is when the messages list length in the view exceeds the length of the container, in which case we will have to scroll down to the bottom of the view. This way we can keep track of the most recent message. We will use `ReactDOM` to retrieve the native HTML element of the container and change the position of the scroller whenever a messages was sent:\n\n[{]: <helper> (diffStep 6.8 module=\"client\")\n\n#### [Step 6.8: Reset scroller on message sent](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/8554bf7)\n\n##### Changed src&#x2F;components&#x2F;ChatRoomScreen&#x2F;MessagesList.tsx\n```diff\n@@ -1,5 +1,7 @@\n ┊1┊1┊import moment from 'moment'\n ┊2┊2┊import * as React from 'react'\n+┊ ┊3┊import { useEffect, useRef } from 'react'\n+┊ ┊4┊import * as ReactDOM from 'react-dom'\n ┊3┊5┊import styled from 'styled-components'\n ┊4┊6┊\n ┊5┊7┊const Container = styled.div`\n```\n```diff\n@@ -59,15 +61,26 @@\n ┊59┊61┊  font-size: 12px;\n ┊60┊62┊`\n ┊61┊63┊\n-┊62┊  ┊const MessagesList = ({ messages }) => (\n-┊63┊  ┊  <Container>\n-┊64┊  ┊    {messages.map((message) => (\n-┊65┊  ┊      <MessageItem key={message.id}>\n-┊66┊  ┊        <Contents>{message.content}</Contents>\n-┊67┊  ┊        <Timestamp>{moment(message.createdAt).format('HH:mm')}</Timestamp>\n-┊68┊  ┊      </MessageItem>\n-┊69┊  ┊    ))}\n-┊70┊  ┊  </Container>\n-┊71┊  ┊)\n+┊  ┊64┊const MessagesList = ({ messages }) => {\n+┊  ┊65┊  const selfRef = useRef(null)\n+┊  ┊66┊\n+┊  ┊67┊  useEffect(() => {\n+┊  ┊68┊    if (!selfRef.current) return\n+┊  ┊69┊\n+┊  ┊70┊    const selfDOMNode = ReactDOM.findDOMNode(selfRef.current) as HTMLElement\n+┊  ┊71┊    selfDOMNode.scrollTop = Number.MAX_SAFE_INTEGER\n+┊  ┊72┊  }, [messages.length])\n+┊  ┊73┊\n+┊  ┊74┊  return (\n+┊  ┊75┊    <Container ref={selfRef}>\n+┊  ┊76┊      {messages.map((message) => (\n+┊  ┊77┊        <MessageItem key={message.id}>\n+┊  ┊78┊          <Contents>{message.content}</Contents>\n+┊  ┊79┊          <Timestamp>{moment(message.createdAt).format('HH:mm')}</Timestamp>\n+┊  ┊80┊        </MessageItem>\n+┊  ┊81┊      ))}\n+┊  ┊82┊    </Container>\n+┊  ┊83┊  )\n+┊  ┊84┊}\n ┊72┊85┊\n ┊73┊86┊export default MessagesList\n```\n\n[}]: #\n\nBefore we wrap things up, we should also test our components. Since the new components have a direct control over the app's history, we should also find a way to simulate it in our tests. The `react-dom-router` uses the [`history`](https://www.npmjs.com/package/history) package under the hood, that means that we can use that package to inject a custom history object directly into the tested components. Let's install this package if so:\n\n  $ npm install history --dev\n\nAnd then implement our test suites:\n\n[{]: <helper> (diffStep 6.9 files=\"components\" module=\"client\")\n\n#### [Step 6.9: Test ChatRoomScreen child components](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/d7a189e)\n\n##### Added src&#x2F;components&#x2F;ChatRoomScreen&#x2F;ChatNavbar.test.tsx\n```diff\n@@ -0,0 +1,49 @@\n+┊  ┊ 1┊import { createMemoryHistory } from 'history'\n+┊  ┊ 2┊import React from 'react'\n+┊  ┊ 3┊import { cleanup, render, fireEvent, wait } from 'react-testing-library'\n+┊  ┊ 4┊import ChatNavbar from './ChatNavbar'\n+┊  ┊ 5┊\n+┊  ┊ 6┊describe('ChatNavbar', () => {\n+┊  ┊ 7┊  afterEach(cleanup)\n+┊  ┊ 8┊\n+┊  ┊ 9┊  it('renders chat data', () => {\n+┊  ┊10┊    const chat = {\n+┊  ┊11┊      id: '1',\n+┊  ┊12┊      name: 'Foo Bar',\n+┊  ┊13┊      picture: 'https://localhost:4000/picture.jpg',\n+┊  ┊14┊    }\n+┊  ┊15┊\n+┊  ┊16┊    {\n+┊  ┊17┊      const { container, getByTestId } = render(<ChatNavbar chat={chat} />)\n+┊  ┊18┊\n+┊  ┊19┊      expect(getByTestId('chat-name')).toHaveTextContent('Foo Bar')\n+┊  ┊20┊      expect(getByTestId('chat-picture')).toHaveAttribute('src', 'https://localhost:4000/picture.jpg')\n+┊  ┊21┊    }\n+┊  ┊22┊  })\n+┊  ┊23┊\n+┊  ┊24┊  it('goes back on arrow click', async () => {\n+┊  ┊25┊    const chat = {\n+┊  ┊26┊      id: '1',\n+┊  ┊27┊      name: 'Foo Bar',\n+┊  ┊28┊      picture: 'https://localhost:4000/picture.jpg',\n+┊  ┊29┊    }\n+┊  ┊30┊\n+┊  ┊31┊    const history = createMemoryHistory()\n+┊  ┊32┊\n+┊  ┊33┊    history.push('/chats/1')\n+┊  ┊34┊\n+┊  ┊35┊    await wait(() =>\n+┊  ┊36┊      expect(history.location.pathname).toEqual('/chats/1')\n+┊  ┊37┊    )\n+┊  ┊38┊\n+┊  ┊39┊    {\n+┊  ┊40┊      const { container, getByTestId } = render(<ChatNavbar chat={chat} history={history} />)\n+┊  ┊41┊\n+┊  ┊42┊      fireEvent.click(getByTestId('back-button'))\n+┊  ┊43┊\n+┊  ┊44┊      await wait(() =>\n+┊  ┊45┊        expect(history.location.pathname).toEqual('/chats')\n+┊  ┊46┊      )\n+┊  ┊47┊    }\n+┊  ┊48┊  })\n+┊  ┊49┊})\n```\n\n##### Changed src&#x2F;components&#x2F;ChatRoomScreen&#x2F;ChatNavbar.tsx\n```diff\n@@ -29,7 +29,7 @@\n ┊29┊29┊  border-radius: 50%;\n ┊30┊30┊`\n ┊31┊31┊\n-┊32┊  ┊const Title = styled.div `\n+┊  ┊32┊const Name = styled.div `\n ┊33┊33┊  line-height: 56px;\n ┊34┊34┊`\n ┊35┊35┊\n```\n```diff\n@@ -40,11 +40,11 @@\n ┊40┊40┊\n ┊41┊41┊  return (\n ┊42┊42┊    <Container className={name}>\n-┊43┊  ┊      <BackButton onClick={navBack}>\n+┊  ┊43┊      <BackButton data-testid=\"back-button\" onClick={navBack}>\n ┊44┊44┊        <ArrowBackIcon />\n ┊45┊45┊      </BackButton>\n-┊46┊  ┊      <Picture src={chat.picture} />\n-┊47┊  ┊      <Title>{chat.name}</Title>\n+┊  ┊46┊      <Picture data-testid=\"chat-picture\" src={chat.picture} />\n+┊  ┊47┊      <Name data-testid=\"chat-name\">{chat.name}</Name>\n ┊48┊48┊    </Container>\n ┊49┊49┊  )\n ┊50┊50┊}\n```\n\n##### Added src&#x2F;components&#x2F;ChatRoomScreen&#x2F;MessageInput.test.tsx\n```diff\n@@ -0,0 +1,47 @@\n+┊  ┊ 1┊import { createMemoryHistory } from 'history'\n+┊  ┊ 2┊import React from 'react'\n+┊  ┊ 3┊import { cleanup, render, fireEvent, wait, waitForElement } from 'react-testing-library'\n+┊  ┊ 4┊import MessageInput from './MessageInput'\n+┊  ┊ 5┊\n+┊  ┊ 6┊describe('MessageInput', () => {\n+┊  ┊ 7┊  afterEach(cleanup)\n+┊  ┊ 8┊\n+┊  ┊ 9┊  it('triggers callback on send button click', async () => {\n+┊  ┊10┊    const onSendMessage = jest.fn(() => {})\n+┊  ┊11┊\n+┊  ┊12┊    {\n+┊  ┊13┊      const { container, getByTestId } = render(<MessageInput onSendMessage={onSendMessage} />)\n+┊  ┊14┊      const messageInput = getByTestId('message-input')\n+┊  ┊15┊      const sendButton = getByTestId('send-button')\n+┊  ┊16┊\n+┊  ┊17┊      fireEvent.change(messageInput, { target: { value: 'foo' } })\n+┊  ┊18┊\n+┊  ┊19┊      await waitForElement(() => messageInput)\n+┊  ┊20┊\n+┊  ┊21┊      fireEvent.click(sendButton)\n+┊  ┊22┊\n+┊  ┊23┊      await wait(() =>\n+┊  ┊24┊        expect(onSendMessage.mock.calls.length).toBe(1)\n+┊  ┊25┊      )\n+┊  ┊26┊    }\n+┊  ┊27┊  })\n+┊  ┊28┊\n+┊  ┊29┊  it('triggers callback on Enter press', async () => {\n+┊  ┊30┊    const onSendMessage = jest.fn(() => {})\n+┊  ┊31┊\n+┊  ┊32┊    {\n+┊  ┊33┊      const { container, getByTestId } = render(<MessageInput onSendMessage={onSendMessage} />)\n+┊  ┊34┊      const messageInput = getByTestId('message-input')\n+┊  ┊35┊\n+┊  ┊36┊      fireEvent.change(messageInput, { target: { value: 'foo' } })\n+┊  ┊37┊\n+┊  ┊38┊      await waitForElement(() => messageInput)\n+┊  ┊39┊\n+┊  ┊40┊      fireEvent.keyPress(messageInput, { key: 'Enter', code: 13, charCode: 13 })\n+┊  ┊41┊\n+┊  ┊42┊      await wait(() =>\n+┊  ┊43┊        expect(onSendMessage.mock.calls.length).toBe(1)\n+┊  ┊44┊      )\n+┊  ┊45┊    }\n+┊  ┊46┊  })\n+┊  ┊47┊})\n```\n\n##### Changed src&#x2F;components&#x2F;ChatRoomScreen&#x2F;MessageInput.tsx\n```diff\n@@ -66,6 +66,7 @@\n ┊66┊66┊  return (\n ┊67┊67┊    <Container>\n ┊68┊68┊      <ActualInput\n+┊  ┊69┊        data-testid=\"message-input\"\n ┊69┊70┊        type=\"text\"\n ┊70┊71┊        placeholder=\"Type a message\"\n ┊71┊72┊        value={message}\n```\n```diff\n@@ -73,6 +74,7 @@\n ┊73┊74┊        onChange={onChange}\n ┊74┊75┊      />\n ┊75┊76┊      <SendButton\n+┊  ┊77┊        data-testid=\"send-button\"\n ┊76┊78┊        variant=\"contained\"\n ┊77┊79┊        color=\"primary\"\n ┊78┊80┊        onClick={submitMessage}\n```\n\n##### Added src&#x2F;components&#x2F;ChatRoomScreen&#x2F;MessagesList.test.tsx\n```diff\n@@ -0,0 +1,37 @@\n+┊  ┊ 1┊import { createMemoryHistory } from 'history'\n+┊  ┊ 2┊import React from 'react'\n+┊  ┊ 3┊import { cleanup, render, fireEvent, wait, getByTestId } from 'react-testing-library'\n+┊  ┊ 4┊import MessagesList from './MessagesList'\n+┊  ┊ 5┊\n+┊  ┊ 6┊describe('MessagesList', () => {\n+┊  ┊ 7┊  afterEach(cleanup)\n+┊  ┊ 8┊\n+┊  ┊ 9┊  it('renders messages data', () => {\n+┊  ┊10┊    const messages = [\n+┊  ┊11┊      {\n+┊  ┊12┊        id: '1',\n+┊  ┊13┊        content: 'foo',\n+┊  ┊14┊        createdAt: new Date(0),\n+┊  ┊15┊      },\n+┊  ┊16┊      {\n+┊  ┊17┊        id: '2',\n+┊  ┊18┊        content: 'bar',\n+┊  ┊19┊        createdAt: new Date(1000 * 60 * 60),\n+┊  ┊20┊      },\n+┊  ┊21┊    ]\n+┊  ┊22┊\n+┊  ┊23┊    let message1, message2\n+┊  ┊24┊    {\n+┊  ┊25┊      const { container, getAllByTestId, getByTestId } = render(<MessagesList messages={messages} />)\n+┊  ┊26┊      const match = getAllByTestId('message-item')\n+┊  ┊27┊      message1 = match[0]\n+┊  ┊28┊      message2 = match[1]\n+┊  ┊29┊    }\n+┊  ┊30┊\n+┊  ┊31┊    expect(getByTestId(message1, 'message-content')).toHaveTextContent('foo')\n+┊  ┊32┊    expect(getByTestId(message1, 'message-date')).toHaveTextContent('08:00')\n+┊  ┊33┊\n+┊  ┊34┊    expect(getByTestId(message2, 'message-content')).toHaveTextContent('bar')\n+┊  ┊35┊    expect(getByTestId(message2, 'message-date')).toHaveTextContent('09:00')\n+┊  ┊36┊  })\n+┊  ┊37┊})\n```\n\n##### Changed src&#x2F;components&#x2F;ChatRoomScreen&#x2F;MessagesList.tsx\n```diff\n@@ -74,9 +74,9 @@\n ┊74┊74┊  return (\n ┊75┊75┊    <Container ref={selfRef}>\n ┊76┊76┊      {messages.map((message) => (\n-┊77┊  ┊        <MessageItem key={message.id}>\n-┊78┊  ┊          <Contents>{message.content}</Contents>\n-┊79┊  ┊          <Timestamp>{moment(message.createdAt).format('HH:mm')}</Timestamp>\n+┊  ┊77┊        <MessageItem data-testid=\"message-item\" key={message.id}>\n+┊  ┊78┊          <Contents data-testid=\"message-content\">{message.content}</Contents>\n+┊  ┊79┊          <Timestamp data-testid=\"message-date\">{moment(message.createdAt).format('HH:mm')}</Timestamp>\n ┊80┊80┊        </MessageItem>\n ┊81┊81┊      ))}\n ┊82┊82┊    </Container>\n```\n\n[}]: #\n\nThere are many things which are incomplete in the current implementation. The functionality exists in the UI, but no messages are really being sent and stored in the database. In the next chapters we will learn how to:\n\n\n\n*   Cache query results with Apollo-Client.\n*   Send messages with GraphQL mutations"
          },
          {
            "manualTitle": "Step 7: Caching with Apollo-Client",
            "stepRevision": "f9b678f1853108d3cb3cc8a374dccc26980b50fc",
            "manualView": "In the previous step we've implemented a `ChatRoomScreen` where we were able to view each chat's messages list by clicking on a chat item from the main screen. It all looks functional, however, there's a significant optimization issue - each time we navigate into a `ChatRoomScreen`, we need to re-fetch the data related to the target chat.\n\nThe solution for that would be [caching](https://en.wikipedia.org/wiki/Cache_(computing)) the fetch result, so it can be re-used once we re-enter a screen that we've visited before. For now things are fairly simple so the caching mechanism can be implemented manually, but things are gonna get tougher when we add more queries or things like message sending and profile updating to the mix, so it's not gonna be an easy task. Luckily, in the Apollo team they've invented a solution that works right out of the box and integrates perfectly with Apollo-GraphQL server - [Apollo-GraphQL client](https://www.apollographql.com/docs/link/#apollo-client).\n\n\n\n![caching](https://user-images.githubusercontent.com/7648874/54871150-f505e100-4dea-11e9-9e2d-439fbf3eaebe.png)\n\n\n\nApollo-Client is a wrap around our GraphQL REST endpoint which essentially uses HTTP requests (and further on [web-sockets](https://en.wikipedia.org/wiki/WebSocket), but we will get there), something that we've implemented manually so far. Not only it can be used to fetch data, but it will also cache the result of the query so it can be seamlessly re-used when we request the same data. This means that we will need to setup an Apollo-Client and replace all our `fetch()` calls with `client.query()` call. More about Apollo-Client's API further in this tutorial, but let's start configuring it. First we will install few essential NPM packages:\n\n  $ npm install apollo-cache-inmemory apollo-client apollo-link apollo-link-http\n\n\n\n*   [`apollo-client`](https://www.npmjs.com/package/apollo-client) - Apollo-Client's core package, as we explained earlier.\n*   [`apollo-cache-inmemory`](https://www.npmjs.com/package/apollo-cache-inmemory) - The data store that will be used to cache the results.\n*   [`apollo-link-http`](https://www.npmjs.com/package/apollo-link-http) - Get GraphQL results over a network using HTTP fetch.\n\nWe will create a new file in the `src` directory called `client.ts` and inside we will export the client:\n\n[{]: <helper> (diffStep 7.1 files=\"client\" module=\"client\")\n\n#### [Step 7.1: Add Apollo client](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/4669eb8)\n\n##### Added src&#x2F;client.ts\n```diff\n@@ -0,0 +1,16 @@\n+┊  ┊ 1┊import { InMemoryCache } from 'apollo-cache-inmemory'\n+┊  ┊ 2┊import { ApolloClient } from 'apollo-client'\n+┊  ┊ 3┊import { HttpLink } from 'apollo-link-http'\n+┊  ┊ 4┊\n+┊  ┊ 5┊const httpUri = process.env.REACT_APP_SERVER_URL + '/graphql'\n+┊  ┊ 6┊\n+┊  ┊ 7┊const httpLink = new HttpLink({\n+┊  ┊ 8┊  uri: httpUri,\n+┊  ┊ 9┊})\n+┊  ┊10┊\n+┊  ┊11┊const inMemoryCache = new InMemoryCache()\n+┊  ┊12┊\n+┊  ┊13┊export default new ApolloClient({\n+┊  ┊14┊  link: httpLink,\n+┊  ┊15┊  cache: inMemoryCache,\n+┊  ┊16┊})\n```\n\n[}]: #\n\nAlthough the client can be used directly and integrated into any UI framework, it would be the most comfortable to use a wrap around it which is suitable for React. For that we will use a package called [`react-apollo-hooks`](https://www.npmjs.com/package/react-apollo-hooks) which includes a set of [React hooks](https://reactjs.org/docs/hooks-intro.html) that can connect between our Apollo-Client and target React.Component:\n\n    $ npm install react-apollo-hooks graphql-tag\n\nWith `react-apollo-hooks` we can use the `useQuery()` hook to fetch data from our GraphQL API. The `graphql-tag` package is used to parse the GraphQL string to an [AST](https://en.wikipedia.org/wiki/Abstract_syntax_tree), something which is required when using Apollo Client. Example:\n\n\n```\nimport gql from 'graphql-tag';\nimport { useQuery } from 'react-apollo-hooks';\n\nconst GET_DOGS = gql`\n  {\n    dogs {\n      id\n      breed\n    }\n  }\n`;\n\nconst Dogs = () => {\n  const { data, error, loading } = useQuery(GET_DOGS);\n  if (loading) {\n    return <div>Loading...</div>;\n  };\n  if (error) {\n    return <div>Error! {error.message}</div>;\n  };\n\n  return (\n    <ul>\n      {data.dogs.map(dog => (\n        <li key={dog.id}>{dog.breed}</li>\n      ))}\n    </ul>\n  );\n};\n```\n\n\nThe package requires a small setup so that imported hooks can use our Apollo-Client:\n\n[{]: <helper> (diffStep 7.2 files=\"index\" module=\"client\")\n\n#### [Step 7.2: Provide Apollo client](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/730babe)\n\n##### Changed src&#x2F;index.jsx\n```diff\n@@ -1,8 +1,10 @@\n ┊ 1┊ 1┊import { MuiThemeProvider, createMuiTheme } from '@material-ui/core/styles'\n ┊ 2┊ 2┊import React from 'react';\n ┊ 3┊ 3┊import ReactDOM from 'react-dom';\n+┊  ┊ 4┊import { ApolloProvider } from 'react-apollo-hooks'\n ┊ 4┊ 5┊import './index.css';\n ┊ 5┊ 6┊import App from './App';\n+┊  ┊ 7┊import client from './client'\n ┊ 6┊ 8┊import * as serviceWorker from './serviceWorker';\n ┊ 7┊ 9┊\n ┊ 8┊10┊const theme = createMuiTheme({\n```\n```diff\n@@ -17,7 +19,9 @@\n ┊17┊19┊\n ┊18┊20┊ReactDOM.render(\n ┊19┊21┊  <MuiThemeProvider theme={theme}>\n-┊20┊  ┊    <App />\n+┊  ┊22┊    <ApolloProvider client={client}>\n+┊  ┊23┊      <App />\n+┊  ┊24┊    </ApolloProvider>\n ┊21┊25┊  </MuiThemeProvider>\n ┊22┊26┊, document.getElementById('root'));\n```\n\n[}]: #\n\nThe code above uses the [Context/Provider](https://reactjs.org/docs/context.html) API, thus the client is now known globally. Now that we can use the `useQuery()` hook, there's no need to use the native Fetch API anymore. Let's replace all our Fetch API call instances with a React hook:\n\n[{]: <helper> (diffStep 7.3 files=\"components\" module=\"client\")\n\n#### [Step 7.3: Replace fetch() calls with useQuery()](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/95d45fd)\n\n##### Changed src&#x2F;components&#x2F;ChatRoomScreen&#x2F;index.tsx\n```diff\n@@ -1,5 +1,7 @@\n+┊ ┊1┊import gql from 'graphql-tag'\n ┊1┊2┊import * as React from 'react'\n-┊2┊ ┊import { useCallback, useMemo, useState } from 'react'\n+┊ ┊3┊import { useCallback } from 'react'\n+┊ ┊4┊import { useApolloClient, useQuery } from 'react-apollo-hooks'\n ┊3┊5┊import styled from 'styled-components'\n ┊4┊6┊import ChatNavbar from './ChatNavbar'\n ┊5┊7┊import MessageInput from './MessageInput'\n```\n```diff\n@@ -12,7 +14,7 @@\n ┊12┊14┊  height: 100vh;\n ┊13┊15┊`\n ┊14┊16┊\n-┊15┊  ┊const getChatQuery = `\n+┊  ┊17┊const getChatQuery = gql `\n ┊16┊18┊  query GetChat($chatId: ID!) {\n ┊17┊19┊    chat(chatId: $chatId) {\n ┊18┊20┊      id\n```\n```diff\n@@ -29,22 +31,10 @@\n ┊29┊31┊\n ┊30┊32┊const ChatRoomScreen = ({ history, match }) => {\n ┊31┊33┊  const { params: { chatId } } = match\n-┊32┊  ┊  const [chat, setChat] = useState(null)\n-┊33┊  ┊\n-┊34┊  ┊  useMemo(async () => {\n-┊35┊  ┊    const body = await fetch(`${process.env.REACT_APP_SERVER_URL}/graphql`, {\n-┊36┊  ┊      method: 'POST',\n-┊37┊  ┊      headers: {\n-┊38┊  ┊        'Content-Type': 'application/json',\n-┊39┊  ┊      },\n-┊40┊  ┊      body: JSON.stringify({\n-┊41┊  ┊        query: getChatQuery,\n-┊42┊  ┊        variables: { chatId },\n-┊43┊  ┊      }),\n-┊44┊  ┊    })\n-┊45┊  ┊    const { data: { chat } } = await body.json()\n-┊46┊  ┊    setChat(chat)\n-┊47┊  ┊  }, [true])\n+┊  ┊34┊  const client = useApolloClient()\n+┊  ┊35┊  const { data: { chat } } = useQuery(getChatQuery, {\n+┊  ┊36┊    variables: { chatId }\n+┊  ┊37┊  })\n ┊48┊38┊\n ┊49┊39┊  const onSendMessage = useCallback((content) => {\n ┊50┊40┊    const message = {\n```\n```diff\n@@ -53,9 +43,15 @@\n ┊53┊43┊      content,\n ┊54┊44┊    }\n ┊55┊45┊\n-┊56┊  ┊    setChat({\n-┊57┊  ┊      ...chat,\n-┊58┊  ┊      messages: chat.messages.concat(message),\n+┊  ┊46┊    client.writeQuery({\n+┊  ┊47┊      query: getChatQuery,\n+┊  ┊48┊      variables: { chatId },\n+┊  ┊49┊      data: {\n+┊  ┊50┊        chat: {\n+┊  ┊51┊          ...chat,\n+┊  ┊52┊          messages: chat.messages.concat(message),\n+┊  ┊53┊        },\n+┊  ┊54┊      },\n ┊59┊55┊    })\n ┊60┊56┊  }, [chat])\n ┊61┊57┊\n```\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;ChatsList.tsx\n```diff\n@@ -1,7 +1,9 @@\n ┊1┊1┊import { List, ListItem } from '@material-ui/core'\n+┊ ┊2┊import gql from 'graphql-tag'\n ┊2┊3┊import moment from 'moment'\n ┊3┊4┊import * as React from 'react'\n-┊4┊ ┊import { useCallback, useState, useMemo } from 'react'\n+┊ ┊5┊import { useCallback } from 'react'\n+┊ ┊6┊import { useQuery } from 'react-apollo-hooks'\n ┊5┊7┊import styled from 'styled-components'\n ┊6┊8┊\n ┊7┊9┊const Container = styled.div `\n```\n```diff\n@@ -56,7 +58,7 @@\n ┊56┊58┊  font-size: 13px;\n ┊57┊59┊`\n ┊58┊60┊\n-┊59┊  ┊const getChatsQuery = `\n+┊  ┊61┊const getChatsQuery = gql `\n ┊60┊62┊  query GetChats {\n ┊61┊63┊    chats {\n ┊62┊64┊      id\n```\n```diff\n@@ -72,19 +74,7 @@\n ┊72┊74┊`\n ┊73┊75┊\n ┊74┊76┊const ChatsList = ({ history }) => {\n-┊75┊  ┊  const [chats, setChats] = useState([])\n-┊76┊  ┊\n-┊77┊  ┊  useMemo(async () => {\n-┊78┊  ┊    const body = await fetch(`${process.env.REACT_APP_SERVER_URL}/graphql`, {\n-┊79┊  ┊      method: 'POST',\n-┊80┊  ┊      headers: {\n-┊81┊  ┊        'Content-Type': 'application/json',\n-┊82┊  ┊      },\n-┊83┊  ┊      body: JSON.stringify({ query: getChatsQuery }),\n-┊84┊  ┊    })\n-┊85┊  ┊    const { data: { chats } } = await body.json()\n-┊86┊  ┊    setChats(chats)\n-┊87┊  ┊  }, [true])\n+┊  ┊77┊  const { data: { chats = [] } } = useQuery(getChatsQuery)\n ┊88┊78┊\n ┊89┊79┊  const navToChat = useCallback((chat) => {\n ┊90┊80┊    history.push(`chats/${chat.id}`)\n```\n\n[}]: #\n\nThe replacement is finished. Note that we removed the usage of `useMemo()` - because Apollo has an internal cache mechanism, there's no need to memoize the result anymore. We also used the [`writeQuery()`](https://www.apollographql.com/docs/react/features/caching.html#writequery-and-writefragment) method to edit the stored result in the cache, so in the next render phase we would have an updated chat with the newly added message.\n\nWe shouldn't feel any change at all in the view and the response time, since we're running it locally, but if we will take a look at the `network` tab in the browser's dev-tools we should notice the differences:\n\n**before**\n\n![fetch](https://user-images.githubusercontent.com/7648874/54871305-e5879780-4dec-11e9-87bb-3279e9e18342.png)\n\n**after**\n\n![apollo](https://user-images.githubusercontent.com/7648874/54871319-1bc51700-4ded-11e9-9001-d5518bedf9ad.png)\n\n> Above: ChatsListScreen -> ChatRoomScreen -> ChatsListScreen -> ChatRoomScreen\n\nThis test is obviously very rough, but the deviation is so big that you don't need any accuracy to emphasize the difference. The blue stripes represents the requests made and the time they took. Before we had about 6 request phases, while after we had only 3 of them.\n\nSince we don't use the Fetch API anymore, we will also need to update our tests. Right now we mock the response from the fetch API, but a more appropriate way would be creating a fake Apollo Client where we will be able to mock the results. For that we will install a package called [`apollo-link-mock`](https://www.npmjs.com/package/apollo-link-mock):\n\n    $ npm install --dev apollo-link-mock\n\nAnd we will create a `test-helpers.ts` file under the `src` directory that will contain the utility function for creating a fake Apollo Client:\n\n[{]: <helper> (diffStep 7.4 files=\"test-helpers\" module=\"client\")\n\n#### [Step 7.4: Mock GraphQL requests in tests](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/fb7fee5)\n\n##### Added src&#x2F;test-helpers.ts\n```diff\n@@ -0,0 +1,10 @@\n+┊  ┊ 1┊import { InMemoryCache } from 'apollo-cache-inmemory'\n+┊  ┊ 2┊import { ApolloClient } from 'apollo-client'\n+┊  ┊ 3┊import { MockLink } from 'apollo-link-mock'\n+┊  ┊ 4┊\n+┊  ┊ 5┊export const mockApolloClient = (mocks) => {\n+┊  ┊ 6┊  return new ApolloClient({\n+┊  ┊ 7┊    cache: new InMemoryCache(),\n+┊  ┊ 8┊    link: new MockLink(mocks),\n+┊  ┊ 9┊  })\n+┊  ┊10┊}\n```\n\n[}]: #\n\nThe fake client accepts an array of mocks where each mock object will have a `request` key that will contain details about the request and a `result` key which will contain the mocked result. You should get a better understanding of how it works now that we will replace the fake Fetch calls with fake Apollo Clients:\n\n[{]: <helper> (diffStep 7.4 files=\"src/components\" module=\"client\")\n\n#### [Step 7.4: Mock GraphQL requests in tests](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/fb7fee5)\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;ChatsList.test.tsx\n```diff\n@@ -1,8 +1,10 @@\n ┊ 1┊ 1┊import { createBrowserHistory } from 'history'\n ┊ 2┊ 2┊import React from 'react'\n+┊  ┊ 3┊import { ApolloProvider } from 'react-apollo-hooks'\n ┊ 3┊ 4┊import ReactDOM from 'react-dom'\n ┊ 4┊ 5┊import { cleanup, render, fireEvent, wait, waitForDomChange } from 'react-testing-library'\n-┊ 5┊  ┊import ChatsList from './ChatsList'\n+┊  ┊ 6┊import { mockApolloClient } from '../../test-helpers'\n+┊  ┊ 7┊import ChatsList, { getChatsQuery } from './ChatsList'\n ┊ 6┊ 8┊\n ┊ 7┊ 9┊describe('ChatsList', () => {\n ┊ 8┊10┊  afterEach(() => {\n```\n```diff\n@@ -11,25 +13,36 @@\n ┊11┊13┊  })\n ┊12┊14┊\n ┊13┊15┊  it('renders fetched chats data', async () => {\n-┊14┊  ┊    fetch.mockResponseOnce(JSON.stringify({\n-┊15┊  ┊      data: {\n-┊16┊  ┊        chats: [\n-┊17┊  ┊          {\n-┊18┊  ┊            id: 1,\n-┊19┊  ┊            name: 'Foo Bar',\n-┊20┊  ┊            picture: 'https://localhost:4000/picture.jpg',\n-┊21┊  ┊            lastMessage: {\n-┊22┊  ┊              id: 1,\n-┊23┊  ┊              content: 'Hello',\n-┊24┊  ┊              createdAt: new Date(0),\n-┊25┊  ┊            },\n+┊  ┊16┊    const client = mockApolloClient([\n+┊  ┊17┊      {\n+┊  ┊18┊        request: { query: getChatsQuery },\n+┊  ┊19┊        result: {\n+┊  ┊20┊          data: {\n+┊  ┊21┊            chats: [\n+┊  ┊22┊              {\n+┊  ┊23┊                __typename: 'Chat',\n+┊  ┊24┊                id: 1,\n+┊  ┊25┊                name: 'Foo Bar',\n+┊  ┊26┊                picture: 'https://localhost:4000/picture.jpg',\n+┊  ┊27┊                lastMessage: {\n+┊  ┊28┊                  __typename: 'Message',\n+┊  ┊29┊                  id: 1,\n+┊  ┊30┊                  content: 'Hello',\n+┊  ┊31┊                  createdAt: new Date(0),\n+┊  ┊32┊                },\n+┊  ┊33┊              },\n+┊  ┊34┊            ],\n ┊26┊35┊          },\n-┊27┊  ┊        ],\n+┊  ┊36┊        },\n ┊28┊37┊      },\n-┊29┊  ┊    }))\n+┊  ┊38┊    ])\n ┊30┊39┊\n ┊31┊40┊    {\n-┊32┊  ┊      const { container, getByTestId } = render(<ChatsList />)\n+┊  ┊41┊      const { container, getByTestId } = render(\n+┊  ┊42┊        <ApolloProvider client={client}>\n+┊  ┊43┊          <ChatsList />\n+┊  ┊44┊        </ApolloProvider>\n+┊  ┊45┊      )\n ┊33┊46┊\n ┊34┊47┊      await waitForDomChange({ container })\n ┊35┊48┊\n```\n```diff\n@@ -41,27 +54,38 @@\n ┊41┊54┊  })\n ┊42┊55┊\n ┊43┊56┊  it('should navigate to the target chat room on chat item click', async () => {\n-┊44┊  ┊    fetch.mockResponseOnce(JSON.stringify({\n-┊45┊  ┊      data: {\n-┊46┊  ┊        chats: [\n-┊47┊  ┊          {\n-┊48┊  ┊            id: 1,\n-┊49┊  ┊            name: 'Foo Bar',\n-┊50┊  ┊            picture: 'https://localhost:4000/picture.jpg',\n-┊51┊  ┊            lastMessage: {\n-┊52┊  ┊              id: 1,\n-┊53┊  ┊              content: 'Hello',\n-┊54┊  ┊              createdAt: new Date(0),\n-┊55┊  ┊            },\n+┊  ┊57┊    const client = mockApolloClient([\n+┊  ┊58┊      {\n+┊  ┊59┊        request: { query: getChatsQuery },\n+┊  ┊60┊        result: {\n+┊  ┊61┊          data: {\n+┊  ┊62┊            chats: [\n+┊  ┊63┊              {\n+┊  ┊64┊                __typename: 'Chat',\n+┊  ┊65┊                id: 1,\n+┊  ┊66┊                name: 'Foo Bar',\n+┊  ┊67┊                picture: 'https://localhost:4000/picture.jpg',\n+┊  ┊68┊                lastMessage: {\n+┊  ┊69┊                  __typename: 'Message',\n+┊  ┊70┊                  id: 1,\n+┊  ┊71┊                  content: 'Hello',\n+┊  ┊72┊                  createdAt: new Date(0),\n+┊  ┊73┊                },\n+┊  ┊74┊              },\n+┊  ┊75┊            ],\n ┊56┊76┊          },\n-┊57┊  ┊        ],\n+┊  ┊77┊        },\n ┊58┊78┊      },\n-┊59┊  ┊    }))\n+┊  ┊79┊    ])\n ┊60┊80┊\n ┊61┊81┊    const history = createBrowserHistory()\n ┊62┊82┊\n ┊63┊83┊    {\n-┊64┊  ┊      const { container, getByTestId } = render(<ChatsList history={history} />)\n+┊  ┊84┊      const { container, getByTestId } = render(\n+┊  ┊85┊        <ApolloProvider client={client}>\n+┊  ┊86┊          <ChatsList history={history} />\n+┊  ┊87┊        </ApolloProvider>\n+┊  ┊88┊      )\n ┊65┊89┊\n ┊66┊90┊      await waitForDomChange({ container })\n ┊67┊91┊\n```\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;ChatsList.tsx\n```diff\n@@ -58,7 +58,7 @@\n ┊58┊58┊  font-size: 13px;\n ┊59┊59┊`\n ┊60┊60┊\n-┊61┊  ┊const getChatsQuery = gql `\n+┊  ┊61┊export const getChatsQuery = gql `\n ┊62┊62┊  query GetChats {\n ┊63┊63┊    chats {\n ┊64┊64┊      id\n```\n\n[}]: #\n\nNote how we used the `ApolloProvider` component to provide the target component with the fake Apollo Client. Like so, any other component which uses Apollo Client should be wrapped with an ApolloProvider when rendering it, otherwise it will not function as intended:\n\n[{]: <helper> (diffStep 7.4 files=\"src/App\" module=\"client\")\n\n#### [Step 7.4: Mock GraphQL requests in tests](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/fb7fee5)\n\n##### Changed src&#x2F;App.test.js\n```diff\n@@ -1,9 +1,17 @@\n ┊ 1┊ 1┊import React from 'react';\n+┊  ┊ 2┊import { ApolloProvider } from 'react-apollo-hooks'\n ┊ 2┊ 3┊import ReactDOM from 'react-dom';\n ┊ 3┊ 4┊import App from './App';\n+┊  ┊ 5┊import { mockApolloClient } from './test-helpers'\n ┊ 4┊ 6┊\n ┊ 5┊ 7┊it('renders without crashing', () => {\n+┊  ┊ 8┊  const client = mockApolloClient()\n ┊ 6┊ 9┊  const div = document.createElement('div');\n-┊ 7┊  ┊  ReactDOM.render(<App />, div);\n+┊  ┊10┊\n+┊  ┊11┊  ReactDOM.render(\n+┊  ┊12┊    <ApolloProvider client={client}>\n+┊  ┊13┊      <App />\n+┊  ┊14┊    </ApolloProvider>\n+┊  ┊15┊  , div);\n ┊ 8┊16┊  ReactDOM.unmountComponentAtNode(div);\n ┊ 9┊17┊});\n```\n\n[}]: #\n\nThat's it for this chapter. There's one thing missing to make our `ChatRoomScreen` functional and that would be actually sending a message to the backend and updating the DB. In the next chapter we will learn how to do exactly that with our new Apollo-Client."
          },
          {
            "manualTitle": "Step 8: Sending messages with GraphQL mutations",
            "stepRevision": "b21dad23ca343ea460bc55374cf6e662b56b1ed2",
            "manualView": "The view and the functionality for updating the component's state when sending a message already exists. The thing is that messages are not really being sent, we only update the memory in the client. If so, how exactly can we send messages and store them in the DB? For this purpose we're gonna learn about GraphQL mutations - a method for sending and applying mutations in our back-end.\n\n**What are GraphQL mutations?**\n\nIf you have an API endpoint that alters data, like inserting data into a database or altering data already in a database, you should make this endpoint a `Mutation` rather than a `Query`. This is as simple as making the API endpoint part of the top-level `Mutation` type instead of the top-level `Query` type.\n\nIt's often convenient to have a mutation that maps to a database create or update operation, return the same thing that the server stored. That way, if you modify the data on the server, the client can learn about those modifications. **A GraphQL mutation is like a GraphQL query, only with side effects**. It's equivalent to GET (query) and POST/PUT (mutation) in the context of REST API.\n\nBelow is a sample GraphQL mutation request:\n\n```graphql\nmutation AddMessage($chatId: ID!) {\n  addMessage(chatId: $chatId) {\n    id\n    contents\n    createdAt\n  }\n}\n```\n\n**How to implement a GraphQL mutation?**\n\nSince GraphQL is schema based, we will need to create a new type called `Mutation` in the `typeDefs.graphql` file. In this chapter we want to have the ability to send messages, thus we will have a field named `addMessage` in the new mutation type:\n\n[{]: <helper> (diffStep 5.1 files=\"typeDefs\" module=\"server\")\n\n#### [Step 5.1: Add addMessage() mutation](https://github.com/Urigo/WhatsApp-Clone-Server/commit/a78d3cf)\n\n##### Changed schema&#x2F;typeDefs.graphql\n```diff\n@@ -18,3 +18,7 @@\n ┊18┊18┊  chats: [Chat!]!\n ┊19┊19┊  chat(chatId: ID!): Chat\n ┊20┊20┊}\n+┊  ┊21┊\n+┊  ┊22┊type Mutation {\n+┊  ┊23┊  addMessage(chatId: ID!, content: String!): Message\n+┊  ┊24┊}\n```\n\n[}]: #\n\nNote that our mutation resolver `addMessage` receives a `chatId`. This is because when adding a message, we should update both the messages collection, and the correlated chat document. Mutations are resolved exactly like any other type in our resolvers manifest. The new resolver should look like this:\n\n[{]: <helper> (diffStep 5.1 files=\"resolvers\" module=\"server\")\n\n#### [Step 5.1: Add addMessage() mutation](https://github.com/Urigo/WhatsApp-Clone-Server/commit/a78d3cf)\n\n##### Changed schema&#x2F;resolvers.ts\n```diff\n@@ -25,6 +25,31 @@\n ┊25┊25┊      return chats.find(c => c.id === chatId)\n ┊26┊26┊    },\n ┊27┊27┊  },\n+┊  ┊28┊\n+┊  ┊29┊  Mutation: {\n+┊  ┊30┊    addMessage(root: any, { chatId, content }: any) {\n+┊  ┊31┊      const chatIndex = chats.findIndex(c => c.id === chatId)\n+┊  ┊32┊\n+┊  ┊33┊      if (chatIndex === -1) return null\n+┊  ┊34┊\n+┊  ┊35┊      const chat = chats[chatIndex]\n+┊  ┊36┊      const lastMessageId = chat.messages[chat.messages.length - 1]\n+┊  ┊37┊      const messageId = String(Number(lastMessageId) + 1)\n+┊  ┊38┊      const message = {\n+┊  ┊39┊        id: messageId,\n+┊  ┊40┊        createdAt: new Date(),\n+┊  ┊41┊        content,\n+┊  ┊42┊      }\n+┊  ┊43┊\n+┊  ┊44┊      messages.push(message)\n+┊  ┊45┊      chat.messages.push(messageId)\n+┊  ┊46┊      // The chat will appear at the top of the ChatsList component\n+┊  ┊47┊      chats.splice(chatIndex, 1)\n+┊  ┊48┊      chats.unshift(chat)\n+┊  ┊49┊\n+┊  ┊50┊      return message\n+┊  ┊51┊    }\n+┊  ┊52┊  }\n ┊28┊53┊}\n ┊29┊54┊\n ┊30┊55┊export default resolvers\n```\n\n[}]: #\n\nIn terms of testing, we will use a temporary solution for now to reset the DB each time we test a mutation. Since we make a modification in the DB, we need to make sure that each test is completely agnostic and doesn't affect one another, thus, we will export a `resetDB()` method from our `db.ts` module:\n\n[{]: <helper> (diffStep 5.2 files=\"db.ts\" module=\"server\")\n\n#### [Step 5.2: Test addMessage() mutation](https://github.com/Urigo/WhatsApp-Clone-Server/commit/6a8697e)\n\n##### Changed db.ts\n```diff\n@@ -1,49 +1,69 @@\n-┊ 1┊  ┊export const messages = [\n-┊ 2┊  ┊  {\n-┊ 3┊  ┊    id: '1',\n-┊ 4┊  ┊    content: \"You on your way?\",\n-┊ 5┊  ┊    createdAt: new Date(new Date('1-1-2019').getTime() - 60 * 1000 * 1000),\n-┊ 6┊  ┊  },\n-┊ 7┊  ┊  {\n-┊ 8┊  ┊    id: '2',\n-┊ 9┊  ┊    content: \"Hey, it's me\",\n-┊10┊  ┊    createdAt: new Date(new Date('1-1-2019').getTime() - 2 * 60 * 1000 * 1000),\n-┊11┊  ┊  },\n-┊12┊  ┊  {\n-┊13┊  ┊    id: '3',\n-┊14┊  ┊    content: \"I should buy a boat\",\n-┊15┊  ┊    createdAt: new Date(new Date('1-1-2019').getTime() - 24 * 60 * 1000 * 1000),\n-┊16┊  ┊  },\n-┊17┊  ┊  {\n-┊18┊  ┊    id: '4',\n-┊19┊  ┊    content: \"This is wicked good ice cream.\",\n-┊20┊  ┊    createdAt: new Date(new Date('1-1-2019').getTime() - 14 * 24 * 60 * 1000 * 1000),\n-┊21┊  ┊  },\n-┊22┊  ┊]\n+┊  ┊ 1┊export type Message = {\n+┊  ┊ 2┊  id: string\n+┊  ┊ 3┊  content: string\n+┊  ┊ 4┊  createdAt: Date\n+┊  ┊ 5┊}\n ┊23┊ 6┊\n-┊24┊  ┊export const chats = [\n-┊25┊  ┊  {\n-┊26┊  ┊    id: '1',\n-┊27┊  ┊    name: 'Ethan Gonzalez',\n-┊28┊  ┊    picture: 'https://randomuser.me/api/portraits/thumb/men/1.jpg',\n-┊29┊  ┊    messages: ['1'],\n-┊30┊  ┊  },\n-┊31┊  ┊  {\n-┊32┊  ┊    id: '2',\n-┊33┊  ┊    name: 'Bryan Wallace',\n-┊34┊  ┊    picture: 'https://randomuser.me/api/portraits/thumb/men/2.jpg',\n-┊35┊  ┊    messages: ['2'],\n-┊36┊  ┊  },\n-┊37┊  ┊  {\n-┊38┊  ┊    id: '3',\n-┊39┊  ┊    name: 'Avery Stewart',\n-┊40┊  ┊    picture: 'https://randomuser.me/api/portraits/thumb/women/1.jpg',\n-┊41┊  ┊    messages: ['3'],\n-┊42┊  ┊  },\n-┊43┊  ┊  {\n-┊44┊  ┊    id: '4',\n-┊45┊  ┊    name: 'Katie Peterson',\n-┊46┊  ┊    picture: 'https://randomuser.me/api/portraits/thumb/women/2.jpg',\n-┊47┊  ┊    messages: ['4'],\n-┊48┊  ┊  },\n-┊49┊  ┊]\n+┊  ┊ 7┊export type Chat = {\n+┊  ┊ 8┊  id: string\n+┊  ┊ 9┊  name: string\n+┊  ┊10┊  picture: string\n+┊  ┊11┊  messages: string[]\n+┊  ┊12┊}\n+┊  ┊13┊\n+┊  ┊14┊export const messages: Message[] = []\n+┊  ┊15┊export const chats: Chat[] = []\n+┊  ┊16┊\n+┊  ┊17┊export const resetDb = () => {\n+┊  ┊18┊  messages.splice(0, Infinity, ...[\n+┊  ┊19┊    {\n+┊  ┊20┊      id: '1',\n+┊  ┊21┊      content: \"You on your way?\",\n+┊  ┊22┊      createdAt: new Date(new Date('1-1-2019').getTime() - 60 * 1000 * 1000),\n+┊  ┊23┊    },\n+┊  ┊24┊    {\n+┊  ┊25┊      id: '2',\n+┊  ┊26┊      content: \"Hey, it's me\",\n+┊  ┊27┊      createdAt: new Date(new Date('1-1-2019').getTime() - 2 * 60 * 1000 * 1000),\n+┊  ┊28┊    },\n+┊  ┊29┊    {\n+┊  ┊30┊      id: '3',\n+┊  ┊31┊      content: \"I should buy a boat\",\n+┊  ┊32┊      createdAt: new Date(new Date('1-1-2019').getTime() - 24 * 60 * 1000 * 1000),\n+┊  ┊33┊    },\n+┊  ┊34┊    {\n+┊  ┊35┊      id: '4',\n+┊  ┊36┊      content: \"This is wicked good ice cream.\",\n+┊  ┊37┊      createdAt: new Date(new Date('1-1-2019').getTime() - 14 * 24 * 60 * 1000 * 1000),\n+┊  ┊38┊    },\n+┊  ┊39┊  ])\n+┊  ┊40┊\n+┊  ┊41┊  chats.splice(0, Infinity, ...[\n+┊  ┊42┊    {\n+┊  ┊43┊      id: '1',\n+┊  ┊44┊      name: 'Ethan Gonzalez',\n+┊  ┊45┊      picture: 'https://randomuser.me/api/portraits/thumb/men/1.jpg',\n+┊  ┊46┊      messages: ['1'],\n+┊  ┊47┊    },\n+┊  ┊48┊    {\n+┊  ┊49┊      id: '2',\n+┊  ┊50┊      name: 'Bryan Wallace',\n+┊  ┊51┊      picture: 'https://randomuser.me/api/portraits/thumb/men/2.jpg',\n+┊  ┊52┊      messages: ['2'],\n+┊  ┊53┊    },\n+┊  ┊54┊    {\n+┊  ┊55┊      id: '3',\n+┊  ┊56┊      name: 'Avery Stewart',\n+┊  ┊57┊      picture: 'https://randomuser.me/api/portraits/thumb/women/1.jpg',\n+┊  ┊58┊      messages: ['3'],\n+┊  ┊59┊    },\n+┊  ┊60┊    {\n+┊  ┊61┊      id: '4',\n+┊  ┊62┊      name: 'Katie Peterson',\n+┊  ┊63┊      picture: 'https://randomuser.me/api/portraits/thumb/women/2.jpg',\n+┊  ┊64┊      messages: ['4'],\n+┊  ┊65┊    },\n+┊  ┊66┊  ])\n+┊  ┊67┊}\n+┊  ┊68┊\n+┊  ┊69┊resetDb()\n```\n\n[}]: #\n\nAnd we will use the `beforeEach()` test hook to reset the `chats` and `messages` collections:\n\n[{]: <helper> (diffStep 5.2 files=\"tests\" module=\"server\")\n\n#### [Step 5.2: Test addMessage() mutation](https://github.com/Urigo/WhatsApp-Clone-Server/commit/6a8697e)\n\n##### Added tests&#x2F;mutations&#x2F;__snapshots__&#x2F;addMessage.test.ts.snap\n```diff\n@@ -0,0 +1,22 @@\n+┊  ┊ 1┊// Jest Snapshot v1, https://goo.gl/fbAQLP\n+┊  ┊ 2┊\n+┊  ┊ 3┊exports[`Mutation.addMessage should add message to specified chat 1`] = `\n+┊  ┊ 4┊Object {\n+┊  ┊ 5┊  \"addMessage\": Object {\n+┊  ┊ 6┊    \"content\": \"Hello World\",\n+┊  ┊ 7┊    \"id\": \"5\",\n+┊  ┊ 8┊  },\n+┊  ┊ 9┊}\n+┊  ┊10┊`;\n+┊  ┊11┊\n+┊  ┊12┊exports[`Mutation.addMessage should add message to specified chat 2`] = `\n+┊  ┊13┊Object {\n+┊  ┊14┊  \"chat\": Object {\n+┊  ┊15┊    \"id\": \"1\",\n+┊  ┊16┊    \"lastMessage\": Object {\n+┊  ┊17┊      \"content\": \"Hello World\",\n+┊  ┊18┊      \"id\": \"5\",\n+┊  ┊19┊    },\n+┊  ┊20┊  },\n+┊  ┊21┊}\n+┊  ┊22┊`;\n```\n\n##### Added tests&#x2F;mutations&#x2F;addMessage.test.ts\n```diff\n@@ -0,0 +1,49 @@\n+┊  ┊ 1┊import { createTestClient } from 'apollo-server-testing'\n+┊  ┊ 2┊import { ApolloServer, gql } from 'apollo-server-express'\n+┊  ┊ 3┊import schema from '../../schema'\n+┊  ┊ 4┊import { resetDb } from '../../db'\n+┊  ┊ 5┊\n+┊  ┊ 6┊describe('Mutation.addMessage', () => {\n+┊  ┊ 7┊  beforeEach(resetDb)\n+┊  ┊ 8┊\n+┊  ┊ 9┊  it('should add message to specified chat', async () => {\n+┊  ┊10┊    const server = new ApolloServer({ schema })\n+┊  ┊11┊\n+┊  ┊12┊    const { query, mutate } = createTestClient(server)\n+┊  ┊13┊\n+┊  ┊14┊    const addMessageRes = await mutate({\n+┊  ┊15┊      variables: { chatId: '1', content: 'Hello World' },\n+┊  ┊16┊      mutation: gql `\n+┊  ┊17┊        mutation AddMessage($chatId: ID!, $content: String!) {\n+┊  ┊18┊          addMessage(chatId: $chatId, content: $content) {\n+┊  ┊19┊            id\n+┊  ┊20┊            content\n+┊  ┊21┊          }\n+┊  ┊22┊        }\n+┊  ┊23┊      `,\n+┊  ┊24┊    })\n+┊  ┊25┊\n+┊  ┊26┊    expect(addMessageRes.data).toBeDefined()\n+┊  ┊27┊    expect(addMessageRes.errors).toBeUndefined()\n+┊  ┊28┊    expect(addMessageRes.data).toMatchSnapshot()\n+┊  ┊29┊\n+┊  ┊30┊    const getChatRes = await query({\n+┊  ┊31┊      variables: { chatId: '1' },\n+┊  ┊32┊      query: gql `\n+┊  ┊33┊        query GetChat($chatId: ID!) {\n+┊  ┊34┊          chat(chatId: $chatId) {\n+┊  ┊35┊            id\n+┊  ┊36┊            lastMessage {\n+┊  ┊37┊              id\n+┊  ┊38┊              content\n+┊  ┊39┊            }\n+┊  ┊40┊          }\n+┊  ┊41┊        }\n+┊  ┊42┊      `,\n+┊  ┊43┊    })\n+┊  ┊44┊\n+┊  ┊45┊    expect(getChatRes.data).toBeDefined()\n+┊  ┊46┊    expect(getChatRes.errors).toBeUndefined()\n+┊  ┊47┊    expect(getChatRes.data).toMatchSnapshot()\n+┊  ┊48┊  })\n+┊  ┊49┊})\n```\n\n[}]: #\n\nNow we have the infrastructure set for sending a new message and we can start using it in our client.\n\n**How to use a GraphQL mutation?**\n\nLike in the previous chapters, we're gonna use a React hook so we can run a mutation more efficiently in a React.Component. For this we're gonna use the [`useMutation()`](https://github.com/trojanowski/react-apollo-hooks#usemutation) react hook. The first argument of the hook is the mutation string, and the second one is the [mutation options](https://www.apollographql.com/docs/react/api/apollo-client.html#ApolloClient.mutate). We're gonna provide our mutation call with a single option called `optimisticResponse`.\n\nOptimistic response is a common pattern that will update the state of the component twice so we can have a better UX: First it updates the component's state with the predicted result, and then it will update the state with the actual result.\n\n\n\n![optimistic_response](https://user-images.githubusercontent.com/7648874/54883302-859df900-4e9f-11e9-9eb7-a98108cd2482.png)\n\n\nThis is how the component should look like:\n\n[{]: <helper> (diffStep 8.1 module=\"client\")\n\n#### [Step 8.1: Send message with a GraphQL mutation](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/1080824)\n\n##### Changed src&#x2F;components&#x2F;ChatRoomScreen&#x2F;index.tsx\n```diff\n@@ -1,7 +1,7 @@\n ┊1┊1┊import gql from 'graphql-tag'\n ┊2┊2┊import * as React from 'react'\n ┊3┊3┊import { useCallback } from 'react'\n-┊4┊ ┊import { useApolloClient, useQuery } from 'react-apollo-hooks'\n+┊ ┊4┊import { useApolloClient, useQuery, useMutation } from 'react-apollo-hooks'\n ┊5┊5┊import styled from 'styled-components'\n ┊6┊6┊import ChatNavbar from './ChatNavbar'\n ┊7┊7┊import MessageInput from './MessageInput'\n```\n```diff\n@@ -29,28 +29,47 @@\n ┊29┊29┊  }\n ┊30┊30┊`\n ┊31┊31┊\n+┊  ┊32┊const addMessageMutation = gql `\n+┊  ┊33┊  mutation AddMessage($chatId: ID!, $content: String!) {\n+┊  ┊34┊    addMessage(chatId: $chatId, content: $content) {\n+┊  ┊35┊      id\n+┊  ┊36┊      content\n+┊  ┊37┊      createdAt\n+┊  ┊38┊    }\n+┊  ┊39┊  }\n+┊  ┊40┊`\n+┊  ┊41┊\n ┊32┊42┊const ChatRoomScreen = ({ history, match }) => {\n ┊33┊43┊  const { params: { chatId } } = match\n ┊34┊44┊  const client = useApolloClient()\n ┊35┊45┊  const { data: { chat } } = useQuery(getChatQuery, {\n ┊36┊46┊    variables: { chatId }\n ┊37┊47┊  })\n+┊  ┊48┊  const addMessage = useMutation(addMessageMutation)\n ┊38┊49┊\n ┊39┊50┊  const onSendMessage = useCallback((content) => {\n-┊40┊  ┊    const message = {\n-┊41┊  ┊      id: chat.messages.length + 1,\n-┊42┊  ┊      createdAt: Date.now(),\n-┊43┊  ┊      content,\n-┊44┊  ┊    }\n-┊45┊  ┊\n-┊46┊  ┊    client.writeQuery({\n-┊47┊  ┊      query: getChatQuery,\n-┊48┊  ┊      variables: { chatId },\n-┊49┊  ┊      data: {\n-┊50┊  ┊        chat: {\n-┊51┊  ┊          ...chat,\n-┊52┊  ┊          messages: chat.messages.concat(message),\n-┊53┊  ┊        },\n+┊  ┊51┊    addMessage({\n+┊  ┊52┊      variables: { chatId, content },\n+┊  ┊53┊      optimisticResponse: {\n+┊  ┊54┊        __typename: 'Mutation',\n+┊  ┊55┊        addMessage: {\n+┊  ┊56┊          __typename: 'Message',\n+┊  ┊57┊          id: Math.random().toString(36).substr(2, 9),\n+┊  ┊58┊          createdAt: new Date(),\n+┊  ┊59┊          content,\n+┊  ┊60┊        }\n+┊  ┊61┊      },\n+┊  ┊62┊      update: (client, { data: { addMessage } }) => {\n+┊  ┊63┊        client.writeQuery({\n+┊  ┊64┊          query: getChatQuery,\n+┊  ┊65┊          variables: { chatId },\n+┊  ┊66┊          data: {\n+┊  ┊67┊            chat: {\n+┊  ┊68┊              ...chat,\n+┊  ┊69┊              messages: chat.messages.concat(addMessage),\n+┊  ┊70┊            },\n+┊  ┊71┊          },\n+┊  ┊72┊        })\n ┊54┊73┊      },\n ┊55┊74┊    })\n ┊56┊75┊  }, [chat])\n```\n\n[}]: #\n\nNote that unlike `useQuery()`, `useMutation()` returns a callback that will run the mutation only once called, NOT immediately. Seemingly, everything works fine, but if you'll try to navigate from `ChatsListScreen` to `ChatRoomScreen`, send a message, and then go back, you'll see that the last message was not updated. So why is that exactly?\n\n**Cache updating**\n\nAs explained in the previous chapter, Apollo-Client will cache all the results in a data-store. Later on, rather than re-fetching the data, it will look up for the result in the store and will serve it to you in case it exists. That means, that even though we ran the mutation and updated the data on the server, our data-store is still left behind and it needs to be updated as well, otherwise Apollo-Client will see nothing wrong with the outcome.\n\nApollo-Client stores the data in a hash, where the key represents the query and the value represents the retrieved result. This means that the cache will need to be updated for:\n\n\n\n*   `chats` query - which we already did, without really diving into the reason behind it.\n*   `chat(chatId: $chatId)` where `chatId` is the chat that was just mutated.\n\nIndeed, a query will be duplicated for each and every distinct set of parameters. So potentially our data-store can grow infinite amount of times, and we will need to take care of it and manage it correctly, so things won't get out of hand.\n\nTo update a query, we will first export the `getChats` query to a separate file so it can be imported in the `ChatRoomScreen`. We will define all our GraphQL assets under the `src/graphql` directory:\n\n[{]: <helper> (diffStep 8.2 files=\"graphql\" module=\"client\")\n\n#### [Step 8.2: Rewrite lastMessage to chats query](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/a7b69fa)\n\n##### Added src&#x2F;graphql&#x2F;queries&#x2F;chats.query.ts\n```diff\n@@ -0,0 +1,16 @@\n+┊  ┊ 1┊import gql from 'graphql-tag'\n+┊  ┊ 2┊\n+┊  ┊ 3┊export default gql `\n+┊  ┊ 4┊  query Chats {\n+┊  ┊ 5┊    chats {\n+┊  ┊ 6┊      id\n+┊  ┊ 7┊      name\n+┊  ┊ 8┊      picture\n+┊  ┊ 9┊      lastMessage {\n+┊  ┊10┊        id\n+┊  ┊11┊        content\n+┊  ┊12┊        createdAt\n+┊  ┊13┊      }\n+┊  ┊14┊    }\n+┊  ┊15┊  }\n+┊  ┊16┊`\n```\n\n##### Added src&#x2F;graphql&#x2F;queries&#x2F;index.ts\n```diff\n@@ -0,0 +1 @@\n+┊ ┊1┊export { default as chats } from './chats.query'\n```\n\n[}]: #\n\nAnd then we will read the memoized result from the store using [`client.readQuery`](https://www.apollographql.com/docs/react/features/caching.html#readquery), update it, and then rewrite it using [`client.writeQuery`](https://www.apollographql.com/docs/react/features/caching.html#writequery-and-writefragment). We can gain access to the client object via the `update` callback which will be triggered right after the mutation has been successfully executed. This is how it should look like:\n\n[{]: <helper> (diffStep 8.2 files=\"components\" module=\"client\")\n\n#### [Step 8.2: Rewrite lastMessage to chats query](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/a7b69fa)\n\n##### Changed src&#x2F;components&#x2F;ChatRoomScreen&#x2F;index.tsx\n```diff\n@@ -6,6 +6,7 @@\n ┊ 6┊ 6┊import ChatNavbar from './ChatNavbar'\n ┊ 7┊ 7┊import MessageInput from './MessageInput'\n ┊ 8┊ 8┊import MessagesList from './MessagesList'\n+┊  ┊ 9┊import * as queries from '../../graphql/queries'\n ┊ 9┊10┊\n ┊10┊11┊const Container = styled.div `\n ┊11┊12┊  background: url(/assets/chat-background.jpg);\n```\n```diff\n@@ -70,6 +71,40 @@\n ┊ 70┊ 71┊            },\n ┊ 71┊ 72┊          },\n ┊ 72┊ 73┊        })\n+┊   ┊ 74┊\n+┊   ┊ 75┊        rewriteChats:\n+┊   ┊ 76┊        {\n+┊   ┊ 77┊          let data\n+┊   ┊ 78┊          try {\n+┊   ┊ 79┊            data = client.readQuery({\n+┊   ┊ 80┊              query: queries.chats,\n+┊   ┊ 81┊            })\n+┊   ┊ 82┊          } catch (e) {\n+┊   ┊ 83┊            break rewriteChats\n+┊   ┊ 84┊          }\n+┊   ┊ 85┊\n+┊   ┊ 86┊          if (!data) break rewriteChats\n+┊   ┊ 87┊\n+┊   ┊ 88┊          const chats = data.chats\n+┊   ┊ 89┊\n+┊   ┊ 90┊          if (!chats) break rewriteChats\n+┊   ┊ 91┊\n+┊   ┊ 92┊          const chatIndex = chats.findIndex(c => c.id === chatId)\n+┊   ┊ 93┊\n+┊   ┊ 94┊          if (chatIndex === -1) break rewriteChats\n+┊   ┊ 95┊\n+┊   ┊ 96┊          const chat = chats[chatIndex]\n+┊   ┊ 97┊\n+┊   ┊ 98┊          chat.lastMessage = addMessage\n+┊   ┊ 99┊          // The chat will appear at the top of the ChatsList component\n+┊   ┊100┊          chats.splice(chatIndex, 1)\n+┊   ┊101┊          chats.unshift(chat)\n+┊   ┊102┊\n+┊   ┊103┊          client.writeQuery({\n+┊   ┊104┊            query: queries.chats,\n+┊   ┊105┊            data: { chats: chats },\n+┊   ┊106┊          })\n+┊   ┊107┊        }\n ┊ 73┊108┊      },\n ┊ 74┊109┊    })\n ┊ 75┊110┊  }, [chat])\n```\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;ChatsList.test.tsx\n```diff\n@@ -5,6 +5,7 @@\n ┊ 5┊ 5┊import { cleanup, render, fireEvent, wait, waitForDomChange } from 'react-testing-library'\n ┊ 6┊ 6┊import { mockApolloClient } from '../../test-helpers'\n ┊ 7┊ 7┊import ChatsList, { getChatsQuery } from './ChatsList'\n+┊  ┊ 8┊import * as queries from '../../graphql/queries'\n ┊ 8┊ 9┊\n ┊ 9┊10┊describe('ChatsList', () => {\n ┊10┊11┊  afterEach(() => {\n```\n```diff\n@@ -15,7 +16,7 @@\n ┊15┊16┊  it('renders fetched chats data', async () => {\n ┊16┊17┊    const client = mockApolloClient([\n ┊17┊18┊      {\n-┊18┊  ┊        request: { query: getChatsQuery },\n+┊  ┊19┊        request: { query: queries.chats },\n ┊19┊20┊        result: {\n ┊20┊21┊          data: {\n ┊21┊22┊            chats: [\n```\n```diff\n@@ -56,7 +57,7 @@\n ┊56┊57┊  it('should navigate to the target chat room on chat item click', async () => {\n ┊57┊58┊    const client = mockApolloClient([\n ┊58┊59┊      {\n-┊59┊  ┊        request: { query: getChatsQuery },\n+┊  ┊60┊        request: { query: queries.chats },\n ┊60┊61┊        result: {\n ┊61┊62┊          data: {\n ┊62┊63┊            chats: [\n```\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;ChatsList.tsx\n```diff\n@@ -5,6 +5,7 @@\n ┊ 5┊ 5┊import { useCallback } from 'react'\n ┊ 6┊ 6┊import { useQuery } from 'react-apollo-hooks'\n ┊ 7┊ 7┊import styled from 'styled-components'\n+┊  ┊ 8┊import * as queries from '../../graphql/queries'\n ┊ 8┊ 9┊\n ┊ 9┊10┊const Container = styled.div `\n ┊10┊11┊  height: calc(100% - 56px);\n```\n```diff\n@@ -58,23 +59,8 @@\n ┊58┊59┊  font-size: 13px;\n ┊59┊60┊`\n ┊60┊61┊\n-┊61┊  ┊export const getChatsQuery = gql `\n-┊62┊  ┊  query GetChats {\n-┊63┊  ┊    chats {\n-┊64┊  ┊      id\n-┊65┊  ┊      name\n-┊66┊  ┊      picture\n-┊67┊  ┊      lastMessage {\n-┊68┊  ┊        id\n-┊69┊  ┊        content\n-┊70┊  ┊        createdAt\n-┊71┊  ┊      }\n-┊72┊  ┊    }\n-┊73┊  ┊  }\n-┊74┊  ┊`\n-┊75┊  ┊\n ┊76┊62┊const ChatsList = ({ history }) => {\n-┊77┊  ┊  const { data: { chats = [] } } = useQuery(getChatsQuery)\n+┊  ┊63┊  const { data: { chats = [] } } = useQuery(queries.chats)\n ┊78┊64┊\n ┊79┊65┊  const navToChat = useCallback((chat) => {\n ┊80┊66┊    history.push(`chats/${chat.id}`)\n```\n\n[}]: #\n\nRight now what happens is that we update a single chat document twice: Once for the `chats` query and another time for the `chat($chatId)` query. This work is redundant and become more complex as we add more `chat` related queries. To solve it, we can define and use a [GraphQL fragment](https://www.apollographql.com/docs/react/advanced/fragments.html).\n\n**Using Fragments**\n\nA GraphQL fragment is a shared piece of query logic.\n\n```graphql\nfragment NameParts on Person {\n  firstName\n  lastName\n}\n\nquery GetPerson {\n  people(id: \"7\") {\n    ...NameParts\n    avatar(size: LARGE)\n  }\n}\n```\n\nIt's important to note that the component after the `on` clause is designated for the type we are selecting from. In this case, `people` is of type `Person` and we want to select the `firstName` and `lastName` fields from `people(id: \"7\")`.\n\nApollo maps the fragment ID to its retrieved data in the store. By default, Apollo will compose the fragment ID out of the entity type and the ID of the document. For example, for a `Chat` document with an ID of `7`, the fragment ID would be `Chat:7`. This behavior can be modified, but there's no need to.\n\nWe will define the following fragments in our app:\n\n\n\n*   `Message` - represents a message\n*   `Chat` - represents a chat, **without its messages list**.\n*   `FullChat` - represents a chat, **including its messages list**.\n\nOnce we define the fragments we can start embedding them in our queries. We will create a new directory path `src/graphql/fragments`, and inside we will create a dedicated fragment file for each fragment type: `message.fragment.ts`, `chat.fragment.ts` and `fullChat.fragment.ts`:\n\n[{]: <helper> (diffStep 8.3 files=\"graphql/fragments\" module=\"client\")\n\n#### [Step 8.3: Update queries to use GraphQL fragments](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/3cd6e31)\n\n##### Added src&#x2F;graphql&#x2F;fragments&#x2F;chat.fragment.ts\n```diff\n@@ -0,0 +1,14 @@\n+┊  ┊ 1┊import gql from 'graphql-tag'\n+┊  ┊ 2┊import message from './message.fragment'\n+┊  ┊ 3┊\n+┊  ┊ 4┊export default gql `\n+┊  ┊ 5┊  fragment Chat on Chat {\n+┊  ┊ 6┊    id\n+┊  ┊ 7┊    name\n+┊  ┊ 8┊    picture\n+┊  ┊ 9┊    lastMessage {\n+┊  ┊10┊      ...Message\n+┊  ┊11┊    }\n+┊  ┊12┊  }\n+┊  ┊13┊  ${message}\n+┊  ┊14┊`\n```\n\n##### Added src&#x2F;graphql&#x2F;fragments&#x2F;fullChat.fragment.ts\n```diff\n@@ -0,0 +1,14 @@\n+┊  ┊ 1┊import gql from 'graphql-tag'\n+┊  ┊ 2┊import chat from './chat.fragment'\n+┊  ┊ 3┊import message from './message.fragment'\n+┊  ┊ 4┊\n+┊  ┊ 5┊export default gql `\n+┊  ┊ 6┊  fragment FullChat on Chat {\n+┊  ┊ 7┊    ...Chat\n+┊  ┊ 8┊    messages {\n+┊  ┊ 9┊      ...Message\n+┊  ┊10┊    }\n+┊  ┊11┊  }\n+┊  ┊12┊  ${chat}\n+┊  ┊13┊  ${message}\n+┊  ┊14┊`\n```\n\n##### Added src&#x2F;graphql&#x2F;fragments&#x2F;index.ts\n```diff\n@@ -0,0 +1,3 @@\n+┊ ┊1┊export { default as chat } from './chat.fragment'\n+┊ ┊2┊export { default as fullChat } from './fullChat.fragment'\n+┊ ┊3┊export { default as message } from './message.fragment'\n```\n\n##### Added src&#x2F;graphql&#x2F;fragments&#x2F;message.fragment.ts\n```diff\n@@ -0,0 +1,9 @@\n+┊ ┊1┊import gql from 'graphql-tag'\n+┊ ┊2┊\n+┊ ┊3┊export default gql`\n+┊ ┊4┊  fragment Message on Message {\n+┊ ┊5┊    id\n+┊ ┊6┊    createdAt\n+┊ ┊7┊    content\n+┊ ┊8┊  }\n+┊ ┊9┊`\n```\n\n[}]: #\n\nAnd now that we have the fragments available to us, let's embed them in the relevant queries:\n\n[{]: <helper> (diffStep 8.3 files=\"components, graphql/queries\" module=\"client\")\n\n#### [Step 8.3: Update queries to use GraphQL fragments](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/3cd6e31)\n\n##### Changed src&#x2F;components&#x2F;ChatRoomScreen&#x2F;index.tsx\n```diff\n@@ -7,6 +7,7 @@\n ┊ 7┊ 7┊import MessageInput from './MessageInput'\n ┊ 8┊ 8┊import MessagesList from './MessagesList'\n ┊ 9┊ 9┊import * as queries from '../../graphql/queries'\n+┊  ┊10┊import * as fragments from '../../graphql/fragments'\n ┊10┊11┊\n ┊11┊12┊const Container = styled.div `\n ┊12┊13┊  background: url(/assets/chat-background.jpg);\n```\n```diff\n@@ -18,26 +19,19 @@\n ┊18┊19┊const getChatQuery = gql `\n ┊19┊20┊  query GetChat($chatId: ID!) {\n ┊20┊21┊    chat(chatId: $chatId) {\n-┊21┊  ┊      id\n-┊22┊  ┊      name\n-┊23┊  ┊      picture\n-┊24┊  ┊      messages {\n-┊25┊  ┊        id\n-┊26┊  ┊        content\n-┊27┊  ┊        createdAt\n-┊28┊  ┊      }\n+┊  ┊22┊      ...FullChat\n ┊29┊23┊    }\n ┊30┊24┊  }\n+┊  ┊25┊  ${fragments.fullChat}\n ┊31┊26┊`\n ┊32┊27┊\n ┊33┊28┊const addMessageMutation = gql `\n ┊34┊29┊  mutation AddMessage($chatId: ID!, $content: String!) {\n ┊35┊30┊    addMessage(chatId: $chatId, content: $content) {\n-┊36┊  ┊      id\n-┊37┊  ┊      content\n-┊38┊  ┊      createdAt\n+┊  ┊31┊      ...Message\n ┊39┊32┊    }\n ┊40┊33┊  }\n+┊  ┊34┊  ${fragments.message}\n ┊41┊35┊`\n ┊42┊36┊\n ┊43┊37┊const ChatRoomScreen = ({ history, match }) => {\n```\n\n##### Changed src&#x2F;graphql&#x2F;queries&#x2F;chats.query.ts\n```diff\n@@ -1,16 +1,11 @@\n ┊ 1┊ 1┊import gql from 'graphql-tag'\n+┊  ┊ 2┊import * as fragments from '../fragments'\n ┊ 2┊ 3┊\n ┊ 3┊ 4┊export default gql `\n ┊ 4┊ 5┊  query Chats {\n ┊ 5┊ 6┊    chats {\n-┊ 6┊  ┊      id\n-┊ 7┊  ┊      name\n-┊ 8┊  ┊      picture\n-┊ 9┊  ┊      lastMessage {\n-┊10┊  ┊        id\n-┊11┊  ┊        content\n-┊12┊  ┊        createdAt\n-┊13┊  ┊      }\n+┊  ┊ 7┊      ...Chat\n ┊14┊ 8┊    }\n ┊15┊ 9┊  }\n+┊  ┊10┊  ${fragments.chat}\n ┊16┊11┊`\n```\n\n[}]: #\n\nSimilarly to query rewriting, we will use the [`readFragment()`](https://www.apollographql.com/docs/react/features/caching.html#readfragment) and [`writeFragment()`](https://www.apollographql.com/docs/react/features/caching.html#writefragment) methods in the same way to rewrite the fragments. When working with a fragment we need to compose its ID, just like explained earlier. The default mapping function called `defaultDataIdFromObject` can be imported from `apollo-cache-inmemory` and be used to specify the fragment that we would like to read/write. Accordingly, we're gonna replace all our query re-writings with fragments re-writings, as we don't need them anymore:\n\n[{]: <helper> (diffStep 8.4 module=\"client\")\n\n#### [Step 8.4: Rewrite fragments](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/c97ebaf)\n\n##### Changed src&#x2F;components&#x2F;ChatRoomScreen&#x2F;index.tsx\n```diff\n@@ -1,3 +1,4 @@\n+┊ ┊1┊import { defaultDataIdFromObject } from 'apollo-cache-inmemory'\n ┊1┊2┊import gql from 'graphql-tag'\n ┊2┊3┊import * as React from 'react'\n ┊3┊4┊import { useCallback } from 'react'\n```\n```diff\n@@ -55,15 +56,27 @@\n ┊55┊56┊        }\n ┊56┊57┊      },\n ┊57┊58┊      update: (client, { data: { addMessage } }) => {\n-┊58┊  ┊        client.writeQuery({\n-┊59┊  ┊          query: getChatQuery,\n-┊60┊  ┊          variables: { chatId },\n-┊61┊  ┊          data: {\n-┊62┊  ┊            chat: {\n-┊63┊  ┊              ...chat,\n-┊64┊  ┊              messages: chat.messages.concat(addMessage),\n-┊65┊  ┊            },\n-┊66┊  ┊          },\n+┊  ┊59┊        let fullChat\n+┊  ┊60┊        try {\n+┊  ┊61┊          fullChat = client.readFragment({\n+┊  ┊62┊            id: defaultDataIdFromObject(chat),\n+┊  ┊63┊            fragment: fragments.fullChat,\n+┊  ┊64┊            fragmentName: 'FullChat',\n+┊  ┊65┊          })\n+┊  ┊66┊        } catch (e) {\n+┊  ┊67┊          return\n+┊  ┊68┊        }\n+┊  ┊69┊\n+┊  ┊70┊        if (fullChat.messages.some(m => m.id === message.id)) return\n+┊  ┊71┊\n+┊  ┊72┊        fullChat.messages.push(addMessage)\n+┊  ┊73┊        fullChat.lastMessage = addMessage\n+┊  ┊74┊\n+┊  ┊75┊        client.writeFragment({\n+┊  ┊76┊          id: defaultDataIdFromObject(chat),\n+┊  ┊77┊          fragment: fragments.fullChat,\n+┊  ┊78┊          fragmentName: 'FullChat',\n+┊  ┊79┊          data: fullChat,\n ┊67┊80┊        })\n ┊68┊81┊\n ┊69┊82┊        rewriteChats:\n```\n```diff\n@@ -89,7 +102,6 @@\n ┊ 89┊102┊\n ┊ 90┊103┊          const chat = chats[chatIndex]\n ┊ 91┊104┊\n-┊ 92┊   ┊          chat.lastMessage = addMessage\n ┊ 93┊105┊          // The chat will appear at the top of the ChatsList component\n ┊ 94┊106┊          chats.splice(chatIndex, 1)\n ┊ 95┊107┊          chats.unshift(chat)\n```\n\n[}]: #"
          },
          {
            "manualTitle": "Step 9: Type safety with GraphQL Code Generator",
            "stepRevision": "5b254da7a9da6da8f3a1d1e6af83dcb4e3efd281",
            "manualView": "So far we've been just writing code. If there was an error we would most likely discover it during runtime. As a reminder, we've created a project which is based on TypeScript, but we haven't really took any advantage of TypeScript's type safety mechanism. Currently, the TypeScript compiler is configured to work on loose mode, so any object which is not bound to any type will be converted to `any` - a type which is compatible with any type of casting and will ignore type errors.\n\nSo far it's been very convenient because we've only started to learn about building an app and the ecosystem around it, but for a long term project it's would be very handy to take a full advantage of TypeScript and not let it go under the radar. So where exactly are we missing type checkings? In the core of our project - when dealing with GraphQL documents.\n\nWhen we run a query, or a mutation, we wanna make sure that we use the received data correctly, based on its intended shape and form. For example, given the following GraphQL query:\n\n```graphql\nquery Chats {\n  chats {\n    id\n    name\n    picture\n  }\n}\n```\n\nWe want to have the following TypeScript type:\n\n```ts\nexport type Chat = {\n  __typename?: \"Chat\"\n  id: string\n  name: string\n  picture: string\n}\n\nexport type ChatQuery = {\n  __typename?: \"Query\"\n  chats: Chats[]\n}\n\n```\n\nSo later on we can use it with `react-apollo-hooks` like so:\n\n```ts\nuseQuery<ChatsQuery>(getChatsQuery)\n```\n\nEverything looks nice in theory, but the main issue that arises from having type definitions is that we need to maintain and sync 2 similar code bases: A GraphQL schema and TypeScript type definitions. Both are essentially the same, and if so, why do we even need to maintain 2 code bases? Isn't there a tool which does that for us? A question which brings us straight to the point of the chapter.\n\n**Introducing: GraphQL Code Generator**\n\nWith [GraphQL Code Generator](https://graphql-code-generator.com/) we can generate TypeScript definitions given a GraphQL schema, and a set of GraphQL documents if they are presented to us.\n\n\n\n![graphql-codegen](https://user-images.githubusercontent.com/7648874/54940897-9f564380-4f66-11e9-9891-3b994a1daef1.png)\n\n\nGraphQL Code Generator is a simple CLI tool that operates based on a configuration file and can generate TypeScript types for both Client and Server. We will start with generating types for the server, as the client types are dependent on them.\n\nIn the server project, install GraphQL Code Generator via NPM (or Yarn)\n\n    $ npm install @graphql-codegen/cli --dev\n\nNow GraphQL Code Generator can be used directly from the `scripts` section in the `package.json` file using the `gql-gen` binary. We're gonna call the code generation script \"codegen\":\n\n```json\n{\n  \"codegen\": \"gql-gen\"\n}\n```\n\nThis command will automatically be referenced to a configuration file in the root of our project called `codegen.yml`. The essence of this file is to provide the code generator with the GraphQL schema, GraphQL documents, the output path of the type definition file/s and a set of plug-ins. More about the configuration file can be found in the [official website](https://graphql-code-generator.com/docs/getting-started/codegen-config).\n\nIn the server project, we will generate the `types/graphql.d.ts` file and we will use a couple of plug-ins to do that:\n\n\n\n*   `@graphql-codegen/typescript` - Will generate the core TypeScript types from our GraphQL schema.\n*   `@graphql-codegen/typescript-resolvers` - Will generate resolvers signatures with the generated TypeScript types.\n\n> A full list of available plugins is available [here](https://graphql-code-generator.com/docs/plugins/). In addition, you can write your own [custom plugin](https://graphql-code-generator.com/docs/custom-codegen/write-your-plugin).\n\nLet's install these 2 plugins:\n\n    $ npm install @graphql-codegen/typescript @graphql-codegen/typescript-resolvers --dev\n\nAnd write the `codegen.yml` file:\n\n[{]: <helper> (diffStep 6.1 files=\"codegen.yml\" module=\"server\")\n\n#### [Step 6.1: Setup GraphQL Code Generator](https://github.com/Urigo/WhatsApp-Clone-Server/commit/d56b979)\n\n##### Added codegen.yml\n```diff\n@@ -0,0 +1,16 @@\n+┊  ┊ 1┊schema: ./schema/typeDefs.graphql\n+┊  ┊ 2┊overwrite: true\n+┊  ┊ 3┊generates:\n+┊  ┊ 4┊  ./types/graphql.d.ts:\n+┊  ┊ 5┊    plugins:\n+┊  ┊ 6┊      - typescript\n+┊  ┊ 7┊      - typescript-resolvers\n+┊  ┊ 8┊    config:\n+┊  ┊ 9┊      mappers:\n+┊  ┊10┊        # import { Message } from '../db'\n+┊  ┊11┊        # The root types of Message resolvers\n+┊  ┊12┊        Message: ../db#Message\n+┊  ┊13┊        Chat: ../db#Chat\n+┊  ┊14┊      scalars:\n+┊  ┊15┊        # e.g. Message.createdAt will be of type Date\n+┊  ┊16┊        Date: Date\n```\n\n[}]: #\n\n> See inline comments to learn more about our configuration setup.\n\nNow if you'll run `$ npm run codegen` you should see that a new file `types/graphql.d.ts` has been generated with all the necessary TypeScript types. Since these types are very likely to change as we extend our schema, there's no need to include them in our project, thus it's recommended to add the appropriate .gitignore rule:\n\n[{]: <helper> (diffStep 6.1 files=\".gitignore\" module=\"server\")\n\n#### [Step 6.1: Setup GraphQL Code Generator](https://github.com/Urigo/WhatsApp-Clone-Server/commit/d56b979)\n\n##### Changed .gitignore\n```diff\n@@ -1,2 +1,3 @@\n ┊1┊1┊node_modules\n-┊2┊ ┊npm-debug.log🚫↵\n+┊ ┊2┊npm-debug.log\n+┊ ┊3┊types/graphql.d.ts🚫↵\n```\n\n[}]: #\n\nNow we can import the `IResolvers` type from the file we've just created and use it in the `resolvers.ts` file to ensure our resolvers handlers have the right signature:\n\n[{]: <helper> (diffStep 6.2 module=\"server\")\n\n#### [Step 6.2: Type resolvers](https://github.com/Urigo/WhatsApp-Clone-Server/commit/4e19e90)\n\n##### Changed schema&#x2F;index.ts\n```diff\n@@ -1,7 +1,10 @@\n ┊ 1┊ 1┊import { importSchema } from 'graphql-import'\n-┊ 2┊  ┊import { makeExecutableSchema } from 'graphql-tools'\n+┊  ┊ 2┊import { makeExecutableSchema, IResolvers } from 'graphql-tools'\n ┊ 3┊ 3┊import resolvers from './resolvers'\n ┊ 4┊ 4┊\n ┊ 5┊ 5┊const typeDefs = importSchema('schema/typeDefs.graphql')\n ┊ 6┊ 6┊\n-┊ 7┊  ┊export default makeExecutableSchema({ resolvers, typeDefs })\n+┊  ┊ 7┊export default makeExecutableSchema({\n+┊  ┊ 8┊  resolvers: resolvers as IResolvers,\n+┊  ┊ 9┊  typeDefs,\n+┊  ┊10┊})\n```\n\n##### Changed schema&#x2F;resolvers.ts\n```diff\n@@ -1,18 +1,19 @@\n ┊ 1┊ 1┊import { GraphQLDateTime } from 'graphql-iso-date'\n-┊ 2┊  ┊import { chats, messages } from '../db'\n+┊  ┊ 2┊import { Message, chats, messages } from '../db'\n+┊  ┊ 3┊import { Resolvers } from '../types/graphql'\n ┊ 3┊ 4┊\n-┊ 4┊  ┊const resolvers = {\n+┊  ┊ 5┊const resolvers: Resolvers = {\n ┊ 5┊ 6┊  Date: GraphQLDateTime,\n ┊ 6┊ 7┊\n ┊ 7┊ 8┊  Chat: {\n-┊ 8┊  ┊    messages(chat: any) {\n+┊  ┊ 9┊    messages(chat) {\n ┊ 9┊10┊      return messages.filter(m => chat.messages.includes(m.id))\n ┊10┊11┊    },\n ┊11┊12┊\n-┊12┊  ┊    lastMessage(chat: any) {\n+┊  ┊13┊    lastMessage(chat) {\n ┊13┊14┊      const lastMessage = chat.messages[chat.messages.length - 1]\n ┊14┊15┊\n-┊15┊  ┊      return messages.find(m => m.id === lastMessage)\n+┊  ┊16┊      return messages.find(m => m.id === lastMessage) || null\n ┊16┊17┊    },\n ┊17┊18┊  },\n ┊18┊19┊\n```\n```diff\n@@ -21,13 +22,13 @@\n ┊21┊22┊      return chats\n ┊22┊23┊    },\n ┊23┊24┊\n-┊24┊  ┊    chat(root: any, { chatId }: any) {\n-┊25┊  ┊      return chats.find(c => c.id === chatId)\n+┊  ┊25┊    chat(root, { chatId }) {\n+┊  ┊26┊      return chats.find(c => c.id === chatId) || null\n ┊26┊27┊    },\n ┊27┊28┊  },\n ┊28┊29┊\n ┊29┊30┊  Mutation: {\n-┊30┊  ┊    addMessage(root: any, { chatId, content }: any) {\n+┊  ┊31┊    addMessage(root, { chatId, content }) {\n ┊31┊32┊      const chatIndex = chats.findIndex(c => c.id === chatId)\n ┊32┊33┊\n ┊33┊34┊      if (chatIndex === -1) return null\n```\n```diff\n@@ -35,7 +36,7 @@\n ┊35┊36┊      const chat = chats[chatIndex]\n ┊36┊37┊      const recentMessage = messages[messages.length - 1]\n ┊37┊38┊      const messageId = String(Number(recentMessage.id) + 1)\n-┊38┊  ┊      const message = {\n+┊  ┊39┊      const message: Message = {\n ┊39┊40┊        id: messageId,\n ┊40┊41┊        createdAt: new Date(),\n ┊41┊42┊        content,\n```\n\n[}]: #\n\nWe will now repeat the same process in the client with few tweaks. Again, we will install GraphQL Code Generator:\n\n    $ npm install @graphql-codegen/cli --dev\n\nAnd we will define a script:\n\n```json\n{\n  \"codegen\": \"gql-gen\"\n}\n```\n\nThis time around, because we're in the client, we will define a set of glob paths that will specify which files contain GraphQL documents. GraphQL Code Generator is smart enough to automatically recognize the documents within these files by looking at the `gql` template literal calls using the `typescript-operations` package. We will be using a plugin called `typescript-react-apollo` to generate React/Apollo-GraphQL hooks that can be used in our function components. Let's install the necessary plugins:\n\n    $ npm install @graphql-codegen/typescript @graphql-codegen/typescript-operations @graphql-codegen/typescript-react-apollo --dev\n\nAnd we will write the `codegen.yml` file:\n\n[{]: <helper> (diffStep 9.1 files=\"codegen.yml\" module=\"client\")\n\n#### [Step 9.1: Setup GraphQL Code Generator](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/1adba2d)\n\n##### Added codegen.yml\n```diff\n@@ -0,0 +1,19 @@\n+┊  ┊ 1┊schema: ../Whatsapp-Clone-Server/schema/typeDefs.graphql\n+┊  ┊ 2┊documents:\n+┊  ┊ 3┊  - ./src/components/**/*.tsx\n+┊  ┊ 4┊  - ./src/graphql/fragments/**/*.ts\n+┊  ┊ 5┊  - ./src/graphql/queries/**/*.ts\n+┊  ┊ 6┊overwrite: true\n+┊  ┊ 7┊generates:\n+┊  ┊ 8┊  ./src/graphql/types.tsx:\n+┊  ┊ 9┊    plugins:\n+┊  ┊10┊      - typescript\n+┊  ┊11┊      - typescript-operations\n+┊  ┊12┊      - typescript-react-apollo\n+┊  ┊13┊    # The combined options of all provided plug-ins\n+┊  ┊14┊    # More information about the options below:\n+┊  ┊15┊    # graphql-code-generator.com/docs/plugins/typescript-react-apollo#configuration\n+┊  ┊16┊    config:\n+┊  ┊17┊      withHOC: false\n+┊  ┊18┊      withHooks: true\n+┊  ┊19┊      withComponent: false\n```\n\n[}]: #\n\nFor the schema path we could have also provided a REST GraphQL endpoint that exposes a GraphQL schema. This way if there's an existing running GraphQL API, we can generate TypeScript types out of it, such as GitHub's GraphQL API. The advantages of providing a local path is that the server doesn't have to be running in order to generate types, which is more comfortable in development, and we can bypass authentication if the REST endpoint is guarded with such mechanism. This will be useful in further chapters when we're introduced to the concept of authentication.\n\nBe sure to add a .gitignore rule:\n\n[{]: <helper> (diffStep 9.1 files=\".gitignore\" module=\"client\")\n\n#### [Step 9.1: Setup GraphQL Code Generator](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/1adba2d)\n\n##### Changed .gitignore\n```diff\n@@ -21,3 +21,5 @@\n ┊21┊21┊npm-debug.log*\n ┊22┊22┊yarn-debug.log*\n ┊23┊23┊yarn-error.log*\n+┊  ┊24┊\n+┊  ┊25┊src/graphql/types.tsx\n```\n\n[}]: #\n\nNow we have TypeScript types available to us and we can replace `useQuery()` and `useMutation()` calls with the generated React hooks:\n\n[{]: <helper> (diffStep 9.2 module=\"client\")\n\n#### [Step 9.2: Use GraphQL Codegen hooks](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/33e181d)\n\n##### Changed src&#x2F;components&#x2F;ChatRoomScreen&#x2F;index.tsx\n```diff\n@@ -7,6 +7,7 @@\n ┊ 7┊ 7┊import ChatNavbar from './ChatNavbar'\n ┊ 8┊ 8┊import MessageInput from './MessageInput'\n ┊ 9┊ 9┊import MessagesList from './MessagesList'\n+┊  ┊10┊import { useGetChatQuery, useAddMessageMutation } from '../../graphql/types'\n ┊10┊11┊import * as queries from '../../graphql/queries'\n ┊11┊12┊import * as fragments from '../../graphql/fragments'\n ┊12┊13┊\n```\n```diff\n@@ -38,10 +39,10 @@\n ┊38┊39┊const ChatRoomScreen = ({ history, match }) => {\n ┊39┊40┊  const { params: { chatId } } = match\n ┊40┊41┊  const client = useApolloClient()\n-┊41┊  ┊  const { data: { chat } } = useQuery(getChatQuery, {\n+┊  ┊42┊  const { data: { chat }, loading: loadingChat } = useGetChatQuery({\n ┊42┊43┊    variables: { chatId }\n ┊43┊44┊  })\n-┊44┊  ┊  const addMessage = useMutation(addMessageMutation)\n+┊  ┊45┊  const addMessage = useAddMessageMutation()\n ┊45┊46┊\n ┊46┊47┊  const onSendMessage = useCallback((content) => {\n ┊47┊48┊    addMessage({\n```\n```diff\n@@ -115,7 +116,7 @@\n ┊115┊116┊    })\n ┊116┊117┊  }, [chat])\n ┊117┊118┊\n-┊118┊   ┊  if (!chat) return null\n+┊   ┊119┊  if (loadingChat) return null\n ┊119┊120┊\n ┊120┊121┊  return (\n ┊121┊122┊    <Container>\n```\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;ChatsList.tsx\n```diff\n@@ -3,9 +3,8 @@\n ┊ 3┊ 3┊import moment from 'moment'\n ┊ 4┊ 4┊import * as React from 'react'\n ┊ 5┊ 5┊import { useCallback } from 'react'\n-┊ 6┊  ┊import { useQuery } from 'react-apollo-hooks'\n ┊ 7┊ 6┊import styled from 'styled-components'\n-┊ 8┊  ┊import * as queries from '../../graphql/queries'\n+┊  ┊ 7┊import { useChatsQuery } from '../../graphql/types'\n ┊ 9┊ 8┊\n ┊10┊ 9┊const Container = styled.div `\n ┊11┊10┊  height: calc(100% - 56px);\n```\n```diff\n@@ -60,7 +59,7 @@\n ┊60┊59┊`\n ┊61┊60┊\n ┊62┊61┊const ChatsList = ({ history }) => {\n-┊63┊  ┊  const { data: { chats = [] } } = useQuery(queries.chats)\n+┊  ┊62┊  const { data: { chats = [] } } = useChatsQuery()\n ┊64┊63┊\n ┊65┊64┊  const navToChat = useCallback((chat) => {\n ┊66┊65┊    history.push(`chats/${chat.id}`)\n```\n\n[}]: #\n\nTo test if things are working properly, we can address a non existing field in one of the retrieved query results, for example `chat.foo` in `useGetChatQuery()`. We should receive the following typing error when trying to run the project:\n\n```\nTypeScript error: Property 'foo' does not exist on type '{ __typename?: \"Chat\"; } & { __typename?: \"Chat\"; } & { messages: ({ __typename?: \"Message\"; } & { __typename?: \"Message\"; } & Pick<Message, \"id\" | \"createdAt\" | \"content\">)[]; } & { __typename?: \"Chat\"; } & Pick<...> & { ...; }'.  TS2339\n\n    44 |   const addMessage = useAddMessageMutation()\n    45 |\n  > 46 |   console.log(chat.foo)\n       |                    ^\n    47 |\n    48 |   const onSendMessage = useCallback((content) => {\n    49 |     addMessage({\n```"
          },
          {
            "manualTitle": "Step 10: Live updates with GraphQL subscriptions",
            "stepRevision": "7bc826fe8e5ea101aa08cd2be5920a70486c4ada",
            "manualView": "So far we've been developing the app and we've been treating it as if there's no other users; we're the only one exists. This approach is true when we want to develop a UI and focus on UX, but comes a point where we need to start thinking on a macro level. Our app is social interactive, and if things work properly for me, it doesn't mean that it works properly to the fellow I'm chatting with. It's inevitable to have an authentication system in our app, hence we need to take care of things before we get to that stage.\n\nTry to open 2 instances of the app in 2 separate tabs/windows, and navigate into the same chat room. Try to send a message with one instance and notice that the second instance doesn't update unless we refresh the page.\n\n\n\n![ezgif com-video-to-gif (2)](https://user-images.githubusercontent.com/7648874/55079371-fbd87080-50d6-11e9-8ade-5ffeed6eaf8d.gif)\n\n\nThis issue is very important and should be addressed, because a chat is all about sending and receiving messages on a lively basis. This issue was expected, as there's no mechanism that would trigger and listen to changes in the back-end. In this chapter we're gonna address that issue by implementing exactly that mechanism.\n\n**Introducing: GraphQL Subscriptions**\n\n[GraphQL subscriptions](https://github.com/apollographql/graphql-subscriptions) is a mechanism that works on [web-sockets](https://en.wikipedia.org/wiki/WebSocket) and live communication; clients can subscribe to it and be notified regards specific changes that happen in the back-end. Notifications will be triggered manually by us and can be provided with parameters that provide additional information regards the triggered event. For example, a `messageAdded` will be published with the new message, and will notify all clients who are subscribed to that event. Once the subscribers are notified, they can respond as they would like to, such as updating the UI.\n\n\n\n![subscription-notifications](https://user-images.githubusercontent.com/7648874/55079462-30e4c300-50d7-11e9-8399-7706da2a9cff.png)\n\n\nA subscription is presented in our GraphQL schema as a separate type called `Subscription`, where each field represents an event name along with its return type. Like any other GraphQL type, each field should be match with a resolver where we handle the request.** **In this chapter we will implement the `messageAdded` subscription, so users can be notified when it happens and update the messages list to contain the new message.\n\n**Implementing a subscription**\n\nWe will start by creating a new `Subscription` type in our GraphQL schema with the field `messageAdded`:\n\n[{]: <helper> (diffStep 7.1 module=\"server\")\n\n#### [Step 7.1: Add subscription type with messageAdded](https://github.com/Urigo/WhatsApp-Clone-Server/commit/6c066f8)\n\n##### Changed schema&#x2F;typeDefs.graphql\n```diff\n@@ -22,3 +22,7 @@\n ┊22┊22┊type Mutation {\n ┊23┊23┊  addMessage(chatId: ID!, content: String!): Message\n ┊24┊24┊}\n+┊  ┊25┊\n+┊  ┊26┊type Subscription {\n+┊  ┊27┊  messageAdded: Message!\n+┊  ┊28┊}\n```\n\n[}]: #\n\nChanges are triggered using an event-emitter like object called `PubSub`. This can be done using the `PubSub.prototype.publish` method. We will create a new instance of it and will provide it via the [context](https://www.apollographql.com/docs/apollo-server/essentials/data#context) - a common pattern for providing objects which are useful for the execution of the resolvers:\n\n[{]: <helper> (diffStep 7.2 module=\"server\")\n\n#### [Step 7.2: Provide a new instance of PubSub to context](https://github.com/Urigo/WhatsApp-Clone-Server/commit/9ba55e0)\n\n##### Changed index.ts\n```diff\n@@ -1,4 +1,4 @@\n-┊1┊ ┊import { ApolloServer, gql } from 'apollo-server-express'\n+┊ ┊1┊import { ApolloServer, gql, PubSub } from 'apollo-server-express'\n ┊2┊2┊import bodyParser from 'body-parser'\n ┊3┊3┊import cors from 'cors'\n ┊4┊4┊import express from 'express'\n```\n```diff\n@@ -13,7 +13,11 @@\n ┊13┊13┊  res.send('pong')\n ┊14┊14┊})\n ┊15┊15┊\n-┊16┊  ┊const server = new ApolloServer({ schema })\n+┊  ┊16┊const pubsub = new PubSub()\n+┊  ┊17┊const server = new ApolloServer({\n+┊  ┊18┊  schema,\n+┊  ┊19┊  context: () => ({ pubsub }),\n+┊  ┊20┊})\n ┊17┊21┊\n ┊18┊22┊server.applyMiddleware({\n ┊19┊23┊  app,\n```\n\n[}]: #\n\nInside the `addMessage` resolver we will publish a new event called `messageAdded`. The 3rd argument of the resolver will be the context object that we've just defined in the previous step, where we can use the pubsub instance. The TypeScript type of our context can be directly defined and generated by CodeGen through the `codegen.yml` file. This can be specified under the `ContextType` field with the file path that contains the context followed by the name of the exported object, like so:\n\n[{]: <helper> (diffStep 7.3 module=\"server\")\n\n#### [Step 7.3: Define Context type](https://github.com/Urigo/WhatsApp-Clone-Server/commit/f0078db)\n\n##### Changed codegen.yml\n```diff\n@@ -6,6 +6,7 @@\n ┊ 6┊ 6┊      - typescript\n ┊ 7┊ 7┊      - typescript-resolvers\n ┊ 8┊ 8┊    config:\n+┊  ┊ 9┊      contextType: ../context#MyContext\n ┊ 9┊10┊      mappers:\n ┊10┊11┊        # import { Message } from '../db'\n ┊11┊12┊        # The root types of Message resolvers\n```\n\n##### Added context.ts\n```diff\n@@ -0,0 +1,5 @@\n+┊ ┊1┊import { PubSub } from 'apollo-server-express'\n+┊ ┊2┊\n+┊ ┊3┊export type MyContext = {\n+┊ ┊4┊  pubsub: PubSub\n+┊ ┊5┊}\n```\n\n[}]: #\n\nThe event will be published right after the message was pushed into the messages collection, because order is a crucial thing. We don't want to notify our users unless the change has been made. The event will have a single parameter which represents the new message.\n\n[{]: <helper> (diffStep 7.4 module=\"server\")\n\n#### [Step 7.4: Publish message added event](https://github.com/Urigo/WhatsApp-Clone-Server/commit/3387986)\n\n##### Changed schema&#x2F;resolvers.ts\n```diff\n@@ -28,7 +28,7 @@\n ┊28┊28┊  },\n ┊29┊29┊\n ┊30┊30┊  Mutation: {\n-┊31┊  ┊    addMessage(root, { chatId, content }) {\n+┊  ┊31┊    addMessage(root, { chatId, content }, { pubsub }) {\n ┊32┊32┊      const chatIndex = chats.findIndex(c => c.id === chatId)\n ┊33┊33┊\n ┊34┊34┊      if (chatIndex === -1) return null\n```\n```diff\n@@ -48,6 +48,10 @@\n ┊48┊48┊      chats.splice(chatIndex, 1)\n ┊49┊49┊      chats.unshift(chat)\n ┊50┊50┊\n+┊  ┊51┊      pubsub.publish('messageAdded', {\n+┊  ┊52┊        messageAdded: message,\n+┊  ┊53┊      })\n+┊  ┊54┊\n ┊51┊55┊      return message\n ┊52┊56┊    }\n ┊53┊57┊  }\n```\n\n##### Changed tests&#x2F;mutations&#x2F;addMessage.test.ts\n```diff\n@@ -1,5 +1,5 @@\n ┊1┊1┊import { createTestClient } from 'apollo-server-testing'\n-┊2┊ ┊import { ApolloServer, gql } from 'apollo-server-express'\n+┊ ┊2┊import { ApolloServer, PubSub, gql } from 'apollo-server-express'\n ┊3┊3┊import schema from '../../schema'\n ┊4┊4┊import { resetDb } from '../../db'\n ┊5┊5┊\n```\n```diff\n@@ -7,7 +7,10 @@\n ┊ 7┊ 7┊  beforeEach(resetDb)\n ┊ 8┊ 8┊\n ┊ 9┊ 9┊  it('should add message to specified chat', async () => {\n-┊10┊  ┊    const server = new ApolloServer({ schema })\n+┊  ┊10┊    const server = new ApolloServer({\n+┊  ┊11┊      schema,\n+┊  ┊12┊      context: () => ({ pubsub: new PubSub() }),\n+┊  ┊13┊    })\n ┊11┊14┊\n ┊12┊15┊    const { query, mutate } = createTestClient(server)\n```\n\n[}]: #\n\nA subscription resolver behaves differently and thus should be implemented differently. Using the `pubsub.asyncIterator` instance, we can specify which events are relevant for the subscription, for example, all clients who are subscribers of the `chatUpdated` subscription will be notified when `messageAdded`, `messageRemoved` and `chatInfoChanged` events were triggered. For now, we will have a 1 to 1 relationship between the `messageAdded` event and `messageAdded` subscription. In code, it should look like this:\n\n[{]: <helper> (diffStep 7.5 module=\"server\")\n\n#### [Step 7.5: Add Subscription.messageAdded resolver](https://github.com/Urigo/WhatsApp-Clone-Server/commit/7ae067e)\n\n##### Changed schema&#x2F;resolvers.ts\n```diff\n@@ -54,6 +54,12 @@\n ┊54┊54┊\n ┊55┊55┊      return message\n ┊56┊56┊    }\n+┊  ┊57┊  },\n+┊  ┊58┊\n+┊  ┊59┊  Subscription: {\n+┊  ┊60┊    messageAdded: {\n+┊  ┊61┊      subscribe: (root, args, { pubsub }) => pubsub.asyncIterator('messageAdded')\n+┊  ┊62┊    }\n ┊57┊63┊  }\n ┊58┊64┊}\n```\n\n[}]: #\n\nThe idea behind the `pubsub.asyncIterator` method is that it returns an [`Iterator`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators#Iterators) like object, where each value is a promise that will be resolved when the relevant events are triggered. By default, the parameter that has a similar name to the subscription will be returned as a response, e.g. `messageAdded` parameter will be sent back to the subscribers. This behavior can be modified as explained [here](https://github.com/apollographql/graphql-subscriptions#payload-manipulation), but it's very unlikely and not necessary for our use case.\n\nAs mentioned at the beginning of this article, there needs to be an open connection between the client and the server so live updates can happen. There are serveral methods for doing so, but the 2 most popular ones are:\n\n\n\n*   Based on polling with HTTP protocol\n*   Based on web-sockets (WS protocol)\n\nHTTP polling means that each amount of time an HTTP request will be made to the server where potential changes can be sent back to us at any given time. HTTP requests are very reliable, but the problem with them is that they contain a lot of information in their headers, so even if we sent an empty request, it might be still very heavy due to cookies, user-agent, language, request type, etc.\n\nWith web-sockets, once a connection has been established, it will remain open and it will only send the information which is relevant for the current session, so it's much faster. The communication is between the server and the client is bi-directional when it comes to web-sockets, which means that a user can spontaneously receive information from the server, as long as the communication channel remains open.\n\n> More information about the advantages of Web Sockets over HTTP can be found at [websocket.org](http://websocket.org/quantum.html)\n\nThe subscription mechanism can be installed using the `server.installSubscriptionHandlers`. It will use the WS protocol by default and will fallback to HTTP polling if there were troubles establishing a connection via WS protocol:\n\n[{]: <helper> (diffStep 7.6 module=\"server\")\n\n#### [Step 7.6: Install subscription handlers](https://github.com/Urigo/WhatsApp-Clone-Server/commit/58ed8a8)\n\n##### Changed index.ts\n```diff\n@@ -2,6 +2,7 @@\n ┊2┊2┊import bodyParser from 'body-parser'\n ┊3┊3┊import cors from 'cors'\n ┊4┊4┊import express from 'express'\n+┊ ┊5┊import http from 'http'\n ┊5┊6┊import schema from './schema'\n ┊6┊7┊\n ┊7┊8┊const app = express()\n```\n```diff\n@@ -24,8 +25,11 @@\n ┊24┊25┊  path: '/graphql',\n ┊25┊26┊})\n ┊26┊27┊\n+┊  ┊28┊const httpServer = http.createServer(app)\n+┊  ┊29┊server.installSubscriptionHandlers(httpServer)\n+┊  ┊30┊\n ┊27┊31┊const port = process.env.PORT || 4000\n ┊28┊32┊\n-┊29┊  ┊app.listen(port, () => {\n+┊  ┊33┊httpServer.listen(port, () => {\n ┊30┊34┊  console.log(`Server is listening on port ${port}`)\n ┊31┊35┊})\n```\n\n[}]: #\n\nNow we have everything set and we can start listening to subscriptions and react to to triggered changes.\n\n**Using subscriptions**\n\nTo support subscriptions we need to establish a WS connection. For that we will need to update our Apollo client. We will install a couple of packages that will enable such feature:\n\n  $ npm install subscriptions-transport-ws apollo-link apollo-link-ws apollo-utilities\n\n\n\n*   [`subscriptions-transport-ws`](https://www.npmjs.com/package/subscriptions-transport-ws) - The WS client. Essential for subscriptions to work.\n*   [`apollo-link-ws`](https://www.npmjs.com/package/apollo-link-ws) - Will establish a WS connection.\n*   [`apollo-link`](https://www.npmjs.com/package/apollo-link) - Will enable WS and HTTP connections co-exist in a single client.\n*   [`apollo-utilities`](https://www.npmjs.com/package/apollo-utilities) - Includes utility functions that will help us analyze a GraphQL AST.\n\nThe WS url can be composed by simply running a regular expression over the `REACT_APP_SERVER_URL` environment variable and is unnecessary to be stored separately. Here's how our new client should look like: \\\n\n\n[{]: <helper> (diffStep 10.1 files=\"client\" module=\"client\")\n\n#### [Step 10.1: Setup WS link](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/3aeee82)\n\n##### Changed src&#x2F;client.ts\n```diff\n@@ -1,16 +1,42 @@\n ┊ 1┊ 1┊import { InMemoryCache } from 'apollo-cache-inmemory'\n ┊ 2┊ 2┊import { ApolloClient } from 'apollo-client'\n+┊  ┊ 3┊import { getMainDefinition } from 'apollo-utilities'\n ┊ 3┊ 4┊import { HttpLink } from 'apollo-link-http'\n+┊  ┊ 5┊import { WebSocketLink } from 'apollo-link-ws'\n+┊  ┊ 6┊import { ApolloLink, split } from 'apollo-link'\n ┊ 4┊ 7┊\n ┊ 5┊ 8┊const httpUri = process.env.REACT_APP_SERVER_URL + '/graphql'\n+┊  ┊ 9┊const wsUri = httpUri.replace(/^https?/, 'ws')\n ┊ 6┊10┊\n ┊ 7┊11┊const httpLink = new HttpLink({\n ┊ 8┊12┊  uri: httpUri,\n ┊ 9┊13┊})\n ┊10┊14┊\n+┊  ┊15┊const wsLink = new WebSocketLink({\n+┊  ┊16┊  uri: wsUri,\n+┊  ┊17┊  options: {\n+┊  ┊18┊    // Automatic reconnect in case of connection error\n+┊  ┊19┊    reconnect: true,\n+┊  ┊20┊  },\n+┊  ┊21┊})\n+┊  ┊22┊\n+┊  ┊23┊const terminatingLink = split(\n+┊  ┊24┊    ({ query }) => {\n+┊  ┊25┊      const { kind, operation } = getMainDefinition(query)\n+┊  ┊26┊      // If this is a subscription query, use wsLink, otherwise use httpLink\n+┊  ┊27┊      return (\n+┊  ┊28┊        kind === 'OperationDefinition' && operation === 'subscription'\n+┊  ┊29┊      )\n+┊  ┊30┊    },\n+┊  ┊31┊    wsLink,\n+┊  ┊32┊    httpLink,\n+┊  ┊33┊)\n+┊  ┊34┊\n+┊  ┊35┊const link = ApolloLink.from([terminatingLink])\n+┊  ┊36┊\n ┊11┊37┊const inMemoryCache = new InMemoryCache()\n ┊12┊38┊\n ┊13┊39┊export default new ApolloClient({\n-┊14┊  ┊  link: httpLink,\n+┊  ┊40┊  link,\n ┊15┊41┊  cache: inMemoryCache,\n ┊16┊42┊})\n```\n\n[}]: #\n\nOur subscription listeners should live globally across our application and shouldn't be bound to a specific component, thus we will create an external service which will be responsible of doing so. Using that service, we will update our GraphQL data-store any time a new message has been added. We will define a `messageAdded` subscription in a dedicated file under the `src/graphql/subscriptions` dir where all our subscriptions will be defined and exported:\n\n[{]: <helper> (diffStep 10.2 module=\"client\")\n\n#### [Step 10.2: Add messageAdded subscription document](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/fb0714d)\n\n##### Added src&#x2F;graphql&#x2F;subscriptions&#x2F;index.ts\n```diff\n@@ -0,0 +1 @@\n+┊ ┊1┊export { default as messageAdded } from './messageAdded.subscription'\n```\n\n##### Added src&#x2F;graphql&#x2F;subscriptions&#x2F;messageAdded.subscription.ts\n```diff\n@@ -0,0 +1,11 @@\n+┊  ┊ 1┊import gql from 'graphql-tag'\n+┊  ┊ 2┊import * as fragments from '../fragments'\n+┊  ┊ 3┊\n+┊  ┊ 4┊export default gql `\n+┊  ┊ 5┊  subscription MessageAdded {\n+┊  ┊ 6┊    messageAdded {\n+┊  ┊ 7┊      ...Message\n+┊  ┊ 8┊    }\n+┊  ┊ 9┊  }\n+┊  ┊10┊  ${fragments.message}\n+┊  ┊11┊`\n```\n\n[}]: #\n\nNow we will create the service under the path `services/cache.service.ts`. Like any other GraphQL operation, `react-apollo-hooks` provides us with a dedicated React hook for subscriptions called `useSubscription`. Given the subscription document and the `onSubscriptionData` callback we can handle incoming changes. We will be using GraphQL Code Generator to generate typed subscription hooks, as the `typescript-react-apollo` plug-in supports it right out of the box. First let's update the `codegen.yml` file to look for documents in the `graphql/subscriptions` dir:\n\n[{]: <helper> (diffStep 10.3 module=\"client\")\n\n#### [Step 10.3: Include subscription documents in codegen.yml](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/41115ad)\n\n##### Changed codegen.yml\n```diff\n@@ -3,6 +3,7 @@\n ┊3┊3┊  - ./src/components/**/*.tsx\n ┊4┊4┊  - ./src/graphql/fragments/**/*.ts\n ┊5┊5┊  - ./src/graphql/queries/**/*.ts\n+┊ ┊6┊  - ./src/graphql/subscriptions/**/*.ts\n ┊6┊7┊overwrite: true\n ┊7┊8┊generates:\n ┊8┊9┊  ./src/graphql/types.tsx:\n```\n\n[}]: #\n\nAnd then we will type the code generation command:\n\n    $ npm run codegen\n\nNow we can import and use the newly generated hook `useMessageAddedSubscription` in the `cache.service`. Like mentioned earlier, we will be using the `onSubscriptionData` callback to retrieve the change that was sent by the server and we will use it to re-write our cache. In this case we will be writing a new fragment for the incoming message, and we will update the correlated chat:\n\n[{]: <helper> (diffStep 10.4 files=\"cache.service\" module=\"client\")\n\n#### [Step 10.4: Update cache on message added](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/4bee34e)\n\n##### Added src&#x2F;services&#x2F;cache.service.ts\n```diff\n@@ -0,0 +1,74 @@\n+┊  ┊ 1┊import { DataProxy } from 'apollo-cache'\n+┊  ┊ 2┊import { defaultDataIdFromObject } from 'apollo-cache-inmemory'\n+┊  ┊ 3┊import { ApolloClient } from 'apollo-client'\n+┊  ┊ 4┊import * as fragments from '../graphql/fragments'\n+┊  ┊ 5┊import * as queries from '../graphql/queries'\n+┊  ┊ 6┊import { MessageFragment, useMessageAddedSubscription } from '../graphql/types'\n+┊  ┊ 7┊\n+┊  ┊ 8┊type Client = ApolloClient<any> | DataProxy\n+┊  ┊ 9┊\n+┊  ┊10┊export const useCacheService = () => {\n+┊  ┊11┊  useMessageAddedSubscription({\n+┊  ┊12┊    onSubscriptionData: ({ client, subscriptionData: { data: { messageAdded } } }) => {\n+┊  ┊13┊      writeMessage(client, messageAdded)\n+┊  ┊14┊    }\n+┊  ┊15┊  })\n+┊  ┊16┊}\n+┊  ┊17┊\n+┊  ┊18┊export const writeMessage = (client: Client, message: MessageFragment) => {\n+┊  ┊19┊  let fullChat\n+┊  ┊20┊  try {\n+┊  ┊21┊    fullChat = client.readFragment({\n+┊  ┊22┊      id: defaultDataIdFromObject(message.chat),\n+┊  ┊23┊      fragment: fragments.fullChat,\n+┊  ┊24┊      fragmentName: 'FullChat',\n+┊  ┊25┊    })\n+┊  ┊26┊  } catch (e) {\n+┊  ┊27┊    return\n+┊  ┊28┊  }\n+┊  ┊29┊\n+┊  ┊30┊  if (fullChat.messages.some(m => m.id === message.id)) return\n+┊  ┊31┊\n+┊  ┊32┊  fullChat.messages.push(message)\n+┊  ┊33┊  fullChat.lastMessage = message\n+┊  ┊34┊\n+┊  ┊35┊  client.writeFragment({\n+┊  ┊36┊    id: defaultDataIdFromObject(message.chat),\n+┊  ┊37┊    fragment: fragments.fullChat,\n+┊  ┊38┊    fragmentName: 'FullChat',\n+┊  ┊39┊    data: fullChat,\n+┊  ┊40┊  })\n+┊  ┊41┊\n+┊  ┊42┊  rewriteChats:\n+┊  ┊43┊  {\n+┊  ┊44┊    let data\n+┊  ┊45┊    try {\n+┊  ┊46┊      data = client.readQuery({\n+┊  ┊47┊        query: queries.chats,\n+┊  ┊48┊      })\n+┊  ┊49┊    } catch (e) {\n+┊  ┊50┊      break rewriteChats\n+┊  ┊51┊    }\n+┊  ┊52┊\n+┊  ┊53┊    if (!data) break rewriteChats\n+┊  ┊54┊\n+┊  ┊55┊    const chats = data.chats\n+┊  ┊56┊\n+┊  ┊57┊    if (!chats) break rewriteChats\n+┊  ┊58┊\n+┊  ┊59┊    const chatIndex = chats.findIndex(c => c.id === message.chat.id)\n+┊  ┊60┊\n+┊  ┊61┊    if (chatIndex === -1) break rewriteChats\n+┊  ┊62┊\n+┊  ┊63┊    const chat = chats[chatIndex]\n+┊  ┊64┊\n+┊  ┊65┊    // The chat will appear at the top of the ChatsList component\n+┊  ┊66┊    chats.splice(chatIndex, 1)\n+┊  ┊67┊    chats.unshift(chat)\n+┊  ┊68┊\n+┊  ┊69┊    client.writeQuery({\n+┊  ┊70┊      query: queries.chats,\n+┊  ┊71┊      data: { chats: chats },\n+┊  ┊72┊    })\n+┊  ┊73┊  }\n+┊  ┊74┊}\n```\n\n[}]: #\n\nWe will also use the exported `writeMessage()` function in the `ChatRoomScreen` so we won't have any code duplications:\n\n[{]: <helper> (diffStep 10.4 files=\"ChatRoom\" module=\"client\")\n\n#### [Step 10.4: Update cache on message added](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/4bee34e)\n\n##### Changed src&#x2F;components&#x2F;ChatRoomScreen&#x2F;index.tsx\n```diff\n@@ -10,6 +10,7 @@\n ┊10┊10┊import { useGetChatQuery, useAddMessageMutation } from '../../graphql/types'\n ┊11┊11┊import * as queries from '../../graphql/queries'\n ┊12┊12┊import * as fragments from '../../graphql/fragments'\n+┊  ┊13┊import { writeMessage } from '../../services/cache.service'\n ┊13┊14┊\n ┊14┊15┊const Container = styled.div `\n ┊15┊16┊  background: url(/assets/chat-background.jpg);\n```\n```diff\n@@ -57,61 +58,7 @@\n ┊ 57┊ 58┊        }\n ┊ 58┊ 59┊      },\n ┊ 59┊ 60┊      update: (client, { data: { addMessage } }) => {\n-┊ 60┊   ┊        let fullChat\n-┊ 61┊   ┊        try {\n-┊ 62┊   ┊          fullChat = client.readFragment({\n-┊ 63┊   ┊            id: defaultDataIdFromObject(chat),\n-┊ 64┊   ┊            fragment: fragments.fullChat,\n-┊ 65┊   ┊            fragmentName: 'FullChat',\n-┊ 66┊   ┊          })\n-┊ 67┊   ┊        } catch (e) {\n-┊ 68┊   ┊          return\n-┊ 69┊   ┊        }\n-┊ 70┊   ┊\n-┊ 71┊   ┊        if (fullChat.messages.some(m => m.id === message.id)) return\n-┊ 72┊   ┊\n-┊ 73┊   ┊        fullChat.messages.push(addMessage)\n-┊ 74┊   ┊        fullChat.lastMessage = addMessage\n-┊ 75┊   ┊\n-┊ 76┊   ┊        client.writeFragment({\n-┊ 77┊   ┊          id: defaultDataIdFromObject(chat),\n-┊ 78┊   ┊          fragment: fragments.fullChat,\n-┊ 79┊   ┊          fragmentName: 'FullChat',\n-┊ 80┊   ┊          data: fullChat,\n-┊ 81┊   ┊        })\n-┊ 82┊   ┊\n-┊ 83┊   ┊        rewriteChats:\n-┊ 84┊   ┊        {\n-┊ 85┊   ┊          let data\n-┊ 86┊   ┊          try {\n-┊ 87┊   ┊            data = client.readQuery({\n-┊ 88┊   ┊              query: queries.chats,\n-┊ 89┊   ┊            })\n-┊ 90┊   ┊          } catch (e) {\n-┊ 91┊   ┊            break rewriteChats\n-┊ 92┊   ┊          }\n-┊ 93┊   ┊\n-┊ 94┊   ┊          if (!data) break rewriteChats\n-┊ 95┊   ┊\n-┊ 96┊   ┊          const chats = data.chats\n-┊ 97┊   ┊\n-┊ 98┊   ┊          if (!chats) break rewriteChats\n-┊ 99┊   ┊\n-┊100┊   ┊          const chatIndex = chats.findIndex(c => c.id === chatId)\n-┊101┊   ┊\n-┊102┊   ┊          if (chatIndex === -1) break rewriteChats\n-┊103┊   ┊\n-┊104┊   ┊          const chat = chats[chatIndex]\n-┊105┊   ┊\n-┊106┊   ┊          // The chat will appear at the top of the ChatsList component\n-┊107┊   ┊          chats.splice(chatIndex, 1)\n-┊108┊   ┊          chats.unshift(chat)\n-┊109┊   ┊\n-┊110┊   ┊          client.writeQuery({\n-┊111┊   ┊            query: queries.chats,\n-┊112┊   ┊            data: { chats: chats },\n-┊113┊   ┊          })\n-┊114┊   ┊        }\n+┊   ┊ 61┊        writeMessage(client, addMessage)\n ┊115┊ 62┊      },\n ┊116┊ 63┊    })\n ┊117┊ 64┊  }, [chat])\n```\n\n[}]: #\n\nOne thing missing that you might notice is that we're trying to retrieve the chat from the received message, unfortunately our GraphQL schema doesn't support it and we will need to add it. On the server, we will add a `chat` field to the `Message` type in the GraphQL schema, and we will implement a resolver which will lookup for the chat in the chats collection:\n\n[{]: <helper> (diffStep 7.7 module=\"server\")\n\n#### [Step 7.7: Add Message.chat resolver](https://github.com/Urigo/WhatsApp-Clone-Server/commit/ad1988a)\n\n##### Changed schema&#x2F;resolvers.ts\n```diff\n@@ -5,6 +5,12 @@\n ┊ 5┊ 5┊const resolvers: Resolvers = {\n ┊ 6┊ 6┊  Date: GraphQLDateTime,\n ┊ 7┊ 7┊\n+┊  ┊ 8┊  Message: {\n+┊  ┊ 9┊    chat(message) {\n+┊  ┊10┊      return chats.find(c => c.messages.some(m => m === message.id)) || null\n+┊  ┊11┊    },\n+┊  ┊12┊  },\n+┊  ┊13┊\n ┊ 8┊14┊  Chat: {\n ┊ 9┊15┊    messages(chat) {\n ┊10┊16┊      return messages.filter(m => chat.messages.includes(m.id))\n```\n\n##### Changed schema&#x2F;typeDefs.graphql\n```diff\n@@ -4,6 +4,7 @@\n ┊ 4┊ 4┊  id: ID!\n ┊ 5┊ 5┊  content: String!\n ┊ 6┊ 6┊  createdAt: Date!\n+┊  ┊ 7┊  chat: Chat\n ┊ 7┊ 8┊}\n ┊ 8┊ 9┊\n ┊ 9┊10┊type Chat {\n```\n\n[}]: #\n\nNow that we have it supported we can update the `Message` fragment in the client to include that information. We don't need the entire chat, only its ID, since the fragment ID composition is done out of an ID and type name:\n\n[{]: <helper> (diffStep 10.5 module=\"client\")\n\n#### [Step 10.5: Add chat.id to message fragment](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/622e182)\n\n##### Changed src&#x2F;components&#x2F;ChatRoomScreen&#x2F;index.tsx\n```diff\n@@ -54,6 +54,10 @@\n ┊54┊54┊          __typename: 'Message',\n ┊55┊55┊          id: Math.random().toString(36).substr(2, 9),\n ┊56┊56┊          createdAt: new Date(),\n+┊  ┊57┊          chat: {\n+┊  ┊58┊            __typename: 'Chat',\n+┊  ┊59┊            id: chatId,\n+┊  ┊60┊          },\n ┊57┊61┊          content,\n ┊58┊62┊        }\n ┊59┊63┊      },\n```\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;ChatsList.test.tsx\n```diff\n@@ -30,6 +30,10 @@\n ┊30┊30┊                  id: 1,\n ┊31┊31┊                  content: 'Hello',\n ┊32┊32┊                  createdAt: new Date(0),\n+┊  ┊33┊                  chat: {\n+┊  ┊34┊                    __typename: 'Chat',\n+┊  ┊35┊                    id: 1,\n+┊  ┊36┊                  },\n ┊33┊37┊                },\n ┊34┊38┊              },\n ┊35┊39┊            ],\n```\n```diff\n@@ -71,6 +75,10 @@\n ┊71┊75┊                  id: 1,\n ┊72┊76┊                  content: 'Hello',\n ┊73┊77┊                  createdAt: new Date(0),\n+┊  ┊78┊                  chat: {\n+┊  ┊79┊                    __typename: 'Chat',\n+┊  ┊80┊                    id: 1,\n+┊  ┊81┊                  },\n ┊74┊82┊                },\n ┊75┊83┊              },\n ┊76┊84┊            ],\n```\n\n##### Changed src&#x2F;graphql&#x2F;fragments&#x2F;message.fragment.ts\n```diff\n@@ -5,5 +5,8 @@\n ┊ 5┊ 5┊    id\n ┊ 6┊ 6┊    createdAt\n ┊ 7┊ 7┊    content\n+┊  ┊ 8┊    chat {\n+┊  ┊ 9┊      id\n+┊  ┊10┊    }\n ┊ 8┊11┊  }\n ┊ 9┊12┊`\n```\n\n[}]: #\n\nFinally, we will import the `useCacheService` React hook that we've just created and we will use it in our main `App` component. This means that the cache service will start listening for changes right as the app component is mounted:\n\n[{]: <helper> (diffStep 10.6 module=\"client\")\n\n#### [Step 10.6: Use cache service](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/6d228f3)\n\n##### Changed src&#x2F;App.jsx\n```diff\n@@ -3,16 +3,21 @@\n ┊ 3┊ 3┊import ChatRoomScreen from './components/ChatRoomScreen'\n ┊ 4┊ 4┊import ChatsListScreen from './components/ChatsListScreen'\n ┊ 5┊ 5┊import AnimatedSwitch from './components/AnimatedSwitch'\n+┊  ┊ 6┊import { useCacheService } from './services/cache.service'\n ┊ 6┊ 7┊\n-┊ 7┊  ┊const App = () => (\n-┊ 8┊  ┊  <BrowserRouter>\n-┊ 9┊  ┊    <AnimatedSwitch>\n-┊10┊  ┊      <Route exact path=\"/chats\" component={ChatsListScreen} />\n-┊11┊  ┊      <Route exact path=\"/chats/:chatId\" component={ChatRoomScreen} />\n-┊12┊  ┊    </AnimatedSwitch>\n-┊13┊  ┊    <Route exact path=\"/\" render={redirectToChats} />\n-┊14┊  ┊  </BrowserRouter>\n-┊15┊  ┊)\n+┊  ┊ 8┊const App = () => {\n+┊  ┊ 9┊  useCacheService()\n+┊  ┊10┊\n+┊  ┊11┊  return (\n+┊  ┊12┊    <BrowserRouter>\n+┊  ┊13┊      <AnimatedSwitch>\n+┊  ┊14┊        <Route exact path=\"/chats\" component={ChatsListScreen} />\n+┊  ┊15┊        <Route exact path=\"/chats/:chatId\" component={ChatRoomScreen} />\n+┊  ┊16┊      </AnimatedSwitch>\n+┊  ┊17┊      <Route exact path=\"/\" render={redirectToChats} />\n+┊  ┊18┊    </BrowserRouter>\n+┊  ┊19┊  )\n+┊  ┊20┊}\n ┊16┊21┊\n ┊17┊22┊const redirectToChats = () => (\n ┊18┊23┊  <Redirect to=\"/chats\" />\n```\n\n[}]: #\n\nSubscription handling is complete! If you'll try to repeat the same process again where you check messages updating between 2 instances of the app, you should see them both update."
          },
          {
            "manualTitle": "Step 11: Users",
            "stepRevision": "e079aaabd1f4eae9dc8f6b602a6b5fb52dbbfd9f",
            "manualView": "Our chat app is pretty functional. We can pick a chat from the chats list and we can send messages. It's not hard to notice that one of the most important mechanisms is missing, which is relating a chat or a message to a specific user. Even though we can send messages, it's basically pointless unless someone else receives it. In this chapter we will create a new users collection with pre-defined documents and we will learn how to simulate authentication programmatically so we can test the new mechanism.\n\n**Reshaping the back-end**\n\nTo implement this feature we need to rethink our back-end and reshape the way our GraphQL schema is structured. Right now we only have 2 entities: Chat and Message, which are connected like so:\n\n\n\n![chat-message-orm](https://user-images.githubusercontent.com/7648874/55325929-0faa1b00-54b9-11e9-8868-7a8ed3edcda1.png)\n\n\nWe want to have a new User entity where each user will have Chats he participates in and Messages he owns. Therefore, our new GraphQL schema should look like something like this:\n\n\n\n![chat-message-user-orm](https://user-images.githubusercontent.com/7648874/55325935-146ecf00-54b9-11e9-8c0f-bc3b63cbe676.png)\n\nThis change would require us to update the GraphQL type definitions and handlers, the DB models, and the codegen configuration file:\n\n[{]: <helper> (diffStep 8.1 module=\"server\")\n\n#### [Step 8.1: Add User type](https://github.com/Urigo/WhatsApp-Clone-Server/commit/76ffcef)\n\n##### Changed codegen.yml\n```diff\n@@ -10,6 +10,7 @@\n ┊10┊10┊      mappers:\n ┊11┊11┊        # import { Message } from '../db'\n ┊12┊12┊        # The root types of Message resolvers\n+┊  ┊13┊        User: ../db#User\n ┊13┊14┊        Message: ../db#Message\n ┊14┊15┊        Chat: ../db#Chat\n ┊15┊16┊      scalars:\n```\n\n##### Changed db.ts\n```diff\n@@ -1,66 +1,106 @@\n+┊   ┊  1┊export type User = {\n+┊   ┊  2┊  id: string\n+┊   ┊  3┊  name: string\n+┊   ┊  4┊  picture: string\n+┊   ┊  5┊}\n+┊   ┊  6┊\n ┊  1┊  7┊export type Message = {\n ┊  2┊  8┊  id: string\n ┊  3┊  9┊  content: string\n ┊  4┊ 10┊  createdAt: Date\n+┊   ┊ 11┊  sender: string\n+┊   ┊ 12┊  recipient: string\n ┊  5┊ 13┊}\n ┊  6┊ 14┊\n ┊  7┊ 15┊export type Chat = {\n ┊  8┊ 16┊  id: string\n-┊  9┊   ┊  name: string\n-┊ 10┊   ┊  picture: string\n ┊ 11┊ 17┊  messages: string[]\n+┊   ┊ 18┊  participants: string[]\n ┊ 12┊ 19┊}\n ┊ 13┊ 20┊\n+┊   ┊ 21┊export const users: User[] = []\n ┊ 14┊ 22┊export const messages: Message[] = []\n ┊ 15┊ 23┊export const chats: Chat[] = []\n ┊ 16┊ 24┊\n ┊ 17┊ 25┊export const resetDb = () => {\n+┊   ┊ 26┊  users.splice(0, Infinity, ...[\n+┊   ┊ 27┊    {\n+┊   ┊ 28┊      id: '1',\n+┊   ┊ 29┊      name: 'Ray Edwards',\n+┊   ┊ 30┊      picture: 'https://randomuser.me/api/portraits/thumb/lego/1.jpg',\n+┊   ┊ 31┊    },\n+┊   ┊ 32┊    {\n+┊   ┊ 33┊      id: '2',\n+┊   ┊ 34┊      name: 'Ethan Gonzalez',\n+┊   ┊ 35┊      picture: 'https://randomuser.me/api/portraits/thumb/men/1.jpg',\n+┊   ┊ 36┊    },\n+┊   ┊ 37┊    {\n+┊   ┊ 38┊      id: '3',\n+┊   ┊ 39┊      name: 'Bryan Wallace',\n+┊   ┊ 40┊      picture: 'https://randomuser.me/api/portraits/thumb/men/2.jpg',\n+┊   ┊ 41┊    },\n+┊   ┊ 42┊    {\n+┊   ┊ 43┊      id: '4',\n+┊   ┊ 44┊      name: 'Avery Stewart',\n+┊   ┊ 45┊      picture: 'https://randomuser.me/api/portraits/thumb/women/1.jpg',\n+┊   ┊ 46┊    },\n+┊   ┊ 47┊    {\n+┊   ┊ 48┊      id: '5',\n+┊   ┊ 49┊      name: 'Katie Peterson',\n+┊   ┊ 50┊      picture: 'https://randomuser.me/api/portraits/thumb/women/2.jpg',\n+┊   ┊ 51┊    },\n+┊   ┊ 52┊  ])\n+┊   ┊ 53┊\n ┊ 18┊ 54┊  messages.splice(0, Infinity, ...[\n ┊ 19┊ 55┊    {\n ┊ 20┊ 56┊      id: '1',\n ┊ 21┊ 57┊      content: \"You on your way?\",\n ┊ 22┊ 58┊      createdAt: new Date(new Date('1-1-2019').getTime() - 60 * 1000 * 1000),\n+┊   ┊ 59┊      sender: '1',\n+┊   ┊ 60┊      recipient: '2',\n ┊ 23┊ 61┊    },\n ┊ 24┊ 62┊    {\n ┊ 25┊ 63┊      id: '2',\n ┊ 26┊ 64┊      content: \"Hey, it's me\",\n ┊ 27┊ 65┊      createdAt: new Date(new Date('1-1-2019').getTime() - 2 * 60 * 1000 * 1000),\n+┊   ┊ 66┊      sender: '1',\n+┊   ┊ 67┊      recipient: '3',\n ┊ 28┊ 68┊    },\n ┊ 29┊ 69┊    {\n ┊ 30┊ 70┊      id: '3',\n ┊ 31┊ 71┊      content: \"I should buy a boat\",\n ┊ 32┊ 72┊      createdAt: new Date(new Date('1-1-2019').getTime() - 24 * 60 * 1000 * 1000),\n+┊   ┊ 73┊      sender: '1',\n+┊   ┊ 74┊      recipient: '4',\n ┊ 33┊ 75┊    },\n ┊ 34┊ 76┊    {\n ┊ 35┊ 77┊      id: '4',\n ┊ 36┊ 78┊      content: \"This is wicked good ice cream.\",\n ┊ 37┊ 79┊      createdAt: new Date(new Date('1-1-2019').getTime() - 14 * 24 * 60 * 1000 * 1000),\n+┊   ┊ 80┊      sender: '1',\n+┊   ┊ 81┊      recipient: '5',\n ┊ 38┊ 82┊    },\n ┊ 39┊ 83┊  ])\n ┊ 40┊ 84┊\n ┊ 41┊ 85┊  chats.splice(0, Infinity, ...[\n ┊ 42┊ 86┊    {\n ┊ 43┊ 87┊      id: '1',\n-┊ 44┊   ┊      name: 'Ethan Gonzalez',\n-┊ 45┊   ┊      picture: 'https://randomuser.me/api/portraits/thumb/men/1.jpg',\n+┊   ┊ 88┊      participants: ['1', '2'],\n ┊ 46┊ 89┊      messages: ['1'],\n ┊ 47┊ 90┊    },\n ┊ 48┊ 91┊    {\n ┊ 49┊ 92┊      id: '2',\n-┊ 50┊   ┊      name: 'Bryan Wallace',\n-┊ 51┊   ┊      picture: 'https://randomuser.me/api/portraits/thumb/men/2.jpg',\n+┊   ┊ 93┊      participants: ['1', '3'],\n ┊ 52┊ 94┊      messages: ['2'],\n ┊ 53┊ 95┊    },\n ┊ 54┊ 96┊    {\n ┊ 55┊ 97┊      id: '3',\n-┊ 56┊   ┊      name: 'Avery Stewart',\n-┊ 57┊   ┊      picture: 'https://randomuser.me/api/portraits/thumb/women/1.jpg',\n+┊   ┊ 98┊      participants: ['1', '4'],\n ┊ 58┊ 99┊      messages: ['3'],\n ┊ 59┊100┊    },\n ┊ 60┊101┊    {\n ┊ 61┊102┊      id: '4',\n-┊ 62┊   ┊      name: 'Katie Peterson',\n-┊ 63┊   ┊      picture: 'https://randomuser.me/api/portraits/thumb/women/2.jpg',\n+┊   ┊103┊      participants: ['1', '5'],\n ┊ 64┊104┊      messages: ['4'],\n ┊ 65┊105┊    },\n ┊ 66┊106┊  ])\n```\n\n##### Changed schema&#x2F;resolvers.ts\n```diff\n@@ -1,5 +1,5 @@\n ┊1┊1┊import { GraphQLDateTime } from 'graphql-iso-date'\n-┊2┊ ┊import { Message, chats, messages } from '../db'\n+┊ ┊2┊import { User, Message, chats, messages, users } from '../db'\n ┊3┊3┊import { Resolvers } from '../types/graphql'\n ┊4┊4┊\n ┊5┊5┊const resolvers: Resolvers = {\n```\n```diff\n@@ -9,9 +9,27 @@\n ┊ 9┊ 9┊    chat(message) {\n ┊10┊10┊      return chats.find(c => c.messages.some(m => m === message.id)) || null\n ┊11┊11┊    },\n+┊  ┊12┊\n+┊  ┊13┊    sender(message) {\n+┊  ┊14┊      return users.find(u => u.id === message.sender) || null\n+┊  ┊15┊    },\n+┊  ┊16┊\n+┊  ┊17┊    recipient(message) {\n+┊  ┊18┊      return users.find(u => u.id === message.recipient) || null\n+┊  ┊19┊    },\n ┊12┊20┊  },\n ┊13┊21┊\n ┊14┊22┊  Chat: {\n+┊  ┊23┊    name() {\n+┊  ┊24┊      // TODO: Resolve in relation to current user\n+┊  ┊25┊      return null\n+┊  ┊26┊    },\n+┊  ┊27┊\n+┊  ┊28┊    picture() {\n+┊  ┊29┊      // TODO: Resolve in relation to current user\n+┊  ┊30┊      return null\n+┊  ┊31┊    },\n+┊  ┊32┊\n ┊15┊33┊    messages(chat) {\n ┊16┊34┊      return messages.filter(m => chat.messages.includes(m.id))\n ┊17┊35┊    },\n```\n```diff\n@@ -21,6 +39,10 @@\n ┊21┊39┊\n ┊22┊40┊      return messages.find(m => m.id === lastMessage) || null\n ┊23┊41┊    },\n+┊  ┊42┊\n+┊  ┊43┊    participants(chat) {\n+┊  ┊44┊      return chat.participants.map(p => users.find(u => u.id === p)).filter(Boolean) as User[]\n+┊  ┊45┊    },\n ┊24┊46┊  },\n ┊25┊47┊\n ┊26┊48┊  Query: {\n```\n```diff\n@@ -45,6 +67,8 @@\n ┊45┊67┊      const message: Message = {\n ┊46┊68┊        id: messageId,\n ┊47┊69┊        createdAt: new Date(),\n+┊  ┊70┊        sender: '', // TODO: Fill-in\n+┊  ┊71┊        recipient: '', // TODO: Fill-in\n ┊48┊72┊        content,\n ┊49┊73┊      }\n ┊50┊74┊\n```\n\n##### Changed schema&#x2F;typeDefs.graphql\n```diff\n@@ -1,18 +1,28 @@\n ┊ 1┊ 1┊scalar Date\n ┊ 2┊ 2┊\n+┊  ┊ 3┊type User {\n+┊  ┊ 4┊  id: ID!\n+┊  ┊ 5┊  name: String!\n+┊  ┊ 6┊  picture: String\n+┊  ┊ 7┊}\n+┊  ┊ 8┊\n ┊ 3┊ 9┊type Message {\n ┊ 4┊10┊  id: ID!\n ┊ 5┊11┊  content: String!\n ┊ 6┊12┊  createdAt: Date!\n ┊ 7┊13┊  chat: Chat\n+┊  ┊14┊  sender: User\n+┊  ┊15┊  recipient: User\n+┊  ┊16┊  isMine: Boolean!\n ┊ 8┊17┊}\n ┊ 9┊18┊\n ┊10┊19┊type Chat {\n ┊11┊20┊  id: ID!\n-┊12┊  ┊  name: String!\n+┊  ┊21┊  name: String\n ┊13┊22┊  picture: String\n ┊14┊23┊  lastMessage: Message\n ┊15┊24┊  messages: [Message!]!\n+┊  ┊25┊  participants: [User!]!\n ┊16┊26┊}\n ┊17┊27┊\n ┊18┊28┊type Query {\n```\n\n[}]: #\n\nEven though we made these changes, the app remained the same. That's because the Query type haven't changed at all, and we still serve the same data as before. What we need to do is to edit the Query resolvers to serve data based on the user that is currently logged-in to the app in the current session. Before we go all in with a robust authentication system, it would be smarter to simulate it, so we can test our app and see that everything works as intended.\n\nFor now, let's assume that we're logged in with user of ID 1 - Ray Edwards. Codewise, this would mean that we will need to have the current user defined on the resolver context. In the main file, let's add the `currentUser` field to the context using a simple `find()` method from our `users` collection:\n\n[{]: <helper> (diffStep 8.2 files=\"index.ts\" module=\"server\")\n\n#### [Step 8.2: Resolve queries in relation to current user](https://github.com/Urigo/WhatsApp-Clone-Server/commit/cc56fb3)\n\n##### Changed index.ts\n```diff\n@@ -3,6 +3,7 @@\n ┊3┊3┊import cors from 'cors'\n ┊4┊4┊import express from 'express'\n ┊5┊5┊import http from 'http'\n+┊ ┊6┊import { users } from './db'\n ┊6┊7┊import schema from './schema'\n ┊7┊8┊\n ┊8┊9┊const app = express()\n```\n```diff\n@@ -17,7 +18,10 @@\n ┊17┊18┊const pubsub = new PubSub()\n ┊18┊19┊const server = new ApolloServer({\n ┊19┊20┊  schema,\n-┊20┊  ┊  context: () => ({ pubsub }),\n+┊  ┊21┊  context: () => ({\n+┊  ┊22┊    currentUser: users.find(u => u.id === '1'),\n+┊  ┊23┊    pubsub,\n+┊  ┊24┊  }),\n ┊21┊25┊})\n ┊22┊26┊\n ┊23┊27┊server.applyMiddleware({\n```\n\n[}]: #\n\nAnd we will update the context type:\n\n[{]: <helper> (diffStep 8.2 files=\"context\" module=\"server\")\n\n#### [Step 8.2: Resolve queries in relation to current user](https://github.com/Urigo/WhatsApp-Clone-Server/commit/cc56fb3)\n\n##### Changed context.ts\n```diff\n@@ -1,5 +1,7 @@\n ┊1┊1┊import { PubSub } from 'apollo-server-express'\n+┊ ┊2┊import { User } from './db'\n ┊2┊3┊\n ┊3┊4┊export type MyContext = {\n-┊4┊ ┊  pubsub: PubSub\n+┊ ┊5┊  pubsub: PubSub,\n+┊ ┊6┊  currentUser: User,\n ┊5┊7┊}\n```\n\n[}]: #\n\nNow we will update the resolvers to fetch data relatively to the current user logged in. If there's no user logged in, the resolvers should return `null`, as the client is not authorized to view the data he requested:\n\n[{]: <helper> (diffStep 8.2 files=\"schema, tests\" module=\"server\")\n\n#### [Step 8.2: Resolve queries in relation to current user](https://github.com/Urigo/WhatsApp-Clone-Server/commit/cc56fb3)\n\n##### Changed schema&#x2F;resolvers.ts\n```diff\n@@ -17,17 +17,35 @@\n ┊17┊17┊    recipient(message) {\n ┊18┊18┊      return users.find(u => u.id === message.recipient) || null\n ┊19┊19┊    },\n+┊  ┊20┊\n+┊  ┊21┊    isMine(message, args, { currentUser }) {\n+┊  ┊22┊      return message.sender === currentUser.id\n+┊  ┊23┊    },\n ┊20┊24┊  },\n ┊21┊25┊\n ┊22┊26┊  Chat: {\n-┊23┊  ┊    name() {\n-┊24┊  ┊      // TODO: Resolve in relation to current user\n-┊25┊  ┊      return null\n+┊  ┊27┊    name(chat, args, { currentUser }) {\n+┊  ┊28┊      if (!currentUser) return null\n+┊  ┊29┊\n+┊  ┊30┊      const participantId = chat.participants.find(p => p !== currentUser.id)\n+┊  ┊31┊\n+┊  ┊32┊      if (!participantId) return null\n+┊  ┊33┊\n+┊  ┊34┊      const participant = users.find(u => u.id === participantId)\n+┊  ┊35┊\n+┊  ┊36┊      return participant ? participant.name : null\n ┊26┊37┊    },\n ┊27┊38┊\n-┊28┊  ┊    picture() {\n-┊29┊  ┊      // TODO: Resolve in relation to current user\n-┊30┊  ┊      return null\n+┊  ┊39┊    picture(chat, args, { currentUser }) {\n+┊  ┊40┊      if (!currentUser) return null\n+┊  ┊41┊\n+┊  ┊42┊      const participantId = chat.participants.find(p => p !== currentUser.id)\n+┊  ┊43┊\n+┊  ┊44┊      if (!participantId) return null\n+┊  ┊45┊\n+┊  ┊46┊      const participant = users.find(u => u.id === participantId)\n+┊  ┊47┊\n+┊  ┊48┊      return participant ? participant.picture : null\n ┊31┊49┊    },\n ┊32┊50┊\n ┊33┊51┊    messages(chat) {\n```\n```diff\n@@ -46,29 +64,42 @@\n ┊ 46┊ 64┊  },\n ┊ 47┊ 65┊\n ┊ 48┊ 66┊  Query: {\n-┊ 49┊   ┊    chats() {\n-┊ 50┊   ┊      return chats\n+┊   ┊ 67┊    chats(root, args, { currentUser }) {\n+┊   ┊ 68┊      if (!currentUser) return []\n+┊   ┊ 69┊\n+┊   ┊ 70┊      return chats.filter(c => c.participants.includes(currentUser.id))\n ┊ 51┊ 71┊    },\n ┊ 52┊ 72┊\n-┊ 53┊   ┊    chat(root, { chatId }) {\n-┊ 54┊   ┊      return chats.find(c => c.id === chatId) || null\n+┊   ┊ 73┊    chat(root, { chatId }, { currentUser }) {\n+┊   ┊ 74┊      if (!currentUser) return null\n+┊   ┊ 75┊\n+┊   ┊ 76┊      const chat = chats.find(c => c.id === chatId)\n+┊   ┊ 77┊\n+┊   ┊ 78┊      if (!chat) return null\n+┊   ┊ 79┊\n+┊   ┊ 80┊      return chat.participants.includes(currentUser.id) ? chat : null\n ┊ 55┊ 81┊    },\n ┊ 56┊ 82┊  },\n ┊ 57┊ 83┊\n ┊ 58┊ 84┊  Mutation: {\n-┊ 59┊   ┊    addMessage(root, { chatId, content }, { pubsub }) {\n+┊   ┊ 85┊    addMessage(root, { chatId, content }, { currentUser, pubsub }) {\n+┊   ┊ 86┊      if (!currentUser) return null\n+┊   ┊ 87┊\n ┊ 60┊ 88┊      const chatIndex = chats.findIndex(c => c.id === chatId)\n ┊ 61┊ 89┊\n ┊ 62┊ 90┊      if (chatIndex === -1) return null\n ┊ 63┊ 91┊\n ┊ 64┊ 92┊      const chat = chats[chatIndex]\n+┊   ┊ 93┊\n+┊   ┊ 94┊      if (!chat.participants.includes(currentUser.id)) return null\n+┊   ┊ 95┊\n ┊ 65┊ 96┊      const recentMessage = messages[messages.length - 1]\n ┊ 66┊ 97┊      const messageId = String(Number(recentMessage.id) + 1)\n ┊ 67┊ 98┊      const message: Message = {\n ┊ 68┊ 99┊        id: messageId,\n ┊ 69┊100┊        createdAt: new Date(),\n-┊ 70┊   ┊        sender: '', // TODO: Fill-in\n-┊ 71┊   ┊        recipient: '', // TODO: Fill-in\n+┊   ┊101┊        sender: currentUser.id,\n+┊   ┊102┊        recipient: chat.participants.find(p => p !== currentUser.id) as string,\n ┊ 72┊103┊        content,\n ┊ 73┊104┊      }\n ┊ 74┊105┊\n```\n\n##### Changed tests&#x2F;mutations&#x2F;addMessage.test.ts\n```diff\n@@ -1,7 +1,7 @@\n ┊1┊1┊import { createTestClient } from 'apollo-server-testing'\n ┊2┊2┊import { ApolloServer, PubSub, gql } from 'apollo-server-express'\n ┊3┊3┊import schema from '../../schema'\n-┊4┊ ┊import { resetDb } from '../../db'\n+┊ ┊4┊import { resetDb, users } from '../../db'\n ┊5┊5┊\n ┊6┊6┊describe('Mutation.addMessage', () => {\n ┊7┊7┊  beforeEach(resetDb)\n```\n```diff\n@@ -9,7 +9,10 @@\n ┊ 9┊ 9┊  it('should add message to specified chat', async () => {\n ┊10┊10┊    const server = new ApolloServer({\n ┊11┊11┊      schema,\n-┊12┊  ┊      context: () => ({ pubsub: new PubSub() }),\n+┊  ┊12┊      context: () => ({\n+┊  ┊13┊        pubsub: new PubSub(),\n+┊  ┊14┊        currentUser: users[0],\n+┊  ┊15┊      }),\n ┊13┊16┊    })\n ┊14┊17┊\n ┊15┊18┊    const { query, mutate } = createTestClient(server)\n```\n\n##### Changed tests&#x2F;queries&#x2F;getChat.test.ts\n```diff\n@@ -1,10 +1,16 @@\n ┊ 1┊ 1┊import { createTestClient } from 'apollo-server-testing'\n ┊ 2┊ 2┊import { ApolloServer, gql } from 'apollo-server-express'\n ┊ 3┊ 3┊import schema from '../../schema'\n+┊  ┊ 4┊import { users } from '../../db'\n ┊ 4┊ 5┊\n ┊ 5┊ 6┊describe('Query.chat', () => {\n ┊ 6┊ 7┊  it('should fetch specified chat', async () => {\n-┊ 7┊  ┊    const server = new ApolloServer({ schema })\n+┊  ┊ 8┊    const server = new ApolloServer({\n+┊  ┊ 9┊      schema,\n+┊  ┊10┊      context: () => ({\n+┊  ┊11┊        currentUser: users[0],\n+┊  ┊12┊      }),\n+┊  ┊13┊    })\n ┊ 8┊14┊\n ┊ 9┊15┊    const { query } = createTestClient(server)\n ┊10┊16┊\n```\n\n##### Changed tests&#x2F;queries&#x2F;getChats.test.ts\n```diff\n@@ -1,10 +1,16 @@\n ┊ 1┊ 1┊import { createTestClient } from 'apollo-server-testing'\n ┊ 2┊ 2┊import { ApolloServer, gql } from 'apollo-server-express'\n ┊ 3┊ 3┊import schema from '../../schema'\n+┊  ┊ 4┊import { users } from '../../db'\n ┊ 4┊ 5┊\n ┊ 5┊ 6┊describe('Query.chats', () => {\n ┊ 6┊ 7┊  it('should fetch all chats', async () => {\n-┊ 7┊  ┊    const server = new ApolloServer({ schema })\n+┊  ┊ 8┊    const server = new ApolloServer({\n+┊  ┊ 9┊      schema,\n+┊  ┊10┊      context: () => ({\n+┊  ┊11┊        currentUser: users[0],\n+┊  ┊12┊      }),\n+┊  ┊13┊    })\n ┊ 8┊14┊\n ┊ 9┊15┊    const { query } = createTestClient(server)\n```\n\n[}]: #\n\nNow if we will get back to the app and refresh the page, we should see a new chats list which is only relevant to Ray Edwards. Earlier in this chapter, we've defined a new `isMine` field on the `Message` type. This field is useful because now we can differentiate between messages that are mine and messages that belong to the recipient. We can use that information to distinct between messages in our UI.\n\nLet's first download a new image that will help us achieve the new style and save it under the [`src/public/assets/message-yours.png`](https://github.com/Urigo/WhatsApp-Clone-Client-React/blob/cordova/public/assets/message-other.png?raw=true) path. Then let's implement the new style:\n\n[{]: <helper> (diffStep 11.1 files=\"src/components\" module=\"client\")\n\n#### [Step 11.1: Distinguish messages](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/7e36442)\n\n##### Changed src&#x2F;components&#x2F;ChatRoomScreen&#x2F;MessagesList.tsx\n```diff\n@@ -2,7 +2,7 @@\n ┊2┊2┊import * as React from 'react'\n ┊3┊3┊import { useEffect, useRef } from 'react'\n ┊4┊4┊import * as ReactDOM from 'react-dom'\n-┊5┊ ┊import styled from 'styled-components'\n+┊ ┊5┊import styled, { css } from 'styled-components'\n ┊6┊6┊\n ┊7┊7┊const Container = styled.div`\n ┊8┊8┊  display: block;\n```\n```diff\n@@ -12,8 +12,6 @@\n ┊12┊12┊`\n ┊13┊13┊\n ┊14┊14┊const MessageItem = styled.div `\n-┊15┊  ┊  float: right;\n-┊16┊  ┊  background-color: #dcf8c6;\n ┊17┊15┊  display: inline-block;\n ┊18┊16┊  position: relative;\n ┊19┊17┊  max-width: 100%;\n```\n```diff\n@@ -30,17 +28,33 @@\n ┊30┊28┊  }\n ┊31┊29┊\n ┊32┊30┊  &::before {\n-┊33┊  ┊    background-image: url(/assets/message-mine.png);\n ┊34┊31┊    content: '';\n ┊35┊32┊    position: absolute;\n ┊36┊33┊    bottom: 3px;\n ┊37┊34┊    width: 12px;\n ┊38┊35┊    height: 19px;\n-┊39┊  ┊    right: -11px;\n ┊40┊36┊    background-position: 50% 50%;\n ┊41┊37┊    background-repeat: no-repeat;\n ┊42┊38┊    background-size: contain;\n ┊43┊39┊  }\n+┊  ┊40┊\n+┊  ┊41┊  ${props => props.isMine ? css `\n+┊  ┊42┊    float: right;\n+┊  ┊43┊    background-color: #dcf8c6;\n+┊  ┊44┊\n+┊  ┊45┊    &::before {\n+┊  ┊46┊      right: -11px;\n+┊  ┊47┊      background-image: url(/assets/message-mine.png);\n+┊  ┊48┊    }\n+┊  ┊49┊  ` : css `\n+┊  ┊50┊    float: left;\n+┊  ┊51┊    background-color: #fff;\n+┊  ┊52┊\n+┊  ┊53┊    &::before {\n+┊  ┊54┊      left: -11px;\n+┊  ┊55┊      background-image: url(/assets/message-other.png);\n+┊  ┊56┊    }\n+┊  ┊57┊  `}\n ┊44┊58┊`\n ┊45┊59┊\n ┊46┊60┊const Contents = styled.div `\n```\n```diff\n@@ -74,7 +88,11 @@\n ┊74┊88┊  return (\n ┊75┊89┊    <Container ref={selfRef}>\n ┊76┊90┊      {messages.map((message) => (\n-┊77┊  ┊        <MessageItem data-testid=\"message-item\" key={message.id}>\n+┊  ┊91┊        <MessageItem\n+┊  ┊92┊          data-testid=\"message-item\"\n+┊  ┊93┊          isMine={message.isMine}\n+┊  ┊94┊          key={message.id}\n+┊  ┊95┊        >\n ┊78┊96┊          <Contents data-testid=\"message-content\">{message.content}</Contents>\n ┊79┊97┊          <Timestamp data-testid=\"message-date\">{moment(message.createdAt).format('HH:mm')}</Timestamp>\n ┊80┊98┊        </MessageItem>\n```\n\n##### Changed src&#x2F;components&#x2F;ChatRoomScreen&#x2F;index.tsx\n```diff\n@@ -54,6 +54,7 @@\n ┊54┊54┊          __typename: 'Message',\n ┊55┊55┊          id: Math.random().toString(36).substr(2, 9),\n ┊56┊56┊          createdAt: new Date(),\n+┊  ┊57┊          isMine: true,\n ┊57┊58┊          chat: {\n ┊58┊59┊            __typename: 'Chat',\n ┊59┊60┊            id: chatId,\n```\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;ChatsList.test.tsx\n```diff\n@@ -30,6 +30,7 @@\n ┊30┊30┊                  id: 1,\n ┊31┊31┊                  content: 'Hello',\n ┊32┊32┊                  createdAt: new Date(0),\n+┊  ┊33┊                  isMine: true,\n ┊33┊34┊                  chat: {\n ┊34┊35┊                    __typename: 'Chat',\n ┊35┊36┊                    id: 1,\n```\n```diff\n@@ -75,6 +76,7 @@\n ┊75┊76┊                  id: 1,\n ┊76┊77┊                  content: 'Hello',\n ┊77┊78┊                  createdAt: new Date(0),\n+┊  ┊79┊                  isMine: true,\n ┊78┊80┊                  chat: {\n ┊79┊81┊                    __typename: 'Chat',\n ┊80┊82┊                    id: 1,\n```\n\n[}]: #\n\nThis is how the updated `ChatRoomScreen` should look like:\n\n\n\n![chat-room-screen](https://user-images.githubusercontent.com/7648874/55326701-face8700-54ba-11e9-877e-0b7dd71a1b68.png)\n\n\n\nWe can use a temporary solution to log-in and alternate between different users. This would be a good way to test data authorization without implementing an authentication mechanism. One way to know which user is logged in is via [cookies](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies).\n\nCookies are just text files which are stored locally on your computer and they contain key-value data maps. Cookies will be sent automatically by the browser with every HTTP request under the `Cookie` header. The header can be parsed and read by the server and this way inform it about the state of the client. Cookie values can also be set by the server by sending back a response which contain a `Set-Cookie` header. The browser will automatically write these cookies because of its specification and how it works.\n\nThis is how you can set cookies on the client:\n\n```js\ndocument.cookie = \"yummy_cookie=choco\"\ndocument.cookie = \"tasty_cookie=strawberry\"\n// logs \"yummy_cookie=choco; tasty_cookie=strawberry\"\n```\n\nAnd this is how further requests would look like:\n\n```\nGET /sample_page.html HTTP/2.0\nHost: www.example.org\nCookie: yummy_cookie=choco; tasty_cookie=strawberry\n```\n\nUsing this method we can set the current user's ID. Open your browser's dev-console, and type the following:\n\n```js\n// Ray Edwards\ndocument.cookie = 'currentUserId=1'\n```\n\nTo be able to send cookies with Apollo Client, we need to set the [`credentials`](https://www.apollographql.com/docs/react/recipes/authentication#cookie) option to \"include\" when creating the HTTP link:\n\n[{]: <helper> (diffStep 11.2 module=\"client\")\n\n#### [Step 11.2: Support credentials](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/e042471)\n\n##### Changed src&#x2F;client.ts\n```diff\n@@ -10,6 +10,7 @@\n ┊10┊10┊\n ┊11┊11┊const httpLink = new HttpLink({\n ┊12┊12┊  uri: httpUri,\n+┊  ┊13┊  credentials: 'include',\n ┊13┊14┊})\n ┊14┊15┊\n ┊15┊16┊const wsLink = new WebSocketLink({\n```\n\n[}]: #\n\nThis will set the [`Access-Control-Allow-Credentials`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Credentials) header to “include” with each HTTP request which is necessary when using the POST method. In correlation to that, we would need to configure the server to be able to receive and set cookies. This can be done via CORS options like so:\n\n[{]: <helper> (diffStep 8.4 files=\"index.ts\" module=\"server\")\n\n#### [Step 8.4: Support credentials](https://github.com/Urigo/WhatsApp-Clone-Server/commit/d65c2f3)\n\n##### Changed index.ts\n```diff\n@@ -8,7 +8,8 @@\n ┊ 8┊ 8┊\n ┊ 9┊ 9┊const app = express()\n ┊10┊10┊\n-┊11┊  ┊app.use(cors())\n+┊  ┊11┊const origin = process.env.ORIGIN || 'http://localhost:3000'\n+┊  ┊12┊app.use(cors({ credentials: true, origin }))\n ┊12┊13┊app.use(bodyParser.json())\n ┊13┊14┊\n ┊14┊15┊app.get('/_ping', (req, res) => {\n```\n```diff\n@@ -27,6 +28,7 @@\n ┊27┊28┊server.applyMiddleware({\n ┊28┊29┊  app,\n ┊29┊30┊  path: '/graphql',\n+┊  ┊31┊  cors: { credentials: true, origin },\n ┊30┊32┊})\n ┊31┊33┊\n ┊32┊34┊const httpServer = http.createServer(app)\n```\n\n[}]: #\n\nSo how exactly does one retrieve the values of the cookies? Like mentioned earlier, each and every request will have them set on the `cookie` header, so one way would be by reading the header directly, but a more convenient way would be using an Express middleware called [`cookie-parser`](https://www.npmjs.com/package/cookie-parser):\n\n  $ npm install cookie-parser\n\n[{]: <helper> (diffStep 8.5 files=\"index.ts\" module=\"server\")\n\n#### [Step 8.5: Use cookie parser](https://github.com/Urigo/WhatsApp-Clone-Server/commit/2cd3964)\n\n##### Changed index.ts\n```diff\n@@ -1,6 +1,7 @@\n ┊1┊1┊import { ApolloServer, gql, PubSub } from 'apollo-server-express'\n ┊2┊2┊import bodyParser from 'body-parser'\n ┊3┊3┊import cors from 'cors'\n+┊ ┊4┊import cookieParser from 'cookie-parser'\n ┊4┊5┊import express from 'express'\n ┊5┊6┊import http from 'http'\n ┊6┊7┊import { users } from './db'\n```\n```diff\n@@ -11,6 +12,7 @@\n ┊11┊12┊const origin = process.env.ORIGIN || 'http://localhost:3000'\n ┊12┊13┊app.use(cors({ credentials: true, origin }))\n ┊13┊14┊app.use(bodyParser.json())\n+┊  ┊15┊app.use(cookieParser())\n ┊14┊16┊\n ┊15┊17┊app.get('/_ping', (req, res) => {\n ┊16┊18┊  res.send('pong')\n```\n\n[}]: #\n\n`cookie-parser` will read the `Cookie` header, it will parse it into a JSON and will define it on `req.cookies`. Since we’re using Apollo-Server with Express, the `req` object should be accessible as the first argument in the `context` function. This means that we can use the `currentUserId` from the cookies to fetch the current user from our users collection and define it on the context object:\n\n[{]: <helper> (diffStep 8.6 module=\"server\")\n\n#### [Step 8.6: Define current user based on cookies](https://github.com/Urigo/WhatsApp-Clone-Server/commit/bdbae75)\n\n##### Changed index.ts\n```diff\n@@ -21,8 +21,8 @@\n ┊21┊21┊const pubsub = new PubSub()\n ┊22┊22┊const server = new ApolloServer({\n ┊23┊23┊  schema,\n-┊24┊  ┊  context: () => ({\n-┊25┊  ┊    currentUser: users.find(u => u.id === '1'),\n+┊  ┊24┊  context: ({ req }) => ({\n+┊  ┊25┊    currentUser: users.find(u => u.id === req.cookies.currentUserId),\n ┊26┊26┊    pubsub,\n ┊27┊27┊  }),\n ┊28┊28┊})\n```\n\n[}]: #\n\nNow you can go ahead and change the value of the `currentUserId` cookie and see how it affects the view anytime you refresh the page. Needless to say that this is not the most convenient way to switch between users, so we’re gonna implement a dedicated screen that will set the cookies for us.\n\nAll the auth related logic should go into a dedicated service since it can serve us vastly across the application, not just for a single component. Thus we will create a new service called `auth.service`, which will contain 3 basic functions for now: `signIn()`, `signOut()` and `isSignedIn():\n\n[{]: <helper> (diffStep 11.3 module=\"client\")\n\n#### [Step 11.3: Add basic auth.service](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/adbd108)\n\n##### Added src&#x2F;services&#x2F;auth.service.tsx\n```diff\n@@ -0,0 +1,21 @@\n+┊  ┊ 1┊import client from '../client'\n+┊  ┊ 2┊\n+┊  ┊ 3┊export const signIn = (currentUserId) => {\n+┊  ┊ 4┊  document.cookie = `currentUserId=${currentUserId}`\n+┊  ┊ 5┊\n+┊  ┊ 6┊  // This will become async in the near future\n+┊  ┊ 7┊  return Promise.resolve()\n+┊  ┊ 8┊}\n+┊  ┊ 9┊\n+┊  ┊10┊export const signOut = () => {\n+┊  ┊11┊  // \"expires\" represents the lifespan of a cookie. Beyond that date the cookie will\n+┊  ┊12┊  // be deleted by the browser. \"expires\" cannot be viewed from \"document.cookie\"\n+┊  ┊13┊  document.cookie = `currentUserId=;expires=${new Date(0)}`\n+┊  ┊14┊\n+┊  ┊15┊  // Clear cache\n+┊  ┊16┊  return client.clearStore()\n+┊  ┊17┊}\n+┊  ┊18┊\n+┊  ┊19┊export const isSignedIn = () => {\n+┊  ┊20┊  return /currentUserId=.+(;|$)/.test(document.cookie)\n+┊  ┊21┊}\n```\n\n[}]: #\n\nNow we will implement the `AuthScreen`. For now this screen should be fairly simple. It should contain a single `TextField` to specify the current user ID, and a `sign-in` button that will call the `signIn()` method with the specified ID. Once it does so, we will be proceeded to the `ChatsListScreen`. First we will download and save the following assets:\n\n- [`src/public/assets/whatsapp-icon.ping`](https://github.com/Urigo/WhatsApp-Clone-Client-React/raw/wip/cookie-auth/public/assets/whatsapp-icon.png)\n\n[{]: <helper> (diffStep 11.4 files=\"components\" module=\"client\")\n\n#### [Step 11.4: Add AuthScreen](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/647bb65)\n\n##### Added src&#x2F;components&#x2F;AuthScreen&#x2F;index.tsx\n```diff\n@@ -0,0 +1,162 @@\n+┊   ┊  1┊import MaterialButton from '@material-ui/core/Button'\n+┊   ┊  2┊import MaterialTextField from '@material-ui/core/TextField'\n+┊   ┊  3┊import * as React from 'react'\n+┊   ┊  4┊import { useCallback, useMemo, useState } from 'react'\n+┊   ┊  5┊import styled from 'styled-components'\n+┊   ┊  6┊import { signIn } from '../../services/auth.service'\n+┊   ┊  7┊\n+┊   ┊  8┊const Container = styled.div `\n+┊   ┊  9┊  height: 100%;\n+┊   ┊ 10┊  background: radial-gradient(rgb(34, 65, 67), rgb(17, 48, 50)),\n+┊   ┊ 11┊    url(/assets/chat-background.jpg) no-repeat;\n+┊   ┊ 12┊  background-size: cover;\n+┊   ┊ 13┊  background-blend-mode: multiply;\n+┊   ┊ 14┊  color: white;\n+┊   ┊ 15┊`\n+┊   ┊ 16┊\n+┊   ┊ 17┊const Intro = styled.div `\n+┊   ┊ 18┊  height: 265px;\n+┊   ┊ 19┊`\n+┊   ┊ 20┊\n+┊   ┊ 21┊const Icon = styled.img `\n+┊   ┊ 22┊  width: 125px;\n+┊   ┊ 23┊  height: auto;\n+┊   ┊ 24┊  margin-left: auto;\n+┊   ┊ 25┊  margin-right: auto;\n+┊   ┊ 26┊  padding-top: 70px;\n+┊   ┊ 27┊  display: block;\n+┊   ┊ 28┊`\n+┊   ┊ 29┊\n+┊   ┊ 30┊const Title = styled.h2 `\n+┊   ┊ 31┊  width: 100%;\n+┊   ┊ 32┊  text-align: center;\n+┊   ┊ 33┊  color: white;\n+┊   ┊ 34┊`\n+┊   ┊ 35┊\n+┊   ┊ 36┊const Alternative = styled.div `\n+┊   ┊ 37┊  position: fixed;\n+┊   ┊ 38┊  bottom: 10px;\n+┊   ┊ 39┊  left: 10px;\n+┊   ┊ 40┊\n+┊   ┊ 41┊  a {\n+┊   ┊ 42┊    color: var(--secondary-bg);\n+┊   ┊ 43┊  }\n+┊   ┊ 44┊`\n+┊   ┊ 45┊\n+┊   ┊ 46┊const SignInForm = styled.div `\n+┊   ┊ 47┊  height: calc(100% - 265px);\n+┊   ┊ 48┊`\n+┊   ┊ 49┊\n+┊   ┊ 50┊const ActualForm = styled.form `\n+┊   ┊ 51┊  padding: 20px;\n+┊   ┊ 52┊`\n+┊   ┊ 53┊\n+┊   ┊ 54┊const Section = styled.div `\n+┊   ┊ 55┊  width: 100%;\n+┊   ┊ 56┊  padding-bottom: 35px;\n+┊   ┊ 57┊`\n+┊   ┊ 58┊\n+┊   ┊ 59┊const Legend = styled.legend `\n+┊   ┊ 60┊  font-weight: bold;\n+┊   ┊ 61┊  color: white;\n+┊   ┊ 62┊`\n+┊   ┊ 63┊\n+┊   ┊ 64┊const Label = styled.label `\n+┊   ┊ 65┊  color: white !important;\n+┊   ┊ 66┊`\n+┊   ┊ 67┊\n+┊   ┊ 68┊const Input = styled.input `\n+┊   ┊ 69┊  color: white;\n+┊   ┊ 70┊\n+┊   ┊ 71┊  &::placeholder {\n+┊   ┊ 72┊    color: var(--primary-bg);\n+┊   ┊ 73┊  }\n+┊   ┊ 74┊`\n+┊   ┊ 75┊\n+┊   ┊ 76┊const TextField = styled(MaterialTextField) `\n+┊   ┊ 77┊  width: 100%;\n+┊   ┊ 78┊  position: relative;\n+┊   ┊ 79┊\n+┊   ┊ 80┊  > div::before {\n+┊   ┊ 81┊    border-color: white !important;\n+┊   ┊ 82┊  }\n+┊   ┊ 83┊\n+┊   ┊ 84┊  input {\n+┊   ┊ 85┊    color: white !important;\n+┊   ┊ 86┊\n+┊   ┊ 87┊    &::placeholder {\n+┊   ┊ 88┊      color: var(--primary-bg) !important;\n+┊   ┊ 89┊    }\n+┊   ┊ 90┊  }\n+┊   ┊ 91┊\n+┊   ┊ 92┊  label {\n+┊   ┊ 93┊    color: white !important;\n+┊   ┊ 94┊  }\n+┊   ┊ 95┊`\n+┊   ┊ 96┊\n+┊   ┊ 97┊const Button = styled(MaterialButton) `\n+┊   ┊ 98┊  width: 100px;\n+┊   ┊ 99┊  display: block !important;\n+┊   ┊100┊  margin: auto !important;\n+┊   ┊101┊  background-color: var(--secondary-bg) !important;\n+┊   ┊102┊\n+┊   ┊103┊  &[disabled] {\n+┊   ┊104┊    color: #38a81c;\n+┊   ┊105┊  }\n+┊   ┊106┊\n+┊   ┊107┊  &:not([disabled]) {\n+┊   ┊108┊    color: white;\n+┊   ┊109┊  }\n+┊   ┊110┊`\n+┊   ┊111┊\n+┊   ┊112┊export default ({ history }) => {\n+┊   ┊113┊  const [userId, setUserId] = useState('')\n+┊   ┊114┊\n+┊   ┊115┊  const onUserIdChange = useCallback(({ target }) => {\n+┊   ┊116┊    setUserId(target.value)\n+┊   ┊117┊  }, [true])\n+┊   ┊118┊\n+┊   ┊119┊  const maySignIn = useCallback(() => {\n+┊   ┊120┊    return !!userId\n+┊   ┊121┊  }, [userId])\n+┊   ┊122┊\n+┊   ┊123┊  const handleSignIn = useCallback(() => {\n+┊   ┊124┊    signIn(userId).then(() => {\n+┊   ┊125┊      history.replace('/chats')\n+┊   ┊126┊    })\n+┊   ┊127┊  }, [userId])\n+┊   ┊128┊\n+┊   ┊129┊  return (\n+┊   ┊130┊    <Container>\n+┊   ┊131┊      <Intro>\n+┊   ┊132┊        <Icon src=\"assets/whatsapp-icon.png\" className=\"AuthScreen-icon\" />\n+┊   ┊133┊        <Title className=\"AuthScreen-title\">WhatsApp</Title>\n+┊   ┊134┊      </Intro>\n+┊   ┊135┊      <SignInForm>\n+┊   ┊136┊        <ActualForm>\n+┊   ┊137┊          <Legend>Sign in</Legend>\n+┊   ┊138┊          <Section>\n+┊   ┊139┊            <TextField\n+┊   ┊140┊              data-testid=\"user-id-input\"\n+┊   ┊141┊              label=\"User ID\"\n+┊   ┊142┊              value={userId}\n+┊   ┊143┊              onChange={onUserIdChange}\n+┊   ┊144┊              margin=\"normal\"\n+┊   ┊145┊              placeholder=\"Enter current user ID\"\n+┊   ┊146┊            />\n+┊   ┊147┊          </Section>\n+┊   ┊148┊          <Button\n+┊   ┊149┊            data-testid=\"sign-in-button\"\n+┊   ┊150┊            type=\"button\"\n+┊   ┊151┊            color=\"secondary\"\n+┊   ┊152┊            variant=\"contained\"\n+┊   ┊153┊            disabled={!maySignIn()}\n+┊   ┊154┊            onClick={handleSignIn}\n+┊   ┊155┊          >\n+┊   ┊156┊            Sign in\n+┊   ┊157┊          </Button>\n+┊   ┊158┊        </ActualForm>\n+┊   ┊159┊      </SignInForm>\n+┊   ┊160┊    </Container>\n+┊   ┊161┊  )\n+┊   ┊162┊}\n```\n\n[}]: #\n\nAccordingly we will define a new `/sign-in` route that will render the `AuthScreen` we’re under that path name:\n\n[{]: <helper> (diffStep 11.4 files=\"App\" module=\"client\")\n\n#### [Step 11.4: Add AuthScreen](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/647bb65)\n\n##### Changed src&#x2F;App.jsx\n```diff\n@@ -1,5 +1,6 @@\n ┊1┊1┊import * as React from 'react'\n ┊2┊2┊import { BrowserRouter, Route, Redirect } from 'react-router-dom'\n+┊ ┊3┊import AuthScreen from './components/AuthScreen'\n ┊3┊4┊import ChatRoomScreen from './components/ChatRoomScreen'\n ┊4┊5┊import ChatsListScreen from './components/ChatsListScreen'\n ┊5┊6┊import AnimatedSwitch from './components/AnimatedSwitch'\n```\n```diff\n@@ -11,6 +12,7 @@\n ┊11┊12┊  return (\n ┊12┊13┊    <BrowserRouter>\n ┊13┊14┊      <AnimatedSwitch>\n+┊  ┊15┊        <Route exact path=\"/sign-in\" component={AuthScreen} />\n ┊14┊16┊        <Route exact path=\"/chats\" component={ChatsListScreen} />\n ┊15┊17┊        <Route exact path=\"/chats/:chatId\" component={ChatRoomScreen} />\n ┊16┊18┊      </AnimatedSwitch>\n```\n\n[}]: #\n\nThis is how the new screen should look like:\n\n![auth-screen](https://user-images.githubusercontent.com/7648874/55606715-7a56a180-57ac-11e9-8eea-2da5931cccf5.png)\n\nNow let’s type the `/sign-in` route in our browser’s navigation bar and assign a user ID, see how it affects what chats we see in the `ChatsListScreen`. You’ve probably noticed that there’s no way to escape from the `/chats` route unless we edit the browser’s navigation bar manually. To fix that, we will add a new sign-out button to the navbar of the `ChatsListScreen` that will call the `signOut()` method anytime we click on it, and will bring us back to the `AuthScreen`:\n\n[{]: <helper> (diffStep 11.5 module=\"client\")\n\n#### [Step 11.5: Add sign-out button that ChatsNavbar](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/dc1711e)\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;ChatsNavbar.tsx\n```diff\n@@ -1,18 +1,41 @@\n-┊ 1┊  ┊import { Toolbar } from '@material-ui/core'\n+┊  ┊ 1┊import { Button, Toolbar } from '@material-ui/core'\n+┊  ┊ 2┊import SignOutIcon from '@material-ui/icons/PowerSettingsNew'\n ┊ 2┊ 3┊import * as React from 'react'\n+┊  ┊ 4┊import { useCallback } from 'react'\n ┊ 3┊ 5┊import styled from 'styled-components'\n+┊  ┊ 6┊import { signOut } from '../../services/auth.service'\n ┊ 4┊ 7┊\n ┊ 5┊ 8┊const Container = styled(Toolbar) `\n+┊  ┊ 9┊  display: flex;\n ┊ 6┊10┊  background-color: var(--primary-bg);\n ┊ 7┊11┊  color: var(--primary-text);\n ┊ 8┊12┊  font-size: 20px;\n ┊ 9┊13┊  line-height: 40px;\n ┊10┊14┊`\n ┊11┊15┊\n-┊12┊  ┊const ChatsNavbar = () => (\n-┊13┊  ┊  <Container>\n-┊14┊  ┊    Whatsapp Clone\n-┊15┊  ┊  </Container>\n-┊16┊  ┊)\n+┊  ┊16┊const Title = styled.div `\n+┊  ┊17┊  flex: 1;\n+┊  ┊18┊`\n+┊  ┊19┊\n+┊  ┊20┊const LogoutButton = styled(Button) `\n+┊  ┊21┊  color: var(--primary-text) !important;\n+┊  ┊22┊`\n+┊  ┊23┊\n+┊  ┊24┊const ChatsNavbar = ({ history }) => {\n+┊  ┊25┊  const handleSignOut = useCallback(() => {\n+┊  ┊26┊    signOut().then(() => {\n+┊  ┊27┊      history.replace('/sign-in')\n+┊  ┊28┊    })\n+┊  ┊29┊  }, [true])\n+┊  ┊30┊\n+┊  ┊31┊  return (\n+┊  ┊32┊    <Container>\n+┊  ┊33┊      <Title>Whatsapp Clone</Title>\n+┊  ┊34┊      <LogoutButton data-testid=\"sign-out-button\" onClick={handleSignOut}>\n+┊  ┊35┊        <SignOutIcon />\n+┊  ┊36┊      </LogoutButton>\n+┊  ┊37┊    </Container>\n+┊  ┊38┊  )\n+┊  ┊39┊}\n ┊17┊40┊\n-┊18┊  ┊export default ChatsNavbar\n+┊  ┊41┊export default ChatsNavbar🚫↵\n```\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;index.tsx\n```diff\n@@ -9,7 +9,7 @@\n ┊ 9┊ 9┊\n ┊10┊10┊const ChatsListScreen = ({ history }) => (\n ┊11┊11┊  <Container>\n-┊12┊  ┊    <ChatsNavbar />\n+┊  ┊12┊    <ChatsNavbar history={history} />\n ┊13┊13┊    <ChatsList history={history} />\n ┊14┊14┊  </Container>\n ┊15┊15┊)\n```\n\n[}]: #\n\nAt this point we’ve got everything we need, but we will add a small touch to improve the user experience and make it feel more complete. Users who aren’t logged in shouldn’t be able to view any screen besides the `AuthScreen`. First they need to sign-in, and only then they will be able to view the `ChatsListScreen` and `ChatRoomScreen`. To achieve that, we will wrap all the components which require authentication before we provide them into their routes. This wrap will basically check whether a user is logged in or not by reading the cookies, and if not we will be redirected to the `/sign-in` route. Let’s implement that wrap in the `auth.service` and call it `withAuth()`:\n\n[{]: <helper> (diffStep 11.6 files=\"auth.service\" module=\"client\")\n\n#### [Step 11.6: Add withAuth() route wrapper](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/d622494)\n\n##### Changed src&#x2F;services&#x2F;auth.service.tsx\n```diff\n@@ -1,4 +1,27 @@\n+┊  ┊ 1┊import * as React from 'react'\n+┊  ┊ 2┊import { Redirect } from 'react-router-dom'\n ┊ 1┊ 3┊import client from '../client'\n+┊  ┊ 4┊import { useCacheService } from './cache.service'\n+┊  ┊ 5┊\n+┊  ┊ 6┊export const withAuth = (Component: React.ComponentType) => {\n+┊  ┊ 7┊  return (props) => {\n+┊  ┊ 8┊    if (!isSignedIn()) {\n+┊  ┊ 9┊      if (props.history.location.pathname === '/sign-in') {\n+┊  ┊10┊        return null\n+┊  ┊11┊      }\n+┊  ┊12┊\n+┊  ┊13┊      return (\n+┊  ┊14┊        <Redirect to=\"/sign-in\" />\n+┊  ┊15┊      )\n+┊  ┊16┊    }\n+┊  ┊17┊\n+┊  ┊18┊    useCacheService()\n+┊  ┊19┊\n+┊  ┊20┊    return (\n+┊  ┊21┊      <Component {...props} />\n+┊  ┊22┊    )\n+┊  ┊23┊  }\n+┊  ┊24┊}\n ┊ 2┊25┊\n ┊ 3┊26┊export const signIn = (currentUserId) => {\n ┊ 4┊27┊  document.cookie = `currentUserId=${currentUserId}`\n```\n\n[}]: #\n\nWe will use this function to wrap the right components in our app’s router. Note that since we used the `useCacheService()` directly in the `withAuth()` method, there’s no need to use it in the router itself anymore. This makes a lot more sense since there’s no need to stay subscribed to data that you're not gonna receive from the first place unless you’re logged-in:\n\n[{]: <helper> (diffStep 11.6 files=\"App\" module=\"client\")\n\n#### [Step 11.6: Add withAuth() route wrapper](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/d622494)\n\n##### Changed src&#x2F;App.jsx\n```diff\n@@ -4,22 +4,18 @@\n ┊ 4┊ 4┊import ChatRoomScreen from './components/ChatRoomScreen'\n ┊ 5┊ 5┊import ChatsListScreen from './components/ChatsListScreen'\n ┊ 6┊ 6┊import AnimatedSwitch from './components/AnimatedSwitch'\n-┊ 7┊  ┊import { useCacheService } from './services/cache.service'\n+┊  ┊ 7┊import { withAuth } from './services/auth.service'\n ┊ 8┊ 8┊\n-┊ 9┊  ┊const App = () => {\n-┊10┊  ┊  useCacheService()\n-┊11┊  ┊\n-┊12┊  ┊  return (\n-┊13┊  ┊    <BrowserRouter>\n-┊14┊  ┊      <AnimatedSwitch>\n-┊15┊  ┊        <Route exact path=\"/sign-in\" component={AuthScreen} />\n-┊16┊  ┊        <Route exact path=\"/chats\" component={ChatsListScreen} />\n-┊17┊  ┊        <Route exact path=\"/chats/:chatId\" component={ChatRoomScreen} />\n-┊18┊  ┊      </AnimatedSwitch>\n-┊19┊  ┊      <Route exact path=\"/\" render={redirectToChats} />\n-┊20┊  ┊    </BrowserRouter>\n-┊21┊  ┊  )\n-┊22┊  ┊}\n+┊  ┊ 9┊const App = () => (\n+┊  ┊10┊  <BrowserRouter>\n+┊  ┊11┊    <AnimatedSwitch>\n+┊  ┊12┊      <Route exact path=\"/sign-in\" component={AuthScreen} />\n+┊  ┊13┊      <Route exact path=\"/chats\" component={withAuth(ChatsListScreen)} />\n+┊  ┊14┊      <Route exact path=\"/chats/:chatId\" component={withAuth(ChatRoomScreen)} />\n+┊  ┊15┊    </AnimatedSwitch>\n+┊  ┊16┊    <Route exact path=\"/\" render={redirectToChats} />\n+┊  ┊17┊  </BrowserRouter>\n+┊  ┊18┊)\n ┊23┊19┊\n ┊24┊20┊const redirectToChats = () => (\n ┊25┊21┊  <Redirect to=\"/chats\" />\n```\n\n[}]: #\n\nAssuming that you’re not logged-in, if you’ll try to force navigate to the `/chats` route you should be automatically redirected to the `/sign-in` form. We will finish the chapter here as we wanna keep things simple and gradual. It’s true that we haven’t implemented true authentication, but that would be addressed soon further in this tutorial."
          },
          {
            "manualTitle": "Step 12: Adding and removing chats",
            "stepRevision": "68c4246cb640a0e68979994cb3795e89e27051c4",
            "manualView": "Now that the users system is ready it would be a lot more comfortable to implement a chat creation feature. In the original Whatsapp, you can create a new chat based on your available contacts - a list of your contacts will appear on the screen and by picking one of the items you’ll basically be able to start chatting with the selected contact. However, since in our app we don’t have any real contacts (yet), we will implement the chats creation feature based on all available users in our DB. By picking a user from the users list we will be able to start chatting with it.\n\n![demo](https://user-images.githubusercontent.com/7648874/55896445-e4c67200-5bf0-11e9-9c1c-88318642ef81.gif)\n\nTo be able to fetch users in our system we will need to add a new query called `users`. The `users` query will retrieve all users except for current user:\n\n[{]: <helper> (diffStep 9.1 module=\"server\")\n\n#### [Step 9.1: Add Query.users](https://github.com/Urigo/WhatsApp-Clone-Server/commit/b290ccf)\n\n##### Changed schema&#x2F;resolvers.ts\n```diff\n@@ -80,6 +80,12 @@\n ┊80┊80┊\n ┊81┊81┊      return chat.participants.includes(currentUser.id) ? chat : null\n ┊82┊82┊    },\n+┊  ┊83┊\n+┊  ┊84┊    users(root, args, { currentUser }) {\n+┊  ┊85┊      if (!currentUser) return []\n+┊  ┊86┊\n+┊  ┊87┊      return users.filter(u => u.id !== currentUser.id)\n+┊  ┊88┊    },\n ┊83┊89┊  },\n ┊84┊90┊\n ┊85┊91┊  Mutation: {\n```\n\n##### Changed schema&#x2F;typeDefs.graphql\n```diff\n@@ -28,6 +28,7 @@\n ┊28┊28┊type Query {\n ┊29┊29┊  chats: [Chat!]!\n ┊30┊30┊  chat(chatId: ID!): Chat\n+┊  ┊31┊  users: [User!]!\n ┊31┊32┊}\n ┊32┊33┊\n ┊33┊34┊type Mutation {\n```\n\n##### Added tests&#x2F;queries&#x2F;__snapshots__&#x2F;getUsers.test.ts.snap\n```diff\n@@ -0,0 +1,55 @@\n+┊  ┊ 1┊// Jest Snapshot v1, https://goo.gl/fbAQLP\n+┊  ┊ 2┊\n+┊  ┊ 3┊exports[`Query.getUsers should fetch all users except the one signed-in 1`] = `\n+┊  ┊ 4┊Object {\n+┊  ┊ 5┊  \"users\": Array [\n+┊  ┊ 6┊    Object {\n+┊  ┊ 7┊      \"id\": \"2\",\n+┊  ┊ 8┊      \"name\": \"Ethan Gonzalez\",\n+┊  ┊ 9┊      \"picture\": \"https://randomuser.me/api/portraits/thumb/men/1.jpg\",\n+┊  ┊10┊    },\n+┊  ┊11┊    Object {\n+┊  ┊12┊      \"id\": \"3\",\n+┊  ┊13┊      \"name\": \"Bryan Wallace\",\n+┊  ┊14┊      \"picture\": \"https://randomuser.me/api/portraits/thumb/men/2.jpg\",\n+┊  ┊15┊    },\n+┊  ┊16┊    Object {\n+┊  ┊17┊      \"id\": \"4\",\n+┊  ┊18┊      \"name\": \"Avery Stewart\",\n+┊  ┊19┊      \"picture\": \"https://randomuser.me/api/portraits/thumb/women/1.jpg\",\n+┊  ┊20┊    },\n+┊  ┊21┊    Object {\n+┊  ┊22┊      \"id\": \"5\",\n+┊  ┊23┊      \"name\": \"Katie Peterson\",\n+┊  ┊24┊      \"picture\": \"https://randomuser.me/api/portraits/thumb/women/2.jpg\",\n+┊  ┊25┊    },\n+┊  ┊26┊  ],\n+┊  ┊27┊}\n+┊  ┊28┊`;\n+┊  ┊29┊\n+┊  ┊30┊exports[`Query.getUsers should fetch all users except the one signed-in 2`] = `\n+┊  ┊31┊Object {\n+┊  ┊32┊  \"users\": Array [\n+┊  ┊33┊    Object {\n+┊  ┊34┊      \"id\": \"1\",\n+┊  ┊35┊      \"name\": \"Ray Edwards\",\n+┊  ┊36┊      \"picture\": \"https://randomuser.me/api/portraits/thumb/lego/1.jpg\",\n+┊  ┊37┊    },\n+┊  ┊38┊    Object {\n+┊  ┊39┊      \"id\": \"3\",\n+┊  ┊40┊      \"name\": \"Bryan Wallace\",\n+┊  ┊41┊      \"picture\": \"https://randomuser.me/api/portraits/thumb/men/2.jpg\",\n+┊  ┊42┊    },\n+┊  ┊43┊    Object {\n+┊  ┊44┊      \"id\": \"4\",\n+┊  ┊45┊      \"name\": \"Avery Stewart\",\n+┊  ┊46┊      \"picture\": \"https://randomuser.me/api/portraits/thumb/women/1.jpg\",\n+┊  ┊47┊    },\n+┊  ┊48┊    Object {\n+┊  ┊49┊      \"id\": \"5\",\n+┊  ┊50┊      \"name\": \"Katie Peterson\",\n+┊  ┊51┊      \"picture\": \"https://randomuser.me/api/portraits/thumb/women/2.jpg\",\n+┊  ┊52┊    },\n+┊  ┊53┊  ],\n+┊  ┊54┊}\n+┊  ┊55┊`;\n```\n\n##### Added tests&#x2F;queries&#x2F;getUsers.test.ts\n```diff\n@@ -0,0 +1,51 @@\n+┊  ┊ 1┊import { createTestClient } from 'apollo-server-testing'\n+┊  ┊ 2┊import { ApolloServer, gql } from 'apollo-server-express'\n+┊  ┊ 3┊import schema from '../../schema'\n+┊  ┊ 4┊import { users } from '../../db'\n+┊  ┊ 5┊\n+┊  ┊ 6┊describe('Query.getUsers', () => {\n+┊  ┊ 7┊  it('should fetch all users except the one signed-in', async () => {\n+┊  ┊ 8┊    let currentUser = users[0]\n+┊  ┊ 9┊\n+┊  ┊10┊    const server = new ApolloServer({\n+┊  ┊11┊      schema,\n+┊  ┊12┊      context: () => ({ currentUser }),\n+┊  ┊13┊    })\n+┊  ┊14┊\n+┊  ┊15┊    const { query } = createTestClient(server)\n+┊  ┊16┊\n+┊  ┊17┊    let res = await query({\n+┊  ┊18┊      query: gql `\n+┊  ┊19┊        query GetUsers {\n+┊  ┊20┊          users {\n+┊  ┊21┊            id\n+┊  ┊22┊            name\n+┊  ┊23┊            picture\n+┊  ┊24┊          }\n+┊  ┊25┊        }\n+┊  ┊26┊      `,\n+┊  ┊27┊    })\n+┊  ┊28┊\n+┊  ┊29┊    expect(res.data).toBeDefined()\n+┊  ┊30┊    expect(res.errors).toBeUndefined()\n+┊  ┊31┊    expect(res.data).toMatchSnapshot()\n+┊  ┊32┊\n+┊  ┊33┊    currentUser = users[1]\n+┊  ┊34┊\n+┊  ┊35┊    res = await query({\n+┊  ┊36┊      query: gql `\n+┊  ┊37┊        query GetUsers {\n+┊  ┊38┊          users {\n+┊  ┊39┊            id\n+┊  ┊40┊            name\n+┊  ┊41┊            picture\n+┊  ┊42┊          }\n+┊  ┊43┊        }\n+┊  ┊44┊      `,\n+┊  ┊45┊    })\n+┊  ┊46┊\n+┊  ┊47┊    expect(res.data).toBeDefined()\n+┊  ┊48┊    expect(res.errors).toBeUndefined()\n+┊  ┊49┊    expect(res.data).toMatchSnapshot()\n+┊  ┊50┊  })\n+┊  ┊51┊})\n```\n\n[}]: #\n\nThis query will be reflected in a component called `UsersList`. First we will define and export a new fragment called `User`:\n\n[{]: <helper> (diffStep 12.1 files=\"graphql/fragments\" module=\"client\")\n\n#### [Step 12.1: Add basic ChatCreationScreen](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/2f2f2ed)\n\n##### Changed src&#x2F;graphql&#x2F;fragments&#x2F;index.ts\n```diff\n@@ -1,3 +1,4 @@\n ┊1┊1┊export { default as chat } from './chat.fragment'\n ┊2┊2┊export { default as fullChat } from './fullChat.fragment'\n ┊3┊3┊export { default as message } from './message.fragment'\n+┊ ┊4┊export { default as user } from './user.fragment'\n```\n\n##### Added src&#x2F;graphql&#x2F;fragments&#x2F;user.fragment.ts\n```diff\n@@ -0,0 +1,9 @@\n+┊ ┊1┊import gql from 'graphql-tag'\n+┊ ┊2┊\n+┊ ┊3┊export default gql`\n+┊ ┊4┊  fragment User on User {\n+┊ ┊5┊    id\n+┊ ┊6┊    name\n+┊ ┊7┊    picture\n+┊ ┊8┊  }\n+┊ ┊9┊`\n```\n\n[}]: #\n\nAnd then we will implement the `UsersList` component which is going to use the `users` query with the `User` fragment:\n\n[{]: <helper> (diffStep 12.1 files=\"UsersList\" module=\"client\")\n\n#### [Step 12.1: Add basic ChatCreationScreen](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/2f2f2ed)\n\n##### Added src&#x2F;components&#x2F;UsersList.test.tsx\n```diff\n@@ -0,0 +1,43 @@\n+┊  ┊ 1┊import React from 'react'\n+┊  ┊ 2┊import { ApolloProvider } from 'react-apollo-hooks'\n+┊  ┊ 3┊import { cleanup, render, waitForDomChange } from 'react-testing-library'\n+┊  ┊ 4┊import { mockApolloClient } from '../test-helpers'\n+┊  ┊ 5┊import UsersList, { UsersListQuery } from './UsersList'\n+┊  ┊ 6┊import * as queries from '../graphql/queries'\n+┊  ┊ 7┊\n+┊  ┊ 8┊describe('UsersList', () => {\n+┊  ┊ 9┊  afterEach(cleanup)\n+┊  ┊10┊\n+┊  ┊11┊  it('renders fetched users data', async () => {\n+┊  ┊12┊    const client = mockApolloClient([\n+┊  ┊13┊      {\n+┊  ┊14┊        request: { query: UsersListQuery },\n+┊  ┊15┊        result: {\n+┊  ┊16┊          data: {\n+┊  ┊17┊            users: [\n+┊  ┊18┊              {\n+┊  ┊19┊                __typename: 'User',\n+┊  ┊20┊                id: 1,\n+┊  ┊21┊                name: 'Charles Dickhead',\n+┊  ┊22┊                picture: 'https://localhost:4000/dick.jpg',\n+┊  ┊23┊              },\n+┊  ┊24┊            ],\n+┊  ┊25┊          },\n+┊  ┊26┊        },\n+┊  ┊27┊      },\n+┊  ┊28┊    ])\n+┊  ┊29┊\n+┊  ┊30┊    {\n+┊  ┊31┊      const { container, getByTestId } = render(\n+┊  ┊32┊        <ApolloProvider client={client}>\n+┊  ┊33┊          <UsersList />\n+┊  ┊34┊        </ApolloProvider>\n+┊  ┊35┊      )\n+┊  ┊36┊\n+┊  ┊37┊      await waitForDomChange({ container })\n+┊  ┊38┊\n+┊  ┊39┊      expect(getByTestId('name')).toHaveTextContent('Charles Dickhead')\n+┊  ┊40┊      expect(getByTestId('picture')).toHaveAttribute('src', 'https://localhost:4000/dick.jpg')\n+┊  ┊41┊    }\n+┊  ┊42┊  })\n+┊  ┊43┊})\n```\n\n##### Added src&#x2F;components&#x2F;UsersList.tsx\n```diff\n@@ -0,0 +1,61 @@\n+┊  ┊ 1┊import MaterialList from '@material-ui/core/List'\n+┊  ┊ 2┊import MaterialItem from '@material-ui/core/ListItem'\n+┊  ┊ 3┊import CheckCircle from '@material-ui/icons/CheckCircle'\n+┊  ┊ 4┊import gql from 'graphql-tag'\n+┊  ┊ 5┊import * as React from 'react'\n+┊  ┊ 6┊import { useCallback, useState } from 'react'\n+┊  ┊ 7┊import styled from 'styled-components'\n+┊  ┊ 8┊import * as fragments from '../graphql/fragments'\n+┊  ┊ 9┊import { useUsersListQuery, User } from '../graphql/types'\n+┊  ┊10┊\n+┊  ┊11┊const ActualList = styled(MaterialList) `\n+┊  ┊12┊  padding: 0;\n+┊  ┊13┊`\n+┊  ┊14┊\n+┊  ┊15┊const UserItem = styled(MaterialItem) `\n+┊  ┊16┊  position: relative;\n+┊  ┊17┊  padding: 7.5px 15px;\n+┊  ┊18┊  display: flex;\n+┊  ┊19┊  cursor: pinter;\n+┊  ┊20┊`\n+┊  ┊21┊\n+┊  ┊22┊const ProfilePicture = styled.img `\n+┊  ┊23┊  height: 50px;\n+┊  ┊24┊  width: 50px;\n+┊  ┊25┊  object-fit: cover;\n+┊  ┊26┊  border-radius: 50%;\n+┊  ┊27┊`\n+┊  ┊28┊\n+┊  ┊29┊const Name = styled.div `\n+┊  ┊30┊  padding-left: 15px;\n+┊  ┊31┊  font-weight: bold;\n+┊  ┊32┊`\n+┊  ┊33┊\n+┊  ┊34┊export const UsersListQuery = gql`\n+┊  ┊35┊  query UsersList {\n+┊  ┊36┊    users {\n+┊  ┊37┊      ...User\n+┊  ┊38┊    }\n+┊  ┊39┊  }\n+┊  ┊40┊  ${fragments.user}\n+┊  ┊41┊`\n+┊  ┊42┊\n+┊  ┊43┊const UsersList = () => {\n+┊  ┊44┊  const { data: { users }, loading: loadingUsers } = useUsersListQuery()\n+┊  ┊45┊\n+┊  ┊46┊  return (\n+┊  ┊47┊    <ActualList>\n+┊  ┊48┊      {!loadingUsers && users.map(user => (\n+┊  ┊49┊        <UserItem\n+┊  ┊50┊          key={user.id}\n+┊  ┊51┊          button\n+┊  ┊52┊        >\n+┊  ┊53┊          <ProfilePicture data-testid=\"picture\" src={user.picture} />\n+┊  ┊54┊          <Name data-testid=\"name\">{user.name}</Name>\n+┊  ┊55┊        </UserItem>\n+┊  ┊56┊      ))}\n+┊  ┊57┊    </ActualList>\n+┊  ┊58┊  )\n+┊  ┊59┊}\n+┊  ┊60┊\n+┊  ┊61┊export default UsersList\n```\n\n[}]: #\n\nThe list is likely to change when a new user signs-up. We will implement a subscription and live-update the list further this tutorial when we go through authentication. Now we will implement a new screen component called `ChatCreationScreen`. The screen will simply render the `UsersList` along with a navigation bar:\n\n[{]: <helper> (diffStep 12.1 files=\"ChatCreationScreen\" module=\"client\")\n\n#### [Step 12.1: Add basic ChatCreationScreen](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/2f2f2ed)\n\n##### Added src&#x2F;components&#x2F;ChatCreationScreen&#x2F;ChatCreationNavbar.test.tsx\n```diff\n@@ -0,0 +1,28 @@\n+┊  ┊ 1┊import { createMemoryHistory } from 'history'\n+┊  ┊ 2┊import React from 'react'\n+┊  ┊ 3┊import { cleanup, render, fireEvent, wait } from 'react-testing-library'\n+┊  ┊ 4┊import ChatCreationNavbar from './ChatCreationNavbar'\n+┊  ┊ 5┊\n+┊  ┊ 6┊describe('ChatCreationNavbar', () => {\n+┊  ┊ 7┊  afterEach(cleanup)\n+┊  ┊ 8┊\n+┊  ┊ 9┊  it('goes back on arrow click', async () => {\n+┊  ┊10┊    const history = createMemoryHistory()\n+┊  ┊11┊\n+┊  ┊12┊    history.push('/new-chat')\n+┊  ┊13┊\n+┊  ┊14┊    await wait(() =>\n+┊  ┊15┊      expect(history.location.pathname).toEqual('/new-chat')\n+┊  ┊16┊    )\n+┊  ┊17┊\n+┊  ┊18┊    {\n+┊  ┊19┊      const { container, getByTestId } = render(<ChatCreationNavbar history={history} />)\n+┊  ┊20┊\n+┊  ┊21┊      fireEvent.click(getByTestId('back-button'))\n+┊  ┊22┊\n+┊  ┊23┊      await wait(() =>\n+┊  ┊24┊        expect(history.location.pathname).toEqual('/chats')\n+┊  ┊25┊      )\n+┊  ┊26┊    }\n+┊  ┊27┊  })\n+┊  ┊28┊})\n```\n\n##### Added src&#x2F;components&#x2F;ChatCreationScreen&#x2F;ChatCreationNavbar.tsx\n```diff\n@@ -0,0 +1,41 @@\n+┊  ┊ 1┊import ArrowBackIcon from '@material-ui/icons/ArrowBack'\n+┊  ┊ 2┊import { Toolbar, Button } from '@material-ui/core'\n+┊  ┊ 3┊import * as React from 'react'\n+┊  ┊ 4┊import { useCallback } from 'react'\n+┊  ┊ 5┊import styled from 'styled-components'\n+┊  ┊ 6┊\n+┊  ┊ 7┊const Container = styled(Toolbar) `\n+┊  ┊ 8┊  display: flex;\n+┊  ┊ 9┊  background-color: var(--primary-bg);\n+┊  ┊10┊  color: var(--primary-text);\n+┊  ┊11┊  font-size: 20px;\n+┊  ┊12┊  line-height: 40px;\n+┊  ┊13┊`\n+┊  ┊14┊\n+┊  ┊15┊const BackButton = styled(Button) `\n+┊  ┊16┊  svg {\n+┊  ┊17┊    color: var(--primary-text);\n+┊  ┊18┊  }\n+┊  ┊19┊`\n+┊  ┊20┊\n+┊  ┊21┊const Title = styled.div `\n+┊  ┊22┊  flex: 1;\n+┊  ┊23┊`\n+┊  ┊24┊\n+┊  ┊25┊const ChatCreationNavbar = ({ history }) => {\n+┊  ┊26┊  const navBack = useCallback(() => {\n+┊  ┊27┊    history.replace('/chats')\n+┊  ┊28┊  }, [true])\n+┊  ┊29┊\n+┊  ┊30┊  return (\n+┊  ┊31┊    <Container>\n+┊  ┊32┊      <BackButton data-testid=\"back-button\" onClick={navBack}>\n+┊  ┊33┊        <ArrowBackIcon />\n+┊  ┊34┊      </BackButton>\n+┊  ┊35┊      <Title>Create Chat</Title>\n+┊  ┊36┊    </Container>\n+┊  ┊37┊  )\n+┊  ┊38┊}\n+┊  ┊39┊\n+┊  ┊40┊\n+┊  ┊41┊export default ChatCreationNavbar\n```\n\n##### Added src&#x2F;components&#x2F;ChatCreationScreen&#x2F;index.tsx\n```diff\n@@ -0,0 +1,22 @@\n+┊  ┊ 1┊import gql from 'graphql-tag'\n+┊  ┊ 2┊import * as React from 'react'\n+┊  ┊ 3┊import styled from 'styled-components'\n+┊  ┊ 4┊import * as fragments from '../../graphql/fragments'\n+┊  ┊ 5┊import UsersList from '../UsersList'\n+┊  ┊ 6┊import ChatCreationNavbar from './ChatCreationNavbar'\n+┊  ┊ 7┊\n+┊  ┊ 8┊const Container = styled.div `\n+┊  ┊ 9┊  height: calc(100% - 56px);\n+┊  ┊10┊  overflow-y: overlay;\n+┊  ┊11┊`\n+┊  ┊12┊\n+┊  ┊13┊const StyledUsersList = styled(UsersList) `\n+┊  ┊14┊  height: calc(100% - 56px);\n+┊  ┊15┊`\n+┊  ┊16┊\n+┊  ┊17┊export default ({ history }) => (\n+┊  ┊18┊  <div>\n+┊  ┊19┊    <ChatCreationNavbar history={history} />\n+┊  ┊20┊    <UsersList />\n+┊  ┊21┊  </div>\n+┊  ┊22┊)\n```\n\n[}]: #\n\nThe screen will be available under the route `/new-chat`. The new route will be restricted, since only authenticated users should be able to access it:\n\n[{]: <helper> (diffStep 12.1 files=\"App\" module=\"client\")\n\n#### [Step 12.1: Add basic ChatCreationScreen](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/2f2f2ed)\n\n##### Changed src&#x2F;App.jsx\n```diff\n@@ -3,6 +3,7 @@\n ┊3┊3┊import AuthScreen from './components/AuthScreen'\n ┊4┊4┊import ChatRoomScreen from './components/ChatRoomScreen'\n ┊5┊5┊import ChatsListScreen from './components/ChatsListScreen'\n+┊ ┊6┊import ChatCreationScreen from './components/ChatCreationScreen'\n ┊6┊7┊import AnimatedSwitch from './components/AnimatedSwitch'\n ┊7┊8┊import { withAuth } from './services/auth.service'\n ┊8┊9┊\n```\n```diff\n@@ -12,6 +13,7 @@\n ┊12┊13┊      <Route exact path=\"/sign-in\" component={AuthScreen} />\n ┊13┊14┊      <Route exact path=\"/chats\" component={withAuth(ChatsListScreen)} />\n ┊14┊15┊      <Route exact path=\"/chats/:chatId\" component={withAuth(ChatRoomScreen)} />\n+┊  ┊16┊      <Route exact path=\"/new-chat\" component={withAuth(ChatCreationScreen)} />\n ┊15┊17┊    </AnimatedSwitch>\n ┊16┊18┊    <Route exact path=\"/\" render={redirectToChats} />\n ┊17┊19┊  </BrowserRouter>\n```\n\n[}]: #\n\nthe `/new-chat` route will be accessible directly from the main `ChatsListScreen`. We will implement a navigation button which is gonna have a fixed position at the bottom right corner of the screen:\n\n[{]: <helper> (diffStep 12.1 files=\"AddChatButton\" module=\"client\")\n\n#### [Step 12.1: Add basic ChatCreationScreen](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/2f2f2ed)\n\n##### Added src&#x2F;components&#x2F;ChatsListScreen&#x2F;AddChatButton.test.tsx\n```diff\n@@ -0,0 +1,22 @@\n+┊  ┊ 1┊import { createMemoryHistory } from 'history'\n+┊  ┊ 2┊import React from 'react'\n+┊  ┊ 3┊import { cleanup, render, fireEvent, wait } from 'react-testing-library'\n+┊  ┊ 4┊import AddChatButton from './AddChatButton'\n+┊  ┊ 5┊\n+┊  ┊ 6┊describe('AddChatButton', () => {\n+┊  ┊ 7┊  afterEach(cleanup)\n+┊  ┊ 8┊\n+┊  ┊ 9┊  it('goes back on arrow click', async () => {\n+┊  ┊10┊    const history = createMemoryHistory()\n+┊  ┊11┊\n+┊  ┊12┊    {\n+┊  ┊13┊      const { container, getByTestId } = render(<AddChatButton history={history} />)\n+┊  ┊14┊\n+┊  ┊15┊      fireEvent.click(getByTestId('new-chat-button'))\n+┊  ┊16┊\n+┊  ┊17┊      await wait(() =>\n+┊  ┊18┊        expect(history.location.pathname).toEqual('/new-chat')\n+┊  ┊19┊      )\n+┊  ┊20┊    }\n+┊  ┊21┊  })\n+┊  ┊22┊})\n```\n\n##### Added src&#x2F;components&#x2F;ChatsListScreen&#x2F;AddChatButton.tsx\n```diff\n@@ -0,0 +1,38 @@\n+┊  ┊ 1┊import Button from '@material-ui/core/Button'\n+┊  ┊ 2┊import ChatIcon from '@material-ui/icons/Chat'\n+┊  ┊ 3┊import * as React from 'react'\n+┊  ┊ 4┊import styled from 'styled-components'\n+┊  ┊ 5┊\n+┊  ┊ 6┊const Container = styled.div `\n+┊  ┊ 7┊  position: fixed;\n+┊  ┊ 8┊  right: 10px;\n+┊  ┊ 9┊  bottom: 10px;\n+┊  ┊10┊\n+┊  ┊11┊  button {\n+┊  ┊12┊    min-width: 50px;\n+┊  ┊13┊    width: 50px;\n+┊  ┊14┊    height: 50px;\n+┊  ┊15┊    border-radius: 999px;\n+┊  ┊16┊    background-color: var(--secondary-bg);\n+┊  ┊17┊    color: white;\n+┊  ┊18┊  }\n+┊  ┊19┊`\n+┊  ┊20┊\n+┊  ┊21┊export default ({ history }) => {\n+┊  ┊22┊  const onClick = () => {\n+┊  ┊23┊    history.push('/new-chat')\n+┊  ┊24┊  }\n+┊  ┊25┊\n+┊  ┊26┊  return (\n+┊  ┊27┊    <Container>\n+┊  ┊28┊      <Button\n+┊  ┊29┊        data-testid=\"new-chat-button\"\n+┊  ┊30┊        variant=\"contained\"\n+┊  ┊31┊        color=\"secondary\"\n+┊  ┊32┊        onClick={onClick}\n+┊  ┊33┊      >\n+┊  ┊34┊        <ChatIcon />\n+┊  ┊35┊      </Button>\n+┊  ┊36┊    </Container>\n+┊  ┊37┊  )\n+┊  ┊38┊}🚫↵\n```\n\n[}]: #\n\nAnd then we will render it in the `ChatsListScreen`:\n\n[{]: <helper> (diffStep 12.1 files=\"ChatsListScreen/index\" module=\"client\")\n\n#### [Step 12.1: Add basic ChatCreationScreen](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/2f2f2ed)\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;index.tsx\n```diff\n@@ -1,5 +1,6 @@\n ┊1┊1┊import * as React from 'react'\n ┊2┊2┊import styled from 'styled-components'\n+┊ ┊3┊import AddChatButton from './AddChatButton'\n ┊3┊4┊import ChatsNavbar from './ChatsNavbar'\n ┊4┊5┊import ChatsList from './ChatsList'\n ┊5┊6┊\n```\n```diff\n@@ -11,6 +12,7 @@\n ┊11┊12┊  <Container>\n ┊12┊13┊    <ChatsNavbar history={history} />\n ┊13┊14┊    <ChatsList history={history} />\n+┊  ┊15┊    <AddChatButton history={history} />\n ┊14┊16┊  </Container>\n ┊15┊17┊)\n ┊16┊18┊\n```\n\n[}]: #\n\nFor now we can only observe the users list. Our goal now is to be able to start chatting with a user once it has been clicked. First we will need to add a new mutation called `addChat` which will create a new chat document and add it to the chats collection. If the chat already exists we will return the existing instance. This behavior will help us navigate to the desired `ChatRoomScreen`, whether it exists or not:\n\n[{]: <helper> (diffStep 9.2 module=\"server\")\n\n#### [Step 9.2: Add Mutation.addChat](https://github.com/Urigo/WhatsApp-Clone-Server/commit/275dbe0)\n\n##### Changed schema&#x2F;resolvers.ts\n```diff\n@@ -1,6 +1,6 @@\n ┊1┊1┊import { withFilter } from 'apollo-server-express'\n ┊2┊2┊import { GraphQLDateTime } from 'graphql-iso-date'\n-┊3┊ ┊import { User, Message, chats, messages, users } from '../db'\n+┊ ┊3┊import { User, Message, Chat, chats, messages, users } from '../db'\n ┊4┊4┊import { Resolvers } from '../types/graphql'\n ┊5┊5┊\n ┊6┊6┊const resolvers: Resolvers = {\n```\n```diff\n@@ -121,7 +121,31 @@\n ┊121┊121┊      })\n ┊122┊122┊\n ┊123┊123┊      return message\n-┊124┊   ┊    }\n+┊   ┊124┊    },\n+┊   ┊125┊\n+┊   ┊126┊    addChat(root, { recipientId }, { currentUser }) {\n+┊   ┊127┊      if (!currentUser) return null\n+┊   ┊128┊      if (!users.some(u => u.id === recipientId)) return null\n+┊   ┊129┊\n+┊   ┊130┊      let chat = chats.find(c =>\n+┊   ┊131┊        c.participants.includes(currentUser.id) &&\n+┊   ┊132┊        c.participants.includes(recipientId)\n+┊   ┊133┊      )\n+┊   ┊134┊\n+┊   ┊135┊      if (chat) return chat\n+┊   ┊136┊\n+┊   ┊137┊      const chatsIds = chats.map(c => Number(c.id))\n+┊   ┊138┊\n+┊   ┊139┊      chat = {\n+┊   ┊140┊        id: String(Math.max(...chatsIds) + 1),\n+┊   ┊141┊        participants: [currentUser.id, recipientId],\n+┊   ┊142┊        messages: [],\n+┊   ┊143┊      }\n+┊   ┊144┊\n+┊   ┊145┊      chats.push(chat)\n+┊   ┊146┊\n+┊   ┊147┊      return chat\n+┊   ┊148┊    },\n ┊125┊149┊  },\n ┊126┊150┊\n ┊127┊151┊  Subscription: {\n```\n\n##### Changed schema&#x2F;typeDefs.graphql\n```diff\n@@ -33,6 +33,7 @@\n ┊33┊33┊\n ┊34┊34┊type Mutation {\n ┊35┊35┊  addMessage(chatId: ID!, content: String!): Message\n+┊  ┊36┊  addChat(recipientId: ID!): Chat\n ┊36┊37┊}\n ┊37┊38┊\n ┊38┊39┊type Subscription {\n```\n\n##### Added tests&#x2F;mutations&#x2F;__snapshots__&#x2F;addChat.test.ts.snap\n```diff\n@@ -0,0 +1,52 @@\n+┊  ┊ 1┊// Jest Snapshot v1, https://goo.gl/fbAQLP\n+┊  ┊ 2┊\n+┊  ┊ 3┊exports[`Mutation.addChat creates a new chat between current user and specified recipient 1`] = `\n+┊  ┊ 4┊Object {\n+┊  ┊ 5┊  \"addChat\": Object {\n+┊  ┊ 6┊    \"id\": \"5\",\n+┊  ┊ 7┊    \"name\": \"Bryan Wallace\",\n+┊  ┊ 8┊    \"participants\": Array [\n+┊  ┊ 9┊      Object {\n+┊  ┊10┊        \"id\": \"2\",\n+┊  ┊11┊      },\n+┊  ┊12┊      Object {\n+┊  ┊13┊        \"id\": \"3\",\n+┊  ┊14┊      },\n+┊  ┊15┊    ],\n+┊  ┊16┊  },\n+┊  ┊17┊}\n+┊  ┊18┊`;\n+┊  ┊19┊\n+┊  ┊20┊exports[`Mutation.addChat creates a new chat between current user and specified recipient 2`] = `\n+┊  ┊21┊Object {\n+┊  ┊22┊  \"chat\": Object {\n+┊  ┊23┊    \"id\": \"5\",\n+┊  ┊24┊    \"name\": \"Bryan Wallace\",\n+┊  ┊25┊    \"participants\": Array [\n+┊  ┊26┊      Object {\n+┊  ┊27┊        \"id\": \"2\",\n+┊  ┊28┊      },\n+┊  ┊29┊      Object {\n+┊  ┊30┊        \"id\": \"3\",\n+┊  ┊31┊      },\n+┊  ┊32┊    ],\n+┊  ┊33┊  },\n+┊  ┊34┊}\n+┊  ┊35┊`;\n+┊  ┊36┊\n+┊  ┊37┊exports[`Mutation.addChat returns the existing chat if so 1`] = `\n+┊  ┊38┊Object {\n+┊  ┊39┊  \"addChat\": Object {\n+┊  ┊40┊    \"id\": \"1\",\n+┊  ┊41┊    \"name\": \"Ethan Gonzalez\",\n+┊  ┊42┊    \"participants\": Array [\n+┊  ┊43┊      Object {\n+┊  ┊44┊        \"id\": \"1\",\n+┊  ┊45┊      },\n+┊  ┊46┊      Object {\n+┊  ┊47┊        \"id\": \"2\",\n+┊  ┊48┊      },\n+┊  ┊49┊    ],\n+┊  ┊50┊  },\n+┊  ┊51┊}\n+┊  ┊52┊`;\n```\n\n##### Added tests&#x2F;mutations&#x2F;addChat.test.ts\n```diff\n@@ -0,0 +1,89 @@\n+┊  ┊ 1┊import { createTestClient } from 'apollo-server-testing'\n+┊  ┊ 2┊import { ApolloServer, PubSub, gql } from 'apollo-server-express'\n+┊  ┊ 3┊import schema from '../../schema'\n+┊  ┊ 4┊import { resetDb, users } from '../../db'\n+┊  ┊ 5┊\n+┊  ┊ 6┊describe('Mutation.addChat', () => {\n+┊  ┊ 7┊  beforeEach(resetDb)\n+┊  ┊ 8┊\n+┊  ┊ 9┊  it('creates a new chat between current user and specified recipient', async () => {\n+┊  ┊10┊    const server = new ApolloServer({\n+┊  ┊11┊      schema,\n+┊  ┊12┊      context: () => ({\n+┊  ┊13┊        pubsub: new PubSub(),\n+┊  ┊14┊        currentUser: users[1],\n+┊  ┊15┊      }),\n+┊  ┊16┊    })\n+┊  ┊17┊\n+┊  ┊18┊    const { query, mutate } = createTestClient(server)\n+┊  ┊19┊\n+┊  ┊20┊    const addChatRes = await mutate({\n+┊  ┊21┊      variables: { recipientId: '3' },\n+┊  ┊22┊      mutation: gql `\n+┊  ┊23┊        mutation AddChat($recipientId: ID!) {\n+┊  ┊24┊          addChat(recipientId: $recipientId) {\n+┊  ┊25┊            id\n+┊  ┊26┊            name\n+┊  ┊27┊            participants {\n+┊  ┊28┊              id\n+┊  ┊29┊            }\n+┊  ┊30┊          }\n+┊  ┊31┊        }\n+┊  ┊32┊      `,\n+┊  ┊33┊    })\n+┊  ┊34┊\n+┊  ┊35┊    expect(addChatRes.data).toBeDefined()\n+┊  ┊36┊    expect(addChatRes.errors).toBeUndefined()\n+┊  ┊37┊    expect(addChatRes.data).toMatchSnapshot()\n+┊  ┊38┊\n+┊  ┊39┊    const getChatRes = await query({\n+┊  ┊40┊      variables: { chatId: '5' },\n+┊  ┊41┊      query: gql `\n+┊  ┊42┊        query GetChat($chatId: ID!) {\n+┊  ┊43┊          chat(chatId: $chatId) {\n+┊  ┊44┊            id\n+┊  ┊45┊            name\n+┊  ┊46┊            participants {\n+┊  ┊47┊              id\n+┊  ┊48┊            }\n+┊  ┊49┊          }\n+┊  ┊50┊        }\n+┊  ┊51┊      `,\n+┊  ┊52┊    })\n+┊  ┊53┊\n+┊  ┊54┊    expect(getChatRes.data).toBeDefined()\n+┊  ┊55┊    expect(getChatRes.errors).toBeUndefined()\n+┊  ┊56┊    expect(getChatRes.data).toMatchSnapshot()\n+┊  ┊57┊  })\n+┊  ┊58┊\n+┊  ┊59┊  it('returns the existing chat if so', async () => {\n+┊  ┊60┊    const server = new ApolloServer({\n+┊  ┊61┊      schema,\n+┊  ┊62┊      context: () => ({\n+┊  ┊63┊        pubsub: new PubSub(),\n+┊  ┊64┊        currentUser: users[0],\n+┊  ┊65┊      }),\n+┊  ┊66┊    })\n+┊  ┊67┊\n+┊  ┊68┊    const { query, mutate } = createTestClient(server)\n+┊  ┊69┊\n+┊  ┊70┊    const addChatRes = await mutate({\n+┊  ┊71┊      variables: { recipientId: '2' },\n+┊  ┊72┊      mutation: gql `\n+┊  ┊73┊        mutation AddChat($recipientId: ID!) {\n+┊  ┊74┊          addChat(recipientId: $recipientId) {\n+┊  ┊75┊            id\n+┊  ┊76┊            name\n+┊  ┊77┊            participants {\n+┊  ┊78┊              id\n+┊  ┊79┊            }\n+┊  ┊80┊          }\n+┊  ┊81┊        }\n+┊  ┊82┊      `,\n+┊  ┊83┊    })\n+┊  ┊84┊\n+┊  ┊85┊    expect(addChatRes.data).toBeDefined()\n+┊  ┊86┊    expect(addChatRes.errors).toBeUndefined()\n+┊  ┊87┊    expect(addChatRes.data).toMatchSnapshot()\n+┊  ┊88┊  })\n+┊  ┊89┊})\n```\n\n[}]: #\n\nTo use the new mutation, we will define a new callback called `onUserPick` in the `UsersList` so it can be used from the `ChatCreationScreen`:\n\n[{]: <helper> (diffStep 12.2 files=\"UsersList\" module=\"client\")\n\n#### [Step 12.2: Create chat on user pick](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/7f16771)\n\n##### Changed src&#x2F;components&#x2F;UsersList.test.tsx\n```diff\n@@ -1,6 +1,6 @@\n ┊1┊1┊import React from 'react'\n ┊2┊2┊import { ApolloProvider } from 'react-apollo-hooks'\n-┊3┊ ┊import { cleanup, render, waitForDomChange } from 'react-testing-library'\n+┊ ┊3┊import { cleanup, render, fireEvent, wait, waitForDomChange } from 'react-testing-library'\n ┊4┊4┊import { mockApolloClient } from '../test-helpers'\n ┊5┊5┊import UsersList, { UsersListQuery } from './UsersList'\n ┊6┊6┊import * as queries from '../graphql/queries'\n```\n```diff\n@@ -40,4 +40,45 @@\n ┊40┊40┊      expect(getByTestId('picture')).toHaveAttribute('src', 'https://localhost:4000/dick.jpg')\n ┊41┊41┊    }\n ┊42┊42┊  })\n+┊  ┊43┊\n+┊  ┊44┊  it('triggers onUserPick() callback on user-item click', async () => {\n+┊  ┊45┊    const client = mockApolloClient([\n+┊  ┊46┊      {\n+┊  ┊47┊        request: { query: UsersListQuery },\n+┊  ┊48┊        result: {\n+┊  ┊49┊          data: {\n+┊  ┊50┊            users: [\n+┊  ┊51┊              {\n+┊  ┊52┊                __typename: 'User',\n+┊  ┊53┊                id: 1,\n+┊  ┊54┊                name: 'Charles Dickhead',\n+┊  ┊55┊                picture: 'https://localhost:4000/dick.jpg',\n+┊  ┊56┊              },\n+┊  ┊57┊            ],\n+┊  ┊58┊          },\n+┊  ┊59┊        },\n+┊  ┊60┊      },\n+┊  ┊61┊    ])\n+┊  ┊62┊\n+┊  ┊63┊    const onUserPick = jest.fn(() => {})\n+┊  ┊64┊\n+┊  ┊65┊    {\n+┊  ┊66┊      const { container, getByTestId } = render(\n+┊  ┊67┊        <ApolloProvider client={client}>\n+┊  ┊68┊          <UsersList onUserPick={onUserPick} />\n+┊  ┊69┊        </ApolloProvider>\n+┊  ┊70┊      )\n+┊  ┊71┊\n+┊  ┊72┊      await waitForDomChange({ container })\n+┊  ┊73┊\n+┊  ┊74┊      fireEvent.click(getByTestId('user'))\n+┊  ┊75┊\n+┊  ┊76┊      await wait(() =>\n+┊  ┊77┊        expect(onUserPick.mock.calls.length).toBe(1)\n+┊  ┊78┊      )\n+┊  ┊79┊\n+┊  ┊80┊      expect(onUserPick.mock.calls[0][0].name).toEqual('Charles Dickhead')\n+┊  ┊81┊      expect(onUserPick.mock.calls[0][0].picture).toEqual('https://localhost:4000/dick.jpg')\n+┊  ┊82┊    }\n+┊  ┊83┊  })\n ┊43┊84┊})\n```\n\n##### Changed src&#x2F;components&#x2F;UsersList.tsx\n```diff\n@@ -40,7 +40,7 @@\n ┊40┊40┊  ${fragments.user}\n ┊41┊41┊`\n ┊42┊42┊\n-┊43┊  ┊const UsersList = () => {\n+┊  ┊43┊const UsersList = ({ onUserPick = (user: User) => {} }) => {\n ┊44┊44┊  const { data: { users }, loading: loadingUsers } = useUsersListQuery()\n ┊45┊45┊\n ┊46┊46┊  return (\n```\n```diff\n@@ -48,6 +48,8 @@\n ┊48┊48┊      {!loadingUsers && users.map(user => (\n ┊49┊49┊        <UserItem\n ┊50┊50┊          key={user.id}\n+┊  ┊51┊          data-testid=\"user\"\n+┊  ┊52┊          onClick={onUserPick.bind(null, user)}\n ┊51┊53┊          button\n ┊52┊54┊        >\n ┊53┊55┊          <ProfilePicture data-testid=\"picture\" src={user.picture} />\n```\n\n[}]: #\n\nIn the `ChatCreationScreen/index.tsx` module, we will define an `AddChat` document with `graphql-tag`. Using the `$ yarn codegen` command we can generate the correlated React mutation hook and use it as the `onUserPick` callback:\n\n[{]: <helper> (diffStep 12.2 files=\"ChatCreationScreen/index\" module=\"client\")\n\n#### [Step 12.2: Create chat on user pick](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/7f16771)\n\n##### Changed src&#x2F;components&#x2F;ChatCreationScreen&#x2F;index.tsx\n```diff\n@@ -1,9 +1,11 @@\n ┊ 1┊ 1┊import gql from 'graphql-tag'\n ┊ 2┊ 2┊import * as React from 'react'\n+┊  ┊ 3┊import { useCallback } from 'react'\n ┊ 3┊ 4┊import styled from 'styled-components'\n ┊ 4┊ 5┊import * as fragments from '../../graphql/fragments'\n ┊ 5┊ 6┊import UsersList from '../UsersList'\n ┊ 6┊ 7┊import ChatCreationNavbar from './ChatCreationNavbar'\n+┊  ┊ 8┊import { useAddChatMutation } from '../../graphql/types'\n ┊ 7┊ 9┊\n ┊ 8┊10┊const Container = styled.div `\n ┊ 9┊11┊  height: calc(100% - 56px);\n```\n```diff\n@@ -14,9 +16,42 @@\n ┊14┊16┊  height: calc(100% - 56px);\n ┊15┊17┊`\n ┊16┊18┊\n-┊17┊  ┊export default ({ history }) => (\n-┊18┊  ┊  <div>\n-┊19┊  ┊    <ChatCreationNavbar history={history} />\n-┊20┊  ┊    <UsersList />\n-┊21┊  ┊  </div>\n-┊22┊  ┊)\n+┊  ┊19┊gql`\n+┊  ┊20┊  mutation AddChat($recipientId: ID!) {\n+┊  ┊21┊    addChat(recipientId: $recipientId) {\n+┊  ┊22┊      ...Chat\n+┊  ┊23┊    }\n+┊  ┊24┊  }\n+┊  ┊25┊  ${fragments.chat}\n+┊  ┊26┊`\n+┊  ┊27┊\n+┊  ┊28┊export default ({ history }) => {\n+┊  ┊29┊  const addChat = useAddChatMutation()\n+┊  ┊30┊\n+┊  ┊31┊  const onUserPick = useCallback((user) => {\n+┊  ┊32┊    addChat({\n+┊  ┊33┊      optimisticResponse: {\n+┊  ┊34┊        __typename: 'Mutation',\n+┊  ┊35┊        addChat: {\n+┊  ┊36┊          __typename: 'Chat',\n+┊  ┊37┊          id: Math.random().toString(36).substr(2, 9),\n+┊  ┊38┊          name: user.name,\n+┊  ┊39┊          picture: user.picture,\n+┊  ┊40┊          lastMessage: null,\n+┊  ┊41┊        },\n+┊  ┊42┊      },\n+┊  ┊43┊      variables: {\n+┊  ┊44┊        recipientId: user.id,\n+┊  ┊45┊      },\n+┊  ┊46┊    }).then(({ data: { addChat } }) => {\n+┊  ┊47┊      history.push(`/chats/${addChat.id}`)\n+┊  ┊48┊    })\n+┊  ┊49┊  }, [addChat])\n+┊  ┊50┊\n+┊  ┊51┊  return (\n+┊  ┊52┊    <div>\n+┊  ┊53┊      <ChatCreationNavbar history={history} />\n+┊  ┊54┊      <UsersList onUserPick={onUserPick} />\n+┊  ┊55┊    </div>\n+┊  ┊56┊  )\n+┊  ┊57┊}\n```\n\n[}]: #\n\nChats can now be created, you can test out the function by signing in with different users. However, the chats list in the `ChatsListScreen` will not be updated unless we refresh the page manually. In the server project, we will define a new subscription called `chatAdded`. The subscription should be broadcasted to the current user only if he is a participant of the published chat:\n\n[{]: <helper> (diffStep 9.3 module=\"server\")\n\n#### [Step 9.3: Add Subscription.chatAdded](https://github.com/Urigo/WhatsApp-Clone-Server/commit/6e8c94f)\n\n##### Changed schema&#x2F;resolvers.ts\n```diff\n@@ -123,7 +123,7 @@\n ┊123┊123┊      return message\n ┊124┊124┊    },\n ┊125┊125┊\n-┊126┊   ┊    addChat(root, { recipientId }, { currentUser }) {\n+┊   ┊126┊    addChat(root, { recipientId }, { currentUser, pubsub }) {\n ┊127┊127┊      if (!currentUser) return null\n ┊128┊128┊      if (!users.some(u => u.id === recipientId)) return null\n ┊129┊129┊\n```\n```diff\n@@ -144,6 +144,10 @@\n ┊144┊144┊\n ┊145┊145┊      chats.push(chat)\n ┊146┊146┊\n+┊   ┊147┊      pubsub.publish('chatAdded', {\n+┊   ┊148┊        chatAdded: chat\n+┊   ┊149┊      })\n+┊   ┊150┊\n ┊147┊151┊      return chat\n ┊148┊152┊    },\n ┊149┊153┊  },\n```\n```diff\n@@ -161,6 +165,17 @@\n ┊161┊165┊          ].includes(currentUser.id)\n ┊162┊166┊        },\n ┊163┊167┊      )\n+┊   ┊168┊    },\n+┊   ┊169┊\n+┊   ┊170┊    chatAdded: {\n+┊   ┊171┊      subscribe: withFilter(\n+┊   ┊172┊        (root, args, { pubsub }) => pubsub.asyncIterator('chatAdded'),\n+┊   ┊173┊        ({ chatAdded }: { chatAdded: Chat }, args, { currentUser }) => {\n+┊   ┊174┊          if (!currentUser) return false\n+┊   ┊175┊\n+┊   ┊176┊          return chatAdded.participants.some(p => p === currentUser.id)\n+┊   ┊177┊        },\n+┊   ┊178┊      )\n ┊164┊179┊    }\n ┊165┊180┊  }\n ┊166┊181┊}\n```\n\n##### Changed schema&#x2F;typeDefs.graphql\n```diff\n@@ -38,4 +38,5 @@\n ┊38┊38┊\n ┊39┊39┊type Subscription {\n ┊40┊40┊  messageAdded: Message!\n+┊  ┊41┊  chatAdded: Chat!\n ┊41┊42┊}\n```\n\n[}]: #\n\nNow we will listen to the new subscription in the client and update the cache. First we will define the subscription document:\n\n[{]: <helper> (diffStep 12.3 files=\"graphql/subscriptions\" module=\"client\")\n\n#### [Step 12.3: Write chat on chatAdded](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/2234872)\n\n##### Added src&#x2F;graphql&#x2F;subscriptions&#x2F;chatAdded.subscription.ts\n```diff\n@@ -0,0 +1,11 @@\n+┊  ┊ 1┊import gql from 'graphql-tag'\n+┊  ┊ 2┊import * as fragments from '../fragments'\n+┊  ┊ 3┊\n+┊  ┊ 4┊export default gql `\n+┊  ┊ 5┊  subscription ChatAdded {\n+┊  ┊ 6┊    chatAdded {\n+┊  ┊ 7┊      ...Chat\n+┊  ┊ 8┊    }\n+┊  ┊ 9┊  }\n+┊  ┊10┊  ${fragments.chat}\n+┊  ┊11┊`\n```\n\n##### Changed src&#x2F;graphql&#x2F;subscriptions&#x2F;index.ts\n```diff\n@@ -1 +1,2 @@\n ┊1┊1┊export { default as messageAdded } from './messageAdded.subscription'\n+┊ ┊2┊export { default as chatAdded } from './chatAdded.subscription'\n```\n\n[}]: #\n\nAnd then we will update the `cache.service` to write the broadcasted chat to the store. We will write the fragment, and we will also update the `chats` query to contain the new chat. We will also check if the chat already exists before we update the query, because remember, the `addChat` mutation will return the chat even if it already exists, not if it was created only:\n\n[{]: <helper> (diffStep 12.3 module=\"client\")\n\n#### [Step 12.3: Write chat on chatAdded](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/2234872)\n\n##### Changed src&#x2F;components&#x2F;ChatCreationScreen&#x2F;index.tsx\n```diff\n@@ -6,6 +6,7 @@\n ┊ 6┊ 6┊import UsersList from '../UsersList'\n ┊ 7┊ 7┊import ChatCreationNavbar from './ChatCreationNavbar'\n ┊ 8┊ 8┊import { useAddChatMutation } from '../../graphql/types'\n+┊  ┊ 9┊import { writeChat } from '../../services/cache.service'\n ┊ 9┊10┊\n ┊10┊11┊const Container = styled.div `\n ┊11┊12┊  height: calc(100% - 56px);\n```\n```diff\n@@ -26,7 +27,11 @@\n ┊26┊27┊`\n ┊27┊28┊\n ┊28┊29┊export default ({ history }) => {\n-┊29┊  ┊  const addChat = useAddChatMutation()\n+┊  ┊30┊  const addChat = useAddChatMutation({\n+┊  ┊31┊    update: (client, { data: { addChat } }) => {\n+┊  ┊32┊      writeChat(client, addChat)\n+┊  ┊33┊    }\n+┊  ┊34┊  })\n ┊30┊35┊\n ┊31┊36┊  const onUserPick = useCallback((user) => {\n ┊32┊37┊    addChat({\n```\n\n##### Added src&#x2F;graphql&#x2F;subscriptions&#x2F;chatAdded.subscription.ts\n```diff\n@@ -0,0 +1,11 @@\n+┊  ┊ 1┊import gql from 'graphql-tag'\n+┊  ┊ 2┊import * as fragments from '../fragments'\n+┊  ┊ 3┊\n+┊  ┊ 4┊export default gql `\n+┊  ┊ 5┊  subscription ChatAdded {\n+┊  ┊ 6┊    chatAdded {\n+┊  ┊ 7┊      ...Chat\n+┊  ┊ 8┊    }\n+┊  ┊ 9┊  }\n+┊  ┊10┊  ${fragments.chat}\n+┊  ┊11┊`\n```\n\n##### Changed src&#x2F;graphql&#x2F;subscriptions&#x2F;index.ts\n```diff\n@@ -1 +1,2 @@\n ┊1┊1┊export { default as messageAdded } from './messageAdded.subscription'\n+┊ ┊2┊export { default as chatAdded } from './chatAdded.subscription'\n```\n\n##### Changed src&#x2F;services&#x2F;cache.service.ts\n```diff\n@@ -3,7 +3,7 @@\n ┊3┊3┊import { ApolloClient } from 'apollo-client'\n ┊4┊4┊import * as fragments from '../graphql/fragments'\n ┊5┊5┊import * as queries from '../graphql/queries'\n-┊6┊ ┊import { MessageFragment, useMessageAddedSubscription } from '../graphql/types'\n+┊ ┊6┊import { MessageFragment, ChatFragment, useMessageAddedSubscription, useChatAddedSubscription } from '../graphql/types'\n ┊7┊7┊\n ┊8┊8┊type Client = ApolloClient<any> | DataProxy\n ┊9┊9┊\n```\n```diff\n@@ -13,6 +13,12 @@\n ┊13┊13┊      writeMessage(client, messageAdded)\n ┊14┊14┊    }\n ┊15┊15┊  })\n+┊  ┊16┊\n+┊  ┊17┊  useChatAddedSubscription({\n+┊  ┊18┊    onSubscriptionData: ({ client, subscriptionData: { data: { chatAdded } } }) => {\n+┊  ┊19┊      writeChat(client, chatAdded)\n+┊  ┊20┊    }\n+┊  ┊21┊  })\n ┊16┊22┊}\n ┊17┊23┊\n ┊18┊24┊export const writeMessage = (client: Client, message: MessageFragment) => {\n```\n```diff\n@@ -72,3 +78,38 @@\n ┊ 72┊ 78┊    })\n ┊ 73┊ 79┊  }\n ┊ 74┊ 80┊}\n+┊   ┊ 81┊\n+┊   ┊ 82┊export const writeChat = (client: Client, chat: ChatFragment) => {\n+┊   ┊ 83┊  client.writeFragment({\n+┊   ┊ 84┊    id: defaultDataIdFromObject(chat),\n+┊   ┊ 85┊    fragment: fragments.chat,\n+┊   ┊ 86┊    fragmentName: 'Chat',\n+┊   ┊ 87┊    data: chat,\n+┊   ┊ 88┊  })\n+┊   ┊ 89┊\n+┊   ┊ 90┊  rewriteChats:\n+┊   ┊ 91┊  {\n+┊   ┊ 92┊    let data\n+┊   ┊ 93┊    try {\n+┊   ┊ 94┊      data = client.readQuery({\n+┊   ┊ 95┊        query: queries.chats,\n+┊   ┊ 96┊      })\n+┊   ┊ 97┊    } catch (e) {\n+┊   ┊ 98┊      break rewriteChats\n+┊   ┊ 99┊    }\n+┊   ┊100┊\n+┊   ┊101┊    if (!data) break rewriteChats\n+┊   ┊102┊\n+┊   ┊103┊    const chats = data.chats\n+┊   ┊104┊\n+┊   ┊105┊    if (!chats) break rewriteChats\n+┊   ┊106┊    if (chats.some(c => c.id === chat.id)) break rewriteChats\n+┊   ┊107┊\n+┊   ┊108┊    chats.unshift(chat)\n+┊   ┊109┊\n+┊   ┊110┊    client.writeQuery({\n+┊   ┊111┊      query: queries.chats,\n+┊   ┊112┊      data: { chats },\n+┊   ┊113┊    })\n+┊   ┊114┊  }\n+┊   ┊115┊}\n```\n\n[}]: #\n\nNow we can create new chats, and the chats list would be updated, without refreshing the page. You can also test it with 2 separate sessions in the browser and see how each tab/window affects the other. Lastly, we will implement a chat removal function. This is important as we don’t want to garbage our chats collection, sometimes we would like to clean up some of them.\n\nIn the back-end, let’s implement the `removeChat` mutation. The chat can only be removed only if the current user is one of the chat’s participants. The mutation will also remove all the messages which are related to the target chat, since we’re not gonna use them anymore. The chat will be removed for all participants. This is not exactly the behavior of the original Whatsapp, but to keep things simple we will go with that solution:\n\n[{]: <helper> (diffStep 9.4 module=\"server\")\n\n#### [Step 9.4: Add Mutation.removeChat](https://github.com/Urigo/WhatsApp-Clone-Server/commit/7f3bd40)\n\n##### Changed schema&#x2F;resolvers.ts\n```diff\n@@ -150,6 +150,30 @@\n ┊150┊150┊\n ┊151┊151┊      return chat\n ┊152┊152┊    },\n+┊   ┊153┊\n+┊   ┊154┊    removeChat(root, { chatId }, { currentUser }) {\n+┊   ┊155┊      if (!currentUser) return null\n+┊   ┊156┊\n+┊   ┊157┊      const chatIndex = chats.findIndex(c => c.id === chatId)\n+┊   ┊158┊\n+┊   ┊159┊      if (chatIndex === -1) return null\n+┊   ┊160┊\n+┊   ┊161┊      const chat = chats[chatIndex]\n+┊   ┊162┊\n+┊   ┊163┊      if (!chat.participants.some(p => p === currentUser.id)) return null\n+┊   ┊164┊\n+┊   ┊165┊      chat.messages.forEach((chatMessage) => {\n+┊   ┊166┊        const chatMessageIndex = messages.findIndex(m => m.id === chatMessage)\n+┊   ┊167┊\n+┊   ┊168┊        if (chatMessageIndex !== -1) {\n+┊   ┊169┊          messages.splice(chatMessageIndex, 1)\n+┊   ┊170┊        }\n+┊   ┊171┊      })\n+┊   ┊172┊\n+┊   ┊173┊      chats.splice(chatIndex, 1)\n+┊   ┊174┊\n+┊   ┊175┊      return chatId\n+┊   ┊176┊    }\n ┊153┊177┊  },\n ┊154┊178┊\n ┊155┊179┊  Subscription: {\n```\n\n##### Changed schema&#x2F;typeDefs.graphql\n```diff\n@@ -34,6 +34,7 @@\n ┊34┊34┊type Mutation {\n ┊35┊35┊  addMessage(chatId: ID!, content: String!): Message\n ┊36┊36┊  addChat(recipientId: ID!): Chat\n+┊  ┊37┊  removeChat(chatId: ID!): ID\n ┊37┊38┊}\n ┊38┊39┊\n ┊39┊40┊type Subscription {\n```\n\n##### Added tests&#x2F;mutations&#x2F;removeChat.test.ts\n```diff\n@@ -0,0 +1,52 @@\n+┊  ┊ 1┊import { createTestClient } from 'apollo-server-testing'\n+┊  ┊ 2┊import { ApolloServer, PubSub, gql } from 'apollo-server-express'\n+┊  ┊ 3┊import schema from '../../schema'\n+┊  ┊ 4┊import { resetDb, users } from '../../db'\n+┊  ┊ 5┊\n+┊  ┊ 6┊describe('Mutation.removeChat', () => {\n+┊  ┊ 7┊  beforeEach(resetDb)\n+┊  ┊ 8┊\n+┊  ┊ 9┊  it('removes chat by id', async () => {\n+┊  ┊10┊    const server = new ApolloServer({\n+┊  ┊11┊      schema,\n+┊  ┊12┊      context: () => ({\n+┊  ┊13┊        pubsub: new PubSub(),\n+┊  ┊14┊        currentUser: users[0],\n+┊  ┊15┊      }),\n+┊  ┊16┊    })\n+┊  ┊17┊\n+┊  ┊18┊    const { query, mutate } = createTestClient(server)\n+┊  ┊19┊\n+┊  ┊20┊    const addChatRes = await mutate({\n+┊  ┊21┊      variables: { chatId: '1' },\n+┊  ┊22┊      mutation: gql `\n+┊  ┊23┊        mutation RemoveChat($chatId: ID!) {\n+┊  ┊24┊          removeChat(chatId: $chatId)\n+┊  ┊25┊        }\n+┊  ┊26┊      `,\n+┊  ┊27┊    })\n+┊  ┊28┊\n+┊  ┊29┊    expect(addChatRes.data).toBeDefined()\n+┊  ┊30┊    expect(addChatRes.errors).toBeUndefined()\n+┊  ┊31┊    expect(addChatRes.data!.removeChat).toEqual('1')\n+┊  ┊32┊\n+┊  ┊33┊    const getChatRes = await query({\n+┊  ┊34┊      variables: { chatId: '1' },\n+┊  ┊35┊      query: gql `\n+┊  ┊36┊        query GetChat($chatId: ID!) {\n+┊  ┊37┊          chat(chatId: $chatId) {\n+┊  ┊38┊            id\n+┊  ┊39┊            name\n+┊  ┊40┊            participants {\n+┊  ┊41┊              id\n+┊  ┊42┊            }\n+┊  ┊43┊          }\n+┊  ┊44┊        }\n+┊  ┊45┊      `,\n+┊  ┊46┊    })\n+┊  ┊47┊\n+┊  ┊48┊    expect(addChatRes.data).toBeDefined()\n+┊  ┊49┊    expect(getChatRes.errors).toBeUndefined()\n+┊  ┊50┊    expect(addChatRes.data!.chat).toBeUndefined()\n+┊  ┊51┊  })\n+┊  ┊52┊})\n```\n\n[}]: #\n\nIn the client app, a chat could be removed directly from the `ChatRoomScreen`. On the top right corner, right on the navbar, we will add a dispose button that will call the `removeChat` mutation. Just like we did before, we will define the mutation document with `graphql-tag` and generate the correlated hook with CodeGen:\n\n[{]: <helper> (diffStep 12.4 module=\"client\")\n\n#### [Step 12.4: Add chat removal function](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/10c95c1)\n\n##### Changed src&#x2F;components&#x2F;ChatRoomScreen&#x2F;ChatNavbar.test.tsx\n```diff\n@@ -1,12 +1,17 @@\n ┊ 1┊ 1┊import { createMemoryHistory } from 'history'\n ┊ 2┊ 2┊import React from 'react'\n+┊  ┊ 3┊import { ApolloProvider } from 'react-apollo-hooks'\n ┊ 3┊ 4┊import { cleanup, render, fireEvent, wait } from 'react-testing-library'\n+┊  ┊ 5┊import { mockApolloClient } from '../../test-helpers'\n ┊ 4┊ 6┊import ChatNavbar from './ChatNavbar'\n+┊  ┊ 7┊import { RemoveChatDocument } from '../../graphql/types'\n ┊ 5┊ 8┊\n ┊ 6┊ 9┊describe('ChatNavbar', () => {\n ┊ 7┊10┊  afterEach(cleanup)\n ┊ 8┊11┊\n ┊ 9┊12┊  it('renders chat data', () => {\n+┊  ┊13┊    const client = mockApolloClient()\n+┊  ┊14┊\n ┊10┊15┊    const chat = {\n ┊11┊16┊      id: '1',\n ┊12┊17┊      name: 'Foo Bar',\n```\n```diff\n@@ -14,7 +19,11 @@\n ┊14┊19┊    }\n ┊15┊20┊\n ┊16┊21┊    {\n-┊17┊  ┊      const { container, getByTestId } = render(<ChatNavbar chat={chat} />)\n+┊  ┊22┊      const { container, getByTestId } = render(\n+┊  ┊23┊        <ApolloProvider client={client}>\n+┊  ┊24┊          <ChatNavbar chat={chat} />\n+┊  ┊25┊        </ApolloProvider>\n+┊  ┊26┊      )\n ┊18┊27┊\n ┊19┊28┊      expect(getByTestId('chat-name')).toHaveTextContent('Foo Bar')\n ┊20┊29┊      expect(getByTestId('chat-picture')).toHaveAttribute('src', 'https://localhost:4000/picture.jpg')\n```\n```diff\n@@ -22,6 +31,8 @@\n ┊22┊31┊  })\n ┊23┊32┊\n ┊24┊33┊  it('goes back on arrow click', async () => {\n+┊  ┊34┊    const client = mockApolloClient()\n+┊  ┊35┊\n ┊25┊36┊    const chat = {\n ┊26┊37┊      id: '1',\n ┊27┊38┊      name: 'Foo Bar',\n```\n```diff\n@@ -37,7 +48,11 @@\n ┊37┊48┊    )\n ┊38┊49┊\n ┊39┊50┊    {\n-┊40┊  ┊      const { container, getByTestId } = render(<ChatNavbar chat={chat} history={history} />)\n+┊  ┊51┊      const { container, getByTestId } = render(\n+┊  ┊52┊        <ApolloProvider client={client}>\n+┊  ┊53┊          <ChatNavbar chat={chat} history={history} />\n+┊  ┊54┊        </ApolloProvider>\n+┊  ┊55┊      )\n ┊41┊56┊\n ┊42┊57┊      fireEvent.click(getByTestId('back-button'))\n ┊43┊58┊\n```\n```diff\n@@ -46,4 +61,48 @@\n ┊ 46┊ 61┊      )\n ┊ 47┊ 62┊    }\n ┊ 48┊ 63┊  })\n+┊   ┊ 64┊\n+┊   ┊ 65┊  it('goes back on chat removal', async () => {\n+┊   ┊ 66┊    const client = mockApolloClient([\n+┊   ┊ 67┊      {\n+┊   ┊ 68┊        request: {\n+┊   ┊ 69┊          query: RemoveChatDocument,\n+┊   ┊ 70┊          variables: { chatId: '1' },\n+┊   ┊ 71┊        },\n+┊   ┊ 72┊        result: {\n+┊   ┊ 73┊          data: {\n+┊   ┊ 74┊            removeChat: '1'\n+┊   ┊ 75┊          }\n+┊   ┊ 76┊        }\n+┊   ┊ 77┊      },\n+┊   ┊ 78┊    ])\n+┊   ┊ 79┊\n+┊   ┊ 80┊    const chat = {\n+┊   ┊ 81┊      id: '1',\n+┊   ┊ 82┊      name: 'Foo Bar',\n+┊   ┊ 83┊      picture: 'https://localhost:4000/picture.jpg',\n+┊   ┊ 84┊    }\n+┊   ┊ 85┊\n+┊   ┊ 86┊    const history = createMemoryHistory()\n+┊   ┊ 87┊\n+┊   ┊ 88┊    history.push('/chats/1')\n+┊   ┊ 89┊\n+┊   ┊ 90┊    await wait(() =>\n+┊   ┊ 91┊      expect(history.location.pathname).toEqual('/chats/1')\n+┊   ┊ 92┊    )\n+┊   ┊ 93┊\n+┊   ┊ 94┊    {\n+┊   ┊ 95┊      const { container, getByTestId } = render(\n+┊   ┊ 96┊        <ApolloProvider client={client}>\n+┊   ┊ 97┊          <ChatNavbar chat={chat} history={history} />\n+┊   ┊ 98┊        </ApolloProvider>\n+┊   ┊ 99┊      )\n+┊   ┊100┊\n+┊   ┊101┊      fireEvent.click(getByTestId('delete-button'))\n+┊   ┊102┊\n+┊   ┊103┊      await wait(() =>\n+┊   ┊104┊        expect(history.location.pathname).toEqual('/chats')\n+┊   ┊105┊      )\n+┊   ┊106┊    }\n+┊   ┊107┊  })\n ┊ 49┊108┊})\n```\n\n##### Changed src&#x2F;components&#x2F;ChatRoomScreen&#x2F;ChatNavbar.tsx\n```diff\n@@ -1,9 +1,12 @@\n ┊ 1┊ 1┊import Button from '@material-ui/core/Button'\n ┊ 2┊ 2┊import Toolbar from '@material-ui/core/Toolbar'\n ┊ 3┊ 3┊import ArrowBackIcon from '@material-ui/icons/ArrowBack'\n+┊  ┊ 4┊import DeleteIcon from '@material-ui/icons/Delete'\n+┊  ┊ 5┊import gql from 'graphql-tag'\n ┊ 4┊ 6┊import * as React from 'react'\n ┊ 5┊ 7┊import { useCallback, useState } from 'react'\n ┊ 6┊ 8┊import styled from 'styled-components'\n+┊  ┊ 9┊import { useRemoveChatMutation } from '../../graphql/types'\n ┊ 7┊10┊\n ┊ 8┊11┊const Container = styled(Toolbar) `\n ┊ 9┊12┊  padding: 0;\n```\n```diff\n@@ -19,6 +22,12 @@\n ┊19┊22┊  }\n ┊20┊23┊`\n ┊21┊24┊\n+┊  ┊25┊const Rest = styled.div `\n+┊  ┊26┊  flex: 1;\n+┊  ┊27┊  display: flex;\n+┊  ┊28┊  justify-content: flex-end;\n+┊  ┊29┊`\n+┊  ┊30┊\n ┊22┊31┊const Picture = styled.img `\n ┊23┊32┊  height: 40px;\n ┊24┊33┊  width: 40px;\n```\n```diff\n@@ -33,7 +42,29 @@\n ┊33┊42┊  line-height: 56px;\n ┊34┊43┊`\n ┊35┊44┊\n+┊  ┊45┊const DeleteButton = styled(Button)`\n+┊  ┊46┊  color: var(--primary-text) !important;\n+┊  ┊47┊`\n+┊  ┊48┊\n+┊  ┊49┊export const removeChatMutation = gql`\n+┊  ┊50┊  mutation RemoveChat($chatId: ID!) {\n+┊  ┊51┊    removeChat(chatId: $chatId)\n+┊  ┊52┊  }\n+┊  ┊53┊`\n+┊  ┊54┊\n ┊36┊55┊const ChatNavbar = ({ chat, history }) => {\n+┊  ┊56┊  const removeChat = useRemoveChatMutation({\n+┊  ┊57┊    variables: {\n+┊  ┊58┊      chatId: chat.id\n+┊  ┊59┊    }\n+┊  ┊60┊  })\n+┊  ┊61┊\n+┊  ┊62┊  const handleRemoveChat = useCallback(() => {\n+┊  ┊63┊    removeChat().then(() => {\n+┊  ┊64┊      history.replace('/chats')\n+┊  ┊65┊    })\n+┊  ┊66┊  }, [removeChat])\n+┊  ┊67┊\n ┊37┊68┊  const navBack = useCallback(() => {\n ┊38┊69┊    history.replace('/chats')\n ┊39┊70┊  }, [true])\n```\n```diff\n@@ -45,6 +76,11 @@\n ┊45┊76┊      </BackButton>\n ┊46┊77┊      <Picture data-testid=\"chat-picture\" src={chat.picture} />\n ┊47┊78┊      <Name data-testid=\"chat-name\">{chat.name}</Name>\n+┊  ┊79┊      <Rest>\n+┊  ┊80┊        <DeleteButton data-testid=\"delete-button\" onClick={handleRemoveChat}>\n+┊  ┊81┊          <DeleteIcon />\n+┊  ┊82┊        </DeleteButton>\n+┊  ┊83┊      </Rest>\n ┊48┊84┊    </Container>\n ┊49┊85┊  )\n ┊50┊86┊}\n```\n\n[}]: #\n\nNormally this is a dangerous behavior because we wipe out the entire history without any warnings, which is not recommended. For tutoring purposes only we will keep it the way it is, because it makes things simple and easier to understand.\n\nTo be able to update the chats list cache, we will implement a `chatRemoved` subscription. The subscription will be broadcasted only to those who’re participants of the published chat:\n\n[{]: <helper> (diffStep 9.5 module=\"server\")\n\n#### [Step 9.5: Add Subscription.chatRemoved](https://github.com/Urigo/WhatsApp-Clone-Server/commit/5c395da)\n\n##### Changed schema&#x2F;resolvers.ts\n```diff\n@@ -151,7 +151,7 @@\n ┊151┊151┊      return chat\n ┊152┊152┊    },\n ┊153┊153┊\n-┊154┊   ┊    removeChat(root, { chatId }, { currentUser }) {\n+┊   ┊154┊    removeChat(root, { chatId }, { currentUser, pubsub }) {\n ┊155┊155┊      if (!currentUser) return null\n ┊156┊156┊\n ┊157┊157┊      const chatIndex = chats.findIndex(c => c.id === chatId)\n```\n```diff\n@@ -172,6 +172,11 @@\n ┊172┊172┊\n ┊173┊173┊      chats.splice(chatIndex, 1)\n ┊174┊174┊\n+┊   ┊175┊      pubsub.publish('chatRemoved', {\n+┊   ┊176┊        chatRemoved: chat.id,\n+┊   ┊177┊        targetChat: chat,\n+┊   ┊178┊      })\n+┊   ┊179┊\n ┊175┊180┊      return chatId\n ┊176┊181┊    }\n ┊177┊182┊  },\n```\n```diff\n@@ -200,6 +205,17 @@\n ┊200┊205┊          return chatAdded.participants.some(p => p === currentUser.id)\n ┊201┊206┊        },\n ┊202┊207┊      )\n+┊   ┊208┊    },\n+┊   ┊209┊\n+┊   ┊210┊    chatRemoved: {\n+┊   ┊211┊      subscribe: withFilter(\n+┊   ┊212┊        (root, args, { pubsub }) => pubsub.asyncIterator('chatRemoved'),\n+┊   ┊213┊        ({ targetChat }: { targetChat: Chat }, args, { currentUser }) => {\n+┊   ┊214┊          if (!currentUser) return false\n+┊   ┊215┊\n+┊   ┊216┊          return targetChat.participants.some(p => p === currentUser.id)\n+┊   ┊217┊        },\n+┊   ┊218┊      )\n ┊203┊219┊    }\n ┊204┊220┊  }\n ┊205┊221┊}\n```\n\n##### Changed schema&#x2F;typeDefs.graphql\n```diff\n@@ -40,4 +40,5 @@\n ┊40┊40┊type Subscription {\n ┊41┊41┊  messageAdded: Message!\n ┊42┊42┊  chatAdded: Chat!\n+┊  ┊43┊  chatRemoved: ID!\n ┊43┊44┊}\n```\n\n[}]: #\n\nIn the client, we will define the right subscription document:\n\n[{]: <helper> (diffStep 12.5 files=\"graphql/subscriptions\" module=\"client\")\n\n#### [Step 12.5: Update cache on chat removal](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/00674c0)\n\n##### Added src&#x2F;graphql&#x2F;subscriptions&#x2F;chatRemoved.subscription.ts\n```diff\n@@ -0,0 +1,7 @@\n+┊ ┊1┊import gql from 'graphql-tag'\n+┊ ┊2┊\n+┊ ┊3┊export default gql `\n+┊ ┊4┊  subscription ChatRemoved {\n+┊ ┊5┊    chatRemoved\n+┊ ┊6┊  }\n+┊ ┊7┊`\n```\n\n##### Changed src&#x2F;graphql&#x2F;subscriptions&#x2F;index.ts\n```diff\n@@ -1,2 +1,3 @@\n ┊1┊1┊export { default as messageAdded } from './messageAdded.subscription'\n ┊2┊2┊export { default as chatAdded } from './chatAdded.subscription'\n+┊ ┊3┊export { default as chatRemoved } from './chatRemoved.subscription'\n```\n\n[}]: #\n\nAnd we will update the `cache.service` to listen to the new subscription and update the `chats` query accordingly. When we deal with the fragment, we remove the `FullChat` fragment because it consists of the `Chat` fragment. If it was the other way around, we would still have some data leftovers from the `FullChat` on the fragment, because of how Apollo-Cache manages the store:\n\n[{]: <helper> (diffStep 12.5 files=\"cache.service\" module=\"client\")\n\n#### [Step 12.5: Update cache on chat removal](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/00674c0)\n\n##### Changed src&#x2F;services&#x2F;cache.service.ts\n```diff\n@@ -3,7 +3,13 @@\n ┊ 3┊ 3┊import { ApolloClient } from 'apollo-client'\n ┊ 4┊ 4┊import * as fragments from '../graphql/fragments'\n ┊ 5┊ 5┊import * as queries from '../graphql/queries'\n-┊ 6┊  ┊import { MessageFragment, ChatFragment, useMessageAddedSubscription, useChatAddedSubscription } from '../graphql/types'\n+┊  ┊ 6┊import {\n+┊  ┊ 7┊  MessageFragment,\n+┊  ┊ 8┊  ChatFragment,\n+┊  ┊ 9┊  useMessageAddedSubscription,\n+┊  ┊10┊  useChatAddedSubscription,\n+┊  ┊11┊  useChatRemovedSubscription,\n+┊  ┊12┊} from '../graphql/types'\n ┊ 7┊13┊\n ┊ 8┊14┊type Client = ApolloClient<any> | DataProxy\n ┊ 9┊15┊\n```\n```diff\n@@ -19,6 +25,12 @@\n ┊19┊25┊      writeChat(client, chatAdded)\n ┊20┊26┊    }\n ┊21┊27┊  })\n+┊  ┊28┊\n+┊  ┊29┊  useChatRemovedSubscription({\n+┊  ┊30┊    onSubscriptionData: ({ client, subscriptionData: { data: { chatRemoved } } }) => {\n+┊  ┊31┊      eraseChat(client, chatRemoved)\n+┊  ┊32┊    }\n+┊  ┊33┊  })\n ┊22┊34┊}\n ┊23┊35┊\n ┊24┊36┊export const writeMessage = (client: Client, message: MessageFragment) => {\n```\n```diff\n@@ -113,3 +125,47 @@\n ┊113┊125┊    })\n ┊114┊126┊  }\n ┊115┊127┊}\n+┊   ┊128┊\n+┊   ┊129┊export const eraseChat = (client: Client, chatId: string) => {\n+┊   ┊130┊  const chatType = {\n+┊   ┊131┊    __typename: 'Chat',\n+┊   ┊132┊    id: chatId\n+┊   ┊133┊  }\n+┊   ┊134┊\n+┊   ┊135┊  client.writeFragment({\n+┊   ┊136┊    id: defaultDataIdFromObject(chatType),\n+┊   ┊137┊    fragment: fragments.fullChat,\n+┊   ┊138┊    fragmentName: 'FullChat',\n+┊   ┊139┊    data: null,\n+┊   ┊140┊  })\n+┊   ┊141┊\n+┊   ┊142┊  rewriteChats:\n+┊   ┊143┊  {\n+┊   ┊144┊    let data\n+┊   ┊145┊    try {\n+┊   ┊146┊      data = client.readQuery({\n+┊   ┊147┊        query: queries.chats,\n+┊   ┊148┊      })\n+┊   ┊149┊    } catch (e) {\n+┊   ┊150┊      break rewriteChats\n+┊   ┊151┊    }\n+┊   ┊152┊\n+┊   ┊153┊    if (!data) break rewriteChats\n+┊   ┊154┊\n+┊   ┊155┊    const chats = data.chats\n+┊   ┊156┊\n+┊   ┊157┊    if (!chats) break rewriteChats\n+┊   ┊158┊\n+┊   ┊159┊    const chatIndex = chats.findIndex(c => c.id === chatId)\n+┊   ┊160┊\n+┊   ┊161┊    if (chatIndex === -1) break rewriteChats\n+┊   ┊162┊\n+┊   ┊163┊    // The chat will appear at the top of the ChatsList component\n+┊   ┊164┊    chats.splice(chatIndex, 1)\n+┊   ┊165┊\n+┊   ┊166┊    client.writeQuery({\n+┊   ┊167┊      query: queries.chats,\n+┊   ┊168┊      data: { chats: chats },\n+┊   ┊169┊    })\n+┊   ┊170┊  }\n+┊   ┊171┊}\n```\n\n[}]: #\n\nWe will also update the `ChatRoomScreen` to redirect us to the `/chats` route if the chat was not found. The render method of the component will be re-triggered automatically by `react-apollo-hooks` if the cached result of `useGetChat()` hook has changed, which means that even if you didn’t actively remove the chat, you will still be redirected as a result:\n\n[{]: <helper> (diffStep 12.5 files=\"ChatRoom\" module=\"client\")\n\n#### [Step 12.5: Update cache on chat removal](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/00674c0)\n\n##### Changed src&#x2F;components&#x2F;ChatRoomScreen&#x2F;ChatNavbar.tsx\n```diff\n@@ -6,6 +6,7 @@\n ┊ 6┊ 6┊import * as React from 'react'\n ┊ 7┊ 7┊import { useCallback, useState } from 'react'\n ┊ 8┊ 8┊import styled from 'styled-components'\n+┊  ┊ 9┊import { eraseChat } from '../../services/cache.service'\n ┊ 9┊10┊import { useRemoveChatMutation } from '../../graphql/types'\n ┊10┊11┊\n ┊11┊12┊const Container = styled(Toolbar) `\n```\n```diff\n@@ -56,6 +57,9 @@\n ┊56┊57┊  const removeChat = useRemoveChatMutation({\n ┊57┊58┊    variables: {\n ┊58┊59┊      chatId: chat.id\n+┊  ┊60┊    },\n+┊  ┊61┊    update: (client, { data: { removeChat } }) => {\n+┊  ┊62┊      eraseChat(client, removeChat)\n ┊59┊63┊    }\n ┊60┊64┊  })\n ┊61┊65┊\n```\n\n##### Changed src&#x2F;components&#x2F;ChatRoomScreen&#x2F;index.tsx\n```diff\n@@ -2,6 +2,7 @@\n ┊2┊2┊import gql from 'graphql-tag'\n ┊3┊3┊import * as React from 'react'\n ┊4┊4┊import { useCallback } from 'react'\n+┊ ┊5┊import { Redirect } from 'react-router-dom'\n ┊5┊6┊import { useApolloClient, useQuery, useMutation } from 'react-apollo-hooks'\n ┊6┊7┊import styled from 'styled-components'\n ┊7┊8┊import ChatNavbar from './ChatNavbar'\n```\n```diff\n@@ -70,6 +71,13 @@\n ┊70┊71┊\n ┊71┊72┊  if (loadingChat) return null\n ┊72┊73┊\n+┊  ┊74┊  // Chat was probably removed from cache by the subscription handler\n+┊  ┊75┊  if (!chat) {\n+┊  ┊76┊    return (\n+┊  ┊77┊      <Redirect to=\"/chats\" />\n+┊  ┊78┊    )\n+┊  ┊79┊  }\n+┊  ┊80┊\n ┊73┊81┊  return (\n ┊74┊82┊    <Container>\n ┊75┊83┊      <ChatNavbar chat={chat} history={history} />\n```\n\n[}]: #"
          },
          {
            "manualTitle": "Step 13: Authentication",
            "stepRevision": "e1c19d194b4b4847a76225a97c53128078503b80",
            "manualView": "In the previous step we’ve set the ground for the authentication system in our app. We have a users collection which can be used to distinguish which data the client is authorized to view, and we have a context handler which can retrieve the current user logged in based on the received value of the `cookie` header. It’s definitely a good starting point, but it misses a lot of things.\n\nIn this chapter we will implement a cookie-based authentication system. There are many ways to implement an authentication system in an app, but cookie-based authentication is one of the most popular ones, hence we will go with that method. Essentially the authentication flow in our app should look very simple: a user will be able to sign-in with a dedicated screen, and if he doesn’t own an account he can use the sign-up screen to create a new one. The more complicated part in this flow is the back-end, which is the core of this chapter. So before we get into the implementation, we need to understand the authentication process:\n\n- A user logs in with a username and a password.\nThe server compares the received username and password to the ones stored in the database.\n- If the comparison was successful, the server will generate a token and will set it as a cookie.\n- Each time a request is sent, the server will retrieve the username from the stored token on the cookie header and will send data back accordingly.\n\n![auth-flow](https://user-images.githubusercontent.com/7648874/55929679-55e94200-5c50-11e9-9fe7-54ad6194a572.png)\n\nThe stored token will save us the hassle of re-specifying the username and password over and over again each and every request. It’s important to note that everything in the authentication process is encrypted, **sensitive information will never be stored or sent in its raw form**, otherwise data might be stolen in case of a DB breach or a request hijacking. This is what it means for our app:\n\n- Passwords will always be stored in an encrypted form in the DB using an algorithm called [Bcrypt](https://en.wikipedia.org/wiki/Bcrypt). Bcrypt has the ability to compare the password in its raw form to the encrypted one, which can help us authorize the user.\n\n- Tokens are self contained. That means that once we decode the encrypted string we can get a hold of the username string. This form of encrypted tokens is called [Json Web Token (JWT)](https://jwt.io/).\n\n> We're not going to elaborate about the algorithm behind each encryption method because we want to focus more on practicality, although it's very much recommended to understand how each method works before proceeding.\n\nThe implementation will follow the principles above. Authentication is a hot topic in the GraphQL world and there are several ways of doing so. In our application we will implement the mechanism using the classic REST framework within our GraphQL back-end. This approach is completely fine and in line with the official GraphQL best practices. We will start with the back-end and set the infrastructure for authentication, and then we will move on to the front-end.\n\nWe’re gonna expose 2 new routes from our REST API: `/sign-in` and `/sign-up`. `/sign-out` is unnecessary because it can be done locally by deleting the right cookie. Our back-end is gonna grow bigger so first we will separate the Express app from the Apollo Server instance, and extract the env vars to a dedicated module:\n\n[{]: <helper> (diffStep 10.1 module=\"server\")\n\n#### [Step 10.1: Separate app into a different module](https://github.com/Urigo/WhatsApp-Clone-Server/commit/f9b9355)\n\n##### Added app.ts\n```diff\n@@ -0,0 +1,15 @@\n+┊  ┊ 1┊import bodyParser from 'body-parser'\n+┊  ┊ 2┊import cors from 'cors'\n+┊  ┊ 3┊import cookieParser from 'cookie-parser'\n+┊  ┊ 4┊import express from 'express'\n+┊  ┊ 5┊import { origin } from './env'\n+┊  ┊ 6┊\n+┊  ┊ 7┊export const app = express()\n+┊  ┊ 8┊\n+┊  ┊ 9┊app.use(cors({ credentials: true, origin }))\n+┊  ┊10┊app.use(bodyParser.json())\n+┊  ┊11┊app.use(cookieParser())\n+┊  ┊12┊\n+┊  ┊13┊app.get('/_ping', (req, res) => {\n+┊  ┊14┊  res.send('pong')\n+┊  ┊15┊})\n```\n\n##### Added env.ts\n```diff\n@@ -0,0 +1,2 @@\n+┊ ┊1┊export const origin = process.env.ORIGIN || 'http://localhost:3000'\n+┊ ┊2┊export const port = process.env.PORT || 4000\n```\n\n##### Changed index.ts\n```diff\n@@ -1,23 +1,10 @@\n ┊ 1┊ 1┊import { ApolloServer, gql, PubSub } from 'apollo-server-express'\n-┊ 2┊  ┊import bodyParser from 'body-parser'\n-┊ 3┊  ┊import cors from 'cors'\n-┊ 4┊  ┊import cookieParser from 'cookie-parser'\n-┊ 5┊  ┊import express from 'express'\n ┊ 6┊ 2┊import http from 'http'\n+┊  ┊ 3┊import { app } from './app'\n ┊ 7┊ 4┊import { users } from './db'\n+┊  ┊ 5┊import { origin, port } from './env'\n ┊ 8┊ 6┊import schema from './schema'\n ┊ 9┊ 7┊\n-┊10┊  ┊const app = express()\n-┊11┊  ┊\n-┊12┊  ┊const origin = process.env.ORIGIN || 'http://localhost:3000'\n-┊13┊  ┊app.use(cors({ credentials: true, origin }))\n-┊14┊  ┊app.use(bodyParser.json())\n-┊15┊  ┊app.use(cookieParser())\n-┊16┊  ┊\n-┊17┊  ┊app.get('/_ping', (req, res) => {\n-┊18┊  ┊  res.send('pong')\n-┊19┊  ┊})\n-┊20┊  ┊\n ┊21┊ 8┊const pubsub = new PubSub()\n ┊22┊ 9┊const server = new ApolloServer({\n ┊23┊10┊  schema,\n```\n```diff\n@@ -36,8 +23,6 @@\n ┊36┊23┊const httpServer = http.createServer(app)\n ┊37┊24┊server.installSubscriptionHandlers(httpServer)\n ┊38┊25┊\n-┊39┊  ┊const port = process.env.PORT || 4000\n-┊40┊  ┊\n ┊41┊26┊httpServer.listen(port, () => {\n ┊42┊27┊  console.log(`Server is listening on port ${port}`)\n ┊43┊28┊})\n```\n\n[}]: #\n\nWe will first start with the `/sign-in` route, so we can test it against pre-defined user credentials, and then we will proceed to implementing the `/sign-up` route. It would be a lot easier to progress this way. For that we will install a couple of packages:\n\n- `bcrypt` - which is responsible for running a one-way encryption against received passwords before they’re stored in the DB.\n- `jsonwebtoken` - responsible for encrypting the logged-in username before it’s set as a cooky and decrypting it once it’s sent back with a request.\n\n    $ npm install bcrypt jsonwebtoken\n    $ npm install --dev @types/bcrypt @types/jsonwebtoken\n\nAnd we will implement the `/sign-in` route:\n\n[{]: <helper> (diffStep 10.2 files=\"app\" module=\"server\")\n\n#### [Step 10.2: Add /sign-in route](https://github.com/Urigo/WhatsApp-Clone-Server/commit/2a05395)\n\n##### Changed app.ts\n```diff\n@@ -2,7 +2,10 @@\n ┊ 2┊ 2┊import cors from 'cors'\n ┊ 3┊ 3┊import cookieParser from 'cookie-parser'\n ┊ 4┊ 4┊import express from 'express'\n-┊ 5┊  ┊import { origin } from './env'\n+┊  ┊ 5┊import bcrypt from 'bcrypt'\n+┊  ┊ 6┊import jwt from 'jsonwebtoken'\n+┊  ┊ 7┊import { users } from './db'\n+┊  ┊ 8┊import { expiration, origin, secret } from './env'\n ┊ 6┊ 9┊\n ┊ 7┊10┊export const app = express()\n ┊ 8┊11┊\n```\n```diff\n@@ -13,3 +16,24 @@\n ┊13┊16┊app.get('/_ping', (req, res) => {\n ┊14┊17┊  res.send('pong')\n ┊15┊18┊})\n+┊  ┊19┊\n+┊  ┊20┊app.post('/sign-in', (req, res) => {\n+┊  ┊21┊  const { username, password } = req.body\n+┊  ┊22┊\n+┊  ┊23┊  const user = users.find(u => u.username === username)\n+┊  ┊24┊\n+┊  ┊25┊  if (!user) {\n+┊  ┊26┊    return res.status(404).send('user not found')\n+┊  ┊27┊  }\n+┊  ┊28┊\n+┊  ┊29┊  const passwordsMatch = bcrypt.compareSync(password, user.password)\n+┊  ┊30┊\n+┊  ┊31┊  if (!passwordsMatch) {\n+┊  ┊32┊    return res.status(400).send('password is incorrect')\n+┊  ┊33┊  }\n+┊  ┊34┊\n+┊  ┊35┊  const authToken = jwt.sign(username, secret)\n+┊  ┊36┊\n+┊  ┊37┊  res.cookie('authToken', authToken, { maxAge: expiration })\n+┊  ┊38┊  res.status(200).send({ id: user.id })\n+┊  ┊39┊})\n```\n\n[}]: #\n\nAs you can see we use a special secret before we encrypt the username with JWT. The same secret will be used later on to decrypt the token back into username when getting requests. If someone malicious will get a hold of that password, he can fabricate an authentication token for every user that he wants, **thus it’s important to choose a strong secret**.\n\nWhen building the context for our GraphQL resolvers, we will decode the received cookie with JWT using the same secret to determine the username who made the request. Once we have that username, we can simply retrieve the original user from the DB and define it on the context:\n\n[{]: <helper> (diffStep 10.3 module=\"server\")\n\n#### [Step 10.3: Get current user from auth token](https://github.com/Urigo/WhatsApp-Clone-Server/commit/a0072e1)\n\n##### Changed index.ts\n```diff\n@@ -1,17 +1,23 @@\n ┊ 1┊ 1┊import { ApolloServer, gql, PubSub } from 'apollo-server-express'\n ┊ 2┊ 2┊import http from 'http'\n+┊  ┊ 3┊import jwt from 'jsonwebtoken'\n ┊ 3┊ 4┊import { app } from './app'\n ┊ 4┊ 5┊import { users } from './db'\n-┊ 5┊  ┊import { origin, port } from './env'\n+┊  ┊ 6┊import { origin, port, secret } from './env'\n ┊ 6┊ 7┊import schema from './schema'\n ┊ 7┊ 8┊\n ┊ 8┊ 9┊const pubsub = new PubSub()\n ┊ 9┊10┊const server = new ApolloServer({\n ┊10┊11┊  schema,\n-┊11┊  ┊  context: ({ req }) => ({\n-┊12┊  ┊    currentUser: users.find(u => u.id === req.cookies.currentUserId),\n-┊13┊  ┊    pubsub,\n-┊14┊  ┊  }),\n+┊  ┊12┊  context: ({ req }) => {\n+┊  ┊13┊    const username = jwt.verify(req.cookies.authToken, secret) as string\n+┊  ┊14┊    const currentUser = username && users.find(u => u.username === username)\n+┊  ┊15┊\n+┊  ┊16┊    return {\n+┊  ┊17┊      currentUser,\n+┊  ┊18┊      pubsub,\n+┊  ┊19┊    }\n+┊  ┊20┊  },\n ┊15┊21┊})\n ┊16┊22┊\n ┊17┊23┊server.applyMiddleware({\n```\n\n[}]: #\n\nYou might have noticed that the User schema has been updated, because we try to address the `user.username` property. The authentication in our app will be done with a username and a password; accordingly, we will update our User type definitions and the user documents in the users collection mock. The credentials that we’re going to store can actually be used to sign-in to our app:\n\n[{]: <helper> (diffStep 10.4 module=\"server\")\n\n#### [Step 10.4: Update user schema to contain credentials](https://github.com/Urigo/WhatsApp-Clone-Server/commit/ebf1d3f)\n\n##### Changed db.ts\n```diff\n@@ -1,6 +1,8 @@\n ┊1┊1┊export type User = {\n ┊2┊2┊  id: string\n ┊3┊3┊  name: string\n+┊ ┊4┊  username: string\n+┊ ┊5┊  password: string\n ┊4┊6┊  picture: string\n ┊5┊7┊}\n ┊6┊8┊\n```\n```diff\n@@ -27,26 +29,36 @@\n ┊27┊29┊    {\n ┊28┊30┊      id: '1',\n ┊29┊31┊      name: 'Ray Edwards',\n+┊  ┊32┊      username: 'ray',\n+┊  ┊33┊      password: '$2a$08$NO9tkFLCoSqX1c5wk3s7z.JfxaVMKA.m7zUDdDwEquo4rvzimQeJm', // 111\n ┊30┊34┊      picture: 'https://randomuser.me/api/portraits/thumb/lego/1.jpg',\n ┊31┊35┊    },\n ┊32┊36┊    {\n ┊33┊37┊      id: '2',\n ┊34┊38┊      name: 'Ethan Gonzalez',\n+┊  ┊39┊      username: 'ethan',\n+┊  ┊40┊      password: '$2a$08$xE4FuCi/ifxjL2S8CzKAmuKLwv18ktksSN.F3XYEnpmcKtpbpeZgO', // 222\n ┊35┊41┊      picture: 'https://randomuser.me/api/portraits/thumb/men/1.jpg',\n ┊36┊42┊    },\n ┊37┊43┊    {\n ┊38┊44┊      id: '3',\n ┊39┊45┊      name: 'Bryan Wallace',\n+┊  ┊46┊      username: 'bryan',\n+┊  ┊47┊      password: '$2a$08$UHgH7J8G6z1mGQn2qx2kdeWv0jvgHItyAsL9hpEUI3KJmhVW5Q1d.', // 333\n ┊40┊48┊      picture: 'https://randomuser.me/api/portraits/thumb/men/2.jpg',\n ┊41┊49┊    },\n ┊42┊50┊    {\n ┊43┊51┊      id: '4',\n ┊44┊52┊      name: 'Avery Stewart',\n+┊  ┊53┊      username: 'avery',\n+┊  ┊54┊      password: '$2a$08$wR1k5Q3T9FC7fUgB7Gdb9Os/GV7dGBBf4PLlWT7HERMFhmFDt47xi', // 444\n ┊45┊55┊      picture: 'https://randomuser.me/api/portraits/thumb/women/1.jpg',\n ┊46┊56┊    },\n ┊47┊57┊    {\n ┊48┊58┊      id: '5',\n ┊49┊59┊      name: 'Katie Peterson',\n+┊  ┊60┊      username: 'katie',\n+┊  ┊61┊      password: '$2a$08$6.mbXqsDX82ZZ7q5d8Osb..JrGSsNp4R3IKj7mxgF6YGT0OmMw242', // 555\n ┊50┊62┊      picture: 'https://randomuser.me/api/portraits/thumb/women/2.jpg',\n ┊51┊63┊    },\n ┊52┊64┊  ])\n```\n```diff\n@@ -106,4 +118,4 @@\n ┊106┊118┊  ])\n ┊107┊119┊}\n ┊108┊120┊\n-┊109┊   ┊resetDb()\n+┊   ┊121┊resetDb()🚫↵\n```\n\n[}]: #\n\nTo test it out, we will run our front-end application and open the dev-console. Using the Fetch API we will send a request to the `/sign-in` route. We can use the credentials of one of the users stored in the DB. As for now all our restricted routes are observing the `currentUserId` cookie. This is wrong and no longer relevant. Let’s change the `withAuth()` method to observe the `authToken` cookie so we can test our REST endpoint successfully:\n\n[{]: <helper> (diffStep 13.1 module=\"client\")\n\n#### [Step 13.1: Use authToken cookie](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/6ea728e)\n\n##### Changed src&#x2F;services&#x2F;auth.service.tsx\n```diff\n@@ -23,8 +23,8 @@\n ┊23┊23┊  }\n ┊24┊24┊}\n ┊25┊25┊\n-┊26┊  ┊export const signIn = (currentUserId) => {\n-┊27┊  ┊  document.cookie = `currentUserId=${currentUserId}`\n+┊  ┊26┊export const signIn = (authToken) => {\n+┊  ┊27┊  document.cookie = `authToken=${authToken}`\n ┊28┊28┊\n ┊29┊29┊  // This will become async in the near future\n ┊30┊30┊  return Promise.resolve()\n```\n```diff\n@@ -33,12 +33,12 @@\n ┊33┊33┊export const signOut = () => {\n ┊34┊34┊  // \"expires\" represents the lifespan of a cookie. Beyond that date the cookie will\n ┊35┊35┊  // be deleted by the browser. \"expires\" cannot be viewed from \"document.cookie\"\n-┊36┊  ┊  document.cookie = `currentUserId=;expires=${new Date(0)}`\n+┊  ┊36┊  document.cookie = `authToken=;expires=${new Date(0)}`\n ┊37┊37┊\n ┊38┊38┊  // Clear cache\n ┊39┊39┊  return client.clearStore()\n ┊40┊40┊}\n ┊41┊41┊\n ┊42┊42┊export const isSignedIn = () => {\n-┊43┊  ┊  return /currentUserId=.+(;|$)/.test(document.cookie)\n+┊  ┊43┊  return /authToken=.+(;|$)/.test(document.cookie)\n ┊44┊44┊}\n```\n\n[}]: #\n\nNow we can perform the sign-in. It would be a good idea to sign-in with the first user - `ray`, since all the DB mock is built around him:\n\n```js\nfetch(`http://localhost:4000/sign-in`, {\n  method: 'POST',\n  body: JSON.stringify({\n    username: 'ray',\n    password: '111',\n  }),\n  credentials: 'include',\n  headers: {\n    'Accept': 'application/json',\n    'Content-Type': 'application/json',\n  },\n})\n```\n\nNow if we would look at the value of `document.cookie` we should see a key named `authToken` with a JWT token and the `ChatsListScreen` should show the chats which are relevant to `ray`. To complete the sign-in flow we would need to update the `AuthScreen` and the `auth.service` to use username and password and the actual `/sign-in` route we’ve just implemented.\n\nTo check if we’re authorized to visit a route, not only we would need to check if we have the `authToken` cookie defined, but we would also need to validate it against the server to see that it actually references a real user. For that we will implement `Query.me` which will send us back the current user logged in directly from the context:\n\n[{]: <helper> (diffStep 10.5 module=\"server\")\n\n#### [Step 10.5: Add Query.me](https://github.com/Urigo/WhatsApp-Clone-Server/commit/9394de4)\n\n##### Changed schema&#x2F;resolvers.ts\n```diff\n@@ -65,6 +65,10 @@\n ┊65┊65┊  },\n ┊66┊66┊\n ┊67┊67┊  Query: {\n+┊  ┊68┊    me(root, args, { currentUser }) {\n+┊  ┊69┊      return currentUser || null\n+┊  ┊70┊    },\n+┊  ┊71┊\n ┊68┊72┊    chats(root, args, { currentUser }) {\n ┊69┊73┊      if (!currentUser) return []\n ┊70┊74┊\n```\n\n##### Changed schema&#x2F;typeDefs.graphql\n```diff\n@@ -26,6 +26,7 @@\n ┊26┊26┊}\n ┊27┊27┊\n ┊28┊28┊type Query {\n+┊  ┊29┊  me: User\n ┊29┊30┊  chats: [Chat!]!\n ┊30┊31┊  chat(chatId: ID!): Chat\n ┊31┊32┊  users: [User!]!\n```\n\n##### Added tests&#x2F;queries&#x2F;getMe.test.ts\n```diff\n@@ -0,0 +1,33 @@\n+┊  ┊ 1┊import { createTestClient } from 'apollo-server-testing'\n+┊  ┊ 2┊import { ApolloServer, gql } from 'apollo-server-express'\n+┊  ┊ 3┊import schema from '../../schema'\n+┊  ┊ 4┊import { users } from '../../db'\n+┊  ┊ 5┊\n+┊  ┊ 6┊describe('Query.me', () => {\n+┊  ┊ 7┊  it('should fetch current user', async () => {\n+┊  ┊ 8┊    const server = new ApolloServer({\n+┊  ┊ 9┊      schema,\n+┊  ┊10┊      context: () => ({\n+┊  ┊11┊        currentUser: users[0],\n+┊  ┊12┊      }),\n+┊  ┊13┊    })\n+┊  ┊14┊\n+┊  ┊15┊    const { query } = createTestClient(server)\n+┊  ┊16┊\n+┊  ┊17┊    const res = await query({\n+┊  ┊18┊      query: gql `\n+┊  ┊19┊        query GetMe {\n+┊  ┊20┊          me {\n+┊  ┊21┊            id\n+┊  ┊22┊            name\n+┊  ┊23┊            picture\n+┊  ┊24┊          }\n+┊  ┊25┊        }\n+┊  ┊26┊      `,\n+┊  ┊27┊    })\n+┊  ┊28┊\n+┊  ┊29┊    expect(res.data).toBeDefined()\n+┊  ┊30┊    expect(res.errors).toBeUndefined()\n+┊  ┊31┊    expect(res.data).toMatchSnapshot()\n+┊  ┊32┊  })\n+┊  ┊33┊})\n```\n\n[}]: #\n\nNow back to the `auth.service`, we will replace the `signIn()` method implementation with one that actually calls the `/sign-in` REST endpoint in our API:\n\n[{]: <helper> (diffStep 13.2 module=\"client\")\n\n#### [Step 13.2: Update auth service to call REST endpoint](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/c8b2efb)\n\n##### Changed src&#x2F;services&#x2F;auth.service.tsx\n```diff\n@@ -1,3 +1,4 @@\n+┊ ┊1┊import { parse as parseCookie } from 'cookie'\n ┊1┊2┊import * as React from 'react'\n ┊2┊3┊import { Redirect } from 'react-router-dom'\n ┊3┊4┊import client from '../client'\n```\n```diff\n@@ -23,22 +24,28 @@\n ┊23┊24┊  }\n ┊24┊25┊}\n ┊25┊26┊\n-┊26┊  ┊export const signIn = (authToken) => {\n-┊27┊  ┊  document.cookie = `authToken=${authToken}`\n-┊28┊  ┊\n-┊29┊  ┊  // This will become async in the near future\n-┊30┊  ┊  return Promise.resolve()\n+┊  ┊27┊export const signIn = ({ username, password }) => {\n+┊  ┊28┊  return fetch(`${process.env.REACT_APP_SERVER_URL}/sign-in`, {\n+┊  ┊29┊    method: 'POST',\n+┊  ┊30┊    body: JSON.stringify({ username, password }),\n+┊  ┊31┊    credentials: 'include',\n+┊  ┊32┊    headers: {\n+┊  ┊33┊      'Accept': 'application/json',\n+┊  ┊34┊      'Content-Type': 'application/json',\n+┊  ┊35┊    },\n+┊  ┊36┊  }).then(res => {\n+┊  ┊37┊    if (res.status >= 400) {\n+┊  ┊38┊      return res.text().then(e => Promise.reject(e))\n+┊  ┊39┊    }\n+┊  ┊40┊  })\n ┊31┊41┊}\n ┊32┊42┊\n ┊33┊43┊export const signOut = () => {\n-┊34┊  ┊  // \"expires\" represents the lifespan of a cookie. Beyond that date the cookie will\n-┊35┊  ┊  // be deleted by the browser. \"expires\" cannot be viewed from \"document.cookie\"\n ┊36┊44┊  document.cookie = `authToken=;expires=${new Date(0)}`\n ┊37┊45┊\n-┊38┊  ┊  // Clear cache\n ┊39┊46┊  return client.clearStore()\n ┊40┊47┊}\n ┊41┊48┊\n ┊42┊49┊export const isSignedIn = () => {\n ┊43┊50┊  return /authToken=.+(;|$)/.test(document.cookie)\n-┊44┊  ┊}\n+┊  ┊51┊}🚫↵\n```\n\n[}]: #\n\nAnd we will use the GraphQL query we’ve just implemented to check if the user actually exists within the DB before we proceed to the restricted route:\n\n[{]: <helper> (diffStep 13.3 module=\"client\")\n\n#### [Step 13.3: Validate auth token against the back-end on restricted route](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/37cb247)\n\n##### Added src&#x2F;graphql&#x2F;queries&#x2F;me.query.ts\n```diff\n@@ -0,0 +1,11 @@\n+┊  ┊ 1┊import gql from 'graphql-tag'\n+┊  ┊ 2┊import * as fragments from '../fragments'\n+┊  ┊ 3┊\n+┊  ┊ 4┊export default gql `\n+┊  ┊ 5┊  query Me {\n+┊  ┊ 6┊    me {\n+┊  ┊ 7┊      ...User\n+┊  ┊ 8┊    }\n+┊  ┊ 9┊  }\n+┊  ┊10┊  ${fragments.user}\n+┊  ┊11┊`\n```\n\n##### Changed src&#x2F;services&#x2F;auth.service.tsx\n```diff\n@@ -1,9 +1,17 @@\n ┊ 1┊ 1┊import { parse as parseCookie } from 'cookie'\n ┊ 2┊ 2┊import * as React from 'react'\n+┊  ┊ 3┊import { useContext } from 'react'\n ┊ 3┊ 4┊import { Redirect } from 'react-router-dom'\n ┊ 4┊ 5┊import client from '../client'\n+┊  ┊ 6┊import { useMeQuery, User } from '../graphql/types'\n ┊ 5┊ 7┊import { useCacheService } from './cache.service'\n ┊ 6┊ 8┊\n+┊  ┊ 9┊const MyContext = React.createContext<User>(null)\n+┊  ┊10┊\n+┊  ┊11┊export const useMe = () => {\n+┊  ┊12┊  return useContext(MyContext)\n+┊  ┊13┊}\n+┊  ┊14┊\n ┊ 7┊15┊export const withAuth = (Component: React.ComponentType) => {\n ┊ 8┊16┊  return (props) => {\n ┊ 9┊17┊    if (!isSignedIn()) {\n```\n```diff\n@@ -16,10 +24,22 @@\n ┊16┊24┊      )\n ┊17┊25┊    }\n ┊18┊26┊\n+┊  ┊27┊    const { data, error, loading } = useMeQuery()\n+┊  ┊28┊\n ┊19┊29┊    useCacheService()\n ┊20┊30┊\n+┊  ┊31┊    if (loading) return null\n+┊  ┊32┊\n+┊  ┊33┊    if (error || !data.me) {\n+┊  ┊34┊      signOut()\n+┊  ┊35┊\n+┊  ┊36┊      return <Redirect to=\"/sign-in\" />\n+┊  ┊37┊    }\n+┊  ┊38┊\n ┊21┊39┊    return (\n-┊22┊  ┊      <Component {...props} />\n+┊  ┊40┊      <MyContext.Provider value={data.me}>\n+┊  ┊41┊        <Component {...props} />\n+┊  ┊42┊      </MyContext.Provider>\n ┊23┊43┊    )\n ┊24┊44┊  }\n ┊25┊45┊}\n```\n\n[}]: #\n\nwe will use the new query to try and fetch the user directly from the back-end, and we will only proceed if the user was actually found. In addition, we will replace the `signIn()` method to call our REST API using the native fetch API:\n\n[{]: <helper> (diffStep 13.4 module=\"client\")\n\n#### [Step 13.4: Add username and password to AuthScreen](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/462cb4f)\n\n##### Changed src&#x2F;components&#x2F;AuthScreen&#x2F;index.tsx\n```diff\n@@ -110,21 +110,33 @@\n ┊110┊110┊`\n ┊111┊111┊\n ┊112┊112┊export default ({ history }) => {\n-┊113┊   ┊  const [userId, setUserId] = useState('')\n+┊   ┊113┊  const [username, setUsername] = useState('')\n+┊   ┊114┊  const [password, setPassword] = useState('')\n+┊   ┊115┊  const [error, setError] = useState('')\n ┊114┊116┊\n-┊115┊   ┊  const onUserIdChange = useCallback(({ target }) => {\n-┊116┊   ┊    setUserId(target.value)\n+┊   ┊117┊  const onUsernameChange = useCallback(({ target }) => {\n+┊   ┊118┊    setError('')\n+┊   ┊119┊    setUsername(target.value)\n+┊   ┊120┊  }, [true])\n+┊   ┊121┊\n+┊   ┊122┊  const onPasswordChange = useCallback(({ target }) => {\n+┊   ┊123┊    setError('')\n+┊   ┊124┊    setPassword(target.value)\n ┊117┊125┊  }, [true])\n ┊118┊126┊\n ┊119┊127┊  const maySignIn = useCallback(() => {\n-┊120┊   ┊    return !!userId\n-┊121┊   ┊  }, [userId])\n+┊   ┊128┊    return !!(username && password)\n+┊   ┊129┊  }, [username, password])\n ┊122┊130┊\n ┊123┊131┊  const handleSignIn = useCallback(() => {\n-┊124┊   ┊    signIn(userId).then(() => {\n-┊125┊   ┊      history.replace('/chats')\n-┊126┊   ┊    })\n-┊127┊   ┊  }, [userId])\n+┊   ┊132┊    signIn({ username, password })\n+┊   ┊133┊      .then(() => {\n+┊   ┊134┊        history.push('/chats')\n+┊   ┊135┊      })\n+┊   ┊136┊      .catch(error => {\n+┊   ┊137┊        setError(error.message || error)\n+┊   ┊138┊      })\n+┊   ┊139┊  }, [username, password])\n ┊128┊140┊\n ┊129┊141┊  return (\n ┊130┊142┊    <Container>\n```\n```diff\n@@ -137,12 +149,21 @@\n ┊137┊149┊          <Legend>Sign in</Legend>\n ┊138┊150┊          <Section>\n ┊139┊151┊            <TextField\n-┊140┊   ┊              data-testid=\"user-id-input\"\n-┊141┊   ┊              label=\"User ID\"\n-┊142┊   ┊              value={userId}\n-┊143┊   ┊              onChange={onUserIdChange}\n+┊   ┊152┊              className=\"AuthScreen-text-field\"\n+┊   ┊153┊              label=\"Username\"\n+┊   ┊154┊              value={username}\n+┊   ┊155┊              onChange={onUsernameChange}\n+┊   ┊156┊              margin=\"normal\"\n+┊   ┊157┊              placeholder=\"Enter your username\"\n+┊   ┊158┊            />\n+┊   ┊159┊            <TextField\n+┊   ┊160┊              className=\"AuthScreen-text-field\"\n+┊   ┊161┊              label=\"Password\"\n+┊   ┊162┊              type=\"password\"\n+┊   ┊163┊              value={password}\n+┊   ┊164┊              onChange={onPasswordChange}\n ┊144┊165┊              margin=\"normal\"\n-┊145┊   ┊              placeholder=\"Enter current user ID\"\n+┊   ┊166┊              placeholder=\"Enter your password\"\n ┊146┊167┊            />\n ┊147┊168┊          </Section>\n ┊148┊169┊          <Button\n```\n\n[}]: #\n\nThe behavior of the updated screen should be identical to what we had so far. To complete the flow we’ll need a way to sign-up. When we signing-up we will need the following parameters: `name`, `username`, `password` and `passwordConfirm`. In addition we will need to run certain validations against the parameters:\n\n- The name must be at least 3 and at most 50 characters long.\n- The username must be at least 3 and at most 18 characters long.\n- A password must be at least 8 and at most 30 characters long. In addition, it should contain English letters, numbers, and special characters.\n\nFor that we will implement a dedicated validations module:\n\n[{]: <helper> (diffStep 10.6 files=\"validators\" module=\"server\")\n\n#### [Step 10.6: Add /sign-up route](https://github.com/Urigo/WhatsApp-Clone-Server/commit/f45b6e1)\n\n##### Added validators.ts\n```diff\n@@ -0,0 +1,43 @@\n+┊  ┊ 1┊export const validatePassword = (ctx: string, str: string) => {\n+┊  ┊ 2┊  if (typeof str !== 'string') {\n+┊  ┊ 3┊    throw TypeError(`${ctx} must be a string`)\n+┊  ┊ 4┊  }\n+┊  ┊ 5┊\n+┊  ┊ 6┊  validateLength(ctx, str, 8, 30)\n+┊  ┊ 7┊\n+┊  ┊ 8┊  if (!/[a-zA-Z]+/.test(str)) {\n+┊  ┊ 9┊    throw TypeError(`${ctx} must contain english letters`)\n+┊  ┊10┊  }\n+┊  ┊11┊\n+┊  ┊12┊  if (!/\\d+/.test(str)) {\n+┊  ┊13┊    throw TypeError(`${ctx} must contain numbers`)\n+┊  ┊14┊  }\n+┊  ┊15┊\n+┊  ┊16┊  if (!/[^\\da-zA-Z]+/.test(str)) {\n+┊  ┊17┊    throw TypeError(`${ctx} must contain special charachters`)\n+┊  ┊18┊  }\n+┊  ┊19┊}\n+┊  ┊20┊\n+┊  ┊21┊export const validateLength = (ctx: string, str: string, ...args: number[]) => {\n+┊  ┊22┊  let min, max\n+┊  ┊23┊\n+┊  ┊24┊  if (args.length === 1) {\n+┊  ┊25┊    min = 0\n+┊  ┊26┊    max = args[0]\n+┊  ┊27┊  } else {\n+┊  ┊28┊    min = args[0]\n+┊  ┊29┊    max = args[1]\n+┊  ┊30┊  }\n+┊  ┊31┊\n+┊  ┊32┊  if (typeof str !== 'string') {\n+┊  ┊33┊    throw TypeError(`${ctx} must be a string`)\n+┊  ┊34┊  }\n+┊  ┊35┊\n+┊  ┊36┊  if (str.length < min) {\n+┊  ┊37┊    throw TypeError(`${ctx} must be at least ${min} chars long`)\n+┊  ┊38┊  }\n+┊  ┊39┊\n+┊  ┊40┊  if (str.length > max) {\n+┊  ┊41┊    throw TypeError(`${ctx} must contain ${max} chars at most`)\n+┊  ┊42┊  }\n+┊  ┊43┊}\n```\n\n[}]: #\n\nAnd we will implement the handler for the `/sign-up` route:\n\n[{]: <helper> (diffStep 10.6 files=\"app\" module=\"server\")\n\n#### [Step 10.6: Add /sign-up route](https://github.com/Urigo/WhatsApp-Clone-Server/commit/f45b6e1)\n\n##### Changed app.ts\n```diff\n@@ -4,8 +4,9 @@\n ┊ 4┊ 4┊import express from 'express'\n ┊ 5┊ 5┊import bcrypt from 'bcrypt'\n ┊ 6┊ 6┊import jwt from 'jsonwebtoken'\n-┊ 7┊  ┊import { users } from './db'\n+┊  ┊ 7┊import { User, users } from './db'\n ┊ 8┊ 8┊import { expiration, origin, secret } from './env'\n+┊  ┊ 9┊import { validateLength, validatePassword } from './validators'\n ┊ 9┊10┊\n ┊10┊11┊export const app = express()\n ┊11┊12┊\n```\n```diff\n@@ -17,6 +18,40 @@\n ┊17┊18┊  res.send('pong')\n ┊18┊19┊})\n ┊19┊20┊\n+┊  ┊21┊app.post('/sign-up', (req, res) => {\n+┊  ┊22┊  const { name, username, password, passwordConfirm } = req.body\n+┊  ┊23┊\n+┊  ┊24┊  try {\n+┊  ┊25┊    validateLength('req.name', name, 3, 50)\n+┊  ┊26┊    validateLength('req.username', name, 3, 18)\n+┊  ┊27┊    validatePassword('req.password', password)\n+┊  ┊28┊\n+┊  ┊29┊    if (password !== passwordConfirm) {\n+┊  ┊30┊      throw Error(\"req.password and req.passwordConfirm don't match\")\n+┊  ┊31┊    }\n+┊  ┊32┊\n+┊  ┊33┊    if (users.some(u => u.username === username)) {\n+┊  ┊34┊      throw Error(\"username already exists\")\n+┊  ┊35┊    }\n+┊  ┊36┊  } catch (e) {\n+┊  ┊37┊    return res.status(400).send(e.message)\n+┊  ┊38┊  }\n+┊  ┊39┊\n+┊  ┊40┊  const passwordHash = bcrypt.hashSync(password, bcrypt.genSaltSync(8))\n+┊  ┊41┊\n+┊  ┊42┊  const user: User = {\n+┊  ┊43┊    id: String(users.length + 1),\n+┊  ┊44┊    password: passwordHash,\n+┊  ┊45┊    picture: '',\n+┊  ┊46┊    username,\n+┊  ┊47┊    name,\n+┊  ┊48┊  }\n+┊  ┊49┊\n+┊  ┊50┊  users.push(user)\n+┊  ┊51┊\n+┊  ┊52┊  res.status(200).send({ id: user.id })\n+┊  ┊53┊})\n+┊  ┊54┊\n ┊20┊55┊app.post('/sign-in', (req, res) => {\n ┊21┊56┊  const { username, password } = req.body\n ┊22┊57┊\n```\n\n[}]: #\n\nBefore encrypting the password we append a string called “salt” to it. Even though the passwords are stored encrypted in the DB, a hacker might use a dictionary of common passwords in their encrypted form to decipher the original password. When adding salt to a password which is essentially a random string, the hacker cannot use a dictionary anymore since he would need to know the salt. Hypothetically, the hacker can get a hold of the salt and re-generate the entire dictionary, however that would take too long because of the way Bcrypt is designed to work.\n\nGoing back to the client, we will implement a new `signUp()` method in the `auth.service` that will call the `/sign-up` route in our REST API:\n\n[{]: <helper> (diffStep 13.5 module=\"client\")\n\n#### [Step 13.5: Add signUp() method to auth.service](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/566c388)\n\n##### Changed src&#x2F;services&#x2F;auth.service.tsx\n```diff\n@@ -60,6 +60,22 @@\n ┊60┊60┊  })\n ┊61┊61┊}\n ┊62┊62┊\n+┊  ┊63┊export const signUp = ({ name, username, password, passwordConfirm }) => {\n+┊  ┊64┊  return fetch(`${process.env.REACT_APP_SERVER_URL}/sign-up`, {\n+┊  ┊65┊    method: 'POST',\n+┊  ┊66┊    body: JSON.stringify({ name, username, password, passwordConfirm }),\n+┊  ┊67┊    credentials: 'include',\n+┊  ┊68┊    headers: {\n+┊  ┊69┊      'Accept': 'application/json',\n+┊  ┊70┊      'Content-Type': 'application/json',\n+┊  ┊71┊    },\n+┊  ┊72┊  }).then(res => {\n+┊  ┊73┊    if (res.status >= 400) {\n+┊  ┊74┊      return res.text().then(e => Promise.reject(e))\n+┊  ┊75┊    }\n+┊  ┊76┊  })\n+┊  ┊77┊}\n+┊  ┊78┊\n ┊63┊79┊export const signOut = () => {\n ┊64┊80┊  document.cookie = `authToken=;expires=${new Date(0)}`\n```\n\n[}]: #\n\nNow we will implement a dedicated `SignUpForm` that we can use to perform the sign-up. Instead of implementing a new screen, we will use the `AuthScreen` to alternate between the `SignInForm` and the `SignUpForm` using `AnimatedSwitch`. This way we can have a container component that is common for both forms, and we will be able to switch between the two very smoothly. We will first define a new `/sign-up` route in our router:\n\n[{]: <helper> (diffStep 13.6 module=\"client\")\n\n#### [Step 13.6: Split AuthScreen into SignInForm and SignUpForm](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/04dbb89)\n\n##### Added src&#x2F;components&#x2F;AuthScreen&#x2F;SignInForm.test.tsx\n```diff\n@@ -0,0 +1,81 @@\n+┊  ┊ 1┊import { createMemoryHistory } from 'history'\n+┊  ┊ 2┊import React from 'react'\n+┊  ┊ 3┊import { cleanup, render, fireEvent, wait, waitForElement } from 'react-testing-library'\n+┊  ┊ 4┊import SignInForm from './SignInForm'\n+┊  ┊ 5┊\n+┊  ┊ 6┊describe('SignInForm', () => {\n+┊  ┊ 7┊  afterEach(cleanup)\n+┊  ┊ 8┊  afterEach(() => fetch.resetMocks())\n+┊  ┊ 9┊\n+┊  ┊10┊  it('enables sign-in button when filled in', async () => {\n+┊  ┊11┊    const history = createMemoryHistory()\n+┊  ┊12┊\n+┊  ┊13┊    {\n+┊  ┊14┊      const { container, getByTestId } = render(<SignInForm history={history} />)\n+┊  ┊15┊      const usernameInput = getByTestId('username-input').querySelector('input')\n+┊  ┊16┊      const passwordInput = getByTestId('password-input').querySelector('input')\n+┊  ┊17┊      const signInButton = getByTestId('sign-in-button') as HTMLButtonElement\n+┊  ┊18┊\n+┊  ┊19┊      expect(signInButton.disabled).toEqual(true)\n+┊  ┊20┊\n+┊  ┊21┊      fireEvent.change(usernameInput, { target: { value: 'username' } })\n+┊  ┊22┊      fireEvent.change(passwordInput, { target: { value: 'password' } })\n+┊  ┊23┊\n+┊  ┊24┊      await waitForElement(() => usernameInput)\n+┊  ┊25┊      await waitForElement(() => passwordInput)\n+┊  ┊26┊\n+┊  ┊27┊      expect(signInButton.disabled).toEqual(false)\n+┊  ┊28┊    }\n+┊  ┊29┊  })\n+┊  ┊30┊\n+┊  ┊31┊  it('prints server error if input was wrong', async () => {\n+┊  ┊32┊    const history = createMemoryHistory()\n+┊  ┊33┊\n+┊  ┊34┊    fetchMock.mockRejectOnce(new Error('sign-in failed'))\n+┊  ┊35┊\n+┊  ┊36┊    {\n+┊  ┊37┊      const { container, getByTestId } = render(<SignInForm history={history} />)\n+┊  ┊38┊      const usernameInput = getByTestId('username-input').querySelector('input')\n+┊  ┊39┊      const passwordInput = getByTestId('password-input').querySelector('input')\n+┊  ┊40┊      const signInButton = getByTestId('sign-in-button') as HTMLButtonElement\n+┊  ┊41┊      const errorMessage = getByTestId('error-message')\n+┊  ┊42┊\n+┊  ┊43┊      fireEvent.change(usernameInput, { target: { value: 'username' } })\n+┊  ┊44┊      fireEvent.change(passwordInput, { target: { value: 'password' } })\n+┊  ┊45┊\n+┊  ┊46┊      await waitForElement(() => usernameInput)\n+┊  ┊47┊      await waitForElement(() => passwordInput)\n+┊  ┊48┊\n+┊  ┊49┊      fireEvent.click(signInButton)\n+┊  ┊50┊\n+┊  ┊51┊      await waitForElement(() => errorMessage)\n+┊  ┊52┊\n+┊  ┊53┊      expect(errorMessage.innerHTML).toEqual('sign-in failed')\n+┊  ┊54┊    }\n+┊  ┊55┊  })\n+┊  ┊56┊\n+┊  ┊57┊  it('navigates to /chats if everything went right', async () => {\n+┊  ┊58┊    const history = createMemoryHistory()\n+┊  ┊59┊\n+┊  ┊60┊    fetchMock.mockResponseOnce('success')\n+┊  ┊61┊\n+┊  ┊62┊    {\n+┊  ┊63┊      const { container, getByTestId } = render(<SignInForm history={history} />)\n+┊  ┊64┊      const usernameInput = getByTestId('username-input').querySelector('input')\n+┊  ┊65┊      const passwordInput = getByTestId('password-input').querySelector('input')\n+┊  ┊66┊      const signInButton = getByTestId('sign-in-button') as HTMLButtonElement\n+┊  ┊67┊\n+┊  ┊68┊      fireEvent.change(usernameInput, { target: { value: 'username' } })\n+┊  ┊69┊      fireEvent.change(passwordInput, { target: { value: 'password' } })\n+┊  ┊70┊\n+┊  ┊71┊      await waitForElement(() => usernameInput)\n+┊  ┊72┊      await waitForElement(() => passwordInput)\n+┊  ┊73┊\n+┊  ┊74┊      fireEvent.click(signInButton)\n+┊  ┊75┊\n+┊  ┊76┊      await wait(() =>\n+┊  ┊77┊        expect(history.location.pathname).toEqual('/chats')\n+┊  ┊78┊      )\n+┊  ┊79┊    }\n+┊  ┊80┊  })\n+┊  ┊81┊})\n```\n\n##### Added src&#x2F;components&#x2F;AuthScreen&#x2F;SignInForm.tsx\n```diff\n@@ -0,0 +1,81 @@\n+┊  ┊ 1┊import { History } from 'history'\n+┊  ┊ 2┊import * as React from 'react'\n+┊  ┊ 3┊import { useCallback, useState } from 'react'\n+┊  ┊ 4┊import { signIn } from '../../services/auth.service'\n+┊  ┊ 5┊import {\n+┊  ┊ 6┊  SignForm,\n+┊  ┊ 7┊  ActualForm,\n+┊  ┊ 8┊  Legend,\n+┊  ┊ 9┊  Section,\n+┊  ┊10┊  TextField,\n+┊  ┊11┊  Button,\n+┊  ┊12┊  ErrorMessage,\n+┊  ┊13┊} from './form-components'\n+┊  ┊14┊\n+┊  ┊15┊export default ({ history }) => {\n+┊  ┊16┊  const [username, setUsername] = useState('')\n+┊  ┊17┊  const [password, setPassword] = useState('')\n+┊  ┊18┊  const [error, setError] = useState('')\n+┊  ┊19┊\n+┊  ┊20┊  const onUsernameChange = useCallback(({ target }) => {\n+┊  ┊21┊    setError('')\n+┊  ┊22┊    setUsername(target.value)\n+┊  ┊23┊  }, [true])\n+┊  ┊24┊\n+┊  ┊25┊  const onPasswordChange = useCallback(({ target }) => {\n+┊  ┊26┊    setError('')\n+┊  ┊27┊    setPassword(target.value)\n+┊  ┊28┊  }, [true])\n+┊  ┊29┊\n+┊  ┊30┊  const maySignIn = useCallback(() => {\n+┊  ┊31┊    return !!(username && password)\n+┊  ┊32┊  }, [username, password])\n+┊  ┊33┊\n+┊  ┊34┊  const handleSignIn = useCallback(() => {\n+┊  ┊35┊    signIn({ username, password })\n+┊  ┊36┊      .then(() => {\n+┊  ┊37┊        history.replace('/chats')\n+┊  ┊38┊      })\n+┊  ┊39┊      .catch(error => {\n+┊  ┊40┊        setError(error.message || error)\n+┊  ┊41┊      })\n+┊  ┊42┊  }, [username, password])\n+┊  ┊43┊\n+┊  ┊44┊  return (\n+┊  ┊45┊    <SignForm>\n+┊  ┊46┊      <ActualForm>\n+┊  ┊47┊        <Legend>Sign in</Legend>\n+┊  ┊48┊        <Section style={{ width: '100%' }}>\n+┊  ┊49┊          <TextField\n+┊  ┊50┊            data-testid=\"username-input\"\n+┊  ┊51┊            label=\"Username\"\n+┊  ┊52┊            value={username}\n+┊  ┊53┊            onChange={onUsernameChange}\n+┊  ┊54┊            margin=\"normal\"\n+┊  ┊55┊            placeholder=\"Enter your username\"\n+┊  ┊56┊          />\n+┊  ┊57┊          <TextField\n+┊  ┊58┊            data-testid=\"password-input\"\n+┊  ┊59┊            label=\"Password\"\n+┊  ┊60┊            type=\"password\"\n+┊  ┊61┊            value={password}\n+┊  ┊62┊            onChange={onPasswordChange}\n+┊  ┊63┊            margin=\"normal\"\n+┊  ┊64┊            placeholder=\"Enter your password\"\n+┊  ┊65┊          />\n+┊  ┊66┊        </Section>\n+┊  ┊67┊        <Button\n+┊  ┊68┊          data-testid=\"sign-in-button\"\n+┊  ┊69┊          type=\"button\"\n+┊  ┊70┊          color=\"secondary\"\n+┊  ┊71┊          variant=\"contained\"\n+┊  ┊72┊          disabled={!maySignIn()}\n+┊  ┊73┊          onClick={handleSignIn}\n+┊  ┊74┊        >\n+┊  ┊75┊          Sign in\n+┊  ┊76┊        </Button>\n+┊  ┊77┊        <ErrorMessage data-testid=\"error-message\">{error}</ErrorMessage>\n+┊  ┊78┊      </ActualForm>\n+┊  ┊79┊    </SignForm>\n+┊  ┊80┊  )\n+┊  ┊81┊}\n```\n\n##### Added src&#x2F;components&#x2F;AuthScreen&#x2F;SignUpForm.test.tsx\n```diff\n@@ -0,0 +1,99 @@\n+┊  ┊ 1┊import { createMemoryHistory } from 'history'\n+┊  ┊ 2┊import React from 'react'\n+┊  ┊ 3┊import { cleanup, render, fireEvent, wait, waitForElement } from 'react-testing-library'\n+┊  ┊ 4┊import SignUpForm from './SignUpForm'\n+┊  ┊ 5┊\n+┊  ┊ 6┊describe('SignUpForm', () => {\n+┊  ┊ 7┊  afterEach(cleanup)\n+┊  ┊ 8┊  afterEach(() => fetch.resetMocks())\n+┊  ┊ 9┊\n+┊  ┊10┊  it('enables sign-up button when filled in', async () => {\n+┊  ┊11┊    const history = createMemoryHistory()\n+┊  ┊12┊\n+┊  ┊13┊    {\n+┊  ┊14┊      const { container, getByTestId } = render(<SignUpForm history={history} />)\n+┊  ┊15┊      const nameInput = getByTestId('name-input').querySelector('input')\n+┊  ┊16┊      const usernameInput = getByTestId('username-input').querySelector('input')\n+┊  ┊17┊      const passwordInput = getByTestId('password-input').querySelector('input')\n+┊  ┊18┊      const passwordConfirmInput = getByTestId('password-confirm-input').querySelector('input')\n+┊  ┊19┊      const signUpButton = getByTestId('sign-up-button') as HTMLButtonElement\n+┊  ┊20┊\n+┊  ┊21┊      expect(signUpButton.disabled).toEqual(true)\n+┊  ┊22┊\n+┊  ┊23┊      fireEvent.change(nameInput, { target: { value: 'User Name' } })\n+┊  ┊24┊      fireEvent.change(usernameInput, { target: { value: 'username' } })\n+┊  ┊25┊      fireEvent.change(passwordInput, { target: { value: 'password' } })\n+┊  ┊26┊      fireEvent.change(passwordConfirmInput, { target: { value: 'password' } })\n+┊  ┊27┊\n+┊  ┊28┊      await waitForElement(() => nameInput)\n+┊  ┊29┊      await waitForElement(() => usernameInput)\n+┊  ┊30┊      await waitForElement(() => passwordInput)\n+┊  ┊31┊      await waitForElement(() => passwordConfirmInput)\n+┊  ┊32┊\n+┊  ┊33┊      expect(signUpButton.disabled).toEqual(false)\n+┊  ┊34┊    }\n+┊  ┊35┊  })\n+┊  ┊36┊\n+┊  ┊37┊  it('prints server error if input was wrong', async () => {\n+┊  ┊38┊    const history = createMemoryHistory()\n+┊  ┊39┊\n+┊  ┊40┊    fetchMock.mockRejectOnce(new Error('sign-up failed'))\n+┊  ┊41┊\n+┊  ┊42┊    {\n+┊  ┊43┊      const { container, getByTestId } = render(<SignUpForm history={history} />)\n+┊  ┊44┊      const nameInput = getByTestId('name-input').querySelector('input')\n+┊  ┊45┊      const usernameInput = getByTestId('username-input').querySelector('input')\n+┊  ┊46┊      const passwordInput = getByTestId('password-input').querySelector('input')\n+┊  ┊47┊      const passwordConfirmInput = getByTestId('password-confirm-input').querySelector('input')\n+┊  ┊48┊      const signUpButton = getByTestId('sign-up-button') as HTMLButtonElement\n+┊  ┊49┊      const errorMessage = getByTestId('error-message')\n+┊  ┊50┊\n+┊  ┊51┊      fireEvent.change(nameInput, { target: { value: 'User Name' } })\n+┊  ┊52┊      fireEvent.change(usernameInput, { target: { value: 'username' } })\n+┊  ┊53┊      fireEvent.change(passwordInput, { target: { value: 'password' } })\n+┊  ┊54┊      fireEvent.change(passwordConfirmInput, { target: { value: 'password' } })\n+┊  ┊55┊\n+┊  ┊56┊      await waitForElement(() => nameInput)\n+┊  ┊57┊      await waitForElement(() => usernameInput)\n+┊  ┊58┊      await waitForElement(() => passwordInput)\n+┊  ┊59┊      await waitForElement(() => passwordConfirmInput)\n+┊  ┊60┊\n+┊  ┊61┊      fireEvent.click(signUpButton)\n+┊  ┊62┊\n+┊  ┊63┊      await waitForElement(() => errorMessage)\n+┊  ┊64┊\n+┊  ┊65┊      expect(errorMessage.innerHTML).toEqual('sign-up failed')\n+┊  ┊66┊    }\n+┊  ┊67┊  })\n+┊  ┊68┊\n+┊  ┊69┊  it('navigates to /sign-in if everything went right', async () => {\n+┊  ┊70┊    const history = createMemoryHistory()\n+┊  ┊71┊\n+┊  ┊72┊    fetchMock.mockResponseOnce('success')\n+┊  ┊73┊\n+┊  ┊74┊    {\n+┊  ┊75┊      const { container, getByTestId } = render(<SignUpForm history={history} />)\n+┊  ┊76┊      const nameInput = getByTestId('name-input').querySelector('input')\n+┊  ┊77┊      const usernameInput = getByTestId('username-input').querySelector('input')\n+┊  ┊78┊      const passwordInput = getByTestId('password-input').querySelector('input')\n+┊  ┊79┊      const passwordConfirmInput = getByTestId('password-confirm-input').querySelector('input')\n+┊  ┊80┊      const signUpButton = getByTestId('sign-up-button') as HTMLButtonElement\n+┊  ┊81┊\n+┊  ┊82┊      fireEvent.change(nameInput, { target: { value: 'User Name' } })\n+┊  ┊83┊      fireEvent.change(usernameInput, { target: { value: 'username' } })\n+┊  ┊84┊      fireEvent.change(passwordInput, { target: { value: 'password' } })\n+┊  ┊85┊      fireEvent.change(passwordConfirmInput, { target: { value: 'password' } })\n+┊  ┊86┊\n+┊  ┊87┊      await waitForElement(() => nameInput)\n+┊  ┊88┊      await waitForElement(() => usernameInput)\n+┊  ┊89┊      await waitForElement(() => passwordInput)\n+┊  ┊90┊      await waitForElement(() => passwordConfirmInput)\n+┊  ┊91┊\n+┊  ┊92┊      fireEvent.click(signUpButton)\n+┊  ┊93┊\n+┊  ┊94┊      await wait(() =>\n+┊  ┊95┊        expect(history.location.pathname).toEqual('/sign-in')\n+┊  ┊96┊      )\n+┊  ┊97┊    }\n+┊  ┊98┊  })\n+┊  ┊99┊})\n```\n\n##### Added src&#x2F;components&#x2F;AuthScreen&#x2F;SignUpForm.tsx\n```diff\n@@ -0,0 +1,123 @@\n+┊   ┊  1┊import * as React from 'react'\n+┊   ┊  2┊import { useCallback, useState } from 'react'\n+┊   ┊  3┊import { signUp } from '../../services/auth.service'\n+┊   ┊  4┊import {\n+┊   ┊  5┊  SignForm,\n+┊   ┊  6┊  ActualForm,\n+┊   ┊  7┊  Legend,\n+┊   ┊  8┊  Section,\n+┊   ┊  9┊  TextField,\n+┊   ┊ 10┊  Button,\n+┊   ┊ 11┊  ErrorMessage,\n+┊   ┊ 12┊} from './form-components'\n+┊   ┊ 13┊\n+┊   ┊ 14┊export default ({ history }) => {\n+┊   ┊ 15┊  const [name, setName] = useState('')\n+┊   ┊ 16┊  const [username, setUsername] = useState('')\n+┊   ┊ 17┊  const [password, setPassword] = useState('')\n+┊   ┊ 18┊  const [passwordConfirm, setPasswordConfirm] = useState('')\n+┊   ┊ 19┊  const [error, setError] = useState('')\n+┊   ┊ 20┊\n+┊   ┊ 21┊  const updateName = useCallback(({ target }) => {\n+┊   ┊ 22┊    setError('')\n+┊   ┊ 23┊    setName(target.value)\n+┊   ┊ 24┊  }, [true])\n+┊   ┊ 25┊\n+┊   ┊ 26┊  const updateUsername = useCallback(({ target }) => {\n+┊   ┊ 27┊    setError('')\n+┊   ┊ 28┊    setUsername(target.value)\n+┊   ┊ 29┊  }, [true])\n+┊   ┊ 30┊\n+┊   ┊ 31┊  const updatePassword = useCallback(({ target }) => {\n+┊   ┊ 32┊    setError('')\n+┊   ┊ 33┊    setPassword(target.value)\n+┊   ┊ 34┊  }, [true])\n+┊   ┊ 35┊\n+┊   ┊ 36┊  const updatePasswordConfirm = useCallback(({ target }) => {\n+┊   ┊ 37┊    setError('')\n+┊   ┊ 38┊    setPasswordConfirm(target.value)\n+┊   ┊ 39┊  }, [true])\n+┊   ┊ 40┊\n+┊   ┊ 41┊  const maySignUp = useCallback(() => {\n+┊   ┊ 42┊    return !!(name && username && password && password === passwordConfirm)\n+┊   ┊ 43┊  }, [name, username, password, passwordConfirm])\n+┊   ┊ 44┊\n+┊   ┊ 45┊  const handleSignUp = useCallback(() => {\n+┊   ┊ 46┊    signUp({ username, password, passwordConfirm, name })\n+┊   ┊ 47┊      .then(() => {\n+┊   ┊ 48┊        history.replace('/sign-in')\n+┊   ┊ 49┊      })\n+┊   ┊ 50┊      .catch(error => {\n+┊   ┊ 51┊        setError(error.message || error)\n+┊   ┊ 52┊      })\n+┊   ┊ 53┊  }, [name, username, password, passwordConfirm])\n+┊   ┊ 54┊\n+┊   ┊ 55┊  return (\n+┊   ┊ 56┊    <SignForm>\n+┊   ┊ 57┊      <ActualForm>\n+┊   ┊ 58┊        <Legend>Sign up</Legend>\n+┊   ┊ 59┊        <Section\n+┊   ┊ 60┊          style={{\n+┊   ┊ 61┊            float: 'left',\n+┊   ┊ 62┊            width: 'calc(50% - 10px)',\n+┊   ┊ 63┊            paddingRight: '10px',\n+┊   ┊ 64┊          }}\n+┊   ┊ 65┊        >\n+┊   ┊ 66┊          <TextField\n+┊   ┊ 67┊            data-testid=\"name-input\"\n+┊   ┊ 68┊            label=\"Name\"\n+┊   ┊ 69┊            value={name}\n+┊   ┊ 70┊            onChange={updateName}\n+┊   ┊ 71┊            autoComplete=\"off\"\n+┊   ┊ 72┊            margin=\"normal\"\n+┊   ┊ 73┊          />\n+┊   ┊ 74┊          <TextField\n+┊   ┊ 75┊            data-testid=\"username-input\"\n+┊   ┊ 76┊            label=\"Username\"\n+┊   ┊ 77┊            value={username}\n+┊   ┊ 78┊            onChange={updateUsername}\n+┊   ┊ 79┊            autoComplete=\"off\"\n+┊   ┊ 80┊            margin=\"normal\"\n+┊   ┊ 81┊          />\n+┊   ┊ 82┊        </Section>\n+┊   ┊ 83┊        <Section\n+┊   ┊ 84┊          style={{\n+┊   ┊ 85┊            float: 'right',\n+┊   ┊ 86┊            width: 'calc(50% - 10px)',\n+┊   ┊ 87┊            paddingLeft: '10px',\n+┊   ┊ 88┊          }}\n+┊   ┊ 89┊        >\n+┊   ┊ 90┊          <TextField\n+┊   ┊ 91┊            data-testid=\"password-input\"\n+┊   ┊ 92┊            label=\"Password\"\n+┊   ┊ 93┊            type=\"password\"\n+┊   ┊ 94┊            value={password}\n+┊   ┊ 95┊            onChange={updatePassword}\n+┊   ┊ 96┊            autoComplete=\"off\"\n+┊   ┊ 97┊            margin=\"normal\"\n+┊   ┊ 98┊          />\n+┊   ┊ 99┊          <TextField\n+┊   ┊100┊            data-testid=\"password-confirm-input\"\n+┊   ┊101┊            label=\"Confirm password\"\n+┊   ┊102┊            type=\"password\"\n+┊   ┊103┊            value={passwordConfirm}\n+┊   ┊104┊            onChange={updatePasswordConfirm}\n+┊   ┊105┊            autoComplete=\"off\"\n+┊   ┊106┊            margin=\"normal\"\n+┊   ┊107┊          />\n+┊   ┊108┊        </Section>\n+┊   ┊109┊        <Button\n+┊   ┊110┊          data-testid=\"sign-up-button\"\n+┊   ┊111┊          type=\"button\"\n+┊   ┊112┊          color=\"secondary\"\n+┊   ┊113┊          variant=\"contained\"\n+┊   ┊114┊          disabled={!maySignUp()}\n+┊   ┊115┊          onClick={handleSignUp}\n+┊   ┊116┊        >\n+┊   ┊117┊          Sign up\n+┊   ┊118┊        </Button>\n+┊   ┊119┊        <ErrorMessage data-testid=\"error-message\">{error}</ErrorMessage>\n+┊   ┊120┊      </ActualForm>\n+┊   ┊121┊    </SignForm>\n+┊   ┊122┊  )\n+┊   ┊123┊}\n```\n\n##### Added src&#x2F;components&#x2F;AuthScreen&#x2F;form-components.ts\n```diff\n@@ -0,0 +1,75 @@\n+┊  ┊ 1┊import MaterialButton from '@material-ui/core/Button'\n+┊  ┊ 2┊import MaterialTextField from '@material-ui/core/TextField'\n+┊  ┊ 3┊import styled from 'styled-components'\n+┊  ┊ 4┊\n+┊  ┊ 5┊export const SignForm = styled.div `\n+┊  ┊ 6┊  height: calc(100% - 265px);\n+┊  ┊ 7┊`\n+┊  ┊ 8┊\n+┊  ┊ 9┊export const ActualForm = styled.form `\n+┊  ┊10┊  padding: 20px;\n+┊  ┊11┊`\n+┊  ┊12┊\n+┊  ┊13┊export const Section = styled.div `\n+┊  ┊14┊  padding-bottom: 35px;\n+┊  ┊15┊`\n+┊  ┊16┊\n+┊  ┊17┊export const Legend = styled.legend `\n+┊  ┊18┊  font-weight: bold;\n+┊  ┊19┊  color: white;\n+┊  ┊20┊`\n+┊  ┊21┊\n+┊  ┊22┊export const Label = styled.label `\n+┊  ┊23┊  color: white !important;\n+┊  ┊24┊`\n+┊  ┊25┊\n+┊  ┊26┊export const Input = styled.input `\n+┊  ┊27┊  color: white;\n+┊  ┊28┊\n+┊  ┊29┊  &::placeholder {\n+┊  ┊30┊    color: var(--primary-bg);\n+┊  ┊31┊  }\n+┊  ┊32┊`\n+┊  ┊33┊\n+┊  ┊34┊export const TextField = styled(MaterialTextField) `\n+┊  ┊35┊  width: 100%;\n+┊  ┊36┊  position: relative;\n+┊  ┊37┊\n+┊  ┊38┊  > div::before {\n+┊  ┊39┊    border-color: white !important;\n+┊  ┊40┊  }\n+┊  ┊41┊\n+┊  ┊42┊  input {\n+┊  ┊43┊    color: white !important;\n+┊  ┊44┊\n+┊  ┊45┊    &::placeholder {\n+┊  ┊46┊      color: var(--primary-bg) !important;\n+┊  ┊47┊    }\n+┊  ┊48┊  }\n+┊  ┊49┊\n+┊  ┊50┊  label {\n+┊  ┊51┊    color: white !important;\n+┊  ┊52┊  }\n+┊  ┊53┊`\n+┊  ┊54┊\n+┊  ┊55┊export const Button = styled(MaterialButton) `\n+┊  ┊56┊  width: 100px;\n+┊  ┊57┊  display: block !important;\n+┊  ┊58┊  margin: auto !important;\n+┊  ┊59┊  background-color: var(--secondary-bg) !important;\n+┊  ┊60┊\n+┊  ┊61┊  &[disabled] {\n+┊  ┊62┊    color: #38a81c;\n+┊  ┊63┊  }\n+┊  ┊64┊\n+┊  ┊65┊  &:not([disabled]) {\n+┊  ┊66┊    color: white;\n+┊  ┊67┊  }\n+┊  ┊68┊`\n+┊  ┊69┊\n+┊  ┊70┊export const ErrorMessage = styled.div `\n+┊  ┊71┊  position: fixed;\n+┊  ┊72┊  color: red;\n+┊  ┊73┊  font-size: 15px;\n+┊  ┊74┊  margin-top: 20px;\n+┊  ┊75┊`\n```\n\n##### Changed src&#x2F;components&#x2F;AuthScreen&#x2F;index.tsx\n```diff\n@@ -1,12 +1,12 @@\n-┊ 1┊  ┊import MaterialButton from '@material-ui/core/Button'\n-┊ 2┊  ┊import MaterialTextField from '@material-ui/core/TextField'\n ┊ 3┊ 1┊import * as React from 'react'\n-┊ 4┊  ┊import { useCallback, useMemo, useState } from 'react'\n+┊  ┊ 2┊import { useMemo } from 'react'\n+┊  ┊ 3┊import { Route } from 'react-router-dom'\n ┊ 5┊ 4┊import styled from 'styled-components'\n-┊ 6┊  ┊import { signIn } from '../../services/auth.service'\n+┊  ┊ 5┊import AnimatedSwitch from '../AnimatedSwitch'\n+┊  ┊ 6┊import SignInForm from './SignInForm'\n+┊  ┊ 7┊import SignUpForm from './SignUpForm'\n ┊ 7┊ 8┊\n ┊ 8┊ 9┊const Container = styled.div `\n-┊ 9┊  ┊  height: 100%;\n ┊10┊10┊  background: radial-gradient(rgb(34, 65, 67), rgb(17, 48, 50)),\n ┊11┊11┊    url(/assets/chat-background.jpg) no-repeat;\n ┊12┊12┊  background-size: cover;\n```\n```diff\n@@ -43,141 +43,43 @@\n ┊ 43┊ 43┊  }\n ┊ 44┊ 44┊`\n ┊ 45┊ 45┊\n-┊ 46┊   ┊const SignInForm = styled.div `\n-┊ 47┊   ┊  height: calc(100% - 265px);\n-┊ 48┊   ┊`\n-┊ 49┊   ┊\n-┊ 50┊   ┊const ActualForm = styled.form `\n-┊ 51┊   ┊  padding: 20px;\n-┊ 52┊   ┊`\n-┊ 53┊   ┊\n-┊ 54┊   ┊const Section = styled.div `\n-┊ 55┊   ┊  width: 100%;\n-┊ 56┊   ┊  padding-bottom: 35px;\n-┊ 57┊   ┊`\n-┊ 58┊   ┊\n-┊ 59┊   ┊const Legend = styled.legend `\n-┊ 60┊   ┊  font-weight: bold;\n-┊ 61┊   ┊  color: white;\n-┊ 62┊   ┊`\n-┊ 63┊   ┊\n-┊ 64┊   ┊const Label = styled.label `\n-┊ 65┊   ┊  color: white !important;\n-┊ 66┊   ┊`\n-┊ 67┊   ┊\n-┊ 68┊   ┊const Input = styled.input `\n-┊ 69┊   ┊  color: white;\n-┊ 70┊   ┊\n-┊ 71┊   ┊  &::placeholder {\n-┊ 72┊   ┊    color: var(--primary-bg);\n-┊ 73┊   ┊  }\n-┊ 74┊   ┊`\n-┊ 75┊   ┊\n-┊ 76┊   ┊const TextField = styled(MaterialTextField) `\n-┊ 77┊   ┊  width: 100%;\n-┊ 78┊   ┊  position: relative;\n-┊ 79┊   ┊\n-┊ 80┊   ┊  > div::before {\n-┊ 81┊   ┊    border-color: white !important;\n-┊ 82┊   ┊  }\n-┊ 83┊   ┊\n-┊ 84┊   ┊  input {\n-┊ 85┊   ┊    color: white !important;\n-┊ 86┊   ┊\n-┊ 87┊   ┊    &::placeholder {\n-┊ 88┊   ┊      color: var(--primary-bg) !important;\n+┊   ┊ 46┊export default ({ history, location }) => {\n+┊   ┊ 47┊  const alternative = useMemo(() => {\n+┊   ┊ 48┊    if (location.pathname === '/sign-in') {\n+┊   ┊ 49┊      const handleSignUp = () => {\n+┊   ┊ 50┊        history.replace('/sign-up')\n+┊   ┊ 51┊      }\n+┊   ┊ 52┊\n+┊   ┊ 53┊      return (\n+┊   ┊ 54┊        <Alternative>\n+┊   ┊ 55┊          Don't have an account yet? <a onClick={handleSignUp}>Sign up!</a>\n+┊   ┊ 56┊        </Alternative>\n+┊   ┊ 57┊      )\n ┊ 89┊ 58┊    }\n-┊ 90┊   ┊  }\n-┊ 91┊   ┊\n-┊ 92┊   ┊  label {\n-┊ 93┊   ┊    color: white !important;\n-┊ 94┊   ┊  }\n-┊ 95┊   ┊`\n-┊ 96┊   ┊\n-┊ 97┊   ┊const Button = styled(MaterialButton) `\n-┊ 98┊   ┊  width: 100px;\n-┊ 99┊   ┊  display: block !important;\n-┊100┊   ┊  margin: auto !important;\n-┊101┊   ┊  background-color: var(--secondary-bg) !important;\n-┊102┊   ┊\n-┊103┊   ┊  &[disabled] {\n-┊104┊   ┊    color: #38a81c;\n-┊105┊   ┊  }\n-┊106┊   ┊\n-┊107┊   ┊  &:not([disabled]) {\n-┊108┊   ┊    color: white;\n-┊109┊   ┊  }\n-┊110┊   ┊`\n-┊111┊   ┊\n-┊112┊   ┊export default ({ history }) => {\n-┊113┊   ┊  const [username, setUsername] = useState('')\n-┊114┊   ┊  const [password, setPassword] = useState('')\n-┊115┊   ┊  const [error, setError] = useState('')\n-┊116┊   ┊\n-┊117┊   ┊  const onUsernameChange = useCallback(({ target }) => {\n-┊118┊   ┊    setError('')\n-┊119┊   ┊    setUsername(target.value)\n-┊120┊   ┊  }, [true])\n-┊121┊   ┊\n-┊122┊   ┊  const onPasswordChange = useCallback(({ target }) => {\n-┊123┊   ┊    setError('')\n-┊124┊   ┊    setPassword(target.value)\n-┊125┊   ┊  }, [true])\n-┊126┊   ┊\n-┊127┊   ┊  const maySignIn = useCallback(() => {\n-┊128┊   ┊    return !!(username && password)\n-┊129┊   ┊  }, [username, password])\n-┊130┊   ┊\n-┊131┊   ┊  const handleSignIn = useCallback(() => {\n-┊132┊   ┊    signIn({ username, password })\n-┊133┊   ┊      .then(() => {\n-┊134┊   ┊        history.push('/chats')\n-┊135┊   ┊      })\n-┊136┊   ┊      .catch(error => {\n-┊137┊   ┊        setError(error.message || error)\n-┊138┊   ┊      })\n-┊139┊   ┊  }, [username, password])\n+┊   ┊ 59┊    else {\n+┊   ┊ 60┊      const handleSignIn = () => {\n+┊   ┊ 61┊        history.replace('/sign-in')\n+┊   ┊ 62┊      }\n+┊   ┊ 63┊\n+┊   ┊ 64┊      return (\n+┊   ┊ 65┊        <Alternative>\n+┊   ┊ 66┊          Already have an accout? <a onClick={handleSignIn}>Sign in!</a>\n+┊   ┊ 67┊        </Alternative>\n+┊   ┊ 68┊      )\n+┊   ┊ 69┊    }\n+┊   ┊ 70┊  }, [location.pathname])\n ┊140┊ 71┊\n ┊141┊ 72┊  return (\n-┊142┊   ┊    <Container>\n-┊143┊   ┊      <Intro>\n+┊   ┊ 73┊    <Container className=\"AuthScreen Screen\">\n+┊   ┊ 74┊      <Intro className=\"AuthScreen-intro\">\n ┊144┊ 75┊        <Icon src=\"assets/whatsapp-icon.png\" className=\"AuthScreen-icon\" />\n ┊145┊ 76┊        <Title className=\"AuthScreen-title\">WhatsApp</Title>\n ┊146┊ 77┊      </Intro>\n-┊147┊   ┊      <SignInForm>\n-┊148┊   ┊        <ActualForm>\n-┊149┊   ┊          <Legend>Sign in</Legend>\n-┊150┊   ┊          <Section>\n-┊151┊   ┊            <TextField\n-┊152┊   ┊              className=\"AuthScreen-text-field\"\n-┊153┊   ┊              label=\"Username\"\n-┊154┊   ┊              value={username}\n-┊155┊   ┊              onChange={onUsernameChange}\n-┊156┊   ┊              margin=\"normal\"\n-┊157┊   ┊              placeholder=\"Enter your username\"\n-┊158┊   ┊            />\n-┊159┊   ┊            <TextField\n-┊160┊   ┊              className=\"AuthScreen-text-field\"\n-┊161┊   ┊              label=\"Password\"\n-┊162┊   ┊              type=\"password\"\n-┊163┊   ┊              value={password}\n-┊164┊   ┊              onChange={onPasswordChange}\n-┊165┊   ┊              margin=\"normal\"\n-┊166┊   ┊              placeholder=\"Enter your password\"\n-┊167┊   ┊            />\n-┊168┊   ┊          </Section>\n-┊169┊   ┊          <Button\n-┊170┊   ┊            data-testid=\"sign-in-button\"\n-┊171┊   ┊            type=\"button\"\n-┊172┊   ┊            color=\"secondary\"\n-┊173┊   ┊            variant=\"contained\"\n-┊174┊   ┊            disabled={!maySignIn()}\n-┊175┊   ┊            onClick={handleSignIn}\n-┊176┊   ┊          >\n-┊177┊   ┊            Sign in\n-┊178┊   ┊          </Button>\n-┊179┊   ┊        </ActualForm>\n-┊180┊   ┊      </SignInForm>\n+┊   ┊ 78┊      <AnimatedSwitch>\n+┊   ┊ 79┊        <Route exact path=\"/sign-in\" component={SignInForm} />\n+┊   ┊ 80┊        <Route exact path=\"/sign-up\" component={SignUpForm} />\n+┊   ┊ 81┊      </AnimatedSwitch>\n+┊   ┊ 82┊      {alternative}\n ┊181┊ 83┊    </Container>\n ┊182┊ 84┊  )\n ┊183┊ 85┊}\n```\n\n[}]: #\n\nAnd then we will make the necessary changes in the `AuthScreen`:\n\n[{]: <helper> (diffStep 13.6 module=\"client\")\n\n#### [Step 13.6: Split AuthScreen into SignInForm and SignUpForm](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/04dbb89)\n\n##### Added src&#x2F;components&#x2F;AuthScreen&#x2F;SignInForm.test.tsx\n```diff\n@@ -0,0 +1,81 @@\n+┊  ┊ 1┊import { createMemoryHistory } from 'history'\n+┊  ┊ 2┊import React from 'react'\n+┊  ┊ 3┊import { cleanup, render, fireEvent, wait, waitForElement } from 'react-testing-library'\n+┊  ┊ 4┊import SignInForm from './SignInForm'\n+┊  ┊ 5┊\n+┊  ┊ 6┊describe('SignInForm', () => {\n+┊  ┊ 7┊  afterEach(cleanup)\n+┊  ┊ 8┊  afterEach(() => fetch.resetMocks())\n+┊  ┊ 9┊\n+┊  ┊10┊  it('enables sign-in button when filled in', async () => {\n+┊  ┊11┊    const history = createMemoryHistory()\n+┊  ┊12┊\n+┊  ┊13┊    {\n+┊  ┊14┊      const { container, getByTestId } = render(<SignInForm history={history} />)\n+┊  ┊15┊      const usernameInput = getByTestId('username-input').querySelector('input')\n+┊  ┊16┊      const passwordInput = getByTestId('password-input').querySelector('input')\n+┊  ┊17┊      const signInButton = getByTestId('sign-in-button') as HTMLButtonElement\n+┊  ┊18┊\n+┊  ┊19┊      expect(signInButton.disabled).toEqual(true)\n+┊  ┊20┊\n+┊  ┊21┊      fireEvent.change(usernameInput, { target: { value: 'username' } })\n+┊  ┊22┊      fireEvent.change(passwordInput, { target: { value: 'password' } })\n+┊  ┊23┊\n+┊  ┊24┊      await waitForElement(() => usernameInput)\n+┊  ┊25┊      await waitForElement(() => passwordInput)\n+┊  ┊26┊\n+┊  ┊27┊      expect(signInButton.disabled).toEqual(false)\n+┊  ┊28┊    }\n+┊  ┊29┊  })\n+┊  ┊30┊\n+┊  ┊31┊  it('prints server error if input was wrong', async () => {\n+┊  ┊32┊    const history = createMemoryHistory()\n+┊  ┊33┊\n+┊  ┊34┊    fetchMock.mockRejectOnce(new Error('sign-in failed'))\n+┊  ┊35┊\n+┊  ┊36┊    {\n+┊  ┊37┊      const { container, getByTestId } = render(<SignInForm history={history} />)\n+┊  ┊38┊      const usernameInput = getByTestId('username-input').querySelector('input')\n+┊  ┊39┊      const passwordInput = getByTestId('password-input').querySelector('input')\n+┊  ┊40┊      const signInButton = getByTestId('sign-in-button') as HTMLButtonElement\n+┊  ┊41┊      const errorMessage = getByTestId('error-message')\n+┊  ┊42┊\n+┊  ┊43┊      fireEvent.change(usernameInput, { target: { value: 'username' } })\n+┊  ┊44┊      fireEvent.change(passwordInput, { target: { value: 'password' } })\n+┊  ┊45┊\n+┊  ┊46┊      await waitForElement(() => usernameInput)\n+┊  ┊47┊      await waitForElement(() => passwordInput)\n+┊  ┊48┊\n+┊  ┊49┊      fireEvent.click(signInButton)\n+┊  ┊50┊\n+┊  ┊51┊      await waitForElement(() => errorMessage)\n+┊  ┊52┊\n+┊  ┊53┊      expect(errorMessage.innerHTML).toEqual('sign-in failed')\n+┊  ┊54┊    }\n+┊  ┊55┊  })\n+┊  ┊56┊\n+┊  ┊57┊  it('navigates to /chats if everything went right', async () => {\n+┊  ┊58┊    const history = createMemoryHistory()\n+┊  ┊59┊\n+┊  ┊60┊    fetchMock.mockResponseOnce('success')\n+┊  ┊61┊\n+┊  ┊62┊    {\n+┊  ┊63┊      const { container, getByTestId } = render(<SignInForm history={history} />)\n+┊  ┊64┊      const usernameInput = getByTestId('username-input').querySelector('input')\n+┊  ┊65┊      const passwordInput = getByTestId('password-input').querySelector('input')\n+┊  ┊66┊      const signInButton = getByTestId('sign-in-button') as HTMLButtonElement\n+┊  ┊67┊\n+┊  ┊68┊      fireEvent.change(usernameInput, { target: { value: 'username' } })\n+┊  ┊69┊      fireEvent.change(passwordInput, { target: { value: 'password' } })\n+┊  ┊70┊\n+┊  ┊71┊      await waitForElement(() => usernameInput)\n+┊  ┊72┊      await waitForElement(() => passwordInput)\n+┊  ┊73┊\n+┊  ┊74┊      fireEvent.click(signInButton)\n+┊  ┊75┊\n+┊  ┊76┊      await wait(() =>\n+┊  ┊77┊        expect(history.location.pathname).toEqual('/chats')\n+┊  ┊78┊      )\n+┊  ┊79┊    }\n+┊  ┊80┊  })\n+┊  ┊81┊})\n```\n\n##### Added src&#x2F;components&#x2F;AuthScreen&#x2F;SignInForm.tsx\n```diff\n@@ -0,0 +1,81 @@\n+┊  ┊ 1┊import { History } from 'history'\n+┊  ┊ 2┊import * as React from 'react'\n+┊  ┊ 3┊import { useCallback, useState } from 'react'\n+┊  ┊ 4┊import { signIn } from '../../services/auth.service'\n+┊  ┊ 5┊import {\n+┊  ┊ 6┊  SignForm,\n+┊  ┊ 7┊  ActualForm,\n+┊  ┊ 8┊  Legend,\n+┊  ┊ 9┊  Section,\n+┊  ┊10┊  TextField,\n+┊  ┊11┊  Button,\n+┊  ┊12┊  ErrorMessage,\n+┊  ┊13┊} from './form-components'\n+┊  ┊14┊\n+┊  ┊15┊export default ({ history }) => {\n+┊  ┊16┊  const [username, setUsername] = useState('')\n+┊  ┊17┊  const [password, setPassword] = useState('')\n+┊  ┊18┊  const [error, setError] = useState('')\n+┊  ┊19┊\n+┊  ┊20┊  const onUsernameChange = useCallback(({ target }) => {\n+┊  ┊21┊    setError('')\n+┊  ┊22┊    setUsername(target.value)\n+┊  ┊23┊  }, [true])\n+┊  ┊24┊\n+┊  ┊25┊  const onPasswordChange = useCallback(({ target }) => {\n+┊  ┊26┊    setError('')\n+┊  ┊27┊    setPassword(target.value)\n+┊  ┊28┊  }, [true])\n+┊  ┊29┊\n+┊  ┊30┊  const maySignIn = useCallback(() => {\n+┊  ┊31┊    return !!(username && password)\n+┊  ┊32┊  }, [username, password])\n+┊  ┊33┊\n+┊  ┊34┊  const handleSignIn = useCallback(() => {\n+┊  ┊35┊    signIn({ username, password })\n+┊  ┊36┊      .then(() => {\n+┊  ┊37┊        history.replace('/chats')\n+┊  ┊38┊      })\n+┊  ┊39┊      .catch(error => {\n+┊  ┊40┊        setError(error.message || error)\n+┊  ┊41┊      })\n+┊  ┊42┊  }, [username, password])\n+┊  ┊43┊\n+┊  ┊44┊  return (\n+┊  ┊45┊    <SignForm>\n+┊  ┊46┊      <ActualForm>\n+┊  ┊47┊        <Legend>Sign in</Legend>\n+┊  ┊48┊        <Section style={{ width: '100%' }}>\n+┊  ┊49┊          <TextField\n+┊  ┊50┊            data-testid=\"username-input\"\n+┊  ┊51┊            label=\"Username\"\n+┊  ┊52┊            value={username}\n+┊  ┊53┊            onChange={onUsernameChange}\n+┊  ┊54┊            margin=\"normal\"\n+┊  ┊55┊            placeholder=\"Enter your username\"\n+┊  ┊56┊          />\n+┊  ┊57┊          <TextField\n+┊  ┊58┊            data-testid=\"password-input\"\n+┊  ┊59┊            label=\"Password\"\n+┊  ┊60┊            type=\"password\"\n+┊  ┊61┊            value={password}\n+┊  ┊62┊            onChange={onPasswordChange}\n+┊  ┊63┊            margin=\"normal\"\n+┊  ┊64┊            placeholder=\"Enter your password\"\n+┊  ┊65┊          />\n+┊  ┊66┊        </Section>\n+┊  ┊67┊        <Button\n+┊  ┊68┊          data-testid=\"sign-in-button\"\n+┊  ┊69┊          type=\"button\"\n+┊  ┊70┊          color=\"secondary\"\n+┊  ┊71┊          variant=\"contained\"\n+┊  ┊72┊          disabled={!maySignIn()}\n+┊  ┊73┊          onClick={handleSignIn}\n+┊  ┊74┊        >\n+┊  ┊75┊          Sign in\n+┊  ┊76┊        </Button>\n+┊  ┊77┊        <ErrorMessage data-testid=\"error-message\">{error}</ErrorMessage>\n+┊  ┊78┊      </ActualForm>\n+┊  ┊79┊    </SignForm>\n+┊  ┊80┊  )\n+┊  ┊81┊}\n```\n\n##### Added src&#x2F;components&#x2F;AuthScreen&#x2F;SignUpForm.test.tsx\n```diff\n@@ -0,0 +1,99 @@\n+┊  ┊ 1┊import { createMemoryHistory } from 'history'\n+┊  ┊ 2┊import React from 'react'\n+┊  ┊ 3┊import { cleanup, render, fireEvent, wait, waitForElement } from 'react-testing-library'\n+┊  ┊ 4┊import SignUpForm from './SignUpForm'\n+┊  ┊ 5┊\n+┊  ┊ 6┊describe('SignUpForm', () => {\n+┊  ┊ 7┊  afterEach(cleanup)\n+┊  ┊ 8┊  afterEach(() => fetch.resetMocks())\n+┊  ┊ 9┊\n+┊  ┊10┊  it('enables sign-up button when filled in', async () => {\n+┊  ┊11┊    const history = createMemoryHistory()\n+┊  ┊12┊\n+┊  ┊13┊    {\n+┊  ┊14┊      const { container, getByTestId } = render(<SignUpForm history={history} />)\n+┊  ┊15┊      const nameInput = getByTestId('name-input').querySelector('input')\n+┊  ┊16┊      const usernameInput = getByTestId('username-input').querySelector('input')\n+┊  ┊17┊      const passwordInput = getByTestId('password-input').querySelector('input')\n+┊  ┊18┊      const passwordConfirmInput = getByTestId('password-confirm-input').querySelector('input')\n+┊  ┊19┊      const signUpButton = getByTestId('sign-up-button') as HTMLButtonElement\n+┊  ┊20┊\n+┊  ┊21┊      expect(signUpButton.disabled).toEqual(true)\n+┊  ┊22┊\n+┊  ┊23┊      fireEvent.change(nameInput, { target: { value: 'User Name' } })\n+┊  ┊24┊      fireEvent.change(usernameInput, { target: { value: 'username' } })\n+┊  ┊25┊      fireEvent.change(passwordInput, { target: { value: 'password' } })\n+┊  ┊26┊      fireEvent.change(passwordConfirmInput, { target: { value: 'password' } })\n+┊  ┊27┊\n+┊  ┊28┊      await waitForElement(() => nameInput)\n+┊  ┊29┊      await waitForElement(() => usernameInput)\n+┊  ┊30┊      await waitForElement(() => passwordInput)\n+┊  ┊31┊      await waitForElement(() => passwordConfirmInput)\n+┊  ┊32┊\n+┊  ┊33┊      expect(signUpButton.disabled).toEqual(false)\n+┊  ┊34┊    }\n+┊  ┊35┊  })\n+┊  ┊36┊\n+┊  ┊37┊  it('prints server error if input was wrong', async () => {\n+┊  ┊38┊    const history = createMemoryHistory()\n+┊  ┊39┊\n+┊  ┊40┊    fetchMock.mockRejectOnce(new Error('sign-up failed'))\n+┊  ┊41┊\n+┊  ┊42┊    {\n+┊  ┊43┊      const { container, getByTestId } = render(<SignUpForm history={history} />)\n+┊  ┊44┊      const nameInput = getByTestId('name-input').querySelector('input')\n+┊  ┊45┊      const usernameInput = getByTestId('username-input').querySelector('input')\n+┊  ┊46┊      const passwordInput = getByTestId('password-input').querySelector('input')\n+┊  ┊47┊      const passwordConfirmInput = getByTestId('password-confirm-input').querySelector('input')\n+┊  ┊48┊      const signUpButton = getByTestId('sign-up-button') as HTMLButtonElement\n+┊  ┊49┊      const errorMessage = getByTestId('error-message')\n+┊  ┊50┊\n+┊  ┊51┊      fireEvent.change(nameInput, { target: { value: 'User Name' } })\n+┊  ┊52┊      fireEvent.change(usernameInput, { target: { value: 'username' } })\n+┊  ┊53┊      fireEvent.change(passwordInput, { target: { value: 'password' } })\n+┊  ┊54┊      fireEvent.change(passwordConfirmInput, { target: { value: 'password' } })\n+┊  ┊55┊\n+┊  ┊56┊      await waitForElement(() => nameInput)\n+┊  ┊57┊      await waitForElement(() => usernameInput)\n+┊  ┊58┊      await waitForElement(() => passwordInput)\n+┊  ┊59┊      await waitForElement(() => passwordConfirmInput)\n+┊  ┊60┊\n+┊  ┊61┊      fireEvent.click(signUpButton)\n+┊  ┊62┊\n+┊  ┊63┊      await waitForElement(() => errorMessage)\n+┊  ┊64┊\n+┊  ┊65┊      expect(errorMessage.innerHTML).toEqual('sign-up failed')\n+┊  ┊66┊    }\n+┊  ┊67┊  })\n+┊  ┊68┊\n+┊  ┊69┊  it('navigates to /sign-in if everything went right', async () => {\n+┊  ┊70┊    const history = createMemoryHistory()\n+┊  ┊71┊\n+┊  ┊72┊    fetchMock.mockResponseOnce('success')\n+┊  ┊73┊\n+┊  ┊74┊    {\n+┊  ┊75┊      const { container, getByTestId } = render(<SignUpForm history={history} />)\n+┊  ┊76┊      const nameInput = getByTestId('name-input').querySelector('input')\n+┊  ┊77┊      const usernameInput = getByTestId('username-input').querySelector('input')\n+┊  ┊78┊      const passwordInput = getByTestId('password-input').querySelector('input')\n+┊  ┊79┊      const passwordConfirmInput = getByTestId('password-confirm-input').querySelector('input')\n+┊  ┊80┊      const signUpButton = getByTestId('sign-up-button') as HTMLButtonElement\n+┊  ┊81┊\n+┊  ┊82┊      fireEvent.change(nameInput, { target: { value: 'User Name' } })\n+┊  ┊83┊      fireEvent.change(usernameInput, { target: { value: 'username' } })\n+┊  ┊84┊      fireEvent.change(passwordInput, { target: { value: 'password' } })\n+┊  ┊85┊      fireEvent.change(passwordConfirmInput, { target: { value: 'password' } })\n+┊  ┊86┊\n+┊  ┊87┊      await waitForElement(() => nameInput)\n+┊  ┊88┊      await waitForElement(() => usernameInput)\n+┊  ┊89┊      await waitForElement(() => passwordInput)\n+┊  ┊90┊      await waitForElement(() => passwordConfirmInput)\n+┊  ┊91┊\n+┊  ┊92┊      fireEvent.click(signUpButton)\n+┊  ┊93┊\n+┊  ┊94┊      await wait(() =>\n+┊  ┊95┊        expect(history.location.pathname).toEqual('/sign-in')\n+┊  ┊96┊      )\n+┊  ┊97┊    }\n+┊  ┊98┊  })\n+┊  ┊99┊})\n```\n\n##### Added src&#x2F;components&#x2F;AuthScreen&#x2F;SignUpForm.tsx\n```diff\n@@ -0,0 +1,123 @@\n+┊   ┊  1┊import * as React from 'react'\n+┊   ┊  2┊import { useCallback, useState } from 'react'\n+┊   ┊  3┊import { signUp } from '../../services/auth.service'\n+┊   ┊  4┊import {\n+┊   ┊  5┊  SignForm,\n+┊   ┊  6┊  ActualForm,\n+┊   ┊  7┊  Legend,\n+┊   ┊  8┊  Section,\n+┊   ┊  9┊  TextField,\n+┊   ┊ 10┊  Button,\n+┊   ┊ 11┊  ErrorMessage,\n+┊   ┊ 12┊} from './form-components'\n+┊   ┊ 13┊\n+┊   ┊ 14┊export default ({ history }) => {\n+┊   ┊ 15┊  const [name, setName] = useState('')\n+┊   ┊ 16┊  const [username, setUsername] = useState('')\n+┊   ┊ 17┊  const [password, setPassword] = useState('')\n+┊   ┊ 18┊  const [passwordConfirm, setPasswordConfirm] = useState('')\n+┊   ┊ 19┊  const [error, setError] = useState('')\n+┊   ┊ 20┊\n+┊   ┊ 21┊  const updateName = useCallback(({ target }) => {\n+┊   ┊ 22┊    setError('')\n+┊   ┊ 23┊    setName(target.value)\n+┊   ┊ 24┊  }, [true])\n+┊   ┊ 25┊\n+┊   ┊ 26┊  const updateUsername = useCallback(({ target }) => {\n+┊   ┊ 27┊    setError('')\n+┊   ┊ 28┊    setUsername(target.value)\n+┊   ┊ 29┊  }, [true])\n+┊   ┊ 30┊\n+┊   ┊ 31┊  const updatePassword = useCallback(({ target }) => {\n+┊   ┊ 32┊    setError('')\n+┊   ┊ 33┊    setPassword(target.value)\n+┊   ┊ 34┊  }, [true])\n+┊   ┊ 35┊\n+┊   ┊ 36┊  const updatePasswordConfirm = useCallback(({ target }) => {\n+┊   ┊ 37┊    setError('')\n+┊   ┊ 38┊    setPasswordConfirm(target.value)\n+┊   ┊ 39┊  }, [true])\n+┊   ┊ 40┊\n+┊   ┊ 41┊  const maySignUp = useCallback(() => {\n+┊   ┊ 42┊    return !!(name && username && password && password === passwordConfirm)\n+┊   ┊ 43┊  }, [name, username, password, passwordConfirm])\n+┊   ┊ 44┊\n+┊   ┊ 45┊  const handleSignUp = useCallback(() => {\n+┊   ┊ 46┊    signUp({ username, password, passwordConfirm, name })\n+┊   ┊ 47┊      .then(() => {\n+┊   ┊ 48┊        history.replace('/sign-in')\n+┊   ┊ 49┊      })\n+┊   ┊ 50┊      .catch(error => {\n+┊   ┊ 51┊        setError(error.message || error)\n+┊   ┊ 52┊      })\n+┊   ┊ 53┊  }, [name, username, password, passwordConfirm])\n+┊   ┊ 54┊\n+┊   ┊ 55┊  return (\n+┊   ┊ 56┊    <SignForm>\n+┊   ┊ 57┊      <ActualForm>\n+┊   ┊ 58┊        <Legend>Sign up</Legend>\n+┊   ┊ 59┊        <Section\n+┊   ┊ 60┊          style={{\n+┊   ┊ 61┊            float: 'left',\n+┊   ┊ 62┊            width: 'calc(50% - 10px)',\n+┊   ┊ 63┊            paddingRight: '10px',\n+┊   ┊ 64┊          }}\n+┊   ┊ 65┊        >\n+┊   ┊ 66┊          <TextField\n+┊   ┊ 67┊            data-testid=\"name-input\"\n+┊   ┊ 68┊            label=\"Name\"\n+┊   ┊ 69┊            value={name}\n+┊   ┊ 70┊            onChange={updateName}\n+┊   ┊ 71┊            autoComplete=\"off\"\n+┊   ┊ 72┊            margin=\"normal\"\n+┊   ┊ 73┊          />\n+┊   ┊ 74┊          <TextField\n+┊   ┊ 75┊            data-testid=\"username-input\"\n+┊   ┊ 76┊            label=\"Username\"\n+┊   ┊ 77┊            value={username}\n+┊   ┊ 78┊            onChange={updateUsername}\n+┊   ┊ 79┊            autoComplete=\"off\"\n+┊   ┊ 80┊            margin=\"normal\"\n+┊   ┊ 81┊          />\n+┊   ┊ 82┊        </Section>\n+┊   ┊ 83┊        <Section\n+┊   ┊ 84┊          style={{\n+┊   ┊ 85┊            float: 'right',\n+┊   ┊ 86┊            width: 'calc(50% - 10px)',\n+┊   ┊ 87┊            paddingLeft: '10px',\n+┊   ┊ 88┊          }}\n+┊   ┊ 89┊        >\n+┊   ┊ 90┊          <TextField\n+┊   ┊ 91┊            data-testid=\"password-input\"\n+┊   ┊ 92┊            label=\"Password\"\n+┊   ┊ 93┊            type=\"password\"\n+┊   ┊ 94┊            value={password}\n+┊   ┊ 95┊            onChange={updatePassword}\n+┊   ┊ 96┊            autoComplete=\"off\"\n+┊   ┊ 97┊            margin=\"normal\"\n+┊   ┊ 98┊          />\n+┊   ┊ 99┊          <TextField\n+┊   ┊100┊            data-testid=\"password-confirm-input\"\n+┊   ┊101┊            label=\"Confirm password\"\n+┊   ┊102┊            type=\"password\"\n+┊   ┊103┊            value={passwordConfirm}\n+┊   ┊104┊            onChange={updatePasswordConfirm}\n+┊   ┊105┊            autoComplete=\"off\"\n+┊   ┊106┊            margin=\"normal\"\n+┊   ┊107┊          />\n+┊   ┊108┊        </Section>\n+┊   ┊109┊        <Button\n+┊   ┊110┊          data-testid=\"sign-up-button\"\n+┊   ┊111┊          type=\"button\"\n+┊   ┊112┊          color=\"secondary\"\n+┊   ┊113┊          variant=\"contained\"\n+┊   ┊114┊          disabled={!maySignUp()}\n+┊   ┊115┊          onClick={handleSignUp}\n+┊   ┊116┊        >\n+┊   ┊117┊          Sign up\n+┊   ┊118┊        </Button>\n+┊   ┊119┊        <ErrorMessage data-testid=\"error-message\">{error}</ErrorMessage>\n+┊   ┊120┊      </ActualForm>\n+┊   ┊121┊    </SignForm>\n+┊   ┊122┊  )\n+┊   ┊123┊}\n```\n\n##### Added src&#x2F;components&#x2F;AuthScreen&#x2F;form-components.ts\n```diff\n@@ -0,0 +1,75 @@\n+┊  ┊ 1┊import MaterialButton from '@material-ui/core/Button'\n+┊  ┊ 2┊import MaterialTextField from '@material-ui/core/TextField'\n+┊  ┊ 3┊import styled from 'styled-components'\n+┊  ┊ 4┊\n+┊  ┊ 5┊export const SignForm = styled.div `\n+┊  ┊ 6┊  height: calc(100% - 265px);\n+┊  ┊ 7┊`\n+┊  ┊ 8┊\n+┊  ┊ 9┊export const ActualForm = styled.form `\n+┊  ┊10┊  padding: 20px;\n+┊  ┊11┊`\n+┊  ┊12┊\n+┊  ┊13┊export const Section = styled.div `\n+┊  ┊14┊  padding-bottom: 35px;\n+┊  ┊15┊`\n+┊  ┊16┊\n+┊  ┊17┊export const Legend = styled.legend `\n+┊  ┊18┊  font-weight: bold;\n+┊  ┊19┊  color: white;\n+┊  ┊20┊`\n+┊  ┊21┊\n+┊  ┊22┊export const Label = styled.label `\n+┊  ┊23┊  color: white !important;\n+┊  ┊24┊`\n+┊  ┊25┊\n+┊  ┊26┊export const Input = styled.input `\n+┊  ┊27┊  color: white;\n+┊  ┊28┊\n+┊  ┊29┊  &::placeholder {\n+┊  ┊30┊    color: var(--primary-bg);\n+┊  ┊31┊  }\n+┊  ┊32┊`\n+┊  ┊33┊\n+┊  ┊34┊export const TextField = styled(MaterialTextField) `\n+┊  ┊35┊  width: 100%;\n+┊  ┊36┊  position: relative;\n+┊  ┊37┊\n+┊  ┊38┊  > div::before {\n+┊  ┊39┊    border-color: white !important;\n+┊  ┊40┊  }\n+┊  ┊41┊\n+┊  ┊42┊  input {\n+┊  ┊43┊    color: white !important;\n+┊  ┊44┊\n+┊  ┊45┊    &::placeholder {\n+┊  ┊46┊      color: var(--primary-bg) !important;\n+┊  ┊47┊    }\n+┊  ┊48┊  }\n+┊  ┊49┊\n+┊  ┊50┊  label {\n+┊  ┊51┊    color: white !important;\n+┊  ┊52┊  }\n+┊  ┊53┊`\n+┊  ┊54┊\n+┊  ┊55┊export const Button = styled(MaterialButton) `\n+┊  ┊56┊  width: 100px;\n+┊  ┊57┊  display: block !important;\n+┊  ┊58┊  margin: auto !important;\n+┊  ┊59┊  background-color: var(--secondary-bg) !important;\n+┊  ┊60┊\n+┊  ┊61┊  &[disabled] {\n+┊  ┊62┊    color: #38a81c;\n+┊  ┊63┊  }\n+┊  ┊64┊\n+┊  ┊65┊  &:not([disabled]) {\n+┊  ┊66┊    color: white;\n+┊  ┊67┊  }\n+┊  ┊68┊`\n+┊  ┊69┊\n+┊  ┊70┊export const ErrorMessage = styled.div `\n+┊  ┊71┊  position: fixed;\n+┊  ┊72┊  color: red;\n+┊  ┊73┊  font-size: 15px;\n+┊  ┊74┊  margin-top: 20px;\n+┊  ┊75┊`\n```\n\n##### Changed src&#x2F;components&#x2F;AuthScreen&#x2F;index.tsx\n```diff\n@@ -1,12 +1,12 @@\n-┊ 1┊  ┊import MaterialButton from '@material-ui/core/Button'\n-┊ 2┊  ┊import MaterialTextField from '@material-ui/core/TextField'\n ┊ 3┊ 1┊import * as React from 'react'\n-┊ 4┊  ┊import { useCallback, useMemo, useState } from 'react'\n+┊  ┊ 2┊import { useMemo } from 'react'\n+┊  ┊ 3┊import { Route } from 'react-router-dom'\n ┊ 5┊ 4┊import styled from 'styled-components'\n-┊ 6┊  ┊import { signIn } from '../../services/auth.service'\n+┊  ┊ 5┊import AnimatedSwitch from '../AnimatedSwitch'\n+┊  ┊ 6┊import SignInForm from './SignInForm'\n+┊  ┊ 7┊import SignUpForm from './SignUpForm'\n ┊ 7┊ 8┊\n ┊ 8┊ 9┊const Container = styled.div `\n-┊ 9┊  ┊  height: 100%;\n ┊10┊10┊  background: radial-gradient(rgb(34, 65, 67), rgb(17, 48, 50)),\n ┊11┊11┊    url(/assets/chat-background.jpg) no-repeat;\n ┊12┊12┊  background-size: cover;\n```\n```diff\n@@ -43,141 +43,43 @@\n ┊ 43┊ 43┊  }\n ┊ 44┊ 44┊`\n ┊ 45┊ 45┊\n-┊ 46┊   ┊const SignInForm = styled.div `\n-┊ 47┊   ┊  height: calc(100% - 265px);\n-┊ 48┊   ┊`\n-┊ 49┊   ┊\n-┊ 50┊   ┊const ActualForm = styled.form `\n-┊ 51┊   ┊  padding: 20px;\n-┊ 52┊   ┊`\n-┊ 53┊   ┊\n-┊ 54┊   ┊const Section = styled.div `\n-┊ 55┊   ┊  width: 100%;\n-┊ 56┊   ┊  padding-bottom: 35px;\n-┊ 57┊   ┊`\n-┊ 58┊   ┊\n-┊ 59┊   ┊const Legend = styled.legend `\n-┊ 60┊   ┊  font-weight: bold;\n-┊ 61┊   ┊  color: white;\n-┊ 62┊   ┊`\n-┊ 63┊   ┊\n-┊ 64┊   ┊const Label = styled.label `\n-┊ 65┊   ┊  color: white !important;\n-┊ 66┊   ┊`\n-┊ 67┊   ┊\n-┊ 68┊   ┊const Input = styled.input `\n-┊ 69┊   ┊  color: white;\n-┊ 70┊   ┊\n-┊ 71┊   ┊  &::placeholder {\n-┊ 72┊   ┊    color: var(--primary-bg);\n-┊ 73┊   ┊  }\n-┊ 74┊   ┊`\n-┊ 75┊   ┊\n-┊ 76┊   ┊const TextField = styled(MaterialTextField) `\n-┊ 77┊   ┊  width: 100%;\n-┊ 78┊   ┊  position: relative;\n-┊ 79┊   ┊\n-┊ 80┊   ┊  > div::before {\n-┊ 81┊   ┊    border-color: white !important;\n-┊ 82┊   ┊  }\n-┊ 83┊   ┊\n-┊ 84┊   ┊  input {\n-┊ 85┊   ┊    color: white !important;\n-┊ 86┊   ┊\n-┊ 87┊   ┊    &::placeholder {\n-┊ 88┊   ┊      color: var(--primary-bg) !important;\n+┊   ┊ 46┊export default ({ history, location }) => {\n+┊   ┊ 47┊  const alternative = useMemo(() => {\n+┊   ┊ 48┊    if (location.pathname === '/sign-in') {\n+┊   ┊ 49┊      const handleSignUp = () => {\n+┊   ┊ 50┊        history.replace('/sign-up')\n+┊   ┊ 51┊      }\n+┊   ┊ 52┊\n+┊   ┊ 53┊      return (\n+┊   ┊ 54┊        <Alternative>\n+┊   ┊ 55┊          Don't have an account yet? <a onClick={handleSignUp}>Sign up!</a>\n+┊   ┊ 56┊        </Alternative>\n+┊   ┊ 57┊      )\n ┊ 89┊ 58┊    }\n-┊ 90┊   ┊  }\n-┊ 91┊   ┊\n-┊ 92┊   ┊  label {\n-┊ 93┊   ┊    color: white !important;\n-┊ 94┊   ┊  }\n-┊ 95┊   ┊`\n-┊ 96┊   ┊\n-┊ 97┊   ┊const Button = styled(MaterialButton) `\n-┊ 98┊   ┊  width: 100px;\n-┊ 99┊   ┊  display: block !important;\n-┊100┊   ┊  margin: auto !important;\n-┊101┊   ┊  background-color: var(--secondary-bg) !important;\n-┊102┊   ┊\n-┊103┊   ┊  &[disabled] {\n-┊104┊   ┊    color: #38a81c;\n-┊105┊   ┊  }\n-┊106┊   ┊\n-┊107┊   ┊  &:not([disabled]) {\n-┊108┊   ┊    color: white;\n-┊109┊   ┊  }\n-┊110┊   ┊`\n-┊111┊   ┊\n-┊112┊   ┊export default ({ history }) => {\n-┊113┊   ┊  const [username, setUsername] = useState('')\n-┊114┊   ┊  const [password, setPassword] = useState('')\n-┊115┊   ┊  const [error, setError] = useState('')\n-┊116┊   ┊\n-┊117┊   ┊  const onUsernameChange = useCallback(({ target }) => {\n-┊118┊   ┊    setError('')\n-┊119┊   ┊    setUsername(target.value)\n-┊120┊   ┊  }, [true])\n-┊121┊   ┊\n-┊122┊   ┊  const onPasswordChange = useCallback(({ target }) => {\n-┊123┊   ┊    setError('')\n-┊124┊   ┊    setPassword(target.value)\n-┊125┊   ┊  }, [true])\n-┊126┊   ┊\n-┊127┊   ┊  const maySignIn = useCallback(() => {\n-┊128┊   ┊    return !!(username && password)\n-┊129┊   ┊  }, [username, password])\n-┊130┊   ┊\n-┊131┊   ┊  const handleSignIn = useCallback(() => {\n-┊132┊   ┊    signIn({ username, password })\n-┊133┊   ┊      .then(() => {\n-┊134┊   ┊        history.push('/chats')\n-┊135┊   ┊      })\n-┊136┊   ┊      .catch(error => {\n-┊137┊   ┊        setError(error.message || error)\n-┊138┊   ┊      })\n-┊139┊   ┊  }, [username, password])\n+┊   ┊ 59┊    else {\n+┊   ┊ 60┊      const handleSignIn = () => {\n+┊   ┊ 61┊        history.replace('/sign-in')\n+┊   ┊ 62┊      }\n+┊   ┊ 63┊\n+┊   ┊ 64┊      return (\n+┊   ┊ 65┊        <Alternative>\n+┊   ┊ 66┊          Already have an accout? <a onClick={handleSignIn}>Sign in!</a>\n+┊   ┊ 67┊        </Alternative>\n+┊   ┊ 68┊      )\n+┊   ┊ 69┊    }\n+┊   ┊ 70┊  }, [location.pathname])\n ┊140┊ 71┊\n ┊141┊ 72┊  return (\n-┊142┊   ┊    <Container>\n-┊143┊   ┊      <Intro>\n+┊   ┊ 73┊    <Container className=\"AuthScreen Screen\">\n+┊   ┊ 74┊      <Intro className=\"AuthScreen-intro\">\n ┊144┊ 75┊        <Icon src=\"assets/whatsapp-icon.png\" className=\"AuthScreen-icon\" />\n ┊145┊ 76┊        <Title className=\"AuthScreen-title\">WhatsApp</Title>\n ┊146┊ 77┊      </Intro>\n-┊147┊   ┊      <SignInForm>\n-┊148┊   ┊        <ActualForm>\n-┊149┊   ┊          <Legend>Sign in</Legend>\n-┊150┊   ┊          <Section>\n-┊151┊   ┊            <TextField\n-┊152┊   ┊              className=\"AuthScreen-text-field\"\n-┊153┊   ┊              label=\"Username\"\n-┊154┊   ┊              value={username}\n-┊155┊   ┊              onChange={onUsernameChange}\n-┊156┊   ┊              margin=\"normal\"\n-┊157┊   ┊              placeholder=\"Enter your username\"\n-┊158┊   ┊            />\n-┊159┊   ┊            <TextField\n-┊160┊   ┊              className=\"AuthScreen-text-field\"\n-┊161┊   ┊              label=\"Password\"\n-┊162┊   ┊              type=\"password\"\n-┊163┊   ┊              value={password}\n-┊164┊   ┊              onChange={onPasswordChange}\n-┊165┊   ┊              margin=\"normal\"\n-┊166┊   ┊              placeholder=\"Enter your password\"\n-┊167┊   ┊            />\n-┊168┊   ┊          </Section>\n-┊169┊   ┊          <Button\n-┊170┊   ┊            data-testid=\"sign-in-button\"\n-┊171┊   ┊            type=\"button\"\n-┊172┊   ┊            color=\"secondary\"\n-┊173┊   ┊            variant=\"contained\"\n-┊174┊   ┊            disabled={!maySignIn()}\n-┊175┊   ┊            onClick={handleSignIn}\n-┊176┊   ┊          >\n-┊177┊   ┊            Sign in\n-┊178┊   ┊          </Button>\n-┊179┊   ┊        </ActualForm>\n-┊180┊   ┊      </SignInForm>\n+┊   ┊ 78┊      <AnimatedSwitch>\n+┊   ┊ 79┊        <Route exact path=\"/sign-in\" component={SignInForm} />\n+┊   ┊ 80┊        <Route exact path=\"/sign-up\" component={SignUpForm} />\n+┊   ┊ 81┊      </AnimatedSwitch>\n+┊   ┊ 82┊      {alternative}\n ┊181┊ 83┊    </Container>\n ┊182┊ 84┊  )\n ┊183┊ 85┊}\n```\n\n[}]: #\n\n> Note how we used the `/sign-(in|up)` pattern to define the `/sign-up` route. This is because the request will be further redirected in the `AuthScreen`.\n\nThe authentication flow is complete! To test it out, you can create a new user, log in with it and start chatting with other users."
          }
        ]
      }
    ]
  }
]
