[
  {
    "repoUrl": "https://DAB0mB@github.com/DAB0mB/node-distance-addon",
    "branchName": "master",
    "historyBranchName": "master-history",
    "releases": [
      {
        "releaseVersion": "1.1.0",
        "releaseDate": "2018-08-27 03:47:10 +0800",
        "tagName": "master@1.1.0",
        "tagRevision": "1e964031827e04b329aa1d3251e474bd7d335477",
        "historyRevision": "e1bf596d998407842e6ef764d94889fb7eefa637",
        "changesDiff": "diff --git a/.tortilla/manuals/templates/root.tmpl b/.tortilla/manuals/templates/root.tmpl\nindex 6a69936..e69de29 100644\n--- a/.tortilla/manuals/templates/root.tmpl\n+++ b/.tortilla/manuals/templates/root.tmpl\n@@ -1,11 +0,0 @@\n-In this tutorial we gonna go through the basics on how to write a native add-on to NodeJS using C++, one of the platform's most powerful capabilities of which most web/JS developers now a days are not even familiar with.\n-\n-For somewhat there is a vacuum which got created around C++ in the recent years, people are so scared from a low-level back-end programming, why should they even deal with memory allocation dilemmas when there are all these interpretation languages like Python, Ruby, and JavaScript who can do that for us? Well folks, once you will realize that all these single web-page application third-party libraries and frameworks are all recycled and repetitive, and you will start doing some real shit by optimizing some heavy-ass machine algorithms, you will realize that **performance is critic**, a title which doesn't really suit NodeJS, with all the love and respect. So why do I even bother making this tutorial? Because people are unaware of many features in the programming world, and the beauty of algorithmics. And why am I even approaching NodeJS developers? Because they have the biggest, most-popular community of all, they have a lot to learn, but they are very open minded, and that's the most important thing. You don't have to be a C++ developer not at all, but if I can at least catch a small part of your attention I will be overwhelmed.\n-\n-We will create a very small and simple module which calculates the distance between two dots, it can do it either synchronously or asynchronously. The algorithm for calculating the distance between a given `pointA` and `pointB` in a 2D [Cartesian coordinate system](https://en.wikipedia.org/wiki/Cartesian_coordinate_system) looks like this:\n-\n-    √[(pointAX - pointBX)^2 + (pointAY - pointBY)^2]\n-\n-Probably not too complicated, kicks me back to the glamorous days in high-school. If put in JavaScript it should take around 10 seconds right? Well in a native NodeJS add-on it should be a bit longer. Of-course when it comes to small logics you shouldn't make too much effort, because it will consume more power only converting all JS objects into C++ native structures. But imagine you would like to run a [blob-detection](https://en.wikipedia.org/wiki/Blob_detection) algorithm and you would like to calculate the [center of mass](https://en.wikipedia.org/wiki/Center_of_mass) of multiple blobs, in C++ it would be much faster, especially when using [shaders](https://en.wikipedia.org/wiki/Shader). Anyways that's not the point of this tutorial, the point is that you will be provided with the necessary tools so next time if you would like to write some heavy logic, you will know how to do it.\n-\n-We will start with a brief introduction for Google's [v8 engine](https://en.wikipedia.org/wiki/V8_(JavaScript_engine)) and some practical examples on how to use it, this will help us getting start, and then we will write our add-on. Let's begin then shall we?\ndiff --git a/.tortilla/manuals/templates/step1.tmpl b/.tortilla/manuals/templates/step1.tmpl\nindex d6acdb6..6a69936 100644\n--- a/.tortilla/manuals/templates/step1.tmpl\n+++ b/.tortilla/manuals/templates/step1.tmpl\n@@ -1,155 +1,11 @@\n-![v8-logo](https://cloud.githubusercontent.com/assets/7648874/20428176/d766fba8-ad6e-11e6-884f-badc847d5e24.png)\n+In this tutorial we gonna go through the basics on how to write a native add-on to NodeJS using C++, one of the platform's most powerful capabilities of which most web/JS developers now a days are not even familiar with.\n \n-The v8 JavaScript Engine is an open source JavaScript engine developed by The [Chromium Project](https://www.chromium.org/) for the [Google Chrome web browser](https://www.google.com/chrome/). It is intended to be used both in a browser and as a standalone high-performance engine that can be integrated into independent projects like [Couchbase](http://www.couchbase.com/), [MongoDB](https://www.mongodb.com/) and [Node.js](https://nodejs.org/). There lots of benchmarks out there but I will not bore you with diagrams, we all know that that this engine has proven itself to be worthy and it is being used world-widely and probably for a good reason.\n+For somewhat there is a vacuum which got created around C++ in the recent years, people are so scared from a low-level back-end programming, why should they even deal with memory allocation dilemmas when there are all these interpretation languages like Python, Ruby, and JavaScript who can do that for us? Well folks, once you will realize that all these single web-page application third-party libraries and frameworks are all recycled and repetitive, and you will start doing some real shit by optimizing some heavy-ass machine algorithms, you will realize that **performance is critic**, a title which doesn't really suit NodeJS, with all the love and respect. So why do I even bother making this tutorial? Because people are unaware of many features in the programming world, and the beauty of algorithmics. And why am I even approaching NodeJS developers? Because they have the biggest, most-popular community of all, they have a lot to learn, but they are very open minded, and that's the most important thing. You don't have to be a C++ developer not at all, but if I can at least catch a small part of your attention I will be overwhelmed.\n \n-> \"Ambition is a dream with a v8 engine\" -Elvis Presley.\n+We will create a very small and simple module which calculates the distance between two dots, it can do it either synchronously or asynchronously. The algorithm for calculating the distance between a given `pointA` and `pointB` in a 2D [Cartesian coordinate system](https://en.wikipedia.org/wiki/Cartesian_coordinate_system) looks like this:\n \n-If you're a JavaScript developer you must be familiar with the event-loop and the scoping system of v8, so it's a good thing that you understand the concept, but you never got to actually look at its source code and explicitly use it. A detailed documentation for v8's different API versions is available [here](https://v8docs.nodesource.com/). I assume that you don't bother reading any of my references that I provide along this tutorial (As a lazy blog-reader myself), I will post here that first thing you gonna see once you enter v8's documentation web-site:\n+    √[(pointAX - pointBX)^2 + (pointAY - pointBY)^2]\n \n-![v8-docs](https://cloud.githubusercontent.com/assets/7648874/20429800/ffeb3a4a-ad77-11e6-8fae-d892304169db.jpg)\n+Probably not too complicated, kicks me back to the glamorous days in high-school. If put in JavaScript it should take around 10 seconds right? Well in a native NodeJS add-on it should be a bit longer. Of-course when it comes to small logics you shouldn't make too much effort, because it will consume more power only converting all JS objects into C++ native structures. But imagine you would like to run a [blob-detection](https://en.wikipedia.org/wiki/Blob_detection) algorithm and you would like to calculate the [center of mass](https://en.wikipedia.org/wiki/Center_of_mass) of multiple blobs, in C++ it would be much faster, especially when using [shaders](https://en.wikipedia.org/wiki/Shader). Anyways that's not the point of this tutorial, the point is that you will be provided with the necessary tools so next time if you would like to write some heavy logic, you will know how to do it.\n \n-Throughout history v8 have changed a lot and it wore many forms. As a result, add-ons are not usable across different versions of the platform since each one supports a different API, which will break our process during run-time. In NodeJS team they came up with a very convenient solution called [Nan](https://github.com/nodejs/nan). Nan stands for \"Native Abstractions for NodeJS\" and is basically a header file filled with macro and utility goodness for making add-on development for NodeJS easier across all versions of v8, without inspecting `NODE_MODULE_VERSION` macro all the time. In this tutorial I'm gonna refer both of them as if they are bundled in a single framework.\n-\n-Eventually JavaScript is just a rehash of v8, everything you know so far is still valid but it uses a different idiom. To prevent some misconceptions, here are some important points regards JavaScript's equivalents which I think you should follow:\n-\n-#### Scopes and Variables\n-\n-In v8 a scope is referred as `Isolate` (`v8::Isolate`) and a variable is referred as `Local` (`v8::Local<T>`). A local is a pointer to an object. All v8 objects are accessed using locals, they are necessary because of the way the v8 garbage collector works. An isolate can be thought of as a container for any number of locals. When you've finished with your locals, instead of deleting each one individually you can simply delete their scope.\n-\n-##### JavaScript\n-\n-```js\n-let obj = {\n-  foo: 'foo',\n-  bar: 'bar',\n-  baz: 'baz'\n-};\n-\n-console.log(obj.foo);\n-console.log(obj.bar);\n-console.log(obj.baz);\n-```\n-\n-##### C++\n-\n-```cpp\n-using Nan::New;\n-using std::cendl;\n-using std::cout;\n-using v8::Local;\n-using v8::Object;\n-using v8::String;\n-\n-Local<Object> obj = New<Object>();\n-\n-obj->Set(New<String>(\"foo\").ToLocalChecked(), New<String>(\"foo\").ToLocalChecked());\n-obj->Set(New<String>(\"bar\").ToLocalChecked(), New<String>(\"bar\").ToLocalChecked());\n-obj->Set(New<String>(\"baz\").ToLocalChecked(), New<String>(\"baz\").ToLocalChecked());\n-\n-cout << obj->Get(New<String>(\"foo\").ToLocalChecked()) << cendl;\n-cout << obj->Get(New<String>(\"bar\").ToLocalChecked()) << cendl;\n-cout << obj->Get(New<String>(\"baz\").ToLocalChecked()) << cendl;\n-```\n-\n-#### Asynchronous Callbacks\n-\n-Asynchronous logic can be implemented using the `AsyncWorker` (`Nan::AsyncWorker`) and invoked by `AsyncQueueWorker` (`Nan::AsyncQueueWorker`). Thanks to these two you can have much of the annoying asynchronous queuing and handling taken care of for you. It can even store arbitrary V8 objects for you and have them persist while the asynchronous work is in progress.\n-\n-##### JavaScript\n-\n-```js\n-setImmediate(() => {\n-  callback(null, 'result');\n-});\n-```\n-\n-##### C++\n-\n-```cpp\n-using Nan::AsyncQueueWorker;\n-using Nan::AsyncWorker;\n-using Nan::HandleScope;\n-using Nan::New;\n-using Nan::Null;\n-using std::string;\n-using v8::Local;\n-using v8::String;\n-\n-class ResultWorker : AsyncWorker {\n- private:\n-  string* result\n-\n- public:\n-  ResultWorker(Callback* callback) : AsyncWorker(callback) {}\n-\n-  ~ResultDistance() {\n-    delete result;\n-  }\n-\n-  // Executed inside the worker-thread.\n-  // It is not safe to access V8, or V8 data structures\n-  // here, so everything we need for input and output\n-  // should go on 'this'.\n-  void Execute () {\n-    result = new string(\"result\");\n-  }\n-\n-  // Executed when the async work is complete.\n-  // This function will be run inside the main event loop\n-  // so it is safe to use V8 again.\n-  void HandleOKCallback () {\n-    HandleScope scope;\n-\n-    Local<Value> argv[] = {\n-      Null(),\n-      New<String>(result).ToLocalChecked()\n-    };\n-\n-    callback->Call(2, argv);\n-  }\n-};\n-\n-AsyncQueueWorker(new ResultWorker(callback));\n-```\n-\n-#### Modules Registration and Methods Definition\n-\n-v8 and Nan provide us with some handy macros (`NODE_MODULE`, `NAN_MODULE_INIT`, `NAN_METHOD` and `NODE_SET_METHOD`) which will help us register a new NodeJS module and define its methods. This might be confusing for some, since we can't see the function's signature it would appear as if variables are just being magically created in the stack, but once the macros are being pre-processed they will just turn into ordinary functions. In the example below I commented the original signature so you can have more clew on what's going on.\n-\n-##### JavaScript\n-\n-```js\n-exports.fn = (a, b) => a + b;\n-```\n-\n-##### C++\n-\n-```cpp\n-using Nan::To;\n-using v8::Local;\n-using v8::Object;\n-\n-// void Fn(FunctionCallbackInfo<Value>& info)\n-NAN_METHOD(Fn) {\n-  double a = To<double>(info[0]).FromJust();\n-  double b = To<double>(info[1]).FromJust();\n-\n-  info.GetReturnValue().Set(a + b);\n-}\n-\n-// void Init(Local<Object> target)\n-NAN_MODULE_INIT(Init) {\n-  NODE_SET_METHOD(target, Fn);\n-}\n-\n-// First argument would be the entry file's name\n-NODE_MODULE(addon, Init);\n-```\n-\n----\n-\n-As you can see when dealing with v8 explicitly is a time consuming process which requires you to do lots of extra-work. With that said, keep in mind that only a small portion of your code is gonna interact with the engine since the core logic should be written using native C++ and other third-party libraries. You always need to find the right balance. Always make sure that your add-on doesn't require too much data to be passed otherwise the conversion process is gonna be hard and inefficient, and think twice before you choose this approach for the sake of simplicity. Overall the estimated optimization should be around 150% and up, depends on the task, first check your JavaScript code snippet, check for unnecessary logic and optimize it, and if you're really sure that it is fully optimized and you're still striving for more performance, *only then* move to C++.\n-\n-So far I went through the very basics which will help you create this bridge between the two platforms. The v8 lacks of detailed documentation, tutorials and examples. [Nan](https://github.com/nodejs/nan) however is a bit more documented IMHO, so when I approach the API documentation I would start from there, and if I didn't find anything useful I would look at [v8's latest API docs](https://v8docs.nodesource.com/). It's not a hard material to learn but it's different so it might be a bit challenging for some, but remember, practice practice practice.\n-\n-Speaking of practice, let's move on to the next step where we gonna implement our first add-on for distance calculation between two points.\n+We will start with a brief introduction for Google's [v8 engine](https://en.wikipedia.org/wiki/V8_(JavaScript_engine)) and some practical examples on how to use it, this will help us getting start, and then we will write our add-on. Let's begin then shall we?\ndiff --git a/.tortilla/manuals/templates/step2.tmpl b/.tortilla/manuals/templates/step2.tmpl\nindex b60230e..d6acdb6 100644\n--- a/.tortilla/manuals/templates/step2.tmpl\n+++ b/.tortilla/manuals/templates/step2.tmpl\n@@ -1,100 +1,155 @@\n-In this step we will base our development process on the TDD methodology, so you will have a chance to look at the final target API that we desire. We will start by writing a test file:\n+![v8-logo](https://cloud.githubusercontent.com/assets/7648874/20428176/d766fba8-ad6e-11e6-884f-badc847d5e24.png)\n \n-{{{diffStep 2.1}}}\n+The v8 JavaScript Engine is an open source JavaScript engine developed by The [Chromium Project](https://www.chromium.org/) for the [Google Chrome web browser](https://www.google.com/chrome/). It is intended to be used both in a browser and as a standalone high-performance engine that can be integrated into independent projects like [Couchbase](http://www.couchbase.com/), [MongoDB](https://www.mongodb.com/) and [Node.js](https://nodejs.org/). There lots of benchmarks out there but I will not bore you with diagrams, we all know that that this engine has proven itself to be worthy and it is being used world-widely and probably for a good reason.\n \n-And the following NPM script should execute it:\n+> \"Ambition is a dream with a v8 engine\" -Elvis Presley.\n \n-{{{diffStep 2.2}}}\n+If you're a JavaScript developer you must be familiar with the event-loop and the scoping system of v8, so it's a good thing that you understand the concept, but you never got to actually look at its source code and explicitly use it. A detailed documentation for v8's different API versions is available [here](https://v8docs.nodesource.com/). I assume that you don't bother reading any of my references that I provide along this tutorial (As a lazy blog-reader myself), I will post here that first thing you gonna see once you enter v8's documentation web-site:\n \n-Like I said in the introduction, it's a simple module which can calculate the distance between 2 given points. `calculate.sync` can do it synchronously and `calculate.async` can do it asynchronously. Now that you got the idea we will start configuring our add-on.\n+![v8-docs](https://cloud.githubusercontent.com/assets/7648874/20429800/ffeb3a4a-ad77-11e6-8fae-d892304169db.jpg)\n \n-The first thing you'll need to do is to make sure that you have `node-gyp` installed:\n+Throughout history v8 have changed a lot and it wore many forms. As a result, add-ons are not usable across different versions of the platform since each one supports a different API, which will break our process during run-time. In NodeJS team they came up with a very convenient solution called [Nan](https://github.com/nodejs/nan). Nan stands for \"Native Abstractions for NodeJS\" and is basically a header file filled with macro and utility goodness for making add-on development for NodeJS easier across all versions of v8, without inspecting `NODE_MODULE_VERSION` macro all the time. In this tutorial I'm gonna refer both of them as if they are bundled in a single framework.\n \n-    $ sudo npm install -g node-gyp\n+Eventually JavaScript is just a rehash of v8, everything you know so far is still valid but it uses a different idiom. To prevent some misconceptions, here are some important points regards JavaScript's equivalents which I think you should follow:\n \n-`node-gyp` is also dependent on many other packages, so before you go any further please take a look at the official installation instructions in their [README.md file](https://github.com/nodejs/node-gyp).\n+#### Scopes and Variables\n \n-Assuming that you have installed everything properly, we will now need to create a `binding.gyp` file:\n+In v8 a scope is referred as `Isolate` (`v8::Isolate`) and a variable is referred as `Local` (`v8::Local<T>`). A local is a pointer to an object. All v8 objects are accessed using locals, they are necessary because of the way the v8 garbage collector works. An isolate can be thought of as a container for any number of locals. When you've finished with your locals, instead of deleting each one individually you can simply delete their scope.\n \n-{{{diffStep 2.3 files=\"binding.gyp\"}}}\n+##### JavaScript\n \n-GYP stands for 'Generate Your Project' and was created by the Chromium team as a configuration file for building native projects. The configuration show above should be a good template for any future add-on you're looking to develop. Let's take a deeper look at it:\n+```js\n+let obj = {\n+  foo: 'foo',\n+  bar: 'bar',\n+  baz: 'baz'\n+};\n \n-- `target_name` - Specifies the output dir of our add-on, in which case it should be `build/Release/distance`.\n-- `sources` - Should include **all** the cpp files that are associated with you add-on.\n-- `include_dirs` - Additional dirs that should be included when building the add-on. If you'll run the given script in the terminal you'll get the node-module path for Nan, a library which we're interested in during the build process.\n+console.log(obj.foo);\n+console.log(obj.bar);\n+console.log(obj.baz);\n+```\n \n-More information about GYP configuration can be found [here](https://gyp.gsrc.io/docs/UserDocumentation.md).\n+##### C++\n \n-Be sure to also add the specified flag to the `package.json` which basically says 'Hey, I have a GYP file which should be taken into consideration as well':\n+```cpp\n+using Nan::New;\n+using std::cendl;\n+using std::cout;\n+using v8::Local;\n+using v8::Object;\n+using v8::String;\n \n-{{{diffStep 2.3 files=\"package.json\"}}}\n+Local<Object> obj = New<Object>();\n \n-Now we will add the following NPM scripts so whenever we run `npm run build` our project will be built:\n+obj->Set(New<String>(\"foo\").ToLocalChecked(), New<String>(\"foo\").ToLocalChecked());\n+obj->Set(New<String>(\"bar\").ToLocalChecked(), New<String>(\"bar\").ToLocalChecked());\n+obj->Set(New<String>(\"baz\").ToLocalChecked(), New<String>(\"baz\").ToLocalChecked());\n \n-{{{diffStep 2.4}}}\n+cout << obj->Get(New<String>(\"foo\").ToLocalChecked()) << cendl;\n+cout << obj->Get(New<String>(\"bar\").ToLocalChecked()) << cendl;\n+cout << obj->Get(New<String>(\"baz\").ToLocalChecked()) << cendl;\n+```\n \n-The only thing left to do before jumping into implementation would be installing Nan:\n+#### Asynchronous Callbacks\n \n-    $ npm install nan --save\n+Asynchronous logic can be implemented using the `AsyncWorker` (`Nan::AsyncWorker`) and invoked by `AsyncQueueWorker` (`Nan::AsyncQueueWorker`). Thanks to these two you can have much of the annoying asynchronous queuing and handling taken care of for you. It can even store arbitrary V8 objects for you and have them persist while the asynchronous work is in progress.\n \n-The basis for build process is set. We will create the entry file for our add-on:\n+##### JavaScript\n \n-{{{diffStep 2.6}}}\n+```js\n+setImmediate(() => {\n+  callback(null, 'result');\n+});\n+```\n \n-Every add-on should start with these two macro calls. They are both compiled into a piece of code which will register our module with ease. The `NODE_MODULE` macro template accepts the name of the target as the first argument (That one we set as `target_name` in the GYP file, remember?) and the initialization method for our module. The `NAN_MODULE_INIT` generates a function with the given name. It accepts `target` as the first argument which is equivalent to NodeJS's `exports`. Now we will create our first method stub for a synchronous distance calculation:\n+##### C++\n \n-{{{diffStep 2.7}}}\n+```cpp\n+using Nan::AsyncQueueWorker;\n+using Nan::AsyncWorker;\n+using Nan::HandleScope;\n+using Nan::New;\n+using Nan::Null;\n+using std::string;\n+using v8::Local;\n+using v8::String;\n \n-We exported the `CalculateSync` by using the `NAN_EXPORT` macro, and we used `NAN_METHOD` to define a new node-valid function. It accepts `info` as the first argument and it is the same as JavaScript's `arguments` vector. We already know which arguments this function should accept, that's why I followed TDD methodology from the first place:\n+class ResultWorker : AsyncWorker {\n+ private:\n+  string* result\n \n-{{{diffStep 2.8}}}\n+ public:\n+  ResultWorker(Callback* callback) : AsyncWorker(callback) {}\n \n-We use the `To()` function to convert the first argument into the desired type, and then we call the method `ToLocalChecked()`. This method is simply going to convert the result into v8's Local, unless the argument is undefined, in which case an error is going to be thrown. I like to prefix JS object with a `js_` so I know with what kind variable I'm dealing with. We should have two points containing `x` and `y` fields. Let's try to extract them out of the arguments vector and convert them into native C++ structures:\n+  ~ResultDistance() {\n+    delete result;\n+  }\n \n-{{{diffStep 2.9}}}\n+  // Executed inside the worker-thread.\n+  // It is not safe to access V8, or V8 data structures\n+  // here, so everything we need for input and output\n+  // should go on 'this'.\n+  void Execute () {\n+    result = new string(\"result\");\n+  }\n \n-Then again we convert the `To()` function to convert the result into the desired data-type, only this time it's a primitive, so we use `FromJust()` instead of `ToLocalChecked()`. Note that v8 only uses double precision rather than a floating point. We can fetch properties from a given JS object with ease using the `Get()` method. Pay attention to use the `->` rather than a period because remember, a Local is actually a pointer! It is not the actual object.\n+  // Executed when the async work is complete.\n+  // This function will be run inside the main event loop\n+  // so it is safe to use V8 again.\n+  void HandleOKCallback () {\n+    HandleScope scope;\n \n-Now all is left to do is defining the return value. Keep in mind that the value should be returned through v8's current scope, not natively, so using the `return` keyword would be useless. The return value can actually be defined through the provided `info` argument, like this:\n+    Local<Value> argv[] = {\n+      Null(),\n+      New<String>(result).ToLocalChecked()\n+    };\n \n-{{{diffStep \"2.10\"}}}\n+    callback->Call(2, argv);\n+  }\n+};\n \n-And of-course it requires us to add the core distance calculation method:\n+AsyncQueueWorker(new ResultWorker(callback));\n+```\n \n-{{{diffStep 2.11}}}\n+#### Modules Registration and Methods Definition\n \n-This is it for the synchronous calculation. Now we will add an async version of it. We will start by creating a method with everything we learned so far until the point where we have to return the result:\n+v8 and Nan provide us with some handy macros (`NODE_MODULE`, `NAN_MODULE_INIT`, `NAN_METHOD` and `NODE_SET_METHOD`) which will help us register a new NodeJS module and define its methods. This might be confusing for some, since we can't see the function's signature it would appear as if variables are just being magically created in the stack, but once the macros are being pre-processed they will just turn into ordinary functions. In the example below I commented the original signature so you can have more clew on what's going on.\n \n-{{{diffStep 2.12}}}\n+##### JavaScript\n \n-Here's the different part. We don't wanna simply return the value, we want to make the calculations in parallel with the event loop, and once we're finished we will interact with it once again. In our model there are two threads. The first thread is the event loop thread, and the second thread will be a worker thread managed by Nan, the library supports asynchronous I/O in NodeJS. Let's start implementing and I will give some more explanations as we go further:\n+```js\n+exports.fn = (a, b) => a + b;\n+```\n \n-{{{diffStep 2.13}}}\n+##### C++\n \n-Here we fetch the third argument which is the callback. We wrap it with Nan's Callback, which will make sure it is not garbage collected once the scope is being deleted, we want it to keep living until it's not relevant. At the bottom of the method, instead of returning a value explicitly, we queue our `DistanceWorker` into the workers queue. On that note, let's implement the DistanceWorker:\n+```cpp\n+using Nan::To;\n+using v8::Local;\n+using v8::Object;\n \n-{{{diffStep 2.14}}}\n+// void Fn(FunctionCallbackInfo<Value>& info)\n+NAN_METHOD(Fn) {\n+  double a = To<double>(info[0]).FromJust();\n+  double b = To<double>(info[1]).FromJust();\n \n-`AsyncWorker` is an abstract class that you can subclass to have much of the annoying asynchronous queuing and handling taken care of for you. It can even store arbitrary v8 objects for you and have them persist while the asynchronous work is in progress. The `execute()` method is being executed inside the worker-thread. It is not safe to access V8, or V8 data structures there, so everything we need for input and output should go on 'this'. The `HandleOKCallback()` method is executed when the async work is complete. This function will be run inside the main event loop so it is safe to use v8 again. Let's implement the core distance calculation on the worker thread:\n+  info.GetReturnValue().Set(a + b);\n+}\n \n-{{{diffStep 2.15}}}\n+// void Init(Local<Object> target)\n+NAN_MODULE_INIT(Init) {\n+  NODE_SET_METHOD(target, Fn);\n+}\n \n-And handle a successful invocation once the calculation is finished:\n+// First argument would be the entry file's name\n+NODE_MODULE(addon, Init);\n+```\n \n-{{{diffStep 2.16}}}\n+---\n \n-Normally, when defining a NodeJS method (`NAN_METHOD` macro) a scope will be created for us automatically. In this function's context there is no scope exist, so we will have to create it using the `HandleScope` deceleration (The current scope is stored globally so even though we don't use it explicitly, v8 and Nan know what to do). We also created an arguments vector as the return value, following NodeJS's conventions, the first argument would be the error and the second argument would be the result.\n+As you can see when dealing with v8 explicitly is a time consuming process which requires you to do lots of extra-work. With that said, keep in mind that only a small portion of your code is gonna interact with the engine since the core logic should be written using native C++ and other third-party libraries. You always need to find the right balance. Always make sure that your add-on doesn't require too much data to be passed otherwise the conversion process is gonna be hard and inefficient, and think twice before you choose this approach for the sake of simplicity. Overall the estimated optimization should be around 150% and up, depends on the task, first check your JavaScript code snippet, check for unnecessary logic and optimize it, and if you're really sure that it is fully optimized and you're still striving for more performance, *only then* move to C++.\n \n-This is it! Finally we will transform the add-on into a nicer looking node-module:\n+So far I went through the very basics which will help you create this bridge between the two platforms. The v8 lacks of detailed documentation, tutorials and examples. [Nan](https://github.com/nodejs/nan) however is a bit more documented IMHO, so when I approach the API documentation I would start from there, and if I didn't find anything useful I would look at [v8's latest API docs](https://v8docs.nodesource.com/). It's not a hard material to learn but it's different so it might be a bit challenging for some, but remember, practice practice practice.\n \n-{{{diffStep 2.17}}}\n-\n-And now, let's run our small test to see that it works, using the following command:\n-\n-    $ npm run test\n-\n-If everything went well, you should have the following messages printed to the terminal:\n-\n-    sync calculation passed\n-    async calculation passed\n+Speaking of practice, let's move on to the next step where we gonna implement our first add-on for distance calculation between two points.\ndiff --git a/.tortilla/manuals/templates/step3.tmpl b/.tortilla/manuals/templates/step3.tmpl\nindex 29e2c65..f04f616 100644\n--- a/.tortilla/manuals/templates/step3.tmpl\n+++ b/.tortilla/manuals/templates/step3.tmpl\n@@ -1,3 +1,104 @@\n-You've just learned the very basics of how to use C++ within NodeJS. There's a lot more to learn when it comes to building an add-on, and I'm not just talking about learning v8 and Nan's API. Think about the possibilities, the C++ community have been developed for years and there are so much great libraries out there that are not necessarily relevant to NodeJS due to its efficiency, like [Boost](http://www.boost.org/), [OpenCV](http://opencv.org/), [CGAL](http://www.cgal.org/) and many more.\n+In this step we will base our development process on the TDD methodology, so you will have a chance to look at the final target API that we desire. We will start by writing a test file:\n \n-This tutorial didn't focus about algorithmics obviously, it's a good starting point though, because from here I can take it to wherever I want, but I won't reveal my future plans in due course. Hopefully you liked it, stay tuned for upcoming tutorials about this topic.\n+{{{diffStep 3.1}}}\n+\n+And the following NPM script should execute it:\n+\n+{{{diffStep 3.2}}}\n+\n+Like I said in the introduction, it's a simple module which can calculate the distance between 2 given points. `calculate.sync` can do it synchronously and `calculate.async` can do it asynchronously. Now that you got the idea we will start configuring our add-on.\n+\n+The first thing you'll need to do is to make sure that you have `node-gyp` installed:\n+\n+    $ sudo npm install -g node-gyp\n+\n+`node-gyp` is also dependent on many other packages, so before you go any further please take a look at the official installation instructions in their [README.md file](https://github.com/nodejs/node-gyp).\n+\n+Assuming that you have installed everything properly, we will now need to create a `binding.gyp` file:\n+\n+{{{diffStep 3.3 files=\"binding.gyp\"}}}\n+\n+GYP stands for 'Generate Your Project' and was created by the Chromium team as a configuration file for building native projects. The configuration show above should be a good template for any future add-on you're looking to develop. Let's take a deeper look at it:\n+\n+- `target_name` - Specifies the output dir of our add-on, in which case it should be `build/Release/distance`.\n+- `sources` - Should include **all** the cpp files that are associated with you add-on.\n+- `include_dirs` - Additional dirs that should be included when building the add-on. If you'll run the given script in the terminal you'll get the node-module path for Nan, a library which we're interested in during the build process.\n+\n+More information about GYP configuration can be found [here](https://gyp.gsrc.io/docs/UserDocumentation.md).\n+\n+Be sure to also add the specified flag to the `package.json` which basically says 'Hey, I have a GYP file which should be taken into consideration as well':\n+\n+{{{diffStep 3.3 files=\"package.json\"}}}\n+\n+Now we will add the following NPM scripts so whenever we run `npm run build` our project will be built:\n+\n+{{{diffStep 3.4}}}\n+\n+The only thing left to do before jumping into implementation would be installing Nan:\n+\n+    $ npm install nan --save\n+\n+The basis for build process is set. We will create the entry file for our add-on:\n+\n+{{{diffStep 3.6}}}\n+\n+Every add-on should start with these two macro calls. They are both compiled into a piece of code which will register our module with ease. The `NODE_MODULE` macro template accepts the name of the target as the first argument (That one we set as `target_name` in the GYP file, remember?) and the initialization method for our module. The `NAN_MODULE_INIT` generates a function with the given name. It accepts `target` as the first argument which is equivalent to NodeJS's `exports`. Now we will create our first method stub for a synchronous distance calculation:\n+\n+{{{diffStep 3.7}}}\n+\n+We exported the `CalculateSync` by using the `NAN_EXPORT` macro, and we used `NAN_METHOD` to define a new node-valid function. It accepts `info` as the first argument and it is the same as JavaScript's `arguments` vector. We already know which arguments this function should accept, that's why I followed TDD methodology from the first place:\n+\n+{{{diffStep 3.8}}}\n+\n+We use the `To()` function to convert the first argument into the desired type, and then we call the method `ToLocalChecked()`. This method is simply going to convert the result into v8's Local, unless the argument is undefined, in which case an error is going to be thrown. I like to prefix JS object with a `js_` so I know with what kind variable I'm dealing with. We should have two points containing `x` and `y` fields. Let's try to extract them out of the arguments vector and convert them into native C++ structures:\n+\n+{{{diffStep 3.9}}}\n+\n+Then again we convert the `To()` function to convert the result into the desired data-type, only this time it's a primitive, so we use `FromJust()` instead of `ToLocalChecked()`. Note that v8 only uses double precision rather than a floating point. We can fetch properties from a given JS object with ease using the `Get()` method. Pay attention to use the `->` rather than a period because remember, a Local is actually a pointer! It is not the actual object.\n+\n+Now all is left to do is defining the return value. Keep in mind that the value should be returned through v8's current scope, not natively, so using the `return` keyword would be useless. The return value can actually be defined through the provided `info` argument, like this:\n+\n+{{{diffStep \"3.10\"}}}\n+\n+And of-course it requires us to add the core distance calculation method:\n+\n+{{{diffStep 3.11}}}\n+\n+This is it for the synchronous calculation. Now we will add an async version of it. We will start by creating a method with everything we learned so far until the point where we have to return the result:\n+\n+{{{diffStep 3.12}}}\n+\n+Here's the different part. We don't wanna simply return the value, we want to make the calculations in parallel with the event loop, and once we're finished we will interact with it once again. In our model there are two threads. The first thread is the event loop thread, and the second thread will be a worker thread managed by Nan, the library supports asynchronous I/O in NodeJS. Let's start implementing and I will give some more explanations as we go further:\n+\n+{{{diffStep 3.13}}}\n+\n+Here we fetch the third argument which is the callback. We wrap it with Nan's Callback, which will make sure it is not garbage collected once the scope is being deleted, we want it to keep living until it's not relevant. At the bottom of the method, instead of returning a value explicitly, we queue our `DistanceWorker` into the workers queue. On that note, let's implement the DistanceWorker:\n+\n+{{{diffStep 3.14}}}\n+\n+`AsyncWorker` is an abstract class that you can subclass to have much of the annoying asynchronous queuing and handling taken care of for you. It can even store arbitrary v8 objects for you and have them persist while the asynchronous work is in progress. The `execute()` method is being executed inside the worker-thread. It is not safe to access V8, or V8 data structures there, so everything we need for input and output should go on 'this'. The `HandleOKCallback()` method is executed when the async work is complete. This function will be run inside the main event loop so it is safe to use v8 again. Let's implement the core distance calculation on the worker thread:\n+\n+{{{diffStep 3.15}}}\n+\n+And handle a successful invocation once the calculation is finished:\n+\n+{{{diffStep 3.16}}}\n+\n+Normally, when defining a NodeJS method (`NAN_METHOD` macro) a scope will be created for us automatically. In this function's context there is no scope exist, so we will have to create it using the `HandleScope` deceleration (The current scope is stored globally so even though we don't use it explicitly, v8 and Nan know what to do). We also created an arguments vector as the return value, following NodeJS's conventions, the first argument would be the error and the second argument would be the result.\n+\n+This is it! Finally we will transform the add-on into a nicer looking node-module:\n+\n+{{{diffStep 3.17}}}\n+\n+And now, let's run our small test to see that it works, using the following command:\n+\n+    $ npm run test\n+\n+If everything went well, you should have the following messages printed to the terminal:\n+\n+    sync calculation passed\n+    async calculation passed\n+\n+That's it. You've just learned the very basics of how to use C++ within NodeJS. There's a lot more to learn when it comes to building an add-on, and I'm not just talking about learning v8 and Nan's API. Think about the possibilities, the C++ community have been active for years and there are so much great libraries out there that are not necessarily relevant to NodeJS due to its efficiency, like [Boost](http://www.boost.org/), [OpenCV](http://opencv.org/), [CGAL](http://www.cgal.org/) and many more.\n+\n+This tutorial didn't focus on algorithmics obviously, but it's a good starting point though. Take it from here, and unleash your creativity!\n",
        "manuals": [
          {
            "manualTitle": "NodeJS Advanced - How to create a native add-on using C++",
            "stepRevision": "eeb98a9f6dc0908010f76e74f46a695f386a6ff0",
            "manualView": ""
          },
          {
            "manualTitle": "Step 1: Introduction",
            "stepRevision": "14c6111213f063210cb887d017cf350ee570fee4",
            "manualView": "In this tutorial we gonna go through the basics on how to write a native add-on to NodeJS using C++, one of the platform's most powerful capabilities of which most web/JS developers now a days are not even familiar with.\n\nFor somewhat there is a vacuum which got created around C++ in the recent years, people are so scared from a low-level back-end programming, why should they even deal with memory allocation dilemmas when there are all these interpretation languages like Python, Ruby, and JavaScript who can do that for us? Well folks, once you will realize that all these single web-page application third-party libraries and frameworks are all recycled and repetitive, and you will start doing some real shit by optimizing some heavy-ass machine algorithms, you will realize that **performance is critic**, a title which doesn't really suit NodeJS, with all the love and respect. So why do I even bother making this tutorial? Because people are unaware of many features in the programming world, and the beauty of algorithmics. And why am I even approaching NodeJS developers? Because they have the biggest, most-popular community of all, they have a lot to learn, but they are very open minded, and that's the most important thing. You don't have to be a C++ developer not at all, but if I can at least catch a small part of your attention I will be overwhelmed.\n\nWe will create a very small and simple module which calculates the distance between two dots, it can do it either synchronously or asynchronously. The algorithm for calculating the distance between a given `pointA` and `pointB` in a 2D [Cartesian coordinate system](https://en.wikipedia.org/wiki/Cartesian_coordinate_system) looks like this:\n\n    √[(pointAX - pointBX)^2 + (pointAY - pointBY)^2]\n\nProbably not too complicated, kicks me back to the glamorous days in high-school. If put in JavaScript it should take around 10 seconds right? Well in a native NodeJS add-on it should be a bit longer. Of-course when it comes to small logics you shouldn't make too much effort, because it will consume more power only converting all JS objects into C++ native structures. But imagine you would like to run a [blob-detection](https://en.wikipedia.org/wiki/Blob_detection) algorithm and you would like to calculate the [center of mass](https://en.wikipedia.org/wiki/Center_of_mass) of multiple blobs, in C++ it would be much faster, especially when using [shaders](https://en.wikipedia.org/wiki/Shader). Anyways that's not the point of this tutorial, the point is that you will be provided with the necessary tools so next time if you would like to write some heavy logic, you will know how to do it.\n\nWe will start with a brief introduction for Google's [v8 engine](https://en.wikipedia.org/wiki/V8_(JavaScript_engine)) and some practical examples on how to use it, this will help us getting start, and then we will write our add-on. Let's begin then shall we?"
          },
          {
            "manualTitle": "Step 2: Meet the V8 engine",
            "stepRevision": "55fbd43bb8b1f70e0df0dcaacca0589a3a8bc780",
            "manualView": "![v8-logo](https://cloud.githubusercontent.com/assets/7648874/20428176/d766fba8-ad6e-11e6-884f-badc847d5e24.png)\n\nThe v8 JavaScript Engine is an open source JavaScript engine developed by The [Chromium Project](https://www.chromium.org/) for the [Google Chrome web browser](https://www.google.com/chrome/). It is intended to be used both in a browser and as a standalone high-performance engine that can be integrated into independent projects like [Couchbase](http://www.couchbase.com/), [MongoDB](https://www.mongodb.com/) and [Node.js](https://nodejs.org/). There lots of benchmarks out there but I will not bore you with diagrams, we all know that that this engine has proven itself to be worthy and it is being used world-widely and probably for a good reason.\n\n> \"Ambition is a dream with a v8 engine\" -Elvis Presley.\n\nIf you're a JavaScript developer you must be familiar with the event-loop and the scoping system of v8, so it's a good thing that you understand the concept, but you never got to actually look at its source code and explicitly use it. A detailed documentation for v8's different API versions is available [here](https://v8docs.nodesource.com/). I assume that you don't bother reading any of my references that I provide along this tutorial (As a lazy blog-reader myself), I will post here that first thing you gonna see once you enter v8's documentation web-site:\n\n![v8-docs](https://cloud.githubusercontent.com/assets/7648874/20429800/ffeb3a4a-ad77-11e6-8fae-d892304169db.jpg)\n\nThroughout history v8 have changed a lot and it wore many forms. As a result, add-ons are not usable across different versions of the platform since each one supports a different API, which will break our process during run-time. In NodeJS team they came up with a very convenient solution called [Nan](https://github.com/nodejs/nan). Nan stands for \"Native Abstractions for NodeJS\" and is basically a header file filled with macro and utility goodness for making add-on development for NodeJS easier across all versions of v8, without inspecting `NODE_MODULE_VERSION` macro all the time. In this tutorial I'm gonna refer both of them as if they are bundled in a single framework.\n\nEventually JavaScript is just a rehash of v8, everything you know so far is still valid but it uses a different idiom. To prevent some misconceptions, here are some important points regards JavaScript's equivalents which I think you should follow:\n\n#### Scopes and Variables\n\nIn v8 a scope is referred as `Isolate` (`v8::Isolate`) and a variable is referred as `Local` (`v8::Local<T>`). A local is a pointer to an object. All v8 objects are accessed using locals, they are necessary because of the way the v8 garbage collector works. An isolate can be thought of as a container for any number of locals. When you've finished with your locals, instead of deleting each one individually you can simply delete their scope.\n\n##### JavaScript\n\n```js\nlet obj = {\n  foo: 'foo',\n  bar: 'bar',\n  baz: 'baz'\n};\n\nconsole.log(obj.foo);\nconsole.log(obj.bar);\nconsole.log(obj.baz);\n```\n\n##### C++\n\n```cpp\nusing Nan::New;\nusing std::cendl;\nusing std::cout;\nusing v8::Local;\nusing v8::Object;\nusing v8::String;\n\nLocal<Object> obj = New<Object>();\n\nobj->Set(New<String>(\"foo\").ToLocalChecked(), New<String>(\"foo\").ToLocalChecked());\nobj->Set(New<String>(\"bar\").ToLocalChecked(), New<String>(\"bar\").ToLocalChecked());\nobj->Set(New<String>(\"baz\").ToLocalChecked(), New<String>(\"baz\").ToLocalChecked());\n\ncout << obj->Get(New<String>(\"foo\").ToLocalChecked()) << cendl;\ncout << obj->Get(New<String>(\"bar\").ToLocalChecked()) << cendl;\ncout << obj->Get(New<String>(\"baz\").ToLocalChecked()) << cendl;\n```\n\n#### Asynchronous Callbacks\n\nAsynchronous logic can be implemented using the `AsyncWorker` (`Nan::AsyncWorker`) and invoked by `AsyncQueueWorker` (`Nan::AsyncQueueWorker`). Thanks to these two you can have much of the annoying asynchronous queuing and handling taken care of for you. It can even store arbitrary V8 objects for you and have them persist while the asynchronous work is in progress.\n\n##### JavaScript\n\n```js\nsetImmediate(() => {\n  callback(null, 'result');\n});\n```\n\n##### C++\n\n```cpp\nusing Nan::AsyncQueueWorker;\nusing Nan::AsyncWorker;\nusing Nan::HandleScope;\nusing Nan::New;\nusing Nan::Null;\nusing std::string;\nusing v8::Local;\nusing v8::String;\n\nclass ResultWorker : AsyncWorker {\n private:\n  string* result\n\n public:\n  ResultWorker(Callback* callback) : AsyncWorker(callback) {}\n\n  ~ResultDistance() {\n    delete result;\n  }\n\n  // Executed inside the worker-thread.\n  // It is not safe to access V8, or V8 data structures\n  // here, so everything we need for input and output\n  // should go on 'this'.\n  void Execute () {\n    result = new string(\"result\");\n  }\n\n  // Executed when the async work is complete.\n  // This function will be run inside the main event loop\n  // so it is safe to use V8 again.\n  void HandleOKCallback () {\n    HandleScope scope;\n\n    Local<Value> argv[] = {\n      Null(),\n      New<String>(result).ToLocalChecked()\n    };\n\n    callback->Call(2, argv);\n  }\n};\n\nAsyncQueueWorker(new ResultWorker(callback));\n```\n\n#### Modules Registration and Methods Definition\n\nv8 and Nan provide us with some handy macros (`NODE_MODULE`, `NAN_MODULE_INIT`, `NAN_METHOD` and `NODE_SET_METHOD`) which will help us register a new NodeJS module and define its methods. This might be confusing for some, since we can't see the function's signature it would appear as if variables are just being magically created in the stack, but once the macros are being pre-processed they will just turn into ordinary functions. In the example below I commented the original signature so you can have more clew on what's going on.\n\n##### JavaScript\n\n```js\nexports.fn = (a, b) => a + b;\n```\n\n##### C++\n\n```cpp\nusing Nan::To;\nusing v8::Local;\nusing v8::Object;\n\n// void Fn(FunctionCallbackInfo<Value>& info)\nNAN_METHOD(Fn) {\n  double a = To<double>(info[0]).FromJust();\n  double b = To<double>(info[1]).FromJust();\n\n  info.GetReturnValue().Set(a + b);\n}\n\n// void Init(Local<Object> target)\nNAN_MODULE_INIT(Init) {\n  NODE_SET_METHOD(target, Fn);\n}\n\n// First argument would be the entry file's name\nNODE_MODULE(addon, Init);\n```\n\n---\n\nAs you can see when dealing with v8 explicitly is a time consuming process which requires you to do lots of extra-work. With that said, keep in mind that only a small portion of your code is gonna interact with the engine since the core logic should be written using native C++ and other third-party libraries. You always need to find the right balance. Always make sure that your add-on doesn't require too much data to be passed otherwise the conversion process is gonna be hard and inefficient, and think twice before you choose this approach for the sake of simplicity. Overall the estimated optimization should be around 150% and up, depends on the task, first check your JavaScript code snippet, check for unnecessary logic and optimize it, and if you're really sure that it is fully optimized and you're still striving for more performance, *only then* move to C++.\n\nSo far I went through the very basics which will help you create this bridge between the two platforms. The v8 lacks of detailed documentation, tutorials and examples. [Nan](https://github.com/nodejs/nan) however is a bit more documented IMHO, so when I approach the API documentation I would start from there, and if I didn't find anything useful I would look at [v8's latest API docs](https://v8docs.nodesource.com/). It's not a hard material to learn but it's different so it might be a bit challenging for some, but remember, practice practice practice.\n\nSpeaking of practice, let's move on to the next step where we gonna implement our first add-on for distance calculation between two points."
          },
          {
            "manualTitle": "Step 3: Creating the add-on",
            "stepRevision": "248648638eac93e0c153105afc91f2fdb1704863",
            "manualView": "In this step we will base our development process on the TDD methodology, so you will have a chance to look at the final target API that we desire. We will start by writing a test file:\n\n[{]: <helper> (diffStep 3.1)\n\n#### [Step 3.1: Add test file](https://github.com/DAB0mB/node-distance-addon/commit/7809332)\n\n##### Added .npmignore\n```diff\n@@ -0,0 +1 @@\n+┊ ┊1┊test.js🚫↵\n```\n\n##### Added test.js\n```diff\n@@ -0,0 +1,23 @@\n+┊  ┊ 1┊const Distance = require('.');\n+┊  ┊ 2┊\n+┊  ┊ 3┊let result;\n+┊  ┊ 4┊let pointA = { x: 0, y: 0 };\n+┊  ┊ 5┊let pointB = { x: 3, y: 4 };\n+┊  ┊ 6┊\n+┊  ┊ 7┊result = Distance.calculate.sync(pointA, pointB);\n+┊  ┊ 8┊\n+┊  ┊ 9┊if (result !== 5) throw Error(\n+┊  ┊10┊  '#Sync: Result expected to equal 5 but instead got ' + result\n+┊  ┊11┊);\n+┊  ┊12┊\n+┊  ┊13┊console.log('sync calculation passed');\n+┊  ┊14┊\n+┊  ┊15┊result = Distance.calculate.async(pointA, pointB, (err, result) => {\n+┊  ┊16┊  if (err) throw err;\n+┊  ┊17┊\n+┊  ┊18┊  if (result !== 5) throw Error(\n+┊  ┊19┊    '#Async: Result expected to equal 5 but instead got ' + result\n+┊  ┊20┊  );\n+┊  ┊21┊\n+┊  ┊22┊  console.log('async calculation passed');\n+┊  ┊23┊});🚫↵\n```\n\n[}]: #\n\nAnd the following NPM script should execute it:\n\n[{]: <helper> (diffStep 3.2)\n\n#### [Step 3.2: Add npm test script](https://github.com/DAB0mB/node-distance-addon/commit/f683a13)\n\n##### Changed package.json\n```diff\n@@ -6,5 +6,8 @@\n ┊ 6┊ 6┊  \"repository\": {\n ┊ 7┊ 7┊    \"type\": \"git\",\n ┊ 8┊ 8┊    \"url\": \"https://DAB0mB@github.com/DAB0mB/node-distance-addon.git\"\n+┊  ┊ 9┊  },\n+┊  ┊10┊  \"scripts\": {\n+┊  ┊11┊    \"test\": \"node test\"\n ┊ 9┊12┊  }\n ┊10┊13┊}\n```\n\n[}]: #\n\nLike I said in the introduction, it's a simple module which can calculate the distance between 2 given points. `calculate.sync` can do it synchronously and `calculate.async` can do it asynchronously. Now that you got the idea we will start configuring our add-on.\n\nThe first thing you'll need to do is to make sure that you have `node-gyp` installed:\n\n    $ sudo npm install -g node-gyp\n\n`node-gyp` is also dependent on many other packages, so before you go any further please take a look at the official installation instructions in their [README.md file](https://github.com/nodejs/node-gyp).\n\nAssuming that you have installed everything properly, we will now need to create a `binding.gyp` file:\n\n[{]: <helper> (diffStep 3.3 files=\"binding.gyp\")\n\n#### [Step 3.3: Create &#x27;binding.gyp&#x27; file](https://github.com/DAB0mB/node-distance-addon/commit/1849cfb)\n\n##### Added binding.gyp\n```diff\n@@ -0,0 +1,11 @@\n+┊  ┊ 1┊{\n+┊  ┊ 2┊  \"targets\": [\n+┊  ┊ 3┊    {\n+┊  ┊ 4┊      \"target_name\": \"distance\",\n+┊  ┊ 5┊      \"sources\": [\n+┊  ┊ 6┊        \"src/distance.cc\"\n+┊  ┊ 7┊      ],\n+┊  ┊ 8┊      \"include_dirs\": [\"<!(node -e \\\"require('nan')\\\")\"]\n+┊  ┊ 9┊    }\n+┊  ┊10┊  ]\n+┊  ┊11┊}🚫↵\n```\n\n[}]: #\n\nGYP stands for 'Generate Your Project' and was created by the Chromium team as a configuration file for building native projects. The configuration show above should be a good template for any future add-on you're looking to develop. Let's take a deeper look at it:\n\n- `target_name` - Specifies the output dir of our add-on, in which case it should be `build/Release/distance`.\n- `sources` - Should include **all** the cpp files that are associated with you add-on.\n- `include_dirs` - Additional dirs that should be included when building the add-on. If you'll run the given script in the terminal you'll get the node-module path for Nan, a library which we're interested in during the build process.\n\nMore information about GYP configuration can be found [here](https://gyp.gsrc.io/docs/UserDocumentation.md).\n\nBe sure to also add the specified flag to the `package.json` which basically says 'Hey, I have a GYP file which should be taken into consideration as well':\n\n[{]: <helper> (diffStep 3.3 files=\"package.json\")\n\n#### [Step 3.3: Create &#x27;binding.gyp&#x27; file](https://github.com/DAB0mB/node-distance-addon/commit/1849cfb)\n\n##### Changed package.json\n```diff\n@@ -7,6 +7,7 @@\n ┊ 7┊ 7┊    \"type\": \"git\",\n ┊ 8┊ 8┊    \"url\": \"https://DAB0mB@github.com/DAB0mB/node-distance-addon.git\"\n ┊ 9┊ 9┊  },\n+┊  ┊10┊  \"gypfile\": true,\n ┊10┊11┊  \"scripts\": {\n ┊11┊12┊    \"test\": \"node test\"\n ┊12┊13┊  }\n```\n\n[}]: #\n\nNow we will add the following NPM scripts so whenever we run `npm run build` our project will be built:\n\n[{]: <helper> (diffStep 3.4)\n\n#### [Step 3.4: Add npm build scripts](https://github.com/DAB0mB/node-distance-addon/commit/74f2ad8)\n\n##### Changed .gitignore\n```diff\n@@ -1 +1,2 @@\n+┊ ┊1┊build\n ┊1┊2┊node_modules🚫↵\n```\n\n##### Changed package.json\n```diff\n@@ -9,6 +9,8 @@\n ┊ 9┊ 9┊  },\n ┊10┊10┊  \"gypfile\": true,\n ┊11┊11┊  \"scripts\": {\n-┊12┊  ┊    \"test\": \"node test\"\n+┊  ┊12┊    \"pre-publish\": \"npm run build\",\n+┊  ┊13┊    \"build\": \"node-gyp rebuild\",\n+┊  ┊14┊    \"test\": \"npm run build && node test\"\n ┊13┊15┊  }\n ┊14┊16┊}\n```\n\n[}]: #\n\nThe only thing left to do before jumping into implementation would be installing Nan:\n\n    $ npm install nan --save\n\nThe basis for build process is set. We will create the entry file for our add-on:\n\n[{]: <helper> (diffStep 3.6)\n\n#### [Step 3.6: Create add-on entry file](https://github.com/DAB0mB/node-distance-addon/commit/999ff94)\n\n##### Added src&#x2F;distance.cc\n```diff\n@@ -0,0 +1,8 @@\n+┊ ┊1┊#include <nan.h>\n+┊ ┊2┊#include <v8.h>\n+┊ ┊3┊\n+┊ ┊4┊NAN_MODULE_INIT(Init) {\n+┊ ┊5┊\n+┊ ┊6┊}\n+┊ ┊7┊\n+┊ ┊8┊NODE_MODULE(distance, Init)🚫↵\n```\n\n[}]: #\n\nEvery add-on should start with these two macro calls. They are both compiled into a piece of code which will register our module with ease. The `NODE_MODULE` macro template accepts the name of the target as the first argument (That one we set as `target_name` in the GYP file, remember?) and the initialization method for our module. The `NAN_MODULE_INIT` generates a function with the given name. It accepts `target` as the first argument which is equivalent to NodeJS's `exports`. Now we will create our first method stub for a synchronous distance calculation:\n\n[{]: <helper> (diffStep 3.7)\n\n#### [Step 3.7: Create &#x27;CalculateSync&#x27; method stub](https://github.com/DAB0mB/node-distance-addon/commit/a67f6e0)\n\n##### Changed src&#x2F;distance.cc\n```diff\n@@ -1,8 +1,12 @@\n ┊ 1┊ 1┊#include <nan.h>\n ┊ 2┊ 2┊#include <v8.h>\n ┊ 3┊ 3┊\n-┊ 4┊  ┊NAN_MODULE_INIT(Init) {\n+┊  ┊ 4┊NAN_METHOD(CalculateSync) {\n+┊  ┊ 5┊\n+┊  ┊ 6┊}\n ┊ 5┊ 7┊\n+┊  ┊ 8┊NAN_MODULE_INIT(Init) {\n+┊  ┊ 9┊  NAN_EXPORT(target, CalculateSync);\n ┊ 6┊10┊}\n ┊ 7┊11┊\n ┊ 8┊12┊NODE_MODULE(distance, Init)🚫↵\n```\n\n[}]: #\n\nWe exported the `CalculateSync` by using the `NAN_EXPORT` macro, and we used `NAN_METHOD` to define a new node-valid function. It accepts `info` as the first argument and it is the same as JavaScript's `arguments` vector. We already know which arguments this function should accept, that's why I followed TDD methodology from the first place:\n\n[{]: <helper> (diffStep 3.8)\n\n#### [Step 3.8: Destructure arguments vector](https://github.com/DAB0mB/node-distance-addon/commit/208d53d)\n\n##### Changed src&#x2F;distance.cc\n```diff\n@@ -1,8 +1,13 @@\n ┊ 1┊ 1┊#include <nan.h>\n ┊ 2┊ 2┊#include <v8.h>\n ┊ 3┊ 3┊\n-┊ 4┊  ┊NAN_METHOD(CalculateSync) {\n+┊  ┊ 4┊using Nan::To;\n+┊  ┊ 5┊using v8::Local;\n+┊  ┊ 6┊using v8::Object;\n ┊ 5┊ 7┊\n+┊  ┊ 8┊NAN_METHOD(CalculateSync) {\n+┊  ┊ 9┊  Local<Object> js_pointA = To<Object>(info[0]).ToLocalChecked();\n+┊  ┊10┊  Local<Object> js_pointB = To<Object>(info[1]).ToLocalChecked();\n ┊ 6┊11┊}\n ┊ 7┊12┊\n ┊ 8┊13┊NAN_MODULE_INIT(Init) {\n```\n\n[}]: #\n\nWe use the `To()` function to convert the first argument into the desired type, and then we call the method `ToLocalChecked()`. This method is simply going to convert the result into v8's Local, unless the argument is undefined, in which case an error is going to be thrown. I like to prefix JS object with a `js_` so I know with what kind variable I'm dealing with. We should have two points containing `x` and `y` fields. Let's try to extract them out of the arguments vector and convert them into native C++ structures:\n\n[{]: <helper> (diffStep 3.9)\n\n#### [Step 3.9: Convert JS objects to native C++ structures](https://github.com/DAB0mB/node-distance-addon/commit/5c29c8e)\n\n##### Changed src&#x2F;distance.cc\n```diff\n@@ -1,13 +1,28 @@\n ┊ 1┊ 1┊#include <nan.h>\n ┊ 2┊ 2┊#include <v8.h>\n ┊ 3┊ 3┊\n+┊  ┊ 4┊using Nan::New;\n ┊ 4┊ 5┊using Nan::To;\n ┊ 5┊ 6┊using v8::Local;\n ┊ 6┊ 7┊using v8::Object;\n+┊  ┊ 8┊using v8::String;\n+┊  ┊ 9┊\n+┊  ┊10┊struct Point {\n+┊  ┊11┊  double x;\n+┊  ┊12┊  double y;\n+┊  ┊13┊};\n ┊ 7┊14┊\n ┊ 8┊15┊NAN_METHOD(CalculateSync) {\n ┊ 9┊16┊  Local<Object> js_pointA = To<Object>(info[0]).ToLocalChecked();\n ┊10┊17┊  Local<Object> js_pointB = To<Object>(info[1]).ToLocalChecked();\n+┊  ┊18┊\n+┊  ┊19┊  Point* pointA = new Point();\n+┊  ┊20┊  pointA->x = To<double>(js_pointA->Get(New<String>(\"x\").ToLocalChecked())).FromJust();\n+┊  ┊21┊  pointA->y = To<double>(js_pointA->Get(New<String>(\"y\").ToLocalChecked())).FromJust();\n+┊  ┊22┊\n+┊  ┊23┊  Point* pointB = new Point();\n+┊  ┊24┊  pointB->x = To<double>(js_pointB->Get(New<String>(\"x\").ToLocalChecked())).FromJust();\n+┊  ┊25┊  pointB->y = To<double>(js_pointB->Get(New<String>(\"y\").ToLocalChecked())).FromJust();\n ┊11┊26┊}\n ┊12┊27┊\n ┊13┊28┊NAN_MODULE_INIT(Init) {\n```\n\n[}]: #\n\nThen again we convert the `To()` function to convert the result into the desired data-type, only this time it's a primitive, so we use `FromJust()` instead of `ToLocalChecked()`. Note that v8 only uses double precision rather than a floating point. We can fetch properties from a given JS object with ease using the `Get()` method. Pay attention to use the `->` rather than a period because remember, a Local is actually a pointer! It is not the actual object.\n\nNow all is left to do is defining the return value. Keep in mind that the value should be returned through v8's current scope, not natively, so using the `return` keyword would be useless. The return value can actually be defined through the provided `info` argument, like this:\n\n[{]: <helper> (diffStep \"3.10\")\n\n#### [Step 3.10: Add return value to &#x27;CalculateSync&#x27; method](https://github.com/DAB0mB/node-distance-addon/commit/a87ded4)\n\n##### Changed src&#x2F;distance.cc\n```diff\n@@ -23,6 +23,8 @@\n ┊23┊23┊  Point* pointB = new Point();\n ┊24┊24┊  pointB->x = To<double>(js_pointB->Get(New<String>(\"x\").ToLocalChecked())).FromJust();\n ┊25┊25┊  pointB->y = To<double>(js_pointB->Get(New<String>(\"y\").ToLocalChecked())).FromJust();\n+┊  ┊26┊\n+┊  ┊27┊  info.GetReturnValue().Set(CalculateDistance(pointA, pointB));\n ┊26┊28┊}\n ┊27┊29┊\n ┊28┊30┊NAN_MODULE_INIT(Init) {\n```\n\n[}]: #\n\nAnd of-course it requires us to add the core distance calculation method:\n\n[{]: <helper> (diffStep 3.11)\n\n#### [Step 3.11: Add core distance calculation method](https://github.com/DAB0mB/node-distance-addon/commit/c7ffb4a)\n\n##### Changed src&#x2F;distance.cc\n```diff\n@@ -1,8 +1,12 @@\n+┊  ┊ 1┊#include <cstdlib>\n+┊  ┊ 2┊#include <cmath>\n ┊ 1┊ 3┊#include <nan.h>\n ┊ 2┊ 4┊#include <v8.h>\n ┊ 3┊ 5┊\n ┊ 4┊ 6┊using Nan::New;\n ┊ 5┊ 7┊using Nan::To;\n+┊  ┊ 8┊using std::pow;\n+┊  ┊ 9┊using std::sqrt;\n ┊ 6┊10┊using v8::Local;\n ┊ 7┊11┊using v8::Object;\n ┊ 8┊12┊using v8::String;\n```\n```diff\n@@ -12,6 +16,10 @@\n ┊12┊16┊  double y;\n ┊13┊17┊};\n ┊14┊18┊\n+┊  ┊19┊double CalculateDistance(Point* pointA, Point* pointB) {\n+┊  ┊20┊  return sqrt(pow(pointA->x - pointB->x, 2) + pow(pointA->y - pointB->y, 2));\n+┊  ┊21┊}\n+┊  ┊22┊\n ┊15┊23┊NAN_METHOD(CalculateSync) {\n ┊16┊24┊  Local<Object> js_pointA = To<Object>(info[0]).ToLocalChecked();\n ┊17┊25┊  Local<Object> js_pointB = To<Object>(info[1]).ToLocalChecked();\n```\n\n[}]: #\n\nThis is it for the synchronous calculation. Now we will add an async version of it. We will start by creating a method with everything we learned so far until the point where we have to return the result:\n\n[{]: <helper> (diffStep 3.12)\n\n#### [Step 3.12: Create &#x27;CalculateAsync&#x27; method with basic deconstructuring](https://github.com/DAB0mB/node-distance-addon/commit/0010ef8)\n\n##### Changed src&#x2F;distance.cc\n```diff\n@@ -35,8 +35,22 @@\n ┊35┊35┊  info.GetReturnValue().Set(CalculateDistance(pointA, pointB));\n ┊36┊36┊}\n ┊37┊37┊\n+┊  ┊38┊NAN_METHOD(CalculateAsync) {\n+┊  ┊39┊  Local<Object> js_pointA = To<Object>(info[0]).ToLocalChecked();\n+┊  ┊40┊  Local<Object> js_pointB = To<Object>(info[1]).ToLocalChecked();\n+┊  ┊41┊\n+┊  ┊42┊  Point* pointA = new Point();\n+┊  ┊43┊  pointA->x = To<double>(js_pointA->Get(New<String>(\"x\").ToLocalChecked())).FromJust();\n+┊  ┊44┊  pointA->y = To<double>(js_pointA->Get(New<String>(\"y\").ToLocalChecked())).FromJust();\n+┊  ┊45┊\n+┊  ┊46┊  Point* pointB = new Point();\n+┊  ┊47┊  pointB->x = To<double>(js_pointB->Get(New<String>(\"x\").ToLocalChecked())).FromJust();\n+┊  ┊48┊  pointB->y = To<double>(js_pointB->Get(New<String>(\"y\").ToLocalChecked())).FromJust();\n+┊  ┊49┊}\n+┊  ┊50┊\n ┊38┊51┊NAN_MODULE_INIT(Init) {\n ┊39┊52┊  NAN_EXPORT(target, CalculateSync);\n+┊  ┊53┊  NAN_EXPORT(target, CalculateAsync);\n ┊40┊54┊}\n ┊41┊55┊\n ┊42┊56┊NODE_MODULE(distance, Init)🚫↵\n```\n\n[}]: #\n\nHere's the different part. We don't wanna simply return the value, we want to make the calculations in parallel with the event loop, and once we're finished we will interact with it once again. In our model there are two threads. The first thread is the event loop thread, and the second thread will be a worker thread managed by Nan, the library supports asynchronous I/O in NodeJS. Let's start implementing and I will give some more explanations as we go further:\n\n[{]: <helper> (diffStep 3.13)\n\n#### [Step 3.13: Queue distance worker](https://github.com/DAB0mB/node-distance-addon/commit/c76c090)\n\n##### Changed src&#x2F;distance.cc\n```diff\n@@ -3,10 +3,14 @@\n ┊ 3┊ 3┊#include <nan.h>\n ┊ 4┊ 4┊#include <v8.h>\n ┊ 5┊ 5┊\n+┊  ┊ 6┊using Nan::AsyncQueueWorker;\n+┊  ┊ 7┊using Nan::AsyncWorker;\n+┊  ┊ 8┊using Nan::Callback;\n ┊ 6┊ 9┊using Nan::New;\n ┊ 7┊10┊using Nan::To;\n ┊ 8┊11┊using std::pow;\n ┊ 9┊12┊using std::sqrt;\n+┊  ┊13┊using v8::Function;\n ┊10┊14┊using v8::Local;\n ┊11┊15┊using v8::Object;\n ┊12┊16┊using v8::String;\n```\n```diff\n@@ -38,6 +42,7 @@\n ┊38┊42┊NAN_METHOD(CalculateAsync) {\n ┊39┊43┊  Local<Object> js_pointA = To<Object>(info[0]).ToLocalChecked();\n ┊40┊44┊  Local<Object> js_pointB = To<Object>(info[1]).ToLocalChecked();\n+┊  ┊45┊  Callback* callback = new Callback(info[2].As<Function>());\n ┊41┊46┊\n ┊42┊47┊  Point* pointA = new Point();\n ┊43┊48┊  pointA->x = To<double>(js_pointA->Get(New<String>(\"x\").ToLocalChecked())).FromJust();\n```\n```diff\n@@ -46,6 +51,8 @@\n ┊46┊51┊  Point* pointB = new Point();\n ┊47┊52┊  pointB->x = To<double>(js_pointB->Get(New<String>(\"x\").ToLocalChecked())).FromJust();\n ┊48┊53┊  pointB->y = To<double>(js_pointB->Get(New<String>(\"y\").ToLocalChecked())).FromJust();\n+┊  ┊54┊\n+┊  ┊55┊  AsyncQueueWorker(new DistanceWorker(callback, pointA, pointB));\n ┊49┊56┊}\n ┊50┊57┊\n ┊51┊58┊NAN_MODULE_INIT(Init) {\n```\n\n[}]: #\n\nHere we fetch the third argument which is the callback. We wrap it with Nan's Callback, which will make sure it is not garbage collected once the scope is being deleted, we want it to keep living until it's not relevant. At the bottom of the method, instead of returning a value explicitly, we queue our `DistanceWorker` into the workers queue. On that note, let's implement the DistanceWorker:\n\n[{]: <helper> (diffStep 3.14)\n\n#### [Step 3.14: Create &#x27;DistanceWorker&#x27; with a constructor and a deconstructor](https://github.com/DAB0mB/node-distance-addon/commit/7af276b)\n\n##### Changed src&#x2F;distance.cc\n```diff\n@@ -24,6 +24,29 @@\n ┊24┊24┊  return sqrt(pow(pointA->x - pointB->x, 2) + pow(pointA->y - pointB->y, 2));\n ┊25┊25┊}\n ┊26┊26┊\n+┊  ┊27┊class DistanceWorker : public AsyncWorker {\n+┊  ┊28┊ private:\n+┊  ┊29┊  Point* pointA;\n+┊  ┊30┊  Point* pointB;\n+┊  ┊31┊\n+┊  ┊32┊ public:\n+┊  ┊33┊  DistanceWorker(Callback* callback, Point* pointA, Point* pointB) :\n+┊  ┊34┊    AsyncWorker(callback), pointA(pointA), pointB(pointB) {}\n+┊  ┊35┊\n+┊  ┊36┊  ~DistanceWorker() {\n+┊  ┊37┊    delete pointA;\n+┊  ┊38┊    delete pointB;\n+┊  ┊39┊  }\n+┊  ┊40┊\n+┊  ┊41┊  void Execute () {\n+┊  ┊42┊\n+┊  ┊43┊  }\n+┊  ┊44┊\n+┊  ┊45┊  void HandleOKCallback () {\n+┊  ┊46┊\n+┊  ┊47┊  }\n+┊  ┊48┊};\n+┊  ┊49┊\n ┊27┊50┊NAN_METHOD(CalculateSync) {\n ┊28┊51┊  Local<Object> js_pointA = To<Object>(info[0]).ToLocalChecked();\n ┊29┊52┊  Local<Object> js_pointB = To<Object>(info[1]).ToLocalChecked();\n```\n\n[}]: #\n\n`AsyncWorker` is an abstract class that you can subclass to have much of the annoying asynchronous queuing and handling taken care of for you. It can even store arbitrary v8 objects for you and have them persist while the asynchronous work is in progress. The `execute()` method is being executed inside the worker-thread. It is not safe to access V8, or V8 data structures there, so everything we need for input and output should go on 'this'. The `HandleOKCallback()` method is executed when the async work is complete. This function will be run inside the main event loop so it is safe to use v8 again. Let's implement the core distance calculation on the worker thread:\n\n[{]: <helper> (diffStep 3.15)\n\n#### [Step 3.15: Execute distance calculation](https://github.com/DAB0mB/node-distance-addon/commit/a812319)\n\n##### Changed src&#x2F;distance.cc\n```diff\n@@ -26,6 +26,7 @@\n ┊26┊26┊\n ┊27┊27┊class DistanceWorker : public AsyncWorker {\n ┊28┊28┊ private:\n+┊  ┊29┊  double distance;\n ┊29┊30┊  Point* pointA;\n ┊30┊31┊  Point* pointB;\n ┊31┊32┊\n```\n```diff\n@@ -39,7 +40,7 @@\n ┊39┊40┊  }\n ┊40┊41┊\n ┊41┊42┊  void Execute () {\n-┊42┊  ┊\n+┊  ┊43┊    distance = CalculateDistance(pointA, pointB);\n ┊43┊44┊  }\n ┊44┊45┊\n ┊45┊46┊  void HandleOKCallback () {\n```\n\n[}]: #\n\nAnd handle a successful invocation once the calculation is finished:\n\n[{]: <helper> (diffStep 3.16)\n\n#### [Step 3.16: Handle successful invokation](https://github.com/DAB0mB/node-distance-addon/commit/5af7f59)\n\n##### Changed src&#x2F;distance.cc\n```diff\n@@ -6,14 +6,18 @@\n ┊ 6┊ 6┊using Nan::AsyncQueueWorker;\n ┊ 7┊ 7┊using Nan::AsyncWorker;\n ┊ 8┊ 8┊using Nan::Callback;\n+┊  ┊ 9┊using Nan::HandleScope;\n ┊ 9┊10┊using Nan::New;\n+┊  ┊11┊using Nan::Null;\n ┊10┊12┊using Nan::To;\n ┊11┊13┊using std::pow;\n ┊12┊14┊using std::sqrt;\n ┊13┊15┊using v8::Function;\n ┊14┊16┊using v8::Local;\n+┊  ┊17┊using v8::Number;\n ┊15┊18┊using v8::Object;\n ┊16┊19┊using v8::String;\n+┊  ┊20┊using v8::Value;\n ┊17┊21┊\n ┊18┊22┊struct Point {\n ┊19┊23┊  double x;\n```\n```diff\n@@ -44,7 +48,14 @@\n ┊44┊48┊  }\n ┊45┊49┊\n ┊46┊50┊  void HandleOKCallback () {\n+┊  ┊51┊    HandleScope scope;\n ┊47┊52┊\n+┊  ┊53┊    Local<Value> argv[] = {\n+┊  ┊54┊      Null(),\n+┊  ┊55┊      New<Number>(distance)\n+┊  ┊56┊    };\n+┊  ┊57┊\n+┊  ┊58┊    callback->Call(2, argv);\n ┊48┊59┊  }\n ┊49┊60┊};\n```\n\n[}]: #\n\nNormally, when defining a NodeJS method (`NAN_METHOD` macro) a scope will be created for us automatically. In this function's context there is no scope exist, so we will have to create it using the `HandleScope` deceleration (The current scope is stored globally so even though we don't use it explicitly, v8 and Nan know what to do). We also created an arguments vector as the return value, following NodeJS's conventions, the first argument would be the error and the second argument would be the result.\n\nThis is it! Finally we will transform the add-on into a nicer looking node-module:\n\n[{]: <helper> (diffStep 3.17)\n\n#### [Step 3.17: Transform add-on into a nicer looking node-module](https://github.com/DAB0mB/node-distance-addon/commit/2f81b05)\n\n##### Added index.js\n```diff\n@@ -0,0 +1,6 @@\n+┊ ┊1┊const Distance = require('./build/Release/distance');\n+┊ ┊2┊\n+┊ ┊3┊exports.calculate = {\n+┊ ┊4┊  sync: Distance.CalculateSync,\n+┊ ┊5┊  async: Distance.CalculateAsync\n+┊ ┊6┊};🚫↵\n```\n\n[}]: #\n\nAnd now, let's run our small test to see that it works, using the following command:\n\n    $ npm run test\n\nIf everything went well, you should have the following messages printed to the terminal:\n\n    sync calculation passed\n    async calculation passed\n\nThat's it. You've just learned the very basics of how to use C++ within NodeJS. There's a lot more to learn when it comes to building an add-on, and I'm not just talking about learning v8 and Nan's API. Think about the possibilities, the C++ community have been active for years and there are so much great libraries out there that are not necessarily relevant to NodeJS due to its efficiency, like [Boost](http://www.boost.org/), [OpenCV](http://opencv.org/), [CGAL](http://www.cgal.org/) and many more.\n\nThis tutorial didn't focus on algorithmics obviously, but it's a good starting point though. Take it from here, and unleash your creativity!"
          }
        ]
      },
      {
        "releaseVersion": "1.0.0",
        "releaseDate": "2018-08-27 03:18:52 +0800",
        "tagName": "master@1.0.0",
        "tagRevision": "257db03f78c0281303e50f8d298b7accd420239a",
        "historyRevision": "d8f5b1fd8d4823bca227a89beea8476b7d08333d",
        "changesDiff": "diff --git a/.gitignore b/.gitignore\nnew file mode 100644\nindex 0000000..48912d2\n--- /dev/null\n+++ b/.gitignore\n@@ -0,0 +1,2 @@\n+build\n+node_modules\n\\ No newline at end of file\ndiff --git a/.npmignore b/.npmignore\nnew file mode 100644\nindex 0000000..602eb8e\n--- /dev/null\n+++ b/.npmignore\n@@ -0,0 +1 @@\n+test.js\n\\ No newline at end of file\ndiff --git a/.tortilla/manuals/templates/root.tmpl b/.tortilla/manuals/templates/root.tmpl\nnew file mode 100644\nindex 0000000..6a69936\n--- /dev/null\n+++ b/.tortilla/manuals/templates/root.tmpl\n@@ -0,0 +1,11 @@\n+In this tutorial we gonna go through the basics on how to write a native add-on to NodeJS using C++, one of the platform's most powerful capabilities of which most web/JS developers now a days are not even familiar with.\n+\n+For somewhat there is a vacuum which got created around C++ in the recent years, people are so scared from a low-level back-end programming, why should they even deal with memory allocation dilemmas when there are all these interpretation languages like Python, Ruby, and JavaScript who can do that for us? Well folks, once you will realize that all these single web-page application third-party libraries and frameworks are all recycled and repetitive, and you will start doing some real shit by optimizing some heavy-ass machine algorithms, you will realize that **performance is critic**, a title which doesn't really suit NodeJS, with all the love and respect. So why do I even bother making this tutorial? Because people are unaware of many features in the programming world, and the beauty of algorithmics. And why am I even approaching NodeJS developers? Because they have the biggest, most-popular community of all, they have a lot to learn, but they are very open minded, and that's the most important thing. You don't have to be a C++ developer not at all, but if I can at least catch a small part of your attention I will be overwhelmed.\n+\n+We will create a very small and simple module which calculates the distance between two dots, it can do it either synchronously or asynchronously. The algorithm for calculating the distance between a given `pointA` and `pointB` in a 2D [Cartesian coordinate system](https://en.wikipedia.org/wiki/Cartesian_coordinate_system) looks like this:\n+\n+    √[(pointAX - pointBX)^2 + (pointAY - pointBY)^2]\n+\n+Probably not too complicated, kicks me back to the glamorous days in high-school. If put in JavaScript it should take around 10 seconds right? Well in a native NodeJS add-on it should be a bit longer. Of-course when it comes to small logics you shouldn't make too much effort, because it will consume more power only converting all JS objects into C++ native structures. But imagine you would like to run a [blob-detection](https://en.wikipedia.org/wiki/Blob_detection) algorithm and you would like to calculate the [center of mass](https://en.wikipedia.org/wiki/Center_of_mass) of multiple blobs, in C++ it would be much faster, especially when using [shaders](https://en.wikipedia.org/wiki/Shader). Anyways that's not the point of this tutorial, the point is that you will be provided with the necessary tools so next time if you would like to write some heavy logic, you will know how to do it.\n+\n+We will start with a brief introduction for Google's [v8 engine](https://en.wikipedia.org/wiki/V8_(JavaScript_engine)) and some practical examples on how to use it, this will help us getting start, and then we will write our add-on. Let's begin then shall we?\ndiff --git a/.tortilla/manuals/templates/step1.tmpl b/.tortilla/manuals/templates/step1.tmpl\nnew file mode 100644\nindex 0000000..d6acdb6\n--- /dev/null\n+++ b/.tortilla/manuals/templates/step1.tmpl\n@@ -0,0 +1,155 @@\n+![v8-logo](https://cloud.githubusercontent.com/assets/7648874/20428176/d766fba8-ad6e-11e6-884f-badc847d5e24.png)\n+\n+The v8 JavaScript Engine is an open source JavaScript engine developed by The [Chromium Project](https://www.chromium.org/) for the [Google Chrome web browser](https://www.google.com/chrome/). It is intended to be used both in a browser and as a standalone high-performance engine that can be integrated into independent projects like [Couchbase](http://www.couchbase.com/), [MongoDB](https://www.mongodb.com/) and [Node.js](https://nodejs.org/). There lots of benchmarks out there but I will not bore you with diagrams, we all know that that this engine has proven itself to be worthy and it is being used world-widely and probably for a good reason.\n+\n+> \"Ambition is a dream with a v8 engine\" -Elvis Presley.\n+\n+If you're a JavaScript developer you must be familiar with the event-loop and the scoping system of v8, so it's a good thing that you understand the concept, but you never got to actually look at its source code and explicitly use it. A detailed documentation for v8's different API versions is available [here](https://v8docs.nodesource.com/). I assume that you don't bother reading any of my references that I provide along this tutorial (As a lazy blog-reader myself), I will post here that first thing you gonna see once you enter v8's documentation web-site:\n+\n+![v8-docs](https://cloud.githubusercontent.com/assets/7648874/20429800/ffeb3a4a-ad77-11e6-8fae-d892304169db.jpg)\n+\n+Throughout history v8 have changed a lot and it wore many forms. As a result, add-ons are not usable across different versions of the platform since each one supports a different API, which will break our process during run-time. In NodeJS team they came up with a very convenient solution called [Nan](https://github.com/nodejs/nan). Nan stands for \"Native Abstractions for NodeJS\" and is basically a header file filled with macro and utility goodness for making add-on development for NodeJS easier across all versions of v8, without inspecting `NODE_MODULE_VERSION` macro all the time. In this tutorial I'm gonna refer both of them as if they are bundled in a single framework.\n+\n+Eventually JavaScript is just a rehash of v8, everything you know so far is still valid but it uses a different idiom. To prevent some misconceptions, here are some important points regards JavaScript's equivalents which I think you should follow:\n+\n+#### Scopes and Variables\n+\n+In v8 a scope is referred as `Isolate` (`v8::Isolate`) and a variable is referred as `Local` (`v8::Local<T>`). A local is a pointer to an object. All v8 objects are accessed using locals, they are necessary because of the way the v8 garbage collector works. An isolate can be thought of as a container for any number of locals. When you've finished with your locals, instead of deleting each one individually you can simply delete their scope.\n+\n+##### JavaScript\n+\n+```js\n+let obj = {\n+  foo: 'foo',\n+  bar: 'bar',\n+  baz: 'baz'\n+};\n+\n+console.log(obj.foo);\n+console.log(obj.bar);\n+console.log(obj.baz);\n+```\n+\n+##### C++\n+\n+```cpp\n+using Nan::New;\n+using std::cendl;\n+using std::cout;\n+using v8::Local;\n+using v8::Object;\n+using v8::String;\n+\n+Local<Object> obj = New<Object>();\n+\n+obj->Set(New<String>(\"foo\").ToLocalChecked(), New<String>(\"foo\").ToLocalChecked());\n+obj->Set(New<String>(\"bar\").ToLocalChecked(), New<String>(\"bar\").ToLocalChecked());\n+obj->Set(New<String>(\"baz\").ToLocalChecked(), New<String>(\"baz\").ToLocalChecked());\n+\n+cout << obj->Get(New<String>(\"foo\").ToLocalChecked()) << cendl;\n+cout << obj->Get(New<String>(\"bar\").ToLocalChecked()) << cendl;\n+cout << obj->Get(New<String>(\"baz\").ToLocalChecked()) << cendl;\n+```\n+\n+#### Asynchronous Callbacks\n+\n+Asynchronous logic can be implemented using the `AsyncWorker` (`Nan::AsyncWorker`) and invoked by `AsyncQueueWorker` (`Nan::AsyncQueueWorker`). Thanks to these two you can have much of the annoying asynchronous queuing and handling taken care of for you. It can even store arbitrary V8 objects for you and have them persist while the asynchronous work is in progress.\n+\n+##### JavaScript\n+\n+```js\n+setImmediate(() => {\n+  callback(null, 'result');\n+});\n+```\n+\n+##### C++\n+\n+```cpp\n+using Nan::AsyncQueueWorker;\n+using Nan::AsyncWorker;\n+using Nan::HandleScope;\n+using Nan::New;\n+using Nan::Null;\n+using std::string;\n+using v8::Local;\n+using v8::String;\n+\n+class ResultWorker : AsyncWorker {\n+ private:\n+  string* result\n+\n+ public:\n+  ResultWorker(Callback* callback) : AsyncWorker(callback) {}\n+\n+  ~ResultDistance() {\n+    delete result;\n+  }\n+\n+  // Executed inside the worker-thread.\n+  // It is not safe to access V8, or V8 data structures\n+  // here, so everything we need for input and output\n+  // should go on 'this'.\n+  void Execute () {\n+    result = new string(\"result\");\n+  }\n+\n+  // Executed when the async work is complete.\n+  // This function will be run inside the main event loop\n+  // so it is safe to use V8 again.\n+  void HandleOKCallback () {\n+    HandleScope scope;\n+\n+    Local<Value> argv[] = {\n+      Null(),\n+      New<String>(result).ToLocalChecked()\n+    };\n+\n+    callback->Call(2, argv);\n+  }\n+};\n+\n+AsyncQueueWorker(new ResultWorker(callback));\n+```\n+\n+#### Modules Registration and Methods Definition\n+\n+v8 and Nan provide us with some handy macros (`NODE_MODULE`, `NAN_MODULE_INIT`, `NAN_METHOD` and `NODE_SET_METHOD`) which will help us register a new NodeJS module and define its methods. This might be confusing for some, since we can't see the function's signature it would appear as if variables are just being magically created in the stack, but once the macros are being pre-processed they will just turn into ordinary functions. In the example below I commented the original signature so you can have more clew on what's going on.\n+\n+##### JavaScript\n+\n+```js\n+exports.fn = (a, b) => a + b;\n+```\n+\n+##### C++\n+\n+```cpp\n+using Nan::To;\n+using v8::Local;\n+using v8::Object;\n+\n+// void Fn(FunctionCallbackInfo<Value>& info)\n+NAN_METHOD(Fn) {\n+  double a = To<double>(info[0]).FromJust();\n+  double b = To<double>(info[1]).FromJust();\n+\n+  info.GetReturnValue().Set(a + b);\n+}\n+\n+// void Init(Local<Object> target)\n+NAN_MODULE_INIT(Init) {\n+  NODE_SET_METHOD(target, Fn);\n+}\n+\n+// First argument would be the entry file's name\n+NODE_MODULE(addon, Init);\n+```\n+\n+---\n+\n+As you can see when dealing with v8 explicitly is a time consuming process which requires you to do lots of extra-work. With that said, keep in mind that only a small portion of your code is gonna interact with the engine since the core logic should be written using native C++ and other third-party libraries. You always need to find the right balance. Always make sure that your add-on doesn't require too much data to be passed otherwise the conversion process is gonna be hard and inefficient, and think twice before you choose this approach for the sake of simplicity. Overall the estimated optimization should be around 150% and up, depends on the task, first check your JavaScript code snippet, check for unnecessary logic and optimize it, and if you're really sure that it is fully optimized and you're still striving for more performance, *only then* move to C++.\n+\n+So far I went through the very basics which will help you create this bridge between the two platforms. The v8 lacks of detailed documentation, tutorials and examples. [Nan](https://github.com/nodejs/nan) however is a bit more documented IMHO, so when I approach the API documentation I would start from there, and if I didn't find anything useful I would look at [v8's latest API docs](https://v8docs.nodesource.com/). It's not a hard material to learn but it's different so it might be a bit challenging for some, but remember, practice practice practice.\n+\n+Speaking of practice, let's move on to the next step where we gonna implement our first add-on for distance calculation between two points.\ndiff --git a/.tortilla/manuals/templates/step2.tmpl b/.tortilla/manuals/templates/step2.tmpl\nnew file mode 100644\nindex 0000000..b60230e\n--- /dev/null\n+++ b/.tortilla/manuals/templates/step2.tmpl\n@@ -0,0 +1,100 @@\n+In this step we will base our development process on the TDD methodology, so you will have a chance to look at the final target API that we desire. We will start by writing a test file:\n+\n+{{{diffStep 2.1}}}\n+\n+And the following NPM script should execute it:\n+\n+{{{diffStep 2.2}}}\n+\n+Like I said in the introduction, it's a simple module which can calculate the distance between 2 given points. `calculate.sync` can do it synchronously and `calculate.async` can do it asynchronously. Now that you got the idea we will start configuring our add-on.\n+\n+The first thing you'll need to do is to make sure that you have `node-gyp` installed:\n+\n+    $ sudo npm install -g node-gyp\n+\n+`node-gyp` is also dependent on many other packages, so before you go any further please take a look at the official installation instructions in their [README.md file](https://github.com/nodejs/node-gyp).\n+\n+Assuming that you have installed everything properly, we will now need to create a `binding.gyp` file:\n+\n+{{{diffStep 2.3 files=\"binding.gyp\"}}}\n+\n+GYP stands for 'Generate Your Project' and was created by the Chromium team as a configuration file for building native projects. The configuration show above should be a good template for any future add-on you're looking to develop. Let's take a deeper look at it:\n+\n+- `target_name` - Specifies the output dir of our add-on, in which case it should be `build/Release/distance`.\n+- `sources` - Should include **all** the cpp files that are associated with you add-on.\n+- `include_dirs` - Additional dirs that should be included when building the add-on. If you'll run the given script in the terminal you'll get the node-module path for Nan, a library which we're interested in during the build process.\n+\n+More information about GYP configuration can be found [here](https://gyp.gsrc.io/docs/UserDocumentation.md).\n+\n+Be sure to also add the specified flag to the `package.json` which basically says 'Hey, I have a GYP file which should be taken into consideration as well':\n+\n+{{{diffStep 2.3 files=\"package.json\"}}}\n+\n+Now we will add the following NPM scripts so whenever we run `npm run build` our project will be built:\n+\n+{{{diffStep 2.4}}}\n+\n+The only thing left to do before jumping into implementation would be installing Nan:\n+\n+    $ npm install nan --save\n+\n+The basis for build process is set. We will create the entry file for our add-on:\n+\n+{{{diffStep 2.6}}}\n+\n+Every add-on should start with these two macro calls. They are both compiled into a piece of code which will register our module with ease. The `NODE_MODULE` macro template accepts the name of the target as the first argument (That one we set as `target_name` in the GYP file, remember?) and the initialization method for our module. The `NAN_MODULE_INIT` generates a function with the given name. It accepts `target` as the first argument which is equivalent to NodeJS's `exports`. Now we will create our first method stub for a synchronous distance calculation:\n+\n+{{{diffStep 2.7}}}\n+\n+We exported the `CalculateSync` by using the `NAN_EXPORT` macro, and we used `NAN_METHOD` to define a new node-valid function. It accepts `info` as the first argument and it is the same as JavaScript's `arguments` vector. We already know which arguments this function should accept, that's why I followed TDD methodology from the first place:\n+\n+{{{diffStep 2.8}}}\n+\n+We use the `To()` function to convert the first argument into the desired type, and then we call the method `ToLocalChecked()`. This method is simply going to convert the result into v8's Local, unless the argument is undefined, in which case an error is going to be thrown. I like to prefix JS object with a `js_` so I know with what kind variable I'm dealing with. We should have two points containing `x` and `y` fields. Let's try to extract them out of the arguments vector and convert them into native C++ structures:\n+\n+{{{diffStep 2.9}}}\n+\n+Then again we convert the `To()` function to convert the result into the desired data-type, only this time it's a primitive, so we use `FromJust()` instead of `ToLocalChecked()`. Note that v8 only uses double precision rather than a floating point. We can fetch properties from a given JS object with ease using the `Get()` method. Pay attention to use the `->` rather than a period because remember, a Local is actually a pointer! It is not the actual object.\n+\n+Now all is left to do is defining the return value. Keep in mind that the value should be returned through v8's current scope, not natively, so using the `return` keyword would be useless. The return value can actually be defined through the provided `info` argument, like this:\n+\n+{{{diffStep \"2.10\"}}}\n+\n+And of-course it requires us to add the core distance calculation method:\n+\n+{{{diffStep 2.11}}}\n+\n+This is it for the synchronous calculation. Now we will add an async version of it. We will start by creating a method with everything we learned so far until the point where we have to return the result:\n+\n+{{{diffStep 2.12}}}\n+\n+Here's the different part. We don't wanna simply return the value, we want to make the calculations in parallel with the event loop, and once we're finished we will interact with it once again. In our model there are two threads. The first thread is the event loop thread, and the second thread will be a worker thread managed by Nan, the library supports asynchronous I/O in NodeJS. Let's start implementing and I will give some more explanations as we go further:\n+\n+{{{diffStep 2.13}}}\n+\n+Here we fetch the third argument which is the callback. We wrap it with Nan's Callback, which will make sure it is not garbage collected once the scope is being deleted, we want it to keep living until it's not relevant. At the bottom of the method, instead of returning a value explicitly, we queue our `DistanceWorker` into the workers queue. On that note, let's implement the DistanceWorker:\n+\n+{{{diffStep 2.14}}}\n+\n+`AsyncWorker` is an abstract class that you can subclass to have much of the annoying asynchronous queuing and handling taken care of for you. It can even store arbitrary v8 objects for you and have them persist while the asynchronous work is in progress. The `execute()` method is being executed inside the worker-thread. It is not safe to access V8, or V8 data structures there, so everything we need for input and output should go on 'this'. The `HandleOKCallback()` method is executed when the async work is complete. This function will be run inside the main event loop so it is safe to use v8 again. Let's implement the core distance calculation on the worker thread:\n+\n+{{{diffStep 2.15}}}\n+\n+And handle a successful invocation once the calculation is finished:\n+\n+{{{diffStep 2.16}}}\n+\n+Normally, when defining a NodeJS method (`NAN_METHOD` macro) a scope will be created for us automatically. In this function's context there is no scope exist, so we will have to create it using the `HandleScope` deceleration (The current scope is stored globally so even though we don't use it explicitly, v8 and Nan know what to do). We also created an arguments vector as the return value, following NodeJS's conventions, the first argument would be the error and the second argument would be the result.\n+\n+This is it! Finally we will transform the add-on into a nicer looking node-module:\n+\n+{{{diffStep 2.17}}}\n+\n+And now, let's run our small test to see that it works, using the following command:\n+\n+    $ npm run test\n+\n+If everything went well, you should have the following messages printed to the terminal:\n+\n+    sync calculation passed\n+    async calculation passed\ndiff --git a/.tortilla/manuals/templates/step3.tmpl b/.tortilla/manuals/templates/step3.tmpl\nnew file mode 100644\nindex 0000000..29e2c65\n--- /dev/null\n+++ b/.tortilla/manuals/templates/step3.tmpl\n@@ -0,0 +1,3 @@\n+You've just learned the very basics of how to use C++ within NodeJS. There's a lot more to learn when it comes to building an add-on, and I'm not just talking about learning v8 and Nan's API. Think about the possibilities, the C++ community have been developed for years and there are so much great libraries out there that are not necessarily relevant to NodeJS due to its efficiency, like [Boost](http://www.boost.org/), [OpenCV](http://opencv.org/), [CGAL](http://www.cgal.org/) and many more.\n+\n+This tutorial didn't focus about algorithmics obviously, it's a good starting point though, because from here I can take it to wherever I want, but I won't reveal my future plans in due course. Hopefully you liked it, stay tuned for upcoming tutorials about this topic.\ndiff --git a/LICENSE b/LICENSE\nnew file mode 100644\nindex 0000000..6117d6f\n--- /dev/null\n+++ b/LICENSE\n@@ -0,0 +1,21 @@\n+The MIT License\n+\n+Copyright (c) 2016 Eytan Manor\n+\n+Permission is hereby granted, free of charge, to any person obtaining a copy\n+of this software and associated documentation files (the \"Software\"), to deal\n+in the Software without restriction, including without limitation the rights\n+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+copies of the Software, and to permit persons to whom the Software is\n+furnished to do so, subject to the following conditions:\n+\n+The above copyright notice and this permission notice shall be included in\n+all copies or substantial portions of the Software.\n+\n+THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+THE SOFTWARE.\ndiff --git a/binding.gyp b/binding.gyp\nnew file mode 100644\nindex 0000000..fd6995f\n--- /dev/null\n+++ b/binding.gyp\n@@ -0,0 +1,11 @@\n+{\n+  \"targets\": [\n+    {\n+      \"target_name\": \"distance\",\n+      \"sources\": [\n+        \"src/distance.cc\"\n+      ],\n+      \"include_dirs\": [\"<!(node -e \\\"require('nan')\\\")\"]\n+    }\n+  ]\n+}\n\\ No newline at end of file\ndiff --git a/index.js b/index.js\nnew file mode 100644\nindex 0000000..147b729\n--- /dev/null\n+++ b/index.js\n@@ -0,0 +1,6 @@\n+const Distance = require('./build/Release/distance');\n+\n+exports.calculate = {\n+  sync: Distance.CalculateSync,\n+  async: Distance.CalculateAsync\n+};\n\\ No newline at end of file\ndiff --git a/package.json b/package.json\nnew file mode 100644\nindex 0000000..604b332\n--- /dev/null\n+++ b/package.json\n@@ -0,0 +1,19 @@\n+{\n+  \"name\": \"distance\",\n+  \"version\": \"0.0.0\",\n+  \"description\": \"Efficient distance calculator for NodeJS\",\n+  \"private\": true,\n+  \"repository\": {\n+    \"type\": \"git\",\n+    \"url\": \"https://DAB0mB@github.com/DAB0mB/node-distance-addon.git\"\n+  },\n+  \"gypfile\": true,\n+  \"scripts\": {\n+    \"pre-publish\": \"npm run build\",\n+    \"build\": \"node-gyp rebuild\",\n+    \"test\": \"npm run build && node test\"\n+  },\n+  \"dependencies\": {\n+    \"nan\": \"^2.4.0\"\n+  }\n+}\ndiff --git a/src/distance.cc b/src/distance.cc\nnew file mode 100644\nindex 0000000..440ac0a\n--- /dev/null\n+++ b/src/distance.cc\n@@ -0,0 +1,98 @@\n+#include <cstdlib>\n+#include <cmath>\n+#include <nan.h>\n+#include <v8.h>\n+\n+using Nan::AsyncQueueWorker;\n+using Nan::AsyncWorker;\n+using Nan::Callback;\n+using Nan::HandleScope;\n+using Nan::New;\n+using Nan::Null;\n+using Nan::To;\n+using std::pow;\n+using std::sqrt;\n+using v8::Function;\n+using v8::Local;\n+using v8::Number;\n+using v8::Object;\n+using v8::String;\n+using v8::Value;\n+\n+struct Point {\n+  double x;\n+  double y;\n+};\n+\n+double CalculateDistance(Point* pointA, Point* pointB) {\n+  return sqrt(pow(pointA->x - pointB->x, 2) + pow(pointA->y - pointB->y, 2));\n+}\n+\n+class DistanceWorker : public AsyncWorker {\n+ private:\n+  double distance;\n+  Point* pointA;\n+  Point* pointB;\n+\n+ public:\n+  DistanceWorker(Callback* callback, Point* pointA, Point* pointB) :\n+    AsyncWorker(callback), pointA(pointA), pointB(pointB) {}\n+\n+  ~DistanceWorker() {\n+    delete pointA;\n+    delete pointB;\n+  }\n+\n+  void Execute () {\n+    distance = CalculateDistance(pointA, pointB);\n+  }\n+\n+  void HandleOKCallback () {\n+    HandleScope scope;\n+\n+    Local<Value> argv[] = {\n+      Null(),\n+      New<Number>(distance)\n+    };\n+\n+    callback->Call(2, argv);\n+  }\n+};\n+\n+NAN_METHOD(CalculateSync) {\n+  Local<Object> js_pointA = To<Object>(info[0]).ToLocalChecked();\n+  Local<Object> js_pointB = To<Object>(info[1]).ToLocalChecked();\n+\n+  Point* pointA = new Point();\n+  pointA->x = To<double>(js_pointA->Get(New<String>(\"x\").ToLocalChecked())).FromJust();\n+  pointA->y = To<double>(js_pointA->Get(New<String>(\"y\").ToLocalChecked())).FromJust();\n+\n+  Point* pointB = new Point();\n+  pointB->x = To<double>(js_pointB->Get(New<String>(\"x\").ToLocalChecked())).FromJust();\n+  pointB->y = To<double>(js_pointB->Get(New<String>(\"y\").ToLocalChecked())).FromJust();\n+\n+  info.GetReturnValue().Set(CalculateDistance(pointA, pointB));\n+}\n+\n+NAN_METHOD(CalculateAsync) {\n+  Local<Object> js_pointA = To<Object>(info[0]).ToLocalChecked();\n+  Local<Object> js_pointB = To<Object>(info[1]).ToLocalChecked();\n+  Callback* callback = new Callback(info[2].As<Function>());\n+\n+  Point* pointA = new Point();\n+  pointA->x = To<double>(js_pointA->Get(New<String>(\"x\").ToLocalChecked())).FromJust();\n+  pointA->y = To<double>(js_pointA->Get(New<String>(\"y\").ToLocalChecked())).FromJust();\n+\n+  Point* pointB = new Point();\n+  pointB->x = To<double>(js_pointB->Get(New<String>(\"x\").ToLocalChecked())).FromJust();\n+  pointB->y = To<double>(js_pointB->Get(New<String>(\"y\").ToLocalChecked())).FromJust();\n+\n+  AsyncQueueWorker(new DistanceWorker(callback, pointA, pointB));\n+}\n+\n+NAN_MODULE_INIT(Init) {\n+  NAN_EXPORT(target, CalculateSync);\n+  NAN_EXPORT(target, CalculateAsync);\n+}\n+\n+NODE_MODULE(distance, Init)\n\\ No newline at end of file\ndiff --git a/test.js b/test.js\nnew file mode 100644\nindex 0000000..583f6e6\n--- /dev/null\n+++ b/test.js\n@@ -0,0 +1,23 @@\n+const Distance = require('.');\n+\n+let result;\n+let pointA = { x: 0, y: 0 };\n+let pointB = { x: 3, y: 4 };\n+\n+result = Distance.calculate.sync(pointA, pointB);\n+\n+if (result !== 5) throw Error(\n+  '#Sync: Result expected to equal 5 but instead got ' + result\n+);\n+\n+console.log('sync calculation passed');\n+\n+result = Distance.calculate.async(pointA, pointB, (err, result) => {\n+  if (err) throw err;\n+\n+  if (result !== 5) throw Error(\n+    '#Async: Result expected to equal 5 but instead got ' + result\n+  );\n+\n+  console.log('async calculation passed');\n+});\n\\ No newline at end of file\n",
        "manuals": [
          {
            "manualTitle": "NodeJS Advanced - How to create a native add-on using C++",
            "stepRevision": "eeb98a9f6dc0908010f76e74f46a695f386a6ff0",
            "manualView": ""
          },
          {
            "manualTitle": "Step 1: Introduction",
            "stepRevision": "14c6111213f063210cb887d017cf350ee570fee4",
            "manualView": "In this tutorial we gonna go through the basics on how to write a native add-on to NodeJS using C++, one of the platform's most powerful capabilities of which most web/JS developers now a days are not even familiar with.\n\nFor somewhat there is a vacuum which got created around C++ in the recent years, people are so scared from a low-level back-end programming, why should they even deal with memory allocation dilemmas when there are all these interpretation languages like Python, Ruby, and JavaScript who can do that for us? Well folks, once you will realize that all these single web-page application third-party libraries and frameworks are all recycled and repetitive, and you will start doing some real shit by optimizing some heavy-ass machine algorithms, you will realize that **performance is critic**, a title which doesn't really suit NodeJS, with all the love and respect. So why do I even bother making this tutorial? Because people are unaware of many features in the programming world, and the beauty of algorithmics. And why am I even approaching NodeJS developers? Because they have the biggest, most-popular community of all, they have a lot to learn, but they are very open minded, and that's the most important thing. You don't have to be a C++ developer not at all, but if I can at least catch a small part of your attention I will be overwhelmed.\n\nWe will create a very small and simple module which calculates the distance between two dots, it can do it either synchronously or asynchronously. The algorithm for calculating the distance between a given `pointA` and `pointB` in a 2D [Cartesian coordinate system](https://en.wikipedia.org/wiki/Cartesian_coordinate_system) looks like this:\n\n    √[(pointAX - pointBX)^2 + (pointAY - pointBY)^2]\n\nProbably not too complicated, kicks me back to the glamorous days in high-school. If put in JavaScript it should take around 10 seconds right? Well in a native NodeJS add-on it should be a bit longer. Of-course when it comes to small logics you shouldn't make too much effort, because it will consume more power only converting all JS objects into C++ native structures. But imagine you would like to run a [blob-detection](https://en.wikipedia.org/wiki/Blob_detection) algorithm and you would like to calculate the [center of mass](https://en.wikipedia.org/wiki/Center_of_mass) of multiple blobs, in C++ it would be much faster, especially when using [shaders](https://en.wikipedia.org/wiki/Shader). Anyways that's not the point of this tutorial, the point is that you will be provided with the necessary tools so next time if you would like to write some heavy logic, you will know how to do it.\n\nWe will start with a brief introduction for Google's [v8 engine](https://en.wikipedia.org/wiki/V8_(JavaScript_engine)) and some practical examples on how to use it, this will help us getting start, and then we will write our add-on. Let's begin then shall we?"
          },
          {
            "manualTitle": "Step 2: Meet the V8 engine",
            "stepRevision": "55fbd43bb8b1f70e0df0dcaacca0589a3a8bc780",
            "manualView": "![v8-logo](https://cloud.githubusercontent.com/assets/7648874/20428176/d766fba8-ad6e-11e6-884f-badc847d5e24.png)\n\nThe v8 JavaScript Engine is an open source JavaScript engine developed by The [Chromium Project](https://www.chromium.org/) for the [Google Chrome web browser](https://www.google.com/chrome/). It is intended to be used both in a browser and as a standalone high-performance engine that can be integrated into independent projects like [Couchbase](http://www.couchbase.com/), [MongoDB](https://www.mongodb.com/) and [Node.js](https://nodejs.org/). There lots of benchmarks out there but I will not bore you with diagrams, we all know that that this engine has proven itself to be worthy and it is being used world-widely and probably for a good reason.\n\n> \"Ambition is a dream with a v8 engine\" -Elvis Presley.\n\nIf you're a JavaScript developer you must be familiar with the event-loop and the scoping system of v8, so it's a good thing that you understand the concept, but you never got to actually look at its source code and explicitly use it. A detailed documentation for v8's different API versions is available [here](https://v8docs.nodesource.com/). I assume that you don't bother reading any of my references that I provide along this tutorial (As a lazy blog-reader myself), I will post here that first thing you gonna see once you enter v8's documentation web-site:\n\n![v8-docs](https://cloud.githubusercontent.com/assets/7648874/20429800/ffeb3a4a-ad77-11e6-8fae-d892304169db.jpg)\n\nThroughout history v8 have changed a lot and it wore many forms. As a result, add-ons are not usable across different versions of the platform since each one supports a different API, which will break our process during run-time. In NodeJS team they came up with a very convenient solution called [Nan](https://github.com/nodejs/nan). Nan stands for \"Native Abstractions for NodeJS\" and is basically a header file filled with macro and utility goodness for making add-on development for NodeJS easier across all versions of v8, without inspecting `NODE_MODULE_VERSION` macro all the time. In this tutorial I'm gonna refer both of them as if they are bundled in a single framework.\n\nEventually JavaScript is just a rehash of v8, everything you know so far is still valid but it uses a different idiom. To prevent some misconceptions, here are some important points regards JavaScript's equivalents which I think you should follow:\n\n#### Scopes and Variables\n\nIn v8 a scope is referred as `Isolate` (`v8::Isolate`) and a variable is referred as `Local` (`v8::Local<T>`). A local is a pointer to an object. All v8 objects are accessed using locals, they are necessary because of the way the v8 garbage collector works. An isolate can be thought of as a container for any number of locals. When you've finished with your locals, instead of deleting each one individually you can simply delete their scope.\n\n##### JavaScript\n\n```js\nlet obj = {\n  foo: 'foo',\n  bar: 'bar',\n  baz: 'baz'\n};\n\nconsole.log(obj.foo);\nconsole.log(obj.bar);\nconsole.log(obj.baz);\n```\n\n##### C++\n\n```cpp\nusing Nan::New;\nusing std::cendl;\nusing std::cout;\nusing v8::Local;\nusing v8::Object;\nusing v8::String;\n\nLocal<Object> obj = New<Object>();\n\nobj->Set(New<String>(\"foo\").ToLocalChecked(), New<String>(\"foo\").ToLocalChecked());\nobj->Set(New<String>(\"bar\").ToLocalChecked(), New<String>(\"bar\").ToLocalChecked());\nobj->Set(New<String>(\"baz\").ToLocalChecked(), New<String>(\"baz\").ToLocalChecked());\n\ncout << obj->Get(New<String>(\"foo\").ToLocalChecked()) << cendl;\ncout << obj->Get(New<String>(\"bar\").ToLocalChecked()) << cendl;\ncout << obj->Get(New<String>(\"baz\").ToLocalChecked()) << cendl;\n```\n\n#### Asynchronous Callbacks\n\nAsynchronous logic can be implemented using the `AsyncWorker` (`Nan::AsyncWorker`) and invoked by `AsyncQueueWorker` (`Nan::AsyncQueueWorker`). Thanks to these two you can have much of the annoying asynchronous queuing and handling taken care of for you. It can even store arbitrary V8 objects for you and have them persist while the asynchronous work is in progress.\n\n##### JavaScript\n\n```js\nsetImmediate(() => {\n  callback(null, 'result');\n});\n```\n\n##### C++\n\n```cpp\nusing Nan::AsyncQueueWorker;\nusing Nan::AsyncWorker;\nusing Nan::HandleScope;\nusing Nan::New;\nusing Nan::Null;\nusing std::string;\nusing v8::Local;\nusing v8::String;\n\nclass ResultWorker : AsyncWorker {\n private:\n  string* result\n\n public:\n  ResultWorker(Callback* callback) : AsyncWorker(callback) {}\n\n  ~ResultDistance() {\n    delete result;\n  }\n\n  // Executed inside the worker-thread.\n  // It is not safe to access V8, or V8 data structures\n  // here, so everything we need for input and output\n  // should go on 'this'.\n  void Execute () {\n    result = new string(\"result\");\n  }\n\n  // Executed when the async work is complete.\n  // This function will be run inside the main event loop\n  // so it is safe to use V8 again.\n  void HandleOKCallback () {\n    HandleScope scope;\n\n    Local<Value> argv[] = {\n      Null(),\n      New<String>(result).ToLocalChecked()\n    };\n\n    callback->Call(2, argv);\n  }\n};\n\nAsyncQueueWorker(new ResultWorker(callback));\n```\n\n#### Modules Registration and Methods Definition\n\nv8 and Nan provide us with some handy macros (`NODE_MODULE`, `NAN_MODULE_INIT`, `NAN_METHOD` and `NODE_SET_METHOD`) which will help us register a new NodeJS module and define its methods. This might be confusing for some, since we can't see the function's signature it would appear as if variables are just being magically created in the stack, but once the macros are being pre-processed they will just turn into ordinary functions. In the example below I commented the original signature so you can have more clew on what's going on.\n\n##### JavaScript\n\n```js\nexports.fn = (a, b) => a + b;\n```\n\n##### C++\n\n```cpp\nusing Nan::To;\nusing v8::Local;\nusing v8::Object;\n\n// void Fn(FunctionCallbackInfo<Value>& info)\nNAN_METHOD(Fn) {\n  double a = To<double>(info[0]).FromJust();\n  double b = To<double>(info[1]).FromJust();\n\n  info.GetReturnValue().Set(a + b);\n}\n\n// void Init(Local<Object> target)\nNAN_MODULE_INIT(Init) {\n  NODE_SET_METHOD(target, Fn);\n}\n\n// First argument would be the entry file's name\nNODE_MODULE(addon, Init);\n```\n\n---\n\nAs you can see when dealing with v8 explicitly is a time consuming process which requires you to do lots of extra-work. With that said, keep in mind that only a small portion of your code is gonna interact with the engine since the core logic should be written using native C++ and other third-party libraries. You always need to find the right balance. Always make sure that your add-on doesn't require too much data to be passed otherwise the conversion process is gonna be hard and inefficient, and think twice before you choose this approach for the sake of simplicity. Overall the estimated optimization should be around 150% and up, depends on the task, first check your JavaScript code snippet, check for unnecessary logic and optimize it, and if you're really sure that it is fully optimized and you're still striving for more performance, *only then* move to C++.\n\nSo far I went through the very basics which will help you create this bridge between the two platforms. The v8 lacks of detailed documentation, tutorials and examples. [Nan](https://github.com/nodejs/nan) however is a bit more documented IMHO, so when I approach the API documentation I would start from there, and if I didn't find anything useful I would look at [v8's latest API docs](https://v8docs.nodesource.com/). It's not a hard material to learn but it's different so it might be a bit challenging for some, but remember, practice practice practice.\n\nSpeaking of practice, let's move on to the next step where we gonna implement our first add-on for distance calculation between two points."
          },
          {
            "manualTitle": "Step 3: Creating the add-on",
            "stepRevision": "248648638eac93e0c153105afc91f2fdb1704863",
            "manualView": "In this step we will base our development process on the TDD methodology, so you will have a chance to look at the final target API that we desire. We will start by writing a test file:\n\n[{]: <helper> (diffStep 3.1)\n\n#### [Step 3.1: Add test file](https://github.com/DAB0mB/node-distance-addon/commit/7809332)\n\n##### Added .npmignore\n```diff\n@@ -0,0 +1 @@\n+┊ ┊1┊test.js🚫↵\n```\n\n##### Added test.js\n```diff\n@@ -0,0 +1,23 @@\n+┊  ┊ 1┊const Distance = require('.');\n+┊  ┊ 2┊\n+┊  ┊ 3┊let result;\n+┊  ┊ 4┊let pointA = { x: 0, y: 0 };\n+┊  ┊ 5┊let pointB = { x: 3, y: 4 };\n+┊  ┊ 6┊\n+┊  ┊ 7┊result = Distance.calculate.sync(pointA, pointB);\n+┊  ┊ 8┊\n+┊  ┊ 9┊if (result !== 5) throw Error(\n+┊  ┊10┊  '#Sync: Result expected to equal 5 but instead got ' + result\n+┊  ┊11┊);\n+┊  ┊12┊\n+┊  ┊13┊console.log('sync calculation passed');\n+┊  ┊14┊\n+┊  ┊15┊result = Distance.calculate.async(pointA, pointB, (err, result) => {\n+┊  ┊16┊  if (err) throw err;\n+┊  ┊17┊\n+┊  ┊18┊  if (result !== 5) throw Error(\n+┊  ┊19┊    '#Async: Result expected to equal 5 but instead got ' + result\n+┊  ┊20┊  );\n+┊  ┊21┊\n+┊  ┊22┊  console.log('async calculation passed');\n+┊  ┊23┊});🚫↵\n```\n\n[}]: #\n\nAnd the following NPM script should execute it:\n\n[{]: <helper> (diffStep 3.2)\n\n#### [Step 3.2: Add npm test script](https://github.com/DAB0mB/node-distance-addon/commit/f683a13)\n\n##### Changed package.json\n```diff\n@@ -6,5 +6,8 @@\n ┊ 6┊ 6┊  \"repository\": {\n ┊ 7┊ 7┊    \"type\": \"git\",\n ┊ 8┊ 8┊    \"url\": \"https://DAB0mB@github.com/DAB0mB/node-distance-addon.git\"\n+┊  ┊ 9┊  },\n+┊  ┊10┊  \"scripts\": {\n+┊  ┊11┊    \"test\": \"node test\"\n ┊ 9┊12┊  }\n ┊10┊13┊}\n```\n\n[}]: #\n\nLike I said in the introduction, it's a simple module which can calculate the distance between 2 given points. `calculate.sync` can do it synchronously and `calculate.async` can do it asynchronously. Now that you got the idea we will start configuring our add-on.\n\nThe first thing you'll need to do is to make sure that you have `node-gyp` installed:\n\n    $ sudo npm install -g node-gyp\n\n`node-gyp` is also dependent on many other packages, so before you go any further please take a look at the official installation instructions in their [README.md file](https://github.com/nodejs/node-gyp).\n\nAssuming that you have installed everything properly, we will now need to create a `binding.gyp` file:\n\n[{]: <helper> (diffStep 3.3 files=\"binding.gyp\")\n\n#### [Step 3.3: Create &#x27;binding.gyp&#x27; file](https://github.com/DAB0mB/node-distance-addon/commit/1849cfb)\n\n##### Added binding.gyp\n```diff\n@@ -0,0 +1,11 @@\n+┊  ┊ 1┊{\n+┊  ┊ 2┊  \"targets\": [\n+┊  ┊ 3┊    {\n+┊  ┊ 4┊      \"target_name\": \"distance\",\n+┊  ┊ 5┊      \"sources\": [\n+┊  ┊ 6┊        \"src/distance.cc\"\n+┊  ┊ 7┊      ],\n+┊  ┊ 8┊      \"include_dirs\": [\"<!(node -e \\\"require('nan')\\\")\"]\n+┊  ┊ 9┊    }\n+┊  ┊10┊  ]\n+┊  ┊11┊}🚫↵\n```\n\n[}]: #\n\nGYP stands for 'Generate Your Project' and was created by the Chromium team as a configuration file for building native projects. The configuration show above should be a good template for any future add-on you're looking to develop. Let's take a deeper look at it:\n\n- `target_name` - Specifies the output dir of our add-on, in which case it should be `build/Release/distance`.\n- `sources` - Should include **all** the cpp files that are associated with you add-on.\n- `include_dirs` - Additional dirs that should be included when building the add-on. If you'll run the given script in the terminal you'll get the node-module path for Nan, a library which we're interested in during the build process.\n\nMore information about GYP configuration can be found [here](https://gyp.gsrc.io/docs/UserDocumentation.md).\n\nBe sure to also add the specified flag to the `package.json` which basically says 'Hey, I have a GYP file which should be taken into consideration as well':\n\n[{]: <helper> (diffStep 3.3 files=\"package.json\")\n\n#### [Step 3.3: Create &#x27;binding.gyp&#x27; file](https://github.com/DAB0mB/node-distance-addon/commit/1849cfb)\n\n##### Changed package.json\n```diff\n@@ -7,6 +7,7 @@\n ┊ 7┊ 7┊    \"type\": \"git\",\n ┊ 8┊ 8┊    \"url\": \"https://DAB0mB@github.com/DAB0mB/node-distance-addon.git\"\n ┊ 9┊ 9┊  },\n+┊  ┊10┊  \"gypfile\": true,\n ┊10┊11┊  \"scripts\": {\n ┊11┊12┊    \"test\": \"node test\"\n ┊12┊13┊  }\n```\n\n[}]: #\n\nNow we will add the following NPM scripts so whenever we run `npm run build` our project will be built:\n\n[{]: <helper> (diffStep 3.4)\n\n#### [Step 3.4: Add npm build scripts](https://github.com/DAB0mB/node-distance-addon/commit/74f2ad8)\n\n##### Changed .gitignore\n```diff\n@@ -1 +1,2 @@\n+┊ ┊1┊build\n ┊1┊2┊node_modules🚫↵\n```\n\n##### Changed package.json\n```diff\n@@ -9,6 +9,8 @@\n ┊ 9┊ 9┊  },\n ┊10┊10┊  \"gypfile\": true,\n ┊11┊11┊  \"scripts\": {\n-┊12┊  ┊    \"test\": \"node test\"\n+┊  ┊12┊    \"pre-publish\": \"npm run build\",\n+┊  ┊13┊    \"build\": \"node-gyp rebuild\",\n+┊  ┊14┊    \"test\": \"npm run build && node test\"\n ┊13┊15┊  }\n ┊14┊16┊}\n```\n\n[}]: #\n\nThe only thing left to do before jumping into implementation would be installing Nan:\n\n    $ npm install nan --save\n\nThe basis for build process is set. We will create the entry file for our add-on:\n\n[{]: <helper> (diffStep 3.6)\n\n#### [Step 3.6: Create add-on entry file](https://github.com/DAB0mB/node-distance-addon/commit/999ff94)\n\n##### Added src&#x2F;distance.cc\n```diff\n@@ -0,0 +1,8 @@\n+┊ ┊1┊#include <nan.h>\n+┊ ┊2┊#include <v8.h>\n+┊ ┊3┊\n+┊ ┊4┊NAN_MODULE_INIT(Init) {\n+┊ ┊5┊\n+┊ ┊6┊}\n+┊ ┊7┊\n+┊ ┊8┊NODE_MODULE(distance, Init)🚫↵\n```\n\n[}]: #\n\nEvery add-on should start with these two macro calls. They are both compiled into a piece of code which will register our module with ease. The `NODE_MODULE` macro template accepts the name of the target as the first argument (That one we set as `target_name` in the GYP file, remember?) and the initialization method for our module. The `NAN_MODULE_INIT` generates a function with the given name. It accepts `target` as the first argument which is equivalent to NodeJS's `exports`. Now we will create our first method stub for a synchronous distance calculation:\n\n[{]: <helper> (diffStep 3.7)\n\n#### [Step 3.7: Create &#x27;CalculateSync&#x27; method stub](https://github.com/DAB0mB/node-distance-addon/commit/a67f6e0)\n\n##### Changed src&#x2F;distance.cc\n```diff\n@@ -1,8 +1,12 @@\n ┊ 1┊ 1┊#include <nan.h>\n ┊ 2┊ 2┊#include <v8.h>\n ┊ 3┊ 3┊\n-┊ 4┊  ┊NAN_MODULE_INIT(Init) {\n+┊  ┊ 4┊NAN_METHOD(CalculateSync) {\n+┊  ┊ 5┊\n+┊  ┊ 6┊}\n ┊ 5┊ 7┊\n+┊  ┊ 8┊NAN_MODULE_INIT(Init) {\n+┊  ┊ 9┊  NAN_EXPORT(target, CalculateSync);\n ┊ 6┊10┊}\n ┊ 7┊11┊\n ┊ 8┊12┊NODE_MODULE(distance, Init)🚫↵\n```\n\n[}]: #\n\nWe exported the `CalculateSync` by using the `NAN_EXPORT` macro, and we used `NAN_METHOD` to define a new node-valid function. It accepts `info` as the first argument and it is the same as JavaScript's `arguments` vector. We already know which arguments this function should accept, that's why I followed TDD methodology from the first place:\n\n[{]: <helper> (diffStep 3.8)\n\n#### [Step 3.8: Destructure arguments vector](https://github.com/DAB0mB/node-distance-addon/commit/208d53d)\n\n##### Changed src&#x2F;distance.cc\n```diff\n@@ -1,8 +1,13 @@\n ┊ 1┊ 1┊#include <nan.h>\n ┊ 2┊ 2┊#include <v8.h>\n ┊ 3┊ 3┊\n-┊ 4┊  ┊NAN_METHOD(CalculateSync) {\n+┊  ┊ 4┊using Nan::To;\n+┊  ┊ 5┊using v8::Local;\n+┊  ┊ 6┊using v8::Object;\n ┊ 5┊ 7┊\n+┊  ┊ 8┊NAN_METHOD(CalculateSync) {\n+┊  ┊ 9┊  Local<Object> js_pointA = To<Object>(info[0]).ToLocalChecked();\n+┊  ┊10┊  Local<Object> js_pointB = To<Object>(info[1]).ToLocalChecked();\n ┊ 6┊11┊}\n ┊ 7┊12┊\n ┊ 8┊13┊NAN_MODULE_INIT(Init) {\n```\n\n[}]: #\n\nWe use the `To()` function to convert the first argument into the desired type, and then we call the method `ToLocalChecked()`. This method is simply going to convert the result into v8's Local, unless the argument is undefined, in which case an error is going to be thrown. I like to prefix JS object with a `js_` so I know with what kind variable I'm dealing with. We should have two points containing `x` and `y` fields. Let's try to extract them out of the arguments vector and convert them into native C++ structures:\n\n[{]: <helper> (diffStep 3.9)\n\n#### [Step 3.9: Convert JS objects to native C++ structures](https://github.com/DAB0mB/node-distance-addon/commit/5c29c8e)\n\n##### Changed src&#x2F;distance.cc\n```diff\n@@ -1,13 +1,28 @@\n ┊ 1┊ 1┊#include <nan.h>\n ┊ 2┊ 2┊#include <v8.h>\n ┊ 3┊ 3┊\n+┊  ┊ 4┊using Nan::New;\n ┊ 4┊ 5┊using Nan::To;\n ┊ 5┊ 6┊using v8::Local;\n ┊ 6┊ 7┊using v8::Object;\n+┊  ┊ 8┊using v8::String;\n+┊  ┊ 9┊\n+┊  ┊10┊struct Point {\n+┊  ┊11┊  double x;\n+┊  ┊12┊  double y;\n+┊  ┊13┊};\n ┊ 7┊14┊\n ┊ 8┊15┊NAN_METHOD(CalculateSync) {\n ┊ 9┊16┊  Local<Object> js_pointA = To<Object>(info[0]).ToLocalChecked();\n ┊10┊17┊  Local<Object> js_pointB = To<Object>(info[1]).ToLocalChecked();\n+┊  ┊18┊\n+┊  ┊19┊  Point* pointA = new Point();\n+┊  ┊20┊  pointA->x = To<double>(js_pointA->Get(New<String>(\"x\").ToLocalChecked())).FromJust();\n+┊  ┊21┊  pointA->y = To<double>(js_pointA->Get(New<String>(\"y\").ToLocalChecked())).FromJust();\n+┊  ┊22┊\n+┊  ┊23┊  Point* pointB = new Point();\n+┊  ┊24┊  pointB->x = To<double>(js_pointB->Get(New<String>(\"x\").ToLocalChecked())).FromJust();\n+┊  ┊25┊  pointB->y = To<double>(js_pointB->Get(New<String>(\"y\").ToLocalChecked())).FromJust();\n ┊11┊26┊}\n ┊12┊27┊\n ┊13┊28┊NAN_MODULE_INIT(Init) {\n```\n\n[}]: #\n\nThen again we convert the `To()` function to convert the result into the desired data-type, only this time it's a primitive, so we use `FromJust()` instead of `ToLocalChecked()`. Note that v8 only uses double precision rather than a floating point. We can fetch properties from a given JS object with ease using the `Get()` method. Pay attention to use the `->` rather than a period because remember, a Local is actually a pointer! It is not the actual object.\n\nNow all is left to do is defining the return value. Keep in mind that the value should be returned through v8's current scope, not natively, so using the `return` keyword would be useless. The return value can actually be defined through the provided `info` argument, like this:\n\n[{]: <helper> (diffStep \"3.10\")\n\n#### [Step 3.10: Add return value to &#x27;CalculateSync&#x27; method](https://github.com/DAB0mB/node-distance-addon/commit/a87ded4)\n\n##### Changed src&#x2F;distance.cc\n```diff\n@@ -23,6 +23,8 @@\n ┊23┊23┊  Point* pointB = new Point();\n ┊24┊24┊  pointB->x = To<double>(js_pointB->Get(New<String>(\"x\").ToLocalChecked())).FromJust();\n ┊25┊25┊  pointB->y = To<double>(js_pointB->Get(New<String>(\"y\").ToLocalChecked())).FromJust();\n+┊  ┊26┊\n+┊  ┊27┊  info.GetReturnValue().Set(CalculateDistance(pointA, pointB));\n ┊26┊28┊}\n ┊27┊29┊\n ┊28┊30┊NAN_MODULE_INIT(Init) {\n```\n\n[}]: #\n\nAnd of-course it requires us to add the core distance calculation method:\n\n[{]: <helper> (diffStep 3.11)\n\n#### [Step 3.11: Add core distance calculation method](https://github.com/DAB0mB/node-distance-addon/commit/c7ffb4a)\n\n##### Changed src&#x2F;distance.cc\n```diff\n@@ -1,8 +1,12 @@\n+┊  ┊ 1┊#include <cstdlib>\n+┊  ┊ 2┊#include <cmath>\n ┊ 1┊ 3┊#include <nan.h>\n ┊ 2┊ 4┊#include <v8.h>\n ┊ 3┊ 5┊\n ┊ 4┊ 6┊using Nan::New;\n ┊ 5┊ 7┊using Nan::To;\n+┊  ┊ 8┊using std::pow;\n+┊  ┊ 9┊using std::sqrt;\n ┊ 6┊10┊using v8::Local;\n ┊ 7┊11┊using v8::Object;\n ┊ 8┊12┊using v8::String;\n```\n```diff\n@@ -12,6 +16,10 @@\n ┊12┊16┊  double y;\n ┊13┊17┊};\n ┊14┊18┊\n+┊  ┊19┊double CalculateDistance(Point* pointA, Point* pointB) {\n+┊  ┊20┊  return sqrt(pow(pointA->x - pointB->x, 2) + pow(pointA->y - pointB->y, 2));\n+┊  ┊21┊}\n+┊  ┊22┊\n ┊15┊23┊NAN_METHOD(CalculateSync) {\n ┊16┊24┊  Local<Object> js_pointA = To<Object>(info[0]).ToLocalChecked();\n ┊17┊25┊  Local<Object> js_pointB = To<Object>(info[1]).ToLocalChecked();\n```\n\n[}]: #\n\nThis is it for the synchronous calculation. Now we will add an async version of it. We will start by creating a method with everything we learned so far until the point where we have to return the result:\n\n[{]: <helper> (diffStep 3.12)\n\n#### [Step 3.12: Create &#x27;CalculateAsync&#x27; method with basic deconstructuring](https://github.com/DAB0mB/node-distance-addon/commit/0010ef8)\n\n##### Changed src&#x2F;distance.cc\n```diff\n@@ -35,8 +35,22 @@\n ┊35┊35┊  info.GetReturnValue().Set(CalculateDistance(pointA, pointB));\n ┊36┊36┊}\n ┊37┊37┊\n+┊  ┊38┊NAN_METHOD(CalculateAsync) {\n+┊  ┊39┊  Local<Object> js_pointA = To<Object>(info[0]).ToLocalChecked();\n+┊  ┊40┊  Local<Object> js_pointB = To<Object>(info[1]).ToLocalChecked();\n+┊  ┊41┊\n+┊  ┊42┊  Point* pointA = new Point();\n+┊  ┊43┊  pointA->x = To<double>(js_pointA->Get(New<String>(\"x\").ToLocalChecked())).FromJust();\n+┊  ┊44┊  pointA->y = To<double>(js_pointA->Get(New<String>(\"y\").ToLocalChecked())).FromJust();\n+┊  ┊45┊\n+┊  ┊46┊  Point* pointB = new Point();\n+┊  ┊47┊  pointB->x = To<double>(js_pointB->Get(New<String>(\"x\").ToLocalChecked())).FromJust();\n+┊  ┊48┊  pointB->y = To<double>(js_pointB->Get(New<String>(\"y\").ToLocalChecked())).FromJust();\n+┊  ┊49┊}\n+┊  ┊50┊\n ┊38┊51┊NAN_MODULE_INIT(Init) {\n ┊39┊52┊  NAN_EXPORT(target, CalculateSync);\n+┊  ┊53┊  NAN_EXPORT(target, CalculateAsync);\n ┊40┊54┊}\n ┊41┊55┊\n ┊42┊56┊NODE_MODULE(distance, Init)🚫↵\n```\n\n[}]: #\n\nHere's the different part. We don't wanna simply return the value, we want to make the calculations in parallel with the event loop, and once we're finished we will interact with it once again. In our model there are two threads. The first thread is the event loop thread, and the second thread will be a worker thread managed by Nan, the library supports asynchronous I/O in NodeJS. Let's start implementing and I will give some more explanations as we go further:\n\n[{]: <helper> (diffStep 3.13)\n\n#### [Step 3.13: Queue distance worker](https://github.com/DAB0mB/node-distance-addon/commit/c76c090)\n\n##### Changed src&#x2F;distance.cc\n```diff\n@@ -3,10 +3,14 @@\n ┊ 3┊ 3┊#include <nan.h>\n ┊ 4┊ 4┊#include <v8.h>\n ┊ 5┊ 5┊\n+┊  ┊ 6┊using Nan::AsyncQueueWorker;\n+┊  ┊ 7┊using Nan::AsyncWorker;\n+┊  ┊ 8┊using Nan::Callback;\n ┊ 6┊ 9┊using Nan::New;\n ┊ 7┊10┊using Nan::To;\n ┊ 8┊11┊using std::pow;\n ┊ 9┊12┊using std::sqrt;\n+┊  ┊13┊using v8::Function;\n ┊10┊14┊using v8::Local;\n ┊11┊15┊using v8::Object;\n ┊12┊16┊using v8::String;\n```\n```diff\n@@ -38,6 +42,7 @@\n ┊38┊42┊NAN_METHOD(CalculateAsync) {\n ┊39┊43┊  Local<Object> js_pointA = To<Object>(info[0]).ToLocalChecked();\n ┊40┊44┊  Local<Object> js_pointB = To<Object>(info[1]).ToLocalChecked();\n+┊  ┊45┊  Callback* callback = new Callback(info[2].As<Function>());\n ┊41┊46┊\n ┊42┊47┊  Point* pointA = new Point();\n ┊43┊48┊  pointA->x = To<double>(js_pointA->Get(New<String>(\"x\").ToLocalChecked())).FromJust();\n```\n```diff\n@@ -46,6 +51,8 @@\n ┊46┊51┊  Point* pointB = new Point();\n ┊47┊52┊  pointB->x = To<double>(js_pointB->Get(New<String>(\"x\").ToLocalChecked())).FromJust();\n ┊48┊53┊  pointB->y = To<double>(js_pointB->Get(New<String>(\"y\").ToLocalChecked())).FromJust();\n+┊  ┊54┊\n+┊  ┊55┊  AsyncQueueWorker(new DistanceWorker(callback, pointA, pointB));\n ┊49┊56┊}\n ┊50┊57┊\n ┊51┊58┊NAN_MODULE_INIT(Init) {\n```\n\n[}]: #\n\nHere we fetch the third argument which is the callback. We wrap it with Nan's Callback, which will make sure it is not garbage collected once the scope is being deleted, we want it to keep living until it's not relevant. At the bottom of the method, instead of returning a value explicitly, we queue our `DistanceWorker` into the workers queue. On that note, let's implement the DistanceWorker:\n\n[{]: <helper> (diffStep 3.14)\n\n#### [Step 3.14: Create &#x27;DistanceWorker&#x27; with a constructor and a deconstructor](https://github.com/DAB0mB/node-distance-addon/commit/7af276b)\n\n##### Changed src&#x2F;distance.cc\n```diff\n@@ -24,6 +24,29 @@\n ┊24┊24┊  return sqrt(pow(pointA->x - pointB->x, 2) + pow(pointA->y - pointB->y, 2));\n ┊25┊25┊}\n ┊26┊26┊\n+┊  ┊27┊class DistanceWorker : public AsyncWorker {\n+┊  ┊28┊ private:\n+┊  ┊29┊  Point* pointA;\n+┊  ┊30┊  Point* pointB;\n+┊  ┊31┊\n+┊  ┊32┊ public:\n+┊  ┊33┊  DistanceWorker(Callback* callback, Point* pointA, Point* pointB) :\n+┊  ┊34┊    AsyncWorker(callback), pointA(pointA), pointB(pointB) {}\n+┊  ┊35┊\n+┊  ┊36┊  ~DistanceWorker() {\n+┊  ┊37┊    delete pointA;\n+┊  ┊38┊    delete pointB;\n+┊  ┊39┊  }\n+┊  ┊40┊\n+┊  ┊41┊  void Execute () {\n+┊  ┊42┊\n+┊  ┊43┊  }\n+┊  ┊44┊\n+┊  ┊45┊  void HandleOKCallback () {\n+┊  ┊46┊\n+┊  ┊47┊  }\n+┊  ┊48┊};\n+┊  ┊49┊\n ┊27┊50┊NAN_METHOD(CalculateSync) {\n ┊28┊51┊  Local<Object> js_pointA = To<Object>(info[0]).ToLocalChecked();\n ┊29┊52┊  Local<Object> js_pointB = To<Object>(info[1]).ToLocalChecked();\n```\n\n[}]: #\n\n`AsyncWorker` is an abstract class that you can subclass to have much of the annoying asynchronous queuing and handling taken care of for you. It can even store arbitrary v8 objects for you and have them persist while the asynchronous work is in progress. The `execute()` method is being executed inside the worker-thread. It is not safe to access V8, or V8 data structures there, so everything we need for input and output should go on 'this'. The `HandleOKCallback()` method is executed when the async work is complete. This function will be run inside the main event loop so it is safe to use v8 again. Let's implement the core distance calculation on the worker thread:\n\n[{]: <helper> (diffStep 3.15)\n\n#### [Step 3.15: Execute distance calculation](https://github.com/DAB0mB/node-distance-addon/commit/a812319)\n\n##### Changed src&#x2F;distance.cc\n```diff\n@@ -26,6 +26,7 @@\n ┊26┊26┊\n ┊27┊27┊class DistanceWorker : public AsyncWorker {\n ┊28┊28┊ private:\n+┊  ┊29┊  double distance;\n ┊29┊30┊  Point* pointA;\n ┊30┊31┊  Point* pointB;\n ┊31┊32┊\n```\n```diff\n@@ -39,7 +40,7 @@\n ┊39┊40┊  }\n ┊40┊41┊\n ┊41┊42┊  void Execute () {\n-┊42┊  ┊\n+┊  ┊43┊    distance = CalculateDistance(pointA, pointB);\n ┊43┊44┊  }\n ┊44┊45┊\n ┊45┊46┊  void HandleOKCallback () {\n```\n\n[}]: #\n\nAnd handle a successful invocation once the calculation is finished:\n\n[{]: <helper> (diffStep 3.16)\n\n#### [Step 3.16: Handle successful invokation](https://github.com/DAB0mB/node-distance-addon/commit/5af7f59)\n\n##### Changed src&#x2F;distance.cc\n```diff\n@@ -6,14 +6,18 @@\n ┊ 6┊ 6┊using Nan::AsyncQueueWorker;\n ┊ 7┊ 7┊using Nan::AsyncWorker;\n ┊ 8┊ 8┊using Nan::Callback;\n+┊  ┊ 9┊using Nan::HandleScope;\n ┊ 9┊10┊using Nan::New;\n+┊  ┊11┊using Nan::Null;\n ┊10┊12┊using Nan::To;\n ┊11┊13┊using std::pow;\n ┊12┊14┊using std::sqrt;\n ┊13┊15┊using v8::Function;\n ┊14┊16┊using v8::Local;\n+┊  ┊17┊using v8::Number;\n ┊15┊18┊using v8::Object;\n ┊16┊19┊using v8::String;\n+┊  ┊20┊using v8::Value;\n ┊17┊21┊\n ┊18┊22┊struct Point {\n ┊19┊23┊  double x;\n```\n```diff\n@@ -44,7 +48,14 @@\n ┊44┊48┊  }\n ┊45┊49┊\n ┊46┊50┊  void HandleOKCallback () {\n+┊  ┊51┊    HandleScope scope;\n ┊47┊52┊\n+┊  ┊53┊    Local<Value> argv[] = {\n+┊  ┊54┊      Null(),\n+┊  ┊55┊      New<Number>(distance)\n+┊  ┊56┊    };\n+┊  ┊57┊\n+┊  ┊58┊    callback->Call(2, argv);\n ┊48┊59┊  }\n ┊49┊60┊};\n```\n\n[}]: #\n\nNormally, when defining a NodeJS method (`NAN_METHOD` macro) a scope will be created for us automatically. In this function's context there is no scope exist, so we will have to create it using the `HandleScope` deceleration (The current scope is stored globally so even though we don't use it explicitly, v8 and Nan know what to do). We also created an arguments vector as the return value, following NodeJS's conventions, the first argument would be the error and the second argument would be the result.\n\nThis is it! Finally we will transform the add-on into a nicer looking node-module:\n\n[{]: <helper> (diffStep 3.17)\n\n#### [Step 3.17: Transform add-on into a nicer looking node-module](https://github.com/DAB0mB/node-distance-addon/commit/2f81b05)\n\n##### Added index.js\n```diff\n@@ -0,0 +1,6 @@\n+┊ ┊1┊const Distance = require('./build/Release/distance');\n+┊ ┊2┊\n+┊ ┊3┊exports.calculate = {\n+┊ ┊4┊  sync: Distance.CalculateSync,\n+┊ ┊5┊  async: Distance.CalculateAsync\n+┊ ┊6┊};🚫↵\n```\n\n[}]: #\n\nAnd now, let's run our small test to see that it works, using the following command:\n\n    $ npm run test\n\nIf everything went well, you should have the following messages printed to the terminal:\n\n    sync calculation passed\n    async calculation passed\n\nThat's it. You've just learned the very basics of how to use C++ within NodeJS. There's a lot more to learn when it comes to building an add-on, and I'm not just talking about learning v8 and Nan's API. Think about the possibilities, the C++ community have been active for years and there are so much great libraries out there that are not necessarily relevant to NodeJS due to its efficiency, like [Boost](http://www.boost.org/), [OpenCV](http://opencv.org/), [CGAL](http://www.cgal.org/) and many more.\n\nThis tutorial didn't focus on algorithmics obviously, but it's a good starting point though. Take it from here, and unleash your creativity!"
          }
        ]
      }
    ]
  }
]
