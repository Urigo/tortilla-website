[
  {
    "repoUrl": "https://github.com/Urigo/WhatsApp-Clone-Server",
    "branchName": "master",
    "historyBranchName": "master-history",
    "releases": [
      {
        "releaseVersion": "next",
        "releaseDate": "2019-06-06 07:35:36 +0800",
        "tagName": "master@next",
        "tagRevision": "0ba50cbfa3f61350be1dd3cb72e9e2d8e5ec8a9f",
        "historyRevision": "09999ec8cd88ea88d4ebd7a8d931fe1ac3a41fe7",
        "changesDiff": "diff --git a/.circleci/config.yml b/.circleci/config.yml\nnew file mode 100644\nindex 0000000..b1c76a7\n--- /dev/null\n+++ b/.circleci/config.yml\n@@ -0,0 +1,33 @@\n+version: 2\n+jobs:\n+  build:\n+    working_directory: ~/server/\n+    docker:\n+      - image: circleci/node:12.3.1\n+      - image: postgres:11.3-alpine\n+        environment:\n+          POSTGRES_PASSWORD: testpassword\n+          POSTGRES_USER: testuser\n+          POSTGRES_DB: whatsapp\n+    steps:\n+      - checkout\n+      - restore_cache:\n+          name: Restore Yarn Package Cache\n+          keys:\n+            - yarn-packages-{{ checksum \"yarn.lock\" }}\n+      - run:\n+          name: Install Dependencies\n+          command: yarn\n+      - run:\n+          name: Build\n+          command: yarn build\n+      - run:\n+          name: Test\n+          command: yarn test\n+      - store_test_results:\n+          path: test-results\n+      - save_cache:\n+          name: Save Yarn Package Cache\n+          key: yarn-packages-{{ checksum \"yarn.lock\" }}\n+          paths:\n+            - ~/.cache/yarn\n\\ No newline at end of file\ndiff --git a/.gitignore b/.gitignore\nnew file mode 100644\nindex 0000000..979c3a7\n--- /dev/null\n+++ b/.gitignore\n@@ -0,0 +1,6 @@\n+dist\n+node_modules\n+npm-debug.log\n+test-results/\n+types/graphql.d.ts\n+types/unsplash.d.ts\n\\ No newline at end of file\ndiff --git a/.prettierignore b/.prettierignore\nnew file mode 100644\nindex 0000000..b512c09\n--- /dev/null\n+++ b/.prettierignore\n@@ -0,0 +1 @@\n+node_modules\n\\ No newline at end of file\ndiff --git a/.prettierrc.yml b/.prettierrc.yml\nnew file mode 100644\nindex 0000000..3250279\n--- /dev/null\n+++ b/.prettierrc.yml\n@@ -0,0 +1,4 @@\n+trailingComma: 'es5'\n+tabWidth: 2\n+singleQuote: true\n+parser: 'typescript'\ndiff --git a/.tortilla/manuals/templates/root.tmpl b/.tortilla/manuals/templates/root.tmpl\nnew file mode 100644\nindex 0000000..37c481e\n--- /dev/null\n+++ b/.tortilla/manuals/templates/root.tmpl\n@@ -0,0 +1 @@\n+A newly created Tortilla project. For more information, see https://github.com/Urigo/tortilla.\n\\ No newline at end of file\ndiff --git a/.tortilla/manuals/templates/step1.tmpl b/.tortilla/manuals/templates/step1.tmpl\nnew file mode 100644\nindex 0000000..e69de29\ndiff --git a/.tortilla/manuals/templates/step10.tmpl b/.tortilla/manuals/templates/step10.tmpl\nnew file mode 100644\nindex 0000000..e69de29\ndiff --git a/.tortilla/manuals/templates/step11.tmpl b/.tortilla/manuals/templates/step11.tmpl\nnew file mode 100644\nindex 0000000..e69de29\ndiff --git a/.tortilla/manuals/templates/step12.tmpl b/.tortilla/manuals/templates/step12.tmpl\nnew file mode 100644\nindex 0000000..e69de29\ndiff --git a/.tortilla/manuals/templates/step13.tmpl b/.tortilla/manuals/templates/step13.tmpl\nnew file mode 100644\nindex 0000000..e69de29\ndiff --git a/.tortilla/manuals/templates/step14.tmpl b/.tortilla/manuals/templates/step14.tmpl\nnew file mode 100644\nindex 0000000..e69de29\ndiff --git a/.tortilla/manuals/templates/step2.tmpl b/.tortilla/manuals/templates/step2.tmpl\nnew file mode 100644\nindex 0000000..e69de29\ndiff --git a/.tortilla/manuals/templates/step3.tmpl b/.tortilla/manuals/templates/step3.tmpl\nnew file mode 100644\nindex 0000000..e69de29\ndiff --git a/.tortilla/manuals/templates/step4.tmpl b/.tortilla/manuals/templates/step4.tmpl\nnew file mode 100644\nindex 0000000..e69de29\ndiff --git a/.tortilla/manuals/templates/step5.tmpl b/.tortilla/manuals/templates/step5.tmpl\nnew file mode 100644\nindex 0000000..e69de29\ndiff --git a/.tortilla/manuals/templates/step6.tmpl b/.tortilla/manuals/templates/step6.tmpl\nnew file mode 100644\nindex 0000000..e69de29\ndiff --git a/.tortilla/manuals/templates/step7.tmpl b/.tortilla/manuals/templates/step7.tmpl\nnew file mode 100644\nindex 0000000..e69de29\ndiff --git a/.tortilla/manuals/templates/step8.tmpl b/.tortilla/manuals/templates/step8.tmpl\nnew file mode 100644\nindex 0000000..e69de29\ndiff --git a/.tortilla/manuals/templates/step9.tmpl b/.tortilla/manuals/templates/step9.tmpl\nnew file mode 100644\nindex 0000000..e69de29\ndiff --git a/app.ts b/app.ts\nnew file mode 100644\nindex 0000000..8f9038c\n--- /dev/null\n+++ b/app.ts\n@@ -0,0 +1,15 @@\n+import bodyParser from 'body-parser';\n+import cors from 'cors';\n+import cookieParser from 'cookie-parser';\n+import express from 'express';\n+import { origin } from './env';\n+\n+export const app = express();\n+\n+app.use(cors({ credentials: true, origin }));\n+app.use(bodyParser.json());\n+app.use(cookieParser());\n+\n+app.get('/_ping', (req, res) => {\n+  res.send('pong');\n+});\ndiff --git a/artillery-limit.yml b/artillery-limit.yml\nnew file mode 100644\nindex 0000000..357786a\n--- /dev/null\n+++ b/artillery-limit.yml\n@@ -0,0 +1,77 @@\n+config:\n+  target: 'http://localhost:4000/graphql'\n+  phases:\n+    - duration: 120\n+      arrivalRate: 5\n+    - duration: 120\n+      arrivalRate: 10\n+    - duration: 300\n+      arrivalRate: 10\n+    - duration: 60\n+      arrivalRate: 100\n+scenarios:\n+  - name: 'Sign in, send a new message and fetch a list of chats'\n+    flow:\n+      - post:\n+          url: '/'\n+          json:\n+            variables:\n+              username: 'ray'\n+              password: '111'\n+            query: |\n+              mutation SignIn($username: String!, $password: String!) {\n+                signIn(username: $username, password: $password) {\n+                  id\n+                }\n+              }\n+      - post:\n+          url: '/'\n+          json:\n+            query: |\n+              mutation message {\n+                addMessage(chatId: \"1\", content: \"artillery\") {\n+                  id\n+                }\n+              }\n+      - post:\n+          url: '/'\n+          json:\n+            variables:\n+              limit: 20\n+            query: |\n+              fragment User on User {\n+                id\n+                name\n+                picture\n+              }\n+              fragment Message on Message {\n+                id\n+                content\n+                chat {\n+                  id\n+                }\n+                sender {\n+                  ...User\n+                }\n+                recipient {\n+                  ...User\n+                }\n+              }\n+              query GetChats($limit: Int!) {\n+                chats {\n+                  id\n+                  name\n+                  picture\n+                  lastMessage {\n+                    ...Message\n+                  }\n+                  messages(limit: $limit) {\n+                    messages {\n+                      ...Message\n+                    }\n+                  }\n+                  participants {\n+                    ...User\n+                  }\n+                }\n+              }\n\\ No newline at end of file\ndiff --git a/artillery.yml b/artillery.yml\nnew file mode 100644\nindex 0000000..b590173\n--- /dev/null\n+++ b/artillery.yml\n@@ -0,0 +1,72 @@\n+config:\n+  target: 'http://localhost:4000/graphql'\n+  phases:\n+    - duration: 120\n+      arrivalRate: 5\n+      rampTo: 20\n+scenarios:\n+  - name: 'Sign in, send a new message and fetch a list of chats'\n+    flow:\n+      - post:\n+          url: '/'\n+          json:\n+            variables:\n+              username: 'ray'\n+              password: '111'\n+            query: |\n+              mutation SignIn($username: String!, $password: String!) {\n+                signIn(username: $username, password: $password) {\n+                  id\n+                }\n+              }\n+      - post:\n+          url: '/'\n+          json:\n+            query: |\n+              mutation message {\n+                addMessage(chatId: \"1\", content: \"artillery\") {\n+                  id\n+                }\n+              }\n+      - post:\n+          url: '/'\n+          json:\n+            variables:\n+              limit: 20\n+            query: |\n+              fragment User on User {\n+                id\n+                name\n+                picture\n+              }\n+              fragment Message on Message {\n+                id\n+                content\n+                chat {\n+                  id\n+                }\n+                sender {\n+                  ...User\n+                }\n+                recipient {\n+                  ...User\n+                }\n+              }\n+              query GetChats($limit: Int!) {\n+                chats {\n+                  id\n+                  name\n+                  picture\n+                  lastMessage {\n+                    ...Message\n+                  }\n+                  messages(limit: $limit) {\n+                    messages {\n+                      ...Message\n+                    }\n+                  }\n+                  participants {\n+                    ...User\n+                  }\n+                }\n+              }\ndiff --git a/codegen.yml b/codegen.yml\nnew file mode 100644\nindex 0000000..9542ce7\n--- /dev/null\n+++ b/codegen.yml\n@@ -0,0 +1,23 @@\n+overwrite: true\n+generates:\n+  ./types/graphql.d.ts:\n+    schema: ./modules/*/*.ts\n+    plugins:\n+      - typescript\n+      - typescript-resolvers\n+    config:\n+      useIndexSignature: true\n+      contextType: ../context#MyContext\n+      mappers:\n+        # import { Message } from '../db'\n+        # The root types of Message resolvers\n+        User: ../db#User\n+        Message: ../db#Message\n+        Chat: ../db#Chat\n+      scalars:\n+        # e.g. Message.createdAt will be of type Date\n+        Date: Date\n+  ./types/unsplash.d.ts:\n+    schema: ./logs/main/Unsplash.RandomPhoto.graphql\n+    plugins:\n+      - typescript\ndiff --git a/context.ts b/context.ts\nnew file mode 100644\nindex 0000000..c9ac74a\n--- /dev/null\n+++ b/context.ts\n@@ -0,0 +1,3 @@\n+import { ModuleContext } from '@graphql-modules/core';\n+\n+export type MyContext = ModuleContext;\ndiff --git a/db.ts b/db.ts\nnew file mode 100644\nindex 0000000..3411c00\n--- /dev/null\n+++ b/db.ts\n@@ -0,0 +1,274 @@\n+import { Pool } from 'pg';\n+import sql from 'sql-template-strings';\n+import faker from 'faker';\n+import addMinutes from 'date-fns/add_minutes';\n+import { resetDb as envResetDb, fakedDb } from './env';\n+\n+export type User = {\n+  id: string;\n+  name: string;\n+  username: string;\n+  password: string;\n+  picture: string;\n+};\n+\n+export type Message = {\n+  id: string;\n+  content: string;\n+  created_at: Date;\n+  chat_id: string;\n+  sender_user_id: string;\n+};\n+\n+export type Chat = {\n+  id: string;\n+};\n+\n+export const dbConfig = {\n+  host: 'localhost',\n+  port: 5432,\n+  user: 'testuser',\n+  password: 'testpassword',\n+  database: 'whatsapp',\n+};\n+\n+export let pool: Pool = new Pool(dbConfig);\n+\n+export async function initDb(): Promise<void> {\n+  // Clear tables\n+  await pool.query(sql`DROP TABLE IF EXISTS messages;`);\n+  await pool.query(sql`DROP TABLE IF EXISTS chats_users;`);\n+  await pool.query(sql`DROP TABLE IF EXISTS users;`);\n+  await pool.query(sql`DROP TABLE IF EXISTS chats;`);\n+\n+  // Create tables\n+  await pool.query(sql`CREATE TABLE chats(\n+    id SERIAL PRIMARY KEY\n+  );`);\n+  await pool.query(sql`CREATE TABLE users(\n+    id SERIAL PRIMARY KEY,\n+    username VARCHAR (50) UNIQUE NOT NULL,\n+    name VARCHAR (50) NOT NULL,\n+    password VARCHAR (255) NOT NULL,\n+    picture VARCHAR (255) NOT NULL\n+  );`);\n+  await pool.query(sql`CREATE TABLE chats_users(\n+    chat_id INTEGER NOT NULL REFERENCES chats(id) ON DELETE CASCADE,\n+    user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE\n+  );`);\n+\n+  await pool.query(sql`CREATE TABLE messages(\n+    id SERIAL PRIMARY KEY,\n+    content VARCHAR (355) NOT NULL,\n+    created_at TIMESTAMP NOT NULL DEFAULT NOW(),\n+    chat_id INTEGER NOT NULL REFERENCES chats(id) ON DELETE CASCADE,\n+    sender_user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE\n+  );`);\n+\n+  // Privileges\n+  await pool.query(\n+    sql`GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO testuser;`\n+  );\n+}\n+\n+export const resetDb = async () => {\n+  await initDb();\n+\n+  const sampleUsers = [\n+    {\n+      id: '1',\n+      name: 'Ray Edwards',\n+      username: 'ray',\n+      password: '$2a$08$NO9tkFLCoSqX1c5wk3s7z.JfxaVMKA.m7zUDdDwEquo4rvzimQeJm', // 111\n+      picture: 'https://randomuser.me/api/portraits/thumb/lego/1.jpg',\n+    },\n+    {\n+      id: '2',\n+      name: 'Ethan Gonzalez',\n+      username: 'ethan',\n+      password: '$2a$08$xE4FuCi/ifxjL2S8CzKAmuKLwv18ktksSN.F3XYEnpmcKtpbpeZgO', // 222\n+      picture: 'https://randomuser.me/api/portraits/thumb/men/1.jpg',\n+    },\n+    {\n+      id: '3',\n+      name: 'Bryan Wallace',\n+      username: 'bryan',\n+      password: '$2a$08$UHgH7J8G6z1mGQn2qx2kdeWv0jvgHItyAsL9hpEUI3KJmhVW5Q1d.', // 333\n+      picture: 'https://randomuser.me/api/portraits/thumb/men/2.jpg',\n+    },\n+    {\n+      id: '4',\n+      name: 'Avery Stewart',\n+      username: 'avery',\n+      password: '$2a$08$wR1k5Q3T9FC7fUgB7Gdb9Os/GV7dGBBf4PLlWT7HERMFhmFDt47xi', // 444\n+      picture: 'https://randomuser.me/api/portraits/thumb/women/1.jpg',\n+    },\n+    {\n+      id: '5',\n+      name: 'Katie Peterson',\n+      username: 'katie',\n+      password: '$2a$08$6.mbXqsDX82ZZ7q5d8Osb..JrGSsNp4R3IKj7mxgF6YGT0OmMw242', // 555\n+      picture: 'https://randomuser.me/api/portraits/thumb/women/2.jpg',\n+    },\n+  ];\n+\n+  for (const sampleUser of sampleUsers) {\n+    await pool.query(sql`\n+      INSERT INTO users(id, name, username, password, picture)\n+      VALUES(${sampleUser.id}, ${sampleUser.name}, ${sampleUser.username}, ${\n+      sampleUser.password\n+    }, ${sampleUser.picture})\n+    `);\n+  }\n+\n+  await pool.query(\n+    sql`SELECT setval('users_id_seq', (SELECT max(id) FROM users))`\n+  );\n+\n+  await pool.query(\n+    sql`SELECT setval('users_id_seq', (SELECT max(id) FROM users))`\n+  );\n+\n+  await pool.query(sql`DELETE FROM chats`);\n+\n+  const sampleChats = [\n+    {\n+      id: '1',\n+    },\n+    {\n+      id: '2',\n+    },\n+    {\n+      id: '3',\n+    },\n+    {\n+      id: '4',\n+    },\n+  ];\n+\n+  for (const sampleChat of sampleChats) {\n+    await pool.query(sql`\n+      INSERT INTO chats(id)\n+      VALUES(${sampleChat.id})\n+    `);\n+  }\n+\n+  await pool.query(\n+    sql`SELECT setval('chats_id_seq', (SELECT max(id) FROM chats))`\n+  );\n+\n+  await pool.query(sql`DELETE FROM chats_users`);\n+\n+  const sampleChatsUsers = [\n+    {\n+      chat_id: '1',\n+      user_id: '1',\n+    },\n+    {\n+      chat_id: '1',\n+      user_id: '2',\n+    },\n+    {\n+      chat_id: '2',\n+      user_id: '1',\n+    },\n+    {\n+      chat_id: '2',\n+      user_id: '3',\n+    },\n+    {\n+      chat_id: '3',\n+      user_id: '1',\n+    },\n+    {\n+      chat_id: '3',\n+      user_id: '4',\n+    },\n+    {\n+      chat_id: '4',\n+      user_id: '1',\n+    },\n+    {\n+      chat_id: '4',\n+      user_id: '5',\n+    },\n+  ];\n+\n+  for (const sampleChatUser of sampleChatsUsers) {\n+    await pool.query(sql`\n+      INSERT INTO chats_users(chat_id, user_id)\n+      VALUES(${sampleChatUser.chat_id}, ${sampleChatUser.user_id})\n+    `);\n+  }\n+\n+  await pool.query(sql`DELETE FROM messages`);\n+\n+  const baseTime = new Date('1 Jan 2019 GMT').getTime();\n+\n+  const sampleMessages = [\n+    {\n+      id: '1',\n+      content: 'You on your way?',\n+      created_at: new Date(baseTime - 60 * 1000 * 1000),\n+      chat_id: '1',\n+      sender_user_id: '1',\n+    },\n+    {\n+      id: '2',\n+      content: \"Hey, it's me\",\n+      created_at: new Date(baseTime - 2 * 60 * 1000 * 1000),\n+      chat_id: '2',\n+      sender_user_id: '1',\n+    },\n+    {\n+      id: '3',\n+      content: 'I should buy a boat',\n+      created_at: new Date(baseTime - 24 * 60 * 1000 * 1000),\n+      chat_id: '3',\n+      sender_user_id: '1',\n+    },\n+    {\n+      id: '4',\n+      content: 'This is wicked good ice cream.',\n+      created_at: new Date(baseTime - 14 * 24 * 60 * 1000 * 1000),\n+      chat_id: '4',\n+      sender_user_id: '1',\n+    },\n+  ];\n+\n+  if (fakedDb) {\n+    addFakedMessages(sampleMessages, fakedDb);\n+  }\n+\n+  for (const sampleMessage of sampleMessages) {\n+    await pool.query(sql`\n+      INSERT INTO messages(id, content, created_at, chat_id, sender_user_id)\n+      VALUES(${sampleMessage.id}, ${sampleMessage.content}, ${\n+      sampleMessage.created_at\n+    }, ${sampleMessage.chat_id}, ${sampleMessage.sender_user_id})\n+    `);\n+  }\n+\n+  await pool.query(\n+    sql`SELECT setval('messages_id_seq', (SELECT max(id) FROM messages))`\n+  );\n+};\n+\n+function addFakedMessages(messages: Message[], count: number) {\n+  const message = messages[0];\n+  const date = message.created_at;\n+  const id = messages.length + 1;\n+\n+  new Array(count).fill(0).forEach((_, i) => {\n+    messages.push({\n+      ...message,\n+      id: `${id + i}`,\n+      content: faker.lorem.sentence(4),\n+      created_at: addMinutes(date, i + 1),\n+    });\n+  });\n+}\n+\n+if (envResetDb) {\n+  resetDb();\n+}\ndiff --git a/env.ts b/env.ts\nnew file mode 100644\nindex 0000000..b9c6573\n--- /dev/null\n+++ b/env.ts\n@@ -0,0 +1,10 @@\n+export const expiration = process.env.JWT_EXPIRATION_MS\n+  ? parseInt(process.env.JWT_EXPIRATION_MS)\n+  : 24 * 60 * 60 * 1000;\n+export const secret = process.env.JWT_SECRET || '70p53cr37';\n+export const origin = process.env.ORIGIN || 'http://localhost:3000';\n+export const port = process.env.PORT || 4000;\n+export const resetDb = process.env.RESET_DB || false;\n+export const fakedDb = process.env.FAKED_DB\n+  ? parseInt(process.env.FAKED_DB, 10)\n+  : 0;\ndiff --git a/index.ts b/index.ts\nnew file mode 100644\nindex 0000000..72d5893\n--- /dev/null\n+++ b/index.ts\n@@ -0,0 +1,17 @@\n+import http from 'http';\n+import { app } from './app';\n+import { origin, port } from './env';\n+import { server } from './server';\n+\n+server.applyMiddleware({\n+  app,\n+  path: '/graphql',\n+  cors: { credentials: true, origin },\n+});\n+\n+const httpServer = http.createServer(app);\n+server.installSubscriptionHandlers(httpServer);\n+\n+httpServer.listen(port, () => {\n+  console.log(`Server is listening on port ${port}`);\n+});\ndiff --git a/logs/main/Unsplash.RandomPhoto.2019-05-09T14:45:43.850Z.graphql b/logs/main/Unsplash.RandomPhoto.2019-05-09T14:45:43.850Z.graphql\nnew file mode 100644\nindex 0000000..20139fc\n--- /dev/null\n+++ b/logs/main/Unsplash.RandomPhoto.2019-05-09T14:45:43.850Z.graphql\n@@ -0,0 +1,103 @@\n+type Exif {\n+  make: String!\n+  model: String!\n+  exposure_time: String!\n+  aperture: String!\n+  focal_length: String!\n+  iso: Int!\n+}\n+\n+scalar JSON\n+\n+type Links {\n+  self: String!\n+  html: String!\n+  download: String\n+  download_location: String\n+  photos: String\n+  likes: String\n+  portfolio: String\n+  following: String\n+  followers: String\n+}\n+\n+type Location {\n+  title: String!\n+  name: String!\n+  city: String!\n+  country: String!\n+  position: Position!\n+}\n+\n+type Position {\n+  latitude: Int!\n+  longitude: Int!\n+}\n+\n+type Profile_image {\n+  small: String!\n+  medium: String!\n+  large: String!\n+}\n+\n+type RandomPhoto {\n+  id: String!\n+  created_at: String!\n+  updated_at: String!\n+  width: Int!\n+  height: Int!\n+  color: String!\n+  description: JSON\n+  alt_description: String!\n+  urls: Urls!\n+  links: Links!\n+  categories: [JSON]!\n+  sponsored: Boolean!\n+  sponsored_by: JSON\n+  sponsored_impressions_id: JSON\n+  likes: Int!\n+  liked_by_user: Boolean!\n+  current_user_collections: [JSON]!\n+  user: User!\n+  exif: Exif!\n+  location: Location!\n+  views: Int!\n+  downloads: Int!\n+}\n+\n+input RandomPhotoInput {\n+  query: String!\n+  orientation: String!\n+}\n+\n+type Root {\n+  RandomPhoto(input: RandomPhotoInput): RandomPhoto\n+}\n+\n+type Urls {\n+  raw: String!\n+  full: String!\n+  regular: String!\n+  small: String!\n+  thumb: String!\n+}\n+\n+type User {\n+  id: String!\n+  updated_at: String!\n+  username: String!\n+  name: String!\n+  first_name: String!\n+  last_name: String!\n+  twitter_username: String!\n+  portfolio_url: String!\n+  bio: String!\n+  location: String!\n+  links: Links!\n+  profile_image: Profile_image!\n+  instagram_username: String!\n+  total_collections: Int!\n+  total_likes: Int!\n+  total_photos: Int!\n+  accepted_tos: Boolean!\n+}\ndiff --git a/logs/main/Unsplash.RandomPhoto.2019-05-09T14:45:45.197Z.graphql b/logs/main/Unsplash.RandomPhoto.2019-05-09T14:45:45.197Z.graphql\nnew file mode 100644\nindex 0000000..02152a8\n--- /dev/null\n+++ b/logs/main/Unsplash.RandomPhoto.2019-05-09T14:45:45.197Z.graphql\n@@ -0,0 +1,103 @@\n+type Exif {\n+  make: String!\n+  model: String!\n+  exposure_time: String!\n+  aperture: String!\n+  focal_length: String!\n+  iso: Int!\n+}\n+\n+scalar JSON\n+\n+type Links {\n+  self: String!\n+  html: String!\n+  download: String\n+  download_location: String\n+  photos: String\n+  likes: String\n+  portfolio: String\n+  following: String\n+  followers: String\n+}\n+\n+type Location {\n+  title: String!\n+  name: String!\n+  city: String!\n+  country: String!\n+  position: Position!\n+}\n+\n+type Position {\n+  latitude: Int!\n+  longitude: Int!\n+}\n+\n+type Profile_image {\n+  small: String!\n+  medium: String!\n+  large: String!\n+}\n+\n+type RandomPhoto {\n+  id: String!\n+  created_at: String!\n+  updated_at: String!\n+  width: Int!\n+  height: Int!\n+  color: String!\n+  description: String!\n+  alt_description: String!\n+  urls: Urls!\n+  links: Links!\n+  categories: [JSON]!\n+  sponsored: Boolean!\n+  sponsored_by: JSON\n+  sponsored_impressions_id: JSON\n+  likes: Int!\n+  liked_by_user: Boolean!\n+  current_user_collections: [JSON]!\n+  user: User!\n+  exif: Exif!\n+  location: Location!\n+  views: Int!\n+  downloads: Int!\n+}\n+\n+input RandomPhotoInput {\n+  query: String!\n+  orientation: String!\n+}\n+\n+type Root {\n+  RandomPhoto(input: RandomPhotoInput): RandomPhoto\n+}\n+\n+type Urls {\n+  raw: String!\n+  full: String!\n+  regular: String!\n+  small: String!\n+  thumb: String!\n+}\n+\n+type User {\n+  id: String!\n+  updated_at: String!\n+  username: String!\n+  name: String!\n+  first_name: String!\n+  last_name: String!\n+  twitter_username: String!\n+  portfolio_url: JSON\n+  bio: String!\n+  location: String!\n+  links: Links!\n+  profile_image: Profile_image!\n+  instagram_username: String!\n+  total_collections: Int!\n+  total_likes: Int!\n+  total_photos: Int!\n+  accepted_tos: Boolean!\n+}\ndiff --git a/logs/main/Unsplash.RandomPhoto.graphql b/logs/main/Unsplash.RandomPhoto.graphql\nnew file mode 100644\nindex 0000000..c412c9c\n--- /dev/null\n+++ b/logs/main/Unsplash.RandomPhoto.graphql\n@@ -0,0 +1,103 @@\n+type Exif {\n+  make: String!\n+  model: String!\n+  exposure_time: String!\n+  aperture: String!\n+  focal_length: String!\n+  iso: Int!\n+}\n+\n+scalar JSON\n+\n+type Links {\n+  self: String!\n+  html: String!\n+  download: String\n+  download_location: String\n+  photos: String\n+  likes: String\n+  portfolio: String\n+  following: String\n+  followers: String\n+}\n+\n+type Location {\n+  title: String!\n+  name: String!\n+  city: String!\n+  country: String!\n+  position: Position!\n+}\n+\n+type Position {\n+  latitude: Int!\n+  longitude: Int!\n+}\n+\n+type Profile_image {\n+  small: String!\n+  medium: String!\n+  large: String!\n+}\n+\n+type RandomPhoto {\n+  id: String!\n+  created_at: String!\n+  updated_at: String!\n+  width: Int!\n+  height: Int!\n+  color: String!\n+  description: String!\n+  alt_description: String!\n+  urls: Urls!\n+  links: Links!\n+  categories: [JSON]!\n+  sponsored: Boolean!\n+  sponsored_by: JSON\n+  sponsored_impressions_id: JSON\n+  likes: Int!\n+  liked_by_user: Boolean!\n+  current_user_collections: [JSON]!\n+  user: User!\n+  exif: Exif!\n+  location: Location!\n+  views: Int!\n+  downloads: Int!\n+}\n+\n+input RandomPhotoInput {\n+  query: String!\n+  orientation: String!\n+}\n+\n+type Root {\n+  RandomPhoto(input: RandomPhotoInput): RandomPhoto\n+}\n+\n+type Urls {\n+  raw: String!\n+  full: String!\n+  regular: String!\n+  small: String!\n+  thumb: String!\n+}\n+\n+type User {\n+  id: String!\n+  updated_at: String!\n+  username: String!\n+  name: String!\n+  first_name: String!\n+  last_name: String!\n+  twitter_username: JSON\n+  portfolio_url: JSON\n+  bio: JSON\n+  location: String!\n+  links: Links!\n+  profile_image: Profile_image!\n+  instagram_username: String!\n+  total_collections: Int!\n+  total_likes: Int!\n+  total_photos: Int!\n+  accepted_tos: Boolean!\n+}\ndiff --git a/modules/chats/chats.provider.ts b/modules/chats/chats.provider.ts\nnew file mode 100644\nindex 0000000..f6b1efe\n--- /dev/null\n+++ b/modules/chats/chats.provider.ts\n@@ -0,0 +1,330 @@\n+import { Injectable, Inject, ProviderScope } from '@graphql-modules/di';\n+import { QueryResult } from 'pg';\n+import sql from 'sql-template-strings';\n+import DataLoader from 'dataloader';\n+import format from 'date-fns/format';\n+import { Database } from '../common/database.provider';\n+import { PubSub } from '../common/pubsub.provider';\n+import { Chat } from '../../db';\n+\n+type ChatsByUser = { userId: string };\n+type ChatByUser = { userId: string; chatId: string };\n+type ChatById = { chatId: string };\n+type ChatsKey = ChatById | ChatByUser | ChatsByUser;\n+\n+function isChatsByUser(query: any): query is ChatsByUser {\n+  return query.userId && !query.chatId;\n+}\n+\n+function isChatByUser(query: any): query is ChatByUser {\n+  return query.userId && query.chatId;\n+}\n+\n+@Injectable({\n+  scope: ProviderScope.Session,\n+})\n+export class Chats {\n+  @Inject() private db: Database;\n+  @Inject() private pubsub: PubSub;\n+\n+  private chatsCache = new Map<string, Chat>();\n+  private loaders = {\n+    chats: new DataLoader<ChatsKey, QueryResult['rows']>(keys => {\n+      return Promise.all(\n+        keys.map(async query => {\n+          if (isChatsByUser(query)) {\n+            return this._findChatsByUser(query.userId);\n+          }\n+\n+          if (this.chatsCache.has(query.chatId)) {\n+            return [this._readChatFromCache(query.chatId)];\n+          }\n+\n+          if (isChatByUser(query)) {\n+            return this._findChatByUser(query);\n+          }\n+\n+          return this._findChatById(query.chatId);\n+        })\n+      );\n+    }),\n+  };\n+\n+  async findChatsByUser(userId: string) {\n+    return this.loaders.chats.load({ userId });\n+  }\n+\n+  private async _findChatsByUser(userId: string) {\n+    const { rows } = await this.db.query(sql`\n+      SELECT chats.* FROM chats, chats_users\n+      WHERE chats.id = chats_users.chat_id\n+      AND chats_users.user_id = ${userId}\n+    `);\n+\n+    rows.forEach(row => {\n+      this._writeChatToCache(row);\n+    });\n+\n+    return rows;\n+  }\n+\n+  async findChatByUser({ chatId, userId }: { chatId: string; userId: string }) {\n+    const rows = await this.loaders.chats.load({ chatId, userId });\n+\n+    return rows[0] || null;\n+  }\n+\n+  private async _findChatByUser({\n+    chatId,\n+    userId,\n+  }: {\n+    chatId: string;\n+    userId: string;\n+  }) {\n+    const { rows } = await this.db.query(sql`\n+      SELECT chats.* FROM chats, chats_users\n+      WHERE chats_users.chat_id = ${chatId}\n+      AND chats.id = chats_users.chat_id\n+      AND chats_users.user_id = ${userId}\n+    `);\n+\n+    this._writeChatToCache(rows[0]);\n+\n+    return rows;\n+  }\n+\n+  async findChatById(chatId: string) {\n+    const rows = await this.loaders.chats.load({ chatId });\n+    return rows[0] || null;\n+  }\n+\n+  private async _findChatById(chatId: string) {\n+    const { rows } = await this.db.query(sql`\n+      SELECT * FROM chats WHERE id = ${chatId}\n+    `);\n+\n+    this._writeChatToCache(rows[0]);\n+\n+    return rows;\n+  }\n+\n+  async findMessagesByChat({\n+    chatId,\n+    limit,\n+    after,\n+  }: {\n+    chatId: string;\n+    limit: number;\n+    after?: number | null;\n+  }): Promise<{\n+    hasMore: boolean;\n+    cursor: number | null;\n+    messages: any[];\n+  }> {\n+    const query = sql`SELECT * FROM messages`;\n+    query.append(` WHERE chat_id = ${chatId}`);\n+\n+    if (after) {\n+      // the created_at is the cursor\n+      query.append(` AND created_at < ${cursorToDate(after)}`);\n+    }\n+\n+    query.append(` ORDER BY created_at DESC LIMIT ${limit}`);\n+\n+    const { rows: messages } = await this.db.query(query);\n+\n+    if (!messages) {\n+      return {\n+        hasMore: false,\n+        cursor: null,\n+        messages: [],\n+      };\n+    }\n+\n+    // so we send them as old -> new\n+    messages.reverse();\n+\n+    // cursor is a number representation of created_at\n+    const cursor = new Date(messages[0].created_at).getTime();\n+    const { rows: next } = await this.db.query(\n+      sql`SELECT * FROM messages WHERE chat_id = ${chatId} AND created_at < ${cursorToDate(\n+        cursor\n+      )} ORDER BY created_at DESC LIMIT 1`\n+    );\n+\n+    return {\n+      hasMore: next.length === 1, // means there's no more messages\n+      cursor,\n+      messages,\n+    };\n+  }\n+\n+  async lastMessage(chatId: string) {\n+    const { rows } = await this.db.query(sql`\n+      SELECT * FROM messages\n+      WHERE chat_id = ${chatId}\n+      ORDER BY created_at DESC\n+      LIMIT 1\n+    `);\n+\n+    return rows[0];\n+  }\n+\n+  async firstRecipient({ chatId, userId }: { chatId: string; userId: string }) {\n+    const { rows } = await this.db.query(sql`\n+      SELECT users.* FROM users, chats_users\n+      WHERE users.id != ${userId}\n+      AND users.id = chats_users.user_id\n+      AND chats_users.chat_id = ${chatId}\n+    `);\n+\n+    return rows[0] || null;\n+  }\n+\n+  async participants(chatId: string) {\n+    const { rows } = await this.db.query(sql`\n+      SELECT users.* FROM users, chats_users\n+      WHERE chats_users.chat_id = ${chatId}\n+      AND chats_users.user_id = users.id\n+    `);\n+\n+    return rows;\n+  }\n+\n+  async isParticipant({ chatId, userId }: { chatId: string; userId: string }) {\n+    const { rows } = await this.db.query(sql`\n+      SELECT * FROM chats_users\n+      WHERE chat_id = ${chatId}\n+      AND user_id = ${userId}\n+    `);\n+\n+    return !!rows.length;\n+  }\n+\n+  async addMessage({\n+    chatId,\n+    userId,\n+    content,\n+  }: {\n+    chatId: string;\n+    userId: string;\n+    content: string;\n+  }) {\n+    const { rows } = await this.db.query(sql`\n+      INSERT INTO messages(chat_id, sender_user_id, content)\n+      VALUES(${chatId}, ${userId}, ${content})\n+      RETURNING *\n+    `);\n+\n+    const messageAdded = rows[0];\n+\n+    this.pubsub.publish('messageAdded', {\n+      messageAdded,\n+    });\n+\n+    return messageAdded;\n+  }\n+\n+  async addChat({\n+    userId,\n+    recipientId,\n+  }: {\n+    userId: string;\n+    recipientId: string;\n+  }) {\n+    const { rows } = await this.db.query(sql`\n+      SELECT chats.* FROM chats, (SELECT * FROM chats_users WHERE user_id = ${userId}) AS chats_of_current_user, chats_users\n+      WHERE chats_users.chat_id = chats_of_current_user.chat_id\n+      AND chats.id = chats_users.chat_id\n+      AND chats_users.user_id = ${recipientId}\n+    `);\n+\n+    // If there is already a chat between these two users, return it\n+    if (rows[0]) {\n+      return rows[0];\n+    }\n+\n+    try {\n+      await this.db.query('BEGIN');\n+\n+      const { rows } = await this.db.query(sql`\n+        INSERT INTO chats\n+        DEFAULT VALUES\n+        RETURNING *\n+      `);\n+\n+      const chatAdded = rows[0];\n+\n+      await this.db.query(sql`\n+        INSERT INTO chats_users(chat_id, user_id)\n+        VALUES(${chatAdded.id}, ${userId})\n+      `);\n+\n+      await this.db.query(sql`\n+        INSERT INTO chats_users(chat_id, user_id)\n+        VALUES(${chatAdded.id}, ${recipientId})\n+      `);\n+\n+      await this.db.query('COMMIT');\n+\n+      this.pubsub.publish('chatAdded', {\n+        chatAdded,\n+      });\n+\n+      return chatAdded;\n+    } catch (e) {\n+      await this.db.query('ROLLBACK');\n+      throw e;\n+    }\n+  }\n+\n+  async removeChat({ chatId, userId }: { chatId: string; userId: string }) {\n+    try {\n+      await this.db.query('BEGIN');\n+\n+      const { rows } = await this.db.query(sql`\n+        SELECT chats.* FROM chats, chats_users\n+        WHERE id = ${chatId}\n+        AND chats.id = chats_users.chat_id\n+        AND chats_users.user_id = ${userId}\n+      `);\n+\n+      const chat = rows[0];\n+\n+      if (!chat) {\n+        await this.db.query('ROLLBACK');\n+        return null;\n+      }\n+\n+      await this.db.query(sql`\n+        DELETE FROM chats WHERE chats.id = ${chatId}\n+      `);\n+\n+      this.pubsub.publish('chatRemoved', {\n+        chatRemoved: chat.id,\n+        targetChat: chat,\n+      });\n+\n+      await this.db.query('COMMIT');\n+\n+      return chatId;\n+    } catch (e) {\n+      await this.db.query('ROLLBACK');\n+      throw e;\n+    }\n+  }\n+\n+  private _readChatFromCache(chatId: string) {\n+    return this.chatsCache.get(chatId);\n+  }\n+\n+  private _writeChatToCache(chat?: Chat) {\n+    if (chat) {\n+      this.chatsCache.set(chat.id, chat);\n+    }\n+  }\n+}\n+\n+function cursorToDate(cursor: number) {\n+  return `'${format(cursor, 'YYYY-MM-DD HH:mm:ss')}'`;\n+}\ndiff --git a/modules/chats/index.ts b/modules/chats/index.ts\nnew file mode 100644\nindex 0000000..708b6ab\n--- /dev/null\n+++ b/modules/chats/index.ts\n@@ -0,0 +1,244 @@\n+import { GraphQLModule } from '@graphql-modules/core';\n+import { gql, withFilter } from 'apollo-server-express';\n+import commonModule from '../common';\n+import usersModule from '../users';\n+import { Message, Chat } from '../../db';\n+import { Resolvers } from '../../types/graphql';\n+import { UnsplashApi } from './unsplash.api';\n+import { Users } from './../users/users.provider';\n+import { Auth } from './../users/auth.provider';\n+import { Chats } from './chats.provider';\n+import { PubSub } from '../common/pubsub.provider';\n+\n+const typeDefs = gql`\n+  type Message {\n+    id: ID!\n+    content: String!\n+    createdAt: DateTime!\n+    chat: Chat\n+    sender: User\n+    recipient: User\n+    isMine: Boolean!\n+  }\n+\n+  type MessagesResult {\n+    cursor: Float\n+    hasMore: Boolean!\n+    messages: [Message!]!\n+  }\n+\n+  type Chat {\n+    id: ID!\n+    name: String\n+    picture: String\n+    lastMessage: Message\n+    messages(limit: Int!, after: Float): MessagesResult!\n+    participants: [User!]!\n+  }\n+\n+  extend type Query {\n+    chats: [Chat!]!\n+    chat(chatId: ID!): Chat\n+  }\n+\n+  extend type Mutation {\n+    addMessage(chatId: ID!, content: String!): Message\n+    addChat(recipientId: ID!): Chat\n+    removeChat(chatId: ID!): ID\n+  }\n+\n+  extend type Subscription {\n+    messageAdded: Message!\n+    chatAdded: Chat!\n+    chatRemoved: ID!\n+  }\n+`;\n+\n+const resolvers: Resolvers = {\n+  Message: {\n+    createdAt(message) {\n+      return new Date(message.created_at);\n+    },\n+\n+    async chat(message, args, { injector }) {\n+      return injector.get(Chats).findChatById(message.chat_id);\n+    },\n+\n+    async sender(message, args, { injector }) {\n+      return injector.get(Users).findById(message.sender_user_id);\n+    },\n+\n+    async recipient(message, args, { injector }) {\n+      return injector.get(Chats).firstRecipient({\n+        chatId: message.chat_id,\n+        userId: message.sender_user_id,\n+      });\n+    },\n+\n+    async isMine(message, args, { injector }) {\n+      const currentUser = await injector.get(Auth).currentUser();\n+      return message.sender_user_id === currentUser!.id;\n+    },\n+  },\n+\n+  Chat: {\n+    async name(chat, args, { injector }) {\n+      const currentUser = await injector.get(Auth).currentUser();\n+\n+      if (!currentUser) return null;\n+\n+      const participant = await injector.get(Chats).firstRecipient({\n+        chatId: chat.id,\n+        userId: currentUser.id,\n+      });\n+\n+      return participant ? participant.name : null;\n+    },\n+\n+    async picture(chat, args, { injector }) {\n+      const currentUser = await injector.get(Auth).currentUser();\n+\n+      if (!currentUser) return null;\n+\n+      const participant = await injector.get(Chats).firstRecipient({\n+        chatId: chat.id,\n+        userId: currentUser.id,\n+      });\n+\n+      return participant && participant.picture\n+        ? participant.picture\n+        : injector.get(UnsplashApi).getRandomPhoto();\n+    },\n+\n+    async messages(chat, args, { injector }) {\n+      return injector.get(Chats).findMessagesByChat({\n+        chatId: chat.id,\n+        limit: args.limit,\n+        after: args.after,\n+      });\n+    },\n+\n+    async lastMessage(chat, args, { injector }) {\n+      return injector.get(Chats).lastMessage(chat.id);\n+    },\n+\n+    async participants(chat, args, { injector }) {\n+      return injector.get(Chats).participants(chat.id);\n+    },\n+  },\n+\n+  Query: {\n+    async chats(root, args, { injector }) {\n+      const currentUser = await injector.get(Auth).currentUser();\n+\n+      if (!currentUser) return [];\n+\n+      return injector.get(Chats).findChatsByUser(currentUser.id);\n+    },\n+\n+    async chat(root, { chatId }, { injector }) {\n+      const currentUser = await injector.get(Auth).currentUser();\n+\n+      if (!currentUser) return null;\n+\n+      return injector\n+        .get(Chats)\n+        .findChatByUser({ chatId, userId: currentUser.id });\n+    },\n+  },\n+\n+  Mutation: {\n+    async addMessage(root, { chatId, content }, { injector }) {\n+      const currentUser = await injector.get(Auth).currentUser();\n+\n+      if (!currentUser) return null;\n+\n+      return injector\n+        .get(Chats)\n+        .addMessage({ chatId, content, userId: currentUser.id });\n+    },\n+\n+    async addChat(root, { recipientId }, { injector }) {\n+      const currentUser = await injector.get(Auth).currentUser();\n+\n+      if (!currentUser) return null;\n+\n+      return injector\n+        .get(Chats)\n+        .addChat({ recipientId, userId: currentUser.id });\n+    },\n+\n+    async removeChat(root, { chatId }, { injector }) {\n+      const currentUser = await injector.get(Auth).currentUser();\n+\n+      if (!currentUser) return null;\n+\n+      return injector.get(Chats).removeChat({ chatId, userId: currentUser.id });\n+    },\n+  },\n+\n+  Subscription: {\n+    messageAdded: {\n+      subscribe: withFilter(\n+        (root, args, { injector }) =>\n+          injector.get(PubSub).asyncIterator('messageAdded'),\n+        async (\n+          { messageAdded }: { messageAdded: Message },\n+          args,\n+          { injector }\n+        ) => {\n+          const currentUser = await injector.get(Auth).currentUser();\n+\n+          if (!currentUser) return false;\n+\n+          return injector.get(Chats).isParticipant({\n+            chatId: messageAdded.chat_id,\n+            userId: currentUser.id,\n+          });\n+        }\n+      ),\n+    },\n+\n+    chatAdded: {\n+      subscribe: withFilter(\n+        (root, args, { injector }) =>\n+          injector.get(PubSub).asyncIterator('chatAdded'),\n+        async ({ chatAdded }: { chatAdded: Chat }, args, { injector }) => {\n+          const currentUser = await injector.get(Auth).currentUser();\n+\n+          if (!currentUser) return false;\n+\n+          return injector.get(Chats).isParticipant({\n+            chatId: chatAdded.id,\n+            userId: currentUser.id,\n+          });\n+        }\n+      ),\n+    },\n+\n+    chatRemoved: {\n+      subscribe: withFilter(\n+        (root, args, { injector }) =>\n+          injector.get(PubSub).asyncIterator('chatRemoved'),\n+        async ({ targetChat }: { targetChat: Chat }, args, { injector }) => {\n+          const currentUser = await injector.get(Auth).currentUser();\n+\n+          if (!currentUser) return false;\n+\n+          return injector.get(Chats).isParticipant({\n+            chatId: targetChat.id,\n+            userId: currentUser.id,\n+          });\n+        }\n+      ),\n+    },\n+  },\n+};\n+\n+export default new GraphQLModule({\n+  name: 'chats',\n+  typeDefs,\n+  resolvers,\n+  imports: () => [commonModule, usersModule],\n+  providers: () => [UnsplashApi, Chats],\n+});\ndiff --git a/modules/chats/unsplash.api.ts b/modules/chats/unsplash.api.ts\nnew file mode 100644\nindex 0000000..7b08c81\n--- /dev/null\n+++ b/modules/chats/unsplash.api.ts\n@@ -0,0 +1,52 @@\n+import { Injectable, ProviderScope } from '@graphql-modules/di';\n+import { resolve } from 'path';\n+import axios from 'axios';\n+import { trackProvider } from '@safe-api/middleware';\n+import { RandomPhoto } from '../../types/unsplash';\n+\n+interface RandomPhotoInput {\n+  query: string;\n+  orientation: 'landscape' | 'portrait' | 'squarish';\n+}\n+\n+@Injectable({\n+  scope: ProviderScope.Application,\n+})\n+export class UnsplashApi {\n+  baseURL = 'https://api.unsplash.com/';\n+\n+  async getRandomPhoto() {\n+    const trackedRandomPhoto = await trackProvider(\n+      async ({ query, orientation }: RandomPhotoInput) => {\n+        const response = await axios.get<RandomPhoto>('photos/random', {\n+          baseURL: this.baseURL,\n+          headers: {\n+            Authorization:\n+              'Client-ID 4d048cfb4383b407eff92e4a2a5ec36c0a866be85e64caafa588c110efad350d',\n+          },\n+          params: {\n+            query,\n+            orientation,\n+          },\n+        });\n+\n+        return response.data;\n+      },\n+      {\n+        provider: 'Unsplash',\n+        method: 'RandomPhoto',\n+        location: resolve(__dirname, '../logs/main'),\n+      }\n+    );\n+\n+    try {\n+      return (await trackedRandomPhoto({\n+        query: 'portrait',\n+        orientation: 'squarish',\n+      })).urls.small;\n+    } catch (err) {\n+      console.error('Cannot retrieve random photo:', err);\n+      return null;\n+    }\n+  }\n+}\ndiff --git a/modules/common/database.provider.ts b/modules/common/database.provider.ts\nnew file mode 100644\nindex 0000000..6798a4e\n--- /dev/null\n+++ b/modules/common/database.provider.ts\n@@ -0,0 +1,57 @@\n+import { Injectable, ProviderScope } from '@graphql-modules/di';\n+import { OnResponse } from '@graphql-modules/core';\n+import { Pool, PoolClient, QueryResult } from 'pg';\n+import { SQLStatement } from 'sql-template-strings';\n+import Dataloader from 'dataloader';\n+\n+@Injectable({\n+  scope: ProviderScope.Session,\n+})\n+export class Database implements OnResponse {\n+  private instance: PoolClient;\n+  private loader: Dataloader<string | SQLStatement, QueryResult>;\n+\n+  constructor(private pool: Pool) {\n+    this.loader = new Dataloader(\n+      queries =>\n+        Promise.all(\n+          queries.map(async query => {\n+            const db = await this.getClient();\n+            return db.query(query);\n+          })\n+        ),\n+      {\n+        cacheKeyFn: (key: string | SQLStatement) => {\n+          let id: string;\n+\n+          if (typeof key === 'string') {\n+            id = key;\n+          } else {\n+            id = key.text + ' - ' + JSON.stringify(key.values);\n+          }\n+\n+          return id;\n+        },\n+        batch: false,\n+      }\n+    );\n+  }\n+\n+  async onRequest() {\n+    this.instance = await this.pool.connect();\n+  }\n+\n+  onResponse() {\n+    if (this.instance) {\n+      this.instance.release();\n+    }\n+  }\n+\n+  private getClient() {\n+    return this.instance;\n+  }\n+\n+  query(query: SQLStatement | string) {\n+    return this.loader.load(query);\n+  }\n+}\ndiff --git a/modules/common/index.ts b/modules/common/index.ts\nnew file mode 100644\nindex 0000000..ddad1f0\n--- /dev/null\n+++ b/modules/common/index.ts\n@@ -0,0 +1,57 @@\n+import { GraphQLModule } from '@graphql-modules/core';\n+import { ProviderScope } from '@graphql-modules/di';\n+import { gql } from 'apollo-server-express';\n+import { GraphQLDateTime } from 'graphql-iso-date';\n+import { Pool } from 'pg';\n+import { pool } from '../../db';\n+import { Resolvers } from '../../types/graphql';\n+import { Database } from './database.provider';\n+import { PubSub } from './pubsub.provider';\n+\n+const { PostgresPubSub } = require('graphql-postgres-subscriptions');\n+\n+const typeDefs = gql`\n+  scalar DateTime\n+\n+  type Query {\n+    _dummy: Boolean\n+  }\n+\n+  type Mutation {\n+    _dummy: Boolean\n+  }\n+\n+  type Subscription {\n+    _dummy: Boolean\n+  }\n+`;\n+\n+const resolvers: Resolvers = {\n+  DateTime: GraphQLDateTime,\n+};\n+\n+const pubsub = new PostgresPubSub({\n+  host: 'localhost',\n+  port: 5432,\n+  user: 'testuser',\n+  password: 'testpassword',\n+  database: 'whatsapp',\n+});\n+\n+export default new GraphQLModule({\n+  name: 'common',\n+  typeDefs,\n+  resolvers,\n+  providers: () => [\n+    {\n+      provide: Pool,\n+      useValue: pool,\n+    },\n+    {\n+      provide: PubSub,\n+      scope: ProviderScope.Application,\n+      useValue: pubsub,\n+    },\n+    Database,\n+  ],\n+});\ndiff --git a/modules/common/pubsub.provider.ts b/modules/common/pubsub.provider.ts\nnew file mode 100644\nindex 0000000..cf85ba4\n--- /dev/null\n+++ b/modules/common/pubsub.provider.ts\n@@ -0,0 +1 @@\n+export { PubSub } from 'apollo-server-express';\ndiff --git a/modules/users/auth.provider.ts b/modules/users/auth.provider.ts\nnew file mode 100644\nindex 0000000..c3bd604\n--- /dev/null\n+++ b/modules/users/auth.provider.ts\n@@ -0,0 +1,95 @@\n+import { Injectable, Inject, ProviderScope } from '@graphql-modules/di';\n+import { ModuleSessionInfo } from '@graphql-modules/core';\n+import { Response } from 'express';\n+import bcrypt from 'bcrypt';\n+import jwt from 'jsonwebtoken';\n+import { secret, expiration } from '../../env';\n+import { validateLength, validatePassword } from '../../validators';\n+import { Users } from './users.provider';\n+import { User } from '../../db';\n+\n+@Injectable({\n+  scope: ProviderScope.Session,\n+})\n+export class Auth {\n+  @Inject() private users: Users;\n+  @Inject() private module: ModuleSessionInfo;\n+  private _currentUser: User;\n+\n+  private get req() {\n+    return this.module.session.req || this.module.session.request;\n+  }\n+\n+  private get res(): Response {\n+    return this.module.session.res;\n+  }\n+\n+  async signIn({ username, password }: { username: string; password: string }) {\n+    const user = await this.users.findByUsername(username);\n+\n+    if (!user) {\n+      throw new Error('user not found');\n+    }\n+\n+    const passwordsMatch = bcrypt.compareSync(password, user.password);\n+\n+    if (!passwordsMatch) {\n+      throw new Error('password is incorrect');\n+    }\n+\n+    const authToken = jwt.sign(username, secret);\n+\n+    this.res.cookie('authToken', authToken, { maxAge: expiration });\n+\n+    return user;\n+  }\n+\n+  async signUp({\n+    name,\n+    password,\n+    passwordConfirm,\n+    username,\n+  }: {\n+    name: string;\n+    password: string;\n+    passwordConfirm: string;\n+    username: string;\n+  }) {\n+    validateLength('req.name', name, 3, 50);\n+    validateLength('req.username', name, 3, 18);\n+    validatePassword('req.password', password);\n+\n+    if (password !== passwordConfirm) {\n+      throw Error(\"req.password and req.passwordConfirm don't match\");\n+    }\n+\n+    const existingUser = await this.users.findByUsername(username);\n+\n+    if (existingUser) {\n+      throw Error('username already exists');\n+    }\n+\n+    return this.users.newUser({\n+      username,\n+      name,\n+      password,\n+    });\n+  }\n+\n+  async currentUser(): Promise<User | null> {\n+    if (this._currentUser) {\n+      return this._currentUser;\n+    }\n+\n+    if (this.req.cookies.authToken) {\n+      const username = jwt.verify(this.req.cookies.authToken, secret) as string;\n+\n+      if (username) {\n+        this._currentUser = await this.users.findByUsername(username);\n+        return this._currentUser;\n+      }\n+    }\n+\n+    return null;\n+  }\n+}\ndiff --git a/modules/users/index.ts b/modules/users/index.ts\nnew file mode 100644\nindex 0000000..74f7601\n--- /dev/null\n+++ b/modules/users/index.ts\n@@ -0,0 +1,67 @@\n+import { GraphQLModule } from '@graphql-modules/core';\n+import { gql } from 'apollo-server-express';\n+import commonModule from '../common';\n+import { Resolvers } from '../../types/graphql';\n+import { Users } from './users.provider';\n+import { Auth } from './auth.provider';\n+\n+const typeDefs = gql`\n+  type User {\n+    id: ID!\n+    name: String!\n+    picture: String\n+  }\n+\n+  extend type Query {\n+    me: User\n+    users: [User!]!\n+  }\n+\n+  extend type Mutation {\n+    signIn(username: String!, password: String!): User\n+    signUp(\n+      name: String!\n+      username: String!\n+      password: String!\n+      passwordConfirm: String!\n+    ): User\n+  }\n+`;\n+\n+const resolvers: Resolvers = {\n+  Query: {\n+    me(root, args, { injector }) {\n+      return injector.get(Auth).currentUser();\n+    },\n+    async users(root, args, { injector }) {\n+      const currentUser = await injector.get(Auth).currentUser();\n+\n+      if (!currentUser) return [];\n+\n+      return injector.get(Users).findAllExcept(currentUser.id);\n+    },\n+  },\n+  Mutation: {\n+    async signIn(root, { username, password }, { injector }) {\n+      return injector.get(Auth).signIn({ username, password });\n+    },\n+\n+    async signUp(\n+      root,\n+      { name, username, password, passwordConfirm },\n+      { injector }\n+    ) {\n+      return injector\n+        .get(Auth)\n+        .signUp({ name, username, password, passwordConfirm });\n+    },\n+  },\n+};\n+\n+export default new GraphQLModule({\n+  name: 'users',\n+  typeDefs,\n+  resolvers,\n+  imports: () => [commonModule],\n+  providers: () => [Users, Auth],\n+});\ndiff --git a/modules/users/users.provider.ts b/modules/users/users.provider.ts\nnew file mode 100644\nindex 0000000..51965e4\n--- /dev/null\n+++ b/modules/users/users.provider.ts\n@@ -0,0 +1,55 @@\n+import { Injectable, Inject, ProviderScope } from '@graphql-modules/di';\n+import sql from 'sql-template-strings';\n+import bcrypt from 'bcrypt';\n+import { Database } from '../common/database.provider';\n+\n+@Injectable({\n+  scope: ProviderScope.Session,\n+})\n+export class Users {\n+  @Inject() private db: Database;\n+\n+  async findById(userId: string) {\n+    const { rows } = await this.db.query(\n+      sql`SELECT * FROM users WHERE id = ${userId}`\n+    );\n+\n+    return rows[0] || null;\n+  }\n+\n+  async findAllExcept(userId: string) {\n+    const { rows } = await this.db.query(\n+      sql`SELECT * FROM users WHERE id != ${userId}`\n+    );\n+\n+    return rows;\n+  }\n+\n+  async findByUsername(username: string) {\n+    const { rows } = await this.db.query(\n+      sql`SELECT * FROM users WHERE username = ${username}`\n+    );\n+\n+    return rows[0] || null;\n+  }\n+\n+  async newUser({\n+    username,\n+    name,\n+    password,\n+  }: {\n+    username: string;\n+    name: string;\n+    password: string;\n+  }) {\n+    const passwordHash = bcrypt.hashSync(password, bcrypt.genSaltSync(8));\n+    const createdUserQuery = await this.db.query(sql`\n+        INSERT INTO users(password, picture, username, name)\n+        VALUES(${passwordHash}, '', ${username}, ${name})\n+        RETURNING *\n+      `);\n+    const user = createdUserQuery.rows[0];\n+\n+    return user;\n+  }\n+}\ndiff --git a/package.json b/package.json\nnew file mode 100644\nindex 0000000..cae52b1\n--- /dev/null\n+++ b/package.json\n@@ -0,0 +1,92 @@\n+{\n+  \"name\": \"whatsapp-clone-server\",\n+  \"description\": \"A newly created Tortilla project\",\n+  \"repository\": {\n+    \"type\": \"git\",\n+    \"url\": \"https://github.com/Urigo/WhatsApp-Clone-Server.git\"\n+  },\n+  \"private\": true,\n+  \"scripts\": {\n+    \"prestart\": \"yarn codegen\",\n+    \"start\": \"ts-node index.ts\",\n+    \"prebuild\": \"yarn codegen\",\n+    \"prod\": \"node dist/index.js\",\n+    \"build\": \"tsc\",\n+    \"test\": \"jest --runInBand --forceExit\",\n+    \"codegen\": \"gql-gen\",\n+    \"format\": \"prettier '**/*.ts' --write\",\n+    \"loadtest\": \"yarn artillery run artillery.yml > loadtest.log\",\n+    \"loadtest:limit\": \"yarn artillery run artillery-limit.yml > loadtest.log\"\n+  },\n+  \"jest-junit\": {\n+    \"outputDirectory\": \"./test-results\"\n+  },\n+  \"devDependencies\": {\n+    \"@graphql-codegen/cli\": \"1.2.1-alpha-3d654462.34\",\n+    \"@graphql-codegen/typescript\": \"1.2.1-alpha-3d654462.34\",\n+    \"@graphql-codegen/typescript-resolvers\": \"1.2.1-alpha-3d654462.34\",\n+    \"@types/bcrypt\": \"3.0.0\",\n+    \"@types/body-parser\": \"1.17.0\",\n+    \"@types/cookie\": \"0.3.3\",\n+    \"@types/cookie-parser\": \"1.4.1\",\n+    \"@types/cors\": \"2.8.5\",\n+    \"@types/express\": \"4.16.1\",\n+    \"@types/faker\": \"4.1.5\",\n+    \"@types/graphql\": \"14.2.0\",\n+    \"@types/graphql-iso-date\": \"3.3.1\",\n+    \"@types/jest\": \"24.0.13\",\n+    \"@types/jsonwebtoken\": \"8.3.2\",\n+    \"@types/lodash\": \"4.14.133\",\n+    \"@types/node\": \"12.0.4\",\n+    \"@types/pg\": \"7.4.14\",\n+    \"artillery\": \"1.6.0-28\",\n+    \"jest\": \"24.8.0\",\n+    \"jest-junit\": \"6.4.0\",\n+    \"prettier\": \"1.17.1\",\n+    \"ts-jest\": \"24.0.2\",\n+    \"ts-node\": \"8.2.0\",\n+    \"typescript\": \"3.5.1\"\n+  },\n+  \"dependencies\": {\n+    \"@graphql-modules/core\": \"0.7.5\",\n+    \"@graphql-modules/di\": \"0.7.5\",\n+    \"@safe-api/middleware\": \"0.0.2\",\n+    \"apollo-datasource-rest\": \"0.5.0\",\n+    \"apollo-server-express\": \"2.6.1\",\n+    \"apollo-server-testing\": \"2.6.1\",\n+    \"axios\": \"0.19.0\",\n+    \"bcrypt\": \"3.0.6\",\n+    \"body-parser\": \"1.19.0\",\n+    \"cookie\": \"0.4.0\",\n+    \"cookie-parser\": \"1.4.4\",\n+    \"cors\": \"2.8.5\",\n+    \"dataloader\": \"1.4.0\",\n+    \"date-fns\": \"1.30.1\",\n+    \"express\": \"4.17.1\",\n+    \"faker\": \"4.1.0\",\n+    \"graphql\": \"14.3.1\",\n+    \"graphql-import\": \"0.7.1\",\n+    \"graphql-iso-date\": \"3.6.1\",\n+    \"graphql-postgres-subscriptions\": \"1.0.5\",\n+    \"graphql-tools\": \"4.0.4\",\n+    \"jsonwebtoken\": \"8.5.1\",\n+    \"lodash\": \"4.17.11\",\n+    \"pg\": \"7.11.0\",\n+    \"reflect-metadata\": \"0.1.13\",\n+    \"sql-template-strings\": \"2.2.2\"\n+  },\n+  \"jest\": {\n+    \"transform\": {\n+      \"^.+\\\\.(js|jsx|ts|tsx)$\": \"<rootDir>/node_modules/ts-jest\"\n+    },\n+    \"globals\": {\n+      \"ts-jest\": {\n+        \"diagnostics\": false\n+      }\n+    },\n+    \"reporters\": [\n+      \"default\",\n+      \"jest-junit\"\n+    ]\n+  }\n+}\ndiff --git a/renovate.json b/renovate.json\nnew file mode 100644\nindex 0000000..216ef3c\n--- /dev/null\n+++ b/renovate.json\n@@ -0,0 +1,23 @@\n+{\n+    \"extends\": [\"config:base\", \":rebaseStalePrs\"],\n+    \"baseBranches\": [\n+      \"master\",\n+      \"master-root\",\n+      \"master-step1\",\n+      \"master-step2\",\n+      \"master-step3\",\n+      \"master-step4\",\n+      \"master-step5\",\n+      \"master-step6\",\n+      \"master-step7\",\n+      \"master-step8\",\n+      \"master-step9\",\n+      \"master-step10\",\n+      \"master-step11\",\n+      \"master-step12\",\n+      \"master-step13\"\n+    ],\n+    \"prHourlyLimit\": 60,\n+    \"recreateClosed\": true,\n+    \"rangeStrategy\": \"lockfile-update\"\n+  }\n\\ No newline at end of file\ndiff --git a/server.ts b/server.ts\nnew file mode 100644\nindex 0000000..ce1b8bb\n--- /dev/null\n+++ b/server.ts\n@@ -0,0 +1,29 @@\n+import 'reflect-metadata';\n+import { ApolloServer } from 'apollo-server-express';\n+import { GraphQLModule } from '@graphql-modules/core';\n+import cookie from 'cookie';\n+\n+import usersModule from './modules/users';\n+import chatsModule from './modules/chats';\n+\n+export const rootModule = new GraphQLModule({\n+  name: 'root',\n+  imports: [usersModule, chatsModule],\n+});\n+\n+export const server = new ApolloServer({\n+  schema: rootModule.schema,\n+  context: (session: any) => {\n+    if (session.connection) {\n+      const req = session.connection.context.session.request;\n+      const cookies = req.headers.cookie;\n+\n+      if (cookies) {\n+        req.cookies = cookie.parse(cookies);\n+      }\n+    }\n+\n+    return rootModule.context(session);\n+  },\n+  subscriptions: rootModule.subscriptions,\n+});\ndiff --git a/tests/mocks/auth.provider.ts b/tests/mocks/auth.provider.ts\nnew file mode 100644\nindex 0000000..6f2d5af\n--- /dev/null\n+++ b/tests/mocks/auth.provider.ts\n@@ -0,0 +1,21 @@\n+import sql from 'sql-template-strings';\n+import { Auth } from './../../modules/users/auth.provider';\n+import usersModule from './../../modules/users';\n+import { pool } from '../../db';\n+\n+export function mockAuth(userId: number) {\n+  class AuthMock extends Auth {\n+    async currentUser() {\n+      const { rows } = await pool.query(\n+        sql`SELECT * FROM users WHERE id = ${userId}`\n+      );\n+      return rows[0];\n+    }\n+  }\n+\n+  usersModule.injector.provide({\n+    provide: Auth,\n+    useClass: AuthMock,\n+    overwrite: true,\n+  });\n+}\ndiff --git a/tests/mutations/__snapshots__/addChat.test.ts.snap b/tests/mutations/__snapshots__/addChat.test.ts.snap\nnew file mode 100644\nindex 0000000..d1d9f44\n--- /dev/null\n+++ b/tests/mutations/__snapshots__/addChat.test.ts.snap\n@@ -0,0 +1,52 @@\n+// Jest Snapshot v1, https://goo.gl/fbAQLP\n+\n+exports[`Mutation.addChat creates a new chat between current user and specified recipient 1`] = `\n+Object {\n+  \"addChat\": Object {\n+    \"id\": \"5\",\n+    \"name\": \"Bryan Wallace\",\n+    \"participants\": Array [\n+      Object {\n+        \"id\": \"2\",\n+      },\n+      Object {\n+        \"id\": \"3\",\n+      },\n+    ],\n+  },\n+}\n+`;\n+\n+exports[`Mutation.addChat creates a new chat between current user and specified recipient 2`] = `\n+Object {\n+  \"chat\": Object {\n+    \"id\": \"5\",\n+    \"name\": \"Bryan Wallace\",\n+    \"participants\": Array [\n+      Object {\n+        \"id\": \"2\",\n+      },\n+      Object {\n+        \"id\": \"3\",\n+      },\n+    ],\n+  },\n+}\n+`;\n+\n+exports[`Mutation.addChat returns the existing chat if so 1`] = `\n+Object {\n+  \"addChat\": Object {\n+    \"id\": \"1\",\n+    \"name\": \"Ethan Gonzalez\",\n+    \"participants\": Array [\n+      Object {\n+        \"id\": \"1\",\n+      },\n+      Object {\n+        \"id\": \"2\",\n+      },\n+    ],\n+  },\n+}\n+`;\ndiff --git a/tests/mutations/__snapshots__/addMessage.test.ts.snap b/tests/mutations/__snapshots__/addMessage.test.ts.snap\nnew file mode 100644\nindex 0000000..0e88349\n--- /dev/null\n+++ b/tests/mutations/__snapshots__/addMessage.test.ts.snap\n@@ -0,0 +1,22 @@\n+// Jest Snapshot v1, https://goo.gl/fbAQLP\n+\n+exports[`Mutation.addMessage should add message to specified chat 1`] = `\n+Object {\n+  \"addMessage\": Object {\n+    \"content\": \"Hello World\",\n+    \"id\": \"5\",\n+  },\n+}\n+`;\n+\n+exports[`Mutation.addMessage should add message to specified chat 2`] = `\n+Object {\n+  \"chat\": Object {\n+    \"id\": \"1\",\n+    \"lastMessage\": Object {\n+      \"content\": \"Hello World\",\n+      \"id\": \"5\",\n+    },\n+  },\n+}\n+`;\ndiff --git a/tests/mutations/addChat.test.ts b/tests/mutations/addChat.test.ts\nnew file mode 100644\nindex 0000000..2c33de7\n--- /dev/null\n+++ b/tests/mutations/addChat.test.ts\n@@ -0,0 +1,78 @@\n+import { createTestClient } from 'apollo-server-testing';\n+import { gql } from 'apollo-server-express';\n+import { server } from '../../server';\n+import { resetDb } from '../../db';\n+import { mockAuth } from '../mocks/auth.provider';\n+\n+describe('Mutation.addChat', () => {\n+  beforeEach(resetDb);\n+\n+  it('creates a new chat between current user and specified recipient', async () => {\n+    mockAuth(2);\n+\n+    const { query, mutate } = createTestClient(server);\n+\n+    const addChatRes = await mutate({\n+      variables: { recipientId: '3' },\n+      mutation: gql`\n+        mutation AddChat($recipientId: ID!) {\n+          addChat(recipientId: $recipientId) {\n+            id\n+            name\n+            participants {\n+              id\n+            }\n+          }\n+        }\n+      `,\n+    });\n+\n+    expect(addChatRes.data).toBeDefined();\n+    expect(addChatRes.errors).toBeUndefined();\n+    expect(addChatRes.data).toMatchSnapshot();\n+\n+    const getChatRes = await query({\n+      variables: { chatId: '5' },\n+      query: gql`\n+        query GetChat($chatId: ID!) {\n+          chat(chatId: $chatId) {\n+            id\n+            name\n+            participants {\n+              id\n+            }\n+          }\n+        }\n+      `,\n+    });\n+\n+    expect(getChatRes.data).toBeDefined();\n+    expect(getChatRes.errors).toBeUndefined();\n+    expect(getChatRes.data).toMatchSnapshot();\n+  });\n+\n+  it('returns the existing chat if so', async () => {\n+    mockAuth(1);\n+\n+    const { query, mutate } = createTestClient(server);\n+\n+    const addChatRes = await mutate({\n+      variables: { recipientId: '2' },\n+      mutation: gql`\n+        mutation AddChat($recipientId: ID!) {\n+          addChat(recipientId: $recipientId) {\n+            id\n+            name\n+            participants {\n+              id\n+            }\n+          }\n+        }\n+      `,\n+    });\n+\n+    expect(addChatRes.data).toBeDefined();\n+    expect(addChatRes.errors).toBeUndefined();\n+    expect(addChatRes.data).toMatchSnapshot();\n+  });\n+});\ndiff --git a/tests/mutations/addMessage.test.ts b/tests/mutations/addMessage.test.ts\nnew file mode 100644\nindex 0000000..60e2995\n--- /dev/null\n+++ b/tests/mutations/addMessage.test.ts\n@@ -0,0 +1,50 @@\n+import { createTestClient } from 'apollo-server-testing';\n+import { gql } from 'apollo-server-express';\n+import { server } from '../../server';\n+import { resetDb } from '../../db';\n+import { mockAuth } from '../mocks/auth.provider';\n+\n+describe('Mutation.addMessage', () => {\n+  beforeEach(resetDb);\n+\n+  it('should add message to specified chat', async () => {\n+    mockAuth(1);\n+\n+    const { query, mutate } = createTestClient(server);\n+\n+    const addMessageRes = await mutate({\n+      variables: { chatId: '1', content: 'Hello World' },\n+      mutation: gql`\n+        mutation AddMessage($chatId: ID!, $content: String!) {\n+          addMessage(chatId: $chatId, content: $content) {\n+            id\n+            content\n+          }\n+        }\n+      `,\n+    });\n+\n+    expect(addMessageRes.data).toBeDefined();\n+    expect(addMessageRes.errors).toBeUndefined();\n+    expect(addMessageRes.data).toMatchSnapshot();\n+\n+    const getChatRes = await query({\n+      variables: { chatId: '1' },\n+      query: gql`\n+        query GetChat($chatId: ID!) {\n+          chat(chatId: $chatId) {\n+            id\n+            lastMessage {\n+              id\n+              content\n+            }\n+          }\n+        }\n+      `,\n+    });\n+\n+    expect(getChatRes.data).toBeDefined();\n+    expect(getChatRes.errors).toBeUndefined();\n+    expect(getChatRes.data).toMatchSnapshot();\n+  });\n+});\ndiff --git a/tests/mutations/removeChat.test.ts b/tests/mutations/removeChat.test.ts\nnew file mode 100644\nindex 0000000..25425d4\n--- /dev/null\n+++ b/tests/mutations/removeChat.test.ts\n@@ -0,0 +1,47 @@\n+import { createTestClient } from 'apollo-server-testing';\n+import { gql } from 'apollo-server-express';\n+import { server } from '../../server';\n+import { resetDb } from '../../db';\n+import { mockAuth } from '../mocks/auth.provider';\n+\n+describe('Mutation.removeChat', () => {\n+  beforeEach(resetDb);\n+\n+  it('removes chat by id', async () => {\n+    mockAuth(1);\n+\n+    const { query, mutate } = createTestClient(server);\n+\n+    const addChatRes = await mutate({\n+      variables: { chatId: '1' },\n+      mutation: gql`\n+        mutation RemoveChat($chatId: ID!) {\n+          removeChat(chatId: $chatId)\n+        }\n+      `,\n+    });\n+\n+    expect(addChatRes.data).toBeDefined();\n+    expect(addChatRes.errors).toBeUndefined();\n+    expect(addChatRes.data!.removeChat).toEqual('1');\n+\n+    const getChatRes = await query({\n+      variables: { chatId: '1' },\n+      query: gql`\n+        query GetChat($chatId: ID!) {\n+          chat(chatId: $chatId) {\n+            id\n+            name\n+            participants {\n+              id\n+            }\n+          }\n+        }\n+      `,\n+    });\n+\n+    expect(addChatRes.data).toBeDefined();\n+    expect(getChatRes.errors).toBeUndefined();\n+    expect(addChatRes.data!.chat).toBeUndefined();\n+  });\n+});\ndiff --git a/tests/queries/__snapshots__/getChat.test.ts.snap b/tests/queries/__snapshots__/getChat.test.ts.snap\nnew file mode 100644\nindex 0000000..628b2cd\n--- /dev/null\n+++ b/tests/queries/__snapshots__/getChat.test.ts.snap\n@@ -0,0 +1,16 @@\n+// Jest Snapshot v1, https://goo.gl/fbAQLP\n+\n+exports[`Query.chat should fetch specified chat 1`] = `\n+Object {\n+  \"chat\": Object {\n+    \"id\": \"1\",\n+    \"lastMessage\": Object {\n+      \"content\": \"You on your way?\",\n+      \"createdAt\": \"2018-12-31T07:20:00.000Z\",\n+      \"id\": \"1\",\n+    },\n+    \"name\": \"Ethan Gonzalez\",\n+    \"picture\": \"https://randomuser.me/api/portraits/thumb/men/1.jpg\",\n+  },\n+}\n+`;\ndiff --git a/tests/queries/__snapshots__/getChats.test.ts.snap b/tests/queries/__snapshots__/getChats.test.ts.snap\nnew file mode 100644\nindex 0000000..951f50a\n--- /dev/null\n+++ b/tests/queries/__snapshots__/getChats.test.ts.snap\n@@ -0,0 +1,48 @@\n+// Jest Snapshot v1, https://goo.gl/fbAQLP\n+\n+exports[`Query.chats should fetch all chats 1`] = `\n+Object {\n+  \"chats\": Array [\n+    Object {\n+      \"id\": \"1\",\n+      \"lastMessage\": Object {\n+        \"content\": \"You on your way?\",\n+        \"createdAt\": \"2018-12-31T07:20:00.000Z\",\n+        \"id\": \"1\",\n+      },\n+      \"name\": \"Ethan Gonzalez\",\n+      \"picture\": \"https://randomuser.me/api/portraits/thumb/men/1.jpg\",\n+    },\n+    Object {\n+      \"id\": \"2\",\n+      \"lastMessage\": Object {\n+        \"content\": \"Hey, it's me\",\n+        \"createdAt\": \"2018-12-30T14:40:00.000Z\",\n+        \"id\": \"2\",\n+      },\n+      \"name\": \"Bryan Wallace\",\n+      \"picture\": \"https://randomuser.me/api/portraits/thumb/men/2.jpg\",\n+    },\n+    Object {\n+      \"id\": \"3\",\n+      \"lastMessage\": Object {\n+        \"content\": \"I should buy a boat\",\n+        \"createdAt\": \"2018-12-15T08:00:00.000Z\",\n+        \"id\": \"3\",\n+      },\n+      \"name\": \"Avery Stewart\",\n+      \"picture\": \"https://randomuser.me/api/portraits/thumb/women/1.jpg\",\n+    },\n+    Object {\n+      \"id\": \"4\",\n+      \"lastMessage\": Object {\n+        \"content\": \"This is wicked good ice cream.\",\n+        \"createdAt\": \"2018-05-12T16:00:00.000Z\",\n+        \"id\": \"4\",\n+      },\n+      \"name\": \"Katie Peterson\",\n+      \"picture\": \"https://randomuser.me/api/portraits/thumb/women/2.jpg\",\n+    },\n+  ],\n+}\n+`;\ndiff --git a/tests/queries/__snapshots__/getMe.test.ts.snap b/tests/queries/__snapshots__/getMe.test.ts.snap\nnew file mode 100644\nindex 0000000..8f5621e\n--- /dev/null\n+++ b/tests/queries/__snapshots__/getMe.test.ts.snap\n@@ -0,0 +1,11 @@\n+// Jest Snapshot v1, https://goo.gl/fbAQLP\n+\n+exports[`Query.me should fetch current user 1`] = `\n+Object {\n+  \"me\": Object {\n+    \"id\": \"1\",\n+    \"name\": \"Ray Edwards\",\n+    \"picture\": \"https://randomuser.me/api/portraits/thumb/lego/1.jpg\",\n+  },\n+}\n+`;\ndiff --git a/tests/queries/__snapshots__/getUsers.test.ts.snap b/tests/queries/__snapshots__/getUsers.test.ts.snap\nnew file mode 100644\nindex 0000000..a2fd9bd\n--- /dev/null\n+++ b/tests/queries/__snapshots__/getUsers.test.ts.snap\n@@ -0,0 +1,55 @@\n+// Jest Snapshot v1, https://goo.gl/fbAQLP\n+\n+exports[`Query.getUsers should fetch all users except the one signed-in 1`] = `\n+Object {\n+  \"users\": Array [\n+    Object {\n+      \"id\": \"2\",\n+      \"name\": \"Ethan Gonzalez\",\n+      \"picture\": \"https://randomuser.me/api/portraits/thumb/men/1.jpg\",\n+    },\n+    Object {\n+      \"id\": \"3\",\n+      \"name\": \"Bryan Wallace\",\n+      \"picture\": \"https://randomuser.me/api/portraits/thumb/men/2.jpg\",\n+    },\n+    Object {\n+      \"id\": \"4\",\n+      \"name\": \"Avery Stewart\",\n+      \"picture\": \"https://randomuser.me/api/portraits/thumb/women/1.jpg\",\n+    },\n+    Object {\n+      \"id\": \"5\",\n+      \"name\": \"Katie Peterson\",\n+      \"picture\": \"https://randomuser.me/api/portraits/thumb/women/2.jpg\",\n+    },\n+  ],\n+}\n+`;\n+\n+exports[`Query.getUsers should fetch all users except the one signed-in 2`] = `\n+Object {\n+  \"users\": Array [\n+    Object {\n+      \"id\": \"1\",\n+      \"name\": \"Ray Edwards\",\n+      \"picture\": \"https://randomuser.me/api/portraits/thumb/lego/1.jpg\",\n+    },\n+    Object {\n+      \"id\": \"3\",\n+      \"name\": \"Bryan Wallace\",\n+      \"picture\": \"https://randomuser.me/api/portraits/thumb/men/2.jpg\",\n+    },\n+    Object {\n+      \"id\": \"4\",\n+      \"name\": \"Avery Stewart\",\n+      \"picture\": \"https://randomuser.me/api/portraits/thumb/women/1.jpg\",\n+    },\n+    Object {\n+      \"id\": \"5\",\n+      \"name\": \"Katie Peterson\",\n+      \"picture\": \"https://randomuser.me/api/portraits/thumb/women/2.jpg\",\n+    },\n+  ],\n+}\n+`;\ndiff --git a/tests/queries/getChat.test.ts b/tests/queries/getChat.test.ts\nnew file mode 100644\nindex 0000000..db5ad8a\n--- /dev/null\n+++ b/tests/queries/getChat.test.ts\n@@ -0,0 +1,37 @@\n+import { createTestClient } from 'apollo-server-testing';\n+import { gql } from 'apollo-server-express';\n+import { server } from '../../server';\n+import { resetDb } from '../../db';\n+import { mockAuth } from '../mocks/auth.provider';\n+\n+describe('Query.chat', () => {\n+  beforeEach(resetDb);\n+\n+  it('should fetch specified chat', async () => {\n+    mockAuth(1);\n+\n+    const { query } = createTestClient(server);\n+\n+    const res = await query({\n+      variables: { chatId: '1' },\n+      query: gql`\n+        query GetChat($chatId: ID!) {\n+          chat(chatId: $chatId) {\n+            id\n+            name\n+            picture\n+            lastMessage {\n+              id\n+              content\n+              createdAt\n+            }\n+          }\n+        }\n+      `,\n+    });\n+\n+    expect(res.data).toBeDefined();\n+    expect(res.errors).toBeUndefined();\n+    expect(res.data).toMatchSnapshot();\n+  });\n+});\ndiff --git a/tests/queries/getChats.test.ts b/tests/queries/getChats.test.ts\nnew file mode 100644\nindex 0000000..f416ee7\n--- /dev/null\n+++ b/tests/queries/getChats.test.ts\n@@ -0,0 +1,36 @@\n+import { createTestClient } from 'apollo-server-testing';\n+import { gql } from 'apollo-server-express';\n+import { server } from '../../server';\n+import { resetDb } from '../../db';\n+import { mockAuth } from '../mocks/auth.provider';\n+\n+describe('Query.chats', () => {\n+  beforeEach(resetDb);\n+\n+  it('should fetch all chats', async () => {\n+    mockAuth(1);\n+\n+    const { query } = createTestClient(server);\n+\n+    const res = await query({\n+      query: gql`\n+        query GetChats {\n+          chats {\n+            id\n+            name\n+            picture\n+            lastMessage {\n+              id\n+              content\n+              createdAt\n+            }\n+          }\n+        }\n+      `,\n+    });\n+\n+    expect(res.data).toBeDefined();\n+    expect(res.errors).toBeUndefined();\n+    expect(res.data).toMatchSnapshot();\n+  });\n+});\ndiff --git a/tests/queries/getMe.test.ts b/tests/queries/getMe.test.ts\nnew file mode 100644\nindex 0000000..6a74b42\n--- /dev/null\n+++ b/tests/queries/getMe.test.ts\n@@ -0,0 +1,31 @@\n+import { createTestClient } from 'apollo-server-testing';\n+import { gql } from 'apollo-server-express';\n+import { server } from '../../server';\n+import { resetDb } from '../../db';\n+import { mockAuth } from '../mocks/auth.provider';\n+\n+describe('Query.me', () => {\n+  beforeEach(resetDb);\n+\n+  it('should fetch current user', async () => {\n+    mockAuth(1);\n+\n+    const { query } = createTestClient(server);\n+\n+    const res = await query({\n+      query: gql`\n+        query GetMe {\n+          me {\n+            id\n+            name\n+            picture\n+          }\n+        }\n+      `,\n+    });\n+\n+    expect(res.data).toBeDefined();\n+    expect(res.errors).toBeUndefined();\n+    expect(res.data).toMatchSnapshot();\n+  });\n+});\ndiff --git a/tests/queries/getUsers.test.ts b/tests/queries/getUsers.test.ts\nnew file mode 100644\nindex 0000000..7e26598\n--- /dev/null\n+++ b/tests/queries/getUsers.test.ts\n@@ -0,0 +1,49 @@\n+import { createTestClient } from 'apollo-server-testing';\n+import { gql } from 'apollo-server-express';\n+import { server } from '../../server';\n+import { resetDb } from '../../db';\n+import { mockAuth } from '../mocks/auth.provider';\n+\n+describe('Query.getUsers', () => {\n+  beforeEach(resetDb);\n+\n+  it('should fetch all users except the one signed-in', async () => {\n+    mockAuth(1);\n+\n+    const { query } = createTestClient(server);\n+\n+    let res = await query({\n+      query: gql`\n+        query GetUsers {\n+          users {\n+            id\n+            name\n+            picture\n+          }\n+        }\n+      `,\n+    });\n+\n+    expect(res.data).toBeDefined();\n+    expect(res.errors).toBeUndefined();\n+    expect(res.data).toMatchSnapshot();\n+\n+    mockAuth(2);\n+\n+    res = await query({\n+      query: gql`\n+        query GetUsers {\n+          users {\n+            id\n+            name\n+            picture\n+          }\n+        }\n+      `,\n+    });\n+\n+    expect(res.data).toBeDefined();\n+    expect(res.errors).toBeUndefined();\n+    expect(res.data).toMatchSnapshot();\n+  });\n+});\ndiff --git a/tsconfig.json b/tsconfig.json\nnew file mode 100644\nindex 0000000..d9d5ac7\n--- /dev/null\n+++ b/tsconfig.json\n@@ -0,0 +1,21 @@\n+{\n+  \"compilerOptions\": {\n+    \"outDir\": \"dist\",\n+    \"target\": \"es2018\",\n+    \"module\": \"commonjs\",\n+    \"lib\": [\n+      \"es2018\",\n+      \"esnext.asynciterable\"\n+    ],\n+    \"skipLibCheck\": true,\n+    \"strict\": true,\n+    \"strictFunctionTypes\": false,\n+    \"strictPropertyInitialization\": false,\n+    \"esModuleInterop\": true,\n+    \"experimentalDecorators\": true,\n+    \"emitDecoratorMetadata\": true\n+  },\n+  \"exclude\": [\n+    \"./tests/\"\n+  ]\n+}\ndiff --git a/types/apollo-server-testing.d.ts b/types/apollo-server-testing.d.ts\nnew file mode 100644\nindex 0000000..554c277\n--- /dev/null\n+++ b/types/apollo-server-testing.d.ts\n@@ -0,0 +1,27 @@\n+declare module 'apollo-server-testing' {\n+  import { ApolloServerBase } from 'apollo-server-core';\n+  import { print, DocumentNode } from 'graphql';\n+  import { GraphQLResponse } from 'graphql-extensions';\n+\n+  type StringOrAst = string | DocumentNode;\n+\n+  // A query must not come with a mutation (and vice versa).\n+  type Query<TVariables> = {\n+    query: StringOrAst;\n+    mutation?: undefined;\n+    variables?: TVariables;\n+  };\n+\n+  type Mutation<TVariables> = {\n+    mutation: StringOrAst;\n+    query?: undefined;\n+    variables?: TVariables;\n+  };\n+\n+  export const createTestClient: <TVariables>(\n+    server: ApolloServerBase\n+  ) => {\n+    query: (query: Query<TVariables>) => Promise<GraphQLResponse>;\n+    mutate: (mutation: Mutation<TVariables>) => Promise<GraphQLResponse>;\n+  };\n+}\ndiff --git a/validators.ts b/validators.ts\nnew file mode 100644\nindex 0000000..7559c52\n--- /dev/null\n+++ b/validators.ts\n@@ -0,0 +1,43 @@\n+export const validatePassword = (ctx: string, str: string) => {\n+  if (typeof str !== 'string') {\n+    throw TypeError(`${ctx} must be a string`);\n+  }\n+\n+  validateLength(ctx, str, 8, 30);\n+\n+  if (!/[a-zA-Z]+/.test(str)) {\n+    throw TypeError(`${ctx} must contain english letters`);\n+  }\n+\n+  if (!/\\d+/.test(str)) {\n+    throw TypeError(`${ctx} must contain numbers`);\n+  }\n+\n+  if (!/[^\\da-zA-Z]+/.test(str)) {\n+    throw TypeError(`${ctx} must contain special charachters`);\n+  }\n+};\n+\n+export const validateLength = (ctx: string, str: string, ...args: number[]) => {\n+  let min, max;\n+\n+  if (args.length === 1) {\n+    min = 0;\n+    max = args[0];\n+  } else {\n+    min = args[0];\n+    max = args[1];\n+  }\n+\n+  if (typeof str !== 'string') {\n+    throw TypeError(`${ctx} must be a string`);\n+  }\n+\n+  if (str.length < min) {\n+    throw TypeError(`${ctx} must be at least ${min} chars long`);\n+  }\n+\n+  if (str.length > max) {\n+    throw TypeError(`${ctx} must contain ${max} chars at most`);\n+  }\n+};\n",
        "manuals": [
          {
            "manualTitle": "Whatsapp Clone Server",
            "stepRevision": "a76e37175f6a988c205a8b807f02846087d5f143",
            "manualView": "A newly created Tortilla project. For more information, see https://github.com/Urigo/tortilla."
          },
          {
            "manualTitle": "Step 1: Setup a basic Node.JS server with a basic REST endpoint",
            "stepRevision": "e17ca0a3ed60873b73060dec0b5df005035db7ca",
            "manualView": ""
          },
          {
            "manualTitle": "Step 2: Transition to GraphQL",
            "stepRevision": "995d4420963642a66cf3be5f3dd4d44f4b883b81",
            "manualView": ""
          },
          {
            "manualTitle": "Step 3: Testing",
            "stepRevision": "06317d99f93e2abb79cf44822030f51f504683bb",
            "manualView": ""
          },
          {
            "manualTitle": "Step 4: Creating an app router and implementing a chat room",
            "stepRevision": "bad038802307c8c1cfb7db472bd56bfd3d69f0da",
            "manualView": ""
          },
          {
            "manualTitle": "Step 5: Sending messages with GraphQL mutations",
            "stepRevision": "751cd3e004bdba12dc749cc652f37cd14f2ac6e2",
            "manualView": ""
          },
          {
            "manualTitle": "Step 6: Type safety with GraphQL Code Generator",
            "stepRevision": "067045e44c412114cd24f098dba2d78c6490ae7f",
            "manualView": ""
          },
          {
            "manualTitle": "Step 7: Live updates with GraphQL subscriptions",
            "stepRevision": "5c7d6f4ea853ecfb04ed395940ea5639d26469f6",
            "manualView": ""
          },
          {
            "manualTitle": "Step 8: Users",
            "stepRevision": "a5ba800ad73f5fcf15281d4770a823b3710bbc78",
            "manualView": ""
          },
          {
            "manualTitle": "Step 9: Adding and removing chats",
            "stepRevision": "663371b98d36ee01d7679b3571f644f8c93d988c",
            "manualView": ""
          },
          {
            "manualTitle": "Step 10: Authentication",
            "stepRevision": "928d87bb80062b94229d3d97520049b50fca5837",
            "manualView": ""
          },
          {
            "manualTitle": "Step 11: Migrating to PostgreSQL instead of in-memory DB",
            "stepRevision": "77001b5e6a1359e82da4c620c50e5d0185b03723",
            "manualView": ""
          },
          {
            "manualTitle": "Step 12: Using a REST API",
            "stepRevision": "abcd0bd419047b5ff8a20d838787e3651670ac4a",
            "manualView": ""
          },
          {
            "manualTitle": "Step 13: Modularizing Schema",
            "stepRevision": "e1e408b07fa19c279a64a2f78a8049ecae46d678",
            "manualView": ""
          },
          {
            "manualTitle": "Step 14: Performance",
            "stepRevision": "2f32e950300b74fe7e1aab7f51e9ce84ff4fc86c",
            "manualView": ""
          }
        ]
      }
    ]
  }
]
