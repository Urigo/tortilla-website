[
  {
    "repoUrl": "https://github.com/Urigo/WhatsApp-Clone-Tutorial",
    "branchName": "master",
    "historyBranchName": "master-history",
    "releases": [
      {
        "releaseVersion": "next",
        "releaseDate": "2019-06-17 22:44:17 +0800",
        "tagName": "master@next",
        "tagRevision": "48028b7318df764ec20010459d7608eb5fdc049f",
        "historyRevision": "a7c325f8ecbf9006d590951fd4d3cfb5bb247ed5",
        "changesDiff": "diff --git a/.tortilla/manuals/templates/step1.tmpl b/.tortilla/manuals/templates/step1.tmpl\nindex 380cc0d..640d3ab 100644\n--- a/.tortilla/manuals/templates/step1.tmpl\n+++ b/.tortilla/manuals/templates/step1.tmpl\n@@ -196,6 +196,26 @@ Here is a nice guide to start: https://try.github.io/.\n You can check out the `.gitignore` file create-react-app has set up for us in the root folder.\n That file will tell `.git` what not to save and not to upload.\n\n+## Code formatting\n+\n+Some developers write code in a different style than others and it might be annoying while doing code reviews or even merging conflicts. That's why we want to make it consistent. We're going to use **Prettier** which has an opinionated set of styling rules and supports many languages. Your IDE most likely supports it too.\n+\n+    $ yarn add prettier\n+\n+We're going to define a npm script called `format`, few styling rules and we're also going to ignore *node_modules*:\n+\n+{{{ diffStep \"1.3\" module=\"client\" files=\"package.json, .prettierrc.yml, .prettierignore\" }}}\n+\n+Now let's run:\n+\n+    $ yarn format\n+\n+Prettier should format your code:\n+\n+{{{ diffStep \"1.3\" module=\"client\" files=\"src/App.tsx\" }}}\n+\n+> Remember to run `yarn prettier` before you comit your changes!\n+\n **End of intro**\n\n Assuming that everything is set, we will now create our first screen - `ChatsListScreen`.\n@@ -220,7 +240,7 @@ Add this data will be changed and we are not going to manually add HTML tags eve\n For now it would be a structure we will manually create.\n That way we can make our React component already behave like our final version.\n\n-{{{ diffStep \"1.3\" module=\"client\" files=\"App.tsx\" }}}\n+{{{ diffStep \"1.4\" module=\"client\" files=\"App.tsx\" }}}\n\n If all we do in the function is just returning a value, instead of `const App: React.FC = () => { return () };` we can also do `const App: React.FC = () => ();`\n So let's use that for our ChatsList component.\n@@ -233,15 +253,15 @@ As we don't use those styles and logos anymore, we can delete the `src/App.css`\n\n Now let's move ChatsList into it's own component:\n\n-{{{ diffStep \"1.4\" module=\"client\" files=\"ChatsList.tsx\" }}}\n+{{{ diffStep \"1.5\" module=\"client\" files=\"ChatsList.tsx\" }}}\n\n and let's import that component into the App component and use the shorter syntax for the functional component:\n\n-{{{ diffStep \"1.4\" module=\"client\" files=\"App.tsx\" }}}\n+{{{ diffStep \"1.5\" module=\"client\" files=\"App.tsx\" }}}\n\n and let's do the same for our Navbar:\n\n-{{{ diffStep \"1.5\" module=\"client\" }}}\n+{{{ diffStep \"1.6\" module=\"client\" }}}\n\n React apps tend to store React.Components under a directory located at `src/components`, and so we're gonna follow this pattern.\n We will create a directory called ChatsListScreen in the `components` dir where we're simply gonna import and put together the Navbar and ChatsList components.\n@@ -254,7 +274,7 @@ This is how the contents of that directory should look like:\n\n We will use the `index.tsx` file to define that component, this way we can import it using the directory name:\n\n-{{{ diffStep \"1.6\" module=\"client\" }}}\n+{{{ diffStep \"1.7\" module=\"client\" }}}\n\n Now, we have our app rendering our view, but it is completely static and manual in the code.\n\n@@ -265,7 +285,7 @@ So let's create a file that lists just the data of our chats and then make our R\n\n We will create the file in a JSON format:\n\n-{{{ diffStep \"1.7\" module=\"client\" files=\"db.ts\" }}}\n+{{{ diffStep \"1.8\" module=\"client\" files=\"db.ts\" }}}\n\n We are giving IDs for the values just like a database gives a unique id for each value.\n\n@@ -276,7 +296,7 @@ Now let's change ChatsList component to import the data from that file.\n Then to use the Javascript [map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)\n function to render a line for each data entry:\n\n-{{{ diffStep \"1.7\" module=\"client\" files=\"ChatsList.tsx\" }}}\n+{{{ diffStep \"1.8\" module=\"client\" files=\"ChatsList.tsx\" }}}\n\n When running `map` on the `chats` array, it will run a function for each entry in the array and return a value.\n The function will receive the current entry as a parameter.\n@@ -291,7 +311,7 @@ Read [here](https://reactjs.org/docs/lists-and-keys.html) for more in depth expl\n\n Now that we rendered a line for each chat, let's add also the last message's content and creation date for each chat:\n\n-{{{ diffStep \"1.8\" module=\"client\" }}}\n+{{{ diffStep \"1.9\" module=\"client\" }}}\n\n Try to run the app again.\n\n@@ -300,7 +320,7 @@ This is because Typescript is smart enough and tells us there might be no last m\n So we add a check.\n Remember to always check for null or undefined if optional, don’t write shorter write safer:\n\n-{{{ diffStep \"1.9\" module=\"client\" }}}\n+{{{ diffStep \"1.10\" module=\"client\" }}}\n\n Now let's try again.\n\n@@ -308,7 +328,7 @@ Now we have a syntax error - A JSX return value can't have more then a single ro\n So in order to return a root element from the function but still display multiple elements in the same level,\n we can use [React.Fragment](https://reactjs.org/docs/fragments.html) to wrap the returned elements:\n\n-{{{ diffStep \"1.10\" module=\"client\" }}}\n+{{{ diffStep \"1.11\" module=\"client\" }}}\n\n\n Let's try again.  This time it looks like the format is not correct, so let's format the date using the `moment` library.\n@@ -323,7 +343,7 @@ To install:\n\n And now let's import the library by it's name, wrap the value of each chat and call the `format` function with our requested format:\n\n-{{{ diffStep \"1.11\" module=\"client\" files=\"ChatsList.tsx\" }}}\n+{{{ diffStep \"1.12\" module=\"client\" files=\"ChatsList.tsx\" }}}\n\n\n If you'll try to run the app you'll see that everything is there, but it's not hard to notice that it's missing some style:\ndiff --git a/.tortilla/manuals/templates/step11.tmpl b/.tortilla/manuals/templates/step11.tmpl\nindex 6c58875..6f2b6a5 100644\n--- a/.tortilla/manuals/templates/step11.tmpl\n+++ b/.tortilla/manuals/templates/step11.tmpl\n@@ -126,12 +126,11 @@ We will use this function to wrap the right components in our app’s router. No\n\n Assuming that you’re not logged-in, if you’ll try to force navigate to the `/chats` route you should be automatically redirected to the `/sign-in` form. We will finish the chapter here as we wanna keep things simple and gradual. It’s true that we haven’t implemented true authentication, but that would be addressed soon further in this tutorial.\n\n----------\n-\n-TODO: minor change, which might be helpful for people in long term. That’s a small but powerful thing to know about in TypeScript\n-+ recipient: chat.participants.find(p => p !== currentUser.id)!\n-- recipient: chat.participants.find(p => p !== currentUser.id) as string\n-\n-\n-TODO: I don’t think we need `if (props.history.location.pathname === '/sign-in') return null`\n-since withAuth HOC is not used on `AuthScreen` component\n\\ No newline at end of file\n+{{#noop}}\n+  TODO: minor change, which might be helpful for people in long term. That’s a small but powerful thing to know about in TypeScript\n+  + recipient: chat.participants.find(p => p !== currentUser.id)!\n+  - recipient: chat.participants.find(p => p !== currentUser.id) as string\n+\n+  TODO: I don’t think we need `if (props.history.location.pathname === '/sign-in') return null`\n+  since withAuth HOC is not used on `AuthScreen` component\n+{{/noop}}\ndiff --git a/.tortilla/manuals/templates/step13.tmpl b/.tortilla/manuals/templates/step13.tmpl\nindex 803b11c..4609db1 100644\n--- a/.tortilla/manuals/templates/step13.tmpl\n+++ b/.tortilla/manuals/templates/step13.tmpl\n@@ -61,15 +61,23 @@ mutation signIn(username: 'ray', password: '111') {\n\n Now if we would look at the value of `document.cookie` we should see a key named `authToken` with a JWT token and the `ChatsListScreen` should show the chats which are relevant to `ray`. To complete the sign-in flow we would need to update the `AuthScreen` and the `auth.service` to use username and password and the actual `sign-in` mutation we’ve just implemented.\n\n-To check if we’re authorized to visit a route, not only we would need to check if we have the `authToken` cookie defined, but we would also need to validate it against the server to see that it actually references a real user. For that we will implement `Query.me` which will send us back the current user logged in directly from the context:\n+Now back to the `auth.service`, we will replace the `signIn()` method implementation with one that actually calls the `signIn` mutation in our API. We will start by defining the mutation:\n\n-{{{ diffStep 10.5 module=\"server\" }}}\n+{{{ diffStep 13.2 module=\"client\" files=\"graphql/mutations\" }}}\n+\n+Updating `codegen.yml` to include the file we've just added in the generation process:\n\n-Now back to the `auth.service`, we will replace the `signIn()` method implementation with one that actually calls the `signIn` mutation in our API:\n+{{{ diffStep 13.2 module=\"client\" files=\"codegen.yml\" }}}\n\n-{{{ diffStep 13.2 module=\"client\" }}}\n+And finally, we will update the service to use the generated mutation method `useSignInMutation()`:\n\n-And we will use the GraphQL query we’ve just implemented to check if the user actually exists within the DB before we proceed to the restricted route:\n+{{{ diffStep 13.2 module=\"client\" files=\"auth.service.ts\" }}}\n+\n+To check if we’re authorized to visit a route, not only we would need to check if we have the `authToken` cookie defined, but we would also need to validate it against the server to see that it actually references a real user. For that we will implement `Query.me` which will send us back the current user logged in directly from the context:\n+\n+{{{ diffStep 10.5 module=\"server\" }}}\n+\n+Now will use the GraphQL query we’ve just implemented to check if the user actually exists within the DB before we proceed to the restricted route:\n\n {{{ diffStep 13.3 module=\"client\" }}}\n\n@@ -109,10 +117,10 @@ And then we will make the necessary changes in the `AuthScreen`:\n\n The authentication flow is complete! To test it out, you can create a new user, log in with it and start chatting with other users.\n\n-------------\n-\n-TODO: maybe use HttpOnly in cookie\n-save user’s id or data in localStorage so we can guess if a user is logged in or not and later on invalidate it\n-we send a password in its raw form over the wire\n-Error message: “req.password and req.passwordConfirm don't match” looks odd, should be “Passwords don’t match”\n-Why is `const maySignUp = useCallback(() => {` a useCallback and not useMemo for example? We do use a value there.\n+{{#noop}}\n+  TODO: maybe use HttpOnly in cookie\n+  save user’s id or data in localStorage so we can guess if a user is logged in or not and later on invalidate it\n+  we send a password in its raw form over the wire\n+  Error message: “req.password and req.passwordConfirm don't match” looks odd, should be “Passwords don’t match”\n+  Why is `const maySignUp = useCallback(() => {` a useCallback and not useMemo for example? We do use a value there.\n+{{/noop}}\ndiff --git a/.tortilla/manuals/templates/step14.tmpl b/.tortilla/manuals/templates/step14.tmpl\nindex 8541c20..8dc3caa 100644\n--- a/.tortilla/manuals/templates/step14.tmpl\n+++ b/.tortilla/manuals/templates/step14.tmpl\n@@ -42,29 +42,41 @@ You can read more about those relations in [here](https://www.techrepublic.com/a\n In existing entity declarations and schema, we have 6 relationships;\n\n * Message has a One To Many relationship under the name of `chat` inside our schema; so one message can have one chat while one chat can have multiple messages.\n-    gql```\n-    type Message { chat: Chat }\n-    ```\n+\n+```gql\n+type Message { chat: Chat }\n+```\n+\n * Message has another One To Many relationship under the name of `sender`` inside our schema; so one message can have one sender while one sender user can have multiple messages.\n-    gql```\n-    type Message { sender: User }\n-    ```\n+\n+```gql\n+type Message { sender: User }\n+```\n+\n * Message has one more One To Many relationship under the name of `recipient`` inside our schema; so one message can have one recipient while one recipient user can have multiple messages.\n-    gql```\n-    type Message { recipient: User }\n-    ```\n+\n+```gql\n+type Message { recipient: User }\n+```\n+\n * Chat has a One To Many relationship under the name of `messages`, because one chat can have multiple messages while one message can have only one chat. Notice that this relationship is the reversed version of the first relationship in Message.\n-    gql```\n-    `type Chat { messages: [Message] }\n-    ```\n+\n+```gql\n+`type Chat { messages: [Message] }\n+```\n+\n * Chat has another Many To Many relationship under the name of `participants`, because one chat can have multiple participants while a participant can have multiple chats as well.\n-    gql```\n-    type Chat { participants: [User] }\n-    ```\n+\n+```gql\n+type Chat { participants: [User] }\n+```\n+\n * User has a Many To Many relationship under the name of `chats`, because one user can have multiple chats, while it has the same situation for chats.\n-    gql```\n-    type User { chats: [Chat] }\n-    ```\n+\n+```gql\n+type User { chats: [Chat] }\n+```\n+\n\n So we should decide the dependencies between each other to add columns and tables to our database.\n\ndiff --git a/.tortilla/manuals/templates/step15.tmpl b/.tortilla/manuals/templates/step15.tmpl\nindex 7ab1c4a..48266ef 100644\n--- a/.tortilla/manuals/templates/step15.tmpl\n+++ b/.tortilla/manuals/templates/step15.tmpl\n@@ -23,11 +23,11 @@ Copy the response, create a new file called types/unsplash.ts in your vscode edi\n\n Now we can finally implement the REST API call in our picture resolver:\n\n-{{{ diffStep \"12.1\" module=\"client\" files=\"schema/resolvers.ts\" }}}\n+{{{ diffStep \"12.1\" module=\"server\" files=\"schema/resolvers.ts\" }}}\n\n In order to test it, we have to remove the picture from one of the users and re-run the server with the `RESET_DB=true` environment variable:\n\n-{{{ diffStep \"12.1\" module=\"client\" files=\"db.ts\" }}}\n+{{{ diffStep \"12.1\" module=\"server\" files=\"db.ts\" }}}\n\n\n ## Track the API\n@@ -40,7 +40,7 @@ First let’s install the safe-api middleware:\n\n Then let’s use it inside our resolver:\n\n-{{{ diffStep \"12.2\" module=\"client\" files=\"schema/resolvers.ts\" }}}\n+{{{ diffStep \"12.2\" module=\"server\" files=\"schema/resolvers.ts\" }}}\n\n Now launch the client in order to retrieve the picture field multiple times.\n\n@@ -48,7 +48,7 @@ If you look inside the logs directory you will notice that it generated some gra\n\n Now we need to remove `types/unsplash.ts` and generate some Typescript typings out of the schema. Do do so we can use the graphql-code-generator:\n\n-{{{ diffStep \"12.3\" module=\"client\" files=\".gitignore, codegen.yml\" }}}\n+{{{ diffStep \"12.3\" module=\"server\" files=\".gitignore, codegen.yml\" }}}\n\n     yarn codegen\n\n@@ -60,20 +60,20 @@ We’re not done yet, there is still room for improvement. Instead of using axio\n     yarn remove axios @types/axios\n     yarn add apollo-datasource-rest\n\n-{{{ diffStep \"12.4\" module=\"client\" files=\"schema/unsplash.api.ts\" }}}\n+{{{ diffStep \"12.4\" module=\"server\" files=\"schema/unsplash.api.ts\" }}}\n\n We created the UnsplashApi class, which extends RESTDataSource. In the constructor you need to set the baseUrl (after calling super() to run the constructor of the base class). You also need to create a willSendRequest method to set the authentication headers for each call. Then it’s simply a matter of creating a getRandomPhoto method to perform the actual REST API call. Instead of calling axios you will have to call the get method of the class (which in turn gets inherited from its RESTDataSource base class): the API is very similar to the axios one.\n\n In order to access the data source from the resolvers we need to tell Apollo to put them on the context for every request. We shouldn’t use the context field, because that would lead to circular dependencies. Instead we need to use the dataSources field:\n\n-{{{ diffStep \"12.4\" module=\"client\" files=\"index.ts\" }}}\n+{{{ diffStep \"12.4\" module=\"server\" files=\"index.ts\" }}}\n\n Now we need to update the typings for our context and run the graphq-code-generator again:\n\n-{{{ diffStep \"12.4\" module=\"client\" files=\"context.ts\" }}}\n+{{{ diffStep \"12.4\" module=\"server\" files=\"context.ts\" }}}\n\n     yarn codegen\n\n Now it should be pretty easy to modify our resolver in order to use our just created datasource:\n\n-{{{ diffStep \"12.4\" module=\"client\" files=\"schema/resolvers.ts\" }}}\n+{{{ diffStep \"12.4\" module=\"server\" files=\"schema/resolvers.ts\" }}}\ndiff --git a/.tortilla/manuals/templates/step16.tmpl b/.tortilla/manuals/templates/step16.tmpl\nnew file mode 100644\nindex 0000000..a9913c6\n--- /dev/null\n+++ b/.tortilla/manuals/templates/step16.tmpl\n@@ -0,0 +1,374 @@\n+This chapter is focused entirely on how to organize a GraphQL API. By far, our project's schema looks simple and keeping SDL and resolvers in two files is really enough.\n+\n+## Issues we face when GraphQL API grows\n+\n+Usually, every app starts small and the difficulty of maintenance grows while features are being implemented. I believe that you should always start small and see how a project involves. You could look up many articles about best practices of organising a project but they bring no benefit when your project is small. You don't want to jump between files in order to find what you're looking for, it should be intuitive. I agree a proper folder structure helps but if your schema has 100 lines of code then it makes no sense to split it into 5 files with 20 LOC each. The schema is so small that it won't hurt you when you hit the wall and separation will be necessary but until it happens you can easily move on with the project.\n+\n+Bigger project means more people, more people means teams. In the current state of the app, they might interrupt each other and that eventually affects productivity.\n+Lack of separation makes the schema harder to maintain, especially once it grows rapidly.\n+\n+## That's why modularity is a thing!\n+\n+In order to improve and solve those issues we would have to split an API into many pieces.\n+Those might be files, even folders, doesn't really matter because the goal is to keep relevant chunks of code in one place, conceptually called module.\n+\n+If done right, one team won't disturb another and it also helps to understand an entire codebase just by looking at those modules or even learn a feature because everything related to it is within a single module.\n+\n+There's also a very important aspect, reusability. Most APIs have something in common, the first thing that comes to mind is authentication and user mechanism in general.\n+When working with modules, it gets easier to share those.\n+\n+## Many ways to organize an API\n+\n+GraphQL specification explains just the language and how to form an API. Managing codebase, that's on our side.\n+\n+Since we're talking about modularity, let's see possible implementations.\n+\n+The first thing on mind are files and folders. Putting relevant logic in a file won't scale well once we add more things, like business logic for example. Which means we need folders, that's for sure.\n+\n+Okay, so the next question, how to store SDL and resolvers. Do we want to have them stored together or keep them separated?\n+\n+I'm a big fan of the former because in schema-first approach the SDL is written first and you see exactly how to construct resolvers. The latter would require to jump between files or have them opened side-by-side.\n+Another benefit shows up when you add, remove or just change part of a schema, less likely that you'll miss something.\n+\n+But as always, there are things you can't do with that approach.\n+One that pops into my head right away is an IDE support… ?\n+< guys, any ideas? >\n+\n+Let's talk about modularity in terms of SDL.\n+We know how to define types in GraphQL but what if a type is a sum of many features?\n+There two ways to do it. One is to use the `extend` keyword, another to define a type multiple type. Both gave the same effect, all is merged into one type after all.\n+\n+But there are few major differences.\n+\n+The `extend` keyword is obviously a part of the specification so IDEs and most tools support it. It feels more natural than the second option.\n+\n+Defining the same type multiple times is the opposite. It might feel odd, not many IDEs and\n+tools support it so you have to add a library that handles it but on the other way you don't care if there's already a type or not, you just make sure there's one with proper fields, no matter what. It might also warn you when fields overlap.\n+\n+## Modularized schema\n+\n+There are couple solutions to help you modularize the schema and we will look at 3 of them.\n+\n+First, let's start by defining 3 modules:\n+\n+- common - things we want to share with all the rest\n+- users - everything related to users\n+- chats - core logic of WhatsApp\n+\n+### Using directories\n+\n+The simplest and most obvious solution would be to split what we have and move that into directories.\n+\n+Starting with common module. We need to create a folder at `/modules/common` and a `index.ts` file in it:\n+\n+{{{ diffStep \"13.1\" module=\"server\" files=\"modules/common/index.ts\" }}}\n+\n+You can see a pattern here, two things are being exported, one with type definitions and the other with resolvers. Why those `_dummy` fields? We want to use `extend` keyword, that require a base type and GraphQL doesn't accept empty objects.\n+\n+Now, let's do the same but with Users module:\n+\n+{{{ diffStep \"13.1\" module=\"server\" files=\"modules/users/index.ts\" }}}\n+\n+And Chats module:\n+\n+{{{ diffStep \"13.1\" module=\"server\" files=\"modules/chats/index.ts\" }}}\n+\n+Seems like modules are ready but we still need to create a Schema out of them.\n+\n+{{{ diffStep \"13.1\" module=\"server\" files=\"schema/index.ts\" }}}\n+\n+Because we moved everything from `resolvers.ts` and `typeDefs.graphql` files, those can now be removed.\n+\n+The last thing we need to adjust is the GraphQL Code Generator's config, in `codegen.yml`:\n+\n+{{{ diffStep \"13.1\" module=\"server\" files=\"codegen.yml\" }}}\n+\n+We no longer keep all type definitions in one place and all documents are wrapped with `gql` tag, the codegen is smart enough to find those.\n+\n+### Using Apollo Modules\n+\n+An alternative to the previous solution and far more interesting is a module feature of Apollo Server.\n+\n+Let's see how it all might look like when using Apollo Server's modules:\n+\n+{{{ diffStep \"13.2\" module=\"server\" files=\"index.ts\" }}}\n+\n+The `modules` of ApolloServer accepts an array of objects with `resolvers` and `typeDefs` properties. That's exactly what we exported and that's why we can use esmodules directly.\n+\n+Because we no longer use `schema.ts`, let's remove it.\n+\n+If you would run the server right now, you will see a lot of warnings about missing index signatures. It's definitely nothing to worry about and can be easily fixed by using `useIndexSignature` flag of codegen:\n+\n+{{{ diffStep \"13.2\" module=\"server\" files=\"codegen.yml\" }}}\n+\n+You might ask how is that different from what we have already implemented. The code is a bit simpler because the merging part is done by Apollo Server. We get some helpful messages when type's definition is missing but one of the modules was extending it and also when there are duplicates. Apollo Modules are very straightforward and basic but maybe that's all you really need in a project.\n+\n+### Using GraphQL Modules\n+\n+There's an another alternative option that forces good patterns and providess a nice to work with API. It's called GraphQL Modules.\n+The main goal is to help organize an API and allow to develop it across multiple teams.\n+\n+yarn add @graphql-modules/core\n+\n+Same as Apollo Server's modules, has useful warnings and messages but you can use it with any implementation of GraphQL server.\n+\n+```ts\n+import { GraphQLModule } from ‘@graphql-modules/core';\n+\n+export default = new GraphQLModule({\n+  name: 'common',\n+  typeDefs,\n+  resolvers\n+});\n+```\n+\n+It's a bit similar to what we have in Apollo Modules but as you probably noticed, it's wrapped within `GraphQLModule` class. The class manages a business logic, SDL, resolvers and dependencies between modules.\n+\n+> An important thing to be aware of, GraphQL Modules encapsulates every module. To get a better understanding, think of it as CSS Modules.\n+\n+Now that you know some basics, let's implement the simplest of all modules:\n+\n+{{{ diffStep \"13.3\" module=\"server\" files=\"modules/common/index.ts\" }}}\n+\n+As we mentioned, there's no global context so we moved the common parts into Common module.\n+\n+Let's take care of other two modules and migrate `modules/users/index.ts` first:\n+\n+{{{ diffStep \"13.3\" module=\"server\" files=\"modules/users/index.ts\" }}}\n+\n+Just like with Common, we also moved related context but there's a totally new thing called `imports`. In order to let Users module see Common's contents (types, resolvers, context etc) we need to include it in the dependencies.\n+\n+Now `Chats` that depends on `Users` and `Common` modules:\n+\n+{{{ diffStep \"13.3\" module=\"server\" files=\"modules/chats/index.ts\" }}}\n+\n+Since every module is now a GraphQL Module, we can take care of how to use them in the ApolloServer.\n+\n+To make things easier, we're going to create a module that's called `Root` and represents our API.\n+\n+```ts\n+export const rootModule = new GraphQLModule({\n+  name: 'root',\n+  imports: [usersModule, chatsModule],\n+});\n+```\n+\n+We want to pass `schema` and `context` to ApolloServer:\n+\n+```ts\n+const server = new ApolloServer({\n+  schema: rootModule.schema,\n+  context: rootModule.context,\n+  // ...\n+```\n+\n+Now with all that knowledge, take a look at all changes at once:\n+\n+{{{ diffStep \"13.3\" module=\"server\" files=\"index.ts\" }}}\n+\n+#### Migrate Unsplash API to Chats\n+\n+We still make use of global context which won't work with GraphQL Modules. To be more specific, it's not the context definition itself but the thing that's being added by ApolloServer, Data Sources.\n+\n+The `RESTDataSource` is of course more than a class but in case of Unsplash API we won't loose any important features except the HTTP client. We're going to use `axios` instead:\n+\n+yarn add axios\n+\n+We've got everything now so let's migrate UnsplashAPI class and move it from `schema/unsplash.api.ts` under `modules/chats`!\n+\n+{{{ diffStep \"13.3\" module=\"server\" files=\"modules/chats/unsplash.api.ts\" }}}\n+\n+There is no big differences between now and what we had before, the only thing that's changed is the way we make http requests.\n+\n+The `UnsplashAPI` can be now removed from `dataSources` and moved under Chats module's context:\n+\n+{{{ diffStep \"13.3\" module=\"server\" files=\"index.ts\" }}}\n+\n+{{{ diffStep \"13.3\" module=\"server\" files=\"context.ts\" }}}\n+\n+{{{ diffStep \"13.3\" module=\"server\" files=\"modules/chats/index.ts\" }}}\n+\n+#### Dependency Injection in GraphQL Modules\n+\n+The major feature of GraphQL Modules is the Dependency Injection. It's optional, you don't have to use it until it's really necessary. Even though WhatsApp clone doesn't need it yet, we're going to talk about DI and implement a simple thing, just for educational purpose.\n+\n+If you're familiar with Dependency Injection then you will get it straight away. If not, please read about it here or here (**links**).\n+\n+To start working with DI, we we need to install two packages:\n+\n+yarn add @graphql-modules/di reflect-metadata\n+\n+Let's now adjust the context type and import `reflect-metadata` into the project:\n+\n+{{{ diffStep \"13.5\" module=\"server\" files=\"context.ts\" }}}\n+\n+{{{ diffStep \"13.5\" module=\"server\" files=\"index.ts\" }}}\n+\n+In short, Iependency Injection will instantiate classes, manage dependencies between them and so on and in addition to that, the GraphQL Modules allows to define when each provider / class should be created. We call it scopes.\n+\n+- Application scope - provider is created when application starts (default)\n+- Session - providers are constructed in the beginning of the network request, then kept until the network request is closed\n+- Request - creates an instance each time you request it from the injector\n+\n+Because our `UnsplashApi` doesn't have to be recreated on every request, we can easily use Application scope, which is the default. The `Injectable` decorator is just to attach some metadata to the class.\n+\n+{{{ diffStep \"13.5\" module=\"server\" files=\"modules/chats/unsplash.api.ts\" }}}\n+\n+Here's how to register the UnsplashApi provider in Chats module:\n+\n+{{{ diffStep \"13.5\" module=\"server\" files=\"modules/chats/index.ts\" }}}\n+\n+Please also take a look at `injector.get(UnsplashApi)` part. There's `injector` instance in every module's context that allows to consume providers and everything that is defined within DI. You simply pass a class / token to the `get` method and GraphQL Modules takes care of the rest.\n+\n+**What are the benefits of DI?**\n+\n+You can have a different implementation of Users based on the same interface. Maybe right now you're using PostgreSQL but at some point a project will be migrated to MongoDB. You could do it through GraphQL context, of course but with Dependency Injection, GraphQL Modules is able to tell you exactly what's missing and where. It reduces boiler plate because instantiation is done by the injector, code is loosely coupled.\n+\n+Helps maintainability but also comes with few disadvantages. It's a bit complex concept to learn and what could be done on compile time (TypeScript) is moved to run-time.\n+\n+You might find DI useful while testing. Let's say you want to test a query that involves `UnsplashApi` provider, you simply replace it with a mocked version without touching the context or internals and you get the expected result every single time.\n+\n+We know there's only one provider by far, the `UnsplashApi`, but we're going to implement more and more in following steps.\n+\n+#### Continuing with DI\n+\n+We want to have everything easily accesible and DI helps with that so let's move on and continue migrating things.\n+\n+One of the shared objects is database connection and we're going to create a Database provider:\n+\n+{{{ diffStep \"13.6\" module=\"server\" files=\"modules/common/database.provider.ts\" }}}\n+\n+Things we did there:\n+- Session scope was used, which makes sure our provider is created and destroyed on every GraphQL Operation\n+- `onRequest` hook is called when a GraphQL Operation starts and we create a database connection in it.\n+- `onResponse` hook is triggered when GraphQL Response is about to be sent to the consumer, so we destroy the connection there.\n+- `getClient` method exposes the connection\n+- `Pool` in constructor means we expect `Pool` to be injected into `Database` provider.\n+\n+Now we can define `Pool` token and register `Database`:\n+\n+{{{ diffStep \"13.6\" module=\"server\" files=\"modules/common/index.ts\" }}}\n+\n+{{{ diffStep \"13.6\" module=\"server\" files=\"modules/index.ts\" }}}\n+\n+#### Creating Users and Chats services\n+\n+It's not really recommended to put logic in resolvers so we're going to create a layer with business logic. A good example of that are Users and Chats modules so let's start with the former.\n+\n+We're going to create `Users` service and move `Query.users` logic into `findAllExcept` method:\n+\n+{{{ diffStep \"13.7\" module=\"server\" files=\"modules/users/users.provider.ts,modules/users/index.ts\" }}}\n+\n+A very interesting thing to notice is `@Inject()` decorator.\n+\n+```ts\n+@Inject() private db: Database;\n+```\n+\n+The @Inject, well... injects `Database` provider as `db` property so you don't have to use the `constructor`.\n+\n+Back to the Users service. It's very similar to what we did with the `UnsplashApi` so let's move on and implement more methods.\n+\n+{{{ diffStep \"13.8\" module=\"server\" }}}\n+{{{ diffStep \"13.9\" module=\"server\" }}}\n+\n+Let's now implement `Chats` service with two basic methods:\n+\n+{{{ diffStep \"13.10\" module=\"server\" }}}\n+\n+It looks exatly like `Users` and also has only `database` provider in it.\n+\n+We're going to move on and more things:\n+\n+{{{ diffStep \"13.11\" module=\"server\" }}}\n+{{{ diffStep \"13.12\" module=\"server\" }}}\n+{{{ diffStep \"13.13\" module=\"server\" }}}\n+{{{ diffStep \"13.14\" module=\"server\" }}}\n+{{{ diffStep \"13.15\" module=\"server\" }}}\n+\n+#### Sharing PubSub\n+\n+One of things that are still in the context is `PubSub`. Because we're moving an entire business logic into a separate layer and as part of GraphQL Module's providers we need to make sure that PubSub is accessible throug DI.\n+\n+Let's register the PubSub and migrate resolvers:\n+\n+{{{ diffStep \"13.16\" module=\"server\" }}}\n+\n+Now, we're going to use `PubSub` within `Chats` service:\n+\n+{{{ diffStep \"13.17\" module=\"server\" }}}\n+{{{ diffStep \"13.18\" module=\"server\" }}}\n+{{{ diffStep \"13.19\" module=\"server\" }}}\n+\n+#### Implementing Auth service\n+\n+The last missing piece of our \"context migration\" journey is `currentUser` object. We're going to define the `Auth` service.\n+\n+{{{ diffStep \"13.20\" module=\"server\" files=\"modules/users/auth.provider.ts\" }}}\n+\n+It still needs to be registered and few resolvers in Users module have to be migrated:\n+\n+{{{ diffStep \"13.20\" module=\"server\" files=\"modules/users/index.ts, context.ts\" }}}\n+\n+Now let's use the Auth service in Chats:\n+\n+{{{ diffStep \"13.20\" module=\"server\" files=\"modules/chats/index.ts\" }}}\n+\n+Because we no longer need `db` instance in the context, let's remove it:\n+\n+{{{ diffStep \"13.21\" module=\"server\" }}}\n+\n+Besides the `currentUser` method we're going to have two more, one to sign in and the other to sign up:\n+\n+{{{ diffStep \"13.22\" module=\"server\" }}}\n+{{{ diffStep \"13.23\" module=\"server\" }}}\n+\n+#### Exposing server instance\n+\n+If you would run `yarn test` right now, you will see a lot of errors, every test will fail. That's because we changed our setup but we didn't adjusted tests.\n+\n+We're going to change the setup of tests as well so whenever we do something on server it won't affect them. Instead of exposing schema and context as we did before, we're going to base the tests on a ready to use ApolloServer instance.\n+\n+In order to achieve it, we need to separate ApolloServer from other server related logic.\n+\n+{{{ diffStep \"13.24\" module=\"server\" }}}\n+{{{ diffStep \"13.25\" module=\"server\" }}}\n+\n+There's one thing that changed and might break our tests, this line fix it:\n+\n+{{{ diffStep \"13.26\" module=\"server\" }}}\n+\n+Remember when I said about benefits of Dependency Injection? Here's one of them. We create a function that overwrites the `currentUser` method so it always returns a specific user.\n+\n+{{{ diffStep \"13.27\" module=\"server\" }}}\n+\n+Let's now migrate all tests and see how easier it is now to manage those. Because we use ApolloServer's instance, we don't need to understand how it's implemented.\n+\n+{{{ diffStep \"13.28\" module=\"server\" }}}\n+\n+## Adjusting client\n+\n+We still need to update `codegen.yml` in the client app because of the changes we introduced in this chapter:\n+\n+{{{ diffStep \"14.1\" module=\"client\" }}}\n+\n+## Many ways to write GraphQL\n+\n+We’re going to discuss what are the possible options of building GraphQL API and why schema-first approach was our choice.\n+\n+The main ingredient of a GraphQL API is, of course the schema. It’s built out of type definitions where each of them describes a piece of data, connections between them and how data is actually resolved.\n+\n+The way we develop all of it changes the way we work with the API.\n+\n+We could define two main approaches:\n+  - schema-first\n+  - resolver-first\n+\n+The former means design comes before code, the latter vice-versa.\n+\n+In schema-first development you start with SDL, resolvers and code go next. Schema is sort of a contract between teams and also between frontend and backend. With schema-first approach it’s easier to cooperate, discuss and write a better API. Because the SDL is written upfront, the frontend developers can use a mocked version of it and start working on the product while the backend team does the API, in parallel.\n+There are of course some pain points. Once schema is splitted into SDL and resolvers it’s hard to keep them in sync and that’s why things like GraphQL Code Generator were developed, to add type safety on top of all.\n+\n+The resolver-first approach is a bit different. The schema is defined programmatically, which usually means it’s more flexible and combined with TypeScript or Flow gives you type-safety out of the box.\n+\n+We think it’s less readable than having a SDL and there’s a lack of separation between schema and code which might be a blocker for some teams.\ndiff --git a/.tortilla/manuals/templates/step17.tmpl b/.tortilla/manuals/templates/step17.tmpl\nnew file mode 100644\nindex 0000000..a0e2c2e\n--- /dev/null\n+++ b/.tortilla/manuals/templates/step17.tmpl\n@@ -0,0 +1,655 @@\n+In this part of the tutorial we're going to do a bit different work than in previous chapters. We'll analyze the code instead of writing it, including both the API and the web application.\n+\n+## API Performance\n+\n+First, let's start with the GraphQL API.\n+\n+### Finding bottlenecks\n+\n+In order to implement fixes and do improvements we need to understand which part of the API needs help. There's still not many tools around GraphQL in terms of analytics and inspection but there's one highly useful, it's called **Apollo Engine**.\n+\n+Since we're going to use it, you need to register an account at [engine.apollographql.com](https://engine.apollographql.com/) and create a service. Please then follow [the \"How to configure an Apollo project\" instructions](https://www.apollographql.com/docs/platform/schema-registry/#using-the-schema-registry).\n+\n+Once you're ready, please start the server and run this command:\n+\n+    $ apollo service:push\n+\n+To collect the data, let's play with the client app for some time. After that, go to Engine's website.\n+\n+Here's one of graphs with timing of an operation. We can understand when each resolver takes place and how much time it consumes. Some resolvers happen in parallel.\n+The `< 1ms` says it was a very simple computation or an element resolved immediately.\n+\n+We find it very useful to understand how operation behaves.\n+\n+![Resolvers](../../../assets/step17/img-01.png \"Resolvers\")\n+\n+Let's go through an entire query to find fields fetched multiple times. The most obvious field is `isMine`. We see it's computed twice for almost 4 and 5 milliseconds.\n+In order to find out what does it mean, we need to look at the code. The resolver gets the currently logged in user from the `Auth` service and its `currentUser`. Each time the method is invoked, a query to PostgreSQL is made. We ask for that data multiple times, once in `lastMessage` and also in every message from the list.\n+\n+We could deduplicate the SQL queries! In order to do that the most obvious library that pops to my mind is Dataloader.\n+\n+Let's install the package and discuss it afterwards:\n+\n+    npm install dataloader\n+\n+The Dataloader is a library created and maintained by Facebook. It's main purpose is to turn equivalent requests into a single execution. Sounds like a perfect solution, right? It actually is.\n+\n+A short explaination of how Dataloader works.\n+\n+```ts\n+async function fetchUser(id: number): Promise<User> {\n+  // Resolves asynchronously, after less than 1s.\n+  return db.users.findOne(id);\n+}\n+\n+async function fetchUsers(ids: number[]): Promise<User[]> {\n+  const users = ids.map(id => fetchUser(id));\n+  return Promise.all(users);\n+}\n+\n+const loader = new Dataloader(keys => fetchUsers(keys));\n+\n+async function main() {\n+  const user1 = await loader.load(1);\n+  const user2 = await loader.load(2);\n+\n+  // Later on user #1 is fetched again.\n+  // It resolves immediately.\n+  const member1 = await loader.load(1);\n+}\n+```\n+\n+Think of the Dataloader as a class that has a `Map` object in it, its keys are of course unique and each value is a `Promise`.\n+Every time you ask for something, Dataloader looks for it in the `Map`. When there's already something, the `Promise` is returned but if there's none the provided function is invoked and a new `Promise` is created. This way equivalent requests share the same `Promise`.\n+\n+> It's important to know that the `Map` object grows until the DataLoader is released, that's why it's recommended to keep `Dataloader` in GraphQL's context.\n+\n+Let's implement `Dataloader` in our `Database` service:\n+\n+{{{ diffStep \"14.1\" module=\"server\" files=\"modules/common/database.provider.ts\" }}}\n+\n+The key is created based on SQL statement and its values and we also turned off batching because it's important to execute SQL operations sequentially.\n+There's also a new method called `query`, to execute SQL statements through Dataloader. It also reduces a boilerplate of asking for db client and executing a query every time we do SQL in resolvers and providers.\n+\n+Now we need to apply that change in all providers:\n+\n+{{{ diffStep \"14.1\" module=\"server\" files=\"modules/users/users.provider.ts, modules/chats/chats.provider.ts\" }}}\n+\n+Deduplication is done but the `currentUser` method does more than just that. It verifies the auth token extracted from a request's cookie. This could be avoided by an assignment to a private prop and a simple if statement.\n+\n+{{{ diffStep \"14.2\" module=\"server\" }}}\n+\n+![Resolvers](../../../assets/step17/img-02.png \"Resolvers\")\n+\n+As you can see at the graph above, we reduced an execution time of `isMine` field from 4ms and 5ms to less than 1. That applies for all calls, all messages so it scales well and won't grow as list of messages increases.\n+\n+But there's more... We see `chat` field being computed over and over again. So again, let's repeat the same steps.\n+The `Message.chat` resolver asks `Chats` service and its `findChatById` method which makes a SQL call.\n+\n+The deduplication logic, we introduced in the previous step, helps to immediately resolve all `Message.chat` fields except the first occurrence but there's still a space for improvements.\n+\n+The `Query.chats` resolver is invoked before the `Message.chat` which means at this point, we already have knowledge about the chats.\n+\n+Let's implement a caching logic for chats so we could reuse them. We will do it in few steps.\n+\n+First, because we're going to use `Dataloader`, `Chats` class should have private and public API.\n+\n+{{{ diffStep \"14.3\" module=\"server\" }}}\n+\n+The private method is responsible for quering data from the database but the public one is to allow communication between the service and its consumers.\n+It's also there so we could switch to using Dataloader later on.\n+\n+We did that to `findChatsByUser` but there are more:\n+\n+{{{ diffStep \"14.4\" module=\"server\" }}}\n+{{{ diffStep \"14.5\" module=\"server\" }}}\n+\n+> Because those private methods are just to query data, make sure they all return untouched `row` object.\n+\n+Now's the most interesting part, Dataloader.\n+\n+{{{ diffStep \"14.6\" module=\"server\" }}}\n+\n+We introduced `ChatsKey` that is a union type, to standarize the input value. Those helper methods like `isChatsByUser` and `isChatByUser` are there to decide what should be fetched.\n+\n+In every public method that we previously changed, there's now Dataloader in use but that's not entirely what we're trying to achieve.\n+\n+The caching mechanism is not yet completed. We deduplicate requests but in some cases, we ask for chats that are already there, so we need to intercept our dataloader logic and introduce caching.\n+\n+{{{ diffStep \"14.7\" module=\"server\" }}}\n+\n+Whenever we ask for a single chat that is available, it's being resolved right away but we still need to write data to the cache.\n+\n+{{{ diffStep \"14.8\" module=\"server\" }}}\n+\n+Let's look at charts in Apollo Engine.\n+\n+![Resolvers](../../../assets/step17/img-03.png \"Resolvers\")\n+\n+We cut off `Message.chat` to less than 1ms.\n+\n+The `Chat.name` and `Chat.picture` resolvers share the same logic and since Database service is wrapped with DataLoader, we make a single SQL query. Unfortunately, it's not visible on the graph.\n+\n+Let's summarize our work. **We made the GetChat operation almost 60% faster on average** and it's just based on one chat with one message. The number would be much much higher on a bigger scale.\n+\n+### Preventing issues\n+\n+The Apollo Engine has another interesting feature. It’s called Alerts. You set a threshold for all operations or a specific one and whenever it takes longer, you get a notification on Slack. But there’s a catch, you need to pay in order to unlock it.\n+\n+We’re working on something similar but entirely open-sourced. It’s an extension of ApolloServer that lets you track operations and get exactly what you would get from the engine but self-hosted.\n+\n+## UI Performance\n+\n+The part would be the User Interface and the web app in general.\n+\n+### Metrics\n+\n+There's a highly recommended and very comprehensive publication written by Philip Walton (Engineer at Google) called [\"User-centric Performance Metrics\"](https://developers.google.com/web/fundamentals/performance/user-centric-performance-metrics) that was an inspiration for this chapter. We’re going to talk in short about measuring render performance of a web application.\n+\n+Let’s base this chapter on real data. First, open the app and go to Performance tab of Chrome DevTools.\n+\n+![Record](../../../assets/step17/img-04.png \"Record\")\n+\n+Now click on “Start profiling and reload page”. After it’s done you should see the following:\n+\n+![All panels](../../../assets/step17/img-05.png \"All panels\")\n+\n+Right now it may not make a lot of sense, so we’re going to start with something basic.\n+\n+There’s many different kinds of charts but we will cover only few of them: Network, Frames, Timings and Main.\n+\n+Let’s check out the Timings section and explain few important performance metrics.\n+\n+- DCL - DOMContentLoaded Event\n+- L - Onload Event\n+- FP - First Paint\n+- FCP - First Contentful Paint\n+- FMP - First Meaningful Paint\n+\n+There’s also another one that is not visible on the timeline but also not less important, TTI - Time to Interactive.\n+\n+We will focus on FP, FCP, FMP and TTI.\n+\n+The primary difference between the two metrics is **First Paint** marks the point when the browser renders anything that is visually different from what was on the screen prior to navigation. By contrast, **First Contentful Paint** is the point when the browser renders the first bit of content from the DOM, which may be text, an image, SVG, or even a `<canvas>` element.\n+\n+The **First Meaningful Paint** should mark the point when something useful was rendered. It might mean an input box on Google, video player on YouTube or in our case, a list of chats.\n+\n+The **Time To Interactive** metric marks the point at which the application is both visually rendered and capable of reliably responding to user input.\n+\n+Now with all that knowledge we can move on to something more practical, the **Frames panel**. The main purpose here is to see what’s rendered at given time. In our case, the first paint was made after over 200ms, which is not a bad result at all but see that huge blank space next to it.\n+\n+The **Network section**, is going to help us out here and give some pointers of what might be a reason of it. It’s a timeline that explains when each request was made and how long it took to resolve.\n+\n+![Network section](../../../assets/step17/img-06.png \"Network section\")\n+\n+What do we see here? One of the first requests are js files and we need those to bootstrap and render the app. That’s the reason of the blank page.\n+\n+We could improve that by either Server-Side Rendering or using a Service Worker.\n+\n+### Rendering improvements\n+\n+#### Server-Side Rendering\n+\n+Implementing SSR means you run the app on server, before it’s being shipped to the client and the document’s content is not just `<html><body><app></app></body></html>` but an actual markup with all the components in it. Because it’s a part of the document, the browser can already display something meaningful and after js files are loaded, the app bootstraps on the client and it becomes interactive. There is one caveat. Wherever you ship the app it has to be able to run node js.\n+\n+#### Store Rehydration\n+\n+When talking SSR it’s worth to mention GraphQL and related technique called Store Rehydration. API calls are an important part of an application and plays a huge role in SSR.\n+\n+GraphQL operations are called once components are mounted which means the cache is filled up and why not reuse it on client.\n+\n+How would it work? Data is extracted from the apollo’s cache and passed within a document. After it’s received by the browser, the app runs and so does the Apollo Client. While it happens we look for the data and fill up the cache. Now whenever a component calls a GraphQL operation, the result is already in the cache and resolves immediately.\n+\n+#### Service Worker\n+\n+Another approach is a bit different. By using a Service Worker, we’re able to control and cache requests, including js files, images etc. On the first visit, the app loads exactly the same as without SSR but the next visits are a bit faster. It’s because the Service Worker is registered after you close the app and of course we can’t cache things that weren’t fetched yet.\n+\n+Both techniques are not mutually exclusive and we highly recommend to use both.\n+\n+![Main section](../../../assets/step17/img-07.png \"Main section\")\n+\n+The next section we’re going to talk about is the **Main panel**, a flame chart of activity on the main thread. You see those blocks? They represent an event, the wider it is the longer it took. One of the most important things to remember is to avoid long events since they block the thread.\n+The longest event on our timeline is the Evaluate Script event that involves `main.js`. The file contains all the libraries and the core functionality, those are needed to run the app. By making it lighter we would decrease the time of the first render.\n+We already do something to reduce the bundle size, This technique we use is called code-splitting and it allows to split one piece of code into multiple files which are lazy loaded.\n+It cuts off the size of the main bundle and the rest is loaded on demand, let’s say login page is in a different chunk than list of chats.\n+\n+### Tooling\n+\n+There’s one tool built into Chrome DevTools called Lighthouse that allows to measure, collect metrics and get helpful tips on how to improve the performance and where are the pain points.\n+\n+Here’s the example:\n+\n+![Lighthouse results](../../../assets/step17/img-08.png \"Lighthouse results\")\n+\n+Once your app is optimized you want to prevent regressions. Lighthouse has you covered! It may run as part of Continuous Integration and prevents deployment when key metrics regress or drop below a certain threshold.\n+\n+## Making the app feels instant\n+\n+Dealing with slow network can be hard so let's simulate that situation. After all, running the application on local host will always result in low response times.\n+\n+Luckily most browser come with a built in solution for that - we can simulate a slow network by defining the throttle level:\n+\n+![Throttling](../../../assets/step17/img-09.png \"Throttling\")\n+\n+If we will refresh the application, we should notice a significant slow down the first time we load each screen; about few seconds to load each of them. To ensure that this is really caused by a slow network and not by anything else, we can open the dev-tools of our browser (let’s assume you use Chrome) and under the `network` tab we should notice the network activity times.\n+\n+> More information about monitoring network activity and throttling it using the Chrome’s dev-tools can be found in [the official dev-tools docs page](https://developers.google.com/web/tools/chrome-devtools/network/).\n+\n+To solve these issues there are a couple of changes we’re gonna make in the way we fetch and manage data.\n+\n+### Optimistic UI\n+\n+As you know, pretty much in all cases, everything in Apollo flows through its cache. If a requested data is in there, a query is resolved right away. Mutations are a bit different, they have to reach the server every single time. Seems like nothing we can do about it but fortunately we can simulate the mutation, predict the result and make Apollo treat it as a temporary data. Which means, the app’s state and all components are updated and the change is visible instantly after it’s made.\n+\n+In case of the WhatsApp clone, whenever a new message is sent, we will see it right away, on the screen, doesn’t matter if the network is low or even super fast. You may experience the similar behavior on Facebook’s Messenger.\n+\n+\n+```graphql\n+  mutation AddMessage($chatId: ID!, $content: String!) {\n+    addMessage(chatId: $chatId, content: $content) {\n+      ...Message\n+    }\n+  }\n+```\n+\n+```graphql\n+  addMessage({\n+    variables: { chatId, content },\n+    optimisticResponse: {\n+      __typename: 'Mutation',\n+      addMessage: {\n+        __typename: 'Message',\n+        id: Math.random().toString(36).substr(2, 9),\n+        createdAt: new Date(),\n+        isMine: true,\n+        chat: {\n+          __typename: 'Chat',\n+          id: chatId,\n+        },\n+        content,\n+      }\n+    },\n+    update: (client, { data: { addMessage } }) => {\n+      writeMessage(client, addMessage);\n+    },\n+  })\n+```\n+\n+We used words “predict” and “simulate”, what if the mutation behaves differently or what’s more interesting, it fails. Apollo handles that as well. The “real” response overwrites the fake one and the store is reverted back to the original state.\n+\n+### Prefetching data\n+\n+Another technique but with a bit different purpose is about fetching data in advance. In some situations, you might be able to predict which page/component is going to be entered next.\n+\n+Let’s base it on a real example. The WhatsApp clone has a page with a list of chats. The component that represents the page, calls a GraphQL operation to fetch that list. Right now, when user clicks on one of the chats, he’s redirected to a partially empty page because of the ongoing GraphQL request. What if we could fetch that data in advance? That’s what this technique is about. We could predict user’s next move based on a simple mouse event or even by using Artificial Intelligence and data collected by Google Analytics, so whenever the move actually happens, the data is already in the cache.\n+\n+{{{ diffStep \"15.1\" module=\"client\" files=\"src/components/ChatRoomScreen/index.tsx\" }}}\n+\n+We created the `useGetChatPrefetch` hook that gets ApolloClient instance through `useApolloClient` and returns a function to prefetch data. In this case we request `GetChat` operation. Because Apollo deduplicates queries, we won't make multiple http calls, we're safe.\n+\n+The actual usage of `useGetChatPrefetch`, happens on `mouse entered` event:\n+\n+{{{ diffStep \"15.1\" module=\"client\" files=\"src/components/ChatsListScreen/ChatsList.tsx\" }}}\n+\n+Now, the same but with the list of users:\n+\n+{{{ diffStep \"15.1\" module=\"client\" files=\"src/components/ChatsListScreen/AddChatButton.tsx\" }}}\n+{{{ diffStep \"15.1\" module=\"client\" files=\"src/components/ChatsListScreen/ChatsList.tsx\" }}}\n+\n+### Splitting and Deferring Queries\n+\n+Prefetching is an easy way to make your applications UI feel faster. You can use mouse events to predict the data that could be needed. This is powerful and works perfectly on the browser, but can not be applied to a mobile device.\n+\n+One solution for improving the UI experience would be the usage of fragments to preload more data in a query, but loading huge amounts of data (that you probably never show to the user) is expensive.\n+\n+Another solution would be to **split huge queries into two smaller queries**:\n+\n+- The first one could load data which is already in the store. This means that it can be displayed instantly.\n+- The second query could load data which is not in the store yet and must be fetched from the server first.\n+\n+This solution gives you the benefit of not fetching too much data, as well as the possibility to show some part of the views data before the server responds.\n+\n+This could be used in our messaging app to load chat’s information and messages separately. This way we will see the title and the image instantly, because it’s already in the cache but messages will be loaded afterwards. UX will benefit a lot.\n+\n+There’s also something very similar conceptually to Query Splitting but instead of separating queries we keep everything in one operation and annotate the parts that should be deferred. The annotation is, of course a directive and it’s called **`@defer`**.\n+\n+Once the `@defer` is used, the server returns an initial response without waiting for deferred fields to resolve, using null as placeholders for them. Then, it streams patches for each deferred field asynchronously as they resolve. Thanks to that, we maintain one operation but decide how it behaves.\n+\n+> Right now, this feature is not well supported in Apollo Server so we don’t recommend to use it yet. Keep it on mind though.\n+\n+### Dealing with rendering issues\n+\n+The most naive thing we can do to start noticing performance issues would be loading TONS of data to our app, and make sure that each view is absolutely overwhelmed with information. This way performance issues will start rising above the surface pretty quickly. To do that, we will edit the `resetDb()` method on the server so it can generate large quantities of data. The most comfortable way of controlling that behavior would be through an environment variable that will tell the reset method how much iterations it should run. The more iterations, the more data would be fabricated:\n+\n+{{{ diffStep \"15.10\" module=\"server\" }}}\n+\n+It’s important to note that we’ve generated the data in a very specific way where a single user will be the center of the network of data. This way when we log in with that user, we should see our views packed. If it wasn’t for that we would have just had large quantities of data in the DB, but none of it would appear to the end-user.\n+\n+Now, we will restart the server and this time run it differently. We will provide `FAKED_DB` with a value of `100` which should connect us to 100 messages per single view:\n+\n+    RESET_DB=true FAKED_DB=100 yarn start\n+\n+Now make sure that the application is running and log-in with the first user of Ray Edwards using the credentials:\n+\n+    username: ray\n+    passowrd: 111\n+\n+Now try to navigate around between the `ChatsScreen` and `ChatBoxScreen`. You’ll notice that each transition takes a long time until it shows the data. It’s obviously something which is related to rendering and not data transportation, because the slowdown also happens the second time you visit a view, a point where the fetched data should have already been stored by Apollo in cache. So we’ve already detected one performance issue we should deal with.\n+\n+### Pagination\n+\n+To solve it, there are couple of changes we’re gonna make in the way we ask for data, messages will be fetched dynamically based on our scrolling position.\n+\n+With these changes, the requests will be splitted into smaller chunks, and React DOM won’t have to deal with a lot of data the first time it loads. There are few challenges that may arise from this implementation:\n+\n+- Representing queries in a way that they can be loaded in chunks\n+- Sending requests and updating the view dynamically\n+- Maintaining updates from subscriptions\n+\n+To start with, we will first take on the task of improving initialization times. We will release the pressure by fetching only the first 20 messages. This way when we visit a chat, it should be loaded faster.\n+\n+For that we're going to implement cursor-based pagination. We will add `after` and `limit` arguments to `Chat.messages` that could be used to fetch a specific snapshot of available messages.\n+\n+- `after` is optional and marks the point where the last fetch ended (what is the last element of a received list)\n+- `limit` is required, defines amount of data\n+\n+A common design pattern for fetching data snapshots from a GraphQL back-end is called [Relay](https://facebook.github.io/relay/docs/en/graphql-server-specification.html). Relay provides a robust solution which is suitable for things like search engines.\n+\n+We will define our own version of it.\n+\n+{{{ diffStep \"14.9\" module=\"server\" }}}\n+\n+The `MessagesResult` is built of:\n+\n+- `cursor` - marks the end of a fetched list\n+- `hasMore` - tells if there's more data to ask for\n+- `message` - has the same type as `Chat.messages` previously had\n+\n+Because the cursor marks the edge of received data, it has to be something we could use while sorting. The most obvious choice is the date of creation, so `created_at` column of `messages` table.\n+\n+It's stored as `YYYY-MM-DD HH:mm:ss` but we want to expose it as something easier to work with, let's say a `number`.\n+\n+In order to do it quickly, let's add `date-fns` package:\n+\n+    npm install date-fns\n+\n+It has `format` method that will help us to do conversions.\n+\n+We need to the logic of `Chats.findMessagesByChat` method.\n+\n+{{{ diffStep \"14.11\" module=\"server\" }}}\n+\n+Because the order of creation matters, messages are selected quite differently than before, we keep selecting all columns but records are ordered by the date of creation.\n+\n+There's an interesting thing related to the cursor. If it's provided, we query for only those messages that happened before our cursor. This way we have a valid direction, fetching more messages means fetching older records.\n+\n+The last message in the list becomes of course the `cursor`.\n+\n+In order to calculate `hasMore` we need to apply the same conditions as above but with `LIMIT 1` and see if we get a result.\n+\n+Since the API part is done, let's take care of something much more complicated, which is always the UI...\n+\n+Let's plan it first. We know we want to fetch more messages while scrolling up. That means, Infinite Scroll with a corresponding request each time we hit the top. Because we implemented prefetching, we need to know what's the `limit`. React's Context might be helpful here. There was, of course, the change in GraphQL Schema we need to take care of too.\n+\n+### Apply schema changes\n+\n+Since we know what the plan is, let's start with schema changes. The `Chat.messages` is no longer a list, it's an object now.\n+\n+{{{ diffStep \"15.6\" module=\"client\" }}}\n+\n+Now we need reflect those changes in generated hooks by running:\n+\n+    yarn codegen\n+\n+Okay, let's move on!\n+\n+### Infinite Scrolling\n+\n+Now this Infinite Scroll thing. The core concept is to ask for more data, once a user's scrollbar hits the top edge of the screen.\n+\n+{{{ diffStep \"15.2\" module=\"client\" }}}\n+\n+Our `useInfiniteScroll` hook requires:\n+\n+- `ref` is a reference of a HTML element\n+- `onLoadMore` calls the part component back and asks for data\n+\n+We used `useEffect` to add and remove a scroll event listener. The function lives as long as `ref` and `onLoadMore` stay the same, that's because we simply make use of them in `handleScroll` function. The `handleScroll` function calls `onLoadMore` when a user scrolled to the top.\n+\n+It all looks fine at first, but we still need to prevent calling back once fetching is in progress.\n+\n+{{{ diffStep \"15.3\" module=\"client\" }}}\n+\n+That's why `isFetching` state is necessary but as you can tell, we don't set it to `false`.\n+\n+{{{ diffStep \"15.4\" module=\"client\" }}}\n+\n+We want the consumer of the hook to tell it when fetching is finished, that's why we expose the state with `stopFetching` function.\n+\n+The next issue that appears right away is related to the case when there's no more data to fetch.\n+\n+{{{ diffStep \"15.5\" module=\"client\" }}}\n+\n+Pfff... The hook part is done!\n+\n+### Pagination\n+\n+Pagination is partially implemented thanks to Infinite Scrolling but the thing we need to still apply is React's context. It will be a central place of storing `limit` and `after` values, so they could be shared across multiple components and not passed directly from one to another.\n+\n+{{{ diffStep \"15.7\" module=\"client\" }}}\n+\n+We implemented three things:\n+\n+- `PaginationContext` is simple, it stores the values but also allows to set a new one for `after` or even bring it all back to the initial state.\n+- `usePagination` hook is there so components could use `PaginationContext` and to make sure we reset it when component unmounts.\n+- `ChatPaginationProvider` provides the logic and core functionality\n+\n+Since the pagination is almost ready, let's make use of it in `useGetChatPrefetch` hook and `ChatRoomScreen` component.\n+\n+{{{ diffStep \"15.8\" module=\"client\" }}}\n+\n+This won't work yet because there's nothing that creates the context.\n+\n+{{{ diffStep \"15.9\" module=\"client\" }}}\n+\n+We had to split the `ChatRoomScreen` into two pieces. One that includes `ChatPaginationProvider` and produces `chatId` and the other that keeps pretty much everything else. This way the tree of child components, starting from `ChatRoom` share the same context.\n+\n+### Fetching more messages\n+\n+Everything is set up, we can now move on and consume the `useInfiniteScroll` in the `MessagesList` component.\n+\n+{{{ diffStep \"15.10\" module=\"client\" }}}\n+\n+We added the `LoadingMore` component with *Loading more messages...* text in it that pops out when fetching is in progress.\n+Because the `MessagesList` is not responsible of quering data we don't know exactly when it's completed but we can assume, it happens once the length of `messages` changes.\n+We also pass `onLoadMore` and `hasMore` props to the parent component and the `useInfiniteScroll` uses `MessagesList` as the element we're going to scroll in.\n+\n+There's also one more thing that could be turned into a hook, it's the logic responsible for scrolling to bottom of the page, every time `messages` changes.\n+\n+{{{ diffStep \"15.11\" module=\"client\" }}}\n+\n+We also added some extra functionality there. Because we don't want to scroll to bottom when a new message is added, the function returned by `useAdjustedScroll` accepts now an argument.\n+\n+We did the `MessagesList`, now let's move onto real data and the `ChatRoom` component.\n+\n+{{{ diffStep \"15.12\" module=\"client\" }}}\n+\n+As you see above, every time the `MessagesList` asks for more messages, the `after` changes its value to `chat.messages.cursor` which means that's a new \"end\" of the list and we need to fill it up.\n+\n+Right now we just have a logic and a place to do it but we still need to make a GraphQL call.\n+\n+Fortunately, Apollo lets you do pagination with a method called `fetchMore`. You need to specify what query and variables to use for the update, and how to merge the new query result with the existing data on the client. How exactly you do that will determine what kind of pagination you are implementing, in our case it's cursor-based.\n+\n+But there's a catch!\n+\n+It's related to how Apollo stores query results in cache. When we update the variables, in our case it's the `after` that changes quite a lot, a new record is created that is totally unrelated to the original query. That's because Apollo uses a combination of variables and query string to produce a key.\n+\n+An example:\n+\n+\n+```graphql\n+{\n+  query getUser($id: ID!) {\n+    user(id: $id) {\n+      name\n+    }\n+  }\n+}\n+```\n+\n+The result of `getUser` query will be saved under `user({\"id\":2})` key.\n+\n+This is a huge problem, it breaks imperative store updates but that's why `@connection` directive exists. It directs Apollo to use a stable store key for paginated queries, so every `useQuery()` or `fetchMore()` is being placed in the same space.\n+\n+With all that knowledge, let's implement the last puzzle piece!\n+\n+{{{ diffStep \"15.13\" module=\"client\" }}}\n+\n+As you see, we mutate the store as usual and we put fetched messages before the existing ones. Remember, it's from older to newer.\n+\n+### Looking at the bundle size\n+\n+We can't of course forget about one of the most important aspects of optimization, the size of the application. As bundle size increases, both the parsing time and the time of the request takes longer.\n+\n+How can we check what libraries and source files are shipped within the produced bundle?\n+\n+There are many tools that analyze it for us but we're going to use only one of them, just for educational purpose.\n+\n+      $ yarn add -D source-map-explorer\n+\n+We're going to add the `size` npm script in which we point the `source-map-explorer` to transpiled js files.\n+\n+{{{ diffStep \"15.14\" module=\"client\" }}}\n+\n+Let's see it in action, run:\n+\n+    $ yarn build && yarn size\n+\n+That's what you should see:\n+\n+![Source Map Explorer](../../../assets/step17/img-10.png \"Source Map Explorer\")\n+\n+It's interactive so you can dive deeper and deeper into those blocks but in general it shows what libraries and files are included in the produced output with their size(not minified and not gzipped).\n+\n+![Source Map Explorer](../../../assets/step17/img-11.png \"Source Map Explorer with moment highlighted\")\n+\n+For example, we see that `moment` takes almost _53.49KB_ which is enourmous. In fact we only use its `format` method. The reason is that the library is not well tree-shakable. There are plugins for webpack (or any other build tool) that helps with it but we're going to use an alternative instead. We're going to replace it with `date-fns`.\n+\n+{{{ diffStep \"15.15\" module=\"client\" }}}\n+\n+Now when you run:\n+\n+    $ yarn build && yarn size\n+\n+You should see the following results.\n+\n+![Source Map Explorer](../../../assets/step17/img-12.png \"Source Map Explorer with date-fns\")\n+\n+The bundle size is a bit smaller and `date-fns` takes only _8.93KB_ which in comparison to _53.49KB_ is a significant change!\n+\n+## Load testing\n+\n+Load testing, in short, is about finding the limit of an application and figure out how to push it even more. We simulate a stressful behavior and apply that to the server until it crashes. We’re trying to answer the question of how the api deals with a pressure.\n+\n+When to do load testing?\n+I would say at least before and after major changes, when pre-launching and just from time to time to prevent regressions.\n+\n+Before doing load testing, we need to prepare a bit first. Right now we use `ts-node` to run the server but it would be faster to run it directly using `node`, just to avoid on-the-fly transpilation of TypeScript files.\n+\n+In order to do it, we need to define the `outDir` in `tsconfig.json` and add a build step.\n+\n+{{{ diffStep \"14.12\" module=\"server\" }}}\n+\n+Next, the script to actually run the server:\n+\n+{{{ diffStep \"14.13\" module=\"server\" files=\"package.json\" }}}\n+\n+Once it’s ready, we can move on to tooling.\n+\n+### Artillery\n+\n+Artillery is an open-source load testing and functional testing toolkit. It’s API is vast but we will focus on the core part of it which is relevant to this chapter. Artillery is available as a npm package:\n+\n+    $ yarn add -D artillery\n+\n+The only step to use Artillery is to set it up. We will create the `artillery.yml` file, like this:\n+\n+{{{ diffStep \"14.15\" module=\"server\" }}}\n+\n+As you can see, the config file is built of two sections. First one is named `config` and it defines what’s our target and how the traffic should look like. We used one phase but it could have many. The `duration` parameter is to define how long the phase should take. The `arrivalRate` defines how many virtual users per second are going to hit the target and the `rampTo` directs Artillery to increase this number up to 20, at the middle of the phase.\n+\n+The next section, called `scenarios`, is all about the actual requests. In our case, we want to authenticate user, submit a new message and fetch an entire list of chats with their messages at the end. Artillery shares cookies between request of the same virtual user, keep that on mind.\n+\n+We used Ray as the user and fairly similar operations to what the client app sends. That should closely represent the actual usage of the API.\n+\n+Everything is fine with that config but we need to find the limit, to push even more. That's why we'll also add a second config with a bit more heavier traffic, something to simulate the more real life environment. It's pretty much the same setup except phases. First, we \"warms up\" the server for 2 minutes, same amount of times goes next with double the traffic, then we keep it for 5 minutes. At the end, we want to crash the server so we send nearly 100 virtual users per second for an entire minute. This way we know when it cracks.\n+\n+{{{ diffStep \"14.16\" module=\"server\" }}}\n+\n+Once everything is ready, let's add npm scripts, one for a normal traffic and a second with the much more users:\n+\n+{{{ diffStep \"14.17\" module=\"server\" }}}\n+\n+You probably noticed that we stream the output to the `loadtest.log` file and that's just to read the results in a bit more pleasent way, than in the terminal.\n+\n+Let’s start the server and run artillery:\n+\n+    $ yarn build && yarn start\n+    $ yarn loadtest\n+\n+You’ll see a loading indicator, might take a while but when it completes, you should see something like this in `loadtest.log` file:\n+\n+```\n+Summary report @ 15:00:58(+0200) 2019-05-30\n+  Scenarios launched:  1506\n+  Scenarios completed: 1506\n+  Requests completed:  4518\n+  RPS sent: 37.35\n+  Request latency:\n+    min: 3.5\n+    max: 115.7\n+    median: 18.6\n+    p95: 54.4\n+    p99: 66.2\n+  Scenario counts:\n+    Sign in, send a new message and fetch a list of chats: 1506 (100%)\n+  Codes:\n+    200: 4518\n+```\n+\n+We ran the scenario 1506 times, all were completed and the total number of requests was 4518.  The **RPS** means requests per second.\n+\n+The metrics in **Request latency** are in milliseconds. We see what was the shortest request and so on. These **p95** and **p99** values mean that for 95% of virtual users, the latency was 54.4ms or lower, for 99% it was 66.2ms. All requests finished with 200 status code.\n+\n+You might also automate that process and integrate Artillery CLI with CI/CI systems or even send metrics to external monitoring systems.\n+\n+### Apollo Engine\n+\n+Let's bring back the Apollo Engine once again. It will be helpful to analyze the load testing results.\n+\n+On the **Metrics** page, you will see the following view:\n+\n+![Metrics](../../../assets/step17/img-13.png \"Metrics\")\n+\n+Click on the filter and set a custom date range to match the time you were load testing. Just to filter out other requests.\n+\n+![Filter](../../../assets/step17/img-14.png \"Filter\")\n+\n+By default, Apollo Engine counts all operations, but you can pick the one you’re interesting in. We don’t do it and inspect them all.\n+\n+![List](../../../assets/step17/img-15.png \"List of operations\")\n+\n+On the main part of the view, you should see “Last day overview” panel.\n+\n+![Overview](../../../assets/step17/img-16.png \"Last day overview\")\n+\n+As you can see, all operations we ran are listed there and no error occurred.\n+\n+![Request Rate](../../../assets/step17/img-17.png \"Request Rate Over Time\")\n+\n+Next section shows the Requests Per Minute (rpm) metric over time. It’s useful to understand which operations are sent more often than others.\n+\n+![Request 1](../../../assets/step17/img-18.png \"Request Latency Over time\")\n+![Request 2](../../../assets/step17/img-19.png \"Request Latency Distribution\")\n+\n+Last two panels are there to understand at what number of requests the latency increases and to show the correlation between them. We see a distribution of the processing time (the horizontal axis) and the number of operations. It also has p50, p75, p90 and p99 marks on it.\ndiff --git a/.tortilla/manuals/templates/step3.tmpl b/.tortilla/manuals/templates/step3.tmpl\nindex bac6af8..793c0f5 100644\n--- a/.tortilla/manuals/templates/step3.tmpl\n+++ b/.tortilla/manuals/templates/step3.tmpl\n@@ -112,9 +112,30 @@ We can use the\n         `$ curl localhost:4000/_ping`\n\n command to send a request to the server and we should get a \"pong\", assuming that the server available on that URL.\n+\n+**Code formatting**\n+\n+Just like we talked in the first chapter, some developers write code in a different style than others and since we want to make it consistent, we're going to use **Prettier**.\n+\n+    $ yarn add -D prettier\n+\n+We're going to define a npm script called `format`, few styling rules and we're also going to ignore *node_modules*:\n+\n+{{{ diffStep \"1.4\" module=\"server\" files=\"package.json, .prettierrc.yml, .prettierignore\" }}}\n+\n+Now let's run:\n+\n+    $ yarn format\n+\n+Prettier should format your code:\n+\n+{{{ diffStep \"1.4\" module=\"server\" files=\"index.ts\" }}}\n+\n+> Remember to run `yarn prettier` before you comit your changes!\n+\n The `GET /chats` should be implemented similarly, only the response is different. Instead of returning \"pong\" we will return the data-mock for our chats:\n\n-{{{ diffStep \"1.4\" module=\"server\" files=\"index.ts, db.ts\" }}}\n+{{{ diffStep \"1.5\" module=\"server\" files=\"index.ts, db.ts\" }}}\n\n TODO: Mention `_req`\n\n@@ -137,7 +158,7 @@ and its Typescript types:\n\n     $ yarn add --dev @types/cors\n\n-{{{ diffStep \"1.4\" module=\"server\" files=\"index.ts\" }}}\n+{{{ diffStep \"1.6\" module=\"server\" files=\"index.ts\" }}}\n\n The server is now ready to use!\n\ndiff --git a/assets/step17/img-01.png b/assets/step17/img-01.png\nnew file mode 100644\nindex 0000000..1eef108\nBinary files /dev/null and b/assets/step17/img-01.png differ\ndiff --git a/assets/step17/img-02.png b/assets/step17/img-02.png\nnew file mode 100644\nindex 0000000..f4fda88\nBinary files /dev/null and b/assets/step17/img-02.png differ\ndiff --git a/assets/step17/img-03.png b/assets/step17/img-03.png\nnew file mode 100644\nindex 0000000..e44720e\nBinary files /dev/null and b/assets/step17/img-03.png differ\ndiff --git a/assets/step17/img-04.png b/assets/step17/img-04.png\nnew file mode 100644\nindex 0000000..5348f1d\nBinary files /dev/null and b/assets/step17/img-04.png differ\ndiff --git a/assets/step17/img-05.png b/assets/step17/img-05.png\nnew file mode 100644\nindex 0000000..0e3f415\nBinary files /dev/null and b/assets/step17/img-05.png differ\ndiff --git a/assets/step17/img-06.png b/assets/step17/img-06.png\nnew file mode 100644\nindex 0000000..3de7403\nBinary files /dev/null and b/assets/step17/img-06.png differ\ndiff --git a/assets/step17/img-07.png b/assets/step17/img-07.png\nnew file mode 100644\nindex 0000000..9e78e34\nBinary files /dev/null and b/assets/step17/img-07.png differ\ndiff --git a/assets/step17/img-08.png b/assets/step17/img-08.png\nnew file mode 100644\nindex 0000000..cf31e14\nBinary files /dev/null and b/assets/step17/img-08.png differ\ndiff --git a/assets/step17/img-09.png b/assets/step17/img-09.png\nnew file mode 100644\nindex 0000000..a7e0cd9\nBinary files /dev/null and b/assets/step17/img-09.png differ\ndiff --git a/assets/step17/img-10.png b/assets/step17/img-10.png\nnew file mode 100644\nindex 0000000..5b53c72\nBinary files /dev/null and b/assets/step17/img-10.png differ\ndiff --git a/assets/step17/img-11.png b/assets/step17/img-11.png\nnew file mode 100644\nindex 0000000..3de262c\nBinary files /dev/null and b/assets/step17/img-11.png differ\ndiff --git a/assets/step17/img-12.png b/assets/step17/img-12.png\nnew file mode 100644\nindex 0000000..cfda6aa\nBinary files /dev/null and b/assets/step17/img-12.png differ\ndiff --git a/assets/step17/img-13.png b/assets/step17/img-13.png\nnew file mode 100644\nindex 0000000..4a09e7e\nBinary files /dev/null and b/assets/step17/img-13.png differ\ndiff --git a/assets/step17/img-14.png b/assets/step17/img-14.png\nnew file mode 100644\nindex 0000000..b90083b\nBinary files /dev/null and b/assets/step17/img-14.png differ\ndiff --git a/assets/step17/img-15.png b/assets/step17/img-15.png\nnew file mode 100644\nindex 0000000..476d6df\nBinary files /dev/null and b/assets/step17/img-15.png differ\ndiff --git a/assets/step17/img-16.png b/assets/step17/img-16.png\nnew file mode 100644\nindex 0000000..bc22bc5\nBinary files /dev/null and b/assets/step17/img-16.png differ\ndiff --git a/assets/step17/img-17.png b/assets/step17/img-17.png\nnew file mode 100644\nindex 0000000..9833904\nBinary files /dev/null and b/assets/step17/img-17.png differ\ndiff --git a/assets/step17/img-18.png b/assets/step17/img-18.png\nnew file mode 100644\nindex 0000000..81bc4c6\nBinary files /dev/null and b/assets/step17/img-18.png differ\ndiff --git a/assets/step17/img-19.png b/assets/step17/img-19.png\nnew file mode 100644\nindex 0000000..bd991ab\nBinary files /dev/null and b/assets/step17/img-19.png differ\ndiff --git a/client/.circleci/config.yml b/client/.circleci/config.yml\nnew file mode 100644\nindex 0000000..47d16b1\n--- /dev/null\n+++ b/client/.circleci/config.yml\n@@ -0,0 +1,31 @@\n+version: 2\n+jobs:\n+  build:\n+    working_directory: ~/app/\n+    docker:\n+      - image: circleci/node:12.4.0\n+    steps:\n+      - checkout\n+      - restore_cache:\n+          name: Restore Yarn Package Cache\n+          keys:\n+            - yarn-packages-{{ checksum \"package.json\" }}\n+      - run:\n+          name: Clone Server\n+          command: git clone https://github.com/Urigo/WhatsApp-Clone-Server.git --branch master-step14 --single-branch ../Whatsapp-Clone-Server\n+      - run:\n+          name: Install Dependencies\n+          command: yarn\n+      - run:\n+          name: Build\n+          command: yarn build\n+      - run:\n+          name: Test\n+          command: yarn test\n+      - store_test_results:\n+          path: test-results\n+      - save_cache:\n+          name: Save Yarn Package Cache\n+          key: yarn-packages-{{ checksum \"package.json\" }}\n+          paths:\n+            - ~/.cache/yarn\ndiff --git a/client/.prettierignore b/client/.prettierignore\nnew file mode 100644\nindex 0000000..b512c09\n--- /dev/null\n+++ b/client/.prettierignore\n@@ -0,0 +1 @@\n+node_modules\n\\ No newline at end of file\ndiff --git a/client/.prettierrc.yml b/client/.prettierrc.yml\nnew file mode 100644\nindex 0000000..137e486\n--- /dev/null\n+++ b/client/.prettierrc.yml\n@@ -0,0 +1,4 @@\n+trailingComma: 'es5'\n+tabWidth: 2\n+singleQuote: true\n+jsxBracketSameLine: true\ndiff --git a/client/codegen.yml b/client/codegen.yml\nindex 7faedfa..a7ba0a4 100644\n--- a/client/codegen.yml\n+++ b/client/codegen.yml\n@@ -1,9 +1,10 @@\n-schema: ../Whatsapp-Clone-Server/schema/typeDefs.graphql\n+schema: ../Whatsapp-Clone-Server/modules/*/*.ts\n documents:\n   - ./src/components/**/*.tsx\n   - ./src/graphql/fragments/**/*.ts\n   - ./src/graphql/queries/**/*.ts\n   - ./src/graphql/subscriptions/**/*.ts\n+  - ./src/graphql/mutations/**/*.ts\n overwrite: true\n generates:\n   ./src/graphql/types.tsx:\ndiff --git a/client/package.json b/client/package.json\nindex f1093db..0f24e82 100644\n--- a/client/package.json\n+++ b/client/package.json\n@@ -2,50 +2,58 @@\n   \"name\": \"whatsapp-clone-client\",\n   \"version\": \"0.1.0\",\n   \"private\": true,\n+  \"repository\": {\n+    \"type\": \"git\",\n+    \"url\": \"https://github.com/Urigo/WhatsApp-Clone-Client-React.git\"\n+  },\n   \"dependencies\": {\n-    \"@graphql-codegen/add\": \"1.2.0\",\n-    \"@graphql-codegen/cli\": \"1.2.0\",\n-    \"@graphql-codegen/typescript\": \"1.2.0\",\n-    \"@graphql-codegen/typescript-operations\": \"1.2.0\",\n-    \"@graphql-codegen/typescript-react-apollo\": \"1.2.0\",\n-    \"@material-ui/core\": \"3.9.3\",\n-    \"@material-ui/icons\": \"3.0.2\",\n+    \"@graphql-codegen/add\": \"1.2.1\",\n+    \"@graphql-codegen/cli\": \"1.2.1\",\n+    \"@graphql-codegen/typescript\": \"1.2.1\",\n+    \"@graphql-codegen/typescript-operations\": \"1.2.1\",\n+    \"@graphql-codegen/typescript-react-apollo\": \"1.2.1\",\n+    \"@material-ui/core\": \"4.1.1\",\n+    \"@material-ui/icons\": \"4.2.0\",\n     \"@types/history\": \"4.7.2\",\n-    \"@types/jest\": \"24.0.13\",\n+    \"@types/jest\": \"24.0.15\",\n     \"@types/material-ui\": \"0.21.6\",\n-    \"@types/node\": \"12.0.1\",\n-    \"@types/react\": \"16.8.17\",\n+    \"@types/node\": \"12.0.8\",\n+    \"@types/react\": \"16.8.20\",\n     \"@types/react-dom\": \"16.8.4\",\n-    \"@types/react-router-dom\": \"4.3.3\",\n-    \"@types/styled-components\": \"4.1.14\",\n-    \"apollo-cache-inmemory\": \"1.5.1\",\n-    \"apollo-client\": \"2.5.1\",\n-    \"apollo-link\": \"1.2.11\",\n-    \"apollo-link-http\": \"1.5.14\",\n+    \"@types/react-router-dom\": \"4.3.4\",\n+    \"@types/styled-components\": \"4.1.16\",\n+    \"apollo-cache-inmemory\": \"1.6.2\",\n+    \"apollo-client\": \"2.6.2\",\n+    \"apollo-link\": \"1.2.12\",\n+    \"apollo-link-http\": \"1.5.15\",\n     \"apollo-link-mock\": \"1.0.1\",\n     \"graphql\": \"14.3.1\",\n-    \"apollo-link-ws\": \"1.0.17\",\n-    \"apollo-utilities\": \"1.2.1\",\n+    \"apollo-link-ws\": \"1.0.18\",\n+    \"apollo-utilities\": \"1.3.2\",\n+    \"date-fns\": \"1.30.1\",\n     \"graphql-tag\": \"2.10.1\",\n     \"history\": \"4.9.0\",\n-    \"moment\": \"2.24.0\",\n+    \"prettier\": \"1.18.2\",\n     \"react\": \"16.8.6\",\n     \"react-apollo\": \"2.5.6\",\n     \"react-apollo-hooks\": \"0.4.5\",\n     \"react-dom\": \"16.8.6\",\n-    \"react-router-dom\": \"5.0.0\",\n+    \"react-router-dom\": \"5.0.1\",\n     \"react-router-transition\": \"1.3.0\",\n     \"react-scripts\": \"3.0.1\",\n-    \"styled-components\": \"4.2.0\",\n+    \"styled-components\": \"4.3.1\",\n     \"subscriptions-transport-ws\": \"0.9.16\",\n-    \"typescript\": \"3.4.5\"\n+    \"typescript\": \"3.5.2\"\n   },\n   \"scripts\": {\n+    \"prebuild\": \"yarn codegen\",\n     \"start\": \"react-scripts start\",\n     \"build\": \"react-scripts build\",\n-    \"test\": \"react-scripts test\",\n+    \"test\": \"TZ=\\\"Asia/Jerusalem\\\" react-scripts test\",\n     \"eject\": \"react-scripts eject\",\n-    \"codegen\": \"gql-gen\"\n+    \"codegen\": \"gql-gen\",\n+    \"format\": \"prettier '**/*.{ts,tsx,css,graphql}' --write\",\n+    \"size\": \"source-map-explorer 'build/static/js/*.js'\"\n   },\n   \"eslintConfig\": {\n     \"extends\": \"react-app\"\n@@ -63,8 +71,9 @@\n     ]\n   },\n   \"devDependencies\": {\n-    \"jest-dom\": \"3.2.1\",\n+    \"jest-dom\": \"3.5.0\",\n     \"jest-fetch-mock\": \"2.1.2\",\n-    \"react-testing-library\": \"7.0.0\"\n+    \"@testing-library/react\": \"8.0.1\",\n+    \"source-map-explorer\": \"2.0.0\"\n   }\n-}\n+}\n\\ No newline at end of file\ndiff --git a/client/public/chat-background.jpg b/client/public/assets/chat-background.jpg\nsimilarity index 100%\nrename from client/public/chat-background.jpg\nrename to client/public/assets/chat-background.jpg\ndiff --git a/client/public/message-mine.png b/client/public/assets/message-mine.png\nsimilarity index 100%\nrename from client/public/message-mine.png\nrename to client/public/assets/message-mine.png\ndiff --git a/client/public/message-other.png b/client/public/assets/message-other.png\nsimilarity index 100%\nrename from client/public/message-other.png\nrename to client/public/assets/message-other.png\ndiff --git a/client/public/whatsapp-icon.png b/client/public/assets/whatsapp-icon.png\nsimilarity index 100%\nrename from client/public/whatsapp-icon.png\nrename to client/public/assets/whatsapp-icon.png\ndiff --git a/client/renovate.json b/client/renovate.json\nindex a80069a..bc92851 100644\n--- a/client/renovate.json\n+++ b/client/renovate.json\n@@ -2,7 +2,6 @@\n   \"extends\": [\"config:base\", \":rebaseStalePrs\"],\n   \"baseBranches\": [\n     \"master\",\n-    \"master-root\",\n     \"master-step1\",\n     \"master-step2\",\n     \"master-step3\",\ndiff --git a/client/src/App.test.tsx b/client/src/App.test.tsx\nindex c5d9cc9..dfcfead 100644\n--- a/client/src/App.test.tsx\n+++ b/client/src/App.test.tsx\n@@ -3,15 +3,22 @@ import { ApolloProvider } from 'react-apollo-hooks';\n import ReactDOM from 'react-dom';\n import App from './App';\n import { mockApolloClient } from './test-helpers';\n+import * as subscriptions from './graphql/subscriptions';\n\n it('renders without crashing', () => {\n-  const client = mockApolloClient();\n+  const client = mockApolloClient([\n+    {\n+      request: { query: subscriptions.messageAdded },\n+      result: { data: {} }\n+    }\n+  ]);\n   const div = document.createElement('div');\n\n   ReactDOM.render(\n     <ApolloProvider client={client}>\n       <App />\n-    </ApolloProvider>\n-  , div);\n+    </ApolloProvider>,\n+    div\n+  );\n   ReactDOM.unmountComponentAtNode(div);\n });\ndiff --git a/client/src/App.tsx b/client/src/App.tsx\nindex 85131f7..5ddba0c 100644\n--- a/client/src/App.tsx\n+++ b/client/src/App.tsx\n@@ -1,5 +1,10 @@\n import React from 'react';\n-import { BrowserRouter, Route, Redirect, RouteComponentProps } from 'react-router-dom';\n+import {\n+  BrowserRouter,\n+  Route,\n+  Redirect,\n+  RouteComponentProps,\n+} from 'react-router-dom';\n import AuthScreen from './components/AuthScreen';\n import ChatRoomScreen from './components/ChatRoomScreen';\n import ChatsListScreen from './components/ChatsListScreen';\n@@ -10,13 +15,18 @@ import { withAuth } from './services/auth.service';\n const App: React.FC = () => (\n   <BrowserRouter>\n     <AnimatedSwitch>\n-      <Route exact path=\"/sign-in\" component={AuthScreen} />\n+      <Route exact path=\"/sign-(in|up)\" component={AuthScreen} />\n       <Route exact path=\"/chats\" component={withAuth(ChatsListScreen)} />\n\n-      <Route exact path=\"/chats/:chatId\" component={withAuth(\n-        ({ match, history }: RouteComponentProps<{ chatId: string }>) =>\n-        (<ChatRoomScreen chatId={match.params.chatId} history={history} />)\n-      )} />\n+      <Route\n+        exact\n+        path=\"/chats/:chatId\"\n+        component={withAuth(\n+          ({ match, history }: RouteComponentProps<{ chatId: string }>) => (\n+            <ChatRoomScreen chatId={match.params.chatId} history={history} />\n+          )\n+        )}\n+      />\n\n       <Route exact path=\"/new-chat\" component={withAuth(ChatCreationScreen)} />\n     </AnimatedSwitch>\n@@ -24,8 +34,6 @@ const App: React.FC = () => (\n   </BrowserRouter>\n );\n\n-const redirectToChats = () => (\n-  <Redirect to=\"/chats\" />\n-);\n+const redirectToChats = () => <Redirect to=\"/chats\" />;\n\n-export default App;\n\\ No newline at end of file\n+export default App;\ndiff --git a/client/src/client.ts b/client/src/client.ts\nindex 8f5217f..052fc11 100644\n--- a/client/src/client.ts\n+++ b/client/src/client.ts\n@@ -25,12 +25,10 @@ const terminatingLink = split(\n   ({ query }) => {\n     const { kind, operation } = getMainDefinition(query);\n     // If this is a subscription query, use wsLink, otherwise use httpLink\n-    return (\n-      kind === 'OperationDefinition' && operation === 'subscription'\n-    );\n+    return kind === 'OperationDefinition' && operation === 'subscription';\n   },\n   wsLink,\n-  httpLink,\n+  httpLink\n );\n\n const link = ApolloLink.from([terminatingLink]);\ndiff --git a/client/src/components/AnimatedSwitch.tsx b/client/src/components/AnimatedSwitch.tsx\nindex c1f1cbc..8fa5b13 100644\n--- a/client/src/components/AnimatedSwitch.tsx\n+++ b/client/src/components/AnimatedSwitch.tsx\n@@ -3,7 +3,8 @@ import { AnimatedSwitch, spring } from 'react-router-transition';\n import styled from 'styled-components';\n\n // A workaround to make test pass\n-const SwitchComponent = process.env.NODE_ENV === 'test' ? Switch : AnimatedSwitch;\n+const SwitchComponent =\n+  process.env.NODE_ENV === 'test' ? Switch : AnimatedSwitch;\n\n const glide = (val: number) =>\n   spring(val, {\n@@ -11,11 +12,11 @@ const glide = (val: number) =>\n     damping: 24,\n   });\n\n-const mapStyles = (styles :any) => ({\n+const mapStyles = (styles: any) => ({\n   transform: `translateX(${styles.offset}%)`,\n });\n\n-const MyAnimatedSwitch =  styled(SwitchComponent).attrs(() => ({\n+const MyAnimatedSwitch = styled(SwitchComponent).attrs(() => ({\n   atEnter: { offset: 100 },\n   atLeave: { offset: glide(-100) },\n   atActive: { offset: glide(0) },\n@@ -32,6 +33,6 @@ const MyAnimatedSwitch =  styled(SwitchComponent).attrs(() => ({\n     height: 100vh;\n     width: 100vw;\n   }\n-`\n+`;\n\n export default MyAnimatedSwitch;\ndiff --git a/client/src/components/AuthScreen/SignInForm.test.tsx b/client/src/components/AuthScreen/SignInForm.test.tsx\nindex da27593..cf13651 100644\n--- a/client/src/components/AuthScreen/SignInForm.test.tsx\n+++ b/client/src/components/AuthScreen/SignInForm.test.tsx\n@@ -1,81 +1,163 @@\n import { createMemoryHistory } from 'history';\n import React from 'react';\n-import { cleanup, render, fireEvent, wait, waitForElement } from 'react-testing-library';\n+import { ApolloProvider } from 'react-apollo-hooks';\n+import { act, cleanup, render, fireEvent, wait, waitForElement } from '@testing-library/react';\n import SignInForm from './SignInForm';\n+import { SignInDocument } from '../../graphql/types';\n+import { mockApolloClient } from '../../test-helpers';\n\n describe('SignInForm', () => {\n   afterEach(cleanup);\n-  afterEach(() => fetch.resetMocks());\n\n   it('enables sign-in button when filled in', async () => {\n     const history = createMemoryHistory();\n-\n-    {\n-      const { container, getByTestId } = render(<SignInForm history={history} />);\n-      const usernameInput = getByTestId('username-input').querySelector('input');\n-      const passwordInput = getByTestId('password-input').querySelector('input');\n-      const signInButton = getByTestId('sign-in-button') as HTMLButtonElement;\n-\n-      expect(signInButton.disabled).toEqual(true);\n-\n+    const client = mockApolloClient();\n+\n+    let getByTestId: any = null;\n+\n+    act(() => {\n+      getByTestId = render(\n+        <ApolloProvider client={client}>\n+          <SignInForm history={history} />\n+        </ApolloProvider>\n+      ).getByTestId;\n+    });\n+\n+    const signInButton = await waitForElement(() =>\n+      getByTestId('sign-in-button') as HTMLButtonElement\n+    );\n+    const usernameInput = await waitForElement(() =>\n+      getByTestId('username-input').querySelector('input')\n+    );\n+    const passwordInput = await waitForElement(() =>\n+      getByTestId('password-input').querySelector('input')\n+    );\n+\n+    expect(signInButton.disabled).toEqual(true);\n+\n+    act(() => {\n       fireEvent.change(usernameInput, { target: { value: 'username' } });\n       fireEvent.change(passwordInput, { target: { value: 'password' } });\n+    });\n\n-      await waitForElement(() => usernameInput);\n-      await waitForElement(() => passwordInput);\n-\n-      expect(signInButton.disabled).toEqual(false);\n-    }\n+    await wait(() =>\n+      expect(signInButton.disabled).toEqual(false)\n+    )\n   });\n\n   it('prints server error if input was wrong', async () => {\n     const history = createMemoryHistory();\n\n-    fetchMock.mockRejectOnce(new Error('sign-in failed'));\n-\n-    {\n-      const { container, getByTestId } = render(<SignInForm history={history} />);\n-      const usernameInput = getByTestId('username-input').querySelector('input');\n-      const passwordInput = getByTestId('password-input').querySelector('input');\n-      const signInButton = getByTestId('sign-in-button') as HTMLButtonElement;\n-      const errorMessage = getByTestId('error-message');\n-\n+    const client = mockApolloClient([\n+      {\n+        request: {\n+          query: SignInDocument,\n+          variables: {\n+            username: 'username',\n+            password: 'password'\n+          }\n+        },\n+        get result() { throw Error('sign-in failed') },\n+      }\n+    ]);\n+\n+    let getByTestId: any = null;\n+\n+    act(() => {\n+      getByTestId = render(\n+        <ApolloProvider client={client}>\n+          <SignInForm history={history} />\n+        </ApolloProvider>\n+      ).getByTestId;\n+    });\n+\n+    const signInButton = await waitForElement(() =>\n+      getByTestId('sign-in-button') as HTMLButtonElement\n+    );\n+    const usernameInput = await waitForElement(() =>\n+      getByTestId('username-input').querySelector('input')\n+    );\n+    const passwordInput = await waitForElement(() =>\n+      getByTestId('password-input').querySelector('input')\n+    );\n+\n+    act(() => {\n       fireEvent.change(usernameInput, { target: { value: 'username' } });\n       fireEvent.change(passwordInput, { target: { value: 'password' } });\n+    });\n+\n+    await wait(() =>\n+      expect(usernameInput.value).toEqual('username')\n+    );\n\n-      await waitForElement(() => usernameInput);\n-      await waitForElement(() => passwordInput);\n+    await wait(() =>\n+      expect(passwordInput.value).toEqual('password')\n+    );\n\n+    act(() => {\n       fireEvent.click(signInButton);\n+    });\n\n-      await waitForElement(() => errorMessage);\n+    const errorMessage = await waitForElement(() =>\n+      getByTestId('error-message')\n+    );\n\n-      expect(errorMessage.innerHTML).toEqual('sign-in failed');\n-    }\n+    expect(errorMessage.innerHTML).toContain('sign-in failed');\n   });\n\n   it('navigates to /chats if everything went right', async () => {\n     const history = createMemoryHistory();\n\n-    fetchMock.mockResponseOnce('success');\n-\n-    {\n-      const { container, getByTestId } = render(<SignInForm history={history} />);\n-      const usernameInput = getByTestId('username-input').querySelector('input');\n-      const passwordInput = getByTestId('password-input').querySelector('input');\n-      const signInButton = getByTestId('sign-in-button') as HTMLButtonElement;\n-\n+    const client = mockApolloClient([\n+      {\n+        request: {\n+          query: SignInDocument,\n+          variables: {\n+            username: 'username',\n+            password: 'password'\n+          }\n+        },\n+        result: { data: {} }\n+      }\n+    ]);\n+\n+    let getByTestId: any = null;\n+\n+    act(() => {\n+      getByTestId = render(\n+        <ApolloProvider client={client}>\n+          <SignInForm history={history} />\n+        </ApolloProvider>\n+      ).getByTestId;\n+    })\n+\n+    const usernameInput = await waitForElement(() =>\n+      getByTestId('username-input').querySelector('input')\n+    );\n+    const passwordInput = await waitForElement(() =>\n+      getByTestId('password-input').querySelector('input')\n+    );\n+    const signInButton = await waitForElement(() =>\n+      getByTestId('sign-in-button') as HTMLButtonElement\n+    );\n+\n+    act(() => {\n       fireEvent.change(usernameInput, { target: { value: 'username' } });\n       fireEvent.change(passwordInput, { target: { value: 'password' } });\n+    });\n+\n+    await wait(() =>\n+      expect(usernameInput.value).toEqual('username')\n+    );\n\n-      await waitForElement(() => usernameInput);\n-      await waitForElement(() => passwordInput);\n+    await wait(() =>\n+      expect(passwordInput.value).toEqual('password')\n+    );\n\n+    act(() => {\n       fireEvent.click(signInButton);\n+    });\n\n-      await wait(() =>\n-        expect(history.location.pathname).toEqual('/chats')\n-      );\n-    }\n+    await wait(() => expect(history.location.pathname).toEqual('/chats'));\n   });\n-});\n+});\n\\ No newline at end of file\ndiff --git a/client/src/components/AuthScreen/SignInForm.tsx b/client/src/components/AuthScreen/SignInForm.tsx\nindex fa21d64..f5e2152 100644\n--- a/client/src/components/AuthScreen/SignInForm.tsx\n+++ b/client/src/components/AuthScreen/SignInForm.tsx\n@@ -1,6 +1,6 @@\n import React from 'react';\n import { useCallback, useState } from 'react';\n-import { signIn } from '../../services/auth.service';\n+import { useSignIn } from '../../services/auth.service';\n import {\n   SignForm,\n   ActualForm,\n@@ -16,6 +16,7 @@ const SignInForm: React.FC<RouteComponentProps<any>> = ({ history }) => {\n   const [username, setUsername] = useState('');\n   const [password, setPassword] = useState('');\n   const [error, setError] = useState('');\n+  const signIn = useSignIn();\n\n   const onUsernameChange = useCallback(({ target }) => {\n     setError('');\n@@ -32,14 +33,14 @@ const SignInForm: React.FC<RouteComponentProps<any>> = ({ history }) => {\n   }, [username, password]);\n\n   const handleSignIn = useCallback(() => {\n-    signIn({ username, password })\n+    signIn({ variables: { username, password } })\n       .then(() => {\n-        history.replace('/chats')\n+        history.replace('/chats');\n       })\n       .catch(error => {\n-        setError(error.message || error)\n+        setError(error.message || error);\n       });\n-  }, [username, password, history]);\n+  }, [username, password, history, signIn]);\n\n   return (\n     <SignForm>\n@@ -70,8 +71,7 @@ const SignInForm: React.FC<RouteComponentProps<any>> = ({ history }) => {\n           color=\"secondary\"\n           variant=\"contained\"\n           disabled={!maySignIn()}\n-          onClick={handleSignIn}\n-        >\n+          onClick={handleSignIn}>\n           Sign in\n         </Button>\n         <ErrorMessage data-testid=\"error-message\">{error}</ErrorMessage>\ndiff --git a/client/src/components/AuthScreen/SignUpForm.test.tsx b/client/src/components/AuthScreen/SignUpForm.test.tsx\nindex 669e45d..6fcdd13 100644\n--- a/client/src/components/AuthScreen/SignUpForm.test.tsx\n+++ b/client/src/components/AuthScreen/SignUpForm.test.tsx\n@@ -1,99 +1,225 @@\n import { createMemoryHistory } from 'history';\n import React from 'react';\n-import { cleanup, render, fireEvent, wait, waitForElement } from 'react-testing-library';\n+import { ApolloProvider } from 'react-apollo-hooks';\n+import { act, cleanup, render, fireEvent, wait, waitForElement } from '@testing-library/react';\n import SignUpForm from './SignUpForm';\n+import { SignUpDocument } from '../../graphql/types';\n+import { mockApolloClient } from '../../test-helpers';\n\n describe('SignUpForm', () => {\n   afterEach(cleanup);\n-  afterEach(() => fetch.resetMocks());\n\n   it('enables sign-up button when filled in', async () => {\n     const history = createMemoryHistory();\n-\n-    {\n-      const { container, getByTestId } = render(<SignUpForm history={history} />);\n-      const nameInput = getByTestId('name-input').querySelector('input');\n-      const usernameInput = getByTestId('username-input').querySelector('input');\n-      const passwordInput = getByTestId('password-input').querySelector('input');\n-      const passwordConfirmInput = getByTestId('password-confirm-input').querySelector('input');\n-      const signUpButton = getByTestId('sign-up-button') as HTMLButtonElement;\n-\n-      expect(signUpButton.disabled).toEqual(true);\n-\n+    const client = mockApolloClient();\n+\n+    let getByTestId: any = null;\n+\n+    act(() => {\n+      getByTestId = render(\n+        <ApolloProvider client={client}>\n+          <SignUpForm history={history} />\n+        </ApolloProvider>\n+      ).getByTestId;\n+    });\n+\n+    const nameInput = await waitForElement(() =>\n+      getByTestId('name-input').querySelector('input')\n+    );\n+    const usernameInput = await waitForElement(() =>\n+      getByTestId('username-input').querySelector('input')\n+    );\n+    const passwordInput = await waitForElement(() =>\n+      getByTestId('password-input').querySelector('input')\n+    );\n+    const passwordConfirmInput = await waitForElement(() =>\n+      getByTestId('password-confirm-input').querySelector('input')\n+    );\n+    const signUpButton = await waitForElement(() =>\n+      getByTestId('sign-up-button') as HTMLButtonElement\n+    );\n+\n+    expect(signUpButton.disabled).toEqual(true);\n+\n+    act(() => {\n       fireEvent.change(nameInput, { target: { value: 'User Name' } });\n       fireEvent.change(usernameInput, { target: { value: 'username' } });\n       fireEvent.change(passwordInput, { target: { value: 'password' } });\n       fireEvent.change(passwordConfirmInput, { target: { value: 'password' } });\n+    });\n+\n+    await wait(() =>\n+      expect(nameInput.value).toEqual('User Name')\n+    );\n\n-      await waitForElement(() => nameInput);\n-      await waitForElement(() => usernameInput);\n-      await waitForElement(() => passwordInput);\n-      await waitForElement(() => passwordConfirmInput);\n+    await wait(() =>\n+      expect(usernameInput.value).toEqual('username')\n+    );\n\n-      expect(signUpButton.disabled).toEqual(false);\n-    }\n+    await wait(() =>\n+      expect(passwordInput.value).toEqual('password')\n+    );\n+\n+    await wait(() =>\n+      expect(passwordConfirmInput.value).toEqual('password')\n+    );\n+\n+    await wait(() =>\n+      expect(signUpButton.disabled).toEqual(false)\n+    )\n   });\n\n   it('prints server error if input was wrong', async () => {\n     const history = createMemoryHistory();\n\n-    fetchMock.mockRejectOnce(new Error('sign-up failed'));\n-\n-    {\n-      const { container, getByTestId } = render(<SignUpForm history={history} />);\n-      const nameInput = getByTestId('name-input').querySelector('input');\n-      const usernameInput = getByTestId('username-input').querySelector('input');\n-      const passwordInput = getByTestId('password-input').querySelector('input');\n-      const passwordConfirmInput = getByTestId('password-confirm-input').querySelector('input');\n-      const signUpButton = getByTestId('sign-up-button') as HTMLButtonElement;\n-      const errorMessage = getByTestId('error-message');\n-\n+    const client = mockApolloClient([\n+      {\n+        request: {\n+          query: SignUpDocument,\n+          variables: {\n+            name: 'User Name',\n+            username: 'username',\n+            password: 'password',\n+            passwordConfirm: 'password'\n+          }\n+        },\n+        get result() { throw Error('sign-up failed') }\n+      }\n+    ]);\n+\n+    let getByTestId: any = null;\n+\n+    act(() => {\n+      getByTestId = render(\n+        <ApolloProvider client={client}>\n+          <SignUpForm history={history} />\n+        </ApolloProvider>\n+      ).getByTestId;\n+    });\n+\n+    const nameInput = await waitForElement(() =>\n+      getByTestId('name-input').querySelector('input')\n+    );\n+    const usernameInput = await waitForElement(() =>\n+      getByTestId('username-input').querySelector('input')\n+    );\n+    const passwordInput = await waitForElement(() =>\n+      getByTestId('password-input').querySelector('input')\n+    );\n+    const passwordConfirmInput = await waitForElement(() =>\n+      getByTestId('password-confirm-input').querySelector('input')\n+    );\n+    const signUpButton = await waitForElement(() =>\n+      getByTestId('sign-up-button') as HTMLButtonElement\n+    );\n+\n+    act(() => {\n       fireEvent.change(nameInput, { target: { value: 'User Name' } });\n       fireEvent.change(usernameInput, { target: { value: 'username' } });\n       fireEvent.change(passwordInput, { target: { value: 'password' } });\n       fireEvent.change(passwordConfirmInput, { target: { value: 'password' } });\n+    });\n\n-      await waitForElement(() => nameInput);\n-      await waitForElement(() => usernameInput);\n-      await waitForElement(() => passwordInput);\n-      await waitForElement(() => passwordConfirmInput);\n+    await wait(() =>\n+      expect(nameInput.value).toEqual('User Name')\n+    );\n\n+    await wait(() =>\n+      expect(usernameInput.value).toEqual('username')\n+    );\n+\n+    await wait(() =>\n+      expect(passwordInput.value).toEqual('password')\n+    );\n+\n+    await wait(() =>\n+      expect(passwordConfirmInput.value).toEqual('password')\n+    );\n+\n+    act(() => {\n       fireEvent.click(signUpButton);\n+    });\n\n-      await waitForElement(() => errorMessage);\n+    const errorMessage = await waitForElement(() =>\n+      getByTestId('error-message')\n+    );\n\n-      expect(errorMessage.innerHTML).toEqual('sign-up failed');\n-    }\n+    expect(errorMessage.innerHTML).toContain('sign-up failed');\n   });\n\n   it('navigates to /sign-in if everything went right', async () => {\n     const history = createMemoryHistory();\n\n-    fetchMock.mockResponseOnce('success');\n-\n-    {\n-      const { container, getByTestId } = render(<SignUpForm history={history} />);\n-      const nameInput = getByTestId('name-input').querySelector('input');\n-      const usernameInput = getByTestId('username-input').querySelector('input');\n-      const passwordInput = getByTestId('password-input').querySelector('input');\n-      const passwordConfirmInput = getByTestId('password-confirm-input').querySelector('input');\n-      const signUpButton = getByTestId('sign-up-button') as HTMLButtonElement;\n-\n+    const client = mockApolloClient([\n+      {\n+        request: {\n+          query: SignUpDocument,\n+          variables: {\n+            name: 'User Name',\n+            username: 'username',\n+            password: 'password',\n+            passwordConfirm: 'password'\n+          }\n+        },\n+        result: { data: {} }\n+      }\n+    ]);\n+\n+    let getByTestId: any = null;\n+\n+    act(() => {\n+      getByTestId = render(\n+        <ApolloProvider client={client}>\n+          <SignUpForm history={history} />\n+        </ApolloProvider>\n+      ).getByTestId;\n+    });\n+\n+    const nameInput = await waitForElement(() =>\n+      getByTestId('name-input').querySelector('input')\n+    );\n+    const usernameInput = await waitForElement(() =>\n+      getByTestId('username-input').querySelector('input')\n+    );\n+    const passwordInput = await waitForElement(() =>\n+      getByTestId('password-input').querySelector('input')\n+    );\n+    const passwordConfirmInput = await waitForElement(() =>\n+      getByTestId('password-confirm-input').querySelector('input')\n+    );\n+    const signUpButton = await waitForElement(() =>\n+      getByTestId('sign-up-button') as HTMLButtonElement\n+    );\n+\n+    act(() => {\n       fireEvent.change(nameInput, { target: { value: 'User Name' } });\n       fireEvent.change(usernameInput, { target: { value: 'username' } });\n       fireEvent.change(passwordInput, { target: { value: 'password' } });\n       fireEvent.change(passwordConfirmInput, { target: { value: 'password' } });\n+    });\n+\n+    await wait(() =>\n+      expect(nameInput.value).toEqual('User Name')\n+    );\n+\n+    await wait(() =>\n+      expect(usernameInput.value).toEqual('username')\n+    );\n+\n+    await wait(() =>\n+      expect(passwordInput.value).toEqual('password')\n+    );\n\n-      await waitForElement(() => nameInput);\n-      await waitForElement(() => usernameInput);\n-      await waitForElement(() => passwordInput);\n-      await waitForElement(() => passwordConfirmInput);\n+    await wait(() =>\n+      expect(passwordConfirmInput.value).toEqual('password')\n+    );\n\n+    act(() => {\n       fireEvent.click(signUpButton);\n+    });\n\n-      await wait(() =>\n-        expect(history.location.pathname).toEqual('/sign-in')\n-      );\n-    }\n+    await wait(() =>\n+      expect(history.location.pathname).toEqual('/sign-in')\n+    );\n   });\n-});\n+});\n\\ No newline at end of file\ndiff --git a/client/src/components/AuthScreen/SignUpForm.tsx b/client/src/components/AuthScreen/SignUpForm.tsx\nindex b7fcd69..d02baa9 100644\n--- a/client/src/components/AuthScreen/SignUpForm.tsx\n+++ b/client/src/components/AuthScreen/SignUpForm.tsx\n@@ -1,6 +1,6 @@\n import React from 'react';\n import { useCallback, useState } from 'react';\n-import { signUp } from '../../services/auth.service';\n+import { useSignUp } from '../../services/auth.service';\n import {\n   SignForm,\n   ActualForm,\n@@ -18,6 +18,7 @@ const SignUpForm: React.FC<RouteComponentProps<any>> = ({ history }) => {\n   const [password, setPassword] = useState('');\n   const [passwordConfirm, setPasswordConfirm] = useState('');\n   const [error, setError] = useState('');\n+  const signUp = useSignUp()\n\n   const updateName = useCallback(({ target }) => {\n     setError('');\n@@ -44,14 +45,14 @@ const SignUpForm: React.FC<RouteComponentProps<any>> = ({ history }) => {\n   }, [name, username, password, passwordConfirm]);\n\n   const handleSignUp = useCallback(() => {\n-    signUp({ username, password, passwordConfirm, name })\n+    signUp({ variables: { username, password, passwordConfirm, name } })\n       .then(() => {\n-        history.replace('/sign-in')\n+        history.replace('/sign-in');\n       })\n       .catch(error => {\n-        setError(error.message || error)\n+        setError(error.message || error);\n       });\n-  }, [name, username, password, passwordConfirm, history]);\n+  }, [name, username, password, passwordConfirm, history, signUp]);\n\n   return (\n     <SignForm>\n@@ -62,8 +63,7 @@ const SignUpForm: React.FC<RouteComponentProps<any>> = ({ history }) => {\n             float: 'left',\n             width: 'calc(50% - 10px)',\n             paddingRight: '10px',\n-          }}\n-        >\n+          }}>\n           <TextField\n             data-testid=\"name-input\"\n             label=\"Name\"\n@@ -86,8 +86,7 @@ const SignUpForm: React.FC<RouteComponentProps<any>> = ({ history }) => {\n             float: 'right',\n             width: 'calc(50% - 10px)',\n             paddingLeft: '10px',\n-          }}\n-        >\n+          }}>\n           <TextField\n             data-testid=\"password-input\"\n             label=\"Password\"\n@@ -113,8 +112,7 @@ const SignUpForm: React.FC<RouteComponentProps<any>> = ({ history }) => {\n           color=\"secondary\"\n           variant=\"contained\"\n           disabled={!maySignUp()}\n-          onClick={handleSignUp}\n-        >\n+          onClick={handleSignUp}>\n           Sign up\n         </Button>\n         <ErrorMessage data-testid=\"error-message\">{error}</ErrorMessage>\n@@ -123,4 +121,4 @@ const SignUpForm: React.FC<RouteComponentProps<any>> = ({ history }) => {\n   );\n };\n\n-export default SignUpForm;\n\\ No newline at end of file\n+export default SignUpForm;\ndiff --git a/client/src/components/AuthScreen/form-components.ts b/client/src/components/AuthScreen/form-components.ts\nindex 00c8c9d..db5c185 100644\n--- a/client/src/components/AuthScreen/form-components.ts\n+++ b/client/src/components/AuthScreen/form-components.ts\n@@ -2,28 +2,28 @@ import MaterialButton from '@material-ui/core/Button';\n import MaterialTextField from '@material-ui/core/TextField';\n import styled from 'styled-components';\n\n-export const SignForm = styled.div `\n+export const SignForm = styled.div`\n   height: calc(100% - 265px);\n `;\n\n-export const ActualForm = styled.form `\n+export const ActualForm = styled.form`\n   padding: 20px;\n `;\n\n-export const Section = styled.div `\n+export const Section = styled.div`\n   padding-bottom: 35px;\n `;\n\n-export const Legend = styled.legend `\n+export const Legend = styled.legend`\n   font-weight: bold;\n   color: white;\n `;\n\n-export const Label = styled.label `\n+export const Label = styled.label`\n   color: white !important;\n `;\n\n-export const Input = styled.input `\n+export const Input = styled.input`\n   color: white;\n\n   &::placeholder {\n@@ -31,7 +31,7 @@ export const Input = styled.input `\n   }\n `;\n\n-export const TextField = styled(MaterialTextField) `\n+export const TextField = styled(MaterialTextField)`\n   width: 100%;\n   position: relative;\n\n@@ -52,7 +52,7 @@ export const TextField = styled(MaterialTextField) `\n   }\n ` as typeof MaterialTextField;\n\n-export const Button = styled(MaterialButton) `\n+export const Button = styled(MaterialButton)`\n   width: 100px;\n   display: block !important;\n   margin: auto !important;\n@@ -67,7 +67,7 @@ export const Button = styled(MaterialButton) `\n   }\n ` as typeof MaterialButton;\n\n-export const ErrorMessage = styled.div `\n+export const ErrorMessage = styled.div`\n   position: fixed;\n   color: red;\n   font-size: 15px;\ndiff --git a/client/src/components/AuthScreen/index.tsx b/client/src/components/AuthScreen/index.tsx\nindex c6cdfe0..ed009c8 100644\n--- a/client/src/components/AuthScreen/index.tsx\n+++ b/client/src/components/AuthScreen/index.tsx\n@@ -7,7 +7,7 @@ import SignInForm from './SignInForm';\n import SignUpForm from './SignUpForm';\n import { RouteComponentProps } from 'react-router-dom';\n\n-const Container = styled.div `\n+const Container = styled.div`\n   background: radial-gradient(rgb(34, 65, 67), rgb(17, 48, 50)),\n     url(/assets/chat-background.jpg) no-repeat;\n   background-size: cover;\n@@ -15,11 +15,11 @@ const Container = styled.div `\n   color: white;\n `;\n\n-const Intro = styled.div `\n+const Intro = styled.div`\n   height: 265px;\n `;\n\n-const Icon = styled.img `\n+const Icon = styled.img`\n   width: 125px;\n   height: auto;\n   margin-left: auto;\n@@ -28,14 +28,14 @@ const Icon = styled.img `\n   display: block;\n `;\n\n-const Title = styled.h2 `\n+const Title = styled.h2`\n   width: 100%;\n   text-align: center;\n   color: white;\n `;\n\n // eslint-disable-next-line\n-const Alternative = styled.div `\n+const Alternative = styled.div`\n   position: fixed;\n   bottom: 10px;\n   left: 10px;\n@@ -45,7 +45,10 @@ const Alternative = styled.div `\n   }\n `;\n\n-const AuthScreen: React.FC<RouteComponentProps<any>> = ({ history, location }) => {\n+const AuthScreen: React.FC<RouteComponentProps<any>> = ({\n+  history,\n+  location,\n+}) => {\n   const alternative = useMemo(() => {\n     if (location.pathname === '/sign-in') {\n       const handleSignUp = () => {\n@@ -54,11 +57,11 @@ const AuthScreen: React.FC<RouteComponentProps<any>> = ({ history, location }) =\n\n       return (\n         <Alternative>\n-          Don't have an account yet? <label onClick={handleSignUp}>Sign up!</label>\n+          Don't have an account yet?{' '}\n+          <label onClick={handleSignUp}>Sign up!</label>\n         </Alternative>\n       );\n-    }\n-    else {\n+    } else {\n       const handleSignIn = () => {\n         history.replace('/sign-in');\n       };\n@@ -86,4 +89,4 @@ const AuthScreen: React.FC<RouteComponentProps<any>> = ({ history, location }) =\n   );\n };\n\n-export default AuthScreen;\n\\ No newline at end of file\n+export default AuthScreen;\ndiff --git a/client/src/components/ChatCreationScreen/ChatCreationNavbar.test.tsx b/client/src/components/ChatCreationScreen/ChatCreationNavbar.test.tsx\nindex 0454ed0..5490495 100644\n--- a/client/src/components/ChatCreationScreen/ChatCreationNavbar.test.tsx\n+++ b/client/src/components/ChatCreationScreen/ChatCreationNavbar.test.tsx\n@@ -1,6 +1,6 @@\n import { createMemoryHistory } from 'history';\n import React from 'react';\n-import { cleanup, render, fireEvent, wait } from 'react-testing-library';\n+import { cleanup, render, fireEvent, wait } from '@testing-library/react';\n import ChatCreationNavbar from './ChatCreationNavbar';\n\n describe('ChatCreationNavbar', () => {\n@@ -11,18 +11,16 @@ describe('ChatCreationNavbar', () => {\n\n     history.push('/new-chat');\n\n-    await wait(() =>\n-      expect(history.location.pathname).toEqual('/new-chat')\n-    );\n+    await wait(() => expect(history.location.pathname).toEqual('/new-chat'));\n\n     {\n-      const { container, getByTestId } = render(<ChatCreationNavbar history={history} />);\n+      const { container, getByTestId } = render(\n+        <ChatCreationNavbar history={history} />\n+      );\n\n       fireEvent.click(getByTestId('back-button'));\n\n-      await wait(() =>\n-        expect(history.location.pathname).toEqual('/chats')\n-      );\n+      await wait(() => expect(history.location.pathname).toEqual('/chats'));\n     }\n   });\n });\ndiff --git a/client/src/components/ChatCreationScreen/ChatCreationNavbar.tsx b/client/src/components/ChatCreationScreen/ChatCreationNavbar.tsx\nindex c537475..dfa7f55 100644\n--- a/client/src/components/ChatCreationScreen/ChatCreationNavbar.tsx\n+++ b/client/src/components/ChatCreationScreen/ChatCreationNavbar.tsx\n@@ -5,7 +5,7 @@ import { useCallback } from 'react';\n import styled from 'styled-components';\n import { History } from 'history';\n\n-const Container = styled(Toolbar) `\n+const Container = styled(Toolbar)`\n   display: flex;\n   background-color: var(--primary-bg);\n   color: var(--primary-text);\n@@ -13,19 +13,19 @@ const Container = styled(Toolbar) `\n   line-height: 40px;\n ` as typeof Toolbar;\n\n-const BackButton = styled(Button) `\n+const BackButton = styled(Button)`\n   svg {\n     color: var(--primary-text);\n   }\n ` as typeof Button;\n\n-const Title = styled.div `\n+const Title = styled.div`\n   flex: 1;\n `;\n\n interface ChildComponentProps {\n   history: History;\n-};\n+}\n\n const ChatCreationNavbar: React.FC<ChildComponentProps> = ({ history }) => {\n   const navBack = useCallback(() => {\n@@ -42,5 +42,4 @@ const ChatCreationNavbar: React.FC<ChildComponentProps> = ({ history }) => {\n   );\n };\n\n-\n export default ChatCreationNavbar;\ndiff --git a/client/src/components/ChatCreationScreen/index.tsx b/client/src/components/ChatCreationScreen/index.tsx\nindex 70f8a5a..b244238 100644\n--- a/client/src/components/ChatCreationScreen/index.tsx\n+++ b/client/src/components/ChatCreationScreen/index.tsx\n@@ -10,13 +10,13 @@ import { useAddChatMutation } from '../../graphql/types';\n import { writeChat } from '../../services/cache.service';\n\n // eslint-disable-next-line\n-const Container = styled.div `\n+const Container = styled.div`\n   height: calc(100% - 56px);\n   overflow-y: overlay;\n `;\n\n // eslint-disable-next-line\n-const StyledUsersList = styled(UsersList) `\n+const StyledUsersList = styled(UsersList)`\n   height: calc(100% - 56px);\n `;\n\n@@ -31,36 +31,41 @@ gql`\n\n interface ChildComponentProps {\n   history: History;\n-};\n+}\n\n const ChatCreationScreen: React.FC<ChildComponentProps> = ({ history }) => {\n   const addChat = useAddChatMutation({\n     update: (client, { data: { addChat } }) => {\n       writeChat(client, addChat);\n-    }\n+    },\n   });\n\n-  const onUserPick = useCallback((user) => {\n-    addChat({\n-      optimisticResponse: {\n-        __typename: 'Mutation',\n-        addChat: {\n-          __typename: 'Chat',\n-          id: Math.random().toString(36).substr(2, 9),\n-          name: user.name,\n-          picture: user.picture,\n-          lastMessage: null,\n+  const onUserPick = useCallback(\n+    user => {\n+      addChat({\n+        optimisticResponse: {\n+          __typename: 'Mutation',\n+          addChat: {\n+            __typename: 'Chat',\n+            id: Math.random()\n+              .toString(36)\n+              .substr(2, 9),\n+            name: user.name,\n+            picture: user.picture,\n+            lastMessage: null,\n+          },\n         },\n-      },\n-      variables: {\n-        recipientId: user.id,\n-      },\n-    }).then(({ data }) => {\n-      if (data !== null) {\n-        history.push(`/chats/${data.addChat.id}`);\n-      }\n-    })\n-  }, [addChat, history]);\n+        variables: {\n+          recipientId: user.id,\n+        },\n+      }).then(({ data }) => {\n+        if (data !== null) {\n+          history.push(`/chats/${data.addChat.id}`);\n+        }\n+      });\n+    },\n+    [addChat, history]\n+  );\n\n   return (\n     <div>\ndiff --git a/client/src/components/ChatRoomScreen/ChatNavbar.test.tsx b/client/src/components/ChatRoomScreen/ChatNavbar.test.tsx\nindex 9c61f69..3dacf48 100644\n--- a/client/src/components/ChatRoomScreen/ChatNavbar.test.tsx\n+++ b/client/src/components/ChatRoomScreen/ChatNavbar.test.tsx\n@@ -1,7 +1,7 @@\n import { createMemoryHistory } from 'history';\n import React from 'react';\n import { ApolloProvider } from 'react-apollo-hooks';\n-import { cleanup, render, fireEvent, wait } from 'react-testing-library';\n+import { cleanup, render, fireEvent, wait } from '@testing-library/react';\n import { mockApolloClient } from '../../test-helpers';\n import ChatNavbar from './ChatNavbar';\n import { RemoveChatDocument } from '../../graphql/types';\n@@ -26,9 +26,12 @@ describe('ChatNavbar', () => {\n       );\n\n       expect(getByTestId('chat-name')).toHaveTextContent('Foo Bar');\n-      expect(getByTestId('chat-picture')).toHaveAttribute('src', 'https://localhost:4000/picture.jpg');\n+      expect(getByTestId('chat-picture')).toHaveAttribute(\n+        'src',\n+        'https://localhost:4000/picture.jpg'\n+      );\n     }\n-  })\n+  });\n\n   it('goes back on arrow click', async () => {\n     const client = mockApolloClient();\n@@ -43,9 +46,7 @@ describe('ChatNavbar', () => {\n\n     history.push('/chats/1');\n\n-    await wait(() =>\n-      expect(history.location.pathname).toEqual('/chats/1')\n-    )\n+    await wait(() => expect(history.location.pathname).toEqual('/chats/1'));\n\n     {\n       const { container, getByTestId } = render(\n@@ -56,9 +57,7 @@ describe('ChatNavbar', () => {\n\n       fireEvent.click(getByTestId('back-button'));\n\n-      await wait(() =>\n-        expect(history.location.pathname).toEqual('/chats')\n-      );\n+      await wait(() => expect(history.location.pathname).toEqual('/chats'));\n     }\n   });\n\n@@ -71,9 +70,9 @@ describe('ChatNavbar', () => {\n         },\n         result: {\n           data: {\n-            removeChat: '1'\n-          }\n-        }\n+            removeChat: '1',\n+          },\n+        },\n       },\n     ]);\n\n@@ -87,9 +86,7 @@ describe('ChatNavbar', () => {\n\n     history.push('/chats/1');\n\n-    await wait(() =>\n-      expect(history.location.pathname).toEqual('/chats/1')\n-    );\n+    await wait(() => expect(history.location.pathname).toEqual('/chats/1'));\n\n     {\n       const { container, getByTestId } = render(\n@@ -100,9 +97,7 @@ describe('ChatNavbar', () => {\n\n       fireEvent.click(getByTestId('delete-button'));\n\n-      await wait(() =>\n-        expect(history.location.pathname).toEqual('/chats')\n-      );\n+      await wait(() => expect(history.location.pathname).toEqual('/chats'));\n     }\n-  })\n-});\n\\ No newline at end of file\n+  });\n+});\ndiff --git a/client/src/components/ChatRoomScreen/ChatNavbar.tsx b/client/src/components/ChatRoomScreen/ChatNavbar.tsx\nindex 92f06ab..8ae05a2 100644\n--- a/client/src/components/ChatRoomScreen/ChatNavbar.tsx\n+++ b/client/src/components/ChatRoomScreen/ChatNavbar.tsx\n@@ -10,7 +10,7 @@ import { History } from 'history';\n import { useRemoveChatMutation } from '../../graphql/types';\n import { eraseChat } from '../../services/cache.service';\n\n-const Container = styled(Toolbar) `\n+const Container = styled(Toolbar)`\n   padding: 0;\n   display: flex;\n   flex-direction: row;\n@@ -18,19 +18,19 @@ const Container = styled(Toolbar) `\n   color: var(--primary-text);\n ` as typeof Toolbar;\n\n-const BackButton = styled(Button) `\n+const BackButton = styled(Button)`\n   svg {\n     color: var(--primary-text);\n   }\n ` as typeof Button;\n\n-const Rest = styled.div `\n+const Rest = styled.div`\n   flex: 1;\n   display: flex;\n   justify-content: flex-end;\n-`\n+`;\n\n-const Picture = styled.img `\n+const Picture = styled.img`\n   height: 40px;\n   width: 40px;\n   margin-top: 3px;\n@@ -40,7 +40,7 @@ const Picture = styled.img `\n   border-radius: 50%;\n `;\n\n-const Name = styled.div `\n+const Name = styled.div`\n   line-height: 56px;\n `;\n\n@@ -61,21 +61,21 @@ interface ChatNavbarProps {\n     name?: string | null;\n     id: string;\n   };\n-};\n+}\n\n const ChatNavbar: React.FC<ChatNavbarProps> = ({ chat, history }) => {\n   const removeChat = useRemoveChatMutation({\n     variables: {\n-      chatId: chat.id\n+      chatId: chat.id,\n     },\n     update: (client, { data: { removeChat } }) => {\n       eraseChat(client, removeChat);\n-    }\n+    },\n   });\n\n   const handleRemoveChat = useCallback(() => {\n     removeChat().then(() => {\n-      history.replace('/chats')\n+      history.replace('/chats');\n     });\n   }, [removeChat, history]);\n\n@@ -103,4 +103,4 @@ const ChatNavbar: React.FC<ChatNavbarProps> = ({ chat, history }) => {\n   );\n };\n\n-export default ChatNavbar;\n\\ No newline at end of file\n+export default ChatNavbar;\ndiff --git a/client/src/components/ChatRoomScreen/MessageInput.test.tsx b/client/src/components/ChatRoomScreen/MessageInput.test.tsx\nindex 973de60..dfe35e7 100644\n--- a/client/src/components/ChatRoomScreen/MessageInput.test.tsx\n+++ b/client/src/components/ChatRoomScreen/MessageInput.test.tsx\n@@ -1,6 +1,12 @@\n import { createMemoryHistory } from 'history';\n import React from 'react';\n-import { cleanup, render, fireEvent, wait, waitForElement } from 'react-testing-library';\n+import {\n+  cleanup,\n+  render,\n+  fireEvent,\n+  wait,\n+  waitForElement,\n+} from '@testing-library/react';\n import MessageInput from './MessageInput';\n\n describe('MessageInput;', () => {\n@@ -10,7 +16,9 @@ describe('MessageInput;', () => {\n     const onSendMessage = jest.fn(() => {});\n\n     {\n-      const { container, getByTestId } = render(<MessageInput onSendMessage={onSendMessage} />);\n+      const { container, getByTestId } = render(\n+        <MessageInput onSendMessage={onSendMessage} />\n+      );\n       const messageInput = getByTestId('message-input');\n       const sendButton = getByTestId('send-button');\n\n@@ -20,9 +28,7 @@ describe('MessageInput;', () => {\n\n       fireEvent.click(sendButton);\n\n-      await wait(() =>\n-        expect(onSendMessage.mock.calls.length).toBe(1)\n-      );\n+      await wait(() => expect(onSendMessage.mock.calls.length).toBe(1));\n     }\n   });\n\n@@ -30,18 +36,22 @@ describe('MessageInput;', () => {\n     const onSendMessage = jest.fn(() => {});\n\n     {\n-      const { container, getByTestId } = render(<MessageInput onSendMessage={onSendMessage} />);\n+      const { container, getByTestId } = render(\n+        <MessageInput onSendMessage={onSendMessage} />\n+      );\n       const messageInput = getByTestId('message-input');\n\n       fireEvent.change(messageInput, { target: { value: 'foo' } });\n\n       await waitForElement(() => messageInput);\n\n-      fireEvent.keyPress(messageInput, { key: 'Enter', code: 13, charCode: 13 });\n+      fireEvent.keyPress(messageInput, {\n+        key: 'Enter',\n+        code: 13,\n+        charCode: 13,\n+      });\n\n-      await wait(() =>\n-        expect(onSendMessage.mock.calls.length).toBe(1)\n-      );\n+      await wait(() => expect(onSendMessage.mock.calls.length).toBe(1));\n     }\n   });\n-});\n\\ No newline at end of file\n+});\ndiff --git a/client/src/components/ChatRoomScreen/MessageInput.tsx b/client/src/components/ChatRoomScreen/MessageInput.tsx\nindex 266cfbd..8f0b19c 100644\n--- a/client/src/components/ChatRoomScreen/MessageInput.tsx\n+++ b/client/src/components/ChatRoomScreen/MessageInput.tsx\n@@ -11,7 +11,7 @@ const Container = styled.div`\n   width: calc(100% - 10px);\n `;\n\n-const ActualInput = styled.input `\n+const ActualInput = styled.input`\n   width: calc(100% - 50px);\n   border: none;\n   border-radius: 999px;\n@@ -25,7 +25,7 @@ const ActualInput = styled.input `\n   line-height: 45px;\n `;\n\n-const SendButton = styled(Button) `\n+const SendButton = styled(Button)`\n   min-width: 50px !important;\n   width: 50px !important;\n   border-radius: 999px !important;\n@@ -45,7 +45,7 @@ interface MessageInputProps {\n }\n\n const MessageInput: React.FC<MessageInputProps> = ({ onSendMessage }) => {\n-  const [message, setMessage] = useState(\"\");\n+  const [message, setMessage] = useState('');\n\n   const onKeyPress = (e: any) => {\n     if (e.charCode === 13) {\n@@ -60,9 +60,9 @@ const MessageInput: React.FC<MessageInputProps> = ({ onSendMessage }) => {\n   const submitMessage = () => {\n     if (!message) return;\n\n-    setMessage(\"\");\n+    setMessage('');\n\n-    if (typeof onSendMessage === \"function\") {\n+    if (typeof onSendMessage === 'function') {\n       onSendMessage(message);\n     }\n   };\n@@ -81,12 +81,11 @@ const MessageInput: React.FC<MessageInputProps> = ({ onSendMessage }) => {\n         data-testid=\"send-button\"\n         variant=\"contained\"\n         color=\"primary\"\n-        onClick={submitMessage}\n-      >\n+        onClick={submitMessage}>\n         <SendIcon />\n       </SendButton>\n     </Container>\n   );\n };\n\n-export default MessageInput;\n\\ No newline at end of file\n+export default MessageInput;\ndiff --git a/client/src/components/ChatRoomScreen/MessagesList.test.tsx b/client/src/components/ChatRoomScreen/MessagesList.test.tsx\nindex 57aa03d..d5c1333 100644\n--- a/client/src/components/ChatRoomScreen/MessagesList.test.tsx\n+++ b/client/src/components/ChatRoomScreen/MessagesList.test.tsx\n@@ -1,37 +1,47 @@\n import { createMemoryHistory } from 'history';\n import React from 'react';\n-import { cleanup, render, fireEvent, wait, getByTestId } from 'react-testing-library';\n+import {\n+  cleanup,\n+  render,\n+  fireEvent,\n+  wait,\n+  getByTestId,\n+} from '@testing-library/react';\n import MessagesList from './MessagesList';\n\n describe('MessagesList', () => {\n   afterEach(cleanup);\n\n+  const time = new Date('1 Jan 2019 GMT');\n+\n   it('renders messages data', () => {\n     const messages = [\n       {\n         id: '1',\n         content: 'foo',\n-        createdAt: new Date('14 Jun 2017 00:00:00 PDT').toUTCString(),\n+        createdAt: time,\n       },\n       {\n         id: '2',\n         content: 'bar',\n-        createdAt: new Date('17 Jun 2017 00:01:00 PDT').toUTCString(),\n+        createdAt: time,\n       },\n     ];\n\n     let message1, message2;\n     {\n-      const { container, getAllByTestId, getByTestId } = render(<MessagesList messages={messages} />);\n+      const { container, getAllByTestId, getByTestId } = render(\n+        <MessagesList messages={messages} />\n+      );\n       const match = getAllByTestId('message-item');\n       message1 = match[0];\n       message2 = match[1];\n     }\n\n     expect(getByTestId(message1, 'message-content')).toHaveTextContent('foo');\n-    expect(getByTestId(message1, 'message-date')).toHaveTextContent('10:00');\n+    expect(getByTestId(message1, 'message-date')).toHaveTextContent('02:00');\n\n     expect(getByTestId(message2, 'message-content')).toHaveTextContent('bar');\n-    expect(getByTestId(message2, 'message-date')).toHaveTextContent('10:01');\n+    expect(getByTestId(message2, 'message-date')).toHaveTextContent('02:00');\n   });\n-});\n\\ No newline at end of file\n+});\ndiff --git a/client/src/components/ChatRoomScreen/MessagesList.tsx b/client/src/components/ChatRoomScreen/MessagesList.tsx\nindex 5a6d418..7597c8a 100644\n--- a/client/src/components/ChatRoomScreen/MessagesList.tsx\n+++ b/client/src/components/ChatRoomScreen/MessagesList.tsx\n@@ -1,21 +1,34 @@\n-import moment from 'moment';\n+import format from 'date-fns/format';\n import React from 'react';\n import { useEffect, useRef } from 'react';\n-import ReactDOM from 'react-dom';\n import styled, { css } from 'styled-components';\n+import { useInfiniteScroll } from '../../hooks/use-infinite-scroll';\n+import { useAdjustedScroll } from '../../hooks/use-adjusted-scroll';\n\n const Container = styled.div`\n+  position: relative;\n   display: block;\n   flex: 2;\n   overflow-y: overlay;\n   padding: 0 15px;\n `;\n\n-type StyledProp = {\n+const LoadingMore = styled.div`\n+  height: 30px;\n+  line-height: 30px;\n+  position: absolute;\n+  top: 0;\n+  right: 0;\n+  bottom: 0;\n+  left: 0;\n+  text-align: center;\n+`;\n+\n+type StyledProp = {\n   isMine: any;\n };\n\n-const MessageItem = styled.div `\n+const MessageItem = styled.div`\n   display: inline-block;\n   position: relative;\n   max-width: 100%;\n@@ -42,36 +55,39 @@ const MessageItem = styled.div `\n     background-size: contain;\n   }\n\n-  ${(props: StyledProp) => props.isMine ? css `\n-    float: right;\n-    background-color: #dcf8c6;\n-\n-    &::before {\n-      right: -11px;\n-      background-image: url(/assets/message-mine.png);\n-    }\n-  ` : css `\n-    float: left;\n-    background-color: #fff;\n-\n-    &::before {\n-      left: -11px;\n-      background-image: url(/assets/message-other.png);\n-    }\n-  `}\n+  ${(props: StyledProp) =>\n+    props.isMine\n+      ? css`\n+          float: right;\n+          background-color: #dcf8c6;\n+\n+          &::before {\n+            right: -11px;\n+            background-image: url(/assets/message-mine.png);\n+          }\n+        `\n+      : css`\n+          float: left;\n+          background-color: #fff;\n+\n+          &::before {\n+            left: -11px;\n+            background-image: url(/assets/message-other.png);\n+          }\n+        `}\n `;\n\n-const Contents = styled.div `\n+const Contents = styled.div`\n   padding: 5px 7px;\n   word-wrap: break-word;\n\n   &::after {\n-    content: ' \\00a0\\00a0\\00a0\\00a0\\00a0\\00a0\\00a0\\00a0\\00a0\\00a0\\00a0\\00a0\\00a0\\00a0\\00a0\\00a0\\00a0\\00a0\\00a0';\n+    content: ' \\\\00a0\\\\00a0\\\\00a0\\\\00a0\\\\00a0\\\\00a0\\\\00a0\\\\00a0\\\\00a0\\\\00a0\\\\00a0\\\\00a0\\\\00a0\\\\00a0\\\\00a0\\\\00a0\\\\00a0\\\\00a0\\\\00a0';\n     display: inline;\n   }\n `;\n\n-const Timestamp = styled.div `\n+const Timestamp = styled.div`\n   position: absolute;\n   bottom: 2px;\n   right: 7px;\n@@ -86,31 +102,51 @@ interface Message {\n }\n interface MessagesListProps {\n   messages: Array<Message>;\n+  loadMore: Function;\n+  hasMore: boolean;\n }\n\n-const MessagesList: React.FC<MessagesListProps> = ({ messages }) => {\n-  const selfRef = useRef(null);\n+const MessagesList: React.FC<MessagesListProps> = ({\n+  messages,\n+  loadMore,\n+  hasMore,\n+}) => {\n+  const selfRef = useRef<HTMLDivElement>(null);\n+  const [fetching, stopFetching] = useInfiniteScroll({\n+    onLoadMore: loadMore,\n+    hasMore,\n+    ref: selfRef!,\n+  });\n+  const adjustScroll = useAdjustedScroll(selfRef);\n\n   useEffect(() => {\n     if (!selfRef.current) return;\n-    const selfDOMNode = ReactDOM.findDOMNode(selfRef.current) as HTMLElement;\n-    selfDOMNode.scrollTop = Number.MAX_SAFE_INTEGER;\n-  }, [messages.length]);\n+\n+    if (fetching) {\n+      stopFetching();\n+      adjustScroll();\n+    } else {\n+      // scroll to the most recent message\n+      adjustScroll(true);\n+    }\n+  }, [messages.length, selfRef, fetching, stopFetching, adjustScroll]);\n\n   return (\n     <Container ref={selfRef}>\n+      {fetching && <LoadingMore>{'Loading more messages...'}</LoadingMore>}\n       {messages.map((message: any) => (\n         <MessageItem\n           data-testid=\"message-item\"\n           isMine={message.isMine}\n-          key={message.id}\n-        >\n+          key={message.id}>\n           <Contents data-testid=\"message-content\">{message.content}</Contents>\n-          <Timestamp data-testid=\"message-date\">{moment(message.createdAt).format('HH:mm')}</Timestamp>\n+          <Timestamp data-testid=\"message-date\">\n+            {format(message.createdAt, 'HH:mm')}\n+          </Timestamp>\n         </MessageItem>\n       ))}\n     </Container>\n   );\n };\n\n-export default MessagesList;\n\\ No newline at end of file\n+export default MessagesList;\ndiff --git a/client/src/components/ChatRoomScreen/index.tsx b/client/src/components/ChatRoomScreen/index.tsx\nindex f109d67..826e3bb 100644\n--- a/client/src/components/ChatRoomScreen/index.tsx\n+++ b/client/src/components/ChatRoomScreen/index.tsx\n@@ -1,17 +1,24 @@\n import gql from 'graphql-tag';\n import React from 'react';\n-import { useCallback } from 'react';\n+import { useCallback, useState, useContext, useEffect } from 'react';\n import { Redirect } from 'react-router-dom';\n+import { useApolloClient } from 'react-apollo-hooks';\n import styled from 'styled-components';\n import ChatNavbar from './ChatNavbar';\n import MessageInput from './MessageInput';\n import MessagesList from './MessagesList';\n import { History } from 'history';\n-import { useGetChatQuery, useAddMessageMutation } from '../../graphql/types';\n+import {\n+  useGetChatQuery,\n+  useAddMessageMutation,\n+  GetChatQuery,\n+  GetChatQueryVariables,\n+  GetChatDocument,\n+} from '../../graphql/types';\n import * as fragments from '../../graphql/fragments';\n import { writeMessage } from '../../services/cache.service';\n\n- const Container = styled.div `\n+const Container = styled.div`\n   background: url(/assets/chat-background.jpg);\n   display: flex;\n   flex-flow: column;\n@@ -19,8 +26,8 @@ import { writeMessage } from '../../services/cache.service';\n `;\n\n // eslint-disable-next-line\n-const getChatQuery = gql `\n-  query GetChat($chatId: ID!) {\n+const getChatQuery = gql`\n+  query GetChat($chatId: ID!, $limit: Int!, $after: Float) {\n     chat(chatId: $chatId) {\n       ...FullChat\n     }\n@@ -29,7 +36,7 @@ const getChatQuery = gql `\n `;\n\n // eslint-disable-next-line\n-const addMessageMutation = gql `\n+const addMessageMutation = gql`\n   mutation AddMessage($chatId: ID!, $content: String!) {\n     addMessage(chatId: $chatId, content: $content) {\n       ...Message\n@@ -38,45 +45,141 @@ const addMessageMutation = gql `\n   ${fragments.message}\n `;\n\n+const PaginationContext = React.createContext({\n+  after: 0,\n+  limit: 20,\n+  /**\n+   * Sets new cursor\n+   */\n+  setAfter: (after: number) => {},\n+  /**\n+   * Resets `after` value to its inital state (null) so\n+   */\n+  reset: () => {},\n+});\n+\n+const usePagination = () => {\n+  const pagination = useContext(PaginationContext);\n+\n+  // Resets the pagination every time a component did unmount\n+  useEffect(() => {\n+    return () => {\n+      pagination.reset();\n+    };\n+  }, [pagination]);\n+\n+  return pagination;\n+};\n+\n+export const ChatPaginationProvider = ({ children }: { children: any }) => {\n+  const [after, setAfter] = useState<number | null>(null);\n+\n+  return (\n+    <PaginationContext.Provider\n+      value={{\n+        limit: 20,\n+        after: after!,\n+        setAfter,\n+        reset: () => setAfter(null),\n+      }}>\n+      {children}\n+    </PaginationContext.Provider>\n+  );\n+};\n+\n+export const useGetChatPrefetch = () => {\n+  const client = useApolloClient();\n+  const { limit, after } = usePagination();\n+\n+  return (chatId: string) => {\n+    client.query<GetChatQuery, GetChatQueryVariables>({\n+      query: GetChatDocument,\n+      variables: {\n+        chatId,\n+        after,\n+        limit,\n+      },\n+    });\n+  };\n+};\n+\n interface ChatRoomScreenParams {\n-  chatId: string\n+  chatId: string;\n   history: History;\n-};\n+}\n\n-const ChatRoomScreen: React.FC<ChatRoomScreenParams> = ({ history, chatId }) => {\n-  const { data, loading } = useGetChatQuery({\n-    variables: { chatId }\n+const ChatRoom: React.FC<ChatRoomScreenParams> = ({ history, chatId }) => {\n+  const { after, limit, setAfter } = usePagination();\n+  const { data, loading, fetchMore } = useGetChatQuery({\n+    variables: { chatId, after, limit },\n   });\n\n   const addMessage = useAddMessageMutation();\n\n-  const onSendMessage = useCallback((content: string) => {\n-\n-    if (data === undefined) { return null; }\n-    const chat = data.chat;\n-    if (chat === null) return null;\n-\n-    addMessage({\n-      variables: { chatId, content },\n-      optimisticResponse: {\n-        __typename: 'Mutation',\n-        addMessage: {\n-          __typename: 'Message',\n-          id: Math.random().toString(36).substr(2, 9),\n-          createdAt: new Date(),\n-          isMine: true,\n-          chat: {\n-            __typename: 'Chat',\n-            id: chatId,\n+  const onSendMessage = useCallback(\n+    (content: string) => {\n+      if (data === undefined) {\n+        return null;\n+      }\n+      const chat = data.chat;\n+      if (chat === null) return null;\n+\n+      addMessage({\n+        variables: { chatId, content },\n+        optimisticResponse: {\n+          __typename: 'Mutation',\n+          addMessage: {\n+            __typename: 'Message',\n+            id: Math.random()\n+              .toString(36)\n+              .substr(2, 9),\n+            createdAt: new Date(),\n+            isMine: true,\n+            chat: {\n+              __typename: 'Chat',\n+              id: chatId,\n+            },\n+            content,\n           },\n-          content,\n-        }\n+        },\n+        update: (client, { data: { addMessage } }) => {\n+          writeMessage(client, addMessage);\n+        },\n+      });\n+    },\n+    [data, chatId, addMessage]\n+  );\n+\n+  useEffect(() => {\n+    if (!after) {\n+      return;\n+    }\n+\n+    // every time after changes its value, fetch more messages\n+    fetchMore({\n+      variables: {\n+        after,\n+        limit,\n       },\n-      update: (client, { data: { addMessage } }) => {\n-        writeMessage(client, addMessage);\n+      updateQuery(prev, { fetchMoreResult }) {\n+        const messages = [\n+          ...fetchMoreResult!.chat!.messages.messages,\n+          ...prev.chat!.messages.messages,\n+        ];\n+\n+        return {\n+          ...prev,\n+          chat: {\n+            ...prev.chat!,\n+            messages: {\n+              ...fetchMoreResult!.chat!.messages,\n+              messages,\n+            },\n+          },\n+        };\n       },\n-    })\n-  }, [data, chatId, addMessage]);\n+    });\n+  }, [after, limit, fetchMore]);\n\n   if (data === undefined) {\n     return null;\n@@ -89,20 +192,33 @@ const ChatRoomScreen: React.FC<ChatRoomScreenParams> = ({ history, chatId }) =>\n\n   // Chat was probably removed from cache by the subscription handler\n   if (!chat) {\n-    return (\n-      <Redirect to=\"/chats\" />\n-    );\n+    return <Redirect to=\"/chats\" />;\n   }\n\n   return (\n     <Container>\n       <ChatNavbar chat={chat} history={history} />\n       {chat.messages && (\n-        <MessagesList messages={chat.messages} />\n+        <MessagesList\n+          messages={chat.messages.messages}\n+          hasMore={chat.messages.hasMore}\n+          loadMore={() => setAfter(chat.messages.cursor!)}\n+        />\n       )}\n-      <MessageInput onSendMessage={onSendMessage}/>\n+      <MessageInput onSendMessage={onSendMessage} />\n     </Container>\n   );\n };\n\n-export default ChatRoomScreen;\n\\ No newline at end of file\n+const ChatRoomScreen: React.FC<ChatRoomScreenParams> = ({\n+  history,\n+  chatId,\n+}) => {\n+  return (\n+    <ChatPaginationProvider>\n+      <ChatRoom history={history} chatId={chatId} />\n+    </ChatPaginationProvider>\n+  );\n+};\n+\n+export default ChatRoomScreen;\ndiff --git a/client/src/components/ChatsListScreen/AddChatButton.test.tsx b/client/src/components/ChatsListScreen/AddChatButton.test.tsx\nindex 8a21aff..9727a2e 100644\n--- a/client/src/components/ChatsListScreen/AddChatButton.test.tsx\n+++ b/client/src/components/ChatsListScreen/AddChatButton.test.tsx\n@@ -1,22 +1,27 @@\n import { createMemoryHistory } from 'history';\n+import { ApolloProvider } from 'react-apollo-hooks';\n import React from 'react';\n-import { cleanup, render, fireEvent, wait } from 'react-testing-library';\n+import { cleanup, render, fireEvent, wait } from '@testing-library/react';\n import AddChatButton from './AddChatButton';\n+import { mockApolloClient } from '../../test-helpers';\n\n describe('AddChatButton', () => {\n   afterEach(cleanup);\n\n   it('goes back on arrow click', async () => {\n     const history = createMemoryHistory();\n+    const client = mockApolloClient();\n\n     {\n-      const { container, getByTestId } = render(<AddChatButton history={history} />);\n+      const { container, getByTestId } = render(\n+        <ApolloProvider client={client}>\n+          <AddChatButton history={history} />\n+        </ApolloProvider>\n+      );\n\n       fireEvent.click(getByTestId('new-chat-button'));\n\n-      await wait(() =>\n-        expect(history.location.pathname).toEqual('/new-chat')\n-      );\n+      await wait(() => expect(history.location.pathname).toEqual('/new-chat'));\n     }\n   });\n });\ndiff --git a/client/src/components/ChatsListScreen/AddChatButton.tsx b/client/src/components/ChatsListScreen/AddChatButton.tsx\nindex d14fc44..53470e0 100644\n--- a/client/src/components/ChatsListScreen/AddChatButton.tsx\n+++ b/client/src/components/ChatsListScreen/AddChatButton.tsx\n@@ -3,8 +3,9 @@ import ChatIcon from '@material-ui/icons/Chat';\n import React from 'react';\n import styled from 'styled-components';\n import { History } from 'history';\n+import { useUsersPrefetch } from '../UsersList';\n\n-const Container = styled.div `\n+const Container = styled.div`\n   position: fixed;\n   right: 10px;\n   bottom: 10px;\n@@ -18,27 +19,28 @@ const Container = styled.div `\n     color: white;\n   }\n `;\n+\n interface ChildComponentProps {\n   history: History;\n-};\n+}\n\n const AddChatButton: React.FC<ChildComponentProps> = ({ history }) => {\n+  const prefetchUsers = useUsersPrefetch();\n   const onClick = () => {\n-    history.push('/new-chat')\n+    history.push('/new-chat');\n   };\n\n   return (\n-    <Container>\n+    <Container onMouseEnter={() => prefetchUsers()}>\n       <Button\n         data-testid=\"new-chat-button\"\n         variant=\"contained\"\n         color=\"secondary\"\n-        onClick={onClick}\n-      >\n+        onClick={onClick}>\n         <ChatIcon />\n       </Button>\n     </Container>\n   );\n };\n\n-export default AddChatButton;\n\\ No newline at end of file\n+export default AddChatButton;\ndiff --git a/client/src/components/ChatsListScreen/ChatsList.test.tsx b/client/src/components/ChatsListScreen/ChatsList.test.tsx\nindex 33447b8..5b01462 100644\n--- a/client/src/components/ChatsListScreen/ChatsList.test.tsx\n+++ b/client/src/components/ChatsListScreen/ChatsList.test.tsx\n@@ -1,7 +1,13 @@\n import React from 'react';\n import { ApolloProvider } from 'react-apollo-hooks';\n import ReactDOM from 'react-dom';\n-import { cleanup, render, fireEvent, wait, waitForDomChange } from 'react-testing-library';\n+import {\n+  cleanup,\n+  render,\n+  fireEvent,\n+  wait,\n+  waitForDomChange,\n+} from '@testing-library/react';\n import { createBrowserHistory } from 'history';\n import { mockApolloClient } from '../../test-helpers';\n import ChatsList, { getChatsQuery } from './ChatsList';\n@@ -29,7 +35,7 @@ describe('ChatsList', () => {\n                   __typename: 'Message',\n                   id: 1,\n                   content: 'Hello',\n-                  createdAt: new Date('14 Jun 2017 00:00:00 PDT').toUTCString(),\n+                  createdAt: new Date('1 Jan 2019 GMT'),\n                   isMine: true,\n                   chat: {\n                     __typename: 'Chat',\n@@ -53,9 +59,12 @@ describe('ChatsList', () => {\n       await waitForDomChange({ container });\n\n       expect(getByTestId('name')).toHaveTextContent('Foo Bar');\n-      expect(getByTestId('picture')).toHaveAttribute('src', 'https://localhost:4000/picture.jpg');\n+      expect(getByTestId('picture')).toHaveAttribute(\n+        'src',\n+        'https://localhost:4000/picture.jpg'\n+      );\n       expect(getByTestId('content')).toHaveTextContent('Hello');\n-      expect(getByTestId('date')).toHaveTextContent('10:00');\n+      expect(getByTestId('date')).toHaveTextContent('02:00');\n     }\n   });\n\n@@ -75,7 +84,7 @@ describe('ChatsList', () => {\n                   __typename: 'Message',\n                   id: 1,\n                   content: 'Hello',\n-                  createdAt: new Date(0),\n+                  createdAt: new Date('1 Jan 2019 GMT'),\n                   isMine: true,\n                   chat: {\n                     __typename: 'Chat',\n@@ -89,7 +98,7 @@ describe('ChatsList', () => {\n       },\n     ]);\n\n-     const history = createBrowserHistory();\n+    const history = createBrowserHistory();\n\n     {\n       const { container, getByTestId } = render(\n@@ -98,13 +107,11 @@ describe('ChatsList', () => {\n         </ApolloProvider>\n       );\n\n-       await waitForDomChange({ container });\n+      await waitForDomChange({ container });\n\n-       fireEvent.click(getByTestId('chat'));\n+      fireEvent.click(getByTestId('chat'));\n\n-       await wait(() =>\n-        expect(history.location.pathname).toEqual('/chats/1')\n-      );\n+      await wait(() => expect(history.location.pathname).toEqual('/chats/1'));\n     }\n   });\n });\ndiff --git a/client/src/components/ChatsListScreen/ChatsList.tsx b/client/src/components/ChatsListScreen/ChatsList.tsx\nindex c5fd34a..56cf21f 100644\n--- a/client/src/components/ChatsListScreen/ChatsList.tsx\n+++ b/client/src/components/ChatsListScreen/ChatsList.tsx\n@@ -1,34 +1,35 @@\n import React from 'react';\n-import moment from 'moment';\n+import format from 'date-fns/format';\n import { List, ListItem } from '@material-ui/core';\n import styled from 'styled-components';\n import { useCallback } from 'react';\n import { History } from 'history';\n import { useChatsQuery } from '../../graphql/types';\n+import { useGetChatPrefetch } from '../ChatRoomScreen';\n\n-const Container = styled.div `\n+const Container = styled.div`\n   height: calc(100% - 56px);\n   overflow-y: overlay;\n `;\n\n-const StyledList = styled(List) `\n+const StyledList = styled(List)`\n   padding: 0 !important;\n ` as typeof List;\n\n-const StyledListItem = styled(ListItem) `\n+const StyledListItem = styled(ListItem)`\n   height: 76px;\n   padding: 0 15px;\n   display: flex;\n ` as typeof ListItem;\n\n-const ChatPicture = styled.img `\n+const ChatPicture = styled.img`\n   height: 50px;\n   width: 50px;\n   object-fit: cover;\n   border-radius: 50%;\n `;\n\n-const ChatInfo = styled.div `\n+const ChatInfo = styled.div`\n   width: calc(100% - 60px);\n   height: 46px;\n   padding: 15px 0;\n@@ -37,11 +38,11 @@ const ChatInfo = styled.div `\n   position: relative;\n `;\n\n-const ChatName = styled.div `\n+const ChatName = styled.div`\n   margin-top: 5px;\n `;\n\n-const MessageContent = styled.div `\n+const MessageContent = styled.div`\n   color: gray;\n   font-size: 15px;\n   margin-top: 5px;\n@@ -50,7 +51,7 @@ const MessageContent = styled.div `\n   white-space: nowrap;\n `;\n\n-const MessageDate = styled.div `\n+const MessageDate = styled.div`\n   position: absolute;\n   color: gray;\n   top: 20px;\n@@ -59,14 +60,17 @@ const MessageDate = styled.div `\n `;\n\n interface ChatsListProps {\n-  history : History;\n-};\n+  history: History;\n+}\n\n const ChatsList: React.FC<ChatsListProps> = ({ history }) => {\n-\n-  const navToChat = useCallback((chat) => {\n-    history.push(`chats/${chat.id}`)\n-  }, [history]);\n+  const navToChat = useCallback(\n+    chat => {\n+      history.push(`chats/${chat.id}`);\n+    },\n+    [history]\n+  );\n+  const prefetchChat = useGetChatPrefetch();\n\n   const { data } = useChatsQuery();\n\n@@ -80,14 +84,29 @@ const ChatsList: React.FC<ChatsListProps> = ({ history }) => {\n     <Container>\n       <StyledList>\n         {chats.map((chat: any) => (\n-          <StyledListItem key={chat.id} data-testid=\"chat\" button onClick={navToChat.bind(null, chat)}>\n-            <ChatPicture data-testid=\"picture\" src={chat.picture} alt=\"Profile\"/>\n+          <StyledListItem\n+            key={chat.id}\n+            data-testid=\"chat\"\n+            button\n+            onClick={navToChat.bind(null, chat)}\n+            onMouseEnter={() => {\n+              prefetchChat(chat.id);\n+            }}>\n+            <ChatPicture\n+              data-testid=\"picture\"\n+              src={chat.picture}\n+              alt=\"Profile\"\n+            />\n             <ChatInfo>\n               <ChatName data-testid=\"name\">{chat.name}</ChatName>\n               {chat.lastMessage && (\n                 <React.Fragment>\n-                  <MessageContent data-testid=\"content\">{chat.lastMessage.content}</MessageContent>\n-                  <MessageDate data-testid=\"date\">{moment(chat.lastMessage.createdAt).format('HH:mm')}</MessageDate>\n+                  <MessageContent data-testid=\"content\">\n+                    {chat.lastMessage.content}\n+                  </MessageContent>\n+                  <MessageDate data-testid=\"date\">\n+                    {format(chat.lastMessage.createdAt, 'HH:mm')}\n+                  </MessageDate>\n                 </React.Fragment>\n               )}\n             </ChatInfo>\n@@ -95,7 +114,7 @@ const ChatsList: React.FC<ChatsListProps> = ({ history }) => {\n         ))}\n       </StyledList>\n     </Container>\n-  )\n+  );\n };\n\n-export default ChatsList;\n\\ No newline at end of file\n+export default ChatsList;\ndiff --git a/client/src/components/ChatsListScreen/ChatsNavbar.tsx b/client/src/components/ChatsListScreen/ChatsNavbar.tsx\nindex 9ef163a..41e588a 100644\n--- a/client/src/components/ChatsListScreen/ChatsNavbar.tsx\n+++ b/client/src/components/ChatsListScreen/ChatsNavbar.tsx\n@@ -3,10 +3,10 @@ import { Button, Toolbar } from '@material-ui/core';\n import styled from 'styled-components';\n import SignOutIcon from '@material-ui/icons/PowerSettingsNew';\n import { useCallback } from 'react';\n-import { signOut } from '../../services/auth.service';\n+import { useSignOut } from '../../services/auth.service';\n import { History } from 'history';\n\n-const Container = styled(Toolbar) `\n+const Container = styled(Toolbar)`\n   display: flex;\n   background-color: var(--primary-bg);\n   color: var(--primary-text);\n@@ -14,24 +14,26 @@ const Container = styled(Toolbar) `\n   line-height: 40px;\n ` as typeof Toolbar;\n\n-const Title = styled.div `\n+const Title = styled.div`\n   flex: 1;\n `;\n\n-const LogoutButton = styled(Button) `\n+const LogoutButton = styled(Button)`\n   color: var(--primary-text) !important;\n ` as typeof Button;\n\n interface ChildComponentProps {\n   history: History;\n-};\n+}\n\n const ChatsNavbar: React.FC<ChildComponentProps> = ({ history }) => {\n+  const signOut = useSignOut();\n+\n   const handleSignOut = useCallback(() => {\n     signOut().then(() => {\n-      history.replace('/sign-in')\n+      history.replace('/sign-in');\n     });\n-  }, [history]);\n+  }, [history, signOut]);\n\n   return (\n     <Container>\n@@ -43,4 +45,4 @@ const ChatsNavbar: React.FC<ChildComponentProps> = ({ history }) => {\n   );\n };\n\n-export default ChatsNavbar;\n\\ No newline at end of file\n+export default ChatsNavbar;\ndiff --git a/client/src/components/ChatsListScreen/index.tsx b/client/src/components/ChatsListScreen/index.tsx\nindex 4451ea2..2d0416c 100644\n--- a/client/src/components/ChatsListScreen/index.tsx\n+++ b/client/src/components/ChatsListScreen/index.tsx\n@@ -5,13 +5,13 @@ import styled from 'styled-components';\n import { History } from 'history';\n import AddChatButton from './AddChatButton';\n\n-const Container = styled.div `\n+const Container = styled.div`\n   height: 100vh;\n `;\n\n interface ChatsListScreenProps {\n-  history : History;\n-};\n+  history: History;\n+}\n\n const ChatsListScreen: React.FC<ChatsListScreenProps> = ({ history }) => (\n   <Container>\n@@ -21,4 +21,4 @@ const ChatsListScreen: React.FC<ChatsListScreenProps> = ({ history }) => (\n   </Container>\n );\n\n-export default ChatsListScreen;\n\\ No newline at end of file\n+export default ChatsListScreen;\ndiff --git a/client/src/components/UsersList.test.tsx b/client/src/components/UsersList.test.tsx\nindex 5af11e0..0316441 100644\n--- a/client/src/components/UsersList.test.tsx\n+++ b/client/src/components/UsersList.test.tsx\n@@ -1,6 +1,12 @@\n import React from 'react';\n import { ApolloProvider } from 'react-apollo-hooks';\n-import { cleanup, render, fireEvent, wait, waitForDomChange } from 'react-testing-library';\n+import {\n+  cleanup,\n+  render,\n+  fireEvent,\n+  wait,\n+  waitForDomChange,\n+} from '@testing-library/react';\n import { mockApolloClient } from '../test-helpers';\n import UsersList, { UsersListQuery } from './UsersList';\n import * as queries from '../graphql/queries';\n@@ -37,9 +43,12 @@ describe('UsersList', () => {\n       await waitForDomChange({ container });\n\n       expect(getByTestId('name')).toHaveTextContent('Charles Dickhead');\n-      expect(getByTestId('picture')).toHaveAttribute('src', 'https://localhost:4000/dick.jpg');\n+      expect(getByTestId('picture')).toHaveAttribute(\n+        'src',\n+        'https://localhost:4000/dick.jpg'\n+      );\n     }\n-  })\n+  });\n\n   it('triggers onUserPick() callback on user-item click', async () => {\n     const client = mockApolloClient([\n@@ -73,12 +82,12 @@ describe('UsersList', () => {\n\n       fireEvent.click(getByTestId('user'));\n\n-      await wait(() =>\n-        expect(onUserPick.mock.calls.length).toBe(1)\n-      );\n+      await wait(() => expect(onUserPick.mock.calls.length).toBe(1));\n\n       expect(onUserPick.mock.calls[0][0].name).toEqual('Charles Dickhead');\n-      expect(onUserPick.mock.calls[0][0].picture).toEqual('https://localhost:4000/dick.jpg');\n+      expect(onUserPick.mock.calls[0][0].picture).toEqual(\n+        'https://localhost:4000/dick.jpg'\n+      );\n     }\n   });\n });\ndiff --git a/client/src/components/UsersList.tsx b/client/src/components/UsersList.tsx\nindex 0fbf394..0987ba9 100644\n--- a/client/src/components/UsersList.tsx\n+++ b/client/src/components/UsersList.tsx\n@@ -3,28 +3,29 @@ import MaterialItem from '@material-ui/core/ListItem';\n import gql from 'graphql-tag';\n import React from 'react';\n import styled from 'styled-components';\n+import { useApolloClient } from 'react-apollo-hooks';\n+import { useUsersListQuery, User, UsersListDocument } from '../graphql/types';\n import * as fragments from '../graphql/fragments';\n-import { useUsersListQuery, User } from '../graphql/types';\n\n-const ActualList = styled(MaterialList) `\n+const ActualList = styled(MaterialList)`\n   padding: 0;\n ` as typeof MaterialList;\n\n-const UserItem = styled(MaterialItem) `\n+const UserItem = styled(MaterialItem)`\n   position: relative;\n   padding: 7.5px 15px;\n   display: flex;\n   cursor: pinter;\n ` as typeof MaterialItem;\n\n-const ProfilePicture = styled.img `\n+const ProfilePicture = styled.img`\n   height: 50px;\n   width: 50px;\n   object-fit: cover;\n   border-radius: 50%;\n `;\n\n-const Name = styled.div `\n+const Name = styled.div`\n   padding-left: 15px;\n   font-weight: bold;\n `;\n@@ -38,11 +39,23 @@ export const UsersListQuery = gql`\n   ${fragments.user}\n `;\n\n+export const useUsersPrefetch = () => {\n+  const client = useApolloClient();\n+\n+  return () => {\n+    client.query({\n+      query: UsersListDocument,\n+    });\n+  };\n+};\n+\n interface ChildComponentProps {\n   onUserPick: any;\n-};\n+}\n\n-const UsersList: React.FC<ChildComponentProps> = ({ onUserPick = (user: User) => {} }) => {\n+const UsersList: React.FC<ChildComponentProps> = ({\n+  onUserPick = (user: User) => {},\n+}) => {\n   const { data, loading: loadingUsers } = useUsersListQuery();\n\n   if (data === undefined) return null;\n@@ -50,21 +63,21 @@ const UsersList: React.FC<ChildComponentProps> = ({ onUserPick = (user: User) =>\n\n   return (\n     <ActualList>\n-      {!loadingUsers && users.map(user => (\n-        <UserItem\n-          key={user.id}\n-          data-testid=\"user\"\n-          onClick={onUserPick.bind(null, user)}\n-          button\n-        >\n-          {(user !== null && user.picture !== null) &&\n-            <React.Fragment>\n-              <ProfilePicture data-testid=\"picture\" src={user.picture} />\n-              <Name data-testid=\"name\">{user.name}</Name>\n-            </React.Fragment>\n-          }\n-        </UserItem>\n-      ))}\n+      {!loadingUsers &&\n+        users.map(user => (\n+          <UserItem\n+            key={user.id}\n+            data-testid=\"user\"\n+            onClick={onUserPick.bind(null, user)}\n+            button>\n+            {user !== null && user.picture !== null && (\n+              <React.Fragment>\n+                <ProfilePicture data-testid=\"picture\" src={user.picture} />\n+                <Name data-testid=\"name\">{user.name}</Name>\n+              </React.Fragment>\n+            )}\n+          </UserItem>\n+        ))}\n     </ActualList>\n   );\n };\ndiff --git a/client/src/graphql/fragments/fullChat.fragment.ts b/client/src/graphql/fragments/fullChat.fragment.ts\nindex 26998e4..2d2cd30 100644\n--- a/client/src/graphql/fragments/fullChat.fragment.ts\n+++ b/client/src/graphql/fragments/fullChat.fragment.ts\n@@ -1,14 +1,14 @@\n import gql from 'graphql-tag';\n import chat from './chat.fragment';\n-import message from './message.fragment';\n+import messagesResult from './messagesResult.fragment';\n\n export default gql`\n   fragment FullChat on Chat {\n     ...Chat\n-    messages {\n-      ...Message\n+    messages(limit: $limit, after: $after) @connection(key: \"messages\") {\n+      ...MessagesResult\n     }\n   }\n   ${chat}\n-  ${message}\n+  ${messagesResult}\n `;\ndiff --git a/client/src/graphql/fragments/messagesResult.fragment.ts b/client/src/graphql/fragments/messagesResult.fragment.ts\nnew file mode 100644\nindex 0000000..b1131f0\n--- /dev/null\n+++ b/client/src/graphql/fragments/messagesResult.fragment.ts\n@@ -0,0 +1,13 @@\n+import gql from 'graphql-tag';\n+import message from './message.fragment';\n+\n+export default gql`\n+  fragment MessagesResult on MessagesResult {\n+    cursor\n+    hasMore\n+    messages {\n+      ...Message\n+    }\n+  }\n+  ${message}\n+`;\ndiff --git a/client/src/graphql/mutations/index.ts b/client/src/graphql/mutations/index.ts\nnew file mode 100644\nindex 0000000..b4db188\n--- /dev/null\n+++ b/client/src/graphql/mutations/index.ts\n@@ -0,0 +1 @@\n+export { default as signIn } from './signIn.mutation'\ndiff --git a/client/src/graphql/mutations/signIn.mutation.ts b/client/src/graphql/mutations/signIn.mutation.ts\nnew file mode 100644\nindex 0000000..582afd6\n--- /dev/null\n+++ b/client/src/graphql/mutations/signIn.mutation.ts\n@@ -0,0 +1,9 @@\n+import gql from 'graphql-tag'\n+\n+export default gql`\n+  mutation signIn($username: String!, $password: String!) {\n+    signIn(username: $username, password: $password) {\n+      id\n+    }\n+  }\n+`\ndiff --git a/client/src/graphql/mutations/signUp.mutation.ts b/client/src/graphql/mutations/signUp.mutation.ts\nnew file mode 100644\nindex 0000000..041f137\n--- /dev/null\n+++ b/client/src/graphql/mutations/signUp.mutation.ts\n@@ -0,0 +1,9 @@\n+import gql from 'graphql-tag'\n+\n+export default gql`\n+  mutation signUp($name: String!, $username: String!, $password: String!, $passwordConfirm: String!) {\n+    signUp(name: $name, username: $username, password: $password, passwordConfirm: $passwordConfirm) {\n+      id\n+    }\n+  }\n+`\ndiff --git a/client/src/graphql/subscriptions/messageAdded.subscription.ts b/client/src/graphql/subscriptions/messageAdded.subscription.ts\nindex 382c755..ad284f8 100644\n--- a/client/src/graphql/subscriptions/messageAdded.subscription.ts\n+++ b/client/src/graphql/subscriptions/messageAdded.subscription.ts\n@@ -1,7 +1,7 @@\n import gql from 'graphql-tag';\n import * as fragments from '../fragments';\n\n-export default gql `\n+export default gql`\n   subscription MessageAdded {\n     messageAdded {\n       ...Message\ndiff --git a/client/src/hooks/use-adjusted-scroll.ts b/client/src/hooks/use-adjusted-scroll.ts\nnew file mode 100644\nindex 0000000..94173e4\n--- /dev/null\n+++ b/client/src/hooks/use-adjusted-scroll.ts\n@@ -0,0 +1,35 @@\n+import { useState, useCallback, RefObject } from 'react';\n+import * as ReactDOM from 'react-dom';\n+\n+export const useAdjustedScroll = (ref: RefObject<HTMLElement>) => {\n+  const [previousScroll, setPreviousScroll] = useState<{\n+    top: number;\n+    height: number;\n+  }>();\n+\n+  /**\n+   * Scrolls to the previous position or completely to bottom (on demand)\n+   */\n+  const adjust = useCallback(\n+    (scrollToBottom?: boolean) => {\n+      if (!ref.current) return;\n+\n+      const node = ReactDOM.findDOMNode(ref.current) as HTMLElement;\n+      const height =\n+        !scrollToBottom && previousScroll\n+          ? previousScroll.height\n+          : node.clientHeight;\n+\n+      node.scrollTop = node.scrollHeight - height;\n+\n+      // saves current scroll details\n+      setPreviousScroll({\n+        top: node.scrollTop,\n+        height: node.scrollHeight,\n+      });\n+    },\n+    [ref, previousScroll]\n+  );\n+\n+  return adjust;\n+};\ndiff --git a/client/src/hooks/use-infinite-scroll.ts b/client/src/hooks/use-infinite-scroll.ts\nnew file mode 100644\nindex 0000000..1872801\n--- /dev/null\n+++ b/client/src/hooks/use-infinite-scroll.ts\n@@ -0,0 +1,48 @@\n+import { useState, useEffect, useCallback, RefObject } from 'react';\n+\n+export const useInfiniteScroll = ({\n+  ref,\n+  hasMore,\n+  onLoadMore,\n+}: {\n+  onLoadMore: Function;\n+  hasMore: boolean;\n+  ref: RefObject<HTMLElement>;\n+}): [boolean, () => void] => {\n+  const [isFetching, setIsFetching] = useState(false);\n+  const handleScroll = useCallback(() => {\n+    if (ref.current!.scrollTop === 0 && isFetching === false && hasMore) {\n+      // starts to fetch if scrolled to top, fetching is not in progress and has more data\n+      setIsFetching(true);\n+    }\n+  }, [ref, isFetching, hasMore]);\n+\n+  useEffect(() => {\n+    const elem = ref.current;\n+\n+    if (!elem) {\n+      return;\n+    }\n+\n+    elem.addEventListener('scroll', handleScroll);\n+\n+    return () => {\n+      elem!.removeEventListener('scroll', handleScroll);\n+    };\n+  }, [ref, handleScroll]);\n+\n+  // loads more if fetching has started\n+  useEffect(() => {\n+    if (isFetching) {\n+      onLoadMore();\n+    }\n+  }, [isFetching, onLoadMore]);\n+\n+  const stopFetching = useCallback(() => {\n+    setIsFetching(false);\n+  }, []);\n+\n+  return [isFetching, stopFetching];\n+};\n+\n+export default useInfiniteScroll;\ndiff --git a/client/src/index.tsx b/client/src/index.tsx\nindex e953ef2..28f1411 100644\n--- a/client/src/index.tsx\n+++ b/client/src/index.tsx\n@@ -1,4 +1,4 @@\n-import { MuiThemeProvider, createMuiTheme } from '@material-ui/core/styles'\n+import { MuiThemeProvider, createMuiTheme } from '@material-ui/core/styles';\n import React from 'react';\n import ReactDOM from 'react-dom';\n import { ApolloProvider } from 'react-apollo-hooks';\n@@ -12,18 +12,16 @@ const theme = createMuiTheme({\n     primary: { main: '#2c6157' },\n     secondary: { main: '#6fd056' },\n   },\n-  typography: {\n-    useNextVariants: true,\n-  },\n-})\n+});\n\n ReactDOM.render(\n   <MuiThemeProvider theme={theme}>\n     <ApolloProvider client={client}>\n       <App />\n     </ApolloProvider>\n-  </MuiThemeProvider>\n-, document.getElementById('root'));\n+  </MuiThemeProvider>,\n+  document.getElementById('root')\n+);\n\n // If you want your app to work offline and load faster, you can change\n // unregister() to register() below. Note this comes with some pitfalls.\ndiff --git a/client/src/react-app-env.d.ts b/client/src/react-app-env.d.ts\nindex c148f59..048e7ba 100644\n--- a/client/src/react-app-env.d.ts\n+++ b/client/src/react-app-env.d.ts\n@@ -1,3 +1,3 @@\n /// <reference types=\"react-scripts\" />\n\n-declare module \"react-router-transition\";\n\\ No newline at end of file\n+declare module 'react-router-transition';\ndiff --git a/client/src/services/auth.service.tsx b/client/src/services/auth.service.tsx\nindex 8ae9e7f..9d021ef 100644\n--- a/client/src/services/auth.service.tsx\n+++ b/client/src/services/auth.service.tsx\n@@ -1,29 +1,29 @@\n import React from 'react';\n-import { useContext } from 'react';\n+import { useContext, useCallback } from 'react';\n+import { useApolloClient } from 'react-apollo-hooks';\n import { Redirect } from 'react-router-dom';\n-import client from '../client';\n-import { useMeQuery, User } from '../graphql/types';\n+import { useMeQuery, User, useSignInMutation, useSignUpMutation } from '../graphql/types';\n import { useCacheService } from './cache.service';\n-import gql from 'graphql-tag';\n\n-const MyContext = React.createContext<User|null>(null);\n+const MyContext = React.createContext<User | null>(null);\n\n export const useMe = () => {\n   return useContext(MyContext);\n };\n\n-export const withAuth = <P extends object>(Component: React.ComponentType<P>) => {\n+export const withAuth = <P extends object>(\n+  Component: React.ComponentType<P>\n+) => {\n   return (props: any) => {\n     if (!isSignedIn()) {\n       if (props.history.location.pathname === '/sign-in') {\n         return null;\n       }\n\n-      return (\n-        <Redirect to=\"/sign-in\" />\n-      );\n+      return <Redirect to=\"/sign-in\" />;\n     }\n\n+    const signOut = useSignOut();\n     const { data, error, loading } = useMeQuery();\n\n     useCacheService();\n@@ -46,45 +46,20 @@ export const withAuth = <P extends object>(Component: React.ComponentType<P>) =>\n   };\n };\n\n-export const signIn = ({ username, password }: { username: string, password: string}) => {\n-  return client.mutate({\n-    mutation: gql`\n-      mutation signIn($username: String!, $password: String!) {\n-        signIn(username: $username, password: $password) {\n-          id\n-        }\n-      }\n-    `,\n-    variables: {\n-      username,\n-      password\n-    }\n-  });\n-};\n+export const useSignIn = useSignInMutation;\n+export const useSignUp = useSignUpMutation;\n\n-export const signUp = ({ name, username, password, passwordConfirm }:\n-  {name: string, username: string, password: string, passwordConfirm: string}) => {\n-  return client.mutate({\n-    mutation: gql`\n-      mutation signUp($name: String!, $username: String!, $password: String!, $passwordConfirm: String!) {\n-        signUp(name: $name, username: $username, password: $password, passwordConfirm: $passwordConfirm) {\n-          id\n-        }\n-      }\n-    `,\n-    variables: {\n-      name,\n-      username,\n-      password,\n-      passwordConfirm\n-    }\n-  });\n-};\n+export const useSignOut = () => {\n+  const client = useApolloClient()\n\n-export const signOut = () => {\n-  document.cookie = `authToken=;expires=${new Date(0)}`;\n+  return useCallback(() => {\n+    // \"expires\" represents the lifespan of a cookie. Beyond that date the cookie will\n+    // be deleted by the browser. \"expires\" cannot be viewed from \"document.cookie\"\n+    document.cookie = `authToken=;expires=${new Date(0)}`;\n\n-  return client.clearStore();\n+    // Clear cache\n+    return client.clearStore();\n+  }, [client])\n };\n\n export const isSignedIn = () => {\ndiff --git a/client/src/services/cache.service.ts b/client/src/services/cache.service.ts\nindex 0b54829..06ed21b 100644\n--- a/client/src/services/cache.service.ts\n+++ b/client/src/services/cache.service.ts\n@@ -19,7 +19,7 @@ export const useCacheService = () => {\n       if (data) {\n         writeMessage(client, data.messageAdded);\n       }\n-    }\n+    },\n   });\n\n   useChatAddedSubscription({\n@@ -27,7 +27,7 @@ export const useCacheService = () => {\n       if (data) {\n         writeChat(client, data.chatAdded);\n       }\n-    }\n+    },\n   });\n\n   useChatRemovedSubscription({\n@@ -35,7 +35,7 @@ export const useCacheService = () => {\n       if (data) {\n         eraseChat(client, data.chatRemoved);\n       }\n-    }\n+    },\n   });\n };\n\n@@ -45,21 +45,25 @@ export const writeMessage = (client: Client, message: MessageFragment) => {\n\n   const chatIdFromStore = defaultDataIdFromObject(message.chat);\n\n-  if (chatIdFromStore === null) { return; }\n+  if (chatIdFromStore === null) {\n+    return;\n+  }\n   try {\n     fullChat = client.readFragment<FullChat>({\n       id: chatIdFromStore,\n       fragment: fragments.fullChat,\n       fragmentName: 'FullChat',\n-    })\n+    });\n   } catch (e) {\n     return;\n   }\n\n-  if (fullChat === null || fullChat.messages === null) { return; }\n-  if (fullChat.messages.some((m: any) => m.id === message.id)) return;\n+  if (fullChat === null || fullChat.messages === null) {\n+    return;\n+  }\n+  if (fullChat.messages.messages.some((m: any) => m.id === message.id)) return;\n\n-  fullChat.messages.push(message);\n+  fullChat.messages.messages.push(message);\n   fullChat.lastMessage = message;\n\n   client.writeFragment({\n@@ -69,22 +73,22 @@ export const writeMessage = (client: Client, message: MessageFragment) => {\n     data: fullChat,\n   });\n\n-\n   let data;\n   try {\n     data = client.readQuery({\n       query: queries.chats,\n-    })\n+    });\n   } catch (e) {\n     return;\n-  };\n+  }\n\n-  if (data === undefined || data.chats === undefined) {\n+  if (!data || data === null) {\n+    return null;\n+  }\n+  if (!data.chats || data.chats === undefined) {\n     return null;\n   }\n-\n   const chats = data.chats;\n-  if (!chats) return;\n\n   const chatIndex = chats.findIndex((c: any) => {\n     if (message === null || message.chat === null) return -1;\n@@ -101,10 +105,9 @@ export const writeMessage = (client: Client, message: MessageFragment) => {\n     query: queries.chats,\n     data: { chats: chats },\n   });\n-}\n+};\n\n export const writeChat = (client: Client, chat: ChatFragment) => {\n-\n   const chatId = defaultDataIdFromObject(chat);\n   if (chatId === null) {\n     return;\n@@ -115,15 +118,15 @@ export const writeChat = (client: Client, chat: ChatFragment) => {\n     fragment: fragments.chat,\n     fragmentName: 'Chat',\n     data: chat,\n-  })\n+  });\n\n   let data;\n   try {\n     data = client.readQuery({\n       query: queries.chats,\n-    })\n+    });\n   } catch (e) {\n-    return;\n+    return;\n   }\n\n   if (!data) return;\n@@ -133,18 +136,18 @@ export const writeChat = (client: Client, chat: ChatFragment) => {\n   if (!chats) return;\n   if (chats.some((c: any) => c.id === chat.id)) return;\n\n-  chats.unshift(chat)\n+  chats.unshift(chat);\n\n   client.writeQuery({\n     query: queries.chats,\n     data: { chats },\n   });\n-}\n+};\n\n export const eraseChat = (client: Client, chatId: string) => {\n   const chatType = {\n     __typename: 'Chat',\n-    id: chatId\n+    id: chatId,\n   };\n\n   const chatIdFromObject = defaultDataIdFromObject(chatType);\n@@ -157,7 +160,7 @@ export const eraseChat = (client: Client, chatId: string) => {\n     fragment: fragments.fullChat,\n     fragmentName: 'FullChat',\n     data: null,\n-  })\n+  });\n\n   let data;\n   try {\n@@ -185,4 +188,4 @@ export const eraseChat = (client: Client, chatId: string) => {\n     query: queries.chats,\n     data: { chats: chats },\n   });\n-}\n+};\ndiff --git a/client/src/setupTests.ts b/client/src/setupTests.ts\nindex c42be90..065a1d2 100644\n--- a/client/src/setupTests.ts\n+++ b/client/src/setupTests.ts\n@@ -1,7 +1,7 @@\n-import 'jest-dom/extend-expect'\n-import { GlobalWithFetchMock } from 'jest-fetch-mock'\n-import { act } from 'react-testing-library'\n+import 'jest-dom/extend-expect';\n+import { GlobalWithFetchMock } from 'jest-fetch-mock';\n+import { act } from '@testing-library/react';\n\n-const customGlobal: GlobalWithFetchMock = global as GlobalWithFetchMock\n-customGlobal.fetch = require('jest-fetch-mock')\n-customGlobal.fetchMock = customGlobal.fetch\n+const customGlobal: GlobalWithFetchMock = global as GlobalWithFetchMock;\n+customGlobal.fetch = require('jest-fetch-mock');\n+customGlobal.fetchMock = customGlobal.fetch;\ndiff --git a/package.json b/package.json\nindex 008b058..6408034 100644\n--- a/package.json\n+++ b/package.json\n@@ -5,5 +5,23 @@\n   \"repository\": {\n     \"type\": \"git\",\n     \"url\": \"https://github.com/Urigo/WhatsApp-Clone-Tutorial.git\"\n-  }\n+  },\n+  \"keywords\": [\n+    \"chat\",\n+    \"whatsapp\",\n+    \"nodejs\",\n+    \"node\",\n+    \"postgres\",\n+    \"postgresql\",\n+    \"sql\",\n+    \"graphql\",\n+    \"typescript\",\n+    \"javascript\",\n+    \"react\",\n+    \"reactjs\",\n+    \"fullstack\",\n+    \"websocket\",\n+    \"socketio\",\n+    \"performance\"\n+  ]\n }\ndiff --git a/server/.circleci/config.yml b/server/.circleci/config.yml\nnew file mode 100644\nindex 0000000..a96d4fc\n--- /dev/null\n+++ b/server/.circleci/config.yml\n@@ -0,0 +1,33 @@\n+version: 2\n+jobs:\n+  build:\n+    working_directory: ~/server/\n+    docker:\n+      - image: circleci/node:12.4.0\n+      - image: postgres:11.3-alpine\n+        environment:\n+          POSTGRES_PASSWORD: testpassword\n+          POSTGRES_USER: testuser\n+          POSTGRES_DB: whatsapp\n+    steps:\n+      - checkout\n+      - restore_cache:\n+          name: Restore Yarn Package Cache\n+          keys:\n+            - yarn-packages-{{ checksum \"yarn.lock\" }}\n+      - run:\n+          name: Install Dependencies\n+          command: yarn\n+      - run:\n+          name: Build\n+          command: yarn build\n+      - run:\n+          name: Test\n+          command: yarn test\n+      - store_test_results:\n+          path: test-results\n+      - save_cache:\n+          name: Save Yarn Package Cache\n+          key: yarn-packages-{{ checksum \"yarn.lock\" }}\n+          paths:\n+            - ~/.cache/yarn\n\\ No newline at end of file\ndiff --git a/server/.gitignore b/server/.gitignore\nindex ba92242..979c3a7 100644\n--- a/server/.gitignore\n+++ b/server/.gitignore\n@@ -1,4 +1,6 @@\n+dist\n node_modules\n npm-debug.log\n+test-results/\n types/graphql.d.ts\n-types/unsplash.d.ts\n+types/unsplash.d.ts\n\\ No newline at end of file\ndiff --git a/server/.prettierignore b/server/.prettierignore\nnew file mode 100644\nindex 0000000..b512c09\n--- /dev/null\n+++ b/server/.prettierignore\n@@ -0,0 +1 @@\n+node_modules\n\\ No newline at end of file\ndiff --git a/server/.prettierrc.yml b/server/.prettierrc.yml\nnew file mode 100644\nindex 0000000..3250279\n--- /dev/null\n+++ b/server/.prettierrc.yml\n@@ -0,0 +1,4 @@\n+trailingComma: 'es5'\n+tabWidth: 2\n+singleQuote: true\n+parser: 'typescript'\ndiff --git a/server/app.ts b/server/app.ts\nindex 943a214..8f9038c 100644\n--- a/server/app.ts\n+++ b/server/app.ts\n@@ -1,15 +1,15 @@\n-import bodyParser from 'body-parser'\n-import cors from 'cors'\n-import cookieParser from 'cookie-parser'\n-import express from 'express'\n-import { origin } from './env'\n+import bodyParser from 'body-parser';\n+import cors from 'cors';\n+import cookieParser from 'cookie-parser';\n+import express from 'express';\n+import { origin } from './env';\n\n-export const app = express()\n+export const app = express();\n\n-app.use(cors({ credentials: true, origin }))\n-app.use(bodyParser.json())\n-app.use(cookieParser())\n+app.use(cors({ credentials: true, origin }));\n+app.use(bodyParser.json());\n+app.use(cookieParser());\n\n app.get('/_ping', (req, res) => {\n-  res.send('pong')\n-})\n+  res.send('pong');\n+});\ndiff --git a/server/artillery-limit.yml b/server/artillery-limit.yml\nnew file mode 100644\nindex 0000000..357786a\n--- /dev/null\n+++ b/server/artillery-limit.yml\n@@ -0,0 +1,77 @@\n+config:\n+  target: 'http://localhost:4000/graphql'\n+  phases:\n+    - duration: 120\n+      arrivalRate: 5\n+    - duration: 120\n+      arrivalRate: 10\n+    - duration: 300\n+      arrivalRate: 10\n+    - duration: 60\n+      arrivalRate: 100\n+scenarios:\n+  - name: 'Sign in, send a new message and fetch a list of chats'\n+    flow:\n+      - post:\n+          url: '/'\n+          json:\n+            variables:\n+              username: 'ray'\n+              password: '111'\n+            query: |\n+              mutation SignIn($username: String!, $password: String!) {\n+                signIn(username: $username, password: $password) {\n+                  id\n+                }\n+              }\n+      - post:\n+          url: '/'\n+          json:\n+            query: |\n+              mutation message {\n+                addMessage(chatId: \"1\", content: \"artillery\") {\n+                  id\n+                }\n+              }\n+      - post:\n+          url: '/'\n+          json:\n+            variables:\n+              limit: 20\n+            query: |\n+              fragment User on User {\n+                id\n+                name\n+                picture\n+              }\n+              fragment Message on Message {\n+                id\n+                content\n+                chat {\n+                  id\n+                }\n+                sender {\n+                  ...User\n+                }\n+                recipient {\n+                  ...User\n+                }\n+              }\n+              query GetChats($limit: Int!) {\n+                chats {\n+                  id\n+                  name\n+                  picture\n+                  lastMessage {\n+                    ...Message\n+                  }\n+                  messages(limit: $limit) {\n+                    messages {\n+                      ...Message\n+                    }\n+                  }\n+                  participants {\n+                    ...User\n+                  }\n+                }\n+              }\n\\ No newline at end of file\ndiff --git a/server/artillery.yml b/server/artillery.yml\nnew file mode 100644\nindex 0000000..b590173\n--- /dev/null\n+++ b/server/artillery.yml\n@@ -0,0 +1,72 @@\n+config:\n+  target: 'http://localhost:4000/graphql'\n+  phases:\n+    - duration: 120\n+      arrivalRate: 5\n+      rampTo: 20\n+scenarios:\n+  - name: 'Sign in, send a new message and fetch a list of chats'\n+    flow:\n+      - post:\n+          url: '/'\n+          json:\n+            variables:\n+              username: 'ray'\n+              password: '111'\n+            query: |\n+              mutation SignIn($username: String!, $password: String!) {\n+                signIn(username: $username, password: $password) {\n+                  id\n+                }\n+              }\n+      - post:\n+          url: '/'\n+          json:\n+            query: |\n+              mutation message {\n+                addMessage(chatId: \"1\", content: \"artillery\") {\n+                  id\n+                }\n+              }\n+      - post:\n+          url: '/'\n+          json:\n+            variables:\n+              limit: 20\n+            query: |\n+              fragment User on User {\n+                id\n+                name\n+                picture\n+              }\n+              fragment Message on Message {\n+                id\n+                content\n+                chat {\n+                  id\n+                }\n+                sender {\n+                  ...User\n+                }\n+                recipient {\n+                  ...User\n+                }\n+              }\n+              query GetChats($limit: Int!) {\n+                chats {\n+                  id\n+                  name\n+                  picture\n+                  lastMessage {\n+                    ...Message\n+                  }\n+                  messages(limit: $limit) {\n+                    messages {\n+                      ...Message\n+                    }\n+                  }\n+                  participants {\n+                    ...User\n+                  }\n+                }\n+              }\ndiff --git a/server/db.ts b/server/db.ts\nindex cd3c287..3411c00 100644\n--- a/server/db.ts\n+++ b/server/db.ts\n@@ -1,38 +1,78 @@\n-import { Pool } from \"pg\";\n-import sql from 'sql-template-strings'\n-import { resetDb as envResetDb } from './env'\n+import { Pool } from 'pg';\n+import sql from 'sql-template-strings';\n+import faker from 'faker';\n+import addMinutes from 'date-fns/add_minutes';\n+import { resetDb as envResetDb, fakedDb } from './env';\n\n export type User = {\n-  id: string\n-  name: string\n-  username: string\n-  password: string\n-  picture: string\n-}\n+  id: string;\n+  name: string;\n+  username: string;\n+  password: string;\n+  picture: string;\n+};\n\n export type Message = {\n-  id: string\n-  content: string\n-  created_at: Date\n-  chat_id: string\n-  sender_user_id: string\n-}\n+  id: string;\n+  content: string;\n+  created_at: Date;\n+  chat_id: string;\n+  sender_user_id: string;\n+};\n\n export type Chat = {\n-  id: string\n-}\n+  id: string;\n+};\n\n-export const pool = new Pool({\n+export const dbConfig = {\n   host: 'localhost',\n   port: 5432,\n   user: 'testuser',\n   password: 'testpassword',\n-  database: 'whatsapp'\n-})\n+  database: 'whatsapp',\n+};\n\n-export const resetDb = async () => {\n+export let pool: Pool = new Pool(dbConfig);\n\n-  await pool.query(sql`DELETE FROM users`)\n+export async function initDb(): Promise<void> {\n+  // Clear tables\n+  await pool.query(sql`DROP TABLE IF EXISTS messages;`);\n+  await pool.query(sql`DROP TABLE IF EXISTS chats_users;`);\n+  await pool.query(sql`DROP TABLE IF EXISTS users;`);\n+  await pool.query(sql`DROP TABLE IF EXISTS chats;`);\n+\n+  // Create tables\n+  await pool.query(sql`CREATE TABLE chats(\n+    id SERIAL PRIMARY KEY\n+  );`);\n+  await pool.query(sql`CREATE TABLE users(\n+    id SERIAL PRIMARY KEY,\n+    username VARCHAR (50) UNIQUE NOT NULL,\n+    name VARCHAR (50) NOT NULL,\n+    password VARCHAR (255) NOT NULL,\n+    picture VARCHAR (255) NOT NULL\n+  );`);\n+  await pool.query(sql`CREATE TABLE chats_users(\n+    chat_id INTEGER NOT NULL REFERENCES chats(id) ON DELETE CASCADE,\n+    user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE\n+  );`);\n+\n+  await pool.query(sql`CREATE TABLE messages(\n+    id SERIAL PRIMARY KEY,\n+    content VARCHAR (355) NOT NULL,\n+    created_at TIMESTAMP NOT NULL DEFAULT NOW(),\n+    chat_id INTEGER NOT NULL REFERENCES chats(id) ON DELETE CASCADE,\n+    sender_user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE\n+  );`);\n+\n+  // Privileges\n+  await pool.query(\n+    sql`GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO testuser;`\n+  );\n+}\n+\n+export const resetDb = async () => {\n+  await initDb();\n\n   const sampleUsers = [\n     {\n@@ -70,18 +110,26 @@ export const resetDb = async () => {\n       password: '$2a$08$6.mbXqsDX82ZZ7q5d8Osb..JrGSsNp4R3IKj7mxgF6YGT0OmMw242', // 555\n       picture: 'https://randomuser.me/api/portraits/thumb/women/2.jpg',\n     },\n-  ]\n+  ];\n\n   for (const sampleUser of sampleUsers) {\n     await pool.query(sql`\n       INSERT INTO users(id, name, username, password, picture)\n-      VALUES(${sampleUser.id}, ${sampleUser.name}, ${sampleUser.username}, ${sampleUser.password}, ${sampleUser.picture})\n-    `)\n+      VALUES(${sampleUser.id}, ${sampleUser.name}, ${sampleUser.username}, ${\n+      sampleUser.password\n+    }, ${sampleUser.picture})\n+    `);\n   }\n\n-  await pool.query(sql`SELECT setval('users_id_seq', (SELECT max(id) FROM users))`)\n+  await pool.query(\n+    sql`SELECT setval('users_id_seq', (SELECT max(id) FROM users))`\n+  );\n\n-  await pool.query(sql`DELETE FROM chats`)\n+  await pool.query(\n+    sql`SELECT setval('users_id_seq', (SELECT max(id) FROM users))`\n+  );\n+\n+  await pool.query(sql`DELETE FROM chats`);\n\n   const sampleChats = [\n     {\n@@ -96,18 +144,20 @@ export const resetDb = async () => {\n     {\n       id: '4',\n     },\n-  ]\n+  ];\n\n   for (const sampleChat of sampleChats) {\n     await pool.query(sql`\n       INSERT INTO chats(id)\n       VALUES(${sampleChat.id})\n-    `)\n+    `);\n   }\n\n-  await pool.query(sql`SELECT setval('chats_id_seq', (SELECT max(id) FROM chats))`)\n+  await pool.query(\n+    sql`SELECT setval('chats_id_seq', (SELECT max(id) FROM chats))`\n+  );\n\n-  await pool.query(sql`DELETE FROM chats_users`)\n+  await pool.query(sql`DELETE FROM chats_users`);\n\n   const sampleChatsUsers = [\n     {\n@@ -142,59 +192,83 @@ export const resetDb = async () => {\n       chat_id: '4',\n       user_id: '5',\n     },\n-  ]\n+  ];\n\n   for (const sampleChatUser of sampleChatsUsers) {\n     await pool.query(sql`\n       INSERT INTO chats_users(chat_id, user_id)\n       VALUES(${sampleChatUser.chat_id}, ${sampleChatUser.user_id})\n-    `)\n+    `);\n   }\n\n-  await pool.query(sql`DELETE FROM messages`)\n+  await pool.query(sql`DELETE FROM messages`);\n+\n+  const baseTime = new Date('1 Jan 2019 GMT').getTime();\n\n   const sampleMessages = [\n     {\n       id: '1',\n-      content: \"You on your way?\",\n-      created_at: new Date(new Date('1-1-2019').getTime() - 60 * 1000 * 1000),\n+      content: 'You on your way?',\n+      created_at: new Date(baseTime - 60 * 1000 * 1000),\n       chat_id: '1',\n       sender_user_id: '1',\n     },\n     {\n       id: '2',\n       content: \"Hey, it's me\",\n-      created_at: new Date(new Date('1-1-2019').getTime() - 2 * 60 * 1000 * 1000),\n+      created_at: new Date(baseTime - 2 * 60 * 1000 * 1000),\n       chat_id: '2',\n       sender_user_id: '1',\n     },\n     {\n       id: '3',\n-      content: \"I should buy a boat\",\n-      created_at: new Date(new Date('1-1-2019').getTime() - 24 * 60 * 1000 * 1000),\n+      content: 'I should buy a boat',\n+      created_at: new Date(baseTime - 24 * 60 * 1000 * 1000),\n       chat_id: '3',\n       sender_user_id: '1',\n     },\n     {\n       id: '4',\n-      content: \"This is wicked good ice cream.\",\n-      created_at: new Date(new Date('1-1-2019').getTime() - 14 * 24 * 60 * 1000 * 1000),\n+      content: 'This is wicked good ice cream.',\n+      created_at: new Date(baseTime - 14 * 24 * 60 * 1000 * 1000),\n       chat_id: '4',\n       sender_user_id: '1',\n     },\n-  ]\n+  ];\n+\n+  if (fakedDb) {\n+    addFakedMessages(sampleMessages, fakedDb);\n+  }\n\n   for (const sampleMessage of sampleMessages) {\n     await pool.query(sql`\n       INSERT INTO messages(id, content, created_at, chat_id, sender_user_id)\n-      VALUES(${sampleMessage.id}, ${sampleMessage.content}, ${sampleMessage.created_at}, ${sampleMessage.chat_id}, ${sampleMessage.sender_user_id})\n-    `)\n+      VALUES(${sampleMessage.id}, ${sampleMessage.content}, ${\n+      sampleMessage.created_at\n+    }, ${sampleMessage.chat_id}, ${sampleMessage.sender_user_id})\n+    `);\n   }\n\n-  await pool.query(sql`SELECT setval('messages_id_seq', (SELECT max(id) FROM messages))`)\n+  await pool.query(\n+    sql`SELECT setval('messages_id_seq', (SELECT max(id) FROM messages))`\n+  );\n+};\n+\n+function addFakedMessages(messages: Message[], count: number) {\n+  const message = messages[0];\n+  const date = message.created_at;\n+  const id = messages.length + 1;\n\n+  new Array(count).fill(0).forEach((_, i) => {\n+    messages.push({\n+      ...message,\n+      id: `${id + i}`,\n+      content: faker.lorem.sentence(4),\n+      created_at: addMinutes(date, i + 1),\n+    });\n+  });\n }\n\n if (envResetDb) {\n-  resetDb()\n+  resetDb();\n }\ndiff --git a/server/env.ts b/server/env.ts\nindex d6b5023..b9c6573 100644\n--- a/server/env.ts\n+++ b/server/env.ts\n@@ -1,7 +1,10 @@\n export const expiration = process.env.JWT_EXPIRATION_MS\n-  ?  parseInt(process.env.JWT_EXPIRATION_MS)\n-  : 24 * 60 * 60 * 1000\n-export const secret = process.env.JWT_SECRET || '70p53cr37'\n-export const origin = process.env.ORIGIN || 'http://localhost:3000'\n-export const port = process.env.PORT || 4000\n+  ? parseInt(process.env.JWT_EXPIRATION_MS)\n+  : 24 * 60 * 60 * 1000;\n+export const secret = process.env.JWT_SECRET || '70p53cr37';\n+export const origin = process.env.ORIGIN || 'http://localhost:3000';\n+export const port = process.env.PORT || 4000;\n export const resetDb = process.env.RESET_DB || false;\n+export const fakedDb = process.env.FAKED_DB\n+  ? parseInt(process.env.FAKED_DB, 10)\n+  : 0;\ndiff --git a/server/index.ts b/server/index.ts\nindex 39dd8b0..72d5893 100644\n--- a/server/index.ts\n+++ b/server/index.ts\n@@ -1,17 +1,17 @@\n-import http from 'http'\n-import { app } from './app'\n-import { origin, port } from './env'\n+import http from 'http';\n+import { app } from './app';\n+import { origin, port } from './env';\n import { server } from './server';\n\n server.applyMiddleware({\n   app,\n   path: '/graphql',\n   cors: { credentials: true, origin },\n-})\n+});\n\n-const httpServer = http.createServer(app)\n-server.installSubscriptionHandlers(httpServer)\n+const httpServer = http.createServer(app);\n+server.installSubscriptionHandlers(httpServer);\n\n httpServer.listen(port, () => {\n-  console.log(`Server is listening on port ${port}`)\n-})\n+  console.log(`Server is listening on port ${port}`);\n+});\ndiff --git a/server/modules/chats/chats.provider.ts b/server/modules/chats/chats.provider.ts\nindex 3659604..9ecf6bc 100644\n--- a/server/modules/chats/chats.provider.ts\n+++ b/server/modules/chats/chats.provider.ts\n@@ -1,7 +1,24 @@\n import { Injectable, Inject, ProviderScope } from '@graphql-modules/di';\n+import { QueryResult } from 'pg';\n import sql from 'sql-template-strings';\n+import DataLoader from 'dataloader';\n+import format from 'date-fns/format';\n import { Database } from '../common/database.provider';\n import { PubSub } from '../common/pubsub.provider';\n+import { Chat } from '../../db';\n+\n+type ChatsByUser = { userId: string };\n+type ChatByUser = { userId: string; chatId: string };\n+type ChatById = { chatId: string };\n+type ChatsKey = ChatById | ChatByUser | ChatsByUser;\n+\n+function isChatsByUser(query: any): query is ChatsByUser {\n+  return query.userId && !query.chatId;\n+}\n+\n+function isChatByUser(query: any): query is ChatByUser {\n+  return query.userId && query.chatId;\n+}\n\n @Injectable({\n   scope: ProviderScope.Session,\n@@ -10,50 +27,140 @@ export class Chats {\n   @Inject() private db: Database;\n   @Inject() private pubsub: PubSub;\n\n+  private chatsCache = new Map<string, Chat>();\n+  private loaders = {\n+    chats: new DataLoader<ChatsKey, QueryResult['rows']>(keys => {\n+      return Promise.all(\n+        keys.map(async query => {\n+          if (isChatsByUser(query)) {\n+            return this._findChatsByUser(query.userId);\n+          }\n+\n+          if (this.chatsCache.has(query.chatId)) {\n+            return [this._readChatFromCache(query.chatId)];\n+          }\n+\n+          if (isChatByUser(query)) {\n+            return this._findChatByUser(query);\n+          }\n+\n+          return this._findChatById(query.chatId);\n+        })\n+      );\n+    }),\n+  };\n+\n   async findChatsByUser(userId: string) {\n-    const db = await this.db.getClient();\n+    return this.loaders.chats.load({ userId });\n+  }\n\n-    const { rows } = await db.query(sql`\n+  private async _findChatsByUser(userId: string) {\n+    const { rows } = await this.db.query(sql`\n       SELECT chats.* FROM chats, chats_users\n       WHERE chats.id = chats_users.chat_id\n       AND chats_users.user_id = ${userId}\n     `);\n\n+    rows.forEach(row => {\n+      this._writeChatToCache(row);\n+    });\n+\n     return rows;\n   }\n\n   async findChatByUser({ chatId, userId }: { chatId: string; userId: string }) {\n-    const db = await this.db.getClient();\n-    const { rows } = await db.query(sql`\n+    const rows = await this.loaders.chats.load({ chatId, userId });\n+\n+    return rows[0] || null;\n+  }\n+\n+  private async _findChatByUser({\n+    chatId,\n+    userId,\n+  }: {\n+    chatId: string;\n+    userId: string;\n+  }) {\n+    const { rows } = await this.db.query(sql`\n       SELECT chats.* FROM chats, chats_users\n       WHERE chats_users.chat_id = ${chatId}\n       AND chats.id = chats_users.chat_id\n       AND chats_users.user_id = ${userId}\n     `);\n\n-    return rows[0] || null;\n+    this._writeChatToCache(rows[0]);\n+\n+    return rows;\n   }\n\n   async findChatById(chatId: string) {\n-    const db = await this.db.getClient();\n-    const { rows } = await db.query(sql`\n+    const rows = await this.loaders.chats.load({ chatId });\n+    return rows[0] || null;\n+  }\n+\n+  private async _findChatById(chatId: string) {\n+    const { rows } = await this.db.query(sql`\n       SELECT * FROM chats WHERE id = ${chatId}\n     `);\n-    return rows[0] || null;\n+\n+    this._writeChatToCache(rows[0]);\n+\n+    return rows;\n   }\n\n-  async findMessagesByChat(chatId: string) {\n-    const db = await this.db.getClient();\n-    const { rows } = await db.query(\n-      sql`SELECT * FROM messages WHERE chat_id = ${chatId}`,\n+  async findMessagesByChat({\n+    chatId,\n+    limit,\n+    after,\n+  }: {\n+    chatId: string;\n+    limit: number;\n+    after?: number | null;\n+  }): Promise<{\n+    hasMore: boolean;\n+    cursor: number | null;\n+    messages: any[];\n+  }> {\n+    const query = sql`SELECT * FROM messages`;\n+    query.append(` WHERE chat_id = ${chatId}`);\n+\n+    if (after) {\n+      // the created_at is the cursor\n+      query.append(` AND created_at < ${cursorToDate(after)}`);\n+    }\n+\n+    query.append(` ORDER BY created_at DESC LIMIT ${limit}`);\n+\n+    const { rows: messages } = await this.db.query(query);\n+\n+    if (!messages) {\n+      return {\n+        hasMore: false,\n+        cursor: null,\n+        messages: [],\n+      };\n+    }\n+\n+    // so we send them as old -> new\n+    messages.reverse();\n+\n+    // cursor is a number representation of created_at\n+    const cursor = messages.length ? new Date(messages[0].created_at).getTime() : 0;\n+    const { rows: next } = await this.db.query(\n+      sql`SELECT * FROM messages WHERE chat_id = ${chatId} AND created_at < ${cursorToDate(\n+        cursor\n+      )} ORDER BY created_at DESC LIMIT 1`\n     );\n\n-    return rows;\n+    return {\n+      hasMore: next.length === 1, // means there's no more messages\n+      cursor,\n+      messages,\n+    };\n   }\n\n   async lastMessage(chatId: string) {\n-    const db = await this.db.getClient();\n-    const { rows } = await db.query(sql`\n+    const { rows } = await this.db.query(sql`\n       SELECT * FROM messages\n       WHERE chat_id = ${chatId}\n       ORDER BY created_at DESC\n@@ -64,8 +171,7 @@ export class Chats {\n   }\n\n   async firstRecipient({ chatId, userId }: { chatId: string; userId: string }) {\n-    const db = await this.db.getClient();\n-    const { rows } = await db.query(sql`\n+    const { rows } = await this.db.query(sql`\n       SELECT users.* FROM users, chats_users\n       WHERE users.id != ${userId}\n       AND users.id = chats_users.user_id\n@@ -76,8 +182,7 @@ export class Chats {\n   }\n\n   async participants(chatId: string) {\n-    const db = await this.db.getClient();\n-    const { rows } = await db.query(sql`\n+    const { rows } = await this.db.query(sql`\n       SELECT users.* FROM users, chats_users\n       WHERE chats_users.chat_id = ${chatId}\n       AND chats_users.user_id = users.id\n@@ -87,8 +192,7 @@ export class Chats {\n   }\n\n   async isParticipant({ chatId, userId }: { chatId: string; userId: string }) {\n-    const db = await this.db.getClient();\n-    const { rows } = await db.query(sql`\n+    const { rows } = await this.db.query(sql`\n       SELECT * FROM chats_users\n       WHERE chat_id = ${chatId}\n       AND user_id = ${userId}\n@@ -106,8 +210,7 @@ export class Chats {\n     userId: string;\n     content: string;\n   }) {\n-    const db = await this.db.getClient();\n-    const { rows } = await db.query(sql`\n+    const { rows } = await this.db.query(sql`\n       INSERT INTO messages(chat_id, sender_user_id, content)\n       VALUES(${chatId}, ${userId}, ${content})\n       RETURNING *\n@@ -129,8 +232,7 @@ export class Chats {\n     userId: string;\n     recipientId: string;\n   }) {\n-    const db = await this.db.getClient();\n-    const { rows } = await db.query(sql`\n+    const { rows } = await this.db.query(sql`\n       SELECT chats.* FROM chats, (SELECT * FROM chats_users WHERE user_id = ${userId}) AS chats_of_current_user, chats_users\n       WHERE chats_users.chat_id = chats_of_current_user.chat_id\n       AND chats.id = chats_users.chat_id\n@@ -143,9 +245,9 @@ export class Chats {\n     }\n\n     try {\n-      await db.query('BEGIN');\n+      await this.db.query('BEGIN');\n\n-      const { rows } = await db.query(sql`\n+      const { rows } = await this.db.query(sql`\n         INSERT INTO chats\n         DEFAULT VALUES\n         RETURNING *\n@@ -153,17 +255,17 @@ export class Chats {\n\n       const chatAdded = rows[0];\n\n-      await db.query(sql`\n+      await this.db.query(sql`\n         INSERT INTO chats_users(chat_id, user_id)\n         VALUES(${chatAdded.id}, ${userId})\n       `);\n\n-      await db.query(sql`\n+      await this.db.query(sql`\n         INSERT INTO chats_users(chat_id, user_id)\n         VALUES(${chatAdded.id}, ${recipientId})\n       `);\n\n-      await db.query('COMMIT');\n+      await this.db.query('COMMIT');\n\n       this.pubsub.publish('chatAdded', {\n         chatAdded,\n@@ -171,18 +273,16 @@ export class Chats {\n\n       return chatAdded;\n     } catch (e) {\n-      await db.query('ROLLBACK');\n+      await this.db.query('ROLLBACK');\n       throw e;\n     }\n   }\n\n   async removeChat({ chatId, userId }: { chatId: string; userId: string }) {\n-    const db = await this.db.getClient();\n-\n     try {\n-      await db.query('BEGIN');\n+      await this.db.query('BEGIN');\n\n-      const { rows } = await db.query(sql`\n+      const { rows } = await this.db.query(sql`\n         SELECT chats.* FROM chats, chats_users\n         WHERE id = ${chatId}\n         AND chats.id = chats_users.chat_id\n@@ -192,11 +292,11 @@ export class Chats {\n       const chat = rows[0];\n\n       if (!chat) {\n-        await db.query('ROLLBACK');\n+        await this.db.query('ROLLBACK');\n         return null;\n       }\n\n-      await db.query(sql`\n+      await this.db.query(sql`\n         DELETE FROM chats WHERE chats.id = ${chatId}\n       `);\n\n@@ -205,12 +305,26 @@ export class Chats {\n         targetChat: chat,\n       });\n\n-      await db.query('COMMIT');\n+      await this.db.query('COMMIT');\n\n       return chatId;\n     } catch (e) {\n-      await db.query('ROLLBACK');\n+      await this.db.query('ROLLBACK');\n       throw e;\n     }\n   }\n+\n+  private _readChatFromCache(chatId: string) {\n+    return this.chatsCache.get(chatId);\n+  }\n+\n+  private _writeChatToCache(chat?: Chat) {\n+    if (chat) {\n+      this.chatsCache.set(chat.id, chat);\n+    }\n+  }\n+}\n+\n+function cursorToDate(cursor: number) {\n+  return `'${format(cursor, 'YYYY-MM-DD HH:mm:ss')}'`;\n }\ndiff --git a/server/modules/chats/index.ts b/server/modules/chats/index.ts\nindex a8dd8ff..708b6ab 100644\n--- a/server/modules/chats/index.ts\n+++ b/server/modules/chats/index.ts\n@@ -21,12 +21,18 @@ const typeDefs = gql`\n     isMine: Boolean!\n   }\n\n+  type MessagesResult {\n+    cursor: Float\n+    hasMore: Boolean!\n+    messages: [Message!]!\n+  }\n+\n   type Chat {\n     id: ID!\n     name: String\n     picture: String\n     lastMessage: Message\n-    messages: [Message!]!\n+    messages(limit: Int!, after: Float): MessagesResult!\n     participants: [User!]!\n   }\n\n@@ -105,7 +111,11 @@ const resolvers: Resolvers = {\n     },\n\n     async messages(chat, args, { injector }) {\n-      return injector.get(Chats).findMessagesByChat(chat.id);\n+      return injector.get(Chats).findMessagesByChat({\n+        chatId: chat.id,\n+        limit: args.limit,\n+        after: args.after,\n+      });\n     },\n\n     async lastMessage(chat, args, { injector }) {\n@@ -120,7 +130,7 @@ const resolvers: Resolvers = {\n   Query: {\n     async chats(root, args, { injector }) {\n       const currentUser = await injector.get(Auth).currentUser();\n-\n+\n       if (!currentUser) return [];\n\n       return injector.get(Chats).findChatsByUser(currentUser.id);\n@@ -150,7 +160,7 @@ const resolvers: Resolvers = {\n\n     async addChat(root, { recipientId }, { injector }) {\n       const currentUser = await injector.get(Auth).currentUser();\n-\n+\n       if (!currentUser) return null;\n\n       return injector\n@@ -175,7 +185,7 @@ const resolvers: Resolvers = {\n         async (\n           { messageAdded }: { messageAdded: Message },\n           args,\n-          { injector },\n+          { injector }\n         ) => {\n           const currentUser = await injector.get(Auth).currentUser();\n\n@@ -185,7 +195,7 @@ const resolvers: Resolvers = {\n             chatId: messageAdded.chat_id,\n             userId: currentUser.id,\n           });\n-        },\n+        }\n       ),\n     },\n\n@@ -193,11 +203,7 @@ const resolvers: Resolvers = {\n       subscribe: withFilter(\n         (root, args, { injector }) =>\n           injector.get(PubSub).asyncIterator('chatAdded'),\n-        async (\n-          { chatAdded }: { chatAdded: Chat },\n-          args,\n-          { injector },\n-        ) => {\n+        async ({ chatAdded }: { chatAdded: Chat }, args, { injector }) => {\n           const currentUser = await injector.get(Auth).currentUser();\n\n           if (!currentUser) return false;\n@@ -206,7 +212,7 @@ const resolvers: Resolvers = {\n             chatId: chatAdded.id,\n             userId: currentUser.id,\n           });\n-        },\n+        }\n       ),\n     },\n\n@@ -214,20 +220,16 @@ const resolvers: Resolvers = {\n       subscribe: withFilter(\n         (root, args, { injector }) =>\n           injector.get(PubSub).asyncIterator('chatRemoved'),\n-        async (\n-          { targetChat }: { targetChat: Chat },\n-          args,\n-          { injector },\n-        ) => {\n+        async ({ targetChat }: { targetChat: Chat }, args, { injector }) => {\n           const currentUser = await injector.get(Auth).currentUser();\n-\n+\n           if (!currentUser) return false;\n\n           return injector.get(Chats).isParticipant({\n             chatId: targetChat.id,\n             userId: currentUser.id,\n           });\n-        },\n+        }\n       ),\n     },\n   },\ndiff --git a/server/modules/chats/unsplash.api.ts b/server/modules/chats/unsplash.api.ts\nindex cb993f0..7b08c81 100644\n--- a/server/modules/chats/unsplash.api.ts\n+++ b/server/modules/chats/unsplash.api.ts\n@@ -36,7 +36,7 @@ export class UnsplashApi {\n         provider: 'Unsplash',\n         method: 'RandomPhoto',\n         location: resolve(__dirname, '../logs/main'),\n-      },\n+      }\n     );\n\n     try {\ndiff --git a/server/modules/common/database.provider.ts b/server/modules/common/database.provider.ts\nindex 4e72c6a..6798a4e 100644\n--- a/server/modules/common/database.provider.ts\n+++ b/server/modules/common/database.provider.ts\n@@ -1,14 +1,41 @@\n import { Injectable, ProviderScope } from '@graphql-modules/di';\n import { OnResponse } from '@graphql-modules/core';\n-import { Pool, PoolClient } from 'pg';\n+import { Pool, PoolClient, QueryResult } from 'pg';\n+import { SQLStatement } from 'sql-template-strings';\n+import Dataloader from 'dataloader';\n\n @Injectable({\n   scope: ProviderScope.Session,\n })\n export class Database implements OnResponse {\n   private instance: PoolClient;\n+  private loader: Dataloader<string | SQLStatement, QueryResult>;\n\n-  constructor(private pool: Pool) {}\n+  constructor(private pool: Pool) {\n+    this.loader = new Dataloader(\n+      queries =>\n+        Promise.all(\n+          queries.map(async query => {\n+            const db = await this.getClient();\n+            return db.query(query);\n+          })\n+        ),\n+      {\n+        cacheKeyFn: (key: string | SQLStatement) => {\n+          let id: string;\n+\n+          if (typeof key === 'string') {\n+            id = key;\n+          } else {\n+            id = key.text + ' - ' + JSON.stringify(key.values);\n+          }\n+\n+          return id;\n+        },\n+        batch: false,\n+      }\n+    );\n+  }\n\n   async onRequest() {\n     this.instance = await this.pool.connect();\n@@ -20,7 +47,11 @@ export class Database implements OnResponse {\n     }\n   }\n\n-  async getClient() {\n+  private getClient() {\n     return this.instance;\n   }\n-}\n\\ No newline at end of file\n+\n+  query(query: SQLStatement | string) {\n+    return this.loader.load(query);\n+  }\n+}\ndiff --git a/server/modules/common/pubsub.provider.ts b/server/modules/common/pubsub.provider.ts\nindex d1455e2..cf85ba4 100644\n--- a/server/modules/common/pubsub.provider.ts\n+++ b/server/modules/common/pubsub.provider.ts\n@@ -1 +1 @@\n-export { PubSub } from 'apollo-server-express';\n\\ No newline at end of file\n+export { PubSub } from 'apollo-server-express';\ndiff --git a/server/modules/users/auth.provider.ts b/server/modules/users/auth.provider.ts\nindex a781b82..c3bd604 100644\n--- a/server/modules/users/auth.provider.ts\n+++ b/server/modules/users/auth.provider.ts\n@@ -14,9 +14,10 @@ import { User } from '../../db';\n export class Auth {\n   @Inject() private users: Users;\n   @Inject() private module: ModuleSessionInfo;\n+  private _currentUser: User;\n\n   private get req() {\n-    return this.module.session.req;\n+    return this.module.session.req || this.module.session.request;\n   }\n\n   private get res(): Response {\n@@ -74,16 +75,21 @@ export class Auth {\n       password,\n     });\n   }\n-\n+\n   async currentUser(): Promise<User | null> {\n+    if (this._currentUser) {\n+      return this._currentUser;\n+    }\n+\n     if (this.req.cookies.authToken) {\n       const username = jwt.verify(this.req.cookies.authToken, secret) as string;\n\n       if (username) {\n-        return this.users.findByUsername(username);\n+        this._currentUser = await this.users.findByUsername(username);\n+        return this._currentUser;\n       }\n     }\n\n     return null;\n   }\n-}\n\\ No newline at end of file\n+}\ndiff --git a/server/modules/users/index.ts b/server/modules/users/index.ts\nindex 93e30ea..74f7601 100644\n--- a/server/modules/users/index.ts\n+++ b/server/modules/users/index.ts\n@@ -35,7 +35,7 @@ const resolvers: Resolvers = {\n     },\n     async users(root, args, { injector }) {\n       const currentUser = await injector.get(Auth).currentUser();\n-\n+\n       if (!currentUser) return [];\n\n       return injector.get(Users).findAllExcept(currentUser.id);\n@@ -43,11 +43,17 @@ const resolvers: Resolvers = {\n   },\n   Mutation: {\n     async signIn(root, { username, password }, { injector }) {\n-      return injector.get(Auth).signIn({username, password});\n+      return injector.get(Auth).signIn({ username, password });\n     },\n\n-    async signUp(root, { name, username, password, passwordConfirm }, { injector }) {\n-      return injector.get(Auth).signUp({name, username, password, passwordConfirm });\n+    async signUp(\n+      root,\n+      { name, username, password, passwordConfirm },\n+      { injector }\n+    ) {\n+      return injector\n+        .get(Auth)\n+        .signUp({ name, username, password, passwordConfirm });\n     },\n   },\n };\n@@ -57,5 +63,5 @@ export default new GraphQLModule({\n   typeDefs,\n   resolvers,\n   imports: () => [commonModule],\n-  providers: () => [Users, Auth]\n+  providers: () => [Users, Auth],\n });\ndiff --git a/server/modules/users/users.provider.ts b/server/modules/users/users.provider.ts\nindex daf32fd..2651863 100644\n--- a/server/modules/users/users.provider.ts\n+++ b/server/modules/users/users.provider.ts\n@@ -3,6 +3,8 @@ import sql from 'sql-template-strings';\n import bcrypt from 'bcrypt';\n import { Database } from '../common/database.provider';\n\n+const DEFAULT_PROFILE_PIC = 'https://raw.githubusercontent.com/Urigo/WhatsApp-Clone-Client-React/legacy/public/assets/default-profile-pic.jpg'\n+\n @Injectable({\n   scope: ProviderScope.Session,\n })\n@@ -10,27 +12,24 @@ export class Users {\n   @Inject() private db: Database;\n\n   async findById(userId: string) {\n-    const db = await this.db.getClient();\n-    const { rows } = await db.query(\n-      sql`SELECT * FROM users WHERE id = ${userId}`,\n+    const { rows } = await this.db.query(\n+      sql`SELECT * FROM users WHERE id = ${userId}`\n     );\n\n     return rows[0] || null;\n   }\n\n   async findAllExcept(userId: string) {\n-    const db = await this.db.getClient();\n-    const { rows } = await db.query(\n-      sql`SELECT * FROM users WHERE id != ${userId}`,\n+    const { rows } = await this.db.query(\n+      sql`SELECT * FROM users WHERE id != ${userId}`\n     );\n\n     return rows;\n   }\n\n   async findByUsername(username: string) {\n-    const db = await this.db.getClient();\n-    const { rows } = await db.query(\n-      sql`SELECT * FROM users WHERE username = ${username}`,\n+    const { rows } = await this.db.query(\n+      sql`SELECT * FROM users WHERE username = ${username}`\n     );\n\n     return rows[0] || null;\n@@ -45,15 +44,14 @@ export class Users {\n     name: string;\n     password: string;\n   }) {\n-    const db = await this.db.getClient();\n     const passwordHash = bcrypt.hashSync(password, bcrypt.genSaltSync(8));\n-    const createdUserQuery = await db.query(sql`\n+    const createdUserQuery = await this.db.query(sql`\n         INSERT INTO users(password, picture, username, name)\n-        VALUES(${passwordHash}, '', ${username}, ${name})\n+        VALUES(${passwordHash}, ${DEFAULT_PROFILE_PIC}, ${username}, ${name})\n         RETURNING *\n       `);\n     const user = createdUserQuery.rows[0];\n\n     return user;\n   }\n-}\n\\ No newline at end of file\n+}\ndiff --git a/server/package.json b/server/package.json\nindex 30019b0..03eb9cf 100644\n--- a/server/package.json\n+++ b/server/package.json\n@@ -7,58 +7,86 @@\n   },\n   \"private\": true,\n   \"scripts\": {\n+    \"prestart\": \"yarn codegen\",\n     \"start\": \"ts-node index.ts\",\n-    \"test\": \"jest --runInBand\",\n-    \"codegen\": \"gql-gen\"\n+    \"prebuild\": \"yarn codegen\",\n+    \"prod\": \"node dist/index.js\",\n+    \"build\": \"tsc\",\n+    \"test\": \"TZ=\\\"Asia/Jerusalem\\\" jest --runInBand --forceExit\",\n+    \"codegen\": \"gql-gen\",\n+    \"format\": \"prettier '**/*.ts' --write\",\n+    \"loadtest\": \"yarn artillery run artillery.yml > loadtest.log\",\n+    \"loadtest:limit\": \"yarn artillery run artillery-limit.yml > loadtest.log\"\n+  },\n+  \"jest-junit\": {\n+    \"outputDirectory\": \"./test-results\"\n   },\n   \"devDependencies\": {\n-    \"@graphql-codegen/cli\": \"1.0.3\",\n-    \"@graphql-codegen/typescript\": \"1.0.3\",\n-    \"@graphql-codegen/typescript-resolvers\": \"1.0.3\",\n+    \"@graphql-codegen/cli\": \"1.2.1\",\n+    \"@graphql-codegen/typescript\": \"1.2.1\",\n+    \"@graphql-codegen/typescript-resolvers\": \"1.2.1\",\n     \"@types/bcrypt\": \"3.0.0\",\n     \"@types/body-parser\": \"1.17.0\",\n+    \"@types/cookie\": \"0.3.3\",\n     \"@types/cookie-parser\": \"1.4.1\",\n-    \"@types/cors\": \"2.8.4\",\n-    \"@types/express\": \"4.16.1\",\n-    \"@types/graphql\": \"14.0.7\",\n+    \"@types/cors\": \"2.8.5\",\n+    \"@types/express\": \"4.17.0\",\n+    \"@types/faker\": \"4.1.5\",\n+    \"@types/graphql\": \"14.2.1\",\n     \"@types/graphql-iso-date\": \"3.3.1\",\n-    \"@types/jest\": \"24.0.11\",\n+    \"@types/jest\": \"24.0.15\",\n     \"@types/jsonwebtoken\": \"8.3.2\",\n-    \"@types/lodash\": \"4.14.126\",\n-    \"@types/node\": \"11.11.0\",\n-    \"@types/pg\": \"^7.4.14\",\n-    \"jest\": \"24.5.0\",\n-    \"ts-jest\": \"24.0.0\",\n-    \"ts-node\": \"8.0.3\",\n-    \"typescript\": \"3.3.3333\"\n+    \"@types/lodash\": \"4.14.134\",\n+    \"@types/node\": \"12.0.8\",\n+    \"@types/pg\": \"7.4.14\",\n+    \"artillery\": \"1.6.0-28\",\n+    \"jest\": \"24.8.0\",\n+    \"jest-junit\": \"6.4.0\",\n+    \"prettier\": \"1.18.2\",\n+    \"ts-jest\": \"24.0.2\",\n+    \"ts-node\": \"8.3.0\",\n+    \"typescript\": \"3.5.2\"\n   },\n   \"dependencies\": {\n-    \"@graphql-modules/core\": \"0.7.1\",\n-    \"@graphql-modules/di\": \"0.7.1\",\n-    \"@safe-api/middleware\": \"^0.0.2\",\n-    \"apollo-datasource-rest\": \"^0.4.0\",\n-    \"apollo-server-express\": \"2.4.8\",\n-    \"apollo-server-testing\": \"2.4.8\",\n-    \"axios\": \"0.18.0\",\n-    \"bcrypt\": \"3.0.5\",\n-    \"body-parser\": \"1.18.3\",\n+    \"@graphql-modules/core\": \"0.7.5\",\n+    \"@graphql-modules/di\": \"0.7.5\",\n+    \"@safe-api/middleware\": \"0.0.2\",\n+    \"apollo-datasource-rest\": \"0.5.0\",\n+    \"apollo-server-express\": \"2.6.3\",\n+    \"apollo-server-testing\": \"2.6.3\",\n+    \"axios\": \"0.19.0\",\n+    \"bcrypt\": \"3.0.6\",\n+    \"body-parser\": \"1.19.0\",\n+    \"cookie\": \"0.4.0\",\n     \"cookie-parser\": \"1.4.4\",\n     \"cors\": \"2.8.5\",\n-    \"express\": \"4.16.4\",\n-    \"graphql\": \"14.1.1\",\n+    \"dataloader\": \"1.4.0\",\n+    \"date-fns\": \"1.30.1\",\n+    \"express\": \"4.17.1\",\n+    \"faker\": \"4.1.0\",\n+    \"graphql\": \"14.3.1\",\n     \"graphql-import\": \"0.7.1\",\n     \"graphql-iso-date\": \"3.6.1\",\n-    \"graphql-postgres-subscriptions\": \"^1.0.5\",\n+    \"graphql-postgres-subscriptions\": \"1.0.5\",\n     \"graphql-tools\": \"4.0.4\",\n     \"jsonwebtoken\": \"8.5.1\",\n     \"lodash\": \"4.17.11\",\n-    \"pg\": \"^7.10.0\",\n+    \"pg\": \"7.11.0\",\n     \"reflect-metadata\": \"0.1.13\",\n-    \"sql-template-strings\": \"^2.2.2\"\n+    \"sql-template-strings\": \"2.2.2\"\n   },\n   \"jest\": {\n     \"transform\": {\n       \"^.+\\\\.(js|jsx|ts|tsx)$\": \"<rootDir>/node_modules/ts-jest\"\n-    }\n+    },\n+    \"globals\": {\n+      \"ts-jest\": {\n+        \"diagnostics\": false\n+      }\n+    },\n+    \"reporters\": [\n+      \"default\",\n+      \"jest-junit\"\n+    ]\n   }\n-}\n+}\n\\ No newline at end of file\ndiff --git a/server/server.ts b/server/server.ts\nindex 43e68ac..ce1b8bb 100644\n--- a/server/server.ts\n+++ b/server/server.ts\n@@ -1,16 +1,29 @@\n import 'reflect-metadata';\n-import { ApolloServer } from 'apollo-server-express'\n-import { GraphQLModule } from '@graphql-modules/core'\n+import { ApolloServer } from 'apollo-server-express';\n+import { GraphQLModule } from '@graphql-modules/core';\n+import cookie from 'cookie';\n\n-import usersModule from './modules/users'\n-import chatsModule from './modules/chats'\n+import usersModule from './modules/users';\n+import chatsModule from './modules/chats';\n\n export const rootModule = new GraphQLModule({\n   name: 'root',\n-  imports: [usersModule, chatsModule]\n-})\n+  imports: [usersModule, chatsModule],\n+});\n\n export const server = new ApolloServer({\n   schema: rootModule.schema,\n-  context: rootModule.context\n-})\n+  context: (session: any) => {\n+    if (session.connection) {\n+      const req = session.connection.context.session.request;\n+      const cookies = req.headers.cookie;\n+\n+      if (cookies) {\n+        req.cookies = cookie.parse(cookies);\n+      }\n+    }\n+\n+    return rootModule.context(session);\n+  },\n+  subscriptions: rootModule.subscriptions,\n+});\ndiff --git a/server/tests/mocks/auth.provider.ts b/server/tests/mocks/auth.provider.ts\nindex 074f62c..6f2d5af 100644\n--- a/server/tests/mocks/auth.provider.ts\n+++ b/server/tests/mocks/auth.provider.ts\n@@ -7,7 +7,7 @@ export function mockAuth(userId: number) {\n   class AuthMock extends Auth {\n     async currentUser() {\n       const { rows } = await pool.query(\n-        sql`SELECT * FROM users WHERE id = ${userId}`,\n+        sql`SELECT * FROM users WHERE id = ${userId}`\n       );\n       return rows[0];\n     }\n@@ -18,4 +18,4 @@ export function mockAuth(userId: number) {\n     useClass: AuthMock,\n     overwrite: true,\n   });\n-}\n\\ No newline at end of file\n+}\ndiff --git a/server/tests/mutations/addChat.test.ts b/server/tests/mutations/addChat.test.ts\nindex ad369f2..2c33de7 100644\n--- a/server/tests/mutations/addChat.test.ts\n+++ b/server/tests/mutations/addChat.test.ts\n@@ -1,20 +1,20 @@\n-import { createTestClient } from 'apollo-server-testing'\n-import { gql } from 'apollo-server-express'\n+import { createTestClient } from 'apollo-server-testing';\n+import { gql } from 'apollo-server-express';\n import { server } from '../../server';\n-import { resetDb } from '../../db'\n+import { resetDb } from '../../db';\n import { mockAuth } from '../mocks/auth.provider';\n\n describe('Mutation.addChat', () => {\n-  beforeEach(resetDb)\n+  beforeEach(resetDb);\n\n   it('creates a new chat between current user and specified recipient', async () => {\n     mockAuth(2);\n\n-    const { query, mutate } = createTestClient(server)\n+    const { query, mutate } = createTestClient(server);\n\n     const addChatRes = await mutate({\n       variables: { recipientId: '3' },\n-      mutation: gql `\n+      mutation: gql`\n         mutation AddChat($recipientId: ID!) {\n           addChat(recipientId: $recipientId) {\n             id\n@@ -25,15 +25,15 @@ describe('Mutation.addChat', () => {\n           }\n         }\n       `,\n-    })\n+    });\n\n-    expect(addChatRes.data).toBeDefined()\n-    expect(addChatRes.errors).toBeUndefined()\n-    expect(addChatRes.data).toMatchSnapshot()\n+    expect(addChatRes.data).toBeDefined();\n+    expect(addChatRes.errors).toBeUndefined();\n+    expect(addChatRes.data).toMatchSnapshot();\n\n     const getChatRes = await query({\n       variables: { chatId: '5' },\n-      query: gql `\n+      query: gql`\n         query GetChat($chatId: ID!) {\n           chat(chatId: $chatId) {\n             id\n@@ -44,21 +44,21 @@ describe('Mutation.addChat', () => {\n           }\n         }\n       `,\n-    })\n+    });\n\n-    expect(getChatRes.data).toBeDefined()\n-    expect(getChatRes.errors).toBeUndefined()\n-    expect(getChatRes.data).toMatchSnapshot()\n-  })\n+    expect(getChatRes.data).toBeDefined();\n+    expect(getChatRes.errors).toBeUndefined();\n+    expect(getChatRes.data).toMatchSnapshot();\n+  });\n\n   it('returns the existing chat if so', async () => {\n     mockAuth(1);\n\n-    const { query, mutate } = createTestClient(server)\n+    const { query, mutate } = createTestClient(server);\n\n     const addChatRes = await mutate({\n       variables: { recipientId: '2' },\n-      mutation: gql `\n+      mutation: gql`\n         mutation AddChat($recipientId: ID!) {\n           addChat(recipientId: $recipientId) {\n             id\n@@ -69,10 +69,10 @@ describe('Mutation.addChat', () => {\n           }\n         }\n       `,\n-    })\n+    });\n\n-    expect(addChatRes.data).toBeDefined()\n-    expect(addChatRes.errors).toBeUndefined()\n-    expect(addChatRes.data).toMatchSnapshot()\n-  })\n-})\n+    expect(addChatRes.data).toBeDefined();\n+    expect(addChatRes.errors).toBeUndefined();\n+    expect(addChatRes.data).toMatchSnapshot();\n+  });\n+});\ndiff --git a/server/tests/mutations/addMessage.test.ts b/server/tests/mutations/addMessage.test.ts\nindex ec98e08..60e2995 100644\n--- a/server/tests/mutations/addMessage.test.ts\n+++ b/server/tests/mutations/addMessage.test.ts\n@@ -1,20 +1,20 @@\n-import { createTestClient } from 'apollo-server-testing'\n-import { gql } from 'apollo-server-express'\n+import { createTestClient } from 'apollo-server-testing';\n+import { gql } from 'apollo-server-express';\n import { server } from '../../server';\n-import { resetDb } from '../../db'\n+import { resetDb } from '../../db';\n import { mockAuth } from '../mocks/auth.provider';\n\n describe('Mutation.addMessage', () => {\n-  beforeEach(resetDb)\n+  beforeEach(resetDb);\n\n   it('should add message to specified chat', async () => {\n     mockAuth(1);\n\n-    const { query, mutate } = createTestClient(server)\n+    const { query, mutate } = createTestClient(server);\n\n     const addMessageRes = await mutate({\n       variables: { chatId: '1', content: 'Hello World' },\n-      mutation: gql `\n+      mutation: gql`\n         mutation AddMessage($chatId: ID!, $content: String!) {\n           addMessage(chatId: $chatId, content: $content) {\n             id\n@@ -22,15 +22,15 @@ describe('Mutation.addMessage', () => {\n           }\n         }\n       `,\n-    })\n+    });\n\n-    expect(addMessageRes.data).toBeDefined()\n-    expect(addMessageRes.errors).toBeUndefined()\n-    expect(addMessageRes.data).toMatchSnapshot()\n+    expect(addMessageRes.data).toBeDefined();\n+    expect(addMessageRes.errors).toBeUndefined();\n+    expect(addMessageRes.data).toMatchSnapshot();\n\n     const getChatRes = await query({\n       variables: { chatId: '1' },\n-      query: gql `\n+      query: gql`\n         query GetChat($chatId: ID!) {\n           chat(chatId: $chatId) {\n             id\n@@ -41,10 +41,10 @@ describe('Mutation.addMessage', () => {\n           }\n         }\n       `,\n-    })\n+    });\n\n-    expect(getChatRes.data).toBeDefined()\n-    expect(getChatRes.errors).toBeUndefined()\n-    expect(getChatRes.data).toMatchSnapshot()\n-  })\n-})\n+    expect(getChatRes.data).toBeDefined();\n+    expect(getChatRes.errors).toBeUndefined();\n+    expect(getChatRes.data).toMatchSnapshot();\n+  });\n+});\ndiff --git a/server/tests/mutations/removeChat.test.ts b/server/tests/mutations/removeChat.test.ts\nindex 010232d..25425d4 100644\n--- a/server/tests/mutations/removeChat.test.ts\n+++ b/server/tests/mutations/removeChat.test.ts\n@@ -1,33 +1,33 @@\n-import { createTestClient } from 'apollo-server-testing'\n-import { gql } from 'apollo-server-express'\n+import { createTestClient } from 'apollo-server-testing';\n+import { gql } from 'apollo-server-express';\n import { server } from '../../server';\n-import { resetDb } from '../../db'\n+import { resetDb } from '../../db';\n import { mockAuth } from '../mocks/auth.provider';\n\n describe('Mutation.removeChat', () => {\n-  beforeEach(resetDb)\n+  beforeEach(resetDb);\n\n   it('removes chat by id', async () => {\n     mockAuth(1);\n\n-    const { query, mutate } = createTestClient(server)\n+    const { query, mutate } = createTestClient(server);\n\n     const addChatRes = await mutate({\n       variables: { chatId: '1' },\n-      mutation: gql `\n+      mutation: gql`\n         mutation RemoveChat($chatId: ID!) {\n           removeChat(chatId: $chatId)\n         }\n       `,\n-    })\n+    });\n\n-    expect(addChatRes.data).toBeDefined()\n-    expect(addChatRes.errors).toBeUndefined()\n-    expect(addChatRes.data!.removeChat).toEqual('1')\n+    expect(addChatRes.data).toBeDefined();\n+    expect(addChatRes.errors).toBeUndefined();\n+    expect(addChatRes.data!.removeChat).toEqual('1');\n\n     const getChatRes = await query({\n       variables: { chatId: '1' },\n-      query: gql `\n+      query: gql`\n         query GetChat($chatId: ID!) {\n           chat(chatId: $chatId) {\n             id\n@@ -38,10 +38,10 @@ describe('Mutation.removeChat', () => {\n           }\n         }\n       `,\n-    })\n+    });\n\n-    expect(addChatRes.data).toBeDefined()\n-    expect(getChatRes.errors).toBeUndefined()\n-    expect(addChatRes.data!.chat).toBeUndefined()\n-  })\n-})\n+    expect(addChatRes.data).toBeDefined();\n+    expect(getChatRes.errors).toBeUndefined();\n+    expect(addChatRes.data!.chat).toBeUndefined();\n+  });\n+});\ndiff --git a/server/tests/queries/__snapshots__/getChat.test.ts.snap b/server/tests/queries/__snapshots__/getChat.test.ts.snap\nindex 64b1e2b..628b2cd 100644\n--- a/server/tests/queries/__snapshots__/getChat.test.ts.snap\n+++ b/server/tests/queries/__snapshots__/getChat.test.ts.snap\n@@ -6,7 +6,7 @@ Object {\n     \"id\": \"1\",\n     \"lastMessage\": Object {\n       \"content\": \"You on your way?\",\n-      \"createdAt\": \"2018-12-31T06:20:00.000Z\",\n+      \"createdAt\": \"2018-12-31T07:20:00.000Z\",\n       \"id\": \"1\",\n     },\n     \"name\": \"Ethan Gonzalez\",\ndiff --git a/server/tests/queries/__snapshots__/getChats.test.ts.snap b/server/tests/queries/__snapshots__/getChats.test.ts.snap\nindex 1bd3a67..951f50a 100644\n--- a/server/tests/queries/__snapshots__/getChats.test.ts.snap\n+++ b/server/tests/queries/__snapshots__/getChats.test.ts.snap\n@@ -7,7 +7,7 @@ Object {\n       \"id\": \"1\",\n       \"lastMessage\": Object {\n         \"content\": \"You on your way?\",\n-        \"createdAt\": \"2018-12-31T06:20:00.000Z\",\n+        \"createdAt\": \"2018-12-31T07:20:00.000Z\",\n         \"id\": \"1\",\n       },\n       \"name\": \"Ethan Gonzalez\",\n@@ -17,7 +17,7 @@ Object {\n       \"id\": \"2\",\n       \"lastMessage\": Object {\n         \"content\": \"Hey, it's me\",\n-        \"createdAt\": \"2018-12-30T13:40:00.000Z\",\n+        \"createdAt\": \"2018-12-30T14:40:00.000Z\",\n         \"id\": \"2\",\n       },\n       \"name\": \"Bryan Wallace\",\n@@ -27,7 +27,7 @@ Object {\n       \"id\": \"3\",\n       \"lastMessage\": Object {\n         \"content\": \"I should buy a boat\",\n-        \"createdAt\": \"2018-12-15T07:00:00.000Z\",\n+        \"createdAt\": \"2018-12-15T08:00:00.000Z\",\n         \"id\": \"3\",\n       },\n       \"name\": \"Avery Stewart\",\n@@ -37,7 +37,7 @@ Object {\n       \"id\": \"4\",\n       \"lastMessage\": Object {\n         \"content\": \"This is wicked good ice cream.\",\n-        \"createdAt\": \"2018-05-12T15:00:00.000Z\",\n+        \"createdAt\": \"2018-05-12T16:00:00.000Z\",\n         \"id\": \"4\",\n       },\n       \"name\": \"Katie Peterson\",\ndiff --git a/server/tests/queries/getChat.test.ts b/server/tests/queries/getChat.test.ts\nindex 0e63918..db5ad8a 100644\n--- a/server/tests/queries/getChat.test.ts\n+++ b/server/tests/queries/getChat.test.ts\n@@ -1,20 +1,20 @@\n-import { createTestClient } from 'apollo-server-testing'\n-import { gql } from 'apollo-server-express'\n+import { createTestClient } from 'apollo-server-testing';\n+import { gql } from 'apollo-server-express';\n import { server } from '../../server';\n import { resetDb } from '../../db';\n import { mockAuth } from '../mocks/auth.provider';\n\n describe('Query.chat', () => {\n-  beforeEach(resetDb)\n-\n+  beforeEach(resetDb);\n+\n   it('should fetch specified chat', async () => {\n     mockAuth(1);\n\n-    const { query } = createTestClient(server)\n+    const { query } = createTestClient(server);\n\n     const res = await query({\n       variables: { chatId: '1' },\n-      query: gql `\n+      query: gql`\n         query GetChat($chatId: ID!) {\n           chat(chatId: $chatId) {\n             id\n@@ -28,10 +28,10 @@ describe('Query.chat', () => {\n           }\n         }\n       `,\n-    })\n+    });\n\n-    expect(res.data).toBeDefined()\n-    expect(res.errors).toBeUndefined()\n-    expect(res.data).toMatchSnapshot()\n-  })\n-})\n+    expect(res.data).toBeDefined();\n+    expect(res.errors).toBeUndefined();\n+    expect(res.data).toMatchSnapshot();\n+  });\n+});\ndiff --git a/server/tests/queries/getChats.test.ts b/server/tests/queries/getChats.test.ts\nindex 171aa10..f416ee7 100644\n--- a/server/tests/queries/getChats.test.ts\n+++ b/server/tests/queries/getChats.test.ts\n@@ -1,19 +1,19 @@\n-import { createTestClient } from 'apollo-server-testing'\n-import { gql } from 'apollo-server-express'\n+import { createTestClient } from 'apollo-server-testing';\n+import { gql } from 'apollo-server-express';\n import { server } from '../../server';\n import { resetDb } from '../../db';\n import { mockAuth } from '../mocks/auth.provider';\n\n describe('Query.chats', () => {\n-  beforeEach(resetDb)\n-\n+  beforeEach(resetDb);\n+\n   it('should fetch all chats', async () => {\n     mockAuth(1);\n\n-    const { query } = createTestClient(server)\n+    const { query } = createTestClient(server);\n\n     const res = await query({\n-      query: gql `\n+      query: gql`\n         query GetChats {\n           chats {\n             id\n@@ -27,10 +27,10 @@ describe('Query.chats', () => {\n           }\n         }\n       `,\n-    })\n+    });\n\n-    expect(res.data).toBeDefined()\n-    expect(res.errors).toBeUndefined()\n-    expect(res.data).toMatchSnapshot()\n-  })\n-})\n+    expect(res.data).toBeDefined();\n+    expect(res.errors).toBeUndefined();\n+    expect(res.data).toMatchSnapshot();\n+  });\n+});\ndiff --git a/server/tests/queries/getMe.test.ts b/server/tests/queries/getMe.test.ts\nindex 022c28e..6a74b42 100644\n--- a/server/tests/queries/getMe.test.ts\n+++ b/server/tests/queries/getMe.test.ts\n@@ -1,19 +1,19 @@\n-import { createTestClient } from 'apollo-server-testing'\n-import { gql } from 'apollo-server-express'\n+import { createTestClient } from 'apollo-server-testing';\n+import { gql } from 'apollo-server-express';\n import { server } from '../../server';\n import { resetDb } from '../../db';\n import { mockAuth } from '../mocks/auth.provider';\n\n describe('Query.me', () => {\n-  beforeEach(resetDb)\n-\n+  beforeEach(resetDb);\n+\n   it('should fetch current user', async () => {\n-    mockAuth(1)\n+    mockAuth(1);\n\n-    const { query } = createTestClient(server)\n+    const { query } = createTestClient(server);\n\n     const res = await query({\n-      query: gql `\n+      query: gql`\n         query GetMe {\n           me {\n             id\n@@ -22,10 +22,10 @@ describe('Query.me', () => {\n           }\n         }\n       `,\n-    })\n+    });\n\n-    expect(res.data).toBeDefined()\n-    expect(res.errors).toBeUndefined()\n-    expect(res.data).toMatchSnapshot()\n-  })\n-})\n+    expect(res.data).toBeDefined();\n+    expect(res.errors).toBeUndefined();\n+    expect(res.data).toMatchSnapshot();\n+  });\n+});\ndiff --git a/server/tests/queries/getUsers.test.ts b/server/tests/queries/getUsers.test.ts\nindex 47ac87a..7e26598 100644\n--- a/server/tests/queries/getUsers.test.ts\n+++ b/server/tests/queries/getUsers.test.ts\n@@ -1,19 +1,19 @@\n-import { createTestClient } from 'apollo-server-testing'\n-import { gql } from 'apollo-server-express'\n+import { createTestClient } from 'apollo-server-testing';\n+import { gql } from 'apollo-server-express';\n import { server } from '../../server';\n import { resetDb } from '../../db';\n import { mockAuth } from '../mocks/auth.provider';\n\n describe('Query.getUsers', () => {\n-  beforeEach(resetDb)\n-\n+  beforeEach(resetDb);\n+\n   it('should fetch all users except the one signed-in', async () => {\n     mockAuth(1);\n\n-    const { query } = createTestClient(server)\n+    const { query } = createTestClient(server);\n\n     let res = await query({\n-      query: gql `\n+      query: gql`\n         query GetUsers {\n           users {\n             id\n@@ -22,16 +22,16 @@ describe('Query.getUsers', () => {\n           }\n         }\n       `,\n-    })\n+    });\n\n-    expect(res.data).toBeDefined()\n-    expect(res.errors).toBeUndefined()\n-    expect(res.data).toMatchSnapshot()\n+    expect(res.data).toBeDefined();\n+    expect(res.errors).toBeUndefined();\n+    expect(res.data).toMatchSnapshot();\n\n     mockAuth(2);\n\n     res = await query({\n-      query: gql `\n+      query: gql`\n         query GetUsers {\n           users {\n             id\n@@ -40,10 +40,10 @@ describe('Query.getUsers', () => {\n           }\n         }\n       `,\n-    })\n+    });\n\n-    expect(res.data).toBeDefined()\n-    expect(res.errors).toBeUndefined()\n-    expect(res.data).toMatchSnapshot()\n-  })\n-})\n+    expect(res.data).toBeDefined();\n+    expect(res.errors).toBeUndefined();\n+    expect(res.data).toMatchSnapshot();\n+  });\n+});\ndiff --git a/server/tsconfig.json b/server/tsconfig.json\nindex fe56553..d9d5ac7 100644\n--- a/server/tsconfig.json\n+++ b/server/tsconfig.json\n@@ -1,16 +1,21 @@\n {\n   \"compilerOptions\": {\n+    \"outDir\": \"dist\",\n     \"target\": \"es2018\",\n     \"module\": \"commonjs\",\n     \"lib\": [\n       \"es2018\",\n       \"esnext.asynciterable\"\n     ],\n+    \"skipLibCheck\": true,\n     \"strict\": true,\n     \"strictFunctionTypes\": false,\n     \"strictPropertyInitialization\": false,\n     \"esModuleInterop\": true,\n     \"experimentalDecorators\": true,\n     \"emitDecoratorMetadata\": true\n-  }\n+  },\n+  \"exclude\": [\n+    \"./tests/\"\n+  ]\n }\ndiff --git a/server/types/apollo-server-testing.d.ts b/server/types/apollo-server-testing.d.ts\nindex e9d9b94..554c277 100644\n--- a/server/types/apollo-server-testing.d.ts\n+++ b/server/types/apollo-server-testing.d.ts\n@@ -19,7 +19,7 @@ declare module 'apollo-server-testing' {\n   };\n\n   export const createTestClient: <TVariables>(\n-    server: ApolloServerBase,\n+    server: ApolloServerBase\n   ) => {\n     query: (query: Query<TVariables>) => Promise<GraphQLResponse>;\n     mutate: (mutation: Mutation<TVariables>) => Promise<GraphQLResponse>;\ndiff --git a/server/validators.ts b/server/validators.ts\nindex 341d955..7559c52 100644\n--- a/server/validators.ts\n+++ b/server/validators.ts\n@@ -1,43 +1,43 @@\n export const validatePassword = (ctx: string, str: string) => {\n   if (typeof str !== 'string') {\n-    throw TypeError(`${ctx} must be a string`)\n+    throw TypeError(`${ctx} must be a string`);\n   }\n\n-  validateLength(ctx, str, 8, 30)\n+  validateLength(ctx, str, 8, 30);\n\n   if (!/[a-zA-Z]+/.test(str)) {\n-    throw TypeError(`${ctx} must contain english letters`)\n+    throw TypeError(`${ctx} must contain english letters`);\n   }\n\n   if (!/\\d+/.test(str)) {\n-    throw TypeError(`${ctx} must contain numbers`)\n+    throw TypeError(`${ctx} must contain numbers`);\n   }\n\n   if (!/[^\\da-zA-Z]+/.test(str)) {\n-    throw TypeError(`${ctx} must contain special charachters`)\n+    throw TypeError(`${ctx} must contain special charachters`);\n   }\n-}\n+};\n\n export const validateLength = (ctx: string, str: string, ...args: number[]) => {\n-  let min, max\n+  let min, max;\n\n   if (args.length === 1) {\n-    min = 0\n-    max = args[0]\n+    min = 0;\n+    max = args[0];\n   } else {\n-    min = args[0]\n-    max = args[1]\n+    min = args[0];\n+    max = args[1];\n   }\n\n   if (typeof str !== 'string') {\n-    throw TypeError(`${ctx} must be a string`)\n+    throw TypeError(`${ctx} must be a string`);\n   }\n\n   if (str.length < min) {\n-    throw TypeError(`${ctx} must be at least ${min} chars long`)\n+    throw TypeError(`${ctx} must be at least ${min} chars long`);\n   }\n\n   if (str.length > max) {\n-    throw TypeError(`${ctx} must contain ${max} chars at most`)\n+    throw TypeError(`${ctx} must contain ${max} chars at most`);\n   }\n-}\n+};\n",
        "manuals": [
          {
            "manualTitle": "Whatsapp Clone Tutorial",
            "stepRevision": "5ea161d7034a0b250eb801439265174b41b64fbf",
            "manualView": "![whatsapp-clone](https://user-images.githubusercontent.com/7648874/54141944-9f801a80-4461-11e9-85a1-bcb161d9a6c6.png)\n\nWhatsapp Clone is a free and open-source tutorial that will guide you step-by-step on how to create a full-stack,\nmobile, hybrid web application from scratch.\n\nThe software world is evolving quickly, and oftentimes people find themselves left behind, even the most experienced ones.\nThe purpose of this tutorial is not only to demonstrate how to create a full application with the latest technologies, but also\nto keep up to date with the ever-changing development ecosystem.\n\nThis tutorial is for anyone who has ever asked themselves one of the following questions:\n\n- How do people build an app today?\n- What are the currently leading technologies in the ecosystem?\n- What are the best practices for using technology XXX?\n- What is the purpose of technology XXX?\n- How does technology XXX work?\n- How do I use technology XXX?\n- How do I migrate to the new version of technology XXX?\n- Why should I use technology XXX over technology YYY?\n\nAll of the above and more can be answered in the tutorial. Whether you’re a beginner, intermediate or a professional,\nwe will have the answers you’re looking for.\n\n**What technologies does Whatsapp Clone uses?**\n\nThe version of the Whatsapp Clone you are looking at, uses:\n\n- [React (with Hooks and Suspense)](http://react.com)\n- [Styled-Components](https://styled-components.com)\n- [Material-UI](https://material-ui.com)\n- [TypeScript](https://typescriptlang.org)\n- [Apollo GraphQL](https://www.apollographql.com)\n- [GraphQL Code Generator](http://graphql-code-generator.com)\n- [GraphQL Modules](https://graphql-modules.com)\n- [PostgreSQL](https://www.postgresql.org/)\n- [GraphQL Inspector](https://graphql-inspector.com/)\n\nThe point of this tutorial is not to be bound to a certain technology, but rather keep itself aligned with the ecosystem.\nWhen a new technology comes out, and it’s better and more popular, Whatsapp Clone will upgrade to use it (together with full migration instructions).\n\n**P2P tutorial for the community by the community**\n\nKeeping tutorials up to date is not an easy task.\nThat's why we've created the Tortilla Tutorial Framework that makes it easy to write and update tutorials.\nAlso, the WhatsApp clone is completely open source in order for the community to give its feedback, help and fork ideas.\nHere are the repositories the tutorial is made of:\n\n- [Whatsapp Clone - Client](https://github.com/Urigo/WhatsApp-Clone-Client-React)\n- [Whatsapp Clone - Server](https://github.com/Urigo/WhatsApp-Clone-server)\n- [Whatsapp Clone - Script's text](https://github.com/Urigo/WhatsApp-Clone-Tutorial)\n\nWe’ve also made sure to publish some important documents so you can get more involved.\nYou can track our progress and comment your suggestions, since everything is based on Google Docs and is updated live:\n\n- [Road map](https://docs.google.com/document/d/1p2Zio6Js2eoFfHs9CjIMF6jTuNyD4eQEHlgEAKhAqM8/edit?usp=sharing)\n- [Chapter manuals] (https://drive.google.com/open?id=1ITxOniS_S3sgZfunLvtJ1L9P6Fj1YOLlFHhoQPjT3S0)\n\n**Migration instructions included**\n\nThere are many great tutorials out there, but almost none of them shows you what changes you should make in your app in order to be aligned with a new version of a certain technology.\nAs technologies are being updated by the minute, some changes are minor and insignificant,\nbut often times a breaking change will be made in which case we need to know how we can adapt to that change.\nThanks to the [Tortilla platform](https://tortilla.academy), we can provide you with a git-diff that will show you what changes were made between each and every released version of the Whatsapp Clone tutorial since the beginning of history.\nThis way you can easily notice the changes in APIs and migrate your app in no time.\n\n![tutorial-versions-diff](https://user-images.githubusercontent.com/7648874/54142148-0f8ea080-4462-11e9-9522-ec9997b76169.png)\n\n**Prerequisites for WhatsApp Clone**\n\n- JavaScript - https://javascript.info/\n- TypeScript\n- JSX\n- HTML\n- CSS\n- Node.JS\n- npm & Yarn\n- React\n- SQL\n\n> Even if you don't have experience with the technologies above you might be able to start the tutorial and pick things along the way.\n> If you struggle with anything, contact us on the forum or on Github with your questions.\n\nOS operations such as navigating to a folder, or creating a folder, are all gonna be written in Bash, but the instructions are OS agnostic and can be applied on any machine that is web-compatible.\n\nMake sure you have the latest global dependencies on your computer before starting the tutorial:\n\n**[Node](https://nodejs.org/)**\n\nInstall [nvm](https://github.com/nvm-sh/nvm) by running the following command in your command line:\n\n    $ curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.34.0/install.sh | bash\n\nThen install the latest version of Node by running the following:\n\n    $ nvm install node\n\n**[Yarn](https://yarnpkg.com)**\n\nFollow the instructions [here](https://yarnpkg.com/en/docs/install#mac-stable).\n\n\n**What’s on the tutorial?**\n\nWhatsapp Clone is built chronologically, from the most basic, to more higher level features, so we recommend you to follow the tutorial in the right order.\nEach step is focused on a different subject, so by the end of it you’ll have a new feature and a new set of knowledge that you can start implementing in your everyday scenario immediately.\n\nIf you feel like you want to skip or focus on a specific subject, on each step you can download the full app code till that point in time.\n\nThat is also useful in case you get stuck.\n\nCurrently, Whatsapp Clone includes the following chapters:\n\n- [Step 1: Creating a basic React APP with a basic view.](https://github.com/Urigo/WhatsApp-Clone-Tutorial/blob/final/.tortilla/manuals/views/step1.md)\n- [Step 2: Styling with Material-UI and Styled-Components.](https://github.com/Urigo/WhatsApp-Clone-Tutorial/blob/final/.tortilla/manuals/views/step2.md)\n- [Step 3: Setting a basic Node.JS server with basic a basic REST endpoint.](https://github.com/Urigo/WhatsApp-Clone-Tutorial/blob/final/.tortilla/manuals/views/step3.md)\n- [Step 4: Transition to GraphQL.](https://github.com/Urigo/WhatsApp-Clone-Tutorial/blob/final/.tortilla/manuals/views/step4.md)\n- [Step 5: Testing.](https://github.com/Urigo/WhatsApp-Clone-Tutorial/blob/final/.tortilla/manuals/views/step5.md)\n- [Step 6: Creating an app router and implementing a chat room.](https://github.com/Urigo/WhatsApp-Clone-Tutorial/blob/final/.tortilla/manuals/views/step6.md)\n- [Step 7: Caching with Apollo-Client.](https://github.com/Urigo/WhatsApp-Clone-Tutorial/blob/final/.tortilla/manuals/views/step7.md)\n- [Step 8: Sending messages with GraphQL mutations.](https://github.com/Urigo/WhatsApp-Clone-Tutorial/blob/final/.tortilla/manuals/views/step8.md)\n- [Step 9: Type safety with GraphQL Code Generator.](https://github.com/Urigo/WhatsApp-Clone-Tutorial/blob/final/.tortilla/manuals/views/step9.md)\n- [Step 10: Live updates with GraphQL subscriptions.](https://github.com/Urigo/WhatsApp-Clone-Tutorial/blob/final/.tortilla/manuals/views/step10.md)\n- [Step 11: Users.](https://github.com/Urigo/WhatsApp-Clone-Tutorial/blob/final/.tortilla/manuals/views/step11.md)\n- [Step 12: Adding and removing chats.](https://github.com/Urigo/WhatsApp-Clone-Tutorial/blob/final/.tortilla/manuals/views/step12.md)\n- [Step 13: Authentication.](https://github.com/Urigo/WhatsApp-Clone-Tutorial/blob/final/.tortilla/manuals/views/step13.md)\n- Step 14: Your choice! Submit a request [here](https://github.com/Urigo/WhatsApp-Clone-Client-React/issues)\n\nWhatsapp Clone is updated on a regular basis, so you should expect more steps and extensions with time.\nYou can keep track of our [road map](https://docs.google.com/document/d/1p2Zio6Js2eoFfHs9CjIMF6jTuNyD4eQEHlgEAKhAqM8/edit?usp=sharing) to see what’s upcoming."
          },
          {
            "manualTitle": "Step 1: Creating a basic React APP with a basic view",
            "stepRevision": "7867ace8fe2cfe5430a578e00554ba618ceda880",
            "manualView": "The first thing we will do in the tutorial is to start with the UI (User Interface).\nThat is the visible part of our app that our users will see and interact with.\n\nIn this chapter we will learn how to create a basic React app.\nThe app will contain a basic view that will render a list of conversations within our app.\nWe will gradually create our app, so for now, instead of using real data, we will use in-memory fake data instead of calling a server.\n\nIn order to save time, instead of starting from scratch, we will use a boilerplate to kick-start our application.\nWhen it comes to React apps, the most popular boilerplate is [`create-react-app`](https://github.com/facebook/create-react-app)\nwhich is also officially maintained by Facebook, the creators of [React](https://reactjs.org/).\n\nWe'll launch `create-react-app` using `yarn create` (so we won't need to install `create-react-app` permanently),\nand run the `react-app` command to create the basis for our WhatsApp Clone.\n\nIn your command line, navigate to the folder you want to put your app's folder in and run:\n\n    $ yarn create react-app whatsapp-clone-client --typescript\n\n> Note how we used the `client` postfix. That's because we're planning to create a server as well on later chapters.\n\nIt will create a directory called `whatsapp-clone-client` inside the current folder.\nInside that directory, it will generate the initial project structure and install the needed dependencies.\nNo configuration or complicated folder structures, just the files you need to build your app.\n\n> In our project, we're gonna use [TypeScript](https://www.typescriptlang.org/) (indicated by the `--typescript` command).\n> The main advantage of using TypeScript over using plain JavaScript is that if we want, we get to tell the compiler what types and data structures we expect in certain places,\n> so that the compiler (which unlike a human never forgets) will remind us when we make a mistake and assume something that is not true.\n> The more information we will provide to the compiler, the more the compiler will be able to help us.\n\nOnce the installation is done, you can open your project folder:\n\n\t$ cd whatsapp-clone-client\n\nInside the newly created project, you can run some built-in commands:\n\n\t$ yarn start\n\nRuns the app in development mode. Open `http://localhost:3000` to view it in the browser:\n\n![boilerplate-page](https://user-images.githubusercontent.com/7648874/54026782-025f8080-41da-11e9-9a4e-796fe15e8d03.png)\n\n### create-react-app\n\nLet's look at what create-react-app has created for us in order to understand everything that's going on.\n\nFirst thing, let's look at what webpage is being served to the browser.\nThat webpage in `index.html` that sits under the `public` folder.\n\nAs you can see, this file is a regular HTML file. You will want to edit it's `<title>` to name our real app:\n\n[{]: <helper> (diffStep \"1.1\" files=\"public/index.html\" module=\"client\")\n\n#### [__Client__ Step 1.1: Rename the app](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/47d7325)\n\n##### Changed public&#x2F;index.html\n```diff\n@@ -19,7 +19,7 @@\n ┊19┊19┊      work correctly both with client-side routing and a non-root public URL.\n ┊20┊20┊      Learn how to configure a non-root public URL by running `npm run build`.\n ┊21┊21┊    -->\n-┊22┊  ┊    <title>React App</title>\n+┊  ┊22┊    <title>WhatsApp Clone</title>\n ┊23┊23┊  </head>\n ┊24┊24┊  <body>\n ┊25┊25┊    <noscript>You need to enable JavaScript to run this app.</noscript>\n```\n\n[}]: #\n\nIn the `public` folder we will place assets that are not going to change, like `favicon.ico`, static images and the HTML templates.\n\nWhen we will prepare to app for production, a script from `create-react-app` will place those assets in a build folder and reference them into the\nHTML template.\n\nAnother file in the `public` folder is the `manifest.json` file that gives browsers information about our app in case the users will install the app permanently on their\nmobile phones or desktop apps.\nYou can read more about it here: https://developers.google.com/web/fundamentals/web-app-manifest/.\n\n[{]: <helper> (diffStep \"1.1\" files=\"public/manifest.json\" module=\"client\")\n\n#### [__Client__ Step 1.1: Rename the app](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/47d7325)\n\n##### Changed public&#x2F;manifest.json\n```diff\n@@ -1,6 +1,6 @@\n ┊1┊1┊{\n-┊2┊ ┊  \"short_name\": \"React App\",\n-┊3┊ ┊  \"name\": \"Create React App Sample\",\n+┊ ┊2┊  \"short_name\": \"WhatsApp Clone\",\n+┊ ┊3┊  \"name\": \"An open source chat app\",\n ┊4┊4┊  \"icons\": [\n ┊5┊5┊    {\n ┊6┊6┊      \"src\": \"favicon.ico\",\n```\n\n[}]: #\n\nNow the HTML file has in it's <body> tag just one `<div id=\"root\"></div>` tag which is empty.\nSo how do we get the nice React logo that is being rendered onto our screen?\n\n`create-react-app` has scripts that will run the `src/index.tsx` file together with our HTML template, so let's look what this file is doing.\nThe important thing to see here is the `React` is calling it's render method and telling it to render the `App` component into a document where `id` equals `root`.\n\nSo now you know where React is coming into our html template.\n\nBut where does the `App` React component comes from and where does `React` itself comes from?\n\nThe `index.tsx` file imports this code from outside of the file using the `import` command.\n\nIn the case of the `App` component, we can see it bring it from the path './App', which is in the same folder ('src').\n\nGetting React, it is simply calling it by name instead of a path. That means that the import will automatically look for a folder named `react` under the `node-modules` folder.\n\n`node-modules` is a default folder which will include all of the libraries we want to use in our app.\n\n[yarn](https://yarnpkg.com) will install those libraries according to the dependencies listed inside the `package.json` file, so let's look into that.\n\nUnder dependencies you can see all the libraries our app currently depends on.\n\nYou can also see other values in there like `scripts`, which will teach `yarn` new commands that we can use.\nThe right side will name the command and the left would be the actual command that it will run.\n\nAnother file that got created is `tsconfig.json`.\nThat file specifies options for the Typescript compiler when it takes our code and transforms it from Typescript into Javascript.\n\nSome noticeable configuration options for that file are:\n\n* `target` - What kind of Javascript should the compilers output? in our case `es5` is the version of Javascript that is supported by many browsers.\nIf you know that your app would run only on newer browsers or a Node environment, you can change that value to a newer version and gain performance improvements.\n* `lib` - If you are using new syntax from Javascript, the compiler can add to it's output libraries that would help you support the new syntax even if the browsers don't know those.\n* `strict` - We can give Typescript a lot of information or not so much. The more we give it the more it can help us. adding the strict option will make the compiler warn us when we won't give it enough information.\n\nFor the full set of options, check out the [official docs](https://www.typescriptlang.org/docs/handbook/compiler-options.html);\n\nNow, let's look at our App's code in `src/App.tsx`.\n\nWe can see that our app is just a function named `App`.\n\n`const App` means we declare a variable named `App` and `const` means it cannot be changed after it has been declared (you can't do `App = XX;` later in the app);\n\nNext we assign App with a function. Something like: `const App = () => {}`.\nThat way of creating functions is called `arrow functions`. It is almost equivalent to `const App = function(){}`.\nSo it is a function that doesn't accept any parameters into it.\n\nThat function returns `jsx`. A visual language from React that describes how our component should look like.\n\nSo all a React component is, is simply a function that returns how it look like.\n\nWe then export this function so that React could import it from `index.tsx`.\n\nIn our own component we will import things like the logo and styles that the component uses and those will be imported together with it each time\nsomething will import our component.\n\nThe last thing we haven't explained is the following part: `App: React.FC`.\nThose are Typescript typings. Everything after `:` describes the types of the `App` variable and has no affect on the behavior and execution of the app.\nIt will tell Typescript what `App` is suppose to look so that in case we make a mistake Typescript will warn us before we get the app running.\n\nSo what are the types of React.FC?  You can check it out inside by using command+click on it's name.\nYou see that it accepts `P` as props into the component and needs to return `React.Element` or `null`.\n\nLet's test this out, add a Typescript interface named `AppProps` and put that it includes a property called `name` of type string.\n\nNow let's try to return something invalid. `\"some string\"`, or `1+1`.\nYou can see that our editor is calling out that there are errors in our code.\n\nYou will encounter those error a lot as you develop.\nAlways read the errors all the way. Understand each sentence there because that will save you a lot of time.\n\nOk we now know the component doesn't get anything into itself so let's make sure the typings reflect that as well.\nThe default for React.FC is that there are no props passed inside so if we'll bring that back but keep sending the `name` value from `index.tsx` in the code, you should now get an error.\n\nThose errors can be very useful when your app grows.\nMake sure to define types on the component itself like we have done now. It would make it easier to identify the issues.\n\nNext, we have `App.css`. This is used to style our App component.\nPlay around with changing some of the values and see how it changes your view.\nRight now the link between the styles and the components is done by class names (`App-header`, etc).\nLater on we'll learn better strategies of sorting our styles and making\nsure they are not touching components that we don't want them to affect.\n\nNext file - `App.test.tsx`.\nThis file contains automatic tests to make sure our app is doing what it's suppose to do.\n\nWe are programmers, that means that many times our job is to take something manual and making it automatic.\nThat's why we should also strive to automate things we do ourselves.\nType checking is one area, testing is another.  If we can automate tests and run them all the time, it can save us a lot of time\nand bring us a lot of confidence that when we change our code, we haven't destroyed anything.\n\nThe testing tool that create-react-app provides us with is [Jest](https://jestjs.io/).\n\nRight now we have only one simple test - it renders the App React component and makes sure nothing crashes.\nRun the test by running `yarn test` in the command line.\n\nNow go and remove the export from the app component. see how the tests picked up immediately that something is wrong.\n\nIn a later chapter we'll learn how to test more things to make sure we get guarantees that things are working as expected.\n\n## Pin dependencies and save-exact\n\nCheckout the package versions on the `package.json` file.\n\nyou can see the `^` sign.  That means that every time someone will get this code and run `yarn`, what `yarn` will do is to get the newest version on that range.\nWe don't want that. We want to first be notified when a new version is out and we want to explicitly update it.\n\nThat's why we need to add 2 things into our code:\nFirst, to delete all `^`.\n\n[{]: <helper> (diffStep \"1.2\" files=\"package.json\" module=\"client\")\n\n#### [__Client__ Step 1.2: Pin dependencies](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/56ab6fc)\n\n##### Changed package.json\n```diff\n@@ -7,14 +7,14 @@\n ┊ 7┊ 7┊    \"url\": \"https://github.com/Urigo/WhatsApp-Clone-Client-React.git\"\n ┊ 8┊ 8┊  },\n ┊ 9┊ 9┊  \"dependencies\": {\n-┊10┊  ┊    \"@types/jest\": \"24.0.13\",\n-┊11┊  ┊    \"@types/node\": \"12.0.1\",\n-┊12┊  ┊    \"@types/react\": \"16.8.17\",\n+┊  ┊10┊    \"@types/jest\": \"24.0.15\",\n+┊  ┊11┊    \"@types/node\": \"12.0.8\",\n+┊  ┊12┊    \"@types/react\": \"16.8.20\",\n ┊13┊13┊    \"@types/react-dom\": \"16.8.4\",\n-┊14┊  ┊    \"react\": \"^16.8.6\",\n-┊15┊  ┊    \"react-dom\": \"^16.8.6\",\n+┊  ┊14┊    \"react\": \"16.8.6\",\n+┊  ┊15┊    \"react-dom\": \"16.8.6\",\n ┊16┊16┊    \"react-scripts\": \"3.0.1\",\n-┊17┊  ┊    \"typescript\": \"3.4.5\"\n+┊  ┊17┊    \"typescript\": \"3.5.2\"\n ┊18┊18┊  },\n ┊19┊19┊  \"scripts\": {\n ┊20┊20┊    \"start\": \"react-scripts start\",\n```\n```diff\n@@ -37,4 +37,4 @@\n ┊37┊37┊      \"last 1 safari version\"\n ┊38┊38┊    ]\n ┊39┊39┊  }\n-┊40┊  ┊}\n+┊  ┊40┊}🚫↵\n```\n\n[}]: #\n\nSecond, to add the following command that will make each `yarn add <package-name>` command automatically add the library without any additions or `^` signs into it.\n\n[{]: <helper> (diffStep \"1.2\" files=\".npmrc\" module=\"client\")\n\n#### [__Client__ Step 1.2: Pin dependencies](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/56ab6fc)\n\n##### Added .npmrc\n```diff\n@@ -0,0 +1 @@\n+┊ ┊1┊save-exact=true\n```\n\n[}]: #\n\nThere is no need to upgrade your dependencies at all. If they work it's ok. But, it is highly recommended.\nPackages keep improving all the time with important things that would help your app and will save you time.\nIf you make it a routine to upgrade it makes it much easier then to upgrade every couple of months.\nIn order to discover if there are new versions of libraries there are 2 options.\n\nOne is to manually run a check every day or so to find new packages out there.\nYou can do that by going to your command line in the root folder of the project and type `yarn outdated`.\n\nBut if you want to get notified when there is a new version of your dependencies, you can check out [Renovate](https://github.com/renovatebot/renovate).\nIf your project is hosted somewhere, for example Github, it will analyze your `package.json` and submit a new PR when a new release happened from one of your dependencies.\n\n## git and saving your code on Github\n\nIf you want to save your code somewhere where you can track versions, using [git](https://git-scm.com/book/en/v2) and [Github](https://guides.github.com/activities/hello-world/) is a good choice.\nHere is a nice guide to start: https://try.github.io/.\n\nYou can check out the `.gitignore` file create-react-app has set up for us in the root folder.\nThat file will tell `.git` what not to save and not to upload.\n\n## Code formatting\n\nSome developers write code in a different style than others and it might be annoying while doing code reviews or even merging conflicts. That's why we want to make it consistent. We're going to use **Prettier** which has an opinionated set of styling rules and supports many languages. Your IDE most likely supports it too.\n\n    $ yarn add prettier\n\nWe're going to define a npm script called `format`, few styling rules and we're also going to ignore *node_modules*:\n\n[{]: <helper> (diffStep \"1.3\" files=\"package.json, .prettierrc.yml, .prettierignore\" module=\"client\")\n\n#### [__Client__ Step 1.3: Use Prettier](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/d5ba91b)\n\n##### Added .prettierignore\n```diff\n@@ -0,0 +1 @@\n+┊ ┊1┊node_modules🚫↵\n```\n\n##### Added .prettierrc.yml\n```diff\n@@ -0,0 +1,4 @@\n+┊ ┊1┊trailingComma: 'es5'\n+┊ ┊2┊tabWidth: 2\n+┊ ┊3┊singleQuote: true\n+┊ ┊4┊jsxBracketSameLine: true\n```\n\n##### Changed package.json\n```diff\n@@ -11,6 +11,7 @@\n ┊11┊11┊    \"@types/node\": \"12.0.8\",\n ┊12┊12┊    \"@types/react\": \"16.8.20\",\n ┊13┊13┊    \"@types/react-dom\": \"16.8.4\",\n+┊  ┊14┊    \"prettier\": \"1.18.2\",\n ┊14┊15┊    \"react\": \"16.8.6\",\n ┊15┊16┊    \"react-dom\": \"16.8.6\",\n ┊16┊17┊    \"react-scripts\": \"3.0.1\",\n```\n```diff\n@@ -20,7 +21,8 @@\n ┊20┊21┊    \"start\": \"react-scripts start\",\n ┊21┊22┊    \"build\": \"react-scripts build\",\n ┊22┊23┊    \"test\": \"TZ=\\\"Asia/Jerusalem\\\" react-scripts test\",\n-┊23┊  ┊    \"eject\": \"react-scripts eject\"\n+┊  ┊24┊    \"eject\": \"react-scripts eject\",\n+┊  ┊25┊    \"format\": \"prettier '**/*.{ts,tsx,css,graphql}' --write\"\n ┊24┊26┊  },\n ┊25┊27┊  \"eslintConfig\": {\n ┊26┊28┊    \"extends\": \"react-app\"\n```\n\n[}]: #\n\nNow let's run:\n\n    $ yarn format\n\nPrettier should format your code:\n\n[{]: <helper> (diffStep \"1.3\" files=\"src/App.tsx\" module=\"client\")\n\n#### [__Client__ Step 1.3: Use Prettier](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/d5ba91b)\n\n##### Changed src&#x2F;App.tsx\n```diff\n@@ -14,13 +14,12 @@\n ┊14┊14┊          className=\"App-link\"\n ┊15┊15┊          href=\"https://reactjs.org\"\n ┊16┊16┊          target=\"_blank\"\n-┊17┊  ┊          rel=\"noopener noreferrer\"\n-┊18┊  ┊        >\n+┊  ┊17┊          rel=\"noopener noreferrer\">\n ┊19┊18┊          Learn React\n ┊20┊19┊        </a>\n ┊21┊20┊      </header>\n ┊22┊21┊    </div>\n ┊23┊22┊  );\n-┊24┊  ┊}\n+┊  ┊23┊};\n ┊25┊24┊\n ┊26┊25┊export default App;\n```\n\n[}]: #\n\n> Remember to run `yarn prettier` before you comit your changes!\n\n**End of intro**\n\nAssuming that everything is set, we will now create our first screen - `ChatsListScreen`.\nThe ChatsListScreen component is responsible for showing the active conversations within our app.\n\nIt's best to first schematically plan how our view's gonna look like.\nThis would help us illustrate the intended view and also understand which React.Components / elements take part in it.\nThis is how our screen's gonna look like:\n\n![chatslistscreen](https://user-images.githubusercontent.com/7648874/54027873-01305280-41de-11e9-9df0-5ad9c9c2f226.png)\n\nLet's break down the image above and see what components are we gonna have in the `ChatsListScreen`:\n\n- Navbar -  Which should contain a simple static title for now.\n- ChatsList - Where each item's gonna contain some data regards the user we're chatting with and information about the chat.\n\nFirst let's remove the current React code and add our own code into it.\n\nFor now, let's create fake data on our HTML.\n\nAdd this data will be changed and we are not going to manually add HTML tags every time there is a new message, let's move our data into a JSON structure.\nFor now it would be a structure we will manually create.\nThat way we can make our React component already behave like our final version.\n\n[{]: <helper> (diffStep \"1.4\" files=\"App.tsx\" module=\"client\")\n\n#### [__Client__ Step 1.4: Create ChatsList screen](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/28d3c10)\n\n##### Changed src&#x2F;App.tsx\n```diff\n@@ -1,23 +1,31 @@\n ┊ 1┊ 1┊import React from 'react';\n-┊ 2┊  ┊import logo from './logo.svg';\n-┊ 3┊  ┊import './App.css';\n ┊ 4┊ 2┊\n ┊ 5┊ 3┊const App: React.FC = () => {\n ┊ 6┊ 4┊  return (\n-┊ 7┊  ┊    <div className=\"App\">\n-┊ 8┊  ┊      <header className=\"App-header\">\n-┊ 9┊  ┊        <img src={logo} className=\"App-logo\" alt=\"logo\" />\n-┊10┊  ┊        <p>\n-┊11┊  ┊          Edit <code>src/App.tsx</code> and save to reload.\n-┊12┊  ┊        </p>\n-┊13┊  ┊        <a\n-┊14┊  ┊          className=\"App-link\"\n-┊15┊  ┊          href=\"https://reactjs.org\"\n-┊16┊  ┊          target=\"_blank\"\n-┊17┊  ┊          rel=\"noopener noreferrer\">\n-┊18┊  ┊          Learn React\n-┊19┊  ┊        </a>\n-┊20┊  ┊      </header>\n+┊  ┊ 5┊    <div>\n+┊  ┊ 6┊      <div>Whatsapp Clone</div>\n+┊  ┊ 7┊      <div>\n+┊  ┊ 8┊        <ul>\n+┊  ┊ 9┊          <li>\n+┊  ┊10┊            <img\n+┊  ┊11┊              src=\"https://randomuser.me/api/portraits/thumb/men/1.jpg\"\n+┊  ┊12┊              alt=\"Profile\"\n+┊  ┊13┊            />\n+┊  ┊14┊            <div>Ethan Gonzalez</div>\n+┊  ┊15┊            <div>You on your way?</div>\n+┊  ┊16┊            <div>10:25</div>\n+┊  ┊17┊          </li>\n+┊  ┊18┊          <li>\n+┊  ┊19┊            <img\n+┊  ┊20┊              src=\"https://randomuser.me/api/portraits/thumb/men/2.jpg\"\n+┊  ┊21┊              alt=\"Profile\"\n+┊  ┊22┊            />\n+┊  ┊23┊            <div>Bryan Wallace</div>\n+┊  ┊24┊            <div>Hey, it's me</div>\n+┊  ┊25┊            <div>13:27</div>\n+┊  ┊26┊          </li>\n+┊  ┊27┊        </ul>\n+┊  ┊28┊      </div>\n ┊21┊29┊    </div>\n ┊22┊30┊  );\n ┊23┊31┊};\n```\n\n[}]: #\n\nIf all we do in the function is just returning a value, instead of `const App: React.FC = () => { return () };` we can also do `const App: React.FC = () => ();`\nSo let's use that for our ChatsList component.\n\nWe have to import React to make sure it will work.\nWe also have to export our component function so that the `App` component would be able to import it.\n(You can't import Javascript variables from a file if that file won't explicitly export it).\n\nAs we don't use those styles and logos anymore, we can delete the `src/App.css` and the `src/logo.svg` files from our app.\n\nNow let's move ChatsList into it's own component:\n\n[{]: <helper> (diffStep \"1.5\" files=\"ChatsList.tsx\" module=\"client\")\n\n#### [__Client__ Step 1.5: Move ChatsList to a component](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/0a8fd60)\n\n##### Added src&#x2F;components&#x2F;ChatsList.tsx\n```diff\n@@ -0,0 +1,22 @@\n+┊  ┊ 1┊import React from 'react';\n+┊  ┊ 2┊\n+┊  ┊ 3┊const ChatsList: React.FC = () => (\n+┊  ┊ 4┊  <div>\n+┊  ┊ 5┊    <ul>\n+┊  ┊ 6┊        <li>\n+┊  ┊ 7┊          <img src=\"https://randomuser.me/api/portraits/thumb/men/1.jpg\" alt=\"Profile\"/>\n+┊  ┊ 8┊          <div>Ethan Gonzalez</div>\n+┊  ┊ 9┊            <div>You on your way?</div>\n+┊  ┊10┊            <div>10:25</div>\n+┊  ┊11┊        </li>\n+┊  ┊12┊        <li>\n+┊  ┊13┊          <img src=\"https://randomuser.me/api/portraits/thumb/men/2.jpg\" alt=\"Profile\"/>\n+┊  ┊14┊          <div>Bryan Wallace</div>\n+┊  ┊15┊            <div>Hey, it's me</div>\n+┊  ┊16┊            <div>13:27</div>\n+┊  ┊17┊        </li>\n+┊  ┊18┊    </ul>\n+┊  ┊19┊  </div>\n+┊  ┊20┊);\n+┊  ┊21┊\n+┊  ┊22┊export default ChatsList;🚫↵\n```\n\n[}]: #\n\nand let's import that component into the App component and use the shorter syntax for the functional component:\n\n[{]: <helper> (diffStep \"1.5\" files=\"App.tsx\" module=\"client\")\n\n#### [__Client__ Step 1.5: Move ChatsList to a component](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/0a8fd60)\n\n##### Changed src&#x2F;App.tsx\n```diff\n@@ -1,31 +1,13 @@\n ┊ 1┊ 1┊import React from 'react';\n+┊  ┊ 2┊import ChatsList from './components/ChatsList';\n ┊ 2┊ 3┊\n ┊ 3┊ 4┊const App: React.FC = () => {\n ┊ 4┊ 5┊  return (\n ┊ 5┊ 6┊    <div>\n-┊ 6┊  ┊      <div>Whatsapp Clone</div>\n ┊ 7┊ 7┊      <div>\n-┊ 8┊  ┊        <ul>\n-┊ 9┊  ┊          <li>\n-┊10┊  ┊            <img\n-┊11┊  ┊              src=\"https://randomuser.me/api/portraits/thumb/men/1.jpg\"\n-┊12┊  ┊              alt=\"Profile\"\n-┊13┊  ┊            />\n-┊14┊  ┊            <div>Ethan Gonzalez</div>\n-┊15┊  ┊            <div>You on your way?</div>\n-┊16┊  ┊            <div>10:25</div>\n-┊17┊  ┊          </li>\n-┊18┊  ┊          <li>\n-┊19┊  ┊            <img\n-┊20┊  ┊              src=\"https://randomuser.me/api/portraits/thumb/men/2.jpg\"\n-┊21┊  ┊              alt=\"Profile\"\n-┊22┊  ┊            />\n-┊23┊  ┊            <div>Bryan Wallace</div>\n-┊24┊  ┊            <div>Hey, it's me</div>\n-┊25┊  ┊            <div>13:27</div>\n-┊26┊  ┊          </li>\n-┊27┊  ┊        </ul>\n+┊  ┊ 8┊        Whatsapp Clone\n ┊28┊ 9┊      </div>\n+┊  ┊10┊      <ChatsList />\n ┊29┊11┊    </div>\n ┊30┊12┊  );\n ┊31┊13┊};\n```\n\n[}]: #\n\nand let's do the same for our Navbar:\n\n[{]: <helper> (diffStep \"1.6\" module=\"client\")\n\n#### [__Client__ Step 1.6: Move ChatsNavbar to a component](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/6c59c5e)\n\n##### Changed src&#x2F;App.tsx\n```diff\n@@ -1,12 +1,11 @@\n ┊ 1┊ 1┊import React from 'react';\n ┊ 2┊ 2┊import ChatsList from './components/ChatsList';\n+┊  ┊ 3┊import ChatsNavbar from './components/ChatsNavbar';\n ┊ 3┊ 4┊\n ┊ 4┊ 5┊const App: React.FC = () => {\n ┊ 5┊ 6┊  return (\n ┊ 6┊ 7┊    <div>\n-┊ 7┊  ┊      <div>\n-┊ 8┊  ┊        Whatsapp Clone\n-┊ 9┊  ┊      </div>\n+┊  ┊ 8┊      <ChatsNavbar />\n ┊10┊ 9┊      <ChatsList />\n ┊11┊10┊    </div>\n ┊12┊11┊  );\n```\n\n##### Changed src&#x2F;components&#x2F;ChatsList.tsx\n```diff\n@@ -3,20 +3,26 @@\n ┊ 3┊ 3┊const ChatsList: React.FC = () => (\n ┊ 4┊ 4┊  <div>\n ┊ 5┊ 5┊    <ul>\n-┊ 6┊  ┊        <li>\n-┊ 7┊  ┊          <img src=\"https://randomuser.me/api/portraits/thumb/men/1.jpg\" alt=\"Profile\"/>\n-┊ 8┊  ┊          <div>Ethan Gonzalez</div>\n-┊ 9┊  ┊            <div>You on your way?</div>\n-┊10┊  ┊            <div>10:25</div>\n-┊11┊  ┊        </li>\n-┊12┊  ┊        <li>\n-┊13┊  ┊          <img src=\"https://randomuser.me/api/portraits/thumb/men/2.jpg\" alt=\"Profile\"/>\n-┊14┊  ┊          <div>Bryan Wallace</div>\n-┊15┊  ┊            <div>Hey, it's me</div>\n-┊16┊  ┊            <div>13:27</div>\n-┊17┊  ┊        </li>\n+┊  ┊ 6┊      <li>\n+┊  ┊ 7┊        <img\n+┊  ┊ 8┊          src=\"https://randomuser.me/api/portraits/thumb/men/1.jpg\"\n+┊  ┊ 9┊          alt=\"Profile\"\n+┊  ┊10┊        />\n+┊  ┊11┊        <div>Ethan Gonzalez</div>\n+┊  ┊12┊        <div>You on your way?</div>\n+┊  ┊13┊        <div>10:25</div>\n+┊  ┊14┊      </li>\n+┊  ┊15┊      <li>\n+┊  ┊16┊        <img\n+┊  ┊17┊          src=\"https://randomuser.me/api/portraits/thumb/men/2.jpg\"\n+┊  ┊18┊          alt=\"Profile\"\n+┊  ┊19┊        />\n+┊  ┊20┊        <div>Bryan Wallace</div>\n+┊  ┊21┊        <div>Hey, it's me</div>\n+┊  ┊22┊        <div>13:27</div>\n+┊  ┊23┊      </li>\n ┊18┊24┊    </ul>\n ┊19┊25┊  </div>\n ┊20┊26┊);\n ┊21┊27┊\n-┊22┊  ┊export default ChatsList;🚫↵\n+┊  ┊28┊export default ChatsList;\n```\n\n##### Added src&#x2F;components&#x2F;ChatsNavbar.tsx\n```diff\n@@ -0,0 +1,5 @@\n+┊ ┊1┊import React from 'react';\n+┊ ┊2┊\n+┊ ┊3┊const ChatsNavbar: React.FC = () => <div>Whatsapp Clone</div>;\n+┊ ┊4┊\n+┊ ┊5┊export default ChatsNavbar;\n```\n\n[}]: #\n\nReact apps tend to store React.Components under a directory located at `src/components`, and so we're gonna follow this pattern.\nWe will create a directory called ChatsListScreen in the `components` dir where we're simply gonna import and put together the Navbar and ChatsList components.\nThis is how the contents of that directory should look like:\n\n    ChatsListScreen\n    ├── index.tsx\n    ├── ChatsList\n    └── ChatsNavbar\n\nWe will use the `index.tsx` file to define that component, this way we can import it using the directory name:\n\n[{]: <helper> (diffStep \"1.7\" module=\"client\")\n\n#### [__Client__ Step 1.7: Move all ChatsListScreen into a folder](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/c9c25d8)\n\n##### Changed src&#x2F;App.tsx\n```diff\n@@ -1,14 +1,10 @@\n ┊ 1┊ 1┊import React from 'react';\n-┊ 2┊  ┊import ChatsList from './components/ChatsList';\n-┊ 3┊  ┊import ChatsNavbar from './components/ChatsNavbar';\n+┊  ┊ 2┊import ChatsListScreen from './components/ChatsListScreen';\n ┊ 4┊ 3┊\n-┊ 5┊  ┊const App: React.FC = () => {\n-┊ 6┊  ┊  return (\n-┊ 7┊  ┊    <div>\n-┊ 8┊  ┊      <ChatsNavbar />\n-┊ 9┊  ┊      <ChatsList />\n-┊10┊  ┊    </div>\n-┊11┊  ┊  );\n-┊12┊  ┊};\n+┊  ┊ 4┊const App: React.FC = () => (\n+┊  ┊ 5┊  <div>\n+┊  ┊ 6┊    <ChatsListScreen />\n+┊  ┊ 7┊  </div>\n+┊  ┊ 8┊);\n ┊13┊ 9┊\n ┊14┊10┊export default App;\n```\n\n##### Renamed from src&#x2F;components&#x2F;ChatsList.tsx to src&#x2F;components&#x2F;ChatsListScreen&#x2F;ChatsList.tsx\n\n\n##### Renamed from src&#x2F;components&#x2F;ChatsNavbar.tsx to src&#x2F;components&#x2F;ChatsListScreen&#x2F;ChatsNavbar.tsx\n\n\n##### Added src&#x2F;components&#x2F;ChatsListScreen&#x2F;index.tsx\n```diff\n@@ -0,0 +1,12 @@\n+┊  ┊ 1┊import React from 'react';\n+┊  ┊ 2┊import ChatsNavbar from './ChatsNavbar';\n+┊  ┊ 3┊import ChatsList from './ChatsList';\n+┊  ┊ 4┊\n+┊  ┊ 5┊const ChatsListScreen: React.FC = () => (\n+┊  ┊ 6┊  <div>\n+┊  ┊ 7┊    <ChatsNavbar />\n+┊  ┊ 8┊    <ChatsList />\n+┊  ┊ 9┊  </div>\n+┊  ┊10┊);\n+┊  ┊11┊\n+┊  ┊12┊export default ChatsListScreen;\n```\n\n[}]: #\n\nNow, we have our app rendering our view, but it is completely static and manual in the code.\n\nIf we had 10 messages, we wouldn't want to type all of those HTML tags again and again.\nAlso if the data will change, the app should do this update itself without the need of hand written code.\n\nSo let's create a file that lists just the data of our chats and then make our React component render a line for each entry in that file.\n\nWe will create the file in a JSON format:\n\n[{]: <helper> (diffStep \"1.8\" files=\"db.ts\" module=\"client\")\n\n#### [__Client__ Step 1.8: Attach unique keys to ChatsList](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/693443b)\n\n##### Added src&#x2F;db.ts\n```diff\n@@ -0,0 +1,49 @@\n+┊  ┊ 1┊export const messages = [\n+┊  ┊ 2┊  {\n+┊  ┊ 3┊    id: 1,\n+┊  ┊ 4┊    content: 'You on your way?',\n+┊  ┊ 5┊    createdAt: new Date(Date.now() - 60 * 1000 * 1000),\n+┊  ┊ 6┊  },\n+┊  ┊ 7┊  {\n+┊  ┊ 8┊    id: 2,\n+┊  ┊ 9┊    content: \"Hey, it's me\",\n+┊  ┊10┊    createdAt: new Date(Date.now() - 2 * 60 * 1000 * 1000),\n+┊  ┊11┊  },\n+┊  ┊12┊  {\n+┊  ┊13┊    id: 3,\n+┊  ┊14┊    content: 'I should buy a boat',\n+┊  ┊15┊    createdAt: new Date(Date.now() - 24 * 60 * 1000 * 1000),\n+┊  ┊16┊  },\n+┊  ┊17┊  {\n+┊  ┊18┊    id: 4,\n+┊  ┊19┊    content: 'This is wicked good ice cream.',\n+┊  ┊20┊    createdAt: new Date(Date.now() - 14 * 24 * 60 * 1000 * 1000),\n+┊  ┊21┊  },\n+┊  ┊22┊];\n+┊  ┊23┊\n+┊  ┊24┊export const chats = [\n+┊  ┊25┊  {\n+┊  ┊26┊    id: 1,\n+┊  ┊27┊    name: 'Ethan Gonzalez',\n+┊  ┊28┊    picture: 'https://randomuser.me/api/portraits/thumb/men/1.jpg',\n+┊  ┊29┊    lastMessage: messages.find(m => m.id === 1),\n+┊  ┊30┊  },\n+┊  ┊31┊  {\n+┊  ┊32┊    id: 2,\n+┊  ┊33┊    name: 'Bryan Wallace',\n+┊  ┊34┊    picture: 'https://randomuser.me/api/portraits/thumb/men/2.jpg',\n+┊  ┊35┊    lastMessage: messages.find(m => m.id === 2),\n+┊  ┊36┊  },\n+┊  ┊37┊  {\n+┊  ┊38┊    id: 3,\n+┊  ┊39┊    name: 'Avery Stewart',\n+┊  ┊40┊    picture: 'https://randomuser.me/api/portraits/thumb/women/1.jpg',\n+┊  ┊41┊    lastMessage: messages.find(m => m.id === 3),\n+┊  ┊42┊  },\n+┊  ┊43┊  {\n+┊  ┊44┊    id: 4,\n+┊  ┊45┊    name: 'Katie Peterson',\n+┊  ┊46┊    picture: 'https://randomuser.me/api/portraits/thumb/women/2.jpg',\n+┊  ┊47┊    lastMessage: messages.find(m => m.id === 4),\n+┊  ┊48┊  },\n+┊  ┊49┊];\n```\n\n[}]: #\n\nWe are giving IDs for the values just like a database gives a unique id for each value.\n\nThe is so we can reference specific values, for example,\nlast message would actually reference the other array instead of duplicating the values.\n\nNow let's change ChatsList component to import the data from that file.\nThen to use the Javascript [map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)\nfunction to render a line for each data entry:\n\n[{]: <helper> (diffStep \"1.8\" files=\"ChatsList.tsx\" module=\"client\")\n\n#### [__Client__ Step 1.8: Attach unique keys to ChatsList](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/693443b)\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;ChatsList.tsx\n```diff\n@@ -1,26 +1,15 @@\n ┊ 1┊ 1┊import React from 'react';\n+┊  ┊ 2┊import { chats } from '../../db';\n ┊ 2┊ 3┊\n ┊ 3┊ 4┊const ChatsList: React.FC = () => (\n ┊ 4┊ 5┊  <div>\n ┊ 5┊ 6┊    <ul>\n-┊ 6┊  ┊      <li>\n-┊ 7┊  ┊        <img\n-┊ 8┊  ┊          src=\"https://randomuser.me/api/portraits/thumb/men/1.jpg\"\n-┊ 9┊  ┊          alt=\"Profile\"\n-┊10┊  ┊        />\n-┊11┊  ┊        <div>Ethan Gonzalez</div>\n-┊12┊  ┊        <div>You on your way?</div>\n-┊13┊  ┊        <div>10:25</div>\n-┊14┊  ┊      </li>\n-┊15┊  ┊      <li>\n-┊16┊  ┊        <img\n-┊17┊  ┊          src=\"https://randomuser.me/api/portraits/thumb/men/2.jpg\"\n-┊18┊  ┊          alt=\"Profile\"\n-┊19┊  ┊        />\n-┊20┊  ┊        <div>Bryan Wallace</div>\n-┊21┊  ┊        <div>Hey, it's me</div>\n-┊22┊  ┊        <div>13:27</div>\n-┊23┊  ┊      </li>\n+┊  ┊ 7┊      {chats.map(chat => (\n+┊  ┊ 8┊        <li key={chat.id}>\n+┊  ┊ 9┊          <img src={chat.picture} alt=\"Profile\" />\n+┊  ┊10┊          <div>{chat.name}</div>\n+┊  ┊11┊        </li>\n+┊  ┊12┊      ))}\n ┊24┊13┊    </ul>\n ┊25┊14┊  </div>\n ┊26┊15┊);\n```\n\n[}]: #\n\nWhen running `map` on the `chats` array, it will run a function for each entry in the array and return a value.\nThe function will receive the current entry as a parameter.\nIn our case the function will get the current function and will return a JSX line with the data of that specific chat.\n\nNotice we are also adding the `key` tag with the ID of each chat.\nIf you'll remove that and render again you will see the following error inside the console of your [Chrome developer tools](https://developers.google.com/web/tools/chrome-devtools/):\n`Warning: Each child in a list should have a unique \"key\" prop`.\n\nBy telling React how to identify and distinguish each element using the `key` value we help solve that problem and also making React faster.\nRead [here](https://reactjs.org/docs/lists-and-keys.html) for more in depth explanation.\n\nNow that we rendered a line for each chat, let's add also the last message's content and creation date for each chat:\n\n[{]: <helper> (diffStep \"1.9\" module=\"client\")\n\n#### [__Client__ Step 1.9: Failed try to add last message to ChatsList](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/499bfc7)\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;ChatsList.tsx\n```diff\n@@ -8,6 +8,8 @@\n ┊ 8┊ 8┊        <li key={chat.id}>\n ┊ 9┊ 9┊          <img src={chat.picture} alt=\"Profile\" />\n ┊10┊10┊          <div>{chat.name}</div>\n+┊  ┊11┊          <div>{chat.lastMessage.content}</div>\n+┊  ┊12┊          <div>{chat.lastMessage.createdAt}</div>\n ┊11┊13┊        </li>\n ┊12┊14┊      ))}\n ┊13┊15┊    </ul>\n```\n\n[}]: #\n\nTry to run the app again.\n\nYou can see we get a Typescript error.\nThis is because Typescript is smart enough and tells us there might be no last message.\nSo we add a check.\nRemember to always check for null or undefined if optional, don’t write shorter write safer:\n\n[{]: <helper> (diffStep \"1.10\" module=\"client\")\n\n#### [__Client__ Step 1.10: Second failed try to add last message to ChatsList](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/a2c85cb)\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;ChatsList.tsx\n```diff\n@@ -8,8 +8,10 @@\n ┊ 8┊ 8┊        <li key={chat.id}>\n ┊ 9┊ 9┊          <img src={chat.picture} alt=\"Profile\" />\n ┊10┊10┊          <div>{chat.name}</div>\n+┊  ┊11┊          {chat.lastMessage && (\n ┊11┊12┊          <div>{chat.lastMessage.content}</div>\n ┊12┊13┊          <div>{chat.lastMessage.createdAt}</div>\n+┊  ┊14┊          )}\n ┊13┊15┊        </li>\n ┊14┊16┊      ))}\n ┊15┊17┊    </ul>\n```\n\n[}]: #\n\nNow let's try again.\n\nNow we have a syntax error - A JSX return value can't have more then a single root Element.\nSo in order to return a root element from the function but still display multiple elements in the same level,\nwe can use [React.Fragment](https://reactjs.org/docs/fragments.html) to wrap the returned elements:\n\n[{]: <helper> (diffStep \"1.11\" module=\"client\")\n\n#### [__Client__ Step 1.11: Third failed try to add last message to ChatsList](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/3df0b87)\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;ChatsList.tsx\n```diff\n@@ -9,8 +9,10 @@\n ┊ 9┊ 9┊          <img src={chat.picture} alt=\"Profile\" />\n ┊10┊10┊          <div>{chat.name}</div>\n ┊11┊11┊          {chat.lastMessage && (\n-┊12┊  ┊          <div>{chat.lastMessage.content}</div>\n-┊13┊  ┊          <div>{chat.lastMessage.createdAt}</div>\n+┊  ┊12┊            <React.Fragment>\n+┊  ┊13┊              <div>{chat.lastMessage.content}</div>\n+┊  ┊14┊              <div>{chat.lastMessage.createdAt}</div>\n+┊  ┊15┊            </React.Fragment>\n ┊14┊16┊          )}\n ┊15┊17┊        </li>\n ┊16┊18┊      ))}\n```\n\n[}]: #\n\n\nLet's try again.  This time it looks like the format is not correct, so let's format the date using the `moment` library.\n\nLet's install the [`moment`](https://momentjs.com/) library to wrap `lastMessage.createdAt` with a better format.\nMoment has the ability to wrap date objects nicely and rewrite them in a pretty format.\nThis way we can have an elegant time format at which the message was sent e.g. `11:34`.\nTo install:\n\n\t$ yarn add moment\n\n\nAnd now let's import the library by it's name, wrap the value of each chat and call the `format` function with our requested format:\n\n[{]: <helper> (diffStep \"1.12\" files=\"ChatsList.tsx\" module=\"client\")\n\n#### [__Client__ Step 1.12: Success adding last message to ChatsList](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/164512a)\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;ChatsList.tsx\n```diff\n@@ -1,5 +1,6 @@\n ┊1┊1┊import React from 'react';\n ┊2┊2┊import { chats } from '../../db';\n+┊ ┊3┊import moment from 'moment';\n ┊3┊4┊\n ┊4┊5┊const ChatsList: React.FC = () => (\n ┊5┊6┊  <div>\n```\n```diff\n@@ -11,7 +12,7 @@\n ┊11┊12┊          {chat.lastMessage && (\n ┊12┊13┊            <React.Fragment>\n ┊13┊14┊              <div>{chat.lastMessage.content}</div>\n-┊14┊  ┊              <div>{chat.lastMessage.createdAt}</div>\n+┊  ┊15┊              <div>{moment(chat.lastMessage.createdAt).format('HH:mm')}</div>\n ┊15┊16┊            </React.Fragment>\n ┊16┊17┊          )}\n ┊17┊18┊        </li>\n```\n\n[}]: #\n\n\nIf you'll try to run the app you'll see that everything is there, but it's not hard to notice that it's missing some style:\n\n![naked-chats-list](https://user-images.githubusercontent.com/7648874/54028578-73099b80-41e0-11e9-803a-7469300acb06.png)\n\nIn the next chapter we will take care of styling our application with [Material-UI](https://material-ui.com/) and [styled-components](https://www.styled-components.com/) - we will give it the desired look and make it more user friendly. For now the ChatsListScreen serves no purpose, because you can't really do anything with it, but it can be used as a great basis to build on top of as we make progress.\n\nTODO: Define and use Prettier.\nTODO: Editor and Prettier, extensions - Auto Import, GitLens, npm Intellisense, TypeScript Importer - works when Auto Import doesn't\nTODO: react-dev-tools, go through everything on dev tools.\nTODO: build. show built code. show it on file and show it on the browser.\nTODO: Go through all of https://facebook.github.io/create-react-app/docs/\nTODO: Should we talk about Storybook?\nTODO: Should we use “” or ‘’?\nTODO: Should we use date-fns instead of moment?"
          },
          {
            "manualTitle": "Step 2: Styling with Material UI and styled-components",
            "stepRevision": "853bf2dbba8eb3a0be200f6aa3b6825fff3cabf1",
            "manualView": "Now it's time to style our app.\n\nWe can edit styles manually but we can also usie ready made components that have already been styled and shared in the community.\n\nIn this chapter we will do both.\n\nFirst, we would also use [Material-UI](https://material-ui.com/) - a library with a set of React components that implements Google's Material Design.\nWhat's good about it is that the design is already implemented right out of the box.\nNot only that, but it also includes a set of icons which are free to use.\n\nThere are many things that Material-UI can offer, and it's not easy to follow it up, especially with the constantly evolving and improving API.\nThe best way to go with it, is to identify a component you need, and then look for it in the [official website](https://material-ui.com/).\nAnd when it comes to searching for icons, they can be found on the [material.io](https://material-ui.com/) website through the search bar.\n\nAs we move further in this tutorial you should have a better grasp of Material and how to use it.\n\n![material-ui-icons](https://user-images.githubusercontent.com/7648874/54141504-c853e000-4460-11e9-94b5-aae98ec9a1e3.png)\n\nWe will start off by installing some of the needed material libraries and its Typescript types library:\n\n    $ yarn add @material-ui/core @material-ui/icons @types/material-ui\n\n`@material-ui/core` includes core component of Material-UI such as Input, Popover, Modal, etc, and `@material-ui/icons` includes a set of icons.\nMaterial is very generic and has a built in theming system which can be controlled by simply setting few variables,\nwhich is exactly what we're gonna need in our app.\n\nIn our app we're mainly gonna use 2 colors:\n\n- Primary #306759\n- Secondary #79e352\n\nThe easiest way to reference colors without repeating yourself is through Themes.\nTheme definition can easily be done in Material using the MuiThemeProvider component:\n\n[{]: <helper> (diffStep \"2.2\" module=\"client\")\n\n#### [__Client__ Step 2.2: Setup Material-UI theme](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/79f5de4)\n\n##### Changed src&#x2F;index.tsx\n```diff\n@@ -1,10 +1,23 @@\n+┊  ┊ 1┊import { MuiThemeProvider, createMuiTheme } from '@material-ui/core/styles';\n ┊ 1┊ 2┊import React from 'react';\n ┊ 2┊ 3┊import ReactDOM from 'react-dom';\n ┊ 3┊ 4┊import './index.css';\n ┊ 4┊ 5┊import App from './App';\n ┊ 5┊ 6┊import * as serviceWorker from './serviceWorker';\n ┊ 6┊ 7┊\n-┊ 7┊  ┊ReactDOM.render(<App />, document.getElementById('root'));\n+┊  ┊ 8┊const theme = createMuiTheme({\n+┊  ┊ 9┊  palette: {\n+┊  ┊10┊    primary: { main: '#2c6157' },\n+┊  ┊11┊    secondary: { main: '#6fd056' },\n+┊  ┊12┊  },\n+┊  ┊13┊});\n+┊  ┊14┊\n+┊  ┊15┊ReactDOM.render(\n+┊  ┊16┊  <MuiThemeProvider theme={theme}>\n+┊  ┊17┊    <App />\n+┊  ┊18┊  </MuiThemeProvider>,\n+┊  ┊19┊  document.getElementById('root')\n+┊  ┊20┊);\n ┊ 8┊21┊\n ┊ 9┊22┊// If you want your app to work offline and load faster, you can change\n ┊10┊23┊// unregister() to register() below. Note this comes with some pitfalls.\n```\n\n[}]: #\n\n\nWe create a `palette` of the themes together with any other definitions for the theme, and then we wrap our app with a React component\nfrom the `material-ui` library to provide those definitions to all of our App's components when they need them.\n\nOnce we have it set, the colors should be available to use in our application by simply providing the \"color\" prop to the component instance whose color we would like to change:\n\n```diff\n<Button color=\"primary\">Primary</Button>\n<Button color=\"secondary\">Secondary</Button>\n```\n\nIn our app, we're also gonna use CSS directly to change its colors, therefore it would be handy to have these theme variables available to us through CSS.\nTo do so, we will have a second definition of these variables in `index.css`, at the `:root` level of our application.\n\nThat feels like a small duplication but this will help us use them in styled components directly.\nAlso that means you can view the variables in chrome-dev-tools.\n\n[{]: <helper> (diffStep \"2.3\" module=\"client\")\n\n#### [__Client__ Step 2.3: Setup CSS theme vars](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/c5b5220)\n\n##### Changed src&#x2F;index.css\n```diff\n@@ -1,3 +1,10 @@\n+┊  ┊ 1┊:root {\n+┊  ┊ 2┊  --primary-bg: #2c6157;\n+┊  ┊ 3┊  --secondary-bg: #6fd056;\n+┊  ┊ 4┊  --primary-text: white;\n+┊  ┊ 5┊  --secondary-text: white;\n+┊  ┊ 6┊}\n+┊  ┊ 7┊\n ┊ 1┊ 8┊body {\n ┊ 2┊ 9┊  margin: 0;\n ┊ 3┊10┊  padding: 0;\n```\n\n[}]: #\n\n`:root` is a pseudo element that simply represents the root node, which will make the colors available in all elements.\nNormally, it works like JavaScript's scoping system and it will make variables available only to the current node and to its children, NOT its parents.\nCSS vars can be used like so:\n\n```css\n  color: var(--primary-text);\n  background-color: var(--primary-bg);\n```\n\nMore information about CSS variables can be found in the [official MDN docs](https://developer.mozilla.org/en-US/docs/Web/CSS/Using_CSS_variables).\n\nSo getting back to the ChatsListScreen, we will wrap the ChatsNavbar with Material's <Toolbar /> component:\n\n[{]: <helper> (diffStep \"2.4\" files=\"ChatsNavbar.tsx\" module=\"client\")\n\n#### [__Client__ Step 2.4: Use Material components](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/9b837d8)\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;ChatsNavbar.tsx\n```diff\n@@ -1,5 +1,6 @@\n ┊1┊1┊import React from 'react';\n+┊ ┊2┊import { Toolbar } from '@material-ui/core';\n ┊2┊3┊\n-┊3┊ ┊const ChatsNavbar: React.FC = () => <div>Whatsapp Clone</div>;\n+┊ ┊4┊const ChatsNavbar: React.FC = () => <Toolbar>Whatsapp Clone</Toolbar>;\n ┊4┊5┊\n ┊5┊6┊export default ChatsNavbar;\n```\n\n[}]: #\n\nAnd we will replace the `<ul />` and `<li />` elements with Material's `<List />` and `<ListItem />` in ChatsList:\n\n[{]: <helper> (diffStep \"2.4\" files=\"ChatsList.tsx\" module=\"client\")\n\n#### [__Client__ Step 2.4: Use Material components](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/9b837d8)\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;ChatsList.tsx\n```diff\n@@ -1,12 +1,13 @@\n ┊ 1┊ 1┊import React from 'react';\n ┊ 2┊ 2┊import { chats } from '../../db';\n ┊ 3┊ 3┊import moment from 'moment';\n+┊  ┊ 4┊import { List, ListItem } from '@material-ui/core';\n ┊ 4┊ 5┊\n ┊ 5┊ 6┊const ChatsList: React.FC = () => (\n ┊ 6┊ 7┊  <div>\n-┊ 7┊  ┊    <ul>\n+┊  ┊ 8┊    <List>\n ┊ 8┊ 9┊      {chats.map(chat => (\n-┊ 9┊  ┊        <li key={chat.id}>\n+┊  ┊10┊        <ListItem key={chat.id} button>\n ┊10┊11┊          <img src={chat.picture} alt=\"Profile\" />\n ┊11┊12┊          <div>{chat.name}</div>\n ┊12┊13┊          {chat.lastMessage && (\n```\n```diff\n@@ -15,9 +16,9 @@\n ┊15┊16┊              <div>{moment(chat.lastMessage.createdAt).format('HH:mm')}</div>\n ┊16┊17┊            </React.Fragment>\n ┊17┊18┊          )}\n-┊18┊  ┊        </li>\n+┊  ┊19┊        </ListItem>\n ┊19┊20┊      ))}\n-┊20┊  ┊    </ul>\n+┊  ┊21┊    </List>\n ┊21┊22┊  </div>\n ┊22┊23┊);\n ┊23┊24┊\n```\n\n[}]: #\n\nThanks to the `button` attribute, the Material component can give our list a more vibrant feeling and that will display a nice ripple effect once an item is clicked,\nsomething that could have taken a long time to implement manually.\n\nNow that we are using existing styled components, it's time to customize them to look exactly like we want them to look.\nWhen we write styles, we usually use CSS.\n\nOne of the important concepts that React brought us was the fact we could use just Javascript to describe our components\nand another was the fact that we could encapsulate our UI into a set of separated components.\n\nBut when it comes to CSS, we are still using it like before, having no encapsulation between different definitions and files.\n\n[Styled-components](https://www.styled-components.com/) is a relatively new library that will transpile a given string into a CSS string and will encapsulate it under a `React.Component`.\nBringing the same concepts from React into the way we write styles, so we ca define our styles programmatically.\nWith JavaScript in-hand you naturally have more control over our styles and its encapsulation, which makes it a very powerful tool.\n\nHere's one way to style a button using styled-components:\n\n```js\nimport styled, { css } from 'styled-components';\n\nconst Button = styled.button`\n  background: transparent;\n  border-radius: 3px;\n  border: 2px solid palevioletred;\n  color: palevioletred;\n  margin: 0.5em 1em;\n  padding: 0.25em 1em;\n\n  ${props => props.primary && css`\n    background: palevioletred;\n    color: white;\n  `}\n`;\n```\n\n* `styled` is coming from the `styled-components` library. When we call `styled.button` that means we are extending a button component from styled.\n* `Button` will become a full React componnet with the extended styled we specified\n* Like a React component, we can send props into our component. And like a React function, we can write Javascript code that interact and respond to those props.\nIn our case, just like a check we've done before in TSX to render something only if it exists, here only if we have a `primary` property, we will add extra styles to our component.\nThe created Button is actually a React.Component, so an instance of it can be created with ease like any other component:\n* `css` is telling Styled components that the string literal that comes after describes CSS styles.\n\n```jsx\n  <Button primary />\n```\n\nBut as this is just like a component, we should type it just like we type component, defining what properties it should get in:\n\n```tsx\nimport styled, { css } from 'styled-components';\n\ninterface ButtonProps {\n  readonly primary: any;\n};\n\nconst Button = styled.button<ButtonProps>`\n  background: transparent;\n  border-radius: 3px;\n  border: 2px solid palevioletred;\n  color: palevioletred;\n  margin: 0.5em 1em;\n  padding: 0.25em 1em;\n\n  ${props => props.primary && css`\n    background: palevioletred;\n    color: white;\n  `}\n`;\n```\n\nMore information about styled-components can be found in the official [docs page](https://www.styled-components.com/docs).\n\nNow, we will use `styled-components` to create new React.Components which are bound into a style-sheet.\nThis way when we create new instances of them, the components will be styled right out of the box. Example:\n\n```jsx\nconst Button = styled.button `\n  border-radius: 999px;\n`\n\nconst RedButton = styled(Button) `\n  color: red;\n`\n\nconst GreenButton = styled(Button) `\n  color: green;\n`\n\nconst BlueButton = styled(Button) `\n  color: blue;\n`\n\nconst Dashboard = (\n  <div>\n    <RedButton />\n    <GreenButton />\n    <BlueButton />\n  </div>\n)\n```\n\nThe clear advantage of such working strategy is that all the styles are encapsulated, unlike traditional CSS where style rules can easily collide and be merged unintentionally.\nRemember that **`styled-components` operates per component, not globally**.\n\nWe will start off by installing `styled-components` and its Typescript types library:\n\n    $ yarn add styled-components @types/styled-components\n\nNow, let's use `styled-components` our `ChatsListScreen`:\n\n[{]: <helper> (diffStep \"2.5\" files=\"index.tsx\" module=\"client\")\n\n#### [__Client__ Step 2.5: Add style with styled-components](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/78e3fee)\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;index.tsx\n```diff\n@@ -1,12 +1,17 @@\n ┊ 1┊ 1┊import React from 'react';\n ┊ 2┊ 2┊import ChatsNavbar from './ChatsNavbar';\n ┊ 3┊ 3┊import ChatsList from './ChatsList';\n+┊  ┊ 4┊import styled from 'styled-components';\n+┊  ┊ 5┊\n+┊  ┊ 6┊const Container = styled.div`\n+┊  ┊ 7┊  height: 100vh;\n+┊  ┊ 8┊`;\n ┊ 4┊ 9┊\n ┊ 5┊10┊const ChatsListScreen: React.FC = () => (\n-┊ 6┊  ┊  <div>\n+┊  ┊11┊  <Container>\n ┊ 7┊12┊    <ChatsNavbar />\n ┊ 8┊13┊    <ChatsList />\n-┊ 9┊  ┊  </div>\n+┊  ┊14┊  </Container>\n ┊10┊15┊);\n ┊11┊16┊\n ┊12┊17┊export default ChatsListScreen;\n```\n\n[}]: #\n\nHere you can see that we've created a new component called `Container`.\nThat component is extending `div` and adds some styles into it.\nThen we've replaced the `div` element with the new, enhanced `div` called `Container`.\n\nWith this we know for sure that the styles we applied for `Container` won't affect any other component in our app.\n\n[{]: <helper> (diffStep \"2.5\" files=\"ChatsNavbar.tsx\" module=\"client\")\n\n#### [__Client__ Step 2.5: Add style with styled-components](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/78e3fee)\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;ChatsNavbar.tsx\n```diff\n@@ -1,6 +1,14 @@\n ┊ 1┊ 1┊import React from 'react';\n ┊ 2┊ 2┊import { Toolbar } from '@material-ui/core';\n+┊  ┊ 3┊import styled from 'styled-components';\n ┊ 3┊ 4┊\n-┊ 4┊  ┊const ChatsNavbar: React.FC = () => <Toolbar>Whatsapp Clone</Toolbar>;\n+┊  ┊ 5┊const Container = styled(Toolbar)`\n+┊  ┊ 6┊  background-color: var(--primary-bg);\n+┊  ┊ 7┊  color: var(--primary-text);\n+┊  ┊ 8┊  font-size: 20px;\n+┊  ┊ 9┊  line-height: 40px;\n+┊  ┊10┊` as typeof Toolbar;\n+┊  ┊11┊\n+┊  ┊12┊const ChatsNavbar: React.FC = () => <Container>Whatsapp Clone</Container>;\n ┊ 5┊13┊\n ┊ 6┊14┊export default ChatsNavbar;\n```\n\n[}]: #\n\nHere you can see we've done the same, but instead of extending a built-in component from styled-component,\nwe enhanced the `Toolbar` component from `material-ui.\n\nNotice that we also called the wrapper `Container` but again it has no affect on any component outside of our specific component.\n\n> Notice that we've added Typescript type inference `as typeof Toolbar` at the end. That's because of an issue that suppose to be fixed when we'll upgrade to material-ui v4.\n\nLet's finish this off by doing the same in our last component:\n\n[{]: <helper> (diffStep \"2.5\" files=\"ChatsList.tsx\" module=\"client\")\n\n#### [__Client__ Step 2.5: Add style with styled-components](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/78e3fee)\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;ChatsList.tsx\n```diff\n@@ -2,24 +2,81 @@\n ┊ 2┊ 2┊import { chats } from '../../db';\n ┊ 3┊ 3┊import moment from 'moment';\n ┊ 4┊ 4┊import { List, ListItem } from '@material-ui/core';\n+┊  ┊ 5┊import styled from 'styled-components';\n ┊ 5┊ 6┊\n-┊ 6┊  ┊const ChatsList: React.FC = () => (\n-┊ 7┊  ┊  <div>\n-┊ 8┊  ┊    <List>\n+┊  ┊ 7┊const Container = styled.div`\n+┊  ┊ 8┊  height: calc(100% - 56px);\n+┊  ┊ 9┊  overflow-y: overlay;\n+┊  ┊10┊`;\n+┊  ┊11┊\n+┊  ┊12┊const StyledList = styled(List)`\n+┊  ┊13┊  padding: 0 !important;\n+┊  ┊14┊` as typeof List;\n+┊  ┊15┊\n+┊  ┊16┊const StyledListItem = styled(ListItem)`\n+┊  ┊17┊  height: 76px;\n+┊  ┊18┊  padding: 0 15px;\n+┊  ┊19┊  display: flex;\n+┊  ┊20┊` as typeof ListItem;\n+┊  ┊21┊\n+┊  ┊22┊const ChatPicture = styled.img`\n+┊  ┊23┊  height: 50px;\n+┊  ┊24┊  width: 50px;\n+┊  ┊25┊  object-fit: cover;\n+┊  ┊26┊  border-radius: 50%;\n+┊  ┊27┊`;\n+┊  ┊28┊\n+┊  ┊29┊const ChatInfo = styled.div`\n+┊  ┊30┊  width: calc(100% - 60px);\n+┊  ┊31┊  height: 46px;\n+┊  ┊32┊  padding: 15px 0;\n+┊  ┊33┊  margin-left: 10px;\n+┊  ┊34┊  border-bottom: 0.5px solid silver;\n+┊  ┊35┊  position: relative;\n+┊  ┊36┊`;\n+┊  ┊37┊\n+┊  ┊38┊const ChatName = styled.div`\n+┊  ┊39┊  margin-top: 5px;\n+┊  ┊40┊`;\n+┊  ┊41┊\n+┊  ┊42┊const MessageContent = styled.div`\n+┊  ┊43┊  color: gray;\n+┊  ┊44┊  font-size: 15px;\n+┊  ┊45┊  margin-top: 5px;\n+┊  ┊46┊  text-overflow: ellipsis;\n+┊  ┊47┊  overflow: hidden;\n+┊  ┊48┊  white-space: nowrap;\n+┊  ┊49┊`;\n+┊  ┊50┊\n+┊  ┊51┊const MessageDate = styled.div`\n+┊  ┊52┊  position: absolute;\n+┊  ┊53┊  color: gray;\n+┊  ┊54┊  top: 20px;\n+┊  ┊55┊  right: 0;\n+┊  ┊56┊  font-size: 13px;\n+┊  ┊57┊`;\n+┊  ┊58┊\n+┊  ┊59┊const ChatsList = () => (\n+┊  ┊60┊  <Container>\n+┊  ┊61┊    <StyledList>\n ┊ 9┊62┊      {chats.map(chat => (\n-┊10┊  ┊        <ListItem key={chat.id} button>\n-┊11┊  ┊          <img src={chat.picture} alt=\"Profile\" />\n-┊12┊  ┊          <div>{chat.name}</div>\n-┊13┊  ┊          {chat.lastMessage && (\n-┊14┊  ┊            <React.Fragment>\n-┊15┊  ┊              <div>{chat.lastMessage.content}</div>\n-┊16┊  ┊              <div>{moment(chat.lastMessage.createdAt).format('HH:mm')}</div>\n-┊17┊  ┊            </React.Fragment>\n-┊18┊  ┊          )}\n-┊19┊  ┊        </ListItem>\n+┊  ┊63┊        <StyledListItem key={chat.id} button>\n+┊  ┊64┊          <ChatPicture src={chat.picture} alt=\"Profile\" />\n+┊  ┊65┊          <ChatInfo>\n+┊  ┊66┊            <ChatName>{chat.name}</ChatName>\n+┊  ┊67┊            {chat.lastMessage && (\n+┊  ┊68┊              <React.Fragment>\n+┊  ┊69┊                <MessageContent>{chat.lastMessage.content}</MessageContent>\n+┊  ┊70┊                <MessageDate>\n+┊  ┊71┊                  {moment(chat.lastMessage.createdAt).format('HH:mm')}\n+┊  ┊72┊                </MessageDate>\n+┊  ┊73┊              </React.Fragment>\n+┊  ┊74┊            )}\n+┊  ┊75┊          </ChatInfo>\n+┊  ┊76┊        </StyledListItem>\n ┊20┊77┊      ))}\n-┊21┊  ┊    </List>\n-┊22┊  ┊  </div>\n+┊  ┊78┊    </StyledList>\n+┊  ┊79┊  </Container>\n ┊23┊80┊);\n ┊24┊81┊\n ┊25┊82┊export default ChatsList;\n```\n\n[}]: #\n\nNotice that we've changed the structure of the HTML of the `ChatsList` component.\nWe've added the ChatInfo to allow better alignment of the elements.\n\nWe're done styling `ChatsListScreen`. We will keep using the same principles to style the rest of the components in our application. The final result should look like so:\n\n![screenshot](https://user-images.githubusercontent.com/7648874/54141766-40baa100-4461-11e9-8dd0-59edcfdb3b84.png)\n\n\nTODO: What do people think about https://www.styled-components.com/docs/tooling#babel-plugin, should we use it here?"
          },
          {
            "manualTitle": "Step 3: Setup a basic Node.JS server with a basic REST endpoint",
            "stepRevision": "07524a22c8bb88a28a530ccd98849248e6b2d79e",
            "manualView": "Currently we have a running app with a single screen which looks stylish and presents some data to the user.\n\nThere is something missing though - The data that we are displaying can't be changed in any way.\n\nbut even if we'll change the data, there is still a more fundamental issue - all of the data lives on the client.\n\nThat means that each client has it's own copy of the data and the data is not shared between them,\nif a client will create a new message, only that client will have the new message and not the client that the message was sent to.\n\nAlso if the client will shut down, all data will be lost.\n\nSo how can we have a place to put data that is being shared between all clients?\n\nWe should find a central machine that all clients will connect to and get the data from.\nIf some client wants to create a new message, it will create it on that central machine so that the next time another clients will ask for the available messages,\nall those messages will be available on the central machine.\n\nThat central machine that stores data is called a database. and the machine that communicates between the database and the client is called a server.\n\nIn this step, we will write a NodeJS server (server that runs using the Javascript language) and will expose a REST endpoint that will serve the data-mock.\nWe will build the REST application using [Express](https://www.npmjs.com/package/express).\nFurther in this tutorial, we will migrate to using a real data-base with real I/O from the user, because at this point, if the server will shut down, all data will be lost.\n\nThe plan is to have a server up and running at `localhost:4000` that will expose a `GET /chats` route.\nUnlike our client application, we're not gonna use any boilerplate and we're gonna set everything up manually.\n\nRight outside the client project, we will create a new directory called `whatsapp-clone-server` in which we will start creating our server:\n\n    $ mkdir whatsapp-clone-server\n    $ cd whatsapp-clone-server\n\nThen we will use `Yarn` to initialize a new project:\n\n    $ yarn init -yp\n\nThere's nothing special about this command, it only creates a basic `package.json` file.\nJust to make sure that things work, we will add an `index.js` file which will print `\"hello world\"` to the console.\n\n[{]: <helper> (diffStep \"1.1\" files=\"index.js\" module=\"server\")\n\n#### [__Server__ Step 1.1: Create start script](https://github.com/Urigo/WhatsApp-Clone-Server/commit/ffe3b90)\n\n##### Added index.js\n```diff\n@@ -0,0 +1 @@\n+┊ ┊1┊console.log('hello world')\n```\n\n[}]: #\n\nAnd we will add a startup script to the `package.json` file called `start`:\n\n    \"start\": \"node index.js\"\n\nNPM-scripts are just a way to defined an alias for commands. Now we only have one simple script,\nbut it can turn out to be something very complex depending on our server, so it can be very useful.\nMore about npm-scripts can be found in the [official NPM docs](https://docs.npmjs.com/misc/scripts).\n\nNow we can run our server by running `$ yarn start` and we should see the message \"hello world\" printed to the console, as expected.\n\nLike in our client's app, we will be using TypeScript.\nIn order to use TypeScript we will install few packages:\n\n    $ yarn add --dev typescript ts-node @types/node\n\n> Note how we used the `--dev` flag. It is a good practice to separate between production dependencies and development dependencies.\nThat way when you deploy your server to the real environment, you won't install the unnecessary development dependencies there.\nMore about the `--dev` option can be read in the [NPM-install docs](https://docs.npmjs.com/cli/install).\n\n- The [`typescript`](https://www.npmjs.com/package/typescript) package is TypeScript's core transpiler.\n- [`ts-node`](https://www.npmjs.com/package/ts-node) is an interpreter that will transpile required `.ts` files into JavaScript at runtime.\n- [`@types/node`](https://www.npmjs.com/package/@types/node) will make the appropriate definitions for a Node.JS environment.\n\n> You can read more about the `@types` monorepo in the [official GitHub repository](https://github.com/DefinitelyTyped/DefinitelyTyped).\n\nWe will rename the `index.js` file to `index.ts`:\n\n    $ mv index.js index.ts\n\nNow we need to compile the `ts` file to turn it into a Javascript file the Node can run.\n\nFor that we will use Typescript and its `tsc` command.\nThe command has many options, but instead of writing them in the command line, we can specify them in a `tsconfig.json` file at the root of the project.\n\nOur server is gonna use the following `tsconfig.json` file, feel free to make the necessary modifications based on your needs:\n\n[{]: <helper> (diffStep \"1.2\" files=\"tsconfig.json\" module=\"server\")\n\n#### [__Server__ Step 1.2: Setup TypeScript](https://github.com/Urigo/WhatsApp-Clone-Server/commit/de10ad8)\n\n##### Added tsconfig.json\n```diff\n@@ -0,0 +1,17 @@\n+┊  ┊ 1┊{\n+┊  ┊ 2┊  \"compilerOptions\": {\n+┊  ┊ 3┊    \"target\": \"es2018\",\n+┊  ┊ 4┊    \"module\": \"commonjs\",\n+┊  ┊ 5┊    \"lib\": [\n+┊  ┊ 6┊      \"es2018\",\n+┊  ┊ 7┊      \"esnext.asynciterable\"\n+┊  ┊ 8┊    ],\n+┊  ┊ 9┊    \"skipLibCheck\": true,\n+┊  ┊10┊    \"strict\": true,\n+┊  ┊11┊    \"strictFunctionTypes\": false,\n+┊  ┊12┊    \"strictPropertyInitialization\": false,\n+┊  ┊13┊    \"esModuleInterop\": true,\n+┊  ┊14┊    \"experimentalDecorators\": true,\n+┊  ┊15┊    \"emitDecoratorMetadata\": true\n+┊  ┊16┊  }\n+┊  ┊17┊}\n```\n\n[}]: #\n\nWe need to tell Typescript which files to compile. Those are in the `include` key.\n\nNow let's run `tsc` and see what happens.\n\nWe've got a new `index.js` file!  Now let's run it by running `node index.js`.\n\nThat's great, but doing this work each time we change a file can be annoying,\nso let's use tools to track when files change and make them run the code automatically after.\n\nAnd we will update the npm-script `start` to use `ts-node`, since we wanna use TypeScript, and not JavaScript directly:\n\n    start: ts-node index.ts\n\nWe can test the startup of our server again by running `$ yarn start` and we should see the message \"hello world\" printed to the console.\n\nThe skeleton of the project is set and we can move on to implementing the REST API.\n\nLike we said at the beginning, we will be using Express to setup the API. Express is a wrapper around the native [Node.JS \"http\"](https://nodejs.org/api/http.html) library which is responsible for handling HTTP requests.\nYes, it can also be used directly, but Express is much more comfortable and has an amazing ecosystem built around it.\nLet's install Express and its TypeScript definitions:\n\n    $ yarn add express\n    $ yarn add --dev @types/express\n\nBefore we implement the `GET /chats` route we will implement a `GET /_ping` route. This route will be used to determine whether the server is up and running or not, and how fast the connection is based on the response time.\nFor every request sent to this route, we should expect a response saying \"pong\".\nSome call it \"heartbeat\", because this route is being tested repeatedly by the hosting machine to check if it's alive, just like a heartbeat in a way.\nThis is how the route should look like:\n\n[{]: <helper> (diffStep \"1.3\" files=\"index.ts\" module=\"server\")\n\n#### [__Server__ Step 1.3: Setup a Express with a basic health check route](https://github.com/Urigo/WhatsApp-Clone-Server/commit/b6cff9c)\n\n##### Changed index.ts\n```diff\n@@ -1 +1,13 @@\n-┊ 1┊  ┊console.log('hello world')\n+┊  ┊ 1┊import express from 'express'\n+┊  ┊ 2┊\n+┊  ┊ 3┊const app = express()\n+┊  ┊ 4┊\n+┊  ┊ 5┊app.get('/_ping', (req, res) => {\n+┊  ┊ 6┊  res.send('pong')\n+┊  ┊ 7┊})\n+┊  ┊ 8┊\n+┊  ┊ 9┊const port = process.env.PORT || 4000\n+┊  ┊10┊\n+┊  ┊11┊app.listen(port, () => {\n+┊  ┊12┊  console.log(`Server is listening on port ${port}`)\n+┊  ┊13┊})\n```\n\n[}]: #\n\nWe can use the\n\n        `$ curl localhost:4000/_ping`\n\ncommand to send a request to the server and we should get a \"pong\", assuming that the server available on that URL.\n\n**Code formatting**\n\nJust like we talked in the first chapter, some developers write code in a different style than others and since we want to make it consistent, we're going to use **Prettier**.\n\n    $ yarn add -D prettier\n\nWe're going to define a npm script called `format`, few styling rules and we're also going to ignore *node_modules*:\n\n[{]: <helper> (diffStep \"1.4\" files=\"package.json, .prettierrc.yml, .prettierignore\" module=\"server\")\n\n#### [__Server__ Step 1.4: Use Prettier](https://github.com/Urigo/WhatsApp-Clone-Server/commit/f183b70)\n\n##### Added .prettierignore\n```diff\n@@ -0,0 +1 @@\n+┊ ┊1┊node_modules🚫↵\n```\n\n##### Added .prettierrc.yml\n```diff\n@@ -0,0 +1,4 @@\n+┊ ┊1┊trailingComma: 'es5'\n+┊ ┊2┊tabWidth: 2\n+┊ ┊3┊singleQuote: true\n+┊ ┊4┊parser: 'typescript'\n```\n\n##### Changed package.json\n```diff\n@@ -7,11 +7,13 @@\n ┊ 7┊ 7┊  },\n ┊ 8┊ 8┊  \"private\": true,\n ┊ 9┊ 9┊  \"scripts\": {\n-┊10┊  ┊    \"start\": \"ts-node index.ts\"\n+┊  ┊10┊    \"start\": \"ts-node index.ts\",\n+┊  ┊11┊    \"format\": \"prettier '**/*.ts' --write\"\n ┊11┊12┊  },\n ┊12┊13┊  \"devDependencies\": {\n ┊13┊14┊    \"@types/express\": \"4.17.0\",\n ┊14┊15┊    \"@types/node\": \"12.0.8\",\n+┊  ┊16┊    \"prettier\": \"1.18.2\",\n ┊15┊17┊    \"ts-node\": \"8.3.0\",\n ┊16┊18┊    \"typescript\": \"3.5.2\"\n ┊17┊19┊  },\n```\n\n[}]: #\n\nNow let's run:\n\n    $ yarn format\n\nPrettier should format your code:\n\n[{]: <helper> (diffStep \"1.4\" files=\"index.ts\" module=\"server\")\n\n#### [__Server__ Step 1.4: Use Prettier](https://github.com/Urigo/WhatsApp-Clone-Server/commit/f183b70)\n\n##### Changed index.ts\n```diff\n@@ -1,13 +1,13 @@\n-┊ 1┊  ┊import express from 'express'\n+┊  ┊ 1┊import express from 'express';\n ┊ 2┊ 2┊\n-┊ 3┊  ┊const app = express()\n+┊  ┊ 3┊const app = express();\n ┊ 4┊ 4┊\n ┊ 5┊ 5┊app.get('/_ping', (req, res) => {\n-┊ 6┊  ┊  res.send('pong')\n-┊ 7┊  ┊})\n+┊  ┊ 6┊  res.send('pong');\n+┊  ┊ 7┊});\n ┊ 8┊ 8┊\n-┊ 9┊  ┊const port = process.env.PORT || 4000\n+┊  ┊ 9┊const port = process.env.PORT || 4000;\n ┊10┊10┊\n ┊11┊11┊app.listen(port, () => {\n-┊12┊  ┊  console.log(`Server is listening on port ${port}`)\n-┊13┊  ┊})\n+┊  ┊12┊  console.log(`Server is listening on port ${port}`);\n+┊  ┊13┊});\n```\n\n[}]: #\n\n> Remember to run `yarn prettier` before you comit your changes!\n\nThe `GET /chats` should be implemented similarly, only the response is different. Instead of returning \"pong\" we will return the data-mock for our chats:\n\n[{]: <helper> (diffStep \"1.5\" files=\"index.ts, db.ts\" module=\"server\")\n\n#### [__Server__ Step 1.5: Create GET /chats route](https://github.com/Urigo/WhatsApp-Clone-Server/commit/d14ae70)\n\n##### Added db.ts\n```diff\n@@ -0,0 +1,51 @@\n+┊  ┊ 1┊export const messages = [\n+┊  ┊ 2┊  {\n+┊  ┊ 3┊    id: '1',\n+┊  ┊ 4┊    content: 'You on your way?',\n+┊  ┊ 5┊    createdAt: new Date(new Date('1-1-2019').getTime() - 60 * 1000 * 1000),\n+┊  ┊ 6┊  },\n+┊  ┊ 7┊  {\n+┊  ┊ 8┊    id: '2',\n+┊  ┊ 9┊    content: \"Hey, it's me\",\n+┊  ┊10┊    createdAt: new Date(new Date('1-1-2019').getTime() - 2 * 60 * 1000 * 1000),\n+┊  ┊11┊  },\n+┊  ┊12┊  {\n+┊  ┊13┊    id: '3',\n+┊  ┊14┊    content: 'I should buy a boat',\n+┊  ┊15┊    createdAt: new Date(new Date('1-1-2019').getTime() - 24 * 60 * 1000 * 1000),\n+┊  ┊16┊  },\n+┊  ┊17┊  {\n+┊  ┊18┊    id: '4',\n+┊  ┊19┊    content: 'This is wicked good ice cream.',\n+┊  ┊20┊    createdAt: new Date(\n+┊  ┊21┊      new Date('1-1-2019').getTime() - 14 * 24 * 60 * 1000 * 1000\n+┊  ┊22┊    ),\n+┊  ┊23┊  },\n+┊  ┊24┊];\n+┊  ┊25┊\n+┊  ┊26┊export const chats = [\n+┊  ┊27┊  {\n+┊  ┊28┊    id: '1',\n+┊  ┊29┊    name: 'Ethan Gonzalez',\n+┊  ┊30┊    picture: 'https://randomuser.me/api/portraits/thumb/men/1.jpg',\n+┊  ┊31┊    lastMessage: '1',\n+┊  ┊32┊  },\n+┊  ┊33┊  {\n+┊  ┊34┊    id: '2',\n+┊  ┊35┊    name: 'Bryan Wallace',\n+┊  ┊36┊    picture: 'https://randomuser.me/api/portraits/thumb/men/2.jpg',\n+┊  ┊37┊    lastMessage: '2',\n+┊  ┊38┊  },\n+┊  ┊39┊  {\n+┊  ┊40┊    id: '3',\n+┊  ┊41┊    name: 'Avery Stewart',\n+┊  ┊42┊    picture: 'https://randomuser.me/api/portraits/thumb/women/1.jpg',\n+┊  ┊43┊    lastMessage: '3',\n+┊  ┊44┊  },\n+┊  ┊45┊  {\n+┊  ┊46┊    id: '4',\n+┊  ┊47┊    name: 'Katie Peterson',\n+┊  ┊48┊    picture: 'https://randomuser.me/api/portraits/thumb/women/2.jpg',\n+┊  ┊49┊    lastMessage: '4',\n+┊  ┊50┊  },\n+┊  ┊51┊];\n```\n\n##### Changed index.ts\n```diff\n@@ -1,4 +1,5 @@\n ┊1┊1┊import express from 'express';\n+┊ ┊2┊import { chats } from './db';\n ┊2┊3┊\n ┊3┊4┊const app = express();\n ┊4┊5┊\n```\n```diff\n@@ -6,6 +7,10 @@\n ┊ 6┊ 7┊  res.send('pong');\n ┊ 7┊ 8┊});\n ┊ 8┊ 9┊\n+┊  ┊10┊app.get('/chats', (req, res) => {\n+┊  ┊11┊  res.json(chats);\n+┊  ┊12┊});\n+┊  ┊13┊\n ┊ 9┊14┊const port = process.env.PORT || 4000;\n ┊10┊15┊\n ┊11┊16┊app.listen(port, () => {\n```\n\n[}]: #\n\nTODO: Mention `_req`\n\nCheck we can get the chats by running:\n\n        `$ curl localhost:4000/chats`\n\nUnlike the previous route, we used the `.json()` method this time around to send a response. This will simply stringify the given JSON and set the right headers.\nSimilarly to the client, we've defined the db mock in a dedicated file, as this is easier to maintain and look at.\n\nIt's also recommended to connect a middleware called [`cors`](https://www.npmjs.com/package/cors) which will enable cross-origin requests.\nWithout it we will only be able to make requests in localhost, something which is likely to limit us in the future because we would probably host our server somewhere separate than the client application.\nWithout it it will also be impossible to call the server from our client app.\nLet's install the `cors` library and load it with the Express `middleware()` function:\n\n    $ yarn add cors\n\nand its Typescript types:\n\n\n    $ yarn add --dev @types/cors\n\n[{]: <helper> (diffStep \"1.6\" files=\"index.ts\" module=\"server\")\n\n#### [__Server__ Step 1.6: Use CORS](https://github.com/Urigo/WhatsApp-Clone-Server/commit/28c3030)\n\n##### Changed index.ts\n```diff\n@@ -1,8 +1,11 @@\n+┊  ┊ 1┊import cors from 'cors';\n ┊ 1┊ 2┊import express from 'express';\n ┊ 2┊ 3┊import { chats } from './db';\n ┊ 3┊ 4┊\n ┊ 4┊ 5┊const app = express();\n ┊ 5┊ 6┊\n+┊  ┊ 7┊app.use(cors());\n+┊  ┊ 8┊\n ┊ 6┊ 9┊app.get('/_ping', (req, res) => {\n ┊ 7┊10┊  res.send('pong');\n ┊ 8┊11┊});\n```\n\n[}]: #\n\nThe server is now ready to use!\n\nSo getting back to the client, first we will define our server's URL under the `.env` file:\n\n[{]: <helper> (diffStep \"3.1\" module=\"client\")\n\n#### [__Client__ Step 3.1: Define server URL](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/4e98281)\n\n##### Added .env\n```diff\n@@ -0,0 +1 @@\n+┊ ┊1┊REACT_APP_SERVER_URL=http://localhost:4000🚫↵\n```\n\n[}]: #\n\nThis will make our server's URL available under the `process.env.REACT_APP_SERVER_URL` member expression and it will be replaced with a fixed value at build time, just like macros.\nThe `.env` file is a file which will automatically be loaded to `process.env` by the [`dotenv`](https://www.npmjs.com/package/dotenv) NPM package.\n`react-scripts` then filters environment variables which have a `REACT_APP_` prefix and provides the created JSON to a Webpack plugin called [DefinePlugin](https://webpack.js.org/plugins/define-plugin/), which will result in the macro effect.\n\nNow let's move back into our React app folder.\nWe will now replace the local data-mock usage with a fetch from the server.\nFor that we can use the native [fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API),\nhowever, it needs to be used in the right life-cycle hook of the React.Component.\n\nThere are 2 naive approaches for that:\n\n- Calling `fetch()` outside the component, but this way that chats will be fetched even if we're not even intending to create an instance of the component.\n\n```js\nfetch().then(() => /* ... */)\nconst MyComponent = () => {}\n```\n\n- Calling `fetch()` inside the component, but then it will be invoked whenever the component is re-rendered.\n\n```js\nconst MyComponent = () => {\n  fetch().then(() => /* ... */)\n}\n```\n\nThese 2 approaches indeed work, but they both fail to deliver what's necessary on the right time.\nIn addition, there's no way to properly coordinate async function calls with the render method of the component.\n\n**Introducing: React hooks**\n\nWith React hooks we can invoke the desired logic in the right life-cycle stage of the target component.\nThis way we can avoid potential memory leaks or extra calculations.\nTo implement a proper `fetch()`, we will be using 2 React hooks:\n\n- [`React.useState()`](https://reactjs.org/docs/hooks-reference.html#usestate) - which is used to get and set a state of the component - will be used to store the chats fetched from the server.\n\n```js\nconst [value, setValue] = useState(initialValue);\n```\n\n- [`React.useMemo()`](https://reactjs.org/docs/hooks-reference.html#usememo) - which is used to run a computation only once certain conditions were met - will be used to run the `fetch()` function only once the component has mounted.\n\n```js\nconst memoizedValue = useMemo(calcFn, [cond1, cond2, ...conds]);\n```\n\nThe result of that approach will look like this, in the context of our ChatsList component:\n\n[{]: <helper> (diffStep \"3.2\" module=\"client\")\n\n#### [__Client__ Step 3.2: Fetch chats using native fetch API instead of mock DB](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/6e4407a)\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;ChatsList.tsx\n```diff\n@@ -1,8 +1,8 @@\n ┊1┊1┊import React from 'react';\n-┊2┊ ┊import { chats } from '../../db';\n ┊3┊2┊import moment from 'moment';\n ┊4┊3┊import { List, ListItem } from '@material-ui/core';\n ┊5┊4┊import styled from 'styled-components';\n+┊ ┊5┊import { useState, useMemo } from 'react';\n ┊6┊6┊\n ┊7┊7┊const Container = styled.div`\n ┊8┊8┊  height: calc(100% - 56px);\n```\n```diff\n@@ -56,27 +56,37 @@\n ┊56┊56┊  font-size: 13px;\n ┊57┊57┊`;\n ┊58┊58┊\n-┊59┊  ┊const ChatsList = () => (\n-┊60┊  ┊  <Container>\n-┊61┊  ┊    <StyledList>\n-┊62┊  ┊      {chats.map(chat => (\n-┊63┊  ┊        <StyledListItem key={chat.id} button>\n-┊64┊  ┊          <ChatPicture src={chat.picture} alt=\"Profile\" />\n-┊65┊  ┊          <ChatInfo>\n-┊66┊  ┊            <ChatName>{chat.name}</ChatName>\n-┊67┊  ┊            {chat.lastMessage && (\n-┊68┊  ┊              <React.Fragment>\n-┊69┊  ┊                <MessageContent>{chat.lastMessage.content}</MessageContent>\n-┊70┊  ┊                <MessageDate>\n-┊71┊  ┊                  {moment(chat.lastMessage.createdAt).format('HH:mm')}\n-┊72┊  ┊                </MessageDate>\n-┊73┊  ┊              </React.Fragment>\n-┊74┊  ┊            )}\n-┊75┊  ┊          </ChatInfo>\n-┊76┊  ┊        </StyledListItem>\n-┊77┊  ┊      ))}\n-┊78┊  ┊    </StyledList>\n-┊79┊  ┊  </Container>\n-┊80┊  ┊);\n+┊  ┊59┊const ChatsList = () => {\n+┊  ┊60┊  const [chats, setChats] = useState<any[]>([]);\n+┊  ┊61┊\n+┊  ┊62┊  useMemo(async () => {\n+┊  ┊63┊    const body = await fetch(`${process.env.REACT_APP_SERVER_URL}/chats`);\n+┊  ┊64┊    const chats = await body.json();\n+┊  ┊65┊    setChats(chats);\n+┊  ┊66┊  }, []);\n+┊  ┊67┊\n+┊  ┊68┊  return (\n+┊  ┊69┊    <Container>\n+┊  ┊70┊      <StyledList>\n+┊  ┊71┊        {chats.map(chat => (\n+┊  ┊72┊          <StyledListItem key={chat!.id} button>\n+┊  ┊73┊            <ChatPicture src={chat.picture} alt=\"Profile\" />\n+┊  ┊74┊            <ChatInfo>\n+┊  ┊75┊              <ChatName>{chat.name}</ChatName>\n+┊  ┊76┊              {chat.lastMessage && (\n+┊  ┊77┊                <React.Fragment>\n+┊  ┊78┊                  <MessageContent>{chat.lastMessage.content}</MessageContent>\n+┊  ┊79┊                  <MessageDate>\n+┊  ┊80┊                    {moment(chat.lastMessage.createdAt).format('HH:mm')}\n+┊  ┊81┊                  </MessageDate>\n+┊  ┊82┊                </React.Fragment>\n+┊  ┊83┊              )}\n+┊  ┊84┊            </ChatInfo>\n+┊  ┊85┊          </StyledListItem>\n+┊  ┊86┊        ))}\n+┊  ┊87┊      </StyledList>\n+┊  ┊88┊    </Container>\n+┊  ┊89┊  );\n+┊  ┊90┊};\n ┊81┊91┊\n ┊82┊92┊export default ChatsList;\n```\n\n##### Deleted src&#x2F;db.ts\n```diff\n@@ -1,49 +0,0 @@\n-┊ 1┊  ┊export const messages = [\n-┊ 2┊  ┊  {\n-┊ 3┊  ┊    id: 1,\n-┊ 4┊  ┊    content: 'You on your way?',\n-┊ 5┊  ┊    createdAt: new Date(Date.now() - 60 * 1000 * 1000),\n-┊ 6┊  ┊  },\n-┊ 7┊  ┊  {\n-┊ 8┊  ┊    id: 2,\n-┊ 9┊  ┊    content: \"Hey, it's me\",\n-┊10┊  ┊    createdAt: new Date(Date.now() - 2 * 60 * 1000 * 1000),\n-┊11┊  ┊  },\n-┊12┊  ┊  {\n-┊13┊  ┊    id: 3,\n-┊14┊  ┊    content: 'I should buy a boat',\n-┊15┊  ┊    createdAt: new Date(Date.now() - 24 * 60 * 1000 * 1000),\n-┊16┊  ┊  },\n-┊17┊  ┊  {\n-┊18┊  ┊    id: 4,\n-┊19┊  ┊    content: 'This is wicked good ice cream.',\n-┊20┊  ┊    createdAt: new Date(Date.now() - 14 * 24 * 60 * 1000 * 1000),\n-┊21┊  ┊  },\n-┊22┊  ┊];\n-┊23┊  ┊\n-┊24┊  ┊export const chats = [\n-┊25┊  ┊  {\n-┊26┊  ┊    id: 1,\n-┊27┊  ┊    name: 'Ethan Gonzalez',\n-┊28┊  ┊    picture: 'https://randomuser.me/api/portraits/thumb/men/1.jpg',\n-┊29┊  ┊    lastMessage: messages.find(m => m.id === 1),\n-┊30┊  ┊  },\n-┊31┊  ┊  {\n-┊32┊  ┊    id: 2,\n-┊33┊  ┊    name: 'Bryan Wallace',\n-┊34┊  ┊    picture: 'https://randomuser.me/api/portraits/thumb/men/2.jpg',\n-┊35┊  ┊    lastMessage: messages.find(m => m.id === 2),\n-┊36┊  ┊  },\n-┊37┊  ┊  {\n-┊38┊  ┊    id: 3,\n-┊39┊  ┊    name: 'Avery Stewart',\n-┊40┊  ┊    picture: 'https://randomuser.me/api/portraits/thumb/women/1.jpg',\n-┊41┊  ┊    lastMessage: messages.find(m => m.id === 3),\n-┊42┊  ┊  },\n-┊43┊  ┊  {\n-┊44┊  ┊    id: 4,\n-┊45┊  ┊    name: 'Katie Peterson',\n-┊46┊  ┊    picture: 'https://randomuser.me/api/portraits/thumb/women/2.jpg',\n-┊47┊  ┊    lastMessage: messages.find(m => m.id === 4),\n-┊48┊  ┊  },\n-┊49┊  ┊];\n```\n\n[}]: #\n\n> It's recommended to read about React hooks and their basic concept at the [official React docs page](https://reactjs.org/docs/hooks-overview.html).\n\nAt this point we can get rid of `db.ts` file in the client, since we don't use it anymore:\n\n    $ rm src/db.ts\n\nThat's it. Our ChatsListScreen is now connected to a working back-end.\nIn the next step we will upgrade our REST API into a GraphQL API and we will create a basis for a more robust back-end.\n\n-------------\nTODO:\n\nFirst, `tsc` has a `--watch` option so that if the Typescript files changed it will compile them again and spit new Javascript files.\n\nThen we need to rerun the Node server everytime the output Javascript files has changed.\n[nodemon](https://github.com/remy/nodemon) is a tool that tracks file and if the files changed it will re-run our node server.\n\nLet's create a new npm script called \"watch\" and make it run both tools:\n\nTODO: New diff\n\nTODO: https://stackoverflow.com/a/39172660/1426570\n\nTODO: Better watch, also watch and copy schema files (maybe in a later chapter)?\n\nTODO: concurrently - because it works on all environments\n\nTODO: Explain what -r register command does in Node and in Jest\n\nTODO: Talk about the difference between graphql-import and graphql-import-node\n\nTODO: Show debugging\n\n\nIt's a bit annoying that we get the compiled file right next to our Typescript file, so let's move it into a separate folder:\n\nTODO: New diff for the `lib` folder update\n\nTODO: why `useMemo(fn, [true])` instead of `useEffect(fn, [])` ?\n\nTODO: Move to hooks in a separate commit and later change to call the server"
          },
          {
            "manualTitle": "Step 4: Transition to GraphQL",
            "stepRevision": "bf6407fde3b937e1f2da4820cbc8652793aa483c",
            "manualView": "**What is GraphQL?**\n\n[GraphQL](https://graphql.org/) is a query language invented by Facebook, and it's used to query data within from a schema.\nIn our case, we will create a schema for the data that our server exposes through its API.\nIt allows clients to define the structure of the data required, and the exact same structure of data will be returned from the server,\ntherefore preventing excessively large amounts of data from being returned.\nUnlike REST, GraphQL APIs are organized in terms of types and fields, not endpoints.\n\nEven if we use GraphQL without a server, it can save us a lot of code and work becuase it can transform data in a very easy way from a schema to a query.\n\nCurrently in our app, if we'd like to get its chats we would send a GET request to `/chats`.\nWith GraphQL it would be done differently with a string that describes the data that we would like to get:\n\n```graphql\nchats {\n  id\n  name\n  picture\n  lastMessage {\n    id\n    content\n    createdAt\n  }\n}\n```\n\n> Above: An illustration of a potential GraphQL query sent to our Whatsapp API\n\n**Why GraphQL and not REST?**\n\nREST has been used for many more years and has proven itself to work well, and it's completely agnostic to the implementation of the back-end.\nHowever, when it comes to data projection and aggregation, it fails to deliver.\n\nWhen using REST, often times you'll find yourself performing multiple requests to execute a single query of data.\nNot only that, you might even end up with additional data that is not necessary.\nEither way, the process would result in slower and heavier response.\n\nWith GraphQL we don’t have that kind of problem. The API is based on a schema built from many entities that we call object types.\nThink of GraphQL as something similar to TypeScript but for API.\nObject types are like interfaces, they describe the shape of an entity.\n\nIn TypeScript you would describe a Chat as:\n\n```\ninterface Chat {\n  id: string;\n  name: string;\n  picture: string;\n  lastMessage: Message;\n}\n\ninterface Message {\n  id: string;\n  content: string;\n  createdAt: number;\n}\n```\n\nGraphQL:\n\n```\ntype Chat {\n  id: String\n  name: String\n  picture: String\n  lastMessage: Message\n}\n\ntype Message {\n  id: String\n  content: String\n  createdAt: Float\n}\n```\n\nLooks pretty similar?\n\nSo this is the definition of the available data, now let's see how we can pick and structure data from it using a query:\n\n```graphql\n# request\nchats {\n  id\n  name\n  picture\n  lastMessage {\n    id\n    content\n    createdAt\n  }\n}\n```\n\nWe think it’s pretty straightforward to understand what do you fetch by just looking at the query above.\n\n![graphql-request](https://user-images.githubusercontent.com/7648874/54133620-5aec8300-4451-11e9-9bda-a459dc48f57c.png)\n\nIf you would execute that query the result might look like this:\n\n```js\n// response\n{\n  chats: [{\n    id: “1”,\n    name: “Ethan Gonzalez”,\n    picture: “https://randomuser.me/api/portraits/thumb/men/1.jpg”,\n    lastMessage: {\n      id: “1”,\n      content: \"You on your way?\",\n      createdAt: 1234567890\n  }]\n}\n```\n\nYou'll get exactly what you asked for with a single request. GraphQL provides a dynamic API while REST doesn't.\n\n**GraphQL schema, in a nutshell**\n\nLike said earlier,  GraphQL APIs are organized in terms of types and fields.\nThat means that our app data should be described with a schema, where each field's gonna have a resolver - the handler that will return the corresponding data.\nThings will be much clearer as we move further.\n\nLet's try to describe our app's data with a GraphQL schema and then dive into it:\n\n```graphql\nscalar Date\n\ntype Message {\n  id: ID!\n  content: String!\n  createdAt: Date!\n}\n\ntype Chat {\n  id: ID!\n  name: String!\n  picture: String\n  lastMessage: Message\n}\n\ntype Query {\n  chats: [Chat!]!\n}\n```\n\nThe schema is self explanatory in terms of what data it's compatible with. Supported built-in scalar types in GraphQL are:\n\n- Int: Signed 32‐bit integer\n- Float: Signed double-precision floating-point value\n- String: UTF‐8 character sequence\n- Boolean: true or false\n- ID (serialized as String): A unique identifier, often used to refetch an object or as the key for a cache.\nWhile serialized as a String, ID signifies that it is not intended to be human‐readable\n\nAny custom scalar can be declared with the `scalar` keyword, and custom types can be declared with the `type` keyword.\nHowever, you should know that some types are reserved by GraphQL itself; `Query` is one of them.\nThe `Query` type will be used as the root for received queries by the clients, which means that we can send queries which start with the `chats` field.\nOther reserved types are:\n\n- `type Query` - reserved for [GraphQL queries](https://graphql.org/learn/queries/#mutations).\n- `type Mutation` - reserved for [GraphQL mutations.](https://graphql.github.io/learn/queries/)\n- `type Subscription` - reserved for [GraphQL subscriptions.](https://www.apollographql.com/docs/react/advanced/subscriptions.html)\n\n> As we're not gonna go through the entire GraphQL API, it's recommended to go through the [official learn section of the GraphQL website](https://graphql.org/learn/), but the information so far will definitely help you kick-start, plus the upcoming implementation.\n\n**Getting started**\n\nWe will be implementing a GraphQL mechanism for the client and for the server.\nWe will start with the server as things will make more sense, and we will be able to test it before we proceed into the client.\nEssentially GraphQL is connected into a HTTP endpoint, usually under `POST /graphql`, and so this is exactly what we're gonna do, connect the endpoint handler.\nLuckily, we don't have to implement that. A team called [Apollo](https://www.apollographql.com/) already did it for us, so we can use their implementation.\nWe will install the required packages:\n\n    $ yarn add apollo-server-express body-parser graphql\n    $ yarn add --dev @types/body-parser @types/graphql\n\n- [`graphql`](https://www.npmjs.com/package/graphql) - The core package of GraphQL that includes the resolvers for basic data-types.\n- [`apollo-server-express`](https://www.npmjs.com/package/apollo-server-express) - Apollo's implementation for the GraphQL Express REST endpoint.\n- [`body-parser`](https://www.npmjs.com/package/body-parser) - Parse incoming request bodies in a middleware before your handlers, available under the req.body property.\n- `@types/…` - TypeScript definitions. Notice that we didn't need to install Apollo's types library. That is because Apollo themselves writes their source code in Typescript so\nwe get a ready Typescript code directly from their library.\n\nWe can now connect Apollo's middleware under the `/graphql` route:\n\n[{]: <helper> (diffStep \"2.1\" files=\"index.ts\" module=\"server\")\n\n#### [__Server__ Step 2.1: Setup Apollo GraphQL](https://github.com/Urigo/WhatsApp-Clone-Server/commit/5839b3f)\n\n##### Changed index.ts\n```diff\n@@ -1,10 +1,14 @@\n+┊  ┊ 1┊import { ApolloServer, gql } from 'apollo-server-express';\n+┊  ┊ 2┊import bodyParser from 'body-parser';\n ┊ 1┊ 3┊import cors from 'cors';\n ┊ 2┊ 4┊import express from 'express';\n ┊ 3┊ 5┊import { chats } from './db';\n+┊  ┊ 6┊import schema from './schema';\n ┊ 4┊ 7┊\n ┊ 5┊ 8┊const app = express();\n ┊ 6┊ 9┊\n ┊ 7┊10┊app.use(cors());\n+┊  ┊11┊app.use(bodyParser.json());\n ┊ 8┊12┊\n ┊ 9┊13┊app.get('/_ping', (req, res) => {\n ┊10┊14┊  res.send('pong');\n```\n```diff\n@@ -14,6 +18,13 @@\n ┊14┊18┊  res.json(chats);\n ┊15┊19┊});\n ┊16┊20┊\n+┊  ┊21┊const server = new ApolloServer({ schema });\n+┊  ┊22┊\n+┊  ┊23┊server.applyMiddleware({\n+┊  ┊24┊  app,\n+┊  ┊25┊  path: '/graphql',\n+┊  ┊26┊});\n+┊  ┊27┊\n ┊17┊28┊const port = process.env.PORT || 4000;\n ┊18┊29┊\n ┊19┊30┊app.listen(port, () => {\n```\n\n[}]: #\n\nAs you can see, the middleware requires a schema. A schema is composed mainly out of 2 fields:\n\n- `typeDefs` (type definitions) - the schema types we wrote earlier this chapter for chats.\n- `resolvers` - The handlers that will provide the data for each field in `typeDefs`.\n\nWe will start first by defining the types.\nAll we have to do is to copy-paste the contents of the schema that was shown earlier into a new file called `typeDefs.graphql`:\n\n[{]: <helper> (diffStep \"2.2\" files=\"schema/typeDefs.graphql\" module=\"server\")\n\n#### [__Server__ Step 2.2: Create a basic GraphQL schema](https://github.com/Urigo/WhatsApp-Clone-Server/commit/931ea01)\n\n##### Added schema&#x2F;typeDefs.graphql\n```diff\n@@ -0,0 +1,18 @@\n+┊  ┊ 1┊scalar Date\n+┊  ┊ 2┊\n+┊  ┊ 3┊type Message {\n+┊  ┊ 4┊  id: ID!\n+┊  ┊ 5┊  content: String!\n+┊  ┊ 6┊  createdAt: Date!\n+┊  ┊ 7┊}\n+┊  ┊ 8┊\n+┊  ┊ 9┊type Chat {\n+┊  ┊10┊  id: ID!\n+┊  ┊11┊  name: String!\n+┊  ┊12┊  picture: String\n+┊  ┊13┊  lastMessage: Message\n+┊  ┊14┊}\n+┊  ┊15┊\n+┊  ┊16┊type Query {\n+┊  ┊17┊  chats: [Chat!]!\n+┊  ┊18┊}\n```\n\n[}]: #\n\nThe `.graphql` file extension is just a more convenient way to work with a GraphQL schema. The exported result should be a simple string that we can use to compose our GraphQL schema. The clear advantage of working with a dedicated file is that we get to have syntax highlight.\n\nNow we will implement the resolvers. Resolvers are presented in a JSON object where each resolver name should match the field name it represents. You can read more about resolvers in [Apollo's official docs for resolvers](https://www.apollographql.com/docs/tutorial/resolvers.html). This is how our resolvers should look like:\n\n[{]: <helper> (diffStep \"2.2\" files=\"schema/resolvers.ts\" module=\"server\")\n\n#### [__Server__ Step 2.2: Create a basic GraphQL schema](https://github.com/Urigo/WhatsApp-Clone-Server/commit/931ea01)\n\n##### Added schema&#x2F;resolvers.ts\n```diff\n@@ -0,0 +1,14 @@\n+┊  ┊ 1┊import { GraphQLDateTime } from 'graphql-iso-date';\n+┊  ┊ 2┊import { chats } from '../db';\n+┊  ┊ 3┊\n+┊  ┊ 4┊const resolvers = {\n+┊  ┊ 5┊  Date: GraphQLDateTime,\n+┊  ┊ 6┊\n+┊  ┊ 7┊  Query: {\n+┊  ┊ 8┊    chats() {\n+┊  ┊ 9┊      return chats;\n+┊  ┊10┊    },\n+┊  ┊11┊  },\n+┊  ┊12┊};\n+┊  ┊13┊\n+┊  ┊14┊export default resolvers;\n```\n\n[}]: #\n\nFor now it's extremely simple, we map the chats query directly into the database collection. Each field in the resolvers object should match the GraphQL type it represents in the schema. Since we don't have any logic now, we should not implement any resolvers for the rest of the types, the data will simply be forwarded as is.\n\nNote that we've implemented a custom scalar named `Date` and we resolved it with an NPM package. Let's install it:\n\n    $ yarn add graphql-iso-date\n    $ yarn add --dev @types/graphql-iso-date\n\nFinal thing that we have to do would be combining the resolvers and the type-defs under a single GraphQL schema.\n\n[{]: <helper> (diffStep \"2.2\" files=\"index.ts\" module=\"server\")\n\n#### [__Server__ Step 2.2: Create a basic GraphQL schema](https://github.com/Urigo/WhatsApp-Clone-Server/commit/931ea01)\n\n##### Added schema&#x2F;index.ts\n```diff\n@@ -0,0 +1,7 @@\n+┊ ┊1┊import { importSchema } from 'graphql-import';\n+┊ ┊2┊import { makeExecutableSchema } from 'graphql-tools';\n+┊ ┊3┊import resolvers from './resolvers';\n+┊ ┊4┊\n+┊ ┊5┊const typeDefs = importSchema('schema/typeDefs.graphql');\n+┊ ┊6┊\n+┊ ┊7┊export default makeExecutableSchema({ resolvers, typeDefs });\n```\n\n[}]: #\n\n[`graphql-tools`](https://www.npmjs.com/package/graphql-tools) is a library with a set of utilities that will help us create a schema that will be compatible with Apollo's API:\n\n    $ yarn add graphql-tools graphql-import\n\nThere's one optimization however that we should make in the our DB. Right now, the each chat document has a direct reference to a message via the `lastMessage` field. Practically speaking, this is NOT how the data sits in the DB. The `lastMessage` should only hold the ID for the correlated message, and then in the Node.JS app we should **resolve** it according to our needs. Let's make the appropriate changes in the DB then:\n\n[{]: <helper> (diffStep \"2.3\" files=\"db.ts\" module=\"server\")\n\n#### [__Server__ Step 2.3: Resolve Chat.lastMessage](https://github.com/Urigo/WhatsApp-Clone-Server/commit/c1a8e07)\n\n\n\n[}]: #\n\nAnd a resolver to the `lastMessage` field:\n\n[{]: <helper> (diffStep \"2.3\" files=\"schema/resolvers.ts\" module=\"server\")\n\n#### [__Server__ Step 2.3: Resolve Chat.lastMessage](https://github.com/Urigo/WhatsApp-Clone-Server/commit/c1a8e07)\n\n##### Changed schema&#x2F;resolvers.ts\n```diff\n@@ -1,9 +1,15 @@\n ┊ 1┊ 1┊import { GraphQLDateTime } from 'graphql-iso-date';\n-┊ 2┊  ┊import { chats } from '../db';\n+┊  ┊ 2┊import { chats, messages } from '../db';\n ┊ 3┊ 3┊\n ┊ 4┊ 4┊const resolvers = {\n ┊ 5┊ 5┊  Date: GraphQLDateTime,\n ┊ 6┊ 6┊\n+┊  ┊ 7┊  Chat: {\n+┊  ┊ 8┊    lastMessage(chat: any) {\n+┊  ┊ 9┊      return messages.find(m => m.id === chat.lastMessage);\n+┊  ┊10┊    },\n+┊  ┊11┊  },\n+┊  ┊12┊\n ┊ 7┊13┊  Query: {\n ┊ 8┊14┊    chats() {\n ┊ 9┊15┊      return chats;\n```\n\n[}]: #\n\nThe first argument of the resolver is the raw chat data received by the DB, and the returned result should be the mapped value which we would like to return to the client.\n\nAs we get further in this tutorial we should get a better grasp regards resolvers and their API, since we will have to deal with more logic and complexity within our Node.JS app.\n\nAssuming that the server is running, we can already test our GraphQL endpoint. Because it's exposed to us via a REST endpoint, we can use a `$ curl` command to send a request to `GET localhost:4000/graphql` and get a response with all the data. Again, the query that we're gonna use to fetch the chats is:\n\n```graphql\nchats {\n  id\n  name\n  picture\n  lastMessage {\n    id\n    content\n    createdAt\n  }\n}\n```\n\nThe one-liner version of it with a `$ curl` command looks like so:\n\n    curl \\\n      -X POST \\\n      -H \"Content-Type: application/json\" \\\n      --data '{ \"query\": \"{ chats { id name picture lastMessage { id content createdAt } } }\" }' \\\n      localhost:4000/graphql\n\nAs a response we should get the data-mock for our chats stored in the server. Since we have that in place, we can go ahead and delete our implementation for the `GET /chats` route.\n\nAnother way to test and inspect our GraphQL schema would be by using an IDE for the browser called [GraphQL Playground](https://github.com/prisma/graphql-playground).\nApollo-Server ships with it right out of the box and can be used right away by navigating to the `http://localhost:4000/graphql` URL from the browser.\n\n[![](https://i.imgur.com/AE5W6OW.png)](https://graphqlbin.com/v2/6RQ6TM)\n\nSo getting back to the client, all we have to do is to change the fetching URL in the ChatsList component to use our newly implemented GraphQL REST endpoint:\n\n[{]: <helper> (diffStep \"4.1\" module=\"client\")\n\n#### [__Client__ Step 4.1: Replace REST call with GraphQL call](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/70dc7ff)\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;ChatsList.tsx\n```diff\n@@ -56,12 +56,35 @@\n ┊56┊56┊  font-size: 13px;\n ┊57┊57┊`;\n ┊58┊58┊\n+┊  ┊59┊const getChatsQuery = `\n+┊  ┊60┊  query GetChats {\n+┊  ┊61┊    chats {\n+┊  ┊62┊      id\n+┊  ┊63┊      name\n+┊  ┊64┊      picture\n+┊  ┊65┊      lastMessage {\n+┊  ┊66┊        id\n+┊  ┊67┊        content\n+┊  ┊68┊        createdAt\n+┊  ┊69┊      }\n+┊  ┊70┊    }\n+┊  ┊71┊  }\n+┊  ┊72┊`;\n+┊  ┊73┊\n ┊59┊74┊const ChatsList = () => {\n ┊60┊75┊  const [chats, setChats] = useState<any[]>([]);\n ┊61┊76┊\n ┊62┊77┊  useMemo(async () => {\n-┊63┊  ┊    const body = await fetch(`${process.env.REACT_APP_SERVER_URL}/chats`);\n-┊64┊  ┊    const chats = await body.json();\n+┊  ┊78┊    const body = await fetch(`${process.env.REACT_APP_SERVER_URL}/graphql`, {\n+┊  ┊79┊      method: 'POST',\n+┊  ┊80┊      headers: {\n+┊  ┊81┊        'Content-Type': 'application/json',\n+┊  ┊82┊      },\n+┊  ┊83┊      body: JSON.stringify({ query: getChatsQuery }),\n+┊  ┊84┊    });\n+┊  ┊85┊    const {\n+┊  ┊86┊      data: { chats },\n+┊  ┊87┊    } = await body.json();\n ┊65┊88┊    setChats(chats);\n ┊66┊89┊  }, []);\n```\n\n[}]: #\n\nThe received data should be similar to the previous one.\nNo further changes are required.\n\nIn the next chapter, we will continue working on the UI of our front-end application and we will add a new screen to the flow - the `ChatRoomScreen`.\n\n-------\nTODO: Start with calling the  `graphql` function just on the server to show how it works.\nTODO: Separate step for body parser.\nTODO: Example middlewares in Node\nTODO: Mention the vs code extension\n\nTODO: Introduce the scalar type later on\n\nTODO: Start without Apollo and add it later, in the same file.\nTODO: remove `gql` import becuase it's unused\nTODO: Add visualizations of how GraphQL works\nTODO: import { loadSchema } from 'graphql-toolkit'; and install it\n\nTODO: What DB change is that?\nTODO: Type `lastMessage(chat: any) {`\nTOOD: Change `m` to `currentIteratedMessage`\n\nTODO: Why adding headers? and go through the code\n\nTODO: Talk about working with document node and not with makeExacutableSchema\n```\nזה לא משנה בתכלס, כי ApolloServer בכל מקרה יעשה לזה קימפול\nהנקודה היא שלא צריך לקמפל פעמיים לGraphQLSchema\nפשוט עדיף שאת הקימפול יעשה הרכיב האחרון שהולך להשתמש בtypeDefs\n\nDocumentNode => DocumentNode (cheap, easy, no checks)\nDocumentNode => GraphQLSchema (compile AST, does all checking, might throw exceptions, expensive)\nGraphQLSchema => DocumentNode (printed version, might lost AST features such as directives)\n```"
          },
          {
            "manualTitle": "Step 5: Testing",
            "stepRevision": "e084b2cbf8acdb9d3c2006e6dfccee62652c42ea",
            "manualView": "Testing is a crucial part when writing an application, especially if we're planning to publish it or make it a commercial thing. Before we hand someone a product, of any kind, we wanna make sure that it passes certain quality checks. We're signed on that product and so it's very important to ensure that it functions properly according our expectations, otherwise wouldn't wanna use it and will look for alternatives.\n\nIn the context of software, we constantly make changes. It's also inevitable to make all features completely independent from one another, so something in the app is likely to break as we upgrade it or maintain it. That's why we need to write a set of tests that can be run on demand, so when we implement a new feature we can simply run the tests and see what feature broke due to most recent changes.\n\nThere are currently 3 main testing frameworks in the NPM ecosystem: [Jasmine](https://jasmine.github.io/), [Mocha](https://mochajs.org/), and [Jest](https://jestjs.io/). Each testing framework has its pros, and cons, and at the end of the day it's a matter of preference. In our application we're gonna use [Jest](https://jestjs.io/) - a testing framework which was developed by Facebook. What's good about Jest is that it can be used to test both client and server logic, because it runs as a Node.JS application, but it also emulates the browser environment whenever we run it, thanks to [JSDOM](https://github.com/jsdom/jsdom).\n\n![jest](https://user-images.githubusercontent.com/7648874/54493900-e2ce0380-490f-11e9-8075-be4a236c7c38.png)\n\nIn this chapter we will learn how to test the React.Components in the client, and Apollo-GraphQL resolvers in the server. There are 3 kinds of tests:\n\n- Unit tests - which are used to test a single component, independently from other components in our system.\n- Integration tests - which are used to test a component in relation to other components in our systems (how well do they co-work with each other).\n- e2e tests (end to end) - which are used to test a complete, from the moment I clicked on a button in the user interface until the data gets back from the server and shown on the screen.\n\nThe efficiency of the tests go from bottom to top (unit -> e2e), but the maintenance and complexity go from bottom to top (e2e -> unit). Accordingly we will need to find a good balance where we don’t spend too much time on writing tests yet have a good indicator for how well our system functions. So we should write a lot of unit tests, a good amount of integration tests and a handful of e2e tests.\n\n![tests-types-table](https://user-images.githubusercontent.com/7648874/54494121-fed2a480-4911-11e9-9370-694ec989729b.png)\n\nWe will start with the client as it’s much easier, because Jest is set and ready to use right out of the box thanks to `create-react-app`.\n\n**Client - Testing React.Components**\n\nThanks to `create-react-app`, we have Jest set and ready to use right out of the box, so we can start writing tests right away. I you'll look at the `src` you'll see a file called `App.test.tsx`, which simply ensures that the component can be rendered without crashing.\n\n```jsx\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nit('renders without crashing', () => {\n  const div = document.createElement('div');\n  ReactDOM.render(<App />, div);\n  ReactDOM.unmountComponentAtNode(div);\n});\n```\n\nThis is not a typical test that you're likely to find in a React project, but it demonstrates very well how Jest can be used to test DOM related issues. If you'll run `$ npm run test` (or `$ yarn test`) in the command line and then press `a`, you should see the following output:\n\n![report](https://user-images.githubusercontent.com/7648874/54341429-eabe4700-4674-11e9-8e76-3aaaf7fec79a.png)\n\nJest will automatically run for every file that ends with a `.test.xxx` extension. This is very convenient because the tests can live right next to the component, and you don't need to lookup for it across the project. This behavior can be modified by configuring Jest in the `package.json` file under the `\"jest\"` field. More information about configuring Jest can be found in the official[ configuration documentation](https://jestjs.io/docs/en/configuration).\n\n> If you get a warning message regards wrapping the component with `act()` - this is a known issue with hooks and should have a proper solution soon. More about this issue and progress regards its fix can be found in this [GitHub thread](https://github.com/facebook/react/issues/14769#issuecomment-470097212).\n\nNow we're gonna write a basic test for the `<ChatsList />` component. In the test, we'll mock a fake response from the server, and examine the contents of rendered HTML. Since the HTML of the component is a dynamic thing and is constantly subject to changes, it would be a good idea to annotate it with `data-testid` attributes so it can be tested regardless of its structure:\n\n[{]: <helper> (diffStep \"5.1\" files=\"ChatsList.tsx\" module=\"client\")\n\n#### [__Client__ Step 5.1: Add data-testid attributes](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/3cf5be9)\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;ChatsList.tsx\n```diff\n@@ -92,14 +92,20 @@\n ┊ 92┊ 92┊    <Container>\n ┊ 93┊ 93┊      <StyledList>\n ┊ 94┊ 94┊        {chats.map(chat => (\n-┊ 95┊   ┊          <StyledListItem key={chat!.id} button>\n-┊ 96┊   ┊            <ChatPicture src={chat.picture} alt=\"Profile\" />\n+┊   ┊ 95┊          <StyledListItem key={chat.id} button>\n+┊   ┊ 96┊            <ChatPicture\n+┊   ┊ 97┊              data-testid=\"picture\"\n+┊   ┊ 98┊              src={chat.picture}\n+┊   ┊ 99┊              alt=\"Profile\"\n+┊   ┊100┊            />\n ┊ 97┊101┊            <ChatInfo>\n-┊ 98┊   ┊              <ChatName>{chat.name}</ChatName>\n+┊   ┊102┊              <ChatName data-testid=\"name\">{chat.name}</ChatName>\n ┊ 99┊103┊              {chat.lastMessage && (\n ┊100┊104┊                <React.Fragment>\n-┊101┊   ┊                  <MessageContent>{chat.lastMessage.content}</MessageContent>\n-┊102┊   ┊                  <MessageDate>\n+┊   ┊105┊                  <MessageContent data-testid=\"content\">\n+┊   ┊106┊                    {chat.lastMessage.content}\n+┊   ┊107┊                  </MessageContent>\n+┊   ┊108┊                  <MessageDate data-testid=\"date\">\n ┊103┊109┊                    {moment(chat.lastMessage.createdAt).format('HH:mm')}\n ┊104┊110┊                  </MessageDate>\n ┊105┊111┊                </React.Fragment>\n```\n\n[}]: #\n\nNow we can select various HTML elements with a query selector when we test the component. We will install a couple of packages that will assist us in implementing the test:\n\n  $ yarn add jest-fetch-mock jest-dom react-testing-library\n\n- The [`jest-fetch-mock`](https://www.npmjs.com/package/jest-fetch-mock) package can mock responses emitted by the Fetch API.\n- The [`jest-dom`](https://www.npmjs.com/package/jsdom) package will add custom matchers that will help us examine HTML contents of DOM elements.\n- The [`react-testing-library`](https://www.npmjs.com/package/react-testing-library) package contains utility methods that will help us test React.Components with Jest.\n\nNext, we will create a file under the `src` folder called `setupTests.ts`. This file is loaded configured automatically by `create-react-app` and loaded by Jest, and we can use it to set up our testing environment according to our needs (like said earlier, Jest can be configured, so this file path can be changed). We will use that file to define a fake Fetch API using the `jest-fetch-mock` library:\n\n[{]: <helper> (diffStep \"5.2\" files=\"src/setupTests.ts\" module=\"client\")\n\n#### [__Client__ Step 5.2: Setup tests](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/57ccbad)\n\n##### Added src&#x2F;setupTests.ts\n```diff\n@@ -0,0 +1,7 @@\n+┊ ┊1┊import 'jest-dom/extend-expect';\n+┊ ┊2┊import { GlobalWithFetchMock } from 'jest-fetch-mock';\n+┊ ┊3┊import { act } from '@testing-library/react';\n+┊ ┊4┊\n+┊ ┊5┊const customGlobal: GlobalWithFetchMock = global as GlobalWithFetchMock;\n+┊ ┊6┊customGlobal.fetch = require('jest-fetch-mock');\n+┊ ┊7┊customGlobal.fetchMock = customGlobal.fetch;\n```\n\n[}]: #\n\nWe will create another file called `ChatsList.test.tsx`, right next to the `<ChatsList />` component under the `ChatsListScreen` directory, and inside we will implement our test. The test should follow these steps:\n\n- Mock the response to contain a fake chat, so we won't need to make an actual call to our GraphQL API.\n- We will create a new instance of `<ChatsList />` and render it in a container element.\n- We will wait for changes in the DOM caused by `setState()`.\n- We will test the contents of the container.\n\nAnd this is how the implementation should look like:\n\n[{]: <helper> (diffStep \"5.3\" files=\"src/components/ChatsListScreen/ChatsList.test.tsx\" module=\"client\")\n\n#### [__Client__ Step 5.3: Test ChatsList](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/21bd332)\n\n##### Added src&#x2F;components&#x2F;ChatsListScreen&#x2F;ChatsList.test.tsx\n```diff\n@@ -0,0 +1,61 @@\n+┊  ┊ 1┊import React from 'react';\n+┊  ┊ 2┊import ReactDOM from 'react-dom';\n+┊  ┊ 3┊import { cleanup, render, waitForDomChange } from '@testing-library/react';\n+┊  ┊ 4┊import ChatsList from './ChatsList';\n+┊  ┊ 5┊\n+┊  ┊ 6┊describe('ChatsList', () => {\n+┊  ┊ 7┊  afterEach(cleanup);\n+┊  ┊ 8┊\n+┊  ┊ 9┊  it('renders fetched chats data', async () => {\n+┊  ┊10┊    fetch.mockResponseOnce(\n+┊  ┊11┊      JSON.stringify({\n+┊  ┊12┊        data: {\n+┊  ┊13┊          chats: [\n+┊  ┊14┊            {\n+┊  ┊15┊              id: 1,\n+┊  ┊16┊              name: 'Foo Bar',\n+┊  ┊17┊              picture: 'https://localhost:4000/picture.jpg',\n+┊  ┊18┊              lastMessage: {\n+┊  ┊19┊                id: 1,\n+┊  ┊20┊                content: 'Hello',\n+┊  ┊21┊                createdAt: new Date('1 Jan 2019 GMT'),\n+┊  ┊22┊              },\n+┊  ┊23┊            },\n+┊  ┊24┊          ],\n+┊  ┊25┊        },\n+┊  ┊26┊      })\n+┊  ┊27┊    );\n+┊  ┊28┊\n+┊  ┊29┊    {\n+┊  ┊30┊      const { container, getByTestId } = render(<ChatsList />);\n+┊  ┊31┊\n+┊  ┊32┊      await waitForDomChange({ container });\n+┊  ┊33┊\n+┊  ┊34┊      expect(getByTestId('name')).toHaveTextContent('Foo Bar');\n+┊  ┊35┊      expect(getByTestId('picture')).toHaveAttribute(\n+┊  ┊36┊        'src',\n+┊  ┊37┊        'https://localhost:4000/picture.jpg'\n+┊  ┊38┊      );\n+┊  ┊39┊      expect(getByTestId('content')).toHaveTextContent('Hello');\n+┊  ┊40┊      expect(getByTestId('date')).toHaveTextContent('02:00');\n+┊  ┊41┊    }\n+┊  ┊42┊  });\n+┊  ┊43┊});\n+┊  ┊44┊\n+┊  ┊45┊// IMPORTANT\n+┊  ┊46┊// Below is a temporary hack to suppress warnings generated by a React bug.\n+┊  ┊47┊// Source: https://github.com/testing-library/react-testing-library/issues/281\n+┊  ┊48┊// @todo: remove this when React 16.9.0 is stable and we upgrade.\n+┊  ┊49┊const originalError = console.error;\n+┊  ┊50┊beforeAll(() => {\n+┊  ┊51┊  console.error = (...args: string[]) => {\n+┊  ┊52┊    if (/Warning.*not wrapped in act/.test(args[0])) {\n+┊  ┊53┊      return;\n+┊  ┊54┊    }\n+┊  ┊55┊    originalError.call(console, ...args);\n+┊  ┊56┊  };\n+┊  ┊57┊});\n+┊  ┊58┊\n+┊  ┊59┊afterAll(() => {\n+┊  ┊60┊  console.error = originalError;\n+┊  ┊61┊});\n```\n\n[}]: #\n\n> Jest API is vast but pretty intuitive for the most part. It mostly consists of test descriptors and matchers. [Here's a full list of all matchers which are built into Jest's API](https://jestjs.io/docs/en/expect). Always make sure to work against it when writing tests, for optimal results.\n\nWe will now move on to testing the server where we will learn how to setup Jest manually and test it against a GraphQL API.\n\n**Server - Testing GraphQL resolvers**\n\nTo set-up Jest, we will run the following in the command line:\n\n    $ yarn add --dev jest @types/jest ts-jest\n\n\nThis will basically install Jest and make it useable with TypeScript.\nIn addition, we will need to specify the file pattern that we would like to transform with [`ts-jest`](https://www.npmjs.com/package/ts-jest), by adding the following section to `package.json`:\n\n```\n{\n  \"jest\": {\n    \"transform\": {\n      \"^.+\\\\.(js|jsx|ts|tsx)$\": \"<rootDir>/node_modules/ts-jest\"\n    }\n  }\n}\n```\n\nWe will also add a `\"test\"` script in the `package.json` file,\nso we can run the tests with `$ yarn test`:\n\n```\n{\n  \"scripts\": {\n    \"test\": \"jest\"\n  }\n}\n```\n\nThis is how our `package.json` should look like at this point:\n\n[{]: <helper> (diffStep \"3.1\" files=\"package.json\" module=\"server\")\n\n#### [__Server__ Step 3.1: Install and configure Jest](https://github.com/Urigo/WhatsApp-Clone-Server/commit/71d7c9e)\n\n##### Changed package.json\n```diff\n@@ -8,16 +8,24 @@\n ┊ 8┊ 8┊  \"private\": true,\n ┊ 9┊ 9┊  \"scripts\": {\n ┊10┊10┊    \"start\": \"ts-node index.ts\",\n+┊  ┊11┊    \"test\": \"TZ=\\\"Asia/Jerusalem\\\" jest\",\n ┊11┊12┊    \"format\": \"prettier '**/*.ts' --write\"\n ┊12┊13┊  },\n+┊  ┊14┊  \"jest-junit\": {\n+┊  ┊15┊    \"outputDirectory\": \"./test-results\"\n+┊  ┊16┊  },\n ┊13┊17┊  \"devDependencies\": {\n ┊14┊18┊    \"@types/body-parser\": \"1.17.0\",\n ┊15┊19┊    \"@types/cors\": \"2.8.5\",\n ┊16┊20┊    \"@types/express\": \"4.17.0\",\n ┊17┊21┊    \"@types/graphql\": \"14.2.1\",\n ┊18┊22┊    \"@types/graphql-iso-date\": \"3.3.1\",\n+┊  ┊23┊    \"@types/jest\": \"24.0.15\",\n ┊19┊24┊    \"@types/node\": \"12.0.8\",\n+┊  ┊25┊    \"jest\": \"24.8.0\",\n+┊  ┊26┊    \"jest-junit\": \"6.4.0\",\n ┊20┊27┊    \"prettier\": \"1.18.2\",\n+┊  ┊28┊    \"ts-jest\": \"24.0.2\",\n ┊21┊29┊    \"ts-node\": \"8.3.0\",\n ┊22┊30┊    \"typescript\": \"3.5.2\"\n ┊23┊31┊  },\n```\n```diff\n@@ -30,5 +38,19 @@\n ┊30┊38┊    \"graphql-import\": \"0.7.1\",\n ┊31┊39┊    \"graphql-iso-date\": \"3.6.1\",\n ┊32┊40┊    \"graphql-tools\": \"4.0.4\"\n+┊  ┊41┊  },\n+┊  ┊42┊  \"jest\": {\n+┊  ┊43┊    \"transform\": {\n+┊  ┊44┊      \"^.+\\\\.(js|jsx|ts|tsx)$\": \"<rootDir>/node_modules/ts-jest\"\n+┊  ┊45┊    },\n+┊  ┊46┊    \"globals\": {\n+┊  ┊47┊      \"ts-jest\": {\n+┊  ┊48┊        \"diagnostics\": false\n+┊  ┊49┊      }\n+┊  ┊50┊    },\n+┊  ┊51┊    \"reporters\": [\n+┊  ┊52┊      \"default\",\n+┊  ┊53┊      \"jest-junit\"\n+┊  ┊54┊    ]\n ┊33┊55┊  }\n ┊34┊56┊}🚫↵\n```\n\n[}]: #\n\nNow we're gonna test the `chats` query in our GraphQL schema. To do so, we will setup an Apollo Client and send a query request to our back-end, and then we will match the received response with a pre-defined snapshot. Luckily, we don't have to set an actual client, since the tests and the implementation of the back-end live right next to each other, thus, we will install a package which will help us achieving so:\n\n    $ yarn add --dev apollo-server-testing\n\nWe will define the test suite under the `tests/queries` folder in a file called `getChats.test.ts`:\n\n[{]: <helper> (diffStep \"3.2\" files=\"tests/queries/getChats.test.ts\" module=\"server\")\n\n#### [__Server__ Step 3.2: Test Query.chats](https://github.com/Urigo/WhatsApp-Clone-Server/commit/70068c8)\n\n##### Added tests&#x2F;queries&#x2F;getChats.test.ts\n```diff\n@@ -0,0 +1,32 @@\n+┊  ┊ 1┊import { createTestClient } from 'apollo-server-testing';\n+┊  ┊ 2┊import { ApolloServer, gql } from 'apollo-server-express';\n+┊  ┊ 3┊import schema from '../../schema';\n+┊  ┊ 4┊\n+┊  ┊ 5┊describe('Query.chats', () => {\n+┊  ┊ 6┊  it('should fetch all chats', async () => {\n+┊  ┊ 7┊    const server = new ApolloServer({ schema });\n+┊  ┊ 8┊\n+┊  ┊ 9┊    const { query } = createTestClient(server);\n+┊  ┊10┊\n+┊  ┊11┊    const res = await query({\n+┊  ┊12┊      query: gql`\n+┊  ┊13┊        query GetChats {\n+┊  ┊14┊          chats {\n+┊  ┊15┊            id\n+┊  ┊16┊            name\n+┊  ┊17┊            picture\n+┊  ┊18┊            lastMessage {\n+┊  ┊19┊              id\n+┊  ┊20┊              content\n+┊  ┊21┊              createdAt\n+┊  ┊22┊            }\n+┊  ┊23┊          }\n+┊  ┊24┊        }\n+┊  ┊25┊      `,\n+┊  ┊26┊    });\n+┊  ┊27┊\n+┊  ┊28┊    expect(res.data).toBeDefined();\n+┊  ┊29┊    expect(res.errors).toBeUndefined();\n+┊  ┊30┊    expect(res.data).toMatchSnapshot();\n+┊  ┊31┊  });\n+┊  ┊32┊});\n```\n\n[}]: #\n\nIn the test function, we create a new instance of the Apollo-GraphQL server using our schema, and we query some data against it thanks to the fake client created by [`apollo-server-testing`](https://www.npmjs.com/package/apollo-server-testing).\n\nThe `.toMatchSnapshot()` matcher will call the `toString()` method on the examined object and will test it against a predefined snapshot.\nThe snapshot will automatically be created once we run the test for the first time and will be stored under the `__snapshot__` directory.\nThis means that the first test run will always pass. This is useful because you can later on observe and adjust manually the snapshot manually without having to write it from scratch.\n\nSo let's do our first test run for the server:\n\n    $ yarn test\n\nThe expected result should be a projection of the data stored in the `db.ts` file.\n\n[{]: <helper> (diffStep \"3.2\" files=\"tests/queries/__snapshots__\" module=\"server\")\n\n#### [__Server__ Step 3.2: Test Query.chats](https://github.com/Urigo/WhatsApp-Clone-Server/commit/70068c8)\n\n##### Added tests&#x2F;queries&#x2F;\\__snapshots__&#x2F;getChats.test.ts.snap\n```diff\n@@ -0,0 +1,48 @@\n+┊  ┊ 1┊// Jest Snapshot v1, https://goo.gl/fbAQLP\n+┊  ┊ 2┊\n+┊  ┊ 3┊exports[`Query.chats should fetch all chats 1`] = `\n+┊  ┊ 4┊Object {\n+┊  ┊ 5┊  \"chats\": Array [\n+┊  ┊ 6┊    Object {\n+┊  ┊ 7┊      \"id\": \"1\",\n+┊  ┊ 8┊      \"lastMessage\": Object {\n+┊  ┊ 9┊        \"content\": \"You on your way?\",\n+┊  ┊10┊        \"createdAt\": \"2018-12-30T23:20:00.000Z\",\n+┊  ┊11┊        \"id\": \"1\",\n+┊  ┊12┊      },\n+┊  ┊13┊      \"name\": \"Ethan Gonzalez\",\n+┊  ┊14┊      \"picture\": \"https://randomuser.me/api/portraits/thumb/men/1.jpg\",\n+┊  ┊15┊    },\n+┊  ┊16┊    Object {\n+┊  ┊17┊      \"id\": \"2\",\n+┊  ┊18┊      \"lastMessage\": Object {\n+┊  ┊19┊        \"content\": \"Hey, it's me\",\n+┊  ┊20┊        \"createdAt\": \"2018-12-30T06:40:00.000Z\",\n+┊  ┊21┊        \"id\": \"2\",\n+┊  ┊22┊      },\n+┊  ┊23┊      \"name\": \"Bryan Wallace\",\n+┊  ┊24┊      \"picture\": \"https://randomuser.me/api/portraits/thumb/men/2.jpg\",\n+┊  ┊25┊    },\n+┊  ┊26┊    Object {\n+┊  ┊27┊      \"id\": \"3\",\n+┊  ┊28┊      \"lastMessage\": Object {\n+┊  ┊29┊        \"content\": \"I should buy a boat\",\n+┊  ┊30┊        \"createdAt\": \"2018-12-15T00:00:00.000Z\",\n+┊  ┊31┊        \"id\": \"3\",\n+┊  ┊32┊      },\n+┊  ┊33┊      \"name\": \"Avery Stewart\",\n+┊  ┊34┊      \"picture\": \"https://randomuser.me/api/portraits/thumb/women/1.jpg\",\n+┊  ┊35┊    },\n+┊  ┊36┊    Object {\n+┊  ┊37┊      \"id\": \"4\",\n+┊  ┊38┊      \"lastMessage\": Object {\n+┊  ┊39┊        \"content\": \"This is wicked good ice cream.\",\n+┊  ┊40┊        \"createdAt\": \"2018-05-12T08:00:00.000Z\",\n+┊  ┊41┊        \"id\": \"4\",\n+┊  ┊42┊      },\n+┊  ┊43┊      \"name\": \"Katie Peterson\",\n+┊  ┊44┊      \"picture\": \"https://randomuser.me/api/portraits/thumb/women/2.jpg\",\n+┊  ┊45┊    },\n+┊  ┊46┊  ],\n+┊  ┊47┊}\n+┊  ┊48┊`;\n```\n\n[}]: #\n\nAlways be sure to observe the snapshot before moving on! The received result isn't necessarily what you'd expect. Also it's not a good practice to store production data in the snapshot because it's subject to changes. Normally we would set up another instance of the DB for testing purposes, but since our DB is a mock and doesn't represent real data, there's no need to at this stage.\n\nNow that we have the required knowledge regards testing and Jest's API, we will implement tests throughout the tutorial as a trivial thing. We will not go through each and every new matcher that we introduce, as it is self explanatory and there's too much of them. Be sure to work against [this full list of matchers](https://jestjs.io/docs/en/expect) when working with Jest.\n\nIn the next chapter we will continue expanding our application by adding a `<ChatRoomScreen />`.\n\n----------\nTODO: Check what changed on testing in create-react-app 3.0 https://facebook.github.io/create-react-app/docs/running-tests\n\nTODO: I think ts-jest could be configured in a simpler way, but need to check\n\t{ preset: 'ts-jest' }\n\nTODO: I don’t like using jest’s toMatchSnapshot() to compare operation’s result that comes from the real GraphQL Schema (with resolvers).\nIt might change quite a lot and break tests. That data might be huge and hard to be validated by looking at it. Maybe checking a structure is a better approach?\n\nTODO: Why ts-jest?\n\nTODO: Change into tortilla diff:\n\nTODO: Change into Tortilla diif:\n\nTODO: Test with UTC timezone so it would work on all computers\n\nTODO: const server = new ApolloServer({ typeDefs }); // easier, no need to compile the schema before"
          },
          {
            "manualTitle": "Step 6: Creating an app router and implementing a chat room",
            "stepRevision": "ce3c5ffeef300f29a74e4c5c0f67bb610f0aeb09",
            "manualView": "In this chapter we will learn how to build a chat room screen.\nIn order to navigate between different screens, we will setup a router.\n\nSince we're gonna have to screens in our app now - `ChatsListScreen` and `ChatRoomScreen`, we will need a router that will be able to alternate between them.\nWe will be using the [`react-router-dom`](https://www.npmjs.com/package/react-router-dom) package to manage the routes of the application:\n\n    $ yarn add react-router-dom\n\nAnd we will implement a router directly in the `<App />` component:\n\n[{]: <helper> (diffStep 6.1 files=\"App\" module=\"client\")\n\n#### [__Client__ Step 6.1: Add router](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/1f7e981)\n\n##### Changed src&#x2F;App.tsx\n```diff\n@@ -1,10 +1,18 @@\n ┊ 1┊ 1┊import React from 'react';\n+┊  ┊ 2┊import { BrowserRouter, Route, Redirect, Switch } from 'react-router-dom';\n+┊  ┊ 3┊import ChatRoomScreen from './components/ChatRoomScreen';\n ┊ 2┊ 4┊import ChatsListScreen from './components/ChatsListScreen';\n ┊ 3┊ 5┊\n ┊ 4┊ 6┊const App: React.FC = () => (\n-┊ 5┊  ┊  <div>\n-┊ 6┊  ┊    <ChatsListScreen />\n-┊ 7┊  ┊  </div>\n+┊  ┊ 7┊  <BrowserRouter>\n+┊  ┊ 8┊    <Switch>\n+┊  ┊ 9┊      <Route exact path=\"/chats\" component={ChatsListScreen} />\n+┊  ┊10┊      <Route exact path=\"/chats/:chatId\" component={ChatRoomScreen} />\n+┊  ┊11┊    </Switch>\n+┊  ┊12┊    <Route exact path=\"/\" render={redirectToChats} />\n+┊  ┊13┊  </BrowserRouter>\n ┊ 8┊14┊);\n ┊ 9┊15┊\n+┊  ┊16┊const redirectToChats = () => <Redirect to=\"/chats\" />;\n+┊  ┊17┊\n ┊10┊18┊export default App;\n```\n\n[}]: #\n\nThe purpose of a router is to make route managing easy and declarative.\nIt will take care of managing the history within our app and parameterizing certain screens according to our need.\nEssentially it's a wrap around the `window.history` object which is also compatible with React.\nI recommend you to go through the [official MDN docs](https://developer.mozilla.org/en-US/docs/Web/API/History) if you're not yet familiar with the concept.\n\nThe `<Route />` component represents a path for a route in our application. Using the colon syntax (`:chatId`) we basically tell the router that the `/chat` route should be followed by a string whose value can later on be addressed via a parameter called `chatId` when navigating to the route. So here's a sum-up of the routes manifest:\n\n\n\n*   `/chats` - will navigate to the `ChatsListScreen`.\n*   `/chat/:chatId` - e.g. `/chat/1`, will navigate to the `ChatRoomScreen` and will parameterize it to show data which is related to chat ID 1.\n*   Any other route will fallback to the `/chats` route which will redirect us to the `ChatsListScreen`.\n\nNow we will implement the `ChatRoomScreen` so the router can function properly.\nFor now we will make it a plain screen which simply prints out the information of the chat that was clicked so we can have a complete flow,\nand then we will take care of the rest.\n\nTo do so, we will first implement the `chat` query in our backend.\nThis would be a parameterized query that will provide us with a specific chat according to the received ID,\nand it will be used by the new screen as soon as it is initialized.\nFirst we would update the `Chat` type to contain a `messages` field:\n\n[{]: <helper> (diffStep 4.1 files=\"typeDefs.graphql\" module=\"server\")\n\n#### [__Server__ Step 4.1: Add messages field to Chat type](https://github.com/Urigo/WhatsApp-Clone-Server/commit/7802ffb)\n\n##### Changed schema&#x2F;typeDefs.graphql\n```diff\n@@ -11,6 +11,7 @@\n ┊11┊11┊  name: String!\n ┊12┊12┊  picture: String\n ┊13┊13┊  lastMessage: Message\n+┊  ┊14┊  messages: [Message!]!\n ┊14┊15┊}\n ┊15┊16┊\n ┊16┊17┊type Query {\n```\n\n[}]: #\n\nThen we will create the appropriate resolver:\n\n[{]: <helper> (diffStep 4.1 files=\"resolvers.ts\" module=\"server\")\n\n#### [__Server__ Step 4.1: Add messages field to Chat type](https://github.com/Urigo/WhatsApp-Clone-Server/commit/7802ffb)\n\n##### Changed schema&#x2F;resolvers.ts\n```diff\n@@ -5,6 +5,10 @@\n ┊ 5┊ 5┊  Date: GraphQLDateTime,\n ┊ 6┊ 6┊\n ┊ 7┊ 7┊  Chat: {\n+┊  ┊ 8┊    messages(chat: any) {\n+┊  ┊ 9┊      return messages.filter(m => chat.messages.includes(m.id));\n+┊  ┊10┊    },\n+┊  ┊11┊\n ┊ 8┊12┊    lastMessage(chat: any) {\n ┊ 9┊13┊      return messages.find(m => m.id === chat.lastMessage);\n ┊10┊14┊    },\n```\n\n[}]: #\n\nAnd then we will update our DB mock to be aligned with these changes:\n\n[{]: <helper> (diffStep 4.1 files=\"db\" module=\"server\")\n\n#### [__Server__ Step 4.1: Add messages field to Chat type](https://github.com/Urigo/WhatsApp-Clone-Server/commit/7802ffb)\n\n##### Changed db.ts\n```diff\n@@ -29,23 +29,27 @@\n ┊29┊29┊    name: 'Ethan Gonzalez',\n ┊30┊30┊    picture: 'https://randomuser.me/api/portraits/thumb/men/1.jpg',\n ┊31┊31┊    lastMessage: '1',\n+┊  ┊32┊    messages: ['1'],\n ┊32┊33┊  },\n ┊33┊34┊  {\n ┊34┊35┊    id: '2',\n ┊35┊36┊    name: 'Bryan Wallace',\n ┊36┊37┊    picture: 'https://randomuser.me/api/portraits/thumb/men/2.jpg',\n ┊37┊38┊    lastMessage: '2',\n+┊  ┊39┊    messages: ['2'],\n ┊38┊40┊  },\n ┊39┊41┊  {\n ┊40┊42┊    id: '3',\n ┊41┊43┊    name: 'Avery Stewart',\n ┊42┊44┊    picture: 'https://randomuser.me/api/portraits/thumb/women/1.jpg',\n ┊43┊45┊    lastMessage: '3',\n+┊  ┊46┊    messages: ['3'],\n ┊44┊47┊  },\n ┊45┊48┊  {\n ┊46┊49┊    id: '4',\n ┊47┊50┊    name: 'Katie Peterson',\n ┊48┊51┊    picture: 'https://randomuser.me/api/portraits/thumb/women/2.jpg',\n ┊49┊52┊    lastMessage: '4',\n+┊  ┊53┊    messages: ['4'],\n ┊50┊54┊  },\n ┊51┊55┊];\n```\n\n[}]: #\n\nThis means that when we resolve `Chat.lastMessage`, we should get it directly from the `Chat.messages` field:\n\n[{]: <helper> (diffStep 4.2 module=\"server\")\n\n#### [__Server__ Step 4.2: Resolve last message based on messages array](https://github.com/Urigo/WhatsApp-Clone-Server/commit/358a4e9)\n\n##### Changed db.ts\n```diff\n@@ -28,28 +28,24 @@\n ┊28┊28┊    id: '1',\n ┊29┊29┊    name: 'Ethan Gonzalez',\n ┊30┊30┊    picture: 'https://randomuser.me/api/portraits/thumb/men/1.jpg',\n-┊31┊  ┊    lastMessage: '1',\n ┊32┊31┊    messages: ['1'],\n ┊33┊32┊  },\n ┊34┊33┊  {\n ┊35┊34┊    id: '2',\n ┊36┊35┊    name: 'Bryan Wallace',\n ┊37┊36┊    picture: 'https://randomuser.me/api/portraits/thumb/men/2.jpg',\n-┊38┊  ┊    lastMessage: '2',\n ┊39┊37┊    messages: ['2'],\n ┊40┊38┊  },\n ┊41┊39┊  {\n ┊42┊40┊    id: '3',\n ┊43┊41┊    name: 'Avery Stewart',\n ┊44┊42┊    picture: 'https://randomuser.me/api/portraits/thumb/women/1.jpg',\n-┊45┊  ┊    lastMessage: '3',\n ┊46┊43┊    messages: ['3'],\n ┊47┊44┊  },\n ┊48┊45┊  {\n ┊49┊46┊    id: '4',\n ┊50┊47┊    name: 'Katie Peterson',\n ┊51┊48┊    picture: 'https://randomuser.me/api/portraits/thumb/women/2.jpg',\n-┊52┊  ┊    lastMessage: '4',\n ┊53┊49┊    messages: ['4'],\n ┊54┊50┊  },\n ┊55┊51┊];\n```\n\n##### Changed schema&#x2F;resolvers.ts\n```diff\n@@ -10,7 +10,9 @@\n ┊10┊10┊    },\n ┊11┊11┊\n ┊12┊12┊    lastMessage(chat: any) {\n-┊13┊  ┊      return messages.find(m => m.id === chat.lastMessage);\n+┊  ┊13┊      const lastMessage = chat.messages[chat.messages.length - 1];\n+┊  ┊14┊\n+┊  ┊15┊      return messages.find(m => m.id === lastMessage);\n ┊14┊16┊    },\n ┊15┊17┊  },\n```\n\n[}]: #\n\nNow that we have an updated schema which is relevant to the new screen that we would like to add, we will declare a new query called `chat`:\n\n[{]: <helper> (diffStep 4.3 files=\"schema/typeDefs\" module=\"server\")\n\n#### [__Server__ Step 4.3: Add chat field to Query type](https://github.com/Urigo/WhatsApp-Clone-Server/commit/9561663)\n\n##### Changed schema&#x2F;typeDefs.graphql\n```diff\n@@ -16,4 +16,5 @@\n ┊16┊16┊\n ┊17┊17┊type Query {\n ┊18┊18┊  chats: [Chat!]!\n+┊  ┊19┊  chat(chatId: ID!): Chat\n ┊19┊20┊}\n```\n\n[}]: #\n\nNote that unlike the `chats` query, this time we have a parameter. The parameters are provided to the resolver function as the second parameter as a JSON. Using the provided parameter - the chat ID, we will find and return the relevant chat from the DB:\n\n[{]: <helper> (diffStep 4.3 files=\"schema/resolvers\" module=\"server\")\n\n#### [__Server__ Step 4.3: Add chat field to Query type](https://github.com/Urigo/WhatsApp-Clone-Server/commit/9561663)\n\n##### Changed schema&#x2F;resolvers.ts\n```diff\n@@ -20,6 +20,10 @@\n ┊20┊20┊    chats() {\n ┊21┊21┊      return chats;\n ┊22┊22┊    },\n+┊  ┊23┊\n+┊  ┊24┊    chat(root: any, { chatId }: any) {\n+┊  ┊25┊      return chats.find(c => c.id === chatId);\n+┊  ┊26┊    },\n ┊23┊27┊  },\n ┊24┊28┊};\n ┊25┊29┊\n```\n\n[}]: #\n\n> More about the resolver signature can be read in [Apollo-GraphQL's official docs page](https://www.apollographql.com/docs/apollo-server/essentials/data.html#type-signature).\n\nNow we will add a test suite:\n\n[{]: <helper> (diffStep 4.3 files=\"tests/queries/getChat.test\" module=\"server\")\n\n#### [__Server__ Step 4.3: Add chat field to Query type](https://github.com/Urigo/WhatsApp-Clone-Server/commit/9561663)\n\n##### Added tests&#x2F;queries&#x2F;getChat.test.ts\n```diff\n@@ -0,0 +1,33 @@\n+┊  ┊ 1┊import { createTestClient } from 'apollo-server-testing';\n+┊  ┊ 2┊import { ApolloServer, gql } from 'apollo-server-express';\n+┊  ┊ 3┊import schema from '../../schema';\n+┊  ┊ 4┊\n+┊  ┊ 5┊describe('Query.chat', () => {\n+┊  ┊ 6┊  it('should fetch specified chat', async () => {\n+┊  ┊ 7┊    const server = new ApolloServer({ schema });\n+┊  ┊ 8┊\n+┊  ┊ 9┊    const { query } = createTestClient(server);\n+┊  ┊10┊\n+┊  ┊11┊    const res = await query({\n+┊  ┊12┊      variables: { chatId: '1' },\n+┊  ┊13┊      query: gql`\n+┊  ┊14┊        query GetChat($chatId: ID!) {\n+┊  ┊15┊          chat(chatId: $chatId) {\n+┊  ┊16┊            id\n+┊  ┊17┊            name\n+┊  ┊18┊            picture\n+┊  ┊19┊            lastMessage {\n+┊  ┊20┊              id\n+┊  ┊21┊              content\n+┊  ┊22┊              createdAt\n+┊  ┊23┊            }\n+┊  ┊24┊          }\n+┊  ┊25┊        }\n+┊  ┊26┊      `,\n+┊  ┊27┊    });\n+┊  ┊28┊\n+┊  ┊29┊    expect(res.data).toBeDefined();\n+┊  ┊30┊    expect(res.errors).toBeUndefined();\n+┊  ┊31┊    expect(res.data).toMatchSnapshot();\n+┊  ┊32┊  });\n+┊  ┊33┊});\n```\n\n[}]: #\n\nWe can observe the snapshot created by Jest to get a better understanding of how the response should look like:\n\n[{]: <helper> (diffStep 4.3 files=\"__snapshot__\" module=\"server\")\n\n#### [__Server__ Step 4.3: Add chat field to Query type](https://github.com/Urigo/WhatsApp-Clone-Server/commit/9561663)\n\n\n\n[}]: #\n\nIf you experience any TypeScript related issues with the following error:\n\n```\nObject literal may only specify known properties, and 'variables' does not exist in type 'Query'.\n```\n\nAdd the following declaration file to your project:\n\n[{]: <helper> (diffStep 4.3 files=\"types\" module=\"server\")\n\n#### [__Server__ Step 4.3: Add chat field to Query type](https://github.com/Urigo/WhatsApp-Clone-Server/commit/9561663)\n\n##### Added types&#x2F;apollo-server-testing.d.ts\n```diff\n@@ -0,0 +1,27 @@\n+┊  ┊ 1┊declare module 'apollo-server-testing' {\n+┊  ┊ 2┊  import { ApolloServerBase } from 'apollo-server-core';\n+┊  ┊ 3┊  import { print, DocumentNode } from 'graphql';\n+┊  ┊ 4┊  import { GraphQLResponse } from 'graphql-extensions';\n+┊  ┊ 5┊\n+┊  ┊ 6┊  type StringOrAst = string | DocumentNode;\n+┊  ┊ 7┊\n+┊  ┊ 8┊  // A query must not come with a mutation (and vice versa).\n+┊  ┊ 9┊  type Query<TVariables> = {\n+┊  ┊10┊    query: StringOrAst;\n+┊  ┊11┊    mutation?: undefined;\n+┊  ┊12┊    variables?: TVariables;\n+┊  ┊13┊  };\n+┊  ┊14┊\n+┊  ┊15┊  type Mutation<TVariables> = {\n+┊  ┊16┊    mutation: StringOrAst;\n+┊  ┊17┊    query?: undefined;\n+┊  ┊18┊    variables?: TVariables;\n+┊  ┊19┊  };\n+┊  ┊20┊\n+┊  ┊21┊  export const createTestClient: <TVariables>(\n+┊  ┊22┊    server: ApolloServerBase\n+┊  ┊23┊  ) => {\n+┊  ┊24┊    query: (query: Query<TVariables>) => Promise<GraphQLResponse>;\n+┊  ┊25┊    mutate: (mutation: Mutation<TVariables>) => Promise<GraphQLResponse>;\n+┊  ┊26┊  };\n+┊  ┊27┊}\n```\n\n[}]: #\n\nThis is a [known issue](https://github.com/apollographql/apollo-server/issues/2172) in the `apollo-server-testing` package and has a pending [fix PR](https://github.com/apollographql/apollo-server/pull/2307).\nNow getting back to the client, let's implement a basic version of the `ChatRoomScreen` where we will fetch the new query and print it to the screen:\n\n[{]: <helper> (diffStep 6.2 module=\"client\")\n\n#### [__Client__ Step 6.2: Add basic ChatRoomScreen](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/5783d51)\n\n##### Changed src&#x2F;App.tsx\n```diff\n@@ -1,5 +1,11 @@\n ┊ 1┊ 1┊import React from 'react';\n-┊ 2┊  ┊import { BrowserRouter, Route, Redirect, Switch } from 'react-router-dom';\n+┊  ┊ 2┊import {\n+┊  ┊ 3┊  BrowserRouter,\n+┊  ┊ 4┊  Route,\n+┊  ┊ 5┊  Redirect,\n+┊  ┊ 6┊  Switch,\n+┊  ┊ 7┊  RouteComponentProps,\n+┊  ┊ 8┊} from 'react-router-dom';\n ┊ 3┊ 9┊import ChatRoomScreen from './components/ChatRoomScreen';\n ┊ 4┊10┊import ChatsListScreen from './components/ChatsListScreen';\n ┊ 5┊11┊\n```\n```diff\n@@ -7,7 +13,14 @@\n ┊ 7┊13┊  <BrowserRouter>\n ┊ 8┊14┊    <Switch>\n ┊ 9┊15┊      <Route exact path=\"/chats\" component={ChatsListScreen} />\n-┊10┊  ┊      <Route exact path=\"/chats/:chatId\" component={ChatRoomScreen} />\n+┊  ┊16┊\n+┊  ┊17┊      <Route\n+┊  ┊18┊        exact\n+┊  ┊19┊        path=\"/chats/:chatId\"\n+┊  ┊20┊        component={({ match }: RouteComponentProps<{ chatId: string }>) => (\n+┊  ┊21┊          <ChatRoomScreen chatId={match.params.chatId} />\n+┊  ┊22┊        )}\n+┊  ┊23┊      />\n ┊11┊24┊    </Switch>\n ┊12┊25┊    <Route exact path=\"/\" render={redirectToChats} />\n ┊13┊26┊  </BrowserRouter>\n```\n\n##### Added src&#x2F;components&#x2F;ChatRoomScreen&#x2F;index.tsx\n```diff\n@@ -0,0 +1,76 @@\n+┊  ┊ 1┊import React from 'react';\n+┊  ┊ 2┊import { useMemo, useState } from 'react';\n+┊  ┊ 3┊\n+┊  ┊ 4┊const getChatQuery = `\n+┊  ┊ 5┊  query GetChat($chatId: ID!) {\n+┊  ┊ 6┊    chat(chatId: $chatId) {\n+┊  ┊ 7┊      id\n+┊  ┊ 8┊      name\n+┊  ┊ 9┊      picture\n+┊  ┊10┊      messages {\n+┊  ┊11┊        id\n+┊  ┊12┊        content\n+┊  ┊13┊        createdAt\n+┊  ┊14┊      }\n+┊  ┊15┊    }\n+┊  ┊16┊  }\n+┊  ┊17┊`;\n+┊  ┊18┊\n+┊  ┊19┊interface ChatRoomScreenParams {\n+┊  ┊20┊  chatId: string;\n+┊  ┊21┊}\n+┊  ┊22┊\n+┊  ┊23┊interface ChatQueryMessage {\n+┊  ┊24┊  id: string;\n+┊  ┊25┊  content: string;\n+┊  ┊26┊  createdAt: string;\n+┊  ┊27┊}\n+┊  ┊28┊\n+┊  ┊29┊interface ChatQueryResult {\n+┊  ┊30┊  id: string;\n+┊  ┊31┊  name: string;\n+┊  ┊32┊  picture: string;\n+┊  ┊33┊  messages: Array<ChatQueryMessage>;\n+┊  ┊34┊}\n+┊  ┊35┊\n+┊  ┊36┊type OptionalChatQueryResult = ChatQueryResult | null;\n+┊  ┊37┊\n+┊  ┊38┊const ChatRoomScreen: React.FC<ChatRoomScreenParams> = ({ chatId }) => {\n+┊  ┊39┊  const [chat, setChat] = useState<OptionalChatQueryResult>(null);\n+┊  ┊40┊\n+┊  ┊41┊  useMemo(async () => {\n+┊  ┊42┊    const body = await fetch(`${process.env.REACT_APP_SERVER_URL}/graphql`, {\n+┊  ┊43┊      method: 'POST',\n+┊  ┊44┊      headers: {\n+┊  ┊45┊        'Content-Type': 'application/json',\n+┊  ┊46┊      },\n+┊  ┊47┊      body: JSON.stringify({\n+┊  ┊48┊        query: getChatQuery,\n+┊  ┊49┊        variables: { chatId },\n+┊  ┊50┊      }),\n+┊  ┊51┊    });\n+┊  ┊52┊    const {\n+┊  ┊53┊      data: { chat },\n+┊  ┊54┊    } = await body.json();\n+┊  ┊55┊    setChat(chat);\n+┊  ┊56┊  }, [chatId]);\n+┊  ┊57┊\n+┊  ┊58┊  if (!chat) return null;\n+┊  ┊59┊\n+┊  ┊60┊  return (\n+┊  ┊61┊    <div>\n+┊  ┊62┊      <img src={chat.picture} alt=\"Profile\" />\n+┊  ┊63┊      <div>{chat.name}</div>\n+┊  ┊64┊      <ul>\n+┊  ┊65┊        {chat.messages.map(message => (\n+┊  ┊66┊          <li key={message.id}>\n+┊  ┊67┊            <div>{message.content}</div>\n+┊  ┊68┊            <div>{message.createdAt}</div>\n+┊  ┊69┊          </li>\n+┊  ┊70┊        ))}\n+┊  ┊71┊      </ul>\n+┊  ┊72┊    </div>\n+┊  ┊73┊  );\n+┊  ┊74┊};\n+┊  ┊75┊\n+┊  ┊76┊export default ChatRoomScreen;\n```\n\n[}]: #\n\nNote how we used the `match.params.chatId` variable to get the selected chat ID.\nThe `match` prop is defined and provided to us by the `<Route />` component, since it interfaces directly with the `ChatRoomScreen`.\nMore about that can be read in the [official docs page](https://reacttraining.com/react-router/core/api/match).\n\nIn many examples online, you can see people pass the `match` prop directly to the component.\nThe main issue with that is that this makes the component being usable only by a router, but the truth is that the component\ndoesn't care if it's consumed by a router or another parents component as long as they will pass the `chatId` prop.\n\nSo we need to make sure the interface of the ChatRoom component defines those requierements right.\n\nNext we will call our server from the component with the right query and store the result on a `useState` hook.\n\nNow, because we are using GraphQL, we know the types of the result that we are going to get, so let's create Typescript interfaces that\ndescribe the data we're going to get from the server.\n\nIf you'll run the application and type `/chats/1` in the URL bar, this is what you should see on the screen:\n\n![naked-chat](https://user-images.githubusercontent.com/7648874/54664314-d4096b80-4b1e-11e9-9e06-1323cf7b0abe.png)\n\nThe view has no styling at all but it should be fixed in a moment.\nTo make navigation more convenient we will add an `onClick` listener for each chat item in the `ChatsList`.\nUsing the [history](https://reacttraining.com/react-router/core/api/history) object, provided to us by the `<Route />` component,\nwe will navigate to the correlated `ChatRoomScreen`:\n\nFirst let's install the `history` package:\n\n    $ yarn add history @types/history\n\n[{]: <helper> (diffStep 6.3 module=\"client\")\n\n#### [__Client__ Step 6.3: Navigate to chat on click](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/276772d)\n\n##### Changed package.json\n```diff\n@@ -9,6 +9,7 @@\n ┊ 9┊ 9┊  \"dependencies\": {\n ┊10┊10┊    \"@material-ui/core\": \"4.1.1\",\n ┊11┊11┊    \"@material-ui/icons\": \"4.2.0\",\n+┊  ┊12┊    \"@types/history\": \"4.7.2\",\n ┊12┊13┊    \"@types/jest\": \"24.0.15\",\n ┊13┊14┊    \"@types/material-ui\": \"0.21.6\",\n ┊14┊15┊    \"@types/node\": \"12.0.8\",\n```\n```diff\n@@ -16,6 +17,7 @@\n ┊16┊17┊    \"@types/react-dom\": \"16.8.4\",\n ┊17┊18┊    \"@types/react-router-dom\": \"4.3.4\",\n ┊18┊19┊    \"@types/styled-components\": \"4.1.16\",\n+┊  ┊20┊    \"history\": \"4.9.0\",\n ┊19┊21┊    \"moment\": \"2.24.0\",\n ┊20┊22┊    \"prettier\": \"1.18.2\",\n ┊21┊23┊    \"react\": \"16.8.6\",\n```\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;ChatsList.tsx\n```diff\n@@ -2,7 +2,8 @@\n ┊2┊2┊import moment from 'moment';\n ┊3┊3┊import { List, ListItem } from '@material-ui/core';\n ┊4┊4┊import styled from 'styled-components';\n-┊5┊ ┊import { useState, useMemo } from 'react';\n+┊ ┊5┊import { useCallback, useState, useMemo } from 'react';\n+┊ ┊6┊import { History } from 'history';\n ┊6┊7┊\n ┊7┊8┊const Container = styled.div`\n ┊8┊9┊  height: calc(100% - 56px);\n```\n```diff\n@@ -71,7 +72,11 @@\n ┊71┊72┊  }\n ┊72┊73┊`;\n ┊73┊74┊\n-┊74┊  ┊const ChatsList = () => {\n+┊  ┊75┊interface ChatsListProps {\n+┊  ┊76┊  history: History;\n+┊  ┊77┊}\n+┊  ┊78┊\n+┊  ┊79┊const ChatsList: React.FC<ChatsListProps> = ({ history }) => {\n ┊75┊80┊  const [chats, setChats] = useState<any[]>([]);\n ┊76┊81┊\n ┊77┊82┊  useMemo(async () => {\n```\n```diff\n@@ -88,11 +93,22 @@\n ┊ 88┊ 93┊    setChats(chats);\n ┊ 89┊ 94┊  }, []);\n ┊ 90┊ 95┊\n+┊   ┊ 96┊  const navToChat = useCallback(\n+┊   ┊ 97┊    chat => {\n+┊   ┊ 98┊      history.push(`chats/${chat.id}`);\n+┊   ┊ 99┊    },\n+┊   ┊100┊    [history]\n+┊   ┊101┊  );\n+┊   ┊102┊\n ┊ 91┊103┊  return (\n ┊ 92┊104┊    <Container>\n ┊ 93┊105┊      <StyledList>\n ┊ 94┊106┊        {chats.map(chat => (\n-┊ 95┊   ┊          <StyledListItem key={chat.id} button>\n+┊   ┊107┊          <StyledListItem\n+┊   ┊108┊            key={chat.id}\n+┊   ┊109┊            data-testid=\"chat\"\n+┊   ┊110┊            button\n+┊   ┊111┊            onClick={navToChat.bind(null, chat)}>\n ┊ 96┊112┊            <ChatPicture\n ┊ 97┊113┊              data-testid=\"picture\"\n ┊ 98┊114┊              src={chat.picture}\n```\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;index.tsx\n```diff\n@@ -2,15 +2,20 @@\n ┊ 2┊ 2┊import ChatsNavbar from './ChatsNavbar';\n ┊ 3┊ 3┊import ChatsList from './ChatsList';\n ┊ 4┊ 4┊import styled from 'styled-components';\n+┊  ┊ 5┊import { History } from 'history';\n ┊ 5┊ 6┊\n ┊ 6┊ 7┊const Container = styled.div`\n ┊ 7┊ 8┊  height: 100vh;\n ┊ 8┊ 9┊`;\n ┊ 9┊10┊\n-┊10┊  ┊const ChatsListScreen: React.FC = () => (\n+┊  ┊11┊interface ChatsListScreenProps {\n+┊  ┊12┊  history: History;\n+┊  ┊13┊}\n+┊  ┊14┊\n+┊  ┊15┊const ChatsListScreen: React.FC<ChatsListScreenProps> = ({ history }) => (\n ┊11┊16┊  <Container>\n ┊12┊17┊    <ChatsNavbar />\n-┊13┊  ┊    <ChatsList />\n+┊  ┊18┊    <ChatsList history={history} />\n ┊14┊19┊  </Container>\n ┊15┊20┊);\n```\n\n[}]: #\n\nAnd add test the new logic:\n\n[{]: <helper> (diffStep 6.4 module=\"client\")\n\n#### [__Client__ Step 6.4: Test new navigation logic](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/8f0a864)\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;ChatsList.test.tsx\n```diff\n@@ -1,10 +1,20 @@\n ┊ 1┊ 1┊import React from 'react';\n ┊ 2┊ 2┊import ReactDOM from 'react-dom';\n-┊ 3┊  ┊import { cleanup, render, waitForDomChange } from '@testing-library/react';\n+┊  ┊ 3┊import {\n+┊  ┊ 4┊  cleanup,\n+┊  ┊ 5┊  render,\n+┊  ┊ 6┊  fireEvent,\n+┊  ┊ 7┊  wait,\n+┊  ┊ 8┊  waitForDomChange,\n+┊  ┊ 9┊} from '@testing-library/react';\n ┊ 4┊10┊import ChatsList from './ChatsList';\n+┊  ┊11┊import { createBrowserHistory } from 'history';\n ┊ 5┊12┊\n ┊ 6┊13┊describe('ChatsList', () => {\n-┊ 7┊  ┊  afterEach(cleanup);\n+┊  ┊14┊  afterEach(() => {\n+┊  ┊15┊    cleanup();\n+┊  ┊16┊    window.location.pathname = '/';\n+┊  ┊17┊  });\n ┊ 8┊18┊\n ┊ 9┊19┊  it('renders fetched chats data', async () => {\n ┊10┊20┊    fetch.mockResponseOnce(\n```\n```diff\n@@ -40,6 +50,41 @@\n ┊40┊50┊      expect(getByTestId('date')).toHaveTextContent('02:00');\n ┊41┊51┊    }\n ┊42┊52┊  });\n+┊  ┊53┊\n+┊  ┊54┊  it('should navigate to the target chat room on chat item click', async () => {\n+┊  ┊55┊    fetch.mockResponseOnce(\n+┊  ┊56┊      JSON.stringify({\n+┊  ┊57┊        data: {\n+┊  ┊58┊          chats: [\n+┊  ┊59┊            {\n+┊  ┊60┊              id: 1,\n+┊  ┊61┊              name: 'Foo Bar',\n+┊  ┊62┊              picture: 'https://localhost:4000/picture.jpg',\n+┊  ┊63┊              lastMessage: {\n+┊  ┊64┊                id: 1,\n+┊  ┊65┊                content: 'Hello',\n+┊  ┊66┊                createdAt: new Date('1 Jan 2019 GMT'),\n+┊  ┊67┊              },\n+┊  ┊68┊            },\n+┊  ┊69┊          ],\n+┊  ┊70┊        },\n+┊  ┊71┊      })\n+┊  ┊72┊    );\n+┊  ┊73┊\n+┊  ┊74┊    const history = createBrowserHistory();\n+┊  ┊75┊\n+┊  ┊76┊    {\n+┊  ┊77┊      const { container, getByTestId } = render(\n+┊  ┊78┊        <ChatsList history={history} />\n+┊  ┊79┊      );\n+┊  ┊80┊\n+┊  ┊81┊      await waitForDomChange({ container });\n+┊  ┊82┊\n+┊  ┊83┊      fireEvent.click(getByTestId('chat'));\n+┊  ┊84┊\n+┊  ┊85┊      await wait(() => expect(history.location.pathname).toEqual('/chats/1'));\n+┊  ┊86┊    }\n+┊  ┊87┊  });\n ┊43┊88┊});\n ┊44┊89┊\n ┊45┊90┊// IMPORTANT\n```\n\n[}]: #\n\nIf you'll click on the chat item you'll see that the screen changes very suddenly.\nWe can smooth the transition by animating it with CSS.\nLuckily we don't need to implemented such mechanism manually because there's a package that can do that for us - [`react-router-transition`](https://www.npmjs.com/package/react-router-transition):\n\n    $ yarn add react-router-transition\n\nAnd let's add the mising types for the library:\n\n[{]: <helper> (diffStep 6.5 files=\"react-app-env.d.ts\" module=\"client\")\n\n#### [__Client__ Step 6.5: Animate route switching](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/4209949)\n\n##### Changed src&#x2F;react-app-env.d.ts\n```diff\n@@ -1 +1,3 @@\n ┊1┊1┊/// <reference types=\"react-scripts\" />\n+┊ ┊2┊\n+┊ ┊3┊declare module 'react-router-transition';\n```\n\n[}]: #\n\nUsing this package, we will create a custom `Switch` component that will play an animation for all its subordinate `Route` components.\nThe animation is defined by the user using a component called `AnimatedSwitch` as specified in the [package's docs page](http://maisano.github.io/react-router-transition/animated-switch/props).\nSo first, let's create our switch component that will play a smooth transition switching routes:\n\n[{]: <helper> (diffStep 6.5 files=\"AnimatedSwitch\" module=\"client\")\n\n#### [__Client__ Step 6.5: Animate route switching](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/4209949)\n\n##### Added src&#x2F;components&#x2F;AnimatedSwitch.tsx\n```diff\n@@ -0,0 +1,38 @@\n+┊  ┊ 1┊import { Switch } from 'react-router-dom';\n+┊  ┊ 2┊import { AnimatedSwitch, spring } from 'react-router-transition';\n+┊  ┊ 3┊import styled from 'styled-components';\n+┊  ┊ 4┊\n+┊  ┊ 5┊// A workaround to make test pass\n+┊  ┊ 6┊const SwitchComponent =\n+┊  ┊ 7┊  process.env.NODE_ENV === 'test' ? Switch : AnimatedSwitch;\n+┊  ┊ 8┊\n+┊  ┊ 9┊const glide = (val: number) =>\n+┊  ┊10┊  spring(val, {\n+┊  ┊11┊    stiffness: 174,\n+┊  ┊12┊    damping: 24,\n+┊  ┊13┊  });\n+┊  ┊14┊\n+┊  ┊15┊const mapStyles = (styles: any) => ({\n+┊  ┊16┊  transform: `translateX(${styles.offset}%)`,\n+┊  ┊17┊});\n+┊  ┊18┊\n+┊  ┊19┊const MyAnimatedSwitch = styled(SwitchComponent).attrs(() => ({\n+┊  ┊20┊  atEnter: { offset: 100 },\n+┊  ┊21┊  atLeave: { offset: glide(-100) },\n+┊  ┊22┊  atActive: { offset: glide(0) },\n+┊  ┊23┊  mapStyles,\n+┊  ┊24┊}))`\n+┊  ┊25┊  position: relative;\n+┊  ┊26┊  overflow: hidden;\n+┊  ┊27┊  height: 100vh;\n+┊  ┊28┊  width: 100vw;\n+┊  ┊29┊\n+┊  ┊30┊  > div {\n+┊  ┊31┊    position: absolute;\n+┊  ┊32┊    overflow: hidden;\n+┊  ┊33┊    height: 100vh;\n+┊  ┊34┊    width: 100vw;\n+┊  ┊35┊  }\n+┊  ┊36┊`;\n+┊  ┊37┊\n+┊  ┊38┊export default MyAnimatedSwitch;\n```\n\n[}]: #\n\nAnd then replace it with the main `Switch` component in our app:\n\n[{]: <helper> (diffStep 6.5 files=\"App\" module=\"client\")\n\n#### [__Client__ Step 6.5: Animate route switching](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/4209949)\n\n##### Changed src&#x2F;App.tsx\n```diff\n@@ -3,15 +3,15 @@\n ┊ 3┊ 3┊  BrowserRouter,\n ┊ 4┊ 4┊  Route,\n ┊ 5┊ 5┊  Redirect,\n-┊ 6┊  ┊  Switch,\n ┊ 7┊ 6┊  RouteComponentProps,\n ┊ 8┊ 7┊} from 'react-router-dom';\n ┊ 9┊ 8┊import ChatRoomScreen from './components/ChatRoomScreen';\n ┊10┊ 9┊import ChatsListScreen from './components/ChatsListScreen';\n+┊  ┊10┊import AnimatedSwitch from './components/AnimatedSwitch';\n ┊11┊11┊\n ┊12┊12┊const App: React.FC = () => (\n ┊13┊13┊  <BrowserRouter>\n-┊14┊  ┊    <Switch>\n+┊  ┊14┊    <AnimatedSwitch>\n ┊15┊15┊      <Route exact path=\"/chats\" component={ChatsListScreen} />\n ┊16┊16┊\n ┊17┊17┊      <Route\n```\n```diff\n@@ -21,7 +21,7 @@\n ┊21┊21┊          <ChatRoomScreen chatId={match.params.chatId} />\n ┊22┊22┊        )}\n ┊23┊23┊      />\n-┊24┊  ┊    </Switch>\n+┊  ┊24┊    </AnimatedSwitch>\n ┊25┊25┊    <Route exact path=\"/\" render={redirectToChats} />\n ┊26┊26┊  </BrowserRouter>\n ┊27┊27┊);\n```\n\n[}]: #\n\nBoth components act identically and thus there shall be no special treatment. Behold the new transition effect:\n\n![transition-demo](https://user-images.githubusercontent.com/7648874/54739398-ebb22400-4bf2-11e9-8d4c-2aeb65deeb92.gif)\n\nThe final screen will be composed out of 3 components:\n\n\n\n*   A navigation bar.\n*   A messages list.\n*   A message input.\n\nWe will create a new directory under the path `public/assets` and inside we will download and place a couple of assets which are necessary for our view:\n\n*   [chat-background.jpg](https://raw.githubusercontent.com/Urigo/WhatsApp-Clone-Client-Angular/master/src/assets/chat-background.jpg)\n*   [message-mine.png](https://raw.githubusercontent.com/Urigo/WhatsApp-Clone-Client-Angular/master/src/assets/message-mine.png)\n\nIn the main `index.ts` file of the screen we will simply import all 3 in the right order.\nWe will start with the most simple one - the `ChatRoomNavbar`.\nThe navbar should show the picture of the chat we're currently at and its name,\nalong with a back button that will bring us back to the `ChatsListScreen`:\n\n[{]: <helper> (diffStep 6.6 files=\"ChatNavbar\" module=\"client\")\n\n#### [__Client__ Step 6.6: Implement ChatRoomScreen components](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/50b24db)\n\n##### Added src&#x2F;components&#x2F;ChatRoomScreen&#x2F;ChatNavbar.tsx\n```diff\n@@ -0,0 +1,59 @@\n+┊  ┊ 1┊import Button from '@material-ui/core/Button';\n+┊  ┊ 2┊import Toolbar from '@material-ui/core/Toolbar';\n+┊  ┊ 3┊import ArrowBackIcon from '@material-ui/icons/ArrowBack';\n+┊  ┊ 4┊import React from 'react';\n+┊  ┊ 5┊import { useCallback } from 'react';\n+┊  ┊ 6┊import styled from 'styled-components';\n+┊  ┊ 7┊import { History } from 'history';\n+┊  ┊ 8┊import { ChatQueryResult } from './index';\n+┊  ┊ 9┊\n+┊  ┊10┊const Container = styled(Toolbar)`\n+┊  ┊11┊  padding: 0;\n+┊  ┊12┊  display: flex;\n+┊  ┊13┊  flex-direction: row;\n+┊  ┊14┊  background-color: var(--primary-bg);\n+┊  ┊15┊  color: var(--primary-text);\n+┊  ┊16┊` as typeof Toolbar;\n+┊  ┊17┊\n+┊  ┊18┊const BackButton = styled(Button)`\n+┊  ┊19┊  svg {\n+┊  ┊20┊    color: var(--primary-text);\n+┊  ┊21┊  }\n+┊  ┊22┊` as typeof Button;\n+┊  ┊23┊\n+┊  ┊24┊const Picture = styled.img`\n+┊  ┊25┊  height: 40px;\n+┊  ┊26┊  width: 40px;\n+┊  ┊27┊  margin-top: 3px;\n+┊  ┊28┊  margin-left: -22px;\n+┊  ┊29┊  object-fit: cover;\n+┊  ┊30┊  padding: 5px;\n+┊  ┊31┊  border-radius: 50%;\n+┊  ┊32┊`;\n+┊  ┊33┊\n+┊  ┊34┊const Name = styled.div`\n+┊  ┊35┊  line-height: 56px;\n+┊  ┊36┊`;\n+┊  ┊37┊\n+┊  ┊38┊interface ChatNavbarProps {\n+┊  ┊39┊  history: History;\n+┊  ┊40┊  chat: ChatQueryResult;\n+┊  ┊41┊}\n+┊  ┊42┊\n+┊  ┊43┊const ChatNavbar: React.FC<ChatNavbarProps> = ({ chat, history }) => {\n+┊  ┊44┊  const navBack = useCallback(() => {\n+┊  ┊45┊    history.replace('/chats');\n+┊  ┊46┊  }, [history]);\n+┊  ┊47┊\n+┊  ┊48┊  return (\n+┊  ┊49┊    <Container>\n+┊  ┊50┊      <BackButton onClick={navBack}>\n+┊  ┊51┊        <ArrowBackIcon />\n+┊  ┊52┊      </BackButton>\n+┊  ┊53┊      <Picture src={chat.picture} />\n+┊  ┊54┊      <Name>{chat.name}</Name>\n+┊  ┊55┊    </Container>\n+┊  ┊56┊  );\n+┊  ┊57┊};\n+┊  ┊58┊\n+┊  ┊59┊export default ChatNavbar;\n```\n\n[}]: #\n\nNext, would be the `MesagesList` component, where we will see a scrollable list of all the messages of the active chat:\n\n[{]: <helper> (diffStep 6.6 files=\"MessagesList\" module=\"client\")\n\n#### [__Client__ Step 6.6: Implement ChatRoomScreen components](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/50b24db)\n\n##### Added src&#x2F;components&#x2F;ChatRoomScreen&#x2F;MessagesList.tsx\n```diff\n@@ -0,0 +1,78 @@\n+┊  ┊ 1┊import moment from 'moment';\n+┊  ┊ 2┊import React from 'react';\n+┊  ┊ 3┊import styled from 'styled-components';\n+┊  ┊ 4┊import { ChatQueryMessage } from './index';\n+┊  ┊ 5┊\n+┊  ┊ 6┊const Container = styled.div`\n+┊  ┊ 7┊  display: block;\n+┊  ┊ 8┊  flex: 2;\n+┊  ┊ 9┊  overflow-y: overlay;\n+┊  ┊10┊  padding: 0 15px;\n+┊  ┊11┊`;\n+┊  ┊12┊\n+┊  ┊13┊const MessageItem = styled.div`\n+┊  ┊14┊  float: right;\n+┊  ┊15┊  background-color: #dcf8c6;\n+┊  ┊16┊  display: inline-block;\n+┊  ┊17┊  position: relative;\n+┊  ┊18┊  max-width: 100%;\n+┊  ┊19┊  border-radius: 7px;\n+┊  ┊20┊  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.15);\n+┊  ┊21┊  margin-top: 10px;\n+┊  ┊22┊  margin-bottom: 10px;\n+┊  ┊23┊  clear: both;\n+┊  ┊24┊\n+┊  ┊25┊  &::after {\n+┊  ┊26┊    content: '';\n+┊  ┊27┊    display: table;\n+┊  ┊28┊    clear: both;\n+┊  ┊29┊  }\n+┊  ┊30┊\n+┊  ┊31┊  &::before {\n+┊  ┊32┊    background-image: url(/assets/message-mine.png);\n+┊  ┊33┊    content: '';\n+┊  ┊34┊    position: absolute;\n+┊  ┊35┊    bottom: 3px;\n+┊  ┊36┊    width: 12px;\n+┊  ┊37┊    height: 19px;\n+┊  ┊38┊    right: -11px;\n+┊  ┊39┊    background-position: 50% 50%;\n+┊  ┊40┊    background-repeat: no-repeat;\n+┊  ┊41┊    background-size: contain;\n+┊  ┊42┊  }\n+┊  ┊43┊`;\n+┊  ┊44┊\n+┊  ┊45┊const Contents = styled.div`\n+┊  ┊46┊  padding: 5px 7px;\n+┊  ┊47┊  word-wrap: break-word;\n+┊  ┊48┊\n+┊  ┊49┊  &::after {\n+┊  ┊50┊    content: ' \\\\00a0\\\\00a0\\\\00a0\\\\00a0\\\\00a0\\\\00a0\\\\00a0\\\\00a0\\\\00a0\\\\00a0\\\\00a0\\\\00a0\\\\00a0\\\\00a0\\\\00a0\\\\00a0\\\\00a0\\\\00a0\\\\00a0';\n+┊  ┊51┊    display: inline;\n+┊  ┊52┊  }\n+┊  ┊53┊`;\n+┊  ┊54┊\n+┊  ┊55┊const Timestamp = styled.div`\n+┊  ┊56┊  position: absolute;\n+┊  ┊57┊  bottom: 2px;\n+┊  ┊58┊  right: 7px;\n+┊  ┊59┊  color: gray;\n+┊  ┊60┊  font-size: 12px;\n+┊  ┊61┊`;\n+┊  ┊62┊\n+┊  ┊63┊interface MessagesListProps {\n+┊  ┊64┊  messages: Array<ChatQueryMessage>;\n+┊  ┊65┊}\n+┊  ┊66┊\n+┊  ┊67┊const MessagesList: React.FC<MessagesListProps> = ({ messages }) => (\n+┊  ┊68┊  <Container>\n+┊  ┊69┊    {messages.map((message: any) => (\n+┊  ┊70┊      <MessageItem key={message.id}>\n+┊  ┊71┊        <Contents>{message.content}</Contents>\n+┊  ┊72┊        <Timestamp>{moment(message.createdAt).format('HH:mm')}</Timestamp>\n+┊  ┊73┊      </MessageItem>\n+┊  ┊74┊    ))}\n+┊  ┊75┊  </Container>\n+┊  ┊76┊);\n+┊  ┊77┊\n+┊  ┊78┊export default MessagesList;\n```\n\n[}]: #\n\nAnd finally, would be the `MessageInput` component which will trigger an event whenever we type and submit a new message:\n\n[{]: <helper> (diffStep 6.6 files=\"MessageInput\" module=\"client\")\n\n#### [__Client__ Step 6.6: Implement ChatRoomScreen components](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/50b24db)\n\n##### Added src&#x2F;components&#x2F;ChatRoomScreen&#x2F;MessageInput.tsx\n```diff\n@@ -0,0 +1,53 @@\n+┊  ┊ 1┊import Button from '@material-ui/core/Button';\n+┊  ┊ 2┊import SendIcon from '@material-ui/icons/Send';\n+┊  ┊ 3┊import React from 'react';\n+┊  ┊ 4┊import styled from 'styled-components';\n+┊  ┊ 5┊\n+┊  ┊ 6┊const Container = styled.div`\n+┊  ┊ 7┊  display: flex;\n+┊  ┊ 8┊  height: 50px;\n+┊  ┊ 9┊  padding: 5px;\n+┊  ┊10┊  width: calc(100% - 10px);\n+┊  ┊11┊`;\n+┊  ┊12┊\n+┊  ┊13┊const ActualInput = styled.input`\n+┊  ┊14┊  width: calc(100% - 50px);\n+┊  ┊15┊  border: none;\n+┊  ┊16┊  border-radius: 999px;\n+┊  ┊17┊  padding: 10px;\n+┊  ┊18┊  padding-left: 20px;\n+┊  ┊19┊  padding-right: 20px;\n+┊  ┊20┊  font-size: 15px;\n+┊  ┊21┊  outline: none;\n+┊  ┊22┊  box-shadow: 0 1px silver;\n+┊  ┊23┊  font-size: 18px;\n+┊  ┊24┊  line-height: 45px;\n+┊  ┊25┊`;\n+┊  ┊26┊\n+┊  ┊27┊const SendButton = styled(Button)`\n+┊  ┊28┊  min-width: 50px !important;\n+┊  ┊29┊  width: 50px !important;\n+┊  ┊30┊  border-radius: 999px !important;\n+┊  ┊31┊  background-color: var(--primary-bg) !important;\n+┊  ┊32┊  margin: 0 5px !important;\n+┊  ┊33┊  margin-right: 0 !important;\n+┊  ┊34┊  color: white !important;\n+┊  ┊35┊  padding-left: 20px !important;\n+┊  ┊36┊\n+┊  ┊37┊  svg {\n+┊  ┊38┊    margin-left: -3px;\n+┊  ┊39┊  }\n+┊  ┊40┊` as typeof Button;\n+┊  ┊41┊\n+┊  ┊42┊const MessageInput: React.FC = () => {\n+┊  ┊43┊  return (\n+┊  ┊44┊    <Container>\n+┊  ┊45┊      <ActualInput type=\"text\" placeholder=\"Type a message\" />\n+┊  ┊46┊      <SendButton variant=\"contained\" color=\"primary\">\n+┊  ┊47┊        <SendIcon />\n+┊  ┊48┊      </SendButton>\n+┊  ┊49┊    </Container>\n+┊  ┊50┊  );\n+┊  ┊51┊};\n+┊  ┊52┊\n+┊  ┊53┊export default MessageInput;\n```\n\n[}]: #\n\nNow that we have all 3 components, we will put them all together in the main `index.ts` file:\n\n[{]: <helper> (diffStep 6.6 files=\"index\" module=\"client\")\n\n#### [__Client__ Step 6.6: Implement ChatRoomScreen components](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/50b24db)\n\n##### Changed src&#x2F;components&#x2F;ChatRoomScreen&#x2F;index.tsx\n```diff\n@@ -1,5 +1,17 @@\n ┊ 1┊ 1┊import React from 'react';\n ┊ 2┊ 2┊import { useMemo, useState } from 'react';\n+┊  ┊ 3┊import styled from 'styled-components';\n+┊  ┊ 4┊import ChatNavbar from './ChatNavbar';\n+┊  ┊ 5┊import MessageInput from './MessageInput';\n+┊  ┊ 6┊import MessagesList from './MessagesList';\n+┊  ┊ 7┊import { History } from 'history';\n+┊  ┊ 8┊\n+┊  ┊ 9┊const Container = styled.div`\n+┊  ┊10┊  background: url(/assets/chat-background.jpg);\n+┊  ┊11┊  display: flex;\n+┊  ┊12┊  flex-flow: column;\n+┊  ┊13┊  height: 100vh;\n+┊  ┊14┊`;\n ┊ 3┊15┊\n ┊ 4┊16┊const getChatQuery = `\n ┊ 5┊17┊  query GetChat($chatId: ID!) {\n```\n```diff\n@@ -18,15 +30,16 @@\n ┊18┊30┊\n ┊19┊31┊interface ChatRoomScreenParams {\n ┊20┊32┊  chatId: string;\n+┊  ┊33┊  history: History;\n ┊21┊34┊}\n ┊22┊35┊\n-┊23┊  ┊interface ChatQueryMessage {\n+┊  ┊36┊export interface ChatQueryMessage {\n ┊24┊37┊  id: string;\n ┊25┊38┊  content: string;\n ┊26┊39┊  createdAt: string;\n ┊27┊40┊}\n ┊28┊41┊\n-┊29┊  ┊interface ChatQueryResult {\n+┊  ┊42┊export interface ChatQueryResult {\n ┊30┊43┊  id: string;\n ┊31┊44┊  name: string;\n ┊32┊45┊  picture: string;\n```\n```diff\n@@ -35,7 +48,10 @@\n ┊35┊48┊\n ┊36┊49┊type OptionalChatQueryResult = ChatQueryResult | null;\n ┊37┊50┊\n-┊38┊  ┊const ChatRoomScreen: React.FC<ChatRoomScreenParams> = ({ chatId }) => {\n+┊  ┊51┊const ChatRoomScreen: React.FC<ChatRoomScreenParams> = ({\n+┊  ┊52┊  history,\n+┊  ┊53┊  chatId,\n+┊  ┊54┊}) => {\n ┊39┊55┊  const [chat, setChat] = useState<OptionalChatQueryResult>(null);\n ┊40┊56┊\n ┊41┊57┊  useMemo(async () => {\n```\n```diff\n@@ -58,18 +74,11 @@\n ┊58┊74┊  if (!chat) return null;\n ┊59┊75┊\n ┊60┊76┊  return (\n-┊61┊  ┊    <div>\n-┊62┊  ┊      <img src={chat.picture} alt=\"Profile\" />\n-┊63┊  ┊      <div>{chat.name}</div>\n-┊64┊  ┊      <ul>\n-┊65┊  ┊        {chat.messages.map(message => (\n-┊66┊  ┊          <li key={message.id}>\n-┊67┊  ┊            <div>{message.content}</div>\n-┊68┊  ┊            <div>{message.createdAt}</div>\n-┊69┊  ┊          </li>\n-┊70┊  ┊        ))}\n-┊71┊  ┊      </ul>\n-┊72┊  ┊    </div>\n+┊  ┊77┊    <Container>\n+┊  ┊78┊      <ChatNavbar chat={chat} history={history} />\n+┊  ┊79┊      {chat.messages && <MessagesList messages={chat.messages} />}\n+┊  ┊80┊      <MessageInput />\n+┊  ┊81┊    </Container>\n ┊73┊82┊  );\n ┊74┊83┊};\n```\n\n[}]: #\n\nThe view is complete! However the `MessageInput` is not bound to our messages list.\nWe will use the triggered callback to update the chat state, whose changes should appear in the `MessagesList` component in the following render phase:\n\n[{]: <helper> (diffStep 6.7 module=\"client\")\n\n#### [__Client__ Step 6.7: Define onSendMessage callback](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/60a2ad4)\n\n##### Changed src&#x2F;components&#x2F;ChatRoomScreen&#x2F;MessageInput.tsx\n```diff\n@@ -2,6 +2,7 @@\n ┊2┊2┊import SendIcon from '@material-ui/icons/Send';\n ┊3┊3┊import React from 'react';\n ┊4┊4┊import styled from 'styled-components';\n+┊ ┊5┊import { useState } from 'react';\n ┊5┊6┊\n ┊6┊7┊const Container = styled.div`\n ┊7┊8┊  display: flex;\n```\n```diff\n@@ -39,11 +40,43 @@\n ┊39┊40┊  }\n ┊40┊41┊` as typeof Button;\n ┊41┊42┊\n-┊42┊  ┊const MessageInput: React.FC = () => {\n+┊  ┊43┊interface MessageInputProps {\n+┊  ┊44┊  onSendMessage(content: string): any;\n+┊  ┊45┊}\n+┊  ┊46┊\n+┊  ┊47┊const MessageInput: React.FC<MessageInputProps> = ({ onSendMessage }) => {\n+┊  ┊48┊  const [message, setMessage] = useState('');\n+┊  ┊49┊\n+┊  ┊50┊  const onKeyPress = (e: any) => {\n+┊  ┊51┊    if (e.charCode === 13) {\n+┊  ┊52┊      submitMessage();\n+┊  ┊53┊    }\n+┊  ┊54┊  };\n+┊  ┊55┊\n+┊  ┊56┊  const onChange = ({ target }: any) => {\n+┊  ┊57┊    setMessage(target.value);\n+┊  ┊58┊  };\n+┊  ┊59┊\n+┊  ┊60┊  const submitMessage = () => {\n+┊  ┊61┊    if (!message) return;\n+┊  ┊62┊\n+┊  ┊63┊    setMessage('');\n+┊  ┊64┊\n+┊  ┊65┊    if (typeof onSendMessage === 'function') {\n+┊  ┊66┊      onSendMessage(message);\n+┊  ┊67┊    }\n+┊  ┊68┊  };\n+┊  ┊69┊\n ┊43┊70┊  return (\n ┊44┊71┊    <Container>\n-┊45┊  ┊      <ActualInput type=\"text\" placeholder=\"Type a message\" />\n-┊46┊  ┊      <SendButton variant=\"contained\" color=\"primary\">\n+┊  ┊72┊      <ActualInput\n+┊  ┊73┊        type=\"text\"\n+┊  ┊74┊        placeholder=\"Type a message\"\n+┊  ┊75┊        value={message}\n+┊  ┊76┊        onKeyPress={onKeyPress}\n+┊  ┊77┊        onChange={onChange}\n+┊  ┊78┊      />\n+┊  ┊79┊      <SendButton variant=\"contained\" color=\"primary\" onClick={submitMessage}>\n ┊47┊80┊        <SendIcon />\n ┊48┊81┊      </SendButton>\n ┊49┊82┊    </Container>\n```\n\n##### Changed src&#x2F;components&#x2F;ChatRoomScreen&#x2F;index.tsx\n```diff\n@@ -1,5 +1,5 @@\n ┊1┊1┊import React from 'react';\n-┊2┊ ┊import { useMemo, useState } from 'react';\n+┊ ┊2┊import { useCallback, useMemo, useState } from 'react';\n ┊3┊3┊import styled from 'styled-components';\n ┊4┊4┊import ChatNavbar from './ChatNavbar';\n ┊5┊5┊import MessageInput from './MessageInput';\n```\n```diff\n@@ -36,7 +36,7 @@\n ┊36┊36┊export interface ChatQueryMessage {\n ┊37┊37┊  id: string;\n ┊38┊38┊  content: string;\n-┊39┊  ┊  createdAt: string;\n+┊  ┊39┊  createdAt: number;\n ┊40┊40┊}\n ┊41┊41┊\n ┊42┊42┊export interface ChatQueryResult {\n```\n```diff\n@@ -71,13 +71,33 @@\n ┊ 71┊ 71┊    setChat(chat);\n ┊ 72┊ 72┊  }, [chatId]);\n ┊ 73┊ 73┊\n+┊   ┊ 74┊  const onSendMessage = useCallback(\n+┊   ┊ 75┊    (content: string) => {\n+┊   ┊ 76┊      if (!chat) return null;\n+┊   ┊ 77┊\n+┊   ┊ 78┊      const message = {\n+┊   ┊ 79┊        id: (chat.messages.length + 10).toString(),\n+┊   ┊ 80┊        createdAt: Date.now(),\n+┊   ┊ 81┊        content,\n+┊   ┊ 82┊      };\n+┊   ┊ 83┊\n+┊   ┊ 84┊      console.log(chat.messages);\n+┊   ┊ 85┊\n+┊   ┊ 86┊      setChat({\n+┊   ┊ 87┊        ...chat,\n+┊   ┊ 88┊        messages: chat.messages.concat(message),\n+┊   ┊ 89┊      });\n+┊   ┊ 90┊    },\n+┊   ┊ 91┊    [chat]\n+┊   ┊ 92┊  );\n+┊   ┊ 93┊\n ┊ 74┊ 94┊  if (!chat) return null;\n ┊ 75┊ 95┊\n ┊ 76┊ 96┊  return (\n ┊ 77┊ 97┊    <Container>\n ┊ 78┊ 98┊      <ChatNavbar chat={chat} history={history} />\n ┊ 79┊ 99┊      {chat.messages && <MessagesList messages={chat.messages} />}\n-┊ 80┊   ┊      <MessageInput />\n+┊   ┊100┊      <MessageInput onSendMessage={onSendMessage} />\n ┊ 81┊101┊    </Container>\n ┊ 82┊102┊  );\n ┊ 83┊103┊};\n```\n\n[}]: #\n\nThis is how the entire flow should look like:\n\n![flow-demo](https://user-images.githubusercontent.com/7648874/54739741-27012280-4bf4-11e9-97cb-c715482e2e70.gif)\n\nAn edge case that should be taken care of is when the messages list length in the view exceeds the length of the container,\nin which case we will have to scroll down to the bottom of the view.\nThis way we can keep track of the most recent message.\nWe will use `ReactDOM` to retrieve the native HTML element of the container and change the position of the scroller whenever a messages was sent:\n\n[{]: <helper> (diffStep 6.8 module=\"client\")\n\n#### [__Client__ Step 6.8: Reset scroller on message sent](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/18f9eaf)\n\n##### Changed src&#x2F;components&#x2F;ChatRoomScreen&#x2F;MessagesList.tsx\n```diff\n@@ -1,5 +1,7 @@\n ┊1┊1┊import moment from 'moment';\n ┊2┊2┊import React from 'react';\n+┊ ┊3┊import { useEffect, useRef } from 'react';\n+┊ ┊4┊import ReactDOM from 'react-dom';\n ┊3┊5┊import styled from 'styled-components';\n ┊4┊6┊import { ChatQueryMessage } from './index';\n ┊5┊7┊\n```\n```diff\n@@ -64,15 +66,26 @@\n ┊64┊66┊  messages: Array<ChatQueryMessage>;\n ┊65┊67┊}\n ┊66┊68┊\n-┊67┊  ┊const MessagesList: React.FC<MessagesListProps> = ({ messages }) => (\n-┊68┊  ┊  <Container>\n-┊69┊  ┊    {messages.map((message: any) => (\n-┊70┊  ┊      <MessageItem key={message.id}>\n-┊71┊  ┊        <Contents>{message.content}</Contents>\n-┊72┊  ┊        <Timestamp>{moment(message.createdAt).format('HH:mm')}</Timestamp>\n-┊73┊  ┊      </MessageItem>\n-┊74┊  ┊    ))}\n-┊75┊  ┊  </Container>\n-┊76┊  ┊);\n+┊  ┊69┊const MessagesList: React.FC<MessagesListProps> = ({ messages }) => {\n+┊  ┊70┊  const selfRef = useRef(null);\n+┊  ┊71┊\n+┊  ┊72┊  useEffect(() => {\n+┊  ┊73┊    if (!selfRef.current) return;\n+┊  ┊74┊\n+┊  ┊75┊    const selfDOMNode = ReactDOM.findDOMNode(selfRef.current) as HTMLElement;\n+┊  ┊76┊    selfDOMNode.scrollTop = Number.MAX_SAFE_INTEGER;\n+┊  ┊77┊  }, [messages.length]);\n+┊  ┊78┊\n+┊  ┊79┊  return (\n+┊  ┊80┊    <Container ref={selfRef}>\n+┊  ┊81┊      {messages.map((message: any) => (\n+┊  ┊82┊        <MessageItem key={message.id}>\n+┊  ┊83┊          <Contents>{message.content}</Contents>\n+┊  ┊84┊          <Timestamp>{moment(message.createdAt).format('HH:mm')}</Timestamp>\n+┊  ┊85┊        </MessageItem>\n+┊  ┊86┊      ))}\n+┊  ┊87┊    </Container>\n+┊  ┊88┊  );\n+┊  ┊89┊};\n ┊77┊90┊\n ┊78┊91┊export default MessagesList;\n```\n\n[}]: #\n\nBefore we wrap things up, we should also test our components.\nSince the new components have a direct control over the app's history,\nwe should also find a way to simulate it in our tests.\nBecause `react-dom-router` uses the [`history`](https://www.npmjs.com/package/history) package under the hood,\nthat means that we can use that package to inject a custom history object directly into the tested components:\n\n[{]: <helper> (diffStep 6.9 files=\"components\" module=\"client\")\n\n#### [__Client__ Step 6.9: Test ChatRoomScreen child components](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/0e8e7cf)\n\n##### Added src&#x2F;components&#x2F;ChatRoomScreen&#x2F;ChatNavbar.test.tsx\n```diff\n@@ -0,0 +1,50 @@\n+┊  ┊ 1┊import { createMemoryHistory } from 'history';\n+┊  ┊ 2┊import React from 'react';\n+┊  ┊ 3┊import { cleanup, render, fireEvent, wait } from '@testing-library/react';\n+┊  ┊ 4┊import ChatNavbar from './ChatNavbar';\n+┊  ┊ 5┊\n+┊  ┊ 6┊describe('ChatNavbar', () => {\n+┊  ┊ 7┊  afterEach(cleanup);\n+┊  ┊ 8┊\n+┊  ┊ 9┊  it('renders chat data', () => {\n+┊  ┊10┊    const chat = {\n+┊  ┊11┊      id: '1',\n+┊  ┊12┊      name: 'Foo Bar',\n+┊  ┊13┊      picture: 'https://localhost:4000/picture.jpg',\n+┊  ┊14┊    };\n+┊  ┊15┊\n+┊  ┊16┊    {\n+┊  ┊17┊      const { container, getByTestId } = render(<ChatNavbar chat={chat} />);\n+┊  ┊18┊\n+┊  ┊19┊      expect(getByTestId('chat-name')).toHaveTextContent('Foo Bar');\n+┊  ┊20┊      expect(getByTestId('chat-picture')).toHaveAttribute(\n+┊  ┊21┊        'src',\n+┊  ┊22┊        'https://localhost:4000/picture.jpg'\n+┊  ┊23┊      );\n+┊  ┊24┊    }\n+┊  ┊25┊  });\n+┊  ┊26┊\n+┊  ┊27┊  it('goes back on arrow click', async () => {\n+┊  ┊28┊    const chat = {\n+┊  ┊29┊      id: '1',\n+┊  ┊30┊      name: 'Foo Bar',\n+┊  ┊31┊      picture: 'https://localhost:4000/picture.jpg',\n+┊  ┊32┊    };\n+┊  ┊33┊\n+┊  ┊34┊    const history = createMemoryHistory();\n+┊  ┊35┊\n+┊  ┊36┊    history.push('/chats/1');\n+┊  ┊37┊\n+┊  ┊38┊    await wait(() => expect(history.location.pathname).toEqual('/chats/1'));\n+┊  ┊39┊\n+┊  ┊40┊    {\n+┊  ┊41┊      const { container, getByTestId } = render(\n+┊  ┊42┊        <ChatNavbar chat={chat} history={history} />\n+┊  ┊43┊      );\n+┊  ┊44┊\n+┊  ┊45┊      fireEvent.click(getByTestId('back-button'));\n+┊  ┊46┊\n+┊  ┊47┊      await wait(() => expect(history.location.pathname).toEqual('/chats'));\n+┊  ┊48┊    }\n+┊  ┊49┊  });\n+┊  ┊50┊});\n```\n\n##### Changed src&#x2F;components&#x2F;ChatRoomScreen&#x2F;ChatNavbar.tsx\n```diff\n@@ -47,11 +47,11 @@\n ┊47┊47┊\n ┊48┊48┊  return (\n ┊49┊49┊    <Container>\n-┊50┊  ┊      <BackButton onClick={navBack}>\n+┊  ┊50┊      <BackButton data-testid=\"back-button\" onClick={navBack}>\n ┊51┊51┊        <ArrowBackIcon />\n ┊52┊52┊      </BackButton>\n-┊53┊  ┊      <Picture src={chat.picture} />\n-┊54┊  ┊      <Name>{chat.name}</Name>\n+┊  ┊53┊      <Picture data-testid=\"chat-picture\" src={chat.picture} />\n+┊  ┊54┊      <Name data-testid=\"chat-name\">{chat.name}</Name>\n ┊55┊55┊    </Container>\n ┊56┊56┊  );\n ┊57┊57┊};\n```\n\n##### Added src&#x2F;components&#x2F;ChatRoomScreen&#x2F;MessageInput.test.tsx\n```diff\n@@ -0,0 +1,57 @@\n+┊  ┊ 1┊import { createMemoryHistory } from 'history';\n+┊  ┊ 2┊import React from 'react';\n+┊  ┊ 3┊import {\n+┊  ┊ 4┊  cleanup,\n+┊  ┊ 5┊  render,\n+┊  ┊ 6┊  fireEvent,\n+┊  ┊ 7┊  wait,\n+┊  ┊ 8┊  waitForElement,\n+┊  ┊ 9┊} from '@testing-library/react';\n+┊  ┊10┊import MessageInput from './MessageInput';\n+┊  ┊11┊\n+┊  ┊12┊describe('MessageInput;', () => {\n+┊  ┊13┊  afterEach(cleanup);\n+┊  ┊14┊\n+┊  ┊15┊  it('triggers callback on send button click', async () => {\n+┊  ┊16┊    const onSendMessage = jest.fn(() => {});\n+┊  ┊17┊\n+┊  ┊18┊    {\n+┊  ┊19┊      const { container, getByTestId } = render(\n+┊  ┊20┊        <MessageInput onSendMessage={onSendMessage} />\n+┊  ┊21┊      );\n+┊  ┊22┊      const messageInput = getByTestId('message-input');\n+┊  ┊23┊      const sendButton = getByTestId('send-button');\n+┊  ┊24┊\n+┊  ┊25┊      fireEvent.change(messageInput, { target: { value: 'foo' } });\n+┊  ┊26┊\n+┊  ┊27┊      await waitForElement(() => messageInput);\n+┊  ┊28┊\n+┊  ┊29┊      fireEvent.click(sendButton);\n+┊  ┊30┊\n+┊  ┊31┊      await wait(() => expect(onSendMessage.mock.calls.length).toBe(1));\n+┊  ┊32┊    }\n+┊  ┊33┊  });\n+┊  ┊34┊\n+┊  ┊35┊  it('triggers callback on Enter press', async () => {\n+┊  ┊36┊    const onSendMessage = jest.fn(() => {});\n+┊  ┊37┊\n+┊  ┊38┊    {\n+┊  ┊39┊      const { container, getByTestId } = render(\n+┊  ┊40┊        <MessageInput onSendMessage={onSendMessage} />\n+┊  ┊41┊      );\n+┊  ┊42┊      const messageInput = getByTestId('message-input');\n+┊  ┊43┊\n+┊  ┊44┊      fireEvent.change(messageInput, { target: { value: 'foo' } });\n+┊  ┊45┊\n+┊  ┊46┊      await waitForElement(() => messageInput);\n+┊  ┊47┊\n+┊  ┊48┊      fireEvent.keyPress(messageInput, {\n+┊  ┊49┊        key: 'Enter',\n+┊  ┊50┊        code: 13,\n+┊  ┊51┊        charCode: 13,\n+┊  ┊52┊      });\n+┊  ┊53┊\n+┊  ┊54┊      await wait(() => expect(onSendMessage.mock.calls.length).toBe(1));\n+┊  ┊55┊    }\n+┊  ┊56┊  });\n+┊  ┊57┊});\n```\n\n##### Changed src&#x2F;components&#x2F;ChatRoomScreen&#x2F;MessageInput.tsx\n```diff\n@@ -70,13 +70,18 @@\n ┊70┊70┊  return (\n ┊71┊71┊    <Container>\n ┊72┊72┊      <ActualInput\n+┊  ┊73┊        data-testid=\"message-input\"\n ┊73┊74┊        type=\"text\"\n ┊74┊75┊        placeholder=\"Type a message\"\n ┊75┊76┊        value={message}\n ┊76┊77┊        onKeyPress={onKeyPress}\n ┊77┊78┊        onChange={onChange}\n ┊78┊79┊      />\n-┊79┊  ┊      <SendButton variant=\"contained\" color=\"primary\" onClick={submitMessage}>\n+┊  ┊80┊      <SendButton\n+┊  ┊81┊        data-testid=\"send-button\"\n+┊  ┊82┊        variant=\"contained\"\n+┊  ┊83┊        color=\"primary\"\n+┊  ┊84┊        onClick={submitMessage}>\n ┊80┊85┊        <SendIcon />\n ┊81┊86┊      </SendButton>\n ┊82┊87┊    </Container>\n```\n\n##### Added src&#x2F;components&#x2F;ChatRoomScreen&#x2F;MessagesList.test.tsx\n```diff\n@@ -0,0 +1,47 @@\n+┊  ┊ 1┊import { createMemoryHistory } from 'history';\n+┊  ┊ 2┊import React from 'react';\n+┊  ┊ 3┊import {\n+┊  ┊ 4┊  cleanup,\n+┊  ┊ 5┊  render,\n+┊  ┊ 6┊  fireEvent,\n+┊  ┊ 7┊  wait,\n+┊  ┊ 8┊  getByTestId,\n+┊  ┊ 9┊} from '@testing-library/react';\n+┊  ┊10┊import MessagesList from './MessagesList';\n+┊  ┊11┊\n+┊  ┊12┊describe('MessagesList', () => {\n+┊  ┊13┊  afterEach(cleanup);\n+┊  ┊14┊\n+┊  ┊15┊  const time = new Date('1 Jan 2019 GMT');\n+┊  ┊16┊\n+┊  ┊17┊  it('renders messages data', () => {\n+┊  ┊18┊    const messages = [\n+┊  ┊19┊      {\n+┊  ┊20┊        id: '1',\n+┊  ┊21┊        content: 'foo',\n+┊  ┊22┊        createdAt: time,\n+┊  ┊23┊      },\n+┊  ┊24┊      {\n+┊  ┊25┊        id: '2',\n+┊  ┊26┊        content: 'bar',\n+┊  ┊27┊        createdAt: time,\n+┊  ┊28┊      },\n+┊  ┊29┊    ];\n+┊  ┊30┊\n+┊  ┊31┊    let message1, message2;\n+┊  ┊32┊    {\n+┊  ┊33┊      const { container, getAllByTestId, getByTestId } = render(\n+┊  ┊34┊        <MessagesList messages={messages} />\n+┊  ┊35┊      );\n+┊  ┊36┊      const match = getAllByTestId('message-item');\n+┊  ┊37┊      message1 = match[0];\n+┊  ┊38┊      message2 = match[1];\n+┊  ┊39┊    }\n+┊  ┊40┊\n+┊  ┊41┊    expect(getByTestId(message1, 'message-content')).toHaveTextContent('foo');\n+┊  ┊42┊    expect(getByTestId(message1, 'message-date')).toHaveTextContent('02:00');\n+┊  ┊43┊\n+┊  ┊44┊    expect(getByTestId(message2, 'message-content')).toHaveTextContent('bar');\n+┊  ┊45┊    expect(getByTestId(message2, 'message-date')).toHaveTextContent('02:00');\n+┊  ┊46┊  });\n+┊  ┊47┊});\n```\n\n##### Changed src&#x2F;components&#x2F;ChatRoomScreen&#x2F;MessagesList.tsx\n```diff\n@@ -79,9 +79,11 @@\n ┊79┊79┊  return (\n ┊80┊80┊    <Container ref={selfRef}>\n ┊81┊81┊      {messages.map((message: any) => (\n-┊82┊  ┊        <MessageItem key={message.id}>\n-┊83┊  ┊          <Contents>{message.content}</Contents>\n-┊84┊  ┊          <Timestamp>{moment(message.createdAt).format('HH:mm')}</Timestamp>\n+┊  ┊82┊        <MessageItem data-testid=\"message-item\" key={message.id}>\n+┊  ┊83┊          <Contents data-testid=\"message-content\">{message.content}</Contents>\n+┊  ┊84┊          <Timestamp data-testid=\"message-date\">\n+┊  ┊85┊            {moment(message.createdAt).format('HH:mm')}\n+┊  ┊86┊          </Timestamp>\n ┊85┊87┊        </MessageItem>\n ┊86┊88┊      ))}\n ┊87┊89┊    </Container>\n```\n\n[}]: #\n\nThere are many things which are incomplete in the current implementation. The functionality exists in the UI, but no messages are really being sent and stored in the database. In the next chapters we will learn how to:\n\n\n\n*   Cache query results with Apollo-Client.\n*   Send messages with GraphQL mutations\n\n--------\nTODO: Add this to router chapter - https://www.pluralsight.com/guides/react-router-typescript\nAnd this - https://stackoverflow.com/questions/49342390/typescript-how-to-add-type-check-for-history-object-in-react\n\nTODO: https://medium.com/@jrwebdev/react-higher-order-component-patterns-in-typescript-42278f7590fb\n\nTODO: https://www.cypress.io/blog/2019/05/13/code-create-react-app-v3-and-its-cypress-tests-using-typescript/#\n\nTODO: Schema says there’s always an array with messages, is it really true? Is newly created chat resolves an empty array, null will throw an error?\n\nTODO: Same thing with `chats: [Chat!]!`, do we always return an array here?\n\nTODO: _root and type all resolvers\n\nTODO: How to import schema together with jest, should I changed from ts-jest?\n\nTODO: remove all that part including the file in the commit\n\nTODO: Add all the new files and changes on 6.6\n\nTODO: Add all the new files and changes on 6.7"
          },
          {
            "manualTitle": "Step 7: Caching with Apollo-Client",
            "stepRevision": "b599329325bb6cfcb1ce509670e2d8185ca4e366",
            "manualView": "In the previous step we've implemented a `ChatRoomScreen` where we were able to view each chat's messages list by clicking on a chat item from the main screen.\nIt all looks functional, however, there's a significant optimization issue - each time we navigate into a `ChatRoomScreen`,\nwe need to re-fetch the data related to the target chat.\n\nThe solution for that would be [caching](https://en.wikipedia.org/wiki/Cache_(computing)) the fetch result,\nso it can be re-used once we re-enter a screen that we've visited before.\nFor now things are fairly simple so the caching mechanism can be implemented manually,\nbut things are gonna get tougher when we add more queries or things like message sending and profile updating to the mix,\nso it's not gonna be an easy task.\n\nLuckily, in the Apollo team they've invented a solution that works right out of the box and integrates perfectly with Apollo-GraphQL server - [Apollo-GraphQL client](https://www.apollographql.com/docs/link/#apollo-client).\n\n\n![caching](https://user-images.githubusercontent.com/7648874/54871150-f505e100-4dea-11e9-9e2d-439fbf3eaebe.png)\n\n\n\nApollo-Client is a wrap around our GraphQL endpoint which essentially uses HTTP requests (and further on [web-sockets](https://en.wikipedia.org/wiki/WebSocket), but we will get there), something that we've implemented manually so far.\nNot only it can be used to fetch data, but it will also cache the result of the query so it can be seamlessly re-used when we request the same data.\nThis means that we will need to setup an Apollo-Client and replace all our `fetch()` calls with `client.query()` call.\nMore about Apollo-Client's API further in this tutorial, but let's start configuring it.\nFirst we will install few essential NPM packages:\n\n    $ yarn add apollo-client apollo-cache-inmemory apollo-link apollo-link-http\n\n\n\n*   [`apollo-client`](https://www.npmjs.com/package/apollo-client) - Apollo-Client's core package, as we explained earlier.\n*   [`apollo-cache-inmemory`](https://www.npmjs.com/package/apollo-cache-inmemory) - The data store that will be used to cache the results.\n*   [`apollo-link-http`](https://www.npmjs.com/package/apollo-link-http) - Get GraphQL results over a network using HTTP fetch.\n\nWe will create a new file in the `src` directory called `client.ts` and inside we will export the client:\n\n[{]: <helper> (diffStep 7.1 files=\"client\" module=\"client\")\n\n#### [__Client__ Step 7.1: Add Apollo client](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/29bb028)\n\n##### Added src&#x2F;client.ts\n```diff\n@@ -0,0 +1,16 @@\n+┊  ┊ 1┊import { InMemoryCache } from 'apollo-cache-inmemory';\n+┊  ┊ 2┊import { ApolloClient } from 'apollo-client';\n+┊  ┊ 3┊import { HttpLink } from 'apollo-link-http';\n+┊  ┊ 4┊\n+┊  ┊ 5┊const httpUri = process.env.REACT_APP_SERVER_URL + '/graphql';\n+┊  ┊ 6┊\n+┊  ┊ 7┊const httpLink = new HttpLink({\n+┊  ┊ 8┊  uri: httpUri,\n+┊  ┊ 9┊});\n+┊  ┊10┊\n+┊  ┊11┊const inMemoryCache = new InMemoryCache();\n+┊  ┊12┊\n+┊  ┊13┊export default new ApolloClient({\n+┊  ┊14┊  link: httpLink,\n+┊  ┊15┊  cache: inMemoryCache,\n+┊  ┊16┊});\n```\n\n[}]: #\n\nAlthough the client can be used directly and integrated into any UI framework, it would be the most comfortable to use a wrap around it which is suitable for React.\nFor that we will use a package called [`react-apollo-hooks`](https://www.npmjs.com/package/react-apollo-hooks) which includes a set of [React hooks](https://reactjs.org/docs/hooks-intro.html) that can connect between our Apollo-Client and target React.Component:\n\n    $ yarn add react-apollo-hooks graphql-tag graphql\n\nWith `react-apollo-hooks` we can use the `useQuery()` hook to fetch data from our GraphQL API.\nThe `graphql-tag` package is used to parse the GraphQL string to an [AST](https://en.wikipedia.org/wiki/Abstract_syntax_tree), something which is required when using Apollo Client. Example:\n\n\n```\nimport gql from 'graphql-tag';\nimport { useQuery } from 'react-apollo-hooks';\n\nconst GET_DOGS = gql`\n  {\n    dogs {\n      id\n      breed\n    }\n  }\n`;\n\nconst Dogs = () => {\n  const { data, error, loading } = useQuery(GET_DOGS);\n  if (loading) {\n    return <div>Loading...</div>;\n  };\n  if (error) {\n    return <div>Error! {error.message}</div>;\n  };\n\n  return (\n    <ul>\n      {data.dogs.map(dog => (\n        <li key={dog.id}>{dog.breed}</li>\n      ))}\n    </ul>\n  );\n};\n```\n\n\nThe package requires a small setup so that imported hooks can use our Apollo-Client:\n\n[{]: <helper> (diffStep 7.2 files=\"index\" module=\"client\")\n\n#### [__Client__ Step 7.2: Provide Apollo client](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/c7ca633)\n\n##### Changed src&#x2F;components&#x2F;ChatRoomScreen&#x2F;index.tsx\n```diff\n@@ -81,8 +81,6 @@\n ┊81┊81┊        content,\n ┊82┊82┊      };\n ┊83┊83┊\n-┊84┊  ┊      console.log(chat.messages);\n-┊85┊  ┊\n ┊86┊84┊      setChat({\n ┊87┊85┊        ...chat,\n ┊88┊86┊        messages: chat.messages.concat(message),\n```\n\n##### Changed src&#x2F;index.tsx\n```diff\n@@ -1,8 +1,10 @@\n ┊ 1┊ 1┊import { MuiThemeProvider, createMuiTheme } from '@material-ui/core/styles';\n ┊ 2┊ 2┊import React from 'react';\n ┊ 3┊ 3┊import ReactDOM from 'react-dom';\n+┊  ┊ 4┊import { ApolloProvider } from 'react-apollo-hooks';\n ┊ 4┊ 5┊import './index.css';\n ┊ 5┊ 6┊import App from './App';\n+┊  ┊ 7┊import client from './client';\n ┊ 6┊ 8┊import * as serviceWorker from './serviceWorker';\n ┊ 7┊ 9┊\n ┊ 8┊10┊const theme = createMuiTheme({\n```\n```diff\n@@ -14,7 +16,9 @@\n ┊14┊16┊\n ┊15┊17┊ReactDOM.render(\n ┊16┊18┊  <MuiThemeProvider theme={theme}>\n-┊17┊  ┊    <App />\n+┊  ┊19┊    <ApolloProvider client={client}>\n+┊  ┊20┊      <App />\n+┊  ┊21┊    </ApolloProvider>\n ┊18┊22┊  </MuiThemeProvider>,\n ┊19┊23┊  document.getElementById('root')\n ┊20┊24┊);\n```\n\n[}]: #\n\nThe code above uses the [Context/Provider](https://reactjs.org/docs/context.html) API, thus the client is now known globally.\nNow that we can use the `useQuery()` hook, there's no need to use the native Fetch API anymore.\nLet's replace all our Fetch API call instances with a React hook:\n\n[{]: <helper> (diffStep 7.3 files=\"components\" module=\"client\")\n\n#### [__Client__ Step 7.3: Replace fetch() calls with Apollo useQuery()](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/a619587)\n\n##### Changed src&#x2F;components&#x2F;ChatRoomScreen&#x2F;index.tsx\n```diff\n@@ -1,5 +1,7 @@\n+┊ ┊1┊import gql from 'graphql-tag';\n ┊1┊2┊import React from 'react';\n-┊2┊ ┊import { useCallback, useMemo, useState } from 'react';\n+┊ ┊3┊import { useCallback } from 'react';\n+┊ ┊4┊import { useApolloClient, useQuery } from 'react-apollo-hooks';\n ┊3┊5┊import styled from 'styled-components';\n ┊4┊6┊import ChatNavbar from './ChatNavbar';\n ┊5┊7┊import MessageInput from './MessageInput';\n```\n```diff\n@@ -13,7 +15,7 @@\n ┊13┊15┊  height: 100vh;\n ┊14┊16┊`;\n ┊15┊17┊\n-┊16┊  ┊const getChatQuery = `\n+┊  ┊18┊const getChatQuery = gql`\n ┊17┊19┊  query GetChat($chatId: ID!) {\n ┊18┊20┊    chat(chatId: $chatId) {\n ┊19┊21┊      id\n```\n```diff\n@@ -52,24 +54,12 @@\n ┊52┊54┊  history,\n ┊53┊55┊  chatId,\n ┊54┊56┊}) => {\n-┊55┊  ┊  const [chat, setChat] = useState<OptionalChatQueryResult>(null);\n-┊56┊  ┊\n-┊57┊  ┊  useMemo(async () => {\n-┊58┊  ┊    const body = await fetch(`${process.env.REACT_APP_SERVER_URL}/graphql`, {\n-┊59┊  ┊      method: 'POST',\n-┊60┊  ┊      headers: {\n-┊61┊  ┊        'Content-Type': 'application/json',\n-┊62┊  ┊      },\n-┊63┊  ┊      body: JSON.stringify({\n-┊64┊  ┊        query: getChatQuery,\n-┊65┊  ┊        variables: { chatId },\n-┊66┊  ┊      }),\n-┊67┊  ┊    });\n-┊68┊  ┊    const {\n-┊69┊  ┊      data: { chat },\n-┊70┊  ┊    } = await body.json();\n-┊71┊  ┊    setChat(chat);\n-┊72┊  ┊  }, [chatId]);\n+┊  ┊57┊  const client = useApolloClient();\n+┊  ┊58┊  const {\n+┊  ┊59┊    data: { chat },\n+┊  ┊60┊  } = useQuery<any>(getChatQuery, {\n+┊  ┊61┊    variables: { chatId },\n+┊  ┊62┊  });\n ┊73┊63┊\n ┊74┊64┊  const onSendMessage = useCallback(\n ┊75┊65┊    (content: string) => {\n```\n```diff\n@@ -79,14 +69,21 @@\n ┊79┊69┊        id: (chat.messages.length + 10).toString(),\n ┊80┊70┊        createdAt: Date.now(),\n ┊81┊71┊        content,\n+┊  ┊72┊        __typename: 'Chat',\n ┊82┊73┊      };\n ┊83┊74┊\n-┊84┊  ┊      setChat({\n-┊85┊  ┊        ...chat,\n-┊86┊  ┊        messages: chat.messages.concat(message),\n+┊  ┊75┊      client.writeQuery({\n+┊  ┊76┊        query: getChatQuery,\n+┊  ┊77┊        variables: { chatId },\n+┊  ┊78┊        data: {\n+┊  ┊79┊          chat: {\n+┊  ┊80┊            ...chat,\n+┊  ┊81┊            messages: chat.messages.concat(message),\n+┊  ┊82┊          },\n+┊  ┊83┊        },\n ┊87┊84┊      });\n ┊88┊85┊    },\n-┊89┊  ┊    [chat]\n+┊  ┊86┊    [chat, chatId, client]\n ┊90┊87┊  );\n ┊91┊88┊\n ┊92┊89┊  if (!chat) return null;\n```\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;ChatsList.tsx\n```diff\n@@ -2,8 +2,10 @@\n ┊ 2┊ 2┊import moment from 'moment';\n ┊ 3┊ 3┊import { List, ListItem } from '@material-ui/core';\n ┊ 4┊ 4┊import styled from 'styled-components';\n-┊ 5┊  ┊import { useCallback, useState, useMemo } from 'react';\n+┊  ┊ 5┊import { useCallback } from 'react';\n ┊ 6┊ 6┊import { History } from 'history';\n+┊  ┊ 7┊import gql from 'graphql-tag';\n+┊  ┊ 8┊import { useQuery } from 'react-apollo-hooks';\n ┊ 7┊ 9┊\n ┊ 8┊10┊const Container = styled.div`\n ┊ 9┊11┊  height: calc(100% - 56px);\n```\n```diff\n@@ -57,7 +59,7 @@\n ┊57┊59┊  font-size: 13px;\n ┊58┊60┊`;\n ┊59┊61┊\n-┊60┊  ┊const getChatsQuery = `\n+┊  ┊62┊const getChatsQuery = gql`\n ┊61┊63┊  query GetChats {\n ┊62┊64┊    chats {\n ┊63┊65┊      id\n```\n```diff\n@@ -77,21 +79,9 @@\n ┊77┊79┊}\n ┊78┊80┊\n ┊79┊81┊const ChatsList: React.FC<ChatsListProps> = ({ history }) => {\n-┊80┊  ┊  const [chats, setChats] = useState<any[]>([]);\n-┊81┊  ┊\n-┊82┊  ┊  useMemo(async () => {\n-┊83┊  ┊    const body = await fetch(`${process.env.REACT_APP_SERVER_URL}/graphql`, {\n-┊84┊  ┊      method: 'POST',\n-┊85┊  ┊      headers: {\n-┊86┊  ┊        'Content-Type': 'application/json',\n-┊87┊  ┊      },\n-┊88┊  ┊      body: JSON.stringify({ query: getChatsQuery }),\n-┊89┊  ┊    });\n-┊90┊  ┊    const {\n-┊91┊  ┊      data: { chats },\n-┊92┊  ┊    } = await body.json();\n-┊93┊  ┊    setChats(chats);\n-┊94┊  ┊  }, []);\n+┊  ┊82┊  const {\n+┊  ┊83┊    data: { chats = [] },\n+┊  ┊84┊  } = useQuery<any>(getChatsQuery);\n ┊95┊85┊\n ┊96┊86┊  const navToChat = useCallback(\n ┊97┊87┊    chat => {\n```\n```diff\n@@ -103,7 +93,7 @@\n ┊103┊ 93┊  return (\n ┊104┊ 94┊    <Container>\n ┊105┊ 95┊      <StyledList>\n-┊106┊   ┊        {chats.map(chat => (\n+┊   ┊ 96┊        {chats.map((chat: any) => (\n ┊107┊ 97┊          <StyledListItem\n ┊108┊ 98┊            key={chat.id}\n ┊109┊ 99┊            data-testid=\"chat\"\n```\n\n[}]: #\n\nYou can see that we've fetched the query using Apollo client, and we removed the `setChat` call because Apollo will know automatically to place the results in the cache.\n\nAnd you can see we can also work directly with the cache.\n\nOn the `OnSendMessage` function we take the new message and push it to Apollo Client's cache.\n\nNow if we'll scroll to another screen and come back, the messages will still be displayed there.\n\nYou can see that we've added the `__typename` when we push a new chat to the cache.\nThat's how Apollo Client knows where to place the results.\n\nThe replacement is finished. Note that we removed the usage of `useMemo()` - because Apollo has an internal cache mechanism, there's no need to memoize the result anymore.\nWe also used the [`writeQuery()`](https://www.apollographql.com/docs/react/features/caching.html#writequery-and-writefragment) method to edit the stored result in the cache, so in the next render phase we would have an updated chat with the newly added message.\n\nWe shouldn't see any change at all in the view and the response time, since we're running it locally, but if we will take a look at the `network` tab in the browser's dev-tools we should notice the differences:\n\n**before**\n\n![fetch](https://user-images.githubusercontent.com/7648874/54871305-e5879780-4dec-11e9-87bb-3279e9e18342.png)\n\n**after**\n\n![apollo](https://user-images.githubusercontent.com/7648874/54871319-1bc51700-4ded-11e9-9001-d5518bedf9ad.png)\n\n> Above: ChatsListScreen -> ChatRoomScreen -> ChatsListScreen -> ChatRoomScreen\n\nThis test is obviously very rough, but the deviation is so big that you don't need any accuracy to emphasize the difference.\nThe blue stripes represents the requests made and the time they took. Before we had about 6 request phases, while after we had only 3 of them.\n\nSince we don't use the Fetch API anymore, we will also need to update our tests.\nRight now we mock the response from the fetch API, but a more appropriate way would be creating a fake Apollo Client where we will be able to mock the results.\nFor that we will install a package called [`apollo-link-mock`](https://www.npmjs.com/package/apollo-link-mock):\n\n    $ yarn add --dev apollo-link-mock\n\nAnd we will create a `test-helpers.ts` file under the `src` directory that will contain the utility function for creating a fake Apollo Client:\n\n[{]: <helper> (diffStep 7.4 files=\"test-helpers\" module=\"client\")\n\n#### [__Client__ Step 7.4: Mock Apollo requests in tests](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/a2f65ee)\n\n##### Added src&#x2F;test-helpers.ts\n```diff\n@@ -0,0 +1,10 @@\n+┊  ┊ 1┊import { InMemoryCache } from 'apollo-cache-inmemory';\n+┊  ┊ 2┊import { ApolloClient } from 'apollo-client';\n+┊  ┊ 3┊import { MockLink } from 'apollo-link-mock';\n+┊  ┊ 4┊\n+┊  ┊ 5┊export const mockApolloClient = (mocks: any) => {\n+┊  ┊ 6┊  return new ApolloClient({\n+┊  ┊ 7┊    cache: new InMemoryCache(),\n+┊  ┊ 8┊    link: new MockLink(mocks),\n+┊  ┊ 9┊  });\n+┊  ┊10┊};\n```\n\n[}]: #\n\nThe fake client accepts an array of mocks where each mock object will have a `request` key that will contain details about the request and a `result` key which will contain the mocked result.\nYou should get a better understanding of how it works now that we will replace the fake Fetch calls with fake Apollo Clients:\n\n[{]: <helper> (diffStep 7.4 files=\"src/components\" module=\"client\")\n\n#### [__Client__ Step 7.4: Mock Apollo requests in tests](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/a2f65ee)\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;ChatsList.test.tsx\n```diff\n@@ -1,4 +1,5 @@\n ┊1┊1┊import React from 'react';\n+┊ ┊2┊import { ApolloProvider } from 'react-apollo-hooks';\n ┊2┊3┊import ReactDOM from 'react-dom';\n ┊3┊4┊import {\n ┊4┊5┊  cleanup,\n```\n```diff\n@@ -7,8 +8,9 @@\n ┊ 7┊ 8┊  wait,\n ┊ 8┊ 9┊  waitForDomChange,\n ┊ 9┊10┊} from '@testing-library/react';\n-┊10┊  ┊import ChatsList from './ChatsList';\n ┊11┊11┊import { createBrowserHistory } from 'history';\n+┊  ┊12┊import { mockApolloClient } from '../../test-helpers';\n+┊  ┊13┊import ChatsList, { getChatsQuery } from './ChatsList';\n ┊12┊14┊\n ┊13┊15┊describe('ChatsList', () => {\n ┊14┊16┊  afterEach(() => {\n```\n```diff\n@@ -17,27 +19,36 @@\n ┊17┊19┊  });\n ┊18┊20┊\n ┊19┊21┊  it('renders fetched chats data', async () => {\n-┊20┊  ┊    fetch.mockResponseOnce(\n-┊21┊  ┊      JSON.stringify({\n-┊22┊  ┊        data: {\n-┊23┊  ┊          chats: [\n-┊24┊  ┊            {\n-┊25┊  ┊              id: 1,\n-┊26┊  ┊              name: 'Foo Bar',\n-┊27┊  ┊              picture: 'https://localhost:4000/picture.jpg',\n-┊28┊  ┊              lastMessage: {\n+┊  ┊22┊    const client = mockApolloClient([\n+┊  ┊23┊      {\n+┊  ┊24┊        request: { query: getChatsQuery },\n+┊  ┊25┊        result: {\n+┊  ┊26┊          data: {\n+┊  ┊27┊            chats: [\n+┊  ┊28┊              {\n+┊  ┊29┊                __typename: 'Chat',\n ┊29┊30┊                id: 1,\n-┊30┊  ┊                content: 'Hello',\n-┊31┊  ┊                createdAt: new Date('1 Jan 2019 GMT'),\n+┊  ┊31┊                name: 'Foo Bar',\n+┊  ┊32┊                picture: 'https://localhost:4000/picture.jpg',\n+┊  ┊33┊                lastMessage: {\n+┊  ┊34┊                  __typename: 'Message',\n+┊  ┊35┊                  id: 1,\n+┊  ┊36┊                  content: 'Hello',\n+┊  ┊37┊                  createdAt: new Date('1 Jan 2019 GMT'),\n+┊  ┊38┊                },\n ┊32┊39┊              },\n-┊33┊  ┊            },\n-┊34┊  ┊          ],\n+┊  ┊40┊            ],\n+┊  ┊41┊          },\n ┊35┊42┊        },\n-┊36┊  ┊      })\n-┊37┊  ┊    );\n+┊  ┊43┊      },\n+┊  ┊44┊    ]);\n ┊38┊45┊\n ┊39┊46┊    {\n-┊40┊  ┊      const { container, getByTestId } = render(<ChatsList />);\n+┊  ┊47┊      const { container, getByTestId } = render(\n+┊  ┊48┊        <ApolloProvider client={client}>\n+┊  ┊49┊          <ChatsList />\n+┊  ┊50┊        </ApolloProvider>\n+┊  ┊51┊      );\n ┊41┊52┊\n ┊42┊53┊      await waitForDomChange({ container });\n ┊43┊54┊\n```\n```diff\n@@ -52,30 +63,37 @@\n ┊52┊63┊  });\n ┊53┊64┊\n ┊54┊65┊  it('should navigate to the target chat room on chat item click', async () => {\n-┊55┊  ┊    fetch.mockResponseOnce(\n-┊56┊  ┊      JSON.stringify({\n-┊57┊  ┊        data: {\n-┊58┊  ┊          chats: [\n-┊59┊  ┊            {\n-┊60┊  ┊              id: 1,\n-┊61┊  ┊              name: 'Foo Bar',\n-┊62┊  ┊              picture: 'https://localhost:4000/picture.jpg',\n-┊63┊  ┊              lastMessage: {\n+┊  ┊66┊    const client = mockApolloClient([\n+┊  ┊67┊      {\n+┊  ┊68┊        request: { query: getChatsQuery },\n+┊  ┊69┊        result: {\n+┊  ┊70┊          data: {\n+┊  ┊71┊            chats: [\n+┊  ┊72┊              {\n+┊  ┊73┊                __typename: 'Chat',\n ┊64┊74┊                id: 1,\n-┊65┊  ┊                content: 'Hello',\n-┊66┊  ┊                createdAt: new Date('1 Jan 2019 GMT'),\n+┊  ┊75┊                name: 'Foo Bar',\n+┊  ┊76┊                picture: 'https://localhost:4000/picture.jpg',\n+┊  ┊77┊                lastMessage: {\n+┊  ┊78┊                  __typename: 'Message',\n+┊  ┊79┊                  id: 1,\n+┊  ┊80┊                  content: 'Hello',\n+┊  ┊81┊                  createdAt: new Date('1 Jan 2019 GMT'),\n+┊  ┊82┊                },\n ┊67┊83┊              },\n-┊68┊  ┊            },\n-┊69┊  ┊          ],\n+┊  ┊84┊            ],\n+┊  ┊85┊          },\n ┊70┊86┊        },\n-┊71┊  ┊      })\n-┊72┊  ┊    );\n+┊  ┊87┊      },\n+┊  ┊88┊    ]);\n ┊73┊89┊\n ┊74┊90┊    const history = createBrowserHistory();\n ┊75┊91┊\n ┊76┊92┊    {\n ┊77┊93┊      const { container, getByTestId } = render(\n-┊78┊  ┊        <ChatsList history={history} />\n+┊  ┊94┊        <ApolloProvider client={client}>\n+┊  ┊95┊          <ChatsList history={history} />\n+┊  ┊96┊        </ApolloProvider>\n ┊79┊97┊      );\n ┊80┊98┊\n ┊81┊99┊      await waitForDomChange({ container });\n```\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;ChatsList.tsx\n```diff\n@@ -59,7 +59,7 @@\n ┊59┊59┊  font-size: 13px;\n ┊60┊60┊`;\n ┊61┊61┊\n-┊62┊  ┊const getChatsQuery = gql`\n+┊  ┊62┊export const getChatsQuery = gql`\n ┊63┊63┊  query GetChats {\n ┊64┊64┊    chats {\n ┊65┊65┊      id\n```\n\n[}]: #\n\nWe are telling Apollo mock to give a certain result each time it gets a specific query.\n\nNote how we used the `ApolloProvider` component to provide the target component with the fake Apollo Client.\nLike so, any other component which uses Apollo Client should be wrapped with an ApolloProvider when rendering it, otherwise it will not function as intended:\n\n[{]: <helper> (diffStep 7.4 files=\"src/App\" module=\"client\")\n\n#### [__Client__ Step 7.4: Mock Apollo requests in tests](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/a2f65ee)\n\n##### Changed src&#x2F;App.test.tsx\n```diff\n@@ -1,9 +1,18 @@\n ┊ 1┊ 1┊import React from 'react';\n+┊  ┊ 2┊import { ApolloProvider } from 'react-apollo-hooks';\n ┊ 2┊ 3┊import ReactDOM from 'react-dom';\n ┊ 3┊ 4┊import App from './App';\n+┊  ┊ 5┊import { mockApolloClient } from './test-helpers';\n ┊ 4┊ 6┊\n ┊ 5┊ 7┊it('renders without crashing', () => {\n+┊  ┊ 8┊  const client = mockApolloClient();\n ┊ 6┊ 9┊  const div = document.createElement('div');\n-┊ 7┊  ┊  ReactDOM.render(<App />, div);\n+┊  ┊10┊\n+┊  ┊11┊  ReactDOM.render(\n+┊  ┊12┊    <ApolloProvider client={client}>\n+┊  ┊13┊      <App />\n+┊  ┊14┊    </ApolloProvider>,\n+┊  ┊15┊    div\n+┊  ┊16┊  );\n ┊ 8┊17┊  ReactDOM.unmountComponentAtNode(div);\n ┊ 9┊18┊});\n```\n\n[}]: #\n\nThat's it for this chapter. There's one thing missing to make our `ChatRoomScreen` functional and that would be actually sending a message to the backend and updating the DB. In the next chapter we will learn how to do exactly that with our new Apollo-Client.\n\n\n--------------------\n\nTODO: Change the whole intro.\n\nTODO: I think we might want to explain the cache in more details\nhow it’s normalized\nhow some parts update automatically and some do not\nwhat’s the smallest unit stored in the cache\nand other stuff\nthis might help later on with optimistic responses and mutations in general\n\nTODO: Remove all label code\n\nTODO: Create a drawing of the cache.\nTODO: Change typename from Chat to Message\n\nTODO: Explain a bit about Apollo links."
          },
          {
            "manualTitle": "Step 8: Sending messages with GraphQL mutations",
            "stepRevision": "3b37e2967748f9224b41bac04d69cfb854ee0233",
            "manualView": "The view and the functionality for updating the component's state when sending a message already exists.\nThe thing is that messages are not really being sent, we only update the memory in the client.\n\nIf so, how exactly can we send messages and store them in the DB? For this purpose we're gonna learn about GraphQL mutations -\na method for sending and applying mutations in our back-end.\n\n**What are GraphQL mutations?**\n\nIf you have an API endpoint that alters data, like inserting data into a database or altering data already in a database,\nyou should make this endpoint a `Mutation` rather than a `Query`.\nThis is as simple as making the API endpoint part of the top-level `Mutation` type instead of the top-level `Query` type.\n\nIt's often convenient to have a mutation that maps to a database create or update operation, return the same thing that the server stored.\nThat way, if you modify the data on the server, the client can learn about those modifications.\n**A GraphQL mutation is like a GraphQL query, only with side effects**.\nIt's equivalent to GET (query) and POST/PUT (mutation) in the context of REST API.\n\nBelow is a sample GraphQL mutation request:\n\n```graphql\nmutation AddMessage($chatId: ID!) {\n  addMessage(chatId: $chatId) {\n    id\n    contents\n    createdAt\n  }\n}\n```\n\n**How to implement a GraphQL mutation?**\n\nSince GraphQL is schema based, we will need to create a new type called `Mutation` in the `typeDefs.graphql` file.\nIn this chapter we want to have the ability to send messages, thus we will have a field named `addMessage` in the new mutation type:\n\n[{]: <helper> (diffStep 5.1 files=\"typeDefs\" module=\"server\")\n\n#### [__Server__ Step 5.1: Add addMessage() mutation](https://github.com/Urigo/WhatsApp-Clone-Server/commit/91324d3)\n\n##### Changed schema&#x2F;typeDefs.graphql\n```diff\n@@ -18,3 +18,7 @@\n ┊18┊18┊  chats: [Chat!]!\n ┊19┊19┊  chat(chatId: ID!): Chat\n ┊20┊20┊}\n+┊  ┊21┊\n+┊  ┊22┊type Mutation {\n+┊  ┊23┊  addMessage(chatId: ID!, content: String!): Message\n+┊  ┊24┊}\n```\n\n[}]: #\n\nNote that our mutation resolver `addMessage` receives a `chatId`. This is because when adding a message, we should update both the messages collection, and the correlated chat document. Mutations are resolved exactly like any other type in our resolvers manifest. The new resolver should look like this:\n\n[{]: <helper> (diffStep 5.1 files=\"resolvers\" module=\"server\")\n\n#### [__Server__ Step 5.1: Add addMessage() mutation](https://github.com/Urigo/WhatsApp-Clone-Server/commit/91324d3)\n\n##### Changed schema&#x2F;resolvers.ts\n```diff\n@@ -25,6 +25,31 @@\n ┊25┊25┊      return chats.find(c => c.id === chatId);\n ┊26┊26┊    },\n ┊27┊27┊  },\n+┊  ┊28┊\n+┊  ┊29┊  Mutation: {\n+┊  ┊30┊    addMessage(root: any, { chatId, content }: any) {\n+┊  ┊31┊      const chatIndex = chats.findIndex(c => c.id === chatId);\n+┊  ┊32┊\n+┊  ┊33┊      if (chatIndex === -1) return null;\n+┊  ┊34┊\n+┊  ┊35┊      const chat = chats[chatIndex];\n+┊  ┊36┊      const lastMessageId = chat.messages[chat.messages.length - 1];\n+┊  ┊37┊      const messageId = String(Number(lastMessageId) + 1);\n+┊  ┊38┊      const message = {\n+┊  ┊39┊        id: messageId,\n+┊  ┊40┊        createdAt: new Date(),\n+┊  ┊41┊        content,\n+┊  ┊42┊      };\n+┊  ┊43┊\n+┊  ┊44┊      messages.push(message);\n+┊  ┊45┊      chat.messages.push(messageId);\n+┊  ┊46┊      // The chat will appear at the top of the ChatsList component\n+┊  ┊47┊      chats.splice(chatIndex, 1);\n+┊  ┊48┊      chats.unshift(chat);\n+┊  ┊49┊\n+┊  ┊50┊      return message;\n+┊  ┊51┊    },\n+┊  ┊52┊  },\n ┊28┊53┊};\n ┊29┊54┊\n ┊30┊55┊export default resolvers;\n```\n\n[}]: #\n\nIn terms of testing, we will use a temporary solution for now to reset the DB each time we test a mutation. Since we make a modification in the DB, we need to make sure that each test is completely agnostic and doesn't affect one another, thus, we will export a `resetDB()` method from our `db.ts` module:\n\n[{]: <helper> (diffStep 5.2 files=\"db.ts\" module=\"server\")\n\n#### [__Server__ Step 5.2: Test addMessage() mutation](https://github.com/Urigo/WhatsApp-Clone-Server/commit/70b87ed)\n\n##### Changed db.ts\n```diff\n@@ -1,51 +1,83 @@\n-┊ 1┊  ┊export const messages = [\n-┊ 2┊  ┊  {\n-┊ 3┊  ┊    id: '1',\n-┊ 4┊  ┊    content: 'You on your way?',\n-┊ 5┊  ┊    createdAt: new Date(new Date('1-1-2019').getTime() - 60 * 1000 * 1000),\n-┊ 6┊  ┊  },\n-┊ 7┊  ┊  {\n-┊ 8┊  ┊    id: '2',\n-┊ 9┊  ┊    content: \"Hey, it's me\",\n-┊10┊  ┊    createdAt: new Date(new Date('1-1-2019').getTime() - 2 * 60 * 1000 * 1000),\n-┊11┊  ┊  },\n-┊12┊  ┊  {\n-┊13┊  ┊    id: '3',\n-┊14┊  ┊    content: 'I should buy a boat',\n-┊15┊  ┊    createdAt: new Date(new Date('1-1-2019').getTime() - 24 * 60 * 1000 * 1000),\n-┊16┊  ┊  },\n-┊17┊  ┊  {\n-┊18┊  ┊    id: '4',\n-┊19┊  ┊    content: 'This is wicked good ice cream.',\n-┊20┊  ┊    createdAt: new Date(\n-┊21┊  ┊      new Date('1-1-2019').getTime() - 14 * 24 * 60 * 1000 * 1000\n-┊22┊  ┊    ),\n-┊23┊  ┊  },\n-┊24┊  ┊];\n+┊  ┊ 1┊export type Message = {\n+┊  ┊ 2┊  id: string;\n+┊  ┊ 3┊  content: string;\n+┊  ┊ 4┊  createdAt: Date;\n+┊  ┊ 5┊};\n ┊25┊ 6┊\n-┊26┊  ┊export const chats = [\n-┊27┊  ┊  {\n-┊28┊  ┊    id: '1',\n-┊29┊  ┊    name: 'Ethan Gonzalez',\n-┊30┊  ┊    picture: 'https://randomuser.me/api/portraits/thumb/men/1.jpg',\n-┊31┊  ┊    messages: ['1'],\n-┊32┊  ┊  },\n-┊33┊  ┊  {\n-┊34┊  ┊    id: '2',\n-┊35┊  ┊    name: 'Bryan Wallace',\n-┊36┊  ┊    picture: 'https://randomuser.me/api/portraits/thumb/men/2.jpg',\n-┊37┊  ┊    messages: ['2'],\n-┊38┊  ┊  },\n-┊39┊  ┊  {\n-┊40┊  ┊    id: '3',\n-┊41┊  ┊    name: 'Avery Stewart',\n-┊42┊  ┊    picture: 'https://randomuser.me/api/portraits/thumb/women/1.jpg',\n-┊43┊  ┊    messages: ['3'],\n-┊44┊  ┊  },\n-┊45┊  ┊  {\n-┊46┊  ┊    id: '4',\n-┊47┊  ┊    name: 'Katie Peterson',\n-┊48┊  ┊    picture: 'https://randomuser.me/api/portraits/thumb/women/2.jpg',\n-┊49┊  ┊    messages: ['4'],\n-┊50┊  ┊  },\n-┊51┊  ┊];\n+┊  ┊ 7┊export type Chat = {\n+┊  ┊ 8┊  id: string;\n+┊  ┊ 9┊  name: string;\n+┊  ┊10┊  picture: string;\n+┊  ┊11┊  messages: string[];\n+┊  ┊12┊};\n+┊  ┊13┊\n+┊  ┊14┊export const messages: Message[] = [];\n+┊  ┊15┊export const chats: Chat[] = [];\n+┊  ┊16┊\n+┊  ┊17┊export const resetDb = () => {\n+┊  ┊18┊  messages.splice(\n+┊  ┊19┊    0,\n+┊  ┊20┊    Infinity,\n+┊  ┊21┊    ...[\n+┊  ┊22┊      {\n+┊  ┊23┊        id: '1',\n+┊  ┊24┊        content: 'You on your way?',\n+┊  ┊25┊        createdAt: new Date(new Date('1-1-2019').getTime() - 60 * 1000 * 1000),\n+┊  ┊26┊      },\n+┊  ┊27┊      {\n+┊  ┊28┊        id: '2',\n+┊  ┊29┊        content: \"Hey, it's me\",\n+┊  ┊30┊        createdAt: new Date(\n+┊  ┊31┊          new Date('1-1-2019').getTime() - 2 * 60 * 1000 * 1000\n+┊  ┊32┊        ),\n+┊  ┊33┊      },\n+┊  ┊34┊      {\n+┊  ┊35┊        id: '3',\n+┊  ┊36┊        content: 'I should buy a boat',\n+┊  ┊37┊        createdAt: new Date(\n+┊  ┊38┊          new Date('1-1-2019').getTime() - 24 * 60 * 1000 * 1000\n+┊  ┊39┊        ),\n+┊  ┊40┊      },\n+┊  ┊41┊      {\n+┊  ┊42┊        id: '4',\n+┊  ┊43┊        content: 'This is wicked good ice cream.',\n+┊  ┊44┊        createdAt: new Date(\n+┊  ┊45┊          new Date('1-1-2019').getTime() - 14 * 24 * 60 * 1000 * 1000\n+┊  ┊46┊        ),\n+┊  ┊47┊      },\n+┊  ┊48┊    ]\n+┊  ┊49┊  );\n+┊  ┊50┊\n+┊  ┊51┊  chats.splice(\n+┊  ┊52┊    0,\n+┊  ┊53┊    Infinity,\n+┊  ┊54┊    ...[\n+┊  ┊55┊      {\n+┊  ┊56┊        id: '1',\n+┊  ┊57┊        name: 'Ethan Gonzalez',\n+┊  ┊58┊        picture: 'https://randomuser.me/api/portraits/thumb/men/1.jpg',\n+┊  ┊59┊        messages: ['1'],\n+┊  ┊60┊      },\n+┊  ┊61┊      {\n+┊  ┊62┊        id: '2',\n+┊  ┊63┊        name: 'Bryan Wallace',\n+┊  ┊64┊        picture: 'https://randomuser.me/api/portraits/thumb/men/2.jpg',\n+┊  ┊65┊        messages: ['2'],\n+┊  ┊66┊      },\n+┊  ┊67┊      {\n+┊  ┊68┊        id: '3',\n+┊  ┊69┊        name: 'Avery Stewart',\n+┊  ┊70┊        picture: 'https://randomuser.me/api/portraits/thumb/women/1.jpg',\n+┊  ┊71┊        messages: ['3'],\n+┊  ┊72┊      },\n+┊  ┊73┊      {\n+┊  ┊74┊        id: '4',\n+┊  ┊75┊        name: 'Katie Peterson',\n+┊  ┊76┊        picture: 'https://randomuser.me/api/portraits/thumb/women/2.jpg',\n+┊  ┊77┊        messages: ['4'],\n+┊  ┊78┊      },\n+┊  ┊79┊    ]\n+┊  ┊80┊  );\n+┊  ┊81┊};\n+┊  ┊82┊\n+┊  ┊83┊resetDb();\n```\n\n[}]: #\n\nAnd we will use the `beforeEach()` test hook to reset the `chats` and `messages` collections:\n\n[{]: <helper> (diffStep 5.2 files=\"tests\" module=\"server\")\n\n#### [__Server__ Step 5.2: Test addMessage() mutation](https://github.com/Urigo/WhatsApp-Clone-Server/commit/70b87ed)\n\n##### Added tests&#x2F;mutations&#x2F;\\__snapshots__&#x2F;addMessage.test.ts.snap\n```diff\n@@ -0,0 +1,22 @@\n+┊  ┊ 1┊// Jest Snapshot v1, https://goo.gl/fbAQLP\n+┊  ┊ 2┊\n+┊  ┊ 3┊exports[`Mutation.addMessage should add message to specified chat 1`] = `\n+┊  ┊ 4┊Object {\n+┊  ┊ 5┊  \"addMessage\": Object {\n+┊  ┊ 6┊    \"content\": \"Hello World\",\n+┊  ┊ 7┊    \"id\": \"5\",\n+┊  ┊ 8┊  },\n+┊  ┊ 9┊}\n+┊  ┊10┊`;\n+┊  ┊11┊\n+┊  ┊12┊exports[`Mutation.addMessage should add message to specified chat 2`] = `\n+┊  ┊13┊Object {\n+┊  ┊14┊  \"chat\": Object {\n+┊  ┊15┊    \"id\": \"1\",\n+┊  ┊16┊    \"lastMessage\": Object {\n+┊  ┊17┊      \"content\": \"Hello World\",\n+┊  ┊18┊      \"id\": \"5\",\n+┊  ┊19┊    },\n+┊  ┊20┊  },\n+┊  ┊21┊}\n+┊  ┊22┊`;\n```\n\n##### Added tests&#x2F;mutations&#x2F;addMessage.test.ts\n```diff\n@@ -0,0 +1,49 @@\n+┊  ┊ 1┊import { createTestClient } from 'apollo-server-testing';\n+┊  ┊ 2┊import { ApolloServer, gql } from 'apollo-server-express';\n+┊  ┊ 3┊import schema from '../../schema';\n+┊  ┊ 4┊import { resetDb } from '../../db';\n+┊  ┊ 5┊\n+┊  ┊ 6┊describe('Mutation.addMessage', () => {\n+┊  ┊ 7┊  beforeEach(resetDb);\n+┊  ┊ 8┊\n+┊  ┊ 9┊  it('should add message to specified chat', async () => {\n+┊  ┊10┊    const server = new ApolloServer({ schema });\n+┊  ┊11┊\n+┊  ┊12┊    const { query, mutate } = createTestClient(server);\n+┊  ┊13┊\n+┊  ┊14┊    const addMessageRes = await mutate({\n+┊  ┊15┊      variables: { chatId: '1', content: 'Hello World' },\n+┊  ┊16┊      mutation: gql`\n+┊  ┊17┊        mutation AddMessage($chatId: ID!, $content: String!) {\n+┊  ┊18┊          addMessage(chatId: $chatId, content: $content) {\n+┊  ┊19┊            id\n+┊  ┊20┊            content\n+┊  ┊21┊          }\n+┊  ┊22┊        }\n+┊  ┊23┊      `,\n+┊  ┊24┊    });\n+┊  ┊25┊\n+┊  ┊26┊    expect(addMessageRes.data).toBeDefined();\n+┊  ┊27┊    expect(addMessageRes.errors).toBeUndefined();\n+┊  ┊28┊    expect(addMessageRes.data).toMatchSnapshot();\n+┊  ┊29┊\n+┊  ┊30┊    const getChatRes = await query({\n+┊  ┊31┊      variables: { chatId: '1' },\n+┊  ┊32┊      query: gql`\n+┊  ┊33┊        query GetChat($chatId: ID!) {\n+┊  ┊34┊          chat(chatId: $chatId) {\n+┊  ┊35┊            id\n+┊  ┊36┊            lastMessage {\n+┊  ┊37┊              id\n+┊  ┊38┊              content\n+┊  ┊39┊            }\n+┊  ┊40┊          }\n+┊  ┊41┊        }\n+┊  ┊42┊      `,\n+┊  ┊43┊    });\n+┊  ┊44┊\n+┊  ┊45┊    expect(getChatRes.data).toBeDefined();\n+┊  ┊46┊    expect(getChatRes.errors).toBeUndefined();\n+┊  ┊47┊    expect(getChatRes.data).toMatchSnapshot();\n+┊  ┊48┊  });\n+┊  ┊49┊});\n```\n\n[}]: #\n\nNow we have the infrastructure set for sending a new message and we can start using it in our client.\n\n**How to use a GraphQL mutation?**\n\nLike in the previous chapters, we're gonna use a React hook so we can run a mutation more efficiently in a React.Component.\nFor this we're gonna use the [`useMutation()`](https://github.com/trojanowski/react-apollo-hooks#usemutation) react hook.\nThe first argument of the hook is the mutation string, and the second one is the [mutation options](https://www.apollographql.com/docs/react/api/apollo-client.html#ApolloClient.mutate).\nWe're gonna provide our mutation call with a single option called `optimisticResponse`.\n\nOptimistic response is a common pattern that will update the state of the component twice so we can have a better UX: First it updates the component's state with the predicted result,\nand then it will update the state with the actual result.\n\n\n\n![optimistic_response](https://user-images.githubusercontent.com/7648874/54883302-859df900-4e9f-11e9-9eb7-a98108cd2482.png)\n\n\nThis is how the component should look like:\n\n[{]: <helper> (diffStep 8.1 module=\"client\")\n\n#### [__Client__ Step 8.1: Send message with a GraphQL mutation](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/890d051)\n\n##### Changed src&#x2F;components&#x2F;ChatRoomScreen&#x2F;index.tsx\n```diff\n@@ -1,7 +1,7 @@\n ┊1┊1┊import gql from 'graphql-tag';\n ┊2┊2┊import React from 'react';\n ┊3┊3┊import { useCallback } from 'react';\n-┊4┊ ┊import { useApolloClient, useQuery } from 'react-apollo-hooks';\n+┊ ┊4┊import { useQuery, useMutation } from 'react-apollo-hooks';\n ┊5┊5┊import styled from 'styled-components';\n ┊6┊6┊import ChatNavbar from './ChatNavbar';\n ┊7┊7┊import MessageInput from './MessageInput';\n```\n```diff\n@@ -30,6 +30,16 @@\n ┊30┊30┊  }\n ┊31┊31┊`;\n ┊32┊32┊\n+┊  ┊33┊const addMessageMutation = gql`\n+┊  ┊34┊  mutation AddMessage($chatId: ID!, $content: String!) {\n+┊  ┊35┊    addMessage(chatId: $chatId, content: $content) {\n+┊  ┊36┊      id\n+┊  ┊37┊      content\n+┊  ┊38┊      createdAt\n+┊  ┊39┊    }\n+┊  ┊40┊  }\n+┊  ┊41┊`;\n+┊  ┊42┊\n ┊33┊43┊interface ChatRoomScreenParams {\n ┊34┊44┊  chatId: string;\n ┊35┊45┊  history: History;\n```\n```diff\n@@ -54,36 +64,43 @@\n ┊ 54┊ 64┊  history,\n ┊ 55┊ 65┊  chatId,\n ┊ 56┊ 66┊}) => {\n-┊ 57┊   ┊  const client = useApolloClient();\n ┊ 58┊ 67┊  const {\n ┊ 59┊ 68┊    data: { chat },\n ┊ 60┊ 69┊  } = useQuery<any>(getChatQuery, {\n ┊ 61┊ 70┊    variables: { chatId },\n ┊ 62┊ 71┊  });\n+┊   ┊ 72┊  const addMessage = useMutation(addMessageMutation);\n ┊ 63┊ 73┊\n ┊ 64┊ 74┊  const onSendMessage = useCallback(\n ┊ 65┊ 75┊    (content: string) => {\n-┊ 66┊   ┊      if (!chat) return null;\n-┊ 67┊   ┊\n-┊ 68┊   ┊      const message = {\n-┊ 69┊   ┊        id: (chat.messages.length + 10).toString(),\n-┊ 70┊   ┊        createdAt: Date.now(),\n-┊ 71┊   ┊        content,\n-┊ 72┊   ┊        __typename: 'Chat',\n-┊ 73┊   ┊      };\n-┊ 74┊   ┊\n-┊ 75┊   ┊      client.writeQuery({\n-┊ 76┊   ┊        query: getChatQuery,\n-┊ 77┊   ┊        variables: { chatId },\n-┊ 78┊   ┊        data: {\n-┊ 79┊   ┊          chat: {\n-┊ 80┊   ┊            ...chat,\n-┊ 81┊   ┊            messages: chat.messages.concat(message),\n+┊   ┊ 76┊      addMessage({\n+┊   ┊ 77┊        variables: { chatId, content },\n+┊   ┊ 78┊        optimisticResponse: {\n+┊   ┊ 79┊          __typename: 'Mutation',\n+┊   ┊ 80┊          addMessage: {\n+┊   ┊ 81┊            __typename: 'Message',\n+┊   ┊ 82┊            id: Math.random()\n+┊   ┊ 83┊              .toString(36)\n+┊   ┊ 84┊              .substr(2, 9),\n+┊   ┊ 85┊            createdAt: new Date(),\n+┊   ┊ 86┊            content,\n ┊ 82┊ 87┊          },\n ┊ 83┊ 88┊        },\n+┊   ┊ 89┊        update: (client, { data: { addMessage } }) => {\n+┊   ┊ 90┊          client.writeQuery({\n+┊   ┊ 91┊            query: getChatQuery,\n+┊   ┊ 92┊            variables: { chatId },\n+┊   ┊ 93┊            data: {\n+┊   ┊ 94┊              chat: {\n+┊   ┊ 95┊                ...chat,\n+┊   ┊ 96┊                messages: chat.messages.concat(addMessage),\n+┊   ┊ 97┊              },\n+┊   ┊ 98┊            },\n+┊   ┊ 99┊          });\n+┊   ┊100┊        },\n ┊ 84┊101┊      });\n ┊ 85┊102┊    },\n-┊ 86┊   ┊    [chat, chatId, client]\n+┊   ┊103┊    [chat, chatId, addMessage]\n ┊ 87┊104┊  );\n ┊ 88┊105┊\n ┊ 89┊106┊  if (!chat) return null;\n```\n\n[}]: #\n\nNote that unlike `useQuery()`, `useMutation()` returns a callback that will run the mutation only once called, NOT immediately.\nSeemingly, everything works fine, but if you'll try to navigate from `ChatsListScreen` to `ChatRoomScreen`, send a message, and then go back, you'll see that the last message was not updated.\nSo why is that exactly?\n\n**Cache updating**\n\nAs explained in the previous chapter, Apollo-Client will cache all the results in a data-store.\nLater on, rather than re-fetching the data, it will look up for the result in the store and will serve it to you in case it exists.\nThat means, that even though we ran the mutation and updated the data on the server, our data-store is still left behind and it needs to be updated as well,\notherwise Apollo-Client will see nothing wrong with the outcome.\n\nApollo-Client stores the data in a hash, where the key represents the query and the value represents the retrieved result.\nThis means that the cache will need to be updated for:\n\n\n*   `chats` query - which we already did, without really diving into the reason behind it.\n*   `chat(chatId: $chatId)` where `chatId` is the chat that was just mutated.\n\nIndeed, a query will be duplicated for each and every distinct set of parameters.\nSo potentially our data-store can grow infinite amount of times, and we will need to take care of it and manage it correctly, so things won't get out of hand.\n\nTo update a query, we will first export the `getChats` query to a separate file so it can be imported in the `ChatRoomScreen`.\nWe will define all our GraphQL assets under the `src/graphql` directory:\n\n[{]: <helper> (diffStep 8.2 files=\"graphql\" module=\"client\")\n\n#### [__Client__ Step 8.2: Rewrite lastMessage to chats query](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/00dfaec)\n\n##### Added src&#x2F;graphql&#x2F;queries&#x2F;chats.query.ts\n```diff\n@@ -0,0 +1,16 @@\n+┊  ┊ 1┊import gql from 'graphql-tag';\n+┊  ┊ 2┊\n+┊  ┊ 3┊export default gql`\n+┊  ┊ 4┊  query Chats {\n+┊  ┊ 5┊    chats {\n+┊  ┊ 6┊      id\n+┊  ┊ 7┊      name\n+┊  ┊ 8┊      picture\n+┊  ┊ 9┊      lastMessage {\n+┊  ┊10┊        id\n+┊  ┊11┊        content\n+┊  ┊12┊        createdAt\n+┊  ┊13┊      }\n+┊  ┊14┊    }\n+┊  ┊15┊  }\n+┊  ┊16┊`;\n```\n\n##### Added src&#x2F;graphql&#x2F;queries&#x2F;index.ts\n```diff\n@@ -0,0 +1 @@\n+┊ ┊1┊export { default as chats } from './chats.query';\n```\n\n[}]: #\n\nAnd then we will read the memoized result from the store using [`client.readQuery`](https://www.apollographql.com/docs/react/features/caching.html#readquery),\nupdate it, and then rewrite it using [`client.writeQuery`](https://www.apollographql.com/docs/react/features/caching.html#writequery-and-writefragment).\nWe can gain access to the client object via the `update` callback which will be triggered right after the mutation has been successfully executed.\nThis is how it should look like:\n\n[{]: <helper> (diffStep 8.2 files=\"components\" module=\"client\")\n\n#### [__Client__ Step 8.2: Rewrite lastMessage to chats query](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/00dfaec)\n\n##### Changed src&#x2F;components&#x2F;ChatRoomScreen&#x2F;index.tsx\n```diff\n@@ -7,6 +7,7 @@\n ┊ 7┊ 7┊import MessageInput from './MessageInput';\n ┊ 8┊ 8┊import MessagesList from './MessagesList';\n ┊ 9┊ 9┊import { History } from 'history';\n+┊  ┊10┊import * as queries from '../../graphql/queries';\n ┊10┊11┊\n ┊11┊12┊const Container = styled.div`\n ┊12┊13┊  background: url(/assets/chat-background.jpg);\n```\n```diff\n@@ -60,6 +61,10 @@\n ┊60┊61┊\n ┊61┊62┊type OptionalChatQueryResult = ChatQueryResult | null;\n ┊62┊63┊\n+┊  ┊64┊interface ChatsResult {\n+┊  ┊65┊  chats: any[];\n+┊  ┊66┊}\n+┊  ┊67┊\n ┊63┊68┊const ChatRoomScreen: React.FC<ChatRoomScreenParams> = ({\n ┊64┊69┊  history,\n ┊65┊70┊  chatId,\n```\n```diff\n@@ -97,6 +102,37 @@\n ┊ 97┊102┊              },\n ┊ 98┊103┊            },\n ┊ 99┊104┊          });\n+┊   ┊105┊\n+┊   ┊106┊          let data;\n+┊   ┊107┊          try {\n+┊   ┊108┊            data = client.readQuery<ChatsResult>({\n+┊   ┊109┊              query: queries.chats,\n+┊   ┊110┊            });\n+┊   ┊111┊          } catch (e) {\n+┊   ┊112┊            return;\n+┊   ┊113┊          }\n+┊   ┊114┊\n+┊   ┊115┊          if (!data || data === null) {\n+┊   ┊116┊            return null;\n+┊   ┊117┊          }\n+┊   ┊118┊          if (!data.chats || data.chats === undefined) {\n+┊   ┊119┊            return null;\n+┊   ┊120┊          }\n+┊   ┊121┊          const chats = data.chats;\n+┊   ┊122┊\n+┊   ┊123┊          const chatIndex = chats.findIndex((c: any) => c.id === chatId);\n+┊   ┊124┊          if (chatIndex === -1) return;\n+┊   ┊125┊          const chatWhereAdded = chats[chatIndex];\n+┊   ┊126┊\n+┊   ┊127┊          chatWhereAdded.lastMessage = addMessage;\n+┊   ┊128┊          // The chat will appear at the top of the ChatsList component\n+┊   ┊129┊          chats.splice(chatIndex, 1);\n+┊   ┊130┊          chats.unshift(chatWhereAdded);\n+┊   ┊131┊\n+┊   ┊132┊          client.writeQuery({\n+┊   ┊133┊            query: queries.chats,\n+┊   ┊134┊            data: { chats: chats },\n+┊   ┊135┊          });\n ┊100┊136┊        },\n ┊101┊137┊      });\n ┊102┊138┊    },\n```\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;ChatsList.test.tsx\n```diff\n@@ -11,6 +11,7 @@\n ┊11┊11┊import { createBrowserHistory } from 'history';\n ┊12┊12┊import { mockApolloClient } from '../../test-helpers';\n ┊13┊13┊import ChatsList, { getChatsQuery } from './ChatsList';\n+┊  ┊14┊import * as queries from '../../graphql/queries';\n ┊14┊15┊\n ┊15┊16┊describe('ChatsList', () => {\n ┊16┊17┊  afterEach(() => {\n```\n```diff\n@@ -21,7 +22,7 @@\n ┊21┊22┊  it('renders fetched chats data', async () => {\n ┊22┊23┊    const client = mockApolloClient([\n ┊23┊24┊      {\n-┊24┊  ┊        request: { query: getChatsQuery },\n+┊  ┊25┊        request: { query: queries.chats },\n ┊25┊26┊        result: {\n ┊26┊27┊          data: {\n ┊27┊28┊            chats: [\n```\n```diff\n@@ -65,7 +66,7 @@\n ┊65┊66┊  it('should navigate to the target chat room on chat item click', async () => {\n ┊66┊67┊    const client = mockApolloClient([\n ┊67┊68┊      {\n-┊68┊  ┊        request: { query: getChatsQuery },\n+┊  ┊69┊        request: { query: queries.chats },\n ┊69┊70┊        result: {\n ┊70┊71┊          data: {\n ┊71┊72┊            chats: [\n```\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;ChatsList.tsx\n```diff\n@@ -4,8 +4,8 @@\n ┊ 4┊ 4┊import styled from 'styled-components';\n ┊ 5┊ 5┊import { useCallback } from 'react';\n ┊ 6┊ 6┊import { History } from 'history';\n-┊ 7┊  ┊import gql from 'graphql-tag';\n ┊ 8┊ 7┊import { useQuery } from 'react-apollo-hooks';\n+┊  ┊ 8┊import * as queries from '../../graphql/queries';\n ┊ 9┊ 9┊\n ┊10┊10┊const Container = styled.div`\n ┊11┊11┊  height: calc(100% - 56px);\n```\n```diff\n@@ -59,21 +59,6 @@\n ┊59┊59┊  font-size: 13px;\n ┊60┊60┊`;\n ┊61┊61┊\n-┊62┊  ┊export const getChatsQuery = gql`\n-┊63┊  ┊  query GetChats {\n-┊64┊  ┊    chats {\n-┊65┊  ┊      id\n-┊66┊  ┊      name\n-┊67┊  ┊      picture\n-┊68┊  ┊      lastMessage {\n-┊69┊  ┊        id\n-┊70┊  ┊        content\n-┊71┊  ┊        createdAt\n-┊72┊  ┊      }\n-┊73┊  ┊    }\n-┊74┊  ┊  }\n-┊75┊  ┊`;\n-┊76┊  ┊\n ┊77┊62┊interface ChatsListProps {\n ┊78┊63┊  history: History;\n ┊79┊64┊}\n```\n```diff\n@@ -81,7 +66,7 @@\n ┊81┊66┊const ChatsList: React.FC<ChatsListProps> = ({ history }) => {\n ┊82┊67┊  const {\n ┊83┊68┊    data: { chats = [] },\n-┊84┊  ┊  } = useQuery<any>(getChatsQuery);\n+┊  ┊69┊  } = useQuery<any>(queries.chats);\n ┊85┊70┊\n ┊86┊71┊  const navToChat = useCallback(\n ┊87┊72┊    chat => {\n```\n\n[}]: #\n\nRight now what happens is that we update a single chat document twice: Once for the `chats` query and another time for the `chat($chatId)` query.\nThis work is redundant and become more complex as we add more `chat` related queries.\nTo solve it, we can define and use a [GraphQL fragment](https://www.apollographql.com/docs/react/advanced/fragments.html).\n\n**Using Fragments**\n\nA GraphQL fragment is a shared piece of query logic.\n\n```graphql\nfragment NameParts on Person {\n  firstName\n  lastName\n}\n\nquery GetPerson {\n  people(id: \"7\") {\n    ...NameParts\n    avatar(size: LARGE)\n  }\n}\n```\n\nIt's important to note that the component after the `on` clause is designated for the type we are selecting from. In this case, `people` is of type `Person` and we want to select the `firstName` and `lastName` fields from `people(id: \"7\")`.\n\nApollo maps the fragment ID to its retrieved data in the store. By default, Apollo will compose the fragment ID out of the entity type and the ID of the document. For example, for a `Chat` document with an ID of `7`, the fragment ID would be `Chat:7`. This behavior can be modified, but there's no need to.\n\nWe will define the following fragments in our app:\n\n\n\n*   `Message` - represents a message\n*   `Chat` - represents a chat, **without its messages list**.\n*   `FullChat` - represents a chat, **including its messages list**.\n\nOnce we define the fragments we can start embedding them in our queries. We will create a new directory path `src/graphql/fragments`, and inside we will create a dedicated fragment file for each fragment type: `message.fragment.ts`, `chat.fragment.ts` and `fullChat.fragment.ts`:\n\n[{]: <helper> (diffStep 8.3 files=\"graphql/fragments\" module=\"client\")\n\n#### [__Client__ Step 8.3: Update queries to use GraphQL fragments](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/8e6a4b2)\n\n##### Added src&#x2F;graphql&#x2F;fragments&#x2F;chat.fragment.ts\n```diff\n@@ -0,0 +1,14 @@\n+┊  ┊ 1┊import gql from 'graphql-tag';\n+┊  ┊ 2┊import message from './message.fragment';\n+┊  ┊ 3┊\n+┊  ┊ 4┊export default gql`\n+┊  ┊ 5┊  fragment Chat on Chat {\n+┊  ┊ 6┊    id\n+┊  ┊ 7┊    name\n+┊  ┊ 8┊    picture\n+┊  ┊ 9┊    lastMessage {\n+┊  ┊10┊      ...Message\n+┊  ┊11┊    }\n+┊  ┊12┊  }\n+┊  ┊13┊  ${message}\n+┊  ┊14┊`;\n```\n\n##### Added src&#x2F;graphql&#x2F;fragments&#x2F;fullChat.fragment.ts\n```diff\n@@ -0,0 +1,14 @@\n+┊  ┊ 1┊import gql from 'graphql-tag';\n+┊  ┊ 2┊import chat from './chat.fragment';\n+┊  ┊ 3┊import message from './message.fragment';\n+┊  ┊ 4┊\n+┊  ┊ 5┊export default gql`\n+┊  ┊ 6┊  fragment FullChat on Chat {\n+┊  ┊ 7┊    ...Chat\n+┊  ┊ 8┊    messages {\n+┊  ┊ 9┊      ...Message\n+┊  ┊10┊    }\n+┊  ┊11┊  }\n+┊  ┊12┊  ${chat}\n+┊  ┊13┊  ${message}\n+┊  ┊14┊`;\n```\n\n##### Added src&#x2F;graphql&#x2F;fragments&#x2F;index.ts\n```diff\n@@ -0,0 +1,3 @@\n+┊ ┊1┊export { default as chat } from './chat.fragment';\n+┊ ┊2┊export { default as fullChat } from './fullChat.fragment';\n+┊ ┊3┊export { default as message } from './message.fragment';\n```\n\n##### Added src&#x2F;graphql&#x2F;fragments&#x2F;message.fragment.ts\n```diff\n@@ -0,0 +1,9 @@\n+┊ ┊1┊import gql from 'graphql-tag';\n+┊ ┊2┊\n+┊ ┊3┊export default gql`\n+┊ ┊4┊  fragment Message on Message {\n+┊ ┊5┊    id\n+┊ ┊6┊    createdAt\n+┊ ┊7┊    content\n+┊ ┊8┊  }\n+┊ ┊9┊`;\n```\n\n[}]: #\n\nAnd now that we have the fragments available to us, let's embed them in the relevant queries:\n\n[{]: <helper> (diffStep 8.3 files=\"components, graphql/queries\" module=\"client\")\n\n#### [__Client__ Step 8.3: Update queries to use GraphQL fragments](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/8e6a4b2)\n\n##### Changed src&#x2F;components&#x2F;ChatRoomScreen&#x2F;index.tsx\n```diff\n@@ -8,6 +8,7 @@\n ┊ 8┊ 8┊import MessagesList from './MessagesList';\n ┊ 9┊ 9┊import { History } from 'history';\n ┊10┊10┊import * as queries from '../../graphql/queries';\n+┊  ┊11┊import * as fragments from '../../graphql/fragments';\n ┊11┊12┊\n ┊12┊13┊const Container = styled.div`\n ┊13┊14┊  background: url(/assets/chat-background.jpg);\n```\n```diff\n@@ -19,26 +20,19 @@\n ┊19┊20┊const getChatQuery = gql`\n ┊20┊21┊  query GetChat($chatId: ID!) {\n ┊21┊22┊    chat(chatId: $chatId) {\n-┊22┊  ┊      id\n-┊23┊  ┊      name\n-┊24┊  ┊      picture\n-┊25┊  ┊      messages {\n-┊26┊  ┊        id\n-┊27┊  ┊        content\n-┊28┊  ┊        createdAt\n-┊29┊  ┊      }\n+┊  ┊23┊      ...FullChat\n ┊30┊24┊    }\n ┊31┊25┊  }\n+┊  ┊26┊  ${fragments.fullChat}\n ┊32┊27┊`;\n ┊33┊28┊\n ┊34┊29┊const addMessageMutation = gql`\n ┊35┊30┊  mutation AddMessage($chatId: ID!, $content: String!) {\n ┊36┊31┊    addMessage(chatId: $chatId, content: $content) {\n-┊37┊  ┊      id\n-┊38┊  ┊      content\n-┊39┊  ┊      createdAt\n+┊  ┊32┊      ...Message\n ┊40┊33┊    }\n ┊41┊34┊  }\n+┊  ┊35┊  ${fragments.message}\n ┊42┊36┊`;\n ┊43┊37┊\n ┊44┊38┊interface ChatRoomScreenParams {\n```\n\n##### Changed src&#x2F;graphql&#x2F;queries&#x2F;chats.query.ts\n```diff\n@@ -1,16 +1,11 @@\n ┊ 1┊ 1┊import gql from 'graphql-tag';\n+┊  ┊ 2┊import * as fragments from '../fragments';\n ┊ 2┊ 3┊\n ┊ 3┊ 4┊export default gql`\n ┊ 4┊ 5┊  query Chats {\n ┊ 5┊ 6┊    chats {\n-┊ 6┊  ┊      id\n-┊ 7┊  ┊      name\n-┊ 8┊  ┊      picture\n-┊ 9┊  ┊      lastMessage {\n-┊10┊  ┊        id\n-┊11┊  ┊        content\n-┊12┊  ┊        createdAt\n-┊13┊  ┊      }\n+┊  ┊ 7┊      ...Chat\n ┊14┊ 8┊    }\n ┊15┊ 9┊  }\n+┊  ┊10┊  ${fragments.chat}\n ┊16┊11┊`;\n```\n\n[}]: #\n\nSimilarly to query rewriting, we will use the [`readFragment()`](https://www.apollographql.com/docs/react/features/caching.html#readfragment) and [`writeFragment()`](https://www.apollographql.com/docs/react/features/caching.html#writefragment) methods in the same way to rewrite the fragments. When working with a fragment we need to compose its ID, just like explained earlier. The default mapping function called `defaultDataIdFromObject` can be imported from `apollo-cache-inmemory` and be used to specify the fragment that we would like to read/write. Accordingly, we're gonna replace all our query re-writings with fragments re-writings, as we don't need them anymore:\n\n[{]: <helper> (diffStep 8.4 module=\"client\")\n\n#### [__Client__ Step 8.4: Rewrite fragments](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/297979e)\n\n##### Changed src&#x2F;components&#x2F;ChatRoomScreen&#x2F;index.tsx\n```diff\n@@ -1,3 +1,4 @@\n+┊ ┊1┊import { defaultDataIdFromObject } from 'apollo-cache-inmemory';\n ┊1┊2┊import gql from 'graphql-tag';\n ┊2┊3┊import React from 'react';\n ┊3┊4┊import { useCallback } from 'react';\n```\n```diff\n@@ -86,15 +87,38 @@\n ┊ 86┊ 87┊          },\n ┊ 87┊ 88┊        },\n ┊ 88┊ 89┊        update: (client, { data: { addMessage } }) => {\n-┊ 89┊   ┊          client.writeQuery({\n-┊ 90┊   ┊            query: getChatQuery,\n-┊ 91┊   ┊            variables: { chatId },\n-┊ 92┊   ┊            data: {\n-┊ 93┊   ┊              chat: {\n-┊ 94┊   ┊                ...chat,\n-┊ 95┊   ┊                messages: chat.messages.concat(addMessage),\n-┊ 96┊   ┊              },\n-┊ 97┊   ┊            },\n+┊   ┊ 90┊          type FullChat = { [key: string]: any };\n+┊   ┊ 91┊          let fullChat;\n+┊   ┊ 92┊          const chatIdFromStore = defaultDataIdFromObject(chat);\n+┊   ┊ 93┊\n+┊   ┊ 94┊          if (chatIdFromStore === null) {\n+┊   ┊ 95┊            return;\n+┊   ┊ 96┊          }\n+┊   ┊ 97┊\n+┊   ┊ 98┊          try {\n+┊   ┊ 99┊            fullChat = client.readFragment<FullChat>({\n+┊   ┊100┊              id: chatIdFromStore,\n+┊   ┊101┊              fragment: fragments.fullChat,\n+┊   ┊102┊              fragmentName: 'FullChat',\n+┊   ┊103┊            });\n+┊   ┊104┊          } catch (e) {\n+┊   ┊105┊            return;\n+┊   ┊106┊          }\n+┊   ┊107┊\n+┊   ┊108┊          if (fullChat === null) {\n+┊   ┊109┊            return;\n+┊   ┊110┊          }\n+┊   ┊111┊          if (fullChat.messages.some((m: any) => m.id === addMessage.id))\n+┊   ┊112┊            return;\n+┊   ┊113┊\n+┊   ┊114┊          fullChat.messages.push(addMessage);\n+┊   ┊115┊          fullChat.lastMessage = addMessage;\n+┊   ┊116┊\n+┊   ┊117┊          client.writeFragment({\n+┊   ┊118┊            id: chatIdFromStore,\n+┊   ┊119┊            fragment: fragments.fullChat,\n+┊   ┊120┊            fragmentName: 'FullChat',\n+┊   ┊121┊            data: fullChat,\n ┊ 98┊122┊          });\n ┊ 99┊123┊\n ┊100┊124┊          let data;\n```\n```diff\n@@ -118,7 +142,6 @@\n ┊118┊142┊          if (chatIndex === -1) return;\n ┊119┊143┊          const chatWhereAdded = chats[chatIndex];\n ┊120┊144┊\n-┊121┊   ┊          chatWhereAdded.lastMessage = addMessage;\n ┊122┊145┊          // The chat will appear at the top of the ChatsList component\n ┊123┊146┊          chats.splice(chatIndex, 1);\n ┊124┊147┊          chats.unshift(chatWhereAdded);\n```\n\n[}]: #\n\n\n----------\nTODO: Isn’t `chats.splice(0, Infinity, ...[ … ])` the same as `chats = [...]` ?\nI see an explanation of apollo-cache but it makes you feel it’s the fragment that’s being cached, which is not true, it’s the object type.\nWe shouldn’t use `defaultDataIdFromObject` directly from `apollo-cache-inmemory` but define it somewhere in our code and use that. It might change in the future and then we would have to do it in 500 files.\nI would explain a lot more than it is now, about the caching. It should be based on a simpler example and show that when an entity `Foo:1` is modified, the change reflects in all component. We should describe how it’s stored, as references and not real data and so on.\n\nTODO: Better fragments naming and convensions"
          },
          {
            "manualTitle": "Step 9: Type safety with GraphQL Code Generator",
            "stepRevision": "24d409385f383317a6c72dc95187de685e989480",
            "manualView": "So far we've been just writing code. If there was an error we would most likely discover it during runtime. As a reminder, we've created a project which is based on TypeScript, but we haven't really took any advantage of TypeScript's type safety mechanism. Currently, the TypeScript compiler is configured to work on loose mode, so any object which is not bound to any type will be converted to `any` - a type which is compatible with any type of casting and will ignore type errors.\n\nSo far it's been very convenient because we've only started to learn about building an app and the ecosystem around it, but for a long term project it's would be very handy to take a full advantage of TypeScript and not let it go under the radar. So where exactly are we missing type checkings? In the core of our project - when dealing with GraphQL documents.\n\nWhen we run a query, or a mutation, we wanna make sure that we use the received data correctly, based on its intended shape and form. For example, given the following GraphQL query:\n\n```graphql\nquery Chats {\n  chats {\n    id\n    name\n    picture\n  }\n}\n```\n\nWe want to have the following TypeScript type:\n\n```ts\nexport type Chat = {\n  __typename?: \"Chat\"\n  id: string\n  name: string\n  picture: string\n}\n\nexport type ChatQuery = {\n  __typename?: \"Query\"\n  chats: Chats[]\n}\n\n```\n\nSo later on we can use it with `react-apollo-hooks` like so:\n\n```ts\nuseQuery<ChatsQuery>(getChatsQuery)\n```\n\nEverything looks nice in theory, but the main issue that arises from having type definitions is that we need to maintain and sync 2 similar code bases:\nA GraphQL schema and TypeScript type definitions.\nBoth are essentially the same, and if so, why do we even need to maintain 2 code bases?\nIsn't there a tool which does that for us? A question which brings us straight to the point of the chapter.\n\n**Introducing: GraphQL Code Generator**\n\nWith [GraphQL Code Generator](https://graphql-code-generator.com/) we can generate TypeScript definitions given a GraphQL schema, and a set of GraphQL documents if they are presented to us.\n\n\n\n![graphql-codegen](https://user-images.githubusercontent.com/7648874/54940897-9f564380-4f66-11e9-9891-3b994a1daef1.png)\n\n\nGraphQL Code Generator is a simple CLI tool that operates based on a configuration file and can generate TypeScript types for both Client and Server.\nWe will start with generating types for the server.\n\nIn the server project, install GraphQL Code Generator via Yarn\n\n    $ yarn add @graphql-codegen/cli --dev\n\nNow GraphQL Code Generator can be used directly from the `scripts` section in the `package.json` file using the `gql-gen` binary.\nWe're gonna call the code generation script \"codegen\":\n\n```json\n{\n  \"codegen\": \"gql-gen\"\n}\n```\n\nThis command will automatically be referenced to a configuration file in the root of our project called `codegen.yml`.\nThe essence of this file is to provide the code generator with the GraphQL schema, GraphQL documents, the output path of the type definition file/s and a set of plug-ins.\nMore about the configuration file can be found in the [official website](https://graphql-code-generator.com/docs/getting-started/codegen-config).\n\nIn the server project, we will generate the `types/graphql.d.ts` file and we will use a couple of plug-ins to do that:\n\n\n\n*   `@graphql-codegen/typescript` - Will generate the core TypeScript types from our GraphQL schema.\n*   `@graphql-codegen/typescript-resolvers` - Will generate resolvers signatures with the generated TypeScript types.\n\n> A full list of available plugins is available [here](https://graphql-code-generator.com/docs/plugins/). In addition, you can write your own [custom plugin](https://graphql-code-generator.com/docs/custom-codegen/write-your-plugin).\n\nLet's install these 2 plugins:\n\n    $ yarn add @graphql-codegen/typescript @graphql-codegen/typescript-resolvers --dev\n\nAnd write the `codegen.yml` file:\n\n[{]: <helper> (diffStep 6.1 files=\"codegen.yml\" module=\"server\")\n\n#### [__Server__ Step 6.1: Setup GraphQL Code Generator](https://github.com/Urigo/WhatsApp-Clone-Server/commit/1494ed1)\n\n##### Added codegen.yml\n```diff\n@@ -0,0 +1,16 @@\n+┊  ┊ 1┊schema: ./schema/typeDefs.graphql\n+┊  ┊ 2┊overwrite: true\n+┊  ┊ 3┊generates:\n+┊  ┊ 4┊  ./types/graphql.d.ts:\n+┊  ┊ 5┊    plugins:\n+┊  ┊ 6┊      - typescript\n+┊  ┊ 7┊      - typescript-resolvers\n+┊  ┊ 8┊    config:\n+┊  ┊ 9┊      mappers:\n+┊  ┊10┊        # import { Message } from '../db'\n+┊  ┊11┊        # The root types of Message resolvers\n+┊  ┊12┊        Message: ../db#Message\n+┊  ┊13┊        Chat: ../db#Chat\n+┊  ┊14┊      scalars:\n+┊  ┊15┊        # e.g. Message.createdAt will be of type Date\n+┊  ┊16┊        Date: Date\n```\n\n[}]: #\n\n> See inline comments to learn more about our configuration setup.\n\nNow if you'll run `$ npm run codegen` you should see that a new file `types/graphql.d.ts` has been generated with all the necessary TypeScript types. Since these types are very likely to change as we extend our schema, there's no need to include them in our project, thus it's recommended to add the appropriate .gitignore rule:\n\n[{]: <helper> (diffStep 6.1 files=\".gitignore\" module=\"server\")\n\n#### [__Server__ Step 6.1: Setup GraphQL Code Generator](https://github.com/Urigo/WhatsApp-Clone-Server/commit/1494ed1)\n\n##### Changed .gitignore\n```diff\n@@ -1,3 +1,4 @@\n ┊1┊1┊node_modules\n ┊2┊2┊npm-debug.log\n-┊3┊ ┊test-results/🚫↵\n+┊ ┊3┊test-results/\n+┊ ┊4┊types/graphql.d.ts🚫↵\n```\n\n[}]: #\n\nNow we can import the `IResolvers` type from the file we've just created and use it in the `resolvers.ts` file to ensure our resolvers handlers have the right signature:\n\n[{]: <helper> (diffStep 6.2 module=\"server\")\n\n#### [__Server__ Step 6.2: Type resolvers](https://github.com/Urigo/WhatsApp-Clone-Server/commit/d1c9fbb)\n\n##### Changed schema&#x2F;index.ts\n```diff\n@@ -1,7 +1,10 @@\n ┊ 1┊ 1┊import { importSchema } from 'graphql-import';\n-┊ 2┊  ┊import { makeExecutableSchema } from 'graphql-tools';\n+┊  ┊ 2┊import { makeExecutableSchema, IResolvers } from 'graphql-tools';\n ┊ 3┊ 3┊import resolvers from './resolvers';\n ┊ 4┊ 4┊\n ┊ 5┊ 5┊const typeDefs = importSchema('schema/typeDefs.graphql');\n ┊ 6┊ 6┊\n-┊ 7┊  ┊export default makeExecutableSchema({ resolvers, typeDefs });\n+┊  ┊ 7┊export default makeExecutableSchema({\n+┊  ┊ 8┊  resolvers: resolvers as IResolvers,\n+┊  ┊ 9┊  typeDefs,\n+┊  ┊10┊});\n```\n\n##### Changed schema&#x2F;resolvers.ts\n```diff\n@@ -1,18 +1,19 @@\n ┊ 1┊ 1┊import { GraphQLDateTime } from 'graphql-iso-date';\n-┊ 2┊  ┊import { chats, messages } from '../db';\n+┊  ┊ 2┊import { Message, chats, messages } from '../db';\n+┊  ┊ 3┊import { Resolvers } from '../types/graphql';\n ┊ 3┊ 4┊\n-┊ 4┊  ┊const resolvers = {\n+┊  ┊ 5┊const resolvers: Resolvers = {\n ┊ 5┊ 6┊  Date: GraphQLDateTime,\n ┊ 6┊ 7┊\n ┊ 7┊ 8┊  Chat: {\n-┊ 8┊  ┊    messages(chat: any) {\n+┊  ┊ 9┊    messages(chat) {\n ┊ 9┊10┊      return messages.filter(m => chat.messages.includes(m.id));\n ┊10┊11┊    },\n ┊11┊12┊\n-┊12┊  ┊    lastMessage(chat: any) {\n+┊  ┊13┊    lastMessage(chat) {\n ┊13┊14┊      const lastMessage = chat.messages[chat.messages.length - 1];\n ┊14┊15┊\n-┊15┊  ┊      return messages.find(m => m.id === lastMessage);\n+┊  ┊16┊      return messages.find(m => m.id === lastMessage) || null;\n ┊16┊17┊    },\n ┊17┊18┊  },\n ┊18┊19┊\n```\n```diff\n@@ -21,13 +22,13 @@\n ┊21┊22┊      return chats;\n ┊22┊23┊    },\n ┊23┊24┊\n-┊24┊  ┊    chat(root: any, { chatId }: any) {\n-┊25┊  ┊      return chats.find(c => c.id === chatId);\n+┊  ┊25┊    chat(root, { chatId }) {\n+┊  ┊26┊      return chats.find(c => c.id === chatId) || null;\n ┊26┊27┊    },\n ┊27┊28┊  },\n ┊28┊29┊\n ┊29┊30┊  Mutation: {\n-┊30┊  ┊    addMessage(root: any, { chatId, content }: any) {\n+┊  ┊31┊    addMessage(root, { chatId, content }) {\n ┊31┊32┊      const chatIndex = chats.findIndex(c => c.id === chatId);\n ┊32┊33┊\n ┊33┊34┊      if (chatIndex === -1) return null;\n```\n```diff\n@@ -35,7 +36,7 @@\n ┊35┊36┊      const chat = chats[chatIndex];\n ┊36┊37┊      const recentMessage = messages[messages.length - 1];\n ┊37┊38┊      const messageId = String(Number(recentMessage.id) + 1);\n-┊38┊  ┊      const message = {\n+┊  ┊39┊      const message: Message = {\n ┊39┊40┊        id: messageId,\n ┊40┊41┊        createdAt: new Date(),\n ┊41┊42┊        content,\n```\n\n[}]: #\n\nWe will now repeat the same process in the client with few tweaks. Again, we will install GraphQL Code Generator:\n\n    $ yarn add @graphql-codegen/cli --dev\n\nAnd we will define a script:\n\n```json\n{\n  \"codegen\": \"gql-gen\"\n}\n```\n\nThis time around, because we're in the client, we will define a set of glob paths that will specify which files contain GraphQL documents.\nGraphQL Code Generator is smart enough to automatically recognize the documents within these files by looking at the `gql` template literal calls using the `typescript-operations` package.\nWe will be using a plugin called `typescript-react-apollo` to generate React/Apollo-GraphQL hooks that can be used in our function components.\nLet's install the necessary plugins:\n\n    $ yarn add @graphql-codegen/cli @graphql-codegen/typescript @graphql-codegen/typescript-operations @graphql-codegen/typescript-react-apollo @graphql-codegen/add\n\n\nAnd we will write the `codegen.yml` file:\n\n[{]: <helper> (diffStep 9.1 files=\"codegen.yml\" module=\"client\")\n\n#### [__Client__ Step 9.1: Setup GraphQL Code Generator](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/857f871)\n\n##### Added codegen.yml\n```diff\n@@ -0,0 +1,20 @@\n+┊  ┊ 1┊schema: ../Whatsapp-Clone-Server/schema/typeDefs.graphql\n+┊  ┊ 2┊documents:\n+┊  ┊ 3┊  - ./src/components/**/*.tsx\n+┊  ┊ 4┊  - ./src/graphql/fragments/**/*.ts\n+┊  ┊ 5┊  - ./src/graphql/queries/**/*.ts\n+┊  ┊ 6┊overwrite: true\n+┊  ┊ 7┊generates:\n+┊  ┊ 8┊  ./src/graphql/types.tsx:\n+┊  ┊ 9┊    plugins:\n+┊  ┊10┊      - add: '/* eslint-disable */'\n+┊  ┊11┊      - typescript\n+┊  ┊12┊      - typescript-operations\n+┊  ┊13┊      - typescript-react-apollo\n+┊  ┊14┊    # The combined options of all provided plug-ins\n+┊  ┊15┊    # More information about the options below:\n+┊  ┊16┊    # graphql-code-generator.com/docs/plugins/typescript-react-apollo#configuration\n+┊  ┊17┊    config:\n+┊  ┊18┊      withHOC: false\n+┊  ┊19┊      withHooks: true\n+┊  ┊20┊      withComponent: false\n```\n\n[}]: #\n\nNotice that we sent the schema as a local path.\nWe could have also provided a GraphQL endpoint that exposes a GraphQL schema.\nThis way if there's an existing running GraphQL API, we can generate TypeScript types out of it, such as GitHub's GraphQL API.\nThe advantages of providing a local path is that the server doesn't have to be running in order to generate types, which is more comfortable in development, and we can bypass authentication if the endpoint is guarded with such mechanism.\nThis will be useful in further chapters when we're introduced to the concept of authentication.\n\nBe sure to add a .gitignore rule because we want to run the generator every time there is a change and don't want to rely on old generated types:\n\n[{]: <helper> (diffStep 9.1 files=\".gitignore\" module=\"client\")\n\n#### [__Client__ Step 9.1: Setup GraphQL Code Generator](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/857f871)\n\n##### Changed .gitignore\n```diff\n@@ -21,3 +21,5 @@\n ┊21┊21┊npm-debug.log*\n ┊22┊22┊yarn-debug.log*\n ┊23┊23┊yarn-error.log*\n+┊  ┊24┊\n+┊  ┊25┊src/graphql/types.tsx\n```\n\n[}]: #\n\nNow we have TypeScript types available to us and we can replace `useQuery()` and `useMutation()` calls with the generated React hooks.\nLet's use those and also remove all the old manual typings:\n\n[{]: <helper> (diffStep 9.2 module=\"client\")\n\n#### [__Client__ Step 9.2: Use GraphQL Codegen hooks](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/4426b62)\n\n##### Changed src&#x2F;components&#x2F;ChatRoomScreen&#x2F;ChatNavbar.tsx\n```diff\n@@ -5,7 +5,6 @@\n ┊ 5┊ 5┊import { useCallback } from 'react';\n ┊ 6┊ 6┊import styled from 'styled-components';\n ┊ 7┊ 7┊import { History } from 'history';\n-┊ 8┊  ┊import { ChatQueryResult } from './index';\n ┊ 9┊ 8┊\n ┊10┊ 9┊const Container = styled(Toolbar)`\n ┊11┊10┊  padding: 0;\n```\n```diff\n@@ -37,7 +36,10 @@\n ┊37┊36┊\n ┊38┊37┊interface ChatNavbarProps {\n ┊39┊38┊  history: History;\n-┊40┊  ┊  chat: ChatQueryResult;\n+┊  ┊39┊  chat?: {\n+┊  ┊40┊    picture?: string | null;\n+┊  ┊41┊    name?: string | null;\n+┊  ┊42┊  };\n ┊41┊43┊}\n ┊42┊44┊\n ┊43┊45┊const ChatNavbar: React.FC<ChatNavbarProps> = ({ chat, history }) => {\n```\n```diff\n@@ -50,8 +52,12 @@\n ┊50┊52┊      <BackButton data-testid=\"back-button\" onClick={navBack}>\n ┊51┊53┊        <ArrowBackIcon />\n ┊52┊54┊      </BackButton>\n-┊53┊  ┊      <Picture data-testid=\"chat-picture\" src={chat.picture} />\n-┊54┊  ┊      <Name data-testid=\"chat-name\">{chat.name}</Name>\n+┊  ┊55┊      {chat && chat.picture && chat.name && (\n+┊  ┊56┊        <React.Fragment>\n+┊  ┊57┊          <Picture data-testid=\"chat-picture\" src={chat.picture} />\n+┊  ┊58┊          <Name data-testid=\"chat-name\">{chat.name}</Name>\n+┊  ┊59┊        </React.Fragment>\n+┊  ┊60┊      )}\n ┊55┊61┊    </Container>\n ┊56┊62┊  );\n ┊57┊63┊};\n```\n\n##### Changed src&#x2F;components&#x2F;ChatRoomScreen&#x2F;MessagesList.tsx\n```diff\n@@ -3,7 +3,6 @@\n ┊3┊3┊import { useEffect, useRef } from 'react';\n ┊4┊4┊import ReactDOM from 'react-dom';\n ┊5┊5┊import styled from 'styled-components';\n-┊6┊ ┊import { ChatQueryMessage } from './index';\n ┊7┊6┊\n ┊8┊7┊const Container = styled.div`\n ┊9┊8┊  display: block;\n```\n```diff\n@@ -62,8 +61,13 @@\n ┊62┊61┊  font-size: 12px;\n ┊63┊62┊`;\n ┊64┊63┊\n+┊  ┊64┊interface Message {\n+┊  ┊65┊  id: string | null;\n+┊  ┊66┊  content: string | null;\n+┊  ┊67┊  createdAt: string | null;\n+┊  ┊68┊}\n ┊65┊69┊interface MessagesListProps {\n-┊66┊  ┊  messages: Array<ChatQueryMessage>;\n+┊  ┊70┊  messages: Array<Message>;\n ┊67┊71┊}\n ┊68┊72┊\n ┊69┊73┊const MessagesList: React.FC<MessagesListProps> = ({ messages }) => {\n```\n\n##### Changed src&#x2F;components&#x2F;ChatRoomScreen&#x2F;index.tsx\n```diff\n@@ -2,12 +2,12 @@\n ┊ 2┊ 2┊import gql from 'graphql-tag';\n ┊ 3┊ 3┊import React from 'react';\n ┊ 4┊ 4┊import { useCallback } from 'react';\n-┊ 5┊  ┊import { useQuery, useMutation } from 'react-apollo-hooks';\n ┊ 6┊ 5┊import styled from 'styled-components';\n ┊ 7┊ 6┊import ChatNavbar from './ChatNavbar';\n ┊ 8┊ 7┊import MessageInput from './MessageInput';\n ┊ 9┊ 8┊import MessagesList from './MessagesList';\n ┊10┊ 9┊import { History } from 'history';\n+┊  ┊10┊import { ChatsQuery, useGetChatQuery, useAddMessageMutation } from '../../graphql/types';\n ┊11┊11┊import * as queries from '../../graphql/queries';\n ┊12┊12┊import * as fragments from '../../graphql/fragments';\n ┊13┊13┊\n```\n```diff\n@@ -18,6 +18,7 @@\n ┊18┊18┊  height: 100vh;\n ┊19┊19┊`;\n ┊20┊20┊\n+┊  ┊21┊// eslint-disable-next-line\n ┊21┊22┊const getChatQuery = gql`\n ┊22┊23┊  query GetChat($chatId: ID!) {\n ┊23┊24┊    chat(chatId: $chatId) {\n```\n```diff\n@@ -27,6 +28,7 @@\n ┊27┊28┊  ${fragments.fullChat}\n ┊28┊29┊`;\n ┊29┊30┊\n+┊  ┊31┊// eslint-disable-next-line\n ┊30┊32┊const addMessageMutation = gql`\n ┊31┊33┊  mutation AddMessage($chatId: ID!, $content: String!) {\n ┊32┊34┊    addMessage(chatId: $chatId, content: $content) {\n```\n```diff\n@@ -41,21 +43,6 @@\n ┊41┊43┊  history: History;\n ┊42┊44┊}\n ┊43┊45┊\n-┊44┊  ┊export interface ChatQueryMessage {\n-┊45┊  ┊  id: string;\n-┊46┊  ┊  content: string;\n-┊47┊  ┊  createdAt: number;\n-┊48┊  ┊}\n-┊49┊  ┊\n-┊50┊  ┊export interface ChatQueryResult {\n-┊51┊  ┊  id: string;\n-┊52┊  ┊  name: string;\n-┊53┊  ┊  picture: string;\n-┊54┊  ┊  messages: Array<ChatQueryMessage>;\n-┊55┊  ┊}\n-┊56┊  ┊\n-┊57┊  ┊type OptionalChatQueryResult = ChatQueryResult | null;\n-┊58┊  ┊\n ┊59┊46┊interface ChatsResult {\n ┊60┊47┊  chats: any[];\n ┊61┊48┊}\n```\n```diff\n@@ -64,15 +51,20 @@\n ┊64┊51┊  history,\n ┊65┊52┊  chatId,\n ┊66┊53┊}) => {\n-┊67┊  ┊  const {\n-┊68┊  ┊    data: { chat },\n-┊69┊  ┊  } = useQuery<any>(getChatQuery, {\n+┊  ┊54┊  const { data, loading } = useGetChatQuery({\n ┊70┊55┊    variables: { chatId },\n ┊71┊56┊  });\n-┊72┊  ┊  const addMessage = useMutation(addMessageMutation);\n+┊  ┊57┊\n+┊  ┊58┊  const addMessage = useAddMessageMutation();\n ┊73┊59┊\n ┊74┊60┊  const onSendMessage = useCallback(\n ┊75┊61┊    (content: string) => {\n+┊  ┊62┊      if (data === undefined) {\n+┊  ┊63┊        return null;\n+┊  ┊64┊      }\n+┊  ┊65┊      const chat = data.chat;\n+┊  ┊66┊      if (chat === null) return null;\n+┊  ┊67┊\n ┊76┊68┊      addMessage({\n ┊77┊69┊        variables: { chatId, content },\n ┊78┊70┊        optimisticResponse: {\n```\n```diff\n@@ -89,12 +81,12 @@\n ┊ 89┊ 81┊        update: (client, { data: { addMessage } }) => {\n ┊ 90┊ 82┊          type FullChat = { [key: string]: any };\n ┊ 91┊ 83┊          let fullChat;\n-┊ 92┊   ┊          const chatIdFromStore = defaultDataIdFromObject(chat);\n+┊   ┊ 84┊\n+┊   ┊ 85┊          const chatIdFromStore = defaultDataIdFromObject(addMessage.chat);\n ┊ 93┊ 86┊\n ┊ 94┊ 87┊          if (chatIdFromStore === null) {\n ┊ 95┊ 88┊            return;\n ┊ 96┊ 89┊          }\n-┊ 97┊   ┊\n ┊ 98┊ 90┊          try {\n ┊ 99┊ 91┊            fullChat = client.readFragment<FullChat>({\n ┊100┊ 92┊              id: chatIdFromStore,\n```\n```diff\n@@ -105,13 +97,12 @@\n ┊105┊ 97┊            return;\n ┊106┊ 98┊          }\n ┊107┊ 99┊\n-┊108┊   ┊          if (fullChat === null) {\n+┊   ┊100┊          if (fullChat === null || fullChat.messages === null) {\n ┊109┊101┊            return;\n ┊110┊102┊          }\n-┊111┊   ┊          if (fullChat.messages.some((m: any) => m.id === addMessage.id))\n-┊112┊   ┊            return;\n+┊   ┊103┊          if (fullChat.messages.messages.some((m: any) => m.id === addMessage.id)) return;\n ┊113┊104┊\n-┊114┊   ┊          fullChat.messages.push(addMessage);\n+┊   ┊105┊          fullChat.messages.messages.push(addMessage);\n ┊115┊106┊          fullChat.lastMessage = addMessage;\n ┊116┊107┊\n ┊117┊108┊          client.writeFragment({\n```\n```diff\n@@ -121,24 +112,24 @@\n ┊121┊112┊            data: fullChat,\n ┊122┊113┊          });\n ┊123┊114┊\n-┊124┊   ┊          let data;\n+┊   ┊115┊          let data: ChatsQuery | null;\n ┊125┊116┊          try {\n-┊126┊   ┊            data = client.readQuery<ChatsResult>({\n+┊   ┊117┊            data = client.readQuery({\n ┊127┊118┊              query: queries.chats,\n ┊128┊119┊            });\n ┊129┊120┊          } catch (e) {\n ┊130┊121┊            return;\n ┊131┊122┊          }\n ┊132┊123┊\n-┊133┊   ┊          if (!data || data === null) {\n-┊134┊   ┊            return null;\n-┊135┊   ┊          }\n-┊136┊   ┊          if (!data.chats || data.chats === undefined) {\n+┊   ┊124┊          if (!data || !data.chats) {\n ┊137┊125┊            return null;\n ┊138┊126┊          }\n ┊139┊127┊          const chats = data.chats;\n ┊140┊128┊\n-┊141┊   ┊          const chatIndex = chats.findIndex((c: any) => c.id === chatId);\n+┊   ┊129┊          const chatIndex = chats.findIndex((c: any) => {\n+┊   ┊130┊            if (addMessage === null || addMessage.chat === null) return -1;\n+┊   ┊131┊            return c.id === addMessage.chat.id;\n+┊   ┊132┊          });\n ┊142┊133┊          if (chatIndex === -1) return;\n ┊143┊134┊          const chatWhereAdded = chats[chatIndex];\n ┊144┊135┊\n```\n```diff\n@@ -153,10 +144,17 @@\n ┊153┊144┊        },\n ┊154┊145┊      });\n ┊155┊146┊    },\n-┊156┊   ┊    [chat, chatId, addMessage]\n+┊   ┊147┊    [data, chatId, addMessage]\n ┊157┊148┊  );\n ┊158┊149┊\n-┊159┊   ┊  if (!chat) return null;\n+┊   ┊150┊  if (data === undefined) {\n+┊   ┊151┊    return null;\n+┊   ┊152┊  }\n+┊   ┊153┊  const chat = data.chat;\n+┊   ┊154┊  const loadingChat = loading;\n+┊   ┊155┊\n+┊   ┊156┊  if (loadingChat) return null;\n+┊   ┊157┊  if (chat === null) return null;\n ┊160┊158┊\n ┊161┊159┊  return (\n ┊162┊160┊    <Container>\n```\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;ChatsList.tsx\n```diff\n@@ -4,8 +4,7 @@\n ┊ 4┊ 4┊import styled from 'styled-components';\n ┊ 5┊ 5┊import { useCallback } from 'react';\n ┊ 6┊ 6┊import { History } from 'history';\n-┊ 7┊  ┊import { useQuery } from 'react-apollo-hooks';\n-┊ 8┊  ┊import * as queries from '../../graphql/queries';\n+┊  ┊ 7┊import { useChatsQuery } from '../../graphql/types';\n ┊ 9┊ 8┊\n ┊10┊ 9┊const Container = styled.div`\n ┊11┊10┊  height: calc(100% - 56px);\n```\n```diff\n@@ -64,10 +63,6 @@\n ┊64┊63┊}\n ┊65┊64┊\n ┊66┊65┊const ChatsList: React.FC<ChatsListProps> = ({ history }) => {\n-┊67┊  ┊  const {\n-┊68┊  ┊    data: { chats = [] },\n-┊69┊  ┊  } = useQuery<any>(queries.chats);\n-┊70┊  ┊\n ┊71┊66┊  const navToChat = useCallback(\n ┊72┊67┊    chat => {\n ┊73┊68┊      history.push(`chats/${chat.id}`);\n```\n```diff\n@@ -75,6 +70,14 @@\n ┊75┊70┊    [history]\n ┊76┊71┊  );\n ┊77┊72┊\n+┊  ┊73┊  const { data } = useChatsQuery();\n+┊  ┊74┊\n+┊  ┊75┊  if (data === undefined || data.chats === undefined) {\n+┊  ┊76┊    return null;\n+┊  ┊77┊  }\n+┊  ┊78┊\n+┊  ┊79┊  let chats = data.chats;\n+┊  ┊80┊\n ┊78┊81┊  return (\n ┊79┊82┊    <Container>\n ┊80┊83┊      <StyledList>\n```\n\n[}]: #\n\nTo test if things are working properly, we can address a non existing field in one of the retrieved query results, for example `chat.foo` in `useGetChatQuery()`.\nWe should receive the following typing error when trying to run the project:\n\n```\nTypeScript error: Property 'foo' does not exist on type '{ __typename?: \"Chat\"; } & { __typename?: \"Chat\"; } & { messages: ({ __typename?: \"Message\"; } & { __typename?: \"Message\"; } & Pick<Message, \"id\" | \"createdAt\" | \"content\">)[]; } & { __typename?: \"Chat\"; } & Pick<...> & { ...; }'.  TS2339\n\n    44 |   const addMessage = useAddMessageMutation()\n    45 |\n  > 46 |   console.log(chat.foo)\n       |                    ^\n    47 |\n    48 |   const onSendMessage = useCallback((content) => {\n    49 |     addMessage({\n```\n\nTODO: Mappers are not explained - The root types of Message resolvers - doesn’t say much\nwe don’t need to use `resolvers as IResolvers`, there’s a flag for it, in codegen\n\nTODO: Change `gql-gen` to `graphql-codegen`"
          },
          {
            "manualTitle": "Step 10: Live updates with GraphQL subscriptions",
            "stepRevision": "82379c272c03e4e1f598214d76bf27be9febd077",
            "manualView": "So far we've been developing the app and we've been treating it as if there's no other users; we're the only one exists.\nThis approach is true when we want to develop a UI and focus on UX, but comes a point where we need to start thinking on a macro level.\nOur app is social interactive, and if things work properly for me, it doesn't mean that it works properly to the fellow I'm chatting with.\nIt's inevitable to have an authentication system in our app, hence we need to take care of things before we get to that stage.\n\nTry to open 2 instances of the app in 2 separate tabs/windows, and navigate into the same chat room.\nTry to send a message with one instance and notice that the second instance doesn't update unless we refresh the page.\n\n\n![ezgif com-video-to-gif (2)](https://user-images.githubusercontent.com/7648874/55079371-fbd87080-50d6-11e9-8ade-5ffeed6eaf8d.gif)\n\n\nThis issue is very important and should be addressed, because a chat is all about sending and receiving messages on a lively basis.\nThis issue was expected, as there's no mechanism that would trigger and listen to changes in the back-end.\nIn this chapter we're gonna address that issue by implementing exactly that mechanism.\n\n**Introducing: GraphQL Subscriptions**\n\n[GraphQL subscriptions](https://github.com/apollographql/graphql-subscriptions) is a mechanism that works on [web-sockets](https://en.wikipedia.org/wiki/WebSocket) and live communication; clients can subscribe to it and be notified regards specific changes that happen in the back-end. Notifications will be triggered manually by us and can be provided with parameters that provide additional information regards the triggered event. For example, a `messageAdded` will be published with the new message, and will notify all clients who are subscribed to that event. Once the subscribers are notified, they can respond as they would like to, such as updating the UI.\n\n\n\n![subscription-notifications](https://user-images.githubusercontent.com/7648874/55079462-30e4c300-50d7-11e9-8399-7706da2a9cff.png)\n\n\nA subscription is presented in our GraphQL schema as a separate type called `Subscription`, where each field represents an event name along with its return type.\nLike any other GraphQL type, each field should be match with a resolver where we handle the request.\n\nIn this chapter we will implement the `messageAdded` subscription, so users can be notified when it happens and update the messages list to contain the new message.\n\n**Implementing a subscription**\n\nWe will start by creating a new `Subscription` type in our GraphQL schema with the field `messageAdded`:\n\n[{]: <helper> (diffStep 7.1 module=\"server\")\n\n#### [__Server__ Step 7.1: Add subscription type with messageAdded](https://github.com/Urigo/WhatsApp-Clone-Server/commit/54efd6f)\n\n##### Changed schema&#x2F;typeDefs.graphql\n```diff\n@@ -22,3 +22,7 @@\n ┊22┊22┊type Mutation {\n ┊23┊23┊  addMessage(chatId: ID!, content: String!): Message\n ┊24┊24┊}\n+┊  ┊25┊\n+┊  ┊26┊type Subscription {\n+┊  ┊27┊  messageAdded: Message!\n+┊  ┊28┊}\n```\n\n[}]: #\n\nChanges are triggered using an event-emitter like object called `PubSub`. This can be done using the `PubSub.prototype.publish` method. We will create a new instance of it and will provide it via the [context](https://www.apollographql.com/docs/apollo-server/essentials/data#context) - a common pattern for providing objects which are useful for the execution of the resolvers:\n\nTODO: Explain what the context is\n\n[{]: <helper> (diffStep 7.2 module=\"server\")\n\n#### [__Server__ Step 7.2: Provide a new instance of PubSub to context](https://github.com/Urigo/WhatsApp-Clone-Server/commit/91b92d0)\n\n##### Changed index.ts\n```diff\n@@ -1,4 +1,4 @@\n-┊1┊ ┊import { ApolloServer, gql } from 'apollo-server-express';\n+┊ ┊1┊import { ApolloServer, gql, PubSub } from 'apollo-server-express';\n ┊2┊2┊import bodyParser from 'body-parser';\n ┊3┊3┊import cors from 'cors';\n ┊4┊4┊import express from 'express';\n```\n```diff\n@@ -13,7 +13,11 @@\n ┊13┊13┊  res.send('pong');\n ┊14┊14┊});\n ┊15┊15┊\n-┊16┊  ┊const server = new ApolloServer({ schema });\n+┊  ┊16┊const pubsub = new PubSub();\n+┊  ┊17┊const server = new ApolloServer({\n+┊  ┊18┊  schema,\n+┊  ┊19┊  context: () => ({ pubsub }),\n+┊  ┊20┊});\n ┊17┊21┊\n ┊18┊22┊server.applyMiddleware({\n ┊19┊23┊  app,\n```\n\n[}]: #\n\nInside the `addMessage` resolver we will publish a new event called `messageAdded`. The 3rd argument of the resolver will be the context object that we've just defined in the previous step, where we can use the pubsub instance. The TypeScript type of our context can be directly defined and generated by CodeGen through the `codegen.yml` file. This can be specified under the `ContextType` field with the file path that contains the context followed by the name of the exported object, like so:\n\n[{]: <helper> (diffStep 7.3 module=\"server\")\n\n#### [__Server__ Step 7.3: Define Context type](https://github.com/Urigo/WhatsApp-Clone-Server/commit/94689cb)\n\n##### Changed codegen.yml\n```diff\n@@ -6,6 +6,7 @@\n ┊ 6┊ 6┊      - typescript\n ┊ 7┊ 7┊      - typescript-resolvers\n ┊ 8┊ 8┊    config:\n+┊  ┊ 9┊      contextType: ../context#MyContext\n ┊ 9┊10┊      mappers:\n ┊10┊11┊        # import { Message } from '../db'\n ┊11┊12┊        # The root types of Message resolvers\n```\n\n##### Added context.ts\n```diff\n@@ -0,0 +1,5 @@\n+┊ ┊1┊import { PubSub } from 'apollo-server-express';\n+┊ ┊2┊\n+┊ ┊3┊export type MyContext = {\n+┊ ┊4┊  pubsub: PubSub;\n+┊ ┊5┊};\n```\n\n[}]: #\n\nThe event will be published right after the message was pushed into the messages collection, because order is a crucial thing. We don't want to notify our users unless the change has been made. The event will have a single parameter which represents the new message.\n\n[{]: <helper> (diffStep 7.4 module=\"server\")\n\n#### [__Server__ Step 7.4: Publish message added event](https://github.com/Urigo/WhatsApp-Clone-Server/commit/e034daa)\n\n##### Changed schema&#x2F;resolvers.ts\n```diff\n@@ -28,7 +28,7 @@\n ┊28┊28┊  },\n ┊29┊29┊\n ┊30┊30┊  Mutation: {\n-┊31┊  ┊    addMessage(root, { chatId, content }) {\n+┊  ┊31┊    addMessage(root, { chatId, content }, { pubsub }) {\n ┊32┊32┊      const chatIndex = chats.findIndex(c => c.id === chatId);\n ┊33┊33┊\n ┊34┊34┊      if (chatIndex === -1) return null;\n```\n```diff\n@@ -48,6 +48,10 @@\n ┊48┊48┊      chats.splice(chatIndex, 1);\n ┊49┊49┊      chats.unshift(chat);\n ┊50┊50┊\n+┊  ┊51┊      pubsub.publish('messageAdded', {\n+┊  ┊52┊        messageAdded: message,\n+┊  ┊53┊      });\n+┊  ┊54┊\n ┊51┊55┊      return message;\n ┊52┊56┊    },\n ┊53┊57┊  },\n```\n\n##### Changed tests&#x2F;mutations&#x2F;addMessage.test.ts\n```diff\n@@ -1,5 +1,5 @@\n ┊1┊1┊import { createTestClient } from 'apollo-server-testing';\n-┊2┊ ┊import { ApolloServer, gql } from 'apollo-server-express';\n+┊ ┊2┊import { ApolloServer, PubSub, gql } from 'apollo-server-express';\n ┊3┊3┊import schema from '../../schema';\n ┊4┊4┊import { resetDb } from '../../db';\n ┊5┊5┊\n```\n```diff\n@@ -7,7 +7,10 @@\n ┊ 7┊ 7┊  beforeEach(resetDb);\n ┊ 8┊ 8┊\n ┊ 9┊ 9┊  it('should add message to specified chat', async () => {\n-┊10┊  ┊    const server = new ApolloServer({ schema });\n+┊  ┊10┊    const server = new ApolloServer({\n+┊  ┊11┊      schema,\n+┊  ┊12┊      context: () => ({ pubsub: new PubSub() }),\n+┊  ┊13┊    });\n ┊11┊14┊\n ┊12┊15┊    const { query, mutate } = createTestClient(server);\n```\n\n[}]: #\n\nA subscription resolver behaves differently and thus should be implemented differently. Using the `pubsub.asyncIterator` instance, we can specify which events are relevant for the subscription, for example, all clients who are subscribers of the `chatUpdated` subscription will be notified when `messageAdded`, `messageRemoved` and `chatInfoChanged` events were triggered. For now, we will have a 1 to 1 relationship between the `messageAdded` event and `messageAdded` subscription. In code, it should look like this:\n\n[{]: <helper> (diffStep 7.5 module=\"server\")\n\n#### [__Server__ Step 7.5: Add Subscription.messageAdded resolver](https://github.com/Urigo/WhatsApp-Clone-Server/commit/f5e3afe)\n\n##### Changed schema&#x2F;resolvers.ts\n```diff\n@@ -55,6 +55,13 @@\n ┊55┊55┊      return message;\n ┊56┊56┊    },\n ┊57┊57┊  },\n+┊  ┊58┊\n+┊  ┊59┊  Subscription: {\n+┊  ┊60┊    messageAdded: {\n+┊  ┊61┊      subscribe: (root, args, { pubsub }) =>\n+┊  ┊62┊        pubsub.asyncIterator('messageAdded'),\n+┊  ┊63┊    },\n+┊  ┊64┊  },\n ┊58┊65┊};\n ┊59┊66┊\n ┊60┊67┊export default resolvers;\n```\n\n[}]: #\n\nThe idea behind the `pubsub.asyncIterator` method is that it returns an [`Iterator`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators#Iterators) like object, where each value is a promise that will be resolved when the relevant events are triggered. By default, the parameter that has a similar name to the subscription will be returned as a response, e.g. `messageAdded` parameter will be sent back to the subscribers. This behavior can be modified as explained [here](https://github.com/apollographql/graphql-subscriptions#payload-manipulation), but it's very unlikely and not necessary for our use case.\n\nAs mentioned at the beginning of this article, there needs to be an open connection between the client and the server so live updates can happen. There are serveral methods for doing so, but the 2 most popular ones are:\n\n\n\n*   Based on polling with HTTP protocol\n*   Based on web-sockets (WS protocol)\n\nHTTP polling means that each amount of time an HTTP request will be made to the server where potential changes can be sent back to us at any given time. HTTP requests are very reliable, but the problem with them is that they contain a lot of information in their headers, so even if we sent an empty request, it might be still very heavy due to cookies, user-agent, language, request type, etc.\n\nWith web-sockets, once a connection has been established, it will remain open and it will only send the information which is relevant for the current session, so it's much faster. The communication is between the server and the client is bi-directional when it comes to web-sockets, which means that a user can spontaneously receive information from the server, as long as the communication channel remains open.\n\n> More information about the advantages of Web Sockets over HTTP can be found at [websocket.org](http://websocket.org/quantum.html)\n\nThe subscription mechanism can be installed using the `server.installSubscriptionHandlers`. It will use the WS protocol by default and will fallback to HTTP polling if there were troubles establishing a connection via WS protocol:\n\n[{]: <helper> (diffStep 7.6 module=\"server\")\n\n#### [__Server__ Step 7.6: Install subscription handlers](https://github.com/Urigo/WhatsApp-Clone-Server/commit/688c3f2)\n\n##### Changed index.ts\n```diff\n@@ -2,6 +2,7 @@\n ┊2┊2┊import bodyParser from 'body-parser';\n ┊3┊3┊import cors from 'cors';\n ┊4┊4┊import express from 'express';\n+┊ ┊5┊import http from 'http';\n ┊5┊6┊import schema from './schema';\n ┊6┊7┊\n ┊7┊8┊const app = express();\n```\n```diff\n@@ -24,8 +25,11 @@\n ┊24┊25┊  path: '/graphql',\n ┊25┊26┊});\n ┊26┊27┊\n+┊  ┊28┊const httpServer = http.createServer(app);\n+┊  ┊29┊server.installSubscriptionHandlers(httpServer);\n+┊  ┊30┊\n ┊27┊31┊const port = process.env.PORT || 4000;\n ┊28┊32┊\n-┊29┊  ┊app.listen(port, () => {\n+┊  ┊33┊httpServer.listen(port, () => {\n ┊30┊34┊  console.log(`Server is listening on port ${port}`);\n ┊31┊35┊});\n```\n\n[}]: #\n\nNow we have everything set and we can start listening to subscriptions and react to to triggered changes.\n\n**Using subscriptions**\n\nTo support subscriptions we need to establish a WS connection. For that we will need to update our Apollo client. We will install a couple of packages that will enable such feature:\n\n    $ yarn add subscriptions-transport-ws apollo-link apollo-link-ws apollo-utilities\n\n\n*   [`subscriptions-transport-ws`](https://www.npmjs.com/package/subscriptions-transport-ws) - a transport layer that understands how client and GraphQL API communicates with each other. The spec has GQL_INIT GQL_UPDATE GQL_DATA events.\n*   [`apollo-link-ws`](https://www.npmjs.com/package/apollo-link-ws) - Will establish a WS connection.\n*   [`apollo-link`](https://www.npmjs.com/package/apollo-link) - Will enable WS and HTTP connections co-exist in a single client.\n*   [`apollo-utilities`](https://www.npmjs.com/package/apollo-utilities) - Includes utility functions that will help us analyze a GraphQL AST.\n\nThe WS url can be composed by simply running a regular expression over the `REACT_APP_SERVER_URL` environment variable and is unnecessary to be stored separately. Here's how our new client should look like: \\\n\n\n[{]: <helper> (diffStep 10.1 files=\"client\" module=\"client\")\n\n#### [__Client__ Step 10.1: Setup WS link](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/c7b1680)\n\n##### Changed src&#x2F;client.ts\n```diff\n@@ -1,16 +1,40 @@\n ┊ 1┊ 1┊import { InMemoryCache } from 'apollo-cache-inmemory';\n ┊ 2┊ 2┊import { ApolloClient } from 'apollo-client';\n+┊  ┊ 3┊import { getMainDefinition } from 'apollo-utilities';\n ┊ 3┊ 4┊import { HttpLink } from 'apollo-link-http';\n+┊  ┊ 5┊import { WebSocketLink } from 'apollo-link-ws';\n+┊  ┊ 6┊import { ApolloLink, split } from 'apollo-link';\n ┊ 4┊ 7┊\n ┊ 5┊ 8┊const httpUri = process.env.REACT_APP_SERVER_URL + '/graphql';\n+┊  ┊ 9┊const wsUri = httpUri.replace(/^https?/, 'ws');\n ┊ 6┊10┊\n ┊ 7┊11┊const httpLink = new HttpLink({\n ┊ 8┊12┊  uri: httpUri,\n ┊ 9┊13┊});\n ┊10┊14┊\n+┊  ┊15┊const wsLink = new WebSocketLink({\n+┊  ┊16┊  uri: wsUri,\n+┊  ┊17┊  options: {\n+┊  ┊18┊    // Automatic reconnect in case of connection error\n+┊  ┊19┊    reconnect: true,\n+┊  ┊20┊  },\n+┊  ┊21┊});\n+┊  ┊22┊\n+┊  ┊23┊const terminatingLink = split(\n+┊  ┊24┊  ({ query }) => {\n+┊  ┊25┊    const { kind, operation } = getMainDefinition(query);\n+┊  ┊26┊    // If this is a subscription query, use wsLink, otherwise use httpLink\n+┊  ┊27┊    return kind === 'OperationDefinition' && operation === 'subscription';\n+┊  ┊28┊  },\n+┊  ┊29┊  wsLink,\n+┊  ┊30┊  httpLink\n+┊  ┊31┊);\n+┊  ┊32┊\n+┊  ┊33┊const link = ApolloLink.from([terminatingLink]);\n+┊  ┊34┊\n ┊11┊35┊const inMemoryCache = new InMemoryCache();\n ┊12┊36┊\n ┊13┊37┊export default new ApolloClient({\n-┊14┊  ┊  link: httpLink,\n+┊  ┊38┊  link,\n ┊15┊39┊  cache: inMemoryCache,\n ┊16┊40┊});\n```\n\n[}]: #\n\nOur subscription listeners should live globally across our application and shouldn't be bound to a specific component, thus we will create an external service which will be responsible of doing so. Using that service, we will update our GraphQL data-store any time a new message has been added. We will define a `messageAdded` subscription in a dedicated file under the `src/graphql/subscriptions` dir where all our subscriptions will be defined and exported:\n\nTODO: - but they are anyway. It’s just a standalone function that is used in a component. Which makes no difference.\n\n[{]: <helper> (diffStep 10.2 module=\"client\")\n\n#### [__Client__ Step 10.2: Add messageAdded subscription document](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/a266b4f)\n\n##### Added src&#x2F;graphql&#x2F;subscriptions&#x2F;index.ts\n```diff\n@@ -0,0 +1 @@\n+┊ ┊1┊export { default as messageAdded } from './messageAdded.subscription';\n```\n\n##### Added src&#x2F;graphql&#x2F;subscriptions&#x2F;messageAdded.subscription.ts\n```diff\n@@ -0,0 +1,11 @@\n+┊  ┊ 1┊import gql from 'graphql-tag';\n+┊  ┊ 2┊import * as fragments from '../fragments';\n+┊  ┊ 3┊\n+┊  ┊ 4┊export default gql`\n+┊  ┊ 5┊  subscription MessageAdded {\n+┊  ┊ 6┊    messageAdded {\n+┊  ┊ 7┊      ...Message\n+┊  ┊ 8┊    }\n+┊  ┊ 9┊  }\n+┊  ┊10┊  ${fragments.message}\n+┊  ┊11┊`;\n```\n\n[}]: #\n\nNow we will create the service under the path `services/cache.service.ts`. Like any other GraphQL operation, `react-apollo-hooks` provides us with a dedicated React hook for subscriptions called `useSubscription`. Given the subscription document and the `onSubscriptionData` callback we can handle incoming changes. We will be using GraphQL Code Generator to generate typed subscription hooks, as the `typescript-react-apollo` plug-in supports it right out of the box. First let's update the `codegen.yml` file to look for documents in the `graphql/subscriptions` dir:\n\n[{]: <helper> (diffStep 10.3 module=\"client\")\n\n#### [__Client__ Step 10.3: Include subscription documents in codegen.yml](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/3fc354a)\n\n##### Changed codegen.yml\n```diff\n@@ -3,6 +3,7 @@\n ┊3┊3┊  - ./src/components/**/*.tsx\n ┊4┊4┊  - ./src/graphql/fragments/**/*.ts\n ┊5┊5┊  - ./src/graphql/queries/**/*.ts\n+┊ ┊6┊  - ./src/graphql/subscriptions/**/*.ts\n ┊6┊7┊overwrite: true\n ┊7┊8┊generates:\n ┊8┊9┊  ./src/graphql/types.tsx:\n```\n\n[}]: #\n\nAnd then we will type the code generation command:\n\n    $ npm run codegen\n\nNow we can import and use the newly generated hook `useMessageAddedSubscription` in the `cache.service`. Like mentioned earlier, we will be using the `onSubscriptionData` callback to retrieve the change that was sent by the server and we will use it to re-write our cache. In this case we will be writing a new fragment for the incoming message, and we will update the correlated chat:\n\n[{]: <helper> (diffStep 10.4 files=\"cache.service\" module=\"client\")\n\n#### [__Client__ Step 10.4: Update cache on message added](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/940853c)\n\n##### Added src&#x2F;services&#x2F;cache.service.ts\n```diff\n@@ -0,0 +1,86 @@\n+┊  ┊ 1┊import { DataProxy } from 'apollo-cache';\n+┊  ┊ 2┊import { defaultDataIdFromObject } from 'apollo-cache-inmemory';\n+┊  ┊ 3┊import { ApolloClient } from 'apollo-client';\n+┊  ┊ 4┊import * as fragments from '../graphql/fragments';\n+┊  ┊ 5┊import * as queries from '../graphql/queries';\n+┊  ┊ 6┊import { MessageFragment, useMessageAddedSubscription } from '../graphql/types';\n+┊  ┊ 7┊\n+┊  ┊ 8┊type Client = ApolloClient<any> | DataProxy;\n+┊  ┊ 9┊\n+┊  ┊10┊export const useCacheService = () => {\n+┊  ┊11┊  useMessageAddedSubscription({\n+┊  ┊12┊    onSubscriptionData: ({ client, subscriptionData: { data } }) => {\n+┊  ┊13┊      if (data) {\n+┊  ┊14┊        writeMessage(client, data.messageAdded);\n+┊  ┊15┊      }\n+┊  ┊16┊    },\n+┊  ┊17┊  });\n+┊  ┊18┊};\n+┊  ┊19┊\n+┊  ┊20┊export const writeMessage = (client: Client, message: MessageFragment) => {\n+┊  ┊21┊  type FullChat = { [key: string]: any };\n+┊  ┊22┊  let fullChat;\n+┊  ┊23┊\n+┊  ┊24┊  const chatIdFromStore = defaultDataIdFromObject(message.chat);\n+┊  ┊25┊\n+┊  ┊26┊  if (chatIdFromStore === null) {\n+┊  ┊27┊    return;\n+┊  ┊28┊  }\n+┊  ┊29┊  try {\n+┊  ┊30┊    fullChat = client.readFragment<FullChat>({\n+┊  ┊31┊      id: chatIdFromStore,\n+┊  ┊32┊      fragment: fragments.fullChat,\n+┊  ┊33┊      fragmentName: 'FullChat',\n+┊  ┊34┊    });\n+┊  ┊35┊  } catch (e) {\n+┊  ┊36┊    return;\n+┊  ┊37┊  }\n+┊  ┊38┊\n+┊  ┊39┊  if (fullChat === null || fullChat.messages === null) {\n+┊  ┊40┊    return;\n+┊  ┊41┊  }\n+┊  ┊42┊  if (fullChat.messages.some((m: any) => m.id === message.id)) return;\n+┊  ┊43┊\n+┊  ┊44┊  fullChat.messages.push(message);\n+┊  ┊45┊  fullChat.lastMessage = message;\n+┊  ┊46┊\n+┊  ┊47┊  client.writeFragment({\n+┊  ┊48┊    id: chatIdFromStore,\n+┊  ┊49┊    fragment: fragments.fullChat,\n+┊  ┊50┊    fragmentName: 'FullChat',\n+┊  ┊51┊    data: fullChat,\n+┊  ┊52┊  });\n+┊  ┊53┊\n+┊  ┊54┊  let data;\n+┊  ┊55┊  try {\n+┊  ┊56┊    data = client.readQuery({\n+┊  ┊57┊      query: queries.chats,\n+┊  ┊58┊    });\n+┊  ┊59┊  } catch (e) {\n+┊  ┊60┊    return;\n+┊  ┊61┊  }\n+┊  ┊62┊\n+┊  ┊63┊  if (!data || data === null) {\n+┊  ┊64┊    return null;\n+┊  ┊65┊  }\n+┊  ┊66┊  if (!data.chats || data.chats === undefined) {\n+┊  ┊67┊    return null;\n+┊  ┊68┊  }\n+┊  ┊69┊  const chats = data.chats;\n+┊  ┊70┊\n+┊  ┊71┊  const chatIndex = chats.findIndex((c: any) => {\n+┊  ┊72┊    if (message === null || message.chat === null) return -1;\n+┊  ┊73┊    return c.id === message.chat.id;\n+┊  ┊74┊  });\n+┊  ┊75┊  if (chatIndex === -1) return;\n+┊  ┊76┊  const chatWhereAdded = chats[chatIndex];\n+┊  ┊77┊\n+┊  ┊78┊  // The chat will appear at the top of the ChatsList component\n+┊  ┊79┊  chats.splice(chatIndex, 1);\n+┊  ┊80┊  chats.unshift(chatWhereAdded);\n+┊  ┊81┊\n+┊  ┊82┊  client.writeQuery({\n+┊  ┊83┊    query: queries.chats,\n+┊  ┊84┊    data: { chats: chats },\n+┊  ┊85┊  });\n+┊  ┊86┊};\n```\n\n[}]: #\n\nWe will also use the exported `writeMessage()` function in the `ChatRoomScreen` so we won't have any code duplications:\n\n[{]: <helper> (diffStep 10.4 files=\"ChatRoom\" module=\"client\")\n\n#### [__Client__ Step 10.4: Update cache on message added](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/940853c)\n\n##### Changed src&#x2F;components&#x2F;ChatRoomScreen&#x2F;index.tsx\n```diff\n@@ -1,4 +1,3 @@\n-┊1┊ ┊import { defaultDataIdFromObject } from 'apollo-cache-inmemory';\n ┊2┊1┊import gql from 'graphql-tag';\n ┊3┊2┊import React from 'react';\n ┊4┊3┊import { useCallback } from 'react';\n```\n```diff\n@@ -7,9 +6,9 @@\n ┊ 7┊ 6┊import MessageInput from './MessageInput';\n ┊ 8┊ 7┊import MessagesList from './MessagesList';\n ┊ 9┊ 8┊import { History } from 'history';\n-┊10┊  ┊import { ChatsQuery, useGetChatQuery, useAddMessageMutation } from '../../graphql/types';\n-┊11┊  ┊import * as queries from '../../graphql/queries';\n+┊  ┊ 9┊import { useGetChatQuery, useAddMessageMutation } from '../../graphql/types';\n ┊12┊10┊import * as fragments from '../../graphql/fragments';\n+┊  ┊11┊import { writeMessage } from '../../services/cache.service';\n ┊13┊12┊\n ┊14┊13┊const Container = styled.div`\n ┊15┊14┊  background: url(/assets/chat-background.jpg);\n```\n```diff\n@@ -43,10 +42,6 @@\n ┊43┊42┊  history: History;\n ┊44┊43┊}\n ┊45┊44┊\n-┊46┊  ┊interface ChatsResult {\n-┊47┊  ┊  chats: any[];\n-┊48┊  ┊}\n-┊49┊  ┊\n ┊50┊45┊const ChatRoomScreen: React.FC<ChatRoomScreenParams> = ({\n ┊51┊46┊  history,\n ┊52┊47┊  chatId,\n```\n```diff\n@@ -79,68 +74,7 @@\n ┊ 79┊ 74┊          },\n ┊ 80┊ 75┊        },\n ┊ 81┊ 76┊        update: (client, { data: { addMessage } }) => {\n-┊ 82┊   ┊          type FullChat = { [key: string]: any };\n-┊ 83┊   ┊          let fullChat;\n-┊ 84┊   ┊\n-┊ 85┊   ┊          const chatIdFromStore = defaultDataIdFromObject(addMessage.chat);\n-┊ 86┊   ┊\n-┊ 87┊   ┊          if (chatIdFromStore === null) {\n-┊ 88┊   ┊            return;\n-┊ 89┊   ┊          }\n-┊ 90┊   ┊          try {\n-┊ 91┊   ┊            fullChat = client.readFragment<FullChat>({\n-┊ 92┊   ┊              id: chatIdFromStore,\n-┊ 93┊   ┊              fragment: fragments.fullChat,\n-┊ 94┊   ┊              fragmentName: 'FullChat',\n-┊ 95┊   ┊            });\n-┊ 96┊   ┊          } catch (e) {\n-┊ 97┊   ┊            return;\n-┊ 98┊   ┊          }\n-┊ 99┊   ┊\n-┊100┊   ┊          if (fullChat === null || fullChat.messages === null) {\n-┊101┊   ┊            return;\n-┊102┊   ┊          }\n-┊103┊   ┊          if (fullChat.messages.messages.some((m: any) => m.id === addMessage.id)) return;\n-┊104┊   ┊\n-┊105┊   ┊          fullChat.messages.messages.push(addMessage);\n-┊106┊   ┊          fullChat.lastMessage = addMessage;\n-┊107┊   ┊\n-┊108┊   ┊          client.writeFragment({\n-┊109┊   ┊            id: chatIdFromStore,\n-┊110┊   ┊            fragment: fragments.fullChat,\n-┊111┊   ┊            fragmentName: 'FullChat',\n-┊112┊   ┊            data: fullChat,\n-┊113┊   ┊          });\n-┊114┊   ┊\n-┊115┊   ┊          let data: ChatsQuery | null;\n-┊116┊   ┊          try {\n-┊117┊   ┊            data = client.readQuery({\n-┊118┊   ┊              query: queries.chats,\n-┊119┊   ┊            });\n-┊120┊   ┊          } catch (e) {\n-┊121┊   ┊            return;\n-┊122┊   ┊          }\n-┊123┊   ┊\n-┊124┊   ┊          if (!data || !data.chats) {\n-┊125┊   ┊            return null;\n-┊126┊   ┊          }\n-┊127┊   ┊          const chats = data.chats;\n-┊128┊   ┊\n-┊129┊   ┊          const chatIndex = chats.findIndex((c: any) => {\n-┊130┊   ┊            if (addMessage === null || addMessage.chat === null) return -1;\n-┊131┊   ┊            return c.id === addMessage.chat.id;\n-┊132┊   ┊          });\n-┊133┊   ┊          if (chatIndex === -1) return;\n-┊134┊   ┊          const chatWhereAdded = chats[chatIndex];\n-┊135┊   ┊\n-┊136┊   ┊          // The chat will appear at the top of the ChatsList component\n-┊137┊   ┊          chats.splice(chatIndex, 1);\n-┊138┊   ┊          chats.unshift(chatWhereAdded);\n-┊139┊   ┊\n-┊140┊   ┊          client.writeQuery({\n-┊141┊   ┊            query: queries.chats,\n-┊142┊   ┊            data: { chats: chats },\n-┊143┊   ┊          });\n+┊   ┊ 77┊          writeMessage(client, addMessage);\n ┊144┊ 78┊        },\n ┊145┊ 79┊      });\n ┊146┊ 80┊    },\n```\n\n[}]: #\n\nOne thing missing that you might notice is that we're trying to retrieve the chat from the received message, unfortunately our GraphQL schema doesn't support it and we will need to add it. On the server, we will add a `chat` field to the `Message` type in the GraphQL schema, and we will implement a resolver which will lookup for the chat in the chats collection:\n\n[{]: <helper> (diffStep 7.7 module=\"server\")\n\n#### [__Server__ Step 7.7: Add Message.chat resolver](https://github.com/Urigo/WhatsApp-Clone-Server/commit/7fdc301)\n\n##### Changed schema&#x2F;resolvers.ts\n```diff\n@@ -5,6 +5,12 @@\n ┊ 5┊ 5┊const resolvers: Resolvers = {\n ┊ 6┊ 6┊  Date: GraphQLDateTime,\n ┊ 7┊ 7┊\n+┊  ┊ 8┊  Message: {\n+┊  ┊ 9┊    chat(message) {\n+┊  ┊10┊      return chats.find(c => c.messages.some(m => m === message.id)) || null;\n+┊  ┊11┊    },\n+┊  ┊12┊  },\n+┊  ┊13┊\n ┊ 8┊14┊  Chat: {\n ┊ 9┊15┊    messages(chat) {\n ┊10┊16┊      return messages.filter(m => chat.messages.includes(m.id));\n```\n\n##### Changed schema&#x2F;typeDefs.graphql\n```diff\n@@ -4,6 +4,7 @@\n ┊ 4┊ 4┊  id: ID!\n ┊ 5┊ 5┊  content: String!\n ┊ 6┊ 6┊  createdAt: Date!\n+┊  ┊ 7┊  chat: Chat\n ┊ 7┊ 8┊}\n ┊ 8┊ 9┊\n ┊ 9┊10┊type Chat {\n```\n\n[}]: #\n\nNow that we have it supported we can update the `Message` fragment in the client to include that information. We don't need the entire chat, only its ID, since the fragment ID composition is done out of an ID and type name:\n\n[{]: <helper> (diffStep 10.5 module=\"client\")\n\n#### [__Client__ Step 10.5: Add chat.id to message fragment](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/eb6cead)\n\n##### Changed src&#x2F;components&#x2F;ChatRoomScreen&#x2F;index.tsx\n```diff\n@@ -70,6 +70,10 @@\n ┊70┊70┊              .toString(36)\n ┊71┊71┊              .substr(2, 9),\n ┊72┊72┊            createdAt: new Date(),\n+┊  ┊73┊            chat: {\n+┊  ┊74┊              __typename: 'Chat',\n+┊  ┊75┊              id: chatId,\n+┊  ┊76┊            },\n ┊73┊77┊            content,\n ┊74┊78┊          },\n ┊75┊79┊        },\n```\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;ChatsList.test.tsx\n```diff\n@@ -36,6 +36,10 @@\n ┊36┊36┊                  id: 1,\n ┊37┊37┊                  content: 'Hello',\n ┊38┊38┊                  createdAt: new Date('1 Jan 2019 GMT'),\n+┊  ┊39┊                  chat: {\n+┊  ┊40┊                    __typename: 'Chat',\n+┊  ┊41┊                    id: 1,\n+┊  ┊42┊                  },\n ┊39┊43┊                },\n ┊40┊44┊              },\n ┊41┊45┊            ],\n```\n```diff\n@@ -80,6 +84,10 @@\n ┊80┊84┊                  id: 1,\n ┊81┊85┊                  content: 'Hello',\n ┊82┊86┊                  createdAt: new Date('1 Jan 2019 GMT'),\n+┊  ┊87┊                  chat: {\n+┊  ┊88┊                    __typename: 'Chat',\n+┊  ┊89┊                    id: 1,\n+┊  ┊90┊                  },\n ┊83┊91┊                },\n ┊84┊92┊              },\n ┊85┊93┊            ],\n```\n\n##### Changed src&#x2F;graphql&#x2F;fragments&#x2F;message.fragment.ts\n```diff\n@@ -5,5 +5,8 @@\n ┊ 5┊ 5┊    id\n ┊ 6┊ 6┊    createdAt\n ┊ 7┊ 7┊    content\n+┊  ┊ 8┊    chat {\n+┊  ┊ 9┊      id\n+┊  ┊10┊    }\n ┊ 8┊11┊  }\n ┊ 9┊12┊`;\n```\n\n[}]: #\n\nFinally, we will import the `useCacheService` React hook that we've just created and we will use it in our main `App` component. This means that the cache service will start listening for changes right as the app component is mounted:\n\n[{]: <helper> (diffStep 10.6 module=\"client\")\n\n#### [__Client__ Step 10.6: Use cache service](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/12b2429)\n\n##### Changed src&#x2F;App.test.tsx\n```diff\n@@ -3,9 +3,15 @@\n ┊ 3┊ 3┊import ReactDOM from 'react-dom';\n ┊ 4┊ 4┊import App from './App';\n ┊ 5┊ 5┊import { mockApolloClient } from './test-helpers';\n+┊  ┊ 6┊import * as subscriptions from './graphql/subscriptions';\n ┊ 6┊ 7┊\n ┊ 7┊ 8┊it('renders without crashing', () => {\n-┊ 8┊  ┊  const client = mockApolloClient();\n+┊  ┊ 9┊  const client = mockApolloClient([\n+┊  ┊10┊    {\n+┊  ┊11┊      request: { query: subscriptions.messageAdded },\n+┊  ┊12┊      result: { data: {} }\n+┊  ┊13┊    }\n+┊  ┊14┊  ]);\n ┊ 9┊15┊  const div = document.createElement('div');\n ┊10┊16┊\n ┊11┊17┊  ReactDOM.render(\n```\n\n##### Changed src&#x2F;App.tsx\n```diff\n@@ -8,26 +8,31 @@\n ┊ 8┊ 8┊import ChatRoomScreen from './components/ChatRoomScreen';\n ┊ 9┊ 9┊import ChatsListScreen from './components/ChatsListScreen';\n ┊10┊10┊import AnimatedSwitch from './components/AnimatedSwitch';\n+┊  ┊11┊import { useCacheService } from './services/cache.service';\n ┊11┊12┊\n-┊12┊  ┊const App: React.FC = () => (\n-┊13┊  ┊  <BrowserRouter>\n-┊14┊  ┊    <AnimatedSwitch>\n-┊15┊  ┊      <Route exact path=\"/chats\" component={ChatsListScreen} />\n+┊  ┊13┊const App: React.FC = () => {\n+┊  ┊14┊  useCacheService();\n ┊16┊15┊\n-┊17┊  ┊      <Route\n-┊18┊  ┊        exact\n-┊19┊  ┊        path=\"/chats/:chatId\"\n-┊20┊  ┊        component={({\n-┊21┊  ┊          match,\n-┊22┊  ┊          history,\n-┊23┊  ┊        }: RouteComponentProps<{ chatId: string }>) => (\n-┊24┊  ┊          <ChatRoomScreen chatId={match.params.chatId} history={history} />\n-┊25┊  ┊        )}\n-┊26┊  ┊      />\n-┊27┊  ┊    </AnimatedSwitch>\n-┊28┊  ┊    <Route exact path=\"/\" render={redirectToChats} />\n-┊29┊  ┊  </BrowserRouter>\n-┊30┊  ┊);\n+┊  ┊16┊  return (\n+┊  ┊17┊    <BrowserRouter>\n+┊  ┊18┊      <AnimatedSwitch>\n+┊  ┊19┊        <Route exact path=\"/chats\" component={ChatsListScreen} />\n+┊  ┊20┊\n+┊  ┊21┊        <Route\n+┊  ┊22┊          exact\n+┊  ┊23┊          path=\"/chats/:chatId\"\n+┊  ┊24┊          component={({\n+┊  ┊25┊            match,\n+┊  ┊26┊            history,\n+┊  ┊27┊          }: RouteComponentProps<{ chatId: string }>) => (\n+┊  ┊28┊            <ChatRoomScreen chatId={match.params.chatId} history={history} />\n+┊  ┊29┊          )}\n+┊  ┊30┊        />\n+┊  ┊31┊      </AnimatedSwitch>\n+┊  ┊32┊      <Route exact path=\"/\" render={redirectToChats} />\n+┊  ┊33┊    </BrowserRouter>\n+┊  ┊34┊  );\n+┊  ┊35┊};\n ┊31┊36┊\n ┊32┊37┊const redirectToChats = () => <Redirect to=\"/chats\" />;\n```\n\n[}]: #\n\nSubscription handling is complete! If you'll try to repeat the same process again where you check messages updating between 2 instances of the app, you should see them both update.\n\n-------\n\nTODO: `useCacheService` shouldn’t be called like that since it’s related to message events and cache updates are only side-effects."
          },
          {
            "manualTitle": "Step 11: Users",
            "stepRevision": "5e7b8cf30587b2e71567d9bb394e0a5ed48b0681",
            "manualView": "Our chat app is pretty functional. We can pick a chat from the chats list and we can send messages. It's not hard to notice that one of the most important mechanisms is missing, which is relating a chat or a message to a specific user. Even though we can send messages, it's basically pointless unless someone else receives it. In this chapter we will create a new users collection with pre-defined documents and we will learn how to simulate authentication programmatically so we can test the new mechanism.\n\n**Reshaping the back-end**\n\nTo implement this feature we need to rethink our back-end and reshape the way our GraphQL schema is structured. Right now we only have 2 entities: Chat and Message, which are connected like so:\n\n\n\n![chat-message-orm](https://user-images.githubusercontent.com/7648874/55325929-0faa1b00-54b9-11e9-8868-7a8ed3edcda1.png)\n\n\nWe want to have a new User entity where each user will have Chats he participates in and Messages he owns. Therefore, our new GraphQL schema should look like something like this:\n\n\n\n![chat-message-user-orm](https://user-images.githubusercontent.com/7648874/55325935-146ecf00-54b9-11e9-8c0f-bc3b63cbe676.png)\n\nThis change would require us to update the GraphQL type definitions and handlers, the DB models, and the codegen configuration file:\n\n[{]: <helper> (diffStep 8.1 module=\"server\")\n\n#### [__Server__ Step 8.1: Add User type](https://github.com/Urigo/WhatsApp-Clone-Server/commit/d0104a4)\n\n##### Changed codegen.yml\n```diff\n@@ -10,6 +10,7 @@\n ┊10┊10┊      mappers:\n ┊11┊11┊        # import { Message } from '../db'\n ┊12┊12┊        # The root types of Message resolvers\n+┊  ┊13┊        User: ../db#User\n ┊13┊14┊        Message: ../db#Message\n ┊14┊15┊        Chat: ../db#Chat\n ┊15┊16┊      scalars:\n```\n\n##### Changed db.ts\n```diff\n@@ -1,20 +1,60 @@\n+┊  ┊ 1┊export type User = {\n+┊  ┊ 2┊  id: string;\n+┊  ┊ 3┊  name: string;\n+┊  ┊ 4┊  picture: string;\n+┊  ┊ 5┊};\n+┊  ┊ 6┊\n ┊ 1┊ 7┊export type Message = {\n ┊ 2┊ 8┊  id: string;\n ┊ 3┊ 9┊  content: string;\n ┊ 4┊10┊  createdAt: Date;\n+┊  ┊11┊  sender: string;\n+┊  ┊12┊  recipient: string;\n ┊ 5┊13┊};\n ┊ 6┊14┊\n ┊ 7┊15┊export type Chat = {\n ┊ 8┊16┊  id: string;\n-┊ 9┊  ┊  name: string;\n-┊10┊  ┊  picture: string;\n ┊11┊17┊  messages: string[];\n+┊  ┊18┊  participants: string[];\n ┊12┊19┊};\n ┊13┊20┊\n+┊  ┊21┊export const users: User[] = [];\n ┊14┊22┊export const messages: Message[] = [];\n ┊15┊23┊export const chats: Chat[] = [];\n ┊16┊24┊\n ┊17┊25┊export const resetDb = () => {\n+┊  ┊26┊  users.splice(\n+┊  ┊27┊    0,\n+┊  ┊28┊    Infinity,\n+┊  ┊29┊    ...[\n+┊  ┊30┊      {\n+┊  ┊31┊        id: '1',\n+┊  ┊32┊        name: 'Ray Edwards',\n+┊  ┊33┊        picture: 'https://randomuser.me/api/portraits/thumb/lego/1.jpg',\n+┊  ┊34┊      },\n+┊  ┊35┊      {\n+┊  ┊36┊        id: '2',\n+┊  ┊37┊        name: 'Ethan Gonzalez',\n+┊  ┊38┊        picture: 'https://randomuser.me/api/portraits/thumb/men/1.jpg',\n+┊  ┊39┊      },\n+┊  ┊40┊      {\n+┊  ┊41┊        id: '3',\n+┊  ┊42┊        name: 'Bryan Wallace',\n+┊  ┊43┊        picture: 'https://randomuser.me/api/portraits/thumb/men/2.jpg',\n+┊  ┊44┊      },\n+┊  ┊45┊      {\n+┊  ┊46┊        id: '4',\n+┊  ┊47┊        name: 'Avery Stewart',\n+┊  ┊48┊        picture: 'https://randomuser.me/api/portraits/thumb/women/1.jpg',\n+┊  ┊49┊      },\n+┊  ┊50┊      {\n+┊  ┊51┊        id: '5',\n+┊  ┊52┊        name: 'Katie Peterson',\n+┊  ┊53┊        picture: 'https://randomuser.me/api/portraits/thumb/women/2.jpg',\n+┊  ┊54┊      },\n+┊  ┊55┊    ]\n+┊  ┊56┊  );\n+┊  ┊57┊\n ┊18┊58┊  messages.splice(\n ┊19┊59┊    0,\n ┊20┊60┊    Infinity,\n```\n```diff\n@@ -23,6 +63,8 @@\n ┊23┊63┊        id: '1',\n ┊24┊64┊        content: 'You on your way?',\n ┊25┊65┊        createdAt: new Date(new Date('1-1-2019').getTime() - 60 * 1000 * 1000),\n+┊  ┊66┊        sender: '1',\n+┊  ┊67┊        recipient: '2',\n ┊26┊68┊      },\n ┊27┊69┊      {\n ┊28┊70┊        id: '2',\n```\n```diff\n@@ -30,6 +72,8 @@\n ┊30┊72┊        createdAt: new Date(\n ┊31┊73┊          new Date('1-1-2019').getTime() - 2 * 60 * 1000 * 1000\n ┊32┊74┊        ),\n+┊  ┊75┊        sender: '1',\n+┊  ┊76┊        recipient: '3',\n ┊33┊77┊      },\n ┊34┊78┊      {\n ┊35┊79┊        id: '3',\n```\n```diff\n@@ -37,6 +81,8 @@\n ┊37┊81┊        createdAt: new Date(\n ┊38┊82┊          new Date('1-1-2019').getTime() - 24 * 60 * 1000 * 1000\n ┊39┊83┊        ),\n+┊  ┊84┊        sender: '1',\n+┊  ┊85┊        recipient: '4',\n ┊40┊86┊      },\n ┊41┊87┊      {\n ┊42┊88┊        id: '4',\n```\n```diff\n@@ -44,6 +90,8 @@\n ┊44┊90┊        createdAt: new Date(\n ┊45┊91┊          new Date('1-1-2019').getTime() - 14 * 24 * 60 * 1000 * 1000\n ┊46┊92┊        ),\n+┊  ┊93┊        sender: '1',\n+┊  ┊94┊        recipient: '5',\n ┊47┊95┊      },\n ┊48┊96┊    ]\n ┊49┊97┊  );\n```\n```diff\n@@ -54,26 +102,22 @@\n ┊ 54┊102┊    ...[\n ┊ 55┊103┊      {\n ┊ 56┊104┊        id: '1',\n-┊ 57┊   ┊        name: 'Ethan Gonzalez',\n-┊ 58┊   ┊        picture: 'https://randomuser.me/api/portraits/thumb/men/1.jpg',\n+┊   ┊105┊        participants: ['1', '2'],\n ┊ 59┊106┊        messages: ['1'],\n ┊ 60┊107┊      },\n ┊ 61┊108┊      {\n ┊ 62┊109┊        id: '2',\n-┊ 63┊   ┊        name: 'Bryan Wallace',\n-┊ 64┊   ┊        picture: 'https://randomuser.me/api/portraits/thumb/men/2.jpg',\n+┊   ┊110┊        participants: ['1', '3'],\n ┊ 65┊111┊        messages: ['2'],\n ┊ 66┊112┊      },\n ┊ 67┊113┊      {\n ┊ 68┊114┊        id: '3',\n-┊ 69┊   ┊        name: 'Avery Stewart',\n-┊ 70┊   ┊        picture: 'https://randomuser.me/api/portraits/thumb/women/1.jpg',\n+┊   ┊115┊        participants: ['1', '4'],\n ┊ 71┊116┊        messages: ['3'],\n ┊ 72┊117┊      },\n ┊ 73┊118┊      {\n ┊ 74┊119┊        id: '4',\n-┊ 75┊   ┊        name: 'Katie Peterson',\n-┊ 76┊   ┊        picture: 'https://randomuser.me/api/portraits/thumb/women/2.jpg',\n+┊   ┊120┊        participants: ['1', '5'],\n ┊ 77┊121┊        messages: ['4'],\n ┊ 78┊122┊      },\n ┊ 79┊123┊    ]\n```\n\n##### Changed schema&#x2F;resolvers.ts\n```diff\n@@ -1,5 +1,5 @@\n ┊1┊1┊import { GraphQLDateTime } from 'graphql-iso-date';\n-┊2┊ ┊import { Message, chats, messages } from '../db';\n+┊ ┊2┊import { User, Message, chats, messages, users } from '../db';\n ┊3┊3┊import { Resolvers } from '../types/graphql';\n ┊4┊4┊\n ┊5┊5┊const resolvers: Resolvers = {\n```\n```diff\n@@ -9,9 +9,27 @@\n ┊ 9┊ 9┊    chat(message) {\n ┊10┊10┊      return chats.find(c => c.messages.some(m => m === message.id)) || null;\n ┊11┊11┊    },\n+┊  ┊12┊\n+┊  ┊13┊    sender(message) {\n+┊  ┊14┊      return users.find(u => u.id === message.sender) || null;\n+┊  ┊15┊    },\n+┊  ┊16┊\n+┊  ┊17┊    recipient(message) {\n+┊  ┊18┊      return users.find(u => u.id === message.recipient) || null;\n+┊  ┊19┊    },\n ┊12┊20┊  },\n ┊13┊21┊\n ┊14┊22┊  Chat: {\n+┊  ┊23┊    name() {\n+┊  ┊24┊      // TODO: Resolve in relation to current user\n+┊  ┊25┊      return null;\n+┊  ┊26┊    },\n+┊  ┊27┊\n+┊  ┊28┊    picture() {\n+┊  ┊29┊      // TODO: Resolve in relation to current user\n+┊  ┊30┊      return null;\n+┊  ┊31┊    },\n+┊  ┊32┊\n ┊15┊33┊    messages(chat) {\n ┊16┊34┊      return messages.filter(m => chat.messages.includes(m.id));\n ┊17┊35┊    },\n```\n```diff\n@@ -21,6 +39,12 @@\n ┊21┊39┊\n ┊22┊40┊      return messages.find(m => m.id === lastMessage) || null;\n ┊23┊41┊    },\n+┊  ┊42┊\n+┊  ┊43┊    participants(chat) {\n+┊  ┊44┊      return chat.participants\n+┊  ┊45┊        .map(p => users.find(u => u.id === p))\n+┊  ┊46┊        .filter(Boolean) as User[];\n+┊  ┊47┊    },\n ┊24┊48┊  },\n ┊25┊49┊\n ┊26┊50┊  Query: {\n```\n```diff\n@@ -45,6 +69,8 @@\n ┊45┊69┊      const message: Message = {\n ┊46┊70┊        id: messageId,\n ┊47┊71┊        createdAt: new Date(),\n+┊  ┊72┊        sender: '', // TODO: Fill-in\n+┊  ┊73┊        recipient: '', // TODO: Fill-in\n ┊48┊74┊        content,\n ┊49┊75┊      };\n ┊50┊76┊\n```\n\n##### Changed schema&#x2F;typeDefs.graphql\n```diff\n@@ -1,18 +1,28 @@\n ┊ 1┊ 1┊scalar Date\n ┊ 2┊ 2┊\n+┊  ┊ 3┊type User {\n+┊  ┊ 4┊  id: ID!\n+┊  ┊ 5┊  name: String!\n+┊  ┊ 6┊  picture: String\n+┊  ┊ 7┊}\n+┊  ┊ 8┊\n ┊ 3┊ 9┊type Message {\n ┊ 4┊10┊  id: ID!\n ┊ 5┊11┊  content: String!\n ┊ 6┊12┊  createdAt: Date!\n ┊ 7┊13┊  chat: Chat\n+┊  ┊14┊  sender: User\n+┊  ┊15┊  recipient: User\n+┊  ┊16┊  isMine: Boolean!\n ┊ 8┊17┊}\n ┊ 9┊18┊\n ┊10┊19┊type Chat {\n ┊11┊20┊  id: ID!\n-┊12┊  ┊  name: String!\n+┊  ┊21┊  name: String\n ┊13┊22┊  picture: String\n ┊14┊23┊  lastMessage: Message\n ┊15┊24┊  messages: [Message!]!\n+┊  ┊25┊  participants: [User!]!\n ┊16┊26┊}\n ┊17┊27┊\n ┊18┊28┊type Query {\n```\n\n[}]: #\n\nEven though we made these changes, the app remained the same. That's because the Query type haven't changed at all, and we still serve the same data as before. What we need to do is to edit the Query resolvers to serve data based on the user that is currently logged-in to the app in the current session. Before we go all in with a robust authentication system, it would be smarter to simulate it, so we can test our app and see that everything works as intended.\n\nFor now, let's assume that we're logged in with user of ID 1 - Ray Edwards. Codewise, this would mean that we will need to have the current user defined on the resolver context. In the main file, let's add the `currentUser` field to the context using a simple `find()` method from our `users` collection:\n\n[{]: <helper> (diffStep 8.2 files=\"index.ts\" module=\"server\")\n\n#### [__Server__ Step 8.2: Resolve queries in relation to current user](https://github.com/Urigo/WhatsApp-Clone-Server/commit/d3025d0)\n\n##### Changed index.ts\n```diff\n@@ -3,6 +3,7 @@\n ┊3┊3┊import cors from 'cors';\n ┊4┊4┊import express from 'express';\n ┊5┊5┊import http from 'http';\n+┊ ┊6┊import { users } from './db';\n ┊6┊7┊import schema from './schema';\n ┊7┊8┊\n ┊8┊9┊const app = express();\n```\n```diff\n@@ -17,7 +18,10 @@\n ┊17┊18┊const pubsub = new PubSub();\n ┊18┊19┊const server = new ApolloServer({\n ┊19┊20┊  schema,\n-┊20┊  ┊  context: () => ({ pubsub }),\n+┊  ┊21┊  context: () => ({\n+┊  ┊22┊    currentUser: users.find(u => u.id === '1'),\n+┊  ┊23┊    pubsub,\n+┊  ┊24┊  }),\n ┊21┊25┊});\n ┊22┊26┊\n ┊23┊27┊server.applyMiddleware({\n```\n\n[}]: #\n\nAnd we will update the context type:\n\n[{]: <helper> (diffStep 8.2 files=\"context\" module=\"server\")\n\n#### [__Server__ Step 8.2: Resolve queries in relation to current user](https://github.com/Urigo/WhatsApp-Clone-Server/commit/d3025d0)\n\n##### Changed context.ts\n```diff\n@@ -1,5 +1,7 @@\n ┊1┊1┊import { PubSub } from 'apollo-server-express';\n+┊ ┊2┊import { User } from './db';\n ┊2┊3┊\n ┊3┊4┊export type MyContext = {\n ┊4┊5┊  pubsub: PubSub;\n+┊ ┊6┊  currentUser: User;\n ┊5┊7┊};\n```\n\n[}]: #\n\nNow we will update the resolvers to fetch data relatively to the current user logged in. If there's no user logged in, the resolvers should return `null`, as the client is not authorized to view the data he requested:\n\n[{]: <helper> (diffStep 8.2 files=\"schema, tests\" module=\"server\")\n\n#### [__Server__ Step 8.2: Resolve queries in relation to current user](https://github.com/Urigo/WhatsApp-Clone-Server/commit/d3025d0)\n\n##### Changed schema&#x2F;resolvers.ts\n```diff\n@@ -17,17 +17,35 @@\n ┊17┊17┊    recipient(message) {\n ┊18┊18┊      return users.find(u => u.id === message.recipient) || null;\n ┊19┊19┊    },\n+┊  ┊20┊\n+┊  ┊21┊    isMine(message, args, { currentUser }) {\n+┊  ┊22┊      return message.sender === currentUser.id;\n+┊  ┊23┊    },\n ┊20┊24┊  },\n ┊21┊25┊\n ┊22┊26┊  Chat: {\n-┊23┊  ┊    name() {\n-┊24┊  ┊      // TODO: Resolve in relation to current user\n-┊25┊  ┊      return null;\n+┊  ┊27┊    name(chat, args, { currentUser }) {\n+┊  ┊28┊      if (!currentUser) return null;\n+┊  ┊29┊\n+┊  ┊30┊      const participantId = chat.participants.find(p => p !== currentUser.id);\n+┊  ┊31┊\n+┊  ┊32┊      if (!participantId) return null;\n+┊  ┊33┊\n+┊  ┊34┊      const participant = users.find(u => u.id === participantId);\n+┊  ┊35┊\n+┊  ┊36┊      return participant ? participant.name : null;\n ┊26┊37┊    },\n ┊27┊38┊\n-┊28┊  ┊    picture() {\n-┊29┊  ┊      // TODO: Resolve in relation to current user\n-┊30┊  ┊      return null;\n+┊  ┊39┊    picture(chat, args, { currentUser }) {\n+┊  ┊40┊      if (!currentUser) return null;\n+┊  ┊41┊\n+┊  ┊42┊      const participantId = chat.participants.find(p => p !== currentUser.id);\n+┊  ┊43┊\n+┊  ┊44┊      if (!participantId) return null;\n+┊  ┊45┊\n+┊  ┊46┊      const participant = users.find(u => u.id === participantId);\n+┊  ┊47┊\n+┊  ┊48┊      return participant ? participant.picture : null;\n ┊31┊49┊    },\n ┊32┊50┊\n ┊33┊51┊    messages(chat) {\n```\n```diff\n@@ -48,29 +66,42 @@\n ┊ 48┊ 66┊  },\n ┊ 49┊ 67┊\n ┊ 50┊ 68┊  Query: {\n-┊ 51┊   ┊    chats() {\n-┊ 52┊   ┊      return chats;\n+┊   ┊ 69┊    chats(root, args, { currentUser }) {\n+┊   ┊ 70┊      if (!currentUser) return [];\n+┊   ┊ 71┊\n+┊   ┊ 72┊      return chats.filter(c => c.participants.includes(currentUser.id));\n ┊ 53┊ 73┊    },\n ┊ 54┊ 74┊\n-┊ 55┊   ┊    chat(root, { chatId }) {\n-┊ 56┊   ┊      return chats.find(c => c.id === chatId) || null;\n+┊   ┊ 75┊    chat(root, { chatId }, { currentUser }) {\n+┊   ┊ 76┊      if (!currentUser) return null;\n+┊   ┊ 77┊\n+┊   ┊ 78┊      const chat = chats.find(c => c.id === chatId);\n+┊   ┊ 79┊\n+┊   ┊ 80┊      if (!chat) return null;\n+┊   ┊ 81┊\n+┊   ┊ 82┊      return chat.participants.includes(currentUser.id) ? chat : null;\n ┊ 57┊ 83┊    },\n ┊ 58┊ 84┊  },\n ┊ 59┊ 85┊\n ┊ 60┊ 86┊  Mutation: {\n-┊ 61┊   ┊    addMessage(root, { chatId, content }, { pubsub }) {\n+┊   ┊ 87┊    addMessage(root, { chatId, content }, { currentUser, pubsub }) {\n+┊   ┊ 88┊      if (!currentUser) return null;\n+┊   ┊ 89┊\n ┊ 62┊ 90┊      const chatIndex = chats.findIndex(c => c.id === chatId);\n ┊ 63┊ 91┊\n ┊ 64┊ 92┊      if (chatIndex === -1) return null;\n ┊ 65┊ 93┊\n ┊ 66┊ 94┊      const chat = chats[chatIndex];\n+┊   ┊ 95┊\n+┊   ┊ 96┊      if (!chat.participants.includes(currentUser.id)) return null;\n+┊   ┊ 97┊\n ┊ 67┊ 98┊      const recentMessage = messages[messages.length - 1];\n ┊ 68┊ 99┊      const messageId = String(Number(recentMessage.id) + 1);\n ┊ 69┊100┊      const message: Message = {\n ┊ 70┊101┊        id: messageId,\n ┊ 71┊102┊        createdAt: new Date(),\n-┊ 72┊   ┊        sender: '', // TODO: Fill-in\n-┊ 73┊   ┊        recipient: '', // TODO: Fill-in\n+┊   ┊103┊        sender: currentUser.id,\n+┊   ┊104┊        recipient: chat.participants.find(p => p !== currentUser.id) as string,\n ┊ 74┊105┊        content,\n ┊ 75┊106┊      };\n ┊ 76┊107┊\n```\n\n##### Changed tests&#x2F;mutations&#x2F;addMessage.test.ts\n```diff\n@@ -1,7 +1,7 @@\n ┊1┊1┊import { createTestClient } from 'apollo-server-testing';\n ┊2┊2┊import { ApolloServer, PubSub, gql } from 'apollo-server-express';\n ┊3┊3┊import schema from '../../schema';\n-┊4┊ ┊import { resetDb } from '../../db';\n+┊ ┊4┊import { resetDb, users } from '../../db';\n ┊5┊5┊\n ┊6┊6┊describe('Mutation.addMessage', () => {\n ┊7┊7┊  beforeEach(resetDb);\n```\n```diff\n@@ -9,7 +9,10 @@\n ┊ 9┊ 9┊  it('should add message to specified chat', async () => {\n ┊10┊10┊    const server = new ApolloServer({\n ┊11┊11┊      schema,\n-┊12┊  ┊      context: () => ({ pubsub: new PubSub() }),\n+┊  ┊12┊      context: () => ({\n+┊  ┊13┊        pubsub: new PubSub(),\n+┊  ┊14┊        currentUser: users[0],\n+┊  ┊15┊      }),\n ┊13┊16┊    });\n ┊14┊17┊\n ┊15┊18┊    const { query, mutate } = createTestClient(server);\n```\n\n##### Changed tests&#x2F;queries&#x2F;getChat.test.ts\n```diff\n@@ -1,10 +1,16 @@\n ┊ 1┊ 1┊import { createTestClient } from 'apollo-server-testing';\n ┊ 2┊ 2┊import { ApolloServer, gql } from 'apollo-server-express';\n ┊ 3┊ 3┊import schema from '../../schema';\n+┊  ┊ 4┊import { users } from '../../db';\n ┊ 4┊ 5┊\n ┊ 5┊ 6┊describe('Query.chat', () => {\n ┊ 6┊ 7┊  it('should fetch specified chat', async () => {\n-┊ 7┊  ┊    const server = new ApolloServer({ schema });\n+┊  ┊ 8┊    const server = new ApolloServer({\n+┊  ┊ 9┊      schema,\n+┊  ┊10┊      context: () => ({\n+┊  ┊11┊        currentUser: users[0],\n+┊  ┊12┊      }),\n+┊  ┊13┊    });\n ┊ 8┊14┊\n ┊ 9┊15┊    const { query } = createTestClient(server);\n ┊10┊16┊\n```\n\n##### Changed tests&#x2F;queries&#x2F;getChats.test.ts\n```diff\n@@ -1,10 +1,16 @@\n ┊ 1┊ 1┊import { createTestClient } from 'apollo-server-testing';\n ┊ 2┊ 2┊import { ApolloServer, gql } from 'apollo-server-express';\n ┊ 3┊ 3┊import schema from '../../schema';\n+┊  ┊ 4┊import { users } from '../../db';\n ┊ 4┊ 5┊\n ┊ 5┊ 6┊describe('Query.chats', () => {\n ┊ 6┊ 7┊  it('should fetch all chats', async () => {\n-┊ 7┊  ┊    const server = new ApolloServer({ schema });\n+┊  ┊ 8┊    const server = new ApolloServer({\n+┊  ┊ 9┊      schema,\n+┊  ┊10┊      context: () => ({\n+┊  ┊11┊        currentUser: users[0],\n+┊  ┊12┊      }),\n+┊  ┊13┊    });\n ┊ 8┊14┊\n ┊ 9┊15┊    const { query } = createTestClient(server);\n```\n\n[}]: #\n\nNow if we will get back to the app and refresh the page, we should see a new chats list which is only relevant to Ray Edwards. Earlier in this chapter, we've defined a new `isMine` field on the `Message` type. This field is useful because now we can differentiate between messages that are mine and messages that belong to the recipient. We can use that information to distinct between messages in our UI.\n\nLet's first download a new image that will help us achieve the new style and save it under the [`src/public/assets/message-yours.png`](https://github.com/Urigo/WhatsApp-Clone-Client-React/blob/cordova/public/assets/message-other.png?raw=true) path. Then let's implement the new style:\n\n[{]: <helper> (diffStep 11.1 files=\"src/components\" module=\"client\")\n\n#### [__Client__ Step 11.1: Distinguish messages](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/a6bfc7f)\n\n##### Changed src&#x2F;components&#x2F;ChatRoomScreen&#x2F;MessagesList.tsx\n```diff\n@@ -2,7 +2,7 @@\n ┊2┊2┊import React from 'react';\n ┊3┊3┊import { useEffect, useRef } from 'react';\n ┊4┊4┊import ReactDOM from 'react-dom';\n-┊5┊ ┊import styled from 'styled-components';\n+┊ ┊5┊import styled, { css } from 'styled-components';\n ┊6┊6┊\n ┊7┊7┊const Container = styled.div`\n ┊8┊8┊  display: block;\n```\n```diff\n@@ -11,9 +11,11 @@\n ┊11┊11┊  padding: 0 15px;\n ┊12┊12┊`;\n ┊13┊13┊\n+┊  ┊14┊type StyledProp = {\n+┊  ┊15┊  isMine: any;\n+┊  ┊16┊};\n+┊  ┊17┊\n ┊14┊18┊const MessageItem = styled.div`\n-┊15┊  ┊  float: right;\n-┊16┊  ┊  background-color: #dcf8c6;\n ┊17┊19┊  display: inline-block;\n ┊18┊20┊  position: relative;\n ┊19┊21┊  max-width: 100%;\n```\n```diff\n@@ -30,17 +32,36 @@\n ┊30┊32┊  }\n ┊31┊33┊\n ┊32┊34┊  &::before {\n-┊33┊  ┊    background-image: url(/assets/message-mine.png);\n ┊34┊35┊    content: '';\n ┊35┊36┊    position: absolute;\n ┊36┊37┊    bottom: 3px;\n ┊37┊38┊    width: 12px;\n ┊38┊39┊    height: 19px;\n-┊39┊  ┊    right: -11px;\n ┊40┊40┊    background-position: 50% 50%;\n ┊41┊41┊    background-repeat: no-repeat;\n ┊42┊42┊    background-size: contain;\n ┊43┊43┊  }\n+┊  ┊44┊\n+┊  ┊45┊  ${(props: StyledProp) =>\n+┊  ┊46┊    props.isMine\n+┊  ┊47┊      ? css`\n+┊  ┊48┊          float: right;\n+┊  ┊49┊          background-color: #dcf8c6;\n+┊  ┊50┊\n+┊  ┊51┊          &::before {\n+┊  ┊52┊            right: -11px;\n+┊  ┊53┊            background-image: url(/assets/message-mine.png);\n+┊  ┊54┊          }\n+┊  ┊55┊        `\n+┊  ┊56┊      : css`\n+┊  ┊57┊          float: left;\n+┊  ┊58┊          background-color: #fff;\n+┊  ┊59┊\n+┊  ┊60┊          &::before {\n+┊  ┊61┊            left: -11px;\n+┊  ┊62┊            background-image: url(/assets/message-other.png);\n+┊  ┊63┊          }\n+┊  ┊64┊        `}\n ┊44┊65┊`;\n ┊45┊66┊\n ┊46┊67┊const Contents = styled.div`\n```\n```diff\n@@ -75,7 +96,6 @@\n ┊ 75┊ 96┊\n ┊ 76┊ 97┊  useEffect(() => {\n ┊ 77┊ 98┊    if (!selfRef.current) return;\n-┊ 78┊   ┊\n ┊ 79┊ 99┊    const selfDOMNode = ReactDOM.findDOMNode(selfRef.current) as HTMLElement;\n ┊ 80┊100┊    selfDOMNode.scrollTop = Number.MAX_SAFE_INTEGER;\n ┊ 81┊101┊  }, [messages.length]);\n```\n```diff\n@@ -83,7 +103,10 @@\n ┊ 83┊103┊  return (\n ┊ 84┊104┊    <Container ref={selfRef}>\n ┊ 85┊105┊      {messages.map((message: any) => (\n-┊ 86┊   ┊        <MessageItem data-testid=\"message-item\" key={message.id}>\n+┊   ┊106┊        <MessageItem\n+┊   ┊107┊          data-testid=\"message-item\"\n+┊   ┊108┊          isMine={message.isMine}\n+┊   ┊109┊          key={message.id}>\n ┊ 87┊110┊          <Contents data-testid=\"message-content\">{message.content}</Contents>\n ┊ 88┊111┊          <Timestamp data-testid=\"message-date\">\n ┊ 89┊112┊            {moment(message.createdAt).format('HH:mm')}\n```\n\n##### Changed src&#x2F;components&#x2F;ChatRoomScreen&#x2F;index.tsx\n```diff\n@@ -70,6 +70,7 @@\n ┊70┊70┊              .toString(36)\n ┊71┊71┊              .substr(2, 9),\n ┊72┊72┊            createdAt: new Date(),\n+┊  ┊73┊            isMine: true,\n ┊73┊74┊            chat: {\n ┊74┊75┊              __typename: 'Chat',\n ┊75┊76┊              id: chatId,\n```\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;ChatsList.test.tsx\n```diff\n@@ -36,6 +36,7 @@\n ┊36┊36┊                  id: 1,\n ┊37┊37┊                  content: 'Hello',\n ┊38┊38┊                  createdAt: new Date('1 Jan 2019 GMT'),\n+┊  ┊39┊                  isMine: true,\n ┊39┊40┊                  chat: {\n ┊40┊41┊                    __typename: 'Chat',\n ┊41┊42┊                    id: 1,\n```\n```diff\n@@ -84,6 +85,7 @@\n ┊84┊85┊                  id: 1,\n ┊85┊86┊                  content: 'Hello',\n ┊86┊87┊                  createdAt: new Date('1 Jan 2019 GMT'),\n+┊  ┊88┊                  isMine: true,\n ┊87┊89┊                  chat: {\n ┊88┊90┊                    __typename: 'Chat',\n ┊89┊91┊                    id: 1,\n```\n\n[}]: #\n\nThis is how the updated `ChatRoomScreen` should look like:\n\n\n\n![chat-room-screen](https://user-images.githubusercontent.com/7648874/55326701-face8700-54ba-11e9-877e-0b7dd71a1b68.png)\n\n\n\nWe can use a temporary solution to log-in and alternate between different users. This would be a good way to test data authorization without implementing an authentication mechanism. One way to know which user is logged in is via [cookies](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies).\n\nCookies are just text files which are stored locally on your computer and they contain key-value data maps. Cookies will be sent automatically by the browser with every HTTP request under the `Cookie` header. The header can be parsed and read by the server and this way inform it about the state of the client. Cookie values can also be set by the server by sending back a response which contain a `Set-Cookie` header. The browser will automatically write these cookies because of its specification and how it works.\n\nThis is how you can set cookies on the client:\n\n```js\ndocument.cookie = \"yummy_cookie=choco\"\ndocument.cookie = \"tasty_cookie=strawberry\"\n// logs \"yummy_cookie=choco; tasty_cookie=strawberry\"\n```\n\nAnd this is how further requests would look like:\n\n```\nGET /sample_page.html HTTP/2.0\nHost: www.example.org\nCookie: yummy_cookie=choco; tasty_cookie=strawberry\n```\n\nUsing this method we can set the current user's ID. Open your browser's dev-console, and type the following:\n\n```js\n// Ray Edwards\ndocument.cookie = 'currentUserId=1'\n```\n\nTo be able to send cookies with Apollo Client, we need to set the [`credentials`](https://www.apollographql.com/docs/react/recipes/authentication#cookie) option to \"include\" when creating the HTTP link:\n\n[{]: <helper> (diffStep 11.2 module=\"client\")\n\n#### [__Client__ Step 11.2: Support credentials](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/c89b891)\n\n##### Changed src&#x2F;client.ts\n```diff\n@@ -10,6 +10,7 @@\n ┊10┊10┊\n ┊11┊11┊const httpLink = new HttpLink({\n ┊12┊12┊  uri: httpUri,\n+┊  ┊13┊  credentials: 'include',\n ┊13┊14┊});\n ┊14┊15┊\n ┊15┊16┊const wsLink = new WebSocketLink({\n```\n\n[}]: #\n\nThis will set the [`Access-Control-Allow-Credentials`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Credentials) header to “include” with each HTTP request which is necessary when using the POST method. In correlation to that, we would need to configure the server to be able to receive and set cookies. This can be done via CORS options like so:\n\n[{]: <helper> (diffStep 8.4 files=\"index.ts\" module=\"server\")\n\n#### [__Server__ Step 8.4: Support credentials](https://github.com/Urigo/WhatsApp-Clone-Server/commit/0e8f496)\n\n##### Changed index.ts\n```diff\n@@ -8,7 +8,8 @@\n ┊ 8┊ 8┊\n ┊ 9┊ 9┊const app = express();\n ┊10┊10┊\n-┊11┊  ┊app.use(cors());\n+┊  ┊11┊const origin = process.env.ORIGIN || 'http://localhost:3000';\n+┊  ┊12┊app.use(cors({ credentials: true, origin }));\n ┊12┊13┊app.use(bodyParser.json());\n ┊13┊14┊\n ┊14┊15┊app.get('/_ping', (req, res) => {\n```\n```diff\n@@ -27,6 +28,7 @@\n ┊27┊28┊server.applyMiddleware({\n ┊28┊29┊  app,\n ┊29┊30┊  path: '/graphql',\n+┊  ┊31┊  cors: { credentials: true, origin },\n ┊30┊32┊});\n ┊31┊33┊\n ┊32┊34┊const httpServer = http.createServer(app);\n```\n\n[}]: #\n\nSo how exactly does one retrieve the values of the cookies? Like mentioned earlier, each and every request will have them set on the `cookie` header, so one way would be by reading the header directly, but a more convenient way would be using an Express middleware called [`cookie-parser`](https://www.npmjs.com/package/cookie-parser):\n\n    $ yarn add cookie-parser\n\n[{]: <helper> (diffStep 8.5 files=\"index.ts\" module=\"server\")\n\n#### [__Server__ Step 8.5: Use cookie parser](https://github.com/Urigo/WhatsApp-Clone-Server/commit/95e390c)\n\n##### Changed index.ts\n```diff\n@@ -1,6 +1,7 @@\n ┊1┊1┊import { ApolloServer, gql, PubSub } from 'apollo-server-express';\n ┊2┊2┊import bodyParser from 'body-parser';\n ┊3┊3┊import cors from 'cors';\n+┊ ┊4┊import cookieParser from 'cookie-parser';\n ┊4┊5┊import express from 'express';\n ┊5┊6┊import http from 'http';\n ┊6┊7┊import { users } from './db';\n```\n```diff\n@@ -11,6 +12,7 @@\n ┊11┊12┊const origin = process.env.ORIGIN || 'http://localhost:3000';\n ┊12┊13┊app.use(cors({ credentials: true, origin }));\n ┊13┊14┊app.use(bodyParser.json());\n+┊  ┊15┊app.use(cookieParser());\n ┊14┊16┊\n ┊15┊17┊app.get('/_ping', (req, res) => {\n ┊16┊18┊  res.send('pong');\n```\n\n[}]: #\n\n`cookie-parser` will read the `Cookie` header, it will parse it into a JSON and will define it on `req.cookies`. Since we’re using Apollo-Server with Express, the `req` object should be accessible as the first argument in the `context` function. This means that we can use the `currentUserId` from the cookies to fetch the current user from our users collection and define it on the context object:\n\n[{]: <helper> (diffStep 8.6 module=\"server\")\n\n#### [__Server__ Step 8.6: Define current user based on cookies](https://github.com/Urigo/WhatsApp-Clone-Server/commit/c94335e)\n\n##### Changed index.ts\n```diff\n@@ -2,6 +2,7 @@\n ┊2┊2┊import bodyParser from 'body-parser';\n ┊3┊3┊import cors from 'cors';\n ┊4┊4┊import cookieParser from 'cookie-parser';\n+┊ ┊5┊import cookie from 'cookie';\n ┊5┊6┊import express from 'express';\n ┊6┊7┊import http from 'http';\n ┊7┊8┊import { users } from './db';\n```\n```diff\n@@ -21,10 +22,30 @@\n ┊21┊22┊const pubsub = new PubSub();\n ┊22┊23┊const server = new ApolloServer({\n ┊23┊24┊  schema,\n-┊24┊  ┊  context: () => ({\n-┊25┊  ┊    currentUser: users.find(u => u.id === '1'),\n-┊26┊  ┊    pubsub,\n-┊27┊  ┊  }),\n+┊  ┊25┊  context: (session: any) => {\n+┊  ┊26┊    // Access the request object\n+┊  ┊27┊    let req = session.connection\n+┊  ┊28┊      ? session.connection.context.request\n+┊  ┊29┊      : session.req;\n+┊  ┊30┊\n+┊  ┊31┊    // It's subscription\n+┊  ┊32┊    if (session.connection) {\n+┊  ┊33┊      req.cookies = cookie.parse(req.headers.cookie || '');\n+┊  ┊34┊    }\n+┊  ┊35┊\n+┊  ┊36┊    return {\n+┊  ┊37┊      currentUser: users.find(u => u.id === req.cookies.currentUserId),\n+┊  ┊38┊      pubsub,\n+┊  ┊39┊    };\n+┊  ┊40┊  },\n+┊  ┊41┊  subscriptions: {\n+┊  ┊42┊    onConnect(params, ws, ctx) {\n+┊  ┊43┊      // pass the request object to context\n+┊  ┊44┊      return {\n+┊  ┊45┊        request: ctx.request,\n+┊  ┊46┊      };\n+┊  ┊47┊    },\n+┊  ┊48┊  },\n ┊28┊49┊});\n ┊29┊50┊\n ┊30┊51┊server.applyMiddleware({\n```\n\n##### Changed package.json\n```diff\n@@ -22,6 +22,7 @@\n ┊22┊22┊    \"@graphql-codegen/typescript-resolvers\": \"1.2.1\",\n ┊23┊23┊    \"@types/body-parser\": \"1.17.0\",\n ┊24┊24┊    \"@types/cors\": \"2.8.5\",\n+┊  ┊25┊    \"@types/cookie\": \"0.3.3\",\n ┊25┊26┊    \"@types/cookie-parser\": \"1.4.1\",\n ┊26┊27┊    \"@types/express\": \"4.17.0\",\n ┊27┊28┊    \"@types/graphql\": \"14.2.1\",\n```\n```diff\n@@ -39,6 +40,7 @@\n ┊39┊40┊    \"apollo-server-express\": \"2.6.3\",\n ┊40┊41┊    \"apollo-server-testing\": \"2.6.3\",\n ┊41┊42┊    \"body-parser\": \"1.19.0\",\n+┊  ┊43┊    \"cookie\": \"0.4.0\",\n ┊42┊44┊    \"cors\": \"2.8.5\",\n ┊43┊45┊    \"cookie-parser\": \"1.4.4\",\n ┊44┊46┊    \"express\": \"4.17.1\",\n```\n\n[}]: #\n\nNow you can go ahead and change the value of the `currentUserId` cookie and see how it affects the view anytime you refresh the page. Needless to say that this is not the most convenient way to switch between users, so we’re gonna implement a dedicated screen that will set the cookies for us.\n\nAll the auth related logic should go into a dedicated service since it can serve us vastly across the application, not just for a single component. Thus we will create a new service called `auth.service`, which will contain 3 basic functions for now: `signIn()`, `signOut()` and `isSignedIn():\n\n[{]: <helper> (diffStep 11.3 module=\"client\")\n\n#### [__Client__ Step 11.3: Add basic auth.service](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/41b5b52)\n\n##### Added src&#x2F;services&#x2F;auth.service.tsx\n```diff\n@@ -0,0 +1,26 @@\n+┊  ┊ 1┊import { useCallback } from 'react'\n+┊  ┊ 2┊import { useApolloClient } from 'react-apollo-hooks'\n+┊  ┊ 3┊\n+┊  ┊ 4┊export const signIn = (currentUserId: string) => {\n+┊  ┊ 5┊  document.cookie = `currentUserId=${currentUserId}`;\n+┊  ┊ 6┊\n+┊  ┊ 7┊  // This will become async in the near future\n+┊  ┊ 8┊  return Promise.resolve();\n+┊  ┊ 9┊};\n+┊  ┊10┊\n+┊  ┊11┊export const useSignOut = () => {\n+┊  ┊12┊  const client = useApolloClient()\n+┊  ┊13┊\n+┊  ┊14┊  return useCallback(() => {\n+┊  ┊15┊    // \"expires\" represents the lifespan of a cookie. Beyond that date the cookie will\n+┊  ┊16┊    // be deleted by the browser. \"expires\" cannot be viewed from \"document.cookie\"\n+┊  ┊17┊    document.cookie = `currentUserId=;expires=${new Date(0)}`;\n+┊  ┊18┊\n+┊  ┊19┊    // Clear cache\n+┊  ┊20┊    return client.clearStore();\n+┊  ┊21┊  }, [client])\n+┊  ┊22┊};\n+┊  ┊23┊\n+┊  ┊24┊export const isSignedIn = () => {\n+┊  ┊25┊  return /currentUserId=.+(;|$)/.test(document.cookie);\n+┊  ┊26┊};\n```\n\n[}]: #\n\nNow we will implement the `AuthScreen`. For now this screen should be fairly simple. It should contain a single `TextField` to specify the current user ID, and a `sign-in` button that will call the `signIn()` method with the specified ID. Once it does so, we will be proceeded to the `ChatsListScreen`. First we will download and save the following assets:\n\n- [`src/public/assets/whatsapp-icon.ping`](https://github.com/Urigo/WhatsApp-Clone-Client-React/raw/wip/cookie-auth/public/assets/whatsapp-icon.png)\n\n[{]: <helper> (diffStep 11.4 files=\"components\" module=\"client\")\n\n#### [__Client__ Step 11.4: Add AuthScreen](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/bfb36e7)\n\n##### Added src&#x2F;components&#x2F;AuthScreen&#x2F;index.tsx\n```diff\n@@ -0,0 +1,167 @@\n+┊   ┊  1┊import MaterialButton from '@material-ui/core/Button';\n+┊   ┊  2┊import MaterialTextField from '@material-ui/core/TextField';\n+┊   ┊  3┊import React from 'react';\n+┊   ┊  4┊import { useCallback, useState } from 'react';\n+┊   ┊  5┊import styled from 'styled-components';\n+┊   ┊  6┊import { signIn } from '../../services/auth.service';\n+┊   ┊  7┊import { RouteComponentProps } from 'react-router-dom';\n+┊   ┊  8┊\n+┊   ┊  9┊const Container = styled.div`\n+┊   ┊ 10┊  height: 100%;\n+┊   ┊ 11┊  background: radial-gradient(rgb(34, 65, 67), rgb(17, 48, 50)),\n+┊   ┊ 12┊    url(/assets/chat-background.jpg) no-repeat;\n+┊   ┊ 13┊  background-size: cover;\n+┊   ┊ 14┊  background-blend-mode: multiply;\n+┊   ┊ 15┊  color: white;\n+┊   ┊ 16┊`;\n+┊   ┊ 17┊\n+┊   ┊ 18┊const Intro = styled.div`\n+┊   ┊ 19┊  height: 265px;\n+┊   ┊ 20┊`;\n+┊   ┊ 21┊\n+┊   ┊ 22┊const Icon = styled.img`\n+┊   ┊ 23┊  width: 125px;\n+┊   ┊ 24┊  height: auto;\n+┊   ┊ 25┊  margin-left: auto;\n+┊   ┊ 26┊  margin-right: auto;\n+┊   ┊ 27┊  padding-top: 70px;\n+┊   ┊ 28┊  display: block;\n+┊   ┊ 29┊`;\n+┊   ┊ 30┊\n+┊   ┊ 31┊const Title = styled.h2`\n+┊   ┊ 32┊  width: 100%;\n+┊   ┊ 33┊  text-align: center;\n+┊   ┊ 34┊  color: white;\n+┊   ┊ 35┊`;\n+┊   ┊ 36┊\n+┊   ┊ 37┊// eslint-disable-next-line\n+┊   ┊ 38┊const Alternative = styled.div`\n+┊   ┊ 39┊  position: fixed;\n+┊   ┊ 40┊  bottom: 10px;\n+┊   ┊ 41┊  left: 10px;\n+┊   ┊ 42┊\n+┊   ┊ 43┊  a {\n+┊   ┊ 44┊    color: var(--secondary-bg);\n+┊   ┊ 45┊  }\n+┊   ┊ 46┊`;\n+┊   ┊ 47┊\n+┊   ┊ 48┊const SignInForm = styled.div`\n+┊   ┊ 49┊  height: calc(100% - 265px);\n+┊   ┊ 50┊`;\n+┊   ┊ 51┊\n+┊   ┊ 52┊const ActualForm = styled.form`\n+┊   ┊ 53┊  padding: 20px;\n+┊   ┊ 54┊`;\n+┊   ┊ 55┊\n+┊   ┊ 56┊const Section = styled.div`\n+┊   ┊ 57┊  width: 100%;\n+┊   ┊ 58┊  padding-bottom: 35px;\n+┊   ┊ 59┊`;\n+┊   ┊ 60┊\n+┊   ┊ 61┊const Legend = styled.legend`\n+┊   ┊ 62┊  font-weight: bold;\n+┊   ┊ 63┊  color: white;\n+┊   ┊ 64┊`;\n+┊   ┊ 65┊\n+┊   ┊ 66┊// eslint-disable-next-line\n+┊   ┊ 67┊const Label = styled.label`\n+┊   ┊ 68┊  color: white !important;\n+┊   ┊ 69┊`;\n+┊   ┊ 70┊\n+┊   ┊ 71┊// eslint-disable-next-line\n+┊   ┊ 72┊const Input = styled.input`\n+┊   ┊ 73┊  color: white;\n+┊   ┊ 74┊\n+┊   ┊ 75┊  &::placeholder {\n+┊   ┊ 76┊    color: var(--primary-bg);\n+┊   ┊ 77┊  }\n+┊   ┊ 78┊`;\n+┊   ┊ 79┊\n+┊   ┊ 80┊const TextField = styled(MaterialTextField)`\n+┊   ┊ 81┊  width: 100%;\n+┊   ┊ 82┊  position: relative;\n+┊   ┊ 83┊\n+┊   ┊ 84┊  > div::before {\n+┊   ┊ 85┊    border-color: white !important;\n+┊   ┊ 86┊  }\n+┊   ┊ 87┊\n+┊   ┊ 88┊  input {\n+┊   ┊ 89┊    color: white !important;\n+┊   ┊ 90┊\n+┊   ┊ 91┊    &::placeholder {\n+┊   ┊ 92┊      color: var(--primary-bg) !important;\n+┊   ┊ 93┊    }\n+┊   ┊ 94┊  }\n+┊   ┊ 95┊\n+┊   ┊ 96┊  label {\n+┊   ┊ 97┊    color: white !important;\n+┊   ┊ 98┊  }\n+┊   ┊ 99┊` as typeof MaterialTextField;\n+┊   ┊100┊\n+┊   ┊101┊const Button = styled(MaterialButton)`\n+┊   ┊102┊  width: 100px;\n+┊   ┊103┊  display: block !important;\n+┊   ┊104┊  margin: auto !important;\n+┊   ┊105┊  background-color: var(--secondary-bg) !important;\n+┊   ┊106┊\n+┊   ┊107┊  &[disabled] {\n+┊   ┊108┊    color: #38a81c;\n+┊   ┊109┊  }\n+┊   ┊110┊\n+┊   ┊111┊  &:not([disabled]) {\n+┊   ┊112┊    color: white;\n+┊   ┊113┊  }\n+┊   ┊114┊` as typeof MaterialButton;\n+┊   ┊115┊\n+┊   ┊116┊const AuthScreen: React.FC<RouteComponentProps<any>> = ({ history }) => {\n+┊   ┊117┊  const [userId, setUserId] = useState('');\n+┊   ┊118┊\n+┊   ┊119┊  const onUserIdChange = useCallback(({ target }) => {\n+┊   ┊120┊    setUserId(target.value);\n+┊   ┊121┊  }, []);\n+┊   ┊122┊\n+┊   ┊123┊  const maySignIn = useCallback(() => {\n+┊   ┊124┊    return !!userId;\n+┊   ┊125┊  }, [userId]);\n+┊   ┊126┊\n+┊   ┊127┊  const handleSignIn = useCallback(() => {\n+┊   ┊128┊    signIn(userId).then(() => {\n+┊   ┊129┊      history.replace('/chats');\n+┊   ┊130┊    });\n+┊   ┊131┊  }, [userId, history]);\n+┊   ┊132┊\n+┊   ┊133┊  return (\n+┊   ┊134┊    <Container>\n+┊   ┊135┊      <Intro>\n+┊   ┊136┊        <Icon src=\"assets/whatsapp-icon.png\" className=\"AuthScreen-icon\" />\n+┊   ┊137┊        <Title className=\"AuthScreen-title\">WhatsApp</Title>\n+┊   ┊138┊      </Intro>\n+┊   ┊139┊      <SignInForm>\n+┊   ┊140┊        <ActualForm>\n+┊   ┊141┊          <Legend>Sign in</Legend>\n+┊   ┊142┊          <Section>\n+┊   ┊143┊            <TextField\n+┊   ┊144┊              data-testid=\"user-id-input\"\n+┊   ┊145┊              label=\"User ID\"\n+┊   ┊146┊              value={userId}\n+┊   ┊147┊              onChange={onUserIdChange}\n+┊   ┊148┊              margin=\"normal\"\n+┊   ┊149┊              placeholder=\"Enter current user ID\"\n+┊   ┊150┊            />\n+┊   ┊151┊          </Section>\n+┊   ┊152┊          <Button\n+┊   ┊153┊            data-testid=\"sign-in-button\"\n+┊   ┊154┊            type=\"button\"\n+┊   ┊155┊            color=\"secondary\"\n+┊   ┊156┊            variant=\"contained\"\n+┊   ┊157┊            disabled={!maySignIn()}\n+┊   ┊158┊            onClick={handleSignIn}>\n+┊   ┊159┊            Sign in\n+┊   ┊160┊          </Button>\n+┊   ┊161┊        </ActualForm>\n+┊   ┊162┊      </SignInForm>\n+┊   ┊163┊    </Container>\n+┊   ┊164┊  );\n+┊   ┊165┊};\n+┊   ┊166┊\n+┊   ┊167┊export default AuthScreen;\n```\n\n[}]: #\n\nAccordingly we will define a new `/sign-in` route that will render the `AuthScreen` we’re under that path name:\n\n[{]: <helper> (diffStep 11.4 files=\"App\" module=\"client\")\n\n#### [__Client__ Step 11.4: Add AuthScreen](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/bfb36e7)\n\n##### Changed src&#x2F;App.tsx\n```diff\n@@ -5,6 +5,7 @@\n ┊ 5┊ 5┊  Redirect,\n ┊ 6┊ 6┊  RouteComponentProps,\n ┊ 7┊ 7┊} from 'react-router-dom';\n+┊  ┊ 8┊import AuthScreen from './components/AuthScreen';\n ┊ 8┊ 9┊import ChatRoomScreen from './components/ChatRoomScreen';\n ┊ 9┊10┊import ChatsListScreen from './components/ChatsListScreen';\n ┊10┊11┊import AnimatedSwitch from './components/AnimatedSwitch';\n```\n```diff\n@@ -16,6 +17,7 @@\n ┊16┊17┊  return (\n ┊17┊18┊    <BrowserRouter>\n ┊18┊19┊      <AnimatedSwitch>\n+┊  ┊20┊        <Route exact path=\"/sign-(in|up)\" component={AuthScreen} />\n ┊19┊21┊        <Route exact path=\"/chats\" component={ChatsListScreen} />\n ┊20┊22┊\n ┊21┊23┊        <Route\n```\n\n[}]: #\n\nThis is how the new screen should look like:\n\n![auth-screen](https://user-images.githubusercontent.com/7648874/55606715-7a56a180-57ac-11e9-8eea-2da5931cccf5.png)\n\nNow let’s type the `/sign-in` route in our browser’s navigation bar and assign a user ID, see how it affects what chats we see in the `ChatsListScreen`. You’ve probably noticed that there’s no way to escape from the `/chats` route unless we edit the browser’s navigation bar manually. To fix that, we will add a new sign-out button to the navbar of the `ChatsListScreen` that will call the `signOut()` method anytime we click on it, and will bring us back to the `AuthScreen`:\n\n[{]: <helper> (diffStep 11.5 module=\"client\")\n\n#### [__Client__ Step 11.5: Add sign-out button that ChatsNavbar](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/e8bb7a5)\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;ChatsNavbar.tsx\n```diff\n@@ -1,14 +1,48 @@\n ┊ 1┊ 1┊import React from 'react';\n-┊ 2┊  ┊import { Toolbar } from '@material-ui/core';\n+┊  ┊ 2┊import { Button, Toolbar } from '@material-ui/core';\n ┊ 3┊ 3┊import styled from 'styled-components';\n+┊  ┊ 4┊import SignOutIcon from '@material-ui/icons/PowerSettingsNew';\n+┊  ┊ 5┊import { useCallback } from 'react';\n+┊  ┊ 6┊import { useSignOut } from '../../services/auth.service';\n+┊  ┊ 7┊import { History } from 'history';\n ┊ 4┊ 8┊\n ┊ 5┊ 9┊const Container = styled(Toolbar)`\n+┊  ┊10┊  display: flex;\n ┊ 6┊11┊  background-color: var(--primary-bg);\n ┊ 7┊12┊  color: var(--primary-text);\n ┊ 8┊13┊  font-size: 20px;\n ┊ 9┊14┊  line-height: 40px;\n ┊10┊15┊` as typeof Toolbar;\n ┊11┊16┊\n-┊12┊  ┊const ChatsNavbar: React.FC = () => <Container>Whatsapp Clone</Container>;\n+┊  ┊17┊const Title = styled.div`\n+┊  ┊18┊  flex: 1;\n+┊  ┊19┊`;\n+┊  ┊20┊\n+┊  ┊21┊const LogoutButton = styled(Button)`\n+┊  ┊22┊  color: var(--primary-text) !important;\n+┊  ┊23┊` as typeof Button;\n+┊  ┊24┊\n+┊  ┊25┊interface ChildComponentProps {\n+┊  ┊26┊  history: History;\n+┊  ┊27┊}\n+┊  ┊28┊\n+┊  ┊29┊const ChatsNavbar: React.FC<ChildComponentProps> = ({ history }) => {\n+┊  ┊30┊  const signOut = useSignOut();\n+┊  ┊31┊\n+┊  ┊32┊  const handleSignOut = useCallback(() => {\n+┊  ┊33┊    signOut().then(() => {\n+┊  ┊34┊      history.replace('/sign-in');\n+┊  ┊35┊    });\n+┊  ┊36┊  }, [history, signOut]);\n+┊  ┊37┊\n+┊  ┊38┊  return (\n+┊  ┊39┊    <Container>\n+┊  ┊40┊      <Title>Whatsapp Clone</Title>\n+┊  ┊41┊      <LogoutButton data-testid=\"sign-out-button\" onClick={handleSignOut}>\n+┊  ┊42┊        <SignOutIcon />\n+┊  ┊43┊      </LogoutButton>\n+┊  ┊44┊    </Container>\n+┊  ┊45┊  );\n+┊  ┊46┊};\n ┊13┊47┊\n ┊14┊48┊export default ChatsNavbar;\n```\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;index.tsx\n```diff\n@@ -14,7 +14,7 @@\n ┊14┊14┊\n ┊15┊15┊const ChatsListScreen: React.FC<ChatsListScreenProps> = ({ history }) => (\n ┊16┊16┊  <Container>\n-┊17┊  ┊    <ChatsNavbar />\n+┊  ┊17┊    <ChatsNavbar history={history} />\n ┊18┊18┊    <ChatsList history={history} />\n ┊19┊19┊  </Container>\n ┊20┊20┊);\n```\n\n[}]: #\n\nAt this point we’ve got everything we need, but we will add a small touch to improve the user experience and make it feel more complete. Users who aren’t logged in shouldn’t be able to view any screen besides the `AuthScreen`. First they need to sign-in, and only then they will be able to view the `ChatsListScreen` and `ChatRoomScreen`. To achieve that, we will wrap all the components which require authentication before we provide them into their routes. This wrap will basically check whether a user is logged in or not by reading the cookies, and if not we will be redirected to the `/sign-in` route. Let’s implement that wrap in the `auth.service` and call it `withAuth()`:\n\n[{]: <helper> (diffStep 11.6 files=\"auth.service\" module=\"client\")\n\n#### [__Client__ Step 11.6: Add withAuth() route wrapper](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/4076b08)\n\n##### Changed src&#x2F;services&#x2F;auth.service.tsx\n```diff\n@@ -1,5 +1,26 @@\n-┊ 1┊  ┊import { useCallback } from 'react'\n-┊ 2┊  ┊import { useApolloClient } from 'react-apollo-hooks'\n+┊  ┊ 1┊import React from 'react';\n+┊  ┊ 2┊import { useCallback } from 'react';\n+┊  ┊ 3┊import { useApolloClient } from 'react-apollo-hooks';\n+┊  ┊ 4┊import { Redirect } from 'react-router-dom';\n+┊  ┊ 5┊import { useCacheService } from './cache.service';\n+┊  ┊ 6┊\n+┊  ┊ 7┊export const withAuth = <P extends object>(\n+┊  ┊ 8┊  Component: React.ComponentType<P>\n+┊  ┊ 9┊) => {\n+┊  ┊10┊  return (props: any) => {\n+┊  ┊11┊    if (!isSignedIn()) {\n+┊  ┊12┊      if (props.history.location.pathname === '/sign-in') {\n+┊  ┊13┊        return null;\n+┊  ┊14┊      }\n+┊  ┊15┊\n+┊  ┊16┊      return <Redirect to=\"/sign-in\" />;\n+┊  ┊17┊    }\n+┊  ┊18┊\n+┊  ┊19┊    useCacheService();\n+┊  ┊20┊\n+┊  ┊21┊    return <Component {...props as P} />;\n+┊  ┊22┊  };\n+┊  ┊23┊};\n ┊ 3┊24┊\n ┊ 4┊25┊export const signIn = (currentUserId: string) => {\n ┊ 5┊26┊  document.cookie = `currentUserId=${currentUserId}`;\n```\n\n[}]: #\n\nWe will use this function to wrap the right components in our app’s router. Note that since we used the `useCacheService()` directly in the `withAuth()` method, there’s no need to use it in the router itself anymore. This makes a lot more sense since there’s no need to stay subscribed to data that you're not gonna receive from the first place unless you’re logged-in:\n\n[{]: <helper> (diffStep 11.6 files=\"App\" module=\"client\")\n\n#### [__Client__ Step 11.6: Add withAuth() route wrapper](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/4076b08)\n\n##### Changed src&#x2F;App.tsx\n```diff\n@@ -9,32 +9,27 @@\n ┊ 9┊ 9┊import ChatRoomScreen from './components/ChatRoomScreen';\n ┊10┊10┊import ChatsListScreen from './components/ChatsListScreen';\n ┊11┊11┊import AnimatedSwitch from './components/AnimatedSwitch';\n-┊12┊  ┊import { useCacheService } from './services/cache.service';\n+┊  ┊12┊import { withAuth } from './services/auth.service';\n ┊13┊13┊\n-┊14┊  ┊const App: React.FC = () => {\n-┊15┊  ┊  useCacheService();\n+┊  ┊14┊const App: React.FC = () => (\n+┊  ┊15┊  <BrowserRouter>\n+┊  ┊16┊    <AnimatedSwitch>\n+┊  ┊17┊      <Route exact path=\"/sign-(in|up)\" component={AuthScreen} />\n+┊  ┊18┊      <Route exact path=\"/chats\" component={withAuth(ChatsListScreen)} />\n ┊16┊19┊\n-┊17┊  ┊  return (\n-┊18┊  ┊    <BrowserRouter>\n-┊19┊  ┊      <AnimatedSwitch>\n-┊20┊  ┊        <Route exact path=\"/sign-(in|up)\" component={AuthScreen} />\n-┊21┊  ┊        <Route exact path=\"/chats\" component={ChatsListScreen} />\n-┊22┊  ┊\n-┊23┊  ┊        <Route\n-┊24┊  ┊          exact\n-┊25┊  ┊          path=\"/chats/:chatId\"\n-┊26┊  ┊          component={({\n-┊27┊  ┊            match,\n-┊28┊  ┊            history,\n-┊29┊  ┊          }: RouteComponentProps<{ chatId: string }>) => (\n+┊  ┊20┊      <Route\n+┊  ┊21┊        exact\n+┊  ┊22┊        path=\"/chats/:chatId\"\n+┊  ┊23┊        component={withAuth(\n+┊  ┊24┊          ({ match, history }: RouteComponentProps<{ chatId: string }>) => (\n ┊30┊25┊            <ChatRoomScreen chatId={match.params.chatId} history={history} />\n-┊31┊  ┊          )}\n-┊32┊  ┊        />\n-┊33┊  ┊      </AnimatedSwitch>\n-┊34┊  ┊      <Route exact path=\"/\" render={redirectToChats} />\n-┊35┊  ┊    </BrowserRouter>\n-┊36┊  ┊  );\n-┊37┊  ┊};\n+┊  ┊26┊          )\n+┊  ┊27┊        )}\n+┊  ┊28┊      />\n+┊  ┊29┊    </AnimatedSwitch>\n+┊  ┊30┊    <Route exact path=\"/\" render={redirectToChats} />\n+┊  ┊31┊  </BrowserRouter>\n+┊  ┊32┊);\n ┊38┊33┊\n ┊39┊34┊const redirectToChats = () => <Redirect to=\"/chats\" />;\n ┊40┊35┊\n```\n\n[}]: #\n\nAssuming that you’re not logged-in, if you’ll try to force navigate to the `/chats` route you should be automatically redirected to the `/sign-in` form. We will finish the chapter here as we wanna keep things simple and gradual. It’s true that we haven’t implemented true authentication, but that would be addressed soon further in this tutorial."
          },
          {
            "manualTitle": "Step 12: Adding and removing chats",
            "stepRevision": "b6116e262e6215d6d67f73ab4d7a29126727eda3",
            "manualView": "Now that the users system is ready it would be a lot more comfortable to implement a chat creation feature. In the original Whatsapp, you can create a new chat based on your available contacts - a list of your contacts will appear on the screen and by picking one of the items you’ll basically be able to start chatting with the selected contact. However, since in our app we don’t have any real contacts (yet), we will implement the chats creation feature based on all available users in our DB. By picking a user from the users list we will be able to start chatting with it.\n\n![demo](https://user-images.githubusercontent.com/7648874/55896445-e4c67200-5bf0-11e9-9c1c-88318642ef81.gif)\n\nTo be able to fetch users in our system we will need to add a new query called `users`. The `users` query will retrieve all users except for current user:\n\n[{]: <helper> (diffStep 9.1 module=\"server\")\n\n#### [__Server__ Step 9.1: Add Query.users](https://github.com/Urigo/WhatsApp-Clone-Server/commit/225a12f)\n\n##### Changed schema&#x2F;resolvers.ts\n```diff\n@@ -82,6 +82,12 @@\n ┊82┊82┊\n ┊83┊83┊      return chat.participants.includes(currentUser.id) ? chat : null;\n ┊84┊84┊    },\n+┊  ┊85┊\n+┊  ┊86┊    users(root, args, { currentUser }) {\n+┊  ┊87┊      if (!currentUser) return [];\n+┊  ┊88┊\n+┊  ┊89┊      return users.filter(u => u.id !== currentUser.id);\n+┊  ┊90┊    },\n ┊85┊91┊  },\n ┊86┊92┊\n ┊87┊93┊  Mutation: {\n```\n\n##### Changed schema&#x2F;typeDefs.graphql\n```diff\n@@ -28,6 +28,7 @@\n ┊28┊28┊type Query {\n ┊29┊29┊  chats: [Chat!]!\n ┊30┊30┊  chat(chatId: ID!): Chat\n+┊  ┊31┊  users: [User!]!\n ┊31┊32┊}\n ┊32┊33┊\n ┊33┊34┊type Mutation {\n```\n\n##### Added tests&#x2F;queries&#x2F;\\__snapshots__&#x2F;getUsers.test.ts.snap\n```diff\n@@ -0,0 +1,55 @@\n+┊  ┊ 1┊// Jest Snapshot v1, https://goo.gl/fbAQLP\n+┊  ┊ 2┊\n+┊  ┊ 3┊exports[`Query.getUsers should fetch all users except the one signed-in 1`] = `\n+┊  ┊ 4┊Object {\n+┊  ┊ 5┊  \"users\": Array [\n+┊  ┊ 6┊    Object {\n+┊  ┊ 7┊      \"id\": \"2\",\n+┊  ┊ 8┊      \"name\": \"Ethan Gonzalez\",\n+┊  ┊ 9┊      \"picture\": \"https://randomuser.me/api/portraits/thumb/men/1.jpg\",\n+┊  ┊10┊    },\n+┊  ┊11┊    Object {\n+┊  ┊12┊      \"id\": \"3\",\n+┊  ┊13┊      \"name\": \"Bryan Wallace\",\n+┊  ┊14┊      \"picture\": \"https://randomuser.me/api/portraits/thumb/men/2.jpg\",\n+┊  ┊15┊    },\n+┊  ┊16┊    Object {\n+┊  ┊17┊      \"id\": \"4\",\n+┊  ┊18┊      \"name\": \"Avery Stewart\",\n+┊  ┊19┊      \"picture\": \"https://randomuser.me/api/portraits/thumb/women/1.jpg\",\n+┊  ┊20┊    },\n+┊  ┊21┊    Object {\n+┊  ┊22┊      \"id\": \"5\",\n+┊  ┊23┊      \"name\": \"Katie Peterson\",\n+┊  ┊24┊      \"picture\": \"https://randomuser.me/api/portraits/thumb/women/2.jpg\",\n+┊  ┊25┊    },\n+┊  ┊26┊  ],\n+┊  ┊27┊}\n+┊  ┊28┊`;\n+┊  ┊29┊\n+┊  ┊30┊exports[`Query.getUsers should fetch all users except the one signed-in 2`] = `\n+┊  ┊31┊Object {\n+┊  ┊32┊  \"users\": Array [\n+┊  ┊33┊    Object {\n+┊  ┊34┊      \"id\": \"1\",\n+┊  ┊35┊      \"name\": \"Ray Edwards\",\n+┊  ┊36┊      \"picture\": \"https://randomuser.me/api/portraits/thumb/lego/1.jpg\",\n+┊  ┊37┊    },\n+┊  ┊38┊    Object {\n+┊  ┊39┊      \"id\": \"3\",\n+┊  ┊40┊      \"name\": \"Bryan Wallace\",\n+┊  ┊41┊      \"picture\": \"https://randomuser.me/api/portraits/thumb/men/2.jpg\",\n+┊  ┊42┊    },\n+┊  ┊43┊    Object {\n+┊  ┊44┊      \"id\": \"4\",\n+┊  ┊45┊      \"name\": \"Avery Stewart\",\n+┊  ┊46┊      \"picture\": \"https://randomuser.me/api/portraits/thumb/women/1.jpg\",\n+┊  ┊47┊    },\n+┊  ┊48┊    Object {\n+┊  ┊49┊      \"id\": \"5\",\n+┊  ┊50┊      \"name\": \"Katie Peterson\",\n+┊  ┊51┊      \"picture\": \"https://randomuser.me/api/portraits/thumb/women/2.jpg\",\n+┊  ┊52┊    },\n+┊  ┊53┊  ],\n+┊  ┊54┊}\n+┊  ┊55┊`;\n```\n\n##### Added tests&#x2F;queries&#x2F;getUsers.test.ts\n```diff\n@@ -0,0 +1,51 @@\n+┊  ┊ 1┊import { createTestClient } from 'apollo-server-testing';\n+┊  ┊ 2┊import { ApolloServer, gql } from 'apollo-server-express';\n+┊  ┊ 3┊import schema from '../../schema';\n+┊  ┊ 4┊import { users } from '../../db';\n+┊  ┊ 5┊\n+┊  ┊ 6┊describe('Query.getUsers', () => {\n+┊  ┊ 7┊  it('should fetch all users except the one signed-in', async () => {\n+┊  ┊ 8┊    let currentUser = users[0];\n+┊  ┊ 9┊\n+┊  ┊10┊    const server = new ApolloServer({\n+┊  ┊11┊      schema,\n+┊  ┊12┊      context: () => ({ currentUser }),\n+┊  ┊13┊    });\n+┊  ┊14┊\n+┊  ┊15┊    const { query } = createTestClient(server);\n+┊  ┊16┊\n+┊  ┊17┊    let res = await query({\n+┊  ┊18┊      query: gql`\n+┊  ┊19┊        query GetUsers {\n+┊  ┊20┊          users {\n+┊  ┊21┊            id\n+┊  ┊22┊            name\n+┊  ┊23┊            picture\n+┊  ┊24┊          }\n+┊  ┊25┊        }\n+┊  ┊26┊      `,\n+┊  ┊27┊    });\n+┊  ┊28┊\n+┊  ┊29┊    expect(res.data).toBeDefined();\n+┊  ┊30┊    expect(res.errors).toBeUndefined();\n+┊  ┊31┊    expect(res.data).toMatchSnapshot();\n+┊  ┊32┊\n+┊  ┊33┊    currentUser = users[1];\n+┊  ┊34┊\n+┊  ┊35┊    res = await query({\n+┊  ┊36┊      query: gql`\n+┊  ┊37┊        query GetUsers {\n+┊  ┊38┊          users {\n+┊  ┊39┊            id\n+┊  ┊40┊            name\n+┊  ┊41┊            picture\n+┊  ┊42┊          }\n+┊  ┊43┊        }\n+┊  ┊44┊      `,\n+┊  ┊45┊    });\n+┊  ┊46┊\n+┊  ┊47┊    expect(res.data).toBeDefined();\n+┊  ┊48┊    expect(res.errors).toBeUndefined();\n+┊  ┊49┊    expect(res.data).toMatchSnapshot();\n+┊  ┊50┊  });\n+┊  ┊51┊});\n```\n\n[}]: #\n\nThis query will be reflected in a component called `UsersList`. First we will define and export a new fragment called `User`:\n\n[{]: <helper> (diffStep 12.1 files=\"graphql/fragments\" module=\"client\")\n\n#### [__Client__ Step 12.1: Add basic ChatCreationScreen](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/de87523)\n\n##### Changed src&#x2F;graphql&#x2F;fragments&#x2F;index.ts\n```diff\n@@ -1,3 +1,4 @@\n ┊1┊1┊export { default as chat } from './chat.fragment';\n ┊2┊2┊export { default as fullChat } from './fullChat.fragment';\n ┊3┊3┊export { default as message } from './message.fragment';\n+┊ ┊4┊export { default as user } from './user.fragment';\n```\n\n##### Added src&#x2F;graphql&#x2F;fragments&#x2F;user.fragment.ts\n```diff\n@@ -0,0 +1,9 @@\n+┊ ┊1┊import gql from 'graphql-tag';\n+┊ ┊2┊\n+┊ ┊3┊export default gql`\n+┊ ┊4┊  fragment User on User {\n+┊ ┊5┊    id\n+┊ ┊6┊    name\n+┊ ┊7┊    picture\n+┊ ┊8┊  }\n+┊ ┊9┊`;\n```\n\n[}]: #\n\nAnd then we will implement the `UsersList` component which is going to use the `users` query with the `User` fragment:\n\n[{]: <helper> (diffStep 12.1 files=\"UsersList\" module=\"client\")\n\n#### [__Client__ Step 12.1: Add basic ChatCreationScreen](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/de87523)\n\n##### Added src&#x2F;components&#x2F;UsersList.test.tsx\n```diff\n@@ -0,0 +1,46 @@\n+┊  ┊ 1┊import React from 'react';\n+┊  ┊ 2┊import { ApolloProvider } from 'react-apollo-hooks';\n+┊  ┊ 3┊import { cleanup, render, waitForDomChange } from '@testing-library/react';\n+┊  ┊ 4┊import { mockApolloClient } from '../test-helpers';\n+┊  ┊ 5┊import UsersList, { UsersListQuery } from './UsersList';\n+┊  ┊ 6┊import * as queries from '../graphql/queries';\n+┊  ┊ 7┊\n+┊  ┊ 8┊describe('UsersList', () => {\n+┊  ┊ 9┊  afterEach(cleanup);\n+┊  ┊10┊\n+┊  ┊11┊  it('renders fetched users data', async () => {\n+┊  ┊12┊    const client = mockApolloClient([\n+┊  ┊13┊      {\n+┊  ┊14┊        request: { query: UsersListQuery },\n+┊  ┊15┊        result: {\n+┊  ┊16┊          data: {\n+┊  ┊17┊            users: [\n+┊  ┊18┊              {\n+┊  ┊19┊                __typename: 'User',\n+┊  ┊20┊                id: 1,\n+┊  ┊21┊                name: 'Charles Dickhead',\n+┊  ┊22┊                picture: 'https://localhost:4000/dick.jpg',\n+┊  ┊23┊              },\n+┊  ┊24┊            ],\n+┊  ┊25┊          },\n+┊  ┊26┊        },\n+┊  ┊27┊      },\n+┊  ┊28┊    ]);\n+┊  ┊29┊\n+┊  ┊30┊    {\n+┊  ┊31┊      const { container, getByTestId } = render(\n+┊  ┊32┊        <ApolloProvider client={client}>\n+┊  ┊33┊          <UsersList />\n+┊  ┊34┊        </ApolloProvider>\n+┊  ┊35┊      );\n+┊  ┊36┊\n+┊  ┊37┊      await waitForDomChange({ container });\n+┊  ┊38┊\n+┊  ┊39┊      expect(getByTestId('name')).toHaveTextContent('Charles Dickhead');\n+┊  ┊40┊      expect(getByTestId('picture')).toHaveAttribute(\n+┊  ┊41┊        'src',\n+┊  ┊42┊        'https://localhost:4000/dick.jpg'\n+┊  ┊43┊      );\n+┊  ┊44┊    }\n+┊  ┊45┊  });\n+┊  ┊46┊});\n```\n\n##### Added src&#x2F;components&#x2F;UsersList.tsx\n```diff\n@@ -0,0 +1,64 @@\n+┊  ┊ 1┊import MaterialList from '@material-ui/core/List';\n+┊  ┊ 2┊import MaterialItem from '@material-ui/core/ListItem';\n+┊  ┊ 3┊import gql from 'graphql-tag';\n+┊  ┊ 4┊import React from 'react';\n+┊  ┊ 5┊import styled from 'styled-components';\n+┊  ┊ 6┊import * as fragments from '../graphql/fragments';\n+┊  ┊ 7┊import { useUsersListQuery } from '../graphql/types';\n+┊  ┊ 8┊\n+┊  ┊ 9┊const ActualList = styled(MaterialList)`\n+┊  ┊10┊  padding: 0;\n+┊  ┊11┊` as typeof MaterialList;\n+┊  ┊12┊\n+┊  ┊13┊const UserItem = styled(MaterialItem)`\n+┊  ┊14┊  position: relative;\n+┊  ┊15┊  padding: 7.5px 15px;\n+┊  ┊16┊  display: flex;\n+┊  ┊17┊  cursor: pinter;\n+┊  ┊18┊` as typeof MaterialItem;\n+┊  ┊19┊\n+┊  ┊20┊const ProfilePicture = styled.img`\n+┊  ┊21┊  height: 50px;\n+┊  ┊22┊  width: 50px;\n+┊  ┊23┊  object-fit: cover;\n+┊  ┊24┊  border-radius: 50%;\n+┊  ┊25┊`;\n+┊  ┊26┊\n+┊  ┊27┊const Name = styled.div`\n+┊  ┊28┊  padding-left: 15px;\n+┊  ┊29┊  font-weight: bold;\n+┊  ┊30┊`;\n+┊  ┊31┊\n+┊  ┊32┊export const UsersListQuery = gql`\n+┊  ┊33┊  query UsersList {\n+┊  ┊34┊    users {\n+┊  ┊35┊      ...User\n+┊  ┊36┊    }\n+┊  ┊37┊  }\n+┊  ┊38┊  ${fragments.user}\n+┊  ┊39┊`;\n+┊  ┊40┊\n+┊  ┊41┊const UsersList: React.FC = () => {\n+┊  ┊42┊  const { data, loading: loadingUsers } = useUsersListQuery();\n+┊  ┊43┊\n+┊  ┊44┊  if (data === undefined) return null;\n+┊  ┊45┊  const users = data.users;\n+┊  ┊46┊\n+┊  ┊47┊  return (\n+┊  ┊48┊    <ActualList>\n+┊  ┊49┊      {!loadingUsers &&\n+┊  ┊50┊        users.map(user => (\n+┊  ┊51┊          <UserItem key={user.id} button>\n+┊  ┊52┊            {user !== null && user.picture !== null && (\n+┊  ┊53┊              <React.Fragment>\n+┊  ┊54┊                <ProfilePicture data-testid=\"picture\" src={user.picture} />\n+┊  ┊55┊                <Name data-testid=\"name\">{user.name}</Name>\n+┊  ┊56┊              </React.Fragment>\n+┊  ┊57┊            )}\n+┊  ┊58┊          </UserItem>\n+┊  ┊59┊        ))}\n+┊  ┊60┊    </ActualList>\n+┊  ┊61┊  );\n+┊  ┊62┊};\n+┊  ┊63┊\n+┊  ┊64┊export default UsersList;\n```\n\n[}]: #\n\nThe list is likely to change when a new user signs-up. We will implement a subscription and live-update the list further this tutorial when we go through authentication. Now we will implement a new screen component called `ChatCreationScreen`. The screen will simply render the `UsersList` along with a navigation bar:\n\n[{]: <helper> (diffStep 12.1 files=\"ChatCreationScreen\" module=\"client\")\n\n#### [__Client__ Step 12.1: Add basic ChatCreationScreen](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/de87523)\n\n##### Added src&#x2F;components&#x2F;ChatCreationScreen&#x2F;ChatCreationNavbar.test.tsx\n```diff\n@@ -0,0 +1,26 @@\n+┊  ┊ 1┊import { createMemoryHistory } from 'history';\n+┊  ┊ 2┊import React from 'react';\n+┊  ┊ 3┊import { cleanup, render, fireEvent, wait } from '@testing-library/react';\n+┊  ┊ 4┊import ChatCreationNavbar from './ChatCreationNavbar';\n+┊  ┊ 5┊\n+┊  ┊ 6┊describe('ChatCreationNavbar', () => {\n+┊  ┊ 7┊  afterEach(cleanup);\n+┊  ┊ 8┊\n+┊  ┊ 9┊  it('goes back on arrow click', async () => {\n+┊  ┊10┊    const history = createMemoryHistory();\n+┊  ┊11┊\n+┊  ┊12┊    history.push('/new-chat');\n+┊  ┊13┊\n+┊  ┊14┊    await wait(() => expect(history.location.pathname).toEqual('/new-chat'));\n+┊  ┊15┊\n+┊  ┊16┊    {\n+┊  ┊17┊      const { container, getByTestId } = render(\n+┊  ┊18┊        <ChatCreationNavbar history={history} />\n+┊  ┊19┊      );\n+┊  ┊20┊\n+┊  ┊21┊      fireEvent.click(getByTestId('back-button'));\n+┊  ┊22┊\n+┊  ┊23┊      await wait(() => expect(history.location.pathname).toEqual('/chats'));\n+┊  ┊24┊    }\n+┊  ┊25┊  });\n+┊  ┊26┊});\n```\n\n##### Added src&#x2F;components&#x2F;ChatCreationScreen&#x2F;ChatCreationNavbar.tsx\n```diff\n@@ -0,0 +1,45 @@\n+┊  ┊ 1┊import ArrowBackIcon from '@material-ui/icons/ArrowBack';\n+┊  ┊ 2┊import { Toolbar, Button } from '@material-ui/core';\n+┊  ┊ 3┊import React from 'react';\n+┊  ┊ 4┊import { useCallback } from 'react';\n+┊  ┊ 5┊import styled from 'styled-components';\n+┊  ┊ 6┊import { History } from 'history';\n+┊  ┊ 7┊\n+┊  ┊ 8┊const Container = styled(Toolbar)`\n+┊  ┊ 9┊  display: flex;\n+┊  ┊10┊  background-color: var(--primary-bg);\n+┊  ┊11┊  color: var(--primary-text);\n+┊  ┊12┊  font-size: 20px;\n+┊  ┊13┊  line-height: 40px;\n+┊  ┊14┊` as typeof Toolbar;\n+┊  ┊15┊\n+┊  ┊16┊const BackButton = styled(Button)`\n+┊  ┊17┊  svg {\n+┊  ┊18┊    color: var(--primary-text);\n+┊  ┊19┊  }\n+┊  ┊20┊` as typeof Button;\n+┊  ┊21┊\n+┊  ┊22┊const Title = styled.div`\n+┊  ┊23┊  flex: 1;\n+┊  ┊24┊`;\n+┊  ┊25┊\n+┊  ┊26┊interface ChildComponentProps {\n+┊  ┊27┊  history: History;\n+┊  ┊28┊}\n+┊  ┊29┊\n+┊  ┊30┊const ChatCreationNavbar: React.FC<ChildComponentProps> = ({ history }) => {\n+┊  ┊31┊  const navBack = useCallback(() => {\n+┊  ┊32┊    history.replace('/chats');\n+┊  ┊33┊  }, [history]);\n+┊  ┊34┊\n+┊  ┊35┊  return (\n+┊  ┊36┊    <Container>\n+┊  ┊37┊      <BackButton data-testid=\"back-button\" onClick={navBack}>\n+┊  ┊38┊        <ArrowBackIcon />\n+┊  ┊39┊      </BackButton>\n+┊  ┊40┊      <Title>Create Chat</Title>\n+┊  ┊41┊    </Container>\n+┊  ┊42┊  );\n+┊  ┊43┊};\n+┊  ┊44┊\n+┊  ┊45┊export default ChatCreationNavbar;\n```\n\n##### Added src&#x2F;components&#x2F;ChatCreationScreen&#x2F;index.tsx\n```diff\n@@ -0,0 +1,29 @@\n+┊  ┊ 1┊import React from 'react';\n+┊  ┊ 2┊import styled from 'styled-components';\n+┊  ┊ 3┊import UsersList from '../UsersList';\n+┊  ┊ 4┊import ChatCreationNavbar from './ChatCreationNavbar';\n+┊  ┊ 5┊import { History } from 'history';\n+┊  ┊ 6┊\n+┊  ┊ 7┊// eslint-disable-next-line\n+┊  ┊ 8┊const Container = styled.div`\n+┊  ┊ 9┊  height: calc(100% - 56px);\n+┊  ┊10┊  overflow-y: overlay;\n+┊  ┊11┊`;\n+┊  ┊12┊\n+┊  ┊13┊// eslint-disable-next-line\n+┊  ┊14┊const StyledUsersList = styled(UsersList)`\n+┊  ┊15┊  height: calc(100% - 56px);\n+┊  ┊16┊`;\n+┊  ┊17┊\n+┊  ┊18┊interface ChildComponentProps {\n+┊  ┊19┊  history: History;\n+┊  ┊20┊}\n+┊  ┊21┊\n+┊  ┊22┊const ChatCreationScreen: React.FC<ChildComponentProps> = ({ history }) => (\n+┊  ┊23┊  <div>\n+┊  ┊24┊    <ChatCreationNavbar history={history} />\n+┊  ┊25┊    <UsersList />\n+┊  ┊26┊  </div>\n+┊  ┊27┊);\n+┊  ┊28┊\n+┊  ┊29┊export default ChatCreationScreen;\n```\n\n[}]: #\n\nThe screen will be available under the route `/new-chat`. The new route will be restricted, since only authenticated users should be able to access it:\n\n[{]: <helper> (diffStep 12.1 files=\"App\" module=\"client\")\n\n#### [__Client__ Step 12.1: Add basic ChatCreationScreen](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/de87523)\n\n##### Changed src&#x2F;App.tsx\n```diff\n@@ -8,6 +8,7 @@\n ┊ 8┊ 8┊import AuthScreen from './components/AuthScreen';\n ┊ 9┊ 9┊import ChatRoomScreen from './components/ChatRoomScreen';\n ┊10┊10┊import ChatsListScreen from './components/ChatsListScreen';\n+┊  ┊11┊import ChatCreationScreen from './components/ChatCreationScreen';\n ┊11┊12┊import AnimatedSwitch from './components/AnimatedSwitch';\n ┊12┊13┊import { withAuth } from './services/auth.service';\n ┊13┊14┊\n```\n```diff\n@@ -26,6 +27,8 @@\n ┊26┊27┊          )\n ┊27┊28┊        )}\n ┊28┊29┊      />\n+┊  ┊30┊\n+┊  ┊31┊      <Route exact path=\"/new-chat\" component={withAuth(ChatCreationScreen)} />\n ┊29┊32┊    </AnimatedSwitch>\n ┊30┊33┊    <Route exact path=\"/\" render={redirectToChats} />\n ┊31┊34┊  </BrowserRouter>\n```\n\n[}]: #\n\nthe `/new-chat` route will be accessible directly from the main `ChatsListScreen`. We will implement a navigation button which is gonna have a fixed position at the bottom right corner of the screen:\n\n[{]: <helper> (diffStep 12.1 files=\"AddChatButton\" module=\"client\")\n\n#### [__Client__ Step 12.1: Add basic ChatCreationScreen](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/de87523)\n\n##### Added src&#x2F;components&#x2F;ChatsListScreen&#x2F;AddChatButton.test.tsx\n```diff\n@@ -0,0 +1,27 @@\n+┊  ┊ 1┊import { createMemoryHistory } from 'history';\n+┊  ┊ 2┊import { ApolloProvider } from 'react-apollo-hooks';\n+┊  ┊ 3┊import React from 'react';\n+┊  ┊ 4┊import { cleanup, render, fireEvent, wait } from '@testing-library/react';\n+┊  ┊ 5┊import AddChatButton from './AddChatButton';\n+┊  ┊ 6┊import { mockApolloClient } from '../../test-helpers';\n+┊  ┊ 7┊\n+┊  ┊ 8┊describe('AddChatButton', () => {\n+┊  ┊ 9┊  afterEach(cleanup);\n+┊  ┊10┊\n+┊  ┊11┊  it('goes back on arrow click', async () => {\n+┊  ┊12┊    const history = createMemoryHistory();\n+┊  ┊13┊    const client = mockApolloClient();\n+┊  ┊14┊\n+┊  ┊15┊    {\n+┊  ┊16┊      const { container, getByTestId } = render(\n+┊  ┊17┊        <ApolloProvider client={client}>\n+┊  ┊18┊          <AddChatButton history={history} />\n+┊  ┊19┊        </ApolloProvider>\n+┊  ┊20┊      );\n+┊  ┊21┊\n+┊  ┊22┊      fireEvent.click(getByTestId('new-chat-button'));\n+┊  ┊23┊\n+┊  ┊24┊      await wait(() => expect(history.location.pathname).toEqual('/new-chat'));\n+┊  ┊25┊    }\n+┊  ┊26┊  });\n+┊  ┊27┊});\n```\n\n##### Added src&#x2F;components&#x2F;ChatsListScreen&#x2F;AddChatButton.tsx\n```diff\n@@ -0,0 +1,43 @@\n+┊  ┊ 1┊import Button from '@material-ui/core/Button';\n+┊  ┊ 2┊import ChatIcon from '@material-ui/icons/Chat';\n+┊  ┊ 3┊import React from 'react';\n+┊  ┊ 4┊import styled from 'styled-components';\n+┊  ┊ 5┊import { History } from 'history';\n+┊  ┊ 6┊\n+┊  ┊ 7┊const Container = styled.div`\n+┊  ┊ 8┊  position: fixed;\n+┊  ┊ 9┊  right: 10px;\n+┊  ┊10┊  bottom: 10px;\n+┊  ┊11┊\n+┊  ┊12┊  button {\n+┊  ┊13┊    min-width: 50px;\n+┊  ┊14┊    width: 50px;\n+┊  ┊15┊    height: 50px;\n+┊  ┊16┊    border-radius: 999px;\n+┊  ┊17┊    background-color: var(--secondary-bg);\n+┊  ┊18┊    color: white;\n+┊  ┊19┊  }\n+┊  ┊20┊`;\n+┊  ┊21┊interface ChildComponentProps {\n+┊  ┊22┊  history: History;\n+┊  ┊23┊}\n+┊  ┊24┊\n+┊  ┊25┊const AddChatButton: React.FC<ChildComponentProps> = ({ history }) => {\n+┊  ┊26┊  const onClick = () => {\n+┊  ┊27┊    history.push('/new-chat');\n+┊  ┊28┊  };\n+┊  ┊29┊\n+┊  ┊30┊  return (\n+┊  ┊31┊    <Container>\n+┊  ┊32┊      <Button\n+┊  ┊33┊        data-testid=\"new-chat-button\"\n+┊  ┊34┊        variant=\"contained\"\n+┊  ┊35┊        color=\"secondary\"\n+┊  ┊36┊        onClick={onClick}>\n+┊  ┊37┊        <ChatIcon />\n+┊  ┊38┊      </Button>\n+┊  ┊39┊    </Container>\n+┊  ┊40┊  );\n+┊  ┊41┊};\n+┊  ┊42┊\n+┊  ┊43┊export default AddChatButton;\n```\n\n[}]: #\n\nAnd then we will render it in the `ChatsListScreen`:\n\n[{]: <helper> (diffStep 12.1 files=\"ChatsListScreen/index\" module=\"client\")\n\n#### [__Client__ Step 12.1: Add basic ChatCreationScreen](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/de87523)\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;index.tsx\n```diff\n@@ -3,6 +3,7 @@\n ┊3┊3┊import ChatsList from './ChatsList';\n ┊4┊4┊import styled from 'styled-components';\n ┊5┊5┊import { History } from 'history';\n+┊ ┊6┊import AddChatButton from './AddChatButton';\n ┊6┊7┊\n ┊7┊8┊const Container = styled.div`\n ┊8┊9┊  height: 100vh;\n```\n```diff\n@@ -16,6 +17,7 @@\n ┊16┊17┊  <Container>\n ┊17┊18┊    <ChatsNavbar history={history} />\n ┊18┊19┊    <ChatsList history={history} />\n+┊  ┊20┊    <AddChatButton history={history} />\n ┊19┊21┊  </Container>\n ┊20┊22┊);\n ┊21┊23┊\n```\n\n[}]: #\n\nFor now we can only observe the users list. Our goal now is to be able to start chatting with a user once it has been clicked. First we will need to add a new mutation called `addChat` which will create a new chat document and add it to the chats collection. If the chat already exists we will return the existing instance. This behavior will help us navigate to the desired `ChatRoomScreen`, whether it exists or not:\n\n[{]: <helper> (diffStep 9.2 module=\"server\")\n\n#### [__Server__ Step 9.2: Add Mutation.addChat](https://github.com/Urigo/WhatsApp-Clone-Server/commit/84ee468)\n\n##### Changed schema&#x2F;resolvers.ts\n```diff\n@@ -1,6 +1,6 @@\n ┊1┊1┊import { withFilter } from 'apollo-server-express';\n ┊2┊2┊import { GraphQLDateTime } from 'graphql-iso-date';\n-┊3┊ ┊import { User, Message, chats, messages, users } from '../db';\n+┊ ┊3┊import { User, Message, Chat, chats, messages, users } from '../db';\n ┊4┊4┊import { Resolvers } from '../types/graphql';\n ┊5┊5┊\n ┊6┊6┊const resolvers: Resolvers = {\n```\n```diff\n@@ -124,6 +124,31 @@\n ┊124┊124┊\n ┊125┊125┊      return message;\n ┊126┊126┊    },\n+┊   ┊127┊\n+┊   ┊128┊    addChat(root, { recipientId }, { currentUser }) {\n+┊   ┊129┊      if (!currentUser) return null;\n+┊   ┊130┊      if (!users.some(u => u.id === recipientId)) return null;\n+┊   ┊131┊\n+┊   ┊132┊      let chat = chats.find(\n+┊   ┊133┊        c =>\n+┊   ┊134┊          c.participants.includes(currentUser.id) &&\n+┊   ┊135┊          c.participants.includes(recipientId)\n+┊   ┊136┊      );\n+┊   ┊137┊\n+┊   ┊138┊      if (chat) return chat;\n+┊   ┊139┊\n+┊   ┊140┊      const chatsIds = chats.map(c => Number(c.id));\n+┊   ┊141┊\n+┊   ┊142┊      chat = {\n+┊   ┊143┊        id: String(Math.max(...chatsIds) + 1),\n+┊   ┊144┊        participants: [currentUser.id, recipientId],\n+┊   ┊145┊        messages: [],\n+┊   ┊146┊      };\n+┊   ┊147┊\n+┊   ┊148┊      chats.push(chat);\n+┊   ┊149┊\n+┊   ┊150┊      return chat;\n+┊   ┊151┊    },\n ┊127┊152┊  },\n ┊128┊153┊\n ┊129┊154┊  Subscription: {\n```\n\n##### Changed schema&#x2F;typeDefs.graphql\n```diff\n@@ -33,6 +33,7 @@\n ┊33┊33┊\n ┊34┊34┊type Mutation {\n ┊35┊35┊  addMessage(chatId: ID!, content: String!): Message\n+┊  ┊36┊  addChat(recipientId: ID!): Chat\n ┊36┊37┊}\n ┊37┊38┊\n ┊38┊39┊type Subscription {\n```\n\n##### Added tests&#x2F;mutations&#x2F;\\__snapshots__&#x2F;addChat.test.ts.snap\n```diff\n@@ -0,0 +1,52 @@\n+┊  ┊ 1┊// Jest Snapshot v1, https://goo.gl/fbAQLP\n+┊  ┊ 2┊\n+┊  ┊ 3┊exports[`Mutation.addChat creates a new chat between current user and specified recipient 1`] = `\n+┊  ┊ 4┊Object {\n+┊  ┊ 5┊  \"addChat\": Object {\n+┊  ┊ 6┊    \"id\": \"5\",\n+┊  ┊ 7┊    \"name\": \"Bryan Wallace\",\n+┊  ┊ 8┊    \"participants\": Array [\n+┊  ┊ 9┊      Object {\n+┊  ┊10┊        \"id\": \"2\",\n+┊  ┊11┊      },\n+┊  ┊12┊      Object {\n+┊  ┊13┊        \"id\": \"3\",\n+┊  ┊14┊      },\n+┊  ┊15┊    ],\n+┊  ┊16┊  },\n+┊  ┊17┊}\n+┊  ┊18┊`;\n+┊  ┊19┊\n+┊  ┊20┊exports[`Mutation.addChat creates a new chat between current user and specified recipient 2`] = `\n+┊  ┊21┊Object {\n+┊  ┊22┊  \"chat\": Object {\n+┊  ┊23┊    \"id\": \"5\",\n+┊  ┊24┊    \"name\": \"Bryan Wallace\",\n+┊  ┊25┊    \"participants\": Array [\n+┊  ┊26┊      Object {\n+┊  ┊27┊        \"id\": \"2\",\n+┊  ┊28┊      },\n+┊  ┊29┊      Object {\n+┊  ┊30┊        \"id\": \"3\",\n+┊  ┊31┊      },\n+┊  ┊32┊    ],\n+┊  ┊33┊  },\n+┊  ┊34┊}\n+┊  ┊35┊`;\n+┊  ┊36┊\n+┊  ┊37┊exports[`Mutation.addChat returns the existing chat if so 1`] = `\n+┊  ┊38┊Object {\n+┊  ┊39┊  \"addChat\": Object {\n+┊  ┊40┊    \"id\": \"1\",\n+┊  ┊41┊    \"name\": \"Ethan Gonzalez\",\n+┊  ┊42┊    \"participants\": Array [\n+┊  ┊43┊      Object {\n+┊  ┊44┊        \"id\": \"1\",\n+┊  ┊45┊      },\n+┊  ┊46┊      Object {\n+┊  ┊47┊        \"id\": \"2\",\n+┊  ┊48┊      },\n+┊  ┊49┊    ],\n+┊  ┊50┊  },\n+┊  ┊51┊}\n+┊  ┊52┊`;\n```\n\n##### Added tests&#x2F;mutations&#x2F;addChat.test.ts\n```diff\n@@ -0,0 +1,89 @@\n+┊  ┊ 1┊import { createTestClient } from 'apollo-server-testing';\n+┊  ┊ 2┊import { ApolloServer, PubSub, gql } from 'apollo-server-express';\n+┊  ┊ 3┊import schema from '../../schema';\n+┊  ┊ 4┊import { resetDb, users } from '../../db';\n+┊  ┊ 5┊\n+┊  ┊ 6┊describe('Mutation.addChat', () => {\n+┊  ┊ 7┊  beforeEach(resetDb);\n+┊  ┊ 8┊\n+┊  ┊ 9┊  it('creates a new chat between current user and specified recipient', async () => {\n+┊  ┊10┊    const server = new ApolloServer({\n+┊  ┊11┊      schema,\n+┊  ┊12┊      context: () => ({\n+┊  ┊13┊        pubsub: new PubSub(),\n+┊  ┊14┊        currentUser: users[1],\n+┊  ┊15┊      }),\n+┊  ┊16┊    });\n+┊  ┊17┊\n+┊  ┊18┊    const { query, mutate } = createTestClient(server);\n+┊  ┊19┊\n+┊  ┊20┊    const addChatRes = await mutate({\n+┊  ┊21┊      variables: { recipientId: '3' },\n+┊  ┊22┊      mutation: gql`\n+┊  ┊23┊        mutation AddChat($recipientId: ID!) {\n+┊  ┊24┊          addChat(recipientId: $recipientId) {\n+┊  ┊25┊            id\n+┊  ┊26┊            name\n+┊  ┊27┊            participants {\n+┊  ┊28┊              id\n+┊  ┊29┊            }\n+┊  ┊30┊          }\n+┊  ┊31┊        }\n+┊  ┊32┊      `,\n+┊  ┊33┊    });\n+┊  ┊34┊\n+┊  ┊35┊    expect(addChatRes.data).toBeDefined();\n+┊  ┊36┊    expect(addChatRes.errors).toBeUndefined();\n+┊  ┊37┊    expect(addChatRes.data).toMatchSnapshot();\n+┊  ┊38┊\n+┊  ┊39┊    const getChatRes = await query({\n+┊  ┊40┊      variables: { chatId: '5' },\n+┊  ┊41┊      query: gql`\n+┊  ┊42┊        query GetChat($chatId: ID!) {\n+┊  ┊43┊          chat(chatId: $chatId) {\n+┊  ┊44┊            id\n+┊  ┊45┊            name\n+┊  ┊46┊            participants {\n+┊  ┊47┊              id\n+┊  ┊48┊            }\n+┊  ┊49┊          }\n+┊  ┊50┊        }\n+┊  ┊51┊      `,\n+┊  ┊52┊    });\n+┊  ┊53┊\n+┊  ┊54┊    expect(getChatRes.data).toBeDefined();\n+┊  ┊55┊    expect(getChatRes.errors).toBeUndefined();\n+┊  ┊56┊    expect(getChatRes.data).toMatchSnapshot();\n+┊  ┊57┊  });\n+┊  ┊58┊\n+┊  ┊59┊  it('returns the existing chat if so', async () => {\n+┊  ┊60┊    const server = new ApolloServer({\n+┊  ┊61┊      schema,\n+┊  ┊62┊      context: () => ({\n+┊  ┊63┊        pubsub: new PubSub(),\n+┊  ┊64┊        currentUser: users[0],\n+┊  ┊65┊      }),\n+┊  ┊66┊    });\n+┊  ┊67┊\n+┊  ┊68┊    const { query, mutate } = createTestClient(server);\n+┊  ┊69┊\n+┊  ┊70┊    const addChatRes = await mutate({\n+┊  ┊71┊      variables: { recipientId: '2' },\n+┊  ┊72┊      mutation: gql`\n+┊  ┊73┊        mutation AddChat($recipientId: ID!) {\n+┊  ┊74┊          addChat(recipientId: $recipientId) {\n+┊  ┊75┊            id\n+┊  ┊76┊            name\n+┊  ┊77┊            participants {\n+┊  ┊78┊              id\n+┊  ┊79┊            }\n+┊  ┊80┊          }\n+┊  ┊81┊        }\n+┊  ┊82┊      `,\n+┊  ┊83┊    });\n+┊  ┊84┊\n+┊  ┊85┊    expect(addChatRes.data).toBeDefined();\n+┊  ┊86┊    expect(addChatRes.errors).toBeUndefined();\n+┊  ┊87┊    expect(addChatRes.data).toMatchSnapshot();\n+┊  ┊88┊  });\n+┊  ┊89┊});\n```\n\n[}]: #\n\nTo use the new mutation, we will define a new callback called `onUserPick` in the `UsersList` so it can be used from the `ChatCreationScreen`:\n\n[{]: <helper> (diffStep 12.2 files=\"UsersList\" module=\"client\")\n\n#### [__Client__ Step 12.2: Create chat on user pick](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/2504bd3)\n\n##### Changed src&#x2F;components&#x2F;UsersList.test.tsx\n```diff\n@@ -1,6 +1,12 @@\n ┊ 1┊ 1┊import React from 'react';\n ┊ 2┊ 2┊import { ApolloProvider } from 'react-apollo-hooks';\n-┊ 3┊  ┊import { cleanup, render, waitForDomChange } from '@testing-library/react';\n+┊  ┊ 3┊import {\n+┊  ┊ 4┊  cleanup,\n+┊  ┊ 5┊  render,\n+┊  ┊ 6┊  fireEvent,\n+┊  ┊ 7┊  wait,\n+┊  ┊ 8┊  waitForDomChange,\n+┊  ┊ 9┊} from '@testing-library/react';\n ┊ 4┊10┊import { mockApolloClient } from '../test-helpers';\n ┊ 5┊11┊import UsersList, { UsersListQuery } from './UsersList';\n ┊ 6┊12┊import * as queries from '../graphql/queries';\n```\n```diff\n@@ -43,4 +49,45 @@\n ┊43┊49┊      );\n ┊44┊50┊    }\n ┊45┊51┊  });\n+┊  ┊52┊\n+┊  ┊53┊  it('triggers onUserPick() callback on user-item click', async () => {\n+┊  ┊54┊    const client = mockApolloClient([\n+┊  ┊55┊      {\n+┊  ┊56┊        request: { query: UsersListQuery },\n+┊  ┊57┊        result: {\n+┊  ┊58┊          data: {\n+┊  ┊59┊            users: [\n+┊  ┊60┊              {\n+┊  ┊61┊                __typename: 'User',\n+┊  ┊62┊                id: 1,\n+┊  ┊63┊                name: 'Charles Dickhead',\n+┊  ┊64┊                picture: 'https://localhost:4000/dick.jpg',\n+┊  ┊65┊              },\n+┊  ┊66┊            ],\n+┊  ┊67┊          },\n+┊  ┊68┊        },\n+┊  ┊69┊      },\n+┊  ┊70┊    ]);\n+┊  ┊71┊\n+┊  ┊72┊    const onUserPick = jest.fn(() => {});\n+┊  ┊73┊\n+┊  ┊74┊    {\n+┊  ┊75┊      const { container, getByTestId } = render(\n+┊  ┊76┊        <ApolloProvider client={client}>\n+┊  ┊77┊          <UsersList onUserPick={onUserPick} />\n+┊  ┊78┊        </ApolloProvider>\n+┊  ┊79┊      );\n+┊  ┊80┊\n+┊  ┊81┊      await waitForDomChange({ container });\n+┊  ┊82┊\n+┊  ┊83┊      fireEvent.click(getByTestId('user'));\n+┊  ┊84┊\n+┊  ┊85┊      await wait(() => expect(onUserPick.mock.calls.length).toBe(1));\n+┊  ┊86┊\n+┊  ┊87┊      expect(onUserPick.mock.calls[0][0].name).toEqual('Charles Dickhead');\n+┊  ┊88┊      expect(onUserPick.mock.calls[0][0].picture).toEqual(\n+┊  ┊89┊        'https://localhost:4000/dick.jpg'\n+┊  ┊90┊      );\n+┊  ┊91┊    }\n+┊  ┊92┊  });\n ┊46┊93┊});\n```\n\n##### Changed src&#x2F;components&#x2F;UsersList.tsx\n```diff\n@@ -4,7 +4,7 @@\n ┊ 4┊ 4┊import React from 'react';\n ┊ 5┊ 5┊import styled from 'styled-components';\n ┊ 6┊ 6┊import * as fragments from '../graphql/fragments';\n-┊ 7┊  ┊import { useUsersListQuery } from '../graphql/types';\n+┊  ┊ 7┊import { useUsersListQuery, User } from '../graphql/types';\n ┊ 8┊ 8┊\n ┊ 9┊ 9┊const ActualList = styled(MaterialList)`\n ┊10┊10┊  padding: 0;\n```\n```diff\n@@ -38,7 +38,13 @@\n ┊38┊38┊  ${fragments.user}\n ┊39┊39┊`;\n ┊40┊40┊\n-┊41┊  ┊const UsersList: React.FC = () => {\n+┊  ┊41┊interface ChildComponentProps {\n+┊  ┊42┊  onUserPick: any;\n+┊  ┊43┊}\n+┊  ┊44┊\n+┊  ┊45┊const UsersList: React.FC<ChildComponentProps> = ({\n+┊  ┊46┊  onUserPick = (user: User) => {},\n+┊  ┊47┊}) => {\n ┊42┊48┊  const { data, loading: loadingUsers } = useUsersListQuery();\n ┊43┊49┊\n ┊44┊50┊  if (data === undefined) return null;\n```\n```diff\n@@ -48,7 +54,11 @@\n ┊48┊54┊    <ActualList>\n ┊49┊55┊      {!loadingUsers &&\n ┊50┊56┊        users.map(user => (\n-┊51┊  ┊          <UserItem key={user.id} button>\n+┊  ┊57┊          <UserItem\n+┊  ┊58┊            key={user.id}\n+┊  ┊59┊            data-testid=\"user\"\n+┊  ┊60┊            onClick={onUserPick.bind(null, user)}\n+┊  ┊61┊            button>\n ┊52┊62┊            {user !== null && user.picture !== null && (\n ┊53┊63┊              <React.Fragment>\n ┊54┊64┊                <ProfilePicture data-testid=\"picture\" src={user.picture} />\n```\n\n[}]: #\n\nIn the `ChatCreationScreen/index.tsx` module, we will define an `AddChat` document with `graphql-tag`. Using the `$ yarn codegen` command we can generate the correlated React mutation hook and use it as the `onUserPick` callback:\n\n[{]: <helper> (diffStep 12.2 files=\"ChatCreationScreen/index\" module=\"client\")\n\n#### [__Client__ Step 12.2: Create chat on user pick](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/2504bd3)\n\n##### Changed src&#x2F;components&#x2F;ChatCreationScreen&#x2F;index.tsx\n```diff\n@@ -1,8 +1,12 @@\n+┊  ┊ 1┊import gql from 'graphql-tag';\n ┊ 1┊ 2┊import React from 'react';\n+┊  ┊ 3┊import { useCallback } from 'react';\n ┊ 2┊ 4┊import styled from 'styled-components';\n+┊  ┊ 5┊import * as fragments from '../../graphql/fragments';\n ┊ 3┊ 6┊import UsersList from '../UsersList';\n ┊ 4┊ 7┊import ChatCreationNavbar from './ChatCreationNavbar';\n ┊ 5┊ 8┊import { History } from 'history';\n+┊  ┊ 9┊import { useAddChatMutation } from '../../graphql/types';\n ┊ 6┊10┊\n ┊ 7┊11┊// eslint-disable-next-line\n ┊ 8┊12┊const Container = styled.div`\n```\n```diff\n@@ -15,15 +19,55 @@\n ┊15┊19┊  height: calc(100% - 56px);\n ┊16┊20┊`;\n ┊17┊21┊\n+┊  ┊22┊gql`\n+┊  ┊23┊  mutation AddChat($recipientId: ID!) {\n+┊  ┊24┊    addChat(recipientId: $recipientId) {\n+┊  ┊25┊      ...Chat\n+┊  ┊26┊    }\n+┊  ┊27┊  }\n+┊  ┊28┊  ${fragments.chat}\n+┊  ┊29┊`;\n+┊  ┊30┊\n ┊18┊31┊interface ChildComponentProps {\n ┊19┊32┊  history: History;\n ┊20┊33┊}\n ┊21┊34┊\n-┊22┊  ┊const ChatCreationScreen: React.FC<ChildComponentProps> = ({ history }) => (\n-┊23┊  ┊  <div>\n-┊24┊  ┊    <ChatCreationNavbar history={history} />\n-┊25┊  ┊    <UsersList />\n-┊26┊  ┊  </div>\n-┊27┊  ┊);\n+┊  ┊35┊const ChatCreationScreen: React.FC<ChildComponentProps> = ({ history }) => {\n+┊  ┊36┊  const addChat = useAddChatMutation();\n+┊  ┊37┊\n+┊  ┊38┊  const onUserPick = useCallback(\n+┊  ┊39┊    user => {\n+┊  ┊40┊      addChat({\n+┊  ┊41┊        optimisticResponse: {\n+┊  ┊42┊          __typename: 'Mutation',\n+┊  ┊43┊          addChat: {\n+┊  ┊44┊            __typename: 'Chat',\n+┊  ┊45┊            id: Math.random()\n+┊  ┊46┊              .toString(36)\n+┊  ┊47┊              .substr(2, 9),\n+┊  ┊48┊            name: user.name,\n+┊  ┊49┊            picture: user.picture,\n+┊  ┊50┊            lastMessage: null,\n+┊  ┊51┊          },\n+┊  ┊52┊        },\n+┊  ┊53┊        variables: {\n+┊  ┊54┊          recipientId: user.id,\n+┊  ┊55┊        },\n+┊  ┊56┊      }).then(({ data }) => {\n+┊  ┊57┊        if (data !== null) {\n+┊  ┊58┊          history.push(`/chats/${data.addChat.id}`);\n+┊  ┊59┊        }\n+┊  ┊60┊      });\n+┊  ┊61┊    },\n+┊  ┊62┊    [addChat, history]\n+┊  ┊63┊  );\n+┊  ┊64┊\n+┊  ┊65┊  return (\n+┊  ┊66┊    <div>\n+┊  ┊67┊      <ChatCreationNavbar history={history} />\n+┊  ┊68┊      <UsersList onUserPick={onUserPick} />\n+┊  ┊69┊    </div>\n+┊  ┊70┊  );\n+┊  ┊71┊};\n ┊28┊72┊\n ┊29┊73┊export default ChatCreationScreen;\n```\n\n[}]: #\n\nChats can now be created, you can test out the function by signing in with different users. However, the chats list in the `ChatsListScreen` will not be updated unless we refresh the page manually. In the server project, we will define a new subscription called `chatAdded`. The subscription should be broadcasted to the current user only if he is a participant of the published chat:\n\n[{]: <helper> (diffStep 9.3 module=\"server\")\n\n#### [__Server__ Step 9.3: Add Subscription.chatAdded](https://github.com/Urigo/WhatsApp-Clone-Server/commit/a9d1249)\n\n##### Changed schema&#x2F;resolvers.ts\n```diff\n@@ -125,7 +125,7 @@\n ┊125┊125┊      return message;\n ┊126┊126┊    },\n ┊127┊127┊\n-┊128┊   ┊    addChat(root, { recipientId }, { currentUser }) {\n+┊   ┊128┊    addChat(root, { recipientId }, { currentUser, pubsub }) {\n ┊129┊129┊      if (!currentUser) return null;\n ┊130┊130┊      if (!users.some(u => u.id === recipientId)) return null;\n ┊131┊131┊\n```\n```diff\n@@ -147,6 +147,10 @@\n ┊147┊147┊\n ┊148┊148┊      chats.push(chat);\n ┊149┊149┊\n+┊   ┊150┊      pubsub.publish('chatAdded', {\n+┊   ┊151┊        chatAdded: chat,\n+┊   ┊152┊      });\n+┊   ┊153┊\n ┊150┊154┊      return chat;\n ┊151┊155┊    },\n ┊152┊156┊  },\n```\n```diff\n@@ -164,6 +168,17 @@\n ┊164┊168┊        }\n ┊165┊169┊      ),\n ┊166┊170┊    },\n+┊   ┊171┊\n+┊   ┊172┊    chatAdded: {\n+┊   ┊173┊      subscribe: withFilter(\n+┊   ┊174┊        (root, args, { pubsub }) => pubsub.asyncIterator('chatAdded'),\n+┊   ┊175┊        ({ chatAdded }: { chatAdded: Chat }, args, { currentUser }) => {\n+┊   ┊176┊          if (!currentUser) return false;\n+┊   ┊177┊\n+┊   ┊178┊          return chatAdded.participants.some(p => p === currentUser.id);\n+┊   ┊179┊        }\n+┊   ┊180┊      ),\n+┊   ┊181┊    },\n ┊167┊182┊  },\n ┊168┊183┊};\n ┊169┊184┊\n```\n\n##### Changed schema&#x2F;typeDefs.graphql\n```diff\n@@ -38,4 +38,5 @@\n ┊38┊38┊\n ┊39┊39┊type Subscription {\n ┊40┊40┊  messageAdded: Message!\n+┊  ┊41┊  chatAdded: Chat!\n ┊41┊42┊}\n```\n\n[}]: #\n\nNow we will listen to the new subscription in the client and update the cache. First we will define the subscription document:\n\n[{]: <helper> (diffStep 12.3 files=\"graphql/subscriptions\" module=\"client\")\n\n#### [__Client__ Step 12.3: Write chat on chatAdded](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/5f5589d)\n\n##### Added src&#x2F;graphql&#x2F;subscriptions&#x2F;chatAdded.subscription.ts\n```diff\n@@ -0,0 +1,11 @@\n+┊  ┊ 1┊import gql from 'graphql-tag';\n+┊  ┊ 2┊import * as fragments from '../fragments';\n+┊  ┊ 3┊\n+┊  ┊ 4┊export default gql`\n+┊  ┊ 5┊  subscription ChatAdded {\n+┊  ┊ 6┊    chatAdded {\n+┊  ┊ 7┊      ...Chat\n+┊  ┊ 8┊    }\n+┊  ┊ 9┊  }\n+┊  ┊10┊  ${fragments.chat}\n+┊  ┊11┊`;\n```\n\n##### Changed src&#x2F;graphql&#x2F;subscriptions&#x2F;index.ts\n```diff\n@@ -1 +1,2 @@\n ┊1┊1┊export { default as messageAdded } from './messageAdded.subscription';\n+┊ ┊2┊export { default as chatAdded } from './chatAdded.subscription';\n```\n\n[}]: #\n\nAnd then we will update the `cache.service` to write the broadcasted chat to the store. We will write the fragment, and we will also update the `chats` query to contain the new chat. We will also check if the chat already exists before we update the query, because remember, the `addChat` mutation will return the chat even if it already exists, not if it was created only:\n\n[{]: <helper> (diffStep 12.3 module=\"client\")\n\n#### [__Client__ Step 12.3: Write chat on chatAdded](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/5f5589d)\n\n##### Changed src&#x2F;components&#x2F;ChatCreationScreen&#x2F;index.tsx\n```diff\n@@ -7,6 +7,7 @@\n ┊ 7┊ 7┊import ChatCreationNavbar from './ChatCreationNavbar';\n ┊ 8┊ 8┊import { History } from 'history';\n ┊ 9┊ 9┊import { useAddChatMutation } from '../../graphql/types';\n+┊  ┊10┊import { writeChat } from '../../services/cache.service';\n ┊10┊11┊\n ┊11┊12┊// eslint-disable-next-line\n ┊12┊13┊const Container = styled.div`\n```\n```diff\n@@ -33,7 +34,11 @@\n ┊33┊34┊}\n ┊34┊35┊\n ┊35┊36┊const ChatCreationScreen: React.FC<ChildComponentProps> = ({ history }) => {\n-┊36┊  ┊  const addChat = useAddChatMutation();\n+┊  ┊37┊  const addChat = useAddChatMutation({\n+┊  ┊38┊    update: (client, { data: { addChat } }) => {\n+┊  ┊39┊      writeChat(client, addChat);\n+┊  ┊40┊    },\n+┊  ┊41┊  });\n ┊37┊42┊\n ┊38┊43┊  const onUserPick = useCallback(\n ┊39┊44┊    user => {\n```\n\n##### Added src&#x2F;graphql&#x2F;subscriptions&#x2F;chatAdded.subscription.ts\n```diff\n@@ -0,0 +1,11 @@\n+┊  ┊ 1┊import gql from 'graphql-tag';\n+┊  ┊ 2┊import * as fragments from '../fragments';\n+┊  ┊ 3┊\n+┊  ┊ 4┊export default gql`\n+┊  ┊ 5┊  subscription ChatAdded {\n+┊  ┊ 6┊    chatAdded {\n+┊  ┊ 7┊      ...Chat\n+┊  ┊ 8┊    }\n+┊  ┊ 9┊  }\n+┊  ┊10┊  ${fragments.chat}\n+┊  ┊11┊`;\n```\n\n##### Changed src&#x2F;graphql&#x2F;subscriptions&#x2F;index.ts\n```diff\n@@ -1 +1,2 @@\n ┊1┊1┊export { default as messageAdded } from './messageAdded.subscription';\n+┊ ┊2┊export { default as chatAdded } from './chatAdded.subscription';\n```\n\n##### Changed src&#x2F;services&#x2F;cache.service.ts\n```diff\n@@ -3,7 +3,12 @@\n ┊ 3┊ 3┊import { ApolloClient } from 'apollo-client';\n ┊ 4┊ 4┊import * as fragments from '../graphql/fragments';\n ┊ 5┊ 5┊import * as queries from '../graphql/queries';\n-┊ 6┊  ┊import { MessageFragment, useMessageAddedSubscription } from '../graphql/types';\n+┊  ┊ 6┊import {\n+┊  ┊ 7┊  MessageFragment,\n+┊  ┊ 8┊  ChatFragment,\n+┊  ┊ 9┊  useMessageAddedSubscription,\n+┊  ┊10┊  useChatAddedSubscription,\n+┊  ┊11┊} from '../graphql/types';\n ┊ 7┊12┊\n ┊ 8┊13┊type Client = ApolloClient<any> | DataProxy;\n ┊ 9┊14┊\n```\n```diff\n@@ -15,6 +20,14 @@\n ┊15┊20┊      }\n ┊16┊21┊    },\n ┊17┊22┊  });\n+┊  ┊23┊\n+┊  ┊24┊  useChatAddedSubscription({\n+┊  ┊25┊    onSubscriptionData: ({ client, subscriptionData: { data } }) => {\n+┊  ┊26┊      if (data) {\n+┊  ┊27┊        writeChat(client, data.chatAdded);\n+┊  ┊28┊      }\n+┊  ┊29┊    },\n+┊  ┊30┊  });\n ┊18┊31┊};\n ┊19┊32┊\n ┊20┊33┊export const writeMessage = (client: Client, message: MessageFragment) => {\n```\n```diff\n@@ -84,3 +97,40 @@\n ┊ 84┊ 97┊    data: { chats: chats },\n ┊ 85┊ 98┊  });\n ┊ 86┊ 99┊};\n+┊   ┊100┊\n+┊   ┊101┊export const writeChat = (client: Client, chat: ChatFragment) => {\n+┊   ┊102┊  const chatId = defaultDataIdFromObject(chat);\n+┊   ┊103┊  if (chatId === null) {\n+┊   ┊104┊    return;\n+┊   ┊105┊  }\n+┊   ┊106┊\n+┊   ┊107┊  client.writeFragment({\n+┊   ┊108┊    id: chatId,\n+┊   ┊109┊    fragment: fragments.chat,\n+┊   ┊110┊    fragmentName: 'Chat',\n+┊   ┊111┊    data: chat,\n+┊   ┊112┊  });\n+┊   ┊113┊\n+┊   ┊114┊  let data;\n+┊   ┊115┊  try {\n+┊   ┊116┊    data = client.readQuery({\n+┊   ┊117┊      query: queries.chats,\n+┊   ┊118┊    });\n+┊   ┊119┊  } catch (e) {\n+┊   ┊120┊    return;\n+┊   ┊121┊  }\n+┊   ┊122┊\n+┊   ┊123┊  if (!data) return;\n+┊   ┊124┊\n+┊   ┊125┊  const chats = data.chats;\n+┊   ┊126┊\n+┊   ┊127┊  if (!chats) return;\n+┊   ┊128┊  if (chats.some((c: any) => c.id === chat.id)) return;\n+┊   ┊129┊\n+┊   ┊130┊  chats.unshift(chat);\n+┊   ┊131┊\n+┊   ┊132┊  client.writeQuery({\n+┊   ┊133┊    query: queries.chats,\n+┊   ┊134┊    data: { chats },\n+┊   ┊135┊  });\n+┊   ┊136┊};\n```\n\n[}]: #\n\nNow we can create new chats, and the chats list would be updated, without refreshing the page. You can also test it with 2 separate sessions in the browser and see how each tab/window affects the other. Lastly, we will implement a chat removal function. This is important as we don’t want to garbage our chats collection, sometimes we would like to clean up some of them.\n\nIn the back-end, let’s implement the `removeChat` mutation. The chat can only be removed only if the current user is one of the chat’s participants. The mutation will also remove all the messages which are related to the target chat, since we’re not gonna use them anymore. The chat will be removed for all participants. This is not exactly the behavior of the original Whatsapp, but to keep things simple we will go with that solution:\n\n[{]: <helper> (diffStep 9.4 module=\"server\")\n\n#### [__Server__ Step 9.4: Add Mutation.removeChat](https://github.com/Urigo/WhatsApp-Clone-Server/commit/dad0f49)\n\n##### Changed schema&#x2F;resolvers.ts\n```diff\n@@ -153,6 +153,30 @@\n ┊153┊153┊\n ┊154┊154┊      return chat;\n ┊155┊155┊    },\n+┊   ┊156┊\n+┊   ┊157┊    removeChat(root, { chatId }, { currentUser }) {\n+┊   ┊158┊      if (!currentUser) return null;\n+┊   ┊159┊\n+┊   ┊160┊      const chatIndex = chats.findIndex(c => c.id === chatId);\n+┊   ┊161┊\n+┊   ┊162┊      if (chatIndex === -1) return null;\n+┊   ┊163┊\n+┊   ┊164┊      const chat = chats[chatIndex];\n+┊   ┊165┊\n+┊   ┊166┊      if (!chat.participants.some(p => p === currentUser.id)) return null;\n+┊   ┊167┊\n+┊   ┊168┊      chat.messages.forEach(chatMessage => {\n+┊   ┊169┊        const chatMessageIndex = messages.findIndex(m => m.id === chatMessage);\n+┊   ┊170┊\n+┊   ┊171┊        if (chatMessageIndex !== -1) {\n+┊   ┊172┊          messages.splice(chatMessageIndex, 1);\n+┊   ┊173┊        }\n+┊   ┊174┊      });\n+┊   ┊175┊\n+┊   ┊176┊      chats.splice(chatIndex, 1);\n+┊   ┊177┊\n+┊   ┊178┊      return chatId;\n+┊   ┊179┊    },\n ┊156┊180┊  },\n ┊157┊181┊\n ┊158┊182┊  Subscription: {\n```\n\n##### Changed schema&#x2F;typeDefs.graphql\n```diff\n@@ -34,6 +34,7 @@\n ┊34┊34┊type Mutation {\n ┊35┊35┊  addMessage(chatId: ID!, content: String!): Message\n ┊36┊36┊  addChat(recipientId: ID!): Chat\n+┊  ┊37┊  removeChat(chatId: ID!): ID\n ┊37┊38┊}\n ┊38┊39┊\n ┊39┊40┊type Subscription {\n```\n\n##### Added tests&#x2F;mutations&#x2F;removeChat.test.ts\n```diff\n@@ -0,0 +1,52 @@\n+┊  ┊ 1┊import { createTestClient } from 'apollo-server-testing';\n+┊  ┊ 2┊import { ApolloServer, PubSub, gql } from 'apollo-server-express';\n+┊  ┊ 3┊import schema from '../../schema';\n+┊  ┊ 4┊import { resetDb, users } from '../../db';\n+┊  ┊ 5┊\n+┊  ┊ 6┊describe('Mutation.removeChat', () => {\n+┊  ┊ 7┊  beforeEach(resetDb);\n+┊  ┊ 8┊\n+┊  ┊ 9┊  it('removes chat by id', async () => {\n+┊  ┊10┊    const server = new ApolloServer({\n+┊  ┊11┊      schema,\n+┊  ┊12┊      context: () => ({\n+┊  ┊13┊        pubsub: new PubSub(),\n+┊  ┊14┊        currentUser: users[0],\n+┊  ┊15┊      }),\n+┊  ┊16┊    });\n+┊  ┊17┊\n+┊  ┊18┊    const { query, mutate } = createTestClient(server);\n+┊  ┊19┊\n+┊  ┊20┊    const addChatRes = await mutate({\n+┊  ┊21┊      variables: { chatId: '1' },\n+┊  ┊22┊      mutation: gql`\n+┊  ┊23┊        mutation RemoveChat($chatId: ID!) {\n+┊  ┊24┊          removeChat(chatId: $chatId)\n+┊  ┊25┊        }\n+┊  ┊26┊      `,\n+┊  ┊27┊    });\n+┊  ┊28┊\n+┊  ┊29┊    expect(addChatRes.data).toBeDefined();\n+┊  ┊30┊    expect(addChatRes.errors).toBeUndefined();\n+┊  ┊31┊    expect(addChatRes.data!.removeChat).toEqual('1');\n+┊  ┊32┊\n+┊  ┊33┊    const getChatRes = await query({\n+┊  ┊34┊      variables: { chatId: '1' },\n+┊  ┊35┊      query: gql`\n+┊  ┊36┊        query GetChat($chatId: ID!) {\n+┊  ┊37┊          chat(chatId: $chatId) {\n+┊  ┊38┊            id\n+┊  ┊39┊            name\n+┊  ┊40┊            participants {\n+┊  ┊41┊              id\n+┊  ┊42┊            }\n+┊  ┊43┊          }\n+┊  ┊44┊        }\n+┊  ┊45┊      `,\n+┊  ┊46┊    });\n+┊  ┊47┊\n+┊  ┊48┊    expect(addChatRes.data).toBeDefined();\n+┊  ┊49┊    expect(getChatRes.errors).toBeUndefined();\n+┊  ┊50┊    expect(addChatRes.data!.chat).toBeUndefined();\n+┊  ┊51┊  });\n+┊  ┊52┊});\n```\n\n[}]: #\n\nIn the client app, a chat could be removed directly from the `ChatRoomScreen`. On the top right corner, right on the navbar, we will add a dispose button that will call the `removeChat` mutation. Just like we did before, we will define the mutation document with `graphql-tag` and generate the correlated hook with CodeGen:\n\n[{]: <helper> (diffStep 12.4 module=\"client\")\n\n#### [__Client__ Step 12.4: Add chat removal function](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/34b99e9)\n\n##### Changed src&#x2F;components&#x2F;ChatRoomScreen&#x2F;ChatNavbar.test.tsx\n```diff\n@@ -1,12 +1,17 @@\n ┊ 1┊ 1┊import { createMemoryHistory } from 'history';\n ┊ 2┊ 2┊import React from 'react';\n+┊  ┊ 3┊import { ApolloProvider } from 'react-apollo-hooks';\n ┊ 3┊ 4┊import { cleanup, render, fireEvent, wait } from '@testing-library/react';\n+┊  ┊ 5┊import { mockApolloClient } from '../../test-helpers';\n ┊ 4┊ 6┊import ChatNavbar from './ChatNavbar';\n+┊  ┊ 7┊import { RemoveChatDocument } from '../../graphql/types';\n ┊ 5┊ 8┊\n ┊ 6┊ 9┊describe('ChatNavbar', () => {\n ┊ 7┊10┊  afterEach(cleanup);\n ┊ 8┊11┊\n ┊ 9┊12┊  it('renders chat data', () => {\n+┊  ┊13┊    const client = mockApolloClient();\n+┊  ┊14┊\n ┊10┊15┊    const chat = {\n ┊11┊16┊      id: '1',\n ┊12┊17┊      name: 'Foo Bar',\n```\n```diff\n@@ -14,7 +19,11 @@\n ┊14┊19┊    };\n ┊15┊20┊\n ┊16┊21┊    {\n-┊17┊  ┊      const { container, getByTestId } = render(<ChatNavbar chat={chat} />);\n+┊  ┊22┊      const { container, getByTestId } = render(\n+┊  ┊23┊        <ApolloProvider client={client}>\n+┊  ┊24┊          <ChatNavbar chat={chat} />\n+┊  ┊25┊        </ApolloProvider>\n+┊  ┊26┊      );\n ┊18┊27┊\n ┊19┊28┊      expect(getByTestId('chat-name')).toHaveTextContent('Foo Bar');\n ┊20┊29┊      expect(getByTestId('chat-picture')).toHaveAttribute(\n```\n```diff\n@@ -25,6 +34,8 @@\n ┊25┊34┊  });\n ┊26┊35┊\n ┊27┊36┊  it('goes back on arrow click', async () => {\n+┊  ┊37┊    const client = mockApolloClient();\n+┊  ┊38┊\n ┊28┊39┊    const chat = {\n ┊29┊40┊      id: '1',\n ┊30┊41┊      name: 'Foo Bar',\n```\n```diff\n@@ -39,7 +50,9 @@\n ┊39┊50┊\n ┊40┊51┊    {\n ┊41┊52┊      const { container, getByTestId } = render(\n-┊42┊  ┊        <ChatNavbar chat={chat} history={history} />\n+┊  ┊53┊        <ApolloProvider client={client}>\n+┊  ┊54┊          <ChatNavbar chat={chat} history={history} />\n+┊  ┊55┊        </ApolloProvider>\n ┊43┊56┊      );\n ┊44┊57┊\n ┊45┊58┊      fireEvent.click(getByTestId('back-button'));\n```\n```diff\n@@ -47,4 +60,44 @@\n ┊ 47┊ 60┊      await wait(() => expect(history.location.pathname).toEqual('/chats'));\n ┊ 48┊ 61┊    }\n ┊ 49┊ 62┊  });\n+┊   ┊ 63┊\n+┊   ┊ 64┊  it('goes back on chat removal', async () => {\n+┊   ┊ 65┊    const client = mockApolloClient([\n+┊   ┊ 66┊      {\n+┊   ┊ 67┊        request: {\n+┊   ┊ 68┊          query: RemoveChatDocument,\n+┊   ┊ 69┊          variables: { chatId: '1' },\n+┊   ┊ 70┊        },\n+┊   ┊ 71┊        result: {\n+┊   ┊ 72┊          data: {\n+┊   ┊ 73┊            removeChat: '1',\n+┊   ┊ 74┊          },\n+┊   ┊ 75┊        },\n+┊   ┊ 76┊      },\n+┊   ┊ 77┊    ]);\n+┊   ┊ 78┊\n+┊   ┊ 79┊    const chat = {\n+┊   ┊ 80┊      id: '1',\n+┊   ┊ 81┊      name: 'Foo Bar',\n+┊   ┊ 82┊      picture: 'https://localhost:4000/picture.jpg',\n+┊   ┊ 83┊    };\n+┊   ┊ 84┊\n+┊   ┊ 85┊    const history = createMemoryHistory();\n+┊   ┊ 86┊\n+┊   ┊ 87┊    history.push('/chats/1');\n+┊   ┊ 88┊\n+┊   ┊ 89┊    await wait(() => expect(history.location.pathname).toEqual('/chats/1'));\n+┊   ┊ 90┊\n+┊   ┊ 91┊    {\n+┊   ┊ 92┊      const { container, getByTestId } = render(\n+┊   ┊ 93┊        <ApolloProvider client={client}>\n+┊   ┊ 94┊          <ChatNavbar chat={chat} history={history} />\n+┊   ┊ 95┊        </ApolloProvider>\n+┊   ┊ 96┊      );\n+┊   ┊ 97┊\n+┊   ┊ 98┊      fireEvent.click(getByTestId('delete-button'));\n+┊   ┊ 99┊\n+┊   ┊100┊      await wait(() => expect(history.location.pathname).toEqual('/chats'));\n+┊   ┊101┊    }\n+┊   ┊102┊  });\n ┊ 50┊103┊});\n```\n\n##### Changed src&#x2F;components&#x2F;ChatRoomScreen&#x2F;ChatNavbar.tsx\n```diff\n@@ -1,10 +1,13 @@\n ┊ 1┊ 1┊import Button from '@material-ui/core/Button';\n ┊ 2┊ 2┊import Toolbar from '@material-ui/core/Toolbar';\n ┊ 3┊ 3┊import ArrowBackIcon from '@material-ui/icons/ArrowBack';\n+┊  ┊ 4┊import DeleteIcon from '@material-ui/icons/Delete';\n+┊  ┊ 5┊import gql from 'graphql-tag';\n ┊ 4┊ 6┊import React from 'react';\n ┊ 5┊ 7┊import { useCallback } from 'react';\n ┊ 6┊ 8┊import styled from 'styled-components';\n ┊ 7┊ 9┊import { History } from 'history';\n+┊  ┊10┊import { useRemoveChatMutation } from '../../graphql/types';\n ┊ 8┊11┊\n ┊ 9┊12┊const Container = styled(Toolbar)`\n ┊10┊13┊  padding: 0;\n```\n```diff\n@@ -20,6 +23,12 @@\n ┊20┊23┊  }\n ┊21┊24┊` as typeof Button;\n ┊22┊25┊\n+┊  ┊26┊const Rest = styled.div`\n+┊  ┊27┊  flex: 1;\n+┊  ┊28┊  display: flex;\n+┊  ┊29┊  justify-content: flex-end;\n+┊  ┊30┊`;\n+┊  ┊31┊\n ┊23┊32┊const Picture = styled.img`\n ┊24┊33┊  height: 40px;\n ┊25┊34┊  width: 40px;\n```\n```diff\n@@ -34,15 +43,38 @@\n ┊34┊43┊  line-height: 56px;\n ┊35┊44┊`;\n ┊36┊45┊\n+┊  ┊46┊const DeleteButton = styled(Button)`\n+┊  ┊47┊  color: var(--primary-text) !important;\n+┊  ┊48┊` as typeof Button;\n+┊  ┊49┊\n+┊  ┊50┊export const removeChatMutation = gql`\n+┊  ┊51┊  mutation RemoveChat($chatId: ID!) {\n+┊  ┊52┊    removeChat(chatId: $chatId)\n+┊  ┊53┊  }\n+┊  ┊54┊`;\n+┊  ┊55┊\n ┊37┊56┊interface ChatNavbarProps {\n ┊38┊57┊  history: History;\n-┊39┊  ┊  chat?: {\n+┊  ┊58┊  chat: {\n ┊40┊59┊    picture?: string | null;\n ┊41┊60┊    name?: string | null;\n+┊  ┊61┊    id: string;\n ┊42┊62┊  };\n ┊43┊63┊}\n ┊44┊64┊\n ┊45┊65┊const ChatNavbar: React.FC<ChatNavbarProps> = ({ chat, history }) => {\n+┊  ┊66┊  const removeChat = useRemoveChatMutation({\n+┊  ┊67┊    variables: {\n+┊  ┊68┊      chatId: chat.id,\n+┊  ┊69┊    },\n+┊  ┊70┊  });\n+┊  ┊71┊\n+┊  ┊72┊  const handleRemoveChat = useCallback(() => {\n+┊  ┊73┊    removeChat().then(() => {\n+┊  ┊74┊      history.replace('/chats');\n+┊  ┊75┊    });\n+┊  ┊76┊  }, [removeChat, history]);\n+┊  ┊77┊\n ┊46┊78┊  const navBack = useCallback(() => {\n ┊47┊79┊    history.replace('/chats');\n ┊48┊80┊  }, [history]);\n```\n```diff\n@@ -58,6 +90,11 @@\n ┊ 58┊ 90┊          <Name data-testid=\"chat-name\">{chat.name}</Name>\n ┊ 59┊ 91┊        </React.Fragment>\n ┊ 60┊ 92┊      )}\n+┊   ┊ 93┊      <Rest>\n+┊   ┊ 94┊        <DeleteButton data-testid=\"delete-button\" onClick={handleRemoveChat}>\n+┊   ┊ 95┊          <DeleteIcon />\n+┊   ┊ 96┊        </DeleteButton>\n+┊   ┊ 97┊      </Rest>\n ┊ 61┊ 98┊    </Container>\n ┊ 62┊ 99┊  );\n ┊ 63┊100┊};\n```\n\n[}]: #\n\nNormally this is a dangerous behavior because we wipe out the entire history without any warnings, which is not recommended. For tutoring purposes only we will keep it the way it is, because it makes things simple and easier to understand.\n\nTo be able to update the chats list cache, we will implement a `chatRemoved` subscription. The subscription will be broadcasted only to those who’re participants of the published chat:\n\n[{]: <helper> (diffStep 9.5 module=\"server\")\n\n#### [__Server__ Step 9.5: Add Subscription.chatRemoved](https://github.com/Urigo/WhatsApp-Clone-Server/commit/abdb732)\n\n##### Changed schema&#x2F;resolvers.ts\n```diff\n@@ -154,7 +154,7 @@\n ┊154┊154┊      return chat;\n ┊155┊155┊    },\n ┊156┊156┊\n-┊157┊   ┊    removeChat(root, { chatId }, { currentUser }) {\n+┊   ┊157┊    removeChat(root, { chatId }, { currentUser, pubsub }) {\n ┊158┊158┊      if (!currentUser) return null;\n ┊159┊159┊\n ┊160┊160┊      const chatIndex = chats.findIndex(c => c.id === chatId);\n```\n```diff\n@@ -175,6 +175,11 @@\n ┊175┊175┊\n ┊176┊176┊      chats.splice(chatIndex, 1);\n ┊177┊177┊\n+┊   ┊178┊      pubsub.publish('chatRemoved', {\n+┊   ┊179┊        chatRemoved: chat.id,\n+┊   ┊180┊        targetChat: chat,\n+┊   ┊181┊      });\n+┊   ┊182┊\n ┊178┊183┊      return chatId;\n ┊179┊184┊    },\n ┊180┊185┊  },\n```\n```diff\n@@ -203,6 +208,17 @@\n ┊203┊208┊        }\n ┊204┊209┊      ),\n ┊205┊210┊    },\n+┊   ┊211┊\n+┊   ┊212┊    chatRemoved: {\n+┊   ┊213┊      subscribe: withFilter(\n+┊   ┊214┊        (root, args, { pubsub }) => pubsub.asyncIterator('chatRemoved'),\n+┊   ┊215┊        ({ targetChat }: { targetChat: Chat }, args, { currentUser }) => {\n+┊   ┊216┊          if (!currentUser) return false;\n+┊   ┊217┊\n+┊   ┊218┊          return targetChat.participants.some(p => p === currentUser.id);\n+┊   ┊219┊        }\n+┊   ┊220┊      ),\n+┊   ┊221┊    },\n ┊206┊222┊  },\n ┊207┊223┊};\n ┊208┊224┊\n```\n\n##### Changed schema&#x2F;typeDefs.graphql\n```diff\n@@ -40,4 +40,5 @@\n ┊40┊40┊type Subscription {\n ┊41┊41┊  messageAdded: Message!\n ┊42┊42┊  chatAdded: Chat!\n+┊  ┊43┊  chatRemoved: ID!\n ┊43┊44┊}\n```\n\n[}]: #\n\nIn the client, we will define the right subscription document:\n\n[{]: <helper> (diffStep 12.5 files=\"graphql/subscriptions\" module=\"client\")\n\n#### [__Client__ Step 12.5: Update cache on chat removal](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/9ddbfb5)\n\n##### Added src&#x2F;graphql&#x2F;subscriptions&#x2F;chatRemoved.subscription.ts\n```diff\n@@ -0,0 +1,7 @@\n+┊ ┊1┊import gql from 'graphql-tag';\n+┊ ┊2┊\n+┊ ┊3┊export default gql`\n+┊ ┊4┊  subscription ChatRemoved {\n+┊ ┊5┊    chatRemoved\n+┊ ┊6┊  }\n+┊ ┊7┊`;\n```\n\n##### Changed src&#x2F;graphql&#x2F;subscriptions&#x2F;index.ts\n```diff\n@@ -1,2 +1,3 @@\n ┊1┊1┊export { default as messageAdded } from './messageAdded.subscription';\n ┊2┊2┊export { default as chatAdded } from './chatAdded.subscription';\n+┊ ┊3┊export { default as chatRemoved } from './chatRemoved.subscription';\n```\n\n[}]: #\n\nAnd we will update the `cache.service` to listen to the new subscription and update the `chats` query accordingly. When we deal with the fragment, we remove the `FullChat` fragment because it consists of the `Chat` fragment. If it was the other way around, we would still have some data leftovers from the `FullChat` on the fragment, because of how Apollo-Cache manages the store:\n\n[{]: <helper> (diffStep 12.5 files=\"cache.service\" module=\"client\")\n\n#### [__Client__ Step 12.5: Update cache on chat removal](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/9ddbfb5)\n\n##### Changed src&#x2F;services&#x2F;cache.service.ts\n```diff\n@@ -8,6 +8,7 @@\n ┊ 8┊ 8┊  ChatFragment,\n ┊ 9┊ 9┊  useMessageAddedSubscription,\n ┊10┊10┊  useChatAddedSubscription,\n+┊  ┊11┊  useChatRemovedSubscription,\n ┊11┊12┊} from '../graphql/types';\n ┊12┊13┊\n ┊13┊14┊type Client = ApolloClient<any> | DataProxy;\n```\n```diff\n@@ -28,6 +29,14 @@\n ┊28┊29┊      }\n ┊29┊30┊    },\n ┊30┊31┊  });\n+┊  ┊32┊\n+┊  ┊33┊  useChatRemovedSubscription({\n+┊  ┊34┊    onSubscriptionData: ({ client, subscriptionData: { data } }) => {\n+┊  ┊35┊      if (data) {\n+┊  ┊36┊        eraseChat(client, data.chatRemoved);\n+┊  ┊37┊      }\n+┊  ┊38┊    },\n+┊  ┊39┊  });\n ┊31┊40┊};\n ┊32┊41┊\n ┊33┊42┊export const writeMessage = (client: Client, message: MessageFragment) => {\n```\n```diff\n@@ -134,3 +143,49 @@\n ┊134┊143┊    data: { chats },\n ┊135┊144┊  });\n ┊136┊145┊};\n+┊   ┊146┊\n+┊   ┊147┊export const eraseChat = (client: Client, chatId: string) => {\n+┊   ┊148┊  const chatType = {\n+┊   ┊149┊    __typename: 'Chat',\n+┊   ┊150┊    id: chatId,\n+┊   ┊151┊  };\n+┊   ┊152┊\n+┊   ┊153┊  const chatIdFromObject = defaultDataIdFromObject(chatType);\n+┊   ┊154┊  if (chatIdFromObject === null) {\n+┊   ┊155┊    return;\n+┊   ┊156┊  }\n+┊   ┊157┊\n+┊   ┊158┊  client.writeFragment({\n+┊   ┊159┊    id: chatIdFromObject,\n+┊   ┊160┊    fragment: fragments.fullChat,\n+┊   ┊161┊    fragmentName: 'FullChat',\n+┊   ┊162┊    data: null,\n+┊   ┊163┊  });\n+┊   ┊164┊\n+┊   ┊165┊  let data;\n+┊   ┊166┊  try {\n+┊   ┊167┊    data = client.readQuery({\n+┊   ┊168┊      query: queries.chats,\n+┊   ┊169┊    });\n+┊   ┊170┊  } catch (e) {\n+┊   ┊171┊    return;\n+┊   ┊172┊  }\n+┊   ┊173┊\n+┊   ┊174┊  if (!data || !data.chats) return;\n+┊   ┊175┊\n+┊   ┊176┊  const chats = data.chats;\n+┊   ┊177┊\n+┊   ┊178┊  if (!chats) return;\n+┊   ┊179┊\n+┊   ┊180┊  const chatIndex = chats.findIndex((c: any) => c.id === chatId);\n+┊   ┊181┊\n+┊   ┊182┊  if (chatIndex === -1) return;\n+┊   ┊183┊\n+┊   ┊184┊  // The chat will appear at the top of the ChatsList component\n+┊   ┊185┊  chats.splice(chatIndex, 1);\n+┊   ┊186┊\n+┊   ┊187┊  client.writeQuery({\n+┊   ┊188┊    query: queries.chats,\n+┊   ┊189┊    data: { chats: chats },\n+┊   ┊190┊  });\n+┊   ┊191┊};\n```\n\n[}]: #\n\nWe will also update the `ChatRoomScreen` to redirect us to the `/chats` route if the chat was not found. The render method of the component will be re-triggered automatically by `react-apollo-hooks` if the cached result of `useGetChat()` hook has changed, which means that even if you didn’t actively remove the chat, you will still be redirected as a result:\n\n[{]: <helper> (diffStep 12.5 files=\"ChatRoom\" module=\"client\")\n\n#### [__Client__ Step 12.5: Update cache on chat removal](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/9ddbfb5)\n\n##### Changed src&#x2F;components&#x2F;ChatRoomScreen&#x2F;ChatNavbar.tsx\n```diff\n@@ -8,6 +8,7 @@\n ┊ 8┊ 8┊import styled from 'styled-components';\n ┊ 9┊ 9┊import { History } from 'history';\n ┊10┊10┊import { useRemoveChatMutation } from '../../graphql/types';\n+┊  ┊11┊import { eraseChat } from '../../services/cache.service';\n ┊11┊12┊\n ┊12┊13┊const Container = styled(Toolbar)`\n ┊13┊14┊  padding: 0;\n```\n```diff\n@@ -67,6 +68,9 @@\n ┊67┊68┊    variables: {\n ┊68┊69┊      chatId: chat.id,\n ┊69┊70┊    },\n+┊  ┊71┊    update: (client, { data: { removeChat } }) => {\n+┊  ┊72┊      eraseChat(client, removeChat);\n+┊  ┊73┊    },\n ┊70┊74┊  });\n ┊71┊75┊\n ┊72┊76┊  const handleRemoveChat = useCallback(() => {\n```\n\n##### Changed src&#x2F;components&#x2F;ChatRoomScreen&#x2F;index.tsx\n```diff\n@@ -1,6 +1,7 @@\n ┊1┊1┊import gql from 'graphql-tag';\n ┊2┊2┊import React from 'react';\n ┊3┊3┊import { useCallback } from 'react';\n+┊ ┊4┊import { Redirect } from 'react-router-dom';\n ┊4┊5┊import styled from 'styled-components';\n ┊5┊6┊import ChatNavbar from './ChatNavbar';\n ┊6┊7┊import MessageInput from './MessageInput';\n```\n```diff\n@@ -95,6 +96,11 @@\n ┊ 95┊ 96┊  if (loadingChat) return null;\n ┊ 96┊ 97┊  if (chat === null) return null;\n ┊ 97┊ 98┊\n+┊   ┊ 99┊  // Chat was probably removed from cache by the subscription handler\n+┊   ┊100┊  if (!chat) {\n+┊   ┊101┊    return <Redirect to=\"/chats\" />;\n+┊   ┊102┊  }\n+┊   ┊103┊\n ┊ 98┊104┊  return (\n ┊ 99┊105┊    <Container>\n ┊100┊106┊      <ChatNavbar chat={chat} history={history} />\n```\n\n[}]: #\n\nTODO: maybe mention that ApolloCache doesn’t have Garbage Collector so even though the object is removed, everything else related to it says in cache."
          },
          {
            "manualTitle": "Step 13: Authentication",
            "stepRevision": "f6d8f047e5dc4aac39554208c89c4aa90d632c77",
            "manualView": "In the previous step we’ve set the ground for the authentication system in our app. We have a users collection which can be used to distinguish which data the client is authorized to view, and we have a context handler which can retrieve the current user logged in based on the received value of the `cookie` header. It’s definitely a good starting point, but it misses a lot of things.\n\nIn this chapter we will implement a cookie-based authentication system. There are many ways to implement an authentication system in an app, but cookie-based authentication is one of the most popular ones, hence we will go with that method. Essentially the authentication flow in our app should look very simple: a user will be able to sign-in with a dedicated screen, and if he doesn’t own an account he can use the sign-up screen to create a new one. The more complicated part in this flow is the back-end, which is the core of this chapter. So before we get into the implementation, we need to understand the authentication process:\n\n- A user logs in with a username and a password.\nThe server compares the received username and password to the ones stored in the database.\n- If the comparison was successful, the server will generate a token and will set it as a cookie.\n- Each time a request is sent, the server will retrieve the username from the stored token on the cookie header and will send data back accordingly.\n\n![auth-flow](https://user-images.githubusercontent.com/7648874/55929679-55e94200-5c50-11e9-9fe7-54ad6194a572.png)\n\nThe stored token will save us the hassle of re-specifying the username and password over and over again each and every request. It’s important to note that everything in the authentication process is encrypted, **sensitive information will never be stored or sent in its raw form**, otherwise data might be stolen in case of a DB breach or a request hijacking. This is what it means for our app:\n\n- Passwords will always be stored in an encrypted form in the DB using an algorithm called [Bcrypt](https://en.wikipedia.org/wiki/Bcrypt). Bcrypt has the ability to compare the password in its raw form to the encrypted one, which can help us authorize the user.\n\n- Tokens are self contained. That means that once we decode the encrypted string we can get a hold of the username string. This form of encrypted tokens is called [Json Web Token (JWT)](https://jwt.io/).\n\n> We're not going to elaborate about the algorithm behind each encryption method because we want to focus more on practicality, although it's very much recommended to understand how each method works before proceeding.\n\nThe implementation will follow the principles above. Authentication is a hot topic in the GraphQL world and there are several ways of doing so. We will start with the back-end and set the infrastructure for authentication, and then we will move on to the front-end.\n\nWe’re gonna expose 2 new mutations from GraphQL Schema: `signIn` and `signUp`. `/sign-out` is unnecessary because it can be done locally by deleting the right cookie. Our back-end is gonna grow bigger so first we will separate the Express app from the Apollo Server instance, and extract the env vars to a dedicated module:\n\n[{]: <helper> (diffStep 10.1 module=\"server\")\n\n#### [__Server__ Step 10.1: Separate app into a different module](https://github.com/Urigo/WhatsApp-Clone-Server/commit/c1f3d95)\n\n##### Added app.ts\n```diff\n@@ -0,0 +1,15 @@\n+┊  ┊ 1┊import bodyParser from 'body-parser';\n+┊  ┊ 2┊import cors from 'cors';\n+┊  ┊ 3┊import cookieParser from 'cookie-parser';\n+┊  ┊ 4┊import express from 'express';\n+┊  ┊ 5┊import { origin } from './env';\n+┊  ┊ 6┊\n+┊  ┊ 7┊export const app = express();\n+┊  ┊ 8┊\n+┊  ┊ 9┊app.use(cors({ credentials: true, origin }));\n+┊  ┊10┊app.use(bodyParser.json());\n+┊  ┊11┊app.use(cookieParser());\n+┊  ┊12┊\n+┊  ┊13┊app.get('/_ping', (req, res) => {\n+┊  ┊14┊  res.send('pong');\n+┊  ┊15┊});\n```\n\n##### Added env.ts\n```diff\n@@ -0,0 +1,2 @@\n+┊ ┊1┊export const origin = process.env.ORIGIN || 'http://localhost:3000';\n+┊ ┊2┊export const port = process.env.PORT || 4000;\n```\n\n##### Changed index.ts\n```diff\n@@ -1,24 +1,11 @@\n ┊ 1┊ 1┊import { ApolloServer, gql, PubSub } from 'apollo-server-express';\n-┊ 2┊  ┊import bodyParser from 'body-parser';\n-┊ 3┊  ┊import cors from 'cors';\n-┊ 4┊  ┊import cookieParser from 'cookie-parser';\n ┊ 5┊ 2┊import cookie from 'cookie';\n-┊ 6┊  ┊import express from 'express';\n ┊ 7┊ 3┊import http from 'http';\n+┊  ┊ 4┊import { app } from './app';\n ┊ 8┊ 5┊import { users } from './db';\n+┊  ┊ 6┊import { origin, port } from './env';\n ┊ 9┊ 7┊import schema from './schema';\n ┊10┊ 8┊\n-┊11┊  ┊const app = express();\n-┊12┊  ┊\n-┊13┊  ┊const origin = process.env.ORIGIN || 'http://localhost:3000';\n-┊14┊  ┊app.use(cors({ credentials: true, origin }));\n-┊15┊  ┊app.use(bodyParser.json());\n-┊16┊  ┊app.use(cookieParser());\n-┊17┊  ┊\n-┊18┊  ┊app.get('/_ping', (req, res) => {\n-┊19┊  ┊  res.send('pong');\n-┊20┊  ┊});\n-┊21┊  ┊\n ┊22┊ 9┊const pubsub = new PubSub();\n ┊23┊10┊const server = new ApolloServer({\n ┊24┊11┊  schema,\n```\n```diff\n@@ -57,8 +44,6 @@\n ┊57┊44┊const httpServer = http.createServer(app);\n ┊58┊45┊server.installSubscriptionHandlers(httpServer);\n ┊59┊46┊\n-┊60┊  ┊const port = process.env.PORT || 4000;\n-┊61┊  ┊\n ┊62┊47┊httpServer.listen(port, () => {\n ┊63┊48┊  console.log(`Server is listening on port ${port}`);\n ┊64┊49┊});\n```\n\n[}]: #\n\nWe will first start with the `signIn` mutation, so we can test it against pre-defined user credentials, and then we will proceed to implementing the `signUp` mutation. It would be a lot easier to progress this way. For that we will install a couple of packages:\n\n- `bcrypt` - which is responsible for running a one-way encryption against received passwords before they’re stored in the DB.\n- `jsonwebtoken` - responsible for encrypting the logged-in username before it’s set as a cooky and decrypting it once it’s sent back with a request.\n\n    $ yarn add bcrypt jsonwebtoken\n\n\n    $ yarn add --dev @types/bcrypt @types/jsonwebtoken\n\nAnd we will implement the `signIn` mutation:\n\n[{]: <helper> (diffStep 10.2 files=\"schema\" module=\"server\")\n\n#### [__Server__ Step 10.2: Add signIn mutation](https://github.com/Urigo/WhatsApp-Clone-Server/commit/b4c55f8)\n\n##### Changed schema&#x2F;resolvers.ts\n```diff\n@@ -2,6 +2,9 @@\n ┊ 2┊ 2┊import { GraphQLDateTime } from 'graphql-iso-date';\n ┊ 3┊ 3┊import { User, Message, Chat, chats, messages, users } from '../db';\n ┊ 4┊ 4┊import { Resolvers } from '../types/graphql';\n+┊  ┊ 5┊import { secret, expiration } from '../env';\n+┊  ┊ 6┊import bcrypt from 'bcrypt';\n+┊  ┊ 7┊import jwt from 'jsonwebtoken';\n ┊ 5┊ 8┊\n ┊ 6┊ 9┊const resolvers: Resolvers = {\n ┊ 7┊10┊  Date: GraphQLDateTime,\n```\n```diff\n@@ -91,6 +94,26 @@\n ┊ 91┊ 94┊  },\n ┊ 92┊ 95┊\n ┊ 93┊ 96┊  Mutation: {\n+┊   ┊ 97┊    signIn(root, { username, password }, { res }) {\n+┊   ┊ 98┊      const user = users.find(u => u.username === username);\n+┊   ┊ 99┊\n+┊   ┊100┊      if (!user) {\n+┊   ┊101┊        throw new Error('user not found');\n+┊   ┊102┊      }\n+┊   ┊103┊\n+┊   ┊104┊      const passwordsMatch = bcrypt.compareSync(password, user.password);\n+┊   ┊105┊\n+┊   ┊106┊      if (!passwordsMatch) {\n+┊   ┊107┊        throw new Error('password is incorrect');\n+┊   ┊108┊      }\n+┊   ┊109┊\n+┊   ┊110┊      const authToken = jwt.sign(username, secret);\n+┊   ┊111┊\n+┊   ┊112┊      res.cookie('authToken', authToken, { maxAge: expiration });\n+┊   ┊113┊\n+┊   ┊114┊      return user;\n+┊   ┊115┊    },\n+┊   ┊116┊\n ┊ 94┊117┊    addMessage(root, { chatId, content }, { currentUser, pubsub }) {\n ┊ 95┊118┊      if (!currentUser) return null;\n ┊ 96┊119┊\n```\n\n##### Changed schema&#x2F;typeDefs.graphql\n```diff\n@@ -32,6 +32,7 @@\n ┊32┊32┊}\n ┊33┊33┊\n ┊34┊34┊type Mutation {\n+┊  ┊35┊  signIn(username: String!, password: String!): User\n ┊35┊36┊  addMessage(chatId: ID!, content: String!): Message\n ┊36┊37┊  addChat(recipientId: ID!): Chat\n ┊37┊38┊  removeChat(chatId: ID!): ID\n```\n\n[}]: #\n\nAs you can see we use a special secret before we encrypt the username with JWT. The same secret will be used later on to decrypt the token back into username when getting requests. If someone malicious will get a hold of that password, he can fabricate an authentication token for every user that he wants, **thus it’s important to choose a strong secret**.\n\nWhen building the context for our GraphQL resolvers, we will decode the received cookie with JWT using the same secret to determine the username who made the request. Once we have that username, we can simply retrieve the original user from the DB and define it on the context:\n\n[{]: <helper> (diffStep 10.3 module=\"server\")\n\n#### [__Server__ Step 10.3: Get current user from auth token](https://github.com/Urigo/WhatsApp-Clone-Server/commit/80893a2)\n\n##### Changed index.ts\n```diff\n@@ -1,9 +1,10 @@\n ┊ 1┊ 1┊import { ApolloServer, gql, PubSub } from 'apollo-server-express';\n ┊ 2┊ 2┊import cookie from 'cookie';\n ┊ 3┊ 3┊import http from 'http';\n+┊  ┊ 4┊import jwt from 'jsonwebtoken';\n ┊ 4┊ 5┊import { app } from './app';\n ┊ 5┊ 6┊import { users } from './db';\n-┊ 6┊  ┊import { origin, port } from './env';\n+┊  ┊ 7┊import { origin, port, secret } from './env';\n ┊ 7┊ 8┊import schema from './schema';\n ┊ 8┊ 9┊\n ┊ 9┊10┊const pubsub = new PubSub();\n```\n```diff\n@@ -20,8 +21,14 @@\n ┊20┊21┊      req.cookies = cookie.parse(req.headers.cookie || '');\n ┊21┊22┊    }\n ┊22┊23┊\n+┊  ┊24┊    let currentUser;\n+┊  ┊25┊    if (req.cookies.authToken) {\n+┊  ┊26┊      const username = jwt.verify(req.cookies.authToken, secret) as string;\n+┊  ┊27┊      currentUser = username && users.find(u => u.username === username);\n+┊  ┊28┊    }\n+┊  ┊29┊\n ┊23┊30┊    return {\n-┊24┊  ┊      currentUser: users.find(u => u.id === req.cookies.currentUserId),\n+┊  ┊31┊      currentUser,\n ┊25┊32┊      pubsub,\n ┊26┊33┊      res: session.res,\n ┊27┊34┊    };\n```\n\n[}]: #\n\nYou might have noticed that the User schema has been updated, because we try to address the `user.username` property. The authentication in our app will be done with a username and a password; accordingly, we will update our User type definitions and the user documents in the users collection mock. The credentials that we’re going to store can actually be used to sign-in to our app:\n\n[{]: <helper> (diffStep 10.4 module=\"server\")\n\n#### [__Server__ Step 10.4: Update user schema to contain credentials](https://github.com/Urigo/WhatsApp-Clone-Server/commit/a5869c6)\n\n##### Changed db.ts\n```diff\n@@ -1,6 +1,8 @@\n ┊1┊1┊export type User = {\n ┊2┊2┊  id: string;\n ┊3┊3┊  name: string;\n+┊ ┊4┊  username: string;\n+┊ ┊5┊  password: string;\n ┊4┊6┊  picture: string;\n ┊5┊7┊};\n ┊6┊8┊\n```\n```diff\n@@ -30,26 +32,41 @@\n ┊30┊32┊      {\n ┊31┊33┊        id: '1',\n ┊32┊34┊        name: 'Ray Edwards',\n+┊  ┊35┊        username: 'ray',\n+┊  ┊36┊        password:\n+┊  ┊37┊          '$2a$08$NO9tkFLCoSqX1c5wk3s7z.JfxaVMKA.m7zUDdDwEquo4rvzimQeJm', // 111\n ┊33┊38┊        picture: 'https://randomuser.me/api/portraits/thumb/lego/1.jpg',\n ┊34┊39┊      },\n ┊35┊40┊      {\n ┊36┊41┊        id: '2',\n ┊37┊42┊        name: 'Ethan Gonzalez',\n+┊  ┊43┊        username: 'ethan',\n+┊  ┊44┊        password:\n+┊  ┊45┊          '$2a$08$xE4FuCi/ifxjL2S8CzKAmuKLwv18ktksSN.F3XYEnpmcKtpbpeZgO', // 222\n ┊38┊46┊        picture: 'https://randomuser.me/api/portraits/thumb/men/1.jpg',\n ┊39┊47┊      },\n ┊40┊48┊      {\n ┊41┊49┊        id: '3',\n ┊42┊50┊        name: 'Bryan Wallace',\n+┊  ┊51┊        username: 'bryan',\n+┊  ┊52┊        password:\n+┊  ┊53┊          '$2a$08$UHgH7J8G6z1mGQn2qx2kdeWv0jvgHItyAsL9hpEUI3KJmhVW5Q1d.', // 333\n ┊43┊54┊        picture: 'https://randomuser.me/api/portraits/thumb/men/2.jpg',\n ┊44┊55┊      },\n ┊45┊56┊      {\n ┊46┊57┊        id: '4',\n ┊47┊58┊        name: 'Avery Stewart',\n+┊  ┊59┊        username: 'avery',\n+┊  ┊60┊        password:\n+┊  ┊61┊          '$2a$08$wR1k5Q3T9FC7fUgB7Gdb9Os/GV7dGBBf4PLlWT7HERMFhmFDt47xi', // 444\n ┊48┊62┊        picture: 'https://randomuser.me/api/portraits/thumb/women/1.jpg',\n ┊49┊63┊      },\n ┊50┊64┊      {\n ┊51┊65┊        id: '5',\n ┊52┊66┊        name: 'Katie Peterson',\n+┊  ┊67┊        username: 'katie',\n+┊  ┊68┊        password:\n+┊  ┊69┊          '$2a$08$6.mbXqsDX82ZZ7q5d8Osb..JrGSsNp4R3IKj7mxgF6YGT0OmMw242', // 555\n ┊53┊70┊        picture: 'https://randomuser.me/api/portraits/thumb/women/2.jpg',\n ┊54┊71┊      },\n ┊55┊72┊    ]\n```\n\n[}]: #\n\nTo test it out, we will run our front-end application and open the dev-console. Using the Apollo Client we will send a request to the `signIn` mutation. We can use the credentials of one of the users stored in the DB. As for now all our restricted routes are observing the `currentUserId` cookie. This is wrong and no longer relevant. Let’s change the `withAuth()` method to observe the `authToken` cookie so we can test our new mutation successfully:\n\n[{]: <helper> (diffStep 13.1 module=\"client\")\n\n#### [__Client__ Step 13.1: Use authToken cookie](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/abb76ee)\n\n##### Changed src&#x2F;services&#x2F;auth.service.tsx\n```diff\n@@ -22,8 +22,8 @@\n ┊22┊22┊  };\n ┊23┊23┊};\n ┊24┊24┊\n-┊25┊  ┊export const signIn = (currentUserId: string) => {\n-┊26┊  ┊  document.cookie = `currentUserId=${currentUserId}`;\n+┊  ┊25┊export const signIn = (authToken: string) => {\n+┊  ┊26┊  document.cookie = `authToken=${authToken}`;\n ┊27┊27┊\n ┊28┊28┊  // This will become async in the near future\n ┊29┊29┊  return Promise.resolve();\n```\n```diff\n@@ -35,7 +35,7 @@\n ┊35┊35┊  return useCallback(() => {\n ┊36┊36┊    // \"expires\" represents the lifespan of a cookie. Beyond that date the cookie will\n ┊37┊37┊    // be deleted by the browser. \"expires\" cannot be viewed from \"document.cookie\"\n-┊38┊  ┊    document.cookie = `currentUserId=;expires=${new Date(0)}`;\n+┊  ┊38┊    document.cookie = `authToken=;expires=${new Date(0)}`;\n ┊39┊39┊\n ┊40┊40┊    // Clear cache\n ┊41┊41┊    return client.clearStore();\n```\n```diff\n@@ -43,5 +43,5 @@\n ┊43┊43┊};\n ┊44┊44┊\n ┊45┊45┊export const isSignedIn = () => {\n-┊46┊  ┊  return /currentUserId=.+(;|$)/.test(document.cookie);\n+┊  ┊46┊  return /authToken=.+(;|$)/.test(document.cookie);\n ┊47┊47┊};\n```\n\n[}]: #\n\nNow we can perform the signIn. It would be a good idea to signIn with the first user - `ray`, since all the DB mock is built around him:\n\n```js\nmutation signIn(username: 'ray', password: '111') {\n  id\n}\n```\n\nNow if we would look at the value of `document.cookie` we should see a key named `authToken` with a JWT token and the `ChatsListScreen` should show the chats which are relevant to `ray`. To complete the sign-in flow we would need to update the `AuthScreen` and the `auth.service` to use username and password and the actual `sign-in` mutation we’ve just implemented.\n\nNow back to the `auth.service`, we will replace the `signIn()` method implementation with one that actually calls the `signIn` mutation in our API. We will start by defining the mutation:\n\n[{]: <helper> (diffStep 13.2 files=\"graphql/mutations\" module=\"client\")\n\n#### [__Client__ Step 13.2: Update auth service to call signIn mutation](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/86f0250)\n\n##### Added src&#x2F;graphql&#x2F;mutations&#x2F;index.ts\n```diff\n@@ -0,0 +1 @@\n+┊ ┊1┊export { default as signIn } from './signIn.mutation'\n```\n\n##### Added src&#x2F;graphql&#x2F;mutations&#x2F;signIn.mutation.ts\n```diff\n@@ -0,0 +1,9 @@\n+┊ ┊1┊import gql from 'graphql-tag'\n+┊ ┊2┊\n+┊ ┊3┊export default gql`\n+┊ ┊4┊  mutation signIn($username: String!, $password: String!) {\n+┊ ┊5┊    signIn(username: $username, password: $password) {\n+┊ ┊6┊      id\n+┊ ┊7┊    }\n+┊ ┊8┊  }\n+┊ ┊9┊`\n```\n\n[}]: #\n\nUpdating `codegen.yml` to include the file we've just added in the generation process:\n\n[{]: <helper> (diffStep 13.2 files=\"codegen.yml\" module=\"client\")\n\n#### [__Client__ Step 13.2: Update auth service to call signIn mutation](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/86f0250)\n\n##### Changed codegen.yml\n```diff\n@@ -4,6 +4,7 @@\n ┊ 4┊ 4┊  - ./src/graphql/fragments/**/*.ts\n ┊ 5┊ 5┊  - ./src/graphql/queries/**/*.ts\n ┊ 6┊ 6┊  - ./src/graphql/subscriptions/**/*.ts\n+┊  ┊ 7┊  - ./src/graphql/mutations/**/*.ts\n ┊ 7┊ 8┊overwrite: true\n ┊ 8┊ 9┊generates:\n ┊ 9┊10┊  ./src/graphql/types.tsx:\n```\n\n[}]: #\n\nAnd finally, we will update the service to use the generated mutation method `useSignInMutation()`:\n\n[{]: <helper> (diffStep 13.2 files=\"auth.service.ts\" module=\"client\")\n\n#### [__Client__ Step 13.2: Update auth service to call signIn mutation](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/86f0250)\n\n##### Changed src&#x2F;services&#x2F;auth.service.tsx\n```diff\n@@ -2,6 +2,7 @@\n ┊2┊2┊import { useCallback } from 'react';\n ┊3┊3┊import { useApolloClient } from 'react-apollo-hooks';\n ┊4┊4┊import { Redirect } from 'react-router-dom';\n+┊ ┊5┊import { useSignInMutation } from '../graphql/types';\n ┊5┊6┊import { useCacheService } from './cache.service';\n ┊6┊7┊\n ┊7┊8┊export const withAuth = <P extends object>(\n```\n```diff\n@@ -22,12 +23,7 @@\n ┊22┊23┊  };\n ┊23┊24┊};\n ┊24┊25┊\n-┊25┊  ┊export const signIn = (authToken: string) => {\n-┊26┊  ┊  document.cookie = `authToken=${authToken}`;\n-┊27┊  ┊\n-┊28┊  ┊  // This will become async in the near future\n-┊29┊  ┊  return Promise.resolve();\n-┊30┊  ┊};\n+┊  ┊26┊export const useSignIn = useSignInMutation;\n ┊31┊27┊\n ┊32┊28┊export const useSignOut = () => {\n ┊33┊29┊  const client = useApolloClient()\n```\n\n[}]: #\n\nTo check if we’re authorized to visit a route, not only we would need to check if we have the `authToken` cookie defined, but we would also need to validate it against the server to see that it actually references a real user. For that we will implement `Query.me` which will send us back the current user logged in directly from the context:\n\n[{]: <helper> (diffStep 10.5 module=\"server\")\n\n#### [__Server__ Step 10.5: Add Query.me](https://github.com/Urigo/WhatsApp-Clone-Server/commit/51c0032)\n\n##### Changed schema&#x2F;resolvers.ts\n```diff\n@@ -70,6 +70,10 @@\n ┊70┊70┊  },\n ┊71┊71┊\n ┊72┊72┊  Query: {\n+┊  ┊73┊    me(root, args, { currentUser }) {\n+┊  ┊74┊      return currentUser || null;\n+┊  ┊75┊    },\n+┊  ┊76┊\n ┊73┊77┊    chats(root, args, { currentUser }) {\n ┊74┊78┊      if (!currentUser) return [];\n ┊75┊79┊\n```\n\n##### Changed schema&#x2F;typeDefs.graphql\n```diff\n@@ -26,6 +26,7 @@\n ┊26┊26┊}\n ┊27┊27┊\n ┊28┊28┊type Query {\n+┊  ┊29┊  me: User\n ┊29┊30┊  chats: [Chat!]!\n ┊30┊31┊  chat(chatId: ID!): Chat\n ┊31┊32┊  users: [User!]!\n```\n\n##### Added tests&#x2F;queries&#x2F;getMe.test.ts\n```diff\n@@ -0,0 +1,33 @@\n+┊  ┊ 1┊import { createTestClient } from 'apollo-server-testing';\n+┊  ┊ 2┊import { ApolloServer, gql } from 'apollo-server-express';\n+┊  ┊ 3┊import schema from '../../schema';\n+┊  ┊ 4┊import { users } from '../../db';\n+┊  ┊ 5┊\n+┊  ┊ 6┊describe('Query.me', () => {\n+┊  ┊ 7┊  it('should fetch current user', async () => {\n+┊  ┊ 8┊    const server = new ApolloServer({\n+┊  ┊ 9┊      schema,\n+┊  ┊10┊      context: () => ({\n+┊  ┊11┊        currentUser: users[0],\n+┊  ┊12┊      }),\n+┊  ┊13┊    });\n+┊  ┊14┊\n+┊  ┊15┊    const { query } = createTestClient(server);\n+┊  ┊16┊\n+┊  ┊17┊    const res = await query({\n+┊  ┊18┊      query: gql`\n+┊  ┊19┊        query GetMe {\n+┊  ┊20┊          me {\n+┊  ┊21┊            id\n+┊  ┊22┊            name\n+┊  ┊23┊            picture\n+┊  ┊24┊          }\n+┊  ┊25┊        }\n+┊  ┊26┊      `,\n+┊  ┊27┊    });\n+┊  ┊28┊\n+┊  ┊29┊    expect(res.data).toBeDefined();\n+┊  ┊30┊    expect(res.errors).toBeUndefined();\n+┊  ┊31┊    expect(res.data).toMatchSnapshot();\n+┊  ┊32┊  });\n+┊  ┊33┊});\n```\n\n[}]: #\n\nNow will use the GraphQL query we’ve just implemented to check if the user actually exists within the DB before we proceed to the restricted route:\n\n[{]: <helper> (diffStep 13.3 module=\"client\")\n\n#### [__Client__ Step 13.3: Validate auth token against the back-end on restricted route](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/8b6e7eb)\n\n##### Added src&#x2F;graphql&#x2F;queries&#x2F;me.query.ts\n```diff\n@@ -0,0 +1,11 @@\n+┊  ┊ 1┊import gql from 'graphql-tag';\n+┊  ┊ 2┊import * as fragments from '../fragments';\n+┊  ┊ 3┊\n+┊  ┊ 4┊export default gql`\n+┊  ┊ 5┊  query Me {\n+┊  ┊ 6┊    me {\n+┊  ┊ 7┊      ...User\n+┊  ┊ 8┊    }\n+┊  ┊ 9┊  }\n+┊  ┊10┊  ${fragments.user}\n+┊  ┊11┊`;\n```\n\n##### Changed src&#x2F;services&#x2F;auth.service.tsx\n```diff\n@@ -1,10 +1,16 @@\n ┊ 1┊ 1┊import React from 'react';\n-┊ 2┊  ┊import { useCallback } from 'react';\n+┊  ┊ 2┊import { useContext, useCallback } from 'react';\n ┊ 3┊ 3┊import { useApolloClient } from 'react-apollo-hooks';\n ┊ 4┊ 4┊import { Redirect } from 'react-router-dom';\n-┊ 5┊  ┊import { useSignInMutation } from '../graphql/types';\n+┊  ┊ 5┊import { useMeQuery, User, useSignInMutation } from '../graphql/types';\n ┊ 6┊ 6┊import { useCacheService } from './cache.service';\n ┊ 7┊ 7┊\n+┊  ┊ 8┊const MyContext = React.createContext<User | null>(null);\n+┊  ┊ 9┊\n+┊  ┊10┊export const useMe = () => {\n+┊  ┊11┊  return useContext(MyContext);\n+┊  ┊12┊};\n+┊  ┊13┊\n ┊ 8┊14┊export const withAuth = <P extends object>(\n ┊ 9┊15┊  Component: React.ComponentType<P>\n ┊10┊16┊) => {\n```\n```diff\n@@ -17,9 +23,26 @@\n ┊17┊23┊      return <Redirect to=\"/sign-in\" />;\n ┊18┊24┊    }\n ┊19┊25┊\n+┊  ┊26┊    const signOut = useSignOut();\n+┊  ┊27┊    const { data, error, loading } = useMeQuery();\n+┊  ┊28┊\n ┊20┊29┊    useCacheService();\n ┊21┊30┊\n-┊22┊  ┊    return <Component {...props as P} />;\n+┊  ┊31┊    if (loading) return null;\n+┊  ┊32┊\n+┊  ┊33┊    if (data === undefined) return null;\n+┊  ┊34┊\n+┊  ┊35┊    if (error || !data.me) {\n+┊  ┊36┊      signOut();\n+┊  ┊37┊\n+┊  ┊38┊      return <Redirect to=\"/sign-in\" />;\n+┊  ┊39┊    }\n+┊  ┊40┊\n+┊  ┊41┊    return (\n+┊  ┊42┊      <MyContext.Provider value={data.me}>\n+┊  ┊43┊        <Component {...props as P} />\n+┊  ┊44┊      </MyContext.Provider>\n+┊  ┊45┊    );\n ┊23┊46┊  };\n ┊24┊47┊};\n```\n\n[}]: #\n\nwe will use the new query to try and fetch the user directly from the back-end, and we will only proceed if the user was actually found. In addition, we will replace the `signIn()` method to call `signIn` mutation:\n\n[{]: <helper> (diffStep 13.4 module=\"client\")\n\n#### [__Client__ Step 13.4: Add username and password to AuthScreen](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/4607207)\n\n##### Changed src&#x2F;components&#x2F;AuthScreen&#x2F;index.tsx\n```diff\n@@ -3,7 +3,7 @@\n ┊3┊3┊import React from 'react';\n ┊4┊4┊import { useCallback, useState } from 'react';\n ┊5┊5┊import styled from 'styled-components';\n-┊6┊ ┊import { signIn } from '../../services/auth.service';\n+┊ ┊6┊import { useSignIn } from '../../services/auth.service';\n ┊7┊7┊import { RouteComponentProps } from 'react-router-dom';\n ┊8┊8┊\n ┊9┊9┊const Container = styled.div`\n```\n```diff\n@@ -114,21 +114,35 @@\n ┊114┊114┊` as typeof MaterialButton;\n ┊115┊115┊\n ┊116┊116┊const AuthScreen: React.FC<RouteComponentProps<any>> = ({ history }) => {\n-┊117┊   ┊  const [userId, setUserId] = useState('');\n+┊   ┊117┊  const [username, setUsername] = useState('');\n+┊   ┊118┊  const [password, setPassword] = useState('');\n+┊   ┊119┊  // eslint-disable-next-line\n+┊   ┊120┊  const [error, setError] = useState('');\n+┊   ┊121┊  const signIn = useSignIn();\n+┊   ┊122┊\n+┊   ┊123┊  const onUsernameChange = useCallback(({ target }) => {\n+┊   ┊124┊    setError('');\n+┊   ┊125┊    setUsername(target.value);\n+┊   ┊126┊  }, []);\n ┊118┊127┊\n-┊119┊   ┊  const onUserIdChange = useCallback(({ target }) => {\n-┊120┊   ┊    setUserId(target.value);\n+┊   ┊128┊  const onPasswordChange = useCallback(({ target }) => {\n+┊   ┊129┊    setError('');\n+┊   ┊130┊    setPassword(target.value);\n ┊121┊131┊  }, []);\n ┊122┊132┊\n ┊123┊133┊  const maySignIn = useCallback(() => {\n-┊124┊   ┊    return !!userId;\n-┊125┊   ┊  }, [userId]);\n+┊   ┊134┊    return !!(username && password);\n+┊   ┊135┊  }, [username, password]);\n ┊126┊136┊\n ┊127┊137┊  const handleSignIn = useCallback(() => {\n-┊128┊   ┊    signIn(userId).then(() => {\n-┊129┊   ┊      history.replace('/chats');\n-┊130┊   ┊    });\n-┊131┊   ┊  }, [userId, history]);\n+┊   ┊138┊    signIn({ variables: { username, password } })\n+┊   ┊139┊      .then(() => {\n+┊   ┊140┊        history.push('/chats');\n+┊   ┊141┊      })\n+┊   ┊142┊      .catch(error => {\n+┊   ┊143┊        setError(error.message || error);\n+┊   ┊144┊      });\n+┊   ┊145┊  }, [username, password, history, signIn]);\n ┊132┊146┊\n ┊133┊147┊  return (\n ┊134┊148┊    <Container>\n```\n```diff\n@@ -141,12 +155,21 @@\n ┊141┊155┊          <Legend>Sign in</Legend>\n ┊142┊156┊          <Section>\n ┊143┊157┊            <TextField\n-┊144┊   ┊              data-testid=\"user-id-input\"\n-┊145┊   ┊              label=\"User ID\"\n-┊146┊   ┊              value={userId}\n-┊147┊   ┊              onChange={onUserIdChange}\n+┊   ┊158┊              className=\"AuthScreen-text-field\"\n+┊   ┊159┊              label=\"Username\"\n+┊   ┊160┊              value={username}\n+┊   ┊161┊              onChange={onUsernameChange}\n+┊   ┊162┊              margin=\"normal\"\n+┊   ┊163┊              placeholder=\"Enter your username\"\n+┊   ┊164┊            />\n+┊   ┊165┊            <TextField\n+┊   ┊166┊              className=\"AuthScreen-text-field\"\n+┊   ┊167┊              label=\"Password\"\n+┊   ┊168┊              type=\"password\"\n+┊   ┊169┊              value={password}\n+┊   ┊170┊              onChange={onPasswordChange}\n ┊148┊171┊              margin=\"normal\"\n-┊149┊   ┊              placeholder=\"Enter current user ID\"\n+┊   ┊172┊              placeholder=\"Enter your password\"\n ┊150┊173┊            />\n ┊151┊174┊          </Section>\n ┊152┊175┊          <Button\n```\n\n[}]: #\n\nThe behavior of the updated screen should be identical to what we had so far. To complete the flow we’ll need a way to signUp. When we signing-up we will need the following parameters: `name`, `username`, `password` and `passwordConfirm`. In addition we will need to run certain validations against the parameters:\n\n- The name must be at least 3 and at most 50 characters long.\n- The username must be at least 3 and at most 18 characters long.\n- A password must be at least 8 and at most 30 characters long. In addition, it should contain English letters, numbers, and special characters.\n\nFor that we will implement a dedicated validations module:\n\n[{]: <helper> (diffStep 10.6 files=\"validators\" module=\"server\")\n\n#### [__Server__ Step 10.6: Add signUp mutation](https://github.com/Urigo/WhatsApp-Clone-Server/commit/30b50ba)\n\n##### Added validators.ts\n```diff\n@@ -0,0 +1,43 @@\n+┊  ┊ 1┊export const validatePassword = (ctx: string, str: string) => {\n+┊  ┊ 2┊  if (typeof str !== 'string') {\n+┊  ┊ 3┊    throw TypeError(`${ctx} must be a string`);\n+┊  ┊ 4┊  }\n+┊  ┊ 5┊\n+┊  ┊ 6┊  validateLength(ctx, str, 8, 30);\n+┊  ┊ 7┊\n+┊  ┊ 8┊  if (!/[a-zA-Z]+/.test(str)) {\n+┊  ┊ 9┊    throw TypeError(`${ctx} must contain english letters`);\n+┊  ┊10┊  }\n+┊  ┊11┊\n+┊  ┊12┊  if (!/\\d+/.test(str)) {\n+┊  ┊13┊    throw TypeError(`${ctx} must contain numbers`);\n+┊  ┊14┊  }\n+┊  ┊15┊\n+┊  ┊16┊  if (!/[^\\da-zA-Z]+/.test(str)) {\n+┊  ┊17┊    throw TypeError(`${ctx} must contain special charachters`);\n+┊  ┊18┊  }\n+┊  ┊19┊};\n+┊  ┊20┊\n+┊  ┊21┊export const validateLength = (ctx: string, str: string, ...args: number[]) => {\n+┊  ┊22┊  let min, max;\n+┊  ┊23┊\n+┊  ┊24┊  if (args.length === 1) {\n+┊  ┊25┊    min = 0;\n+┊  ┊26┊    max = args[0];\n+┊  ┊27┊  } else {\n+┊  ┊28┊    min = args[0];\n+┊  ┊29┊    max = args[1];\n+┊  ┊30┊  }\n+┊  ┊31┊\n+┊  ┊32┊  if (typeof str !== 'string') {\n+┊  ┊33┊    throw TypeError(`${ctx} must be a string`);\n+┊  ┊34┊  }\n+┊  ┊35┊\n+┊  ┊36┊  if (str.length < min) {\n+┊  ┊37┊    throw TypeError(`${ctx} must be at least ${min} chars long`);\n+┊  ┊38┊  }\n+┊  ┊39┊\n+┊  ┊40┊  if (str.length > max) {\n+┊  ┊41┊    throw TypeError(`${ctx} must contain ${max} chars at most`);\n+┊  ┊42┊  }\n+┊  ┊43┊};\n```\n\n[}]: #\n\nAnd we will implement the resolver and schema for the `signUp` mutation:\n\n[{]: <helper> (diffStep 10.6 files=\"schema\" module=\"server\")\n\n#### [__Server__ Step 10.6: Add signUp mutation](https://github.com/Urigo/WhatsApp-Clone-Server/commit/30b50ba)\n\n##### Changed schema&#x2F;resolvers.ts\n```diff\n@@ -5,6 +5,7 @@\n ┊ 5┊ 5┊import { secret, expiration } from '../env';\n ┊ 6┊ 6┊import bcrypt from 'bcrypt';\n ┊ 7┊ 7┊import jwt from 'jsonwebtoken';\n+┊  ┊ 8┊import { validateLength, validatePassword } from '../validators';\n ┊ 8┊ 9┊\n ┊ 9┊10┊const resolvers: Resolvers = {\n ┊10┊11┊  Date: GraphQLDateTime,\n```\n```diff\n@@ -118,6 +119,34 @@\n ┊118┊119┊      return user;\n ┊119┊120┊    },\n ┊120┊121┊\n+┊   ┊122┊    signUp(root, { name, username, password, passwordConfirm }) {\n+┊   ┊123┊      validateLength('req.name', name, 3, 50);\n+┊   ┊124┊      validateLength('req.username', name, 3, 18);\n+┊   ┊125┊      validatePassword('req.password', password);\n+┊   ┊126┊\n+┊   ┊127┊      if (password !== passwordConfirm) {\n+┊   ┊128┊        throw Error(\"req.password and req.passwordConfirm don't match\");\n+┊   ┊129┊      }\n+┊   ┊130┊\n+┊   ┊131┊      if (users.some(u => u.username === username)) {\n+┊   ┊132┊        throw Error('username already exists');\n+┊   ┊133┊      }\n+┊   ┊134┊\n+┊   ┊135┊      const passwordHash = bcrypt.hashSync(password, bcrypt.genSaltSync(8));\n+┊   ┊136┊\n+┊   ┊137┊      const user: User = {\n+┊   ┊138┊        id: String(users.length + 1),\n+┊   ┊139┊        password: passwordHash,\n+┊   ┊140┊        picture: '',\n+┊   ┊141┊        username,\n+┊   ┊142┊        name,\n+┊   ┊143┊      };\n+┊   ┊144┊\n+┊   ┊145┊      users.push(user);\n+┊   ┊146┊\n+┊   ┊147┊      return user;\n+┊   ┊148┊    },\n+┊   ┊149┊\n ┊121┊150┊    addMessage(root, { chatId, content }, { currentUser, pubsub }) {\n ┊122┊151┊      if (!currentUser) return null;\n ┊123┊152┊\n```\n\n##### Changed schema&#x2F;typeDefs.graphql\n```diff\n@@ -34,6 +34,7 @@\n ┊34┊34┊\n ┊35┊35┊type Mutation {\n ┊36┊36┊  signIn(username: String!, password: String!): User\n+┊  ┊37┊  signUp(name: String!, username: String!, password: String!, passwordConfirm: String!): User\n ┊37┊38┊  addMessage(chatId: ID!, content: String!): Message\n ┊38┊39┊  addChat(recipientId: ID!): Chat\n ┊39┊40┊  removeChat(chatId: ID!): ID\n```\n\n[}]: #\n\nBefore encrypting the password we append a string called “salt” to it. Even though the passwords are stored encrypted in the DB, a hacker might use a dictionary of common passwords in their encrypted form to decipher the original password. When adding salt to a password which is essentially a random string, the hacker cannot use a dictionary anymore since he would need to know the salt. Hypothetically, the hacker can get a hold of the salt and re-generate the entire dictionary, however that would take too long because of the way Bcrypt is designed to work.\n\nGoing back to the client, we will implement a new `signUp()` method in the `auth.service` that will call the `signUp` mutation:\n\n[{]: <helper> (diffStep 13.5 module=\"client\")\n\n#### [__Client__ Step 13.5: Add signUp() method to auth.service](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/dee1f96)\n\n##### Added src&#x2F;graphql&#x2F;mutations&#x2F;signUp.mutation.ts\n```diff\n@@ -0,0 +1,9 @@\n+┊ ┊1┊import gql from 'graphql-tag'\n+┊ ┊2┊\n+┊ ┊3┊export default gql`\n+┊ ┊4┊  mutation signUp($name: String!, $username: String!, $password: String!, $passwordConfirm: String!) {\n+┊ ┊5┊    signUp(name: $name, username: $username, password: $password, passwordConfirm: $passwordConfirm) {\n+┊ ┊6┊      id\n+┊ ┊7┊    }\n+┊ ┊8┊  }\n+┊ ┊9┊`\n```\n\n##### Changed src&#x2F;services&#x2F;auth.service.tsx\n```diff\n@@ -2,7 +2,7 @@\n ┊2┊2┊import { useContext, useCallback } from 'react';\n ┊3┊3┊import { useApolloClient } from 'react-apollo-hooks';\n ┊4┊4┊import { Redirect } from 'react-router-dom';\n-┊5┊ ┊import { useMeQuery, User, useSignInMutation } from '../graphql/types';\n+┊ ┊5┊import { useMeQuery, User, useSignInMutation, useSignUpMutation } from '../graphql/types';\n ┊6┊6┊import { useCacheService } from './cache.service';\n ┊7┊7┊\n ┊8┊8┊const MyContext = React.createContext<User | null>(null);\n```\n```diff\n@@ -47,6 +47,7 @@\n ┊47┊47┊};\n ┊48┊48┊\n ┊49┊49┊export const useSignIn = useSignInMutation;\n+┊  ┊50┊export const useSignUp = useSignUpMutation;\n ┊50┊51┊\n ┊51┊52┊export const useSignOut = () => {\n ┊52┊53┊  const client = useApolloClient()\n```\n\n[}]: #\n\nNow we will implement a dedicated `SignUpForm` that we can use to perform the sign-up. Instead of implementing a new screen, we will use the `AuthScreen` to alternate between the `SignInForm` and the `SignUpForm` using `AnimatedSwitch`. This way we can have a container component that is common for both forms, and we will be able to switch between the two very smoothly. We will first define a new `/sign-up` route in our router:\n\n[{]: <helper> (diffStep 13.6 module=\"client\")\n\n#### [__Client__ Step 13.6: Split AuthScreen into SignInForm and SignUpForm](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/b04495c)\n\n##### Added src&#x2F;components&#x2F;AuthScreen&#x2F;SignInForm.test.tsx\n```diff\n@@ -0,0 +1,163 @@\n+┊   ┊  1┊import { createMemoryHistory } from 'history';\n+┊   ┊  2┊import React from 'react';\n+┊   ┊  3┊import { ApolloProvider } from 'react-apollo-hooks';\n+┊   ┊  4┊import { act, cleanup, render, fireEvent, wait, waitForElement } from '@testing-library/react';\n+┊   ┊  5┊import SignInForm from './SignInForm';\n+┊   ┊  6┊import { SignInDocument } from '../../graphql/types';\n+┊   ┊  7┊import { mockApolloClient } from '../../test-helpers';\n+┊   ┊  8┊\n+┊   ┊  9┊describe('SignInForm', () => {\n+┊   ┊ 10┊  afterEach(cleanup);\n+┊   ┊ 11┊\n+┊   ┊ 12┊  it('enables sign-in button when filled in', async () => {\n+┊   ┊ 13┊    const history = createMemoryHistory();\n+┊   ┊ 14┊    const client = mockApolloClient();\n+┊   ┊ 15┊\n+┊   ┊ 16┊    let getByTestId: any = null;\n+┊   ┊ 17┊\n+┊   ┊ 18┊    act(() => {\n+┊   ┊ 19┊      getByTestId = render(\n+┊   ┊ 20┊        <ApolloProvider client={client}>\n+┊   ┊ 21┊          <SignInForm history={history} />\n+┊   ┊ 22┊        </ApolloProvider>\n+┊   ┊ 23┊      ).getByTestId;\n+┊   ┊ 24┊    });\n+┊   ┊ 25┊\n+┊   ┊ 26┊    const signInButton = await waitForElement(() =>\n+┊   ┊ 27┊      getByTestId('sign-in-button') as HTMLButtonElement\n+┊   ┊ 28┊    );\n+┊   ┊ 29┊    const usernameInput = await waitForElement(() =>\n+┊   ┊ 30┊      getByTestId('username-input').querySelector('input')\n+┊   ┊ 31┊    );\n+┊   ┊ 32┊    const passwordInput = await waitForElement(() =>\n+┊   ┊ 33┊      getByTestId('password-input').querySelector('input')\n+┊   ┊ 34┊    );\n+┊   ┊ 35┊\n+┊   ┊ 36┊    expect(signInButton.disabled).toEqual(true);\n+┊   ┊ 37┊\n+┊   ┊ 38┊    act(() => {\n+┊   ┊ 39┊      fireEvent.change(usernameInput, { target: { value: 'username' } });\n+┊   ┊ 40┊      fireEvent.change(passwordInput, { target: { value: 'password' } });\n+┊   ┊ 41┊    });\n+┊   ┊ 42┊\n+┊   ┊ 43┊    await wait(() =>\n+┊   ┊ 44┊      expect(signInButton.disabled).toEqual(false)\n+┊   ┊ 45┊    )\n+┊   ┊ 46┊  });\n+┊   ┊ 47┊\n+┊   ┊ 48┊  it('prints server error if input was wrong', async () => {\n+┊   ┊ 49┊    const history = createMemoryHistory();\n+┊   ┊ 50┊\n+┊   ┊ 51┊    const client = mockApolloClient([\n+┊   ┊ 52┊      {\n+┊   ┊ 53┊        request: {\n+┊   ┊ 54┊          query: SignInDocument,\n+┊   ┊ 55┊          variables: {\n+┊   ┊ 56┊            username: 'username',\n+┊   ┊ 57┊            password: 'password'\n+┊   ┊ 58┊          }\n+┊   ┊ 59┊        },\n+┊   ┊ 60┊        get result() { throw Error('sign-in failed') },\n+┊   ┊ 61┊      }\n+┊   ┊ 62┊    ]);\n+┊   ┊ 63┊\n+┊   ┊ 64┊    let getByTestId: any = null;\n+┊   ┊ 65┊\n+┊   ┊ 66┊    act(() => {\n+┊   ┊ 67┊      getByTestId = render(\n+┊   ┊ 68┊        <ApolloProvider client={client}>\n+┊   ┊ 69┊          <SignInForm history={history} />\n+┊   ┊ 70┊        </ApolloProvider>\n+┊   ┊ 71┊      ).getByTestId;\n+┊   ┊ 72┊    });\n+┊   ┊ 73┊\n+┊   ┊ 74┊    const signInButton = await waitForElement(() =>\n+┊   ┊ 75┊      getByTestId('sign-in-button') as HTMLButtonElement\n+┊   ┊ 76┊    );\n+┊   ┊ 77┊    const usernameInput = await waitForElement(() =>\n+┊   ┊ 78┊      getByTestId('username-input').querySelector('input')\n+┊   ┊ 79┊    );\n+┊   ┊ 80┊    const passwordInput = await waitForElement(() =>\n+┊   ┊ 81┊      getByTestId('password-input').querySelector('input')\n+┊   ┊ 82┊    );\n+┊   ┊ 83┊\n+┊   ┊ 84┊    act(() => {\n+┊   ┊ 85┊      fireEvent.change(usernameInput, { target: { value: 'username' } });\n+┊   ┊ 86┊      fireEvent.change(passwordInput, { target: { value: 'password' } });\n+┊   ┊ 87┊    });\n+┊   ┊ 88┊\n+┊   ┊ 89┊    await wait(() =>\n+┊   ┊ 90┊      expect(usernameInput.value).toEqual('username')\n+┊   ┊ 91┊    );\n+┊   ┊ 92┊\n+┊   ┊ 93┊    await wait(() =>\n+┊   ┊ 94┊      expect(passwordInput.value).toEqual('password')\n+┊   ┊ 95┊    );\n+┊   ┊ 96┊\n+┊   ┊ 97┊    act(() => {\n+┊   ┊ 98┊      fireEvent.click(signInButton);\n+┊   ┊ 99┊    });\n+┊   ┊100┊\n+┊   ┊101┊    const errorMessage = await waitForElement(() =>\n+┊   ┊102┊      getByTestId('error-message')\n+┊   ┊103┊    );\n+┊   ┊104┊\n+┊   ┊105┊    expect(errorMessage.innerHTML).toContain('sign-in failed');\n+┊   ┊106┊  });\n+┊   ┊107┊\n+┊   ┊108┊  it('navigates to /chats if everything went right', async () => {\n+┊   ┊109┊    const history = createMemoryHistory();\n+┊   ┊110┊\n+┊   ┊111┊    const client = mockApolloClient([\n+┊   ┊112┊      {\n+┊   ┊113┊        request: {\n+┊   ┊114┊          query: SignInDocument,\n+┊   ┊115┊          variables: {\n+┊   ┊116┊            username: 'username',\n+┊   ┊117┊            password: 'password'\n+┊   ┊118┊          }\n+┊   ┊119┊        },\n+┊   ┊120┊        result: { data: {} }\n+┊   ┊121┊      }\n+┊   ┊122┊    ]);\n+┊   ┊123┊\n+┊   ┊124┊    let getByTestId: any = null;\n+┊   ┊125┊\n+┊   ┊126┊    act(() => {\n+┊   ┊127┊      getByTestId = render(\n+┊   ┊128┊        <ApolloProvider client={client}>\n+┊   ┊129┊          <SignInForm history={history} />\n+┊   ┊130┊        </ApolloProvider>\n+┊   ┊131┊      ).getByTestId;\n+┊   ┊132┊    })\n+┊   ┊133┊\n+┊   ┊134┊    const usernameInput = await waitForElement(() =>\n+┊   ┊135┊      getByTestId('username-input').querySelector('input')\n+┊   ┊136┊    );\n+┊   ┊137┊    const passwordInput = await waitForElement(() =>\n+┊   ┊138┊      getByTestId('password-input').querySelector('input')\n+┊   ┊139┊    );\n+┊   ┊140┊    const signInButton = await waitForElement(() =>\n+┊   ┊141┊      getByTestId('sign-in-button') as HTMLButtonElement\n+┊   ┊142┊    );\n+┊   ┊143┊\n+┊   ┊144┊    act(() => {\n+┊   ┊145┊      fireEvent.change(usernameInput, { target: { value: 'username' } });\n+┊   ┊146┊      fireEvent.change(passwordInput, { target: { value: 'password' } });\n+┊   ┊147┊    });\n+┊   ┊148┊\n+┊   ┊149┊    await wait(() =>\n+┊   ┊150┊      expect(usernameInput.value).toEqual('username')\n+┊   ┊151┊    );\n+┊   ┊152┊\n+┊   ┊153┊    await wait(() =>\n+┊   ┊154┊      expect(passwordInput.value).toEqual('password')\n+┊   ┊155┊    );\n+┊   ┊156┊\n+┊   ┊157┊    act(() => {\n+┊   ┊158┊      fireEvent.click(signInButton);\n+┊   ┊159┊    });\n+┊   ┊160┊\n+┊   ┊161┊    await wait(() => expect(history.location.pathname).toEqual('/chats'));\n+┊   ┊162┊  });\n+┊   ┊163┊});🚫↵\n```\n\n##### Added src&#x2F;components&#x2F;AuthScreen&#x2F;SignInForm.tsx\n```diff\n@@ -0,0 +1,83 @@\n+┊  ┊ 1┊import React from 'react';\n+┊  ┊ 2┊import { useCallback, useState } from 'react';\n+┊  ┊ 3┊import { useSignIn } from '../../services/auth.service';\n+┊  ┊ 4┊import {\n+┊  ┊ 5┊  SignForm,\n+┊  ┊ 6┊  ActualForm,\n+┊  ┊ 7┊  Legend,\n+┊  ┊ 8┊  Section,\n+┊  ┊ 9┊  TextField,\n+┊  ┊10┊  Button,\n+┊  ┊11┊  ErrorMessage,\n+┊  ┊12┊} from './form-components';\n+┊  ┊13┊import { RouteComponentProps } from 'react-router-dom';\n+┊  ┊14┊\n+┊  ┊15┊const SignInForm: React.FC<RouteComponentProps<any>> = ({ history }) => {\n+┊  ┊16┊  const [username, setUsername] = useState('');\n+┊  ┊17┊  const [password, setPassword] = useState('');\n+┊  ┊18┊  const [error, setError] = useState('');\n+┊  ┊19┊  const signIn = useSignIn();\n+┊  ┊20┊\n+┊  ┊21┊  const onUsernameChange = useCallback(({ target }) => {\n+┊  ┊22┊    setError('');\n+┊  ┊23┊    setUsername(target.value);\n+┊  ┊24┊  }, []);\n+┊  ┊25┊\n+┊  ┊26┊  const onPasswordChange = useCallback(({ target }) => {\n+┊  ┊27┊    setError('');\n+┊  ┊28┊    setPassword(target.value);\n+┊  ┊29┊  }, []);\n+┊  ┊30┊\n+┊  ┊31┊  const maySignIn = useCallback(() => {\n+┊  ┊32┊    return !!(username && password);\n+┊  ┊33┊  }, [username, password]);\n+┊  ┊34┊\n+┊  ┊35┊  const handleSignIn = useCallback(() => {\n+┊  ┊36┊    signIn({ variables: { username, password } })\n+┊  ┊37┊      .then(() => {\n+┊  ┊38┊        history.replace('/chats');\n+┊  ┊39┊      })\n+┊  ┊40┊      .catch(error => {\n+┊  ┊41┊        setError(error.message || error);\n+┊  ┊42┊      });\n+┊  ┊43┊  }, [username, password, history, signIn]);\n+┊  ┊44┊\n+┊  ┊45┊  return (\n+┊  ┊46┊    <SignForm>\n+┊  ┊47┊      <ActualForm>\n+┊  ┊48┊        <Legend>Sign in</Legend>\n+┊  ┊49┊        <Section style={{ width: '100%' }}>\n+┊  ┊50┊          <TextField\n+┊  ┊51┊            data-testid=\"username-input\"\n+┊  ┊52┊            label=\"Username\"\n+┊  ┊53┊            value={username}\n+┊  ┊54┊            onChange={onUsernameChange}\n+┊  ┊55┊            margin=\"normal\"\n+┊  ┊56┊            placeholder=\"Enter your username\"\n+┊  ┊57┊          />\n+┊  ┊58┊          <TextField\n+┊  ┊59┊            data-testid=\"password-input\"\n+┊  ┊60┊            label=\"Password\"\n+┊  ┊61┊            type=\"password\"\n+┊  ┊62┊            value={password}\n+┊  ┊63┊            onChange={onPasswordChange}\n+┊  ┊64┊            margin=\"normal\"\n+┊  ┊65┊            placeholder=\"Enter your password\"\n+┊  ┊66┊          />\n+┊  ┊67┊        </Section>\n+┊  ┊68┊        <Button\n+┊  ┊69┊          data-testid=\"sign-in-button\"\n+┊  ┊70┊          type=\"button\"\n+┊  ┊71┊          color=\"secondary\"\n+┊  ┊72┊          variant=\"contained\"\n+┊  ┊73┊          disabled={!maySignIn()}\n+┊  ┊74┊          onClick={handleSignIn}>\n+┊  ┊75┊          Sign in\n+┊  ┊76┊        </Button>\n+┊  ┊77┊        <ErrorMessage data-testid=\"error-message\">{error}</ErrorMessage>\n+┊  ┊78┊      </ActualForm>\n+┊  ┊79┊    </SignForm>\n+┊  ┊80┊  );\n+┊  ┊81┊};\n+┊  ┊82┊\n+┊  ┊83┊export default SignInForm;\n```\n\n##### Added src&#x2F;components&#x2F;AuthScreen&#x2F;SignUpForm.test.tsx\n```diff\n@@ -0,0 +1,225 @@\n+┊   ┊  1┊import { createMemoryHistory } from 'history';\n+┊   ┊  2┊import React from 'react';\n+┊   ┊  3┊import { ApolloProvider } from 'react-apollo-hooks';\n+┊   ┊  4┊import { act, cleanup, render, fireEvent, wait, waitForElement } from '@testing-library/react';\n+┊   ┊  5┊import SignUpForm from './SignUpForm';\n+┊   ┊  6┊import { SignUpDocument } from '../../graphql/types';\n+┊   ┊  7┊import { mockApolloClient } from '../../test-helpers';\n+┊   ┊  8┊\n+┊   ┊  9┊describe('SignUpForm', () => {\n+┊   ┊ 10┊  afterEach(cleanup);\n+┊   ┊ 11┊\n+┊   ┊ 12┊  it('enables sign-up button when filled in', async () => {\n+┊   ┊ 13┊    const history = createMemoryHistory();\n+┊   ┊ 14┊    const client = mockApolloClient();\n+┊   ┊ 15┊\n+┊   ┊ 16┊    let getByTestId: any = null;\n+┊   ┊ 17┊\n+┊   ┊ 18┊    act(() => {\n+┊   ┊ 19┊      getByTestId = render(\n+┊   ┊ 20┊        <ApolloProvider client={client}>\n+┊   ┊ 21┊          <SignUpForm history={history} />\n+┊   ┊ 22┊        </ApolloProvider>\n+┊   ┊ 23┊      ).getByTestId;\n+┊   ┊ 24┊    });\n+┊   ┊ 25┊\n+┊   ┊ 26┊    const nameInput = await waitForElement(() =>\n+┊   ┊ 27┊      getByTestId('name-input').querySelector('input')\n+┊   ┊ 28┊    );\n+┊   ┊ 29┊    const usernameInput = await waitForElement(() =>\n+┊   ┊ 30┊      getByTestId('username-input').querySelector('input')\n+┊   ┊ 31┊    );\n+┊   ┊ 32┊    const passwordInput = await waitForElement(() =>\n+┊   ┊ 33┊      getByTestId('password-input').querySelector('input')\n+┊   ┊ 34┊    );\n+┊   ┊ 35┊    const passwordConfirmInput = await waitForElement(() =>\n+┊   ┊ 36┊      getByTestId('password-confirm-input').querySelector('input')\n+┊   ┊ 37┊    );\n+┊   ┊ 38┊    const signUpButton = await waitForElement(() =>\n+┊   ┊ 39┊      getByTestId('sign-up-button') as HTMLButtonElement\n+┊   ┊ 40┊    );\n+┊   ┊ 41┊\n+┊   ┊ 42┊    expect(signUpButton.disabled).toEqual(true);\n+┊   ┊ 43┊\n+┊   ┊ 44┊    act(() => {\n+┊   ┊ 45┊      fireEvent.change(nameInput, { target: { value: 'User Name' } });\n+┊   ┊ 46┊      fireEvent.change(usernameInput, { target: { value: 'username' } });\n+┊   ┊ 47┊      fireEvent.change(passwordInput, { target: { value: 'password' } });\n+┊   ┊ 48┊      fireEvent.change(passwordConfirmInput, { target: { value: 'password' } });\n+┊   ┊ 49┊    });\n+┊   ┊ 50┊\n+┊   ┊ 51┊    await wait(() =>\n+┊   ┊ 52┊      expect(nameInput.value).toEqual('User Name')\n+┊   ┊ 53┊    );\n+┊   ┊ 54┊\n+┊   ┊ 55┊    await wait(() =>\n+┊   ┊ 56┊      expect(usernameInput.value).toEqual('username')\n+┊   ┊ 57┊    );\n+┊   ┊ 58┊\n+┊   ┊ 59┊    await wait(() =>\n+┊   ┊ 60┊      expect(passwordInput.value).toEqual('password')\n+┊   ┊ 61┊    );\n+┊   ┊ 62┊\n+┊   ┊ 63┊    await wait(() =>\n+┊   ┊ 64┊      expect(passwordConfirmInput.value).toEqual('password')\n+┊   ┊ 65┊    );\n+┊   ┊ 66┊\n+┊   ┊ 67┊    await wait(() =>\n+┊   ┊ 68┊      expect(signUpButton.disabled).toEqual(false)\n+┊   ┊ 69┊    )\n+┊   ┊ 70┊  });\n+┊   ┊ 71┊\n+┊   ┊ 72┊  it('prints server error if input was wrong', async () => {\n+┊   ┊ 73┊    const history = createMemoryHistory();\n+┊   ┊ 74┊\n+┊   ┊ 75┊    const client = mockApolloClient([\n+┊   ┊ 76┊      {\n+┊   ┊ 77┊        request: {\n+┊   ┊ 78┊          query: SignUpDocument,\n+┊   ┊ 79┊          variables: {\n+┊   ┊ 80┊            name: 'User Name',\n+┊   ┊ 81┊            username: 'username',\n+┊   ┊ 82┊            password: 'password',\n+┊   ┊ 83┊            passwordConfirm: 'password'\n+┊   ┊ 84┊          }\n+┊   ┊ 85┊        },\n+┊   ┊ 86┊        get result() { throw Error('sign-up failed') }\n+┊   ┊ 87┊      }\n+┊   ┊ 88┊    ]);\n+┊   ┊ 89┊\n+┊   ┊ 90┊    let getByTestId: any = null;\n+┊   ┊ 91┊\n+┊   ┊ 92┊    act(() => {\n+┊   ┊ 93┊      getByTestId = render(\n+┊   ┊ 94┊        <ApolloProvider client={client}>\n+┊   ┊ 95┊          <SignUpForm history={history} />\n+┊   ┊ 96┊        </ApolloProvider>\n+┊   ┊ 97┊      ).getByTestId;\n+┊   ┊ 98┊    });\n+┊   ┊ 99┊\n+┊   ┊100┊    const nameInput = await waitForElement(() =>\n+┊   ┊101┊      getByTestId('name-input').querySelector('input')\n+┊   ┊102┊    );\n+┊   ┊103┊    const usernameInput = await waitForElement(() =>\n+┊   ┊104┊      getByTestId('username-input').querySelector('input')\n+┊   ┊105┊    );\n+┊   ┊106┊    const passwordInput = await waitForElement(() =>\n+┊   ┊107┊      getByTestId('password-input').querySelector('input')\n+┊   ┊108┊    );\n+┊   ┊109┊    const passwordConfirmInput = await waitForElement(() =>\n+┊   ┊110┊      getByTestId('password-confirm-input').querySelector('input')\n+┊   ┊111┊    );\n+┊   ┊112┊    const signUpButton = await waitForElement(() =>\n+┊   ┊113┊      getByTestId('sign-up-button') as HTMLButtonElement\n+┊   ┊114┊    );\n+┊   ┊115┊\n+┊   ┊116┊    act(() => {\n+┊   ┊117┊      fireEvent.change(nameInput, { target: { value: 'User Name' } });\n+┊   ┊118┊      fireEvent.change(usernameInput, { target: { value: 'username' } });\n+┊   ┊119┊      fireEvent.change(passwordInput, { target: { value: 'password' } });\n+┊   ┊120┊      fireEvent.change(passwordConfirmInput, { target: { value: 'password' } });\n+┊   ┊121┊    });\n+┊   ┊122┊\n+┊   ┊123┊    await wait(() =>\n+┊   ┊124┊      expect(nameInput.value).toEqual('User Name')\n+┊   ┊125┊    );\n+┊   ┊126┊\n+┊   ┊127┊    await wait(() =>\n+┊   ┊128┊      expect(usernameInput.value).toEqual('username')\n+┊   ┊129┊    );\n+┊   ┊130┊\n+┊   ┊131┊    await wait(() =>\n+┊   ┊132┊      expect(passwordInput.value).toEqual('password')\n+┊   ┊133┊    );\n+┊   ┊134┊\n+┊   ┊135┊    await wait(() =>\n+┊   ┊136┊      expect(passwordConfirmInput.value).toEqual('password')\n+┊   ┊137┊    );\n+┊   ┊138┊\n+┊   ┊139┊    act(() => {\n+┊   ┊140┊      fireEvent.click(signUpButton);\n+┊   ┊141┊    });\n+┊   ┊142┊\n+┊   ┊143┊    const errorMessage = await waitForElement(() =>\n+┊   ┊144┊      getByTestId('error-message')\n+┊   ┊145┊    );\n+┊   ┊146┊\n+┊   ┊147┊    expect(errorMessage.innerHTML).toContain('sign-up failed');\n+┊   ┊148┊  });\n+┊   ┊149┊\n+┊   ┊150┊  it('navigates to /sign-in if everything went right', async () => {\n+┊   ┊151┊    const history = createMemoryHistory();\n+┊   ┊152┊\n+┊   ┊153┊    const client = mockApolloClient([\n+┊   ┊154┊      {\n+┊   ┊155┊        request: {\n+┊   ┊156┊          query: SignUpDocument,\n+┊   ┊157┊          variables: {\n+┊   ┊158┊            name: 'User Name',\n+┊   ┊159┊            username: 'username',\n+┊   ┊160┊            password: 'password',\n+┊   ┊161┊            passwordConfirm: 'password'\n+┊   ┊162┊          }\n+┊   ┊163┊        },\n+┊   ┊164┊        result: { data: {} }\n+┊   ┊165┊      }\n+┊   ┊166┊    ]);\n+┊   ┊167┊\n+┊   ┊168┊    let getByTestId: any = null;\n+┊   ┊169┊\n+┊   ┊170┊    act(() => {\n+┊   ┊171┊      getByTestId = render(\n+┊   ┊172┊        <ApolloProvider client={client}>\n+┊   ┊173┊          <SignUpForm history={history} />\n+┊   ┊174┊        </ApolloProvider>\n+┊   ┊175┊      ).getByTestId;\n+┊   ┊176┊    });\n+┊   ┊177┊\n+┊   ┊178┊    const nameInput = await waitForElement(() =>\n+┊   ┊179┊      getByTestId('name-input').querySelector('input')\n+┊   ┊180┊    );\n+┊   ┊181┊    const usernameInput = await waitForElement(() =>\n+┊   ┊182┊      getByTestId('username-input').querySelector('input')\n+┊   ┊183┊    );\n+┊   ┊184┊    const passwordInput = await waitForElement(() =>\n+┊   ┊185┊      getByTestId('password-input').querySelector('input')\n+┊   ┊186┊    );\n+┊   ┊187┊    const passwordConfirmInput = await waitForElement(() =>\n+┊   ┊188┊      getByTestId('password-confirm-input').querySelector('input')\n+┊   ┊189┊    );\n+┊   ┊190┊    const signUpButton = await waitForElement(() =>\n+┊   ┊191┊      getByTestId('sign-up-button') as HTMLButtonElement\n+┊   ┊192┊    );\n+┊   ┊193┊\n+┊   ┊194┊    act(() => {\n+┊   ┊195┊      fireEvent.change(nameInput, { target: { value: 'User Name' } });\n+┊   ┊196┊      fireEvent.change(usernameInput, { target: { value: 'username' } });\n+┊   ┊197┊      fireEvent.change(passwordInput, { target: { value: 'password' } });\n+┊   ┊198┊      fireEvent.change(passwordConfirmInput, { target: { value: 'password' } });\n+┊   ┊199┊    });\n+┊   ┊200┊\n+┊   ┊201┊    await wait(() =>\n+┊   ┊202┊      expect(nameInput.value).toEqual('User Name')\n+┊   ┊203┊    );\n+┊   ┊204┊\n+┊   ┊205┊    await wait(() =>\n+┊   ┊206┊      expect(usernameInput.value).toEqual('username')\n+┊   ┊207┊    );\n+┊   ┊208┊\n+┊   ┊209┊    await wait(() =>\n+┊   ┊210┊      expect(passwordInput.value).toEqual('password')\n+┊   ┊211┊    );\n+┊   ┊212┊\n+┊   ┊213┊    await wait(() =>\n+┊   ┊214┊      expect(passwordConfirmInput.value).toEqual('password')\n+┊   ┊215┊    );\n+┊   ┊216┊\n+┊   ┊217┊    act(() => {\n+┊   ┊218┊      fireEvent.click(signUpButton);\n+┊   ┊219┊    });\n+┊   ┊220┊\n+┊   ┊221┊    await wait(() =>\n+┊   ┊222┊      expect(history.location.pathname).toEqual('/sign-in')\n+┊   ┊223┊    );\n+┊   ┊224┊  });\n+┊   ┊225┊});🚫↵\n```\n\n##### Added src&#x2F;components&#x2F;AuthScreen&#x2F;SignUpForm.tsx\n```diff\n@@ -0,0 +1,124 @@\n+┊   ┊  1┊import React from 'react';\n+┊   ┊  2┊import { useCallback, useState } from 'react';\n+┊   ┊  3┊import { useSignUp } from '../../services/auth.service';\n+┊   ┊  4┊import {\n+┊   ┊  5┊  SignForm,\n+┊   ┊  6┊  ActualForm,\n+┊   ┊  7┊  Legend,\n+┊   ┊  8┊  Section,\n+┊   ┊  9┊  TextField,\n+┊   ┊ 10┊  Button,\n+┊   ┊ 11┊  ErrorMessage,\n+┊   ┊ 12┊} from './form-components';\n+┊   ┊ 13┊import { RouteComponentProps } from 'react-router-dom';\n+┊   ┊ 14┊\n+┊   ┊ 15┊const SignUpForm: React.FC<RouteComponentProps<any>> = ({ history }) => {\n+┊   ┊ 16┊  const [name, setName] = useState('');\n+┊   ┊ 17┊  const [username, setUsername] = useState('');\n+┊   ┊ 18┊  const [password, setPassword] = useState('');\n+┊   ┊ 19┊  const [passwordConfirm, setPasswordConfirm] = useState('');\n+┊   ┊ 20┊  const [error, setError] = useState('');\n+┊   ┊ 21┊  const signUp = useSignUp()\n+┊   ┊ 22┊\n+┊   ┊ 23┊  const updateName = useCallback(({ target }) => {\n+┊   ┊ 24┊    setError('');\n+┊   ┊ 25┊    setName(target.value);\n+┊   ┊ 26┊  }, []);\n+┊   ┊ 27┊\n+┊   ┊ 28┊  const updateUsername = useCallback(({ target }) => {\n+┊   ┊ 29┊    setError('');\n+┊   ┊ 30┊    setUsername(target.value);\n+┊   ┊ 31┊  }, []);\n+┊   ┊ 32┊\n+┊   ┊ 33┊  const updatePassword = useCallback(({ target }) => {\n+┊   ┊ 34┊    setError('');\n+┊   ┊ 35┊    setPassword(target.value);\n+┊   ┊ 36┊  }, []);\n+┊   ┊ 37┊\n+┊   ┊ 38┊  const updatePasswordConfirm = useCallback(({ target }) => {\n+┊   ┊ 39┊    setError('');\n+┊   ┊ 40┊    setPasswordConfirm(target.value);\n+┊   ┊ 41┊  }, []);\n+┊   ┊ 42┊\n+┊   ┊ 43┊  const maySignUp = useCallback(() => {\n+┊   ┊ 44┊    return !!(name && username && password && password === passwordConfirm);\n+┊   ┊ 45┊  }, [name, username, password, passwordConfirm]);\n+┊   ┊ 46┊\n+┊   ┊ 47┊  const handleSignUp = useCallback(() => {\n+┊   ┊ 48┊    signUp({ variables: { username, password, passwordConfirm, name } })\n+┊   ┊ 49┊      .then(() => {\n+┊   ┊ 50┊        history.replace('/sign-in');\n+┊   ┊ 51┊      })\n+┊   ┊ 52┊      .catch(error => {\n+┊   ┊ 53┊        setError(error.message || error);\n+┊   ┊ 54┊      });\n+┊   ┊ 55┊  }, [name, username, password, passwordConfirm, history, signUp]);\n+┊   ┊ 56┊\n+┊   ┊ 57┊  return (\n+┊   ┊ 58┊    <SignForm>\n+┊   ┊ 59┊      <ActualForm>\n+┊   ┊ 60┊        <Legend>Sign up</Legend>\n+┊   ┊ 61┊        <Section\n+┊   ┊ 62┊          style={{\n+┊   ┊ 63┊            float: 'left',\n+┊   ┊ 64┊            width: 'calc(50% - 10px)',\n+┊   ┊ 65┊            paddingRight: '10px',\n+┊   ┊ 66┊          }}>\n+┊   ┊ 67┊          <TextField\n+┊   ┊ 68┊            data-testid=\"name-input\"\n+┊   ┊ 69┊            label=\"Name\"\n+┊   ┊ 70┊            value={name}\n+┊   ┊ 71┊            onChange={updateName}\n+┊   ┊ 72┊            autoComplete=\"off\"\n+┊   ┊ 73┊            margin=\"normal\"\n+┊   ┊ 74┊          />\n+┊   ┊ 75┊          <TextField\n+┊   ┊ 76┊            data-testid=\"username-input\"\n+┊   ┊ 77┊            label=\"Username\"\n+┊   ┊ 78┊            value={username}\n+┊   ┊ 79┊            onChange={updateUsername}\n+┊   ┊ 80┊            autoComplete=\"off\"\n+┊   ┊ 81┊            margin=\"normal\"\n+┊   ┊ 82┊          />\n+┊   ┊ 83┊        </Section>\n+┊   ┊ 84┊        <Section\n+┊   ┊ 85┊          style={{\n+┊   ┊ 86┊            float: 'right',\n+┊   ┊ 87┊            width: 'calc(50% - 10px)',\n+┊   ┊ 88┊            paddingLeft: '10px',\n+┊   ┊ 89┊          }}>\n+┊   ┊ 90┊          <TextField\n+┊   ┊ 91┊            data-testid=\"password-input\"\n+┊   ┊ 92┊            label=\"Password\"\n+┊   ┊ 93┊            type=\"password\"\n+┊   ┊ 94┊            value={password}\n+┊   ┊ 95┊            onChange={updatePassword}\n+┊   ┊ 96┊            autoComplete=\"off\"\n+┊   ┊ 97┊            margin=\"normal\"\n+┊   ┊ 98┊          />\n+┊   ┊ 99┊          <TextField\n+┊   ┊100┊            data-testid=\"password-confirm-input\"\n+┊   ┊101┊            label=\"Confirm password\"\n+┊   ┊102┊            type=\"password\"\n+┊   ┊103┊            value={passwordConfirm}\n+┊   ┊104┊            onChange={updatePasswordConfirm}\n+┊   ┊105┊            autoComplete=\"off\"\n+┊   ┊106┊            margin=\"normal\"\n+┊   ┊107┊          />\n+┊   ┊108┊        </Section>\n+┊   ┊109┊        <Button\n+┊   ┊110┊          data-testid=\"sign-up-button\"\n+┊   ┊111┊          type=\"button\"\n+┊   ┊112┊          color=\"secondary\"\n+┊   ┊113┊          variant=\"contained\"\n+┊   ┊114┊          disabled={!maySignUp()}\n+┊   ┊115┊          onClick={handleSignUp}>\n+┊   ┊116┊          Sign up\n+┊   ┊117┊        </Button>\n+┊   ┊118┊        <ErrorMessage data-testid=\"error-message\">{error}</ErrorMessage>\n+┊   ┊119┊      </ActualForm>\n+┊   ┊120┊    </SignForm>\n+┊   ┊121┊  );\n+┊   ┊122┊};\n+┊   ┊123┊\n+┊   ┊124┊export default SignUpForm;\n```\n\n##### Added src&#x2F;components&#x2F;AuthScreen&#x2F;form-components.ts\n```diff\n@@ -0,0 +1,75 @@\n+┊  ┊ 1┊import MaterialButton from '@material-ui/core/Button';\n+┊  ┊ 2┊import MaterialTextField from '@material-ui/core/TextField';\n+┊  ┊ 3┊import styled from 'styled-components';\n+┊  ┊ 4┊\n+┊  ┊ 5┊export const SignForm = styled.div`\n+┊  ┊ 6┊  height: calc(100% - 265px);\n+┊  ┊ 7┊`;\n+┊  ┊ 8┊\n+┊  ┊ 9┊export const ActualForm = styled.form`\n+┊  ┊10┊  padding: 20px;\n+┊  ┊11┊`;\n+┊  ┊12┊\n+┊  ┊13┊export const Section = styled.div`\n+┊  ┊14┊  padding-bottom: 35px;\n+┊  ┊15┊`;\n+┊  ┊16┊\n+┊  ┊17┊export const Legend = styled.legend`\n+┊  ┊18┊  font-weight: bold;\n+┊  ┊19┊  color: white;\n+┊  ┊20┊`;\n+┊  ┊21┊\n+┊  ┊22┊export const Label = styled.label`\n+┊  ┊23┊  color: white !important;\n+┊  ┊24┊`;\n+┊  ┊25┊\n+┊  ┊26┊export const Input = styled.input`\n+┊  ┊27┊  color: white;\n+┊  ┊28┊\n+┊  ┊29┊  &::placeholder {\n+┊  ┊30┊    color: var(--primary-bg);\n+┊  ┊31┊  }\n+┊  ┊32┊`;\n+┊  ┊33┊\n+┊  ┊34┊export const TextField = styled(MaterialTextField)`\n+┊  ┊35┊  width: 100%;\n+┊  ┊36┊  position: relative;\n+┊  ┊37┊\n+┊  ┊38┊  > div::before {\n+┊  ┊39┊    border-color: white !important;\n+┊  ┊40┊  }\n+┊  ┊41┊\n+┊  ┊42┊  input {\n+┊  ┊43┊    color: white !important;\n+┊  ┊44┊\n+┊  ┊45┊    &::placeholder {\n+┊  ┊46┊      color: var(--primary-bg) !important;\n+┊  ┊47┊    }\n+┊  ┊48┊  }\n+┊  ┊49┊\n+┊  ┊50┊  label {\n+┊  ┊51┊    color: white !important;\n+┊  ┊52┊  }\n+┊  ┊53┊` as typeof MaterialTextField;\n+┊  ┊54┊\n+┊  ┊55┊export const Button = styled(MaterialButton)`\n+┊  ┊56┊  width: 100px;\n+┊  ┊57┊  display: block !important;\n+┊  ┊58┊  margin: auto !important;\n+┊  ┊59┊  background-color: var(--secondary-bg) !important;\n+┊  ┊60┊\n+┊  ┊61┊  &[disabled] {\n+┊  ┊62┊    color: #38a81c;\n+┊  ┊63┊  }\n+┊  ┊64┊\n+┊  ┊65┊  &:not([disabled]) {\n+┊  ┊66┊    color: white;\n+┊  ┊67┊  }\n+┊  ┊68┊` as typeof MaterialButton;\n+┊  ┊69┊\n+┊  ┊70┊export const ErrorMessage = styled.div`\n+┊  ┊71┊  position: fixed;\n+┊  ┊72┊  color: red;\n+┊  ┊73┊  font-size: 15px;\n+┊  ┊74┊  margin-top: 20px;\n+┊  ┊75┊`;\n```\n\n##### Changed src&#x2F;components&#x2F;AuthScreen&#x2F;index.tsx\n```diff\n@@ -1,13 +1,13 @@\n-┊ 1┊  ┊import MaterialButton from '@material-ui/core/Button';\n-┊ 2┊  ┊import MaterialTextField from '@material-ui/core/TextField';\n ┊ 3┊ 1┊import React from 'react';\n-┊ 4┊  ┊import { useCallback, useState } from 'react';\n+┊  ┊ 2┊import { useMemo } from 'react';\n+┊  ┊ 3┊import { Route } from 'react-router-dom';\n ┊ 5┊ 4┊import styled from 'styled-components';\n-┊ 6┊  ┊import { useSignIn } from '../../services/auth.service';\n+┊  ┊ 5┊import AnimatedSwitch from '../AnimatedSwitch';\n+┊  ┊ 6┊import SignInForm from './SignInForm';\n+┊  ┊ 7┊import SignUpForm from './SignUpForm';\n ┊ 7┊ 8┊import { RouteComponentProps } from 'react-router-dom';\n ┊ 8┊ 9┊\n ┊ 9┊10┊const Container = styled.div`\n-┊10┊  ┊  height: 100%;\n ┊11┊11┊  background: radial-gradient(rgb(34, 65, 67), rgb(17, 48, 50)),\n ┊12┊12┊    url(/assets/chat-background.jpg) no-repeat;\n ┊13┊13┊  background-size: cover;\n```\n```diff\n@@ -40,149 +40,51 @@\n ┊ 40┊ 40┊  bottom: 10px;\n ┊ 41┊ 41┊  left: 10px;\n ┊ 42┊ 42┊\n-┊ 43┊   ┊  a {\n+┊   ┊ 43┊  label {\n ┊ 44┊ 44┊    color: var(--secondary-bg);\n ┊ 45┊ 45┊  }\n ┊ 46┊ 46┊`;\n ┊ 47┊ 47┊\n-┊ 48┊   ┊const SignInForm = styled.div`\n-┊ 49┊   ┊  height: calc(100% - 265px);\n-┊ 50┊   ┊`;\n-┊ 51┊   ┊\n-┊ 52┊   ┊const ActualForm = styled.form`\n-┊ 53┊   ┊  padding: 20px;\n-┊ 54┊   ┊`;\n-┊ 55┊   ┊\n-┊ 56┊   ┊const Section = styled.div`\n-┊ 57┊   ┊  width: 100%;\n-┊ 58┊   ┊  padding-bottom: 35px;\n-┊ 59┊   ┊`;\n-┊ 60┊   ┊\n-┊ 61┊   ┊const Legend = styled.legend`\n-┊ 62┊   ┊  font-weight: bold;\n-┊ 63┊   ┊  color: white;\n-┊ 64┊   ┊`;\n-┊ 65┊   ┊\n-┊ 66┊   ┊// eslint-disable-next-line\n-┊ 67┊   ┊const Label = styled.label`\n-┊ 68┊   ┊  color: white !important;\n-┊ 69┊   ┊`;\n-┊ 70┊   ┊\n-┊ 71┊   ┊// eslint-disable-next-line\n-┊ 72┊   ┊const Input = styled.input`\n-┊ 73┊   ┊  color: white;\n-┊ 74┊   ┊\n-┊ 75┊   ┊  &::placeholder {\n-┊ 76┊   ┊    color: var(--primary-bg);\n-┊ 77┊   ┊  }\n-┊ 78┊   ┊`;\n-┊ 79┊   ┊\n-┊ 80┊   ┊const TextField = styled(MaterialTextField)`\n-┊ 81┊   ┊  width: 100%;\n-┊ 82┊   ┊  position: relative;\n-┊ 83┊   ┊\n-┊ 84┊   ┊  > div::before {\n-┊ 85┊   ┊    border-color: white !important;\n-┊ 86┊   ┊  }\n-┊ 87┊   ┊\n-┊ 88┊   ┊  input {\n-┊ 89┊   ┊    color: white !important;\n-┊ 90┊   ┊\n-┊ 91┊   ┊    &::placeholder {\n-┊ 92┊   ┊      color: var(--primary-bg) !important;\n+┊   ┊ 48┊const AuthScreen: React.FC<RouteComponentProps<any>> = ({\n+┊   ┊ 49┊  history,\n+┊   ┊ 50┊  location,\n+┊   ┊ 51┊}) => {\n+┊   ┊ 52┊  const alternative = useMemo(() => {\n+┊   ┊ 53┊    if (location.pathname === '/sign-in') {\n+┊   ┊ 54┊      const handleSignUp = () => {\n+┊   ┊ 55┊        history.replace('/sign-up');\n+┊   ┊ 56┊      };\n+┊   ┊ 57┊\n+┊   ┊ 58┊      return (\n+┊   ┊ 59┊        <Alternative>\n+┊   ┊ 60┊          Don't have an account yet?{' '}\n+┊   ┊ 61┊          <label onClick={handleSignUp}>Sign up!</label>\n+┊   ┊ 62┊        </Alternative>\n+┊   ┊ 63┊      );\n+┊   ┊ 64┊    } else {\n+┊   ┊ 65┊      const handleSignIn = () => {\n+┊   ┊ 66┊        history.replace('/sign-in');\n+┊   ┊ 67┊      };\n+┊   ┊ 68┊\n+┊   ┊ 69┊      return (\n+┊   ┊ 70┊        <Alternative>\n+┊   ┊ 71┊          Already have an accout? <label onClick={handleSignIn}>Sign in!</label>\n+┊   ┊ 72┊        </Alternative>\n+┊   ┊ 73┊      );\n ┊ 93┊ 74┊    }\n-┊ 94┊   ┊  }\n-┊ 95┊   ┊\n-┊ 96┊   ┊  label {\n-┊ 97┊   ┊    color: white !important;\n-┊ 98┊   ┊  }\n-┊ 99┊   ┊` as typeof MaterialTextField;\n-┊100┊   ┊\n-┊101┊   ┊const Button = styled(MaterialButton)`\n-┊102┊   ┊  width: 100px;\n-┊103┊   ┊  display: block !important;\n-┊104┊   ┊  margin: auto !important;\n-┊105┊   ┊  background-color: var(--secondary-bg) !important;\n-┊106┊   ┊\n-┊107┊   ┊  &[disabled] {\n-┊108┊   ┊    color: #38a81c;\n-┊109┊   ┊  }\n-┊110┊   ┊\n-┊111┊   ┊  &:not([disabled]) {\n-┊112┊   ┊    color: white;\n-┊113┊   ┊  }\n-┊114┊   ┊` as typeof MaterialButton;\n-┊115┊   ┊\n-┊116┊   ┊const AuthScreen: React.FC<RouteComponentProps<any>> = ({ history }) => {\n-┊117┊   ┊  const [username, setUsername] = useState('');\n-┊118┊   ┊  const [password, setPassword] = useState('');\n-┊119┊   ┊  // eslint-disable-next-line\n-┊120┊   ┊  const [error, setError] = useState('');\n-┊121┊   ┊  const signIn = useSignIn();\n-┊122┊   ┊\n-┊123┊   ┊  const onUsernameChange = useCallback(({ target }) => {\n-┊124┊   ┊    setError('');\n-┊125┊   ┊    setUsername(target.value);\n-┊126┊   ┊  }, []);\n-┊127┊   ┊\n-┊128┊   ┊  const onPasswordChange = useCallback(({ target }) => {\n-┊129┊   ┊    setError('');\n-┊130┊   ┊    setPassword(target.value);\n-┊131┊   ┊  }, []);\n-┊132┊   ┊\n-┊133┊   ┊  const maySignIn = useCallback(() => {\n-┊134┊   ┊    return !!(username && password);\n-┊135┊   ┊  }, [username, password]);\n-┊136┊   ┊\n-┊137┊   ┊  const handleSignIn = useCallback(() => {\n-┊138┊   ┊    signIn({ variables: { username, password } })\n-┊139┊   ┊      .then(() => {\n-┊140┊   ┊        history.push('/chats');\n-┊141┊   ┊      })\n-┊142┊   ┊      .catch(error => {\n-┊143┊   ┊        setError(error.message || error);\n-┊144┊   ┊      });\n-┊145┊   ┊  }, [username, password, history, signIn]);\n+┊   ┊ 75┊  }, [location.pathname, history]);\n ┊146┊ 76┊\n ┊147┊ 77┊  return (\n-┊148┊   ┊    <Container>\n-┊149┊   ┊      <Intro>\n+┊   ┊ 78┊    <Container className=\"AuthScreen Screen\">\n+┊   ┊ 79┊      <Intro className=\"AuthScreen-intro\">\n ┊150┊ 80┊        <Icon src=\"assets/whatsapp-icon.png\" className=\"AuthScreen-icon\" />\n ┊151┊ 81┊        <Title className=\"AuthScreen-title\">WhatsApp</Title>\n ┊152┊ 82┊      </Intro>\n-┊153┊   ┊      <SignInForm>\n-┊154┊   ┊        <ActualForm>\n-┊155┊   ┊          <Legend>Sign in</Legend>\n-┊156┊   ┊          <Section>\n-┊157┊   ┊            <TextField\n-┊158┊   ┊              className=\"AuthScreen-text-field\"\n-┊159┊   ┊              label=\"Username\"\n-┊160┊   ┊              value={username}\n-┊161┊   ┊              onChange={onUsernameChange}\n-┊162┊   ┊              margin=\"normal\"\n-┊163┊   ┊              placeholder=\"Enter your username\"\n-┊164┊   ┊            />\n-┊165┊   ┊            <TextField\n-┊166┊   ┊              className=\"AuthScreen-text-field\"\n-┊167┊   ┊              label=\"Password\"\n-┊168┊   ┊              type=\"password\"\n-┊169┊   ┊              value={password}\n-┊170┊   ┊              onChange={onPasswordChange}\n-┊171┊   ┊              margin=\"normal\"\n-┊172┊   ┊              placeholder=\"Enter your password\"\n-┊173┊   ┊            />\n-┊174┊   ┊          </Section>\n-┊175┊   ┊          <Button\n-┊176┊   ┊            data-testid=\"sign-in-button\"\n-┊177┊   ┊            type=\"button\"\n-┊178┊   ┊            color=\"secondary\"\n-┊179┊   ┊            variant=\"contained\"\n-┊180┊   ┊            disabled={!maySignIn()}\n-┊181┊   ┊            onClick={handleSignIn}>\n-┊182┊   ┊            Sign in\n-┊183┊   ┊          </Button>\n-┊184┊   ┊        </ActualForm>\n-┊185┊   ┊      </SignInForm>\n+┊   ┊ 83┊      <AnimatedSwitch>\n+┊   ┊ 84┊        <Route exact path=\"/sign-in\" component={SignInForm} />\n+┊   ┊ 85┊        <Route exact path=\"/sign-up\" component={SignUpForm} />\n+┊   ┊ 86┊      </AnimatedSwitch>\n+┊   ┊ 87┊      {alternative}\n ┊186┊ 88┊    </Container>\n ┊187┊ 89┊  );\n ┊188┊ 90┊};\n```\n\n[}]: #\n\nAnd then we will make the necessary changes in the `AuthScreen`:\n\n[{]: <helper> (diffStep 13.6 module=\"client\")\n\n#### [__Client__ Step 13.6: Split AuthScreen into SignInForm and SignUpForm](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/b04495c)\n\n##### Added src&#x2F;components&#x2F;AuthScreen&#x2F;SignInForm.test.tsx\n```diff\n@@ -0,0 +1,163 @@\n+┊   ┊  1┊import { createMemoryHistory } from 'history';\n+┊   ┊  2┊import React from 'react';\n+┊   ┊  3┊import { ApolloProvider } from 'react-apollo-hooks';\n+┊   ┊  4┊import { act, cleanup, render, fireEvent, wait, waitForElement } from '@testing-library/react';\n+┊   ┊  5┊import SignInForm from './SignInForm';\n+┊   ┊  6┊import { SignInDocument } from '../../graphql/types';\n+┊   ┊  7┊import { mockApolloClient } from '../../test-helpers';\n+┊   ┊  8┊\n+┊   ┊  9┊describe('SignInForm', () => {\n+┊   ┊ 10┊  afterEach(cleanup);\n+┊   ┊ 11┊\n+┊   ┊ 12┊  it('enables sign-in button when filled in', async () => {\n+┊   ┊ 13┊    const history = createMemoryHistory();\n+┊   ┊ 14┊    const client = mockApolloClient();\n+┊   ┊ 15┊\n+┊   ┊ 16┊    let getByTestId: any = null;\n+┊   ┊ 17┊\n+┊   ┊ 18┊    act(() => {\n+┊   ┊ 19┊      getByTestId = render(\n+┊   ┊ 20┊        <ApolloProvider client={client}>\n+┊   ┊ 21┊          <SignInForm history={history} />\n+┊   ┊ 22┊        </ApolloProvider>\n+┊   ┊ 23┊      ).getByTestId;\n+┊   ┊ 24┊    });\n+┊   ┊ 25┊\n+┊   ┊ 26┊    const signInButton = await waitForElement(() =>\n+┊   ┊ 27┊      getByTestId('sign-in-button') as HTMLButtonElement\n+┊   ┊ 28┊    );\n+┊   ┊ 29┊    const usernameInput = await waitForElement(() =>\n+┊   ┊ 30┊      getByTestId('username-input').querySelector('input')\n+┊   ┊ 31┊    );\n+┊   ┊ 32┊    const passwordInput = await waitForElement(() =>\n+┊   ┊ 33┊      getByTestId('password-input').querySelector('input')\n+┊   ┊ 34┊    );\n+┊   ┊ 35┊\n+┊   ┊ 36┊    expect(signInButton.disabled).toEqual(true);\n+┊   ┊ 37┊\n+┊   ┊ 38┊    act(() => {\n+┊   ┊ 39┊      fireEvent.change(usernameInput, { target: { value: 'username' } });\n+┊   ┊ 40┊      fireEvent.change(passwordInput, { target: { value: 'password' } });\n+┊   ┊ 41┊    });\n+┊   ┊ 42┊\n+┊   ┊ 43┊    await wait(() =>\n+┊   ┊ 44┊      expect(signInButton.disabled).toEqual(false)\n+┊   ┊ 45┊    )\n+┊   ┊ 46┊  });\n+┊   ┊ 47┊\n+┊   ┊ 48┊  it('prints server error if input was wrong', async () => {\n+┊   ┊ 49┊    const history = createMemoryHistory();\n+┊   ┊ 50┊\n+┊   ┊ 51┊    const client = mockApolloClient([\n+┊   ┊ 52┊      {\n+┊   ┊ 53┊        request: {\n+┊   ┊ 54┊          query: SignInDocument,\n+┊   ┊ 55┊          variables: {\n+┊   ┊ 56┊            username: 'username',\n+┊   ┊ 57┊            password: 'password'\n+┊   ┊ 58┊          }\n+┊   ┊ 59┊        },\n+┊   ┊ 60┊        get result() { throw Error('sign-in failed') },\n+┊   ┊ 61┊      }\n+┊   ┊ 62┊    ]);\n+┊   ┊ 63┊\n+┊   ┊ 64┊    let getByTestId: any = null;\n+┊   ┊ 65┊\n+┊   ┊ 66┊    act(() => {\n+┊   ┊ 67┊      getByTestId = render(\n+┊   ┊ 68┊        <ApolloProvider client={client}>\n+┊   ┊ 69┊          <SignInForm history={history} />\n+┊   ┊ 70┊        </ApolloProvider>\n+┊   ┊ 71┊      ).getByTestId;\n+┊   ┊ 72┊    });\n+┊   ┊ 73┊\n+┊   ┊ 74┊    const signInButton = await waitForElement(() =>\n+┊   ┊ 75┊      getByTestId('sign-in-button') as HTMLButtonElement\n+┊   ┊ 76┊    );\n+┊   ┊ 77┊    const usernameInput = await waitForElement(() =>\n+┊   ┊ 78┊      getByTestId('username-input').querySelector('input')\n+┊   ┊ 79┊    );\n+┊   ┊ 80┊    const passwordInput = await waitForElement(() =>\n+┊   ┊ 81┊      getByTestId('password-input').querySelector('input')\n+┊   ┊ 82┊    );\n+┊   ┊ 83┊\n+┊   ┊ 84┊    act(() => {\n+┊   ┊ 85┊      fireEvent.change(usernameInput, { target: { value: 'username' } });\n+┊   ┊ 86┊      fireEvent.change(passwordInput, { target: { value: 'password' } });\n+┊   ┊ 87┊    });\n+┊   ┊ 88┊\n+┊   ┊ 89┊    await wait(() =>\n+┊   ┊ 90┊      expect(usernameInput.value).toEqual('username')\n+┊   ┊ 91┊    );\n+┊   ┊ 92┊\n+┊   ┊ 93┊    await wait(() =>\n+┊   ┊ 94┊      expect(passwordInput.value).toEqual('password')\n+┊   ┊ 95┊    );\n+┊   ┊ 96┊\n+┊   ┊ 97┊    act(() => {\n+┊   ┊ 98┊      fireEvent.click(signInButton);\n+┊   ┊ 99┊    });\n+┊   ┊100┊\n+┊   ┊101┊    const errorMessage = await waitForElement(() =>\n+┊   ┊102┊      getByTestId('error-message')\n+┊   ┊103┊    );\n+┊   ┊104┊\n+┊   ┊105┊    expect(errorMessage.innerHTML).toContain('sign-in failed');\n+┊   ┊106┊  });\n+┊   ┊107┊\n+┊   ┊108┊  it('navigates to /chats if everything went right', async () => {\n+┊   ┊109┊    const history = createMemoryHistory();\n+┊   ┊110┊\n+┊   ┊111┊    const client = mockApolloClient([\n+┊   ┊112┊      {\n+┊   ┊113┊        request: {\n+┊   ┊114┊          query: SignInDocument,\n+┊   ┊115┊          variables: {\n+┊   ┊116┊            username: 'username',\n+┊   ┊117┊            password: 'password'\n+┊   ┊118┊          }\n+┊   ┊119┊        },\n+┊   ┊120┊        result: { data: {} }\n+┊   ┊121┊      }\n+┊   ┊122┊    ]);\n+┊   ┊123┊\n+┊   ┊124┊    let getByTestId: any = null;\n+┊   ┊125┊\n+┊   ┊126┊    act(() => {\n+┊   ┊127┊      getByTestId = render(\n+┊   ┊128┊        <ApolloProvider client={client}>\n+┊   ┊129┊          <SignInForm history={history} />\n+┊   ┊130┊        </ApolloProvider>\n+┊   ┊131┊      ).getByTestId;\n+┊   ┊132┊    })\n+┊   ┊133┊\n+┊   ┊134┊    const usernameInput = await waitForElement(() =>\n+┊   ┊135┊      getByTestId('username-input').querySelector('input')\n+┊   ┊136┊    );\n+┊   ┊137┊    const passwordInput = await waitForElement(() =>\n+┊   ┊138┊      getByTestId('password-input').querySelector('input')\n+┊   ┊139┊    );\n+┊   ┊140┊    const signInButton = await waitForElement(() =>\n+┊   ┊141┊      getByTestId('sign-in-button') as HTMLButtonElement\n+┊   ┊142┊    );\n+┊   ┊143┊\n+┊   ┊144┊    act(() => {\n+┊   ┊145┊      fireEvent.change(usernameInput, { target: { value: 'username' } });\n+┊   ┊146┊      fireEvent.change(passwordInput, { target: { value: 'password' } });\n+┊   ┊147┊    });\n+┊   ┊148┊\n+┊   ┊149┊    await wait(() =>\n+┊   ┊150┊      expect(usernameInput.value).toEqual('username')\n+┊   ┊151┊    );\n+┊   ┊152┊\n+┊   ┊153┊    await wait(() =>\n+┊   ┊154┊      expect(passwordInput.value).toEqual('password')\n+┊   ┊155┊    );\n+┊   ┊156┊\n+┊   ┊157┊    act(() => {\n+┊   ┊158┊      fireEvent.click(signInButton);\n+┊   ┊159┊    });\n+┊   ┊160┊\n+┊   ┊161┊    await wait(() => expect(history.location.pathname).toEqual('/chats'));\n+┊   ┊162┊  });\n+┊   ┊163┊});🚫↵\n```\n\n##### Added src&#x2F;components&#x2F;AuthScreen&#x2F;SignInForm.tsx\n```diff\n@@ -0,0 +1,83 @@\n+┊  ┊ 1┊import React from 'react';\n+┊  ┊ 2┊import { useCallback, useState } from 'react';\n+┊  ┊ 3┊import { useSignIn } from '../../services/auth.service';\n+┊  ┊ 4┊import {\n+┊  ┊ 5┊  SignForm,\n+┊  ┊ 6┊  ActualForm,\n+┊  ┊ 7┊  Legend,\n+┊  ┊ 8┊  Section,\n+┊  ┊ 9┊  TextField,\n+┊  ┊10┊  Button,\n+┊  ┊11┊  ErrorMessage,\n+┊  ┊12┊} from './form-components';\n+┊  ┊13┊import { RouteComponentProps } from 'react-router-dom';\n+┊  ┊14┊\n+┊  ┊15┊const SignInForm: React.FC<RouteComponentProps<any>> = ({ history }) => {\n+┊  ┊16┊  const [username, setUsername] = useState('');\n+┊  ┊17┊  const [password, setPassword] = useState('');\n+┊  ┊18┊  const [error, setError] = useState('');\n+┊  ┊19┊  const signIn = useSignIn();\n+┊  ┊20┊\n+┊  ┊21┊  const onUsernameChange = useCallback(({ target }) => {\n+┊  ┊22┊    setError('');\n+┊  ┊23┊    setUsername(target.value);\n+┊  ┊24┊  }, []);\n+┊  ┊25┊\n+┊  ┊26┊  const onPasswordChange = useCallback(({ target }) => {\n+┊  ┊27┊    setError('');\n+┊  ┊28┊    setPassword(target.value);\n+┊  ┊29┊  }, []);\n+┊  ┊30┊\n+┊  ┊31┊  const maySignIn = useCallback(() => {\n+┊  ┊32┊    return !!(username && password);\n+┊  ┊33┊  }, [username, password]);\n+┊  ┊34┊\n+┊  ┊35┊  const handleSignIn = useCallback(() => {\n+┊  ┊36┊    signIn({ variables: { username, password } })\n+┊  ┊37┊      .then(() => {\n+┊  ┊38┊        history.replace('/chats');\n+┊  ┊39┊      })\n+┊  ┊40┊      .catch(error => {\n+┊  ┊41┊        setError(error.message || error);\n+┊  ┊42┊      });\n+┊  ┊43┊  }, [username, password, history, signIn]);\n+┊  ┊44┊\n+┊  ┊45┊  return (\n+┊  ┊46┊    <SignForm>\n+┊  ┊47┊      <ActualForm>\n+┊  ┊48┊        <Legend>Sign in</Legend>\n+┊  ┊49┊        <Section style={{ width: '100%' }}>\n+┊  ┊50┊          <TextField\n+┊  ┊51┊            data-testid=\"username-input\"\n+┊  ┊52┊            label=\"Username\"\n+┊  ┊53┊            value={username}\n+┊  ┊54┊            onChange={onUsernameChange}\n+┊  ┊55┊            margin=\"normal\"\n+┊  ┊56┊            placeholder=\"Enter your username\"\n+┊  ┊57┊          />\n+┊  ┊58┊          <TextField\n+┊  ┊59┊            data-testid=\"password-input\"\n+┊  ┊60┊            label=\"Password\"\n+┊  ┊61┊            type=\"password\"\n+┊  ┊62┊            value={password}\n+┊  ┊63┊            onChange={onPasswordChange}\n+┊  ┊64┊            margin=\"normal\"\n+┊  ┊65┊            placeholder=\"Enter your password\"\n+┊  ┊66┊          />\n+┊  ┊67┊        </Section>\n+┊  ┊68┊        <Button\n+┊  ┊69┊          data-testid=\"sign-in-button\"\n+┊  ┊70┊          type=\"button\"\n+┊  ┊71┊          color=\"secondary\"\n+┊  ┊72┊          variant=\"contained\"\n+┊  ┊73┊          disabled={!maySignIn()}\n+┊  ┊74┊          onClick={handleSignIn}>\n+┊  ┊75┊          Sign in\n+┊  ┊76┊        </Button>\n+┊  ┊77┊        <ErrorMessage data-testid=\"error-message\">{error}</ErrorMessage>\n+┊  ┊78┊      </ActualForm>\n+┊  ┊79┊    </SignForm>\n+┊  ┊80┊  );\n+┊  ┊81┊};\n+┊  ┊82┊\n+┊  ┊83┊export default SignInForm;\n```\n\n##### Added src&#x2F;components&#x2F;AuthScreen&#x2F;SignUpForm.test.tsx\n```diff\n@@ -0,0 +1,225 @@\n+┊   ┊  1┊import { createMemoryHistory } from 'history';\n+┊   ┊  2┊import React from 'react';\n+┊   ┊  3┊import { ApolloProvider } from 'react-apollo-hooks';\n+┊   ┊  4┊import { act, cleanup, render, fireEvent, wait, waitForElement } from '@testing-library/react';\n+┊   ┊  5┊import SignUpForm from './SignUpForm';\n+┊   ┊  6┊import { SignUpDocument } from '../../graphql/types';\n+┊   ┊  7┊import { mockApolloClient } from '../../test-helpers';\n+┊   ┊  8┊\n+┊   ┊  9┊describe('SignUpForm', () => {\n+┊   ┊ 10┊  afterEach(cleanup);\n+┊   ┊ 11┊\n+┊   ┊ 12┊  it('enables sign-up button when filled in', async () => {\n+┊   ┊ 13┊    const history = createMemoryHistory();\n+┊   ┊ 14┊    const client = mockApolloClient();\n+┊   ┊ 15┊\n+┊   ┊ 16┊    let getByTestId: any = null;\n+┊   ┊ 17┊\n+┊   ┊ 18┊    act(() => {\n+┊   ┊ 19┊      getByTestId = render(\n+┊   ┊ 20┊        <ApolloProvider client={client}>\n+┊   ┊ 21┊          <SignUpForm history={history} />\n+┊   ┊ 22┊        </ApolloProvider>\n+┊   ┊ 23┊      ).getByTestId;\n+┊   ┊ 24┊    });\n+┊   ┊ 25┊\n+┊   ┊ 26┊    const nameInput = await waitForElement(() =>\n+┊   ┊ 27┊      getByTestId('name-input').querySelector('input')\n+┊   ┊ 28┊    );\n+┊   ┊ 29┊    const usernameInput = await waitForElement(() =>\n+┊   ┊ 30┊      getByTestId('username-input').querySelector('input')\n+┊   ┊ 31┊    );\n+┊   ┊ 32┊    const passwordInput = await waitForElement(() =>\n+┊   ┊ 33┊      getByTestId('password-input').querySelector('input')\n+┊   ┊ 34┊    );\n+┊   ┊ 35┊    const passwordConfirmInput = await waitForElement(() =>\n+┊   ┊ 36┊      getByTestId('password-confirm-input').querySelector('input')\n+┊   ┊ 37┊    );\n+┊   ┊ 38┊    const signUpButton = await waitForElement(() =>\n+┊   ┊ 39┊      getByTestId('sign-up-button') as HTMLButtonElement\n+┊   ┊ 40┊    );\n+┊   ┊ 41┊\n+┊   ┊ 42┊    expect(signUpButton.disabled).toEqual(true);\n+┊   ┊ 43┊\n+┊   ┊ 44┊    act(() => {\n+┊   ┊ 45┊      fireEvent.change(nameInput, { target: { value: 'User Name' } });\n+┊   ┊ 46┊      fireEvent.change(usernameInput, { target: { value: 'username' } });\n+┊   ┊ 47┊      fireEvent.change(passwordInput, { target: { value: 'password' } });\n+┊   ┊ 48┊      fireEvent.change(passwordConfirmInput, { target: { value: 'password' } });\n+┊   ┊ 49┊    });\n+┊   ┊ 50┊\n+┊   ┊ 51┊    await wait(() =>\n+┊   ┊ 52┊      expect(nameInput.value).toEqual('User Name')\n+┊   ┊ 53┊    );\n+┊   ┊ 54┊\n+┊   ┊ 55┊    await wait(() =>\n+┊   ┊ 56┊      expect(usernameInput.value).toEqual('username')\n+┊   ┊ 57┊    );\n+┊   ┊ 58┊\n+┊   ┊ 59┊    await wait(() =>\n+┊   ┊ 60┊      expect(passwordInput.value).toEqual('password')\n+┊   ┊ 61┊    );\n+┊   ┊ 62┊\n+┊   ┊ 63┊    await wait(() =>\n+┊   ┊ 64┊      expect(passwordConfirmInput.value).toEqual('password')\n+┊   ┊ 65┊    );\n+┊   ┊ 66┊\n+┊   ┊ 67┊    await wait(() =>\n+┊   ┊ 68┊      expect(signUpButton.disabled).toEqual(false)\n+┊   ┊ 69┊    )\n+┊   ┊ 70┊  });\n+┊   ┊ 71┊\n+┊   ┊ 72┊  it('prints server error if input was wrong', async () => {\n+┊   ┊ 73┊    const history = createMemoryHistory();\n+┊   ┊ 74┊\n+┊   ┊ 75┊    const client = mockApolloClient([\n+┊   ┊ 76┊      {\n+┊   ┊ 77┊        request: {\n+┊   ┊ 78┊          query: SignUpDocument,\n+┊   ┊ 79┊          variables: {\n+┊   ┊ 80┊            name: 'User Name',\n+┊   ┊ 81┊            username: 'username',\n+┊   ┊ 82┊            password: 'password',\n+┊   ┊ 83┊            passwordConfirm: 'password'\n+┊   ┊ 84┊          }\n+┊   ┊ 85┊        },\n+┊   ┊ 86┊        get result() { throw Error('sign-up failed') }\n+┊   ┊ 87┊      }\n+┊   ┊ 88┊    ]);\n+┊   ┊ 89┊\n+┊   ┊ 90┊    let getByTestId: any = null;\n+┊   ┊ 91┊\n+┊   ┊ 92┊    act(() => {\n+┊   ┊ 93┊      getByTestId = render(\n+┊   ┊ 94┊        <ApolloProvider client={client}>\n+┊   ┊ 95┊          <SignUpForm history={history} />\n+┊   ┊ 96┊        </ApolloProvider>\n+┊   ┊ 97┊      ).getByTestId;\n+┊   ┊ 98┊    });\n+┊   ┊ 99┊\n+┊   ┊100┊    const nameInput = await waitForElement(() =>\n+┊   ┊101┊      getByTestId('name-input').querySelector('input')\n+┊   ┊102┊    );\n+┊   ┊103┊    const usernameInput = await waitForElement(() =>\n+┊   ┊104┊      getByTestId('username-input').querySelector('input')\n+┊   ┊105┊    );\n+┊   ┊106┊    const passwordInput = await waitForElement(() =>\n+┊   ┊107┊      getByTestId('password-input').querySelector('input')\n+┊   ┊108┊    );\n+┊   ┊109┊    const passwordConfirmInput = await waitForElement(() =>\n+┊   ┊110┊      getByTestId('password-confirm-input').querySelector('input')\n+┊   ┊111┊    );\n+┊   ┊112┊    const signUpButton = await waitForElement(() =>\n+┊   ┊113┊      getByTestId('sign-up-button') as HTMLButtonElement\n+┊   ┊114┊    );\n+┊   ┊115┊\n+┊   ┊116┊    act(() => {\n+┊   ┊117┊      fireEvent.change(nameInput, { target: { value: 'User Name' } });\n+┊   ┊118┊      fireEvent.change(usernameInput, { target: { value: 'username' } });\n+┊   ┊119┊      fireEvent.change(passwordInput, { target: { value: 'password' } });\n+┊   ┊120┊      fireEvent.change(passwordConfirmInput, { target: { value: 'password' } });\n+┊   ┊121┊    });\n+┊   ┊122┊\n+┊   ┊123┊    await wait(() =>\n+┊   ┊124┊      expect(nameInput.value).toEqual('User Name')\n+┊   ┊125┊    );\n+┊   ┊126┊\n+┊   ┊127┊    await wait(() =>\n+┊   ┊128┊      expect(usernameInput.value).toEqual('username')\n+┊   ┊129┊    );\n+┊   ┊130┊\n+┊   ┊131┊    await wait(() =>\n+┊   ┊132┊      expect(passwordInput.value).toEqual('password')\n+┊   ┊133┊    );\n+┊   ┊134┊\n+┊   ┊135┊    await wait(() =>\n+┊   ┊136┊      expect(passwordConfirmInput.value).toEqual('password')\n+┊   ┊137┊    );\n+┊   ┊138┊\n+┊   ┊139┊    act(() => {\n+┊   ┊140┊      fireEvent.click(signUpButton);\n+┊   ┊141┊    });\n+┊   ┊142┊\n+┊   ┊143┊    const errorMessage = await waitForElement(() =>\n+┊   ┊144┊      getByTestId('error-message')\n+┊   ┊145┊    );\n+┊   ┊146┊\n+┊   ┊147┊    expect(errorMessage.innerHTML).toContain('sign-up failed');\n+┊   ┊148┊  });\n+┊   ┊149┊\n+┊   ┊150┊  it('navigates to /sign-in if everything went right', async () => {\n+┊   ┊151┊    const history = createMemoryHistory();\n+┊   ┊152┊\n+┊   ┊153┊    const client = mockApolloClient([\n+┊   ┊154┊      {\n+┊   ┊155┊        request: {\n+┊   ┊156┊          query: SignUpDocument,\n+┊   ┊157┊          variables: {\n+┊   ┊158┊            name: 'User Name',\n+┊   ┊159┊            username: 'username',\n+┊   ┊160┊            password: 'password',\n+┊   ┊161┊            passwordConfirm: 'password'\n+┊   ┊162┊          }\n+┊   ┊163┊        },\n+┊   ┊164┊        result: { data: {} }\n+┊   ┊165┊      }\n+┊   ┊166┊    ]);\n+┊   ┊167┊\n+┊   ┊168┊    let getByTestId: any = null;\n+┊   ┊169┊\n+┊   ┊170┊    act(() => {\n+┊   ┊171┊      getByTestId = render(\n+┊   ┊172┊        <ApolloProvider client={client}>\n+┊   ┊173┊          <SignUpForm history={history} />\n+┊   ┊174┊        </ApolloProvider>\n+┊   ┊175┊      ).getByTestId;\n+┊   ┊176┊    });\n+┊   ┊177┊\n+┊   ┊178┊    const nameInput = await waitForElement(() =>\n+┊   ┊179┊      getByTestId('name-input').querySelector('input')\n+┊   ┊180┊    );\n+┊   ┊181┊    const usernameInput = await waitForElement(() =>\n+┊   ┊182┊      getByTestId('username-input').querySelector('input')\n+┊   ┊183┊    );\n+┊   ┊184┊    const passwordInput = await waitForElement(() =>\n+┊   ┊185┊      getByTestId('password-input').querySelector('input')\n+┊   ┊186┊    );\n+┊   ┊187┊    const passwordConfirmInput = await waitForElement(() =>\n+┊   ┊188┊      getByTestId('password-confirm-input').querySelector('input')\n+┊   ┊189┊    );\n+┊   ┊190┊    const signUpButton = await waitForElement(() =>\n+┊   ┊191┊      getByTestId('sign-up-button') as HTMLButtonElement\n+┊   ┊192┊    );\n+┊   ┊193┊\n+┊   ┊194┊    act(() => {\n+┊   ┊195┊      fireEvent.change(nameInput, { target: { value: 'User Name' } });\n+┊   ┊196┊      fireEvent.change(usernameInput, { target: { value: 'username' } });\n+┊   ┊197┊      fireEvent.change(passwordInput, { target: { value: 'password' } });\n+┊   ┊198┊      fireEvent.change(passwordConfirmInput, { target: { value: 'password' } });\n+┊   ┊199┊    });\n+┊   ┊200┊\n+┊   ┊201┊    await wait(() =>\n+┊   ┊202┊      expect(nameInput.value).toEqual('User Name')\n+┊   ┊203┊    );\n+┊   ┊204┊\n+┊   ┊205┊    await wait(() =>\n+┊   ┊206┊      expect(usernameInput.value).toEqual('username')\n+┊   ┊207┊    );\n+┊   ┊208┊\n+┊   ┊209┊    await wait(() =>\n+┊   ┊210┊      expect(passwordInput.value).toEqual('password')\n+┊   ┊211┊    );\n+┊   ┊212┊\n+┊   ┊213┊    await wait(() =>\n+┊   ┊214┊      expect(passwordConfirmInput.value).toEqual('password')\n+┊   ┊215┊    );\n+┊   ┊216┊\n+┊   ┊217┊    act(() => {\n+┊   ┊218┊      fireEvent.click(signUpButton);\n+┊   ┊219┊    });\n+┊   ┊220┊\n+┊   ┊221┊    await wait(() =>\n+┊   ┊222┊      expect(history.location.pathname).toEqual('/sign-in')\n+┊   ┊223┊    );\n+┊   ┊224┊  });\n+┊   ┊225┊});🚫↵\n```\n\n##### Added src&#x2F;components&#x2F;AuthScreen&#x2F;SignUpForm.tsx\n```diff\n@@ -0,0 +1,124 @@\n+┊   ┊  1┊import React from 'react';\n+┊   ┊  2┊import { useCallback, useState } from 'react';\n+┊   ┊  3┊import { useSignUp } from '../../services/auth.service';\n+┊   ┊  4┊import {\n+┊   ┊  5┊  SignForm,\n+┊   ┊  6┊  ActualForm,\n+┊   ┊  7┊  Legend,\n+┊   ┊  8┊  Section,\n+┊   ┊  9┊  TextField,\n+┊   ┊ 10┊  Button,\n+┊   ┊ 11┊  ErrorMessage,\n+┊   ┊ 12┊} from './form-components';\n+┊   ┊ 13┊import { RouteComponentProps } from 'react-router-dom';\n+┊   ┊ 14┊\n+┊   ┊ 15┊const SignUpForm: React.FC<RouteComponentProps<any>> = ({ history }) => {\n+┊   ┊ 16┊  const [name, setName] = useState('');\n+┊   ┊ 17┊  const [username, setUsername] = useState('');\n+┊   ┊ 18┊  const [password, setPassword] = useState('');\n+┊   ┊ 19┊  const [passwordConfirm, setPasswordConfirm] = useState('');\n+┊   ┊ 20┊  const [error, setError] = useState('');\n+┊   ┊ 21┊  const signUp = useSignUp()\n+┊   ┊ 22┊\n+┊   ┊ 23┊  const updateName = useCallback(({ target }) => {\n+┊   ┊ 24┊    setError('');\n+┊   ┊ 25┊    setName(target.value);\n+┊   ┊ 26┊  }, []);\n+┊   ┊ 27┊\n+┊   ┊ 28┊  const updateUsername = useCallback(({ target }) => {\n+┊   ┊ 29┊    setError('');\n+┊   ┊ 30┊    setUsername(target.value);\n+┊   ┊ 31┊  }, []);\n+┊   ┊ 32┊\n+┊   ┊ 33┊  const updatePassword = useCallback(({ target }) => {\n+┊   ┊ 34┊    setError('');\n+┊   ┊ 35┊    setPassword(target.value);\n+┊   ┊ 36┊  }, []);\n+┊   ┊ 37┊\n+┊   ┊ 38┊  const updatePasswordConfirm = useCallback(({ target }) => {\n+┊   ┊ 39┊    setError('');\n+┊   ┊ 40┊    setPasswordConfirm(target.value);\n+┊   ┊ 41┊  }, []);\n+┊   ┊ 42┊\n+┊   ┊ 43┊  const maySignUp = useCallback(() => {\n+┊   ┊ 44┊    return !!(name && username && password && password === passwordConfirm);\n+┊   ┊ 45┊  }, [name, username, password, passwordConfirm]);\n+┊   ┊ 46┊\n+┊   ┊ 47┊  const handleSignUp = useCallback(() => {\n+┊   ┊ 48┊    signUp({ variables: { username, password, passwordConfirm, name } })\n+┊   ┊ 49┊      .then(() => {\n+┊   ┊ 50┊        history.replace('/sign-in');\n+┊   ┊ 51┊      })\n+┊   ┊ 52┊      .catch(error => {\n+┊   ┊ 53┊        setError(error.message || error);\n+┊   ┊ 54┊      });\n+┊   ┊ 55┊  }, [name, username, password, passwordConfirm, history, signUp]);\n+┊   ┊ 56┊\n+┊   ┊ 57┊  return (\n+┊   ┊ 58┊    <SignForm>\n+┊   ┊ 59┊      <ActualForm>\n+┊   ┊ 60┊        <Legend>Sign up</Legend>\n+┊   ┊ 61┊        <Section\n+┊   ┊ 62┊          style={{\n+┊   ┊ 63┊            float: 'left',\n+┊   ┊ 64┊            width: 'calc(50% - 10px)',\n+┊   ┊ 65┊            paddingRight: '10px',\n+┊   ┊ 66┊          }}>\n+┊   ┊ 67┊          <TextField\n+┊   ┊ 68┊            data-testid=\"name-input\"\n+┊   ┊ 69┊            label=\"Name\"\n+┊   ┊ 70┊            value={name}\n+┊   ┊ 71┊            onChange={updateName}\n+┊   ┊ 72┊            autoComplete=\"off\"\n+┊   ┊ 73┊            margin=\"normal\"\n+┊   ┊ 74┊          />\n+┊   ┊ 75┊          <TextField\n+┊   ┊ 76┊            data-testid=\"username-input\"\n+┊   ┊ 77┊            label=\"Username\"\n+┊   ┊ 78┊            value={username}\n+┊   ┊ 79┊            onChange={updateUsername}\n+┊   ┊ 80┊            autoComplete=\"off\"\n+┊   ┊ 81┊            margin=\"normal\"\n+┊   ┊ 82┊          />\n+┊   ┊ 83┊        </Section>\n+┊   ┊ 84┊        <Section\n+┊   ┊ 85┊          style={{\n+┊   ┊ 86┊            float: 'right',\n+┊   ┊ 87┊            width: 'calc(50% - 10px)',\n+┊   ┊ 88┊            paddingLeft: '10px',\n+┊   ┊ 89┊          }}>\n+┊   ┊ 90┊          <TextField\n+┊   ┊ 91┊            data-testid=\"password-input\"\n+┊   ┊ 92┊            label=\"Password\"\n+┊   ┊ 93┊            type=\"password\"\n+┊   ┊ 94┊            value={password}\n+┊   ┊ 95┊            onChange={updatePassword}\n+┊   ┊ 96┊            autoComplete=\"off\"\n+┊   ┊ 97┊            margin=\"normal\"\n+┊   ┊ 98┊          />\n+┊   ┊ 99┊          <TextField\n+┊   ┊100┊            data-testid=\"password-confirm-input\"\n+┊   ┊101┊            label=\"Confirm password\"\n+┊   ┊102┊            type=\"password\"\n+┊   ┊103┊            value={passwordConfirm}\n+┊   ┊104┊            onChange={updatePasswordConfirm}\n+┊   ┊105┊            autoComplete=\"off\"\n+┊   ┊106┊            margin=\"normal\"\n+┊   ┊107┊          />\n+┊   ┊108┊        </Section>\n+┊   ┊109┊        <Button\n+┊   ┊110┊          data-testid=\"sign-up-button\"\n+┊   ┊111┊          type=\"button\"\n+┊   ┊112┊          color=\"secondary\"\n+┊   ┊113┊          variant=\"contained\"\n+┊   ┊114┊          disabled={!maySignUp()}\n+┊   ┊115┊          onClick={handleSignUp}>\n+┊   ┊116┊          Sign up\n+┊   ┊117┊        </Button>\n+┊   ┊118┊        <ErrorMessage data-testid=\"error-message\">{error}</ErrorMessage>\n+┊   ┊119┊      </ActualForm>\n+┊   ┊120┊    </SignForm>\n+┊   ┊121┊  );\n+┊   ┊122┊};\n+┊   ┊123┊\n+┊   ┊124┊export default SignUpForm;\n```\n\n##### Added src&#x2F;components&#x2F;AuthScreen&#x2F;form-components.ts\n```diff\n@@ -0,0 +1,75 @@\n+┊  ┊ 1┊import MaterialButton from '@material-ui/core/Button';\n+┊  ┊ 2┊import MaterialTextField from '@material-ui/core/TextField';\n+┊  ┊ 3┊import styled from 'styled-components';\n+┊  ┊ 4┊\n+┊  ┊ 5┊export const SignForm = styled.div`\n+┊  ┊ 6┊  height: calc(100% - 265px);\n+┊  ┊ 7┊`;\n+┊  ┊ 8┊\n+┊  ┊ 9┊export const ActualForm = styled.form`\n+┊  ┊10┊  padding: 20px;\n+┊  ┊11┊`;\n+┊  ┊12┊\n+┊  ┊13┊export const Section = styled.div`\n+┊  ┊14┊  padding-bottom: 35px;\n+┊  ┊15┊`;\n+┊  ┊16┊\n+┊  ┊17┊export const Legend = styled.legend`\n+┊  ┊18┊  font-weight: bold;\n+┊  ┊19┊  color: white;\n+┊  ┊20┊`;\n+┊  ┊21┊\n+┊  ┊22┊export const Label = styled.label`\n+┊  ┊23┊  color: white !important;\n+┊  ┊24┊`;\n+┊  ┊25┊\n+┊  ┊26┊export const Input = styled.input`\n+┊  ┊27┊  color: white;\n+┊  ┊28┊\n+┊  ┊29┊  &::placeholder {\n+┊  ┊30┊    color: var(--primary-bg);\n+┊  ┊31┊  }\n+┊  ┊32┊`;\n+┊  ┊33┊\n+┊  ┊34┊export const TextField = styled(MaterialTextField)`\n+┊  ┊35┊  width: 100%;\n+┊  ┊36┊  position: relative;\n+┊  ┊37┊\n+┊  ┊38┊  > div::before {\n+┊  ┊39┊    border-color: white !important;\n+┊  ┊40┊  }\n+┊  ┊41┊\n+┊  ┊42┊  input {\n+┊  ┊43┊    color: white !important;\n+┊  ┊44┊\n+┊  ┊45┊    &::placeholder {\n+┊  ┊46┊      color: var(--primary-bg) !important;\n+┊  ┊47┊    }\n+┊  ┊48┊  }\n+┊  ┊49┊\n+┊  ┊50┊  label {\n+┊  ┊51┊    color: white !important;\n+┊  ┊52┊  }\n+┊  ┊53┊` as typeof MaterialTextField;\n+┊  ┊54┊\n+┊  ┊55┊export const Button = styled(MaterialButton)`\n+┊  ┊56┊  width: 100px;\n+┊  ┊57┊  display: block !important;\n+┊  ┊58┊  margin: auto !important;\n+┊  ┊59┊  background-color: var(--secondary-bg) !important;\n+┊  ┊60┊\n+┊  ┊61┊  &[disabled] {\n+┊  ┊62┊    color: #38a81c;\n+┊  ┊63┊  }\n+┊  ┊64┊\n+┊  ┊65┊  &:not([disabled]) {\n+┊  ┊66┊    color: white;\n+┊  ┊67┊  }\n+┊  ┊68┊` as typeof MaterialButton;\n+┊  ┊69┊\n+┊  ┊70┊export const ErrorMessage = styled.div`\n+┊  ┊71┊  position: fixed;\n+┊  ┊72┊  color: red;\n+┊  ┊73┊  font-size: 15px;\n+┊  ┊74┊  margin-top: 20px;\n+┊  ┊75┊`;\n```\n\n##### Changed src&#x2F;components&#x2F;AuthScreen&#x2F;index.tsx\n```diff\n@@ -1,13 +1,13 @@\n-┊ 1┊  ┊import MaterialButton from '@material-ui/core/Button';\n-┊ 2┊  ┊import MaterialTextField from '@material-ui/core/TextField';\n ┊ 3┊ 1┊import React from 'react';\n-┊ 4┊  ┊import { useCallback, useState } from 'react';\n+┊  ┊ 2┊import { useMemo } from 'react';\n+┊  ┊ 3┊import { Route } from 'react-router-dom';\n ┊ 5┊ 4┊import styled from 'styled-components';\n-┊ 6┊  ┊import { useSignIn } from '../../services/auth.service';\n+┊  ┊ 5┊import AnimatedSwitch from '../AnimatedSwitch';\n+┊  ┊ 6┊import SignInForm from './SignInForm';\n+┊  ┊ 7┊import SignUpForm from './SignUpForm';\n ┊ 7┊ 8┊import { RouteComponentProps } from 'react-router-dom';\n ┊ 8┊ 9┊\n ┊ 9┊10┊const Container = styled.div`\n-┊10┊  ┊  height: 100%;\n ┊11┊11┊  background: radial-gradient(rgb(34, 65, 67), rgb(17, 48, 50)),\n ┊12┊12┊    url(/assets/chat-background.jpg) no-repeat;\n ┊13┊13┊  background-size: cover;\n```\n```diff\n@@ -40,149 +40,51 @@\n ┊ 40┊ 40┊  bottom: 10px;\n ┊ 41┊ 41┊  left: 10px;\n ┊ 42┊ 42┊\n-┊ 43┊   ┊  a {\n+┊   ┊ 43┊  label {\n ┊ 44┊ 44┊    color: var(--secondary-bg);\n ┊ 45┊ 45┊  }\n ┊ 46┊ 46┊`;\n ┊ 47┊ 47┊\n-┊ 48┊   ┊const SignInForm = styled.div`\n-┊ 49┊   ┊  height: calc(100% - 265px);\n-┊ 50┊   ┊`;\n-┊ 51┊   ┊\n-┊ 52┊   ┊const ActualForm = styled.form`\n-┊ 53┊   ┊  padding: 20px;\n-┊ 54┊   ┊`;\n-┊ 55┊   ┊\n-┊ 56┊   ┊const Section = styled.div`\n-┊ 57┊   ┊  width: 100%;\n-┊ 58┊   ┊  padding-bottom: 35px;\n-┊ 59┊   ┊`;\n-┊ 60┊   ┊\n-┊ 61┊   ┊const Legend = styled.legend`\n-┊ 62┊   ┊  font-weight: bold;\n-┊ 63┊   ┊  color: white;\n-┊ 64┊   ┊`;\n-┊ 65┊   ┊\n-┊ 66┊   ┊// eslint-disable-next-line\n-┊ 67┊   ┊const Label = styled.label`\n-┊ 68┊   ┊  color: white !important;\n-┊ 69┊   ┊`;\n-┊ 70┊   ┊\n-┊ 71┊   ┊// eslint-disable-next-line\n-┊ 72┊   ┊const Input = styled.input`\n-┊ 73┊   ┊  color: white;\n-┊ 74┊   ┊\n-┊ 75┊   ┊  &::placeholder {\n-┊ 76┊   ┊    color: var(--primary-bg);\n-┊ 77┊   ┊  }\n-┊ 78┊   ┊`;\n-┊ 79┊   ┊\n-┊ 80┊   ┊const TextField = styled(MaterialTextField)`\n-┊ 81┊   ┊  width: 100%;\n-┊ 82┊   ┊  position: relative;\n-┊ 83┊   ┊\n-┊ 84┊   ┊  > div::before {\n-┊ 85┊   ┊    border-color: white !important;\n-┊ 86┊   ┊  }\n-┊ 87┊   ┊\n-┊ 88┊   ┊  input {\n-┊ 89┊   ┊    color: white !important;\n-┊ 90┊   ┊\n-┊ 91┊   ┊    &::placeholder {\n-┊ 92┊   ┊      color: var(--primary-bg) !important;\n+┊   ┊ 48┊const AuthScreen: React.FC<RouteComponentProps<any>> = ({\n+┊   ┊ 49┊  history,\n+┊   ┊ 50┊  location,\n+┊   ┊ 51┊}) => {\n+┊   ┊ 52┊  const alternative = useMemo(() => {\n+┊   ┊ 53┊    if (location.pathname === '/sign-in') {\n+┊   ┊ 54┊      const handleSignUp = () => {\n+┊   ┊ 55┊        history.replace('/sign-up');\n+┊   ┊ 56┊      };\n+┊   ┊ 57┊\n+┊   ┊ 58┊      return (\n+┊   ┊ 59┊        <Alternative>\n+┊   ┊ 60┊          Don't have an account yet?{' '}\n+┊   ┊ 61┊          <label onClick={handleSignUp}>Sign up!</label>\n+┊   ┊ 62┊        </Alternative>\n+┊   ┊ 63┊      );\n+┊   ┊ 64┊    } else {\n+┊   ┊ 65┊      const handleSignIn = () => {\n+┊   ┊ 66┊        history.replace('/sign-in');\n+┊   ┊ 67┊      };\n+┊   ┊ 68┊\n+┊   ┊ 69┊      return (\n+┊   ┊ 70┊        <Alternative>\n+┊   ┊ 71┊          Already have an accout? <label onClick={handleSignIn}>Sign in!</label>\n+┊   ┊ 72┊        </Alternative>\n+┊   ┊ 73┊      );\n ┊ 93┊ 74┊    }\n-┊ 94┊   ┊  }\n-┊ 95┊   ┊\n-┊ 96┊   ┊  label {\n-┊ 97┊   ┊    color: white !important;\n-┊ 98┊   ┊  }\n-┊ 99┊   ┊` as typeof MaterialTextField;\n-┊100┊   ┊\n-┊101┊   ┊const Button = styled(MaterialButton)`\n-┊102┊   ┊  width: 100px;\n-┊103┊   ┊  display: block !important;\n-┊104┊   ┊  margin: auto !important;\n-┊105┊   ┊  background-color: var(--secondary-bg) !important;\n-┊106┊   ┊\n-┊107┊   ┊  &[disabled] {\n-┊108┊   ┊    color: #38a81c;\n-┊109┊   ┊  }\n-┊110┊   ┊\n-┊111┊   ┊  &:not([disabled]) {\n-┊112┊   ┊    color: white;\n-┊113┊   ┊  }\n-┊114┊   ┊` as typeof MaterialButton;\n-┊115┊   ┊\n-┊116┊   ┊const AuthScreen: React.FC<RouteComponentProps<any>> = ({ history }) => {\n-┊117┊   ┊  const [username, setUsername] = useState('');\n-┊118┊   ┊  const [password, setPassword] = useState('');\n-┊119┊   ┊  // eslint-disable-next-line\n-┊120┊   ┊  const [error, setError] = useState('');\n-┊121┊   ┊  const signIn = useSignIn();\n-┊122┊   ┊\n-┊123┊   ┊  const onUsernameChange = useCallback(({ target }) => {\n-┊124┊   ┊    setError('');\n-┊125┊   ┊    setUsername(target.value);\n-┊126┊   ┊  }, []);\n-┊127┊   ┊\n-┊128┊   ┊  const onPasswordChange = useCallback(({ target }) => {\n-┊129┊   ┊    setError('');\n-┊130┊   ┊    setPassword(target.value);\n-┊131┊   ┊  }, []);\n-┊132┊   ┊\n-┊133┊   ┊  const maySignIn = useCallback(() => {\n-┊134┊   ┊    return !!(username && password);\n-┊135┊   ┊  }, [username, password]);\n-┊136┊   ┊\n-┊137┊   ┊  const handleSignIn = useCallback(() => {\n-┊138┊   ┊    signIn({ variables: { username, password } })\n-┊139┊   ┊      .then(() => {\n-┊140┊   ┊        history.push('/chats');\n-┊141┊   ┊      })\n-┊142┊   ┊      .catch(error => {\n-┊143┊   ┊        setError(error.message || error);\n-┊144┊   ┊      });\n-┊145┊   ┊  }, [username, password, history, signIn]);\n+┊   ┊ 75┊  }, [location.pathname, history]);\n ┊146┊ 76┊\n ┊147┊ 77┊  return (\n-┊148┊   ┊    <Container>\n-┊149┊   ┊      <Intro>\n+┊   ┊ 78┊    <Container className=\"AuthScreen Screen\">\n+┊   ┊ 79┊      <Intro className=\"AuthScreen-intro\">\n ┊150┊ 80┊        <Icon src=\"assets/whatsapp-icon.png\" className=\"AuthScreen-icon\" />\n ┊151┊ 81┊        <Title className=\"AuthScreen-title\">WhatsApp</Title>\n ┊152┊ 82┊      </Intro>\n-┊153┊   ┊      <SignInForm>\n-┊154┊   ┊        <ActualForm>\n-┊155┊   ┊          <Legend>Sign in</Legend>\n-┊156┊   ┊          <Section>\n-┊157┊   ┊            <TextField\n-┊158┊   ┊              className=\"AuthScreen-text-field\"\n-┊159┊   ┊              label=\"Username\"\n-┊160┊   ┊              value={username}\n-┊161┊   ┊              onChange={onUsernameChange}\n-┊162┊   ┊              margin=\"normal\"\n-┊163┊   ┊              placeholder=\"Enter your username\"\n-┊164┊   ┊            />\n-┊165┊   ┊            <TextField\n-┊166┊   ┊              className=\"AuthScreen-text-field\"\n-┊167┊   ┊              label=\"Password\"\n-┊168┊   ┊              type=\"password\"\n-┊169┊   ┊              value={password}\n-┊170┊   ┊              onChange={onPasswordChange}\n-┊171┊   ┊              margin=\"normal\"\n-┊172┊   ┊              placeholder=\"Enter your password\"\n-┊173┊   ┊            />\n-┊174┊   ┊          </Section>\n-┊175┊   ┊          <Button\n-┊176┊   ┊            data-testid=\"sign-in-button\"\n-┊177┊   ┊            type=\"button\"\n-┊178┊   ┊            color=\"secondary\"\n-┊179┊   ┊            variant=\"contained\"\n-┊180┊   ┊            disabled={!maySignIn()}\n-┊181┊   ┊            onClick={handleSignIn}>\n-┊182┊   ┊            Sign in\n-┊183┊   ┊          </Button>\n-┊184┊   ┊        </ActualForm>\n-┊185┊   ┊      </SignInForm>\n+┊   ┊ 83┊      <AnimatedSwitch>\n+┊   ┊ 84┊        <Route exact path=\"/sign-in\" component={SignInForm} />\n+┊   ┊ 85┊        <Route exact path=\"/sign-up\" component={SignUpForm} />\n+┊   ┊ 86┊      </AnimatedSwitch>\n+┊   ┊ 87┊      {alternative}\n ┊186┊ 88┊    </Container>\n ┊187┊ 89┊  );\n ┊188┊ 90┊};\n```\n\n[}]: #\n\n> Note how we used the `/sign-(in|up)` pattern to define the `signUp` mutation. This is because the request will be further redirected in the `AuthScreen`.\n\nThe authentication flow is complete! To test it out, you can create a new user, log in with it and start chatting with other users."
          },
          {
            "manualTitle": "Step 14: Migrating to PostgreSQL",
            "stepRevision": "be29b2169309f0e2de4bea0655e419fbcc2761e7",
            "manualView": "**Which Relational Database? And Why?**\n\nWe’ve used to have an in-memory database so far that keeps our entities on memory inside business logic so far. But in a real application we will need a real database system that keeps our data which is seperated from our business logic. In this part we will design our database according to the relational database principles with the benefits of SQL.\n\nWe prefer to use PostgreSQL from now on; because PostgreSQL is a Relational Database implementation that has tables, constraints, triggers, roles, stored procedures and views together with foreign tables from external data sources and many features from NoSQL.\n\n**Database Design**\n\nWhile we are defining our entity types and schema inside our array-based in-memory database, we have already designed the basic parts of them. In this part, we will design our relational database with base and relation tables regarding to them.\n\nInitially we can decide the base fields without relations;\n* User;\n    * `id`\n    * `name`\n    * `username`\n    * `password`\n    * `picture`\n* Message;\n    * `id`\n    * `content`\n    * `created_at`\n* Chat;\n    * `id`\n\nBefore creating tables, we should design our database structure according to [Database Normalization principles](https://www.essentialsql.com/get-ready-to-learn-sql-database-normalization-explained-in-simple-english/) to prevent duplicated data and modification anomalies.\n\nInitially we will have 3 base tables in our database; `user`, `chat`, `message`; and there are some relations between those 3 tables. These relations will be defined in other relation tables together with different primary key and foreign key definitions.\n\nThere are four types of relations in relational databases;\n\n* One to one\n    * This relationship means A entity type can have a relationship with only one instance of B entity type while B entity type can have a relationship with only one instance of A entity type. For example, one user can have only one profile while a profile belongs to only one user.\n* Many to one\n    * This relationship means A entity type can have a relationship with multiple instances of B entity type while B entity type can have a relationship with only one instance of A entity type. For example, a chat can have multiple messages while a message belongs to only one chat. But `many to one` as a word means multiple photos belong to the same chat.\n* One to many\n    * This relationship has the same logic with Many to one. However, `One to many` as a word means a chat can have multiple messages while those messages cannot have multiple chats but only one.\n* Many to many\n    * This relationship means A entity type can have a relationship with multiple instances of B entity type while B entity type can have a relationship with multiple instances of A entity type dependently or independently. For example; a chat can have multiple users, and a user can have multiple chats.\n\nYou can read more about those relations in [here](https://www.techrepublic.com/article/relational-databases-defining-relationships-between-database-tables/).\n\nIn existing entity declarations and schema, we have 6 relationships;\n\n* Message has a One To Many relationship under the name of `chat` inside our schema; so one message can have one chat while one chat can have multiple messages.\n\n```gql\ntype Message { chat: Chat }\n```\n\n* Message has another One To Many relationship under the name of `sender`` inside our schema; so one message can have one sender while one sender user can have multiple messages.\n\n```gql\ntype Message { sender: User }\n```\n\n* Message has one more One To Many relationship under the name of `recipient`` inside our schema; so one message can have one recipient while one recipient user can have multiple messages.\n\n```gql\ntype Message { recipient: User }\n```\n\n* Chat has a One To Many relationship under the name of `messages`, because one chat can have multiple messages while one message can have only one chat. Notice that this relationship is the reversed version of the first relationship in Message.\n\n```gql\n`type Chat { messages: [Message] }\n```\n\n* Chat has another Many To Many relationship under the name of `participants`, because one chat can have multiple participants while a participant can have multiple chats as well.\n\n```gql\ntype Chat { participants: [User] }\n```\n\n* User has a Many To Many relationship under the name of `chats`, because one user can have multiple chats, while it has the same situation for chats.\n\n```gql\ntype User { chats: [Chat] }\n```\n\n\nSo we should decide the dependencies between each other to add columns and tables to our database.\n\n* User is independent in all relationships, so we will keep its columns as it is\n* Message is dependent to User in two cases so we can define this relationship as two different new foreign keys pointing to User’s id under the columns `sender_user_id`. But we don’t need `recipient_user_id` because `recipient` can be found under Chat’s participants.\n* Chat is also independent because it will be better to keep those relations inside Message.\n* Message is dependent to Chat so we can define this relationship as a new foreign key that points to Chat’s id under the column named `chat_id`.\n* We need to have another table that defines the relationship between multiple chats and users.\n\n> We don’t need to duplicate relations in each entities, because SQL has the power to reverse each relations even if they are defined only in one entity. This is one of the rule of Database Normalization.\n\nFinally we can decide on our tables;\n\n* `chats` table;\n    * `id` ->\n        * `PRIMARY KEY` - `SERIAL`\n        * `SERIAL` will automatically increase the number of the new chat row. Check SQL docs about primary key and auto increment\n* `users` table;\n    * `id` ->\n        * `PRIMARY KEY` - `SERIAL`\n    * `name` ->\n        * `VARCHAR`\n    * `username` ->\n        * `VARCHAR` - `UNIQUE`\n        * `UNIQUE` means this value can exist in this table only once. We use this feature because `username` must be unique in users for each user\n    * `password` ->\n        * `VARCHAR`\n    * `picture` ->\n        * `VARCHAR`\n* `chats_users` table;\n    * `chat_id` ->\n        * `FOREIGN KEY` points to `chat.id` ->\n            * `ON DELETE` -> `CASCADE`.\n            * This means that if chat that has this id is deleted, this row will be deleted automatically as well.\n    * `user_id` ->\n        * FOREIGN KEY points to `user.id` ->\n            * `ON DELETE` -> `CASCADE`.\n* `messages` table;\n    * `id` ->\n        * `PRIMARY KEY` - `SERIAL`\n    * `content` ->\n        * `VARCHAR`\n    * `created_at` ->\n        * `TIMESTAMP` ->\n            * `DEFAULT_VALUE = now()`\n            * This means it will automatically set this to the current timestamp in the new row.\n    * `chat_id` ->\n        * `FOREIGN KEY` points to `chat.id` ->\n            * `ON DELETE` -> `CASCADE`\n            * This means that if chat that has this id is deleted, this row will be deleted automatically as well. So the message will be deleted immediately after the chat is deleted.\n    * `sender_user_id` ->\n        * `FOREIGN_KEY` points to `user.id`\n            * `ON DELETE` -> `CASCADE`\n            * This means that if user that has this id is deleted, this message will be deleted.\n\n> Notice that having a good dependency gives us an opportunity to benefit from `ON_DELETE` feature of SQL. Otherwise, we need to delete each dependent row manually by hand.\n\n**Installing PostgreSQL on your machine**\n\n***Windows / Mac OS X***\n\nYou can download one-click installer for Windows and Mac OS X. During the installation, you must define a password and keep it somewhere safe.\n\n[https://www.enterprisedb.com/downloads/postgres-postgresql-downloads](Download Installer)\n\n***Ubuntu / Debian***\n\nIf you have Debian package manager on your machine, you can install PostgreSQL in a single line in your Bash terminal;\n\n    $ sudo apt-get install postgresql postgresql-contrib\n\n***Other environments***\n\nCheck [https://www.postgresql.org/download/](PostgreSQL website) for installation instructions on other environments.\n\n**Creating Database, Database User and Tables**\n\n> Make sure you have installed PostgreSQL on your environment first!\n\nWe will use Bash terminal in order to access PostgreSQL using superuser;\n\n    $ su - postgres\n\nYou don't need to execute the previous command if you're using Windows. But you have to open the terminal with Administrator privileges.\n\n    $ psql template1\n\nThen we will see the following PostgreSQL console;\n\nbash```\nWelcome to psql 7.4.16, the PostgreSQL interactive terminal.\n\nType:  \\\\copyright for distribution terms\n       \\\\h for help with SQL commands\n       \\\\? for help on internal slash commands\n       \\\\g or terminate with semicolon to execute query\n       \\\\q to quit\n\ntemplate1\n```\n\nSo we can do the following SQL operations in order to create our new user, database and tables;\n\n* Create user for our database\n\n```sql\n    CREATE DATABASE whatsapp;\n```\n\n* Create database\n\n```sql\n    CREATE USER testuser WITH PASSWORD 'testpassword';\n```\n\n* Give permissions to that user\n\n```sql\n    GRANT ALL PRIVILEGES ON DATABASE whatsapp to testuser;\n```\n\n* Connect database\n\n```sql\n    \\connect whatsapp\n```\n\n* Create `chats` table\n\n```sql\n    CREATE TABLE chats(\n        id SERIAL PRIMARY KEY\n    );\n```\n\n* Create `users` table\n\n```sql\n    CREATE TABLE users(\n        id SERIAL PRIMARY KEY,\n        username VARCHAR (50) UNIQUE NOT NULL,\n        name VARCHAR (50) NOT NULL,\n        password VARCHAR (255) NOT NULL,\n        picture VARCHAR (255) NOT NULL\n    );\n```\n\n* Create `chats_users` table\n\n```sql\n    CREATE TABLE chats_users(\n        chat_id INTEGER NOT NULL REFERENCES chats(id) ON DELETE CASCADE,\n        user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE\n    );\n```\n\n* Create messages table;\n\n```sql\n    CREATE TABLE messages(\n        id SERIAL PRIMARY KEY,\n        content VARCHAR (355) NOT NULL,\n        created_at TIMESTAMP NOT NULL DEFAULT NOW(),\n        chat_id INTEGER NOT NULL REFERENCES chats(id) ON DELETE CASCADE,\n        sender_user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE\n    );\n```\n\n* Give access for those tables\n\n```sql\n    GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO testuser;\n    GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA public TO testuser;\n```\n\n**Installing PostgreSQL on our backend project**\n\nAs we are using PostgreSQL, we will use `node-postgres` as our database client in the backend.\n\nFirst install necessary npm packages using yarn;\n\n\t$ yarn add pg\n\nAnd we will also need TypeScript definitions for better development experience;\n\n\t$ yarn add @types/pg --dev\n\nWe will use `sql` template literals (which is way easier and safer than native API) with [this package](https://github.com/felixfbecker/node-sql-template-strings) which allows you to have SQL highlighting in VSCode with (this extension)[https://marketplace.visualstudio.com/items?itemName=forbeslindesay.vscode-sql-template-literal].\n\n\t$ yarn add sql-template-strings\n\n**Connecting to our database**\n\nWe will use connection pooling to prevent connection leaks and benefit from transactions in our complicated SQL queries. [You can read more about the benefits of connection pooling.](https://node-postgres.com/features/pooling)\n\nFirst we need to create a connection pool using our connection credentials;\n\n[{]: <helper> (diffStep 11.2 files=\"db\" module=\"server\")\n\n#### [__Server__ Step 11.2: Connecting to database](https://github.com/Urigo/WhatsApp-Clone-Server/commit/21f89c2)\n\n##### Changed db.ts\n```diff\n@@ -1,3 +1,5 @@\n+┊ ┊1┊import { Pool } from 'pg';\n+┊ ┊2┊\n ┊1┊3┊export type User = {\n ┊2┊4┊  id: string;\n ┊3┊5┊  name: string;\n```\n```diff\n@@ -20,6 +22,16 @@\n ┊20┊22┊  participants: string[];\n ┊21┊23┊};\n ┊22┊24┊\n+┊  ┊25┊export const dbConfig = {\n+┊  ┊26┊  host: 'localhost',\n+┊  ┊27┊  port: 5432,\n+┊  ┊28┊  user: 'testuser',\n+┊  ┊29┊  password: 'testpassword',\n+┊  ┊30┊  database: 'whatsapp',\n+┊  ┊31┊};\n+┊  ┊32┊\n+┊  ┊33┊export let pool: Pool = new Pool(dbConfig);\n+┊  ┊34┊\n ┊23┊35┊export const users: User[] = [];\n ┊24┊36┊export const messages: Message[] = [];\n ┊25┊37┊export const chats: Chat[] = [];\n```\n\n[}]: #\n\n**Add Database Client to GraphQL Context**\n\nAfter that, we will request a client from this pool on each network request in our GraphQL context. So we need to update our context interface and context builder function.\n\n[{]: <helper> (diffStep 11.3 files=\"context, index\" module=\"server\")\n\n#### [__Server__ Step 11.3: Add Database Client to GraphQL Context](https://github.com/Urigo/WhatsApp-Clone-Server/commit/d7293ef)\n\n##### Changed context.ts\n```diff\n@@ -1,9 +1,11 @@\n ┊ 1┊ 1┊import { PubSub } from 'apollo-server-express';\n ┊ 2┊ 2┊import { User } from './db';\n ┊ 3┊ 3┊import { Response } from 'express';\n+┊  ┊ 4┊import { PoolClient } from 'pg';\n ┊ 4┊ 5┊\n ┊ 5┊ 6┊export type MyContext = {\n ┊ 6┊ 7┊  pubsub: PubSub;\n ┊ 7┊ 8┊  currentUser: User;\n ┊ 8┊ 9┊  res: Response;\n+┊  ┊10┊  db: PoolClient;\n ┊ 9┊11┊};\n```\n\n##### Changed index.ts\n```diff\n@@ -3,14 +3,16 @@\n ┊ 3┊ 3┊import http from 'http';\n ┊ 4┊ 4┊import jwt from 'jsonwebtoken';\n ┊ 5┊ 5┊import { app } from './app';\n-┊ 6┊  ┊import { users } from './db';\n+┊  ┊ 6┊import { pool } from './db';\n ┊ 7┊ 7┊import { origin, port, secret } from './env';\n ┊ 8┊ 8┊import schema from './schema';\n+┊  ┊ 9┊import { MyContext } from './context';\n+┊  ┊10┊import sql from 'sql-template-strings';\n ┊ 9┊11┊\n ┊10┊12┊const pubsub = new PubSub();\n ┊11┊13┊const server = new ApolloServer({\n ┊12┊14┊  schema,\n-┊13┊  ┊  context: (session: any) => {\n+┊  ┊15┊  context: async (session: any) => {\n ┊14┊16┊    // Access the request object\n ┊15┊17┊    let req = session.connection\n ┊16┊18┊      ? session.connection.context.request\n```\n```diff\n@@ -24,12 +26,24 @@\n ┊24┊26┊    let currentUser;\n ┊25┊27┊    if (req.cookies.authToken) {\n ┊26┊28┊      const username = jwt.verify(req.cookies.authToken, secret) as string;\n-┊27┊  ┊      currentUser = username && users.find(u => u.username === username);\n+┊  ┊29┊      if (username) {\n+┊  ┊30┊        const { rows } = await pool.query(\n+┊  ┊31┊          sql`SELECT * FROM users WHERE username = ${username}`\n+┊  ┊32┊        );\n+┊  ┊33┊        currentUser = rows[0];\n+┊  ┊34┊      }\n+┊  ┊35┊    }\n+┊  ┊36┊\n+┊  ┊37┊    let db;\n+┊  ┊38┊\n+┊  ┊39┊    if (!session.connection) {\n+┊  ┊40┊      db = await pool.connect();\n ┊28┊41┊    }\n ┊29┊42┊\n ┊30┊43┊    return {\n ┊31┊44┊      currentUser,\n ┊32┊45┊      pubsub,\n+┊  ┊46┊      db,\n ┊33┊47┊      res: session.res,\n ┊34┊48┊    };\n ┊35┊49┊  },\n```\n```diff\n@@ -41,6 +55,11 @@\n ┊41┊55┊      };\n ┊42┊56┊    },\n ┊43┊57┊  },\n+┊  ┊58┊  formatResponse: (res: any, { context }: { context: MyContext }) => {\n+┊  ┊59┊    context.db.release();\n+┊  ┊60┊\n+┊  ┊61┊    return res;\n+┊  ┊62┊  },\n ┊44┊63┊});\n ┊45┊64┊\n ┊46┊65┊server.applyMiddleware({\n```\n\n[}]: #\n\n> However we need to release that client to the pool after the network connection ends to prevent connection leaks. So, let’s use `formatResponse` to do this operation.\n> We don't need connection pooling for subscriptions, because it can cause the connection open in all websocket connection. That's why, we don't request a new client from the pool if it is a subscription.\n\n**Update entity typings**\n\nWe should update our entity typings according to our new database tables and columns.\n\n[{]: <helper> (diffStep 11.4 files=\"db\" module=\"server\")\n\n#### [__Server__ Step 11.4: Update Entity Types](https://github.com/Urigo/WhatsApp-Clone-Server/commit/3c91fca)\n\n##### Changed db.ts\n```diff\n@@ -11,15 +11,13 @@\n ┊11┊11┊export type Message = {\n ┊12┊12┊  id: string;\n ┊13┊13┊  content: string;\n-┊14┊  ┊  createdAt: Date;\n-┊15┊  ┊  sender: string;\n-┊16┊  ┊  recipient: string;\n+┊  ┊14┊  created_at: Date;\n+┊  ┊15┊  chat_id: string;\n+┊  ┊16┊  sender_user_id: string;\n ┊17┊17┊};\n ┊18┊18┊\n ┊19┊19┊export type Chat = {\n ┊20┊20┊  id: string;\n-┊21┊  ┊  messages: string[];\n-┊22┊  ┊  participants: string[];\n ┊23┊21┊};\n ┊24┊22┊\n ┊25┊23┊export const dbConfig = {\n```\n\n[}]: #\n\n**Add Sample Data**\n\nWe need to update the `resetDb` function to add a sample data to our new relational database instead of in-memory database. But we will call `resetDb` if it is asked by using the environmental variable.\n\n[{]: <helper> (diffStep 11.5 files=\"db\" module=\"server\")\n\n#### [__Server__ Step 11.5: Add Sample Data](https://github.com/Urigo/WhatsApp-Clone-Server/commit/8cb336b)\n\n##### Changed db.ts\n```diff\n@@ -1,4 +1,6 @@\n ┊1┊1┊import { Pool } from 'pg';\n+┊ ┊2┊import sql from 'sql-template-strings';\n+┊ ┊3┊import { resetDb as envResetDb } from './env';\n ┊2┊4┊\n ┊3┊5┊export type User = {\n ┊4┊6┊  id: string;\n```\n```diff\n@@ -34,121 +36,181 @@\n ┊ 34┊ 36┊export const messages: Message[] = [];\n ┊ 35┊ 37┊export const chats: Chat[] = [];\n ┊ 36┊ 38┊\n-┊ 37┊   ┊export const resetDb = () => {\n-┊ 38┊   ┊  users.splice(\n-┊ 39┊   ┊    0,\n-┊ 40┊   ┊    Infinity,\n-┊ 41┊   ┊    ...[\n-┊ 42┊   ┊      {\n-┊ 43┊   ┊        id: '1',\n-┊ 44┊   ┊        name: 'Ray Edwards',\n-┊ 45┊   ┊        username: 'ray',\n-┊ 46┊   ┊        password:\n-┊ 47┊   ┊          '$2a$08$NO9tkFLCoSqX1c5wk3s7z.JfxaVMKA.m7zUDdDwEquo4rvzimQeJm', // 111\n-┊ 48┊   ┊        picture: 'https://randomuser.me/api/portraits/thumb/lego/1.jpg',\n-┊ 49┊   ┊      },\n-┊ 50┊   ┊      {\n-┊ 51┊   ┊        id: '2',\n-┊ 52┊   ┊        name: 'Ethan Gonzalez',\n-┊ 53┊   ┊        username: 'ethan',\n-┊ 54┊   ┊        password:\n-┊ 55┊   ┊          '$2a$08$xE4FuCi/ifxjL2S8CzKAmuKLwv18ktksSN.F3XYEnpmcKtpbpeZgO', // 222\n-┊ 56┊   ┊        picture: 'https://randomuser.me/api/portraits/thumb/men/1.jpg',\n-┊ 57┊   ┊      },\n-┊ 58┊   ┊      {\n-┊ 59┊   ┊        id: '3',\n-┊ 60┊   ┊        name: 'Bryan Wallace',\n-┊ 61┊   ┊        username: 'bryan',\n-┊ 62┊   ┊        password:\n-┊ 63┊   ┊          '$2a$08$UHgH7J8G6z1mGQn2qx2kdeWv0jvgHItyAsL9hpEUI3KJmhVW5Q1d.', // 333\n-┊ 64┊   ┊        picture: 'https://randomuser.me/api/portraits/thumb/men/2.jpg',\n-┊ 65┊   ┊      },\n-┊ 66┊   ┊      {\n-┊ 67┊   ┊        id: '4',\n-┊ 68┊   ┊        name: 'Avery Stewart',\n-┊ 69┊   ┊        username: 'avery',\n-┊ 70┊   ┊        password:\n-┊ 71┊   ┊          '$2a$08$wR1k5Q3T9FC7fUgB7Gdb9Os/GV7dGBBf4PLlWT7HERMFhmFDt47xi', // 444\n-┊ 72┊   ┊        picture: 'https://randomuser.me/api/portraits/thumb/women/1.jpg',\n-┊ 73┊   ┊      },\n-┊ 74┊   ┊      {\n-┊ 75┊   ┊        id: '5',\n-┊ 76┊   ┊        name: 'Katie Peterson',\n-┊ 77┊   ┊        username: 'katie',\n-┊ 78┊   ┊        password:\n-┊ 79┊   ┊          '$2a$08$6.mbXqsDX82ZZ7q5d8Osb..JrGSsNp4R3IKj7mxgF6YGT0OmMw242', // 555\n-┊ 80┊   ┊        picture: 'https://randomuser.me/api/portraits/thumb/women/2.jpg',\n-┊ 81┊   ┊      },\n-┊ 82┊   ┊    ]\n+┊   ┊ 39┊export const resetDb = async () => {\n+┊   ┊ 40┊  await pool.query(sql`DELETE FROM users`);\n+┊   ┊ 41┊\n+┊   ┊ 42┊  const sampleUsers = [\n+┊   ┊ 43┊    {\n+┊   ┊ 44┊      id: '1',\n+┊   ┊ 45┊      name: 'Ray Edwards',\n+┊   ┊ 46┊      username: 'ray',\n+┊   ┊ 47┊      password: '$2a$08$NO9tkFLCoSqX1c5wk3s7z.JfxaVMKA.m7zUDdDwEquo4rvzimQeJm', // 111\n+┊   ┊ 48┊      picture: 'https://randomuser.me/api/portraits/thumb/lego/1.jpg',\n+┊   ┊ 49┊    },\n+┊   ┊ 50┊    {\n+┊   ┊ 51┊      id: '2',\n+┊   ┊ 52┊      name: 'Ethan Gonzalez',\n+┊   ┊ 53┊      username: 'ethan',\n+┊   ┊ 54┊      password: '$2a$08$xE4FuCi/ifxjL2S8CzKAmuKLwv18ktksSN.F3XYEnpmcKtpbpeZgO', // 222\n+┊   ┊ 55┊      picture: 'https://randomuser.me/api/portraits/thumb/men/1.jpg',\n+┊   ┊ 56┊    },\n+┊   ┊ 57┊    {\n+┊   ┊ 58┊      id: '3',\n+┊   ┊ 59┊      name: 'Bryan Wallace',\n+┊   ┊ 60┊      username: 'bryan',\n+┊   ┊ 61┊      password: '$2a$08$UHgH7J8G6z1mGQn2qx2kdeWv0jvgHItyAsL9hpEUI3KJmhVW5Q1d.', // 333\n+┊   ┊ 62┊      picture: 'https://randomuser.me/api/portraits/thumb/men/2.jpg',\n+┊   ┊ 63┊    },\n+┊   ┊ 64┊    {\n+┊   ┊ 65┊      id: '4',\n+┊   ┊ 66┊      name: 'Avery Stewart',\n+┊   ┊ 67┊      username: 'avery',\n+┊   ┊ 68┊      password: '$2a$08$wR1k5Q3T9FC7fUgB7Gdb9Os/GV7dGBBf4PLlWT7HERMFhmFDt47xi', // 444\n+┊   ┊ 69┊      picture: 'https://randomuser.me/api/portraits/thumb/women/1.jpg',\n+┊   ┊ 70┊    },\n+┊   ┊ 71┊    {\n+┊   ┊ 72┊      id: '5',\n+┊   ┊ 73┊      name: 'Katie Peterson',\n+┊   ┊ 74┊      username: 'katie',\n+┊   ┊ 75┊      password: '$2a$08$6.mbXqsDX82ZZ7q5d8Osb..JrGSsNp4R3IKj7mxgF6YGT0OmMw242', // 555\n+┊   ┊ 76┊      picture: 'https://randomuser.me/api/portraits/thumb/women/2.jpg',\n+┊   ┊ 77┊    },\n+┊   ┊ 78┊  ];\n+┊   ┊ 79┊\n+┊   ┊ 80┊  for (const sampleUser of sampleUsers) {\n+┊   ┊ 81┊    await pool.query(sql`\n+┊   ┊ 82┊      INSERT INTO users(id, name, username, password, picture)\n+┊   ┊ 83┊      VALUES(${sampleUser.id}, ${sampleUser.name}, ${sampleUser.username}, ${\n+┊   ┊ 84┊      sampleUser.password\n+┊   ┊ 85┊    }, ${sampleUser.picture})\n+┊   ┊ 86┊    `);\n+┊   ┊ 87┊  }\n+┊   ┊ 88┊\n+┊   ┊ 89┊  await pool.query(\n+┊   ┊ 90┊    sql`SELECT setval('users_id_seq', (SELECT max(id) FROM users))`\n ┊ 83┊ 91┊  );\n ┊ 84┊ 92┊\n-┊ 85┊   ┊  messages.splice(\n-┊ 86┊   ┊    0,\n-┊ 87┊   ┊    Infinity,\n-┊ 88┊   ┊    ...[\n-┊ 89┊   ┊      {\n-┊ 90┊   ┊        id: '1',\n-┊ 91┊   ┊        content: 'You on your way?',\n-┊ 92┊   ┊        createdAt: new Date(new Date('1-1-2019').getTime() - 60 * 1000 * 1000),\n-┊ 93┊   ┊        sender: '1',\n-┊ 94┊   ┊        recipient: '2',\n-┊ 95┊   ┊      },\n-┊ 96┊   ┊      {\n-┊ 97┊   ┊        id: '2',\n-┊ 98┊   ┊        content: \"Hey, it's me\",\n-┊ 99┊   ┊        createdAt: new Date(\n-┊100┊   ┊          new Date('1-1-2019').getTime() - 2 * 60 * 1000 * 1000\n-┊101┊   ┊        ),\n-┊102┊   ┊        sender: '1',\n-┊103┊   ┊        recipient: '3',\n-┊104┊   ┊      },\n-┊105┊   ┊      {\n-┊106┊   ┊        id: '3',\n-┊107┊   ┊        content: 'I should buy a boat',\n-┊108┊   ┊        createdAt: new Date(\n-┊109┊   ┊          new Date('1-1-2019').getTime() - 24 * 60 * 1000 * 1000\n-┊110┊   ┊        ),\n-┊111┊   ┊        sender: '1',\n-┊112┊   ┊        recipient: '4',\n-┊113┊   ┊      },\n-┊114┊   ┊      {\n-┊115┊   ┊        id: '4',\n-┊116┊   ┊        content: 'This is wicked good ice cream.',\n-┊117┊   ┊        createdAt: new Date(\n-┊118┊   ┊          new Date('1-1-2019').getTime() - 14 * 24 * 60 * 1000 * 1000\n-┊119┊   ┊        ),\n-┊120┊   ┊        sender: '1',\n-┊121┊   ┊        recipient: '5',\n-┊122┊   ┊      },\n-┊123┊   ┊    ]\n+┊   ┊ 93┊  await pool.query(sql`DELETE FROM chats`);\n+┊   ┊ 94┊\n+┊   ┊ 95┊  const sampleChats = [\n+┊   ┊ 96┊    {\n+┊   ┊ 97┊      id: '1',\n+┊   ┊ 98┊    },\n+┊   ┊ 99┊    {\n+┊   ┊100┊      id: '2',\n+┊   ┊101┊    },\n+┊   ┊102┊    {\n+┊   ┊103┊      id: '3',\n+┊   ┊104┊    },\n+┊   ┊105┊    {\n+┊   ┊106┊      id: '4',\n+┊   ┊107┊    },\n+┊   ┊108┊  ];\n+┊   ┊109┊\n+┊   ┊110┊  for (const sampleChat of sampleChats) {\n+┊   ┊111┊    await pool.query(sql`\n+┊   ┊112┊      INSERT INTO chats(id)\n+┊   ┊113┊      VALUES(${sampleChat.id})\n+┊   ┊114┊    `);\n+┊   ┊115┊  }\n+┊   ┊116┊\n+┊   ┊117┊  await pool.query(\n+┊   ┊118┊    sql`SELECT setval('chats_id_seq', (SELECT max(id) FROM chats))`\n ┊124┊119┊  );\n ┊125┊120┊\n-┊126┊   ┊  chats.splice(\n-┊127┊   ┊    0,\n-┊128┊   ┊    Infinity,\n-┊129┊   ┊    ...[\n-┊130┊   ┊      {\n-┊131┊   ┊        id: '1',\n-┊132┊   ┊        participants: ['1', '2'],\n-┊133┊   ┊        messages: ['1'],\n-┊134┊   ┊      },\n-┊135┊   ┊      {\n-┊136┊   ┊        id: '2',\n-┊137┊   ┊        participants: ['1', '3'],\n-┊138┊   ┊        messages: ['2'],\n-┊139┊   ┊      },\n-┊140┊   ┊      {\n-┊141┊   ┊        id: '3',\n-┊142┊   ┊        participants: ['1', '4'],\n-┊143┊   ┊        messages: ['3'],\n-┊144┊   ┊      },\n-┊145┊   ┊      {\n-┊146┊   ┊        id: '4',\n-┊147┊   ┊        participants: ['1', '5'],\n-┊148┊   ┊        messages: ['4'],\n-┊149┊   ┊      },\n-┊150┊   ┊    ]\n+┊   ┊121┊  await pool.query(sql`DELETE FROM chats_users`);\n+┊   ┊122┊\n+┊   ┊123┊  const sampleChatsUsers = [\n+┊   ┊124┊    {\n+┊   ┊125┊      chat_id: '1',\n+┊   ┊126┊      user_id: '1',\n+┊   ┊127┊    },\n+┊   ┊128┊    {\n+┊   ┊129┊      chat_id: '1',\n+┊   ┊130┊      user_id: '2',\n+┊   ┊131┊    },\n+┊   ┊132┊    {\n+┊   ┊133┊      chat_id: '2',\n+┊   ┊134┊      user_id: '1',\n+┊   ┊135┊    },\n+┊   ┊136┊    {\n+┊   ┊137┊      chat_id: '2',\n+┊   ┊138┊      user_id: '3',\n+┊   ┊139┊    },\n+┊   ┊140┊    {\n+┊   ┊141┊      chat_id: '3',\n+┊   ┊142┊      user_id: '1',\n+┊   ┊143┊    },\n+┊   ┊144┊    {\n+┊   ┊145┊      chat_id: '3',\n+┊   ┊146┊      user_id: '4',\n+┊   ┊147┊    },\n+┊   ┊148┊    {\n+┊   ┊149┊      chat_id: '4',\n+┊   ┊150┊      user_id: '1',\n+┊   ┊151┊    },\n+┊   ┊152┊    {\n+┊   ┊153┊      chat_id: '4',\n+┊   ┊154┊      user_id: '5',\n+┊   ┊155┊    },\n+┊   ┊156┊  ];\n+┊   ┊157┊\n+┊   ┊158┊  for (const sampleChatUser of sampleChatsUsers) {\n+┊   ┊159┊    await pool.query(sql`\n+┊   ┊160┊      INSERT INTO chats_users(chat_id, user_id)\n+┊   ┊161┊      VALUES(${sampleChatUser.chat_id}, ${sampleChatUser.user_id})\n+┊   ┊162┊    `);\n+┊   ┊163┊  }\n+┊   ┊164┊\n+┊   ┊165┊  await pool.query(sql`DELETE FROM messages`);\n+┊   ┊166┊\n+┊   ┊167┊  const baseTime = new Date('1 Jan 2019 GMT').getTime();\n+┊   ┊168┊\n+┊   ┊169┊  const sampleMessages = [\n+┊   ┊170┊    {\n+┊   ┊171┊      id: '1',\n+┊   ┊172┊      content: 'You on your way?',\n+┊   ┊173┊      created_at: new Date(baseTime - 60 * 1000 * 1000),\n+┊   ┊174┊      chat_id: '1',\n+┊   ┊175┊      sender_user_id: '1',\n+┊   ┊176┊    },\n+┊   ┊177┊    {\n+┊   ┊178┊      id: '2',\n+┊   ┊179┊      content: \"Hey, it's me\",\n+┊   ┊180┊      created_at: new Date(baseTime - 2 * 60 * 1000 * 1000),\n+┊   ┊181┊      chat_id: '2',\n+┊   ┊182┊      sender_user_id: '1',\n+┊   ┊183┊    },\n+┊   ┊184┊    {\n+┊   ┊185┊      id: '3',\n+┊   ┊186┊      content: 'I should buy a boat',\n+┊   ┊187┊      created_at: new Date(baseTime - 24 * 60 * 1000 * 1000),\n+┊   ┊188┊      chat_id: '3',\n+┊   ┊189┊      sender_user_id: '1',\n+┊   ┊190┊    },\n+┊   ┊191┊    {\n+┊   ┊192┊      id: '4',\n+┊   ┊193┊      content: 'This is wicked good ice cream.',\n+┊   ┊194┊      created_at: new Date(baseTime - 14 * 24 * 60 * 1000 * 1000),\n+┊   ┊195┊      chat_id: '4',\n+┊   ┊196┊      sender_user_id: '1',\n+┊   ┊197┊    },\n+┊   ┊198┊  ];\n+┊   ┊199┊\n+┊   ┊200┊  for (const sampleMessage of sampleMessages) {\n+┊   ┊201┊    await pool.query(sql`\n+┊   ┊202┊      INSERT INTO messages(id, content, created_at, chat_id, sender_user_id)\n+┊   ┊203┊      VALUES(${sampleMessage.id}, ${sampleMessage.content}, ${\n+┊   ┊204┊      sampleMessage.created_at\n+┊   ┊205┊    }, ${sampleMessage.chat_id}, ${sampleMessage.sender_user_id})\n+┊   ┊206┊    `);\n+┊   ┊207┊  }\n+┊   ┊208┊\n+┊   ┊209┊  await pool.query(\n+┊   ┊210┊    sql`SELECT setval('messages_id_seq', (SELECT max(id) FROM messages))`\n ┊151┊211┊  );\n ┊152┊212┊};\n ┊153┊213┊\n-┊154┊   ┊resetDb();\n+┊   ┊214┊if (envResetDb) {\n+┊   ┊215┊  resetDb();\n+┊   ┊216┊}\n```\n\n[}]: #\n\n> When you update tables with your own ID values, you have to update `SEQUENCE`; because PostgreSQL calculates the next ID value using `SEQUENCE`s.\n\n**Updating Resolvers**\n\nWe will benefit from transactions for complicated SQL queries in mutation. Transactions will help us to rollback our changes if there is an exception in the middle of our operations.\n\n[{]: <helper> (diffStep 11.6 files=\"resolvers\" module=\"server\")\n\n#### [__Server__ Step 11.6: Updating Resolvers with SQL](https://github.com/Urigo/WhatsApp-Clone-Server/commit/9fe066e)\n\n##### Changed schema&#x2F;resolvers.ts\n```diff\n@@ -1,72 +1,104 @@\n ┊  1┊  1┊import { withFilter } from 'apollo-server-express';\n ┊  2┊  2┊import { GraphQLDateTime } from 'graphql-iso-date';\n-┊  3┊   ┊import { User, Message, Chat, chats, messages, users } from '../db';\n+┊   ┊  3┊import { Message, Chat, pool } from '../db';\n ┊  4┊  4┊import { Resolvers } from '../types/graphql';\n ┊  5┊  5┊import { secret, expiration } from '../env';\n ┊  6┊  6┊import bcrypt from 'bcrypt';\n ┊  7┊  7┊import jwt from 'jsonwebtoken';\n ┊  8┊  8┊import { validateLength, validatePassword } from '../validators';\n+┊   ┊  9┊import sql from 'sql-template-strings';\n ┊  9┊ 10┊\n ┊ 10┊ 11┊const resolvers: Resolvers = {\n ┊ 11┊ 12┊  Date: GraphQLDateTime,\n ┊ 12┊ 13┊\n ┊ 13┊ 14┊  Message: {\n-┊ 14┊   ┊    chat(message) {\n-┊ 15┊   ┊      return chats.find(c => c.messages.some(m => m === message.id)) || null;\n+┊   ┊ 15┊    createdAt(message) {\n+┊   ┊ 16┊      return new Date(message.created_at);\n ┊ 16┊ 17┊    },\n ┊ 17┊ 18┊\n-┊ 18┊   ┊    sender(message) {\n-┊ 19┊   ┊      return users.find(u => u.id === message.sender) || null;\n+┊   ┊ 19┊    async chat(message, args, { db }) {\n+┊   ┊ 20┊      const { rows } = await db.query(sql`\n+┊   ┊ 21┊        SELECT * FROM chats WHERE id = ${message.chat_id}\n+┊   ┊ 22┊      `);\n+┊   ┊ 23┊      return rows[0] || null;\n ┊ 20┊ 24┊    },\n ┊ 21┊ 25┊\n-┊ 22┊   ┊    recipient(message) {\n-┊ 23┊   ┊      return users.find(u => u.id === message.recipient) || null;\n+┊   ┊ 26┊    async sender(message, args, { db }) {\n+┊   ┊ 27┊      const { rows } = await db.query(sql`\n+┊   ┊ 28┊        SELECT * FROM users WHERE id = ${message.sender_user_id}\n+┊   ┊ 29┊      `);\n+┊   ┊ 30┊      return rows[0] || null;\n+┊   ┊ 31┊    },\n+┊   ┊ 32┊\n+┊   ┊ 33┊    async recipient(message, args, { db }) {\n+┊   ┊ 34┊      const { rows } = await db.query(sql`\n+┊   ┊ 35┊        SELECT users.* FROM users, chats_users\n+┊   ┊ 36┊        WHERE chats_users.user_id != ${message.sender_user_id}\n+┊   ┊ 37┊        AND chats_users.chat_id = ${message.chat_id}\n+┊   ┊ 38┊      `);\n+┊   ┊ 39┊      return rows[0] || null;\n ┊ 24┊ 40┊    },\n ┊ 25┊ 41┊\n ┊ 26┊ 42┊    isMine(message, args, { currentUser }) {\n-┊ 27┊   ┊      return message.sender === currentUser.id;\n+┊   ┊ 43┊      return message.sender_user_id === currentUser.id;\n ┊ 28┊ 44┊    },\n ┊ 29┊ 45┊  },\n ┊ 30┊ 46┊\n ┊ 31┊ 47┊  Chat: {\n-┊ 32┊   ┊    name(chat, args, { currentUser }) {\n+┊   ┊ 48┊    async name(chat, args, { currentUser, db }) {\n ┊ 33┊ 49┊      if (!currentUser) return null;\n ┊ 34┊ 50┊\n-┊ 35┊   ┊      const participantId = chat.participants.find(p => p !== currentUser.id);\n+┊   ┊ 51┊      const { rows } = await db.query(sql`\n+┊   ┊ 52┊        SELECT users.* FROM users, chats_users\n+┊   ┊ 53┊        WHERE users.id != ${currentUser.id}\n+┊   ┊ 54┊        AND users.id = chats_users.user_id\n+┊   ┊ 55┊        AND chats_users.chat_id = ${chat.id}`);\n ┊ 36┊ 56┊\n-┊ 37┊   ┊      if (!participantId) return null;\n-┊ 38┊   ┊\n-┊ 39┊   ┊      const participant = users.find(u => u.id === participantId);\n+┊   ┊ 57┊      const participant = rows[0];\n ┊ 40┊ 58┊\n ┊ 41┊ 59┊      return participant ? participant.name : null;\n ┊ 42┊ 60┊    },\n ┊ 43┊ 61┊\n-┊ 44┊   ┊    picture(chat, args, { currentUser }) {\n+┊   ┊ 62┊    async picture(chat, args, { currentUser, db }) {\n ┊ 45┊ 63┊      if (!currentUser) return null;\n ┊ 46┊ 64┊\n-┊ 47┊   ┊      const participantId = chat.participants.find(p => p !== currentUser.id);\n-┊ 48┊   ┊\n-┊ 49┊   ┊      if (!participantId) return null;\n+┊   ┊ 65┊      const { rows } = await db.query(sql`\n+┊   ┊ 66┊        SELECT users.* FROM users, chats_users\n+┊   ┊ 67┊        WHERE users.id != ${currentUser.id}\n+┊   ┊ 68┊        AND users.id = chats_users.user_id\n+┊   ┊ 69┊        AND chats_users.chat_id = ${chat.id}`);\n ┊ 50┊ 70┊\n-┊ 51┊   ┊      const participant = users.find(u => u.id === participantId);\n+┊   ┊ 71┊      const participant = rows[0];\n ┊ 52┊ 72┊\n ┊ 53┊ 73┊      return participant ? participant.picture : null;\n ┊ 54┊ 74┊    },\n ┊ 55┊ 75┊\n-┊ 56┊   ┊    messages(chat) {\n-┊ 57┊   ┊      return messages.filter(m => chat.messages.includes(m.id));\n+┊   ┊ 76┊    async messages(chat, args, { db }) {\n+┊   ┊ 77┊      const { rows } = await db.query(\n+┊   ┊ 78┊        sql`SELECT * FROM messages WHERE chat_id = ${chat.id}`\n+┊   ┊ 79┊      );\n+┊   ┊ 80┊\n+┊   ┊ 81┊      return rows;\n ┊ 58┊ 82┊    },\n ┊ 59┊ 83┊\n-┊ 60┊   ┊    lastMessage(chat) {\n-┊ 61┊   ┊      const lastMessage = chat.messages[chat.messages.length - 1];\n+┊   ┊ 84┊    async lastMessage(chat, args, { db }) {\n+┊   ┊ 85┊      const { rows } = await db.query(sql`\n+┊   ┊ 86┊        SELECT * FROM messages\n+┊   ┊ 87┊        WHERE chat_id = ${chat.id}\n+┊   ┊ 88┊        ORDER BY created_at DESC\n+┊   ┊ 89┊        LIMIT 1`);\n ┊ 62┊ 90┊\n-┊ 63┊   ┊      return messages.find(m => m.id === lastMessage) || null;\n+┊   ┊ 91┊      return rows[0];\n ┊ 64┊ 92┊    },\n ┊ 65┊ 93┊\n-┊ 66┊   ┊    participants(chat) {\n-┊ 67┊   ┊      return chat.participants\n-┊ 68┊   ┊        .map(p => users.find(u => u.id === p))\n-┊ 69┊   ┊        .filter(Boolean) as User[];\n+┊   ┊ 94┊    async participants(chat, args, { db }) {\n+┊   ┊ 95┊      const { rows } = await db.query(sql`\n+┊   ┊ 96┊        SELECT users.* FROM users, chats_users\n+┊   ┊ 97┊        WHERE chats_users.chat_id = ${chat.id}\n+┊   ┊ 98┊        AND chats_users.user_id = users.id\n+┊   ┊ 99┊      `);\n+┊   ┊100┊\n+┊   ┊101┊      return rows;\n ┊ 70┊102┊    },\n ┊ 71┊103┊  },\n ┊ 72┊104┊\n```\n```diff\n@@ -75,32 +107,48 @@\n ┊ 75┊107┊      return currentUser || null;\n ┊ 76┊108┊    },\n ┊ 77┊109┊\n-┊ 78┊   ┊    chats(root, args, { currentUser }) {\n+┊   ┊110┊    async chats(root, args, { currentUser, db }) {\n ┊ 79┊111┊      if (!currentUser) return [];\n ┊ 80┊112┊\n-┊ 81┊   ┊      return chats.filter(c => c.participants.includes(currentUser.id));\n+┊   ┊113┊      const { rows } = await db.query(sql`\n+┊   ┊114┊        SELECT chats.* FROM chats, chats_users\n+┊   ┊115┊        WHERE chats.id = chats_users.chat_id\n+┊   ┊116┊        AND chats_users.user_id = ${currentUser.id}\n+┊   ┊117┊      `);\n+┊   ┊118┊\n+┊   ┊119┊      return rows;\n ┊ 82┊120┊    },\n ┊ 83┊121┊\n-┊ 84┊   ┊    chat(root, { chatId }, { currentUser }) {\n+┊   ┊122┊    async chat(root, { chatId }, { currentUser, db }) {\n ┊ 85┊123┊      if (!currentUser) return null;\n ┊ 86┊124┊\n-┊ 87┊   ┊      const chat = chats.find(c => c.id === chatId);\n+┊   ┊125┊      const { rows } = await db.query(sql`\n+┊   ┊126┊        SELECT chats.* FROM chats, chats_users\n+┊   ┊127┊        WHERE chats_users.chat_id = ${chatId}\n+┊   ┊128┊        AND chats.id = chats_users.chat_id\n+┊   ┊129┊        AND chats_users.user_id = ${currentUser.id}\n+┊   ┊130┊      `);\n ┊ 88┊131┊\n-┊ 89┊   ┊      if (!chat) return null;\n-┊ 90┊   ┊\n-┊ 91┊   ┊      return chat.participants.includes(currentUser.id) ? chat : null;\n+┊   ┊132┊      return rows[0] ? rows[0] : null;\n ┊ 92┊133┊    },\n ┊ 93┊134┊\n-┊ 94┊   ┊    users(root, args, { currentUser }) {\n+┊   ┊135┊    async users(root, args, { currentUser, db }) {\n ┊ 95┊136┊      if (!currentUser) return [];\n ┊ 96┊137┊\n-┊ 97┊   ┊      return users.filter(u => u.id !== currentUser.id);\n+┊   ┊138┊      const { rows } = await db.query(sql`\n+┊   ┊139┊        SELECT * FROM users WHERE users.id != ${currentUser.id}\n+┊   ┊140┊      `);\n+┊   ┊141┊\n+┊   ┊142┊      return rows;\n ┊ 98┊143┊    },\n ┊ 99┊144┊  },\n ┊100┊145┊\n ┊101┊146┊  Mutation: {\n-┊102┊   ┊    signIn(root, { username, password }, { res }) {\n-┊103┊   ┊      const user = users.find(u => u.username === username);\n+┊   ┊147┊    async signIn(root, { username, password }, { db, res }) {\n+┊   ┊148┊      const { rows } = await db.query(\n+┊   ┊149┊        sql`SELECT * FROM users WHERE username = ${username}`\n+┊   ┊150┊      );\n+┊   ┊151┊      const user = rows[0];\n ┊104┊152┊\n ┊105┊153┊      if (!user) {\n ┊106┊154┊        throw new Error('user not found');\n```\n```diff\n@@ -119,7 +167,7 @@\n ┊119┊167┊      return user;\n ┊120┊168┊    },\n ┊121┊169┊\n-┊122┊   ┊    signUp(root, { name, username, password, passwordConfirm }) {\n+┊   ┊170┊    async signUp(root, { name, username, password, passwordConfirm }, { db }) {\n ┊123┊171┊      validateLength('req.name', name, 3, 50);\n ┊124┊172┊      validateLength('req.username', name, 3, 18);\n ┊125┊173┊      validatePassword('req.password', password);\n```\n```diff\n@@ -128,115 +176,131 @@\n ┊128┊176┊        throw Error(\"req.password and req.passwordConfirm don't match\");\n ┊129┊177┊      }\n ┊130┊178┊\n-┊131┊   ┊      if (users.some(u => u.username === username)) {\n+┊   ┊179┊      const existingUserQuery = await db.query(\n+┊   ┊180┊        sql`SELECT * FROM users WHERE username = ${username}`\n+┊   ┊181┊      );\n+┊   ┊182┊      if (existingUserQuery.rows[0]) {\n ┊132┊183┊        throw Error('username already exists');\n ┊133┊184┊      }\n ┊134┊185┊\n ┊135┊186┊      const passwordHash = bcrypt.hashSync(password, bcrypt.genSaltSync(8));\n ┊136┊187┊\n-┊137┊   ┊      const user: User = {\n-┊138┊   ┊        id: String(users.length + 1),\n-┊139┊   ┊        password: passwordHash,\n-┊140┊   ┊        picture: '',\n-┊141┊   ┊        username,\n-┊142┊   ┊        name,\n-┊143┊   ┊      };\n+┊   ┊188┊      const createdUserQuery = await db.query(sql`\n+┊   ┊189┊        INSERT INTO users(password, picture, username, name)\n+┊   ┊190┊        VALUES(${passwordHash}, '', ${username}, ${name})\n+┊   ┊191┊        RETURNING *\n+┊   ┊192┊      `);\n ┊144┊193┊\n-┊145┊   ┊      users.push(user);\n+┊   ┊194┊      const user = createdUserQuery.rows[0];\n ┊146┊195┊\n ┊147┊196┊      return user;\n ┊148┊197┊    },\n ┊149┊198┊\n-┊150┊   ┊    addMessage(root, { chatId, content }, { currentUser, pubsub }) {\n+┊   ┊199┊    async addMessage(root, { chatId, content }, { currentUser, pubsub, db }) {\n ┊151┊200┊      if (!currentUser) return null;\n ┊152┊201┊\n-┊153┊   ┊      const chatIndex = chats.findIndex(c => c.id === chatId);\n-┊154┊   ┊\n-┊155┊   ┊      if (chatIndex === -1) return null;\n-┊156┊   ┊\n-┊157┊   ┊      const chat = chats[chatIndex];\n-┊158┊   ┊\n-┊159┊   ┊      if (!chat.participants.includes(currentUser.id)) return null;\n-┊160┊   ┊\n-┊161┊   ┊      const recentMessage = messages[messages.length - 1];\n-┊162┊   ┊      const messageId = String(Number(recentMessage.id) + 1);\n-┊163┊   ┊      const message: Message = {\n-┊164┊   ┊        id: messageId,\n-┊165┊   ┊        createdAt: new Date(),\n-┊166┊   ┊        sender: currentUser.id,\n-┊167┊   ┊        recipient: chat.participants.find(p => p !== currentUser.id) as string,\n-┊168┊   ┊        content,\n-┊169┊   ┊      };\n+┊   ┊202┊      const { rows } = await db.query(sql`\n+┊   ┊203┊        INSERT INTO messages(chat_id, sender_user_id, content)\n+┊   ┊204┊        VALUES(${chatId}, ${currentUser.id}, ${content})\n+┊   ┊205┊        RETURNING *\n+┊   ┊206┊      `);\n ┊170┊207┊\n-┊171┊   ┊      messages.push(message);\n-┊172┊   ┊      chat.messages.push(messageId);\n-┊173┊   ┊      // The chat will appear at the top of the ChatsList component\n-┊174┊   ┊      chats.splice(chatIndex, 1);\n-┊175┊   ┊      chats.unshift(chat);\n+┊   ┊208┊      const messageAdded = rows[0];\n ┊176┊209┊\n ┊177┊210┊      pubsub.publish('messageAdded', {\n-┊178┊   ┊        messageAdded: message,\n+┊   ┊211┊        messageAdded,\n ┊179┊212┊      });\n ┊180┊213┊\n-┊181┊   ┊      return message;\n+┊   ┊214┊      return messageAdded;\n ┊182┊215┊    },\n ┊183┊216┊\n-┊184┊   ┊    addChat(root, { recipientId }, { currentUser, pubsub }) {\n+┊   ┊217┊    async addChat(root, { recipientId }, { currentUser, pubsub, db }) {\n ┊185┊218┊      if (!currentUser) return null;\n-┊186┊   ┊      if (!users.some(u => u.id === recipientId)) return null;\n ┊187┊219┊\n-┊188┊   ┊      let chat = chats.find(\n-┊189┊   ┊        c =>\n-┊190┊   ┊          c.participants.includes(currentUser.id) &&\n-┊191┊   ┊          c.participants.includes(recipientId)\n-┊192┊   ┊      );\n+┊   ┊220┊      const { rows } = await db.query(sql`\n+┊   ┊221┊        SELECT chats.* FROM chats, (SELECT * FROM chats_users WHERE user_id = ${\n+┊   ┊222┊          currentUser.id\n+┊   ┊223┊        }) AS chats_of_current_user, chats_users\n+┊   ┊224┊        WHERE chats_users.chat_id = chats_of_current_user.chat_id\n+┊   ┊225┊        AND chats.id = chats_users.chat_id\n+┊   ┊226┊        AND chats_users.user_id = ${recipientId}\n+┊   ┊227┊      `);\n+┊   ┊228┊\n+┊   ┊229┊      // If there is already a chat between these two users, return it\n+┊   ┊230┊      if (rows[0]) {\n+┊   ┊231┊        return rows[0];\n+┊   ┊232┊      }\n ┊193┊233┊\n-┊194┊   ┊      if (chat) return chat;\n+┊   ┊234┊      try {\n+┊   ┊235┊        await db.query('BEGIN');\n ┊195┊236┊\n-┊196┊   ┊      const chatsIds = chats.map(c => Number(c.id));\n+┊   ┊237┊        const { rows } = await db.query(sql`\n+┊   ┊238┊          INSERT INTO chats\n+┊   ┊239┊          DEFAULT VALUES\n+┊   ┊240┊          RETURNING *\n+┊   ┊241┊        `);\n ┊197┊242┊\n-┊198┊   ┊      chat = {\n-┊199┊   ┊        id: String(Math.max(...chatsIds) + 1),\n-┊200┊   ┊        participants: [currentUser.id, recipientId],\n-┊201┊   ┊        messages: [],\n-┊202┊   ┊      };\n+┊   ┊243┊        const chatAdded = rows[0];\n ┊203┊244┊\n-┊204┊   ┊      chats.push(chat);\n+┊   ┊245┊        await db.query(sql`\n+┊   ┊246┊          INSERT INTO chats_users(chat_id, user_id)\n+┊   ┊247┊          VALUES(${chatAdded.id}, ${currentUser.id})\n+┊   ┊248┊        `);\n ┊205┊249┊\n-┊206┊   ┊      pubsub.publish('chatAdded', {\n-┊207┊   ┊        chatAdded: chat,\n-┊208┊   ┊      });\n+┊   ┊250┊        await db.query(sql`\n+┊   ┊251┊          INSERT INTO chats_users(chat_id, user_id)\n+┊   ┊252┊          VALUES(${chatAdded.id}, ${recipientId})\n+┊   ┊253┊        `);\n ┊209┊254┊\n-┊210┊   ┊      return chat;\n-┊211┊   ┊    },\n+┊   ┊255┊        await db.query('COMMIT');\n ┊212┊256┊\n-┊213┊   ┊    removeChat(root, { chatId }, { currentUser, pubsub }) {\n-┊214┊   ┊      if (!currentUser) return null;\n+┊   ┊257┊        pubsub.publish('chatAdded', {\n+┊   ┊258┊          chatAdded,\n+┊   ┊259┊        });\n ┊215┊260┊\n-┊216┊   ┊      const chatIndex = chats.findIndex(c => c.id === chatId);\n+┊   ┊261┊        return chatAdded;\n+┊   ┊262┊      } catch (e) {\n+┊   ┊263┊        await db.query('ROLLBACK');\n+┊   ┊264┊        throw e;\n+┊   ┊265┊      }\n+┊   ┊266┊    },\n ┊217┊267┊\n-┊218┊   ┊      if (chatIndex === -1) return null;\n+┊   ┊268┊    async removeChat(root, { chatId }, { currentUser, pubsub, db }) {\n+┊   ┊269┊      if (!currentUser) return null;\n ┊219┊270┊\n-┊220┊   ┊      const chat = chats[chatIndex];\n+┊   ┊271┊      try {\n+┊   ┊272┊        await db.query('BEGIN');\n ┊221┊273┊\n-┊222┊   ┊      if (!chat.participants.some(p => p === currentUser.id)) return null;\n+┊   ┊274┊        const { rows } = await db.query(sql`\n+┊   ┊275┊          SELECT chats.* FROM chats, chats_users\n+┊   ┊276┊          WHERE id = ${chatId}\n+┊   ┊277┊          AND chats.id = chats_users.chat_id\n+┊   ┊278┊          AND chats_users.user_id = ${currentUser.id}\n+┊   ┊279┊        `);\n ┊223┊280┊\n-┊224┊   ┊      chat.messages.forEach(chatMessage => {\n-┊225┊   ┊        const chatMessageIndex = messages.findIndex(m => m.id === chatMessage);\n+┊   ┊281┊        const chat = rows[0];\n ┊226┊282┊\n-┊227┊   ┊        if (chatMessageIndex !== -1) {\n-┊228┊   ┊          messages.splice(chatMessageIndex, 1);\n+┊   ┊283┊        if (!chat) {\n+┊   ┊284┊          await db.query('ROLLBACK');\n+┊   ┊285┊          return null;\n ┊229┊286┊        }\n-┊230┊   ┊      });\n ┊231┊287┊\n-┊232┊   ┊      chats.splice(chatIndex, 1);\n+┊   ┊288┊        await db.query(sql`\n+┊   ┊289┊          DELETE FROM chats WHERE chats.id = ${chatId}\n+┊   ┊290┊        `);\n ┊233┊291┊\n-┊234┊   ┊      pubsub.publish('chatRemoved', {\n-┊235┊   ┊        chatRemoved: chat.id,\n-┊236┊   ┊        targetChat: chat,\n-┊237┊   ┊      });\n+┊   ┊292┊        pubsub.publish('chatRemoved', {\n+┊   ┊293┊          chatRemoved: chat.id,\n+┊   ┊294┊          targetChat: chat,\n+┊   ┊295┊        });\n ┊238┊296┊\n-┊239┊   ┊      return chatId;\n+┊   ┊297┊        await db.query('COMMIT');\n+┊   ┊298┊\n+┊   ┊299┊        return chatId;\n+┊   ┊300┊      } catch (e) {\n+┊   ┊301┊        await db.query('ROLLBACK');\n+┊   ┊302┊        throw e;\n+┊   ┊303┊      }\n ┊240┊304┊    },\n ┊241┊305┊  },\n ┊242┊306┊\n```\n```diff\n@@ -244,12 +308,19 @@\n ┊244┊308┊    messageAdded: {\n ┊245┊309┊      subscribe: withFilter(\n ┊246┊310┊        (root, args, { pubsub }) => pubsub.asyncIterator('messageAdded'),\n-┊247┊   ┊        ({ messageAdded }, args, { currentUser }) => {\n+┊   ┊311┊        async (\n+┊   ┊312┊          { messageAdded }: { messageAdded: Message },\n+┊   ┊313┊          args,\n+┊   ┊314┊          { currentUser }\n+┊   ┊315┊        ) => {\n ┊248┊316┊          if (!currentUser) return false;\n ┊249┊317┊\n-┊250┊   ┊          return [messageAdded.sender, messageAdded.recipient].includes(\n-┊251┊   ┊            currentUser.id\n-┊252┊   ┊          );\n+┊   ┊318┊          const { rows } = await pool.query(sql`\n+┊   ┊319┊            SELECT * FROM chats_users\n+┊   ┊320┊            WHERE chat_id = ${messageAdded.chat_id}\n+┊   ┊321┊            AND user_id = ${currentUser.id}`);\n+┊   ┊322┊\n+┊   ┊323┊          return !!rows.length;\n ┊253┊324┊        }\n ┊254┊325┊      ),\n ┊255┊326┊    },\n```\n```diff\n@@ -257,10 +328,15 @@\n ┊257┊328┊    chatAdded: {\n ┊258┊329┊      subscribe: withFilter(\n ┊259┊330┊        (root, args, { pubsub }) => pubsub.asyncIterator('chatAdded'),\n-┊260┊   ┊        ({ chatAdded }: { chatAdded: Chat }, args, { currentUser }) => {\n+┊   ┊331┊        async ({ chatAdded }: { chatAdded: Chat }, args, { currentUser }) => {\n ┊261┊332┊          if (!currentUser) return false;\n ┊262┊333┊\n-┊263┊   ┊          return chatAdded.participants.some(p => p === currentUser.id);\n+┊   ┊334┊          const { rows } = await pool.query(sql`\n+┊   ┊335┊            SELECT * FROM chats_users\n+┊   ┊336┊            WHERE chat_id = ${chatAdded.id}\n+┊   ┊337┊            AND user_id = ${currentUser.id}`);\n+┊   ┊338┊\n+┊   ┊339┊          return !!rows.length;\n ┊264┊340┊        }\n ┊265┊341┊      ),\n ┊266┊342┊    },\n```\n```diff\n@@ -268,10 +344,15 @@\n ┊268┊344┊    chatRemoved: {\n ┊269┊345┊      subscribe: withFilter(\n ┊270┊346┊        (root, args, { pubsub }) => pubsub.asyncIterator('chatRemoved'),\n-┊271┊   ┊        ({ targetChat }: { targetChat: Chat }, args, { currentUser }) => {\n+┊   ┊347┊        async ({ targetChat }: { targetChat: Chat }, args, { currentUser }) => {\n ┊272┊348┊          if (!currentUser) return false;\n ┊273┊349┊\n-┊274┊   ┊          return targetChat.participants.some(p => p === currentUser.id);\n+┊   ┊350┊          const { rows } = await pool.query(sql`\n+┊   ┊351┊            SELECT * FROM chats_users\n+┊   ┊352┊            WHERE chat_id = ${targetChat.id}\n+┊   ┊353┊            AND user_id = ${currentUser.id}`);\n+┊   ┊354┊\n+┊   ┊355┊          return !!rows.length;\n ┊275┊356┊        }\n ┊276┊357┊      ),\n ┊277┊358┊    },\n```\n\n[}]: #\n\n> We use `pool` itself instead of `db` from the context in the subscriptions. Remember we don't request for a new client from the pool in subscriptions.\n> If you use `pool.query`, it just opens a connection, does that operation and set the client free. In that case, you wouldn't be able to work with transactions which is not need in GraphQL Subscriptions.\n\n**Updating Subscriptions w/ PostgreSQL PubSub mechanism**\n\nApollo’s default PubSub mechanism is not for production usage. So, we will use PostgreSQL’s notify/listen for our PubSub mechanism in GraphQL Subscriptions.\n\nInstall the necessary packages;\n\n\t$ yarn add graphql-postgres-subscriptions\n\n[{]: <helper> (diffStep 11.7 files=\"index\" module=\"server\")\n\n#### [__Server__ Step 11.7: Updating Subscriptions w/ PostgreSQL PubSub mechanism](https://github.com/Urigo/WhatsApp-Clone-Server/commit/2aa51eb)\n\n##### Changed index.ts\n```diff\n@@ -1,4 +1,4 @@\n-┊1┊ ┊import { ApolloServer, gql, PubSub } from 'apollo-server-express';\n+┊ ┊1┊import { ApolloServer } from 'apollo-server-express';\n ┊2┊2┊import cookie from 'cookie';\n ┊3┊3┊import http from 'http';\n ┊4┊4┊import jwt from 'jsonwebtoken';\n```\n```diff\n@@ -8,8 +8,15 @@\n ┊ 8┊ 8┊import schema from './schema';\n ┊ 9┊ 9┊import { MyContext } from './context';\n ┊10┊10┊import sql from 'sql-template-strings';\n+┊  ┊11┊const { PostgresPubSub } = require('graphql-postgres-subscriptions');\n ┊11┊12┊\n-┊12┊  ┊const pubsub = new PubSub();\n+┊  ┊13┊const pubsub = new PostgresPubSub({\n+┊  ┊14┊  host: 'localhost',\n+┊  ┊15┊  port: 5432,\n+┊  ┊16┊  user: 'testuser',\n+┊  ┊17┊  password: 'testpassword',\n+┊  ┊18┊  database: 'whatsapp',\n+┊  ┊19┊});\n ┊13┊20┊const server = new ApolloServer({\n ┊14┊21┊  schema,\n ┊15┊22┊  context: async (session: any) => {\n```\n\n[}]: #\n\n> Unfortunately `graphql-postgres-subscription` doesn't have TypeScript typings, so we have to import it using `require`.\n\n**Updating Tests**\n\nWe should update tests to use SQL instead of in-memory database.\n\n[{]: <helper> (diffStep 11.8 files=\"test\" module=\"server\")\n\n#### [__Server__ Step 11.8: Updating Tests with SQL](https://github.com/Urigo/WhatsApp-Clone-Server/commit/60d0b1a)\n\n##### Changed tests&#x2F;mutations&#x2F;addChat.test.ts\n```diff\n@@ -1,18 +1,27 @@\n ┊ 1┊ 1┊import { createTestClient } from 'apollo-server-testing';\n ┊ 2┊ 2┊import { ApolloServer, PubSub, gql } from 'apollo-server-express';\n ┊ 3┊ 3┊import schema from '../../schema';\n-┊ 4┊  ┊import { resetDb, users } from '../../db';\n+┊  ┊ 4┊import { resetDb, pool } from '../../db';\n+┊  ┊ 5┊import sql from 'sql-template-strings';\n+┊  ┊ 6┊import { MyContext } from '../../context';\n ┊ 5┊ 7┊\n ┊ 6┊ 8┊describe('Mutation.addChat', () => {\n ┊ 7┊ 9┊  beforeEach(resetDb);\n ┊ 8┊10┊\n ┊ 9┊11┊  it('creates a new chat between current user and specified recipient', async () => {\n+┊  ┊12┊    const { rows } = await pool.query(sql`SELECT * FROM users WHERE id = 2`);\n+┊  ┊13┊    const currentUser = rows[0];\n ┊10┊14┊    const server = new ApolloServer({\n ┊11┊15┊      schema,\n-┊12┊  ┊      context: () => ({\n+┊  ┊16┊      context: async () => ({\n ┊13┊17┊        pubsub: new PubSub(),\n-┊14┊  ┊        currentUser: users[1],\n+┊  ┊18┊        currentUser,\n+┊  ┊19┊        db: await pool.connect(),\n ┊15┊20┊      }),\n+┊  ┊21┊      formatResponse: (res: any, { context }: { context: MyContext }) => {\n+┊  ┊22┊        context.db.release();\n+┊  ┊23┊        return res;\n+┊  ┊24┊      },\n ┊16┊25┊    });\n ┊17┊26┊\n ┊18┊27┊    const { query, mutate } = createTestClient(server);\n```\n```diff\n@@ -57,12 +66,19 @@\n ┊57┊66┊  });\n ┊58┊67┊\n ┊59┊68┊  it('returns the existing chat if so', async () => {\n+┊  ┊69┊    const { rows } = await pool.query(sql`SELECT * FROM users WHERE id = 1`);\n+┊  ┊70┊    const currentUser = rows[0];\n ┊60┊71┊    const server = new ApolloServer({\n ┊61┊72┊      schema,\n-┊62┊  ┊      context: () => ({\n+┊  ┊73┊      context: async () => ({\n ┊63┊74┊        pubsub: new PubSub(),\n-┊64┊  ┊        currentUser: users[0],\n+┊  ┊75┊        currentUser,\n+┊  ┊76┊        db: await pool.connect(),\n ┊65┊77┊      }),\n+┊  ┊78┊      formatResponse: (res: any, { context }: { context: MyContext }) => {\n+┊  ┊79┊        context.db.release();\n+┊  ┊80┊        return res;\n+┊  ┊81┊      },\n ┊66┊82┊    });\n ┊67┊83┊\n ┊68┊84┊    const { query, mutate } = createTestClient(server);\n```\n\n##### Changed tests&#x2F;mutations&#x2F;addMessage.test.ts\n```diff\n@@ -1,18 +1,27 @@\n ┊ 1┊ 1┊import { createTestClient } from 'apollo-server-testing';\n ┊ 2┊ 2┊import { ApolloServer, PubSub, gql } from 'apollo-server-express';\n ┊ 3┊ 3┊import schema from '../../schema';\n-┊ 4┊  ┊import { resetDb, users } from '../../db';\n+┊  ┊ 4┊import { resetDb, pool } from '../../db';\n+┊  ┊ 5┊import sql from 'sql-template-strings';\n+┊  ┊ 6┊import { MyContext } from '../../context';\n ┊ 5┊ 7┊\n ┊ 6┊ 8┊describe('Mutation.addMessage', () => {\n ┊ 7┊ 9┊  beforeEach(resetDb);\n ┊ 8┊10┊\n ┊ 9┊11┊  it('should add message to specified chat', async () => {\n+┊  ┊12┊    const { rows } = await pool.query(sql`SELECT * FROM users WHERE id = 1`);\n+┊  ┊13┊    const currentUser = rows[0];\n ┊10┊14┊    const server = new ApolloServer({\n ┊11┊15┊      schema,\n-┊12┊  ┊      context: () => ({\n+┊  ┊16┊      context: async () => ({\n ┊13┊17┊        pubsub: new PubSub(),\n-┊14┊  ┊        currentUser: users[0],\n+┊  ┊18┊        currentUser,\n+┊  ┊19┊        db: await pool.connect(),\n ┊15┊20┊      }),\n+┊  ┊21┊      formatResponse: (res: any, { context }: { context: MyContext }) => {\n+┊  ┊22┊        context.db.release();\n+┊  ┊23┊        return res;\n+┊  ┊24┊      },\n ┊16┊25┊    });\n ┊17┊26┊\n ┊18┊27┊    const { query, mutate } = createTestClient(server);\n```\n\n##### Changed tests&#x2F;mutations&#x2F;removeChat.test.ts\n```diff\n@@ -1,18 +1,27 @@\n ┊ 1┊ 1┊import { createTestClient } from 'apollo-server-testing';\n ┊ 2┊ 2┊import { ApolloServer, PubSub, gql } from 'apollo-server-express';\n ┊ 3┊ 3┊import schema from '../../schema';\n-┊ 4┊  ┊import { resetDb, users } from '../../db';\n+┊  ┊ 4┊import { resetDb, pool } from '../../db';\n+┊  ┊ 5┊import sql from 'sql-template-strings';\n+┊  ┊ 6┊import { MyContext } from '../../context';\n ┊ 5┊ 7┊\n ┊ 6┊ 8┊describe('Mutation.removeChat', () => {\n ┊ 7┊ 9┊  beforeEach(resetDb);\n ┊ 8┊10┊\n ┊ 9┊11┊  it('removes chat by id', async () => {\n+┊  ┊12┊    const { rows } = await pool.query(sql`SELECT * FROM users WHERE id = 1`);\n+┊  ┊13┊    const currentUser = rows[0];\n ┊10┊14┊    const server = new ApolloServer({\n ┊11┊15┊      schema,\n-┊12┊  ┊      context: () => ({\n+┊  ┊16┊      context: async () => ({\n ┊13┊17┊        pubsub: new PubSub(),\n-┊14┊  ┊        currentUser: users[0],\n+┊  ┊18┊        currentUser,\n+┊  ┊19┊        db: await pool.connect(),\n ┊15┊20┊      }),\n+┊  ┊21┊      formatResponse: (res: any, { context }: { context: MyContext }) => {\n+┊  ┊22┊        context.db.release();\n+┊  ┊23┊        return res;\n+┊  ┊24┊      },\n ┊16┊25┊    });\n ┊17┊26┊\n ┊18┊27┊    const { query, mutate } = createTestClient(server);\n```\n\n##### Changed tests&#x2F;queries&#x2F;getChat.test.ts\n```diff\n@@ -1,15 +1,26 @@\n ┊ 1┊ 1┊import { createTestClient } from 'apollo-server-testing';\n ┊ 2┊ 2┊import { ApolloServer, gql } from 'apollo-server-express';\n ┊ 3┊ 3┊import schema from '../../schema';\n-┊ 4┊  ┊import { users } from '../../db';\n+┊  ┊ 4┊import { pool, resetDb } from '../../db';\n+┊  ┊ 5┊import sql from 'sql-template-strings';\n+┊  ┊ 6┊import { MyContext } from '../../context';\n ┊ 5┊ 7┊\n ┊ 6┊ 8┊describe('Query.chat', () => {\n+┊  ┊ 9┊  beforeEach(resetDb);\n+┊  ┊10┊\n ┊ 7┊11┊  it('should fetch specified chat', async () => {\n+┊  ┊12┊    const { rows } = await pool.query(sql`SELECT * FROM users WHERE id = 1`);\n+┊  ┊13┊    const currentUser = rows[0];\n ┊ 8┊14┊    const server = new ApolloServer({\n ┊ 9┊15┊      schema,\n-┊10┊  ┊      context: () => ({\n-┊11┊  ┊        currentUser: users[0],\n+┊  ┊16┊      context: async () => ({\n+┊  ┊17┊        currentUser,\n+┊  ┊18┊        db: await pool.connect(),\n ┊12┊19┊      }),\n+┊  ┊20┊      formatResponse: (res: any, { context }: { context: MyContext }) => {\n+┊  ┊21┊        context.db.release();\n+┊  ┊22┊        return res;\n+┊  ┊23┊      },\n ┊13┊24┊    });\n ┊14┊25┊\n ┊15┊26┊    const { query } = createTestClient(server);\n```\n\n##### Changed tests&#x2F;queries&#x2F;getChats.test.ts\n```diff\n@@ -1,15 +1,26 @@\n ┊ 1┊ 1┊import { createTestClient } from 'apollo-server-testing';\n ┊ 2┊ 2┊import { ApolloServer, gql } from 'apollo-server-express';\n ┊ 3┊ 3┊import schema from '../../schema';\n-┊ 4┊  ┊import { users } from '../../db';\n+┊  ┊ 4┊import { pool, resetDb } from '../../db';\n+┊  ┊ 5┊import sql from 'sql-template-strings';\n+┊  ┊ 6┊import { MyContext } from '../../context';\n ┊ 5┊ 7┊\n ┊ 6┊ 8┊describe('Query.chats', () => {\n+┊  ┊ 9┊  beforeEach(resetDb);\n+┊  ┊10┊\n ┊ 7┊11┊  it('should fetch all chats', async () => {\n+┊  ┊12┊    const { rows } = await pool.query(sql`SELECT * FROM users WHERE id = 1`);\n+┊  ┊13┊    const currentUser = rows[0];\n ┊ 8┊14┊    const server = new ApolloServer({\n ┊ 9┊15┊      schema,\n-┊10┊  ┊      context: () => ({\n-┊11┊  ┊        currentUser: users[0],\n+┊  ┊16┊      context: async () => ({\n+┊  ┊17┊        currentUser,\n+┊  ┊18┊        db: await pool.connect(),\n ┊12┊19┊      }),\n+┊  ┊20┊      formatResponse: (res: any, { context }: { context: MyContext }) => {\n+┊  ┊21┊        context.db.release();\n+┊  ┊22┊        return res;\n+┊  ┊23┊      },\n ┊13┊24┊    });\n ┊14┊25┊\n ┊15┊26┊    const { query } = createTestClient(server);\n```\n\n##### Changed tests&#x2F;queries&#x2F;getMe.test.ts\n```diff\n@@ -1,15 +1,24 @@\n ┊ 1┊ 1┊import { createTestClient } from 'apollo-server-testing';\n ┊ 2┊ 2┊import { ApolloServer, gql } from 'apollo-server-express';\n ┊ 3┊ 3┊import schema from '../../schema';\n-┊ 4┊  ┊import { users } from '../../db';\n+┊  ┊ 4┊import { pool } from '../../db';\n+┊  ┊ 5┊import sql from 'sql-template-strings';\n+┊  ┊ 6┊import { MyContext } from '../../context';\n ┊ 5┊ 7┊\n ┊ 6┊ 8┊describe('Query.me', () => {\n ┊ 7┊ 9┊  it('should fetch current user', async () => {\n+┊  ┊10┊    const { rows } = await pool.query(sql`SELECT * FROM users WHERE id = 1`);\n+┊  ┊11┊    const currentUser = rows[0];\n ┊ 8┊12┊    const server = new ApolloServer({\n ┊ 9┊13┊      schema,\n-┊10┊  ┊      context: () => ({\n-┊11┊  ┊        currentUser: users[0],\n+┊  ┊14┊      context: async () => ({\n+┊  ┊15┊        currentUser,\n+┊  ┊16┊        db: await pool.connect(),\n ┊12┊17┊      }),\n+┊  ┊18┊      formatResponse: (res: any, { context }: { context: MyContext }) => {\n+┊  ┊19┊        context.db.release();\n+┊  ┊20┊        return res;\n+┊  ┊21┊      },\n ┊13┊22┊    });\n ┊14┊23┊\n ┊15┊24┊    const { query } = createTestClient(server);\n```\n\n##### Changed tests&#x2F;queries&#x2F;getUsers.test.ts\n```diff\n@@ -1,15 +1,27 @@\n ┊ 1┊ 1┊import { createTestClient } from 'apollo-server-testing';\n ┊ 2┊ 2┊import { ApolloServer, gql } from 'apollo-server-express';\n ┊ 3┊ 3┊import schema from '../../schema';\n-┊ 4┊  ┊import { users } from '../../db';\n+┊  ┊ 4┊import { pool } from '../../db';\n+┊  ┊ 5┊import sql from 'sql-template-strings';\n+┊  ┊ 6┊import { MyContext } from '../../context';\n ┊ 5┊ 7┊\n ┊ 6┊ 8┊describe('Query.getUsers', () => {\n ┊ 7┊ 9┊  it('should fetch all users except the one signed-in', async () => {\n-┊ 8┊  ┊    let currentUser = users[0];\n-┊ 9┊  ┊\n+┊  ┊10┊    const firstUserQuery = await pool.query(\n+┊  ┊11┊      sql`SELECT * FROM users WHERE id = 1`\n+┊  ┊12┊    );\n+┊  ┊13┊    let currentUser = firstUserQuery.rows[0];\n+┊  ┊14┊    const db = await pool.connect();\n ┊10┊15┊    const server = new ApolloServer({\n ┊11┊16┊      schema,\n-┊12┊  ┊      context: () => ({ currentUser }),\n+┊  ┊17┊      context: async () => ({\n+┊  ┊18┊        currentUser,\n+┊  ┊19┊        db: await pool.connect(),\n+┊  ┊20┊      }),\n+┊  ┊21┊      formatResponse: (res: any, { context }: { context: MyContext }) => {\n+┊  ┊22┊        context.db.release();\n+┊  ┊23┊        return res;\n+┊  ┊24┊      },\n ┊13┊25┊    });\n ┊14┊26┊\n ┊15┊27┊    const { query } = createTestClient(server);\n```\n```diff\n@@ -30,7 +42,10 @@\n ┊30┊42┊    expect(res.errors).toBeUndefined();\n ┊31┊43┊    expect(res.data).toMatchSnapshot();\n ┊32┊44┊\n-┊33┊  ┊    currentUser = users[1];\n+┊  ┊45┊    const secondUserQuery = await pool.query(\n+┊  ┊46┊      sql`SELECT * FROM users WHERE id = '2'`\n+┊  ┊47┊    );\n+┊  ┊48┊    currentUser = secondUserQuery.rows[0];\n ┊34┊49┊\n ┊35┊50┊    res = await query({\n ┊36┊51┊      query: gql`\n```\n\n[}]: #\n\n**Remove in-memory database**\n\nWe can remove all the stuff related to in-memory database now.\n\n[{]: <helper> (diffStep 11.9 files=\"db\" module=\"server\")\n\n#### [__Server__ Step 11.9: Removing in-memory database](https://github.com/Urigo/WhatsApp-Clone-Server/commit/4b2bdde)\n\n##### Changed db.ts\n```diff\n@@ -32,10 +32,6 @@\n ┊32┊32┊\n ┊33┊33┊export let pool: Pool = new Pool(dbConfig);\n ┊34┊34┊\n-┊35┊  ┊export const users: User[] = [];\n-┊36┊  ┊export const messages: Message[] = [];\n-┊37┊  ┊export const chats: Chat[] = [];\n-┊38┊  ┊\n ┊39┊35┊export async function initDb(): Promise<void> {\n ┊40┊36┊  // Clear tables\n ┊41┊37┊  await pool.query(sql`DROP TABLE IF EXISTS messages;`);\n```\n\n[}]: #"
          },
          {
            "manualTitle": "Step 15: Using a REST API",
            "stepRevision": "4804eaa1823300331921a06bdd65e30d2957667a",
            "manualView": "Despite using GraphQL throughout all our app, we will soon meet the need to use some external API and chances are it will be REST.\nOur first idea could be to bridge the REST API through GraphQL, reproposing the very same API to the client. This approach is wrong, because our first concern should always be to provide the client with ready to use data in the best possible shape.\nThe client don’t need to know that our GraphQL API is backed by a REST API, it doesn’t have to pass headers required by the underlying API or do any kind of special considerations: our backend should take care of everything.\n\n## Retrieve a profile picture from a REST API\n\nIn this chapter we will discuss how to use an external API called Unsplash to retrieve random profile pictures for the users who didn’t set any.\n\nStart heading to https://unsplash.com/developers and clicking on “Register as a developer”. After registering you will have to create a new app: take note of the Access Key because we’re going to need it.\n\nIf you look at the Documentation (https://unsplash.com/documentation#get-a-random-photo) you’ll notice that in order to retrieve a random photo we have to query the /photos/random endpoint (GET method). We also have to pass some headers for the authent\ncation and some params for the search term and the orientation.\n\nOn the browser we would probably use the fetch api, but since on we node we would need a polyfill it’s better to just use a full fledged library like axios:\n\n    yarn add axios\n    yarn add -D @types/axios\n\nBefore we start implementing, we want to create some typings for our endpoint, because ideally we would like to be aided by those typings during the development.\nIn order to do so we can use a Chrome extension like Advanced Rest Client to retrieve the response.\nSet the Method to GET, the Headers to Authorization: 'Client-ID 4d048cfb4383b407eff92e4a2a5ec36c0a866be85e64caafa588c110efad350d' and the Request URL to https://api.unsplash.com/photos/random, along with the params to query: 'portrait' and orientation: 'squarish'.\nCopy the response, create a new file called types/unsplash.ts in your vscode editor and run the command “Past JSON as Types” (you need to install the Past JSON as Code extension and press CTRL+P to open the run command prompt). That would be enough to automatically create the typings for the random photo endpoint.\n\nNow we can finally implement the REST API call in our picture resolver:\n\n[{]: <helper> (diffStep \"12.1\" files=\"schema/resolvers.ts\" module=\"server\")\n\n#### [__Server__ Step 12.1: Retrieve profile picture from REST API](https://github.com/Urigo/WhatsApp-Clone-Server/commit/f537fd8)\n\n##### Changed schema&#x2F;resolvers.ts\n```diff\n@@ -7,6 +7,8 @@\n ┊ 7┊ 7┊import jwt from 'jsonwebtoken';\n ┊ 8┊ 8┊import { validateLength, validatePassword } from '../validators';\n ┊ 9┊ 9┊import sql from 'sql-template-strings';\n+┊  ┊10┊import axios from 'axios';\n+┊  ┊11┊import { RandomPhoto } from '../types/unsplash';\n ┊10┊12┊\n ┊11┊13┊const resolvers: Resolvers = {\n ┊12┊14┊  Date: GraphQLDateTime,\n```\n```diff\n@@ -70,7 +72,26 @@\n ┊70┊72┊\n ┊71┊73┊      const participant = rows[0];\n ┊72┊74┊\n-┊73┊  ┊      return participant ? participant.picture : null;\n+┊  ┊75┊      if (participant && participant.picture) return participant.picture;\n+┊  ┊76┊\n+┊  ┊77┊      try {\n+┊  ┊78┊        return (await axios.get<RandomPhoto>(\n+┊  ┊79┊          'https://api.unsplash.com/photos/random',\n+┊  ┊80┊          {\n+┊  ┊81┊            params: {\n+┊  ┊82┊              query: 'portrait',\n+┊  ┊83┊              orientation: 'squarish',\n+┊  ┊84┊            },\n+┊  ┊85┊            headers: {\n+┊  ┊86┊              Authorization:\n+┊  ┊87┊                'Client-ID 4d048cfb4383b407eff92e4a2a5ec36c0a866be85e64caafa588c110efad350d',\n+┊  ┊88┊            },\n+┊  ┊89┊          }\n+┊  ┊90┊        )).data.urls.small;\n+┊  ┊91┊      } catch (err) {\n+┊  ┊92┊        console.error('Cannot retrieve random photo:', err);\n+┊  ┊93┊        return null;\n+┊  ┊94┊      }\n ┊74┊95┊    },\n ┊75┊96┊\n ┊76┊97┊    async messages(chat, args, { db }) {\n```\n\n[}]: #\n\nIn order to test it, we have to remove the picture from one of the users and re-run the server with the `RESET_DB=true` environment variable:\n\n[{]: <helper> (diffStep \"12.1\" files=\"db.ts\" module=\"server\")\n\n#### [__Server__ Step 12.1: Retrieve profile picture from REST API](https://github.com/Urigo/WhatsApp-Clone-Server/commit/f537fd8)\n\n##### Changed db.ts\n```diff\n@@ -123,6 +123,10 @@\n ┊123┊123┊    sql`SELECT setval('users_id_seq', (SELECT max(id) FROM users))`\n ┊124┊124┊  );\n ┊125┊125┊\n+┊   ┊126┊  await pool.query(\n+┊   ┊127┊    sql`SELECT setval('users_id_seq', (SELECT max(id) FROM users))`\n+┊   ┊128┊  );\n+┊   ┊129┊\n ┊126┊130┊  await pool.query(sql`DELETE FROM chats`);\n ┊127┊131┊\n ┊128┊132┊  const sampleChats = [\n```\n\n[}]: #\n\n\n## Track the API\n\nEven if our typings are working pretty well so far, not all REST APIs are versioned and the shape we’ve got from the server could potentially change.\nIn order to keep an eye on it we could use the safe-api middleware in order to check for abnormal answers coming from the server and log them. We can also generate the typings automatically based on the response we get.\nFirst let’s install the safe-api middleware:\n\n    yarn add @safe-api/middleware\n\nThen let’s use it inside our resolver:\n\n[{]: <helper> (diffStep \"12.2\" files=\"schema/resolvers.ts\" module=\"server\")\n\n#### [__Server__ Step 12.2: Use safe-api](https://github.com/Urigo/WhatsApp-Clone-Server/commit/bbc07f5)\n\n##### Changed schema&#x2F;resolvers.ts\n```diff\n@@ -9,6 +9,8 @@\n ┊ 9┊ 9┊import sql from 'sql-template-strings';\n ┊10┊10┊import axios from 'axios';\n ┊11┊11┊import { RandomPhoto } from '../types/unsplash';\n+┊  ┊12┊import { trackProvider } from '@safe-api/middleware';\n+┊  ┊13┊import { resolve } from 'path';\n ┊12┊14┊\n ┊13┊15┊const resolvers: Resolvers = {\n ┊14┊16┊  Date: GraphQLDateTime,\n```\n```diff\n@@ -74,20 +76,38 @@\n ┊ 74┊ 76┊\n ┊ 75┊ 77┊      if (participant && participant.picture) return participant.picture;\n ┊ 76┊ 78┊\n+┊   ┊ 79┊      interface RandomPhotoInput {\n+┊   ┊ 80┊        query: string;\n+┊   ┊ 81┊        orientation: 'landscape' | 'portrait' | 'squarish';\n+┊   ┊ 82┊      }\n+┊   ┊ 83┊\n+┊   ┊ 84┊      const trackedRandomPhoto = await trackProvider(\n+┊   ┊ 85┊        async ({ query, orientation }: RandomPhotoInput) =>\n+┊   ┊ 86┊          (await axios.get<RandomPhoto>(\n+┊   ┊ 87┊            'https://api.unsplash.com/photos/random',\n+┊   ┊ 88┊            {\n+┊   ┊ 89┊              params: {\n+┊   ┊ 90┊                query,\n+┊   ┊ 91┊                orientation,\n+┊   ┊ 92┊              },\n+┊   ┊ 93┊              headers: {\n+┊   ┊ 94┊                Authorization:\n+┊   ┊ 95┊                  'Client-ID 4d048cfb4383b407eff92e4a2a5ec36c0a866be85e64caafa588c110efad350d',\n+┊   ┊ 96┊              },\n+┊   ┊ 97┊            }\n+┊   ┊ 98┊          )).data,\n+┊   ┊ 99┊        {\n+┊   ┊100┊          provider: 'Unsplash',\n+┊   ┊101┊          method: 'RandomPhoto',\n+┊   ┊102┊          location: resolve(__dirname, '../logs/main'),\n+┊   ┊103┊        }\n+┊   ┊104┊      );\n+┊   ┊105┊\n ┊ 77┊106┊      try {\n-┊ 78┊   ┊        return (await axios.get<RandomPhoto>(\n-┊ 79┊   ┊          'https://api.unsplash.com/photos/random',\n-┊ 80┊   ┊          {\n-┊ 81┊   ┊            params: {\n-┊ 82┊   ┊              query: 'portrait',\n-┊ 83┊   ┊              orientation: 'squarish',\n-┊ 84┊   ┊            },\n-┊ 85┊   ┊            headers: {\n-┊ 86┊   ┊              Authorization:\n-┊ 87┊   ┊                'Client-ID 4d048cfb4383b407eff92e4a2a5ec36c0a866be85e64caafa588c110efad350d',\n-┊ 88┊   ┊            },\n-┊ 89┊   ┊          }\n-┊ 90┊   ┊        )).data.urls.small;\n+┊   ┊107┊        return (await trackedRandomPhoto({\n+┊   ┊108┊          query: 'portrait',\n+┊   ┊109┊          orientation: 'squarish',\n+┊   ┊110┊        })).urls.small;\n ┊ 91┊111┊      } catch (err) {\n ┊ 92┊112┊        console.error('Cannot retrieve random photo:', err);\n ┊ 93┊113┊        return null;\n```\n\n[}]: #\n\nNow launch the client in order to retrieve the picture field multiple times.\n\nIf you look inside the logs directory you will notice that it generated some graphql schema to represent the REST API. You will notice that each time we call the REST endpoint it generates a new schema, because a single response isn’t generic enough to account for all possible responses. Ideally safe-api should be able to average multiple esponses in order to generate the least generic schema matching the given responses.\n\nNow we need to remove `types/unsplash.ts` and generate some Typescript typings out of the schema. Do do so we can use the graphql-code-generator:\n\n[{]: <helper> (diffStep \"12.3\" files=\".gitignore, codegen.yml\" module=\"server\")\n\n#### [__Server__ Step 12.3: Generate typings from safe-api](https://github.com/Urigo/WhatsApp-Clone-Server/commit/cb338f6)\n\n##### Changed .gitignore\n```diff\n@@ -1,4 +1,5 @@\n ┊1┊1┊node_modules\n ┊2┊2┊npm-debug.log\n ┊3┊3┊test-results/\n-┊4┊ ┊types/graphql.d.ts🚫↵\n+┊ ┊4┊types/graphql.d.ts\n+┊ ┊5┊types/unsplash.d.ts🚫↵\n```\n\n##### Changed codegen.yml\n```diff\n@@ -1,7 +1,7 @@\n-┊1┊ ┊schema: ./schema/typeDefs.graphql\n ┊2┊1┊overwrite: true\n ┊3┊2┊generates:\n ┊4┊3┊  ./types/graphql.d.ts:\n+┊ ┊4┊    schema: ./schema/typeDefs.graphql\n ┊5┊5┊    plugins:\n ┊6┊6┊      - typescript\n ┊7┊7┊      - typescript-resolvers\n```\n```diff\n@@ -16,3 +16,7 @@\n ┊16┊16┊      scalars:\n ┊17┊17┊        # e.g. Message.createdAt will be of type Date\n ┊18┊18┊        Date: Date\n+┊  ┊19┊  ./types/unsplash.d.ts:\n+┊  ┊20┊    schema: ./logs/main/Unsplash.RandomPhoto.graphql\n+┊  ┊21┊    plugins:\n+┊  ┊22┊      - typescript\n```\n\n[}]: #\n\n    yarn codegen\n\n\n## Apollo DataSources\n\nWe’re not done yet, there is still room for improvement. Instead of using axios, we could use Apollo’s Data Sources and take advantage of the built-in support for caching, deduplication and error handling.\n\n    yarn remove axios @types/axios\n    yarn add apollo-datasource-rest\n\n[{]: <helper> (diffStep \"12.4\" files=\"schema/unsplash.api.ts\" module=\"server\")\n\n#### [__Server__ Step 12.4: Use Apollo DataSources](https://github.com/Urigo/WhatsApp-Clone-Server/commit/7aa8728)\n\n##### Added schema&#x2F;unsplash.api.ts\n```diff\n@@ -0,0 +1,45 @@\n+┊  ┊ 1┊import { RESTDataSource, RequestOptions } from 'apollo-datasource-rest';\n+┊  ┊ 2┊import { resolve } from 'path';\n+┊  ┊ 3┊import { trackProvider } from '@safe-api/middleware';\n+┊  ┊ 4┊import { RandomPhoto } from '../types/unsplash';\n+┊  ┊ 5┊\n+┊  ┊ 6┊interface RandomPhotoInput {\n+┊  ┊ 7┊  query: string;\n+┊  ┊ 8┊  orientation: 'landscape' | 'portrait' | 'squarish';\n+┊  ┊ 9┊}\n+┊  ┊10┊\n+┊  ┊11┊export class UnsplashApi extends RESTDataSource {\n+┊  ┊12┊  constructor() {\n+┊  ┊13┊    super();\n+┊  ┊14┊    this.baseURL = 'https://api.unsplash.com/';\n+┊  ┊15┊  }\n+┊  ┊16┊\n+┊  ┊17┊  willSendRequest(request: RequestOptions) {\n+┊  ┊18┊    request.headers.set(\n+┊  ┊19┊      'Authorization',\n+┊  ┊20┊      'Client-ID 4d048cfb4383b407eff92e4a2a5ec36c0a866be85e64caafa588c110efad350d'\n+┊  ┊21┊    );\n+┊  ┊22┊  }\n+┊  ┊23┊\n+┊  ┊24┊  async getRandomPhoto() {\n+┊  ┊25┊    const trackedRandomPhoto = await trackProvider(\n+┊  ┊26┊      ({ query, orientation }: RandomPhotoInput) =>\n+┊  ┊27┊        this.get<RandomPhoto>('photos/random', { query, orientation }),\n+┊  ┊28┊      {\n+┊  ┊29┊        provider: 'Unsplash',\n+┊  ┊30┊        method: 'RandomPhoto',\n+┊  ┊31┊        location: resolve(__dirname, '../logs/main'),\n+┊  ┊32┊      }\n+┊  ┊33┊    );\n+┊  ┊34┊\n+┊  ┊35┊    try {\n+┊  ┊36┊      return (await trackedRandomPhoto({\n+┊  ┊37┊        query: 'portrait',\n+┊  ┊38┊        orientation: 'squarish',\n+┊  ┊39┊      })).urls.small;\n+┊  ┊40┊    } catch (err) {\n+┊  ┊41┊      console.error('Cannot retrieve random photo:', err);\n+┊  ┊42┊      return null;\n+┊  ┊43┊    }\n+┊  ┊44┊  }\n+┊  ┊45┊}\n```\n\n[}]: #\n\nWe created the UnsplashApi class, which extends RESTDataSource. In the constructor you need to set the baseUrl (after calling super() to run the constructor of the base class). You also need to create a willSendRequest method to set the authentication headers for each call. Then it’s simply a matter of creating a getRandomPhoto method to perform the actual REST API call. Instead of calling axios you will have to call the get method of the class (which in turn gets inherited from its RESTDataSource base class): the API is very similar to the axios one.\n\nIn order to access the data source from the resolvers we need to tell Apollo to put them on the context for every request. We shouldn’t use the context field, because that would lead to circular dependencies. Instead we need to use the dataSources field:\n\n[{]: <helper> (diffStep \"12.4\" files=\"index.ts\" module=\"server\")\n\n#### [__Server__ Step 12.4: Use Apollo DataSources](https://github.com/Urigo/WhatsApp-Clone-Server/commit/7aa8728)\n\n##### Changed index.ts\n```diff\n@@ -8,6 +8,7 @@\n ┊ 8┊ 8┊import schema from './schema';\n ┊ 9┊ 9┊import { MyContext } from './context';\n ┊10┊10┊import sql from 'sql-template-strings';\n+┊  ┊11┊import { UnsplashApi } from './schema/unsplash.api';\n ┊11┊12┊const { PostgresPubSub } = require('graphql-postgres-subscriptions');\n ┊12┊13┊\n ┊13┊14┊const pubsub = new PostgresPubSub({\n```\n```diff\n@@ -67,6 +68,9 @@\n ┊67┊68┊\n ┊68┊69┊    return res;\n ┊69┊70┊  },\n+┊  ┊71┊  dataSources: () => ({\n+┊  ┊72┊    unsplashApi: new UnsplashApi(),\n+┊  ┊73┊  }),\n ┊70┊74┊});\n ┊71┊75┊\n ┊72┊76┊server.applyMiddleware({\n```\n\n[}]: #\n\nNow we need to update the typings for our context and run the graphq-code-generator again:\n\n[{]: <helper> (diffStep \"12.4\" files=\"context.ts\" module=\"server\")\n\n#### [__Server__ Step 12.4: Use Apollo DataSources](https://github.com/Urigo/WhatsApp-Clone-Server/commit/7aa8728)\n\n##### Changed context.ts\n```diff\n@@ -2,10 +2,14 @@\n ┊ 2┊ 2┊import { User } from './db';\n ┊ 3┊ 3┊import { Response } from 'express';\n ┊ 4┊ 4┊import { PoolClient } from 'pg';\n+┊  ┊ 5┊import { UnsplashApi } from './schema/unsplash.api';\n ┊ 5┊ 6┊\n ┊ 6┊ 7┊export type MyContext = {\n ┊ 7┊ 8┊  pubsub: PubSub;\n ┊ 8┊ 9┊  currentUser: User;\n ┊ 9┊10┊  res: Response;\n ┊10┊11┊  db: PoolClient;\n+┊  ┊12┊  dataSources: {\n+┊  ┊13┊    unsplashApi: UnsplashApi;\n+┊  ┊14┊  };\n ┊11┊15┊};\n```\n\n[}]: #\n\n    yarn codegen\n\nNow it should be pretty easy to modify our resolver in order to use our just created datasource:\n\n[{]: <helper> (diffStep \"12.4\" files=\"schema/resolvers.ts\" module=\"server\")\n\n#### [__Server__ Step 12.4: Use Apollo DataSources](https://github.com/Urigo/WhatsApp-Clone-Server/commit/7aa8728)\n\n##### Changed schema&#x2F;resolvers.ts\n```diff\n@@ -7,10 +7,6 @@\n ┊ 7┊ 7┊import jwt from 'jsonwebtoken';\n ┊ 8┊ 8┊import { validateLength, validatePassword } from '../validators';\n ┊ 9┊ 9┊import sql from 'sql-template-strings';\n-┊10┊  ┊import axios from 'axios';\n-┊11┊  ┊import { RandomPhoto } from '../types/unsplash';\n-┊12┊  ┊import { trackProvider } from '@safe-api/middleware';\n-┊13┊  ┊import { resolve } from 'path';\n ┊14┊10┊\n ┊15┊11┊const resolvers: Resolvers = {\n ┊16┊12┊  Date: GraphQLDateTime,\n```\n```diff\n@@ -63,7 +59,7 @@\n ┊63┊59┊      return participant ? participant.name : null;\n ┊64┊60┊    },\n ┊65┊61┊\n-┊66┊  ┊    async picture(chat, args, { currentUser, db }) {\n+┊  ┊62┊    async picture(chat, args, { currentUser, db, dataSources }) {\n ┊67┊63┊      if (!currentUser) return null;\n ┊68┊64┊\n ┊69┊65┊      const { rows } = await db.query(sql`\n```\n```diff\n@@ -74,44 +70,9 @@\n ┊ 74┊ 70┊\n ┊ 75┊ 71┊      const participant = rows[0];\n ┊ 76┊ 72┊\n-┊ 77┊   ┊      if (participant && participant.picture) return participant.picture;\n-┊ 78┊   ┊\n-┊ 79┊   ┊      interface RandomPhotoInput {\n-┊ 80┊   ┊        query: string;\n-┊ 81┊   ┊        orientation: 'landscape' | 'portrait' | 'squarish';\n-┊ 82┊   ┊      }\n-┊ 83┊   ┊\n-┊ 84┊   ┊      const trackedRandomPhoto = await trackProvider(\n-┊ 85┊   ┊        async ({ query, orientation }: RandomPhotoInput) =>\n-┊ 86┊   ┊          (await axios.get<RandomPhoto>(\n-┊ 87┊   ┊            'https://api.unsplash.com/photos/random',\n-┊ 88┊   ┊            {\n-┊ 89┊   ┊              params: {\n-┊ 90┊   ┊                query,\n-┊ 91┊   ┊                orientation,\n-┊ 92┊   ┊              },\n-┊ 93┊   ┊              headers: {\n-┊ 94┊   ┊                Authorization:\n-┊ 95┊   ┊                  'Client-ID 4d048cfb4383b407eff92e4a2a5ec36c0a866be85e64caafa588c110efad350d',\n-┊ 96┊   ┊              },\n-┊ 97┊   ┊            }\n-┊ 98┊   ┊          )).data,\n-┊ 99┊   ┊        {\n-┊100┊   ┊          provider: 'Unsplash',\n-┊101┊   ┊          method: 'RandomPhoto',\n-┊102┊   ┊          location: resolve(__dirname, '../logs/main'),\n-┊103┊   ┊        }\n-┊104┊   ┊      );\n-┊105┊   ┊\n-┊106┊   ┊      try {\n-┊107┊   ┊        return (await trackedRandomPhoto({\n-┊108┊   ┊          query: 'portrait',\n-┊109┊   ┊          orientation: 'squarish',\n-┊110┊   ┊        })).urls.small;\n-┊111┊   ┊      } catch (err) {\n-┊112┊   ┊        console.error('Cannot retrieve random photo:', err);\n-┊113┊   ┊        return null;\n-┊114┊   ┊      }\n+┊   ┊ 73┊      return participant && participant.picture\n+┊   ┊ 74┊        ? participant.picture\n+┊   ┊ 75┊        : dataSources.unsplashApi.getRandomPhoto();\n ┊115┊ 76┊    },\n ┊116┊ 77┊\n ┊117┊ 78┊    async messages(chat, args, { db }) {\n```\n\n[}]: #"
          },
          {
            "manualTitle": "Step 16: Modularity",
            "stepRevision": "61a9d4539b5574b1cb1a7dd581f042bd957ef836",
            "manualView": "This chapter is focused entirely on how to organize a GraphQL API. By far, our project's schema looks simple and keeping SDL and resolvers in two files is really enough.\n\n## Issues we face when GraphQL API grows\n\nUsually, every app starts small and the difficulty of maintenance grows while features are being implemented. I believe that you should always start small and see how a project involves. You could look up many articles about best practices of organising a project but they bring no benefit when your project is small. You don't want to jump between files in order to find what you're looking for, it should be intuitive. I agree a proper folder structure helps but if your schema has 100 lines of code then it makes no sense to split it into 5 files with 20 LOC each. The schema is so small that it won't hurt you when you hit the wall and separation will be necessary but until it happens you can easily move on with the project.\n\nBigger project means more people, more people means teams. In the current state of the app, they might interrupt each other and that eventually affects productivity.\nLack of separation makes the schema harder to maintain, especially once it grows rapidly.\n\n## That's why modularity is a thing!\n\nIn order to improve and solve those issues we would have to split an API into many pieces.\nThose might be files, even folders, doesn't really matter because the goal is to keep relevant chunks of code in one place, conceptually called module.\n\nIf done right, one team won't disturb another and it also helps to understand an entire codebase just by looking at those modules or even learn a feature because everything related to it is within a single module.\n\nThere's also a very important aspect, reusability. Most APIs have something in common, the first thing that comes to mind is authentication and user mechanism in general.\nWhen working with modules, it gets easier to share those.\n\n## Many ways to organize an API\n\nGraphQL specification explains just the language and how to form an API. Managing codebase, that's on our side.\n\nSince we're talking about modularity, let's see possible implementations.\n\nThe first thing on mind are files and folders. Putting relevant logic in a file won't scale well once we add more things, like business logic for example. Which means we need folders, that's for sure.\n\nOkay, so the next question, how to store SDL and resolvers. Do we want to have them stored together or keep them separated?\n\nI'm a big fan of the former because in schema-first approach the SDL is written first and you see exactly how to construct resolvers. The latter would require to jump between files or have them opened side-by-side.\nAnother benefit shows up when you add, remove or just change part of a schema, less likely that you'll miss something.\n\nBut as always, there are things you can't do with that approach.\nOne that pops into my head right away is an IDE support… ?\n< guys, any ideas? >\n\nLet's talk about modularity in terms of SDL.\nWe know how to define types in GraphQL but what if a type is a sum of many features?\nThere two ways to do it. One is to use the `extend` keyword, another to define a type multiple type. Both gave the same effect, all is merged into one type after all.\n\nBut there are few major differences.\n\nThe `extend` keyword is obviously a part of the specification so IDEs and most tools support it. It feels more natural than the second option.\n\nDefining the same type multiple times is the opposite. It might feel odd, not many IDEs and\ntools support it so you have to add a library that handles it but on the other way you don't care if there's already a type or not, you just make sure there's one with proper fields, no matter what. It might also warn you when fields overlap.\n\n## Modularized schema\n\nThere are couple solutions to help you modularize the schema and we will look at 3 of them.\n\nFirst, let's start by defining 3 modules:\n\n- common - things we want to share with all the rest\n- users - everything related to users\n- chats - core logic of WhatsApp\n\n### Using directories\n\nThe simplest and most obvious solution would be to split what we have and move that into directories.\n\nStarting with common module. We need to create a folder at `/modules/common` and a `index.ts` file in it:\n\n[{]: <helper> (diffStep \"13.1\" files=\"modules/common/index.ts\" module=\"server\")\n\n#### [__Server__ Step 13.1: Modularize schema](https://github.com/Urigo/WhatsApp-Clone-Server/commit/987c01f)\n\n##### Added modules&#x2F;common&#x2F;index.ts\n```diff\n@@ -0,0 +1,23 @@\n+┊  ┊ 1┊import { gql } from 'apollo-server-express';\n+┊  ┊ 2┊import { GraphQLDateTime } from 'graphql-iso-date';\n+┊  ┊ 3┊import { Resolvers } from '../../types/graphql';\n+┊  ┊ 4┊\n+┊  ┊ 5┊export const typeDefs = gql`\n+┊  ┊ 6┊  scalar Date\n+┊  ┊ 7┊\n+┊  ┊ 8┊  type Query {\n+┊  ┊ 9┊    _dummy: Boolean\n+┊  ┊10┊  }\n+┊  ┊11┊\n+┊  ┊12┊  type Mutation {\n+┊  ┊13┊    _dummy: Boolean\n+┊  ┊14┊  }\n+┊  ┊15┊\n+┊  ┊16┊  type Subscription {\n+┊  ┊17┊    _dummy: Boolean\n+┊  ┊18┊  }\n+┊  ┊19┊`;\n+┊  ┊20┊\n+┊  ┊21┊export const resolvers: Resolvers = {\n+┊  ┊22┊  Date: GraphQLDateTime,\n+┊  ┊23┊};\n```\n\n[}]: #\n\nYou can see a pattern here, two things are being exported, one with type definitions and the other with resolvers. Why those `_dummy` fields? We want to use `extend` keyword, that require a base type and GraphQL doesn't accept empty objects.\n\nNow, let's do the same but with Users module:\n\n[{]: <helper> (diffStep \"13.1\" files=\"modules/users/index.ts\" module=\"server\")\n\n#### [__Server__ Step 13.1: Modularize schema](https://github.com/Urigo/WhatsApp-Clone-Server/commit/987c01f)\n\n##### Added modules&#x2F;users&#x2F;index.ts\n```diff\n@@ -0,0 +1,100 @@\n+┊   ┊  1┊import { gql } from 'apollo-server-express';\n+┊   ┊  2┊import sql from 'sql-template-strings';\n+┊   ┊  3┊import bcrypt from 'bcrypt';\n+┊   ┊  4┊import jwt from 'jsonwebtoken';\n+┊   ┊  5┊import { secret, expiration } from '../../env';\n+┊   ┊  6┊import { validateLength, validatePassword } from '../../validators';\n+┊   ┊  7┊import { Resolvers } from '../../types/graphql';\n+┊   ┊  8┊\n+┊   ┊  9┊export const typeDefs = gql`\n+┊   ┊ 10┊  type User {\n+┊   ┊ 11┊    id: ID!\n+┊   ┊ 12┊    name: String!\n+┊   ┊ 13┊    picture: String\n+┊   ┊ 14┊  }\n+┊   ┊ 15┊\n+┊   ┊ 16┊  extend type Query {\n+┊   ┊ 17┊    me: User\n+┊   ┊ 18┊    users: [User!]!\n+┊   ┊ 19┊  }\n+┊   ┊ 20┊\n+┊   ┊ 21┊  extend type Mutation {\n+┊   ┊ 22┊    signIn(username: String!, password: String!): User\n+┊   ┊ 23┊    signUp(\n+┊   ┊ 24┊      name: String!\n+┊   ┊ 25┊      username: String!\n+┊   ┊ 26┊      password: String!\n+┊   ┊ 27┊      passwordConfirm: String!\n+┊   ┊ 28┊    ): User\n+┊   ┊ 29┊  }\n+┊   ┊ 30┊`;\n+┊   ┊ 31┊\n+┊   ┊ 32┊export const resolvers: Resolvers = {\n+┊   ┊ 33┊  Query: {\n+┊   ┊ 34┊    me(root, args, { currentUser }) {\n+┊   ┊ 35┊      return currentUser || null;\n+┊   ┊ 36┊    },\n+┊   ┊ 37┊    async users(root, args, { currentUser, db }) {\n+┊   ┊ 38┊      if (!currentUser) return [];\n+┊   ┊ 39┊\n+┊   ┊ 40┊      const { rows } = await db.query(sql`\n+┊   ┊ 41┊        SELECT * FROM users WHERE users.id != ${currentUser.id}\n+┊   ┊ 42┊      `);\n+┊   ┊ 43┊\n+┊   ┊ 44┊      return rows;\n+┊   ┊ 45┊    },\n+┊   ┊ 46┊  },\n+┊   ┊ 47┊  Mutation: {\n+┊   ┊ 48┊    async signIn(root, { username, password }, { db, res }) {\n+┊   ┊ 49┊      const { rows } = await db.query(\n+┊   ┊ 50┊        sql`SELECT * FROM users WHERE username = ${username}`\n+┊   ┊ 51┊      );\n+┊   ┊ 52┊      const user = rows[0];\n+┊   ┊ 53┊\n+┊   ┊ 54┊      if (!user) {\n+┊   ┊ 55┊        throw new Error('user not found');\n+┊   ┊ 56┊      }\n+┊   ┊ 57┊\n+┊   ┊ 58┊      const passwordsMatch = bcrypt.compareSync(password, user.password);\n+┊   ┊ 59┊\n+┊   ┊ 60┊      if (!passwordsMatch) {\n+┊   ┊ 61┊        throw new Error('password is incorrect');\n+┊   ┊ 62┊      }\n+┊   ┊ 63┊\n+┊   ┊ 64┊      const authToken = jwt.sign(username, secret);\n+┊   ┊ 65┊\n+┊   ┊ 66┊      res.cookie('authToken', authToken, { maxAge: expiration });\n+┊   ┊ 67┊\n+┊   ┊ 68┊      return user;\n+┊   ┊ 69┊    },\n+┊   ┊ 70┊\n+┊   ┊ 71┊    async signUp(root, { name, username, password, passwordConfirm }, { db }) {\n+┊   ┊ 72┊      validateLength('req.name', name, 3, 50);\n+┊   ┊ 73┊      validateLength('req.username', name, 3, 18);\n+┊   ┊ 74┊      validatePassword('req.password', password);\n+┊   ┊ 75┊\n+┊   ┊ 76┊      if (password !== passwordConfirm) {\n+┊   ┊ 77┊        throw Error(\"req.password and req.passwordConfirm don't match\");\n+┊   ┊ 78┊      }\n+┊   ┊ 79┊\n+┊   ┊ 80┊      const existingUserQuery = await db.query(\n+┊   ┊ 81┊        sql`SELECT * FROM users WHERE username = ${username}`\n+┊   ┊ 82┊      );\n+┊   ┊ 83┊      if (existingUserQuery.rows[0]) {\n+┊   ┊ 84┊        throw Error('username already exists');\n+┊   ┊ 85┊      }\n+┊   ┊ 86┊\n+┊   ┊ 87┊      const passwordHash = bcrypt.hashSync(password, bcrypt.genSaltSync(8));\n+┊   ┊ 88┊\n+┊   ┊ 89┊      const createdUserQuery = await db.query(sql`\n+┊   ┊ 90┊        INSERT INTO users(password, picture, username, name)\n+┊   ┊ 91┊        VALUES(${passwordHash}, '', ${username}, ${name})\n+┊   ┊ 92┊        RETURNING *\n+┊   ┊ 93┊      `);\n+┊   ┊ 94┊\n+┊   ┊ 95┊      const user = createdUserQuery.rows[0];\n+┊   ┊ 96┊\n+┊   ┊ 97┊      return user;\n+┊   ┊ 98┊    },\n+┊   ┊ 99┊  },\n+┊   ┊100┊};\n```\n\n[}]: #\n\nAnd Chats module:\n\n[{]: <helper> (diffStep \"13.1\" files=\"modules/chats/index.ts\" module=\"server\")\n\n#### [__Server__ Step 13.1: Modularize schema](https://github.com/Urigo/WhatsApp-Clone-Server/commit/987c01f)\n\n##### Changed schema&#x2F;resolvers.ts\n```diff\n@@ -1,16 +1,47 @@\n-┊ 1┊  ┊import { withFilter } from 'apollo-server-express';\n-┊ 2┊  ┊import { GraphQLDateTime } from 'graphql-iso-date';\n-┊ 3┊  ┊import { Message, Chat, pool } from '../db';\n-┊ 4┊  ┊import { Resolvers } from '../types/graphql';\n-┊ 5┊  ┊import { secret, expiration } from '../env';\n-┊ 6┊  ┊import bcrypt from 'bcrypt';\n-┊ 7┊  ┊import jwt from 'jsonwebtoken';\n-┊ 8┊  ┊import { validateLength, validatePassword } from '../validators';\n+┊  ┊ 1┊import { gql, withFilter } from 'apollo-server-express';\n ┊ 9┊ 2┊import sql from 'sql-template-strings';\n-┊10┊  ┊\n-┊11┊  ┊const resolvers: Resolvers = {\n-┊12┊  ┊  Date: GraphQLDateTime,\n-┊13┊  ┊\n+┊  ┊ 3┊import { Message, Chat, pool } from '../../db';\n+┊  ┊ 4┊import { Resolvers } from '../../types/graphql';\n+┊  ┊ 5┊\n+┊  ┊ 6┊export const typeDefs = gql`\n+┊  ┊ 7┊  type Message {\n+┊  ┊ 8┊    id: ID!\n+┊  ┊ 9┊    content: String!\n+┊  ┊10┊    createdAt: Date!\n+┊  ┊11┊    chat: Chat\n+┊  ┊12┊    sender: User\n+┊  ┊13┊    recipient: User\n+┊  ┊14┊    isMine: Boolean!\n+┊  ┊15┊  }\n+┊  ┊16┊\n+┊  ┊17┊  type Chat {\n+┊  ┊18┊    id: ID!\n+┊  ┊19┊    name: String\n+┊  ┊20┊    picture: String\n+┊  ┊21┊    lastMessage: Message\n+┊  ┊22┊    messages: [Message!]!\n+┊  ┊23┊    participants: [User!]!\n+┊  ┊24┊  }\n+┊  ┊25┊\n+┊  ┊26┊  extend type Query {\n+┊  ┊27┊    chats: [Chat!]!\n+┊  ┊28┊    chat(chatId: ID!): Chat\n+┊  ┊29┊  }\n+┊  ┊30┊\n+┊  ┊31┊  extend type Mutation {\n+┊  ┊32┊    addMessage(chatId: ID!, content: String!): Message\n+┊  ┊33┊    addChat(recipientId: ID!): Chat\n+┊  ┊34┊    removeChat(chatId: ID!): ID\n+┊  ┊35┊  }\n+┊  ┊36┊\n+┊  ┊37┊  extend type Subscription {\n+┊  ┊38┊    messageAdded: Message!\n+┊  ┊39┊    chatAdded: Chat!\n+┊  ┊40┊    chatRemoved: ID!\n+┊  ┊41┊  }\n+┊  ┊42┊`;\n+┊  ┊43┊\n+┊  ┊44┊export const resolvers: Resolvers = {\n ┊14┊45┊  Message: {\n ┊15┊46┊    createdAt(message) {\n ┊16┊47┊      return new Date(message.created_at);\n```\n```diff\n@@ -105,10 +136,6 @@\n ┊105┊136┊  },\n ┊106┊137┊\n ┊107┊138┊  Query: {\n-┊108┊   ┊    me(root, args, { currentUser }) {\n-┊109┊   ┊      return currentUser || null;\n-┊110┊   ┊    },\n-┊111┊   ┊\n ┊112┊139┊    async chats(root, args, { currentUser, db }) {\n ┊113┊140┊      if (!currentUser) return [];\n ┊114┊141┊\n```\n```diff\n@@ -133,71 +160,9 @@\n ┊133┊160┊\n ┊134┊161┊      return rows[0] ? rows[0] : null;\n ┊135┊162┊    },\n-┊136┊   ┊\n-┊137┊   ┊    async users(root, args, { currentUser, db }) {\n-┊138┊   ┊      if (!currentUser) return [];\n-┊139┊   ┊\n-┊140┊   ┊      const { rows } = await db.query(sql`\n-┊141┊   ┊        SELECT * FROM users WHERE users.id != ${currentUser.id}\n-┊142┊   ┊      `);\n-┊143┊   ┊\n-┊144┊   ┊      return rows;\n-┊145┊   ┊    },\n ┊146┊163┊  },\n ┊147┊164┊\n ┊148┊165┊  Mutation: {\n-┊149┊   ┊    async signIn(root, { username, password }, { db, res }) {\n-┊150┊   ┊      const { rows } = await db.query(\n-┊151┊   ┊        sql`SELECT * FROM users WHERE username = ${username}`\n-┊152┊   ┊      );\n-┊153┊   ┊      const user = rows[0];\n-┊154┊   ┊\n-┊155┊   ┊      if (!user) {\n-┊156┊   ┊        throw new Error('user not found');\n-┊157┊   ┊      }\n-┊158┊   ┊\n-┊159┊   ┊      const passwordsMatch = bcrypt.compareSync(password, user.password);\n-┊160┊   ┊\n-┊161┊   ┊      if (!passwordsMatch) {\n-┊162┊   ┊        throw new Error('password is incorrect');\n-┊163┊   ┊      }\n-┊164┊   ┊\n-┊165┊   ┊      const authToken = jwt.sign(username, secret);\n-┊166┊   ┊\n-┊167┊   ┊      res.cookie('authToken', authToken, { maxAge: expiration });\n-┊168┊   ┊\n-┊169┊   ┊      return user;\n-┊170┊   ┊    },\n-┊171┊   ┊\n-┊172┊   ┊    async signUp(root, { name, username, password, passwordConfirm }, { db }) {\n-┊173┊   ┊      validateLength('req.name', name, 3, 50);\n-┊174┊   ┊      validateLength('req.username', name, 3, 18);\n-┊175┊   ┊      validatePassword('req.password', password);\n-┊176┊   ┊\n-┊177┊   ┊      if (password !== passwordConfirm) {\n-┊178┊   ┊        throw Error(\"req.password and req.passwordConfirm don't match\");\n-┊179┊   ┊      }\n-┊180┊   ┊\n-┊181┊   ┊      const existingUserQuery = await db.query(\n-┊182┊   ┊        sql`SELECT * FROM users WHERE username = ${username}`\n-┊183┊   ┊      );\n-┊184┊   ┊      if (existingUserQuery.rows[0]) {\n-┊185┊   ┊        throw Error('username already exists');\n-┊186┊   ┊      }\n-┊187┊   ┊\n-┊188┊   ┊      const passwordHash = bcrypt.hashSync(password, bcrypt.genSaltSync(8));\n-┊189┊   ┊\n-┊190┊   ┊      const createdUserQuery = await db.query(sql`\n-┊191┊   ┊        INSERT INTO users(password, picture, username, name)\n-┊192┊   ┊        VALUES(${passwordHash}, '', ${username}, ${name})\n-┊193┊   ┊        RETURNING *\n-┊194┊   ┊      `);\n-┊195┊   ┊\n-┊196┊   ┊      const user = createdUserQuery.rows[0];\n-┊197┊   ┊\n-┊198┊   ┊      return user;\n-┊199┊   ┊    },\n-┊200┊   ┊\n ┊201┊166┊    async addMessage(root, { chatId, content }, { currentUser, pubsub, db }) {\n ┊202┊167┊      if (!currentUser) return null;\n ┊203┊168┊\n```\n```diff\n@@ -360,5 +325,3 @@\n ┊360┊325┊    },\n ┊361┊326┊  },\n ┊362┊327┊};\n-┊363┊   ┊\n-┊364┊   ┊export default resolvers;\n```\n\n[}]: #\n\nSeems like modules are ready but we still need to create a Schema out of them.\n\n[{]: <helper> (diffStep \"13.1\" files=\"schema/index.ts\" module=\"server\")\n\n#### [__Server__ Step 13.1: Modularize schema](https://github.com/Urigo/WhatsApp-Clone-Server/commit/987c01f)\n\n##### Changed schema&#x2F;index.ts\n```diff\n@@ -1,10 +1,15 @@\n-┊ 1┊  ┊import { importSchema } from 'graphql-import';\n ┊ 2┊ 1┊import { makeExecutableSchema, IResolvers } from 'graphql-tools';\n-┊ 3┊  ┊import resolvers from './resolvers';\n-┊ 4┊  ┊\n-┊ 5┊  ┊const typeDefs = importSchema('schema/typeDefs.graphql');\n+┊  ┊ 2┊import { merge } from 'lodash';\n+┊  ┊ 3┊import * as commonModule from '../modules/common';\n+┊  ┊ 4┊import * as usersModule from '../modules/users';\n+┊  ┊ 5┊import * as chatsModule from '../modules/chats';\n ┊ 6┊ 6┊\n ┊ 7┊ 7┊export default makeExecutableSchema({\n-┊ 8┊  ┊  resolvers: resolvers as IResolvers,\n-┊ 9┊  ┊  typeDefs,\n+┊  ┊ 8┊  resolvers: merge(\n+┊  ┊ 9┊    {},\n+┊  ┊10┊    commonModule.resolvers,\n+┊  ┊11┊    usersModule.resolvers,\n+┊  ┊12┊    chatsModule.resolvers\n+┊  ┊13┊  ) as IResolvers,\n+┊  ┊14┊  typeDefs: [commonModule.typeDefs, usersModule.typeDefs, chatsModule.typeDefs],\n ┊10┊15┊});\n```\n\n[}]: #\n\nBecause we moved everything from `resolvers.ts` and `typeDefs.graphql` files, those can now be removed.\n\nThe last thing we need to adjust is the GraphQL Code Generator's config, in `codegen.yml`:\n\n[{]: <helper> (diffStep \"13.1\" files=\"codegen.yml\" module=\"server\")\n\n#### [__Server__ Step 13.1: Modularize schema](https://github.com/Urigo/WhatsApp-Clone-Server/commit/987c01f)\n\n##### Changed codegen.yml\n```diff\n@@ -1,7 +1,7 @@\n ┊1┊1┊overwrite: true\n ┊2┊2┊generates:\n ┊3┊3┊  ./types/graphql.d.ts:\n-┊4┊ ┊    schema: ./schema/typeDefs.graphql\n+┊ ┊4┊    schema: ./modules/*/*.ts\n ┊5┊5┊    plugins:\n ┊6┊6┊      - typescript\n ┊7┊7┊      - typescript-resolvers\n```\n\n[}]: #\n\nWe no longer keep all type definitions in one place and all documents are wrapped with `gql` tag, the codegen is smart enough to find those.\n\n### Using Apollo Modules\n\nAn alternative to the previous solution and far more interesting is a module feature of Apollo Server.\n\nLet's see how it all might look like when using Apollo Server's modules:\n\n[{]: <helper> (diffStep \"13.2\" files=\"index.ts\" module=\"server\")\n\n#### [__Server__ Step 13.2: Use Apollo Modules](https://github.com/Urigo/WhatsApp-Clone-Server/commit/f32259c)\n\n##### Changed index.ts\n```diff\n@@ -5,12 +5,15 @@\n ┊ 5┊ 5┊import { app } from './app';\n ┊ 6┊ 6┊import { pool } from './db';\n ┊ 7┊ 7┊import { origin, port, secret } from './env';\n-┊ 8┊  ┊import schema from './schema';\n ┊ 9┊ 8┊import { MyContext } from './context';\n ┊10┊ 9┊import sql from 'sql-template-strings';\n ┊11┊10┊import { UnsplashApi } from './schema/unsplash.api';\n ┊12┊11┊const { PostgresPubSub } = require('graphql-postgres-subscriptions');\n ┊13┊12┊\n+┊  ┊13┊import * as commonModule from './modules/common';\n+┊  ┊14┊import * as usersModule from './modules/users';\n+┊  ┊15┊import * as chatsModule from './modules/chats';\n+┊  ┊16┊\n ┊14┊17┊const pubsub = new PostgresPubSub({\n ┊15┊18┊  host: 'localhost',\n ┊16┊19┊  port: 5432,\n```\n```diff\n@@ -19,7 +22,7 @@\n ┊19┊22┊  database: 'whatsapp',\n ┊20┊23┊});\n ┊21┊24┊const server = new ApolloServer({\n-┊22┊  ┊  schema,\n+┊  ┊25┊  modules: [commonModule, usersModule, chatsModule],\n ┊23┊26┊  context: async (session: any) => {\n ┊24┊27┊    // Access the request object\n ┊25┊28┊    let req = session.connection\n```\n\n##### Deleted schema&#x2F;index.ts\n```diff\n@@ -1,15 +0,0 @@\n-┊ 1┊  ┊import { makeExecutableSchema, IResolvers } from 'graphql-tools';\n-┊ 2┊  ┊import { merge } from 'lodash';\n-┊ 3┊  ┊import * as commonModule from '../modules/common';\n-┊ 4┊  ┊import * as usersModule from '../modules/users';\n-┊ 5┊  ┊import * as chatsModule from '../modules/chats';\n-┊ 6┊  ┊\n-┊ 7┊  ┊export default makeExecutableSchema({\n-┊ 8┊  ┊  resolvers: merge(\n-┊ 9┊  ┊    {},\n-┊10┊  ┊    commonModule.resolvers,\n-┊11┊  ┊    usersModule.resolvers,\n-┊12┊  ┊    chatsModule.resolvers\n-┊13┊  ┊  ) as IResolvers,\n-┊14┊  ┊  typeDefs: [commonModule.typeDefs, usersModule.typeDefs, chatsModule.typeDefs],\n-┊15┊  ┊});\n```\n\n[}]: #\n\nThe `modules` of ApolloServer accepts an array of objects with `resolvers` and `typeDefs` properties. That's exactly what we exported and that's why we can use esmodules directly.\n\nBecause we no longer use `schema.ts`, let's remove it.\n\nIf you would run the server right now, you will see a lot of warnings about missing index signatures. It's definitely nothing to worry about and can be easily fixed by using `useIndexSignature` flag of codegen:\n\n[{]: <helper> (diffStep \"13.2\" files=\"codegen.yml\" module=\"server\")\n\n#### [__Server__ Step 13.2: Use Apollo Modules](https://github.com/Urigo/WhatsApp-Clone-Server/commit/f32259c)\n\n##### Changed codegen.yml\n```diff\n@@ -6,6 +6,7 @@\n ┊ 6┊ 6┊      - typescript\n ┊ 7┊ 7┊      - typescript-resolvers\n ┊ 8┊ 8┊    config:\n+┊  ┊ 9┊      useIndexSignature: true\n ┊ 9┊10┊      contextType: ../context#MyContext\n ┊10┊11┊      mappers:\n ┊11┊12┊        # import { Message } from '../db'\n```\n\n[}]: #\n\nYou might ask how is that different from what we have already implemented. The code is a bit simpler because the merging part is done by Apollo Server. We get some helpful messages when type's definition is missing but one of the modules was extending it and also when there are duplicates. Apollo Modules are very straightforward and basic but maybe that's all you really need in a project.\n\n### Using GraphQL Modules\n\nThere's an another alternative option that forces good patterns and providess a nice to work with API. It's called GraphQL Modules.\nThe main goal is to help organize an API and allow to develop it across multiple teams.\n\nyarn add @graphql-modules/core\n\nSame as Apollo Server's modules, has useful warnings and messages but you can use it with any implementation of GraphQL server.\n\n```ts\nimport { GraphQLModule } from ‘@graphql-modules/core';\n\nexport default = new GraphQLModule({\n  name: 'common',\n  typeDefs,\n  resolvers\n});\n```\n\nIt's a bit similar to what we have in Apollo Modules but as you probably noticed, it's wrapped within `GraphQLModule` class. The class manages a business logic, SDL, resolvers and dependencies between modules.\n\n> An important thing to be aware of, GraphQL Modules encapsulates every module. To get a better understanding, think of it as CSS Modules.\n\nNow that you know some basics, let's implement the simplest of all modules:\n\n[{]: <helper> (diffStep \"13.3\" files=\"modules/common/index.ts\" module=\"server\")\n\n#### [__Server__ Step 13.3: Use GraphQL Modules](https://github.com/Urigo/WhatsApp-Clone-Server/commit/840b369)\n\n##### Changed modules&#x2F;common&#x2F;index.ts\n```diff\n@@ -1,8 +1,12 @@\n+┊  ┊ 1┊import { GraphQLModule } from '@graphql-modules/core';\n ┊ 1┊ 2┊import { gql } from 'apollo-server-express';\n ┊ 2┊ 3┊import { GraphQLDateTime } from 'graphql-iso-date';\n+┊  ┊ 4┊import { pool } from '../../db';\n ┊ 3┊ 5┊import { Resolvers } from '../../types/graphql';\n ┊ 4┊ 6┊\n-┊ 5┊  ┊export const typeDefs = gql`\n+┊  ┊ 7┊const { PostgresPubSub } = require('graphql-postgres-subscriptions');\n+┊  ┊ 8┊\n+┊  ┊ 9┊const typeDefs = gql`\n ┊ 6┊10┊  scalar Date\n ┊ 7┊11┊\n ┊ 8┊12┊  type Query {\n```\n```diff\n@@ -18,6 +22,33 @@\n ┊18┊22┊  }\n ┊19┊23┊`;\n ┊20┊24┊\n-┊21┊  ┊export const resolvers: Resolvers = {\n+┊  ┊25┊const resolvers: Resolvers = {\n ┊22┊26┊  Date: GraphQLDateTime,\n ┊23┊27┊};\n+┊  ┊28┊\n+┊  ┊29┊const pubsub = new PostgresPubSub({\n+┊  ┊30┊  host: 'localhost',\n+┊  ┊31┊  port: 5432,\n+┊  ┊32┊  user: 'testuser',\n+┊  ┊33┊  password: 'testpassword',\n+┊  ┊34┊  database: 'whatsapp',\n+┊  ┊35┊});\n+┊  ┊36┊\n+┊  ┊37┊export default new GraphQLModule({\n+┊  ┊38┊  name: 'common',\n+┊  ┊39┊  typeDefs,\n+┊  ┊40┊  resolvers,\n+┊  ┊41┊  async context({ res, connection }) {\n+┊  ┊42┊    let db;\n+┊  ┊43┊\n+┊  ┊44┊    if (!connection) {\n+┊  ┊45┊      db = await pool.connect();\n+┊  ┊46┊    }\n+┊  ┊47┊\n+┊  ┊48┊    return {\n+┊  ┊49┊      pubsub,\n+┊  ┊50┊      res,\n+┊  ┊51┊      db,\n+┊  ┊52┊    };\n+┊  ┊53┊  },\n+┊  ┊54┊});\n```\n\n[}]: #\n\nAs we mentioned, there's no global context so we moved the common parts into Common module.\n\nLet's take care of other two modules and migrate `modules/users/index.ts` first:\n\n[{]: <helper> (diffStep \"13.3\" files=\"modules/users/index.ts\" module=\"server\")\n\n#### [__Server__ Step 13.3: Use GraphQL Modules](https://github.com/Urigo/WhatsApp-Clone-Server/commit/840b369)\n\n##### Changed modules&#x2F;users&#x2F;index.ts\n```diff\n@@ -1,12 +1,16 @@\n+┊  ┊ 1┊import { GraphQLModule } from '@graphql-modules/core';\n ┊ 1┊ 2┊import { gql } from 'apollo-server-express';\n+┊  ┊ 3┊import cookie from 'cookie';\n ┊ 2┊ 4┊import sql from 'sql-template-strings';\n ┊ 3┊ 5┊import bcrypt from 'bcrypt';\n ┊ 4┊ 6┊import jwt from 'jsonwebtoken';\n+┊  ┊ 7┊import commonModule from '../common';\n ┊ 5┊ 8┊import { secret, expiration } from '../../env';\n+┊  ┊ 9┊import { pool } from '../../db';\n ┊ 6┊10┊import { validateLength, validatePassword } from '../../validators';\n ┊ 7┊11┊import { Resolvers } from '../../types/graphql';\n ┊ 8┊12┊\n-┊ 9┊  ┊export const typeDefs = gql`\n+┊  ┊13┊const typeDefs = gql`\n ┊10┊14┊  type User {\n ┊11┊15┊    id: ID!\n ┊12┊16┊    name: String!\n```\n```diff\n@@ -29,7 +33,7 @@\n ┊29┊33┊  }\n ┊30┊34┊`;\n ┊31┊35┊\n-┊32┊  ┊export const resolvers: Resolvers = {\n+┊  ┊36┊const resolvers: Resolvers = {\n ┊33┊37┊  Query: {\n ┊34┊38┊    me(root, args, { currentUser }) {\n ┊35┊39┊      return currentUser || null;\n```\n```diff\n@@ -98,3 +102,38 @@\n ┊ 98┊102┊    },\n ┊ 99┊103┊  },\n ┊100┊104┊};\n+┊   ┊105┊\n+┊   ┊106┊export default new GraphQLModule({\n+┊   ┊107┊  name: 'users',\n+┊   ┊108┊  typeDefs,\n+┊   ┊109┊  resolvers,\n+┊   ┊110┊  imports: () => [commonModule],\n+┊   ┊111┊  async context(session) {\n+┊   ┊112┊    let currentUser;\n+┊   ┊113┊\n+┊   ┊114┊    // Access the request object\n+┊   ┊115┊    let req = session.connection\n+┊   ┊116┊      ? session.connection.context.request\n+┊   ┊117┊      : session.req;\n+┊   ┊118┊\n+┊   ┊119┊    // It's subscription\n+┊   ┊120┊    if (session.connection) {\n+┊   ┊121┊      req.cookies = cookie.parse(req.headers.cookie || '');\n+┊   ┊122┊    }\n+┊   ┊123┊\n+┊   ┊124┊    if (req.cookies.authToken) {\n+┊   ┊125┊      const username = jwt.verify(req.cookies.authToken, secret) as string;\n+┊   ┊126┊\n+┊   ┊127┊      if (username) {\n+┊   ┊128┊        const { rows } = await pool.query(\n+┊   ┊129┊          sql`SELECT * FROM users WHERE username = ${username}`\n+┊   ┊130┊        );\n+┊   ┊131┊        currentUser = rows[0];\n+┊   ┊132┊      }\n+┊   ┊133┊    }\n+┊   ┊134┊\n+┊   ┊135┊    return {\n+┊   ┊136┊      currentUser,\n+┊   ┊137┊    };\n+┊   ┊138┊  },\n+┊   ┊139┊});\n```\n\n[}]: #\n\nJust like with Common, we also moved related context but there's a totally new thing called `imports`. In order to let Users module see Common's contents (types, resolvers, context etc) we need to include it in the dependencies.\n\nNow `Chats` that depends on `Users` and `Common` modules:\n\n[{]: <helper> (diffStep \"13.3\" files=\"modules/chats/index.ts\" module=\"server\")\n\n#### [__Server__ Step 13.3: Use GraphQL Modules](https://github.com/Urigo/WhatsApp-Clone-Server/commit/840b369)\n\n##### Changed modules&#x2F;chats&#x2F;index.ts\n```diff\n@@ -1,9 +1,12 @@\n+┊  ┊ 1┊import { GraphQLModule } from '@graphql-modules/core';\n ┊ 1┊ 2┊import { gql, withFilter } from 'apollo-server-express';\n ┊ 2┊ 3┊import sql from 'sql-template-strings';\n+┊  ┊ 4┊import commonModule from '../common';\n+┊  ┊ 5┊import usersModule from '../users';\n ┊ 3┊ 6┊import { Message, Chat, pool } from '../../db';\n ┊ 4┊ 7┊import { Resolvers } from '../../types/graphql';\n ┊ 5┊ 8┊\n-┊ 6┊  ┊export const typeDefs = gql`\n+┊  ┊ 9┊const typeDefs = gql`\n ┊ 7┊10┊  type Message {\n ┊ 8┊11┊    id: ID!\n ┊ 9┊12┊    content: String!\n```\n```diff\n@@ -41,7 +44,7 @@\n ┊41┊44┊  }\n ┊42┊45┊`;\n ┊43┊46┊\n-┊44┊  ┊export const resolvers: Resolvers = {\n+┊  ┊47┊const resolvers: Resolvers = {\n ┊45┊48┊  Message: {\n ┊46┊49┊    createdAt(message) {\n ┊47┊50┊      return new Date(message.created_at);\n```\n```diff\n@@ -325,3 +328,10 @@\n ┊325┊328┊    },\n ┊326┊329┊  },\n ┊327┊330┊};\n+┊   ┊331┊\n+┊   ┊332┊export default new GraphQLModule({\n+┊   ┊333┊  name: 'chats',\n+┊   ┊334┊  typeDefs,\n+┊   ┊335┊  resolvers,\n+┊   ┊336┊  imports: () => [commonModule, usersModule],\n+┊   ┊337┊});\n```\n\n[}]: #\n\nSince every module is now a GraphQL Module, we can take care of how to use them in the ApolloServer.\n\nTo make things easier, we're going to create a module that's called `Root` and represents our API.\n\n```ts\nexport const rootModule = new GraphQLModule({\n  name: 'root',\n  imports: [usersModule, chatsModule],\n});\n```\n\nWe want to pass `schema` and `context` to ApolloServer:\n\n```ts\nconst server = new ApolloServer({\n  schema: rootModule.schema,\n  context: rootModule.context,\n  // ...\n```\n\nNow with all that knowledge, take a look at all changes at once:\n\n[{]: <helper> (diffStep \"13.3\" files=\"index.ts\" module=\"server\")\n\n#### [__Server__ Step 13.3: Use GraphQL Modules](https://github.com/Urigo/WhatsApp-Clone-Server/commit/840b369)\n\n##### Changed index.ts\n```diff\n@@ -1,71 +1,23 @@\n ┊ 1┊ 1┊import { ApolloServer } from 'apollo-server-express';\n-┊ 2┊  ┊import cookie from 'cookie';\n+┊  ┊ 2┊import { GraphQLModule } from '@graphql-modules/core';\n ┊ 3┊ 3┊import http from 'http';\n-┊ 4┊  ┊import jwt from 'jsonwebtoken';\n ┊ 5┊ 4┊import { app } from './app';\n-┊ 6┊  ┊import { pool } from './db';\n-┊ 7┊  ┊import { origin, port, secret } from './env';\n+┊  ┊ 5┊import { origin, port } from './env';\n ┊ 8┊ 6┊import { MyContext } from './context';\n-┊ 9┊  ┊import sql from 'sql-template-strings';\n ┊10┊ 7┊import { UnsplashApi } from './schema/unsplash.api';\n-┊11┊  ┊const { PostgresPubSub } = require('graphql-postgres-subscriptions');\n ┊12┊ 8┊\n-┊13┊  ┊import * as commonModule from './modules/common';\n-┊14┊  ┊import * as usersModule from './modules/users';\n-┊15┊  ┊import * as chatsModule from './modules/chats';\n+┊  ┊ 9┊import usersModule from './modules/users';\n+┊  ┊10┊import chatsModule from './modules/chats';\n ┊16┊11┊\n-┊17┊  ┊const pubsub = new PostgresPubSub({\n-┊18┊  ┊  host: 'localhost',\n-┊19┊  ┊  port: 5432,\n-┊20┊  ┊  user: 'testuser',\n-┊21┊  ┊  password: 'testpassword',\n-┊22┊  ┊  database: 'whatsapp',\n+┊  ┊12┊export const rootModule = new GraphQLModule({\n+┊  ┊13┊  name: 'root',\n+┊  ┊14┊  imports: [usersModule, chatsModule],\n ┊23┊15┊});\n-┊24┊  ┊const server = new ApolloServer({\n-┊25┊  ┊  modules: [commonModule, usersModule, chatsModule],\n-┊26┊  ┊  context: async (session: any) => {\n-┊27┊  ┊    // Access the request object\n-┊28┊  ┊    let req = session.connection\n-┊29┊  ┊      ? session.connection.context.request\n-┊30┊  ┊      : session.req;\n-┊31┊  ┊\n-┊32┊  ┊    // It's subscription\n-┊33┊  ┊    if (session.connection) {\n-┊34┊  ┊      req.cookies = cookie.parse(req.headers.cookie || '');\n-┊35┊  ┊    }\n-┊36┊  ┊\n-┊37┊  ┊    let currentUser;\n-┊38┊  ┊    if (req.cookies.authToken) {\n-┊39┊  ┊      const username = jwt.verify(req.cookies.authToken, secret) as string;\n-┊40┊  ┊      if (username) {\n-┊41┊  ┊        const { rows } = await pool.query(\n-┊42┊  ┊          sql`SELECT * FROM users WHERE username = ${username}`\n-┊43┊  ┊        );\n-┊44┊  ┊        currentUser = rows[0];\n-┊45┊  ┊      }\n-┊46┊  ┊    }\n-┊47┊  ┊\n-┊48┊  ┊    let db;\n ┊49┊16┊\n-┊50┊  ┊    if (!session.connection) {\n-┊51┊  ┊      db = await pool.connect();\n-┊52┊  ┊    }\n-┊53┊  ┊\n-┊54┊  ┊    return {\n-┊55┊  ┊      currentUser,\n-┊56┊  ┊      pubsub,\n-┊57┊  ┊      db,\n-┊58┊  ┊      res: session.res,\n-┊59┊  ┊    };\n-┊60┊  ┊  },\n-┊61┊  ┊  subscriptions: {\n-┊62┊  ┊    onConnect(params, ws, ctx) {\n-┊63┊  ┊      // pass the request object to context\n-┊64┊  ┊      return {\n-┊65┊  ┊        request: ctx.request,\n-┊66┊  ┊      };\n-┊67┊  ┊    },\n-┊68┊  ┊  },\n+┊  ┊17┊const server = new ApolloServer({\n+┊  ┊18┊  schema: rootModule.schema,\n+┊  ┊19┊  context: rootModule.context,\n+┊  ┊20┊  subscriptions: rootModule.subscriptions,\n ┊69┊21┊  formatResponse: (res: any, { context }: { context: MyContext }) => {\n ┊70┊22┊    context.db.release();\n ┊71┊23┊\n```\n\n##### Changed modules&#x2F;chats&#x2F;index.ts\n```diff\n@@ -1,9 +1,12 @@\n+┊  ┊ 1┊import { GraphQLModule } from '@graphql-modules/core';\n ┊ 1┊ 2┊import { gql, withFilter } from 'apollo-server-express';\n ┊ 2┊ 3┊import sql from 'sql-template-strings';\n+┊  ┊ 4┊import commonModule from '../common';\n+┊  ┊ 5┊import usersModule from '../users';\n ┊ 3┊ 6┊import { Message, Chat, pool } from '../../db';\n ┊ 4┊ 7┊import { Resolvers } from '../../types/graphql';\n ┊ 5┊ 8┊\n-┊ 6┊  ┊export const typeDefs = gql`\n+┊  ┊ 9┊const typeDefs = gql`\n ┊ 7┊10┊  type Message {\n ┊ 8┊11┊    id: ID!\n ┊ 9┊12┊    content: String!\n```\n```diff\n@@ -41,7 +44,7 @@\n ┊41┊44┊  }\n ┊42┊45┊`;\n ┊43┊46┊\n-┊44┊  ┊export const resolvers: Resolvers = {\n+┊  ┊47┊const resolvers: Resolvers = {\n ┊45┊48┊  Message: {\n ┊46┊49┊    createdAt(message) {\n ┊47┊50┊      return new Date(message.created_at);\n```\n```diff\n@@ -325,3 +328,10 @@\n ┊325┊328┊    },\n ┊326┊329┊  },\n ┊327┊330┊};\n+┊   ┊331┊\n+┊   ┊332┊export default new GraphQLModule({\n+┊   ┊333┊  name: 'chats',\n+┊   ┊334┊  typeDefs,\n+┊   ┊335┊  resolvers,\n+┊   ┊336┊  imports: () => [commonModule, usersModule],\n+┊   ┊337┊});\n```\n\n##### Changed modules&#x2F;common&#x2F;index.ts\n```diff\n@@ -1,8 +1,12 @@\n+┊  ┊ 1┊import { GraphQLModule } from '@graphql-modules/core';\n ┊ 1┊ 2┊import { gql } from 'apollo-server-express';\n ┊ 2┊ 3┊import { GraphQLDateTime } from 'graphql-iso-date';\n+┊  ┊ 4┊import { pool } from '../../db';\n ┊ 3┊ 5┊import { Resolvers } from '../../types/graphql';\n ┊ 4┊ 6┊\n-┊ 5┊  ┊export const typeDefs = gql`\n+┊  ┊ 7┊const { PostgresPubSub } = require('graphql-postgres-subscriptions');\n+┊  ┊ 8┊\n+┊  ┊ 9┊const typeDefs = gql`\n ┊ 6┊10┊  scalar Date\n ┊ 7┊11┊\n ┊ 8┊12┊  type Query {\n```\n```diff\n@@ -18,6 +22,33 @@\n ┊18┊22┊  }\n ┊19┊23┊`;\n ┊20┊24┊\n-┊21┊  ┊export const resolvers: Resolvers = {\n+┊  ┊25┊const resolvers: Resolvers = {\n ┊22┊26┊  Date: GraphQLDateTime,\n ┊23┊27┊};\n+┊  ┊28┊\n+┊  ┊29┊const pubsub = new PostgresPubSub({\n+┊  ┊30┊  host: 'localhost',\n+┊  ┊31┊  port: 5432,\n+┊  ┊32┊  user: 'testuser',\n+┊  ┊33┊  password: 'testpassword',\n+┊  ┊34┊  database: 'whatsapp',\n+┊  ┊35┊});\n+┊  ┊36┊\n+┊  ┊37┊export default new GraphQLModule({\n+┊  ┊38┊  name: 'common',\n+┊  ┊39┊  typeDefs,\n+┊  ┊40┊  resolvers,\n+┊  ┊41┊  async context({ res, connection }) {\n+┊  ┊42┊    let db;\n+┊  ┊43┊\n+┊  ┊44┊    if (!connection) {\n+┊  ┊45┊      db = await pool.connect();\n+┊  ┊46┊    }\n+┊  ┊47┊\n+┊  ┊48┊    return {\n+┊  ┊49┊      pubsub,\n+┊  ┊50┊      res,\n+┊  ┊51┊      db,\n+┊  ┊52┊    };\n+┊  ┊53┊  },\n+┊  ┊54┊});\n```\n\n##### Changed modules&#x2F;users&#x2F;index.ts\n```diff\n@@ -1,12 +1,16 @@\n+┊  ┊ 1┊import { GraphQLModule } from '@graphql-modules/core';\n ┊ 1┊ 2┊import { gql } from 'apollo-server-express';\n+┊  ┊ 3┊import cookie from 'cookie';\n ┊ 2┊ 4┊import sql from 'sql-template-strings';\n ┊ 3┊ 5┊import bcrypt from 'bcrypt';\n ┊ 4┊ 6┊import jwt from 'jsonwebtoken';\n+┊  ┊ 7┊import commonModule from '../common';\n ┊ 5┊ 8┊import { secret, expiration } from '../../env';\n+┊  ┊ 9┊import { pool } from '../../db';\n ┊ 6┊10┊import { validateLength, validatePassword } from '../../validators';\n ┊ 7┊11┊import { Resolvers } from '../../types/graphql';\n ┊ 8┊12┊\n-┊ 9┊  ┊export const typeDefs = gql`\n+┊  ┊13┊const typeDefs = gql`\n ┊10┊14┊  type User {\n ┊11┊15┊    id: ID!\n ┊12┊16┊    name: String!\n```\n```diff\n@@ -29,7 +33,7 @@\n ┊29┊33┊  }\n ┊30┊34┊`;\n ┊31┊35┊\n-┊32┊  ┊export const resolvers: Resolvers = {\n+┊  ┊36┊const resolvers: Resolvers = {\n ┊33┊37┊  Query: {\n ┊34┊38┊    me(root, args, { currentUser }) {\n ┊35┊39┊      return currentUser || null;\n```\n```diff\n@@ -98,3 +102,38 @@\n ┊ 98┊102┊    },\n ┊ 99┊103┊  },\n ┊100┊104┊};\n+┊   ┊105┊\n+┊   ┊106┊export default new GraphQLModule({\n+┊   ┊107┊  name: 'users',\n+┊   ┊108┊  typeDefs,\n+┊   ┊109┊  resolvers,\n+┊   ┊110┊  imports: () => [commonModule],\n+┊   ┊111┊  async context(session) {\n+┊   ┊112┊    let currentUser;\n+┊   ┊113┊\n+┊   ┊114┊    // Access the request object\n+┊   ┊115┊    let req = session.connection\n+┊   ┊116┊      ? session.connection.context.request\n+┊   ┊117┊      : session.req;\n+┊   ┊118┊\n+┊   ┊119┊    // It's subscription\n+┊   ┊120┊    if (session.connection) {\n+┊   ┊121┊      req.cookies = cookie.parse(req.headers.cookie || '');\n+┊   ┊122┊    }\n+┊   ┊123┊\n+┊   ┊124┊    if (req.cookies.authToken) {\n+┊   ┊125┊      const username = jwt.verify(req.cookies.authToken, secret) as string;\n+┊   ┊126┊\n+┊   ┊127┊      if (username) {\n+┊   ┊128┊        const { rows } = await pool.query(\n+┊   ┊129┊          sql`SELECT * FROM users WHERE username = ${username}`\n+┊   ┊130┊        );\n+┊   ┊131┊        currentUser = rows[0];\n+┊   ┊132┊      }\n+┊   ┊133┊    }\n+┊   ┊134┊\n+┊   ┊135┊    return {\n+┊   ┊136┊      currentUser,\n+┊   ┊137┊    };\n+┊   ┊138┊  },\n+┊   ┊139┊});\n```\n\n[}]: #\n\n#### Migrate Unsplash API to Chats\n\nWe still make use of global context which won't work with GraphQL Modules. To be more specific, it's not the context definition itself but the thing that's being added by ApolloServer, Data Sources.\n\nThe `RESTDataSource` is of course more than a class but in case of Unsplash API we won't loose any important features except the HTTP client. We're going to use `axios` instead:\n\nyarn add axios\n\nWe've got everything now so let's migrate UnsplashAPI class and move it from `schema/unsplash.api.ts` under `modules/chats`!\n\n[{]: <helper> (diffStep \"13.3\" files=\"modules/chats/unsplash.api.ts\" module=\"server\")\n\n#### [__Server__ Step 13.3: Use GraphQL Modules](https://github.com/Urigo/WhatsApp-Clone-Server/commit/840b369)\n\n\n\n[}]: #\n\nThere is no big differences between now and what we had before, the only thing that's changed is the way we make http requests.\n\nThe `UnsplashAPI` can be now removed from `dataSources` and moved under Chats module's context:\n\n[{]: <helper> (diffStep \"13.3\" files=\"index.ts\" module=\"server\")\n\n#### [__Server__ Step 13.3: Use GraphQL Modules](https://github.com/Urigo/WhatsApp-Clone-Server/commit/840b369)\n\n##### Changed index.ts\n```diff\n@@ -1,71 +1,23 @@\n ┊ 1┊ 1┊import { ApolloServer } from 'apollo-server-express';\n-┊ 2┊  ┊import cookie from 'cookie';\n+┊  ┊ 2┊import { GraphQLModule } from '@graphql-modules/core';\n ┊ 3┊ 3┊import http from 'http';\n-┊ 4┊  ┊import jwt from 'jsonwebtoken';\n ┊ 5┊ 4┊import { app } from './app';\n-┊ 6┊  ┊import { pool } from './db';\n-┊ 7┊  ┊import { origin, port, secret } from './env';\n+┊  ┊ 5┊import { origin, port } from './env';\n ┊ 8┊ 6┊import { MyContext } from './context';\n-┊ 9┊  ┊import sql from 'sql-template-strings';\n ┊10┊ 7┊import { UnsplashApi } from './schema/unsplash.api';\n-┊11┊  ┊const { PostgresPubSub } = require('graphql-postgres-subscriptions');\n ┊12┊ 8┊\n-┊13┊  ┊import * as commonModule from './modules/common';\n-┊14┊  ┊import * as usersModule from './modules/users';\n-┊15┊  ┊import * as chatsModule from './modules/chats';\n+┊  ┊ 9┊import usersModule from './modules/users';\n+┊  ┊10┊import chatsModule from './modules/chats';\n ┊16┊11┊\n-┊17┊  ┊const pubsub = new PostgresPubSub({\n-┊18┊  ┊  host: 'localhost',\n-┊19┊  ┊  port: 5432,\n-┊20┊  ┊  user: 'testuser',\n-┊21┊  ┊  password: 'testpassword',\n-┊22┊  ┊  database: 'whatsapp',\n+┊  ┊12┊export const rootModule = new GraphQLModule({\n+┊  ┊13┊  name: 'root',\n+┊  ┊14┊  imports: [usersModule, chatsModule],\n ┊23┊15┊});\n-┊24┊  ┊const server = new ApolloServer({\n-┊25┊  ┊  modules: [commonModule, usersModule, chatsModule],\n-┊26┊  ┊  context: async (session: any) => {\n-┊27┊  ┊    // Access the request object\n-┊28┊  ┊    let req = session.connection\n-┊29┊  ┊      ? session.connection.context.request\n-┊30┊  ┊      : session.req;\n-┊31┊  ┊\n-┊32┊  ┊    // It's subscription\n-┊33┊  ┊    if (session.connection) {\n-┊34┊  ┊      req.cookies = cookie.parse(req.headers.cookie || '');\n-┊35┊  ┊    }\n-┊36┊  ┊\n-┊37┊  ┊    let currentUser;\n-┊38┊  ┊    if (req.cookies.authToken) {\n-┊39┊  ┊      const username = jwt.verify(req.cookies.authToken, secret) as string;\n-┊40┊  ┊      if (username) {\n-┊41┊  ┊        const { rows } = await pool.query(\n-┊42┊  ┊          sql`SELECT * FROM users WHERE username = ${username}`\n-┊43┊  ┊        );\n-┊44┊  ┊        currentUser = rows[0];\n-┊45┊  ┊      }\n-┊46┊  ┊    }\n-┊47┊  ┊\n-┊48┊  ┊    let db;\n ┊49┊16┊\n-┊50┊  ┊    if (!session.connection) {\n-┊51┊  ┊      db = await pool.connect();\n-┊52┊  ┊    }\n-┊53┊  ┊\n-┊54┊  ┊    return {\n-┊55┊  ┊      currentUser,\n-┊56┊  ┊      pubsub,\n-┊57┊  ┊      db,\n-┊58┊  ┊      res: session.res,\n-┊59┊  ┊    };\n-┊60┊  ┊  },\n-┊61┊  ┊  subscriptions: {\n-┊62┊  ┊    onConnect(params, ws, ctx) {\n-┊63┊  ┊      // pass the request object to context\n-┊64┊  ┊      return {\n-┊65┊  ┊        request: ctx.request,\n-┊66┊  ┊      };\n-┊67┊  ┊    },\n-┊68┊  ┊  },\n+┊  ┊17┊const server = new ApolloServer({\n+┊  ┊18┊  schema: rootModule.schema,\n+┊  ┊19┊  context: rootModule.context,\n+┊  ┊20┊  subscriptions: rootModule.subscriptions,\n ┊69┊21┊  formatResponse: (res: any, { context }: { context: MyContext }) => {\n ┊70┊22┊    context.db.release();\n ┊71┊23┊\n```\n\n##### Changed modules&#x2F;chats&#x2F;index.ts\n```diff\n@@ -1,9 +1,12 @@\n+┊  ┊ 1┊import { GraphQLModule } from '@graphql-modules/core';\n ┊ 1┊ 2┊import { gql, withFilter } from 'apollo-server-express';\n ┊ 2┊ 3┊import sql from 'sql-template-strings';\n+┊  ┊ 4┊import commonModule from '../common';\n+┊  ┊ 5┊import usersModule from '../users';\n ┊ 3┊ 6┊import { Message, Chat, pool } from '../../db';\n ┊ 4┊ 7┊import { Resolvers } from '../../types/graphql';\n ┊ 5┊ 8┊\n-┊ 6┊  ┊export const typeDefs = gql`\n+┊  ┊ 9┊const typeDefs = gql`\n ┊ 7┊10┊  type Message {\n ┊ 8┊11┊    id: ID!\n ┊ 9┊12┊    content: String!\n```\n```diff\n@@ -41,7 +44,7 @@\n ┊41┊44┊  }\n ┊42┊45┊`;\n ┊43┊46┊\n-┊44┊  ┊export const resolvers: Resolvers = {\n+┊  ┊47┊const resolvers: Resolvers = {\n ┊45┊48┊  Message: {\n ┊46┊49┊    createdAt(message) {\n ┊47┊50┊      return new Date(message.created_at);\n```\n```diff\n@@ -325,3 +328,10 @@\n ┊325┊328┊    },\n ┊326┊329┊  },\n ┊327┊330┊};\n+┊   ┊331┊\n+┊   ┊332┊export default new GraphQLModule({\n+┊   ┊333┊  name: 'chats',\n+┊   ┊334┊  typeDefs,\n+┊   ┊335┊  resolvers,\n+┊   ┊336┊  imports: () => [commonModule, usersModule],\n+┊   ┊337┊});\n```\n\n##### Changed modules&#x2F;common&#x2F;index.ts\n```diff\n@@ -1,8 +1,12 @@\n+┊  ┊ 1┊import { GraphQLModule } from '@graphql-modules/core';\n ┊ 1┊ 2┊import { gql } from 'apollo-server-express';\n ┊ 2┊ 3┊import { GraphQLDateTime } from 'graphql-iso-date';\n+┊  ┊ 4┊import { pool } from '../../db';\n ┊ 3┊ 5┊import { Resolvers } from '../../types/graphql';\n ┊ 4┊ 6┊\n-┊ 5┊  ┊export const typeDefs = gql`\n+┊  ┊ 7┊const { PostgresPubSub } = require('graphql-postgres-subscriptions');\n+┊  ┊ 8┊\n+┊  ┊ 9┊const typeDefs = gql`\n ┊ 6┊10┊  scalar Date\n ┊ 7┊11┊\n ┊ 8┊12┊  type Query {\n```\n```diff\n@@ -18,6 +22,33 @@\n ┊18┊22┊  }\n ┊19┊23┊`;\n ┊20┊24┊\n-┊21┊  ┊export const resolvers: Resolvers = {\n+┊  ┊25┊const resolvers: Resolvers = {\n ┊22┊26┊  Date: GraphQLDateTime,\n ┊23┊27┊};\n+┊  ┊28┊\n+┊  ┊29┊const pubsub = new PostgresPubSub({\n+┊  ┊30┊  host: 'localhost',\n+┊  ┊31┊  port: 5432,\n+┊  ┊32┊  user: 'testuser',\n+┊  ┊33┊  password: 'testpassword',\n+┊  ┊34┊  database: 'whatsapp',\n+┊  ┊35┊});\n+┊  ┊36┊\n+┊  ┊37┊export default new GraphQLModule({\n+┊  ┊38┊  name: 'common',\n+┊  ┊39┊  typeDefs,\n+┊  ┊40┊  resolvers,\n+┊  ┊41┊  async context({ res, connection }) {\n+┊  ┊42┊    let db;\n+┊  ┊43┊\n+┊  ┊44┊    if (!connection) {\n+┊  ┊45┊      db = await pool.connect();\n+┊  ┊46┊    }\n+┊  ┊47┊\n+┊  ┊48┊    return {\n+┊  ┊49┊      pubsub,\n+┊  ┊50┊      res,\n+┊  ┊51┊      db,\n+┊  ┊52┊    };\n+┊  ┊53┊  },\n+┊  ┊54┊});\n```\n\n##### Changed modules&#x2F;users&#x2F;index.ts\n```diff\n@@ -1,12 +1,16 @@\n+┊  ┊ 1┊import { GraphQLModule } from '@graphql-modules/core';\n ┊ 1┊ 2┊import { gql } from 'apollo-server-express';\n+┊  ┊ 3┊import cookie from 'cookie';\n ┊ 2┊ 4┊import sql from 'sql-template-strings';\n ┊ 3┊ 5┊import bcrypt from 'bcrypt';\n ┊ 4┊ 6┊import jwt from 'jsonwebtoken';\n+┊  ┊ 7┊import commonModule from '../common';\n ┊ 5┊ 8┊import { secret, expiration } from '../../env';\n+┊  ┊ 9┊import { pool } from '../../db';\n ┊ 6┊10┊import { validateLength, validatePassword } from '../../validators';\n ┊ 7┊11┊import { Resolvers } from '../../types/graphql';\n ┊ 8┊12┊\n-┊ 9┊  ┊export const typeDefs = gql`\n+┊  ┊13┊const typeDefs = gql`\n ┊10┊14┊  type User {\n ┊11┊15┊    id: ID!\n ┊12┊16┊    name: String!\n```\n```diff\n@@ -29,7 +33,7 @@\n ┊29┊33┊  }\n ┊30┊34┊`;\n ┊31┊35┊\n-┊32┊  ┊export const resolvers: Resolvers = {\n+┊  ┊36┊const resolvers: Resolvers = {\n ┊33┊37┊  Query: {\n ┊34┊38┊    me(root, args, { currentUser }) {\n ┊35┊39┊      return currentUser || null;\n```\n```diff\n@@ -98,3 +102,38 @@\n ┊ 98┊102┊    },\n ┊ 99┊103┊  },\n ┊100┊104┊};\n+┊   ┊105┊\n+┊   ┊106┊export default new GraphQLModule({\n+┊   ┊107┊  name: 'users',\n+┊   ┊108┊  typeDefs,\n+┊   ┊109┊  resolvers,\n+┊   ┊110┊  imports: () => [commonModule],\n+┊   ┊111┊  async context(session) {\n+┊   ┊112┊    let currentUser;\n+┊   ┊113┊\n+┊   ┊114┊    // Access the request object\n+┊   ┊115┊    let req = session.connection\n+┊   ┊116┊      ? session.connection.context.request\n+┊   ┊117┊      : session.req;\n+┊   ┊118┊\n+┊   ┊119┊    // It's subscription\n+┊   ┊120┊    if (session.connection) {\n+┊   ┊121┊      req.cookies = cookie.parse(req.headers.cookie || '');\n+┊   ┊122┊    }\n+┊   ┊123┊\n+┊   ┊124┊    if (req.cookies.authToken) {\n+┊   ┊125┊      const username = jwt.verify(req.cookies.authToken, secret) as string;\n+┊   ┊126┊\n+┊   ┊127┊      if (username) {\n+┊   ┊128┊        const { rows } = await pool.query(\n+┊   ┊129┊          sql`SELECT * FROM users WHERE username = ${username}`\n+┊   ┊130┊        );\n+┊   ┊131┊        currentUser = rows[0];\n+┊   ┊132┊      }\n+┊   ┊133┊    }\n+┊   ┊134┊\n+┊   ┊135┊    return {\n+┊   ┊136┊      currentUser,\n+┊   ┊137┊    };\n+┊   ┊138┊  },\n+┊   ┊139┊});\n```\n\n[}]: #\n\n[{]: <helper> (diffStep \"13.3\" files=\"context.ts\" module=\"server\")\n\n#### [__Server__ Step 13.3: Use GraphQL Modules](https://github.com/Urigo/WhatsApp-Clone-Server/commit/840b369)\n\n\n\n[}]: #\n\n[{]: <helper> (diffStep \"13.3\" files=\"modules/chats/index.ts\" module=\"server\")\n\n#### [__Server__ Step 13.3: Use GraphQL Modules](https://github.com/Urigo/WhatsApp-Clone-Server/commit/840b369)\n\n##### Changed modules&#x2F;chats&#x2F;index.ts\n```diff\n@@ -1,9 +1,12 @@\n+┊  ┊ 1┊import { GraphQLModule } from '@graphql-modules/core';\n ┊ 1┊ 2┊import { gql, withFilter } from 'apollo-server-express';\n ┊ 2┊ 3┊import sql from 'sql-template-strings';\n+┊  ┊ 4┊import commonModule from '../common';\n+┊  ┊ 5┊import usersModule from '../users';\n ┊ 3┊ 6┊import { Message, Chat, pool } from '../../db';\n ┊ 4┊ 7┊import { Resolvers } from '../../types/graphql';\n ┊ 5┊ 8┊\n-┊ 6┊  ┊export const typeDefs = gql`\n+┊  ┊ 9┊const typeDefs = gql`\n ┊ 7┊10┊  type Message {\n ┊ 8┊11┊    id: ID!\n ┊ 9┊12┊    content: String!\n```\n```diff\n@@ -41,7 +44,7 @@\n ┊41┊44┊  }\n ┊42┊45┊`;\n ┊43┊46┊\n-┊44┊  ┊export const resolvers: Resolvers = {\n+┊  ┊47┊const resolvers: Resolvers = {\n ┊45┊48┊  Message: {\n ┊46┊49┊    createdAt(message) {\n ┊47┊50┊      return new Date(message.created_at);\n```\n```diff\n@@ -325,3 +328,10 @@\n ┊325┊328┊    },\n ┊326┊329┊  },\n ┊327┊330┊};\n+┊   ┊331┊\n+┊   ┊332┊export default new GraphQLModule({\n+┊   ┊333┊  name: 'chats',\n+┊   ┊334┊  typeDefs,\n+┊   ┊335┊  resolvers,\n+┊   ┊336┊  imports: () => [commonModule, usersModule],\n+┊   ┊337┊});\n```\n\n[}]: #\n\n#### Dependency Injection in GraphQL Modules\n\nThe major feature of GraphQL Modules is the Dependency Injection. It's optional, you don't have to use it until it's really necessary. Even though WhatsApp clone doesn't need it yet, we're going to talk about DI and implement a simple thing, just for educational purpose.\n\nIf you're familiar with Dependency Injection then you will get it straight away. If not, please read about it here or here (**links**).\n\nTo start working with DI, we we need to install two packages:\n\nyarn add @graphql-modules/di reflect-metadata\n\nLet's now adjust the context type and import `reflect-metadata` into the project:\n\n[{]: <helper> (diffStep \"13.5\" files=\"context.ts\" module=\"server\")\n\n#### [__Server__ Step 13.5: Use Dependency Injection](https://github.com/Urigo/WhatsApp-Clone-Server/commit/c50b363)\n\n##### Changed context.ts\n```diff\n@@ -1,13 +1,12 @@\n ┊ 1┊ 1┊import { PubSub } from 'apollo-server-express';\n+┊  ┊ 2┊import { ModuleContext } from '@graphql-modules/core';\n ┊ 2┊ 3┊import { User } from './db';\n ┊ 3┊ 4┊import { Response } from 'express';\n ┊ 4┊ 5┊import { PoolClient } from 'pg';\n-┊ 5┊  ┊import { UnsplashApi } from './modules/chats/unsplash.api';\n ┊ 6┊ 6┊\n ┊ 7┊ 7┊export type MyContext = {\n ┊ 8┊ 8┊  pubsub: PubSub;\n ┊ 9┊ 9┊  currentUser: User;\n ┊10┊10┊  res: Response;\n ┊11┊11┊  db: PoolClient;\n-┊12┊  ┊  unsplashApi: UnsplashApi;\n-┊13┊  ┊};\n+┊  ┊12┊} & ModuleContext;\n```\n\n[}]: #\n\n[{]: <helper> (diffStep \"13.5\" files=\"index.ts\" module=\"server\")\n\n#### [__Server__ Step 13.5: Use Dependency Injection](https://github.com/Urigo/WhatsApp-Clone-Server/commit/c50b363)\n\n##### Changed index.ts\n```diff\n@@ -1,3 +1,4 @@\n+┊ ┊1┊import 'reflect-metadata';\n ┊1┊2┊import { ApolloServer } from 'apollo-server-express';\n ┊2┊3┊import { GraphQLModule } from '@graphql-modules/core';\n ┊3┊4┊import http from 'http';\n```\n\n##### Changed modules&#x2F;chats&#x2F;index.ts\n```diff\n@@ -11,7 +11,7 @@\n ┊11┊11┊  type Message {\n ┊12┊12┊    id: ID!\n ┊13┊13┊    content: String!\n-┊14┊  ┊    createdAt: Date!\n+┊  ┊14┊    createdAt: DateTime!\n ┊15┊15┊    chat: Chat\n ┊16┊16┊    sender: User\n ┊17┊17┊    recipient: User\n```\n```diff\n@@ -94,7 +94,7 @@\n ┊ 94┊ 94┊      return participant ? participant.name : null;\n ┊ 95┊ 95┊    },\n ┊ 96┊ 96┊\n-┊ 97┊   ┊    async picture(chat, args, { currentUser, db, unsplashApi }) {\n+┊   ┊ 97┊    async picture(chat, args, { currentUser, db, injector }) {\n ┊ 98┊ 98┊      if (!currentUser) return null;\n ┊ 99┊ 99┊\n ┊100┊100┊      const { rows } = await db.query(sql`\n```\n```diff\n@@ -107,7 +107,7 @@\n ┊107┊107┊\n ┊108┊108┊      return participant && participant.picture\n ┊109┊109┊        ? participant.picture\n-┊110┊   ┊        : unsplashApi.getRandomPhoto();\n+┊   ┊110┊        : injector.get(UnsplashApi).getRandomPhoto();\n ┊111┊111┊    },\n ┊112┊112┊\n ┊113┊113┊    async messages(chat, args, { db }) {\n```\n```diff\n@@ -335,9 +335,5 @@\n ┊335┊335┊  typeDefs,\n ┊336┊336┊  resolvers,\n ┊337┊337┊  imports: () => [commonModule, usersModule],\n-┊338┊   ┊  context() {\n-┊339┊   ┊    return {\n-┊340┊   ┊      unsplashApi: new UnsplashApi(),\n-┊341┊   ┊    };\n-┊342┊   ┊  },\n+┊   ┊338┊  providers: () => [UnsplashApi],\n ┊343┊339┊});\n```\n\n##### Changed modules&#x2F;common&#x2F;index.ts\n```diff\n@@ -7,7 +7,7 @@\n ┊ 7┊ 7┊const { PostgresPubSub } = require('graphql-postgres-subscriptions');\n ┊ 8┊ 8┊\n ┊ 9┊ 9┊const typeDefs = gql`\n-┊10┊  ┊  scalar Date\n+┊  ┊10┊  scalar DateTime\n ┊11┊11┊\n ┊12┊12┊  type Query {\n ┊13┊13┊    _dummy: Boolean\n```\n```diff\n@@ -23,7 +23,7 @@\n ┊23┊23┊`;\n ┊24┊24┊\n ┊25┊25┊const resolvers: Resolvers = {\n-┊26┊  ┊  Date: GraphQLDateTime,\n+┊  ┊26┊  DateTime: GraphQLDateTime,\n ┊27┊27┊};\n ┊28┊28┊\n ┊29┊29┊const pubsub = new PostgresPubSub({\n```\n\n[}]: #\n\nIn short, Iependency Injection will instantiate classes, manage dependencies between them and so on and in addition to that, the GraphQL Modules allows to define when each provider / class should be created. We call it scopes.\n\n- Application scope - provider is created when application starts (default)\n- Session - providers are constructed in the beginning of the network request, then kept until the network request is closed\n- Request - creates an instance each time you request it from the injector\n\nBecause our `UnsplashApi` doesn't have to be recreated on every request, we can easily use Application scope, which is the default. The `Injectable` decorator is just to attach some metadata to the class.\n\n[{]: <helper> (diffStep \"13.5\" files=\"modules/chats/unsplash.api.ts\" module=\"server\")\n\n#### [__Server__ Step 13.5: Use Dependency Injection](https://github.com/Urigo/WhatsApp-Clone-Server/commit/c50b363)\n\n##### Changed modules&#x2F;chats&#x2F;unsplash.api.ts\n```diff\n@@ -1,3 +1,4 @@\n+┊ ┊1┊import { Injectable, ProviderScope } from '@graphql-modules/di';\n ┊1┊2┊import { resolve } from 'path';\n ┊2┊3┊import axios from 'axios';\n ┊3┊4┊import { trackProvider } from '@safe-api/middleware';\n```\n```diff\n@@ -8,6 +9,9 @@\n ┊ 8┊ 9┊  orientation: 'landscape' | 'portrait' | 'squarish';\n ┊ 9┊10┊}\n ┊10┊11┊\n+┊  ┊12┊@Injectable({\n+┊  ┊13┊  scope: ProviderScope.Application,\n+┊  ┊14┊})\n ┊11┊15┊export class UnsplashApi {\n ┊12┊16┊  baseURL = 'https://api.unsplash.com/';\n ┊13┊17┊\n```\n\n[}]: #\n\nHere's how to register the UnsplashApi provider in Chats module:\n\n[{]: <helper> (diffStep \"13.5\" files=\"modules/chats/index.ts\" module=\"server\")\n\n#### [__Server__ Step 13.5: Use Dependency Injection](https://github.com/Urigo/WhatsApp-Clone-Server/commit/c50b363)\n\n##### Changed modules&#x2F;chats&#x2F;index.ts\n```diff\n@@ -11,7 +11,7 @@\n ┊11┊11┊  type Message {\n ┊12┊12┊    id: ID!\n ┊13┊13┊    content: String!\n-┊14┊  ┊    createdAt: Date!\n+┊  ┊14┊    createdAt: DateTime!\n ┊15┊15┊    chat: Chat\n ┊16┊16┊    sender: User\n ┊17┊17┊    recipient: User\n```\n```diff\n@@ -94,7 +94,7 @@\n ┊ 94┊ 94┊      return participant ? participant.name : null;\n ┊ 95┊ 95┊    },\n ┊ 96┊ 96┊\n-┊ 97┊   ┊    async picture(chat, args, { currentUser, db, unsplashApi }) {\n+┊   ┊ 97┊    async picture(chat, args, { currentUser, db, injector }) {\n ┊ 98┊ 98┊      if (!currentUser) return null;\n ┊ 99┊ 99┊\n ┊100┊100┊      const { rows } = await db.query(sql`\n```\n```diff\n@@ -107,7 +107,7 @@\n ┊107┊107┊\n ┊108┊108┊      return participant && participant.picture\n ┊109┊109┊        ? participant.picture\n-┊110┊   ┊        : unsplashApi.getRandomPhoto();\n+┊   ┊110┊        : injector.get(UnsplashApi).getRandomPhoto();\n ┊111┊111┊    },\n ┊112┊112┊\n ┊113┊113┊    async messages(chat, args, { db }) {\n```\n```diff\n@@ -335,9 +335,5 @@\n ┊335┊335┊  typeDefs,\n ┊336┊336┊  resolvers,\n ┊337┊337┊  imports: () => [commonModule, usersModule],\n-┊338┊   ┊  context() {\n-┊339┊   ┊    return {\n-┊340┊   ┊      unsplashApi: new UnsplashApi(),\n-┊341┊   ┊    };\n-┊342┊   ┊  },\n+┊   ┊338┊  providers: () => [UnsplashApi],\n ┊343┊339┊});\n```\n\n[}]: #\n\nPlease also take a look at `injector.get(UnsplashApi)` part. There's `injector` instance in every module's context that allows to consume providers and everything that is defined within DI. You simply pass a class / token to the `get` method and GraphQL Modules takes care of the rest.\n\n**What are the benefits of DI?**\n\nYou can have a different implementation of Users based on the same interface. Maybe right now you're using PostgreSQL but at some point a project will be migrated to MongoDB. You could do it through GraphQL context, of course but with Dependency Injection, GraphQL Modules is able to tell you exactly what's missing and where. It reduces boiler plate because instantiation is done by the injector, code is loosely coupled.\n\nHelps maintainability but also comes with few disadvantages. It's a bit complex concept to learn and what could be done on compile time (TypeScript) is moved to run-time.\n\nYou might find DI useful while testing. Let's say you want to test a query that involves `UnsplashApi` provider, you simply replace it with a mocked version without touching the context or internals and you get the expected result every single time.\n\nWe know there's only one provider by far, the `UnsplashApi`, but we're going to implement more and more in following steps.\n\n#### Continuing with DI\n\nWe want to have everything easily accesible and DI helps with that so let's move on and continue migrating things.\n\nOne of the shared objects is database connection and we're going to create a Database provider:\n\n[{]: <helper> (diffStep \"13.6\" files=\"modules/common/database.provider.ts\" module=\"server\")\n\n#### [__Server__ Step 13.6: Define Database provider](https://github.com/Urigo/WhatsApp-Clone-Server/commit/af6b5b8)\n\n##### Added modules&#x2F;common&#x2F;database.provider.ts\n```diff\n@@ -0,0 +1,26 @@\n+┊  ┊ 1┊import { Injectable, ProviderScope } from '@graphql-modules/di';\n+┊  ┊ 2┊import { OnResponse } from '@graphql-modules/core';\n+┊  ┊ 3┊import { Pool, PoolClient } from 'pg';\n+┊  ┊ 4┊\n+┊  ┊ 5┊@Injectable({\n+┊  ┊ 6┊  scope: ProviderScope.Session,\n+┊  ┊ 7┊})\n+┊  ┊ 8┊export class Database implements OnResponse {\n+┊  ┊ 9┊  private instance: PoolClient;\n+┊  ┊10┊\n+┊  ┊11┊  constructor(private pool: Pool) {}\n+┊  ┊12┊\n+┊  ┊13┊  async onRequest() {\n+┊  ┊14┊    this.instance = await this.pool.connect();\n+┊  ┊15┊  }\n+┊  ┊16┊\n+┊  ┊17┊  onResponse() {\n+┊  ┊18┊    if (this.instance) {\n+┊  ┊19┊      this.instance.release();\n+┊  ┊20┊    }\n+┊  ┊21┊  }\n+┊  ┊22┊\n+┊  ┊23┊  async getClient() {\n+┊  ┊24┊    return this.instance;\n+┊  ┊25┊  }\n+┊  ┊26┊}\n```\n\n[}]: #\n\nThings we did there:\n- Session scope was used, which makes sure our provider is created and destroyed on every GraphQL Operation\n- `onRequest` hook is called when a GraphQL Operation starts and we create a database connection in it.\n- `onResponse` hook is triggered when GraphQL Response is about to be sent to the consumer, so we destroy the connection there.\n- `getClient` method exposes the connection\n- `Pool` in constructor means we expect `Pool` to be injected into `Database` provider.\n\nNow we can define `Pool` token and register `Database`:\n\n[{]: <helper> (diffStep \"13.6\" files=\"modules/common/index.ts\" module=\"server\")\n\n#### [__Server__ Step 13.6: Define Database provider](https://github.com/Urigo/WhatsApp-Clone-Server/commit/af6b5b8)\n\n##### Changed modules&#x2F;common&#x2F;index.ts\n```diff\n@@ -1,8 +1,10 @@\n ┊ 1┊ 1┊import { GraphQLModule } from '@graphql-modules/core';\n ┊ 2┊ 2┊import { gql } from 'apollo-server-express';\n ┊ 3┊ 3┊import { GraphQLDateTime } from 'graphql-iso-date';\n+┊  ┊ 4┊import { Pool } from 'pg';\n ┊ 4┊ 5┊import { pool } from '../../db';\n ┊ 5┊ 6┊import { Resolvers } from '../../types/graphql';\n+┊  ┊ 7┊import { Database } from './database.provider';\n ┊ 6┊ 8┊\n ┊ 7┊ 9┊const { PostgresPubSub } = require('graphql-postgres-subscriptions');\n ┊ 8┊10┊\n```\n```diff\n@@ -38,6 +40,13 @@\n ┊38┊40┊  name: 'common',\n ┊39┊41┊  typeDefs,\n ┊40┊42┊  resolvers,\n+┊  ┊43┊  providers: () => [\n+┊  ┊44┊    {\n+┊  ┊45┊      provide: Pool,\n+┊  ┊46┊      useValue: pool,\n+┊  ┊47┊    },\n+┊  ┊48┊    Database,\n+┊  ┊49┊  ],\n ┊41┊50┊  async context({ res, connection }) {\n ┊42┊51┊    let db;\n```\n\n[}]: #\n\n[{]: <helper> (diffStep \"13.6\" files=\"modules/index.ts\" module=\"server\")\n\n#### [__Server__ Step 13.6: Define Database provider](https://github.com/Urigo/WhatsApp-Clone-Server/commit/af6b5b8)\n\n\n\n[}]: #\n\n#### Creating Users and Chats services\n\nIt's not really recommended to put logic in resolvers so we're going to create a layer with business logic. A good example of that are Users and Chats modules so let's start with the former.\n\nWe're going to create `Users` service and move `Query.users` logic into `findAllExcept` method:\n\n[{]: <helper> (diffStep \"13.7\" files=\"modules/users/users.provider.ts,modules/users/index.ts\" module=\"server\")\n\n#### [__Server__ Step 13.7: Basic User provider](https://github.com/Urigo/WhatsApp-Clone-Server/commit/1aa8838)\n\n##### Changed modules&#x2F;users&#x2F;index.ts\n```diff\n@@ -9,6 +9,7 @@\n ┊ 9┊ 9┊import { pool } from '../../db';\n ┊10┊10┊import { validateLength, validatePassword } from '../../validators';\n ┊11┊11┊import { Resolvers } from '../../types/graphql';\n+┊  ┊12┊import { Users } from './users.provider';\n ┊12┊13┊\n ┊13┊14┊const typeDefs = gql`\n ┊14┊15┊  type User {\n```\n```diff\n@@ -38,14 +39,10 @@\n ┊38┊39┊    me(root, args, { currentUser }) {\n ┊39┊40┊      return currentUser || null;\n ┊40┊41┊    },\n-┊41┊  ┊    async users(root, args, { currentUser, db }) {\n+┊  ┊42┊    async users(root, args, { currentUser, injector }) {\n ┊42┊43┊      if (!currentUser) return [];\n ┊43┊44┊\n-┊44┊  ┊      const { rows } = await db.query(sql`\n-┊45┊  ┊        SELECT * FROM users WHERE users.id != ${currentUser.id}\n-┊46┊  ┊      `);\n-┊47┊  ┊\n-┊48┊  ┊      return rows;\n+┊  ┊45┊      return injector.get(Users).findAllExcept(currentUser.id);\n ┊49┊46┊    },\n ┊50┊47┊  },\n ┊51┊48┊  Mutation: {\n```\n```diff\n@@ -108,6 +105,7 @@\n ┊108┊105┊  typeDefs,\n ┊109┊106┊  resolvers,\n ┊110┊107┊  imports: () => [commonModule],\n+┊   ┊108┊  providers: () => [Users],\n ┊111┊109┊  async context(session) {\n ┊112┊110┊    let currentUser;\n ┊113┊111┊\n```\n\n##### Added modules&#x2F;users&#x2F;users.provider.ts\n```diff\n@@ -0,0 +1,19 @@\n+┊  ┊ 1┊import { Injectable, Inject, ProviderScope } from '@graphql-modules/di';\n+┊  ┊ 2┊import sql from 'sql-template-strings';\n+┊  ┊ 3┊import { Database } from '../common/database.provider';\n+┊  ┊ 4┊\n+┊  ┊ 5┊@Injectable({\n+┊  ┊ 6┊  scope: ProviderScope.Session,\n+┊  ┊ 7┊})\n+┊  ┊ 8┊export class Users {\n+┊  ┊ 9┊  @Inject() private db: Database;\n+┊  ┊10┊\n+┊  ┊11┊  async findAllExcept(userId: string) {\n+┊  ┊12┊    const db = await this.db.getClient();\n+┊  ┊13┊    const { rows } = await db.query(\n+┊  ┊14┊      sql`SELECT * FROM users WHERE id != ${userId}`\n+┊  ┊15┊    );\n+┊  ┊16┊\n+┊  ┊17┊    return rows;\n+┊  ┊18┊  }\n+┊  ┊19┊}\n```\n\n[}]: #\n\nA very interesting thing to notice is `@Inject()` decorator.\n\n```ts\n@Inject() private db: Database;\n```\n\nThe @Inject, well... injects `Database` provider as `db` property so you don't have to use the `constructor`.\n\nBack to the Users service. It's very similar to what we did with the `UnsplashApi` so let's move on and implement more methods.\n\n[{]: <helper> (diffStep \"13.8\" module=\"server\")\n\n#### [__Server__ Step 13.8: Implement newUser and findByUsername](https://github.com/Urigo/WhatsApp-Clone-Server/commit/d76b3f7)\n\n##### Changed modules&#x2F;users&#x2F;index.ts\n```diff\n@@ -46,11 +46,8 @@\n ┊46┊46┊    },\n ┊47┊47┊  },\n ┊48┊48┊  Mutation: {\n-┊49┊  ┊    async signIn(root, { username, password }, { db, res }) {\n-┊50┊  ┊      const { rows } = await db.query(\n-┊51┊  ┊        sql`SELECT * FROM users WHERE username = ${username}`\n-┊52┊  ┊      );\n-┊53┊  ┊      const user = rows[0];\n+┊  ┊49┊    async signIn(root, { username, password }, { injector, res }) {\n+┊  ┊50┊      const user = await injector.get(Users).findByUsername(username);\n ┊54┊51┊\n ┊55┊52┊      if (!user) {\n ┊56┊53┊        throw new Error('user not found');\n```\n```diff\n@@ -69,7 +66,11 @@\n ┊69┊66┊      return user;\n ┊70┊67┊    },\n ┊71┊68┊\n-┊72┊  ┊    async signUp(root, { name, username, password, passwordConfirm }, { db }) {\n+┊  ┊69┊    async signUp(\n+┊  ┊70┊      root,\n+┊  ┊71┊      { name, username, password, passwordConfirm },\n+┊  ┊72┊      { injector }\n+┊  ┊73┊    ) {\n ┊73┊74┊      validateLength('req.name', name, 3, 50);\n ┊74┊75┊      validateLength('req.username', name, 3, 18);\n ┊75┊76┊      validatePassword('req.password', password);\n```\n```diff\n@@ -78,24 +79,18 @@\n ┊ 78┊ 79┊        throw Error(\"req.password and req.passwordConfirm don't match\");\n ┊ 79┊ 80┊      }\n ┊ 80┊ 81┊\n-┊ 81┊   ┊      const existingUserQuery = await db.query(\n-┊ 82┊   ┊        sql`SELECT * FROM users WHERE username = ${username}`\n-┊ 83┊   ┊      );\n-┊ 84┊   ┊      if (existingUserQuery.rows[0]) {\n+┊   ┊ 82┊      const existingUser = await injector.get(Users).findByUsername(username);\n+┊   ┊ 83┊      if (existingUser) {\n ┊ 85┊ 84┊        throw Error('username already exists');\n ┊ 86┊ 85┊      }\n ┊ 87┊ 86┊\n-┊ 88┊   ┊      const passwordHash = bcrypt.hashSync(password, bcrypt.genSaltSync(8));\n+┊   ┊ 87┊      const createdUser = await injector.get(Users).newUser({\n+┊   ┊ 88┊        username,\n+┊   ┊ 89┊        password,\n+┊   ┊ 90┊        name,\n+┊   ┊ 91┊      });\n ┊ 89┊ 92┊\n-┊ 90┊   ┊      const createdUserQuery = await db.query(sql`\n-┊ 91┊   ┊        INSERT INTO users(password, picture, username, name)\n-┊ 92┊   ┊        VALUES(${passwordHash}, '', ${username}, ${name})\n-┊ 93┊   ┊        RETURNING *\n-┊ 94┊   ┊      `);\n-┊ 95┊   ┊\n-┊ 96┊   ┊      const user = createdUserQuery.rows[0];\n-┊ 97┊   ┊\n-┊ 98┊   ┊      return user;\n+┊   ┊ 93┊      return createdUser;\n ┊ 99┊ 94┊    },\n ┊100┊ 95┊  },\n ┊101┊ 96┊};\n```\n\n##### Changed modules&#x2F;users&#x2F;users.provider.ts\n```diff\n@@ -1,7 +1,10 @@\n ┊ 1┊ 1┊import { Injectable, Inject, ProviderScope } from '@graphql-modules/di';\n ┊ 2┊ 2┊import sql from 'sql-template-strings';\n+┊  ┊ 3┊import bcrypt from 'bcrypt';\n ┊ 3┊ 4┊import { Database } from '../common/database.provider';\n ┊ 4┊ 5┊\n+┊  ┊ 6┊const DEFAULT_PROFILE_PIC = 'https://raw.githubusercontent.com/Urigo/WhatsApp-Clone-Client-React/legacy/public/assets/default-profile-pic.jpg'\n+┊  ┊ 7┊\n ┊ 5┊ 8┊@Injectable({\n ┊ 6┊ 9┊  scope: ProviderScope.Session,\n ┊ 7┊10┊})\n```\n```diff\n@@ -16,4 +19,34 @@\n ┊16┊19┊\n ┊17┊20┊    return rows;\n ┊18┊21┊  }\n+┊  ┊22┊\n+┊  ┊23┊  async findByUsername(username: string) {\n+┊  ┊24┊    const db = await this.db.getClient();\n+┊  ┊25┊    const { rows } = await db.query(\n+┊  ┊26┊      sql`SELECT * FROM users WHERE username = ${username}`\n+┊  ┊27┊    );\n+┊  ┊28┊\n+┊  ┊29┊    return rows[0] || null;\n+┊  ┊30┊  }\n+┊  ┊31┊\n+┊  ┊32┊  async newUser({\n+┊  ┊33┊    username,\n+┊  ┊34┊    name,\n+┊  ┊35┊    password,\n+┊  ┊36┊  }: {\n+┊  ┊37┊    username: string;\n+┊  ┊38┊    name: string;\n+┊  ┊39┊    password: string;\n+┊  ┊40┊  }) {\n+┊  ┊41┊    const db = await this.db.getClient();\n+┊  ┊42┊    const passwordHash = bcrypt.hashSync(password, bcrypt.genSaltSync(8));\n+┊  ┊43┊    const createdUserQuery = await db.query(sql`\n+┊  ┊44┊        INSERT INTO users(password, picture, username, name)\n+┊  ┊45┊        VALUES(${passwordHash}, ${DEFAULT_PROFILE_PIC}, ${username}, ${name})\n+┊  ┊46┊        RETURNING *\n+┊  ┊47┊      `);\n+┊  ┊48┊    const user = createdUserQuery.rows[0];\n+┊  ┊49┊\n+┊  ┊50┊    return user;\n+┊  ┊51┊  }\n ┊19┊52┊}\n```\n\n[}]: #\n[{]: <helper> (diffStep \"13.9\" module=\"server\")\n\n#### [__Server__ Step 13.9: Implement findById and use in Chats module](https://github.com/Urigo/WhatsApp-Clone-Server/commit/f41cca7)\n\n##### Changed modules&#x2F;chats&#x2F;index.ts\n```diff\n@@ -6,6 +6,7 @@\n ┊ 6┊ 6┊import { Message, Chat, pool } from '../../db';\n ┊ 7┊ 7┊import { Resolvers } from '../../types/graphql';\n ┊ 8┊ 8┊import { UnsplashApi } from './unsplash.api';\n+┊  ┊ 9┊import { Users } from './../users/users.provider';\n ┊ 9┊10┊\n ┊10┊11┊const typeDefs = gql`\n ┊11┊12┊  type Message {\n```\n```diff\n@@ -58,11 +59,8 @@\n ┊58┊59┊      return rows[0] || null;\n ┊59┊60┊    },\n ┊60┊61┊\n-┊61┊  ┊    async sender(message, args, { db }) {\n-┊62┊  ┊      const { rows } = await db.query(sql`\n-┊63┊  ┊        SELECT * FROM users WHERE id = ${message.sender_user_id}\n-┊64┊  ┊      `);\n-┊65┊  ┊      return rows[0] || null;\n+┊  ┊62┊    async sender(message, args, { injector }) {\n+┊  ┊63┊      return injector.get(Users).findById(message.sender_user_id);\n ┊66┊64┊    },\n ┊67┊65┊\n ┊68┊66┊    async recipient(message, args, { db }) {\n```\n\n##### Changed modules&#x2F;users&#x2F;users.provider.ts\n```diff\n@@ -11,6 +11,15 @@\n ┊11┊11┊export class Users {\n ┊12┊12┊  @Inject() private db: Database;\n ┊13┊13┊\n+┊  ┊14┊  async findById(userId: string) {\n+┊  ┊15┊    const db = await this.db.getClient();\n+┊  ┊16┊    const { rows } = await db.query(\n+┊  ┊17┊      sql`SELECT * FROM users WHERE id = ${userId}`\n+┊  ┊18┊    );\n+┊  ┊19┊\n+┊  ┊20┊    return rows[0] || null;\n+┊  ┊21┊  }\n+┊  ┊22┊\n ┊14┊23┊  async findAllExcept(userId: string) {\n ┊15┊24┊    const db = await this.db.getClient();\n ┊16┊25┊    const { rows } = await db.query(\n```\n\n[}]: #\n\nLet's now implement `Chats` service with two basic methods:\n\n[{]: <helper> (diffStep \"13.10\" module=\"server\")\n\n#### [__Server__ Step 13.10: Basic Chats provider](https://github.com/Urigo/WhatsApp-Clone-Server/commit/07458ac)\n\n##### Added modules&#x2F;chats&#x2F;chats.provider.ts\n```diff\n@@ -0,0 +1,34 @@\n+┊  ┊ 1┊import { Injectable, Inject, ProviderScope } from '@graphql-modules/di';\n+┊  ┊ 2┊import sql from 'sql-template-strings';\n+┊  ┊ 3┊import { Database } from '../common/database.provider';\n+┊  ┊ 4┊\n+┊  ┊ 5┊@Injectable({\n+┊  ┊ 6┊  scope: ProviderScope.Session,\n+┊  ┊ 7┊})\n+┊  ┊ 8┊export class Chats {\n+┊  ┊ 9┊  @Inject() private db: Database;\n+┊  ┊10┊\n+┊  ┊11┊  async findChatsByUser(userId: string) {\n+┊  ┊12┊    const db = await this.db.getClient();\n+┊  ┊13┊\n+┊  ┊14┊    const { rows } = await db.query(sql`\n+┊  ┊15┊      SELECT chats.* FROM chats, chats_users\n+┊  ┊16┊      WHERE chats.id = chats_users.chat_id\n+┊  ┊17┊      AND chats_users.user_id = ${userId}\n+┊  ┊18┊    `);\n+┊  ┊19┊\n+┊  ┊20┊    return rows;\n+┊  ┊21┊  }\n+┊  ┊22┊\n+┊  ┊23┊  async findChatByUser({ chatId, userId }: { chatId: string; userId: string }) {\n+┊  ┊24┊    const db = await this.db.getClient();\n+┊  ┊25┊    const { rows } = await db.query(sql`\n+┊  ┊26┊      SELECT chats.* FROM chats, chats_users\n+┊  ┊27┊      WHERE chats_users.chat_id = ${chatId}\n+┊  ┊28┊      AND chats.id = chats_users.chat_id\n+┊  ┊29┊      AND chats_users.user_id = ${userId}\n+┊  ┊30┊    `);\n+┊  ┊31┊\n+┊  ┊32┊    return rows[0] || null;\n+┊  ┊33┊  }\n+┊  ┊34┊}\n```\n\n##### Changed modules&#x2F;chats&#x2F;index.ts\n```diff\n@@ -7,6 +7,7 @@\n ┊ 7┊ 7┊import { Resolvers } from '../../types/graphql';\n ┊ 8┊ 8┊import { UnsplashApi } from './unsplash.api';\n ┊ 9┊ 9┊import { Users } from './../users/users.provider';\n+┊  ┊10┊import { Chats } from './chats.provider';\n ┊10┊11┊\n ┊11┊12┊const typeDefs = gql`\n ┊12┊13┊  type Message {\n```\n```diff\n@@ -138,29 +139,18 @@\n ┊138┊139┊  },\n ┊139┊140┊\n ┊140┊141┊  Query: {\n-┊141┊   ┊    async chats(root, args, { currentUser, db }) {\n+┊   ┊142┊    async chats(root, args, { currentUser, injector }) {\n ┊142┊143┊      if (!currentUser) return [];\n ┊143┊144┊\n-┊144┊   ┊      const { rows } = await db.query(sql`\n-┊145┊   ┊        SELECT chats.* FROM chats, chats_users\n-┊146┊   ┊        WHERE chats.id = chats_users.chat_id\n-┊147┊   ┊        AND chats_users.user_id = ${currentUser.id}\n-┊148┊   ┊      `);\n-┊149┊   ┊\n-┊150┊   ┊      return rows;\n+┊   ┊145┊      return injector.get(Chats).findChatsByUser(currentUser.id);\n ┊151┊146┊    },\n ┊152┊147┊\n-┊153┊   ┊    async chat(root, { chatId }, { currentUser, db }) {\n+┊   ┊148┊    async chat(root, { chatId }, { currentUser, injector }) {\n ┊154┊149┊      if (!currentUser) return null;\n ┊155┊150┊\n-┊156┊   ┊      const { rows } = await db.query(sql`\n-┊157┊   ┊        SELECT chats.* FROM chats, chats_users\n-┊158┊   ┊        WHERE chats_users.chat_id = ${chatId}\n-┊159┊   ┊        AND chats.id = chats_users.chat_id\n-┊160┊   ┊        AND chats_users.user_id = ${currentUser.id}\n-┊161┊   ┊      `);\n-┊162┊   ┊\n-┊163┊   ┊      return rows[0] ? rows[0] : null;\n+┊   ┊151┊      return injector\n+┊   ┊152┊        .get(Chats)\n+┊   ┊153┊        .findChatByUser({ chatId, userId: currentUser.id });\n ┊164┊154┊    },\n ┊165┊155┊  },\n ┊166┊156┊\n```\n```diff\n@@ -333,5 +323,5 @@\n ┊333┊323┊  typeDefs,\n ┊334┊324┊  resolvers,\n ┊335┊325┊  imports: () => [commonModule, usersModule],\n-┊336┊   ┊  providers: () => [UnsplashApi],\n+┊   ┊326┊  providers: () => [UnsplashApi, Chats],\n ┊337┊327┊});\n```\n\n[}]: #\n\nIt looks exatly like `Users` and also has only `database` provider in it.\n\nWe're going to move on and more things:\n\n[{]: <helper> (diffStep \"13.11\" module=\"server\")\n\n#### [__Server__ Step 13.11: Implement findChatById](https://github.com/Urigo/WhatsApp-Clone-Server/commit/043d833)\n\n##### Changed modules&#x2F;chats&#x2F;chats.provider.ts\n```diff\n@@ -31,4 +31,12 @@\n ┊31┊31┊\n ┊32┊32┊    return rows[0] || null;\n ┊33┊33┊  }\n+┊  ┊34┊\n+┊  ┊35┊  async findChatById(chatId: string) {\n+┊  ┊36┊    const db = await this.db.getClient();\n+┊  ┊37┊    const { rows } = await db.query(sql`\n+┊  ┊38┊      SELECT * FROM chats WHERE id = ${chatId}\n+┊  ┊39┊    `);\n+┊  ┊40┊    return rows[0] || null;\n+┊  ┊41┊  }\n ┊34┊42┊}\n```\n\n##### Changed modules&#x2F;chats&#x2F;index.ts\n```diff\n@@ -53,11 +53,8 @@\n ┊53┊53┊      return new Date(message.created_at);\n ┊54┊54┊    },\n ┊55┊55┊\n-┊56┊  ┊    async chat(message, args, { db }) {\n-┊57┊  ┊      const { rows } = await db.query(sql`\n-┊58┊  ┊        SELECT * FROM chats WHERE id = ${message.chat_id}\n-┊59┊  ┊      `);\n-┊60┊  ┊      return rows[0] || null;\n+┊  ┊56┊    async chat(message, args, { injector }) {\n+┊  ┊57┊      return injector.get(Chats).findChatById(message.chat_id);\n ┊61┊58┊    },\n ┊62┊59┊\n ┊63┊60┊    async sender(message, args, { injector }) {\n```\n\n[}]: #\n[{]: <helper> (diffStep \"13.12\" module=\"server\")\n\n#### [__Server__ Step 13.12: Find chat&#x27;s messages](https://github.com/Urigo/WhatsApp-Clone-Server/commit/4277bf8)\n\n##### Changed modules&#x2F;chats&#x2F;chats.provider.ts\n```diff\n@@ -39,4 +39,25 @@\n ┊39┊39┊    `);\n ┊40┊40┊    return rows[0] || null;\n ┊41┊41┊  }\n+┊  ┊42┊\n+┊  ┊43┊  async findMessagesByChat(chatId: string) {\n+┊  ┊44┊    const db = await this.db.getClient();\n+┊  ┊45┊    const { rows } = await db.query(\n+┊  ┊46┊      sql`SELECT * FROM messages WHERE chat_id = ${chatId}`\n+┊  ┊47┊    );\n+┊  ┊48┊\n+┊  ┊49┊    return rows;\n+┊  ┊50┊  }\n+┊  ┊51┊\n+┊  ┊52┊  async lastMessage(chatId: string) {\n+┊  ┊53┊    const db = await this.db.getClient();\n+┊  ┊54┊    const { rows } = await db.query(sql`\n+┊  ┊55┊      SELECT * FROM messages\n+┊  ┊56┊      WHERE chat_id = ${chatId}\n+┊  ┊57┊      ORDER BY created_at DESC\n+┊  ┊58┊      LIMIT 1\n+┊  ┊59┊    `);\n+┊  ┊60┊\n+┊  ┊61┊    return rows[0];\n+┊  ┊62┊  }\n ┊42┊63┊}\n```\n\n##### Changed modules&#x2F;chats&#x2F;index.ts\n```diff\n@@ -106,22 +106,12 @@\n ┊106┊106┊        : injector.get(UnsplashApi).getRandomPhoto();\n ┊107┊107┊    },\n ┊108┊108┊\n-┊109┊   ┊    async messages(chat, args, { db }) {\n-┊110┊   ┊      const { rows } = await db.query(\n-┊111┊   ┊        sql`SELECT * FROM messages WHERE chat_id = ${chat.id}`\n-┊112┊   ┊      );\n-┊113┊   ┊\n-┊114┊   ┊      return rows;\n+┊   ┊109┊    async messages(chat, args, { injector }) {\n+┊   ┊110┊      return injector.get(Chats).findMessagesByChat(chat.id);\n ┊115┊111┊    },\n ┊116┊112┊\n-┊117┊   ┊    async lastMessage(chat, args, { db }) {\n-┊118┊   ┊      const { rows } = await db.query(sql`\n-┊119┊   ┊        SELECT * FROM messages\n-┊120┊   ┊        WHERE chat_id = ${chat.id}\n-┊121┊   ┊        ORDER BY created_at DESC\n-┊122┊   ┊        LIMIT 1`);\n-┊123┊   ┊\n-┊124┊   ┊      return rows[0];\n+┊   ┊113┊    async lastMessage(chat, args, { injector }) {\n+┊   ┊114┊      return injector.get(Chats).lastMessage(chat.id);\n ┊125┊115┊    },\n ┊126┊116┊\n ┊127┊117┊    async participants(chat, args, { db }) {\n```\n\n[}]: #\n[{]: <helper> (diffStep \"13.13\" module=\"server\")\n\n#### [__Server__ Step 13.13: Find first participant](https://github.com/Urigo/WhatsApp-Clone-Server/commit/7450ff7)\n\n##### Changed modules&#x2F;chats&#x2F;chats.provider.ts\n```diff\n@@ -60,4 +60,16 @@\n ┊60┊60┊\n ┊61┊61┊    return rows[0];\n ┊62┊62┊  }\n+┊  ┊63┊\n+┊  ┊64┊  async firstRecipient({ chatId, userId }: { chatId: string; userId: string }) {\n+┊  ┊65┊    const db = await this.db.getClient();\n+┊  ┊66┊    const { rows } = await db.query(sql`\n+┊  ┊67┊      SELECT users.* FROM users, chats_users\n+┊  ┊68┊      WHERE users.id != ${userId}\n+┊  ┊69┊      AND users.id = chats_users.user_id\n+┊  ┊70┊      AND chats_users.chat_id = ${chatId}\n+┊  ┊71┊    `);\n+┊  ┊72┊\n+┊  ┊73┊    return rows[0] || null;\n+┊  ┊74┊  }\n ┊63┊75┊}\n```\n\n##### Changed modules&#x2F;chats&#x2F;index.ts\n```diff\n@@ -61,13 +61,11 @@\n ┊61┊61┊      return injector.get(Users).findById(message.sender_user_id);\n ┊62┊62┊    },\n ┊63┊63┊\n-┊64┊  ┊    async recipient(message, args, { db }) {\n-┊65┊  ┊      const { rows } = await db.query(sql`\n-┊66┊  ┊        SELECT users.* FROM users, chats_users\n-┊67┊  ┊        WHERE chats_users.user_id != ${message.sender_user_id}\n-┊68┊  ┊        AND chats_users.chat_id = ${message.chat_id}\n-┊69┊  ┊      `);\n-┊70┊  ┊      return rows[0] || null;\n+┊  ┊64┊    async recipient(message, args, { injector }) {\n+┊  ┊65┊      return injector.get(Chats).firstRecipient({\n+┊  ┊66┊        chatId: message.chat_id,\n+┊  ┊67┊        userId: message.sender_user_id,\n+┊  ┊68┊      });\n ┊71┊69┊    },\n ┊72┊70┊\n ┊73┊71┊    isMine(message, args, { currentUser }) {\n```\n```diff\n@@ -76,16 +74,13 @@\n ┊76┊74┊  },\n ┊77┊75┊\n ┊78┊76┊  Chat: {\n-┊79┊  ┊    async name(chat, args, { currentUser, db }) {\n+┊  ┊77┊    async name(chat, args, { currentUser, injector }) {\n ┊80┊78┊      if (!currentUser) return null;\n ┊81┊79┊\n-┊82┊  ┊      const { rows } = await db.query(sql`\n-┊83┊  ┊        SELECT users.* FROM users, chats_users\n-┊84┊  ┊        WHERE users.id != ${currentUser.id}\n-┊85┊  ┊        AND users.id = chats_users.user_id\n-┊86┊  ┊        AND chats_users.chat_id = ${chat.id}`);\n-┊87┊  ┊\n-┊88┊  ┊      const participant = rows[0];\n+┊  ┊80┊      const participant = await injector.get(Chats).firstRecipient({\n+┊  ┊81┊        chatId: chat.id,\n+┊  ┊82┊        userId: currentUser.id,\n+┊  ┊83┊      });\n ┊89┊84┊\n ┊90┊85┊      return participant ? participant.name : null;\n ┊91┊86┊    },\n```\n```diff\n@@ -93,13 +88,10 @@\n ┊ 93┊ 88┊    async picture(chat, args, { currentUser, db, injector }) {\n ┊ 94┊ 89┊      if (!currentUser) return null;\n ┊ 95┊ 90┊\n-┊ 96┊   ┊      const { rows } = await db.query(sql`\n-┊ 97┊   ┊        SELECT users.* FROM users, chats_users\n-┊ 98┊   ┊        WHERE users.id != ${currentUser.id}\n-┊ 99┊   ┊        AND users.id = chats_users.user_id\n-┊100┊   ┊        AND chats_users.chat_id = ${chat.id}`);\n-┊101┊   ┊\n-┊102┊   ┊      const participant = rows[0];\n+┊   ┊ 91┊      const participant = await injector.get(Chats).firstRecipient({\n+┊   ┊ 92┊        chatId: chat.id,\n+┊   ┊ 93┊        userId: currentUser.id,\n+┊   ┊ 94┊      });\n ┊103┊ 95┊\n ┊104┊ 96┊      return participant && participant.picture\n ┊105┊ 97┊        ? participant.picture\n```\n\n[}]: #\n[{]: <helper> (diffStep \"13.14\" module=\"server\")\n\n#### [__Server__ Step 13.14: Find all participants](https://github.com/Urigo/WhatsApp-Clone-Server/commit/c9ba8f1)\n\n##### Changed modules&#x2F;chats&#x2F;chats.provider.ts\n```diff\n@@ -72,4 +72,15 @@\n ┊72┊72┊\n ┊73┊73┊    return rows[0] || null;\n ┊74┊74┊  }\n+┊  ┊75┊\n+┊  ┊76┊  async participants(chatId: string) {\n+┊  ┊77┊    const db = await this.db.getClient();\n+┊  ┊78┊    const { rows } = await db.query(sql`\n+┊  ┊79┊      SELECT users.* FROM users, chats_users\n+┊  ┊80┊      WHERE chats_users.chat_id = ${chatId}\n+┊  ┊81┊      AND chats_users.user_id = users.id\n+┊  ┊82┊    `);\n+┊  ┊83┊\n+┊  ┊84┊    return rows;\n+┊  ┊85┊  }\n ┊75┊86┊}\n```\n\n##### Changed modules&#x2F;chats&#x2F;index.ts\n```diff\n@@ -106,14 +106,8 @@\n ┊106┊106┊      return injector.get(Chats).lastMessage(chat.id);\n ┊107┊107┊    },\n ┊108┊108┊\n-┊109┊   ┊    async participants(chat, args, { db }) {\n-┊110┊   ┊      const { rows } = await db.query(sql`\n-┊111┊   ┊        SELECT users.* FROM users, chats_users\n-┊112┊   ┊        WHERE chats_users.chat_id = ${chat.id}\n-┊113┊   ┊        AND chats_users.user_id = users.id\n-┊114┊   ┊      `);\n-┊115┊   ┊\n-┊116┊   ┊      return rows;\n+┊   ┊109┊    async participants(chat, args, { injector }) {\n+┊   ┊110┊      return injector.get(Chats).participants(chat.id);\n ┊117┊111┊    },\n ┊118┊112┊  },\n```\n\n[}]: #\n[{]: <helper> (diffStep \"13.15\" module=\"server\")\n\n#### [__Server__ Step 13.15: Check if a user belongs to a chat](https://github.com/Urigo/WhatsApp-Clone-Server/commit/2ebefe7)\n\n##### Changed modules&#x2F;chats&#x2F;chats.provider.ts\n```diff\n@@ -83,4 +83,15 @@\n ┊83┊83┊\n ┊84┊84┊    return rows;\n ┊85┊85┊  }\n+┊  ┊86┊\n+┊  ┊87┊  async isParticipant({ chatId, userId }: { chatId: string; userId: string }) {\n+┊  ┊88┊    const db = await this.db.getClient();\n+┊  ┊89┊    const { rows } = await db.query(sql`\n+┊  ┊90┊      SELECT * FROM chats_users\n+┊  ┊91┊      WHERE chat_id = ${chatId}\n+┊  ┊92┊      AND user_id = ${userId}\n+┊  ┊93┊    `);\n+┊  ┊94┊\n+┊  ┊95┊    return !!rows.length;\n+┊  ┊96┊  }\n ┊86┊97┊}\n```\n\n##### Changed modules&#x2F;chats&#x2F;index.ts\n```diff\n@@ -243,16 +243,14 @@\n ┊243┊243┊        async (\n ┊244┊244┊          { messageAdded }: { messageAdded: Message },\n ┊245┊245┊          args,\n-┊246┊   ┊          { currentUser }\n+┊   ┊246┊          { currentUser, injector }\n ┊247┊247┊        ) => {\n ┊248┊248┊          if (!currentUser) return false;\n ┊249┊249┊\n-┊250┊   ┊          const { rows } = await pool.query(sql`\n-┊251┊   ┊            SELECT * FROM chats_users\n-┊252┊   ┊            WHERE chat_id = ${messageAdded.chat_id}\n-┊253┊   ┊            AND user_id = ${currentUser.id}`);\n-┊254┊   ┊\n-┊255┊   ┊          return !!rows.length;\n+┊   ┊250┊          return injector.get(Chats).isParticipant({\n+┊   ┊251┊            chatId: messageAdded.chat_id,\n+┊   ┊252┊            userId: currentUser.id,\n+┊   ┊253┊          });\n ┊256┊254┊        }\n ┊257┊255┊      ),\n ┊258┊256┊    },\n```\n```diff\n@@ -260,15 +258,17 @@\n ┊260┊258┊    chatAdded: {\n ┊261┊259┊      subscribe: withFilter(\n ┊262┊260┊        (root, args, { pubsub }) => pubsub.asyncIterator('chatAdded'),\n-┊263┊   ┊        async ({ chatAdded }: { chatAdded: Chat }, args, { currentUser }) => {\n+┊   ┊261┊        async (\n+┊   ┊262┊          { chatAdded }: { chatAdded: Chat },\n+┊   ┊263┊          args,\n+┊   ┊264┊          { currentUser, injector }\n+┊   ┊265┊        ) => {\n ┊264┊266┊          if (!currentUser) return false;\n ┊265┊267┊\n-┊266┊   ┊          const { rows } = await pool.query(sql`\n-┊267┊   ┊            SELECT * FROM chats_users\n-┊268┊   ┊            WHERE chat_id = ${chatAdded.id}\n-┊269┊   ┊            AND user_id = ${currentUser.id}`);\n-┊270┊   ┊\n-┊271┊   ┊          return !!rows.length;\n+┊   ┊268┊          return injector.get(Chats).isParticipant({\n+┊   ┊269┊            chatId: chatAdded.id,\n+┊   ┊270┊            userId: currentUser.id,\n+┊   ┊271┊          });\n ┊272┊272┊        }\n ┊273┊273┊      ),\n ┊274┊274┊    },\n```\n```diff\n@@ -276,15 +276,17 @@\n ┊276┊276┊    chatRemoved: {\n ┊277┊277┊      subscribe: withFilter(\n ┊278┊278┊        (root, args, { pubsub }) => pubsub.asyncIterator('chatRemoved'),\n-┊279┊   ┊        async ({ targetChat }: { targetChat: Chat }, args, { currentUser }) => {\n+┊   ┊279┊        async (\n+┊   ┊280┊          { targetChat }: { targetChat: Chat },\n+┊   ┊281┊          args,\n+┊   ┊282┊          { currentUser, injector }\n+┊   ┊283┊        ) => {\n ┊280┊284┊          if (!currentUser) return false;\n ┊281┊285┊\n-┊282┊   ┊          const { rows } = await pool.query(sql`\n-┊283┊   ┊            SELECT * FROM chats_users\n-┊284┊   ┊            WHERE chat_id = ${targetChat.id}\n-┊285┊   ┊            AND user_id = ${currentUser.id}`);\n-┊286┊   ┊\n-┊287┊   ┊          return !!rows.length;\n+┊   ┊286┊          return injector.get(Chats).isParticipant({\n+┊   ┊287┊            chatId: targetChat.id,\n+┊   ┊288┊            userId: currentUser.id,\n+┊   ┊289┊          });\n ┊288┊290┊        }\n ┊289┊291┊      ),\n ┊290┊292┊    },\n```\n\n[}]: #\n\n#### Sharing PubSub\n\nOne of things that are still in the context is `PubSub`. Because we're moving an entire business logic into a separate layer and as part of GraphQL Module's providers we need to make sure that PubSub is accessible throug DI.\n\nLet's register the PubSub and migrate resolvers:\n\n[{]: <helper> (diffStep \"13.16\" module=\"server\")\n\n#### [__Server__ Step 13.16: Move PubSub to Dependency Injection](https://github.com/Urigo/WhatsApp-Clone-Server/commit/26504cd)\n\n##### Changed context.ts\n```diff\n@@ -1,11 +1,9 @@\n-┊ 1┊  ┊import { PubSub } from 'apollo-server-express';\n ┊ 2┊ 1┊import { ModuleContext } from '@graphql-modules/core';\n ┊ 3┊ 2┊import { User } from './db';\n ┊ 4┊ 3┊import { Response } from 'express';\n ┊ 5┊ 4┊import { PoolClient } from 'pg';\n ┊ 6┊ 5┊\n ┊ 7┊ 6┊export type MyContext = {\n-┊ 8┊  ┊  pubsub: PubSub;\n ┊ 9┊ 7┊  currentUser: User;\n ┊10┊ 8┊  res: Response;\n ┊11┊ 9┊  db: PoolClient;\n```\n\n##### Changed modules&#x2F;chats&#x2F;index.ts\n```diff\n@@ -8,6 +8,7 @@\n ┊ 8┊ 8┊import { UnsplashApi } from './unsplash.api';\n ┊ 9┊ 9┊import { Users } from './../users/users.provider';\n ┊10┊10┊import { Chats } from './chats.provider';\n+┊  ┊11┊import { PubSub } from '../common/pubsub.provider';\n ┊11┊12┊\n ┊12┊13┊const typeDefs = gql`\n ┊13┊14┊  type Message {\n```\n```diff\n@@ -128,7 +129,7 @@\n ┊128┊129┊  },\n ┊129┊130┊\n ┊130┊131┊  Mutation: {\n-┊131┊   ┊    async addMessage(root, { chatId, content }, { currentUser, pubsub, db }) {\n+┊   ┊132┊    async addMessage(root, { chatId, content }, { currentUser, injector, db }) {\n ┊132┊133┊      if (!currentUser) return null;\n ┊133┊134┊\n ┊134┊135┊      const { rows } = await db.query(sql`\n```\n```diff\n@@ -139,14 +140,14 @@\n ┊139┊140┊\n ┊140┊141┊      const messageAdded = rows[0];\n ┊141┊142┊\n-┊142┊   ┊      pubsub.publish('messageAdded', {\n+┊   ┊143┊      injector.get(PubSub).publish('messageAdded', {\n ┊143┊144┊        messageAdded,\n ┊144┊145┊      });\n ┊145┊146┊\n ┊146┊147┊      return messageAdded;\n ┊147┊148┊    },\n ┊148┊149┊\n-┊149┊   ┊    async addChat(root, { recipientId }, { currentUser, pubsub, db }) {\n+┊   ┊150┊    async addChat(root, { recipientId }, { currentUser, injector, db }) {\n ┊150┊151┊      if (!currentUser) return null;\n ┊151┊152┊\n ┊152┊153┊      const { rows } = await db.query(sql`\n```\n```diff\n@@ -186,7 +187,7 @@\n ┊186┊187┊\n ┊187┊188┊        await db.query('COMMIT');\n ┊188┊189┊\n-┊189┊   ┊        pubsub.publish('chatAdded', {\n+┊   ┊190┊        injector.get(PubSub).publish('chatAdded', {\n ┊190┊191┊          chatAdded,\n ┊191┊192┊        });\n ┊192┊193┊\n```\n```diff\n@@ -197,7 +198,7 @@\n ┊197┊198┊      }\n ┊198┊199┊    },\n ┊199┊200┊\n-┊200┊   ┊    async removeChat(root, { chatId }, { currentUser, pubsub, db }) {\n+┊   ┊201┊    async removeChat(root, { chatId }, { currentUser, injector, db }) {\n ┊201┊202┊      if (!currentUser) return null;\n ┊202┊203┊\n ┊203┊204┊      try {\n```\n```diff\n@@ -221,7 +222,7 @@\n ┊221┊222┊          DELETE FROM chats WHERE chats.id = ${chatId}\n ┊222┊223┊        `);\n ┊223┊224┊\n-┊224┊   ┊        pubsub.publish('chatRemoved', {\n+┊   ┊225┊        injector.get(PubSub).publish('chatRemoved', {\n ┊225┊226┊          chatRemoved: chat.id,\n ┊226┊227┊          targetChat: chat,\n ┊227┊228┊        });\n```\n```diff\n@@ -239,7 +240,8 @@\n ┊239┊240┊  Subscription: {\n ┊240┊241┊    messageAdded: {\n ┊241┊242┊      subscribe: withFilter(\n-┊242┊   ┊        (root, args, { pubsub }) => pubsub.asyncIterator('messageAdded'),\n+┊   ┊243┊        (root, args, { injector }) =>\n+┊   ┊244┊          injector.get(PubSub).asyncIterator('messageAdded'),\n ┊243┊245┊        async (\n ┊244┊246┊          { messageAdded }: { messageAdded: Message },\n ┊245┊247┊          args,\n```\n```diff\n@@ -257,7 +259,8 @@\n ┊257┊259┊\n ┊258┊260┊    chatAdded: {\n ┊259┊261┊      subscribe: withFilter(\n-┊260┊   ┊        (root, args, { pubsub }) => pubsub.asyncIterator('chatAdded'),\n+┊   ┊262┊        (root, args, { injector }) =>\n+┊   ┊263┊          injector.get(PubSub).asyncIterator('chatAdded'),\n ┊261┊264┊        async (\n ┊262┊265┊          { chatAdded }: { chatAdded: Chat },\n ┊263┊266┊          args,\n```\n```diff\n@@ -275,7 +278,8 @@\n ┊275┊278┊\n ┊276┊279┊    chatRemoved: {\n ┊277┊280┊      subscribe: withFilter(\n-┊278┊   ┊        (root, args, { pubsub }) => pubsub.asyncIterator('chatRemoved'),\n+┊   ┊281┊        (root, args, { injector }) =>\n+┊   ┊282┊          injector.get(PubSub).asyncIterator('chatRemoved'),\n ┊279┊283┊        async (\n ┊280┊284┊          { targetChat }: { targetChat: Chat },\n ┊281┊285┊          args,\n```\n\n##### Changed modules&#x2F;common&#x2F;index.ts\n```diff\n@@ -1,10 +1,12 @@\n ┊ 1┊ 1┊import { GraphQLModule } from '@graphql-modules/core';\n+┊  ┊ 2┊import { ProviderScope } from '@graphql-modules/di';\n ┊ 2┊ 3┊import { gql } from 'apollo-server-express';\n ┊ 3┊ 4┊import { GraphQLDateTime } from 'graphql-iso-date';\n ┊ 4┊ 5┊import { Pool } from 'pg';\n ┊ 5┊ 6┊import { pool } from '../../db';\n ┊ 6┊ 7┊import { Resolvers } from '../../types/graphql';\n ┊ 7┊ 8┊import { Database } from './database.provider';\n+┊  ┊ 9┊import { PubSub } from './pubsub.provider';\n ┊ 8┊10┊\n ┊ 9┊11┊const { PostgresPubSub } = require('graphql-postgres-subscriptions');\n ┊10┊12┊\n```\n```diff\n@@ -45,6 +47,11 @@\n ┊45┊47┊      provide: Pool,\n ┊46┊48┊      useValue: pool,\n ┊47┊49┊    },\n+┊  ┊50┊    {\n+┊  ┊51┊      provide: PubSub,\n+┊  ┊52┊      scope: ProviderScope.Application,\n+┊  ┊53┊      useValue: pubsub,\n+┊  ┊54┊    },\n ┊48┊55┊    Database,\n ┊49┊56┊  ],\n ┊50┊57┊  async context({ res, connection }) {\n```\n```diff\n@@ -55,7 +62,6 @@\n ┊55┊62┊    }\n ┊56┊63┊\n ┊57┊64┊    return {\n-┊58┊  ┊      pubsub,\n ┊59┊65┊      res,\n ┊60┊66┊      db,\n ┊61┊67┊    };\n```\n\n##### Added modules&#x2F;common&#x2F;pubsub.provider.ts\n```diff\n@@ -0,0 +1 @@\n+┊ ┊1┊export { PubSub } from 'apollo-server-express';\n```\n\n[}]: #\n\nNow, we're going to use `PubSub` within `Chats` service:\n\n[{]: <helper> (diffStep \"13.17\" module=\"server\")\n\n#### [__Server__ Step 13.17: Migrate addMessage to Chats provider](https://github.com/Urigo/WhatsApp-Clone-Server/commit/cdec452)\n\n##### Changed modules&#x2F;chats&#x2F;chats.provider.ts\n```diff\n@@ -1,12 +1,14 @@\n ┊ 1┊ 1┊import { Injectable, Inject, ProviderScope } from '@graphql-modules/di';\n ┊ 2┊ 2┊import sql from 'sql-template-strings';\n ┊ 3┊ 3┊import { Database } from '../common/database.provider';\n+┊  ┊ 4┊import { PubSub } from '../common/pubsub.provider';\n ┊ 4┊ 5┊\n ┊ 5┊ 6┊@Injectable({\n ┊ 6┊ 7┊  scope: ProviderScope.Session,\n ┊ 7┊ 8┊})\n ┊ 8┊ 9┊export class Chats {\n ┊ 9┊10┊  @Inject() private db: Database;\n+┊  ┊11┊  @Inject() private pubsub: PubSub;\n ┊10┊12┊\n ┊11┊13┊  async findChatsByUser(userId: string) {\n ┊12┊14┊    const db = await this.db.getClient();\n```\n```diff\n@@ -94,4 +96,29 @@\n ┊ 94┊ 96┊\n ┊ 95┊ 97┊    return !!rows.length;\n ┊ 96┊ 98┊  }\n+┊   ┊ 99┊\n+┊   ┊100┊  async addMessage({\n+┊   ┊101┊    chatId,\n+┊   ┊102┊    userId,\n+┊   ┊103┊    content,\n+┊   ┊104┊  }: {\n+┊   ┊105┊    chatId: string;\n+┊   ┊106┊    userId: string;\n+┊   ┊107┊    content: string;\n+┊   ┊108┊  }) {\n+┊   ┊109┊    const db = await this.db.getClient();\n+┊   ┊110┊    const { rows } = await db.query(sql`\n+┊   ┊111┊      INSERT INTO messages(chat_id, sender_user_id, content)\n+┊   ┊112┊      VALUES(${chatId}, ${userId}, ${content})\n+┊   ┊113┊      RETURNING *\n+┊   ┊114┊    `);\n+┊   ┊115┊\n+┊   ┊116┊    const messageAdded = rows[0];\n+┊   ┊117┊\n+┊   ┊118┊    this.pubsub.publish('messageAdded', {\n+┊   ┊119┊      messageAdded,\n+┊   ┊120┊    });\n+┊   ┊121┊\n+┊   ┊122┊    return messageAdded;\n+┊   ┊123┊  }\n ┊ 97┊124┊}\n```\n\n##### Changed modules&#x2F;chats&#x2F;index.ts\n```diff\n@@ -129,22 +129,12 @@\n ┊129┊129┊  },\n ┊130┊130┊\n ┊131┊131┊  Mutation: {\n-┊132┊   ┊    async addMessage(root, { chatId, content }, { currentUser, injector, db }) {\n+┊   ┊132┊    async addMessage(root, { chatId, content }, { currentUser, injector }) {\n ┊133┊133┊      if (!currentUser) return null;\n ┊134┊134┊\n-┊135┊   ┊      const { rows } = await db.query(sql`\n-┊136┊   ┊        INSERT INTO messages(chat_id, sender_user_id, content)\n-┊137┊   ┊        VALUES(${chatId}, ${currentUser.id}, ${content})\n-┊138┊   ┊        RETURNING *\n-┊139┊   ┊      `);\n-┊140┊   ┊\n-┊141┊   ┊      const messageAdded = rows[0];\n-┊142┊   ┊\n-┊143┊   ┊      injector.get(PubSub).publish('messageAdded', {\n-┊144┊   ┊        messageAdded,\n-┊145┊   ┊      });\n-┊146┊   ┊\n-┊147┊   ┊      return messageAdded;\n+┊   ┊135┊      return injector\n+┊   ┊136┊        .get(Chats)\n+┊   ┊137┊        .addMessage({ chatId, content, userId: currentUser.id });\n ┊148┊138┊    },\n ┊149┊139┊\n ┊150┊140┊    async addChat(root, { recipientId }, { currentUser, injector, db }) {\n```\n\n[}]: #\n[{]: <helper> (diffStep \"13.18\" module=\"server\")\n\n#### [__Server__ Step 13.18: Migrate addChat to Chats provider](https://github.com/Urigo/WhatsApp-Clone-Server/commit/45c2098)\n\n##### Changed modules&#x2F;chats&#x2F;chats.provider.ts\n```diff\n@@ -121,4 +121,58 @@\n ┊121┊121┊\n ┊122┊122┊    return messageAdded;\n ┊123┊123┊  }\n+┊   ┊124┊\n+┊   ┊125┊  async addChat({\n+┊   ┊126┊    userId,\n+┊   ┊127┊    recipientId,\n+┊   ┊128┊  }: {\n+┊   ┊129┊    userId: string;\n+┊   ┊130┊    recipientId: string;\n+┊   ┊131┊  }) {\n+┊   ┊132┊    const db = await this.db.getClient();\n+┊   ┊133┊    const { rows } = await db.query(sql`\n+┊   ┊134┊      SELECT chats.* FROM chats, (SELECT * FROM chats_users WHERE user_id = ${userId}) AS chats_of_current_user, chats_users\n+┊   ┊135┊      WHERE chats_users.chat_id = chats_of_current_user.chat_id\n+┊   ┊136┊      AND chats.id = chats_users.chat_id\n+┊   ┊137┊      AND chats_users.user_id = ${recipientId}\n+┊   ┊138┊    `);\n+┊   ┊139┊\n+┊   ┊140┊    // If there is already a chat between these two users, return it\n+┊   ┊141┊    if (rows[0]) {\n+┊   ┊142┊      return rows[0];\n+┊   ┊143┊    }\n+┊   ┊144┊\n+┊   ┊145┊    try {\n+┊   ┊146┊      await db.query('BEGIN');\n+┊   ┊147┊\n+┊   ┊148┊      const { rows } = await db.query(sql`\n+┊   ┊149┊        INSERT INTO chats\n+┊   ┊150┊        DEFAULT VALUES\n+┊   ┊151┊        RETURNING *\n+┊   ┊152┊      `);\n+┊   ┊153┊\n+┊   ┊154┊      const chatAdded = rows[0];\n+┊   ┊155┊\n+┊   ┊156┊      await db.query(sql`\n+┊   ┊157┊        INSERT INTO chats_users(chat_id, user_id)\n+┊   ┊158┊        VALUES(${chatAdded.id}, ${userId})\n+┊   ┊159┊      `);\n+┊   ┊160┊\n+┊   ┊161┊      await db.query(sql`\n+┊   ┊162┊        INSERT INTO chats_users(chat_id, user_id)\n+┊   ┊163┊        VALUES(${chatAdded.id}, ${recipientId})\n+┊   ┊164┊      `);\n+┊   ┊165┊\n+┊   ┊166┊      await db.query('COMMIT');\n+┊   ┊167┊\n+┊   ┊168┊      this.pubsub.publish('chatAdded', {\n+┊   ┊169┊        chatAdded,\n+┊   ┊170┊      });\n+┊   ┊171┊\n+┊   ┊172┊      return chatAdded;\n+┊   ┊173┊    } catch (e) {\n+┊   ┊174┊      await db.query('ROLLBACK');\n+┊   ┊175┊      throw e;\n+┊   ┊176┊    }\n+┊   ┊177┊  }\n ┊124┊178┊}\n```\n\n##### Changed modules&#x2F;chats&#x2F;index.ts\n```diff\n@@ -137,55 +137,12 @@\n ┊137┊137┊        .addMessage({ chatId, content, userId: currentUser.id });\n ┊138┊138┊    },\n ┊139┊139┊\n-┊140┊   ┊    async addChat(root, { recipientId }, { currentUser, injector, db }) {\n+┊   ┊140┊    async addChat(root, { recipientId }, { currentUser, injector }) {\n ┊141┊141┊      if (!currentUser) return null;\n ┊142┊142┊\n-┊143┊   ┊      const { rows } = await db.query(sql`\n-┊144┊   ┊        SELECT chats.* FROM chats, (SELECT * FROM chats_users WHERE user_id = ${\n-┊145┊   ┊          currentUser.id\n-┊146┊   ┊        }) AS chats_of_current_user, chats_users\n-┊147┊   ┊        WHERE chats_users.chat_id = chats_of_current_user.chat_id\n-┊148┊   ┊        AND chats.id = chats_users.chat_id\n-┊149┊   ┊        AND chats_users.user_id = ${recipientId}\n-┊150┊   ┊      `);\n-┊151┊   ┊\n-┊152┊   ┊      // If there is already a chat between these two users, return it\n-┊153┊   ┊      if (rows[0]) {\n-┊154┊   ┊        return rows[0];\n-┊155┊   ┊      }\n-┊156┊   ┊\n-┊157┊   ┊      try {\n-┊158┊   ┊        await db.query('BEGIN');\n-┊159┊   ┊\n-┊160┊   ┊        const { rows } = await db.query(sql`\n-┊161┊   ┊          INSERT INTO chats\n-┊162┊   ┊          DEFAULT VALUES\n-┊163┊   ┊          RETURNING *\n-┊164┊   ┊        `);\n-┊165┊   ┊\n-┊166┊   ┊        const chatAdded = rows[0];\n-┊167┊   ┊\n-┊168┊   ┊        await db.query(sql`\n-┊169┊   ┊          INSERT INTO chats_users(chat_id, user_id)\n-┊170┊   ┊          VALUES(${chatAdded.id}, ${currentUser.id})\n-┊171┊   ┊        `);\n-┊172┊   ┊\n-┊173┊   ┊        await db.query(sql`\n-┊174┊   ┊          INSERT INTO chats_users(chat_id, user_id)\n-┊175┊   ┊          VALUES(${chatAdded.id}, ${recipientId})\n-┊176┊   ┊        `);\n-┊177┊   ┊\n-┊178┊   ┊        await db.query('COMMIT');\n-┊179┊   ┊\n-┊180┊   ┊        injector.get(PubSub).publish('chatAdded', {\n-┊181┊   ┊          chatAdded,\n-┊182┊   ┊        });\n-┊183┊   ┊\n-┊184┊   ┊        return chatAdded;\n-┊185┊   ┊      } catch (e) {\n-┊186┊   ┊        await db.query('ROLLBACK');\n-┊187┊   ┊        throw e;\n-┊188┊   ┊      }\n+┊   ┊143┊      return injector\n+┊   ┊144┊        .get(Chats)\n+┊   ┊145┊        .addChat({ recipientId, userId: currentUser.id });\n ┊189┊146┊    },\n ┊190┊147┊\n ┊191┊148┊    async removeChat(root, { chatId }, { currentUser, injector, db }) {\n```\n\n[}]: #\n[{]: <helper> (diffStep \"13.19\" module=\"server\")\n\n#### [__Server__ Step 13.19: Migrate removeChat to Chats provider](https://github.com/Urigo/WhatsApp-Clone-Server/commit/16d3d4b)\n\n##### Changed modules&#x2F;chats&#x2F;chats.provider.ts\n```diff\n@@ -175,4 +175,42 @@\n ┊175┊175┊      throw e;\n ┊176┊176┊    }\n ┊177┊177┊  }\n+┊   ┊178┊\n+┊   ┊179┊  async removeChat({ chatId, userId }: { chatId: string; userId: string }) {\n+┊   ┊180┊    const db = await this.db.getClient();\n+┊   ┊181┊\n+┊   ┊182┊    try {\n+┊   ┊183┊      await db.query('BEGIN');\n+┊   ┊184┊\n+┊   ┊185┊      const { rows } = await db.query(sql`\n+┊   ┊186┊        SELECT chats.* FROM chats, chats_users\n+┊   ┊187┊        WHERE id = ${chatId}\n+┊   ┊188┊        AND chats.id = chats_users.chat_id\n+┊   ┊189┊        AND chats_users.user_id = ${userId}\n+┊   ┊190┊      `);\n+┊   ┊191┊\n+┊   ┊192┊      const chat = rows[0];\n+┊   ┊193┊\n+┊   ┊194┊      if (!chat) {\n+┊   ┊195┊        await db.query('ROLLBACK');\n+┊   ┊196┊        return null;\n+┊   ┊197┊      }\n+┊   ┊198┊\n+┊   ┊199┊      await db.query(sql`\n+┊   ┊200┊        DELETE FROM chats WHERE chats.id = ${chatId}\n+┊   ┊201┊      `);\n+┊   ┊202┊\n+┊   ┊203┊      this.pubsub.publish('chatRemoved', {\n+┊   ┊204┊        chatRemoved: chat.id,\n+┊   ┊205┊        targetChat: chat,\n+┊   ┊206┊      });\n+┊   ┊207┊\n+┊   ┊208┊      await db.query('COMMIT');\n+┊   ┊209┊\n+┊   ┊210┊      return chatId;\n+┊   ┊211┊    } catch (e) {\n+┊   ┊212┊      await db.query('ROLLBACK');\n+┊   ┊213┊      throw e;\n+┊   ┊214┊    }\n+┊   ┊215┊  }\n ┊178┊216┊}\n```\n\n##### Changed modules&#x2F;chats&#x2F;index.ts\n```diff\n@@ -145,42 +145,10 @@\n ┊145┊145┊        .addChat({ recipientId, userId: currentUser.id });\n ┊146┊146┊    },\n ┊147┊147┊\n-┊148┊   ┊    async removeChat(root, { chatId }, { currentUser, injector, db }) {\n+┊   ┊148┊    async removeChat(root, { chatId }, { currentUser, injector }) {\n ┊149┊149┊      if (!currentUser) return null;\n ┊150┊150┊\n-┊151┊   ┊      try {\n-┊152┊   ┊        await db.query('BEGIN');\n-┊153┊   ┊\n-┊154┊   ┊        const { rows } = await db.query(sql`\n-┊155┊   ┊          SELECT chats.* FROM chats, chats_users\n-┊156┊   ┊          WHERE id = ${chatId}\n-┊157┊   ┊          AND chats.id = chats_users.chat_id\n-┊158┊   ┊          AND chats_users.user_id = ${currentUser.id}\n-┊159┊   ┊        `);\n-┊160┊   ┊\n-┊161┊   ┊        const chat = rows[0];\n-┊162┊   ┊\n-┊163┊   ┊        if (!chat) {\n-┊164┊   ┊          await db.query('ROLLBACK');\n-┊165┊   ┊          return null;\n-┊166┊   ┊        }\n-┊167┊   ┊\n-┊168┊   ┊        await db.query(sql`\n-┊169┊   ┊          DELETE FROM chats WHERE chats.id = ${chatId}\n-┊170┊   ┊        `);\n-┊171┊   ┊\n-┊172┊   ┊        injector.get(PubSub).publish('chatRemoved', {\n-┊173┊   ┊          chatRemoved: chat.id,\n-┊174┊   ┊          targetChat: chat,\n-┊175┊   ┊        });\n-┊176┊   ┊\n-┊177┊   ┊        await db.query('COMMIT');\n-┊178┊   ┊\n-┊179┊   ┊        return chatId;\n-┊180┊   ┊      } catch (e) {\n-┊181┊   ┊        await db.query('ROLLBACK');\n-┊182┊   ┊        throw e;\n-┊183┊   ┊      }\n+┊   ┊151┊      return injector.get(Chats).removeChat({ chatId, userId: currentUser.id });\n ┊184┊152┊    },\n ┊185┊153┊  },\n```\n\n[}]: #\n\n#### Implementing Auth service\n\nThe last missing piece of our \"context migration\" journey is `currentUser` object. We're going to define the `Auth` service.\n\n[{]: <helper> (diffStep \"13.20\" files=\"modules/users/auth.provider.ts\" module=\"server\")\n\n#### [__Server__ Step 13.20: Implement Auth provider with currentUser method](https://github.com/Urigo/WhatsApp-Clone-Server/commit/0178527)\n\n##### Added modules&#x2F;users&#x2F;auth.provider.ts\n```diff\n@@ -0,0 +1,30 @@\n+┊  ┊ 1┊import { Injectable, Inject, ProviderScope } from '@graphql-modules/di';\n+┊  ┊ 2┊import { ModuleSessionInfo } from '@graphql-modules/core';\n+┊  ┊ 3┊import jwt from 'jsonwebtoken';\n+┊  ┊ 4┊import { secret } from '../../env';\n+┊  ┊ 5┊import { Users } from './users.provider';\n+┊  ┊ 6┊import { User } from '../../db';\n+┊  ┊ 7┊\n+┊  ┊ 8┊@Injectable({\n+┊  ┊ 9┊  scope: ProviderScope.Session,\n+┊  ┊10┊})\n+┊  ┊11┊export class Auth {\n+┊  ┊12┊  @Inject() private users: Users;\n+┊  ┊13┊  @Inject() private module: ModuleSessionInfo;\n+┊  ┊14┊\n+┊  ┊15┊  private get req() {\n+┊  ┊16┊    return this.module.session.req || this.module.session.request;\n+┊  ┊17┊  }\n+┊  ┊18┊\n+┊  ┊19┊  async currentUser(): Promise<User | null> {\n+┊  ┊20┊    if (this.req.cookies.authToken) {\n+┊  ┊21┊      const username = jwt.verify(this.req.cookies.authToken, secret) as string;\n+┊  ┊22┊\n+┊  ┊23┊      if (username) {\n+┊  ┊24┊        return this.users.findByUsername(username);\n+┊  ┊25┊      }\n+┊  ┊26┊    }\n+┊  ┊27┊\n+┊  ┊28┊    return null;\n+┊  ┊29┊  }\n+┊  ┊30┊}\n```\n\n[}]: #\n\nIt still needs to be registered and few resolvers in Users module have to be migrated:\n\n[{]: <helper> (diffStep \"13.20\" files=\"modules/users/index.ts, context.ts\" module=\"server\")\n\n#### [__Server__ Step 13.20: Implement Auth provider with currentUser method](https://github.com/Urigo/WhatsApp-Clone-Server/commit/0178527)\n\n##### Changed context.ts\n```diff\n@@ -1,10 +1,8 @@\n ┊ 1┊ 1┊import { ModuleContext } from '@graphql-modules/core';\n-┊ 2┊  ┊import { User } from './db';\n ┊ 3┊ 2┊import { Response } from 'express';\n ┊ 4┊ 3┊import { PoolClient } from 'pg';\n ┊ 5┊ 4┊\n ┊ 6┊ 5┊export type MyContext = {\n-┊ 7┊  ┊  currentUser: User;\n ┊ 8┊ 6┊  res: Response;\n ┊ 9┊ 7┊  db: PoolClient;\n ┊10┊ 8┊} & ModuleContext;\n```\n\n##### Changed modules&#x2F;users&#x2F;index.ts\n```diff\n@@ -1,6 +1,5 @@\n ┊1┊1┊import { GraphQLModule } from '@graphql-modules/core';\n ┊2┊2┊import { gql } from 'apollo-server-express';\n-┊3┊ ┊import cookie from 'cookie';\n ┊4┊3┊import sql from 'sql-template-strings';\n ┊5┊4┊import bcrypt from 'bcrypt';\n ┊6┊5┊import jwt from 'jsonwebtoken';\n```\n```diff\n@@ -10,6 +9,7 @@\n ┊10┊ 9┊import { validateLength, validatePassword } from '../../validators';\n ┊11┊10┊import { Resolvers } from '../../types/graphql';\n ┊12┊11┊import { Users } from './users.provider';\n+┊  ┊12┊import { Auth } from './auth.provider';\n ┊13┊13┊\n ┊14┊14┊const typeDefs = gql`\n ┊15┊15┊  type User {\n```\n```diff\n@@ -36,10 +36,12 @@\n ┊36┊36┊\n ┊37┊37┊const resolvers: Resolvers = {\n ┊38┊38┊  Query: {\n-┊39┊  ┊    me(root, args, { currentUser }) {\n-┊40┊  ┊      return currentUser || null;\n+┊  ┊39┊    me(root, args, { injector }) {\n+┊  ┊40┊      return injector.get(Auth).currentUser();\n ┊41┊41┊    },\n-┊42┊  ┊    async users(root, args, { currentUser, injector }) {\n+┊  ┊42┊    async users(root, args, { injector }) {\n+┊  ┊43┊      const currentUser = await injector.get(Auth).currentUser();\n+┊  ┊44┊\n ┊43┊45┊      if (!currentUser) return [];\n ┊44┊46┊\n ┊45┊47┊      return injector.get(Users).findAllExcept(currentUser.id);\n```\n```diff\n@@ -100,33 +102,5 @@\n ┊100┊102┊  typeDefs,\n ┊101┊103┊  resolvers,\n ┊102┊104┊  imports: () => [commonModule],\n-┊103┊   ┊  providers: () => [Users],\n-┊104┊   ┊  async context(session) {\n-┊105┊   ┊    let currentUser;\n-┊106┊   ┊\n-┊107┊   ┊    // Access the request object\n-┊108┊   ┊    let req = session.connection\n-┊109┊   ┊      ? session.connection.context.request\n-┊110┊   ┊      : session.req;\n-┊111┊   ┊\n-┊112┊   ┊    // It's subscription\n-┊113┊   ┊    if (session.connection) {\n-┊114┊   ┊      req.cookies = cookie.parse(req.headers.cookie || '');\n-┊115┊   ┊    }\n-┊116┊   ┊\n-┊117┊   ┊    if (req.cookies.authToken) {\n-┊118┊   ┊      const username = jwt.verify(req.cookies.authToken, secret) as string;\n-┊119┊   ┊\n-┊120┊   ┊      if (username) {\n-┊121┊   ┊        const { rows } = await pool.query(\n-┊122┊   ┊          sql`SELECT * FROM users WHERE username = ${username}`\n-┊123┊   ┊        );\n-┊124┊   ┊        currentUser = rows[0];\n-┊125┊   ┊      }\n-┊126┊   ┊    }\n-┊127┊   ┊\n-┊128┊   ┊    return {\n-┊129┊   ┊      currentUser,\n-┊130┊   ┊    };\n-┊131┊   ┊  },\n+┊   ┊105┊  providers: () => [Users, Auth],\n ┊132┊106┊});\n```\n\n[}]: #\n\nNow let's use the Auth service in Chats:\n\n[{]: <helper> (diffStep \"13.20\" files=\"modules/chats/index.ts\" module=\"server\")\n\n#### [__Server__ Step 13.20: Implement Auth provider with currentUser method](https://github.com/Urigo/WhatsApp-Clone-Server/commit/0178527)\n\n##### Changed modules&#x2F;chats&#x2F;index.ts\n```diff\n@@ -7,6 +7,7 @@\n ┊ 7┊ 7┊import { Resolvers } from '../../types/graphql';\n ┊ 8┊ 8┊import { UnsplashApi } from './unsplash.api';\n ┊ 9┊ 9┊import { Users } from './../users/users.provider';\n+┊  ┊10┊import { Auth } from './../users/auth.provider';\n ┊10┊11┊import { Chats } from './chats.provider';\n ┊11┊12┊import { PubSub } from '../common/pubsub.provider';\n ┊12┊13┊\n```\n```diff\n@@ -69,13 +70,16 @@\n ┊69┊70┊      });\n ┊70┊71┊    },\n ┊71┊72┊\n-┊72┊  ┊    isMine(message, args, { currentUser }) {\n-┊73┊  ┊      return message.sender_user_id === currentUser.id;\n+┊  ┊73┊    async isMine(message, args, { injector }) {\n+┊  ┊74┊      const currentUser = await injector.get(Auth).currentUser();\n+┊  ┊75┊      return message.sender_user_id === currentUser!.id;\n ┊74┊76┊    },\n ┊75┊77┊  },\n ┊76┊78┊\n ┊77┊79┊  Chat: {\n-┊78┊  ┊    async name(chat, args, { currentUser, injector }) {\n+┊  ┊80┊    async name(chat, args, { injector }) {\n+┊  ┊81┊      const currentUser = await injector.get(Auth).currentUser();\n+┊  ┊82┊\n ┊79┊83┊      if (!currentUser) return null;\n ┊80┊84┊\n ┊81┊85┊      const participant = await injector.get(Chats).firstRecipient({\n```\n```diff\n@@ -86,7 +90,9 @@\n ┊86┊90┊      return participant ? participant.name : null;\n ┊87┊91┊    },\n ┊88┊92┊\n-┊89┊  ┊    async picture(chat, args, { currentUser, db, injector }) {\n+┊  ┊93┊    async picture(chat, args, { injector }) {\n+┊  ┊94┊      const currentUser = await injector.get(Auth).currentUser();\n+┊  ┊95┊\n ┊90┊96┊      if (!currentUser) return null;\n ┊91┊97┊\n ┊92┊98┊      const participant = await injector.get(Chats).firstRecipient({\n```\n```diff\n@@ -113,13 +119,17 @@\n ┊113┊119┊  },\n ┊114┊120┊\n ┊115┊121┊  Query: {\n-┊116┊   ┊    async chats(root, args, { currentUser, injector }) {\n+┊   ┊122┊    async chats(root, args, { injector }) {\n+┊   ┊123┊      const currentUser = await injector.get(Auth).currentUser();\n+┊   ┊124┊\n ┊117┊125┊      if (!currentUser) return [];\n ┊118┊126┊\n ┊119┊127┊      return injector.get(Chats).findChatsByUser(currentUser.id);\n ┊120┊128┊    },\n ┊121┊129┊\n-┊122┊   ┊    async chat(root, { chatId }, { currentUser, injector }) {\n+┊   ┊130┊    async chat(root, { chatId }, { injector }) {\n+┊   ┊131┊      const currentUser = await injector.get(Auth).currentUser();\n+┊   ┊132┊\n ┊123┊133┊      if (!currentUser) return null;\n ┊124┊134┊\n ┊125┊135┊      return injector\n```\n```diff\n@@ -129,7 +139,9 @@\n ┊129┊139┊  },\n ┊130┊140┊\n ┊131┊141┊  Mutation: {\n-┊132┊   ┊    async addMessage(root, { chatId, content }, { currentUser, injector }) {\n+┊   ┊142┊    async addMessage(root, { chatId, content }, { injector }) {\n+┊   ┊143┊      const currentUser = await injector.get(Auth).currentUser();\n+┊   ┊144┊\n ┊133┊145┊      if (!currentUser) return null;\n ┊134┊146┊\n ┊135┊147┊      return injector\n```\n```diff\n@@ -137,7 +149,9 @@\n ┊137┊149┊        .addMessage({ chatId, content, userId: currentUser.id });\n ┊138┊150┊    },\n ┊139┊151┊\n-┊140┊   ┊    async addChat(root, { recipientId }, { currentUser, injector }) {\n+┊   ┊152┊    async addChat(root, { recipientId }, { injector }) {\n+┊   ┊153┊      const currentUser = await injector.get(Auth).currentUser();\n+┊   ┊154┊\n ┊141┊155┊      if (!currentUser) return null;\n ┊142┊156┊\n ┊143┊157┊      return injector\n```\n```diff\n@@ -145,7 +159,9 @@\n ┊145┊159┊        .addChat({ recipientId, userId: currentUser.id });\n ┊146┊160┊    },\n ┊147┊161┊\n-┊148┊   ┊    async removeChat(root, { chatId }, { currentUser, injector }) {\n+┊   ┊162┊    async removeChat(root, { chatId }, { injector }) {\n+┊   ┊163┊      const currentUser = await injector.get(Auth).currentUser();\n+┊   ┊164┊\n ┊149┊165┊      if (!currentUser) return null;\n ┊150┊166┊\n ┊151┊167┊      return injector.get(Chats).removeChat({ chatId, userId: currentUser.id });\n```\n```diff\n@@ -160,8 +176,10 @@\n ┊160┊176┊        async (\n ┊161┊177┊          { messageAdded }: { messageAdded: Message },\n ┊162┊178┊          args,\n-┊163┊   ┊          { currentUser, injector }\n+┊   ┊179┊          { injector }\n ┊164┊180┊        ) => {\n+┊   ┊181┊          const currentUser = await injector.get(Auth).currentUser();\n+┊   ┊182┊\n ┊165┊183┊          if (!currentUser) return false;\n ┊166┊184┊\n ┊167┊185┊          return injector.get(Chats).isParticipant({\n```\n```diff\n@@ -176,11 +194,9 @@\n ┊176┊194┊      subscribe: withFilter(\n ┊177┊195┊        (root, args, { injector }) =>\n ┊178┊196┊          injector.get(PubSub).asyncIterator('chatAdded'),\n-┊179┊   ┊        async (\n-┊180┊   ┊          { chatAdded }: { chatAdded: Chat },\n-┊181┊   ┊          args,\n-┊182┊   ┊          { currentUser, injector }\n-┊183┊   ┊        ) => {\n+┊   ┊197┊        async ({ chatAdded }: { chatAdded: Chat }, args, { injector }) => {\n+┊   ┊198┊          const currentUser = await injector.get(Auth).currentUser();\n+┊   ┊199┊\n ┊184┊200┊          if (!currentUser) return false;\n ┊185┊201┊\n ┊186┊202┊          return injector.get(Chats).isParticipant({\n```\n```diff\n@@ -195,11 +211,9 @@\n ┊195┊211┊      subscribe: withFilter(\n ┊196┊212┊        (root, args, { injector }) =>\n ┊197┊213┊          injector.get(PubSub).asyncIterator('chatRemoved'),\n-┊198┊   ┊        async (\n-┊199┊   ┊          { targetChat }: { targetChat: Chat },\n-┊200┊   ┊          args,\n-┊201┊   ┊          { currentUser, injector }\n-┊202┊   ┊        ) => {\n+┊   ┊214┊        async ({ targetChat }: { targetChat: Chat }, args, { injector }) => {\n+┊   ┊215┊          const currentUser = await injector.get(Auth).currentUser();\n+┊   ┊216┊\n ┊203┊217┊          if (!currentUser) return false;\n ┊204┊218┊\n ┊205┊219┊          return injector.get(Chats).isParticipant({\n```\n\n[}]: #\n\nBecause we no longer need `db` instance in the context, let's remove it:\n\n[{]: <helper> (diffStep \"13.21\" module=\"server\")\n\n#### [__Server__ Step 13.21: Remove db from context](https://github.com/Urigo/WhatsApp-Clone-Server/commit/e070736)\n\n##### Changed context.ts\n```diff\n@@ -1,8 +1,6 @@\n ┊1┊1┊import { ModuleContext } from '@graphql-modules/core';\n ┊2┊2┊import { Response } from 'express';\n-┊3┊ ┊import { PoolClient } from 'pg';\n ┊4┊3┊\n ┊5┊4┊export type MyContext = {\n ┊6┊5┊  res: Response;\n-┊7┊ ┊  db: PoolClient;\n ┊8┊6┊} & ModuleContext;\n```\n\n##### Changed modules&#x2F;chats&#x2F;index.ts\n```diff\n@@ -1,9 +1,8 @@\n ┊1┊1┊import { GraphQLModule } from '@graphql-modules/core';\n ┊2┊2┊import { gql, withFilter } from 'apollo-server-express';\n-┊3┊ ┊import sql from 'sql-template-strings';\n ┊4┊3┊import commonModule from '../common';\n ┊5┊4┊import usersModule from '../users';\n-┊6┊ ┊import { Message, Chat, pool } from '../../db';\n+┊ ┊5┊import { Message, Chat } from '../../db';\n ┊7┊6┊import { Resolvers } from '../../types/graphql';\n ┊8┊7┊import { UnsplashApi } from './unsplash.api';\n ┊9┊8┊import { Users } from './../users/users.provider';\n```\n\n##### Changed modules&#x2F;common&#x2F;index.ts\n```diff\n@@ -54,16 +54,9 @@\n ┊54┊54┊    },\n ┊55┊55┊    Database,\n ┊56┊56┊  ],\n-┊57┊  ┊  async context({ res, connection }) {\n-┊58┊  ┊    let db;\n-┊59┊  ┊\n-┊60┊  ┊    if (!connection) {\n-┊61┊  ┊      db = await pool.connect();\n-┊62┊  ┊    }\n-┊63┊  ┊\n+┊  ┊57┊  async context({ res }) {\n ┊64┊58┊    return {\n ┊65┊59┊      res,\n-┊66┊  ┊      db,\n ┊67┊60┊    };\n ┊68┊61┊  },\n ┊69┊62┊});\n```\n\n##### Changed modules&#x2F;users&#x2F;index.ts\n```diff\n@@ -1,11 +1,9 @@\n ┊ 1┊ 1┊import { GraphQLModule } from '@graphql-modules/core';\n ┊ 2┊ 2┊import { gql } from 'apollo-server-express';\n-┊ 3┊  ┊import sql from 'sql-template-strings';\n ┊ 4┊ 3┊import bcrypt from 'bcrypt';\n ┊ 5┊ 4┊import jwt from 'jsonwebtoken';\n ┊ 6┊ 5┊import commonModule from '../common';\n ┊ 7┊ 6┊import { secret, expiration } from '../../env';\n-┊ 8┊  ┊import { pool } from '../../db';\n ┊ 9┊ 7┊import { validateLength, validatePassword } from '../../validators';\n ┊10┊ 8┊import { Resolvers } from '../../types/graphql';\n ┊11┊ 9┊import { Users } from './users.provider';\n```\n\n[}]: #\n\nBesides the `currentUser` method we're going to have two more, one to sign in and the other to sign up:\n\n[{]: <helper> (diffStep \"13.22\" module=\"server\")\n\n#### [__Server__ Step 13.22: Move signUp logic to Auth provider](https://github.com/Urigo/WhatsApp-Clone-Server/commit/820a0bf)\n\n##### Changed modules&#x2F;users&#x2F;auth.provider.ts\n```diff\n@@ -2,6 +2,7 @@\n ┊2┊2┊import { ModuleSessionInfo } from '@graphql-modules/core';\n ┊3┊3┊import jwt from 'jsonwebtoken';\n ┊4┊4┊import { secret } from '../../env';\n+┊ ┊5┊import { validateLength, validatePassword } from '../../validators';\n ┊5┊6┊import { Users } from './users.provider';\n ┊6┊7┊import { User } from '../../db';\n ┊7┊8┊\n```\n```diff\n@@ -16,6 +17,38 @@\n ┊16┊17┊    return this.module.session.req || this.module.session.request;\n ┊17┊18┊  }\n ┊18┊19┊\n+┊  ┊20┊  async signUp({\n+┊  ┊21┊    name,\n+┊  ┊22┊    password,\n+┊  ┊23┊    passwordConfirm,\n+┊  ┊24┊    username,\n+┊  ┊25┊  }: {\n+┊  ┊26┊    name: string;\n+┊  ┊27┊    password: string;\n+┊  ┊28┊    passwordConfirm: string;\n+┊  ┊29┊    username: string;\n+┊  ┊30┊  }) {\n+┊  ┊31┊    validateLength('req.name', name, 3, 50);\n+┊  ┊32┊    validateLength('req.username', name, 3, 18);\n+┊  ┊33┊    validatePassword('req.password', password);\n+┊  ┊34┊\n+┊  ┊35┊    if (password !== passwordConfirm) {\n+┊  ┊36┊      throw Error(\"req.password and req.passwordConfirm don't match\");\n+┊  ┊37┊    }\n+┊  ┊38┊\n+┊  ┊39┊    const existingUser = await this.users.findByUsername(username);\n+┊  ┊40┊\n+┊  ┊41┊    if (existingUser) {\n+┊  ┊42┊      throw Error('username already exists');\n+┊  ┊43┊    }\n+┊  ┊44┊\n+┊  ┊45┊    return this.users.newUser({\n+┊  ┊46┊      username,\n+┊  ┊47┊      name,\n+┊  ┊48┊      password,\n+┊  ┊49┊    });\n+┊  ┊50┊  }\n+┊  ┊51┊\n ┊19┊52┊  async currentUser(): Promise<User | null> {\n ┊20┊53┊    if (this.req.cookies.authToken) {\n ┊21┊54┊      const username = jwt.verify(this.req.cookies.authToken, secret) as string;\n```\n\n##### Changed modules&#x2F;users&#x2F;index.ts\n```diff\n@@ -4,7 +4,6 @@\n ┊ 4┊ 4┊import jwt from 'jsonwebtoken';\n ┊ 5┊ 5┊import commonModule from '../common';\n ┊ 6┊ 6┊import { secret, expiration } from '../../env';\n-┊ 7┊  ┊import { validateLength, validatePassword } from '../../validators';\n ┊ 8┊ 7┊import { Resolvers } from '../../types/graphql';\n ┊ 9┊ 8┊import { Users } from './users.provider';\n ┊10┊ 9┊import { Auth } from './auth.provider';\n```\n```diff\n@@ -71,26 +70,9 @@\n ┊71┊70┊      { name, username, password, passwordConfirm },\n ┊72┊71┊      { injector }\n ┊73┊72┊    ) {\n-┊74┊  ┊      validateLength('req.name', name, 3, 50);\n-┊75┊  ┊      validateLength('req.username', name, 3, 18);\n-┊76┊  ┊      validatePassword('req.password', password);\n-┊77┊  ┊\n-┊78┊  ┊      if (password !== passwordConfirm) {\n-┊79┊  ┊        throw Error(\"req.password and req.passwordConfirm don't match\");\n-┊80┊  ┊      }\n-┊81┊  ┊\n-┊82┊  ┊      const existingUser = await injector.get(Users).findByUsername(username);\n-┊83┊  ┊      if (existingUser) {\n-┊84┊  ┊        throw Error('username already exists');\n-┊85┊  ┊      }\n-┊86┊  ┊\n-┊87┊  ┊      const createdUser = await injector.get(Users).newUser({\n-┊88┊  ┊        username,\n-┊89┊  ┊        password,\n-┊90┊  ┊        name,\n-┊91┊  ┊      });\n-┊92┊  ┊\n-┊93┊  ┊      return createdUser;\n+┊  ┊73┊      return injector\n+┊  ┊74┊        .get(Auth)\n+┊  ┊75┊        .signUp({ name, username, password, passwordConfirm });\n ┊94┊76┊    },\n ┊95┊77┊  },\n ┊96┊78┊};\n```\n\n[}]: #\n[{]: <helper> (diffStep \"13.23\" module=\"server\")\n\n#### [__Server__ Step 13.23: Move signIn logic to Auth provider](https://github.com/Urigo/WhatsApp-Clone-Server/commit/dc53058)\n\n##### Changed context.ts\n```diff\n@@ -1,6 +1,3 @@\n ┊1┊1┊import { ModuleContext } from '@graphql-modules/core';\n-┊2┊ ┊import { Response } from 'express';\n ┊3┊2┊\n-┊4┊ ┊export type MyContext = {\n-┊5┊ ┊  res: Response;\n-┊6┊ ┊} & ModuleContext;\n+┊ ┊3┊export type MyContext = ModuleContext;\n```\n\n##### Changed modules&#x2F;common&#x2F;index.ts\n```diff\n@@ -54,9 +54,4 @@\n ┊54┊54┊    },\n ┊55┊55┊    Database,\n ┊56┊56┊  ],\n-┊57┊  ┊  async context({ res }) {\n-┊58┊  ┊    return {\n-┊59┊  ┊      res,\n-┊60┊  ┊    };\n-┊61┊  ┊  },\n ┊62┊57┊});\n```\n\n##### Changed modules&#x2F;users&#x2F;auth.provider.ts\n```diff\n@@ -1,7 +1,9 @@\n ┊1┊1┊import { Injectable, Inject, ProviderScope } from '@graphql-modules/di';\n ┊2┊2┊import { ModuleSessionInfo } from '@graphql-modules/core';\n+┊ ┊3┊import { Response } from 'express';\n+┊ ┊4┊import bcrypt from 'bcrypt';\n ┊3┊5┊import jwt from 'jsonwebtoken';\n-┊4┊ ┊import { secret } from '../../env';\n+┊ ┊6┊import { secret, expiration } from '../../env';\n ┊5┊7┊import { validateLength, validatePassword } from '../../validators';\n ┊6┊8┊import { Users } from './users.provider';\n ┊7┊9┊import { User } from '../../db';\n```\n```diff\n@@ -17,6 +19,30 @@\n ┊17┊19┊    return this.module.session.req || this.module.session.request;\n ┊18┊20┊  }\n ┊19┊21┊\n+┊  ┊22┊  private get res(): Response {\n+┊  ┊23┊    return this.module.session.res;\n+┊  ┊24┊  }\n+┊  ┊25┊\n+┊  ┊26┊  async signIn({ username, password }: { username: string; password: string }) {\n+┊  ┊27┊    const user = await this.users.findByUsername(username);\n+┊  ┊28┊\n+┊  ┊29┊    if (!user) {\n+┊  ┊30┊      throw new Error('user not found');\n+┊  ┊31┊    }\n+┊  ┊32┊\n+┊  ┊33┊    const passwordsMatch = bcrypt.compareSync(password, user.password);\n+┊  ┊34┊\n+┊  ┊35┊    if (!passwordsMatch) {\n+┊  ┊36┊      throw new Error('password is incorrect');\n+┊  ┊37┊    }\n+┊  ┊38┊\n+┊  ┊39┊    const authToken = jwt.sign(username, secret);\n+┊  ┊40┊\n+┊  ┊41┊    this.res.cookie('authToken', authToken, { maxAge: expiration });\n+┊  ┊42┊\n+┊  ┊43┊    return user;\n+┊  ┊44┊  }\n+┊  ┊45┊\n ┊20┊46┊  async signUp({\n ┊21┊47┊    name,\n ┊22┊48┊    password,\n```\n\n##### Changed modules&#x2F;users&#x2F;index.ts\n```diff\n@@ -1,9 +1,6 @@\n ┊1┊1┊import { GraphQLModule } from '@graphql-modules/core';\n ┊2┊2┊import { gql } from 'apollo-server-express';\n-┊3┊ ┊import bcrypt from 'bcrypt';\n-┊4┊ ┊import jwt from 'jsonwebtoken';\n ┊5┊3┊import commonModule from '../common';\n-┊6┊ ┊import { secret, expiration } from '../../env';\n ┊7┊4┊import { Resolvers } from '../../types/graphql';\n ┊8┊5┊import { Users } from './users.provider';\n ┊9┊6┊import { Auth } from './auth.provider';\n```\n```diff\n@@ -45,24 +42,8 @@\n ┊45┊42┊    },\n ┊46┊43┊  },\n ┊47┊44┊  Mutation: {\n-┊48┊  ┊    async signIn(root, { username, password }, { injector, res }) {\n-┊49┊  ┊      const user = await injector.get(Users).findByUsername(username);\n-┊50┊  ┊\n-┊51┊  ┊      if (!user) {\n-┊52┊  ┊        throw new Error('user not found');\n-┊53┊  ┊      }\n-┊54┊  ┊\n-┊55┊  ┊      const passwordsMatch = bcrypt.compareSync(password, user.password);\n-┊56┊  ┊\n-┊57┊  ┊      if (!passwordsMatch) {\n-┊58┊  ┊        throw new Error('password is incorrect');\n-┊59┊  ┊      }\n-┊60┊  ┊\n-┊61┊  ┊      const authToken = jwt.sign(username, secret);\n-┊62┊  ┊\n-┊63┊  ┊      res.cookie('authToken', authToken, { maxAge: expiration });\n-┊64┊  ┊\n-┊65┊  ┊      return user;\n+┊  ┊45┊    async signIn(root, { username, password }, { injector }) {\n+┊  ┊46┊      return injector.get(Auth).signIn({ username, password });\n ┊66┊47┊    },\n ┊67┊48┊\n ┊68┊49┊    async signUp(\n```\n\n[}]: #\n\n#### Exposing server instance\n\nIf you would run `yarn test` right now, you will see a lot of errors, every test will fail. That's because we changed our setup but we didn't adjusted tests.\n\nWe're going to change the setup of tests as well so whenever we do something on server it won't affect them. Instead of exposing schema and context as we did before, we're going to base the tests on a ready to use ApolloServer instance.\n\nIn order to achieve it, we need to separate ApolloServer from other server related logic.\n\n[{]: <helper> (diffStep \"13.24\" module=\"server\")\n\n#### [__Server__ Step 13.24: Move ApolloServer and RootModule into a separate file](https://github.com/Urigo/WhatsApp-Clone-Server/commit/a237de0)\n\n##### Changed index.ts\n```diff\n@@ -1,35 +1,7 @@\n-┊ 1┊  ┊import 'reflect-metadata';\n-┊ 2┊  ┊import { ApolloServer } from 'apollo-server-express';\n-┊ 3┊  ┊import { GraphQLModule } from '@graphql-modules/core';\n-┊ 4┊  ┊import cookie from 'cookie';\n ┊ 5┊ 1┊import http from 'http';\n ┊ 6┊ 2┊import { app } from './app';\n ┊ 7┊ 3┊import { origin, port } from './env';\n-┊ 8┊  ┊\n-┊ 9┊  ┊import usersModule from './modules/users';\n-┊10┊  ┊import chatsModule from './modules/chats';\n-┊11┊  ┊\n-┊12┊  ┊export const rootModule = new GraphQLModule({\n-┊13┊  ┊  name: 'root',\n-┊14┊  ┊  imports: [usersModule, chatsModule],\n-┊15┊  ┊});\n-┊16┊  ┊\n-┊17┊  ┊const server = new ApolloServer({\n-┊18┊  ┊  schema: rootModule.schema,\n-┊19┊  ┊  context: (session: any) => {\n-┊20┊  ┊    if (session.connection) {\n-┊21┊  ┊      const req = session.connection.context.session.request;\n-┊22┊  ┊      const cookies = req.headers.cookie;\n-┊23┊  ┊\n-┊24┊  ┊      if (cookies) {\n-┊25┊  ┊        req.cookies = cookie.parse(cookies);\n-┊26┊  ┊      }\n-┊27┊  ┊    }\n-┊28┊  ┊\n-┊29┊  ┊    return rootModule.context(session);\n-┊30┊  ┊  },\n-┊31┊  ┊  subscriptions: rootModule.subscriptions,\n-┊32┊  ┊});\n+┊  ┊ 4┊import { server } from './server';\n ┊33┊ 5┊\n ┊34┊ 6┊server.applyMiddleware({\n ┊35┊ 7┊  app,\n```\n\n##### Added server.ts\n```diff\n@@ -0,0 +1,29 @@\n+┊  ┊ 1┊import 'reflect-metadata';\n+┊  ┊ 2┊import { ApolloServer } from 'apollo-server-express';\n+┊  ┊ 3┊import { GraphQLModule } from '@graphql-modules/core';\n+┊  ┊ 4┊import cookie from 'cookie';\n+┊  ┊ 5┊\n+┊  ┊ 6┊import usersModule from './modules/users';\n+┊  ┊ 7┊import chatsModule from './modules/chats';\n+┊  ┊ 8┊\n+┊  ┊ 9┊export const rootModule = new GraphQLModule({\n+┊  ┊10┊  name: 'root',\n+┊  ┊11┊  imports: [usersModule, chatsModule],\n+┊  ┊12┊});\n+┊  ┊13┊\n+┊  ┊14┊const server = new ApolloServer({\n+┊  ┊15┊  schema: rootModule.schema,\n+┊  ┊16┊  context: (session: any) => {\n+┊  ┊17┊    if (session.connection) {\n+┊  ┊18┊      const req = session.connection.context.session.request;\n+┊  ┊19┊      const cookies = req.headers.cookie;\n+┊  ┊20┊\n+┊  ┊21┊      if (cookies) {\n+┊  ┊22┊        req.cookies = cookie.parse(cookies);\n+┊  ┊23┊      }\n+┊  ┊24┊    }\n+┊  ┊25┊\n+┊  ┊26┊    return rootModule.context(session);\n+┊  ┊27┊  },\n+┊  ┊28┊  subscriptions: rootModule.subscriptions,\n+┊  ┊29┊});\n```\n\n[}]: #\n[{]: <helper> (diffStep \"13.25\" module=\"server\")\n\n#### [__Server__ Step 13.25: Export server instance](https://github.com/Urigo/WhatsApp-Clone-Server/commit/b0d9bc8)\n\n##### Changed server.ts\n```diff\n@@ -11,7 +11,7 @@\n ┊11┊11┊  imports: [usersModule, chatsModule],\n ┊12┊12┊});\n ┊13┊13┊\n-┊14┊  ┊const server = new ApolloServer({\n+┊  ┊14┊export const server = new ApolloServer({\n ┊15┊15┊  schema: rootModule.schema,\n ┊16┊16┊  context: (session: any) => {\n ┊17┊17┊    if (session.connection) {\n```\n\n[}]: #\n\nThere's one thing that changed and might break our tests, this line fix it:\n\n[{]: <helper> (diffStep \"13.26\" module=\"server\")\n\n#### [__Server__ Step 13.26: Define mocked version of Auth provider](https://github.com/Urigo/WhatsApp-Clone-Server/commit/e3ee9cd)\n\n##### Added tests&#x2F;mocks&#x2F;auth.provider.ts\n```diff\n@@ -0,0 +1,21 @@\n+┊  ┊ 1┊import sql from 'sql-template-strings';\n+┊  ┊ 2┊import { Auth } from './../../modules/users/auth.provider';\n+┊  ┊ 3┊import usersModule from './../../modules/users';\n+┊  ┊ 4┊import { pool } from '../../db';\n+┊  ┊ 5┊\n+┊  ┊ 6┊export function mockAuth(userId: number) {\n+┊  ┊ 7┊  class AuthMock extends Auth {\n+┊  ┊ 8┊    async currentUser() {\n+┊  ┊ 9┊      const { rows } = await pool.query(\n+┊  ┊10┊        sql`SELECT * FROM users WHERE id = ${userId}`\n+┊  ┊11┊      );\n+┊  ┊12┊      return rows[0];\n+┊  ┊13┊    }\n+┊  ┊14┊  }\n+┊  ┊15┊\n+┊  ┊16┊  usersModule.injector.provide({\n+┊  ┊17┊    provide: Auth,\n+┊  ┊18┊    useClass: AuthMock,\n+┊  ┊19┊    overwrite: true,\n+┊  ┊20┊  });\n+┊  ┊21┊}\n```\n\n[}]: #\n\nRemember when I said about benefits of Dependency Injection? Here's one of them. We create a function that overwrites the `currentUser` method so it always returns a specific user.\n\n[{]: <helper> (diffStep \"13.27\" module=\"server\")\n\n#### [__Server__ Step 13.27: Adjust tests](https://github.com/Urigo/WhatsApp-Clone-Server/commit/7655fa7)\n\n##### Changed tests&#x2F;mutations&#x2F;addChat.test.ts\n```diff\n@@ -1,28 +1,14 @@\n ┊ 1┊ 1┊import { createTestClient } from 'apollo-server-testing';\n-┊ 2┊  ┊import { ApolloServer, PubSub, gql } from 'apollo-server-express';\n-┊ 3┊  ┊import { rootModule } from '../../index';\n-┊ 4┊  ┊import { resetDb, pool } from '../../db';\n-┊ 5┊  ┊import sql from 'sql-template-strings';\n-┊ 6┊  ┊import { MyContext } from '../../context';\n+┊  ┊ 2┊import { gql } from 'apollo-server-express';\n+┊  ┊ 3┊import { server } from '../../server';\n+┊  ┊ 4┊import { resetDb } from '../../db';\n+┊  ┊ 5┊import { mockAuth } from '../mocks/auth.provider';\n ┊ 7┊ 6┊\n ┊ 8┊ 7┊describe('Mutation.addChat', () => {\n ┊ 9┊ 8┊  beforeEach(resetDb);\n ┊10┊ 9┊\n ┊11┊10┊  it('creates a new chat between current user and specified recipient', async () => {\n-┊12┊  ┊    const { rows } = await pool.query(sql`SELECT * FROM users WHERE id = 2`);\n-┊13┊  ┊    const currentUser = rows[0];\n-┊14┊  ┊    const server = new ApolloServer({\n-┊15┊  ┊      schema: rootModule.schema,\n-┊16┊  ┊      context: async () => ({\n-┊17┊  ┊        pubsub: new PubSub(),\n-┊18┊  ┊        currentUser,\n-┊19┊  ┊        db: await pool.connect(),\n-┊20┊  ┊      }),\n-┊21┊  ┊      formatResponse: (res: any, { context }: { context: MyContext }) => {\n-┊22┊  ┊        context.db.release();\n-┊23┊  ┊        return res;\n-┊24┊  ┊      },\n-┊25┊  ┊    });\n+┊  ┊11┊    mockAuth(2);\n ┊26┊12┊\n ┊27┊13┊    const { query, mutate } = createTestClient(server);\n ┊28┊14┊\n```\n```diff\n@@ -66,20 +52,7 @@\n ┊66┊52┊  });\n ┊67┊53┊\n ┊68┊54┊  it('returns the existing chat if so', async () => {\n-┊69┊  ┊    const { rows } = await pool.query(sql`SELECT * FROM users WHERE id = 1`);\n-┊70┊  ┊    const currentUser = rows[0];\n-┊71┊  ┊    const server = new ApolloServer({\n-┊72┊  ┊      schema: rootModule.schema,\n-┊73┊  ┊      context: async () => ({\n-┊74┊  ┊        pubsub: new PubSub(),\n-┊75┊  ┊        currentUser,\n-┊76┊  ┊        db: await pool.connect(),\n-┊77┊  ┊      }),\n-┊78┊  ┊      formatResponse: (res: any, { context }: { context: MyContext }) => {\n-┊79┊  ┊        context.db.release();\n-┊80┊  ┊        return res;\n-┊81┊  ┊      },\n-┊82┊  ┊    });\n+┊  ┊55┊    mockAuth(1);\n ┊83┊56┊\n ┊84┊57┊    const { query, mutate } = createTestClient(server);\n ┊85┊58┊\n```\n\n##### Changed tests&#x2F;mutations&#x2F;addMessage.test.ts\n```diff\n@@ -1,28 +1,14 @@\n ┊ 1┊ 1┊import { createTestClient } from 'apollo-server-testing';\n-┊ 2┊  ┊import { ApolloServer, PubSub, gql } from 'apollo-server-express';\n-┊ 3┊  ┊import { rootModule } from '../../index';\n-┊ 4┊  ┊import { resetDb, pool } from '../../db';\n-┊ 5┊  ┊import sql from 'sql-template-strings';\n-┊ 6┊  ┊import { MyContext } from '../../context';\n+┊  ┊ 2┊import { gql } from 'apollo-server-express';\n+┊  ┊ 3┊import { server } from '../../server';\n+┊  ┊ 4┊import { resetDb } from '../../db';\n+┊  ┊ 5┊import { mockAuth } from '../mocks/auth.provider';\n ┊ 7┊ 6┊\n ┊ 8┊ 7┊describe('Mutation.addMessage', () => {\n ┊ 9┊ 8┊  beforeEach(resetDb);\n ┊10┊ 9┊\n ┊11┊10┊  it('should add message to specified chat', async () => {\n-┊12┊  ┊    const { rows } = await pool.query(sql`SELECT * FROM users WHERE id = 1`);\n-┊13┊  ┊    const currentUser = rows[0];\n-┊14┊  ┊    const server = new ApolloServer({\n-┊15┊  ┊      schema: rootModule.schema,\n-┊16┊  ┊      context: async () => ({\n-┊17┊  ┊        pubsub: new PubSub(),\n-┊18┊  ┊        currentUser,\n-┊19┊  ┊        db: await pool.connect(),\n-┊20┊  ┊      }),\n-┊21┊  ┊      formatResponse: (res: any, { context }: { context: MyContext }) => {\n-┊22┊  ┊        context.db.release();\n-┊23┊  ┊        return res;\n-┊24┊  ┊      },\n-┊25┊  ┊    });\n+┊  ┊11┊    mockAuth(1);\n ┊26┊12┊\n ┊27┊13┊    const { query, mutate } = createTestClient(server);\n ┊28┊14┊\n```\n\n##### Changed tests&#x2F;mutations&#x2F;removeChat.test.ts\n```diff\n@@ -1,28 +1,14 @@\n ┊ 1┊ 1┊import { createTestClient } from 'apollo-server-testing';\n-┊ 2┊  ┊import { ApolloServer, PubSub, gql } from 'apollo-server-express';\n-┊ 3┊  ┊import { rootModule } from '../../index';\n-┊ 4┊  ┊import { resetDb, pool } from '../../db';\n-┊ 5┊  ┊import sql from 'sql-template-strings';\n-┊ 6┊  ┊import { MyContext } from '../../context';\n+┊  ┊ 2┊import { gql } from 'apollo-server-express';\n+┊  ┊ 3┊import { server } from '../../server';\n+┊  ┊ 4┊import { resetDb } from '../../db';\n+┊  ┊ 5┊import { mockAuth } from '../mocks/auth.provider';\n ┊ 7┊ 6┊\n ┊ 8┊ 7┊describe('Mutation.removeChat', () => {\n ┊ 9┊ 8┊  beforeEach(resetDb);\n ┊10┊ 9┊\n ┊11┊10┊  it('removes chat by id', async () => {\n-┊12┊  ┊    const { rows } = await pool.query(sql`SELECT * FROM users WHERE id = 1`);\n-┊13┊  ┊    const currentUser = rows[0];\n-┊14┊  ┊    const server = new ApolloServer({\n-┊15┊  ┊      schema: rootModule.schema,\n-┊16┊  ┊      context: async () => ({\n-┊17┊  ┊        pubsub: new PubSub(),\n-┊18┊  ┊        currentUser,\n-┊19┊  ┊        db: await pool.connect(),\n-┊20┊  ┊      }),\n-┊21┊  ┊      formatResponse: (res: any, { context }: { context: MyContext }) => {\n-┊22┊  ┊        context.db.release();\n-┊23┊  ┊        return res;\n-┊24┊  ┊      },\n-┊25┊  ┊    });\n+┊  ┊11┊    mockAuth(1);\n ┊26┊12┊\n ┊27┊13┊    const { query, mutate } = createTestClient(server);\n ┊28┊14┊\n```\n\n##### Changed tests&#x2F;queries&#x2F;getChat.test.ts\n```diff\n@@ -1,27 +1,14 @@\n ┊ 1┊ 1┊import { createTestClient } from 'apollo-server-testing';\n-┊ 2┊  ┊import { ApolloServer, gql } from 'apollo-server-express';\n-┊ 3┊  ┊import { rootModule } from '../../index';\n-┊ 4┊  ┊import { poolm resetDb } from '../../db';\n-┊ 5┊  ┊import sql from 'sql-template-strings';\n-┊ 6┊  ┊import { MyContext } from '../../context';\n+┊  ┊ 2┊import { gql } from 'apollo-server-express';\n+┊  ┊ 3┊import { server } from '../../server';\n+┊  ┊ 4┊import { resetDb } from '../../db';\n+┊  ┊ 5┊import { mockAuth } from '../mocks/auth.provider';\n ┊ 7┊ 6┊\n ┊ 8┊ 7┊describe('Query.chat', () => {\n ┊ 9┊ 8┊  beforeEach(resetDb);\n ┊10┊ 9┊\n ┊11┊10┊  it('should fetch specified chat', async () => {\n-┊12┊  ┊    const { rows } = await pool.query(sql`SELECT * FROM users WHERE id = 1`);\n-┊13┊  ┊    const currentUser = rows[0];\n-┊14┊  ┊    const server = new ApolloServer({\n-┊15┊  ┊      schema: rootModule.schema,\n-┊16┊  ┊      context: async () => ({\n-┊17┊  ┊        currentUser,\n-┊18┊  ┊        db: await pool.connect(),\n-┊19┊  ┊      }),\n-┊20┊  ┊      formatResponse: (res: any, { context }: { context: MyContext }) => {\n-┊21┊  ┊        context.db.release();\n-┊22┊  ┊        return res;\n-┊23┊  ┊      },\n-┊24┊  ┊    });\n+┊  ┊11┊    mockAuth(1);\n ┊25┊12┊\n ┊26┊13┊    const { query } = createTestClient(server);\n ┊27┊14┊\n```\n\n##### Changed tests&#x2F;queries&#x2F;getChats.test.ts\n```diff\n@@ -1,27 +1,14 @@\n ┊ 1┊ 1┊import { createTestClient } from 'apollo-server-testing';\n-┊ 2┊  ┊import { ApolloServer, gql } from 'apollo-server-express';\n-┊ 3┊  ┊import { rootModule } from '../../index';\n-┊ 4┊  ┊import { pool, resetDb } from '../../db';\n-┊ 5┊  ┊import sql from 'sql-template-strings';\n-┊ 6┊  ┊import { MyContext } from '../../context';\n+┊  ┊ 2┊import { gql } from 'apollo-server-express';\n+┊  ┊ 3┊import { server } from '../../server';\n+┊  ┊ 4┊import { resetDb } from '../../db';\n+┊  ┊ 5┊import { mockAuth } from '../mocks/auth.provider';\n ┊ 7┊ 6┊\n ┊ 8┊ 7┊describe('Query.chats', () => {\n ┊ 9┊ 8┊  beforeEach(resetDb);\n ┊10┊ 9┊\n ┊11┊10┊  it('should fetch all chats', async () => {\n-┊12┊  ┊    const { rows } = await pool.query(sql`SELECT * FROM users WHERE id = 1`);\n-┊13┊  ┊    const currentUser = rows[0];\n-┊14┊  ┊    const server = new ApolloServer({\n-┊15┊  ┊      schema: rootModule.schema,\n-┊16┊  ┊      context: async () => ({\n-┊17┊  ┊        currentUser,\n-┊18┊  ┊        db: await pool.connect(),\n-┊19┊  ┊      }),\n-┊20┊  ┊      formatResponse: (res: any, { context }: { context: MyContext }) => {\n-┊21┊  ┊        context.db.release();\n-┊22┊  ┊        return res;\n-┊23┊  ┊      },\n-┊24┊  ┊    });\n+┊  ┊11┊    mockAuth(1);\n ┊25┊12┊\n ┊26┊13┊    const { query } = createTestClient(server);\n ┊27┊14┊\n```\n\n##### Changed tests&#x2F;queries&#x2F;getMe.test.ts\n```diff\n@@ -1,25 +1,14 @@\n ┊ 1┊ 1┊import { createTestClient } from 'apollo-server-testing';\n-┊ 2┊  ┊import { ApolloServer, gql } from 'apollo-server-express';\n-┊ 3┊  ┊import { rootModule } from '../../index';\n-┊ 4┊  ┊import { pool } from '../../db';\n-┊ 5┊  ┊import sql from 'sql-template-strings';\n-┊ 6┊  ┊import { MyContext } from '../../context';\n+┊  ┊ 2┊import { gql } from 'apollo-server-express';\n+┊  ┊ 3┊import { server } from '../../server';\n+┊  ┊ 4┊import { resetDb } from '../../db';\n+┊  ┊ 5┊import { mockAuth } from '../mocks/auth.provider';\n ┊ 7┊ 6┊\n ┊ 8┊ 7┊describe('Query.me', () => {\n+┊  ┊ 8┊  beforeEach(resetDb);\n+┊  ┊ 9┊\n ┊ 9┊10┊  it('should fetch current user', async () => {\n-┊10┊  ┊    const { rows } = await pool.query(sql`SELECT * FROM users WHERE id = 1`);\n-┊11┊  ┊    const currentUser = rows[0];\n-┊12┊  ┊    const server = new ApolloServer({\n-┊13┊  ┊      schema: rootModule.schema,\n-┊14┊  ┊      context: async () => ({\n-┊15┊  ┊        currentUser,\n-┊16┊  ┊        db: await pool.connect(),\n-┊17┊  ┊      }),\n-┊18┊  ┊      formatResponse: (res: any, { context }: { context: MyContext }) => {\n-┊19┊  ┊        context.db.release();\n-┊20┊  ┊        return res;\n-┊21┊  ┊      },\n-┊22┊  ┊    });\n+┊  ┊11┊    mockAuth(1);\n ┊23┊12┊\n ┊24┊13┊    const { query } = createTestClient(server);\n ┊25┊14┊\n```\n\n##### Changed tests&#x2F;queries&#x2F;getUsers.test.ts\n```diff\n@@ -1,28 +1,14 @@\n ┊ 1┊ 1┊import { createTestClient } from 'apollo-server-testing';\n-┊ 2┊  ┊import { ApolloServer, gql } from 'apollo-server-express';\n-┊ 3┊  ┊import { rootModule } from '../../index';\n-┊ 4┊  ┊import { pool } from '../../db';\n-┊ 5┊  ┊import sql from 'sql-template-strings';\n-┊ 6┊  ┊import { MyContext } from '../../context';\n+┊  ┊ 2┊import { gql } from 'apollo-server-express';\n+┊  ┊ 3┊import { server } from '../../server';\n+┊  ┊ 4┊import { resetDb } from '../../db';\n+┊  ┊ 5┊import { mockAuth } from '../mocks/auth.provider';\n ┊ 7┊ 6┊\n ┊ 8┊ 7┊describe('Query.getUsers', () => {\n+┊  ┊ 8┊  beforeEach(resetDb);\n+┊  ┊ 9┊\n ┊ 9┊10┊  it('should fetch all users except the one signed-in', async () => {\n-┊10┊  ┊    const firstUserQuery = await pool.query(\n-┊11┊  ┊      sql`SELECT * FROM users WHERE id = 1`\n-┊12┊  ┊    );\n-┊13┊  ┊    let currentUser = firstUserQuery.rows[0];\n-┊14┊  ┊    const db = await pool.connect();\n-┊15┊  ┊    const server = new ApolloServer({\n-┊16┊  ┊      schema: rootModule.schema,\n-┊17┊  ┊      context: async () => ({\n-┊18┊  ┊        currentUser,\n-┊19┊  ┊        db: await pool.connect(),\n-┊20┊  ┊      }),\n-┊21┊  ┊      formatResponse: (res: any, { context }: { context: MyContext }) => {\n-┊22┊  ┊        context.db.release();\n-┊23┊  ┊        return res;\n-┊24┊  ┊      },\n-┊25┊  ┊    });\n+┊  ┊11┊    mockAuth(1);\n ┊26┊12┊\n ┊27┊13┊    const { query } = createTestClient(server);\n ┊28┊14┊\n```\n```diff\n@@ -42,10 +28,7 @@\n ┊42┊28┊    expect(res.errors).toBeUndefined();\n ┊43┊29┊    expect(res.data).toMatchSnapshot();\n ┊44┊30┊\n-┊45┊  ┊    const secondUserQuery = await pool.query(\n-┊46┊  ┊      sql`SELECT * FROM users WHERE id = '2'`\n-┊47┊  ┊    );\n-┊48┊  ┊    currentUser = secondUserQuery.rows[0];\n+┊  ┊31┊    mockAuth(2);\n ┊49┊32┊\n ┊50┊33┊    res = await query({\n ┊51┊34┊      query: gql`\n```\n\n[}]: #\n\nLet's now migrate all tests and see how easier it is now to manage those. Because we use ApolloServer's instance, we don't need to understand how it's implemented.\n\n[{]: <helper> (diffStep \"13.28\" module=\"server\")\n\n#### Step 13.28: NOT FOUND!\n\n[}]: #\n\n## Adjusting client\n\nWe still need to update `codegen.yml` in the client app because of the changes we introduced in this chapter:\n\n[{]: <helper> (diffStep \"14.1\" module=\"client\")\n\n#### [__Client__ Step 14.1: Adjust to GraphQL Modules](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/fea358d)\n\n##### Changed codegen.yml\n```diff\n@@ -1,4 +1,4 @@\n-┊1┊ ┊schema: ../Whatsapp-Clone-Server/schema/typeDefs.graphql\n+┊ ┊1┊schema: ../Whatsapp-Clone-Server/modules/*/*.ts\n ┊2┊2┊documents:\n ┊3┊3┊  - ./src/components/**/*.tsx\n ┊4┊4┊  - ./src/graphql/fragments/**/*.ts\n```\n\n[}]: #\n\n## Many ways to write GraphQL\n\nWe’re going to discuss what are the possible options of building GraphQL API and why schema-first approach was our choice.\n\nThe main ingredient of a GraphQL API is, of course the schema. It’s built out of type definitions where each of them describes a piece of data, connections between them and how data is actually resolved.\n\nThe way we develop all of it changes the way we work with the API.\n\nWe could define two main approaches:\n  - schema-first\n  - resolver-first\n\nThe former means design comes before code, the latter vice-versa.\n\nIn schema-first development you start with SDL, resolvers and code go next. Schema is sort of a contract between teams and also between frontend and backend. With schema-first approach it’s easier to cooperate, discuss and write a better API. Because the SDL is written upfront, the frontend developers can use a mocked version of it and start working on the product while the backend team does the API, in parallel.\nThere are of course some pain points. Once schema is splitted into SDL and resolvers it’s hard to keep them in sync and that’s why things like GraphQL Code Generator were developed, to add type safety on top of all.\n\nThe resolver-first approach is a bit different. The schema is defined programmatically, which usually means it’s more flexible and combined with TypeScript or Flow gives you type-safety out of the box.\n\nWe think it’s less readable than having a SDL and there’s a lack of separation between schema and code which might be a blocker for some teams."
          },
          {
            "manualTitle": "Step 17: Performance",
            "stepRevision": "b1da0ef99b5367dc42b879e55dde63a7171de979",
            "manualView": "In this part of the tutorial we're going to do a bit different work than in previous chapters. We'll analyze the code instead of writing it, including both the API and the web application.\n\n## API Performance\n\nFirst, let's start with the GraphQL API.\n\n### Finding bottlenecks\n\nIn order to implement fixes and do improvements we need to understand which part of the API needs help. There's still not many tools around GraphQL in terms of analytics and inspection but there's one highly useful, it's called **Apollo Engine**.\n\nSince we're going to use it, you need to register an account at [engine.apollographql.com](https://engine.apollographql.com/) and create a service. Please then follow [the \"How to configure an Apollo project\" instructions](https://www.apollographql.com/docs/platform/schema-registry/#using-the-schema-registry).\n\nOnce you're ready, please start the server and run this command:\n\n    $ apollo service:push\n\nTo collect the data, let's play with the client app for some time. After that, go to Engine's website.\n\nHere's one of graphs with timing of an operation. We can understand when each resolver takes place and how much time it consumes. Some resolvers happen in parallel.\nThe `< 1ms` says it was a very simple computation or an element resolved immediately.\n\nWe find it very useful to understand how operation behaves.\n\n![Resolvers](../../../assets/step17/img-01.png \"Resolvers\")\n\nLet's go through an entire query to find fields fetched multiple times. The most obvious field is `isMine`. We see it's computed twice for almost 4 and 5 milliseconds.\nIn order to find out what does it mean, we need to look at the code. The resolver gets the currently logged in user from the `Auth` service and its `currentUser`. Each time the method is invoked, a query to PostgreSQL is made. We ask for that data multiple times, once in `lastMessage` and also in every message from the list.\n\nWe could deduplicate the SQL queries! In order to do that the most obvious library that pops to my mind is Dataloader.\n\nLet's install the package and discuss it afterwards:\n\n    npm install dataloader\n\nThe Dataloader is a library created and maintained by Facebook. It's main purpose is to turn equivalent requests into a single execution. Sounds like a perfect solution, right? It actually is.\n\nA short explaination of how Dataloader works.\n\n```ts\nasync function fetchUser(id: number): Promise<User> {\n  // Resolves asynchronously, after less than 1s.\n  return db.users.findOne(id);\n}\n\nasync function fetchUsers(ids: number[]): Promise<User[]> {\n  const users = ids.map(id => fetchUser(id));\n  return Promise.all(users);\n}\n\nconst loader = new Dataloader(keys => fetchUsers(keys));\n\nasync function main() {\n  const user1 = await loader.load(1);\n  const user2 = await loader.load(2);\n\n  // Later on user #1 is fetched again.\n  // It resolves immediately.\n  const member1 = await loader.load(1);\n}\n```\n\nThink of the Dataloader as a class that has a `Map` object in it, its keys are of course unique and each value is a `Promise`.\nEvery time you ask for something, Dataloader looks for it in the `Map`. When there's already something, the `Promise` is returned but if there's none the provided function is invoked and a new `Promise` is created. This way equivalent requests share the same `Promise`.\n\n> It's important to know that the `Map` object grows until the DataLoader is released, that's why it's recommended to keep `Dataloader` in GraphQL's context.\n\nLet's implement `Dataloader` in our `Database` service:\n\n[{]: <helper> (diffStep \"14.1\" files=\"modules/common/database.provider.ts\" module=\"server\")\n\n#### [__Server__ Step 14.1: Deduplicate SQL queries](https://github.com/Urigo/WhatsApp-Clone-Server/commit/f3586df)\n\n##### Changed modules&#x2F;common&#x2F;database.provider.ts\n```diff\n@@ -1,14 +1,41 @@\n ┊ 1┊ 1┊import { Injectable, ProviderScope } from '@graphql-modules/di';\n ┊ 2┊ 2┊import { OnResponse } from '@graphql-modules/core';\n-┊ 3┊  ┊import { Pool, PoolClient } from 'pg';\n+┊  ┊ 3┊import { Pool, PoolClient, QueryResult } from 'pg';\n+┊  ┊ 4┊import { SQLStatement } from 'sql-template-strings';\n+┊  ┊ 5┊import Dataloader from 'dataloader';\n ┊ 4┊ 6┊\n ┊ 5┊ 7┊@Injectable({\n ┊ 6┊ 8┊  scope: ProviderScope.Session,\n ┊ 7┊ 9┊})\n ┊ 8┊10┊export class Database implements OnResponse {\n ┊ 9┊11┊  private instance: PoolClient;\n+┊  ┊12┊  private loader: Dataloader<string | SQLStatement, QueryResult>;\n ┊10┊13┊\n-┊11┊  ┊  constructor(private pool: Pool) {}\n+┊  ┊14┊  constructor(private pool: Pool) {\n+┊  ┊15┊    this.loader = new Dataloader(\n+┊  ┊16┊      queries =>\n+┊  ┊17┊        Promise.all(\n+┊  ┊18┊          queries.map(async query => {\n+┊  ┊19┊            const db = await this.getClient();\n+┊  ┊20┊            return db.query(query);\n+┊  ┊21┊          })\n+┊  ┊22┊        ),\n+┊  ┊23┊      {\n+┊  ┊24┊        cacheKeyFn: (key: string | SQLStatement) => {\n+┊  ┊25┊          let id: string;\n+┊  ┊26┊\n+┊  ┊27┊          if (typeof key === 'string') {\n+┊  ┊28┊            id = key;\n+┊  ┊29┊          } else {\n+┊  ┊30┊            id = key.text + ' - ' + JSON.stringify(key.values);\n+┊  ┊31┊          }\n+┊  ┊32┊\n+┊  ┊33┊          return id;\n+┊  ┊34┊        },\n+┊  ┊35┊        batch: false,\n+┊  ┊36┊      }\n+┊  ┊37┊    );\n+┊  ┊38┊  }\n ┊12┊39┊\n ┊13┊40┊  async onRequest() {\n ┊14┊41┊    this.instance = await this.pool.connect();\n```\n```diff\n@@ -20,7 +47,11 @@\n ┊20┊47┊    }\n ┊21┊48┊  }\n ┊22┊49┊\n-┊23┊  ┊  async getClient() {\n+┊  ┊50┊  private getClient() {\n ┊24┊51┊    return this.instance;\n ┊25┊52┊  }\n+┊  ┊53┊\n+┊  ┊54┊  query(query: SQLStatement | string) {\n+┊  ┊55┊    return this.loader.load(query);\n+┊  ┊56┊  }\n ┊26┊57┊}\n```\n\n[}]: #\n\nThe key is created based on SQL statement and its values and we also turned off batching because it's important to execute SQL operations sequentially.\nThere's also a new method called `query`, to execute SQL statements through Dataloader. It also reduces a boilerplate of asking for db client and executing a query every time we do SQL in resolvers and providers.\n\nNow we need to apply that change in all providers:\n\n[{]: <helper> (diffStep \"14.1\" files=\"modules/users/users.provider.ts, modules/chats/chats.provider.ts\" module=\"server\")\n\n#### [__Server__ Step 14.1: Deduplicate SQL queries](https://github.com/Urigo/WhatsApp-Clone-Server/commit/f3586df)\n\n##### Changed modules&#x2F;chats&#x2F;chats.provider.ts\n```diff\n@@ -11,9 +11,7 @@\n ┊11┊11┊  @Inject() private pubsub: PubSub;\n ┊12┊12┊\n ┊13┊13┊  async findChatsByUser(userId: string) {\n-┊14┊  ┊    const db = await this.db.getClient();\n-┊15┊  ┊\n-┊16┊  ┊    const { rows } = await db.query(sql`\n+┊  ┊14┊    const { rows } = await this.db.query(sql`\n ┊17┊15┊      SELECT chats.* FROM chats, chats_users\n ┊18┊16┊      WHERE chats.id = chats_users.chat_id\n ┊19┊17┊      AND chats_users.user_id = ${userId}\n```\n```diff\n@@ -23,8 +21,7 @@\n ┊23┊21┊  }\n ┊24┊22┊\n ┊25┊23┊  async findChatByUser({ chatId, userId }: { chatId: string; userId: string }) {\n-┊26┊  ┊    const db = await this.db.getClient();\n-┊27┊  ┊    const { rows } = await db.query(sql`\n+┊  ┊24┊    const { rows } = await this.db.query(sql`\n ┊28┊25┊      SELECT chats.* FROM chats, chats_users\n ┊29┊26┊      WHERE chats_users.chat_id = ${chatId}\n ┊30┊27┊      AND chats.id = chats_users.chat_id\n```\n```diff\n@@ -35,16 +32,14 @@\n ┊35┊32┊  }\n ┊36┊33┊\n ┊37┊34┊  async findChatById(chatId: string) {\n-┊38┊  ┊    const db = await this.db.getClient();\n-┊39┊  ┊    const { rows } = await db.query(sql`\n+┊  ┊35┊    const { rows } = await this.db.query(sql`\n ┊40┊36┊      SELECT * FROM chats WHERE id = ${chatId}\n ┊41┊37┊    `);\n ┊42┊38┊    return rows[0] || null;\n ┊43┊39┊  }\n ┊44┊40┊\n ┊45┊41┊  async findMessagesByChat(chatId: string) {\n-┊46┊  ┊    const db = await this.db.getClient();\n-┊47┊  ┊    const { rows } = await db.query(\n+┊  ┊42┊    const { rows } = await this.db.query(\n ┊48┊43┊      sql`SELECT * FROM messages WHERE chat_id = ${chatId}`\n ┊49┊44┊    );\n ┊50┊45┊\n```\n```diff\n@@ -52,8 +47,7 @@\n ┊52┊47┊  }\n ┊53┊48┊\n ┊54┊49┊  async lastMessage(chatId: string) {\n-┊55┊  ┊    const db = await this.db.getClient();\n-┊56┊  ┊    const { rows } = await db.query(sql`\n+┊  ┊50┊    const { rows } = await this.db.query(sql`\n ┊57┊51┊      SELECT * FROM messages\n ┊58┊52┊      WHERE chat_id = ${chatId}\n ┊59┊53┊      ORDER BY created_at DESC\n```\n```diff\n@@ -64,8 +58,7 @@\n ┊64┊58┊  }\n ┊65┊59┊\n ┊66┊60┊  async firstRecipient({ chatId, userId }: { chatId: string; userId: string }) {\n-┊67┊  ┊    const db = await this.db.getClient();\n-┊68┊  ┊    const { rows } = await db.query(sql`\n+┊  ┊61┊    const { rows } = await this.db.query(sql`\n ┊69┊62┊      SELECT users.* FROM users, chats_users\n ┊70┊63┊      WHERE users.id != ${userId}\n ┊71┊64┊      AND users.id = chats_users.user_id\n```\n```diff\n@@ -76,8 +69,7 @@\n ┊76┊69┊  }\n ┊77┊70┊\n ┊78┊71┊  async participants(chatId: string) {\n-┊79┊  ┊    const db = await this.db.getClient();\n-┊80┊  ┊    const { rows } = await db.query(sql`\n+┊  ┊72┊    const { rows } = await this.db.query(sql`\n ┊81┊73┊      SELECT users.* FROM users, chats_users\n ┊82┊74┊      WHERE chats_users.chat_id = ${chatId}\n ┊83┊75┊      AND chats_users.user_id = users.id\n```\n```diff\n@@ -87,8 +79,7 @@\n ┊87┊79┊  }\n ┊88┊80┊\n ┊89┊81┊  async isParticipant({ chatId, userId }: { chatId: string; userId: string }) {\n-┊90┊  ┊    const db = await this.db.getClient();\n-┊91┊  ┊    const { rows } = await db.query(sql`\n+┊  ┊82┊    const { rows } = await this.db.query(sql`\n ┊92┊83┊      SELECT * FROM chats_users\n ┊93┊84┊      WHERE chat_id = ${chatId}\n ┊94┊85┊      AND user_id = ${userId}\n```\n```diff\n@@ -106,8 +97,7 @@\n ┊106┊ 97┊    userId: string;\n ┊107┊ 98┊    content: string;\n ┊108┊ 99┊  }) {\n-┊109┊   ┊    const db = await this.db.getClient();\n-┊110┊   ┊    const { rows } = await db.query(sql`\n+┊   ┊100┊    const { rows } = await this.db.query(sql`\n ┊111┊101┊      INSERT INTO messages(chat_id, sender_user_id, content)\n ┊112┊102┊      VALUES(${chatId}, ${userId}, ${content})\n ┊113┊103┊      RETURNING *\n```\n```diff\n@@ -129,8 +119,7 @@\n ┊129┊119┊    userId: string;\n ┊130┊120┊    recipientId: string;\n ┊131┊121┊  }) {\n-┊132┊   ┊    const db = await this.db.getClient();\n-┊133┊   ┊    const { rows } = await db.query(sql`\n+┊   ┊122┊    const { rows } = await this.db.query(sql`\n ┊134┊123┊      SELECT chats.* FROM chats, (SELECT * FROM chats_users WHERE user_id = ${userId}) AS chats_of_current_user, chats_users\n ┊135┊124┊      WHERE chats_users.chat_id = chats_of_current_user.chat_id\n ┊136┊125┊      AND chats.id = chats_users.chat_id\n```\n```diff\n@@ -143,9 +132,9 @@\n ┊143┊132┊    }\n ┊144┊133┊\n ┊145┊134┊    try {\n-┊146┊   ┊      await db.query('BEGIN');\n+┊   ┊135┊      await this.db.query('BEGIN');\n ┊147┊136┊\n-┊148┊   ┊      const { rows } = await db.query(sql`\n+┊   ┊137┊      const { rows } = await this.db.query(sql`\n ┊149┊138┊        INSERT INTO chats\n ┊150┊139┊        DEFAULT VALUES\n ┊151┊140┊        RETURNING *\n```\n```diff\n@@ -153,17 +142,17 @@\n ┊153┊142┊\n ┊154┊143┊      const chatAdded = rows[0];\n ┊155┊144┊\n-┊156┊   ┊      await db.query(sql`\n+┊   ┊145┊      await this.db.query(sql`\n ┊157┊146┊        INSERT INTO chats_users(chat_id, user_id)\n ┊158┊147┊        VALUES(${chatAdded.id}, ${userId})\n ┊159┊148┊      `);\n ┊160┊149┊\n-┊161┊   ┊      await db.query(sql`\n+┊   ┊150┊      await this.db.query(sql`\n ┊162┊151┊        INSERT INTO chats_users(chat_id, user_id)\n ┊163┊152┊        VALUES(${chatAdded.id}, ${recipientId})\n ┊164┊153┊      `);\n ┊165┊154┊\n-┊166┊   ┊      await db.query('COMMIT');\n+┊   ┊155┊      await this.db.query('COMMIT');\n ┊167┊156┊\n ┊168┊157┊      this.pubsub.publish('chatAdded', {\n ┊169┊158┊        chatAdded,\n```\n```diff\n@@ -171,18 +160,16 @@\n ┊171┊160┊\n ┊172┊161┊      return chatAdded;\n ┊173┊162┊    } catch (e) {\n-┊174┊   ┊      await db.query('ROLLBACK');\n+┊   ┊163┊      await this.db.query('ROLLBACK');\n ┊175┊164┊      throw e;\n ┊176┊165┊    }\n ┊177┊166┊  }\n ┊178┊167┊\n ┊179┊168┊  async removeChat({ chatId, userId }: { chatId: string; userId: string }) {\n-┊180┊   ┊    const db = await this.db.getClient();\n-┊181┊   ┊\n ┊182┊169┊    try {\n-┊183┊   ┊      await db.query('BEGIN');\n+┊   ┊170┊      await this.db.query('BEGIN');\n ┊184┊171┊\n-┊185┊   ┊      const { rows } = await db.query(sql`\n+┊   ┊172┊      const { rows } = await this.db.query(sql`\n ┊186┊173┊        SELECT chats.* FROM chats, chats_users\n ┊187┊174┊        WHERE id = ${chatId}\n ┊188┊175┊        AND chats.id = chats_users.chat_id\n```\n```diff\n@@ -192,11 +179,11 @@\n ┊192┊179┊      const chat = rows[0];\n ┊193┊180┊\n ┊194┊181┊      if (!chat) {\n-┊195┊   ┊        await db.query('ROLLBACK');\n+┊   ┊182┊        await this.db.query('ROLLBACK');\n ┊196┊183┊        return null;\n ┊197┊184┊      }\n ┊198┊185┊\n-┊199┊   ┊      await db.query(sql`\n+┊   ┊186┊      await this.db.query(sql`\n ┊200┊187┊        DELETE FROM chats WHERE chats.id = ${chatId}\n ┊201┊188┊      `);\n ┊202┊189┊\n```\n```diff\n@@ -205,11 +192,11 @@\n ┊205┊192┊        targetChat: chat,\n ┊206┊193┊      });\n ┊207┊194┊\n-┊208┊   ┊      await db.query('COMMIT');\n+┊   ┊195┊      await this.db.query('COMMIT');\n ┊209┊196┊\n ┊210┊197┊      return chatId;\n ┊211┊198┊    } catch (e) {\n-┊212┊   ┊      await db.query('ROLLBACK');\n+┊   ┊199┊      await this.db.query('ROLLBACK');\n ┊213┊200┊      throw e;\n ┊214┊201┊    }\n ┊215┊202┊  }\n```\n\n##### Changed modules&#x2F;users&#x2F;users.provider.ts\n```diff\n@@ -12,8 +12,7 @@\n ┊12┊12┊  @Inject() private db: Database;\n ┊13┊13┊\n ┊14┊14┊  async findById(userId: string) {\n-┊15┊  ┊    const db = await this.db.getClient();\n-┊16┊  ┊    const { rows } = await db.query(\n+┊  ┊15┊    const { rows } = await this.db.query(\n ┊17┊16┊      sql`SELECT * FROM users WHERE id = ${userId}`\n ┊18┊17┊    );\n ┊19┊18┊\n```\n```diff\n@@ -21,8 +20,7 @@\n ┊21┊20┊  }\n ┊22┊21┊\n ┊23┊22┊  async findAllExcept(userId: string) {\n-┊24┊  ┊    const db = await this.db.getClient();\n-┊25┊  ┊    const { rows } = await db.query(\n+┊  ┊23┊    const { rows } = await this.db.query(\n ┊26┊24┊      sql`SELECT * FROM users WHERE id != ${userId}`\n ┊27┊25┊    );\n ┊28┊26┊\n```\n```diff\n@@ -30,8 +28,7 @@\n ┊30┊28┊  }\n ┊31┊29┊\n ┊32┊30┊  async findByUsername(username: string) {\n-┊33┊  ┊    const db = await this.db.getClient();\n-┊34┊  ┊    const { rows } = await db.query(\n+┊  ┊31┊    const { rows } = await this.db.query(\n ┊35┊32┊      sql`SELECT * FROM users WHERE username = ${username}`\n ┊36┊33┊    );\n ┊37┊34┊\n```\n```diff\n@@ -47,9 +44,8 @@\n ┊47┊44┊    name: string;\n ┊48┊45┊    password: string;\n ┊49┊46┊  }) {\n-┊50┊  ┊    const db = await this.db.getClient();\n ┊51┊47┊    const passwordHash = bcrypt.hashSync(password, bcrypt.genSaltSync(8));\n-┊52┊  ┊    const createdUserQuery = await db.query(sql`\n+┊  ┊48┊    const createdUserQuery = await this.db.query(sql`\n ┊53┊49┊        INSERT INTO users(password, picture, username, name)\n ┊54┊50┊        VALUES(${passwordHash}, ${DEFAULT_PROFILE_PIC}, ${username}, ${name})\n ┊55┊51┊        RETURNING *\n```\n\n[}]: #\n\nDeduplication is done but the `currentUser` method does more than just that. It verifies the auth token extracted from a request's cookie. This could be avoided by an assignment to a private prop and a simple if statement.\n\n[{]: <helper> (diffStep \"14.2\" module=\"server\")\n\n#### [__Server__ Step 14.2: Cache current user object](https://github.com/Urigo/WhatsApp-Clone-Server/commit/a0fe5f6)\n\n##### Changed modules&#x2F;users&#x2F;auth.provider.ts\n```diff\n@@ -14,6 +14,7 @@\n ┊14┊14┊export class Auth {\n ┊15┊15┊  @Inject() private users: Users;\n ┊16┊16┊  @Inject() private module: ModuleSessionInfo;\n+┊  ┊17┊  private _currentUser: User;\n ┊17┊18┊\n ┊18┊19┊  private get req() {\n ┊19┊20┊    return this.module.session.req || this.module.session.request;\n```\n```diff\n@@ -76,11 +77,16 @@\n ┊76┊77┊  }\n ┊77┊78┊\n ┊78┊79┊  async currentUser(): Promise<User | null> {\n+┊  ┊80┊    if (this._currentUser) {\n+┊  ┊81┊      return this._currentUser;\n+┊  ┊82┊    }\n+┊  ┊83┊\n ┊79┊84┊    if (this.req.cookies.authToken) {\n ┊80┊85┊      const username = jwt.verify(this.req.cookies.authToken, secret) as string;\n ┊81┊86┊\n ┊82┊87┊      if (username) {\n-┊83┊  ┊        return this.users.findByUsername(username);\n+┊  ┊88┊        this._currentUser = await this.users.findByUsername(username);\n+┊  ┊89┊        return this._currentUser;\n ┊84┊90┊      }\n ┊85┊91┊    }\n```\n\n[}]: #\n\n![Resolvers](../../../assets/step17/img-02.png \"Resolvers\")\n\nAs you can see at the graph above, we reduced an execution time of `isMine` field from 4ms and 5ms to less than 1. That applies for all calls, all messages so it scales well and won't grow as list of messages increases.\n\nBut there's more... We see `chat` field being computed over and over again. So again, let's repeat the same steps.\nThe `Message.chat` resolver asks `Chats` service and its `findChatById` method which makes a SQL call.\n\nThe deduplication logic, we introduced in the previous step, helps to immediately resolve all `Message.chat` fields except the first occurrence but there's still a space for improvements.\n\nThe `Query.chats` resolver is invoked before the `Message.chat` which means at this point, we already have knowledge about the chats.\n\nLet's implement a caching logic for chats so we could reuse them. We will do it in few steps.\n\nFirst, because we're going to use `Dataloader`, `Chats` class should have private and public API.\n\n[{]: <helper> (diffStep \"14.3\" module=\"server\")\n\n#### [__Server__ Step 14.3: Separate db query from public API](https://github.com/Urigo/WhatsApp-Clone-Server/commit/745543f)\n\n##### Changed modules&#x2F;chats&#x2F;chats.provider.ts\n```diff\n@@ -11,6 +11,10 @@\n ┊11┊11┊  @Inject() private pubsub: PubSub;\n ┊12┊12┊\n ┊13┊13┊  async findChatsByUser(userId: string) {\n+┊  ┊14┊    return this._findChatsByUser(userId);\n+┊  ┊15┊  }\n+┊  ┊16┊\n+┊  ┊17┊  private async _findChatsByUser(userId: string) {\n ┊14┊18┊    const { rows } = await this.db.query(sql`\n ┊15┊19┊      SELECT chats.* FROM chats, chats_users\n ┊16┊20┊      WHERE chats.id = chats_users.chat_id\n```\n\n[}]: #\n\nThe private method is responsible for quering data from the database but the public one is to allow communication between the service and its consumers.\nIt's also there so we could switch to using Dataloader later on.\n\nWe did that to `findChatsByUser` but there are more:\n\n[{]: <helper> (diffStep \"14.4\" module=\"server\")\n\n#### [__Server__ Step 14.4: Separate findChatByUser](https://github.com/Urigo/WhatsApp-Clone-Server/commit/17414f9)\n\n##### Changed modules&#x2F;chats&#x2F;chats.provider.ts\n```diff\n@@ -25,6 +25,18 @@\n ┊25┊25┊  }\n ┊26┊26┊\n ┊27┊27┊  async findChatByUser({ chatId, userId }: { chatId: string; userId: string }) {\n+┊  ┊28┊    const rows = await this._findChatByUser({ chatId, userId });\n+┊  ┊29┊\n+┊  ┊30┊    return rows[0] || null;\n+┊  ┊31┊  }\n+┊  ┊32┊\n+┊  ┊33┊  private async _findChatByUser({\n+┊  ┊34┊    chatId,\n+┊  ┊35┊    userId,\n+┊  ┊36┊  }: {\n+┊  ┊37┊    chatId: string;\n+┊  ┊38┊    userId: string;\n+┊  ┊39┊  }) {\n ┊28┊40┊    const { rows } = await this.db.query(sql`\n ┊29┊41┊      SELECT chats.* FROM chats, chats_users\n ┊30┊42┊      WHERE chats_users.chat_id = ${chatId}\n```\n```diff\n@@ -32,7 +44,7 @@\n ┊32┊44┊      AND chats_users.user_id = ${userId}\n ┊33┊45┊    `);\n ┊34┊46┊\n-┊35┊  ┊    return rows[0] || null;\n+┊  ┊47┊    return rows;\n ┊36┊48┊  }\n ┊37┊49┊\n ┊38┊50┊  async findChatById(chatId: string) {\n```\n\n[}]: #\n[{]: <helper> (diffStep \"14.5\" module=\"server\")\n\n#### [__Server__ Step 14.5: Separate findChatById](https://github.com/Urigo/WhatsApp-Clone-Server/commit/275d39c)\n\n##### Changed modules&#x2F;chats&#x2F;chats.provider.ts\n```diff\n@@ -48,10 +48,15 @@\n ┊48┊48┊  }\n ┊49┊49┊\n ┊50┊50┊  async findChatById(chatId: string) {\n+┊  ┊51┊    const rows = await this._findChatById(chatId);\n+┊  ┊52┊    return rows[0] || null;\n+┊  ┊53┊  }\n+┊  ┊54┊\n+┊  ┊55┊  private async _findChatById(chatId: string) {\n ┊51┊56┊    const { rows } = await this.db.query(sql`\n ┊52┊57┊      SELECT * FROM chats WHERE id = ${chatId}\n ┊53┊58┊    `);\n-┊54┊  ┊    return rows[0] || null;\n+┊  ┊59┊    return rows;\n ┊55┊60┊  }\n ┊56┊61┊\n ┊57┊62┊  async findMessagesByChat(chatId: string) {\n```\n\n[}]: #\n\n> Because those private methods are just to query data, make sure they all return untouched `row` object.\n\nNow's the most interesting part, Dataloader.\n\n[{]: <helper> (diffStep \"14.6\" module=\"server\")\n\n#### [__Server__ Step 14.6: Use Dataloader in Chats](https://github.com/Urigo/WhatsApp-Clone-Server/commit/9bf654b)\n\n##### Changed modules&#x2F;chats&#x2F;chats.provider.ts\n```diff\n@@ -1,8 +1,23 @@\n ┊ 1┊ 1┊import { Injectable, Inject, ProviderScope } from '@graphql-modules/di';\n+┊  ┊ 2┊import { QueryResult } from 'pg';\n ┊ 2┊ 3┊import sql from 'sql-template-strings';\n+┊  ┊ 4┊import DataLoader from 'dataloader';\n ┊ 3┊ 5┊import { Database } from '../common/database.provider';\n ┊ 4┊ 6┊import { PubSub } from '../common/pubsub.provider';\n ┊ 5┊ 7┊\n+┊  ┊ 8┊type ChatsByUser = { userId: string };\n+┊  ┊ 9┊type ChatByUser = { userId: string; chatId: string };\n+┊  ┊10┊type ChatById = { chatId: string };\n+┊  ┊11┊type ChatsKey = ChatById | ChatByUser | ChatsByUser;\n+┊  ┊12┊\n+┊  ┊13┊function isChatsByUser(query: any): query is ChatsByUser {\n+┊  ┊14┊  return query.userId && !query.chatId;\n+┊  ┊15┊}\n+┊  ┊16┊\n+┊  ┊17┊function isChatByUser(query: any): query is ChatByUser {\n+┊  ┊18┊  return query.userId && query.chatId;\n+┊  ┊19┊}\n+┊  ┊20┊\n ┊ 6┊21┊@Injectable({\n ┊ 7┊22┊  scope: ProviderScope.Session,\n ┊ 8┊23┊})\n```\n```diff\n@@ -10,8 +25,26 @@\n ┊10┊25┊  @Inject() private db: Database;\n ┊11┊26┊  @Inject() private pubsub: PubSub;\n ┊12┊27┊\n+┊  ┊28┊  private loaders = {\n+┊  ┊29┊    chats: new DataLoader<ChatsKey, QueryResult['rows']>(keys => {\n+┊  ┊30┊      return Promise.all(\n+┊  ┊31┊        keys.map(async query => {\n+┊  ┊32┊          if (isChatsByUser(query)) {\n+┊  ┊33┊            return this._findChatsByUser(query.userId);\n+┊  ┊34┊          }\n+┊  ┊35┊\n+┊  ┊36┊          if (isChatByUser(query)) {\n+┊  ┊37┊            return this._findChatByUser(query);\n+┊  ┊38┊          }\n+┊  ┊39┊\n+┊  ┊40┊          return this._findChatById(query.chatId);\n+┊  ┊41┊        })\n+┊  ┊42┊      );\n+┊  ┊43┊    }),\n+┊  ┊44┊  };\n+┊  ┊45┊\n ┊13┊46┊  async findChatsByUser(userId: string) {\n-┊14┊  ┊    return this._findChatsByUser(userId);\n+┊  ┊47┊    return this.loaders.chats.load({ userId });\n ┊15┊48┊  }\n ┊16┊49┊\n ┊17┊50┊  private async _findChatsByUser(userId: string) {\n```\n```diff\n@@ -25,7 +58,7 @@\n ┊25┊58┊  }\n ┊26┊59┊\n ┊27┊60┊  async findChatByUser({ chatId, userId }: { chatId: string; userId: string }) {\n-┊28┊  ┊    const rows = await this._findChatByUser({ chatId, userId });\n+┊  ┊61┊    const rows = await this.loaders.chats.load({ chatId, userId });\n ┊29┊62┊\n ┊30┊63┊    return rows[0] || null;\n ┊31┊64┊  }\n```\n```diff\n@@ -48,7 +81,7 @@\n ┊48┊81┊  }\n ┊49┊82┊\n ┊50┊83┊  async findChatById(chatId: string) {\n-┊51┊  ┊    const rows = await this._findChatById(chatId);\n+┊  ┊84┊    const rows = await this.loaders.chats.load({ chatId });\n ┊52┊85┊    return rows[0] || null;\n ┊53┊86┊  }\n ┊54┊87┊\n```\n\n##### Changed package.json\n```diff\n@@ -53,6 +53,7 @@\n ┊53┊53┊    \"cookie\": \"0.4.0\",\n ┊54┊54┊    \"cookie-parser\": \"1.4.4\",\n ┊55┊55┊    \"cors\": \"2.8.5\",\n+┊  ┊56┊    \"dataloader\": \"1.4.0\",\n ┊56┊57┊    \"express\": \"4.17.1\",\n ┊57┊58┊    \"graphql\": \"14.3.1\",\n ┊58┊59┊    \"graphql-import\": \"0.7.1\",\n```\n\n[}]: #\n\nWe introduced `ChatsKey` that is a union type, to standarize the input value. Those helper methods like `isChatsByUser` and `isChatByUser` are there to decide what should be fetched.\n\nIn every public method that we previously changed, there's now Dataloader in use but that's not entirely what we're trying to achieve.\n\nThe caching mechanism is not yet completed. We deduplicate requests but in some cases, we ask for chats that are already there, so we need to intercept our dataloader logic and introduce caching.\n\n[{]: <helper> (diffStep \"14.7\" module=\"server\")\n\n#### [__Server__ Step 14.7: Implement caching for Chats](https://github.com/Urigo/WhatsApp-Clone-Server/commit/f158dd6)\n\n##### Changed modules&#x2F;chats&#x2F;chats.provider.ts\n```diff\n@@ -4,6 +4,7 @@\n ┊ 4┊ 4┊import DataLoader from 'dataloader';\n ┊ 5┊ 5┊import { Database } from '../common/database.provider';\n ┊ 6┊ 6┊import { PubSub } from '../common/pubsub.provider';\n+┊  ┊ 7┊import { Chat } from '../../db';\n ┊ 7┊ 8┊\n ┊ 8┊ 9┊type ChatsByUser = { userId: string };\n ┊ 9┊10┊type ChatByUser = { userId: string; chatId: string };\n```\n```diff\n@@ -25,6 +26,7 @@\n ┊25┊26┊  @Inject() private db: Database;\n ┊26┊27┊  @Inject() private pubsub: PubSub;\n ┊27┊28┊\n+┊  ┊29┊  private chatsCache = new Map<string, Chat>();\n ┊28┊30┊  private loaders = {\n ┊29┊31┊    chats: new DataLoader<ChatsKey, QueryResult['rows']>(keys => {\n ┊30┊32┊      return Promise.all(\n```\n```diff\n@@ -33,6 +35,10 @@\n ┊33┊35┊            return this._findChatsByUser(query.userId);\n ┊34┊36┊          }\n ┊35┊37┊\n+┊  ┊38┊          if (this.chatsCache.has(query.chatId)) {\n+┊  ┊39┊            return [this._readChatFromCache(query.chatId)];\n+┊  ┊40┊          }\n+┊  ┊41┊\n ┊36┊42┊          if (isChatByUser(query)) {\n ┊37┊43┊            return this._findChatByUser(query);\n ┊38┊44┊          }\n```\n```diff\n@@ -254,4 +260,14 @@\n ┊254┊260┊      throw e;\n ┊255┊261┊    }\n ┊256┊262┊  }\n+┊   ┊263┊\n+┊   ┊264┊  private _readChatFromCache(chatId: string) {\n+┊   ┊265┊    return this.chatsCache.get(chatId);\n+┊   ┊266┊  }\n+┊   ┊267┊\n+┊   ┊268┊  private _writeChatToCache(chat?: Chat) {\n+┊   ┊269┊    if (chat) {\n+┊   ┊270┊      this.chatsCache.set(chat.id, chat);\n+┊   ┊271┊    }\n+┊   ┊272┊  }\n ┊257┊273┊}\n```\n\n[}]: #\n\nWhenever we ask for a single chat that is available, it's being resolved right away but we still need to write data to the cache.\n\n[{]: <helper> (diffStep \"14.8\" module=\"server\")\n\n#### [__Server__ Step 14.8: Write chats to the cache](https://github.com/Urigo/WhatsApp-Clone-Server/commit/06baa2b)\n\n##### Changed modules&#x2F;chats&#x2F;chats.provider.ts\n```diff\n@@ -60,6 +60,10 @@\n ┊60┊60┊      AND chats_users.user_id = ${userId}\n ┊61┊61┊    `);\n ┊62┊62┊\n+┊  ┊63┊    rows.forEach(row => {\n+┊  ┊64┊      this._writeChatToCache(row);\n+┊  ┊65┊    });\n+┊  ┊66┊\n ┊63┊67┊    return rows;\n ┊64┊68┊  }\n ┊65┊69┊\n```\n```diff\n@@ -83,6 +87,8 @@\n ┊83┊87┊      AND chats_users.user_id = ${userId}\n ┊84┊88┊    `);\n ┊85┊89┊\n+┊  ┊90┊    this._writeChatToCache(rows[0]);\n+┊  ┊91┊\n ┊86┊92┊    return rows;\n ┊87┊93┊  }\n ┊88┊94┊\n```\n```diff\n@@ -95,6 +101,9 @@\n ┊ 95┊101┊    const { rows } = await this.db.query(sql`\n ┊ 96┊102┊      SELECT * FROM chats WHERE id = ${chatId}\n ┊ 97┊103┊    `);\n+┊   ┊104┊\n+┊   ┊105┊    this._writeChatToCache(rows[0]);\n+┊   ┊106┊\n ┊ 98┊107┊    return rows;\n ┊ 99┊108┊  }\n```\n\n[}]: #\n\nLet's look at charts in Apollo Engine.\n\n![Resolvers](../../../assets/step17/img-03.png \"Resolvers\")\n\nWe cut off `Message.chat` to less than 1ms.\n\nThe `Chat.name` and `Chat.picture` resolvers share the same logic and since Database service is wrapped with DataLoader, we make a single SQL query. Unfortunately, it's not visible on the graph.\n\nLet's summarize our work. **We made the GetChat operation almost 60% faster on average** and it's just based on one chat with one message. The number would be much much higher on a bigger scale.\n\n### Preventing issues\n\nThe Apollo Engine has another interesting feature. It’s called Alerts. You set a threshold for all operations or a specific one and whenever it takes longer, you get a notification on Slack. But there’s a catch, you need to pay in order to unlock it.\n\nWe’re working on something similar but entirely open-sourced. It’s an extension of ApolloServer that lets you track operations and get exactly what you would get from the engine but self-hosted.\n\n## UI Performance\n\nThe part would be the User Interface and the web app in general.\n\n### Metrics\n\nThere's a highly recommended and very comprehensive publication written by Philip Walton (Engineer at Google) called [\"User-centric Performance Metrics\"](https://developers.google.com/web/fundamentals/performance/user-centric-performance-metrics) that was an inspiration for this chapter. We’re going to talk in short about measuring render performance of a web application.\n\nLet’s base this chapter on real data. First, open the app and go to Performance tab of Chrome DevTools.\n\n![Record](../../../assets/step17/img-04.png \"Record\")\n\nNow click on “Start profiling and reload page”. After it’s done you should see the following:\n\n![All panels](../../../assets/step17/img-05.png \"All panels\")\n\nRight now it may not make a lot of sense, so we’re going to start with something basic.\n\nThere’s many different kinds of charts but we will cover only few of them: Network, Frames, Timings and Main.\n\nLet’s check out the Timings section and explain few important performance metrics.\n\n- DCL - DOMContentLoaded Event\n- L - Onload Event\n- FP - First Paint\n- FCP - First Contentful Paint\n- FMP - First Meaningful Paint\n\nThere’s also another one that is not visible on the timeline but also not less important, TTI - Time to Interactive.\n\nWe will focus on FP, FCP, FMP and TTI.\n\nThe primary difference between the two metrics is **First Paint** marks the point when the browser renders anything that is visually different from what was on the screen prior to navigation. By contrast, **First Contentful Paint** is the point when the browser renders the first bit of content from the DOM, which may be text, an image, SVG, or even a `<canvas>` element.\n\nThe **First Meaningful Paint** should mark the point when something useful was rendered. It might mean an input box on Google, video player on YouTube or in our case, a list of chats.\n\nThe **Time To Interactive** metric marks the point at which the application is both visually rendered and capable of reliably responding to user input.\n\nNow with all that knowledge we can move on to something more practical, the **Frames panel**. The main purpose here is to see what’s rendered at given time. In our case, the first paint was made after over 200ms, which is not a bad result at all but see that huge blank space next to it.\n\nThe **Network section**, is going to help us out here and give some pointers of what might be a reason of it. It’s a timeline that explains when each request was made and how long it took to resolve.\n\n![Network section](../../../assets/step17/img-06.png \"Network section\")\n\nWhat do we see here? One of the first requests are js files and we need those to bootstrap and render the app. That’s the reason of the blank page.\n\nWe could improve that by either Server-Side Rendering or using a Service Worker.\n\n### Rendering improvements\n\n#### Server-Side Rendering\n\nImplementing SSR means you run the app on server, before it’s being shipped to the client and the document’s content is not just `<html><body><app></app></body></html>` but an actual markup with all the components in it. Because it’s a part of the document, the browser can already display something meaningful and after js files are loaded, the app bootstraps on the client and it becomes interactive. There is one caveat. Wherever you ship the app it has to be able to run node js.\n\n#### Store Rehydration\n\nWhen talking SSR it’s worth to mention GraphQL and related technique called Store Rehydration. API calls are an important part of an application and plays a huge role in SSR.\n\nGraphQL operations are called once components are mounted which means the cache is filled up and why not reuse it on client.\n\nHow would it work? Data is extracted from the apollo’s cache and passed within a document. After it’s received by the browser, the app runs and so does the Apollo Client. While it happens we look for the data and fill up the cache. Now whenever a component calls a GraphQL operation, the result is already in the cache and resolves immediately.\n\n#### Service Worker\n\nAnother approach is a bit different. By using a Service Worker, we’re able to control and cache requests, including js files, images etc. On the first visit, the app loads exactly the same as without SSR but the next visits are a bit faster. It’s because the Service Worker is registered after you close the app and of course we can’t cache things that weren’t fetched yet.\n\nBoth techniques are not mutually exclusive and we highly recommend to use both.\n\n![Main section](../../../assets/step17/img-07.png \"Main section\")\n\nThe next section we’re going to talk about is the **Main panel**, a flame chart of activity on the main thread. You see those blocks? They represent an event, the wider it is the longer it took. One of the most important things to remember is to avoid long events since they block the thread.\nThe longest event on our timeline is the Evaluate Script event that involves `main.js`. The file contains all the libraries and the core functionality, those are needed to run the app. By making it lighter we would decrease the time of the first render.\nWe already do something to reduce the bundle size, This technique we use is called code-splitting and it allows to split one piece of code into multiple files which are lazy loaded.\nIt cuts off the size of the main bundle and the rest is loaded on demand, let’s say login page is in a different chunk than list of chats.\n\n### Tooling\n\nThere’s one tool built into Chrome DevTools called Lighthouse that allows to measure, collect metrics and get helpful tips on how to improve the performance and where are the pain points.\n\nHere’s the example:\n\n![Lighthouse results](../../../assets/step17/img-08.png \"Lighthouse results\")\n\nOnce your app is optimized you want to prevent regressions. Lighthouse has you covered! It may run as part of Continuous Integration and prevents deployment when key metrics regress or drop below a certain threshold.\n\n## Making the app feels instant\n\nDealing with slow network can be hard so let's simulate that situation. After all, running the application on local host will always result in low response times.\n\nLuckily most browser come with a built in solution for that - we can simulate a slow network by defining the throttle level:\n\n![Throttling](../../../assets/step17/img-09.png \"Throttling\")\n\nIf we will refresh the application, we should notice a significant slow down the first time we load each screen; about few seconds to load each of them. To ensure that this is really caused by a slow network and not by anything else, we can open the dev-tools of our browser (let’s assume you use Chrome) and under the `network` tab we should notice the network activity times.\n\n> More information about monitoring network activity and throttling it using the Chrome’s dev-tools can be found in [the official dev-tools docs page](https://developers.google.com/web/tools/chrome-devtools/network/).\n\nTo solve these issues there are a couple of changes we’re gonna make in the way we fetch and manage data.\n\n### Optimistic UI\n\nAs you know, pretty much in all cases, everything in Apollo flows through its cache. If a requested data is in there, a query is resolved right away. Mutations are a bit different, they have to reach the server every single time. Seems like nothing we can do about it but fortunately we can simulate the mutation, predict the result and make Apollo treat it as a temporary data. Which means, the app’s state and all components are updated and the change is visible instantly after it’s made.\n\nIn case of the WhatsApp clone, whenever a new message is sent, we will see it right away, on the screen, doesn’t matter if the network is low or even super fast. You may experience the similar behavior on Facebook’s Messenger.\n\n\n```graphql\n  mutation AddMessage($chatId: ID!, $content: String!) {\n    addMessage(chatId: $chatId, content: $content) {\n      ...Message\n    }\n  }\n```\n\n```graphql\n  addMessage({\n    variables: { chatId, content },\n    optimisticResponse: {\n      __typename: 'Mutation',\n      addMessage: {\n        __typename: 'Message',\n        id: Math.random().toString(36).substr(2, 9),\n        createdAt: new Date(),\n        isMine: true,\n        chat: {\n          __typename: 'Chat',\n          id: chatId,\n        },\n        content,\n      }\n    },\n    update: (client, { data: { addMessage } }) => {\n      writeMessage(client, addMessage);\n    },\n  })\n```\n\nWe used words “predict” and “simulate”, what if the mutation behaves differently or what’s more interesting, it fails. Apollo handles that as well. The “real” response overwrites the fake one and the store is reverted back to the original state.\n\n### Prefetching data\n\nAnother technique but with a bit different purpose is about fetching data in advance. In some situations, you might be able to predict which page/component is going to be entered next.\n\nLet’s base it on a real example. The WhatsApp clone has a page with a list of chats. The component that represents the page, calls a GraphQL operation to fetch that list. Right now, when user clicks on one of the chats, he’s redirected to a partially empty page because of the ongoing GraphQL request. What if we could fetch that data in advance? That’s what this technique is about. We could predict user’s next move based on a simple mouse event or even by using Artificial Intelligence and data collected by Google Analytics, so whenever the move actually happens, the data is already in the cache.\n\n[{]: <helper> (diffStep \"15.1\" files=\"src/components/ChatRoomScreen/index.tsx\" module=\"client\")\n\n#### [__Client__ Step 15.1: Implement prefetching](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/f8a5c4e)\n\n##### Changed src&#x2F;components&#x2F;ChatRoomScreen&#x2F;index.tsx\n```diff\n@@ -2,12 +2,19 @@\n ┊ 2┊ 2┊import React from 'react';\n ┊ 3┊ 3┊import { useCallback } from 'react';\n ┊ 4┊ 4┊import { Redirect } from 'react-router-dom';\n+┊  ┊ 5┊import { useApolloClient } from 'react-apollo-hooks';\n ┊ 5┊ 6┊import styled from 'styled-components';\n ┊ 6┊ 7┊import ChatNavbar from './ChatNavbar';\n ┊ 7┊ 8┊import MessageInput from './MessageInput';\n ┊ 8┊ 9┊import MessagesList from './MessagesList';\n ┊ 9┊10┊import { History } from 'history';\n-┊10┊  ┊import { useGetChatQuery, useAddMessageMutation } from '../../graphql/types';\n+┊  ┊11┊import {\n+┊  ┊12┊  useGetChatQuery,\n+┊  ┊13┊  useAddMessageMutation,\n+┊  ┊14┊  GetChatQuery,\n+┊  ┊15┊  GetChatQueryVariables,\n+┊  ┊16┊  GetChatDocument,\n+┊  ┊17┊} from '../../graphql/types';\n ┊11┊18┊import * as fragments from '../../graphql/fragments';\n ┊12┊19┊import { writeMessage } from '../../services/cache.service';\n ┊13┊20┊\n```\n```diff\n@@ -38,6 +45,19 @@\n ┊38┊45┊  ${fragments.message}\n ┊39┊46┊`;\n ┊40┊47┊\n+┊  ┊48┊export const useGetChatPrefetch = () => {\n+┊  ┊49┊  const client = useApolloClient();\n+┊  ┊50┊\n+┊  ┊51┊  return (chatId: string) => {\n+┊  ┊52┊    client.query<GetChatQuery, GetChatQueryVariables>({\n+┊  ┊53┊      query: GetChatDocument,\n+┊  ┊54┊      variables: {\n+┊  ┊55┊        chatId,\n+┊  ┊56┊      },\n+┊  ┊57┊    });\n+┊  ┊58┊  };\n+┊  ┊59┊};\n+┊  ┊60┊\n ┊41┊61┊interface ChatRoomScreenParams {\n ┊42┊62┊  chatId: string;\n ┊43┊63┊  history: History;\n```\n\n[}]: #\n\nWe created the `useGetChatPrefetch` hook that gets ApolloClient instance through `useApolloClient` and returns a function to prefetch data. In this case we request `GetChat` operation. Because Apollo deduplicates queries, we won't make multiple http calls, we're safe.\n\nThe actual usage of `useGetChatPrefetch`, happens on `mouse entered` event:\n\n[{]: <helper> (diffStep \"15.1\" files=\"src/components/ChatsListScreen/ChatsList.tsx\" module=\"client\")\n\n#### [__Client__ Step 15.1: Implement prefetching](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/f8a5c4e)\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;ChatsList.tsx\n```diff\n@@ -5,6 +5,7 @@\n ┊ 5┊ 5┊import { useCallback } from 'react';\n ┊ 6┊ 6┊import { History } from 'history';\n ┊ 7┊ 7┊import { useChatsQuery } from '../../graphql/types';\n+┊  ┊ 8┊import { useGetChatPrefetch } from '../ChatRoomScreen';\n ┊ 8┊ 9┊\n ┊ 9┊10┊const Container = styled.div`\n ┊10┊11┊  height: calc(100% - 56px);\n```\n```diff\n@@ -69,6 +70,7 @@\n ┊69┊70┊    },\n ┊70┊71┊    [history]\n ┊71┊72┊  );\n+┊  ┊73┊  const prefetchChat = useGetChatPrefetch();\n ┊72┊74┊\n ┊73┊75┊  const { data } = useChatsQuery();\n ┊74┊76┊\n```\n```diff\n@@ -86,7 +88,10 @@\n ┊86┊88┊            key={chat.id}\n ┊87┊89┊            data-testid=\"chat\"\n ┊88┊90┊            button\n-┊89┊  ┊            onClick={navToChat.bind(null, chat)}>\n+┊  ┊91┊            onClick={navToChat.bind(null, chat)}\n+┊  ┊92┊            onMouseEnter={() => {\n+┊  ┊93┊              prefetchChat(chat.id);\n+┊  ┊94┊            }}>\n ┊90┊95┊            <ChatPicture\n ┊91┊96┊              data-testid=\"picture\"\n ┊92┊97┊              src={chat.picture}\n```\n\n[}]: #\n\nNow, the same but with the list of users:\n\n[{]: <helper> (diffStep \"15.1\" files=\"src/components/ChatsListScreen/AddChatButton.tsx\" module=\"client\")\n\n#### [__Client__ Step 15.1: Implement prefetching](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/f8a5c4e)\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;AddChatButton.tsx\n```diff\n@@ -3,6 +3,7 @@\n ┊3┊3┊import React from 'react';\n ┊4┊4┊import styled from 'styled-components';\n ┊5┊5┊import { History } from 'history';\n+┊ ┊6┊import { useUsersPrefetch } from '../UsersList';\n ┊6┊7┊\n ┊7┊8┊const Container = styled.div`\n ┊8┊9┊  position: fixed;\n```\n```diff\n@@ -18,17 +19,19 @@\n ┊18┊19┊    color: white;\n ┊19┊20┊  }\n ┊20┊21┊`;\n+┊  ┊22┊\n ┊21┊23┊interface ChildComponentProps {\n ┊22┊24┊  history: History;\n ┊23┊25┊}\n ┊24┊26┊\n ┊25┊27┊const AddChatButton: React.FC<ChildComponentProps> = ({ history }) => {\n+┊  ┊28┊  const prefetchUsers = useUsersPrefetch();\n ┊26┊29┊  const onClick = () => {\n ┊27┊30┊    history.push('/new-chat');\n ┊28┊31┊  };\n ┊29┊32┊\n ┊30┊33┊  return (\n-┊31┊  ┊    <Container>\n+┊  ┊34┊    <Container onMouseEnter={() => prefetchUsers()}>\n ┊32┊35┊      <Button\n ┊33┊36┊        data-testid=\"new-chat-button\"\n ┊34┊37┊        variant=\"contained\"\n```\n\n[}]: #\n[{]: <helper> (diffStep \"15.1\" files=\"src/components/ChatsListScreen/ChatsList.tsx\" module=\"client\")\n\n#### [__Client__ Step 15.1: Implement prefetching](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/f8a5c4e)\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;ChatsList.tsx\n```diff\n@@ -5,6 +5,7 @@\n ┊ 5┊ 5┊import { useCallback } from 'react';\n ┊ 6┊ 6┊import { History } from 'history';\n ┊ 7┊ 7┊import { useChatsQuery } from '../../graphql/types';\n+┊  ┊ 8┊import { useGetChatPrefetch } from '../ChatRoomScreen';\n ┊ 8┊ 9┊\n ┊ 9┊10┊const Container = styled.div`\n ┊10┊11┊  height: calc(100% - 56px);\n```\n```diff\n@@ -69,6 +70,7 @@\n ┊69┊70┊    },\n ┊70┊71┊    [history]\n ┊71┊72┊  );\n+┊  ┊73┊  const prefetchChat = useGetChatPrefetch();\n ┊72┊74┊\n ┊73┊75┊  const { data } = useChatsQuery();\n ┊74┊76┊\n```\n```diff\n@@ -86,7 +88,10 @@\n ┊86┊88┊            key={chat.id}\n ┊87┊89┊            data-testid=\"chat\"\n ┊88┊90┊            button\n-┊89┊  ┊            onClick={navToChat.bind(null, chat)}>\n+┊  ┊91┊            onClick={navToChat.bind(null, chat)}\n+┊  ┊92┊            onMouseEnter={() => {\n+┊  ┊93┊              prefetchChat(chat.id);\n+┊  ┊94┊            }}>\n ┊90┊95┊            <ChatPicture\n ┊91┊96┊              data-testid=\"picture\"\n ┊92┊97┊              src={chat.picture}\n```\n\n[}]: #\n\n### Splitting and Deferring Queries\n\nPrefetching is an easy way to make your applications UI feel faster. You can use mouse events to predict the data that could be needed. This is powerful and works perfectly on the browser, but can not be applied to a mobile device.\n\nOne solution for improving the UI experience would be the usage of fragments to preload more data in a query, but loading huge amounts of data (that you probably never show to the user) is expensive.\n\nAnother solution would be to **split huge queries into two smaller queries**:\n\n- The first one could load data which is already in the store. This means that it can be displayed instantly.\n- The second query could load data which is not in the store yet and must be fetched from the server first.\n\nThis solution gives you the benefit of not fetching too much data, as well as the possibility to show some part of the views data before the server responds.\n\nThis could be used in our messaging app to load chat’s information and messages separately. This way we will see the title and the image instantly, because it’s already in the cache but messages will be loaded afterwards. UX will benefit a lot.\n\nThere’s also something very similar conceptually to Query Splitting but instead of separating queries we keep everything in one operation and annotate the parts that should be deferred. The annotation is, of course a directive and it’s called **`@defer`**.\n\nOnce the `@defer` is used, the server returns an initial response without waiting for deferred fields to resolve, using null as placeholders for them. Then, it streams patches for each deferred field asynchronously as they resolve. Thanks to that, we maintain one operation but decide how it behaves.\n\n> Right now, this feature is not well supported in Apollo Server so we don’t recommend to use it yet. Keep it on mind though.\n\n### Dealing with rendering issues\n\nThe most naive thing we can do to start noticing performance issues would be loading TONS of data to our app, and make sure that each view is absolutely overwhelmed with information. This way performance issues will start rising above the surface pretty quickly. To do that, we will edit the `resetDb()` method on the server so it can generate large quantities of data. The most comfortable way of controlling that behavior would be through an environment variable that will tell the reset method how much iterations it should run. The more iterations, the more data would be fabricated:\n\n[{]: <helper> (diffStep \"15.10\" module=\"server\")\n\n#### Step 15.10: NOT FOUND!\n\n[}]: #\n\nIt’s important to note that we’ve generated the data in a very specific way where a single user will be the center of the network of data. This way when we log in with that user, we should see our views packed. If it wasn’t for that we would have just had large quantities of data in the DB, but none of it would appear to the end-user.\n\nNow, we will restart the server and this time run it differently. We will provide `FAKED_DB` with a value of `100` which should connect us to 100 messages per single view:\n\n    RESET_DB=true FAKED_DB=100 yarn start\n\nNow make sure that the application is running and log-in with the first user of Ray Edwards using the credentials:\n\n    username: ray\n    passowrd: 111\n\nNow try to navigate around between the `ChatsScreen` and `ChatBoxScreen`. You’ll notice that each transition takes a long time until it shows the data. It’s obviously something which is related to rendering and not data transportation, because the slowdown also happens the second time you visit a view, a point where the fetched data should have already been stored by Apollo in cache. So we’ve already detected one performance issue we should deal with.\n\n### Pagination\n\nTo solve it, there are couple of changes we’re gonna make in the way we ask for data, messages will be fetched dynamically based on our scrolling position.\n\nWith these changes, the requests will be splitted into smaller chunks, and React DOM won’t have to deal with a lot of data the first time it loads. There are few challenges that may arise from this implementation:\n\n- Representing queries in a way that they can be loaded in chunks\n- Sending requests and updating the view dynamically\n- Maintaining updates from subscriptions\n\nTo start with, we will first take on the task of improving initialization times. We will release the pressure by fetching only the first 20 messages. This way when we visit a chat, it should be loaded faster.\n\nFor that we're going to implement cursor-based pagination. We will add `after` and `limit` arguments to `Chat.messages` that could be used to fetch a specific snapshot of available messages.\n\n- `after` is optional and marks the point where the last fetch ended (what is the last element of a received list)\n- `limit` is required, defines amount of data\n\nA common design pattern for fetching data snapshots from a GraphQL back-end is called [Relay](https://facebook.github.io/relay/docs/en/graphql-server-specification.html). Relay provides a robust solution which is suitable for things like search engines.\n\nWe will define our own version of it.\n\n[{]: <helper> (diffStep \"14.9\" module=\"server\")\n\n#### [__Server__ Step 14.9: Add fake data](https://github.com/Urigo/WhatsApp-Clone-Server/commit/c126e2c)\n\n##### Changed db.ts\n```diff\n@@ -1,6 +1,8 @@\n ┊1┊1┊import { Pool } from 'pg';\n ┊2┊2┊import sql from 'sql-template-strings';\n-┊3┊ ┊import { resetDb as envResetDb } from './env';\n+┊ ┊3┊import faker from 'faker';\n+┊ ┊4┊import addMinutes from 'date-fns/add_minutes';\n+┊ ┊5┊import { resetDb as envResetDb, fakedDb } from './env';\n ┊4┊6┊\n ┊5┊7┊export type User = {\n ┊6┊8┊  id: string;\n```\n```diff\n@@ -234,6 +236,10 @@\n ┊234┊236┊    },\n ┊235┊237┊  ];\n ┊236┊238┊\n+┊   ┊239┊  if (fakedDb) {\n+┊   ┊240┊    addFakedMessages(sampleMessages, fakedDb);\n+┊   ┊241┊  }\n+┊   ┊242┊\n ┊237┊243┊  for (const sampleMessage of sampleMessages) {\n ┊238┊244┊    await pool.query(sql`\n ┊239┊245┊      INSERT INTO messages(id, content, created_at, chat_id, sender_user_id)\n```\n```diff\n@@ -248,6 +254,21 @@\n ┊248┊254┊  );\n ┊249┊255┊};\n ┊250┊256┊\n+┊   ┊257┊function addFakedMessages(messages: Message[], count: number) {\n+┊   ┊258┊  const message = messages[0];\n+┊   ┊259┊  const date = message.created_at;\n+┊   ┊260┊  const id = messages.length + 1;\n+┊   ┊261┊\n+┊   ┊262┊  new Array(count).fill(0).forEach((_, i) => {\n+┊   ┊263┊    messages.push({\n+┊   ┊264┊      ...message,\n+┊   ┊265┊      id: `${id + i}`,\n+┊   ┊266┊      content: faker.lorem.sentence(4),\n+┊   ┊267┊      created_at: addMinutes(date, i + 1),\n+┊   ┊268┊    });\n+┊   ┊269┊  });\n+┊   ┊270┊}\n+┊   ┊271┊\n ┊251┊272┊if (envResetDb) {\n ┊252┊273┊  resetDb();\n ┊253┊274┊}\n```\n\n##### Changed env.ts\n```diff\n@@ -5,3 +5,6 @@\n ┊ 5┊ 5┊export const origin = process.env.ORIGIN || 'http://localhost:3000';\n ┊ 6┊ 6┊export const port = process.env.PORT || 4000;\n ┊ 7┊ 7┊export const resetDb = process.env.RESET_DB || false;\n+┊  ┊ 8┊export const fakedDb = process.env.FAKED_DB\n+┊  ┊ 9┊  ? parseInt(process.env.FAKED_DB, 10)\n+┊  ┊10┊  : 0;\n```\n\n##### Changed package.json\n```diff\n@@ -26,6 +26,7 @@\n ┊26┊26┊    \"@types/cookie-parser\": \"1.4.1\",\n ┊27┊27┊    \"@types/cors\": \"2.8.5\",\n ┊28┊28┊    \"@types/express\": \"4.17.0\",\n+┊  ┊29┊    \"@types/faker\": \"4.1.5\",\n ┊29┊30┊    \"@types/graphql\": \"14.2.1\",\n ┊30┊31┊    \"@types/graphql-iso-date\": \"3.3.1\",\n ┊31┊32┊    \"@types/jest\": \"24.0.15\",\n```\n```diff\n@@ -54,7 +55,9 @@\n ┊54┊55┊    \"cookie-parser\": \"1.4.4\",\n ┊55┊56┊    \"cors\": \"2.8.5\",\n ┊56┊57┊    \"dataloader\": \"1.4.0\",\n+┊  ┊58┊    \"date-fns\": \"1.30.1\",\n ┊57┊59┊    \"express\": \"4.17.1\",\n+┊  ┊60┊    \"faker\": \"4.1.0\",\n ┊58┊61┊    \"graphql\": \"14.3.1\",\n ┊59┊62┊    \"graphql-import\": \"0.7.1\",\n ┊60┊63┊    \"graphql-iso-date\": \"3.6.1\",\n```\n\n[}]: #\n\nThe `MessagesResult` is built of:\n\n- `cursor` - marks the end of a fetched list\n- `hasMore` - tells if there's more data to ask for\n- `message` - has the same type as `Chat.messages` previously had\n\nBecause the cursor marks the edge of received data, it has to be something we could use while sorting. The most obvious choice is the date of creation, so `created_at` column of `messages` table.\n\nIt's stored as `YYYY-MM-DD HH:mm:ss` but we want to expose it as something easier to work with, let's say a `number`.\n\nIn order to do it quickly, let's add `date-fns` package:\n\n    npm install date-fns\n\nIt has `format` method that will help us to do conversions.\n\nWe need to the logic of `Chats.findMessagesByChat` method.\n\n[{]: <helper> (diffStep \"14.11\" module=\"server\")\n\n#### [__Server__ Step 14.11: Implement cursor-based pagination in messages](https://github.com/Urigo/WhatsApp-Clone-Server/commit/7f32d53)\n\n##### Changed modules&#x2F;chats&#x2F;chats.provider.ts\n```diff\n@@ -2,6 +2,7 @@\n ┊2┊2┊import { QueryResult } from 'pg';\n ┊3┊3┊import sql from 'sql-template-strings';\n ┊4┊4┊import DataLoader from 'dataloader';\n+┊ ┊5┊import format from 'date-fns/format';\n ┊5┊6┊import { Database } from '../common/database.provider';\n ┊6┊7┊import { PubSub } from '../common/pubsub.provider';\n ┊7┊8┊import { Chat } from '../../db';\n```\n```diff\n@@ -107,12 +108,55 @@\n ┊107┊108┊    return rows;\n ┊108┊109┊  }\n ┊109┊110┊\n-┊110┊   ┊  async findMessagesByChat(chatId: string) {\n-┊111┊   ┊    const { rows } = await this.db.query(\n-┊112┊   ┊      sql`SELECT * FROM messages WHERE chat_id = ${chatId}`\n+┊   ┊111┊  async findMessagesByChat({\n+┊   ┊112┊    chatId,\n+┊   ┊113┊    limit,\n+┊   ┊114┊    after,\n+┊   ┊115┊  }: {\n+┊   ┊116┊    chatId: string;\n+┊   ┊117┊    limit: number;\n+┊   ┊118┊    after?: number | null;\n+┊   ┊119┊  }): Promise<{\n+┊   ┊120┊    hasMore: boolean;\n+┊   ┊121┊    cursor: number | null;\n+┊   ┊122┊    messages: any[];\n+┊   ┊123┊  }> {\n+┊   ┊124┊    const query = sql`SELECT * FROM messages`;\n+┊   ┊125┊    query.append(` WHERE chat_id = ${chatId}`);\n+┊   ┊126┊\n+┊   ┊127┊    if (after) {\n+┊   ┊128┊      // the created_at is the cursor\n+┊   ┊129┊      query.append(` AND created_at < ${cursorToDate(after)}`);\n+┊   ┊130┊    }\n+┊   ┊131┊\n+┊   ┊132┊    query.append(` ORDER BY created_at DESC LIMIT ${limit}`);\n+┊   ┊133┊\n+┊   ┊134┊    const { rows: messages } = await this.db.query(query);\n+┊   ┊135┊\n+┊   ┊136┊    if (!messages) {\n+┊   ┊137┊      return {\n+┊   ┊138┊        hasMore: false,\n+┊   ┊139┊        cursor: null,\n+┊   ┊140┊        messages: [],\n+┊   ┊141┊      };\n+┊   ┊142┊    }\n+┊   ┊143┊\n+┊   ┊144┊    // so we send them as old -> new\n+┊   ┊145┊    messages.reverse();\n+┊   ┊146┊\n+┊   ┊147┊    // cursor is a number representation of created_at\n+┊   ┊148┊    const cursor = messages.length ? new Date(messages[0].created_at).getTime() : 0;\n+┊   ┊149┊    const { rows: next } = await this.db.query(\n+┊   ┊150┊      sql`SELECT * FROM messages WHERE chat_id = ${chatId} AND created_at < ${cursorToDate(\n+┊   ┊151┊        cursor\n+┊   ┊152┊      )} ORDER BY created_at DESC LIMIT 1`\n ┊113┊153┊    );\n ┊114┊154┊\n-┊115┊   ┊    return rows;\n+┊   ┊155┊    return {\n+┊   ┊156┊      hasMore: next.length === 1, // means there's no more messages\n+┊   ┊157┊      cursor,\n+┊   ┊158┊      messages,\n+┊   ┊159┊    };\n ┊116┊160┊  }\n ┊117┊161┊\n ┊118┊162┊  async lastMessage(chatId: string) {\n```\n```diff\n@@ -280,3 +324,7 @@\n ┊280┊324┊    }\n ┊281┊325┊  }\n ┊282┊326┊}\n+┊   ┊327┊\n+┊   ┊328┊function cursorToDate(cursor: number) {\n+┊   ┊329┊  return `'${format(cursor, 'YYYY-MM-DD HH:mm:ss')}'`;\n+┊   ┊330┊}\n```\n\n##### Changed modules&#x2F;chats&#x2F;index.ts\n```diff\n@@ -111,7 +111,11 @@\n ┊111┊111┊    },\n ┊112┊112┊\n ┊113┊113┊    async messages(chat, args, { injector }) {\n-┊114┊   ┊      return injector.get(Chats).findMessagesByChat(chat.id);\n+┊   ┊114┊      return injector.get(Chats).findMessagesByChat({\n+┊   ┊115┊        chatId: chat.id,\n+┊   ┊116┊        limit: args.limit,\n+┊   ┊117┊        after: args.after,\n+┊   ┊118┊      });\n ┊115┊119┊    },\n ┊116┊120┊\n ┊117┊121┊    async lastMessage(chat, args, { injector }) {\n```\n\n[}]: #\n\nBecause the order of creation matters, messages are selected quite differently than before, we keep selecting all columns but records are ordered by the date of creation.\n\nThere's an interesting thing related to the cursor. If it's provided, we query for only those messages that happened before our cursor. This way we have a valid direction, fetching more messages means fetching older records.\n\nThe last message in the list becomes of course the `cursor`.\n\nIn order to calculate `hasMore` we need to apply the same conditions as above but with `LIMIT 1` and see if we get a result.\n\nSince the API part is done, let's take care of something much more complicated, which is always the UI...\n\nLet's plan it first. We know we want to fetch more messages while scrolling up. That means, Infinite Scroll with a corresponding request each time we hit the top. Because we implemented prefetching, we need to know what's the `limit`. React's Context might be helpful here. There was, of course, the change in GraphQL Schema we need to take care of too.\n\n### Apply schema changes\n\nSince we know what the plan is, let's start with schema changes. The `Chat.messages` is no longer a list, it's an object now.\n\n[{]: <helper> (diffStep \"15.6\" module=\"client\")\n\n#### [__Client__ Step 15.6: Apply MessagesResult type](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/8e1f994)\n\n##### Changed src&#x2F;components&#x2F;ChatRoomScreen&#x2F;index.tsx\n```diff\n@@ -27,7 +27,7 @@\n ┊27┊27┊\n ┊28┊28┊// eslint-disable-next-line\n ┊29┊29┊const getChatQuery = gql`\n-┊30┊  ┊  query GetChat($chatId: ID!) {\n+┊  ┊30┊  query GetChat($chatId: ID!, $limit: Int!, $after: Float) {\n ┊31┊31┊    chat(chatId: $chatId) {\n ┊32┊32┊      ...FullChat\n ┊33┊33┊    }\n```\n\n##### Changed src&#x2F;graphql&#x2F;fragments&#x2F;fullChat.fragment.ts\n```diff\n@@ -1,14 +1,14 @@\n ┊ 1┊ 1┊import gql from 'graphql-tag';\n ┊ 2┊ 2┊import chat from './chat.fragment';\n-┊ 3┊  ┊import message from './message.fragment';\n+┊  ┊ 3┊import messagesResult from './messagesResult.fragment';\n ┊ 4┊ 4┊\n ┊ 5┊ 5┊export default gql`\n ┊ 6┊ 6┊  fragment FullChat on Chat {\n ┊ 7┊ 7┊    ...Chat\n-┊ 8┊  ┊    messages {\n-┊ 9┊  ┊      ...Message\n+┊  ┊ 8┊    messages(limit: $limit, after: $after) @connection(key: \"messages\") {\n+┊  ┊ 9┊      ...MessagesResult\n ┊10┊10┊    }\n ┊11┊11┊  }\n ┊12┊12┊  ${chat}\n-┊13┊  ┊  ${message}\n+┊  ┊13┊  ${messagesResult}\n ┊14┊14┊`;\n```\n\n##### Added src&#x2F;graphql&#x2F;fragments&#x2F;messagesResult.fragment.ts\n```diff\n@@ -0,0 +1,13 @@\n+┊  ┊ 1┊import gql from 'graphql-tag';\n+┊  ┊ 2┊import message from './message.fragment';\n+┊  ┊ 3┊\n+┊  ┊ 4┊export default gql`\n+┊  ┊ 5┊  fragment MessagesResult on MessagesResult {\n+┊  ┊ 6┊    cursor\n+┊  ┊ 7┊    hasMore\n+┊  ┊ 8┊    messages {\n+┊  ┊ 9┊      ...Message\n+┊  ┊10┊    }\n+┊  ┊11┊  }\n+┊  ┊12┊  ${message}\n+┊  ┊13┊`;\n```\n\n##### Changed src&#x2F;services&#x2F;cache.service.ts\n```diff\n@@ -61,9 +61,9 @@\n ┊61┊61┊  if (fullChat === null || fullChat.messages === null) {\n ┊62┊62┊    return;\n ┊63┊63┊  }\n-┊64┊  ┊  if (fullChat.messages.some((m: any) => m.id === message.id)) return;\n+┊  ┊64┊  if (fullChat.messages.messages.some((m: any) => m.id === message.id)) return;\n ┊65┊65┊\n-┊66┊  ┊  fullChat.messages.push(message);\n+┊  ┊66┊  fullChat.messages.messages.push(message);\n ┊67┊67┊  fullChat.lastMessage = message;\n ┊68┊68┊\n ┊69┊69┊  client.writeFragment({\n```\n\n[}]: #\n\nNow we need reflect those changes in generated hooks by running:\n\n    yarn codegen\n\nOkay, let's move on!\n\n### Infinite Scrolling\n\nNow this Infinite Scroll thing. The core concept is to ask for more data, once a user's scrollbar hits the top edge of the screen.\n\n[{]: <helper> (diffStep \"15.2\" module=\"client\")\n\n#### [__Client__ Step 15.2: Basics for infinite scroll](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/e60c6a7)\n\n##### Added src&#x2F;hooks&#x2F;use-infinite-scroll.ts\n```diff\n@@ -0,0 +1,32 @@\n+┊  ┊ 1┊import { useEffect, useCallback, RefObject } from 'react';\n+┊  ┊ 2┊\n+┊  ┊ 3┊export const useInfiniteScroll = ({\n+┊  ┊ 4┊  ref,\n+┊  ┊ 5┊  onLoadMore,\n+┊  ┊ 6┊}: {\n+┊  ┊ 7┊  onLoadMore: Function;\n+┊  ┊ 8┊  ref: RefObject<HTMLElement>;\n+┊  ┊ 9┊}) => {\n+┊  ┊10┊  const handleScroll = useCallback(() => {\n+┊  ┊11┊    if (ref.current!.scrollTop === 0) {\n+┊  ┊12┊      // loads more if scrolled to top\n+┊  ┊13┊      onLoadMore();\n+┊  ┊14┊    }\n+┊  ┊15┊  }, [ref, onLoadMore]);\n+┊  ┊16┊\n+┊  ┊17┊  useEffect(() => {\n+┊  ┊18┊    const elem = ref.current;\n+┊  ┊19┊\n+┊  ┊20┊    if (!elem) {\n+┊  ┊21┊      return;\n+┊  ┊22┊    }\n+┊  ┊23┊\n+┊  ┊24┊    elem.addEventListener('scroll', handleScroll);\n+┊  ┊25┊\n+┊  ┊26┊    return () => {\n+┊  ┊27┊      elem!.removeEventListener('scroll', handleScroll);\n+┊  ┊28┊    };\n+┊  ┊29┊  }, [ref, handleScroll]);\n+┊  ┊30┊};\n+┊  ┊31┊\n+┊  ┊32┊export default useInfiniteScroll;\n```\n\n[}]: #\n\nOur `useInfiniteScroll` hook requires:\n\n- `ref` is a reference of a HTML element\n- `onLoadMore` calls the part component back and asks for data\n\nWe used `useEffect` to add and remove a scroll event listener. The function lives as long as `ref` and `onLoadMore` stay the same, that's because we simply make use of them in `handleScroll` function. The `handleScroll` function calls `onLoadMore` when a user scrolled to the top.\n\nIt all looks fine at first, but we still need to prevent calling back once fetching is in progress.\n\n[{]: <helper> (diffStep \"15.3\" module=\"client\")\n\n#### [__Client__ Step 15.3: Prevent calling back once fetching is in progress](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/f8cf2f9)\n\n##### Changed src&#x2F;hooks&#x2F;use-infinite-scroll.ts\n```diff\n@@ -1,4 +1,4 @@\n-┊1┊ ┊import { useEffect, useCallback, RefObject } from 'react';\n+┊ ┊1┊import { useState, useEffect, useCallback, RefObject } from 'react';\n ┊2┊2┊\n ┊3┊3┊export const useInfiniteScroll = ({\n ┊4┊4┊  ref,\n```\n```diff\n@@ -7,12 +7,13 @@\n ┊ 7┊ 7┊  onLoadMore: Function;\n ┊ 8┊ 8┊  ref: RefObject<HTMLElement>;\n ┊ 9┊ 9┊}) => {\n+┊  ┊10┊  const [isFetching, setIsFetching] = useState(false);\n ┊10┊11┊  const handleScroll = useCallback(() => {\n-┊11┊  ┊    if (ref.current!.scrollTop === 0) {\n-┊12┊  ┊      // loads more if scrolled to top\n-┊13┊  ┊      onLoadMore();\n+┊  ┊12┊    if (ref.current!.scrollTop === 0 && isFetching === false) {\n+┊  ┊13┊      // starts to fetch if scrolled to top and fetching is not in progress\n+┊  ┊14┊      setIsFetching(true);\n ┊14┊15┊    }\n-┊15┊  ┊  }, [ref, onLoadMore]);\n+┊  ┊16┊  }, [ref, isFetching]);\n ┊16┊17┊\n ┊17┊18┊  useEffect(() => {\n ┊18┊19┊    const elem = ref.current;\n```\n```diff\n@@ -27,6 +28,13 @@\n ┊27┊28┊      elem!.removeEventListener('scroll', handleScroll);\n ┊28┊29┊    };\n ┊29┊30┊  }, [ref, handleScroll]);\n+┊  ┊31┊\n+┊  ┊32┊  // loads more if fetching has started\n+┊  ┊33┊  useEffect(() => {\n+┊  ┊34┊    if (isFetching) {\n+┊  ┊35┊      onLoadMore();\n+┊  ┊36┊    }\n+┊  ┊37┊  }, [isFetching, onLoadMore]);\n ┊30┊38┊};\n ┊31┊39┊\n ┊32┊40┊export default useInfiniteScroll;\n```\n\n[}]: #\n\nThat's why `isFetching` state is necessary but as you can tell, we don't set it to `false`.\n\n[{]: <helper> (diffStep \"15.4\" module=\"client\")\n\n#### [__Client__ Step 15.4: Allow to notify when finished](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/efe45e9)\n\n##### Changed src&#x2F;hooks&#x2F;use-infinite-scroll.ts\n```diff\n@@ -6,7 +6,7 @@\n ┊ 6┊ 6┊}: {\n ┊ 7┊ 7┊  onLoadMore: Function;\n ┊ 8┊ 8┊  ref: RefObject<HTMLElement>;\n-┊ 9┊  ┊}) => {\n+┊  ┊ 9┊}): [boolean, () => void] => {\n ┊10┊10┊  const [isFetching, setIsFetching] = useState(false);\n ┊11┊11┊  const handleScroll = useCallback(() => {\n ┊12┊12┊    if (ref.current!.scrollTop === 0 && isFetching === false) {\n```\n```diff\n@@ -35,6 +35,12 @@\n ┊35┊35┊      onLoadMore();\n ┊36┊36┊    }\n ┊37┊37┊  }, [isFetching, onLoadMore]);\n+┊  ┊38┊\n+┊  ┊39┊  const stopFetching = useCallback(() => {\n+┊  ┊40┊    setIsFetching(false);\n+┊  ┊41┊  }, []);\n+┊  ┊42┊\n+┊  ┊43┊  return [isFetching, stopFetching];\n ┊38┊44┊};\n ┊39┊45┊\n ┊40┊46┊export default useInfiniteScroll;\n```\n\n[}]: #\n\nWe want the consumer of the hook to tell it when fetching is finished, that's why we expose the state with `stopFetching` function.\n\nThe next issue that appears right away is related to the case when there's no more data to fetch.\n\n[{]: <helper> (diffStep \"15.5\" module=\"client\")\n\n#### [__Client__ Step 15.5: Fetch only if there is more data](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/639937c)\n\n##### Changed src&#x2F;hooks&#x2F;use-infinite-scroll.ts\n```diff\n@@ -2,18 +2,20 @@\n ┊ 2┊ 2┊\n ┊ 3┊ 3┊export const useInfiniteScroll = ({\n ┊ 4┊ 4┊  ref,\n+┊  ┊ 5┊  hasMore,\n ┊ 5┊ 6┊  onLoadMore,\n ┊ 6┊ 7┊}: {\n ┊ 7┊ 8┊  onLoadMore: Function;\n+┊  ┊ 9┊  hasMore: boolean;\n ┊ 8┊10┊  ref: RefObject<HTMLElement>;\n ┊ 9┊11┊}): [boolean, () => void] => {\n ┊10┊12┊  const [isFetching, setIsFetching] = useState(false);\n ┊11┊13┊  const handleScroll = useCallback(() => {\n-┊12┊  ┊    if (ref.current!.scrollTop === 0 && isFetching === false) {\n-┊13┊  ┊      // starts to fetch if scrolled to top and fetching is not in progress\n+┊  ┊14┊    if (ref.current!.scrollTop === 0 && isFetching === false && hasMore) {\n+┊  ┊15┊      // starts to fetch if scrolled to top, fetching is not in progress and has more data\n ┊14┊16┊      setIsFetching(true);\n ┊15┊17┊    }\n-┊16┊  ┊  }, [ref, isFetching]);\n+┊  ┊18┊  }, [ref, isFetching, hasMore]);\n ┊17┊19┊\n ┊18┊20┊  useEffect(() => {\n ┊19┊21┊    const elem = ref.current;\n```\n\n[}]: #\n\nPfff... The hook part is done!\n\n### Pagination\n\nPagination is partially implemented thanks to Infinite Scrolling but the thing we need to still apply is React's context. It will be a central place of storing `limit` and `after` values, so they could be shared across multiple components and not passed directly from one to another.\n\n[{]: <helper> (diffStep \"15.7\" module=\"client\")\n\n#### [__Client__ Step 15.7: Implement pagination with context and hooks](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/85a37bd)\n\n##### Changed src&#x2F;components&#x2F;ChatRoomScreen&#x2F;index.tsx\n```diff\n@@ -1,6 +1,6 @@\n ┊1┊1┊import gql from 'graphql-tag';\n ┊2┊2┊import React from 'react';\n-┊3┊ ┊import { useCallback } from 'react';\n+┊ ┊3┊import { useCallback, useState, useContext, useEffect } from 'react';\n ┊4┊4┊import { Redirect } from 'react-router-dom';\n ┊5┊5┊import { useApolloClient } from 'react-apollo-hooks';\n ┊6┊6┊import styled from 'styled-components';\n```\n```diff\n@@ -45,6 +45,48 @@\n ┊45┊45┊  ${fragments.message}\n ┊46┊46┊`;\n ┊47┊47┊\n+┊  ┊48┊const PaginationContext = React.createContext({\n+┊  ┊49┊  after: 0,\n+┊  ┊50┊  limit: 20,\n+┊  ┊51┊  /**\n+┊  ┊52┊   * Sets new cursor\n+┊  ┊53┊   */\n+┊  ┊54┊  setAfter: (after: number) => {},\n+┊  ┊55┊  /**\n+┊  ┊56┊   * Resets `after` value to its inital state (null) so\n+┊  ┊57┊   */\n+┊  ┊58┊  reset: () => {},\n+┊  ┊59┊});\n+┊  ┊60┊\n+┊  ┊61┊const usePagination = () => {\n+┊  ┊62┊  const pagination = useContext(PaginationContext);\n+┊  ┊63┊\n+┊  ┊64┊  // Resets the pagination every time a component did unmount\n+┊  ┊65┊  useEffect(() => {\n+┊  ┊66┊    return () => {\n+┊  ┊67┊      pagination.reset();\n+┊  ┊68┊    };\n+┊  ┊69┊  }, [pagination]);\n+┊  ┊70┊\n+┊  ┊71┊  return pagination;\n+┊  ┊72┊};\n+┊  ┊73┊\n+┊  ┊74┊export const ChatPaginationProvider = ({ children }: { children: any }) => {\n+┊  ┊75┊  const [after, setAfter] = useState<number | null>(null);\n+┊  ┊76┊\n+┊  ┊77┊  return (\n+┊  ┊78┊    <PaginationContext.Provider\n+┊  ┊79┊      value={{\n+┊  ┊80┊        limit: 20,\n+┊  ┊81┊        after: after!,\n+┊  ┊82┊        setAfter,\n+┊  ┊83┊        reset: () => setAfter(null),\n+┊  ┊84┊      }}>\n+┊  ┊85┊      {children}\n+┊  ┊86┊    </PaginationContext.Provider>\n+┊  ┊87┊  );\n+┊  ┊88┊};\n+┊  ┊89┊\n ┊48┊90┊export const useGetChatPrefetch = () => {\n ┊49┊91┊  const client = useApolloClient();\n```\n\n[}]: #\n\nWe implemented three things:\n\n- `PaginationContext` is simple, it stores the values but also allows to set a new one for `after` or even bring it all back to the initial state.\n- `usePagination` hook is there so components could use `PaginationContext` and to make sure we reset it when component unmounts.\n- `ChatPaginationProvider` provides the logic and core functionality\n\nSince the pagination is almost ready, let's make use of it in `useGetChatPrefetch` hook and `ChatRoomScreen` component.\n\n[{]: <helper> (diffStep \"15.8\" module=\"client\")\n\n#### [__Client__ Step 15.8: Use pagination limit and after props](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/e439479)\n\n##### Changed src&#x2F;components&#x2F;ChatRoomScreen&#x2F;index.tsx\n```diff\n@@ -89,12 +89,15 @@\n ┊ 89┊ 89┊\n ┊ 90┊ 90┊export const useGetChatPrefetch = () => {\n ┊ 91┊ 91┊  const client = useApolloClient();\n+┊   ┊ 92┊  const { limit, after } = usePagination();\n ┊ 92┊ 93┊\n ┊ 93┊ 94┊  return (chatId: string) => {\n ┊ 94┊ 95┊    client.query<GetChatQuery, GetChatQueryVariables>({\n ┊ 95┊ 96┊      query: GetChatDocument,\n ┊ 96┊ 97┊      variables: {\n ┊ 97┊ 98┊        chatId,\n+┊   ┊ 99┊        after,\n+┊   ┊100┊        limit,\n ┊ 98┊101┊      },\n ┊ 99┊102┊    });\n ┊100┊103┊  };\n```\n```diff\n@@ -109,8 +112,9 @@\n ┊109┊112┊  history,\n ┊110┊113┊  chatId,\n ┊111┊114┊}) => {\n+┊   ┊115┊  const { after, limit } = usePagination();\n ┊112┊116┊  const { data, loading } = useGetChatQuery({\n-┊113┊   ┊    variables: { chatId },\n+┊   ┊117┊    variables: { chatId, after, limit },\n ┊114┊118┊  });\n ┊115┊119┊\n ┊116┊120┊  const addMessage = useAddMessageMutation();\n```\n\n[}]: #\n\nThis won't work yet because there's nothing that creates the context.\n\n[{]: <helper> (diffStep \"15.9\" module=\"client\")\n\n#### [__Client__ Step 15.9: Use ChatPaginationProvider](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/9a2f78f)\n\n##### Changed src&#x2F;components&#x2F;ChatRoomScreen&#x2F;index.tsx\n```diff\n@@ -108,10 +108,7 @@\n ┊108┊108┊  history: History;\n ┊109┊109┊}\n ┊110┊110┊\n-┊111┊   ┊const ChatRoomScreen: React.FC<ChatRoomScreenParams> = ({\n-┊112┊   ┊  history,\n-┊113┊   ┊  chatId,\n-┊114┊   ┊}) => {\n+┊   ┊111┊const ChatRoom: React.FC<ChatRoomScreenParams> = ({ history, chatId }) => {\n ┊115┊112┊  const { after, limit } = usePagination();\n ┊116┊113┊  const { data, loading } = useGetChatQuery({\n ┊117┊114┊    variables: { chatId, after, limit },\n```\n```diff\n@@ -176,4 +173,15 @@\n ┊176┊173┊  );\n ┊177┊174┊};\n ┊178┊175┊\n+┊   ┊176┊const ChatRoomScreen: React.FC<ChatRoomScreenParams> = ({\n+┊   ┊177┊  history,\n+┊   ┊178┊  chatId,\n+┊   ┊179┊}) => {\n+┊   ┊180┊  return (\n+┊   ┊181┊    <ChatPaginationProvider>\n+┊   ┊182┊      <ChatRoom history={history} chatId={chatId} />\n+┊   ┊183┊    </ChatPaginationProvider>\n+┊   ┊184┊  );\n+┊   ┊185┊};\n+┊   ┊186┊\n ┊179┊187┊export default ChatRoomScreen;\n```\n\n[}]: #\n\nWe had to split the `ChatRoomScreen` into two pieces. One that includes `ChatPaginationProvider` and produces `chatId` and the other that keeps pretty much everything else. This way the tree of child components, starting from `ChatRoom` share the same context.\n\n### Fetching more messages\n\nEverything is set up, we can now move on and consume the `useInfiniteScroll` in the `MessagesList` component.\n\n[{]: <helper> (diffStep \"15.10\" module=\"client\")\n\n#### [__Client__ Step 15.10: Make use of infinite scroll in MessagesList component](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/7a18cdd)\n\n##### Changed src&#x2F;components&#x2F;ChatRoomScreen&#x2F;MessagesList.tsx\n```diff\n@@ -3,14 +3,27 @@\n ┊ 3┊ 3┊import { useEffect, useRef } from 'react';\n ┊ 4┊ 4┊import ReactDOM from 'react-dom';\n ┊ 5┊ 5┊import styled, { css } from 'styled-components';\n+┊  ┊ 6┊import { useInfiniteScroll } from '../../hooks/use-infinite-scroll';\n ┊ 6┊ 7┊\n ┊ 7┊ 8┊const Container = styled.div`\n+┊  ┊ 9┊  position: relative;\n ┊ 8┊10┊  display: block;\n ┊ 9┊11┊  flex: 2;\n ┊10┊12┊  overflow-y: overlay;\n ┊11┊13┊  padding: 0 15px;\n ┊12┊14┊`;\n ┊13┊15┊\n+┊  ┊16┊const LoadingMore = styled.div`\n+┊  ┊17┊  height: 30px;\n+┊  ┊18┊  line-height: 30px;\n+┊  ┊19┊  position: absolute;\n+┊  ┊20┊  top: 0;\n+┊  ┊21┊  right: 0;\n+┊  ┊22┊  bottom: 0;\n+┊  ┊23┊  left: 0;\n+┊  ┊24┊  text-align: center;\n+┊  ┊25┊`;\n+┊  ┊26┊\n ┊14┊27┊type StyledProp = {\n ┊15┊28┊  isMine: any;\n ┊16┊29┊};\n```\n```diff\n@@ -89,19 +102,36 @@\n ┊ 89┊102┊}\n ┊ 90┊103┊interface MessagesListProps {\n ┊ 91┊104┊  messages: Array<Message>;\n+┊   ┊105┊  loadMore: Function;\n+┊   ┊106┊  hasMore: boolean;\n ┊ 92┊107┊}\n ┊ 93┊108┊\n-┊ 94┊   ┊const MessagesList: React.FC<MessagesListProps> = ({ messages }) => {\n-┊ 95┊   ┊  const selfRef = useRef(null);\n+┊   ┊109┊const MessagesList: React.FC<MessagesListProps> = ({\n+┊   ┊110┊  messages,\n+┊   ┊111┊  loadMore,\n+┊   ┊112┊  hasMore,\n+┊   ┊113┊}) => {\n+┊   ┊114┊  const selfRef = useRef<HTMLDivElement>(null);\n+┊   ┊115┊  const [fetching, stopFetching] = useInfiniteScroll({\n+┊   ┊116┊    onLoadMore: loadMore,\n+┊   ┊117┊    hasMore,\n+┊   ┊118┊    ref: selfRef!,\n+┊   ┊119┊  });\n ┊ 96┊120┊\n ┊ 97┊121┊  useEffect(() => {\n ┊ 98┊122┊    if (!selfRef.current) return;\n+┊   ┊123┊\n+┊   ┊124┊    if (fetching) {\n+┊   ┊125┊      stopFetching();\n+┊   ┊126┊    }\n+┊   ┊127┊\n ┊ 99┊128┊    const selfDOMNode = ReactDOM.findDOMNode(selfRef.current) as HTMLElement;\n ┊100┊129┊    selfDOMNode.scrollTop = Number.MAX_SAFE_INTEGER;\n-┊101┊   ┊  }, [messages.length]);\n+┊   ┊130┊  }, [messages.length, selfRef, fetching, stopFetching]);\n ┊102┊131┊\n ┊103┊132┊  return (\n ┊104┊133┊    <Container ref={selfRef}>\n+┊   ┊134┊      {fetching && <LoadingMore>{'Loading more messages...'}</LoadingMore>}\n ┊105┊135┊      {messages.map((message: any) => (\n ┊106┊136┊        <MessageItem\n ┊107┊137┊          data-testid=\"message-item\"\n```\n\n[}]: #\n\nWe added the `LoadingMore` component with *Loading more messages...* text in it that pops out when fetching is in progress.\nBecause the `MessagesList` is not responsible of quering data we don't know exactly when it's completed but we can assume, it happens once the length of `messages` changes.\nWe also pass `onLoadMore` and `hasMore` props to the parent component and the `useInfiniteScroll` uses `MessagesList` as the element we're going to scroll in.\n\nThere's also one more thing that could be turned into a hook, it's the logic responsible for scrolling to bottom of the page, every time `messages` changes.\n\n[{]: <helper> (diffStep \"15.11\" module=\"client\")\n\n#### [__Client__ Step 15.11: Implement a hook responsible for scrolling](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/52ba927)\n\n##### Changed src&#x2F;components&#x2F;ChatRoomScreen&#x2F;MessagesList.tsx\n```diff\n@@ -1,9 +1,9 @@\n ┊1┊1┊import moment from 'moment';\n ┊2┊2┊import React from 'react';\n ┊3┊3┊import { useEffect, useRef } from 'react';\n-┊4┊ ┊import ReactDOM from 'react-dom';\n ┊5┊4┊import styled, { css } from 'styled-components';\n ┊6┊5┊import { useInfiniteScroll } from '../../hooks/use-infinite-scroll';\n+┊ ┊6┊import { useAdjustedScroll } from '../../hooks/use-adjusted-scroll';\n ┊7┊7┊\n ┊8┊8┊const Container = styled.div`\n ┊9┊9┊  position: relative;\n```\n```diff\n@@ -117,17 +117,19 @@\n ┊117┊117┊    hasMore,\n ┊118┊118┊    ref: selfRef!,\n ┊119┊119┊  });\n+┊   ┊120┊  const adjustScroll = useAdjustedScroll(selfRef);\n ┊120┊121┊\n ┊121┊122┊  useEffect(() => {\n ┊122┊123┊    if (!selfRef.current) return;\n ┊123┊124┊\n ┊124┊125┊    if (fetching) {\n ┊125┊126┊      stopFetching();\n+┊   ┊127┊      adjustScroll();\n+┊   ┊128┊    } else {\n+┊   ┊129┊      // scroll to the most recent message\n+┊   ┊130┊      adjustScroll(true);\n ┊126┊131┊    }\n-┊127┊   ┊\n-┊128┊   ┊    const selfDOMNode = ReactDOM.findDOMNode(selfRef.current) as HTMLElement;\n-┊129┊   ┊    selfDOMNode.scrollTop = Number.MAX_SAFE_INTEGER;\n-┊130┊   ┊  }, [messages.length, selfRef, fetching, stopFetching]);\n+┊   ┊132┊  }, [messages.length, selfRef, fetching, stopFetching, adjustScroll]);\n ┊131┊133┊\n ┊132┊134┊  return (\n ┊133┊135┊    <Container ref={selfRef}>\n```\n\n##### Added src&#x2F;hooks&#x2F;use-adjusted-scroll.ts\n```diff\n@@ -0,0 +1,35 @@\n+┊  ┊ 1┊import { useState, useCallback, RefObject } from 'react';\n+┊  ┊ 2┊import * as ReactDOM from 'react-dom';\n+┊  ┊ 3┊\n+┊  ┊ 4┊export const useAdjustedScroll = (ref: RefObject<HTMLElement>) => {\n+┊  ┊ 5┊  const [previousScroll, setPreviousScroll] = useState<{\n+┊  ┊ 6┊    top: number;\n+┊  ┊ 7┊    height: number;\n+┊  ┊ 8┊  }>();\n+┊  ┊ 9┊\n+┊  ┊10┊  /**\n+┊  ┊11┊   * Scrolls to the previous position or completely to bottom (on demand)\n+┊  ┊12┊   */\n+┊  ┊13┊  const adjust = useCallback(\n+┊  ┊14┊    (scrollToBottom?: boolean) => {\n+┊  ┊15┊      if (!ref.current) return;\n+┊  ┊16┊\n+┊  ┊17┊      const node = ReactDOM.findDOMNode(ref.current) as HTMLElement;\n+┊  ┊18┊      const height =\n+┊  ┊19┊        !scrollToBottom && previousScroll\n+┊  ┊20┊          ? previousScroll.height\n+┊  ┊21┊          : node.clientHeight;\n+┊  ┊22┊\n+┊  ┊23┊      node.scrollTop = node.scrollHeight - height;\n+┊  ┊24┊\n+┊  ┊25┊      // saves current scroll details\n+┊  ┊26┊      setPreviousScroll({\n+┊  ┊27┊        top: node.scrollTop,\n+┊  ┊28┊        height: node.scrollHeight,\n+┊  ┊29┊      });\n+┊  ┊30┊    },\n+┊  ┊31┊    [ref, previousScroll]\n+┊  ┊32┊  );\n+┊  ┊33┊\n+┊  ┊34┊  return adjust;\n+┊  ┊35┊};\n```\n\n[}]: #\n\nWe also added some extra functionality there. Because we don't want to scroll to bottom when a new message is added, the function returned by `useAdjustedScroll` accepts now an argument.\n\nWe did the `MessagesList`, now let's move onto real data and the `ChatRoom` component.\n\n[{]: <helper> (diffStep \"15.12\" module=\"client\")\n\n#### [__Client__ Step 15.12: Implement pagination in ChatRoom component](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/4b10c9f)\n\n##### Changed src&#x2F;components&#x2F;ChatRoomScreen&#x2F;index.tsx\n```diff\n@@ -109,7 +109,7 @@\n ┊109┊109┊}\n ┊110┊110┊\n ┊111┊111┊const ChatRoom: React.FC<ChatRoomScreenParams> = ({ history, chatId }) => {\n-┊112┊   ┊  const { after, limit } = usePagination();\n+┊   ┊112┊  const { after, limit, setAfter } = usePagination();\n ┊113┊113┊  const { data, loading } = useGetChatQuery({\n ┊114┊114┊    variables: { chatId, after, limit },\n ┊115┊115┊  });\n```\n```diff\n@@ -150,6 +150,14 @@\n ┊150┊150┊    [data, chatId, addMessage]\n ┊151┊151┊  );\n ┊152┊152┊\n+┊   ┊153┊  useEffect(() => {\n+┊   ┊154┊    if (!after) {\n+┊   ┊155┊      return;\n+┊   ┊156┊    }\n+┊   ┊157┊\n+┊   ┊158┊    // every time after changes its value, fetch more messages\n+┊   ┊159┊  }, [after]);\n+┊   ┊160┊\n ┊153┊161┊  if (data === undefined) {\n ┊154┊162┊    return null;\n ┊155┊163┊  }\n```\n```diff\n@@ -167,7 +175,13 @@\n ┊167┊175┊  return (\n ┊168┊176┊    <Container>\n ┊169┊177┊      <ChatNavbar chat={chat} history={history} />\n-┊170┊   ┊      {chat.messages && <MessagesList messages={chat.messages} />}\n+┊   ┊178┊      {chat.messages && (\n+┊   ┊179┊        <MessagesList\n+┊   ┊180┊          messages={chat.messages.messages}\n+┊   ┊181┊          hasMore={chat.messages.hasMore}\n+┊   ┊182┊          loadMore={() => setAfter(chat.messages.cursor!)}\n+┊   ┊183┊        />\n+┊   ┊184┊      )}\n ┊171┊185┊      <MessageInput onSendMessage={onSendMessage} />\n ┊172┊186┊    </Container>\n ┊173┊187┊  );\n```\n\n[}]: #\n\nAs you see above, every time the `MessagesList` asks for more messages, the `after` changes its value to `chat.messages.cursor` which means that's a new \"end\" of the list and we need to fill it up.\n\nRight now we just have a logic and a place to do it but we still need to make a GraphQL call.\n\nFortunately, Apollo lets you do pagination with a method called `fetchMore`. You need to specify what query and variables to use for the update, and how to merge the new query result with the existing data on the client. How exactly you do that will determine what kind of pagination you are implementing, in our case it's cursor-based.\n\nBut there's a catch!\n\nIt's related to how Apollo stores query results in cache. When we update the variables, in our case it's the `after` that changes quite a lot, a new record is created that is totally unrelated to the original query. That's because Apollo uses a combination of variables and query string to produce a key.\n\nAn example:\n\n\n```graphql\n{\n  query getUser($id: ID!) {\n    user(id: $id) {\n      name\n    }\n  }\n}\n```\n\nThe result of `getUser` query will be saved under `user({\"id\":2})` key.\n\nThis is a huge problem, it breaks imperative store updates but that's why `@connection` directive exists. It directs Apollo to use a stable store key for paginated queries, so every `useQuery()` or `fetchMore()` is being placed in the same space.\n\nWith all that knowledge, let's implement the last puzzle piece!\n\n[{]: <helper> (diffStep \"15.13\" module=\"client\")\n\n#### [__Client__ Step 15.13: Use fetchMore to load more messages](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/29a171d)\n\n##### Changed src&#x2F;components&#x2F;ChatRoomScreen&#x2F;index.tsx\n```diff\n@@ -110,7 +110,7 @@\n ┊110┊110┊\n ┊111┊111┊const ChatRoom: React.FC<ChatRoomScreenParams> = ({ history, chatId }) => {\n ┊112┊112┊  const { after, limit, setAfter } = usePagination();\n-┊113┊   ┊  const { data, loading } = useGetChatQuery({\n+┊   ┊113┊  const { data, loading, fetchMore } = useGetChatQuery({\n ┊114┊114┊    variables: { chatId, after, limit },\n ┊115┊115┊  });\n ┊116┊116┊\n```\n```diff\n@@ -156,7 +156,30 @@\n ┊156┊156┊    }\n ┊157┊157┊\n ┊158┊158┊    // every time after changes its value, fetch more messages\n-┊159┊   ┊  }, [after]);\n+┊   ┊159┊    fetchMore({\n+┊   ┊160┊      variables: {\n+┊   ┊161┊        after,\n+┊   ┊162┊        limit,\n+┊   ┊163┊      },\n+┊   ┊164┊      updateQuery(prev, { fetchMoreResult }) {\n+┊   ┊165┊        const messages = [\n+┊   ┊166┊          ...fetchMoreResult!.chat!.messages.messages,\n+┊   ┊167┊          ...prev.chat!.messages.messages,\n+┊   ┊168┊        ];\n+┊   ┊169┊\n+┊   ┊170┊        return {\n+┊   ┊171┊          ...prev,\n+┊   ┊172┊          chat: {\n+┊   ┊173┊            ...prev.chat!,\n+┊   ┊174┊            messages: {\n+┊   ┊175┊              ...fetchMoreResult!.chat!.messages,\n+┊   ┊176┊              messages,\n+┊   ┊177┊            },\n+┊   ┊178┊          },\n+┊   ┊179┊        };\n+┊   ┊180┊      },\n+┊   ┊181┊    });\n+┊   ┊182┊  }, [after, limit, fetchMore]);\n ┊160┊183┊\n ┊161┊184┊  if (data === undefined) {\n ┊162┊185┊    return null;\n```\n\n[}]: #\n\nAs you see, we mutate the store as usual and we put fetched messages before the existing ones. Remember, it's from older to newer.\n\n### Looking at the bundle size\n\nWe can't of course forget about one of the most important aspects of optimization, the size of the application. As bundle size increases, both the parsing time and the time of the request takes longer.\n\nHow can we check what libraries and source files are shipped within the produced bundle?\n\nThere are many tools that analyze it for us but we're going to use only one of them, just for educational purpose.\n\n      $ yarn add -D source-map-explorer\n\nWe're going to add the `size` npm script in which we point the `source-map-explorer` to transpiled js files.\n\n[{]: <helper> (diffStep \"15.14\" module=\"client\")\n\n#### [__Client__ Step 15.14: Explore bundle size](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/9b9499c)\n\n##### Changed package.json\n```diff\n@@ -52,7 +52,8 @@\n ┊52┊52┊    \"test\": \"TZ=\\\"Asia/Jerusalem\\\" react-scripts test\",\n ┊53┊53┊    \"eject\": \"react-scripts eject\",\n ┊54┊54┊    \"codegen\": \"gql-gen\",\n-┊55┊  ┊    \"format\": \"prettier '**/*.{ts,tsx,css,graphql}' --write\"\n+┊  ┊55┊    \"format\": \"prettier '**/*.{ts,tsx,css,graphql}' --write\",\n+┊  ┊56┊    \"size\": \"source-map-explorer 'build/static/js/*.js'\"\n ┊56┊57┊  },\n ┊57┊58┊  \"eslintConfig\": {\n ┊58┊59┊    \"extends\": \"react-app\"\n```\n```diff\n@@ -72,6 +73,7 @@\n ┊72┊73┊  \"devDependencies\": {\n ┊73┊74┊    \"jest-dom\": \"3.5.0\",\n ┊74┊75┊    \"jest-fetch-mock\": \"2.1.2\",\n-┊75┊  ┊    \"@testing-library/react\": \"8.0.1\"\n+┊  ┊76┊    \"@testing-library/react\": \"8.0.1\",\n+┊  ┊77┊    \"source-map-explorer\": \"2.0.0\"\n ┊76┊78┊  }\n ┊77┊79┊}🚫↵\n```\n\n[}]: #\n\nLet's see it in action, run:\n\n    $ yarn build && yarn size\n\nThat's what you should see:\n\n![Source Map Explorer](../../../assets/step17/img-10.png \"Source Map Explorer\")\n\nIt's interactive so you can dive deeper and deeper into those blocks but in general it shows what libraries and files are included in the produced output with their size(not minified and not gzipped).\n\n![Source Map Explorer](../../../assets/step17/img-11.png \"Source Map Explorer with moment highlighted\")\n\nFor example, we see that `moment` takes almost _53.49KB_ which is enourmous. In fact we only use its `format` method. The reason is that the library is not well tree-shakable. There are plugins for webpack (or any other build tool) that helps with it but we're going to use an alternative instead. We're going to replace it with `date-fns`.\n\n[{]: <helper> (diffStep \"15.15\" module=\"client\")\n\n#### [__Client__ Step 15.15: Replace moment with date-fns](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/869dddd)\n\n##### Changed package.json\n```diff\n@@ -30,9 +30,9 @@\n ┊30┊30┊    \"graphql\": \"14.3.1\",\n ┊31┊31┊    \"apollo-link-ws\": \"1.0.18\",\n ┊32┊32┊    \"apollo-utilities\": \"1.3.2\",\n+┊  ┊33┊    \"date-fns\": \"1.30.1\",\n ┊33┊34┊    \"graphql-tag\": \"2.10.1\",\n ┊34┊35┊    \"history\": \"4.9.0\",\n-┊35┊  ┊    \"moment\": \"2.24.0\",\n ┊36┊36┊    \"prettier\": \"1.18.2\",\n ┊37┊37┊    \"react\": \"16.8.6\",\n ┊38┊38┊    \"react-apollo\": \"2.5.6\",\n```\n\n##### Changed src&#x2F;components&#x2F;ChatRoomScreen&#x2F;MessagesList.tsx\n```diff\n@@ -1,4 +1,4 @@\n-┊1┊ ┊import moment from 'moment';\n+┊ ┊1┊import format from 'date-fns/format';\n ┊2┊2┊import React from 'react';\n ┊3┊3┊import { useEffect, useRef } from 'react';\n ┊4┊4┊import styled, { css } from 'styled-components';\n```\n```diff\n@@ -141,7 +141,7 @@\n ┊141┊141┊          key={message.id}>\n ┊142┊142┊          <Contents data-testid=\"message-content\">{message.content}</Contents>\n ┊143┊143┊          <Timestamp data-testid=\"message-date\">\n-┊144┊   ┊            {moment(message.createdAt).format('HH:mm')}\n+┊   ┊144┊            {format(message.createdAt, 'HH:mm')}\n ┊145┊145┊          </Timestamp>\n ┊146┊146┊        </MessageItem>\n ┊147┊147┊      ))}\n```\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;ChatsList.tsx\n```diff\n@@ -1,5 +1,5 @@\n ┊1┊1┊import React from 'react';\n-┊2┊ ┊import moment from 'moment';\n+┊ ┊2┊import format from 'date-fns/format';\n ┊3┊3┊import { List, ListItem } from '@material-ui/core';\n ┊4┊4┊import styled from 'styled-components';\n ┊5┊5┊import { useCallback } from 'react';\n```\n```diff\n@@ -105,7 +105,7 @@\n ┊105┊105┊                    {chat.lastMessage.content}\n ┊106┊106┊                  </MessageContent>\n ┊107┊107┊                  <MessageDate data-testid=\"date\">\n-┊108┊   ┊                    {moment(chat.lastMessage.createdAt).format('HH:mm')}\n+┊   ┊108┊                    {format(chat.lastMessage.createdAt, 'HH:mm')}\n ┊109┊109┊                  </MessageDate>\n ┊110┊110┊                </React.Fragment>\n ┊111┊111┊              )}\n```\n\n[}]: #\n\nNow when you run:\n\n    $ yarn build && yarn size\n\nYou should see the following results.\n\n![Source Map Explorer](../../../assets/step17/img-12.png \"Source Map Explorer with date-fns\")\n\nThe bundle size is a bit smaller and `date-fns` takes only _8.93KB_ which in comparison to _53.49KB_ is a significant change!\n\n## Load testing\n\nLoad testing, in short, is about finding the limit of an application and figure out how to push it even more. We simulate a stressful behavior and apply that to the server until it crashes. We’re trying to answer the question of how the api deals with a pressure.\n\nWhen to do load testing?\nI would say at least before and after major changes, when pre-launching and just from time to time to prevent regressions.\n\nBefore doing load testing, we need to prepare a bit first. Right now we use `ts-node` to run the server but it would be faster to run it directly using `node`, just to avoid on-the-fly transpilation of TypeScript files.\n\nIn order to do it, we need to define the `outDir` in `tsconfig.json` and add a build step.\n\n[{]: <helper> (diffStep \"14.12\" module=\"server\")\n\n#### [__Server__ Step 14.12: Produce transpiled code](https://github.com/Urigo/WhatsApp-Clone-Server/commit/5a50a2e)\n\n##### Changed .circleci&#x2F;config.yml\n```diff\n@@ -18,6 +18,9 @@\n ┊18┊18┊      - run:\n ┊19┊19┊          name: Install Dependencies\n ┊20┊20┊          command: yarn\n+┊  ┊21┊      - run:\n+┊  ┊22┊          name: Build\n+┊  ┊23┊          command: yarn build\n ┊21┊24┊      - run:\n ┊22┊25┊          name: Test\n ┊23┊26┊          command: yarn test\n```\n\n##### Changed .gitignore\n```diff\n@@ -1,3 +1,4 @@\n+┊ ┊1┊dist\n ┊1┊2┊node_modules\n ┊2┊3┊npm-debug.log\n ┊3┊4┊test-results/\n```\n\n##### Changed package.json\n```diff\n@@ -9,6 +9,8 @@\n ┊ 9┊ 9┊  \"scripts\": {\n ┊10┊10┊    \"prestart\": \"yarn codegen\",\n ┊11┊11┊    \"start\": \"ts-node index.ts\",\n+┊  ┊12┊    \"prebuild\": \"yarn codegen\",\n+┊  ┊13┊    \"build\": \"tsc\",\n ┊12┊14┊    \"test\": \"TZ=\\\"Asia/Jerusalem\\\" jest --runInBand --forceExit\",\n ┊13┊15┊    \"codegen\": \"gql-gen\",\n ┊14┊16┊    \"format\": \"prettier '**/*.ts' --write\"\n```\n\n##### Changed tsconfig.json\n```diff\n@@ -1,5 +1,6 @@\n ┊1┊1┊{\n ┊2┊2┊  \"compilerOptions\": {\n+┊ ┊3┊    \"outDir\": \"dist\",\n ┊3┊4┊    \"target\": \"es2018\",\n ┊4┊5┊    \"module\": \"commonjs\",\n ┊5┊6┊    \"lib\": [\n```\n\n[}]: #\n\nNext, the script to actually run the server:\n\n[{]: <helper> (diffStep \"14.13\" files=\"package.json\" module=\"server\")\n\n#### [__Server__ Step 14.13: Prepare for production](https://github.com/Urigo/WhatsApp-Clone-Server/commit/5c81fe8)\n\n##### Changed package.json\n```diff\n@@ -10,6 +10,7 @@\n ┊10┊10┊    \"prestart\": \"yarn codegen\",\n ┊11┊11┊    \"start\": \"ts-node index.ts\",\n ┊12┊12┊    \"prebuild\": \"yarn codegen\",\n+┊  ┊13┊    \"prod\": \"node dist/index.js\",\n ┊13┊14┊    \"build\": \"tsc\",\n ┊14┊15┊    \"test\": \"TZ=\\\"Asia/Jerusalem\\\" jest --runInBand --forceExit\",\n ┊15┊16┊    \"codegen\": \"gql-gen\",\n```\n\n[}]: #\n\nOnce it’s ready, we can move on to tooling.\n\n### Artillery\n\nArtillery is an open-source load testing and functional testing toolkit. It’s API is vast but we will focus on the core part of it which is relevant to this chapter. Artillery is available as a npm package:\n\n    $ yarn add -D artillery\n\nThe only step to use Artillery is to set it up. We will create the `artillery.yml` file, like this:\n\n[{]: <helper> (diffStep \"14.15\" module=\"server\")\n\n#### [__Server__ Step 14.15: Add artillery config](https://github.com/Urigo/WhatsApp-Clone-Server/commit/5461d2c)\n\n##### Added artillery.yml\n```diff\n@@ -0,0 +1,72 @@\n+┊  ┊ 1┊config:\n+┊  ┊ 2┊  target: 'http://localhost:4000/graphql'\n+┊  ┊ 3┊  phases:\n+┊  ┊ 4┊    - duration: 120\n+┊  ┊ 5┊      arrivalRate: 5\n+┊  ┊ 6┊      rampTo: 20\n+┊  ┊ 7┊scenarios:\n+┊  ┊ 8┊  - name: 'Sign in, send a new message and fetch a list of chats'\n+┊  ┊ 9┊    flow:\n+┊  ┊10┊      - post:\n+┊  ┊11┊          url: '/'\n+┊  ┊12┊          json:\n+┊  ┊13┊            variables:\n+┊  ┊14┊              username: 'ray'\n+┊  ┊15┊              password: '111'\n+┊  ┊16┊            query: |\n+┊  ┊17┊              mutation SignIn($username: String!, $password: String!) {\n+┊  ┊18┊                signIn(username: $username, password: $password) {\n+┊  ┊19┊                  id\n+┊  ┊20┊                }\n+┊  ┊21┊              }\n+┊  ┊22┊      - post:\n+┊  ┊23┊          url: '/'\n+┊  ┊24┊          json:\n+┊  ┊25┊            query: |\n+┊  ┊26┊              mutation message {\n+┊  ┊27┊                addMessage(chatId: \"1\", content: \"artillery\") {\n+┊  ┊28┊                  id\n+┊  ┊29┊                }\n+┊  ┊30┊              }\n+┊  ┊31┊      - post:\n+┊  ┊32┊          url: '/'\n+┊  ┊33┊          json:\n+┊  ┊34┊            variables:\n+┊  ┊35┊              limit: 20\n+┊  ┊36┊            query: |\n+┊  ┊37┊              fragment User on User {\n+┊  ┊38┊                id\n+┊  ┊39┊                name\n+┊  ┊40┊                picture\n+┊  ┊41┊              }\n+┊  ┊42┊              fragment Message on Message {\n+┊  ┊43┊                id\n+┊  ┊44┊                content\n+┊  ┊45┊                chat {\n+┊  ┊46┊                  id\n+┊  ┊47┊                }\n+┊  ┊48┊                sender {\n+┊  ┊49┊                  ...User\n+┊  ┊50┊                }\n+┊  ┊51┊                recipient {\n+┊  ┊52┊                  ...User\n+┊  ┊53┊                }\n+┊  ┊54┊              }\n+┊  ┊55┊              query GetChats($limit: Int!) {\n+┊  ┊56┊                chats {\n+┊  ┊57┊                  id\n+┊  ┊58┊                  name\n+┊  ┊59┊                  picture\n+┊  ┊60┊                  lastMessage {\n+┊  ┊61┊                    ...Message\n+┊  ┊62┊                  }\n+┊  ┊63┊                  messages(limit: $limit) {\n+┊  ┊64┊                    messages {\n+┊  ┊65┊                      ...Message\n+┊  ┊66┊                    }\n+┊  ┊67┊                  }\n+┊  ┊68┊                  participants {\n+┊  ┊69┊                    ...User\n+┊  ┊70┊                  }\n+┊  ┊71┊                }\n+┊  ┊72┊              }\n```\n\n[}]: #\n\nAs you can see, the config file is built of two sections. First one is named `config` and it defines what’s our target and how the traffic should look like. We used one phase but it could have many. The `duration` parameter is to define how long the phase should take. The `arrivalRate` defines how many virtual users per second are going to hit the target and the `rampTo` directs Artillery to increase this number up to 20, at the middle of the phase.\n\nThe next section, called `scenarios`, is all about the actual requests. In our case, we want to authenticate user, submit a new message and fetch an entire list of chats with their messages at the end. Artillery shares cookies between request of the same virtual user, keep that on mind.\n\nWe used Ray as the user and fairly similar operations to what the client app sends. That should closely represent the actual usage of the API.\n\nEverything is fine with that config but we need to find the limit, to push even more. That's why we'll also add a second config with a bit more heavier traffic, something to simulate the more real life environment. It's pretty much the same setup except phases. First, we \"warms up\" the server for 2 minutes, same amount of times goes next with double the traffic, then we keep it for 5 minutes. At the end, we want to crash the server so we send nearly 100 virtual users per second for an entire minute. This way we know when it cracks.\n\n[{]: <helper> (diffStep \"14.16\" module=\"server\")\n\n#### [__Server__ Step 14.16: Artillery config to find a limit](https://github.com/Urigo/WhatsApp-Clone-Server/commit/70bc88f)\n\n##### Added artillery-limit.yml\n```diff\n@@ -0,0 +1,77 @@\n+┊  ┊ 1┊config:\n+┊  ┊ 2┊  target: 'http://localhost:4000/graphql'\n+┊  ┊ 3┊  phases:\n+┊  ┊ 4┊    - duration: 120\n+┊  ┊ 5┊      arrivalRate: 5\n+┊  ┊ 6┊    - duration: 120\n+┊  ┊ 7┊      arrivalRate: 10\n+┊  ┊ 8┊    - duration: 300\n+┊  ┊ 9┊      arrivalRate: 10\n+┊  ┊10┊    - duration: 60\n+┊  ┊11┊      arrivalRate: 100\n+┊  ┊12┊scenarios:\n+┊  ┊13┊  - name: 'Sign in, send a new message and fetch a list of chats'\n+┊  ┊14┊    flow:\n+┊  ┊15┊      - post:\n+┊  ┊16┊          url: '/'\n+┊  ┊17┊          json:\n+┊  ┊18┊            variables:\n+┊  ┊19┊              username: 'ray'\n+┊  ┊20┊              password: '111'\n+┊  ┊21┊            query: |\n+┊  ┊22┊              mutation SignIn($username: String!, $password: String!) {\n+┊  ┊23┊                signIn(username: $username, password: $password) {\n+┊  ┊24┊                  id\n+┊  ┊25┊                }\n+┊  ┊26┊              }\n+┊  ┊27┊      - post:\n+┊  ┊28┊          url: '/'\n+┊  ┊29┊          json:\n+┊  ┊30┊            query: |\n+┊  ┊31┊              mutation message {\n+┊  ┊32┊                addMessage(chatId: \"1\", content: \"artillery\") {\n+┊  ┊33┊                  id\n+┊  ┊34┊                }\n+┊  ┊35┊              }\n+┊  ┊36┊      - post:\n+┊  ┊37┊          url: '/'\n+┊  ┊38┊          json:\n+┊  ┊39┊            variables:\n+┊  ┊40┊              limit: 20\n+┊  ┊41┊            query: |\n+┊  ┊42┊              fragment User on User {\n+┊  ┊43┊                id\n+┊  ┊44┊                name\n+┊  ┊45┊                picture\n+┊  ┊46┊              }\n+┊  ┊47┊              fragment Message on Message {\n+┊  ┊48┊                id\n+┊  ┊49┊                content\n+┊  ┊50┊                chat {\n+┊  ┊51┊                  id\n+┊  ┊52┊                }\n+┊  ┊53┊                sender {\n+┊  ┊54┊                  ...User\n+┊  ┊55┊                }\n+┊  ┊56┊                recipient {\n+┊  ┊57┊                  ...User\n+┊  ┊58┊                }\n+┊  ┊59┊              }\n+┊  ┊60┊              query GetChats($limit: Int!) {\n+┊  ┊61┊                chats {\n+┊  ┊62┊                  id\n+┊  ┊63┊                  name\n+┊  ┊64┊                  picture\n+┊  ┊65┊                  lastMessage {\n+┊  ┊66┊                    ...Message\n+┊  ┊67┊                  }\n+┊  ┊68┊                  messages(limit: $limit) {\n+┊  ┊69┊                    messages {\n+┊  ┊70┊                      ...Message\n+┊  ┊71┊                    }\n+┊  ┊72┊                  }\n+┊  ┊73┊                  participants {\n+┊  ┊74┊                    ...User\n+┊  ┊75┊                  }\n+┊  ┊76┊                }\n+┊  ┊77┊              }🚫↵\n```\n\n[}]: #\n\nOnce everything is ready, let's add npm scripts, one for a normal traffic and a second with the much more users:\n\n[{]: <helper> (diffStep \"14.17\" module=\"server\")\n\n#### [__Server__ Step 14.17: Add loadtest scripts](https://github.com/Urigo/WhatsApp-Clone-Server/commit/9457e93)\n\n##### Changed package.json\n```diff\n@@ -14,7 +14,9 @@\n ┊14┊14┊    \"build\": \"tsc\",\n ┊15┊15┊    \"test\": \"TZ=\\\"Asia/Jerusalem\\\" jest --runInBand --forceExit\",\n ┊16┊16┊    \"codegen\": \"gql-gen\",\n-┊17┊  ┊    \"format\": \"prettier '**/*.ts' --write\"\n+┊  ┊17┊    \"format\": \"prettier '**/*.ts' --write\",\n+┊  ┊18┊    \"loadtest\": \"yarn artillery run artillery.yml > loadtest.log\",\n+┊  ┊19┊    \"loadtest:limit\": \"yarn artillery run artillery-limit.yml > loadtest.log\"\n ┊18┊20┊  },\n ┊19┊21┊  \"jest-junit\": {\n ┊20┊22┊    \"outputDirectory\": \"./test-results\"\n```\n\n[}]: #\n\nYou probably noticed that we stream the output to the `loadtest.log` file and that's just to read the results in a bit more pleasent way, than in the terminal.\n\nLet’s start the server and run artillery:\n\n    $ yarn build && yarn start\n    $ yarn loadtest\n\nYou’ll see a loading indicator, might take a while but when it completes, you should see something like this in `loadtest.log` file:\n\n```\nSummary report @ 15:00:58(+0200) 2019-05-30\n  Scenarios launched:  1506\n  Scenarios completed: 1506\n  Requests completed:  4518\n  RPS sent: 37.35\n  Request latency:\n    min: 3.5\n    max: 115.7\n    median: 18.6\n    p95: 54.4\n    p99: 66.2\n  Scenario counts:\n    Sign in, send a new message and fetch a list of chats: 1506 (100%)\n  Codes:\n    200: 4518\n```\n\nWe ran the scenario 1506 times, all were completed and the total number of requests was 4518.  The **RPS** means requests per second.\n\nThe metrics in **Request latency** are in milliseconds. We see what was the shortest request and so on. These **p95** and **p99** values mean that for 95% of virtual users, the latency was 54.4ms or lower, for 99% it was 66.2ms. All requests finished with 200 status code.\n\nYou might also automate that process and integrate Artillery CLI with CI/CI systems or even send metrics to external monitoring systems.\n\n### Apollo Engine\n\nLet's bring back the Apollo Engine once again. It will be helpful to analyze the load testing results.\n\nOn the **Metrics** page, you will see the following view:\n\n![Metrics](../../../assets/step17/img-13.png \"Metrics\")\n\nClick on the filter and set a custom date range to match the time you were load testing. Just to filter out other requests.\n\n![Filter](../../../assets/step17/img-14.png \"Filter\")\n\nBy default, Apollo Engine counts all operations, but you can pick the one you’re interesting in. We don’t do it and inspect them all.\n\n![List](../../../assets/step17/img-15.png \"List of operations\")\n\nOn the main part of the view, you should see “Last day overview” panel.\n\n![Overview](../../../assets/step17/img-16.png \"Last day overview\")\n\nAs you can see, all operations we ran are listed there and no error occurred.\n\n![Request Rate](../../../assets/step17/img-17.png \"Request Rate Over Time\")\n\nNext section shows the Requests Per Minute (rpm) metric over time. It’s useful to understand which operations are sent more often than others.\n\n![Request 1](../../../assets/step17/img-18.png \"Request Latency Over time\")\n![Request 2](../../../assets/step17/img-19.png \"Request Latency Distribution\")\n\nLast two panels are there to understand at what number of requests the latency increases and to show the correlation between them. We see a distribution of the processing time (the horizontal axis) and the number of operations. It also has p50, p75, p90 and p99 marks on it."
          }
        ]
      },
      {
        "releaseVersion": "0.1.0",
        "releaseDate": "2019-06-01 01:45:09 +0800",
        "tagName": "master@0.1.0",
        "tagRevision": "437c0e5feed066018bb9aa41ea28c01eabed9c32",
        "historyRevision": "8b039f9a70942ba2188260f0fe3538e11343983e",
        "changesDiff": "diff --git a/.gitignore b/.gitignore\nnew file mode 100644\nindex 0000000..5171c54\n--- /dev/null\n+++ b/.gitignore\n@@ -0,0 +1,2 @@\n+node_modules\n+npm-debug.log\n\\ No newline at end of file\ndiff --git a/.tortilla/manuals/templates/root.tmpl b/.tortilla/manuals/templates/root.tmpl\nnew file mode 100644\nindex 0000000..4586208\n--- /dev/null\n+++ b/.tortilla/manuals/templates/root.tmpl\n@@ -0,0 +1,129 @@\n+![whatsapp-clone](https://user-images.githubusercontent.com/7648874/54141944-9f801a80-4461-11e9-85a1-bcb161d9a6c6.png)\n+\n+Whatsapp Clone is a free and open-source tutorial that will guide you step-by-step on how to create a full-stack,\n+mobile, hybrid web application from scratch.\n+\n+The software world is evolving quickly, and oftentimes people find themselves left behind, even the most experienced ones.\n+The purpose of this tutorial is not only to demonstrate how to create a full application with the latest technologies, but also\n+to keep up to date with the ever-changing development ecosystem.\n+\n+This tutorial is for anyone who has ever asked themselves one of the following questions:\n+\n+- How do people build an app today?\n+- What are the currently leading technologies in the ecosystem?\n+- What are the best practices for using technology XXX?\n+- What is the purpose of technology XXX?\n+- How does technology XXX work?\n+- How do I use technology XXX?\n+- How do I migrate to the new version of technology XXX?\n+- Why should I use technology XXX over technology YYY?\n+\n+All of the above and more can be answered in the tutorial. Whether you’re a beginner, intermediate or a professional,\n+we will have the answers you’re looking for.\n+\n+**What technologies does Whatsapp Clone uses?**\n+\n+The version of the Whatsapp Clone you are looking at, uses:\n+\n+- [React (with Hooks and Suspense)](http://react.com)\n+- [Styled-Components](https://styled-components.com)\n+- [Material-UI](https://material-ui.com)\n+- [TypeScript](https://typescriptlang.org)\n+- [Apollo GraphQL](https://www.apollographql.com)\n+- [GraphQL Code Generator](http://graphql-code-generator.com)\n+- [GraphQL Modules](https://graphql-modules.com)\n+- [PostgreSQL](https://www.postgresql.org/)\n+- [GraphQL Inspector](https://graphql-inspector.com/)\n+\n+The point of this tutorial is not to be bound to a certain technology, but rather keep itself aligned with the ecosystem.\n+When a new technology comes out, and it’s better and more popular, Whatsapp Clone will upgrade to use it (together with full migration instructions).\n+\n+**P2P tutorial for the community by the community**\n+\n+Keeping tutorials up to date is not an easy task.\n+That's why we've created the Tortilla Tutorial Framework that makes it easy to write and update tutorials.\n+Also, the WhatsApp clone is completely open source in order for the community to give its feedback, help and fork ideas.\n+Here are the repositories the tutorial is made of:\n+\n+- [Whatsapp Clone - Client](https://github.com/Urigo/WhatsApp-Clone-Client-React)\n+- [Whatsapp Clone - Server](https://github.com/Urigo/WhatsApp-Clone-server)\n+- [Whatsapp Clone - Script's text](https://github.com/Urigo/WhatsApp-Clone-Tutorial)\n+\n+We’ve also made sure to publish some important documents so you can get more involved.\n+You can track our progress and comment your suggestions, since everything is based on Google Docs and is updated live:\n+\n+- [Road map](https://docs.google.com/document/d/1p2Zio6Js2eoFfHs9CjIMF6jTuNyD4eQEHlgEAKhAqM8/edit?usp=sharing)\n+- [Chapter manuals] (https://drive.google.com/open?id=1ITxOniS_S3sgZfunLvtJ1L9P6Fj1YOLlFHhoQPjT3S0)\n+\n+**Migration instructions included**\n+\n+There are many great tutorials out there, but almost none of them shows you what changes you should make in your app in order to be aligned with a new version of a certain technology.\n+As technologies are being updated by the minute, some changes are minor and insignificant,\n+but often times a breaking change will be made in which case we need to know how we can adapt to that change.\n+Thanks to the [Tortilla platform](https://tortilla.academy), we can provide you with a git-diff that will show you what changes were made between each and every released version of the Whatsapp Clone tutorial since the beginning of history.\n+This way you can easily notice the changes in APIs and migrate your app in no time.\n+\n+![tutorial-versions-diff](https://user-images.githubusercontent.com/7648874/54142148-0f8ea080-4462-11e9-9522-ec9997b76169.png)\n+\n+**Prerequisites for WhatsApp Clone**\n+\n+- JavaScript - https://javascript.info/\n+- TypeScript\n+- JSX\n+- HTML\n+- CSS\n+- Node.JS\n+- npm & Yarn\n+- React\n+- SQL\n+\n+> Even if you don't have experience with the technologies above you might be able to start the tutorial and pick things along the way.\n+> If you struggle with anything, contact us on the forum or on Github with your questions.\n+\n+OS operations such as navigating to a folder, or creating a folder, are all gonna be written in Bash, but the instructions are OS agnostic and can be applied on any machine that is web-compatible.\n+\n+Make sure you have the latest global dependencies on your computer before starting the tutorial:\n+\n+**[Node](https://nodejs.org/)**\n+\n+Install [nvm](https://github.com/nvm-sh/nvm) by running the following command in your command line:\n+\n+    $ curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.34.0/install.sh | bash\n+\n+Then install the latest version of Node by running the following:\n+\n+    $ nvm install node\n+\n+**[Yarn](https://yarnpkg.com)**\n+\n+Follow the instructions [here](https://yarnpkg.com/en/docs/install#mac-stable).\n+\n+\n+**What’s on the tutorial?**\n+\n+Whatsapp Clone is built chronologically, from the most basic, to more higher level features, so we recommend you to follow the tutorial in the right order.\n+Each step is focused on a different subject, so by the end of it you’ll have a new feature and a new set of knowledge that you can start implementing in your everyday scenario immediately.\n+\n+If you feel like you want to skip or focus on a specific subject, on each step you can download the full app code till that point in time.\n+\n+That is also useful in case you get stuck.\n+\n+Currently, Whatsapp Clone includes the following chapters:\n+\n+- [Step 1: Creating a basic React APP with a basic view.](https://github.com/Urigo/WhatsApp-Clone-Tutorial/blob/final/.tortilla/manuals/views/step1.md)\n+- [Step 2: Styling with Material-UI and Styled-Components.](https://github.com/Urigo/WhatsApp-Clone-Tutorial/blob/final/.tortilla/manuals/views/step2.md)\n+- [Step 3: Setting a basic Node.JS server with basic a basic REST endpoint.](https://github.com/Urigo/WhatsApp-Clone-Tutorial/blob/final/.tortilla/manuals/views/step3.md)\n+- [Step 4: Transition to GraphQL.](https://github.com/Urigo/WhatsApp-Clone-Tutorial/blob/final/.tortilla/manuals/views/step4.md)\n+- [Step 5: Testing.](https://github.com/Urigo/WhatsApp-Clone-Tutorial/blob/final/.tortilla/manuals/views/step5.md)\n+- [Step 6: Creating an app router and implementing a chat room.](https://github.com/Urigo/WhatsApp-Clone-Tutorial/blob/final/.tortilla/manuals/views/step6.md)\n+- [Step 7: Caching with Apollo-Client.](https://github.com/Urigo/WhatsApp-Clone-Tutorial/blob/final/.tortilla/manuals/views/step7.md)\n+- [Step 8: Sending messages with GraphQL mutations.](https://github.com/Urigo/WhatsApp-Clone-Tutorial/blob/final/.tortilla/manuals/views/step8.md)\n+- [Step 9: Type safety with GraphQL Code Generator.](https://github.com/Urigo/WhatsApp-Clone-Tutorial/blob/final/.tortilla/manuals/views/step9.md)\n+- [Step 10: Live updates with GraphQL subscriptions.](https://github.com/Urigo/WhatsApp-Clone-Tutorial/blob/final/.tortilla/manuals/views/step10.md)\n+- [Step 11: Users.](https://github.com/Urigo/WhatsApp-Clone-Tutorial/blob/final/.tortilla/manuals/views/step11.md)\n+- [Step 12: Adding and removing chats.](https://github.com/Urigo/WhatsApp-Clone-Tutorial/blob/final/.tortilla/manuals/views/step12.md)\n+- [Step 13: Authentication.](https://github.com/Urigo/WhatsApp-Clone-Tutorial/blob/final/.tortilla/manuals/views/step13.md)\n+- Step 14: Your choice! Submit a request [here](https://github.com/Urigo/WhatsApp-Clone-Client-React/issues)\n+\n+Whatsapp Clone is updated on a regular basis, so you should expect more steps and extensions with time.\n+You can keep track of our [road map](https://docs.google.com/document/d/1p2Zio6Js2eoFfHs9CjIMF6jTuNyD4eQEHlgEAKhAqM8/edit?usp=sharing) to see what’s upcoming.\ndiff --git a/.tortilla/manuals/templates/step1.tmpl b/.tortilla/manuals/templates/step1.tmpl\nnew file mode 100644\nindex 0000000..380cc0d\n--- /dev/null\n+++ b/.tortilla/manuals/templates/step1.tmpl\n@@ -0,0 +1,342 @@\n+The first thing we will do in the tutorial is to start with the UI (User Interface).\n+That is the visible part of our app that our users will see and interact with.\n+\n+In this chapter we will learn how to create a basic React app.\n+The app will contain a basic view that will render a list of conversations within our app.\n+We will gradually create our app, so for now, instead of using real data, we will use in-memory fake data instead of calling a server.\n+\n+In order to save time, instead of starting from scratch, we will use a boilerplate to kick-start our application.\n+When it comes to React apps, the most popular boilerplate is [`create-react-app`](https://github.com/facebook/create-react-app)\n+which is also officially maintained by Facebook, the creators of [React](https://reactjs.org/).\n+\n+We'll launch `create-react-app` using `yarn create` (so we won't need to install `create-react-app` permanently),\n+and run the `react-app` command to create the basis for our WhatsApp Clone.\n+\n+In your command line, navigate to the folder you want to put your app's folder in and run:\n+\n+    $ yarn create react-app whatsapp-clone-client --typescript\n+\n+> Note how we used the `client` postfix. That's because we're planning to create a server as well on later chapters.\n+\n+It will create a directory called `whatsapp-clone-client` inside the current folder.\n+Inside that directory, it will generate the initial project structure and install the needed dependencies.\n+No configuration or complicated folder structures, just the files you need to build your app.\n+\n+> In our project, we're gonna use [TypeScript](https://www.typescriptlang.org/) (indicated by the `--typescript` command).\n+> The main advantage of using TypeScript over using plain JavaScript is that if we want, we get to tell the compiler what types and data structures we expect in certain places,\n+> so that the compiler (which unlike a human never forgets) will remind us when we make a mistake and assume something that is not true.\n+> The more information we will provide to the compiler, the more the compiler will be able to help us.\n+\n+Once the installation is done, you can open your project folder:\n+\n+\t$ cd whatsapp-clone-client\n+\n+Inside the newly created project, you can run some built-in commands:\n+\n+\t$ yarn start\n+\n+Runs the app in development mode. Open `http://localhost:3000` to view it in the browser:\n+\n+![boilerplate-page](https://user-images.githubusercontent.com/7648874/54026782-025f8080-41da-11e9-9a4e-796fe15e8d03.png)\n+\n+### create-react-app\n+\n+Let's look at what create-react-app has created for us in order to understand everything that's going on.\n+\n+First thing, let's look at what webpage is being served to the browser.\n+That webpage in `index.html` that sits under the `public` folder.\n+\n+As you can see, this file is a regular HTML file. You will want to edit it's `<title>` to name our real app:\n+\n+{{{ diffStep \"1.1\" module=\"client\" files=\"public/index.html\" }}}\n+\n+In the `public` folder we will place assets that are not going to change, like `favicon.ico`, static images and the HTML templates.\n+\n+When we will prepare to app for production, a script from `create-react-app` will place those assets in a build folder and reference them into the\n+HTML template.\n+\n+Another file in the `public` folder is the `manifest.json` file that gives browsers information about our app in case the users will install the app permanently on their\n+mobile phones or desktop apps.\n+You can read more about it here: https://developers.google.com/web/fundamentals/web-app-manifest/.\n+\n+{{{ diffStep \"1.1\" module=\"client\" files=\"public/manifest.json\" }}}\n+\n+Now the HTML file has in it's <body> tag just one `<div id=\"root\"></div>` tag which is empty.\n+So how do we get the nice React logo that is being rendered onto our screen?\n+\n+`create-react-app` has scripts that will run the `src/index.tsx` file together with our HTML template, so let's look what this file is doing.\n+The important thing to see here is the `React` is calling it's render method and telling it to render the `App` component into a document where `id` equals `root`.\n+\n+So now you know where React is coming into our html template.\n+\n+But where does the `App` React component comes from and where does `React` itself comes from?\n+\n+The `index.tsx` file imports this code from outside of the file using the `import` command.\n+\n+In the case of the `App` component, we can see it bring it from the path './App', which is in the same folder ('src').\n+\n+Getting React, it is simply calling it by name instead of a path. That means that the import will automatically look for a folder named `react` under the `node-modules` folder.\n+\n+`node-modules` is a default folder which will include all of the libraries we want to use in our app.\n+\n+[yarn](https://yarnpkg.com) will install those libraries according to the dependencies listed inside the `package.json` file, so let's look into that.\n+\n+Under dependencies you can see all the libraries our app currently depends on.\n+\n+You can also see other values in there like `scripts`, which will teach `yarn` new commands that we can use.\n+The right side will name the command and the left would be the actual command that it will run.\n+\n+Another file that got created is `tsconfig.json`.\n+That file specifies options for the Typescript compiler when it takes our code and transforms it from Typescript into Javascript.\n+\n+Some noticeable configuration options for that file are:\n+\n+* `target` - What kind of Javascript should the compilers output? in our case `es5` is the version of Javascript that is supported by many browsers.\n+If you know that your app would run only on newer browsers or a Node environment, you can change that value to a newer version and gain performance improvements.\n+* `lib` - If you are using new syntax from Javascript, the compiler can add to it's output libraries that would help you support the new syntax even if the browsers don't know those.\n+* `strict` - We can give Typescript a lot of information or not so much. The more we give it the more it can help us. adding the strict option will make the compiler warn us when we won't give it enough information.\n+\n+For the full set of options, check out the [official docs](https://www.typescriptlang.org/docs/handbook/compiler-options.html);\n+\n+Now, let's look at our App's code in `src/App.tsx`.\n+\n+We can see that our app is just a function named `App`.\n+\n+`const App` means we declare a variable named `App` and `const` means it cannot be changed after it has been declared (you can't do `App = XX;` later in the app);\n+\n+Next we assign App with a function. Something like: `const App = () => {}`.\n+That way of creating functions is called `arrow functions`. It is almost equivalent to `const App = function(){}`.\n+So it is a function that doesn't accept any parameters into it.\n+\n+That function returns `jsx`. A visual language from React that describes how our component should look like.\n+\n+So all a React component is, is simply a function that returns how it look like.\n+\n+We then export this function so that React could import it from `index.tsx`.\n+\n+In our own component we will import things like the logo and styles that the component uses and those will be imported together with it each time\n+something will import our component.\n+\n+The last thing we haven't explained is the following part: `App: React.FC`.\n+Those are Typescript typings. Everything after `:` describes the types of the `App` variable and has no affect on the behavior and execution of the app.\n+It will tell Typescript what `App` is suppose to look so that in case we make a mistake Typescript will warn us before we get the app running.\n+\n+So what are the types of React.FC?  You can check it out inside by using command+click on it's name.\n+You see that it accepts `P` as props into the component and needs to return `React.Element` or `null`.\n+\n+Let's test this out, add a Typescript interface named `AppProps` and put that it includes a property called `name` of type string.\n+\n+Now let's try to return something invalid. `\"some string\"`, or `1+1`.\n+You can see that our editor is calling out that there are errors in our code.\n+\n+You will encounter those error a lot as you develop.\n+Always read the errors all the way. Understand each sentence there because that will save you a lot of time.\n+\n+Ok we now know the component doesn't get anything into itself so let's make sure the typings reflect that as well.\n+The default for React.FC is that there are no props passed inside so if we'll bring that back but keep sending the `name` value from `index.tsx` in the code, you should now get an error.\n+\n+Those errors can be very useful when your app grows.\n+Make sure to define types on the component itself like we have done now. It would make it easier to identify the issues.\n+\n+Next, we have `App.css`. This is used to style our App component.\n+Play around with changing some of the values and see how it changes your view.\n+Right now the link between the styles and the components is done by class names (`App-header`, etc).\n+Later on we'll learn better strategies of sorting our styles and making\n+sure they are not touching components that we don't want them to affect.\n+\n+Next file - `App.test.tsx`.\n+This file contains automatic tests to make sure our app is doing what it's suppose to do.\n+\n+We are programmers, that means that many times our job is to take something manual and making it automatic.\n+That's why we should also strive to automate things we do ourselves.\n+Type checking is one area, testing is another.  If we can automate tests and run them all the time, it can save us a lot of time\n+and bring us a lot of confidence that when we change our code, we haven't destroyed anything.\n+\n+The testing tool that create-react-app provides us with is [Jest](https://jestjs.io/).\n+\n+Right now we have only one simple test - it renders the App React component and makes sure nothing crashes.\n+Run the test by running `yarn test` in the command line.\n+\n+Now go and remove the export from the app component. see how the tests picked up immediately that something is wrong.\n+\n+In a later chapter we'll learn how to test more things to make sure we get guarantees that things are working as expected.\n+\n+## Pin dependencies and save-exact\n+\n+Checkout the package versions on the `package.json` file.\n+\n+you can see the `^` sign.  That means that every time someone will get this code and run `yarn`, what `yarn` will do is to get the newest version on that range.\n+We don't want that. We want to first be notified when a new version is out and we want to explicitly update it.\n+\n+That's why we need to add 2 things into our code:\n+First, to delete all `^`.\n+\n+{{{ diffStep \"1.2\" module=\"client\" files=\"package.json\" }}}\n+\n+Second, to add the following command that will make each `yarn add <package-name>` command automatically add the library without any additions or `^` signs into it.\n+\n+{{{ diffStep \"1.2\" module=\"client\" files=\".npmrc\" }}}\n+\n+There is no need to upgrade your dependencies at all. If they work it's ok. But, it is highly recommended.\n+Packages keep improving all the time with important things that would help your app and will save you time.\n+If you make it a routine to upgrade it makes it much easier then to upgrade every couple of months.\n+In order to discover if there are new versions of libraries there are 2 options.\n+\n+One is to manually run a check every day or so to find new packages out there.\n+You can do that by going to your command line in the root folder of the project and type `yarn outdated`.\n+\n+But if you want to get notified when there is a new version of your dependencies, you can check out [Renovate](https://github.com/renovatebot/renovate).\n+If your project is hosted somewhere, for example Github, it will analyze your `package.json` and submit a new PR when a new release happened from one of your dependencies.\n+\n+## git and saving your code on Github\n+\n+If you want to save your code somewhere where you can track versions, using [git](https://git-scm.com/book/en/v2) and [Github](https://guides.github.com/activities/hello-world/) is a good choice.\n+Here is a nice guide to start: https://try.github.io/.\n+\n+You can check out the `.gitignore` file create-react-app has set up for us in the root folder.\n+That file will tell `.git` what not to save and not to upload.\n+\n+**End of intro**\n+\n+Assuming that everything is set, we will now create our first screen - `ChatsListScreen`.\n+The ChatsListScreen component is responsible for showing the active conversations within our app.\n+\n+It's best to first schematically plan how our view's gonna look like.\n+This would help us illustrate the intended view and also understand which React.Components / elements take part in it.\n+This is how our screen's gonna look like:\n+\n+![chatslistscreen](https://user-images.githubusercontent.com/7648874/54027873-01305280-41de-11e9-9df0-5ad9c9c2f226.png)\n+\n+Let's break down the image above and see what components are we gonna have in the `ChatsListScreen`:\n+\n+- Navbar -  Which should contain a simple static title for now.\n+- ChatsList - Where each item's gonna contain some data regards the user we're chatting with and information about the chat.\n+\n+First let's remove the current React code and add our own code into it.\n+\n+For now, let's create fake data on our HTML.\n+\n+Add this data will be changed and we are not going to manually add HTML tags every time there is a new message, let's move our data into a JSON structure.\n+For now it would be a structure we will manually create.\n+That way we can make our React component already behave like our final version.\n+\n+{{{ diffStep \"1.3\" module=\"client\" files=\"App.tsx\" }}}\n+\n+If all we do in the function is just returning a value, instead of `const App: React.FC = () => { return () };` we can also do `const App: React.FC = () => ();`\n+So let's use that for our ChatsList component.\n+\n+We have to import React to make sure it will work.\n+We also have to export our component function so that the `App` component would be able to import it.\n+(You can't import Javascript variables from a file if that file won't explicitly export it).\n+\n+As we don't use those styles and logos anymore, we can delete the `src/App.css` and the `src/logo.svg` files from our app.\n+\n+Now let's move ChatsList into it's own component:\n+\n+{{{ diffStep \"1.4\" module=\"client\" files=\"ChatsList.tsx\" }}}\n+\n+and let's import that component into the App component and use the shorter syntax for the functional component:\n+\n+{{{ diffStep \"1.4\" module=\"client\" files=\"App.tsx\" }}}\n+\n+and let's do the same for our Navbar:\n+\n+{{{ diffStep \"1.5\" module=\"client\" }}}\n+\n+React apps tend to store React.Components under a directory located at `src/components`, and so we're gonna follow this pattern.\n+We will create a directory called ChatsListScreen in the `components` dir where we're simply gonna import and put together the Navbar and ChatsList components.\n+This is how the contents of that directory should look like:\n+\n+    ChatsListScreen\n+    ├── index.tsx\n+    ├── ChatsList\n+    └── ChatsNavbar\n+\n+We will use the `index.tsx` file to define that component, this way we can import it using the directory name:\n+\n+{{{ diffStep \"1.6\" module=\"client\" }}}\n+\n+Now, we have our app rendering our view, but it is completely static and manual in the code.\n+\n+If we had 10 messages, we wouldn't want to type all of those HTML tags again and again.\n+Also if the data will change, the app should do this update itself without the need of hand written code.\n+\n+So let's create a file that lists just the data of our chats and then make our React component render a line for each entry in that file.\n+\n+We will create the file in a JSON format:\n+\n+{{{ diffStep \"1.7\" module=\"client\" files=\"db.ts\" }}}\n+\n+We are giving IDs for the values just like a database gives a unique id for each value.\n+\n+The is so we can reference specific values, for example,\n+last message would actually reference the other array instead of duplicating the values.\n+\n+Now let's change ChatsList component to import the data from that file.\n+Then to use the Javascript [map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)\n+function to render a line for each data entry:\n+\n+{{{ diffStep \"1.7\" module=\"client\" files=\"ChatsList.tsx\" }}}\n+\n+When running `map` on the `chats` array, it will run a function for each entry in the array and return a value.\n+The function will receive the current entry as a parameter.\n+In our case the function will get the current function and will return a JSX line with the data of that specific chat.\n+\n+Notice we are also adding the `key` tag with the ID of each chat.\n+If you'll remove that and render again you will see the following error inside the console of your [Chrome developer tools](https://developers.google.com/web/tools/chrome-devtools/):\n+`Warning: Each child in a list should have a unique \"key\" prop`.\n+\n+By telling React how to identify and distinguish each element using the `key` value we help solve that problem and also making React faster.\n+Read [here](https://reactjs.org/docs/lists-and-keys.html) for more in depth explanation.\n+\n+Now that we rendered a line for each chat, let's add also the last message's content and creation date for each chat:\n+\n+{{{ diffStep \"1.8\" module=\"client\" }}}\n+\n+Try to run the app again.\n+\n+You can see we get a Typescript error.\n+This is because Typescript is smart enough and tells us there might be no last message.\n+So we add a check.\n+Remember to always check for null or undefined if optional, don’t write shorter write safer:\n+\n+{{{ diffStep \"1.9\" module=\"client\" }}}\n+\n+Now let's try again.\n+\n+Now we have a syntax error - A JSX return value can't have more then a single root Element.\n+So in order to return a root element from the function but still display multiple elements in the same level,\n+we can use [React.Fragment](https://reactjs.org/docs/fragments.html) to wrap the returned elements:\n+\n+{{{ diffStep \"1.10\" module=\"client\" }}}\n+\n+\n+Let's try again.  This time it looks like the format is not correct, so let's format the date using the `moment` library.\n+\n+Let's install the [`moment`](https://momentjs.com/) library to wrap `lastMessage.createdAt` with a better format.\n+Moment has the ability to wrap date objects nicely and rewrite them in a pretty format.\n+This way we can have an elegant time format at which the message was sent e.g. `11:34`.\n+To install:\n+\n+\t$ yarn add moment\n+\n+\n+And now let's import the library by it's name, wrap the value of each chat and call the `format` function with our requested format:\n+\n+{{{ diffStep \"1.11\" module=\"client\" files=\"ChatsList.tsx\" }}}\n+\n+\n+If you'll try to run the app you'll see that everything is there, but it's not hard to notice that it's missing some style:\n+\n+![naked-chats-list](https://user-images.githubusercontent.com/7648874/54028578-73099b80-41e0-11e9-803a-7469300acb06.png)\n+\n+In the next chapter we will take care of styling our application with [Material-UI](https://material-ui.com/) and [styled-components](https://www.styled-components.com/) - we will give it the desired look and make it more user friendly. For now the ChatsListScreen serves no purpose, because you can't really do anything with it, but it can be used as a great basis to build on top of as we make progress.\n+\n+TODO: Define and use Prettier.\n+TODO: Editor and Prettier, extensions - Auto Import, GitLens, npm Intellisense, TypeScript Importer - works when Auto Import doesn't\n+TODO: react-dev-tools, go through everything on dev tools.\n+TODO: build. show built code. show it on file and show it on the browser.\n+TODO: Go through all of https://facebook.github.io/create-react-app/docs/\n+TODO: Should we talk about Storybook?\n+TODO: Should we use “” or ‘’?\n+TODO: Should we use date-fns instead of moment?\n\\ No newline at end of file\ndiff --git a/.tortilla/manuals/templates/step10.tmpl b/.tortilla/manuals/templates/step10.tmpl\nnew file mode 100644\nindex 0000000..6486d3b\n--- /dev/null\n+++ b/.tortilla/manuals/templates/step10.tmpl\n@@ -0,0 +1,131 @@\n+So far we've been developing the app and we've been treating it as if there's no other users; we're the only one exists.\n+This approach is true when we want to develop a UI and focus on UX, but comes a point where we need to start thinking on a macro level.\n+Our app is social interactive, and if things work properly for me, it doesn't mean that it works properly to the fellow I'm chatting with.\n+It's inevitable to have an authentication system in our app, hence we need to take care of things before we get to that stage.\n+\n+Try to open 2 instances of the app in 2 separate tabs/windows, and navigate into the same chat room.\n+Try to send a message with one instance and notice that the second instance doesn't update unless we refresh the page.\n+\n+\n+![ezgif com-video-to-gif (2)](https://user-images.githubusercontent.com/7648874/55079371-fbd87080-50d6-11e9-8ade-5ffeed6eaf8d.gif)\n+\n+\n+This issue is very important and should be addressed, because a chat is all about sending and receiving messages on a lively basis.\n+This issue was expected, as there's no mechanism that would trigger and listen to changes in the back-end.\n+In this chapter we're gonna address that issue by implementing exactly that mechanism.\n+\n+**Introducing: GraphQL Subscriptions**\n+\n+[GraphQL subscriptions](https://github.com/apollographql/graphql-subscriptions) is a mechanism that works on [web-sockets](https://en.wikipedia.org/wiki/WebSocket) and live communication; clients can subscribe to it and be notified regards specific changes that happen in the back-end. Notifications will be triggered manually by us and can be provided with parameters that provide additional information regards the triggered event. For example, a `messageAdded` will be published with the new message, and will notify all clients who are subscribed to that event. Once the subscribers are notified, they can respond as they would like to, such as updating the UI.\n+\n+\n+\n+![subscription-notifications](https://user-images.githubusercontent.com/7648874/55079462-30e4c300-50d7-11e9-8399-7706da2a9cff.png)\n+\n+\n+A subscription is presented in our GraphQL schema as a separate type called `Subscription`, where each field represents an event name along with its return type.\n+Like any other GraphQL type, each field should be match with a resolver where we handle the request.\n+\n+In this chapter we will implement the `messageAdded` subscription, so users can be notified when it happens and update the messages list to contain the new message.\n+\n+**Implementing a subscription**\n+\n+We will start by creating a new `Subscription` type in our GraphQL schema with the field `messageAdded`:\n+\n+{{{ diffStep 7.1 module=\"server\" }}}\n+\n+Changes are triggered using an event-emitter like object called `PubSub`. This can be done using the `PubSub.prototype.publish` method. We will create a new instance of it and will provide it via the [context](https://www.apollographql.com/docs/apollo-server/essentials/data#context) - a common pattern for providing objects which are useful for the execution of the resolvers:\n+\n+TODO: Explain what the context is\n+\n+{{{ diffStep 7.2 module=\"server\" }}}\n+\n+Inside the `addMessage` resolver we will publish a new event called `messageAdded`. The 3rd argument of the resolver will be the context object that we've just defined in the previous step, where we can use the pubsub instance. The TypeScript type of our context can be directly defined and generated by CodeGen through the `codegen.yml` file. This can be specified under the `ContextType` field with the file path that contains the context followed by the name of the exported object, like so:\n+\n+{{{ diffStep 7.3 module=\"server\" }}}\n+\n+The event will be published right after the message was pushed into the messages collection, because order is a crucial thing. We don't want to notify our users unless the change has been made. The event will have a single parameter which represents the new message.\n+\n+{{{ diffStep 7.4 module=\"server\" }}}\n+\n+A subscription resolver behaves differently and thus should be implemented differently. Using the `pubsub.asyncIterator` instance, we can specify which events are relevant for the subscription, for example, all clients who are subscribers of the `chatUpdated` subscription will be notified when `messageAdded`, `messageRemoved` and `chatInfoChanged` events were triggered. For now, we will have a 1 to 1 relationship between the `messageAdded` event and `messageAdded` subscription. In code, it should look like this:\n+\n+{{{ diffStep 7.5 module=\"server\" }}}\n+\n+The idea behind the `pubsub.asyncIterator` method is that it returns an [`Iterator`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators#Iterators) like object, where each value is a promise that will be resolved when the relevant events are triggered. By default, the parameter that has a similar name to the subscription will be returned as a response, e.g. `messageAdded` parameter will be sent back to the subscribers. This behavior can be modified as explained [here](https://github.com/apollographql/graphql-subscriptions#payload-manipulation), but it's very unlikely and not necessary for our use case.\n+\n+As mentioned at the beginning of this article, there needs to be an open connection between the client and the server so live updates can happen. There are serveral methods for doing so, but the 2 most popular ones are:\n+\n+\n+\n+*   Based on polling with HTTP protocol\n+*   Based on web-sockets (WS protocol)\n+\n+HTTP polling means that each amount of time an HTTP request will be made to the server where potential changes can be sent back to us at any given time. HTTP requests are very reliable, but the problem with them is that they contain a lot of information in their headers, so even if we sent an empty request, it might be still very heavy due to cookies, user-agent, language, request type, etc.\n+\n+With web-sockets, once a connection has been established, it will remain open and it will only send the information which is relevant for the current session, so it's much faster. The communication is between the server and the client is bi-directional when it comes to web-sockets, which means that a user can spontaneously receive information from the server, as long as the communication channel remains open.\n+\n+> More information about the advantages of Web Sockets over HTTP can be found at [websocket.org](http://websocket.org/quantum.html)\n+\n+The subscription mechanism can be installed using the `server.installSubscriptionHandlers`. It will use the WS protocol by default and will fallback to HTTP polling if there were troubles establishing a connection via WS protocol:\n+\n+{{{ diffStep 7.6 module=\"server\" }}}\n+\n+Now we have everything set and we can start listening to subscriptions and react to to triggered changes.\n+\n+**Using subscriptions**\n+\n+To support subscriptions we need to establish a WS connection. For that we will need to update our Apollo client. We will install a couple of packages that will enable such feature:\n+\n+    $ yarn add subscriptions-transport-ws apollo-link apollo-link-ws apollo-utilities\n+\n+\n+*   [`subscriptions-transport-ws`](https://www.npmjs.com/package/subscriptions-transport-ws) - a transport layer that understands how client and GraphQL API communicates with each other. The spec has GQL_INIT GQL_UPDATE GQL_DATA events.\n+*   [`apollo-link-ws`](https://www.npmjs.com/package/apollo-link-ws) - Will establish a WS connection.\n+*   [`apollo-link`](https://www.npmjs.com/package/apollo-link) - Will enable WS and HTTP connections co-exist in a single client.\n+*   [`apollo-utilities`](https://www.npmjs.com/package/apollo-utilities) - Includes utility functions that will help us analyze a GraphQL AST.\n+\n+The WS url can be composed by simply running a regular expression over the `REACT_APP_SERVER_URL` environment variable and is unnecessary to be stored separately. Here's how our new client should look like: \\\n+\n+\n+{{{ diffStep 10.1 module=\"client\" files=\"client\" }}}\n+\n+Our subscription listeners should live globally across our application and shouldn't be bound to a specific component, thus we will create an external service which will be responsible of doing so. Using that service, we will update our GraphQL data-store any time a new message has been added. We will define a `messageAdded` subscription in a dedicated file under the `src/graphql/subscriptions` dir where all our subscriptions will be defined and exported:\n+\n+TODO: - but they are anyway. It’s just a standalone function that is used in a component. Which makes no difference.\n+\n+{{{ diffStep 10.2 module=\"client\" }}}\n+\n+Now we will create the service under the path `services/cache.service.ts`. Like any other GraphQL operation, `react-apollo-hooks` provides us with a dedicated React hook for subscriptions called `useSubscription`. Given the subscription document and the `onSubscriptionData` callback we can handle incoming changes. We will be using GraphQL Code Generator to generate typed subscription hooks, as the `typescript-react-apollo` plug-in supports it right out of the box. First let's update the `codegen.yml` file to look for documents in the `graphql/subscriptions` dir:\n+\n+{{{ diffStep 10.3 module=\"client\" }}}\n+\n+And then we will type the code generation command:\n+\n+    $ npm run codegen\n+\n+Now we can import and use the newly generated hook `useMessageAddedSubscription` in the `cache.service`. Like mentioned earlier, we will be using the `onSubscriptionData` callback to retrieve the change that was sent by the server and we will use it to re-write our cache. In this case we will be writing a new fragment for the incoming message, and we will update the correlated chat:\n+\n+{{{ diffStep 10.4 module=\"client\" files=\"cache.service\" }}}\n+\n+We will also use the exported `writeMessage()` function in the `ChatRoomScreen` so we won't have any code duplications:\n+\n+{{{ diffStep 10.4 module=\"client\" files=\"ChatRoom\" }}}\n+\n+One thing missing that you might notice is that we're trying to retrieve the chat from the received message, unfortunately our GraphQL schema doesn't support it and we will need to add it. On the server, we will add a `chat` field to the `Message` type in the GraphQL schema, and we will implement a resolver which will lookup for the chat in the chats collection:\n+\n+{{{ diffStep 7.7 module=\"server\" }}}\n+\n+Now that we have it supported we can update the `Message` fragment in the client to include that information. We don't need the entire chat, only its ID, since the fragment ID composition is done out of an ID and type name:\n+\n+{{{ diffStep 10.5 module=\"client\" }}}\n+\n+Finally, we will import the `useCacheService` React hook that we've just created and we will use it in our main `App` component. This means that the cache service will start listening for changes right as the app component is mounted:\n+\n+{{{ diffStep 10.6 module=\"client\" }}}\n+\n+Subscription handling is complete! If you'll try to repeat the same process again where you check messages updating between 2 instances of the app, you should see them both update.\n+\n+-------\n+\n+TODO: `useCacheService` shouldn’t be called like that since it’s related to message events and cache updates are only side-effects.\n\\ No newline at end of file\ndiff --git a/.tortilla/manuals/templates/step11.tmpl b/.tortilla/manuals/templates/step11.tmpl\nnew file mode 100644\nindex 0000000..6c58875\n--- /dev/null\n+++ b/.tortilla/manuals/templates/step11.tmpl\n@@ -0,0 +1,137 @@\n+Our chat app is pretty functional. We can pick a chat from the chats list and we can send messages. It's not hard to notice that one of the most important mechanisms is missing, which is relating a chat or a message to a specific user. Even though we can send messages, it's basically pointless unless someone else receives it. In this chapter we will create a new users collection with pre-defined documents and we will learn how to simulate authentication programmatically so we can test the new mechanism.\n+\n+**Reshaping the back-end**\n+\n+To implement this feature we need to rethink our back-end and reshape the way our GraphQL schema is structured. Right now we only have 2 entities: Chat and Message, which are connected like so:\n+\n+\n+\n+![chat-message-orm](https://user-images.githubusercontent.com/7648874/55325929-0faa1b00-54b9-11e9-8868-7a8ed3edcda1.png)\n+\n+\n+We want to have a new User entity where each user will have Chats he participates in and Messages he owns. Therefore, our new GraphQL schema should look like something like this:\n+\n+\n+\n+![chat-message-user-orm](https://user-images.githubusercontent.com/7648874/55325935-146ecf00-54b9-11e9-8c0f-bc3b63cbe676.png)\n+\n+This change would require us to update the GraphQL type definitions and handlers, the DB models, and the codegen configuration file:\n+\n+{{{ diffStep 8.1 module=\"server\" }}}\n+\n+Even though we made these changes, the app remained the same. That's because the Query type haven't changed at all, and we still serve the same data as before. What we need to do is to edit the Query resolvers to serve data based on the user that is currently logged-in to the app in the current session. Before we go all in with a robust authentication system, it would be smarter to simulate it, so we can test our app and see that everything works as intended.\n+\n+For now, let's assume that we're logged in with user of ID 1 - Ray Edwards. Codewise, this would mean that we will need to have the current user defined on the resolver context. In the main file, let's add the `currentUser` field to the context using a simple `find()` method from our `users` collection:\n+\n+{{{ diffStep 8.2 module=\"server\" files=\"index.ts\" }}}\n+\n+And we will update the context type:\n+\n+{{{ diffStep 8.2 module=\"server\" files=\"context\" }}}\n+\n+Now we will update the resolvers to fetch data relatively to the current user logged in. If there's no user logged in, the resolvers should return `null`, as the client is not authorized to view the data he requested:\n+\n+{{{ diffStep 8.2 module=\"server\" files=\"schema, tests\" }}}\n+\n+Now if we will get back to the app and refresh the page, we should see a new chats list which is only relevant to Ray Edwards. Earlier in this chapter, we've defined a new `isMine` field on the `Message` type. This field is useful because now we can differentiate between messages that are mine and messages that belong to the recipient. We can use that information to distinct between messages in our UI.\n+\n+Let's first download a new image that will help us achieve the new style and save it under the [`src/public/assets/message-yours.png`](https://github.com/Urigo/WhatsApp-Clone-Client-React/blob/cordova/public/assets/message-other.png?raw=true) path. Then let's implement the new style:\n+\n+{{{ diffStep 11.1 module=\"client\" files=\"src/components\" }}}\n+\n+This is how the updated `ChatRoomScreen` should look like:\n+\n+\n+\n+![chat-room-screen](https://user-images.githubusercontent.com/7648874/55326701-face8700-54ba-11e9-877e-0b7dd71a1b68.png)\n+\n+\n+\n+We can use a temporary solution to log-in and alternate between different users. This would be a good way to test data authorization without implementing an authentication mechanism. One way to know which user is logged in is via [cookies](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies).\n+\n+Cookies are just text files which are stored locally on your computer and they contain key-value data maps. Cookies will be sent automatically by the browser with every HTTP request under the `Cookie` header. The header can be parsed and read by the server and this way inform it about the state of the client. Cookie values can also be set by the server by sending back a response which contain a `Set-Cookie` header. The browser will automatically write these cookies because of its specification and how it works.\n+\n+This is how you can set cookies on the client:\n+\n+```js\n+document.cookie = \"yummy_cookie=choco\"\n+document.cookie = \"tasty_cookie=strawberry\"\n+// logs \"yummy_cookie=choco; tasty_cookie=strawberry\"\n+```\n+\n+And this is how further requests would look like:\n+\n+```\n+GET /sample_page.html HTTP/2.0\n+Host: www.example.org\n+Cookie: yummy_cookie=choco; tasty_cookie=strawberry\n+```\n+\n+Using this method we can set the current user's ID. Open your browser's dev-console, and type the following:\n+\n+```js\n+// Ray Edwards\n+document.cookie = 'currentUserId=1'\n+```\n+\n+To be able to send cookies with Apollo Client, we need to set the [`credentials`](https://www.apollographql.com/docs/react/recipes/authentication#cookie) option to \"include\" when creating the HTTP link:\n+\n+{{{ diffStep 11.2 module=\"client\" }}}\n+\n+This will set the [`Access-Control-Allow-Credentials`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Credentials) header to “include” with each HTTP request which is necessary when using the POST method. In correlation to that, we would need to configure the server to be able to receive and set cookies. This can be done via CORS options like so:\n+\n+{{{ diffStep 8.4 module=\"server\" files=\"index.ts\" }}}\n+\n+So how exactly does one retrieve the values of the cookies? Like mentioned earlier, each and every request will have them set on the `cookie` header, so one way would be by reading the header directly, but a more convenient way would be using an Express middleware called [`cookie-parser`](https://www.npmjs.com/package/cookie-parser):\n+\n+    $ yarn add cookie-parser\n+\n+{{{ diffStep 8.5 module=\"server\" files=\"index.ts\" }}}\n+\n+`cookie-parser` will read the `Cookie` header, it will parse it into a JSON and will define it on `req.cookies`. Since we’re using Apollo-Server with Express, the `req` object should be accessible as the first argument in the `context` function. This means that we can use the `currentUserId` from the cookies to fetch the current user from our users collection and define it on the context object:\n+\n+{{{ diffStep 8.6 module=\"server\" }}}\n+\n+Now you can go ahead and change the value of the `currentUserId` cookie and see how it affects the view anytime you refresh the page. Needless to say that this is not the most convenient way to switch between users, so we’re gonna implement a dedicated screen that will set the cookies for us.\n+\n+All the auth related logic should go into a dedicated service since it can serve us vastly across the application, not just for a single component. Thus we will create a new service called `auth.service`, which will contain 3 basic functions for now: `signIn()`, `signOut()` and `isSignedIn():\n+\n+{{{ diffStep 11.3 module=\"client\" }}}\n+\n+Now we will implement the `AuthScreen`. For now this screen should be fairly simple. It should contain a single `TextField` to specify the current user ID, and a `sign-in` button that will call the `signIn()` method with the specified ID. Once it does so, we will be proceeded to the `ChatsListScreen`. First we will download and save the following assets:\n+\n+- [`src/public/assets/whatsapp-icon.ping`](https://github.com/Urigo/WhatsApp-Clone-Client-React/raw/wip/cookie-auth/public/assets/whatsapp-icon.png)\n+\n+{{{ diffStep 11.4 module=\"client\" files=\"components\" }}}\n+\n+Accordingly we will define a new `/sign-in` route that will render the `AuthScreen` we’re under that path name:\n+\n+{{{ diffStep 11.4 module=\"client\" files=\"App\" }}}\n+\n+This is how the new screen should look like:\n+\n+![auth-screen](https://user-images.githubusercontent.com/7648874/55606715-7a56a180-57ac-11e9-8eea-2da5931cccf5.png)\n+\n+Now let’s type the `/sign-in` route in our browser’s navigation bar and assign a user ID, see how it affects what chats we see in the `ChatsListScreen`. You’ve probably noticed that there’s no way to escape from the `/chats` route unless we edit the browser’s navigation bar manually. To fix that, we will add a new sign-out button to the navbar of the `ChatsListScreen` that will call the `signOut()` method anytime we click on it, and will bring us back to the `AuthScreen`:\n+\n+{{{ diffStep 11.5 module=\"client\" }}}\n+\n+At this point we’ve got everything we need, but we will add a small touch to improve the user experience and make it feel more complete. Users who aren’t logged in shouldn’t be able to view any screen besides the `AuthScreen`. First they need to sign-in, and only then they will be able to view the `ChatsListScreen` and `ChatRoomScreen`. To achieve that, we will wrap all the components which require authentication before we provide them into their routes. This wrap will basically check whether a user is logged in or not by reading the cookies, and if not we will be redirected to the `/sign-in` route. Let’s implement that wrap in the `auth.service` and call it `withAuth()`:\n+\n+{{{ diffStep 11.6 module=\"client\" files=\"auth.service\" }}}\n+\n+We will use this function to wrap the right components in our app’s router. Note that since we used the `useCacheService()` directly in the `withAuth()` method, there’s no need to use it in the router itself anymore. This makes a lot more sense since there’s no need to stay subscribed to data that you're not gonna receive from the first place unless you’re logged-in:\n+\n+{{{ diffStep 11.6 module=\"client\" files=\"App\" }}}\n+\n+Assuming that you’re not logged-in, if you’ll try to force navigate to the `/chats` route you should be automatically redirected to the `/sign-in` form. We will finish the chapter here as we wanna keep things simple and gradual. It’s true that we haven’t implemented true authentication, but that would be addressed soon further in this tutorial.\n+\n+---------\n+\n+TODO: minor change, which might be helpful for people in long term. That’s a small but powerful thing to know about in TypeScript\n++ recipient: chat.participants.find(p => p !== currentUser.id)!\n+- recipient: chat.participants.find(p => p !== currentUser.id) as string\n+\n+\n+TODO: I don’t think we need `if (props.history.location.pathname === '/sign-in') return null`\n+since withAuth HOC is not used on `AuthScreen` component\n\\ No newline at end of file\ndiff --git a/.tortilla/manuals/templates/step12.tmpl b/.tortilla/manuals/templates/step12.tmpl\nnew file mode 100644\nindex 0000000..aaf2562\n--- /dev/null\n+++ b/.tortilla/manuals/templates/step12.tmpl\n@@ -0,0 +1,85 @@\n+Now that the users system is ready it would be a lot more comfortable to implement a chat creation feature. In the original Whatsapp, you can create a new chat based on your available contacts - a list of your contacts will appear on the screen and by picking one of the items you’ll basically be able to start chatting with the selected contact. However, since in our app we don’t have any real contacts (yet), we will implement the chats creation feature based on all available users in our DB. By picking a user from the users list we will be able to start chatting with it.\n+\n+![demo](https://user-images.githubusercontent.com/7648874/55896445-e4c67200-5bf0-11e9-9c1c-88318642ef81.gif)\n+\n+To be able to fetch users in our system we will need to add a new query called `users`. The `users` query will retrieve all users except for current user:\n+\n+{{{ diffStep 9.1 module=\"server\" }}}\n+\n+This query will be reflected in a component called `UsersList`. First we will define and export a new fragment called `User`:\n+\n+{{{ diffStep 12.1 module=\"client\" files=\"graphql/fragments\" }}}\n+\n+And then we will implement the `UsersList` component which is going to use the `users` query with the `User` fragment:\n+\n+{{{ diffStep 12.1 module=\"client\" files=\"UsersList\" }}}\n+\n+The list is likely to change when a new user signs-up. We will implement a subscription and live-update the list further this tutorial when we go through authentication. Now we will implement a new screen component called `ChatCreationScreen`. The screen will simply render the `UsersList` along with a navigation bar:\n+\n+{{{ diffStep 12.1 module=\"client\" files=\"ChatCreationScreen\" }}}\n+\n+The screen will be available under the route `/new-chat`. The new route will be restricted, since only authenticated users should be able to access it:\n+\n+{{{ diffStep 12.1 module=\"client\" files=\"App\" }}}\n+\n+the `/new-chat` route will be accessible directly from the main `ChatsListScreen`. We will implement a navigation button which is gonna have a fixed position at the bottom right corner of the screen:\n+\n+{{{ diffStep 12.1 module=\"client\" files=\"AddChatButton\" }}}\n+\n+And then we will render it in the `ChatsListScreen`:\n+\n+{{{ diffStep 12.1 module=\"client\" files=\"ChatsListScreen/index\" }}}\n+\n+For now we can only observe the users list. Our goal now is to be able to start chatting with a user once it has been clicked. First we will need to add a new mutation called `addChat` which will create a new chat document and add it to the chats collection. If the chat already exists we will return the existing instance. This behavior will help us navigate to the desired `ChatRoomScreen`, whether it exists or not:\n+\n+{{{ diffStep 9.2 module=\"server\" }}}\n+\n+To use the new mutation, we will define a new callback called `onUserPick` in the `UsersList` so it can be used from the `ChatCreationScreen`:\n+\n+{{{ diffStep 12.2 module=\"client\" files=\"UsersList\" }}}\n+\n+In the `ChatCreationScreen/index.tsx` module, we will define an `AddChat` document with `graphql-tag`. Using the `$ yarn codegen` command we can generate the correlated React mutation hook and use it as the `onUserPick` callback:\n+\n+{{{ diffStep 12.2 module=\"client\" files=\"ChatCreationScreen/index\" }}}\n+\n+Chats can now be created, you can test out the function by signing in with different users. However, the chats list in the `ChatsListScreen` will not be updated unless we refresh the page manually. In the server project, we will define a new subscription called `chatAdded`. The subscription should be broadcasted to the current user only if he is a participant of the published chat:\n+\n+{{{ diffStep 9.3 module=\"server\" }}}\n+\n+Now we will listen to the new subscription in the client and update the cache. First we will define the subscription document:\n+\n+{{{ diffStep 12.3 module=\"client\" files=\"graphql/subscriptions\" }}}\n+\n+And then we will update the `cache.service` to write the broadcasted chat to the store. We will write the fragment, and we will also update the `chats` query to contain the new chat. We will also check if the chat already exists before we update the query, because remember, the `addChat` mutation will return the chat even if it already exists, not if it was created only:\n+\n+{{{ diffStep 12.3 module=\"client\" }}}\n+\n+Now we can create new chats, and the chats list would be updated, without refreshing the page. You can also test it with 2 separate sessions in the browser and see how each tab/window affects the other. Lastly, we will implement a chat removal function. This is important as we don’t want to garbage our chats collection, sometimes we would like to clean up some of them.\n+\n+In the back-end, let’s implement the `removeChat` mutation. The chat can only be removed only if the current user is one of the chat’s participants. The mutation will also remove all the messages which are related to the target chat, since we’re not gonna use them anymore. The chat will be removed for all participants. This is not exactly the behavior of the original Whatsapp, but to keep things simple we will go with that solution:\n+\n+{{{ diffStep 9.4 module=\"server\" }}}\n+\n+In the client app, a chat could be removed directly from the `ChatRoomScreen`. On the top right corner, right on the navbar, we will add a dispose button that will call the `removeChat` mutation. Just like we did before, we will define the mutation document with `graphql-tag` and generate the correlated hook with CodeGen:\n+\n+{{{ diffStep 12.4 module=\"client\" }}}\n+\n+Normally this is a dangerous behavior because we wipe out the entire history without any warnings, which is not recommended. For tutoring purposes only we will keep it the way it is, because it makes things simple and easier to understand.\n+\n+To be able to update the chats list cache, we will implement a `chatRemoved` subscription. The subscription will be broadcasted only to those who’re participants of the published chat:\n+\n+{{{ diffStep 9.5 module=\"server\" }}}\n+\n+In the client, we will define the right subscription document:\n+\n+{{{ diffStep 12.5 module=\"client\" files=\"graphql/subscriptions\" }}}\n+\n+And we will update the `cache.service` to listen to the new subscription and update the `chats` query accordingly. When we deal with the fragment, we remove the `FullChat` fragment because it consists of the `Chat` fragment. If it was the other way around, we would still have some data leftovers from the `FullChat` on the fragment, because of how Apollo-Cache manages the store:\n+\n+{{{ diffStep 12.5 module=\"client\" files=\"cache.service\" }}}\n+\n+We will also update the `ChatRoomScreen` to redirect us to the `/chats` route if the chat was not found. The render method of the component will be re-triggered automatically by `react-apollo-hooks` if the cached result of `useGetChat()` hook has changed, which means that even if you didn’t actively remove the chat, you will still be redirected as a result:\n+\n+{{{ diffStep 12.5 module=\"client\" files=\"ChatRoom\" }}}\n+\n+TODO: maybe mention that ApolloCache doesn’t have Garbage Collector so even though the object is removed, everything else related to it says in cache.\ndiff --git a/.tortilla/manuals/templates/step13.tmpl b/.tortilla/manuals/templates/step13.tmpl\nnew file mode 100644\nindex 0000000..803b11c\n--- /dev/null\n+++ b/.tortilla/manuals/templates/step13.tmpl\n@@ -0,0 +1,118 @@\n+In the previous step we’ve set the ground for the authentication system in our app. We have a users collection which can be used to distinguish which data the client is authorized to view, and we have a context handler which can retrieve the current user logged in based on the received value of the `cookie` header. It’s definitely a good starting point, but it misses a lot of things.\n+\n+In this chapter we will implement a cookie-based authentication system. There are many ways to implement an authentication system in an app, but cookie-based authentication is one of the most popular ones, hence we will go with that method. Essentially the authentication flow in our app should look very simple: a user will be able to sign-in with a dedicated screen, and if he doesn’t own an account he can use the sign-up screen to create a new one. The more complicated part in this flow is the back-end, which is the core of this chapter. So before we get into the implementation, we need to understand the authentication process:\n+\n+- A user logs in with a username and a password.\n+The server compares the received username and password to the ones stored in the database.\n+- If the comparison was successful, the server will generate a token and will set it as a cookie.\n+- Each time a request is sent, the server will retrieve the username from the stored token on the cookie header and will send data back accordingly.\n+\n+![auth-flow](https://user-images.githubusercontent.com/7648874/55929679-55e94200-5c50-11e9-9fe7-54ad6194a572.png)\n+\n+The stored token will save us the hassle of re-specifying the username and password over and over again each and every request. It’s important to note that everything in the authentication process is encrypted, **sensitive information will never be stored or sent in its raw form**, otherwise data might be stolen in case of a DB breach or a request hijacking. This is what it means for our app:\n+\n+- Passwords will always be stored in an encrypted form in the DB using an algorithm called [Bcrypt](https://en.wikipedia.org/wiki/Bcrypt). Bcrypt has the ability to compare the password in its raw form to the encrypted one, which can help us authorize the user.\n+\n+- Tokens are self contained. That means that once we decode the encrypted string we can get a hold of the username string. This form of encrypted tokens is called [Json Web Token (JWT)](https://jwt.io/).\n+\n+> We're not going to elaborate about the algorithm behind each encryption method because we want to focus more on practicality, although it's very much recommended to understand how each method works before proceeding.\n+\n+The implementation will follow the principles above. Authentication is a hot topic in the GraphQL world and there are several ways of doing so. We will start with the back-end and set the infrastructure for authentication, and then we will move on to the front-end.\n+\n+We’re gonna expose 2 new mutations from GraphQL Schema: `signIn` and `signUp`. `/sign-out` is unnecessary because it can be done locally by deleting the right cookie. Our back-end is gonna grow bigger so first we will separate the Express app from the Apollo Server instance, and extract the env vars to a dedicated module:\n+\n+{{{ diffStep 10.1 module=\"server\" }}}\n+\n+We will first start with the `signIn` mutation, so we can test it against pre-defined user credentials, and then we will proceed to implementing the `signUp` mutation. It would be a lot easier to progress this way. For that we will install a couple of packages:\n+\n+- `bcrypt` - which is responsible for running a one-way encryption against received passwords before they’re stored in the DB.\n+- `jsonwebtoken` - responsible for encrypting the logged-in username before it’s set as a cooky and decrypting it once it’s sent back with a request.\n+\n+    $ yarn add bcrypt jsonwebtoken\n+\n+\n+    $ yarn add --dev @types/bcrypt @types/jsonwebtoken\n+\n+And we will implement the `signIn` mutation:\n+\n+{{{ diffStep 10.2 module=\"server\" files=\"schema\" }}}\n+\n+As you can see we use a special secret before we encrypt the username with JWT. The same secret will be used later on to decrypt the token back into username when getting requests. If someone malicious will get a hold of that password, he can fabricate an authentication token for every user that he wants, **thus it’s important to choose a strong secret**.\n+\n+When building the context for our GraphQL resolvers, we will decode the received cookie with JWT using the same secret to determine the username who made the request. Once we have that username, we can simply retrieve the original user from the DB and define it on the context:\n+\n+{{{ diffStep 10.3 module=\"server\" }}}\n+\n+You might have noticed that the User schema has been updated, because we try to address the `user.username` property. The authentication in our app will be done with a username and a password; accordingly, we will update our User type definitions and the user documents in the users collection mock. The credentials that we’re going to store can actually be used to sign-in to our app:\n+\n+{{{ diffStep 10.4 module=\"server\" }}}\n+\n+To test it out, we will run our front-end application and open the dev-console. Using the Apollo Client we will send a request to the `signIn` mutation. We can use the credentials of one of the users stored in the DB. As for now all our restricted routes are observing the `currentUserId` cookie. This is wrong and no longer relevant. Let’s change the `withAuth()` method to observe the `authToken` cookie so we can test our new mutation successfully:\n+\n+{{{ diffStep 13.1 module=\"client\" }}}\n+\n+Now we can perform the signIn. It would be a good idea to signIn with the first user - `ray`, since all the DB mock is built around him:\n+\n+```js\n+mutation signIn(username: 'ray', password: '111') {\n+  id\n+}\n+```\n+\n+Now if we would look at the value of `document.cookie` we should see a key named `authToken` with a JWT token and the `ChatsListScreen` should show the chats which are relevant to `ray`. To complete the sign-in flow we would need to update the `AuthScreen` and the `auth.service` to use username and password and the actual `sign-in` mutation we’ve just implemented.\n+\n+To check if we’re authorized to visit a route, not only we would need to check if we have the `authToken` cookie defined, but we would also need to validate it against the server to see that it actually references a real user. For that we will implement `Query.me` which will send us back the current user logged in directly from the context:\n+\n+{{{ diffStep 10.5 module=\"server\" }}}\n+\n+Now back to the `auth.service`, we will replace the `signIn()` method implementation with one that actually calls the `signIn` mutation in our API:\n+\n+{{{ diffStep 13.2 module=\"client\" }}}\n+\n+And we will use the GraphQL query we’ve just implemented to check if the user actually exists within the DB before we proceed to the restricted route:\n+\n+{{{ diffStep 13.3 module=\"client\" }}}\n+\n+we will use the new query to try and fetch the user directly from the back-end, and we will only proceed if the user was actually found. In addition, we will replace the `signIn()` method to call `signIn` mutation:\n+\n+{{{ diffStep 13.4 module=\"client\" }}}\n+\n+The behavior of the updated screen should be identical to what we had so far. To complete the flow we’ll need a way to signUp. When we signing-up we will need the following parameters: `name`, `username`, `password` and `passwordConfirm`. In addition we will need to run certain validations against the parameters:\n+\n+- The name must be at least 3 and at most 50 characters long.\n+- The username must be at least 3 and at most 18 characters long.\n+- A password must be at least 8 and at most 30 characters long. In addition, it should contain English letters, numbers, and special characters.\n+\n+For that we will implement a dedicated validations module:\n+\n+{{{ diffStep 10.6 module=\"server\" files=\"validators\" }}}\n+\n+And we will implement the resolver and schema for the `signUp` mutation:\n+\n+{{{ diffStep 10.6 module=\"server\" files=\"schema\" }}}\n+\n+Before encrypting the password we append a string called “salt” to it. Even though the passwords are stored encrypted in the DB, a hacker might use a dictionary of common passwords in their encrypted form to decipher the original password. When adding salt to a password which is essentially a random string, the hacker cannot use a dictionary anymore since he would need to know the salt. Hypothetically, the hacker can get a hold of the salt and re-generate the entire dictionary, however that would take too long because of the way Bcrypt is designed to work.\n+\n+Going back to the client, we will implement a new `signUp()` method in the `auth.service` that will call the `signUp` mutation:\n+\n+{{{ diffStep 13.5 module=\"client\" }}}\n+\n+Now we will implement a dedicated `SignUpForm` that we can use to perform the sign-up. Instead of implementing a new screen, we will use the `AuthScreen` to alternate between the `SignInForm` and the `SignUpForm` using `AnimatedSwitch`. This way we can have a container component that is common for both forms, and we will be able to switch between the two very smoothly. We will first define a new `/sign-up` route in our router:\n+\n+{{{ diffStep 13.6 module=\"client\" module=\"App\" }}}\n+\n+And then we will make the necessary changes in the `AuthScreen`:\n+\n+{{{ diffStep 13.6 module=\"client\" module=\"AuthScreen\" }}}\n+\n+> Note how we used the `/sign-(in|up)` pattern to define the `signUp` mutation. This is because the request will be further redirected in the `AuthScreen`.\n+\n+The authentication flow is complete! To test it out, you can create a new user, log in with it and start chatting with other users.\n+\n+------------\n+\n+TODO: maybe use HttpOnly in cookie\n+save user’s id or data in localStorage so we can guess if a user is logged in or not and later on invalidate it\n+we send a password in its raw form over the wire\n+Error message: “req.password and req.passwordConfirm don't match” looks odd, should be “Passwords don’t match”\n+Why is `const maySignUp = useCallback(() => {` a useCallback and not useMemo for example? We do use a value there.\ndiff --git a/.tortilla/manuals/templates/step14.tmpl b/.tortilla/manuals/templates/step14.tmpl\nnew file mode 100644\nindex 0000000..8541c20\n--- /dev/null\n+++ b/.tortilla/manuals/templates/step14.tmpl\n@@ -0,0 +1,321 @@\n+**Which Relational Database? And Why?**\n+\n+We’ve used to have an in-memory database so far that keeps our entities on memory inside business logic so far. But in a real application we will need a real database system that keeps our data which is seperated from our business logic. In this part we will design our database according to the relational database principles with the benefits of SQL.\n+\n+We prefer to use PostgreSQL from now on; because PostgreSQL is a Relational Database implementation that has tables, constraints, triggers, roles, stored procedures and views together with foreign tables from external data sources and many features from NoSQL.\n+\n+**Database Design**\n+\n+While we are defining our entity types and schema inside our array-based in-memory database, we have already designed the basic parts of them. In this part, we will design our relational database with base and relation tables regarding to them.\n+\n+Initially we can decide the base fields without relations;\n+* User;\n+    * `id`\n+    * `name`\n+    * `username`\n+    * `password`\n+    * `picture`\n+* Message;\n+    * `id`\n+    * `content`\n+    * `created_at`\n+* Chat;\n+    * `id`\n+\n+Before creating tables, we should design our database structure according to [Database Normalization principles](https://www.essentialsql.com/get-ready-to-learn-sql-database-normalization-explained-in-simple-english/) to prevent duplicated data and modification anomalies.\n+\n+Initially we will have 3 base tables in our database; `user`, `chat`, `message`; and there are some relations between those 3 tables. These relations will be defined in other relation tables together with different primary key and foreign key definitions.\n+\n+There are four types of relations in relational databases;\n+\n+* One to one\n+    * This relationship means A entity type can have a relationship with only one instance of B entity type while B entity type can have a relationship with only one instance of A entity type. For example, one user can have only one profile while a profile belongs to only one user.\n+* Many to one\n+    * This relationship means A entity type can have a relationship with multiple instances of B entity type while B entity type can have a relationship with only one instance of A entity type. For example, a chat can have multiple messages while a message belongs to only one chat. But `many to one` as a word means multiple photos belong to the same chat.\n+* One to many\n+    * This relationship has the same logic with Many to one. However, `One to many` as a word means a chat can have multiple messages while those messages cannot have multiple chats but only one.\n+* Many to many\n+    * This relationship means A entity type can have a relationship with multiple instances of B entity type while B entity type can have a relationship with multiple instances of A entity type dependently or independently. For example; a chat can have multiple users, and a user can have multiple chats.\n+\n+You can read more about those relations in [here](https://www.techrepublic.com/article/relational-databases-defining-relationships-between-database-tables/).\n+\n+In existing entity declarations and schema, we have 6 relationships;\n+\n+* Message has a One To Many relationship under the name of `chat` inside our schema; so one message can have one chat while one chat can have multiple messages.\n+    gql```\n+    type Message { chat: Chat }\n+    ```\n+* Message has another One To Many relationship under the name of `sender`` inside our schema; so one message can have one sender while one sender user can have multiple messages.\n+    gql```\n+    type Message { sender: User }\n+    ```\n+* Message has one more One To Many relationship under the name of `recipient`` inside our schema; so one message can have one recipient while one recipient user can have multiple messages.\n+    gql```\n+    type Message { recipient: User }\n+    ```\n+* Chat has a One To Many relationship under the name of `messages`, because one chat can have multiple messages while one message can have only one chat. Notice that this relationship is the reversed version of the first relationship in Message.\n+    gql```\n+    `type Chat { messages: [Message] }\n+    ```\n+* Chat has another Many To Many relationship under the name of `participants`, because one chat can have multiple participants while a participant can have multiple chats as well.\n+    gql```\n+    type Chat { participants: [User] }\n+    ```\n+* User has a Many To Many relationship under the name of `chats`, because one user can have multiple chats, while it has the same situation for chats.\n+    gql```\n+    type User { chats: [Chat] }\n+    ```\n+\n+So we should decide the dependencies between each other to add columns and tables to our database.\n+\n+* User is independent in all relationships, so we will keep its columns as it is\n+* Message is dependent to User in two cases so we can define this relationship as two different new foreign keys pointing to User’s id under the columns `sender_user_id`. But we don’t need `recipient_user_id` because `recipient` can be found under Chat’s participants.\n+* Chat is also independent because it will be better to keep those relations inside Message.\n+* Message is dependent to Chat so we can define this relationship as a new foreign key that points to Chat’s id under the column named `chat_id`.\n+* We need to have another table that defines the relationship between multiple chats and users.\n+\n+> We don’t need to duplicate relations in each entities, because SQL has the power to reverse each relations even if they are defined only in one entity. This is one of the rule of Database Normalization.\n+\n+Finally we can decide on our tables;\n+\n+* `chats` table;\n+    * `id` ->\n+        * `PRIMARY KEY` - `SERIAL`\n+        * `SERIAL` will automatically increase the number of the new chat row. Check SQL docs about primary key and auto increment\n+* `users` table;\n+    * `id` ->\n+        * `PRIMARY KEY` - `SERIAL`\n+    * `name` ->\n+        * `VARCHAR`\n+    * `username` ->\n+        * `VARCHAR` - `UNIQUE`\n+        * `UNIQUE` means this value can exist in this table only once. We use this feature because `username` must be unique in users for each user\n+    * `password` ->\n+        * `VARCHAR`\n+    * `picture` ->\n+        * `VARCHAR`\n+* `chats_users` table;\n+    * `chat_id` ->\n+        * `FOREIGN KEY` points to `chat.id` ->\n+            * `ON DELETE` -> `CASCADE`.\n+            * This means that if chat that has this id is deleted, this row will be deleted automatically as well.\n+    * `user_id` ->\n+        * FOREIGN KEY points to `user.id` ->\n+            * `ON DELETE` -> `CASCADE`.\n+* `messages` table;\n+    * `id` ->\n+        * `PRIMARY KEY` - `SERIAL`\n+    * `content` ->\n+        * `VARCHAR`\n+    * `created_at` ->\n+        * `TIMESTAMP` ->\n+            * `DEFAULT_VALUE = now()`\n+            * This means it will automatically set this to the current timestamp in the new row.\n+    * `chat_id` ->\n+        * `FOREIGN KEY` points to `chat.id` ->\n+            * `ON DELETE` -> `CASCADE`\n+            * This means that if chat that has this id is deleted, this row will be deleted automatically as well. So the message will be deleted immediately after the chat is deleted.\n+    * `sender_user_id` ->\n+        * `FOREIGN_KEY` points to `user.id`\n+            * `ON DELETE` -> `CASCADE`\n+            * This means that if user that has this id is deleted, this message will be deleted.\n+\n+> Notice that having a good dependency gives us an opportunity to benefit from `ON_DELETE` feature of SQL. Otherwise, we need to delete each dependent row manually by hand.\n+\n+**Installing PostgreSQL on your machine**\n+\n+***Windows / Mac OS X***\n+\n+You can download one-click installer for Windows and Mac OS X. During the installation, you must define a password and keep it somewhere safe.\n+\n+[https://www.enterprisedb.com/downloads/postgres-postgresql-downloads](Download Installer)\n+\n+***Ubuntu / Debian***\n+\n+If you have Debian package manager on your machine, you can install PostgreSQL in a single line in your Bash terminal;\n+\n+    $ sudo apt-get install postgresql postgresql-contrib\n+\n+***Other environments***\n+\n+Check [https://www.postgresql.org/download/](PostgreSQL website) for installation instructions on other environments.\n+\n+**Creating Database, Database User and Tables**\n+\n+> Make sure you have installed PostgreSQL on your environment first!\n+\n+We will use Bash terminal in order to access PostgreSQL using superuser;\n+\n+    $ su - postgres\n+\n+You don't need to execute the previous command if you're using Windows. But you have to open the terminal with Administrator privileges.\n+\n+    $ psql template1\n+\n+Then we will see the following PostgreSQL console;\n+\n+bash```\n+Welcome to psql 7.4.16, the PostgreSQL interactive terminal.\n+\n+Type:  \\\\copyright for distribution terms\n+       \\\\h for help with SQL commands\n+       \\\\? for help on internal slash commands\n+       \\\\g or terminate with semicolon to execute query\n+       \\\\q to quit\n+\n+template1\n+```\n+\n+So we can do the following SQL operations in order to create our new user, database and tables;\n+\n+* Create user for our database\n+\n+```sql\n+    CREATE DATABASE whatsapp;\n+```\n+\n+* Create database\n+\n+```sql\n+    CREATE USER testuser WITH PASSWORD 'testpassword';\n+```\n+\n+* Give permissions to that user\n+\n+```sql\n+    GRANT ALL PRIVILEGES ON DATABASE whatsapp to testuser;\n+```\n+\n+* Connect database\n+\n+```sql\n+    \\connect whatsapp\n+```\n+\n+* Create `chats` table\n+\n+```sql\n+    CREATE TABLE chats(\n+        id SERIAL PRIMARY KEY\n+    );\n+```\n+\n+* Create `users` table\n+\n+```sql\n+    CREATE TABLE users(\n+        id SERIAL PRIMARY KEY,\n+        username VARCHAR (50) UNIQUE NOT NULL,\n+        name VARCHAR (50) NOT NULL,\n+        password VARCHAR (255) NOT NULL,\n+        picture VARCHAR (255) NOT NULL\n+    );\n+```\n+\n+* Create `chats_users` table\n+\n+```sql\n+    CREATE TABLE chats_users(\n+        chat_id INTEGER NOT NULL REFERENCES chats(id) ON DELETE CASCADE,\n+        user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE\n+    );\n+```\n+\n+* Create messages table;\n+\n+```sql\n+    CREATE TABLE messages(\n+        id SERIAL PRIMARY KEY,\n+        content VARCHAR (355) NOT NULL,\n+        created_at TIMESTAMP NOT NULL DEFAULT NOW(),\n+        chat_id INTEGER NOT NULL REFERENCES chats(id) ON DELETE CASCADE,\n+        sender_user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE\n+    );\n+```\n+\n+* Give access for those tables\n+\n+```sql\n+    GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO testuser;\n+    GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA public TO testuser;\n+```\n+\n+**Installing PostgreSQL on our backend project**\n+\n+As we are using PostgreSQL, we will use `node-postgres` as our database client in the backend.\n+\n+First install necessary npm packages using yarn;\n+\n+\t$ yarn add pg\n+\n+And we will also need TypeScript definitions for better development experience;\n+\n+\t$ yarn add @types/pg --dev\n+\n+We will use `sql` template literals (which is way easier and safer than native API) with [this package](https://github.com/felixfbecker/node-sql-template-strings) which allows you to have SQL highlighting in VSCode with (this extension)[https://marketplace.visualstudio.com/items?itemName=forbeslindesay.vscode-sql-template-literal].\n+\n+\t$ yarn add sql-template-strings\n+\n+**Connecting to our database**\n+\n+We will use connection pooling to prevent connection leaks and benefit from transactions in our complicated SQL queries. [You can read more about the benefits of connection pooling.](https://node-postgres.com/features/pooling)\n+\n+First we need to create a connection pool using our connection credentials;\n+\n+{{{diffStep 11.2 module=\"server\" files=\"db\"}}}\n+\n+**Add Database Client to GraphQL Context**\n+\n+After that, we will request a client from this pool on each network request in our GraphQL context. So we need to update our context interface and context builder function.\n+\n+{{{diffStep 11.3 module=\"server\" files=\"context, index\"}}}\n+\n+> However we need to release that client to the pool after the network connection ends to prevent connection leaks. So, let’s use `formatResponse` to do this operation.\n+> We don't need connection pooling for subscriptions, because it can cause the connection open in all websocket connection. That's why, we don't request a new client from the pool if it is a subscription.\n+\n+**Update entity typings**\n+\n+We should update our entity typings according to our new database tables and columns.\n+\n+{{{diffStep 11.4 module=\"server\" files=\"db\"}}}\n+\n+**Add Sample Data**\n+\n+We need to update the `resetDb` function to add a sample data to our new relational database instead of in-memory database. But we will call `resetDb` if it is asked by using the environmental variable.\n+\n+{{{diffStep 11.5 module=\"server\" files=\"db\"}}}\n+\n+> When you update tables with your own ID values, you have to update `SEQUENCE`; because PostgreSQL calculates the next ID value using `SEQUENCE`s.\n+\n+**Updating Resolvers**\n+\n+We will benefit from transactions for complicated SQL queries in mutation. Transactions will help us to rollback our changes if there is an exception in the middle of our operations.\n+\n+{{{diffStep 11.6 module=\"server\" files=\"resolvers\"}}}\n+\n+> We use `pool` itself instead of `db` from the context in the subscriptions. Remember we don't request for a new client from the pool in subscriptions.\n+> If you use `pool.query`, it just opens a connection, does that operation and set the client free. In that case, you wouldn't be able to work with transactions which is not need in GraphQL Subscriptions.\n+\n+**Updating Subscriptions w/ PostgreSQL PubSub mechanism**\n+\n+Apollo’s default PubSub mechanism is not for production usage. So, we will use PostgreSQL’s notify/listen for our PubSub mechanism in GraphQL Subscriptions.\n+\n+Install the necessary packages;\n+\n+\t$ yarn add graphql-postgres-subscriptions\n+\n+{{{diffStep 11.7 module=\"server\" files=\"index\"}}}\n+\n+> Unfortunately `graphql-postgres-subscription` doesn't have TypeScript typings, so we have to import it using `require`.\n+\n+**Updating Tests**\n+\n+We should update tests to use SQL instead of in-memory database.\n+\n+{{{diffStep 11.8 module=\"server\" files=\"test\"}}}\n+\n+**Remove in-memory database**\n+\n+We can remove all the stuff related to in-memory database now.\n+\n+{{{diffStep 11.9 module=\"server\" files=\"db\"}}}\ndiff --git a/.tortilla/manuals/templates/step15.tmpl b/.tortilla/manuals/templates/step15.tmpl\nnew file mode 100644\nindex 0000000..7ab1c4a\n--- /dev/null\n+++ b/.tortilla/manuals/templates/step15.tmpl\n@@ -0,0 +1,79 @@\n+Despite using GraphQL throughout all our app, we will soon meet the need to use some external API and chances are it will be REST.\n+Our first idea could be to bridge the REST API through GraphQL, reproposing the very same API to the client. This approach is wrong, because our first concern should always be to provide the client with ready to use data in the best possible shape.\n+The client don’t need to know that our GraphQL API is backed by a REST API, it doesn’t have to pass headers required by the underlying API or do any kind of special considerations: our backend should take care of everything.\n+\n+## Retrieve a profile picture from a REST API\n+\n+In this chapter we will discuss how to use an external API called Unsplash to retrieve random profile pictures for the users who didn’t set any.\n+\n+Start heading to https://unsplash.com/developers and clicking on “Register as a developer”. After registering you will have to create a new app: take note of the Access Key because we’re going to need it.\n+\n+If you look at the Documentation (https://unsplash.com/documentation#get-a-random-photo) you’ll notice that in order to retrieve a random photo we have to query the /photos/random endpoint (GET method). We also have to pass some headers for the authent\n+cation and some params for the search term and the orientation.\n+\n+On the browser we would probably use the fetch api, but since on we node we would need a polyfill it’s better to just use a full fledged library like axios:\n+\n+    yarn add axios\n+    yarn add -D @types/axios\n+\n+Before we start implementing, we want to create some typings for our endpoint, because ideally we would like to be aided by those typings during the development.\n+In order to do so we can use a Chrome extension like Advanced Rest Client to retrieve the response.\n+Set the Method to GET, the Headers to Authorization: 'Client-ID 4d048cfb4383b407eff92e4a2a5ec36c0a866be85e64caafa588c110efad350d' and the Request URL to https://api.unsplash.com/photos/random, along with the params to query: 'portrait' and orientation: 'squarish'.\n+Copy the response, create a new file called types/unsplash.ts in your vscode editor and run the command “Past JSON as Types” (you need to install the Past JSON as Code extension and press CTRL+P to open the run command prompt). That would be enough to automatically create the typings for the random photo endpoint.\n+\n+Now we can finally implement the REST API call in our picture resolver:\n+\n+{{{ diffStep \"12.1\" module=\"client\" files=\"schema/resolvers.ts\" }}}\n+\n+In order to test it, we have to remove the picture from one of the users and re-run the server with the `RESET_DB=true` environment variable:\n+\n+{{{ diffStep \"12.1\" module=\"client\" files=\"db.ts\" }}}\n+\n+\n+## Track the API\n+\n+Even if our typings are working pretty well so far, not all REST APIs are versioned and the shape we’ve got from the server could potentially change.\n+In order to keep an eye on it we could use the safe-api middleware in order to check for abnormal answers coming from the server and log them. We can also generate the typings automatically based on the response we get.\n+First let’s install the safe-api middleware:\n+\n+    yarn add @safe-api/middleware\n+\n+Then let’s use it inside our resolver:\n+\n+{{{ diffStep \"12.2\" module=\"client\" files=\"schema/resolvers.ts\" }}}\n+\n+Now launch the client in order to retrieve the picture field multiple times.\n+\n+If you look inside the logs directory you will notice that it generated some graphql schema to represent the REST API. You will notice that each time we call the REST endpoint it generates a new schema, because a single response isn’t generic enough to account for all possible responses. Ideally safe-api should be able to average multiple esponses in order to generate the least generic schema matching the given responses.\n+\n+Now we need to remove `types/unsplash.ts` and generate some Typescript typings out of the schema. Do do so we can use the graphql-code-generator:\n+\n+{{{ diffStep \"12.3\" module=\"client\" files=\".gitignore, codegen.yml\" }}}\n+\n+    yarn codegen\n+\n+\n+## Apollo DataSources\n+\n+We’re not done yet, there is still room for improvement. Instead of using axios, we could use Apollo’s Data Sources and take advantage of the built-in support for caching, deduplication and error handling.\n+\n+    yarn remove axios @types/axios\n+    yarn add apollo-datasource-rest\n+\n+{{{ diffStep \"12.4\" module=\"client\" files=\"schema/unsplash.api.ts\" }}}\n+\n+We created the UnsplashApi class, which extends RESTDataSource. In the constructor you need to set the baseUrl (after calling super() to run the constructor of the base class). You also need to create a willSendRequest method to set the authentication headers for each call. Then it’s simply a matter of creating a getRandomPhoto method to perform the actual REST API call. Instead of calling axios you will have to call the get method of the class (which in turn gets inherited from its RESTDataSource base class): the API is very similar to the axios one.\n+\n+In order to access the data source from the resolvers we need to tell Apollo to put them on the context for every request. We shouldn’t use the context field, because that would lead to circular dependencies. Instead we need to use the dataSources field:\n+\n+{{{ diffStep \"12.4\" module=\"client\" files=\"index.ts\" }}}\n+\n+Now we need to update the typings for our context and run the graphq-code-generator again:\n+\n+{{{ diffStep \"12.4\" module=\"client\" files=\"context.ts\" }}}\n+\n+    yarn codegen\n+\n+Now it should be pretty easy to modify our resolver in order to use our just created datasource:\n+\n+{{{ diffStep \"12.4\" module=\"client\" files=\"schema/resolvers.ts\" }}}\ndiff --git a/.tortilla/manuals/templates/step2.tmpl b/.tortilla/manuals/templates/step2.tmpl\nnew file mode 100644\nindex 0000000..f0dbebe\n--- /dev/null\n+++ b/.tortilla/manuals/templates/step2.tmpl\n@@ -0,0 +1,214 @@\n+Now it's time to style our app.\n+\n+We can edit styles manually but we can also usie ready made components that have already been styled and shared in the community.\n+\n+In this chapter we will do both.\n+\n+First, we would also use [Material-UI](https://material-ui.com/) - a library with a set of React components that implements Google's Material Design.\n+What's good about it is that the design is already implemented right out of the box.\n+Not only that, but it also includes a set of icons which are free to use.\n+\n+There are many things that Material-UI can offer, and it's not easy to follow it up, especially with the constantly evolving and improving API.\n+The best way to go with it, is to identify a component you need, and then look for it in the [official website](https://material-ui.com/).\n+And when it comes to searching for icons, they can be found on the [material.io](https://material-ui.com/) website through the search bar.\n+\n+As we move further in this tutorial you should have a better grasp of Material and how to use it.\n+\n+![material-ui-icons](https://user-images.githubusercontent.com/7648874/54141504-c853e000-4460-11e9-94b5-aae98ec9a1e3.png)\n+\n+We will start off by installing some of the needed material libraries and its Typescript types library:\n+\n+    $ yarn add @material-ui/core @material-ui/icons @types/material-ui\n+\n+`@material-ui/core` includes core component of Material-UI such as Input, Popover, Modal, etc, and `@material-ui/icons` includes a set of icons.\n+Material is very generic and has a built in theming system which can be controlled by simply setting few variables,\n+which is exactly what we're gonna need in our app.\n+\n+In our app we're mainly gonna use 2 colors:\n+\n+- Primary #306759\n+- Secondary #79e352\n+\n+The easiest way to reference colors without repeating yourself is through Themes.\n+Theme definition can easily be done in Material using the MuiThemeProvider component:\n+\n+{{{ diffStep \"2.2\" module=\"client\" }}}\n+\n+\n+We create a `palette` of the themes together with any other definitions for the theme, and then we wrap our app with a React component\n+from the `material-ui` library to provide those definitions to all of our App's components when they need them.\n+\n+Once we have it set, the colors should be available to use in our application by simply providing the \"color\" prop to the component instance whose color we would like to change:\n+\n+```diff\n+<Button color=\"primary\">Primary</Button>\n+<Button color=\"secondary\">Secondary</Button>\n+```\n+\n+In our app, we're also gonna use CSS directly to change its colors, therefore it would be handy to have these theme variables available to us through CSS.\n+To do so, we will have a second definition of these variables in `index.css`, at the `:root` level of our application.\n+\n+That feels like a small duplication but this will help us use them in styled components directly.\n+Also that means you can view the variables in chrome-dev-tools.\n+\n+{{{ diffStep \"2.3\" module=\"client\" }}}\n+\n+`:root` is a pseudo element that simply represents the root node, which will make the colors available in all elements.\n+Normally, it works like JavaScript's scoping system and it will make variables available only to the current node and to its children, NOT its parents.\n+CSS vars can be used like so:\n+\n+```css\n+  color: var(--primary-text);\n+  background-color: var(--primary-bg);\n+```\n+\n+More information about CSS variables can be found in the [official MDN docs](https://developer.mozilla.org/en-US/docs/Web/CSS/Using_CSS_variables).\n+\n+So getting back to the ChatsListScreen, we will wrap the ChatsNavbar with Material's <Toolbar /> component:\n+\n+{{{ diffStep \"2.4\" module=\"client\" files=\"ChatsNavbar.tsx\" }}}\n+\n+And we will replace the `<ul />` and `<li />` elements with Material's `<List />` and `<ListItem />` in ChatsList:\n+\n+{{{ diffStep \"2.4\" module=\"client\" files=\"ChatsList.tsx\" }}}\n+\n+Thanks to the `button` attribute, the Material component can give our list a more vibrant feeling and that will display a nice ripple effect once an item is clicked,\n+something that could have taken a long time to implement manually.\n+\n+Now that we are using existing styled components, it's time to customize them to look exactly like we want them to look.\n+When we write styles, we usually use CSS.\n+\n+One of the important concepts that React brought us was the fact we could use just Javascript to describe our components\n+and another was the fact that we could encapsulate our UI into a set of separated components.\n+\n+But when it comes to CSS, we are still using it like before, having no encapsulation between different definitions and files.\n+\n+[Styled-components](https://www.styled-components.com/) is a relatively new library that will transpile a given string into a CSS string and will encapsulate it under a `React.Component`.\n+Bringing the same concepts from React into the way we write styles, so we ca define our styles programmatically.\n+With JavaScript in-hand you naturally have more control over our styles and its encapsulation, which makes it a very powerful tool.\n+\n+Here's one way to style a button using styled-components:\n+\n+```js\n+import styled, { css } from 'styled-components';\n+\n+const Button = styled.button`\n+  background: transparent;\n+  border-radius: 3px;\n+  border: 2px solid palevioletred;\n+  color: palevioletred;\n+  margin: 0.5em 1em;\n+  padding: 0.25em 1em;\n+\n+  ${props => props.primary && css`\n+    background: palevioletred;\n+    color: white;\n+  `}\n+`;\n+```\n+\n+* `styled` is coming from the `styled-components` library. When we call `styled.button` that means we are extending a button component from styled.\n+* `Button` will become a full React componnet with the extended styled we specified\n+* Like a React component, we can send props into our component. And like a React function, we can write Javascript code that interact and respond to those props.\n+In our case, just like a check we've done before in TSX to render something only if it exists, here only if we have a `primary` property, we will add extra styles to our component.\n+The created Button is actually a React.Component, so an instance of it can be created with ease like any other component:\n+* `css` is telling Styled components that the string literal that comes after describes CSS styles.\n+\n+```jsx\n+  <Button primary />\n+```\n+\n+But as this is just like a component, we should type it just like we type component, defining what properties it should get in:\n+\n+```tsx\n+import styled, { css } from 'styled-components';\n+\n+interface ButtonProps {\n+  readonly primary: any;\n+};\n+\n+const Button = styled.button<ButtonProps>`\n+  background: transparent;\n+  border-radius: 3px;\n+  border: 2px solid palevioletred;\n+  color: palevioletred;\n+  margin: 0.5em 1em;\n+  padding: 0.25em 1em;\n+\n+  ${props => props.primary && css`\n+    background: palevioletred;\n+    color: white;\n+  `}\n+`;\n+```\n+\n+More information about styled-components can be found in the official [docs page](https://www.styled-components.com/docs).\n+\n+Now, we will use `styled-components` to create new React.Components which are bound into a style-sheet.\n+This way when we create new instances of them, the components will be styled right out of the box. Example:\n+\n+```jsx\n+const Button = styled.button `\n+  border-radius: 999px;\n+`\n+\n+const RedButton = styled(Button) `\n+  color: red;\n+`\n+\n+const GreenButton = styled(Button) `\n+  color: green;\n+`\n+\n+const BlueButton = styled(Button) `\n+  color: blue;\n+`\n+\n+const Dashboard = (\n+  <div>\n+    <RedButton />\n+    <GreenButton />\n+    <BlueButton />\n+  </div>\n+)\n+```\n+\n+The clear advantage of such working strategy is that all the styles are encapsulated, unlike traditional CSS where style rules can easily collide and be merged unintentionally.\n+Remember that **`styled-components` operates per component, not globally**.\n+\n+We will start off by installing `styled-components` and its Typescript types library:\n+\n+    $ yarn add styled-components @types/styled-components\n+\n+Now, let's use `styled-components` our `ChatsListScreen`:\n+\n+{{{ diffStep \"2.5\" module=\"client\" files=\"index.tsx\" }}}\n+\n+Here you can see that we've created a new component called `Container`.\n+That component is extending `div` and adds some styles into it.\n+Then we've replaced the `div` element with the new, enhanced `div` called `Container`.\n+\n+With this we know for sure that the styles we applied for `Container` won't affect any other component in our app.\n+\n+{{{ diffStep \"2.5\" module=\"client\" files=\"ChatsNavbar.tsx\" }}}\n+\n+Here you can see we've done the same, but instead of extending a built-in component from styled-component,\n+we enhanced the `Toolbar` component from `material-ui.\n+\n+Notice that we also called the wrapper `Container` but again it has no affect on any component outside of our specific component.\n+\n+> Notice that we've added Typescript type inference `as typeof Toolbar` at the end. That's because of an issue that suppose to be fixed when we'll upgrade to material-ui v4.\n+\n+Let's finish this off by doing the same in our last component:\n+\n+{{{ diffStep \"2.5\" module=\"client\" files=\"ChatsList.tsx\" }}}\n+\n+Notice that we've changed the structure of the HTML of the `ChatsList` component.\n+We've added the ChatInfo to allow better alignment of the elements.\n+\n+We're done styling `ChatsListScreen`. We will keep using the same principles to style the rest of the components in our application. The final result should look like so:\n+\n+![screenshot](https://user-images.githubusercontent.com/7648874/54141766-40baa100-4461-11e9-8dd0-59edcfdb3b84.png)\n+\n+\n+TODO: What do people think about https://www.styled-components.com/docs/tooling#babel-plugin, should we use it here?\ndiff --git a/.tortilla/manuals/templates/step3.tmpl b/.tortilla/manuals/templates/step3.tmpl\nnew file mode 100644\nindex 0000000..bac6af8\n--- /dev/null\n+++ b/.tortilla/manuals/templates/step3.tmpl\n@@ -0,0 +1,239 @@\n+Currently we have a running app with a single screen which looks stylish and presents some data to the user.\n+\n+There is something missing though - The data that we are displaying can't be changed in any way.\n+\n+but even if we'll change the data, there is still a more fundamental issue - all of the data lives on the client.\n+\n+That means that each client has it's own copy of the data and the data is not shared between them,\n+if a client will create a new message, only that client will have the new message and not the client that the message was sent to.\n+\n+Also if the client will shut down, all data will be lost.\n+\n+So how can we have a place to put data that is being shared between all clients?\n+\n+We should find a central machine that all clients will connect to and get the data from.\n+If some client wants to create a new message, it will create it on that central machine so that the next time another clients will ask for the available messages,\n+all those messages will be available on the central machine.\n+\n+That central machine that stores data is called a database. and the machine that communicates between the database and the client is called a server.\n+\n+In this step, we will write a NodeJS server (server that runs using the Javascript language) and will expose a REST endpoint that will serve the data-mock.\n+We will build the REST application using [Express](https://www.npmjs.com/package/express).\n+Further in this tutorial, we will migrate to using a real data-base with real I/O from the user, because at this point, if the server will shut down, all data will be lost.\n+\n+The plan is to have a server up and running at `localhost:4000` that will expose a `GET /chats` route.\n+Unlike our client application, we're not gonna use any boilerplate and we're gonna set everything up manually.\n+\n+Right outside the client project, we will create a new directory called `whatsapp-clone-server` in which we will start creating our server:\n+\n+    $ mkdir whatsapp-clone-server\n+    $ cd whatsapp-clone-server\n+\n+Then we will use `Yarn` to initialize a new project:\n+\n+    $ yarn init -yp\n+\n+There's nothing special about this command, it only creates a basic `package.json` file.\n+Just to make sure that things work, we will add an `index.js` file which will print `\"hello world\"` to the console.\n+\n+{{{ diffStep \"1.1\" module=\"server\" files=\"index.js\" }}}\n+\n+And we will add a startup script to the `package.json` file called `start`:\n+\n+    \"start\": \"node index.js\"\n+\n+NPM-scripts are just a way to defined an alias for commands. Now we only have one simple script,\n+but it can turn out to be something very complex depending on our server, so it can be very useful.\n+More about npm-scripts can be found in the [official NPM docs](https://docs.npmjs.com/misc/scripts).\n+\n+Now we can run our server by running `$ yarn start` and we should see the message \"hello world\" printed to the console, as expected.\n+\n+Like in our client's app, we will be using TypeScript.\n+In order to use TypeScript we will install few packages:\n+\n+    $ yarn add --dev typescript ts-node @types/node\n+\n+> Note how we used the `--dev` flag. It is a good practice to separate between production dependencies and development dependencies.\n+That way when you deploy your server to the real environment, you won't install the unnecessary development dependencies there.\n+More about the `--dev` option can be read in the [NPM-install docs](https://docs.npmjs.com/cli/install).\n+\n+- The [`typescript`](https://www.npmjs.com/package/typescript) package is TypeScript's core transpiler.\n+- [`ts-node`](https://www.npmjs.com/package/ts-node) is an interpreter that will transpile required `.ts` files into JavaScript at runtime.\n+- [`@types/node`](https://www.npmjs.com/package/@types/node) will make the appropriate definitions for a Node.JS environment.\n+\n+> You can read more about the `@types` monorepo in the [official GitHub repository](https://github.com/DefinitelyTyped/DefinitelyTyped).\n+\n+We will rename the `index.js` file to `index.ts`:\n+\n+    $ mv index.js index.ts\n+\n+Now we need to compile the `ts` file to turn it into a Javascript file the Node can run.\n+\n+For that we will use Typescript and its `tsc` command.\n+The command has many options, but instead of writing them in the command line, we can specify them in a `tsconfig.json` file at the root of the project.\n+\n+Our server is gonna use the following `tsconfig.json` file, feel free to make the necessary modifications based on your needs:\n+\n+{{{ diffStep \"1.2\" module=\"server\" files=\"tsconfig.json\" }}}\n+\n+We need to tell Typescript which files to compile. Those are in the `include` key.\n+\n+Now let's run `tsc` and see what happens.\n+\n+We've got a new `index.js` file!  Now let's run it by running `node index.js`.\n+\n+That's great, but doing this work each time we change a file can be annoying,\n+so let's use tools to track when files change and make them run the code automatically after.\n+\n+And we will update the npm-script `start` to use `ts-node`, since we wanna use TypeScript, and not JavaScript directly:\n+\n+    start: ts-node index.ts\n+\n+We can test the startup of our server again by running `$ yarn start` and we should see the message \"hello world\" printed to the console.\n+\n+The skeleton of the project is set and we can move on to implementing the REST API.\n+\n+Like we said at the beginning, we will be using Express to setup the API. Express is a wrapper around the native [Node.JS \"http\"](https://nodejs.org/api/http.html) library which is responsible for handling HTTP requests.\n+Yes, it can also be used directly, but Express is much more comfortable and has an amazing ecosystem built around it.\n+Let's install Express and its TypeScript definitions:\n+\n+    $ yarn add express\n+    $ yarn add --dev @types/express\n+\n+Before we implement the `GET /chats` route we will implement a `GET /_ping` route. This route will be used to determine whether the server is up and running or not, and how fast the connection is based on the response time.\n+For every request sent to this route, we should expect a response saying \"pong\".\n+Some call it \"heartbeat\", because this route is being tested repeatedly by the hosting machine to check if it's alive, just like a heartbeat in a way.\n+This is how the route should look like:\n+\n+{{{ diffStep \"1.3\" module=\"server\" files=\"index.ts\" }}}\n+\n+We can use the\n+\n+        `$ curl localhost:4000/_ping`\n+\n+command to send a request to the server and we should get a \"pong\", assuming that the server available on that URL.\n+The `GET /chats` should be implemented similarly, only the response is different. Instead of returning \"pong\" we will return the data-mock for our chats:\n+\n+{{{ diffStep \"1.4\" module=\"server\" files=\"index.ts, db.ts\" }}}\n+\n+TODO: Mention `_req`\n+\n+Check we can get the chats by running:\n+\n+        `$ curl localhost:4000/chats`\n+\n+Unlike the previous route, we used the `.json()` method this time around to send a response. This will simply stringify the given JSON and set the right headers.\n+Similarly to the client, we've defined the db mock in a dedicated file, as this is easier to maintain and look at.\n+\n+It's also recommended to connect a middleware called [`cors`](https://www.npmjs.com/package/cors) which will enable cross-origin requests.\n+Without it we will only be able to make requests in localhost, something which is likely to limit us in the future because we would probably host our server somewhere separate than the client application.\n+Without it it will also be impossible to call the server from our client app.\n+Let's install the `cors` library and load it with the Express `middleware()` function:\n+\n+    $ yarn add cors\n+\n+and its Typescript types:\n+\n+\n+    $ yarn add --dev @types/cors\n+\n+{{{ diffStep \"1.4\" module=\"server\" files=\"index.ts\" }}}\n+\n+The server is now ready to use!\n+\n+So getting back to the client, first we will define our server's URL under the `.env` file:\n+\n+{{{ diffStep \"3.1\" module=\"client\" }}}\n+\n+This will make our server's URL available under the `process.env.REACT_APP_SERVER_URL` member expression and it will be replaced with a fixed value at build time, just like macros.\n+The `.env` file is a file which will automatically be loaded to `process.env` by the [`dotenv`](https://www.npmjs.com/package/dotenv) NPM package.\n+`react-scripts` then filters environment variables which have a `REACT_APP_` prefix and provides the created JSON to a Webpack plugin called [DefinePlugin](https://webpack.js.org/plugins/define-plugin/), which will result in the macro effect.\n+\n+Now let's move back into our React app folder.\n+We will now replace the local data-mock usage with a fetch from the server.\n+For that we can use the native [fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API),\n+however, it needs to be used in the right life-cycle hook of the React.Component.\n+\n+There are 2 naive approaches for that:\n+\n+- Calling `fetch()` outside the component, but this way that chats will be fetched even if we're not even intending to create an instance of the component.\n+\n+```js\n+fetch().then(() => /* ... */)\n+const MyComponent = () => {}\n+```\n+\n+- Calling `fetch()` inside the component, but then it will be invoked whenever the component is re-rendered.\n+\n+```js\n+const MyComponent = () => {\n+  fetch().then(() => /* ... */)\n+}\n+```\n+\n+These 2 approaches indeed work, but they both fail to deliver what's necessary on the right time.\n+In addition, there's no way to properly coordinate async function calls with the render method of the component.\n+\n+**Introducing: React hooks**\n+\n+With React hooks we can invoke the desired logic in the right life-cycle stage of the target component.\n+This way we can avoid potential memory leaks or extra calculations.\n+To implement a proper `fetch()`, we will be using 2 React hooks:\n+\n+- [`React.useState()`](https://reactjs.org/docs/hooks-reference.html#usestate) - which is used to get and set a state of the component - will be used to store the chats fetched from the server.\n+\n+```js\n+const [value, setValue] = useState(initialValue);\n+```\n+\n+- [`React.useMemo()`](https://reactjs.org/docs/hooks-reference.html#usememo) - which is used to run a computation only once certain conditions were met - will be used to run the `fetch()` function only once the component has mounted.\n+\n+```js\n+const memoizedValue = useMemo(calcFn, [cond1, cond2, ...conds]);\n+```\n+\n+The result of that approach will look like this, in the context of our ChatsList component:\n+\n+{{{ diffStep \"3.2\" module=\"client\" }}}\n+\n+> It's recommended to read about React hooks and their basic concept at the [official React docs page](https://reactjs.org/docs/hooks-overview.html).\n+\n+At this point we can get rid of `db.ts` file in the client, since we don't use it anymore:\n+\n+    $ rm src/db.ts\n+\n+That's it. Our ChatsListScreen is now connected to a working back-end.\n+In the next step we will upgrade our REST API into a GraphQL API and we will create a basis for a more robust back-end.\n+\n+-------------\n+TODO:\n+\n+First, `tsc` has a `--watch` option so that if the Typescript files changed it will compile them again and spit new Javascript files.\n+\n+Then we need to rerun the Node server everytime the output Javascript files has changed.\n+[nodemon](https://github.com/remy/nodemon) is a tool that tracks file and if the files changed it will re-run our node server.\n+\n+Let's create a new npm script called \"watch\" and make it run both tools:\n+\n+TODO: New diff\n+\n+TODO: https://stackoverflow.com/a/39172660/1426570\n+\n+TODO: Better watch, also watch and copy schema files (maybe in a later chapter)?\n+\n+TODO: concurrently - because it works on all environments\n+\n+TODO: Explain what -r register command does in Node and in Jest\n+\n+TODO: Talk about the difference between graphql-import and graphql-import-node\n+\n+TODO: Show debugging\n+\n+\n+It's a bit annoying that we get the compiled file right next to our Typescript file, so let's move it into a separate folder:\n+\n+TODO: New diff for the `lib` folder update\n+\n+TODO: why `useMemo(fn, [true])` instead of `useEffect(fn, [])` ?\n+\n+TODO: Move to hooks in a separate commit and later change to call the server\ndiff --git a/.tortilla/manuals/templates/step4.tmpl b/.tortilla/manuals/templates/step4.tmpl\nnew file mode 100644\nindex 0000000..0d3700e\n--- /dev/null\n+++ b/.tortilla/manuals/templates/step4.tmpl\n@@ -0,0 +1,297 @@\n+**What is GraphQL?**\n+\n+[GraphQL](https://graphql.org/) is a query language invented by Facebook, and it's used to query data within from a schema.\n+In our case, we will create a schema for the data that our server exposes through its API.\n+It allows clients to define the structure of the data required, and the exact same structure of data will be returned from the server,\n+therefore preventing excessively large amounts of data from being returned.\n+Unlike REST, GraphQL APIs are organized in terms of types and fields, not endpoints.\n+\n+Even if we use GraphQL without a server, it can save us a lot of code and work becuase it can transform data in a very easy way from a schema to a query.\n+\n+Currently in our app, if we'd like to get its chats we would send a GET request to `/chats`.\n+With GraphQL it would be done differently with a string that describes the data that we would like to get:\n+\n+```graphql\n+chats {\n+  id\n+  name\n+  picture\n+  lastMessage {\n+    id\n+    content\n+    createdAt\n+  }\n+}\n+```\n+\n+> Above: An illustration of a potential GraphQL query sent to our Whatsapp API\n+\n+**Why GraphQL and not REST?**\n+\n+REST has been used for many more years and has proven itself to work well, and it's completely agnostic to the implementation of the back-end.\n+However, when it comes to data projection and aggregation, it fails to deliver.\n+\n+When using REST, often times you'll find yourself performing multiple requests to execute a single query of data.\n+Not only that, you might even end up with additional data that is not necessary.\n+Either way, the process would result in slower and heavier response.\n+\n+With GraphQL we don’t have that kind of problem. The API is based on a schema built from many entities that we call object types.\n+Think of GraphQL as something similar to TypeScript but for API.\n+Object types are like interfaces, they describe the shape of an entity.\n+\n+In TypeScript you would describe a Chat as:\n+\n+```\n+interface Chat {\n+  id: string;\n+  name: string;\n+  picture: string;\n+  lastMessage: Message;\n+}\n+\n+interface Message {\n+  id: string;\n+  content: string;\n+  createdAt: number;\n+}\n+```\n+\n+GraphQL:\n+\n+```\n+type Chat {\n+  id: String\n+  name: String\n+  picture: String\n+  lastMessage: Message\n+}\n+\n+type Message {\n+  id: String\n+  content: String\n+  createdAt: Float\n+}\n+```\n+\n+Looks pretty similar?\n+\n+So this is the definition of the available data, now let's see how we can pick and structure data from it using a query:\n+\n+```graphql\n+# request\n+chats {\n+  id\n+  name\n+  picture\n+  lastMessage {\n+    id\n+    content\n+    createdAt\n+  }\n+}\n+```\n+\n+We think it’s pretty straightforward to understand what do you fetch by just looking at the query above.\n+\n+![graphql-request](https://user-images.githubusercontent.com/7648874/54133620-5aec8300-4451-11e9-9bda-a459dc48f57c.png)\n+\n+If you would execute that query the result might look like this:\n+\n+```js\n+// response\n+{\n+  chats: [{\n+    id: “1”,\n+    name: “Ethan Gonzalez”,\n+    picture: “https://randomuser.me/api/portraits/thumb/men/1.jpg”,\n+    lastMessage: {\n+      id: “1”,\n+      content: \"You on your way?\",\n+      createdAt: 1234567890\n+  }]\n+}\n+```\n+\n+You'll get exactly what you asked for with a single request. GraphQL provides a dynamic API while REST doesn't.\n+\n+**GraphQL schema, in a nutshell**\n+\n+Like said earlier,  GraphQL APIs are organized in terms of types and fields.\n+That means that our app data should be described with a schema, where each field's gonna have a resolver - the handler that will return the corresponding data.\n+Things will be much clearer as we move further.\n+\n+Let's try to describe our app's data with a GraphQL schema and then dive into it:\n+\n+```graphql\n+scalar Date\n+\n+type Message {\n+  id: ID!\n+  content: String!\n+  createdAt: Date!\n+}\n+\n+type Chat {\n+  id: ID!\n+  name: String!\n+  picture: String\n+  lastMessage: Message\n+}\n+\n+type Query {\n+  chats: [Chat!]!\n+}\n+```\n+\n+The schema is self explanatory in terms of what data it's compatible with. Supported built-in scalar types in GraphQL are:\n+\n+- Int: Signed 32‐bit integer\n+- Float: Signed double-precision floating-point value\n+- String: UTF‐8 character sequence\n+- Boolean: true or false\n+- ID (serialized as String): A unique identifier, often used to refetch an object or as the key for a cache.\n+While serialized as a String, ID signifies that it is not intended to be human‐readable\n+\n+Any custom scalar can be declared with the `scalar` keyword, and custom types can be declared with the `type` keyword.\n+However, you should know that some types are reserved by GraphQL itself; `Query` is one of them.\n+The `Query` type will be used as the root for received queries by the clients, which means that we can send queries which start with the `chats` field.\n+Other reserved types are:\n+\n+- `type Query` - reserved for [GraphQL queries](https://graphql.org/learn/queries/#mutations).\n+- `type Mutation` - reserved for [GraphQL mutations.](https://graphql.github.io/learn/queries/)\n+- `type Subscription` - reserved for [GraphQL subscriptions.](https://www.apollographql.com/docs/react/advanced/subscriptions.html)\n+\n+> As we're not gonna go through the entire GraphQL API, it's recommended to go through the [official learn section of the GraphQL website](https://graphql.org/learn/), but the information so far will definitely help you kick-start, plus the upcoming implementation.\n+\n+**Getting started**\n+\n+We will be implementing a GraphQL mechanism for the client and for the server.\n+We will start with the server as things will make more sense, and we will be able to test it before we proceed into the client.\n+Essentially GraphQL is connected into a HTTP endpoint, usually under `POST /graphql`, and so this is exactly what we're gonna do, connect the endpoint handler.\n+Luckily, we don't have to implement that. A team called [Apollo](https://www.apollographql.com/) already did it for us, so we can use their implementation.\n+We will install the required packages:\n+\n+    $ yarn add apollo-server-express body-parser graphql\n+    $ yarn add --dev @types/body-parser @types/graphql\n+\n+- [`graphql`](https://www.npmjs.com/package/graphql) - The core package of GraphQL that includes the resolvers for basic data-types.\n+- [`apollo-server-express`](https://www.npmjs.com/package/apollo-server-express) - Apollo's implementation for the GraphQL Express REST endpoint.\n+- [`body-parser`](https://www.npmjs.com/package/body-parser) - Parse incoming request bodies in a middleware before your handlers, available under the req.body property.\n+- `@types/…` - TypeScript definitions. Notice that we didn't need to install Apollo's types library. That is because Apollo themselves writes their source code in Typescript so\n+we get a ready Typescript code directly from their library.\n+\n+We can now connect Apollo's middleware under the `/graphql` route:\n+\n+{{{ diffStep \"2.1\" module=\"server\" files=\"index.ts\" }}}\n+\n+As you can see, the middleware requires a schema. A schema is composed mainly out of 2 fields:\n+\n+- `typeDefs` (type definitions) - the schema types we wrote earlier this chapter for chats.\n+- `resolvers` - The handlers that will provide the data for each field in `typeDefs`.\n+\n+We will start first by defining the types.\n+All we have to do is to copy-paste the contents of the schema that was shown earlier into a new file called `typeDefs.graphql`:\n+\n+{{{ diffStep \"2.2\" module=\"server\" files=\"schema/typeDefs.graphql\" }}}\n+\n+The `.graphql` file extension is just a more convenient way to work with a GraphQL schema. The exported result should be a simple string that we can use to compose our GraphQL schema. The clear advantage of working with a dedicated file is that we get to have syntax highlight.\n+\n+Now we will implement the resolvers. Resolvers are presented in a JSON object where each resolver name should match the field name it represents. You can read more about resolvers in [Apollo's official docs for resolvers](https://www.apollographql.com/docs/tutorial/resolvers.html). This is how our resolvers should look like:\n+\n+{{{ diffStep \"2.2\" module=\"server\" files=\"schema/resolvers.ts\" }}}\n+\n+For now it's extremely simple, we map the chats query directly into the database collection. Each field in the resolvers object should match the GraphQL type it represents in the schema. Since we don't have any logic now, we should not implement any resolvers for the rest of the types, the data will simply be forwarded as is.\n+\n+Note that we've implemented a custom scalar named `Date` and we resolved it with an NPM package. Let's install it:\n+\n+    $ yarn add graphql-iso-date\n+    $ yarn add --dev @types/graphql-iso-date\n+\n+Final thing that we have to do would be combining the resolvers and the type-defs under a single GraphQL schema.\n+\n+{{{ diffStep \"2.2\" module=\"server\" files=\"index.ts\" }}}\n+\n+[`graphql-tools`](https://www.npmjs.com/package/graphql-tools) is a library with a set of utilities that will help us create a schema that will be compatible with Apollo's API:\n+\n+    $ yarn add graphql-tools graphql-import\n+\n+There's one optimization however that we should make in the our DB. Right now, the each chat document has a direct reference to a message via the `lastMessage` field. Practically speaking, this is NOT how the data sits in the DB. The `lastMessage` should only hold the ID for the correlated message, and then in the Node.JS app we should **resolve** it according to our needs. Let's make the appropriate changes in the DB then:\n+\n+{{{ diffStep \"2.3\" module=\"server\" files=\"db.ts\" }}}\n+\n+And a resolver to the `lastMessage` field:\n+\n+{{{ diffStep \"2.3\" module=\"server\" files=\"schema/resolvers.ts\" }}}\n+\n+The first argument of the resolver is the raw chat data received by the DB, and the returned result should be the mapped value which we would like to return to the client.\n+\n+As we get further in this tutorial we should get a better grasp regards resolvers and their API, since we will have to deal with more logic and complexity within our Node.JS app.\n+\n+Assuming that the server is running, we can already test our GraphQL endpoint. Because it's exposed to us via a REST endpoint, we can use a `$ curl` command to send a request to `GET localhost:4000/graphql` and get a response with all the data. Again, the query that we're gonna use to fetch the chats is:\n+\n+```graphql\n+chats {\n+  id\n+  name\n+  picture\n+  lastMessage {\n+    id\n+    content\n+    createdAt\n+  }\n+}\n+```\n+\n+The one-liner version of it with a `$ curl` command looks like so:\n+\n+    curl \\\n+      -X POST \\\n+      -H \"Content-Type: application/json\" \\\n+      --data '{ \"query\": \"{ chats { id name picture lastMessage { id content createdAt } } }\" }' \\\n+      localhost:4000/graphql\n+\n+As a response we should get the data-mock for our chats stored in the server. Since we have that in place, we can go ahead and delete our implementation for the `GET /chats` route.\n+\n+Another way to test and inspect our GraphQL schema would be by using an IDE for the browser called [GraphQL Playground](https://github.com/prisma/graphql-playground).\n+Apollo-Server ships with it right out of the box and can be used right away by navigating to the `http://localhost:4000/graphql` URL from the browser.\n+\n+[![](https://i.imgur.com/AE5W6OW.png)](https://graphqlbin.com/v2/6RQ6TM)\n+\n+So getting back to the client, all we have to do is to change the fetching URL in the ChatsList component to use our newly implemented GraphQL REST endpoint:\n+\n+{{{ diffStep \"4.1\" module=\"client\" }}}\n+\n+The received data should be similar to the previous one.\n+No further changes are required.\n+\n+In the next chapter, we will continue working on the UI of our front-end application and we will add a new screen to the flow - the `ChatRoomScreen`.\n+\n+-------\n+TODO: Start with calling the  `graphql` function just on the server to show how it works.\n+TODO: Separate step for body parser.\n+TODO: Example middlewares in Node\n+TODO: Mention the vs code extension\n+\n+TODO: Introduce the scalar type later on\n+\n+TODO: Start without Apollo and add it later, in the same file.\n+TODO: remove `gql` import becuase it's unused\n+TODO: Add visualizations of how GraphQL works\n+TODO: import { loadSchema } from 'graphql-toolkit'; and install it\n+\n+TODO: What DB change is that?\n+TODO: Type `lastMessage(chat: any) {`\n+TOOD: Change `m` to `currentIteratedMessage`\n+\n+TODO: Why adding headers? and go through the code\n+\n+TODO: Talk about working with document node and not with makeExacutableSchema\n+```\n+זה לא משנה בתכלס, כי ApolloServer בכל מקרה יעשה לזה קימפול\n+הנקודה היא שלא צריך לקמפל פעמיים לGraphQLSchema\n+פשוט עדיף שאת הקימפול יעשה הרכיב האחרון שהולך להשתמש בtypeDefs\n+\n+DocumentNode => DocumentNode (cheap, easy, no checks)\n+DocumentNode => GraphQLSchema (compile AST, does all checking, might throw exceptions, expensive)\n+GraphQLSchema => DocumentNode (printed version, might lost AST features such as directives)\n+```\n\\ No newline at end of file\ndiff --git a/.tortilla/manuals/templates/step5.tmpl b/.tortilla/manuals/templates/step5.tmpl\nnew file mode 100644\nindex 0000000..ba9132d\n--- /dev/null\n+++ b/.tortilla/manuals/templates/step5.tmpl\n@@ -0,0 +1,156 @@\n+Testing is a crucial part when writing an application, especially if we're planning to publish it or make it a commercial thing. Before we hand someone a product, of any kind, we wanna make sure that it passes certain quality checks. We're signed on that product and so it's very important to ensure that it functions properly according our expectations, otherwise wouldn't wanna use it and will look for alternatives.\n+\n+In the context of software, we constantly make changes. It's also inevitable to make all features completely independent from one another, so something in the app is likely to break as we upgrade it or maintain it. That's why we need to write a set of tests that can be run on demand, so when we implement a new feature we can simply run the tests and see what feature broke due to most recent changes.\n+\n+There are currently 3 main testing frameworks in the NPM ecosystem: [Jasmine](https://jasmine.github.io/), [Mocha](https://mochajs.org/), and [Jest](https://jestjs.io/). Each testing framework has its pros, and cons, and at the end of the day it's a matter of preference. In our application we're gonna use [Jest](https://jestjs.io/) - a testing framework which was developed by Facebook. What's good about Jest is that it can be used to test both client and server logic, because it runs as a Node.JS application, but it also emulates the browser environment whenever we run it, thanks to [JSDOM](https://github.com/jsdom/jsdom).\n+\n+![jest](https://user-images.githubusercontent.com/7648874/54493900-e2ce0380-490f-11e9-8075-be4a236c7c38.png)\n+\n+In this chapter we will learn how to test the React.Components in the client, and Apollo-GraphQL resolvers in the server. There are 3 kinds of tests:\n+\n+- Unit tests - which are used to test a single component, independently from other components in our system.\n+- Integration tests - which are used to test a component in relation to other components in our systems (how well do they co-work with each other).\n+- e2e tests (end to end) - which are used to test a complete, from the moment I clicked on a button in the user interface until the data gets back from the server and shown on the screen.\n+\n+The efficiency of the tests go from bottom to top (unit -> e2e), but the maintenance and complexity go from bottom to top (e2e -> unit). Accordingly we will need to find a good balance where we don’t spend too much time on writing tests yet have a good indicator for how well our system functions. So we should write a lot of unit tests, a good amount of integration tests and a handful of e2e tests.\n+\n+![tests-types-table](https://user-images.githubusercontent.com/7648874/54494121-fed2a480-4911-11e9-9370-694ec989729b.png)\n+\n+We will start with the client as it’s much easier, because Jest is set and ready to use right out of the box thanks to `create-react-app`.\n+\n+**Client - Testing React.Components**\n+\n+Thanks to `create-react-app`, we have Jest set and ready to use right out of the box, so we can start writing tests right away. I you'll look at the `src` you'll see a file called `App.test.tsx`, which simply ensures that the component can be rendered without crashing.\n+\n+```jsx\n+import React from 'react';\n+import ReactDOM from 'react-dom';\n+import App from './App';\n+\n+it('renders without crashing', () => {\n+  const div = document.createElement('div');\n+  ReactDOM.render(<App />, div);\n+  ReactDOM.unmountComponentAtNode(div);\n+});\n+```\n+\n+This is not a typical test that you're likely to find in a React project, but it demonstrates very well how Jest can be used to test DOM related issues. If you'll run `$ npm run test` (or `$ yarn test`) in the command line and then press `a`, you should see the following output:\n+\n+![report](https://user-images.githubusercontent.com/7648874/54341429-eabe4700-4674-11e9-8e76-3aaaf7fec79a.png)\n+\n+Jest will automatically run for every file that ends with a `.test.xxx` extension. This is very convenient because the tests can live right next to the component, and you don't need to lookup for it across the project. This behavior can be modified by configuring Jest in the `package.json` file under the `\"jest\"` field. More information about configuring Jest can be found in the official[ configuration documentation](https://jestjs.io/docs/en/configuration).\n+\n+> If you get a warning message regards wrapping the component with `act()` - this is a known issue with hooks and should have a proper solution soon. More about this issue and progress regards its fix can be found in this [GitHub thread](https://github.com/facebook/react/issues/14769#issuecomment-470097212).\n+\n+Now we're gonna write a basic test for the `<ChatsList />` component. In the test, we'll mock a fake response from the server, and examine the contents of rendered HTML. Since the HTML of the component is a dynamic thing and is constantly subject to changes, it would be a good idea to annotate it with `data-testid` attributes so it can be tested regardless of its structure:\n+\n+{{{ diffStep \"5.1\" module=\"client\" files=\"ChatsList.tsx\" }}}\n+\n+Now we can select various HTML elements with a query selector when we test the component. We will install a couple of packages that will assist us in implementing the test:\n+\n+  $ yarn add jest-fetch-mock jest-dom react-testing-library\n+\n+- The [`jest-fetch-mock`](https://www.npmjs.com/package/jest-fetch-mock) package can mock responses emitted by the Fetch API.\n+- The [`jest-dom`](https://www.npmjs.com/package/jsdom) package will add custom matchers that will help us examine HTML contents of DOM elements.\n+- The [`react-testing-library`](https://www.npmjs.com/package/react-testing-library) package contains utility methods that will help us test React.Components with Jest.\n+\n+Next, we will create a file under the `src` folder called `setupTests.ts`. This file is loaded configured automatically by `create-react-app` and loaded by Jest, and we can use it to set up our testing environment according to our needs (like said earlier, Jest can be configured, so this file path can be changed). We will use that file to define a fake Fetch API using the `jest-fetch-mock` library:\n+\n+{{{ diffStep \"5.2\" module=\"client\" files=\"src/setupTests.ts\" }}}\n+\n+We will create another file called `ChatsList.test.tsx`, right next to the `<ChatsList />` component under the `ChatsListScreen` directory, and inside we will implement our test. The test should follow these steps:\n+\n+- Mock the response to contain a fake chat, so we won't need to make an actual call to our GraphQL API.\n+- We will create a new instance of `<ChatsList />` and render it in a container element.\n+- We will wait for changes in the DOM caused by `setState()`.\n+- We will test the contents of the container.\n+\n+And this is how the implementation should look like:\n+\n+{{{ diffStep \"5.3\" module=\"client\" files=\"src/components/ChatsListScreen/ChatsList.test.tsx\" }}}\n+\n+> Jest API is vast but pretty intuitive for the most part. It mostly consists of test descriptors and matchers. [Here's a full list of all matchers which are built into Jest's API](https://jestjs.io/docs/en/expect). Always make sure to work against it when writing tests, for optimal results.\n+\n+We will now move on to testing the server where we will learn how to setup Jest manually and test it against a GraphQL API.\n+\n+**Server - Testing GraphQL resolvers**\n+\n+To set-up Jest, we will run the following in the command line:\n+\n+    $ yarn add --dev jest @types/jest ts-jest\n+\n+\n+This will basically install Jest and make it useable with TypeScript.\n+In addition, we will need to specify the file pattern that we would like to transform with [`ts-jest`](https://www.npmjs.com/package/ts-jest), by adding the following section to `package.json`:\n+\n+```\n+{\n+  \"jest\": {\n+    \"transform\": {\n+      \"^.+\\\\.(js|jsx|ts|tsx)$\": \"<rootDir>/node_modules/ts-jest\"\n+    }\n+  }\n+}\n+```\n+\n+We will also add a `\"test\"` script in the `package.json` file,\n+so we can run the tests with `$ yarn test`:\n+\n+```\n+{\n+  \"scripts\": {\n+    \"test\": \"jest\"\n+  }\n+}\n+```\n+\n+This is how our `package.json` should look like at this point:\n+\n+{{{ diffStep \"3.1\" module=\"server\" files=\"package.json\" }}}\n+\n+Now we're gonna test the `chats` query in our GraphQL schema. To do so, we will setup an Apollo Client and send a query request to our back-end, and then we will match the received response with a pre-defined snapshot. Luckily, we don't have to set an actual client, since the tests and the implementation of the back-end live right next to each other, thus, we will install a package which will help us achieving so:\n+\n+    $ yarn add --dev apollo-server-testing\n+\n+We will define the test suite under the `tests/queries` folder in a file called `getChats.test.ts`:\n+\n+{{{ diffStep \"3.2\" module=\"server\" files=\"tests/queries/getChats.test.ts\" }}}\n+\n+In the test function, we create a new instance of the Apollo-GraphQL server using our schema, and we query some data against it thanks to the fake client created by [`apollo-server-testing`](https://www.npmjs.com/package/apollo-server-testing).\n+\n+The `.toMatchSnapshot()` matcher will call the `toString()` method on the examined object and will test it against a predefined snapshot.\n+The snapshot will automatically be created once we run the test for the first time and will be stored under the `__snapshot__` directory.\n+This means that the first test run will always pass. This is useful because you can later on observe and adjust manually the snapshot manually without having to write it from scratch.\n+\n+So let's do our first test run for the server:\n+\n+    $ yarn test\n+\n+The expected result should be a projection of the data stored in the `db.ts` file.\n+\n+{{{ diffStep \"3.2\" module=\"server\" files=\"tests/queries/__snapshots__\" }}}\n+\n+Always be sure to observe the snapshot before moving on! The received result isn't necessarily what you'd expect. Also it's not a good practice to store production data in the snapshot because it's subject to changes. Normally we would set up another instance of the DB for testing purposes, but since our DB is a mock and doesn't represent real data, there's no need to at this stage.\n+\n+Now that we have the required knowledge regards testing and Jest's API, we will implement tests throughout the tutorial as a trivial thing. We will not go through each and every new matcher that we introduce, as it is self explanatory and there's too much of them. Be sure to work against [this full list of matchers](https://jestjs.io/docs/en/expect) when working with Jest.\n+\n+In the next chapter we will continue expanding our application by adding a `<ChatRoomScreen />`.\n+\n+----------\n+TODO: Check what changed on testing in create-react-app 3.0 https://facebook.github.io/create-react-app/docs/running-tests\n+\n+TODO: I think ts-jest could be configured in a simpler way, but need to check\n+\t{ preset: 'ts-jest' }\n+\n+TODO: I don’t like using jest’s toMatchSnapshot() to compare operation’s result that comes from the real GraphQL Schema (with resolvers).\n+It might change quite a lot and break tests. That data might be huge and hard to be validated by looking at it. Maybe checking a structure is a better approach?\n+\n+TODO: Why ts-jest?\n+\n+TODO: Change into tortilla diff:\n+\n+TODO: Change into Tortilla diif:\n+\n+TODO: Test with UTC timezone so it would work on all computers\n+\n+TODO: const server = new ApolloServer({ typeDefs }); // easier, no need to compile the schema before\n\\ No newline at end of file\ndiff --git a/.tortilla/manuals/templates/step6.tmpl b/.tortilla/manuals/templates/step6.tmpl\nnew file mode 100644\nindex 0000000..cf3c983\n--- /dev/null\n+++ b/.tortilla/manuals/templates/step6.tmpl\n@@ -0,0 +1,223 @@\n+In this chapter we will learn how to build a chat room screen.\n+In order to navigate between different screens, we will setup a router.\n+\n+Since we're gonna have to screens in our app now - `ChatsListScreen` and `ChatRoomScreen`, we will need a router that will be able to alternate between them.\n+We will be using the [`react-router-dom`](https://www.npmjs.com/package/react-router-dom) package to manage the routes of the application:\n+\n+    $ yarn add react-router-dom\n+\n+And we will implement a router directly in the `<App />` component:\n+\n+{{{ diffStep 6.1 module=\"client\" files=\"App\" }}}\n+\n+The purpose of a router is to make route managing easy and declarative.\n+It will take care of managing the history within our app and parameterizing certain screens according to our need.\n+Essentially it's a wrap around the `window.history` object which is also compatible with React.\n+I recommend you to go through the [official MDN docs](https://developer.mozilla.org/en-US/docs/Web/API/History) if you're not yet familiar with the concept.\n+\n+The `<Route />` component represents a path for a route in our application. Using the colon syntax (`:chatId`) we basically tell the router that the `/chat` route should be followed by a string whose value can later on be addressed via a parameter called `chatId` when navigating to the route. So here's a sum-up of the routes manifest:\n+\n+\n+\n+*   `/chats` - will navigate to the `ChatsListScreen`.\n+*   `/chat/:chatId` - e.g. `/chat/1`, will navigate to the `ChatRoomScreen` and will parameterize it to show data which is related to chat ID 1.\n+*   Any other route will fallback to the `/chats` route which will redirect us to the `ChatsListScreen`.\n+\n+Now we will implement the `ChatRoomScreen` so the router can function properly.\n+For now we will make it a plain screen which simply prints out the information of the chat that was clicked so we can have a complete flow,\n+and then we will take care of the rest.\n+\n+To do so, we will first implement the `chat` query in our backend.\n+This would be a parameterized query that will provide us with a specific chat according to the received ID,\n+and it will be used by the new screen as soon as it is initialized.\n+First we would update the `Chat` type to contain a `messages` field:\n+\n+{{{ diffStep 4.1 module=\"server\" files=\"typeDefs.graphql\" }}}\n+\n+Then we will create the appropriate resolver:\n+\n+{{{ diffStep 4.1 module=\"server\" files=\"resolvers.ts\" }}}\n+\n+And then we will update our DB mock to be aligned with these changes:\n+\n+{{{ diffStep 4.1 module=\"server\" files=\"db\" }}}\n+\n+This means that when we resolve `Chat.lastMessage`, we should get it directly from the `Chat.messages` field:\n+\n+{{{ diffStep 4.2 module=\"server\" }}}\n+\n+Now that we have an updated schema which is relevant to the new screen that we would like to add, we will declare a new query called `chat`:\n+\n+{{{ diffStep 4.3 module=\"server\" files=\"schema/typeDefs\" }}}\n+\n+Note that unlike the `chats` query, this time we have a parameter. The parameters are provided to the resolver function as the second parameter as a JSON. Using the provided parameter - the chat ID, we will find and return the relevant chat from the DB:\n+\n+{{{ diffStep 4.3 module=\"server\" files=\"schema/resolvers\" }}}\n+\n+> More about the resolver signature can be read in [Apollo-GraphQL's official docs page](https://www.apollographql.com/docs/apollo-server/essentials/data.html#type-signature).\n+\n+Now we will add a test suite:\n+\n+{{{ diffStep 4.3 module=\"server\" files=\"tests/queries/getChat.test\" }}}\n+\n+We can observe the snapshot created by Jest to get a better understanding of how the response should look like:\n+\n+{{{ diffStep 4.3 module=\"server\" files=\"__snapshot__\" }}}\n+\n+If you experience any TypeScript related issues with the following error:\n+\n+```\n+Object literal may only specify known properties, and 'variables' does not exist in type 'Query'.\n+```\n+\n+Add the following declaration file to your project:\n+\n+{{{ diffStep 4.3 module=\"server\" files=\"types\" }}}\n+\n+This is a [known issue](https://github.com/apollographql/apollo-server/issues/2172) in the `apollo-server-testing` package and has a pending [fix PR](https://github.com/apollographql/apollo-server/pull/2307).\n+Now getting back to the client, let's implement a basic version of the `ChatRoomScreen` where we will fetch the new query and print it to the screen:\n+\n+{{{ diffStep 6.2 module=\"client\" }}}\n+\n+Note how we used the `match.params.chatId` variable to get the selected chat ID.\n+The `match` prop is defined and provided to us by the `<Route />` component, since it interfaces directly with the `ChatRoomScreen`.\n+More about that can be read in the [official docs page](https://reacttraining.com/react-router/core/api/match).\n+\n+In many examples online, you can see people pass the `match` prop directly to the component.\n+The main issue with that is that this makes the component being usable only by a router, but the truth is that the component\n+doesn't care if it's consumed by a router or another parents component as long as they will pass the `chatId` prop.\n+\n+So we need to make sure the interface of the ChatRoom component defines those requierements right.\n+\n+Next we will call our server from the component with the right query and store the result on a `useState` hook.\n+\n+Now, because we are using GraphQL, we know the types of the result that we are going to get, so let's create Typescript interfaces that\n+describe the data we're going to get from the server.\n+\n+If you'll run the application and type `/chats/1` in the URL bar, this is what you should see on the screen:\n+\n+![naked-chat](https://user-images.githubusercontent.com/7648874/54664314-d4096b80-4b1e-11e9-9e06-1323cf7b0abe.png)\n+\n+The view has no styling at all but it should be fixed in a moment.\n+To make navigation more convenient we will add an `onClick` listener for each chat item in the `ChatsList`.\n+Using the [history](https://reacttraining.com/react-router/core/api/history) object, provided to us by the `<Route />` component,\n+we will navigate to the correlated `ChatRoomScreen`:\n+\n+First let's install the `history` package:\n+\n+    $ yarn add history @types/history\n+\n+{{{ diffStep 6.3 module=\"client\" }}}\n+\n+And add test the new logic:\n+\n+{{{ diffStep 6.4 module=\"client\" }}}\n+\n+If you'll click on the chat item you'll see that the screen changes very suddenly.\n+We can smooth the transition by animating it with CSS.\n+Luckily we don't need to implemented such mechanism manually because there's a package that can do that for us - [`react-router-transition`](https://www.npmjs.com/package/react-router-transition):\n+\n+    $ yarn add react-router-transition\n+\n+And let's add the mising types for the library:\n+\n+{{{ diffStep 6.5 module=\"client\" files=\"react-app-env.d.ts\" }}}\n+\n+Using this package, we will create a custom `Switch` component that will play an animation for all its subordinate `Route` components.\n+The animation is defined by the user using a component called `AnimatedSwitch` as specified in the [package's docs page](http://maisano.github.io/react-router-transition/animated-switch/props).\n+So first, let's create our switch component that will play a smooth transition switching routes:\n+\n+{{{ diffStep 6.5 module=\"client\" files=\"AnimatedSwitch\" }}}\n+\n+And then replace it with the main `Switch` component in our app:\n+\n+{{{ diffStep 6.5 module=\"client\" files=\"App\" }}}\n+\n+Both components act identically and thus there shall be no special treatment. Behold the new transition effect:\n+\n+![transition-demo](https://user-images.githubusercontent.com/7648874/54739398-ebb22400-4bf2-11e9-8d4c-2aeb65deeb92.gif)\n+\n+The final screen will be composed out of 3 components:\n+\n+\n+\n+*   A navigation bar.\n+*   A messages list.\n+*   A message input.\n+\n+We will create a new directory under the path `public/assets` and inside we will download and place a couple of assets which are necessary for our view:\n+\n+*   [chat-background.jpg](https://raw.githubusercontent.com/Urigo/WhatsApp-Clone-Client-Angular/master/src/assets/chat-background.jpg)\n+*   [message-mine.png](https://raw.githubusercontent.com/Urigo/WhatsApp-Clone-Client-Angular/master/src/assets/message-mine.png)\n+\n+In the main `index.ts` file of the screen we will simply import all 3 in the right order.\n+We will start with the most simple one - the `ChatRoomNavbar`.\n+The navbar should show the picture of the chat we're currently at and its name,\n+along with a back button that will bring us back to the `ChatsListScreen`:\n+\n+{{{ diffStep 6.6 module=\"client\" files=\"ChatNavbar\" }}}\n+\n+Next, would be the `MesagesList` component, where we will see a scrollable list of all the messages of the active chat:\n+\n+{{{ diffStep 6.6 module=\"client\" files=\"MessagesList\" }}}\n+\n+And finally, would be the `MessageInput` component which will trigger an event whenever we type and submit a new message:\n+\n+{{{ diffStep 6.6 module=\"client\" files=\"MessageInput\" }}}\n+\n+Now that we have all 3 components, we will put them all together in the main `index.ts` file:\n+\n+{{{ diffStep 6.6 module=\"client\" files=\"index\" }}}\n+\n+The view is complete! However the `MessageInput` is not bound to our messages list.\n+We will use the triggered callback to update the chat state, whose changes should appear in the `MessagesList` component in the following render phase:\n+\n+{{{ diffStep 6.7 module=\"client\" }}}\n+\n+This is how the entire flow should look like:\n+\n+![flow-demo](https://user-images.githubusercontent.com/7648874/54739741-27012280-4bf4-11e9-97cb-c715482e2e70.gif)\n+\n+An edge case that should be taken care of is when the messages list length in the view exceeds the length of the container,\n+in which case we will have to scroll down to the bottom of the view.\n+This way we can keep track of the most recent message.\n+We will use `ReactDOM` to retrieve the native HTML element of the container and change the position of the scroller whenever a messages was sent:\n+\n+{{{ diffStep 6.8 module=\"client\" }}}\n+\n+Before we wrap things up, we should also test our components.\n+Since the new components have a direct control over the app's history,\n+we should also find a way to simulate it in our tests.\n+Because `react-dom-router` uses the [`history`](https://www.npmjs.com/package/history) package under the hood,\n+that means that we can use that package to inject a custom history object directly into the tested components:\n+\n+{{{ diffStep 6.9 module=\"client\" files=\"components\" }}}\n+\n+There are many things which are incomplete in the current implementation. The functionality exists in the UI, but no messages are really being sent and stored in the database. In the next chapters we will learn how to:\n+\n+\n+\n+*   Cache query results with Apollo-Client.\n+*   Send messages with GraphQL mutations\n+\n+--------\n+TODO: Add this to router chapter - https://www.pluralsight.com/guides/react-router-typescript\n+And this - https://stackoverflow.com/questions/49342390/typescript-how-to-add-type-check-for-history-object-in-react\n+\n+TODO: https://medium.com/@jrwebdev/react-higher-order-component-patterns-in-typescript-42278f7590fb\n+\n+TODO: https://www.cypress.io/blog/2019/05/13/code-create-react-app-v3-and-its-cypress-tests-using-typescript/#\n+\n+TODO: Schema says there’s always an array with messages, is it really true? Is newly created chat resolves an empty array, null will throw an error?\n+\n+TODO: Same thing with `chats: [Chat!]!`, do we always return an array here?\n+\n+TODO: _root and type all resolvers\n+\n+TODO: How to import schema together with jest, should I changed from ts-jest?\n+\n+TODO: remove all that part including the file in the commit\n+\n+TODO: Add all the new files and changes on 6.6\n+\n+TODO: Add all the new files and changes on 6.7\n\\ No newline at end of file\ndiff --git a/.tortilla/manuals/templates/step7.tmpl b/.tortilla/manuals/templates/step7.tmpl\nnew file mode 100644\nindex 0000000..2c24150\n--- /dev/null\n+++ b/.tortilla/manuals/templates/step7.tmpl\n@@ -0,0 +1,158 @@\n+In the previous step we've implemented a `ChatRoomScreen` where we were able to view each chat's messages list by clicking on a chat item from the main screen.\n+It all looks functional, however, there's a significant optimization issue - each time we navigate into a `ChatRoomScreen`,\n+we need to re-fetch the data related to the target chat.\n+\n+The solution for that would be [caching](https://en.wikipedia.org/wiki/Cache_(computing)) the fetch result,\n+so it can be re-used once we re-enter a screen that we've visited before.\n+For now things are fairly simple so the caching mechanism can be implemented manually,\n+but things are gonna get tougher when we add more queries or things like message sending and profile updating to the mix,\n+so it's not gonna be an easy task.\n+\n+Luckily, in the Apollo team they've invented a solution that works right out of the box and integrates perfectly with Apollo-GraphQL server - [Apollo-GraphQL client](https://www.apollographql.com/docs/link/#apollo-client).\n+\n+\n+![caching](https://user-images.githubusercontent.com/7648874/54871150-f505e100-4dea-11e9-9e2d-439fbf3eaebe.png)\n+\n+\n+\n+Apollo-Client is a wrap around our GraphQL endpoint which essentially uses HTTP requests (and further on [web-sockets](https://en.wikipedia.org/wiki/WebSocket), but we will get there), something that we've implemented manually so far.\n+Not only it can be used to fetch data, but it will also cache the result of the query so it can be seamlessly re-used when we request the same data.\n+This means that we will need to setup an Apollo-Client and replace all our `fetch()` calls with `client.query()` call.\n+More about Apollo-Client's API further in this tutorial, but let's start configuring it.\n+First we will install few essential NPM packages:\n+\n+    $ yarn add apollo-client apollo-cache-inmemory apollo-link apollo-link-http\n+\n+\n+\n+*   [`apollo-client`](https://www.npmjs.com/package/apollo-client) - Apollo-Client's core package, as we explained earlier.\n+*   [`apollo-cache-inmemory`](https://www.npmjs.com/package/apollo-cache-inmemory) - The data store that will be used to cache the results.\n+*   [`apollo-link-http`](https://www.npmjs.com/package/apollo-link-http) - Get GraphQL results over a network using HTTP fetch.\n+\n+We will create a new file in the `src` directory called `client.ts` and inside we will export the client:\n+\n+{{{ diffStep 7.1 module=\"client\" files=\"client\" }}}\n+\n+Although the client can be used directly and integrated into any UI framework, it would be the most comfortable to use a wrap around it which is suitable for React.\n+For that we will use a package called [`react-apollo-hooks`](https://www.npmjs.com/package/react-apollo-hooks) which includes a set of [React hooks](https://reactjs.org/docs/hooks-intro.html) that can connect between our Apollo-Client and target React.Component:\n+\n+    $ yarn add react-apollo-hooks graphql-tag graphql\n+\n+With `react-apollo-hooks` we can use the `useQuery()` hook to fetch data from our GraphQL API.\n+The `graphql-tag` package is used to parse the GraphQL string to an [AST](https://en.wikipedia.org/wiki/Abstract_syntax_tree), something which is required when using Apollo Client. Example:\n+\n+\n+```\n+import gql from 'graphql-tag';\n+import { useQuery } from 'react-apollo-hooks';\n+\n+const GET_DOGS = gql`\n+  {\n+    dogs {\n+      id\n+      breed\n+    }\n+  }\n+`;\n+\n+const Dogs = () => {\n+  const { data, error, loading } = useQuery(GET_DOGS);\n+  if (loading) {\n+    return <div>Loading...</div>;\n+  };\n+  if (error) {\n+    return <div>Error! {error.message}</div>;\n+  };\n+\n+  return (\n+    <ul>\n+      {data.dogs.map(dog => (\n+        <li key={dog.id}>{dog.breed}</li>\n+      ))}\n+    </ul>\n+  );\n+};\n+```\n+\n+\n+The package requires a small setup so that imported hooks can use our Apollo-Client:\n+\n+{{{ diffStep 7.2 module=\"client\" files=\"index\" }}}\n+\n+The code above uses the [Context/Provider](https://reactjs.org/docs/context.html) API, thus the client is now known globally.\n+Now that we can use the `useQuery()` hook, there's no need to use the native Fetch API anymore.\n+Let's replace all our Fetch API call instances with a React hook:\n+\n+{{{ diffStep 7.3 module=\"client\" files=\"components\" }}}\n+\n+You can see that we've fetched the query using Apollo client, and we removed the `setChat` call because Apollo will know automatically to place the results in the cache.\n+\n+And you can see we can also work directly with the cache.\n+\n+On the `OnSendMessage` function we take the new message and push it to Apollo Client's cache.\n+\n+Now if we'll scroll to another screen and come back, the messages will still be displayed there.\n+\n+You can see that we've added the `__typename` when we push a new chat to the cache.\n+That's how Apollo Client knows where to place the results.\n+\n+The replacement is finished. Note that we removed the usage of `useMemo()` - because Apollo has an internal cache mechanism, there's no need to memoize the result anymore.\n+We also used the [`writeQuery()`](https://www.apollographql.com/docs/react/features/caching.html#writequery-and-writefragment) method to edit the stored result in the cache, so in the next render phase we would have an updated chat with the newly added message.\n+\n+We shouldn't see any change at all in the view and the response time, since we're running it locally, but if we will take a look at the `network` tab in the browser's dev-tools we should notice the differences:\n+\n+**before**\n+\n+![fetch](https://user-images.githubusercontent.com/7648874/54871305-e5879780-4dec-11e9-87bb-3279e9e18342.png)\n+\n+**after**\n+\n+![apollo](https://user-images.githubusercontent.com/7648874/54871319-1bc51700-4ded-11e9-9001-d5518bedf9ad.png)\n+\n+> Above: ChatsListScreen -> ChatRoomScreen -> ChatsListScreen -> ChatRoomScreen\n+\n+This test is obviously very rough, but the deviation is so big that you don't need any accuracy to emphasize the difference.\n+The blue stripes represents the requests made and the time they took. Before we had about 6 request phases, while after we had only 3 of them.\n+\n+Since we don't use the Fetch API anymore, we will also need to update our tests.\n+Right now we mock the response from the fetch API, but a more appropriate way would be creating a fake Apollo Client where we will be able to mock the results.\n+For that we will install a package called [`apollo-link-mock`](https://www.npmjs.com/package/apollo-link-mock):\n+\n+    $ yarn add --dev apollo-link-mock\n+\n+And we will create a `test-helpers.ts` file under the `src` directory that will contain the utility function for creating a fake Apollo Client:\n+\n+{{{ diffStep 7.4 module=\"client\" files=\"test-helpers\" }}}\n+\n+The fake client accepts an array of mocks where each mock object will have a `request` key that will contain details about the request and a `result` key which will contain the mocked result.\n+You should get a better understanding of how it works now that we will replace the fake Fetch calls with fake Apollo Clients:\n+\n+{{{ diffStep 7.4 module=\"client\" files=\"src/components\" }}}\n+\n+We are telling Apollo mock to give a certain result each time it gets a specific query.\n+\n+Note how we used the `ApolloProvider` component to provide the target component with the fake Apollo Client.\n+Like so, any other component which uses Apollo Client should be wrapped with an ApolloProvider when rendering it, otherwise it will not function as intended:\n+\n+{{{ diffStep 7.4 module=\"client\" files=\"src/App\" }}}\n+\n+That's it for this chapter. There's one thing missing to make our `ChatRoomScreen` functional and that would be actually sending a message to the backend and updating the DB. In the next chapter we will learn how to do exactly that with our new Apollo-Client.\n+\n+\n+--------------------\n+\n+TODO: Change the whole intro.\n+\n+TODO: I think we might want to explain the cache in more details\n+how it’s normalized\n+how some parts update automatically and some do not\n+what’s the smallest unit stored in the cache\n+and other stuff\n+this might help later on with optimistic responses and mutations in general\n+\n+TODO: Remove all label code\n+\n+TODO: Create a drawing of the cache.\n+TODO: Change typename from Chat to Message\n+\n+TODO: Explain a bit about Apollo links.\n\\ No newline at end of file\ndiff --git a/.tortilla/manuals/templates/step8.tmpl b/.tortilla/manuals/templates/step8.tmpl\nnew file mode 100644\nindex 0000000..f3a2022\n--- /dev/null\n+++ b/.tortilla/manuals/templates/step8.tmpl\n@@ -0,0 +1,156 @@\n+The view and the functionality for updating the component's state when sending a message already exists.\n+The thing is that messages are not really being sent, we only update the memory in the client.\n+\n+If so, how exactly can we send messages and store them in the DB? For this purpose we're gonna learn about GraphQL mutations -\n+a method for sending and applying mutations in our back-end.\n+\n+**What are GraphQL mutations?**\n+\n+If you have an API endpoint that alters data, like inserting data into a database or altering data already in a database,\n+you should make this endpoint a `Mutation` rather than a `Query`.\n+This is as simple as making the API endpoint part of the top-level `Mutation` type instead of the top-level `Query` type.\n+\n+It's often convenient to have a mutation that maps to a database create or update operation, return the same thing that the server stored.\n+That way, if you modify the data on the server, the client can learn about those modifications.\n+**A GraphQL mutation is like a GraphQL query, only with side effects**.\n+It's equivalent to GET (query) and POST/PUT (mutation) in the context of REST API.\n+\n+Below is a sample GraphQL mutation request:\n+\n+```graphql\n+mutation AddMessage($chatId: ID!) {\n+  addMessage(chatId: $chatId) {\n+    id\n+    contents\n+    createdAt\n+  }\n+}\n+```\n+\n+**How to implement a GraphQL mutation?**\n+\n+Since GraphQL is schema based, we will need to create a new type called `Mutation` in the `typeDefs.graphql` file.\n+In this chapter we want to have the ability to send messages, thus we will have a field named `addMessage` in the new mutation type:\n+\n+{{{ diffStep 5.1 module=\"server\" files=\"typeDefs\" }}}\n+\n+Note that our mutation resolver `addMessage` receives a `chatId`. This is because when adding a message, we should update both the messages collection, and the correlated chat document. Mutations are resolved exactly like any other type in our resolvers manifest. The new resolver should look like this:\n+\n+{{{ diffStep 5.1 module=\"server\" files=\"resolvers\" }}}\n+\n+In terms of testing, we will use a temporary solution for now to reset the DB each time we test a mutation. Since we make a modification in the DB, we need to make sure that each test is completely agnostic and doesn't affect one another, thus, we will export a `resetDB()` method from our `db.ts` module:\n+\n+{{{ diffStep 5.2 module=\"server\" files=\"db.ts\" }}}\n+\n+And we will use the `beforeEach()` test hook to reset the `chats` and `messages` collections:\n+\n+{{{ diffStep 5.2 module=\"server\" files=\"tests\" }}}\n+\n+Now we have the infrastructure set for sending a new message and we can start using it in our client.\n+\n+**How to use a GraphQL mutation?**\n+\n+Like in the previous chapters, we're gonna use a React hook so we can run a mutation more efficiently in a React.Component.\n+For this we're gonna use the [`useMutation()`](https://github.com/trojanowski/react-apollo-hooks#usemutation) react hook.\n+The first argument of the hook is the mutation string, and the second one is the [mutation options](https://www.apollographql.com/docs/react/api/apollo-client.html#ApolloClient.mutate).\n+We're gonna provide our mutation call with a single option called `optimisticResponse`.\n+\n+Optimistic response is a common pattern that will update the state of the component twice so we can have a better UX: First it updates the component's state with the predicted result,\n+and then it will update the state with the actual result.\n+\n+\n+\n+![optimistic_response](https://user-images.githubusercontent.com/7648874/54883302-859df900-4e9f-11e9-9eb7-a98108cd2482.png)\n+\n+\n+This is how the component should look like:\n+\n+{{{ diffStep 8.1 module=\"client\" }}}\n+\n+Note that unlike `useQuery()`, `useMutation()` returns a callback that will run the mutation only once called, NOT immediately.\n+Seemingly, everything works fine, but if you'll try to navigate from `ChatsListScreen` to `ChatRoomScreen`, send a message, and then go back, you'll see that the last message was not updated.\n+So why is that exactly?\n+\n+**Cache updating**\n+\n+As explained in the previous chapter, Apollo-Client will cache all the results in a data-store.\n+Later on, rather than re-fetching the data, it will look up for the result in the store and will serve it to you in case it exists.\n+That means, that even though we ran the mutation and updated the data on the server, our data-store is still left behind and it needs to be updated as well,\n+otherwise Apollo-Client will see nothing wrong with the outcome.\n+\n+Apollo-Client stores the data in a hash, where the key represents the query and the value represents the retrieved result.\n+This means that the cache will need to be updated for:\n+\n+\n+*   `chats` query - which we already did, without really diving into the reason behind it.\n+*   `chat(chatId: $chatId)` where `chatId` is the chat that was just mutated.\n+\n+Indeed, a query will be duplicated for each and every distinct set of parameters.\n+So potentially our data-store can grow infinite amount of times, and we will need to take care of it and manage it correctly, so things won't get out of hand.\n+\n+To update a query, we will first export the `getChats` query to a separate file so it can be imported in the `ChatRoomScreen`.\n+We will define all our GraphQL assets under the `src/graphql` directory:\n+\n+{{{ diffStep 8.2 module=\"client\" files=\"graphql\" }}}\n+\n+And then we will read the memoized result from the store using [`client.readQuery`](https://www.apollographql.com/docs/react/features/caching.html#readquery),\n+update it, and then rewrite it using [`client.writeQuery`](https://www.apollographql.com/docs/react/features/caching.html#writequery-and-writefragment).\n+We can gain access to the client object via the `update` callback which will be triggered right after the mutation has been successfully executed.\n+This is how it should look like:\n+\n+{{{ diffStep 8.2 module=\"client\" files=\"components\" }}}\n+\n+Right now what happens is that we update a single chat document twice: Once for the `chats` query and another time for the `chat($chatId)` query.\n+This work is redundant and become more complex as we add more `chat` related queries.\n+To solve it, we can define and use a [GraphQL fragment](https://www.apollographql.com/docs/react/advanced/fragments.html).\n+\n+**Using Fragments**\n+\n+A GraphQL fragment is a shared piece of query logic.\n+\n+```graphql\n+fragment NameParts on Person {\n+  firstName\n+  lastName\n+}\n+\n+query GetPerson {\n+  people(id: \"7\") {\n+    ...NameParts\n+    avatar(size: LARGE)\n+  }\n+}\n+```\n+\n+It's important to note that the component after the `on` clause is designated for the type we are selecting from. In this case, `people` is of type `Person` and we want to select the `firstName` and `lastName` fields from `people(id: \"7\")`.\n+\n+Apollo maps the fragment ID to its retrieved data in the store. By default, Apollo will compose the fragment ID out of the entity type and the ID of the document. For example, for a `Chat` document with an ID of `7`, the fragment ID would be `Chat:7`. This behavior can be modified, but there's no need to.\n+\n+We will define the following fragments in our app:\n+\n+\n+\n+*   `Message` - represents a message\n+*   `Chat` - represents a chat, **without its messages list**.\n+*   `FullChat` - represents a chat, **including its messages list**.\n+\n+Once we define the fragments we can start embedding them in our queries. We will create a new directory path `src/graphql/fragments`, and inside we will create a dedicated fragment file for each fragment type: `message.fragment.ts`, `chat.fragment.ts` and `fullChat.fragment.ts`:\n+\n+{{{ diffStep 8.3 module=\"client\" files=\"graphql/fragments\" }}}\n+\n+And now that we have the fragments available to us, let's embed them in the relevant queries:\n+\n+{{{ diffStep 8.3 module=\"client\" files=\"components, graphql/queries\" }}}\n+\n+Similarly to query rewriting, we will use the [`readFragment()`](https://www.apollographql.com/docs/react/features/caching.html#readfragment) and [`writeFragment()`](https://www.apollographql.com/docs/react/features/caching.html#writefragment) methods in the same way to rewrite the fragments. When working with a fragment we need to compose its ID, just like explained earlier. The default mapping function called `defaultDataIdFromObject` can be imported from `apollo-cache-inmemory` and be used to specify the fragment that we would like to read/write. Accordingly, we're gonna replace all our query re-writings with fragments re-writings, as we don't need them anymore:\n+\n+{{{ diffStep 8.4 module=\"client\" }}}\n+\n+\n+----------\n+TODO: Isn’t `chats.splice(0, Infinity, ...[ … ])` the same as `chats = [...]` ?\n+I see an explanation of apollo-cache but it makes you feel it’s the fragment that’s being cached, which is not true, it’s the object type.\n+We shouldn’t use `defaultDataIdFromObject` directly from `apollo-cache-inmemory` but define it somewhere in our code and use that. It might change in the future and then we would have to do it in 500 files.\n+I would explain a lot more than it is now, about the caching. It should be based on a simpler example and show that when an entity `Foo:1` is modified, the change reflects in all component. We should describe how it’s stored, as references and not real data and so on.\n+\n+TODO: Better fragments naming and convensions\n\\ No newline at end of file\ndiff --git a/.tortilla/manuals/templates/step9.tmpl b/.tortilla/manuals/templates/step9.tmpl\nnew file mode 100644\nindex 0000000..4c87613\n--- /dev/null\n+++ b/.tortilla/manuals/templates/step9.tmpl\n@@ -0,0 +1,158 @@\n+So far we've been just writing code. If there was an error we would most likely discover it during runtime. As a reminder, we've created a project which is based on TypeScript, but we haven't really took any advantage of TypeScript's type safety mechanism. Currently, the TypeScript compiler is configured to work on loose mode, so any object which is not bound to any type will be converted to `any` - a type which is compatible with any type of casting and will ignore type errors.\n+\n+So far it's been very convenient because we've only started to learn about building an app and the ecosystem around it, but for a long term project it's would be very handy to take a full advantage of TypeScript and not let it go under the radar. So where exactly are we missing type checkings? In the core of our project - when dealing with GraphQL documents.\n+\n+When we run a query, or a mutation, we wanna make sure that we use the received data correctly, based on its intended shape and form. For example, given the following GraphQL query:\n+\n+```graphql\n+query Chats {\n+  chats {\n+    id\n+    name\n+    picture\n+  }\n+}\n+```\n+\n+We want to have the following TypeScript type:\n+\n+```ts\n+export type Chat = {\n+  __typename?: \"Chat\"\n+  id: string\n+  name: string\n+  picture: string\n+}\n+\n+export type ChatQuery = {\n+  __typename?: \"Query\"\n+  chats: Chats[]\n+}\n+\n+```\n+\n+So later on we can use it with `react-apollo-hooks` like so:\n+\n+```ts\n+useQuery<ChatsQuery>(getChatsQuery)\n+```\n+\n+Everything looks nice in theory, but the main issue that arises from having type definitions is that we need to maintain and sync 2 similar code bases:\n+A GraphQL schema and TypeScript type definitions.\n+Both are essentially the same, and if so, why do we even need to maintain 2 code bases?\n+Isn't there a tool which does that for us? A question which brings us straight to the point of the chapter.\n+\n+**Introducing: GraphQL Code Generator**\n+\n+With [GraphQL Code Generator](https://graphql-code-generator.com/) we can generate TypeScript definitions given a GraphQL schema, and a set of GraphQL documents if they are presented to us.\n+\n+\n+\n+![graphql-codegen](https://user-images.githubusercontent.com/7648874/54940897-9f564380-4f66-11e9-9891-3b994a1daef1.png)\n+\n+\n+GraphQL Code Generator is a simple CLI tool that operates based on a configuration file and can generate TypeScript types for both Client and Server.\n+We will start with generating types for the server.\n+\n+In the server project, install GraphQL Code Generator via Yarn\n+\n+    $ yarn add @graphql-codegen/cli --dev\n+\n+Now GraphQL Code Generator can be used directly from the `scripts` section in the `package.json` file using the `gql-gen` binary.\n+We're gonna call the code generation script \"codegen\":\n+\n+```json\n+{\n+  \"codegen\": \"gql-gen\"\n+}\n+```\n+\n+This command will automatically be referenced to a configuration file in the root of our project called `codegen.yml`.\n+The essence of this file is to provide the code generator with the GraphQL schema, GraphQL documents, the output path of the type definition file/s and a set of plug-ins.\n+More about the configuration file can be found in the [official website](https://graphql-code-generator.com/docs/getting-started/codegen-config).\n+\n+In the server project, we will generate the `types/graphql.d.ts` file and we will use a couple of plug-ins to do that:\n+\n+\n+\n+*   `@graphql-codegen/typescript` - Will generate the core TypeScript types from our GraphQL schema.\n+*   `@graphql-codegen/typescript-resolvers` - Will generate resolvers signatures with the generated TypeScript types.\n+\n+> A full list of available plugins is available [here](https://graphql-code-generator.com/docs/plugins/). In addition, you can write your own [custom plugin](https://graphql-code-generator.com/docs/custom-codegen/write-your-plugin).\n+\n+Let's install these 2 plugins:\n+\n+    $ yarn add @graphql-codegen/typescript @graphql-codegen/typescript-resolvers --dev\n+\n+And write the `codegen.yml` file:\n+\n+{{{ diffStep 6.1 module=\"server\" files=\"codegen.yml\" }}}\n+\n+> See inline comments to learn more about our configuration setup.\n+\n+Now if you'll run `$ npm run codegen` you should see that a new file `types/graphql.d.ts` has been generated with all the necessary TypeScript types. Since these types are very likely to change as we extend our schema, there's no need to include them in our project, thus it's recommended to add the appropriate .gitignore rule:\n+\n+{{{ diffStep 6.1 module=\"server\" files=\".gitignore\" }}}\n+\n+Now we can import the `IResolvers` type from the file we've just created and use it in the `resolvers.ts` file to ensure our resolvers handlers have the right signature:\n+\n+{{{ diffStep 6.2 module=\"server\" }}}\n+\n+We will now repeat the same process in the client with few tweaks. Again, we will install GraphQL Code Generator:\n+\n+    $ yarn add @graphql-codegen/cli --dev\n+\n+And we will define a script:\n+\n+```json\n+{\n+  \"codegen\": \"gql-gen\"\n+}\n+```\n+\n+This time around, because we're in the client, we will define a set of glob paths that will specify which files contain GraphQL documents.\n+GraphQL Code Generator is smart enough to automatically recognize the documents within these files by looking at the `gql` template literal calls using the `typescript-operations` package.\n+We will be using a plugin called `typescript-react-apollo` to generate React/Apollo-GraphQL hooks that can be used in our function components.\n+Let's install the necessary plugins:\n+\n+    $ yarn add @graphql-codegen/cli @graphql-codegen/typescript @graphql-codegen/typescript-operations @graphql-codegen/typescript-react-apollo @graphql-codegen/add\n+\n+\n+And we will write the `codegen.yml` file:\n+\n+{{{ diffStep 9.1 module=\"client\" files=\"codegen.yml\" }}}\n+\n+Notice that we sent the schema as a local path.\n+We could have also provided a GraphQL endpoint that exposes a GraphQL schema.\n+This way if there's an existing running GraphQL API, we can generate TypeScript types out of it, such as GitHub's GraphQL API.\n+The advantages of providing a local path is that the server doesn't have to be running in order to generate types, which is more comfortable in development, and we can bypass authentication if the endpoint is guarded with such mechanism.\n+This will be useful in further chapters when we're introduced to the concept of authentication.\n+\n+Be sure to add a .gitignore rule because we want to run the generator every time there is a change and don't want to rely on old generated types:\n+\n+{{{ diffStep 9.1 module=\"client\" files=\".gitignore\" }}}\n+\n+Now we have TypeScript types available to us and we can replace `useQuery()` and `useMutation()` calls with the generated React hooks.\n+Let's use those and also remove all the old manual typings:\n+\n+{{{ diffStep 9.2 module=\"client\" }}}\n+\n+To test if things are working properly, we can address a non existing field in one of the retrieved query results, for example `chat.foo` in `useGetChatQuery()`.\n+We should receive the following typing error when trying to run the project:\n+\n+```\n+TypeScript error: Property 'foo' does not exist on type '{ __typename?: \"Chat\"; } & { __typename?: \"Chat\"; } & { messages: ({ __typename?: \"Message\"; } & { __typename?: \"Message\"; } & Pick<Message, \"id\" | \"createdAt\" | \"content\">)[]; } & { __typename?: \"Chat\"; } & Pick<...> & { ...; }'.  TS2339\n+\n+    44 |   const addMessage = useAddMessageMutation()\n+    45 |\n+  > 46 |   console.log(chat.foo)\n+       |                    ^\n+    47 |\n+    48 |   const onSendMessage = useCallback((content) => {\n+    49 |     addMessage({\n+```\n+\n+TODO: Mappers are not explained - The root types of Message resolvers - doesn’t say much\n+we don’t need to use `resolvers as IResolvers`, there’s a flag for it, in codegen\n+\n+TODO: Change `gql-gen` to `graphql-codegen`\n\\ No newline at end of file\ndiff --git a/client/.env b/client/.env\nnew file mode 100644\nindex 0000000..f0fc5d5\n--- /dev/null\n+++ b/client/.env\n@@ -0,0 +1 @@\n+REACT_APP_SERVER_URL=http://localhost:4000\n\\ No newline at end of file\ndiff --git a/client/.gitignore b/client/.gitignore\nnew file mode 100644\nindex 0000000..31561ca\n--- /dev/null\n+++ b/client/.gitignore\n@@ -0,0 +1,25 @@\n+# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.\n+\n+# dependencies\n+/node_modules\n+/.pnp\n+.pnp.js\n+\n+# testing\n+/coverage\n+\n+# production\n+/build\n+\n+# misc\n+.DS_Store\n+.env.local\n+.env.development.local\n+.env.test.local\n+.env.production.local\n+\n+npm-debug.log*\n+yarn-debug.log*\n+yarn-error.log*\n+\n+src/graphql/types.tsx\ndiff --git a/client/.npmrc b/client/.npmrc\nnew file mode 100644\nindex 0000000..cffe8cd\n--- /dev/null\n+++ b/client/.npmrc\n@@ -0,0 +1 @@\n+save-exact=true\ndiff --git a/client/codegen.yml b/client/codegen.yml\nnew file mode 100644\nindex 0000000..7faedfa\n--- /dev/null\n+++ b/client/codegen.yml\n@@ -0,0 +1,21 @@\n+schema: ../Whatsapp-Clone-Server/schema/typeDefs.graphql\n+documents:\n+  - ./src/components/**/*.tsx\n+  - ./src/graphql/fragments/**/*.ts\n+  - ./src/graphql/queries/**/*.ts\n+  - ./src/graphql/subscriptions/**/*.ts\n+overwrite: true\n+generates:\n+  ./src/graphql/types.tsx:\n+    plugins:\n+      - add: '/* eslint-disable */'\n+      - typescript\n+      - typescript-operations\n+      - typescript-react-apollo\n+    # The combined options of all provided plug-ins\n+    # More information about the options below:\n+    # graphql-code-generator.com/docs/plugins/typescript-react-apollo#configuration\n+    config:\n+      withHOC: false\n+      withHooks: true\n+      withComponent: false\ndiff --git a/client/package.json b/client/package.json\nnew file mode 100644\nindex 0000000..f1093db\n--- /dev/null\n+++ b/client/package.json\n@@ -0,0 +1,70 @@\n+{\n+  \"name\": \"whatsapp-clone-client\",\n+  \"version\": \"0.1.0\",\n+  \"private\": true,\n+  \"dependencies\": {\n+    \"@graphql-codegen/add\": \"1.2.0\",\n+    \"@graphql-codegen/cli\": \"1.2.0\",\n+    \"@graphql-codegen/typescript\": \"1.2.0\",\n+    \"@graphql-codegen/typescript-operations\": \"1.2.0\",\n+    \"@graphql-codegen/typescript-react-apollo\": \"1.2.0\",\n+    \"@material-ui/core\": \"3.9.3\",\n+    \"@material-ui/icons\": \"3.0.2\",\n+    \"@types/history\": \"4.7.2\",\n+    \"@types/jest\": \"24.0.13\",\n+    \"@types/material-ui\": \"0.21.6\",\n+    \"@types/node\": \"12.0.1\",\n+    \"@types/react\": \"16.8.17\",\n+    \"@types/react-dom\": \"16.8.4\",\n+    \"@types/react-router-dom\": \"4.3.3\",\n+    \"@types/styled-components\": \"4.1.14\",\n+    \"apollo-cache-inmemory\": \"1.5.1\",\n+    \"apollo-client\": \"2.5.1\",\n+    \"apollo-link\": \"1.2.11\",\n+    \"apollo-link-http\": \"1.5.14\",\n+    \"apollo-link-mock\": \"1.0.1\",\n+    \"graphql\": \"14.3.1\",\n+    \"apollo-link-ws\": \"1.0.17\",\n+    \"apollo-utilities\": \"1.2.1\",\n+    \"graphql-tag\": \"2.10.1\",\n+    \"history\": \"4.9.0\",\n+    \"moment\": \"2.24.0\",\n+    \"react\": \"16.8.6\",\n+    \"react-apollo\": \"2.5.6\",\n+    \"react-apollo-hooks\": \"0.4.5\",\n+    \"react-dom\": \"16.8.6\",\n+    \"react-router-dom\": \"5.0.0\",\n+    \"react-router-transition\": \"1.3.0\",\n+    \"react-scripts\": \"3.0.1\",\n+    \"styled-components\": \"4.2.0\",\n+    \"subscriptions-transport-ws\": \"0.9.16\",\n+    \"typescript\": \"3.4.5\"\n+  },\n+  \"scripts\": {\n+    \"start\": \"react-scripts start\",\n+    \"build\": \"react-scripts build\",\n+    \"test\": \"react-scripts test\",\n+    \"eject\": \"react-scripts eject\",\n+    \"codegen\": \"gql-gen\"\n+  },\n+  \"eslintConfig\": {\n+    \"extends\": \"react-app\"\n+  },\n+  \"browserslist\": {\n+    \"production\": [\n+      \">0.2%\",\n+      \"not dead\",\n+      \"not op_mini all\"\n+    ],\n+    \"development\": [\n+      \"last 1 chrome version\",\n+      \"last 1 firefox version\",\n+      \"last 1 safari version\"\n+    ]\n+  },\n+  \"devDependencies\": {\n+    \"jest-dom\": \"3.2.1\",\n+    \"jest-fetch-mock\": \"2.1.2\",\n+    \"react-testing-library\": \"7.0.0\"\n+  }\n+}\ndiff --git a/client/public/chat-background.jpg b/client/public/chat-background.jpg\nnew file mode 100644\nindex 0000000..12cf45c\nBinary files /dev/null and b/client/public/chat-background.jpg differ\ndiff --git a/client/public/favicon.ico b/client/public/favicon.ico\nnew file mode 100644\nindex 0000000..a11777c\nBinary files /dev/null and b/client/public/favicon.ico differ\ndiff --git a/client/public/index.html b/client/public/index.html\nnew file mode 100644\nindex 0000000..7f991f8\n--- /dev/null\n+++ b/client/public/index.html\n@@ -0,0 +1,38 @@\n+<!DOCTYPE html>\n+<html lang=\"en\">\n+  <head>\n+    <meta charset=\"utf-8\" />\n+    <link rel=\"shortcut icon\" href=\"%PUBLIC_URL%/favicon.ico\" />\n+    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n+    <meta name=\"theme-color\" content=\"#000000\" />\n+    <!--\n+      manifest.json provides metadata used when your web app is installed on a\n+      user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/\n+    -->\n+    <link rel=\"manifest\" href=\"%PUBLIC_URL%/manifest.json\" />\n+    <!--\n+      Notice the use of %PUBLIC_URL% in the tags above.\n+      It will be replaced with the URL of the `public` folder during the build.\n+      Only files inside the `public` folder can be referenced from the HTML.\n+\n+      Unlike \"/favicon.ico\" or \"favicon.ico\", \"%PUBLIC_URL%/favicon.ico\" will\n+      work correctly both with client-side routing and a non-root public URL.\n+      Learn how to configure a non-root public URL by running `npm run build`.\n+    -->\n+    <title>WhatsApp Clone</title>\n+  </head>\n+  <body>\n+    <noscript>You need to enable JavaScript to run this app.</noscript>\n+    <div id=\"root\"></div>\n+    <!--\n+      This HTML file is a template.\n+      If you open it directly in the browser, you will see an empty page.\n+\n+      You can add webfonts, meta tags, or analytics to this file.\n+      The build step will place the bundled scripts into the <body> tag.\n+\n+      To begin the development, run `npm start` or `yarn start`.\n+      To create a production bundle, use `npm run build` or `yarn build`.\n+    -->\n+  </body>\n+</html>\ndiff --git a/client/public/manifest.json b/client/public/manifest.json\nnew file mode 100644\nindex 0000000..5696e11\n--- /dev/null\n+++ b/client/public/manifest.json\n@@ -0,0 +1,15 @@\n+{\n+  \"short_name\": \"WhatsApp Clone\",\n+  \"name\": \"An open source chat app\",\n+  \"icons\": [\n+    {\n+      \"src\": \"favicon.ico\",\n+      \"sizes\": \"64x64 32x32 24x24 16x16\",\n+      \"type\": \"image/x-icon\"\n+    }\n+  ],\n+  \"start_url\": \".\",\n+  \"display\": \"standalone\",\n+  \"theme_color\": \"#000000\",\n+  \"background_color\": \"#ffffff\"\n+}\ndiff --git a/client/public/message-mine.png b/client/public/message-mine.png\nnew file mode 100644\nindex 0000000..a5503eb\nBinary files /dev/null and b/client/public/message-mine.png differ\ndiff --git a/client/public/message-other.png b/client/public/message-other.png\nnew file mode 100644\nindex 0000000..a9477be\nBinary files /dev/null and b/client/public/message-other.png differ\ndiff --git a/client/public/whatsapp-icon.png b/client/public/whatsapp-icon.png\nnew file mode 100644\nindex 0000000..ef4c897\nBinary files /dev/null and b/client/public/whatsapp-icon.png differ\ndiff --git a/client/renovate.json b/client/renovate.json\nnew file mode 100644\nindex 0000000..a80069a\n--- /dev/null\n+++ b/client/renovate.json\n@@ -0,0 +1,23 @@\n+{\n+  \"extends\": [\"config:base\", \":rebaseStalePrs\"],\n+  \"baseBranches\": [\n+    \"master\",\n+    \"master-root\",\n+    \"master-step1\",\n+    \"master-step2\",\n+    \"master-step3\",\n+    \"master-step4\",\n+    \"master-step5\",\n+    \"master-step6\",\n+    \"master-step7\",\n+    \"master-step8\",\n+    \"master-step9\",\n+    \"master-step10\",\n+    \"master-step11\",\n+    \"master-step12\",\n+    \"master-step13\"\n+  ],\n+  \"prHourlyLimit\": 60,\n+  \"recreateClosed\": true,\n+  \"rangeStrategy\": \"lockfile-update\"\n+}\ndiff --git a/client/src/App.test.tsx b/client/src/App.test.tsx\nnew file mode 100644\nindex 0000000..c5d9cc9\n--- /dev/null\n+++ b/client/src/App.test.tsx\n@@ -0,0 +1,17 @@\n+import React from 'react';\n+import { ApolloProvider } from 'react-apollo-hooks';\n+import ReactDOM from 'react-dom';\n+import App from './App';\n+import { mockApolloClient } from './test-helpers';\n+\n+it('renders without crashing', () => {\n+  const client = mockApolloClient();\n+  const div = document.createElement('div');\n+\n+  ReactDOM.render(\n+    <ApolloProvider client={client}>\n+      <App />\n+    </ApolloProvider>\n+  , div);\n+  ReactDOM.unmountComponentAtNode(div);\n+});\ndiff --git a/client/src/App.tsx b/client/src/App.tsx\nnew file mode 100644\nindex 0000000..85131f7\n--- /dev/null\n+++ b/client/src/App.tsx\n@@ -0,0 +1,31 @@\n+import React from 'react';\n+import { BrowserRouter, Route, Redirect, RouteComponentProps } from 'react-router-dom';\n+import AuthScreen from './components/AuthScreen';\n+import ChatRoomScreen from './components/ChatRoomScreen';\n+import ChatsListScreen from './components/ChatsListScreen';\n+import ChatCreationScreen from './components/ChatCreationScreen';\n+import AnimatedSwitch from './components/AnimatedSwitch';\n+import { withAuth } from './services/auth.service';\n+\n+const App: React.FC = () => (\n+  <BrowserRouter>\n+    <AnimatedSwitch>\n+      <Route exact path=\"/sign-in\" component={AuthScreen} />\n+      <Route exact path=\"/chats\" component={withAuth(ChatsListScreen)} />\n+\n+      <Route exact path=\"/chats/:chatId\" component={withAuth(\n+        ({ match, history }: RouteComponentProps<{ chatId: string }>) =>\n+        (<ChatRoomScreen chatId={match.params.chatId} history={history} />)\n+      )} />\n+\n+      <Route exact path=\"/new-chat\" component={withAuth(ChatCreationScreen)} />\n+    </AnimatedSwitch>\n+    <Route exact path=\"/\" render={redirectToChats} />\n+  </BrowserRouter>\n+);\n+\n+const redirectToChats = () => (\n+  <Redirect to=\"/chats\" />\n+);\n+\n+export default App;\n\\ No newline at end of file\ndiff --git a/client/src/client.ts b/client/src/client.ts\nnew file mode 100644\nindex 0000000..8f5217f\n--- /dev/null\n+++ b/client/src/client.ts\n@@ -0,0 +1,43 @@\n+import { InMemoryCache } from 'apollo-cache-inmemory';\n+import { ApolloClient } from 'apollo-client';\n+import { getMainDefinition } from 'apollo-utilities';\n+import { HttpLink } from 'apollo-link-http';\n+import { WebSocketLink } from 'apollo-link-ws';\n+import { ApolloLink, split } from 'apollo-link';\n+\n+const httpUri = process.env.REACT_APP_SERVER_URL + '/graphql';\n+const wsUri = httpUri.replace(/^https?/, 'ws');\n+\n+const httpLink = new HttpLink({\n+  uri: httpUri,\n+  credentials: 'include',\n+});\n+\n+const wsLink = new WebSocketLink({\n+  uri: wsUri,\n+  options: {\n+    // Automatic reconnect in case of connection error\n+    reconnect: true,\n+  },\n+});\n+\n+const terminatingLink = split(\n+  ({ query }) => {\n+    const { kind, operation } = getMainDefinition(query);\n+    // If this is a subscription query, use wsLink, otherwise use httpLink\n+    return (\n+      kind === 'OperationDefinition' && operation === 'subscription'\n+    );\n+  },\n+  wsLink,\n+  httpLink,\n+);\n+\n+const link = ApolloLink.from([terminatingLink]);\n+\n+const inMemoryCache = new InMemoryCache();\n+\n+export default new ApolloClient({\n+  link,\n+  cache: inMemoryCache,\n+});\ndiff --git a/client/src/components/AnimatedSwitch.tsx b/client/src/components/AnimatedSwitch.tsx\nnew file mode 100644\nindex 0000000..c1f1cbc\n--- /dev/null\n+++ b/client/src/components/AnimatedSwitch.tsx\n@@ -0,0 +1,37 @@\n+import { Switch } from 'react-router-dom';\n+import { AnimatedSwitch, spring } from 'react-router-transition';\n+import styled from 'styled-components';\n+\n+// A workaround to make test pass\n+const SwitchComponent = process.env.NODE_ENV === 'test' ? Switch : AnimatedSwitch;\n+\n+const glide = (val: number) =>\n+  spring(val, {\n+    stiffness: 174,\n+    damping: 24,\n+  });\n+\n+const mapStyles = (styles :any) => ({\n+  transform: `translateX(${styles.offset}%)`,\n+});\n+\n+const MyAnimatedSwitch =  styled(SwitchComponent).attrs(() => ({\n+  atEnter: { offset: 100 },\n+  atLeave: { offset: glide(-100) },\n+  atActive: { offset: glide(0) },\n+  mapStyles,\n+}))`\n+  position: relative;\n+  overflow: hidden;\n+  height: 100vh;\n+  width: 100vw;\n+\n+  > div {\n+    position: absolute;\n+    overflow: hidden;\n+    height: 100vh;\n+    width: 100vw;\n+  }\n+`\n+\n+export default MyAnimatedSwitch;\ndiff --git a/client/src/components/AuthScreen/SignInForm.test.tsx b/client/src/components/AuthScreen/SignInForm.test.tsx\nnew file mode 100644\nindex 0000000..da27593\n--- /dev/null\n+++ b/client/src/components/AuthScreen/SignInForm.test.tsx\n@@ -0,0 +1,81 @@\n+import { createMemoryHistory } from 'history';\n+import React from 'react';\n+import { cleanup, render, fireEvent, wait, waitForElement } from 'react-testing-library';\n+import SignInForm from './SignInForm';\n+\n+describe('SignInForm', () => {\n+  afterEach(cleanup);\n+  afterEach(() => fetch.resetMocks());\n+\n+  it('enables sign-in button when filled in', async () => {\n+    const history = createMemoryHistory();\n+\n+    {\n+      const { container, getByTestId } = render(<SignInForm history={history} />);\n+      const usernameInput = getByTestId('username-input').querySelector('input');\n+      const passwordInput = getByTestId('password-input').querySelector('input');\n+      const signInButton = getByTestId('sign-in-button') as HTMLButtonElement;\n+\n+      expect(signInButton.disabled).toEqual(true);\n+\n+      fireEvent.change(usernameInput, { target: { value: 'username' } });\n+      fireEvent.change(passwordInput, { target: { value: 'password' } });\n+\n+      await waitForElement(() => usernameInput);\n+      await waitForElement(() => passwordInput);\n+\n+      expect(signInButton.disabled).toEqual(false);\n+    }\n+  });\n+\n+  it('prints server error if input was wrong', async () => {\n+    const history = createMemoryHistory();\n+\n+    fetchMock.mockRejectOnce(new Error('sign-in failed'));\n+\n+    {\n+      const { container, getByTestId } = render(<SignInForm history={history} />);\n+      const usernameInput = getByTestId('username-input').querySelector('input');\n+      const passwordInput = getByTestId('password-input').querySelector('input');\n+      const signInButton = getByTestId('sign-in-button') as HTMLButtonElement;\n+      const errorMessage = getByTestId('error-message');\n+\n+      fireEvent.change(usernameInput, { target: { value: 'username' } });\n+      fireEvent.change(passwordInput, { target: { value: 'password' } });\n+\n+      await waitForElement(() => usernameInput);\n+      await waitForElement(() => passwordInput);\n+\n+      fireEvent.click(signInButton);\n+\n+      await waitForElement(() => errorMessage);\n+\n+      expect(errorMessage.innerHTML).toEqual('sign-in failed');\n+    }\n+  });\n+\n+  it('navigates to /chats if everything went right', async () => {\n+    const history = createMemoryHistory();\n+\n+    fetchMock.mockResponseOnce('success');\n+\n+    {\n+      const { container, getByTestId } = render(<SignInForm history={history} />);\n+      const usernameInput = getByTestId('username-input').querySelector('input');\n+      const passwordInput = getByTestId('password-input').querySelector('input');\n+      const signInButton = getByTestId('sign-in-button') as HTMLButtonElement;\n+\n+      fireEvent.change(usernameInput, { target: { value: 'username' } });\n+      fireEvent.change(passwordInput, { target: { value: 'password' } });\n+\n+      await waitForElement(() => usernameInput);\n+      await waitForElement(() => passwordInput);\n+\n+      fireEvent.click(signInButton);\n+\n+      await wait(() =>\n+        expect(history.location.pathname).toEqual('/chats')\n+      );\n+    }\n+  });\n+});\ndiff --git a/client/src/components/AuthScreen/SignInForm.tsx b/client/src/components/AuthScreen/SignInForm.tsx\nnew file mode 100644\nindex 0000000..fa21d64\n--- /dev/null\n+++ b/client/src/components/AuthScreen/SignInForm.tsx\n@@ -0,0 +1,83 @@\n+import React from 'react';\n+import { useCallback, useState } from 'react';\n+import { signIn } from '../../services/auth.service';\n+import {\n+  SignForm,\n+  ActualForm,\n+  Legend,\n+  Section,\n+  TextField,\n+  Button,\n+  ErrorMessage,\n+} from './form-components';\n+import { RouteComponentProps } from 'react-router-dom';\n+\n+const SignInForm: React.FC<RouteComponentProps<any>> = ({ history }) => {\n+  const [username, setUsername] = useState('');\n+  const [password, setPassword] = useState('');\n+  const [error, setError] = useState('');\n+\n+  const onUsernameChange = useCallback(({ target }) => {\n+    setError('');\n+    setUsername(target.value);\n+  }, []);\n+\n+  const onPasswordChange = useCallback(({ target }) => {\n+    setError('');\n+    setPassword(target.value);\n+  }, []);\n+\n+  const maySignIn = useCallback(() => {\n+    return !!(username && password);\n+  }, [username, password]);\n+\n+  const handleSignIn = useCallback(() => {\n+    signIn({ username, password })\n+      .then(() => {\n+        history.replace('/chats')\n+      })\n+      .catch(error => {\n+        setError(error.message || error)\n+      });\n+  }, [username, password, history]);\n+\n+  return (\n+    <SignForm>\n+      <ActualForm>\n+        <Legend>Sign in</Legend>\n+        <Section style={{ width: '100%' }}>\n+          <TextField\n+            data-testid=\"username-input\"\n+            label=\"Username\"\n+            value={username}\n+            onChange={onUsernameChange}\n+            margin=\"normal\"\n+            placeholder=\"Enter your username\"\n+          />\n+          <TextField\n+            data-testid=\"password-input\"\n+            label=\"Password\"\n+            type=\"password\"\n+            value={password}\n+            onChange={onPasswordChange}\n+            margin=\"normal\"\n+            placeholder=\"Enter your password\"\n+          />\n+        </Section>\n+        <Button\n+          data-testid=\"sign-in-button\"\n+          type=\"button\"\n+          color=\"secondary\"\n+          variant=\"contained\"\n+          disabled={!maySignIn()}\n+          onClick={handleSignIn}\n+        >\n+          Sign in\n+        </Button>\n+        <ErrorMessage data-testid=\"error-message\">{error}</ErrorMessage>\n+      </ActualForm>\n+    </SignForm>\n+  );\n+};\n+\n+export default SignInForm;\ndiff --git a/client/src/components/AuthScreen/SignUpForm.test.tsx b/client/src/components/AuthScreen/SignUpForm.test.tsx\nnew file mode 100644\nindex 0000000..669e45d\n--- /dev/null\n+++ b/client/src/components/AuthScreen/SignUpForm.test.tsx\n@@ -0,0 +1,99 @@\n+import { createMemoryHistory } from 'history';\n+import React from 'react';\n+import { cleanup, render, fireEvent, wait, waitForElement } from 'react-testing-library';\n+import SignUpForm from './SignUpForm';\n+\n+describe('SignUpForm', () => {\n+  afterEach(cleanup);\n+  afterEach(() => fetch.resetMocks());\n+\n+  it('enables sign-up button when filled in', async () => {\n+    const history = createMemoryHistory();\n+\n+    {\n+      const { container, getByTestId } = render(<SignUpForm history={history} />);\n+      const nameInput = getByTestId('name-input').querySelector('input');\n+      const usernameInput = getByTestId('username-input').querySelector('input');\n+      const passwordInput = getByTestId('password-input').querySelector('input');\n+      const passwordConfirmInput = getByTestId('password-confirm-input').querySelector('input');\n+      const signUpButton = getByTestId('sign-up-button') as HTMLButtonElement;\n+\n+      expect(signUpButton.disabled).toEqual(true);\n+\n+      fireEvent.change(nameInput, { target: { value: 'User Name' } });\n+      fireEvent.change(usernameInput, { target: { value: 'username' } });\n+      fireEvent.change(passwordInput, { target: { value: 'password' } });\n+      fireEvent.change(passwordConfirmInput, { target: { value: 'password' } });\n+\n+      await waitForElement(() => nameInput);\n+      await waitForElement(() => usernameInput);\n+      await waitForElement(() => passwordInput);\n+      await waitForElement(() => passwordConfirmInput);\n+\n+      expect(signUpButton.disabled).toEqual(false);\n+    }\n+  });\n+\n+  it('prints server error if input was wrong', async () => {\n+    const history = createMemoryHistory();\n+\n+    fetchMock.mockRejectOnce(new Error('sign-up failed'));\n+\n+    {\n+      const { container, getByTestId } = render(<SignUpForm history={history} />);\n+      const nameInput = getByTestId('name-input').querySelector('input');\n+      const usernameInput = getByTestId('username-input').querySelector('input');\n+      const passwordInput = getByTestId('password-input').querySelector('input');\n+      const passwordConfirmInput = getByTestId('password-confirm-input').querySelector('input');\n+      const signUpButton = getByTestId('sign-up-button') as HTMLButtonElement;\n+      const errorMessage = getByTestId('error-message');\n+\n+      fireEvent.change(nameInput, { target: { value: 'User Name' } });\n+      fireEvent.change(usernameInput, { target: { value: 'username' } });\n+      fireEvent.change(passwordInput, { target: { value: 'password' } });\n+      fireEvent.change(passwordConfirmInput, { target: { value: 'password' } });\n+\n+      await waitForElement(() => nameInput);\n+      await waitForElement(() => usernameInput);\n+      await waitForElement(() => passwordInput);\n+      await waitForElement(() => passwordConfirmInput);\n+\n+      fireEvent.click(signUpButton);\n+\n+      await waitForElement(() => errorMessage);\n+\n+      expect(errorMessage.innerHTML).toEqual('sign-up failed');\n+    }\n+  });\n+\n+  it('navigates to /sign-in if everything went right', async () => {\n+    const history = createMemoryHistory();\n+\n+    fetchMock.mockResponseOnce('success');\n+\n+    {\n+      const { container, getByTestId } = render(<SignUpForm history={history} />);\n+      const nameInput = getByTestId('name-input').querySelector('input');\n+      const usernameInput = getByTestId('username-input').querySelector('input');\n+      const passwordInput = getByTestId('password-input').querySelector('input');\n+      const passwordConfirmInput = getByTestId('password-confirm-input').querySelector('input');\n+      const signUpButton = getByTestId('sign-up-button') as HTMLButtonElement;\n+\n+      fireEvent.change(nameInput, { target: { value: 'User Name' } });\n+      fireEvent.change(usernameInput, { target: { value: 'username' } });\n+      fireEvent.change(passwordInput, { target: { value: 'password' } });\n+      fireEvent.change(passwordConfirmInput, { target: { value: 'password' } });\n+\n+      await waitForElement(() => nameInput);\n+      await waitForElement(() => usernameInput);\n+      await waitForElement(() => passwordInput);\n+      await waitForElement(() => passwordConfirmInput);\n+\n+      fireEvent.click(signUpButton);\n+\n+      await wait(() =>\n+        expect(history.location.pathname).toEqual('/sign-in')\n+      );\n+    }\n+  });\n+});\ndiff --git a/client/src/components/AuthScreen/SignUpForm.tsx b/client/src/components/AuthScreen/SignUpForm.tsx\nnew file mode 100644\nindex 0000000..b7fcd69\n--- /dev/null\n+++ b/client/src/components/AuthScreen/SignUpForm.tsx\n@@ -0,0 +1,126 @@\n+import React from 'react';\n+import { useCallback, useState } from 'react';\n+import { signUp } from '../../services/auth.service';\n+import {\n+  SignForm,\n+  ActualForm,\n+  Legend,\n+  Section,\n+  TextField,\n+  Button,\n+  ErrorMessage,\n+} from './form-components';\n+import { RouteComponentProps } from 'react-router-dom';\n+\n+const SignUpForm: React.FC<RouteComponentProps<any>> = ({ history }) => {\n+  const [name, setName] = useState('');\n+  const [username, setUsername] = useState('');\n+  const [password, setPassword] = useState('');\n+  const [passwordConfirm, setPasswordConfirm] = useState('');\n+  const [error, setError] = useState('');\n+\n+  const updateName = useCallback(({ target }) => {\n+    setError('');\n+    setName(target.value);\n+  }, []);\n+\n+  const updateUsername = useCallback(({ target }) => {\n+    setError('');\n+    setUsername(target.value);\n+  }, []);\n+\n+  const updatePassword = useCallback(({ target }) => {\n+    setError('');\n+    setPassword(target.value);\n+  }, []);\n+\n+  const updatePasswordConfirm = useCallback(({ target }) => {\n+    setError('');\n+    setPasswordConfirm(target.value);\n+  }, []);\n+\n+  const maySignUp = useCallback(() => {\n+    return !!(name && username && password && password === passwordConfirm);\n+  }, [name, username, password, passwordConfirm]);\n+\n+  const handleSignUp = useCallback(() => {\n+    signUp({ username, password, passwordConfirm, name })\n+      .then(() => {\n+        history.replace('/sign-in')\n+      })\n+      .catch(error => {\n+        setError(error.message || error)\n+      });\n+  }, [name, username, password, passwordConfirm, history]);\n+\n+  return (\n+    <SignForm>\n+      <ActualForm>\n+        <Legend>Sign up</Legend>\n+        <Section\n+          style={{\n+            float: 'left',\n+            width: 'calc(50% - 10px)',\n+            paddingRight: '10px',\n+          }}\n+        >\n+          <TextField\n+            data-testid=\"name-input\"\n+            label=\"Name\"\n+            value={name}\n+            onChange={updateName}\n+            autoComplete=\"off\"\n+            margin=\"normal\"\n+          />\n+          <TextField\n+            data-testid=\"username-input\"\n+            label=\"Username\"\n+            value={username}\n+            onChange={updateUsername}\n+            autoComplete=\"off\"\n+            margin=\"normal\"\n+          />\n+        </Section>\n+        <Section\n+          style={{\n+            float: 'right',\n+            width: 'calc(50% - 10px)',\n+            paddingLeft: '10px',\n+          }}\n+        >\n+          <TextField\n+            data-testid=\"password-input\"\n+            label=\"Password\"\n+            type=\"password\"\n+            value={password}\n+            onChange={updatePassword}\n+            autoComplete=\"off\"\n+            margin=\"normal\"\n+          />\n+          <TextField\n+            data-testid=\"password-confirm-input\"\n+            label=\"Confirm password\"\n+            type=\"password\"\n+            value={passwordConfirm}\n+            onChange={updatePasswordConfirm}\n+            autoComplete=\"off\"\n+            margin=\"normal\"\n+          />\n+        </Section>\n+        <Button\n+          data-testid=\"sign-up-button\"\n+          type=\"button\"\n+          color=\"secondary\"\n+          variant=\"contained\"\n+          disabled={!maySignUp()}\n+          onClick={handleSignUp}\n+        >\n+          Sign up\n+        </Button>\n+        <ErrorMessage data-testid=\"error-message\">{error}</ErrorMessage>\n+      </ActualForm>\n+    </SignForm>\n+  );\n+};\n+\n+export default SignUpForm;\n\\ No newline at end of file\ndiff --git a/client/src/components/AuthScreen/form-components.ts b/client/src/components/AuthScreen/form-components.ts\nnew file mode 100644\nindex 0000000..00c8c9d\n--- /dev/null\n+++ b/client/src/components/AuthScreen/form-components.ts\n@@ -0,0 +1,75 @@\n+import MaterialButton from '@material-ui/core/Button';\n+import MaterialTextField from '@material-ui/core/TextField';\n+import styled from 'styled-components';\n+\n+export const SignForm = styled.div `\n+  height: calc(100% - 265px);\n+`;\n+\n+export const ActualForm = styled.form `\n+  padding: 20px;\n+`;\n+\n+export const Section = styled.div `\n+  padding-bottom: 35px;\n+`;\n+\n+export const Legend = styled.legend `\n+  font-weight: bold;\n+  color: white;\n+`;\n+\n+export const Label = styled.label `\n+  color: white !important;\n+`;\n+\n+export const Input = styled.input `\n+  color: white;\n+\n+  &::placeholder {\n+    color: var(--primary-bg);\n+  }\n+`;\n+\n+export const TextField = styled(MaterialTextField) `\n+  width: 100%;\n+  position: relative;\n+\n+  > div::before {\n+    border-color: white !important;\n+  }\n+\n+  input {\n+    color: white !important;\n+\n+    &::placeholder {\n+      color: var(--primary-bg) !important;\n+    }\n+  }\n+\n+  label {\n+    color: white !important;\n+  }\n+` as typeof MaterialTextField;\n+\n+export const Button = styled(MaterialButton) `\n+  width: 100px;\n+  display: block !important;\n+  margin: auto !important;\n+  background-color: var(--secondary-bg) !important;\n+\n+  &[disabled] {\n+    color: #38a81c;\n+  }\n+\n+  &:not([disabled]) {\n+    color: white;\n+  }\n+` as typeof MaterialButton;\n+\n+export const ErrorMessage = styled.div `\n+  position: fixed;\n+  color: red;\n+  font-size: 15px;\n+  margin-top: 20px;\n+`;\ndiff --git a/client/src/components/AuthScreen/index.tsx b/client/src/components/AuthScreen/index.tsx\nnew file mode 100644\nindex 0000000..c6cdfe0\n--- /dev/null\n+++ b/client/src/components/AuthScreen/index.tsx\n@@ -0,0 +1,89 @@\n+import React from 'react';\n+import { useMemo } from 'react';\n+import { Route } from 'react-router-dom';\n+import styled from 'styled-components';\n+import AnimatedSwitch from '../AnimatedSwitch';\n+import SignInForm from './SignInForm';\n+import SignUpForm from './SignUpForm';\n+import { RouteComponentProps } from 'react-router-dom';\n+\n+const Container = styled.div `\n+  background: radial-gradient(rgb(34, 65, 67), rgb(17, 48, 50)),\n+    url(/assets/chat-background.jpg) no-repeat;\n+  background-size: cover;\n+  background-blend-mode: multiply;\n+  color: white;\n+`;\n+\n+const Intro = styled.div `\n+  height: 265px;\n+`;\n+\n+const Icon = styled.img `\n+  width: 125px;\n+  height: auto;\n+  margin-left: auto;\n+  margin-right: auto;\n+  padding-top: 70px;\n+  display: block;\n+`;\n+\n+const Title = styled.h2 `\n+  width: 100%;\n+  text-align: center;\n+  color: white;\n+`;\n+\n+// eslint-disable-next-line\n+const Alternative = styled.div `\n+  position: fixed;\n+  bottom: 10px;\n+  left: 10px;\n+\n+  label {\n+    color: var(--secondary-bg);\n+  }\n+`;\n+\n+const AuthScreen: React.FC<RouteComponentProps<any>> = ({ history, location }) => {\n+  const alternative = useMemo(() => {\n+    if (location.pathname === '/sign-in') {\n+      const handleSignUp = () => {\n+        history.replace('/sign-up');\n+      };\n+\n+      return (\n+        <Alternative>\n+          Don't have an account yet? <label onClick={handleSignUp}>Sign up!</label>\n+        </Alternative>\n+      );\n+    }\n+    else {\n+      const handleSignIn = () => {\n+        history.replace('/sign-in');\n+      };\n+\n+      return (\n+        <Alternative>\n+          Already have an accout? <label onClick={handleSignIn}>Sign in!</label>\n+        </Alternative>\n+      );\n+    }\n+  }, [location.pathname, history]);\n+\n+  return (\n+    <Container className=\"AuthScreen Screen\">\n+      <Intro className=\"AuthScreen-intro\">\n+        <Icon src=\"assets/whatsapp-icon.png\" className=\"AuthScreen-icon\" />\n+        <Title className=\"AuthScreen-title\">WhatsApp</Title>\n+      </Intro>\n+      <AnimatedSwitch>\n+        <Route exact path=\"/sign-in\" component={SignInForm} />\n+        <Route exact path=\"/sign-up\" component={SignUpForm} />\n+      </AnimatedSwitch>\n+      {alternative}\n+    </Container>\n+  );\n+};\n+\n+export default AuthScreen;\n\\ No newline at end of file\ndiff --git a/client/src/components/ChatCreationScreen/ChatCreationNavbar.test.tsx b/client/src/components/ChatCreationScreen/ChatCreationNavbar.test.tsx\nnew file mode 100644\nindex 0000000..0454ed0\n--- /dev/null\n+++ b/client/src/components/ChatCreationScreen/ChatCreationNavbar.test.tsx\n@@ -0,0 +1,28 @@\n+import { createMemoryHistory } from 'history';\n+import React from 'react';\n+import { cleanup, render, fireEvent, wait } from 'react-testing-library';\n+import ChatCreationNavbar from './ChatCreationNavbar';\n+\n+describe('ChatCreationNavbar', () => {\n+  afterEach(cleanup);\n+\n+  it('goes back on arrow click', async () => {\n+    const history = createMemoryHistory();\n+\n+    history.push('/new-chat');\n+\n+    await wait(() =>\n+      expect(history.location.pathname).toEqual('/new-chat')\n+    );\n+\n+    {\n+      const { container, getByTestId } = render(<ChatCreationNavbar history={history} />);\n+\n+      fireEvent.click(getByTestId('back-button'));\n+\n+      await wait(() =>\n+        expect(history.location.pathname).toEqual('/chats')\n+      );\n+    }\n+  });\n+});\ndiff --git a/client/src/components/ChatCreationScreen/ChatCreationNavbar.tsx b/client/src/components/ChatCreationScreen/ChatCreationNavbar.tsx\nnew file mode 100644\nindex 0000000..c537475\n--- /dev/null\n+++ b/client/src/components/ChatCreationScreen/ChatCreationNavbar.tsx\n@@ -0,0 +1,46 @@\n+import ArrowBackIcon from '@material-ui/icons/ArrowBack';\n+import { Toolbar, Button } from '@material-ui/core';\n+import React from 'react';\n+import { useCallback } from 'react';\n+import styled from 'styled-components';\n+import { History } from 'history';\n+\n+const Container = styled(Toolbar) `\n+  display: flex;\n+  background-color: var(--primary-bg);\n+  color: var(--primary-text);\n+  font-size: 20px;\n+  line-height: 40px;\n+` as typeof Toolbar;\n+\n+const BackButton = styled(Button) `\n+  svg {\n+    color: var(--primary-text);\n+  }\n+` as typeof Button;\n+\n+const Title = styled.div `\n+  flex: 1;\n+`;\n+\n+interface ChildComponentProps {\n+  history: History;\n+};\n+\n+const ChatCreationNavbar: React.FC<ChildComponentProps> = ({ history }) => {\n+  const navBack = useCallback(() => {\n+    history.replace('/chats');\n+  }, [history]);\n+\n+  return (\n+    <Container>\n+      <BackButton data-testid=\"back-button\" onClick={navBack}>\n+        <ArrowBackIcon />\n+      </BackButton>\n+      <Title>Create Chat</Title>\n+    </Container>\n+  );\n+};\n+\n+\n+export default ChatCreationNavbar;\ndiff --git a/client/src/components/ChatCreationScreen/index.tsx b/client/src/components/ChatCreationScreen/index.tsx\nnew file mode 100644\nindex 0000000..70f8a5a\n--- /dev/null\n+++ b/client/src/components/ChatCreationScreen/index.tsx\n@@ -0,0 +1,73 @@\n+import gql from 'graphql-tag';\n+import React from 'react';\n+import { useCallback } from 'react';\n+import styled from 'styled-components';\n+import * as fragments from '../../graphql/fragments';\n+import UsersList from '../UsersList';\n+import ChatCreationNavbar from './ChatCreationNavbar';\n+import { History } from 'history';\n+import { useAddChatMutation } from '../../graphql/types';\n+import { writeChat } from '../../services/cache.service';\n+\n+// eslint-disable-next-line\n+const Container = styled.div `\n+  height: calc(100% - 56px);\n+  overflow-y: overlay;\n+`;\n+\n+// eslint-disable-next-line\n+const StyledUsersList = styled(UsersList) `\n+  height: calc(100% - 56px);\n+`;\n+\n+gql`\n+  mutation AddChat($recipientId: ID!) {\n+    addChat(recipientId: $recipientId) {\n+      ...Chat\n+    }\n+  }\n+  ${fragments.chat}\n+`;\n+\n+interface ChildComponentProps {\n+  history: History;\n+};\n+\n+const ChatCreationScreen: React.FC<ChildComponentProps> = ({ history }) => {\n+  const addChat = useAddChatMutation({\n+    update: (client, { data: { addChat } }) => {\n+      writeChat(client, addChat);\n+    }\n+  });\n+\n+  const onUserPick = useCallback((user) => {\n+    addChat({\n+      optimisticResponse: {\n+        __typename: 'Mutation',\n+        addChat: {\n+          __typename: 'Chat',\n+          id: Math.random().toString(36).substr(2, 9),\n+          name: user.name,\n+          picture: user.picture,\n+          lastMessage: null,\n+        },\n+      },\n+      variables: {\n+        recipientId: user.id,\n+      },\n+    }).then(({ data }) => {\n+      if (data !== null) {\n+        history.push(`/chats/${data.addChat.id}`);\n+      }\n+    })\n+  }, [addChat, history]);\n+\n+  return (\n+    <div>\n+      <ChatCreationNavbar history={history} />\n+      <UsersList onUserPick={onUserPick} />\n+    </div>\n+  );\n+};\n+\n+export default ChatCreationScreen;\ndiff --git a/client/src/components/ChatRoomScreen/ChatNavbar.test.tsx b/client/src/components/ChatRoomScreen/ChatNavbar.test.tsx\nnew file mode 100644\nindex 0000000..9c61f69\n--- /dev/null\n+++ b/client/src/components/ChatRoomScreen/ChatNavbar.test.tsx\n@@ -0,0 +1,108 @@\n+import { createMemoryHistory } from 'history';\n+import React from 'react';\n+import { ApolloProvider } from 'react-apollo-hooks';\n+import { cleanup, render, fireEvent, wait } from 'react-testing-library';\n+import { mockApolloClient } from '../../test-helpers';\n+import ChatNavbar from './ChatNavbar';\n+import { RemoveChatDocument } from '../../graphql/types';\n+\n+describe('ChatNavbar', () => {\n+  afterEach(cleanup);\n+\n+  it('renders chat data', () => {\n+    const client = mockApolloClient();\n+\n+    const chat = {\n+      id: '1',\n+      name: 'Foo Bar',\n+      picture: 'https://localhost:4000/picture.jpg',\n+    };\n+\n+    {\n+      const { container, getByTestId } = render(\n+        <ApolloProvider client={client}>\n+          <ChatNavbar chat={chat} />\n+        </ApolloProvider>\n+      );\n+\n+      expect(getByTestId('chat-name')).toHaveTextContent('Foo Bar');\n+      expect(getByTestId('chat-picture')).toHaveAttribute('src', 'https://localhost:4000/picture.jpg');\n+    }\n+  })\n+\n+  it('goes back on arrow click', async () => {\n+    const client = mockApolloClient();\n+\n+    const chat = {\n+      id: '1',\n+      name: 'Foo Bar',\n+      picture: 'https://localhost:4000/picture.jpg',\n+    };\n+\n+    const history = createMemoryHistory();\n+\n+    history.push('/chats/1');\n+\n+    await wait(() =>\n+      expect(history.location.pathname).toEqual('/chats/1')\n+    )\n+\n+    {\n+      const { container, getByTestId } = render(\n+        <ApolloProvider client={client}>\n+          <ChatNavbar chat={chat} history={history} />\n+        </ApolloProvider>\n+      );\n+\n+      fireEvent.click(getByTestId('back-button'));\n+\n+      await wait(() =>\n+        expect(history.location.pathname).toEqual('/chats')\n+      );\n+    }\n+  });\n+\n+  it('goes back on chat removal', async () => {\n+    const client = mockApolloClient([\n+      {\n+        request: {\n+          query: RemoveChatDocument,\n+          variables: { chatId: '1' },\n+        },\n+        result: {\n+          data: {\n+            removeChat: '1'\n+          }\n+        }\n+      },\n+    ]);\n+\n+    const chat = {\n+      id: '1',\n+      name: 'Foo Bar',\n+      picture: 'https://localhost:4000/picture.jpg',\n+    };\n+\n+    const history = createMemoryHistory();\n+\n+    history.push('/chats/1');\n+\n+    await wait(() =>\n+      expect(history.location.pathname).toEqual('/chats/1')\n+    );\n+\n+    {\n+      const { container, getByTestId } = render(\n+        <ApolloProvider client={client}>\n+          <ChatNavbar chat={chat} history={history} />\n+        </ApolloProvider>\n+      );\n+\n+      fireEvent.click(getByTestId('delete-button'));\n+\n+      await wait(() =>\n+        expect(history.location.pathname).toEqual('/chats')\n+      );\n+    }\n+  })\n+});\n\\ No newline at end of file\ndiff --git a/client/src/components/ChatRoomScreen/ChatNavbar.tsx b/client/src/components/ChatRoomScreen/ChatNavbar.tsx\nnew file mode 100644\nindex 0000000..92f06ab\n--- /dev/null\n+++ b/client/src/components/ChatRoomScreen/ChatNavbar.tsx\n@@ -0,0 +1,106 @@\n+import Button from '@material-ui/core/Button';\n+import Toolbar from '@material-ui/core/Toolbar';\n+import ArrowBackIcon from '@material-ui/icons/ArrowBack';\n+import DeleteIcon from '@material-ui/icons/Delete';\n+import gql from 'graphql-tag';\n+import React from 'react';\n+import { useCallback } from 'react';\n+import styled from 'styled-components';\n+import { History } from 'history';\n+import { useRemoveChatMutation } from '../../graphql/types';\n+import { eraseChat } from '../../services/cache.service';\n+\n+const Container = styled(Toolbar) `\n+  padding: 0;\n+  display: flex;\n+  flex-direction: row;\n+  background-color: var(--primary-bg);\n+  color: var(--primary-text);\n+` as typeof Toolbar;\n+\n+const BackButton = styled(Button) `\n+  svg {\n+    color: var(--primary-text);\n+  }\n+` as typeof Button;\n+\n+const Rest = styled.div `\n+  flex: 1;\n+  display: flex;\n+  justify-content: flex-end;\n+`\n+\n+const Picture = styled.img `\n+  height: 40px;\n+  width: 40px;\n+  margin-top: 3px;\n+  margin-left: -22px;\n+  object-fit: cover;\n+  padding: 5px;\n+  border-radius: 50%;\n+`;\n+\n+const Name = styled.div `\n+  line-height: 56px;\n+`;\n+\n+const DeleteButton = styled(Button)`\n+  color: var(--primary-text) !important;\n+` as typeof Button;\n+\n+export const removeChatMutation = gql`\n+  mutation RemoveChat($chatId: ID!) {\n+    removeChat(chatId: $chatId)\n+  }\n+`;\n+\n+interface ChatNavbarProps {\n+  history: History;\n+  chat: {\n+    picture?: string | null;\n+    name?: string | null;\n+    id: string;\n+  };\n+};\n+\n+const ChatNavbar: React.FC<ChatNavbarProps> = ({ chat, history }) => {\n+  const removeChat = useRemoveChatMutation({\n+    variables: {\n+      chatId: chat.id\n+    },\n+    update: (client, { data: { removeChat } }) => {\n+      eraseChat(client, removeChat);\n+    }\n+  });\n+\n+  const handleRemoveChat = useCallback(() => {\n+    removeChat().then(() => {\n+      history.replace('/chats')\n+    });\n+  }, [removeChat, history]);\n+\n+  const navBack = useCallback(() => {\n+    history.replace('/chats');\n+  }, [history]);\n+\n+  return (\n+    <Container>\n+      <BackButton data-testid=\"back-button\" onClick={navBack}>\n+        <ArrowBackIcon />\n+      </BackButton>\n+      {chat && chat.picture && chat.name && (\n+        <React.Fragment>\n+          <Picture data-testid=\"chat-picture\" src={chat.picture} />\n+          <Name data-testid=\"chat-name\">{chat.name}</Name>\n+        </React.Fragment>\n+      )}\n+      <Rest>\n+        <DeleteButton data-testid=\"delete-button\" onClick={handleRemoveChat}>\n+          <DeleteIcon />\n+        </DeleteButton>\n+      </Rest>\n+    </Container>\n+  );\n+};\n+\n+export default ChatNavbar;\n\\ No newline at end of file\ndiff --git a/client/src/components/ChatRoomScreen/MessageInput.test.tsx b/client/src/components/ChatRoomScreen/MessageInput.test.tsx\nnew file mode 100644\nindex 0000000..973de60\n--- /dev/null\n+++ b/client/src/components/ChatRoomScreen/MessageInput.test.tsx\n@@ -0,0 +1,47 @@\n+import { createMemoryHistory } from 'history';\n+import React from 'react';\n+import { cleanup, render, fireEvent, wait, waitForElement } from 'react-testing-library';\n+import MessageInput from './MessageInput';\n+\n+describe('MessageInput;', () => {\n+  afterEach(cleanup);\n+\n+  it('triggers callback on send button click', async () => {\n+    const onSendMessage = jest.fn(() => {});\n+\n+    {\n+      const { container, getByTestId } = render(<MessageInput onSendMessage={onSendMessage} />);\n+      const messageInput = getByTestId('message-input');\n+      const sendButton = getByTestId('send-button');\n+\n+      fireEvent.change(messageInput, { target: { value: 'foo' } });\n+\n+      await waitForElement(() => messageInput);\n+\n+      fireEvent.click(sendButton);\n+\n+      await wait(() =>\n+        expect(onSendMessage.mock.calls.length).toBe(1)\n+      );\n+    }\n+  });\n+\n+  it('triggers callback on Enter press', async () => {\n+    const onSendMessage = jest.fn(() => {});\n+\n+    {\n+      const { container, getByTestId } = render(<MessageInput onSendMessage={onSendMessage} />);\n+      const messageInput = getByTestId('message-input');\n+\n+      fireEvent.change(messageInput, { target: { value: 'foo' } });\n+\n+      await waitForElement(() => messageInput);\n+\n+      fireEvent.keyPress(messageInput, { key: 'Enter', code: 13, charCode: 13 });\n+\n+      await wait(() =>\n+        expect(onSendMessage.mock.calls.length).toBe(1)\n+      );\n+    }\n+  });\n+});\n\\ No newline at end of file\ndiff --git a/client/src/components/ChatRoomScreen/MessageInput.tsx b/client/src/components/ChatRoomScreen/MessageInput.tsx\nnew file mode 100644\nindex 0000000..266cfbd\n--- /dev/null\n+++ b/client/src/components/ChatRoomScreen/MessageInput.tsx\n@@ -0,0 +1,92 @@\n+import Button from '@material-ui/core/Button';\n+import SendIcon from '@material-ui/icons/Send';\n+import React from 'react';\n+import styled from 'styled-components';\n+import { useState } from 'react';\n+\n+const Container = styled.div`\n+  display: flex;\n+  height: 50px;\n+  padding: 5px;\n+  width: calc(100% - 10px);\n+`;\n+\n+const ActualInput = styled.input `\n+  width: calc(100% - 50px);\n+  border: none;\n+  border-radius: 999px;\n+  padding: 10px;\n+  padding-left: 20px;\n+  padding-right: 20px;\n+  font-size: 15px;\n+  outline: none;\n+  box-shadow: 0 1px silver;\n+  font-size: 18px;\n+  line-height: 45px;\n+`;\n+\n+const SendButton = styled(Button) `\n+  min-width: 50px !important;\n+  width: 50px !important;\n+  border-radius: 999px !important;\n+  background-color: var(--primary-bg) !important;\n+  margin: 0 5px !important;\n+  margin-right: 0 !important;\n+  color: white !important;\n+  padding-left: 20px !important;\n+\n+  svg {\n+    margin-left: -3px;\n+  }\n+` as typeof Button;\n+\n+interface MessageInputProps {\n+  onSendMessage(content: string): any;\n+}\n+\n+const MessageInput: React.FC<MessageInputProps> = ({ onSendMessage }) => {\n+  const [message, setMessage] = useState(\"\");\n+\n+  const onKeyPress = (e: any) => {\n+    if (e.charCode === 13) {\n+      submitMessage();\n+    }\n+  };\n+\n+  const onChange = ({ target }: any) => {\n+    setMessage(target.value);\n+  };\n+\n+  const submitMessage = () => {\n+    if (!message) return;\n+\n+    setMessage(\"\");\n+\n+    if (typeof onSendMessage === \"function\") {\n+      onSendMessage(message);\n+    }\n+  };\n+\n+  return (\n+    <Container>\n+      <ActualInput\n+        data-testid=\"message-input\"\n+        type=\"text\"\n+        placeholder=\"Type a message\"\n+        value={message}\n+        onKeyPress={onKeyPress}\n+        onChange={onChange}\n+      />\n+      <SendButton\n+        data-testid=\"send-button\"\n+        variant=\"contained\"\n+        color=\"primary\"\n+        onClick={submitMessage}\n+      >\n+        <SendIcon />\n+      </SendButton>\n+    </Container>\n+  );\n+};\n+\n+export default MessageInput;\n\\ No newline at end of file\ndiff --git a/client/src/components/ChatRoomScreen/MessagesList.test.tsx b/client/src/components/ChatRoomScreen/MessagesList.test.tsx\nnew file mode 100644\nindex 0000000..57aa03d\n--- /dev/null\n+++ b/client/src/components/ChatRoomScreen/MessagesList.test.tsx\n@@ -0,0 +1,37 @@\n+import { createMemoryHistory } from 'history';\n+import React from 'react';\n+import { cleanup, render, fireEvent, wait, getByTestId } from 'react-testing-library';\n+import MessagesList from './MessagesList';\n+\n+describe('MessagesList', () => {\n+  afterEach(cleanup);\n+\n+  it('renders messages data', () => {\n+    const messages = [\n+      {\n+        id: '1',\n+        content: 'foo',\n+        createdAt: new Date('14 Jun 2017 00:00:00 PDT').toUTCString(),\n+      },\n+      {\n+        id: '2',\n+        content: 'bar',\n+        createdAt: new Date('17 Jun 2017 00:01:00 PDT').toUTCString(),\n+      },\n+    ];\n+\n+    let message1, message2;\n+    {\n+      const { container, getAllByTestId, getByTestId } = render(<MessagesList messages={messages} />);\n+      const match = getAllByTestId('message-item');\n+      message1 = match[0];\n+      message2 = match[1];\n+    }\n+\n+    expect(getByTestId(message1, 'message-content')).toHaveTextContent('foo');\n+    expect(getByTestId(message1, 'message-date')).toHaveTextContent('10:00');\n+\n+    expect(getByTestId(message2, 'message-content')).toHaveTextContent('bar');\n+    expect(getByTestId(message2, 'message-date')).toHaveTextContent('10:01');\n+  });\n+});\n\\ No newline at end of file\ndiff --git a/client/src/components/ChatRoomScreen/MessagesList.tsx b/client/src/components/ChatRoomScreen/MessagesList.tsx\nnew file mode 100644\nindex 0000000..5a6d418\n--- /dev/null\n+++ b/client/src/components/ChatRoomScreen/MessagesList.tsx\n@@ -0,0 +1,116 @@\n+import moment from 'moment';\n+import React from 'react';\n+import { useEffect, useRef } from 'react';\n+import ReactDOM from 'react-dom';\n+import styled, { css } from 'styled-components';\n+\n+const Container = styled.div`\n+  display: block;\n+  flex: 2;\n+  overflow-y: overlay;\n+  padding: 0 15px;\n+`;\n+\n+type StyledProp = {\n+  isMine: any;\n+};\n+\n+const MessageItem = styled.div `\n+  display: inline-block;\n+  position: relative;\n+  max-width: 100%;\n+  border-radius: 7px;\n+  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.15);\n+  margin-top: 10px;\n+  margin-bottom: 10px;\n+  clear: both;\n+\n+  &::after {\n+    content: '';\n+    display: table;\n+    clear: both;\n+  }\n+\n+  &::before {\n+    content: '';\n+    position: absolute;\n+    bottom: 3px;\n+    width: 12px;\n+    height: 19px;\n+    background-position: 50% 50%;\n+    background-repeat: no-repeat;\n+    background-size: contain;\n+  }\n+\n+  ${(props: StyledProp) => props.isMine ? css `\n+    float: right;\n+    background-color: #dcf8c6;\n+\n+    &::before {\n+      right: -11px;\n+      background-image: url(/assets/message-mine.png);\n+    }\n+  ` : css `\n+    float: left;\n+    background-color: #fff;\n+\n+    &::before {\n+      left: -11px;\n+      background-image: url(/assets/message-other.png);\n+    }\n+  `}\n+`;\n+\n+const Contents = styled.div `\n+  padding: 5px 7px;\n+  word-wrap: break-word;\n+\n+  &::after {\n+    content: ' \\00a0\\00a0\\00a0\\00a0\\00a0\\00a0\\00a0\\00a0\\00a0\\00a0\\00a0\\00a0\\00a0\\00a0\\00a0\\00a0\\00a0\\00a0\\00a0';\n+    display: inline;\n+  }\n+`;\n+\n+const Timestamp = styled.div `\n+  position: absolute;\n+  bottom: 2px;\n+  right: 7px;\n+  color: gray;\n+  font-size: 12px;\n+`;\n+\n+interface Message {\n+  id: string | null;\n+  content: string | null;\n+  createdAt: string | null;\n+}\n+interface MessagesListProps {\n+  messages: Array<Message>;\n+}\n+\n+const MessagesList: React.FC<MessagesListProps> = ({ messages }) => {\n+  const selfRef = useRef(null);\n+\n+  useEffect(() => {\n+    if (!selfRef.current) return;\n+    const selfDOMNode = ReactDOM.findDOMNode(selfRef.current) as HTMLElement;\n+    selfDOMNode.scrollTop = Number.MAX_SAFE_INTEGER;\n+  }, [messages.length]);\n+\n+  return (\n+    <Container ref={selfRef}>\n+      {messages.map((message: any) => (\n+        <MessageItem\n+          data-testid=\"message-item\"\n+          isMine={message.isMine}\n+          key={message.id}\n+        >\n+          <Contents data-testid=\"message-content\">{message.content}</Contents>\n+          <Timestamp data-testid=\"message-date\">{moment(message.createdAt).format('HH:mm')}</Timestamp>\n+        </MessageItem>\n+      ))}\n+    </Container>\n+  );\n+};\n+\n+export default MessagesList;\n\\ No newline at end of file\ndiff --git a/client/src/components/ChatRoomScreen/index.tsx b/client/src/components/ChatRoomScreen/index.tsx\nnew file mode 100644\nindex 0000000..f109d67\n--- /dev/null\n+++ b/client/src/components/ChatRoomScreen/index.tsx\n@@ -0,0 +1,108 @@\n+import gql from 'graphql-tag';\n+import React from 'react';\n+import { useCallback } from 'react';\n+import { Redirect } from 'react-router-dom';\n+import styled from 'styled-components';\n+import ChatNavbar from './ChatNavbar';\n+import MessageInput from './MessageInput';\n+import MessagesList from './MessagesList';\n+import { History } from 'history';\n+import { useGetChatQuery, useAddMessageMutation } from '../../graphql/types';\n+import * as fragments from '../../graphql/fragments';\n+import { writeMessage } from '../../services/cache.service';\n+\n+ const Container = styled.div `\n+  background: url(/assets/chat-background.jpg);\n+  display: flex;\n+  flex-flow: column;\n+  height: 100vh;\n+`;\n+\n+// eslint-disable-next-line\n+const getChatQuery = gql `\n+  query GetChat($chatId: ID!) {\n+    chat(chatId: $chatId) {\n+      ...FullChat\n+    }\n+  }\n+  ${fragments.fullChat}\n+`;\n+\n+// eslint-disable-next-line\n+const addMessageMutation = gql `\n+  mutation AddMessage($chatId: ID!, $content: String!) {\n+    addMessage(chatId: $chatId, content: $content) {\n+      ...Message\n+    }\n+  }\n+  ${fragments.message}\n+`;\n+\n+interface ChatRoomScreenParams {\n+  chatId: string\n+  history: History;\n+};\n+\n+const ChatRoomScreen: React.FC<ChatRoomScreenParams> = ({ history, chatId }) => {\n+  const { data, loading } = useGetChatQuery({\n+    variables: { chatId }\n+  });\n+\n+  const addMessage = useAddMessageMutation();\n+\n+  const onSendMessage = useCallback((content: string) => {\n+\n+    if (data === undefined) { return null; }\n+    const chat = data.chat;\n+    if (chat === null) return null;\n+\n+    addMessage({\n+      variables: { chatId, content },\n+      optimisticResponse: {\n+        __typename: 'Mutation',\n+        addMessage: {\n+          __typename: 'Message',\n+          id: Math.random().toString(36).substr(2, 9),\n+          createdAt: new Date(),\n+          isMine: true,\n+          chat: {\n+            __typename: 'Chat',\n+            id: chatId,\n+          },\n+          content,\n+        }\n+      },\n+      update: (client, { data: { addMessage } }) => {\n+        writeMessage(client, addMessage);\n+      },\n+    })\n+  }, [data, chatId, addMessage]);\n+\n+  if (data === undefined) {\n+    return null;\n+  }\n+  const chat = data.chat;\n+  const loadingChat = loading;\n+\n+  if (loadingChat) return null;\n+  if (chat === null) return null;\n+\n+  // Chat was probably removed from cache by the subscription handler\n+  if (!chat) {\n+    return (\n+      <Redirect to=\"/chats\" />\n+    );\n+  }\n+\n+  return (\n+    <Container>\n+      <ChatNavbar chat={chat} history={history} />\n+      {chat.messages && (\n+        <MessagesList messages={chat.messages} />\n+      )}\n+      <MessageInput onSendMessage={onSendMessage}/>\n+    </Container>\n+  );\n+};\n+\n+export default ChatRoomScreen;\n\\ No newline at end of file\ndiff --git a/client/src/components/ChatsListScreen/AddChatButton.test.tsx b/client/src/components/ChatsListScreen/AddChatButton.test.tsx\nnew file mode 100644\nindex 0000000..8a21aff\n--- /dev/null\n+++ b/client/src/components/ChatsListScreen/AddChatButton.test.tsx\n@@ -0,0 +1,22 @@\n+import { createMemoryHistory } from 'history';\n+import React from 'react';\n+import { cleanup, render, fireEvent, wait } from 'react-testing-library';\n+import AddChatButton from './AddChatButton';\n+\n+describe('AddChatButton', () => {\n+  afterEach(cleanup);\n+\n+  it('goes back on arrow click', async () => {\n+    const history = createMemoryHistory();\n+\n+    {\n+      const { container, getByTestId } = render(<AddChatButton history={history} />);\n+\n+      fireEvent.click(getByTestId('new-chat-button'));\n+\n+      await wait(() =>\n+        expect(history.location.pathname).toEqual('/new-chat')\n+      );\n+    }\n+  });\n+});\ndiff --git a/client/src/components/ChatsListScreen/AddChatButton.tsx b/client/src/components/ChatsListScreen/AddChatButton.tsx\nnew file mode 100644\nindex 0000000..d14fc44\n--- /dev/null\n+++ b/client/src/components/ChatsListScreen/AddChatButton.tsx\n@@ -0,0 +1,44 @@\n+import Button from '@material-ui/core/Button';\n+import ChatIcon from '@material-ui/icons/Chat';\n+import React from 'react';\n+import styled from 'styled-components';\n+import { History } from 'history';\n+\n+const Container = styled.div `\n+  position: fixed;\n+  right: 10px;\n+  bottom: 10px;\n+\n+  button {\n+    min-width: 50px;\n+    width: 50px;\n+    height: 50px;\n+    border-radius: 999px;\n+    background-color: var(--secondary-bg);\n+    color: white;\n+  }\n+`;\n+interface ChildComponentProps {\n+  history: History;\n+};\n+\n+const AddChatButton: React.FC<ChildComponentProps> = ({ history }) => {\n+  const onClick = () => {\n+    history.push('/new-chat')\n+  };\n+\n+  return (\n+    <Container>\n+      <Button\n+        data-testid=\"new-chat-button\"\n+        variant=\"contained\"\n+        color=\"secondary\"\n+        onClick={onClick}\n+      >\n+        <ChatIcon />\n+      </Button>\n+    </Container>\n+  );\n+};\n+\n+export default AddChatButton;\n\\ No newline at end of file\ndiff --git a/client/src/components/ChatsListScreen/ChatsList.test.tsx b/client/src/components/ChatsListScreen/ChatsList.test.tsx\nnew file mode 100644\nindex 0000000..33447b8\n--- /dev/null\n+++ b/client/src/components/ChatsListScreen/ChatsList.test.tsx\n@@ -0,0 +1,128 @@\n+import React from 'react';\n+import { ApolloProvider } from 'react-apollo-hooks';\n+import ReactDOM from 'react-dom';\n+import { cleanup, render, fireEvent, wait, waitForDomChange } from 'react-testing-library';\n+import { createBrowserHistory } from 'history';\n+import { mockApolloClient } from '../../test-helpers';\n+import ChatsList, { getChatsQuery } from './ChatsList';\n+import * as queries from '../../graphql/queries';\n+\n+describe('ChatsList', () => {\n+  afterEach(() => {\n+    cleanup();\n+    window.location.pathname = '/';\n+  });\n+\n+  it('renders fetched chats data', async () => {\n+    const client = mockApolloClient([\n+      {\n+        request: { query: queries.chats },\n+        result: {\n+          data: {\n+            chats: [\n+              {\n+                __typename: 'Chat',\n+                id: 1,\n+                name: 'Foo Bar',\n+                picture: 'https://localhost:4000/picture.jpg',\n+                lastMessage: {\n+                  __typename: 'Message',\n+                  id: 1,\n+                  content: 'Hello',\n+                  createdAt: new Date('14 Jun 2017 00:00:00 PDT').toUTCString(),\n+                  isMine: true,\n+                  chat: {\n+                    __typename: 'Chat',\n+                    id: 1,\n+                  },\n+                },\n+              },\n+            ],\n+          },\n+        },\n+      },\n+    ]);\n+\n+    {\n+      const { container, getByTestId } = render(\n+        <ApolloProvider client={client}>\n+          <ChatsList />\n+        </ApolloProvider>\n+      );\n+\n+      await waitForDomChange({ container });\n+\n+      expect(getByTestId('name')).toHaveTextContent('Foo Bar');\n+      expect(getByTestId('picture')).toHaveAttribute('src', 'https://localhost:4000/picture.jpg');\n+      expect(getByTestId('content')).toHaveTextContent('Hello');\n+      expect(getByTestId('date')).toHaveTextContent('10:00');\n+    }\n+  });\n+\n+  it('should navigate to the target chat room on chat item click', async () => {\n+    const client = mockApolloClient([\n+      {\n+        request: { query: queries.chats },\n+        result: {\n+          data: {\n+            chats: [\n+              {\n+                __typename: 'Chat',\n+                id: 1,\n+                name: 'Foo Bar',\n+                picture: 'https://localhost:4000/picture.jpg',\n+                lastMessage: {\n+                  __typename: 'Message',\n+                  id: 1,\n+                  content: 'Hello',\n+                  createdAt: new Date(0),\n+                  isMine: true,\n+                  chat: {\n+                    __typename: 'Chat',\n+                    id: 1,\n+                  },\n+                },\n+              },\n+            ],\n+          },\n+        },\n+      },\n+    ]);\n+\n+     const history = createBrowserHistory();\n+\n+    {\n+      const { container, getByTestId } = render(\n+        <ApolloProvider client={client}>\n+          <ChatsList history={history} />\n+        </ApolloProvider>\n+      );\n+\n+       await waitForDomChange({ container });\n+\n+       fireEvent.click(getByTestId('chat'));\n+\n+       await wait(() =>\n+        expect(history.location.pathname).toEqual('/chats/1')\n+      );\n+    }\n+  });\n+});\n+\n+// IMPORTANT\n+// Below is a temporary hack to suppress warnings generated by a React bug.\n+// Source: https://github.com/testing-library/react-testing-library/issues/281\n+// @todo: remove this when React 16.9.0 is stable and we upgrade.\n+const originalError = console.error;\n+beforeAll(() => {\n+  console.error = (...args: string[]) => {\n+    if (/Warning.*not wrapped in act/.test(args[0])) {\n+      return;\n+    }\n+    originalError.call(console, ...args);\n+  };\n+});\n+\n+afterAll(() => {\n+  console.error = originalError;\n+});\ndiff --git a/client/src/components/ChatsListScreen/ChatsList.tsx b/client/src/components/ChatsListScreen/ChatsList.tsx\nnew file mode 100644\nindex 0000000..c5fd34a\n--- /dev/null\n+++ b/client/src/components/ChatsListScreen/ChatsList.tsx\n@@ -0,0 +1,101 @@\n+import React from 'react';\n+import moment from 'moment';\n+import { List, ListItem } from '@material-ui/core';\n+import styled from 'styled-components';\n+import { useCallback } from 'react';\n+import { History } from 'history';\n+import { useChatsQuery } from '../../graphql/types';\n+\n+const Container = styled.div `\n+  height: calc(100% - 56px);\n+  overflow-y: overlay;\n+`;\n+\n+const StyledList = styled(List) `\n+  padding: 0 !important;\n+` as typeof List;\n+\n+const StyledListItem = styled(ListItem) `\n+  height: 76px;\n+  padding: 0 15px;\n+  display: flex;\n+` as typeof ListItem;\n+\n+const ChatPicture = styled.img `\n+  height: 50px;\n+  width: 50px;\n+  object-fit: cover;\n+  border-radius: 50%;\n+`;\n+\n+const ChatInfo = styled.div `\n+  width: calc(100% - 60px);\n+  height: 46px;\n+  padding: 15px 0;\n+  margin-left: 10px;\n+  border-bottom: 0.5px solid silver;\n+  position: relative;\n+`;\n+\n+const ChatName = styled.div `\n+  margin-top: 5px;\n+`;\n+\n+const MessageContent = styled.div `\n+  color: gray;\n+  font-size: 15px;\n+  margin-top: 5px;\n+  text-overflow: ellipsis;\n+  overflow: hidden;\n+  white-space: nowrap;\n+`;\n+\n+const MessageDate = styled.div `\n+  position: absolute;\n+  color: gray;\n+  top: 20px;\n+  right: 0;\n+  font-size: 13px;\n+`;\n+\n+interface ChatsListProps {\n+  history : History;\n+};\n+\n+const ChatsList: React.FC<ChatsListProps> = ({ history }) => {\n+\n+  const navToChat = useCallback((chat) => {\n+    history.push(`chats/${chat.id}`)\n+  }, [history]);\n+\n+  const { data } = useChatsQuery();\n+\n+  if (data === undefined || data.chats === undefined) {\n+    return null;\n+  }\n+\n+  let chats = data.chats;\n+\n+  return (\n+    <Container>\n+      <StyledList>\n+        {chats.map((chat: any) => (\n+          <StyledListItem key={chat.id} data-testid=\"chat\" button onClick={navToChat.bind(null, chat)}>\n+            <ChatPicture data-testid=\"picture\" src={chat.picture} alt=\"Profile\"/>\n+            <ChatInfo>\n+              <ChatName data-testid=\"name\">{chat.name}</ChatName>\n+              {chat.lastMessage && (\n+                <React.Fragment>\n+                  <MessageContent data-testid=\"content\">{chat.lastMessage.content}</MessageContent>\n+                  <MessageDate data-testid=\"date\">{moment(chat.lastMessage.createdAt).format('HH:mm')}</MessageDate>\n+                </React.Fragment>\n+              )}\n+            </ChatInfo>\n+          </StyledListItem>\n+        ))}\n+      </StyledList>\n+    </Container>\n+  )\n+};\n+\n+export default ChatsList;\n\\ No newline at end of file\ndiff --git a/client/src/components/ChatsListScreen/ChatsNavbar.tsx b/client/src/components/ChatsListScreen/ChatsNavbar.tsx\nnew file mode 100644\nindex 0000000..9ef163a\n--- /dev/null\n+++ b/client/src/components/ChatsListScreen/ChatsNavbar.tsx\n@@ -0,0 +1,46 @@\n+import React from 'react';\n+import { Button, Toolbar } from '@material-ui/core';\n+import styled from 'styled-components';\n+import SignOutIcon from '@material-ui/icons/PowerSettingsNew';\n+import { useCallback } from 'react';\n+import { signOut } from '../../services/auth.service';\n+import { History } from 'history';\n+\n+const Container = styled(Toolbar) `\n+  display: flex;\n+  background-color: var(--primary-bg);\n+  color: var(--primary-text);\n+  font-size: 20px;\n+  line-height: 40px;\n+` as typeof Toolbar;\n+\n+const Title = styled.div `\n+  flex: 1;\n+`;\n+\n+const LogoutButton = styled(Button) `\n+  color: var(--primary-text) !important;\n+` as typeof Button;\n+\n+interface ChildComponentProps {\n+  history: History;\n+};\n+\n+const ChatsNavbar: React.FC<ChildComponentProps> = ({ history }) => {\n+  const handleSignOut = useCallback(() => {\n+    signOut().then(() => {\n+      history.replace('/sign-in')\n+    });\n+  }, [history]);\n+\n+  return (\n+    <Container>\n+      <Title>Whatsapp Clone</Title>\n+      <LogoutButton data-testid=\"sign-out-button\" onClick={handleSignOut}>\n+        <SignOutIcon />\n+      </LogoutButton>\n+    </Container>\n+  );\n+};\n+\n+export default ChatsNavbar;\n\\ No newline at end of file\ndiff --git a/client/src/components/ChatsListScreen/index.tsx b/client/src/components/ChatsListScreen/index.tsx\nnew file mode 100644\nindex 0000000..4451ea2\n--- /dev/null\n+++ b/client/src/components/ChatsListScreen/index.tsx\n@@ -0,0 +1,24 @@\n+import React from 'react';\n+import ChatsNavbar from './ChatsNavbar';\n+import ChatsList from './ChatsList';\n+import styled from 'styled-components';\n+import { History } from 'history';\n+import AddChatButton from './AddChatButton';\n+\n+const Container = styled.div `\n+  height: 100vh;\n+`;\n+\n+interface ChatsListScreenProps {\n+  history : History;\n+};\n+\n+const ChatsListScreen: React.FC<ChatsListScreenProps> = ({ history }) => (\n+  <Container>\n+    <ChatsNavbar history={history} />\n+    <ChatsList history={history} />\n+    <AddChatButton history={history} />\n+  </Container>\n+);\n+\n+export default ChatsListScreen;\n\\ No newline at end of file\ndiff --git a/client/src/components/UsersList.test.tsx b/client/src/components/UsersList.test.tsx\nnew file mode 100644\nindex 0000000..5af11e0\n--- /dev/null\n+++ b/client/src/components/UsersList.test.tsx\n@@ -0,0 +1,84 @@\n+import React from 'react';\n+import { ApolloProvider } from 'react-apollo-hooks';\n+import { cleanup, render, fireEvent, wait, waitForDomChange } from 'react-testing-library';\n+import { mockApolloClient } from '../test-helpers';\n+import UsersList, { UsersListQuery } from './UsersList';\n+import * as queries from '../graphql/queries';\n+\n+describe('UsersList', () => {\n+  afterEach(cleanup);\n+\n+  it('renders fetched users data', async () => {\n+    const client = mockApolloClient([\n+      {\n+        request: { query: UsersListQuery },\n+        result: {\n+          data: {\n+            users: [\n+              {\n+                __typename: 'User',\n+                id: 1,\n+                name: 'Charles Dickhead',\n+                picture: 'https://localhost:4000/dick.jpg',\n+              },\n+            ],\n+          },\n+        },\n+      },\n+    ]);\n+\n+    {\n+      const { container, getByTestId } = render(\n+        <ApolloProvider client={client}>\n+          <UsersList />\n+        </ApolloProvider>\n+      );\n+\n+      await waitForDomChange({ container });\n+\n+      expect(getByTestId('name')).toHaveTextContent('Charles Dickhead');\n+      expect(getByTestId('picture')).toHaveAttribute('src', 'https://localhost:4000/dick.jpg');\n+    }\n+  })\n+\n+  it('triggers onUserPick() callback on user-item click', async () => {\n+    const client = mockApolloClient([\n+      {\n+        request: { query: UsersListQuery },\n+        result: {\n+          data: {\n+            users: [\n+              {\n+                __typename: 'User',\n+                id: 1,\n+                name: 'Charles Dickhead',\n+                picture: 'https://localhost:4000/dick.jpg',\n+              },\n+            ],\n+          },\n+        },\n+      },\n+    ]);\n+\n+    const onUserPick = jest.fn(() => {});\n+\n+    {\n+      const { container, getByTestId } = render(\n+        <ApolloProvider client={client}>\n+          <UsersList onUserPick={onUserPick} />\n+        </ApolloProvider>\n+      );\n+\n+      await waitForDomChange({ container });\n+\n+      fireEvent.click(getByTestId('user'));\n+\n+      await wait(() =>\n+        expect(onUserPick.mock.calls.length).toBe(1)\n+      );\n+\n+      expect(onUserPick.mock.calls[0][0].name).toEqual('Charles Dickhead');\n+      expect(onUserPick.mock.calls[0][0].picture).toEqual('https://localhost:4000/dick.jpg');\n+    }\n+  });\n+});\ndiff --git a/client/src/components/UsersList.tsx b/client/src/components/UsersList.tsx\nnew file mode 100644\nindex 0000000..0fbf394\n--- /dev/null\n+++ b/client/src/components/UsersList.tsx\n@@ -0,0 +1,72 @@\n+import MaterialList from '@material-ui/core/List';\n+import MaterialItem from '@material-ui/core/ListItem';\n+import gql from 'graphql-tag';\n+import React from 'react';\n+import styled from 'styled-components';\n+import * as fragments from '../graphql/fragments';\n+import { useUsersListQuery, User } from '../graphql/types';\n+\n+const ActualList = styled(MaterialList) `\n+  padding: 0;\n+` as typeof MaterialList;\n+\n+const UserItem = styled(MaterialItem) `\n+  position: relative;\n+  padding: 7.5px 15px;\n+  display: flex;\n+  cursor: pinter;\n+` as typeof MaterialItem;\n+\n+const ProfilePicture = styled.img `\n+  height: 50px;\n+  width: 50px;\n+  object-fit: cover;\n+  border-radius: 50%;\n+`;\n+\n+const Name = styled.div `\n+  padding-left: 15px;\n+  font-weight: bold;\n+`;\n+\n+export const UsersListQuery = gql`\n+  query UsersList {\n+    users {\n+      ...User\n+    }\n+  }\n+  ${fragments.user}\n+`;\n+\n+interface ChildComponentProps {\n+  onUserPick: any;\n+};\n+\n+const UsersList: React.FC<ChildComponentProps> = ({ onUserPick = (user: User) => {} }) => {\n+  const { data, loading: loadingUsers } = useUsersListQuery();\n+\n+  if (data === undefined) return null;\n+  const users = data.users;\n+\n+  return (\n+    <ActualList>\n+      {!loadingUsers && users.map(user => (\n+        <UserItem\n+          key={user.id}\n+          data-testid=\"user\"\n+          onClick={onUserPick.bind(null, user)}\n+          button\n+        >\n+          {(user !== null && user.picture !== null) &&\n+            <React.Fragment>\n+              <ProfilePicture data-testid=\"picture\" src={user.picture} />\n+              <Name data-testid=\"name\">{user.name}</Name>\n+            </React.Fragment>\n+          }\n+        </UserItem>\n+      ))}\n+    </ActualList>\n+  );\n+};\n+\n+export default UsersList;\ndiff --git a/client/src/graphql/fragments/chat.fragment.ts b/client/src/graphql/fragments/chat.fragment.ts\nnew file mode 100644\nindex 0000000..9ef2c89\n--- /dev/null\n+++ b/client/src/graphql/fragments/chat.fragment.ts\n@@ -0,0 +1,14 @@\n+import gql from 'graphql-tag';\n+import message from './message.fragment';\n+\n+export default gql`\n+  fragment Chat on Chat {\n+    id\n+    name\n+    picture\n+    lastMessage {\n+      ...Message\n+    }\n+  }\n+  ${message}\n+`;\ndiff --git a/client/src/graphql/fragments/fullChat.fragment.ts b/client/src/graphql/fragments/fullChat.fragment.ts\nnew file mode 100644\nindex 0000000..26998e4\n--- /dev/null\n+++ b/client/src/graphql/fragments/fullChat.fragment.ts\n@@ -0,0 +1,14 @@\n+import gql from 'graphql-tag';\n+import chat from './chat.fragment';\n+import message from './message.fragment';\n+\n+export default gql`\n+  fragment FullChat on Chat {\n+    ...Chat\n+    messages {\n+      ...Message\n+    }\n+  }\n+  ${chat}\n+  ${message}\n+`;\ndiff --git a/client/src/graphql/fragments/index.ts b/client/src/graphql/fragments/index.ts\nnew file mode 100644\nindex 0000000..83a5d91\n--- /dev/null\n+++ b/client/src/graphql/fragments/index.ts\n@@ -0,0 +1,4 @@\n+export { default as chat } from './chat.fragment';\n+export { default as fullChat } from './fullChat.fragment';\n+export { default as message } from './message.fragment';\n+export { default as user } from './user.fragment';\ndiff --git a/client/src/graphql/fragments/message.fragment.ts b/client/src/graphql/fragments/message.fragment.ts\nnew file mode 100644\nindex 0000000..8fdf90f\n--- /dev/null\n+++ b/client/src/graphql/fragments/message.fragment.ts\n@@ -0,0 +1,13 @@\n+import gql from 'graphql-tag';\n+\n+export default gql`\n+  fragment Message on Message {\n+    id\n+    createdAt\n+    content\n+    isMine\n+    chat {\n+      id\n+    }\n+  }\n+`;\ndiff --git a/client/src/graphql/fragments/user.fragment.ts b/client/src/graphql/fragments/user.fragment.ts\nnew file mode 100644\nindex 0000000..7fb70c7\n--- /dev/null\n+++ b/client/src/graphql/fragments/user.fragment.ts\n@@ -0,0 +1,9 @@\n+import gql from 'graphql-tag';\n+\n+export default gql`\n+  fragment User on User {\n+    id\n+    name\n+    picture\n+  }\n+`;\ndiff --git a/client/src/graphql/queries/chats.query.ts b/client/src/graphql/queries/chats.query.ts\nnew file mode 100644\nindex 0000000..332d28a\n--- /dev/null\n+++ b/client/src/graphql/queries/chats.query.ts\n@@ -0,0 +1,11 @@\n+import gql from 'graphql-tag';\n+import * as fragments from '../fragments';\n+\n+export default gql`\n+  query Chats {\n+    chats {\n+      ...Chat\n+    }\n+  }\n+  ${fragments.chat}\n+`;\ndiff --git a/client/src/graphql/queries/index.ts b/client/src/graphql/queries/index.ts\nnew file mode 100644\nindex 0000000..a27d3d3\n--- /dev/null\n+++ b/client/src/graphql/queries/index.ts\n@@ -0,0 +1 @@\n+export { default as chats } from './chats.query';\ndiff --git a/client/src/graphql/queries/me.query.ts b/client/src/graphql/queries/me.query.ts\nnew file mode 100644\nindex 0000000..3ca7870\n--- /dev/null\n+++ b/client/src/graphql/queries/me.query.ts\n@@ -0,0 +1,11 @@\n+import gql from 'graphql-tag';\n+import * as fragments from '../fragments';\n+\n+export default gql`\n+  query Me {\n+    me {\n+      ...User\n+    }\n+  }\n+  ${fragments.user}\n+`;\ndiff --git a/client/src/graphql/subscriptions/chatAdded.subscription.ts b/client/src/graphql/subscriptions/chatAdded.subscription.ts\nnew file mode 100644\nindex 0000000..625420c\n--- /dev/null\n+++ b/client/src/graphql/subscriptions/chatAdded.subscription.ts\n@@ -0,0 +1,11 @@\n+import gql from 'graphql-tag';\n+import * as fragments from '../fragments';\n+\n+export default gql`\n+  subscription ChatAdded {\n+    chatAdded {\n+      ...Chat\n+    }\n+  }\n+  ${fragments.chat}\n+`;\ndiff --git a/client/src/graphql/subscriptions/chatRemoved.subscription.ts b/client/src/graphql/subscriptions/chatRemoved.subscription.ts\nnew file mode 100644\nindex 0000000..cfc6fcc\n--- /dev/null\n+++ b/client/src/graphql/subscriptions/chatRemoved.subscription.ts\n@@ -0,0 +1,7 @@\n+import gql from 'graphql-tag';\n+\n+export default gql`\n+  subscription ChatRemoved {\n+    chatRemoved\n+  }\n+`;\ndiff --git a/client/src/graphql/subscriptions/index.ts b/client/src/graphql/subscriptions/index.ts\nnew file mode 100644\nindex 0000000..0616a47\n--- /dev/null\n+++ b/client/src/graphql/subscriptions/index.ts\n@@ -0,0 +1,3 @@\n+export { default as messageAdded } from './messageAdded.subscription';\n+export { default as chatAdded } from './chatAdded.subscription';\n+export { default as chatRemoved } from './chatRemoved.subscription';\ndiff --git a/client/src/graphql/subscriptions/messageAdded.subscription.ts b/client/src/graphql/subscriptions/messageAdded.subscription.ts\nnew file mode 100644\nindex 0000000..382c755\n--- /dev/null\n+++ b/client/src/graphql/subscriptions/messageAdded.subscription.ts\n@@ -0,0 +1,11 @@\n+import gql from 'graphql-tag';\n+import * as fragments from '../fragments';\n+\n+export default gql `\n+  subscription MessageAdded {\n+    messageAdded {\n+      ...Message\n+    }\n+  }\n+  ${fragments.message}\n+`;\ndiff --git a/client/src/index.css b/client/src/index.css\nnew file mode 100644\nindex 0000000..75eaaee\n--- /dev/null\n+++ b/client/src/index.css\n@@ -0,0 +1,21 @@\n+:root {\n+  --primary-bg: #2c6157;\n+  --secondary-bg: #6fd056;\n+  --primary-text: white;\n+  --secondary-text: white;\n+}\n+\n+body {\n+  margin: 0;\n+  padding: 0;\n+  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',\n+    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',\n+    sans-serif;\n+  -webkit-font-smoothing: antialiased;\n+  -moz-osx-font-smoothing: grayscale;\n+}\n+\n+code {\n+  font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',\n+    monospace;\n+}\ndiff --git a/client/src/index.tsx b/client/src/index.tsx\nnew file mode 100644\nindex 0000000..e953ef2\n--- /dev/null\n+++ b/client/src/index.tsx\n@@ -0,0 +1,31 @@\n+import { MuiThemeProvider, createMuiTheme } from '@material-ui/core/styles'\n+import React from 'react';\n+import ReactDOM from 'react-dom';\n+import { ApolloProvider } from 'react-apollo-hooks';\n+import './index.css';\n+import App from './App';\n+import client from './client';\n+import * as serviceWorker from './serviceWorker';\n+\n+const theme = createMuiTheme({\n+  palette: {\n+    primary: { main: '#2c6157' },\n+    secondary: { main: '#6fd056' },\n+  },\n+  typography: {\n+    useNextVariants: true,\n+  },\n+})\n+\n+ReactDOM.render(\n+  <MuiThemeProvider theme={theme}>\n+    <ApolloProvider client={client}>\n+      <App />\n+    </ApolloProvider>\n+  </MuiThemeProvider>\n+, document.getElementById('root'));\n+\n+// If you want your app to work offline and load faster, you can change\n+// unregister() to register() below. Note this comes with some pitfalls.\n+// Learn more about service workers: https://bit.ly/CRA-PWA\n+serviceWorker.unregister();\ndiff --git a/client/src/react-app-env.d.ts b/client/src/react-app-env.d.ts\nnew file mode 100644\nindex 0000000..c148f59\n--- /dev/null\n+++ b/client/src/react-app-env.d.ts\n@@ -0,0 +1,3 @@\n+/// <reference types=\"react-scripts\" />\n+\n+declare module \"react-router-transition\";\n\\ No newline at end of file\ndiff --git a/client/src/serviceWorker.ts b/client/src/serviceWorker.ts\nnew file mode 100644\nindex 0000000..15d90cb\n--- /dev/null\n+++ b/client/src/serviceWorker.ts\n@@ -0,0 +1,143 @@\n+// This optional code is used to register a service worker.\n+// register() is not called by default.\n+\n+// This lets the app load faster on subsequent visits in production, and gives\n+// it offline capabilities. However, it also means that developers (and users)\n+// will only see deployed updates on subsequent visits to a page, after all the\n+// existing tabs open on the page have been closed, since previously cached\n+// resources are updated in the background.\n+\n+// To learn more about the benefits of this model and instructions on how to\n+// opt-in, read https://bit.ly/CRA-PWA\n+\n+const isLocalhost = Boolean(\n+  window.location.hostname === 'localhost' ||\n+    // [::1] is the IPv6 localhost address.\n+    window.location.hostname === '[::1]' ||\n+    // 127.0.0.1/8 is considered localhost for IPv4.\n+    window.location.hostname.match(\n+      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n+    )\n+);\n+\n+type Config = {\n+  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n+  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n+};\n+\n+export function register(config?: Config) {\n+  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n+    // The URL constructor is available in all browsers that support SW.\n+    const publicUrl = new URL(\n+      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n+      window.location.href\n+    );\n+    if (publicUrl.origin !== window.location.origin) {\n+      // Our service worker won't work if PUBLIC_URL is on a different origin\n+      // from what our page is served on. This might happen if a CDN is used to\n+      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n+      return;\n+    }\n+\n+    window.addEventListener('load', () => {\n+      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n+\n+      if (isLocalhost) {\n+        // This is running on localhost. Let's check if a service worker still exists or not.\n+        checkValidServiceWorker(swUrl, config);\n+\n+        // Add some additional logging to localhost, pointing developers to the\n+        // service worker/PWA documentation.\n+        navigator.serviceWorker.ready.then(() => {\n+          console.log(\n+            'This web app is being served cache-first by a service ' +\n+              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n+          );\n+        });\n+      } else {\n+        // Is not localhost. Just register service worker\n+        registerValidSW(swUrl, config);\n+      }\n+    });\n+  }\n+}\n+\n+function registerValidSW(swUrl: string, config?: Config) {\n+  navigator.serviceWorker\n+    .register(swUrl)\n+    .then(registration => {\n+      registration.onupdatefound = () => {\n+        const installingWorker = registration.installing;\n+        if (installingWorker == null) {\n+          return;\n+        }\n+        installingWorker.onstatechange = () => {\n+          if (installingWorker.state === 'installed') {\n+            if (navigator.serviceWorker.controller) {\n+              // At this point, the updated precached content has been fetched,\n+              // but the previous service worker will still serve the older\n+              // content until all client tabs are closed.\n+              console.log(\n+                'New content is available and will be used when all ' +\n+                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n+              );\n+\n+              // Execute callback\n+              if (config && config.onUpdate) {\n+                config.onUpdate(registration);\n+              }\n+            } else {\n+              // At this point, everything has been precached.\n+              // It's the perfect time to display a\n+              // \"Content is cached for offline use.\" message.\n+              console.log('Content is cached for offline use.');\n+\n+              // Execute callback\n+              if (config && config.onSuccess) {\n+                config.onSuccess(registration);\n+              }\n+            }\n+          }\n+        };\n+      };\n+    })\n+    .catch(error => {\n+      console.error('Error during service worker registration:', error);\n+    });\n+}\n+\n+function checkValidServiceWorker(swUrl: string, config?: Config) {\n+  // Check if the service worker can be found. If it can't reload the page.\n+  fetch(swUrl)\n+    .then(response => {\n+      // Ensure service worker exists, and that we really are getting a JS file.\n+      const contentType = response.headers.get('content-type');\n+      if (\n+        response.status === 404 ||\n+        (contentType != null && contentType.indexOf('javascript') === -1)\n+      ) {\n+        // No service worker found. Probably a different app. Reload the page.\n+        navigator.serviceWorker.ready.then(registration => {\n+          registration.unregister().then(() => {\n+            window.location.reload();\n+          });\n+        });\n+      } else {\n+        // Service worker found. Proceed as normal.\n+        registerValidSW(swUrl, config);\n+      }\n+    })\n+    .catch(() => {\n+      console.log(\n+        'No internet connection found. App is running in offline mode.'\n+      );\n+    });\n+}\n+\n+export function unregister() {\n+  if ('serviceWorker' in navigator) {\n+    navigator.serviceWorker.ready.then(registration => {\n+      registration.unregister();\n+    });\n+  }\n+}\ndiff --git a/client/src/services/auth.service.tsx b/client/src/services/auth.service.tsx\nnew file mode 100644\nindex 0000000..8ae9e7f\n--- /dev/null\n+++ b/client/src/services/auth.service.tsx\n@@ -0,0 +1,92 @@\n+import React from 'react';\n+import { useContext } from 'react';\n+import { Redirect } from 'react-router-dom';\n+import client from '../client';\n+import { useMeQuery, User } from '../graphql/types';\n+import { useCacheService } from './cache.service';\n+import gql from 'graphql-tag';\n+\n+const MyContext = React.createContext<User|null>(null);\n+\n+export const useMe = () => {\n+  return useContext(MyContext);\n+};\n+\n+export const withAuth = <P extends object>(Component: React.ComponentType<P>) => {\n+  return (props: any) => {\n+    if (!isSignedIn()) {\n+      if (props.history.location.pathname === '/sign-in') {\n+        return null;\n+      }\n+\n+      return (\n+        <Redirect to=\"/sign-in\" />\n+      );\n+    }\n+\n+    const { data, error, loading } = useMeQuery();\n+\n+    useCacheService();\n+\n+    if (loading) return null;\n+\n+    if (data === undefined) return null;\n+\n+    if (error || !data.me) {\n+      signOut();\n+\n+      return <Redirect to=\"/sign-in\" />;\n+    }\n+\n+    return (\n+      <MyContext.Provider value={data.me}>\n+        <Component {...props as P} />\n+      </MyContext.Provider>\n+    );\n+  };\n+};\n+\n+export const signIn = ({ username, password }: { username: string, password: string}) => {\n+  return client.mutate({\n+    mutation: gql`\n+      mutation signIn($username: String!, $password: String!) {\n+        signIn(username: $username, password: $password) {\n+          id\n+        }\n+      }\n+    `,\n+    variables: {\n+      username,\n+      password\n+    }\n+  });\n+};\n+\n+export const signUp = ({ name, username, password, passwordConfirm }:\n+  {name: string, username: string, password: string, passwordConfirm: string}) => {\n+  return client.mutate({\n+    mutation: gql`\n+      mutation signUp($name: String!, $username: String!, $password: String!, $passwordConfirm: String!) {\n+        signUp(name: $name, username: $username, password: $password, passwordConfirm: $passwordConfirm) {\n+          id\n+        }\n+      }\n+    `,\n+    variables: {\n+      name,\n+      username,\n+      password,\n+      passwordConfirm\n+    }\n+  });\n+};\n+\n+export const signOut = () => {\n+  document.cookie = `authToken=;expires=${new Date(0)}`;\n+\n+  return client.clearStore();\n+};\n+\n+export const isSignedIn = () => {\n+  return /authToken=.+(;|$)/.test(document.cookie);\n+};\ndiff --git a/client/src/services/cache.service.ts b/client/src/services/cache.service.ts\nnew file mode 100644\nindex 0000000..0b54829\n--- /dev/null\n+++ b/client/src/services/cache.service.ts\n@@ -0,0 +1,188 @@\n+import { DataProxy } from 'apollo-cache';\n+import { defaultDataIdFromObject } from 'apollo-cache-inmemory';\n+import { ApolloClient } from 'apollo-client';\n+import * as fragments from '../graphql/fragments';\n+import * as queries from '../graphql/queries';\n+import {\n+  MessageFragment,\n+  ChatFragment,\n+  useMessageAddedSubscription,\n+  useChatAddedSubscription,\n+  useChatRemovedSubscription,\n+} from '../graphql/types';\n+\n+type Client = ApolloClient<any> | DataProxy;\n+\n+export const useCacheService = () => {\n+  useMessageAddedSubscription({\n+    onSubscriptionData: ({ client, subscriptionData: { data } }) => {\n+      if (data) {\n+        writeMessage(client, data.messageAdded);\n+      }\n+    }\n+  });\n+\n+  useChatAddedSubscription({\n+    onSubscriptionData: ({ client, subscriptionData: { data } }) => {\n+      if (data) {\n+        writeChat(client, data.chatAdded);\n+      }\n+    }\n+  });\n+\n+  useChatRemovedSubscription({\n+    onSubscriptionData: ({ client, subscriptionData: { data } }) => {\n+      if (data) {\n+        eraseChat(client, data.chatRemoved);\n+      }\n+    }\n+  });\n+};\n+\n+export const writeMessage = (client: Client, message: MessageFragment) => {\n+  type FullChat = { [key: string]: any };\n+  let fullChat;\n+\n+  const chatIdFromStore = defaultDataIdFromObject(message.chat);\n+\n+  if (chatIdFromStore === null) { return; }\n+  try {\n+    fullChat = client.readFragment<FullChat>({\n+      id: chatIdFromStore,\n+      fragment: fragments.fullChat,\n+      fragmentName: 'FullChat',\n+    })\n+  } catch (e) {\n+    return;\n+  }\n+\n+  if (fullChat === null || fullChat.messages === null) { return; }\n+  if (fullChat.messages.some((m: any) => m.id === message.id)) return;\n+\n+  fullChat.messages.push(message);\n+  fullChat.lastMessage = message;\n+\n+  client.writeFragment({\n+    id: chatIdFromStore,\n+    fragment: fragments.fullChat,\n+    fragmentName: 'FullChat',\n+    data: fullChat,\n+  });\n+\n+\n+  let data;\n+  try {\n+    data = client.readQuery({\n+      query: queries.chats,\n+    })\n+  } catch (e) {\n+    return;\n+  };\n+\n+  if (data === undefined || data.chats === undefined) {\n+    return null;\n+  }\n+\n+  const chats = data.chats;\n+  if (!chats) return;\n+\n+  const chatIndex = chats.findIndex((c: any) => {\n+    if (message === null || message.chat === null) return -1;\n+    return c.id === message.chat.id;\n+  });\n+  if (chatIndex === -1) return;\n+  const chatWhereAdded = chats[chatIndex];\n+\n+  // The chat will appear at the top of the ChatsList component\n+  chats.splice(chatIndex, 1);\n+  chats.unshift(chatWhereAdded);\n+\n+  client.writeQuery({\n+    query: queries.chats,\n+    data: { chats: chats },\n+  });\n+}\n+\n+export const writeChat = (client: Client, chat: ChatFragment) => {\n+\n+  const chatId = defaultDataIdFromObject(chat);\n+  if (chatId === null) {\n+    return;\n+  }\n+\n+  client.writeFragment({\n+    id: chatId,\n+    fragment: fragments.chat,\n+    fragmentName: 'Chat',\n+    data: chat,\n+  })\n+\n+  let data;\n+  try {\n+    data = client.readQuery({\n+      query: queries.chats,\n+    })\n+  } catch (e) {\n+    return;\n+  }\n+\n+  if (!data) return;\n+\n+  const chats = data.chats;\n+\n+  if (!chats) return;\n+  if (chats.some((c: any) => c.id === chat.id)) return;\n+\n+  chats.unshift(chat)\n+\n+  client.writeQuery({\n+    query: queries.chats,\n+    data: { chats },\n+  });\n+}\n+\n+export const eraseChat = (client: Client, chatId: string) => {\n+  const chatType = {\n+    __typename: 'Chat',\n+    id: chatId\n+  };\n+\n+  const chatIdFromObject = defaultDataIdFromObject(chatType);\n+  if (chatIdFromObject === null) {\n+    return;\n+  }\n+\n+  client.writeFragment({\n+    id: chatIdFromObject,\n+    fragment: fragments.fullChat,\n+    fragmentName: 'FullChat',\n+    data: null,\n+  })\n+\n+  let data;\n+  try {\n+    data = client.readQuery({\n+      query: queries.chats,\n+    });\n+  } catch (e) {\n+    return;\n+  }\n+\n+  if (!data || !data.chats) return;\n+\n+  const chats = data.chats;\n+\n+  if (!chats) return;\n+\n+  const chatIndex = chats.findIndex((c: any) => c.id === chatId);\n+\n+  if (chatIndex === -1) return;\n+\n+  // The chat will appear at the top of the ChatsList component\n+  chats.splice(chatIndex, 1);\n+\n+  client.writeQuery({\n+    query: queries.chats,\n+    data: { chats: chats },\n+  });\n+}\ndiff --git a/client/src/setupTests.ts b/client/src/setupTests.ts\nnew file mode 100644\nindex 0000000..c42be90\n--- /dev/null\n+++ b/client/src/setupTests.ts\n@@ -0,0 +1,7 @@\n+import 'jest-dom/extend-expect'\n+import { GlobalWithFetchMock } from 'jest-fetch-mock'\n+import { act } from 'react-testing-library'\n+\n+const customGlobal: GlobalWithFetchMock = global as GlobalWithFetchMock\n+customGlobal.fetch = require('jest-fetch-mock')\n+customGlobal.fetchMock = customGlobal.fetch\ndiff --git a/client/src/test-helpers.ts b/client/src/test-helpers.ts\nnew file mode 100644\nindex 0000000..82ecfdc\n--- /dev/null\n+++ b/client/src/test-helpers.ts\n@@ -0,0 +1,10 @@\n+import { InMemoryCache } from 'apollo-cache-inmemory';\n+import { ApolloClient } from 'apollo-client';\n+import { MockLink } from 'apollo-link-mock';\n+\n+export const mockApolloClient = (mocks: any) => {\n+  return new ApolloClient({\n+    cache: new InMemoryCache(),\n+    link: new MockLink(mocks),\n+  });\n+};\ndiff --git a/client/tsconfig.json b/client/tsconfig.json\nnew file mode 100644\nindex 0000000..0980b23\n--- /dev/null\n+++ b/client/tsconfig.json\n@@ -0,0 +1,25 @@\n+{\n+  \"compilerOptions\": {\n+    \"target\": \"es5\",\n+    \"lib\": [\n+      \"dom\",\n+      \"dom.iterable\",\n+      \"esnext\"\n+    ],\n+    \"allowJs\": true,\n+    \"skipLibCheck\": true,\n+    \"esModuleInterop\": true,\n+    \"allowSyntheticDefaultImports\": true,\n+    \"strict\": true,\n+    \"forceConsistentCasingInFileNames\": true,\n+    \"module\": \"esnext\",\n+    \"moduleResolution\": \"node\",\n+    \"resolveJsonModule\": true,\n+    \"isolatedModules\": true,\n+    \"noEmit\": true,\n+    \"jsx\": \"preserve\"\n+  },\n+  \"include\": [\n+    \"src\"\n+  ]\n+}\ndiff --git a/package.json b/package.json\nnew file mode 100644\nindex 0000000..008b058\n--- /dev/null\n+++ b/package.json\n@@ -0,0 +1,9 @@\n+{\n+  \"name\": \"whatsapp-clone-tutorial\",\n+  \"description\": \"A newly created Tortilla project\",\n+  \"private\": true,\n+  \"repository\": {\n+    \"type\": \"git\",\n+    \"url\": \"https://github.com/Urigo/WhatsApp-Clone-Tutorial.git\"\n+  }\n+}\ndiff --git a/server/.gitignore b/server/.gitignore\nnew file mode 100644\nindex 0000000..ba92242\n--- /dev/null\n+++ b/server/.gitignore\n@@ -0,0 +1,4 @@\n+node_modules\n+npm-debug.log\n+types/graphql.d.ts\n+types/unsplash.d.ts\ndiff --git a/server/app.ts b/server/app.ts\nnew file mode 100644\nindex 0000000..943a214\n--- /dev/null\n+++ b/server/app.ts\n@@ -0,0 +1,15 @@\n+import bodyParser from 'body-parser'\n+import cors from 'cors'\n+import cookieParser from 'cookie-parser'\n+import express from 'express'\n+import { origin } from './env'\n+\n+export const app = express()\n+\n+app.use(cors({ credentials: true, origin }))\n+app.use(bodyParser.json())\n+app.use(cookieParser())\n+\n+app.get('/_ping', (req, res) => {\n+  res.send('pong')\n+})\ndiff --git a/server/codegen.yml b/server/codegen.yml\nnew file mode 100644\nindex 0000000..9542ce7\n--- /dev/null\n+++ b/server/codegen.yml\n@@ -0,0 +1,23 @@\n+overwrite: true\n+generates:\n+  ./types/graphql.d.ts:\n+    schema: ./modules/*/*.ts\n+    plugins:\n+      - typescript\n+      - typescript-resolvers\n+    config:\n+      useIndexSignature: true\n+      contextType: ../context#MyContext\n+      mappers:\n+        # import { Message } from '../db'\n+        # The root types of Message resolvers\n+        User: ../db#User\n+        Message: ../db#Message\n+        Chat: ../db#Chat\n+      scalars:\n+        # e.g. Message.createdAt will be of type Date\n+        Date: Date\n+  ./types/unsplash.d.ts:\n+    schema: ./logs/main/Unsplash.RandomPhoto.graphql\n+    plugins:\n+      - typescript\ndiff --git a/server/context.ts b/server/context.ts\nnew file mode 100644\nindex 0000000..c9ac74a\n--- /dev/null\n+++ b/server/context.ts\n@@ -0,0 +1,3 @@\n+import { ModuleContext } from '@graphql-modules/core';\n+\n+export type MyContext = ModuleContext;\ndiff --git a/server/db.ts b/server/db.ts\nnew file mode 100644\nindex 0000000..cd3c287\n--- /dev/null\n+++ b/server/db.ts\n@@ -0,0 +1,200 @@\n+import { Pool } from \"pg\";\n+import sql from 'sql-template-strings'\n+import { resetDb as envResetDb } from './env'\n+\n+export type User = {\n+  id: string\n+  name: string\n+  username: string\n+  password: string\n+  picture: string\n+}\n+\n+export type Message = {\n+  id: string\n+  content: string\n+  created_at: Date\n+  chat_id: string\n+  sender_user_id: string\n+}\n+\n+export type Chat = {\n+  id: string\n+}\n+\n+export const pool = new Pool({\n+  host: 'localhost',\n+  port: 5432,\n+  user: 'testuser',\n+  password: 'testpassword',\n+  database: 'whatsapp'\n+})\n+\n+export const resetDb = async () => {\n+\n+  await pool.query(sql`DELETE FROM users`)\n+\n+  const sampleUsers = [\n+    {\n+      id: '1',\n+      name: 'Ray Edwards',\n+      username: 'ray',\n+      password: '$2a$08$NO9tkFLCoSqX1c5wk3s7z.JfxaVMKA.m7zUDdDwEquo4rvzimQeJm', // 111\n+      picture: 'https://randomuser.me/api/portraits/thumb/lego/1.jpg',\n+    },\n+    {\n+      id: '2',\n+      name: 'Ethan Gonzalez',\n+      username: 'ethan',\n+      password: '$2a$08$xE4FuCi/ifxjL2S8CzKAmuKLwv18ktksSN.F3XYEnpmcKtpbpeZgO', // 222\n+      picture: 'https://randomuser.me/api/portraits/thumb/men/1.jpg',\n+    },\n+    {\n+      id: '3',\n+      name: 'Bryan Wallace',\n+      username: 'bryan',\n+      password: '$2a$08$UHgH7J8G6z1mGQn2qx2kdeWv0jvgHItyAsL9hpEUI3KJmhVW5Q1d.', // 333\n+      picture: 'https://randomuser.me/api/portraits/thumb/men/2.jpg',\n+    },\n+    {\n+      id: '4',\n+      name: 'Avery Stewart',\n+      username: 'avery',\n+      password: '$2a$08$wR1k5Q3T9FC7fUgB7Gdb9Os/GV7dGBBf4PLlWT7HERMFhmFDt47xi', // 444\n+      picture: 'https://randomuser.me/api/portraits/thumb/women/1.jpg',\n+    },\n+    {\n+      id: '5',\n+      name: 'Katie Peterson',\n+      username: 'katie',\n+      password: '$2a$08$6.mbXqsDX82ZZ7q5d8Osb..JrGSsNp4R3IKj7mxgF6YGT0OmMw242', // 555\n+      picture: 'https://randomuser.me/api/portraits/thumb/women/2.jpg',\n+    },\n+  ]\n+\n+  for (const sampleUser of sampleUsers) {\n+    await pool.query(sql`\n+      INSERT INTO users(id, name, username, password, picture)\n+      VALUES(${sampleUser.id}, ${sampleUser.name}, ${sampleUser.username}, ${sampleUser.password}, ${sampleUser.picture})\n+    `)\n+  }\n+\n+  await pool.query(sql`SELECT setval('users_id_seq', (SELECT max(id) FROM users))`)\n+\n+  await pool.query(sql`DELETE FROM chats`)\n+\n+  const sampleChats = [\n+    {\n+      id: '1',\n+    },\n+    {\n+      id: '2',\n+    },\n+    {\n+      id: '3',\n+    },\n+    {\n+      id: '4',\n+    },\n+  ]\n+\n+  for (const sampleChat of sampleChats) {\n+    await pool.query(sql`\n+      INSERT INTO chats(id)\n+      VALUES(${sampleChat.id})\n+    `)\n+  }\n+\n+  await pool.query(sql`SELECT setval('chats_id_seq', (SELECT max(id) FROM chats))`)\n+\n+  await pool.query(sql`DELETE FROM chats_users`)\n+\n+  const sampleChatsUsers = [\n+    {\n+      chat_id: '1',\n+      user_id: '1',\n+    },\n+    {\n+      chat_id: '1',\n+      user_id: '2',\n+    },\n+    {\n+      chat_id: '2',\n+      user_id: '1',\n+    },\n+    {\n+      chat_id: '2',\n+      user_id: '3',\n+    },\n+    {\n+      chat_id: '3',\n+      user_id: '1',\n+    },\n+    {\n+      chat_id: '3',\n+      user_id: '4',\n+    },\n+    {\n+      chat_id: '4',\n+      user_id: '1',\n+    },\n+    {\n+      chat_id: '4',\n+      user_id: '5',\n+    },\n+  ]\n+\n+  for (const sampleChatUser of sampleChatsUsers) {\n+    await pool.query(sql`\n+      INSERT INTO chats_users(chat_id, user_id)\n+      VALUES(${sampleChatUser.chat_id}, ${sampleChatUser.user_id})\n+    `)\n+  }\n+\n+  await pool.query(sql`DELETE FROM messages`)\n+\n+  const sampleMessages = [\n+    {\n+      id: '1',\n+      content: \"You on your way?\",\n+      created_at: new Date(new Date('1-1-2019').getTime() - 60 * 1000 * 1000),\n+      chat_id: '1',\n+      sender_user_id: '1',\n+    },\n+    {\n+      id: '2',\n+      content: \"Hey, it's me\",\n+      created_at: new Date(new Date('1-1-2019').getTime() - 2 * 60 * 1000 * 1000),\n+      chat_id: '2',\n+      sender_user_id: '1',\n+    },\n+    {\n+      id: '3',\n+      content: \"I should buy a boat\",\n+      created_at: new Date(new Date('1-1-2019').getTime() - 24 * 60 * 1000 * 1000),\n+      chat_id: '3',\n+      sender_user_id: '1',\n+    },\n+    {\n+      id: '4',\n+      content: \"This is wicked good ice cream.\",\n+      created_at: new Date(new Date('1-1-2019').getTime() - 14 * 24 * 60 * 1000 * 1000),\n+      chat_id: '4',\n+      sender_user_id: '1',\n+    },\n+  ]\n+\n+  for (const sampleMessage of sampleMessages) {\n+    await pool.query(sql`\n+      INSERT INTO messages(id, content, created_at, chat_id, sender_user_id)\n+      VALUES(${sampleMessage.id}, ${sampleMessage.content}, ${sampleMessage.created_at}, ${sampleMessage.chat_id}, ${sampleMessage.sender_user_id})\n+    `)\n+  }\n+\n+  await pool.query(sql`SELECT setval('messages_id_seq', (SELECT max(id) FROM messages))`)\n+\n+}\n+\n+if (envResetDb) {\n+  resetDb()\n+}\ndiff --git a/server/env.ts b/server/env.ts\nnew file mode 100644\nindex 0000000..d6b5023\n--- /dev/null\n+++ b/server/env.ts\n@@ -0,0 +1,7 @@\n+export const expiration = process.env.JWT_EXPIRATION_MS\n+  ?  parseInt(process.env.JWT_EXPIRATION_MS)\n+  : 24 * 60 * 60 * 1000\n+export const secret = process.env.JWT_SECRET || '70p53cr37'\n+export const origin = process.env.ORIGIN || 'http://localhost:3000'\n+export const port = process.env.PORT || 4000\n+export const resetDb = process.env.RESET_DB || false;\ndiff --git a/server/index.ts b/server/index.ts\nnew file mode 100644\nindex 0000000..39dd8b0\n--- /dev/null\n+++ b/server/index.ts\n@@ -0,0 +1,17 @@\n+import http from 'http'\n+import { app } from './app'\n+import { origin, port } from './env'\n+import { server } from './server';\n+\n+server.applyMiddleware({\n+  app,\n+  path: '/graphql',\n+  cors: { credentials: true, origin },\n+})\n+\n+const httpServer = http.createServer(app)\n+server.installSubscriptionHandlers(httpServer)\n+\n+httpServer.listen(port, () => {\n+  console.log(`Server is listening on port ${port}`)\n+})\ndiff --git a/server/logs/main/Unsplash.RandomPhoto.2019-05-09T14:45:43.850Z.graphql b/server/logs/main/Unsplash.RandomPhoto.2019-05-09T14:45:43.850Z.graphql\nnew file mode 100644\nindex 0000000..20139fc\n--- /dev/null\n+++ b/server/logs/main/Unsplash.RandomPhoto.2019-05-09T14:45:43.850Z.graphql\n@@ -0,0 +1,103 @@\n+type Exif {\n+  make: String!\n+  model: String!\n+  exposure_time: String!\n+  aperture: String!\n+  focal_length: String!\n+  iso: Int!\n+}\n+\n+scalar JSON\n+\n+type Links {\n+  self: String!\n+  html: String!\n+  download: String\n+  download_location: String\n+  photos: String\n+  likes: String\n+  portfolio: String\n+  following: String\n+  followers: String\n+}\n+\n+type Location {\n+  title: String!\n+  name: String!\n+  city: String!\n+  country: String!\n+  position: Position!\n+}\n+\n+type Position {\n+  latitude: Int!\n+  longitude: Int!\n+}\n+\n+type Profile_image {\n+  small: String!\n+  medium: String!\n+  large: String!\n+}\n+\n+type RandomPhoto {\n+  id: String!\n+  created_at: String!\n+  updated_at: String!\n+  width: Int!\n+  height: Int!\n+  color: String!\n+  description: JSON\n+  alt_description: String!\n+  urls: Urls!\n+  links: Links!\n+  categories: [JSON]!\n+  sponsored: Boolean!\n+  sponsored_by: JSON\n+  sponsored_impressions_id: JSON\n+  likes: Int!\n+  liked_by_user: Boolean!\n+  current_user_collections: [JSON]!\n+  user: User!\n+  exif: Exif!\n+  location: Location!\n+  views: Int!\n+  downloads: Int!\n+}\n+\n+input RandomPhotoInput {\n+  query: String!\n+  orientation: String!\n+}\n+\n+type Root {\n+  RandomPhoto(input: RandomPhotoInput): RandomPhoto\n+}\n+\n+type Urls {\n+  raw: String!\n+  full: String!\n+  regular: String!\n+  small: String!\n+  thumb: String!\n+}\n+\n+type User {\n+  id: String!\n+  updated_at: String!\n+  username: String!\n+  name: String!\n+  first_name: String!\n+  last_name: String!\n+  twitter_username: String!\n+  portfolio_url: String!\n+  bio: String!\n+  location: String!\n+  links: Links!\n+  profile_image: Profile_image!\n+  instagram_username: String!\n+  total_collections: Int!\n+  total_likes: Int!\n+  total_photos: Int!\n+  accepted_tos: Boolean!\n+}\ndiff --git a/server/logs/main/Unsplash.RandomPhoto.2019-05-09T14:45:45.197Z.graphql b/server/logs/main/Unsplash.RandomPhoto.2019-05-09T14:45:45.197Z.graphql\nnew file mode 100644\nindex 0000000..02152a8\n--- /dev/null\n+++ b/server/logs/main/Unsplash.RandomPhoto.2019-05-09T14:45:45.197Z.graphql\n@@ -0,0 +1,103 @@\n+type Exif {\n+  make: String!\n+  model: String!\n+  exposure_time: String!\n+  aperture: String!\n+  focal_length: String!\n+  iso: Int!\n+}\n+\n+scalar JSON\n+\n+type Links {\n+  self: String!\n+  html: String!\n+  download: String\n+  download_location: String\n+  photos: String\n+  likes: String\n+  portfolio: String\n+  following: String\n+  followers: String\n+}\n+\n+type Location {\n+  title: String!\n+  name: String!\n+  city: String!\n+  country: String!\n+  position: Position!\n+}\n+\n+type Position {\n+  latitude: Int!\n+  longitude: Int!\n+}\n+\n+type Profile_image {\n+  small: String!\n+  medium: String!\n+  large: String!\n+}\n+\n+type RandomPhoto {\n+  id: String!\n+  created_at: String!\n+  updated_at: String!\n+  width: Int!\n+  height: Int!\n+  color: String!\n+  description: String!\n+  alt_description: String!\n+  urls: Urls!\n+  links: Links!\n+  categories: [JSON]!\n+  sponsored: Boolean!\n+  sponsored_by: JSON\n+  sponsored_impressions_id: JSON\n+  likes: Int!\n+  liked_by_user: Boolean!\n+  current_user_collections: [JSON]!\n+  user: User!\n+  exif: Exif!\n+  location: Location!\n+  views: Int!\n+  downloads: Int!\n+}\n+\n+input RandomPhotoInput {\n+  query: String!\n+  orientation: String!\n+}\n+\n+type Root {\n+  RandomPhoto(input: RandomPhotoInput): RandomPhoto\n+}\n+\n+type Urls {\n+  raw: String!\n+  full: String!\n+  regular: String!\n+  small: String!\n+  thumb: String!\n+}\n+\n+type User {\n+  id: String!\n+  updated_at: String!\n+  username: String!\n+  name: String!\n+  first_name: String!\n+  last_name: String!\n+  twitter_username: String!\n+  portfolio_url: JSON\n+  bio: String!\n+  location: String!\n+  links: Links!\n+  profile_image: Profile_image!\n+  instagram_username: String!\n+  total_collections: Int!\n+  total_likes: Int!\n+  total_photos: Int!\n+  accepted_tos: Boolean!\n+}\ndiff --git a/server/logs/main/Unsplash.RandomPhoto.graphql b/server/logs/main/Unsplash.RandomPhoto.graphql\nnew file mode 100644\nindex 0000000..c412c9c\n--- /dev/null\n+++ b/server/logs/main/Unsplash.RandomPhoto.graphql\n@@ -0,0 +1,103 @@\n+type Exif {\n+  make: String!\n+  model: String!\n+  exposure_time: String!\n+  aperture: String!\n+  focal_length: String!\n+  iso: Int!\n+}\n+\n+scalar JSON\n+\n+type Links {\n+  self: String!\n+  html: String!\n+  download: String\n+  download_location: String\n+  photos: String\n+  likes: String\n+  portfolio: String\n+  following: String\n+  followers: String\n+}\n+\n+type Location {\n+  title: String!\n+  name: String!\n+  city: String!\n+  country: String!\n+  position: Position!\n+}\n+\n+type Position {\n+  latitude: Int!\n+  longitude: Int!\n+}\n+\n+type Profile_image {\n+  small: String!\n+  medium: String!\n+  large: String!\n+}\n+\n+type RandomPhoto {\n+  id: String!\n+  created_at: String!\n+  updated_at: String!\n+  width: Int!\n+  height: Int!\n+  color: String!\n+  description: String!\n+  alt_description: String!\n+  urls: Urls!\n+  links: Links!\n+  categories: [JSON]!\n+  sponsored: Boolean!\n+  sponsored_by: JSON\n+  sponsored_impressions_id: JSON\n+  likes: Int!\n+  liked_by_user: Boolean!\n+  current_user_collections: [JSON]!\n+  user: User!\n+  exif: Exif!\n+  location: Location!\n+  views: Int!\n+  downloads: Int!\n+}\n+\n+input RandomPhotoInput {\n+  query: String!\n+  orientation: String!\n+}\n+\n+type Root {\n+  RandomPhoto(input: RandomPhotoInput): RandomPhoto\n+}\n+\n+type Urls {\n+  raw: String!\n+  full: String!\n+  regular: String!\n+  small: String!\n+  thumb: String!\n+}\n+\n+type User {\n+  id: String!\n+  updated_at: String!\n+  username: String!\n+  name: String!\n+  first_name: String!\n+  last_name: String!\n+  twitter_username: JSON\n+  portfolio_url: JSON\n+  bio: JSON\n+  location: String!\n+  links: Links!\n+  profile_image: Profile_image!\n+  instagram_username: String!\n+  total_collections: Int!\n+  total_likes: Int!\n+  total_photos: Int!\n+  accepted_tos: Boolean!\n+}\ndiff --git a/server/modules/chats/chats.provider.ts b/server/modules/chats/chats.provider.ts\nnew file mode 100644\nindex 0000000..3659604\n--- /dev/null\n+++ b/server/modules/chats/chats.provider.ts\n@@ -0,0 +1,216 @@\n+import { Injectable, Inject, ProviderScope } from '@graphql-modules/di';\n+import sql from 'sql-template-strings';\n+import { Database } from '../common/database.provider';\n+import { PubSub } from '../common/pubsub.provider';\n+\n+@Injectable({\n+  scope: ProviderScope.Session,\n+})\n+export class Chats {\n+  @Inject() private db: Database;\n+  @Inject() private pubsub: PubSub;\n+\n+  async findChatsByUser(userId: string) {\n+    const db = await this.db.getClient();\n+\n+    const { rows } = await db.query(sql`\n+      SELECT chats.* FROM chats, chats_users\n+      WHERE chats.id = chats_users.chat_id\n+      AND chats_users.user_id = ${userId}\n+    `);\n+\n+    return rows;\n+  }\n+\n+  async findChatByUser({ chatId, userId }: { chatId: string; userId: string }) {\n+    const db = await this.db.getClient();\n+    const { rows } = await db.query(sql`\n+      SELECT chats.* FROM chats, chats_users\n+      WHERE chats_users.chat_id = ${chatId}\n+      AND chats.id = chats_users.chat_id\n+      AND chats_users.user_id = ${userId}\n+    `);\n+\n+    return rows[0] || null;\n+  }\n+\n+  async findChatById(chatId: string) {\n+    const db = await this.db.getClient();\n+    const { rows } = await db.query(sql`\n+      SELECT * FROM chats WHERE id = ${chatId}\n+    `);\n+    return rows[0] || null;\n+  }\n+\n+  async findMessagesByChat(chatId: string) {\n+    const db = await this.db.getClient();\n+    const { rows } = await db.query(\n+      sql`SELECT * FROM messages WHERE chat_id = ${chatId}`,\n+    );\n+\n+    return rows;\n+  }\n+\n+  async lastMessage(chatId: string) {\n+    const db = await this.db.getClient();\n+    const { rows } = await db.query(sql`\n+      SELECT * FROM messages\n+      WHERE chat_id = ${chatId}\n+      ORDER BY created_at DESC\n+      LIMIT 1\n+    `);\n+\n+    return rows[0];\n+  }\n+\n+  async firstRecipient({ chatId, userId }: { chatId: string; userId: string }) {\n+    const db = await this.db.getClient();\n+    const { rows } = await db.query(sql`\n+      SELECT users.* FROM users, chats_users\n+      WHERE users.id != ${userId}\n+      AND users.id = chats_users.user_id\n+      AND chats_users.chat_id = ${chatId}\n+    `);\n+\n+    return rows[0] || null;\n+  }\n+\n+  async participants(chatId: string) {\n+    const db = await this.db.getClient();\n+    const { rows } = await db.query(sql`\n+      SELECT users.* FROM users, chats_users\n+      WHERE chats_users.chat_id = ${chatId}\n+      AND chats_users.user_id = users.id\n+    `);\n+\n+    return rows;\n+  }\n+\n+  async isParticipant({ chatId, userId }: { chatId: string; userId: string }) {\n+    const db = await this.db.getClient();\n+    const { rows } = await db.query(sql`\n+      SELECT * FROM chats_users\n+      WHERE chat_id = ${chatId}\n+      AND user_id = ${userId}\n+    `);\n+\n+    return !!rows.length;\n+  }\n+\n+  async addMessage({\n+    chatId,\n+    userId,\n+    content,\n+  }: {\n+    chatId: string;\n+    userId: string;\n+    content: string;\n+  }) {\n+    const db = await this.db.getClient();\n+    const { rows } = await db.query(sql`\n+      INSERT INTO messages(chat_id, sender_user_id, content)\n+      VALUES(${chatId}, ${userId}, ${content})\n+      RETURNING *\n+    `);\n+\n+    const messageAdded = rows[0];\n+\n+    this.pubsub.publish('messageAdded', {\n+      messageAdded,\n+    });\n+\n+    return messageAdded;\n+  }\n+\n+  async addChat({\n+    userId,\n+    recipientId,\n+  }: {\n+    userId: string;\n+    recipientId: string;\n+  }) {\n+    const db = await this.db.getClient();\n+    const { rows } = await db.query(sql`\n+      SELECT chats.* FROM chats, (SELECT * FROM chats_users WHERE user_id = ${userId}) AS chats_of_current_user, chats_users\n+      WHERE chats_users.chat_id = chats_of_current_user.chat_id\n+      AND chats.id = chats_users.chat_id\n+      AND chats_users.user_id = ${recipientId}\n+    `);\n+\n+    // If there is already a chat between these two users, return it\n+    if (rows[0]) {\n+      return rows[0];\n+    }\n+\n+    try {\n+      await db.query('BEGIN');\n+\n+      const { rows } = await db.query(sql`\n+        INSERT INTO chats\n+        DEFAULT VALUES\n+        RETURNING *\n+      `);\n+\n+      const chatAdded = rows[0];\n+\n+      await db.query(sql`\n+        INSERT INTO chats_users(chat_id, user_id)\n+        VALUES(${chatAdded.id}, ${userId})\n+      `);\n+\n+      await db.query(sql`\n+        INSERT INTO chats_users(chat_id, user_id)\n+        VALUES(${chatAdded.id}, ${recipientId})\n+      `);\n+\n+      await db.query('COMMIT');\n+\n+      this.pubsub.publish('chatAdded', {\n+        chatAdded,\n+      });\n+\n+      return chatAdded;\n+    } catch (e) {\n+      await db.query('ROLLBACK');\n+      throw e;\n+    }\n+  }\n+\n+  async removeChat({ chatId, userId }: { chatId: string; userId: string }) {\n+    const db = await this.db.getClient();\n+\n+    try {\n+      await db.query('BEGIN');\n+\n+      const { rows } = await db.query(sql`\n+        SELECT chats.* FROM chats, chats_users\n+        WHERE id = ${chatId}\n+        AND chats.id = chats_users.chat_id\n+        AND chats_users.user_id = ${userId}\n+      `);\n+\n+      const chat = rows[0];\n+\n+      if (!chat) {\n+        await db.query('ROLLBACK');\n+        return null;\n+      }\n+\n+      await db.query(sql`\n+        DELETE FROM chats WHERE chats.id = ${chatId}\n+      `);\n+\n+      this.pubsub.publish('chatRemoved', {\n+        chatRemoved: chat.id,\n+        targetChat: chat,\n+      });\n+\n+      await db.query('COMMIT');\n+\n+      return chatId;\n+    } catch (e) {\n+      await db.query('ROLLBACK');\n+      throw e;\n+    }\n+  }\n+}\ndiff --git a/server/modules/chats/index.ts b/server/modules/chats/index.ts\nnew file mode 100644\nindex 0000000..a8dd8ff\n--- /dev/null\n+++ b/server/modules/chats/index.ts\n@@ -0,0 +1,242 @@\n+import { GraphQLModule } from '@graphql-modules/core';\n+import { gql, withFilter } from 'apollo-server-express';\n+import commonModule from '../common';\n+import usersModule from '../users';\n+import { Message, Chat } from '../../db';\n+import { Resolvers } from '../../types/graphql';\n+import { UnsplashApi } from './unsplash.api';\n+import { Users } from './../users/users.provider';\n+import { Auth } from './../users/auth.provider';\n+import { Chats } from './chats.provider';\n+import { PubSub } from '../common/pubsub.provider';\n+\n+const typeDefs = gql`\n+  type Message {\n+    id: ID!\n+    content: String!\n+    createdAt: DateTime!\n+    chat: Chat\n+    sender: User\n+    recipient: User\n+    isMine: Boolean!\n+  }\n+\n+  type Chat {\n+    id: ID!\n+    name: String\n+    picture: String\n+    lastMessage: Message\n+    messages: [Message!]!\n+    participants: [User!]!\n+  }\n+\n+  extend type Query {\n+    chats: [Chat!]!\n+    chat(chatId: ID!): Chat\n+  }\n+\n+  extend type Mutation {\n+    addMessage(chatId: ID!, content: String!): Message\n+    addChat(recipientId: ID!): Chat\n+    removeChat(chatId: ID!): ID\n+  }\n+\n+  extend type Subscription {\n+    messageAdded: Message!\n+    chatAdded: Chat!\n+    chatRemoved: ID!\n+  }\n+`;\n+\n+const resolvers: Resolvers = {\n+  Message: {\n+    createdAt(message) {\n+      return new Date(message.created_at);\n+    },\n+\n+    async chat(message, args, { injector }) {\n+      return injector.get(Chats).findChatById(message.chat_id);\n+    },\n+\n+    async sender(message, args, { injector }) {\n+      return injector.get(Users).findById(message.sender_user_id);\n+    },\n+\n+    async recipient(message, args, { injector }) {\n+      return injector.get(Chats).firstRecipient({\n+        chatId: message.chat_id,\n+        userId: message.sender_user_id,\n+      });\n+    },\n+\n+    async isMine(message, args, { injector }) {\n+      const currentUser = await injector.get(Auth).currentUser();\n+      return message.sender_user_id === currentUser!.id;\n+    },\n+  },\n+\n+  Chat: {\n+    async name(chat, args, { injector }) {\n+      const currentUser = await injector.get(Auth).currentUser();\n+\n+      if (!currentUser) return null;\n+\n+      const participant = await injector.get(Chats).firstRecipient({\n+        chatId: chat.id,\n+        userId: currentUser.id,\n+      });\n+\n+      return participant ? participant.name : null;\n+    },\n+\n+    async picture(chat, args, { injector }) {\n+      const currentUser = await injector.get(Auth).currentUser();\n+\n+      if (!currentUser) return null;\n+\n+      const participant = await injector.get(Chats).firstRecipient({\n+        chatId: chat.id,\n+        userId: currentUser.id,\n+      });\n+\n+      return participant && participant.picture\n+        ? participant.picture\n+        : injector.get(UnsplashApi).getRandomPhoto();\n+    },\n+\n+    async messages(chat, args, { injector }) {\n+      return injector.get(Chats).findMessagesByChat(chat.id);\n+    },\n+\n+    async lastMessage(chat, args, { injector }) {\n+      return injector.get(Chats).lastMessage(chat.id);\n+    },\n+\n+    async participants(chat, args, { injector }) {\n+      return injector.get(Chats).participants(chat.id);\n+    },\n+  },\n+\n+  Query: {\n+    async chats(root, args, { injector }) {\n+      const currentUser = await injector.get(Auth).currentUser();\n+\n+      if (!currentUser) return [];\n+\n+      return injector.get(Chats).findChatsByUser(currentUser.id);\n+    },\n+\n+    async chat(root, { chatId }, { injector }) {\n+      const currentUser = await injector.get(Auth).currentUser();\n+\n+      if (!currentUser) return null;\n+\n+      return injector\n+        .get(Chats)\n+        .findChatByUser({ chatId, userId: currentUser.id });\n+    },\n+  },\n+\n+  Mutation: {\n+    async addMessage(root, { chatId, content }, { injector }) {\n+      const currentUser = await injector.get(Auth).currentUser();\n+\n+      if (!currentUser) return null;\n+\n+      return injector\n+        .get(Chats)\n+        .addMessage({ chatId, content, userId: currentUser.id });\n+    },\n+\n+    async addChat(root, { recipientId }, { injector }) {\n+      const currentUser = await injector.get(Auth).currentUser();\n+\n+      if (!currentUser) return null;\n+\n+      return injector\n+        .get(Chats)\n+        .addChat({ recipientId, userId: currentUser.id });\n+    },\n+\n+    async removeChat(root, { chatId }, { injector }) {\n+      const currentUser = await injector.get(Auth).currentUser();\n+\n+      if (!currentUser) return null;\n+\n+      return injector.get(Chats).removeChat({ chatId, userId: currentUser.id });\n+    },\n+  },\n+\n+  Subscription: {\n+    messageAdded: {\n+      subscribe: withFilter(\n+        (root, args, { injector }) =>\n+          injector.get(PubSub).asyncIterator('messageAdded'),\n+        async (\n+          { messageAdded }: { messageAdded: Message },\n+          args,\n+          { injector },\n+        ) => {\n+          const currentUser = await injector.get(Auth).currentUser();\n+\n+          if (!currentUser) return false;\n+\n+          return injector.get(Chats).isParticipant({\n+            chatId: messageAdded.chat_id,\n+            userId: currentUser.id,\n+          });\n+        },\n+      ),\n+    },\n+\n+    chatAdded: {\n+      subscribe: withFilter(\n+        (root, args, { injector }) =>\n+          injector.get(PubSub).asyncIterator('chatAdded'),\n+        async (\n+          { chatAdded }: { chatAdded: Chat },\n+          args,\n+          { injector },\n+        ) => {\n+          const currentUser = await injector.get(Auth).currentUser();\n+\n+          if (!currentUser) return false;\n+\n+          return injector.get(Chats).isParticipant({\n+            chatId: chatAdded.id,\n+            userId: currentUser.id,\n+          });\n+        },\n+      ),\n+    },\n+\n+    chatRemoved: {\n+      subscribe: withFilter(\n+        (root, args, { injector }) =>\n+          injector.get(PubSub).asyncIterator('chatRemoved'),\n+        async (\n+          { targetChat }: { targetChat: Chat },\n+          args,\n+          { injector },\n+        ) => {\n+          const currentUser = await injector.get(Auth).currentUser();\n+\n+          if (!currentUser) return false;\n+\n+          return injector.get(Chats).isParticipant({\n+            chatId: targetChat.id,\n+            userId: currentUser.id,\n+          });\n+        },\n+      ),\n+    },\n+  },\n+};\n+\n+export default new GraphQLModule({\n+  name: 'chats',\n+  typeDefs,\n+  resolvers,\n+  imports: () => [commonModule, usersModule],\n+  providers: () => [UnsplashApi, Chats],\n+});\ndiff --git a/server/modules/chats/unsplash.api.ts b/server/modules/chats/unsplash.api.ts\nnew file mode 100644\nindex 0000000..cb993f0\n--- /dev/null\n+++ b/server/modules/chats/unsplash.api.ts\n@@ -0,0 +1,52 @@\n+import { Injectable, ProviderScope } from '@graphql-modules/di';\n+import { resolve } from 'path';\n+import axios from 'axios';\n+import { trackProvider } from '@safe-api/middleware';\n+import { RandomPhoto } from '../../types/unsplash';\n+\n+interface RandomPhotoInput {\n+  query: string;\n+  orientation: 'landscape' | 'portrait' | 'squarish';\n+}\n+\n+@Injectable({\n+  scope: ProviderScope.Application,\n+})\n+export class UnsplashApi {\n+  baseURL = 'https://api.unsplash.com/';\n+\n+  async getRandomPhoto() {\n+    const trackedRandomPhoto = await trackProvider(\n+      async ({ query, orientation }: RandomPhotoInput) => {\n+        const response = await axios.get<RandomPhoto>('photos/random', {\n+          baseURL: this.baseURL,\n+          headers: {\n+            Authorization:\n+              'Client-ID 4d048cfb4383b407eff92e4a2a5ec36c0a866be85e64caafa588c110efad350d',\n+          },\n+          params: {\n+            query,\n+            orientation,\n+          },\n+        });\n+\n+        return response.data;\n+      },\n+      {\n+        provider: 'Unsplash',\n+        method: 'RandomPhoto',\n+        location: resolve(__dirname, '../logs/main'),\n+      },\n+    );\n+\n+    try {\n+      return (await trackedRandomPhoto({\n+        query: 'portrait',\n+        orientation: 'squarish',\n+      })).urls.small;\n+    } catch (err) {\n+      console.error('Cannot retrieve random photo:', err);\n+      return null;\n+    }\n+  }\n+}\ndiff --git a/server/modules/common/database.provider.ts b/server/modules/common/database.provider.ts\nnew file mode 100644\nindex 0000000..4e72c6a\n--- /dev/null\n+++ b/server/modules/common/database.provider.ts\n@@ -0,0 +1,26 @@\n+import { Injectable, ProviderScope } from '@graphql-modules/di';\n+import { OnResponse } from '@graphql-modules/core';\n+import { Pool, PoolClient } from 'pg';\n+\n+@Injectable({\n+  scope: ProviderScope.Session,\n+})\n+export class Database implements OnResponse {\n+  private instance: PoolClient;\n+\n+  constructor(private pool: Pool) {}\n+\n+  async onRequest() {\n+    this.instance = await this.pool.connect();\n+  }\n+\n+  onResponse() {\n+    if (this.instance) {\n+      this.instance.release();\n+    }\n+  }\n+\n+  async getClient() {\n+    return this.instance;\n+  }\n+}\n\\ No newline at end of file\ndiff --git a/server/modules/common/index.ts b/server/modules/common/index.ts\nnew file mode 100644\nindex 0000000..ddad1f0\n--- /dev/null\n+++ b/server/modules/common/index.ts\n@@ -0,0 +1,57 @@\n+import { GraphQLModule } from '@graphql-modules/core';\n+import { ProviderScope } from '@graphql-modules/di';\n+import { gql } from 'apollo-server-express';\n+import { GraphQLDateTime } from 'graphql-iso-date';\n+import { Pool } from 'pg';\n+import { pool } from '../../db';\n+import { Resolvers } from '../../types/graphql';\n+import { Database } from './database.provider';\n+import { PubSub } from './pubsub.provider';\n+\n+const { PostgresPubSub } = require('graphql-postgres-subscriptions');\n+\n+const typeDefs = gql`\n+  scalar DateTime\n+\n+  type Query {\n+    _dummy: Boolean\n+  }\n+\n+  type Mutation {\n+    _dummy: Boolean\n+  }\n+\n+  type Subscription {\n+    _dummy: Boolean\n+  }\n+`;\n+\n+const resolvers: Resolvers = {\n+  DateTime: GraphQLDateTime,\n+};\n+\n+const pubsub = new PostgresPubSub({\n+  host: 'localhost',\n+  port: 5432,\n+  user: 'testuser',\n+  password: 'testpassword',\n+  database: 'whatsapp',\n+});\n+\n+export default new GraphQLModule({\n+  name: 'common',\n+  typeDefs,\n+  resolvers,\n+  providers: () => [\n+    {\n+      provide: Pool,\n+      useValue: pool,\n+    },\n+    {\n+      provide: PubSub,\n+      scope: ProviderScope.Application,\n+      useValue: pubsub,\n+    },\n+    Database,\n+  ],\n+});\ndiff --git a/server/modules/common/pubsub.provider.ts b/server/modules/common/pubsub.provider.ts\nnew file mode 100644\nindex 0000000..d1455e2\n--- /dev/null\n+++ b/server/modules/common/pubsub.provider.ts\n@@ -0,0 +1 @@\n+export { PubSub } from 'apollo-server-express';\n\\ No newline at end of file\ndiff --git a/server/modules/users/auth.provider.ts b/server/modules/users/auth.provider.ts\nnew file mode 100644\nindex 0000000..a781b82\n--- /dev/null\n+++ b/server/modules/users/auth.provider.ts\n@@ -0,0 +1,89 @@\n+import { Injectable, Inject, ProviderScope } from '@graphql-modules/di';\n+import { ModuleSessionInfo } from '@graphql-modules/core';\n+import { Response } from 'express';\n+import bcrypt from 'bcrypt';\n+import jwt from 'jsonwebtoken';\n+import { secret, expiration } from '../../env';\n+import { validateLength, validatePassword } from '../../validators';\n+import { Users } from './users.provider';\n+import { User } from '../../db';\n+\n+@Injectable({\n+  scope: ProviderScope.Session,\n+})\n+export class Auth {\n+  @Inject() private users: Users;\n+  @Inject() private module: ModuleSessionInfo;\n+\n+  private get req() {\n+    return this.module.session.req;\n+  }\n+\n+  private get res(): Response {\n+    return this.module.session.res;\n+  }\n+\n+  async signIn({ username, password }: { username: string; password: string }) {\n+    const user = await this.users.findByUsername(username);\n+\n+    if (!user) {\n+      throw new Error('user not found');\n+    }\n+\n+    const passwordsMatch = bcrypt.compareSync(password, user.password);\n+\n+    if (!passwordsMatch) {\n+      throw new Error('password is incorrect');\n+    }\n+\n+    const authToken = jwt.sign(username, secret);\n+\n+    this.res.cookie('authToken', authToken, { maxAge: expiration });\n+\n+    return user;\n+  }\n+\n+  async signUp({\n+    name,\n+    password,\n+    passwordConfirm,\n+    username,\n+  }: {\n+    name: string;\n+    password: string;\n+    passwordConfirm: string;\n+    username: string;\n+  }) {\n+    validateLength('req.name', name, 3, 50);\n+    validateLength('req.username', name, 3, 18);\n+    validatePassword('req.password', password);\n+\n+    if (password !== passwordConfirm) {\n+      throw Error(\"req.password and req.passwordConfirm don't match\");\n+    }\n+\n+    const existingUser = await this.users.findByUsername(username);\n+\n+    if (existingUser) {\n+      throw Error('username already exists');\n+    }\n+\n+    return this.users.newUser({\n+      username,\n+      name,\n+      password,\n+    });\n+  }\n+\n+  async currentUser(): Promise<User | null> {\n+    if (this.req.cookies.authToken) {\n+      const username = jwt.verify(this.req.cookies.authToken, secret) as string;\n+\n+      if (username) {\n+        return this.users.findByUsername(username);\n+      }\n+    }\n+\n+    return null;\n+  }\n+}\n\\ No newline at end of file\ndiff --git a/server/modules/users/index.ts b/server/modules/users/index.ts\nnew file mode 100644\nindex 0000000..93e30ea\n--- /dev/null\n+++ b/server/modules/users/index.ts\n@@ -0,0 +1,61 @@\n+import { GraphQLModule } from '@graphql-modules/core';\n+import { gql } from 'apollo-server-express';\n+import commonModule from '../common';\n+import { Resolvers } from '../../types/graphql';\n+import { Users } from './users.provider';\n+import { Auth } from './auth.provider';\n+\n+const typeDefs = gql`\n+  type User {\n+    id: ID!\n+    name: String!\n+    picture: String\n+  }\n+\n+  extend type Query {\n+    me: User\n+    users: [User!]!\n+  }\n+\n+  extend type Mutation {\n+    signIn(username: String!, password: String!): User\n+    signUp(\n+      name: String!\n+      username: String!\n+      password: String!\n+      passwordConfirm: String!\n+    ): User\n+  }\n+`;\n+\n+const resolvers: Resolvers = {\n+  Query: {\n+    me(root, args, { injector }) {\n+      return injector.get(Auth).currentUser();\n+    },\n+    async users(root, args, { injector }) {\n+      const currentUser = await injector.get(Auth).currentUser();\n+\n+      if (!currentUser) return [];\n+\n+      return injector.get(Users).findAllExcept(currentUser.id);\n+    },\n+  },\n+  Mutation: {\n+    async signIn(root, { username, password }, { injector }) {\n+      return injector.get(Auth).signIn({username, password});\n+    },\n+\n+    async signUp(root, { name, username, password, passwordConfirm }, { injector }) {\n+      return injector.get(Auth).signUp({name, username, password, passwordConfirm });\n+    },\n+  },\n+};\n+\n+export default new GraphQLModule({\n+  name: 'users',\n+  typeDefs,\n+  resolvers,\n+  imports: () => [commonModule],\n+  providers: () => [Users, Auth]\n+});\ndiff --git a/server/modules/users/users.provider.ts b/server/modules/users/users.provider.ts\nnew file mode 100644\nindex 0000000..daf32fd\n--- /dev/null\n+++ b/server/modules/users/users.provider.ts\n@@ -0,0 +1,59 @@\n+import { Injectable, Inject, ProviderScope } from '@graphql-modules/di';\n+import sql from 'sql-template-strings';\n+import bcrypt from 'bcrypt';\n+import { Database } from '../common/database.provider';\n+\n+@Injectable({\n+  scope: ProviderScope.Session,\n+})\n+export class Users {\n+  @Inject() private db: Database;\n+\n+  async findById(userId: string) {\n+    const db = await this.db.getClient();\n+    const { rows } = await db.query(\n+      sql`SELECT * FROM users WHERE id = ${userId}`,\n+    );\n+\n+    return rows[0] || null;\n+  }\n+\n+  async findAllExcept(userId: string) {\n+    const db = await this.db.getClient();\n+    const { rows } = await db.query(\n+      sql`SELECT * FROM users WHERE id != ${userId}`,\n+    );\n+\n+    return rows;\n+  }\n+\n+  async findByUsername(username: string) {\n+    const db = await this.db.getClient();\n+    const { rows } = await db.query(\n+      sql`SELECT * FROM users WHERE username = ${username}`,\n+    );\n+\n+    return rows[0] || null;\n+  }\n+\n+  async newUser({\n+    username,\n+    name,\n+    password,\n+  }: {\n+    username: string;\n+    name: string;\n+    password: string;\n+  }) {\n+    const db = await this.db.getClient();\n+    const passwordHash = bcrypt.hashSync(password, bcrypt.genSaltSync(8));\n+    const createdUserQuery = await db.query(sql`\n+        INSERT INTO users(password, picture, username, name)\n+        VALUES(${passwordHash}, '', ${username}, ${name})\n+        RETURNING *\n+      `);\n+    const user = createdUserQuery.rows[0];\n+\n+    return user;\n+  }\n+}\n\\ No newline at end of file\ndiff --git a/server/package.json b/server/package.json\nnew file mode 100644\nindex 0000000..30019b0\n--- /dev/null\n+++ b/server/package.json\n@@ -0,0 +1,64 @@\n+{\n+  \"name\": \"whatsapp-clone-server\",\n+  \"description\": \"A newly created Tortilla project\",\n+  \"repository\": {\n+    \"type\": \"git\",\n+    \"url\": \"https://github.com/Urigo/WhatsApp-Clone-Server.git\"\n+  },\n+  \"private\": true,\n+  \"scripts\": {\n+    \"start\": \"ts-node index.ts\",\n+    \"test\": \"jest --runInBand\",\n+    \"codegen\": \"gql-gen\"\n+  },\n+  \"devDependencies\": {\n+    \"@graphql-codegen/cli\": \"1.0.3\",\n+    \"@graphql-codegen/typescript\": \"1.0.3\",\n+    \"@graphql-codegen/typescript-resolvers\": \"1.0.3\",\n+    \"@types/bcrypt\": \"3.0.0\",\n+    \"@types/body-parser\": \"1.17.0\",\n+    \"@types/cookie-parser\": \"1.4.1\",\n+    \"@types/cors\": \"2.8.4\",\n+    \"@types/express\": \"4.16.1\",\n+    \"@types/graphql\": \"14.0.7\",\n+    \"@types/graphql-iso-date\": \"3.3.1\",\n+    \"@types/jest\": \"24.0.11\",\n+    \"@types/jsonwebtoken\": \"8.3.2\",\n+    \"@types/lodash\": \"4.14.126\",\n+    \"@types/node\": \"11.11.0\",\n+    \"@types/pg\": \"^7.4.14\",\n+    \"jest\": \"24.5.0\",\n+    \"ts-jest\": \"24.0.0\",\n+    \"ts-node\": \"8.0.3\",\n+    \"typescript\": \"3.3.3333\"\n+  },\n+  \"dependencies\": {\n+    \"@graphql-modules/core\": \"0.7.1\",\n+    \"@graphql-modules/di\": \"0.7.1\",\n+    \"@safe-api/middleware\": \"^0.0.2\",\n+    \"apollo-datasource-rest\": \"^0.4.0\",\n+    \"apollo-server-express\": \"2.4.8\",\n+    \"apollo-server-testing\": \"2.4.8\",\n+    \"axios\": \"0.18.0\",\n+    \"bcrypt\": \"3.0.5\",\n+    \"body-parser\": \"1.18.3\",\n+    \"cookie-parser\": \"1.4.4\",\n+    \"cors\": \"2.8.5\",\n+    \"express\": \"4.16.4\",\n+    \"graphql\": \"14.1.1\",\n+    \"graphql-import\": \"0.7.1\",\n+    \"graphql-iso-date\": \"3.6.1\",\n+    \"graphql-postgres-subscriptions\": \"^1.0.5\",\n+    \"graphql-tools\": \"4.0.4\",\n+    \"jsonwebtoken\": \"8.5.1\",\n+    \"lodash\": \"4.17.11\",\n+    \"pg\": \"^7.10.0\",\n+    \"reflect-metadata\": \"0.1.13\",\n+    \"sql-template-strings\": \"^2.2.2\"\n+  },\n+  \"jest\": {\n+    \"transform\": {\n+      \"^.+\\\\.(js|jsx|ts|tsx)$\": \"<rootDir>/node_modules/ts-jest\"\n+    }\n+  }\n+}\ndiff --git a/server/renovate.json b/server/renovate.json\nnew file mode 100644\nindex 0000000..216ef3c\n--- /dev/null\n+++ b/server/renovate.json\n@@ -0,0 +1,23 @@\n+{\n+    \"extends\": [\"config:base\", \":rebaseStalePrs\"],\n+    \"baseBranches\": [\n+      \"master\",\n+      \"master-root\",\n+      \"master-step1\",\n+      \"master-step2\",\n+      \"master-step3\",\n+      \"master-step4\",\n+      \"master-step5\",\n+      \"master-step6\",\n+      \"master-step7\",\n+      \"master-step8\",\n+      \"master-step9\",\n+      \"master-step10\",\n+      \"master-step11\",\n+      \"master-step12\",\n+      \"master-step13\"\n+    ],\n+    \"prHourlyLimit\": 60,\n+    \"recreateClosed\": true,\n+    \"rangeStrategy\": \"lockfile-update\"\n+  }\n\\ No newline at end of file\ndiff --git a/server/server.ts b/server/server.ts\nnew file mode 100644\nindex 0000000..43e68ac\n--- /dev/null\n+++ b/server/server.ts\n@@ -0,0 +1,16 @@\n+import 'reflect-metadata';\n+import { ApolloServer } from 'apollo-server-express'\n+import { GraphQLModule } from '@graphql-modules/core'\n+\n+import usersModule from './modules/users'\n+import chatsModule from './modules/chats'\n+\n+export const rootModule = new GraphQLModule({\n+  name: 'root',\n+  imports: [usersModule, chatsModule]\n+})\n+\n+export const server = new ApolloServer({\n+  schema: rootModule.schema,\n+  context: rootModule.context\n+})\ndiff --git a/server/tests/mocks/auth.provider.ts b/server/tests/mocks/auth.provider.ts\nnew file mode 100644\nindex 0000000..074f62c\n--- /dev/null\n+++ b/server/tests/mocks/auth.provider.ts\n@@ -0,0 +1,21 @@\n+import sql from 'sql-template-strings';\n+import { Auth } from './../../modules/users/auth.provider';\n+import usersModule from './../../modules/users';\n+import { pool } from '../../db';\n+\n+export function mockAuth(userId: number) {\n+  class AuthMock extends Auth {\n+    async currentUser() {\n+      const { rows } = await pool.query(\n+        sql`SELECT * FROM users WHERE id = ${userId}`,\n+      );\n+      return rows[0];\n+    }\n+  }\n+\n+  usersModule.injector.provide({\n+    provide: Auth,\n+    useClass: AuthMock,\n+    overwrite: true,\n+  });\n+}\n\\ No newline at end of file\ndiff --git a/server/tests/mutations/__snapshots__/addChat.test.ts.snap b/server/tests/mutations/__snapshots__/addChat.test.ts.snap\nnew file mode 100644\nindex 0000000..d1d9f44\n--- /dev/null\n+++ b/server/tests/mutations/__snapshots__/addChat.test.ts.snap\n@@ -0,0 +1,52 @@\n+// Jest Snapshot v1, https://goo.gl/fbAQLP\n+\n+exports[`Mutation.addChat creates a new chat between current user and specified recipient 1`] = `\n+Object {\n+  \"addChat\": Object {\n+    \"id\": \"5\",\n+    \"name\": \"Bryan Wallace\",\n+    \"participants\": Array [\n+      Object {\n+        \"id\": \"2\",\n+      },\n+      Object {\n+        \"id\": \"3\",\n+      },\n+    ],\n+  },\n+}\n+`;\n+\n+exports[`Mutation.addChat creates a new chat between current user and specified recipient 2`] = `\n+Object {\n+  \"chat\": Object {\n+    \"id\": \"5\",\n+    \"name\": \"Bryan Wallace\",\n+    \"participants\": Array [\n+      Object {\n+        \"id\": \"2\",\n+      },\n+      Object {\n+        \"id\": \"3\",\n+      },\n+    ],\n+  },\n+}\n+`;\n+\n+exports[`Mutation.addChat returns the existing chat if so 1`] = `\n+Object {\n+  \"addChat\": Object {\n+    \"id\": \"1\",\n+    \"name\": \"Ethan Gonzalez\",\n+    \"participants\": Array [\n+      Object {\n+        \"id\": \"1\",\n+      },\n+      Object {\n+        \"id\": \"2\",\n+      },\n+    ],\n+  },\n+}\n+`;\ndiff --git a/server/tests/mutations/__snapshots__/addMessage.test.ts.snap b/server/tests/mutations/__snapshots__/addMessage.test.ts.snap\nnew file mode 100644\nindex 0000000..0e88349\n--- /dev/null\n+++ b/server/tests/mutations/__snapshots__/addMessage.test.ts.snap\n@@ -0,0 +1,22 @@\n+// Jest Snapshot v1, https://goo.gl/fbAQLP\n+\n+exports[`Mutation.addMessage should add message to specified chat 1`] = `\n+Object {\n+  \"addMessage\": Object {\n+    \"content\": \"Hello World\",\n+    \"id\": \"5\",\n+  },\n+}\n+`;\n+\n+exports[`Mutation.addMessage should add message to specified chat 2`] = `\n+Object {\n+  \"chat\": Object {\n+    \"id\": \"1\",\n+    \"lastMessage\": Object {\n+      \"content\": \"Hello World\",\n+      \"id\": \"5\",\n+    },\n+  },\n+}\n+`;\ndiff --git a/server/tests/mutations/addChat.test.ts b/server/tests/mutations/addChat.test.ts\nnew file mode 100644\nindex 0000000..ad369f2\n--- /dev/null\n+++ b/server/tests/mutations/addChat.test.ts\n@@ -0,0 +1,78 @@\n+import { createTestClient } from 'apollo-server-testing'\n+import { gql } from 'apollo-server-express'\n+import { server } from '../../server';\n+import { resetDb } from '../../db'\n+import { mockAuth } from '../mocks/auth.provider';\n+\n+describe('Mutation.addChat', () => {\n+  beforeEach(resetDb)\n+\n+  it('creates a new chat between current user and specified recipient', async () => {\n+    mockAuth(2);\n+\n+    const { query, mutate } = createTestClient(server)\n+\n+    const addChatRes = await mutate({\n+      variables: { recipientId: '3' },\n+      mutation: gql `\n+        mutation AddChat($recipientId: ID!) {\n+          addChat(recipientId: $recipientId) {\n+            id\n+            name\n+            participants {\n+              id\n+            }\n+          }\n+        }\n+      `,\n+    })\n+\n+    expect(addChatRes.data).toBeDefined()\n+    expect(addChatRes.errors).toBeUndefined()\n+    expect(addChatRes.data).toMatchSnapshot()\n+\n+    const getChatRes = await query({\n+      variables: { chatId: '5' },\n+      query: gql `\n+        query GetChat($chatId: ID!) {\n+          chat(chatId: $chatId) {\n+            id\n+            name\n+            participants {\n+              id\n+            }\n+          }\n+        }\n+      `,\n+    })\n+\n+    expect(getChatRes.data).toBeDefined()\n+    expect(getChatRes.errors).toBeUndefined()\n+    expect(getChatRes.data).toMatchSnapshot()\n+  })\n+\n+  it('returns the existing chat if so', async () => {\n+    mockAuth(1);\n+\n+    const { query, mutate } = createTestClient(server)\n+\n+    const addChatRes = await mutate({\n+      variables: { recipientId: '2' },\n+      mutation: gql `\n+        mutation AddChat($recipientId: ID!) {\n+          addChat(recipientId: $recipientId) {\n+            id\n+            name\n+            participants {\n+              id\n+            }\n+          }\n+        }\n+      `,\n+    })\n+\n+    expect(addChatRes.data).toBeDefined()\n+    expect(addChatRes.errors).toBeUndefined()\n+    expect(addChatRes.data).toMatchSnapshot()\n+  })\n+})\ndiff --git a/server/tests/mutations/addMessage.test.ts b/server/tests/mutations/addMessage.test.ts\nnew file mode 100644\nindex 0000000..ec98e08\n--- /dev/null\n+++ b/server/tests/mutations/addMessage.test.ts\n@@ -0,0 +1,50 @@\n+import { createTestClient } from 'apollo-server-testing'\n+import { gql } from 'apollo-server-express'\n+import { server } from '../../server';\n+import { resetDb } from '../../db'\n+import { mockAuth } from '../mocks/auth.provider';\n+\n+describe('Mutation.addMessage', () => {\n+  beforeEach(resetDb)\n+\n+  it('should add message to specified chat', async () => {\n+    mockAuth(1);\n+\n+    const { query, mutate } = createTestClient(server)\n+\n+    const addMessageRes = await mutate({\n+      variables: { chatId: '1', content: 'Hello World' },\n+      mutation: gql `\n+        mutation AddMessage($chatId: ID!, $content: String!) {\n+          addMessage(chatId: $chatId, content: $content) {\n+            id\n+            content\n+          }\n+        }\n+      `,\n+    })\n+\n+    expect(addMessageRes.data).toBeDefined()\n+    expect(addMessageRes.errors).toBeUndefined()\n+    expect(addMessageRes.data).toMatchSnapshot()\n+\n+    const getChatRes = await query({\n+      variables: { chatId: '1' },\n+      query: gql `\n+        query GetChat($chatId: ID!) {\n+          chat(chatId: $chatId) {\n+            id\n+            lastMessage {\n+              id\n+              content\n+            }\n+          }\n+        }\n+      `,\n+    })\n+\n+    expect(getChatRes.data).toBeDefined()\n+    expect(getChatRes.errors).toBeUndefined()\n+    expect(getChatRes.data).toMatchSnapshot()\n+  })\n+})\ndiff --git a/server/tests/mutations/removeChat.test.ts b/server/tests/mutations/removeChat.test.ts\nnew file mode 100644\nindex 0000000..010232d\n--- /dev/null\n+++ b/server/tests/mutations/removeChat.test.ts\n@@ -0,0 +1,47 @@\n+import { createTestClient } from 'apollo-server-testing'\n+import { gql } from 'apollo-server-express'\n+import { server } from '../../server';\n+import { resetDb } from '../../db'\n+import { mockAuth } from '../mocks/auth.provider';\n+\n+describe('Mutation.removeChat', () => {\n+  beforeEach(resetDb)\n+\n+  it('removes chat by id', async () => {\n+    mockAuth(1);\n+\n+    const { query, mutate } = createTestClient(server)\n+\n+    const addChatRes = await mutate({\n+      variables: { chatId: '1' },\n+      mutation: gql `\n+        mutation RemoveChat($chatId: ID!) {\n+          removeChat(chatId: $chatId)\n+        }\n+      `,\n+    })\n+\n+    expect(addChatRes.data).toBeDefined()\n+    expect(addChatRes.errors).toBeUndefined()\n+    expect(addChatRes.data!.removeChat).toEqual('1')\n+\n+    const getChatRes = await query({\n+      variables: { chatId: '1' },\n+      query: gql `\n+        query GetChat($chatId: ID!) {\n+          chat(chatId: $chatId) {\n+            id\n+            name\n+            participants {\n+              id\n+            }\n+          }\n+        }\n+      `,\n+    })\n+\n+    expect(addChatRes.data).toBeDefined()\n+    expect(getChatRes.errors).toBeUndefined()\n+    expect(addChatRes.data!.chat).toBeUndefined()\n+  })\n+})\ndiff --git a/server/tests/queries/__snapshots__/getChat.test.ts.snap b/server/tests/queries/__snapshots__/getChat.test.ts.snap\nnew file mode 100644\nindex 0000000..64b1e2b\n--- /dev/null\n+++ b/server/tests/queries/__snapshots__/getChat.test.ts.snap\n@@ -0,0 +1,16 @@\n+// Jest Snapshot v1, https://goo.gl/fbAQLP\n+\n+exports[`Query.chat should fetch specified chat 1`] = `\n+Object {\n+  \"chat\": Object {\n+    \"id\": \"1\",\n+    \"lastMessage\": Object {\n+      \"content\": \"You on your way?\",\n+      \"createdAt\": \"2018-12-31T06:20:00.000Z\",\n+      \"id\": \"1\",\n+    },\n+    \"name\": \"Ethan Gonzalez\",\n+    \"picture\": \"https://randomuser.me/api/portraits/thumb/men/1.jpg\",\n+  },\n+}\n+`;\ndiff --git a/server/tests/queries/__snapshots__/getChats.test.ts.snap b/server/tests/queries/__snapshots__/getChats.test.ts.snap\nnew file mode 100644\nindex 0000000..1bd3a67\n--- /dev/null\n+++ b/server/tests/queries/__snapshots__/getChats.test.ts.snap\n@@ -0,0 +1,48 @@\n+// Jest Snapshot v1, https://goo.gl/fbAQLP\n+\n+exports[`Query.chats should fetch all chats 1`] = `\n+Object {\n+  \"chats\": Array [\n+    Object {\n+      \"id\": \"1\",\n+      \"lastMessage\": Object {\n+        \"content\": \"You on your way?\",\n+        \"createdAt\": \"2018-12-31T06:20:00.000Z\",\n+        \"id\": \"1\",\n+      },\n+      \"name\": \"Ethan Gonzalez\",\n+      \"picture\": \"https://randomuser.me/api/portraits/thumb/men/1.jpg\",\n+    },\n+    Object {\n+      \"id\": \"2\",\n+      \"lastMessage\": Object {\n+        \"content\": \"Hey, it's me\",\n+        \"createdAt\": \"2018-12-30T13:40:00.000Z\",\n+        \"id\": \"2\",\n+      },\n+      \"name\": \"Bryan Wallace\",\n+      \"picture\": \"https://randomuser.me/api/portraits/thumb/men/2.jpg\",\n+    },\n+    Object {\n+      \"id\": \"3\",\n+      \"lastMessage\": Object {\n+        \"content\": \"I should buy a boat\",\n+        \"createdAt\": \"2018-12-15T07:00:00.000Z\",\n+        \"id\": \"3\",\n+      },\n+      \"name\": \"Avery Stewart\",\n+      \"picture\": \"https://randomuser.me/api/portraits/thumb/women/1.jpg\",\n+    },\n+    Object {\n+      \"id\": \"4\",\n+      \"lastMessage\": Object {\n+        \"content\": \"This is wicked good ice cream.\",\n+        \"createdAt\": \"2018-05-12T15:00:00.000Z\",\n+        \"id\": \"4\",\n+      },\n+      \"name\": \"Katie Peterson\",\n+      \"picture\": \"https://randomuser.me/api/portraits/thumb/women/2.jpg\",\n+    },\n+  ],\n+}\n+`;\ndiff --git a/server/tests/queries/__snapshots__/getMe.test.ts.snap b/server/tests/queries/__snapshots__/getMe.test.ts.snap\nnew file mode 100644\nindex 0000000..8f5621e\n--- /dev/null\n+++ b/server/tests/queries/__snapshots__/getMe.test.ts.snap\n@@ -0,0 +1,11 @@\n+// Jest Snapshot v1, https://goo.gl/fbAQLP\n+\n+exports[`Query.me should fetch current user 1`] = `\n+Object {\n+  \"me\": Object {\n+    \"id\": \"1\",\n+    \"name\": \"Ray Edwards\",\n+    \"picture\": \"https://randomuser.me/api/portraits/thumb/lego/1.jpg\",\n+  },\n+}\n+`;\ndiff --git a/server/tests/queries/__snapshots__/getUsers.test.ts.snap b/server/tests/queries/__snapshots__/getUsers.test.ts.snap\nnew file mode 100644\nindex 0000000..a2fd9bd\n--- /dev/null\n+++ b/server/tests/queries/__snapshots__/getUsers.test.ts.snap\n@@ -0,0 +1,55 @@\n+// Jest Snapshot v1, https://goo.gl/fbAQLP\n+\n+exports[`Query.getUsers should fetch all users except the one signed-in 1`] = `\n+Object {\n+  \"users\": Array [\n+    Object {\n+      \"id\": \"2\",\n+      \"name\": \"Ethan Gonzalez\",\n+      \"picture\": \"https://randomuser.me/api/portraits/thumb/men/1.jpg\",\n+    },\n+    Object {\n+      \"id\": \"3\",\n+      \"name\": \"Bryan Wallace\",\n+      \"picture\": \"https://randomuser.me/api/portraits/thumb/men/2.jpg\",\n+    },\n+    Object {\n+      \"id\": \"4\",\n+      \"name\": \"Avery Stewart\",\n+      \"picture\": \"https://randomuser.me/api/portraits/thumb/women/1.jpg\",\n+    },\n+    Object {\n+      \"id\": \"5\",\n+      \"name\": \"Katie Peterson\",\n+      \"picture\": \"https://randomuser.me/api/portraits/thumb/women/2.jpg\",\n+    },\n+  ],\n+}\n+`;\n+\n+exports[`Query.getUsers should fetch all users except the one signed-in 2`] = `\n+Object {\n+  \"users\": Array [\n+    Object {\n+      \"id\": \"1\",\n+      \"name\": \"Ray Edwards\",\n+      \"picture\": \"https://randomuser.me/api/portraits/thumb/lego/1.jpg\",\n+    },\n+    Object {\n+      \"id\": \"3\",\n+      \"name\": \"Bryan Wallace\",\n+      \"picture\": \"https://randomuser.me/api/portraits/thumb/men/2.jpg\",\n+    },\n+    Object {\n+      \"id\": \"4\",\n+      \"name\": \"Avery Stewart\",\n+      \"picture\": \"https://randomuser.me/api/portraits/thumb/women/1.jpg\",\n+    },\n+    Object {\n+      \"id\": \"5\",\n+      \"name\": \"Katie Peterson\",\n+      \"picture\": \"https://randomuser.me/api/portraits/thumb/women/2.jpg\",\n+    },\n+  ],\n+}\n+`;\ndiff --git a/server/tests/queries/getChat.test.ts b/server/tests/queries/getChat.test.ts\nnew file mode 100644\nindex 0000000..0e63918\n--- /dev/null\n+++ b/server/tests/queries/getChat.test.ts\n@@ -0,0 +1,37 @@\n+import { createTestClient } from 'apollo-server-testing'\n+import { gql } from 'apollo-server-express'\n+import { server } from '../../server';\n+import { resetDb } from '../../db';\n+import { mockAuth } from '../mocks/auth.provider';\n+\n+describe('Query.chat', () => {\n+  beforeEach(resetDb)\n+\n+  it('should fetch specified chat', async () => {\n+    mockAuth(1);\n+\n+    const { query } = createTestClient(server)\n+\n+    const res = await query({\n+      variables: { chatId: '1' },\n+      query: gql `\n+        query GetChat($chatId: ID!) {\n+          chat(chatId: $chatId) {\n+            id\n+            name\n+            picture\n+            lastMessage {\n+              id\n+              content\n+              createdAt\n+            }\n+          }\n+        }\n+      `,\n+    })\n+\n+    expect(res.data).toBeDefined()\n+    expect(res.errors).toBeUndefined()\n+    expect(res.data).toMatchSnapshot()\n+  })\n+})\ndiff --git a/server/tests/queries/getChats.test.ts b/server/tests/queries/getChats.test.ts\nnew file mode 100644\nindex 0000000..171aa10\n--- /dev/null\n+++ b/server/tests/queries/getChats.test.ts\n@@ -0,0 +1,36 @@\n+import { createTestClient } from 'apollo-server-testing'\n+import { gql } from 'apollo-server-express'\n+import { server } from '../../server';\n+import { resetDb } from '../../db';\n+import { mockAuth } from '../mocks/auth.provider';\n+\n+describe('Query.chats', () => {\n+  beforeEach(resetDb)\n+\n+  it('should fetch all chats', async () => {\n+    mockAuth(1);\n+\n+    const { query } = createTestClient(server)\n+\n+    const res = await query({\n+      query: gql `\n+        query GetChats {\n+          chats {\n+            id\n+            name\n+            picture\n+            lastMessage {\n+              id\n+              content\n+              createdAt\n+            }\n+          }\n+        }\n+      `,\n+    })\n+\n+    expect(res.data).toBeDefined()\n+    expect(res.errors).toBeUndefined()\n+    expect(res.data).toMatchSnapshot()\n+  })\n+})\ndiff --git a/server/tests/queries/getMe.test.ts b/server/tests/queries/getMe.test.ts\nnew file mode 100644\nindex 0000000..022c28e\n--- /dev/null\n+++ b/server/tests/queries/getMe.test.ts\n@@ -0,0 +1,31 @@\n+import { createTestClient } from 'apollo-server-testing'\n+import { gql } from 'apollo-server-express'\n+import { server } from '../../server';\n+import { resetDb } from '../../db';\n+import { mockAuth } from '../mocks/auth.provider';\n+\n+describe('Query.me', () => {\n+  beforeEach(resetDb)\n+\n+  it('should fetch current user', async () => {\n+    mockAuth(1)\n+\n+    const { query } = createTestClient(server)\n+\n+    const res = await query({\n+      query: gql `\n+        query GetMe {\n+          me {\n+            id\n+            name\n+            picture\n+          }\n+        }\n+      `,\n+    })\n+\n+    expect(res.data).toBeDefined()\n+    expect(res.errors).toBeUndefined()\n+    expect(res.data).toMatchSnapshot()\n+  })\n+})\ndiff --git a/server/tests/queries/getUsers.test.ts b/server/tests/queries/getUsers.test.ts\nnew file mode 100644\nindex 0000000..47ac87a\n--- /dev/null\n+++ b/server/tests/queries/getUsers.test.ts\n@@ -0,0 +1,49 @@\n+import { createTestClient } from 'apollo-server-testing'\n+import { gql } from 'apollo-server-express'\n+import { server } from '../../server';\n+import { resetDb } from '../../db';\n+import { mockAuth } from '../mocks/auth.provider';\n+\n+describe('Query.getUsers', () => {\n+  beforeEach(resetDb)\n+\n+  it('should fetch all users except the one signed-in', async () => {\n+    mockAuth(1);\n+\n+    const { query } = createTestClient(server)\n+\n+    let res = await query({\n+      query: gql `\n+        query GetUsers {\n+          users {\n+            id\n+            name\n+            picture\n+          }\n+        }\n+      `,\n+    })\n+\n+    expect(res.data).toBeDefined()\n+    expect(res.errors).toBeUndefined()\n+    expect(res.data).toMatchSnapshot()\n+\n+    mockAuth(2);\n+\n+    res = await query({\n+      query: gql `\n+        query GetUsers {\n+          users {\n+            id\n+            name\n+            picture\n+          }\n+        }\n+      `,\n+    })\n+\n+    expect(res.data).toBeDefined()\n+    expect(res.errors).toBeUndefined()\n+    expect(res.data).toMatchSnapshot()\n+  })\n+})\ndiff --git a/server/tsconfig.json b/server/tsconfig.json\nnew file mode 100644\nindex 0000000..fe56553\n--- /dev/null\n+++ b/server/tsconfig.json\n@@ -0,0 +1,16 @@\n+{\n+  \"compilerOptions\": {\n+    \"target\": \"es2018\",\n+    \"module\": \"commonjs\",\n+    \"lib\": [\n+      \"es2018\",\n+      \"esnext.asynciterable\"\n+    ],\n+    \"strict\": true,\n+    \"strictFunctionTypes\": false,\n+    \"strictPropertyInitialization\": false,\n+    \"esModuleInterop\": true,\n+    \"experimentalDecorators\": true,\n+    \"emitDecoratorMetadata\": true\n+  }\n+}\ndiff --git a/server/types/apollo-server-testing.d.ts b/server/types/apollo-server-testing.d.ts\nnew file mode 100644\nindex 0000000..e9d9b94\n--- /dev/null\n+++ b/server/types/apollo-server-testing.d.ts\n@@ -0,0 +1,27 @@\n+declare module 'apollo-server-testing' {\n+  import { ApolloServerBase } from 'apollo-server-core';\n+  import { print, DocumentNode } from 'graphql';\n+  import { GraphQLResponse } from 'graphql-extensions';\n+\n+  type StringOrAst = string | DocumentNode;\n+\n+  // A query must not come with a mutation (and vice versa).\n+  type Query<TVariables> = {\n+    query: StringOrAst;\n+    mutation?: undefined;\n+    variables?: TVariables;\n+  };\n+\n+  type Mutation<TVariables> = {\n+    mutation: StringOrAst;\n+    query?: undefined;\n+    variables?: TVariables;\n+  };\n+\n+  export const createTestClient: <TVariables>(\n+    server: ApolloServerBase,\n+  ) => {\n+    query: (query: Query<TVariables>) => Promise<GraphQLResponse>;\n+    mutate: (mutation: Mutation<TVariables>) => Promise<GraphQLResponse>;\n+  };\n+}\ndiff --git a/server/validators.ts b/server/validators.ts\nnew file mode 100644\nindex 0000000..341d955\n--- /dev/null\n+++ b/server/validators.ts\n@@ -0,0 +1,43 @@\n+export const validatePassword = (ctx: string, str: string) => {\n+  if (typeof str !== 'string') {\n+    throw TypeError(`${ctx} must be a string`)\n+  }\n+\n+  validateLength(ctx, str, 8, 30)\n+\n+  if (!/[a-zA-Z]+/.test(str)) {\n+    throw TypeError(`${ctx} must contain english letters`)\n+  }\n+\n+  if (!/\\d+/.test(str)) {\n+    throw TypeError(`${ctx} must contain numbers`)\n+  }\n+\n+  if (!/[^\\da-zA-Z]+/.test(str)) {\n+    throw TypeError(`${ctx} must contain special charachters`)\n+  }\n+}\n+\n+export const validateLength = (ctx: string, str: string, ...args: number[]) => {\n+  let min, max\n+\n+  if (args.length === 1) {\n+    min = 0\n+    max = args[0]\n+  } else {\n+    min = args[0]\n+    max = args[1]\n+  }\n+\n+  if (typeof str !== 'string') {\n+    throw TypeError(`${ctx} must be a string`)\n+  }\n+\n+  if (str.length < min) {\n+    throw TypeError(`${ctx} must be at least ${min} chars long`)\n+  }\n+\n+  if (str.length > max) {\n+    throw TypeError(`${ctx} must contain ${max} chars at most`)\n+  }\n+}\n",
        "manuals": [
          {
            "manualTitle": "Whatsapp Clone Tutorial",
            "stepRevision": "b730e902f078ad498ac130dc99ec5e523a32f139",
            "manualView": "![whatsapp-clone](https://user-images.githubusercontent.com/7648874/54141944-9f801a80-4461-11e9-85a1-bcb161d9a6c6.png)\n\nWhatsapp Clone is a free and open-source tutorial that will guide you step-by-step on how to create a full-stack,\nmobile, hybrid web application from scratch.\n\nThe software world is evolving quickly, and oftentimes people find themselves left behind, even the most experienced ones.\nThe purpose of this tutorial is not only to demonstrate how to create a full application with the latest technologies, but also\nto keep up to date with the ever-changing development ecosystem.\n\nThis tutorial is for anyone who has ever asked themselves one of the following questions:\n\n- How do people build an app today?\n- What are the currently leading technologies in the ecosystem?\n- What are the best practices for using technology XXX?\n- What is the purpose of technology XXX?\n- How does technology XXX work?\n- How do I use technology XXX?\n- How do I migrate to the new version of technology XXX?\n- Why should I use technology XXX over technology YYY?\n\nAll of the above and more can be answered in the tutorial. Whether you’re a beginner, intermediate or a professional,\nwe will have the answers you’re looking for.\n\n**What technologies does Whatsapp Clone uses?**\n\nThe version of the Whatsapp Clone you are looking at, uses:\n\n- [React (with Hooks and Suspense)](http://react.com)\n- [Styled-Components](https://styled-components.com)\n- [Material-UI](https://material-ui.com)\n- [TypeScript](https://typescriptlang.org)\n- [Apollo GraphQL](https://www.apollographql.com)\n- [GraphQL Code Generator](http://graphql-code-generator.com)\n- [GraphQL Modules](https://graphql-modules.com)\n- [PostgreSQL](https://www.postgresql.org/)\n- [GraphQL Inspector](https://graphql-inspector.com/)\n\nThe point of this tutorial is not to be bound to a certain technology, but rather keep itself aligned with the ecosystem.\nWhen a new technology comes out, and it’s better and more popular, Whatsapp Clone will upgrade to use it (together with full migration instructions).\n\n**P2P tutorial for the community by the community**\n\nKeeping tutorials up to date is not an easy task.\nThat's why we've created the Tortilla Tutorial Framework that makes it easy to write and update tutorials.\nAlso, the WhatsApp clone is completely open source in order for the community to give its feedback, help and fork ideas.\nHere are the repositories the tutorial is made of:\n\n- [Whatsapp Clone - Client](https://github.com/Urigo/WhatsApp-Clone-Client-React)\n- [Whatsapp Clone - Server](https://github.com/Urigo/WhatsApp-Clone-server)\n- [Whatsapp Clone - Script's text](https://github.com/Urigo/WhatsApp-Clone-Tutorial)\n\nWe’ve also made sure to publish some important documents so you can get more involved.\nYou can track our progress and comment your suggestions, since everything is based on Google Docs and is updated live:\n\n- [Road map](https://docs.google.com/document/d/1p2Zio6Js2eoFfHs9CjIMF6jTuNyD4eQEHlgEAKhAqM8/edit?usp=sharing)\n- [Chapter manuals] (https://drive.google.com/open?id=1ITxOniS_S3sgZfunLvtJ1L9P6Fj1YOLlFHhoQPjT3S0)\n\n**Migration instructions included**\n\nThere are many great tutorials out there, but almost none of them shows you what changes you should make in your app in order to be aligned with a new version of a certain technology.\nAs technologies are being updated by the minute, some changes are minor and insignificant,\nbut often times a breaking change will be made in which case we need to know how we can adapt to that change.\nThanks to the [Tortilla platform](https://tortilla.academy), we can provide you with a git-diff that will show you what changes were made between each and every released version of the Whatsapp Clone tutorial since the beginning of history.\nThis way you can easily notice the changes in APIs and migrate your app in no time.\n\n![tutorial-versions-diff](https://user-images.githubusercontent.com/7648874/54142148-0f8ea080-4462-11e9-9522-ec9997b76169.png)\n\n**Prerequisites for WhatsApp Clone**\n\n- JavaScript - https://javascript.info/\n- TypeScript\n- JSX\n- HTML\n- CSS\n- Node.JS\n- npm & Yarn\n- React\n- SQL\n\n> Even if you don't have experience with the technologies above you might be able to start the tutorial and pick things along the way.\n> If you struggle with anything, contact us on the forum or on Github with your questions.\n\nOS operations such as navigating to a folder, or creating a folder, are all gonna be written in Bash, but the instructions are OS agnostic and can be applied on any machine that is web-compatible.\n\nMake sure you have the latest global dependencies on your computer before starting the tutorial:\n\n**[Node](https://nodejs.org/)**\n\nInstall [nvm](https://github.com/nvm-sh/nvm) by running the following command in your command line:\n\n    $ curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.34.0/install.sh | bash\n\nThen install the latest version of Node by running the following:\n\n    $ nvm install node\n\n**[Yarn](https://yarnpkg.com)**\n\nFollow the instructions [here](https://yarnpkg.com/en/docs/install#mac-stable).\n\n\n**What’s on the tutorial?**\n\nWhatsapp Clone is built chronologically, from the most basic, to more higher level features, so we recommend you to follow the tutorial in the right order.\nEach step is focused on a different subject, so by the end of it you’ll have a new feature and a new set of knowledge that you can start implementing in your everyday scenario immediately.\n\nIf you feel like you want to skip or focus on a specific subject, on each step you can download the full app code till that point in time.\n\nThat is also useful in case you get stuck.\n\nCurrently, Whatsapp Clone includes the following chapters:\n\n- [Step 1: Creating a basic React APP with a basic view.](https://github.com/Urigo/WhatsApp-Clone-Tutorial/blob/final/.tortilla/manuals/views/step1.md)\n- [Step 2: Styling with Material-UI and Styled-Components.](https://github.com/Urigo/WhatsApp-Clone-Tutorial/blob/final/.tortilla/manuals/views/step2.md)\n- [Step 3: Setting a basic Node.JS server with basic a basic REST endpoint.](https://github.com/Urigo/WhatsApp-Clone-Tutorial/blob/final/.tortilla/manuals/views/step3.md)\n- [Step 4: Transition to GraphQL.](https://github.com/Urigo/WhatsApp-Clone-Tutorial/blob/final/.tortilla/manuals/views/step4.md)\n- [Step 5: Testing.](https://github.com/Urigo/WhatsApp-Clone-Tutorial/blob/final/.tortilla/manuals/views/step5.md)\n- [Step 6: Creating an app router and implementing a chat room.](https://github.com/Urigo/WhatsApp-Clone-Tutorial/blob/final/.tortilla/manuals/views/step6.md)\n- [Step 7: Caching with Apollo-Client.](https://github.com/Urigo/WhatsApp-Clone-Tutorial/blob/final/.tortilla/manuals/views/step7.md)\n- [Step 8: Sending messages with GraphQL mutations.](https://github.com/Urigo/WhatsApp-Clone-Tutorial/blob/final/.tortilla/manuals/views/step8.md)\n- [Step 9: Type safety with GraphQL Code Generator.](https://github.com/Urigo/WhatsApp-Clone-Tutorial/blob/final/.tortilla/manuals/views/step9.md)\n- [Step 10: Live updates with GraphQL subscriptions.](https://github.com/Urigo/WhatsApp-Clone-Tutorial/blob/final/.tortilla/manuals/views/step10.md)\n- [Step 11: Users.](https://github.com/Urigo/WhatsApp-Clone-Tutorial/blob/final/.tortilla/manuals/views/step11.md)\n- [Step 12: Adding and removing chats.](https://github.com/Urigo/WhatsApp-Clone-Tutorial/blob/final/.tortilla/manuals/views/step12.md)\n- [Step 13: Authentication.](https://github.com/Urigo/WhatsApp-Clone-Tutorial/blob/final/.tortilla/manuals/views/step13.md)\n- Step 14: Your choice! Submit a request [here](https://github.com/Urigo/WhatsApp-Clone-Client-React/issues)\n\nWhatsapp Clone is updated on a regular basis, so you should expect more steps and extensions with time.\nYou can keep track of our [road map](https://docs.google.com/document/d/1p2Zio6Js2eoFfHs9CjIMF6jTuNyD4eQEHlgEAKhAqM8/edit?usp=sharing) to see what’s upcoming."
          },
          {
            "manualTitle": "Step 1: Creating a basic React APP with a basic view",
            "stepRevision": "f47f90a83d7d83a0c40e4a4646cad843ad8a81c3",
            "manualView": "The first thing we will do in the tutorial is to start with the UI (User Interface).\nThat is the visible part of our app that our users will see and interact with.\n\nIn this chapter we will learn how to create a basic React app.\nThe app will contain a basic view that will render a list of conversations within our app.\nWe will gradually create our app, so for now, instead of using real data, we will use in-memory fake data instead of calling a server.\n\nIn order to save time, instead of starting from scratch, we will use a boilerplate to kick-start our application.\nWhen it comes to React apps, the most popular boilerplate is [`create-react-app`](https://github.com/facebook/create-react-app)\nwhich is also officially maintained by Facebook, the creators of [React](https://reactjs.org/).\n\nWe'll launch `create-react-app` using `yarn create` (so we won't need to install `create-react-app` permanently),\nand run the `react-app` command to create the basis for our WhatsApp Clone.\n\nIn your command line, navigate to the folder you want to put your app's folder in and run:\n\n    $ yarn create react-app whatsapp-clone-client --typescript\n\n> Note how we used the `client` postfix. That's because we're planning to create a server as well on later chapters.\n\nIt will create a directory called `whatsapp-clone-client` inside the current folder.\nInside that directory, it will generate the initial project structure and install the needed dependencies.\nNo configuration or complicated folder structures, just the files you need to build your app.\n\n> In our project, we're gonna use [TypeScript](https://www.typescriptlang.org/) (indicated by the `--typescript` command).\n> The main advantage of using TypeScript over using plain JavaScript is that if we want, we get to tell the compiler what types and data structures we expect in certain places,\n> so that the compiler (which unlike a human never forgets) will remind us when we make a mistake and assume something that is not true.\n> The more information we will provide to the compiler, the more the compiler will be able to help us.\n\nOnce the installation is done, you can open your project folder:\n\n\t$ cd whatsapp-clone-client\n\nInside the newly created project, you can run some built-in commands:\n\n\t$ yarn start\n\nRuns the app in development mode. Open `http://localhost:3000` to view it in the browser:\n\n![boilerplate-page](https://user-images.githubusercontent.com/7648874/54026782-025f8080-41da-11e9-9a4e-796fe15e8d03.png)\n\n### create-react-app\n\nLet's look at what create-react-app has created for us in order to understand everything that's going on.\n\nFirst thing, let's look at what webpage is being served to the browser.\nThat webpage in `index.html` that sits under the `public` folder.\n\nAs you can see, this file is a regular HTML file. You will want to edit it's `<title>` to name our real app:\n\n[{]: <helper> (diffStep \"1.1\" files=\"public/index.html\" module=\"client\")\n\n#### Client Step 1.1: Rename the app\n\n##### Changed public&#x2F;index.html\n```diff\n@@ -19,7 +19,7 @@\n ┊19┊19┊      work correctly both with client-side routing and a non-root public URL.\n ┊20┊20┊      Learn how to configure a non-root public URL by running `npm run build`.\n ┊21┊21┊    -->\n-┊22┊  ┊    <title>React App</title>\n+┊  ┊22┊    <title>WhatsApp Clone</title>\n ┊23┊23┊  </head>\n ┊24┊24┊  <body>\n ┊25┊25┊    <noscript>You need to enable JavaScript to run this app.</noscript>\n```\n\n[}]: #\n\nIn the `public` folder we will place assets that are not going to change, like `favicon.ico`, static images and the HTML templates.\n\nWhen we will prepare to app for production, a script from `create-react-app` will place those assets in a build folder and reference them into the\nHTML template.\n\nAnother file in the `public` folder is the `manifest.json` file that gives browsers information about our app in case the users will install the app permanently on their\nmobile phones or desktop apps.\nYou can read more about it here: https://developers.google.com/web/fundamentals/web-app-manifest/.\n\n[{]: <helper> (diffStep \"1.1\" files=\"public/manifest.json\" module=\"client\")\n\n#### Client Step 1.1: Rename the app\n\n##### Changed public&#x2F;manifest.json\n```diff\n@@ -1,6 +1,6 @@\n ┊1┊1┊{\n-┊2┊ ┊  \"short_name\": \"React App\",\n-┊3┊ ┊  \"name\": \"Create React App Sample\",\n+┊ ┊2┊  \"short_name\": \"WhatsApp Clone\",\n+┊ ┊3┊  \"name\": \"An open source chat app\",\n ┊4┊4┊  \"icons\": [\n ┊5┊5┊    {\n ┊6┊6┊      \"src\": \"favicon.ico\",\n```\n\n[}]: #\n\nNow the HTML file has in it's <body> tag just one `<div id=\"root\"></div>` tag which is empty.\nSo how do we get the nice React logo that is being rendered onto our screen?\n\n`create-react-app` has scripts that will run the `src/index.tsx` file together with our HTML template, so let's look what this file is doing.\nThe important thing to see here is the `React` is calling it's render method and telling it to render the `App` component into a document where `id` equals `root`.\n\nSo now you know where React is coming into our html template.\n\nBut where does the `App` React component comes from and where does `React` itself comes from?\n\nThe `index.tsx` file imports this code from outside of the file using the `import` command.\n\nIn the case of the `App` component, we can see it bring it from the path './App', which is in the same folder ('src').\n\nGetting React, it is simply calling it by name instead of a path. That means that the import will automatically look for a folder named `react` under the `node-modules` folder.\n\n`node-modules` is a default folder which will include all of the libraries we want to use in our app.\n\n[yarn](https://yarnpkg.com) will install those libraries according to the dependencies listed inside the `package.json` file, so let's look into that.\n\nUnder dependencies you can see all the libraries our app currently depends on.\n\nYou can also see other values in there like `scripts`, which will teach `yarn` new commands that we can use.\nThe right side will name the command and the left would be the actual command that it will run.\n\nAnother file that got created is `tsconfig.json`.\nThat file specifies options for the Typescript compiler when it takes our code and transforms it from Typescript into Javascript.\n\nSome noticeable configuration options for that file are:\n\n* `target` - What kind of Javascript should the compilers output? in our case `es5` is the version of Javascript that is supported by many browsers.\nIf you know that your app would run only on newer browsers or a Node environment, you can change that value to a newer version and gain performance improvements.\n* `lib` - If you are using new syntax from Javascript, the compiler can add to it's output libraries that would help you support the new syntax even if the browsers don't know those.\n* `strict` - We can give Typescript a lot of information or not so much. The more we give it the more it can help us. adding the strict option will make the compiler warn us when we won't give it enough information.\n\nFor the full set of options, check out the [official docs](https://www.typescriptlang.org/docs/handbook/compiler-options.html);\n\nNow, let's look at our App's code in `src/App.tsx`.\n\nWe can see that our app is just a function named `App`.\n\n`const App` means we declare a variable named `App` and `const` means it cannot be changed after it has been declared (you can't do `App = XX;` later in the app);\n\nNext we assign App with a function. Something like: `const App = () => {}`.\nThat way of creating functions is called `arrow functions`. It is almost equivalent to `const App = function(){}`.\nSo it is a function that doesn't accept any parameters into it.\n\nThat function returns `jsx`. A visual language from React that describes how our component should look like.\n\nSo all a React component is, is simply a function that returns how it look like.\n\nWe then export this function so that React could import it from `index.tsx`.\n\nIn our own component we will import things like the logo and styles that the component uses and those will be imported together with it each time\nsomething will import our component.\n\nThe last thing we haven't explained is the following part: `App: React.FC`.\nThose are Typescript typings. Everything after `:` describes the types of the `App` variable and has no affect on the behavior and execution of the app.\nIt will tell Typescript what `App` is suppose to look so that in case we make a mistake Typescript will warn us before we get the app running.\n\nSo what are the types of React.FC?  You can check it out inside by using command+click on it's name.\nYou see that it accepts `P` as props into the component and needs to return `React.Element` or `null`.\n\nLet's test this out, add a Typescript interface named `AppProps` and put that it includes a property called `name` of type string.\n\nNow let's try to return something invalid. `\"some string\"`, or `1+1`.\nYou can see that our editor is calling out that there are errors in our code.\n\nYou will encounter those error a lot as you develop.\nAlways read the errors all the way. Understand each sentence there because that will save you a lot of time.\n\nOk we now know the component doesn't get anything into itself so let's make sure the typings reflect that as well.\nThe default for React.FC is that there are no props passed inside so if we'll bring that back but keep sending the `name` value from `index.tsx` in the code, you should now get an error.\n\nThose errors can be very useful when your app grows.\nMake sure to define types on the component itself like we have done now. It would make it easier to identify the issues.\n\nNext, we have `App.css`. This is used to style our App component.\nPlay around with changing some of the values and see how it changes your view.\nRight now the link between the styles and the components is done by class names (`App-header`, etc).\nLater on we'll learn better strategies of sorting our styles and making\nsure they are not touching components that we don't want them to affect.\n\nNext file - `App.test.tsx`.\nThis file contains automatic tests to make sure our app is doing what it's suppose to do.\n\nWe are programmers, that means that many times our job is to take something manual and making it automatic.\nThat's why we should also strive to automate things we do ourselves.\nType checking is one area, testing is another.  If we can automate tests and run them all the time, it can save us a lot of time\nand bring us a lot of confidence that when we change our code, we haven't destroyed anything.\n\nThe testing tool that create-react-app provides us with is [Jest](https://jestjs.io/).\n\nRight now we have only one simple test - it renders the App React component and makes sure nothing crashes.\nRun the test by running `yarn test` in the command line.\n\nNow go and remove the export from the app component. see how the tests picked up immediately that something is wrong.\n\nIn a later chapter we'll learn how to test more things to make sure we get guarantees that things are working as expected.\n\n## Pin dependencies and save-exact\n\nCheckout the package versions on the `package.json` file.\n\nyou can see the `^` sign.  That means that every time someone will get this code and run `yarn`, what `yarn` will do is to get the newest version on that range.\nWe don't want that. We want to first be notified when a new version is out and we want to explicitly update it.\n\nThat's why we need to add 2 things into our code:\nFirst, to delete all `^`.\n\n[{]: <helper> (diffStep \"1.2\" files=\"package.json\" module=\"client\")\n\n#### Client Step 1.2: Pin dependencies\n\n##### Changed package.json\n```diff\n@@ -7,8 +7,8 @@\n ┊ 7┊ 7┊    \"@types/node\": \"12.0.1\",\n ┊ 8┊ 8┊    \"@types/react\": \"16.8.17\",\n ┊ 9┊ 9┊    \"@types/react-dom\": \"16.8.4\",\n-┊10┊  ┊    \"react\": \"^16.8.6\",\n-┊11┊  ┊    \"react-dom\": \"^16.8.6\",\n+┊  ┊10┊    \"react\": \"16.8.6\",\n+┊  ┊11┊    \"react-dom\": \"16.8.6\",\n ┊12┊12┊    \"react-scripts\": \"3.0.1\",\n ┊13┊13┊    \"typescript\": \"3.4.5\"\n ┊14┊14┊  },\n```\n\n[}]: #\n\nSecond, to add the following command that will make each `yarn add <package-name>` command automatically add the library without any additions or `^` signs into it.\n\n[{]: <helper> (diffStep \"1.2\" files=\".npmrc\" module=\"client\")\n\n#### Client Step 1.2: Pin dependencies\n\n##### Added .npmrc\n```diff\n@@ -0,0 +1 @@\n+┊ ┊1┊save-exact=true\n```\n\n[}]: #\n\nThere is no need to upgrade your dependencies at all. If they work it's ok. But, it is highly recommended.\nPackages keep improving all the time with important things that would help your app and will save you time.\nIf you make it a routine to upgrade it makes it much easier then to upgrade every couple of months.\nIn order to discover if there are new versions of libraries there are 2 options.\n\nOne is to manually run a check every day or so to find new packages out there.\nYou can do that by going to your command line in the root folder of the project and type `yarn outdated`.\n\nBut if you want to get notified when there is a new version of your dependencies, you can check out [Renovate](https://github.com/renovatebot/renovate).\nIf your project is hosted somewhere, for example Github, it will analyze your `package.json` and submit a new PR when a new release happened from one of your dependencies.\n\n## git and saving your code on Github\n\nIf you want to save your code somewhere where you can track versions, using [git](https://git-scm.com/book/en/v2) and [Github](https://guides.github.com/activities/hello-world/) is a good choice.\nHere is a nice guide to start: https://try.github.io/.\n\nYou can check out the `.gitignore` file create-react-app has set up for us in the root folder.\nThat file will tell `.git` what not to save and not to upload.\n\n**End of intro**\n\nAssuming that everything is set, we will now create our first screen - `ChatsListScreen`.\nThe ChatsListScreen component is responsible for showing the active conversations within our app.\n\nIt's best to first schematically plan how our view's gonna look like.\nThis would help us illustrate the intended view and also understand which React.Components / elements take part in it.\nThis is how our screen's gonna look like:\n\n![chatslistscreen](https://user-images.githubusercontent.com/7648874/54027873-01305280-41de-11e9-9df0-5ad9c9c2f226.png)\n\nLet's break down the image above and see what components are we gonna have in the `ChatsListScreen`:\n\n- Navbar -  Which should contain a simple static title for now.\n- ChatsList - Where each item's gonna contain some data regards the user we're chatting with and information about the chat.\n\nFirst let's remove the current React code and add our own code into it.\n\nFor now, let's create fake data on our HTML.\n\nAdd this data will be changed and we are not going to manually add HTML tags every time there is a new message, let's move our data into a JSON structure.\nFor now it would be a structure we will manually create.\nThat way we can make our React component already behave like our final version.\n\n[{]: <helper> (diffStep \"1.3\" files=\"App.tsx\" module=\"client\")\n\n#### Client Step 1.3: Create ChatsList screen\n\n##### Changed src&#x2F;App.tsx\n```diff\n@@ -1,26 +1,29 @@\n ┊ 1┊ 1┊import React from 'react';\n-┊ 2┊  ┊import logo from './logo.svg';\n-┊ 3┊  ┊import './App.css';\n ┊ 4┊ 2┊\n ┊ 5┊ 3┊const App: React.FC = () => {\n ┊ 6┊ 4┊  return (\n-┊ 7┊  ┊    <div className=\"App\">\n-┊ 8┊  ┊      <header className=\"App-header\">\n-┊ 9┊  ┊        <img src={logo} className=\"App-logo\" alt=\"logo\" />\n-┊10┊  ┊        <p>\n-┊11┊  ┊          Edit <code>src/App.tsx</code> and save to reload.\n-┊12┊  ┊        </p>\n-┊13┊  ┊        <a\n-┊14┊  ┊          className=\"App-link\"\n-┊15┊  ┊          href=\"https://reactjs.org\"\n-┊16┊  ┊          target=\"_blank\"\n-┊17┊  ┊          rel=\"noopener noreferrer\"\n-┊18┊  ┊        >\n-┊19┊  ┊          Learn React\n-┊20┊  ┊        </a>\n-┊21┊  ┊      </header>\n+┊  ┊ 5┊    <div>\n+┊  ┊ 6┊      <div>\n+┊  ┊ 7┊        Whatsapp Clone\n+┊  ┊ 8┊      </div>\n+┊  ┊ 9┊      <div>\n+┊  ┊10┊        <ul>\n+┊  ┊11┊            <li>\n+┊  ┊12┊              <img src=\"https://randomuser.me/api/portraits/thumb/men/1.jpg\" alt=\"Profile\"/>\n+┊  ┊13┊              <div>Ethan Gonzalez</div>\n+┊  ┊14┊                <div>You on your way?</div>\n+┊  ┊15┊                <div>10:25</div>\n+┊  ┊16┊            </li>\n+┊  ┊17┊            <li>\n+┊  ┊18┊              <img src=\"https://randomuser.me/api/portraits/thumb/men/2.jpg\" alt=\"Profile\"/>\n+┊  ┊19┊              <div>Bryan Wallace</div>\n+┊  ┊20┊                <div>Hey, it's me</div>\n+┊  ┊21┊                <div>13:27</div>\n+┊  ┊22┊            </li>\n+┊  ┊23┊        </ul>\n+┊  ┊24┊      </div>\n ┊22┊25┊    </div>\n ┊23┊26┊  );\n-┊24┊  ┊}\n+┊  ┊27┊};\n ┊25┊28┊\n ┊26┊29┊export default App;\n```\n\n[}]: #\n\nIf all we do in the function is just returning a value, instead of `const App: React.FC = () => { return () };` we can also do `const App: React.FC = () => ();`\nSo let's use that for our ChatsList component.\n\nWe have to import React to make sure it will work.\nWe also have to export our component function so that the `App` component would be able to import it.\n(You can't import Javascript variables from a file if that file won't explicitly export it).\n\nAs we don't use those styles and logos anymore, we can delete the `src/App.css` and the `src/logo.svg` files from our app.\n\nNow let's move ChatsList into it's own component:\n\n[{]: <helper> (diffStep \"1.4\" files=\"ChatsList.tsx\" module=\"client\")\n\n#### Client Step 1.4: Move ChatsList to a component\n\n##### Added src&#x2F;components&#x2F;ChatsList.tsx\n```diff\n@@ -0,0 +1,22 @@\n+┊  ┊ 1┊import React from 'react';\n+┊  ┊ 2┊\n+┊  ┊ 3┊const ChatsList: React.FC = () => (\n+┊  ┊ 4┊  <div>\n+┊  ┊ 5┊    <ul>\n+┊  ┊ 6┊        <li>\n+┊  ┊ 7┊          <img src=\"https://randomuser.me/api/portraits/thumb/men/1.jpg\" alt=\"Profile\"/>\n+┊  ┊ 8┊          <div>Ethan Gonzalez</div>\n+┊  ┊ 9┊            <div>You on your way?</div>\n+┊  ┊10┊            <div>10:25</div>\n+┊  ┊11┊        </li>\n+┊  ┊12┊        <li>\n+┊  ┊13┊          <img src=\"https://randomuser.me/api/portraits/thumb/men/2.jpg\" alt=\"Profile\"/>\n+┊  ┊14┊          <div>Bryan Wallace</div>\n+┊  ┊15┊            <div>Hey, it's me</div>\n+┊  ┊16┊            <div>13:27</div>\n+┊  ┊17┊        </li>\n+┊  ┊18┊    </ul>\n+┊  ┊19┊  </div>\n+┊  ┊20┊);\n+┊  ┊21┊\n+┊  ┊22┊export default ChatsList;🚫↵\n```\n\n[}]: #\n\nand let's import that component into the App component and use the shorter syntax for the functional component:\n\n[{]: <helper> (diffStep \"1.4\" files=\"App.tsx\" module=\"client\")\n\n#### Client Step 1.4: Move ChatsList to a component\n\n##### Changed src&#x2F;App.tsx\n```diff\n@@ -1,4 +1,5 @@\n ┊1┊1┊import React from 'react';\n+┊ ┊2┊import ChatsList from './components/ChatsList';\n ┊2┊3┊\n ┊3┊4┊const App: React.FC = () => {\n ┊4┊5┊  return (\n```\n```diff\n@@ -6,22 +7,7 @@\n ┊ 6┊ 7┊      <div>\n ┊ 7┊ 8┊        Whatsapp Clone\n ┊ 8┊ 9┊      </div>\n-┊ 9┊  ┊      <div>\n-┊10┊  ┊        <ul>\n-┊11┊  ┊            <li>\n-┊12┊  ┊              <img src=\"https://randomuser.me/api/portraits/thumb/men/1.jpg\" alt=\"Profile\"/>\n-┊13┊  ┊              <div>Ethan Gonzalez</div>\n-┊14┊  ┊                <div>You on your way?</div>\n-┊15┊  ┊                <div>10:25</div>\n-┊16┊  ┊            </li>\n-┊17┊  ┊            <li>\n-┊18┊  ┊              <img src=\"https://randomuser.me/api/portraits/thumb/men/2.jpg\" alt=\"Profile\"/>\n-┊19┊  ┊              <div>Bryan Wallace</div>\n-┊20┊  ┊                <div>Hey, it's me</div>\n-┊21┊  ┊                <div>13:27</div>\n-┊22┊  ┊            </li>\n-┊23┊  ┊        </ul>\n-┊24┊  ┊      </div>\n+┊  ┊10┊      <ChatsList />\n ┊25┊11┊    </div>\n ┊26┊12┊  );\n ┊27┊13┊};\n```\n\n[}]: #\n\nand let's do the same for our Navbar:\n\n[{]: <helper> (diffStep \"1.5\" module=\"client\")\n\n#### Client Step 1.5: Move ChatsNavbar to a component\n\n##### Changed src&#x2F;App.tsx\n```diff\n@@ -1,12 +1,11 @@\n ┊ 1┊ 1┊import React from 'react';\n ┊ 2┊ 2┊import ChatsList from './components/ChatsList';\n+┊  ┊ 3┊import ChatsNavbar from './components/ChatsNavbar';\n ┊ 3┊ 4┊\n ┊ 4┊ 5┊const App: React.FC = () => {\n ┊ 5┊ 6┊  return (\n ┊ 6┊ 7┊    <div>\n-┊ 7┊  ┊      <div>\n-┊ 8┊  ┊        Whatsapp Clone\n-┊ 9┊  ┊      </div>\n+┊  ┊ 8┊      <ChatsNavbar />\n ┊10┊ 9┊      <ChatsList />\n ┊11┊10┊    </div>\n ┊12┊11┊  );\n```\n\n##### Added src&#x2F;components&#x2F;ChatsNavbar.tsx\n```diff\n@@ -0,0 +1,9 @@\n+┊ ┊1┊import React from 'react';\n+┊ ┊2┊\n+┊ ┊3┊const ChatsNavbar: React.FC = () => (\n+┊ ┊4┊  <div>\n+┊ ┊5┊    Whatsapp Clone\n+┊ ┊6┊  </div>\n+┊ ┊7┊);\n+┊ ┊8┊\n+┊ ┊9┊export default ChatsNavbar;🚫↵\n```\n\n[}]: #\n\nReact apps tend to store React.Components under a directory located at `src/components`, and so we're gonna follow this pattern.\nWe will create a directory called ChatsListScreen in the `components` dir where we're simply gonna import and put together the Navbar and ChatsList components.\nThis is how the contents of that directory should look like:\n\n    ChatsListScreen\n    ├── index.tsx\n    ├── ChatsList\n    └── ChatsNavbar\n\nWe will use the `index.tsx` file to define that component, this way we can import it using the directory name:\n\n[{]: <helper> (diffStep \"1.6\" module=\"client\")\n\n#### Client Step 1.6: Move all ChatsListScreen into a folder\n\n##### Changed src&#x2F;App.tsx\n```diff\n@@ -1,14 +1,10 @@\n ┊ 1┊ 1┊import React from 'react';\n-┊ 2┊  ┊import ChatsList from './components/ChatsList';\n-┊ 3┊  ┊import ChatsNavbar from './components/ChatsNavbar';\n+┊  ┊ 2┊import ChatsListScreen from './components/ChatsListScreen';\n ┊ 4┊ 3┊\n-┊ 5┊  ┊const App: React.FC = () => {\n-┊ 6┊  ┊  return (\n-┊ 7┊  ┊    <div>\n-┊ 8┊  ┊      <ChatsNavbar />\n-┊ 9┊  ┊      <ChatsList />\n-┊10┊  ┊    </div>\n-┊11┊  ┊  );\n-┊12┊  ┊};\n+┊  ┊ 4┊const App: React.FC = () => (\n+┊  ┊ 5┊  <div>\n+┊  ┊ 6┊    <ChatsListScreen/>\n+┊  ┊ 7┊  </div>\n+┊  ┊ 8┊);\n ┊13┊ 9┊\n ┊14┊10┊export default App;\n```\n\n##### Renamed from src&#x2F;components&#x2F;ChatsList.tsx to src&#x2F;components&#x2F;ChatsListScreen&#x2F;ChatsList.tsx\n\n\n##### Renamed from src&#x2F;components&#x2F;ChatsNavbar.tsx to src&#x2F;components&#x2F;ChatsListScreen&#x2F;ChatsNavbar.tsx\n\n\n##### Added src&#x2F;components&#x2F;ChatsListScreen&#x2F;index.tsx\n```diff\n@@ -0,0 +1,12 @@\n+┊  ┊ 1┊import React from 'react';\n+┊  ┊ 2┊import ChatsNavbar from './ChatsNavbar';\n+┊  ┊ 3┊import ChatsList from './ChatsList';\n+┊  ┊ 4┊\n+┊  ┊ 5┊const ChatsListScreen: React.FC = () => (\n+┊  ┊ 6┊  <div>\n+┊  ┊ 7┊    <ChatsNavbar />\n+┊  ┊ 8┊    <ChatsList />\n+┊  ┊ 9┊  </div>\n+┊  ┊10┊);\n+┊  ┊11┊\n+┊  ┊12┊export default ChatsListScreen;🚫↵\n```\n\n[}]: #\n\nNow, we have our app rendering our view, but it is completely static and manual in the code.\n\nIf we had 10 messages, we wouldn't want to type all of those HTML tags again and again.\nAlso if the data will change, the app should do this update itself without the need of hand written code.\n\nSo let's create a file that lists just the data of our chats and then make our React component render a line for each entry in that file.\n\nWe will create the file in a JSON format:\n\n[{]: <helper> (diffStep \"1.7\" files=\"db.ts\" module=\"client\")\n\n#### Client Step 1.7: Attach unique keys to ChatsList\n\n##### Added src&#x2F;db.ts\n```diff\n@@ -0,0 +1,49 @@\n+┊  ┊ 1┊export const messages = [\n+┊  ┊ 2┊  {\n+┊  ┊ 3┊    id: 1,\n+┊  ┊ 4┊    content: \"You on your way?\",\n+┊  ┊ 5┊    createdAt: new Date(Date.now() - 60 * 1000 * 1000),\n+┊  ┊ 6┊  },\n+┊  ┊ 7┊  {\n+┊  ┊ 8┊    id: 2,\n+┊  ┊ 9┊    content: \"Hey, it's me\",\n+┊  ┊10┊    createdAt: new Date(Date.now() - 2 * 60 * 1000 * 1000),\n+┊  ┊11┊  },\n+┊  ┊12┊  {\n+┊  ┊13┊    id: 3,\n+┊  ┊14┊    content: \"I should buy a boat\",\n+┊  ┊15┊    createdAt: new Date(Date.now() - 24 * 60 * 1000 * 1000),\n+┊  ┊16┊  },\n+┊  ┊17┊  {\n+┊  ┊18┊    id: 4,\n+┊  ┊19┊    content: \"This is wicked good ice cream.\",\n+┊  ┊20┊    createdAt: new Date(Date.now() - 14 * 24 * 60 * 1000 * 1000),\n+┊  ┊21┊  },\n+┊  ┊22┊];\n+┊  ┊23┊\n+┊  ┊24┊export const chats = [\n+┊  ┊25┊  {\n+┊  ┊26┊    id: 1,\n+┊  ┊27┊    name: 'Ethan Gonzalez',\n+┊  ┊28┊    picture: 'https://randomuser.me/api/portraits/thumb/men/1.jpg',\n+┊  ┊29┊    lastMessage: messages.find(m => m.id === 1),\n+┊  ┊30┊  },\n+┊  ┊31┊  {\n+┊  ┊32┊    id: 2,\n+┊  ┊33┊    name: 'Bryan Wallace',\n+┊  ┊34┊    picture: 'https://randomuser.me/api/portraits/thumb/men/2.jpg',\n+┊  ┊35┊    lastMessage: messages.find(m => m.id === 2),\n+┊  ┊36┊  },\n+┊  ┊37┊  {\n+┊  ┊38┊    id: 3,\n+┊  ┊39┊    name: 'Avery Stewart',\n+┊  ┊40┊    picture: 'https://randomuser.me/api/portraits/thumb/women/1.jpg',\n+┊  ┊41┊    lastMessage: messages.find(m => m.id === 3),\n+┊  ┊42┊  },\n+┊  ┊43┊  {\n+┊  ┊44┊    id: 4,\n+┊  ┊45┊    name: 'Katie Peterson',\n+┊  ┊46┊    picture: 'https://randomuser.me/api/portraits/thumb/women/2.jpg',\n+┊  ┊47┊    lastMessage: messages.find(m => m.id === 4),\n+┊  ┊48┊  },\n+┊  ┊49┊];🚫↵\n```\n\n[}]: #\n\nWe are giving IDs for the values just like a database gives a unique id for each value.\n\nThe is so we can reference specific values, for example,\nlast message would actually reference the other array instead of duplicating the values.\n\nNow let's change ChatsList component to import the data from that file.\nThen to use the Javascript [map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)\nfunction to render a line for each data entry:\n\n[{]: <helper> (diffStep \"1.7\" files=\"ChatsList.tsx\" module=\"client\")\n\n#### Client Step 1.7: Attach unique keys to ChatsList\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;ChatsList.tsx\n```diff\n@@ -1,20 +1,15 @@\n ┊ 1┊ 1┊import React from 'react';\n+┊  ┊ 2┊import { chats } from '../../db';\n ┊ 2┊ 3┊\n ┊ 3┊ 4┊const ChatsList: React.FC = () => (\n ┊ 4┊ 5┊  <div>\n ┊ 5┊ 6┊    <ul>\n-┊ 6┊  ┊        <li>\n-┊ 7┊  ┊          <img src=\"https://randomuser.me/api/portraits/thumb/men/1.jpg\" alt=\"Profile\"/>\n-┊ 8┊  ┊          <div>Ethan Gonzalez</div>\n-┊ 9┊  ┊            <div>You on your way?</div>\n-┊10┊  ┊            <div>10:25</div>\n-┊11┊  ┊        </li>\n-┊12┊  ┊        <li>\n-┊13┊  ┊          <img src=\"https://randomuser.me/api/portraits/thumb/men/2.jpg\" alt=\"Profile\"/>\n-┊14┊  ┊          <div>Bryan Wallace</div>\n-┊15┊  ┊            <div>Hey, it's me</div>\n-┊16┊  ┊            <div>13:27</div>\n+┊  ┊ 7┊      {chats.map(chat => (\n+┊  ┊ 8┊        <li key={chat.id}>\n+┊  ┊ 9┊          <img src={chat.picture} alt=\"Profile\" />\n+┊  ┊10┊          <div>{chat.name}</div>\n ┊17┊11┊        </li>\n+┊  ┊12┊      ))}\n ┊18┊13┊    </ul>\n ┊19┊14┊  </div>\n ┊20┊15┊);\n```\n\n[}]: #\n\nWhen running `map` on the `chats` array, it will run a function for each entry in the array and return a value.\nThe function will receive the current entry as a parameter.\nIn our case the function will get the current function and will return a JSX line with the data of that specific chat.\n\nNotice we are also adding the `key` tag with the ID of each chat.\nIf you'll remove that and render again you will see the following error inside the console of your [Chrome developer tools](https://developers.google.com/web/tools/chrome-devtools/):\n`Warning: Each child in a list should have a unique \"key\" prop`.\n\nBy telling React how to identify and distinguish each element using the `key` value we help solve that problem and also making React faster.\nRead [here](https://reactjs.org/docs/lists-and-keys.html) for more in depth explanation.\n\nNow that we rendered a line for each chat, let's add also the last message's content and creation date for each chat:\n\n[{]: <helper> (diffStep \"1.8\" module=\"client\")\n\n#### Client Step 1.8: Failed try to add last message to ChatsList\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;ChatsList.tsx\n```diff\n@@ -8,6 +8,8 @@\n ┊ 8┊ 8┊        <li key={chat.id}>\n ┊ 9┊ 9┊          <img src={chat.picture} alt=\"Profile\" />\n ┊10┊10┊          <div>{chat.name}</div>\n+┊  ┊11┊          <div>{chat.lastMessage.content}</div>\n+┊  ┊12┊          <div>{chat.lastMessage.createdAt}</div>\n ┊11┊13┊        </li>\n ┊12┊14┊      ))}\n ┊13┊15┊    </ul>\n```\n\n[}]: #\n\nTry to run the app again.\n\nYou can see we get a Typescript error.\nThis is because Typescript is smart enough and tells us there might be no last message.\nSo we add a check.\nRemember to always check for null or undefined if optional, don’t write shorter write safer:\n\n[{]: <helper> (diffStep \"1.9\" module=\"client\")\n\n#### Client Step 1.9: Second failed try to add last message to ChatsList\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;ChatsList.tsx\n```diff\n@@ -8,8 +8,10 @@\n ┊ 8┊ 8┊        <li key={chat.id}>\n ┊ 9┊ 9┊          <img src={chat.picture} alt=\"Profile\" />\n ┊10┊10┊          <div>{chat.name}</div>\n+┊  ┊11┊          {chat.lastMessage && (\n ┊11┊12┊          <div>{chat.lastMessage.content}</div>\n ┊12┊13┊          <div>{chat.lastMessage.createdAt}</div>\n+┊  ┊14┊          )}\n ┊13┊15┊        </li>\n ┊14┊16┊      ))}\n ┊15┊17┊    </ul>\n```\n\n[}]: #\n\nNow let's try again.\n\nNow we have a syntax error - A JSX return value can't have more then a single root Element.\nSo in order to return a root element from the function but still display multiple elements in the same level,\nwe can use [React.Fragment](https://reactjs.org/docs/fragments.html) to wrap the returned elements:\n\n[{]: <helper> (diffStep \"1.10\" module=\"client\")\n\n#### Client Step 1.10: Third failed try to add last message to ChatsList\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;ChatsList.tsx\n```diff\n@@ -9,8 +9,10 @@\n ┊ 9┊ 9┊          <img src={chat.picture} alt=\"Profile\" />\n ┊10┊10┊          <div>{chat.name}</div>\n ┊11┊11┊          {chat.lastMessage && (\n-┊12┊  ┊          <div>{chat.lastMessage.content}</div>\n-┊13┊  ┊          <div>{chat.lastMessage.createdAt}</div>\n+┊  ┊12┊            <React.Fragment>\n+┊  ┊13┊              <div>{chat.lastMessage.content}</div>\n+┊  ┊14┊              <div>{chat.lastMessage.createdAt}</div>\n+┊  ┊15┊            </React.Fragment>\n ┊14┊16┊          )}\n ┊15┊17┊        </li>\n ┊16┊18┊      ))}\n```\n\n[}]: #\n\n\nLet's try again.  This time it looks like the format is not correct, so let's format the date using the `moment` library.\n\nLet's install the [`moment`](https://momentjs.com/) library to wrap `lastMessage.createdAt` with a better format.\nMoment has the ability to wrap date objects nicely and rewrite them in a pretty format.\nThis way we can have an elegant time format at which the message was sent e.g. `11:34`.\nTo install:\n\n\t$ yarn add moment\n\n\nAnd now let's import the library by it's name, wrap the value of each chat and call the `format` function with our requested format:\n\n[{]: <helper> (diffStep \"1.11\" files=\"ChatsList.tsx\" module=\"client\")\n\n#### Client Step 1.11: Success adding last message to ChatsList\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;ChatsList.tsx\n```diff\n@@ -1,5 +1,6 @@\n ┊1┊1┊import React from 'react';\n ┊2┊2┊import { chats } from '../../db';\n+┊ ┊3┊import moment from 'moment';\n ┊3┊4┊\n ┊4┊5┊const ChatsList: React.FC = () => (\n ┊5┊6┊  <div>\n```\n```diff\n@@ -11,7 +12,7 @@\n ┊11┊12┊          {chat.lastMessage && (\n ┊12┊13┊            <React.Fragment>\n ┊13┊14┊              <div>{chat.lastMessage.content}</div>\n-┊14┊  ┊              <div>{chat.lastMessage.createdAt}</div>\n+┊  ┊15┊              <div>{moment(chat.lastMessage.createdAt).format('HH:mm')}</div>\n ┊15┊16┊            </React.Fragment>\n ┊16┊17┊          )}\n ┊17┊18┊        </li>\n```\n\n[}]: #\n\n\nIf you'll try to run the app you'll see that everything is there, but it's not hard to notice that it's missing some style:\n\n![naked-chats-list](https://user-images.githubusercontent.com/7648874/54028578-73099b80-41e0-11e9-803a-7469300acb06.png)\n\nIn the next chapter we will take care of styling our application with [Material-UI](https://material-ui.com/) and [styled-components](https://www.styled-components.com/) - we will give it the desired look and make it more user friendly. For now the ChatsListScreen serves no purpose, because you can't really do anything with it, but it can be used as a great basis to build on top of as we make progress.\n\nTODO: Define and use Prettier.\nTODO: Editor and Prettier, extensions - Auto Import, GitLens, npm Intellisense, TypeScript Importer - works when Auto Import doesn't\nTODO: react-dev-tools, go through everything on dev tools.\nTODO: build. show built code. show it on file and show it on the browser.\nTODO: Go through all of https://facebook.github.io/create-react-app/docs/\nTODO: Should we talk about Storybook?\nTODO: Should we use “” or ‘’?\nTODO: Should we use date-fns instead of moment?"
          },
          {
            "manualTitle": "Step 2: Styling with Material UI and styled-components",
            "stepRevision": "6cbeea8a1ed4b498ab29a90210b610854489d4c7",
            "manualView": "Now it's time to style our app.\n\nWe can edit styles manually but we can also usie ready made components that have already been styled and shared in the community.\n\nIn this chapter we will do both.\n\nFirst, we would also use [Material-UI](https://material-ui.com/) - a library with a set of React components that implements Google's Material Design.\nWhat's good about it is that the design is already implemented right out of the box.\nNot only that, but it also includes a set of icons which are free to use.\n\nThere are many things that Material-UI can offer, and it's not easy to follow it up, especially with the constantly evolving and improving API.\nThe best way to go with it, is to identify a component you need, and then look for it in the [official website](https://material-ui.com/).\nAnd when it comes to searching for icons, they can be found on the [material.io](https://material-ui.com/) website through the search bar.\n\nAs we move further in this tutorial you should have a better grasp of Material and how to use it.\n\n![material-ui-icons](https://user-images.githubusercontent.com/7648874/54141504-c853e000-4460-11e9-94b5-aae98ec9a1e3.png)\n\nWe will start off by installing some of the needed material libraries and its Typescript types library:\n\n    $ yarn add @material-ui/core @material-ui/icons @types/material-ui\n\n`@material-ui/core` includes core component of Material-UI such as Input, Popover, Modal, etc, and `@material-ui/icons` includes a set of icons.\nMaterial is very generic and has a built in theming system which can be controlled by simply setting few variables,\nwhich is exactly what we're gonna need in our app.\n\nIn our app we're mainly gonna use 2 colors:\n\n- Primary #306759\n- Secondary #79e352\n\nThe easiest way to reference colors without repeating yourself is through Themes.\nTheme definition can easily be done in Material using the MuiThemeProvider component:\n\n[{]: <helper> (diffStep \"2.2\" module=\"client\")\n\n#### Client Step 2.2: Setup Material-UI theme\n\n##### Changed src&#x2F;index.tsx\n```diff\n@@ -1,10 +1,25 @@\n+┊  ┊ 1┊import { MuiThemeProvider, createMuiTheme } from '@material-ui/core/styles'\n ┊ 1┊ 2┊import React from 'react';\n ┊ 2┊ 3┊import ReactDOM from 'react-dom';\n ┊ 3┊ 4┊import './index.css';\n ┊ 4┊ 5┊import App from './App';\n ┊ 5┊ 6┊import * as serviceWorker from './serviceWorker';\n ┊ 6┊ 7┊\n-┊ 7┊  ┊ReactDOM.render(<App />, document.getElementById('root'));\n+┊  ┊ 8┊const theme = createMuiTheme({\n+┊  ┊ 9┊  palette: {\n+┊  ┊10┊    primary: { main: '#2c6157' },\n+┊  ┊11┊    secondary: { main: '#6fd056' },\n+┊  ┊12┊  },\n+┊  ┊13┊  typography: {\n+┊  ┊14┊    useNextVariants: true,\n+┊  ┊15┊  },\n+┊  ┊16┊})\n+┊  ┊17┊\n+┊  ┊18┊ReactDOM.render(\n+┊  ┊19┊  <MuiThemeProvider theme={theme}>\n+┊  ┊20┊    <App />\n+┊  ┊21┊  </MuiThemeProvider>\n+┊  ┊22┊, document.getElementById('root'));\n ┊ 8┊23┊\n ┊ 9┊24┊// If you want your app to work offline and load faster, you can change\n ┊10┊25┊// unregister() to register() below. Note this comes with some pitfalls.\n```\n\n[}]: #\n\n\nWe create a `palette` of the themes together with any other definitions for the theme, and then we wrap our app with a React component\nfrom the `material-ui` library to provide those definitions to all of our App's components when they need them.\n\nOnce we have it set, the colors should be available to use in our application by simply providing the \"color\" prop to the component instance whose color we would like to change:\n\n```diff\n<Button color=\"primary\">Primary</Button>\n<Button color=\"secondary\">Secondary</Button>\n```\n\nIn our app, we're also gonna use CSS directly to change its colors, therefore it would be handy to have these theme variables available to us through CSS.\nTo do so, we will have a second definition of these variables in `index.css`, at the `:root` level of our application.\n\nThat feels like a small duplication but this will help us use them in styled components directly.\nAlso that means you can view the variables in chrome-dev-tools.\n\n[{]: <helper> (diffStep \"2.3\" module=\"client\")\n\n#### Client Step 2.3: Setup CSS theme vars\n\n##### Changed src&#x2F;index.css\n```diff\n@@ -1,3 +1,10 @@\n+┊  ┊ 1┊:root {\n+┊  ┊ 2┊  --primary-bg: #2c6157;\n+┊  ┊ 3┊  --secondary-bg: #6fd056;\n+┊  ┊ 4┊  --primary-text: white;\n+┊  ┊ 5┊  --secondary-text: white;\n+┊  ┊ 6┊}\n+┊  ┊ 7┊\n ┊ 1┊ 8┊body {\n ┊ 2┊ 9┊  margin: 0;\n ┊ 3┊10┊  padding: 0;\n```\n\n[}]: #\n\n`:root` is a pseudo element that simply represents the root node, which will make the colors available in all elements.\nNormally, it works like JavaScript's scoping system and it will make variables available only to the current node and to its children, NOT its parents.\nCSS vars can be used like so:\n\n```css\n  color: var(--primary-text);\n  background-color: var(--primary-bg);\n```\n\nMore information about CSS variables can be found in the [official MDN docs](https://developer.mozilla.org/en-US/docs/Web/CSS/Using_CSS_variables).\n\nSo getting back to the ChatsListScreen, we will wrap the ChatsNavbar with Material's <Toolbar /> component:\n\n[{]: <helper> (diffStep \"2.4\" files=\"ChatsNavbar.tsx\" module=\"client\")\n\n#### Client Step 2.4: Use Material components\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;ChatsNavbar.tsx\n```diff\n@@ -1,9 +1,10 @@\n ┊ 1┊ 1┊import React from 'react';\n+┊  ┊ 2┊import { Toolbar } from '@material-ui/core';\n ┊ 2┊ 3┊\n ┊ 3┊ 4┊const ChatsNavbar: React.FC = () => (\n-┊ 4┊  ┊  <div>\n+┊  ┊ 5┊  <Toolbar>\n ┊ 5┊ 6┊    Whatsapp Clone\n-┊ 6┊  ┊  </div>\n+┊  ┊ 7┊  </Toolbar>\n ┊ 7┊ 8┊);\n ┊ 8┊ 9┊\n ┊ 9┊10┊export default ChatsNavbar;🚫↵\n```\n\n[}]: #\n\nAnd we will replace the `<ul />` and `<li />` elements with Material's `<List />` and `<ListItem />` in ChatsList:\n\n[{]: <helper> (diffStep \"2.4\" files=\"ChatsList.tsx\" module=\"client\")\n\n#### Client Step 2.4: Use Material components\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;ChatsList.tsx\n```diff\n@@ -1,12 +1,13 @@\n ┊ 1┊ 1┊import React from 'react';\n ┊ 2┊ 2┊import { chats } from '../../db';\n ┊ 3┊ 3┊import moment from 'moment';\n+┊  ┊ 4┊import { List, ListItem } from '@material-ui/core';\n ┊ 4┊ 5┊\n ┊ 5┊ 6┊const ChatsList: React.FC = () => (\n ┊ 6┊ 7┊  <div>\n-┊ 7┊  ┊    <ul>\n+┊  ┊ 8┊    <List>\n ┊ 8┊ 9┊      {chats.map(chat => (\n-┊ 9┊  ┊        <li key={chat.id}>\n+┊  ┊10┊        <ListItem key={chat.id} button>\n ┊10┊11┊          <img src={chat.picture} alt=\"Profile\" />\n ┊11┊12┊          <div>{chat.name}</div>\n ┊12┊13┊          {chat.lastMessage && (\n```\n```diff\n@@ -15,9 +16,9 @@\n ┊15┊16┊              <div>{moment(chat.lastMessage.createdAt).format('HH:mm')}</div>\n ┊16┊17┊            </React.Fragment>\n ┊17┊18┊          )}\n-┊18┊  ┊        </li>\n+┊  ┊19┊        </ListItem>\n ┊19┊20┊      ))}\n-┊20┊  ┊    </ul>\n+┊  ┊21┊    </List>\n ┊21┊22┊  </div>\n ┊22┊23┊);\n ┊23┊24┊\n```\n\n[}]: #\n\nThanks to the `button` attribute, the Material component can give our list a more vibrant feeling and that will display a nice ripple effect once an item is clicked,\nsomething that could have taken a long time to implement manually.\n\nNow that we are using existing styled components, it's time to customize them to look exactly like we want them to look.\nWhen we write styles, we usually use CSS.\n\nOne of the important concepts that React brought us was the fact we could use just Javascript to describe our components\nand another was the fact that we could encapsulate our UI into a set of separated components.\n\nBut when it comes to CSS, we are still using it like before, having no encapsulation between different definitions and files.\n\n[Styled-components](https://www.styled-components.com/) is a relatively new library that will transpile a given string into a CSS string and will encapsulate it under a `React.Component`.\nBringing the same concepts from React into the way we write styles, so we ca define our styles programmatically.\nWith JavaScript in-hand you naturally have more control over our styles and its encapsulation, which makes it a very powerful tool.\n\nHere's one way to style a button using styled-components:\n\n```js\nimport styled, { css } from 'styled-components';\n\nconst Button = styled.button`\n  background: transparent;\n  border-radius: 3px;\n  border: 2px solid palevioletred;\n  color: palevioletred;\n  margin: 0.5em 1em;\n  padding: 0.25em 1em;\n\n  ${props => props.primary && css`\n    background: palevioletred;\n    color: white;\n  `}\n`;\n```\n\n* `styled` is coming from the `styled-components` library. When we call `styled.button` that means we are extending a button component from styled.\n* `Button` will become a full React componnet with the extended styled we specified\n* Like a React component, we can send props into our component. And like a React function, we can write Javascript code that interact and respond to those props.\nIn our case, just like a check we've done before in TSX to render something only if it exists, here only if we have a `primary` property, we will add extra styles to our component.\nThe created Button is actually a React.Component, so an instance of it can be created with ease like any other component:\n* `css` is telling Styled components that the string literal that comes after describes CSS styles.\n\n```jsx\n  <Button primary />\n```\n\nBut as this is just like a component, we should type it just like we type component, defining what properties it should get in:\n\n```tsx\nimport styled, { css } from 'styled-components';\n\ninterface ButtonProps {\n  readonly primary: any;\n};\n\nconst Button = styled.button<ButtonProps>`\n  background: transparent;\n  border-radius: 3px;\n  border: 2px solid palevioletred;\n  color: palevioletred;\n  margin: 0.5em 1em;\n  padding: 0.25em 1em;\n\n  ${props => props.primary && css`\n    background: palevioletred;\n    color: white;\n  `}\n`;\n```\n\nMore information about styled-components can be found in the official [docs page](https://www.styled-components.com/docs).\n\nNow, we will use `styled-components` to create new React.Components which are bound into a style-sheet.\nThis way when we create new instances of them, the components will be styled right out of the box. Example:\n\n```jsx\nconst Button = styled.button `\n  border-radius: 999px;\n`\n\nconst RedButton = styled(Button) `\n  color: red;\n`\n\nconst GreenButton = styled(Button) `\n  color: green;\n`\n\nconst BlueButton = styled(Button) `\n  color: blue;\n`\n\nconst Dashboard = (\n  <div>\n    <RedButton />\n    <GreenButton />\n    <BlueButton />\n  </div>\n)\n```\n\nThe clear advantage of such working strategy is that all the styles are encapsulated, unlike traditional CSS where style rules can easily collide and be merged unintentionally.\nRemember that **`styled-components` operates per component, not globally**.\n\nWe will start off by installing `styled-components` and its Typescript types library:\n\n    $ yarn add styled-components @types/styled-components\n\nNow, let's use `styled-components` our `ChatsListScreen`:\n\n[{]: <helper> (diffStep \"2.5\" files=\"index.tsx\" module=\"client\")\n\n#### Client Step 2.5: Add style with styled-components\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;index.tsx\n```diff\n@@ -1,12 +1,17 @@\n ┊ 1┊ 1┊import React from 'react';\n ┊ 2┊ 2┊import ChatsNavbar from './ChatsNavbar';\n ┊ 3┊ 3┊import ChatsList from './ChatsList';\n+┊  ┊ 4┊import styled from 'styled-components';\n+┊  ┊ 5┊\n+┊  ┊ 6┊const Container = styled.div `\n+┊  ┊ 7┊  height: 100vh;\n+┊  ┊ 8┊`;\n ┊ 4┊ 9┊\n ┊ 5┊10┊const ChatsListScreen: React.FC = () => (\n-┊ 6┊  ┊  <div>\n+┊  ┊11┊  <Container>\n ┊ 7┊12┊    <ChatsNavbar />\n ┊ 8┊13┊    <ChatsList />\n-┊ 9┊  ┊  </div>\n+┊  ┊14┊  </Container>\n ┊10┊15┊);\n ┊11┊16┊\n ┊12┊17┊export default ChatsListScreen;🚫↵\n```\n\n[}]: #\n\nHere you can see that we've created a new component called `Container`.\nThat component is extending `div` and adds some styles into it.\nThen we've replaced the `div` element with the new, enhanced `div` called `Container`.\n\nWith this we know for sure that the styles we applied for `Container` won't affect any other component in our app.\n\n[{]: <helper> (diffStep \"2.5\" files=\"ChatsNavbar.tsx\" module=\"client\")\n\n#### Client Step 2.5: Add style with styled-components\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;ChatsNavbar.tsx\n```diff\n@@ -1,10 +1,18 @@\n ┊ 1┊ 1┊import React from 'react';\n ┊ 2┊ 2┊import { Toolbar } from '@material-ui/core';\n+┊  ┊ 3┊import styled from 'styled-components';\n+┊  ┊ 4┊\n+┊  ┊ 5┊const Container = styled(Toolbar) `\n+┊  ┊ 6┊  background-color: var(--primary-bg);\n+┊  ┊ 7┊  color: var(--primary-text);\n+┊  ┊ 8┊  font-size: 20px;\n+┊  ┊ 9┊  line-height: 40px;\n+┊  ┊10┊` as typeof Toolbar;\n ┊ 3┊11┊\n ┊ 4┊12┊const ChatsNavbar: React.FC = () => (\n-┊ 5┊  ┊  <Toolbar>\n+┊  ┊13┊  <Container>\n ┊ 6┊14┊    Whatsapp Clone\n-┊ 7┊  ┊  </Toolbar>\n+┊  ┊15┊  </Container>\n ┊ 8┊16┊);\n ┊ 9┊17┊\n ┊10┊18┊export default ChatsNavbar;🚫↵\n```\n\n[}]: #\n\nHere you can see we've done the same, but instead of extending a built-in component from styled-component,\nwe enhanced the `Toolbar` component from `material-ui.\n\nNotice that we also called the wrapper `Container` but again it has no affect on any component outside of our specific component.\n\n> Notice that we've added Typescript type inference `as typeof Toolbar` at the end. That's because of an issue that suppose to be fixed when we'll upgrade to material-ui v4.\n\nLet's finish this off by doing the same in our last component:\n\n[{]: <helper> (diffStep \"2.5\" files=\"ChatsList.tsx\" module=\"client\")\n\n#### Client Step 2.5: Add style with styled-components\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;ChatsList.tsx\n```diff\n@@ -2,24 +2,79 @@\n ┊ 2┊ 2┊import { chats } from '../../db';\n ┊ 3┊ 3┊import moment from 'moment';\n ┊ 4┊ 4┊import { List, ListItem } from '@material-ui/core';\n+┊  ┊ 5┊import styled from 'styled-components';\n ┊ 5┊ 6┊\n-┊ 6┊  ┊const ChatsList: React.FC = () => (\n-┊ 7┊  ┊  <div>\n-┊ 8┊  ┊    <List>\n-┊ 9┊  ┊      {chats.map(chat => (\n-┊10┊  ┊        <ListItem key={chat.id} button>\n-┊11┊  ┊          <img src={chat.picture} alt=\"Profile\" />\n-┊12┊  ┊          <div>{chat.name}</div>\n-┊13┊  ┊          {chat.lastMessage && (\n-┊14┊  ┊            <React.Fragment>\n-┊15┊  ┊              <div>{chat.lastMessage.content}</div>\n-┊16┊  ┊              <div>{moment(chat.lastMessage.createdAt).format('HH:mm')}</div>\n-┊17┊  ┊            </React.Fragment>\n-┊18┊  ┊          )}\n-┊19┊  ┊        </ListItem>\n+┊  ┊ 7┊const Container = styled.div `\n+┊  ┊ 8┊  height: calc(100% - 56px);\n+┊  ┊ 9┊  overflow-y: overlay;\n+┊  ┊10┊`;\n+┊  ┊11┊\n+┊  ┊12┊const StyledList = styled(List) `\n+┊  ┊13┊  padding: 0 !important;\n+┊  ┊14┊` as typeof List;\n+┊  ┊15┊\n+┊  ┊16┊const StyledListItem = styled(ListItem) `\n+┊  ┊17┊  height: 76px;\n+┊  ┊18┊  padding: 0 15px;\n+┊  ┊19┊  display: flex;\n+┊  ┊20┊` as typeof ListItem;\n+┊  ┊21┊\n+┊  ┊22┊const ChatPicture = styled.img `\n+┊  ┊23┊  height: 50px;\n+┊  ┊24┊  width: 50px;\n+┊  ┊25┊  object-fit: cover;\n+┊  ┊26┊  border-radius: 50%;\n+┊  ┊27┊`;\n+┊  ┊28┊\n+┊  ┊29┊const ChatInfo = styled.div `\n+┊  ┊30┊  width: calc(100% - 60px);\n+┊  ┊31┊  height: 46px;\n+┊  ┊32┊  padding: 15px 0;\n+┊  ┊33┊  margin-left: 10px;\n+┊  ┊34┊  border-bottom: 0.5px solid silver;\n+┊  ┊35┊  position: relative;\n+┊  ┊36┊`;\n+┊  ┊37┊\n+┊  ┊38┊const ChatName = styled.div `\n+┊  ┊39┊  margin-top: 5px;\n+┊  ┊40┊`;\n+┊  ┊41┊\n+┊  ┊42┊const MessageContent = styled.div `\n+┊  ┊43┊  color: gray;\n+┊  ┊44┊  font-size: 15px;\n+┊  ┊45┊  margin-top: 5px;\n+┊  ┊46┊  text-overflow: ellipsis;\n+┊  ┊47┊  overflow: hidden;\n+┊  ┊48┊  white-space: nowrap;\n+┊  ┊49┊`;\n+┊  ┊50┊\n+┊  ┊51┊const MessageDate = styled.div `\n+┊  ┊52┊  position: absolute;\n+┊  ┊53┊  color: gray;\n+┊  ┊54┊  top: 20px;\n+┊  ┊55┊  right: 0;\n+┊  ┊56┊  font-size: 13px;\n+┊  ┊57┊`;\n+┊  ┊58┊\n+┊  ┊59┊const ChatsList = () => (\n+┊  ┊60┊  <Container>\n+┊  ┊61┊    <StyledList>\n+┊  ┊62┊      {chats.map((chat) => (\n+┊  ┊63┊        <StyledListItem key={chat.id} button>\n+┊  ┊64┊          <ChatPicture src={chat.picture} alt=\"Profile\"/>\n+┊  ┊65┊          <ChatInfo>\n+┊  ┊66┊            <ChatName>{chat.name}</ChatName>\n+┊  ┊67┊            {chat.lastMessage && (\n+┊  ┊68┊              <React.Fragment>\n+┊  ┊69┊                <MessageContent>{chat.lastMessage.content}</MessageContent>\n+┊  ┊70┊                <MessageDate>{moment(chat.lastMessage.createdAt).format('HH:mm')}</MessageDate>\n+┊  ┊71┊              </React.Fragment>\n+┊  ┊72┊            )}\n+┊  ┊73┊          </ChatInfo>\n+┊  ┊74┊        </StyledListItem>\n ┊20┊75┊      ))}\n-┊21┊  ┊    </List>\n-┊22┊  ┊  </div>\n+┊  ┊76┊    </StyledList>\n+┊  ┊77┊  </Container>\n ┊23┊78┊);\n ┊24┊79┊\n ┊25┊80┊export default ChatsList;🚫↵\n```\n\n[}]: #\n\nNotice that we've changed the structure of the HTML of the `ChatsList` component.\nWe've added the ChatInfo to allow better alignment of the elements.\n\nWe're done styling `ChatsListScreen`. We will keep using the same principles to style the rest of the components in our application. The final result should look like so:\n\n![screenshot](https://user-images.githubusercontent.com/7648874/54141766-40baa100-4461-11e9-8dd0-59edcfdb3b84.png)\n\n\nTODO: What do people think about https://www.styled-components.com/docs/tooling#babel-plugin, should we use it here?"
          },
          {
            "manualTitle": "Step 3: Setup a basic Node.JS server with a basic REST endpoint",
            "stepRevision": "fe6585f4ef8228e7732e90efa2f4092ea2789f29",
            "manualView": "Currently we have a running app with a single screen which looks stylish and presents some data to the user.\n\nThere is something missing though - The data that we are displaying can't be changed in any way.\n\nbut even if we'll change the data, there is still a more fundamental issue - all of the data lives on the client.\n\nThat means that each client has it's own copy of the data and the data is not shared between them,\nif a client will create a new message, only that client will have the new message and not the client that the message was sent to.\n\nAlso if the client will shut down, all data will be lost.\n\nSo how can we have a place to put data that is being shared between all clients?\n\nWe should find a central machine that all clients will connect to and get the data from.\nIf some client wants to create a new message, it will create it on that central machine so that the next time another clients will ask for the available messages,\nall those messages will be available on the central machine.\n\nThat central machine that stores data is called a database. and the machine that communicates between the database and the client is called a server.\n\nIn this step, we will write a NodeJS server (server that runs using the Javascript language) and will expose a REST endpoint that will serve the data-mock.\nWe will build the REST application using [Express](https://www.npmjs.com/package/express).\nFurther in this tutorial, we will migrate to using a real data-base with real I/O from the user, because at this point, if the server will shut down, all data will be lost.\n\nThe plan is to have a server up and running at `localhost:4000` that will expose a `GET /chats` route.\nUnlike our client application, we're not gonna use any boilerplate and we're gonna set everything up manually.\n\nRight outside the client project, we will create a new directory called `whatsapp-clone-server` in which we will start creating our server:\n\n    $ mkdir whatsapp-clone-server\n    $ cd whatsapp-clone-server\n\nThen we will use `Yarn` to initialize a new project:\n\n    $ yarn init -yp\n\nThere's nothing special about this command, it only creates a basic `package.json` file.\nJust to make sure that things work, we will add an `index.js` file which will print `\"hello world\"` to the console.\n\n[{]: <helper> (diffStep \"1.1\" files=\"index.js\" module=\"server\")\n\n#### [Server Step 1.1: Create start script](https://github.com/Urigo/WhatsApp-Clone-Server/commit/adbc199)\n\n##### Added index.js\n```diff\n@@ -0,0 +1 @@\n+┊ ┊1┊console.log('hello world')\n```\n\n[}]: #\n\nAnd we will add a startup script to the `package.json` file called `start`:\n\n    \"start\": \"node index.js\"\n\nNPM-scripts are just a way to defined an alias for commands. Now we only have one simple script,\nbut it can turn out to be something very complex depending on our server, so it can be very useful.\nMore about npm-scripts can be found in the [official NPM docs](https://docs.npmjs.com/misc/scripts).\n\nNow we can run our server by running `$ yarn start` and we should see the message \"hello world\" printed to the console, as expected.\n\nLike in our client's app, we will be using TypeScript.\nIn order to use TypeScript we will install few packages:\n\n    $ yarn add --dev typescript ts-node @types/node\n\n> Note how we used the `--dev` flag. It is a good practice to separate between production dependencies and development dependencies.\nThat way when you deploy your server to the real environment, you won't install the unnecessary development dependencies there.\nMore about the `--dev` option can be read in the [NPM-install docs](https://docs.npmjs.com/cli/install).\n\n- The [`typescript`](https://www.npmjs.com/package/typescript) package is TypeScript's core transpiler.\n- [`ts-node`](https://www.npmjs.com/package/ts-node) is an interpreter that will transpile required `.ts` files into JavaScript at runtime.\n- [`@types/node`](https://www.npmjs.com/package/@types/node) will make the appropriate definitions for a Node.JS environment.\n\n> You can read more about the `@types` monorepo in the [official GitHub repository](https://github.com/DefinitelyTyped/DefinitelyTyped).\n\nWe will rename the `index.js` file to `index.ts`:\n\n    $ mv index.js index.ts\n\nNow we need to compile the `ts` file to turn it into a Javascript file the Node can run.\n\nFor that we will use Typescript and its `tsc` command.\nThe command has many options, but instead of writing them in the command line, we can specify them in a `tsconfig.json` file at the root of the project.\n\nOur server is gonna use the following `tsconfig.json` file, feel free to make the necessary modifications based on your needs:\n\n[{]: <helper> (diffStep \"1.2\" files=\"tsconfig.json\" module=\"server\")\n\n#### [Server Step 1.2: Setup TypeScript](https://github.com/Urigo/WhatsApp-Clone-Server/commit/0dcf18c)\n\n##### Added tsconfig.json\n```diff\n@@ -0,0 +1,16 @@\n+┊  ┊ 1┊{\n+┊  ┊ 2┊  \"compilerOptions\": {\n+┊  ┊ 3┊    \"target\": \"es2018\",\n+┊  ┊ 4┊    \"module\": \"commonjs\",\n+┊  ┊ 5┊    \"lib\": [\n+┊  ┊ 6┊      \"es2018\",\n+┊  ┊ 7┊      \"esnext.asynciterable\"\n+┊  ┊ 8┊    ],\n+┊  ┊ 9┊    \"strict\": true,\n+┊  ┊10┊    \"strictFunctionTypes\": false,\n+┊  ┊11┊    \"strictPropertyInitialization\": false,\n+┊  ┊12┊    \"esModuleInterop\": true,\n+┊  ┊13┊    \"experimentalDecorators\": true,\n+┊  ┊14┊    \"emitDecoratorMetadata\": true\n+┊  ┊15┊  }\n+┊  ┊16┊}\n```\n\n[}]: #\n\nWe need to tell Typescript which files to compile. Those are in the `include` key.\n\nNow let's run `tsc` and see what happens.\n\nWe've got a new `index.js` file!  Now let's run it by running `node index.js`.\n\nThat's great, but doing this work each time we change a file can be annoying,\nso let's use tools to track when files change and make them run the code automatically after.\n\nAnd we will update the npm-script `start` to use `ts-node`, since we wanna use TypeScript, and not JavaScript directly:\n\n    start: ts-node index.ts\n\nWe can test the startup of our server again by running `$ yarn start` and we should see the message \"hello world\" printed to the console.\n\nThe skeleton of the project is set and we can move on to implementing the REST API.\n\nLike we said at the beginning, we will be using Express to setup the API. Express is a wrapper around the native [Node.JS \"http\"](https://nodejs.org/api/http.html) library which is responsible for handling HTTP requests.\nYes, it can also be used directly, but Express is much more comfortable and has an amazing ecosystem built around it.\nLet's install Express and its TypeScript definitions:\n\n    $ yarn add express\n    $ yarn add --dev @types/express\n\nBefore we implement the `GET /chats` route we will implement a `GET /_ping` route. This route will be used to determine whether the server is up and running or not, and how fast the connection is based on the response time.\nFor every request sent to this route, we should expect a response saying \"pong\".\nSome call it \"heartbeat\", because this route is being tested repeatedly by the hosting machine to check if it's alive, just like a heartbeat in a way.\nThis is how the route should look like:\n\n[{]: <helper> (diffStep \"1.3\" files=\"index.ts\" module=\"server\")\n\n#### [Server Step 1.3: Setup a Express with a basic health check route](https://github.com/Urigo/WhatsApp-Clone-Server/commit/4a60e4b)\n\n##### Changed index.ts\n```diff\n@@ -1 +1,13 @@\n-┊ 1┊  ┊console.log('hello world')\n+┊  ┊ 1┊import express from 'express'\n+┊  ┊ 2┊\n+┊  ┊ 3┊const app = express()\n+┊  ┊ 4┊\n+┊  ┊ 5┊app.get('/_ping', (req, res) => {\n+┊  ┊ 6┊  res.send('pong')\n+┊  ┊ 7┊})\n+┊  ┊ 8┊\n+┊  ┊ 9┊const port = process.env.PORT || 4000\n+┊  ┊10┊\n+┊  ┊11┊app.listen(port, () => {\n+┊  ┊12┊  console.log(`Server is listening on port ${port}`)\n+┊  ┊13┊})\n```\n\n[}]: #\n\nWe can use the\n\n        `$ curl localhost:4000/_ping`\n\ncommand to send a request to the server and we should get a \"pong\", assuming that the server available on that URL.\nThe `GET /chats` should be implemented similarly, only the response is different. Instead of returning \"pong\" we will return the data-mock for our chats:\n\n[{]: <helper> (diffStep \"1.4\" files=\"index.ts, db.ts\" module=\"server\")\n\n#### [Server Step 1.4: Create GET /chats route](https://github.com/Urigo/WhatsApp-Clone-Server/commit/e216866)\n\n##### Added db.ts\n```diff\n@@ -0,0 +1,49 @@\n+┊  ┊ 1┊export const messages = [\n+┊  ┊ 2┊  {\n+┊  ┊ 3┊    id: '1',\n+┊  ┊ 4┊    content: \"You on your way?\",\n+┊  ┊ 5┊    createdAt: new Date(new Date('1-1-2019').getTime() - 60 * 1000 * 1000),\n+┊  ┊ 6┊  },\n+┊  ┊ 7┊  {\n+┊  ┊ 8┊    id: '2',\n+┊  ┊ 9┊    content: \"Hey, it's me\",\n+┊  ┊10┊    createdAt: new Date(new Date('1-1-2019').getTime() - 2 * 60 * 1000 * 1000),\n+┊  ┊11┊  },\n+┊  ┊12┊  {\n+┊  ┊13┊    id: '3',\n+┊  ┊14┊    content: \"I should buy a boat\",\n+┊  ┊15┊    createdAt: new Date(new Date('1-1-2019').getTime() - 24 * 60 * 1000 * 1000),\n+┊  ┊16┊  },\n+┊  ┊17┊  {\n+┊  ┊18┊    id: '4',\n+┊  ┊19┊    content: \"This is wicked good ice cream.\",\n+┊  ┊20┊    createdAt: new Date(new Date('1-1-2019').getTime() - 14 * 24 * 60 * 1000 * 1000),\n+┊  ┊21┊  },\n+┊  ┊22┊]\n+┊  ┊23┊\n+┊  ┊24┊export const chats = [\n+┊  ┊25┊  {\n+┊  ┊26┊    id: '1',\n+┊  ┊27┊    name: 'Ethan Gonzalez',\n+┊  ┊28┊    picture: 'https://randomuser.me/api/portraits/thumb/men/1.jpg',\n+┊  ┊29┊    lastMessage: '1',\n+┊  ┊30┊  },\n+┊  ┊31┊  {\n+┊  ┊32┊    id: '2',\n+┊  ┊33┊    name: 'Bryan Wallace',\n+┊  ┊34┊    picture: 'https://randomuser.me/api/portraits/thumb/men/2.jpg',\n+┊  ┊35┊    lastMessage: '2',\n+┊  ┊36┊  },\n+┊  ┊37┊  {\n+┊  ┊38┊    id: '3',\n+┊  ┊39┊    name: 'Avery Stewart',\n+┊  ┊40┊    picture: 'https://randomuser.me/api/portraits/thumb/women/1.jpg',\n+┊  ┊41┊    lastMessage: '3',\n+┊  ┊42┊  },\n+┊  ┊43┊  {\n+┊  ┊44┊    id: '4',\n+┊  ┊45┊    name: 'Katie Peterson',\n+┊  ┊46┊    picture: 'https://randomuser.me/api/portraits/thumb/women/2.jpg',\n+┊  ┊47┊    lastMessage: '4',\n+┊  ┊48┊  },\n+┊  ┊49┊]\n```\n\n##### Changed index.ts\n```diff\n@@ -1,4 +1,5 @@\n ┊1┊1┊import express from 'express'\n+┊ ┊2┊import { chats } from './db'\n ┊2┊3┊\n ┊3┊4┊const app = express()\n ┊4┊5┊\n```\n```diff\n@@ -6,6 +7,10 @@\n ┊ 6┊ 7┊  res.send('pong')\n ┊ 7┊ 8┊})\n ┊ 8┊ 9┊\n+┊  ┊10┊app.get('/chats', (req, res) => {\n+┊  ┊11┊  res.json(chats)\n+┊  ┊12┊})\n+┊  ┊13┊\n ┊ 9┊14┊const port = process.env.PORT || 4000\n ┊10┊15┊\n ┊11┊16┊app.listen(port, () => {\n```\n\n[}]: #\n\nTODO: Mention `_req`\n\nCheck we can get the chats by running:\n\n        `$ curl localhost:4000/chats`\n\nUnlike the previous route, we used the `.json()` method this time around to send a response. This will simply stringify the given JSON and set the right headers.\nSimilarly to the client, we've defined the db mock in a dedicated file, as this is easier to maintain and look at.\n\nIt's also recommended to connect a middleware called [`cors`](https://www.npmjs.com/package/cors) which will enable cross-origin requests.\nWithout it we will only be able to make requests in localhost, something which is likely to limit us in the future because we would probably host our server somewhere separate than the client application.\nWithout it it will also be impossible to call the server from our client app.\nLet's install the `cors` library and load it with the Express `middleware()` function:\n\n    $ yarn add cors\n\nand its Typescript types:\n\n\n    $ yarn add --dev @types/cors\n\n[{]: <helper> (diffStep \"1.4\" files=\"index.ts\" module=\"server\")\n\n#### [Server Step 1.4: Create GET /chats route](https://github.com/Urigo/WhatsApp-Clone-Server/commit/e216866)\n\n##### Changed index.ts\n```diff\n@@ -1,4 +1,5 @@\n ┊1┊1┊import express from 'express'\n+┊ ┊2┊import { chats } from './db'\n ┊2┊3┊\n ┊3┊4┊const app = express()\n ┊4┊5┊\n```\n```diff\n@@ -6,6 +7,10 @@\n ┊ 6┊ 7┊  res.send('pong')\n ┊ 7┊ 8┊})\n ┊ 8┊ 9┊\n+┊  ┊10┊app.get('/chats', (req, res) => {\n+┊  ┊11┊  res.json(chats)\n+┊  ┊12┊})\n+┊  ┊13┊\n ┊ 9┊14┊const port = process.env.PORT || 4000\n ┊10┊15┊\n ┊11┊16┊app.listen(port, () => {\n```\n\n[}]: #\n\nThe server is now ready to use!\n\nSo getting back to the client, first we will define our server's URL under the `.env` file:\n\n[{]: <helper> (diffStep \"3.1\" module=\"client\")\n\n#### Client Step 3.1: Define server URL\n\n##### Added .env\n```diff\n@@ -0,0 +1 @@\n+┊ ┊1┊REACT_APP_SERVER_URL=http://localhost:4000🚫↵\n```\n\n[}]: #\n\nThis will make our server's URL available under the `process.env.REACT_APP_SERVER_URL` member expression and it will be replaced with a fixed value at build time, just like macros.\nThe `.env` file is a file which will automatically be loaded to `process.env` by the [`dotenv`](https://www.npmjs.com/package/dotenv) NPM package.\n`react-scripts` then filters environment variables which have a `REACT_APP_` prefix and provides the created JSON to a Webpack plugin called [DefinePlugin](https://webpack.js.org/plugins/define-plugin/), which will result in the macro effect.\n\nNow let's move back into our React app folder.\nWe will now replace the local data-mock usage with a fetch from the server.\nFor that we can use the native [fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API),\nhowever, it needs to be used in the right life-cycle hook of the React.Component.\n\nThere are 2 naive approaches for that:\n\n- Calling `fetch()` outside the component, but this way that chats will be fetched even if we're not even intending to create an instance of the component.\n\n```js\nfetch().then(() => /* ... */)\nconst MyComponent = () => {}\n```\n\n- Calling `fetch()` inside the component, but then it will be invoked whenever the component is re-rendered.\n\n```js\nconst MyComponent = () => {\n  fetch().then(() => /* ... */)\n}\n```\n\nThese 2 approaches indeed work, but they both fail to deliver what's necessary on the right time.\nIn addition, there's no way to properly coordinate async function calls with the render method of the component.\n\n**Introducing: React hooks**\n\nWith React hooks we can invoke the desired logic in the right life-cycle stage of the target component.\nThis way we can avoid potential memory leaks or extra calculations.\nTo implement a proper `fetch()`, we will be using 2 React hooks:\n\n- [`React.useState()`](https://reactjs.org/docs/hooks-reference.html#usestate) - which is used to get and set a state of the component - will be used to store the chats fetched from the server.\n\n```js\nconst [value, setValue] = useState(initialValue);\n```\n\n- [`React.useMemo()`](https://reactjs.org/docs/hooks-reference.html#usememo) - which is used to run a computation only once certain conditions were met - will be used to run the `fetch()` function only once the component has mounted.\n\n```js\nconst memoizedValue = useMemo(calcFn, [cond1, cond2, ...conds]);\n```\n\nThe result of that approach will look like this, in the context of our ChatsList component:\n\n[{]: <helper> (diffStep \"3.2\" module=\"client\")\n\n#### Client Step 3.2: Fetch chats using native fetch API instead of mock DB\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;ChatsList.tsx\n```diff\n@@ -1,8 +1,8 @@\n ┊1┊1┊import React from 'react';\n-┊2┊ ┊import { chats } from '../../db';\n ┊3┊2┊import moment from 'moment';\n ┊4┊3┊import { List, ListItem } from '@material-ui/core';\n ┊5┊4┊import styled from 'styled-components';\n+┊ ┊5┊import { useState, useMemo } from 'react';\n ┊6┊6┊\n ┊7┊7┊const Container = styled.div `\n ┊8┊8┊  height: calc(100% - 56px);\n```\n```diff\n@@ -56,25 +56,35 @@\n ┊56┊56┊  font-size: 13px;\n ┊57┊57┊`;\n ┊58┊58┊\n-┊59┊  ┊const ChatsList = () => (\n-┊60┊  ┊  <Container>\n-┊61┊  ┊    <StyledList>\n-┊62┊  ┊      {chats.map((chat) => (\n-┊63┊  ┊        <StyledListItem key={chat.id} button>\n-┊64┊  ┊          <ChatPicture src={chat.picture} alt=\"Profile\"/>\n-┊65┊  ┊          <ChatInfo>\n-┊66┊  ┊            <ChatName>{chat.name}</ChatName>\n-┊67┊  ┊            {chat.lastMessage && (\n-┊68┊  ┊              <React.Fragment>\n-┊69┊  ┊                <MessageContent>{chat.lastMessage.content}</MessageContent>\n-┊70┊  ┊                <MessageDate>{moment(chat.lastMessage.createdAt).format('HH:mm')}</MessageDate>\n-┊71┊  ┊              </React.Fragment>\n-┊72┊  ┊            )}\n-┊73┊  ┊          </ChatInfo>\n-┊74┊  ┊        </StyledListItem>\n-┊75┊  ┊      ))}\n-┊76┊  ┊    </StyledList>\n-┊77┊  ┊  </Container>\n-┊78┊  ┊);\n+┊  ┊59┊const ChatsList = () => {\n+┊  ┊60┊  const [chats, setChats] = useState<any[]>([]);\n+┊  ┊61┊\n+┊  ┊62┊  useMemo(async () => {\n+┊  ┊63┊    const body = await fetch(`${process.env.REACT_APP_SERVER_URL}/chats`);\n+┊  ┊64┊    const chats = await body.json();\n+┊  ┊65┊    setChats(chats);\n+┊  ┊66┊  }, []);\n+┊  ┊67┊\n+┊  ┊68┊  return (\n+┊  ┊69┊    <Container>\n+┊  ┊70┊      <StyledList>\n+┊  ┊71┊        {chats.map((chat) => (\n+┊  ┊72┊          <StyledListItem key={chat!.id} button>\n+┊  ┊73┊            <ChatPicture src={chat.picture} alt=\"Profile\"/>\n+┊  ┊74┊            <ChatInfo>\n+┊  ┊75┊              <ChatName>{chat.name}</ChatName>\n+┊  ┊76┊              {chat.lastMessage && (\n+┊  ┊77┊                <React.Fragment>\n+┊  ┊78┊                  <MessageContent>{chat.lastMessage.content}</MessageContent>\n+┊  ┊79┊                  <MessageDate>{moment(chat.lastMessage.createdAt).format('HH:mm')}</MessageDate>\n+┊  ┊80┊                </React.Fragment>\n+┊  ┊81┊              )}\n+┊  ┊82┊            </ChatInfo>\n+┊  ┊83┊          </StyledListItem>\n+┊  ┊84┊        ))}\n+┊  ┊85┊      </StyledList>\n+┊  ┊86┊    </Container>\n+┊  ┊87┊  )\n+┊  ┊88┊};\n ┊79┊89┊\n ┊80┊90┊export default ChatsList;🚫↵\n```\n\n##### Deleted src&#x2F;db.ts\n```diff\n@@ -1,49 +0,0 @@\n-┊ 1┊  ┊export const messages = [\n-┊ 2┊  ┊  {\n-┊ 3┊  ┊    id: 1,\n-┊ 4┊  ┊    content: \"You on your way?\",\n-┊ 5┊  ┊    createdAt: new Date(Date.now() - 60 * 1000 * 1000),\n-┊ 6┊  ┊  },\n-┊ 7┊  ┊  {\n-┊ 8┊  ┊    id: 2,\n-┊ 9┊  ┊    content: \"Hey, it's me\",\n-┊10┊  ┊    createdAt: new Date(Date.now() - 2 * 60 * 1000 * 1000),\n-┊11┊  ┊  },\n-┊12┊  ┊  {\n-┊13┊  ┊    id: 3,\n-┊14┊  ┊    content: \"I should buy a boat\",\n-┊15┊  ┊    createdAt: new Date(Date.now() - 24 * 60 * 1000 * 1000),\n-┊16┊  ┊  },\n-┊17┊  ┊  {\n-┊18┊  ┊    id: 4,\n-┊19┊  ┊    content: \"This is wicked good ice cream.\",\n-┊20┊  ┊    createdAt: new Date(Date.now() - 14 * 24 * 60 * 1000 * 1000),\n-┊21┊  ┊  },\n-┊22┊  ┊];\n-┊23┊  ┊\n-┊24┊  ┊export const chats = [\n-┊25┊  ┊  {\n-┊26┊  ┊    id: 1,\n-┊27┊  ┊    name: 'Ethan Gonzalez',\n-┊28┊  ┊    picture: 'https://randomuser.me/api/portraits/thumb/men/1.jpg',\n-┊29┊  ┊    lastMessage: messages.find(m => m.id === 1),\n-┊30┊  ┊  },\n-┊31┊  ┊  {\n-┊32┊  ┊    id: 2,\n-┊33┊  ┊    name: 'Bryan Wallace',\n-┊34┊  ┊    picture: 'https://randomuser.me/api/portraits/thumb/men/2.jpg',\n-┊35┊  ┊    lastMessage: messages.find(m => m.id === 2),\n-┊36┊  ┊  },\n-┊37┊  ┊  {\n-┊38┊  ┊    id: 3,\n-┊39┊  ┊    name: 'Avery Stewart',\n-┊40┊  ┊    picture: 'https://randomuser.me/api/portraits/thumb/women/1.jpg',\n-┊41┊  ┊    lastMessage: messages.find(m => m.id === 3),\n-┊42┊  ┊  },\n-┊43┊  ┊  {\n-┊44┊  ┊    id: 4,\n-┊45┊  ┊    name: 'Katie Peterson',\n-┊46┊  ┊    picture: 'https://randomuser.me/api/portraits/thumb/women/2.jpg',\n-┊47┊  ┊    lastMessage: messages.find(m => m.id === 4),\n-┊48┊  ┊  },\n-┊49┊  ┊];🚫↵\n```\n\n[}]: #\n\n> It's recommended to read about React hooks and their basic concept at the [official React docs page](https://reactjs.org/docs/hooks-overview.html).\n\nAt this point we can get rid of `db.ts` file in the client, since we don't use it anymore:\n\n    $ rm src/db.ts\n\nThat's it. Our ChatsListScreen is now connected to a working back-end.\nIn the next step we will upgrade our REST API into a GraphQL API and we will create a basis for a more robust back-end.\n\n-------------\nTODO:\n\nFirst, `tsc` has a `--watch` option so that if the Typescript files changed it will compile them again and spit new Javascript files.\n\nThen we need to rerun the Node server everytime the output Javascript files has changed.\n[nodemon](https://github.com/remy/nodemon) is a tool that tracks file and if the files changed it will re-run our node server.\n\nLet's create a new npm script called \"watch\" and make it run both tools:\n\nTODO: New diff\n\nTODO: https://stackoverflow.com/a/39172660/1426570\n\nTODO: Better watch, also watch and copy schema files (maybe in a later chapter)?\n\nTODO: concurrently - because it works on all environments\n\nTODO: Explain what -r register command does in Node and in Jest\n\nTODO: Talk about the difference between graphql-import and graphql-import-node\n\nTODO: Show debugging\n\n\nIt's a bit annoying that we get the compiled file right next to our Typescript file, so let's move it into a separate folder:\n\nTODO: New diff for the `lib` folder update\n\nTODO: why `useMemo(fn, [true])` instead of `useEffect(fn, [])` ?\n\nTODO: Move to hooks in a separate commit and later change to call the server"
          },
          {
            "manualTitle": "Step 4: Transition to GraphQL",
            "stepRevision": "1eeb3a1eff7815775bc8b005f08fd99935f2ba29",
            "manualView": "**What is GraphQL?**\n\n[GraphQL](https://graphql.org/) is a query language invented by Facebook, and it's used to query data within from a schema.\nIn our case, we will create a schema for the data that our server exposes through its API.\nIt allows clients to define the structure of the data required, and the exact same structure of data will be returned from the server,\ntherefore preventing excessively large amounts of data from being returned.\nUnlike REST, GraphQL APIs are organized in terms of types and fields, not endpoints.\n\nEven if we use GraphQL without a server, it can save us a lot of code and work becuase it can transform data in a very easy way from a schema to a query.\n\nCurrently in our app, if we'd like to get its chats we would send a GET request to `/chats`.\nWith GraphQL it would be done differently with a string that describes the data that we would like to get:\n\n```graphql\nchats {\n  id\n  name\n  picture\n  lastMessage {\n    id\n    content\n    createdAt\n  }\n}\n```\n\n> Above: An illustration of a potential GraphQL query sent to our Whatsapp API\n\n**Why GraphQL and not REST?**\n\nREST has been used for many more years and has proven itself to work well, and it's completely agnostic to the implementation of the back-end.\nHowever, when it comes to data projection and aggregation, it fails to deliver.\n\nWhen using REST, often times you'll find yourself performing multiple requests to execute a single query of data.\nNot only that, you might even end up with additional data that is not necessary.\nEither way, the process would result in slower and heavier response.\n\nWith GraphQL we don’t have that kind of problem. The API is based on a schema built from many entities that we call object types.\nThink of GraphQL as something similar to TypeScript but for API.\nObject types are like interfaces, they describe the shape of an entity.\n\nIn TypeScript you would describe a Chat as:\n\n```\ninterface Chat {\n  id: string;\n  name: string;\n  picture: string;\n  lastMessage: Message;\n}\n\ninterface Message {\n  id: string;\n  content: string;\n  createdAt: number;\n}\n```\n\nGraphQL:\n\n```\ntype Chat {\n  id: String\n  name: String\n  picture: String\n  lastMessage: Message\n}\n\ntype Message {\n  id: String\n  content: String\n  createdAt: Float\n}\n```\n\nLooks pretty similar?\n\nSo this is the definition of the available data, now let's see how we can pick and structure data from it using a query:\n\n```graphql\n# request\nchats {\n  id\n  name\n  picture\n  lastMessage {\n    id\n    content\n    createdAt\n  }\n}\n```\n\nWe think it’s pretty straightforward to understand what do you fetch by just looking at the query above.\n\n![graphql-request](https://user-images.githubusercontent.com/7648874/54133620-5aec8300-4451-11e9-9bda-a459dc48f57c.png)\n\nIf you would execute that query the result might look like this:\n\n```js\n// response\n{\n  chats: [{\n    id: “1”,\n    name: “Ethan Gonzalez”,\n    picture: “https://randomuser.me/api/portraits/thumb/men/1.jpg”,\n    lastMessage: {\n      id: “1”,\n      content: \"You on your way?\",\n      createdAt: 1234567890\n  }]\n}\n```\n\nYou'll get exactly what you asked for with a single request. GraphQL provides a dynamic API while REST doesn't.\n\n**GraphQL schema, in a nutshell**\n\nLike said earlier,  GraphQL APIs are organized in terms of types and fields.\nThat means that our app data should be described with a schema, where each field's gonna have a resolver - the handler that will return the corresponding data.\nThings will be much clearer as we move further.\n\nLet's try to describe our app's data with a GraphQL schema and then dive into it:\n\n```graphql\nscalar Date\n\ntype Message {\n  id: ID!\n  content: String!\n  createdAt: Date!\n}\n\ntype Chat {\n  id: ID!\n  name: String!\n  picture: String\n  lastMessage: Message\n}\n\ntype Query {\n  chats: [Chat!]!\n}\n```\n\nThe schema is self explanatory in terms of what data it's compatible with. Supported built-in scalar types in GraphQL are:\n\n- Int: Signed 32‐bit integer\n- Float: Signed double-precision floating-point value\n- String: UTF‐8 character sequence\n- Boolean: true or false\n- ID (serialized as String): A unique identifier, often used to refetch an object or as the key for a cache.\nWhile serialized as a String, ID signifies that it is not intended to be human‐readable\n\nAny custom scalar can be declared with the `scalar` keyword, and custom types can be declared with the `type` keyword.\nHowever, you should know that some types are reserved by GraphQL itself; `Query` is one of them.\nThe `Query` type will be used as the root for received queries by the clients, which means that we can send queries which start with the `chats` field.\nOther reserved types are:\n\n- `type Query` - reserved for [GraphQL queries](https://graphql.org/learn/queries/#mutations).\n- `type Mutation` - reserved for [GraphQL mutations.](https://graphql.github.io/learn/queries/)\n- `type Subscription` - reserved for [GraphQL subscriptions.](https://www.apollographql.com/docs/react/advanced/subscriptions.html)\n\n> As we're not gonna go through the entire GraphQL API, it's recommended to go through the [official learn section of the GraphQL website](https://graphql.org/learn/), but the information so far will definitely help you kick-start, plus the upcoming implementation.\n\n**Getting started**\n\nWe will be implementing a GraphQL mechanism for the client and for the server.\nWe will start with the server as things will make more sense, and we will be able to test it before we proceed into the client.\nEssentially GraphQL is connected into a HTTP endpoint, usually under `POST /graphql`, and so this is exactly what we're gonna do, connect the endpoint handler.\nLuckily, we don't have to implement that. A team called [Apollo](https://www.apollographql.com/) already did it for us, so we can use their implementation.\nWe will install the required packages:\n\n    $ yarn add apollo-server-express body-parser graphql\n    $ yarn add --dev @types/body-parser @types/graphql\n\n- [`graphql`](https://www.npmjs.com/package/graphql) - The core package of GraphQL that includes the resolvers for basic data-types.\n- [`apollo-server-express`](https://www.npmjs.com/package/apollo-server-express) - Apollo's implementation for the GraphQL Express REST endpoint.\n- [`body-parser`](https://www.npmjs.com/package/body-parser) - Parse incoming request bodies in a middleware before your handlers, available under the req.body property.\n- `@types/…` - TypeScript definitions. Notice that we didn't need to install Apollo's types library. That is because Apollo themselves writes their source code in Typescript so\nwe get a ready Typescript code directly from their library.\n\nWe can now connect Apollo's middleware under the `/graphql` route:\n\n[{]: <helper> (diffStep \"2.1\" files=\"index.ts\" module=\"server\")\n\n#### [Server Step 2.1: Setup Apollo GraphQL](https://github.com/Urigo/WhatsApp-Clone-Server/commit/b988e04)\n\n##### Changed index.ts\n```diff\n@@ -1,10 +1,14 @@\n+┊  ┊ 1┊import { ApolloServer, gql } from 'apollo-server-express'\n+┊  ┊ 2┊import bodyParser from 'body-parser'\n ┊ 1┊ 3┊import cors from 'cors'\n ┊ 2┊ 4┊import express from 'express'\n ┊ 3┊ 5┊import { chats } from './db'\n+┊  ┊ 6┊import schema from './schema'\n ┊ 4┊ 7┊\n ┊ 5┊ 8┊const app = express()\n ┊ 6┊ 9┊\n ┊ 7┊10┊app.use(cors())\n+┊  ┊11┊app.use(bodyParser.json())\n ┊ 8┊12┊\n ┊ 9┊13┊app.get('/_ping', (req, res) => {\n ┊10┊14┊  res.send('pong')\n```\n```diff\n@@ -14,6 +18,13 @@\n ┊14┊18┊  res.json(chats)\n ┊15┊19┊})\n ┊16┊20┊\n+┊  ┊21┊const server = new ApolloServer({ schema })\n+┊  ┊22┊\n+┊  ┊23┊server.applyMiddleware({\n+┊  ┊24┊  app,\n+┊  ┊25┊  path: '/graphql',\n+┊  ┊26┊})\n+┊  ┊27┊\n ┊17┊28┊const port = process.env.PORT || 4000\n ┊18┊29┊\n ┊19┊30┊app.listen(port, () => {\n```\n\n[}]: #\n\nAs you can see, the middleware requires a schema. A schema is composed mainly out of 2 fields:\n\n- `typeDefs` (type definitions) - the schema types we wrote earlier this chapter for chats.\n- `resolvers` - The handlers that will provide the data for each field in `typeDefs`.\n\nWe will start first by defining the types.\nAll we have to do is to copy-paste the contents of the schema that was shown earlier into a new file called `typeDefs.graphql`:\n\n[{]: <helper> (diffStep \"2.2\" files=\"schema/typeDefs.graphql\" module=\"server\")\n\n#### [Server Step 2.2: Create a basic GraphQL schema](https://github.com/Urigo/WhatsApp-Clone-Server/commit/ff4c53d)\n\n##### Added schema&#x2F;typeDefs.graphql\n```diff\n@@ -0,0 +1,18 @@\n+┊  ┊ 1┊scalar Date\n+┊  ┊ 2┊\n+┊  ┊ 3┊type Message {\n+┊  ┊ 4┊  id: ID!\n+┊  ┊ 5┊  content: String!\n+┊  ┊ 6┊  createdAt: Date!\n+┊  ┊ 7┊}\n+┊  ┊ 8┊\n+┊  ┊ 9┊type Chat {\n+┊  ┊10┊  id: ID!\n+┊  ┊11┊  name: String!\n+┊  ┊12┊  picture: String\n+┊  ┊13┊  lastMessage: Message\n+┊  ┊14┊}\n+┊  ┊15┊\n+┊  ┊16┊type Query {\n+┊  ┊17┊  chats: [Chat!]!\n+┊  ┊18┊}\n```\n\n[}]: #\n\nThe `.graphql` file extension is just a more convenient way to work with a GraphQL schema. The exported result should be a simple string that we can use to compose our GraphQL schema. The clear advantage of working with a dedicated file is that we get to have syntax highlight.\n\nNow we will implement the resolvers. Resolvers are presented in a JSON object where each resolver name should match the field name it represents. You can read more about resolvers in [Apollo's official docs for resolvers](https://www.apollographql.com/docs/tutorial/resolvers.html). This is how our resolvers should look like:\n\n[{]: <helper> (diffStep \"2.2\" files=\"schema/resolvers.ts\" module=\"server\")\n\n#### [Server Step 2.2: Create a basic GraphQL schema](https://github.com/Urigo/WhatsApp-Clone-Server/commit/ff4c53d)\n\n##### Added schema&#x2F;resolvers.ts\n```diff\n@@ -0,0 +1,14 @@\n+┊  ┊ 1┊import { GraphQLDateTime } from 'graphql-iso-date'\n+┊  ┊ 2┊import { chats } from '../db'\n+┊  ┊ 3┊\n+┊  ┊ 4┊const resolvers = {\n+┊  ┊ 5┊  Date: GraphQLDateTime,\n+┊  ┊ 6┊\n+┊  ┊ 7┊  Query: {\n+┊  ┊ 8┊    chats() {\n+┊  ┊ 9┊      return chats\n+┊  ┊10┊    },\n+┊  ┊11┊  },\n+┊  ┊12┊}\n+┊  ┊13┊\n+┊  ┊14┊export default resolvers\n```\n\n[}]: #\n\nFor now it's extremely simple, we map the chats query directly into the database collection. Each field in the resolvers object should match the GraphQL type it represents in the schema. Since we don't have any logic now, we should not implement any resolvers for the rest of the types, the data will simply be forwarded as is.\n\nNote that we've implemented a custom scalar named `Date` and we resolved it with an NPM package. Let's install it:\n\n    $ yarn add graphql-iso-date\n    $ yarn add --dev @types/graphql-iso-date\n\nFinal thing that we have to do would be combining the resolvers and the type-defs under a single GraphQL schema.\n\n[{]: <helper> (diffStep \"2.2\" files=\"index.ts\" module=\"server\")\n\n#### [Server Step 2.2: Create a basic GraphQL schema](https://github.com/Urigo/WhatsApp-Clone-Server/commit/ff4c53d)\n\n##### Added schema&#x2F;index.ts\n```diff\n@@ -0,0 +1,7 @@\n+┊ ┊1┊import { importSchema } from 'graphql-import'\n+┊ ┊2┊import { makeExecutableSchema } from 'graphql-tools'\n+┊ ┊3┊import resolvers from './resolvers'\n+┊ ┊4┊\n+┊ ┊5┊const typeDefs = importSchema('schema/typeDefs.graphql')\n+┊ ┊6┊\n+┊ ┊7┊export default makeExecutableSchema({ resolvers, typeDefs })\n```\n\n[}]: #\n\n[`graphql-tools`](https://www.npmjs.com/package/graphql-tools) is a library with a set of utilities that will help us create a schema that will be compatible with Apollo's API:\n\n    $ yarn add graphql-tools graphql-import\n\nThere's one optimization however that we should make in the our DB. Right now, the each chat document has a direct reference to a message via the `lastMessage` field. Practically speaking, this is NOT how the data sits in the DB. The `lastMessage` should only hold the ID for the correlated message, and then in the Node.JS app we should **resolve** it according to our needs. Let's make the appropriate changes in the DB then:\n\n[{]: <helper> (diffStep \"2.3\" files=\"db.ts\" module=\"server\")\n\n#### [Server Step 2.3: Resolve Chat.lastMessage](https://github.com/Urigo/WhatsApp-Clone-Server/commit/908839f)\n\n\n\n[}]: #\n\nAnd a resolver to the `lastMessage` field:\n\n[{]: <helper> (diffStep \"2.3\" files=\"schema/resolvers.ts\" module=\"server\")\n\n#### [Server Step 2.3: Resolve Chat.lastMessage](https://github.com/Urigo/WhatsApp-Clone-Server/commit/908839f)\n\n##### Changed schema&#x2F;resolvers.ts\n```diff\n@@ -1,9 +1,15 @@\n ┊ 1┊ 1┊import { GraphQLDateTime } from 'graphql-iso-date'\n-┊ 2┊  ┊import { chats } from '../db'\n+┊  ┊ 2┊import { chats, messages } from '../db'\n ┊ 3┊ 3┊\n ┊ 4┊ 4┊const resolvers = {\n ┊ 5┊ 5┊  Date: GraphQLDateTime,\n ┊ 6┊ 6┊\n+┊  ┊ 7┊  Chat: {\n+┊  ┊ 8┊    lastMessage(chat: any) {\n+┊  ┊ 9┊      return messages.find(m => m.id === chat.lastMessage)\n+┊  ┊10┊    },\n+┊  ┊11┊  },\n+┊  ┊12┊\n ┊ 7┊13┊  Query: {\n ┊ 8┊14┊    chats() {\n ┊ 9┊15┊      return chats\n```\n\n[}]: #\n\nThe first argument of the resolver is the raw chat data received by the DB, and the returned result should be the mapped value which we would like to return to the client.\n\nAs we get further in this tutorial we should get a better grasp regards resolvers and their API, since we will have to deal with more logic and complexity within our Node.JS app.\n\nAssuming that the server is running, we can already test our GraphQL endpoint. Because it's exposed to us via a REST endpoint, we can use a `$ curl` command to send a request to `GET localhost:4000/graphql` and get a response with all the data. Again, the query that we're gonna use to fetch the chats is:\n\n```graphql\nchats {\n  id\n  name\n  picture\n  lastMessage {\n    id\n    content\n    createdAt\n  }\n}\n```\n\nThe one-liner version of it with a `$ curl` command looks like so:\n\n    curl \\\n      -X POST \\\n      -H \"Content-Type: application/json\" \\\n      --data '{ \"query\": \"{ chats { id name picture lastMessage { id content createdAt } } }\" }' \\\n      localhost:4000/graphql\n\nAs a response we should get the data-mock for our chats stored in the server. Since we have that in place, we can go ahead and delete our implementation for the `GET /chats` route.\n\nAnother way to test and inspect our GraphQL schema would be by using an IDE for the browser called [GraphQL Playground](https://github.com/prisma/graphql-playground).\nApollo-Server ships with it right out of the box and can be used right away by navigating to the `http://localhost:4000/graphql` URL from the browser.\n\n[![](https://i.imgur.com/AE5W6OW.png)](https://graphqlbin.com/v2/6RQ6TM)\n\nSo getting back to the client, all we have to do is to change the fetching URL in the ChatsList component to use our newly implemented GraphQL REST endpoint:\n\n[{]: <helper> (diffStep \"4.1\" module=\"client\")\n\n#### Client Step 4.1: Replace REST call with GraphQL call\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;ChatsList.tsx\n```diff\n@@ -56,12 +56,33 @@\n ┊56┊56┊  font-size: 13px;\n ┊57┊57┊`;\n ┊58┊58┊\n+┊  ┊59┊const getChatsQuery = `\n+┊  ┊60┊  query GetChats {\n+┊  ┊61┊    chats {\n+┊  ┊62┊      id\n+┊  ┊63┊      name\n+┊  ┊64┊      picture\n+┊  ┊65┊      lastMessage {\n+┊  ┊66┊        id\n+┊  ┊67┊        content\n+┊  ┊68┊        createdAt\n+┊  ┊69┊      }\n+┊  ┊70┊    }\n+┊  ┊71┊  }\n+┊  ┊72┊`\n+┊  ┊73┊\n ┊59┊74┊const ChatsList = () => {\n ┊60┊75┊  const [chats, setChats] = useState<any[]>([]);\n ┊61┊76┊\n ┊62┊77┊  useMemo(async () => {\n-┊63┊  ┊    const body = await fetch(`${process.env.REACT_APP_SERVER_URL}/chats`);\n-┊64┊  ┊    const chats = await body.json();\n+┊  ┊78┊    const body = await fetch(`${process.env.REACT_APP_SERVER_URL}/graphql`, {\n+┊  ┊79┊      method: 'POST',\n+┊  ┊80┊      headers: {\n+┊  ┊81┊        'Content-Type': 'application/json',\n+┊  ┊82┊      },\n+┊  ┊83┊      body: JSON.stringify({ query: getChatsQuery }),\n+┊  ┊84┊    });\n+┊  ┊85┊    const { data: { chats } } = await body.json();\n ┊65┊86┊    setChats(chats);\n ┊66┊87┊  }, []);\n```\n\n[}]: #\n\nThe received data should be similar to the previous one.\nNo further changes are required.\n\nIn the next chapter, we will continue working on the UI of our front-end application and we will add a new screen to the flow - the `ChatRoomScreen`.\n\n-------\nTODO: Start with calling the  `graphql` function just on the server to show how it works.\nTODO: Separate step for body parser.\nTODO: Example middlewares in Node\nTODO: Mention the vs code extension\n\nTODO: Introduce the scalar type later on\n\nTODO: Start without Apollo and add it later, in the same file.\nTODO: remove `gql` import becuase it's unused\nTODO: Add visualizations of how GraphQL works\nTODO: import { loadSchema } from 'graphql-toolkit'; and install it\n\nTODO: What DB change is that?\nTODO: Type `lastMessage(chat: any) {`\nTOOD: Change `m` to `currentIteratedMessage`\n\nTODO: Why adding headers? and go through the code\n\nTODO: Talk about working with document node and not with makeExacutableSchema\n```\nזה לא משנה בתכלס, כי ApolloServer בכל מקרה יעשה לזה קימפול\nהנקודה היא שלא צריך לקמפל פעמיים לGraphQLSchema\nפשוט עדיף שאת הקימפול יעשה הרכיב האחרון שהולך להשתמש בtypeDefs\n\nDocumentNode => DocumentNode (cheap, easy, no checks)\nDocumentNode => GraphQLSchema (compile AST, does all checking, might throw exceptions, expensive)\nGraphQLSchema => DocumentNode (printed version, might lost AST features such as directives)\n```"
          },
          {
            "manualTitle": "Step 5: Testing",
            "stepRevision": "74de26b395c828fde0285ed89d1bb6e82676e753",
            "manualView": "Testing is a crucial part when writing an application, especially if we're planning to publish it or make it a commercial thing. Before we hand someone a product, of any kind, we wanna make sure that it passes certain quality checks. We're signed on that product and so it's very important to ensure that it functions properly according our expectations, otherwise wouldn't wanna use it and will look for alternatives.\n\nIn the context of software, we constantly make changes. It's also inevitable to make all features completely independent from one another, so something in the app is likely to break as we upgrade it or maintain it. That's why we need to write a set of tests that can be run on demand, so when we implement a new feature we can simply run the tests and see what feature broke due to most recent changes.\n\nThere are currently 3 main testing frameworks in the NPM ecosystem: [Jasmine](https://jasmine.github.io/), [Mocha](https://mochajs.org/), and [Jest](https://jestjs.io/). Each testing framework has its pros, and cons, and at the end of the day it's a matter of preference. In our application we're gonna use [Jest](https://jestjs.io/) - a testing framework which was developed by Facebook. What's good about Jest is that it can be used to test both client and server logic, because it runs as a Node.JS application, but it also emulates the browser environment whenever we run it, thanks to [JSDOM](https://github.com/jsdom/jsdom).\n\n![jest](https://user-images.githubusercontent.com/7648874/54493900-e2ce0380-490f-11e9-8075-be4a236c7c38.png)\n\nIn this chapter we will learn how to test the React.Components in the client, and Apollo-GraphQL resolvers in the server. There are 3 kinds of tests:\n\n- Unit tests - which are used to test a single component, independently from other components in our system.\n- Integration tests - which are used to test a component in relation to other components in our systems (how well do they co-work with each other).\n- e2e tests (end to end) - which are used to test a complete, from the moment I clicked on a button in the user interface until the data gets back from the server and shown on the screen.\n\nThe efficiency of the tests go from bottom to top (unit -> e2e), but the maintenance and complexity go from bottom to top (e2e -> unit). Accordingly we will need to find a good balance where we don’t spend too much time on writing tests yet have a good indicator for how well our system functions. So we should write a lot of unit tests, a good amount of integration tests and a handful of e2e tests.\n\n![tests-types-table](https://user-images.githubusercontent.com/7648874/54494121-fed2a480-4911-11e9-9370-694ec989729b.png)\n\nWe will start with the client as it’s much easier, because Jest is set and ready to use right out of the box thanks to `create-react-app`.\n\n**Client - Testing React.Components**\n\nThanks to `create-react-app`, we have Jest set and ready to use right out of the box, so we can start writing tests right away. I you'll look at the `src` you'll see a file called `App.test.tsx`, which simply ensures that the component can be rendered without crashing.\n\n```jsx\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nit('renders without crashing', () => {\n  const div = document.createElement('div');\n  ReactDOM.render(<App />, div);\n  ReactDOM.unmountComponentAtNode(div);\n});\n```\n\nThis is not a typical test that you're likely to find in a React project, but it demonstrates very well how Jest can be used to test DOM related issues. If you'll run `$ npm run test` (or `$ yarn test`) in the command line and then press `a`, you should see the following output:\n\n![report](https://user-images.githubusercontent.com/7648874/54341429-eabe4700-4674-11e9-8e76-3aaaf7fec79a.png)\n\nJest will automatically run for every file that ends with a `.test.xxx` extension. This is very convenient because the tests can live right next to the component, and you don't need to lookup for it across the project. This behavior can be modified by configuring Jest in the `package.json` file under the `\"jest\"` field. More information about configuring Jest can be found in the official[ configuration documentation](https://jestjs.io/docs/en/configuration).\n\n> If you get a warning message regards wrapping the component with `act()` - this is a known issue with hooks and should have a proper solution soon. More about this issue and progress regards its fix can be found in this [GitHub thread](https://github.com/facebook/react/issues/14769#issuecomment-470097212).\n\nNow we're gonna write a basic test for the `<ChatsList />` component. In the test, we'll mock a fake response from the server, and examine the contents of rendered HTML. Since the HTML of the component is a dynamic thing and is constantly subject to changes, it would be a good idea to annotate it with `data-testid` attributes so it can be tested regardless of its structure:\n\n[{]: <helper> (diffStep \"5.1\" files=\"ChatsList.tsx\" module=\"client\")\n\n#### Client Step 5.1: Add data-testid attributes\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;ChatsList.tsx\n```diff\n@@ -90,14 +90,14 @@\n ┊ 90┊ 90┊    <Container>\n ┊ 91┊ 91┊      <StyledList>\n ┊ 92┊ 92┊        {chats.map((chat) => (\n-┊ 93┊   ┊          <StyledListItem key={chat!.id} button>\n-┊ 94┊   ┊            <ChatPicture src={chat.picture} alt=\"Profile\"/>\n+┊   ┊ 93┊          <StyledListItem key={chat.id} button>\n+┊   ┊ 94┊            <ChatPicture data-testid=\"picture\" src={chat.picture} alt=\"Profile\"/>\n ┊ 95┊ 95┊            <ChatInfo>\n-┊ 96┊   ┊              <ChatName>{chat.name}</ChatName>\n+┊   ┊ 96┊              <ChatName data-testid=\"name\">{chat.name}</ChatName>\n ┊ 97┊ 97┊              {chat.lastMessage && (\n ┊ 98┊ 98┊                <React.Fragment>\n-┊ 99┊   ┊                  <MessageContent>{chat.lastMessage.content}</MessageContent>\n-┊100┊   ┊                  <MessageDate>{moment(chat.lastMessage.createdAt).format('HH:mm')}</MessageDate>\n+┊   ┊ 99┊                  <MessageContent data-testid=\"content\">{chat.lastMessage.content}</MessageContent>\n+┊   ┊100┊                  <MessageDate data-testid=\"date\">{moment(chat.lastMessage.createdAt).format('HH:mm')}</MessageDate>\n ┊101┊101┊                </React.Fragment>\n ┊102┊102┊              )}\n ┊103┊103┊            </ChatInfo>\n```\n\n[}]: #\n\nNow we can select various HTML elements with a query selector when we test the component. We will install a couple of packages that will assist us in implementing the test:\n\n  $ yarn add jest-fetch-mock jest-dom react-testing-library\n\n- The [`jest-fetch-mock`](https://www.npmjs.com/package/jest-fetch-mock) package can mock responses emitted by the Fetch API.\n- The [`jest-dom`](https://www.npmjs.com/package/jsdom) package will add custom matchers that will help us examine HTML contents of DOM elements.\n- The [`react-testing-library`](https://www.npmjs.com/package/react-testing-library) package contains utility methods that will help us test React.Components with Jest.\n\nNext, we will create a file under the `src` folder called `setupTests.ts`. This file is loaded configured automatically by `create-react-app` and loaded by Jest, and we can use it to set up our testing environment according to our needs (like said earlier, Jest can be configured, so this file path can be changed). We will use that file to define a fake Fetch API using the `jest-fetch-mock` library:\n\n[{]: <helper> (diffStep \"5.2\" files=\"src/setupTests.ts\" module=\"client\")\n\n#### Client Step 5.2: Setup tests\n\n##### Added src&#x2F;setupTests.ts\n```diff\n@@ -0,0 +1,7 @@\n+┊ ┊1┊import 'jest-dom/extend-expect'\n+┊ ┊2┊import { GlobalWithFetchMock } from 'jest-fetch-mock'\n+┊ ┊3┊import { act } from 'react-testing-library'\n+┊ ┊4┊\n+┊ ┊5┊const customGlobal: GlobalWithFetchMock = global as GlobalWithFetchMock\n+┊ ┊6┊customGlobal.fetch = require('jest-fetch-mock')\n+┊ ┊7┊customGlobal.fetchMock = customGlobal.fetch\n```\n\n[}]: #\n\nWe will create another file called `ChatsList.test.tsx`, right next to the `<ChatsList />` component under the `ChatsListScreen` directory, and inside we will implement our test. The test should follow these steps:\n\n- Mock the response to contain a fake chat, so we won't need to make an actual call to our GraphQL API.\n- We will create a new instance of `<ChatsList />` and render it in a container element.\n- We will wait for changes in the DOM caused by `setState()`.\n- We will test the contents of the container.\n\nAnd this is how the implementation should look like:\n\n[{]: <helper> (diffStep \"5.3\" files=\"src/components/ChatsListScreen/ChatsList.test.tsx\" module=\"client\")\n\n#### Client Step 5.3: Test ChatsList\n\n##### Added src&#x2F;components&#x2F;ChatsListScreen&#x2F;ChatsList.test.tsx\n```diff\n@@ -0,0 +1,56 @@\n+┊  ┊ 1┊import React from 'react';\n+┊  ┊ 2┊import ReactDOM from 'react-dom';\n+┊  ┊ 3┊import { cleanup, render, waitForDomChange } from 'react-testing-library';\n+┊  ┊ 4┊import ChatsList from './ChatsList';\n+┊  ┊ 5┊\n+┊  ┊ 6┊describe('ChatsList', () => {\n+┊  ┊ 7┊  afterEach(cleanup);\n+┊  ┊ 8┊\n+┊  ┊ 9┊  it('renders fetched chats data', async () => {\n+┊  ┊10┊    fetch.mockResponseOnce(JSON.stringify({\n+┊  ┊11┊      data: {\n+┊  ┊12┊        chats: [\n+┊  ┊13┊          {\n+┊  ┊14┊            id: 1,\n+┊  ┊15┊            name: 'Foo Bar',\n+┊  ┊16┊            picture: 'https://localhost:4000/picture.jpg',\n+┊  ┊17┊            lastMessage: {\n+┊  ┊18┊              id: 1,\n+┊  ┊19┊              content: 'Hello',\n+┊  ┊20┊              createdAt: new Date(0),\n+┊  ┊21┊            },\n+┊  ┊22┊          },\n+┊  ┊23┊        ],\n+┊  ┊24┊      },\n+┊  ┊25┊    }));\n+┊  ┊26┊\n+┊  ┊27┊    {\n+┊  ┊28┊      const { container, getByTestId } = render(<ChatsList />);\n+┊  ┊29┊\n+┊  ┊30┊      await waitForDomChange({ container });\n+┊  ┊31┊\n+┊  ┊32┊      expect(getByTestId('name')).toHaveTextContent('Foo Bar');\n+┊  ┊33┊      expect(getByTestId('picture')).toHaveAttribute('src', 'https://localhost:4000/picture.jpg');\n+┊  ┊34┊      expect(getByTestId('content')).toHaveTextContent('Hello');\n+┊  ┊35┊      expect(getByTestId('date')).toHaveTextContent('01:00');\n+┊  ┊36┊    }\n+┊  ┊37┊  });\n+┊  ┊38┊});\n+┊  ┊39┊\n+┊  ┊40┊// IMPORTANT\n+┊  ┊41┊// Below is a temporary hack to suppress warnings generated by a React bug.\n+┊  ┊42┊// Source: https://github.com/testing-library/react-testing-library/issues/281\n+┊  ┊43┊// @todo: remove this when React 16.9.0 is stable and we upgrade.\n+┊  ┊44┊const originalError = console.error;\n+┊  ┊45┊beforeAll(() => {\n+┊  ┊46┊  console.error = (...args: string[]) => {\n+┊  ┊47┊    if (/Warning.*not wrapped in act/.test(args[0])) {\n+┊  ┊48┊      return;\n+┊  ┊49┊    }\n+┊  ┊50┊    originalError.call(console, ...args);\n+┊  ┊51┊  };\n+┊  ┊52┊});\n+┊  ┊53┊\n+┊  ┊54┊afterAll(() => {\n+┊  ┊55┊  console.error = originalError;\n+┊  ┊56┊});\n```\n\n[}]: #\n\n> Jest API is vast but pretty intuitive for the most part. It mostly consists of test descriptors and matchers. [Here's a full list of all matchers which are built into Jest's API](https://jestjs.io/docs/en/expect). Always make sure to work against it when writing tests, for optimal results.\n\nWe will now move on to testing the server where we will learn how to setup Jest manually and test it against a GraphQL API.\n\n**Server - Testing GraphQL resolvers**\n\nTo set-up Jest, we will run the following in the command line:\n\n    $ yarn add --dev jest @types/jest ts-jest\n\n\nThis will basically install Jest and make it useable with TypeScript.\nIn addition, we will need to specify the file pattern that we would like to transform with [`ts-jest`](https://www.npmjs.com/package/ts-jest), by adding the following section to `package.json`:\n\n```\n{\n  \"jest\": {\n    \"transform\": {\n      \"^.+\\\\.(js|jsx|ts|tsx)$\": \"<rootDir>/node_modules/ts-jest\"\n    }\n  }\n}\n```\n\nWe will also add a `\"test\"` script in the `package.json` file,\nso we can run the tests with `$ yarn test`:\n\n```\n{\n  \"scripts\": {\n    \"test\": \"jest\"\n  }\n}\n```\n\nThis is how our `package.json` should look like at this point:\n\n[{]: <helper> (diffStep \"3.1\" files=\"package.json\" module=\"server\")\n\n#### [Server Step 3.1: Install and configure Jest](https://github.com/Urigo/WhatsApp-Clone-Server/commit/2712fc5)\n\n##### Changed package.json\n```diff\n@@ -7,7 +7,8 @@\n ┊ 7┊ 7┊  },\n ┊ 8┊ 8┊  \"private\": true,\n ┊ 9┊ 9┊  \"scripts\": {\n-┊10┊  ┊    \"start\": \"ts-node index.ts\"\n+┊  ┊10┊    \"start\": \"ts-node index.ts\",\n+┊  ┊11┊    \"test\": \"jest\"\n ┊11┊12┊  },\n ┊12┊13┊  \"devDependencies\": {\n ┊13┊14┊    \"@types/body-parser\": \"1.17.0\",\n```\n```diff\n@@ -15,7 +16,10 @@\n ┊15┊16┊    \"@types/express\": \"4.16.1\",\n ┊16┊17┊    \"@types/graphql\": \"14.0.7\",\n ┊17┊18┊    \"@types/graphql-iso-date\": \"3.3.1\",\n+┊  ┊19┊    \"@types/jest\": \"24.0.11\",\n ┊18┊20┊    \"@types/node\": \"11.11.0\",\n+┊  ┊21┊    \"ts-jest\": \"24.0.0\",\n+┊  ┊22┊    \"jest\": \"24.5.0\",\n ┊19┊23┊    \"ts-node\": \"8.0.3\",\n ┊20┊24┊    \"typescript\": \"3.3.3333\"\n ┊21┊25┊  },\n```\n```diff\n@@ -28,5 +32,10 @@\n ┊28┊32┊    \"graphql-import\": \"0.7.1\",\n ┊29┊33┊    \"graphql-iso-date\": \"3.6.1\",\n ┊30┊34┊    \"graphql-tools\": \"4.0.4\"\n+┊  ┊35┊  },\n+┊  ┊36┊  \"jest\": {\n+┊  ┊37┊    \"transform\": {\n+┊  ┊38┊      \"^.+\\\\.(js|jsx|ts|tsx)$\": \"<rootDir>/node_modules/ts-jest\"\n+┊  ┊39┊    }\n ┊31┊40┊  }\n ┊32┊41┊}\n```\n\n[}]: #\n\nNow we're gonna test the `chats` query in our GraphQL schema. To do so, we will setup an Apollo Client and send a query request to our back-end, and then we will match the received response with a pre-defined snapshot. Luckily, we don't have to set an actual client, since the tests and the implementation of the back-end live right next to each other, thus, we will install a package which will help us achieving so:\n\n    $ yarn add --dev apollo-server-testing\n\nWe will define the test suite under the `tests/queries` folder in a file called `getChats.test.ts`:\n\n[{]: <helper> (diffStep \"3.2\" files=\"tests/queries/getChats.test.ts\" module=\"server\")\n\n#### [Server Step 3.2: Test Query.chats](https://github.com/Urigo/WhatsApp-Clone-Server/commit/5a5edc4)\n\n##### Added tests&#x2F;queries&#x2F;getChats.test.ts\n```diff\n@@ -0,0 +1,32 @@\n+┊  ┊ 1┊import { createTestClient } from 'apollo-server-testing'\n+┊  ┊ 2┊import { ApolloServer, gql } from 'apollo-server-express'\n+┊  ┊ 3┊import schema from '../../schema'\n+┊  ┊ 4┊\n+┊  ┊ 5┊describe('Query.chats', () => {\n+┊  ┊ 6┊  it('should fetch all chats', async () => {\n+┊  ┊ 7┊    const server = new ApolloServer({ schema })\n+┊  ┊ 8┊\n+┊  ┊ 9┊    const { query } = createTestClient(server)\n+┊  ┊10┊\n+┊  ┊11┊    const res = await query({\n+┊  ┊12┊      query: gql `\n+┊  ┊13┊        query GetChats {\n+┊  ┊14┊          chats {\n+┊  ┊15┊            id\n+┊  ┊16┊            name\n+┊  ┊17┊            picture\n+┊  ┊18┊            lastMessage {\n+┊  ┊19┊              id\n+┊  ┊20┊              content\n+┊  ┊21┊              createdAt\n+┊  ┊22┊            }\n+┊  ┊23┊          }\n+┊  ┊24┊        }\n+┊  ┊25┊      `,\n+┊  ┊26┊    })\n+┊  ┊27┊\n+┊  ┊28┊    expect(res.data).toBeDefined()\n+┊  ┊29┊    expect(res.errors).toBeUndefined()\n+┊  ┊30┊    expect(res.data).toMatchSnapshot()\n+┊  ┊31┊  })\n+┊  ┊32┊})\n```\n\n[}]: #\n\nIn the test function, we create a new instance of the Apollo-GraphQL server using our schema, and we query some data against it thanks to the fake client created by [`apollo-server-testing`](https://www.npmjs.com/package/apollo-server-testing).\n\nThe `.toMatchSnapshot()` matcher will call the `toString()` method on the examined object and will test it against a predefined snapshot.\nThe snapshot will automatically be created once we run the test for the first time and will be stored under the `__snapshot__` directory.\nThis means that the first test run will always pass. This is useful because you can later on observe and adjust manually the snapshot manually without having to write it from scratch.\n\nSo let's do our first test run for the server:\n\n    $ yarn test\n\nThe expected result should be a projection of the data stored in the `db.ts` file.\n\n[{]: <helper> (diffStep \"3.2\" files=\"tests/queries/__snapshots__\" module=\"server\")\n\n#### [Server Step 3.2: Test Query.chats](https://github.com/Urigo/WhatsApp-Clone-Server/commit/5a5edc4)\n\n##### Added tests&#x2F;queries&#x2F;\\__snapshots__&#x2F;getChats.test.ts.snap\n```diff\n@@ -0,0 +1,48 @@\n+┊  ┊ 1┊// Jest Snapshot v1, https://goo.gl/fbAQLP\n+┊  ┊ 2┊\n+┊  ┊ 3┊exports[`Query.chats should fetch all chats 1`] = `\n+┊  ┊ 4┊Object {\n+┊  ┊ 5┊  \"chats\": Array [\n+┊  ┊ 6┊    Object {\n+┊  ┊ 7┊      \"id\": \"1\",\n+┊  ┊ 8┊      \"lastMessage\": Object {\n+┊  ┊ 9┊        \"content\": \"You on your way?\",\n+┊  ┊10┊        \"createdAt\": \"2018-12-30T23:20:00.000Z\",\n+┊  ┊11┊        \"id\": \"1\",\n+┊  ┊12┊      },\n+┊  ┊13┊      \"name\": \"Ethan Gonzalez\",\n+┊  ┊14┊      \"picture\": \"https://randomuser.me/api/portraits/thumb/men/1.jpg\",\n+┊  ┊15┊    },\n+┊  ┊16┊    Object {\n+┊  ┊17┊      \"id\": \"2\",\n+┊  ┊18┊      \"lastMessage\": Object {\n+┊  ┊19┊        \"content\": \"Hey, it's me\",\n+┊  ┊20┊        \"createdAt\": \"2018-12-30T06:40:00.000Z\",\n+┊  ┊21┊        \"id\": \"2\",\n+┊  ┊22┊      },\n+┊  ┊23┊      \"name\": \"Bryan Wallace\",\n+┊  ┊24┊      \"picture\": \"https://randomuser.me/api/portraits/thumb/men/2.jpg\",\n+┊  ┊25┊    },\n+┊  ┊26┊    Object {\n+┊  ┊27┊      \"id\": \"3\",\n+┊  ┊28┊      \"lastMessage\": Object {\n+┊  ┊29┊        \"content\": \"I should buy a boat\",\n+┊  ┊30┊        \"createdAt\": \"2018-12-15T00:00:00.000Z\",\n+┊  ┊31┊        \"id\": \"3\",\n+┊  ┊32┊      },\n+┊  ┊33┊      \"name\": \"Avery Stewart\",\n+┊  ┊34┊      \"picture\": \"https://randomuser.me/api/portraits/thumb/women/1.jpg\",\n+┊  ┊35┊    },\n+┊  ┊36┊    Object {\n+┊  ┊37┊      \"id\": \"4\",\n+┊  ┊38┊      \"lastMessage\": Object {\n+┊  ┊39┊        \"content\": \"This is wicked good ice cream.\",\n+┊  ┊40┊        \"createdAt\": \"2018-05-12T08:00:00.000Z\",\n+┊  ┊41┊        \"id\": \"4\",\n+┊  ┊42┊      },\n+┊  ┊43┊      \"name\": \"Katie Peterson\",\n+┊  ┊44┊      \"picture\": \"https://randomuser.me/api/portraits/thumb/women/2.jpg\",\n+┊  ┊45┊    },\n+┊  ┊46┊  ],\n+┊  ┊47┊}\n+┊  ┊48┊`;\n```\n\n[}]: #\n\nAlways be sure to observe the snapshot before moving on! The received result isn't necessarily what you'd expect. Also it's not a good practice to store production data in the snapshot because it's subject to changes. Normally we would set up another instance of the DB for testing purposes, but since our DB is a mock and doesn't represent real data, there's no need to at this stage.\n\nNow that we have the required knowledge regards testing and Jest's API, we will implement tests throughout the tutorial as a trivial thing. We will not go through each and every new matcher that we introduce, as it is self explanatory and there's too much of them. Be sure to work against [this full list of matchers](https://jestjs.io/docs/en/expect) when working with Jest.\n\nIn the next chapter we will continue expanding our application by adding a `<ChatRoomScreen />`.\n\n----------\nTODO: Check what changed on testing in create-react-app 3.0 https://facebook.github.io/create-react-app/docs/running-tests\n\nTODO: I think ts-jest could be configured in a simpler way, but need to check\n\t{ preset: 'ts-jest' }\n\nTODO: I don’t like using jest’s toMatchSnapshot() to compare operation’s result that comes from the real GraphQL Schema (with resolvers).\nIt might change quite a lot and break tests. That data might be huge and hard to be validated by looking at it. Maybe checking a structure is a better approach?\n\nTODO: Why ts-jest?\n\nTODO: Change into tortilla diff:\n\nTODO: Change into Tortilla diif:\n\nTODO: Test with UTC timezone so it would work on all computers\n\nTODO: const server = new ApolloServer({ typeDefs }); // easier, no need to compile the schema before"
          },
          {
            "manualTitle": "Step 6: Creating an app router and implementing a chat room",
            "stepRevision": "b1853f0258e57eb800345f3985d55b2d29e641bd",
            "manualView": "In this chapter we will learn how to build a chat room screen.\nIn order to navigate between different screens, we will setup a router.\n\nSince we're gonna have to screens in our app now - `ChatsListScreen` and `ChatRoomScreen`, we will need a router that will be able to alternate between them.\nWe will be using the [`react-router-dom`](https://www.npmjs.com/package/react-router-dom) package to manage the routes of the application:\n\n    $ yarn add react-router-dom\n\nAnd we will implement a router directly in the `<App />` component:\n\n[{]: <helper> (diffStep 6.1 files=\"App\" module=\"client\")\n\n#### Client Step 6.1: Add router\n\n##### Changed src&#x2F;App.tsx\n```diff\n@@ -1,10 +1,20 @@\n ┊ 1┊ 1┊import React from 'react';\n+┊  ┊ 2┊import { BrowserRouter, Route, Redirect, Switch } from 'react-router-dom';\n+┊  ┊ 3┊import ChatRoomScreen from './components/ChatRoomScreen';\n ┊ 2┊ 4┊import ChatsListScreen from './components/ChatsListScreen';\n ┊ 3┊ 5┊\n ┊ 4┊ 6┊const App: React.FC = () => (\n-┊ 5┊  ┊  <div>\n-┊ 6┊  ┊    <ChatsListScreen/>\n-┊ 7┊  ┊  </div>\n+┊  ┊ 7┊  <BrowserRouter>\n+┊  ┊ 8┊    <Switch>\n+┊  ┊ 9┊      <Route exact path=\"/chats\" component={ChatsListScreen} />\n+┊  ┊10┊      <Route exact path=\"/chats/:chatId\" component={ChatRoomScreen} />\n+┊  ┊11┊    </Switch>\n+┊  ┊12┊    <Route exact path=\"/\" render={redirectToChats} />\n+┊  ┊13┊  </BrowserRouter>\n+┊  ┊14┊);\n+┊  ┊15┊\n+┊  ┊16┊const redirectToChats = () => (\n+┊  ┊17┊  <Redirect to=\"/chats\" />\n ┊ 8┊18┊);\n ┊ 9┊19┊\n ┊10┊20┊export default App;\n```\n\n[}]: #\n\nThe purpose of a router is to make route managing easy and declarative.\nIt will take care of managing the history within our app and parameterizing certain screens according to our need.\nEssentially it's a wrap around the `window.history` object which is also compatible with React.\nI recommend you to go through the [official MDN docs](https://developer.mozilla.org/en-US/docs/Web/API/History) if you're not yet familiar with the concept.\n\nThe `<Route />` component represents a path for a route in our application. Using the colon syntax (`:chatId`) we basically tell the router that the `/chat` route should be followed by a string whose value can later on be addressed via a parameter called `chatId` when navigating to the route. So here's a sum-up of the routes manifest:\n\n\n\n*   `/chats` - will navigate to the `ChatsListScreen`.\n*   `/chat/:chatId` - e.g. `/chat/1`, will navigate to the `ChatRoomScreen` and will parameterize it to show data which is related to chat ID 1.\n*   Any other route will fallback to the `/chats` route which will redirect us to the `ChatsListScreen`.\n\nNow we will implement the `ChatRoomScreen` so the router can function properly.\nFor now we will make it a plain screen which simply prints out the information of the chat that was clicked so we can have a complete flow,\nand then we will take care of the rest.\n\nTo do so, we will first implement the `chat` query in our backend.\nThis would be a parameterized query that will provide us with a specific chat according to the received ID,\nand it will be used by the new screen as soon as it is initialized.\nFirst we would update the `Chat` type to contain a `messages` field:\n\n[{]: <helper> (diffStep 4.1 files=\"typeDefs.graphql\" module=\"server\")\n\n#### [Server Step 4.1: Add messages field to Chat type](https://github.com/Urigo/WhatsApp-Clone-Server/commit/9f01cf6)\n\n##### Changed schema&#x2F;typeDefs.graphql\n```diff\n@@ -11,6 +11,7 @@\n ┊11┊11┊  name: String!\n ┊12┊12┊  picture: String\n ┊13┊13┊  lastMessage: Message\n+┊  ┊14┊  messages: [Message!]!\n ┊14┊15┊}\n ┊15┊16┊\n ┊16┊17┊type Query {\n```\n\n[}]: #\n\nThen we will create the appropriate resolver:\n\n[{]: <helper> (diffStep 4.1 files=\"resolvers.ts\" module=\"server\")\n\n#### [Server Step 4.1: Add messages field to Chat type](https://github.com/Urigo/WhatsApp-Clone-Server/commit/9f01cf6)\n\n##### Changed schema&#x2F;resolvers.ts\n```diff\n@@ -5,6 +5,10 @@\n ┊ 5┊ 5┊  Date: GraphQLDateTime,\n ┊ 6┊ 6┊\n ┊ 7┊ 7┊  Chat: {\n+┊  ┊ 8┊    messages(chat: any) {\n+┊  ┊ 9┊      return messages.filter(m => chat.messages.includes(m.id))\n+┊  ┊10┊    },\n+┊  ┊11┊\n ┊ 8┊12┊    lastMessage(chat: any) {\n ┊ 9┊13┊      return messages.find(m => m.id === chat.lastMessage)\n ┊10┊14┊    },\n```\n\n[}]: #\n\nAnd then we will update our DB mock to be aligned with these changes:\n\n[{]: <helper> (diffStep 4.1 files=\"db\" module=\"server\")\n\n#### [Server Step 4.1: Add messages field to Chat type](https://github.com/Urigo/WhatsApp-Clone-Server/commit/9f01cf6)\n\n##### Changed db.ts\n```diff\n@@ -27,23 +27,27 @@\n ┊27┊27┊    name: 'Ethan Gonzalez',\n ┊28┊28┊    picture: 'https://randomuser.me/api/portraits/thumb/men/1.jpg',\n ┊29┊29┊    lastMessage: '1',\n+┊  ┊30┊    messages: ['1'],\n ┊30┊31┊  },\n ┊31┊32┊  {\n ┊32┊33┊    id: '2',\n ┊33┊34┊    name: 'Bryan Wallace',\n ┊34┊35┊    picture: 'https://randomuser.me/api/portraits/thumb/men/2.jpg',\n ┊35┊36┊    lastMessage: '2',\n+┊  ┊37┊    messages: ['2'],\n ┊36┊38┊  },\n ┊37┊39┊  {\n ┊38┊40┊    id: '3',\n ┊39┊41┊    name: 'Avery Stewart',\n ┊40┊42┊    picture: 'https://randomuser.me/api/portraits/thumb/women/1.jpg',\n ┊41┊43┊    lastMessage: '3',\n+┊  ┊44┊    messages: ['3'],\n ┊42┊45┊  },\n ┊43┊46┊  {\n ┊44┊47┊    id: '4',\n ┊45┊48┊    name: 'Katie Peterson',\n ┊46┊49┊    picture: 'https://randomuser.me/api/portraits/thumb/women/2.jpg',\n ┊47┊50┊    lastMessage: '4',\n+┊  ┊51┊    messages: ['4'],\n ┊48┊52┊  },\n ┊49┊53┊]\n```\n\n[}]: #\n\nThis means that when we resolve `Chat.lastMessage`, we should get it directly from the `Chat.messages` field:\n\n[{]: <helper> (diffStep 4.2 module=\"server\")\n\n#### [Server Step 4.2: Resolve last message based on messages array](https://github.com/Urigo/WhatsApp-Clone-Server/commit/eacae7b)\n\n##### Changed db.ts\n```diff\n@@ -26,28 +26,24 @@\n ┊26┊26┊    id: '1',\n ┊27┊27┊    name: 'Ethan Gonzalez',\n ┊28┊28┊    picture: 'https://randomuser.me/api/portraits/thumb/men/1.jpg',\n-┊29┊  ┊    lastMessage: '1',\n ┊30┊29┊    messages: ['1'],\n ┊31┊30┊  },\n ┊32┊31┊  {\n ┊33┊32┊    id: '2',\n ┊34┊33┊    name: 'Bryan Wallace',\n ┊35┊34┊    picture: 'https://randomuser.me/api/portraits/thumb/men/2.jpg',\n-┊36┊  ┊    lastMessage: '2',\n ┊37┊35┊    messages: ['2'],\n ┊38┊36┊  },\n ┊39┊37┊  {\n ┊40┊38┊    id: '3',\n ┊41┊39┊    name: 'Avery Stewart',\n ┊42┊40┊    picture: 'https://randomuser.me/api/portraits/thumb/women/1.jpg',\n-┊43┊  ┊    lastMessage: '3',\n ┊44┊41┊    messages: ['3'],\n ┊45┊42┊  },\n ┊46┊43┊  {\n ┊47┊44┊    id: '4',\n ┊48┊45┊    name: 'Katie Peterson',\n ┊49┊46┊    picture: 'https://randomuser.me/api/portraits/thumb/women/2.jpg',\n-┊50┊  ┊    lastMessage: '4',\n ┊51┊47┊    messages: ['4'],\n ┊52┊48┊  },\n ┊53┊49┊]\n```\n\n##### Changed schema&#x2F;resolvers.ts\n```diff\n@@ -10,7 +10,9 @@\n ┊10┊10┊    },\n ┊11┊11┊\n ┊12┊12┊    lastMessage(chat: any) {\n-┊13┊  ┊      return messages.find(m => m.id === chat.lastMessage)\n+┊  ┊13┊      const lastMessage = chat.messages[chat.messages.length - 1]\n+┊  ┊14┊\n+┊  ┊15┊      return messages.find(m => m.id === lastMessage)\n ┊14┊16┊    },\n ┊15┊17┊  },\n```\n\n[}]: #\n\nNow that we have an updated schema which is relevant to the new screen that we would like to add, we will declare a new query called `chat`:\n\n[{]: <helper> (diffStep 4.3 files=\"schema/typeDefs\" module=\"server\")\n\n#### [Server Step 4.3: Add chat field to Query type](https://github.com/Urigo/WhatsApp-Clone-Server/commit/93160df)\n\n##### Changed schema&#x2F;typeDefs.graphql\n```diff\n@@ -16,4 +16,5 @@\n ┊16┊16┊\n ┊17┊17┊type Query {\n ┊18┊18┊  chats: [Chat!]!\n+┊  ┊19┊  chat(chatId: ID!): Chat\n ┊19┊20┊}\n```\n\n[}]: #\n\nNote that unlike the `chats` query, this time we have a parameter. The parameters are provided to the resolver function as the second parameter as a JSON. Using the provided parameter - the chat ID, we will find and return the relevant chat from the DB:\n\n[{]: <helper> (diffStep 4.3 files=\"schema/resolvers\" module=\"server\")\n\n#### [Server Step 4.3: Add chat field to Query type](https://github.com/Urigo/WhatsApp-Clone-Server/commit/93160df)\n\n##### Changed schema&#x2F;resolvers.ts\n```diff\n@@ -20,6 +20,10 @@\n ┊20┊20┊    chats() {\n ┊21┊21┊      return chats\n ┊22┊22┊    },\n+┊  ┊23┊\n+┊  ┊24┊    chat(root: any, { chatId }: any) {\n+┊  ┊25┊      return chats.find(c => c.id === chatId)\n+┊  ┊26┊    },\n ┊23┊27┊  },\n ┊24┊28┊}\n ┊25┊29┊\n```\n\n[}]: #\n\n> More about the resolver signature can be read in [Apollo-GraphQL's official docs page](https://www.apollographql.com/docs/apollo-server/essentials/data.html#type-signature).\n\nNow we will add a test suite:\n\n[{]: <helper> (diffStep 4.3 files=\"tests/queries/getChat.test\" module=\"server\")\n\n#### [Server Step 4.3: Add chat field to Query type](https://github.com/Urigo/WhatsApp-Clone-Server/commit/93160df)\n\n##### Added tests&#x2F;queries&#x2F;getChat.test.ts\n```diff\n@@ -0,0 +1,33 @@\n+┊  ┊ 1┊import { createTestClient } from 'apollo-server-testing'\n+┊  ┊ 2┊import { ApolloServer, gql } from 'apollo-server-express'\n+┊  ┊ 3┊import schema from '../../schema'\n+┊  ┊ 4┊\n+┊  ┊ 5┊describe('Query.chat', () => {\n+┊  ┊ 6┊  it('should fetch specified chat', async () => {\n+┊  ┊ 7┊    const server = new ApolloServer({ schema })\n+┊  ┊ 8┊\n+┊  ┊ 9┊    const { query } = createTestClient(server)\n+┊  ┊10┊\n+┊  ┊11┊    const res = await query({\n+┊  ┊12┊      variables: { chatId: '1' },\n+┊  ┊13┊      query: gql `\n+┊  ┊14┊        query GetChat($chatId: ID!) {\n+┊  ┊15┊          chat(chatId: $chatId) {\n+┊  ┊16┊            id\n+┊  ┊17┊            name\n+┊  ┊18┊            picture\n+┊  ┊19┊            lastMessage {\n+┊  ┊20┊              id\n+┊  ┊21┊              content\n+┊  ┊22┊              createdAt\n+┊  ┊23┊            }\n+┊  ┊24┊          }\n+┊  ┊25┊        }\n+┊  ┊26┊      `,\n+┊  ┊27┊    })\n+┊  ┊28┊\n+┊  ┊29┊    expect(res.data).toBeDefined()\n+┊  ┊30┊    expect(res.errors).toBeUndefined()\n+┊  ┊31┊    expect(res.data).toMatchSnapshot()\n+┊  ┊32┊  })\n+┊  ┊33┊})\n```\n\n[}]: #\n\nWe can observe the snapshot created by Jest to get a better understanding of how the response should look like:\n\n[{]: <helper> (diffStep 4.3 files=\"__snapshot__\" module=\"server\")\n\n#### [Server Step 4.3: Add chat field to Query type](https://github.com/Urigo/WhatsApp-Clone-Server/commit/93160df)\n\n\n\n[}]: #\n\nIf you experience any TypeScript related issues with the following error:\n\n```\nObject literal may only specify known properties, and 'variables' does not exist in type 'Query'.\n```\n\nAdd the following declaration file to your project:\n\n[{]: <helper> (diffStep 4.3 files=\"types\" module=\"server\")\n\n#### [Server Step 4.3: Add chat field to Query type](https://github.com/Urigo/WhatsApp-Clone-Server/commit/93160df)\n\n##### Added types&#x2F;apollo-server-testing.d.ts\n```diff\n@@ -0,0 +1,27 @@\n+┊  ┊ 1┊declare module 'apollo-server-testing' {\n+┊  ┊ 2┊  import { ApolloServerBase } from 'apollo-server-core';\n+┊  ┊ 3┊  import { print, DocumentNode } from 'graphql';\n+┊  ┊ 4┊  import { GraphQLResponse } from 'graphql-extensions';\n+┊  ┊ 5┊\n+┊  ┊ 6┊  type StringOrAst = string | DocumentNode;\n+┊  ┊ 7┊\n+┊  ┊ 8┊  // A query must not come with a mutation (and vice versa).\n+┊  ┊ 9┊  type Query<TVariables> = {\n+┊  ┊10┊    query: StringOrAst;\n+┊  ┊11┊    mutation?: undefined;\n+┊  ┊12┊    variables?: TVariables;\n+┊  ┊13┊  };\n+┊  ┊14┊\n+┊  ┊15┊  type Mutation<TVariables> = {\n+┊  ┊16┊    mutation: StringOrAst;\n+┊  ┊17┊    query?: undefined;\n+┊  ┊18┊    variables?: TVariables;\n+┊  ┊19┊  };\n+┊  ┊20┊\n+┊  ┊21┊  export const createTestClient: <TVariables>(\n+┊  ┊22┊    server: ApolloServerBase,\n+┊  ┊23┊  ) => {\n+┊  ┊24┊    query: (query: Query<TVariables>) => Promise<GraphQLResponse>;\n+┊  ┊25┊    mutate: (mutation: Mutation<TVariables>) => Promise<GraphQLResponse>;\n+┊  ┊26┊  };\n+┊  ┊27┊}\n```\n\n[}]: #\n\nThis is a [known issue](https://github.com/apollographql/apollo-server/issues/2172) in the `apollo-server-testing` package and has a pending [fix PR](https://github.com/apollographql/apollo-server/pull/2307).\nNow getting back to the client, let's implement a basic version of the `ChatRoomScreen` where we will fetch the new query and print it to the screen:\n\n[{]: <helper> (diffStep 6.2 module=\"client\")\n\n#### Client Step 6.2: Add basic ChatRoomScreen\n\n##### Changed src&#x2F;App.tsx\n```diff\n@@ -1,5 +1,5 @@\n ┊1┊1┊import React from 'react';\n-┊2┊ ┊import { BrowserRouter, Route, Redirect, Switch } from 'react-router-dom';\n+┊ ┊2┊import { BrowserRouter, Route, Redirect, Switch, RouteComponentProps } from 'react-router-dom';\n ┊3┊3┊import ChatRoomScreen from './components/ChatRoomScreen';\n ┊4┊4┊import ChatsListScreen from './components/ChatsListScreen';\n ┊5┊5┊\n```\n```diff\n@@ -7,7 +7,12 @@\n ┊ 7┊ 7┊  <BrowserRouter>\n ┊ 8┊ 8┊    <Switch>\n ┊ 9┊ 9┊      <Route exact path=\"/chats\" component={ChatsListScreen} />\n-┊10┊  ┊      <Route exact path=\"/chats/:chatId\" component={ChatRoomScreen} />\n+┊  ┊10┊\n+┊  ┊11┊      <Route exact path=\"/chats/:chatId\" component={\n+┊  ┊12┊        ({ match }: RouteComponentProps<{ chatId: string }>) =>\n+┊  ┊13┊        (<ChatRoomScreen chatId={match.params.chatId} />)\n+┊  ┊14┊      } />\n+┊  ┊15┊\n ┊11┊16┊    </Switch>\n ┊12┊17┊    <Route exact path=\"/\" render={redirectToChats} />\n ┊13┊18┊  </BrowserRouter>\n```\n```diff\n@@ -17,4 +22,4 @@\n ┊17┊22┊  <Redirect to=\"/chats\" />\n ┊18┊23┊);\n ┊19┊24┊\n-┊20┊  ┊export default App;\n+┊  ┊25┊export default App;🚫↵\n```\n\n##### Added src&#x2F;components&#x2F;ChatRoomScreen&#x2F;index.tsx\n```diff\n@@ -0,0 +1,74 @@\n+┊  ┊ 1┊import React from 'react';\n+┊  ┊ 2┊import { useMemo, useState } from 'react';\n+┊  ┊ 3┊\n+┊  ┊ 4┊const getChatQuery = `\n+┊  ┊ 5┊  query GetChat($chatId: ID!) {\n+┊  ┊ 6┊    chat(chatId: $chatId) {\n+┊  ┊ 7┊      id\n+┊  ┊ 8┊      name\n+┊  ┊ 9┊      picture\n+┊  ┊10┊      messages {\n+┊  ┊11┊        id\n+┊  ┊12┊        content\n+┊  ┊13┊        createdAt\n+┊  ┊14┊      }\n+┊  ┊15┊    }\n+┊  ┊16┊  }\n+┊  ┊17┊`;\n+┊  ┊18┊\n+┊  ┊19┊interface ChatRoomScreenParams {\n+┊  ┊20┊  chatId: string\n+┊  ┊21┊};\n+┊  ┊22┊\n+┊  ┊23┊interface ChatQueryMessage {\n+┊  ┊24┊  id: string;\n+┊  ┊25┊  content: string;\n+┊  ┊26┊  createdAt: string;\n+┊  ┊27┊};\n+┊  ┊28┊\n+┊  ┊29┊interface ChatQueryResult {\n+┊  ┊30┊  id: string;\n+┊  ┊31┊  name: string;\n+┊  ┊32┊  picture: string;\n+┊  ┊33┊  messages: Array<ChatQueryMessage>;\n+┊  ┊34┊};\n+┊  ┊35┊\n+┊  ┊36┊type OptionalChatQueryResult = ChatQueryResult | null;\n+┊  ┊37┊\n+┊  ┊38┊const ChatRoomScreen: React.FC<ChatRoomScreenParams> = ({ chatId }) => {\n+┊  ┊39┊  const [chat, setChat] = useState<OptionalChatQueryResult>(null);\n+┊  ┊40┊\n+┊  ┊41┊  useMemo(async () => {\n+┊  ┊42┊    const body = await fetch(`${process.env.REACT_APP_SERVER_URL}/graphql`, {\n+┊  ┊43┊      method: 'POST',\n+┊  ┊44┊      headers: {\n+┊  ┊45┊        'Content-Type': 'application/json',\n+┊  ┊46┊      },\n+┊  ┊47┊      body: JSON.stringify({\n+┊  ┊48┊        query: getChatQuery,\n+┊  ┊49┊        variables: { chatId },\n+┊  ┊50┊      }),\n+┊  ┊51┊    });\n+┊  ┊52┊    const { data: { chat } } = await body.json();\n+┊  ┊53┊    setChat(chat);\n+┊  ┊54┊  }, [chatId]);\n+┊  ┊55┊\n+┊  ┊56┊  if (!chat) return null;\n+┊  ┊57┊\n+┊  ┊58┊  return (\n+┊  ┊59┊    <div>\n+┊  ┊60┊      <img src={chat.picture} alt=\"Profile\"/>\n+┊  ┊61┊      <div>{chat.name}</div>\n+┊  ┊62┊      <ul>\n+┊  ┊63┊        {chat.messages.map((message) =>\n+┊  ┊64┊          <li key={message.id}>\n+┊  ┊65┊            <div>{message.content}</div>\n+┊  ┊66┊            <div>{message.createdAt}</div>\n+┊  ┊67┊          </li>\n+┊  ┊68┊        )}\n+┊  ┊69┊      </ul>\n+┊  ┊70┊    </div>\n+┊  ┊71┊  );\n+┊  ┊72┊};\n+┊  ┊73┊\n+┊  ┊74┊export default ChatRoomScreen;🚫↵\n```\n\n[}]: #\n\nNote how we used the `match.params.chatId` variable to get the selected chat ID.\nThe `match` prop is defined and provided to us by the `<Route />` component, since it interfaces directly with the `ChatRoomScreen`.\nMore about that can be read in the [official docs page](https://reacttraining.com/react-router/core/api/match).\n\nIn many examples online, you can see people pass the `match` prop directly to the component.\nThe main issue with that is that this makes the component being usable only by a router, but the truth is that the component\ndoesn't care if it's consumed by a router or another parents component as long as they will pass the `chatId` prop.\n\nSo we need to make sure the interface of the ChatRoom component defines those requierements right.\n\nNext we will call our server from the component with the right query and store the result on a `useState` hook.\n\nNow, because we are using GraphQL, we know the types of the result that we are going to get, so let's create Typescript interfaces that\ndescribe the data we're going to get from the server.\n\nIf you'll run the application and type `/chats/1` in the URL bar, this is what you should see on the screen:\n\n![naked-chat](https://user-images.githubusercontent.com/7648874/54664314-d4096b80-4b1e-11e9-9e06-1323cf7b0abe.png)\n\nThe view has no styling at all but it should be fixed in a moment.\nTo make navigation more convenient we will add an `onClick` listener for each chat item in the `ChatsList`.\nUsing the [history](https://reacttraining.com/react-router/core/api/history) object, provided to us by the `<Route />` component,\nwe will navigate to the correlated `ChatRoomScreen`:\n\nFirst let's install the `history` package:\n\n    $ yarn add history @types/history\n\n[{]: <helper> (diffStep 6.3 module=\"client\")\n\n#### Client Step 6.3: Navigate to chat on click\n\n##### Changed package.json\n```diff\n@@ -5,6 +5,7 @@\n ┊ 5┊ 5┊  \"dependencies\": {\n ┊ 6┊ 6┊    \"@material-ui/core\": \"3.9.3\",\n ┊ 7┊ 7┊    \"@material-ui/icons\": \"3.0.2\",\n+┊  ┊ 8┊    \"@types/history\": \"4.7.2\",\n ┊ 8┊ 9┊    \"@types/jest\": \"24.0.13\",\n ┊ 9┊10┊    \"@types/material-ui\": \"0.21.6\",\n ┊10┊11┊    \"@types/node\": \"12.0.1\",\n```\n```diff\n@@ -12,6 +13,7 @@\n ┊12┊13┊    \"@types/react-dom\": \"16.8.4\",\n ┊13┊14┊    \"@types/react-router-dom\": \"4.3.3\",\n ┊14┊15┊    \"@types/styled-components\": \"4.1.14\",\n+┊  ┊16┊    \"history\": \"4.9.0\",\n ┊15┊17┊    \"moment\": \"2.24.0\",\n ┊16┊18┊    \"react\": \"16.8.6\",\n ┊17┊19┊    \"react-dom\": \"16.8.6\",\n```\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;ChatsList.tsx\n```diff\n@@ -2,7 +2,8 @@\n ┊2┊2┊import moment from 'moment';\n ┊3┊3┊import { List, ListItem } from '@material-ui/core';\n ┊4┊4┊import styled from 'styled-components';\n-┊5┊ ┊import { useState, useMemo } from 'react';\n+┊ ┊5┊import { useCallback, useState, useMemo } from 'react';\n+┊ ┊6┊import { History } from 'history';\n ┊6┊7┊\n ┊7┊8┊const Container = styled.div `\n ┊8┊9┊  height: calc(100% - 56px);\n```\n```diff\n@@ -69,9 +70,13 @@\n ┊69┊70┊      }\n ┊70┊71┊    }\n ┊71┊72┊  }\n-┊72┊  ┊`\n+┊  ┊73┊`;\n+┊  ┊74┊\n+┊  ┊75┊interface ChatsListProps {\n+┊  ┊76┊  history : History;\n+┊  ┊77┊};\n ┊73┊78┊\n-┊74┊  ┊const ChatsList = () => {\n+┊  ┊79┊const ChatsList: React.FC<ChatsListProps> = ({ history }) => {\n ┊75┊80┊  const [chats, setChats] = useState<any[]>([]);\n ┊76┊81┊\n ┊77┊82┊  useMemo(async () => {\n```\n```diff\n@@ -86,11 +91,15 @@\n ┊ 86┊ 91┊    setChats(chats);\n ┊ 87┊ 92┊  }, []);\n ┊ 88┊ 93┊\n+┊   ┊ 94┊  const navToChat = useCallback((chat) => {\n+┊   ┊ 95┊    history.push(`chats/${chat.id}`)\n+┊   ┊ 96┊  }, [history]);\n+┊   ┊ 97┊\n ┊ 89┊ 98┊  return (\n ┊ 90┊ 99┊    <Container>\n ┊ 91┊100┊      <StyledList>\n ┊ 92┊101┊        {chats.map((chat) => (\n-┊ 93┊   ┊          <StyledListItem key={chat.id} button>\n+┊   ┊102┊          <StyledListItem key={chat.id} data-testid=\"chat\" button onClick={navToChat.bind(null, chat)}>\n ┊ 94┊103┊            <ChatPicture data-testid=\"picture\" src={chat.picture} alt=\"Profile\"/>\n ┊ 95┊104┊            <ChatInfo>\n ┊ 96┊105┊              <ChatName data-testid=\"name\">{chat.name}</ChatName>\n```\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;index.tsx\n```diff\n@@ -2,15 +2,20 @@\n ┊ 2┊ 2┊import ChatsNavbar from './ChatsNavbar';\n ┊ 3┊ 3┊import ChatsList from './ChatsList';\n ┊ 4┊ 4┊import styled from 'styled-components';\n+┊  ┊ 5┊import { History } from 'history';\n ┊ 5┊ 6┊\n ┊ 6┊ 7┊const Container = styled.div `\n ┊ 7┊ 8┊  height: 100vh;\n ┊ 8┊ 9┊`;\n ┊ 9┊10┊\n-┊10┊  ┊const ChatsListScreen: React.FC = () => (\n+┊  ┊11┊interface ChatsListScreenProps {\n+┊  ┊12┊  history : History;\n+┊  ┊13┊};\n+┊  ┊14┊\n+┊  ┊15┊const ChatsListScreen: React.FC<ChatsListScreenProps> = ({ history }) => (\n ┊11┊16┊  <Container>\n ┊12┊17┊    <ChatsNavbar />\n-┊13┊  ┊    <ChatsList />\n+┊  ┊18┊    <ChatsList history={history} />\n ┊14┊19┊  </Container>\n ┊15┊20┊);\n```\n\n[}]: #\n\nAnd add test the new logic:\n\n[{]: <helper> (diffStep 6.4 module=\"client\")\n\n#### Client Step 6.4: Test new navigation logic\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;ChatsList.test.tsx\n```diff\n@@ -1,10 +1,14 @@\n ┊ 1┊ 1┊import React from 'react';\n ┊ 2┊ 2┊import ReactDOM from 'react-dom';\n-┊ 3┊  ┊import { cleanup, render, waitForDomChange } from 'react-testing-library';\n+┊  ┊ 3┊import { cleanup, render, fireEvent, wait, waitForDomChange } from 'react-testing-library';\n ┊ 4┊ 4┊import ChatsList from './ChatsList';\n+┊  ┊ 5┊import { createBrowserHistory } from 'history';\n ┊ 5┊ 6┊\n ┊ 6┊ 7┊describe('ChatsList', () => {\n-┊ 7┊  ┊  afterEach(cleanup);\n+┊  ┊ 8┊  afterEach(() => {\n+┊  ┊ 9┊    cleanup();\n+┊  ┊10┊    window.location.pathname = '/';\n+┊  ┊11┊  });\n ┊ 8┊12┊\n ┊ 9┊13┊  it('renders fetched chats data', async () => {\n ┊10┊14┊    fetch.mockResponseOnce(JSON.stringify({\n```\n```diff\n@@ -17,7 +21,7 @@\n ┊17┊21┊            lastMessage: {\n ┊18┊22┊              id: 1,\n ┊19┊23┊              content: 'Hello',\n-┊20┊  ┊              createdAt: new Date(0),\n+┊  ┊24┊              createdAt: new Date('14 Jun 2017 00:00:00 PDT').toUTCString(),\n ┊21┊25┊            },\n ┊22┊26┊          },\n ┊23┊27┊        ],\n```\n```diff\n@@ -32,7 +36,40 @@\n ┊32┊36┊      expect(getByTestId('name')).toHaveTextContent('Foo Bar');\n ┊33┊37┊      expect(getByTestId('picture')).toHaveAttribute('src', 'https://localhost:4000/picture.jpg');\n ┊34┊38┊      expect(getByTestId('content')).toHaveTextContent('Hello');\n-┊35┊  ┊      expect(getByTestId('date')).toHaveTextContent('01:00');\n+┊  ┊39┊      expect(getByTestId('date')).toHaveTextContent('10:00');\n+┊  ┊40┊    }\n+┊  ┊41┊  });\n+┊  ┊42┊\n+┊  ┊43┊  it('should navigate to the target chat room on chat item click', async () => {\n+┊  ┊44┊    fetch.mockResponseOnce(JSON.stringify({\n+┊  ┊45┊      data: {\n+┊  ┊46┊        chats: [\n+┊  ┊47┊          {\n+┊  ┊48┊            id: 1,\n+┊  ┊49┊            name: 'Foo Bar',\n+┊  ┊50┊            picture: 'https://localhost:4000/picture.jpg',\n+┊  ┊51┊            lastMessage: {\n+┊  ┊52┊              id: 1,\n+┊  ┊53┊              content: 'Hello',\n+┊  ┊54┊              createdAt: new Date(0),\n+┊  ┊55┊            },\n+┊  ┊56┊          },\n+┊  ┊57┊        ],\n+┊  ┊58┊      },\n+┊  ┊59┊    }));\n+┊  ┊60┊\n+┊  ┊61┊     const history = createBrowserHistory();\n+┊  ┊62┊\n+┊  ┊63┊     {\n+┊  ┊64┊      const { container, getByTestId } = render(<ChatsList history={history} />);\n+┊  ┊65┊\n+┊  ┊66┊       await waitForDomChange({ container });\n+┊  ┊67┊\n+┊  ┊68┊       fireEvent.click(getByTestId('chat'));\n+┊  ┊69┊\n+┊  ┊70┊       await wait(() =>\n+┊  ┊71┊        expect(history.location.pathname).toEqual('/chats/1')\n+┊  ┊72┊      );\n ┊36┊73┊    }\n ┊37┊74┊  });\n ┊38┊75┊});\n```\n\n[}]: #\n\nIf you'll click on the chat item you'll see that the screen changes very suddenly.\nWe can smooth the transition by animating it with CSS.\nLuckily we don't need to implemented such mechanism manually because there's a package that can do that for us - [`react-router-transition`](https://www.npmjs.com/package/react-router-transition):\n\n    $ yarn add react-router-transition\n\nAnd let's add the mising types for the library:\n\n[{]: <helper> (diffStep 6.5 files=\"react-app-env.d.ts\" module=\"client\")\n\n#### Client Step 6.5: Animate route switching\n\n##### Changed src&#x2F;react-app-env.d.ts\n```diff\n@@ -1 +1,3 @@\n ┊1┊1┊/// <reference types=\"react-scripts\" />\n+┊ ┊2┊\n+┊ ┊3┊declare module \"react-router-transition\";🚫↵\n```\n\n[}]: #\n\nUsing this package, we will create a custom `Switch` component that will play an animation for all its subordinate `Route` components.\nThe animation is defined by the user using a component called `AnimatedSwitch` as specified in the [package's docs page](http://maisano.github.io/react-router-transition/animated-switch/props).\nSo first, let's create our switch component that will play a smooth transition switching routes:\n\n[{]: <helper> (diffStep 6.5 files=\"AnimatedSwitch\" module=\"client\")\n\n#### Client Step 6.5: Animate route switching\n\n##### Added src&#x2F;components&#x2F;AnimatedSwitch.tsx\n```diff\n@@ -0,0 +1,37 @@\n+┊  ┊ 1┊import { Switch } from 'react-router-dom';\n+┊  ┊ 2┊import { AnimatedSwitch, spring } from 'react-router-transition';\n+┊  ┊ 3┊import styled from 'styled-components';\n+┊  ┊ 4┊\n+┊  ┊ 5┊// A workaround to make test pass\n+┊  ┊ 6┊const SwitchComponent = process.env.NODE_ENV === 'test' ? Switch : AnimatedSwitch;\n+┊  ┊ 7┊\n+┊  ┊ 8┊const glide = (val: number) =>\n+┊  ┊ 9┊  spring(val, {\n+┊  ┊10┊    stiffness: 174,\n+┊  ┊11┊    damping: 24,\n+┊  ┊12┊  });\n+┊  ┊13┊\n+┊  ┊14┊const mapStyles = (styles :any) => ({\n+┊  ┊15┊  transform: `translateX(${styles.offset}%)`,\n+┊  ┊16┊});\n+┊  ┊17┊\n+┊  ┊18┊const MyAnimatedSwitch =  styled(SwitchComponent).attrs(() => ({\n+┊  ┊19┊  atEnter: { offset: 100 },\n+┊  ┊20┊  atLeave: { offset: glide(-100) },\n+┊  ┊21┊  atActive: { offset: glide(0) },\n+┊  ┊22┊  mapStyles,\n+┊  ┊23┊}))`\n+┊  ┊24┊  position: relative;\n+┊  ┊25┊  overflow: hidden;\n+┊  ┊26┊  height: 100vh;\n+┊  ┊27┊  width: 100vw;\n+┊  ┊28┊\n+┊  ┊29┊  > div {\n+┊  ┊30┊    position: absolute;\n+┊  ┊31┊    overflow: hidden;\n+┊  ┊32┊    height: 100vh;\n+┊  ┊33┊    width: 100vw;\n+┊  ┊34┊  }\n+┊  ┊35┊`\n+┊  ┊36┊\n+┊  ┊37┊export default MyAnimatedSwitch;\n```\n\n[}]: #\n\nAnd then replace it with the main `Switch` component in our app:\n\n[{]: <helper> (diffStep 6.5 files=\"App\" module=\"client\")\n\n#### Client Step 6.5: Animate route switching\n\n##### Changed src&#x2F;App.tsx\n```diff\n@@ -1,11 +1,12 @@\n ┊ 1┊ 1┊import React from 'react';\n-┊ 2┊  ┊import { BrowserRouter, Route, Redirect, Switch, RouteComponentProps } from 'react-router-dom';\n+┊  ┊ 2┊import { BrowserRouter, Route, Redirect, RouteComponentProps } from 'react-router-dom';\n ┊ 3┊ 3┊import ChatRoomScreen from './components/ChatRoomScreen';\n ┊ 4┊ 4┊import ChatsListScreen from './components/ChatsListScreen';\n+┊  ┊ 5┊import AnimatedSwitch from './components/AnimatedSwitch';\n ┊ 5┊ 6┊\n ┊ 6┊ 7┊const App: React.FC = () => (\n ┊ 7┊ 8┊  <BrowserRouter>\n-┊ 8┊  ┊    <Switch>\n+┊  ┊ 9┊    <AnimatedSwitch>\n ┊ 9┊10┊      <Route exact path=\"/chats\" component={ChatsListScreen} />\n ┊10┊11┊\n ┊11┊12┊      <Route exact path=\"/chats/:chatId\" component={\n```\n```diff\n@@ -13,7 +14,7 @@\n ┊13┊14┊        (<ChatRoomScreen chatId={match.params.chatId} />)\n ┊14┊15┊      } />\n ┊15┊16┊\n-┊16┊  ┊    </Switch>\n+┊  ┊17┊    </AnimatedSwitch>\n ┊17┊18┊    <Route exact path=\"/\" render={redirectToChats} />\n ┊18┊19┊  </BrowserRouter>\n ┊19┊20┊);\n```\n\n[}]: #\n\nBoth components act identically and thus there shall be no special treatment. Behold the new transition effect:\n\n![transition-demo](https://user-images.githubusercontent.com/7648874/54739398-ebb22400-4bf2-11e9-8d4c-2aeb65deeb92.gif)\n\nThe final screen will be composed out of 3 components:\n\n\n\n*   A navigation bar.\n*   A messages list.\n*   A message input.\n\nWe will create a new directory under the path `public/assets` and inside we will download and place a couple of assets which are necessary for our view:\n\n*   [chat-background.jpg](https://raw.githubusercontent.com/Urigo/WhatsApp-Clone-Client-Angular/master/src/assets/chat-background.jpg)\n*   [message-mine.png](https://raw.githubusercontent.com/Urigo/WhatsApp-Clone-Client-Angular/master/src/assets/message-mine.png)\n\nIn the main `index.ts` file of the screen we will simply import all 3 in the right order.\nWe will start with the most simple one - the `ChatRoomNavbar`.\nThe navbar should show the picture of the chat we're currently at and its name,\nalong with a back button that will bring us back to the `ChatsListScreen`:\n\n[{]: <helper> (diffStep 6.6 files=\"ChatNavbar\" module=\"client\")\n\n#### Client Step 6.6: Implement ChatRoomScreen components\n\n##### Added src&#x2F;components&#x2F;ChatRoomScreen&#x2F;ChatNavbar.tsx\n```diff\n@@ -0,0 +1,59 @@\n+┊  ┊ 1┊import Button from '@material-ui/core/Button';\n+┊  ┊ 2┊import Toolbar from '@material-ui/core/Toolbar';\n+┊  ┊ 3┊import ArrowBackIcon from '@material-ui/icons/ArrowBack';\n+┊  ┊ 4┊import React from 'react';\n+┊  ┊ 5┊import { useCallback } from 'react';\n+┊  ┊ 6┊import styled from 'styled-components';\n+┊  ┊ 7┊import { History } from 'history';\n+┊  ┊ 8┊import { ChatQueryResult } from './index';\n+┊  ┊ 9┊\n+┊  ┊10┊const Container = styled(Toolbar) `\n+┊  ┊11┊  padding: 0;\n+┊  ┊12┊  display: flex;\n+┊  ┊13┊  flex-direction: row;\n+┊  ┊14┊  background-color: var(--primary-bg);\n+┊  ┊15┊  color: var(--primary-text);\n+┊  ┊16┊` as typeof Toolbar;\n+┊  ┊17┊\n+┊  ┊18┊const BackButton = styled(Button) `\n+┊  ┊19┊  svg {\n+┊  ┊20┊    color: var(--primary-text);\n+┊  ┊21┊  }\n+┊  ┊22┊` as typeof Button;\n+┊  ┊23┊\n+┊  ┊24┊const Picture = styled.img `\n+┊  ┊25┊  height: 40px;\n+┊  ┊26┊  width: 40px;\n+┊  ┊27┊  margin-top: 3px;\n+┊  ┊28┊  margin-left: -22px;\n+┊  ┊29┊  object-fit: cover;\n+┊  ┊30┊  padding: 5px;\n+┊  ┊31┊  border-radius: 50%;\n+┊  ┊32┊`;\n+┊  ┊33┊\n+┊  ┊34┊const Name = styled.div `\n+┊  ┊35┊  line-height: 56px;\n+┊  ┊36┊`;\n+┊  ┊37┊\n+┊  ┊38┊interface ChatNavbarProps {\n+┊  ┊39┊  history: History;\n+┊  ┊40┊  chat: ChatQueryResult;\n+┊  ┊41┊};\n+┊  ┊42┊\n+┊  ┊43┊const ChatNavbar: React.FC<ChatNavbarProps> = ({ chat, history }) => {\n+┊  ┊44┊  const navBack = useCallback(() => {\n+┊  ┊45┊    history.replace('/chats');\n+┊  ┊46┊  }, [history]);\n+┊  ┊47┊\n+┊  ┊48┊  return (\n+┊  ┊49┊    <Container>\n+┊  ┊50┊      <BackButton onClick={navBack}>\n+┊  ┊51┊        <ArrowBackIcon />\n+┊  ┊52┊      </BackButton>\n+┊  ┊53┊      <Picture src={chat.picture} />\n+┊  ┊54┊      <Name>{chat.name}</Name>\n+┊  ┊55┊    </Container>\n+┊  ┊56┊  );\n+┊  ┊57┊};\n+┊  ┊58┊\n+┊  ┊59┊export default ChatNavbar;🚫↵\n```\n\n[}]: #\n\nNext, would be the `MesagesList` component, where we will see a scrollable list of all the messages of the active chat:\n\n[{]: <helper> (diffStep 6.6 files=\"MessagesList\" module=\"client\")\n\n#### Client Step 6.6: Implement ChatRoomScreen components\n\n##### Added src&#x2F;components&#x2F;ChatRoomScreen&#x2F;MessagesList.tsx\n```diff\n@@ -0,0 +1,78 @@\n+┊  ┊ 1┊import moment from 'moment';\n+┊  ┊ 2┊import React from 'react';\n+┊  ┊ 3┊import styled from 'styled-components';\n+┊  ┊ 4┊import { ChatQueryMessage } from './index';\n+┊  ┊ 5┊\n+┊  ┊ 6┊const Container = styled.div`\n+┊  ┊ 7┊  display: block;\n+┊  ┊ 8┊  flex: 2;\n+┊  ┊ 9┊  overflow-y: overlay;\n+┊  ┊10┊  padding: 0 15px;\n+┊  ┊11┊`;\n+┊  ┊12┊\n+┊  ┊13┊const MessageItem = styled.div `\n+┊  ┊14┊  float: right;\n+┊  ┊15┊  background-color: #dcf8c6;\n+┊  ┊16┊  display: inline-block;\n+┊  ┊17┊  position: relative;\n+┊  ┊18┊  max-width: 100%;\n+┊  ┊19┊  border-radius: 7px;\n+┊  ┊20┊  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.15);\n+┊  ┊21┊  margin-top: 10px;\n+┊  ┊22┊  margin-bottom: 10px;\n+┊  ┊23┊  clear: both;\n+┊  ┊24┊\n+┊  ┊25┊  &::after {\n+┊  ┊26┊    content: '';\n+┊  ┊27┊    display: table;\n+┊  ┊28┊    clear: both;\n+┊  ┊29┊  }\n+┊  ┊30┊\n+┊  ┊31┊  &::before {\n+┊  ┊32┊    background-image: url(/assets/message-mine.png);\n+┊  ┊33┊    content: '';\n+┊  ┊34┊    position: absolute;\n+┊  ┊35┊    bottom: 3px;\n+┊  ┊36┊    width: 12px;\n+┊  ┊37┊    height: 19px;\n+┊  ┊38┊    right: -11px;\n+┊  ┊39┊    background-position: 50% 50%;\n+┊  ┊40┊    background-repeat: no-repeat;\n+┊  ┊41┊    background-size: contain;\n+┊  ┊42┊  }\n+┊  ┊43┊`;\n+┊  ┊44┊\n+┊  ┊45┊const Contents = styled.div `\n+┊  ┊46┊  padding: 5px 7px;\n+┊  ┊47┊  word-wrap: break-word;\n+┊  ┊48┊\n+┊  ┊49┊  &::after {\n+┊  ┊50┊    content: ' \\00a0\\00a0\\00a0\\00a0\\00a0\\00a0\\00a0\\00a0\\00a0\\00a0\\00a0\\00a0\\00a0\\00a0\\00a0\\00a0\\00a0\\00a0\\00a0';\n+┊  ┊51┊    display: inline;\n+┊  ┊52┊  }\n+┊  ┊53┊`;\n+┊  ┊54┊\n+┊  ┊55┊const Timestamp = styled.div `\n+┊  ┊56┊  position: absolute;\n+┊  ┊57┊  bottom: 2px;\n+┊  ┊58┊  right: 7px;\n+┊  ┊59┊  color: gray;\n+┊  ┊60┊  font-size: 12px;\n+┊  ┊61┊`;\n+┊  ┊62┊\n+┊  ┊63┊interface MessagesListProps {\n+┊  ┊64┊  messages: Array<ChatQueryMessage>;\n+┊  ┊65┊}\n+┊  ┊66┊\n+┊  ┊67┊const MessagesList: React.FC<MessagesListProps> = ({ messages }) => (\n+┊  ┊68┊  <Container>\n+┊  ┊69┊    {messages.map((message: any) => (\n+┊  ┊70┊      <MessageItem key={message.id}>\n+┊  ┊71┊        <Contents>{message.content}</Contents>\n+┊  ┊72┊        <Timestamp>{moment(message.createdAt).format('HH:mm')}</Timestamp>\n+┊  ┊73┊      </MessageItem>\n+┊  ┊74┊    ))}\n+┊  ┊75┊  </Container>\n+┊  ┊76┊);\n+┊  ┊77┊\n+┊  ┊78┊export default MessagesList;🚫↵\n```\n\n[}]: #\n\nAnd finally, would be the `MessageInput` component which will trigger an event whenever we type and submit a new message:\n\n[{]: <helper> (diffStep 6.6 files=\"MessageInput\" module=\"client\")\n\n#### Client Step 6.6: Implement ChatRoomScreen components\n\n##### Added src&#x2F;components&#x2F;ChatRoomScreen&#x2F;MessageInput.tsx\n```diff\n@@ -0,0 +1,60 @@\n+┊  ┊ 1┊import Button from '@material-ui/core/Button';\n+┊  ┊ 2┊import SendIcon from '@material-ui/icons/Send';\n+┊  ┊ 3┊import React from 'react';\n+┊  ┊ 4┊import styled from 'styled-components';\n+┊  ┊ 5┊\n+┊  ┊ 6┊const Container = styled.div`\n+┊  ┊ 7┊  display: flex;\n+┊  ┊ 8┊  height: 50px;\n+┊  ┊ 9┊  padding: 5px;\n+┊  ┊10┊  width: calc(100% - 10px);\n+┊  ┊11┊`;\n+┊  ┊12┊\n+┊  ┊13┊const ActualInput = styled.input `\n+┊  ┊14┊  width: calc(100% - 50px);\n+┊  ┊15┊  border: none;\n+┊  ┊16┊  border-radius: 999px;\n+┊  ┊17┊  padding: 10px;\n+┊  ┊18┊  padding-left: 20px;\n+┊  ┊19┊  padding-right: 20px;\n+┊  ┊20┊  font-size: 15px;\n+┊  ┊21┊  outline: none;\n+┊  ┊22┊  box-shadow: 0 1px silver;\n+┊  ┊23┊  font-size: 18px;\n+┊  ┊24┊  line-height: 45px;\n+┊  ┊25┊`;\n+┊  ┊26┊\n+┊  ┊27┊const SendButton = styled(Button) `\n+┊  ┊28┊  min-width: 50px !important;\n+┊  ┊29┊  width: 50px !important;\n+┊  ┊30┊  border-radius: 999px !important;\n+┊  ┊31┊  background-color: var(--primary-bg) !important;\n+┊  ┊32┊  margin: 0 5px !important;\n+┊  ┊33┊  margin-right: 0 !important;\n+┊  ┊34┊  color: white !important;\n+┊  ┊35┊  padding-left: 20px !important;\n+┊  ┊36┊\n+┊  ┊37┊  svg {\n+┊  ┊38┊    margin-left: -3px;\n+┊  ┊39┊  }\n+┊  ┊40┊` as typeof Button;\n+┊  ┊41┊\n+┊  ┊42┊const MessageInput: React.FC = () => {\n+┊  ┊43┊\n+┊  ┊44┊  return (\n+┊  ┊45┊    <Container>\n+┊  ┊46┊      <ActualInput\n+┊  ┊47┊        type=\"text\"\n+┊  ┊48┊        placeholder=\"Type a message\"\n+┊  ┊49┊      />\n+┊  ┊50┊      <SendButton\n+┊  ┊51┊        variant=\"contained\"\n+┊  ┊52┊        color=\"primary\"\n+┊  ┊53┊      >\n+┊  ┊54┊        <SendIcon />\n+┊  ┊55┊      </SendButton>\n+┊  ┊56┊    </Container>\n+┊  ┊57┊  );\n+┊  ┊58┊};\n+┊  ┊59┊\n+┊  ┊60┊export default MessageInput;🚫↵\n```\n\n[}]: #\n\nNow that we have all 3 components, we will put them all together in the main `index.ts` file:\n\n[{]: <helper> (diffStep 6.6 files=\"index\" module=\"client\")\n\n#### Client Step 6.6: Implement ChatRoomScreen components\n\n##### Changed src&#x2F;components&#x2F;ChatRoomScreen&#x2F;index.tsx\n```diff\n@@ -1,5 +1,17 @@\n ┊ 1┊ 1┊import React from 'react';\n ┊ 2┊ 2┊import { useMemo, useState } from 'react';\n+┊  ┊ 3┊import styled from 'styled-components';\n+┊  ┊ 4┊import ChatNavbar from './ChatNavbar';\n+┊  ┊ 5┊import MessageInput from './MessageInput';\n+┊  ┊ 6┊import MessagesList from './MessagesList';\n+┊  ┊ 7┊import { History } from 'history';\n+┊  ┊ 8┊\n+┊  ┊ 9┊ const Container = styled.div `\n+┊  ┊10┊  background: url(/assets/chat-background.jpg);\n+┊  ┊11┊  display: flex;\n+┊  ┊12┊  flex-flow: column;\n+┊  ┊13┊  height: 100vh;\n+┊  ┊14┊`;\n ┊ 3┊15┊\n ┊ 4┊16┊const getChatQuery = `\n ┊ 5┊17┊  query GetChat($chatId: ID!) {\n```\n```diff\n@@ -18,15 +30,16 @@\n ┊18┊30┊\n ┊19┊31┊interface ChatRoomScreenParams {\n ┊20┊32┊  chatId: string\n+┊  ┊33┊  history: History;\n ┊21┊34┊};\n ┊22┊35┊\n-┊23┊  ┊interface ChatQueryMessage {\n+┊  ┊36┊export interface ChatQueryMessage {\n ┊24┊37┊  id: string;\n ┊25┊38┊  content: string;\n ┊26┊39┊  createdAt: string;\n ┊27┊40┊};\n ┊28┊41┊\n-┊29┊  ┊interface ChatQueryResult {\n+┊  ┊42┊export interface ChatQueryResult {\n ┊30┊43┊  id: string;\n ┊31┊44┊  name: string;\n ┊32┊45┊  picture: string;\n```\n```diff\n@@ -35,7 +48,7 @@\n ┊35┊48┊\n ┊36┊49┊type OptionalChatQueryResult = ChatQueryResult | null;\n ┊37┊50┊\n-┊38┊  ┊const ChatRoomScreen: React.FC<ChatRoomScreenParams> = ({ chatId }) => {\n+┊  ┊51┊const ChatRoomScreen: React.FC<ChatRoomScreenParams> = ({ history, chatId }) => {\n ┊39┊52┊  const [chat, setChat] = useState<OptionalChatQueryResult>(null);\n ┊40┊53┊\n ┊41┊54┊  useMemo(async () => {\n```\n```diff\n@@ -56,18 +69,13 @@\n ┊56┊69┊  if (!chat) return null;\n ┊57┊70┊\n ┊58┊71┊  return (\n-┊59┊  ┊    <div>\n-┊60┊  ┊      <img src={chat.picture} alt=\"Profile\"/>\n-┊61┊  ┊      <div>{chat.name}</div>\n-┊62┊  ┊      <ul>\n-┊63┊  ┊        {chat.messages.map((message) =>\n-┊64┊  ┊          <li key={message.id}>\n-┊65┊  ┊            <div>{message.content}</div>\n-┊66┊  ┊            <div>{message.createdAt}</div>\n-┊67┊  ┊          </li>\n-┊68┊  ┊        )}\n-┊69┊  ┊      </ul>\n-┊70┊  ┊    </div>\n+┊  ┊72┊    <Container>\n+┊  ┊73┊      <ChatNavbar chat={chat} history={history} />\n+┊  ┊74┊      {chat.messages && (\n+┊  ┊75┊        <MessagesList messages={chat.messages} />\n+┊  ┊76┊      )}\n+┊  ┊77┊      <MessageInput />\n+┊  ┊78┊    </Container>\n ┊71┊79┊  );\n ┊72┊80┊};\n```\n\n[}]: #\n\nThe view is complete! However the `MessageInput` is not bound to our messages list.\nWe will use the triggered callback to update the chat state, whose changes should appear in the `MessagesList` component in the following render phase:\n\n[{]: <helper> (diffStep 6.7 module=\"client\")\n\n#### Client Step 6.7: Define onSendMessage callback\n\n##### Changed src&#x2F;components&#x2F;ChatRoomScreen&#x2F;MessageInput.tsx\n```diff\n@@ -2,6 +2,7 @@\n ┊2┊2┊import SendIcon from '@material-ui/icons/Send';\n ┊3┊3┊import React from 'react';\n ┊4┊4┊import styled from 'styled-components';\n+┊ ┊5┊import { useState } from 'react';\n ┊5┊6┊\n ┊6┊7┊const Container = styled.div`\n ┊7┊8┊  display: flex;\n```\n```diff\n@@ -39,17 +40,46 @@\n ┊39┊40┊  }\n ┊40┊41┊` as typeof Button;\n ┊41┊42┊\n-┊42┊  ┊const MessageInput: React.FC = () => {\n+┊  ┊43┊interface MessageInputProps {\n+┊  ┊44┊  onSendMessage(content: string): any;\n+┊  ┊45┊}\n+┊  ┊46┊\n+┊  ┊47┊const MessageInput: React.FC<MessageInputProps> = ({ onSendMessage }) => {\n+┊  ┊48┊  const [message, setMessage] = useState(\"\");\n+┊  ┊49┊\n+┊  ┊50┊  const onKeyPress = (e: any) => {\n+┊  ┊51┊    if (e.charCode === 13) {\n+┊  ┊52┊      submitMessage();\n+┊  ┊53┊    }\n+┊  ┊54┊  };\n+┊  ┊55┊\n+┊  ┊56┊  const onChange = ({ target }: any) => {\n+┊  ┊57┊    setMessage(target.value);\n+┊  ┊58┊  };\n+┊  ┊59┊\n+┊  ┊60┊  const submitMessage = () => {\n+┊  ┊61┊    if (!message) return;\n+┊  ┊62┊\n+┊  ┊63┊    setMessage(\"\");\n+┊  ┊64┊\n+┊  ┊65┊    if (typeof onSendMessage === \"function\") {\n+┊  ┊66┊      onSendMessage(message);\n+┊  ┊67┊    }\n+┊  ┊68┊  };\n ┊43┊69┊\n ┊44┊70┊  return (\n ┊45┊71┊    <Container>\n ┊46┊72┊      <ActualInput\n ┊47┊73┊        type=\"text\"\n ┊48┊74┊        placeholder=\"Type a message\"\n+┊  ┊75┊        value={message}\n+┊  ┊76┊        onKeyPress={onKeyPress}\n+┊  ┊77┊        onChange={onChange}\n ┊49┊78┊      />\n ┊50┊79┊      <SendButton\n ┊51┊80┊        variant=\"contained\"\n ┊52┊81┊        color=\"primary\"\n+┊  ┊82┊        onClick={submitMessage}\n ┊53┊83┊      >\n ┊54┊84┊        <SendIcon />\n ┊55┊85┊      </SendButton>\n```\n\n##### Changed src&#x2F;components&#x2F;ChatRoomScreen&#x2F;index.tsx\n```diff\n@@ -1,5 +1,5 @@\n ┊1┊1┊import React from 'react';\n-┊2┊ ┊import { useMemo, useState } from 'react';\n+┊ ┊2┊import { useCallback, useMemo, useState } from 'react';\n ┊3┊3┊import styled from 'styled-components';\n ┊4┊4┊import ChatNavbar from './ChatNavbar';\n ┊5┊5┊import MessageInput from './MessageInput';\n```\n```diff\n@@ -36,7 +36,7 @@\n ┊36┊36┊export interface ChatQueryMessage {\n ┊37┊37┊  id: string;\n ┊38┊38┊  content: string;\n-┊39┊  ┊  createdAt: string;\n+┊  ┊39┊  createdAt: number;\n ┊40┊40┊};\n ┊41┊41┊\n ┊42┊42┊export interface ChatQueryResult {\n```\n```diff\n@@ -66,6 +66,23 @@\n ┊66┊66┊    setChat(chat);\n ┊67┊67┊  }, [chatId]);\n ┊68┊68┊\n+┊  ┊69┊  const onSendMessage = useCallback((content: string) => {\n+┊  ┊70┊    if (!chat) return null;\n+┊  ┊71┊\n+┊  ┊72┊    const message = {\n+┊  ┊73┊      id: (chat.messages.length + 10).toString(),\n+┊  ┊74┊      createdAt: Date.now(),\n+┊  ┊75┊      content,\n+┊  ┊76┊    };\n+┊  ┊77┊\n+┊  ┊78┊    console.log(chat.messages);\n+┊  ┊79┊\n+┊  ┊80┊     setChat({\n+┊  ┊81┊      ...chat,\n+┊  ┊82┊      messages: chat.messages.concat(message),\n+┊  ┊83┊    });\n+┊  ┊84┊  }, [chat]);\n+┊  ┊85┊\n ┊69┊86┊  if (!chat) return null;\n ┊70┊87┊\n ┊71┊88┊  return (\n```\n```diff\n@@ -74,7 +91,7 @@\n ┊74┊91┊      {chat.messages && (\n ┊75┊92┊        <MessagesList messages={chat.messages} />\n ┊76┊93┊      )}\n-┊77┊  ┊      <MessageInput />\n+┊  ┊94┊      <MessageInput onSendMessage={onSendMessage}/>\n ┊78┊95┊    </Container>\n ┊79┊96┊  );\n ┊80┊97┊};\n```\n\n[}]: #\n\nThis is how the entire flow should look like:\n\n![flow-demo](https://user-images.githubusercontent.com/7648874/54739741-27012280-4bf4-11e9-97cb-c715482e2e70.gif)\n\nAn edge case that should be taken care of is when the messages list length in the view exceeds the length of the container,\nin which case we will have to scroll down to the bottom of the view.\nThis way we can keep track of the most recent message.\nWe will use `ReactDOM` to retrieve the native HTML element of the container and change the position of the scroller whenever a messages was sent:\n\n[{]: <helper> (diffStep 6.8 module=\"client\")\n\n#### Client Step 6.8: Reset scroller on message sent\n\n##### Changed src&#x2F;components&#x2F;ChatRoomScreen&#x2F;MessagesList.tsx\n```diff\n@@ -1,5 +1,7 @@\n ┊1┊1┊import moment from 'moment';\n ┊2┊2┊import React from 'react';\n+┊ ┊3┊import { useEffect, useRef } from 'react';\n+┊ ┊4┊import ReactDOM from 'react-dom';\n ┊3┊5┊import styled from 'styled-components';\n ┊4┊6┊import { ChatQueryMessage } from './index';\n ┊5┊7┊\n```\n```diff\n@@ -64,15 +66,26 @@\n ┊64┊66┊  messages: Array<ChatQueryMessage>;\n ┊65┊67┊}\n ┊66┊68┊\n-┊67┊  ┊const MessagesList: React.FC<MessagesListProps> = ({ messages }) => (\n-┊68┊  ┊  <Container>\n-┊69┊  ┊    {messages.map((message: any) => (\n-┊70┊  ┊      <MessageItem key={message.id}>\n-┊71┊  ┊        <Contents>{message.content}</Contents>\n-┊72┊  ┊        <Timestamp>{moment(message.createdAt).format('HH:mm')}</Timestamp>\n-┊73┊  ┊      </MessageItem>\n-┊74┊  ┊    ))}\n-┊75┊  ┊  </Container>\n-┊76┊  ┊);\n+┊  ┊69┊const MessagesList: React.FC<MessagesListProps> = ({ messages }) => {\n+┊  ┊70┊  const selfRef = useRef(null);\n+┊  ┊71┊\n+┊  ┊72┊  useEffect(() => {\n+┊  ┊73┊    if (!selfRef.current) return;\n+┊  ┊74┊\n+┊  ┊75┊     const selfDOMNode = ReactDOM.findDOMNode(selfRef.current) as HTMLElement;\n+┊  ┊76┊    selfDOMNode.scrollTop = Number.MAX_SAFE_INTEGER;\n+┊  ┊77┊  }, [messages.length]);\n+┊  ┊78┊\n+┊  ┊79┊  return (\n+┊  ┊80┊    <Container ref={selfRef}>\n+┊  ┊81┊      {messages.map((message: any) => (\n+┊  ┊82┊        <MessageItem key={message.id}>\n+┊  ┊83┊          <Contents>{message.content}</Contents>\n+┊  ┊84┊          <Timestamp>{moment(message.createdAt).format('HH:mm')}</Timestamp>\n+┊  ┊85┊        </MessageItem>\n+┊  ┊86┊      ))}\n+┊  ┊87┊    </Container>\n+┊  ┊88┊  )\n+┊  ┊89┊};\n ┊77┊90┊\n ┊78┊91┊export default MessagesList;🚫↵\n```\n\n[}]: #\n\nBefore we wrap things up, we should also test our components.\nSince the new components have a direct control over the app's history,\nwe should also find a way to simulate it in our tests.\nBecause `react-dom-router` uses the [`history`](https://www.npmjs.com/package/history) package under the hood,\nthat means that we can use that package to inject a custom history object directly into the tested components:\n\n[{]: <helper> (diffStep 6.9 files=\"components\" module=\"client\")\n\n#### Client Step 6.9: Test ChatRoomScreen child components\n\n##### Added src&#x2F;components&#x2F;ChatRoomScreen&#x2F;ChatNavbar.test.tsx\n```diff\n@@ -0,0 +1,49 @@\n+┊  ┊ 1┊import { createMemoryHistory } from 'history';\n+┊  ┊ 2┊import React from 'react';\n+┊  ┊ 3┊import { cleanup, render, fireEvent, wait } from 'react-testing-library';\n+┊  ┊ 4┊import ChatNavbar from './ChatNavbar';\n+┊  ┊ 5┊\n+┊  ┊ 6┊describe('ChatNavbar', () => {\n+┊  ┊ 7┊  afterEach(cleanup);\n+┊  ┊ 8┊\n+┊  ┊ 9┊  it('renders chat data', () => {\n+┊  ┊10┊    const chat = {\n+┊  ┊11┊      id: '1',\n+┊  ┊12┊      name: 'Foo Bar',\n+┊  ┊13┊      picture: 'https://localhost:4000/picture.jpg',\n+┊  ┊14┊    };\n+┊  ┊15┊\n+┊  ┊16┊    {\n+┊  ┊17┊      const { container, getByTestId } = render(<ChatNavbar chat={chat} />);\n+┊  ┊18┊\n+┊  ┊19┊      expect(getByTestId('chat-name')).toHaveTextContent('Foo Bar');\n+┊  ┊20┊      expect(getByTestId('chat-picture')).toHaveAttribute('src', 'https://localhost:4000/picture.jpg');\n+┊  ┊21┊    }\n+┊  ┊22┊  })\n+┊  ┊23┊\n+┊  ┊24┊  it('goes back on arrow click', async () => {\n+┊  ┊25┊    const chat = {\n+┊  ┊26┊      id: '1',\n+┊  ┊27┊      name: 'Foo Bar',\n+┊  ┊28┊      picture: 'https://localhost:4000/picture.jpg',\n+┊  ┊29┊    };\n+┊  ┊30┊\n+┊  ┊31┊    const history = createMemoryHistory();\n+┊  ┊32┊\n+┊  ┊33┊    history.push('/chats/1');\n+┊  ┊34┊\n+┊  ┊35┊    await wait(() =>\n+┊  ┊36┊      expect(history.location.pathname).toEqual('/chats/1')\n+┊  ┊37┊    )\n+┊  ┊38┊\n+┊  ┊39┊    {\n+┊  ┊40┊      const { container, getByTestId } = render(<ChatNavbar chat={chat} history={history} />);\n+┊  ┊41┊\n+┊  ┊42┊      fireEvent.click(getByTestId('back-button'));\n+┊  ┊43┊\n+┊  ┊44┊      await wait(() =>\n+┊  ┊45┊        expect(history.location.pathname).toEqual('/chats')\n+┊  ┊46┊      );\n+┊  ┊47┊    }\n+┊  ┊48┊  });\n+┊  ┊49┊});🚫↵\n```\n\n##### Changed src&#x2F;components&#x2F;ChatRoomScreen&#x2F;ChatNavbar.tsx\n```diff\n@@ -47,11 +47,11 @@\n ┊47┊47┊\n ┊48┊48┊  return (\n ┊49┊49┊    <Container>\n-┊50┊  ┊      <BackButton onClick={navBack}>\n+┊  ┊50┊      <BackButton data-testid=\"back-button\" onClick={navBack}>\n ┊51┊51┊        <ArrowBackIcon />\n ┊52┊52┊      </BackButton>\n-┊53┊  ┊      <Picture src={chat.picture} />\n-┊54┊  ┊      <Name>{chat.name}</Name>\n+┊  ┊53┊      <Picture data-testid=\"chat-picture\" src={chat.picture} />\n+┊  ┊54┊      <Name data-testid=\"chat-name\">{chat.name}</Name>\n ┊55┊55┊    </Container>\n ┊56┊56┊  );\n ┊57┊57┊};\n```\n\n##### Added src&#x2F;components&#x2F;ChatRoomScreen&#x2F;MessageInput.test.tsx\n```diff\n@@ -0,0 +1,47 @@\n+┊  ┊ 1┊import { createMemoryHistory } from 'history';\n+┊  ┊ 2┊import React from 'react';\n+┊  ┊ 3┊import { cleanup, render, fireEvent, wait, waitForElement } from 'react-testing-library';\n+┊  ┊ 4┊import MessageInput from './MessageInput';\n+┊  ┊ 5┊\n+┊  ┊ 6┊describe('MessageInput;', () => {\n+┊  ┊ 7┊  afterEach(cleanup);\n+┊  ┊ 8┊\n+┊  ┊ 9┊  it('triggers callback on send button click', async () => {\n+┊  ┊10┊    const onSendMessage = jest.fn(() => {});\n+┊  ┊11┊\n+┊  ┊12┊    {\n+┊  ┊13┊      const { container, getByTestId } = render(<MessageInput onSendMessage={onSendMessage} />);\n+┊  ┊14┊      const messageInput = getByTestId('message-input');\n+┊  ┊15┊      const sendButton = getByTestId('send-button');\n+┊  ┊16┊\n+┊  ┊17┊      fireEvent.change(messageInput, { target: { value: 'foo' } });\n+┊  ┊18┊\n+┊  ┊19┊      await waitForElement(() => messageInput);\n+┊  ┊20┊\n+┊  ┊21┊      fireEvent.click(sendButton);\n+┊  ┊22┊\n+┊  ┊23┊      await wait(() =>\n+┊  ┊24┊        expect(onSendMessage.mock.calls.length).toBe(1)\n+┊  ┊25┊      );\n+┊  ┊26┊    }\n+┊  ┊27┊  });\n+┊  ┊28┊\n+┊  ┊29┊  it('triggers callback on Enter press', async () => {\n+┊  ┊30┊    const onSendMessage = jest.fn(() => {});\n+┊  ┊31┊\n+┊  ┊32┊    {\n+┊  ┊33┊      const { container, getByTestId } = render(<MessageInput onSendMessage={onSendMessage} />);\n+┊  ┊34┊      const messageInput = getByTestId('message-input');\n+┊  ┊35┊\n+┊  ┊36┊      fireEvent.change(messageInput, { target: { value: 'foo' } });\n+┊  ┊37┊\n+┊  ┊38┊      await waitForElement(() => messageInput);\n+┊  ┊39┊\n+┊  ┊40┊      fireEvent.keyPress(messageInput, { key: 'Enter', code: 13, charCode: 13 });\n+┊  ┊41┊\n+┊  ┊42┊      await wait(() =>\n+┊  ┊43┊        expect(onSendMessage.mock.calls.length).toBe(1)\n+┊  ┊44┊      );\n+┊  ┊45┊    }\n+┊  ┊46┊  });\n+┊  ┊47┊});🚫↵\n```\n\n##### Changed src&#x2F;components&#x2F;ChatRoomScreen&#x2F;MessageInput.tsx\n```diff\n@@ -70,6 +70,7 @@\n ┊70┊70┊  return (\n ┊71┊71┊    <Container>\n ┊72┊72┊      <ActualInput\n+┊  ┊73┊        data-testid=\"message-input\"\n ┊73┊74┊        type=\"text\"\n ┊74┊75┊        placeholder=\"Type a message\"\n ┊75┊76┊        value={message}\n```\n```diff\n@@ -77,6 +78,7 @@\n ┊77┊78┊        onChange={onChange}\n ┊78┊79┊      />\n ┊79┊80┊      <SendButton\n+┊  ┊81┊        data-testid=\"send-button\"\n ┊80┊82┊        variant=\"contained\"\n ┊81┊83┊        color=\"primary\"\n ┊82┊84┊        onClick={submitMessage}\n```\n\n##### Added src&#x2F;components&#x2F;ChatRoomScreen&#x2F;MessagesList.test.tsx\n```diff\n@@ -0,0 +1,37 @@\n+┊  ┊ 1┊import { createMemoryHistory } from 'history';\n+┊  ┊ 2┊import React from 'react';\n+┊  ┊ 3┊import { cleanup, render, fireEvent, wait, getByTestId } from 'react-testing-library';\n+┊  ┊ 4┊import MessagesList from './MessagesList';\n+┊  ┊ 5┊\n+┊  ┊ 6┊describe('MessagesList', () => {\n+┊  ┊ 7┊  afterEach(cleanup);\n+┊  ┊ 8┊\n+┊  ┊ 9┊  it('renders messages data', () => {\n+┊  ┊10┊    const messages = [\n+┊  ┊11┊      {\n+┊  ┊12┊        id: '1',\n+┊  ┊13┊        content: 'foo',\n+┊  ┊14┊        createdAt: new Date('14 Jun 2017 00:00:00 PDT').toUTCString(),\n+┊  ┊15┊      },\n+┊  ┊16┊      {\n+┊  ┊17┊        id: '2',\n+┊  ┊18┊        content: 'bar',\n+┊  ┊19┊        createdAt: new Date('17 Jun 2017 00:01:00 PDT').toUTCString(),\n+┊  ┊20┊      },\n+┊  ┊21┊    ];\n+┊  ┊22┊\n+┊  ┊23┊    let message1, message2;\n+┊  ┊24┊    {\n+┊  ┊25┊      const { container, getAllByTestId, getByTestId } = render(<MessagesList messages={messages} />);\n+┊  ┊26┊      const match = getAllByTestId('message-item');\n+┊  ┊27┊      message1 = match[0];\n+┊  ┊28┊      message2 = match[1];\n+┊  ┊29┊    }\n+┊  ┊30┊\n+┊  ┊31┊    expect(getByTestId(message1, 'message-content')).toHaveTextContent('foo');\n+┊  ┊32┊    expect(getByTestId(message1, 'message-date')).toHaveTextContent('10:00');\n+┊  ┊33┊\n+┊  ┊34┊    expect(getByTestId(message2, 'message-content')).toHaveTextContent('bar');\n+┊  ┊35┊    expect(getByTestId(message2, 'message-date')).toHaveTextContent('10:01');\n+┊  ┊36┊  });\n+┊  ┊37┊});🚫↵\n```\n\n##### Changed src&#x2F;components&#x2F;ChatRoomScreen&#x2F;MessagesList.tsx\n```diff\n@@ -79,9 +79,9 @@\n ┊79┊79┊  return (\n ┊80┊80┊    <Container ref={selfRef}>\n ┊81┊81┊      {messages.map((message: any) => (\n-┊82┊  ┊        <MessageItem key={message.id}>\n-┊83┊  ┊          <Contents>{message.content}</Contents>\n-┊84┊  ┊          <Timestamp>{moment(message.createdAt).format('HH:mm')}</Timestamp>\n+┊  ┊82┊        <MessageItem data-testid=\"message-item\" key={message.id}>\n+┊  ┊83┊          <Contents data-testid=\"message-content\">{message.content}</Contents>\n+┊  ┊84┊          <Timestamp data-testid=\"message-date\">{moment(message.createdAt).format('HH:mm')}</Timestamp>\n ┊85┊85┊        </MessageItem>\n ┊86┊86┊      ))}\n ┊87┊87┊    </Container>\n```\n\n[}]: #\n\nThere are many things which are incomplete in the current implementation. The functionality exists in the UI, but no messages are really being sent and stored in the database. In the next chapters we will learn how to:\n\n\n\n*   Cache query results with Apollo-Client.\n*   Send messages with GraphQL mutations\n\n--------\nTODO: Add this to router chapter - https://www.pluralsight.com/guides/react-router-typescript\nAnd this - https://stackoverflow.com/questions/49342390/typescript-how-to-add-type-check-for-history-object-in-react\n\nTODO: https://medium.com/@jrwebdev/react-higher-order-component-patterns-in-typescript-42278f7590fb\n\nTODO: https://www.cypress.io/blog/2019/05/13/code-create-react-app-v3-and-its-cypress-tests-using-typescript/#\n\nTODO: Schema says there’s always an array with messages, is it really true? Is newly created chat resolves an empty array, null will throw an error?\n\nTODO: Same thing with `chats: [Chat!]!`, do we always return an array here?\n\nTODO: _root and type all resolvers\n\nTODO: How to import schema together with jest, should I changed from ts-jest?\n\nTODO: remove all that part including the file in the commit\n\nTODO: Add all the new files and changes on 6.6\n\nTODO: Add all the new files and changes on 6.7"
          },
          {
            "manualTitle": "Step 7: Caching with Apollo-Client",
            "stepRevision": "00b04bd11897e0a5c13ae50bb28a973622a78d41",
            "manualView": "In the previous step we've implemented a `ChatRoomScreen` where we were able to view each chat's messages list by clicking on a chat item from the main screen.\nIt all looks functional, however, there's a significant optimization issue - each time we navigate into a `ChatRoomScreen`,\nwe need to re-fetch the data related to the target chat.\n\nThe solution for that would be [caching](https://en.wikipedia.org/wiki/Cache_(computing)) the fetch result,\nso it can be re-used once we re-enter a screen that we've visited before.\nFor now things are fairly simple so the caching mechanism can be implemented manually,\nbut things are gonna get tougher when we add more queries or things like message sending and profile updating to the mix,\nso it's not gonna be an easy task.\n\nLuckily, in the Apollo team they've invented a solution that works right out of the box and integrates perfectly with Apollo-GraphQL server - [Apollo-GraphQL client](https://www.apollographql.com/docs/link/#apollo-client).\n\n\n![caching](https://user-images.githubusercontent.com/7648874/54871150-f505e100-4dea-11e9-9e2d-439fbf3eaebe.png)\n\n\n\nApollo-Client is a wrap around our GraphQL endpoint which essentially uses HTTP requests (and further on [web-sockets](https://en.wikipedia.org/wiki/WebSocket), but we will get there), something that we've implemented manually so far.\nNot only it can be used to fetch data, but it will also cache the result of the query so it can be seamlessly re-used when we request the same data.\nThis means that we will need to setup an Apollo-Client and replace all our `fetch()` calls with `client.query()` call.\nMore about Apollo-Client's API further in this tutorial, but let's start configuring it.\nFirst we will install few essential NPM packages:\n\n    $ yarn add apollo-client apollo-cache-inmemory apollo-link apollo-link-http\n\n\n\n*   [`apollo-client`](https://www.npmjs.com/package/apollo-client) - Apollo-Client's core package, as we explained earlier.\n*   [`apollo-cache-inmemory`](https://www.npmjs.com/package/apollo-cache-inmemory) - The data store that will be used to cache the results.\n*   [`apollo-link-http`](https://www.npmjs.com/package/apollo-link-http) - Get GraphQL results over a network using HTTP fetch.\n\nWe will create a new file in the `src` directory called `client.ts` and inside we will export the client:\n\n[{]: <helper> (diffStep 7.1 files=\"client\" module=\"client\")\n\n#### Client Step 7.1: Add Apollo client\n\n##### Added src&#x2F;client.ts\n```diff\n@@ -0,0 +1,16 @@\n+┊  ┊ 1┊import { InMemoryCache } from 'apollo-cache-inmemory';\n+┊  ┊ 2┊import { ApolloClient } from 'apollo-client';\n+┊  ┊ 3┊import { HttpLink } from 'apollo-link-http';\n+┊  ┊ 4┊\n+┊  ┊ 5┊const httpUri = process.env.REACT_APP_SERVER_URL + '/graphql';\n+┊  ┊ 6┊\n+┊  ┊ 7┊const httpLink = new HttpLink({\n+┊  ┊ 8┊  uri: httpUri,\n+┊  ┊ 9┊});\n+┊  ┊10┊\n+┊  ┊11┊const inMemoryCache = new InMemoryCache();\n+┊  ┊12┊\n+┊  ┊13┊export default new ApolloClient({\n+┊  ┊14┊  link: httpLink,\n+┊  ┊15┊  cache: inMemoryCache,\n+┊  ┊16┊});\n```\n\n[}]: #\n\nAlthough the client can be used directly and integrated into any UI framework, it would be the most comfortable to use a wrap around it which is suitable for React.\nFor that we will use a package called [`react-apollo-hooks`](https://www.npmjs.com/package/react-apollo-hooks) which includes a set of [React hooks](https://reactjs.org/docs/hooks-intro.html) that can connect between our Apollo-Client and target React.Component:\n\n    $ yarn add react-apollo-hooks graphql-tag graphql\n\nWith `react-apollo-hooks` we can use the `useQuery()` hook to fetch data from our GraphQL API.\nThe `graphql-tag` package is used to parse the GraphQL string to an [AST](https://en.wikipedia.org/wiki/Abstract_syntax_tree), something which is required when using Apollo Client. Example:\n\n\n```\nimport gql from 'graphql-tag';\nimport { useQuery } from 'react-apollo-hooks';\n\nconst GET_DOGS = gql`\n  {\n    dogs {\n      id\n      breed\n    }\n  }\n`;\n\nconst Dogs = () => {\n  const { data, error, loading } = useQuery(GET_DOGS);\n  if (loading) {\n    return <div>Loading...</div>;\n  };\n  if (error) {\n    return <div>Error! {error.message}</div>;\n  };\n\n  return (\n    <ul>\n      {data.dogs.map(dog => (\n        <li key={dog.id}>{dog.breed}</li>\n      ))}\n    </ul>\n  );\n};\n```\n\n\nThe package requires a small setup so that imported hooks can use our Apollo-Client:\n\n[{]: <helper> (diffStep 7.2 files=\"index\" module=\"client\")\n\n#### Client Step 7.2: Provide Apollo client\n\n##### Changed src&#x2F;components&#x2F;ChatRoomScreen&#x2F;index.tsx\n```diff\n@@ -75,9 +75,7 @@\n ┊75┊75┊      content,\n ┊76┊76┊    };\n ┊77┊77┊\n-┊78┊  ┊    console.log(chat.messages);\n-┊79┊  ┊\n-┊80┊  ┊     setChat({\n+┊  ┊78┊    setChat({\n ┊81┊79┊      ...chat,\n ┊82┊80┊      messages: chat.messages.concat(message),\n ┊83┊81┊    });\n```\n\n##### Changed src&#x2F;index.tsx\n```diff\n@@ -1,8 +1,10 @@\n ┊ 1┊ 1┊import { MuiThemeProvider, createMuiTheme } from '@material-ui/core/styles'\n ┊ 2┊ 2┊import React from 'react';\n ┊ 3┊ 3┊import ReactDOM from 'react-dom';\n+┊  ┊ 4┊import { ApolloProvider } from 'react-apollo-hooks';\n ┊ 4┊ 5┊import './index.css';\n ┊ 5┊ 6┊import App from './App';\n+┊  ┊ 7┊import client from './client';\n ┊ 6┊ 8┊import * as serviceWorker from './serviceWorker';\n ┊ 7┊ 9┊\n ┊ 8┊10┊const theme = createMuiTheme({\n```\n```diff\n@@ -17,7 +19,9 @@\n ┊17┊19┊\n ┊18┊20┊ReactDOM.render(\n ┊19┊21┊  <MuiThemeProvider theme={theme}>\n-┊20┊  ┊    <App />\n+┊  ┊22┊    <ApolloProvider client={client}>\n+┊  ┊23┊      <App />\n+┊  ┊24┊    </ApolloProvider>\n ┊21┊25┊  </MuiThemeProvider>\n ┊22┊26┊, document.getElementById('root'));\n```\n\n[}]: #\n\nThe code above uses the [Context/Provider](https://reactjs.org/docs/context.html) API, thus the client is now known globally.\nNow that we can use the `useQuery()` hook, there's no need to use the native Fetch API anymore.\nLet's replace all our Fetch API call instances with a React hook:\n\n[{]: <helper> (diffStep 7.3 files=\"components\" module=\"client\")\n\n#### Client Step 7.3: Replace fetch() calls with Apollo useQuery()\n\n##### Changed src&#x2F;components&#x2F;ChatRoomScreen&#x2F;index.tsx\n```diff\n@@ -1,5 +1,7 @@\n+┊ ┊1┊import gql from 'graphql-tag';\n ┊1┊2┊import React from 'react';\n-┊2┊ ┊import { useCallback, useMemo, useState } from 'react';\n+┊ ┊3┊import { useCallback } from 'react';\n+┊ ┊4┊import { useApolloClient, useQuery } from 'react-apollo-hooks';\n ┊3┊5┊import styled from 'styled-components';\n ┊4┊6┊import ChatNavbar from './ChatNavbar';\n ┊5┊7┊import MessageInput from './MessageInput';\n```\n```diff\n@@ -13,7 +15,7 @@\n ┊13┊15┊  height: 100vh;\n ┊14┊16┊`;\n ┊15┊17┊\n-┊16┊  ┊const getChatQuery = `\n+┊  ┊18┊const getChatQuery = gql`\n ┊17┊19┊  query GetChat($chatId: ID!) {\n ┊18┊20┊    chat(chatId: $chatId) {\n ┊19┊21┊      id\n```\n```diff\n@@ -47,24 +49,12 @@\n ┊47┊49┊};\n ┊48┊50┊\n ┊49┊51┊type OptionalChatQueryResult = ChatQueryResult | null;\n-┊50┊  ┊\n+┊  ┊52┊\n ┊51┊53┊const ChatRoomScreen: React.FC<ChatRoomScreenParams> = ({ history, chatId }) => {\n-┊52┊  ┊  const [chat, setChat] = useState<OptionalChatQueryResult>(null);\n-┊53┊  ┊\n-┊54┊  ┊  useMemo(async () => {\n-┊55┊  ┊    const body = await fetch(`${process.env.REACT_APP_SERVER_URL}/graphql`, {\n-┊56┊  ┊      method: 'POST',\n-┊57┊  ┊      headers: {\n-┊58┊  ┊        'Content-Type': 'application/json',\n-┊59┊  ┊      },\n-┊60┊  ┊      body: JSON.stringify({\n-┊61┊  ┊        query: getChatQuery,\n-┊62┊  ┊        variables: { chatId },\n-┊63┊  ┊      }),\n-┊64┊  ┊    });\n-┊65┊  ┊    const { data: { chat } } = await body.json();\n-┊66┊  ┊    setChat(chat);\n-┊67┊  ┊  }, [chatId]);\n+┊  ┊54┊  const client = useApolloClient();\n+┊  ┊55┊  const { data: { chat } } = useQuery<any>(getChatQuery, {\n+┊  ┊56┊    variables: { chatId }\n+┊  ┊57┊  });\n ┊68┊58┊\n ┊69┊59┊  const onSendMessage = useCallback((content: string) => {\n ┊70┊60┊    if (!chat) return null;\n```\n```diff\n@@ -73,13 +63,20 @@\n ┊73┊63┊      id: (chat.messages.length + 10).toString(),\n ┊74┊64┊      createdAt: Date.now(),\n ┊75┊65┊      content,\n+┊  ┊66┊      __typename: \"Chat\",\n ┊76┊67┊    };\n ┊77┊68┊\n-┊78┊  ┊    setChat({\n-┊79┊  ┊      ...chat,\n-┊80┊  ┊      messages: chat.messages.concat(message),\n-┊81┊  ┊    });\n-┊82┊  ┊  }, [chat]);\n+┊  ┊69┊    client.writeQuery({\n+┊  ┊70┊      query: getChatQuery,\n+┊  ┊71┊      variables: { chatId },\n+┊  ┊72┊      data: {\n+┊  ┊73┊        chat: {\n+┊  ┊74┊          ...chat,\n+┊  ┊75┊          messages: chat.messages.concat(message),\n+┊  ┊76┊        },\n+┊  ┊77┊      },\n+┊  ┊78┊    })\n+┊  ┊79┊  }, [chat, chatId, client]);\n ┊83┊80┊\n ┊84┊81┊  if (!chat) return null;\n ┊85┊82┊\n```\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;ChatsList.tsx\n```diff\n@@ -2,8 +2,10 @@\n ┊ 2┊ 2┊import moment from 'moment';\n ┊ 3┊ 3┊import { List, ListItem } from '@material-ui/core';\n ┊ 4┊ 4┊import styled from 'styled-components';\n-┊ 5┊  ┊import { useCallback, useState, useMemo } from 'react';\n+┊  ┊ 5┊import { useCallback } from 'react';\n ┊ 6┊ 6┊import { History } from 'history';\n+┊  ┊ 7┊import gql from 'graphql-tag';\n+┊  ┊ 8┊import { useQuery } from 'react-apollo-hooks';\n ┊ 7┊ 9┊\n ┊ 8┊10┊const Container = styled.div `\n ┊ 9┊11┊  height: calc(100% - 56px);\n```\n```diff\n@@ -57,7 +59,7 @@\n ┊57┊59┊  font-size: 13px;\n ┊58┊60┊`;\n ┊59┊61┊\n-┊60┊  ┊const getChatsQuery = `\n+┊  ┊62┊const getChatsQuery = gql`\n ┊61┊63┊  query GetChats {\n ┊62┊64┊    chats {\n ┊63┊65┊      id\n```\n```diff\n@@ -77,19 +79,7 @@\n ┊77┊79┊};\n ┊78┊80┊\n ┊79┊81┊const ChatsList: React.FC<ChatsListProps> = ({ history }) => {\n-┊80┊  ┊  const [chats, setChats] = useState<any[]>([]);\n-┊81┊  ┊\n-┊82┊  ┊  useMemo(async () => {\n-┊83┊  ┊    const body = await fetch(`${process.env.REACT_APP_SERVER_URL}/graphql`, {\n-┊84┊  ┊      method: 'POST',\n-┊85┊  ┊      headers: {\n-┊86┊  ┊        'Content-Type': 'application/json',\n-┊87┊  ┊      },\n-┊88┊  ┊      body: JSON.stringify({ query: getChatsQuery }),\n-┊89┊  ┊    });\n-┊90┊  ┊    const { data: { chats } } = await body.json();\n-┊91┊  ┊    setChats(chats);\n-┊92┊  ┊  }, []);\n+┊  ┊82┊  const { data: { chats = [] } } = useQuery<any>(getChatsQuery);\n ┊93┊83┊\n ┊94┊84┊  const navToChat = useCallback((chat) => {\n ┊95┊85┊    history.push(`chats/${chat.id}`)\n```\n```diff\n@@ -98,7 +88,7 @@\n ┊ 98┊ 88┊  return (\n ┊ 99┊ 89┊    <Container>\n ┊100┊ 90┊      <StyledList>\n-┊101┊   ┊        {chats.map((chat) => (\n+┊   ┊ 91┊        {chats.map((chat: any) => (\n ┊102┊ 92┊          <StyledListItem key={chat.id} data-testid=\"chat\" button onClick={navToChat.bind(null, chat)}>\n ┊103┊ 93┊            <ChatPicture data-testid=\"picture\" src={chat.picture} alt=\"Profile\"/>\n ┊104┊ 94┊            <ChatInfo>\n```\n\n[}]: #\n\nYou can see that we've fetched the query using Apollo client, and we removed the `setChat` call because Apollo will know automatically to place the results in the cache.\n\nAnd you can see we can also work directly with the cache.\n\nOn the `OnSendMessage` function we take the new message and push it to Apollo Client's cache.\n\nNow if we'll scroll to another screen and come back, the messages will still be displayed there.\n\nYou can see that we've added the `__typename` when we push a new chat to the cache.\nThat's how Apollo Client knows where to place the results.\n\nThe replacement is finished. Note that we removed the usage of `useMemo()` - because Apollo has an internal cache mechanism, there's no need to memoize the result anymore.\nWe also used the [`writeQuery()`](https://www.apollographql.com/docs/react/features/caching.html#writequery-and-writefragment) method to edit the stored result in the cache, so in the next render phase we would have an updated chat with the newly added message.\n\nWe shouldn't see any change at all in the view and the response time, since we're running it locally, but if we will take a look at the `network` tab in the browser's dev-tools we should notice the differences:\n\n**before**\n\n![fetch](https://user-images.githubusercontent.com/7648874/54871305-e5879780-4dec-11e9-87bb-3279e9e18342.png)\n\n**after**\n\n![apollo](https://user-images.githubusercontent.com/7648874/54871319-1bc51700-4ded-11e9-9001-d5518bedf9ad.png)\n\n> Above: ChatsListScreen -> ChatRoomScreen -> ChatsListScreen -> ChatRoomScreen\n\nThis test is obviously very rough, but the deviation is so big that you don't need any accuracy to emphasize the difference.\nThe blue stripes represents the requests made and the time they took. Before we had about 6 request phases, while after we had only 3 of them.\n\nSince we don't use the Fetch API anymore, we will also need to update our tests.\nRight now we mock the response from the fetch API, but a more appropriate way would be creating a fake Apollo Client where we will be able to mock the results.\nFor that we will install a package called [`apollo-link-mock`](https://www.npmjs.com/package/apollo-link-mock):\n\n    $ yarn add --dev apollo-link-mock\n\nAnd we will create a `test-helpers.ts` file under the `src` directory that will contain the utility function for creating a fake Apollo Client:\n\n[{]: <helper> (diffStep 7.4 files=\"test-helpers\" module=\"client\")\n\n#### Client Step 7.4: Mock Apollo requests in tests\n\n##### Added src&#x2F;test-helpers.ts\n```diff\n@@ -0,0 +1,10 @@\n+┊  ┊ 1┊import { InMemoryCache } from 'apollo-cache-inmemory';\n+┊  ┊ 2┊import { ApolloClient } from 'apollo-client';\n+┊  ┊ 3┊import { MockLink } from 'apollo-link-mock';\n+┊  ┊ 4┊\n+┊  ┊ 5┊export const mockApolloClient = (mocks: any) => {\n+┊  ┊ 6┊  return new ApolloClient({\n+┊  ┊ 7┊    cache: new InMemoryCache(),\n+┊  ┊ 8┊    link: new MockLink(mocks),\n+┊  ┊ 9┊  });\n+┊  ┊10┊};\n```\n\n[}]: #\n\nThe fake client accepts an array of mocks where each mock object will have a `request` key that will contain details about the request and a `result` key which will contain the mocked result.\nYou should get a better understanding of how it works now that we will replace the fake Fetch calls with fake Apollo Clients:\n\n[{]: <helper> (diffStep 7.4 files=\"src/components\" module=\"client\")\n\n#### Client Step 7.4: Mock Apollo requests in tests\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;ChatsList.test.tsx\n```diff\n@@ -1,8 +1,10 @@\n ┊ 1┊ 1┊import React from 'react';\n+┊  ┊ 2┊import { ApolloProvider } from 'react-apollo-hooks';\n ┊ 2┊ 3┊import ReactDOM from 'react-dom';\n ┊ 3┊ 4┊import { cleanup, render, fireEvent, wait, waitForDomChange } from 'react-testing-library';\n-┊ 4┊  ┊import ChatsList from './ChatsList';\n ┊ 5┊ 5┊import { createBrowserHistory } from 'history';\n+┊  ┊ 6┊import { mockApolloClient } from '../../test-helpers';\n+┊  ┊ 7┊import ChatsList, { getChatsQuery } from './ChatsList';\n ┊ 6┊ 8┊\n ┊ 7┊ 9┊describe('ChatsList', () => {\n ┊ 8┊10┊  afterEach(() => {\n```\n```diff\n@@ -11,25 +13,36 @@\n ┊11┊13┊  });\n ┊12┊14┊\n ┊13┊15┊  it('renders fetched chats data', async () => {\n-┊14┊  ┊    fetch.mockResponseOnce(JSON.stringify({\n-┊15┊  ┊      data: {\n-┊16┊  ┊        chats: [\n-┊17┊  ┊          {\n-┊18┊  ┊            id: 1,\n-┊19┊  ┊            name: 'Foo Bar',\n-┊20┊  ┊            picture: 'https://localhost:4000/picture.jpg',\n-┊21┊  ┊            lastMessage: {\n-┊22┊  ┊              id: 1,\n-┊23┊  ┊              content: 'Hello',\n-┊24┊  ┊              createdAt: new Date('14 Jun 2017 00:00:00 PDT').toUTCString(),\n-┊25┊  ┊            },\n+┊  ┊16┊    const client = mockApolloClient([\n+┊  ┊17┊      {\n+┊  ┊18┊        request: { query: getChatsQuery },\n+┊  ┊19┊        result: {\n+┊  ┊20┊          data: {\n+┊  ┊21┊            chats: [\n+┊  ┊22┊              {\n+┊  ┊23┊                __typename: 'Chat',\n+┊  ┊24┊                id: 1,\n+┊  ┊25┊                name: 'Foo Bar',\n+┊  ┊26┊                picture: 'https://localhost:4000/picture.jpg',\n+┊  ┊27┊                lastMessage: {\n+┊  ┊28┊                  __typename: 'Message',\n+┊  ┊29┊                  id: 1,\n+┊  ┊30┊                  content: 'Hello',\n+┊  ┊31┊                  createdAt: new Date('14 Jun 2017 00:00:00 PDT').toUTCString(),\n+┊  ┊32┊                },\n+┊  ┊33┊              },\n+┊  ┊34┊            ],\n ┊26┊35┊          },\n-┊27┊  ┊        ],\n+┊  ┊36┊        },\n ┊28┊37┊      },\n-┊29┊  ┊    }));\n+┊  ┊38┊    ]);\n ┊30┊39┊\n ┊31┊40┊    {\n-┊32┊  ┊      const { container, getByTestId } = render(<ChatsList />);\n+┊  ┊41┊      const { container, getByTestId } = render(\n+┊  ┊42┊        <ApolloProvider client={client}>\n+┊  ┊43┊          <ChatsList />\n+┊  ┊44┊        </ApolloProvider>\n+┊  ┊45┊      );\n ┊33┊46┊\n ┊34┊47┊      await waitForDomChange({ container });\n ┊35┊48┊\n```\n```diff\n@@ -41,27 +54,38 @@\n ┊41┊54┊  });\n ┊42┊55┊\n ┊43┊56┊  it('should navigate to the target chat room on chat item click', async () => {\n-┊44┊  ┊    fetch.mockResponseOnce(JSON.stringify({\n-┊45┊  ┊      data: {\n-┊46┊  ┊        chats: [\n-┊47┊  ┊          {\n-┊48┊  ┊            id: 1,\n-┊49┊  ┊            name: 'Foo Bar',\n-┊50┊  ┊            picture: 'https://localhost:4000/picture.jpg',\n-┊51┊  ┊            lastMessage: {\n-┊52┊  ┊              id: 1,\n-┊53┊  ┊              content: 'Hello',\n-┊54┊  ┊              createdAt: new Date(0),\n-┊55┊  ┊            },\n+┊  ┊57┊    const client = mockApolloClient([\n+┊  ┊58┊      {\n+┊  ┊59┊        request: { query: getChatsQuery },\n+┊  ┊60┊        result: {\n+┊  ┊61┊          data: {\n+┊  ┊62┊            chats: [\n+┊  ┊63┊              {\n+┊  ┊64┊                __typename: 'Chat',\n+┊  ┊65┊                id: 1,\n+┊  ┊66┊                name: 'Foo Bar',\n+┊  ┊67┊                picture: 'https://localhost:4000/picture.jpg',\n+┊  ┊68┊                lastMessage: {\n+┊  ┊69┊                  __typename: 'Message',\n+┊  ┊70┊                  id: 1,\n+┊  ┊71┊                  content: 'Hello',\n+┊  ┊72┊                  createdAt: new Date(0),\n+┊  ┊73┊                },\n+┊  ┊74┊              },\n+┊  ┊75┊            ],\n ┊56┊76┊          },\n-┊57┊  ┊        ],\n+┊  ┊77┊        },\n ┊58┊78┊      },\n-┊59┊  ┊    }));\n+┊  ┊79┊    ]);\n ┊60┊80┊\n ┊61┊81┊     const history = createBrowserHistory();\n ┊62┊82┊\n-┊63┊  ┊     {\n-┊64┊  ┊      const { container, getByTestId } = render(<ChatsList history={history} />);\n+┊  ┊83┊    {\n+┊  ┊84┊      const { container, getByTestId } = render(\n+┊  ┊85┊        <ApolloProvider client={client}>\n+┊  ┊86┊          <ChatsList history={history} />\n+┊  ┊87┊        </ApolloProvider>\n+┊  ┊88┊      );\n ┊65┊89┊\n ┊66┊90┊       await waitForDomChange({ container });\n ┊67┊91┊\n```\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;ChatsList.tsx\n```diff\n@@ -59,7 +59,7 @@\n ┊59┊59┊  font-size: 13px;\n ┊60┊60┊`;\n ┊61┊61┊\n-┊62┊  ┊const getChatsQuery = gql`\n+┊  ┊62┊export const getChatsQuery = gql`\n ┊63┊63┊  query GetChats {\n ┊64┊64┊    chats {\n ┊65┊65┊      id\n```\n\n[}]: #\n\nWe are telling Apollo mock to give a certain result each time it gets a specific query.\n\nNote how we used the `ApolloProvider` component to provide the target component with the fake Apollo Client.\nLike so, any other component which uses Apollo Client should be wrapped with an ApolloProvider when rendering it, otherwise it will not function as intended:\n\n[{]: <helper> (diffStep 7.4 files=\"src/App\" module=\"client\")\n\n#### Client Step 7.4: Mock Apollo requests in tests\n\n##### Changed src&#x2F;App.test.tsx\n```diff\n@@ -1,9 +1,17 @@\n ┊ 1┊ 1┊import React from 'react';\n+┊  ┊ 2┊import { ApolloProvider } from 'react-apollo-hooks';\n ┊ 2┊ 3┊import ReactDOM from 'react-dom';\n ┊ 3┊ 4┊import App from './App';\n+┊  ┊ 5┊import { mockApolloClient } from './test-helpers';\n ┊ 4┊ 6┊\n ┊ 5┊ 7┊it('renders without crashing', () => {\n+┊  ┊ 8┊  const client = mockApolloClient();\n ┊ 6┊ 9┊  const div = document.createElement('div');\n-┊ 7┊  ┊  ReactDOM.render(<App />, div);\n+┊  ┊10┊\n+┊  ┊11┊  ReactDOM.render(\n+┊  ┊12┊    <ApolloProvider client={client}>\n+┊  ┊13┊      <App />\n+┊  ┊14┊    </ApolloProvider>\n+┊  ┊15┊  , div);\n ┊ 8┊16┊  ReactDOM.unmountComponentAtNode(div);\n ┊ 9┊17┊});\n```\n\n[}]: #\n\nThat's it for this chapter. There's one thing missing to make our `ChatRoomScreen` functional and that would be actually sending a message to the backend and updating the DB. In the next chapter we will learn how to do exactly that with our new Apollo-Client.\n\n\n--------------------\n\nTODO: Change the whole intro.\n\nTODO: I think we might want to explain the cache in more details\nhow it’s normalized\nhow some parts update automatically and some do not\nwhat’s the smallest unit stored in the cache\nand other stuff\nthis might help later on with optimistic responses and mutations in general\n\nTODO: Remove all label code\n\nTODO: Create a drawing of the cache.\nTODO: Change typename from Chat to Message\n\nTODO: Explain a bit about Apollo links."
          },
          {
            "manualTitle": "Step 8: Sending messages with GraphQL mutations",
            "stepRevision": "512e9ff8b40162a08642c8d4a888429f7e24ecf1",
            "manualView": "The view and the functionality for updating the component's state when sending a message already exists.\nThe thing is that messages are not really being sent, we only update the memory in the client.\n\nIf so, how exactly can we send messages and store them in the DB? For this purpose we're gonna learn about GraphQL mutations -\na method for sending and applying mutations in our back-end.\n\n**What are GraphQL mutations?**\n\nIf you have an API endpoint that alters data, like inserting data into a database or altering data already in a database,\nyou should make this endpoint a `Mutation` rather than a `Query`.\nThis is as simple as making the API endpoint part of the top-level `Mutation` type instead of the top-level `Query` type.\n\nIt's often convenient to have a mutation that maps to a database create or update operation, return the same thing that the server stored.\nThat way, if you modify the data on the server, the client can learn about those modifications.\n**A GraphQL mutation is like a GraphQL query, only with side effects**.\nIt's equivalent to GET (query) and POST/PUT (mutation) in the context of REST API.\n\nBelow is a sample GraphQL mutation request:\n\n```graphql\nmutation AddMessage($chatId: ID!) {\n  addMessage(chatId: $chatId) {\n    id\n    contents\n    createdAt\n  }\n}\n```\n\n**How to implement a GraphQL mutation?**\n\nSince GraphQL is schema based, we will need to create a new type called `Mutation` in the `typeDefs.graphql` file.\nIn this chapter we want to have the ability to send messages, thus we will have a field named `addMessage` in the new mutation type:\n\n[{]: <helper> (diffStep 5.1 files=\"typeDefs\" module=\"server\")\n\n#### [Server Step 5.1: Add addMessage() mutation](https://github.com/Urigo/WhatsApp-Clone-Server/commit/5b54877)\n\n##### Changed schema&#x2F;typeDefs.graphql\n```diff\n@@ -18,3 +18,7 @@\n ┊18┊18┊  chats: [Chat!]!\n ┊19┊19┊  chat(chatId: ID!): Chat\n ┊20┊20┊}\n+┊  ┊21┊\n+┊  ┊22┊type Mutation {\n+┊  ┊23┊  addMessage(chatId: ID!, content: String!): Message\n+┊  ┊24┊}\n```\n\n[}]: #\n\nNote that our mutation resolver `addMessage` receives a `chatId`. This is because when adding a message, we should update both the messages collection, and the correlated chat document. Mutations are resolved exactly like any other type in our resolvers manifest. The new resolver should look like this:\n\n[{]: <helper> (diffStep 5.1 files=\"resolvers\" module=\"server\")\n\n#### [Server Step 5.1: Add addMessage() mutation](https://github.com/Urigo/WhatsApp-Clone-Server/commit/5b54877)\n\n##### Changed schema&#x2F;resolvers.ts\n```diff\n@@ -25,6 +25,31 @@\n ┊25┊25┊      return chats.find(c => c.id === chatId)\n ┊26┊26┊    },\n ┊27┊27┊  },\n+┊  ┊28┊\n+┊  ┊29┊  Mutation: {\n+┊  ┊30┊    addMessage(root: any, { chatId, content }: any) {\n+┊  ┊31┊      const chatIndex = chats.findIndex(c => c.id === chatId)\n+┊  ┊32┊\n+┊  ┊33┊      if (chatIndex === -1) return null\n+┊  ┊34┊\n+┊  ┊35┊      const chat = chats[chatIndex]\n+┊  ┊36┊      const lastMessageId = chat.messages[chat.messages.length - 1]\n+┊  ┊37┊      const messageId = String(Number(lastMessageId) + 1)\n+┊  ┊38┊      const message = {\n+┊  ┊39┊        id: messageId,\n+┊  ┊40┊        createdAt: new Date(),\n+┊  ┊41┊        content,\n+┊  ┊42┊      }\n+┊  ┊43┊\n+┊  ┊44┊      messages.push(message)\n+┊  ┊45┊      chat.messages.push(messageId)\n+┊  ┊46┊      // The chat will appear at the top of the ChatsList component\n+┊  ┊47┊      chats.splice(chatIndex, 1)\n+┊  ┊48┊      chats.unshift(chat)\n+┊  ┊49┊\n+┊  ┊50┊      return message\n+┊  ┊51┊    }\n+┊  ┊52┊  }\n ┊28┊53┊}\n ┊29┊54┊\n ┊30┊55┊export default resolvers\n```\n\n[}]: #\n\nIn terms of testing, we will use a temporary solution for now to reset the DB each time we test a mutation. Since we make a modification in the DB, we need to make sure that each test is completely agnostic and doesn't affect one another, thus, we will export a `resetDB()` method from our `db.ts` module:\n\n[{]: <helper> (diffStep 5.2 files=\"db.ts\" module=\"server\")\n\n#### [Server Step 5.2: Test addMessage() mutation](https://github.com/Urigo/WhatsApp-Clone-Server/commit/78b7349)\n\n##### Changed db.ts\n```diff\n@@ -1,49 +1,69 @@\n-┊ 1┊  ┊export const messages = [\n-┊ 2┊  ┊  {\n-┊ 3┊  ┊    id: '1',\n-┊ 4┊  ┊    content: \"You on your way?\",\n-┊ 5┊  ┊    createdAt: new Date(new Date('1-1-2019').getTime() - 60 * 1000 * 1000),\n-┊ 6┊  ┊  },\n-┊ 7┊  ┊  {\n-┊ 8┊  ┊    id: '2',\n-┊ 9┊  ┊    content: \"Hey, it's me\",\n-┊10┊  ┊    createdAt: new Date(new Date('1-1-2019').getTime() - 2 * 60 * 1000 * 1000),\n-┊11┊  ┊  },\n-┊12┊  ┊  {\n-┊13┊  ┊    id: '3',\n-┊14┊  ┊    content: \"I should buy a boat\",\n-┊15┊  ┊    createdAt: new Date(new Date('1-1-2019').getTime() - 24 * 60 * 1000 * 1000),\n-┊16┊  ┊  },\n-┊17┊  ┊  {\n-┊18┊  ┊    id: '4',\n-┊19┊  ┊    content: \"This is wicked good ice cream.\",\n-┊20┊  ┊    createdAt: new Date(new Date('1-1-2019').getTime() - 14 * 24 * 60 * 1000 * 1000),\n-┊21┊  ┊  },\n-┊22┊  ┊]\n+┊  ┊ 1┊export type Message = {\n+┊  ┊ 2┊  id: string\n+┊  ┊ 3┊  content: string\n+┊  ┊ 4┊  createdAt: Date\n+┊  ┊ 5┊}\n ┊23┊ 6┊\n-┊24┊  ┊export const chats = [\n-┊25┊  ┊  {\n-┊26┊  ┊    id: '1',\n-┊27┊  ┊    name: 'Ethan Gonzalez',\n-┊28┊  ┊    picture: 'https://randomuser.me/api/portraits/thumb/men/1.jpg',\n-┊29┊  ┊    messages: ['1'],\n-┊30┊  ┊  },\n-┊31┊  ┊  {\n-┊32┊  ┊    id: '2',\n-┊33┊  ┊    name: 'Bryan Wallace',\n-┊34┊  ┊    picture: 'https://randomuser.me/api/portraits/thumb/men/2.jpg',\n-┊35┊  ┊    messages: ['2'],\n-┊36┊  ┊  },\n-┊37┊  ┊  {\n-┊38┊  ┊    id: '3',\n-┊39┊  ┊    name: 'Avery Stewart',\n-┊40┊  ┊    picture: 'https://randomuser.me/api/portraits/thumb/women/1.jpg',\n-┊41┊  ┊    messages: ['3'],\n-┊42┊  ┊  },\n-┊43┊  ┊  {\n-┊44┊  ┊    id: '4',\n-┊45┊  ┊    name: 'Katie Peterson',\n-┊46┊  ┊    picture: 'https://randomuser.me/api/portraits/thumb/women/2.jpg',\n-┊47┊  ┊    messages: ['4'],\n-┊48┊  ┊  },\n-┊49┊  ┊]\n+┊  ┊ 7┊export type Chat = {\n+┊  ┊ 8┊  id: string\n+┊  ┊ 9┊  name: string\n+┊  ┊10┊  picture: string\n+┊  ┊11┊  messages: string[]\n+┊  ┊12┊}\n+┊  ┊13┊\n+┊  ┊14┊export const messages: Message[] = []\n+┊  ┊15┊export const chats: Chat[] = []\n+┊  ┊16┊\n+┊  ┊17┊export const resetDb = () => {\n+┊  ┊18┊  messages.splice(0, Infinity, ...[\n+┊  ┊19┊    {\n+┊  ┊20┊      id: '1',\n+┊  ┊21┊      content: \"You on your way?\",\n+┊  ┊22┊      createdAt: new Date(new Date('1-1-2019').getTime() - 60 * 1000 * 1000),\n+┊  ┊23┊    },\n+┊  ┊24┊    {\n+┊  ┊25┊      id: '2',\n+┊  ┊26┊      content: \"Hey, it's me\",\n+┊  ┊27┊      createdAt: new Date(new Date('1-1-2019').getTime() - 2 * 60 * 1000 * 1000),\n+┊  ┊28┊    },\n+┊  ┊29┊    {\n+┊  ┊30┊      id: '3',\n+┊  ┊31┊      content: \"I should buy a boat\",\n+┊  ┊32┊      createdAt: new Date(new Date('1-1-2019').getTime() - 24 * 60 * 1000 * 1000),\n+┊  ┊33┊    },\n+┊  ┊34┊    {\n+┊  ┊35┊      id: '4',\n+┊  ┊36┊      content: \"This is wicked good ice cream.\",\n+┊  ┊37┊      createdAt: new Date(new Date('1-1-2019').getTime() - 14 * 24 * 60 * 1000 * 1000),\n+┊  ┊38┊    },\n+┊  ┊39┊  ])\n+┊  ┊40┊\n+┊  ┊41┊  chats.splice(0, Infinity, ...[\n+┊  ┊42┊    {\n+┊  ┊43┊      id: '1',\n+┊  ┊44┊      name: 'Ethan Gonzalez',\n+┊  ┊45┊      picture: 'https://randomuser.me/api/portraits/thumb/men/1.jpg',\n+┊  ┊46┊      messages: ['1'],\n+┊  ┊47┊    },\n+┊  ┊48┊    {\n+┊  ┊49┊      id: '2',\n+┊  ┊50┊      name: 'Bryan Wallace',\n+┊  ┊51┊      picture: 'https://randomuser.me/api/portraits/thumb/men/2.jpg',\n+┊  ┊52┊      messages: ['2'],\n+┊  ┊53┊    },\n+┊  ┊54┊    {\n+┊  ┊55┊      id: '3',\n+┊  ┊56┊      name: 'Avery Stewart',\n+┊  ┊57┊      picture: 'https://randomuser.me/api/portraits/thumb/women/1.jpg',\n+┊  ┊58┊      messages: ['3'],\n+┊  ┊59┊    },\n+┊  ┊60┊    {\n+┊  ┊61┊      id: '4',\n+┊  ┊62┊      name: 'Katie Peterson',\n+┊  ┊63┊      picture: 'https://randomuser.me/api/portraits/thumb/women/2.jpg',\n+┊  ┊64┊      messages: ['4'],\n+┊  ┊65┊    },\n+┊  ┊66┊  ])\n+┊  ┊67┊}\n+┊  ┊68┊\n+┊  ┊69┊resetDb()\n```\n\n[}]: #\n\nAnd we will use the `beforeEach()` test hook to reset the `chats` and `messages` collections:\n\n[{]: <helper> (diffStep 5.2 files=\"tests\" module=\"server\")\n\n#### [Server Step 5.2: Test addMessage() mutation](https://github.com/Urigo/WhatsApp-Clone-Server/commit/78b7349)\n\n##### Added tests&#x2F;mutations&#x2F;\\__snapshots__&#x2F;addMessage.test.ts.snap\n```diff\n@@ -0,0 +1,22 @@\n+┊  ┊ 1┊// Jest Snapshot v1, https://goo.gl/fbAQLP\n+┊  ┊ 2┊\n+┊  ┊ 3┊exports[`Mutation.addMessage should add message to specified chat 1`] = `\n+┊  ┊ 4┊Object {\n+┊  ┊ 5┊  \"addMessage\": Object {\n+┊  ┊ 6┊    \"content\": \"Hello World\",\n+┊  ┊ 7┊    \"id\": \"5\",\n+┊  ┊ 8┊  },\n+┊  ┊ 9┊}\n+┊  ┊10┊`;\n+┊  ┊11┊\n+┊  ┊12┊exports[`Mutation.addMessage should add message to specified chat 2`] = `\n+┊  ┊13┊Object {\n+┊  ┊14┊  \"chat\": Object {\n+┊  ┊15┊    \"id\": \"1\",\n+┊  ┊16┊    \"lastMessage\": Object {\n+┊  ┊17┊      \"content\": \"Hello World\",\n+┊  ┊18┊      \"id\": \"5\",\n+┊  ┊19┊    },\n+┊  ┊20┊  },\n+┊  ┊21┊}\n+┊  ┊22┊`;\n```\n\n##### Added tests&#x2F;mutations&#x2F;addMessage.test.ts\n```diff\n@@ -0,0 +1,49 @@\n+┊  ┊ 1┊import { createTestClient } from 'apollo-server-testing'\n+┊  ┊ 2┊import { ApolloServer, gql } from 'apollo-server-express'\n+┊  ┊ 3┊import schema from '../../schema'\n+┊  ┊ 4┊import { resetDb } from '../../db'\n+┊  ┊ 5┊\n+┊  ┊ 6┊describe('Mutation.addMessage', () => {\n+┊  ┊ 7┊  beforeEach(resetDb)\n+┊  ┊ 8┊\n+┊  ┊ 9┊  it('should add message to specified chat', async () => {\n+┊  ┊10┊    const server = new ApolloServer({ schema })\n+┊  ┊11┊\n+┊  ┊12┊    const { query, mutate } = createTestClient(server)\n+┊  ┊13┊\n+┊  ┊14┊    const addMessageRes = await mutate({\n+┊  ┊15┊      variables: { chatId: '1', content: 'Hello World' },\n+┊  ┊16┊      mutation: gql `\n+┊  ┊17┊        mutation AddMessage($chatId: ID!, $content: String!) {\n+┊  ┊18┊          addMessage(chatId: $chatId, content: $content) {\n+┊  ┊19┊            id\n+┊  ┊20┊            content\n+┊  ┊21┊          }\n+┊  ┊22┊        }\n+┊  ┊23┊      `,\n+┊  ┊24┊    })\n+┊  ┊25┊\n+┊  ┊26┊    expect(addMessageRes.data).toBeDefined()\n+┊  ┊27┊    expect(addMessageRes.errors).toBeUndefined()\n+┊  ┊28┊    expect(addMessageRes.data).toMatchSnapshot()\n+┊  ┊29┊\n+┊  ┊30┊    const getChatRes = await query({\n+┊  ┊31┊      variables: { chatId: '1' },\n+┊  ┊32┊      query: gql `\n+┊  ┊33┊        query GetChat($chatId: ID!) {\n+┊  ┊34┊          chat(chatId: $chatId) {\n+┊  ┊35┊            id\n+┊  ┊36┊            lastMessage {\n+┊  ┊37┊              id\n+┊  ┊38┊              content\n+┊  ┊39┊            }\n+┊  ┊40┊          }\n+┊  ┊41┊        }\n+┊  ┊42┊      `,\n+┊  ┊43┊    })\n+┊  ┊44┊\n+┊  ┊45┊    expect(getChatRes.data).toBeDefined()\n+┊  ┊46┊    expect(getChatRes.errors).toBeUndefined()\n+┊  ┊47┊    expect(getChatRes.data).toMatchSnapshot()\n+┊  ┊48┊  })\n+┊  ┊49┊})\n```\n\n[}]: #\n\nNow we have the infrastructure set for sending a new message and we can start using it in our client.\n\n**How to use a GraphQL mutation?**\n\nLike in the previous chapters, we're gonna use a React hook so we can run a mutation more efficiently in a React.Component.\nFor this we're gonna use the [`useMutation()`](https://github.com/trojanowski/react-apollo-hooks#usemutation) react hook.\nThe first argument of the hook is the mutation string, and the second one is the [mutation options](https://www.apollographql.com/docs/react/api/apollo-client.html#ApolloClient.mutate).\nWe're gonna provide our mutation call with a single option called `optimisticResponse`.\n\nOptimistic response is a common pattern that will update the state of the component twice so we can have a better UX: First it updates the component's state with the predicted result,\nand then it will update the state with the actual result.\n\n\n\n![optimistic_response](https://user-images.githubusercontent.com/7648874/54883302-859df900-4e9f-11e9-9eb7-a98108cd2482.png)\n\n\nThis is how the component should look like:\n\n[{]: <helper> (diffStep 8.1 module=\"client\")\n\n#### Client Step 8.1: Send message with a GraphQL mutation\n\n##### Changed src&#x2F;components&#x2F;ChatRoomScreen&#x2F;index.tsx\n```diff\n@@ -1,7 +1,7 @@\n ┊1┊1┊import gql from 'graphql-tag';\n ┊2┊2┊import React from 'react';\n ┊3┊3┊import { useCallback } from 'react';\n-┊4┊ ┊import { useApolloClient, useQuery } from 'react-apollo-hooks';\n+┊ ┊4┊import { useQuery, useMutation } from 'react-apollo-hooks';\n ┊5┊5┊import styled from 'styled-components';\n ┊6┊6┊import ChatNavbar from './ChatNavbar';\n ┊7┊7┊import MessageInput from './MessageInput';\n```\n```diff\n@@ -30,6 +30,16 @@\n ┊30┊30┊  }\n ┊31┊31┊`;\n ┊32┊32┊\n+┊  ┊33┊const addMessageMutation = gql `\n+┊  ┊34┊  mutation AddMessage($chatId: ID!, $content: String!) {\n+┊  ┊35┊    addMessage(chatId: $chatId, content: $content) {\n+┊  ┊36┊      id\n+┊  ┊37┊      content\n+┊  ┊38┊      createdAt\n+┊  ┊39┊    }\n+┊  ┊40┊  }\n+┊  ┊41┊`;\n+┊  ┊42┊\n ┊33┊43┊interface ChatRoomScreenParams {\n ┊34┊44┊  chatId: string\n ┊35┊45┊  history: History;\n```\n```diff\n@@ -51,32 +61,37 @@\n ┊51┊61┊type OptionalChatQueryResult = ChatQueryResult | null;\n ┊52┊62┊\n ┊53┊63┊const ChatRoomScreen: React.FC<ChatRoomScreenParams> = ({ history, chatId }) => {\n-┊54┊  ┊  const client = useApolloClient();\n ┊55┊64┊  const { data: { chat } } = useQuery<any>(getChatQuery, {\n ┊56┊65┊    variables: { chatId }\n ┊57┊66┊  });\n+┊  ┊67┊  const addMessage = useMutation(addMessageMutation);\n ┊58┊68┊\n ┊59┊69┊  const onSendMessage = useCallback((content: string) => {\n-┊60┊  ┊    if (!chat) return null;\n-┊61┊  ┊\n-┊62┊  ┊    const message = {\n-┊63┊  ┊      id: (chat.messages.length + 10).toString(),\n-┊64┊  ┊      createdAt: Date.now(),\n-┊65┊  ┊      content,\n-┊66┊  ┊      __typename: \"Chat\",\n-┊67┊  ┊    };\n-┊68┊  ┊\n-┊69┊  ┊    client.writeQuery({\n-┊70┊  ┊      query: getChatQuery,\n-┊71┊  ┊      variables: { chatId },\n-┊72┊  ┊      data: {\n-┊73┊  ┊        chat: {\n-┊74┊  ┊          ...chat,\n-┊75┊  ┊          messages: chat.messages.concat(message),\n-┊76┊  ┊        },\n+┊  ┊70┊    addMessage({\n+┊  ┊71┊      variables: { chatId, content },\n+┊  ┊72┊      optimisticResponse: {\n+┊  ┊73┊        __typename: 'Mutation',\n+┊  ┊74┊        addMessage: {\n+┊  ┊75┊          __typename: 'Message',\n+┊  ┊76┊          id: Math.random().toString(36).substr(2, 9),\n+┊  ┊77┊          createdAt: new Date(),\n+┊  ┊78┊          content,\n+┊  ┊79┊        }\n ┊77┊80┊      },\n-┊78┊  ┊    })\n-┊79┊  ┊  }, [chat, chatId, client]);\n+┊  ┊81┊      update: (client, { data: { addMessage } }) => {\n+┊  ┊82┊        client.writeQuery({\n+┊  ┊83┊          query: getChatQuery,\n+┊  ┊84┊          variables: { chatId },\n+┊  ┊85┊          data: {\n+┊  ┊86┊            chat: {\n+┊  ┊87┊              ...chat,\n+┊  ┊88┊              messages: chat.messages.concat(addMessage)\n+┊  ┊89┊            }\n+┊  ┊90┊          }\n+┊  ┊91┊        });\n+┊  ┊92┊      }\n+┊  ┊93┊    });\n+┊  ┊94┊  }, [chat, chatId, addMessage]);\n ┊80┊95┊\n ┊81┊96┊  if (!chat) return null;\n```\n\n[}]: #\n\nNote that unlike `useQuery()`, `useMutation()` returns a callback that will run the mutation only once called, NOT immediately.\nSeemingly, everything works fine, but if you'll try to navigate from `ChatsListScreen` to `ChatRoomScreen`, send a message, and then go back, you'll see that the last message was not updated.\nSo why is that exactly?\n\n**Cache updating**\n\nAs explained in the previous chapter, Apollo-Client will cache all the results in a data-store.\nLater on, rather than re-fetching the data, it will look up for the result in the store and will serve it to you in case it exists.\nThat means, that even though we ran the mutation and updated the data on the server, our data-store is still left behind and it needs to be updated as well,\notherwise Apollo-Client will see nothing wrong with the outcome.\n\nApollo-Client stores the data in a hash, where the key represents the query and the value represents the retrieved result.\nThis means that the cache will need to be updated for:\n\n\n*   `chats` query - which we already did, without really diving into the reason behind it.\n*   `chat(chatId: $chatId)` where `chatId` is the chat that was just mutated.\n\nIndeed, a query will be duplicated for each and every distinct set of parameters.\nSo potentially our data-store can grow infinite amount of times, and we will need to take care of it and manage it correctly, so things won't get out of hand.\n\nTo update a query, we will first export the `getChats` query to a separate file so it can be imported in the `ChatRoomScreen`.\nWe will define all our GraphQL assets under the `src/graphql` directory:\n\n[{]: <helper> (diffStep 8.2 files=\"graphql\" module=\"client\")\n\n#### Client Step 8.2: Rewrite lastMessage to chats query\n\n##### Added src&#x2F;graphql&#x2F;queries&#x2F;chats.query.ts\n```diff\n@@ -0,0 +1,16 @@\n+┊  ┊ 1┊import gql from 'graphql-tag';\n+┊  ┊ 2┊\n+┊  ┊ 3┊export default gql`\n+┊  ┊ 4┊  query Chats {\n+┊  ┊ 5┊    chats {\n+┊  ┊ 6┊      id\n+┊  ┊ 7┊      name\n+┊  ┊ 8┊      picture\n+┊  ┊ 9┊      lastMessage {\n+┊  ┊10┊        id\n+┊  ┊11┊        content\n+┊  ┊12┊        createdAt\n+┊  ┊13┊      }\n+┊  ┊14┊    }\n+┊  ┊15┊  }\n+┊  ┊16┊`;\n```\n\n##### Added src&#x2F;graphql&#x2F;queries&#x2F;index.ts\n```diff\n@@ -0,0 +1 @@\n+┊ ┊1┊export { default as chats } from './chats.query';\n```\n\n[}]: #\n\nAnd then we will read the memoized result from the store using [`client.readQuery`](https://www.apollographql.com/docs/react/features/caching.html#readquery),\nupdate it, and then rewrite it using [`client.writeQuery`](https://www.apollographql.com/docs/react/features/caching.html#writequery-and-writefragment).\nWe can gain access to the client object via the `update` callback which will be triggered right after the mutation has been successfully executed.\nThis is how it should look like:\n\n[{]: <helper> (diffStep 8.2 files=\"components\" module=\"client\")\n\n#### Client Step 8.2: Rewrite lastMessage to chats query\n\n##### Changed src&#x2F;components&#x2F;ChatRoomScreen&#x2F;index.tsx\n```diff\n@@ -7,6 +7,7 @@\n ┊ 7┊ 7┊import MessageInput from './MessageInput';\n ┊ 8┊ 8┊import MessagesList from './MessagesList';\n ┊ 9┊ 9┊import { History } from 'history';\n+┊  ┊10┊import * as queries from '../../graphql/queries';\n ┊10┊11┊\n ┊11┊12┊ const Container = styled.div `\n ┊12┊13┊  background: url(/assets/chat-background.jpg);\n```\n```diff\n@@ -26,8 +27,8 @@\n ┊26┊27┊        content\n ┊27┊28┊        createdAt\n ┊28┊29┊      }\n-┊29┊  ┊    }\n ┊30┊30┊  }\n+┊  ┊31┊}\n ┊31┊32┊`;\n ┊32┊33┊\n ┊33┊34┊const addMessageMutation = gql `\n```\n```diff\n@@ -60,6 +61,10 @@\n ┊60┊61┊\n ┊61┊62┊type OptionalChatQueryResult = ChatQueryResult | null;\n ┊62┊63┊\n+┊  ┊64┊interface ChatsResult {\n+┊  ┊65┊  chats: any[];\n+┊  ┊66┊}\n+┊  ┊67┊\n ┊63┊68┊const ChatRoomScreen: React.FC<ChatRoomScreenParams> = ({ history, chatId }) => {\n ┊64┊69┊  const { data: { chat } } = useQuery<any>(getChatQuery, {\n ┊65┊70┊    variables: { chatId }\n```\n```diff\n@@ -89,6 +94,33 @@\n ┊ 89┊ 94┊            }\n ┊ 90┊ 95┊          }\n ┊ 91┊ 96┊        });\n+┊   ┊ 97┊\n+┊   ┊ 98┊        let data;\n+┊   ┊ 99┊        try {\n+┊   ┊100┊          data = client.readQuery<ChatsResult>({\n+┊   ┊101┊            query: queries.chats,\n+┊   ┊102┊          });\n+┊   ┊103┊        } catch (e) {\n+┊   ┊104┊          return;\n+┊   ┊105┊        }\n+┊   ┊106┊\n+┊   ┊107┊        if (!data) return;\n+┊   ┊108┊        const chats = data.chats;\n+┊   ┊109┊        if (!chats) return;\n+┊   ┊110┊\n+┊   ┊111┊        const chatIndex = chats.findIndex((c:any) => c.id === chatId);\n+┊   ┊112┊        if (chatIndex === -1) return;\n+┊   ┊113┊        const chatWhereAdded = chats[chatIndex];\n+┊   ┊114┊\n+┊   ┊115┊        chatWhereAdded.lastMessage = addMessage;\n+┊   ┊116┊        // The chat will appear at the top of the ChatsList component\n+┊   ┊117┊        chats.splice(chatIndex, 1);\n+┊   ┊118┊        chats.unshift(chatWhereAdded);\n+┊   ┊119┊\n+┊   ┊120┊        client.writeQuery({\n+┊   ┊121┊          query: queries.chats,\n+┊   ┊122┊          data: { chats: chats },\n+┊   ┊123┊        });\n ┊ 92┊124┊      }\n ┊ 93┊125┊    });\n ┊ 94┊126┊  }, [chat, chatId, addMessage]);\n```\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;ChatsList.test.tsx\n```diff\n@@ -5,6 +5,7 @@\n ┊ 5┊ 5┊import { createBrowserHistory } from 'history';\n ┊ 6┊ 6┊import { mockApolloClient } from '../../test-helpers';\n ┊ 7┊ 7┊import ChatsList, { getChatsQuery } from './ChatsList';\n+┊  ┊ 8┊import * as queries from '../../graphql/queries';\n ┊ 8┊ 9┊\n ┊ 9┊10┊describe('ChatsList', () => {\n ┊10┊11┊  afterEach(() => {\n```\n```diff\n@@ -15,7 +16,7 @@\n ┊15┊16┊  it('renders fetched chats data', async () => {\n ┊16┊17┊    const client = mockApolloClient([\n ┊17┊18┊      {\n-┊18┊  ┊        request: { query: getChatsQuery },\n+┊  ┊19┊        request: { query: queries.chats },\n ┊19┊20┊        result: {\n ┊20┊21┊          data: {\n ┊21┊22┊            chats: [\n```\n```diff\n@@ -56,7 +57,7 @@\n ┊56┊57┊  it('should navigate to the target chat room on chat item click', async () => {\n ┊57┊58┊    const client = mockApolloClient([\n ┊58┊59┊      {\n-┊59┊  ┊        request: { query: getChatsQuery },\n+┊  ┊60┊        request: { query: queries.chats },\n ┊60┊61┊        result: {\n ┊61┊62┊          data: {\n ┊62┊63┊            chats: [\n```\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;ChatsList.tsx\n```diff\n@@ -4,8 +4,8 @@\n ┊ 4┊ 4┊import styled from 'styled-components';\n ┊ 5┊ 5┊import { useCallback } from 'react';\n ┊ 6┊ 6┊import { History } from 'history';\n-┊ 7┊  ┊import gql from 'graphql-tag';\n ┊ 8┊ 7┊import { useQuery } from 'react-apollo-hooks';\n+┊  ┊ 8┊import * as queries from '../../graphql/queries';\n ┊ 9┊ 9┊\n ┊10┊10┊const Container = styled.div `\n ┊11┊11┊  height: calc(100% - 56px);\n```\n```diff\n@@ -59,27 +59,12 @@\n ┊59┊59┊  font-size: 13px;\n ┊60┊60┊`;\n ┊61┊61┊\n-┊62┊  ┊export const getChatsQuery = gql`\n-┊63┊  ┊  query GetChats {\n-┊64┊  ┊    chats {\n-┊65┊  ┊      id\n-┊66┊  ┊      name\n-┊67┊  ┊      picture\n-┊68┊  ┊      lastMessage {\n-┊69┊  ┊        id\n-┊70┊  ┊        content\n-┊71┊  ┊        createdAt\n-┊72┊  ┊      }\n-┊73┊  ┊    }\n-┊74┊  ┊  }\n-┊75┊  ┊`;\n-┊76┊  ┊\n ┊77┊62┊interface ChatsListProps {\n ┊78┊63┊  history : History;\n ┊79┊64┊};\n ┊80┊65┊\n ┊81┊66┊const ChatsList: React.FC<ChatsListProps> = ({ history }) => {\n-┊82┊  ┊  const { data: { chats = [] } } = useQuery<any>(getChatsQuery);\n+┊  ┊67┊  const { data: { chats = [] } } = useQuery<any>(queries.chats);\n ┊83┊68┊\n ┊84┊69┊  const navToChat = useCallback((chat) => {\n ┊85┊70┊    history.push(`chats/${chat.id}`)\n```\n\n[}]: #\n\nRight now what happens is that we update a single chat document twice: Once for the `chats` query and another time for the `chat($chatId)` query.\nThis work is redundant and become more complex as we add more `chat` related queries.\nTo solve it, we can define and use a [GraphQL fragment](https://www.apollographql.com/docs/react/advanced/fragments.html).\n\n**Using Fragments**\n\nA GraphQL fragment is a shared piece of query logic.\n\n```graphql\nfragment NameParts on Person {\n  firstName\n  lastName\n}\n\nquery GetPerson {\n  people(id: \"7\") {\n    ...NameParts\n    avatar(size: LARGE)\n  }\n}\n```\n\nIt's important to note that the component after the `on` clause is designated for the type we are selecting from. In this case, `people` is of type `Person` and we want to select the `firstName` and `lastName` fields from `people(id: \"7\")`.\n\nApollo maps the fragment ID to its retrieved data in the store. By default, Apollo will compose the fragment ID out of the entity type and the ID of the document. For example, for a `Chat` document with an ID of `7`, the fragment ID would be `Chat:7`. This behavior can be modified, but there's no need to.\n\nWe will define the following fragments in our app:\n\n\n\n*   `Message` - represents a message\n*   `Chat` - represents a chat, **without its messages list**.\n*   `FullChat` - represents a chat, **including its messages list**.\n\nOnce we define the fragments we can start embedding them in our queries. We will create a new directory path `src/graphql/fragments`, and inside we will create a dedicated fragment file for each fragment type: `message.fragment.ts`, `chat.fragment.ts` and `fullChat.fragment.ts`:\n\n[{]: <helper> (diffStep 8.3 files=\"graphql/fragments\" module=\"client\")\n\n#### Client Step 8.3: Update queries to use GraphQL fragments\n\n##### Added src&#x2F;graphql&#x2F;fragments&#x2F;chat.fragment.ts\n```diff\n@@ -0,0 +1,14 @@\n+┊  ┊ 1┊import gql from 'graphql-tag';\n+┊  ┊ 2┊import message from './message.fragment';\n+┊  ┊ 3┊\n+┊  ┊ 4┊export default gql`\n+┊  ┊ 5┊  fragment Chat on Chat {\n+┊  ┊ 6┊    id\n+┊  ┊ 7┊    name\n+┊  ┊ 8┊    picture\n+┊  ┊ 9┊    lastMessage {\n+┊  ┊10┊      ...Message\n+┊  ┊11┊    }\n+┊  ┊12┊  }\n+┊  ┊13┊  ${message}\n+┊  ┊14┊`;\n```\n\n##### Added src&#x2F;graphql&#x2F;fragments&#x2F;fullChat.fragment.ts\n```diff\n@@ -0,0 +1,14 @@\n+┊  ┊ 1┊import gql from 'graphql-tag';\n+┊  ┊ 2┊import chat from './chat.fragment';\n+┊  ┊ 3┊import message from './message.fragment';\n+┊  ┊ 4┊\n+┊  ┊ 5┊export default gql`\n+┊  ┊ 6┊  fragment FullChat on Chat {\n+┊  ┊ 7┊    ...Chat\n+┊  ┊ 8┊    messages {\n+┊  ┊ 9┊      ...Message\n+┊  ┊10┊    }\n+┊  ┊11┊  }\n+┊  ┊12┊  ${chat}\n+┊  ┊13┊  ${message}\n+┊  ┊14┊`;\n```\n\n##### Added src&#x2F;graphql&#x2F;fragments&#x2F;index.ts\n```diff\n@@ -0,0 +1,3 @@\n+┊ ┊1┊export { default as chat } from './chat.fragment';\n+┊ ┊2┊export { default as fullChat } from './fullChat.fragment';\n+┊ ┊3┊export { default as message } from './message.fragment';\n```\n\n##### Added src&#x2F;graphql&#x2F;fragments&#x2F;message.fragment.ts\n```diff\n@@ -0,0 +1,9 @@\n+┊ ┊1┊import gql from 'graphql-tag';\n+┊ ┊2┊\n+┊ ┊3┊export default gql`\n+┊ ┊4┊  fragment Message on Message {\n+┊ ┊5┊    id\n+┊ ┊6┊    createdAt\n+┊ ┊7┊    content\n+┊ ┊8┊  }\n+┊ ┊9┊`;\n```\n\n[}]: #\n\nAnd now that we have the fragments available to us, let's embed them in the relevant queries:\n\n[{]: <helper> (diffStep 8.3 files=\"components, graphql/queries\" module=\"client\")\n\n#### Client Step 8.3: Update queries to use GraphQL fragments\n\n##### Changed src&#x2F;components&#x2F;ChatRoomScreen&#x2F;index.tsx\n```diff\n@@ -8,6 +8,7 @@\n ┊ 8┊ 8┊import MessagesList from './MessagesList';\n ┊ 9┊ 9┊import { History } from 'history';\n ┊10┊10┊import * as queries from '../../graphql/queries';\n+┊  ┊11┊import * as fragments from '../../graphql/fragments';\n ┊11┊12┊\n ┊12┊13┊ const Container = styled.div `\n ┊13┊14┊  background: url(/assets/chat-background.jpg);\n```\n```diff\n@@ -19,26 +20,19 @@\n ┊19┊20┊const getChatQuery = gql`\n ┊20┊21┊  query GetChat($chatId: ID!) {\n ┊21┊22┊    chat(chatId: $chatId) {\n-┊22┊  ┊      id\n-┊23┊  ┊      name\n-┊24┊  ┊      picture\n-┊25┊  ┊      messages {\n-┊26┊  ┊        id\n-┊27┊  ┊        content\n-┊28┊  ┊        createdAt\n-┊29┊  ┊      }\n+┊  ┊23┊      ...FullChat\n+┊  ┊24┊    }\n ┊30┊25┊  }\n-┊31┊  ┊}\n+┊  ┊26┊  ${fragments.fullChat}\n ┊32┊27┊`;\n ┊33┊28┊\n ┊34┊29┊const addMessageMutation = gql `\n ┊35┊30┊  mutation AddMessage($chatId: ID!, $content: String!) {\n ┊36┊31┊    addMessage(chatId: $chatId, content: $content) {\n-┊37┊  ┊      id\n-┊38┊  ┊      content\n-┊39┊  ┊      createdAt\n+┊  ┊32┊      ...Message\n ┊40┊33┊    }\n ┊41┊34┊  }\n+┊  ┊35┊  ${fragments.message}\n ┊42┊36┊`;\n ┊43┊37┊\n ┊44┊38┊interface ChatRoomScreenParams {\n```\n\n##### Changed src&#x2F;graphql&#x2F;queries&#x2F;chats.query.ts\n```diff\n@@ -1,16 +1,11 @@\n ┊ 1┊ 1┊import gql from 'graphql-tag';\n+┊  ┊ 2┊import * as fragments from '../fragments';\n ┊ 2┊ 3┊\n ┊ 3┊ 4┊export default gql`\n ┊ 4┊ 5┊  query Chats {\n ┊ 5┊ 6┊    chats {\n-┊ 6┊  ┊      id\n-┊ 7┊  ┊      name\n-┊ 8┊  ┊      picture\n-┊ 9┊  ┊      lastMessage {\n-┊10┊  ┊        id\n-┊11┊  ┊        content\n-┊12┊  ┊        createdAt\n-┊13┊  ┊      }\n+┊  ┊ 7┊      ...Chat\n ┊14┊ 8┊    }\n ┊15┊ 9┊  }\n+┊  ┊10┊  ${fragments.chat}\n ┊16┊11┊`;\n```\n\n[}]: #\n\nSimilarly to query rewriting, we will use the [`readFragment()`](https://www.apollographql.com/docs/react/features/caching.html#readfragment) and [`writeFragment()`](https://www.apollographql.com/docs/react/features/caching.html#writefragment) methods in the same way to rewrite the fragments. When working with a fragment we need to compose its ID, just like explained earlier. The default mapping function called `defaultDataIdFromObject` can be imported from `apollo-cache-inmemory` and be used to specify the fragment that we would like to read/write. Accordingly, we're gonna replace all our query re-writings with fragments re-writings, as we don't need them anymore:\n\n[{]: <helper> (diffStep 8.4 module=\"client\")\n\n#### Client Step 8.4: Rewrite fragments\n\n##### Changed src&#x2F;components&#x2F;ChatRoomScreen&#x2F;index.tsx\n```diff\n@@ -1,3 +1,4 @@\n+┊ ┊1┊import { defaultDataIdFromObject } from 'apollo-cache-inmemory';\n ┊1┊2┊import gql from 'graphql-tag';\n ┊2┊3┊import React from 'react';\n ┊3┊4┊import { useCallback } from 'react';\n```\n```diff\n@@ -78,15 +79,33 @@\n ┊ 78┊ 79┊        }\n ┊ 79┊ 80┊      },\n ┊ 80┊ 81┊      update: (client, { data: { addMessage } }) => {\n-┊ 81┊   ┊        client.writeQuery({\n-┊ 82┊   ┊          query: getChatQuery,\n-┊ 83┊   ┊          variables: { chatId },\n-┊ 84┊   ┊          data: {\n-┊ 85┊   ┊            chat: {\n-┊ 86┊   ┊              ...chat,\n-┊ 87┊   ┊              messages: chat.messages.concat(addMessage)\n-┊ 88┊   ┊            }\n-┊ 89┊   ┊          }\n+┊   ┊ 82┊        type FullChat = { [key: string]: any };\n+┊   ┊ 83┊        let fullChat;\n+┊   ┊ 84┊        const chatIdFromStore = defaultDataIdFromObject(chat);\n+┊   ┊ 85┊\n+┊   ┊ 86┊        if (chatIdFromStore === null) { return; }\n+┊   ┊ 87┊\n+┊   ┊ 88┊        try {\n+┊   ┊ 89┊          fullChat = client.readFragment<FullChat>({\n+┊   ┊ 90┊            id: chatIdFromStore,\n+┊   ┊ 91┊            fragment: fragments.fullChat,\n+┊   ┊ 92┊            fragmentName: 'FullChat',\n+┊   ┊ 93┊          });\n+┊   ┊ 94┊        } catch (e) {\n+┊   ┊ 95┊          return;\n+┊   ┊ 96┊        }\n+┊   ┊ 97┊\n+┊   ┊ 98┊        if (fullChat === null) { return; }\n+┊   ┊ 99┊        if (fullChat.messages.some((m:any) => m.id === addMessage.id)) return;\n+┊   ┊100┊\n+┊   ┊101┊        fullChat.messages.push(addMessage);\n+┊   ┊102┊        fullChat.lastMessage = addMessage;\n+┊   ┊103┊\n+┊   ┊104┊        client.writeFragment({\n+┊   ┊105┊          id: chatIdFromStore,\n+┊   ┊106┊          fragment: fragments.fullChat,\n+┊   ┊107┊          fragmentName: 'FullChat',\n+┊   ┊108┊          data: fullChat,\n ┊ 90┊109┊        });\n ┊ 91┊110┊\n ┊ 92┊111┊        let data;\n```\n```diff\n@@ -106,7 +125,6 @@\n ┊106┊125┊        if (chatIndex === -1) return;\n ┊107┊126┊        const chatWhereAdded = chats[chatIndex];\n ┊108┊127┊\n-┊109┊   ┊        chatWhereAdded.lastMessage = addMessage;\n ┊110┊128┊        // The chat will appear at the top of the ChatsList component\n ┊111┊129┊        chats.splice(chatIndex, 1);\n ┊112┊130┊        chats.unshift(chatWhereAdded);\n```\n\n[}]: #\n\n\n----------\nTODO: Isn’t `chats.splice(0, Infinity, ...[ … ])` the same as `chats = [...]` ?\nI see an explanation of apollo-cache but it makes you feel it’s the fragment that’s being cached, which is not true, it’s the object type.\nWe shouldn’t use `defaultDataIdFromObject` directly from `apollo-cache-inmemory` but define it somewhere in our code and use that. It might change in the future and then we would have to do it in 500 files.\nI would explain a lot more than it is now, about the caching. It should be based on a simpler example and show that when an entity `Foo:1` is modified, the change reflects in all component. We should describe how it’s stored, as references and not real data and so on.\n\nTODO: Better fragments naming and convensions"
          },
          {
            "manualTitle": "Step 9: Type safety with GraphQL Code Generator",
            "stepRevision": "bf4d4410e6a2867a686daaab67abf66f380a449d",
            "manualView": "So far we've been just writing code. If there was an error we would most likely discover it during runtime. As a reminder, we've created a project which is based on TypeScript, but we haven't really took any advantage of TypeScript's type safety mechanism. Currently, the TypeScript compiler is configured to work on loose mode, so any object which is not bound to any type will be converted to `any` - a type which is compatible with any type of casting and will ignore type errors.\n\nSo far it's been very convenient because we've only started to learn about building an app and the ecosystem around it, but for a long term project it's would be very handy to take a full advantage of TypeScript and not let it go under the radar. So where exactly are we missing type checkings? In the core of our project - when dealing with GraphQL documents.\n\nWhen we run a query, or a mutation, we wanna make sure that we use the received data correctly, based on its intended shape and form. For example, given the following GraphQL query:\n\n```graphql\nquery Chats {\n  chats {\n    id\n    name\n    picture\n  }\n}\n```\n\nWe want to have the following TypeScript type:\n\n```ts\nexport type Chat = {\n  __typename?: \"Chat\"\n  id: string\n  name: string\n  picture: string\n}\n\nexport type ChatQuery = {\n  __typename?: \"Query\"\n  chats: Chats[]\n}\n\n```\n\nSo later on we can use it with `react-apollo-hooks` like so:\n\n```ts\nuseQuery<ChatsQuery>(getChatsQuery)\n```\n\nEverything looks nice in theory, but the main issue that arises from having type definitions is that we need to maintain and sync 2 similar code bases:\nA GraphQL schema and TypeScript type definitions.\nBoth are essentially the same, and if so, why do we even need to maintain 2 code bases?\nIsn't there a tool which does that for us? A question which brings us straight to the point of the chapter.\n\n**Introducing: GraphQL Code Generator**\n\nWith [GraphQL Code Generator](https://graphql-code-generator.com/) we can generate TypeScript definitions given a GraphQL schema, and a set of GraphQL documents if they are presented to us.\n\n\n\n![graphql-codegen](https://user-images.githubusercontent.com/7648874/54940897-9f564380-4f66-11e9-9891-3b994a1daef1.png)\n\n\nGraphQL Code Generator is a simple CLI tool that operates based on a configuration file and can generate TypeScript types for both Client and Server.\nWe will start with generating types for the server.\n\nIn the server project, install GraphQL Code Generator via Yarn\n\n    $ yarn add @graphql-codegen/cli --dev\n\nNow GraphQL Code Generator can be used directly from the `scripts` section in the `package.json` file using the `gql-gen` binary.\nWe're gonna call the code generation script \"codegen\":\n\n```json\n{\n  \"codegen\": \"gql-gen\"\n}\n```\n\nThis command will automatically be referenced to a configuration file in the root of our project called `codegen.yml`.\nThe essence of this file is to provide the code generator with the GraphQL schema, GraphQL documents, the output path of the type definition file/s and a set of plug-ins.\nMore about the configuration file can be found in the [official website](https://graphql-code-generator.com/docs/getting-started/codegen-config).\n\nIn the server project, we will generate the `types/graphql.d.ts` file and we will use a couple of plug-ins to do that:\n\n\n\n*   `@graphql-codegen/typescript` - Will generate the core TypeScript types from our GraphQL schema.\n*   `@graphql-codegen/typescript-resolvers` - Will generate resolvers signatures with the generated TypeScript types.\n\n> A full list of available plugins is available [here](https://graphql-code-generator.com/docs/plugins/). In addition, you can write your own [custom plugin](https://graphql-code-generator.com/docs/custom-codegen/write-your-plugin).\n\nLet's install these 2 plugins:\n\n    $ yarn add @graphql-codegen/typescript @graphql-codegen/typescript-resolvers --dev\n\nAnd write the `codegen.yml` file:\n\n[{]: <helper> (diffStep 6.1 files=\"codegen.yml\" module=\"server\")\n\n#### [Server Step 6.1: Setup GraphQL Code Generator](https://github.com/Urigo/WhatsApp-Clone-Server/commit/2296411)\n\n##### Added codegen.yml\n```diff\n@@ -0,0 +1,16 @@\n+┊  ┊ 1┊schema: ./schema/typeDefs.graphql\n+┊  ┊ 2┊overwrite: true\n+┊  ┊ 3┊generates:\n+┊  ┊ 4┊  ./types/graphql.d.ts:\n+┊  ┊ 5┊    plugins:\n+┊  ┊ 6┊      - typescript\n+┊  ┊ 7┊      - typescript-resolvers\n+┊  ┊ 8┊    config:\n+┊  ┊ 9┊      mappers:\n+┊  ┊10┊        # import { Message } from '../db'\n+┊  ┊11┊        # The root types of Message resolvers\n+┊  ┊12┊        Message: ../db#Message\n+┊  ┊13┊        Chat: ../db#Chat\n+┊  ┊14┊      scalars:\n+┊  ┊15┊        # e.g. Message.createdAt will be of type Date\n+┊  ┊16┊        Date: Date\n```\n\n[}]: #\n\n> See inline comments to learn more about our configuration setup.\n\nNow if you'll run `$ npm run codegen` you should see that a new file `types/graphql.d.ts` has been generated with all the necessary TypeScript types. Since these types are very likely to change as we extend our schema, there's no need to include them in our project, thus it's recommended to add the appropriate .gitignore rule:\n\n[{]: <helper> (diffStep 6.1 files=\".gitignore\" module=\"server\")\n\n#### [Server Step 6.1: Setup GraphQL Code Generator](https://github.com/Urigo/WhatsApp-Clone-Server/commit/2296411)\n\n##### Changed .gitignore\n```diff\n@@ -1,2 +1,3 @@\n ┊1┊1┊node_modules\n-┊2┊ ┊npm-debug.log🚫↵\n+┊ ┊2┊npm-debug.log\n+┊ ┊3┊types/graphql.d.ts🚫↵\n```\n\n[}]: #\n\nNow we can import the `IResolvers` type from the file we've just created and use it in the `resolvers.ts` file to ensure our resolvers handlers have the right signature:\n\n[{]: <helper> (diffStep 6.2 module=\"server\")\n\n#### [Server Step 6.2: Type resolvers](https://github.com/Urigo/WhatsApp-Clone-Server/commit/9cb0db6)\n\n##### Changed schema&#x2F;index.ts\n```diff\n@@ -1,7 +1,10 @@\n ┊ 1┊ 1┊import { importSchema } from 'graphql-import'\n-┊ 2┊  ┊import { makeExecutableSchema } from 'graphql-tools'\n+┊  ┊ 2┊import { makeExecutableSchema, IResolvers } from 'graphql-tools'\n ┊ 3┊ 3┊import resolvers from './resolvers'\n ┊ 4┊ 4┊\n ┊ 5┊ 5┊const typeDefs = importSchema('schema/typeDefs.graphql')\n ┊ 6┊ 6┊\n-┊ 7┊  ┊export default makeExecutableSchema({ resolvers, typeDefs })\n+┊  ┊ 7┊export default makeExecutableSchema({\n+┊  ┊ 8┊  resolvers: resolvers as IResolvers,\n+┊  ┊ 9┊  typeDefs,\n+┊  ┊10┊})\n```\n\n##### Changed schema&#x2F;resolvers.ts\n```diff\n@@ -1,18 +1,19 @@\n ┊ 1┊ 1┊import { GraphQLDateTime } from 'graphql-iso-date'\n-┊ 2┊  ┊import { chats, messages } from '../db'\n+┊  ┊ 2┊import { Message, chats, messages } from '../db'\n+┊  ┊ 3┊import { Resolvers } from '../types/graphql'\n ┊ 3┊ 4┊\n-┊ 4┊  ┊const resolvers = {\n+┊  ┊ 5┊const resolvers: Resolvers = {\n ┊ 5┊ 6┊  Date: GraphQLDateTime,\n ┊ 6┊ 7┊\n ┊ 7┊ 8┊  Chat: {\n-┊ 8┊  ┊    messages(chat: any) {\n+┊  ┊ 9┊    messages(chat) {\n ┊ 9┊10┊      return messages.filter(m => chat.messages.includes(m.id))\n ┊10┊11┊    },\n ┊11┊12┊\n-┊12┊  ┊    lastMessage(chat: any) {\n+┊  ┊13┊    lastMessage(chat) {\n ┊13┊14┊      const lastMessage = chat.messages[chat.messages.length - 1]\n ┊14┊15┊\n-┊15┊  ┊      return messages.find(m => m.id === lastMessage)\n+┊  ┊16┊      return messages.find(m => m.id === lastMessage) || null\n ┊16┊17┊    },\n ┊17┊18┊  },\n ┊18┊19┊\n```\n```diff\n@@ -21,13 +22,13 @@\n ┊21┊22┊      return chats\n ┊22┊23┊    },\n ┊23┊24┊\n-┊24┊  ┊    chat(root: any, { chatId }: any) {\n-┊25┊  ┊      return chats.find(c => c.id === chatId)\n+┊  ┊25┊    chat(root, { chatId }) {\n+┊  ┊26┊      return chats.find(c => c.id === chatId) || null\n ┊26┊27┊    },\n ┊27┊28┊  },\n ┊28┊29┊\n ┊29┊30┊  Mutation: {\n-┊30┊  ┊    addMessage(root: any, { chatId, content }: any) {\n+┊  ┊31┊    addMessage(root, { chatId, content }) {\n ┊31┊32┊      const chatIndex = chats.findIndex(c => c.id === chatId)\n ┊32┊33┊\n ┊33┊34┊      if (chatIndex === -1) return null\n```\n```diff\n@@ -35,7 +36,7 @@\n ┊35┊36┊      const chat = chats[chatIndex]\n ┊36┊37┊      const recentMessage = messages[messages.length - 1]\n ┊37┊38┊      const messageId = String(Number(recentMessage.id) + 1)\n-┊38┊  ┊      const message = {\n+┊  ┊39┊      const message: Message = {\n ┊39┊40┊        id: messageId,\n ┊40┊41┊        createdAt: new Date(),\n ┊41┊42┊        content,\n```\n\n[}]: #\n\nWe will now repeat the same process in the client with few tweaks. Again, we will install GraphQL Code Generator:\n\n    $ yarn add @graphql-codegen/cli --dev\n\nAnd we will define a script:\n\n```json\n{\n  \"codegen\": \"gql-gen\"\n}\n```\n\nThis time around, because we're in the client, we will define a set of glob paths that will specify which files contain GraphQL documents.\nGraphQL Code Generator is smart enough to automatically recognize the documents within these files by looking at the `gql` template literal calls using the `typescript-operations` package.\nWe will be using a plugin called `typescript-react-apollo` to generate React/Apollo-GraphQL hooks that can be used in our function components.\nLet's install the necessary plugins:\n\n    $ yarn add @graphql-codegen/cli @graphql-codegen/typescript @graphql-codegen/typescript-operations @graphql-codegen/typescript-react-apollo @graphql-codegen/add\n\n\nAnd we will write the `codegen.yml` file:\n\n[{]: <helper> (diffStep 9.1 files=\"codegen.yml\" module=\"client\")\n\n#### Client Step 9.1: Setup GraphQL Code Generator\n\n##### Added codegen.yml\n```diff\n@@ -0,0 +1,20 @@\n+┊  ┊ 1┊schema: ../Whatsapp-Clone-Server/schema/typeDefs.graphql\n+┊  ┊ 2┊documents:\n+┊  ┊ 3┊  - ./src/components/**/*.tsx\n+┊  ┊ 4┊  - ./src/graphql/fragments/**/*.ts\n+┊  ┊ 5┊  - ./src/graphql/queries/**/*.ts\n+┊  ┊ 6┊overwrite: true\n+┊  ┊ 7┊generates:\n+┊  ┊ 8┊  ./src/graphql/types.tsx:\n+┊  ┊ 9┊    plugins:\n+┊  ┊10┊      - add: '/* eslint-disable */'\n+┊  ┊11┊      - typescript\n+┊  ┊12┊      - typescript-operations\n+┊  ┊13┊      - typescript-react-apollo\n+┊  ┊14┊    # The combined options of all provided plug-ins\n+┊  ┊15┊    # More information about the options below:\n+┊  ┊16┊    # graphql-code-generator.com/docs/plugins/typescript-react-apollo#configuration\n+┊  ┊17┊    config:\n+┊  ┊18┊      withHOC: false\n+┊  ┊19┊      withHooks: true\n+┊  ┊20┊      withComponent: false\n```\n\n[}]: #\n\nNotice that we sent the schema as a local path.\nWe could have also provided a GraphQL endpoint that exposes a GraphQL schema.\nThis way if there's an existing running GraphQL API, we can generate TypeScript types out of it, such as GitHub's GraphQL API.\nThe advantages of providing a local path is that the server doesn't have to be running in order to generate types, which is more comfortable in development, and we can bypass authentication if the endpoint is guarded with such mechanism.\nThis will be useful in further chapters when we're introduced to the concept of authentication.\n\nBe sure to add a .gitignore rule because we want to run the generator every time there is a change and don't want to rely on old generated types:\n\n[{]: <helper> (diffStep 9.1 files=\".gitignore\" module=\"client\")\n\n#### Client Step 9.1: Setup GraphQL Code Generator\n\n##### Changed .gitignore\n```diff\n@@ -21,3 +21,5 @@\n ┊21┊21┊npm-debug.log*\n ┊22┊22┊yarn-debug.log*\n ┊23┊23┊yarn-error.log*\n+┊  ┊24┊\n+┊  ┊25┊src/graphql/types.tsx\n```\n\n[}]: #\n\nNow we have TypeScript types available to us and we can replace `useQuery()` and `useMutation()` calls with the generated React hooks.\nLet's use those and also remove all the old manual typings:\n\n[{]: <helper> (diffStep 9.2 module=\"client\")\n\n#### Client Step 9.2: Use GraphQL Codegen hooks\n\n##### Changed src&#x2F;components&#x2F;ChatRoomScreen&#x2F;ChatNavbar.tsx\n```diff\n@@ -5,7 +5,6 @@\n ┊ 5┊ 5┊import { useCallback } from 'react';\n ┊ 6┊ 6┊import styled from 'styled-components';\n ┊ 7┊ 7┊import { History } from 'history';\n-┊ 8┊  ┊import { ChatQueryResult } from './index';\n ┊ 9┊ 8┊\n ┊10┊ 9┊const Container = styled(Toolbar) `\n ┊11┊10┊  padding: 0;\n```\n```diff\n@@ -37,7 +36,10 @@\n ┊37┊36┊\n ┊38┊37┊interface ChatNavbarProps {\n ┊39┊38┊  history: History;\n-┊40┊  ┊  chat: ChatQueryResult;\n+┊  ┊39┊  chat?: {\n+┊  ┊40┊    picture?: string | null;\n+┊  ┊41┊    name?: string | null;\n+┊  ┊42┊  };\n ┊41┊43┊};\n ┊42┊44┊\n ┊43┊45┊const ChatNavbar: React.FC<ChatNavbarProps> = ({ chat, history }) => {\n```\n```diff\n@@ -50,8 +52,12 @@\n ┊50┊52┊      <BackButton data-testid=\"back-button\" onClick={navBack}>\n ┊51┊53┊        <ArrowBackIcon />\n ┊52┊54┊      </BackButton>\n-┊53┊  ┊      <Picture data-testid=\"chat-picture\" src={chat.picture} />\n-┊54┊  ┊      <Name data-testid=\"chat-name\">{chat.name}</Name>\n+┊  ┊55┊      {chat && chat.picture && chat.name && (\n+┊  ┊56┊        <React.Fragment>\n+┊  ┊57┊          <Picture data-testid=\"chat-picture\" src={chat.picture} />\n+┊  ┊58┊          <Name data-testid=\"chat-name\">{chat.name}</Name>\n+┊  ┊59┊        </React.Fragment>\n+┊  ┊60┊      )}\n ┊55┊61┊    </Container>\n ┊56┊62┊  );\n ┊57┊63┊};\n```\n\n##### Changed src&#x2F;components&#x2F;ChatRoomScreen&#x2F;MessagesList.tsx\n```diff\n@@ -3,7 +3,6 @@\n ┊3┊3┊import { useEffect, useRef } from 'react';\n ┊4┊4┊import ReactDOM from 'react-dom';\n ┊5┊5┊import styled from 'styled-components';\n-┊6┊ ┊import { ChatQueryMessage } from './index';\n ┊7┊6┊\n ┊8┊7┊const Container = styled.div`\n ┊9┊8┊  display: block;\n```\n```diff\n@@ -62,8 +61,13 @@\n ┊62┊61┊  font-size: 12px;\n ┊63┊62┊`;\n ┊64┊63┊\n+┊  ┊64┊interface Message {\n+┊  ┊65┊  id: string | null;\n+┊  ┊66┊  content: string | null;\n+┊  ┊67┊  createdAt: string | null;\n+┊  ┊68┊}\n ┊65┊69┊interface MessagesListProps {\n-┊66┊  ┊  messages: Array<ChatQueryMessage>;\n+┊  ┊70┊  messages: Array<Message>;\n ┊67┊71┊}\n ┊68┊72┊\n ┊69┊73┊const MessagesList: React.FC<MessagesListProps> = ({ messages }) => {\n```\n\n##### Changed src&#x2F;components&#x2F;ChatRoomScreen&#x2F;index.tsx\n```diff\n@@ -2,12 +2,12 @@\n ┊ 2┊ 2┊import gql from 'graphql-tag';\n ┊ 3┊ 3┊import React from 'react';\n ┊ 4┊ 4┊import { useCallback } from 'react';\n-┊ 5┊  ┊import { useQuery, useMutation } from 'react-apollo-hooks';\n ┊ 6┊ 5┊import styled from 'styled-components';\n ┊ 7┊ 6┊import ChatNavbar from './ChatNavbar';\n ┊ 8┊ 7┊import MessageInput from './MessageInput';\n ┊ 9┊ 8┊import MessagesList from './MessagesList';\n ┊10┊ 9┊import { History } from 'history';\n+┊  ┊10┊import { useGetChatQuery, useAddMessageMutation } from '../../graphql/types';\n ┊11┊11┊import * as queries from '../../graphql/queries';\n ┊12┊12┊import * as fragments from '../../graphql/fragments';\n ┊13┊13┊\n```\n```diff\n@@ -18,7 +18,8 @@\n ┊18┊18┊  height: 100vh;\n ┊19┊19┊`;\n ┊20┊20┊\n-┊21┊  ┊const getChatQuery = gql`\n+┊  ┊21┊// eslint-disable-next-line\n+┊  ┊22┊const getChatQuery = gql `\n ┊22┊23┊  query GetChat($chatId: ID!) {\n ┊23┊24┊    chat(chatId: $chatId) {\n ┊24┊25┊      ...FullChat\n```\n```diff\n@@ -27,6 +28,7 @@\n ┊27┊28┊  ${fragments.fullChat}\n ┊28┊29┊`;\n ┊29┊30┊\n+┊  ┊31┊// eslint-disable-next-line\n ┊30┊32┊const addMessageMutation = gql `\n ┊31┊33┊  mutation AddMessage($chatId: ID!, $content: String!) {\n ┊32┊34┊    addMessage(chatId: $chatId, content: $content) {\n```\n```diff\n@@ -36,37 +38,28 @@\n ┊36┊38┊  ${fragments.message}\n ┊37┊39┊`;\n ┊38┊40┊\n-┊39┊  ┊interface ChatRoomScreenParams {\n+┊  ┊41┊interface ChatRoomScreenParams {\n ┊40┊42┊  chatId: string\n ┊41┊43┊  history: History;\n ┊42┊44┊};\n-┊43┊  ┊\n-┊44┊  ┊export interface ChatQueryMessage {\n-┊45┊  ┊  id: string;\n-┊46┊  ┊  content: string;\n-┊47┊  ┊  createdAt: number;\n-┊48┊  ┊};\n-┊49┊  ┊\n-┊50┊  ┊export interface ChatQueryResult {\n-┊51┊  ┊  id: string;\n-┊52┊  ┊  name: string;\n-┊53┊  ┊  picture: string;\n-┊54┊  ┊  messages: Array<ChatQueryMessage>;\n-┊55┊  ┊};\n-┊56┊  ┊\n-┊57┊  ┊type OptionalChatQueryResult = ChatQueryResult | null;\n ┊58┊45┊\n ┊59┊46┊interface ChatsResult {\n ┊60┊47┊  chats: any[];\n ┊61┊48┊}\n ┊62┊49┊\n ┊63┊50┊const ChatRoomScreen: React.FC<ChatRoomScreenParams> = ({ history, chatId }) => {\n-┊64┊  ┊  const { data: { chat } } = useQuery<any>(getChatQuery, {\n+┊  ┊51┊  const { data, loading } = useGetChatQuery({\n ┊65┊52┊    variables: { chatId }\n ┊66┊53┊  });\n-┊67┊  ┊  const addMessage = useMutation(addMessageMutation);\n+┊  ┊54┊\n+┊  ┊55┊  const addMessage = useAddMessageMutation();\n ┊68┊56┊\n ┊69┊57┊  const onSendMessage = useCallback((content: string) => {\n+┊  ┊58┊\n+┊  ┊59┊    if (data === undefined) { return null; }\n+┊  ┊60┊    const chat = data.chat;\n+┊  ┊61┊    if (chat === null) return null;\n+┊  ┊62┊\n ┊70┊63┊    addMessage({\n ┊71┊64┊      variables: { chatId, content },\n ┊72┊65┊      optimisticResponse: {\n```\n```diff\n@@ -82,7 +75,7 @@\n ┊82┊75┊        type FullChat = { [key: string]: any };\n ┊83┊76┊        let fullChat;\n ┊84┊77┊        const chatIdFromStore = defaultDataIdFromObject(chat);\n-┊85┊  ┊\n+┊  ┊78┊\n ┊86┊79┊        if (chatIdFromStore === null) { return; }\n ┊87┊80┊\n ┊88┊81┊        try {\n```\n```diff\n@@ -132,12 +125,19 @@\n ┊132┊125┊        client.writeQuery({\n ┊133┊126┊          query: queries.chats,\n ┊134┊127┊          data: { chats: chats },\n-┊135┊   ┊        });\n+┊   ┊128┊        });\n ┊136┊129┊      }\n ┊137┊130┊    });\n-┊138┊   ┊  }, [chat, chatId, addMessage]);\n+┊   ┊131┊  }, [data, chatId, addMessage]);\n+┊   ┊132┊\n+┊   ┊133┊  if (data === undefined) {\n+┊   ┊134┊    return null;\n+┊   ┊135┊  }\n+┊   ┊136┊  const chat = data.chat;\n+┊   ┊137┊  const loadingChat = loading;\n ┊139┊138┊\n-┊140┊   ┊  if (!chat) return null;\n+┊   ┊139┊  if (loadingChat) return null;\n+┊   ┊140┊  if (chat === null) return null;\n ┊141┊141┊\n ┊142┊142┊  return (\n ┊143┊143┊    <Container>\n```\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;ChatsList.tsx\n```diff\n@@ -4,8 +4,7 @@\n ┊ 4┊ 4┊import styled from 'styled-components';\n ┊ 5┊ 5┊import { useCallback } from 'react';\n ┊ 6┊ 6┊import { History } from 'history';\n-┊ 7┊  ┊import { useQuery } from 'react-apollo-hooks';\n-┊ 8┊  ┊import * as queries from '../../graphql/queries';\n+┊  ┊ 7┊import { useChatsQuery } from '../../graphql/types';\n ┊ 9┊ 8┊\n ┊10┊ 9┊const Container = styled.div `\n ┊11┊10┊  height: calc(100% - 56px);\n```\n```diff\n@@ -64,12 +63,19 @@\n ┊64┊63┊};\n ┊65┊64┊\n ┊66┊65┊const ChatsList: React.FC<ChatsListProps> = ({ history }) => {\n-┊67┊  ┊  const { data: { chats = [] } } = useQuery<any>(queries.chats);\n ┊68┊66┊\n ┊69┊67┊  const navToChat = useCallback((chat) => {\n ┊70┊68┊    history.push(`chats/${chat.id}`)\n ┊71┊69┊  }, [history]);\n ┊72┊70┊\n+┊  ┊71┊  const { data } = useChatsQuery();\n+┊  ┊72┊\n+┊  ┊73┊  if (data === undefined || data.chats === undefined) {\n+┊  ┊74┊    return null;\n+┊  ┊75┊  }\n+┊  ┊76┊\n+┊  ┊77┊  let chats = data.chats;\n+┊  ┊78┊\n ┊73┊79┊  return (\n ┊74┊80┊    <Container>\n ┊75┊81┊      <StyledList>\n```\n\n[}]: #\n\nTo test if things are working properly, we can address a non existing field in one of the retrieved query results, for example `chat.foo` in `useGetChatQuery()`.\nWe should receive the following typing error when trying to run the project:\n\n```\nTypeScript error: Property 'foo' does not exist on type '{ __typename?: \"Chat\"; } & { __typename?: \"Chat\"; } & { messages: ({ __typename?: \"Message\"; } & { __typename?: \"Message\"; } & Pick<Message, \"id\" | \"createdAt\" | \"content\">)[]; } & { __typename?: \"Chat\"; } & Pick<...> & { ...; }'.  TS2339\n\n    44 |   const addMessage = useAddMessageMutation()\n    45 |\n  > 46 |   console.log(chat.foo)\n       |                    ^\n    47 |\n    48 |   const onSendMessage = useCallback((content) => {\n    49 |     addMessage({\n```\n\nTODO: Mappers are not explained - The root types of Message resolvers - doesn’t say much\nwe don’t need to use `resolvers as IResolvers`, there’s a flag for it, in codegen\n\nTODO: Change `gql-gen` to `graphql-codegen`"
          },
          {
            "manualTitle": "Step 10: Live updates with GraphQL subscriptions",
            "stepRevision": "7a5987372e3538bec4342cde757f725cc8ebf9f0",
            "manualView": "So far we've been developing the app and we've been treating it as if there's no other users; we're the only one exists.\nThis approach is true when we want to develop a UI and focus on UX, but comes a point where we need to start thinking on a macro level.\nOur app is social interactive, and if things work properly for me, it doesn't mean that it works properly to the fellow I'm chatting with.\nIt's inevitable to have an authentication system in our app, hence we need to take care of things before we get to that stage.\n\nTry to open 2 instances of the app in 2 separate tabs/windows, and navigate into the same chat room.\nTry to send a message with one instance and notice that the second instance doesn't update unless we refresh the page.\n\n\n![ezgif com-video-to-gif (2)](https://user-images.githubusercontent.com/7648874/55079371-fbd87080-50d6-11e9-8ade-5ffeed6eaf8d.gif)\n\n\nThis issue is very important and should be addressed, because a chat is all about sending and receiving messages on a lively basis.\nThis issue was expected, as there's no mechanism that would trigger and listen to changes in the back-end.\nIn this chapter we're gonna address that issue by implementing exactly that mechanism.\n\n**Introducing: GraphQL Subscriptions**\n\n[GraphQL subscriptions](https://github.com/apollographql/graphql-subscriptions) is a mechanism that works on [web-sockets](https://en.wikipedia.org/wiki/WebSocket) and live communication; clients can subscribe to it and be notified regards specific changes that happen in the back-end. Notifications will be triggered manually by us and can be provided with parameters that provide additional information regards the triggered event. For example, a `messageAdded` will be published with the new message, and will notify all clients who are subscribed to that event. Once the subscribers are notified, they can respond as they would like to, such as updating the UI.\n\n\n\n![subscription-notifications](https://user-images.githubusercontent.com/7648874/55079462-30e4c300-50d7-11e9-8399-7706da2a9cff.png)\n\n\nA subscription is presented in our GraphQL schema as a separate type called `Subscription`, where each field represents an event name along with its return type.\nLike any other GraphQL type, each field should be match with a resolver where we handle the request.\n\nIn this chapter we will implement the `messageAdded` subscription, so users can be notified when it happens and update the messages list to contain the new message.\n\n**Implementing a subscription**\n\nWe will start by creating a new `Subscription` type in our GraphQL schema with the field `messageAdded`:\n\n[{]: <helper> (diffStep 7.1 module=\"server\")\n\n#### [Server Step 7.1: Add subscription type with messageAdded](https://github.com/Urigo/WhatsApp-Clone-Server/commit/8b6d50c)\n\n##### Changed schema&#x2F;typeDefs.graphql\n```diff\n@@ -22,3 +22,7 @@\n ┊22┊22┊type Mutation {\n ┊23┊23┊  addMessage(chatId: ID!, content: String!): Message\n ┊24┊24┊}\n+┊  ┊25┊\n+┊  ┊26┊type Subscription {\n+┊  ┊27┊  messageAdded: Message!\n+┊  ┊28┊}\n```\n\n[}]: #\n\nChanges are triggered using an event-emitter like object called `PubSub`. This can be done using the `PubSub.prototype.publish` method. We will create a new instance of it and will provide it via the [context](https://www.apollographql.com/docs/apollo-server/essentials/data#context) - a common pattern for providing objects which are useful for the execution of the resolvers:\n\nTODO: Explain what the context is\n\n[{]: <helper> (diffStep 7.2 module=\"server\")\n\n#### [Server Step 7.2: Provide a new instance of PubSub to context](https://github.com/Urigo/WhatsApp-Clone-Server/commit/a1b2016)\n\n##### Changed index.ts\n```diff\n@@ -1,4 +1,4 @@\n-┊1┊ ┊import { ApolloServer, gql } from 'apollo-server-express'\n+┊ ┊1┊import { ApolloServer, gql, PubSub } from 'apollo-server-express'\n ┊2┊2┊import bodyParser from 'body-parser'\n ┊3┊3┊import cors from 'cors'\n ┊4┊4┊import express from 'express'\n```\n```diff\n@@ -13,7 +13,11 @@\n ┊13┊13┊  res.send('pong')\n ┊14┊14┊})\n ┊15┊15┊\n-┊16┊  ┊const server = new ApolloServer({ schema })\n+┊  ┊16┊const pubsub = new PubSub()\n+┊  ┊17┊const server = new ApolloServer({\n+┊  ┊18┊  schema,\n+┊  ┊19┊  context: () => ({ pubsub }),\n+┊  ┊20┊})\n ┊17┊21┊\n ┊18┊22┊server.applyMiddleware({\n ┊19┊23┊  app,\n```\n\n[}]: #\n\nInside the `addMessage` resolver we will publish a new event called `messageAdded`. The 3rd argument of the resolver will be the context object that we've just defined in the previous step, where we can use the pubsub instance. The TypeScript type of our context can be directly defined and generated by CodeGen through the `codegen.yml` file. This can be specified under the `ContextType` field with the file path that contains the context followed by the name of the exported object, like so:\n\n[{]: <helper> (diffStep 7.3 module=\"server\")\n\n#### [Server Step 7.3: Define Context type](https://github.com/Urigo/WhatsApp-Clone-Server/commit/405ba97)\n\n##### Changed codegen.yml\n```diff\n@@ -6,6 +6,7 @@\n ┊ 6┊ 6┊      - typescript\n ┊ 7┊ 7┊      - typescript-resolvers\n ┊ 8┊ 8┊    config:\n+┊  ┊ 9┊      contextType: ../context#MyContext\n ┊ 9┊10┊      mappers:\n ┊10┊11┊        # import { Message } from '../db'\n ┊11┊12┊        # The root types of Message resolvers\n```\n\n##### Added context.ts\n```diff\n@@ -0,0 +1,5 @@\n+┊ ┊1┊import { PubSub } from 'apollo-server-express'\n+┊ ┊2┊\n+┊ ┊3┊export type MyContext = {\n+┊ ┊4┊  pubsub: PubSub\n+┊ ┊5┊}\n```\n\n[}]: #\n\nThe event will be published right after the message was pushed into the messages collection, because order is a crucial thing. We don't want to notify our users unless the change has been made. The event will have a single parameter which represents the new message.\n\n[{]: <helper> (diffStep 7.4 module=\"server\")\n\n#### [Server Step 7.4: Publish message added event](https://github.com/Urigo/WhatsApp-Clone-Server/commit/4c6d52a)\n\n##### Changed schema&#x2F;resolvers.ts\n```diff\n@@ -28,7 +28,7 @@\n ┊28┊28┊  },\n ┊29┊29┊\n ┊30┊30┊  Mutation: {\n-┊31┊  ┊    addMessage(root, { chatId, content }) {\n+┊  ┊31┊    addMessage(root, { chatId, content }, { pubsub }) {\n ┊32┊32┊      const chatIndex = chats.findIndex(c => c.id === chatId)\n ┊33┊33┊\n ┊34┊34┊      if (chatIndex === -1) return null\n```\n```diff\n@@ -48,6 +48,10 @@\n ┊48┊48┊      chats.splice(chatIndex, 1)\n ┊49┊49┊      chats.unshift(chat)\n ┊50┊50┊\n+┊  ┊51┊      pubsub.publish('messageAdded', {\n+┊  ┊52┊        messageAdded: message,\n+┊  ┊53┊      })\n+┊  ┊54┊\n ┊51┊55┊      return message\n ┊52┊56┊    }\n ┊53┊57┊  }\n```\n\n##### Changed tests&#x2F;mutations&#x2F;addMessage.test.ts\n```diff\n@@ -1,5 +1,5 @@\n ┊1┊1┊import { createTestClient } from 'apollo-server-testing'\n-┊2┊ ┊import { ApolloServer, gql } from 'apollo-server-express'\n+┊ ┊2┊import { ApolloServer, PubSub, gql } from 'apollo-server-express'\n ┊3┊3┊import schema from '../../schema'\n ┊4┊4┊import { resetDb } from '../../db'\n ┊5┊5┊\n```\n```diff\n@@ -7,7 +7,10 @@\n ┊ 7┊ 7┊  beforeEach(resetDb)\n ┊ 8┊ 8┊\n ┊ 9┊ 9┊  it('should add message to specified chat', async () => {\n-┊10┊  ┊    const server = new ApolloServer({ schema })\n+┊  ┊10┊    const server = new ApolloServer({\n+┊  ┊11┊      schema,\n+┊  ┊12┊      context: () => ({ pubsub: new PubSub() }),\n+┊  ┊13┊    })\n ┊11┊14┊\n ┊12┊15┊    const { query, mutate } = createTestClient(server)\n```\n\n[}]: #\n\nA subscription resolver behaves differently and thus should be implemented differently. Using the `pubsub.asyncIterator` instance, we can specify which events are relevant for the subscription, for example, all clients who are subscribers of the `chatUpdated` subscription will be notified when `messageAdded`, `messageRemoved` and `chatInfoChanged` events were triggered. For now, we will have a 1 to 1 relationship between the `messageAdded` event and `messageAdded` subscription. In code, it should look like this:\n\n[{]: <helper> (diffStep 7.5 module=\"server\")\n\n#### [Server Step 7.5: Add Subscription.messageAdded resolver](https://github.com/Urigo/WhatsApp-Clone-Server/commit/3bbaa14)\n\n##### Changed schema&#x2F;resolvers.ts\n```diff\n@@ -54,6 +54,12 @@\n ┊54┊54┊\n ┊55┊55┊      return message\n ┊56┊56┊    }\n+┊  ┊57┊  },\n+┊  ┊58┊\n+┊  ┊59┊  Subscription: {\n+┊  ┊60┊    messageAdded: {\n+┊  ┊61┊      subscribe: (root, args, { pubsub }) => pubsub.asyncIterator('messageAdded')\n+┊  ┊62┊    }\n ┊57┊63┊  }\n ┊58┊64┊}\n```\n\n[}]: #\n\nThe idea behind the `pubsub.asyncIterator` method is that it returns an [`Iterator`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators#Iterators) like object, where each value is a promise that will be resolved when the relevant events are triggered. By default, the parameter that has a similar name to the subscription will be returned as a response, e.g. `messageAdded` parameter will be sent back to the subscribers. This behavior can be modified as explained [here](https://github.com/apollographql/graphql-subscriptions#payload-manipulation), but it's very unlikely and not necessary for our use case.\n\nAs mentioned at the beginning of this article, there needs to be an open connection between the client and the server so live updates can happen. There are serveral methods for doing so, but the 2 most popular ones are:\n\n\n\n*   Based on polling with HTTP protocol\n*   Based on web-sockets (WS protocol)\n\nHTTP polling means that each amount of time an HTTP request will be made to the server where potential changes can be sent back to us at any given time. HTTP requests are very reliable, but the problem with them is that they contain a lot of information in their headers, so even if we sent an empty request, it might be still very heavy due to cookies, user-agent, language, request type, etc.\n\nWith web-sockets, once a connection has been established, it will remain open and it will only send the information which is relevant for the current session, so it's much faster. The communication is between the server and the client is bi-directional when it comes to web-sockets, which means that a user can spontaneously receive information from the server, as long as the communication channel remains open.\n\n> More information about the advantages of Web Sockets over HTTP can be found at [websocket.org](http://websocket.org/quantum.html)\n\nThe subscription mechanism can be installed using the `server.installSubscriptionHandlers`. It will use the WS protocol by default and will fallback to HTTP polling if there were troubles establishing a connection via WS protocol:\n\n[{]: <helper> (diffStep 7.6 module=\"server\")\n\n#### [Server Step 7.6: Install subscription handlers](https://github.com/Urigo/WhatsApp-Clone-Server/commit/8fd8a58)\n\n##### Changed index.ts\n```diff\n@@ -2,6 +2,7 @@\n ┊2┊2┊import bodyParser from 'body-parser'\n ┊3┊3┊import cors from 'cors'\n ┊4┊4┊import express from 'express'\n+┊ ┊5┊import http from 'http'\n ┊5┊6┊import schema from './schema'\n ┊6┊7┊\n ┊7┊8┊const app = express()\n```\n```diff\n@@ -24,8 +25,11 @@\n ┊24┊25┊  path: '/graphql',\n ┊25┊26┊})\n ┊26┊27┊\n+┊  ┊28┊const httpServer = http.createServer(app)\n+┊  ┊29┊server.installSubscriptionHandlers(httpServer)\n+┊  ┊30┊\n ┊27┊31┊const port = process.env.PORT || 4000\n ┊28┊32┊\n-┊29┊  ┊app.listen(port, () => {\n+┊  ┊33┊httpServer.listen(port, () => {\n ┊30┊34┊  console.log(`Server is listening on port ${port}`)\n ┊31┊35┊})\n```\n\n[}]: #\n\nNow we have everything set and we can start listening to subscriptions and react to to triggered changes.\n\n**Using subscriptions**\n\nTo support subscriptions we need to establish a WS connection. For that we will need to update our Apollo client. We will install a couple of packages that will enable such feature:\n\n    $ yarn add subscriptions-transport-ws apollo-link apollo-link-ws apollo-utilities\n\n\n*   [`subscriptions-transport-ws`](https://www.npmjs.com/package/subscriptions-transport-ws) - a transport layer that understands how client and GraphQL API communicates with each other. The spec has GQL_INIT GQL_UPDATE GQL_DATA events.\n*   [`apollo-link-ws`](https://www.npmjs.com/package/apollo-link-ws) - Will establish a WS connection.\n*   [`apollo-link`](https://www.npmjs.com/package/apollo-link) - Will enable WS and HTTP connections co-exist in a single client.\n*   [`apollo-utilities`](https://www.npmjs.com/package/apollo-utilities) - Includes utility functions that will help us analyze a GraphQL AST.\n\nThe WS url can be composed by simply running a regular expression over the `REACT_APP_SERVER_URL` environment variable and is unnecessary to be stored separately. Here's how our new client should look like: \\\n\n\n[{]: <helper> (diffStep 10.1 files=\"client\" module=\"client\")\n\n#### Client Step 10.1: Setup WS link\n\n##### Changed src&#x2F;client.ts\n```diff\n@@ -1,16 +1,42 @@\n ┊ 1┊ 1┊import { InMemoryCache } from 'apollo-cache-inmemory';\n ┊ 2┊ 2┊import { ApolloClient } from 'apollo-client';\n+┊  ┊ 3┊import { getMainDefinition } from 'apollo-utilities';\n ┊ 3┊ 4┊import { HttpLink } from 'apollo-link-http';\n+┊  ┊ 5┊import { WebSocketLink } from 'apollo-link-ws';\n+┊  ┊ 6┊import { ApolloLink, split } from 'apollo-link';\n ┊ 4┊ 7┊\n ┊ 5┊ 8┊const httpUri = process.env.REACT_APP_SERVER_URL + '/graphql';\n+┊  ┊ 9┊const wsUri = httpUri.replace(/^https?/, 'ws');\n ┊ 6┊10┊\n ┊ 7┊11┊const httpLink = new HttpLink({\n ┊ 8┊12┊  uri: httpUri,\n ┊ 9┊13┊});\n ┊10┊14┊\n+┊  ┊15┊const wsLink = new WebSocketLink({\n+┊  ┊16┊  uri: wsUri,\n+┊  ┊17┊  options: {\n+┊  ┊18┊    // Automatic reconnect in case of connection error\n+┊  ┊19┊    reconnect: true,\n+┊  ┊20┊  },\n+┊  ┊21┊});\n+┊  ┊22┊\n+┊  ┊23┊const terminatingLink = split(\n+┊  ┊24┊  ({ query }) => {\n+┊  ┊25┊    const { kind, operation } = getMainDefinition(query);\n+┊  ┊26┊    // If this is a subscription query, use wsLink, otherwise use httpLink\n+┊  ┊27┊    return (\n+┊  ┊28┊      kind === 'OperationDefinition' && operation === 'subscription'\n+┊  ┊29┊    );\n+┊  ┊30┊  },\n+┊  ┊31┊  wsLink,\n+┊  ┊32┊  httpLink,\n+┊  ┊33┊);\n+┊  ┊34┊\n+┊  ┊35┊const link = ApolloLink.from([terminatingLink]);\n+┊  ┊36┊\n ┊11┊37┊const inMemoryCache = new InMemoryCache();\n ┊12┊38┊\n ┊13┊39┊export default new ApolloClient({\n-┊14┊  ┊  link: httpLink,\n+┊  ┊40┊  link,\n ┊15┊41┊  cache: inMemoryCache,\n ┊16┊42┊});\n```\n\n[}]: #\n\nOur subscription listeners should live globally across our application and shouldn't be bound to a specific component, thus we will create an external service which will be responsible of doing so. Using that service, we will update our GraphQL data-store any time a new message has been added. We will define a `messageAdded` subscription in a dedicated file under the `src/graphql/subscriptions` dir where all our subscriptions will be defined and exported:\n\nTODO: - but they are anyway. It’s just a standalone function that is used in a component. Which makes no difference.\n\n[{]: <helper> (diffStep 10.2 module=\"client\")\n\n#### Client Step 10.2: Add messageAdded subscription document\n\n##### Added src&#x2F;graphql&#x2F;subscriptions&#x2F;index.ts\n```diff\n@@ -0,0 +1 @@\n+┊ ┊1┊export { default as messageAdded } from './messageAdded.subscription';\n```\n\n##### Added src&#x2F;graphql&#x2F;subscriptions&#x2F;messageAdded.subscription.ts\n```diff\n@@ -0,0 +1,11 @@\n+┊  ┊ 1┊import gql from 'graphql-tag';\n+┊  ┊ 2┊import * as fragments from '../fragments';\n+┊  ┊ 3┊\n+┊  ┊ 4┊export default gql `\n+┊  ┊ 5┊  subscription MessageAdded {\n+┊  ┊ 6┊    messageAdded {\n+┊  ┊ 7┊      ...Message\n+┊  ┊ 8┊    }\n+┊  ┊ 9┊  }\n+┊  ┊10┊  ${fragments.message}\n+┊  ┊11┊`;\n```\n\n[}]: #\n\nNow we will create the service under the path `services/cache.service.ts`. Like any other GraphQL operation, `react-apollo-hooks` provides us with a dedicated React hook for subscriptions called `useSubscription`. Given the subscription document and the `onSubscriptionData` callback we can handle incoming changes. We will be using GraphQL Code Generator to generate typed subscription hooks, as the `typescript-react-apollo` plug-in supports it right out of the box. First let's update the `codegen.yml` file to look for documents in the `graphql/subscriptions` dir:\n\n[{]: <helper> (diffStep 10.3 module=\"client\")\n\n#### Client Step 10.3: Include subscription documents in codegen.yml\n\n##### Changed codegen.yml\n```diff\n@@ -3,6 +3,7 @@\n ┊3┊3┊  - ./src/components/**/*.tsx\n ┊4┊4┊  - ./src/graphql/fragments/**/*.ts\n ┊5┊5┊  - ./src/graphql/queries/**/*.ts\n+┊ ┊6┊  - ./src/graphql/subscriptions/**/*.ts\n ┊6┊7┊overwrite: true\n ┊7┊8┊generates:\n ┊8┊9┊  ./src/graphql/types.tsx:\n```\n\n[}]: #\n\nAnd then we will type the code generation command:\n\n    $ npm run codegen\n\nNow we can import and use the newly generated hook `useMessageAddedSubscription` in the `cache.service`. Like mentioned earlier, we will be using the `onSubscriptionData` callback to retrieve the change that was sent by the server and we will use it to re-write our cache. In this case we will be writing a new fragment for the incoming message, and we will update the correlated chat:\n\n[{]: <helper> (diffStep 10.4 files=\"cache.service\" module=\"client\")\n\n#### Client Step 10.4: Update cache on message added\n\n##### Added src&#x2F;services&#x2F;cache.service.ts\n```diff\n@@ -0,0 +1,79 @@\n+┊  ┊ 1┊import { DataProxy } from 'apollo-cache';\n+┊  ┊ 2┊import { defaultDataIdFromObject } from 'apollo-cache-inmemory';\n+┊  ┊ 3┊import { ApolloClient } from 'apollo-client';\n+┊  ┊ 4┊import * as fragments from '../graphql/fragments';\n+┊  ┊ 5┊import * as queries from '../graphql/queries';\n+┊  ┊ 6┊import { MessageFragment, useMessageAddedSubscription } from '../graphql/types';\n+┊  ┊ 7┊\n+┊  ┊ 8┊type Client = ApolloClient<any> | DataProxy;\n+┊  ┊ 9┊\n+┊  ┊10┊export const useCacheService = () => {\n+┊  ┊11┊  useMessageAddedSubscription({\n+┊  ┊12┊    onSubscriptionData: ({ client, subscriptionData: { data } }) => {\n+┊  ┊13┊      if (data) {\n+┊  ┊14┊        writeMessage(client, data.messageAdded);\n+┊  ┊15┊      }\n+┊  ┊16┊    }\n+┊  ┊17┊  });\n+┊  ┊18┊};\n+┊  ┊19┊\n+┊  ┊20┊export const writeMessage = (client: Client, message: MessageFragment) => {\n+┊  ┊21┊  type FullChat = { [key: string]: any };\n+┊  ┊22┊  let fullChat;\n+┊  ┊23┊\n+┊  ┊24┊  const chatIdFromStore = defaultDataIdFromObject(message.chat);\n+┊  ┊25┊\n+┊  ┊26┊  if (chatIdFromStore === null) { return; }\n+┊  ┊27┊  try {\n+┊  ┊28┊    fullChat = client.readFragment<FullChat>({\n+┊  ┊29┊      id: chatIdFromStore,\n+┊  ┊30┊      fragment: fragments.fullChat,\n+┊  ┊31┊      fragmentName: 'FullChat',\n+┊  ┊32┊    })\n+┊  ┊33┊  } catch (e) {\n+┊  ┊34┊    return;\n+┊  ┊35┊  }\n+┊  ┊36┊\n+┊  ┊37┊  if (fullChat === null || fullChat.messages === null) { return; }\n+┊  ┊38┊  if (fullChat.messages.some((m: any) => m.id === message.id)) return;\n+┊  ┊39┊\n+┊  ┊40┊  fullChat.messages.push(message);\n+┊  ┊41┊  fullChat.lastMessage = message;\n+┊  ┊42┊\n+┊  ┊43┊  client.writeFragment({\n+┊  ┊44┊    id: chatIdFromStore,\n+┊  ┊45┊    fragment: fragments.fullChat,\n+┊  ┊46┊    fragmentName: 'FullChat',\n+┊  ┊47┊    data: fullChat,\n+┊  ┊48┊  });\n+┊  ┊49┊\n+┊  ┊50┊\n+┊  ┊51┊  let data;\n+┊  ┊52┊  try {\n+┊  ┊53┊    data = client.readQuery({\n+┊  ┊54┊      query: queries.chats,\n+┊  ┊55┊    })\n+┊  ┊56┊  } catch (e) {\n+┊  ┊57┊    return;\n+┊  ┊58┊  };\n+┊  ┊59┊\n+┊  ┊60┊  if (!data) return;\n+┊  ┊61┊  const chats = data.chats;\n+┊  ┊62┊  if (!chats) return;\n+┊  ┊63┊\n+┊  ┊64┊  const chatIndex = chats.findIndex((c: any) => {\n+┊  ┊65┊    if (message === null || message.chat === null) return -1;\n+┊  ┊66┊    return c.id === message.chat.id;\n+┊  ┊67┊  });\n+┊  ┊68┊  if (chatIndex === -1) return;\n+┊  ┊69┊  const chatWhereAdded = chats[chatIndex];\n+┊  ┊70┊\n+┊  ┊71┊  // The chat will appear at the top of the ChatsList component\n+┊  ┊72┊  chats.splice(chatIndex, 1);\n+┊  ┊73┊  chats.unshift(chatWhereAdded);\n+┊  ┊74┊\n+┊  ┊75┊  client.writeQuery({\n+┊  ┊76┊    query: queries.chats,\n+┊  ┊77┊    data: { chats: chats },\n+┊  ┊78┊  });\n+┊  ┊79┊}\n```\n\n[}]: #\n\nWe will also use the exported `writeMessage()` function in the `ChatRoomScreen` so we won't have any code duplications:\n\n[{]: <helper> (diffStep 10.4 files=\"ChatRoom\" module=\"client\")\n\n#### Client Step 10.4: Update cache on message added\n\n##### Changed src&#x2F;components&#x2F;ChatRoomScreen&#x2F;index.tsx\n```diff\n@@ -1,4 +1,3 @@\n-┊1┊ ┊import { defaultDataIdFromObject } from 'apollo-cache-inmemory';\n ┊2┊1┊import gql from 'graphql-tag';\n ┊3┊2┊import React from 'react';\n ┊4┊3┊import { useCallback } from 'react';\n```\n```diff\n@@ -8,8 +7,8 @@\n ┊ 8┊ 7┊import MessagesList from './MessagesList';\n ┊ 9┊ 8┊import { History } from 'history';\n ┊10┊ 9┊import { useGetChatQuery, useAddMessageMutation } from '../../graphql/types';\n-┊11┊  ┊import * as queries from '../../graphql/queries';\n ┊12┊10┊import * as fragments from '../../graphql/fragments';\n+┊  ┊11┊import { writeMessage } from '../../services/cache.service';\n ┊13┊12┊\n ┊14┊13┊ const Container = styled.div `\n ┊15┊14┊  background: url(/assets/chat-background.jpg);\n```\n```diff\n@@ -42,10 +41,6 @@\n ┊42┊41┊  chatId: string\n ┊43┊42┊  history: History;\n ┊44┊43┊};\n-┊45┊  ┊\n-┊46┊  ┊interface ChatsResult {\n-┊47┊  ┊  chats: any[];\n-┊48┊  ┊}\n ┊49┊44┊\n ┊50┊45┊const ChatRoomScreen: React.FC<ChatRoomScreenParams> = ({ history, chatId }) => {\n ┊51┊46┊  const { data, loading } = useGetChatQuery({\n```\n```diff\n@@ -72,62 +67,9 @@\n ┊ 72┊ 67┊        }\n ┊ 73┊ 68┊      },\n ┊ 74┊ 69┊      update: (client, { data: { addMessage } }) => {\n-┊ 75┊   ┊        type FullChat = { [key: string]: any };\n-┊ 76┊   ┊        let fullChat;\n-┊ 77┊   ┊        const chatIdFromStore = defaultDataIdFromObject(chat);\n-┊ 78┊   ┊\n-┊ 79┊   ┊        if (chatIdFromStore === null) { return; }\n-┊ 80┊   ┊\n-┊ 81┊   ┊        try {\n-┊ 82┊   ┊          fullChat = client.readFragment<FullChat>({\n-┊ 83┊   ┊            id: chatIdFromStore,\n-┊ 84┊   ┊            fragment: fragments.fullChat,\n-┊ 85┊   ┊            fragmentName: 'FullChat',\n-┊ 86┊   ┊          });\n-┊ 87┊   ┊        } catch (e) {\n-┊ 88┊   ┊          return;\n-┊ 89┊   ┊        }\n-┊ 90┊   ┊\n-┊ 91┊   ┊        if (fullChat === null) { return; }\n-┊ 92┊   ┊        if (fullChat.messages.some((m:any) => m.id === addMessage.id)) return;\n-┊ 93┊   ┊\n-┊ 94┊   ┊        fullChat.messages.push(addMessage);\n-┊ 95┊   ┊        fullChat.lastMessage = addMessage;\n-┊ 96┊   ┊\n-┊ 97┊   ┊        client.writeFragment({\n-┊ 98┊   ┊          id: chatIdFromStore,\n-┊ 99┊   ┊          fragment: fragments.fullChat,\n-┊100┊   ┊          fragmentName: 'FullChat',\n-┊101┊   ┊          data: fullChat,\n-┊102┊   ┊        });\n-┊103┊   ┊\n-┊104┊   ┊        let data;\n-┊105┊   ┊        try {\n-┊106┊   ┊          data = client.readQuery<ChatsResult>({\n-┊107┊   ┊            query: queries.chats,\n-┊108┊   ┊          });\n-┊109┊   ┊        } catch (e) {\n-┊110┊   ┊          return;\n-┊111┊   ┊        }\n-┊112┊   ┊\n-┊113┊   ┊        if (!data) return;\n-┊114┊   ┊        const chats = data.chats;\n-┊115┊   ┊        if (!chats) return;\n-┊116┊   ┊\n-┊117┊   ┊        const chatIndex = chats.findIndex((c:any) => c.id === chatId);\n-┊118┊   ┊        if (chatIndex === -1) return;\n-┊119┊   ┊        const chatWhereAdded = chats[chatIndex];\n-┊120┊   ┊\n-┊121┊   ┊        // The chat will appear at the top of the ChatsList component\n-┊122┊   ┊        chats.splice(chatIndex, 1);\n-┊123┊   ┊        chats.unshift(chatWhereAdded);\n-┊124┊   ┊\n-┊125┊   ┊        client.writeQuery({\n-┊126┊   ┊          query: queries.chats,\n-┊127┊   ┊          data: { chats: chats },\n-┊128┊   ┊        });\n-┊129┊   ┊      }\n-┊130┊   ┊    });\n+┊   ┊ 70┊        writeMessage(client, addMessage);\n+┊   ┊ 71┊      },\n+┊   ┊ 72┊    })\n ┊131┊ 73┊  }, [data, chatId, addMessage]);\n ┊132┊ 74┊\n ┊133┊ 75┊  if (data === undefined) {\n```\n\n[}]: #\n\nOne thing missing that you might notice is that we're trying to retrieve the chat from the received message, unfortunately our GraphQL schema doesn't support it and we will need to add it. On the server, we will add a `chat` field to the `Message` type in the GraphQL schema, and we will implement a resolver which will lookup for the chat in the chats collection:\n\n[{]: <helper> (diffStep 7.7 module=\"server\")\n\n#### [Server Step 7.7: Add Message.chat resolver](https://github.com/Urigo/WhatsApp-Clone-Server/commit/19f77a3)\n\n##### Changed schema&#x2F;resolvers.ts\n```diff\n@@ -5,6 +5,12 @@\n ┊ 5┊ 5┊const resolvers: Resolvers = {\n ┊ 6┊ 6┊  Date: GraphQLDateTime,\n ┊ 7┊ 7┊\n+┊  ┊ 8┊  Message: {\n+┊  ┊ 9┊    chat(message) {\n+┊  ┊10┊      return chats.find(c => c.messages.some(m => m === message.id)) || null\n+┊  ┊11┊    },\n+┊  ┊12┊  },\n+┊  ┊13┊\n ┊ 8┊14┊  Chat: {\n ┊ 9┊15┊    messages(chat) {\n ┊10┊16┊      return messages.filter(m => chat.messages.includes(m.id))\n```\n\n##### Changed schema&#x2F;typeDefs.graphql\n```diff\n@@ -4,6 +4,7 @@\n ┊ 4┊ 4┊  id: ID!\n ┊ 5┊ 5┊  content: String!\n ┊ 6┊ 6┊  createdAt: Date!\n+┊  ┊ 7┊  chat: Chat\n ┊ 7┊ 8┊}\n ┊ 8┊ 9┊\n ┊ 9┊10┊type Chat {\n```\n\n[}]: #\n\nNow that we have it supported we can update the `Message` fragment in the client to include that information. We don't need the entire chat, only its ID, since the fragment ID composition is done out of an ID and type name:\n\n[{]: <helper> (diffStep 10.5 module=\"client\")\n\n#### Client Step 10.5: Add chat.id to message fragment\n\n##### Changed src&#x2F;components&#x2F;ChatRoomScreen&#x2F;index.tsx\n```diff\n@@ -63,6 +63,10 @@\n ┊63┊63┊          __typename: 'Message',\n ┊64┊64┊          id: Math.random().toString(36).substr(2, 9),\n ┊65┊65┊          createdAt: new Date(),\n+┊  ┊66┊          chat: {\n+┊  ┊67┊            __typename: 'Chat',\n+┊  ┊68┊            id: chatId,\n+┊  ┊69┊          },\n ┊66┊70┊          content,\n ┊67┊71┊        }\n ┊68┊72┊      },\n```\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;ChatsList.test.tsx\n```diff\n@@ -30,6 +30,10 @@\n ┊30┊30┊                  id: 1,\n ┊31┊31┊                  content: 'Hello',\n ┊32┊32┊                  createdAt: new Date('14 Jun 2017 00:00:00 PDT').toUTCString(),\n+┊  ┊33┊                  chat: {\n+┊  ┊34┊                    __typename: 'Chat',\n+┊  ┊35┊                    id: 1,\n+┊  ┊36┊                  },\n ┊33┊37┊                },\n ┊34┊38┊              },\n ┊35┊39┊            ],\n```\n```diff\n@@ -71,6 +75,10 @@\n ┊71┊75┊                  id: 1,\n ┊72┊76┊                  content: 'Hello',\n ┊73┊77┊                  createdAt: new Date(0),\n+┊  ┊78┊                  chat: {\n+┊  ┊79┊                    __typename: 'Chat',\n+┊  ┊80┊                    id: 1,\n+┊  ┊81┊                  },\n ┊74┊82┊                },\n ┊75┊83┊              },\n ┊76┊84┊            ],\n```\n\n##### Changed src&#x2F;graphql&#x2F;fragments&#x2F;message.fragment.ts\n```diff\n@@ -5,5 +5,8 @@\n ┊ 5┊ 5┊    id\n ┊ 6┊ 6┊    createdAt\n ┊ 7┊ 7┊    content\n+┊  ┊ 8┊    chat {\n+┊  ┊ 9┊      id\n+┊  ┊10┊    }\n ┊ 8┊11┊  }\n ┊ 9┊12┊`;\n```\n\n[}]: #\n\nFinally, we will import the `useCacheService` React hook that we've just created and we will use it in our main `App` component. This means that the cache service will start listening for changes right as the app component is mounted:\n\n[{]: <helper> (diffStep 10.6 module=\"client\")\n\n#### Client Step 10.6: Use cache service\n\n##### Changed src&#x2F;App.tsx\n```diff\n@@ -3,21 +3,26 @@\n ┊ 3┊ 3┊import ChatRoomScreen from './components/ChatRoomScreen';\n ┊ 4┊ 4┊import ChatsListScreen from './components/ChatsListScreen';\n ┊ 5┊ 5┊import AnimatedSwitch from './components/AnimatedSwitch';\n+┊  ┊ 6┊import { useCacheService } from './services/cache.service';\n ┊ 6┊ 7┊\n-┊ 7┊  ┊const App: React.FC = () => (\n-┊ 8┊  ┊  <BrowserRouter>\n-┊ 9┊  ┊    <AnimatedSwitch>\n-┊10┊  ┊      <Route exact path=\"/chats\" component={ChatsListScreen} />\n+┊  ┊ 8┊const App: React.FC = () => {\n+┊  ┊ 9┊  useCacheService();\n ┊11┊10┊\n-┊12┊  ┊      <Route exact path=\"/chats/:chatId\" component={\n-┊13┊  ┊        ({ match, history }: RouteComponentProps<{ chatId: string }>) =>\n-┊14┊  ┊        (<ChatRoomScreen chatId={match.params.chatId} history={history} />)\n-┊15┊  ┊      } />\n+┊  ┊11┊  return (\n+┊  ┊12┊    <BrowserRouter>\n+┊  ┊13┊      <AnimatedSwitch>\n+┊  ┊14┊        <Route exact path=\"/chats\" component={ChatsListScreen} />\n ┊16┊15┊\n-┊17┊  ┊    </AnimatedSwitch>\n-┊18┊  ┊    <Route exact path=\"/\" render={redirectToChats} />\n-┊19┊  ┊  </BrowserRouter>\n-┊20┊  ┊);\n+┊  ┊16┊        <Route exact path=\"/chats/:chatId\" component={\n+┊  ┊17┊          ({ match, history }: RouteComponentProps<{ chatId: string }>) =>\n+┊  ┊18┊          (<ChatRoomScreen chatId={match.params.chatId} history={history} />)\n+┊  ┊19┊        } />\n+┊  ┊20┊\n+┊  ┊21┊      </AnimatedSwitch>\n+┊  ┊22┊      <Route exact path=\"/\" render={redirectToChats} />\n+┊  ┊23┊    </BrowserRouter>\n+┊  ┊24┊  );\n+┊  ┊25┊};\n ┊21┊26┊\n ┊22┊27┊const redirectToChats = () => (\n ┊23┊28┊  <Redirect to=\"/chats\" />\n```\n\n[}]: #\n\nSubscription handling is complete! If you'll try to repeat the same process again where you check messages updating between 2 instances of the app, you should see them both update.\n\n-------\n\nTODO: `useCacheService` shouldn’t be called like that since it’s related to message events and cache updates are only side-effects."
          },
          {
            "manualTitle": "Step 11: Users",
            "stepRevision": "689df04c93f5d49a946de533243bbf71d328fd91",
            "manualView": "Our chat app is pretty functional. We can pick a chat from the chats list and we can send messages. It's not hard to notice that one of the most important mechanisms is missing, which is relating a chat or a message to a specific user. Even though we can send messages, it's basically pointless unless someone else receives it. In this chapter we will create a new users collection with pre-defined documents and we will learn how to simulate authentication programmatically so we can test the new mechanism.\n\n**Reshaping the back-end**\n\nTo implement this feature we need to rethink our back-end and reshape the way our GraphQL schema is structured. Right now we only have 2 entities: Chat and Message, which are connected like so:\n\n\n\n![chat-message-orm](https://user-images.githubusercontent.com/7648874/55325929-0faa1b00-54b9-11e9-8868-7a8ed3edcda1.png)\n\n\nWe want to have a new User entity where each user will have Chats he participates in and Messages he owns. Therefore, our new GraphQL schema should look like something like this:\n\n\n\n![chat-message-user-orm](https://user-images.githubusercontent.com/7648874/55325935-146ecf00-54b9-11e9-8c0f-bc3b63cbe676.png)\n\nThis change would require us to update the GraphQL type definitions and handlers, the DB models, and the codegen configuration file:\n\n[{]: <helper> (diffStep 8.1 module=\"server\")\n\n#### [Server Step 8.1: Add User type](https://github.com/Urigo/WhatsApp-Clone-Server/commit/8400014)\n\n##### Changed codegen.yml\n```diff\n@@ -10,6 +10,7 @@\n ┊10┊10┊      mappers:\n ┊11┊11┊        # import { Message } from '../db'\n ┊12┊12┊        # The root types of Message resolvers\n+┊  ┊13┊        User: ../db#User\n ┊13┊14┊        Message: ../db#Message\n ┊14┊15┊        Chat: ../db#Chat\n ┊15┊16┊      scalars:\n```\n\n##### Changed db.ts\n```diff\n@@ -1,66 +1,106 @@\n+┊   ┊  1┊export type User = {\n+┊   ┊  2┊  id: string\n+┊   ┊  3┊  name: string\n+┊   ┊  4┊  picture: string\n+┊   ┊  5┊}\n+┊   ┊  6┊\n ┊  1┊  7┊export type Message = {\n ┊  2┊  8┊  id: string\n ┊  3┊  9┊  content: string\n ┊  4┊ 10┊  createdAt: Date\n+┊   ┊ 11┊  sender: string\n+┊   ┊ 12┊  recipient: string\n ┊  5┊ 13┊}\n ┊  6┊ 14┊\n ┊  7┊ 15┊export type Chat = {\n ┊  8┊ 16┊  id: string\n-┊  9┊   ┊  name: string\n-┊ 10┊   ┊  picture: string\n ┊ 11┊ 17┊  messages: string[]\n+┊   ┊ 18┊  participants: string[]\n ┊ 12┊ 19┊}\n ┊ 13┊ 20┊\n+┊   ┊ 21┊export const users: User[] = []\n ┊ 14┊ 22┊export const messages: Message[] = []\n ┊ 15┊ 23┊export const chats: Chat[] = []\n ┊ 16┊ 24┊\n ┊ 17┊ 25┊export const resetDb = () => {\n+┊   ┊ 26┊  users.splice(0, Infinity, ...[\n+┊   ┊ 27┊    {\n+┊   ┊ 28┊      id: '1',\n+┊   ┊ 29┊      name: 'Ray Edwards',\n+┊   ┊ 30┊      picture: 'https://randomuser.me/api/portraits/thumb/lego/1.jpg',\n+┊   ┊ 31┊    },\n+┊   ┊ 32┊    {\n+┊   ┊ 33┊      id: '2',\n+┊   ┊ 34┊      name: 'Ethan Gonzalez',\n+┊   ┊ 35┊      picture: 'https://randomuser.me/api/portraits/thumb/men/1.jpg',\n+┊   ┊ 36┊    },\n+┊   ┊ 37┊    {\n+┊   ┊ 38┊      id: '3',\n+┊   ┊ 39┊      name: 'Bryan Wallace',\n+┊   ┊ 40┊      picture: 'https://randomuser.me/api/portraits/thumb/men/2.jpg',\n+┊   ┊ 41┊    },\n+┊   ┊ 42┊    {\n+┊   ┊ 43┊      id: '4',\n+┊   ┊ 44┊      name: 'Avery Stewart',\n+┊   ┊ 45┊      picture: 'https://randomuser.me/api/portraits/thumb/women/1.jpg',\n+┊   ┊ 46┊    },\n+┊   ┊ 47┊    {\n+┊   ┊ 48┊      id: '5',\n+┊   ┊ 49┊      name: 'Katie Peterson',\n+┊   ┊ 50┊      picture: 'https://randomuser.me/api/portraits/thumb/women/2.jpg',\n+┊   ┊ 51┊    },\n+┊   ┊ 52┊  ])\n+┊   ┊ 53┊\n ┊ 18┊ 54┊  messages.splice(0, Infinity, ...[\n ┊ 19┊ 55┊    {\n ┊ 20┊ 56┊      id: '1',\n ┊ 21┊ 57┊      content: \"You on your way?\",\n ┊ 22┊ 58┊      createdAt: new Date(new Date('1-1-2019').getTime() - 60 * 1000 * 1000),\n+┊   ┊ 59┊      sender: '1',\n+┊   ┊ 60┊      recipient: '2',\n ┊ 23┊ 61┊    },\n ┊ 24┊ 62┊    {\n ┊ 25┊ 63┊      id: '2',\n ┊ 26┊ 64┊      content: \"Hey, it's me\",\n ┊ 27┊ 65┊      createdAt: new Date(new Date('1-1-2019').getTime() - 2 * 60 * 1000 * 1000),\n+┊   ┊ 66┊      sender: '1',\n+┊   ┊ 67┊      recipient: '3',\n ┊ 28┊ 68┊    },\n ┊ 29┊ 69┊    {\n ┊ 30┊ 70┊      id: '3',\n ┊ 31┊ 71┊      content: \"I should buy a boat\",\n ┊ 32┊ 72┊      createdAt: new Date(new Date('1-1-2019').getTime() - 24 * 60 * 1000 * 1000),\n+┊   ┊ 73┊      sender: '1',\n+┊   ┊ 74┊      recipient: '4',\n ┊ 33┊ 75┊    },\n ┊ 34┊ 76┊    {\n ┊ 35┊ 77┊      id: '4',\n ┊ 36┊ 78┊      content: \"This is wicked good ice cream.\",\n ┊ 37┊ 79┊      createdAt: new Date(new Date('1-1-2019').getTime() - 14 * 24 * 60 * 1000 * 1000),\n+┊   ┊ 80┊      sender: '1',\n+┊   ┊ 81┊      recipient: '5',\n ┊ 38┊ 82┊    },\n ┊ 39┊ 83┊  ])\n ┊ 40┊ 84┊\n ┊ 41┊ 85┊  chats.splice(0, Infinity, ...[\n ┊ 42┊ 86┊    {\n ┊ 43┊ 87┊      id: '1',\n-┊ 44┊   ┊      name: 'Ethan Gonzalez',\n-┊ 45┊   ┊      picture: 'https://randomuser.me/api/portraits/thumb/men/1.jpg',\n+┊   ┊ 88┊      participants: ['1', '2'],\n ┊ 46┊ 89┊      messages: ['1'],\n ┊ 47┊ 90┊    },\n ┊ 48┊ 91┊    {\n ┊ 49┊ 92┊      id: '2',\n-┊ 50┊   ┊      name: 'Bryan Wallace',\n-┊ 51┊   ┊      picture: 'https://randomuser.me/api/portraits/thumb/men/2.jpg',\n+┊   ┊ 93┊      participants: ['1', '3'],\n ┊ 52┊ 94┊      messages: ['2'],\n ┊ 53┊ 95┊    },\n ┊ 54┊ 96┊    {\n ┊ 55┊ 97┊      id: '3',\n-┊ 56┊   ┊      name: 'Avery Stewart',\n-┊ 57┊   ┊      picture: 'https://randomuser.me/api/portraits/thumb/women/1.jpg',\n+┊   ┊ 98┊      participants: ['1', '4'],\n ┊ 58┊ 99┊      messages: ['3'],\n ┊ 59┊100┊    },\n ┊ 60┊101┊    {\n ┊ 61┊102┊      id: '4',\n-┊ 62┊   ┊      name: 'Katie Peterson',\n-┊ 63┊   ┊      picture: 'https://randomuser.me/api/portraits/thumb/women/2.jpg',\n+┊   ┊103┊      participants: ['1', '5'],\n ┊ 64┊104┊      messages: ['4'],\n ┊ 65┊105┊    },\n ┊ 66┊106┊  ])\n```\n\n##### Changed schema&#x2F;resolvers.ts\n```diff\n@@ -1,5 +1,5 @@\n ┊1┊1┊import { GraphQLDateTime } from 'graphql-iso-date'\n-┊2┊ ┊import { Message, chats, messages } from '../db'\n+┊ ┊2┊import { User, Message, chats, messages, users } from '../db'\n ┊3┊3┊import { Resolvers } from '../types/graphql'\n ┊4┊4┊\n ┊5┊5┊const resolvers: Resolvers = {\n```\n```diff\n@@ -9,9 +9,27 @@\n ┊ 9┊ 9┊    chat(message) {\n ┊10┊10┊      return chats.find(c => c.messages.some(m => m === message.id)) || null\n ┊11┊11┊    },\n+┊  ┊12┊\n+┊  ┊13┊    sender(message) {\n+┊  ┊14┊      return users.find(u => u.id === message.sender) || null\n+┊  ┊15┊    },\n+┊  ┊16┊\n+┊  ┊17┊    recipient(message) {\n+┊  ┊18┊      return users.find(u => u.id === message.recipient) || null\n+┊  ┊19┊    },\n ┊12┊20┊  },\n ┊13┊21┊\n ┊14┊22┊  Chat: {\n+┊  ┊23┊    name() {\n+┊  ┊24┊      // TODO: Resolve in relation to current user\n+┊  ┊25┊      return null\n+┊  ┊26┊    },\n+┊  ┊27┊\n+┊  ┊28┊    picture() {\n+┊  ┊29┊      // TODO: Resolve in relation to current user\n+┊  ┊30┊      return null\n+┊  ┊31┊    },\n+┊  ┊32┊\n ┊15┊33┊    messages(chat) {\n ┊16┊34┊      return messages.filter(m => chat.messages.includes(m.id))\n ┊17┊35┊    },\n```\n```diff\n@@ -21,6 +39,10 @@\n ┊21┊39┊\n ┊22┊40┊      return messages.find(m => m.id === lastMessage) || null\n ┊23┊41┊    },\n+┊  ┊42┊\n+┊  ┊43┊    participants(chat) {\n+┊  ┊44┊      return chat.participants.map(p => users.find(u => u.id === p)).filter(Boolean) as User[]\n+┊  ┊45┊    },\n ┊24┊46┊  },\n ┊25┊47┊\n ┊26┊48┊  Query: {\n```\n```diff\n@@ -45,6 +67,8 @@\n ┊45┊67┊      const message: Message = {\n ┊46┊68┊        id: messageId,\n ┊47┊69┊        createdAt: new Date(),\n+┊  ┊70┊        sender: '', // TODO: Fill-in\n+┊  ┊71┊        recipient: '', // TODO: Fill-in\n ┊48┊72┊        content,\n ┊49┊73┊      }\n ┊50┊74┊\n```\n\n##### Changed schema&#x2F;typeDefs.graphql\n```diff\n@@ -1,18 +1,28 @@\n ┊ 1┊ 1┊scalar Date\n ┊ 2┊ 2┊\n+┊  ┊ 3┊type User {\n+┊  ┊ 4┊  id: ID!\n+┊  ┊ 5┊  name: String!\n+┊  ┊ 6┊  picture: String\n+┊  ┊ 7┊}\n+┊  ┊ 8┊\n ┊ 3┊ 9┊type Message {\n ┊ 4┊10┊  id: ID!\n ┊ 5┊11┊  content: String!\n ┊ 6┊12┊  createdAt: Date!\n ┊ 7┊13┊  chat: Chat\n+┊  ┊14┊  sender: User\n+┊  ┊15┊  recipient: User\n+┊  ┊16┊  isMine: Boolean!\n ┊ 8┊17┊}\n ┊ 9┊18┊\n ┊10┊19┊type Chat {\n ┊11┊20┊  id: ID!\n-┊12┊  ┊  name: String!\n+┊  ┊21┊  name: String\n ┊13┊22┊  picture: String\n ┊14┊23┊  lastMessage: Message\n ┊15┊24┊  messages: [Message!]!\n+┊  ┊25┊  participants: [User!]!\n ┊16┊26┊}\n ┊17┊27┊\n ┊18┊28┊type Query {\n```\n\n[}]: #\n\nEven though we made these changes, the app remained the same. That's because the Query type haven't changed at all, and we still serve the same data as before. What we need to do is to edit the Query resolvers to serve data based on the user that is currently logged-in to the app in the current session. Before we go all in with a robust authentication system, it would be smarter to simulate it, so we can test our app and see that everything works as intended.\n\nFor now, let's assume that we're logged in with user of ID 1 - Ray Edwards. Codewise, this would mean that we will need to have the current user defined on the resolver context. In the main file, let's add the `currentUser` field to the context using a simple `find()` method from our `users` collection:\n\n[{]: <helper> (diffStep 8.2 files=\"index.ts\" module=\"server\")\n\n#### [Server Step 8.2: Resolve queries in relation to current user](https://github.com/Urigo/WhatsApp-Clone-Server/commit/5fc7bfd)\n\n##### Changed index.ts\n```diff\n@@ -3,6 +3,7 @@\n ┊3┊3┊import cors from 'cors'\n ┊4┊4┊import express from 'express'\n ┊5┊5┊import http from 'http'\n+┊ ┊6┊import { users } from './db'\n ┊6┊7┊import schema from './schema'\n ┊7┊8┊\n ┊8┊9┊const app = express()\n```\n```diff\n@@ -17,7 +18,10 @@\n ┊17┊18┊const pubsub = new PubSub()\n ┊18┊19┊const server = new ApolloServer({\n ┊19┊20┊  schema,\n-┊20┊  ┊  context: () => ({ pubsub }),\n+┊  ┊21┊  context: () => ({\n+┊  ┊22┊    currentUser: users.find(u => u.id === '1'),\n+┊  ┊23┊    pubsub,\n+┊  ┊24┊  }),\n ┊21┊25┊})\n ┊22┊26┊\n ┊23┊27┊server.applyMiddleware({\n```\n\n[}]: #\n\nAnd we will update the context type:\n\n[{]: <helper> (diffStep 8.2 files=\"context\" module=\"server\")\n\n#### [Server Step 8.2: Resolve queries in relation to current user](https://github.com/Urigo/WhatsApp-Clone-Server/commit/5fc7bfd)\n\n##### Changed context.ts\n```diff\n@@ -1,5 +1,7 @@\n ┊1┊1┊import { PubSub } from 'apollo-server-express'\n+┊ ┊2┊import { User } from './db'\n ┊2┊3┊\n ┊3┊4┊export type MyContext = {\n-┊4┊ ┊  pubsub: PubSub\n+┊ ┊5┊  pubsub: PubSub,\n+┊ ┊6┊  currentUser: User,\n ┊5┊7┊}\n```\n\n[}]: #\n\nNow we will update the resolvers to fetch data relatively to the current user logged in. If there's no user logged in, the resolvers should return `null`, as the client is not authorized to view the data he requested:\n\n[{]: <helper> (diffStep 8.2 files=\"schema, tests\" module=\"server\")\n\n#### [Server Step 8.2: Resolve queries in relation to current user](https://github.com/Urigo/WhatsApp-Clone-Server/commit/5fc7bfd)\n\n##### Changed schema&#x2F;resolvers.ts\n```diff\n@@ -17,17 +17,35 @@\n ┊17┊17┊    recipient(message) {\n ┊18┊18┊      return users.find(u => u.id === message.recipient) || null\n ┊19┊19┊    },\n+┊  ┊20┊\n+┊  ┊21┊    isMine(message, args, { currentUser }) {\n+┊  ┊22┊      return message.sender === currentUser.id\n+┊  ┊23┊    },\n ┊20┊24┊  },\n ┊21┊25┊\n ┊22┊26┊  Chat: {\n-┊23┊  ┊    name() {\n-┊24┊  ┊      // TODO: Resolve in relation to current user\n-┊25┊  ┊      return null\n+┊  ┊27┊    name(chat, args, { currentUser }) {\n+┊  ┊28┊      if (!currentUser) return null\n+┊  ┊29┊\n+┊  ┊30┊      const participantId = chat.participants.find(p => p !== currentUser.id)\n+┊  ┊31┊\n+┊  ┊32┊      if (!participantId) return null\n+┊  ┊33┊\n+┊  ┊34┊      const participant = users.find(u => u.id === participantId)\n+┊  ┊35┊\n+┊  ┊36┊      return participant ? participant.name : null\n ┊26┊37┊    },\n ┊27┊38┊\n-┊28┊  ┊    picture() {\n-┊29┊  ┊      // TODO: Resolve in relation to current user\n-┊30┊  ┊      return null\n+┊  ┊39┊    picture(chat, args, { currentUser }) {\n+┊  ┊40┊      if (!currentUser) return null\n+┊  ┊41┊\n+┊  ┊42┊      const participantId = chat.participants.find(p => p !== currentUser.id)\n+┊  ┊43┊\n+┊  ┊44┊      if (!participantId) return null\n+┊  ┊45┊\n+┊  ┊46┊      const participant = users.find(u => u.id === participantId)\n+┊  ┊47┊\n+┊  ┊48┊      return participant ? participant.picture : null\n ┊31┊49┊    },\n ┊32┊50┊\n ┊33┊51┊    messages(chat) {\n```\n```diff\n@@ -46,29 +64,42 @@\n ┊ 46┊ 64┊  },\n ┊ 47┊ 65┊\n ┊ 48┊ 66┊  Query: {\n-┊ 49┊   ┊    chats() {\n-┊ 50┊   ┊      return chats\n+┊   ┊ 67┊    chats(root, args, { currentUser }) {\n+┊   ┊ 68┊      if (!currentUser) return []\n+┊   ┊ 69┊\n+┊   ┊ 70┊      return chats.filter(c => c.participants.includes(currentUser.id))\n ┊ 51┊ 71┊    },\n ┊ 52┊ 72┊\n-┊ 53┊   ┊    chat(root, { chatId }) {\n-┊ 54┊   ┊      return chats.find(c => c.id === chatId) || null\n+┊   ┊ 73┊    chat(root, { chatId }, { currentUser }) {\n+┊   ┊ 74┊      if (!currentUser) return null\n+┊   ┊ 75┊\n+┊   ┊ 76┊      const chat = chats.find(c => c.id === chatId)\n+┊   ┊ 77┊\n+┊   ┊ 78┊      if (!chat) return null\n+┊   ┊ 79┊\n+┊   ┊ 80┊      return chat.participants.includes(currentUser.id) ? chat : null\n ┊ 55┊ 81┊    },\n ┊ 56┊ 82┊  },\n ┊ 57┊ 83┊\n ┊ 58┊ 84┊  Mutation: {\n-┊ 59┊   ┊    addMessage(root, { chatId, content }, { pubsub }) {\n+┊   ┊ 85┊    addMessage(root, { chatId, content }, { currentUser, pubsub }) {\n+┊   ┊ 86┊      if (!currentUser) return null\n+┊   ┊ 87┊\n ┊ 60┊ 88┊      const chatIndex = chats.findIndex(c => c.id === chatId)\n ┊ 61┊ 89┊\n ┊ 62┊ 90┊      if (chatIndex === -1) return null\n ┊ 63┊ 91┊\n ┊ 64┊ 92┊      const chat = chats[chatIndex]\n+┊   ┊ 93┊\n+┊   ┊ 94┊      if (!chat.participants.includes(currentUser.id)) return null\n+┊   ┊ 95┊\n ┊ 65┊ 96┊      const recentMessage = messages[messages.length - 1]\n ┊ 66┊ 97┊      const messageId = String(Number(recentMessage.id) + 1)\n ┊ 67┊ 98┊      const message: Message = {\n ┊ 68┊ 99┊        id: messageId,\n ┊ 69┊100┊        createdAt: new Date(),\n-┊ 70┊   ┊        sender: '', // TODO: Fill-in\n-┊ 71┊   ┊        recipient: '', // TODO: Fill-in\n+┊   ┊101┊        sender: currentUser.id,\n+┊   ┊102┊        recipient: chat.participants.find(p => p !== currentUser.id) as string,\n ┊ 72┊103┊        content,\n ┊ 73┊104┊      }\n ┊ 74┊105┊\n```\n\n##### Changed tests&#x2F;mutations&#x2F;addMessage.test.ts\n```diff\n@@ -1,7 +1,7 @@\n ┊1┊1┊import { createTestClient } from 'apollo-server-testing'\n ┊2┊2┊import { ApolloServer, PubSub, gql } from 'apollo-server-express'\n ┊3┊3┊import schema from '../../schema'\n-┊4┊ ┊import { resetDb } from '../../db'\n+┊ ┊4┊import { resetDb, users } from '../../db'\n ┊5┊5┊\n ┊6┊6┊describe('Mutation.addMessage', () => {\n ┊7┊7┊  beforeEach(resetDb)\n```\n```diff\n@@ -9,7 +9,10 @@\n ┊ 9┊ 9┊  it('should add message to specified chat', async () => {\n ┊10┊10┊    const server = new ApolloServer({\n ┊11┊11┊      schema,\n-┊12┊  ┊      context: () => ({ pubsub: new PubSub() }),\n+┊  ┊12┊      context: () => ({\n+┊  ┊13┊        pubsub: new PubSub(),\n+┊  ┊14┊        currentUser: users[0],\n+┊  ┊15┊      }),\n ┊13┊16┊    })\n ┊14┊17┊\n ┊15┊18┊    const { query, mutate } = createTestClient(server)\n```\n\n##### Changed tests&#x2F;queries&#x2F;getChat.test.ts\n```diff\n@@ -1,10 +1,16 @@\n ┊ 1┊ 1┊import { createTestClient } from 'apollo-server-testing'\n ┊ 2┊ 2┊import { ApolloServer, gql } from 'apollo-server-express'\n ┊ 3┊ 3┊import schema from '../../schema'\n+┊  ┊ 4┊import { users } from '../../db'\n ┊ 4┊ 5┊\n ┊ 5┊ 6┊describe('Query.chat', () => {\n ┊ 6┊ 7┊  it('should fetch specified chat', async () => {\n-┊ 7┊  ┊    const server = new ApolloServer({ schema })\n+┊  ┊ 8┊    const server = new ApolloServer({\n+┊  ┊ 9┊      schema,\n+┊  ┊10┊      context: () => ({\n+┊  ┊11┊        currentUser: users[0],\n+┊  ┊12┊      }),\n+┊  ┊13┊    })\n ┊ 8┊14┊\n ┊ 9┊15┊    const { query } = createTestClient(server)\n ┊10┊16┊\n```\n\n##### Changed tests&#x2F;queries&#x2F;getChats.test.ts\n```diff\n@@ -1,10 +1,16 @@\n ┊ 1┊ 1┊import { createTestClient } from 'apollo-server-testing'\n ┊ 2┊ 2┊import { ApolloServer, gql } from 'apollo-server-express'\n ┊ 3┊ 3┊import schema from '../../schema'\n+┊  ┊ 4┊import { users } from '../../db'\n ┊ 4┊ 5┊\n ┊ 5┊ 6┊describe('Query.chats', () => {\n ┊ 6┊ 7┊  it('should fetch all chats', async () => {\n-┊ 7┊  ┊    const server = new ApolloServer({ schema })\n+┊  ┊ 8┊    const server = new ApolloServer({\n+┊  ┊ 9┊      schema,\n+┊  ┊10┊      context: () => ({\n+┊  ┊11┊        currentUser: users[0],\n+┊  ┊12┊      }),\n+┊  ┊13┊    })\n ┊ 8┊14┊\n ┊ 9┊15┊    const { query } = createTestClient(server)\n```\n\n[}]: #\n\nNow if we will get back to the app and refresh the page, we should see a new chats list which is only relevant to Ray Edwards. Earlier in this chapter, we've defined a new `isMine` field on the `Message` type. This field is useful because now we can differentiate between messages that are mine and messages that belong to the recipient. We can use that information to distinct between messages in our UI.\n\nLet's first download a new image that will help us achieve the new style and save it under the [`src/public/assets/message-yours.png`](https://github.com/Urigo/WhatsApp-Clone-Client-React/blob/cordova/public/assets/message-other.png?raw=true) path. Then let's implement the new style:\n\n[{]: <helper> (diffStep 11.1 files=\"src/components\" module=\"client\")\n\n#### Client Step 11.1: Distinguish messages\n\n##### Changed src&#x2F;components&#x2F;ChatRoomScreen&#x2F;MessagesList.tsx\n```diff\n@@ -2,7 +2,7 @@\n ┊2┊2┊import React from 'react';\n ┊3┊3┊import { useEffect, useRef } from 'react';\n ┊4┊4┊import ReactDOM from 'react-dom';\n-┊5┊ ┊import styled from 'styled-components';\n+┊ ┊5┊import styled, { css } from 'styled-components';\n ┊6┊6┊\n ┊7┊7┊const Container = styled.div`\n ┊8┊8┊  display: block;\n```\n```diff\n@@ -11,9 +11,11 @@\n ┊11┊11┊  padding: 0 15px;\n ┊12┊12┊`;\n ┊13┊13┊\n+┊  ┊14┊type StyledProp = {\n+┊  ┊15┊  isMine: any;\n+┊  ┊16┊};\n+┊  ┊17┊\n ┊14┊18┊const MessageItem = styled.div `\n-┊15┊  ┊  float: right;\n-┊16┊  ┊  background-color: #dcf8c6;\n ┊17┊19┊  display: inline-block;\n ┊18┊20┊  position: relative;\n ┊19┊21┊  max-width: 100%;\n```\n```diff\n@@ -30,17 +32,33 @@\n ┊30┊32┊  }\n ┊31┊33┊\n ┊32┊34┊  &::before {\n-┊33┊  ┊    background-image: url(/assets/message-mine.png);\n ┊34┊35┊    content: '';\n ┊35┊36┊    position: absolute;\n ┊36┊37┊    bottom: 3px;\n ┊37┊38┊    width: 12px;\n ┊38┊39┊    height: 19px;\n-┊39┊  ┊    right: -11px;\n ┊40┊40┊    background-position: 50% 50%;\n ┊41┊41┊    background-repeat: no-repeat;\n ┊42┊42┊    background-size: contain;\n ┊43┊43┊  }\n+┊  ┊44┊\n+┊  ┊45┊  ${(props: StyledProp) => props.isMine ? css `\n+┊  ┊46┊    float: right;\n+┊  ┊47┊    background-color: #dcf8c6;\n+┊  ┊48┊\n+┊  ┊49┊    &::before {\n+┊  ┊50┊      right: -11px;\n+┊  ┊51┊      background-image: url(/assets/message-mine.png);\n+┊  ┊52┊    }\n+┊  ┊53┊  ` : css `\n+┊  ┊54┊    float: left;\n+┊  ┊55┊    background-color: #fff;\n+┊  ┊56┊\n+┊  ┊57┊    &::before {\n+┊  ┊58┊      left: -11px;\n+┊  ┊59┊      background-image: url(/assets/message-other.png);\n+┊  ┊60┊    }\n+┊  ┊61┊  `}\n ┊44┊62┊`;\n ┊45┊63┊\n ┊46┊64┊const Contents = styled.div `\n```\n```diff\n@@ -75,21 +93,24 @@\n ┊ 75┊ 93┊\n ┊ 76┊ 94┊  useEffect(() => {\n ┊ 77┊ 95┊    if (!selfRef.current) return;\n-┊ 78┊   ┊\n-┊ 79┊   ┊     const selfDOMNode = ReactDOM.findDOMNode(selfRef.current) as HTMLElement;\n+┊   ┊ 96┊    const selfDOMNode = ReactDOM.findDOMNode(selfRef.current) as HTMLElement;\n ┊ 80┊ 97┊    selfDOMNode.scrollTop = Number.MAX_SAFE_INTEGER;\n ┊ 81┊ 98┊  }, [messages.length]);\n-┊ 82┊   ┊\n+┊   ┊ 99┊\n ┊ 83┊100┊  return (\n ┊ 84┊101┊    <Container ref={selfRef}>\n ┊ 85┊102┊      {messages.map((message: any) => (\n-┊ 86┊   ┊        <MessageItem data-testid=\"message-item\" key={message.id}>\n+┊   ┊103┊        <MessageItem\n+┊   ┊104┊          data-testid=\"message-item\"\n+┊   ┊105┊          isMine={message.isMine}\n+┊   ┊106┊          key={message.id}\n+┊   ┊107┊        >\n ┊ 87┊108┊          <Contents data-testid=\"message-content\">{message.content}</Contents>\n ┊ 88┊109┊          <Timestamp data-testid=\"message-date\">{moment(message.createdAt).format('HH:mm')}</Timestamp>\n ┊ 89┊110┊        </MessageItem>\n ┊ 90┊111┊      ))}\n ┊ 91┊112┊    </Container>\n-┊ 92┊   ┊  )\n+┊   ┊113┊  );\n ┊ 93┊114┊};\n ┊ 94┊115┊\n ┊ 95┊116┊export default MessagesList;🚫↵\n```\n\n##### Changed src&#x2F;components&#x2F;ChatRoomScreen&#x2F;index.tsx\n```diff\n@@ -63,6 +63,7 @@\n ┊63┊63┊          __typename: 'Message',\n ┊64┊64┊          id: Math.random().toString(36).substr(2, 9),\n ┊65┊65┊          createdAt: new Date(),\n+┊  ┊66┊          isMine: true,\n ┊66┊67┊          chat: {\n ┊67┊68┊            __typename: 'Chat',\n ┊68┊69┊            id: chatId,\n```\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;ChatsList.test.tsx\n```diff\n@@ -30,6 +30,7 @@\n ┊30┊30┊                  id: 1,\n ┊31┊31┊                  content: 'Hello',\n ┊32┊32┊                  createdAt: new Date('14 Jun 2017 00:00:00 PDT').toUTCString(),\n+┊  ┊33┊                  isMine: true,\n ┊33┊34┊                  chat: {\n ┊34┊35┊                    __typename: 'Chat',\n ┊35┊36┊                    id: 1,\n```\n```diff\n@@ -75,6 +76,7 @@\n ┊75┊76┊                  id: 1,\n ┊76┊77┊                  content: 'Hello',\n ┊77┊78┊                  createdAt: new Date(0),\n+┊  ┊79┊                  isMine: true,\n ┊78┊80┊                  chat: {\n ┊79┊81┊                    __typename: 'Chat',\n ┊80┊82┊                    id: 1,\n```\n\n[}]: #\n\nThis is how the updated `ChatRoomScreen` should look like:\n\n\n\n![chat-room-screen](https://user-images.githubusercontent.com/7648874/55326701-face8700-54ba-11e9-877e-0b7dd71a1b68.png)\n\n\n\nWe can use a temporary solution to log-in and alternate between different users. This would be a good way to test data authorization without implementing an authentication mechanism. One way to know which user is logged in is via [cookies](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies).\n\nCookies are just text files which are stored locally on your computer and they contain key-value data maps. Cookies will be sent automatically by the browser with every HTTP request under the `Cookie` header. The header can be parsed and read by the server and this way inform it about the state of the client. Cookie values can also be set by the server by sending back a response which contain a `Set-Cookie` header. The browser will automatically write these cookies because of its specification and how it works.\n\nThis is how you can set cookies on the client:\n\n```js\ndocument.cookie = \"yummy_cookie=choco\"\ndocument.cookie = \"tasty_cookie=strawberry\"\n// logs \"yummy_cookie=choco; tasty_cookie=strawberry\"\n```\n\nAnd this is how further requests would look like:\n\n```\nGET /sample_page.html HTTP/2.0\nHost: www.example.org\nCookie: yummy_cookie=choco; tasty_cookie=strawberry\n```\n\nUsing this method we can set the current user's ID. Open your browser's dev-console, and type the following:\n\n```js\n// Ray Edwards\ndocument.cookie = 'currentUserId=1'\n```\n\nTo be able to send cookies with Apollo Client, we need to set the [`credentials`](https://www.apollographql.com/docs/react/recipes/authentication#cookie) option to \"include\" when creating the HTTP link:\n\n[{]: <helper> (diffStep 11.2 module=\"client\")\n\n#### Client Step 11.2: Support credentials\n\n##### Changed src&#x2F;client.ts\n```diff\n@@ -10,6 +10,7 @@\n ┊10┊10┊\n ┊11┊11┊const httpLink = new HttpLink({\n ┊12┊12┊  uri: httpUri,\n+┊  ┊13┊  credentials: 'include',\n ┊13┊14┊});\n ┊14┊15┊\n ┊15┊16┊const wsLink = new WebSocketLink({\n```\n\n[}]: #\n\nThis will set the [`Access-Control-Allow-Credentials`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Credentials) header to “include” with each HTTP request which is necessary when using the POST method. In correlation to that, we would need to configure the server to be able to receive and set cookies. This can be done via CORS options like so:\n\n[{]: <helper> (diffStep 8.4 files=\"index.ts\" module=\"server\")\n\n#### [Server Step 8.4: Support credentials](https://github.com/Urigo/WhatsApp-Clone-Server/commit/44bf4c2)\n\n##### Changed index.ts\n```diff\n@@ -8,7 +8,8 @@\n ┊ 8┊ 8┊\n ┊ 9┊ 9┊const app = express()\n ┊10┊10┊\n-┊11┊  ┊app.use(cors())\n+┊  ┊11┊const origin = process.env.ORIGIN || 'http://localhost:3000'\n+┊  ┊12┊app.use(cors({ credentials: true, origin }))\n ┊12┊13┊app.use(bodyParser.json())\n ┊13┊14┊\n ┊14┊15┊app.get('/_ping', (req, res) => {\n```\n```diff\n@@ -27,6 +28,7 @@\n ┊27┊28┊server.applyMiddleware({\n ┊28┊29┊  app,\n ┊29┊30┊  path: '/graphql',\n+┊  ┊31┊  cors: { credentials: true, origin },\n ┊30┊32┊})\n ┊31┊33┊\n ┊32┊34┊const httpServer = http.createServer(app)\n```\n\n[}]: #\n\nSo how exactly does one retrieve the values of the cookies? Like mentioned earlier, each and every request will have them set on the `cookie` header, so one way would be by reading the header directly, but a more convenient way would be using an Express middleware called [`cookie-parser`](https://www.npmjs.com/package/cookie-parser):\n\n    $ yarn add cookie-parser\n\n[{]: <helper> (diffStep 8.5 files=\"index.ts\" module=\"server\")\n\n#### [Server Step 8.5: Use cookie parser](https://github.com/Urigo/WhatsApp-Clone-Server/commit/ac3a481)\n\n##### Changed index.ts\n```diff\n@@ -1,6 +1,7 @@\n ┊1┊1┊import { ApolloServer, gql, PubSub } from 'apollo-server-express'\n ┊2┊2┊import bodyParser from 'body-parser'\n ┊3┊3┊import cors from 'cors'\n+┊ ┊4┊import cookieParser from 'cookie-parser'\n ┊4┊5┊import express from 'express'\n ┊5┊6┊import http from 'http'\n ┊6┊7┊import { users } from './db'\n```\n```diff\n@@ -11,6 +12,7 @@\n ┊11┊12┊const origin = process.env.ORIGIN || 'http://localhost:3000'\n ┊12┊13┊app.use(cors({ credentials: true, origin }))\n ┊13┊14┊app.use(bodyParser.json())\n+┊  ┊15┊app.use(cookieParser())\n ┊14┊16┊\n ┊15┊17┊app.get('/_ping', (req, res) => {\n ┊16┊18┊  res.send('pong')\n```\n\n[}]: #\n\n`cookie-parser` will read the `Cookie` header, it will parse it into a JSON and will define it on `req.cookies`. Since we’re using Apollo-Server with Express, the `req` object should be accessible as the first argument in the `context` function. This means that we can use the `currentUserId` from the cookies to fetch the current user from our users collection and define it on the context object:\n\n[{]: <helper> (diffStep 8.6 module=\"server\")\n\n#### [Server Step 8.6: Define current user based on cookies](https://github.com/Urigo/WhatsApp-Clone-Server/commit/9d9333f)\n\n##### Changed index.ts\n```diff\n@@ -21,8 +21,8 @@\n ┊21┊21┊const pubsub = new PubSub()\n ┊22┊22┊const server = new ApolloServer({\n ┊23┊23┊  schema,\n-┊24┊  ┊  context: () => ({\n-┊25┊  ┊    currentUser: users.find(u => u.id === '1'),\n+┊  ┊24┊  context: ({ req }) => ({\n+┊  ┊25┊    currentUser: users.find(u => u.id === req.cookies.currentUserId),\n ┊26┊26┊    pubsub,\n ┊27┊27┊  }),\n ┊28┊28┊})\n```\n\n[}]: #\n\nNow you can go ahead and change the value of the `currentUserId` cookie and see how it affects the view anytime you refresh the page. Needless to say that this is not the most convenient way to switch between users, so we’re gonna implement a dedicated screen that will set the cookies for us.\n\nAll the auth related logic should go into a dedicated service since it can serve us vastly across the application, not just for a single component. Thus we will create a new service called `auth.service`, which will contain 3 basic functions for now: `signIn()`, `signOut()` and `isSignedIn():\n\n[{]: <helper> (diffStep 11.3 module=\"client\")\n\n#### Client Step 11.3: Add basic auth.service\n\n##### Added src&#x2F;services&#x2F;auth.service.tsx\n```diff\n@@ -0,0 +1,21 @@\n+┊  ┊ 1┊import client from '../client';\n+┊  ┊ 2┊\n+┊  ┊ 3┊export const signIn = (currentUserId: string) => {\n+┊  ┊ 4┊  document.cookie = `currentUserId=${currentUserId}`;\n+┊  ┊ 5┊\n+┊  ┊ 6┊  // This will become async in the near future\n+┊  ┊ 7┊  return Promise.resolve();\n+┊  ┊ 8┊};\n+┊  ┊ 9┊\n+┊  ┊10┊export const signOut = () => {\n+┊  ┊11┊  // \"expires\" represents the lifespan of a cookie. Beyond that date the cookie will\n+┊  ┊12┊  // be deleted by the browser. \"expires\" cannot be viewed from \"document.cookie\"\n+┊  ┊13┊  document.cookie = `currentUserId=;expires=${new Date(0)}`;\n+┊  ┊14┊\n+┊  ┊15┊  // Clear cache\n+┊  ┊16┊  return client.clearStore();\n+┊  ┊17┊};\n+┊  ┊18┊\n+┊  ┊19┊export const isSignedIn = () => {\n+┊  ┊20┊  return /currentUserId=.+(;|$)/.test(document.cookie);\n+┊  ┊21┊};🚫↵\n```\n\n[}]: #\n\nNow we will implement the `AuthScreen`. For now this screen should be fairly simple. It should contain a single `TextField` to specify the current user ID, and a `sign-in` button that will call the `signIn()` method with the specified ID. Once it does so, we will be proceeded to the `ChatsListScreen`. First we will download and save the following assets:\n\n- [`src/public/assets/whatsapp-icon.ping`](https://github.com/Urigo/WhatsApp-Clone-Client-React/raw/wip/cookie-auth/public/assets/whatsapp-icon.png)\n\n[{]: <helper> (diffStep 11.4 files=\"components\" module=\"client\")\n\n#### Client Step 11.4: Add AuthScreen\n\n##### Added src&#x2F;components&#x2F;AuthScreen&#x2F;index.tsx\n```diff\n@@ -0,0 +1,168 @@\n+┊   ┊  1┊import MaterialButton from '@material-ui/core/Button';\n+┊   ┊  2┊import MaterialTextField from '@material-ui/core/TextField';\n+┊   ┊  3┊import React from 'react';\n+┊   ┊  4┊import { useCallback, useState } from 'react';\n+┊   ┊  5┊import styled from 'styled-components';\n+┊   ┊  6┊import { signIn } from '../../services/auth.service';\n+┊   ┊  7┊import { RouteComponentProps } from 'react-router-dom';\n+┊   ┊  8┊\n+┊   ┊  9┊const Container = styled.div `\n+┊   ┊ 10┊  height: 100%;\n+┊   ┊ 11┊  background: radial-gradient(rgb(34, 65, 67), rgb(17, 48, 50)),\n+┊   ┊ 12┊    url(/assets/chat-background.jpg) no-repeat;\n+┊   ┊ 13┊  background-size: cover;\n+┊   ┊ 14┊  background-blend-mode: multiply;\n+┊   ┊ 15┊  color: white;\n+┊   ┊ 16┊`;\n+┊   ┊ 17┊\n+┊   ┊ 18┊const Intro = styled.div `\n+┊   ┊ 19┊  height: 265px;\n+┊   ┊ 20┊`;\n+┊   ┊ 21┊\n+┊   ┊ 22┊const Icon = styled.img `\n+┊   ┊ 23┊  width: 125px;\n+┊   ┊ 24┊  height: auto;\n+┊   ┊ 25┊  margin-left: auto;\n+┊   ┊ 26┊  margin-right: auto;\n+┊   ┊ 27┊  padding-top: 70px;\n+┊   ┊ 28┊  display: block;\n+┊   ┊ 29┊`;\n+┊   ┊ 30┊\n+┊   ┊ 31┊const Title = styled.h2 `\n+┊   ┊ 32┊  width: 100%;\n+┊   ┊ 33┊  text-align: center;\n+┊   ┊ 34┊  color: white;\n+┊   ┊ 35┊`;\n+┊   ┊ 36┊\n+┊   ┊ 37┊// eslint-disable-next-line\n+┊   ┊ 38┊const Alternative = styled.div `\n+┊   ┊ 39┊  position: fixed;\n+┊   ┊ 40┊  bottom: 10px;\n+┊   ┊ 41┊  left: 10px;\n+┊   ┊ 42┊\n+┊   ┊ 43┊  a {\n+┊   ┊ 44┊    color: var(--secondary-bg);\n+┊   ┊ 45┊  }\n+┊   ┊ 46┊`;\n+┊   ┊ 47┊\n+┊   ┊ 48┊const SignInForm = styled.div `\n+┊   ┊ 49┊  height: calc(100% - 265px);\n+┊   ┊ 50┊`;\n+┊   ┊ 51┊\n+┊   ┊ 52┊const ActualForm = styled.form `\n+┊   ┊ 53┊  padding: 20px;\n+┊   ┊ 54┊`;\n+┊   ┊ 55┊\n+┊   ┊ 56┊const Section = styled.div `\n+┊   ┊ 57┊  width: 100%;\n+┊   ┊ 58┊  padding-bottom: 35px;\n+┊   ┊ 59┊`;\n+┊   ┊ 60┊\n+┊   ┊ 61┊const Legend = styled.legend `\n+┊   ┊ 62┊  font-weight: bold;\n+┊   ┊ 63┊  color: white;\n+┊   ┊ 64┊`;\n+┊   ┊ 65┊\n+┊   ┊ 66┊// eslint-disable-next-line\n+┊   ┊ 67┊const Label = styled.label `\n+┊   ┊ 68┊  color: white !important;\n+┊   ┊ 69┊`;\n+┊   ┊ 70┊\n+┊   ┊ 71┊// eslint-disable-next-line\n+┊   ┊ 72┊const Input = styled.input `\n+┊   ┊ 73┊  color: white;\n+┊   ┊ 74┊\n+┊   ┊ 75┊  &::placeholder {\n+┊   ┊ 76┊    color: var(--primary-bg);\n+┊   ┊ 77┊  }\n+┊   ┊ 78┊`;\n+┊   ┊ 79┊\n+┊   ┊ 80┊const TextField = styled(MaterialTextField) `\n+┊   ┊ 81┊  width: 100%;\n+┊   ┊ 82┊  position: relative;\n+┊   ┊ 83┊\n+┊   ┊ 84┊  > div::before {\n+┊   ┊ 85┊    border-color: white !important;\n+┊   ┊ 86┊  }\n+┊   ┊ 87┊\n+┊   ┊ 88┊  input {\n+┊   ┊ 89┊    color: white !important;\n+┊   ┊ 90┊\n+┊   ┊ 91┊    &::placeholder {\n+┊   ┊ 92┊      color: var(--primary-bg) !important;\n+┊   ┊ 93┊    }\n+┊   ┊ 94┊  }\n+┊   ┊ 95┊\n+┊   ┊ 96┊  label {\n+┊   ┊ 97┊    color: white !important;\n+┊   ┊ 98┊  }\n+┊   ┊ 99┊` as typeof MaterialTextField;\n+┊   ┊100┊\n+┊   ┊101┊const Button = styled(MaterialButton) `\n+┊   ┊102┊  width: 100px;\n+┊   ┊103┊  display: block !important;\n+┊   ┊104┊  margin: auto !important;\n+┊   ┊105┊  background-color: var(--secondary-bg) !important;\n+┊   ┊106┊\n+┊   ┊107┊  &[disabled] {\n+┊   ┊108┊    color: #38a81c;\n+┊   ┊109┊  }\n+┊   ┊110┊\n+┊   ┊111┊  &:not([disabled]) {\n+┊   ┊112┊    color: white;\n+┊   ┊113┊  }\n+┊   ┊114┊` as typeof MaterialButton;\n+┊   ┊115┊\n+┊   ┊116┊const AuthScreen: React.FC<RouteComponentProps<any>> = ({ history }) => {\n+┊   ┊117┊  const [userId, setUserId] = useState('');\n+┊   ┊118┊\n+┊   ┊119┊  const onUserIdChange = useCallback(({ target }) => {\n+┊   ┊120┊    setUserId(target.value);\n+┊   ┊121┊  }, []);\n+┊   ┊122┊\n+┊   ┊123┊  const maySignIn = useCallback(() => {\n+┊   ┊124┊    return !!userId\n+┊   ┊125┊  }, [userId]);\n+┊   ┊126┊\n+┊   ┊127┊  const handleSignIn = useCallback(() => {\n+┊   ┊128┊    signIn(userId).then(() => {\n+┊   ┊129┊      history.replace('/chats')\n+┊   ┊130┊    })\n+┊   ┊131┊  }, [userId, history]);\n+┊   ┊132┊\n+┊   ┊133┊  return (\n+┊   ┊134┊    <Container>\n+┊   ┊135┊      <Intro>\n+┊   ┊136┊        <Icon src=\"assets/whatsapp-icon.png\" className=\"AuthScreen-icon\" />\n+┊   ┊137┊        <Title className=\"AuthScreen-title\">WhatsApp</Title>\n+┊   ┊138┊      </Intro>\n+┊   ┊139┊      <SignInForm>\n+┊   ┊140┊        <ActualForm>\n+┊   ┊141┊          <Legend>Sign in</Legend>\n+┊   ┊142┊          <Section>\n+┊   ┊143┊            <TextField\n+┊   ┊144┊              data-testid=\"user-id-input\"\n+┊   ┊145┊              label=\"User ID\"\n+┊   ┊146┊              value={userId}\n+┊   ┊147┊              onChange={onUserIdChange}\n+┊   ┊148┊              margin=\"normal\"\n+┊   ┊149┊              placeholder=\"Enter current user ID\"\n+┊   ┊150┊            />\n+┊   ┊151┊          </Section>\n+┊   ┊152┊          <Button\n+┊   ┊153┊            data-testid=\"sign-in-button\"\n+┊   ┊154┊            type=\"button\"\n+┊   ┊155┊            color=\"secondary\"\n+┊   ┊156┊            variant=\"contained\"\n+┊   ┊157┊            disabled={!maySignIn()}\n+┊   ┊158┊            onClick={handleSignIn}\n+┊   ┊159┊          >\n+┊   ┊160┊            Sign in\n+┊   ┊161┊          </Button>\n+┊   ┊162┊        </ActualForm>\n+┊   ┊163┊      </SignInForm>\n+┊   ┊164┊    </Container>\n+┊   ┊165┊  );\n+┊   ┊166┊};\n+┊   ┊167┊\n+┊   ┊168┊export default AuthScreen;🚫↵\n```\n\n[}]: #\n\nAccordingly we will define a new `/sign-in` route that will render the `AuthScreen` we’re under that path name:\n\n[{]: <helper> (diffStep 11.4 files=\"App\" module=\"client\")\n\n#### Client Step 11.4: Add AuthScreen\n\n##### Changed src&#x2F;App.tsx\n```diff\n@@ -1,5 +1,6 @@\n ┊1┊1┊import React from 'react';\n ┊2┊2┊import { BrowserRouter, Route, Redirect, RouteComponentProps } from 'react-router-dom';\n+┊ ┊3┊import AuthScreen from './components/AuthScreen';\n ┊3┊4┊import ChatRoomScreen from './components/ChatRoomScreen';\n ┊4┊5┊import ChatsListScreen from './components/ChatsListScreen';\n ┊5┊6┊import AnimatedSwitch from './components/AnimatedSwitch';\n```\n```diff\n@@ -11,6 +12,7 @@\n ┊11┊12┊  return (\n ┊12┊13┊    <BrowserRouter>\n ┊13┊14┊      <AnimatedSwitch>\n+┊  ┊15┊        <Route exact path=\"/sign-in\" component={AuthScreen} />\n ┊14┊16┊        <Route exact path=\"/chats\" component={ChatsListScreen} />\n ┊15┊17┊\n ┊16┊18┊        <Route exact path=\"/chats/:chatId\" component={\n```\n\n[}]: #\n\nThis is how the new screen should look like:\n\n![auth-screen](https://user-images.githubusercontent.com/7648874/55606715-7a56a180-57ac-11e9-8eea-2da5931cccf5.png)\n\nNow let’s type the `/sign-in` route in our browser’s navigation bar and assign a user ID, see how it affects what chats we see in the `ChatsListScreen`. You’ve probably noticed that there’s no way to escape from the `/chats` route unless we edit the browser’s navigation bar manually. To fix that, we will add a new sign-out button to the navbar of the `ChatsListScreen` that will call the `signOut()` method anytime we click on it, and will bring us back to the `AuthScreen`:\n\n[{]: <helper> (diffStep 11.5 module=\"client\")\n\n#### Client Step 11.5: Add sign-out button that ChatsNavbar\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;ChatsNavbar.tsx\n```diff\n@@ -1,18 +1,46 @@\n ┊ 1┊ 1┊import React from 'react';\n-┊ 2┊  ┊import { Toolbar } from '@material-ui/core';\n+┊  ┊ 2┊import { Button, Toolbar } from '@material-ui/core';\n ┊ 3┊ 3┊import styled from 'styled-components';\n+┊  ┊ 4┊import SignOutIcon from '@material-ui/icons/PowerSettingsNew';\n+┊  ┊ 5┊import { useCallback } from 'react';\n+┊  ┊ 6┊import { signOut } from '../../services/auth.service';\n+┊  ┊ 7┊import { History } from 'history';\n ┊ 4┊ 8┊\n ┊ 5┊ 9┊const Container = styled(Toolbar) `\n+┊  ┊10┊  display: flex;\n ┊ 6┊11┊  background-color: var(--primary-bg);\n ┊ 7┊12┊  color: var(--primary-text);\n ┊ 8┊13┊  font-size: 20px;\n ┊ 9┊14┊  line-height: 40px;\n ┊10┊15┊` as typeof Toolbar;\n ┊11┊16┊\n-┊12┊  ┊const ChatsNavbar: React.FC = () => (\n-┊13┊  ┊  <Container>\n-┊14┊  ┊    Whatsapp Clone\n-┊15┊  ┊  </Container>\n-┊16┊  ┊);\n+┊  ┊17┊const Title = styled.div `\n+┊  ┊18┊  flex: 1;\n+┊  ┊19┊`;\n+┊  ┊20┊\n+┊  ┊21┊const LogoutButton = styled(Button) `\n+┊  ┊22┊  color: var(--primary-text) !important;\n+┊  ┊23┊` as typeof Button;\n+┊  ┊24┊\n+┊  ┊25┊interface ChildComponentProps {\n+┊  ┊26┊  history: History;\n+┊  ┊27┊};\n+┊  ┊28┊\n+┊  ┊29┊const ChatsNavbar: React.FC<ChildComponentProps> = ({ history }) => {\n+┊  ┊30┊  const handleSignOut = useCallback(() => {\n+┊  ┊31┊    signOut().then(() => {\n+┊  ┊32┊      history.replace('/sign-in')\n+┊  ┊33┊    });\n+┊  ┊34┊  }, [history]);\n+┊  ┊35┊\n+┊  ┊36┊  return (\n+┊  ┊37┊    <Container>\n+┊  ┊38┊      <Title>Whatsapp Clone</Title>\n+┊  ┊39┊      <LogoutButton data-testid=\"sign-out-button\" onClick={handleSignOut}>\n+┊  ┊40┊        <SignOutIcon />\n+┊  ┊41┊      </LogoutButton>\n+┊  ┊42┊    </Container>\n+┊  ┊43┊  );\n+┊  ┊44┊};\n ┊17┊45┊\n ┊18┊46┊export default ChatsNavbar;🚫↵\n```\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;index.tsx\n```diff\n@@ -14,7 +14,7 @@\n ┊14┊14┊\n ┊15┊15┊const ChatsListScreen: React.FC<ChatsListScreenProps> = ({ history }) => (\n ┊16┊16┊  <Container>\n-┊17┊  ┊    <ChatsNavbar />\n+┊  ┊17┊    <ChatsNavbar history={history} />\n ┊18┊18┊    <ChatsList history={history} />\n ┊19┊19┊  </Container>\n ┊20┊20┊);\n```\n\n[}]: #\n\nAt this point we’ve got everything we need, but we will add a small touch to improve the user experience and make it feel more complete. Users who aren’t logged in shouldn’t be able to view any screen besides the `AuthScreen`. First they need to sign-in, and only then they will be able to view the `ChatsListScreen` and `ChatRoomScreen`. To achieve that, we will wrap all the components which require authentication before we provide them into their routes. This wrap will basically check whether a user is logged in or not by reading the cookies, and if not we will be redirected to the `/sign-in` route. Let’s implement that wrap in the `auth.service` and call it `withAuth()`:\n\n[{]: <helper> (diffStep 11.6 files=\"auth.service\" module=\"client\")\n\n#### Client Step 11.6: Add withAuth() route wrapper\n\n##### Changed src&#x2F;services&#x2F;auth.service.tsx\n```diff\n@@ -1,4 +1,27 @@\n+┊  ┊ 1┊import React from 'react';\n+┊  ┊ 2┊import { Redirect } from 'react-router-dom';\n ┊ 1┊ 3┊import client from '../client';\n+┊  ┊ 4┊import { useCacheService } from './cache.service';\n+┊  ┊ 5┊\n+┊  ┊ 6┊export const withAuth = <P extends object>(Component: React.ComponentType<P>) => {\n+┊  ┊ 7┊  return (props: any) => {\n+┊  ┊ 8┊    if (!isSignedIn()) {\n+┊  ┊ 9┊      if (props.history.location.pathname === '/sign-in') {\n+┊  ┊10┊        return null;\n+┊  ┊11┊      }\n+┊  ┊12┊\n+┊  ┊13┊      return (\n+┊  ┊14┊        <Redirect to=\"/sign-in\" />\n+┊  ┊15┊      );\n+┊  ┊16┊    }\n+┊  ┊17┊\n+┊  ┊18┊    useCacheService();\n+┊  ┊19┊\n+┊  ┊20┊    return (\n+┊  ┊21┊      <Component {...props as P} />\n+┊  ┊22┊    );\n+┊  ┊23┊  };\n+┊  ┊24┊};\n ┊ 2┊25┊\n ┊ 3┊26┊export const signIn = (currentUserId: string) => {\n ┊ 4┊27┊  document.cookie = `currentUserId=${currentUserId}`;\n```\n\n[}]: #\n\nWe will use this function to wrap the right components in our app’s router. Note that since we used the `useCacheService()` directly in the `withAuth()` method, there’s no need to use it in the router itself anymore. This makes a lot more sense since there’s no need to stay subscribed to data that you're not gonna receive from the first place unless you’re logged-in:\n\n[{]: <helper> (diffStep 11.6 files=\"App\" module=\"client\")\n\n#### Client Step 11.6: Add withAuth() route wrapper\n\n##### Changed src&#x2F;App.tsx\n```diff\n@@ -4,27 +4,23 @@\n ┊ 4┊ 4┊import ChatRoomScreen from './components/ChatRoomScreen';\n ┊ 5┊ 5┊import ChatsListScreen from './components/ChatsListScreen';\n ┊ 6┊ 6┊import AnimatedSwitch from './components/AnimatedSwitch';\n-┊ 7┊  ┊import { useCacheService } from './services/cache.service';\n+┊  ┊ 7┊import { withAuth } from './services/auth.service';\n ┊ 8┊ 8┊\n-┊ 9┊  ┊const App: React.FC = () => {\n-┊10┊  ┊  useCacheService();\n+┊  ┊ 9┊const App: React.FC = () => (\n+┊  ┊10┊  <BrowserRouter>\n+┊  ┊11┊    <AnimatedSwitch>\n+┊  ┊12┊      <Route exact path=\"/sign-in\" component={AuthScreen} />\n+┊  ┊13┊      <Route exact path=\"/chats\" component={withAuth(ChatsListScreen)} />\n ┊11┊14┊\n-┊12┊  ┊  return (\n-┊13┊  ┊    <BrowserRouter>\n-┊14┊  ┊      <AnimatedSwitch>\n-┊15┊  ┊        <Route exact path=\"/sign-in\" component={AuthScreen} />\n-┊16┊  ┊        <Route exact path=\"/chats\" component={ChatsListScreen} />\n+┊  ┊15┊      <Route exact path=\"/chats/:chatId\" component={withAuth(\n+┊  ┊16┊        ({ match, history }: RouteComponentProps<{ chatId: string }>) =>\n+┊  ┊17┊        (<ChatRoomScreen chatId={match.params.chatId} history={history} />)\n+┊  ┊18┊      )} />\n ┊17┊19┊\n-┊18┊  ┊        <Route exact path=\"/chats/:chatId\" component={\n-┊19┊  ┊          ({ match, history }: RouteComponentProps<{ chatId: string }>) =>\n-┊20┊  ┊          (<ChatRoomScreen chatId={match.params.chatId} history={history} />)\n-┊21┊  ┊        } />\n-┊22┊  ┊\n-┊23┊  ┊      </AnimatedSwitch>\n-┊24┊  ┊      <Route exact path=\"/\" render={redirectToChats} />\n-┊25┊  ┊    </BrowserRouter>\n-┊26┊  ┊  );\n-┊27┊  ┊};\n+┊  ┊20┊    </AnimatedSwitch>\n+┊  ┊21┊    <Route exact path=\"/\" render={redirectToChats} />\n+┊  ┊22┊  </BrowserRouter>\n+┊  ┊23┊);\n ┊28┊24┊\n ┊29┊25┊const redirectToChats = () => (\n ┊30┊26┊  <Redirect to=\"/chats\" />\n```\n\n[}]: #\n\nAssuming that you’re not logged-in, if you’ll try to force navigate to the `/chats` route you should be automatically redirected to the `/sign-in` form. We will finish the chapter here as we wanna keep things simple and gradual. It’s true that we haven’t implemented true authentication, but that would be addressed soon further in this tutorial.\n\n---------\n\nTODO: minor change, which might be helpful for people in long term. That’s a small but powerful thing to know about in TypeScript\n+ recipient: chat.participants.find(p => p !== currentUser.id)!\n- recipient: chat.participants.find(p => p !== currentUser.id) as string\n\n\nTODO: I don’t think we need `if (props.history.location.pathname === '/sign-in') return null`\nsince withAuth HOC is not used on `AuthScreen` component"
          },
          {
            "manualTitle": "Step 12: Adding and removing chats",
            "stepRevision": "52aa581ceab56fe7d39cab9a6b0db5ba52737f7d",
            "manualView": "Now that the users system is ready it would be a lot more comfortable to implement a chat creation feature. In the original Whatsapp, you can create a new chat based on your available contacts - a list of your contacts will appear on the screen and by picking one of the items you’ll basically be able to start chatting with the selected contact. However, since in our app we don’t have any real contacts (yet), we will implement the chats creation feature based on all available users in our DB. By picking a user from the users list we will be able to start chatting with it.\n\n![demo](https://user-images.githubusercontent.com/7648874/55896445-e4c67200-5bf0-11e9-9c1c-88318642ef81.gif)\n\nTo be able to fetch users in our system we will need to add a new query called `users`. The `users` query will retrieve all users except for current user:\n\n[{]: <helper> (diffStep 9.1 module=\"server\")\n\n#### [Server Step 9.1: Add Query.users](https://github.com/Urigo/WhatsApp-Clone-Server/commit/95127eb)\n\n##### Changed schema&#x2F;resolvers.ts\n```diff\n@@ -80,6 +80,12 @@\n ┊80┊80┊\n ┊81┊81┊      return chat.participants.includes(currentUser.id) ? chat : null\n ┊82┊82┊    },\n+┊  ┊83┊\n+┊  ┊84┊    users(root, args, { currentUser }) {\n+┊  ┊85┊      if (!currentUser) return []\n+┊  ┊86┊\n+┊  ┊87┊      return users.filter(u => u.id !== currentUser.id)\n+┊  ┊88┊    },\n ┊83┊89┊  },\n ┊84┊90┊\n ┊85┊91┊  Mutation: {\n```\n\n##### Changed schema&#x2F;typeDefs.graphql\n```diff\n@@ -28,6 +28,7 @@\n ┊28┊28┊type Query {\n ┊29┊29┊  chats: [Chat!]!\n ┊30┊30┊  chat(chatId: ID!): Chat\n+┊  ┊31┊  users: [User!]!\n ┊31┊32┊}\n ┊32┊33┊\n ┊33┊34┊type Mutation {\n```\n\n##### Added tests&#x2F;queries&#x2F;\\__snapshots__&#x2F;getUsers.test.ts.snap\n```diff\n@@ -0,0 +1,55 @@\n+┊  ┊ 1┊// Jest Snapshot v1, https://goo.gl/fbAQLP\n+┊  ┊ 2┊\n+┊  ┊ 3┊exports[`Query.getUsers should fetch all users except the one signed-in 1`] = `\n+┊  ┊ 4┊Object {\n+┊  ┊ 5┊  \"users\": Array [\n+┊  ┊ 6┊    Object {\n+┊  ┊ 7┊      \"id\": \"2\",\n+┊  ┊ 8┊      \"name\": \"Ethan Gonzalez\",\n+┊  ┊ 9┊      \"picture\": \"https://randomuser.me/api/portraits/thumb/men/1.jpg\",\n+┊  ┊10┊    },\n+┊  ┊11┊    Object {\n+┊  ┊12┊      \"id\": \"3\",\n+┊  ┊13┊      \"name\": \"Bryan Wallace\",\n+┊  ┊14┊      \"picture\": \"https://randomuser.me/api/portraits/thumb/men/2.jpg\",\n+┊  ┊15┊    },\n+┊  ┊16┊    Object {\n+┊  ┊17┊      \"id\": \"4\",\n+┊  ┊18┊      \"name\": \"Avery Stewart\",\n+┊  ┊19┊      \"picture\": \"https://randomuser.me/api/portraits/thumb/women/1.jpg\",\n+┊  ┊20┊    },\n+┊  ┊21┊    Object {\n+┊  ┊22┊      \"id\": \"5\",\n+┊  ┊23┊      \"name\": \"Katie Peterson\",\n+┊  ┊24┊      \"picture\": \"https://randomuser.me/api/portraits/thumb/women/2.jpg\",\n+┊  ┊25┊    },\n+┊  ┊26┊  ],\n+┊  ┊27┊}\n+┊  ┊28┊`;\n+┊  ┊29┊\n+┊  ┊30┊exports[`Query.getUsers should fetch all users except the one signed-in 2`] = `\n+┊  ┊31┊Object {\n+┊  ┊32┊  \"users\": Array [\n+┊  ┊33┊    Object {\n+┊  ┊34┊      \"id\": \"1\",\n+┊  ┊35┊      \"name\": \"Ray Edwards\",\n+┊  ┊36┊      \"picture\": \"https://randomuser.me/api/portraits/thumb/lego/1.jpg\",\n+┊  ┊37┊    },\n+┊  ┊38┊    Object {\n+┊  ┊39┊      \"id\": \"3\",\n+┊  ┊40┊      \"name\": \"Bryan Wallace\",\n+┊  ┊41┊      \"picture\": \"https://randomuser.me/api/portraits/thumb/men/2.jpg\",\n+┊  ┊42┊    },\n+┊  ┊43┊    Object {\n+┊  ┊44┊      \"id\": \"4\",\n+┊  ┊45┊      \"name\": \"Avery Stewart\",\n+┊  ┊46┊      \"picture\": \"https://randomuser.me/api/portraits/thumb/women/1.jpg\",\n+┊  ┊47┊    },\n+┊  ┊48┊    Object {\n+┊  ┊49┊      \"id\": \"5\",\n+┊  ┊50┊      \"name\": \"Katie Peterson\",\n+┊  ┊51┊      \"picture\": \"https://randomuser.me/api/portraits/thumb/women/2.jpg\",\n+┊  ┊52┊    },\n+┊  ┊53┊  ],\n+┊  ┊54┊}\n+┊  ┊55┊`;\n```\n\n##### Added tests&#x2F;queries&#x2F;getUsers.test.ts\n```diff\n@@ -0,0 +1,51 @@\n+┊  ┊ 1┊import { createTestClient } from 'apollo-server-testing'\n+┊  ┊ 2┊import { ApolloServer, gql } from 'apollo-server-express'\n+┊  ┊ 3┊import schema from '../../schema'\n+┊  ┊ 4┊import { users } from '../../db'\n+┊  ┊ 5┊\n+┊  ┊ 6┊describe('Query.getUsers', () => {\n+┊  ┊ 7┊  it('should fetch all users except the one signed-in', async () => {\n+┊  ┊ 8┊    let currentUser = users[0]\n+┊  ┊ 9┊\n+┊  ┊10┊    const server = new ApolloServer({\n+┊  ┊11┊      schema,\n+┊  ┊12┊      context: () => ({ currentUser }),\n+┊  ┊13┊    })\n+┊  ┊14┊\n+┊  ┊15┊    const { query } = createTestClient(server)\n+┊  ┊16┊\n+┊  ┊17┊    let res = await query({\n+┊  ┊18┊      query: gql `\n+┊  ┊19┊        query GetUsers {\n+┊  ┊20┊          users {\n+┊  ┊21┊            id\n+┊  ┊22┊            name\n+┊  ┊23┊            picture\n+┊  ┊24┊          }\n+┊  ┊25┊        }\n+┊  ┊26┊      `,\n+┊  ┊27┊    })\n+┊  ┊28┊\n+┊  ┊29┊    expect(res.data).toBeDefined()\n+┊  ┊30┊    expect(res.errors).toBeUndefined()\n+┊  ┊31┊    expect(res.data).toMatchSnapshot()\n+┊  ┊32┊\n+┊  ┊33┊    currentUser = users[1]\n+┊  ┊34┊\n+┊  ┊35┊    res = await query({\n+┊  ┊36┊      query: gql `\n+┊  ┊37┊        query GetUsers {\n+┊  ┊38┊          users {\n+┊  ┊39┊            id\n+┊  ┊40┊            name\n+┊  ┊41┊            picture\n+┊  ┊42┊          }\n+┊  ┊43┊        }\n+┊  ┊44┊      `,\n+┊  ┊45┊    })\n+┊  ┊46┊\n+┊  ┊47┊    expect(res.data).toBeDefined()\n+┊  ┊48┊    expect(res.errors).toBeUndefined()\n+┊  ┊49┊    expect(res.data).toMatchSnapshot()\n+┊  ┊50┊  })\n+┊  ┊51┊})\n```\n\n[}]: #\n\nThis query will be reflected in a component called `UsersList`. First we will define and export a new fragment called `User`:\n\n[{]: <helper> (diffStep 12.1 files=\"graphql/fragments\" module=\"client\")\n\n#### Client Step 12.1: Add basic ChatCreationScreen\n\n##### Changed src&#x2F;graphql&#x2F;fragments&#x2F;index.ts\n```diff\n@@ -1,3 +1,4 @@\n ┊1┊1┊export { default as chat } from './chat.fragment';\n ┊2┊2┊export { default as fullChat } from './fullChat.fragment';\n ┊3┊3┊export { default as message } from './message.fragment';\n+┊ ┊4┊export { default as user } from './user.fragment';\n```\n\n##### Added src&#x2F;graphql&#x2F;fragments&#x2F;user.fragment.ts\n```diff\n@@ -0,0 +1,9 @@\n+┊ ┊1┊import gql from 'graphql-tag';\n+┊ ┊2┊\n+┊ ┊3┊export default gql`\n+┊ ┊4┊  fragment User on User {\n+┊ ┊5┊    id\n+┊ ┊6┊    name\n+┊ ┊7┊    picture\n+┊ ┊8┊  }\n+┊ ┊9┊`;\n```\n\n[}]: #\n\nAnd then we will implement the `UsersList` component which is going to use the `users` query with the `User` fragment:\n\n[{]: <helper> (diffStep 12.1 files=\"UsersList\" module=\"client\")\n\n#### Client Step 12.1: Add basic ChatCreationScreen\n\n##### Added src&#x2F;components&#x2F;UsersList.test.tsx\n```diff\n@@ -0,0 +1,43 @@\n+┊  ┊ 1┊import React from 'react';\n+┊  ┊ 2┊import { ApolloProvider } from 'react-apollo-hooks';\n+┊  ┊ 3┊import { cleanup, render, waitForDomChange } from 'react-testing-library';\n+┊  ┊ 4┊import { mockApolloClient } from '../test-helpers';\n+┊  ┊ 5┊import UsersList, { UsersListQuery } from './UsersList';\n+┊  ┊ 6┊import * as queries from '../graphql/queries';\n+┊  ┊ 7┊\n+┊  ┊ 8┊describe('UsersList', () => {\n+┊  ┊ 9┊  afterEach(cleanup);\n+┊  ┊10┊\n+┊  ┊11┊  it('renders fetched users data', async () => {\n+┊  ┊12┊    const client = mockApolloClient([\n+┊  ┊13┊      {\n+┊  ┊14┊        request: { query: UsersListQuery },\n+┊  ┊15┊        result: {\n+┊  ┊16┊          data: {\n+┊  ┊17┊            users: [\n+┊  ┊18┊              {\n+┊  ┊19┊                __typename: 'User',\n+┊  ┊20┊                id: 1,\n+┊  ┊21┊                name: 'Charles Dickhead',\n+┊  ┊22┊                picture: 'https://localhost:4000/dick.jpg',\n+┊  ┊23┊              },\n+┊  ┊24┊            ],\n+┊  ┊25┊          },\n+┊  ┊26┊        },\n+┊  ┊27┊      },\n+┊  ┊28┊    ]);\n+┊  ┊29┊\n+┊  ┊30┊    {\n+┊  ┊31┊      const { container, getByTestId } = render(\n+┊  ┊32┊        <ApolloProvider client={client}>\n+┊  ┊33┊          <UsersList />\n+┊  ┊34┊        </ApolloProvider>\n+┊  ┊35┊      );\n+┊  ┊36┊\n+┊  ┊37┊      await waitForDomChange({ container });\n+┊  ┊38┊\n+┊  ┊39┊      expect(getByTestId('name')).toHaveTextContent('Charles Dickhead');\n+┊  ┊40┊      expect(getByTestId('picture')).toHaveAttribute('src', 'https://localhost:4000/dick.jpg');\n+┊  ┊41┊    }\n+┊  ┊42┊  })\n+┊  ┊43┊});\n```\n\n##### Added src&#x2F;components&#x2F;UsersList.tsx\n```diff\n@@ -0,0 +1,66 @@\n+┊  ┊ 1┊import MaterialList from '@material-ui/core/List';\n+┊  ┊ 2┊import MaterialItem from '@material-ui/core/ListItem';\n+┊  ┊ 3┊import gql from 'graphql-tag';\n+┊  ┊ 4┊import React from 'react';\n+┊  ┊ 5┊import styled from 'styled-components';\n+┊  ┊ 6┊import * as fragments from '../graphql/fragments';\n+┊  ┊ 7┊import { useUsersListQuery } from '../graphql/types';\n+┊  ┊ 8┊\n+┊  ┊ 9┊const ActualList = styled(MaterialList) `\n+┊  ┊10┊  padding: 0;\n+┊  ┊11┊` as typeof MaterialList;\n+┊  ┊12┊\n+┊  ┊13┊const UserItem = styled(MaterialItem) `\n+┊  ┊14┊  position: relative;\n+┊  ┊15┊  padding: 7.5px 15px;\n+┊  ┊16┊  display: flex;\n+┊  ┊17┊  cursor: pinter;\n+┊  ┊18┊` as typeof MaterialItem;\n+┊  ┊19┊\n+┊  ┊20┊const ProfilePicture = styled.img `\n+┊  ┊21┊  height: 50px;\n+┊  ┊22┊  width: 50px;\n+┊  ┊23┊  object-fit: cover;\n+┊  ┊24┊  border-radius: 50%;\n+┊  ┊25┊`;\n+┊  ┊26┊\n+┊  ┊27┊const Name = styled.div `\n+┊  ┊28┊  padding-left: 15px;\n+┊  ┊29┊  font-weight: bold;\n+┊  ┊30┊`;\n+┊  ┊31┊\n+┊  ┊32┊export const UsersListQuery = gql`\n+┊  ┊33┊  query UsersList {\n+┊  ┊34┊    users {\n+┊  ┊35┊      ...User\n+┊  ┊36┊    }\n+┊  ┊37┊  }\n+┊  ┊38┊  ${fragments.user}\n+┊  ┊39┊`;\n+┊  ┊40┊\n+┊  ┊41┊const UsersList: React.FC = () => {\n+┊  ┊42┊  const { data, loading: loadingUsers } = useUsersListQuery();\n+┊  ┊43┊\n+┊  ┊44┊  if (data === undefined) return null;\n+┊  ┊45┊  const users = data.users;\n+┊  ┊46┊\n+┊  ┊47┊  return (\n+┊  ┊48┊    <ActualList>\n+┊  ┊49┊      {!loadingUsers && users.map(user => (\n+┊  ┊50┊        <UserItem\n+┊  ┊51┊          key={user.id}\n+┊  ┊52┊          button\n+┊  ┊53┊        >\n+┊  ┊54┊          {(user !== null && user.picture !== null) &&\n+┊  ┊55┊            <React.Fragment>\n+┊  ┊56┊              <ProfilePicture data-testid=\"picture\" src={user.picture} />\n+┊  ┊57┊              <Name data-testid=\"name\">{user.name}</Name>\n+┊  ┊58┊            </React.Fragment>\n+┊  ┊59┊          }\n+┊  ┊60┊        </UserItem>\n+┊  ┊61┊      ))}\n+┊  ┊62┊    </ActualList>\n+┊  ┊63┊  );\n+┊  ┊64┊};\n+┊  ┊65┊\n+┊  ┊66┊export default UsersList;\n```\n\n[}]: #\n\nThe list is likely to change when a new user signs-up. We will implement a subscription and live-update the list further this tutorial when we go through authentication. Now we will implement a new screen component called `ChatCreationScreen`. The screen will simply render the `UsersList` along with a navigation bar:\n\n[{]: <helper> (diffStep 12.1 files=\"ChatCreationScreen\" module=\"client\")\n\n#### Client Step 12.1: Add basic ChatCreationScreen\n\n##### Added src&#x2F;components&#x2F;ChatCreationScreen&#x2F;ChatCreationNavbar.test.tsx\n```diff\n@@ -0,0 +1,28 @@\n+┊  ┊ 1┊import { createMemoryHistory } from 'history';\n+┊  ┊ 2┊import React from 'react';\n+┊  ┊ 3┊import { cleanup, render, fireEvent, wait } from 'react-testing-library';\n+┊  ┊ 4┊import ChatCreationNavbar from './ChatCreationNavbar';\n+┊  ┊ 5┊\n+┊  ┊ 6┊describe('ChatCreationNavbar', () => {\n+┊  ┊ 7┊  afterEach(cleanup);\n+┊  ┊ 8┊\n+┊  ┊ 9┊  it('goes back on arrow click', async () => {\n+┊  ┊10┊    const history = createMemoryHistory();\n+┊  ┊11┊\n+┊  ┊12┊    history.push('/new-chat');\n+┊  ┊13┊\n+┊  ┊14┊    await wait(() =>\n+┊  ┊15┊      expect(history.location.pathname).toEqual('/new-chat')\n+┊  ┊16┊    );\n+┊  ┊17┊\n+┊  ┊18┊    {\n+┊  ┊19┊      const { container, getByTestId } = render(<ChatCreationNavbar history={history} />);\n+┊  ┊20┊\n+┊  ┊21┊      fireEvent.click(getByTestId('back-button'));\n+┊  ┊22┊\n+┊  ┊23┊      await wait(() =>\n+┊  ┊24┊        expect(history.location.pathname).toEqual('/chats')\n+┊  ┊25┊      );\n+┊  ┊26┊    }\n+┊  ┊27┊  });\n+┊  ┊28┊});\n```\n\n##### Added src&#x2F;components&#x2F;ChatCreationScreen&#x2F;ChatCreationNavbar.tsx\n```diff\n@@ -0,0 +1,46 @@\n+┊  ┊ 1┊import ArrowBackIcon from '@material-ui/icons/ArrowBack';\n+┊  ┊ 2┊import { Toolbar, Button } from '@material-ui/core';\n+┊  ┊ 3┊import React from 'react';\n+┊  ┊ 4┊import { useCallback } from 'react';\n+┊  ┊ 5┊import styled from 'styled-components';\n+┊  ┊ 6┊import { History } from 'history';\n+┊  ┊ 7┊\n+┊  ┊ 8┊const Container = styled(Toolbar) `\n+┊  ┊ 9┊  display: flex;\n+┊  ┊10┊  background-color: var(--primary-bg);\n+┊  ┊11┊  color: var(--primary-text);\n+┊  ┊12┊  font-size: 20px;\n+┊  ┊13┊  line-height: 40px;\n+┊  ┊14┊` as typeof Toolbar;\n+┊  ┊15┊\n+┊  ┊16┊const BackButton = styled(Button) `\n+┊  ┊17┊  svg {\n+┊  ┊18┊    color: var(--primary-text);\n+┊  ┊19┊  }\n+┊  ┊20┊` as typeof Button;\n+┊  ┊21┊\n+┊  ┊22┊const Title = styled.div `\n+┊  ┊23┊  flex: 1;\n+┊  ┊24┊`;\n+┊  ┊25┊\n+┊  ┊26┊interface ChildComponentProps {\n+┊  ┊27┊  history: History;\n+┊  ┊28┊};\n+┊  ┊29┊\n+┊  ┊30┊const ChatCreationNavbar: React.FC<ChildComponentProps> = ({ history }) => {\n+┊  ┊31┊  const navBack = useCallback(() => {\n+┊  ┊32┊    history.replace('/chats');\n+┊  ┊33┊  }, [history]);\n+┊  ┊34┊\n+┊  ┊35┊  return (\n+┊  ┊36┊    <Container>\n+┊  ┊37┊      <BackButton data-testid=\"back-button\" onClick={navBack}>\n+┊  ┊38┊        <ArrowBackIcon />\n+┊  ┊39┊      </BackButton>\n+┊  ┊40┊      <Title>Create Chat</Title>\n+┊  ┊41┊    </Container>\n+┊  ┊42┊  );\n+┊  ┊43┊};\n+┊  ┊44┊\n+┊  ┊45┊\n+┊  ┊46┊export default ChatCreationNavbar;\n```\n\n##### Added src&#x2F;components&#x2F;ChatCreationScreen&#x2F;index.tsx\n```diff\n@@ -0,0 +1,29 @@\n+┊  ┊ 1┊import React from 'react';\n+┊  ┊ 2┊import styled from 'styled-components';\n+┊  ┊ 3┊import UsersList from '../UsersList';\n+┊  ┊ 4┊import ChatCreationNavbar from './ChatCreationNavbar';\n+┊  ┊ 5┊import { History } from 'history';\n+┊  ┊ 6┊\n+┊  ┊ 7┊// eslint-disable-next-line\n+┊  ┊ 8┊const Container = styled.div `\n+┊  ┊ 9┊  height: calc(100% - 56px);\n+┊  ┊10┊  overflow-y: overlay;\n+┊  ┊11┊`;\n+┊  ┊12┊\n+┊  ┊13┊// eslint-disable-next-line\n+┊  ┊14┊const StyledUsersList = styled(UsersList) `\n+┊  ┊15┊  height: calc(100% - 56px);\n+┊  ┊16┊`;\n+┊  ┊17┊\n+┊  ┊18┊interface ChildComponentProps {\n+┊  ┊19┊  history: History;\n+┊  ┊20┊};\n+┊  ┊21┊\n+┊  ┊22┊const ChatCreationScreen: React.FC<ChildComponentProps> = ({ history }) => (\n+┊  ┊23┊  <div>\n+┊  ┊24┊    <ChatCreationNavbar history={history} />\n+┊  ┊25┊    <UsersList/>\n+┊  ┊26┊  </div>\n+┊  ┊27┊);\n+┊  ┊28┊\n+┊  ┊29┊export default ChatCreationScreen;\n```\n\n[}]: #\n\nThe screen will be available under the route `/new-chat`. The new route will be restricted, since only authenticated users should be able to access it:\n\n[{]: <helper> (diffStep 12.1 files=\"App\" module=\"client\")\n\n#### Client Step 12.1: Add basic ChatCreationScreen\n\n##### Changed src&#x2F;App.tsx\n```diff\n@@ -3,6 +3,7 @@\n ┊3┊3┊import AuthScreen from './components/AuthScreen';\n ┊4┊4┊import ChatRoomScreen from './components/ChatRoomScreen';\n ┊5┊5┊import ChatsListScreen from './components/ChatsListScreen';\n+┊ ┊6┊import ChatCreationScreen from './components/ChatCreationScreen';\n ┊6┊7┊import AnimatedSwitch from './components/AnimatedSwitch';\n ┊7┊8┊import { withAuth } from './services/auth.service';\n ┊8┊9┊\n```\n```diff\n@@ -17,6 +18,7 @@\n ┊17┊18┊        (<ChatRoomScreen chatId={match.params.chatId} history={history} />)\n ┊18┊19┊      )} />\n ┊19┊20┊\n+┊  ┊21┊      <Route exact path=\"/new-chat\" component={withAuth(ChatCreationScreen)} />\n ┊20┊22┊    </AnimatedSwitch>\n ┊21┊23┊    <Route exact path=\"/\" render={redirectToChats} />\n ┊22┊24┊  </BrowserRouter>\n```\n\n[}]: #\n\nthe `/new-chat` route will be accessible directly from the main `ChatsListScreen`. We will implement a navigation button which is gonna have a fixed position at the bottom right corner of the screen:\n\n[{]: <helper> (diffStep 12.1 files=\"AddChatButton\" module=\"client\")\n\n#### Client Step 12.1: Add basic ChatCreationScreen\n\n##### Added src&#x2F;components&#x2F;ChatsListScreen&#x2F;AddChatButton.test.tsx\n```diff\n@@ -0,0 +1,22 @@\n+┊  ┊ 1┊import { createMemoryHistory } from 'history';\n+┊  ┊ 2┊import React from 'react';\n+┊  ┊ 3┊import { cleanup, render, fireEvent, wait } from 'react-testing-library';\n+┊  ┊ 4┊import AddChatButton from './AddChatButton';\n+┊  ┊ 5┊\n+┊  ┊ 6┊describe('AddChatButton', () => {\n+┊  ┊ 7┊  afterEach(cleanup);\n+┊  ┊ 8┊\n+┊  ┊ 9┊  it('goes back on arrow click', async () => {\n+┊  ┊10┊    const history = createMemoryHistory();\n+┊  ┊11┊\n+┊  ┊12┊    {\n+┊  ┊13┊      const { container, getByTestId } = render(<AddChatButton history={history} />);\n+┊  ┊14┊\n+┊  ┊15┊      fireEvent.click(getByTestId('new-chat-button'));\n+┊  ┊16┊\n+┊  ┊17┊      await wait(() =>\n+┊  ┊18┊        expect(history.location.pathname).toEqual('/new-chat')\n+┊  ┊19┊      );\n+┊  ┊20┊    }\n+┊  ┊21┊  });\n+┊  ┊22┊});\n```\n\n##### Added src&#x2F;components&#x2F;ChatsListScreen&#x2F;AddChatButton.tsx\n```diff\n@@ -0,0 +1,44 @@\n+┊  ┊ 1┊import Button from '@material-ui/core/Button';\n+┊  ┊ 2┊import ChatIcon from '@material-ui/icons/Chat';\n+┊  ┊ 3┊import React from 'react';\n+┊  ┊ 4┊import styled from 'styled-components';\n+┊  ┊ 5┊import { History } from 'history';\n+┊  ┊ 6┊\n+┊  ┊ 7┊const Container = styled.div `\n+┊  ┊ 8┊  position: fixed;\n+┊  ┊ 9┊  right: 10px;\n+┊  ┊10┊  bottom: 10px;\n+┊  ┊11┊\n+┊  ┊12┊  button {\n+┊  ┊13┊    min-width: 50px;\n+┊  ┊14┊    width: 50px;\n+┊  ┊15┊    height: 50px;\n+┊  ┊16┊    border-radius: 999px;\n+┊  ┊17┊    background-color: var(--secondary-bg);\n+┊  ┊18┊    color: white;\n+┊  ┊19┊  }\n+┊  ┊20┊`;\n+┊  ┊21┊interface ChildComponentProps {\n+┊  ┊22┊  history: History;\n+┊  ┊23┊};\n+┊  ┊24┊\n+┊  ┊25┊const AddChatButton: React.FC<ChildComponentProps> = ({ history }) => {\n+┊  ┊26┊  const onClick = () => {\n+┊  ┊27┊    history.push('/new-chat')\n+┊  ┊28┊  };\n+┊  ┊29┊\n+┊  ┊30┊  return (\n+┊  ┊31┊    <Container>\n+┊  ┊32┊      <Button\n+┊  ┊33┊        data-testid=\"new-chat-button\"\n+┊  ┊34┊        variant=\"contained\"\n+┊  ┊35┊        color=\"secondary\"\n+┊  ┊36┊        onClick={onClick}\n+┊  ┊37┊      >\n+┊  ┊38┊        <ChatIcon />\n+┊  ┊39┊      </Button>\n+┊  ┊40┊    </Container>\n+┊  ┊41┊  );\n+┊  ┊42┊};\n+┊  ┊43┊\n+┊  ┊44┊export default AddChatButton;🚫↵\n```\n\n[}]: #\n\nAnd then we will render it in the `ChatsListScreen`:\n\n[{]: <helper> (diffStep 12.1 files=\"ChatsListScreen/index\" module=\"client\")\n\n#### Client Step 12.1: Add basic ChatCreationScreen\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;index.tsx\n```diff\n@@ -3,6 +3,7 @@\n ┊3┊3┊import ChatsList from './ChatsList';\n ┊4┊4┊import styled from 'styled-components';\n ┊5┊5┊import { History } from 'history';\n+┊ ┊6┊import AddChatButton from './AddChatButton';\n ┊6┊7┊\n ┊7┊8┊const Container = styled.div `\n ┊8┊9┊  height: 100vh;\n```\n```diff\n@@ -16,6 +17,7 @@\n ┊16┊17┊  <Container>\n ┊17┊18┊    <ChatsNavbar history={history} />\n ┊18┊19┊    <ChatsList history={history} />\n+┊  ┊20┊    <AddChatButton history={history} />\n ┊19┊21┊  </Container>\n ┊20┊22┊);\n ┊21┊23┊\n```\n\n[}]: #\n\nFor now we can only observe the users list. Our goal now is to be able to start chatting with a user once it has been clicked. First we will need to add a new mutation called `addChat` which will create a new chat document and add it to the chats collection. If the chat already exists we will return the existing instance. This behavior will help us navigate to the desired `ChatRoomScreen`, whether it exists or not:\n\n[{]: <helper> (diffStep 9.2 module=\"server\")\n\n#### [Server Step 9.2: Add Mutation.addChat](https://github.com/Urigo/WhatsApp-Clone-Server/commit/e3509c3)\n\n##### Changed schema&#x2F;resolvers.ts\n```diff\n@@ -1,6 +1,6 @@\n ┊1┊1┊import { withFilter } from 'apollo-server-express'\n ┊2┊2┊import { GraphQLDateTime } from 'graphql-iso-date'\n-┊3┊ ┊import { User, Message, chats, messages, users } from '../db'\n+┊ ┊3┊import { User, Message, Chat, chats, messages, users } from '../db'\n ┊4┊4┊import { Resolvers } from '../types/graphql'\n ┊5┊5┊\n ┊6┊6┊const resolvers: Resolvers = {\n```\n```diff\n@@ -121,7 +121,31 @@\n ┊121┊121┊      })\n ┊122┊122┊\n ┊123┊123┊      return message\n-┊124┊   ┊    }\n+┊   ┊124┊    },\n+┊   ┊125┊\n+┊   ┊126┊    addChat(root, { recipientId }, { currentUser }) {\n+┊   ┊127┊      if (!currentUser) return null\n+┊   ┊128┊      if (!users.some(u => u.id === recipientId)) return null\n+┊   ┊129┊\n+┊   ┊130┊      let chat = chats.find(c =>\n+┊   ┊131┊        c.participants.includes(currentUser.id) &&\n+┊   ┊132┊        c.participants.includes(recipientId)\n+┊   ┊133┊      )\n+┊   ┊134┊\n+┊   ┊135┊      if (chat) return chat\n+┊   ┊136┊\n+┊   ┊137┊      const chatsIds = chats.map(c => Number(c.id))\n+┊   ┊138┊\n+┊   ┊139┊      chat = {\n+┊   ┊140┊        id: String(Math.max(...chatsIds) + 1),\n+┊   ┊141┊        participants: [currentUser.id, recipientId],\n+┊   ┊142┊        messages: [],\n+┊   ┊143┊      }\n+┊   ┊144┊\n+┊   ┊145┊      chats.push(chat)\n+┊   ┊146┊\n+┊   ┊147┊      return chat\n+┊   ┊148┊    },\n ┊125┊149┊  },\n ┊126┊150┊\n ┊127┊151┊  Subscription: {\n```\n\n##### Changed schema&#x2F;typeDefs.graphql\n```diff\n@@ -33,6 +33,7 @@\n ┊33┊33┊\n ┊34┊34┊type Mutation {\n ┊35┊35┊  addMessage(chatId: ID!, content: String!): Message\n+┊  ┊36┊  addChat(recipientId: ID!): Chat\n ┊36┊37┊}\n ┊37┊38┊\n ┊38┊39┊type Subscription {\n```\n\n##### Added tests&#x2F;mutations&#x2F;\\__snapshots__&#x2F;addChat.test.ts.snap\n```diff\n@@ -0,0 +1,52 @@\n+┊  ┊ 1┊// Jest Snapshot v1, https://goo.gl/fbAQLP\n+┊  ┊ 2┊\n+┊  ┊ 3┊exports[`Mutation.addChat creates a new chat between current user and specified recipient 1`] = `\n+┊  ┊ 4┊Object {\n+┊  ┊ 5┊  \"addChat\": Object {\n+┊  ┊ 6┊    \"id\": \"5\",\n+┊  ┊ 7┊    \"name\": \"Bryan Wallace\",\n+┊  ┊ 8┊    \"participants\": Array [\n+┊  ┊ 9┊      Object {\n+┊  ┊10┊        \"id\": \"2\",\n+┊  ┊11┊      },\n+┊  ┊12┊      Object {\n+┊  ┊13┊        \"id\": \"3\",\n+┊  ┊14┊      },\n+┊  ┊15┊    ],\n+┊  ┊16┊  },\n+┊  ┊17┊}\n+┊  ┊18┊`;\n+┊  ┊19┊\n+┊  ┊20┊exports[`Mutation.addChat creates a new chat between current user and specified recipient 2`] = `\n+┊  ┊21┊Object {\n+┊  ┊22┊  \"chat\": Object {\n+┊  ┊23┊    \"id\": \"5\",\n+┊  ┊24┊    \"name\": \"Bryan Wallace\",\n+┊  ┊25┊    \"participants\": Array [\n+┊  ┊26┊      Object {\n+┊  ┊27┊        \"id\": \"2\",\n+┊  ┊28┊      },\n+┊  ┊29┊      Object {\n+┊  ┊30┊        \"id\": \"3\",\n+┊  ┊31┊      },\n+┊  ┊32┊    ],\n+┊  ┊33┊  },\n+┊  ┊34┊}\n+┊  ┊35┊`;\n+┊  ┊36┊\n+┊  ┊37┊exports[`Mutation.addChat returns the existing chat if so 1`] = `\n+┊  ┊38┊Object {\n+┊  ┊39┊  \"addChat\": Object {\n+┊  ┊40┊    \"id\": \"1\",\n+┊  ┊41┊    \"name\": \"Ethan Gonzalez\",\n+┊  ┊42┊    \"participants\": Array [\n+┊  ┊43┊      Object {\n+┊  ┊44┊        \"id\": \"1\",\n+┊  ┊45┊      },\n+┊  ┊46┊      Object {\n+┊  ┊47┊        \"id\": \"2\",\n+┊  ┊48┊      },\n+┊  ┊49┊    ],\n+┊  ┊50┊  },\n+┊  ┊51┊}\n+┊  ┊52┊`;\n```\n\n##### Added tests&#x2F;mutations&#x2F;addChat.test.ts\n```diff\n@@ -0,0 +1,89 @@\n+┊  ┊ 1┊import { createTestClient } from 'apollo-server-testing'\n+┊  ┊ 2┊import { ApolloServer, PubSub, gql } from 'apollo-server-express'\n+┊  ┊ 3┊import schema from '../../schema'\n+┊  ┊ 4┊import { resetDb, users } from '../../db'\n+┊  ┊ 5┊\n+┊  ┊ 6┊describe('Mutation.addChat', () => {\n+┊  ┊ 7┊  beforeEach(resetDb)\n+┊  ┊ 8┊\n+┊  ┊ 9┊  it('creates a new chat between current user and specified recipient', async () => {\n+┊  ┊10┊    const server = new ApolloServer({\n+┊  ┊11┊      schema,\n+┊  ┊12┊      context: () => ({\n+┊  ┊13┊        pubsub: new PubSub(),\n+┊  ┊14┊        currentUser: users[1],\n+┊  ┊15┊      }),\n+┊  ┊16┊    })\n+┊  ┊17┊\n+┊  ┊18┊    const { query, mutate } = createTestClient(server)\n+┊  ┊19┊\n+┊  ┊20┊    const addChatRes = await mutate({\n+┊  ┊21┊      variables: { recipientId: '3' },\n+┊  ┊22┊      mutation: gql `\n+┊  ┊23┊        mutation AddChat($recipientId: ID!) {\n+┊  ┊24┊          addChat(recipientId: $recipientId) {\n+┊  ┊25┊            id\n+┊  ┊26┊            name\n+┊  ┊27┊            participants {\n+┊  ┊28┊              id\n+┊  ┊29┊            }\n+┊  ┊30┊          }\n+┊  ┊31┊        }\n+┊  ┊32┊      `,\n+┊  ┊33┊    })\n+┊  ┊34┊\n+┊  ┊35┊    expect(addChatRes.data).toBeDefined()\n+┊  ┊36┊    expect(addChatRes.errors).toBeUndefined()\n+┊  ┊37┊    expect(addChatRes.data).toMatchSnapshot()\n+┊  ┊38┊\n+┊  ┊39┊    const getChatRes = await query({\n+┊  ┊40┊      variables: { chatId: '5' },\n+┊  ┊41┊      query: gql `\n+┊  ┊42┊        query GetChat($chatId: ID!) {\n+┊  ┊43┊          chat(chatId: $chatId) {\n+┊  ┊44┊            id\n+┊  ┊45┊            name\n+┊  ┊46┊            participants {\n+┊  ┊47┊              id\n+┊  ┊48┊            }\n+┊  ┊49┊          }\n+┊  ┊50┊        }\n+┊  ┊51┊      `,\n+┊  ┊52┊    })\n+┊  ┊53┊\n+┊  ┊54┊    expect(getChatRes.data).toBeDefined()\n+┊  ┊55┊    expect(getChatRes.errors).toBeUndefined()\n+┊  ┊56┊    expect(getChatRes.data).toMatchSnapshot()\n+┊  ┊57┊  })\n+┊  ┊58┊\n+┊  ┊59┊  it('returns the existing chat if so', async () => {\n+┊  ┊60┊    const server = new ApolloServer({\n+┊  ┊61┊      schema,\n+┊  ┊62┊      context: () => ({\n+┊  ┊63┊        pubsub: new PubSub(),\n+┊  ┊64┊        currentUser: users[0],\n+┊  ┊65┊      }),\n+┊  ┊66┊    })\n+┊  ┊67┊\n+┊  ┊68┊    const { query, mutate } = createTestClient(server)\n+┊  ┊69┊\n+┊  ┊70┊    const addChatRes = await mutate({\n+┊  ┊71┊      variables: { recipientId: '2' },\n+┊  ┊72┊      mutation: gql `\n+┊  ┊73┊        mutation AddChat($recipientId: ID!) {\n+┊  ┊74┊          addChat(recipientId: $recipientId) {\n+┊  ┊75┊            id\n+┊  ┊76┊            name\n+┊  ┊77┊            participants {\n+┊  ┊78┊              id\n+┊  ┊79┊            }\n+┊  ┊80┊          }\n+┊  ┊81┊        }\n+┊  ┊82┊      `,\n+┊  ┊83┊    })\n+┊  ┊84┊\n+┊  ┊85┊    expect(addChatRes.data).toBeDefined()\n+┊  ┊86┊    expect(addChatRes.errors).toBeUndefined()\n+┊  ┊87┊    expect(addChatRes.data).toMatchSnapshot()\n+┊  ┊88┊  })\n+┊  ┊89┊})\n```\n\n[}]: #\n\nTo use the new mutation, we will define a new callback called `onUserPick` in the `UsersList` so it can be used from the `ChatCreationScreen`:\n\n[{]: <helper> (diffStep 12.2 files=\"UsersList\" module=\"client\")\n\n#### Client Step 12.2: Create chat on user pick\n\n##### Changed src&#x2F;components&#x2F;UsersList.test.tsx\n```diff\n@@ -1,6 +1,6 @@\n ┊1┊1┊import React from 'react';\n ┊2┊2┊import { ApolloProvider } from 'react-apollo-hooks';\n-┊3┊ ┊import { cleanup, render, waitForDomChange } from 'react-testing-library';\n+┊ ┊3┊import { cleanup, render, fireEvent, wait, waitForDomChange } from 'react-testing-library';\n ┊4┊4┊import { mockApolloClient } from '../test-helpers';\n ┊5┊5┊import UsersList, { UsersListQuery } from './UsersList';\n ┊6┊6┊import * as queries from '../graphql/queries';\n```\n```diff\n@@ -40,4 +40,45 @@\n ┊40┊40┊      expect(getByTestId('picture')).toHaveAttribute('src', 'https://localhost:4000/dick.jpg');\n ┊41┊41┊    }\n ┊42┊42┊  })\n+┊  ┊43┊\n+┊  ┊44┊  it('triggers onUserPick() callback on user-item click', async () => {\n+┊  ┊45┊    const client = mockApolloClient([\n+┊  ┊46┊      {\n+┊  ┊47┊        request: { query: UsersListQuery },\n+┊  ┊48┊        result: {\n+┊  ┊49┊          data: {\n+┊  ┊50┊            users: [\n+┊  ┊51┊              {\n+┊  ┊52┊                __typename: 'User',\n+┊  ┊53┊                id: 1,\n+┊  ┊54┊                name: 'Charles Dickhead',\n+┊  ┊55┊                picture: 'https://localhost:4000/dick.jpg',\n+┊  ┊56┊              },\n+┊  ┊57┊            ],\n+┊  ┊58┊          },\n+┊  ┊59┊        },\n+┊  ┊60┊      },\n+┊  ┊61┊    ]);\n+┊  ┊62┊\n+┊  ┊63┊    const onUserPick = jest.fn(() => {});\n+┊  ┊64┊\n+┊  ┊65┊    {\n+┊  ┊66┊      const { container, getByTestId } = render(\n+┊  ┊67┊        <ApolloProvider client={client}>\n+┊  ┊68┊          <UsersList onUserPick={onUserPick} />\n+┊  ┊69┊        </ApolloProvider>\n+┊  ┊70┊      );\n+┊  ┊71┊\n+┊  ┊72┊      await waitForDomChange({ container });\n+┊  ┊73┊\n+┊  ┊74┊      fireEvent.click(getByTestId('user'));\n+┊  ┊75┊\n+┊  ┊76┊      await wait(() =>\n+┊  ┊77┊        expect(onUserPick.mock.calls.length).toBe(1)\n+┊  ┊78┊      );\n+┊  ┊79┊\n+┊  ┊80┊      expect(onUserPick.mock.calls[0][0].name).toEqual('Charles Dickhead');\n+┊  ┊81┊      expect(onUserPick.mock.calls[0][0].picture).toEqual('https://localhost:4000/dick.jpg');\n+┊  ┊82┊    }\n+┊  ┊83┊  });\n ┊43┊84┊});\n```\n\n##### Changed src&#x2F;components&#x2F;UsersList.tsx\n```diff\n@@ -4,7 +4,7 @@\n ┊ 4┊ 4┊import React from 'react';\n ┊ 5┊ 5┊import styled from 'styled-components';\n ┊ 6┊ 6┊import * as fragments from '../graphql/fragments';\n-┊ 7┊  ┊import { useUsersListQuery } from '../graphql/types';\n+┊  ┊ 7┊import { useUsersListQuery, User } from '../graphql/types';\n ┊ 8┊ 8┊\n ┊ 9┊ 9┊const ActualList = styled(MaterialList) `\n ┊10┊10┊  padding: 0;\n```\n```diff\n@@ -38,7 +38,11 @@\n ┊38┊38┊  ${fragments.user}\n ┊39┊39┊`;\n ┊40┊40┊\n-┊41┊  ┊const UsersList: React.FC = () => {\n+┊  ┊41┊interface ChildComponentProps {\n+┊  ┊42┊  onUserPick: any;\n+┊  ┊43┊};\n+┊  ┊44┊\n+┊  ┊45┊const UsersList: React.FC<ChildComponentProps> = ({ onUserPick = (user: User) => {} }) => {\n ┊42┊46┊  const { data, loading: loadingUsers } = useUsersListQuery();\n ┊43┊47┊\n ┊44┊48┊  if (data === undefined) return null;\n```\n```diff\n@@ -49,6 +53,8 @@\n ┊49┊53┊      {!loadingUsers && users.map(user => (\n ┊50┊54┊        <UserItem\n ┊51┊55┊          key={user.id}\n+┊  ┊56┊          data-testid=\"user\"\n+┊  ┊57┊          onClick={onUserPick.bind(null, user)}\n ┊52┊58┊          button\n ┊53┊59┊        >\n ┊54┊60┊          {(user !== null && user.picture !== null) &&\n```\n\n[}]: #\n\nIn the `ChatCreationScreen/index.tsx` module, we will define an `AddChat` document with `graphql-tag`. Using the `$ yarn codegen` command we can generate the correlated React mutation hook and use it as the `onUserPick` callback:\n\n[{]: <helper> (diffStep 12.2 files=\"ChatCreationScreen/index\" module=\"client\")\n\n#### Client Step 12.2: Create chat on user pick\n\n##### Changed src&#x2F;components&#x2F;ChatCreationScreen&#x2F;index.tsx\n```diff\n@@ -1,8 +1,12 @@\n+┊  ┊ 1┊import gql from 'graphql-tag';\n ┊ 1┊ 2┊import React from 'react';\n+┊  ┊ 3┊import { useCallback } from 'react';\n ┊ 2┊ 4┊import styled from 'styled-components';\n+┊  ┊ 5┊import * as fragments from '../../graphql/fragments';\n ┊ 3┊ 6┊import UsersList from '../UsersList';\n ┊ 4┊ 7┊import ChatCreationNavbar from './ChatCreationNavbar';\n ┊ 5┊ 8┊import { History } from 'history';\n+┊  ┊ 9┊import { useAddChatMutation } from '../../graphql/types';\n ┊ 6┊10┊\n ┊ 7┊11┊// eslint-disable-next-line\n ┊ 8┊12┊const Container = styled.div `\n```\n```diff\n@@ -15,15 +19,50 @@\n ┊15┊19┊  height: calc(100% - 56px);\n ┊16┊20┊`;\n ┊17┊21┊\n+┊  ┊22┊gql`\n+┊  ┊23┊  mutation AddChat($recipientId: ID!) {\n+┊  ┊24┊    addChat(recipientId: $recipientId) {\n+┊  ┊25┊      ...Chat\n+┊  ┊26┊    }\n+┊  ┊27┊  }\n+┊  ┊28┊  ${fragments.chat}\n+┊  ┊29┊`;\n+┊  ┊30┊\n ┊18┊31┊interface ChildComponentProps {\n ┊19┊32┊  history: History;\n ┊20┊33┊};\n ┊21┊34┊\n-┊22┊  ┊const ChatCreationScreen: React.FC<ChildComponentProps> = ({ history }) => (\n-┊23┊  ┊  <div>\n-┊24┊  ┊    <ChatCreationNavbar history={history} />\n-┊25┊  ┊    <UsersList/>\n-┊26┊  ┊  </div>\n-┊27┊  ┊);\n+┊  ┊35┊const ChatCreationScreen: React.FC<ChildComponentProps> = ({ history }) => {\n+┊  ┊36┊  const addChat = useAddChatMutation();\n+┊  ┊37┊\n+┊  ┊38┊  const onUserPick = useCallback((user) => {\n+┊  ┊39┊    addChat({\n+┊  ┊40┊      optimisticResponse: {\n+┊  ┊41┊        __typename: 'Mutation',\n+┊  ┊42┊        addChat: {\n+┊  ┊43┊          __typename: 'Chat',\n+┊  ┊44┊          id: Math.random().toString(36).substr(2, 9),\n+┊  ┊45┊          name: user.name,\n+┊  ┊46┊          picture: user.picture,\n+┊  ┊47┊          lastMessage: null,\n+┊  ┊48┊        },\n+┊  ┊49┊      },\n+┊  ┊50┊      variables: {\n+┊  ┊51┊        recipientId: user.id,\n+┊  ┊52┊      },\n+┊  ┊53┊    }).then(({ data }) => {\n+┊  ┊54┊      if (data !== null) {\n+┊  ┊55┊        history.push(`/chats/${data.addChat.id}`);\n+┊  ┊56┊      }\n+┊  ┊57┊    })\n+┊  ┊58┊  }, [addChat, history]);\n+┊  ┊59┊\n+┊  ┊60┊  return (\n+┊  ┊61┊    <div>\n+┊  ┊62┊      <ChatCreationNavbar history={history} />\n+┊  ┊63┊      <UsersList onUserPick={onUserPick} />\n+┊  ┊64┊    </div>\n+┊  ┊65┊  );\n+┊  ┊66┊};\n ┊28┊67┊\n ┊29┊68┊export default ChatCreationScreen;\n```\n\n[}]: #\n\nChats can now be created, you can test out the function by signing in with different users. However, the chats list in the `ChatsListScreen` will not be updated unless we refresh the page manually. In the server project, we will define a new subscription called `chatAdded`. The subscription should be broadcasted to the current user only if he is a participant of the published chat:\n\n[{]: <helper> (diffStep 9.3 module=\"server\")\n\n#### [Server Step 9.3: Add Subscription.chatAdded](https://github.com/Urigo/WhatsApp-Clone-Server/commit/693b6bd)\n\n##### Changed schema&#x2F;resolvers.ts\n```diff\n@@ -123,7 +123,7 @@\n ┊123┊123┊      return message\n ┊124┊124┊    },\n ┊125┊125┊\n-┊126┊   ┊    addChat(root, { recipientId }, { currentUser }) {\n+┊   ┊126┊    addChat(root, { recipientId }, { currentUser, pubsub }) {\n ┊127┊127┊      if (!currentUser) return null\n ┊128┊128┊      if (!users.some(u => u.id === recipientId)) return null\n ┊129┊129┊\n```\n```diff\n@@ -144,6 +144,10 @@\n ┊144┊144┊\n ┊145┊145┊      chats.push(chat)\n ┊146┊146┊\n+┊   ┊147┊      pubsub.publish('chatAdded', {\n+┊   ┊148┊        chatAdded: chat\n+┊   ┊149┊      })\n+┊   ┊150┊\n ┊147┊151┊      return chat\n ┊148┊152┊    },\n ┊149┊153┊  },\n```\n```diff\n@@ -161,6 +165,17 @@\n ┊161┊165┊          ].includes(currentUser.id)\n ┊162┊166┊        },\n ┊163┊167┊      )\n+┊   ┊168┊    },\n+┊   ┊169┊\n+┊   ┊170┊    chatAdded: {\n+┊   ┊171┊      subscribe: withFilter(\n+┊   ┊172┊        (root, args, { pubsub }) => pubsub.asyncIterator('chatAdded'),\n+┊   ┊173┊        ({ chatAdded }: { chatAdded: Chat }, args, { currentUser }) => {\n+┊   ┊174┊          if (!currentUser) return false\n+┊   ┊175┊\n+┊   ┊176┊          return chatAdded.participants.some(p => p === currentUser.id)\n+┊   ┊177┊        },\n+┊   ┊178┊      )\n ┊164┊179┊    }\n ┊165┊180┊  }\n ┊166┊181┊}\n```\n\n##### Changed schema&#x2F;typeDefs.graphql\n```diff\n@@ -38,4 +38,5 @@\n ┊38┊38┊\n ┊39┊39┊type Subscription {\n ┊40┊40┊  messageAdded: Message!\n+┊  ┊41┊  chatAdded: Chat!\n ┊41┊42┊}\n```\n\n[}]: #\n\nNow we will listen to the new subscription in the client and update the cache. First we will define the subscription document:\n\n[{]: <helper> (diffStep 12.3 files=\"graphql/subscriptions\" module=\"client\")\n\n#### Client Step 12.3: Write chat on chatAdded\n\n##### Added src&#x2F;graphql&#x2F;subscriptions&#x2F;chatAdded.subscription.ts\n```diff\n@@ -0,0 +1,11 @@\n+┊  ┊ 1┊import gql from 'graphql-tag';\n+┊  ┊ 2┊import * as fragments from '../fragments';\n+┊  ┊ 3┊\n+┊  ┊ 4┊export default gql`\n+┊  ┊ 5┊  subscription ChatAdded {\n+┊  ┊ 6┊    chatAdded {\n+┊  ┊ 7┊      ...Chat\n+┊  ┊ 8┊    }\n+┊  ┊ 9┊  }\n+┊  ┊10┊  ${fragments.chat}\n+┊  ┊11┊`;\n```\n\n##### Changed src&#x2F;graphql&#x2F;subscriptions&#x2F;index.ts\n```diff\n@@ -1 +1,2 @@\n ┊1┊1┊export { default as messageAdded } from './messageAdded.subscription';\n+┊ ┊2┊export { default as chatAdded } from './chatAdded.subscription';\n```\n\n[}]: #\n\nAnd then we will update the `cache.service` to write the broadcasted chat to the store. We will write the fragment, and we will also update the `chats` query to contain the new chat. We will also check if the chat already exists before we update the query, because remember, the `addChat` mutation will return the chat even if it already exists, not if it was created only:\n\n[{]: <helper> (diffStep 12.3 module=\"client\")\n\n#### Client Step 12.3: Write chat on chatAdded\n\n##### Changed src&#x2F;components&#x2F;ChatCreationScreen&#x2F;index.tsx\n```diff\n@@ -7,6 +7,7 @@\n ┊ 7┊ 7┊import ChatCreationNavbar from './ChatCreationNavbar';\n ┊ 8┊ 8┊import { History } from 'history';\n ┊ 9┊ 9┊import { useAddChatMutation } from '../../graphql/types';\n+┊  ┊10┊import { writeChat } from '../../services/cache.service';\n ┊10┊11┊\n ┊11┊12┊// eslint-disable-next-line\n ┊12┊13┊const Container = styled.div `\n```\n```diff\n@@ -33,7 +34,11 @@\n ┊33┊34┊};\n ┊34┊35┊\n ┊35┊36┊const ChatCreationScreen: React.FC<ChildComponentProps> = ({ history }) => {\n-┊36┊  ┊  const addChat = useAddChatMutation();\n+┊  ┊37┊  const addChat = useAddChatMutation({\n+┊  ┊38┊    update: (client, { data: { addChat } }) => {\n+┊  ┊39┊      writeChat(client, addChat);\n+┊  ┊40┊    }\n+┊  ┊41┊  });\n ┊37┊42┊\n ┊38┊43┊  const onUserPick = useCallback((user) => {\n ┊39┊44┊    addChat({\n```\n\n##### Added src&#x2F;graphql&#x2F;subscriptions&#x2F;chatAdded.subscription.ts\n```diff\n@@ -0,0 +1,11 @@\n+┊  ┊ 1┊import gql from 'graphql-tag';\n+┊  ┊ 2┊import * as fragments from '../fragments';\n+┊  ┊ 3┊\n+┊  ┊ 4┊export default gql`\n+┊  ┊ 5┊  subscription ChatAdded {\n+┊  ┊ 6┊    chatAdded {\n+┊  ┊ 7┊      ...Chat\n+┊  ┊ 8┊    }\n+┊  ┊ 9┊  }\n+┊  ┊10┊  ${fragments.chat}\n+┊  ┊11┊`;\n```\n\n##### Changed src&#x2F;graphql&#x2F;subscriptions&#x2F;index.ts\n```diff\n@@ -1 +1,2 @@\n ┊1┊1┊export { default as messageAdded } from './messageAdded.subscription';\n+┊ ┊2┊export { default as chatAdded } from './chatAdded.subscription';\n```\n\n##### Changed src&#x2F;services&#x2F;cache.service.ts\n```diff\n@@ -5,7 +5,9 @@\n ┊ 5┊ 5┊import * as queries from '../graphql/queries';\n ┊ 6┊ 6┊import {\n ┊ 7┊ 7┊  MessageFragment,\n+┊  ┊ 8┊  ChatFragment,\n ┊ 8┊ 9┊  useMessageAddedSubscription,\n+┊  ┊10┊  useChatAddedSubscription,\n ┊ 9┊11┊} from '../graphql/types';\n ┊10┊12┊\n ┊11┊13┊type Client = ApolloClient<any> | DataProxy;\n```\n```diff\n@@ -18,6 +20,14 @@\n ┊18┊20┊      }\n ┊19┊21┊    }\n ┊20┊22┊  });\n+┊  ┊23┊\n+┊  ┊24┊  useChatAddedSubscription({\n+┊  ┊25┊    onSubscriptionData: ({ client, subscriptionData: { data } }) => {\n+┊  ┊26┊      if (data) {\n+┊  ┊27┊        writeChat(client, data.chatAdded);\n+┊  ┊28┊      }\n+┊  ┊29┊    }\n+┊  ┊30┊  });\n ┊21┊31┊};\n ┊22┊32┊\n ┊23┊33┊export const writeMessage = (client: Client, message: MessageFragment) => {\n```\n```diff\n@@ -83,3 +93,41 @@\n ┊ 83┊ 93┊    data: { chats: chats },\n ┊ 84┊ 94┊  });\n ┊ 85┊ 95┊}\n+┊   ┊ 96┊\n+┊   ┊ 97┊export const writeChat = (client: Client, chat: ChatFragment) => {\n+┊   ┊ 98┊\n+┊   ┊ 99┊  const chatId = defaultDataIdFromObject(chat);\n+┊   ┊100┊  if (chatId === null) {\n+┊   ┊101┊    return;\n+┊   ┊102┊  }\n+┊   ┊103┊\n+┊   ┊104┊  client.writeFragment({\n+┊   ┊105┊    id: chatId,\n+┊   ┊106┊    fragment: fragments.chat,\n+┊   ┊107┊    fragmentName: 'Chat',\n+┊   ┊108┊    data: chat,\n+┊   ┊109┊  })\n+┊   ┊110┊\n+┊   ┊111┊  let data;\n+┊   ┊112┊  try {\n+┊   ┊113┊    data = client.readQuery({\n+┊   ┊114┊      query: queries.chats,\n+┊   ┊115┊    })\n+┊   ┊116┊  } catch (e) {\n+┊   ┊117┊    return;\n+┊   ┊118┊  }\n+┊   ┊119┊\n+┊   ┊120┊  if (!data) return;\n+┊   ┊121┊\n+┊   ┊122┊  const chats = data.chats;\n+┊   ┊123┊\n+┊   ┊124┊  if (!chats) return;\n+┊   ┊125┊  if (chats.some((c: any) => c.id === chat.id)) return;\n+┊   ┊126┊\n+┊   ┊127┊  chats.unshift(chat)\n+┊   ┊128┊\n+┊   ┊129┊  client.writeQuery({\n+┊   ┊130┊    query: queries.chats,\n+┊   ┊131┊    data: { chats },\n+┊   ┊132┊  });\n+┊   ┊133┊}\n```\n\n[}]: #\n\nNow we can create new chats, and the chats list would be updated, without refreshing the page. You can also test it with 2 separate sessions in the browser and see how each tab/window affects the other. Lastly, we will implement a chat removal function. This is important as we don’t want to garbage our chats collection, sometimes we would like to clean up some of them.\n\nIn the back-end, let’s implement the `removeChat` mutation. The chat can only be removed only if the current user is one of the chat’s participants. The mutation will also remove all the messages which are related to the target chat, since we’re not gonna use them anymore. The chat will be removed for all participants. This is not exactly the behavior of the original Whatsapp, but to keep things simple we will go with that solution:\n\n[{]: <helper> (diffStep 9.4 module=\"server\")\n\n#### [Server Step 9.4: Add Mutation.removeChat](https://github.com/Urigo/WhatsApp-Clone-Server/commit/19f69d9)\n\n##### Changed schema&#x2F;resolvers.ts\n```diff\n@@ -150,6 +150,30 @@\n ┊150┊150┊\n ┊151┊151┊      return chat\n ┊152┊152┊    },\n+┊   ┊153┊\n+┊   ┊154┊    removeChat(root, { chatId }, { currentUser }) {\n+┊   ┊155┊      if (!currentUser) return null\n+┊   ┊156┊\n+┊   ┊157┊      const chatIndex = chats.findIndex(c => c.id === chatId)\n+┊   ┊158┊\n+┊   ┊159┊      if (chatIndex === -1) return null\n+┊   ┊160┊\n+┊   ┊161┊      const chat = chats[chatIndex]\n+┊   ┊162┊\n+┊   ┊163┊      if (!chat.participants.some(p => p === currentUser.id)) return null\n+┊   ┊164┊\n+┊   ┊165┊      chat.messages.forEach((chatMessage) => {\n+┊   ┊166┊        const chatMessageIndex = messages.findIndex(m => m.id === chatMessage)\n+┊   ┊167┊\n+┊   ┊168┊        if (chatMessageIndex !== -1) {\n+┊   ┊169┊          messages.splice(chatMessageIndex, 1)\n+┊   ┊170┊        }\n+┊   ┊171┊      })\n+┊   ┊172┊\n+┊   ┊173┊      chats.splice(chatIndex, 1)\n+┊   ┊174┊\n+┊   ┊175┊      return chatId\n+┊   ┊176┊    }\n ┊153┊177┊  },\n ┊154┊178┊\n ┊155┊179┊  Subscription: {\n```\n\n##### Changed schema&#x2F;typeDefs.graphql\n```diff\n@@ -34,6 +34,7 @@\n ┊34┊34┊type Mutation {\n ┊35┊35┊  addMessage(chatId: ID!, content: String!): Message\n ┊36┊36┊  addChat(recipientId: ID!): Chat\n+┊  ┊37┊  removeChat(chatId: ID!): ID\n ┊37┊38┊}\n ┊38┊39┊\n ┊39┊40┊type Subscription {\n```\n\n##### Added tests&#x2F;mutations&#x2F;removeChat.test.ts\n```diff\n@@ -0,0 +1,52 @@\n+┊  ┊ 1┊import { createTestClient } from 'apollo-server-testing'\n+┊  ┊ 2┊import { ApolloServer, PubSub, gql } from 'apollo-server-express'\n+┊  ┊ 3┊import schema from '../../schema'\n+┊  ┊ 4┊import { resetDb, users } from '../../db'\n+┊  ┊ 5┊\n+┊  ┊ 6┊describe('Mutation.removeChat', () => {\n+┊  ┊ 7┊  beforeEach(resetDb)\n+┊  ┊ 8┊\n+┊  ┊ 9┊  it('removes chat by id', async () => {\n+┊  ┊10┊    const server = new ApolloServer({\n+┊  ┊11┊      schema,\n+┊  ┊12┊      context: () => ({\n+┊  ┊13┊        pubsub: new PubSub(),\n+┊  ┊14┊        currentUser: users[0],\n+┊  ┊15┊      }),\n+┊  ┊16┊    })\n+┊  ┊17┊\n+┊  ┊18┊    const { query, mutate } = createTestClient(server)\n+┊  ┊19┊\n+┊  ┊20┊    const addChatRes = await mutate({\n+┊  ┊21┊      variables: { chatId: '1' },\n+┊  ┊22┊      mutation: gql `\n+┊  ┊23┊        mutation RemoveChat($chatId: ID!) {\n+┊  ┊24┊          removeChat(chatId: $chatId)\n+┊  ┊25┊        }\n+┊  ┊26┊      `,\n+┊  ┊27┊    })\n+┊  ┊28┊\n+┊  ┊29┊    expect(addChatRes.data).toBeDefined()\n+┊  ┊30┊    expect(addChatRes.errors).toBeUndefined()\n+┊  ┊31┊    expect(addChatRes.data!.removeChat).toEqual('1')\n+┊  ┊32┊\n+┊  ┊33┊    const getChatRes = await query({\n+┊  ┊34┊      variables: { chatId: '1' },\n+┊  ┊35┊      query: gql `\n+┊  ┊36┊        query GetChat($chatId: ID!) {\n+┊  ┊37┊          chat(chatId: $chatId) {\n+┊  ┊38┊            id\n+┊  ┊39┊            name\n+┊  ┊40┊            participants {\n+┊  ┊41┊              id\n+┊  ┊42┊            }\n+┊  ┊43┊          }\n+┊  ┊44┊        }\n+┊  ┊45┊      `,\n+┊  ┊46┊    })\n+┊  ┊47┊\n+┊  ┊48┊    expect(addChatRes.data).toBeDefined()\n+┊  ┊49┊    expect(getChatRes.errors).toBeUndefined()\n+┊  ┊50┊    expect(addChatRes.data!.chat).toBeUndefined()\n+┊  ┊51┊  })\n+┊  ┊52┊})\n```\n\n[}]: #\n\nIn the client app, a chat could be removed directly from the `ChatRoomScreen`. On the top right corner, right on the navbar, we will add a dispose button that will call the `removeChat` mutation. Just like we did before, we will define the mutation document with `graphql-tag` and generate the correlated hook with CodeGen:\n\n[{]: <helper> (diffStep 12.4 module=\"client\")\n\n#### Client Step 12.4: Add chat removal function\n\n##### Changed src&#x2F;components&#x2F;ChatRoomScreen&#x2F;ChatNavbar.test.tsx\n```diff\n@@ -1,12 +1,17 @@\n ┊ 1┊ 1┊import { createMemoryHistory } from 'history';\n ┊ 2┊ 2┊import React from 'react';\n+┊  ┊ 3┊import { ApolloProvider } from 'react-apollo-hooks';\n ┊ 3┊ 4┊import { cleanup, render, fireEvent, wait } from 'react-testing-library';\n+┊  ┊ 5┊import { mockApolloClient } from '../../test-helpers';\n ┊ 4┊ 6┊import ChatNavbar from './ChatNavbar';\n+┊  ┊ 7┊import { RemoveChatDocument } from '../../graphql/types';\n ┊ 5┊ 8┊\n ┊ 6┊ 9┊describe('ChatNavbar', () => {\n ┊ 7┊10┊  afterEach(cleanup);\n ┊ 8┊11┊\n ┊ 9┊12┊  it('renders chat data', () => {\n+┊  ┊13┊    const client = mockApolloClient();\n+┊  ┊14┊\n ┊10┊15┊    const chat = {\n ┊11┊16┊      id: '1',\n ┊12┊17┊      name: 'Foo Bar',\n```\n```diff\n@@ -14,7 +19,11 @@\n ┊14┊19┊    };\n ┊15┊20┊\n ┊16┊21┊    {\n-┊17┊  ┊      const { container, getByTestId } = render(<ChatNavbar chat={chat} />);\n+┊  ┊22┊      const { container, getByTestId } = render(\n+┊  ┊23┊        <ApolloProvider client={client}>\n+┊  ┊24┊          <ChatNavbar chat={chat} />\n+┊  ┊25┊        </ApolloProvider>\n+┊  ┊26┊      );\n ┊18┊27┊\n ┊19┊28┊      expect(getByTestId('chat-name')).toHaveTextContent('Foo Bar');\n ┊20┊29┊      expect(getByTestId('chat-picture')).toHaveAttribute('src', 'https://localhost:4000/picture.jpg');\n```\n```diff\n@@ -22,6 +31,8 @@\n ┊22┊31┊  })\n ┊23┊32┊\n ┊24┊33┊  it('goes back on arrow click', async () => {\n+┊  ┊34┊    const client = mockApolloClient();\n+┊  ┊35┊\n ┊25┊36┊    const chat = {\n ┊26┊37┊      id: '1',\n ┊27┊38┊      name: 'Foo Bar',\n```\n```diff\n@@ -37,7 +48,11 @@\n ┊37┊48┊    )\n ┊38┊49┊\n ┊39┊50┊    {\n-┊40┊  ┊      const { container, getByTestId } = render(<ChatNavbar chat={chat} history={history} />);\n+┊  ┊51┊      const { container, getByTestId } = render(\n+┊  ┊52┊        <ApolloProvider client={client}>\n+┊  ┊53┊          <ChatNavbar chat={chat} history={history} />\n+┊  ┊54┊        </ApolloProvider>\n+┊  ┊55┊      );\n ┊41┊56┊\n ┊42┊57┊      fireEvent.click(getByTestId('back-button'));\n ┊43┊58┊\n```\n```diff\n@@ -46,4 +61,48 @@\n ┊ 46┊ 61┊      );\n ┊ 47┊ 62┊    }\n ┊ 48┊ 63┊  });\n+┊   ┊ 64┊\n+┊   ┊ 65┊  it('goes back on chat removal', async () => {\n+┊   ┊ 66┊    const client = mockApolloClient([\n+┊   ┊ 67┊      {\n+┊   ┊ 68┊        request: {\n+┊   ┊ 69┊          query: RemoveChatDocument,\n+┊   ┊ 70┊          variables: { chatId: '1' },\n+┊   ┊ 71┊        },\n+┊   ┊ 72┊        result: {\n+┊   ┊ 73┊          data: {\n+┊   ┊ 74┊            removeChat: '1'\n+┊   ┊ 75┊          }\n+┊   ┊ 76┊        }\n+┊   ┊ 77┊      },\n+┊   ┊ 78┊    ]);\n+┊   ┊ 79┊\n+┊   ┊ 80┊    const chat = {\n+┊   ┊ 81┊      id: '1',\n+┊   ┊ 82┊      name: 'Foo Bar',\n+┊   ┊ 83┊      picture: 'https://localhost:4000/picture.jpg',\n+┊   ┊ 84┊    };\n+┊   ┊ 85┊\n+┊   ┊ 86┊    const history = createMemoryHistory();\n+┊   ┊ 87┊\n+┊   ┊ 88┊    history.push('/chats/1');\n+┊   ┊ 89┊\n+┊   ┊ 90┊    await wait(() =>\n+┊   ┊ 91┊      expect(history.location.pathname).toEqual('/chats/1')\n+┊   ┊ 92┊    );\n+┊   ┊ 93┊\n+┊   ┊ 94┊    {\n+┊   ┊ 95┊      const { container, getByTestId } = render(\n+┊   ┊ 96┊        <ApolloProvider client={client}>\n+┊   ┊ 97┊          <ChatNavbar chat={chat} history={history} />\n+┊   ┊ 98┊        </ApolloProvider>\n+┊   ┊ 99┊      );\n+┊   ┊100┊\n+┊   ┊101┊      fireEvent.click(getByTestId('delete-button'));\n+┊   ┊102┊\n+┊   ┊103┊      await wait(() =>\n+┊   ┊104┊        expect(history.location.pathname).toEqual('/chats')\n+┊   ┊105┊      );\n+┊   ┊106┊    }\n+┊   ┊107┊  })\n ┊ 49┊108┊});🚫↵\n```\n\n##### Changed src&#x2F;components&#x2F;ChatRoomScreen&#x2F;ChatNavbar.tsx\n```diff\n@@ -1,10 +1,13 @@\n ┊ 1┊ 1┊import Button from '@material-ui/core/Button';\n ┊ 2┊ 2┊import Toolbar from '@material-ui/core/Toolbar';\n ┊ 3┊ 3┊import ArrowBackIcon from '@material-ui/icons/ArrowBack';\n+┊  ┊ 4┊import DeleteIcon from '@material-ui/icons/Delete';\n+┊  ┊ 5┊import gql from 'graphql-tag';\n ┊ 4┊ 6┊import React from 'react';\n ┊ 5┊ 7┊import { useCallback } from 'react';\n ┊ 6┊ 8┊import styled from 'styled-components';\n ┊ 7┊ 9┊import { History } from 'history';\n+┊  ┊10┊import { useRemoveChatMutation } from '../../graphql/types';\n ┊ 8┊11┊\n ┊ 9┊12┊const Container = styled(Toolbar) `\n ┊10┊13┊  padding: 0;\n```\n```diff\n@@ -20,6 +23,12 @@\n ┊20┊23┊  }\n ┊21┊24┊` as typeof Button;\n ┊22┊25┊\n+┊  ┊26┊const Rest = styled.div `\n+┊  ┊27┊  flex: 1;\n+┊  ┊28┊  display: flex;\n+┊  ┊29┊  justify-content: flex-end;\n+┊  ┊30┊`\n+┊  ┊31┊\n ┊23┊32┊const Picture = styled.img `\n ┊24┊33┊  height: 40px;\n ┊25┊34┊  width: 40px;\n```\n```diff\n@@ -34,15 +43,38 @@\n ┊34┊43┊  line-height: 56px;\n ┊35┊44┊`;\n ┊36┊45┊\n+┊  ┊46┊const DeleteButton = styled(Button)`\n+┊  ┊47┊  color: var(--primary-text) !important;\n+┊  ┊48┊` as typeof Button;\n+┊  ┊49┊\n+┊  ┊50┊export const removeChatMutation = gql`\n+┊  ┊51┊  mutation RemoveChat($chatId: ID!) {\n+┊  ┊52┊    removeChat(chatId: $chatId)\n+┊  ┊53┊  }\n+┊  ┊54┊`;\n+┊  ┊55┊\n ┊37┊56┊interface ChatNavbarProps {\n ┊38┊57┊  history: History;\n-┊39┊  ┊  chat?: {\n+┊  ┊58┊  chat: {\n ┊40┊59┊    picture?: string | null;\n ┊41┊60┊    name?: string | null;\n+┊  ┊61┊    id: string;\n ┊42┊62┊  };\n ┊43┊63┊};\n ┊44┊64┊\n ┊45┊65┊const ChatNavbar: React.FC<ChatNavbarProps> = ({ chat, history }) => {\n+┊  ┊66┊  const removeChat = useRemoveChatMutation({\n+┊  ┊67┊    variables: {\n+┊  ┊68┊      chatId: chat.id\n+┊  ┊69┊    }\n+┊  ┊70┊  });\n+┊  ┊71┊\n+┊  ┊72┊  const handleRemoveChat = useCallback(() => {\n+┊  ┊73┊    removeChat().then(() => {\n+┊  ┊74┊      history.replace('/chats')\n+┊  ┊75┊    });\n+┊  ┊76┊  }, [removeChat, history]);\n+┊  ┊77┊\n ┊46┊78┊  const navBack = useCallback(() => {\n ┊47┊79┊    history.replace('/chats');\n ┊48┊80┊  }, [history]);\n```\n```diff\n@@ -58,6 +90,11 @@\n ┊ 58┊ 90┊          <Name data-testid=\"chat-name\">{chat.name}</Name>\n ┊ 59┊ 91┊        </React.Fragment>\n ┊ 60┊ 92┊      )}\n+┊   ┊ 93┊      <Rest>\n+┊   ┊ 94┊        <DeleteButton data-testid=\"delete-button\" onClick={handleRemoveChat}>\n+┊   ┊ 95┊          <DeleteIcon />\n+┊   ┊ 96┊        </DeleteButton>\n+┊   ┊ 97┊      </Rest>\n ┊ 61┊ 98┊    </Container>\n ┊ 62┊ 99┊  );\n ┊ 63┊100┊};\n```\n\n[}]: #\n\nNormally this is a dangerous behavior because we wipe out the entire history without any warnings, which is not recommended. For tutoring purposes only we will keep it the way it is, because it makes things simple and easier to understand.\n\nTo be able to update the chats list cache, we will implement a `chatRemoved` subscription. The subscription will be broadcasted only to those who’re participants of the published chat:\n\n[{]: <helper> (diffStep 9.5 module=\"server\")\n\n#### [Server Step 9.5: Add Subscription.chatRemoved](https://github.com/Urigo/WhatsApp-Clone-Server/commit/7f6b7a4)\n\n##### Changed schema&#x2F;resolvers.ts\n```diff\n@@ -151,7 +151,7 @@\n ┊151┊151┊      return chat\n ┊152┊152┊    },\n ┊153┊153┊\n-┊154┊   ┊    removeChat(root, { chatId }, { currentUser }) {\n+┊   ┊154┊    removeChat(root, { chatId }, { currentUser, pubsub }) {\n ┊155┊155┊      if (!currentUser) return null\n ┊156┊156┊\n ┊157┊157┊      const chatIndex = chats.findIndex(c => c.id === chatId)\n```\n```diff\n@@ -172,6 +172,11 @@\n ┊172┊172┊\n ┊173┊173┊      chats.splice(chatIndex, 1)\n ┊174┊174┊\n+┊   ┊175┊      pubsub.publish('chatRemoved', {\n+┊   ┊176┊        chatRemoved: chat.id,\n+┊   ┊177┊        targetChat: chat,\n+┊   ┊178┊      })\n+┊   ┊179┊\n ┊175┊180┊      return chatId\n ┊176┊181┊    }\n ┊177┊182┊  },\n```\n```diff\n@@ -200,6 +205,17 @@\n ┊200┊205┊          return chatAdded.participants.some(p => p === currentUser.id)\n ┊201┊206┊        },\n ┊202┊207┊      )\n+┊   ┊208┊    },\n+┊   ┊209┊\n+┊   ┊210┊    chatRemoved: {\n+┊   ┊211┊      subscribe: withFilter(\n+┊   ┊212┊        (root, args, { pubsub }) => pubsub.asyncIterator('chatRemoved'),\n+┊   ┊213┊        ({ targetChat }: { targetChat: Chat }, args, { currentUser }) => {\n+┊   ┊214┊          if (!currentUser) return false\n+┊   ┊215┊\n+┊   ┊216┊          return targetChat.participants.some(p => p === currentUser.id)\n+┊   ┊217┊        },\n+┊   ┊218┊      )\n ┊203┊219┊    }\n ┊204┊220┊  }\n ┊205┊221┊}\n```\n\n##### Changed schema&#x2F;typeDefs.graphql\n```diff\n@@ -40,4 +40,5 @@\n ┊40┊40┊type Subscription {\n ┊41┊41┊  messageAdded: Message!\n ┊42┊42┊  chatAdded: Chat!\n+┊  ┊43┊  chatRemoved: ID!\n ┊43┊44┊}\n```\n\n[}]: #\n\nIn the client, we will define the right subscription document:\n\n[{]: <helper> (diffStep 12.5 files=\"graphql/subscriptions\" module=\"client\")\n\n#### Client Step 12.5: Update cache on chat removal\n\n##### Added src&#x2F;graphql&#x2F;subscriptions&#x2F;chatRemoved.subscription.ts\n```diff\n@@ -0,0 +1,7 @@\n+┊ ┊1┊import gql from 'graphql-tag';\n+┊ ┊2┊\n+┊ ┊3┊export default gql`\n+┊ ┊4┊  subscription ChatRemoved {\n+┊ ┊5┊    chatRemoved\n+┊ ┊6┊  }\n+┊ ┊7┊`;\n```\n\n##### Changed src&#x2F;graphql&#x2F;subscriptions&#x2F;index.ts\n```diff\n@@ -1,2 +1,3 @@\n ┊1┊1┊export { default as messageAdded } from './messageAdded.subscription';\n ┊2┊2┊export { default as chatAdded } from './chatAdded.subscription';\n+┊ ┊3┊export { default as chatRemoved } from './chatRemoved.subscription';\n```\n\n[}]: #\n\nAnd we will update the `cache.service` to listen to the new subscription and update the `chats` query accordingly. When we deal with the fragment, we remove the `FullChat` fragment because it consists of the `Chat` fragment. If it was the other way around, we would still have some data leftovers from the `FullChat` on the fragment, because of how Apollo-Cache manages the store:\n\n[{]: <helper> (diffStep 12.5 files=\"cache.service\" module=\"client\")\n\n#### Client Step 12.5: Update cache on chat removal\n\n##### Changed src&#x2F;services&#x2F;cache.service.ts\n```diff\n@@ -8,6 +8,7 @@\n ┊ 8┊ 8┊  ChatFragment,\n ┊ 9┊ 9┊  useMessageAddedSubscription,\n ┊10┊10┊  useChatAddedSubscription,\n+┊  ┊11┊  useChatRemovedSubscription,\n ┊11┊12┊} from '../graphql/types';\n ┊12┊13┊\n ┊13┊14┊type Client = ApolloClient<any> | DataProxy;\n```\n```diff\n@@ -28,6 +29,14 @@\n ┊28┊29┊      }\n ┊29┊30┊    }\n ┊30┊31┊  });\n+┊  ┊32┊\n+┊  ┊33┊  useChatRemovedSubscription({\n+┊  ┊34┊    onSubscriptionData: ({ client, subscriptionData: { data } }) => {\n+┊  ┊35┊      if (data) {\n+┊  ┊36┊        eraseChat(client, data.chatRemoved);\n+┊  ┊37┊      }\n+┊  ┊38┊    }\n+┊  ┊39┊  });\n ┊31┊40┊};\n ┊32┊41┊\n ┊33┊42┊export const writeMessage = (client: Client, message: MessageFragment) => {\n```\n```diff\n@@ -131,3 +140,49 @@\n ┊131┊140┊    data: { chats },\n ┊132┊141┊  });\n ┊133┊142┊}\n+┊   ┊143┊\n+┊   ┊144┊export const eraseChat = (client: Client, chatId: string) => {\n+┊   ┊145┊  const chatType = {\n+┊   ┊146┊    __typename: 'Chat',\n+┊   ┊147┊    id: chatId\n+┊   ┊148┊  };\n+┊   ┊149┊\n+┊   ┊150┊  const chatIdFromObject = defaultDataIdFromObject(chatType);\n+┊   ┊151┊  if (chatIdFromObject === null) {\n+┊   ┊152┊    return;\n+┊   ┊153┊  }\n+┊   ┊154┊\n+┊   ┊155┊  client.writeFragment({\n+┊   ┊156┊    id: chatIdFromObject,\n+┊   ┊157┊    fragment: fragments.fullChat,\n+┊   ┊158┊    fragmentName: 'FullChat',\n+┊   ┊159┊    data: null,\n+┊   ┊160┊  })\n+┊   ┊161┊\n+┊   ┊162┊  let data;\n+┊   ┊163┊  try {\n+┊   ┊164┊    data = client.readQuery({\n+┊   ┊165┊      query: queries.chats,\n+┊   ┊166┊    });\n+┊   ┊167┊  } catch (e) {\n+┊   ┊168┊    return;\n+┊   ┊169┊  }\n+┊   ┊170┊\n+┊   ┊171┊  if (!data || !data.chats) return;\n+┊   ┊172┊\n+┊   ┊173┊  const chats = data.chats;\n+┊   ┊174┊\n+┊   ┊175┊  if (!chats) return;\n+┊   ┊176┊\n+┊   ┊177┊  const chatIndex = chats.findIndex((c: any) => c.id === chatId);\n+┊   ┊178┊\n+┊   ┊179┊  if (chatIndex === -1) return;\n+┊   ┊180┊\n+┊   ┊181┊  // The chat will appear at the top of the ChatsList component\n+┊   ┊182┊  chats.splice(chatIndex, 1);\n+┊   ┊183┊\n+┊   ┊184┊  client.writeQuery({\n+┊   ┊185┊    query: queries.chats,\n+┊   ┊186┊    data: { chats: chats },\n+┊   ┊187┊  });\n+┊   ┊188┊}\n```\n\n[}]: #\n\nWe will also update the `ChatRoomScreen` to redirect us to the `/chats` route if the chat was not found. The render method of the component will be re-triggered automatically by `react-apollo-hooks` if the cached result of `useGetChat()` hook has changed, which means that even if you didn’t actively remove the chat, you will still be redirected as a result:\n\n[{]: <helper> (diffStep 12.5 files=\"ChatRoom\" module=\"client\")\n\n#### Client Step 12.5: Update cache on chat removal\n\n##### Changed src&#x2F;components&#x2F;ChatRoomScreen&#x2F;ChatNavbar.tsx\n```diff\n@@ -8,6 +8,7 @@\n ┊ 8┊ 8┊import styled from 'styled-components';\n ┊ 9┊ 9┊import { History } from 'history';\n ┊10┊10┊import { useRemoveChatMutation } from '../../graphql/types';\n+┊  ┊11┊import { eraseChat } from '../../services/cache.service';\n ┊11┊12┊\n ┊12┊13┊const Container = styled(Toolbar) `\n ┊13┊14┊  padding: 0;\n```\n```diff\n@@ -66,6 +67,9 @@\n ┊66┊67┊  const removeChat = useRemoveChatMutation({\n ┊67┊68┊    variables: {\n ┊68┊69┊      chatId: chat.id\n+┊  ┊70┊    },\n+┊  ┊71┊    update: (client, { data: { removeChat } }) => {\n+┊  ┊72┊      eraseChat(client, removeChat);\n ┊69┊73┊    }\n ┊70┊74┊  });\n ┊71┊75┊\n```\n\n##### Changed src&#x2F;components&#x2F;ChatRoomScreen&#x2F;index.tsx\n```diff\n@@ -1,6 +1,7 @@\n ┊1┊1┊import gql from 'graphql-tag';\n ┊2┊2┊import React from 'react';\n ┊3┊3┊import { useCallback } from 'react';\n+┊ ┊4┊import { Redirect } from 'react-router-dom';\n ┊4┊5┊import styled from 'styled-components';\n ┊5┊6┊import ChatNavbar from './ChatNavbar';\n ┊6┊7┊import MessageInput from './MessageInput';\n```\n```diff\n@@ -86,6 +87,13 @@\n ┊86┊87┊  if (loadingChat) return null;\n ┊87┊88┊  if (chat === null) return null;\n ┊88┊89┊\n+┊  ┊90┊  // Chat was probably removed from cache by the subscription handler\n+┊  ┊91┊  if (!chat) {\n+┊  ┊92┊    return (\n+┊  ┊93┊      <Redirect to=\"/chats\" />\n+┊  ┊94┊    );\n+┊  ┊95┊  }\n+┊  ┊96┊\n ┊89┊97┊  return (\n ┊90┊98┊    <Container>\n ┊91┊99┊      <ChatNavbar chat={chat} history={history} />\n```\n\n[}]: #\n\nTODO: maybe mention that ApolloCache doesn’t have Garbage Collector so even though the object is removed, everything else related to it says in cache."
          },
          {
            "manualTitle": "Step 13: Authentication",
            "stepRevision": "71ccc9d595ba621cfbea06c102ddf8e951aecc34",
            "manualView": "In the previous step we’ve set the ground for the authentication system in our app. We have a users collection which can be used to distinguish which data the client is authorized to view, and we have a context handler which can retrieve the current user logged in based on the received value of the `cookie` header. It’s definitely a good starting point, but it misses a lot of things.\n\nIn this chapter we will implement a cookie-based authentication system. There are many ways to implement an authentication system in an app, but cookie-based authentication is one of the most popular ones, hence we will go with that method. Essentially the authentication flow in our app should look very simple: a user will be able to sign-in with a dedicated screen, and if he doesn’t own an account he can use the sign-up screen to create a new one. The more complicated part in this flow is the back-end, which is the core of this chapter. So before we get into the implementation, we need to understand the authentication process:\n\n- A user logs in with a username and a password.\nThe server compares the received username and password to the ones stored in the database.\n- If the comparison was successful, the server will generate a token and will set it as a cookie.\n- Each time a request is sent, the server will retrieve the username from the stored token on the cookie header and will send data back accordingly.\n\n![auth-flow](https://user-images.githubusercontent.com/7648874/55929679-55e94200-5c50-11e9-9fe7-54ad6194a572.png)\n\nThe stored token will save us the hassle of re-specifying the username and password over and over again each and every request. It’s important to note that everything in the authentication process is encrypted, **sensitive information will never be stored or sent in its raw form**, otherwise data might be stolen in case of a DB breach or a request hijacking. This is what it means for our app:\n\n- Passwords will always be stored in an encrypted form in the DB using an algorithm called [Bcrypt](https://en.wikipedia.org/wiki/Bcrypt). Bcrypt has the ability to compare the password in its raw form to the encrypted one, which can help us authorize the user.\n\n- Tokens are self contained. That means that once we decode the encrypted string we can get a hold of the username string. This form of encrypted tokens is called [Json Web Token (JWT)](https://jwt.io/).\n\n> We're not going to elaborate about the algorithm behind each encryption method because we want to focus more on practicality, although it's very much recommended to understand how each method works before proceeding.\n\nThe implementation will follow the principles above. Authentication is a hot topic in the GraphQL world and there are several ways of doing so. We will start with the back-end and set the infrastructure for authentication, and then we will move on to the front-end.\n\nWe’re gonna expose 2 new mutations from GraphQL Schema: `signIn` and `signUp`. `/sign-out` is unnecessary because it can be done locally by deleting the right cookie. Our back-end is gonna grow bigger so first we will separate the Express app from the Apollo Server instance, and extract the env vars to a dedicated module:\n\n[{]: <helper> (diffStep 10.1 module=\"server\")\n\n#### [Server Step 10.1: Separate app into a different module](https://github.com/Urigo/WhatsApp-Clone-Server/commit/47bf939)\n\n##### Added app.ts\n```diff\n@@ -0,0 +1,15 @@\n+┊  ┊ 1┊import bodyParser from 'body-parser'\n+┊  ┊ 2┊import cors from 'cors'\n+┊  ┊ 3┊import cookieParser from 'cookie-parser'\n+┊  ┊ 4┊import express from 'express'\n+┊  ┊ 5┊import { origin } from './env'\n+┊  ┊ 6┊\n+┊  ┊ 7┊export const app = express()\n+┊  ┊ 8┊\n+┊  ┊ 9┊app.use(cors({ credentials: true, origin }))\n+┊  ┊10┊app.use(bodyParser.json())\n+┊  ┊11┊app.use(cookieParser())\n+┊  ┊12┊\n+┊  ┊13┊app.get('/_ping', (req, res) => {\n+┊  ┊14┊  res.send('pong')\n+┊  ┊15┊})\n```\n\n##### Added env.ts\n```diff\n@@ -0,0 +1,2 @@\n+┊ ┊1┊export const origin = process.env.ORIGIN || 'http://localhost:3000'\n+┊ ┊2┊export const port = process.env.PORT || 4000\n```\n\n##### Changed index.ts\n```diff\n@@ -1,23 +1,10 @@\n ┊ 1┊ 1┊import { ApolloServer, gql, PubSub } from 'apollo-server-express'\n-┊ 2┊  ┊import bodyParser from 'body-parser'\n-┊ 3┊  ┊import cors from 'cors'\n-┊ 4┊  ┊import cookieParser from 'cookie-parser'\n-┊ 5┊  ┊import express from 'express'\n ┊ 6┊ 2┊import http from 'http'\n+┊  ┊ 3┊import { app } from './app'\n ┊ 7┊ 4┊import { users } from './db'\n+┊  ┊ 5┊import { origin, port } from './env'\n ┊ 8┊ 6┊import schema from './schema'\n ┊ 9┊ 7┊\n-┊10┊  ┊const app = express()\n-┊11┊  ┊\n-┊12┊  ┊const origin = process.env.ORIGIN || 'http://localhost:3000'\n-┊13┊  ┊app.use(cors({ credentials: true, origin }))\n-┊14┊  ┊app.use(bodyParser.json())\n-┊15┊  ┊app.use(cookieParser())\n-┊16┊  ┊\n-┊17┊  ┊app.get('/_ping', (req, res) => {\n-┊18┊  ┊  res.send('pong')\n-┊19┊  ┊})\n-┊20┊  ┊\n ┊21┊ 8┊const pubsub = new PubSub()\n ┊22┊ 9┊const server = new ApolloServer({\n ┊23┊10┊  schema,\n```\n```diff\n@@ -36,8 +23,6 @@\n ┊36┊23┊const httpServer = http.createServer(app)\n ┊37┊24┊server.installSubscriptionHandlers(httpServer)\n ┊38┊25┊\n-┊39┊  ┊const port = process.env.PORT || 4000\n-┊40┊  ┊\n ┊41┊26┊httpServer.listen(port, () => {\n ┊42┊27┊  console.log(`Server is listening on port ${port}`)\n ┊43┊28┊})\n```\n\n[}]: #\n\nWe will first start with the `signIn` mutation, so we can test it against pre-defined user credentials, and then we will proceed to implementing the `signUp` mutation. It would be a lot easier to progress this way. For that we will install a couple of packages:\n\n- `bcrypt` - which is responsible for running a one-way encryption against received passwords before they’re stored in the DB.\n- `jsonwebtoken` - responsible for encrypting the logged-in username before it’s set as a cooky and decrypting it once it’s sent back with a request.\n\n    $ yarn add bcrypt jsonwebtoken\n\n\n    $ yarn add --dev @types/bcrypt @types/jsonwebtoken\n\nAnd we will implement the `signIn` mutation:\n\n[{]: <helper> (diffStep 10.2 files=\"schema\" module=\"server\")\n\n#### [Server Step 10.2: Add signIn mutation](https://github.com/Urigo/WhatsApp-Clone-Server/commit/c6ac755)\n\n##### Changed schema&#x2F;resolvers.ts\n```diff\n@@ -2,6 +2,9 @@\n ┊ 2┊ 2┊import { GraphQLDateTime } from 'graphql-iso-date'\n ┊ 3┊ 3┊import { User, Message, Chat, chats, messages, users } from '../db'\n ┊ 4┊ 4┊import { Resolvers } from '../types/graphql'\n+┊  ┊ 5┊import { secret, expiration } from '../env'\n+┊  ┊ 6┊import bcrypt from 'bcrypt'\n+┊  ┊ 7┊import jwt from 'jsonwebtoken'\n ┊ 5┊ 8┊\n ┊ 6┊ 9┊const resolvers: Resolvers = {\n ┊ 7┊10┊  Date: GraphQLDateTime,\n```\n```diff\n@@ -89,6 +92,27 @@\n ┊ 89┊ 92┊  },\n ┊ 90┊ 93┊\n ┊ 91┊ 94┊  Mutation: {\n+┊   ┊ 95┊    signIn(root, { username, password}, { res }) {\n+┊   ┊ 96┊\n+┊   ┊ 97┊      const user = users.find(u => u.username === username)\n+┊   ┊ 98┊\n+┊   ┊ 99┊      if (!user) {\n+┊   ┊100┊        throw new Error('user not found')\n+┊   ┊101┊      }\n+┊   ┊102┊\n+┊   ┊103┊      const passwordsMatch = bcrypt.compareSync(password, user.password)\n+┊   ┊104┊\n+┊   ┊105┊      if (!passwordsMatch) {\n+┊   ┊106┊        throw new Error('password is incorrect')\n+┊   ┊107┊      }\n+┊   ┊108┊\n+┊   ┊109┊      const authToken = jwt.sign(username, secret)\n+┊   ┊110┊\n+┊   ┊111┊      res.cookie('authToken', authToken, { maxAge: expiration })\n+┊   ┊112┊\n+┊   ┊113┊      return user;\n+┊   ┊114┊    },\n+┊   ┊115┊\n ┊ 92┊116┊    addMessage(root, { chatId, content }, { currentUser, pubsub }) {\n ┊ 93┊117┊      if (!currentUser) return null\n ┊ 94┊118┊\n```\n\n##### Changed schema&#x2F;typeDefs.graphql\n```diff\n@@ -32,6 +32,7 @@\n ┊32┊32┊}\n ┊33┊33┊\n ┊34┊34┊type Mutation {\n+┊  ┊35┊  signIn(username: String!, password: String!): User\n ┊35┊36┊  addMessage(chatId: ID!, content: String!): Message\n ┊36┊37┊  addChat(recipientId: ID!): Chat\n ┊37┊38┊  removeChat(chatId: ID!): ID\n```\n\n[}]: #\n\nAs you can see we use a special secret before we encrypt the username with JWT. The same secret will be used later on to decrypt the token back into username when getting requests. If someone malicious will get a hold of that password, he can fabricate an authentication token for every user that he wants, **thus it’s important to choose a strong secret**.\n\nWhen building the context for our GraphQL resolvers, we will decode the received cookie with JWT using the same secret to determine the username who made the request. Once we have that username, we can simply retrieve the original user from the DB and define it on the context:\n\n[{]: <helper> (diffStep 10.3 module=\"server\")\n\n#### [Server Step 10.3: Get current user from auth token](https://github.com/Urigo/WhatsApp-Clone-Server/commit/51cae3f)\n\n##### Changed index.ts\n```diff\n@@ -1,18 +1,27 @@\n ┊ 1┊ 1┊import { ApolloServer, gql, PubSub } from 'apollo-server-express'\n ┊ 2┊ 2┊import http from 'http'\n+┊  ┊ 3┊import jwt from 'jsonwebtoken'\n ┊ 3┊ 4┊import { app } from './app'\n ┊ 4┊ 5┊import { users } from './db'\n-┊ 5┊  ┊import { origin, port } from './env'\n+┊  ┊ 6┊import { origin, port, secret } from './env'\n ┊ 6┊ 7┊import schema from './schema'\n ┊ 7┊ 8┊\n ┊ 8┊ 9┊const pubsub = new PubSub()\n ┊ 9┊10┊const server = new ApolloServer({\n ┊10┊11┊  schema,\n-┊11┊  ┊  context: ({ req, res }) => ({\n-┊12┊  ┊    currentUser: users.find(u => u.id === req.cookies.currentUserId),\n-┊13┊  ┊    pubsub,\n-┊14┊  ┊    res,\n-┊15┊  ┊  }),\n+┊  ┊12┊  context: ({ req, res }) => {\n+┊  ┊13┊    let currentUser;\n+┊  ┊14┊    if (req.cookies.authToken) {\n+┊  ┊15┊      const username = jwt.verify(req.cookies.authToken, secret) as string\n+┊  ┊16┊      currentUser = username && users.find(u => u.username === username)\n+┊  ┊17┊    }\n+┊  ┊18┊\n+┊  ┊19┊    return {\n+┊  ┊20┊      currentUser,\n+┊  ┊21┊      pubsub,\n+┊  ┊22┊      res,\n+┊  ┊23┊    }\n+┊  ┊24┊  },\n ┊16┊25┊})\n ┊17┊26┊\n ┊18┊27┊server.applyMiddleware({\n```\n\n[}]: #\n\nYou might have noticed that the User schema has been updated, because we try to address the `user.username` property. The authentication in our app will be done with a username and a password; accordingly, we will update our User type definitions and the user documents in the users collection mock. The credentials that we’re going to store can actually be used to sign-in to our app:\n\n[{]: <helper> (diffStep 10.4 module=\"server\")\n\n#### [Server Step 10.4: Update user schema to contain credentials](https://github.com/Urigo/WhatsApp-Clone-Server/commit/754bdf4)\n\n##### Changed db.ts\n```diff\n@@ -1,6 +1,8 @@\n ┊1┊1┊export type User = {\n ┊2┊2┊  id: string\n ┊3┊3┊  name: string\n+┊ ┊4┊  username: string\n+┊ ┊5┊  password: string\n ┊4┊6┊  picture: string\n ┊5┊7┊}\n ┊6┊8┊\n```\n```diff\n@@ -27,26 +29,36 @@\n ┊27┊29┊    {\n ┊28┊30┊      id: '1',\n ┊29┊31┊      name: 'Ray Edwards',\n+┊  ┊32┊      username: 'ray',\n+┊  ┊33┊      password: '$2a$08$NO9tkFLCoSqX1c5wk3s7z.JfxaVMKA.m7zUDdDwEquo4rvzimQeJm', // 111\n ┊30┊34┊      picture: 'https://randomuser.me/api/portraits/thumb/lego/1.jpg',\n ┊31┊35┊    },\n ┊32┊36┊    {\n ┊33┊37┊      id: '2',\n ┊34┊38┊      name: 'Ethan Gonzalez',\n+┊  ┊39┊      username: 'ethan',\n+┊  ┊40┊      password: '$2a$08$xE4FuCi/ifxjL2S8CzKAmuKLwv18ktksSN.F3XYEnpmcKtpbpeZgO', // 222\n ┊35┊41┊      picture: 'https://randomuser.me/api/portraits/thumb/men/1.jpg',\n ┊36┊42┊    },\n ┊37┊43┊    {\n ┊38┊44┊      id: '3',\n ┊39┊45┊      name: 'Bryan Wallace',\n+┊  ┊46┊      username: 'bryan',\n+┊  ┊47┊      password: '$2a$08$UHgH7J8G6z1mGQn2qx2kdeWv0jvgHItyAsL9hpEUI3KJmhVW5Q1d.', // 333\n ┊40┊48┊      picture: 'https://randomuser.me/api/portraits/thumb/men/2.jpg',\n ┊41┊49┊    },\n ┊42┊50┊    {\n ┊43┊51┊      id: '4',\n ┊44┊52┊      name: 'Avery Stewart',\n+┊  ┊53┊      username: 'avery',\n+┊  ┊54┊      password: '$2a$08$wR1k5Q3T9FC7fUgB7Gdb9Os/GV7dGBBf4PLlWT7HERMFhmFDt47xi', // 444\n ┊45┊55┊      picture: 'https://randomuser.me/api/portraits/thumb/women/1.jpg',\n ┊46┊56┊    },\n ┊47┊57┊    {\n ┊48┊58┊      id: '5',\n ┊49┊59┊      name: 'Katie Peterson',\n+┊  ┊60┊      username: 'katie',\n+┊  ┊61┊      password: '$2a$08$6.mbXqsDX82ZZ7q5d8Osb..JrGSsNp4R3IKj7mxgF6YGT0OmMw242', // 555\n ┊50┊62┊      picture: 'https://randomuser.me/api/portraits/thumb/women/2.jpg',\n ┊51┊63┊    },\n ┊52┊64┊  ])\n```\n```diff\n@@ -106,4 +118,4 @@\n ┊106┊118┊  ])\n ┊107┊119┊}\n ┊108┊120┊\n-┊109┊   ┊resetDb()\n+┊   ┊121┊resetDb()🚫↵\n```\n\n[}]: #\n\nTo test it out, we will run our front-end application and open the dev-console. Using the Apollo Client we will send a request to the `signIn` mutation. We can use the credentials of one of the users stored in the DB. As for now all our restricted routes are observing the `currentUserId` cookie. This is wrong and no longer relevant. Let’s change the `withAuth()` method to observe the `authToken` cookie so we can test our new mutation successfully:\n\n[{]: <helper> (diffStep 13.1 module=\"client\")\n\n#### Client Step 13.1: Use authToken cookie\n\n##### Changed src&#x2F;services&#x2F;auth.service.tsx\n```diff\n@@ -23,8 +23,8 @@\n ┊23┊23┊  };\n ┊24┊24┊};\n ┊25┊25┊\n-┊26┊  ┊export const signIn = (currentUserId: string) => {\n-┊27┊  ┊  document.cookie = `currentUserId=${currentUserId}`;\n+┊  ┊26┊export const signIn = (authToken: string) => {\n+┊  ┊27┊  document.cookie = `authToken=${authToken}`;\n ┊28┊28┊\n ┊29┊29┊  // This will become async in the near future\n ┊30┊30┊  return Promise.resolve();\n```\n```diff\n@@ -33,12 +33,12 @@\n ┊33┊33┊export const signOut = () => {\n ┊34┊34┊  // \"expires\" represents the lifespan of a cookie. Beyond that date the cookie will\n ┊35┊35┊  // be deleted by the browser. \"expires\" cannot be viewed from \"document.cookie\"\n-┊36┊  ┊  document.cookie = `currentUserId=;expires=${new Date(0)}`;\n+┊  ┊36┊  document.cookie = `authToken=;expires=${new Date(0)}`;\n ┊37┊37┊\n ┊38┊38┊  // Clear cache\n ┊39┊39┊  return client.clearStore();\n ┊40┊40┊};\n ┊41┊41┊\n ┊42┊42┊export const isSignedIn = () => {\n-┊43┊  ┊  return /currentUserId=.+(;|$)/.test(document.cookie);\n+┊  ┊43┊  return /authToken=.+(;|$)/.test(document.cookie);\n ┊44┊44┊};🚫↵\n```\n\n[}]: #\n\nNow we can perform the signIn. It would be a good idea to signIn with the first user - `ray`, since all the DB mock is built around him:\n\n```js\nmutation signIn(username: 'ray', password: '111') {\n  id\n}\n```\n\nNow if we would look at the value of `document.cookie` we should see a key named `authToken` with a JWT token and the `ChatsListScreen` should show the chats which are relevant to `ray`. To complete the sign-in flow we would need to update the `AuthScreen` and the `auth.service` to use username and password and the actual `sign-in` mutation we’ve just implemented.\n\nTo check if we’re authorized to visit a route, not only we would need to check if we have the `authToken` cookie defined, but we would also need to validate it against the server to see that it actually references a real user. For that we will implement `Query.me` which will send us back the current user logged in directly from the context:\n\n[{]: <helper> (diffStep 10.5 module=\"server\")\n\n#### [Server Step 10.5: Add Query.me](https://github.com/Urigo/WhatsApp-Clone-Server/commit/234afe4)\n\n##### Changed schema&#x2F;resolvers.ts\n```diff\n@@ -68,6 +68,10 @@\n ┊68┊68┊  },\n ┊69┊69┊\n ┊70┊70┊  Query: {\n+┊  ┊71┊    me(root, args, { currentUser }) {\n+┊  ┊72┊      return currentUser || null\n+┊  ┊73┊    },\n+┊  ┊74┊\n ┊71┊75┊    chats(root, args, { currentUser }) {\n ┊72┊76┊      if (!currentUser) return []\n ┊73┊77┊\n```\n\n##### Changed schema&#x2F;typeDefs.graphql\n```diff\n@@ -26,6 +26,7 @@\n ┊26┊26┊}\n ┊27┊27┊\n ┊28┊28┊type Query {\n+┊  ┊29┊  me: User\n ┊29┊30┊  chats: [Chat!]!\n ┊30┊31┊  chat(chatId: ID!): Chat\n ┊31┊32┊  users: [User!]!\n```\n\n##### Added tests&#x2F;queries&#x2F;getMe.test.ts\n```diff\n@@ -0,0 +1,33 @@\n+┊  ┊ 1┊import { createTestClient } from 'apollo-server-testing'\n+┊  ┊ 2┊import { ApolloServer, gql } from 'apollo-server-express'\n+┊  ┊ 3┊import schema from '../../schema'\n+┊  ┊ 4┊import { users } from '../../db'\n+┊  ┊ 5┊\n+┊  ┊ 6┊describe('Query.me', () => {\n+┊  ┊ 7┊  it('should fetch current user', async () => {\n+┊  ┊ 8┊    const server = new ApolloServer({\n+┊  ┊ 9┊      schema,\n+┊  ┊10┊      context: () => ({\n+┊  ┊11┊        currentUser: users[0],\n+┊  ┊12┊      }),\n+┊  ┊13┊    })\n+┊  ┊14┊\n+┊  ┊15┊    const { query } = createTestClient(server)\n+┊  ┊16┊\n+┊  ┊17┊    const res = await query({\n+┊  ┊18┊      query: gql `\n+┊  ┊19┊        query GetMe {\n+┊  ┊20┊          me {\n+┊  ┊21┊            id\n+┊  ┊22┊            name\n+┊  ┊23┊            picture\n+┊  ┊24┊          }\n+┊  ┊25┊        }\n+┊  ┊26┊      `,\n+┊  ┊27┊    })\n+┊  ┊28┊\n+┊  ┊29┊    expect(res.data).toBeDefined()\n+┊  ┊30┊    expect(res.errors).toBeUndefined()\n+┊  ┊31┊    expect(res.data).toMatchSnapshot()\n+┊  ┊32┊  })\n+┊  ┊33┊})\n```\n\n[}]: #\n\nNow back to the `auth.service`, we will replace the `signIn()` method implementation with one that actually calls the `signIn` mutation in our API:\n\n[{]: <helper> (diffStep 13.2 module=\"client\")\n\n#### Client Step 13.2: Update auth service to call signIn mutation\n\n##### Changed src&#x2F;services&#x2F;auth.service.tsx\n```diff\n@@ -2,6 +2,7 @@\n ┊2┊2┊import { Redirect } from 'react-router-dom';\n ┊3┊3┊import client from '../client';\n ┊4┊4┊import { useCacheService } from './cache.service';\n+┊ ┊5┊import gql from 'graphql-tag';\n ┊5┊6┊\n ┊6┊7┊export const withAuth = <P extends object>(Component: React.ComponentType<P>) => {\n ┊7┊8┊  return (props: any) => {\n```\n```diff\n@@ -18,24 +19,30 @@\n ┊18┊19┊    useCacheService();\n ┊19┊20┊\n ┊20┊21┊    return (\n-┊21┊  ┊      <Component {...props as P} />\n+┊  ┊22┊        <Component {...props as P} />\n ┊22┊23┊    );\n ┊23┊24┊  };\n ┊24┊25┊};\n ┊25┊26┊\n-┊26┊  ┊export const signIn = (authToken: string) => {\n-┊27┊  ┊  document.cookie = `authToken=${authToken}`;\n-┊28┊  ┊\n-┊29┊  ┊  // This will become async in the near future\n-┊30┊  ┊  return Promise.resolve();\n+┊  ┊27┊export const signIn = ({ username, password }: { username: string, password: string}) => {\n+┊  ┊28┊  return client.mutate({\n+┊  ┊29┊    mutation: gql`\n+┊  ┊30┊      mutation signIn($username: String!, $password: String!) {\n+┊  ┊31┊        signIn(username: $username, password: $password) {\n+┊  ┊32┊          id\n+┊  ┊33┊        }\n+┊  ┊34┊      }\n+┊  ┊35┊    `,\n+┊  ┊36┊    variables: {\n+┊  ┊37┊      username,\n+┊  ┊38┊      password\n+┊  ┊39┊    }\n+┊  ┊40┊  });\n ┊31┊41┊};\n ┊32┊42┊\n ┊33┊43┊export const signOut = () => {\n-┊34┊  ┊  // \"expires\" represents the lifespan of a cookie. Beyond that date the cookie will\n-┊35┊  ┊  // be deleted by the browser. \"expires\" cannot be viewed from \"document.cookie\"\n ┊36┊44┊  document.cookie = `authToken=;expires=${new Date(0)}`;\n ┊37┊45┊\n-┊38┊  ┊  // Clear cache\n ┊39┊46┊  return client.clearStore();\n ┊40┊47┊};\n```\n\n[}]: #\n\nAnd we will use the GraphQL query we’ve just implemented to check if the user actually exists within the DB before we proceed to the restricted route:\n\n[{]: <helper> (diffStep 13.3 module=\"client\")\n\n#### Client Step 13.3: Validate auth token against the back-end on restricted route\n\n##### Added src&#x2F;graphql&#x2F;queries&#x2F;me.query.ts\n```diff\n@@ -0,0 +1,11 @@\n+┊  ┊ 1┊import gql from 'graphql-tag';\n+┊  ┊ 2┊import * as fragments from '../fragments';\n+┊  ┊ 3┊\n+┊  ┊ 4┊export default gql`\n+┊  ┊ 5┊  query Me {\n+┊  ┊ 6┊    me {\n+┊  ┊ 7┊      ...User\n+┊  ┊ 8┊    }\n+┊  ┊ 9┊  }\n+┊  ┊10┊  ${fragments.user}\n+┊  ┊11┊`;\n```\n\n##### Changed src&#x2F;services&#x2F;auth.service.tsx\n```diff\n@@ -1,9 +1,17 @@\n ┊ 1┊ 1┊import React from 'react';\n+┊  ┊ 2┊import { useContext } from 'react';\n ┊ 2┊ 3┊import { Redirect } from 'react-router-dom';\n ┊ 3┊ 4┊import client from '../client';\n+┊  ┊ 5┊import { useMeQuery, User } from '../graphql/types';\n ┊ 4┊ 6┊import { useCacheService } from './cache.service';\n ┊ 5┊ 7┊import gql from 'graphql-tag';\n ┊ 6┊ 8┊\n+┊  ┊ 9┊const MyContext = React.createContext<User|null>(null);\n+┊  ┊10┊\n+┊  ┊11┊export const useMe = () => {\n+┊  ┊12┊  return useContext(MyContext);\n+┊  ┊13┊};\n+┊  ┊14┊\n ┊ 7┊15┊export const withAuth = <P extends object>(Component: React.ComponentType<P>) => {\n ┊ 8┊16┊  return (props: any) => {\n ┊ 9┊17┊    if (!isSignedIn()) {\n```\n```diff\n@@ -16,10 +24,24 @@\n ┊16┊24┊      );\n ┊17┊25┊    }\n ┊18┊26┊\n+┊  ┊27┊    const { data, error, loading } = useMeQuery();\n+┊  ┊28┊\n ┊19┊29┊    useCacheService();\n ┊20┊30┊\n+┊  ┊31┊    if (loading) return null;\n+┊  ┊32┊\n+┊  ┊33┊    if (data === undefined) return null;\n+┊  ┊34┊\n+┊  ┊35┊    if (error || !data.me) {\n+┊  ┊36┊      signOut();\n+┊  ┊37┊\n+┊  ┊38┊      return <Redirect to=\"/sign-in\" />;\n+┊  ┊39┊    }\n+┊  ┊40┊\n ┊21┊41┊    return (\n+┊  ┊42┊      <MyContext.Provider value={data.me}>\n ┊22┊43┊        <Component {...props as P} />\n+┊  ┊44┊      </MyContext.Provider>\n ┊23┊45┊    );\n ┊24┊46┊  };\n ┊25┊47┊};\n```\n```diff\n@@ -48,4 +70,4 @@\n ┊48┊70┊\n ┊49┊71┊export const isSignedIn = () => {\n ┊50┊72┊  return /authToken=.+(;|$)/.test(document.cookie);\n-┊51┊  ┊};🚫↵\n+┊  ┊73┊};\n```\n\n[}]: #\n\nwe will use the new query to try and fetch the user directly from the back-end, and we will only proceed if the user was actually found. In addition, we will replace the `signIn()` method to call `signIn` mutation:\n\n[{]: <helper> (diffStep 13.4 module=\"client\")\n\n#### Client Step 13.4: Add username and password to AuthScreen\n\n##### Changed src&#x2F;components&#x2F;AuthScreen&#x2F;index.tsx\n```diff\n@@ -114,21 +114,34 @@\n ┊114┊114┊` as typeof MaterialButton;\n ┊115┊115┊\n ┊116┊116┊const AuthScreen: React.FC<RouteComponentProps<any>> = ({ history }) => {\n-┊117┊   ┊  const [userId, setUserId] = useState('');\n+┊   ┊117┊  const [username, setUsername] = useState('');\n+┊   ┊118┊  const [password, setPassword] = useState('');\n+┊   ┊119┊  // eslint-disable-next-line\n+┊   ┊120┊  const [error, setError] = useState('');\n+┊   ┊121┊\n+┊   ┊122┊  const onUsernameChange = useCallback(({ target }) => {\n+┊   ┊123┊    setError('');\n+┊   ┊124┊    setUsername(target.value);\n+┊   ┊125┊  }, []);\n ┊118┊126┊\n-┊119┊   ┊  const onUserIdChange = useCallback(({ target }) => {\n-┊120┊   ┊    setUserId(target.value);\n+┊   ┊127┊  const onPasswordChange = useCallback(({ target }) => {\n+┊   ┊128┊    setError('');\n+┊   ┊129┊    setPassword(target.value);\n ┊121┊130┊  }, []);\n ┊122┊131┊\n ┊123┊132┊  const maySignIn = useCallback(() => {\n-┊124┊   ┊    return !!userId\n-┊125┊   ┊  }, [userId]);\n+┊   ┊133┊    return !!(username && password);\n+┊   ┊134┊  }, [username, password]);\n ┊126┊135┊\n ┊127┊136┊  const handleSignIn = useCallback(() => {\n-┊128┊   ┊    signIn(userId).then(() => {\n-┊129┊   ┊      history.replace('/chats')\n-┊130┊   ┊    })\n-┊131┊   ┊  }, [userId, history]);\n+┊   ┊137┊    signIn({ username, password })\n+┊   ┊138┊      .then(() => {\n+┊   ┊139┊        history.push('/chats')\n+┊   ┊140┊      })\n+┊   ┊141┊      .catch(error => {\n+┊   ┊142┊        setError(error.message || error)\n+┊   ┊143┊      });\n+┊   ┊144┊  }, [username, password, history]);\n ┊132┊145┊\n ┊133┊146┊  return (\n ┊134┊147┊    <Container>\n```\n```diff\n@@ -141,12 +154,21 @@\n ┊141┊154┊          <Legend>Sign in</Legend>\n ┊142┊155┊          <Section>\n ┊143┊156┊            <TextField\n-┊144┊   ┊              data-testid=\"user-id-input\"\n-┊145┊   ┊              label=\"User ID\"\n-┊146┊   ┊              value={userId}\n-┊147┊   ┊              onChange={onUserIdChange}\n+┊   ┊157┊              className=\"AuthScreen-text-field\"\n+┊   ┊158┊              label=\"Username\"\n+┊   ┊159┊              value={username}\n+┊   ┊160┊              onChange={onUsernameChange}\n+┊   ┊161┊              margin=\"normal\"\n+┊   ┊162┊              placeholder=\"Enter your username\"\n+┊   ┊163┊            />\n+┊   ┊164┊            <TextField\n+┊   ┊165┊              className=\"AuthScreen-text-field\"\n+┊   ┊166┊              label=\"Password\"\n+┊   ┊167┊              type=\"password\"\n+┊   ┊168┊              value={password}\n+┊   ┊169┊              onChange={onPasswordChange}\n ┊148┊170┊              margin=\"normal\"\n-┊149┊   ┊              placeholder=\"Enter current user ID\"\n+┊   ┊171┊              placeholder=\"Enter your password\"\n ┊150┊172┊            />\n ┊151┊173┊          </Section>\n ┊152┊174┊          <Button\n```\n\n[}]: #\n\nThe behavior of the updated screen should be identical to what we had so far. To complete the flow we’ll need a way to signUp. When we signing-up we will need the following parameters: `name`, `username`, `password` and `passwordConfirm`. In addition we will need to run certain validations against the parameters:\n\n- The name must be at least 3 and at most 50 characters long.\n- The username must be at least 3 and at most 18 characters long.\n- A password must be at least 8 and at most 30 characters long. In addition, it should contain English letters, numbers, and special characters.\n\nFor that we will implement a dedicated validations module:\n\n[{]: <helper> (diffStep 10.6 files=\"validators\" module=\"server\")\n\n#### [Server Step 10.6: Add signUp mutation](https://github.com/Urigo/WhatsApp-Clone-Server/commit/3e749d6)\n\n##### Added validators.ts\n```diff\n@@ -0,0 +1,43 @@\n+┊  ┊ 1┊export const validatePassword = (ctx: string, str: string) => {\n+┊  ┊ 2┊  if (typeof str !== 'string') {\n+┊  ┊ 3┊    throw TypeError(`${ctx} must be a string`)\n+┊  ┊ 4┊  }\n+┊  ┊ 5┊\n+┊  ┊ 6┊  validateLength(ctx, str, 8, 30)\n+┊  ┊ 7┊\n+┊  ┊ 8┊  if (!/[a-zA-Z]+/.test(str)) {\n+┊  ┊ 9┊    throw TypeError(`${ctx} must contain english letters`)\n+┊  ┊10┊  }\n+┊  ┊11┊\n+┊  ┊12┊  if (!/\\d+/.test(str)) {\n+┊  ┊13┊    throw TypeError(`${ctx} must contain numbers`)\n+┊  ┊14┊  }\n+┊  ┊15┊\n+┊  ┊16┊  if (!/[^\\da-zA-Z]+/.test(str)) {\n+┊  ┊17┊    throw TypeError(`${ctx} must contain special charachters`)\n+┊  ┊18┊  }\n+┊  ┊19┊}\n+┊  ┊20┊\n+┊  ┊21┊export const validateLength = (ctx: string, str: string, ...args: number[]) => {\n+┊  ┊22┊  let min, max\n+┊  ┊23┊\n+┊  ┊24┊  if (args.length === 1) {\n+┊  ┊25┊    min = 0\n+┊  ┊26┊    max = args[0]\n+┊  ┊27┊  } else {\n+┊  ┊28┊    min = args[0]\n+┊  ┊29┊    max = args[1]\n+┊  ┊30┊  }\n+┊  ┊31┊\n+┊  ┊32┊  if (typeof str !== 'string') {\n+┊  ┊33┊    throw TypeError(`${ctx} must be a string`)\n+┊  ┊34┊  }\n+┊  ┊35┊\n+┊  ┊36┊  if (str.length < min) {\n+┊  ┊37┊    throw TypeError(`${ctx} must be at least ${min} chars long`)\n+┊  ┊38┊  }\n+┊  ┊39┊\n+┊  ┊40┊  if (str.length > max) {\n+┊  ┊41┊    throw TypeError(`${ctx} must contain ${max} chars at most`)\n+┊  ┊42┊  }\n+┊  ┊43┊}\n```\n\n[}]: #\n\nAnd we will implement the resolver and schema for the `signUp` mutation:\n\n[{]: <helper> (diffStep 10.6 files=\"schema\" module=\"server\")\n\n#### [Server Step 10.6: Add signUp mutation](https://github.com/Urigo/WhatsApp-Clone-Server/commit/3e749d6)\n\n##### Changed schema&#x2F;resolvers.ts\n```diff\n@@ -5,6 +5,7 @@\n ┊ 5┊ 5┊import { secret, expiration } from '../env'\n ┊ 6┊ 6┊import bcrypt from 'bcrypt'\n ┊ 7┊ 7┊import jwt from 'jsonwebtoken'\n+┊  ┊ 8┊import { validateLength, validatePassword } from '../validators';\n ┊ 8┊ 9┊\n ┊ 9┊10┊const resolvers: Resolvers = {\n ┊10┊11┊  Date: GraphQLDateTime,\n```\n```diff\n@@ -96,20 +97,20 @@\n ┊ 96┊ 97┊  },\n ┊ 97┊ 98┊\n ┊ 98┊ 99┊  Mutation: {\n-┊ 99┊   ┊    signIn(root, { username, password}, { res }) {\n+┊   ┊100┊    signIn(root, { username, password }, { res }) {\n ┊100┊101┊\n ┊101┊102┊      const user = users.find(u => u.username === username)\n-┊102┊   ┊\n+┊   ┊103┊\n ┊103┊104┊      if (!user) {\n ┊104┊105┊        throw new Error('user not found')\n ┊105┊106┊      }\n-┊106┊   ┊\n+┊   ┊107┊\n ┊107┊108┊      const passwordsMatch = bcrypt.compareSync(password, user.password)\n-┊108┊   ┊\n+┊   ┊109┊\n ┊109┊110┊      if (!passwordsMatch) {\n ┊110┊111┊        throw new Error('password is incorrect')\n ┊111┊112┊      }\n-┊112┊   ┊\n+┊   ┊113┊\n ┊113┊114┊      const authToken = jwt.sign(username, secret)\n ┊114┊115┊\n ┊115┊116┊      res.cookie('authToken', authToken, { maxAge: expiration })\n```\n```diff\n@@ -117,6 +118,35 @@\n ┊117┊118┊      return user;\n ┊118┊119┊    },\n ┊119┊120┊\n+┊   ┊121┊    signUp(root, { name, username, password, passwordConfirm }) {\n+┊   ┊122┊\n+┊   ┊123┊      validateLength('req.name', name, 3, 50)\n+┊   ┊124┊      validateLength('req.username', name, 3, 18)\n+┊   ┊125┊      validatePassword('req.password', password)\n+┊   ┊126┊\n+┊   ┊127┊      if (password !== passwordConfirm) {\n+┊   ┊128┊        throw Error(\"req.password and req.passwordConfirm don't match\")\n+┊   ┊129┊      }\n+┊   ┊130┊\n+┊   ┊131┊      if (users.some(u => u.username === username)) {\n+┊   ┊132┊        throw Error(\"username already exists\")\n+┊   ┊133┊      }\n+┊   ┊134┊\n+┊   ┊135┊      const passwordHash = bcrypt.hashSync(password, bcrypt.genSaltSync(8))\n+┊   ┊136┊\n+┊   ┊137┊      const user: User = {\n+┊   ┊138┊        id: String(users.length + 1),\n+┊   ┊139┊        password: passwordHash,\n+┊   ┊140┊        picture: '',\n+┊   ┊141┊        username,\n+┊   ┊142┊        name,\n+┊   ┊143┊      }\n+┊   ┊144┊\n+┊   ┊145┊      users.push(user)\n+┊   ┊146┊\n+┊   ┊147┊      return user\n+┊   ┊148┊    },\n+┊   ┊149┊\n ┊120┊150┊    addMessage(root, { chatId, content }, { currentUser, pubsub }) {\n ┊121┊151┊      if (!currentUser) return null\n ┊122┊152┊\n```\n\n##### Changed schema&#x2F;typeDefs.graphql\n```diff\n@@ -34,6 +34,7 @@\n ┊34┊34┊\n ┊35┊35┊type Mutation {\n ┊36┊36┊  signIn(username: String!, password: String!): User\n+┊  ┊37┊  signUp(name: String!, username: String!, password: String!, passwordConfirm: String!): User\n ┊37┊38┊  addMessage(chatId: ID!, content: String!): Message\n ┊38┊39┊  addChat(recipientId: ID!): Chat\n ┊39┊40┊  removeChat(chatId: ID!): ID\n```\n\n[}]: #\n\nBefore encrypting the password we append a string called “salt” to it. Even though the passwords are stored encrypted in the DB, a hacker might use a dictionary of common passwords in their encrypted form to decipher the original password. When adding salt to a password which is essentially a random string, the hacker cannot use a dictionary anymore since he would need to know the salt. Hypothetically, the hacker can get a hold of the salt and re-generate the entire dictionary, however that would take too long because of the way Bcrypt is designed to work.\n\nGoing back to the client, we will implement a new `signUp()` method in the `auth.service` that will call the `signUp` mutation:\n\n[{]: <helper> (diffStep 13.5 module=\"client\")\n\n#### Client Step 13.5: Add signUp() method to auth.service\n\n##### Changed src&#x2F;services&#x2F;auth.service.tsx\n```diff\n@@ -62,6 +62,25 @@\n ┊62┊62┊  });\n ┊63┊63┊};\n ┊64┊64┊\n+┊  ┊65┊export const signUp = ({ name, username, password, passwordConfirm }:\n+┊  ┊66┊  {name: string, username: string, password: string, passwordConfirm: string}) => {\n+┊  ┊67┊  return client.mutate({\n+┊  ┊68┊    mutation: gql`\n+┊  ┊69┊      mutation signUp($name: String!, $username: String!, $password: String!, $passwordConfirm: String!) {\n+┊  ┊70┊        signUp(name: $name, username: $username, password: $password, passwordConfirm: $passwordConfirm) {\n+┊  ┊71┊          id\n+┊  ┊72┊        }\n+┊  ┊73┊      }\n+┊  ┊74┊    `,\n+┊  ┊75┊    variables: {\n+┊  ┊76┊      name,\n+┊  ┊77┊      username,\n+┊  ┊78┊      password,\n+┊  ┊79┊      passwordConfirm\n+┊  ┊80┊    }\n+┊  ┊81┊  });\n+┊  ┊82┊};\n+┊  ┊83┊\n ┊65┊84┊export const signOut = () => {\n ┊66┊85┊  document.cookie = `authToken=;expires=${new Date(0)}`;\n```\n\n[}]: #\n\nNow we will implement a dedicated `SignUpForm` that we can use to perform the sign-up. Instead of implementing a new screen, we will use the `AuthScreen` to alternate between the `SignInForm` and the `SignUpForm` using `AnimatedSwitch`. This way we can have a container component that is common for both forms, and we will be able to switch between the two very smoothly. We will first define a new `/sign-up` route in our router:\n\n[{]: <helper> (diffStep 13.6 module=\"client\")\n\n#### Client Step 13.6: Split AuthScreen into SignInForm and SignUpForm\n\n##### Added src&#x2F;components&#x2F;AuthScreen&#x2F;SignInForm.test.tsx\n```diff\n@@ -0,0 +1,81 @@\n+┊  ┊ 1┊import { createMemoryHistory } from 'history';\n+┊  ┊ 2┊import React from 'react';\n+┊  ┊ 3┊import { cleanup, render, fireEvent, wait, waitForElement } from 'react-testing-library';\n+┊  ┊ 4┊import SignInForm from './SignInForm';\n+┊  ┊ 5┊\n+┊  ┊ 6┊describe('SignInForm', () => {\n+┊  ┊ 7┊  afterEach(cleanup);\n+┊  ┊ 8┊  afterEach(() => fetch.resetMocks());\n+┊  ┊ 9┊\n+┊  ┊10┊  it('enables sign-in button when filled in', async () => {\n+┊  ┊11┊    const history = createMemoryHistory();\n+┊  ┊12┊\n+┊  ┊13┊    {\n+┊  ┊14┊      const { container, getByTestId } = render(<SignInForm history={history} />);\n+┊  ┊15┊      const usernameInput = getByTestId('username-input').querySelector('input');\n+┊  ┊16┊      const passwordInput = getByTestId('password-input').querySelector('input');\n+┊  ┊17┊      const signInButton = getByTestId('sign-in-button') as HTMLButtonElement;\n+┊  ┊18┊\n+┊  ┊19┊      expect(signInButton.disabled).toEqual(true);\n+┊  ┊20┊\n+┊  ┊21┊      fireEvent.change(usernameInput, { target: { value: 'username' } });\n+┊  ┊22┊      fireEvent.change(passwordInput, { target: { value: 'password' } });\n+┊  ┊23┊\n+┊  ┊24┊      await waitForElement(() => usernameInput);\n+┊  ┊25┊      await waitForElement(() => passwordInput);\n+┊  ┊26┊\n+┊  ┊27┊      expect(signInButton.disabled).toEqual(false);\n+┊  ┊28┊    }\n+┊  ┊29┊  });\n+┊  ┊30┊\n+┊  ┊31┊  it('prints server error if input was wrong', async () => {\n+┊  ┊32┊    const history = createMemoryHistory();\n+┊  ┊33┊\n+┊  ┊34┊    fetchMock.mockRejectOnce(new Error('sign-in failed'));\n+┊  ┊35┊\n+┊  ┊36┊    {\n+┊  ┊37┊      const { container, getByTestId } = render(<SignInForm history={history} />);\n+┊  ┊38┊      const usernameInput = getByTestId('username-input').querySelector('input');\n+┊  ┊39┊      const passwordInput = getByTestId('password-input').querySelector('input');\n+┊  ┊40┊      const signInButton = getByTestId('sign-in-button') as HTMLButtonElement;\n+┊  ┊41┊      const errorMessage = getByTestId('error-message');\n+┊  ┊42┊\n+┊  ┊43┊      fireEvent.change(usernameInput, { target: { value: 'username' } });\n+┊  ┊44┊      fireEvent.change(passwordInput, { target: { value: 'password' } });\n+┊  ┊45┊\n+┊  ┊46┊      await waitForElement(() => usernameInput);\n+┊  ┊47┊      await waitForElement(() => passwordInput);\n+┊  ┊48┊\n+┊  ┊49┊      fireEvent.click(signInButton);\n+┊  ┊50┊\n+┊  ┊51┊      await waitForElement(() => errorMessage);\n+┊  ┊52┊\n+┊  ┊53┊      expect(errorMessage.innerHTML).toEqual('sign-in failed');\n+┊  ┊54┊    }\n+┊  ┊55┊  });\n+┊  ┊56┊\n+┊  ┊57┊  it('navigates to /chats if everything went right', async () => {\n+┊  ┊58┊    const history = createMemoryHistory();\n+┊  ┊59┊\n+┊  ┊60┊    fetchMock.mockResponseOnce('success');\n+┊  ┊61┊\n+┊  ┊62┊    {\n+┊  ┊63┊      const { container, getByTestId } = render(<SignInForm history={history} />);\n+┊  ┊64┊      const usernameInput = getByTestId('username-input').querySelector('input');\n+┊  ┊65┊      const passwordInput = getByTestId('password-input').querySelector('input');\n+┊  ┊66┊      const signInButton = getByTestId('sign-in-button') as HTMLButtonElement;\n+┊  ┊67┊\n+┊  ┊68┊      fireEvent.change(usernameInput, { target: { value: 'username' } });\n+┊  ┊69┊      fireEvent.change(passwordInput, { target: { value: 'password' } });\n+┊  ┊70┊\n+┊  ┊71┊      await waitForElement(() => usernameInput);\n+┊  ┊72┊      await waitForElement(() => passwordInput);\n+┊  ┊73┊\n+┊  ┊74┊      fireEvent.click(signInButton);\n+┊  ┊75┊\n+┊  ┊76┊      await wait(() =>\n+┊  ┊77┊        expect(history.location.pathname).toEqual('/chats')\n+┊  ┊78┊      );\n+┊  ┊79┊    }\n+┊  ┊80┊  });\n+┊  ┊81┊});\n```\n\n##### Added src&#x2F;components&#x2F;AuthScreen&#x2F;SignInForm.tsx\n```diff\n@@ -0,0 +1,83 @@\n+┊  ┊ 1┊import React from 'react';\n+┊  ┊ 2┊import { useCallback, useState } from 'react';\n+┊  ┊ 3┊import { signIn } from '../../services/auth.service';\n+┊  ┊ 4┊import {\n+┊  ┊ 5┊  SignForm,\n+┊  ┊ 6┊  ActualForm,\n+┊  ┊ 7┊  Legend,\n+┊  ┊ 8┊  Section,\n+┊  ┊ 9┊  TextField,\n+┊  ┊10┊  Button,\n+┊  ┊11┊  ErrorMessage,\n+┊  ┊12┊} from './form-components';\n+┊  ┊13┊import { RouteComponentProps } from 'react-router-dom';\n+┊  ┊14┊\n+┊  ┊15┊const SignInForm: React.FC<RouteComponentProps<any>> = ({ history }) => {\n+┊  ┊16┊  const [username, setUsername] = useState('');\n+┊  ┊17┊  const [password, setPassword] = useState('');\n+┊  ┊18┊  const [error, setError] = useState('');\n+┊  ┊19┊\n+┊  ┊20┊  const onUsernameChange = useCallback(({ target }) => {\n+┊  ┊21┊    setError('');\n+┊  ┊22┊    setUsername(target.value);\n+┊  ┊23┊  }, []);\n+┊  ┊24┊\n+┊  ┊25┊  const onPasswordChange = useCallback(({ target }) => {\n+┊  ┊26┊    setError('');\n+┊  ┊27┊    setPassword(target.value);\n+┊  ┊28┊  }, []);\n+┊  ┊29┊\n+┊  ┊30┊  const maySignIn = useCallback(() => {\n+┊  ┊31┊    return !!(username && password);\n+┊  ┊32┊  }, [username, password]);\n+┊  ┊33┊\n+┊  ┊34┊  const handleSignIn = useCallback(() => {\n+┊  ┊35┊    signIn({ username, password })\n+┊  ┊36┊      .then(() => {\n+┊  ┊37┊        history.replace('/chats')\n+┊  ┊38┊      })\n+┊  ┊39┊      .catch(error => {\n+┊  ┊40┊        setError(error.message || error)\n+┊  ┊41┊      });\n+┊  ┊42┊  }, [username, password, history]);\n+┊  ┊43┊\n+┊  ┊44┊  return (\n+┊  ┊45┊    <SignForm>\n+┊  ┊46┊      <ActualForm>\n+┊  ┊47┊        <Legend>Sign in</Legend>\n+┊  ┊48┊        <Section style={{ width: '100%' }}>\n+┊  ┊49┊          <TextField\n+┊  ┊50┊            data-testid=\"username-input\"\n+┊  ┊51┊            label=\"Username\"\n+┊  ┊52┊            value={username}\n+┊  ┊53┊            onChange={onUsernameChange}\n+┊  ┊54┊            margin=\"normal\"\n+┊  ┊55┊            placeholder=\"Enter your username\"\n+┊  ┊56┊          />\n+┊  ┊57┊          <TextField\n+┊  ┊58┊            data-testid=\"password-input\"\n+┊  ┊59┊            label=\"Password\"\n+┊  ┊60┊            type=\"password\"\n+┊  ┊61┊            value={password}\n+┊  ┊62┊            onChange={onPasswordChange}\n+┊  ┊63┊            margin=\"normal\"\n+┊  ┊64┊            placeholder=\"Enter your password\"\n+┊  ┊65┊          />\n+┊  ┊66┊        </Section>\n+┊  ┊67┊        <Button\n+┊  ┊68┊          data-testid=\"sign-in-button\"\n+┊  ┊69┊          type=\"button\"\n+┊  ┊70┊          color=\"secondary\"\n+┊  ┊71┊          variant=\"contained\"\n+┊  ┊72┊          disabled={!maySignIn()}\n+┊  ┊73┊          onClick={handleSignIn}\n+┊  ┊74┊        >\n+┊  ┊75┊          Sign in\n+┊  ┊76┊        </Button>\n+┊  ┊77┊        <ErrorMessage data-testid=\"error-message\">{error}</ErrorMessage>\n+┊  ┊78┊      </ActualForm>\n+┊  ┊79┊    </SignForm>\n+┊  ┊80┊  );\n+┊  ┊81┊};\n+┊  ┊82┊\n+┊  ┊83┊export default SignInForm;\n```\n\n##### Added src&#x2F;components&#x2F;AuthScreen&#x2F;SignUpForm.test.tsx\n```diff\n@@ -0,0 +1,99 @@\n+┊  ┊ 1┊import { createMemoryHistory } from 'history';\n+┊  ┊ 2┊import React from 'react';\n+┊  ┊ 3┊import { cleanup, render, fireEvent, wait, waitForElement } from 'react-testing-library';\n+┊  ┊ 4┊import SignUpForm from './SignUpForm';\n+┊  ┊ 5┊\n+┊  ┊ 6┊describe('SignUpForm', () => {\n+┊  ┊ 7┊  afterEach(cleanup);\n+┊  ┊ 8┊  afterEach(() => fetch.resetMocks());\n+┊  ┊ 9┊\n+┊  ┊10┊  it('enables sign-up button when filled in', async () => {\n+┊  ┊11┊    const history = createMemoryHistory();\n+┊  ┊12┊\n+┊  ┊13┊    {\n+┊  ┊14┊      const { container, getByTestId } = render(<SignUpForm history={history} />);\n+┊  ┊15┊      const nameInput = getByTestId('name-input').querySelector('input');\n+┊  ┊16┊      const usernameInput = getByTestId('username-input').querySelector('input');\n+┊  ┊17┊      const passwordInput = getByTestId('password-input').querySelector('input');\n+┊  ┊18┊      const passwordConfirmInput = getByTestId('password-confirm-input').querySelector('input');\n+┊  ┊19┊      const signUpButton = getByTestId('sign-up-button') as HTMLButtonElement;\n+┊  ┊20┊\n+┊  ┊21┊      expect(signUpButton.disabled).toEqual(true);\n+┊  ┊22┊\n+┊  ┊23┊      fireEvent.change(nameInput, { target: { value: 'User Name' } });\n+┊  ┊24┊      fireEvent.change(usernameInput, { target: { value: 'username' } });\n+┊  ┊25┊      fireEvent.change(passwordInput, { target: { value: 'password' } });\n+┊  ┊26┊      fireEvent.change(passwordConfirmInput, { target: { value: 'password' } });\n+┊  ┊27┊\n+┊  ┊28┊      await waitForElement(() => nameInput);\n+┊  ┊29┊      await waitForElement(() => usernameInput);\n+┊  ┊30┊      await waitForElement(() => passwordInput);\n+┊  ┊31┊      await waitForElement(() => passwordConfirmInput);\n+┊  ┊32┊\n+┊  ┊33┊      expect(signUpButton.disabled).toEqual(false);\n+┊  ┊34┊    }\n+┊  ┊35┊  });\n+┊  ┊36┊\n+┊  ┊37┊  it('prints server error if input was wrong', async () => {\n+┊  ┊38┊    const history = createMemoryHistory();\n+┊  ┊39┊\n+┊  ┊40┊    fetchMock.mockRejectOnce(new Error('sign-up failed'));\n+┊  ┊41┊\n+┊  ┊42┊    {\n+┊  ┊43┊      const { container, getByTestId } = render(<SignUpForm history={history} />);\n+┊  ┊44┊      const nameInput = getByTestId('name-input').querySelector('input');\n+┊  ┊45┊      const usernameInput = getByTestId('username-input').querySelector('input');\n+┊  ┊46┊      const passwordInput = getByTestId('password-input').querySelector('input');\n+┊  ┊47┊      const passwordConfirmInput = getByTestId('password-confirm-input').querySelector('input');\n+┊  ┊48┊      const signUpButton = getByTestId('sign-up-button') as HTMLButtonElement;\n+┊  ┊49┊      const errorMessage = getByTestId('error-message');\n+┊  ┊50┊\n+┊  ┊51┊      fireEvent.change(nameInput, { target: { value: 'User Name' } });\n+┊  ┊52┊      fireEvent.change(usernameInput, { target: { value: 'username' } });\n+┊  ┊53┊      fireEvent.change(passwordInput, { target: { value: 'password' } });\n+┊  ┊54┊      fireEvent.change(passwordConfirmInput, { target: { value: 'password' } });\n+┊  ┊55┊\n+┊  ┊56┊      await waitForElement(() => nameInput);\n+┊  ┊57┊      await waitForElement(() => usernameInput);\n+┊  ┊58┊      await waitForElement(() => passwordInput);\n+┊  ┊59┊      await waitForElement(() => passwordConfirmInput);\n+┊  ┊60┊\n+┊  ┊61┊      fireEvent.click(signUpButton);\n+┊  ┊62┊\n+┊  ┊63┊      await waitForElement(() => errorMessage);\n+┊  ┊64┊\n+┊  ┊65┊      expect(errorMessage.innerHTML).toEqual('sign-up failed');\n+┊  ┊66┊    }\n+┊  ┊67┊  });\n+┊  ┊68┊\n+┊  ┊69┊  it('navigates to /sign-in if everything went right', async () => {\n+┊  ┊70┊    const history = createMemoryHistory();\n+┊  ┊71┊\n+┊  ┊72┊    fetchMock.mockResponseOnce('success');\n+┊  ┊73┊\n+┊  ┊74┊    {\n+┊  ┊75┊      const { container, getByTestId } = render(<SignUpForm history={history} />);\n+┊  ┊76┊      const nameInput = getByTestId('name-input').querySelector('input');\n+┊  ┊77┊      const usernameInput = getByTestId('username-input').querySelector('input');\n+┊  ┊78┊      const passwordInput = getByTestId('password-input').querySelector('input');\n+┊  ┊79┊      const passwordConfirmInput = getByTestId('password-confirm-input').querySelector('input');\n+┊  ┊80┊      const signUpButton = getByTestId('sign-up-button') as HTMLButtonElement;\n+┊  ┊81┊\n+┊  ┊82┊      fireEvent.change(nameInput, { target: { value: 'User Name' } });\n+┊  ┊83┊      fireEvent.change(usernameInput, { target: { value: 'username' } });\n+┊  ┊84┊      fireEvent.change(passwordInput, { target: { value: 'password' } });\n+┊  ┊85┊      fireEvent.change(passwordConfirmInput, { target: { value: 'password' } });\n+┊  ┊86┊\n+┊  ┊87┊      await waitForElement(() => nameInput);\n+┊  ┊88┊      await waitForElement(() => usernameInput);\n+┊  ┊89┊      await waitForElement(() => passwordInput);\n+┊  ┊90┊      await waitForElement(() => passwordConfirmInput);\n+┊  ┊91┊\n+┊  ┊92┊      fireEvent.click(signUpButton);\n+┊  ┊93┊\n+┊  ┊94┊      await wait(() =>\n+┊  ┊95┊        expect(history.location.pathname).toEqual('/sign-in')\n+┊  ┊96┊      );\n+┊  ┊97┊    }\n+┊  ┊98┊  });\n+┊  ┊99┊});\n```\n\n##### Added src&#x2F;components&#x2F;AuthScreen&#x2F;SignUpForm.tsx\n```diff\n@@ -0,0 +1,126 @@\n+┊   ┊  1┊import React from 'react';\n+┊   ┊  2┊import { useCallback, useState } from 'react';\n+┊   ┊  3┊import { signUp } from '../../services/auth.service';\n+┊   ┊  4┊import {\n+┊   ┊  5┊  SignForm,\n+┊   ┊  6┊  ActualForm,\n+┊   ┊  7┊  Legend,\n+┊   ┊  8┊  Section,\n+┊   ┊  9┊  TextField,\n+┊   ┊ 10┊  Button,\n+┊   ┊ 11┊  ErrorMessage,\n+┊   ┊ 12┊} from './form-components';\n+┊   ┊ 13┊import { RouteComponentProps } from 'react-router-dom';\n+┊   ┊ 14┊\n+┊   ┊ 15┊const SignUpForm: React.FC<RouteComponentProps<any>> = ({ history }) => {\n+┊   ┊ 16┊  const [name, setName] = useState('');\n+┊   ┊ 17┊  const [username, setUsername] = useState('');\n+┊   ┊ 18┊  const [password, setPassword] = useState('');\n+┊   ┊ 19┊  const [passwordConfirm, setPasswordConfirm] = useState('');\n+┊   ┊ 20┊  const [error, setError] = useState('');\n+┊   ┊ 21┊\n+┊   ┊ 22┊  const updateName = useCallback(({ target }) => {\n+┊   ┊ 23┊    setError('');\n+┊   ┊ 24┊    setName(target.value);\n+┊   ┊ 25┊  }, []);\n+┊   ┊ 26┊\n+┊   ┊ 27┊  const updateUsername = useCallback(({ target }) => {\n+┊   ┊ 28┊    setError('');\n+┊   ┊ 29┊    setUsername(target.value);\n+┊   ┊ 30┊  }, []);\n+┊   ┊ 31┊\n+┊   ┊ 32┊  const updatePassword = useCallback(({ target }) => {\n+┊   ┊ 33┊    setError('');\n+┊   ┊ 34┊    setPassword(target.value);\n+┊   ┊ 35┊  }, []);\n+┊   ┊ 36┊\n+┊   ┊ 37┊  const updatePasswordConfirm = useCallback(({ target }) => {\n+┊   ┊ 38┊    setError('');\n+┊   ┊ 39┊    setPasswordConfirm(target.value);\n+┊   ┊ 40┊  }, []);\n+┊   ┊ 41┊\n+┊   ┊ 42┊  const maySignUp = useCallback(() => {\n+┊   ┊ 43┊    return !!(name && username && password && password === passwordConfirm);\n+┊   ┊ 44┊  }, [name, username, password, passwordConfirm]);\n+┊   ┊ 45┊\n+┊   ┊ 46┊  const handleSignUp = useCallback(() => {\n+┊   ┊ 47┊    signUp({ username, password, passwordConfirm, name })\n+┊   ┊ 48┊      .then(() => {\n+┊   ┊ 49┊        history.replace('/sign-in')\n+┊   ┊ 50┊      })\n+┊   ┊ 51┊      .catch(error => {\n+┊   ┊ 52┊        setError(error.message || error)\n+┊   ┊ 53┊      });\n+┊   ┊ 54┊  }, [name, username, password, passwordConfirm, history]);\n+┊   ┊ 55┊\n+┊   ┊ 56┊  return (\n+┊   ┊ 57┊    <SignForm>\n+┊   ┊ 58┊      <ActualForm>\n+┊   ┊ 59┊        <Legend>Sign up</Legend>\n+┊   ┊ 60┊        <Section\n+┊   ┊ 61┊          style={{\n+┊   ┊ 62┊            float: 'left',\n+┊   ┊ 63┊            width: 'calc(50% - 10px)',\n+┊   ┊ 64┊            paddingRight: '10px',\n+┊   ┊ 65┊          }}\n+┊   ┊ 66┊        >\n+┊   ┊ 67┊          <TextField\n+┊   ┊ 68┊            data-testid=\"name-input\"\n+┊   ┊ 69┊            label=\"Name\"\n+┊   ┊ 70┊            value={name}\n+┊   ┊ 71┊            onChange={updateName}\n+┊   ┊ 72┊            autoComplete=\"off\"\n+┊   ┊ 73┊            margin=\"normal\"\n+┊   ┊ 74┊          />\n+┊   ┊ 75┊          <TextField\n+┊   ┊ 76┊            data-testid=\"username-input\"\n+┊   ┊ 77┊            label=\"Username\"\n+┊   ┊ 78┊            value={username}\n+┊   ┊ 79┊            onChange={updateUsername}\n+┊   ┊ 80┊            autoComplete=\"off\"\n+┊   ┊ 81┊            margin=\"normal\"\n+┊   ┊ 82┊          />\n+┊   ┊ 83┊        </Section>\n+┊   ┊ 84┊        <Section\n+┊   ┊ 85┊          style={{\n+┊   ┊ 86┊            float: 'right',\n+┊   ┊ 87┊            width: 'calc(50% - 10px)',\n+┊   ┊ 88┊            paddingLeft: '10px',\n+┊   ┊ 89┊          }}\n+┊   ┊ 90┊        >\n+┊   ┊ 91┊          <TextField\n+┊   ┊ 92┊            data-testid=\"password-input\"\n+┊   ┊ 93┊            label=\"Password\"\n+┊   ┊ 94┊            type=\"password\"\n+┊   ┊ 95┊            value={password}\n+┊   ┊ 96┊            onChange={updatePassword}\n+┊   ┊ 97┊            autoComplete=\"off\"\n+┊   ┊ 98┊            margin=\"normal\"\n+┊   ┊ 99┊          />\n+┊   ┊100┊          <TextField\n+┊   ┊101┊            data-testid=\"password-confirm-input\"\n+┊   ┊102┊            label=\"Confirm password\"\n+┊   ┊103┊            type=\"password\"\n+┊   ┊104┊            value={passwordConfirm}\n+┊   ┊105┊            onChange={updatePasswordConfirm}\n+┊   ┊106┊            autoComplete=\"off\"\n+┊   ┊107┊            margin=\"normal\"\n+┊   ┊108┊          />\n+┊   ┊109┊        </Section>\n+┊   ┊110┊        <Button\n+┊   ┊111┊          data-testid=\"sign-up-button\"\n+┊   ┊112┊          type=\"button\"\n+┊   ┊113┊          color=\"secondary\"\n+┊   ┊114┊          variant=\"contained\"\n+┊   ┊115┊          disabled={!maySignUp()}\n+┊   ┊116┊          onClick={handleSignUp}\n+┊   ┊117┊        >\n+┊   ┊118┊          Sign up\n+┊   ┊119┊        </Button>\n+┊   ┊120┊        <ErrorMessage data-testid=\"error-message\">{error}</ErrorMessage>\n+┊   ┊121┊      </ActualForm>\n+┊   ┊122┊    </SignForm>\n+┊   ┊123┊  );\n+┊   ┊124┊};\n+┊   ┊125┊\n+┊   ┊126┊export default SignUpForm;🚫↵\n```\n\n##### Added src&#x2F;components&#x2F;AuthScreen&#x2F;form-components.ts\n```diff\n@@ -0,0 +1,75 @@\n+┊  ┊ 1┊import MaterialButton from '@material-ui/core/Button';\n+┊  ┊ 2┊import MaterialTextField from '@material-ui/core/TextField';\n+┊  ┊ 3┊import styled from 'styled-components';\n+┊  ┊ 4┊\n+┊  ┊ 5┊export const SignForm = styled.div `\n+┊  ┊ 6┊  height: calc(100% - 265px);\n+┊  ┊ 7┊`;\n+┊  ┊ 8┊\n+┊  ┊ 9┊export const ActualForm = styled.form `\n+┊  ┊10┊  padding: 20px;\n+┊  ┊11┊`;\n+┊  ┊12┊\n+┊  ┊13┊export const Section = styled.div `\n+┊  ┊14┊  padding-bottom: 35px;\n+┊  ┊15┊`;\n+┊  ┊16┊\n+┊  ┊17┊export const Legend = styled.legend `\n+┊  ┊18┊  font-weight: bold;\n+┊  ┊19┊  color: white;\n+┊  ┊20┊`;\n+┊  ┊21┊\n+┊  ┊22┊export const Label = styled.label `\n+┊  ┊23┊  color: white !important;\n+┊  ┊24┊`;\n+┊  ┊25┊\n+┊  ┊26┊export const Input = styled.input `\n+┊  ┊27┊  color: white;\n+┊  ┊28┊\n+┊  ┊29┊  &::placeholder {\n+┊  ┊30┊    color: var(--primary-bg);\n+┊  ┊31┊  }\n+┊  ┊32┊`;\n+┊  ┊33┊\n+┊  ┊34┊export const TextField = styled(MaterialTextField) `\n+┊  ┊35┊  width: 100%;\n+┊  ┊36┊  position: relative;\n+┊  ┊37┊\n+┊  ┊38┊  > div::before {\n+┊  ┊39┊    border-color: white !important;\n+┊  ┊40┊  }\n+┊  ┊41┊\n+┊  ┊42┊  input {\n+┊  ┊43┊    color: white !important;\n+┊  ┊44┊\n+┊  ┊45┊    &::placeholder {\n+┊  ┊46┊      color: var(--primary-bg) !important;\n+┊  ┊47┊    }\n+┊  ┊48┊  }\n+┊  ┊49┊\n+┊  ┊50┊  label {\n+┊  ┊51┊    color: white !important;\n+┊  ┊52┊  }\n+┊  ┊53┊` as typeof MaterialTextField;\n+┊  ┊54┊\n+┊  ┊55┊export const Button = styled(MaterialButton) `\n+┊  ┊56┊  width: 100px;\n+┊  ┊57┊  display: block !important;\n+┊  ┊58┊  margin: auto !important;\n+┊  ┊59┊  background-color: var(--secondary-bg) !important;\n+┊  ┊60┊\n+┊  ┊61┊  &[disabled] {\n+┊  ┊62┊    color: #38a81c;\n+┊  ┊63┊  }\n+┊  ┊64┊\n+┊  ┊65┊  &:not([disabled]) {\n+┊  ┊66┊    color: white;\n+┊  ┊67┊  }\n+┊  ┊68┊` as typeof MaterialButton;\n+┊  ┊69┊\n+┊  ┊70┊export const ErrorMessage = styled.div `\n+┊  ┊71┊  position: fixed;\n+┊  ┊72┊  color: red;\n+┊  ┊73┊  font-size: 15px;\n+┊  ┊74┊  margin-top: 20px;\n+┊  ┊75┊`;\n```\n\n##### Changed src&#x2F;components&#x2F;AuthScreen&#x2F;index.tsx\n```diff\n@@ -1,13 +1,13 @@\n-┊ 1┊  ┊import MaterialButton from '@material-ui/core/Button';\n-┊ 2┊  ┊import MaterialTextField from '@material-ui/core/TextField';\n ┊ 3┊ 1┊import React from 'react';\n-┊ 4┊  ┊import { useCallback, useState } from 'react';\n+┊  ┊ 2┊import { useMemo } from 'react';\n+┊  ┊ 3┊import { Route } from 'react-router-dom';\n ┊ 5┊ 4┊import styled from 'styled-components';\n-┊ 6┊  ┊import { signIn } from '../../services/auth.service';\n+┊  ┊ 5┊import AnimatedSwitch from '../AnimatedSwitch';\n+┊  ┊ 6┊import SignInForm from './SignInForm';\n+┊  ┊ 7┊import SignUpForm from './SignUpForm';\n ┊ 7┊ 8┊import { RouteComponentProps } from 'react-router-dom';\n ┊ 8┊ 9┊\n ┊ 9┊10┊const Container = styled.div `\n-┊10┊  ┊  height: 100%;\n ┊11┊11┊  background: radial-gradient(rgb(34, 65, 67), rgb(17, 48, 50)),\n ┊12┊12┊    url(/assets/chat-background.jpg) no-repeat;\n ┊13┊13┊  background-size: cover;\n```\n```diff\n@@ -40,149 +40,48 @@\n ┊ 40┊ 40┊  bottom: 10px;\n ┊ 41┊ 41┊  left: 10px;\n ┊ 42┊ 42┊\n-┊ 43┊   ┊  a {\n+┊   ┊ 43┊  label {\n ┊ 44┊ 44┊    color: var(--secondary-bg);\n ┊ 45┊ 45┊  }\n ┊ 46┊ 46┊`;\n ┊ 47┊ 47┊\n-┊ 48┊   ┊const SignInForm = styled.div `\n-┊ 49┊   ┊  height: calc(100% - 265px);\n-┊ 50┊   ┊`;\n-┊ 51┊   ┊\n-┊ 52┊   ┊const ActualForm = styled.form `\n-┊ 53┊   ┊  padding: 20px;\n-┊ 54┊   ┊`;\n-┊ 55┊   ┊\n-┊ 56┊   ┊const Section = styled.div `\n-┊ 57┊   ┊  width: 100%;\n-┊ 58┊   ┊  padding-bottom: 35px;\n-┊ 59┊   ┊`;\n-┊ 60┊   ┊\n-┊ 61┊   ┊const Legend = styled.legend `\n-┊ 62┊   ┊  font-weight: bold;\n-┊ 63┊   ┊  color: white;\n-┊ 64┊   ┊`;\n-┊ 65┊   ┊\n-┊ 66┊   ┊// eslint-disable-next-line\n-┊ 67┊   ┊const Label = styled.label `\n-┊ 68┊   ┊  color: white !important;\n-┊ 69┊   ┊`;\n-┊ 70┊   ┊\n-┊ 71┊   ┊// eslint-disable-next-line\n-┊ 72┊   ┊const Input = styled.input `\n-┊ 73┊   ┊  color: white;\n-┊ 74┊   ┊\n-┊ 75┊   ┊  &::placeholder {\n-┊ 76┊   ┊    color: var(--primary-bg);\n-┊ 77┊   ┊  }\n-┊ 78┊   ┊`;\n-┊ 79┊   ┊\n-┊ 80┊   ┊const TextField = styled(MaterialTextField) `\n-┊ 81┊   ┊  width: 100%;\n-┊ 82┊   ┊  position: relative;\n-┊ 83┊   ┊\n-┊ 84┊   ┊  > div::before {\n-┊ 85┊   ┊    border-color: white !important;\n-┊ 86┊   ┊  }\n-┊ 87┊   ┊\n-┊ 88┊   ┊  input {\n-┊ 89┊   ┊    color: white !important;\n-┊ 90┊   ┊\n-┊ 91┊   ┊    &::placeholder {\n-┊ 92┊   ┊      color: var(--primary-bg) !important;\n+┊   ┊ 48┊const AuthScreen: React.FC<RouteComponentProps<any>> = ({ history, location }) => {\n+┊   ┊ 49┊  const alternative = useMemo(() => {\n+┊   ┊ 50┊    if (location.pathname === '/sign-in') {\n+┊   ┊ 51┊      const handleSignUp = () => {\n+┊   ┊ 52┊        history.replace('/sign-up');\n+┊   ┊ 53┊      };\n+┊   ┊ 54┊\n+┊   ┊ 55┊      return (\n+┊   ┊ 56┊        <Alternative>\n+┊   ┊ 57┊          Don't have an account yet? <label onClick={handleSignUp}>Sign up!</label>\n+┊   ┊ 58┊        </Alternative>\n+┊   ┊ 59┊      );\n ┊ 93┊ 60┊    }\n-┊ 94┊   ┊  }\n-┊ 95┊   ┊\n-┊ 96┊   ┊  label {\n-┊ 97┊   ┊    color: white !important;\n-┊ 98┊   ┊  }\n-┊ 99┊   ┊` as typeof MaterialTextField;\n-┊100┊   ┊\n-┊101┊   ┊const Button = styled(MaterialButton) `\n-┊102┊   ┊  width: 100px;\n-┊103┊   ┊  display: block !important;\n-┊104┊   ┊  margin: auto !important;\n-┊105┊   ┊  background-color: var(--secondary-bg) !important;\n-┊106┊   ┊\n-┊107┊   ┊  &[disabled] {\n-┊108┊   ┊    color: #38a81c;\n-┊109┊   ┊  }\n-┊110┊   ┊\n-┊111┊   ┊  &:not([disabled]) {\n-┊112┊   ┊    color: white;\n-┊113┊   ┊  }\n-┊114┊   ┊` as typeof MaterialButton;\n-┊115┊   ┊\n-┊116┊   ┊const AuthScreen: React.FC<RouteComponentProps<any>> = ({ history }) => {\n-┊117┊   ┊  const [username, setUsername] = useState('');\n-┊118┊   ┊  const [password, setPassword] = useState('');\n-┊119┊   ┊  // eslint-disable-next-line\n-┊120┊   ┊  const [error, setError] = useState('');\n-┊121┊   ┊\n-┊122┊   ┊  const onUsernameChange = useCallback(({ target }) => {\n-┊123┊   ┊    setError('');\n-┊124┊   ┊    setUsername(target.value);\n-┊125┊   ┊  }, []);\n-┊126┊   ┊\n-┊127┊   ┊  const onPasswordChange = useCallback(({ target }) => {\n-┊128┊   ┊    setError('');\n-┊129┊   ┊    setPassword(target.value);\n-┊130┊   ┊  }, []);\n-┊131┊   ┊\n-┊132┊   ┊  const maySignIn = useCallback(() => {\n-┊133┊   ┊    return !!(username && password);\n-┊134┊   ┊  }, [username, password]);\n-┊135┊   ┊\n-┊136┊   ┊  const handleSignIn = useCallback(() => {\n-┊137┊   ┊    signIn({ username, password })\n-┊138┊   ┊      .then(() => {\n-┊139┊   ┊        history.push('/chats')\n-┊140┊   ┊      })\n-┊141┊   ┊      .catch(error => {\n-┊142┊   ┊        setError(error.message || error)\n-┊143┊   ┊      });\n-┊144┊   ┊  }, [username, password, history]);\n+┊   ┊ 61┊    else {\n+┊   ┊ 62┊      const handleSignIn = () => {\n+┊   ┊ 63┊        history.replace('/sign-in');\n+┊   ┊ 64┊      };\n+┊   ┊ 65┊\n+┊   ┊ 66┊      return (\n+┊   ┊ 67┊        <Alternative>\n+┊   ┊ 68┊          Already have an accout? <label onClick={handleSignIn}>Sign in!</label>\n+┊   ┊ 69┊        </Alternative>\n+┊   ┊ 70┊      );\n+┊   ┊ 71┊    }\n+┊   ┊ 72┊  }, [location.pathname, history]);\n ┊145┊ 73┊\n ┊146┊ 74┊  return (\n-┊147┊   ┊    <Container>\n-┊148┊   ┊      <Intro>\n+┊   ┊ 75┊    <Container className=\"AuthScreen Screen\">\n+┊   ┊ 76┊      <Intro className=\"AuthScreen-intro\">\n ┊149┊ 77┊        <Icon src=\"assets/whatsapp-icon.png\" className=\"AuthScreen-icon\" />\n ┊150┊ 78┊        <Title className=\"AuthScreen-title\">WhatsApp</Title>\n ┊151┊ 79┊      </Intro>\n-┊152┊   ┊      <SignInForm>\n-┊153┊   ┊        <ActualForm>\n-┊154┊   ┊          <Legend>Sign in</Legend>\n-┊155┊   ┊          <Section>\n-┊156┊   ┊            <TextField\n-┊157┊   ┊              className=\"AuthScreen-text-field\"\n-┊158┊   ┊              label=\"Username\"\n-┊159┊   ┊              value={username}\n-┊160┊   ┊              onChange={onUsernameChange}\n-┊161┊   ┊              margin=\"normal\"\n-┊162┊   ┊              placeholder=\"Enter your username\"\n-┊163┊   ┊            />\n-┊164┊   ┊            <TextField\n-┊165┊   ┊              className=\"AuthScreen-text-field\"\n-┊166┊   ┊              label=\"Password\"\n-┊167┊   ┊              type=\"password\"\n-┊168┊   ┊              value={password}\n-┊169┊   ┊              onChange={onPasswordChange}\n-┊170┊   ┊              margin=\"normal\"\n-┊171┊   ┊              placeholder=\"Enter your password\"\n-┊172┊   ┊            />\n-┊173┊   ┊          </Section>\n-┊174┊   ┊          <Button\n-┊175┊   ┊            data-testid=\"sign-in-button\"\n-┊176┊   ┊            type=\"button\"\n-┊177┊   ┊            color=\"secondary\"\n-┊178┊   ┊            variant=\"contained\"\n-┊179┊   ┊            disabled={!maySignIn()}\n-┊180┊   ┊            onClick={handleSignIn}\n-┊181┊   ┊          >\n-┊182┊   ┊            Sign in\n-┊183┊   ┊          </Button>\n-┊184┊   ┊        </ActualForm>\n-┊185┊   ┊      </SignInForm>\n+┊   ┊ 80┊      <AnimatedSwitch>\n+┊   ┊ 81┊        <Route exact path=\"/sign-in\" component={SignInForm} />\n+┊   ┊ 82┊        <Route exact path=\"/sign-up\" component={SignUpForm} />\n+┊   ┊ 83┊      </AnimatedSwitch>\n+┊   ┊ 84┊      {alternative}\n ┊186┊ 85┊    </Container>\n ┊187┊ 86┊  );\n ┊188┊ 87┊};\n```\n\n[}]: #\n\nAnd then we will make the necessary changes in the `AuthScreen`:\n\n[{]: <helper> (diffStep 13.6 module=\"client\")\n\n#### Client Step 13.6: Split AuthScreen into SignInForm and SignUpForm\n\n##### Added src&#x2F;components&#x2F;AuthScreen&#x2F;SignInForm.test.tsx\n```diff\n@@ -0,0 +1,81 @@\n+┊  ┊ 1┊import { createMemoryHistory } from 'history';\n+┊  ┊ 2┊import React from 'react';\n+┊  ┊ 3┊import { cleanup, render, fireEvent, wait, waitForElement } from 'react-testing-library';\n+┊  ┊ 4┊import SignInForm from './SignInForm';\n+┊  ┊ 5┊\n+┊  ┊ 6┊describe('SignInForm', () => {\n+┊  ┊ 7┊  afterEach(cleanup);\n+┊  ┊ 8┊  afterEach(() => fetch.resetMocks());\n+┊  ┊ 9┊\n+┊  ┊10┊  it('enables sign-in button when filled in', async () => {\n+┊  ┊11┊    const history = createMemoryHistory();\n+┊  ┊12┊\n+┊  ┊13┊    {\n+┊  ┊14┊      const { container, getByTestId } = render(<SignInForm history={history} />);\n+┊  ┊15┊      const usernameInput = getByTestId('username-input').querySelector('input');\n+┊  ┊16┊      const passwordInput = getByTestId('password-input').querySelector('input');\n+┊  ┊17┊      const signInButton = getByTestId('sign-in-button') as HTMLButtonElement;\n+┊  ┊18┊\n+┊  ┊19┊      expect(signInButton.disabled).toEqual(true);\n+┊  ┊20┊\n+┊  ┊21┊      fireEvent.change(usernameInput, { target: { value: 'username' } });\n+┊  ┊22┊      fireEvent.change(passwordInput, { target: { value: 'password' } });\n+┊  ┊23┊\n+┊  ┊24┊      await waitForElement(() => usernameInput);\n+┊  ┊25┊      await waitForElement(() => passwordInput);\n+┊  ┊26┊\n+┊  ┊27┊      expect(signInButton.disabled).toEqual(false);\n+┊  ┊28┊    }\n+┊  ┊29┊  });\n+┊  ┊30┊\n+┊  ┊31┊  it('prints server error if input was wrong', async () => {\n+┊  ┊32┊    const history = createMemoryHistory();\n+┊  ┊33┊\n+┊  ┊34┊    fetchMock.mockRejectOnce(new Error('sign-in failed'));\n+┊  ┊35┊\n+┊  ┊36┊    {\n+┊  ┊37┊      const { container, getByTestId } = render(<SignInForm history={history} />);\n+┊  ┊38┊      const usernameInput = getByTestId('username-input').querySelector('input');\n+┊  ┊39┊      const passwordInput = getByTestId('password-input').querySelector('input');\n+┊  ┊40┊      const signInButton = getByTestId('sign-in-button') as HTMLButtonElement;\n+┊  ┊41┊      const errorMessage = getByTestId('error-message');\n+┊  ┊42┊\n+┊  ┊43┊      fireEvent.change(usernameInput, { target: { value: 'username' } });\n+┊  ┊44┊      fireEvent.change(passwordInput, { target: { value: 'password' } });\n+┊  ┊45┊\n+┊  ┊46┊      await waitForElement(() => usernameInput);\n+┊  ┊47┊      await waitForElement(() => passwordInput);\n+┊  ┊48┊\n+┊  ┊49┊      fireEvent.click(signInButton);\n+┊  ┊50┊\n+┊  ┊51┊      await waitForElement(() => errorMessage);\n+┊  ┊52┊\n+┊  ┊53┊      expect(errorMessage.innerHTML).toEqual('sign-in failed');\n+┊  ┊54┊    }\n+┊  ┊55┊  });\n+┊  ┊56┊\n+┊  ┊57┊  it('navigates to /chats if everything went right', async () => {\n+┊  ┊58┊    const history = createMemoryHistory();\n+┊  ┊59┊\n+┊  ┊60┊    fetchMock.mockResponseOnce('success');\n+┊  ┊61┊\n+┊  ┊62┊    {\n+┊  ┊63┊      const { container, getByTestId } = render(<SignInForm history={history} />);\n+┊  ┊64┊      const usernameInput = getByTestId('username-input').querySelector('input');\n+┊  ┊65┊      const passwordInput = getByTestId('password-input').querySelector('input');\n+┊  ┊66┊      const signInButton = getByTestId('sign-in-button') as HTMLButtonElement;\n+┊  ┊67┊\n+┊  ┊68┊      fireEvent.change(usernameInput, { target: { value: 'username' } });\n+┊  ┊69┊      fireEvent.change(passwordInput, { target: { value: 'password' } });\n+┊  ┊70┊\n+┊  ┊71┊      await waitForElement(() => usernameInput);\n+┊  ┊72┊      await waitForElement(() => passwordInput);\n+┊  ┊73┊\n+┊  ┊74┊      fireEvent.click(signInButton);\n+┊  ┊75┊\n+┊  ┊76┊      await wait(() =>\n+┊  ┊77┊        expect(history.location.pathname).toEqual('/chats')\n+┊  ┊78┊      );\n+┊  ┊79┊    }\n+┊  ┊80┊  });\n+┊  ┊81┊});\n```\n\n##### Added src&#x2F;components&#x2F;AuthScreen&#x2F;SignInForm.tsx\n```diff\n@@ -0,0 +1,83 @@\n+┊  ┊ 1┊import React from 'react';\n+┊  ┊ 2┊import { useCallback, useState } from 'react';\n+┊  ┊ 3┊import { signIn } from '../../services/auth.service';\n+┊  ┊ 4┊import {\n+┊  ┊ 5┊  SignForm,\n+┊  ┊ 6┊  ActualForm,\n+┊  ┊ 7┊  Legend,\n+┊  ┊ 8┊  Section,\n+┊  ┊ 9┊  TextField,\n+┊  ┊10┊  Button,\n+┊  ┊11┊  ErrorMessage,\n+┊  ┊12┊} from './form-components';\n+┊  ┊13┊import { RouteComponentProps } from 'react-router-dom';\n+┊  ┊14┊\n+┊  ┊15┊const SignInForm: React.FC<RouteComponentProps<any>> = ({ history }) => {\n+┊  ┊16┊  const [username, setUsername] = useState('');\n+┊  ┊17┊  const [password, setPassword] = useState('');\n+┊  ┊18┊  const [error, setError] = useState('');\n+┊  ┊19┊\n+┊  ┊20┊  const onUsernameChange = useCallback(({ target }) => {\n+┊  ┊21┊    setError('');\n+┊  ┊22┊    setUsername(target.value);\n+┊  ┊23┊  }, []);\n+┊  ┊24┊\n+┊  ┊25┊  const onPasswordChange = useCallback(({ target }) => {\n+┊  ┊26┊    setError('');\n+┊  ┊27┊    setPassword(target.value);\n+┊  ┊28┊  }, []);\n+┊  ┊29┊\n+┊  ┊30┊  const maySignIn = useCallback(() => {\n+┊  ┊31┊    return !!(username && password);\n+┊  ┊32┊  }, [username, password]);\n+┊  ┊33┊\n+┊  ┊34┊  const handleSignIn = useCallback(() => {\n+┊  ┊35┊    signIn({ username, password })\n+┊  ┊36┊      .then(() => {\n+┊  ┊37┊        history.replace('/chats')\n+┊  ┊38┊      })\n+┊  ┊39┊      .catch(error => {\n+┊  ┊40┊        setError(error.message || error)\n+┊  ┊41┊      });\n+┊  ┊42┊  }, [username, password, history]);\n+┊  ┊43┊\n+┊  ┊44┊  return (\n+┊  ┊45┊    <SignForm>\n+┊  ┊46┊      <ActualForm>\n+┊  ┊47┊        <Legend>Sign in</Legend>\n+┊  ┊48┊        <Section style={{ width: '100%' }}>\n+┊  ┊49┊          <TextField\n+┊  ┊50┊            data-testid=\"username-input\"\n+┊  ┊51┊            label=\"Username\"\n+┊  ┊52┊            value={username}\n+┊  ┊53┊            onChange={onUsernameChange}\n+┊  ┊54┊            margin=\"normal\"\n+┊  ┊55┊            placeholder=\"Enter your username\"\n+┊  ┊56┊          />\n+┊  ┊57┊          <TextField\n+┊  ┊58┊            data-testid=\"password-input\"\n+┊  ┊59┊            label=\"Password\"\n+┊  ┊60┊            type=\"password\"\n+┊  ┊61┊            value={password}\n+┊  ┊62┊            onChange={onPasswordChange}\n+┊  ┊63┊            margin=\"normal\"\n+┊  ┊64┊            placeholder=\"Enter your password\"\n+┊  ┊65┊          />\n+┊  ┊66┊        </Section>\n+┊  ┊67┊        <Button\n+┊  ┊68┊          data-testid=\"sign-in-button\"\n+┊  ┊69┊          type=\"button\"\n+┊  ┊70┊          color=\"secondary\"\n+┊  ┊71┊          variant=\"contained\"\n+┊  ┊72┊          disabled={!maySignIn()}\n+┊  ┊73┊          onClick={handleSignIn}\n+┊  ┊74┊        >\n+┊  ┊75┊          Sign in\n+┊  ┊76┊        </Button>\n+┊  ┊77┊        <ErrorMessage data-testid=\"error-message\">{error}</ErrorMessage>\n+┊  ┊78┊      </ActualForm>\n+┊  ┊79┊    </SignForm>\n+┊  ┊80┊  );\n+┊  ┊81┊};\n+┊  ┊82┊\n+┊  ┊83┊export default SignInForm;\n```\n\n##### Added src&#x2F;components&#x2F;AuthScreen&#x2F;SignUpForm.test.tsx\n```diff\n@@ -0,0 +1,99 @@\n+┊  ┊ 1┊import { createMemoryHistory } from 'history';\n+┊  ┊ 2┊import React from 'react';\n+┊  ┊ 3┊import { cleanup, render, fireEvent, wait, waitForElement } from 'react-testing-library';\n+┊  ┊ 4┊import SignUpForm from './SignUpForm';\n+┊  ┊ 5┊\n+┊  ┊ 6┊describe('SignUpForm', () => {\n+┊  ┊ 7┊  afterEach(cleanup);\n+┊  ┊ 8┊  afterEach(() => fetch.resetMocks());\n+┊  ┊ 9┊\n+┊  ┊10┊  it('enables sign-up button when filled in', async () => {\n+┊  ┊11┊    const history = createMemoryHistory();\n+┊  ┊12┊\n+┊  ┊13┊    {\n+┊  ┊14┊      const { container, getByTestId } = render(<SignUpForm history={history} />);\n+┊  ┊15┊      const nameInput = getByTestId('name-input').querySelector('input');\n+┊  ┊16┊      const usernameInput = getByTestId('username-input').querySelector('input');\n+┊  ┊17┊      const passwordInput = getByTestId('password-input').querySelector('input');\n+┊  ┊18┊      const passwordConfirmInput = getByTestId('password-confirm-input').querySelector('input');\n+┊  ┊19┊      const signUpButton = getByTestId('sign-up-button') as HTMLButtonElement;\n+┊  ┊20┊\n+┊  ┊21┊      expect(signUpButton.disabled).toEqual(true);\n+┊  ┊22┊\n+┊  ┊23┊      fireEvent.change(nameInput, { target: { value: 'User Name' } });\n+┊  ┊24┊      fireEvent.change(usernameInput, { target: { value: 'username' } });\n+┊  ┊25┊      fireEvent.change(passwordInput, { target: { value: 'password' } });\n+┊  ┊26┊      fireEvent.change(passwordConfirmInput, { target: { value: 'password' } });\n+┊  ┊27┊\n+┊  ┊28┊      await waitForElement(() => nameInput);\n+┊  ┊29┊      await waitForElement(() => usernameInput);\n+┊  ┊30┊      await waitForElement(() => passwordInput);\n+┊  ┊31┊      await waitForElement(() => passwordConfirmInput);\n+┊  ┊32┊\n+┊  ┊33┊      expect(signUpButton.disabled).toEqual(false);\n+┊  ┊34┊    }\n+┊  ┊35┊  });\n+┊  ┊36┊\n+┊  ┊37┊  it('prints server error if input was wrong', async () => {\n+┊  ┊38┊    const history = createMemoryHistory();\n+┊  ┊39┊\n+┊  ┊40┊    fetchMock.mockRejectOnce(new Error('sign-up failed'));\n+┊  ┊41┊\n+┊  ┊42┊    {\n+┊  ┊43┊      const { container, getByTestId } = render(<SignUpForm history={history} />);\n+┊  ┊44┊      const nameInput = getByTestId('name-input').querySelector('input');\n+┊  ┊45┊      const usernameInput = getByTestId('username-input').querySelector('input');\n+┊  ┊46┊      const passwordInput = getByTestId('password-input').querySelector('input');\n+┊  ┊47┊      const passwordConfirmInput = getByTestId('password-confirm-input').querySelector('input');\n+┊  ┊48┊      const signUpButton = getByTestId('sign-up-button') as HTMLButtonElement;\n+┊  ┊49┊      const errorMessage = getByTestId('error-message');\n+┊  ┊50┊\n+┊  ┊51┊      fireEvent.change(nameInput, { target: { value: 'User Name' } });\n+┊  ┊52┊      fireEvent.change(usernameInput, { target: { value: 'username' } });\n+┊  ┊53┊      fireEvent.change(passwordInput, { target: { value: 'password' } });\n+┊  ┊54┊      fireEvent.change(passwordConfirmInput, { target: { value: 'password' } });\n+┊  ┊55┊\n+┊  ┊56┊      await waitForElement(() => nameInput);\n+┊  ┊57┊      await waitForElement(() => usernameInput);\n+┊  ┊58┊      await waitForElement(() => passwordInput);\n+┊  ┊59┊      await waitForElement(() => passwordConfirmInput);\n+┊  ┊60┊\n+┊  ┊61┊      fireEvent.click(signUpButton);\n+┊  ┊62┊\n+┊  ┊63┊      await waitForElement(() => errorMessage);\n+┊  ┊64┊\n+┊  ┊65┊      expect(errorMessage.innerHTML).toEqual('sign-up failed');\n+┊  ┊66┊    }\n+┊  ┊67┊  });\n+┊  ┊68┊\n+┊  ┊69┊  it('navigates to /sign-in if everything went right', async () => {\n+┊  ┊70┊    const history = createMemoryHistory();\n+┊  ┊71┊\n+┊  ┊72┊    fetchMock.mockResponseOnce('success');\n+┊  ┊73┊\n+┊  ┊74┊    {\n+┊  ┊75┊      const { container, getByTestId } = render(<SignUpForm history={history} />);\n+┊  ┊76┊      const nameInput = getByTestId('name-input').querySelector('input');\n+┊  ┊77┊      const usernameInput = getByTestId('username-input').querySelector('input');\n+┊  ┊78┊      const passwordInput = getByTestId('password-input').querySelector('input');\n+┊  ┊79┊      const passwordConfirmInput = getByTestId('password-confirm-input').querySelector('input');\n+┊  ┊80┊      const signUpButton = getByTestId('sign-up-button') as HTMLButtonElement;\n+┊  ┊81┊\n+┊  ┊82┊      fireEvent.change(nameInput, { target: { value: 'User Name' } });\n+┊  ┊83┊      fireEvent.change(usernameInput, { target: { value: 'username' } });\n+┊  ┊84┊      fireEvent.change(passwordInput, { target: { value: 'password' } });\n+┊  ┊85┊      fireEvent.change(passwordConfirmInput, { target: { value: 'password' } });\n+┊  ┊86┊\n+┊  ┊87┊      await waitForElement(() => nameInput);\n+┊  ┊88┊      await waitForElement(() => usernameInput);\n+┊  ┊89┊      await waitForElement(() => passwordInput);\n+┊  ┊90┊      await waitForElement(() => passwordConfirmInput);\n+┊  ┊91┊\n+┊  ┊92┊      fireEvent.click(signUpButton);\n+┊  ┊93┊\n+┊  ┊94┊      await wait(() =>\n+┊  ┊95┊        expect(history.location.pathname).toEqual('/sign-in')\n+┊  ┊96┊      );\n+┊  ┊97┊    }\n+┊  ┊98┊  });\n+┊  ┊99┊});\n```\n\n##### Added src&#x2F;components&#x2F;AuthScreen&#x2F;SignUpForm.tsx\n```diff\n@@ -0,0 +1,126 @@\n+┊   ┊  1┊import React from 'react';\n+┊   ┊  2┊import { useCallback, useState } from 'react';\n+┊   ┊  3┊import { signUp } from '../../services/auth.service';\n+┊   ┊  4┊import {\n+┊   ┊  5┊  SignForm,\n+┊   ┊  6┊  ActualForm,\n+┊   ┊  7┊  Legend,\n+┊   ┊  8┊  Section,\n+┊   ┊  9┊  TextField,\n+┊   ┊ 10┊  Button,\n+┊   ┊ 11┊  ErrorMessage,\n+┊   ┊ 12┊} from './form-components';\n+┊   ┊ 13┊import { RouteComponentProps } from 'react-router-dom';\n+┊   ┊ 14┊\n+┊   ┊ 15┊const SignUpForm: React.FC<RouteComponentProps<any>> = ({ history }) => {\n+┊   ┊ 16┊  const [name, setName] = useState('');\n+┊   ┊ 17┊  const [username, setUsername] = useState('');\n+┊   ┊ 18┊  const [password, setPassword] = useState('');\n+┊   ┊ 19┊  const [passwordConfirm, setPasswordConfirm] = useState('');\n+┊   ┊ 20┊  const [error, setError] = useState('');\n+┊   ┊ 21┊\n+┊   ┊ 22┊  const updateName = useCallback(({ target }) => {\n+┊   ┊ 23┊    setError('');\n+┊   ┊ 24┊    setName(target.value);\n+┊   ┊ 25┊  }, []);\n+┊   ┊ 26┊\n+┊   ┊ 27┊  const updateUsername = useCallback(({ target }) => {\n+┊   ┊ 28┊    setError('');\n+┊   ┊ 29┊    setUsername(target.value);\n+┊   ┊ 30┊  }, []);\n+┊   ┊ 31┊\n+┊   ┊ 32┊  const updatePassword = useCallback(({ target }) => {\n+┊   ┊ 33┊    setError('');\n+┊   ┊ 34┊    setPassword(target.value);\n+┊   ┊ 35┊  }, []);\n+┊   ┊ 36┊\n+┊   ┊ 37┊  const updatePasswordConfirm = useCallback(({ target }) => {\n+┊   ┊ 38┊    setError('');\n+┊   ┊ 39┊    setPasswordConfirm(target.value);\n+┊   ┊ 40┊  }, []);\n+┊   ┊ 41┊\n+┊   ┊ 42┊  const maySignUp = useCallback(() => {\n+┊   ┊ 43┊    return !!(name && username && password && password === passwordConfirm);\n+┊   ┊ 44┊  }, [name, username, password, passwordConfirm]);\n+┊   ┊ 45┊\n+┊   ┊ 46┊  const handleSignUp = useCallback(() => {\n+┊   ┊ 47┊    signUp({ username, password, passwordConfirm, name })\n+┊   ┊ 48┊      .then(() => {\n+┊   ┊ 49┊        history.replace('/sign-in')\n+┊   ┊ 50┊      })\n+┊   ┊ 51┊      .catch(error => {\n+┊   ┊ 52┊        setError(error.message || error)\n+┊   ┊ 53┊      });\n+┊   ┊ 54┊  }, [name, username, password, passwordConfirm, history]);\n+┊   ┊ 55┊\n+┊   ┊ 56┊  return (\n+┊   ┊ 57┊    <SignForm>\n+┊   ┊ 58┊      <ActualForm>\n+┊   ┊ 59┊        <Legend>Sign up</Legend>\n+┊   ┊ 60┊        <Section\n+┊   ┊ 61┊          style={{\n+┊   ┊ 62┊            float: 'left',\n+┊   ┊ 63┊            width: 'calc(50% - 10px)',\n+┊   ┊ 64┊            paddingRight: '10px',\n+┊   ┊ 65┊          }}\n+┊   ┊ 66┊        >\n+┊   ┊ 67┊          <TextField\n+┊   ┊ 68┊            data-testid=\"name-input\"\n+┊   ┊ 69┊            label=\"Name\"\n+┊   ┊ 70┊            value={name}\n+┊   ┊ 71┊            onChange={updateName}\n+┊   ┊ 72┊            autoComplete=\"off\"\n+┊   ┊ 73┊            margin=\"normal\"\n+┊   ┊ 74┊          />\n+┊   ┊ 75┊          <TextField\n+┊   ┊ 76┊            data-testid=\"username-input\"\n+┊   ┊ 77┊            label=\"Username\"\n+┊   ┊ 78┊            value={username}\n+┊   ┊ 79┊            onChange={updateUsername}\n+┊   ┊ 80┊            autoComplete=\"off\"\n+┊   ┊ 81┊            margin=\"normal\"\n+┊   ┊ 82┊          />\n+┊   ┊ 83┊        </Section>\n+┊   ┊ 84┊        <Section\n+┊   ┊ 85┊          style={{\n+┊   ┊ 86┊            float: 'right',\n+┊   ┊ 87┊            width: 'calc(50% - 10px)',\n+┊   ┊ 88┊            paddingLeft: '10px',\n+┊   ┊ 89┊          }}\n+┊   ┊ 90┊        >\n+┊   ┊ 91┊          <TextField\n+┊   ┊ 92┊            data-testid=\"password-input\"\n+┊   ┊ 93┊            label=\"Password\"\n+┊   ┊ 94┊            type=\"password\"\n+┊   ┊ 95┊            value={password}\n+┊   ┊ 96┊            onChange={updatePassword}\n+┊   ┊ 97┊            autoComplete=\"off\"\n+┊   ┊ 98┊            margin=\"normal\"\n+┊   ┊ 99┊          />\n+┊   ┊100┊          <TextField\n+┊   ┊101┊            data-testid=\"password-confirm-input\"\n+┊   ┊102┊            label=\"Confirm password\"\n+┊   ┊103┊            type=\"password\"\n+┊   ┊104┊            value={passwordConfirm}\n+┊   ┊105┊            onChange={updatePasswordConfirm}\n+┊   ┊106┊            autoComplete=\"off\"\n+┊   ┊107┊            margin=\"normal\"\n+┊   ┊108┊          />\n+┊   ┊109┊        </Section>\n+┊   ┊110┊        <Button\n+┊   ┊111┊          data-testid=\"sign-up-button\"\n+┊   ┊112┊          type=\"button\"\n+┊   ┊113┊          color=\"secondary\"\n+┊   ┊114┊          variant=\"contained\"\n+┊   ┊115┊          disabled={!maySignUp()}\n+┊   ┊116┊          onClick={handleSignUp}\n+┊   ┊117┊        >\n+┊   ┊118┊          Sign up\n+┊   ┊119┊        </Button>\n+┊   ┊120┊        <ErrorMessage data-testid=\"error-message\">{error}</ErrorMessage>\n+┊   ┊121┊      </ActualForm>\n+┊   ┊122┊    </SignForm>\n+┊   ┊123┊  );\n+┊   ┊124┊};\n+┊   ┊125┊\n+┊   ┊126┊export default SignUpForm;🚫↵\n```\n\n##### Added src&#x2F;components&#x2F;AuthScreen&#x2F;form-components.ts\n```diff\n@@ -0,0 +1,75 @@\n+┊  ┊ 1┊import MaterialButton from '@material-ui/core/Button';\n+┊  ┊ 2┊import MaterialTextField from '@material-ui/core/TextField';\n+┊  ┊ 3┊import styled from 'styled-components';\n+┊  ┊ 4┊\n+┊  ┊ 5┊export const SignForm = styled.div `\n+┊  ┊ 6┊  height: calc(100% - 265px);\n+┊  ┊ 7┊`;\n+┊  ┊ 8┊\n+┊  ┊ 9┊export const ActualForm = styled.form `\n+┊  ┊10┊  padding: 20px;\n+┊  ┊11┊`;\n+┊  ┊12┊\n+┊  ┊13┊export const Section = styled.div `\n+┊  ┊14┊  padding-bottom: 35px;\n+┊  ┊15┊`;\n+┊  ┊16┊\n+┊  ┊17┊export const Legend = styled.legend `\n+┊  ┊18┊  font-weight: bold;\n+┊  ┊19┊  color: white;\n+┊  ┊20┊`;\n+┊  ┊21┊\n+┊  ┊22┊export const Label = styled.label `\n+┊  ┊23┊  color: white !important;\n+┊  ┊24┊`;\n+┊  ┊25┊\n+┊  ┊26┊export const Input = styled.input `\n+┊  ┊27┊  color: white;\n+┊  ┊28┊\n+┊  ┊29┊  &::placeholder {\n+┊  ┊30┊    color: var(--primary-bg);\n+┊  ┊31┊  }\n+┊  ┊32┊`;\n+┊  ┊33┊\n+┊  ┊34┊export const TextField = styled(MaterialTextField) `\n+┊  ┊35┊  width: 100%;\n+┊  ┊36┊  position: relative;\n+┊  ┊37┊\n+┊  ┊38┊  > div::before {\n+┊  ┊39┊    border-color: white !important;\n+┊  ┊40┊  }\n+┊  ┊41┊\n+┊  ┊42┊  input {\n+┊  ┊43┊    color: white !important;\n+┊  ┊44┊\n+┊  ┊45┊    &::placeholder {\n+┊  ┊46┊      color: var(--primary-bg) !important;\n+┊  ┊47┊    }\n+┊  ┊48┊  }\n+┊  ┊49┊\n+┊  ┊50┊  label {\n+┊  ┊51┊    color: white !important;\n+┊  ┊52┊  }\n+┊  ┊53┊` as typeof MaterialTextField;\n+┊  ┊54┊\n+┊  ┊55┊export const Button = styled(MaterialButton) `\n+┊  ┊56┊  width: 100px;\n+┊  ┊57┊  display: block !important;\n+┊  ┊58┊  margin: auto !important;\n+┊  ┊59┊  background-color: var(--secondary-bg) !important;\n+┊  ┊60┊\n+┊  ┊61┊  &[disabled] {\n+┊  ┊62┊    color: #38a81c;\n+┊  ┊63┊  }\n+┊  ┊64┊\n+┊  ┊65┊  &:not([disabled]) {\n+┊  ┊66┊    color: white;\n+┊  ┊67┊  }\n+┊  ┊68┊` as typeof MaterialButton;\n+┊  ┊69┊\n+┊  ┊70┊export const ErrorMessage = styled.div `\n+┊  ┊71┊  position: fixed;\n+┊  ┊72┊  color: red;\n+┊  ┊73┊  font-size: 15px;\n+┊  ┊74┊  margin-top: 20px;\n+┊  ┊75┊`;\n```\n\n##### Changed src&#x2F;components&#x2F;AuthScreen&#x2F;index.tsx\n```diff\n@@ -1,13 +1,13 @@\n-┊ 1┊  ┊import MaterialButton from '@material-ui/core/Button';\n-┊ 2┊  ┊import MaterialTextField from '@material-ui/core/TextField';\n ┊ 3┊ 1┊import React from 'react';\n-┊ 4┊  ┊import { useCallback, useState } from 'react';\n+┊  ┊ 2┊import { useMemo } from 'react';\n+┊  ┊ 3┊import { Route } from 'react-router-dom';\n ┊ 5┊ 4┊import styled from 'styled-components';\n-┊ 6┊  ┊import { signIn } from '../../services/auth.service';\n+┊  ┊ 5┊import AnimatedSwitch from '../AnimatedSwitch';\n+┊  ┊ 6┊import SignInForm from './SignInForm';\n+┊  ┊ 7┊import SignUpForm from './SignUpForm';\n ┊ 7┊ 8┊import { RouteComponentProps } from 'react-router-dom';\n ┊ 8┊ 9┊\n ┊ 9┊10┊const Container = styled.div `\n-┊10┊  ┊  height: 100%;\n ┊11┊11┊  background: radial-gradient(rgb(34, 65, 67), rgb(17, 48, 50)),\n ┊12┊12┊    url(/assets/chat-background.jpg) no-repeat;\n ┊13┊13┊  background-size: cover;\n```\n```diff\n@@ -40,149 +40,48 @@\n ┊ 40┊ 40┊  bottom: 10px;\n ┊ 41┊ 41┊  left: 10px;\n ┊ 42┊ 42┊\n-┊ 43┊   ┊  a {\n+┊   ┊ 43┊  label {\n ┊ 44┊ 44┊    color: var(--secondary-bg);\n ┊ 45┊ 45┊  }\n ┊ 46┊ 46┊`;\n ┊ 47┊ 47┊\n-┊ 48┊   ┊const SignInForm = styled.div `\n-┊ 49┊   ┊  height: calc(100% - 265px);\n-┊ 50┊   ┊`;\n-┊ 51┊   ┊\n-┊ 52┊   ┊const ActualForm = styled.form `\n-┊ 53┊   ┊  padding: 20px;\n-┊ 54┊   ┊`;\n-┊ 55┊   ┊\n-┊ 56┊   ┊const Section = styled.div `\n-┊ 57┊   ┊  width: 100%;\n-┊ 58┊   ┊  padding-bottom: 35px;\n-┊ 59┊   ┊`;\n-┊ 60┊   ┊\n-┊ 61┊   ┊const Legend = styled.legend `\n-┊ 62┊   ┊  font-weight: bold;\n-┊ 63┊   ┊  color: white;\n-┊ 64┊   ┊`;\n-┊ 65┊   ┊\n-┊ 66┊   ┊// eslint-disable-next-line\n-┊ 67┊   ┊const Label = styled.label `\n-┊ 68┊   ┊  color: white !important;\n-┊ 69┊   ┊`;\n-┊ 70┊   ┊\n-┊ 71┊   ┊// eslint-disable-next-line\n-┊ 72┊   ┊const Input = styled.input `\n-┊ 73┊   ┊  color: white;\n-┊ 74┊   ┊\n-┊ 75┊   ┊  &::placeholder {\n-┊ 76┊   ┊    color: var(--primary-bg);\n-┊ 77┊   ┊  }\n-┊ 78┊   ┊`;\n-┊ 79┊   ┊\n-┊ 80┊   ┊const TextField = styled(MaterialTextField) `\n-┊ 81┊   ┊  width: 100%;\n-┊ 82┊   ┊  position: relative;\n-┊ 83┊   ┊\n-┊ 84┊   ┊  > div::before {\n-┊ 85┊   ┊    border-color: white !important;\n-┊ 86┊   ┊  }\n-┊ 87┊   ┊\n-┊ 88┊   ┊  input {\n-┊ 89┊   ┊    color: white !important;\n-┊ 90┊   ┊\n-┊ 91┊   ┊    &::placeholder {\n-┊ 92┊   ┊      color: var(--primary-bg) !important;\n+┊   ┊ 48┊const AuthScreen: React.FC<RouteComponentProps<any>> = ({ history, location }) => {\n+┊   ┊ 49┊  const alternative = useMemo(() => {\n+┊   ┊ 50┊    if (location.pathname === '/sign-in') {\n+┊   ┊ 51┊      const handleSignUp = () => {\n+┊   ┊ 52┊        history.replace('/sign-up');\n+┊   ┊ 53┊      };\n+┊   ┊ 54┊\n+┊   ┊ 55┊      return (\n+┊   ┊ 56┊        <Alternative>\n+┊   ┊ 57┊          Don't have an account yet? <label onClick={handleSignUp}>Sign up!</label>\n+┊   ┊ 58┊        </Alternative>\n+┊   ┊ 59┊      );\n ┊ 93┊ 60┊    }\n-┊ 94┊   ┊  }\n-┊ 95┊   ┊\n-┊ 96┊   ┊  label {\n-┊ 97┊   ┊    color: white !important;\n-┊ 98┊   ┊  }\n-┊ 99┊   ┊` as typeof MaterialTextField;\n-┊100┊   ┊\n-┊101┊   ┊const Button = styled(MaterialButton) `\n-┊102┊   ┊  width: 100px;\n-┊103┊   ┊  display: block !important;\n-┊104┊   ┊  margin: auto !important;\n-┊105┊   ┊  background-color: var(--secondary-bg) !important;\n-┊106┊   ┊\n-┊107┊   ┊  &[disabled] {\n-┊108┊   ┊    color: #38a81c;\n-┊109┊   ┊  }\n-┊110┊   ┊\n-┊111┊   ┊  &:not([disabled]) {\n-┊112┊   ┊    color: white;\n-┊113┊   ┊  }\n-┊114┊   ┊` as typeof MaterialButton;\n-┊115┊   ┊\n-┊116┊   ┊const AuthScreen: React.FC<RouteComponentProps<any>> = ({ history }) => {\n-┊117┊   ┊  const [username, setUsername] = useState('');\n-┊118┊   ┊  const [password, setPassword] = useState('');\n-┊119┊   ┊  // eslint-disable-next-line\n-┊120┊   ┊  const [error, setError] = useState('');\n-┊121┊   ┊\n-┊122┊   ┊  const onUsernameChange = useCallback(({ target }) => {\n-┊123┊   ┊    setError('');\n-┊124┊   ┊    setUsername(target.value);\n-┊125┊   ┊  }, []);\n-┊126┊   ┊\n-┊127┊   ┊  const onPasswordChange = useCallback(({ target }) => {\n-┊128┊   ┊    setError('');\n-┊129┊   ┊    setPassword(target.value);\n-┊130┊   ┊  }, []);\n-┊131┊   ┊\n-┊132┊   ┊  const maySignIn = useCallback(() => {\n-┊133┊   ┊    return !!(username && password);\n-┊134┊   ┊  }, [username, password]);\n-┊135┊   ┊\n-┊136┊   ┊  const handleSignIn = useCallback(() => {\n-┊137┊   ┊    signIn({ username, password })\n-┊138┊   ┊      .then(() => {\n-┊139┊   ┊        history.push('/chats')\n-┊140┊   ┊      })\n-┊141┊   ┊      .catch(error => {\n-┊142┊   ┊        setError(error.message || error)\n-┊143┊   ┊      });\n-┊144┊   ┊  }, [username, password, history]);\n+┊   ┊ 61┊    else {\n+┊   ┊ 62┊      const handleSignIn = () => {\n+┊   ┊ 63┊        history.replace('/sign-in');\n+┊   ┊ 64┊      };\n+┊   ┊ 65┊\n+┊   ┊ 66┊      return (\n+┊   ┊ 67┊        <Alternative>\n+┊   ┊ 68┊          Already have an accout? <label onClick={handleSignIn}>Sign in!</label>\n+┊   ┊ 69┊        </Alternative>\n+┊   ┊ 70┊      );\n+┊   ┊ 71┊    }\n+┊   ┊ 72┊  }, [location.pathname, history]);\n ┊145┊ 73┊\n ┊146┊ 74┊  return (\n-┊147┊   ┊    <Container>\n-┊148┊   ┊      <Intro>\n+┊   ┊ 75┊    <Container className=\"AuthScreen Screen\">\n+┊   ┊ 76┊      <Intro className=\"AuthScreen-intro\">\n ┊149┊ 77┊        <Icon src=\"assets/whatsapp-icon.png\" className=\"AuthScreen-icon\" />\n ┊150┊ 78┊        <Title className=\"AuthScreen-title\">WhatsApp</Title>\n ┊151┊ 79┊      </Intro>\n-┊152┊   ┊      <SignInForm>\n-┊153┊   ┊        <ActualForm>\n-┊154┊   ┊          <Legend>Sign in</Legend>\n-┊155┊   ┊          <Section>\n-┊156┊   ┊            <TextField\n-┊157┊   ┊              className=\"AuthScreen-text-field\"\n-┊158┊   ┊              label=\"Username\"\n-┊159┊   ┊              value={username}\n-┊160┊   ┊              onChange={onUsernameChange}\n-┊161┊   ┊              margin=\"normal\"\n-┊162┊   ┊              placeholder=\"Enter your username\"\n-┊163┊   ┊            />\n-┊164┊   ┊            <TextField\n-┊165┊   ┊              className=\"AuthScreen-text-field\"\n-┊166┊   ┊              label=\"Password\"\n-┊167┊   ┊              type=\"password\"\n-┊168┊   ┊              value={password}\n-┊169┊   ┊              onChange={onPasswordChange}\n-┊170┊   ┊              margin=\"normal\"\n-┊171┊   ┊              placeholder=\"Enter your password\"\n-┊172┊   ┊            />\n-┊173┊   ┊          </Section>\n-┊174┊   ┊          <Button\n-┊175┊   ┊            data-testid=\"sign-in-button\"\n-┊176┊   ┊            type=\"button\"\n-┊177┊   ┊            color=\"secondary\"\n-┊178┊   ┊            variant=\"contained\"\n-┊179┊   ┊            disabled={!maySignIn()}\n-┊180┊   ┊            onClick={handleSignIn}\n-┊181┊   ┊          >\n-┊182┊   ┊            Sign in\n-┊183┊   ┊          </Button>\n-┊184┊   ┊        </ActualForm>\n-┊185┊   ┊      </SignInForm>\n+┊   ┊ 80┊      <AnimatedSwitch>\n+┊   ┊ 81┊        <Route exact path=\"/sign-in\" component={SignInForm} />\n+┊   ┊ 82┊        <Route exact path=\"/sign-up\" component={SignUpForm} />\n+┊   ┊ 83┊      </AnimatedSwitch>\n+┊   ┊ 84┊      {alternative}\n ┊186┊ 85┊    </Container>\n ┊187┊ 86┊  );\n ┊188┊ 87┊};\n```\n\n[}]: #\n\n> Note how we used the `/sign-(in|up)` pattern to define the `signUp` mutation. This is because the request will be further redirected in the `AuthScreen`.\n\nThe authentication flow is complete! To test it out, you can create a new user, log in with it and start chatting with other users.\n\n------------\n\nTODO: maybe use HttpOnly in cookie\nsave user’s id or data in localStorage so we can guess if a user is logged in or not and later on invalidate it\nwe send a password in its raw form over the wire\nError message: “req.password and req.passwordConfirm don't match” looks odd, should be “Passwords don’t match”\nWhy is `const maySignUp = useCallback(() => {` a useCallback and not useMemo for example? We do use a value there."
          },
          {
            "manualTitle": "Step 14: Migrating to PostgreSQL",
            "stepRevision": "6cc312657b290bb6d7b8659a30736d8def717567",
            "manualView": "**Which Relational Database? And Why?**\n\nWe’ve used to have an in-memory database so far that keeps our entities on memory inside business logic so far. But in a real application we will need a real database system that keeps our data which is seperated from our business logic. In this part we will design our database according to the relational database principles with the benefits of SQL.\n\nWe prefer to use PostgreSQL from now on; because PostgreSQL is a Relational Database implementation that has tables, constraints, triggers, roles, stored procedures and views together with foreign tables from external data sources and many features from NoSQL.\n\n**Database Design**\n\nWhile we are defining our entity types and schema inside our array-based in-memory database, we have already designed the basic parts of them. In this part, we will design our relational database with base and relation tables regarding to them.\n\nInitially we can decide the base fields without relations;\n* User;\n    * `id`\n    * `name`\n    * `username`\n    * `password`\n    * `picture`\n* Message;\n    * `id`\n    * `content`\n    * `created_at`\n* Chat;\n    * `id`\n\nBefore creating tables, we should design our database structure according to [Database Normalization principles](https://www.essentialsql.com/get-ready-to-learn-sql-database-normalization-explained-in-simple-english/) to prevent duplicated data and modification anomalies.\n\nInitially we will have 3 base tables in our database; `user`, `chat`, `message`; and there are some relations between those 3 tables. These relations will be defined in other relation tables together with different primary key and foreign key definitions.\n\nThere are four types of relations in relational databases;\n\n* One to one\n    * This relationship means A entity type can have a relationship with only one instance of B entity type while B entity type can have a relationship with only one instance of A entity type. For example, one user can have only one profile while a profile belongs to only one user.\n* Many to one\n    * This relationship means A entity type can have a relationship with multiple instances of B entity type while B entity type can have a relationship with only one instance of A entity type. For example, a chat can have multiple messages while a message belongs to only one chat. But `many to one` as a word means multiple photos belong to the same chat.\n* One to many\n    * This relationship has the same logic with Many to one. However, `One to many` as a word means a chat can have multiple messages while those messages cannot have multiple chats but only one.\n* Many to many\n    * This relationship means A entity type can have a relationship with multiple instances of B entity type while B entity type can have a relationship with multiple instances of A entity type dependently or independently. For example; a chat can have multiple users, and a user can have multiple chats.\n\nYou can read more about those relations in [here](https://www.techrepublic.com/article/relational-databases-defining-relationships-between-database-tables/).\n\nIn existing entity declarations and schema, we have 6 relationships;\n\n* Message has a One To Many relationship under the name of `chat` inside our schema; so one message can have one chat while one chat can have multiple messages.\n    gql```\n    type Message { chat: Chat }\n    ```\n* Message has another One To Many relationship under the name of `sender`` inside our schema; so one message can have one sender while one sender user can have multiple messages.\n    gql```\n    type Message { sender: User }\n    ```\n* Message has one more One To Many relationship under the name of `recipient`` inside our schema; so one message can have one recipient while one recipient user can have multiple messages.\n    gql```\n    type Message { recipient: User }\n    ```\n* Chat has a One To Many relationship under the name of `messages`, because one chat can have multiple messages while one message can have only one chat. Notice that this relationship is the reversed version of the first relationship in Message.\n    gql```\n    `type Chat { messages: [Message] }\n    ```\n* Chat has another Many To Many relationship under the name of `participants`, because one chat can have multiple participants while a participant can have multiple chats as well.\n    gql```\n    type Chat { participants: [User] }\n    ```\n* User has a Many To Many relationship under the name of `chats`, because one user can have multiple chats, while it has the same situation for chats.\n    gql```\n    type User { chats: [Chat] }\n    ```\n\nSo we should decide the dependencies between each other to add columns and tables to our database.\n\n* User is independent in all relationships, so we will keep its columns as it is\n* Message is dependent to User in two cases so we can define this relationship as two different new foreign keys pointing to User’s id under the columns `sender_user_id`. But we don’t need `recipient_user_id` because `recipient` can be found under Chat’s participants.\n* Chat is also independent because it will be better to keep those relations inside Message.\n* Message is dependent to Chat so we can define this relationship as a new foreign key that points to Chat’s id under the column named `chat_id`.\n* We need to have another table that defines the relationship between multiple chats and users.\n\n> We don’t need to duplicate relations in each entities, because SQL has the power to reverse each relations even if they are defined only in one entity. This is one of the rule of Database Normalization.\n\nFinally we can decide on our tables;\n\n* `chats` table;\n    * `id` ->\n        * `PRIMARY KEY` - `SERIAL`\n        * `SERIAL` will automatically increase the number of the new chat row. Check SQL docs about primary key and auto increment\n* `users` table;\n    * `id` ->\n        * `PRIMARY KEY` - `SERIAL`\n    * `name` ->\n        * `VARCHAR`\n    * `username` ->\n        * `VARCHAR` - `UNIQUE`\n        * `UNIQUE` means this value can exist in this table only once. We use this feature because `username` must be unique in users for each user\n    * `password` ->\n        * `VARCHAR`\n    * `picture` ->\n        * `VARCHAR`\n* `chats_users` table;\n    * `chat_id` ->\n        * `FOREIGN KEY` points to `chat.id` ->\n            * `ON DELETE` -> `CASCADE`.\n            * This means that if chat that has this id is deleted, this row will be deleted automatically as well.\n    * `user_id` ->\n        * FOREIGN KEY points to `user.id` ->\n            * `ON DELETE` -> `CASCADE`.\n* `messages` table;\n    * `id` ->\n        * `PRIMARY KEY` - `SERIAL`\n    * `content` ->\n        * `VARCHAR`\n    * `created_at` ->\n        * `TIMESTAMP` ->\n            * `DEFAULT_VALUE = now()`\n            * This means it will automatically set this to the current timestamp in the new row.\n    * `chat_id` ->\n        * `FOREIGN KEY` points to `chat.id` ->\n            * `ON DELETE` -> `CASCADE`\n            * This means that if chat that has this id is deleted, this row will be deleted automatically as well. So the message will be deleted immediately after the chat is deleted.\n    * `sender_user_id` ->\n        * `FOREIGN_KEY` points to `user.id`\n            * `ON DELETE` -> `CASCADE`\n            * This means that if user that has this id is deleted, this message will be deleted.\n\n> Notice that having a good dependency gives us an opportunity to benefit from `ON_DELETE` feature of SQL. Otherwise, we need to delete each dependent row manually by hand.\n\n**Installing PostgreSQL on your machine**\n\n***Windows / Mac OS X***\n\nYou can download one-click installer for Windows and Mac OS X. During the installation, you must define a password and keep it somewhere safe.\n\n[https://www.enterprisedb.com/downloads/postgres-postgresql-downloads](Download Installer)\n\n***Ubuntu / Debian***\n\nIf you have Debian package manager on your machine, you can install PostgreSQL in a single line in your Bash terminal;\n\n    $ sudo apt-get install postgresql postgresql-contrib\n\n***Other environments***\n\nCheck [https://www.postgresql.org/download/](PostgreSQL website) for installation instructions on other environments.\n\n**Creating Database, Database User and Tables**\n\n> Make sure you have installed PostgreSQL on your environment first!\n\nWe will use Bash terminal in order to access PostgreSQL using superuser;\n\n    $ su - postgres\n\nYou don't need to execute the previous command if you're using Windows. But you have to open the terminal with Administrator privileges.\n\n    $ psql template1\n\nThen we will see the following PostgreSQL console;\n\nbash```\nWelcome to psql 7.4.16, the PostgreSQL interactive terminal.\n\nType:  \\\\copyright for distribution terms\n       \\\\h for help with SQL commands\n       \\\\? for help on internal slash commands\n       \\\\g or terminate with semicolon to execute query\n       \\\\q to quit\n\ntemplate1\n```\n\nSo we can do the following SQL operations in order to create our new user, database and tables;\n\n* Create user for our database\n\n```sql\n    CREATE DATABASE whatsapp;\n```\n\n* Create database\n\n```sql\n    CREATE USER testuser WITH PASSWORD 'testpassword';\n```\n\n* Give permissions to that user\n\n```sql\n    GRANT ALL PRIVILEGES ON DATABASE whatsapp to testuser;\n```\n\n* Connect database\n\n```sql\n    \\connect whatsapp\n```\n\n* Create `chats` table\n\n```sql\n    CREATE TABLE chats(\n        id SERIAL PRIMARY KEY\n    );\n```\n\n* Create `users` table\n\n```sql\n    CREATE TABLE users(\n        id SERIAL PRIMARY KEY,\n        username VARCHAR (50) UNIQUE NOT NULL,\n        name VARCHAR (50) NOT NULL,\n        password VARCHAR (255) NOT NULL,\n        picture VARCHAR (255) NOT NULL\n    );\n```\n\n* Create `chats_users` table\n\n```sql\n    CREATE TABLE chats_users(\n        chat_id INTEGER NOT NULL REFERENCES chats(id) ON DELETE CASCADE,\n        user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE\n    );\n```\n\n* Create messages table;\n\n```sql\n    CREATE TABLE messages(\n        id SERIAL PRIMARY KEY,\n        content VARCHAR (355) NOT NULL,\n        created_at TIMESTAMP NOT NULL DEFAULT NOW(),\n        chat_id INTEGER NOT NULL REFERENCES chats(id) ON DELETE CASCADE,\n        sender_user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE\n    );\n```\n\n* Give access for those tables\n\n```sql\n    GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO testuser;\n    GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA public TO testuser;\n```\n\n**Installing PostgreSQL on our backend project**\n\nAs we are using PostgreSQL, we will use `node-postgres` as our database client in the backend.\n\nFirst install necessary npm packages using yarn;\n\n\t$ yarn add pg\n\nAnd we will also need TypeScript definitions for better development experience;\n\n\t$ yarn add @types/pg --dev\n\nWe will use `sql` template literals (which is way easier and safer than native API) with [this package](https://github.com/felixfbecker/node-sql-template-strings) which allows you to have SQL highlighting in VSCode with (this extension)[https://marketplace.visualstudio.com/items?itemName=forbeslindesay.vscode-sql-template-literal].\n\n\t$ yarn add sql-template-strings\n\n**Connecting to our database**\n\nWe will use connection pooling to prevent connection leaks and benefit from transactions in our complicated SQL queries. [You can read more about the benefits of connection pooling.](https://node-postgres.com/features/pooling)\n\nFirst we need to create a connection pool using our connection credentials;\n\n[{]: <helper> (diffStep 11.2 files=\"db\" module=\"server\")\n\n#### [Server Step 11.2: Connecting to database](https://github.com/Urigo/WhatsApp-Clone-Server/commit/7dfb72f)\n\n##### Changed db.ts\n```diff\n@@ -1,3 +1,5 @@\n+┊ ┊1┊import { Pool } from \"pg\";\n+┊ ┊2┊\n ┊1┊3┊export type User = {\n ┊2┊4┊  id: string\n ┊3┊5┊  name: string\n```\n```diff\n@@ -20,6 +22,14 @@\n ┊20┊22┊  participants: string[]\n ┊21┊23┊}\n ┊22┊24┊\n+┊  ┊25┊export const pool = new Pool({\n+┊  ┊26┊  host: 'localhost',\n+┊  ┊27┊  port: 5432,\n+┊  ┊28┊  user: 'testuser',\n+┊  ┊29┊  password: 'testpassword',\n+┊  ┊30┊  database: 'whatsapp'\n+┊  ┊31┊})\n+┊  ┊32┊\n ┊23┊33┊export const users: User[] = []\n ┊24┊34┊export const messages: Message[] = []\n ┊25┊35┊export const chats: Chat[] = []\n```\n\n[}]: #\n\n**Add Database Client to GraphQL Context**\n\nAfter that, we will request a client from this pool on each network request in our GraphQL context. So we need to update our context interface and context builder function.\n\n[{]: <helper> (diffStep 11.3 files=\"context, index\" module=\"server\")\n\n#### [Server Step 11.3: Add Database Client to GraphQL Context](https://github.com/Urigo/WhatsApp-Clone-Server/commit/3e77d78)\n\n##### Changed context.ts\n```diff\n@@ -1,9 +1,11 @@\n ┊ 1┊ 1┊import { PubSub } from 'apollo-server-express'\n ┊ 2┊ 2┊import { User } from './db'\n ┊ 3┊ 3┊import { Response } from 'express'\n+┊  ┊ 4┊import { PoolClient } from 'pg';\n ┊ 4┊ 5┊\n ┊ 5┊ 6┊export type MyContext = {\n ┊ 6┊ 7┊  pubsub: PubSub,\n ┊ 7┊ 8┊  currentUser: User,\n ┊ 8┊ 9┊  res: Response,\n+┊  ┊10┊  db: PoolClient,\n ┊ 9┊11┊}\n```\n\n##### Changed index.ts\n```diff\n@@ -2,26 +2,42 @@\n ┊ 2┊ 2┊import http from 'http'\n ┊ 3┊ 3┊import jwt from 'jsonwebtoken'\n ┊ 4┊ 4┊import { app } from './app'\n-┊ 5┊  ┊import { users } from './db'\n+┊  ┊ 5┊import { pool } from './db'\n ┊ 6┊ 6┊import { origin, port, secret } from './env'\n ┊ 7┊ 7┊import schema from './schema'\n+┊  ┊ 8┊import { MyContext } from './context';\n+┊  ┊ 9┊import sql from 'sql-template-strings'\n ┊ 8┊10┊\n ┊ 9┊11┊const pubsub = new PubSub()\n ┊10┊12┊const server = new ApolloServer({\n ┊11┊13┊  schema,\n-┊12┊  ┊  context: ({ req, res }) => {\n-┊13┊  ┊    let currentUser;\n+┊  ┊14┊  context: async ({ req, res, connection }: any) => {\n+┊  ┊15┊    let db;\n+┊  ┊16┊\n+┊  ┊17┊    if(!connection) {\n+┊  ┊18┊      db = await pool.connect();\n+┊  ┊19┊    }\n+┊  ┊20┊\n+┊  ┊21┊    let currentUser\n ┊14┊22┊    if (req.cookies.authToken) {\n ┊15┊23┊      const username = jwt.verify(req.cookies.authToken, secret) as string\n-┊16┊  ┊      currentUser = username && users.find(u => u.username === username)\n+┊  ┊24┊      if (username) {\n+┊  ┊25┊        const { rows } =  await pool.query(sql`SELECT * FROM users WHERE username = ${username}`)\n+┊  ┊26┊        currentUser = rows[0]\n+┊  ┊27┊      }\n ┊17┊28┊    }\n-┊18┊  ┊\n ┊19┊29┊    return {\n ┊20┊30┊      currentUser,\n ┊21┊31┊      pubsub,\n ┊22┊32┊      res,\n+┊  ┊33┊      db,\n ┊23┊34┊    }\n ┊24┊35┊  },\n+┊  ┊36┊  formatResponse: (res: any, { context }: { context: MyContext }) => {\n+┊  ┊37┊    context.db.release()\n+┊  ┊38┊\n+┊  ┊39┊    return res\n+┊  ┊40┊  }\n ┊25┊41┊})\n ┊26┊42┊\n ┊27┊43┊server.applyMiddleware({\n```\n\n[}]: #\n\n> However we need to release that client to the pool after the network connection ends to prevent connection leaks. So, let’s use `formatResponse` to do this operation.\n> We don't need connection pooling for subscriptions, because it can cause the connection open in all websocket connection. That's why, we don't request a new client from the pool if it is a subscription.\n\n**Update entity typings**\n\nWe should update our entity typings according to our new database tables and columns.\n\n[{]: <helper> (diffStep 11.4 files=\"db\" module=\"server\")\n\n#### [Server Step 11.4: Update Entity Types](https://github.com/Urigo/WhatsApp-Clone-Server/commit/0b3d3e2)\n\n##### Changed db.ts\n```diff\n@@ -11,15 +11,13 @@\n ┊11┊11┊export type Message = {\n ┊12┊12┊  id: string\n ┊13┊13┊  content: string\n-┊14┊  ┊  createdAt: Date\n-┊15┊  ┊  sender: string\n-┊16┊  ┊  recipient: string\n+┊  ┊14┊  created_at: Date\n+┊  ┊15┊  chat_id: string\n+┊  ┊16┊  sender_user_id: string\n ┊17┊17┊}\n ┊18┊18┊\n ┊19┊19┊export type Chat = {\n ┊20┊20┊  id: string\n-┊21┊  ┊  messages: string[]\n-┊22┊  ┊  participants: string[]\n ┊23┊21┊}\n ┊24┊22┊\n ┊25┊23┊export const pool = new Pool({\n```\n\n[}]: #\n\n**Add Sample Data**\n\nWe need to update the `resetDb` function to add a sample data to our new relational database instead of in-memory database. But we will call `resetDb` if it is asked by using the environmental variable.\n\n[{]: <helper> (diffStep 11.5 files=\"db\" module=\"server\")\n\n#### [Server Step 11.5: Add Sample Data](https://github.com/Urigo/WhatsApp-Clone-Server/commit/934d3c1)\n\n##### Changed db.ts\n```diff\n@@ -1,4 +1,6 @@\n ┊1┊1┊import { Pool } from \"pg\";\n+┊ ┊2┊import sql from 'sql-template-strings'\n+┊ ┊3┊import { resetDb as envResetDb } from './env'\n ┊2┊4┊\n ┊3┊5┊export type User = {\n ┊4┊6┊  id: string\n```\n```diff\n@@ -32,8 +34,11 @@\n ┊32┊34┊export const messages: Message[] = []\n ┊33┊35┊export const chats: Chat[] = []\n ┊34┊36┊\n-┊35┊  ┊export const resetDb = () => {\n-┊36┊  ┊  users.splice(0, Infinity, ...[\n+┊  ┊37┊export const resetDb = async () => {\n+┊  ┊38┊\n+┊  ┊39┊  await pool.query(sql`DELETE FROM users`)\n+┊  ┊40┊\n+┊  ┊41┊  const sampleUsers = [\n ┊37┊42┊    {\n ┊38┊43┊      id: '1',\n ┊39┊44┊      name: 'Ray Edwards',\n```\n```diff\n@@ -69,61 +74,131 @@\n ┊ 69┊ 74┊      password: '$2a$08$6.mbXqsDX82ZZ7q5d8Osb..JrGSsNp4R3IKj7mxgF6YGT0OmMw242', // 555\n ┊ 70┊ 75┊      picture: 'https://randomuser.me/api/portraits/thumb/women/2.jpg',\n ┊ 71┊ 76┊    },\n-┊ 72┊   ┊  ])\n+┊   ┊ 77┊  ]\n+┊   ┊ 78┊\n+┊   ┊ 79┊  for (const sampleUser of sampleUsers) {\n+┊   ┊ 80┊    await pool.query(sql`\n+┊   ┊ 81┊      INSERT INTO users(id, name, username, password, picture)\n+┊   ┊ 82┊      VALUES(${sampleUser.id}, ${sampleUser.name}, ${sampleUser.username}, ${sampleUser.password}, ${sampleUser.picture})\n+┊   ┊ 83┊    `)\n+┊   ┊ 84┊  }\n+┊   ┊ 85┊\n+┊   ┊ 86┊  await pool.query(sql`SELECT setval('users_id_seq', (SELECT max(id) FROM users))`)\n+┊   ┊ 87┊\n+┊   ┊ 88┊  await pool.query(sql`DELETE FROM chats`)\n ┊ 73┊ 89┊\n-┊ 74┊   ┊  messages.splice(0, Infinity, ...[\n+┊   ┊ 90┊  const sampleChats = [\n ┊ 75┊ 91┊    {\n ┊ 76┊ 92┊      id: '1',\n-┊ 77┊   ┊      content: \"You on your way?\",\n-┊ 78┊   ┊      createdAt: new Date(new Date('1-1-2019').getTime() - 60 * 1000 * 1000),\n-┊ 79┊   ┊      sender: '1',\n-┊ 80┊   ┊      recipient: '2',\n ┊ 81┊ 93┊    },\n ┊ 82┊ 94┊    {\n ┊ 83┊ 95┊      id: '2',\n-┊ 84┊   ┊      content: \"Hey, it's me\",\n-┊ 85┊   ┊      createdAt: new Date(new Date('1-1-2019').getTime() - 2 * 60 * 1000 * 1000),\n-┊ 86┊   ┊      sender: '1',\n-┊ 87┊   ┊      recipient: '3',\n ┊ 88┊ 96┊    },\n ┊ 89┊ 97┊    {\n ┊ 90┊ 98┊      id: '3',\n-┊ 91┊   ┊      content: \"I should buy a boat\",\n-┊ 92┊   ┊      createdAt: new Date(new Date('1-1-2019').getTime() - 24 * 60 * 1000 * 1000),\n-┊ 93┊   ┊      sender: '1',\n-┊ 94┊   ┊      recipient: '4',\n ┊ 95┊ 99┊    },\n ┊ 96┊100┊    {\n ┊ 97┊101┊      id: '4',\n-┊ 98┊   ┊      content: \"This is wicked good ice cream.\",\n-┊ 99┊   ┊      createdAt: new Date(new Date('1-1-2019').getTime() - 14 * 24 * 60 * 1000 * 1000),\n-┊100┊   ┊      sender: '1',\n-┊101┊   ┊      recipient: '5',\n ┊102┊102┊    },\n-┊103┊   ┊  ])\n+┊   ┊103┊  ]\n+┊   ┊104┊\n+┊   ┊105┊  for (const sampleChat of sampleChats) {\n+┊   ┊106┊    await pool.query(sql`\n+┊   ┊107┊      INSERT INTO chats(id)\n+┊   ┊108┊      VALUES(${sampleChat.id})\n+┊   ┊109┊    `)\n+┊   ┊110┊  }\n+┊   ┊111┊\n+┊   ┊112┊  await pool.query(sql`SELECT setval('chats_id_seq', (SELECT max(id) FROM chats))`)\n+┊   ┊113┊\n+┊   ┊114┊  await pool.query(sql`DELETE FROM chats_users`)\n ┊104┊115┊\n-┊105┊   ┊  chats.splice(0, Infinity, ...[\n+┊   ┊116┊  const sampleChatsUsers = [\n+┊   ┊117┊    {\n+┊   ┊118┊      chat_id: '1',\n+┊   ┊119┊      user_id: '1',\n+┊   ┊120┊    },\n+┊   ┊121┊    {\n+┊   ┊122┊      chat_id: '1',\n+┊   ┊123┊      user_id: '2',\n+┊   ┊124┊    },\n+┊   ┊125┊    {\n+┊   ┊126┊      chat_id: '2',\n+┊   ┊127┊      user_id: '1',\n+┊   ┊128┊    },\n+┊   ┊129┊    {\n+┊   ┊130┊      chat_id: '2',\n+┊   ┊131┊      user_id: '3',\n+┊   ┊132┊    },\n+┊   ┊133┊    {\n+┊   ┊134┊      chat_id: '3',\n+┊   ┊135┊      user_id: '1',\n+┊   ┊136┊    },\n+┊   ┊137┊    {\n+┊   ┊138┊      chat_id: '3',\n+┊   ┊139┊      user_id: '4',\n+┊   ┊140┊    },\n+┊   ┊141┊    {\n+┊   ┊142┊      chat_id: '4',\n+┊   ┊143┊      user_id: '1',\n+┊   ┊144┊    },\n+┊   ┊145┊    {\n+┊   ┊146┊      chat_id: '4',\n+┊   ┊147┊      user_id: '5',\n+┊   ┊148┊    },\n+┊   ┊149┊  ]\n+┊   ┊150┊\n+┊   ┊151┊  for (const sampleChatUser of sampleChatsUsers) {\n+┊   ┊152┊    await pool.query(sql`\n+┊   ┊153┊      INSERT INTO chats_users(chat_id, user_id)\n+┊   ┊154┊      VALUES(${sampleChatUser.chat_id}, ${sampleChatUser.user_id})\n+┊   ┊155┊    `)\n+┊   ┊156┊  }\n+┊   ┊157┊\n+┊   ┊158┊  await pool.query(sql`DELETE FROM messages`)\n+┊   ┊159┊\n+┊   ┊160┊  const sampleMessages = [\n ┊106┊161┊    {\n ┊107┊162┊      id: '1',\n-┊108┊   ┊      participants: ['1', '2'],\n-┊109┊   ┊      messages: ['1'],\n+┊   ┊163┊      content: \"You on your way?\",\n+┊   ┊164┊      created_at: new Date(new Date('1-1-2019').getTime() - 60 * 1000 * 1000),\n+┊   ┊165┊      chat_id: '1',\n+┊   ┊166┊      sender_user_id: '1',\n ┊110┊167┊    },\n ┊111┊168┊    {\n ┊112┊169┊      id: '2',\n-┊113┊   ┊      participants: ['1', '3'],\n-┊114┊   ┊      messages: ['2'],\n+┊   ┊170┊      content: \"Hey, it's me\",\n+┊   ┊171┊      created_at: new Date(new Date('1-1-2019').getTime() - 2 * 60 * 1000 * 1000),\n+┊   ┊172┊      chat_id: '2',\n+┊   ┊173┊      sender_user_id: '1',\n ┊115┊174┊    },\n ┊116┊175┊    {\n ┊117┊176┊      id: '3',\n-┊118┊   ┊      participants: ['1', '4'],\n-┊119┊   ┊      messages: ['3'],\n+┊   ┊177┊      content: \"I should buy a boat\",\n+┊   ┊178┊      created_at: new Date(new Date('1-1-2019').getTime() - 24 * 60 * 1000 * 1000),\n+┊   ┊179┊      chat_id: '3',\n+┊   ┊180┊      sender_user_id: '1',\n ┊120┊181┊    },\n ┊121┊182┊    {\n ┊122┊183┊      id: '4',\n-┊123┊   ┊      participants: ['1', '5'],\n-┊124┊   ┊      messages: ['4'],\n+┊   ┊184┊      content: \"This is wicked good ice cream.\",\n+┊   ┊185┊      created_at: new Date(new Date('1-1-2019').getTime() - 14 * 24 * 60 * 1000 * 1000),\n+┊   ┊186┊      chat_id: '4',\n+┊   ┊187┊      sender_user_id: '1',\n ┊125┊188┊    },\n-┊126┊   ┊  ])\n+┊   ┊189┊  ]\n+┊   ┊190┊\n+┊   ┊191┊  for (const sampleMessage of sampleMessages) {\n+┊   ┊192┊    await pool.query(sql`\n+┊   ┊193┊      INSERT INTO messages(id, content, created_at, chat_id, sender_user_id)\n+┊   ┊194┊      VALUES(${sampleMessage.id}, ${sampleMessage.content}, ${sampleMessage.created_at}, ${sampleMessage.chat_id}, ${sampleMessage.sender_user_id})\n+┊   ┊195┊    `)\n+┊   ┊196┊  }\n+┊   ┊197┊\n+┊   ┊198┊  await pool.query(sql`SELECT setval('messages_id_seq', (SELECT max(id) FROM messages))`)\n+┊   ┊199┊\n ┊127┊200┊}\n ┊128┊201┊\n-┊129┊   ┊resetDb()🚫↵\n+┊   ┊202┊if (envResetDb) {\n+┊   ┊203┊  resetDb()\n+┊   ┊204┊}\n```\n\n[}]: #\n\n> When you update tables with your own ID values, you have to update `SEQUENCE`; because PostgreSQL calculates the next ID value using `SEQUENCE`s.\n\n**Updating Resolvers**\n\nWe will benefit from transactions for complicated SQL queries in mutation. Transactions will help us to rollback our changes if there is an exception in the middle of our operations.\n\n[{]: <helper> (diffStep 11.6 files=\"resolvers\" module=\"server\")\n\n#### [Server Step 11.6: Updating Resolvers with SQL](https://github.com/Urigo/WhatsApp-Clone-Server/commit/472470b)\n\n##### Changed schema&#x2F;resolvers.ts\n```diff\n@@ -1,70 +1,102 @@\n ┊  1┊  1┊import { withFilter } from 'apollo-server-express'\n ┊  2┊  2┊import { GraphQLDateTime } from 'graphql-iso-date'\n-┊  3┊   ┊import { User, Message, Chat, chats, messages, users } from '../db'\n+┊   ┊  3┊import { Message, Chat, pool } from '../db'\n ┊  4┊  4┊import { Resolvers } from '../types/graphql'\n ┊  5┊  5┊import { secret, expiration } from '../env'\n ┊  6┊  6┊import bcrypt from 'bcrypt'\n ┊  7┊  7┊import jwt from 'jsonwebtoken'\n ┊  8┊  8┊import { validateLength, validatePassword } from '../validators';\n+┊   ┊  9┊import sql from 'sql-template-strings'\n ┊  9┊ 10┊\n ┊ 10┊ 11┊const resolvers: Resolvers = {\n ┊ 11┊ 12┊  Date: GraphQLDateTime,\n ┊ 12┊ 13┊\n ┊ 13┊ 14┊  Message: {\n-┊ 14┊   ┊    chat(message) {\n-┊ 15┊   ┊      return chats.find(c => c.messages.some(m => m === message.id)) || null\n+┊   ┊ 15┊    createdAt(message) {\n+┊   ┊ 16┊      return new Date(message.created_at)\n ┊ 16┊ 17┊    },\n ┊ 17┊ 18┊\n-┊ 18┊   ┊    sender(message) {\n-┊ 19┊   ┊      return users.find(u => u.id === message.sender) || null\n+┊   ┊ 19┊    async chat(message, args, { db }) {\n+┊   ┊ 20┊      const { rows } = await db.query(sql`\n+┊   ┊ 21┊        SELECT * FROM chats WHERE id = ${message.chat_id}\n+┊   ┊ 22┊      `)\n+┊   ┊ 23┊      return rows[0] || null\n ┊ 20┊ 24┊    },\n ┊ 21┊ 25┊\n-┊ 22┊   ┊    recipient(message) {\n-┊ 23┊   ┊      return users.find(u => u.id === message.recipient) || null\n+┊   ┊ 26┊    async sender(message, args, { db }) {\n+┊   ┊ 27┊      const { rows } = await db.query(sql`\n+┊   ┊ 28┊        SELECT * FROM users WHERE id = ${message.sender_user_id}\n+┊   ┊ 29┊      `)\n+┊   ┊ 30┊      return rows[0] || null\n+┊   ┊ 31┊    },\n+┊   ┊ 32┊\n+┊   ┊ 33┊    async recipient(message, args, { db }) {\n+┊   ┊ 34┊      const { rows } = await db.query(sql`\n+┊   ┊ 35┊        SELECT users.* FROM users, chats_users\n+┊   ┊ 36┊        WHERE chats_users.user_id != ${message.sender_user_id}\n+┊   ┊ 37┊        AND chats_users.chat_id = ${message.chat_id}\n+┊   ┊ 38┊      `)\n+┊   ┊ 39┊      return rows[0] || null\n ┊ 24┊ 40┊    },\n ┊ 25┊ 41┊\n ┊ 26┊ 42┊    isMine(message, args, { currentUser }) {\n-┊ 27┊   ┊      return message.sender === currentUser.id\n+┊   ┊ 43┊      return message.sender_user_id === currentUser.id\n ┊ 28┊ 44┊    },\n ┊ 29┊ 45┊  },\n ┊ 30┊ 46┊\n ┊ 31┊ 47┊  Chat: {\n-┊ 32┊   ┊    name(chat, args, { currentUser }) {\n+┊   ┊ 48┊    async name(chat, args, { currentUser, db }) {\n ┊ 33┊ 49┊      if (!currentUser) return null\n ┊ 34┊ 50┊\n-┊ 35┊   ┊      const participantId = chat.participants.find(p => p !== currentUser.id)\n-┊ 36┊   ┊\n-┊ 37┊   ┊      if (!participantId) return null\n+┊   ┊ 51┊      const { rows } = await db.query(sql`\n+┊   ┊ 52┊        SELECT users.* FROM users, chats_users\n+┊   ┊ 53┊        WHERE users.id != ${currentUser.id}\n+┊   ┊ 54┊        AND users.id = chats_users.user_id\n+┊   ┊ 55┊        AND chats_users.chat_id = ${chat.id}`)\n ┊ 38┊ 56┊\n-┊ 39┊   ┊      const participant = users.find(u => u.id === participantId)\n+┊   ┊ 57┊      const participant = rows[0]\n ┊ 40┊ 58┊\n ┊ 41┊ 59┊      return participant ? participant.name : null\n ┊ 42┊ 60┊    },\n ┊ 43┊ 61┊\n-┊ 44┊   ┊    picture(chat, args, { currentUser }) {\n+┊   ┊ 62┊    async picture(chat, args, { currentUser, db }) {\n ┊ 45┊ 63┊      if (!currentUser) return null\n ┊ 46┊ 64┊\n-┊ 47┊   ┊      const participantId = chat.participants.find(p => p !== currentUser.id)\n+┊   ┊ 65┊      const { rows } = await db.query(sql`\n+┊   ┊ 66┊        SELECT users.* FROM users, chats_users\n+┊   ┊ 67┊        WHERE users.id != ${currentUser.id}\n+┊   ┊ 68┊        AND users.id = chats_users.user_id\n+┊   ┊ 69┊        AND chats_users.chat_id = ${chat.id}`)\n ┊ 48┊ 70┊\n-┊ 49┊   ┊      if (!participantId) return null\n-┊ 50┊   ┊\n-┊ 51┊   ┊      const participant = users.find(u => u.id === participantId)\n+┊   ┊ 71┊      const participant = rows[0]\n ┊ 52┊ 72┊\n ┊ 53┊ 73┊      return participant ? participant.picture : null\n ┊ 54┊ 74┊    },\n ┊ 55┊ 75┊\n-┊ 56┊   ┊    messages(chat) {\n-┊ 57┊   ┊      return messages.filter(m => chat.messages.includes(m.id))\n+┊   ┊ 76┊    async messages(chat, args, { db }) {\n+┊   ┊ 77┊      const { rows } = await db.query(sql`SELECT * FROM messages WHERE chat_id = ${chat.id}`)\n+┊   ┊ 78┊\n+┊   ┊ 79┊      return rows\n ┊ 58┊ 80┊    },\n ┊ 59┊ 81┊\n-┊ 60┊   ┊    lastMessage(chat) {\n-┊ 61┊   ┊      const lastMessage = chat.messages[chat.messages.length - 1]\n+┊   ┊ 82┊    async lastMessage(chat, args, { db }) {\n+┊   ┊ 83┊      const { rows } = await db.query(sql`\n+┊   ┊ 84┊        SELECT * FROM messages\n+┊   ┊ 85┊        WHERE chat_id = ${chat.id}\n+┊   ┊ 86┊        ORDER BY created_at DESC\n+┊   ┊ 87┊        LIMIT 1`)\n ┊ 62┊ 88┊\n-┊ 63┊   ┊      return messages.find(m => m.id === lastMessage) || null\n+┊   ┊ 89┊      return rows[0]\n ┊ 64┊ 90┊    },\n ┊ 65┊ 91┊\n-┊ 66┊   ┊    participants(chat) {\n-┊ 67┊   ┊      return chat.participants.map(p => users.find(u => u.id === p)).filter(Boolean) as User[]\n+┊   ┊ 92┊    async participants(chat, args, { db }) {\n+┊   ┊ 93┊      const { rows } = await db.query(sql`\n+┊   ┊ 94┊        SELECT users.* FROM users, chats_users\n+┊   ┊ 95┊        WHERE chats_users.chat_id = ${chat.id}\n+┊   ┊ 96┊        AND chats_users.user_id = users.id\n+┊   ┊ 97┊      `)\n+┊   ┊ 98┊\n+┊   ┊ 99┊      return rows\n ┊ 68┊100┊    },\n ┊ 69┊101┊  },\n ┊ 70┊102┊\n```\n```diff\n@@ -73,36 +105,50 @@\n ┊ 73┊105┊      return currentUser || null\n ┊ 74┊106┊    },\n ┊ 75┊107┊\n-┊ 76┊   ┊    chats(root, args, { currentUser }) {\n+┊   ┊108┊    async chats(root, args, { currentUser, db }) {\n ┊ 77┊109┊      if (!currentUser) return []\n ┊ 78┊110┊\n-┊ 79┊   ┊      return chats.filter(c => c.participants.includes(currentUser.id))\n+┊   ┊111┊      const { rows } = await db.query(sql`\n+┊   ┊112┊        SELECT chats.* FROM chats, chats_users\n+┊   ┊113┊        WHERE chats.id = chats_users.chat_id\n+┊   ┊114┊        AND chats_users.user_id = ${currentUser.id}\n+┊   ┊115┊      `)\n+┊   ┊116┊\n+┊   ┊117┊      return rows\n ┊ 80┊118┊    },\n ┊ 81┊119┊\n-┊ 82┊   ┊    chat(root, { chatId }, { currentUser }) {\n+┊   ┊120┊    async chat(root, { chatId }, { currentUser, db }) {\n ┊ 83┊121┊      if (!currentUser) return null\n ┊ 84┊122┊\n-┊ 85┊   ┊      const chat = chats.find(c => c.id === chatId)\n-┊ 86┊   ┊\n-┊ 87┊   ┊      if (!chat) return null\n-┊ 88┊   ┊\n-┊ 89┊   ┊      return chat.participants.includes(currentUser.id) ? chat : null\n+┊   ┊123┊      const { rows } = await db.query(sql`\n+┊   ┊124┊        SELECT chats.* FROM chats, chats_users\n+┊   ┊125┊        WHERE chats_users.chat_id = ${chatId}\n+┊   ┊126┊        AND chats.id = chats_users.chat_id\n+┊   ┊127┊        AND chats_users.user_id = ${currentUser.id}\n+┊   ┊128┊      `)\n+┊   ┊129┊\n+┊   ┊130┊      return rows[0] ? rows[0] : null\n ┊ 90┊131┊    },\n ┊ 91┊132┊\n-┊ 92┊   ┊    users(root, args, { currentUser }) {\n+┊   ┊133┊    async users(root, args, { currentUser, db }) {\n ┊ 93┊134┊      if (!currentUser) return []\n ┊ 94┊135┊\n-┊ 95┊   ┊      return users.filter(u => u.id !== currentUser.id)\n+┊   ┊136┊      const { rows } = await db.query(sql`\n+┊   ┊137┊        SELECT * FROM users WHERE users.id != ${currentUser.id}\n+┊   ┊138┊      `)\n+┊   ┊139┊\n+┊   ┊140┊      return rows\n ┊ 96┊141┊    },\n ┊ 97┊142┊  },\n ┊ 98┊143┊\n ┊ 99┊144┊  Mutation: {\n-┊100┊   ┊    signIn(root, { username, password }, { res }) {\n ┊101┊145┊\n-┊102┊   ┊      const user = users.find(u => u.username === username)\n+┊   ┊146┊    async signIn(root, { username, password }, { db, res }) {\n+┊   ┊147┊      const { rows } = await db.query(sql`SELECT * FROM users WHERE username = ${username}`)\n+┊   ┊148┊      const user = rows[0]\n ┊103┊149┊\n ┊104┊150┊      if (!user) {\n-┊105┊   ┊        throw new Error('user not found')\n+┊   ┊151┊        throw new Error('user not found');\n ┊106┊152┊      }\n ┊107┊153┊\n ┊108┊154┊      const passwordsMatch = bcrypt.compareSync(password, user.password)\n```\n```diff\n@@ -112,130 +158,143 @@\n ┊112┊158┊      }\n ┊113┊159┊\n ┊114┊160┊      const authToken = jwt.sign(username, secret)\n-┊115┊   ┊\n+┊   ┊161┊\n ┊116┊162┊      res.cookie('authToken', authToken, { maxAge: expiration })\n ┊117┊163┊\n ┊118┊164┊      return user;\n ┊119┊165┊    },\n-┊120┊   ┊\n-┊121┊   ┊    signUp(root, { name, username, password, passwordConfirm }) {\n-┊122┊   ┊\n+┊   ┊166┊\n+┊   ┊167┊    async signUp(root, { name, username, password, passwordConfirm }, { db }) {\n ┊123┊168┊      validateLength('req.name', name, 3, 50)\n ┊124┊169┊      validateLength('req.username', name, 3, 18)\n ┊125┊170┊      validatePassword('req.password', password)\n-┊126┊   ┊\n+┊   ┊171┊\n ┊127┊172┊      if (password !== passwordConfirm) {\n ┊128┊173┊        throw Error(\"req.password and req.passwordConfirm don't match\")\n ┊129┊174┊      }\n-┊130┊   ┊\n-┊131┊   ┊      if (users.some(u => u.username === username)) {\n+┊   ┊175┊\n+┊   ┊176┊      const existingUserQuery = await db.query(sql`SELECT * FROM users WHERE username = ${username}`)\n+┊   ┊177┊      if (existingUserQuery.rows[0]) {\n ┊132┊178┊        throw Error(\"username already exists\")\n ┊133┊179┊      }\n-┊134┊   ┊\n+┊   ┊180┊\n ┊135┊181┊      const passwordHash = bcrypt.hashSync(password, bcrypt.genSaltSync(8))\n+┊   ┊182┊\n+┊   ┊183┊      const createdUserQuery = await db.query(sql`\n+┊   ┊184┊        INSERT INTO users(password, picture, username, name)\n+┊   ┊185┊        VALUES(${passwordHash}, '', ${username}, ${name})\n+┊   ┊186┊        RETURNING *\n+┊   ┊187┊      `)\n+┊   ┊188┊\n+┊   ┊189┊      const user = createdUserQuery.rows[0]\n+┊   ┊190┊\n+┊   ┊191┊      return user;\n ┊136┊192┊\n-┊137┊   ┊      const user: User = {\n-┊138┊   ┊        id: String(users.length + 1),\n-┊139┊   ┊        password: passwordHash,\n-┊140┊   ┊        picture: '',\n-┊141┊   ┊        username,\n-┊142┊   ┊        name,\n-┊143┊   ┊      }\n-┊144┊   ┊\n-┊145┊   ┊      users.push(user)\n-┊146┊   ┊\n-┊147┊   ┊      return user\n ┊148┊193┊    },\n ┊149┊194┊\n-┊150┊   ┊    addMessage(root, { chatId, content }, { currentUser, pubsub }) {\n+┊   ┊195┊    async addMessage(root, { chatId, content }, { currentUser, pubsub, db }) {\n ┊151┊196┊      if (!currentUser) return null\n ┊152┊197┊\n-┊153┊   ┊      const chatIndex = chats.findIndex(c => c.id === chatId)\n-┊154┊   ┊\n-┊155┊   ┊      if (chatIndex === -1) return null\n-┊156┊   ┊\n-┊157┊   ┊      const chat = chats[chatIndex]\n-┊158┊   ┊\n-┊159┊   ┊      if (!chat.participants.includes(currentUser.id)) return null\n-┊160┊   ┊\n-┊161┊   ┊      const recentMessage = messages[messages.length - 1]\n-┊162┊   ┊      const messageId = String(Number(recentMessage.id) + 1)\n-┊163┊   ┊      const message: Message = {\n-┊164┊   ┊        id: messageId,\n-┊165┊   ┊        createdAt: new Date(),\n-┊166┊   ┊        sender: currentUser.id,\n-┊167┊   ┊        recipient: chat.participants.find(p => p !== currentUser.id) as string,\n-┊168┊   ┊        content,\n-┊169┊   ┊      }\n+┊   ┊198┊      const { rows } = await db.query(sql`\n+┊   ┊199┊        INSERT INTO messages(chat_id, sender_user_id, content)\n+┊   ┊200┊        VALUES(${chatId}, ${currentUser.id}, ${content})\n+┊   ┊201┊        RETURNING *\n+┊   ┊202┊      `)\n ┊170┊203┊\n-┊171┊   ┊      messages.push(message)\n-┊172┊   ┊      chat.messages.push(messageId)\n-┊173┊   ┊      // The chat will appear at the top of the ChatsList component\n-┊174┊   ┊      chats.splice(chatIndex, 1)\n-┊175┊   ┊      chats.unshift(chat)\n+┊   ┊204┊      const messageAdded = rows[0]\n ┊176┊205┊\n ┊177┊206┊      pubsub.publish('messageAdded', {\n-┊178┊   ┊        messageAdded: message,\n+┊   ┊207┊        messageAdded,\n ┊179┊208┊      })\n ┊180┊209┊\n-┊181┊   ┊      return message\n+┊   ┊210┊      return messageAdded\n ┊182┊211┊    },\n ┊183┊212┊\n-┊184┊   ┊    addChat(root, { recipientId }, { currentUser, pubsub }) {\n+┊   ┊213┊    async addChat(root, { recipientId }, { currentUser, pubsub, db }) {\n ┊185┊214┊      if (!currentUser) return null\n-┊186┊   ┊      if (!users.some(u => u.id === recipientId)) return null\n ┊187┊215┊\n-┊188┊   ┊      let chat = chats.find(c =>\n-┊189┊   ┊        c.participants.includes(currentUser.id) &&\n-┊190┊   ┊        c.participants.includes(recipientId)\n-┊191┊   ┊      )\n+┊   ┊216┊      const { rows } = await db.query(sql`\n+┊   ┊217┊        SELECT chats.* FROM chats, (SELECT * FROM chats_users WHERE user_id = ${currentUser.id}) AS chats_of_current_user, chats_users\n+┊   ┊218┊        WHERE chats_users.chat_id = chats_of_current_user.chat_id\n+┊   ┊219┊        AND chats.id = chats_users.chat_id\n+┊   ┊220┊        AND chats_users.user_id = ${recipientId}\n+┊   ┊221┊      `)\n ┊192┊222┊\n-┊193┊   ┊      if (chat) return chat\n+┊   ┊223┊      // If there is already a chat between these two users, return it\n+┊   ┊224┊      if (rows[0]) {\n+┊   ┊225┊        return rows[0]\n+┊   ┊226┊      }\n ┊194┊227┊\n-┊195┊   ┊      const chatsIds = chats.map(c => Number(c.id))\n+┊   ┊228┊      try {\n+┊   ┊229┊        await db.query('BEGIN')\n ┊196┊230┊\n-┊197┊   ┊      chat = {\n-┊198┊   ┊        id: String(Math.max(...chatsIds) + 1),\n-┊199┊   ┊        participants: [currentUser.id, recipientId],\n-┊200┊   ┊        messages: [],\n-┊201┊   ┊      }\n+┊   ┊231┊        const { rows } = await db.query(sql`\n+┊   ┊232┊          INSERT INTO chats\n+┊   ┊233┊          DEFAULT VALUES\n+┊   ┊234┊          RETURNING *\n+┊   ┊235┊        `)\n ┊202┊236┊\n-┊203┊   ┊      chats.push(chat)\n+┊   ┊237┊        const chatAdded = rows[0]\n ┊204┊238┊\n-┊205┊   ┊      pubsub.publish('chatAdded', {\n-┊206┊   ┊        chatAdded: chat\n-┊207┊   ┊      })\n+┊   ┊239┊        await db.query(sql`\n+┊   ┊240┊          INSERT INTO chats_users(chat_id, user_id)\n+┊   ┊241┊          VALUES(${chatAdded.id}, ${currentUser.id})\n+┊   ┊242┊        `)\n ┊208┊243┊\n-┊209┊   ┊      return chat\n-┊210┊   ┊    },\n+┊   ┊244┊        await db.query(sql`\n+┊   ┊245┊          INSERT INTO chats_users(chat_id, user_id)\n+┊   ┊246┊          VALUES(${chatAdded.id}, ${recipientId})\n+┊   ┊247┊        `)\n ┊211┊248┊\n-┊212┊   ┊    removeChat(root, { chatId }, { currentUser, pubsub }) {\n-┊213┊   ┊      if (!currentUser) return null\n+┊   ┊249┊        await db.query('COMMIT')\n ┊214┊250┊\n-┊215┊   ┊      const chatIndex = chats.findIndex(c => c.id === chatId)\n+┊   ┊251┊        pubsub.publish('chatAdded', {\n+┊   ┊252┊          chatAdded\n+┊   ┊253┊        })\n ┊216┊254┊\n-┊217┊   ┊      if (chatIndex === -1) return null\n+┊   ┊255┊        return chatAdded\n+┊   ┊256┊      } catch(e) {\n+┊   ┊257┊        await db.query('ROLLBACK')\n+┊   ┊258┊        throw e\n+┊   ┊259┊      }\n+┊   ┊260┊    },\n+┊   ┊261┊\n+┊   ┊262┊    async removeChat(root, { chatId }, { currentUser, pubsub, db }) {\n+┊   ┊263┊      if (!currentUser) return null\n ┊218┊264┊\n-┊219┊   ┊      const chat = chats[chatIndex]\n+┊   ┊265┊      try {\n+┊   ┊266┊        await db.query('BEGIN')\n ┊220┊267┊\n-┊221┊   ┊      if (!chat.participants.some(p => p === currentUser.id)) return null\n+┊   ┊268┊        const { rows } = await db.query(sql`\n+┊   ┊269┊          SELECT chats.* FROM chats, chats_users\n+┊   ┊270┊          WHERE id = ${chatId}\n+┊   ┊271┊          AND chats.id = chats_users.chat_id\n+┊   ┊272┊          AND chats_users.user_id = ${currentUser.id}\n+┊   ┊273┊        `)\n ┊222┊274┊\n-┊223┊   ┊      chat.messages.forEach((chatMessage) => {\n-┊224┊   ┊        const chatMessageIndex = messages.findIndex(m => m.id === chatMessage)\n+┊   ┊275┊        const chat = rows[0]\n ┊225┊276┊\n-┊226┊   ┊        if (chatMessageIndex !== -1) {\n-┊227┊   ┊          messages.splice(chatMessageIndex, 1)\n+┊   ┊277┊        if (!chat) {\n+┊   ┊278┊          await db.query('ROLLBACK')\n+┊   ┊279┊          return null\n ┊228┊280┊        }\n-┊229┊   ┊      })\n ┊230┊281┊\n-┊231┊   ┊      chats.splice(chatIndex, 1)\n+┊   ┊282┊        await db.query(sql`\n+┊   ┊283┊          DELETE FROM chats WHERE chats.id = ${chatId}\n+┊   ┊284┊        `)\n ┊232┊285┊\n-┊233┊   ┊      pubsub.publish('chatRemoved', {\n-┊234┊   ┊        chatRemoved: chat.id,\n-┊235┊   ┊        targetChat: chat,\n-┊236┊   ┊      })\n+┊   ┊286┊        pubsub.publish('chatRemoved', {\n+┊   ┊287┊          chatRemoved: chat.id,\n+┊   ┊288┊          targetChat: chat,\n+┊   ┊289┊        })\n ┊237┊290┊\n-┊238┊   ┊      return chatId\n+┊   ┊291┊        await db.query('COMMIT')\n+┊   ┊292┊\n+┊   ┊293┊        return chatId\n+┊   ┊294┊      } catch(e) {\n+┊   ┊295┊        await db.query('ROLLBACK')\n+┊   ┊296┊        throw e\n+┊   ┊297┊      }\n ┊239┊298┊    }\n ┊240┊299┊  },\n ┊241┊300┊\n```\n```diff\n@@ -243,13 +302,15 @@\n ┊243┊302┊    messageAdded: {\n ┊244┊303┊      subscribe: withFilter(\n ┊245┊304┊        (root, args, { pubsub }) => pubsub.asyncIterator('messageAdded'),\n-┊246┊   ┊        ({ messageAdded }, args, { currentUser }) => {\n+┊   ┊305┊        async ({ messageAdded }: { messageAdded: Message }, args, { currentUser }) => {\n ┊247┊306┊          if (!currentUser) return false\n ┊248┊307┊\n-┊249┊   ┊          return [\n-┊250┊   ┊            messageAdded.sender,\n-┊251┊   ┊            messageAdded.recipient,\n-┊252┊   ┊          ].includes(currentUser.id)\n+┊   ┊308┊          const { rows } = await pool.query(sql`\n+┊   ┊309┊            SELECT * FROM chats_users\n+┊   ┊310┊            WHERE chat_id = ${messageAdded.chat_id}\n+┊   ┊311┊            AND user_id = ${currentUser.id}`)\n+┊   ┊312┊\n+┊   ┊313┊          return !!rows.length\n ┊253┊314┊        },\n ┊254┊315┊      )\n ┊255┊316┊    },\n```\n```diff\n@@ -257,10 +318,15 @@\n ┊257┊318┊    chatAdded: {\n ┊258┊319┊      subscribe: withFilter(\n ┊259┊320┊        (root, args, { pubsub }) => pubsub.asyncIterator('chatAdded'),\n-┊260┊   ┊        ({ chatAdded }: { chatAdded: Chat }, args, { currentUser }) => {\n+┊   ┊321┊        async ({ chatAdded }: { chatAdded: Chat }, args, { currentUser }) => {\n ┊261┊322┊          if (!currentUser) return false\n ┊262┊323┊\n-┊263┊   ┊          return chatAdded.participants.some(p => p === currentUser.id)\n+┊   ┊324┊          const { rows } = await pool.query(sql`\n+┊   ┊325┊            SELECT * FROM chats_users\n+┊   ┊326┊            WHERE chat_id = ${chatAdded.id}\n+┊   ┊327┊            AND user_id = ${currentUser.id}`)\n+┊   ┊328┊\n+┊   ┊329┊          return !!rows.length\n ┊264┊330┊        },\n ┊265┊331┊      )\n ┊266┊332┊    },\n```\n```diff\n@@ -268,10 +334,15 @@\n ┊268┊334┊    chatRemoved: {\n ┊269┊335┊      subscribe: withFilter(\n ┊270┊336┊        (root, args, { pubsub }) => pubsub.asyncIterator('chatRemoved'),\n-┊271┊   ┊        ({ targetChat }: { targetChat: Chat }, args, { currentUser }) => {\n+┊   ┊337┊        async ({ targetChat }: { targetChat: Chat }, args, { currentUser }) => {\n ┊272┊338┊          if (!currentUser) return false\n ┊273┊339┊\n-┊274┊   ┊          return targetChat.participants.some(p => p === currentUser.id)\n+┊   ┊340┊          const { rows } = await pool.query(sql`\n+┊   ┊341┊            SELECT * FROM chats_users\n+┊   ┊342┊            WHERE chat_id = ${targetChat.id}\n+┊   ┊343┊            AND user_id = ${currentUser.id}`)\n+┊   ┊344┊\n+┊   ┊345┊          return !!rows.length\n ┊275┊346┊        },\n ┊276┊347┊      )\n ┊277┊348┊    }\n```\n\n[}]: #\n\n> We use `pool` itself instead of `db` from the context in the subscriptions. Remember we don't request for a new client from the pool in subscriptions.\n> If you use `pool.query`, it just opens a connection, does that operation and set the client free. In that case, you wouldn't be able to work with transactions which is not need in GraphQL Subscriptions.\n\n**Updating Subscriptions w/ PostgreSQL PubSub mechanism**\n\nApollo’s default PubSub mechanism is not for production usage. So, we will use PostgreSQL’s notify/listen for our PubSub mechanism in GraphQL Subscriptions.\n\nInstall the necessary packages;\n\n\t$ yarn add graphql-postgres-subscriptions\n\n[{]: <helper> (diffStep 11.7 files=\"index\" module=\"server\")\n\n#### [Server Step 11.7: Updating Subscriptions w/ PostgreSQL PubSub mechanism](https://github.com/Urigo/WhatsApp-Clone-Server/commit/2ae7573)\n\n##### Changed index.ts\n```diff\n@@ -1,4 +1,4 @@\n-┊1┊ ┊import { ApolloServer, gql, PubSub } from 'apollo-server-express'\n+┊ ┊1┊import { ApolloServer } from 'apollo-server-express'\n ┊2┊2┊import http from 'http'\n ┊3┊3┊import jwt from 'jsonwebtoken'\n ┊4┊4┊import { app } from './app'\n```\n```diff\n@@ -7,8 +7,15 @@\n ┊ 7┊ 7┊import schema from './schema'\n ┊ 8┊ 8┊import { MyContext } from './context';\n ┊ 9┊ 9┊import sql from 'sql-template-strings'\n+┊  ┊10┊const { PostgresPubSub } = require('graphql-postgres-subscriptions')\n ┊10┊11┊\n-┊11┊  ┊const pubsub = new PubSub()\n+┊  ┊12┊const pubsub = new PostgresPubSub({\n+┊  ┊13┊  host: 'localhost',\n+┊  ┊14┊  port: 5432,\n+┊  ┊15┊  user: 'testuser',\n+┊  ┊16┊  password: 'testpassword',\n+┊  ┊17┊  database: 'whatsapp'\n+┊  ┊18┊})\n ┊12┊19┊const server = new ApolloServer({\n ┊13┊20┊  schema,\n ┊14┊21┊  context: async ({ req, res, connection }: any) => {\n```\n\n[}]: #\n\n> Unfortunately `graphql-postgres-subscription` doesn't have TypeScript typings, so we have to import it using `require`.\n\n**Updating Tests**\n\nWe should update tests to use SQL instead of in-memory database.\n\n[{]: <helper> (diffStep 11.8 files=\"test\" module=\"server\")\n\n#### [Server Step 11.8: Updating Tests with SQL](https://github.com/Urigo/WhatsApp-Clone-Server/commit/9c1d8bc)\n\n##### Changed tests&#x2F;mutations&#x2F;addChat.test.ts\n```diff\n@@ -1,18 +1,27 @@\n ┊ 1┊ 1┊import { createTestClient } from 'apollo-server-testing'\n ┊ 2┊ 2┊import { ApolloServer, PubSub, gql } from 'apollo-server-express'\n ┊ 3┊ 3┊import schema from '../../schema'\n-┊ 4┊  ┊import { resetDb, users } from '../../db'\n+┊  ┊ 4┊import { resetDb, pool } from '../../db'\n+┊  ┊ 5┊import sql from 'sql-template-strings'\n+┊  ┊ 6┊import { MyContext } from '../../context';\n ┊ 5┊ 7┊\n ┊ 6┊ 8┊describe('Mutation.addChat', () => {\n ┊ 7┊ 9┊  beforeEach(resetDb)\n ┊ 8┊10┊\n ┊ 9┊11┊  it('creates a new chat between current user and specified recipient', async () => {\n+┊  ┊12┊    const { rows } = await pool.query(sql`SELECT * FROM users WHERE id = 2`)\n+┊  ┊13┊    const currentUser = rows[0];\n ┊10┊14┊    const server = new ApolloServer({\n ┊11┊15┊      schema,\n-┊12┊  ┊      context: () => ({\n+┊  ┊16┊      context: async () => ({\n ┊13┊17┊        pubsub: new PubSub(),\n-┊14┊  ┊        currentUser: users[1],\n+┊  ┊18┊        currentUser,\n+┊  ┊19┊        db: await pool.connect(),\n ┊15┊20┊      }),\n+┊  ┊21┊      formatResponse: (res: any, { context }: { context: MyContext }) => {\n+┊  ┊22┊        context.db.release();\n+┊  ┊23┊        return res;\n+┊  ┊24┊      }\n ┊16┊25┊    })\n ┊17┊26┊\n ┊18┊27┊    const { query, mutate } = createTestClient(server)\n```\n```diff\n@@ -57,12 +66,19 @@\n ┊57┊66┊  })\n ┊58┊67┊\n ┊59┊68┊  it('returns the existing chat if so', async () => {\n+┊  ┊69┊    const { rows } = await pool.query(sql`SELECT * FROM users WHERE id = 1`)\n+┊  ┊70┊    const currentUser = rows[0]\n ┊60┊71┊    const server = new ApolloServer({\n ┊61┊72┊      schema,\n-┊62┊  ┊      context: () => ({\n+┊  ┊73┊      context: async () => ({\n ┊63┊74┊        pubsub: new PubSub(),\n-┊64┊  ┊        currentUser: users[0],\n+┊  ┊75┊        currentUser,\n+┊  ┊76┊        db: await pool.connect(),\n ┊65┊77┊      }),\n+┊  ┊78┊      formatResponse: (res: any, { context }: { context: MyContext }) => {\n+┊  ┊79┊        context.db.release();\n+┊  ┊80┊        return res;\n+┊  ┊81┊      }\n ┊66┊82┊    })\n ┊67┊83┊\n ┊68┊84┊    const { query, mutate } = createTestClient(server)\n```\n\n##### Changed tests&#x2F;mutations&#x2F;addMessage.test.ts\n```diff\n@@ -1,18 +1,27 @@\n ┊ 1┊ 1┊import { createTestClient } from 'apollo-server-testing'\n ┊ 2┊ 2┊import { ApolloServer, PubSub, gql } from 'apollo-server-express'\n ┊ 3┊ 3┊import schema from '../../schema'\n-┊ 4┊  ┊import { resetDb, users } from '../../db'\n+┊  ┊ 4┊import { resetDb, pool } from '../../db'\n+┊  ┊ 5┊import sql from 'sql-template-strings'\n+┊  ┊ 6┊import { MyContext } from '../../context';\n ┊ 5┊ 7┊\n ┊ 6┊ 8┊describe('Mutation.addMessage', () => {\n ┊ 7┊ 9┊  beforeEach(resetDb)\n ┊ 8┊10┊\n ┊ 9┊11┊  it('should add message to specified chat', async () => {\n+┊  ┊12┊    const { rows } = await pool.query(sql`SELECT * FROM users WHERE id = 1`)\n+┊  ┊13┊    const currentUser = rows[0]\n ┊10┊14┊    const server = new ApolloServer({\n ┊11┊15┊      schema,\n-┊12┊  ┊      context: () => ({\n+┊  ┊16┊      context: async () => ({\n ┊13┊17┊        pubsub: new PubSub(),\n-┊14┊  ┊        currentUser: users[0],\n+┊  ┊18┊        currentUser,\n+┊  ┊19┊        db: await pool.connect(),\n ┊15┊20┊      }),\n+┊  ┊21┊      formatResponse: (res: any, { context }: { context: MyContext }) => {\n+┊  ┊22┊        context.db.release();\n+┊  ┊23┊        return res;\n+┊  ┊24┊      }\n ┊16┊25┊    })\n ┊17┊26┊\n ┊18┊27┊    const { query, mutate } = createTestClient(server)\n```\n\n##### Changed tests&#x2F;mutations&#x2F;removeChat.test.ts\n```diff\n@@ -1,18 +1,27 @@\n ┊ 1┊ 1┊import { createTestClient } from 'apollo-server-testing'\n ┊ 2┊ 2┊import { ApolloServer, PubSub, gql } from 'apollo-server-express'\n ┊ 3┊ 3┊import schema from '../../schema'\n-┊ 4┊  ┊import { resetDb, users } from '../../db'\n+┊  ┊ 4┊import { resetDb, pool } from '../../db'\n+┊  ┊ 5┊import sql from 'sql-template-strings'\n+┊  ┊ 6┊import { MyContext } from '../../context';\n ┊ 5┊ 7┊\n ┊ 6┊ 8┊describe('Mutation.removeChat', () => {\n ┊ 7┊ 9┊  beforeEach(resetDb)\n ┊ 8┊10┊\n ┊ 9┊11┊  it('removes chat by id', async () => {\n+┊  ┊12┊    const { rows } = await pool.query(sql`SELECT * FROM users WHERE id = 1`)\n+┊  ┊13┊    const currentUser = rows[0]\n ┊10┊14┊    const server = new ApolloServer({\n ┊11┊15┊      schema,\n-┊12┊  ┊      context: () => ({\n+┊  ┊16┊      context: async () => ({\n ┊13┊17┊        pubsub: new PubSub(),\n-┊14┊  ┊        currentUser: users[0],\n+┊  ┊18┊        currentUser,\n+┊  ┊19┊        db: await pool.connect(),\n ┊15┊20┊      }),\n+┊  ┊21┊      formatResponse: (res: any, { context }: { context: MyContext }) => {\n+┊  ┊22┊        context.db.release();\n+┊  ┊23┊        return res;\n+┊  ┊24┊      }\n ┊16┊25┊    })\n ┊17┊26┊\n ┊18┊27┊    const { query, mutate } = createTestClient(server)\n```\n\n##### Added tests&#x2F;queries&#x2F;\\__snapshots__&#x2F;getMe.test.ts.snap\n```diff\n@@ -0,0 +1,11 @@\n+┊  ┊ 1┊// Jest Snapshot v1, https://goo.gl/fbAQLP\n+┊  ┊ 2┊\n+┊  ┊ 3┊exports[`Query.me should fetch current user 1`] = `\n+┊  ┊ 4┊Object {\n+┊  ┊ 5┊  \"me\": Object {\n+┊  ┊ 6┊    \"id\": \"1\",\n+┊  ┊ 7┊    \"name\": \"Ray Edwards\",\n+┊  ┊ 8┊    \"picture\": \"https://randomuser.me/api/portraits/thumb/lego/1.jpg\",\n+┊  ┊ 9┊  },\n+┊  ┊10┊}\n+┊  ┊11┊`;\n```\n\n##### Changed tests&#x2F;queries&#x2F;getChat.test.ts\n```diff\n@@ -1,15 +1,24 @@\n ┊ 1┊ 1┊import { createTestClient } from 'apollo-server-testing'\n ┊ 2┊ 2┊import { ApolloServer, gql } from 'apollo-server-express'\n ┊ 3┊ 3┊import schema from '../../schema'\n-┊ 4┊  ┊import { users } from '../../db'\n+┊  ┊ 4┊import { pool } from '../../db'\n+┊  ┊ 5┊import sql from 'sql-template-strings'\n+┊  ┊ 6┊import { MyContext } from '../../context';\n ┊ 5┊ 7┊\n ┊ 6┊ 8┊describe('Query.chat', () => {\n ┊ 7┊ 9┊  it('should fetch specified chat', async () => {\n+┊  ┊10┊    const { rows } = await pool.query(sql`SELECT * FROM users WHERE id = 1`)\n+┊  ┊11┊    const currentUser = rows[0]\n ┊ 8┊12┊    const server = new ApolloServer({\n ┊ 9┊13┊      schema,\n-┊10┊  ┊      context: () => ({\n-┊11┊  ┊        currentUser: users[0],\n+┊  ┊14┊      context: async () => ({\n+┊  ┊15┊        currentUser,\n+┊  ┊16┊        db: await pool.connect(),\n ┊12┊17┊      }),\n+┊  ┊18┊      formatResponse: (res: any, { context }: { context: MyContext }) => {\n+┊  ┊19┊        context.db.release();\n+┊  ┊20┊        return res;\n+┊  ┊21┊      }\n ┊13┊22┊    })\n ┊14┊23┊\n ┊15┊24┊    const { query } = createTestClient(server)\n```\n\n##### Changed tests&#x2F;queries&#x2F;getChats.test.ts\n```diff\n@@ -1,15 +1,24 @@\n ┊ 1┊ 1┊import { createTestClient } from 'apollo-server-testing'\n ┊ 2┊ 2┊import { ApolloServer, gql } from 'apollo-server-express'\n ┊ 3┊ 3┊import schema from '../../schema'\n-┊ 4┊  ┊import { users } from '../../db'\n+┊  ┊ 4┊import { pool } from '../../db'\n+┊  ┊ 5┊import sql from 'sql-template-strings'\n+┊  ┊ 6┊import { MyContext } from '../../context';\n ┊ 5┊ 7┊\n ┊ 6┊ 8┊describe('Query.chats', () => {\n ┊ 7┊ 9┊  it('should fetch all chats', async () => {\n+┊  ┊10┊    const { rows } = await pool.query(sql`SELECT * FROM users WHERE id = 1`)\n+┊  ┊11┊    const currentUser = rows[0]\n ┊ 8┊12┊    const server = new ApolloServer({\n ┊ 9┊13┊      schema,\n-┊10┊  ┊      context: () => ({\n-┊11┊  ┊        currentUser: users[0],\n+┊  ┊14┊      context: async () => ({\n+┊  ┊15┊        currentUser,\n+┊  ┊16┊        db: await pool.connect(),\n ┊12┊17┊      }),\n+┊  ┊18┊      formatResponse: (res: any, { context }: { context: MyContext }) => {\n+┊  ┊19┊        context.db.release();\n+┊  ┊20┊        return res;\n+┊  ┊21┊      }\n ┊13┊22┊    })\n ┊14┊23┊\n ┊15┊24┊    const { query } = createTestClient(server)\n```\n\n##### Changed tests&#x2F;queries&#x2F;getMe.test.ts\n```diff\n@@ -1,15 +1,24 @@\n ┊ 1┊ 1┊import { createTestClient } from 'apollo-server-testing'\n ┊ 2┊ 2┊import { ApolloServer, gql } from 'apollo-server-express'\n ┊ 3┊ 3┊import schema from '../../schema'\n-┊ 4┊  ┊import { users } from '../../db'\n+┊  ┊ 4┊import { pool } from '../../db'\n+┊  ┊ 5┊import sql from 'sql-template-strings'\n+┊  ┊ 6┊import { MyContext } from '../../context';\n ┊ 5┊ 7┊\n ┊ 6┊ 8┊describe('Query.me', () => {\n ┊ 7┊ 9┊  it('should fetch current user', async () => {\n+┊  ┊10┊    const { rows } = await pool.query(sql`SELECT * FROM users WHERE id = 1`)\n+┊  ┊11┊    const currentUser = rows[0]\n ┊ 8┊12┊    const server = new ApolloServer({\n ┊ 9┊13┊      schema,\n-┊10┊  ┊      context: () => ({\n-┊11┊  ┊        currentUser: users[0],\n+┊  ┊14┊      context: async () => ({\n+┊  ┊15┊        currentUser,\n+┊  ┊16┊        db: await pool.connect(),\n ┊12┊17┊      }),\n+┊  ┊18┊      formatResponse: (res: any, { context }: { context: MyContext }) => {\n+┊  ┊19┊        context.db.release();\n+┊  ┊20┊        return res;\n+┊  ┊21┊      }\n ┊13┊22┊    })\n ┊14┊23┊\n ┊15┊24┊    const { query } = createTestClient(server)\n```\n\n##### Changed tests&#x2F;queries&#x2F;getUsers.test.ts\n```diff\n@@ -1,15 +1,25 @@\n ┊ 1┊ 1┊import { createTestClient } from 'apollo-server-testing'\n ┊ 2┊ 2┊import { ApolloServer, gql } from 'apollo-server-express'\n ┊ 3┊ 3┊import schema from '../../schema'\n-┊ 4┊  ┊import { users } from '../../db'\n+┊  ┊ 4┊import { pool } from '../../db'\n+┊  ┊ 5┊import sql from 'sql-template-strings'\n+┊  ┊ 6┊import { MyContext } from '../../context';\n ┊ 5┊ 7┊\n ┊ 6┊ 8┊describe('Query.getUsers', () => {\n ┊ 7┊ 9┊  it('should fetch all users except the one signed-in', async () => {\n-┊ 8┊  ┊    let currentUser = users[0]\n-┊ 9┊  ┊\n+┊  ┊10┊    const firstUserQuery = await pool.query(sql`SELECT * FROM users WHERE id = 1`)\n+┊  ┊11┊    let currentUser = firstUserQuery.rows[0]\n+┊  ┊12┊    const db = await pool.connect()\n ┊10┊13┊    const server = new ApolloServer({\n ┊11┊14┊      schema,\n-┊12┊  ┊      context: () => ({ currentUser }),\n+┊  ┊15┊      context: async () => ({\n+┊  ┊16┊        currentUser,\n+┊  ┊17┊        db: await pool.connect(),\n+┊  ┊18┊      }),\n+┊  ┊19┊      formatResponse: (res: any, { context }: { context: MyContext }) => {\n+┊  ┊20┊        context.db.release();\n+┊  ┊21┊        return res;\n+┊  ┊22┊      }\n ┊13┊23┊    })\n ┊14┊24┊\n ┊15┊25┊    const { query } = createTestClient(server)\n```\n```diff\n@@ -30,7 +40,8 @@\n ┊30┊40┊    expect(res.errors).toBeUndefined()\n ┊31┊41┊    expect(res.data).toMatchSnapshot()\n ┊32┊42┊\n-┊33┊  ┊    currentUser = users[1]\n+┊  ┊43┊    const secondUserQuery = await pool.query(sql`SELECT * FROM users WHERE id = '2'`)\n+┊  ┊44┊    currentUser = secondUserQuery.rows[0]\n ┊34┊45┊\n ┊35┊46┊    res = await query({\n ┊36┊47┊      query: gql `\n```\n\n[}]: #\n\n**Remove in-memory database**\n\nWe can remove all the stuff related to in-memory database now.\n\n[{]: <helper> (diffStep 11.9 files=\"db\" module=\"server\")\n\n#### [Server Step 11.9: Removing in-memory database](https://github.com/Urigo/WhatsApp-Clone-Server/commit/5d4af68)\n\n##### Changed db.ts\n```diff\n@@ -30,10 +30,6 @@\n ┊30┊30┊  database: 'whatsapp'\n ┊31┊31┊})\n ┊32┊32┊\n-┊33┊  ┊export const users: User[] = []\n-┊34┊  ┊export const messages: Message[] = []\n-┊35┊  ┊export const chats: Chat[] = []\n-┊36┊  ┊\n ┊37┊33┊export const resetDb = async () => {\n ┊38┊34┊\n ┊39┊35┊  await pool.query(sql`DELETE FROM users`)\n```\n\n[}]: #"
          },
          {
            "manualTitle": "Step 15: Using a REST API",
            "stepRevision": "0b53d9cd23436376ee9d52dc6a2ec9899b80aa1e",
            "manualView": "Despite using GraphQL throughout all our app, we will soon meet the need to use some external API and chances are it will be REST.\nOur first idea could be to bridge the REST API through GraphQL, reproposing the very same API to the client. This approach is wrong, because our first concern should always be to provide the client with ready to use data in the best possible shape.\nThe client don’t need to know that our GraphQL API is backed by a REST API, it doesn’t have to pass headers required by the underlying API or do any kind of special considerations: our backend should take care of everything.\n\n## Retrieve a profile picture from a REST API\n\nIn this chapter we will discuss how to use an external API called Unsplash to retrieve random profile pictures for the users who didn’t set any.\n\nStart heading to https://unsplash.com/developers and clicking on “Register as a developer”. After registering you will have to create a new app: take note of the Access Key because we’re going to need it.\n\nIf you look at the Documentation (https://unsplash.com/documentation#get-a-random-photo) you’ll notice that in order to retrieve a random photo we have to query the /photos/random endpoint (GET method). We also have to pass some headers for the authent\ncation and some params for the search term and the orientation.\n\nOn the browser we would probably use the fetch api, but since on we node we would need a polyfill it’s better to just use a full fledged library like axios:\n\n    yarn add axios\n    yarn add -D @types/axios\n\nBefore we start implementing, we want to create some typings for our endpoint, because ideally we would like to be aided by those typings during the development.\nIn order to do so we can use a Chrome extension like Advanced Rest Client to retrieve the response.\nSet the Method to GET, the Headers to Authorization: 'Client-ID 4d048cfb4383b407eff92e4a2a5ec36c0a866be85e64caafa588c110efad350d' and the Request URL to https://api.unsplash.com/photos/random, along with the params to query: 'portrait' and orientation: 'squarish'.\nCopy the response, create a new file called types/unsplash.ts in your vscode editor and run the command “Past JSON as Types” (you need to install the Past JSON as Code extension and press CTRL+P to open the run command prompt). That would be enough to automatically create the typings for the random photo endpoint.\n\nNow we can finally implement the REST API call in our picture resolver:\n\n[{]: <helper> (diffStep \"12.1\" files=\"schema/resolvers.ts\" module=\"client\")\n\n#### Client Step 12.1: Add basic ChatCreationScreen\n\n\n\n[}]: #\n\nIn order to test it, we have to remove the picture from one of the users and re-run the server with the `RESET_DB=true` environment variable:\n\n[{]: <helper> (diffStep \"12.1\" files=\"db.ts\" module=\"client\")\n\n#### Client Step 12.1: Add basic ChatCreationScreen\n\n\n\n[}]: #\n\n\n## Track the API\n\nEven if our typings are working pretty well so far, not all REST APIs are versioned and the shape we’ve got from the server could potentially change.\nIn order to keep an eye on it we could use the safe-api middleware in order to check for abnormal answers coming from the server and log them. We can also generate the typings automatically based on the response we get.\nFirst let’s install the safe-api middleware:\n\n    yarn add @safe-api/middleware\n\nThen let’s use it inside our resolver:\n\n[{]: <helper> (diffStep \"12.2\" files=\"schema/resolvers.ts\" module=\"client\")\n\n#### Client Step 12.2: Create chat on user pick\n\n\n\n[}]: #\n\nNow launch the client in order to retrieve the picture field multiple times.\n\nIf you look inside the logs directory you will notice that it generated some graphql schema to represent the REST API. You will notice that each time we call the REST endpoint it generates a new schema, because a single response isn’t generic enough to account for all possible responses. Ideally safe-api should be able to average multiple esponses in order to generate the least generic schema matching the given responses.\n\nNow we need to remove `types/unsplash.ts` and generate some Typescript typings out of the schema. Do do so we can use the graphql-code-generator:\n\n[{]: <helper> (diffStep \"12.3\" files=\".gitignore, codegen.yml\" module=\"client\")\n\n#### Client Step 12.3: Write chat on chatAdded\n\n\n\n[}]: #\n\n    yarn codegen\n\n\n## Apollo DataSources\n\nWe’re not done yet, there is still room for improvement. Instead of using axios, we could use Apollo’s Data Sources and take advantage of the built-in support for caching, deduplication and error handling.\n\n    yarn remove axios @types/axios\n    yarn add apollo-datasource-rest\n\n[{]: <helper> (diffStep \"12.4\" files=\"schema/unsplash.api.ts\" module=\"client\")\n\n#### Client Step 12.4: Add chat removal function\n\n\n\n[}]: #\n\nWe created the UnsplashApi class, which extends RESTDataSource. In the constructor you need to set the baseUrl (after calling super() to run the constructor of the base class). You also need to create a willSendRequest method to set the authentication headers for each call. Then it’s simply a matter of creating a getRandomPhoto method to perform the actual REST API call. Instead of calling axios you will have to call the get method of the class (which in turn gets inherited from its RESTDataSource base class): the API is very similar to the axios one.\n\nIn order to access the data source from the resolvers we need to tell Apollo to put them on the context for every request. We shouldn’t use the context field, because that would lead to circular dependencies. Instead we need to use the dataSources field:\n\n[{]: <helper> (diffStep \"12.4\" files=\"index.ts\" module=\"client\")\n\n#### Client Step 12.4: Add chat removal function\n\n\n\n[}]: #\n\nNow we need to update the typings for our context and run the graphq-code-generator again:\n\n[{]: <helper> (diffStep \"12.4\" files=\"context.ts\" module=\"client\")\n\n#### Client Step 12.4: Add chat removal function\n\n\n\n[}]: #\n\n    yarn codegen\n\nNow it should be pretty easy to modify our resolver in order to use our just created datasource:\n\n[{]: <helper> (diffStep \"12.4\" files=\"schema/resolvers.ts\" module=\"client\")\n\n#### Client Step 12.4: Add chat removal function\n\n\n\n[}]: #"
          },
          {
            "manualTitle": "",
            "stepRevision": "",
            "manualView": "This chapter is focused entirely on how to organize a GraphQL API. By far, our project's schema looks simple and keeping SDL and resolvers in two files is really enough.\n\n## Issues we face when GraphQL API grows\n\nUsually, every app starts small and the difficulty of maintenance grows while features are being implemented. I believe that you should always start small and see how a project involves. You could look up many articles about best practices of organising a project but they bring no benefit when your project is small. You don't want to jump between files in order to find what you're looking for, it should be intuitive. I agree a proper folder structure helps but if your schema has 100 lines of code then it makes no sense to split it into 5 files with 20 LOC each. The schema is so small that it won't hurt you when you hit the wall and separation will be necessary but until it happens you can easily move on with the project.\n\nBigger project means more people, more people means teams. In the current state of the app, they might interrupt each other and that eventually affects productivity.\nLack of separation makes the schema harder to maintain, especially once it grows rapidly.\n\n## That's why modularity is a thing!\n\nIn order to improve and solve those issues we would have to split an API into many pieces.\nThose might be files, even folders, doesn't really matter because the goal is to keep relevant chunks of code in one place, conceptually called module.\n\nIf done right, one team won't disturb another and it also helps to understand an entire codebase just by looking at those modules or even learn a feature because everything related to it is within a single module.\n\nThere's also a very important aspect, reusability. Most APIs have something in common, the first thing that comes to mind is authentication and user mechanism in general.\nWhen working with modules, it gets easier to share those.\n\n## Many ways to organize an API\n\nGraphQL specification explains just the language and how to form an API. Managing codebase, that's on our side.\n\nSince we're talking about modularity, let's see possible implementations.\n\nThe first thing on mind are files and folders. Putting relevant logic in a file won't scale well once we add more things, like business logic for example. Which means we need folders, that's for sure.\n\nOkay, so the next question, how to store SDL and resolvers. Do we want to have them stored together or keep them separated?\n\nI'm a big fan of the former because in schema-first approach the SDL is written first and you see exactly how to construct resolvers. The latter would require to jump between files or have them opened side-by-side.\nAnother benefit shows up when you add, remove or just change part of a schema, less likely that you'll miss something.\n\nBut as always, there are things you can't do with that approach.\nOne that pops into my head right away is an IDE support… ?\n< guys, any ideas? >\n\nLet's talk about modularity in terms of SDL.\nWe know how to define types in GraphQL but what if a type is a sum of many features?\nThere two ways to do it. One is to use the `extend` keyword, another to define a type multiple type. Both gave the same effect, all is merged into one type after all.\n\nBut there are few major differences.\n\nThe `extend` keyword is obviously a part of the specification so IDEs and most tools support it. It feels more natural than the second option.\n\nDefining the same type multiple times is the opposite. It might feel odd, not many IDEs and\ntools support it so you have to add a library that handles it but on the other way you don't care if there's already a type or not, you just make sure there's one with proper fields, no matter what. It might also warn you when fields overlap.\n\n## Modularized schema\n\nThere are couple solutions to help you modularize the schema and we will look at 3 of them.\n\nFirst, let's start by defining 3 modules:\n\n- common - things we want to share with all the rest\n- users - everything related to users\n- chats - core logic of WhatsApp\n\n### Using directories\n\nThe simplest and most obvious solution would be to split what we have and move that into directories.\n\nStarting with common module. We need to create a folder at `/modules/common` and a `index.ts` file in it:\n\n[{]: <helper> (diffStep \"13.1\" files=\"modules/common/index.ts\" module=\"server\")\n\n#### [__Server__ Step 13.1: Modularize schema](https://github.com/Urigo/WhatsApp-Clone-Server/commit/92f9e14)\n\n##### Added modules&#x2F;common&#x2F;index.ts\n```diff\n@@ -0,0 +1,23 @@\n+┊  ┊ 1┊import { gql } from 'apollo-server-express';\n+┊  ┊ 2┊import { GraphQLDateTime } from 'graphql-iso-date';\n+┊  ┊ 3┊import { Resolvers } from '../../types/graphql';\n+┊  ┊ 4┊\n+┊  ┊ 5┊export const typeDefs = gql`\n+┊  ┊ 6┊  scalar Date\n+┊  ┊ 7┊\n+┊  ┊ 8┊  type Query {\n+┊  ┊ 9┊    _dummy: Boolean\n+┊  ┊10┊  }\n+┊  ┊11┊\n+┊  ┊12┊  type Mutation {\n+┊  ┊13┊    _dummy: Boolean\n+┊  ┊14┊  }\n+┊  ┊15┊\n+┊  ┊16┊  type Subscription {\n+┊  ┊17┊    _dummy: Boolean\n+┊  ┊18┊  }\n+┊  ┊19┊`;\n+┊  ┊20┊\n+┊  ┊21┊export const resolvers: Resolvers = {\n+┊  ┊22┊  Date: GraphQLDateTime,\n+┊  ┊23┊};\n```\n\n[}]: #\n\nYou can see a pattern here, two things are being exported, one with type definitions and the other with resolvers. Why those `_dummy` fields? We want to use `extend` keyword, that require a base type and GraphQL doesn't accept empty objects.\n\nNow, let's do the same but with Users module:\n\n[{]: <helper> (diffStep \"13.1\" files=\"modules/users/index.ts\" module=\"server\")\n\n#### [__Server__ Step 13.1: Modularize schema](https://github.com/Urigo/WhatsApp-Clone-Server/commit/92f9e14)\n\n##### Added modules&#x2F;users&#x2F;index.ts\n```diff\n@@ -0,0 +1,100 @@\n+┊   ┊  1┊import { gql } from 'apollo-server-express';\n+┊   ┊  2┊import sql from 'sql-template-strings';\n+┊   ┊  3┊import bcrypt from 'bcrypt';\n+┊   ┊  4┊import jwt from 'jsonwebtoken';\n+┊   ┊  5┊import { secret, expiration } from '../../env';\n+┊   ┊  6┊import { validateLength, validatePassword } from '../../validators';\n+┊   ┊  7┊import { Resolvers } from '../../types/graphql';\n+┊   ┊  8┊\n+┊   ┊  9┊export const typeDefs = gql`\n+┊   ┊ 10┊  type User {\n+┊   ┊ 11┊    id: ID!\n+┊   ┊ 12┊    name: String!\n+┊   ┊ 13┊    picture: String\n+┊   ┊ 14┊  }\n+┊   ┊ 15┊\n+┊   ┊ 16┊  extend type Query {\n+┊   ┊ 17┊    me: User\n+┊   ┊ 18┊    users: [User!]!\n+┊   ┊ 19┊  }\n+┊   ┊ 20┊\n+┊   ┊ 21┊  extend type Mutation {\n+┊   ┊ 22┊    signIn(username: String!, password: String!): User\n+┊   ┊ 23┊    signUp(\n+┊   ┊ 24┊      name: String!\n+┊   ┊ 25┊      username: String!\n+┊   ┊ 26┊      password: String!\n+┊   ┊ 27┊      passwordConfirm: String!\n+┊   ┊ 28┊    ): User\n+┊   ┊ 29┊  }\n+┊   ┊ 30┊`;\n+┊   ┊ 31┊\n+┊   ┊ 32┊export const resolvers: Resolvers = {\n+┊   ┊ 33┊  Query: {\n+┊   ┊ 34┊    me(root, args, { currentUser }) {\n+┊   ┊ 35┊      return currentUser || null;\n+┊   ┊ 36┊    },\n+┊   ┊ 37┊    async users(root, args, { currentUser, db }) {\n+┊   ┊ 38┊      if (!currentUser) return [];\n+┊   ┊ 39┊\n+┊   ┊ 40┊      const { rows } = await db.query(sql`\n+┊   ┊ 41┊        SELECT * FROM users WHERE users.id != ${currentUser.id}\n+┊   ┊ 42┊      `);\n+┊   ┊ 43┊\n+┊   ┊ 44┊      return rows;\n+┊   ┊ 45┊    },\n+┊   ┊ 46┊  },\n+┊   ┊ 47┊  Mutation: {\n+┊   ┊ 48┊    async signIn(root, { username, password }, { db, res }) {\n+┊   ┊ 49┊      const { rows } = await db.query(\n+┊   ┊ 50┊        sql`SELECT * FROM users WHERE username = ${username}`\n+┊   ┊ 51┊      );\n+┊   ┊ 52┊      const user = rows[0];\n+┊   ┊ 53┊\n+┊   ┊ 54┊      if (!user) {\n+┊   ┊ 55┊        throw new Error('user not found');\n+┊   ┊ 56┊      }\n+┊   ┊ 57┊\n+┊   ┊ 58┊      const passwordsMatch = bcrypt.compareSync(password, user.password);\n+┊   ┊ 59┊\n+┊   ┊ 60┊      if (!passwordsMatch) {\n+┊   ┊ 61┊        throw new Error('password is incorrect');\n+┊   ┊ 62┊      }\n+┊   ┊ 63┊\n+┊   ┊ 64┊      const authToken = jwt.sign(username, secret);\n+┊   ┊ 65┊\n+┊   ┊ 66┊      res.cookie('authToken', authToken, { maxAge: expiration });\n+┊   ┊ 67┊\n+┊   ┊ 68┊      return user;\n+┊   ┊ 69┊    },\n+┊   ┊ 70┊\n+┊   ┊ 71┊    async signUp(root, { name, username, password, passwordConfirm }, { db }) {\n+┊   ┊ 72┊      validateLength('req.name', name, 3, 50);\n+┊   ┊ 73┊      validateLength('req.username', name, 3, 18);\n+┊   ┊ 74┊      validatePassword('req.password', password);\n+┊   ┊ 75┊\n+┊   ┊ 76┊      if (password !== passwordConfirm) {\n+┊   ┊ 77┊        throw Error(\"req.password and req.passwordConfirm don't match\");\n+┊   ┊ 78┊      }\n+┊   ┊ 79┊\n+┊   ┊ 80┊      const existingUserQuery = await db.query(\n+┊   ┊ 81┊        sql`SELECT * FROM users WHERE username = ${username}`\n+┊   ┊ 82┊      );\n+┊   ┊ 83┊      if (existingUserQuery.rows[0]) {\n+┊   ┊ 84┊        throw Error('username already exists');\n+┊   ┊ 85┊      }\n+┊   ┊ 86┊\n+┊   ┊ 87┊      const passwordHash = bcrypt.hashSync(password, bcrypt.genSaltSync(8));\n+┊   ┊ 88┊\n+┊   ┊ 89┊      const createdUserQuery = await db.query(sql`\n+┊   ┊ 90┊        INSERT INTO users(password, picture, username, name)\n+┊   ┊ 91┊        VALUES(${passwordHash}, '', ${username}, ${name})\n+┊   ┊ 92┊        RETURNING *\n+┊   ┊ 93┊      `);\n+┊   ┊ 94┊\n+┊   ┊ 95┊      const user = createdUserQuery.rows[0];\n+┊   ┊ 96┊\n+┊   ┊ 97┊      return user;\n+┊   ┊ 98┊    },\n+┊   ┊ 99┊  },\n+┊   ┊100┊};\n```\n\n[}]: #\n\nAnd Chats module:\n\n[{]: <helper> (diffStep \"13.1\" files=\"modules/chats/index.ts\" module=\"server\")\n\n#### [__Server__ Step 13.1: Modularize schema](https://github.com/Urigo/WhatsApp-Clone-Server/commit/92f9e14)\n\n##### Changed schema&#x2F;resolvers.ts\n```diff\n@@ -1,16 +1,47 @@\n-┊ 1┊  ┊import { withFilter } from 'apollo-server-express';\n-┊ 2┊  ┊import { GraphQLDateTime } from 'graphql-iso-date';\n-┊ 3┊  ┊import { Message, Chat, pool } from '../db';\n-┊ 4┊  ┊import { Resolvers } from '../types/graphql';\n-┊ 5┊  ┊import { secret, expiration } from '../env';\n-┊ 6┊  ┊import bcrypt from 'bcrypt';\n-┊ 7┊  ┊import jwt from 'jsonwebtoken';\n-┊ 8┊  ┊import { validateLength, validatePassword } from '../validators';\n+┊  ┊ 1┊import { gql, withFilter } from 'apollo-server-express';\n ┊ 9┊ 2┊import sql from 'sql-template-strings';\n-┊10┊  ┊\n-┊11┊  ┊const resolvers: Resolvers = {\n-┊12┊  ┊  Date: GraphQLDateTime,\n-┊13┊  ┊\n+┊  ┊ 3┊import { Message, Chat, pool } from '../../db';\n+┊  ┊ 4┊import { Resolvers } from '../../types/graphql';\n+┊  ┊ 5┊\n+┊  ┊ 6┊export const typeDefs = gql`\n+┊  ┊ 7┊  type Message {\n+┊  ┊ 8┊    id: ID!\n+┊  ┊ 9┊    content: String!\n+┊  ┊10┊    createdAt: Date!\n+┊  ┊11┊    chat: Chat\n+┊  ┊12┊    sender: User\n+┊  ┊13┊    recipient: User\n+┊  ┊14┊    isMine: Boolean!\n+┊  ┊15┊  }\n+┊  ┊16┊\n+┊  ┊17┊  type Chat {\n+┊  ┊18┊    id: ID!\n+┊  ┊19┊    name: String\n+┊  ┊20┊    picture: String\n+┊  ┊21┊    lastMessage: Message\n+┊  ┊22┊    messages: [Message!]!\n+┊  ┊23┊    participants: [User!]!\n+┊  ┊24┊  }\n+┊  ┊25┊\n+┊  ┊26┊  extend type Query {\n+┊  ┊27┊    chats: [Chat!]!\n+┊  ┊28┊    chat(chatId: ID!): Chat\n+┊  ┊29┊  }\n+┊  ┊30┊\n+┊  ┊31┊  extend type Mutation {\n+┊  ┊32┊    addMessage(chatId: ID!, content: String!): Message\n+┊  ┊33┊    addChat(recipientId: ID!): Chat\n+┊  ┊34┊    removeChat(chatId: ID!): ID\n+┊  ┊35┊  }\n+┊  ┊36┊\n+┊  ┊37┊  extend type Subscription {\n+┊  ┊38┊    messageAdded: Message!\n+┊  ┊39┊    chatAdded: Chat!\n+┊  ┊40┊    chatRemoved: ID!\n+┊  ┊41┊  }\n+┊  ┊42┊`;\n+┊  ┊43┊\n+┊  ┊44┊export const resolvers: Resolvers = {\n ┊14┊45┊  Message: {\n ┊15┊46┊    createdAt(message) {\n ┊16┊47┊      return new Date(message.created_at);\n```\n```diff\n@@ -105,10 +136,6 @@\n ┊105┊136┊  },\n ┊106┊137┊\n ┊107┊138┊  Query: {\n-┊108┊   ┊    me(root, args, { currentUser }) {\n-┊109┊   ┊      return currentUser || null;\n-┊110┊   ┊    },\n-┊111┊   ┊\n ┊112┊139┊    async chats(root, args, { currentUser, db }) {\n ┊113┊140┊      if (!currentUser) return [];\n ┊114┊141┊\n```\n```diff\n@@ -133,71 +160,9 @@\n ┊133┊160┊\n ┊134┊161┊      return rows[0] ? rows[0] : null;\n ┊135┊162┊    },\n-┊136┊   ┊\n-┊137┊   ┊    async users(root, args, { currentUser, db }) {\n-┊138┊   ┊      if (!currentUser) return [];\n-┊139┊   ┊\n-┊140┊   ┊      const { rows } = await db.query(sql`\n-┊141┊   ┊        SELECT * FROM users WHERE users.id != ${currentUser.id}\n-┊142┊   ┊      `);\n-┊143┊   ┊\n-┊144┊   ┊      return rows;\n-┊145┊   ┊    },\n ┊146┊163┊  },\n ┊147┊164┊\n ┊148┊165┊  Mutation: {\n-┊149┊   ┊    async signIn(root, { username, password }, { db, res }) {\n-┊150┊   ┊      const { rows } = await db.query(\n-┊151┊   ┊        sql`SELECT * FROM users WHERE username = ${username}`\n-┊152┊   ┊      );\n-┊153┊   ┊      const user = rows[0];\n-┊154┊   ┊\n-┊155┊   ┊      if (!user) {\n-┊156┊   ┊        throw new Error('user not found');\n-┊157┊   ┊      }\n-┊158┊   ┊\n-┊159┊   ┊      const passwordsMatch = bcrypt.compareSync(password, user.password);\n-┊160┊   ┊\n-┊161┊   ┊      if (!passwordsMatch) {\n-┊162┊   ┊        throw new Error('password is incorrect');\n-┊163┊   ┊      }\n-┊164┊   ┊\n-┊165┊   ┊      const authToken = jwt.sign(username, secret);\n-┊166┊   ┊\n-┊167┊   ┊      res.cookie('authToken', authToken, { maxAge: expiration });\n-┊168┊   ┊\n-┊169┊   ┊      return user;\n-┊170┊   ┊    },\n-┊171┊   ┊\n-┊172┊   ┊    async signUp(root, { name, username, password, passwordConfirm }, { db }) {\n-┊173┊   ┊      validateLength('req.name', name, 3, 50);\n-┊174┊   ┊      validateLength('req.username', name, 3, 18);\n-┊175┊   ┊      validatePassword('req.password', password);\n-┊176┊   ┊\n-┊177┊   ┊      if (password !== passwordConfirm) {\n-┊178┊   ┊        throw Error(\"req.password and req.passwordConfirm don't match\");\n-┊179┊   ┊      }\n-┊180┊   ┊\n-┊181┊   ┊      const existingUserQuery = await db.query(\n-┊182┊   ┊        sql`SELECT * FROM users WHERE username = ${username}`\n-┊183┊   ┊      );\n-┊184┊   ┊      if (existingUserQuery.rows[0]) {\n-┊185┊   ┊        throw Error('username already exists');\n-┊186┊   ┊      }\n-┊187┊   ┊\n-┊188┊   ┊      const passwordHash = bcrypt.hashSync(password, bcrypt.genSaltSync(8));\n-┊189┊   ┊\n-┊190┊   ┊      const createdUserQuery = await db.query(sql`\n-┊191┊   ┊        INSERT INTO users(password, picture, username, name)\n-┊192┊   ┊        VALUES(${passwordHash}, '', ${username}, ${name})\n-┊193┊   ┊        RETURNING *\n-┊194┊   ┊      `);\n-┊195┊   ┊\n-┊196┊   ┊      const user = createdUserQuery.rows[0];\n-┊197┊   ┊\n-┊198┊   ┊      return user;\n-┊199┊   ┊    },\n-┊200┊   ┊\n ┊201┊166┊    async addMessage(root, { chatId, content }, { currentUser, pubsub, db }) {\n ┊202┊167┊      if (!currentUser) return null;\n ┊203┊168┊\n```\n```diff\n@@ -360,5 +325,3 @@\n ┊360┊325┊    },\n ┊361┊326┊  },\n ┊362┊327┊};\n-┊363┊   ┊\n-┊364┊   ┊export default resolvers;\n```\n\n[}]: #\n\nSeems like modules are ready but we still need to create a Schema out of them.\n\n[{]: <helper> (diffStep \"13.1\" files=\"schema/index.ts\" module=\"server\")\n\n#### [__Server__ Step 13.1: Modularize schema](https://github.com/Urigo/WhatsApp-Clone-Server/commit/92f9e14)\n\n##### Changed schema&#x2F;index.ts\n```diff\n@@ -1,10 +1,15 @@\n-┊ 1┊  ┊import { importSchema } from 'graphql-import';\n ┊ 2┊ 1┊import { makeExecutableSchema, IResolvers } from 'graphql-tools';\n-┊ 3┊  ┊import resolvers from './resolvers';\n-┊ 4┊  ┊\n-┊ 5┊  ┊const typeDefs = importSchema('schema/typeDefs.graphql');\n+┊  ┊ 2┊import { merge } from 'lodash';\n+┊  ┊ 3┊import * as commonModule from '../modules/common';\n+┊  ┊ 4┊import * as usersModule from '../modules/users';\n+┊  ┊ 5┊import * as chatsModule from '../modules/chats';\n ┊ 6┊ 6┊\n ┊ 7┊ 7┊export default makeExecutableSchema({\n-┊ 8┊  ┊  resolvers: resolvers as IResolvers,\n-┊ 9┊  ┊  typeDefs,\n+┊  ┊ 8┊  resolvers: merge(\n+┊  ┊ 9┊    {},\n+┊  ┊10┊    commonModule.resolvers,\n+┊  ┊11┊    usersModule.resolvers,\n+┊  ┊12┊    chatsModule.resolvers\n+┊  ┊13┊  ) as IResolvers,\n+┊  ┊14┊  typeDefs: [commonModule.typeDefs, usersModule.typeDefs, chatsModule.typeDefs],\n ┊10┊15┊});\n```\n\n[}]: #\n\nBecause we moved everything from `resolvers.ts` and `typeDefs.graphql` files, those can now be removed.\n\nThe last thing we need to adjust is the GraphQL Code Generator's config, in `codegen.yml`:\n\n[{]: <helper> (diffStep \"13.1\" files=\"codegen.yml\" module=\"server\")\n\n#### [__Server__ Step 13.1: Modularize schema](https://github.com/Urigo/WhatsApp-Clone-Server/commit/92f9e14)\n\n##### Changed codegen.yml\n```diff\n@@ -1,7 +1,7 @@\n ┊1┊1┊overwrite: true\n ┊2┊2┊generates:\n ┊3┊3┊  ./types/graphql.d.ts:\n-┊4┊ ┊    schema: ./schema/typeDefs.graphql\n+┊ ┊4┊    schema: ./modules/*/*.ts\n ┊5┊5┊    plugins:\n ┊6┊6┊      - typescript\n ┊7┊7┊      - typescript-resolvers\n```\n\n[}]: #\n\nWe no longer keep all type definitions in one place and all documents are wrapped with `gql` tag, the codegen is smart enough to find those.\n\n### Using Apollo Modules\n\nAn alternative to the previous solution and far more interesting is a module feature of Apollo Server.\n\nLet's see how it all might look like when using Apollo Server's modules:\n\n[{]: <helper> (diffStep \"13.2\" files=\"index.ts\" module=\"server\")\n\n#### [__Server__ Step 13.2: Use Apollo Modules](https://github.com/Urigo/WhatsApp-Clone-Server/commit/597bbae)\n\n##### Changed index.ts\n```diff\n@@ -5,12 +5,15 @@\n ┊ 5┊ 5┊import { app } from './app';\n ┊ 6┊ 6┊import { pool } from './db';\n ┊ 7┊ 7┊import { origin, port, secret } from './env';\n-┊ 8┊  ┊import schema from './schema';\n ┊ 9┊ 8┊import { MyContext } from './context';\n ┊10┊ 9┊import sql from 'sql-template-strings';\n ┊11┊10┊import { UnsplashApi } from './schema/unsplash.api';\n ┊12┊11┊const { PostgresPubSub } = require('graphql-postgres-subscriptions');\n ┊13┊12┊\n+┊  ┊13┊import * as commonModule from './modules/common';\n+┊  ┊14┊import * as usersModule from './modules/users';\n+┊  ┊15┊import * as chatsModule from './modules/chats';\n+┊  ┊16┊\n ┊14┊17┊const pubsub = new PostgresPubSub({\n ┊15┊18┊  host: 'localhost',\n ┊16┊19┊  port: 5432,\n```\n```diff\n@@ -19,7 +22,7 @@\n ┊19┊22┊  database: 'whatsapp',\n ┊20┊23┊});\n ┊21┊24┊const server = new ApolloServer({\n-┊22┊  ┊  schema,\n+┊  ┊25┊  modules: [commonModule, usersModule, chatsModule],\n ┊23┊26┊  context: async (session: any) => {\n ┊24┊27┊    // Access the request object\n ┊25┊28┊    let req = session.connection\n```\n\n##### Deleted schema&#x2F;index.ts\n```diff\n@@ -1,15 +0,0 @@\n-┊ 1┊  ┊import { makeExecutableSchema, IResolvers } from 'graphql-tools';\n-┊ 2┊  ┊import { merge } from 'lodash';\n-┊ 3┊  ┊import * as commonModule from '../modules/common';\n-┊ 4┊  ┊import * as usersModule from '../modules/users';\n-┊ 5┊  ┊import * as chatsModule from '../modules/chats';\n-┊ 6┊  ┊\n-┊ 7┊  ┊export default makeExecutableSchema({\n-┊ 8┊  ┊  resolvers: merge(\n-┊ 9┊  ┊    {},\n-┊10┊  ┊    commonModule.resolvers,\n-┊11┊  ┊    usersModule.resolvers,\n-┊12┊  ┊    chatsModule.resolvers\n-┊13┊  ┊  ) as IResolvers,\n-┊14┊  ┊  typeDefs: [commonModule.typeDefs, usersModule.typeDefs, chatsModule.typeDefs],\n-┊15┊  ┊});\n```\n\n[}]: #\n\nThe `modules` of ApolloServer accepts an array of objects with `resolvers` and `typeDefs` properties. That's exactly what we exported and that's why we can use esmodules directly.\n\nBecause we no longer use `schema.ts`, let's remove it.\n\nIf you would run the server right now, you will see a lot of warnings about missing index signatures. It's definitely nothing to worry about and can be easily fixed by using `useIndexSignature` flag of codegen:\n\n[{]: <helper> (diffStep \"13.2\" files=\"codegen.yml\" module=\"server\")\n\n#### [__Server__ Step 13.2: Use Apollo Modules](https://github.com/Urigo/WhatsApp-Clone-Server/commit/597bbae)\n\n##### Changed codegen.yml\n```diff\n@@ -6,6 +6,7 @@\n ┊ 6┊ 6┊      - typescript\n ┊ 7┊ 7┊      - typescript-resolvers\n ┊ 8┊ 8┊    config:\n+┊  ┊ 9┊      useIndexSignature: true\n ┊ 9┊10┊      contextType: ../context#MyContext\n ┊10┊11┊      mappers:\n ┊11┊12┊        # import { Message } from '../db'\n```\n\n[}]: #\n\nYou might ask how is that different from what we have already implemented. The code is a bit simpler because the merging part is done by Apollo Server. We get some helpful messages when type's definition is missing but one of the modules was extending it and also when there are duplicates. Apollo Modules are very straightforward and basic but maybe that's all you really need in a project.\n\n### Using GraphQL Modules\n\nThere's an another alternative option that forces good patterns and providess a nice to work with API. It's called GraphQL Modules.\nThe main goal is to help organize an API and allow to develop it across multiple teams.\n\nyarn add @graphql-modules/core\n\nSame as Apollo Server's modules, has useful warnings and messages but you can use it with any implementation of GraphQL server.\n\n```ts\nimport { GraphQLModule } from ‘@graphql-modules/core';\n\nexport default = new GraphQLModule({\n  name: 'common',\n  typeDefs,\n  resolvers\n});\n```\n\nIt's a bit similar to what we have in Apollo Modules but as you probably noticed, it's wrapped within `GraphQLModule` class. The class manages a business logic, SDL, resolvers and dependencies between modules.\n\n> An important thing to be aware of, GraphQL Modules encapsulates every module. To get a better understanding, think of it as CSS Modules.\n\nNow that you know some basics, let's implement the simplest of all modules:\n\n[{]: <helper> (diffStep \"13.3\" files=\"modules/common/index.ts\" module=\"server\")\n\n#### [__Server__ Step 13.3: Use GraphQL Modules](https://github.com/Urigo/WhatsApp-Clone-Server/commit/ad3db30)\n\n##### Changed modules&#x2F;common&#x2F;index.ts\n```diff\n@@ -1,8 +1,12 @@\n+┊  ┊ 1┊import { GraphQLModule } from '@graphql-modules/core';\n ┊ 1┊ 2┊import { gql } from 'apollo-server-express';\n ┊ 2┊ 3┊import { GraphQLDateTime } from 'graphql-iso-date';\n+┊  ┊ 4┊import { pool } from '../../db';\n ┊ 3┊ 5┊import { Resolvers } from '../../types/graphql';\n ┊ 4┊ 6┊\n-┊ 5┊  ┊export const typeDefs = gql`\n+┊  ┊ 7┊const { PostgresPubSub } = require('graphql-postgres-subscriptions');\n+┊  ┊ 8┊\n+┊  ┊ 9┊const typeDefs = gql`\n ┊ 6┊10┊  scalar Date\n ┊ 7┊11┊\n ┊ 8┊12┊  type Query {\n```\n```diff\n@@ -18,6 +22,33 @@\n ┊18┊22┊  }\n ┊19┊23┊`;\n ┊20┊24┊\n-┊21┊  ┊export const resolvers: Resolvers = {\n+┊  ┊25┊const resolvers: Resolvers = {\n ┊22┊26┊  Date: GraphQLDateTime,\n ┊23┊27┊};\n+┊  ┊28┊\n+┊  ┊29┊const pubsub = new PostgresPubSub({\n+┊  ┊30┊  host: 'localhost',\n+┊  ┊31┊  port: 5432,\n+┊  ┊32┊  user: 'testuser',\n+┊  ┊33┊  password: 'testpassword',\n+┊  ┊34┊  database: 'whatsapp',\n+┊  ┊35┊});\n+┊  ┊36┊\n+┊  ┊37┊export default new GraphQLModule({\n+┊  ┊38┊  name: 'common',\n+┊  ┊39┊  typeDefs,\n+┊  ┊40┊  resolvers,\n+┊  ┊41┊  async context({ res, connection }) {\n+┊  ┊42┊    let db;\n+┊  ┊43┊\n+┊  ┊44┊    if (!connection) {\n+┊  ┊45┊      db = await pool.connect();\n+┊  ┊46┊    }\n+┊  ┊47┊\n+┊  ┊48┊    return {\n+┊  ┊49┊      pubsub,\n+┊  ┊50┊      res,\n+┊  ┊51┊      db,\n+┊  ┊52┊    };\n+┊  ┊53┊  },\n+┊  ┊54┊});\n```\n\n[}]: #\n\nAs we mentioned, there's no global context so we moved the common parts into Common module.\n\nLet's take care of other two modules and migrate `modules/users/index.ts` first:\n\n[{]: <helper> (diffStep \"13.3\" files=\"modules/users/index.ts\" module=\"server\")\n\n#### [__Server__ Step 13.3: Use GraphQL Modules](https://github.com/Urigo/WhatsApp-Clone-Server/commit/ad3db30)\n\n##### Changed modules&#x2F;users&#x2F;index.ts\n```diff\n@@ -1,12 +1,16 @@\n+┊  ┊ 1┊import { GraphQLModule } from '@graphql-modules/core';\n ┊ 1┊ 2┊import { gql } from 'apollo-server-express';\n+┊  ┊ 3┊import cookie from 'cookie';\n ┊ 2┊ 4┊import sql from 'sql-template-strings';\n ┊ 3┊ 5┊import bcrypt from 'bcrypt';\n ┊ 4┊ 6┊import jwt from 'jsonwebtoken';\n+┊  ┊ 7┊import commonModule from '../common';\n ┊ 5┊ 8┊import { secret, expiration } from '../../env';\n+┊  ┊ 9┊import { pool } from '../../db';\n ┊ 6┊10┊import { validateLength, validatePassword } from '../../validators';\n ┊ 7┊11┊import { Resolvers } from '../../types/graphql';\n ┊ 8┊12┊\n-┊ 9┊  ┊export const typeDefs = gql`\n+┊  ┊13┊const typeDefs = gql`\n ┊10┊14┊  type User {\n ┊11┊15┊    id: ID!\n ┊12┊16┊    name: String!\n```\n```diff\n@@ -29,7 +33,7 @@\n ┊29┊33┊  }\n ┊30┊34┊`;\n ┊31┊35┊\n-┊32┊  ┊export const resolvers: Resolvers = {\n+┊  ┊36┊const resolvers: Resolvers = {\n ┊33┊37┊  Query: {\n ┊34┊38┊    me(root, args, { currentUser }) {\n ┊35┊39┊      return currentUser || null;\n```\n```diff\n@@ -98,3 +102,38 @@\n ┊ 98┊102┊    },\n ┊ 99┊103┊  },\n ┊100┊104┊};\n+┊   ┊105┊\n+┊   ┊106┊export default new GraphQLModule({\n+┊   ┊107┊  name: 'users',\n+┊   ┊108┊  typeDefs,\n+┊   ┊109┊  resolvers,\n+┊   ┊110┊  imports: () => [commonModule],\n+┊   ┊111┊  async context(session) {\n+┊   ┊112┊    let currentUser;\n+┊   ┊113┊\n+┊   ┊114┊    // Access the request object\n+┊   ┊115┊    let req = session.connection\n+┊   ┊116┊      ? session.connection.context.request\n+┊   ┊117┊      : session.req;\n+┊   ┊118┊\n+┊   ┊119┊    // It's subscription\n+┊   ┊120┊    if (session.connection) {\n+┊   ┊121┊      req.cookies = cookie.parse(req.headers.cookie || '');\n+┊   ┊122┊    }\n+┊   ┊123┊\n+┊   ┊124┊    if (req.cookies.authToken) {\n+┊   ┊125┊      const username = jwt.verify(req.cookies.authToken, secret) as string;\n+┊   ┊126┊\n+┊   ┊127┊      if (username) {\n+┊   ┊128┊        const { rows } = await pool.query(\n+┊   ┊129┊          sql`SELECT * FROM users WHERE username = ${username}`\n+┊   ┊130┊        );\n+┊   ┊131┊        currentUser = rows[0];\n+┊   ┊132┊      }\n+┊   ┊133┊    }\n+┊   ┊134┊\n+┊   ┊135┊    return {\n+┊   ┊136┊      currentUser,\n+┊   ┊137┊    };\n+┊   ┊138┊  },\n+┊   ┊139┊});\n```\n\n[}]: #\n\nJust like with Common, we also moved related context but there's a totally new thing called `imports`. In order to let Users module see Common's contents (types, resolvers, context etc) we need to include it in the dependencies.\n\nNow `Chats` that depends on `Users` and `Common` modules:\n\n[{]: <helper> (diffStep \"13.3\" files=\"modules/chats/index.ts\" module=\"server\")\n\n#### [__Server__ Step 13.3: Use GraphQL Modules](https://github.com/Urigo/WhatsApp-Clone-Server/commit/ad3db30)\n\n##### Changed modules&#x2F;chats&#x2F;index.ts\n```diff\n@@ -1,9 +1,12 @@\n+┊  ┊ 1┊import { GraphQLModule } from '@graphql-modules/core';\n ┊ 1┊ 2┊import { gql, withFilter } from 'apollo-server-express';\n ┊ 2┊ 3┊import sql from 'sql-template-strings';\n+┊  ┊ 4┊import commonModule from '../common';\n+┊  ┊ 5┊import usersModule from '../users';\n ┊ 3┊ 6┊import { Message, Chat, pool } from '../../db';\n ┊ 4┊ 7┊import { Resolvers } from '../../types/graphql';\n ┊ 5┊ 8┊\n-┊ 6┊  ┊export const typeDefs = gql`\n+┊  ┊ 9┊const typeDefs = gql`\n ┊ 7┊10┊  type Message {\n ┊ 8┊11┊    id: ID!\n ┊ 9┊12┊    content: String!\n```\n```diff\n@@ -41,7 +44,7 @@\n ┊41┊44┊  }\n ┊42┊45┊`;\n ┊43┊46┊\n-┊44┊  ┊export const resolvers: Resolvers = {\n+┊  ┊47┊const resolvers: Resolvers = {\n ┊45┊48┊  Message: {\n ┊46┊49┊    createdAt(message) {\n ┊47┊50┊      return new Date(message.created_at);\n```\n```diff\n@@ -325,3 +328,10 @@\n ┊325┊328┊    },\n ┊326┊329┊  },\n ┊327┊330┊};\n+┊   ┊331┊\n+┊   ┊332┊export default new GraphQLModule({\n+┊   ┊333┊  name: 'chats',\n+┊   ┊334┊  typeDefs,\n+┊   ┊335┊  resolvers,\n+┊   ┊336┊  imports: () => [commonModule, usersModule],\n+┊   ┊337┊});\n```\n\n[}]: #\n\nSince every module is now a GraphQL Module, we can take care of how to use them in the ApolloServer.\n\nTo make things easier, we're going to create a module that's called `Root` and represents our API.\n\n```ts\nexport const rootModule = new GraphQLModule({\n  name: 'root',\n  imports: [usersModule, chatsModule],\n});\n```\n\nWe want to pass `schema` and `context` to ApolloServer:\n\n```ts\nconst server = new ApolloServer({\n  schema: rootModule.schema,\n  context: rootModule.context,\n  // ...\n```\n\nNow with all that knowledge, take a look at all changes at once:\n\n[{]: <helper> (diffStep \"13.3\" files=\"index.ts\" module=\"server\")\n\n#### [__Server__ Step 13.3: Use GraphQL Modules](https://github.com/Urigo/WhatsApp-Clone-Server/commit/ad3db30)\n\n##### Changed index.ts\n```diff\n@@ -1,71 +1,23 @@\n ┊ 1┊ 1┊import { ApolloServer } from 'apollo-server-express';\n-┊ 2┊  ┊import cookie from 'cookie';\n+┊  ┊ 2┊import { GraphQLModule } from '@graphql-modules/core';\n ┊ 3┊ 3┊import http from 'http';\n-┊ 4┊  ┊import jwt from 'jsonwebtoken';\n ┊ 5┊ 4┊import { app } from './app';\n-┊ 6┊  ┊import { pool } from './db';\n-┊ 7┊  ┊import { origin, port, secret } from './env';\n+┊  ┊ 5┊import { origin, port } from './env';\n ┊ 8┊ 6┊import { MyContext } from './context';\n-┊ 9┊  ┊import sql from 'sql-template-strings';\n ┊10┊ 7┊import { UnsplashApi } from './schema/unsplash.api';\n-┊11┊  ┊const { PostgresPubSub } = require('graphql-postgres-subscriptions');\n ┊12┊ 8┊\n-┊13┊  ┊import * as commonModule from './modules/common';\n-┊14┊  ┊import * as usersModule from './modules/users';\n-┊15┊  ┊import * as chatsModule from './modules/chats';\n+┊  ┊ 9┊import usersModule from './modules/users';\n+┊  ┊10┊import chatsModule from './modules/chats';\n ┊16┊11┊\n-┊17┊  ┊const pubsub = new PostgresPubSub({\n-┊18┊  ┊  host: 'localhost',\n-┊19┊  ┊  port: 5432,\n-┊20┊  ┊  user: 'testuser',\n-┊21┊  ┊  password: 'testpassword',\n-┊22┊  ┊  database: 'whatsapp',\n+┊  ┊12┊export const rootModule = new GraphQLModule({\n+┊  ┊13┊  name: 'root',\n+┊  ┊14┊  imports: [usersModule, chatsModule],\n ┊23┊15┊});\n-┊24┊  ┊const server = new ApolloServer({\n-┊25┊  ┊  modules: [commonModule, usersModule, chatsModule],\n-┊26┊  ┊  context: async (session: any) => {\n-┊27┊  ┊    // Access the request object\n-┊28┊  ┊    let req = session.connection\n-┊29┊  ┊      ? session.connection.context.request\n-┊30┊  ┊      : session.req;\n-┊31┊  ┊\n-┊32┊  ┊    // It's subscription\n-┊33┊  ┊    if (session.connection) {\n-┊34┊  ┊      req.cookies = cookie.parse(req.headers.cookie || '');\n-┊35┊  ┊    }\n-┊36┊  ┊\n-┊37┊  ┊    let currentUser;\n-┊38┊  ┊    if (req.cookies.authToken) {\n-┊39┊  ┊      const username = jwt.verify(req.cookies.authToken, secret) as string;\n-┊40┊  ┊      if (username) {\n-┊41┊  ┊        const { rows } = await pool.query(\n-┊42┊  ┊          sql`SELECT * FROM users WHERE username = ${username}`\n-┊43┊  ┊        );\n-┊44┊  ┊        currentUser = rows[0];\n-┊45┊  ┊      }\n-┊46┊  ┊    }\n-┊47┊  ┊\n-┊48┊  ┊    let db;\n ┊49┊16┊\n-┊50┊  ┊    if (!session.connection) {\n-┊51┊  ┊      db = await pool.connect();\n-┊52┊  ┊    }\n-┊53┊  ┊\n-┊54┊  ┊    return {\n-┊55┊  ┊      currentUser,\n-┊56┊  ┊      pubsub,\n-┊57┊  ┊      db,\n-┊58┊  ┊      res: session.res,\n-┊59┊  ┊    };\n-┊60┊  ┊  },\n-┊61┊  ┊  subscriptions: {\n-┊62┊  ┊    onConnect(params, ws, ctx) {\n-┊63┊  ┊      // pass the request object to context\n-┊64┊  ┊      return {\n-┊65┊  ┊        request: ctx.request,\n-┊66┊  ┊      };\n-┊67┊  ┊    },\n-┊68┊  ┊  },\n+┊  ┊17┊const server = new ApolloServer({\n+┊  ┊18┊  schema: rootModule.schema,\n+┊  ┊19┊  context: rootModule.context,\n+┊  ┊20┊  subscriptions: rootModule.subscriptions,\n ┊69┊21┊  formatResponse: (res: any, { context }: { context: MyContext }) => {\n ┊70┊22┊    context.db.release();\n ┊71┊23┊\n```\n\n##### Changed modules&#x2F;chats&#x2F;index.ts\n```diff\n@@ -1,9 +1,12 @@\n+┊  ┊ 1┊import { GraphQLModule } from '@graphql-modules/core';\n ┊ 1┊ 2┊import { gql, withFilter } from 'apollo-server-express';\n ┊ 2┊ 3┊import sql from 'sql-template-strings';\n+┊  ┊ 4┊import commonModule from '../common';\n+┊  ┊ 5┊import usersModule from '../users';\n ┊ 3┊ 6┊import { Message, Chat, pool } from '../../db';\n ┊ 4┊ 7┊import { Resolvers } from '../../types/graphql';\n ┊ 5┊ 8┊\n-┊ 6┊  ┊export const typeDefs = gql`\n+┊  ┊ 9┊const typeDefs = gql`\n ┊ 7┊10┊  type Message {\n ┊ 8┊11┊    id: ID!\n ┊ 9┊12┊    content: String!\n```\n```diff\n@@ -41,7 +44,7 @@\n ┊41┊44┊  }\n ┊42┊45┊`;\n ┊43┊46┊\n-┊44┊  ┊export const resolvers: Resolvers = {\n+┊  ┊47┊const resolvers: Resolvers = {\n ┊45┊48┊  Message: {\n ┊46┊49┊    createdAt(message) {\n ┊47┊50┊      return new Date(message.created_at);\n```\n```diff\n@@ -325,3 +328,10 @@\n ┊325┊328┊    },\n ┊326┊329┊  },\n ┊327┊330┊};\n+┊   ┊331┊\n+┊   ┊332┊export default new GraphQLModule({\n+┊   ┊333┊  name: 'chats',\n+┊   ┊334┊  typeDefs,\n+┊   ┊335┊  resolvers,\n+┊   ┊336┊  imports: () => [commonModule, usersModule],\n+┊   ┊337┊});\n```\n\n##### Changed modules&#x2F;common&#x2F;index.ts\n```diff\n@@ -1,8 +1,12 @@\n+┊  ┊ 1┊import { GraphQLModule } from '@graphql-modules/core';\n ┊ 1┊ 2┊import { gql } from 'apollo-server-express';\n ┊ 2┊ 3┊import { GraphQLDateTime } from 'graphql-iso-date';\n+┊  ┊ 4┊import { pool } from '../../db';\n ┊ 3┊ 5┊import { Resolvers } from '../../types/graphql';\n ┊ 4┊ 6┊\n-┊ 5┊  ┊export const typeDefs = gql`\n+┊  ┊ 7┊const { PostgresPubSub } = require('graphql-postgres-subscriptions');\n+┊  ┊ 8┊\n+┊  ┊ 9┊const typeDefs = gql`\n ┊ 6┊10┊  scalar Date\n ┊ 7┊11┊\n ┊ 8┊12┊  type Query {\n```\n```diff\n@@ -18,6 +22,33 @@\n ┊18┊22┊  }\n ┊19┊23┊`;\n ┊20┊24┊\n-┊21┊  ┊export const resolvers: Resolvers = {\n+┊  ┊25┊const resolvers: Resolvers = {\n ┊22┊26┊  Date: GraphQLDateTime,\n ┊23┊27┊};\n+┊  ┊28┊\n+┊  ┊29┊const pubsub = new PostgresPubSub({\n+┊  ┊30┊  host: 'localhost',\n+┊  ┊31┊  port: 5432,\n+┊  ┊32┊  user: 'testuser',\n+┊  ┊33┊  password: 'testpassword',\n+┊  ┊34┊  database: 'whatsapp',\n+┊  ┊35┊});\n+┊  ┊36┊\n+┊  ┊37┊export default new GraphQLModule({\n+┊  ┊38┊  name: 'common',\n+┊  ┊39┊  typeDefs,\n+┊  ┊40┊  resolvers,\n+┊  ┊41┊  async context({ res, connection }) {\n+┊  ┊42┊    let db;\n+┊  ┊43┊\n+┊  ┊44┊    if (!connection) {\n+┊  ┊45┊      db = await pool.connect();\n+┊  ┊46┊    }\n+┊  ┊47┊\n+┊  ┊48┊    return {\n+┊  ┊49┊      pubsub,\n+┊  ┊50┊      res,\n+┊  ┊51┊      db,\n+┊  ┊52┊    };\n+┊  ┊53┊  },\n+┊  ┊54┊});\n```\n\n##### Changed modules&#x2F;users&#x2F;index.ts\n```diff\n@@ -1,12 +1,16 @@\n+┊  ┊ 1┊import { GraphQLModule } from '@graphql-modules/core';\n ┊ 1┊ 2┊import { gql } from 'apollo-server-express';\n+┊  ┊ 3┊import cookie from 'cookie';\n ┊ 2┊ 4┊import sql from 'sql-template-strings';\n ┊ 3┊ 5┊import bcrypt from 'bcrypt';\n ┊ 4┊ 6┊import jwt from 'jsonwebtoken';\n+┊  ┊ 7┊import commonModule from '../common';\n ┊ 5┊ 8┊import { secret, expiration } from '../../env';\n+┊  ┊ 9┊import { pool } from '../../db';\n ┊ 6┊10┊import { validateLength, validatePassword } from '../../validators';\n ┊ 7┊11┊import { Resolvers } from '../../types/graphql';\n ┊ 8┊12┊\n-┊ 9┊  ┊export const typeDefs = gql`\n+┊  ┊13┊const typeDefs = gql`\n ┊10┊14┊  type User {\n ┊11┊15┊    id: ID!\n ┊12┊16┊    name: String!\n```\n```diff\n@@ -29,7 +33,7 @@\n ┊29┊33┊  }\n ┊30┊34┊`;\n ┊31┊35┊\n-┊32┊  ┊export const resolvers: Resolvers = {\n+┊  ┊36┊const resolvers: Resolvers = {\n ┊33┊37┊  Query: {\n ┊34┊38┊    me(root, args, { currentUser }) {\n ┊35┊39┊      return currentUser || null;\n```\n```diff\n@@ -98,3 +102,38 @@\n ┊ 98┊102┊    },\n ┊ 99┊103┊  },\n ┊100┊104┊};\n+┊   ┊105┊\n+┊   ┊106┊export default new GraphQLModule({\n+┊   ┊107┊  name: 'users',\n+┊   ┊108┊  typeDefs,\n+┊   ┊109┊  resolvers,\n+┊   ┊110┊  imports: () => [commonModule],\n+┊   ┊111┊  async context(session) {\n+┊   ┊112┊    let currentUser;\n+┊   ┊113┊\n+┊   ┊114┊    // Access the request object\n+┊   ┊115┊    let req = session.connection\n+┊   ┊116┊      ? session.connection.context.request\n+┊   ┊117┊      : session.req;\n+┊   ┊118┊\n+┊   ┊119┊    // It's subscription\n+┊   ┊120┊    if (session.connection) {\n+┊   ┊121┊      req.cookies = cookie.parse(req.headers.cookie || '');\n+┊   ┊122┊    }\n+┊   ┊123┊\n+┊   ┊124┊    if (req.cookies.authToken) {\n+┊   ┊125┊      const username = jwt.verify(req.cookies.authToken, secret) as string;\n+┊   ┊126┊\n+┊   ┊127┊      if (username) {\n+┊   ┊128┊        const { rows } = await pool.query(\n+┊   ┊129┊          sql`SELECT * FROM users WHERE username = ${username}`\n+┊   ┊130┊        );\n+┊   ┊131┊        currentUser = rows[0];\n+┊   ┊132┊      }\n+┊   ┊133┊    }\n+┊   ┊134┊\n+┊   ┊135┊    return {\n+┊   ┊136┊      currentUser,\n+┊   ┊137┊    };\n+┊   ┊138┊  },\n+┊   ┊139┊});\n```\n\n[}]: #\n\n#### Migrate Unsplash API to Chats\n\nWe still make use of global context which won't work with GraphQL Modules. To be more specific, it's not the context definition itself but the thing that's being added by ApolloServer, Data Sources.\n\nThe `RESTDataSource` is of course more than a class but in case of Unsplash API we won't loose any important features except the HTTP client. We're going to use `axios` instead:\n\nyarn add axios\n\nWe've got everything now so let's migrate UnsplashAPI class and move it from `schema/unsplash.api.ts` under `modules/chats`!\n\n[{]: <helper> (diffStep \"13.3\" files=\"modules/chats/unsplash.api.ts\" module=\"server\")\n\n#### [__Server__ Step 13.3: Use GraphQL Modules](https://github.com/Urigo/WhatsApp-Clone-Server/commit/ad3db30)\n\n\n\n[}]: #\n\nThere is no big differences between now and what we had before, the only thing that's changed is the way we make http requests.\n\nThe `UnsplashAPI` can be now removed from `dataSources` and moved under Chats module's context:\n\n[{]: <helper> (diffStep \"13.3\" files=\"index.ts\" module=\"server\")\n\n#### [__Server__ Step 13.3: Use GraphQL Modules](https://github.com/Urigo/WhatsApp-Clone-Server/commit/ad3db30)\n\n##### Changed index.ts\n```diff\n@@ -1,71 +1,23 @@\n ┊ 1┊ 1┊import { ApolloServer } from 'apollo-server-express';\n-┊ 2┊  ┊import cookie from 'cookie';\n+┊  ┊ 2┊import { GraphQLModule } from '@graphql-modules/core';\n ┊ 3┊ 3┊import http from 'http';\n-┊ 4┊  ┊import jwt from 'jsonwebtoken';\n ┊ 5┊ 4┊import { app } from './app';\n-┊ 6┊  ┊import { pool } from './db';\n-┊ 7┊  ┊import { origin, port, secret } from './env';\n+┊  ┊ 5┊import { origin, port } from './env';\n ┊ 8┊ 6┊import { MyContext } from './context';\n-┊ 9┊  ┊import sql from 'sql-template-strings';\n ┊10┊ 7┊import { UnsplashApi } from './schema/unsplash.api';\n-┊11┊  ┊const { PostgresPubSub } = require('graphql-postgres-subscriptions');\n ┊12┊ 8┊\n-┊13┊  ┊import * as commonModule from './modules/common';\n-┊14┊  ┊import * as usersModule from './modules/users';\n-┊15┊  ┊import * as chatsModule from './modules/chats';\n+┊  ┊ 9┊import usersModule from './modules/users';\n+┊  ┊10┊import chatsModule from './modules/chats';\n ┊16┊11┊\n-┊17┊  ┊const pubsub = new PostgresPubSub({\n-┊18┊  ┊  host: 'localhost',\n-┊19┊  ┊  port: 5432,\n-┊20┊  ┊  user: 'testuser',\n-┊21┊  ┊  password: 'testpassword',\n-┊22┊  ┊  database: 'whatsapp',\n+┊  ┊12┊export const rootModule = new GraphQLModule({\n+┊  ┊13┊  name: 'root',\n+┊  ┊14┊  imports: [usersModule, chatsModule],\n ┊23┊15┊});\n-┊24┊  ┊const server = new ApolloServer({\n-┊25┊  ┊  modules: [commonModule, usersModule, chatsModule],\n-┊26┊  ┊  context: async (session: any) => {\n-┊27┊  ┊    // Access the request object\n-┊28┊  ┊    let req = session.connection\n-┊29┊  ┊      ? session.connection.context.request\n-┊30┊  ┊      : session.req;\n-┊31┊  ┊\n-┊32┊  ┊    // It's subscription\n-┊33┊  ┊    if (session.connection) {\n-┊34┊  ┊      req.cookies = cookie.parse(req.headers.cookie || '');\n-┊35┊  ┊    }\n-┊36┊  ┊\n-┊37┊  ┊    let currentUser;\n-┊38┊  ┊    if (req.cookies.authToken) {\n-┊39┊  ┊      const username = jwt.verify(req.cookies.authToken, secret) as string;\n-┊40┊  ┊      if (username) {\n-┊41┊  ┊        const { rows } = await pool.query(\n-┊42┊  ┊          sql`SELECT * FROM users WHERE username = ${username}`\n-┊43┊  ┊        );\n-┊44┊  ┊        currentUser = rows[0];\n-┊45┊  ┊      }\n-┊46┊  ┊    }\n-┊47┊  ┊\n-┊48┊  ┊    let db;\n ┊49┊16┊\n-┊50┊  ┊    if (!session.connection) {\n-┊51┊  ┊      db = await pool.connect();\n-┊52┊  ┊    }\n-┊53┊  ┊\n-┊54┊  ┊    return {\n-┊55┊  ┊      currentUser,\n-┊56┊  ┊      pubsub,\n-┊57┊  ┊      db,\n-┊58┊  ┊      res: session.res,\n-┊59┊  ┊    };\n-┊60┊  ┊  },\n-┊61┊  ┊  subscriptions: {\n-┊62┊  ┊    onConnect(params, ws, ctx) {\n-┊63┊  ┊      // pass the request object to context\n-┊64┊  ┊      return {\n-┊65┊  ┊        request: ctx.request,\n-┊66┊  ┊      };\n-┊67┊  ┊    },\n-┊68┊  ┊  },\n+┊  ┊17┊const server = new ApolloServer({\n+┊  ┊18┊  schema: rootModule.schema,\n+┊  ┊19┊  context: rootModule.context,\n+┊  ┊20┊  subscriptions: rootModule.subscriptions,\n ┊69┊21┊  formatResponse: (res: any, { context }: { context: MyContext }) => {\n ┊70┊22┊    context.db.release();\n ┊71┊23┊\n```\n\n##### Changed modules&#x2F;chats&#x2F;index.ts\n```diff\n@@ -1,9 +1,12 @@\n+┊  ┊ 1┊import { GraphQLModule } from '@graphql-modules/core';\n ┊ 1┊ 2┊import { gql, withFilter } from 'apollo-server-express';\n ┊ 2┊ 3┊import sql from 'sql-template-strings';\n+┊  ┊ 4┊import commonModule from '../common';\n+┊  ┊ 5┊import usersModule from '../users';\n ┊ 3┊ 6┊import { Message, Chat, pool } from '../../db';\n ┊ 4┊ 7┊import { Resolvers } from '../../types/graphql';\n ┊ 5┊ 8┊\n-┊ 6┊  ┊export const typeDefs = gql`\n+┊  ┊ 9┊const typeDefs = gql`\n ┊ 7┊10┊  type Message {\n ┊ 8┊11┊    id: ID!\n ┊ 9┊12┊    content: String!\n```\n```diff\n@@ -41,7 +44,7 @@\n ┊41┊44┊  }\n ┊42┊45┊`;\n ┊43┊46┊\n-┊44┊  ┊export const resolvers: Resolvers = {\n+┊  ┊47┊const resolvers: Resolvers = {\n ┊45┊48┊  Message: {\n ┊46┊49┊    createdAt(message) {\n ┊47┊50┊      return new Date(message.created_at);\n```\n```diff\n@@ -325,3 +328,10 @@\n ┊325┊328┊    },\n ┊326┊329┊  },\n ┊327┊330┊};\n+┊   ┊331┊\n+┊   ┊332┊export default new GraphQLModule({\n+┊   ┊333┊  name: 'chats',\n+┊   ┊334┊  typeDefs,\n+┊   ┊335┊  resolvers,\n+┊   ┊336┊  imports: () => [commonModule, usersModule],\n+┊   ┊337┊});\n```\n\n##### Changed modules&#x2F;common&#x2F;index.ts\n```diff\n@@ -1,8 +1,12 @@\n+┊  ┊ 1┊import { GraphQLModule } from '@graphql-modules/core';\n ┊ 1┊ 2┊import { gql } from 'apollo-server-express';\n ┊ 2┊ 3┊import { GraphQLDateTime } from 'graphql-iso-date';\n+┊  ┊ 4┊import { pool } from '../../db';\n ┊ 3┊ 5┊import { Resolvers } from '../../types/graphql';\n ┊ 4┊ 6┊\n-┊ 5┊  ┊export const typeDefs = gql`\n+┊  ┊ 7┊const { PostgresPubSub } = require('graphql-postgres-subscriptions');\n+┊  ┊ 8┊\n+┊  ┊ 9┊const typeDefs = gql`\n ┊ 6┊10┊  scalar Date\n ┊ 7┊11┊\n ┊ 8┊12┊  type Query {\n```\n```diff\n@@ -18,6 +22,33 @@\n ┊18┊22┊  }\n ┊19┊23┊`;\n ┊20┊24┊\n-┊21┊  ┊export const resolvers: Resolvers = {\n+┊  ┊25┊const resolvers: Resolvers = {\n ┊22┊26┊  Date: GraphQLDateTime,\n ┊23┊27┊};\n+┊  ┊28┊\n+┊  ┊29┊const pubsub = new PostgresPubSub({\n+┊  ┊30┊  host: 'localhost',\n+┊  ┊31┊  port: 5432,\n+┊  ┊32┊  user: 'testuser',\n+┊  ┊33┊  password: 'testpassword',\n+┊  ┊34┊  database: 'whatsapp',\n+┊  ┊35┊});\n+┊  ┊36┊\n+┊  ┊37┊export default new GraphQLModule({\n+┊  ┊38┊  name: 'common',\n+┊  ┊39┊  typeDefs,\n+┊  ┊40┊  resolvers,\n+┊  ┊41┊  async context({ res, connection }) {\n+┊  ┊42┊    let db;\n+┊  ┊43┊\n+┊  ┊44┊    if (!connection) {\n+┊  ┊45┊      db = await pool.connect();\n+┊  ┊46┊    }\n+┊  ┊47┊\n+┊  ┊48┊    return {\n+┊  ┊49┊      pubsub,\n+┊  ┊50┊      res,\n+┊  ┊51┊      db,\n+┊  ┊52┊    };\n+┊  ┊53┊  },\n+┊  ┊54┊});\n```\n\n##### Changed modules&#x2F;users&#x2F;index.ts\n```diff\n@@ -1,12 +1,16 @@\n+┊  ┊ 1┊import { GraphQLModule } from '@graphql-modules/core';\n ┊ 1┊ 2┊import { gql } from 'apollo-server-express';\n+┊  ┊ 3┊import cookie from 'cookie';\n ┊ 2┊ 4┊import sql from 'sql-template-strings';\n ┊ 3┊ 5┊import bcrypt from 'bcrypt';\n ┊ 4┊ 6┊import jwt from 'jsonwebtoken';\n+┊  ┊ 7┊import commonModule from '../common';\n ┊ 5┊ 8┊import { secret, expiration } from '../../env';\n+┊  ┊ 9┊import { pool } from '../../db';\n ┊ 6┊10┊import { validateLength, validatePassword } from '../../validators';\n ┊ 7┊11┊import { Resolvers } from '../../types/graphql';\n ┊ 8┊12┊\n-┊ 9┊  ┊export const typeDefs = gql`\n+┊  ┊13┊const typeDefs = gql`\n ┊10┊14┊  type User {\n ┊11┊15┊    id: ID!\n ┊12┊16┊    name: String!\n```\n```diff\n@@ -29,7 +33,7 @@\n ┊29┊33┊  }\n ┊30┊34┊`;\n ┊31┊35┊\n-┊32┊  ┊export const resolvers: Resolvers = {\n+┊  ┊36┊const resolvers: Resolvers = {\n ┊33┊37┊  Query: {\n ┊34┊38┊    me(root, args, { currentUser }) {\n ┊35┊39┊      return currentUser || null;\n```\n```diff\n@@ -98,3 +102,38 @@\n ┊ 98┊102┊    },\n ┊ 99┊103┊  },\n ┊100┊104┊};\n+┊   ┊105┊\n+┊   ┊106┊export default new GraphQLModule({\n+┊   ┊107┊  name: 'users',\n+┊   ┊108┊  typeDefs,\n+┊   ┊109┊  resolvers,\n+┊   ┊110┊  imports: () => [commonModule],\n+┊   ┊111┊  async context(session) {\n+┊   ┊112┊    let currentUser;\n+┊   ┊113┊\n+┊   ┊114┊    // Access the request object\n+┊   ┊115┊    let req = session.connection\n+┊   ┊116┊      ? session.connection.context.request\n+┊   ┊117┊      : session.req;\n+┊   ┊118┊\n+┊   ┊119┊    // It's subscription\n+┊   ┊120┊    if (session.connection) {\n+┊   ┊121┊      req.cookies = cookie.parse(req.headers.cookie || '');\n+┊   ┊122┊    }\n+┊   ┊123┊\n+┊   ┊124┊    if (req.cookies.authToken) {\n+┊   ┊125┊      const username = jwt.verify(req.cookies.authToken, secret) as string;\n+┊   ┊126┊\n+┊   ┊127┊      if (username) {\n+┊   ┊128┊        const { rows } = await pool.query(\n+┊   ┊129┊          sql`SELECT * FROM users WHERE username = ${username}`\n+┊   ┊130┊        );\n+┊   ┊131┊        currentUser = rows[0];\n+┊   ┊132┊      }\n+┊   ┊133┊    }\n+┊   ┊134┊\n+┊   ┊135┊    return {\n+┊   ┊136┊      currentUser,\n+┊   ┊137┊    };\n+┊   ┊138┊  },\n+┊   ┊139┊});\n```\n\n[}]: #\n\n[{]: <helper> (diffStep \"13.3\" files=\"context.ts\" module=\"server\")\n\n#### [__Server__ Step 13.3: Use GraphQL Modules](https://github.com/Urigo/WhatsApp-Clone-Server/commit/ad3db30)\n\n\n\n[}]: #\n\n[{]: <helper> (diffStep \"13.3\" files=\"modules/chats/index.ts\" module=\"server\")\n\n#### [__Server__ Step 13.3: Use GraphQL Modules](https://github.com/Urigo/WhatsApp-Clone-Server/commit/ad3db30)\n\n##### Changed modules&#x2F;chats&#x2F;index.ts\n```diff\n@@ -1,9 +1,12 @@\n+┊  ┊ 1┊import { GraphQLModule } from '@graphql-modules/core';\n ┊ 1┊ 2┊import { gql, withFilter } from 'apollo-server-express';\n ┊ 2┊ 3┊import sql from 'sql-template-strings';\n+┊  ┊ 4┊import commonModule from '../common';\n+┊  ┊ 5┊import usersModule from '../users';\n ┊ 3┊ 6┊import { Message, Chat, pool } from '../../db';\n ┊ 4┊ 7┊import { Resolvers } from '../../types/graphql';\n ┊ 5┊ 8┊\n-┊ 6┊  ┊export const typeDefs = gql`\n+┊  ┊ 9┊const typeDefs = gql`\n ┊ 7┊10┊  type Message {\n ┊ 8┊11┊    id: ID!\n ┊ 9┊12┊    content: String!\n```\n```diff\n@@ -41,7 +44,7 @@\n ┊41┊44┊  }\n ┊42┊45┊`;\n ┊43┊46┊\n-┊44┊  ┊export const resolvers: Resolvers = {\n+┊  ┊47┊const resolvers: Resolvers = {\n ┊45┊48┊  Message: {\n ┊46┊49┊    createdAt(message) {\n ┊47┊50┊      return new Date(message.created_at);\n```\n```diff\n@@ -325,3 +328,10 @@\n ┊325┊328┊    },\n ┊326┊329┊  },\n ┊327┊330┊};\n+┊   ┊331┊\n+┊   ┊332┊export default new GraphQLModule({\n+┊   ┊333┊  name: 'chats',\n+┊   ┊334┊  typeDefs,\n+┊   ┊335┊  resolvers,\n+┊   ┊336┊  imports: () => [commonModule, usersModule],\n+┊   ┊337┊});\n```\n\n[}]: #\n\n#### Dependency Injection in GraphQL Modules\n\nThe major feature of GraphQL Modules is the Dependency Injection. It's optional, you don't have to use it until it's really necessary. Even though WhatsApp clone doesn't need it yet, we're going to talk about DI and implement a simple thing, just for educational purpose.\n\nIf you're familiar with Dependency Injection then you will get it straight away. If not, please read about it here or here (**links**).\n\nTo start working with DI, we we need to install two packages:\n\nyarn add @graphql-modules/di reflect-metadata\n\nLet's now adjust the context type and import `reflect-metadata` into the project:\n\n[{]: <helper> (diffStep \"13.5\" files=\"context.ts\" module=\"server\")\n\n#### [__Server__ Step 13.5: Use Dependency Injection](https://github.com/Urigo/WhatsApp-Clone-Server/commit/ccb6a96)\n\n##### Changed context.ts\n```diff\n@@ -1,13 +1,12 @@\n ┊ 1┊ 1┊import { PubSub } from 'apollo-server-express';\n+┊  ┊ 2┊import { ModuleContext } from '@graphql-modules/core';\n ┊ 2┊ 3┊import { User } from './db';\n ┊ 3┊ 4┊import { Response } from 'express';\n ┊ 4┊ 5┊import { PoolClient } from 'pg';\n-┊ 5┊  ┊import { UnsplashApi } from './modules/chats/unsplash.api';\n ┊ 6┊ 6┊\n ┊ 7┊ 7┊export type MyContext = {\n ┊ 8┊ 8┊  pubsub: PubSub;\n ┊ 9┊ 9┊  currentUser: User;\n ┊10┊10┊  res: Response;\n ┊11┊11┊  db: PoolClient;\n-┊12┊  ┊  unsplashApi: UnsplashApi;\n-┊13┊  ┊};\n+┊  ┊12┊} & ModuleContext;\n```\n\n[}]: #\n\n[{]: <helper> (diffStep \"13.5\" files=\"index.ts\" module=\"server\")\n\n#### [__Server__ Step 13.5: Use Dependency Injection](https://github.com/Urigo/WhatsApp-Clone-Server/commit/ccb6a96)\n\n##### Changed index.ts\n```diff\n@@ -1,3 +1,4 @@\n+┊ ┊1┊import 'reflect-metadata';\n ┊1┊2┊import { ApolloServer } from 'apollo-server-express';\n ┊2┊3┊import { GraphQLModule } from '@graphql-modules/core';\n ┊3┊4┊import http from 'http';\n```\n\n##### Changed modules&#x2F;chats&#x2F;index.ts\n```diff\n@@ -11,7 +11,7 @@\n ┊11┊11┊  type Message {\n ┊12┊12┊    id: ID!\n ┊13┊13┊    content: String!\n-┊14┊  ┊    createdAt: Date!\n+┊  ┊14┊    createdAt: DateTime!\n ┊15┊15┊    chat: Chat\n ┊16┊16┊    sender: User\n ┊17┊17┊    recipient: User\n```\n```diff\n@@ -94,7 +94,7 @@\n ┊ 94┊ 94┊      return participant ? participant.name : null;\n ┊ 95┊ 95┊    },\n ┊ 96┊ 96┊\n-┊ 97┊   ┊    async picture(chat, args, { currentUser, db, unsplashApi }) {\n+┊   ┊ 97┊    async picture(chat, args, { currentUser, db, injector }) {\n ┊ 98┊ 98┊      if (!currentUser) return null;\n ┊ 99┊ 99┊\n ┊100┊100┊      const { rows } = await db.query(sql`\n```\n```diff\n@@ -107,7 +107,7 @@\n ┊107┊107┊\n ┊108┊108┊      return participant && participant.picture\n ┊109┊109┊        ? participant.picture\n-┊110┊   ┊        : unsplashApi.getRandomPhoto();\n+┊   ┊110┊        : injector.get(UnsplashApi).getRandomPhoto();\n ┊111┊111┊    },\n ┊112┊112┊\n ┊113┊113┊    async messages(chat, args, { db }) {\n```\n```diff\n@@ -335,9 +335,5 @@\n ┊335┊335┊  typeDefs,\n ┊336┊336┊  resolvers,\n ┊337┊337┊  imports: () => [commonModule, usersModule],\n-┊338┊   ┊  context() {\n-┊339┊   ┊    return {\n-┊340┊   ┊      unsplashApi: new UnsplashApi(),\n-┊341┊   ┊    };\n-┊342┊   ┊  },\n+┊   ┊338┊  providers: () => [UnsplashApi],\n ┊343┊339┊});\n```\n\n##### Changed modules&#x2F;common&#x2F;index.ts\n```diff\n@@ -7,7 +7,7 @@\n ┊ 7┊ 7┊const { PostgresPubSub } = require('graphql-postgres-subscriptions');\n ┊ 8┊ 8┊\n ┊ 9┊ 9┊const typeDefs = gql`\n-┊10┊  ┊  scalar Date\n+┊  ┊10┊  scalar DateTime\n ┊11┊11┊\n ┊12┊12┊  type Query {\n ┊13┊13┊    _dummy: Boolean\n```\n```diff\n@@ -23,7 +23,7 @@\n ┊23┊23┊`;\n ┊24┊24┊\n ┊25┊25┊const resolvers: Resolvers = {\n-┊26┊  ┊  Date: GraphQLDateTime,\n+┊  ┊26┊  DateTime: GraphQLDateTime,\n ┊27┊27┊};\n ┊28┊28┊\n ┊29┊29┊const pubsub = new PostgresPubSub({\n```\n\n[}]: #\n\nIn short, Iependency Injection will instantiate classes, manage dependencies between them and so on and in addition to that, the GraphQL Modules allows to define when each provider / class should be created. We call it scopes.\n\n- Application scope - provider is created when application starts (default)\n- Session - providers are constructed in the beginning of the network request, then kept until the network request is closed\n- Request - creates an instance each time you request it from the injector\n\nBecause our `UnsplashApi` doesn't have to be recreated on every request, we can easily use Application scope, which is the default. The `Injectable` decorator is just to attach some metadata to the class.\n\n[{]: <helper> (diffStep \"13.5\" files=\"modules/chats/unsplash.api.ts\" module=\"server\")\n\n#### [__Server__ Step 13.5: Use Dependency Injection](https://github.com/Urigo/WhatsApp-Clone-Server/commit/ccb6a96)\n\n##### Changed modules&#x2F;chats&#x2F;unsplash.api.ts\n```diff\n@@ -1,3 +1,4 @@\n+┊ ┊1┊import { Injectable, ProviderScope } from '@graphql-modules/di';\n ┊1┊2┊import { resolve } from 'path';\n ┊2┊3┊import axios from 'axios';\n ┊3┊4┊import { trackProvider } from '@safe-api/middleware';\n```\n```diff\n@@ -8,6 +9,9 @@\n ┊ 8┊ 9┊  orientation: 'landscape' | 'portrait' | 'squarish';\n ┊ 9┊10┊}\n ┊10┊11┊\n+┊  ┊12┊@Injectable({\n+┊  ┊13┊  scope: ProviderScope.Application,\n+┊  ┊14┊})\n ┊11┊15┊export class UnsplashApi {\n ┊12┊16┊  baseURL = 'https://api.unsplash.com/';\n ┊13┊17┊\n```\n\n[}]: #\n\nHere's how to register the UnsplashApi provider in Chats module:\n\n[{]: <helper> (diffStep \"13.5\" files=\"modules/chats/index.ts\" module=\"server\")\n\n#### [__Server__ Step 13.5: Use Dependency Injection](https://github.com/Urigo/WhatsApp-Clone-Server/commit/ccb6a96)\n\n##### Changed modules&#x2F;chats&#x2F;index.ts\n```diff\n@@ -11,7 +11,7 @@\n ┊11┊11┊  type Message {\n ┊12┊12┊    id: ID!\n ┊13┊13┊    content: String!\n-┊14┊  ┊    createdAt: Date!\n+┊  ┊14┊    createdAt: DateTime!\n ┊15┊15┊    chat: Chat\n ┊16┊16┊    sender: User\n ┊17┊17┊    recipient: User\n```\n```diff\n@@ -94,7 +94,7 @@\n ┊ 94┊ 94┊      return participant ? participant.name : null;\n ┊ 95┊ 95┊    },\n ┊ 96┊ 96┊\n-┊ 97┊   ┊    async picture(chat, args, { currentUser, db, unsplashApi }) {\n+┊   ┊ 97┊    async picture(chat, args, { currentUser, db, injector }) {\n ┊ 98┊ 98┊      if (!currentUser) return null;\n ┊ 99┊ 99┊\n ┊100┊100┊      const { rows } = await db.query(sql`\n```\n```diff\n@@ -107,7 +107,7 @@\n ┊107┊107┊\n ┊108┊108┊      return participant && participant.picture\n ┊109┊109┊        ? participant.picture\n-┊110┊   ┊        : unsplashApi.getRandomPhoto();\n+┊   ┊110┊        : injector.get(UnsplashApi).getRandomPhoto();\n ┊111┊111┊    },\n ┊112┊112┊\n ┊113┊113┊    async messages(chat, args, { db }) {\n```\n```diff\n@@ -335,9 +335,5 @@\n ┊335┊335┊  typeDefs,\n ┊336┊336┊  resolvers,\n ┊337┊337┊  imports: () => [commonModule, usersModule],\n-┊338┊   ┊  context() {\n-┊339┊   ┊    return {\n-┊340┊   ┊      unsplashApi: new UnsplashApi(),\n-┊341┊   ┊    };\n-┊342┊   ┊  },\n+┊   ┊338┊  providers: () => [UnsplashApi],\n ┊343┊339┊});\n```\n\n[}]: #\n\nPlease also take a look at `injector.get(UnsplashApi)` part. There's `injector` instance in every module's context that allows to consume providers and everything that is defined within DI. You simply pass a class / token to the `get` method and GraphQL Modules takes care of the rest.\n\n**What are the benefits of DI?**\n\nYou can have a different implementation of Users based on the same interface. Maybe right now you're using PostgreSQL but at some point a project will be migrated to MongoDB. You could do it through GraphQL context, of course but with Dependency Injection, GraphQL Modules is able to tell you exactly what's missing and where. It reduces boiler plate because instantiation is done by the injector, code is loosely coupled.\n\nHelps maintainability but also comes with few disadvantages. It's a bit complex concept to learn and what could be done on compile time (TypeScript) is moved to run-time.\n\nYou might find DI useful while testing. Let's say you want to test a query that involves `UnsplashApi` provider, you simply replace it with a mocked version without touching the context or internals and you get the expected result every single time.\n\nWe know there's only one provider by far, the `UnsplashApi`, but we're going to implement more and more in following steps.\n\n#### Continuing with DI\n\nWe want to have everything easily accesible and DI helps with that so let's move on and continue migrating things.\n\nOne of the shared objects is database connection and we're going to create a Database provider:\n\n[{]: <helper> (diffStep \"13.6\" files=\"modules/common/database.provider.ts\" module=\"server\")\n\n#### [__Server__ Step 13.6: Define Database provider](https://github.com/Urigo/WhatsApp-Clone-Server/commit/492309e)\n\n##### Added modules&#x2F;common&#x2F;database.provider.ts\n```diff\n@@ -0,0 +1,26 @@\n+┊  ┊ 1┊import { Injectable, ProviderScope } from '@graphql-modules/di';\n+┊  ┊ 2┊import { OnResponse } from '@graphql-modules/core';\n+┊  ┊ 3┊import { Pool, PoolClient } from 'pg';\n+┊  ┊ 4┊\n+┊  ┊ 5┊@Injectable({\n+┊  ┊ 6┊  scope: ProviderScope.Session,\n+┊  ┊ 7┊})\n+┊  ┊ 8┊export class Database implements OnResponse {\n+┊  ┊ 9┊  private instance: PoolClient;\n+┊  ┊10┊\n+┊  ┊11┊  constructor(private pool: Pool) {}\n+┊  ┊12┊\n+┊  ┊13┊  async onRequest() {\n+┊  ┊14┊    this.instance = await this.pool.connect();\n+┊  ┊15┊  }\n+┊  ┊16┊\n+┊  ┊17┊  onResponse() {\n+┊  ┊18┊    if (this.instance) {\n+┊  ┊19┊      this.instance.release();\n+┊  ┊20┊    }\n+┊  ┊21┊  }\n+┊  ┊22┊\n+┊  ┊23┊  async getClient() {\n+┊  ┊24┊    return this.instance;\n+┊  ┊25┊  }\n+┊  ┊26┊}\n```\n\n[}]: #\n\nThings we did there:\n- Session scope was used, which makes sure our provider is created and destroyed on every GraphQL Operation\n- `onRequest` hook is called when a GraphQL Operation starts and we create a database connection in it.\n- `onResponse` hook is triggered when GraphQL Response is about to be sent to the consumer, so we destroy the connection there.\n- `getClient` method exposes the connection\n- `Pool` in constructor means we expect `Pool` to be injected into `Database` provider.\n\nNow we can define `Pool` token and register `Database`:\n\n[{]: <helper> (diffStep \"13.6\" files=\"modules/common/index.ts\" module=\"server\")\n\n#### [__Server__ Step 13.6: Define Database provider](https://github.com/Urigo/WhatsApp-Clone-Server/commit/492309e)\n\n##### Changed modules&#x2F;common&#x2F;index.ts\n```diff\n@@ -1,8 +1,10 @@\n ┊ 1┊ 1┊import { GraphQLModule } from '@graphql-modules/core';\n ┊ 2┊ 2┊import { gql } from 'apollo-server-express';\n ┊ 3┊ 3┊import { GraphQLDateTime } from 'graphql-iso-date';\n+┊  ┊ 4┊import { Pool } from 'pg';\n ┊ 4┊ 5┊import { pool } from '../../db';\n ┊ 5┊ 6┊import { Resolvers } from '../../types/graphql';\n+┊  ┊ 7┊import { Database } from './database.provider';\n ┊ 6┊ 8┊\n ┊ 7┊ 9┊const { PostgresPubSub } = require('graphql-postgres-subscriptions');\n ┊ 8┊10┊\n```\n```diff\n@@ -38,6 +40,13 @@\n ┊38┊40┊  name: 'common',\n ┊39┊41┊  typeDefs,\n ┊40┊42┊  resolvers,\n+┊  ┊43┊  providers: () => [\n+┊  ┊44┊    {\n+┊  ┊45┊      provide: Pool,\n+┊  ┊46┊      useValue: pool,\n+┊  ┊47┊    },\n+┊  ┊48┊    Database,\n+┊  ┊49┊  ],\n ┊41┊50┊  async context({ res, connection }) {\n ┊42┊51┊    let db;\n```\n\n[}]: #\n\n[{]: <helper> (diffStep \"13.6\" files=\"modules/index.ts\" module=\"server\")\n\n#### [__Server__ Step 13.6: Define Database provider](https://github.com/Urigo/WhatsApp-Clone-Server/commit/492309e)\n\n\n\n[}]: #\n\n#### Creating Users and Chats services\n\nIt's not really recommended to put logic in resolvers so we're going to create a layer with business logic. A good example of that are Users and Chats modules so let's start with the former.\n\nWe're going to create `Users` service and move `Query.users` logic into `findAllExcept` method:\n\n[{]: <helper> (diffStep \"13.7\" files=\"modules/users/users.provider.ts,modules/users/index.ts\" module=\"server\")\n\n#### [__Server__ Step 13.7: Basic User provider](https://github.com/Urigo/WhatsApp-Clone-Server/commit/06ff40a)\n\n##### Changed modules&#x2F;users&#x2F;index.ts\n```diff\n@@ -9,6 +9,7 @@\n ┊ 9┊ 9┊import { pool } from '../../db';\n ┊10┊10┊import { validateLength, validatePassword } from '../../validators';\n ┊11┊11┊import { Resolvers } from '../../types/graphql';\n+┊  ┊12┊import { Users } from './users.provider';\n ┊12┊13┊\n ┊13┊14┊const typeDefs = gql`\n ┊14┊15┊  type User {\n```\n```diff\n@@ -38,14 +39,10 @@\n ┊38┊39┊    me(root, args, { currentUser }) {\n ┊39┊40┊      return currentUser || null;\n ┊40┊41┊    },\n-┊41┊  ┊    async users(root, args, { currentUser, db }) {\n+┊  ┊42┊    async users(root, args, { currentUser, injector }) {\n ┊42┊43┊      if (!currentUser) return [];\n ┊43┊44┊\n-┊44┊  ┊      const { rows } = await db.query(sql`\n-┊45┊  ┊        SELECT * FROM users WHERE users.id != ${currentUser.id}\n-┊46┊  ┊      `);\n-┊47┊  ┊\n-┊48┊  ┊      return rows;\n+┊  ┊45┊      return injector.get(Users).findAllExcept(currentUser.id);\n ┊49┊46┊    },\n ┊50┊47┊  },\n ┊51┊48┊  Mutation: {\n```\n```diff\n@@ -108,6 +105,7 @@\n ┊108┊105┊  typeDefs,\n ┊109┊106┊  resolvers,\n ┊110┊107┊  imports: () => [commonModule],\n+┊   ┊108┊  providers: () => [Users],\n ┊111┊109┊  async context(session) {\n ┊112┊110┊    let currentUser;\n ┊113┊111┊\n```\n\n##### Added modules&#x2F;users&#x2F;users.provider.ts\n```diff\n@@ -0,0 +1,19 @@\n+┊  ┊ 1┊import { Injectable, Inject, ProviderScope } from '@graphql-modules/di';\n+┊  ┊ 2┊import sql from 'sql-template-strings';\n+┊  ┊ 3┊import { Database } from '../common/database.provider';\n+┊  ┊ 4┊\n+┊  ┊ 5┊@Injectable({\n+┊  ┊ 6┊  scope: ProviderScope.Session,\n+┊  ┊ 7┊})\n+┊  ┊ 8┊export class Users {\n+┊  ┊ 9┊  @Inject() private db: Database;\n+┊  ┊10┊\n+┊  ┊11┊  async findAllExcept(userId: string) {\n+┊  ┊12┊    const db = await this.db.getClient();\n+┊  ┊13┊    const { rows } = await db.query(\n+┊  ┊14┊      sql`SELECT * FROM users WHERE id != ${userId}`\n+┊  ┊15┊    );\n+┊  ┊16┊\n+┊  ┊17┊    return rows;\n+┊  ┊18┊  }\n+┊  ┊19┊}\n```\n\n[}]: #\n\nA very interesting thing to notice is `@Inject()` decorator.\n\n```ts\n@Inject() private db: Database;\n```\n\nThe @Inject, well... injects `Database` provider as `db` property so you don't have to use the `constructor`.\n\nBack to the Users service. It's very similar to what we did with the `UnsplashApi` so let's move on and implement more methods.\n\n[{]: <helper> (diffStep \"13.8\" module=\"server\")\n\n#### [__Server__ Step 13.8: Implement newUser and findByUsername](https://github.com/Urigo/WhatsApp-Clone-Server/commit/3821a93)\n\n##### Changed modules&#x2F;users&#x2F;index.ts\n```diff\n@@ -46,11 +46,8 @@\n ┊46┊46┊    },\n ┊47┊47┊  },\n ┊48┊48┊  Mutation: {\n-┊49┊  ┊    async signIn(root, { username, password }, { db, res }) {\n-┊50┊  ┊      const { rows } = await db.query(\n-┊51┊  ┊        sql`SELECT * FROM users WHERE username = ${username}`\n-┊52┊  ┊      );\n-┊53┊  ┊      const user = rows[0];\n+┊  ┊49┊    async signIn(root, { username, password }, { injector, res }) {\n+┊  ┊50┊      const user = await injector.get(Users).findByUsername(username);\n ┊54┊51┊\n ┊55┊52┊      if (!user) {\n ┊56┊53┊        throw new Error('user not found');\n```\n```diff\n@@ -69,7 +66,11 @@\n ┊69┊66┊      return user;\n ┊70┊67┊    },\n ┊71┊68┊\n-┊72┊  ┊    async signUp(root, { name, username, password, passwordConfirm }, { db }) {\n+┊  ┊69┊    async signUp(\n+┊  ┊70┊      root,\n+┊  ┊71┊      { name, username, password, passwordConfirm },\n+┊  ┊72┊      { injector }\n+┊  ┊73┊    ) {\n ┊73┊74┊      validateLength('req.name', name, 3, 50);\n ┊74┊75┊      validateLength('req.username', name, 3, 18);\n ┊75┊76┊      validatePassword('req.password', password);\n```\n```diff\n@@ -78,24 +79,18 @@\n ┊ 78┊ 79┊        throw Error(\"req.password and req.passwordConfirm don't match\");\n ┊ 79┊ 80┊      }\n ┊ 80┊ 81┊\n-┊ 81┊   ┊      const existingUserQuery = await db.query(\n-┊ 82┊   ┊        sql`SELECT * FROM users WHERE username = ${username}`\n-┊ 83┊   ┊      );\n-┊ 84┊   ┊      if (existingUserQuery.rows[0]) {\n+┊   ┊ 82┊      const existingUser = await injector.get(Users).findByUsername(username);\n+┊   ┊ 83┊      if (existingUser) {\n ┊ 85┊ 84┊        throw Error('username already exists');\n ┊ 86┊ 85┊      }\n ┊ 87┊ 86┊\n-┊ 88┊   ┊      const passwordHash = bcrypt.hashSync(password, bcrypt.genSaltSync(8));\n+┊   ┊ 87┊      const createdUser = await injector.get(Users).newUser({\n+┊   ┊ 88┊        username,\n+┊   ┊ 89┊        password,\n+┊   ┊ 90┊        name,\n+┊   ┊ 91┊      });\n ┊ 89┊ 92┊\n-┊ 90┊   ┊      const createdUserQuery = await db.query(sql`\n-┊ 91┊   ┊        INSERT INTO users(password, picture, username, name)\n-┊ 92┊   ┊        VALUES(${passwordHash}, '', ${username}, ${name})\n-┊ 93┊   ┊        RETURNING *\n-┊ 94┊   ┊      `);\n-┊ 95┊   ┊\n-┊ 96┊   ┊      const user = createdUserQuery.rows[0];\n-┊ 97┊   ┊\n-┊ 98┊   ┊      return user;\n+┊   ┊ 93┊      return createdUser;\n ┊ 99┊ 94┊    },\n ┊100┊ 95┊  },\n ┊101┊ 96┊};\n```\n\n##### Changed modules&#x2F;users&#x2F;users.provider.ts\n```diff\n@@ -1,5 +1,6 @@\n ┊1┊1┊import { Injectable, Inject, ProviderScope } from '@graphql-modules/di';\n ┊2┊2┊import sql from 'sql-template-strings';\n+┊ ┊3┊import bcrypt from 'bcrypt';\n ┊3┊4┊import { Database } from '../common/database.provider';\n ┊4┊5┊\n ┊5┊6┊@Injectable({\n```\n```diff\n@@ -16,4 +17,34 @@\n ┊16┊17┊\n ┊17┊18┊    return rows;\n ┊18┊19┊  }\n+┊  ┊20┊\n+┊  ┊21┊  async findByUsername(username: string) {\n+┊  ┊22┊    const db = await this.db.getClient();\n+┊  ┊23┊    const { rows } = await db.query(\n+┊  ┊24┊      sql`SELECT * FROM users WHERE username = ${username}`\n+┊  ┊25┊    );\n+┊  ┊26┊\n+┊  ┊27┊    return rows[0] || null;\n+┊  ┊28┊  }\n+┊  ┊29┊\n+┊  ┊30┊  async newUser({\n+┊  ┊31┊    username,\n+┊  ┊32┊    name,\n+┊  ┊33┊    password,\n+┊  ┊34┊  }: {\n+┊  ┊35┊    username: string;\n+┊  ┊36┊    name: string;\n+┊  ┊37┊    password: string;\n+┊  ┊38┊  }) {\n+┊  ┊39┊    const db = await this.db.getClient();\n+┊  ┊40┊    const passwordHash = bcrypt.hashSync(password, bcrypt.genSaltSync(8));\n+┊  ┊41┊    const createdUserQuery = await db.query(sql`\n+┊  ┊42┊        INSERT INTO users(password, picture, username, name)\n+┊  ┊43┊        VALUES(${passwordHash}, '', ${username}, ${name})\n+┊  ┊44┊        RETURNING *\n+┊  ┊45┊      `);\n+┊  ┊46┊    const user = createdUserQuery.rows[0];\n+┊  ┊47┊\n+┊  ┊48┊    return user;\n+┊  ┊49┊  }\n ┊19┊50┊}\n```\n\n[}]: #\n[{]: <helper> (diffStep \"13.9\" module=\"server\")\n\n#### [__Server__ Step 13.9: Implement findById and use in Chats module](https://github.com/Urigo/WhatsApp-Clone-Server/commit/e8ec3e2)\n\n##### Changed modules&#x2F;chats&#x2F;index.ts\n```diff\n@@ -6,6 +6,7 @@\n ┊ 6┊ 6┊import { Message, Chat, pool } from '../../db';\n ┊ 7┊ 7┊import { Resolvers } from '../../types/graphql';\n ┊ 8┊ 8┊import { UnsplashApi } from './unsplash.api';\n+┊  ┊ 9┊import { Users } from './../users/users.provider';\n ┊ 9┊10┊\n ┊10┊11┊const typeDefs = gql`\n ┊11┊12┊  type Message {\n```\n```diff\n@@ -58,11 +59,8 @@\n ┊58┊59┊      return rows[0] || null;\n ┊59┊60┊    },\n ┊60┊61┊\n-┊61┊  ┊    async sender(message, args, { db }) {\n-┊62┊  ┊      const { rows } = await db.query(sql`\n-┊63┊  ┊        SELECT * FROM users WHERE id = ${message.sender_user_id}\n-┊64┊  ┊      `);\n-┊65┊  ┊      return rows[0] || null;\n+┊  ┊62┊    async sender(message, args, { injector }) {\n+┊  ┊63┊      return injector.get(Users).findById(message.sender_user_id);\n ┊66┊64┊    },\n ┊67┊65┊\n ┊68┊66┊    async recipient(message, args, { db }) {\n```\n\n##### Changed modules&#x2F;users&#x2F;users.provider.ts\n```diff\n@@ -9,6 +9,15 @@\n ┊ 9┊ 9┊export class Users {\n ┊10┊10┊  @Inject() private db: Database;\n ┊11┊11┊\n+┊  ┊12┊  async findById(userId: string) {\n+┊  ┊13┊    const db = await this.db.getClient();\n+┊  ┊14┊    const { rows } = await db.query(\n+┊  ┊15┊      sql`SELECT * FROM users WHERE id = ${userId}`\n+┊  ┊16┊    );\n+┊  ┊17┊\n+┊  ┊18┊    return rows[0] || null;\n+┊  ┊19┊  }\n+┊  ┊20┊\n ┊12┊21┊  async findAllExcept(userId: string) {\n ┊13┊22┊    const db = await this.db.getClient();\n ┊14┊23┊    const { rows } = await db.query(\n```\n\n[}]: #\n\nLet's now implement `Chats` service with two basic methods:\n\n[{]: <helper> (diffStep \"13.10\" module=\"server\")\n\n#### [__Server__ Step 13.10: Basic Chats provider](https://github.com/Urigo/WhatsApp-Clone-Server/commit/8dfec7c)\n\n##### Added modules&#x2F;chats&#x2F;chats.provider.ts\n```diff\n@@ -0,0 +1,34 @@\n+┊  ┊ 1┊import { Injectable, Inject, ProviderScope } from '@graphql-modules/di';\n+┊  ┊ 2┊import sql from 'sql-template-strings';\n+┊  ┊ 3┊import { Database } from '../common/database.provider';\n+┊  ┊ 4┊\n+┊  ┊ 5┊@Injectable({\n+┊  ┊ 6┊  scope: ProviderScope.Session,\n+┊  ┊ 7┊})\n+┊  ┊ 8┊export class Chats {\n+┊  ┊ 9┊  @Inject() private db: Database;\n+┊  ┊10┊\n+┊  ┊11┊  async findChatsByUser(userId: string) {\n+┊  ┊12┊    const db = await this.db.getClient();\n+┊  ┊13┊\n+┊  ┊14┊    const { rows } = await db.query(sql`\n+┊  ┊15┊      SELECT chats.* FROM chats, chats_users\n+┊  ┊16┊      WHERE chats.id = chats_users.chat_id\n+┊  ┊17┊      AND chats_users.user_id = ${userId}\n+┊  ┊18┊    `);\n+┊  ┊19┊\n+┊  ┊20┊    return rows;\n+┊  ┊21┊  }\n+┊  ┊22┊\n+┊  ┊23┊  async findChatByUser({ chatId, userId }: { chatId: string; userId: string }) {\n+┊  ┊24┊    const db = await this.db.getClient();\n+┊  ┊25┊    const { rows } = await db.query(sql`\n+┊  ┊26┊      SELECT chats.* FROM chats, chats_users\n+┊  ┊27┊      WHERE chats_users.chat_id = ${chatId}\n+┊  ┊28┊      AND chats.id = chats_users.chat_id\n+┊  ┊29┊      AND chats_users.user_id = ${userId}\n+┊  ┊30┊    `);\n+┊  ┊31┊\n+┊  ┊32┊    return rows[0] || null;\n+┊  ┊33┊  }\n+┊  ┊34┊}\n```\n\n##### Changed modules&#x2F;chats&#x2F;index.ts\n```diff\n@@ -7,6 +7,7 @@\n ┊ 7┊ 7┊import { Resolvers } from '../../types/graphql';\n ┊ 8┊ 8┊import { UnsplashApi } from './unsplash.api';\n ┊ 9┊ 9┊import { Users } from './../users/users.provider';\n+┊  ┊10┊import { Chats } from './chats.provider';\n ┊10┊11┊\n ┊11┊12┊const typeDefs = gql`\n ┊12┊13┊  type Message {\n```\n```diff\n@@ -138,29 +139,18 @@\n ┊138┊139┊  },\n ┊139┊140┊\n ┊140┊141┊  Query: {\n-┊141┊   ┊    async chats(root, args, { currentUser, db }) {\n+┊   ┊142┊    async chats(root, args, { currentUser, injector }) {\n ┊142┊143┊      if (!currentUser) return [];\n ┊143┊144┊\n-┊144┊   ┊      const { rows } = await db.query(sql`\n-┊145┊   ┊        SELECT chats.* FROM chats, chats_users\n-┊146┊   ┊        WHERE chats.id = chats_users.chat_id\n-┊147┊   ┊        AND chats_users.user_id = ${currentUser.id}\n-┊148┊   ┊      `);\n-┊149┊   ┊\n-┊150┊   ┊      return rows;\n+┊   ┊145┊      return injector.get(Chats).findChatsByUser(currentUser.id);\n ┊151┊146┊    },\n ┊152┊147┊\n-┊153┊   ┊    async chat(root, { chatId }, { currentUser, db }) {\n+┊   ┊148┊    async chat(root, { chatId }, { currentUser, injector }) {\n ┊154┊149┊      if (!currentUser) return null;\n ┊155┊150┊\n-┊156┊   ┊      const { rows } = await db.query(sql`\n-┊157┊   ┊        SELECT chats.* FROM chats, chats_users\n-┊158┊   ┊        WHERE chats_users.chat_id = ${chatId}\n-┊159┊   ┊        AND chats.id = chats_users.chat_id\n-┊160┊   ┊        AND chats_users.user_id = ${currentUser.id}\n-┊161┊   ┊      `);\n-┊162┊   ┊\n-┊163┊   ┊      return rows[0] ? rows[0] : null;\n+┊   ┊151┊      return injector\n+┊   ┊152┊        .get(Chats)\n+┊   ┊153┊        .findChatByUser({ chatId, userId: currentUser.id });\n ┊164┊154┊    },\n ┊165┊155┊  },\n ┊166┊156┊\n```\n```diff\n@@ -333,5 +323,5 @@\n ┊333┊323┊  typeDefs,\n ┊334┊324┊  resolvers,\n ┊335┊325┊  imports: () => [commonModule, usersModule],\n-┊336┊   ┊  providers: () => [UnsplashApi],\n+┊   ┊326┊  providers: () => [UnsplashApi, Chats],\n ┊337┊327┊});\n```\n\n[}]: #\n\nIt looks exatly like `Users` and also has only `database` provider in it.\n\nWe're going to move on and more things:\n\n[{]: <helper> (diffStep \"13.11\" module=\"server\")\n\n#### [__Server__ Step 13.11: Implement findChatById](https://github.com/Urigo/WhatsApp-Clone-Server/commit/c513f48)\n\n##### Changed modules&#x2F;chats&#x2F;chats.provider.ts\n```diff\n@@ -31,4 +31,12 @@\n ┊31┊31┊\n ┊32┊32┊    return rows[0] || null;\n ┊33┊33┊  }\n+┊  ┊34┊\n+┊  ┊35┊  async findChatById(chatId: string) {\n+┊  ┊36┊    const db = await this.db.getClient();\n+┊  ┊37┊    const { rows } = await db.query(sql`\n+┊  ┊38┊      SELECT * FROM chats WHERE id = ${chatId}\n+┊  ┊39┊    `);\n+┊  ┊40┊    return rows[0] || null;\n+┊  ┊41┊  }\n ┊34┊42┊}\n```\n\n##### Changed modules&#x2F;chats&#x2F;index.ts\n```diff\n@@ -53,11 +53,8 @@\n ┊53┊53┊      return new Date(message.created_at);\n ┊54┊54┊    },\n ┊55┊55┊\n-┊56┊  ┊    async chat(message, args, { db }) {\n-┊57┊  ┊      const { rows } = await db.query(sql`\n-┊58┊  ┊        SELECT * FROM chats WHERE id = ${message.chat_id}\n-┊59┊  ┊      `);\n-┊60┊  ┊      return rows[0] || null;\n+┊  ┊56┊    async chat(message, args, { injector }) {\n+┊  ┊57┊      return injector.get(Chats).findChatById(message.chat_id);\n ┊61┊58┊    },\n ┊62┊59┊\n ┊63┊60┊    async sender(message, args, { injector }) {\n```\n\n[}]: #\n[{]: <helper> (diffStep \"13.12\" module=\"server\")\n\n#### [__Server__ Step 13.12: Find chat&#x27;s messages](https://github.com/Urigo/WhatsApp-Clone-Server/commit/11f45aa)\n\n##### Changed modules&#x2F;chats&#x2F;chats.provider.ts\n```diff\n@@ -39,4 +39,25 @@\n ┊39┊39┊    `);\n ┊40┊40┊    return rows[0] || null;\n ┊41┊41┊  }\n+┊  ┊42┊\n+┊  ┊43┊  async findMessagesByChat(chatId: string) {\n+┊  ┊44┊    const db = await this.db.getClient();\n+┊  ┊45┊    const { rows } = await db.query(\n+┊  ┊46┊      sql`SELECT * FROM messages WHERE chat_id = ${chatId}`\n+┊  ┊47┊    );\n+┊  ┊48┊\n+┊  ┊49┊    return rows;\n+┊  ┊50┊  }\n+┊  ┊51┊\n+┊  ┊52┊  async lastMessage(chatId: string) {\n+┊  ┊53┊    const db = await this.db.getClient();\n+┊  ┊54┊    const { rows } = await db.query(sql`\n+┊  ┊55┊      SELECT * FROM messages\n+┊  ┊56┊      WHERE chat_id = ${chatId}\n+┊  ┊57┊      ORDER BY created_at DESC\n+┊  ┊58┊      LIMIT 1\n+┊  ┊59┊    `);\n+┊  ┊60┊\n+┊  ┊61┊    return rows[0];\n+┊  ┊62┊  }\n ┊42┊63┊}\n```\n\n##### Changed modules&#x2F;chats&#x2F;index.ts\n```diff\n@@ -106,22 +106,12 @@\n ┊106┊106┊        : injector.get(UnsplashApi).getRandomPhoto();\n ┊107┊107┊    },\n ┊108┊108┊\n-┊109┊   ┊    async messages(chat, args, { db }) {\n-┊110┊   ┊      const { rows } = await db.query(\n-┊111┊   ┊        sql`SELECT * FROM messages WHERE chat_id = ${chat.id}`\n-┊112┊   ┊      );\n-┊113┊   ┊\n-┊114┊   ┊      return rows;\n+┊   ┊109┊    async messages(chat, args, { injector }) {\n+┊   ┊110┊      return injector.get(Chats).findMessagesByChat(chat.id);\n ┊115┊111┊    },\n ┊116┊112┊\n-┊117┊   ┊    async lastMessage(chat, args, { db }) {\n-┊118┊   ┊      const { rows } = await db.query(sql`\n-┊119┊   ┊        SELECT * FROM messages\n-┊120┊   ┊        WHERE chat_id = ${chat.id}\n-┊121┊   ┊        ORDER BY created_at DESC\n-┊122┊   ┊        LIMIT 1`);\n-┊123┊   ┊\n-┊124┊   ┊      return rows[0];\n+┊   ┊113┊    async lastMessage(chat, args, { injector }) {\n+┊   ┊114┊      return injector.get(Chats).lastMessage(chat.id);\n ┊125┊115┊    },\n ┊126┊116┊\n ┊127┊117┊    async participants(chat, args, { db }) {\n```\n\n[}]: #\n[{]: <helper> (diffStep \"13.13\" module=\"server\")\n\n#### [__Server__ Step 13.13: Find first participant](https://github.com/Urigo/WhatsApp-Clone-Server/commit/f250457)\n\n##### Changed modules&#x2F;chats&#x2F;chats.provider.ts\n```diff\n@@ -60,4 +60,16 @@\n ┊60┊60┊\n ┊61┊61┊    return rows[0];\n ┊62┊62┊  }\n+┊  ┊63┊\n+┊  ┊64┊  async firstRecipient({ chatId, userId }: { chatId: string; userId: string }) {\n+┊  ┊65┊    const db = await this.db.getClient();\n+┊  ┊66┊    const { rows } = await db.query(sql`\n+┊  ┊67┊      SELECT users.* FROM users, chats_users\n+┊  ┊68┊      WHERE users.id != ${userId}\n+┊  ┊69┊      AND users.id = chats_users.user_id\n+┊  ┊70┊      AND chats_users.chat_id = ${chatId}\n+┊  ┊71┊    `);\n+┊  ┊72┊\n+┊  ┊73┊    return rows[0] || null;\n+┊  ┊74┊  }\n ┊63┊75┊}\n```\n\n##### Changed modules&#x2F;chats&#x2F;index.ts\n```diff\n@@ -61,13 +61,11 @@\n ┊61┊61┊      return injector.get(Users).findById(message.sender_user_id);\n ┊62┊62┊    },\n ┊63┊63┊\n-┊64┊  ┊    async recipient(message, args, { db }) {\n-┊65┊  ┊      const { rows } = await db.query(sql`\n-┊66┊  ┊        SELECT users.* FROM users, chats_users\n-┊67┊  ┊        WHERE chats_users.user_id != ${message.sender_user_id}\n-┊68┊  ┊        AND chats_users.chat_id = ${message.chat_id}\n-┊69┊  ┊      `);\n-┊70┊  ┊      return rows[0] || null;\n+┊  ┊64┊    async recipient(message, args, { injector }) {\n+┊  ┊65┊      return injector.get(Chats).firstRecipient({\n+┊  ┊66┊        chatId: message.chat_id,\n+┊  ┊67┊        userId: message.sender_user_id,\n+┊  ┊68┊      });\n ┊71┊69┊    },\n ┊72┊70┊\n ┊73┊71┊    isMine(message, args, { currentUser }) {\n```\n```diff\n@@ -76,16 +74,13 @@\n ┊76┊74┊  },\n ┊77┊75┊\n ┊78┊76┊  Chat: {\n-┊79┊  ┊    async name(chat, args, { currentUser, db }) {\n+┊  ┊77┊    async name(chat, args, { currentUser, injector }) {\n ┊80┊78┊      if (!currentUser) return null;\n ┊81┊79┊\n-┊82┊  ┊      const { rows } = await db.query(sql`\n-┊83┊  ┊        SELECT users.* FROM users, chats_users\n-┊84┊  ┊        WHERE users.id != ${currentUser.id}\n-┊85┊  ┊        AND users.id = chats_users.user_id\n-┊86┊  ┊        AND chats_users.chat_id = ${chat.id}`);\n-┊87┊  ┊\n-┊88┊  ┊      const participant = rows[0];\n+┊  ┊80┊      const participant = await injector.get(Chats).firstRecipient({\n+┊  ┊81┊        chatId: chat.id,\n+┊  ┊82┊        userId: currentUser.id,\n+┊  ┊83┊      });\n ┊89┊84┊\n ┊90┊85┊      return participant ? participant.name : null;\n ┊91┊86┊    },\n```\n```diff\n@@ -93,13 +88,10 @@\n ┊ 93┊ 88┊    async picture(chat, args, { currentUser, db, injector }) {\n ┊ 94┊ 89┊      if (!currentUser) return null;\n ┊ 95┊ 90┊\n-┊ 96┊   ┊      const { rows } = await db.query(sql`\n-┊ 97┊   ┊        SELECT users.* FROM users, chats_users\n-┊ 98┊   ┊        WHERE users.id != ${currentUser.id}\n-┊ 99┊   ┊        AND users.id = chats_users.user_id\n-┊100┊   ┊        AND chats_users.chat_id = ${chat.id}`);\n-┊101┊   ┊\n-┊102┊   ┊      const participant = rows[0];\n+┊   ┊ 91┊      const participant = await injector.get(Chats).firstRecipient({\n+┊   ┊ 92┊        chatId: chat.id,\n+┊   ┊ 93┊        userId: currentUser.id,\n+┊   ┊ 94┊      });\n ┊103┊ 95┊\n ┊104┊ 96┊      return participant && participant.picture\n ┊105┊ 97┊        ? participant.picture\n```\n\n[}]: #\n[{]: <helper> (diffStep \"13.14\" module=\"server\")\n\n#### [__Server__ Step 13.14: Find all participants](https://github.com/Urigo/WhatsApp-Clone-Server/commit/b4b3488)\n\n##### Changed modules&#x2F;chats&#x2F;chats.provider.ts\n```diff\n@@ -72,4 +72,15 @@\n ┊72┊72┊\n ┊73┊73┊    return rows[0] || null;\n ┊74┊74┊  }\n+┊  ┊75┊\n+┊  ┊76┊  async participants(chatId: string) {\n+┊  ┊77┊    const db = await this.db.getClient();\n+┊  ┊78┊    const { rows } = await db.query(sql`\n+┊  ┊79┊      SELECT users.* FROM users, chats_users\n+┊  ┊80┊      WHERE chats_users.chat_id = ${chatId}\n+┊  ┊81┊      AND chats_users.user_id = users.id\n+┊  ┊82┊    `);\n+┊  ┊83┊\n+┊  ┊84┊    return rows;\n+┊  ┊85┊  }\n ┊75┊86┊}\n```\n\n##### Changed modules&#x2F;chats&#x2F;index.ts\n```diff\n@@ -106,14 +106,8 @@\n ┊106┊106┊      return injector.get(Chats).lastMessage(chat.id);\n ┊107┊107┊    },\n ┊108┊108┊\n-┊109┊   ┊    async participants(chat, args, { db }) {\n-┊110┊   ┊      const { rows } = await db.query(sql`\n-┊111┊   ┊        SELECT users.* FROM users, chats_users\n-┊112┊   ┊        WHERE chats_users.chat_id = ${chat.id}\n-┊113┊   ┊        AND chats_users.user_id = users.id\n-┊114┊   ┊      `);\n-┊115┊   ┊\n-┊116┊   ┊      return rows;\n+┊   ┊109┊    async participants(chat, args, { injector }) {\n+┊   ┊110┊      return injector.get(Chats).participants(chat.id);\n ┊117┊111┊    },\n ┊118┊112┊  },\n```\n\n[}]: #\n[{]: <helper> (diffStep \"13.15\" module=\"server\")\n\n#### [__Server__ Step 13.15: Check if a user belongs to a chat](https://github.com/Urigo/WhatsApp-Clone-Server/commit/bccaac7)\n\n##### Changed modules&#x2F;chats&#x2F;chats.provider.ts\n```diff\n@@ -83,4 +83,15 @@\n ┊83┊83┊\n ┊84┊84┊    return rows;\n ┊85┊85┊  }\n+┊  ┊86┊\n+┊  ┊87┊  async isParticipant({ chatId, userId }: { chatId: string; userId: string }) {\n+┊  ┊88┊    const db = await this.db.getClient();\n+┊  ┊89┊    const { rows } = await db.query(sql`\n+┊  ┊90┊      SELECT * FROM chats_users\n+┊  ┊91┊      WHERE chat_id = ${chatId}\n+┊  ┊92┊      AND user_id = ${userId}\n+┊  ┊93┊    `);\n+┊  ┊94┊\n+┊  ┊95┊    return !!rows.length;\n+┊  ┊96┊  }\n ┊86┊97┊}\n```\n\n##### Changed modules&#x2F;chats&#x2F;index.ts\n```diff\n@@ -243,16 +243,14 @@\n ┊243┊243┊        async (\n ┊244┊244┊          { messageAdded }: { messageAdded: Message },\n ┊245┊245┊          args,\n-┊246┊   ┊          { currentUser }\n+┊   ┊246┊          { currentUser, injector }\n ┊247┊247┊        ) => {\n ┊248┊248┊          if (!currentUser) return false;\n ┊249┊249┊\n-┊250┊   ┊          const { rows } = await pool.query(sql`\n-┊251┊   ┊            SELECT * FROM chats_users\n-┊252┊   ┊            WHERE chat_id = ${messageAdded.chat_id}\n-┊253┊   ┊            AND user_id = ${currentUser.id}`);\n-┊254┊   ┊\n-┊255┊   ┊          return !!rows.length;\n+┊   ┊250┊          return injector.get(Chats).isParticipant({\n+┊   ┊251┊            chatId: messageAdded.chat_id,\n+┊   ┊252┊            userId: currentUser.id,\n+┊   ┊253┊          });\n ┊256┊254┊        }\n ┊257┊255┊      ),\n ┊258┊256┊    },\n```\n```diff\n@@ -260,15 +258,17 @@\n ┊260┊258┊    chatAdded: {\n ┊261┊259┊      subscribe: withFilter(\n ┊262┊260┊        (root, args, { pubsub }) => pubsub.asyncIterator('chatAdded'),\n-┊263┊   ┊        async ({ chatAdded }: { chatAdded: Chat }, args, { currentUser }) => {\n+┊   ┊261┊        async (\n+┊   ┊262┊          { chatAdded }: { chatAdded: Chat },\n+┊   ┊263┊          args,\n+┊   ┊264┊          { currentUser, injector }\n+┊   ┊265┊        ) => {\n ┊264┊266┊          if (!currentUser) return false;\n ┊265┊267┊\n-┊266┊   ┊          const { rows } = await pool.query(sql`\n-┊267┊   ┊            SELECT * FROM chats_users\n-┊268┊   ┊            WHERE chat_id = ${chatAdded.id}\n-┊269┊   ┊            AND user_id = ${currentUser.id}`);\n-┊270┊   ┊\n-┊271┊   ┊          return !!rows.length;\n+┊   ┊268┊          return injector.get(Chats).isParticipant({\n+┊   ┊269┊            chatId: chatAdded.id,\n+┊   ┊270┊            userId: currentUser.id,\n+┊   ┊271┊          });\n ┊272┊272┊        }\n ┊273┊273┊      ),\n ┊274┊274┊    },\n```\n```diff\n@@ -276,15 +276,17 @@\n ┊276┊276┊    chatRemoved: {\n ┊277┊277┊      subscribe: withFilter(\n ┊278┊278┊        (root, args, { pubsub }) => pubsub.asyncIterator('chatRemoved'),\n-┊279┊   ┊        async ({ targetChat }: { targetChat: Chat }, args, { currentUser }) => {\n+┊   ┊279┊        async (\n+┊   ┊280┊          { targetChat }: { targetChat: Chat },\n+┊   ┊281┊          args,\n+┊   ┊282┊          { currentUser, injector }\n+┊   ┊283┊        ) => {\n ┊280┊284┊          if (!currentUser) return false;\n ┊281┊285┊\n-┊282┊   ┊          const { rows } = await pool.query(sql`\n-┊283┊   ┊            SELECT * FROM chats_users\n-┊284┊   ┊            WHERE chat_id = ${targetChat.id}\n-┊285┊   ┊            AND user_id = ${currentUser.id}`);\n-┊286┊   ┊\n-┊287┊   ┊          return !!rows.length;\n+┊   ┊286┊          return injector.get(Chats).isParticipant({\n+┊   ┊287┊            chatId: targetChat.id,\n+┊   ┊288┊            userId: currentUser.id,\n+┊   ┊289┊          });\n ┊288┊290┊        }\n ┊289┊291┊      ),\n ┊290┊292┊    },\n```\n\n[}]: #\n\n#### Sharing PubSub\n\nOne of things that are still in the context is `PubSub`. Because we're moving an entire business logic into a separate layer and as part of GraphQL Module's providers we need to make sure that PubSub is accessible throug DI.\n\nLet's register the PubSub and migrate resolvers:\n\n[{]: <helper> (diffStep \"13.16\" module=\"server\")\n\n#### [__Server__ Step 13.16: Move PubSub to Dependency Injection](https://github.com/Urigo/WhatsApp-Clone-Server/commit/29d60b2)\n\n##### Changed context.ts\n```diff\n@@ -1,11 +1,9 @@\n-┊ 1┊  ┊import { PubSub } from 'apollo-server-express';\n ┊ 2┊ 1┊import { ModuleContext } from '@graphql-modules/core';\n ┊ 3┊ 2┊import { User } from './db';\n ┊ 4┊ 3┊import { Response } from 'express';\n ┊ 5┊ 4┊import { PoolClient } from 'pg';\n ┊ 6┊ 5┊\n ┊ 7┊ 6┊export type MyContext = {\n-┊ 8┊  ┊  pubsub: PubSub;\n ┊ 9┊ 7┊  currentUser: User;\n ┊10┊ 8┊  res: Response;\n ┊11┊ 9┊  db: PoolClient;\n```\n\n##### Changed modules&#x2F;chats&#x2F;index.ts\n```diff\n@@ -8,6 +8,7 @@\n ┊ 8┊ 8┊import { UnsplashApi } from './unsplash.api';\n ┊ 9┊ 9┊import { Users } from './../users/users.provider';\n ┊10┊10┊import { Chats } from './chats.provider';\n+┊  ┊11┊import { PubSub } from '../common/pubsub.provider';\n ┊11┊12┊\n ┊12┊13┊const typeDefs = gql`\n ┊13┊14┊  type Message {\n```\n```diff\n@@ -128,7 +129,7 @@\n ┊128┊129┊  },\n ┊129┊130┊\n ┊130┊131┊  Mutation: {\n-┊131┊   ┊    async addMessage(root, { chatId, content }, { currentUser, pubsub, db }) {\n+┊   ┊132┊    async addMessage(root, { chatId, content }, { currentUser, injector, db }) {\n ┊132┊133┊      if (!currentUser) return null;\n ┊133┊134┊\n ┊134┊135┊      const { rows } = await db.query(sql`\n```\n```diff\n@@ -139,14 +140,14 @@\n ┊139┊140┊\n ┊140┊141┊      const messageAdded = rows[0];\n ┊141┊142┊\n-┊142┊   ┊      pubsub.publish('messageAdded', {\n+┊   ┊143┊      injector.get(PubSub).publish('messageAdded', {\n ┊143┊144┊        messageAdded,\n ┊144┊145┊      });\n ┊145┊146┊\n ┊146┊147┊      return messageAdded;\n ┊147┊148┊    },\n ┊148┊149┊\n-┊149┊   ┊    async addChat(root, { recipientId }, { currentUser, pubsub, db }) {\n+┊   ┊150┊    async addChat(root, { recipientId }, { currentUser, injector, db }) {\n ┊150┊151┊      if (!currentUser) return null;\n ┊151┊152┊\n ┊152┊153┊      const { rows } = await db.query(sql`\n```\n```diff\n@@ -186,7 +187,7 @@\n ┊186┊187┊\n ┊187┊188┊        await db.query('COMMIT');\n ┊188┊189┊\n-┊189┊   ┊        pubsub.publish('chatAdded', {\n+┊   ┊190┊        injector.get(PubSub).publish('chatAdded', {\n ┊190┊191┊          chatAdded,\n ┊191┊192┊        });\n ┊192┊193┊\n```\n```diff\n@@ -197,7 +198,7 @@\n ┊197┊198┊      }\n ┊198┊199┊    },\n ┊199┊200┊\n-┊200┊   ┊    async removeChat(root, { chatId }, { currentUser, pubsub, db }) {\n+┊   ┊201┊    async removeChat(root, { chatId }, { currentUser, injector, db }) {\n ┊201┊202┊      if (!currentUser) return null;\n ┊202┊203┊\n ┊203┊204┊      try {\n```\n```diff\n@@ -221,7 +222,7 @@\n ┊221┊222┊          DELETE FROM chats WHERE chats.id = ${chatId}\n ┊222┊223┊        `);\n ┊223┊224┊\n-┊224┊   ┊        pubsub.publish('chatRemoved', {\n+┊   ┊225┊        injector.get(PubSub).publish('chatRemoved', {\n ┊225┊226┊          chatRemoved: chat.id,\n ┊226┊227┊          targetChat: chat,\n ┊227┊228┊        });\n```\n```diff\n@@ -239,7 +240,8 @@\n ┊239┊240┊  Subscription: {\n ┊240┊241┊    messageAdded: {\n ┊241┊242┊      subscribe: withFilter(\n-┊242┊   ┊        (root, args, { pubsub }) => pubsub.asyncIterator('messageAdded'),\n+┊   ┊243┊        (root, args, { injector }) =>\n+┊   ┊244┊          injector.get(PubSub).asyncIterator('messageAdded'),\n ┊243┊245┊        async (\n ┊244┊246┊          { messageAdded }: { messageAdded: Message },\n ┊245┊247┊          args,\n```\n```diff\n@@ -257,7 +259,8 @@\n ┊257┊259┊\n ┊258┊260┊    chatAdded: {\n ┊259┊261┊      subscribe: withFilter(\n-┊260┊   ┊        (root, args, { pubsub }) => pubsub.asyncIterator('chatAdded'),\n+┊   ┊262┊        (root, args, { injector }) =>\n+┊   ┊263┊          injector.get(PubSub).asyncIterator('chatAdded'),\n ┊261┊264┊        async (\n ┊262┊265┊          { chatAdded }: { chatAdded: Chat },\n ┊263┊266┊          args,\n```\n```diff\n@@ -275,7 +278,8 @@\n ┊275┊278┊\n ┊276┊279┊    chatRemoved: {\n ┊277┊280┊      subscribe: withFilter(\n-┊278┊   ┊        (root, args, { pubsub }) => pubsub.asyncIterator('chatRemoved'),\n+┊   ┊281┊        (root, args, { injector }) =>\n+┊   ┊282┊          injector.get(PubSub).asyncIterator('chatRemoved'),\n ┊279┊283┊        async (\n ┊280┊284┊          { targetChat }: { targetChat: Chat },\n ┊281┊285┊          args,\n```\n\n##### Changed modules&#x2F;common&#x2F;index.ts\n```diff\n@@ -1,10 +1,12 @@\n ┊ 1┊ 1┊import { GraphQLModule } from '@graphql-modules/core';\n+┊  ┊ 2┊import { ProviderScope } from '@graphql-modules/di';\n ┊ 2┊ 3┊import { gql } from 'apollo-server-express';\n ┊ 3┊ 4┊import { GraphQLDateTime } from 'graphql-iso-date';\n ┊ 4┊ 5┊import { Pool } from 'pg';\n ┊ 5┊ 6┊import { pool } from '../../db';\n ┊ 6┊ 7┊import { Resolvers } from '../../types/graphql';\n ┊ 7┊ 8┊import { Database } from './database.provider';\n+┊  ┊ 9┊import { PubSub } from './pubsub.provider';\n ┊ 8┊10┊\n ┊ 9┊11┊const { PostgresPubSub } = require('graphql-postgres-subscriptions');\n ┊10┊12┊\n```\n```diff\n@@ -45,6 +47,11 @@\n ┊45┊47┊      provide: Pool,\n ┊46┊48┊      useValue: pool,\n ┊47┊49┊    },\n+┊  ┊50┊    {\n+┊  ┊51┊      provide: PubSub,\n+┊  ┊52┊      scope: ProviderScope.Application,\n+┊  ┊53┊      useValue: pubsub,\n+┊  ┊54┊    },\n ┊48┊55┊    Database,\n ┊49┊56┊  ],\n ┊50┊57┊  async context({ res, connection }) {\n```\n```diff\n@@ -55,7 +62,6 @@\n ┊55┊62┊    }\n ┊56┊63┊\n ┊57┊64┊    return {\n-┊58┊  ┊      pubsub,\n ┊59┊65┊      res,\n ┊60┊66┊      db,\n ┊61┊67┊    };\n```\n\n##### Added modules&#x2F;common&#x2F;pubsub.provider.ts\n```diff\n@@ -0,0 +1 @@\n+┊ ┊1┊export { PubSub } from 'apollo-server-express';\n```\n\n[}]: #\n\nNow, we're going to use `PubSub` within `Chats` service:\n\n[{]: <helper> (diffStep \"13.17\" module=\"server\")\n\n#### [__Server__ Step 13.17: Migrate addMessage to Chats provider](https://github.com/Urigo/WhatsApp-Clone-Server/commit/6dddc94)\n\n##### Changed modules&#x2F;chats&#x2F;chats.provider.ts\n```diff\n@@ -1,12 +1,14 @@\n ┊ 1┊ 1┊import { Injectable, Inject, ProviderScope } from '@graphql-modules/di';\n ┊ 2┊ 2┊import sql from 'sql-template-strings';\n ┊ 3┊ 3┊import { Database } from '../common/database.provider';\n+┊  ┊ 4┊import { PubSub } from '../common/pubsub.provider';\n ┊ 4┊ 5┊\n ┊ 5┊ 6┊@Injectable({\n ┊ 6┊ 7┊  scope: ProviderScope.Session,\n ┊ 7┊ 8┊})\n ┊ 8┊ 9┊export class Chats {\n ┊ 9┊10┊  @Inject() private db: Database;\n+┊  ┊11┊  @Inject() private pubsub: PubSub;\n ┊10┊12┊\n ┊11┊13┊  async findChatsByUser(userId: string) {\n ┊12┊14┊    const db = await this.db.getClient();\n```\n```diff\n@@ -94,4 +96,29 @@\n ┊ 94┊ 96┊\n ┊ 95┊ 97┊    return !!rows.length;\n ┊ 96┊ 98┊  }\n+┊   ┊ 99┊\n+┊   ┊100┊  async addMessage({\n+┊   ┊101┊    chatId,\n+┊   ┊102┊    userId,\n+┊   ┊103┊    content,\n+┊   ┊104┊  }: {\n+┊   ┊105┊    chatId: string;\n+┊   ┊106┊    userId: string;\n+┊   ┊107┊    content: string;\n+┊   ┊108┊  }) {\n+┊   ┊109┊    const db = await this.db.getClient();\n+┊   ┊110┊    const { rows } = await db.query(sql`\n+┊   ┊111┊      INSERT INTO messages(chat_id, sender_user_id, content)\n+┊   ┊112┊      VALUES(${chatId}, ${userId}, ${content})\n+┊   ┊113┊      RETURNING *\n+┊   ┊114┊    `);\n+┊   ┊115┊\n+┊   ┊116┊    const messageAdded = rows[0];\n+┊   ┊117┊\n+┊   ┊118┊    this.pubsub.publish('messageAdded', {\n+┊   ┊119┊      messageAdded,\n+┊   ┊120┊    });\n+┊   ┊121┊\n+┊   ┊122┊    return messageAdded;\n+┊   ┊123┊  }\n ┊ 97┊124┊}\n```\n\n##### Changed modules&#x2F;chats&#x2F;index.ts\n```diff\n@@ -129,22 +129,12 @@\n ┊129┊129┊  },\n ┊130┊130┊\n ┊131┊131┊  Mutation: {\n-┊132┊   ┊    async addMessage(root, { chatId, content }, { currentUser, injector, db }) {\n+┊   ┊132┊    async addMessage(root, { chatId, content }, { currentUser, injector }) {\n ┊133┊133┊      if (!currentUser) return null;\n ┊134┊134┊\n-┊135┊   ┊      const { rows } = await db.query(sql`\n-┊136┊   ┊        INSERT INTO messages(chat_id, sender_user_id, content)\n-┊137┊   ┊        VALUES(${chatId}, ${currentUser.id}, ${content})\n-┊138┊   ┊        RETURNING *\n-┊139┊   ┊      `);\n-┊140┊   ┊\n-┊141┊   ┊      const messageAdded = rows[0];\n-┊142┊   ┊\n-┊143┊   ┊      injector.get(PubSub).publish('messageAdded', {\n-┊144┊   ┊        messageAdded,\n-┊145┊   ┊      });\n-┊146┊   ┊\n-┊147┊   ┊      return messageAdded;\n+┊   ┊135┊      return injector\n+┊   ┊136┊        .get(Chats)\n+┊   ┊137┊        .addMessage({ chatId, content, userId: currentUser.id });\n ┊148┊138┊    },\n ┊149┊139┊\n ┊150┊140┊    async addChat(root, { recipientId }, { currentUser, injector, db }) {\n```\n\n[}]: #\n[{]: <helper> (diffStep \"13.18\" module=\"server\")\n\n#### [__Server__ Step 13.18: Migrate addChat to Chats provider](https://github.com/Urigo/WhatsApp-Clone-Server/commit/297a371)\n\n##### Changed modules&#x2F;chats&#x2F;chats.provider.ts\n```diff\n@@ -121,4 +121,58 @@\n ┊121┊121┊\n ┊122┊122┊    return messageAdded;\n ┊123┊123┊  }\n+┊   ┊124┊\n+┊   ┊125┊  async addChat({\n+┊   ┊126┊    userId,\n+┊   ┊127┊    recipientId,\n+┊   ┊128┊  }: {\n+┊   ┊129┊    userId: string;\n+┊   ┊130┊    recipientId: string;\n+┊   ┊131┊  }) {\n+┊   ┊132┊    const db = await this.db.getClient();\n+┊   ┊133┊    const { rows } = await db.query(sql`\n+┊   ┊134┊      SELECT chats.* FROM chats, (SELECT * FROM chats_users WHERE user_id = ${userId}) AS chats_of_current_user, chats_users\n+┊   ┊135┊      WHERE chats_users.chat_id = chats_of_current_user.chat_id\n+┊   ┊136┊      AND chats.id = chats_users.chat_id\n+┊   ┊137┊      AND chats_users.user_id = ${recipientId}\n+┊   ┊138┊    `);\n+┊   ┊139┊\n+┊   ┊140┊    // If there is already a chat between these two users, return it\n+┊   ┊141┊    if (rows[0]) {\n+┊   ┊142┊      return rows[0];\n+┊   ┊143┊    }\n+┊   ┊144┊\n+┊   ┊145┊    try {\n+┊   ┊146┊      await db.query('BEGIN');\n+┊   ┊147┊\n+┊   ┊148┊      const { rows } = await db.query(sql`\n+┊   ┊149┊        INSERT INTO chats\n+┊   ┊150┊        DEFAULT VALUES\n+┊   ┊151┊        RETURNING *\n+┊   ┊152┊      `);\n+┊   ┊153┊\n+┊   ┊154┊      const chatAdded = rows[0];\n+┊   ┊155┊\n+┊   ┊156┊      await db.query(sql`\n+┊   ┊157┊        INSERT INTO chats_users(chat_id, user_id)\n+┊   ┊158┊        VALUES(${chatAdded.id}, ${userId})\n+┊   ┊159┊      `);\n+┊   ┊160┊\n+┊   ┊161┊      await db.query(sql`\n+┊   ┊162┊        INSERT INTO chats_users(chat_id, user_id)\n+┊   ┊163┊        VALUES(${chatAdded.id}, ${recipientId})\n+┊   ┊164┊      `);\n+┊   ┊165┊\n+┊   ┊166┊      await db.query('COMMIT');\n+┊   ┊167┊\n+┊   ┊168┊      this.pubsub.publish('chatAdded', {\n+┊   ┊169┊        chatAdded,\n+┊   ┊170┊      });\n+┊   ┊171┊\n+┊   ┊172┊      return chatAdded;\n+┊   ┊173┊    } catch (e) {\n+┊   ┊174┊      await db.query('ROLLBACK');\n+┊   ┊175┊      throw e;\n+┊   ┊176┊    }\n+┊   ┊177┊  }\n ┊124┊178┊}\n```\n\n##### Changed modules&#x2F;chats&#x2F;index.ts\n```diff\n@@ -137,55 +137,12 @@\n ┊137┊137┊        .addMessage({ chatId, content, userId: currentUser.id });\n ┊138┊138┊    },\n ┊139┊139┊\n-┊140┊   ┊    async addChat(root, { recipientId }, { currentUser, injector, db }) {\n+┊   ┊140┊    async addChat(root, { recipientId }, { currentUser, injector }) {\n ┊141┊141┊      if (!currentUser) return null;\n ┊142┊142┊\n-┊143┊   ┊      const { rows } = await db.query(sql`\n-┊144┊   ┊        SELECT chats.* FROM chats, (SELECT * FROM chats_users WHERE user_id = ${\n-┊145┊   ┊          currentUser.id\n-┊146┊   ┊        }) AS chats_of_current_user, chats_users\n-┊147┊   ┊        WHERE chats_users.chat_id = chats_of_current_user.chat_id\n-┊148┊   ┊        AND chats.id = chats_users.chat_id\n-┊149┊   ┊        AND chats_users.user_id = ${recipientId}\n-┊150┊   ┊      `);\n-┊151┊   ┊\n-┊152┊   ┊      // If there is already a chat between these two users, return it\n-┊153┊   ┊      if (rows[0]) {\n-┊154┊   ┊        return rows[0];\n-┊155┊   ┊      }\n-┊156┊   ┊\n-┊157┊   ┊      try {\n-┊158┊   ┊        await db.query('BEGIN');\n-┊159┊   ┊\n-┊160┊   ┊        const { rows } = await db.query(sql`\n-┊161┊   ┊          INSERT INTO chats\n-┊162┊   ┊          DEFAULT VALUES\n-┊163┊   ┊          RETURNING *\n-┊164┊   ┊        `);\n-┊165┊   ┊\n-┊166┊   ┊        const chatAdded = rows[0];\n-┊167┊   ┊\n-┊168┊   ┊        await db.query(sql`\n-┊169┊   ┊          INSERT INTO chats_users(chat_id, user_id)\n-┊170┊   ┊          VALUES(${chatAdded.id}, ${currentUser.id})\n-┊171┊   ┊        `);\n-┊172┊   ┊\n-┊173┊   ┊        await db.query(sql`\n-┊174┊   ┊          INSERT INTO chats_users(chat_id, user_id)\n-┊175┊   ┊          VALUES(${chatAdded.id}, ${recipientId})\n-┊176┊   ┊        `);\n-┊177┊   ┊\n-┊178┊   ┊        await db.query('COMMIT');\n-┊179┊   ┊\n-┊180┊   ┊        injector.get(PubSub).publish('chatAdded', {\n-┊181┊   ┊          chatAdded,\n-┊182┊   ┊        });\n-┊183┊   ┊\n-┊184┊   ┊        return chatAdded;\n-┊185┊   ┊      } catch (e) {\n-┊186┊   ┊        await db.query('ROLLBACK');\n-┊187┊   ┊        throw e;\n-┊188┊   ┊      }\n+┊   ┊143┊      return injector\n+┊   ┊144┊        .get(Chats)\n+┊   ┊145┊        .addChat({ recipientId, userId: currentUser.id });\n ┊189┊146┊    },\n ┊190┊147┊\n ┊191┊148┊    async removeChat(root, { chatId }, { currentUser, injector, db }) {\n```\n\n[}]: #\n[{]: <helper> (diffStep \"13.19\" module=\"server\")\n\n#### [__Server__ Step 13.19: Migrate removeChat to Chats provider](https://github.com/Urigo/WhatsApp-Clone-Server/commit/8971087)\n\n##### Changed modules&#x2F;chats&#x2F;chats.provider.ts\n```diff\n@@ -175,4 +175,42 @@\n ┊175┊175┊      throw e;\n ┊176┊176┊    }\n ┊177┊177┊  }\n+┊   ┊178┊\n+┊   ┊179┊  async removeChat({ chatId, userId }: { chatId: string; userId: string }) {\n+┊   ┊180┊    const db = await this.db.getClient();\n+┊   ┊181┊\n+┊   ┊182┊    try {\n+┊   ┊183┊      await db.query('BEGIN');\n+┊   ┊184┊\n+┊   ┊185┊      const { rows } = await db.query(sql`\n+┊   ┊186┊        SELECT chats.* FROM chats, chats_users\n+┊   ┊187┊        WHERE id = ${chatId}\n+┊   ┊188┊        AND chats.id = chats_users.chat_id\n+┊   ┊189┊        AND chats_users.user_id = ${userId}\n+┊   ┊190┊      `);\n+┊   ┊191┊\n+┊   ┊192┊      const chat = rows[0];\n+┊   ┊193┊\n+┊   ┊194┊      if (!chat) {\n+┊   ┊195┊        await db.query('ROLLBACK');\n+┊   ┊196┊        return null;\n+┊   ┊197┊      }\n+┊   ┊198┊\n+┊   ┊199┊      await db.query(sql`\n+┊   ┊200┊        DELETE FROM chats WHERE chats.id = ${chatId}\n+┊   ┊201┊      `);\n+┊   ┊202┊\n+┊   ┊203┊      this.pubsub.publish('chatRemoved', {\n+┊   ┊204┊        chatRemoved: chat.id,\n+┊   ┊205┊        targetChat: chat,\n+┊   ┊206┊      });\n+┊   ┊207┊\n+┊   ┊208┊      await db.query('COMMIT');\n+┊   ┊209┊\n+┊   ┊210┊      return chatId;\n+┊   ┊211┊    } catch (e) {\n+┊   ┊212┊      await db.query('ROLLBACK');\n+┊   ┊213┊      throw e;\n+┊   ┊214┊    }\n+┊   ┊215┊  }\n ┊178┊216┊}\n```\n\n##### Changed modules&#x2F;chats&#x2F;index.ts\n```diff\n@@ -145,42 +145,10 @@\n ┊145┊145┊        .addChat({ recipientId, userId: currentUser.id });\n ┊146┊146┊    },\n ┊147┊147┊\n-┊148┊   ┊    async removeChat(root, { chatId }, { currentUser, injector, db }) {\n+┊   ┊148┊    async removeChat(root, { chatId }, { currentUser, injector }) {\n ┊149┊149┊      if (!currentUser) return null;\n ┊150┊150┊\n-┊151┊   ┊      try {\n-┊152┊   ┊        await db.query('BEGIN');\n-┊153┊   ┊\n-┊154┊   ┊        const { rows } = await db.query(sql`\n-┊155┊   ┊          SELECT chats.* FROM chats, chats_users\n-┊156┊   ┊          WHERE id = ${chatId}\n-┊157┊   ┊          AND chats.id = chats_users.chat_id\n-┊158┊   ┊          AND chats_users.user_id = ${currentUser.id}\n-┊159┊   ┊        `);\n-┊160┊   ┊\n-┊161┊   ┊        const chat = rows[0];\n-┊162┊   ┊\n-┊163┊   ┊        if (!chat) {\n-┊164┊   ┊          await db.query('ROLLBACK');\n-┊165┊   ┊          return null;\n-┊166┊   ┊        }\n-┊167┊   ┊\n-┊168┊   ┊        await db.query(sql`\n-┊169┊   ┊          DELETE FROM chats WHERE chats.id = ${chatId}\n-┊170┊   ┊        `);\n-┊171┊   ┊\n-┊172┊   ┊        injector.get(PubSub).publish('chatRemoved', {\n-┊173┊   ┊          chatRemoved: chat.id,\n-┊174┊   ┊          targetChat: chat,\n-┊175┊   ┊        });\n-┊176┊   ┊\n-┊177┊   ┊        await db.query('COMMIT');\n-┊178┊   ┊\n-┊179┊   ┊        return chatId;\n-┊180┊   ┊      } catch (e) {\n-┊181┊   ┊        await db.query('ROLLBACK');\n-┊182┊   ┊        throw e;\n-┊183┊   ┊      }\n+┊   ┊151┊      return injector.get(Chats).removeChat({ chatId, userId: currentUser.id });\n ┊184┊152┊    },\n ┊185┊153┊  },\n```\n\n[}]: #\n\n#### Implementing Auth service\n\nThe last missing piece of our \"context migration\" journey is `currentUser` object. We're going to define the `Auth` service.\n\n[{]: <helper> (diffStep \"13.20\" files=\"modules/users/auth.provider.ts\" module=\"server\")\n\n#### [__Server__ Step 13.20: Implement Auth provider with currentUser method](https://github.com/Urigo/WhatsApp-Clone-Server/commit/52b9a53)\n\n##### Added modules&#x2F;users&#x2F;auth.provider.ts\n```diff\n@@ -0,0 +1,30 @@\n+┊  ┊ 1┊import { Injectable, Inject, ProviderScope } from '@graphql-modules/di';\n+┊  ┊ 2┊import { ModuleSessionInfo } from '@graphql-modules/core';\n+┊  ┊ 3┊import jwt from 'jsonwebtoken';\n+┊  ┊ 4┊import { secret } from '../../env';\n+┊  ┊ 5┊import { Users } from './users.provider';\n+┊  ┊ 6┊import { User } from '../../db';\n+┊  ┊ 7┊\n+┊  ┊ 8┊@Injectable({\n+┊  ┊ 9┊  scope: ProviderScope.Session,\n+┊  ┊10┊})\n+┊  ┊11┊export class Auth {\n+┊  ┊12┊  @Inject() private users: Users;\n+┊  ┊13┊  @Inject() private module: ModuleSessionInfo;\n+┊  ┊14┊\n+┊  ┊15┊  private get req() {\n+┊  ┊16┊    return this.module.session.req || this.module.session.request;\n+┊  ┊17┊  }\n+┊  ┊18┊\n+┊  ┊19┊  async currentUser(): Promise<User | null> {\n+┊  ┊20┊    if (this.req.cookies.authToken) {\n+┊  ┊21┊      const username = jwt.verify(this.req.cookies.authToken, secret) as string;\n+┊  ┊22┊\n+┊  ┊23┊      if (username) {\n+┊  ┊24┊        return this.users.findByUsername(username);\n+┊  ┊25┊      }\n+┊  ┊26┊    }\n+┊  ┊27┊\n+┊  ┊28┊    return null;\n+┊  ┊29┊  }\n+┊  ┊30┊}\n```\n\n[}]: #\n\nIt still needs to be registered and few resolvers in Users module have to be migrated:\n\n[{]: <helper> (diffStep \"13.20\" files=\"modules/users/index.ts, context.ts\" module=\"server\")\n\n#### [__Server__ Step 13.20: Implement Auth provider with currentUser method](https://github.com/Urigo/WhatsApp-Clone-Server/commit/52b9a53)\n\n##### Changed context.ts\n```diff\n@@ -1,10 +1,8 @@\n ┊ 1┊ 1┊import { ModuleContext } from '@graphql-modules/core';\n-┊ 2┊  ┊import { User } from './db';\n ┊ 3┊ 2┊import { Response } from 'express';\n ┊ 4┊ 3┊import { PoolClient } from 'pg';\n ┊ 5┊ 4┊\n ┊ 6┊ 5┊export type MyContext = {\n-┊ 7┊  ┊  currentUser: User;\n ┊ 8┊ 6┊  res: Response;\n ┊ 9┊ 7┊  db: PoolClient;\n ┊10┊ 8┊} & ModuleContext;\n```\n\n##### Changed modules&#x2F;users&#x2F;index.ts\n```diff\n@@ -1,6 +1,5 @@\n ┊1┊1┊import { GraphQLModule } from '@graphql-modules/core';\n ┊2┊2┊import { gql } from 'apollo-server-express';\n-┊3┊ ┊import cookie from 'cookie';\n ┊4┊3┊import sql from 'sql-template-strings';\n ┊5┊4┊import bcrypt from 'bcrypt';\n ┊6┊5┊import jwt from 'jsonwebtoken';\n```\n```diff\n@@ -10,6 +9,7 @@\n ┊10┊ 9┊import { validateLength, validatePassword } from '../../validators';\n ┊11┊10┊import { Resolvers } from '../../types/graphql';\n ┊12┊11┊import { Users } from './users.provider';\n+┊  ┊12┊import { Auth } from './auth.provider';\n ┊13┊13┊\n ┊14┊14┊const typeDefs = gql`\n ┊15┊15┊  type User {\n```\n```diff\n@@ -36,10 +36,12 @@\n ┊36┊36┊\n ┊37┊37┊const resolvers: Resolvers = {\n ┊38┊38┊  Query: {\n-┊39┊  ┊    me(root, args, { currentUser }) {\n-┊40┊  ┊      return currentUser || null;\n+┊  ┊39┊    me(root, args, { injector }) {\n+┊  ┊40┊      return injector.get(Auth).currentUser();\n ┊41┊41┊    },\n-┊42┊  ┊    async users(root, args, { currentUser, injector }) {\n+┊  ┊42┊    async users(root, args, { injector }) {\n+┊  ┊43┊      const currentUser = await injector.get(Auth).currentUser();\n+┊  ┊44┊\n ┊43┊45┊      if (!currentUser) return [];\n ┊44┊46┊\n ┊45┊47┊      return injector.get(Users).findAllExcept(currentUser.id);\n```\n```diff\n@@ -100,33 +102,5 @@\n ┊100┊102┊  typeDefs,\n ┊101┊103┊  resolvers,\n ┊102┊104┊  imports: () => [commonModule],\n-┊103┊   ┊  providers: () => [Users],\n-┊104┊   ┊  async context(session) {\n-┊105┊   ┊    let currentUser;\n-┊106┊   ┊\n-┊107┊   ┊    // Access the request object\n-┊108┊   ┊    let req = session.connection\n-┊109┊   ┊      ? session.connection.context.request\n-┊110┊   ┊      : session.req;\n-┊111┊   ┊\n-┊112┊   ┊    // It's subscription\n-┊113┊   ┊    if (session.connection) {\n-┊114┊   ┊      req.cookies = cookie.parse(req.headers.cookie || '');\n-┊115┊   ┊    }\n-┊116┊   ┊\n-┊117┊   ┊    if (req.cookies.authToken) {\n-┊118┊   ┊      const username = jwt.verify(req.cookies.authToken, secret) as string;\n-┊119┊   ┊\n-┊120┊   ┊      if (username) {\n-┊121┊   ┊        const { rows } = await pool.query(\n-┊122┊   ┊          sql`SELECT * FROM users WHERE username = ${username}`\n-┊123┊   ┊        );\n-┊124┊   ┊        currentUser = rows[0];\n-┊125┊   ┊      }\n-┊126┊   ┊    }\n-┊127┊   ┊\n-┊128┊   ┊    return {\n-┊129┊   ┊      currentUser,\n-┊130┊   ┊    };\n-┊131┊   ┊  },\n+┊   ┊105┊  providers: () => [Users, Auth],\n ┊132┊106┊});\n```\n\n[}]: #\n\nNow let's use the Auth service in Chats:\n\n[{]: <helper> (diffStep \"13.20\" files=\"modules/chats/index.ts\" module=\"server\")\n\n#### [__Server__ Step 13.20: Implement Auth provider with currentUser method](https://github.com/Urigo/WhatsApp-Clone-Server/commit/52b9a53)\n\n##### Changed modules&#x2F;chats&#x2F;index.ts\n```diff\n@@ -7,6 +7,7 @@\n ┊ 7┊ 7┊import { Resolvers } from '../../types/graphql';\n ┊ 8┊ 8┊import { UnsplashApi } from './unsplash.api';\n ┊ 9┊ 9┊import { Users } from './../users/users.provider';\n+┊  ┊10┊import { Auth } from './../users/auth.provider';\n ┊10┊11┊import { Chats } from './chats.provider';\n ┊11┊12┊import { PubSub } from '../common/pubsub.provider';\n ┊12┊13┊\n```\n```diff\n@@ -69,13 +70,16 @@\n ┊69┊70┊      });\n ┊70┊71┊    },\n ┊71┊72┊\n-┊72┊  ┊    isMine(message, args, { currentUser }) {\n-┊73┊  ┊      return message.sender_user_id === currentUser.id;\n+┊  ┊73┊    async isMine(message, args, { injector }) {\n+┊  ┊74┊      const currentUser = await injector.get(Auth).currentUser();\n+┊  ┊75┊      return message.sender_user_id === currentUser!.id;\n ┊74┊76┊    },\n ┊75┊77┊  },\n ┊76┊78┊\n ┊77┊79┊  Chat: {\n-┊78┊  ┊    async name(chat, args, { currentUser, injector }) {\n+┊  ┊80┊    async name(chat, args, { injector }) {\n+┊  ┊81┊      const currentUser = await injector.get(Auth).currentUser();\n+┊  ┊82┊\n ┊79┊83┊      if (!currentUser) return null;\n ┊80┊84┊\n ┊81┊85┊      const participant = await injector.get(Chats).firstRecipient({\n```\n```diff\n@@ -86,7 +90,9 @@\n ┊86┊90┊      return participant ? participant.name : null;\n ┊87┊91┊    },\n ┊88┊92┊\n-┊89┊  ┊    async picture(chat, args, { currentUser, db, injector }) {\n+┊  ┊93┊    async picture(chat, args, { injector }) {\n+┊  ┊94┊      const currentUser = await injector.get(Auth).currentUser();\n+┊  ┊95┊\n ┊90┊96┊      if (!currentUser) return null;\n ┊91┊97┊\n ┊92┊98┊      const participant = await injector.get(Chats).firstRecipient({\n```\n```diff\n@@ -113,13 +119,17 @@\n ┊113┊119┊  },\n ┊114┊120┊\n ┊115┊121┊  Query: {\n-┊116┊   ┊    async chats(root, args, { currentUser, injector }) {\n+┊   ┊122┊    async chats(root, args, { injector }) {\n+┊   ┊123┊      const currentUser = await injector.get(Auth).currentUser();\n+┊   ┊124┊\n ┊117┊125┊      if (!currentUser) return [];\n ┊118┊126┊\n ┊119┊127┊      return injector.get(Chats).findChatsByUser(currentUser.id);\n ┊120┊128┊    },\n ┊121┊129┊\n-┊122┊   ┊    async chat(root, { chatId }, { currentUser, injector }) {\n+┊   ┊130┊    async chat(root, { chatId }, { injector }) {\n+┊   ┊131┊      const currentUser = await injector.get(Auth).currentUser();\n+┊   ┊132┊\n ┊123┊133┊      if (!currentUser) return null;\n ┊124┊134┊\n ┊125┊135┊      return injector\n```\n```diff\n@@ -129,7 +139,9 @@\n ┊129┊139┊  },\n ┊130┊140┊\n ┊131┊141┊  Mutation: {\n-┊132┊   ┊    async addMessage(root, { chatId, content }, { currentUser, injector }) {\n+┊   ┊142┊    async addMessage(root, { chatId, content }, { injector }) {\n+┊   ┊143┊      const currentUser = await injector.get(Auth).currentUser();\n+┊   ┊144┊\n ┊133┊145┊      if (!currentUser) return null;\n ┊134┊146┊\n ┊135┊147┊      return injector\n```\n```diff\n@@ -137,7 +149,9 @@\n ┊137┊149┊        .addMessage({ chatId, content, userId: currentUser.id });\n ┊138┊150┊    },\n ┊139┊151┊\n-┊140┊   ┊    async addChat(root, { recipientId }, { currentUser, injector }) {\n+┊   ┊152┊    async addChat(root, { recipientId }, { injector }) {\n+┊   ┊153┊      const currentUser = await injector.get(Auth).currentUser();\n+┊   ┊154┊\n ┊141┊155┊      if (!currentUser) return null;\n ┊142┊156┊\n ┊143┊157┊      return injector\n```\n```diff\n@@ -145,7 +159,9 @@\n ┊145┊159┊        .addChat({ recipientId, userId: currentUser.id });\n ┊146┊160┊    },\n ┊147┊161┊\n-┊148┊   ┊    async removeChat(root, { chatId }, { currentUser, injector }) {\n+┊   ┊162┊    async removeChat(root, { chatId }, { injector }) {\n+┊   ┊163┊      const currentUser = await injector.get(Auth).currentUser();\n+┊   ┊164┊\n ┊149┊165┊      if (!currentUser) return null;\n ┊150┊166┊\n ┊151┊167┊      return injector.get(Chats).removeChat({ chatId, userId: currentUser.id });\n```\n```diff\n@@ -160,8 +176,10 @@\n ┊160┊176┊        async (\n ┊161┊177┊          { messageAdded }: { messageAdded: Message },\n ┊162┊178┊          args,\n-┊163┊   ┊          { currentUser, injector }\n+┊   ┊179┊          { injector }\n ┊164┊180┊        ) => {\n+┊   ┊181┊          const currentUser = await injector.get(Auth).currentUser();\n+┊   ┊182┊\n ┊165┊183┊          if (!currentUser) return false;\n ┊166┊184┊\n ┊167┊185┊          return injector.get(Chats).isParticipant({\n```\n```diff\n@@ -176,11 +194,9 @@\n ┊176┊194┊      subscribe: withFilter(\n ┊177┊195┊        (root, args, { injector }) =>\n ┊178┊196┊          injector.get(PubSub).asyncIterator('chatAdded'),\n-┊179┊   ┊        async (\n-┊180┊   ┊          { chatAdded }: { chatAdded: Chat },\n-┊181┊   ┊          args,\n-┊182┊   ┊          { currentUser, injector }\n-┊183┊   ┊        ) => {\n+┊   ┊197┊        async ({ chatAdded }: { chatAdded: Chat }, args, { injector }) => {\n+┊   ┊198┊          const currentUser = await injector.get(Auth).currentUser();\n+┊   ┊199┊\n ┊184┊200┊          if (!currentUser) return false;\n ┊185┊201┊\n ┊186┊202┊          return injector.get(Chats).isParticipant({\n```\n```diff\n@@ -195,11 +211,9 @@\n ┊195┊211┊      subscribe: withFilter(\n ┊196┊212┊        (root, args, { injector }) =>\n ┊197┊213┊          injector.get(PubSub).asyncIterator('chatRemoved'),\n-┊198┊   ┊        async (\n-┊199┊   ┊          { targetChat }: { targetChat: Chat },\n-┊200┊   ┊          args,\n-┊201┊   ┊          { currentUser, injector }\n-┊202┊   ┊        ) => {\n+┊   ┊214┊        async ({ targetChat }: { targetChat: Chat }, args, { injector }) => {\n+┊   ┊215┊          const currentUser = await injector.get(Auth).currentUser();\n+┊   ┊216┊\n ┊203┊217┊          if (!currentUser) return false;\n ┊204┊218┊\n ┊205┊219┊          return injector.get(Chats).isParticipant({\n```\n\n[}]: #\n\nBecause we no longer need `db` instance in the context, let's remove it:\n\n[{]: <helper> (diffStep \"13.21\" module=\"server\")\n\n#### [__Server__ Step 13.21: Remove db from context](https://github.com/Urigo/WhatsApp-Clone-Server/commit/9917231)\n\n##### Changed context.ts\n```diff\n@@ -1,8 +1,6 @@\n ┊1┊1┊import { ModuleContext } from '@graphql-modules/core';\n ┊2┊2┊import { Response } from 'express';\n-┊3┊ ┊import { PoolClient } from 'pg';\n ┊4┊3┊\n ┊5┊4┊export type MyContext = {\n ┊6┊5┊  res: Response;\n-┊7┊ ┊  db: PoolClient;\n ┊8┊6┊} & ModuleContext;\n```\n\n##### Changed modules&#x2F;chats&#x2F;index.ts\n```diff\n@@ -1,9 +1,8 @@\n ┊1┊1┊import { GraphQLModule } from '@graphql-modules/core';\n ┊2┊2┊import { gql, withFilter } from 'apollo-server-express';\n-┊3┊ ┊import sql from 'sql-template-strings';\n ┊4┊3┊import commonModule from '../common';\n ┊5┊4┊import usersModule from '../users';\n-┊6┊ ┊import { Message, Chat, pool } from '../../db';\n+┊ ┊5┊import { Message, Chat } from '../../db';\n ┊7┊6┊import { Resolvers } from '../../types/graphql';\n ┊8┊7┊import { UnsplashApi } from './unsplash.api';\n ┊9┊8┊import { Users } from './../users/users.provider';\n```\n\n##### Changed modules&#x2F;common&#x2F;index.ts\n```diff\n@@ -54,16 +54,9 @@\n ┊54┊54┊    },\n ┊55┊55┊    Database,\n ┊56┊56┊  ],\n-┊57┊  ┊  async context({ res, connection }) {\n-┊58┊  ┊    let db;\n-┊59┊  ┊\n-┊60┊  ┊    if (!connection) {\n-┊61┊  ┊      db = await pool.connect();\n-┊62┊  ┊    }\n-┊63┊  ┊\n+┊  ┊57┊  async context({ res }) {\n ┊64┊58┊    return {\n ┊65┊59┊      res,\n-┊66┊  ┊      db,\n ┊67┊60┊    };\n ┊68┊61┊  },\n ┊69┊62┊});\n```\n\n##### Changed modules&#x2F;users&#x2F;index.ts\n```diff\n@@ -1,11 +1,9 @@\n ┊ 1┊ 1┊import { GraphQLModule } from '@graphql-modules/core';\n ┊ 2┊ 2┊import { gql } from 'apollo-server-express';\n-┊ 3┊  ┊import sql from 'sql-template-strings';\n ┊ 4┊ 3┊import bcrypt from 'bcrypt';\n ┊ 5┊ 4┊import jwt from 'jsonwebtoken';\n ┊ 6┊ 5┊import commonModule from '../common';\n ┊ 7┊ 6┊import { secret, expiration } from '../../env';\n-┊ 8┊  ┊import { pool } from '../../db';\n ┊ 9┊ 7┊import { validateLength, validatePassword } from '../../validators';\n ┊10┊ 8┊import { Resolvers } from '../../types/graphql';\n ┊11┊ 9┊import { Users } from './users.provider';\n```\n\n[}]: #\n\nBesides the `currentUser` method we're going to have two more, one to sign in and the other to sign up:\n\n[{]: <helper> (diffStep \"13.22\" module=\"server\")\n\n#### [__Server__ Step 13.22: Move signUp logic to Auth provider](https://github.com/Urigo/WhatsApp-Clone-Server/commit/f0f4e76)\n\n##### Changed modules&#x2F;users&#x2F;auth.provider.ts\n```diff\n@@ -2,6 +2,7 @@\n ┊2┊2┊import { ModuleSessionInfo } from '@graphql-modules/core';\n ┊3┊3┊import jwt from 'jsonwebtoken';\n ┊4┊4┊import { secret } from '../../env';\n+┊ ┊5┊import { validateLength, validatePassword } from '../../validators';\n ┊5┊6┊import { Users } from './users.provider';\n ┊6┊7┊import { User } from '../../db';\n ┊7┊8┊\n```\n```diff\n@@ -16,6 +17,38 @@\n ┊16┊17┊    return this.module.session.req || this.module.session.request;\n ┊17┊18┊  }\n ┊18┊19┊\n+┊  ┊20┊  async signUp({\n+┊  ┊21┊    name,\n+┊  ┊22┊    password,\n+┊  ┊23┊    passwordConfirm,\n+┊  ┊24┊    username,\n+┊  ┊25┊  }: {\n+┊  ┊26┊    name: string;\n+┊  ┊27┊    password: string;\n+┊  ┊28┊    passwordConfirm: string;\n+┊  ┊29┊    username: string;\n+┊  ┊30┊  }) {\n+┊  ┊31┊    validateLength('req.name', name, 3, 50);\n+┊  ┊32┊    validateLength('req.username', name, 3, 18);\n+┊  ┊33┊    validatePassword('req.password', password);\n+┊  ┊34┊\n+┊  ┊35┊    if (password !== passwordConfirm) {\n+┊  ┊36┊      throw Error(\"req.password and req.passwordConfirm don't match\");\n+┊  ┊37┊    }\n+┊  ┊38┊\n+┊  ┊39┊    const existingUser = await this.users.findByUsername(username);\n+┊  ┊40┊\n+┊  ┊41┊    if (existingUser) {\n+┊  ┊42┊      throw Error('username already exists');\n+┊  ┊43┊    }\n+┊  ┊44┊\n+┊  ┊45┊    return this.users.newUser({\n+┊  ┊46┊      username,\n+┊  ┊47┊      name,\n+┊  ┊48┊      password,\n+┊  ┊49┊    });\n+┊  ┊50┊  }\n+┊  ┊51┊\n ┊19┊52┊  async currentUser(): Promise<User | null> {\n ┊20┊53┊    if (this.req.cookies.authToken) {\n ┊21┊54┊      const username = jwt.verify(this.req.cookies.authToken, secret) as string;\n```\n\n##### Changed modules&#x2F;users&#x2F;index.ts\n```diff\n@@ -4,7 +4,6 @@\n ┊ 4┊ 4┊import jwt from 'jsonwebtoken';\n ┊ 5┊ 5┊import commonModule from '../common';\n ┊ 6┊ 6┊import { secret, expiration } from '../../env';\n-┊ 7┊  ┊import { validateLength, validatePassword } from '../../validators';\n ┊ 8┊ 7┊import { Resolvers } from '../../types/graphql';\n ┊ 9┊ 8┊import { Users } from './users.provider';\n ┊10┊ 9┊import { Auth } from './auth.provider';\n```\n```diff\n@@ -71,26 +70,9 @@\n ┊71┊70┊      { name, username, password, passwordConfirm },\n ┊72┊71┊      { injector }\n ┊73┊72┊    ) {\n-┊74┊  ┊      validateLength('req.name', name, 3, 50);\n-┊75┊  ┊      validateLength('req.username', name, 3, 18);\n-┊76┊  ┊      validatePassword('req.password', password);\n-┊77┊  ┊\n-┊78┊  ┊      if (password !== passwordConfirm) {\n-┊79┊  ┊        throw Error(\"req.password and req.passwordConfirm don't match\");\n-┊80┊  ┊      }\n-┊81┊  ┊\n-┊82┊  ┊      const existingUser = await injector.get(Users).findByUsername(username);\n-┊83┊  ┊      if (existingUser) {\n-┊84┊  ┊        throw Error('username already exists');\n-┊85┊  ┊      }\n-┊86┊  ┊\n-┊87┊  ┊      const createdUser = await injector.get(Users).newUser({\n-┊88┊  ┊        username,\n-┊89┊  ┊        password,\n-┊90┊  ┊        name,\n-┊91┊  ┊      });\n-┊92┊  ┊\n-┊93┊  ┊      return createdUser;\n+┊  ┊73┊      return injector\n+┊  ┊74┊        .get(Auth)\n+┊  ┊75┊        .signUp({ name, username, password, passwordConfirm });\n ┊94┊76┊    },\n ┊95┊77┊  },\n ┊96┊78┊};\n```\n\n[}]: #\n[{]: <helper> (diffStep \"13.23\" module=\"server\")\n\n#### [__Server__ Step 13.23: Move signIn logic to Auth provider](https://github.com/Urigo/WhatsApp-Clone-Server/commit/0168ae8)\n\n##### Changed context.ts\n```diff\n@@ -1,6 +1,3 @@\n ┊1┊1┊import { ModuleContext } from '@graphql-modules/core';\n-┊2┊ ┊import { Response } from 'express';\n ┊3┊2┊\n-┊4┊ ┊export type MyContext = {\n-┊5┊ ┊  res: Response;\n-┊6┊ ┊} & ModuleContext;\n+┊ ┊3┊export type MyContext = ModuleContext;\n```\n\n##### Changed modules&#x2F;common&#x2F;index.ts\n```diff\n@@ -54,9 +54,4 @@\n ┊54┊54┊    },\n ┊55┊55┊    Database,\n ┊56┊56┊  ],\n-┊57┊  ┊  async context({ res }) {\n-┊58┊  ┊    return {\n-┊59┊  ┊      res,\n-┊60┊  ┊    };\n-┊61┊  ┊  },\n ┊62┊57┊});\n```\n\n##### Changed modules&#x2F;users&#x2F;auth.provider.ts\n```diff\n@@ -1,7 +1,9 @@\n ┊1┊1┊import { Injectable, Inject, ProviderScope } from '@graphql-modules/di';\n ┊2┊2┊import { ModuleSessionInfo } from '@graphql-modules/core';\n+┊ ┊3┊import { Response } from 'express';\n+┊ ┊4┊import bcrypt from 'bcrypt';\n ┊3┊5┊import jwt from 'jsonwebtoken';\n-┊4┊ ┊import { secret } from '../../env';\n+┊ ┊6┊import { secret, expiration } from '../../env';\n ┊5┊7┊import { validateLength, validatePassword } from '../../validators';\n ┊6┊8┊import { Users } from './users.provider';\n ┊7┊9┊import { User } from '../../db';\n```\n```diff\n@@ -17,6 +19,30 @@\n ┊17┊19┊    return this.module.session.req || this.module.session.request;\n ┊18┊20┊  }\n ┊19┊21┊\n+┊  ┊22┊  private get res(): Response {\n+┊  ┊23┊    return this.module.session.res;\n+┊  ┊24┊  }\n+┊  ┊25┊\n+┊  ┊26┊  async signIn({ username, password }: { username: string; password: string }) {\n+┊  ┊27┊    const user = await this.users.findByUsername(username);\n+┊  ┊28┊\n+┊  ┊29┊    if (!user) {\n+┊  ┊30┊      throw new Error('user not found');\n+┊  ┊31┊    }\n+┊  ┊32┊\n+┊  ┊33┊    const passwordsMatch = bcrypt.compareSync(password, user.password);\n+┊  ┊34┊\n+┊  ┊35┊    if (!passwordsMatch) {\n+┊  ┊36┊      throw new Error('password is incorrect');\n+┊  ┊37┊    }\n+┊  ┊38┊\n+┊  ┊39┊    const authToken = jwt.sign(username, secret);\n+┊  ┊40┊\n+┊  ┊41┊    this.res.cookie('authToken', authToken, { maxAge: expiration });\n+┊  ┊42┊\n+┊  ┊43┊    return user;\n+┊  ┊44┊  }\n+┊  ┊45┊\n ┊20┊46┊  async signUp({\n ┊21┊47┊    name,\n ┊22┊48┊    password,\n```\n\n##### Changed modules&#x2F;users&#x2F;index.ts\n```diff\n@@ -1,9 +1,6 @@\n ┊1┊1┊import { GraphQLModule } from '@graphql-modules/core';\n ┊2┊2┊import { gql } from 'apollo-server-express';\n-┊3┊ ┊import bcrypt from 'bcrypt';\n-┊4┊ ┊import jwt from 'jsonwebtoken';\n ┊5┊3┊import commonModule from '../common';\n-┊6┊ ┊import { secret, expiration } from '../../env';\n ┊7┊4┊import { Resolvers } from '../../types/graphql';\n ┊8┊5┊import { Users } from './users.provider';\n ┊9┊6┊import { Auth } from './auth.provider';\n```\n```diff\n@@ -45,24 +42,8 @@\n ┊45┊42┊    },\n ┊46┊43┊  },\n ┊47┊44┊  Mutation: {\n-┊48┊  ┊    async signIn(root, { username, password }, { injector, res }) {\n-┊49┊  ┊      const user = await injector.get(Users).findByUsername(username);\n-┊50┊  ┊\n-┊51┊  ┊      if (!user) {\n-┊52┊  ┊        throw new Error('user not found');\n-┊53┊  ┊      }\n-┊54┊  ┊\n-┊55┊  ┊      const passwordsMatch = bcrypt.compareSync(password, user.password);\n-┊56┊  ┊\n-┊57┊  ┊      if (!passwordsMatch) {\n-┊58┊  ┊        throw new Error('password is incorrect');\n-┊59┊  ┊      }\n-┊60┊  ┊\n-┊61┊  ┊      const authToken = jwt.sign(username, secret);\n-┊62┊  ┊\n-┊63┊  ┊      res.cookie('authToken', authToken, { maxAge: expiration });\n-┊64┊  ┊\n-┊65┊  ┊      return user;\n+┊  ┊45┊    async signIn(root, { username, password }, { injector }) {\n+┊  ┊46┊      return injector.get(Auth).signIn({ username, password });\n ┊66┊47┊    },\n ┊67┊48┊\n ┊68┊49┊    async signUp(\n```\n\n[}]: #\n\n#### Exposing server instance\n\nIf you would run `yarn test` right now, you will see a lot of errors, every test will fail. That's because we changed our setup but we didn't adjusted tests.\n\nWe're going to change the setup of tests as well so whenever we do something on server it won't affect them. Instead of exposing schema and context as we did before, we're going to base the tests on a ready to use ApolloServer instance.\n\nIn order to achieve it, we need to separate ApolloServer from other server related logic.\n\n[{]: <helper> (diffStep \"13.24\" module=\"server\")\n\n#### [__Server__ Step 13.24: Move ApolloServer and RootModule into a separate file](https://github.com/Urigo/WhatsApp-Clone-Server/commit/ef8d54e)\n\n##### Changed index.ts\n```diff\n@@ -1,35 +1,7 @@\n-┊ 1┊  ┊import 'reflect-metadata';\n-┊ 2┊  ┊import { ApolloServer } from 'apollo-server-express';\n-┊ 3┊  ┊import { GraphQLModule } from '@graphql-modules/core';\n-┊ 4┊  ┊import cookie from 'cookie';\n ┊ 5┊ 1┊import http from 'http';\n ┊ 6┊ 2┊import { app } from './app';\n ┊ 7┊ 3┊import { origin, port } from './env';\n-┊ 8┊  ┊\n-┊ 9┊  ┊import usersModule from './modules/users';\n-┊10┊  ┊import chatsModule from './modules/chats';\n-┊11┊  ┊\n-┊12┊  ┊export const rootModule = new GraphQLModule({\n-┊13┊  ┊  name: 'root',\n-┊14┊  ┊  imports: [usersModule, chatsModule],\n-┊15┊  ┊});\n-┊16┊  ┊\n-┊17┊  ┊const server = new ApolloServer({\n-┊18┊  ┊  schema: rootModule.schema,\n-┊19┊  ┊  context: (session: any) => {\n-┊20┊  ┊    if (session.connection) {\n-┊21┊  ┊      const req = session.connection.context.session.request;\n-┊22┊  ┊      const cookies = req.headers.cookie;\n-┊23┊  ┊\n-┊24┊  ┊      if (cookies) {\n-┊25┊  ┊        req.cookies = cookie.parse(cookies);\n-┊26┊  ┊      }\n-┊27┊  ┊    }\n-┊28┊  ┊\n-┊29┊  ┊    return rootModule.context(session);\n-┊30┊  ┊  },\n-┊31┊  ┊  subscriptions: rootModule.subscriptions,\n-┊32┊  ┊});\n+┊  ┊ 4┊import { server } from './server';\n ┊33┊ 5┊\n ┊34┊ 6┊server.applyMiddleware({\n ┊35┊ 7┊  app,\n```\n\n##### Added server.ts\n```diff\n@@ -0,0 +1,29 @@\n+┊  ┊ 1┊import 'reflect-metadata';\n+┊  ┊ 2┊import { ApolloServer } from 'apollo-server-express';\n+┊  ┊ 3┊import { GraphQLModule } from '@graphql-modules/core';\n+┊  ┊ 4┊import cookie from 'cookie';\n+┊  ┊ 5┊\n+┊  ┊ 6┊import usersModule from './modules/users';\n+┊  ┊ 7┊import chatsModule from './modules/chats';\n+┊  ┊ 8┊\n+┊  ┊ 9┊export const rootModule = new GraphQLModule({\n+┊  ┊10┊  name: 'root',\n+┊  ┊11┊  imports: [usersModule, chatsModule],\n+┊  ┊12┊});\n+┊  ┊13┊\n+┊  ┊14┊const server = new ApolloServer({\n+┊  ┊15┊  schema: rootModule.schema,\n+┊  ┊16┊  context: (session: any) => {\n+┊  ┊17┊    if (session.connection) {\n+┊  ┊18┊      const req = session.connection.context.session.request;\n+┊  ┊19┊      const cookies = req.headers.cookie;\n+┊  ┊20┊\n+┊  ┊21┊      if (cookies) {\n+┊  ┊22┊        req.cookies = cookie.parse(cookies);\n+┊  ┊23┊      }\n+┊  ┊24┊    }\n+┊  ┊25┊\n+┊  ┊26┊    return rootModule.context(session);\n+┊  ┊27┊  },\n+┊  ┊28┊  subscriptions: rootModule.subscriptions,\n+┊  ┊29┊});\n```\n\n[}]: #\n[{]: <helper> (diffStep \"13.25\" module=\"server\")\n\n#### [__Server__ Step 13.25: Export server instance](https://github.com/Urigo/WhatsApp-Clone-Server/commit/0c561a9)\n\n##### Changed server.ts\n```diff\n@@ -11,7 +11,7 @@\n ┊11┊11┊  imports: [usersModule, chatsModule],\n ┊12┊12┊});\n ┊13┊13┊\n-┊14┊  ┊const server = new ApolloServer({\n+┊  ┊14┊export const server = new ApolloServer({\n ┊15┊15┊  schema: rootModule.schema,\n ┊16┊16┊  context: (session: any) => {\n ┊17┊17┊    if (session.connection) {\n```\n\n[}]: #\n\nThere's one thing that changed and might break our tests, this line fix it:\n\n[{]: <helper> (diffStep \"13.26\" module=\"server\")\n\n#### [__Server__ Step 13.26: Define mocked version of Auth provider](https://github.com/Urigo/WhatsApp-Clone-Server/commit/21e706b)\n\n##### Added tests&#x2F;mocks&#x2F;auth.provider.ts\n```diff\n@@ -0,0 +1,21 @@\n+┊  ┊ 1┊import sql from 'sql-template-strings';\n+┊  ┊ 2┊import { Auth } from './../../modules/users/auth.provider';\n+┊  ┊ 3┊import usersModule from './../../modules/users';\n+┊  ┊ 4┊import { pool } from '../../db';\n+┊  ┊ 5┊\n+┊  ┊ 6┊export function mockAuth(userId: number) {\n+┊  ┊ 7┊  class AuthMock extends Auth {\n+┊  ┊ 8┊    async currentUser() {\n+┊  ┊ 9┊      const { rows } = await pool.query(\n+┊  ┊10┊        sql`SELECT * FROM users WHERE id = ${userId}`\n+┊  ┊11┊      );\n+┊  ┊12┊      return rows[0];\n+┊  ┊13┊    }\n+┊  ┊14┊  }\n+┊  ┊15┊\n+┊  ┊16┊  usersModule.injector.provide({\n+┊  ┊17┊    provide: Auth,\n+┊  ┊18┊    useClass: AuthMock,\n+┊  ┊19┊    overwrite: true,\n+┊  ┊20┊  });\n+┊  ┊21┊}\n```\n\n[}]: #\n\nRemember when I said about benefits of Dependency Injection? Here's one of them. We create a function that overwrites the `currentUser` method so it always returns a specific user.\n\n[{]: <helper> (diffStep \"13.27\" module=\"server\")\n\n#### [__Server__ Step 13.27: Adjust tests](https://github.com/Urigo/WhatsApp-Clone-Server/commit/23361df)\n\n##### Changed tests&#x2F;mutations&#x2F;addChat.test.ts\n```diff\n@@ -1,28 +1,14 @@\n ┊ 1┊ 1┊import { createTestClient } from 'apollo-server-testing';\n-┊ 2┊  ┊import { ApolloServer, PubSub, gql } from 'apollo-server-express';\n-┊ 3┊  ┊import { rootModule } from '../../index';\n-┊ 4┊  ┊import { resetDb, pool } from '../../db';\n-┊ 5┊  ┊import sql from 'sql-template-strings';\n-┊ 6┊  ┊import { MyContext } from '../../context';\n+┊  ┊ 2┊import { gql } from 'apollo-server-express';\n+┊  ┊ 3┊import { server } from '../../server';\n+┊  ┊ 4┊import { resetDb } from '../../db';\n+┊  ┊ 5┊import { mockAuth } from '../mocks/auth.provider';\n ┊ 7┊ 6┊\n ┊ 8┊ 7┊describe('Mutation.addChat', () => {\n ┊ 9┊ 8┊  beforeEach(resetDb);\n ┊10┊ 9┊\n ┊11┊10┊  it('creates a new chat between current user and specified recipient', async () => {\n-┊12┊  ┊    const { rows } = await pool.query(sql`SELECT * FROM users WHERE id = 2`);\n-┊13┊  ┊    const currentUser = rows[0];\n-┊14┊  ┊    const server = new ApolloServer({\n-┊15┊  ┊      schema: rootModule.schema,\n-┊16┊  ┊      context: async () => ({\n-┊17┊  ┊        pubsub: new PubSub(),\n-┊18┊  ┊        currentUser,\n-┊19┊  ┊        db: await pool.connect(),\n-┊20┊  ┊      }),\n-┊21┊  ┊      formatResponse: (res: any, { context }: { context: MyContext }) => {\n-┊22┊  ┊        context.db.release();\n-┊23┊  ┊        return res;\n-┊24┊  ┊      },\n-┊25┊  ┊    });\n+┊  ┊11┊    mockAuth(2);\n ┊26┊12┊\n ┊27┊13┊    const { query, mutate } = createTestClient(server);\n ┊28┊14┊\n```\n```diff\n@@ -66,20 +52,7 @@\n ┊66┊52┊  });\n ┊67┊53┊\n ┊68┊54┊  it('returns the existing chat if so', async () => {\n-┊69┊  ┊    const { rows } = await pool.query(sql`SELECT * FROM users WHERE id = 1`);\n-┊70┊  ┊    const currentUser = rows[0];\n-┊71┊  ┊    const server = new ApolloServer({\n-┊72┊  ┊      schema: rootModule.schema,\n-┊73┊  ┊      context: async () => ({\n-┊74┊  ┊        pubsub: new PubSub(),\n-┊75┊  ┊        currentUser,\n-┊76┊  ┊        db: await pool.connect(),\n-┊77┊  ┊      }),\n-┊78┊  ┊      formatResponse: (res: any, { context }: { context: MyContext }) => {\n-┊79┊  ┊        context.db.release();\n-┊80┊  ┊        return res;\n-┊81┊  ┊      },\n-┊82┊  ┊    });\n+┊  ┊55┊    mockAuth(1);\n ┊83┊56┊\n ┊84┊57┊    const { query, mutate } = createTestClient(server);\n ┊85┊58┊\n```\n\n##### Changed tests&#x2F;mutations&#x2F;addMessage.test.ts\n```diff\n@@ -1,28 +1,14 @@\n ┊ 1┊ 1┊import { createTestClient } from 'apollo-server-testing';\n-┊ 2┊  ┊import { ApolloServer, PubSub, gql } from 'apollo-server-express';\n-┊ 3┊  ┊import { rootModule } from '../../index';\n-┊ 4┊  ┊import { resetDb, pool } from '../../db';\n-┊ 5┊  ┊import sql from 'sql-template-strings';\n-┊ 6┊  ┊import { MyContext } from '../../context';\n+┊  ┊ 2┊import { gql } from 'apollo-server-express';\n+┊  ┊ 3┊import { server } from '../../server';\n+┊  ┊ 4┊import { resetDb } from '../../db';\n+┊  ┊ 5┊import { mockAuth } from '../mocks/auth.provider';\n ┊ 7┊ 6┊\n ┊ 8┊ 7┊describe('Mutation.addMessage', () => {\n ┊ 9┊ 8┊  beforeEach(resetDb);\n ┊10┊ 9┊\n ┊11┊10┊  it('should add message to specified chat', async () => {\n-┊12┊  ┊    const { rows } = await pool.query(sql`SELECT * FROM users WHERE id = 1`);\n-┊13┊  ┊    const currentUser = rows[0];\n-┊14┊  ┊    const server = new ApolloServer({\n-┊15┊  ┊      schema: rootModule.schema,\n-┊16┊  ┊      context: async () => ({\n-┊17┊  ┊        pubsub: new PubSub(),\n-┊18┊  ┊        currentUser,\n-┊19┊  ┊        db: await pool.connect(),\n-┊20┊  ┊      }),\n-┊21┊  ┊      formatResponse: (res: any, { context }: { context: MyContext }) => {\n-┊22┊  ┊        context.db.release();\n-┊23┊  ┊        return res;\n-┊24┊  ┊      },\n-┊25┊  ┊    });\n+┊  ┊11┊    mockAuth(1);\n ┊26┊12┊\n ┊27┊13┊    const { query, mutate } = createTestClient(server);\n ┊28┊14┊\n```\n\n##### Changed tests&#x2F;mutations&#x2F;removeChat.test.ts\n```diff\n@@ -1,28 +1,14 @@\n ┊ 1┊ 1┊import { createTestClient } from 'apollo-server-testing';\n-┊ 2┊  ┊import { ApolloServer, PubSub, gql } from 'apollo-server-express';\n-┊ 3┊  ┊import { rootModule } from '../../index';\n-┊ 4┊  ┊import { resetDb, pool } from '../../db';\n-┊ 5┊  ┊import sql from 'sql-template-strings';\n-┊ 6┊  ┊import { MyContext } from '../../context';\n+┊  ┊ 2┊import { gql } from 'apollo-server-express';\n+┊  ┊ 3┊import { server } from '../../server';\n+┊  ┊ 4┊import { resetDb } from '../../db';\n+┊  ┊ 5┊import { mockAuth } from '../mocks/auth.provider';\n ┊ 7┊ 6┊\n ┊ 8┊ 7┊describe('Mutation.removeChat', () => {\n ┊ 9┊ 8┊  beforeEach(resetDb);\n ┊10┊ 9┊\n ┊11┊10┊  it('removes chat by id', async () => {\n-┊12┊  ┊    const { rows } = await pool.query(sql`SELECT * FROM users WHERE id = 1`);\n-┊13┊  ┊    const currentUser = rows[0];\n-┊14┊  ┊    const server = new ApolloServer({\n-┊15┊  ┊      schema: rootModule.schema,\n-┊16┊  ┊      context: async () => ({\n-┊17┊  ┊        pubsub: new PubSub(),\n-┊18┊  ┊        currentUser,\n-┊19┊  ┊        db: await pool.connect(),\n-┊20┊  ┊      }),\n-┊21┊  ┊      formatResponse: (res: any, { context }: { context: MyContext }) => {\n-┊22┊  ┊        context.db.release();\n-┊23┊  ┊        return res;\n-┊24┊  ┊      },\n-┊25┊  ┊    });\n+┊  ┊11┊    mockAuth(1);\n ┊26┊12┊\n ┊27┊13┊    const { query, mutate } = createTestClient(server);\n ┊28┊14┊\n```\n\n##### Changed tests&#x2F;queries&#x2F;getChat.test.ts\n```diff\n@@ -1,27 +1,14 @@\n ┊ 1┊ 1┊import { createTestClient } from 'apollo-server-testing';\n-┊ 2┊  ┊import { ApolloServer, gql } from 'apollo-server-express';\n-┊ 3┊  ┊import { rootModule } from '../../index';\n-┊ 4┊  ┊import { poolm resetDb } from '../../db';\n-┊ 5┊  ┊import sql from 'sql-template-strings';\n-┊ 6┊  ┊import { MyContext } from '../../context';\n+┊  ┊ 2┊import { gql } from 'apollo-server-express';\n+┊  ┊ 3┊import { server } from '../../server';\n+┊  ┊ 4┊import { resetDb } from '../../db';\n+┊  ┊ 5┊import { mockAuth } from '../mocks/auth.provider';\n ┊ 7┊ 6┊\n ┊ 8┊ 7┊describe('Query.chat', () => {\n ┊ 9┊ 8┊  beforeEach(resetDb);\n ┊10┊ 9┊\n ┊11┊10┊  it('should fetch specified chat', async () => {\n-┊12┊  ┊    const { rows } = await pool.query(sql`SELECT * FROM users WHERE id = 1`);\n-┊13┊  ┊    const currentUser = rows[0];\n-┊14┊  ┊    const server = new ApolloServer({\n-┊15┊  ┊      schema: rootModule.schema,\n-┊16┊  ┊      context: async () => ({\n-┊17┊  ┊        currentUser,\n-┊18┊  ┊        db: await pool.connect(),\n-┊19┊  ┊      }),\n-┊20┊  ┊      formatResponse: (res: any, { context }: { context: MyContext }) => {\n-┊21┊  ┊        context.db.release();\n-┊22┊  ┊        return res;\n-┊23┊  ┊      },\n-┊24┊  ┊    });\n+┊  ┊11┊    mockAuth(1);\n ┊25┊12┊\n ┊26┊13┊    const { query } = createTestClient(server);\n ┊27┊14┊\n```\n\n##### Changed tests&#x2F;queries&#x2F;getChats.test.ts\n```diff\n@@ -1,27 +1,14 @@\n ┊ 1┊ 1┊import { createTestClient } from 'apollo-server-testing';\n-┊ 2┊  ┊import { ApolloServer, gql } from 'apollo-server-express';\n-┊ 3┊  ┊import { rootModule } from '../../index';\n-┊ 4┊  ┊import { pool, resetDb } from '../../db';\n-┊ 5┊  ┊import sql from 'sql-template-strings';\n-┊ 6┊  ┊import { MyContext } from '../../context';\n+┊  ┊ 2┊import { gql } from 'apollo-server-express';\n+┊  ┊ 3┊import { server } from '../../server';\n+┊  ┊ 4┊import { resetDb } from '../../db';\n+┊  ┊ 5┊import { mockAuth } from '../mocks/auth.provider';\n ┊ 7┊ 6┊\n ┊ 8┊ 7┊describe('Query.chats', () => {\n ┊ 9┊ 8┊  beforeEach(resetDb);\n ┊10┊ 9┊\n ┊11┊10┊  it('should fetch all chats', async () => {\n-┊12┊  ┊    const { rows } = await pool.query(sql`SELECT * FROM users WHERE id = 1`);\n-┊13┊  ┊    const currentUser = rows[0];\n-┊14┊  ┊    const server = new ApolloServer({\n-┊15┊  ┊      schema: rootModule.schema,\n-┊16┊  ┊      context: async () => ({\n-┊17┊  ┊        currentUser,\n-┊18┊  ┊        db: await pool.connect(),\n-┊19┊  ┊      }),\n-┊20┊  ┊      formatResponse: (res: any, { context }: { context: MyContext }) => {\n-┊21┊  ┊        context.db.release();\n-┊22┊  ┊        return res;\n-┊23┊  ┊      },\n-┊24┊  ┊    });\n+┊  ┊11┊    mockAuth(1);\n ┊25┊12┊\n ┊26┊13┊    const { query } = createTestClient(server);\n ┊27┊14┊\n```\n\n##### Changed tests&#x2F;queries&#x2F;getMe.test.ts\n```diff\n@@ -1,25 +1,14 @@\n ┊ 1┊ 1┊import { createTestClient } from 'apollo-server-testing';\n-┊ 2┊  ┊import { ApolloServer, gql } from 'apollo-server-express';\n-┊ 3┊  ┊import { rootModule } from '../../index';\n-┊ 4┊  ┊import { pool } from '../../db';\n-┊ 5┊  ┊import sql from 'sql-template-strings';\n-┊ 6┊  ┊import { MyContext } from '../../context';\n+┊  ┊ 2┊import { gql } from 'apollo-server-express';\n+┊  ┊ 3┊import { server } from '../../server';\n+┊  ┊ 4┊import { resetDb } from '../../db';\n+┊  ┊ 5┊import { mockAuth } from '../mocks/auth.provider';\n ┊ 7┊ 6┊\n ┊ 8┊ 7┊describe('Query.me', () => {\n+┊  ┊ 8┊  beforeEach(resetDb);\n+┊  ┊ 9┊\n ┊ 9┊10┊  it('should fetch current user', async () => {\n-┊10┊  ┊    const { rows } = await pool.query(sql`SELECT * FROM users WHERE id = 1`);\n-┊11┊  ┊    const currentUser = rows[0];\n-┊12┊  ┊    const server = new ApolloServer({\n-┊13┊  ┊      schema: rootModule.schema,\n-┊14┊  ┊      context: async () => ({\n-┊15┊  ┊        currentUser,\n-┊16┊  ┊        db: await pool.connect(),\n-┊17┊  ┊      }),\n-┊18┊  ┊      formatResponse: (res: any, { context }: { context: MyContext }) => {\n-┊19┊  ┊        context.db.release();\n-┊20┊  ┊        return res;\n-┊21┊  ┊      },\n-┊22┊  ┊    });\n+┊  ┊11┊    mockAuth(1);\n ┊23┊12┊\n ┊24┊13┊    const { query } = createTestClient(server);\n ┊25┊14┊\n```\n\n##### Changed tests&#x2F;queries&#x2F;getUsers.test.ts\n```diff\n@@ -1,28 +1,14 @@\n ┊ 1┊ 1┊import { createTestClient } from 'apollo-server-testing';\n-┊ 2┊  ┊import { ApolloServer, gql } from 'apollo-server-express';\n-┊ 3┊  ┊import { rootModule } from '../../index';\n-┊ 4┊  ┊import { pool } from '../../db';\n-┊ 5┊  ┊import sql from 'sql-template-strings';\n-┊ 6┊  ┊import { MyContext } from '../../context';\n+┊  ┊ 2┊import { gql } from 'apollo-server-express';\n+┊  ┊ 3┊import { server } from '../../server';\n+┊  ┊ 4┊import { resetDb } from '../../db';\n+┊  ┊ 5┊import { mockAuth } from '../mocks/auth.provider';\n ┊ 7┊ 6┊\n ┊ 8┊ 7┊describe('Query.getUsers', () => {\n+┊  ┊ 8┊  beforeEach(resetDb);\n+┊  ┊ 9┊\n ┊ 9┊10┊  it('should fetch all users except the one signed-in', async () => {\n-┊10┊  ┊    const firstUserQuery = await pool.query(\n-┊11┊  ┊      sql`SELECT * FROM users WHERE id = 1`\n-┊12┊  ┊    );\n-┊13┊  ┊    let currentUser = firstUserQuery.rows[0];\n-┊14┊  ┊    const db = await pool.connect();\n-┊15┊  ┊    const server = new ApolloServer({\n-┊16┊  ┊      schema: rootModule.schema,\n-┊17┊  ┊      context: async () => ({\n-┊18┊  ┊        currentUser,\n-┊19┊  ┊        db: await pool.connect(),\n-┊20┊  ┊      }),\n-┊21┊  ┊      formatResponse: (res: any, { context }: { context: MyContext }) => {\n-┊22┊  ┊        context.db.release();\n-┊23┊  ┊        return res;\n-┊24┊  ┊      },\n-┊25┊  ┊    });\n+┊  ┊11┊    mockAuth(1);\n ┊26┊12┊\n ┊27┊13┊    const { query } = createTestClient(server);\n ┊28┊14┊\n```\n```diff\n@@ -42,10 +28,7 @@\n ┊42┊28┊    expect(res.errors).toBeUndefined();\n ┊43┊29┊    expect(res.data).toMatchSnapshot();\n ┊44┊30┊\n-┊45┊  ┊    const secondUserQuery = await pool.query(\n-┊46┊  ┊      sql`SELECT * FROM users WHERE id = '2'`\n-┊47┊  ┊    );\n-┊48┊  ┊    currentUser = secondUserQuery.rows[0];\n+┊  ┊31┊    mockAuth(2);\n ┊49┊32┊\n ┊50┊33┊    res = await query({\n ┊51┊34┊      query: gql`\n```\n\n[}]: #\n\nLet's now migrate all tests and see how easier it is now to manage those. Because we use ApolloServer's instance, we don't need to understand how it's implemented.\n\n[{]: <helper> (diffStep \"13.28\" module=\"server\")\n\n#### Step 13.28: NOT FOUND!\n\n[}]: #\n\n## Adjusting client\n\nWe still need to update `codegen.yml` in the client app because of the changes we introduced in this chapter:\n\n[{]: <helper> (diffStep \"14.1\" module=\"client\")\n\n#### [__Client__ Step 14.1: Adjust to GraphQL Modules](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/38024f3)\n\n##### Changed codegen.yml\n```diff\n@@ -1,4 +1,4 @@\n-┊1┊ ┊schema: ../Whatsapp-Clone-Server/schema/typeDefs.graphql\n+┊ ┊1┊schema: ../Whatsapp-Clone-Server/modules/*/*.ts\n ┊2┊2┊documents:\n ┊3┊3┊  - ./src/components/**/*.tsx\n ┊4┊4┊  - ./src/graphql/fragments/**/*.ts\n```\n\n[}]: #\n\n## Many ways to write GraphQL\n\nWe’re going to discuss what are the possible options of building GraphQL API and why schema-first approach was our choice.\n\nThe main ingredient of a GraphQL API is, of course the schema. It’s built out of type definitions where each of them describes a piece of data, connections between them and how data is actually resolved.\n\nThe way we develop all of it changes the way we work with the API.\n\nWe could define two main approaches:\n  - schema-first\n  - resolver-first\n\nThe former means design comes before code, the latter vice-versa.\n\nIn schema-first development you start with SDL, resolvers and code go next. Schema is sort of a contract between teams and also between frontend and backend. With schema-first approach it’s easier to cooperate, discuss and write a better API. Because the SDL is written upfront, the frontend developers can use a mocked version of it and start working on the product while the backend team does the API, in parallel.\nThere are of course some pain points. Once schema is splitted into SDL and resolvers it’s hard to keep them in sync and that’s why things like GraphQL Code Generator were developed, to add type safety on top of all.\n\nThe resolver-first approach is a bit different. The schema is defined programmatically, which usually means it’s more flexible and combined with TypeScript or Flow gives you type-safety out of the box.\n\nWe think it’s less readable than having a SDL and there’s a lack of separation between schema and code which might be a blocker for some teams."
          },
          {
            "manualTitle": "",
            "stepRevision": "",
            "manualView": "In this part of the tutorial we're going to do a bit different work than in previous chapters. We'll analyze the code instead of writing it, including both the API and the web application.\n\n## API Performance\n\nFirst, let's start with the GraphQL API.\n\n### Finding bottlenecks\n\nIn order to implement fixes and do improvements we need to understand which part of the API needs help. There's still not many tools around GraphQL in terms of analytics and inspection but there's one highly useful, it's called **Apollo Engine**.\n\nSince we're going to use it, you need to register an account at [engine.apollographql.com](https://engine.apollographql.com/) and create a service. Please then follow [the \"How to configure an Apollo project\" instructions](https://www.apollographql.com/docs/platform/schema-registry/#using-the-schema-registry).\n\nOnce you're ready, please start the server and run this command:\n\n    $ apollo service:push\n\nTo collect the data, let's play with the client app for some time. After that, go to Engine's website.\n\nHere's one of graphs with timing of an operation. We can understand when each resolver takes place and how much time it consumes. Some resolvers happen in parallel.\nThe `< 1ms` says it was a very simple computation or an element resolved immediately.\n\nWe find it very useful to understand how operation behaves.\n\n![Resolvers](../../../assets/step17/img-01.png \"Resolvers\")\n\nLet's go through an entire query to find fields fetched multiple times. The most obvious field is `isMine`. We see it's computed twice for almost 4 and 5 milliseconds.\nIn order to find out what does it mean, we need to look at the code. The resolver gets the currently logged in user from the `Auth` service and its `currentUser`. Each time the method is invoked, a query to PostgreSQL is made. We ask for that data multiple times, once in `lastMessage` and also in every message from the list.\n\nWe could deduplicate the SQL queries! In order to do that the most obvious library that pops to my mind is Dataloader.\n\nLet's install the package and discuss it afterwards:\n\n    npm install dataloader\n\nThe Dataloader is a library created and maintained by Facebook. It's main purpose is to turn equivalent requests into a single execution. Sounds like a perfect solution, right? It actually is.\n\nA short explaination of how Dataloader works.\n\n```ts\nasync function fetchUser(id: number): Promise<User> {\n  // Resolves asynchronously, after less than 1s.\n  return db.users.findOne(id);\n}\n\nasync function fetchUsers(ids: number[]): Promise<User[]> {\n  const users = ids.map(id => fetchUser(id));\n  return Promise.all(users);\n}\n\nconst loader = new Dataloader(keys => fetchUsers(keys));\n\nasync function main() {\n  const user1 = await loader.load(1);\n  const user2 = await loader.load(2);\n\n  // Later on user #1 is fetched again.\n  // It resolves immediately.\n  const member1 = await loader.load(1);\n}\n```\n\nThink of the Dataloader as a class that has a `Map` object in it, its keys are of course unique and each value is a `Promise`.\nEvery time you ask for something, Dataloader looks for it in the `Map`. When there's already something, the `Promise` is returned but if there's none the provided function is invoked and a new `Promise` is created. This way equivalent requests share the same `Promise`.\n\n> It's important to know that the `Map` object grows until the DataLoader is released, that's why it's recommended to keep `Dataloader` in GraphQL's context.\n\nLet's implement `Dataloader` in our `Database` service:\n\n[{]: <helper> (diffStep \"14.1\" files=\"modules/common/database.provider.ts\" module=\"server\")\n\n#### [__Server__ Step 14.1: Deduplicate SQL queries](https://github.com/Urigo/WhatsApp-Clone-Server/commit/c617928)\n\n##### Changed modules&#x2F;common&#x2F;database.provider.ts\n```diff\n@@ -1,14 +1,41 @@\n ┊ 1┊ 1┊import { Injectable, ProviderScope } from '@graphql-modules/di';\n ┊ 2┊ 2┊import { OnResponse } from '@graphql-modules/core';\n-┊ 3┊  ┊import { Pool, PoolClient } from 'pg';\n+┊  ┊ 3┊import { Pool, PoolClient, QueryResult } from 'pg';\n+┊  ┊ 4┊import { SQLStatement } from 'sql-template-strings';\n+┊  ┊ 5┊import Dataloader from 'dataloader';\n ┊ 4┊ 6┊\n ┊ 5┊ 7┊@Injectable({\n ┊ 6┊ 8┊  scope: ProviderScope.Session,\n ┊ 7┊ 9┊})\n ┊ 8┊10┊export class Database implements OnResponse {\n ┊ 9┊11┊  private instance: PoolClient;\n+┊  ┊12┊  private loader: Dataloader<string | SQLStatement, QueryResult>;\n ┊10┊13┊\n-┊11┊  ┊  constructor(private pool: Pool) {}\n+┊  ┊14┊  constructor(private pool: Pool) {\n+┊  ┊15┊    this.loader = new Dataloader(\n+┊  ┊16┊      queries =>\n+┊  ┊17┊        Promise.all(\n+┊  ┊18┊          queries.map(async query => {\n+┊  ┊19┊            const db = await this.getClient();\n+┊  ┊20┊            return db.query(query);\n+┊  ┊21┊          })\n+┊  ┊22┊        ),\n+┊  ┊23┊      {\n+┊  ┊24┊        cacheKeyFn: (key: string | SQLStatement) => {\n+┊  ┊25┊          let id: string;\n+┊  ┊26┊\n+┊  ┊27┊          if (typeof key === 'string') {\n+┊  ┊28┊            id = key;\n+┊  ┊29┊          } else {\n+┊  ┊30┊            id = key.text + ' - ' + JSON.stringify(key.values);\n+┊  ┊31┊          }\n+┊  ┊32┊\n+┊  ┊33┊          return id;\n+┊  ┊34┊        },\n+┊  ┊35┊        batch: false,\n+┊  ┊36┊      }\n+┊  ┊37┊    );\n+┊  ┊38┊  }\n ┊12┊39┊\n ┊13┊40┊  async onRequest() {\n ┊14┊41┊    this.instance = await this.pool.connect();\n```\n```diff\n@@ -20,7 +47,11 @@\n ┊20┊47┊    }\n ┊21┊48┊  }\n ┊22┊49┊\n-┊23┊  ┊  async getClient() {\n+┊  ┊50┊  private getClient() {\n ┊24┊51┊    return this.instance;\n ┊25┊52┊  }\n+┊  ┊53┊\n+┊  ┊54┊  query(query: SQLStatement | string) {\n+┊  ┊55┊    return this.loader.load(query);\n+┊  ┊56┊  }\n ┊26┊57┊}\n```\n\n[}]: #\n\nThe key is created based on SQL statement and its values and we also turned off batching because it's important to execute SQL operations sequentially.\nThere's also a new method called `query`, to execute SQL statements through Dataloader. It also reduces a boilerplate of asking for db client and executing a query every time we do SQL in resolvers and providers.\n\nNow we need to apply that change in all providers:\n\n[{]: <helper> (diffStep \"14.1\" files=\"modules/users/users.provider.ts, modules/chats/chats.provider.ts\" module=\"server\")\n\n#### [__Server__ Step 14.1: Deduplicate SQL queries](https://github.com/Urigo/WhatsApp-Clone-Server/commit/c617928)\n\n##### Changed modules&#x2F;chats&#x2F;chats.provider.ts\n```diff\n@@ -11,9 +11,7 @@\n ┊11┊11┊  @Inject() private pubsub: PubSub;\n ┊12┊12┊\n ┊13┊13┊  async findChatsByUser(userId: string) {\n-┊14┊  ┊    const db = await this.db.getClient();\n-┊15┊  ┊\n-┊16┊  ┊    const { rows } = await db.query(sql`\n+┊  ┊14┊    const { rows } = await this.db.query(sql`\n ┊17┊15┊      SELECT chats.* FROM chats, chats_users\n ┊18┊16┊      WHERE chats.id = chats_users.chat_id\n ┊19┊17┊      AND chats_users.user_id = ${userId}\n```\n```diff\n@@ -23,8 +21,7 @@\n ┊23┊21┊  }\n ┊24┊22┊\n ┊25┊23┊  async findChatByUser({ chatId, userId }: { chatId: string; userId: string }) {\n-┊26┊  ┊    const db = await this.db.getClient();\n-┊27┊  ┊    const { rows } = await db.query(sql`\n+┊  ┊24┊    const { rows } = await this.db.query(sql`\n ┊28┊25┊      SELECT chats.* FROM chats, chats_users\n ┊29┊26┊      WHERE chats_users.chat_id = ${chatId}\n ┊30┊27┊      AND chats.id = chats_users.chat_id\n```\n```diff\n@@ -35,16 +32,14 @@\n ┊35┊32┊  }\n ┊36┊33┊\n ┊37┊34┊  async findChatById(chatId: string) {\n-┊38┊  ┊    const db = await this.db.getClient();\n-┊39┊  ┊    const { rows } = await db.query(sql`\n+┊  ┊35┊    const { rows } = await this.db.query(sql`\n ┊40┊36┊      SELECT * FROM chats WHERE id = ${chatId}\n ┊41┊37┊    `);\n ┊42┊38┊    return rows[0] || null;\n ┊43┊39┊  }\n ┊44┊40┊\n ┊45┊41┊  async findMessagesByChat(chatId: string) {\n-┊46┊  ┊    const db = await this.db.getClient();\n-┊47┊  ┊    const { rows } = await db.query(\n+┊  ┊42┊    const { rows } = await this.db.query(\n ┊48┊43┊      sql`SELECT * FROM messages WHERE chat_id = ${chatId}`\n ┊49┊44┊    );\n ┊50┊45┊\n```\n```diff\n@@ -52,8 +47,7 @@\n ┊52┊47┊  }\n ┊53┊48┊\n ┊54┊49┊  async lastMessage(chatId: string) {\n-┊55┊  ┊    const db = await this.db.getClient();\n-┊56┊  ┊    const { rows } = await db.query(sql`\n+┊  ┊50┊    const { rows } = await this.db.query(sql`\n ┊57┊51┊      SELECT * FROM messages\n ┊58┊52┊      WHERE chat_id = ${chatId}\n ┊59┊53┊      ORDER BY created_at DESC\n```\n```diff\n@@ -64,8 +58,7 @@\n ┊64┊58┊  }\n ┊65┊59┊\n ┊66┊60┊  async firstRecipient({ chatId, userId }: { chatId: string; userId: string }) {\n-┊67┊  ┊    const db = await this.db.getClient();\n-┊68┊  ┊    const { rows } = await db.query(sql`\n+┊  ┊61┊    const { rows } = await this.db.query(sql`\n ┊69┊62┊      SELECT users.* FROM users, chats_users\n ┊70┊63┊      WHERE users.id != ${userId}\n ┊71┊64┊      AND users.id = chats_users.user_id\n```\n```diff\n@@ -76,8 +69,7 @@\n ┊76┊69┊  }\n ┊77┊70┊\n ┊78┊71┊  async participants(chatId: string) {\n-┊79┊  ┊    const db = await this.db.getClient();\n-┊80┊  ┊    const { rows } = await db.query(sql`\n+┊  ┊72┊    const { rows } = await this.db.query(sql`\n ┊81┊73┊      SELECT users.* FROM users, chats_users\n ┊82┊74┊      WHERE chats_users.chat_id = ${chatId}\n ┊83┊75┊      AND chats_users.user_id = users.id\n```\n```diff\n@@ -87,8 +79,7 @@\n ┊87┊79┊  }\n ┊88┊80┊\n ┊89┊81┊  async isParticipant({ chatId, userId }: { chatId: string; userId: string }) {\n-┊90┊  ┊    const db = await this.db.getClient();\n-┊91┊  ┊    const { rows } = await db.query(sql`\n+┊  ┊82┊    const { rows } = await this.db.query(sql`\n ┊92┊83┊      SELECT * FROM chats_users\n ┊93┊84┊      WHERE chat_id = ${chatId}\n ┊94┊85┊      AND user_id = ${userId}\n```\n```diff\n@@ -106,8 +97,7 @@\n ┊106┊ 97┊    userId: string;\n ┊107┊ 98┊    content: string;\n ┊108┊ 99┊  }) {\n-┊109┊   ┊    const db = await this.db.getClient();\n-┊110┊   ┊    const { rows } = await db.query(sql`\n+┊   ┊100┊    const { rows } = await this.db.query(sql`\n ┊111┊101┊      INSERT INTO messages(chat_id, sender_user_id, content)\n ┊112┊102┊      VALUES(${chatId}, ${userId}, ${content})\n ┊113┊103┊      RETURNING *\n```\n```diff\n@@ -129,8 +119,7 @@\n ┊129┊119┊    userId: string;\n ┊130┊120┊    recipientId: string;\n ┊131┊121┊  }) {\n-┊132┊   ┊    const db = await this.db.getClient();\n-┊133┊   ┊    const { rows } = await db.query(sql`\n+┊   ┊122┊    const { rows } = await this.db.query(sql`\n ┊134┊123┊      SELECT chats.* FROM chats, (SELECT * FROM chats_users WHERE user_id = ${userId}) AS chats_of_current_user, chats_users\n ┊135┊124┊      WHERE chats_users.chat_id = chats_of_current_user.chat_id\n ┊136┊125┊      AND chats.id = chats_users.chat_id\n```\n```diff\n@@ -143,9 +132,9 @@\n ┊143┊132┊    }\n ┊144┊133┊\n ┊145┊134┊    try {\n-┊146┊   ┊      await db.query('BEGIN');\n+┊   ┊135┊      await this.db.query('BEGIN');\n ┊147┊136┊\n-┊148┊   ┊      const { rows } = await db.query(sql`\n+┊   ┊137┊      const { rows } = await this.db.query(sql`\n ┊149┊138┊        INSERT INTO chats\n ┊150┊139┊        DEFAULT VALUES\n ┊151┊140┊        RETURNING *\n```\n```diff\n@@ -153,17 +142,17 @@\n ┊153┊142┊\n ┊154┊143┊      const chatAdded = rows[0];\n ┊155┊144┊\n-┊156┊   ┊      await db.query(sql`\n+┊   ┊145┊      await this.db.query(sql`\n ┊157┊146┊        INSERT INTO chats_users(chat_id, user_id)\n ┊158┊147┊        VALUES(${chatAdded.id}, ${userId})\n ┊159┊148┊      `);\n ┊160┊149┊\n-┊161┊   ┊      await db.query(sql`\n+┊   ┊150┊      await this.db.query(sql`\n ┊162┊151┊        INSERT INTO chats_users(chat_id, user_id)\n ┊163┊152┊        VALUES(${chatAdded.id}, ${recipientId})\n ┊164┊153┊      `);\n ┊165┊154┊\n-┊166┊   ┊      await db.query('COMMIT');\n+┊   ┊155┊      await this.db.query('COMMIT');\n ┊167┊156┊\n ┊168┊157┊      this.pubsub.publish('chatAdded', {\n ┊169┊158┊        chatAdded,\n```\n```diff\n@@ -171,18 +160,16 @@\n ┊171┊160┊\n ┊172┊161┊      return chatAdded;\n ┊173┊162┊    } catch (e) {\n-┊174┊   ┊      await db.query('ROLLBACK');\n+┊   ┊163┊      await this.db.query('ROLLBACK');\n ┊175┊164┊      throw e;\n ┊176┊165┊    }\n ┊177┊166┊  }\n ┊178┊167┊\n ┊179┊168┊  async removeChat({ chatId, userId }: { chatId: string; userId: string }) {\n-┊180┊   ┊    const db = await this.db.getClient();\n-┊181┊   ┊\n ┊182┊169┊    try {\n-┊183┊   ┊      await db.query('BEGIN');\n+┊   ┊170┊      await this.db.query('BEGIN');\n ┊184┊171┊\n-┊185┊   ┊      const { rows } = await db.query(sql`\n+┊   ┊172┊      const { rows } = await this.db.query(sql`\n ┊186┊173┊        SELECT chats.* FROM chats, chats_users\n ┊187┊174┊        WHERE id = ${chatId}\n ┊188┊175┊        AND chats.id = chats_users.chat_id\n```\n```diff\n@@ -192,11 +179,11 @@\n ┊192┊179┊      const chat = rows[0];\n ┊193┊180┊\n ┊194┊181┊      if (!chat) {\n-┊195┊   ┊        await db.query('ROLLBACK');\n+┊   ┊182┊        await this.db.query('ROLLBACK');\n ┊196┊183┊        return null;\n ┊197┊184┊      }\n ┊198┊185┊\n-┊199┊   ┊      await db.query(sql`\n+┊   ┊186┊      await this.db.query(sql`\n ┊200┊187┊        DELETE FROM chats WHERE chats.id = ${chatId}\n ┊201┊188┊      `);\n ┊202┊189┊\n```\n```diff\n@@ -205,11 +192,11 @@\n ┊205┊192┊        targetChat: chat,\n ┊206┊193┊      });\n ┊207┊194┊\n-┊208┊   ┊      await db.query('COMMIT');\n+┊   ┊195┊      await this.db.query('COMMIT');\n ┊209┊196┊\n ┊210┊197┊      return chatId;\n ┊211┊198┊    } catch (e) {\n-┊212┊   ┊      await db.query('ROLLBACK');\n+┊   ┊199┊      await this.db.query('ROLLBACK');\n ┊213┊200┊      throw e;\n ┊214┊201┊    }\n ┊215┊202┊  }\n```\n\n##### Changed modules&#x2F;users&#x2F;users.provider.ts\n```diff\n@@ -10,8 +10,7 @@\n ┊10┊10┊  @Inject() private db: Database;\n ┊11┊11┊\n ┊12┊12┊  async findById(userId: string) {\n-┊13┊  ┊    const db = await this.db.getClient();\n-┊14┊  ┊    const { rows } = await db.query(\n+┊  ┊13┊    const { rows } = await this.db.query(\n ┊15┊14┊      sql`SELECT * FROM users WHERE id = ${userId}`\n ┊16┊15┊    );\n ┊17┊16┊\n```\n```diff\n@@ -19,8 +18,7 @@\n ┊19┊18┊  }\n ┊20┊19┊\n ┊21┊20┊  async findAllExcept(userId: string) {\n-┊22┊  ┊    const db = await this.db.getClient();\n-┊23┊  ┊    const { rows } = await db.query(\n+┊  ┊21┊    const { rows } = await this.db.query(\n ┊24┊22┊      sql`SELECT * FROM users WHERE id != ${userId}`\n ┊25┊23┊    );\n ┊26┊24┊\n```\n```diff\n@@ -28,8 +26,7 @@\n ┊28┊26┊  }\n ┊29┊27┊\n ┊30┊28┊  async findByUsername(username: string) {\n-┊31┊  ┊    const db = await this.db.getClient();\n-┊32┊  ┊    const { rows } = await db.query(\n+┊  ┊29┊    const { rows } = await this.db.query(\n ┊33┊30┊      sql`SELECT * FROM users WHERE username = ${username}`\n ┊34┊31┊    );\n ┊35┊32┊\n```\n```diff\n@@ -45,9 +42,8 @@\n ┊45┊42┊    name: string;\n ┊46┊43┊    password: string;\n ┊47┊44┊  }) {\n-┊48┊  ┊    const db = await this.db.getClient();\n ┊49┊45┊    const passwordHash = bcrypt.hashSync(password, bcrypt.genSaltSync(8));\n-┊50┊  ┊    const createdUserQuery = await db.query(sql`\n+┊  ┊46┊    const createdUserQuery = await this.db.query(sql`\n ┊51┊47┊        INSERT INTO users(password, picture, username, name)\n ┊52┊48┊        VALUES(${passwordHash}, '', ${username}, ${name})\n ┊53┊49┊        RETURNING *\n```\n\n[}]: #\n\nDeduplication is done but the `currentUser` method does more than just that. It verifies the auth token extracted from a request's cookie. This could be avoided by an assignment to a private prop and a simple if statement.\n\n[{]: <helper> (diffStep \"14.2\" module=\"server\")\n\n#### [__Server__ Step 14.2: Cache current user object](https://github.com/Urigo/WhatsApp-Clone-Server/commit/aadd6b3)\n\n##### Changed modules&#x2F;users&#x2F;auth.provider.ts\n```diff\n@@ -14,6 +14,7 @@\n ┊14┊14┊export class Auth {\n ┊15┊15┊  @Inject() private users: Users;\n ┊16┊16┊  @Inject() private module: ModuleSessionInfo;\n+┊  ┊17┊  private _currentUser: User;\n ┊17┊18┊\n ┊18┊19┊  private get req() {\n ┊19┊20┊    return this.module.session.req || this.module.session.request;\n```\n```diff\n@@ -76,11 +77,16 @@\n ┊76┊77┊  }\n ┊77┊78┊\n ┊78┊79┊  async currentUser(): Promise<User | null> {\n+┊  ┊80┊    if (this._currentUser) {\n+┊  ┊81┊      return this._currentUser;\n+┊  ┊82┊    }\n+┊  ┊83┊\n ┊79┊84┊    if (this.req.cookies.authToken) {\n ┊80┊85┊      const username = jwt.verify(this.req.cookies.authToken, secret) as string;\n ┊81┊86┊\n ┊82┊87┊      if (username) {\n-┊83┊  ┊        return this.users.findByUsername(username);\n+┊  ┊88┊        this._currentUser = await this.users.findByUsername(username);\n+┊  ┊89┊        return this._currentUser;\n ┊84┊90┊      }\n ┊85┊91┊    }\n```\n\n[}]: #\n\n![Resolvers](../../../assets/step17/img-02.png \"Resolvers\")\n\nAs you can see at the graph above, we reduced an execution time of `isMine` field from 4ms and 5ms to less than 1. That applies for all calls, all messages so it scales well and won't grow as list of messages increases.\n\nBut there's more... We see `chat` field being computed over and over again. So again, let's repeat the same steps.\nThe `Message.chat` resolver asks `Chats` service and its `findChatById` method which makes a SQL call.\n\nThe deduplication logic, we introduced in the previous step, helps to immediately resolve all `Message.chat` fields except the first occurrence but there's still a space for improvements.\n\nThe `Query.chats` resolver is invoked before the `Message.chat` which means at this point, we already have knowledge about the chats.\n\nLet's implement a caching logic for chats so we could reuse them. We will do it in few steps.\n\nFirst, because we're going to use `Dataloader`, `Chats` class should have private and public API.\n\n[{]: <helper> (diffStep \"14.3\" module=\"server\")\n\n#### [__Server__ Step 14.3: Separate db query from public API](https://github.com/Urigo/WhatsApp-Clone-Server/commit/07d810b)\n\n##### Changed modules&#x2F;chats&#x2F;chats.provider.ts\n```diff\n@@ -11,6 +11,10 @@\n ┊11┊11┊  @Inject() private pubsub: PubSub;\n ┊12┊12┊\n ┊13┊13┊  async findChatsByUser(userId: string) {\n+┊  ┊14┊    return this._findChatsByUser(userId);\n+┊  ┊15┊  }\n+┊  ┊16┊\n+┊  ┊17┊  private async _findChatsByUser(userId: string) {\n ┊14┊18┊    const { rows } = await this.db.query(sql`\n ┊15┊19┊      SELECT chats.* FROM chats, chats_users\n ┊16┊20┊      WHERE chats.id = chats_users.chat_id\n```\n\n[}]: #\n\nThe private method is responsible for quering data from the database but the public one is to allow communication between the service and its consumers.\nIt's also there so we could switch to using Dataloader later on.\n\nWe did that to `findChatsByUser` but there are more:\n\n[{]: <helper> (diffStep \"14.4\" module=\"server\")\n\n#### [__Server__ Step 14.4: Separate findChatByUser](https://github.com/Urigo/WhatsApp-Clone-Server/commit/99dc220)\n\n##### Changed modules&#x2F;chats&#x2F;chats.provider.ts\n```diff\n@@ -25,6 +25,18 @@\n ┊25┊25┊  }\n ┊26┊26┊\n ┊27┊27┊  async findChatByUser({ chatId, userId }: { chatId: string; userId: string }) {\n+┊  ┊28┊    const rows = await this._findChatByUser({ chatId, userId });\n+┊  ┊29┊\n+┊  ┊30┊    return rows[0] || null;\n+┊  ┊31┊  }\n+┊  ┊32┊\n+┊  ┊33┊  private async _findChatByUser({\n+┊  ┊34┊    chatId,\n+┊  ┊35┊    userId,\n+┊  ┊36┊  }: {\n+┊  ┊37┊    chatId: string;\n+┊  ┊38┊    userId: string;\n+┊  ┊39┊  }) {\n ┊28┊40┊    const { rows } = await this.db.query(sql`\n ┊29┊41┊      SELECT chats.* FROM chats, chats_users\n ┊30┊42┊      WHERE chats_users.chat_id = ${chatId}\n```\n```diff\n@@ -32,7 +44,7 @@\n ┊32┊44┊      AND chats_users.user_id = ${userId}\n ┊33┊45┊    `);\n ┊34┊46┊\n-┊35┊  ┊    return rows[0] || null;\n+┊  ┊47┊    return rows;\n ┊36┊48┊  }\n ┊37┊49┊\n ┊38┊50┊  async findChatById(chatId: string) {\n```\n\n[}]: #\n[{]: <helper> (diffStep \"14.5\" module=\"server\")\n\n#### [__Server__ Step 14.5: Separate findChatById](https://github.com/Urigo/WhatsApp-Clone-Server/commit/ee816ad)\n\n##### Changed modules&#x2F;chats&#x2F;chats.provider.ts\n```diff\n@@ -48,10 +48,15 @@\n ┊48┊48┊  }\n ┊49┊49┊\n ┊50┊50┊  async findChatById(chatId: string) {\n+┊  ┊51┊    const rows = await this._findChatById(chatId);\n+┊  ┊52┊    return rows[0] || null;\n+┊  ┊53┊  }\n+┊  ┊54┊\n+┊  ┊55┊  private async _findChatById(chatId: string) {\n ┊51┊56┊    const { rows } = await this.db.query(sql`\n ┊52┊57┊      SELECT * FROM chats WHERE id = ${chatId}\n ┊53┊58┊    `);\n-┊54┊  ┊    return rows[0] || null;\n+┊  ┊59┊    return rows;\n ┊55┊60┊  }\n ┊56┊61┊\n ┊57┊62┊  async findMessagesByChat(chatId: string) {\n```\n\n[}]: #\n\n> Because those private methods are just to query data, make sure they all return untouched `row` object.\n\nNow's the most interesting part, Dataloader.\n\n[{]: <helper> (diffStep \"14.6\" module=\"server\")\n\n#### [__Server__ Step 14.6: Use Dataloader in Chats](https://github.com/Urigo/WhatsApp-Clone-Server/commit/f739328)\n\n##### Changed modules&#x2F;chats&#x2F;chats.provider.ts\n```diff\n@@ -1,8 +1,23 @@\n ┊ 1┊ 1┊import { Injectable, Inject, ProviderScope } from '@graphql-modules/di';\n+┊  ┊ 2┊import { QueryResult } from 'pg';\n ┊ 2┊ 3┊import sql from 'sql-template-strings';\n+┊  ┊ 4┊import DataLoader from 'dataloader';\n ┊ 3┊ 5┊import { Database } from '../common/database.provider';\n ┊ 4┊ 6┊import { PubSub } from '../common/pubsub.provider';\n ┊ 5┊ 7┊\n+┊  ┊ 8┊type ChatsByUser = { userId: string };\n+┊  ┊ 9┊type ChatByUser = { userId: string; chatId: string };\n+┊  ┊10┊type ChatById = { chatId: string };\n+┊  ┊11┊type ChatsKey = ChatById | ChatByUser | ChatsByUser;\n+┊  ┊12┊\n+┊  ┊13┊function isChatsByUser(query: any): query is ChatsByUser {\n+┊  ┊14┊  return query.userId && !query.chatId;\n+┊  ┊15┊}\n+┊  ┊16┊\n+┊  ┊17┊function isChatByUser(query: any): query is ChatByUser {\n+┊  ┊18┊  return query.userId && query.chatId;\n+┊  ┊19┊}\n+┊  ┊20┊\n ┊ 6┊21┊@Injectable({\n ┊ 7┊22┊  scope: ProviderScope.Session,\n ┊ 8┊23┊})\n```\n```diff\n@@ -10,8 +25,26 @@\n ┊10┊25┊  @Inject() private db: Database;\n ┊11┊26┊  @Inject() private pubsub: PubSub;\n ┊12┊27┊\n+┊  ┊28┊  private loaders = {\n+┊  ┊29┊    chats: new DataLoader<ChatsKey, QueryResult['rows']>(keys => {\n+┊  ┊30┊      return Promise.all(\n+┊  ┊31┊        keys.map(async query => {\n+┊  ┊32┊          if (isChatsByUser(query)) {\n+┊  ┊33┊            return this._findChatsByUser(query.userId);\n+┊  ┊34┊          }\n+┊  ┊35┊\n+┊  ┊36┊          if (isChatByUser(query)) {\n+┊  ┊37┊            return this._findChatByUser(query);\n+┊  ┊38┊          }\n+┊  ┊39┊\n+┊  ┊40┊          return this._findChatById(query.chatId);\n+┊  ┊41┊        })\n+┊  ┊42┊      );\n+┊  ┊43┊    }),\n+┊  ┊44┊  };\n+┊  ┊45┊\n ┊13┊46┊  async findChatsByUser(userId: string) {\n-┊14┊  ┊    return this._findChatsByUser(userId);\n+┊  ┊47┊    return this.loaders.chats.load({ userId });\n ┊15┊48┊  }\n ┊16┊49┊\n ┊17┊50┊  private async _findChatsByUser(userId: string) {\n```\n```diff\n@@ -25,7 +58,7 @@\n ┊25┊58┊  }\n ┊26┊59┊\n ┊27┊60┊  async findChatByUser({ chatId, userId }: { chatId: string; userId: string }) {\n-┊28┊  ┊    const rows = await this._findChatByUser({ chatId, userId });\n+┊  ┊61┊    const rows = await this.loaders.chats.load({ chatId, userId });\n ┊29┊62┊\n ┊30┊63┊    return rows[0] || null;\n ┊31┊64┊  }\n```\n```diff\n@@ -48,7 +81,7 @@\n ┊48┊81┊  }\n ┊49┊82┊\n ┊50┊83┊  async findChatById(chatId: string) {\n-┊51┊  ┊    const rows = await this._findChatById(chatId);\n+┊  ┊84┊    const rows = await this.loaders.chats.load({ chatId });\n ┊52┊85┊    return rows[0] || null;\n ┊53┊86┊  }\n ┊54┊87┊\n```\n\n##### Changed package.json\n```diff\n@@ -53,6 +53,7 @@\n ┊53┊53┊    \"cookie\": \"0.4.0\",\n ┊54┊54┊    \"cookie-parser\": \"1.4.4\",\n ┊55┊55┊    \"cors\": \"2.8.5\",\n+┊  ┊56┊    \"dataloader\": \"1.4.0\",\n ┊56┊57┊    \"express\": \"4.17.1\",\n ┊57┊58┊    \"graphql\": \"14.3.1\",\n ┊58┊59┊    \"graphql-import\": \"0.7.1\",\n```\n\n[}]: #\n\nWe introduced `ChatsKey` that is a union type, to standarize the input value. Those helper methods like `isChatsByUser` and `isChatByUser` are there to decide what should be fetched.\n\nIn every public method that we previously changed, there's now Dataloader in use but that's not entirely what we're trying to achieve.\n\nThe caching mechanism is not yet completed. We deduplicate requests but in some cases, we ask for chats that are already there, so we need to intercept our dataloader logic and introduce caching.\n\n[{]: <helper> (diffStep \"14.7\" module=\"server\")\n\n#### [__Server__ Step 14.7: Implement caching for Chats](https://github.com/Urigo/WhatsApp-Clone-Server/commit/4f74c94)\n\n##### Changed modules&#x2F;chats&#x2F;chats.provider.ts\n```diff\n@@ -4,6 +4,7 @@\n ┊ 4┊ 4┊import DataLoader from 'dataloader';\n ┊ 5┊ 5┊import { Database } from '../common/database.provider';\n ┊ 6┊ 6┊import { PubSub } from '../common/pubsub.provider';\n+┊  ┊ 7┊import { Chat } from '../../db';\n ┊ 7┊ 8┊\n ┊ 8┊ 9┊type ChatsByUser = { userId: string };\n ┊ 9┊10┊type ChatByUser = { userId: string; chatId: string };\n```\n```diff\n@@ -25,6 +26,7 @@\n ┊25┊26┊  @Inject() private db: Database;\n ┊26┊27┊  @Inject() private pubsub: PubSub;\n ┊27┊28┊\n+┊  ┊29┊  private chatsCache = new Map<string, Chat>();\n ┊28┊30┊  private loaders = {\n ┊29┊31┊    chats: new DataLoader<ChatsKey, QueryResult['rows']>(keys => {\n ┊30┊32┊      return Promise.all(\n```\n```diff\n@@ -33,6 +35,10 @@\n ┊33┊35┊            return this._findChatsByUser(query.userId);\n ┊34┊36┊          }\n ┊35┊37┊\n+┊  ┊38┊          if (this.chatsCache.has(query.chatId)) {\n+┊  ┊39┊            return [this._readChatFromCache(query.chatId)];\n+┊  ┊40┊          }\n+┊  ┊41┊\n ┊36┊42┊          if (isChatByUser(query)) {\n ┊37┊43┊            return this._findChatByUser(query);\n ┊38┊44┊          }\n```\n```diff\n@@ -254,4 +260,14 @@\n ┊254┊260┊      throw e;\n ┊255┊261┊    }\n ┊256┊262┊  }\n+┊   ┊263┊\n+┊   ┊264┊  private _readChatFromCache(chatId: string) {\n+┊   ┊265┊    return this.chatsCache.get(chatId);\n+┊   ┊266┊  }\n+┊   ┊267┊\n+┊   ┊268┊  private _writeChatToCache(chat?: Chat) {\n+┊   ┊269┊    if (chat) {\n+┊   ┊270┊      this.chatsCache.set(chat.id, chat);\n+┊   ┊271┊    }\n+┊   ┊272┊  }\n ┊257┊273┊}\n```\n\n[}]: #\n\nWhenever we ask for a single chat that is available, it's being resolved right away but we still need to write data to the cache.\n\n[{]: <helper> (diffStep \"14.8\" module=\"server\")\n\n#### [__Server__ Step 14.8: Write chats to the cache](https://github.com/Urigo/WhatsApp-Clone-Server/commit/763779e)\n\n##### Changed modules&#x2F;chats&#x2F;chats.provider.ts\n```diff\n@@ -60,6 +60,10 @@\n ┊60┊60┊      AND chats_users.user_id = ${userId}\n ┊61┊61┊    `);\n ┊62┊62┊\n+┊  ┊63┊    rows.forEach(row => {\n+┊  ┊64┊      this._writeChatToCache(row);\n+┊  ┊65┊    });\n+┊  ┊66┊\n ┊63┊67┊    return rows;\n ┊64┊68┊  }\n ┊65┊69┊\n```\n```diff\n@@ -83,6 +87,8 @@\n ┊83┊87┊      AND chats_users.user_id = ${userId}\n ┊84┊88┊    `);\n ┊85┊89┊\n+┊  ┊90┊    this._writeChatToCache(rows[0]);\n+┊  ┊91┊\n ┊86┊92┊    return rows;\n ┊87┊93┊  }\n ┊88┊94┊\n```\n```diff\n@@ -95,6 +101,9 @@\n ┊ 95┊101┊    const { rows } = await this.db.query(sql`\n ┊ 96┊102┊      SELECT * FROM chats WHERE id = ${chatId}\n ┊ 97┊103┊    `);\n+┊   ┊104┊\n+┊   ┊105┊    this._writeChatToCache(rows[0]);\n+┊   ┊106┊\n ┊ 98┊107┊    return rows;\n ┊ 99┊108┊  }\n```\n\n[}]: #\n\nLet's look at charts in Apollo Engine.\n\n![Resolvers](../../../assets/step17/img-03.png \"Resolvers\")\n\nWe cut off `Message.chat` to less than 1ms.\n\nThe `Chat.name` and `Chat.picture` resolvers share the same logic and since Database service is wrapped with DataLoader, we make a single SQL query. Unfortunately, it's not visible on the graph.\n\nLet's summarize our work. **We made the GetChat operation almost 60% faster on average** and it's just based on one chat with one message. The number would be much much higher on a bigger scale.\n\n### Preventing issues\n\nThe Apollo Engine has another interesting feature. It’s called Alerts. You set a threshold for all operations or a specific one and whenever it takes longer, you get a notification on Slack. But there’s a catch, you need to pay in order to unlock it.\n\nWe’re working on something similar but entirely open-sourced. It’s an extension of ApolloServer that lets you track operations and get exactly what you would get from the engine but self-hosted.\n\n## UI Performance\n\nThe part would be the User Interface and the web app in general.\n\n### Metrics\n\nThere's a highly recommended and very comprehensive publication written by Philip Walton (Engineer at Google) called [\"User-centric Performance Metrics\"](https://developers.google.com/web/fundamentals/performance/user-centric-performance-metrics) that was an inspiration for this chapter. We’re going to talk in short about measuring render performance of a web application.\n\nLet’s base this chapter on real data. First, open the app and go to Performance tab of Chrome DevTools.\n\n![Record](../../../assets/step17/img-04.png \"Record\")\n\nNow click on “Start profiling and reload page”. After it’s done you should see the following:\n\n![All panels](../../../assets/step17/img-05.png \"All panels\")\n\nRight now it may not make a lot of sense, so we’re going to start with something basic.\n\nThere’s many different kinds of charts but we will cover only few of them: Network, Frames, Timings and Main.\n\nLet’s check out the Timings section and explain few important performance metrics.\n\n- DCL - DOMContentLoaded Event\n- L - Onload Event\n- FP - First Paint\n- FCP - First Contentful Paint\n- FMP - First Meaningful Paint\n\nThere’s also another one that is not visible on the timeline but also not less important, TTI - Time to Interactive.\n\nWe will focus on FP, FCP, FMP and TTI.\n\nThe primary difference between the two metrics is **First Paint** marks the point when the browser renders anything that is visually different from what was on the screen prior to navigation. By contrast, **First Contentful Paint** is the point when the browser renders the first bit of content from the DOM, which may be text, an image, SVG, or even a `<canvas>` element.\n\nThe **First Meaningful Paint** should mark the point when something useful was rendered. It might mean an input box on Google, video player on YouTube or in our case, a list of chats.\n\nThe **Time To Interactive** metric marks the point at which the application is both visually rendered and capable of reliably responding to user input.\n\nNow with all that knowledge we can move on to something more practical, the **Frames panel**. The main purpose here is to see what’s rendered at given time. In our case, the first paint was made after over 200ms, which is not a bad result at all but see that huge blank space next to it.\n\nThe **Network section**, is going to help us out here and give some pointers of what might be a reason of it. It’s a timeline that explains when each request was made and how long it took to resolve.\n\n![Network section](../../../assets/step17/img-06.png \"Network section\")\n\nWhat do we see here? One of the first requests are js files and we need those to bootstrap and render the app. That’s the reason of the blank page.\n\nWe could improve that by either Server-Side Rendering or using a Service Worker.\n\n### Rendering improvements\n\n#### Server-Side Rendering\n\nImplementing SSR means you run the app on server, before it’s being shipped to the client and the document’s content is not just `<html><body><app></app></body></html>` but an actual markup with all the components in it. Because it’s a part of the document, the browser can already display something meaningful and after js files are loaded, the app bootstraps on the client and it becomes interactive. There is one caveat. Wherever you ship the app it has to be able to run node js.\n\n#### Store Rehydration\n\nWhen talking SSR it’s worth to mention GraphQL and related technique called Store Rehydration. API calls are an important part of an application and plays a huge role in SSR.\n\nGraphQL operations are called once components are mounted which means the cache is filled up and why not reuse it on client.\n\nHow would it work? Data is extracted from the apollo’s cache and passed within a document. After it’s received by the browser, the app runs and so does the Apollo Client. While it happens we look for the data and fill up the cache. Now whenever a component calls a GraphQL operation, the result is already in the cache and resolves immediately.\n\n#### Service Worker\n\nAnother approach is a bit different. By using a Service Worker, we’re able to control and cache requests, including js files, images etc. On the first visit, the app loads exactly the same as without SSR but the next visits are a bit faster. It’s because the Service Worker is registered after you close the app and of course we can’t cache things that weren’t fetched yet.\n\nBoth techniques are not mutually exclusive and we highly recommend to use both.\n\n![Main section](../../../assets/step17/img-07.png \"Main section\")\n\nThe next section we’re going to talk about is the **Main panel**, a flame chart of activity on the main thread. You see those blocks? They represent an event, the wider it is the longer it took. One of the most important things to remember is to avoid long events since they block the thread.\nThe longest event on our timeline is the Evaluate Script event that involves `main.js`. The file contains all the libraries and the core functionality, those are needed to run the app. By making it lighter we would decrease the time of the first render.\nWe already do something to reduce the bundle size, This technique we use is called code-splitting and it allows to split one piece of code into multiple files which are lazy loaded.\nIt cuts off the size of the main bundle and the rest is loaded on demand, let’s say login page is in a different chunk than list of chats.\n\n### Tooling\n\nThere’s one tool built into Chrome DevTools called Lighthouse that allows to measure, collect metrics and get helpful tips on how to improve the performance and where are the pain points.\n\nHere’s the example:\n\n![Lighthouse results](../../../assets/step17/img-08.png \"Lighthouse results\")\n\nOnce your app is optimized you want to prevent regressions. Lighthouse has you covered! It may run as part of Continuous Integration and prevents deployment when key metrics regress or drop below a certain threshold.\n\n## Making the app feels instant\n\nDealing with slow network can be hard so let's simulate that situation. After all, running the application on local host will always result in low response times.\n\nLuckily most browser come with a built in solution for that - we can simulate a slow network by defining the throttle level:\n\n![Throttling](../../../assets/step17/img-09.png \"Throttling\")\n\nIf we will refresh the application, we should notice a significant slow down the first time we load each screen; about few seconds to load each of them. To ensure that this is really caused by a slow network and not by anything else, we can open the dev-tools of our browser (let’s assume you use Chrome) and under the `network` tab we should notice the network activity times.\n\n> More information about monitoring network activity and throttling it using the Chrome’s dev-tools can be found in [the official dev-tools docs page](https://developers.google.com/web/tools/chrome-devtools/network/).\n\nTo solve these issues there are a couple of changes we’re gonna make in the way we fetch and manage data.\n\n### Optimistic UI\n\nAs you know, pretty much in all cases, everything in Apollo flows through its cache. If a requested data is in there, a query is resolved right away. Mutations are a bit different, they have to reach the server every single time. Seems like nothing we can do about it but fortunately we can simulate the mutation, predict the result and make Apollo treat it as a temporary data. Which means, the app’s state and all components are updated and the change is visible instantly after it’s made.\n\nIn case of the WhatsApp clone, whenever a new message is sent, we will see it right away, on the screen, doesn’t matter if the network is low or even super fast. You may experience the similar behavior on Facebook’s Messenger.\n\n\n```graphql\n  mutation AddMessage($chatId: ID!, $content: String!) {\n    addMessage(chatId: $chatId, content: $content) {\n      ...Message\n    }\n  }\n```\n\n```graphql\n  addMessage({\n    variables: { chatId, content },\n    optimisticResponse: {\n      __typename: 'Mutation',\n      addMessage: {\n        __typename: 'Message',\n        id: Math.random().toString(36).substr(2, 9),\n        createdAt: new Date(),\n        isMine: true,\n        chat: {\n          __typename: 'Chat',\n          id: chatId,\n        },\n        content,\n      }\n    },\n    update: (client, { data: { addMessage } }) => {\n      writeMessage(client, addMessage);\n    },\n  })\n```\n\nWe used words “predict” and “simulate”, what if the mutation behaves differently or what’s more interesting, it fails. Apollo handles that as well. The “real” response overwrites the fake one and the store is reverted back to the original state.\n\n### Prefetching data\n\nAnother technique but with a bit different purpose is about fetching data in advance. In some situations, you might be able to predict which page/component is going to be entered next.\n\nLet’s base it on a real example. The WhatsApp clone has a page with a list of chats. The component that represents the page, calls a GraphQL operation to fetch that list. Right now, when user clicks on one of the chats, he’s redirected to a partially empty page because of the ongoing GraphQL request. What if we could fetch that data in advance? That’s what this technique is about. We could predict user’s next move based on a simple mouse event or even by using Artificial Intelligence and data collected by Google Analytics, so whenever the move actually happens, the data is already in the cache.\n\n[{]: <helper> (diffStep \"15.1\" files=\"src/components/ChatRoomScreen/index.tsx\" module=\"client\")\n\n#### [__Client__ Step 15.1: Implement prefetching](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/6afb776)\n\n##### Changed src&#x2F;components&#x2F;ChatRoomScreen&#x2F;index.tsx\n```diff\n@@ -2,12 +2,19 @@\n ┊ 2┊ 2┊import React from 'react';\n ┊ 3┊ 3┊import { useCallback } from 'react';\n ┊ 4┊ 4┊import { Redirect } from 'react-router-dom';\n+┊  ┊ 5┊import { useApolloClient } from 'react-apollo-hooks';\n ┊ 5┊ 6┊import styled from 'styled-components';\n ┊ 6┊ 7┊import ChatNavbar from './ChatNavbar';\n ┊ 7┊ 8┊import MessageInput from './MessageInput';\n ┊ 8┊ 9┊import MessagesList from './MessagesList';\n ┊ 9┊10┊import { History } from 'history';\n-┊10┊  ┊import { useGetChatQuery, useAddMessageMutation } from '../../graphql/types';\n+┊  ┊11┊import {\n+┊  ┊12┊  useGetChatQuery,\n+┊  ┊13┊  useAddMessageMutation,\n+┊  ┊14┊  GetChatQuery,\n+┊  ┊15┊  GetChatQueryVariables,\n+┊  ┊16┊  GetChatDocument,\n+┊  ┊17┊} from '../../graphql/types';\n ┊11┊18┊import * as fragments from '../../graphql/fragments';\n ┊12┊19┊import { writeMessage } from '../../services/cache.service';\n ┊13┊20┊\n```\n```diff\n@@ -38,6 +45,19 @@\n ┊38┊45┊  ${fragments.message}\n ┊39┊46┊`;\n ┊40┊47┊\n+┊  ┊48┊export const useGetChatPrefetch = () => {\n+┊  ┊49┊  const client = useApolloClient();\n+┊  ┊50┊\n+┊  ┊51┊  return (chatId: string) => {\n+┊  ┊52┊    client.query<GetChatQuery, GetChatQueryVariables>({\n+┊  ┊53┊      query: GetChatDocument,\n+┊  ┊54┊      variables: {\n+┊  ┊55┊        chatId,\n+┊  ┊56┊      },\n+┊  ┊57┊    });\n+┊  ┊58┊  };\n+┊  ┊59┊};\n+┊  ┊60┊\n ┊41┊61┊interface ChatRoomScreenParams {\n ┊42┊62┊  chatId: string;\n ┊43┊63┊  history: History;\n```\n\n[}]: #\n\nWe created the `useGetChatPrefetch` hook that gets ApolloClient instance through `useApolloClient` and returns a function to prefetch data. In this case we request `GetChat` operation. Because Apollo deduplicates queries, we won't make multiple http calls, we're safe.\n\nThe actual usage of `useGetChatPrefetch`, happens on `mouse entered` event:\n\n[{]: <helper> (diffStep \"15.1\" files=\"src/components/ChatsListScreen/ChatsList.tsx\" module=\"client\")\n\n#### [__Client__ Step 15.1: Implement prefetching](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/6afb776)\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;ChatsList.tsx\n```diff\n@@ -5,6 +5,7 @@\n ┊ 5┊ 5┊import { useCallback } from 'react';\n ┊ 6┊ 6┊import { History } from 'history';\n ┊ 7┊ 7┊import { useChatsQuery } from '../../graphql/types';\n+┊  ┊ 8┊import { useGetChatPrefetch } from '../ChatRoomScreen';\n ┊ 8┊ 9┊\n ┊ 9┊10┊const Container = styled.div`\n ┊10┊11┊  height: calc(100% - 56px);\n```\n```diff\n@@ -69,6 +70,7 @@\n ┊69┊70┊    },\n ┊70┊71┊    [history]\n ┊71┊72┊  );\n+┊  ┊73┊  const prefetchChat = useGetChatPrefetch();\n ┊72┊74┊\n ┊73┊75┊  const { data } = useChatsQuery();\n ┊74┊76┊\n```\n```diff\n@@ -86,7 +88,10 @@\n ┊86┊88┊            key={chat.id}\n ┊87┊89┊            data-testid=\"chat\"\n ┊88┊90┊            button\n-┊89┊  ┊            onClick={navToChat.bind(null, chat)}>\n+┊  ┊91┊            onClick={navToChat.bind(null, chat)}\n+┊  ┊92┊            onMouseEnter={() => {\n+┊  ┊93┊              prefetchChat(chat.id);\n+┊  ┊94┊            }}>\n ┊90┊95┊            <ChatPicture\n ┊91┊96┊              data-testid=\"picture\"\n ┊92┊97┊              src={chat.picture}\n```\n\n[}]: #\n\nNow, the same but with the list of users:\n\n[{]: <helper> (diffStep \"15.1\" files=\"src/components/ChatsListScreen/AddChatButton.tsx\" module=\"client\")\n\n#### [__Client__ Step 15.1: Implement prefetching](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/6afb776)\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;AddChatButton.tsx\n```diff\n@@ -3,6 +3,7 @@\n ┊3┊3┊import React from 'react';\n ┊4┊4┊import styled from 'styled-components';\n ┊5┊5┊import { History } from 'history';\n+┊ ┊6┊import { useUsersPrefetch } from '../UsersList';\n ┊6┊7┊\n ┊7┊8┊const Container = styled.div`\n ┊8┊9┊  position: fixed;\n```\n```diff\n@@ -18,17 +19,19 @@\n ┊18┊19┊    color: white;\n ┊19┊20┊  }\n ┊20┊21┊`;\n+┊  ┊22┊\n ┊21┊23┊interface ChildComponentProps {\n ┊22┊24┊  history: History;\n ┊23┊25┊}\n ┊24┊26┊\n ┊25┊27┊const AddChatButton: React.FC<ChildComponentProps> = ({ history }) => {\n+┊  ┊28┊  const prefetchUsers = useUsersPrefetch();\n ┊26┊29┊  const onClick = () => {\n ┊27┊30┊    history.push('/new-chat');\n ┊28┊31┊  };\n ┊29┊32┊\n ┊30┊33┊  return (\n-┊31┊  ┊    <Container>\n+┊  ┊34┊    <Container onMouseEnter={() => prefetchUsers()}>\n ┊32┊35┊      <Button\n ┊33┊36┊        data-testid=\"new-chat-button\"\n ┊34┊37┊        variant=\"contained\"\n```\n\n[}]: #\n[{]: <helper> (diffStep \"15.1\" files=\"src/components/ChatsListScreen/ChatsList.tsx\" module=\"client\")\n\n#### [__Client__ Step 15.1: Implement prefetching](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/6afb776)\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;ChatsList.tsx\n```diff\n@@ -5,6 +5,7 @@\n ┊ 5┊ 5┊import { useCallback } from 'react';\n ┊ 6┊ 6┊import { History } from 'history';\n ┊ 7┊ 7┊import { useChatsQuery } from '../../graphql/types';\n+┊  ┊ 8┊import { useGetChatPrefetch } from '../ChatRoomScreen';\n ┊ 8┊ 9┊\n ┊ 9┊10┊const Container = styled.div`\n ┊10┊11┊  height: calc(100% - 56px);\n```\n```diff\n@@ -69,6 +70,7 @@\n ┊69┊70┊    },\n ┊70┊71┊    [history]\n ┊71┊72┊  );\n+┊  ┊73┊  const prefetchChat = useGetChatPrefetch();\n ┊72┊74┊\n ┊73┊75┊  const { data } = useChatsQuery();\n ┊74┊76┊\n```\n```diff\n@@ -86,7 +88,10 @@\n ┊86┊88┊            key={chat.id}\n ┊87┊89┊            data-testid=\"chat\"\n ┊88┊90┊            button\n-┊89┊  ┊            onClick={navToChat.bind(null, chat)}>\n+┊  ┊91┊            onClick={navToChat.bind(null, chat)}\n+┊  ┊92┊            onMouseEnter={() => {\n+┊  ┊93┊              prefetchChat(chat.id);\n+┊  ┊94┊            }}>\n ┊90┊95┊            <ChatPicture\n ┊91┊96┊              data-testid=\"picture\"\n ┊92┊97┊              src={chat.picture}\n```\n\n[}]: #\n\n### Splitting and Deferring Queries\n\nPrefetching is an easy way to make your applications UI feel faster. You can use mouse events to predict the data that could be needed. This is powerful and works perfectly on the browser, but can not be applied to a mobile device.\n\nOne solution for improving the UI experience would be the usage of fragments to preload more data in a query, but loading huge amounts of data (that you probably never show to the user) is expensive.\n\nAnother solution would be to **split huge queries into two smaller queries**:\n\n- The first one could load data which is already in the store. This means that it can be displayed instantly.\n- The second query could load data which is not in the store yet and must be fetched from the server first.\n\nThis solution gives you the benefit of not fetching too much data, as well as the possibility to show some part of the views data before the server responds.\n\nThis could be used in our messaging app to load chat’s information and messages separately. This way we will see the title and the image instantly, because it’s already in the cache but messages will be loaded afterwards. UX will benefit a lot.\n\nThere’s also something very similar conceptually to Query Splitting but instead of separating queries we keep everything in one operation and annotate the parts that should be deferred. The annotation is, of course a directive and it’s called **`@defer`**.\n\nOnce the `@defer` is used, the server returns an initial response without waiting for deferred fields to resolve, using null as placeholders for them. Then, it streams patches for each deferred field asynchronously as they resolve. Thanks to that, we maintain one operation but decide how it behaves.\n\n> Right now, this feature is not well supported in Apollo Server so we don’t recommend to use it yet. Keep it on mind though.\n\n### Dealing with rendering issues\n\nThe most naive thing we can do to start noticing performance issues would be loading TONS of data to our app, and make sure that each view is absolutely overwhelmed with information. This way performance issues will start rising above the surface pretty quickly. To do that, we will edit the `resetDb()` method on the server so it can generate large quantities of data. The most comfortable way of controlling that behavior would be through an environment variable that will tell the reset method how much iterations it should run. The more iterations, the more data would be fabricated:\n\n[{]: <helper> (diffStep \"15.10\" module=\"server\")\n\n#### Step 15.10: NOT FOUND!\n\n[}]: #\n\nIt’s important to note that we’ve generated the data in a very specific way where a single user will be the center of the network of data. This way when we log in with that user, we should see our views packed. If it wasn’t for that we would have just had large quantities of data in the DB, but none of it would appear to the end-user.\n\nNow, we will restart the server and this time run it differently. We will provide `FAKED_DB` with a value of `100` which should connect us to 100 messages per single view:\n\n    RESET_DB=true FAKED_DB=100 yarn start\n\nNow make sure that the application is running and log-in with the first user of Ray Edwards using the credentials:\n\n    username: ray\n    passowrd: 111\n\nNow try to navigate around between the `ChatsScreen` and `ChatBoxScreen`. You’ll notice that each transition takes a long time until it shows the data. It’s obviously something which is related to rendering and not data transportation, because the slowdown also happens the second time you visit a view, a point where the fetched data should have already been stored by Apollo in cache. So we’ve already detected one performance issue we should deal with.\n\n### Pagination\n\nTo solve it, there are couple of changes we’re gonna make in the way we ask for data, messages will be fetched dynamically based on our scrolling position.\n\nWith these changes, the requests will be splitted into smaller chunks, and React DOM won’t have to deal with a lot of data the first time it loads. There are few challenges that may arise from this implementation:\n\n- Representing queries in a way that they can be loaded in chunks\n- Sending requests and updating the view dynamically\n- Maintaining updates from subscriptions\n\nTo start with, we will first take on the task of improving initialization times. We will release the pressure by fetching only the first 20 messages. This way when we visit a chat, it should be loaded faster.\n\nFor that we're going to implement cursor-based pagination. We will add `after` and `limit` arguments to `Chat.messages` that could be used to fetch a specific snapshot of available messages.\n\n- `after` is optional and marks the point where the last fetch ended (what is the last element of a received list)\n- `limit` is required, defines amount of data\n\nA common design pattern for fetching data snapshots from a GraphQL back-end is called [Relay](https://facebook.github.io/relay/docs/en/graphql-server-specification.html). Relay provides a robust solution which is suitable for things like search engines.\n\nWe will define our own version of it.\n\n[{]: <helper> (diffStep \"14.9\" module=\"server\")\n\n#### [__Server__ Step 14.9: Add fake data](https://github.com/Urigo/WhatsApp-Clone-Server/commit/4793087)\n\n##### Changed db.ts\n```diff\n@@ -1,6 +1,8 @@\n ┊1┊1┊import { Pool } from 'pg';\n ┊2┊2┊import sql from 'sql-template-strings';\n-┊3┊ ┊import { resetDb as envResetDb } from './env';\n+┊ ┊3┊import faker from 'faker';\n+┊ ┊4┊import addMinutes from 'date-fns/add_minutes';\n+┊ ┊5┊import { resetDb as envResetDb, fakedDb } from './env';\n ┊4┊6┊\n ┊5┊7┊export type User = {\n ┊6┊8┊  id: string;\n```\n```diff\n@@ -234,6 +236,10 @@\n ┊234┊236┊    },\n ┊235┊237┊  ];\n ┊236┊238┊\n+┊   ┊239┊  if (fakedDb) {\n+┊   ┊240┊    addFakedMessages(sampleMessages, fakedDb);\n+┊   ┊241┊  }\n+┊   ┊242┊\n ┊237┊243┊  for (const sampleMessage of sampleMessages) {\n ┊238┊244┊    await pool.query(sql`\n ┊239┊245┊      INSERT INTO messages(id, content, created_at, chat_id, sender_user_id)\n```\n```diff\n@@ -248,6 +254,21 @@\n ┊248┊254┊  );\n ┊249┊255┊};\n ┊250┊256┊\n+┊   ┊257┊function addFakedMessages(messages: Message[], count: number) {\n+┊   ┊258┊  const message = messages[0];\n+┊   ┊259┊  const date = message.created_at;\n+┊   ┊260┊  const id = messages.length + 1;\n+┊   ┊261┊\n+┊   ┊262┊  new Array(count).fill(0).forEach((_, i) => {\n+┊   ┊263┊    messages.push({\n+┊   ┊264┊      ...message,\n+┊   ┊265┊      id: `${id + i}`,\n+┊   ┊266┊      content: faker.lorem.sentence(4),\n+┊   ┊267┊      created_at: addMinutes(date, i + 1),\n+┊   ┊268┊    });\n+┊   ┊269┊  });\n+┊   ┊270┊}\n+┊   ┊271┊\n ┊251┊272┊if (envResetDb) {\n ┊252┊273┊  resetDb();\n ┊253┊274┊}\n```\n\n##### Changed env.ts\n```diff\n@@ -5,3 +5,6 @@\n ┊ 5┊ 5┊export const origin = process.env.ORIGIN || 'http://localhost:3000';\n ┊ 6┊ 6┊export const port = process.env.PORT || 4000;\n ┊ 7┊ 7┊export const resetDb = process.env.RESET_DB || false;\n+┊  ┊ 8┊export const fakedDb = process.env.FAKED_DB\n+┊  ┊ 9┊  ? parseInt(process.env.FAKED_DB, 10)\n+┊  ┊10┊  : 0;\n```\n\n##### Changed package.json\n```diff\n@@ -26,6 +26,7 @@\n ┊26┊26┊    \"@types/cookie-parser\": \"1.4.1\",\n ┊27┊27┊    \"@types/cors\": \"2.8.5\",\n ┊28┊28┊    \"@types/express\": \"4.17.0\",\n+┊  ┊29┊    \"@types/faker\": \"4.1.5\",\n ┊29┊30┊    \"@types/graphql\": \"14.2.0\",\n ┊30┊31┊    \"@types/graphql-iso-date\": \"3.3.1\",\n ┊31┊32┊    \"@types/jest\": \"24.0.13\",\n```\n```diff\n@@ -54,7 +55,9 @@\n ┊54┊55┊    \"cookie-parser\": \"1.4.4\",\n ┊55┊56┊    \"cors\": \"2.8.5\",\n ┊56┊57┊    \"dataloader\": \"1.4.0\",\n+┊  ┊58┊    \"date-fns\": \"1.30.1\",\n ┊57┊59┊    \"express\": \"4.17.1\",\n+┊  ┊60┊    \"faker\": \"4.1.0\",\n ┊58┊61┊    \"graphql\": \"14.3.1\",\n ┊59┊62┊    \"graphql-import\": \"0.7.1\",\n ┊60┊63┊    \"graphql-iso-date\": \"3.6.1\",\n```\n\n[}]: #\n\nThe `MessagesResult` is built of:\n\n- `cursor` - marks the end of a fetched list\n- `hasMore` - tells if there's more data to ask for\n- `message` - has the same type as `Chat.messages` previously had\n\nBecause the cursor marks the edge of received data, it has to be something we could use while sorting. The most obvious choice is the date of creation, so `created_at` column of `messages` table.\n\nIt's stored as `YYYY-MM-DD HH:mm:ss` but we want to expose it as something easier to work with, let's say a `number`.\n\nIn order to do it quickly, let's add `date-fns` package:\n\n    npm install date-fns\n\nIt has `format` method that will help us to do conversions.\n\nWe need to the logic of `Chats.findMessagesByChat` method.\n\n[{]: <helper> (diffStep \"14.11\" module=\"server\")\n\n#### [__Server__ Step 14.11: Implement cursor-based pagination in messages](https://github.com/Urigo/WhatsApp-Clone-Server/commit/3bb33d2)\n\n##### Changed modules&#x2F;chats&#x2F;chats.provider.ts\n```diff\n@@ -2,6 +2,7 @@\n ┊2┊2┊import { QueryResult } from 'pg';\n ┊3┊3┊import sql from 'sql-template-strings';\n ┊4┊4┊import DataLoader from 'dataloader';\n+┊ ┊5┊import format from 'date-fns/format';\n ┊5┊6┊import { Database } from '../common/database.provider';\n ┊6┊7┊import { PubSub } from '../common/pubsub.provider';\n ┊7┊8┊import { Chat } from '../../db';\n```\n```diff\n@@ -107,12 +108,55 @@\n ┊107┊108┊    return rows;\n ┊108┊109┊  }\n ┊109┊110┊\n-┊110┊   ┊  async findMessagesByChat(chatId: string) {\n-┊111┊   ┊    const { rows } = await this.db.query(\n-┊112┊   ┊      sql`SELECT * FROM messages WHERE chat_id = ${chatId}`\n+┊   ┊111┊  async findMessagesByChat({\n+┊   ┊112┊    chatId,\n+┊   ┊113┊    limit,\n+┊   ┊114┊    after,\n+┊   ┊115┊  }: {\n+┊   ┊116┊    chatId: string;\n+┊   ┊117┊    limit: number;\n+┊   ┊118┊    after?: number | null;\n+┊   ┊119┊  }): Promise<{\n+┊   ┊120┊    hasMore: boolean;\n+┊   ┊121┊    cursor: number | null;\n+┊   ┊122┊    messages: any[];\n+┊   ┊123┊  }> {\n+┊   ┊124┊    const query = sql`SELECT * FROM messages`;\n+┊   ┊125┊    query.append(` WHERE chat_id = ${chatId}`);\n+┊   ┊126┊\n+┊   ┊127┊    if (after) {\n+┊   ┊128┊      // the created_at is the cursor\n+┊   ┊129┊      query.append(` AND created_at < ${cursorToDate(after)}`);\n+┊   ┊130┊    }\n+┊   ┊131┊\n+┊   ┊132┊    query.append(` ORDER BY created_at DESC LIMIT ${limit}`);\n+┊   ┊133┊\n+┊   ┊134┊    const { rows: messages } = await this.db.query(query);\n+┊   ┊135┊\n+┊   ┊136┊    if (!messages) {\n+┊   ┊137┊      return {\n+┊   ┊138┊        hasMore: false,\n+┊   ┊139┊        cursor: null,\n+┊   ┊140┊        messages: [],\n+┊   ┊141┊      };\n+┊   ┊142┊    }\n+┊   ┊143┊\n+┊   ┊144┊    // so we send them as old -> new\n+┊   ┊145┊    messages.reverse();\n+┊   ┊146┊\n+┊   ┊147┊    // cursor is a number representation of created_at\n+┊   ┊148┊    const cursor = new Date(messages[0].created_at).getTime();\n+┊   ┊149┊    const { rows: next } = await this.db.query(\n+┊   ┊150┊      sql`SELECT * FROM messages WHERE chat_id = ${chatId} AND created_at < ${cursorToDate(\n+┊   ┊151┊        cursor\n+┊   ┊152┊      )} ORDER BY created_at DESC LIMIT 1`\n ┊113┊153┊    );\n ┊114┊154┊\n-┊115┊   ┊    return rows;\n+┊   ┊155┊    return {\n+┊   ┊156┊      hasMore: next.length === 1, // means there's no more messages\n+┊   ┊157┊      cursor,\n+┊   ┊158┊      messages,\n+┊   ┊159┊    };\n ┊116┊160┊  }\n ┊117┊161┊\n ┊118┊162┊  async lastMessage(chatId: string) {\n```\n```diff\n@@ -280,3 +324,7 @@\n ┊280┊324┊    }\n ┊281┊325┊  }\n ┊282┊326┊}\n+┊   ┊327┊\n+┊   ┊328┊function cursorToDate(cursor: number) {\n+┊   ┊329┊  return `'${format(cursor, 'YYYY-MM-DD HH:mm:ss')}'`;\n+┊   ┊330┊}\n```\n\n##### Changed modules&#x2F;chats&#x2F;index.ts\n```diff\n@@ -111,7 +111,11 @@\n ┊111┊111┊    },\n ┊112┊112┊\n ┊113┊113┊    async messages(chat, args, { injector }) {\n-┊114┊   ┊      return injector.get(Chats).findMessagesByChat(chat.id);\n+┊   ┊114┊      return injector.get(Chats).findMessagesByChat({\n+┊   ┊115┊        chatId: chat.id,\n+┊   ┊116┊        limit: args.limit,\n+┊   ┊117┊        after: args.after,\n+┊   ┊118┊      });\n ┊115┊119┊    },\n ┊116┊120┊\n ┊117┊121┊    async lastMessage(chat, args, { injector }) {\n```\n\n[}]: #\n\nBecause the order of creation matters, messages are selected quite differently than before, we keep selecting all columns but records are ordered by the date of creation.\n\nThere's an interesting thing related to the cursor. If it's provided, we query for only those messages that happened before our cursor. This way we have a valid direction, fetching more messages means fetching older records.\n\nThe last message in the list becomes of course the `cursor`.\n\nIn order to calculate `hasMore` we need to apply the same conditions as above but with `LIMIT 1` and see if we get a result.\n\nSince the API part is done, let's take care of something much more complicated, which is always the UI...\n\nLet's plan it first. We know we want to fetch more messages while scrolling up. That means, Infinite Scroll with a corresponding request each time we hit the top. Because we implemented prefetching, we need to know what's the `limit`. React's Context might be helpful here. There was, of course, the change in GraphQL Schema we need to take care of too.\n\n### Apply schema changes\n\nSince we know what the plan is, let's start with schema changes. The `Chat.messages` is no longer a list, it's an object now.\n\n[{]: <helper> (diffStep \"15.6\" module=\"client\")\n\n#### [__Client__ Step 15.6: Apply MessagesResult type](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/9630541)\n\n##### Changed src&#x2F;components&#x2F;ChatRoomScreen&#x2F;index.tsx\n```diff\n@@ -27,7 +27,7 @@\n ┊27┊27┊\n ┊28┊28┊// eslint-disable-next-line\n ┊29┊29┊const getChatQuery = gql`\n-┊30┊  ┊  query GetChat($chatId: ID!) {\n+┊  ┊30┊  query GetChat($chatId: ID!, $limit: Int!, $after: Float) {\n ┊31┊31┊    chat(chatId: $chatId) {\n ┊32┊32┊      ...FullChat\n ┊33┊33┊    }\n```\n\n##### Changed src&#x2F;graphql&#x2F;fragments&#x2F;fullChat.fragment.ts\n```diff\n@@ -1,14 +1,14 @@\n ┊ 1┊ 1┊import gql from 'graphql-tag';\n ┊ 2┊ 2┊import chat from './chat.fragment';\n-┊ 3┊  ┊import message from './message.fragment';\n+┊  ┊ 3┊import messagesResult from './messagesResult.fragment';\n ┊ 4┊ 4┊\n ┊ 5┊ 5┊export default gql`\n ┊ 6┊ 6┊  fragment FullChat on Chat {\n ┊ 7┊ 7┊    ...Chat\n-┊ 8┊  ┊    messages {\n-┊ 9┊  ┊      ...Message\n+┊  ┊ 8┊    messages(limit: $limit, after: $after) @connection(key: \"messages\") {\n+┊  ┊ 9┊      ...MessagesResult\n ┊10┊10┊    }\n ┊11┊11┊  }\n ┊12┊12┊  ${chat}\n-┊13┊  ┊  ${message}\n+┊  ┊13┊  ${messagesResult}\n ┊14┊14┊`;\n```\n\n##### Added src&#x2F;graphql&#x2F;fragments&#x2F;messagesResult.fragment.ts\n```diff\n@@ -0,0 +1,13 @@\n+┊  ┊ 1┊import gql from 'graphql-tag';\n+┊  ┊ 2┊import message from './message.fragment';\n+┊  ┊ 3┊\n+┊  ┊ 4┊export default gql`\n+┊  ┊ 5┊  fragment MessagesResult on MessagesResult {\n+┊  ┊ 6┊    cursor\n+┊  ┊ 7┊    hasMore\n+┊  ┊ 8┊    messages {\n+┊  ┊ 9┊      ...Message\n+┊  ┊10┊    }\n+┊  ┊11┊  }\n+┊  ┊12┊  ${message}\n+┊  ┊13┊`;\n```\n\n##### Changed src&#x2F;services&#x2F;cache.service.ts\n```diff\n@@ -61,9 +61,9 @@\n ┊61┊61┊  if (fullChat === null || fullChat.messages === null) {\n ┊62┊62┊    return;\n ┊63┊63┊  }\n-┊64┊  ┊  if (fullChat.messages.some((m: any) => m.id === message.id)) return;\n+┊  ┊64┊  if (fullChat.messages.messages.some((m: any) => m.id === message.id)) return;\n ┊65┊65┊\n-┊66┊  ┊  fullChat.messages.push(message);\n+┊  ┊66┊  fullChat.messages.messages.push(message);\n ┊67┊67┊  fullChat.lastMessage = message;\n ┊68┊68┊\n ┊69┊69┊  client.writeFragment({\n```\n\n[}]: #\n\nNow we need reflect those changes in generated hooks by running:\n\n    yarn codegen\n\nOkay, let's move on!\n\n### Infinite Scrolling\n\nNow this Infinite Scroll thing. The core concept is to ask for more data, once a user's scrollbar hits the top edge of the screen.\n\n[{]: <helper> (diffStep \"15.2\" module=\"client\")\n\n#### [__Client__ Step 15.2: Basics for infinite scroll](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/18c2024)\n\n##### Added src&#x2F;hooks&#x2F;use-infinite-scroll.ts\n```diff\n@@ -0,0 +1,32 @@\n+┊  ┊ 1┊import { useEffect, useCallback, RefObject } from 'react';\n+┊  ┊ 2┊\n+┊  ┊ 3┊export const useInfiniteScroll = ({\n+┊  ┊ 4┊  ref,\n+┊  ┊ 5┊  onLoadMore,\n+┊  ┊ 6┊}: {\n+┊  ┊ 7┊  onLoadMore: Function;\n+┊  ┊ 8┊  ref: RefObject<HTMLElement>;\n+┊  ┊ 9┊}) => {\n+┊  ┊10┊  const handleScroll = useCallback(() => {\n+┊  ┊11┊    if (ref.current!.scrollTop === 0) {\n+┊  ┊12┊      // loads more if scrolled to top\n+┊  ┊13┊      onLoadMore();\n+┊  ┊14┊    }\n+┊  ┊15┊  }, [ref, onLoadMore]);\n+┊  ┊16┊\n+┊  ┊17┊  useEffect(() => {\n+┊  ┊18┊    const elem = ref.current;\n+┊  ┊19┊\n+┊  ┊20┊    if (!elem) {\n+┊  ┊21┊      return;\n+┊  ┊22┊    }\n+┊  ┊23┊\n+┊  ┊24┊    elem.addEventListener('scroll', handleScroll);\n+┊  ┊25┊\n+┊  ┊26┊    return () => {\n+┊  ┊27┊      elem!.removeEventListener('scroll', handleScroll);\n+┊  ┊28┊    };\n+┊  ┊29┊  }, [ref, handleScroll]);\n+┊  ┊30┊};\n+┊  ┊31┊\n+┊  ┊32┊export default useInfiniteScroll;\n```\n\n[}]: #\n\nOur `useInfiniteScroll` hook requires:\n\n- `ref` is a reference of a HTML element\n- `onLoadMore` calls the part component back and asks for data\n\nWe used `useEffect` to add and remove a scroll event listener. The function lives as long as `ref` and `onLoadMore` stay the same, that's because we simply make use of them in `handleScroll` function. The `handleScroll` function calls `onLoadMore` when a user scrolled to the top.\n\nIt all looks fine at first, but we still need to prevent calling back once fetching is in progress.\n\n[{]: <helper> (diffStep \"15.3\" module=\"client\")\n\n#### [__Client__ Step 15.3: Prevent calling back once fetching is in progress](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/e00b740)\n\n##### Changed src&#x2F;hooks&#x2F;use-infinite-scroll.ts\n```diff\n@@ -1,4 +1,4 @@\n-┊1┊ ┊import { useEffect, useCallback, RefObject } from 'react';\n+┊ ┊1┊import { useState, useEffect, useCallback, RefObject } from 'react';\n ┊2┊2┊\n ┊3┊3┊export const useInfiniteScroll = ({\n ┊4┊4┊  ref,\n```\n```diff\n@@ -7,12 +7,13 @@\n ┊ 7┊ 7┊  onLoadMore: Function;\n ┊ 8┊ 8┊  ref: RefObject<HTMLElement>;\n ┊ 9┊ 9┊}) => {\n+┊  ┊10┊  const [isFetching, setIsFetching] = useState(false);\n ┊10┊11┊  const handleScroll = useCallback(() => {\n-┊11┊  ┊    if (ref.current!.scrollTop === 0) {\n-┊12┊  ┊      // loads more if scrolled to top\n-┊13┊  ┊      onLoadMore();\n+┊  ┊12┊    if (ref.current!.scrollTop === 0 && isFetching === false) {\n+┊  ┊13┊      // starts to fetch if scrolled to top and fetching is not in progress\n+┊  ┊14┊      setIsFetching(true);\n ┊14┊15┊    }\n-┊15┊  ┊  }, [ref, onLoadMore]);\n+┊  ┊16┊  }, [ref, isFetching]);\n ┊16┊17┊\n ┊17┊18┊  useEffect(() => {\n ┊18┊19┊    const elem = ref.current;\n```\n```diff\n@@ -27,6 +28,13 @@\n ┊27┊28┊      elem!.removeEventListener('scroll', handleScroll);\n ┊28┊29┊    };\n ┊29┊30┊  }, [ref, handleScroll]);\n+┊  ┊31┊\n+┊  ┊32┊  // loads more if fetching has started\n+┊  ┊33┊  useEffect(() => {\n+┊  ┊34┊    if (isFetching) {\n+┊  ┊35┊      onLoadMore();\n+┊  ┊36┊    }\n+┊  ┊37┊  }, [isFetching, onLoadMore]);\n ┊30┊38┊};\n ┊31┊39┊\n ┊32┊40┊export default useInfiniteScroll;\n```\n\n[}]: #\n\nThat's why `isFetching` state is necessary but as you can tell, we don't set it to `false`.\n\n[{]: <helper> (diffStep \"15.4\" module=\"client\")\n\n#### [__Client__ Step 15.4: Allow to notify when finished](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/59940f0)\n\n##### Changed src&#x2F;hooks&#x2F;use-infinite-scroll.ts\n```diff\n@@ -6,7 +6,7 @@\n ┊ 6┊ 6┊}: {\n ┊ 7┊ 7┊  onLoadMore: Function;\n ┊ 8┊ 8┊  ref: RefObject<HTMLElement>;\n-┊ 9┊  ┊}) => {\n+┊  ┊ 9┊}): [boolean, () => void] => {\n ┊10┊10┊  const [isFetching, setIsFetching] = useState(false);\n ┊11┊11┊  const handleScroll = useCallback(() => {\n ┊12┊12┊    if (ref.current!.scrollTop === 0 && isFetching === false) {\n```\n```diff\n@@ -35,6 +35,12 @@\n ┊35┊35┊      onLoadMore();\n ┊36┊36┊    }\n ┊37┊37┊  }, [isFetching, onLoadMore]);\n+┊  ┊38┊\n+┊  ┊39┊  const stopFetching = useCallback(() => {\n+┊  ┊40┊    setIsFetching(false);\n+┊  ┊41┊  }, []);\n+┊  ┊42┊\n+┊  ┊43┊  return [isFetching, stopFetching];\n ┊38┊44┊};\n ┊39┊45┊\n ┊40┊46┊export default useInfiniteScroll;\n```\n\n[}]: #\n\nWe want the consumer of the hook to tell it when fetching is finished, that's why we expose the state with `stopFetching` function.\n\nThe next issue that appears right away is related to the case when there's no more data to fetch.\n\n[{]: <helper> (diffStep \"15.5\" module=\"client\")\n\n#### [__Client__ Step 15.5: Fetch only if there is more data](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/f5251f8)\n\n##### Changed src&#x2F;hooks&#x2F;use-infinite-scroll.ts\n```diff\n@@ -2,18 +2,20 @@\n ┊ 2┊ 2┊\n ┊ 3┊ 3┊export const useInfiniteScroll = ({\n ┊ 4┊ 4┊  ref,\n+┊  ┊ 5┊  hasMore,\n ┊ 5┊ 6┊  onLoadMore,\n ┊ 6┊ 7┊}: {\n ┊ 7┊ 8┊  onLoadMore: Function;\n+┊  ┊ 9┊  hasMore: boolean;\n ┊ 8┊10┊  ref: RefObject<HTMLElement>;\n ┊ 9┊11┊}): [boolean, () => void] => {\n ┊10┊12┊  const [isFetching, setIsFetching] = useState(false);\n ┊11┊13┊  const handleScroll = useCallback(() => {\n-┊12┊  ┊    if (ref.current!.scrollTop === 0 && isFetching === false) {\n-┊13┊  ┊      // starts to fetch if scrolled to top and fetching is not in progress\n+┊  ┊14┊    if (ref.current!.scrollTop === 0 && isFetching === false && hasMore) {\n+┊  ┊15┊      // starts to fetch if scrolled to top, fetching is not in progress and has more data\n ┊14┊16┊      setIsFetching(true);\n ┊15┊17┊    }\n-┊16┊  ┊  }, [ref, isFetching]);\n+┊  ┊18┊  }, [ref, isFetching, hasMore]);\n ┊17┊19┊\n ┊18┊20┊  useEffect(() => {\n ┊19┊21┊    const elem = ref.current;\n```\n\n[}]: #\n\nPfff... The hook part is done!\n\n### Pagination\n\nPagination is partially implemented thanks to Infinite Scrolling but the thing we need to still apply is React's context. It will be a central place of storing `limit` and `after` values, so they could be shared across multiple components and not passed directly from one to another.\n\n[{]: <helper> (diffStep \"15.7\" module=\"client\")\n\n#### [__Client__ Step 15.7: Implement pagination with context and hooks](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/88553d4)\n\n##### Changed src&#x2F;components&#x2F;ChatRoomScreen&#x2F;index.tsx\n```diff\n@@ -1,6 +1,6 @@\n ┊1┊1┊import gql from 'graphql-tag';\n ┊2┊2┊import React from 'react';\n-┊3┊ ┊import { useCallback } from 'react';\n+┊ ┊3┊import { useCallback, useState, useContext, useEffect } from 'react';\n ┊4┊4┊import { Redirect } from 'react-router-dom';\n ┊5┊5┊import { useApolloClient } from 'react-apollo-hooks';\n ┊6┊6┊import styled from 'styled-components';\n```\n```diff\n@@ -45,6 +45,48 @@\n ┊45┊45┊  ${fragments.message}\n ┊46┊46┊`;\n ┊47┊47┊\n+┊  ┊48┊const PaginationContext = React.createContext({\n+┊  ┊49┊  after: 0,\n+┊  ┊50┊  limit: 20,\n+┊  ┊51┊  /**\n+┊  ┊52┊   * Sets new cursor\n+┊  ┊53┊   */\n+┊  ┊54┊  setAfter: (after: number) => {},\n+┊  ┊55┊  /**\n+┊  ┊56┊   * Resets `after` value to its inital state (null) so\n+┊  ┊57┊   */\n+┊  ┊58┊  reset: () => {},\n+┊  ┊59┊});\n+┊  ┊60┊\n+┊  ┊61┊const usePagination = () => {\n+┊  ┊62┊  const pagination = useContext(PaginationContext);\n+┊  ┊63┊\n+┊  ┊64┊  // Resets the pagination every time a component did unmount\n+┊  ┊65┊  useEffect(() => {\n+┊  ┊66┊    return () => {\n+┊  ┊67┊      pagination.reset();\n+┊  ┊68┊    };\n+┊  ┊69┊  }, [pagination]);\n+┊  ┊70┊\n+┊  ┊71┊  return pagination;\n+┊  ┊72┊};\n+┊  ┊73┊\n+┊  ┊74┊export const ChatPaginationProvider = ({ children }: { children: any }) => {\n+┊  ┊75┊  const [after, setAfter] = useState<number | null>(null);\n+┊  ┊76┊\n+┊  ┊77┊  return (\n+┊  ┊78┊    <PaginationContext.Provider\n+┊  ┊79┊      value={{\n+┊  ┊80┊        limit: 20,\n+┊  ┊81┊        after: after!,\n+┊  ┊82┊        setAfter,\n+┊  ┊83┊        reset: () => setAfter(null),\n+┊  ┊84┊      }}>\n+┊  ┊85┊      {children}\n+┊  ┊86┊    </PaginationContext.Provider>\n+┊  ┊87┊  );\n+┊  ┊88┊};\n+┊  ┊89┊\n ┊48┊90┊export const useGetChatPrefetch = () => {\n ┊49┊91┊  const client = useApolloClient();\n```\n\n[}]: #\n\nWe implemented three things:\n\n- `PaginationContext` is simple, it stores the values but also allows to set a new one for `after` or even bring it all back to the initial state.\n- `usePagination` hook is there so components could use `PaginationContext` and to make sure we reset it when component unmounts.\n- `ChatPaginationProvider` provides the logic and core functionality\n\nSince the pagination is almost ready, let's make use of it in `useGetChatPrefetch` hook and `ChatRoomScreen` component.\n\n[{]: <helper> (diffStep \"15.8\" module=\"client\")\n\n#### [__Client__ Step 15.8: Use pagination limit and after props](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/4c1de7a)\n\n##### Changed src&#x2F;components&#x2F;ChatRoomScreen&#x2F;index.tsx\n```diff\n@@ -89,12 +89,15 @@\n ┊ 89┊ 89┊\n ┊ 90┊ 90┊export const useGetChatPrefetch = () => {\n ┊ 91┊ 91┊  const client = useApolloClient();\n+┊   ┊ 92┊  const { limit, after } = usePagination();\n ┊ 92┊ 93┊\n ┊ 93┊ 94┊  return (chatId: string) => {\n ┊ 94┊ 95┊    client.query<GetChatQuery, GetChatQueryVariables>({\n ┊ 95┊ 96┊      query: GetChatDocument,\n ┊ 96┊ 97┊      variables: {\n ┊ 97┊ 98┊        chatId,\n+┊   ┊ 99┊        after,\n+┊   ┊100┊        limit,\n ┊ 98┊101┊      },\n ┊ 99┊102┊    });\n ┊100┊103┊  };\n```\n```diff\n@@ -109,8 +112,9 @@\n ┊109┊112┊  history,\n ┊110┊113┊  chatId,\n ┊111┊114┊}) => {\n+┊   ┊115┊  const { after, limit } = usePagination();\n ┊112┊116┊  const { data, loading } = useGetChatQuery({\n-┊113┊   ┊    variables: { chatId },\n+┊   ┊117┊    variables: { chatId, after, limit },\n ┊114┊118┊  });\n ┊115┊119┊\n ┊116┊120┊  const addMessage = useAddMessageMutation();\n```\n\n[}]: #\n\nThis won't work yet because there's nothing that creates the context.\n\n[{]: <helper> (diffStep \"15.9\" module=\"client\")\n\n#### [__Client__ Step 15.9: Use ChatPaginationProvider](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/b620f82)\n\n##### Changed src&#x2F;components&#x2F;ChatRoomScreen&#x2F;index.tsx\n```diff\n@@ -108,10 +108,7 @@\n ┊108┊108┊  history: History;\n ┊109┊109┊}\n ┊110┊110┊\n-┊111┊   ┊const ChatRoomScreen: React.FC<ChatRoomScreenParams> = ({\n-┊112┊   ┊  history,\n-┊113┊   ┊  chatId,\n-┊114┊   ┊}) => {\n+┊   ┊111┊const ChatRoom: React.FC<ChatRoomScreenParams> = ({ history, chatId }) => {\n ┊115┊112┊  const { after, limit } = usePagination();\n ┊116┊113┊  const { data, loading } = useGetChatQuery({\n ┊117┊114┊    variables: { chatId, after, limit },\n```\n```diff\n@@ -176,4 +173,15 @@\n ┊176┊173┊  );\n ┊177┊174┊};\n ┊178┊175┊\n+┊   ┊176┊const ChatRoomScreen: React.FC<ChatRoomScreenParams> = ({\n+┊   ┊177┊  history,\n+┊   ┊178┊  chatId,\n+┊   ┊179┊}) => {\n+┊   ┊180┊  return (\n+┊   ┊181┊    <ChatPaginationProvider>\n+┊   ┊182┊      <ChatRoom history={history} chatId={chatId} />\n+┊   ┊183┊    </ChatPaginationProvider>\n+┊   ┊184┊  );\n+┊   ┊185┊};\n+┊   ┊186┊\n ┊179┊187┊export default ChatRoomScreen;\n```\n\n[}]: #\n\nWe had to split the `ChatRoomScreen` into two pieces. One that includes `ChatPaginationProvider` and produces `chatId` and the other that keeps pretty much everything else. This way the tree of child components, starting from `ChatRoom` share the same context.\n\n### Fetching more messages\n\nEverything is set up, we can now move on and consume the `useInfiniteScroll` in the `MessagesList` component.\n\n[{]: <helper> (diffStep \"15.10\" module=\"client\")\n\n#### [__Client__ Step 15.10: Make use of infinite scroll in MessagesList component](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/12e95f7)\n\n##### Changed src&#x2F;components&#x2F;ChatRoomScreen&#x2F;MessagesList.tsx\n```diff\n@@ -3,14 +3,27 @@\n ┊ 3┊ 3┊import { useEffect, useRef } from 'react';\n ┊ 4┊ 4┊import ReactDOM from 'react-dom';\n ┊ 5┊ 5┊import styled, { css } from 'styled-components';\n+┊  ┊ 6┊import { useInfiniteScroll } from '../../hooks/use-infinite-scroll';\n ┊ 6┊ 7┊\n ┊ 7┊ 8┊const Container = styled.div`\n+┊  ┊ 9┊  position: relative;\n ┊ 8┊10┊  display: block;\n ┊ 9┊11┊  flex: 2;\n ┊10┊12┊  overflow-y: overlay;\n ┊11┊13┊  padding: 0 15px;\n ┊12┊14┊`;\n ┊13┊15┊\n+┊  ┊16┊const LoadingMore = styled.div`\n+┊  ┊17┊  height: 30px;\n+┊  ┊18┊  line-height: 30px;\n+┊  ┊19┊  position: absolute;\n+┊  ┊20┊  top: 0;\n+┊  ┊21┊  right: 0;\n+┊  ┊22┊  bottom: 0;\n+┊  ┊23┊  left: 0;\n+┊  ┊24┊  text-align: center;\n+┊  ┊25┊`;\n+┊  ┊26┊\n ┊14┊27┊type StyledProp = {\n ┊15┊28┊  isMine: any;\n ┊16┊29┊};\n```\n```diff\n@@ -89,19 +102,36 @@\n ┊ 89┊102┊}\n ┊ 90┊103┊interface MessagesListProps {\n ┊ 91┊104┊  messages: Array<Message>;\n+┊   ┊105┊  loadMore: Function;\n+┊   ┊106┊  hasMore: boolean;\n ┊ 92┊107┊}\n ┊ 93┊108┊\n-┊ 94┊   ┊const MessagesList: React.FC<MessagesListProps> = ({ messages }) => {\n-┊ 95┊   ┊  const selfRef = useRef(null);\n+┊   ┊109┊const MessagesList: React.FC<MessagesListProps> = ({\n+┊   ┊110┊  messages,\n+┊   ┊111┊  loadMore,\n+┊   ┊112┊  hasMore,\n+┊   ┊113┊}) => {\n+┊   ┊114┊  const selfRef = useRef<HTMLDivElement>(null);\n+┊   ┊115┊  const [fetching, stopFetching] = useInfiniteScroll({\n+┊   ┊116┊    onLoadMore: loadMore,\n+┊   ┊117┊    hasMore,\n+┊   ┊118┊    ref: selfRef!,\n+┊   ┊119┊  });\n ┊ 96┊120┊\n ┊ 97┊121┊  useEffect(() => {\n ┊ 98┊122┊    if (!selfRef.current) return;\n+┊   ┊123┊\n+┊   ┊124┊    if (fetching) {\n+┊   ┊125┊      stopFetching();\n+┊   ┊126┊    }\n+┊   ┊127┊\n ┊ 99┊128┊    const selfDOMNode = ReactDOM.findDOMNode(selfRef.current) as HTMLElement;\n ┊100┊129┊    selfDOMNode.scrollTop = Number.MAX_SAFE_INTEGER;\n-┊101┊   ┊  }, [messages.length]);\n+┊   ┊130┊  }, [messages.length, selfRef, fetching, stopFetching]);\n ┊102┊131┊\n ┊103┊132┊  return (\n ┊104┊133┊    <Container ref={selfRef}>\n+┊   ┊134┊      {fetching && <LoadingMore>{'Loading more messages...'}</LoadingMore>}\n ┊105┊135┊      {messages.map((message: any) => (\n ┊106┊136┊        <MessageItem\n ┊107┊137┊          data-testid=\"message-item\"\n```\n\n[}]: #\n\nWe added the `LoadingMore` component with *Loading more messages...* text in it that pops out when fetching is in progress.\nBecause the `MessagesList` is not responsible of quering data we don't know exactly when it's completed but we can assume, it happens once the length of `messages` changes.\nWe also pass `onLoadMore` and `hasMore` props to the parent component and the `useInfiniteScroll` uses `MessagesList` as the element we're going to scroll in.\n\nThere's also one more thing that could be turned into a hook, it's the logic responsible for scrolling to bottom of the page, every time `messages` changes.\n\n[{]: <helper> (diffStep \"15.11\" module=\"client\")\n\n#### [__Client__ Step 15.11: Implement a hook responsible for scrolling](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/49d80a1)\n\n##### Changed src&#x2F;components&#x2F;ChatRoomScreen&#x2F;MessagesList.tsx\n```diff\n@@ -1,9 +1,9 @@\n ┊1┊1┊import moment from 'moment';\n ┊2┊2┊import React from 'react';\n ┊3┊3┊import { useEffect, useRef } from 'react';\n-┊4┊ ┊import ReactDOM from 'react-dom';\n ┊5┊4┊import styled, { css } from 'styled-components';\n ┊6┊5┊import { useInfiniteScroll } from '../../hooks/use-infinite-scroll';\n+┊ ┊6┊import { useAdjustedScroll } from '../../hooks/use-adjusted-scroll';\n ┊7┊7┊\n ┊8┊8┊const Container = styled.div`\n ┊9┊9┊  position: relative;\n```\n```diff\n@@ -117,17 +117,19 @@\n ┊117┊117┊    hasMore,\n ┊118┊118┊    ref: selfRef!,\n ┊119┊119┊  });\n+┊   ┊120┊  const adjustScroll = useAdjustedScroll(selfRef);\n ┊120┊121┊\n ┊121┊122┊  useEffect(() => {\n ┊122┊123┊    if (!selfRef.current) return;\n ┊123┊124┊\n ┊124┊125┊    if (fetching) {\n ┊125┊126┊      stopFetching();\n+┊   ┊127┊      adjustScroll();\n+┊   ┊128┊    } else {\n+┊   ┊129┊      // scroll to the most recent message\n+┊   ┊130┊      adjustScroll(true);\n ┊126┊131┊    }\n-┊127┊   ┊\n-┊128┊   ┊    const selfDOMNode = ReactDOM.findDOMNode(selfRef.current) as HTMLElement;\n-┊129┊   ┊    selfDOMNode.scrollTop = Number.MAX_SAFE_INTEGER;\n-┊130┊   ┊  }, [messages.length, selfRef, fetching, stopFetching]);\n+┊   ┊132┊  }, [messages.length, selfRef, fetching, stopFetching, adjustScroll]);\n ┊131┊133┊\n ┊132┊134┊  return (\n ┊133┊135┊    <Container ref={selfRef}>\n```\n\n##### Added src&#x2F;hooks&#x2F;use-adjusted-scroll.ts\n```diff\n@@ -0,0 +1,35 @@\n+┊  ┊ 1┊import { useState, useCallback, RefObject } from 'react';\n+┊  ┊ 2┊import * as ReactDOM from 'react-dom';\n+┊  ┊ 3┊\n+┊  ┊ 4┊export const useAdjustedScroll = (ref: RefObject<HTMLElement>) => {\n+┊  ┊ 5┊  const [previousScroll, setPreviousScroll] = useState<{\n+┊  ┊ 6┊    top: number;\n+┊  ┊ 7┊    height: number;\n+┊  ┊ 8┊  }>();\n+┊  ┊ 9┊\n+┊  ┊10┊  /**\n+┊  ┊11┊   * Scrolls to the previous position or completely to bottom (on demand)\n+┊  ┊12┊   */\n+┊  ┊13┊  const adjust = useCallback(\n+┊  ┊14┊    (scrollToBottom?: boolean) => {\n+┊  ┊15┊      if (!ref.current) return;\n+┊  ┊16┊\n+┊  ┊17┊      const node = ReactDOM.findDOMNode(ref.current) as HTMLElement;\n+┊  ┊18┊      const height =\n+┊  ┊19┊        !scrollToBottom && previousScroll\n+┊  ┊20┊          ? previousScroll.height\n+┊  ┊21┊          : node.clientHeight;\n+┊  ┊22┊\n+┊  ┊23┊      node.scrollTop = node.scrollHeight - height;\n+┊  ┊24┊\n+┊  ┊25┊      // saves current scroll details\n+┊  ┊26┊      setPreviousScroll({\n+┊  ┊27┊        top: node.scrollTop,\n+┊  ┊28┊        height: node.scrollHeight,\n+┊  ┊29┊      });\n+┊  ┊30┊    },\n+┊  ┊31┊    [ref, previousScroll]\n+┊  ┊32┊  );\n+┊  ┊33┊\n+┊  ┊34┊  return adjust;\n+┊  ┊35┊};\n```\n\n[}]: #\n\nWe also added some extra functionality there. Because we don't want to scroll to bottom when a new message is added, the function returned by `useAdjustedScroll` accepts now an argument.\n\nWe did the `MessagesList`, now let's move onto real data and the `ChatRoom` component.\n\n[{]: <helper> (diffStep \"15.12\" module=\"client\")\n\n#### [__Client__ Step 15.12: Implement pagination in ChatRoom component](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/71159c0)\n\n##### Changed src&#x2F;components&#x2F;ChatRoomScreen&#x2F;index.tsx\n```diff\n@@ -109,7 +109,7 @@\n ┊109┊109┊}\n ┊110┊110┊\n ┊111┊111┊const ChatRoom: React.FC<ChatRoomScreenParams> = ({ history, chatId }) => {\n-┊112┊   ┊  const { after, limit } = usePagination();\n+┊   ┊112┊  const { after, limit, setAfter } = usePagination();\n ┊113┊113┊  const { data, loading } = useGetChatQuery({\n ┊114┊114┊    variables: { chatId, after, limit },\n ┊115┊115┊  });\n```\n```diff\n@@ -150,6 +150,14 @@\n ┊150┊150┊    [data, chatId, addMessage]\n ┊151┊151┊  );\n ┊152┊152┊\n+┊   ┊153┊  useEffect(() => {\n+┊   ┊154┊    if (!after) {\n+┊   ┊155┊      return;\n+┊   ┊156┊    }\n+┊   ┊157┊\n+┊   ┊158┊    // every time after changes its value, fetch more messages\n+┊   ┊159┊  }, [after]);\n+┊   ┊160┊\n ┊153┊161┊  if (data === undefined) {\n ┊154┊162┊    return null;\n ┊155┊163┊  }\n```\n```diff\n@@ -167,7 +175,13 @@\n ┊167┊175┊  return (\n ┊168┊176┊    <Container>\n ┊169┊177┊      <ChatNavbar chat={chat} history={history} />\n-┊170┊   ┊      {chat.messages && <MessagesList messages={chat.messages} />}\n+┊   ┊178┊      {chat.messages && (\n+┊   ┊179┊        <MessagesList\n+┊   ┊180┊          messages={chat.messages.messages}\n+┊   ┊181┊          hasMore={chat.messages.hasMore}\n+┊   ┊182┊          loadMore={() => setAfter(chat.messages.cursor!)}\n+┊   ┊183┊        />\n+┊   ┊184┊      )}\n ┊171┊185┊      <MessageInput onSendMessage={onSendMessage} />\n ┊172┊186┊    </Container>\n ┊173┊187┊  );\n```\n\n[}]: #\n\nAs you see above, every time the `MessagesList` asks for more messages, the `after` changes its value to `chat.messages.cursor` which means that's a new \"end\" of the list and we need to fill it up.\n\nRight now we just have a logic and a place to do it but we still need to make a GraphQL call.\n\nFortunately, Apollo lets you do pagination with a method called `fetchMore`. You need to specify what query and variables to use for the update, and how to merge the new query result with the existing data on the client. How exactly you do that will determine what kind of pagination you are implementing, in our case it's cursor-based.\n\nBut there's a catch!\n\nIt's related to how Apollo stores query results in cache. When we update the variables, in our case it's the `after` that changes quite a lot, a new record is created that is totally unrelated to the original query. That's because Apollo uses a combination of variables and query string to produce a key.\n\nAn example:\n\n\n```graphql\n{\n  query getUser($id: ID!) {\n    user(id: $id) {\n      name\n    }\n  }\n}\n```\n\nThe result of `getUser` query will be saved under `user({\"id\":2})` key.\n\nThis is a huge problem, it breaks imperative store updates but that's why `@connection` directive exists. It directs Apollo to use a stable store key for paginated queries, so every `useQuery()` or `fetchMore()` is being placed in the same space.\n\nWith all that knowledge, let's implement the last puzzle piece!\n\n[{]: <helper> (diffStep \"15.13\" module=\"client\")\n\n#### [__Client__ Step 15.13: Use fetchMore to load more messages](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/83cc92a)\n\n##### Changed src&#x2F;components&#x2F;ChatRoomScreen&#x2F;index.tsx\n```diff\n@@ -110,7 +110,7 @@\n ┊110┊110┊\n ┊111┊111┊const ChatRoom: React.FC<ChatRoomScreenParams> = ({ history, chatId }) => {\n ┊112┊112┊  const { after, limit, setAfter } = usePagination();\n-┊113┊   ┊  const { data, loading } = useGetChatQuery({\n+┊   ┊113┊  const { data, loading, fetchMore } = useGetChatQuery({\n ┊114┊114┊    variables: { chatId, after, limit },\n ┊115┊115┊  });\n ┊116┊116┊\n```\n```diff\n@@ -156,7 +156,30 @@\n ┊156┊156┊    }\n ┊157┊157┊\n ┊158┊158┊    // every time after changes its value, fetch more messages\n-┊159┊   ┊  }, [after]);\n+┊   ┊159┊    fetchMore({\n+┊   ┊160┊      variables: {\n+┊   ┊161┊        after,\n+┊   ┊162┊        limit,\n+┊   ┊163┊      },\n+┊   ┊164┊      updateQuery(prev, { fetchMoreResult }) {\n+┊   ┊165┊        const messages = [\n+┊   ┊166┊          ...fetchMoreResult!.chat!.messages.messages,\n+┊   ┊167┊          ...prev.chat!.messages.messages,\n+┊   ┊168┊        ];\n+┊   ┊169┊\n+┊   ┊170┊        return {\n+┊   ┊171┊          ...prev,\n+┊   ┊172┊          chat: {\n+┊   ┊173┊            ...prev.chat!,\n+┊   ┊174┊            messages: {\n+┊   ┊175┊              ...fetchMoreResult!.chat!.messages,\n+┊   ┊176┊              messages,\n+┊   ┊177┊            },\n+┊   ┊178┊          },\n+┊   ┊179┊        };\n+┊   ┊180┊      },\n+┊   ┊181┊    });\n+┊   ┊182┊  }, [after, limit, fetchMore]);\n ┊160┊183┊\n ┊161┊184┊  if (data === undefined) {\n ┊162┊185┊    return null;\n```\n\n[}]: #\n\nAs you see, we mutate the store as usual and we put fetched messages before the existing ones. Remember, it's from older to newer.\n\n### Looking at the bundle size\n\nWe can't of course forget about one of the most important aspects of optimization, the size of the application. As bundle size increases, both the parsing time and the time of the request takes longer.\n\nHow can we check what libraries and source files are shipped within the produced bundle?\n\nThere are many tools that analyze it for us but we're going to use only one of them, just for educational purpose.\n\n      $ yarn add -D source-map-explorer\n\nWe're going to add the `size` npm script in which we point the `source-map-explorer` to transpiled js files.\n\n[{]: <helper> (diffStep \"15.14\" module=\"client\")\n\n#### [__Client__ Step 15.14: Explore bundle size](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/50970cd)\n\n##### Changed package.json\n```diff\n@@ -52,7 +52,8 @@\n ┊52┊52┊    \"test\": \"TZ=\\\"Asia/Jerusalem\\\" react-scripts test\",\n ┊53┊53┊    \"eject\": \"react-scripts eject\",\n ┊54┊54┊    \"codegen\": \"gql-gen\",\n-┊55┊  ┊    \"format\": \"prettier '**/*.{ts,tsx,css,graphql}' --write\"\n+┊  ┊55┊    \"format\": \"prettier '**/*.{ts,tsx,css,graphql}' --write\",\n+┊  ┊56┊    \"size\": \"source-map-explorer 'build/static/js/*.js'\"\n ┊56┊57┊  },\n ┊57┊58┊  \"eslintConfig\": {\n ┊58┊59┊    \"extends\": \"react-app\"\n```\n```diff\n@@ -72,6 +73,7 @@\n ┊72┊73┊  \"devDependencies\": {\n ┊73┊74┊    \"jest-dom\": \"3.4.0\",\n ┊74┊75┊    \"jest-fetch-mock\": \"2.1.2\",\n-┊75┊  ┊    \"@testing-library/react\": \"8.0.1\"\n+┊  ┊76┊    \"@testing-library/react\": \"8.0.1\",\n+┊  ┊77┊    \"source-map-explorer\": \"2.0.0\"\n ┊76┊78┊  }\n ┊77┊79┊}🚫↵\n```\n\n[}]: #\n\nLet's see it in action, run:\n\n    $ yarn build && yarn size\n\nThat's what you should see:\n\n![Source Map Explorer](../../../assets/step17/img-10.png \"Source Map Explorer\")\n\nIt's interactive so you can dive deeper and deeper into those blocks but in general it shows what libraries and files are included in the produced output with their size(not minified and not gzipped).\n\n![Source Map Explorer](../../../assets/step17/img-11.png \"Source Map Explorer with moment highlighted\")\n\nFor example, we see that `moment` takes almost _53.49KB_ which is enourmous. In fact we only use its `format` method. The reason is that the library is not well tree-shakable. There are plugins for webpack (or any other build tool) that helps with it but we're going to use an alternative instead. We're going to replace it with `date-fns`.\n\n[{]: <helper> (diffStep \"15.15\" module=\"client\")\n\n#### [__Client__ Step 15.15: Replace moment with date-fns](https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/21d54e9)\n\n##### Changed package.json\n```diff\n@@ -30,9 +30,9 @@\n ┊30┊30┊    \"graphql\": \"14.3.1\",\n ┊31┊31┊    \"apollo-link-ws\": \"1.0.17\",\n ┊32┊32┊    \"apollo-utilities\": \"1.3.2\",\n+┊  ┊33┊    \"date-fns\": \"1.30.1\",\n ┊33┊34┊    \"graphql-tag\": \"2.10.1\",\n ┊34┊35┊    \"history\": \"4.9.0\",\n-┊35┊  ┊    \"moment\": \"2.24.0\",\n ┊36┊36┊    \"prettier\": \"1.18.2\",\n ┊37┊37┊    \"react\": \"16.8.6\",\n ┊38┊38┊    \"react-apollo\": \"2.5.6\",\n```\n\n##### Changed src&#x2F;components&#x2F;ChatRoomScreen&#x2F;MessagesList.tsx\n```diff\n@@ -1,4 +1,4 @@\n-┊1┊ ┊import moment from 'moment';\n+┊ ┊1┊import format from 'date-fns/format';\n ┊2┊2┊import React from 'react';\n ┊3┊3┊import { useEffect, useRef } from 'react';\n ┊4┊4┊import styled, { css } from 'styled-components';\n```\n```diff\n@@ -141,7 +141,7 @@\n ┊141┊141┊          key={message.id}>\n ┊142┊142┊          <Contents data-testid=\"message-content\">{message.content}</Contents>\n ┊143┊143┊          <Timestamp data-testid=\"message-date\">\n-┊144┊   ┊            {moment(message.createdAt).format('HH:mm')}\n+┊   ┊144┊            {format(message.createdAt, 'HH:mm')}\n ┊145┊145┊          </Timestamp>\n ┊146┊146┊        </MessageItem>\n ┊147┊147┊      ))}\n```\n\n##### Changed src&#x2F;components&#x2F;ChatsListScreen&#x2F;ChatsList.tsx\n```diff\n@@ -1,5 +1,5 @@\n ┊1┊1┊import React from 'react';\n-┊2┊ ┊import moment from 'moment';\n+┊ ┊2┊import format from 'date-fns/format';\n ┊3┊3┊import { List, ListItem } from '@material-ui/core';\n ┊4┊4┊import styled from 'styled-components';\n ┊5┊5┊import { useCallback } from 'react';\n```\n```diff\n@@ -105,7 +105,7 @@\n ┊105┊105┊                    {chat.lastMessage.content}\n ┊106┊106┊                  </MessageContent>\n ┊107┊107┊                  <MessageDate data-testid=\"date\">\n-┊108┊   ┊                    {moment(chat.lastMessage.createdAt).format('HH:mm')}\n+┊   ┊108┊                    {format(chat.lastMessage.createdAt, 'HH:mm')}\n ┊109┊109┊                  </MessageDate>\n ┊110┊110┊                </React.Fragment>\n ┊111┊111┊              )}\n```\n\n[}]: #\n\nNow when you run:\n\n    $ yarn build && yarn size\n\nYou should see the following results.\n\n![Source Map Explorer](../../../assets/step17/img-12.png \"Source Map Explorer with date-fns\")\n\nThe bundle size is a bit smaller and `date-fns` takes only _8.93KB_ which in comparison to _53.49KB_ is a significant change!\n\n## Load testing\n\nLoad testing, in short, is about finding the limit of an application and figure out how to push it even more. We simulate a stressful behavior and apply that to the server until it crashes. We’re trying to answer the question of how the api deals with a pressure.\n\nWhen to do load testing?\nI would say at least before and after major changes, when pre-launching and just from time to time to prevent regressions.\n\nBefore doing load testing, we need to prepare a bit first. Right now we use `ts-node` to run the server but it would be faster to run it directly using `node`, just to avoid on-the-fly transpilation of TypeScript files.\n\nIn order to do it, we need to define the `outDir` in `tsconfig.json` and add a build step.\n\n[{]: <helper> (diffStep \"14.12\" module=\"server\")\n\n#### [__Server__ Step 14.12: Produce transpiled code](https://github.com/Urigo/WhatsApp-Clone-Server/commit/c0f6b6d)\n\n##### Changed .circleci&#x2F;config.yml\n```diff\n@@ -18,6 +18,9 @@\n ┊18┊18┊      - run:\n ┊19┊19┊          name: Install Dependencies\n ┊20┊20┊          command: yarn\n+┊  ┊21┊      - run:\n+┊  ┊22┊          name: Build\n+┊  ┊23┊          command: yarn build\n ┊21┊24┊      - run:\n ┊22┊25┊          name: Test\n ┊23┊26┊          command: yarn test\n```\n\n##### Changed .gitignore\n```diff\n@@ -1,3 +1,4 @@\n+┊ ┊1┊dist\n ┊1┊2┊node_modules\n ┊2┊3┊npm-debug.log\n ┊3┊4┊test-results/\n```\n\n##### Changed package.json\n```diff\n@@ -9,6 +9,8 @@\n ┊ 9┊ 9┊  \"scripts\": {\n ┊10┊10┊    \"prestart\": \"yarn codegen\",\n ┊11┊11┊    \"start\": \"ts-node index.ts\",\n+┊  ┊12┊    \"prebuild\": \"yarn codegen\",\n+┊  ┊13┊    \"build\": \"tsc\",\n ┊12┊14┊    \"test\": \"TZ=\\\"Asia/Jerusalem\\\" jest --runInBand --forceExit\",\n ┊13┊15┊    \"codegen\": \"gql-gen\",\n ┊14┊16┊    \"format\": \"prettier '**/*.ts' --write\"\n```\n\n##### Changed tsconfig.json\n```diff\n@@ -1,5 +1,6 @@\n ┊1┊1┊{\n ┊2┊2┊  \"compilerOptions\": {\n+┊ ┊3┊    \"outDir\": \"dist\",\n ┊3┊4┊    \"target\": \"es2018\",\n ┊4┊5┊    \"module\": \"commonjs\",\n ┊5┊6┊    \"lib\": [\n```\n\n[}]: #\n\nNext, the script to actually run the server:\n\n[{]: <helper> (diffStep \"14.13\" files=\"package.json\" module=\"server\")\n\n#### [__Server__ Step 14.13: Prepare for production](https://github.com/Urigo/WhatsApp-Clone-Server/commit/06b58e1)\n\n##### Changed package.json\n```diff\n@@ -10,6 +10,7 @@\n ┊10┊10┊    \"prestart\": \"yarn codegen\",\n ┊11┊11┊    \"start\": \"ts-node index.ts\",\n ┊12┊12┊    \"prebuild\": \"yarn codegen\",\n+┊  ┊13┊    \"prod\": \"node dist/index.js\",\n ┊13┊14┊    \"build\": \"tsc\",\n ┊14┊15┊    \"test\": \"TZ=\\\"Asia/Jerusalem\\\" jest --runInBand --forceExit\",\n ┊15┊16┊    \"codegen\": \"gql-gen\",\n```\n\n[}]: #\n\nOnce it’s ready, we can move on to tooling.\n\n### Artillery\n\nArtillery is an open-source load testing and functional testing toolkit. It’s API is vast but we will focus on the core part of it which is relevant to this chapter. Artillery is available as a npm package:\n\n    $ yarn add -D artillery\n\nThe only step to use Artillery is to set it up. We will create the `artillery.yml` file, like this:\n\n[{]: <helper> (diffStep \"14.15\" module=\"server\")\n\n#### [__Server__ Step 14.15: Add artillery config](https://github.com/Urigo/WhatsApp-Clone-Server/commit/4376904)\n\n##### Added artillery.yml\n```diff\n@@ -0,0 +1,72 @@\n+┊  ┊ 1┊config:\n+┊  ┊ 2┊  target: 'http://localhost:4000/graphql'\n+┊  ┊ 3┊  phases:\n+┊  ┊ 4┊    - duration: 120\n+┊  ┊ 5┊      arrivalRate: 5\n+┊  ┊ 6┊      rampTo: 20\n+┊  ┊ 7┊scenarios:\n+┊  ┊ 8┊  - name: 'Sign in, send a new message and fetch a list of chats'\n+┊  ┊ 9┊    flow:\n+┊  ┊10┊      - post:\n+┊  ┊11┊          url: '/'\n+┊  ┊12┊          json:\n+┊  ┊13┊            variables:\n+┊  ┊14┊              username: 'ray'\n+┊  ┊15┊              password: '111'\n+┊  ┊16┊            query: |\n+┊  ┊17┊              mutation SignIn($username: String!, $password: String!) {\n+┊  ┊18┊                signIn(username: $username, password: $password) {\n+┊  ┊19┊                  id\n+┊  ┊20┊                }\n+┊  ┊21┊              }\n+┊  ┊22┊      - post:\n+┊  ┊23┊          url: '/'\n+┊  ┊24┊          json:\n+┊  ┊25┊            query: |\n+┊  ┊26┊              mutation message {\n+┊  ┊27┊                addMessage(chatId: \"1\", content: \"artillery\") {\n+┊  ┊28┊                  id\n+┊  ┊29┊                }\n+┊  ┊30┊              }\n+┊  ┊31┊      - post:\n+┊  ┊32┊          url: '/'\n+┊  ┊33┊          json:\n+┊  ┊34┊            variables:\n+┊  ┊35┊              limit: 20\n+┊  ┊36┊            query: |\n+┊  ┊37┊              fragment User on User {\n+┊  ┊38┊                id\n+┊  ┊39┊                name\n+┊  ┊40┊                picture\n+┊  ┊41┊              }\n+┊  ┊42┊              fragment Message on Message {\n+┊  ┊43┊                id\n+┊  ┊44┊                content\n+┊  ┊45┊                chat {\n+┊  ┊46┊                  id\n+┊  ┊47┊                }\n+┊  ┊48┊                sender {\n+┊  ┊49┊                  ...User\n+┊  ┊50┊                }\n+┊  ┊51┊                recipient {\n+┊  ┊52┊                  ...User\n+┊  ┊53┊                }\n+┊  ┊54┊              }\n+┊  ┊55┊              query GetChats($limit: Int!) {\n+┊  ┊56┊                chats {\n+┊  ┊57┊                  id\n+┊  ┊58┊                  name\n+┊  ┊59┊                  picture\n+┊  ┊60┊                  lastMessage {\n+┊  ┊61┊                    ...Message\n+┊  ┊62┊                  }\n+┊  ┊63┊                  messages(limit: $limit) {\n+┊  ┊64┊                    messages {\n+┊  ┊65┊                      ...Message\n+┊  ┊66┊                    }\n+┊  ┊67┊                  }\n+┊  ┊68┊                  participants {\n+┊  ┊69┊                    ...User\n+┊  ┊70┊                  }\n+┊  ┊71┊                }\n+┊  ┊72┊              }\n```\n\n[}]: #\n\nAs you can see, the config file is built of two sections. First one is named `config` and it defines what’s our target and how the traffic should look like. We used one phase but it could have many. The `duration` parameter is to define how long the phase should take. The `arrivalRate` defines how many virtual users per second are going to hit the target and the `rampTo` directs Artillery to increase this number up to 20, at the middle of the phase.\n\nThe next section, called `scenarios`, is all about the actual requests. In our case, we want to authenticate user, submit a new message and fetch an entire list of chats with their messages at the end. Artillery shares cookies between request of the same virtual user, keep that on mind.\n\nWe used Ray as the user and fairly similar operations to what the client app sends. That should closely represent the actual usage of the API.\n\nEverything is fine with that config but we need to find the limit, to push even more. That's why we'll also add a second config with a bit more heavier traffic, something to simulate the more real life environment. It's pretty much the same setup except phases. First, we \"warms up\" the server for 2 minutes, same amount of times goes next with double the traffic, then we keep it for 5 minutes. At the end, we want to crash the server so we send nearly 100 virtual users per second for an entire minute. This way we know when it cracks.\n\n[{]: <helper> (diffStep \"14.16\" module=\"server\")\n\n#### [__Server__ Step 14.16: Artillery config to find a limit](https://github.com/Urigo/WhatsApp-Clone-Server/commit/edc44d9)\n\n##### Added artillery-limit.yml\n```diff\n@@ -0,0 +1,77 @@\n+┊  ┊ 1┊config:\n+┊  ┊ 2┊  target: 'http://localhost:4000/graphql'\n+┊  ┊ 3┊  phases:\n+┊  ┊ 4┊    - duration: 120\n+┊  ┊ 5┊      arrivalRate: 5\n+┊  ┊ 6┊    - duration: 120\n+┊  ┊ 7┊      arrivalRate: 10\n+┊  ┊ 8┊    - duration: 300\n+┊  ┊ 9┊      arrivalRate: 10\n+┊  ┊10┊    - duration: 60\n+┊  ┊11┊      arrivalRate: 100\n+┊  ┊12┊scenarios:\n+┊  ┊13┊  - name: 'Sign in, send a new message and fetch a list of chats'\n+┊  ┊14┊    flow:\n+┊  ┊15┊      - post:\n+┊  ┊16┊          url: '/'\n+┊  ┊17┊          json:\n+┊  ┊18┊            variables:\n+┊  ┊19┊              username: 'ray'\n+┊  ┊20┊              password: '111'\n+┊  ┊21┊            query: |\n+┊  ┊22┊              mutation SignIn($username: String!, $password: String!) {\n+┊  ┊23┊                signIn(username: $username, password: $password) {\n+┊  ┊24┊                  id\n+┊  ┊25┊                }\n+┊  ┊26┊              }\n+┊  ┊27┊      - post:\n+┊  ┊28┊          url: '/'\n+┊  ┊29┊          json:\n+┊  ┊30┊            query: |\n+┊  ┊31┊              mutation message {\n+┊  ┊32┊                addMessage(chatId: \"1\", content: \"artillery\") {\n+┊  ┊33┊                  id\n+┊  ┊34┊                }\n+┊  ┊35┊              }\n+┊  ┊36┊      - post:\n+┊  ┊37┊          url: '/'\n+┊  ┊38┊          json:\n+┊  ┊39┊            variables:\n+┊  ┊40┊              limit: 20\n+┊  ┊41┊            query: |\n+┊  ┊42┊              fragment User on User {\n+┊  ┊43┊                id\n+┊  ┊44┊                name\n+┊  ┊45┊                picture\n+┊  ┊46┊              }\n+┊  ┊47┊              fragment Message on Message {\n+┊  ┊48┊                id\n+┊  ┊49┊                content\n+┊  ┊50┊                chat {\n+┊  ┊51┊                  id\n+┊  ┊52┊                }\n+┊  ┊53┊                sender {\n+┊  ┊54┊                  ...User\n+┊  ┊55┊                }\n+┊  ┊56┊                recipient {\n+┊  ┊57┊                  ...User\n+┊  ┊58┊                }\n+┊  ┊59┊              }\n+┊  ┊60┊              query GetChats($limit: Int!) {\n+┊  ┊61┊                chats {\n+┊  ┊62┊                  id\n+┊  ┊63┊                  name\n+┊  ┊64┊                  picture\n+┊  ┊65┊                  lastMessage {\n+┊  ┊66┊                    ...Message\n+┊  ┊67┊                  }\n+┊  ┊68┊                  messages(limit: $limit) {\n+┊  ┊69┊                    messages {\n+┊  ┊70┊                      ...Message\n+┊  ┊71┊                    }\n+┊  ┊72┊                  }\n+┊  ┊73┊                  participants {\n+┊  ┊74┊                    ...User\n+┊  ┊75┊                  }\n+┊  ┊76┊                }\n+┊  ┊77┊              }🚫↵\n```\n\n[}]: #\n\nOnce everything is ready, let's add npm scripts, one for a normal traffic and a second with the much more users:\n\n[{]: <helper> (diffStep \"14.17\" module=\"server\")\n\n#### [__Server__ Step 14.17: Add loadtest scripts](https://github.com/Urigo/WhatsApp-Clone-Server/commit/761945b)\n\n##### Changed package.json\n```diff\n@@ -14,7 +14,9 @@\n ┊14┊14┊    \"build\": \"tsc\",\n ┊15┊15┊    \"test\": \"TZ=\\\"Asia/Jerusalem\\\" jest --runInBand --forceExit\",\n ┊16┊16┊    \"codegen\": \"gql-gen\",\n-┊17┊  ┊    \"format\": \"prettier '**/*.ts' --write\"\n+┊  ┊17┊    \"format\": \"prettier '**/*.ts' --write\",\n+┊  ┊18┊    \"loadtest\": \"yarn artillery run artillery.yml > loadtest.log\",\n+┊  ┊19┊    \"loadtest:limit\": \"yarn artillery run artillery-limit.yml > loadtest.log\"\n ┊18┊20┊  },\n ┊19┊21┊  \"jest-junit\": {\n ┊20┊22┊    \"outputDirectory\": \"./test-results\"\n```\n\n[}]: #\n\nYou probably noticed that we stream the output to the `loadtest.log` file and that's just to read the results in a bit more pleasent way, than in the terminal.\n\nLet’s start the server and run artillery:\n\n    $ yarn build && yarn start\n    $ yarn loadtest\n\nYou’ll see a loading indicator, might take a while but when it completes, you should see something like this in `loadtest.log` file:\n\n```\nSummary report @ 15:00:58(+0200) 2019-05-30\n  Scenarios launched:  1506\n  Scenarios completed: 1506\n  Requests completed:  4518\n  RPS sent: 37.35\n  Request latency:\n    min: 3.5\n    max: 115.7\n    median: 18.6\n    p95: 54.4\n    p99: 66.2\n  Scenario counts:\n    Sign in, send a new message and fetch a list of chats: 1506 (100%)\n  Codes:\n    200: 4518\n```\n\nWe ran the scenario 1506 times, all were completed and the total number of requests was 4518.  The **RPS** means requests per second.\n\nThe metrics in **Request latency** are in milliseconds. We see what was the shortest request and so on. These **p95** and **p99** values mean that for 95% of virtual users, the latency was 54.4ms or lower, for 99% it was 66.2ms. All requests finished with 200 status code.\n\nYou might also automate that process and integrate Artillery CLI with CI/CI systems or even send metrics to external monitoring systems.\n\n### Apollo Engine\n\nLet's bring back the Apollo Engine once again. It will be helpful to analyze the load testing results.\n\nOn the **Metrics** page, you will see the following view:\n\n![Metrics](../../../assets/step17/img-13.png \"Metrics\")\n\nClick on the filter and set a custom date range to match the time you were load testing. Just to filter out other requests.\n\n![Filter](../../../assets/step17/img-14.png \"Filter\")\n\nBy default, Apollo Engine counts all operations, but you can pick the one you’re interesting in. We don’t do it and inspect them all.\n\n![List](../../../assets/step17/img-15.png \"List of operations\")\n\nOn the main part of the view, you should see “Last day overview” panel.\n\n![Overview](../../../assets/step17/img-16.png \"Last day overview\")\n\nAs you can see, all operations we ran are listed there and no error occurred.\n\n![Request Rate](../../../assets/step17/img-17.png \"Request Rate Over Time\")\n\nNext section shows the Requests Per Minute (rpm) metric over time. It’s useful to understand which operations are sent more often than others.\n\n![Request 1](../../../assets/step17/img-18.png \"Request Latency Over time\")\n![Request 2](../../../assets/step17/img-19.png \"Request Latency Distribution\")\n\nLast two panels are there to understand at what number of requests the latency increases and to show the correlation between them. We see a distribution of the processing time (the horizontal axis) and the number of operations. It also has p50, p75, p90 and p99 marks on it."
          }
        ]
      }
    ]
  }
]
